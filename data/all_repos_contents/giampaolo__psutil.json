{"setup.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Cross-platform lib for process and system monitoring in Python.\"\"\"\n\nfrom __future__ import print_function\n\nimport ast\nimport contextlib\nimport glob\nimport io\nimport os\nimport platform\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nimport tempfile\nimport warnings\n\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    try:\n        import setuptools\n        from setuptools import Extension\n        from setuptools import setup\n    except ImportError:\n        setuptools = None\n        from distutils.core import Extension\n        from distutils.core import setup\n    try:\n        from wheel.bdist_wheel import bdist_wheel\n    except ImportError:\n        if \"CIBUILDWHEEL\" in os.environ:\n            raise\n        bdist_wheel = None\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\n# ...so we can import _common.py and _compat.py\nsys.path.insert(0, os.path.join(HERE, \"psutil\"))\n\nfrom _common import AIX  # NOQA\nfrom _common import BSD  # NOQA\nfrom _common import FREEBSD  # NOQA\nfrom _common import LINUX  # NOQA\nfrom _common import MACOS  # NOQA\nfrom _common import NETBSD  # NOQA\nfrom _common import OPENBSD  # NOQA\nfrom _common import POSIX  # NOQA\nfrom _common import SUNOS  # NOQA\nfrom _common import WINDOWS  # NOQA\nfrom _common import hilite  # NOQA\nfrom _compat import PY3  # NOQA\nfrom _compat import which  # NOQA\n\n\nPYPY = '__pypy__' in sys.builtin_module_names\nPY36_PLUS = sys.version_info[:2] >= (3, 6)\nPY37_PLUS = sys.version_info[:2] >= (3, 7)\nCP36_PLUS = PY36_PLUS and sys.implementation.name == \"cpython\"\nCP37_PLUS = PY37_PLUS and sys.implementation.name == \"cpython\"\nPy_GIL_DISABLED = sysconfig.get_config_var(\"Py_GIL_DISABLED\")\n\nmacros = []\nif POSIX:\n    macros.append((\"PSUTIL_POSIX\", 1))\nif BSD:\n    macros.append((\"PSUTIL_BSD\", 1))\n\n# Needed to determine _Py_PARSE_PID in case it's missing (Python 2, PyPy).\n# Taken from Lib/test/test_fcntl.py.\n# XXX: not bullet proof as the (long long) case is missing.\nif struct.calcsize('l') <= 8:\n    macros.append(('PSUTIL_SIZEOF_PID_T', '4'))  # int\nelse:\n    macros.append(('PSUTIL_SIZEOF_PID_T', '8'))  # long\n\n\nsources = ['psutil/_psutil_common.c']\nif POSIX:\n    sources.append('psutil/_psutil_posix.c')\n\n\nextras_require = {\n    \"test\": [\n        \"enum34; python_version <= '3.4'\",\n        \"ipaddress; python_version < '3.0'\",\n        \"mock; python_version < '3.0'\",\n    ]\n}\nif not PYPY:\n    extras_require['test'].extend(\n        [\"pywin32; sys.platform == 'win32'\", \"wmi; sys.platform == 'win32'\"]\n    )\n\n\ndef get_version():\n    INIT = os.path.join(HERE, 'psutil/__init__.py')\n    with open(INIT) as f:\n        for line in f:\n            if line.startswith('__version__'):\n                ret = ast.literal_eval(line.strip().split(' = ')[1])\n                assert ret.count('.') == 2, ret\n                for num in ret.split('.'):\n                    assert num.isdigit(), ret\n                return ret\n        msg = \"couldn't find version string\"\n        raise ValueError(msg)\n\n\nVERSION = get_version()\nmacros.append(('PSUTIL_VERSION', int(VERSION.replace('.', ''))))\n\n# Py_LIMITED_API lets us create a single wheel which works with multiple\n# python versions, including unreleased ones.\nif bdist_wheel and CP36_PLUS and (MACOS or LINUX) and not Py_GIL_DISABLED:\n    py_limited_api = {\"py_limited_api\": True}\n    macros.append(('Py_LIMITED_API', '0x03060000'))\nelif bdist_wheel and CP37_PLUS and WINDOWS and not Py_GIL_DISABLED:\n    # PyErr_SetFromWindowsErr / PyErr_SetFromWindowsErrWithFilename are\n    # part of the stable API/ABI starting with CPython 3.7\n    py_limited_api = {\"py_limited_api\": True}\n    macros.append(('Py_LIMITED_API', '0x03070000'))\nelse:\n    py_limited_api = {}\n\n\ndef get_long_description():\n    script = os.path.join(HERE, \"scripts\", \"internal\", \"convert_readme.py\")\n    readme = os.path.join(HERE, 'README.rst')\n    p = subprocess.Popen(\n        [sys.executable, script, readme],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    return stdout\n\n\n@contextlib.contextmanager\ndef silenced_output(stream_name):\n    class DummyFile(io.BytesIO):\n        # see: https://github.com/giampaolo/psutil/issues/678\n        errors = \"ignore\"\n\n        def write(self, s):\n            pass\n\n    orig = getattr(sys, stream_name)\n    try:\n        setattr(sys, stream_name, DummyFile())\n        yield\n    finally:\n        setattr(sys, stream_name, orig)\n\n\ndef missdeps(cmdline):\n    s = \"psutil could not be installed from sources\"\n    if not SUNOS and not which(\"gcc\"):\n        s += \" because gcc is not installed. \"\n    else:\n        s += \". Perhaps Python header files are not installed. \"\n    s += \"Try running:\\n\"\n    s += \"  %s\" % cmdline\n    print(hilite(s, color=\"red\", bold=True), file=sys.stderr)\n\n\ndef unix_can_compile(c_code):\n    from distutils.errors import CompileError\n    from distutils.unixccompiler import UnixCCompiler\n\n    with tempfile.NamedTemporaryFile(\n        suffix='.c', delete=False, mode=\"wt\"\n    ) as f:\n        f.write(c_code)\n\n    tempdir = tempfile.mkdtemp()\n    try:\n        compiler = UnixCCompiler()\n        # https://github.com/giampaolo/psutil/pull/1568\n        if os.getenv('CC'):\n            compiler.set_executable('compiler_so', os.getenv('CC'))\n        with silenced_output('stderr'):\n            with silenced_output('stdout'):\n                compiler.compile([f.name], output_dir=tempdir)\n    except CompileError:\n        return False\n    else:\n        return True\n    finally:\n        os.remove(f.name)\n        shutil.rmtree(tempdir)\n\n\nif WINDOWS:\n\n    def get_winver():\n        maj, min = sys.getwindowsversion()[0:2]\n        return '0x0%s' % ((maj * 100) + min)\n\n    if sys.getwindowsversion()[0] < 6:\n        msg = \"this Windows version is too old (< Windows Vista); \"\n        msg += \"psutil 3.4.2 is the latest version which supports Windows \"\n        msg += \"2000, XP and 2003 server\"\n        raise RuntimeError(msg)\n\n    macros.append((\"PSUTIL_WINDOWS\", 1))\n    macros.extend([\n        # be nice to mingw, see:\n        # http://www.mingw.org/wiki/Use_more_recent_defined_functions\n        ('_WIN32_WINNT', get_winver()),\n        ('_AVAIL_WINVER_', get_winver()),\n        ('_CRT_SECURE_NO_WARNINGS', None),\n        # see: https://github.com/giampaolo/psutil/issues/348\n        ('PSAPI_VERSION', 1),\n    ])\n\n    ext = Extension(\n        'psutil._psutil_windows',\n        sources=(\n            sources\n            + [\"psutil/_psutil_windows.c\"]\n            + glob.glob(\"psutil/arch/windows/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\n            \"psapi\",\n            \"kernel32\",\n            \"advapi32\",\n            \"shell32\",\n            \"netapi32\",\n            \"ws2_32\",\n            \"PowrProf\",\n            \"pdh\",\n        ],\n        # extra_compile_args=[\"/W 4\"],\n        # extra_link_args=[\"/DEBUG\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif MACOS:\n    macros.append((\"PSUTIL_OSX\", 1))\n    ext = Extension(\n        'psutil._psutil_osx',\n        sources=(\n            sources\n            + [\"psutil/_psutil_osx.c\"]\n            + glob.glob(\"psutil/arch/osx/*.c\")\n        ),\n        define_macros=macros,\n        extra_link_args=[\n            '-framework',\n            'CoreFoundation',\n            '-framework',\n            'IOKit',\n        ],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif FREEBSD:\n    macros.append((\"PSUTIL_FREEBSD\", 1))\n    ext = Extension(\n        'psutil._psutil_bsd',\n        sources=(\n            sources\n            + [\"psutil/_psutil_bsd.c\"]\n            + glob.glob(\"psutil/arch/bsd/*.c\")\n            + glob.glob(\"psutil/arch/freebsd/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\"devstat\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif OPENBSD:\n    macros.append((\"PSUTIL_OPENBSD\", 1))\n    ext = Extension(\n        'psutil._psutil_bsd',\n        sources=(\n            sources\n            + [\"psutil/_psutil_bsd.c\"]\n            + glob.glob(\"psutil/arch/bsd/*.c\")\n            + glob.glob(\"psutil/arch/openbsd/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\"kvm\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif NETBSD:\n    macros.append((\"PSUTIL_NETBSD\", 1))\n    ext = Extension(\n        'psutil._psutil_bsd',\n        sources=(\n            sources\n            + [\"psutil/_psutil_bsd.c\"]\n            + glob.glob(\"psutil/arch/bsd/*.c\")\n            + glob.glob(\"psutil/arch/netbsd/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\"kvm\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif LINUX:\n    # see: https://github.com/giampaolo/psutil/issues/659\n    if not unix_can_compile(\"#include <linux/ethtool.h>\"):\n        macros.append((\"PSUTIL_ETHTOOL_MISSING_TYPES\", 1))\n\n    macros.append((\"PSUTIL_LINUX\", 1))\n    ext = Extension(\n        'psutil._psutil_linux',\n        sources=(\n            sources\n            + [\"psutil/_psutil_linux.c\"]\n            + glob.glob(\"psutil/arch/linux/*.c\")\n        ),\n        define_macros=macros,\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif SUNOS:\n    macros.append((\"PSUTIL_SUNOS\", 1))\n    ext = Extension(\n        'psutil._psutil_sunos',\n        sources=sources\n        + [\n            'psutil/_psutil_sunos.c',\n            'psutil/arch/solaris/v10/ifaddrs.c',\n            'psutil/arch/solaris/environ.c',\n        ],\n        define_macros=macros,\n        libraries=['kstat', 'nsl', 'socket'],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif AIX:\n    macros.append((\"PSUTIL_AIX\", 1))\n    ext = Extension(\n        'psutil._psutil_aix',\n        sources=sources\n        + [\n            'psutil/_psutil_aix.c',\n            'psutil/arch/aix/net_connections.c',\n            'psutil/arch/aix/common.c',\n            'psutil/arch/aix/ifaddrs.c',\n        ],\n        libraries=['perfstat'],\n        define_macros=macros,\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelse:\n    sys.exit('platform %s is not supported' % sys.platform)\n\n\nif POSIX:\n    posix_extension = Extension(\n        'psutil._psutil_posix',\n        define_macros=macros,\n        sources=sources,\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n    if SUNOS:\n\n        def get_sunos_update():\n            # See https://serverfault.com/q/524883\n            # for an explanation of Solaris /etc/release\n            with open('/etc/release') as f:\n                update = re.search(r'(?<=s10s_u)[0-9]{1,2}', f.readline())\n                return int(update.group(0)) if update else 0\n\n        posix_extension.libraries.append('socket')\n        if platform.release() == '5.10':\n            # Detect Solaris 5.10, update >= 4, see:\n            # https://github.com/giampaolo/psutil/pull/1638\n            if get_sunos_update() >= 4:\n                # MIB compliance starts with SunOS 5.10 Update 4:\n                posix_extension.define_macros.append(('NEW_MIB_COMPLIANT', 1))\n            posix_extension.sources.append('psutil/arch/solaris/v10/ifaddrs.c')\n            posix_extension.define_macros.append(('PSUTIL_SUNOS10', 1))\n        else:\n            # Other releases are by default considered to be new mib compliant.\n            posix_extension.define_macros.append(('NEW_MIB_COMPLIANT', 1))\n    elif AIX:\n        posix_extension.sources.append('psutil/arch/aix/ifaddrs.c')\n\n    extensions = [ext, posix_extension]\nelse:\n    extensions = [ext]\n\ncmdclass = {}\nif py_limited_api:\n\n    class bdist_wheel_abi3(bdist_wheel):\n        def get_tag(self):\n            python, _abi, plat = bdist_wheel.get_tag(self)\n            return python, \"abi3\", plat\n\n    cmdclass[\"bdist_wheel\"] = bdist_wheel_abi3\n\n\ndef main():\n    kwargs = dict(\n        name='psutil',\n        version=VERSION,\n        cmdclass=cmdclass,\n        description=__doc__.replace('\\n', ' ').strip() if __doc__ else '',\n        long_description=get_long_description(),\n        long_description_content_type='text/x-rst',\n        # fmt: off\n        keywords=[\n            'ps', 'top', 'kill', 'free', 'lsof', 'netstat', 'nice', 'tty',\n            'ionice', 'uptime', 'taskmgr', 'process', 'df', 'iotop', 'iostat',\n            'ifconfig', 'taskset', 'who', 'pidof', 'pmap', 'smem', 'pstree',\n            'monitoring', 'ulimit', 'prlimit', 'smem', 'performance',\n            'metrics', 'agent', 'observability',\n        ],\n        # fmt: on\n        author='Giampaolo Rodola',\n        author_email='g.rodola@gmail.com',\n        url='https://github.com/giampaolo/psutil',\n        platforms='Platform Independent',\n        license='BSD-3-Clause',\n        packages=['psutil', 'psutil.tests'],\n        ext_modules=extensions,\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Environment :: Console',\n            'Environment :: Win32 (MS Windows)',\n            'Intended Audience :: Developers',\n            'Intended Audience :: Information Technology',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: BSD License',\n            'Operating System :: MacOS :: MacOS X',\n            'Operating System :: Microsoft :: Windows :: Windows 10',\n            'Operating System :: Microsoft :: Windows :: Windows 7',\n            'Operating System :: Microsoft :: Windows :: Windows 8',\n            'Operating System :: Microsoft :: Windows :: Windows 8.1',\n            'Operating System :: Microsoft :: Windows :: Windows Server 2003',\n            'Operating System :: Microsoft :: Windows :: Windows Server 2008',\n            'Operating System :: Microsoft :: Windows :: Windows Vista',\n            'Operating System :: Microsoft',\n            'Operating System :: OS Independent',\n            'Operating System :: POSIX :: AIX',\n            'Operating System :: POSIX :: BSD :: FreeBSD',\n            'Operating System :: POSIX :: BSD :: NetBSD',\n            'Operating System :: POSIX :: BSD :: OpenBSD',\n            'Operating System :: POSIX :: BSD',\n            'Operating System :: POSIX :: Linux',\n            'Operating System :: POSIX :: SunOS/Solaris',\n            'Operating System :: POSIX',\n            'Programming Language :: C',\n            'Programming Language :: Python :: 2',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: Implementation :: CPython',\n            'Programming Language :: Python :: Implementation :: PyPy',\n            'Programming Language :: Python',\n            'Topic :: Software Development :: Libraries :: Python Modules',\n            'Topic :: Software Development :: Libraries',\n            'Topic :: System :: Benchmark',\n            'Topic :: System :: Hardware :: Hardware Drivers',\n            'Topic :: System :: Hardware',\n            'Topic :: System :: Monitoring',\n            'Topic :: System :: Networking :: Monitoring :: Hardware Watchdog',\n            'Topic :: System :: Networking :: Monitoring',\n            'Topic :: System :: Networking',\n            'Topic :: System :: Operating System',\n            'Topic :: System :: Systems Administration',\n            'Topic :: Utilities',\n        ],\n    )\n    if setuptools is not None:\n        kwargs.update(\n            python_requires=(\n                \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*\"\n            ),\n            extras_require=extras_require,\n            zip_safe=False,\n        )\n    success = False\n    try:\n        setup(**kwargs)\n        success = True\n    finally:\n        cmd = sys.argv[1] if len(sys.argv) >= 2 else ''\n        if (\n            not success\n            and POSIX\n            and cmd.startswith(\n                (\"build\", \"install\", \"sdist\", \"bdist\", \"develop\")\n            )\n        ):\n            py3 = \"3\" if PY3 else \"\"\n            if LINUX:\n                pyimpl = \"pypy\" if PYPY else \"python\"\n                if which('dpkg'):\n                    missdeps(\n                        \"sudo apt-get install gcc %s%s-dev\" % (pyimpl, py3)\n                    )\n                elif which('rpm'):\n                    missdeps(\"sudo yum install gcc %s%s-devel\" % (pyimpl, py3))\n                elif which('apk'):\n                    missdeps(\n                        \"sudo apk add gcc %s%s-dev musl-dev linux-headers\"\n                        % (pyimpl, py3)\n                    )\n            elif MACOS:\n                msg = (\n                    \"XCode (https://developer.apple.com/xcode/)\"\n                    \" is not installed\"\n                )\n                print(hilite(msg, color=\"red\"), file=sys.stderr)\n            elif FREEBSD:\n                if which('pkg'):\n                    missdeps(\"pkg install gcc python%s\" % py3)\n                elif which('mport'):  # MidnightBSD\n                    missdeps(\"mport install gcc python%s\" % py3)\n            elif OPENBSD:\n                missdeps(\"pkg_add -v gcc python%s\" % py3)\n            elif NETBSD:\n                missdeps(\"pkgin install gcc python%s\" % py3)\n            elif SUNOS:\n                missdeps(\n                    \"sudo ln -s /usr/bin/gcc /usr/local/bin/cc && \"\n                    \"pkg install gcc\"\n                )\n\n\nif __name__ == '__main__':\n    main()\n", "psutil/_pswindows.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Windows platform implementation.\"\"\"\n\nimport contextlib\nimport errno\nimport functools\nimport os\nimport signal\nimport sys\nimport time\nfrom collections import namedtuple\n\nfrom . import _common\nfrom ._common import ENCODING\nfrom ._common import ENCODING_ERRS\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import TimeoutExpired\nfrom ._common import conn_tmap\nfrom ._common import conn_to_ntuple\nfrom ._common import debug\nfrom ._common import isfile_strict\nfrom ._common import memoize\nfrom ._common import memoize_when_activated\nfrom ._common import parse_environ_block\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import long\nfrom ._compat import lru_cache\nfrom ._compat import range\nfrom ._compat import unicode\nfrom ._psutil_windows import ABOVE_NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import BELOW_NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import HIGH_PRIORITY_CLASS\nfrom ._psutil_windows import IDLE_PRIORITY_CLASS\nfrom ._psutil_windows import NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import REALTIME_PRIORITY_CLASS\n\n\ntry:\n    from . import _psutil_windows as cext\nexcept ImportError as err:\n    if (\n        str(err).lower().startswith(\"dll load failed\")\n        and sys.getwindowsversion()[0] < 6\n    ):\n        # We may get here if:\n        # 1) we are on an old Windows version\n        # 2) psutil was installed via pip + wheel\n        # See: https://github.com/giampaolo/psutil/issues/811\n        msg = \"this Windows version is too old (< Windows Vista); \"\n        msg += \"psutil 3.4.2 is the latest version which supports Windows \"\n        msg += \"2000, XP and 2003 server\"\n        raise RuntimeError(msg)\n    else:\n        raise\n\nif PY3:\n    import enum\nelse:\n    enum = None\n\n# process priority constants, import from __init__.py:\n# http://msdn.microsoft.com/en-us/library/ms686219(v=vs.85).aspx\n# fmt: off\n__extra__all__ = [\n    \"win_service_iter\", \"win_service_get\",\n    # Process priority\n    \"ABOVE_NORMAL_PRIORITY_CLASS\", \"BELOW_NORMAL_PRIORITY_CLASS\",\n    \"HIGH_PRIORITY_CLASS\", \"IDLE_PRIORITY_CLASS\", \"NORMAL_PRIORITY_CLASS\",\n    \"REALTIME_PRIORITY_CLASS\",\n    # IO priority\n    \"IOPRIO_VERYLOW\", \"IOPRIO_LOW\", \"IOPRIO_NORMAL\", \"IOPRIO_HIGH\",\n    # others\n    \"CONN_DELETE_TCB\", \"AF_LINK\",\n]\n# fmt: on\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\nCONN_DELETE_TCB = \"DELETE_TCB\"\nERROR_PARTIAL_COPY = 299\nPYPY = '__pypy__' in sys.builtin_module_names\n\nif enum is None:\n    AF_LINK = -1\nelse:\n    AddressFamily = enum.IntEnum('AddressFamily', {'AF_LINK': -1})\n    AF_LINK = AddressFamily.AF_LINK\n\nTCP_STATUSES = {\n    cext.MIB_TCP_STATE_ESTAB: _common.CONN_ESTABLISHED,\n    cext.MIB_TCP_STATE_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.MIB_TCP_STATE_SYN_RCVD: _common.CONN_SYN_RECV,\n    cext.MIB_TCP_STATE_FIN_WAIT1: _common.CONN_FIN_WAIT1,\n    cext.MIB_TCP_STATE_FIN_WAIT2: _common.CONN_FIN_WAIT2,\n    cext.MIB_TCP_STATE_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.MIB_TCP_STATE_CLOSED: _common.CONN_CLOSE,\n    cext.MIB_TCP_STATE_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.MIB_TCP_STATE_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.MIB_TCP_STATE_LISTEN: _common.CONN_LISTEN,\n    cext.MIB_TCP_STATE_CLOSING: _common.CONN_CLOSING,\n    cext.MIB_TCP_STATE_DELETE_TCB: CONN_DELETE_TCB,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nif enum is not None:\n\n    class Priority(enum.IntEnum):\n        ABOVE_NORMAL_PRIORITY_CLASS = ABOVE_NORMAL_PRIORITY_CLASS\n        BELOW_NORMAL_PRIORITY_CLASS = BELOW_NORMAL_PRIORITY_CLASS\n        HIGH_PRIORITY_CLASS = HIGH_PRIORITY_CLASS\n        IDLE_PRIORITY_CLASS = IDLE_PRIORITY_CLASS\n        NORMAL_PRIORITY_CLASS = NORMAL_PRIORITY_CLASS\n        REALTIME_PRIORITY_CLASS = REALTIME_PRIORITY_CLASS\n\n    globals().update(Priority.__members__)\n\nif enum is None:\n    IOPRIO_VERYLOW = 0\n    IOPRIO_LOW = 1\n    IOPRIO_NORMAL = 2\n    IOPRIO_HIGH = 3\nelse:\n\n    class IOPriority(enum.IntEnum):\n        IOPRIO_VERYLOW = 0\n        IOPRIO_LOW = 1\n        IOPRIO_NORMAL = 2\n        IOPRIO_HIGH = 3\n\n    globals().update(IOPriority.__members__)\n\npinfo_map = dict(\n    num_handles=0,\n    ctx_switches=1,\n    user_time=2,\n    kernel_time=3,\n    create_time=4,\n    num_threads=5,\n    io_rcount=6,\n    io_wcount=7,\n    io_rbytes=8,\n    io_wbytes=9,\n    io_count_others=10,\n    io_bytes_others=11,\n    num_page_faults=12,\n    peak_wset=13,\n    wset=14,\n    peak_paged_pool=15,\n    paged_pool=16,\n    peak_non_paged_pool=17,\n    non_paged_pool=18,\n    pagefile=19,\n    peak_pagefile=20,\n    mem_private=21,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.cpu_times()\nscputimes = namedtuple('scputimes',\n                       ['user', 'system', 'idle', 'interrupt', 'dpc'])\n# psutil.virtual_memory()\nsvmem = namedtuple('svmem', ['total', 'available', 'percent', 'used', 'free'])\n# psutil.Process.memory_info()\npmem = namedtuple(\n    'pmem', ['rss', 'vms',\n             'num_page_faults', 'peak_wset', 'wset', 'peak_paged_pool',\n             'paged_pool', 'peak_nonpaged_pool', 'nonpaged_pool',\n             'pagefile', 'peak_pagefile', 'private'])\n# psutil.Process.memory_full_info()\npfullmem = namedtuple('pfullmem', pmem._fields + ('uss', ))\n# psutil.Process.memory_maps(grouped=True)\npmmap_grouped = namedtuple('pmmap_grouped', ['path', 'rss'])\n# psutil.Process.memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr perms ' + ' '.join(pmmap_grouped._fields))\n# psutil.Process.io_counters()\npio = namedtuple('pio', ['read_count', 'write_count',\n                         'read_bytes', 'write_bytes',\n                         'other_count', 'other_bytes'])\n# fmt: on\n\n\n# =====================================================================\n# --- utils\n# =====================================================================\n\n\n@lru_cache(maxsize=512)\ndef convert_dos_path(s):\n    r\"\"\"Convert paths using native DOS format like:\n        \"\\Device\\HarddiskVolume1\\Windows\\systemew\\file.txt\"\n    into:\n        \"C:\\Windows\\systemew\\file.txt\".\n    \"\"\"\n    rawdrive = '\\\\'.join(s.split('\\\\')[:3])\n    driveletter = cext.QueryDosDevice(rawdrive)\n    remainder = s[len(rawdrive) :]\n    return os.path.join(driveletter, remainder)\n\n\ndef py2_strencode(s):\n    \"\"\"Encode a unicode string to a byte string by using the default fs\n    encoding + \"replace\" error handler.\n    \"\"\"\n    if PY3:\n        return s\n    else:\n        if isinstance(s, str):\n            return s\n        else:\n            return s.encode(ENCODING, ENCODING_ERRS)\n\n\n@memoize\ndef getpagesize():\n    return cext.getpagesize()\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"System virtual memory as a namedtuple.\"\"\"\n    mem = cext.virtual_mem()\n    totphys, availphys, _totsys, _availsys = mem\n    total = totphys\n    avail = availphys\n    free = availphys\n    used = total - avail\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(total, avail, percent, used, free)\n\n\ndef swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    mem = cext.virtual_mem()\n\n    total_phys = mem[0]\n    total_system = mem[2]\n\n    # system memory (commit total/limit) is the sum of physical and swap\n    # thus physical memory values need to be subtracted to get swap values\n    total = total_system - total_phys\n    # commit total is incremented immediately (decrementing free_system)\n    # while the corresponding free physical value is not decremented until\n    # pages are accessed, so we can't use free system memory for swap.\n    # instead, we calculate page file usage based on performance counter\n    if total > 0:\n        percentswap = cext.swap_percent()\n        used = int(0.01 * percentswap * total)\n    else:\n        percentswap = 0.0\n        used = 0\n\n    free = total - used\n    percent = round(percentswap, 1)\n    return _common.sswap(total, used, free, percent, 0, 0)\n\n\n# =====================================================================\n# --- disk\n# =====================================================================\n\n\ndisk_io_counters = cext.disk_io_counters\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage associated with path.\"\"\"\n    if PY3 and isinstance(path, bytes):\n        # XXX: do we want to use \"strict\"? Probably yes, in order\n        # to fail immediately. After all we are accepting input here...\n        path = path.decode(ENCODING, errors=\"strict\")\n    total, free = cext.disk_usage(path)\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sdiskusage(total, used, free, percent)\n\n\ndef disk_partitions(all):\n    \"\"\"Return disk partitions.\"\"\"\n    rawlist = cext.disk_partitions(all)\n    return [_common.sdiskpart(*x) for x in rawlist]\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system CPU times as a named tuple.\"\"\"\n    user, system, idle = cext.cpu_times()\n    # Internally, GetSystemTimes() is used, and it doesn't return\n    # interrupt and dpc times. cext.per_cpu_times() does, so we\n    # rely on it to get those only.\n    percpu_summed = scputimes(*[sum(n) for n in zip(*cext.per_cpu_times())])\n    return scputimes(\n        user, system, idle, percpu_summed.interrupt, percpu_summed.dpc\n    )\n\n\ndef per_cpu_times():\n    \"\"\"Return system per-CPU times as a list of named tuples.\"\"\"\n    ret = []\n    for user, system, idle, interrupt, dpc in cext.per_cpu_times():\n        item = scputimes(user, system, idle, interrupt, dpc)\n        ret.append(item)\n    return ret\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    return cext.cpu_count_logical()\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    return cext.cpu_count_cores()\n\n\ndef cpu_stats():\n    \"\"\"Return CPU statistics.\"\"\"\n    ctx_switches, interrupts, _dpcs, syscalls = cext.cpu_stats()\n    soft_interrupts = 0\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\ndef cpu_freq():\n    \"\"\"Return CPU frequency.\n    On Windows per-cpu frequency is not supported.\n    \"\"\"\n    curr, max_ = cext.cpu_freq()\n    min_ = 0.0\n    return [_common.scpufreq(float(curr), min_, float(max_))]\n\n\n_loadavg_inititialized = False\n\n\ndef getloadavg():\n    \"\"\"Return the number of processes in the system run queue averaged\n    over the last 1, 5, and 15 minutes respectively as a tuple.\n    \"\"\"\n    global _loadavg_inititialized\n\n    if not _loadavg_inititialized:\n        cext.init_loadavg_counter()\n        _loadavg_inititialized = True\n\n    # Drop to 2 decimal points which is what Linux does\n    raw_loads = cext.getloadavg()\n    return tuple([round(load, 2) for load in raw_loads])\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\ndef net_connections(kind, _pid=-1):\n    \"\"\"Return socket connections.  If pid == -1 return system-wide\n    connections (as opposed to connections opened by one process only).\n    \"\"\"\n    if kind not in conn_tmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in conn_tmap]))\n        )\n    families, types = conn_tmap[kind]\n    rawlist = cext.net_connections(_pid, families, types)\n    ret = set()\n    for item in rawlist:\n        fd, fam, type, laddr, raddr, status, pid = item\n        nt = conn_to_ntuple(\n            fd,\n            fam,\n            type,\n            laddr,\n            raddr,\n            status,\n            TCP_STATUSES,\n            pid=pid if _pid == -1 else None,\n        )\n        ret.add(nt)\n    return list(ret)\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    ret = {}\n    rawdict = cext.net_if_stats()\n    for name, items in rawdict.items():\n        if not PY3:\n            assert isinstance(name, unicode), type(name)\n            name = py2_strencode(name)\n        isup, duplex, speed, mtu = items\n        if hasattr(_common, 'NicDuplex'):\n            duplex = _common.NicDuplex(duplex)\n        ret[name] = _common.snicstats(isup, duplex, speed, mtu, '')\n    return ret\n\n\ndef net_io_counters():\n    \"\"\"Return network I/O statistics for every network interface\n    installed on the system as a dict of raw tuples.\n    \"\"\"\n    ret = cext.net_io_counters()\n    return dict([(py2_strencode(k), v) for k, v in ret.items()])\n\n\ndef net_if_addrs():\n    \"\"\"Return the addresses associated to each NIC.\"\"\"\n    ret = []\n    for items in cext.net_if_addrs():\n        items = list(items)\n        items[0] = py2_strencode(items[0])\n        ret.append(items)\n    return ret\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\ndef sensors_battery():\n    \"\"\"Return battery information.\"\"\"\n    # For constants meaning see:\n    # https://msdn.microsoft.com/en-us/library/windows/desktop/\n    #     aa373232(v=vs.85).aspx\n    acline_status, flags, percent, secsleft = cext.sensors_battery()\n    power_plugged = acline_status == 1\n    no_battery = bool(flags & 128)\n    charging = bool(flags & 8)\n\n    if no_battery:\n        return None\n    if power_plugged or charging:\n        secsleft = _common.POWER_TIME_UNLIMITED\n    elif secsleft == -1:\n        secsleft = _common.POWER_TIME_UNKNOWN\n\n    return _common.sbattery(percent, secsleft, power_plugged)\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\n_last_btime = 0\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    # This dirty hack is to adjust the precision of the returned\n    # value which may have a 1 second fluctuation, see:\n    # https://github.com/giampaolo/psutil/issues/1007\n    global _last_btime\n    ret = float(cext.boot_time())\n    if abs(ret - _last_btime) <= 1:\n        return _last_btime\n    else:\n        _last_btime = ret\n        return ret\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, hostname, tstamp = item\n        user = py2_strencode(user)\n        nt = _common.suser(user, None, hostname, tstamp, None)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- Windows services\n# =====================================================================\n\n\ndef win_service_iter():\n    \"\"\"Yields a list of WindowsService instances.\"\"\"\n    for name, display_name in cext.winservice_enumerate():\n        yield WindowsService(py2_strencode(name), py2_strencode(display_name))\n\n\ndef win_service_get(name):\n    \"\"\"Open a Windows service and return it as a WindowsService instance.\"\"\"\n    service = WindowsService(name, None)\n    service._display_name = service._query_config()['display_name']\n    return service\n\n\nclass WindowsService:  # noqa: PLW1641\n    \"\"\"Represents an installed Windows service.\"\"\"\n\n    def __init__(self, name, display_name):\n        self._name = name\n        self._display_name = display_name\n\n    def __str__(self):\n        details = \"(name=%r, display_name=%r)\" % (\n            self._name,\n            self._display_name,\n        )\n        return \"%s%s\" % (self.__class__.__name__, details)\n\n    def __repr__(self):\n        return \"<%s at %s>\" % (self.__str__(), id(self))\n\n    def __eq__(self, other):\n        # Test for equality with another WindosService object based\n        # on name.\n        if not isinstance(other, WindowsService):\n            return NotImplemented\n        return self._name == other._name\n\n    def __ne__(self, other):\n        return not self == other\n\n    def _query_config(self):\n        with self._wrap_exceptions():\n            display_name, binpath, username, start_type = (\n                cext.winservice_query_config(self._name)\n            )\n        # XXX - update _self.display_name?\n        return dict(\n            display_name=py2_strencode(display_name),\n            binpath=py2_strencode(binpath),\n            username=py2_strencode(username),\n            start_type=py2_strencode(start_type),\n        )\n\n    def _query_status(self):\n        with self._wrap_exceptions():\n            status, pid = cext.winservice_query_status(self._name)\n        if pid == 0:\n            pid = None\n        return dict(status=status, pid=pid)\n\n    @contextlib.contextmanager\n    def _wrap_exceptions(self):\n        \"\"\"Ctx manager which translates bare OSError and WindowsError\n        exceptions into NoSuchProcess and AccessDenied.\n        \"\"\"\n        try:\n            yield\n        except OSError as err:\n            if is_permission_err(err):\n                msg = (\n                    \"service %r is not querable (not enough privileges)\"\n                    % self._name\n                )\n                raise AccessDenied(pid=None, name=self._name, msg=msg)\n            elif err.winerror in (\n                cext.ERROR_INVALID_NAME,\n                cext.ERROR_SERVICE_DOES_NOT_EXIST,\n            ):\n                msg = \"service %r does not exist\" % self._name\n                raise NoSuchProcess(pid=None, name=self._name, msg=msg)\n            else:\n                raise\n\n    # config query\n\n    def name(self):\n        \"\"\"The service name. This string is how a service is referenced\n        and can be passed to win_service_get() to get a new\n        WindowsService instance.\n        \"\"\"\n        return self._name\n\n    def display_name(self):\n        \"\"\"The service display name. The value is cached when this class\n        is instantiated.\n        \"\"\"\n        return self._display_name\n\n    def binpath(self):\n        \"\"\"The fully qualified path to the service binary/exe file as\n        a string, including command line arguments.\n        \"\"\"\n        return self._query_config()['binpath']\n\n    def username(self):\n        \"\"\"The name of the user that owns this service.\"\"\"\n        return self._query_config()['username']\n\n    def start_type(self):\n        \"\"\"A string which can either be \"automatic\", \"manual\" or\n        \"disabled\".\n        \"\"\"\n        return self._query_config()['start_type']\n\n    # status query\n\n    def pid(self):\n        \"\"\"The process PID, if any, else None. This can be passed\n        to Process class to control the service's process.\n        \"\"\"\n        return self._query_status()['pid']\n\n    def status(self):\n        \"\"\"Service status as a string.\"\"\"\n        return self._query_status()['status']\n\n    def description(self):\n        \"\"\"Service long description.\"\"\"\n        return py2_strencode(cext.winservice_query_descr(self.name()))\n\n    # utils\n\n    def as_dict(self):\n        \"\"\"Utility method retrieving all the information above as a\n        dictionary.\n        \"\"\"\n        d = self._query_config()\n        d.update(self._query_status())\n        d['name'] = self.name()\n        d['display_name'] = self.display_name()\n        d['description'] = self.description()\n        return d\n\n    # actions\n    # XXX: the necessary C bindings for start() and stop() are\n    # implemented but for now I prefer not to expose them.\n    # I may change my mind in the future. Reasons:\n    # - they require Administrator privileges\n    # - can't implement a timeout for stop() (unless by using a thread,\n    #   which sucks)\n    # - would require adding ServiceAlreadyStarted and\n    #   ServiceAlreadyStopped exceptions, adding two new APIs.\n    # - we might also want to have modify(), which would basically mean\n    #   rewriting win32serviceutil.ChangeServiceConfig, which involves a\n    #   lot of stuff (and API constants which would pollute the API), see:\n    #   http://pyxr.sourceforge.net/PyXR/c/python24/lib/site-packages/\n    #       win32/lib/win32serviceutil.py.html#0175\n    # - psutil is typically about \"read only\" monitoring stuff;\n    #   win_service_* APIs should only be used to retrieve a service and\n    #   check whether it's running\n\n    # def start(self, timeout=None):\n    #     with self._wrap_exceptions():\n    #         cext.winservice_start(self.name())\n    #         if timeout:\n    #             giveup_at = time.time() + timeout\n    #             while True:\n    #                 if self.status() == \"running\":\n    #                     return\n    #                 else:\n    #                     if time.time() > giveup_at:\n    #                         raise TimeoutExpired(timeout)\n    #                     else:\n    #                         time.sleep(.1)\n\n    # def stop(self):\n    #     # Note: timeout is not implemented because it's just not\n    #     # possible, see:\n    #     # http://stackoverflow.com/questions/11973228/\n    #     with self._wrap_exceptions():\n    #         return cext.winservice_stop(self.name())\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\npids = cext.pids\npid_exists = cext.pid_exists\nppid_map = cext.ppid_map  # used internally by Process.children()\n\n\ndef is_permission_err(exc):\n    \"\"\"Return True if this is a permission error.\"\"\"\n    assert isinstance(exc, OSError), exc\n    if exc.errno in (errno.EPERM, errno.EACCES):\n        return True\n    # On Python 2 OSError doesn't always have 'winerror'. Sometimes\n    # it does, in which case the original exception was WindowsError\n    # (which is a subclass of OSError).\n    return getattr(exc, \"winerror\", -1) in (\n        cext.ERROR_ACCESS_DENIED,\n        cext.ERROR_PRIVILEGE_NOT_HELD,\n    )\n\n\ndef convert_oserror(exc, pid=None, name=None):\n    \"\"\"Convert OSError into NoSuchProcess or AccessDenied.\"\"\"\n    assert isinstance(exc, OSError), exc\n    if is_permission_err(exc):\n        return AccessDenied(pid=pid, name=name)\n    if exc.errno == errno.ESRCH:\n        return NoSuchProcess(pid=pid, name=name)\n    raise exc\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which converts OSError into NoSuchProcess or AccessDenied.\"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except OSError as err:\n            raise convert_oserror(err, pid=self.pid, name=self._name)\n\n    return wrapper\n\n\ndef retry_error_partial_copy(fun):\n    \"\"\"Workaround for https://github.com/giampaolo/psutil/issues/875.\n    See: https://stackoverflow.com/questions/4457745#4457745.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        delay = 0.0001\n        times = 33\n        for _ in range(times):  # retries for roughly 1 second\n            try:\n                return fun(self, *args, **kwargs)\n            except WindowsError as _:\n                err = _\n                if err.winerror == ERROR_PARTIAL_COPY:\n                    time.sleep(delay)\n                    delay = min(delay * 2, 0.04)\n                    continue\n                raise\n        msg = (\n            \"{} retried {} times, converted to AccessDenied as it's still\"\n            \"returning {}\".format(fun, times, err)\n        )\n        raise AccessDenied(pid=self.pid, name=self._name, msg=msg)\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n\n    # --- oneshot() stuff\n\n    def oneshot_enter(self):\n        self._proc_info.cache_activate(self)\n        self.exe.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._proc_info.cache_deactivate(self)\n        self.exe.cache_deactivate(self)\n\n    @memoize_when_activated\n    def _proc_info(self):\n        \"\"\"Return multiple information about this process as a\n        raw tuple.\n        \"\"\"\n        ret = cext.proc_info(self.pid)\n        assert len(ret) == len(pinfo_map)\n        return ret\n\n    def name(self):\n        \"\"\"Return process name, which on Windows is always the final\n        part of the executable.\n        \"\"\"\n        # This is how PIDs 0 and 4 are always represented in taskmgr\n        # and process-hacker.\n        if self.pid == 0:\n            return \"System Idle Process\"\n        if self.pid == 4:\n            return \"System\"\n        return os.path.basename(self.exe())\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def exe(self):\n        if PYPY:\n            try:\n                exe = cext.proc_exe(self.pid)\n            except WindowsError as err:\n                # 24 = ERROR_TOO_MANY_OPEN_FILES. Not sure why this happens\n                # (perhaps PyPy's JIT delaying garbage collection of files?).\n                if err.errno == 24:\n                    debug(\"%r translated into AccessDenied\" % err)\n                    raise AccessDenied(self.pid, self._name)\n                raise\n        else:\n            exe = cext.proc_exe(self.pid)\n        if not PY3:\n            exe = py2_strencode(exe)\n        if exe.startswith('\\\\'):\n            return convert_dos_path(exe)\n        return exe  # May be \"Registry\", \"MemCompression\", ...\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def cmdline(self):\n        if cext.WINVER >= cext.WINDOWS_8_1:\n            # PEB method detects cmdline changes but requires more\n            # privileges: https://github.com/giampaolo/psutil/pull/1398\n            try:\n                ret = cext.proc_cmdline(self.pid, use_peb=True)\n            except OSError as err:\n                if is_permission_err(err):\n                    ret = cext.proc_cmdline(self.pid, use_peb=False)\n                else:\n                    raise\n        else:\n            ret = cext.proc_cmdline(self.pid, use_peb=True)\n        if PY3:\n            return ret\n        else:\n            return [py2_strencode(s) for s in ret]\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def environ(self):\n        ustr = cext.proc_environ(self.pid)\n        if ustr and not PY3:\n            assert isinstance(ustr, unicode), type(ustr)\n        return parse_environ_block(py2_strencode(ustr))\n\n    def ppid(self):\n        try:\n            return ppid_map()[self.pid]\n        except KeyError:\n            raise NoSuchProcess(self.pid, self._name)\n\n    def _get_raw_meminfo(self):\n        try:\n            return cext.proc_memory_info(self.pid)\n        except OSError as err:\n            if is_permission_err(err):\n                # TODO: the C ext can probably be refactored in order\n                # to get this from cext.proc_info()\n                debug(\"attempting memory_info() fallback (slower)\")\n                info = self._proc_info()\n                return (\n                    info[pinfo_map['num_page_faults']],\n                    info[pinfo_map['peak_wset']],\n                    info[pinfo_map['wset']],\n                    info[pinfo_map['peak_paged_pool']],\n                    info[pinfo_map['paged_pool']],\n                    info[pinfo_map['peak_non_paged_pool']],\n                    info[pinfo_map['non_paged_pool']],\n                    info[pinfo_map['pagefile']],\n                    info[pinfo_map['peak_pagefile']],\n                    info[pinfo_map['mem_private']],\n                )\n            raise\n\n    @wrap_exceptions\n    def memory_info(self):\n        # on Windows RSS == WorkingSetSize and VSM == PagefileUsage.\n        # Underlying C function returns fields of PROCESS_MEMORY_COUNTERS\n        # struct.\n        t = self._get_raw_meminfo()\n        rss = t[2]  # wset\n        vms = t[7]  # pagefile\n        return pmem(*(rss, vms) + t)\n\n    @wrap_exceptions\n    def memory_full_info(self):\n        basic_mem = self.memory_info()\n        uss = cext.proc_memory_uss(self.pid)\n        uss *= getpagesize()\n        return pfullmem(*basic_mem + (uss,))\n\n    def memory_maps(self):\n        try:\n            raw = cext.proc_memory_maps(self.pid)\n        except OSError as err:\n            # XXX - can't use wrap_exceptions decorator as we're\n            # returning a generator; probably needs refactoring.\n            raise convert_oserror(err, self.pid, self._name)\n        else:\n            for addr, perm, path, rss in raw:\n                path = convert_dos_path(path)\n                if not PY3:\n                    path = py2_strencode(path)\n                addr = hex(addr)\n                yield (addr, perm, path, rss)\n\n    @wrap_exceptions\n    def kill(self):\n        return cext.proc_kill(self.pid)\n\n    @wrap_exceptions\n    def send_signal(self, sig):\n        if sig == signal.SIGTERM:\n            cext.proc_kill(self.pid)\n        # py >= 2.7\n        elif sig in (\n            getattr(signal, \"CTRL_C_EVENT\", object()),\n            getattr(signal, \"CTRL_BREAK_EVENT\", object()),\n        ):\n            os.kill(self.pid, sig)\n        else:\n            msg = (\n                \"only SIGTERM, CTRL_C_EVENT and CTRL_BREAK_EVENT signals \"\n                \"are supported on Windows\"\n            )\n            raise ValueError(msg)\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        if timeout is None:\n            cext_timeout = cext.INFINITE\n        else:\n            # WaitForSingleObject() expects time in milliseconds.\n            cext_timeout = int(timeout * 1000)\n\n        timer = getattr(time, 'monotonic', time.time)\n        stop_at = timer() + timeout if timeout is not None else None\n\n        try:\n            # Exit code is supposed to come from GetExitCodeProcess().\n            # May also be None if OpenProcess() failed with\n            # ERROR_INVALID_PARAMETER, meaning PID is already gone.\n            exit_code = cext.proc_wait(self.pid, cext_timeout)\n        except cext.TimeoutExpired:\n            # WaitForSingleObject() returned WAIT_TIMEOUT. Just raise.\n            raise TimeoutExpired(timeout, self.pid, self._name)\n        except cext.TimeoutAbandoned:\n            # WaitForSingleObject() returned WAIT_ABANDONED, see:\n            # https://github.com/giampaolo/psutil/issues/1224\n            # We'll just rely on the internal polling and return None\n            # when the PID disappears. Subprocess module does the same\n            # (return None):\n            # https://github.com/python/cpython/blob/\n            #     be50a7b627d0aa37e08fa8e2d5568891f19903ce/\n            #     Lib/subprocess.py#L1193-L1194\n            exit_code = None\n\n        # At this point WaitForSingleObject() returned WAIT_OBJECT_0,\n        # meaning the process is gone. Stupidly there are cases where\n        # its PID may still stick around so we do a further internal\n        # polling.\n        delay = 0.0001\n        while True:\n            if not pid_exists(self.pid):\n                return exit_code\n            if stop_at and timer() >= stop_at:\n                raise TimeoutExpired(timeout, pid=self.pid, name=self._name)\n            time.sleep(delay)\n            delay = min(delay * 2, 0.04)  # incremental delay\n\n    @wrap_exceptions\n    def username(self):\n        if self.pid in (0, 4):\n            return 'NT AUTHORITY\\\\SYSTEM'\n        domain, user = cext.proc_username(self.pid)\n        return py2_strencode(domain) + '\\\\' + py2_strencode(user)\n\n    @wrap_exceptions\n    def create_time(self):\n        # Note: proc_times() not put under oneshot() 'cause create_time()\n        # is already cached by the main Process class.\n        try:\n            _user, _system, created = cext.proc_times(self.pid)\n            return created\n        except OSError as err:\n            if is_permission_err(err):\n                debug(\"attempting create_time() fallback (slower)\")\n                return self._proc_info()[pinfo_map['create_time']]\n            raise\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._proc_info()[pinfo_map['num_threads']]\n\n    @wrap_exceptions\n    def threads(self):\n        rawlist = cext.proc_threads(self.pid)\n        retlist = []\n        for thread_id, utime, stime in rawlist:\n            ntuple = _common.pthread(thread_id, utime, stime)\n            retlist.append(ntuple)\n        return retlist\n\n    @wrap_exceptions\n    def cpu_times(self):\n        try:\n            user, system, _created = cext.proc_times(self.pid)\n        except OSError as err:\n            if not is_permission_err(err):\n                raise\n            debug(\"attempting cpu_times() fallback (slower)\")\n            info = self._proc_info()\n            user = info[pinfo_map['user_time']]\n            system = info[pinfo_map['kernel_time']]\n        # Children user/system times are not retrievable (set to 0).\n        return _common.pcputimes(user, system, 0.0, 0.0)\n\n    @wrap_exceptions\n    def suspend(self):\n        cext.proc_suspend_or_resume(self.pid, True)\n\n    @wrap_exceptions\n    def resume(self):\n        cext.proc_suspend_or_resume(self.pid, False)\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def cwd(self):\n        if self.pid in (0, 4):\n            raise AccessDenied(self.pid, self._name)\n        # return a normalized pathname since the native C function appends\n        # \"\\\\\" at the and of the path\n        path = cext.proc_cwd(self.pid)\n        return py2_strencode(os.path.normpath(path))\n\n    @wrap_exceptions\n    def open_files(self):\n        if self.pid in (0, 4):\n            return []\n        ret = set()\n        # Filenames come in in native format like:\n        # \"\\Device\\HarddiskVolume1\\Windows\\systemew\\file.txt\"\n        # Convert the first part in the corresponding drive letter\n        # (e.g. \"C:\\\") by using Windows's QueryDosDevice()\n        raw_file_names = cext.proc_open_files(self.pid)\n        for _file in raw_file_names:\n            _file = convert_dos_path(_file)\n            if isfile_strict(_file):\n                if not PY3:\n                    _file = py2_strencode(_file)\n                ntuple = _common.popenfile(_file, -1)\n                ret.add(ntuple)\n        return list(ret)\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        return net_connections(kind, _pid=self.pid)\n\n    @wrap_exceptions\n    def nice_get(self):\n        value = cext.proc_priority_get(self.pid)\n        if enum is not None:\n            value = Priority(value)\n        return value\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext.proc_priority_set(self.pid, value)\n\n    @wrap_exceptions\n    def ionice_get(self):\n        ret = cext.proc_io_priority_get(self.pid)\n        if enum is not None:\n            ret = IOPriority(ret)\n        return ret\n\n    @wrap_exceptions\n    def ionice_set(self, ioclass, value):\n        if value:\n            msg = \"value argument not accepted on Windows\"\n            raise TypeError(msg)\n        if ioclass not in (\n            IOPRIO_VERYLOW,\n            IOPRIO_LOW,\n            IOPRIO_NORMAL,\n            IOPRIO_HIGH,\n        ):\n            raise ValueError(\"%s is not a valid priority\" % ioclass)\n        cext.proc_io_priority_set(self.pid, ioclass)\n\n    @wrap_exceptions\n    def io_counters(self):\n        try:\n            ret = cext.proc_io_counters(self.pid)\n        except OSError as err:\n            if not is_permission_err(err):\n                raise\n            debug(\"attempting io_counters() fallback (slower)\")\n            info = self._proc_info()\n            ret = (\n                info[pinfo_map['io_rcount']],\n                info[pinfo_map['io_wcount']],\n                info[pinfo_map['io_rbytes']],\n                info[pinfo_map['io_wbytes']],\n                info[pinfo_map['io_count_others']],\n                info[pinfo_map['io_bytes_others']],\n            )\n        return pio(*ret)\n\n    @wrap_exceptions\n    def status(self):\n        suspended = cext.proc_is_suspended(self.pid)\n        if suspended:\n            return _common.STATUS_STOPPED\n        else:\n            return _common.STATUS_RUNNING\n\n    @wrap_exceptions\n    def cpu_affinity_get(self):\n        def from_bitmask(x):\n            return [i for i in range(64) if (1 << i) & x]\n\n        bitmask = cext.proc_cpu_affinity_get(self.pid)\n        return from_bitmask(bitmask)\n\n    @wrap_exceptions\n    def cpu_affinity_set(self, value):\n        def to_bitmask(ls):\n            if not ls:\n                raise ValueError(\"invalid argument %r\" % ls)\n            out = 0\n            for b in ls:\n                out |= 2**b\n            return out\n\n        # SetProcessAffinityMask() states that ERROR_INVALID_PARAMETER\n        # is returned for an invalid CPU but this seems not to be true,\n        # therefore we check CPUs validy beforehand.\n        allcpus = list(range(len(per_cpu_times())))\n        for cpu in value:\n            if cpu not in allcpus:\n                if not isinstance(cpu, (int, long)):\n                    raise TypeError(\n                        \"invalid CPU %r; an integer is required\" % cpu\n                    )\n                else:\n                    raise ValueError(\"invalid CPU %r\" % cpu)\n\n        bitmask = to_bitmask(value)\n        cext.proc_cpu_affinity_set(self.pid, bitmask)\n\n    @wrap_exceptions\n    def num_handles(self):\n        try:\n            return cext.proc_num_handles(self.pid)\n        except OSError as err:\n            if is_permission_err(err):\n                debug(\"attempting num_handles() fallback (slower)\")\n                return self._proc_info()[pinfo_map['num_handles']]\n            raise\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        ctx_switches = self._proc_info()[pinfo_map['ctx_switches']]\n        # only voluntary ctx switches are supported\n        return _common.pctxsw(ctx_switches, 0)\n", "psutil/_common.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Common objects shared by __init__.py and _ps*.py modules.\"\"\"\n\n# Note: this module is imported by setup.py so it should not import\n# psutil or third-party modules.\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\n\n\ntry:\n    from socket import AF_INET6\nexcept ImportError:\n    AF_INET6 = None\ntry:\n    from socket import AF_UNIX\nexcept ImportError:\n    AF_UNIX = None\n\n\n# can't take it from _common.py as this script is imported by setup.py\nPY3 = sys.version_info[0] >= 3\nif PY3:\n    import enum\nelse:\n    enum = None\n\n\nPSUTIL_DEBUG = bool(os.getenv('PSUTIL_DEBUG'))\n_DEFAULT = object()\n\n# fmt: off\n__all__ = [\n    # OS constants\n    'FREEBSD', 'BSD', 'LINUX', 'NETBSD', 'OPENBSD', 'MACOS', 'OSX', 'POSIX',\n    'SUNOS', 'WINDOWS',\n    # connection constants\n    'CONN_CLOSE', 'CONN_CLOSE_WAIT', 'CONN_CLOSING', 'CONN_ESTABLISHED',\n    'CONN_FIN_WAIT1', 'CONN_FIN_WAIT2', 'CONN_LAST_ACK', 'CONN_LISTEN',\n    'CONN_NONE', 'CONN_SYN_RECV', 'CONN_SYN_SENT', 'CONN_TIME_WAIT',\n    # net constants\n    'NIC_DUPLEX_FULL', 'NIC_DUPLEX_HALF', 'NIC_DUPLEX_UNKNOWN',\n    # process status constants\n    'STATUS_DEAD', 'STATUS_DISK_SLEEP', 'STATUS_IDLE', 'STATUS_LOCKED',\n    'STATUS_RUNNING', 'STATUS_SLEEPING', 'STATUS_STOPPED', 'STATUS_SUSPENDED',\n    'STATUS_TRACING_STOP', 'STATUS_WAITING', 'STATUS_WAKE_KILL',\n    'STATUS_WAKING', 'STATUS_ZOMBIE', 'STATUS_PARKED',\n    # other constants\n    'ENCODING', 'ENCODING_ERRS', 'AF_INET6',\n    # named tuples\n    'pconn', 'pcputimes', 'pctxsw', 'pgids', 'pio', 'pionice', 'popenfile',\n    'pthread', 'puids', 'sconn', 'scpustats', 'sdiskio', 'sdiskpart',\n    'sdiskusage', 'snetio', 'snicaddr', 'snicstats', 'sswap', 'suser',\n    # utility functions\n    'conn_tmap', 'deprecated_method', 'isfile_strict', 'memoize',\n    'parse_environ_block', 'path_exists_strict', 'usage_percent',\n    'supports_ipv6', 'sockfam_to_enum', 'socktype_to_enum', \"wrap_numbers\",\n    'open_text', 'open_binary', 'cat', 'bcat',\n    'bytes2human', 'conn_to_ntuple', 'debug',\n    # shell utils\n    'hilite', 'term_supports_colors', 'print_color',\n]\n# fmt: on\n\n\n# ===================================================================\n# --- OS constants\n# ===================================================================\n\n\nPOSIX = os.name == \"posix\"\nWINDOWS = os.name == \"nt\"\nLINUX = sys.platform.startswith(\"linux\")\nMACOS = sys.platform.startswith(\"darwin\")\nOSX = MACOS  # deprecated alias\nFREEBSD = sys.platform.startswith((\"freebsd\", \"midnightbsd\"))\nOPENBSD = sys.platform.startswith(\"openbsd\")\nNETBSD = sys.platform.startswith(\"netbsd\")\nBSD = FREEBSD or OPENBSD or NETBSD\nSUNOS = sys.platform.startswith((\"sunos\", \"solaris\"))\nAIX = sys.platform.startswith(\"aix\")\n\n\n# ===================================================================\n# --- API constants\n# ===================================================================\n\n\n# Process.status()\nSTATUS_RUNNING = \"running\"\nSTATUS_SLEEPING = \"sleeping\"\nSTATUS_DISK_SLEEP = \"disk-sleep\"\nSTATUS_STOPPED = \"stopped\"\nSTATUS_TRACING_STOP = \"tracing-stop\"\nSTATUS_ZOMBIE = \"zombie\"\nSTATUS_DEAD = \"dead\"\nSTATUS_WAKE_KILL = \"wake-kill\"\nSTATUS_WAKING = \"waking\"\nSTATUS_IDLE = \"idle\"  # Linux, macOS, FreeBSD\nSTATUS_LOCKED = \"locked\"  # FreeBSD\nSTATUS_WAITING = \"waiting\"  # FreeBSD\nSTATUS_SUSPENDED = \"suspended\"  # NetBSD\nSTATUS_PARKED = \"parked\"  # Linux\n\n# Process.net_connections() and psutil.net_connections()\nCONN_ESTABLISHED = \"ESTABLISHED\"\nCONN_SYN_SENT = \"SYN_SENT\"\nCONN_SYN_RECV = \"SYN_RECV\"\nCONN_FIN_WAIT1 = \"FIN_WAIT1\"\nCONN_FIN_WAIT2 = \"FIN_WAIT2\"\nCONN_TIME_WAIT = \"TIME_WAIT\"\nCONN_CLOSE = \"CLOSE\"\nCONN_CLOSE_WAIT = \"CLOSE_WAIT\"\nCONN_LAST_ACK = \"LAST_ACK\"\nCONN_LISTEN = \"LISTEN\"\nCONN_CLOSING = \"CLOSING\"\nCONN_NONE = \"NONE\"\n\n# net_if_stats()\nif enum is None:\n    NIC_DUPLEX_FULL = 2\n    NIC_DUPLEX_HALF = 1\n    NIC_DUPLEX_UNKNOWN = 0\nelse:\n\n    class NicDuplex(enum.IntEnum):\n        NIC_DUPLEX_FULL = 2\n        NIC_DUPLEX_HALF = 1\n        NIC_DUPLEX_UNKNOWN = 0\n\n    globals().update(NicDuplex.__members__)\n\n# sensors_battery()\nif enum is None:\n    POWER_TIME_UNKNOWN = -1\n    POWER_TIME_UNLIMITED = -2\nelse:\n\n    class BatteryTime(enum.IntEnum):\n        POWER_TIME_UNKNOWN = -1\n        POWER_TIME_UNLIMITED = -2\n\n    globals().update(BatteryTime.__members__)\n\n# --- others\n\nENCODING = sys.getfilesystemencoding()\nif not PY3:\n    ENCODING_ERRS = \"replace\"\nelse:\n    try:\n        ENCODING_ERRS = sys.getfilesystemencodeerrors()  # py 3.6\n    except AttributeError:\n        ENCODING_ERRS = \"surrogateescape\" if POSIX else \"replace\"\n\n\n# ===================================================================\n# --- namedtuples\n# ===================================================================\n\n# --- for system functions\n\n# fmt: off\n# psutil.swap_memory()\nsswap = namedtuple('sswap', ['total', 'used', 'free', 'percent', 'sin',\n                             'sout'])\n# psutil.disk_usage()\nsdiskusage = namedtuple('sdiskusage', ['total', 'used', 'free', 'percent'])\n# psutil.disk_io_counters()\nsdiskio = namedtuple('sdiskio', ['read_count', 'write_count',\n                                 'read_bytes', 'write_bytes',\n                                 'read_time', 'write_time'])\n# psutil.disk_partitions()\nsdiskpart = namedtuple('sdiskpart', ['device', 'mountpoint', 'fstype', 'opts'])\n# psutil.net_io_counters()\nsnetio = namedtuple('snetio', ['bytes_sent', 'bytes_recv',\n                               'packets_sent', 'packets_recv',\n                               'errin', 'errout',\n                               'dropin', 'dropout'])\n# psutil.users()\nsuser = namedtuple('suser', ['name', 'terminal', 'host', 'started', 'pid'])\n# psutil.net_connections()\nsconn = namedtuple('sconn', ['fd', 'family', 'type', 'laddr', 'raddr',\n                             'status', 'pid'])\n# psutil.net_if_addrs()\nsnicaddr = namedtuple('snicaddr',\n                      ['family', 'address', 'netmask', 'broadcast', 'ptp'])\n# psutil.net_if_stats()\nsnicstats = namedtuple('snicstats',\n                       ['isup', 'duplex', 'speed', 'mtu', 'flags'])\n# psutil.cpu_stats()\nscpustats = namedtuple(\n    'scpustats', ['ctx_switches', 'interrupts', 'soft_interrupts', 'syscalls'])\n# psutil.cpu_freq()\nscpufreq = namedtuple('scpufreq', ['current', 'min', 'max'])\n# psutil.sensors_temperatures()\nshwtemp = namedtuple(\n    'shwtemp', ['label', 'current', 'high', 'critical'])\n# psutil.sensors_battery()\nsbattery = namedtuple('sbattery', ['percent', 'secsleft', 'power_plugged'])\n# psutil.sensors_fans()\nsfan = namedtuple('sfan', ['label', 'current'])\n# fmt: on\n\n# --- for Process methods\n\n# psutil.Process.cpu_times()\npcputimes = namedtuple(\n    'pcputimes', ['user', 'system', 'children_user', 'children_system']\n)\n# psutil.Process.open_files()\npopenfile = namedtuple('popenfile', ['path', 'fd'])\n# psutil.Process.threads()\npthread = namedtuple('pthread', ['id', 'user_time', 'system_time'])\n# psutil.Process.uids()\npuids = namedtuple('puids', ['real', 'effective', 'saved'])\n# psutil.Process.gids()\npgids = namedtuple('pgids', ['real', 'effective', 'saved'])\n# psutil.Process.io_counters()\npio = namedtuple(\n    'pio', ['read_count', 'write_count', 'read_bytes', 'write_bytes']\n)\n# psutil.Process.ionice()\npionice = namedtuple('pionice', ['ioclass', 'value'])\n# psutil.Process.ctx_switches()\npctxsw = namedtuple('pctxsw', ['voluntary', 'involuntary'])\n# psutil.Process.net_connections()\npconn = namedtuple(\n    'pconn', ['fd', 'family', 'type', 'laddr', 'raddr', 'status']\n)\n\n# psutil.net_connections() and psutil.Process.net_connections()\naddr = namedtuple('addr', ['ip', 'port'])\n\n\n# ===================================================================\n# --- Process.net_connections() 'kind' parameter mapping\n# ===================================================================\n\n\nconn_tmap = {\n    \"all\": ([AF_INET, AF_INET6, AF_UNIX], [SOCK_STREAM, SOCK_DGRAM]),\n    \"tcp\": ([AF_INET, AF_INET6], [SOCK_STREAM]),\n    \"tcp4\": ([AF_INET], [SOCK_STREAM]),\n    \"udp\": ([AF_INET, AF_INET6], [SOCK_DGRAM]),\n    \"udp4\": ([AF_INET], [SOCK_DGRAM]),\n    \"inet\": ([AF_INET, AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),\n    \"inet4\": ([AF_INET], [SOCK_STREAM, SOCK_DGRAM]),\n    \"inet6\": ([AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),\n}\n\nif AF_INET6 is not None:\n    conn_tmap.update({\n        \"tcp6\": ([AF_INET6], [SOCK_STREAM]),\n        \"udp6\": ([AF_INET6], [SOCK_DGRAM]),\n    })\n\nif AF_UNIX is not None:\n    conn_tmap.update({\"unix\": ([AF_UNIX], [SOCK_STREAM, SOCK_DGRAM])})\n\n\n# =====================================================================\n# --- Exceptions\n# =====================================================================\n\n\nclass Error(Exception):\n    \"\"\"Base exception class. All other psutil exceptions inherit\n    from this one.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def _infodict(self, attrs):\n        info = collections.OrderedDict()\n        for name in attrs:\n            value = getattr(self, name, None)\n            if value:  # noqa\n                info[name] = value\n            elif name == \"pid\" and value == 0:\n                info[name] = value\n        return info\n\n    def __str__(self):\n        # invoked on `raise Error`\n        info = self._infodict((\"pid\", \"ppid\", \"name\"))\n        if info:\n            details = \"(%s)\" % \", \".join(\n                [\"%s=%r\" % (k, v) for k, v in info.items()]\n            )\n        else:\n            details = None\n        return \" \".join([x for x in (getattr(self, \"msg\", \"\"), details) if x])\n\n    def __repr__(self):\n        # invoked on `repr(Error)`\n        info = self._infodict((\"pid\", \"ppid\", \"name\", \"seconds\", \"msg\"))\n        details = \", \".join([\"%s=%r\" % (k, v) for k, v in info.items()])\n        return \"psutil.%s(%s)\" % (self.__class__.__name__, details)\n\n\nclass NoSuchProcess(Error):\n    \"\"\"Exception raised when a process with a certain PID doesn't\n    or no longer exists.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, pid, name=None, msg=None):\n        Error.__init__(self)\n        self.pid = pid\n        self.name = name\n        self.msg = msg or \"process no longer exists\"\n\n    def __reduce__(self):\n        return (self.__class__, (self.pid, self.name, self.msg))\n\n\nclass ZombieProcess(NoSuchProcess):\n    \"\"\"Exception raised when querying a zombie process. This is\n    raised on macOS, BSD and Solaris only, and not always: depending\n    on the query the OS may be able to succeed anyway.\n    On Linux all zombie processes are querable (hence this is never\n    raised). Windows doesn't have zombie processes.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, pid, name=None, ppid=None, msg=None):\n        NoSuchProcess.__init__(self, pid, name, msg)\n        self.ppid = ppid\n        self.msg = msg or \"PID still exists but it's a zombie\"\n\n    def __reduce__(self):\n        return (self.__class__, (self.pid, self.name, self.ppid, self.msg))\n\n\nclass AccessDenied(Error):\n    \"\"\"Exception raised when permission to perform an action is denied.\"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, pid=None, name=None, msg=None):\n        Error.__init__(self)\n        self.pid = pid\n        self.name = name\n        self.msg = msg or \"\"\n\n    def __reduce__(self):\n        return (self.__class__, (self.pid, self.name, self.msg))\n\n\nclass TimeoutExpired(Error):\n    \"\"\"Raised on Process.wait(timeout) if timeout expires and process\n    is still alive.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, seconds, pid=None, name=None):\n        Error.__init__(self)\n        self.seconds = seconds\n        self.pid = pid\n        self.name = name\n        self.msg = \"timeout after %s seconds\" % seconds\n\n    def __reduce__(self):\n        return (self.__class__, (self.seconds, self.pid, self.name))\n\n\n# ===================================================================\n# --- utils\n# ===================================================================\n\n\n# This should be in _compat.py rather than here, but does not work well\n# with setup.py importing this module via a sys.path trick.\nif PY3:\n    if isinstance(__builtins__, dict):  # cpython\n        exec_ = __builtins__[\"exec\"]\n    else:  # pypy\n        exec_ = getattr(__builtins__, \"exec\")  # noqa\n\n    exec_(\"\"\"def raise_from(value, from_value):\n    try:\n        raise value from from_value\n    finally:\n        value = None\n    \"\"\")\nelse:\n\n    def raise_from(value, from_value):\n        raise value\n\n\ndef usage_percent(used, total, round_=None):\n    \"\"\"Calculate percentage usage of 'used' against 'total'.\"\"\"\n    try:\n        ret = (float(used) / total) * 100\n    except ZeroDivisionError:\n        return 0.0\n    else:\n        if round_ is not None:\n            ret = round(ret, round_)\n        return ret\n\n\ndef memoize(fun):\n    \"\"\"A simple memoize decorator for functions supporting (hashable)\n    positional arguments.\n    It also provides a cache_clear() function for clearing the cache:\n\n    >>> @memoize\n    ... def foo()\n    ...     return 1\n        ...\n    >>> foo()\n    1\n    >>> foo.cache_clear()\n    >>>\n\n    It supports:\n     - functions\n     - classes (acts as a @singleton)\n     - staticmethods\n     - classmethods\n\n    It does NOT support:\n     - methods\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = (args, frozenset(sorted(kwargs.items())))\n        try:\n            return cache[key]\n        except KeyError:\n            try:\n                ret = cache[key] = fun(*args, **kwargs)\n            except Exception as err:  # noqa: BLE001\n                raise raise_from(err, None)\n            return ret\n\n    def cache_clear():\n        \"\"\"Clear cache.\"\"\"\n        cache.clear()\n\n    cache = {}\n    wrapper.cache_clear = cache_clear\n    return wrapper\n\n\ndef memoize_when_activated(fun):\n    \"\"\"A memoize decorator which is disabled by default. It can be\n    activated and deactivated on request.\n    For efficiency reasons it can be used only against class methods\n    accepting no arguments.\n\n    >>> class Foo:\n    ...     @memoize\n    ...     def foo()\n    ...         print(1)\n    ...\n    >>> f = Foo()\n    >>> # deactivated (default)\n    >>> foo()\n    1\n    >>> foo()\n    1\n    >>>\n    >>> # activated\n    >>> foo.cache_activate(self)\n    >>> foo()\n    1\n    >>> foo()\n    >>> foo()\n    >>>\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self):\n        try:\n            # case 1: we previously entered oneshot() ctx\n            ret = self._cache[fun]\n        except AttributeError:\n            # case 2: we never entered oneshot() ctx\n            try:\n                return fun(self)\n            except Exception as err:  # noqa: BLE001\n                raise raise_from(err, None)\n        except KeyError:\n            # case 3: we entered oneshot() ctx but there's no cache\n            # for this entry yet\n            try:\n                ret = fun(self)\n            except Exception as err:  # noqa: BLE001\n                raise raise_from(err, None)\n            try:\n                self._cache[fun] = ret\n            except AttributeError:\n                # multi-threading race condition, see:\n                # https://github.com/giampaolo/psutil/issues/1948\n                pass\n        return ret\n\n    def cache_activate(proc):\n        \"\"\"Activate cache. Expects a Process instance. Cache will be\n        stored as a \"_cache\" instance attribute.\n        \"\"\"\n        proc._cache = {}\n\n    def cache_deactivate(proc):\n        \"\"\"Deactivate and clear cache.\"\"\"\n        try:\n            del proc._cache\n        except AttributeError:\n            pass\n\n    wrapper.cache_activate = cache_activate\n    wrapper.cache_deactivate = cache_deactivate\n    return wrapper\n\n\ndef isfile_strict(path):\n    \"\"\"Same as os.path.isfile() but does not swallow EACCES / EPERM\n    exceptions, see:\n    http://mail.python.org/pipermail/python-dev/2012-June/120787.html.\n    \"\"\"\n    try:\n        st = os.stat(path)\n    except OSError as err:\n        if err.errno in (errno.EPERM, errno.EACCES):\n            raise\n        return False\n    else:\n        return stat.S_ISREG(st.st_mode)\n\n\ndef path_exists_strict(path):\n    \"\"\"Same as os.path.exists() but does not swallow EACCES / EPERM\n    exceptions. See:\n    http://mail.python.org/pipermail/python-dev/2012-June/120787.html.\n    \"\"\"\n    try:\n        os.stat(path)\n    except OSError as err:\n        if err.errno in (errno.EPERM, errno.EACCES):\n            raise\n        return False\n    else:\n        return True\n\n\n@memoize\ndef supports_ipv6():\n    \"\"\"Return True if IPv6 is supported on this platform.\"\"\"\n    if not socket.has_ipv6 or AF_INET6 is None:\n        return False\n    try:\n        sock = socket.socket(AF_INET6, socket.SOCK_STREAM)\n        with contextlib.closing(sock):\n            sock.bind((\"::1\", 0))\n        return True\n    except socket.error:\n        return False\n\n\ndef parse_environ_block(data):\n    \"\"\"Parse a C environ block of environment variables into a dictionary.\"\"\"\n    # The block is usually raw data from the target process.  It might contain\n    # trailing garbage and lines that do not look like assignments.\n    ret = {}\n    pos = 0\n\n    # localize global variable to speed up access.\n    WINDOWS_ = WINDOWS\n    while True:\n        next_pos = data.find(\"\\0\", pos)\n        # nul byte at the beginning or double nul byte means finish\n        if next_pos <= pos:\n            break\n        # there might not be an equals sign\n        equal_pos = data.find(\"=\", pos, next_pos)\n        if equal_pos > pos:\n            key = data[pos:equal_pos]\n            value = data[equal_pos + 1 : next_pos]\n            # Windows expects environment variables to be uppercase only\n            if WINDOWS_:\n                key = key.upper()\n            ret[key] = value\n        pos = next_pos + 1\n\n    return ret\n\n\ndef sockfam_to_enum(num):\n    \"\"\"Convert a numeric socket family value to an IntEnum member.\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    if enum is None:\n        return num\n    else:  # pragma: no cover\n        try:\n            return socket.AddressFamily(num)\n        except ValueError:\n            return num\n\n\ndef socktype_to_enum(num):\n    \"\"\"Convert a numeric socket type value to an IntEnum member.\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    if enum is None:\n        return num\n    else:  # pragma: no cover\n        try:\n            return socket.SocketKind(num)\n        except ValueError:\n            return num\n\n\ndef conn_to_ntuple(fd, fam, type_, laddr, raddr, status, status_map, pid=None):\n    \"\"\"Convert a raw connection tuple to a proper ntuple.\"\"\"\n    if fam in (socket.AF_INET, AF_INET6):\n        if laddr:\n            laddr = addr(*laddr)\n        if raddr:\n            raddr = addr(*raddr)\n    if type_ == socket.SOCK_STREAM and fam in (AF_INET, AF_INET6):\n        status = status_map.get(status, CONN_NONE)\n    else:\n        status = CONN_NONE  # ignore whatever C returned to us\n    fam = sockfam_to_enum(fam)\n    type_ = socktype_to_enum(type_)\n    if pid is None:\n        return pconn(fd, fam, type_, laddr, raddr, status)\n    else:\n        return sconn(fd, fam, type_, laddr, raddr, status, pid)\n\n\ndef deprecated_method(replacement):\n    \"\"\"A decorator which can be used to mark a method as deprecated\n    'replcement' is the method name which will be called instead.\n    \"\"\"\n\n    def outer(fun):\n        msg = \"%s() is deprecated and will be removed; use %s() instead\" % (\n            fun.__name__,\n            replacement,\n        )\n        if fun.__doc__ is None:\n            fun.__doc__ = msg\n\n        @functools.wraps(fun)\n        def inner(self, *args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning, stacklevel=2)\n            return getattr(self, replacement)(*args, **kwargs)\n\n        return inner\n\n    return outer\n\n\nclass _WrapNumbers:\n    \"\"\"Watches numbers so that they don't overflow and wrap\n    (reset to zero).\n    \"\"\"\n\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.cache = {}\n        self.reminders = {}\n        self.reminder_keys = {}\n\n    def _add_dict(self, input_dict, name):\n        assert name not in self.cache\n        assert name not in self.reminders\n        assert name not in self.reminder_keys\n        self.cache[name] = input_dict\n        self.reminders[name] = collections.defaultdict(int)\n        self.reminder_keys[name] = collections.defaultdict(set)\n\n    def _remove_dead_reminders(self, input_dict, name):\n        \"\"\"In case the number of keys changed between calls (e.g. a\n        disk disappears) this removes the entry from self.reminders.\n        \"\"\"\n        old_dict = self.cache[name]\n        gone_keys = set(old_dict.keys()) - set(input_dict.keys())\n        for gone_key in gone_keys:\n            for remkey in self.reminder_keys[name][gone_key]:\n                del self.reminders[name][remkey]\n            del self.reminder_keys[name][gone_key]\n\n    def run(self, input_dict, name):\n        \"\"\"Cache dict and sum numbers which overflow and wrap.\n        Return an updated copy of `input_dict`.\n        \"\"\"\n        if name not in self.cache:\n            # This was the first call.\n            self._add_dict(input_dict, name)\n            return input_dict\n\n        self._remove_dead_reminders(input_dict, name)\n\n        old_dict = self.cache[name]\n        new_dict = {}\n        for key in input_dict:\n            input_tuple = input_dict[key]\n            try:\n                old_tuple = old_dict[key]\n            except KeyError:\n                # The input dict has a new key (e.g. a new disk or NIC)\n                # which didn't exist in the previous call.\n                new_dict[key] = input_tuple\n                continue\n\n            bits = []\n            for i in range(len(input_tuple)):\n                input_value = input_tuple[i]\n                old_value = old_tuple[i]\n                remkey = (key, i)\n                if input_value < old_value:\n                    # it wrapped!\n                    self.reminders[name][remkey] += old_value\n                    self.reminder_keys[name][key].add(remkey)\n                bits.append(input_value + self.reminders[name][remkey])\n\n            new_dict[key] = tuple(bits)\n\n        self.cache[name] = input_dict\n        return new_dict\n\n    def cache_clear(self, name=None):\n        \"\"\"Clear the internal cache, optionally only for function 'name'.\"\"\"\n        with self.lock:\n            if name is None:\n                self.cache.clear()\n                self.reminders.clear()\n                self.reminder_keys.clear()\n            else:\n                self.cache.pop(name, None)\n                self.reminders.pop(name, None)\n                self.reminder_keys.pop(name, None)\n\n    def cache_info(self):\n        \"\"\"Return internal cache dicts as a tuple of 3 elements.\"\"\"\n        with self.lock:\n            return (self.cache, self.reminders, self.reminder_keys)\n\n\ndef wrap_numbers(input_dict, name):\n    \"\"\"Given an `input_dict` and a function `name`, adjust the numbers\n    which \"wrap\" (restart from zero) across different calls by adding\n    \"old value\" to \"new value\" and return an updated dict.\n    \"\"\"\n    with _wn.lock:\n        return _wn.run(input_dict, name)\n\n\n_wn = _WrapNumbers()\nwrap_numbers.cache_clear = _wn.cache_clear\nwrap_numbers.cache_info = _wn.cache_info\n\n\n# The read buffer size for open() builtin. This (also) dictates how\n# much data we read(2) when iterating over file lines as in:\n#   >>> with open(file) as f:\n#   ...    for line in f:\n#   ...        ...\n# Default per-line buffer size for binary files is 1K. For text files\n# is 8K. We use a bigger buffer (32K) in order to have more consistent\n# results when reading /proc pseudo files on Linux, see:\n# https://github.com/giampaolo/psutil/issues/2050\n# On Python 2 this also speeds up the reading of big files:\n# (namely /proc/{pid}/smaps and /proc/net/*):\n# https://github.com/giampaolo/psutil/issues/708\nFILE_READ_BUFFER_SIZE = 32 * 1024\n\n\ndef open_binary(fname):\n    return open(fname, \"rb\", buffering=FILE_READ_BUFFER_SIZE)\n\n\ndef open_text(fname):\n    \"\"\"On Python 3 opens a file in text mode by using fs encoding and\n    a proper en/decoding errors handler.\n    On Python 2 this is just an alias for open(name, 'rt').\n    \"\"\"\n    if not PY3:\n        return open(fname, buffering=FILE_READ_BUFFER_SIZE)\n\n    # See:\n    # https://github.com/giampaolo/psutil/issues/675\n    # https://github.com/giampaolo/psutil/pull/733\n    fobj = open(\n        fname,\n        buffering=FILE_READ_BUFFER_SIZE,\n        encoding=ENCODING,\n        errors=ENCODING_ERRS,\n    )\n    try:\n        # Dictates per-line read(2) buffer size. Defaults is 8k. See:\n        # https://github.com/giampaolo/psutil/issues/2050#issuecomment-1013387546\n        fobj._CHUNK_SIZE = FILE_READ_BUFFER_SIZE\n    except AttributeError:\n        pass\n    except Exception:\n        fobj.close()\n        raise\n\n    return fobj\n\n\ndef cat(fname, fallback=_DEFAULT, _open=open_text):\n    \"\"\"Read entire file content and return it as a string. File is\n    opened in text mode. If specified, `fallback` is the value\n    returned in case of error, either if the file does not exist or\n    it can't be read().\n    \"\"\"\n    if fallback is _DEFAULT:\n        with _open(fname) as f:\n            return f.read()\n    else:\n        try:\n            with _open(fname) as f:\n                return f.read()\n        except (IOError, OSError):\n            return fallback\n\n\ndef bcat(fname, fallback=_DEFAULT):\n    \"\"\"Same as above but opens file in binary mode.\"\"\"\n    return cat(fname, fallback=fallback, _open=open_binary)\n\n\ndef bytes2human(n, format=\"%(value).1f%(symbol)s\"):\n    \"\"\"Used by various scripts. See: http://goo.gl/zeJZl.\n\n    >>> bytes2human(10000)\n    '9.8K'\n    >>> bytes2human(100001221)\n    '95.4M'\n    \"\"\"\n    symbols = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')\n    prefix = {}\n    for i, s in enumerate(symbols[1:]):\n        prefix[s] = 1 << (i + 1) * 10\n    for symbol in reversed(symbols[1:]):\n        if abs(n) >= prefix[symbol]:\n            value = float(n) / prefix[symbol]\n            return format % locals()\n    return format % dict(symbol=symbols[0], value=n)\n\n\ndef get_procfs_path():\n    \"\"\"Return updated psutil.PROCFS_PATH constant.\"\"\"\n    return sys.modules['psutil'].PROCFS_PATH\n\n\nif PY3:\n\n    def decode(s):\n        return s.decode(encoding=ENCODING, errors=ENCODING_ERRS)\n\nelse:\n\n    def decode(s):\n        return s\n\n\n# =====================================================================\n# --- shell utils\n# =====================================================================\n\n\n@memoize\ndef term_supports_colors(file=sys.stdout):  # pragma: no cover\n    if os.name == 'nt':\n        return True\n    try:\n        import curses\n\n        assert file.isatty()\n        curses.setupterm()\n        assert curses.tigetnum(\"colors\") > 0\n    except Exception:  # noqa: BLE001\n        return False\n    else:\n        return True\n\n\ndef hilite(s, color=None, bold=False):  # pragma: no cover\n    \"\"\"Return an highlighted version of 'string'.\"\"\"\n    if not term_supports_colors():\n        return s\n    attr = []\n    colors = dict(\n        blue='34',\n        brown='33',\n        darkgrey='30',\n        green='32',\n        grey='37',\n        lightblue='36',\n        red='91',\n        violet='35',\n        yellow='93',\n    )\n    colors[None] = '29'\n    try:\n        color = colors[color]\n    except KeyError:\n        raise ValueError(\n            \"invalid color %r; choose between %s\" % (list(colors.keys()))\n        )\n    attr.append(color)\n    if bold:\n        attr.append('1')\n    return '\\x1b[%sm%s\\x1b[0m' % (';'.join(attr), s)\n\n\ndef print_color(\n    s, color=None, bold=False, file=sys.stdout\n):  # pragma: no cover\n    \"\"\"Print a colorized version of string.\"\"\"\n    if not term_supports_colors():\n        print(s, file=file)  # NOQA\n    elif POSIX:\n        print(hilite(s, color, bold), file=file)  # NOQA\n    else:\n        import ctypes\n\n        DEFAULT_COLOR = 7\n        GetStdHandle = ctypes.windll.Kernel32.GetStdHandle\n        SetConsoleTextAttribute = (\n            ctypes.windll.Kernel32.SetConsoleTextAttribute\n        )\n\n        colors = dict(green=2, red=4, brown=6, yellow=6)\n        colors[None] = DEFAULT_COLOR\n        try:\n            color = colors[color]\n        except KeyError:\n            raise ValueError(\n                \"invalid color %r; choose between %r\"\n                % (color, list(colors.keys()))\n            )\n        if bold and color <= 7:\n            color += 8\n\n        handle_id = -12 if file is sys.stderr else -11\n        GetStdHandle.restype = ctypes.c_ulong\n        handle = GetStdHandle(handle_id)\n        SetConsoleTextAttribute(handle, color)\n        try:\n            print(s, file=file)  # NOQA\n        finally:\n            SetConsoleTextAttribute(handle, DEFAULT_COLOR)\n\n\ndef debug(msg):\n    \"\"\"If PSUTIL_DEBUG env var is set, print a debug message to stderr.\"\"\"\n    if PSUTIL_DEBUG:\n        import inspect\n\n        fname, lineno, _, _lines, _index = inspect.getframeinfo(\n            inspect.currentframe().f_back\n        )\n        if isinstance(msg, Exception):\n            if isinstance(msg, (OSError, IOError, EnvironmentError)):\n                # ...because str(exc) may contain info about the file name\n                msg = \"ignoring %s\" % msg\n            else:\n                msg = \"ignoring %r\" % msg\n        print(  # noqa\n            \"psutil-debug [%s:%s]> %s\" % (fname, lineno, msg), file=sys.stderr\n        )\n", "psutil/_psposix.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Routines common to all posix systems.\"\"\"\n\nimport glob\nimport os\nimport signal\nimport sys\nimport time\n\nfrom ._common import MACOS\nfrom ._common import TimeoutExpired\nfrom ._common import memoize\nfrom ._common import sdiskusage\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import ChildProcessError\nfrom ._compat import FileNotFoundError\nfrom ._compat import InterruptedError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import unicode\n\n\nif MACOS:\n    from . import _psutil_osx\n\n\nif PY3:\n    import enum\nelse:\n    enum = None\n\n\n__all__ = ['pid_exists', 'wait_pid', 'disk_usage', 'get_terminal_map']\n\n\ndef pid_exists(pid):\n    \"\"\"Check whether pid exists in the current process table.\"\"\"\n    if pid == 0:\n        # According to \"man 2 kill\" PID 0 has a special meaning:\n        # it refers to <<every process in the process group of the\n        # calling process>> so we don't want to go any further.\n        # If we get here it means this UNIX platform *does* have\n        # a process with id 0.\n        return True\n    try:\n        os.kill(pid, 0)\n    except ProcessLookupError:\n        return False\n    except PermissionError:\n        # EPERM clearly means there's a process to deny access to\n        return True\n    # According to \"man 2 kill\" possible error values are\n    # (EINVAL, EPERM, ESRCH)\n    else:\n        return True\n\n\n# Python 3.5 signals enum (contributed by me ^^):\n# https://bugs.python.org/issue21076\nif enum is not None and hasattr(signal, \"Signals\"):\n    Negsignal = enum.IntEnum(\n        'Negsignal', dict([(x.name, -x.value) for x in signal.Signals])\n    )\n\n    def negsig_to_enum(num):\n        \"\"\"Convert a negative signal value to an enum.\"\"\"\n        try:\n            return Negsignal(num)\n        except ValueError:\n            return num\n\nelse:  # pragma: no cover\n\n    def negsig_to_enum(num):\n        return num\n\n\ndef wait_pid(\n    pid,\n    timeout=None,\n    proc_name=None,\n    _waitpid=os.waitpid,\n    _timer=getattr(time, 'monotonic', time.time),  # noqa: B008\n    _min=min,\n    _sleep=time.sleep,\n    _pid_exists=pid_exists,\n):\n    \"\"\"Wait for a process PID to terminate.\n\n    If the process terminated normally by calling exit(3) or _exit(2),\n    or by returning from main(), the return value is the positive integer\n    passed to *exit().\n\n    If it was terminated by a signal it returns the negated value of the\n    signal which caused the termination (e.g. -SIGTERM).\n\n    If PID is not a children of os.getpid() (current process) just\n    wait until the process disappears and return None.\n\n    If PID does not exist at all return None immediately.\n\n    If *timeout* != None and process is still alive raise TimeoutExpired.\n    timeout=0 is also possible (either return immediately or raise).\n    \"\"\"\n    if pid <= 0:\n        # see \"man waitpid\"\n        msg = \"can't wait for PID 0\"\n        raise ValueError(msg)\n    interval = 0.0001\n    flags = 0\n    if timeout is not None:\n        flags |= os.WNOHANG\n        stop_at = _timer() + timeout\n\n    def sleep(interval):\n        # Sleep for some time and return a new increased interval.\n        if timeout is not None:\n            if _timer() >= stop_at:\n                raise TimeoutExpired(timeout, pid=pid, name=proc_name)\n        _sleep(interval)\n        return _min(interval * 2, 0.04)\n\n    # See: https://linux.die.net/man/2/waitpid\n    while True:\n        try:\n            retpid, status = os.waitpid(pid, flags)\n        except InterruptedError:\n            interval = sleep(interval)\n        except ChildProcessError:\n            # This has two meanings:\n            # - PID is not a child of os.getpid() in which case\n            #   we keep polling until it's gone\n            # - PID never existed in the first place\n            # In both cases we'll eventually return None as we\n            # can't determine its exit status code.\n            while _pid_exists(pid):\n                interval = sleep(interval)\n            return\n        else:\n            if retpid == 0:\n                # WNOHANG flag was used and PID is still running.\n                interval = sleep(interval)\n                continue\n\n            if os.WIFEXITED(status):\n                # Process terminated normally by calling exit(3) or _exit(2),\n                # or by returning from main(). The return value is the\n                # positive integer passed to *exit().\n                return os.WEXITSTATUS(status)\n            elif os.WIFSIGNALED(status):\n                # Process exited due to a signal. Return the negative value\n                # of that signal.\n                return negsig_to_enum(-os.WTERMSIG(status))\n            # elif os.WIFSTOPPED(status):\n            #     # Process was stopped via SIGSTOP or is being traced, and\n            #     # waitpid() was called with WUNTRACED flag. PID is still\n            #     # alive. From now on waitpid() will keep returning (0, 0)\n            #     # until the process state doesn't change.\n            #     # It may make sense to catch/enable this since stopped PIDs\n            #     # ignore SIGTERM.\n            #     interval = sleep(interval)\n            #     continue\n            # elif os.WIFCONTINUED(status):\n            #     # Process was resumed via SIGCONT and waitpid() was called\n            #     # with WCONTINUED flag.\n            #     interval = sleep(interval)\n            #     continue\n            else:\n                # Should never happen.\n                raise ValueError(\"unknown process exit status %r\" % status)\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage associated with path.\n    Note: UNIX usually reserves 5% disk space which is not accessible\n    by user. In this function \"total\" and \"used\" values reflect the\n    total and used disk space whereas \"free\" and \"percent\" represent\n    the \"free\" and \"used percent\" user disk space.\n    \"\"\"\n    if PY3:\n        st = os.statvfs(path)\n    else:  # pragma: no cover\n        # os.statvfs() does not support unicode on Python 2:\n        # - https://github.com/giampaolo/psutil/issues/416\n        # - http://bugs.python.org/issue18695\n        try:\n            st = os.statvfs(path)\n        except UnicodeEncodeError:\n            if isinstance(path, unicode):\n                try:\n                    path = path.encode(sys.getfilesystemencoding())\n                except UnicodeEncodeError:\n                    pass\n                st = os.statvfs(path)\n            else:\n                raise\n\n    # Total space which is only available to root (unless changed\n    # at system level).\n    total = st.f_blocks * st.f_frsize\n    # Remaining free space usable by root.\n    avail_to_root = st.f_bfree * st.f_frsize\n    # Remaining free space usable by user.\n    avail_to_user = st.f_bavail * st.f_frsize\n    # Total space being used in general.\n    used = total - avail_to_root\n    if MACOS:\n        # see: https://github.com/giampaolo/psutil/pull/2152\n        used = _psutil_osx.disk_usage_used(path, used)\n    # Total space which is available to user (same as 'total' but\n    # for the user).\n    total_user = used + avail_to_user\n    # User usage percent compared to the total amount of space\n    # the user can use. This number would be higher if compared\n    # to root's because the user has less space (usually -5%).\n    usage_percent_user = usage_percent(used, total_user, round_=1)\n\n    # NB: the percentage is -5% than what shown by df due to\n    # reserved blocks that we are currently not considering:\n    # https://github.com/giampaolo/psutil/issues/829#issuecomment-223750462\n    return sdiskusage(\n        total=total, used=used, free=avail_to_user, percent=usage_percent_user\n    )\n\n\n@memoize\ndef get_terminal_map():\n    \"\"\"Get a map of device-id -> path as a dict.\n    Used by Process.terminal().\n    \"\"\"\n    ret = {}\n    ls = glob.glob('/dev/tty*') + glob.glob('/dev/pts/*')\n    for name in ls:\n        assert name not in ret, name\n        try:\n            ret[os.stat(name).st_rdev] = name\n        except FileNotFoundError:\n            pass\n    return ret\n", "psutil/_psbsd.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"FreeBSD, OpenBSD and NetBSD platforms implementation.\"\"\"\n\nimport contextlib\nimport errno\nimport functools\nimport os\nfrom collections import defaultdict\nfrom collections import namedtuple\nfrom xml.etree import ElementTree\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_bsd as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import FREEBSD\nfrom ._common import NETBSD\nfrom ._common import OPENBSD\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import conn_tmap\nfrom ._common import conn_to_ntuple\nfrom ._common import debug\nfrom ._common import memoize\nfrom ._common import memoize_when_activated\nfrom ._common import usage_percent\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import which\n\n\n__extra__all__ = []\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nif FREEBSD:\n    PROC_STATUSES = {\n        cext.SIDL: _common.STATUS_IDLE,\n        cext.SRUN: _common.STATUS_RUNNING,\n        cext.SSLEEP: _common.STATUS_SLEEPING,\n        cext.SSTOP: _common.STATUS_STOPPED,\n        cext.SZOMB: _common.STATUS_ZOMBIE,\n        cext.SWAIT: _common.STATUS_WAITING,\n        cext.SLOCK: _common.STATUS_LOCKED,\n    }\nelif OPENBSD:\n    PROC_STATUSES = {\n        cext.SIDL: _common.STATUS_IDLE,\n        cext.SSLEEP: _common.STATUS_SLEEPING,\n        cext.SSTOP: _common.STATUS_STOPPED,\n        # According to /usr/include/sys/proc.h SZOMB is unused.\n        # test_zombie_process() shows that SDEAD is the right\n        # equivalent. Also it appears there's no equivalent of\n        # psutil.STATUS_DEAD. SDEAD really means STATUS_ZOMBIE.\n        # cext.SZOMB: _common.STATUS_ZOMBIE,\n        cext.SDEAD: _common.STATUS_ZOMBIE,\n        cext.SZOMB: _common.STATUS_ZOMBIE,\n        # From http://www.eecs.harvard.edu/~margo/cs161/videos/proc.h.txt\n        # OpenBSD has SRUN and SONPROC: SRUN indicates that a process\n        # is runnable but *not* yet running, i.e. is on a run queue.\n        # SONPROC indicates that the process is actually executing on\n        # a CPU, i.e. it is no longer on a run queue.\n        # As such we'll map SRUN to STATUS_WAKING and SONPROC to\n        # STATUS_RUNNING\n        cext.SRUN: _common.STATUS_WAKING,\n        cext.SONPROC: _common.STATUS_RUNNING,\n    }\nelif NETBSD:\n    PROC_STATUSES = {\n        cext.SIDL: _common.STATUS_IDLE,\n        cext.SSLEEP: _common.STATUS_SLEEPING,\n        cext.SSTOP: _common.STATUS_STOPPED,\n        cext.SZOMB: _common.STATUS_ZOMBIE,\n        cext.SRUN: _common.STATUS_WAKING,\n        cext.SONPROC: _common.STATUS_RUNNING,\n    }\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RECEIVED: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nPAGESIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\n\nHAS_PER_CPU_TIMES = hasattr(cext, \"per_cpu_times\")\nHAS_PROC_NUM_THREADS = hasattr(cext, \"proc_num_threads\")\nHAS_PROC_OPEN_FILES = hasattr(cext, 'proc_open_files')\nHAS_PROC_NUM_FDS = hasattr(cext, 'proc_num_fds')\n\nkinfo_proc_map = dict(\n    ppid=0,\n    status=1,\n    real_uid=2,\n    effective_uid=3,\n    saved_uid=4,\n    real_gid=5,\n    effective_gid=6,\n    saved_gid=7,\n    ttynr=8,\n    create_time=9,\n    ctx_switches_vol=10,\n    ctx_switches_unvol=11,\n    read_io_count=12,\n    write_io_count=13,\n    user_time=14,\n    sys_time=15,\n    ch_user_time=16,\n    ch_sys_time=17,\n    rss=18,\n    vms=19,\n    memtext=20,\n    memdata=21,\n    memstack=22,\n    cpunum=23,\n    name=24,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.virtual_memory()\nsvmem = namedtuple(\n    'svmem', ['total', 'available', 'percent', 'used', 'free',\n              'active', 'inactive', 'buffers', 'cached', 'shared', 'wired'])\n# psutil.cpu_times()\nscputimes = namedtuple(\n    'scputimes', ['user', 'nice', 'system', 'idle', 'irq'])\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms', 'text', 'data', 'stack'])\n# psutil.Process.memory_full_info()\npfullmem = pmem\n# psutil.Process.cpu_times()\npcputimes = namedtuple('pcputimes',\n                       ['user', 'system', 'children_user', 'children_system'])\n# psutil.Process.memory_maps(grouped=True)\npmmap_grouped = namedtuple(\n    'pmmap_grouped', 'path rss, private, ref_count, shadow_count')\n# psutil.Process.memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr, perms path rss, private, ref_count, shadow_count')\n# psutil.disk_io_counters()\nif FREEBSD:\n    sdiskio = namedtuple('sdiskio', ['read_count', 'write_count',\n                                     'read_bytes', 'write_bytes',\n                                     'read_time', 'write_time',\n                                     'busy_time'])\nelse:\n    sdiskio = namedtuple('sdiskio', ['read_count', 'write_count',\n                                     'read_bytes', 'write_bytes'])\n# fmt: on\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    mem = cext.virtual_mem()\n    if NETBSD:\n        total, free, active, inactive, wired, cached = mem\n        # On NetBSD buffers and shared mem is determined via /proc.\n        # The C ext set them to 0.\n        with open('/proc/meminfo', 'rb') as f:\n            for line in f:\n                if line.startswith(b'Buffers:'):\n                    buffers = int(line.split()[1]) * 1024\n                elif line.startswith(b'MemShared:'):\n                    shared = int(line.split()[1]) * 1024\n        # Before avail was calculated as (inactive + cached + free),\n        # same as zabbix, but it turned out it could exceed total (see\n        # #2233), so zabbix seems to be wrong. Htop calculates it\n        # differently, and the used value seem more realistic, so let's\n        # match htop.\n        # https://github.com/htop-dev/htop/blob/e7f447b/netbsd/NetBSDProcessList.c#L162  # noqa\n        # https://github.com/zabbix/zabbix/blob/af5e0f8/src/libs/zbxsysinfo/netbsd/memory.c#L135  # noqa\n        used = active + wired\n        avail = total - used\n    else:\n        total, free, active, inactive, wired, cached, buffers, shared = mem\n        # matches freebsd-memory CLI:\n        # * https://people.freebsd.org/~rse/dist/freebsd-memory\n        # * https://www.cyberciti.biz/files/scripts/freebsd-memory.pl.txt\n        # matches zabbix:\n        # * https://github.com/zabbix/zabbix/blob/af5e0f8/src/libs/zbxsysinfo/freebsd/memory.c#L143  # noqa\n        avail = inactive + cached + free\n        used = active + wired + cached\n\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(\n        total,\n        avail,\n        percent,\n        used,\n        free,\n        active,\n        inactive,\n        buffers,\n        cached,\n        shared,\n        wired,\n    )\n\n\ndef swap_memory():\n    \"\"\"System swap memory as (total, used, free, sin, sout) namedtuple.\"\"\"\n    total, used, free, sin, sout = cext.swap_mem()\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system per-CPU times as a namedtuple.\"\"\"\n    user, nice, system, idle, irq = cext.cpu_times()\n    return scputimes(user, nice, system, idle, irq)\n\n\nif HAS_PER_CPU_TIMES:\n\n    def per_cpu_times():\n        \"\"\"Return system CPU times as a namedtuple.\"\"\"\n        ret = []\n        for cpu_t in cext.per_cpu_times():\n            user, nice, system, idle, irq = cpu_t\n            item = scputimes(user, nice, system, idle, irq)\n            ret.append(item)\n        return ret\n\nelse:\n    # XXX\n    # Ok, this is very dirty.\n    # On FreeBSD < 8 we cannot gather per-cpu information, see:\n    # https://github.com/giampaolo/psutil/issues/226\n    # If num cpus > 1, on first call we return single cpu times to avoid a\n    # crash at psutil import time.\n    # Next calls will fail with NotImplementedError\n    def per_cpu_times():\n        \"\"\"Return system CPU times as a namedtuple.\"\"\"\n        if cpu_count_logical() == 1:\n            return [cpu_times()]\n        if per_cpu_times.__called__:\n            msg = \"supported only starting from FreeBSD 8\"\n            raise NotImplementedError(msg)\n        per_cpu_times.__called__ = True\n        return [cpu_times()]\n\n    per_cpu_times.__called__ = False\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    return cext.cpu_count_logical()\n\n\nif OPENBSD or NETBSD:\n\n    def cpu_count_cores():\n        # OpenBSD and NetBSD do not implement this.\n        return 1 if cpu_count_logical() == 1 else None\n\nelse:\n\n    def cpu_count_cores():\n        \"\"\"Return the number of CPU cores in the system.\"\"\"\n        # From the C module we'll get an XML string similar to this:\n        # http://manpages.ubuntu.com/manpages/precise/man4/smp.4freebsd.html\n        # We may get None in case \"sysctl kern.sched.topology_spec\"\n        # is not supported on this BSD version, in which case we'll mimic\n        # os.cpu_count() and return None.\n        ret = None\n        s = cext.cpu_topology()\n        if s is not None:\n            # get rid of padding chars appended at the end of the string\n            index = s.rfind(\"</groups>\")\n            if index != -1:\n                s = s[: index + 9]\n                root = ElementTree.fromstring(s)\n                try:\n                    ret = len(root.findall('group/children/group/cpu')) or None\n                finally:\n                    # needed otherwise it will memleak\n                    root.clear()\n        if not ret:\n            # If logical CPUs == 1 it's obvious we' have only 1 core.\n            if cpu_count_logical() == 1:\n                return 1\n        return ret\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    if FREEBSD:\n        # Note: the C ext is returning some metrics we are not exposing:\n        # traps.\n        ctxsw, intrs, soft_intrs, syscalls, _traps = cext.cpu_stats()\n    elif NETBSD:\n        # XXX\n        # Note about intrs: the C extension returns 0. intrs\n        # can be determined via /proc/stat; it has the same value as\n        # soft_intrs thought so the kernel is faking it (?).\n        #\n        # Note about syscalls: the C extension always sets it to 0 (?).\n        #\n        # Note: the C ext is returning some metrics we are not exposing:\n        # traps, faults and forks.\n        ctxsw, intrs, soft_intrs, syscalls, _traps, _faults, _forks = (\n            cext.cpu_stats()\n        )\n        with open('/proc/stat', 'rb') as f:\n            for line in f:\n                if line.startswith(b'intr'):\n                    intrs = int(line.split()[1])\n    elif OPENBSD:\n        # Note: the C ext is returning some metrics we are not exposing:\n        # traps, faults and forks.\n        ctxsw, intrs, soft_intrs, syscalls, _traps, _faults, _forks = (\n            cext.cpu_stats()\n        )\n    return _common.scpustats(ctxsw, intrs, soft_intrs, syscalls)\n\n\nif FREEBSD:\n\n    def cpu_freq():\n        \"\"\"Return frequency metrics for CPUs. As of Dec 2018 only\n        CPU 0 appears to be supported by FreeBSD and all other cores\n        match the frequency of CPU 0.\n        \"\"\"\n        ret = []\n        num_cpus = cpu_count_logical()\n        for cpu in range(num_cpus):\n            try:\n                current, available_freq = cext.cpu_freq(cpu)\n            except NotImplementedError:\n                continue\n            if available_freq:\n                try:\n                    min_freq = int(available_freq.split(\" \")[-1].split(\"/\")[0])\n                except (IndexError, ValueError):\n                    min_freq = None\n                try:\n                    max_freq = int(available_freq.split(\" \")[0].split(\"/\")[0])\n                except (IndexError, ValueError):\n                    max_freq = None\n            ret.append(_common.scpufreq(current, min_freq, max_freq))\n        return ret\n\nelif OPENBSD:\n\n    def cpu_freq():\n        curr = float(cext.cpu_freq())\n        return [_common.scpufreq(curr, 0.0, 0.0)]\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted disk partitions as a list of namedtuples.\n    'all' argument is ignored, see:\n    https://github.com/giampaolo/psutil/issues/906.\n    \"\"\"\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\ndisk_usage = _psposix.disk_usage\ndisk_io_counters = cext.disk_io_counters\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_io_counters = cext.net_io_counters\nnet_if_addrs = cext_posix.net_if_addrs\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    names = net_io_counters().keys()\n    ret = {}\n    for name in names:\n        try:\n            mtu = cext_posix.net_if_mtu(name)\n            flags = cext_posix.net_if_flags(name)\n            duplex, speed = cext_posix.net_if_duplex_speed(name)\n        except OSError as err:\n            # https://github.com/giampaolo/psutil/issues/1279\n            if err.errno != errno.ENODEV:\n                raise\n        else:\n            if hasattr(_common, 'NicDuplex'):\n                duplex = _common.NicDuplex(duplex)\n            output_flags = ','.join(flags)\n            isup = 'running' in flags\n            ret[name] = _common.snicstats(\n                isup, duplex, speed, mtu, output_flags\n            )\n    return ret\n\n\ndef net_connections(kind):\n    \"\"\"System-wide network connections.\"\"\"\n    if kind not in _common.conn_tmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in conn_tmap]))\n        )\n    families, types = conn_tmap[kind]\n    ret = set()\n\n    if OPENBSD:\n        rawlist = cext.net_connections(-1, families, types)\n    elif NETBSD:\n        rawlist = cext.net_connections(-1, kind)\n    else:  # FreeBSD\n        rawlist = cext.net_connections(families, types)\n\n    for item in rawlist:\n        fd, fam, type, laddr, raddr, status, pid = item\n        nt = conn_to_ntuple(\n            fd, fam, type, laddr, raddr, status, TCP_STATUSES, pid\n        )\n        ret.add(nt)\n    return list(ret)\n\n\n# =====================================================================\n#  --- sensors\n# =====================================================================\n\n\nif FREEBSD:\n\n    def sensors_battery():\n        \"\"\"Return battery info.\"\"\"\n        try:\n            percent, minsleft, power_plugged = cext.sensors_battery()\n        except NotImplementedError:\n            # See: https://github.com/giampaolo/psutil/issues/1074\n            return None\n        power_plugged = power_plugged == 1\n        if power_plugged:\n            secsleft = _common.POWER_TIME_UNLIMITED\n        elif minsleft == -1:\n            secsleft = _common.POWER_TIME_UNKNOWN\n        else:\n            secsleft = minsleft * 60\n        return _common.sbattery(percent, secsleft, power_plugged)\n\n    def sensors_temperatures():\n        \"\"\"Return CPU cores temperatures if available, else an empty dict.\"\"\"\n        ret = defaultdict(list)\n        num_cpus = cpu_count_logical()\n        for cpu in range(num_cpus):\n            try:\n                current, high = cext.sensors_cpu_temperature(cpu)\n                if high <= 0:\n                    high = None\n                name = \"Core %s\" % cpu\n                ret[\"coretemp\"].append(\n                    _common.shwtemp(name, current, high, high)\n                )\n            except NotImplementedError:\n                pass\n\n        return ret\n\n\n# =====================================================================\n#  --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, tty, hostname, tstamp, pid = item\n        if pid == -1:\n            assert OPENBSD\n            pid = None\n        if tty == '~':\n            continue  # reboot or shutdown\n        nt = _common.suser(user, tty or None, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\n@memoize\ndef _pid_0_exists():\n    try:\n        Process(0).name()\n    except NoSuchProcess:\n        return False\n    except AccessDenied:\n        return True\n    else:\n        return True\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    ret = cext.pids()\n    if OPENBSD and (0 not in ret) and _pid_0_exists():\n        # On OpenBSD the kernel does not return PID 0 (neither does\n        # ps) but it's actually querable (Process(0) will succeed).\n        ret.insert(0, 0)\n    return ret\n\n\nif NETBSD:\n\n    def pid_exists(pid):\n        exists = _psposix.pid_exists(pid)\n        if not exists:\n            # We do this because _psposix.pid_exists() lies in case of\n            # zombie processes.\n            return pid in pids()\n        else:\n            return True\n\nelif OPENBSD:\n\n    def pid_exists(pid):\n        exists = _psposix.pid_exists(pid)\n        if not exists:\n            return False\n        else:\n            # OpenBSD seems to be the only BSD platform where\n            # _psposix.pid_exists() returns True for thread IDs (tids),\n            # so we can't use it.\n            return pid in pids()\n\nelse:  # FreeBSD\n    pid_exists = _psposix.pid_exists\n\n\ndef is_zombie(pid):\n    try:\n        st = cext.proc_oneshot_info(pid)[kinfo_proc_map['status']]\n        return PROC_STATUSES.get(st) == _common.STATUS_ZOMBIE\n    except OSError:\n        return False\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which translates bare OSError exceptions into\n    NoSuchProcess and AccessDenied.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except ProcessLookupError:\n            if is_zombie(self.pid):\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n            else:\n                raise NoSuchProcess(self.pid, self._name)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n        except OSError:\n            if self.pid == 0:\n                if 0 in pids():\n                    raise AccessDenied(self.pid, self._name)\n                else:\n                    raise\n            raise\n\n    return wrapper\n\n\n@contextlib.contextmanager\ndef wrap_exceptions_procfs(inst):\n    \"\"\"Same as above, for routines relying on reading /proc fs.\"\"\"\n    try:\n        yield\n    except (ProcessLookupError, FileNotFoundError):\n        # ENOENT (no such file or directory) gets raised on open().\n        # ESRCH (no such process) can get raised on read() if\n        # process is gone in meantime.\n        if is_zombie(inst.pid):\n            raise ZombieProcess(inst.pid, inst._name, inst._ppid)\n        else:\n            raise NoSuchProcess(inst.pid, inst._name)\n    except PermissionError:\n        raise AccessDenied(inst.pid, inst._name)\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n\n    def _assert_alive(self):\n        \"\"\"Raise NSP if the process disappeared on us.\"\"\"\n        # For those C function who do not raise NSP, possibly returning\n        # incorrect or incomplete result.\n        cext.proc_name(self.pid)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def oneshot(self):\n        \"\"\"Retrieves multiple process info in one shot as a raw tuple.\"\"\"\n        ret = cext.proc_oneshot_info(self.pid)\n        assert len(ret) == len(kinfo_proc_map)\n        return ret\n\n    def oneshot_enter(self):\n        self.oneshot.cache_activate(self)\n\n    def oneshot_exit(self):\n        self.oneshot.cache_deactivate(self)\n\n    @wrap_exceptions\n    def name(self):\n        name = self.oneshot()[kinfo_proc_map['name']]\n        return name if name is not None else cext.proc_name(self.pid)\n\n    @wrap_exceptions\n    def exe(self):\n        if FREEBSD:\n            if self.pid == 0:\n                return ''  # else NSP\n            return cext.proc_exe(self.pid)\n        elif NETBSD:\n            if self.pid == 0:\n                # /proc/0 dir exists but /proc/0/exe doesn't\n                return \"\"\n            with wrap_exceptions_procfs(self):\n                return os.readlink(\"/proc/%s/exe\" % self.pid)\n        else:\n            # OpenBSD: exe cannot be determined; references:\n            # https://chromium.googlesource.com/chromium/src/base/+/\n            #     master/base_paths_posix.cc\n            # We try our best guess by using which against the first\n            # cmdline arg (may return None).\n            cmdline = self.cmdline()\n            if cmdline:\n                return which(cmdline[0]) or \"\"\n            else:\n                return \"\"\n\n    @wrap_exceptions\n    def cmdline(self):\n        if OPENBSD and self.pid == 0:\n            return []  # ...else it crashes\n        elif NETBSD:\n            # XXX - most of the times the underlying sysctl() call on\n            # NetBSD and OpenBSD returns a truncated string. Also\n            # /proc/pid/cmdline behaves the same so it looks like this\n            # is a kernel bug.\n            try:\n                return cext.proc_cmdline(self.pid)\n            except OSError as err:\n                if err.errno == errno.EINVAL:\n                    if is_zombie(self.pid):\n                        raise ZombieProcess(self.pid, self._name, self._ppid)\n                    elif not pid_exists(self.pid):\n                        raise NoSuchProcess(self.pid, self._name, self._ppid)\n                    else:\n                        # XXX: this happens with unicode tests. It means the C\n                        # routine is unable to decode invalid unicode chars.\n                        debug(\"ignoring %r and returning an empty list\" % err)\n                        return []\n                else:\n                    raise\n        else:\n            return cext.proc_cmdline(self.pid)\n\n    @wrap_exceptions\n    def environ(self):\n        return cext.proc_environ(self.pid)\n\n    @wrap_exceptions\n    def terminal(self):\n        tty_nr = self.oneshot()[kinfo_proc_map['ttynr']]\n        tmap = _psposix.get_terminal_map()\n        try:\n            return tmap[tty_nr]\n        except KeyError:\n            return None\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self.oneshot()[kinfo_proc_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def uids(self):\n        rawtuple = self.oneshot()\n        return _common.puids(\n            rawtuple[kinfo_proc_map['real_uid']],\n            rawtuple[kinfo_proc_map['effective_uid']],\n            rawtuple[kinfo_proc_map['saved_uid']],\n        )\n\n    @wrap_exceptions\n    def gids(self):\n        rawtuple = self.oneshot()\n        return _common.pgids(\n            rawtuple[kinfo_proc_map['real_gid']],\n            rawtuple[kinfo_proc_map['effective_gid']],\n            rawtuple[kinfo_proc_map['saved_gid']],\n        )\n\n    @wrap_exceptions\n    def cpu_times(self):\n        rawtuple = self.oneshot()\n        return _common.pcputimes(\n            rawtuple[kinfo_proc_map['user_time']],\n            rawtuple[kinfo_proc_map['sys_time']],\n            rawtuple[kinfo_proc_map['ch_user_time']],\n            rawtuple[kinfo_proc_map['ch_sys_time']],\n        )\n\n    if FREEBSD:\n\n        @wrap_exceptions\n        def cpu_num(self):\n            return self.oneshot()[kinfo_proc_map['cpunum']]\n\n    @wrap_exceptions\n    def memory_info(self):\n        rawtuple = self.oneshot()\n        return pmem(\n            rawtuple[kinfo_proc_map['rss']],\n            rawtuple[kinfo_proc_map['vms']],\n            rawtuple[kinfo_proc_map['memtext']],\n            rawtuple[kinfo_proc_map['memdata']],\n            rawtuple[kinfo_proc_map['memstack']],\n        )\n\n    memory_full_info = memory_info\n\n    @wrap_exceptions\n    def create_time(self):\n        return self.oneshot()[kinfo_proc_map['create_time']]\n\n    @wrap_exceptions\n    def num_threads(self):\n        if HAS_PROC_NUM_THREADS:\n            # FreeBSD\n            return cext.proc_num_threads(self.pid)\n        else:\n            return len(self.threads())\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        rawtuple = self.oneshot()\n        return _common.pctxsw(\n            rawtuple[kinfo_proc_map['ctx_switches_vol']],\n            rawtuple[kinfo_proc_map['ctx_switches_unvol']],\n        )\n\n    @wrap_exceptions\n    def threads(self):\n        # Note: on OpenSBD this (/dev/mem) requires root access.\n        rawlist = cext.proc_threads(self.pid)\n        retlist = []\n        for thread_id, utime, stime in rawlist:\n            ntuple = _common.pthread(thread_id, utime, stime)\n            retlist.append(ntuple)\n        if OPENBSD:\n            self._assert_alive()\n        return retlist\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        if kind not in conn_tmap:\n            raise ValueError(\n                \"invalid %r kind argument; choose between %s\"\n                % (kind, ', '.join([repr(x) for x in conn_tmap]))\n            )\n        families, types = conn_tmap[kind]\n        ret = []\n\n        if NETBSD:\n            rawlist = cext.net_connections(self.pid, kind)\n        elif OPENBSD:\n            rawlist = cext.net_connections(self.pid, families, types)\n        else:\n            rawlist = cext.proc_net_connections(self.pid, families, types)\n\n        for item in rawlist:\n            fd, fam, type, laddr, raddr, status = item[:6]\n            if FREEBSD:\n                if (fam not in families) or (type not in types):\n                    continue\n            nt = conn_to_ntuple(\n                fd, fam, type, laddr, raddr, status, TCP_STATUSES\n            )\n            ret.append(nt)\n\n        self._assert_alive()\n        return ret\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    @wrap_exceptions\n    def nice_get(self):\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def status(self):\n        code = self.oneshot()[kinfo_proc_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    @wrap_exceptions\n    def io_counters(self):\n        rawtuple = self.oneshot()\n        return _common.pio(\n            rawtuple[kinfo_proc_map['read_io_count']],\n            rawtuple[kinfo_proc_map['write_io_count']],\n            -1,\n            -1,\n        )\n\n    @wrap_exceptions\n    def cwd(self):\n        \"\"\"Return process current working directory.\"\"\"\n        # sometimes we get an empty string, in which case we turn\n        # it into None\n        if OPENBSD and self.pid == 0:\n            return \"\"  # ...else it would raise EINVAL\n        elif NETBSD or HAS_PROC_OPEN_FILES:\n            # FreeBSD < 8 does not support functions based on\n            # kinfo_getfile() and kinfo_getvmmap()\n            return cext.proc_cwd(self.pid)\n        else:\n            raise NotImplementedError(\n                \"supported only starting from FreeBSD 8\" if FREEBSD else \"\"\n            )\n\n    nt_mmap_grouped = namedtuple(\n        'mmap', 'path rss, private, ref_count, shadow_count'\n    )\n    nt_mmap_ext = namedtuple(\n        'mmap', 'addr, perms path rss, private, ref_count, shadow_count'\n    )\n\n    def _not_implemented(self):\n        raise NotImplementedError\n\n    # FreeBSD < 8 does not support functions based on kinfo_getfile()\n    # and kinfo_getvmmap()\n    if HAS_PROC_OPEN_FILES:\n\n        @wrap_exceptions\n        def open_files(self):\n            \"\"\"Return files opened by process as a list of namedtuples.\"\"\"\n            rawlist = cext.proc_open_files(self.pid)\n            return [_common.popenfile(path, fd) for path, fd in rawlist]\n\n    else:\n        open_files = _not_implemented\n\n    # FreeBSD < 8 does not support functions based on kinfo_getfile()\n    # and kinfo_getvmmap()\n    if HAS_PROC_NUM_FDS:\n\n        @wrap_exceptions\n        def num_fds(self):\n            \"\"\"Return the number of file descriptors opened by this process.\"\"\"\n            ret = cext.proc_num_fds(self.pid)\n            if NETBSD:\n                self._assert_alive()\n            return ret\n\n    else:\n        num_fds = _not_implemented\n\n    # --- FreeBSD only APIs\n\n    if FREEBSD:\n\n        @wrap_exceptions\n        def cpu_affinity_get(self):\n            return cext.proc_cpu_affinity_get(self.pid)\n\n        @wrap_exceptions\n        def cpu_affinity_set(self, cpus):\n            # Pre-emptively check if CPUs are valid because the C\n            # function has a weird behavior in case of invalid CPUs,\n            # see: https://github.com/giampaolo/psutil/issues/586\n            allcpus = tuple(range(len(per_cpu_times())))\n            for cpu in cpus:\n                if cpu not in allcpus:\n                    raise ValueError(\n                        \"invalid CPU #%i (choose between %s)\" % (cpu, allcpus)\n                    )\n            try:\n                cext.proc_cpu_affinity_set(self.pid, cpus)\n            except OSError as err:\n                # 'man cpuset_setaffinity' about EDEADLK:\n                # <<the call would leave a thread without a valid CPU to run\n                # on because the set does not overlap with the thread's\n                # anonymous mask>>\n                if err.errno in (errno.EINVAL, errno.EDEADLK):\n                    for cpu in cpus:\n                        if cpu not in allcpus:\n                            raise ValueError(\n                                \"invalid CPU #%i (choose between %s)\"\n                                % (cpu, allcpus)\n                            )\n                raise\n\n        @wrap_exceptions\n        def memory_maps(self):\n            return cext.proc_memory_maps(self.pid)\n\n        @wrap_exceptions\n        def rlimit(self, resource, limits=None):\n            if limits is None:\n                return cext.proc_getrlimit(self.pid, resource)\n            else:\n                if len(limits) != 2:\n                    raise ValueError(\n                        \"second argument must be a (soft, hard) tuple, got %s\"\n                        % repr(limits)\n                    )\n                soft, hard = limits\n                return cext.proc_setrlimit(self.pid, resource, soft, hard)\n", "psutil/_pssunos.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Sun OS Solaris platform implementation.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport socket\nimport subprocess\nimport sys\nfrom collections import namedtuple\nfrom socket import AF_INET\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_posix as cext_posix\nfrom . import _psutil_sunos as cext\nfrom ._common import AF_INET6\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import debug\nfrom ._common import get_procfs_path\nfrom ._common import isfile_strict\nfrom ._common import memoize_when_activated\nfrom ._common import sockfam_to_enum\nfrom ._common import socktype_to_enum\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import b\n\n\n__extra__all__ = [\"CONN_IDLE\", \"CONN_BOUND\", \"PROCFS_PATH\"]\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nPAGE_SIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\nIS_64_BIT = sys.maxsize > 2**32\n\nCONN_IDLE = \"IDLE\"\nCONN_BOUND = \"BOUND\"\n\nPROC_STATUSES = {\n    cext.SSLEEP: _common.STATUS_SLEEPING,\n    cext.SRUN: _common.STATUS_RUNNING,\n    cext.SZOMB: _common.STATUS_ZOMBIE,\n    cext.SSTOP: _common.STATUS_STOPPED,\n    cext.SIDL: _common.STATUS_IDLE,\n    cext.SONPROC: _common.STATUS_RUNNING,  # same as run\n    cext.SWAIT: _common.STATUS_WAITING,\n}\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RCVD: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n    cext.TCPS_IDLE: CONN_IDLE,  # sunos specific\n    cext.TCPS_BOUND: CONN_BOUND,  # sunos specific\n}\n\nproc_info_map = dict(\n    ppid=0,\n    rss=1,\n    vms=2,\n    create_time=3,\n    nice=4,\n    num_threads=5,\n    status=6,\n    ttynr=7,\n    uid=8,\n    euid=9,\n    gid=10,\n    egid=11,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# psutil.cpu_times()\nscputimes = namedtuple('scputimes', ['user', 'system', 'idle', 'iowait'])\n# psutil.cpu_times(percpu=True)\npcputimes = namedtuple(\n    'pcputimes', ['user', 'system', 'children_user', 'children_system']\n)\n# psutil.virtual_memory()\nsvmem = namedtuple('svmem', ['total', 'available', 'percent', 'used', 'free'])\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms'])\npfullmem = pmem\n# psutil.Process.memory_maps(grouped=True)\npmmap_grouped = namedtuple(\n    'pmmap_grouped', ['path', 'rss', 'anonymous', 'locked']\n)\n# psutil.Process.memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr perms ' + ' '.join(pmmap_grouped._fields)\n)\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"Report virtual memory metrics.\"\"\"\n    # we could have done this with kstat, but IMHO this is good enough\n    total = os.sysconf('SC_PHYS_PAGES') * PAGE_SIZE\n    # note: there's no difference on Solaris\n    free = avail = os.sysconf('SC_AVPHYS_PAGES') * PAGE_SIZE\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return svmem(total, avail, percent, used, free)\n\n\ndef swap_memory():\n    \"\"\"Report swap memory metrics.\"\"\"\n    sin, sout = cext.swap_mem()\n    # XXX\n    # we are supposed to get total/free by doing so:\n    # http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/\n    #     usr/src/cmd/swap/swap.c\n    # ...nevertheless I can't manage to obtain the same numbers as 'swap'\n    # cmdline utility, so let's parse its output (sigh!)\n    p = subprocess.Popen(\n        [\n            '/usr/bin/env',\n            'PATH=/usr/sbin:/sbin:%s' % os.environ['PATH'],\n            'swap',\n            '-l',\n        ],\n        stdout=subprocess.PIPE,\n    )\n    stdout, _ = p.communicate()\n    if PY3:\n        stdout = stdout.decode(sys.stdout.encoding)\n    if p.returncode != 0:\n        raise RuntimeError(\"'swap -l' failed (retcode=%s)\" % p.returncode)\n\n    lines = stdout.strip().split('\\n')[1:]\n    if not lines:\n        msg = 'no swap device(s) configured'\n        raise RuntimeError(msg)\n    total = free = 0\n    for line in lines:\n        line = line.split()\n        t, f = line[3:5]\n        total += int(int(t) * 512)\n        free += int(int(f) * 512)\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(\n        total, used, free, percent, sin * PAGE_SIZE, sout * PAGE_SIZE\n    )\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system-wide CPU times as a named tuple.\"\"\"\n    ret = cext.per_cpu_times()\n    return scputimes(*[sum(x) for x in zip(*ret)])\n\n\ndef per_cpu_times():\n    \"\"\"Return system per-CPU times as a list of named tuples.\"\"\"\n    ret = cext.per_cpu_times()\n    return [scputimes(*x) for x in ret]\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_ONLN\")\n    except ValueError:\n        # mimic os.cpu_count() behavior\n        return None\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    return cext.cpu_count_cores()\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    ctx_switches, interrupts, syscalls, _traps = cext.cpu_stats()\n    soft_interrupts = 0\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_io_counters = cext.disk_io_counters\ndisk_usage = _psposix.disk_usage\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return system disk partitions.\"\"\"\n    # TODO - the filtering logic should be better checked so that\n    # it tries to reflect 'df' as much as possible\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if not all:\n            # Differently from, say, Linux, we don't have a list of\n            # common fs types so the best we can do, AFAIK, is to\n            # filter by filesystem having a total size > 0.\n            try:\n                if not disk_usage(mountpoint).total:\n                    continue\n            except OSError as err:\n                # https://github.com/giampaolo/psutil/issues/1674\n                debug(\"skipping %r: %s\" % (mountpoint, err))\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_io_counters = cext.net_io_counters\nnet_if_addrs = cext_posix.net_if_addrs\n\n\ndef net_connections(kind, _pid=-1):\n    \"\"\"Return socket connections.  If pid == -1 return system-wide\n    connections (as opposed to connections opened by one process only).\n    Only INET sockets are returned (UNIX are not).\n    \"\"\"\n    cmap = _common.conn_tmap.copy()\n    if _pid == -1:\n        cmap.pop('unix', 0)\n    if kind not in cmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in cmap]))\n        )\n    families, types = _common.conn_tmap[kind]\n    rawlist = cext.net_connections(_pid)\n    ret = set()\n    for item in rawlist:\n        fd, fam, type_, laddr, raddr, status, pid = item\n        if fam not in families:\n            continue\n        if type_ not in types:\n            continue\n        # TODO: refactor and use _common.conn_to_ntuple.\n        if fam in (AF_INET, AF_INET6):\n            if laddr:\n                laddr = _common.addr(*laddr)\n            if raddr:\n                raddr = _common.addr(*raddr)\n        status = TCP_STATUSES[status]\n        fam = sockfam_to_enum(fam)\n        type_ = socktype_to_enum(type_)\n        if _pid == -1:\n            nt = _common.sconn(fd, fam, type_, laddr, raddr, status, pid)\n        else:\n            nt = _common.pconn(fd, fam, type_, laddr, raddr, status)\n        ret.add(nt)\n    return list(ret)\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    ret = cext.net_if_stats()\n    for name, items in ret.items():\n        isup, duplex, speed, mtu = items\n        if hasattr(_common, 'NicDuplex'):\n            duplex = _common.NicDuplex(duplex)\n        ret[name] = _common.snicstats(isup, duplex, speed, mtu, '')\n    return ret\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    localhost = (':0.0', ':0')\n    for item in rawlist:\n        user, tty, hostname, tstamp, user_process, pid = item\n        # note: the underlying C function includes entries about\n        # system boot, run level and others.  We might want\n        # to use them in the future.\n        if not user_process:\n            continue\n        if hostname in localhost:\n            hostname = 'localhost'\n        nt = _common.suser(user, tty, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    return [int(x) for x in os.listdir(b(get_procfs_path())) if x.isdigit()]\n\n\ndef pid_exists(pid):\n    \"\"\"Check for the existence of a unix pid.\"\"\"\n    return _psposix.pid_exists(pid)\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Call callable into a try/except clause and translate ENOENT,\n    EACCES and EPERM in NoSuchProcess or AccessDenied exceptions.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except (FileNotFoundError, ProcessLookupError):\n            # ENOENT (no such file or directory) gets raised on open().\n            # ESRCH (no such process) can get raised on read() if\n            # process is gone in meantime.\n            if not pid_exists(self.pid):\n                raise NoSuchProcess(self.pid, self._name)\n            else:\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n        except OSError:\n            if self.pid == 0:\n                if 0 in pids():\n                    raise AccessDenied(self.pid, self._name)\n                else:\n                    raise\n            raise\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_procfs_path\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n        self._procfs_path = get_procfs_path()\n\n    def _assert_alive(self):\n        \"\"\"Raise NSP if the process disappeared on us.\"\"\"\n        # For those C function who do not raise NSP, possibly returning\n        # incorrect or incomplete result.\n        os.stat('%s/%s' % (self._procfs_path, self.pid))\n\n    def oneshot_enter(self):\n        self._proc_name_and_args.cache_activate(self)\n        self._proc_basic_info.cache_activate(self)\n        self._proc_cred.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._proc_name_and_args.cache_deactivate(self)\n        self._proc_basic_info.cache_deactivate(self)\n        self._proc_cred.cache_deactivate(self)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_name_and_args(self):\n        return cext.proc_name_and_args(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_basic_info(self):\n        if self.pid == 0 and not os.path.exists(\n            '%s/%s/psinfo' % (self._procfs_path, self.pid)\n        ):\n            raise AccessDenied(self.pid)\n        ret = cext.proc_basic_info(self.pid, self._procfs_path)\n        assert len(ret) == len(proc_info_map)\n        return ret\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_cred(self):\n        return cext.proc_cred(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def name(self):\n        # note: max len == 15\n        return self._proc_name_and_args()[0]\n\n    @wrap_exceptions\n    def exe(self):\n        try:\n            return os.readlink(\n                \"%s/%s/path/a.out\" % (self._procfs_path, self.pid)\n            )\n        except OSError:\n            pass  # continue and guess the exe name from the cmdline\n        # Will be guessed later from cmdline but we want to explicitly\n        # invoke cmdline here in order to get an AccessDenied\n        # exception if the user has not enough privileges.\n        self.cmdline()\n        return \"\"\n\n    @wrap_exceptions\n    def cmdline(self):\n        return self._proc_name_and_args()[1].split(' ')\n\n    @wrap_exceptions\n    def environ(self):\n        return cext.proc_environ(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def create_time(self):\n        return self._proc_basic_info()[proc_info_map['create_time']]\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._proc_basic_info()[proc_info_map['num_threads']]\n\n    @wrap_exceptions\n    def nice_get(self):\n        # Note #1: getpriority(3) doesn't work for realtime processes.\n        # Psinfo is what ps uses, see:\n        # https://github.com/giampaolo/psutil/issues/1194\n        return self._proc_basic_info()[proc_info_map['nice']]\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        if self.pid in (2, 3):\n            # Special case PIDs: internally setpriority(3) return ESRCH\n            # (no such process), no matter what.\n            # The process actually exists though, as it has a name,\n            # creation time, etc.\n            raise AccessDenied(self.pid, self._name)\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self._proc_basic_info()[proc_info_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def uids(self):\n        try:\n            real, effective, saved, _, _, _ = self._proc_cred()\n        except AccessDenied:\n            real = self._proc_basic_info()[proc_info_map['uid']]\n            effective = self._proc_basic_info()[proc_info_map['euid']]\n            saved = None\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def gids(self):\n        try:\n            _, _, _, real, effective, saved = self._proc_cred()\n        except AccessDenied:\n            real = self._proc_basic_info()[proc_info_map['gid']]\n            effective = self._proc_basic_info()[proc_info_map['egid']]\n            saved = None\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def cpu_times(self):\n        try:\n            times = cext.proc_cpu_times(self.pid, self._procfs_path)\n        except OSError as err:\n            if err.errno == errno.EOVERFLOW and not IS_64_BIT:\n                # We may get here if we attempt to query a 64bit process\n                # with a 32bit python.\n                # Error originates from read() and also tools like \"cat\"\n                # fail in the same way (!).\n                # Since there simply is no way to determine CPU times we\n                # return 0.0 as a fallback. See:\n                # https://github.com/giampaolo/psutil/issues/857\n                times = (0.0, 0.0, 0.0, 0.0)\n            else:\n                raise\n        return _common.pcputimes(*times)\n\n    @wrap_exceptions\n    def cpu_num(self):\n        return cext.proc_cpu_num(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def terminal(self):\n        procfs_path = self._procfs_path\n        hit_enoent = False\n        tty = wrap_exceptions(self._proc_basic_info()[proc_info_map['ttynr']])\n        if tty != cext.PRNODEV:\n            for x in (0, 1, 2, 255):\n                try:\n                    return os.readlink(\n                        '%s/%d/path/%d' % (procfs_path, self.pid, x)\n                    )\n                except FileNotFoundError:\n                    hit_enoent = True\n                    continue\n        if hit_enoent:\n            self._assert_alive()\n\n    @wrap_exceptions\n    def cwd(self):\n        # /proc/PID/path/cwd may not be resolved by readlink() even if\n        # it exists (ls shows it). If that's the case and the process\n        # is still alive return None (we can return None also on BSD).\n        # Reference: http://goo.gl/55XgO\n        procfs_path = self._procfs_path\n        try:\n            return os.readlink(\"%s/%s/path/cwd\" % (procfs_path, self.pid))\n        except FileNotFoundError:\n            os.stat(\"%s/%s\" % (procfs_path, self.pid))  # raise NSP or AD\n            return \"\"\n\n    @wrap_exceptions\n    def memory_info(self):\n        ret = self._proc_basic_info()\n        rss = ret[proc_info_map['rss']] * 1024\n        vms = ret[proc_info_map['vms']] * 1024\n        return pmem(rss, vms)\n\n    memory_full_info = memory_info\n\n    @wrap_exceptions\n    def status(self):\n        code = self._proc_basic_info()[proc_info_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    @wrap_exceptions\n    def threads(self):\n        procfs_path = self._procfs_path\n        ret = []\n        tids = os.listdir('%s/%d/lwp' % (procfs_path, self.pid))\n        hit_enoent = False\n        for tid in tids:\n            tid = int(tid)\n            try:\n                utime, stime = cext.query_process_thread(\n                    self.pid, tid, procfs_path\n                )\n            except EnvironmentError as err:\n                if err.errno == errno.EOVERFLOW and not IS_64_BIT:\n                    # We may get here if we attempt to query a 64bit process\n                    # with a 32bit python.\n                    # Error originates from read() and also tools like \"cat\"\n                    # fail in the same way (!).\n                    # Since there simply is no way to determine CPU times we\n                    # return 0.0 as a fallback. See:\n                    # https://github.com/giampaolo/psutil/issues/857\n                    continue\n                # ENOENT == thread gone in meantime\n                if err.errno == errno.ENOENT:\n                    hit_enoent = True\n                    continue\n                raise\n            else:\n                nt = _common.pthread(tid, utime, stime)\n                ret.append(nt)\n        if hit_enoent:\n            self._assert_alive()\n        return ret\n\n    @wrap_exceptions\n    def open_files(self):\n        retlist = []\n        hit_enoent = False\n        procfs_path = self._procfs_path\n        pathdir = '%s/%d/path' % (procfs_path, self.pid)\n        for fd in os.listdir('%s/%d/fd' % (procfs_path, self.pid)):\n            path = os.path.join(pathdir, fd)\n            if os.path.islink(path):\n                try:\n                    file = os.readlink(path)\n                except FileNotFoundError:\n                    hit_enoent = True\n                    continue\n                else:\n                    if isfile_strict(file):\n                        retlist.append(_common.popenfile(file, int(fd)))\n        if hit_enoent:\n            self._assert_alive()\n        return retlist\n\n    def _get_unix_sockets(self, pid):\n        \"\"\"Get UNIX sockets used by process by parsing 'pfiles' output.\"\"\"\n        # TODO: rewrite this in C (...but the damn netstat source code\n        # does not include this part! Argh!!)\n        cmd = [\"pfiles\", str(pid)]\n        p = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        stdout, stderr = p.communicate()\n        if PY3:\n            stdout, stderr = (\n                x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n            )\n        if p.returncode != 0:\n            if 'permission denied' in stderr.lower():\n                raise AccessDenied(self.pid, self._name)\n            if 'no such process' in stderr.lower():\n                raise NoSuchProcess(self.pid, self._name)\n            raise RuntimeError(\"%r command error\\n%s\" % (cmd, stderr))\n\n        lines = stdout.split('\\n')[2:]\n        for i, line in enumerate(lines):\n            line = line.lstrip()\n            if line.startswith('sockname: AF_UNIX'):\n                path = line.split(' ', 2)[2]\n                type = lines[i - 2].strip()\n                if type == 'SOCK_STREAM':\n                    type = socket.SOCK_STREAM\n                elif type == 'SOCK_DGRAM':\n                    type = socket.SOCK_DGRAM\n                else:\n                    type = -1\n                yield (-1, socket.AF_UNIX, type, path, \"\", _common.CONN_NONE)\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        ret = net_connections(kind, _pid=self.pid)\n        # The underlying C implementation retrieves all OS connections\n        # and filters them by PID.  At this point we can't tell whether\n        # an empty list means there were no connections for process or\n        # process is no longer active so we force NSP in case the PID\n        # is no longer there.\n        if not ret:\n            # will raise NSP if process is gone\n            os.stat('%s/%s' % (self._procfs_path, self.pid))\n\n        # UNIX sockets\n        if kind in ('all', 'unix'):\n            ret.extend([\n                _common.pconn(*conn)\n                for conn in self._get_unix_sockets(self.pid)\n            ])\n        return ret\n\n    nt_mmap_grouped = namedtuple('mmap', 'path rss anon locked')\n    nt_mmap_ext = namedtuple('mmap', 'addr perms path rss anon locked')\n\n    @wrap_exceptions\n    def memory_maps(self):\n        def toaddr(start, end):\n            return '%s-%s' % (\n                hex(start)[2:].strip('L'),\n                hex(end)[2:].strip('L'),\n            )\n\n        procfs_path = self._procfs_path\n        retlist = []\n        try:\n            rawlist = cext.proc_memory_maps(self.pid, procfs_path)\n        except OSError as err:\n            if err.errno == errno.EOVERFLOW and not IS_64_BIT:\n                # We may get here if we attempt to query a 64bit process\n                # with a 32bit python.\n                # Error originates from read() and also tools like \"cat\"\n                # fail in the same way (!).\n                # Since there simply is no way to determine CPU times we\n                # return 0.0 as a fallback. See:\n                # https://github.com/giampaolo/psutil/issues/857\n                return []\n            else:\n                raise\n        hit_enoent = False\n        for item in rawlist:\n            addr, addrsize, perm, name, rss, anon, locked = item\n            addr = toaddr(addr, addrsize)\n            if not name.startswith('['):\n                try:\n                    name = os.readlink(\n                        '%s/%s/path/%s' % (procfs_path, self.pid, name)\n                    )\n                except OSError as err:\n                    if err.errno == errno.ENOENT:\n                        # sometimes the link may not be resolved by\n                        # readlink() even if it exists (ls shows it).\n                        # If that's the case we just return the\n                        # unresolved link path.\n                        # This seems an inconsistency with /proc similar\n                        # to: http://goo.gl/55XgO\n                        name = '%s/%s/path/%s' % (procfs_path, self.pid, name)\n                        hit_enoent = True\n                    else:\n                        raise\n            retlist.append((addr, perm, name, rss, anon, locked))\n        if hit_enoent:\n            self._assert_alive()\n        return retlist\n\n    @wrap_exceptions\n    def num_fds(self):\n        return len(os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid)))\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        return _common.pctxsw(\n            *cext.proc_num_ctx_switches(self.pid, self._procfs_path)\n        )\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n", "psutil/_psaix.py": "# Copyright (c) 2009, Giampaolo Rodola'\n# Copyright (c) 2017, Arnon Yaari\n# All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"AIX platform implementation.\"\"\"\n\nimport functools\nimport glob\nimport os\nimport re\nimport subprocess\nimport sys\nfrom collections import namedtuple\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_aix as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import NIC_DUPLEX_FULL\nfrom ._common import NIC_DUPLEX_HALF\nfrom ._common import NIC_DUPLEX_UNKNOWN\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import conn_to_ntuple\nfrom ._common import get_procfs_path\nfrom ._common import memoize_when_activated\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\n\n\n__extra__all__ = [\"PROCFS_PATH\"]\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nHAS_THREADS = hasattr(cext, \"proc_threads\")\nHAS_NET_IO_COUNTERS = hasattr(cext, \"net_io_counters\")\nHAS_PROC_IO_COUNTERS = hasattr(cext, \"proc_io_counters\")\n\nPAGE_SIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\n\nPROC_STATUSES = {\n    cext.SIDL: _common.STATUS_IDLE,\n    cext.SZOMB: _common.STATUS_ZOMBIE,\n    cext.SACTIVE: _common.STATUS_RUNNING,\n    cext.SSWAP: _common.STATUS_RUNNING,  # TODO what status is this?\n    cext.SSTOP: _common.STATUS_STOPPED,\n}\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RCVD: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nproc_info_map = dict(\n    ppid=0,\n    rss=1,\n    vms=2,\n    create_time=3,\n    nice=4,\n    num_threads=5,\n    status=6,\n    ttynr=7,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms'])\n# psutil.Process.memory_full_info()\npfullmem = pmem\n# psutil.Process.cpu_times()\nscputimes = namedtuple('scputimes', ['user', 'system', 'idle', 'iowait'])\n# psutil.virtual_memory()\nsvmem = namedtuple('svmem', ['total', 'available', 'percent', 'used', 'free'])\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    total, avail, free, _pinned, inuse = cext.virtual_mem()\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(total, avail, percent, inuse, free)\n\n\ndef swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    total, free, sin, sout = cext.swap_mem()\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system-wide CPU times as a named tuple.\"\"\"\n    ret = cext.per_cpu_times()\n    return scputimes(*[sum(x) for x in zip(*ret)])\n\n\ndef per_cpu_times():\n    \"\"\"Return system per-CPU times as a list of named tuples.\"\"\"\n    ret = cext.per_cpu_times()\n    return [scputimes(*x) for x in ret]\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_ONLN\")\n    except ValueError:\n        # mimic os.cpu_count() behavior\n        return None\n\n\ndef cpu_count_cores():\n    cmd = [\"lsdev\", \"-Cc\", \"processor\"]\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    if PY3:\n        stdout, stderr = (\n            x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n        )\n    if p.returncode != 0:\n        raise RuntimeError(\"%r command error\\n%s\" % (cmd, stderr))\n    processors = stdout.strip().splitlines()\n    return len(processors) or None\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    ctx_switches, interrupts, soft_interrupts, syscalls = cext.cpu_stats()\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_io_counters = cext.disk_io_counters\ndisk_usage = _psposix.disk_usage\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return system disk partitions.\"\"\"\n    # TODO - the filtering logic should be better checked so that\n    # it tries to reflect 'df' as much as possible\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if not all:\n            # Differently from, say, Linux, we don't have a list of\n            # common fs types so the best we can do, AFAIK, is to\n            # filter by filesystem having a total size > 0.\n            if not disk_usage(mountpoint).total:\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_if_addrs = cext_posix.net_if_addrs\n\nif HAS_NET_IO_COUNTERS:\n    net_io_counters = cext.net_io_counters\n\n\ndef net_connections(kind, _pid=-1):\n    \"\"\"Return socket connections.  If pid == -1 return system-wide\n    connections (as opposed to connections opened by one process only).\n    \"\"\"\n    cmap = _common.conn_tmap\n    if kind not in cmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in cmap]))\n        )\n    families, types = _common.conn_tmap[kind]\n    rawlist = cext.net_connections(_pid)\n    ret = []\n    for item in rawlist:\n        fd, fam, type_, laddr, raddr, status, pid = item\n        if fam not in families:\n            continue\n        if type_ not in types:\n            continue\n        nt = conn_to_ntuple(\n            fd,\n            fam,\n            type_,\n            laddr,\n            raddr,\n            status,\n            TCP_STATUSES,\n            pid=pid if _pid == -1 else None,\n        )\n        ret.append(nt)\n    return ret\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    duplex_map = {\"Full\": NIC_DUPLEX_FULL, \"Half\": NIC_DUPLEX_HALF}\n    names = set([x[0] for x in net_if_addrs()])\n    ret = {}\n    for name in names:\n        mtu = cext_posix.net_if_mtu(name)\n        flags = cext_posix.net_if_flags(name)\n\n        # try to get speed and duplex\n        # TODO: rewrite this in C (entstat forks, so use truss -f to follow.\n        # looks like it is using an undocumented ioctl?)\n        duplex = \"\"\n        speed = 0\n        p = subprocess.Popen(\n            [\"/usr/bin/entstat\", \"-d\", name],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        stdout, stderr = p.communicate()\n        if PY3:\n            stdout, stderr = (\n                x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n            )\n        if p.returncode == 0:\n            re_result = re.search(\n                r\"Running: (\\d+) Mbps.*?(\\w+) Duplex\", stdout\n            )\n            if re_result is not None:\n                speed = int(re_result.group(1))\n                duplex = re_result.group(2)\n\n        output_flags = ','.join(flags)\n        isup = 'running' in flags\n        duplex = duplex_map.get(duplex, NIC_DUPLEX_UNKNOWN)\n        ret[name] = _common.snicstats(isup, duplex, speed, mtu, output_flags)\n    return ret\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    localhost = (':0.0', ':0')\n    for item in rawlist:\n        user, tty, hostname, tstamp, user_process, pid = item\n        # note: the underlying C function includes entries about\n        # system boot, run level and others.  We might want\n        # to use them in the future.\n        if not user_process:\n            continue\n        if hostname in localhost:\n            hostname = 'localhost'\n        nt = _common.suser(user, tty, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    return [int(x) for x in os.listdir(get_procfs_path()) if x.isdigit()]\n\n\ndef pid_exists(pid):\n    \"\"\"Check for the existence of a unix pid.\"\"\"\n    return os.path.exists(os.path.join(get_procfs_path(), str(pid), \"psinfo\"))\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Call callable into a try/except clause and translate ENOENT,\n    EACCES and EPERM in NoSuchProcess or AccessDenied exceptions.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except (FileNotFoundError, ProcessLookupError):\n            # ENOENT (no such file or directory) gets raised on open().\n            # ESRCH (no such process) can get raised on read() if\n            # process is gone in meantime.\n            if not pid_exists(self.pid):\n                raise NoSuchProcess(self.pid, self._name)\n            else:\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_procfs_path\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n        self._procfs_path = get_procfs_path()\n\n    def oneshot_enter(self):\n        self._proc_basic_info.cache_activate(self)\n        self._proc_cred.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._proc_basic_info.cache_deactivate(self)\n        self._proc_cred.cache_deactivate(self)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_basic_info(self):\n        return cext.proc_basic_info(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_cred(self):\n        return cext.proc_cred(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def name(self):\n        if self.pid == 0:\n            return \"swapper\"\n        # note: max 16 characters\n        return cext.proc_name(self.pid, self._procfs_path).rstrip(\"\\x00\")\n\n    @wrap_exceptions\n    def exe(self):\n        # there is no way to get executable path in AIX other than to guess,\n        # and guessing is more complex than what's in the wrapping class\n        cmdline = self.cmdline()\n        if not cmdline:\n            return ''\n        exe = cmdline[0]\n        if os.path.sep in exe:\n            # relative or absolute path\n            if not os.path.isabs(exe):\n                # if cwd has changed, we're out of luck - this may be wrong!\n                exe = os.path.abspath(os.path.join(self.cwd(), exe))\n            if (\n                os.path.isabs(exe)\n                and os.path.isfile(exe)\n                and os.access(exe, os.X_OK)\n            ):\n                return exe\n            # not found, move to search in PATH using basename only\n            exe = os.path.basename(exe)\n        # search for exe name PATH\n        for path in os.environ[\"PATH\"].split(\":\"):\n            possible_exe = os.path.abspath(os.path.join(path, exe))\n            if os.path.isfile(possible_exe) and os.access(\n                possible_exe, os.X_OK\n            ):\n                return possible_exe\n        return ''\n\n    @wrap_exceptions\n    def cmdline(self):\n        return cext.proc_args(self.pid)\n\n    @wrap_exceptions\n    def environ(self):\n        return cext.proc_environ(self.pid)\n\n    @wrap_exceptions\n    def create_time(self):\n        return self._proc_basic_info()[proc_info_map['create_time']]\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._proc_basic_info()[proc_info_map['num_threads']]\n\n    if HAS_THREADS:\n\n        @wrap_exceptions\n        def threads(self):\n            rawlist = cext.proc_threads(self.pid)\n            retlist = []\n            for thread_id, utime, stime in rawlist:\n                ntuple = _common.pthread(thread_id, utime, stime)\n                retlist.append(ntuple)\n            # The underlying C implementation retrieves all OS threads\n            # and filters them by PID.  At this point we can't tell whether\n            # an empty list means there were no connections for process or\n            # process is no longer active so we force NSP in case the PID\n            # is no longer there.\n            if not retlist:\n                # will raise NSP if process is gone\n                os.stat('%s/%s' % (self._procfs_path, self.pid))\n            return retlist\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        ret = net_connections(kind, _pid=self.pid)\n        # The underlying C implementation retrieves all OS connections\n        # and filters them by PID.  At this point we can't tell whether\n        # an empty list means there were no connections for process or\n        # process is no longer active so we force NSP in case the PID\n        # is no longer there.\n        if not ret:\n            # will raise NSP if process is gone\n            os.stat('%s/%s' % (self._procfs_path, self.pid))\n        return ret\n\n    @wrap_exceptions\n    def nice_get(self):\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self._proc_basic_info()[proc_info_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def uids(self):\n        real, effective, saved, _, _, _ = self._proc_cred()\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def gids(self):\n        _, _, _, real, effective, saved = self._proc_cred()\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def cpu_times(self):\n        t = cext.proc_cpu_times(self.pid, self._procfs_path)\n        return _common.pcputimes(*t)\n\n    @wrap_exceptions\n    def terminal(self):\n        ttydev = self._proc_basic_info()[proc_info_map['ttynr']]\n        # convert from 64-bit dev_t to 32-bit dev_t and then map the device\n        ttydev = ((ttydev & 0x0000FFFF00000000) >> 16) | (ttydev & 0xFFFF)\n        # try to match rdev of /dev/pts/* files ttydev\n        for dev in glob.glob(\"/dev/**/*\"):\n            if os.stat(dev).st_rdev == ttydev:\n                return dev\n        return None\n\n    @wrap_exceptions\n    def cwd(self):\n        procfs_path = self._procfs_path\n        try:\n            result = os.readlink(\"%s/%s/cwd\" % (procfs_path, self.pid))\n            return result.rstrip('/')\n        except FileNotFoundError:\n            os.stat(\"%s/%s\" % (procfs_path, self.pid))  # raise NSP or AD\n            return \"\"\n\n    @wrap_exceptions\n    def memory_info(self):\n        ret = self._proc_basic_info()\n        rss = ret[proc_info_map['rss']] * 1024\n        vms = ret[proc_info_map['vms']] * 1024\n        return pmem(rss, vms)\n\n    memory_full_info = memory_info\n\n    @wrap_exceptions\n    def status(self):\n        code = self._proc_basic_info()[proc_info_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    def open_files(self):\n        # TODO rewrite without using procfiles (stat /proc/pid/fd/* and then\n        # find matching name of the inode)\n        p = subprocess.Popen(\n            [\"/usr/bin/procfiles\", \"-n\", str(self.pid)],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        stdout, stderr = p.communicate()\n        if PY3:\n            stdout, stderr = (\n                x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n            )\n        if \"no such process\" in stderr.lower():\n            raise NoSuchProcess(self.pid, self._name)\n        procfiles = re.findall(r\"(\\d+): S_IFREG.*\\s*.*name:(.*)\\n\", stdout)\n        retlist = []\n        for fd, path in procfiles:\n            path = path.strip()\n            if path.startswith(\"//\"):\n                path = path[1:]\n            if path.lower() == \"cannot be retrieved\":\n                continue\n            retlist.append(_common.popenfile(path, int(fd)))\n        return retlist\n\n    @wrap_exceptions\n    def num_fds(self):\n        if self.pid == 0:  # no /proc/0/fd\n            return 0\n        return len(os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid)))\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        return _common.pctxsw(*cext.proc_num_ctx_switches(self.pid))\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    if HAS_PROC_IO_COUNTERS:\n\n        @wrap_exceptions\n        def io_counters(self):\n            try:\n                rc, wc, rb, wb = cext.proc_io_counters(self.pid)\n            except OSError:\n                # if process is terminated, proc_io_counters returns OSError\n                # instead of NSP\n                if not pid_exists(self.pid):\n                    raise NoSuchProcess(self.pid, self._name)\n                raise\n            return _common.pio(rc, wc, rb, wb)\n", "psutil/_pslinux.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Linux platform implementation.\"\"\"\n\nfrom __future__ import division\n\nimport base64\nimport collections\nimport errno\nimport functools\nimport glob\nimport os\nimport re\nimport socket\nimport struct\nimport sys\nimport warnings\nfrom collections import defaultdict\nfrom collections import namedtuple\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_linux as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import NIC_DUPLEX_FULL\nfrom ._common import NIC_DUPLEX_HALF\nfrom ._common import NIC_DUPLEX_UNKNOWN\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import bcat\nfrom ._common import cat\nfrom ._common import debug\nfrom ._common import decode\nfrom ._common import get_procfs_path\nfrom ._common import isfile_strict\nfrom ._common import memoize\nfrom ._common import memoize_when_activated\nfrom ._common import open_binary\nfrom ._common import open_text\nfrom ._common import parse_environ_block\nfrom ._common import path_exists_strict\nfrom ._common import supports_ipv6\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import b\nfrom ._compat import basestring\n\n\nif PY3:\n    import enum\nelse:\n    enum = None\n\n\n# fmt: off\n__extra__all__ = [\n    'PROCFS_PATH',\n    # io prio constants\n    \"IOPRIO_CLASS_NONE\", \"IOPRIO_CLASS_RT\", \"IOPRIO_CLASS_BE\",\n    \"IOPRIO_CLASS_IDLE\",\n    # connection status constants\n    \"CONN_ESTABLISHED\", \"CONN_SYN_SENT\", \"CONN_SYN_RECV\", \"CONN_FIN_WAIT1\",\n    \"CONN_FIN_WAIT2\", \"CONN_TIME_WAIT\", \"CONN_CLOSE\", \"CONN_CLOSE_WAIT\",\n    \"CONN_LAST_ACK\", \"CONN_LISTEN\", \"CONN_CLOSING\",\n]\n# fmt: on\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nPOWER_SUPPLY_PATH = \"/sys/class/power_supply\"\nHAS_PROC_SMAPS = os.path.exists('/proc/%s/smaps' % os.getpid())\nHAS_PROC_SMAPS_ROLLUP = os.path.exists('/proc/%s/smaps_rollup' % os.getpid())\nHAS_PROC_IO_PRIORITY = hasattr(cext, \"proc_ioprio_get\")\nHAS_CPU_AFFINITY = hasattr(cext, \"proc_cpu_affinity_get\")\n\n# Number of clock ticks per second\nCLOCK_TICKS = os.sysconf(\"SC_CLK_TCK\")\nPAGESIZE = cext_posix.getpagesize()\nBOOT_TIME = None  # set later\nLITTLE_ENDIAN = sys.byteorder == 'little'\n\n# \"man iostat\" states that sectors are equivalent with blocks and have\n# a size of 512 bytes. Despite this value can be queried at runtime\n# via /sys/block/{DISK}/queue/hw_sector_size and results may vary\n# between 1k, 2k, or 4k... 512 appears to be a magic constant used\n# throughout Linux source code:\n# * https://stackoverflow.com/a/38136179/376587\n# * https://lists.gt.net/linux/kernel/2241060\n# * https://github.com/giampaolo/psutil/issues/1305\n# * https://github.com/torvalds/linux/blob/\n#     4f671fe2f9523a1ea206f63fe60a7c7b3a56d5c7/include/linux/bio.h#L99\n# * https://lkml.org/lkml/2015/8/17/234\nDISK_SECTOR_SIZE = 512\n\nif enum is None:\n    AF_LINK = socket.AF_PACKET\nelse:\n    AddressFamily = enum.IntEnum(\n        'AddressFamily', {'AF_LINK': int(socket.AF_PACKET)}\n    )\n    AF_LINK = AddressFamily.AF_LINK\n\n# ioprio_* constants http://linux.die.net/man/2/ioprio_get\nif enum is None:\n    IOPRIO_CLASS_NONE = 0\n    IOPRIO_CLASS_RT = 1\n    IOPRIO_CLASS_BE = 2\n    IOPRIO_CLASS_IDLE = 3\nelse:\n\n    class IOPriority(enum.IntEnum):\n        IOPRIO_CLASS_NONE = 0\n        IOPRIO_CLASS_RT = 1\n        IOPRIO_CLASS_BE = 2\n        IOPRIO_CLASS_IDLE = 3\n\n    globals().update(IOPriority.__members__)\n\n# See:\n# https://github.com/torvalds/linux/blame/master/fs/proc/array.c\n# ...and (TASK_* constants):\n# https://github.com/torvalds/linux/blob/master/include/linux/sched.h\nPROC_STATUSES = {\n    \"R\": _common.STATUS_RUNNING,\n    \"S\": _common.STATUS_SLEEPING,\n    \"D\": _common.STATUS_DISK_SLEEP,\n    \"T\": _common.STATUS_STOPPED,\n    \"t\": _common.STATUS_TRACING_STOP,\n    \"Z\": _common.STATUS_ZOMBIE,\n    \"X\": _common.STATUS_DEAD,\n    \"x\": _common.STATUS_DEAD,\n    \"K\": _common.STATUS_WAKE_KILL,\n    \"W\": _common.STATUS_WAKING,\n    \"I\": _common.STATUS_IDLE,\n    \"P\": _common.STATUS_PARKED,\n}\n\n# https://github.com/torvalds/linux/blob/master/include/net/tcp_states.h\nTCP_STATUSES = {\n    \"01\": _common.CONN_ESTABLISHED,\n    \"02\": _common.CONN_SYN_SENT,\n    \"03\": _common.CONN_SYN_RECV,\n    \"04\": _common.CONN_FIN_WAIT1,\n    \"05\": _common.CONN_FIN_WAIT2,\n    \"06\": _common.CONN_TIME_WAIT,\n    \"07\": _common.CONN_CLOSE,\n    \"08\": _common.CONN_CLOSE_WAIT,\n    \"09\": _common.CONN_LAST_ACK,\n    \"0A\": _common.CONN_LISTEN,\n    \"0B\": _common.CONN_CLOSING,\n}\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.virtual_memory()\nsvmem = namedtuple(\n    'svmem', ['total', 'available', 'percent', 'used', 'free',\n              'active', 'inactive', 'buffers', 'cached', 'shared', 'slab'])\n# psutil.disk_io_counters()\nsdiskio = namedtuple(\n    'sdiskio', ['read_count', 'write_count',\n                'read_bytes', 'write_bytes',\n                'read_time', 'write_time',\n                'read_merged_count', 'write_merged_count',\n                'busy_time'])\n# psutil.Process().open_files()\npopenfile = namedtuple(\n    'popenfile', ['path', 'fd', 'position', 'mode', 'flags'])\n# psutil.Process().memory_info()\npmem = namedtuple('pmem', 'rss vms shared text lib data dirty')\n# psutil.Process().memory_full_info()\npfullmem = namedtuple('pfullmem', pmem._fields + ('uss', 'pss', 'swap'))\n# psutil.Process().memory_maps(grouped=True)\npmmap_grouped = namedtuple(\n    'pmmap_grouped',\n    ['path', 'rss', 'size', 'pss', 'shared_clean', 'shared_dirty',\n     'private_clean', 'private_dirty', 'referenced', 'anonymous', 'swap'])\n# psutil.Process().memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr perms ' + ' '.join(pmmap_grouped._fields))\n# psutil.Process.io_counters()\npio = namedtuple('pio', ['read_count', 'write_count',\n                         'read_bytes', 'write_bytes',\n                         'read_chars', 'write_chars'])\n# psutil.Process.cpu_times()\npcputimes = namedtuple('pcputimes',\n                       ['user', 'system', 'children_user', 'children_system',\n                        'iowait'])\n# fmt: on\n\n\n# =====================================================================\n# --- utils\n# =====================================================================\n\n\ndef readlink(path):\n    \"\"\"Wrapper around os.readlink().\"\"\"\n    assert isinstance(path, basestring), path\n    path = os.readlink(path)\n    # readlink() might return paths containing null bytes ('\\x00')\n    # resulting in \"TypeError: must be encoded string without NULL\n    # bytes, not str\" errors when the string is passed to other\n    # fs-related functions (os.*, open(), ...).\n    # Apparently everything after '\\x00' is garbage (we can have\n    # ' (deleted)', 'new' and possibly others), see:\n    # https://github.com/giampaolo/psutil/issues/717\n    path = path.split('\\x00')[0]\n    # Certain paths have ' (deleted)' appended. Usually this is\n    # bogus as the file actually exists. Even if it doesn't we\n    # don't care.\n    if path.endswith(' (deleted)') and not path_exists_strict(path):\n        path = path[:-10]\n    return path\n\n\ndef file_flags_to_mode(flags):\n    \"\"\"Convert file's open() flags into a readable string.\n    Used by Process.open_files().\n    \"\"\"\n    modes_map = {os.O_RDONLY: 'r', os.O_WRONLY: 'w', os.O_RDWR: 'w+'}\n    mode = modes_map[flags & (os.O_RDONLY | os.O_WRONLY | os.O_RDWR)]\n    if flags & os.O_APPEND:\n        mode = mode.replace('w', 'a', 1)\n    mode = mode.replace('w+', 'r+')\n    # possible values: r, w, a, r+, a+\n    return mode\n\n\ndef is_storage_device(name):\n    \"\"\"Return True if the given name refers to a root device (e.g.\n    \"sda\", \"nvme0n1\") as opposed to a logical partition (e.g.  \"sda1\",\n    \"nvme0n1p1\"). If name is a virtual device (e.g. \"loop1\", \"ram\")\n    return True.\n    \"\"\"\n    # Re-adapted from iostat source code, see:\n    # https://github.com/sysstat/sysstat/blob/\n    #     97912938cd476645b267280069e83b1c8dc0e1c7/common.c#L208\n    # Some devices may have a slash in their name (e.g. cciss/c0d0...).\n    name = name.replace('/', '!')\n    including_virtual = True\n    if including_virtual:\n        path = \"/sys/block/%s\" % name\n    else:\n        path = \"/sys/block/%s/device\" % name\n    return os.access(path, os.F_OK)\n\n\n@memoize\ndef set_scputimes_ntuple(procfs_path):\n    \"\"\"Set a namedtuple of variable fields depending on the CPU times\n    available on this Linux kernel version which may be:\n    (user, nice, system, idle, iowait, irq, softirq, [steal, [guest,\n     [guest_nice]]])\n    Used by cpu_times() function.\n    \"\"\"\n    global scputimes\n    with open_binary('%s/stat' % procfs_path) as f:\n        values = f.readline().split()[1:]\n    fields = ['user', 'nice', 'system', 'idle', 'iowait', 'irq', 'softirq']\n    vlen = len(values)\n    if vlen >= 8:\n        # Linux >= 2.6.11\n        fields.append('steal')\n    if vlen >= 9:\n        # Linux >= 2.6.24\n        fields.append('guest')\n    if vlen >= 10:\n        # Linux >= 3.2.0\n        fields.append('guest_nice')\n    scputimes = namedtuple('scputimes', fields)\n\n\ntry:\n    set_scputimes_ntuple(\"/proc\")\nexcept Exception as err:  # noqa: BLE001\n    # Don't want to crash at import time.\n    debug(\"ignoring exception on import: %r\" % err)\n    scputimes = namedtuple('scputimes', 'user system idle')(0.0, 0.0, 0.0)\n\n\n# =====================================================================\n# --- prlimit\n# =====================================================================\n\n# Backport of resource.prlimit() for Python 2. Originally this was done\n# in C, but CentOS-6 which we use to create manylinux wheels is too old\n# and does not support prlimit() syscall. As such the resulting wheel\n# would not include prlimit(), even when installed on newer systems.\n# This is the only part of psutil using ctypes.\n\nprlimit = None\ntry:\n    from resource import prlimit  # python >= 3.4\nexcept ImportError:\n    import ctypes\n\n    libc = ctypes.CDLL(None, use_errno=True)\n\n    if hasattr(libc, \"prlimit\"):\n\n        def prlimit(pid, resource_, limits=None):\n            class StructRlimit(ctypes.Structure):\n                _fields_ = [\n                    ('rlim_cur', ctypes.c_longlong),\n                    ('rlim_max', ctypes.c_longlong),\n                ]\n\n            current = StructRlimit()\n            if limits is None:\n                # get\n                ret = libc.prlimit(pid, resource_, None, ctypes.byref(current))\n            else:\n                # set\n                new = StructRlimit()\n                new.rlim_cur = limits[0]\n                new.rlim_max = limits[1]\n                ret = libc.prlimit(\n                    pid, resource_, ctypes.byref(new), ctypes.byref(current)\n                )\n\n            if ret != 0:\n                errno_ = ctypes.get_errno()\n                raise OSError(errno_, os.strerror(errno_))\n            return (current.rlim_cur, current.rlim_max)\n\n\nif prlimit is not None:\n    __extra__all__.extend(\n        [x for x in dir(cext) if x.startswith('RLIM') and x.isupper()]\n    )\n\n\n# =====================================================================\n# --- system memory\n# =====================================================================\n\n\ndef calculate_avail_vmem(mems):\n    \"\"\"Fallback for kernels < 3.14 where /proc/meminfo does not provide\n    \"MemAvailable\", see:\n    https://blog.famzah.net/2014/09/24/.\n\n    This code reimplements the algorithm outlined here:\n    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/\n        commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773\n\n    We use this function also when \"MemAvailable\" returns 0 (possibly a\n    kernel bug, see: https://github.com/giampaolo/psutil/issues/1915).\n    In that case this routine matches \"free\" CLI tool result (\"available\"\n    column).\n\n    XXX: on recent kernels this calculation may differ by ~1.5% compared\n    to \"MemAvailable:\", as it's calculated slightly differently.\n    It is still way more realistic than doing (free + cached) though.\n    See:\n    * https://gitlab.com/procps-ng/procps/issues/42\n    * https://github.com/famzah/linux-memavailable-procfs/issues/2\n    \"\"\"\n    # Note about \"fallback\" value. According to:\n    # https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/\n    #     commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773\n    # ...long ago \"available\" memory was calculated as (free + cached),\n    # We use fallback when one of these is missing from /proc/meminfo:\n    # \"Active(file)\": introduced in 2.6.28 / Dec 2008\n    # \"Inactive(file)\": introduced in 2.6.28 / Dec 2008\n    # \"SReclaimable\": introduced in 2.6.19 / Nov 2006\n    # /proc/zoneinfo: introduced in 2.6.13 / Aug 2005\n    free = mems[b'MemFree:']\n    fallback = free + mems.get(b\"Cached:\", 0)\n    try:\n        lru_active_file = mems[b'Active(file):']\n        lru_inactive_file = mems[b'Inactive(file):']\n        slab_reclaimable = mems[b'SReclaimable:']\n    except KeyError as err:\n        debug(\n            \"%s is missing from /proc/meminfo; using an approximation for \"\n            \"calculating available memory\"\n            % err.args[0]\n        )\n        return fallback\n    try:\n        f = open_binary('%s/zoneinfo' % get_procfs_path())\n    except IOError:\n        return fallback  # kernel 2.6.13\n\n    watermark_low = 0\n    with f:\n        for line in f:\n            line = line.strip()\n            if line.startswith(b'low'):\n                watermark_low += int(line.split()[1])\n    watermark_low *= PAGESIZE\n\n    avail = free - watermark_low\n    pagecache = lru_active_file + lru_inactive_file\n    pagecache -= min(pagecache / 2, watermark_low)\n    avail += pagecache\n    avail += slab_reclaimable - min(slab_reclaimable / 2.0, watermark_low)\n    return int(avail)\n\n\ndef virtual_memory():\n    \"\"\"Report virtual memory stats.\n    This implementation mimics procps-ng-3.3.12, aka \"free\" CLI tool:\n    https://gitlab.com/procps-ng/procps/blob/\n        24fd2605c51fccc375ab0287cec33aa767f06718/proc/sysinfo.c#L778-791\n    The returned values are supposed to match both \"free\" and \"vmstat -s\"\n    CLI tools.\n    \"\"\"\n    missing_fields = []\n    mems = {}\n    with open_binary('%s/meminfo' % get_procfs_path()) as f:\n        for line in f:\n            fields = line.split()\n            mems[fields[0]] = int(fields[1]) * 1024\n\n    # /proc doc states that the available fields in /proc/meminfo vary\n    # by architecture and compile options, but these 3 values are also\n    # returned by sysinfo(2); as such we assume they are always there.\n    total = mems[b'MemTotal:']\n    free = mems[b'MemFree:']\n    try:\n        buffers = mems[b'Buffers:']\n    except KeyError:\n        # https://github.com/giampaolo/psutil/issues/1010\n        buffers = 0\n        missing_fields.append('buffers')\n    try:\n        cached = mems[b\"Cached:\"]\n    except KeyError:\n        cached = 0\n        missing_fields.append('cached')\n    else:\n        # \"free\" cmdline utility sums reclaimable to cached.\n        # Older versions of procps used to add slab memory instead.\n        # This got changed in:\n        # https://gitlab.com/procps-ng/procps/commit/\n        #     05d751c4f076a2f0118b914c5e51cfbb4762ad8e\n        cached += mems.get(b\"SReclaimable:\", 0)  # since kernel 2.6.19\n\n    try:\n        shared = mems[b'Shmem:']  # since kernel 2.6.32\n    except KeyError:\n        try:\n            shared = mems[b'MemShared:']  # kernels 2.4\n        except KeyError:\n            shared = 0\n            missing_fields.append('shared')\n\n    try:\n        active = mems[b\"Active:\"]\n    except KeyError:\n        active = 0\n        missing_fields.append('active')\n\n    try:\n        inactive = mems[b\"Inactive:\"]\n    except KeyError:\n        try:\n            inactive = (\n                mems[b\"Inact_dirty:\"]\n                + mems[b\"Inact_clean:\"]\n                + mems[b\"Inact_laundry:\"]\n            )\n        except KeyError:\n            inactive = 0\n            missing_fields.append('inactive')\n\n    try:\n        slab = mems[b\"Slab:\"]\n    except KeyError:\n        slab = 0\n\n    used = total - free - cached - buffers\n    if used < 0:\n        # May be symptomatic of running within a LCX container where such\n        # values will be dramatically distorted over those of the host.\n        used = total - free\n\n    # - starting from 4.4.0 we match free's \"available\" column.\n    #   Before 4.4.0 we calculated it as (free + buffers + cached)\n    #   which matched htop.\n    # - free and htop available memory differs as per:\n    #   http://askubuntu.com/a/369589\n    #   http://unix.stackexchange.com/a/65852/168884\n    # - MemAvailable has been introduced in kernel 3.14\n    try:\n        avail = mems[b'MemAvailable:']\n    except KeyError:\n        avail = calculate_avail_vmem(mems)\n    else:\n        if avail == 0:\n            # Yes, it can happen (probably a kernel bug):\n            # https://github.com/giampaolo/psutil/issues/1915\n            # In this case \"free\" CLI tool makes an estimate. We do the same,\n            # and it matches \"free\" CLI tool.\n            avail = calculate_avail_vmem(mems)\n\n    if avail < 0:\n        avail = 0\n        missing_fields.append('available')\n    elif avail > total:\n        # If avail is greater than total or our calculation overflows,\n        # that's symptomatic of running within a LCX container where such\n        # values will be dramatically distorted over those of the host.\n        # https://gitlab.com/procps-ng/procps/blob/\n        #     24fd2605c51fccc375ab0287cec33aa767f06718/proc/sysinfo.c#L764\n        avail = free\n\n    percent = usage_percent((total - avail), total, round_=1)\n\n    # Warn about missing metrics which are set to 0.\n    if missing_fields:\n        msg = \"%s memory stats couldn't be determined and %s set to 0\" % (\n            \", \".join(missing_fields),\n            \"was\" if len(missing_fields) == 1 else \"were\",\n        )\n        warnings.warn(msg, RuntimeWarning, stacklevel=2)\n\n    return svmem(\n        total,\n        avail,\n        percent,\n        used,\n        free,\n        active,\n        inactive,\n        buffers,\n        cached,\n        shared,\n        slab,\n    )\n\n\ndef swap_memory():\n    \"\"\"Return swap memory metrics.\"\"\"\n    mems = {}\n    with open_binary('%s/meminfo' % get_procfs_path()) as f:\n        for line in f:\n            fields = line.split()\n            mems[fields[0]] = int(fields[1]) * 1024\n    # We prefer /proc/meminfo over sysinfo() syscall so that\n    # psutil.PROCFS_PATH can be used in order to allow retrieval\n    # for linux containers, see:\n    # https://github.com/giampaolo/psutil/issues/1015\n    try:\n        total = mems[b'SwapTotal:']\n        free = mems[b'SwapFree:']\n    except KeyError:\n        _, _, _, _, total, free, unit_multiplier = cext.linux_sysinfo()\n        total *= unit_multiplier\n        free *= unit_multiplier\n\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    # get pgin/pgouts\n    try:\n        f = open_binary(\"%s/vmstat\" % get_procfs_path())\n    except IOError as err:\n        # see https://github.com/giampaolo/psutil/issues/722\n        msg = (\n            \"'sin' and 'sout' swap memory stats couldn't \"\n            + \"be determined and were set to 0 (%s)\" % str(err)\n        )\n        warnings.warn(msg, RuntimeWarning, stacklevel=2)\n        sin = sout = 0\n    else:\n        with f:\n            sin = sout = None\n            for line in f:\n                # values are expressed in 4 kilo bytes, we want\n                # bytes instead\n                if line.startswith(b'pswpin'):\n                    sin = int(line.split(b' ')[1]) * 4 * 1024\n                elif line.startswith(b'pswpout'):\n                    sout = int(line.split(b' ')[1]) * 4 * 1024\n                if sin is not None and sout is not None:\n                    break\n            else:\n                # we might get here when dealing with exotic Linux\n                # flavors, see:\n                # https://github.com/giampaolo/psutil/issues/313\n                msg = \"'sin' and 'sout' swap memory stats couldn't \"\n                msg += \"be determined and were set to 0\"\n                warnings.warn(msg, RuntimeWarning, stacklevel=2)\n                sin = sout = 0\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return a named tuple representing the following system-wide\n    CPU times:\n    (user, nice, system, idle, iowait, irq, softirq [steal, [guest,\n     [guest_nice]]])\n    Last 3 fields may not be available on all Linux kernel versions.\n    \"\"\"\n    procfs_path = get_procfs_path()\n    set_scputimes_ntuple(procfs_path)\n    with open_binary('%s/stat' % procfs_path) as f:\n        values = f.readline().split()\n    fields = values[1 : len(scputimes._fields) + 1]\n    fields = [float(x) / CLOCK_TICKS for x in fields]\n    return scputimes(*fields)\n\n\ndef per_cpu_times():\n    \"\"\"Return a list of namedtuple representing the CPU times\n    for every CPU available on the system.\n    \"\"\"\n    procfs_path = get_procfs_path()\n    set_scputimes_ntuple(procfs_path)\n    cpus = []\n    with open_binary('%s/stat' % procfs_path) as f:\n        # get rid of the first line which refers to system wide CPU stats\n        f.readline()\n        for line in f:\n            if line.startswith(b'cpu'):\n                values = line.split()\n                fields = values[1 : len(scputimes._fields) + 1]\n                fields = [float(x) / CLOCK_TICKS for x in fields]\n                entry = scputimes(*fields)\n                cpus.append(entry)\n        return cpus\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_ONLN\")\n    except ValueError:\n        # as a second fallback we try to parse /proc/cpuinfo\n        num = 0\n        with open_binary('%s/cpuinfo' % get_procfs_path()) as f:\n            for line in f:\n                if line.lower().startswith(b'processor'):\n                    num += 1\n\n        # unknown format (e.g. amrel/sparc architectures), see:\n        # https://github.com/giampaolo/psutil/issues/200\n        # try to parse /proc/stat as a last resort\n        if num == 0:\n            search = re.compile(r'cpu\\d')\n            with open_text('%s/stat' % get_procfs_path()) as f:\n                for line in f:\n                    line = line.split(' ')[0]\n                    if search.match(line):\n                        num += 1\n\n        if num == 0:\n            # mimic os.cpu_count()\n            return None\n        return num\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    # Method #1\n    ls = set()\n    # These 2 files are the same but */core_cpus_list is newer while\n    # */thread_siblings_list is deprecated and may disappear in the future.\n    # https://www.kernel.org/doc/Documentation/admin-guide/cputopology.rst\n    # https://github.com/giampaolo/psutil/pull/1727#issuecomment-707624964\n    # https://lkml.org/lkml/2019/2/26/41\n    p1 = \"/sys/devices/system/cpu/cpu[0-9]*/topology/core_cpus_list\"\n    p2 = \"/sys/devices/system/cpu/cpu[0-9]*/topology/thread_siblings_list\"\n    for path in glob.glob(p1) or glob.glob(p2):\n        with open_binary(path) as f:\n            ls.add(f.read().strip())\n    result = len(ls)\n    if result != 0:\n        return result\n\n    # Method #2\n    mapping = {}\n    current_info = {}\n    with open_binary('%s/cpuinfo' % get_procfs_path()) as f:\n        for line in f:\n            line = line.strip().lower()\n            if not line:\n                # new section\n                try:\n                    mapping[current_info[b'physical id']] = current_info[\n                        b'cpu cores'\n                    ]\n                except KeyError:\n                    pass\n                current_info = {}\n            else:\n                # ongoing section\n                if line.startswith((b'physical id', b'cpu cores')):\n                    key, value = line.split(b'\\t:', 1)\n                    current_info[key] = int(value)\n\n    result = sum(mapping.values())\n    return result or None  # mimic os.cpu_count()\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    with open_binary('%s/stat' % get_procfs_path()) as f:\n        ctx_switches = None\n        interrupts = None\n        soft_interrupts = None\n        for line in f:\n            if line.startswith(b'ctxt'):\n                ctx_switches = int(line.split()[1])\n            elif line.startswith(b'intr'):\n                interrupts = int(line.split()[1])\n            elif line.startswith(b'softirq'):\n                soft_interrupts = int(line.split()[1])\n            if (\n                ctx_switches is not None\n                and soft_interrupts is not None\n                and interrupts is not None\n            ):\n                break\n    syscalls = 0\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\ndef _cpu_get_cpuinfo_freq():\n    \"\"\"Return current CPU frequency from cpuinfo if available.\"\"\"\n    ret = []\n    with open_binary('%s/cpuinfo' % get_procfs_path()) as f:\n        for line in f:\n            if line.lower().startswith(b'cpu mhz'):\n                ret.append(float(line.split(b':', 1)[1]))\n    return ret\n\n\nif os.path.exists(\"/sys/devices/system/cpu/cpufreq/policy0\") or os.path.exists(\n    \"/sys/devices/system/cpu/cpu0/cpufreq\"\n):\n\n    def cpu_freq():\n        \"\"\"Return frequency metrics for all CPUs.\n        Contrarily to other OSes, Linux updates these values in\n        real-time.\n        \"\"\"\n        cpuinfo_freqs = _cpu_get_cpuinfo_freq()\n        paths = glob.glob(\n            \"/sys/devices/system/cpu/cpufreq/policy[0-9]*\"\n        ) or glob.glob(\"/sys/devices/system/cpu/cpu[0-9]*/cpufreq\")\n        paths.sort(key=lambda x: int(re.search(r\"[0-9]+\", x).group()))\n        ret = []\n        pjoin = os.path.join\n        for i, path in enumerate(paths):\n            if len(paths) == len(cpuinfo_freqs):\n                # take cached value from cpuinfo if available, see:\n                # https://github.com/giampaolo/psutil/issues/1851\n                curr = cpuinfo_freqs[i] * 1000\n            else:\n                curr = bcat(pjoin(path, \"scaling_cur_freq\"), fallback=None)\n            if curr is None:\n                # Likely an old RedHat, see:\n                # https://github.com/giampaolo/psutil/issues/1071\n                curr = bcat(pjoin(path, \"cpuinfo_cur_freq\"), fallback=None)\n                if curr is None:\n                    online_path = (\n                        \"/sys/devices/system/cpu/cpu{}/online\".format(i)\n                    )\n                    # if cpu core is offline, set to all zeroes\n                    if cat(online_path, fallback=None) == \"0\\n\":\n                        ret.append(_common.scpufreq(0.0, 0.0, 0.0))\n                        continue\n                    msg = \"can't find current frequency file\"\n                    raise NotImplementedError(msg)\n            curr = int(curr) / 1000\n            max_ = int(bcat(pjoin(path, \"scaling_max_freq\"))) / 1000\n            min_ = int(bcat(pjoin(path, \"scaling_min_freq\"))) / 1000\n            ret.append(_common.scpufreq(curr, min_, max_))\n        return ret\n\nelse:\n\n    def cpu_freq():\n        \"\"\"Alternate implementation using /proc/cpuinfo.\n        min and max frequencies are not available and are set to None.\n        \"\"\"\n        return [_common.scpufreq(x, 0.0, 0.0) for x in _cpu_get_cpuinfo_freq()]\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_if_addrs = cext_posix.net_if_addrs\n\n\nclass _Ipv6UnsupportedError(Exception):\n    pass\n\n\nclass NetConnections:\n    \"\"\"A wrapper on top of /proc/net/* files, retrieving per-process\n    and system-wide open connections (TCP, UDP, UNIX) similarly to\n    \"netstat -an\".\n\n    Note: in case of UNIX sockets we're only able to determine the\n    local endpoint/path, not the one it's connected to.\n    According to [1] it would be possible but not easily.\n\n    [1] http://serverfault.com/a/417946\n    \"\"\"\n\n    def __init__(self):\n        # The string represents the basename of the corresponding\n        # /proc/net/{proto_name} file.\n        tcp4 = (\"tcp\", socket.AF_INET, socket.SOCK_STREAM)\n        tcp6 = (\"tcp6\", socket.AF_INET6, socket.SOCK_STREAM)\n        udp4 = (\"udp\", socket.AF_INET, socket.SOCK_DGRAM)\n        udp6 = (\"udp6\", socket.AF_INET6, socket.SOCK_DGRAM)\n        unix = (\"unix\", socket.AF_UNIX, None)\n        self.tmap = {\n            \"all\": (tcp4, tcp6, udp4, udp6, unix),\n            \"tcp\": (tcp4, tcp6),\n            \"tcp4\": (tcp4,),\n            \"tcp6\": (tcp6,),\n            \"udp\": (udp4, udp6),\n            \"udp4\": (udp4,),\n            \"udp6\": (udp6,),\n            \"unix\": (unix,),\n            \"inet\": (tcp4, tcp6, udp4, udp6),\n            \"inet4\": (tcp4, udp4),\n            \"inet6\": (tcp6, udp6),\n        }\n        self._procfs_path = None\n\n    def get_proc_inodes(self, pid):\n        inodes = defaultdict(list)\n        for fd in os.listdir(\"%s/%s/fd\" % (self._procfs_path, pid)):\n            try:\n                inode = readlink(\"%s/%s/fd/%s\" % (self._procfs_path, pid, fd))\n            except (FileNotFoundError, ProcessLookupError):\n                # ENOENT == file which is gone in the meantime;\n                # os.stat('/proc/%s' % self.pid) will be done later\n                # to force NSP (if it's the case)\n                continue\n            except OSError as err:\n                if err.errno == errno.EINVAL:\n                    # not a link\n                    continue\n                if err.errno == errno.ENAMETOOLONG:\n                    # file name too long\n                    debug(err)\n                    continue\n                raise\n            else:\n                if inode.startswith('socket:['):\n                    # the process is using a socket\n                    inode = inode[8:][:-1]\n                    inodes[inode].append((pid, int(fd)))\n        return inodes\n\n    def get_all_inodes(self):\n        inodes = {}\n        for pid in pids():\n            try:\n                inodes.update(self.get_proc_inodes(pid))\n            except (FileNotFoundError, ProcessLookupError, PermissionError):\n                # os.listdir() is gonna raise a lot of access denied\n                # exceptions in case of unprivileged user; that's fine\n                # as we'll just end up returning a connection with PID\n                # and fd set to None anyway.\n                # Both netstat -an and lsof does the same so it's\n                # unlikely we can do any better.\n                # ENOENT just means a PID disappeared on us.\n                continue\n        return inodes\n\n    @staticmethod\n    def decode_address(addr, family):\n        \"\"\"Accept an \"ip:port\" address as displayed in /proc/net/*\n        and convert it into a human readable form, like:\n\n        \"0500000A:0016\" -> (\"10.0.0.5\", 22)\n        \"0000000000000000FFFF00000100007F:9E49\" -> (\"::ffff:127.0.0.1\", 40521)\n\n        The IP address portion is a little or big endian four-byte\n        hexadecimal number; that is, the least significant byte is listed\n        first, so we need to reverse the order of the bytes to convert it\n        to an IP address.\n        The port is represented as a two-byte hexadecimal number.\n\n        Reference:\n        http://linuxdevcenter.com/pub/a/linux/2000/11/16/LinuxAdmin.html\n        \"\"\"\n        ip, port = addr.split(':')\n        port = int(port, 16)\n        # this usually refers to a local socket in listen mode with\n        # no end-points connected\n        if not port:\n            return ()\n        if PY3:\n            ip = ip.encode('ascii')\n        if family == socket.AF_INET:\n            # see: https://github.com/giampaolo/psutil/issues/201\n            if LITTLE_ENDIAN:\n                ip = socket.inet_ntop(family, base64.b16decode(ip)[::-1])\n            else:\n                ip = socket.inet_ntop(family, base64.b16decode(ip))\n        else:  # IPv6\n            ip = base64.b16decode(ip)\n            try:\n                # see: https://github.com/giampaolo/psutil/issues/201\n                if LITTLE_ENDIAN:\n                    ip = socket.inet_ntop(\n                        socket.AF_INET6,\n                        struct.pack('>4I', *struct.unpack('<4I', ip)),\n                    )\n                else:\n                    ip = socket.inet_ntop(\n                        socket.AF_INET6,\n                        struct.pack('<4I', *struct.unpack('<4I', ip)),\n                    )\n            except ValueError:\n                # see: https://github.com/giampaolo/psutil/issues/623\n                if not supports_ipv6():\n                    raise _Ipv6UnsupportedError\n                else:\n                    raise\n        return _common.addr(ip, port)\n\n    @staticmethod\n    def process_inet(file, family, type_, inodes, filter_pid=None):\n        \"\"\"Parse /proc/net/tcp* and /proc/net/udp* files.\"\"\"\n        if file.endswith('6') and not os.path.exists(file):\n            # IPv6 not supported\n            return\n        with open_text(file) as f:\n            f.readline()  # skip the first line\n            for lineno, line in enumerate(f, 1):\n                try:\n                    _, laddr, raddr, status, _, _, _, _, _, inode = (\n                        line.split()[:10]\n                    )\n                except ValueError:\n                    raise RuntimeError(\n                        \"error while parsing %s; malformed line %s %r\"\n                        % (file, lineno, line)\n                    )\n                if inode in inodes:\n                    # # We assume inet sockets are unique, so we error\n                    # # out if there are multiple references to the\n                    # # same inode. We won't do this for UNIX sockets.\n                    # if len(inodes[inode]) > 1 and family != socket.AF_UNIX:\n                    #     raise ValueError(\"ambiguous inode with multiple \"\n                    #                      \"PIDs references\")\n                    pid, fd = inodes[inode][0]\n                else:\n                    pid, fd = None, -1\n                if filter_pid is not None and filter_pid != pid:\n                    continue\n                else:\n                    if type_ == socket.SOCK_STREAM:\n                        status = TCP_STATUSES[status]\n                    else:\n                        status = _common.CONN_NONE\n                    try:\n                        laddr = NetConnections.decode_address(laddr, family)\n                        raddr = NetConnections.decode_address(raddr, family)\n                    except _Ipv6UnsupportedError:\n                        continue\n                    yield (fd, family, type_, laddr, raddr, status, pid)\n\n    @staticmethod\n    def process_unix(file, family, inodes, filter_pid=None):\n        \"\"\"Parse /proc/net/unix files.\"\"\"\n        with open_text(file) as f:\n            f.readline()  # skip the first line\n            for line in f:\n                tokens = line.split()\n                try:\n                    _, _, _, _, type_, _, inode = tokens[0:7]\n                except ValueError:\n                    if ' ' not in line:\n                        # see: https://github.com/giampaolo/psutil/issues/766\n                        continue\n                    raise RuntimeError(\n                        \"error while parsing %s; malformed line %r\"\n                        % (file, line)\n                    )\n                if inode in inodes:  # noqa\n                    # With UNIX sockets we can have a single inode\n                    # referencing many file descriptors.\n                    pairs = inodes[inode]\n                else:\n                    pairs = [(None, -1)]\n                for pid, fd in pairs:\n                    if filter_pid is not None and filter_pid != pid:\n                        continue\n                    else:\n                        path = tokens[-1] if len(tokens) == 8 else ''\n                        type_ = _common.socktype_to_enum(int(type_))\n                        # XXX: determining the remote endpoint of a\n                        # UNIX socket on Linux is not possible, see:\n                        # https://serverfault.com/questions/252723/\n                        raddr = \"\"\n                        status = _common.CONN_NONE\n                        yield (fd, family, type_, path, raddr, status, pid)\n\n    def retrieve(self, kind, pid=None):\n        if kind not in self.tmap:\n            raise ValueError(\n                \"invalid %r kind argument; choose between %s\"\n                % (kind, ', '.join([repr(x) for x in self.tmap]))\n            )\n        self._procfs_path = get_procfs_path()\n        if pid is not None:\n            inodes = self.get_proc_inodes(pid)\n            if not inodes:\n                # no connections for this process\n                return []\n        else:\n            inodes = self.get_all_inodes()\n        ret = set()\n        for proto_name, family, type_ in self.tmap[kind]:\n            path = \"%s/net/%s\" % (self._procfs_path, proto_name)\n            if family in (socket.AF_INET, socket.AF_INET6):\n                ls = self.process_inet(\n                    path, family, type_, inodes, filter_pid=pid\n                )\n            else:\n                ls = self.process_unix(path, family, inodes, filter_pid=pid)\n            for fd, family, type_, laddr, raddr, status, bound_pid in ls:\n                if pid:\n                    conn = _common.pconn(\n                        fd, family, type_, laddr, raddr, status\n                    )\n                else:\n                    conn = _common.sconn(\n                        fd, family, type_, laddr, raddr, status, bound_pid\n                    )\n                ret.add(conn)\n        return list(ret)\n\n\n_net_connections = NetConnections()\n\n\ndef net_connections(kind='inet'):\n    \"\"\"Return system-wide open connections.\"\"\"\n    return _net_connections.retrieve(kind)\n\n\ndef net_io_counters():\n    \"\"\"Return network I/O statistics for every network interface\n    installed on the system as a dict of raw tuples.\n    \"\"\"\n    with open_text(\"%s/net/dev\" % get_procfs_path()) as f:\n        lines = f.readlines()\n    retdict = {}\n    for line in lines[2:]:\n        colon = line.rfind(':')\n        assert colon > 0, repr(line)\n        name = line[:colon].strip()\n        fields = line[colon + 1 :].strip().split()\n\n        (\n            # in\n            bytes_recv,\n            packets_recv,\n            errin,\n            dropin,\n            _fifoin,  # unused\n            _framein,  # unused\n            _compressedin,  # unused\n            _multicastin,  # unused\n            # out\n            bytes_sent,\n            packets_sent,\n            errout,\n            dropout,\n            _fifoout,  # unused\n            _collisionsout,  # unused\n            _carrierout,  # unused\n            _compressedout,  # unused\n        ) = map(int, fields)\n\n        retdict[name] = (\n            bytes_sent,\n            bytes_recv,\n            packets_sent,\n            packets_recv,\n            errin,\n            errout,\n            dropin,\n            dropout,\n        )\n    return retdict\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    duplex_map = {\n        cext.DUPLEX_FULL: NIC_DUPLEX_FULL,\n        cext.DUPLEX_HALF: NIC_DUPLEX_HALF,\n        cext.DUPLEX_UNKNOWN: NIC_DUPLEX_UNKNOWN,\n    }\n    names = net_io_counters().keys()\n    ret = {}\n    for name in names:\n        try:\n            mtu = cext_posix.net_if_mtu(name)\n            flags = cext_posix.net_if_flags(name)\n            duplex, speed = cext.net_if_duplex_speed(name)\n        except OSError as err:\n            # https://github.com/giampaolo/psutil/issues/1279\n            if err.errno != errno.ENODEV:\n                raise\n            else:\n                debug(err)\n        else:\n            output_flags = ','.join(flags)\n            isup = 'running' in flags\n            ret[name] = _common.snicstats(\n                isup, duplex_map[duplex], speed, mtu, output_flags\n            )\n    return ret\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_usage = _psposix.disk_usage\n\n\ndef disk_io_counters(perdisk=False):\n    \"\"\"Return disk I/O statistics for every disk installed on the\n    system as a dict of raw tuples.\n    \"\"\"\n\n    def read_procfs():\n        # OK, this is a bit confusing. The format of /proc/diskstats can\n        # have 3 variations.\n        # On Linux 2.4 each line has always 15 fields, e.g.:\n        # \"3     0   8 hda 8 8 8 8 8 8 8 8 8 8 8\"\n        # On Linux 2.6+ each line *usually* has 14 fields, and the disk\n        # name is in another position, like this:\n        # \"3    0   hda 8 8 8 8 8 8 8 8 8 8 8\"\n        # ...unless (Linux 2.6) the line refers to a partition instead\n        # of a disk, in which case the line has less fields (7):\n        # \"3    1   hda1 8 8 8 8\"\n        # 4.18+ has 4 fields added:\n        # \"3    0   hda 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0\"\n        # 5.5 has 2 more fields.\n        # See:\n        # https://www.kernel.org/doc/Documentation/iostats.txt\n        # https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats\n        with open_text(\"%s/diskstats\" % get_procfs_path()) as f:\n            lines = f.readlines()\n        for line in lines:\n            fields = line.split()\n            flen = len(fields)\n            # fmt: off\n            if flen == 15:\n                # Linux 2.4\n                name = fields[3]\n                reads = int(fields[2])\n                (reads_merged, rbytes, rtime, writes, writes_merged,\n                    wbytes, wtime, _, busy_time, _) = map(int, fields[4:14])\n            elif flen == 14 or flen >= 18:\n                # Linux 2.6+, line referring to a disk\n                name = fields[2]\n                (reads, reads_merged, rbytes, rtime, writes, writes_merged,\n                    wbytes, wtime, _, busy_time, _) = map(int, fields[3:14])\n            elif flen == 7:\n                # Linux 2.6+, line referring to a partition\n                name = fields[2]\n                reads, rbytes, writes, wbytes = map(int, fields[3:])\n                rtime = wtime = reads_merged = writes_merged = busy_time = 0\n            else:\n                raise ValueError(\"not sure how to interpret line %r\" % line)\n            yield (name, reads, writes, rbytes, wbytes, rtime, wtime,\n                   reads_merged, writes_merged, busy_time)\n            # fmt: on\n\n    def read_sysfs():\n        for block in os.listdir('/sys/block'):\n            for root, _, files in os.walk(os.path.join('/sys/block', block)):\n                if 'stat' not in files:\n                    continue\n                with open_text(os.path.join(root, 'stat')) as f:\n                    fields = f.read().strip().split()\n                name = os.path.basename(root)\n                # fmt: off\n                (reads, reads_merged, rbytes, rtime, writes, writes_merged,\n                    wbytes, wtime, _, busy_time) = map(int, fields[:10])\n                yield (name, reads, writes, rbytes, wbytes, rtime,\n                       wtime, reads_merged, writes_merged, busy_time)\n                # fmt: on\n\n    if os.path.exists('%s/diskstats' % get_procfs_path()):\n        gen = read_procfs()\n    elif os.path.exists('/sys/block'):\n        gen = read_sysfs()\n    else:\n        raise NotImplementedError(\n            \"%s/diskstats nor /sys/block filesystem are available on this \"\n            \"system\"\n            % get_procfs_path()\n        )\n\n    retdict = {}\n    for entry in gen:\n        # fmt: off\n        (name, reads, writes, rbytes, wbytes, rtime, wtime, reads_merged,\n            writes_merged, busy_time) = entry\n        if not perdisk and not is_storage_device(name):\n            # perdisk=False means we want to calculate totals so we skip\n            # partitions (e.g. 'sda1', 'nvme0n1p1') and only include\n            # base disk devices (e.g. 'sda', 'nvme0n1'). Base disks\n            # include a total of all their partitions + some extra size\n            # of their own:\n            #     $ cat /proc/diskstats\n            #     259       0 sda 10485760 ...\n            #     259       1 sda1 5186039 ...\n            #     259       1 sda2 5082039 ...\n            # See:\n            # https://github.com/giampaolo/psutil/pull/1313\n            continue\n\n        rbytes *= DISK_SECTOR_SIZE\n        wbytes *= DISK_SECTOR_SIZE\n        retdict[name] = (reads, writes, rbytes, wbytes, rtime, wtime,\n                         reads_merged, writes_merged, busy_time)\n        # fmt: on\n\n    return retdict\n\n\nclass RootFsDeviceFinder:\n    \"\"\"disk_partitions() may return partitions with device == \"/dev/root\"\n    or \"rootfs\". This container class uses different strategies to try to\n    obtain the real device path. Resources:\n    https://bootlin.com/blog/find-root-device/\n    https://www.systutorials.com/how-to-find-the-disk-where-root-is-on-in-bash-on-linux/.\n    \"\"\"\n\n    __slots__ = ['major', 'minor']\n\n    def __init__(self):\n        dev = os.stat(\"/\").st_dev\n        self.major = os.major(dev)\n        self.minor = os.minor(dev)\n\n    def ask_proc_partitions(self):\n        with open_text(\"%s/partitions\" % get_procfs_path()) as f:\n            for line in f.readlines()[2:]:\n                fields = line.split()\n                if len(fields) < 4:  # just for extra safety\n                    continue\n                major = int(fields[0]) if fields[0].isdigit() else None\n                minor = int(fields[1]) if fields[1].isdigit() else None\n                name = fields[3]\n                if major == self.major and minor == self.minor:\n                    if name:  # just for extra safety\n                        return \"/dev/%s\" % name\n\n    def ask_sys_dev_block(self):\n        path = \"/sys/dev/block/%s:%s/uevent\" % (self.major, self.minor)\n        with open_text(path) as f:\n            for line in f:\n                if line.startswith(\"DEVNAME=\"):\n                    name = line.strip().rpartition(\"DEVNAME=\")[2]\n                    if name:  # just for extra safety\n                        return \"/dev/%s\" % name\n\n    def ask_sys_class_block(self):\n        needle = \"%s:%s\" % (self.major, self.minor)\n        files = glob.iglob(\"/sys/class/block/*/dev\")\n        for file in files:\n            try:\n                f = open_text(file)\n            except FileNotFoundError:  # race condition\n                continue\n            else:\n                with f:\n                    data = f.read().strip()\n                    if data == needle:\n                        name = os.path.basename(os.path.dirname(file))\n                        return \"/dev/%s\" % name\n\n    def find(self):\n        path = None\n        if path is None:\n            try:\n                path = self.ask_proc_partitions()\n            except (IOError, OSError) as err:\n                debug(err)\n        if path is None:\n            try:\n                path = self.ask_sys_dev_block()\n            except (IOError, OSError) as err:\n                debug(err)\n        if path is None:\n            try:\n                path = self.ask_sys_class_block()\n            except (IOError, OSError) as err:\n                debug(err)\n        # We use exists() because the \"/dev/*\" part of the path is hard\n        # coded, so we want to be sure.\n        if path is not None and os.path.exists(path):\n            return path\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted disk partitions as a list of namedtuples.\"\"\"\n    fstypes = set()\n    procfs_path = get_procfs_path()\n    if not all:\n        with open_text(\"%s/filesystems\" % procfs_path) as f:\n            for line in f:\n                line = line.strip()\n                if not line.startswith(\"nodev\"):\n                    fstypes.add(line.strip())\n                else:\n                    # ignore all lines starting with \"nodev\" except \"nodev zfs\"\n                    fstype = line.split(\"\\t\")[1]\n                    if fstype == \"zfs\":\n                        fstypes.add(\"zfs\")\n\n    # See: https://github.com/giampaolo/psutil/issues/1307\n    if procfs_path == \"/proc\" and os.path.isfile('/etc/mtab'):\n        mounts_path = os.path.realpath(\"/etc/mtab\")\n    else:\n        mounts_path = os.path.realpath(\"%s/self/mounts\" % procfs_path)\n\n    retlist = []\n    partitions = cext.disk_partitions(mounts_path)\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if device in (\"/dev/root\", \"rootfs\"):\n            device = RootFsDeviceFinder().find() or device\n        if not all:\n            if not device or fstype not in fstypes:\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n\n    return retlist\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\ndef sensors_temperatures():\n    \"\"\"Return hardware (CPU and others) temperatures as a dict\n    including hardware name, label, current, max and critical\n    temperatures.\n\n    Implementation notes:\n    - /sys/class/hwmon looks like the most recent interface to\n      retrieve this info, and this implementation relies on it\n      only (old distros will probably use something else)\n    - lm-sensors on Ubuntu 16.04 relies on /sys/class/hwmon\n    - /sys/class/thermal/thermal_zone* is another one but it's more\n      difficult to parse\n    \"\"\"\n    ret = collections.defaultdict(list)\n    basenames = glob.glob('/sys/class/hwmon/hwmon*/temp*_*')\n    # CentOS has an intermediate /device directory:\n    # https://github.com/giampaolo/psutil/issues/971\n    # https://github.com/nicolargo/glances/issues/1060\n    basenames.extend(glob.glob('/sys/class/hwmon/hwmon*/device/temp*_*'))\n    basenames = sorted(set([x.split('_')[0] for x in basenames]))\n\n    # Only add the coretemp hwmon entries if they're not already in\n    # /sys/class/hwmon/\n    # https://github.com/giampaolo/psutil/issues/1708\n    # https://github.com/giampaolo/psutil/pull/1648\n    basenames2 = glob.glob(\n        '/sys/devices/platform/coretemp.*/hwmon/hwmon*/temp*_*'\n    )\n    repl = re.compile('/sys/devices/platform/coretemp.*/hwmon/')\n    for name in basenames2:\n        altname = repl.sub('/sys/class/hwmon/', name)\n        if altname not in basenames:\n            basenames.append(name)\n\n    for base in basenames:\n        try:\n            path = base + '_input'\n            current = float(bcat(path)) / 1000.0\n            path = os.path.join(os.path.dirname(base), 'name')\n            unit_name = cat(path).strip()\n        except (IOError, OSError, ValueError):\n            # A lot of things can go wrong here, so let's just skip the\n            # whole entry. Sure thing is Linux's /sys/class/hwmon really\n            # is a stinky broken mess.\n            # https://github.com/giampaolo/psutil/issues/1009\n            # https://github.com/giampaolo/psutil/issues/1101\n            # https://github.com/giampaolo/psutil/issues/1129\n            # https://github.com/giampaolo/psutil/issues/1245\n            # https://github.com/giampaolo/psutil/issues/1323\n            continue\n\n        high = bcat(base + '_max', fallback=None)\n        critical = bcat(base + '_crit', fallback=None)\n        label = cat(base + '_label', fallback='').strip()\n\n        if high is not None:\n            try:\n                high = float(high) / 1000.0\n            except ValueError:\n                high = None\n        if critical is not None:\n            try:\n                critical = float(critical) / 1000.0\n            except ValueError:\n                critical = None\n\n        ret[unit_name].append((label, current, high, critical))\n\n    # Indication that no sensors were detected in /sys/class/hwmon/\n    if not basenames:\n        basenames = glob.glob('/sys/class/thermal/thermal_zone*')\n        basenames = sorted(set(basenames))\n\n        for base in basenames:\n            try:\n                path = os.path.join(base, 'temp')\n                current = float(bcat(path)) / 1000.0\n                path = os.path.join(base, 'type')\n                unit_name = cat(path).strip()\n            except (IOError, OSError, ValueError) as err:\n                debug(err)\n                continue\n\n            trip_paths = glob.glob(base + '/trip_point*')\n            trip_points = set([\n                '_'.join(os.path.basename(p).split('_')[0:3])\n                for p in trip_paths\n            ])\n            critical = None\n            high = None\n            for trip_point in trip_points:\n                path = os.path.join(base, trip_point + \"_type\")\n                trip_type = cat(path, fallback='').strip()\n                if trip_type == 'critical':\n                    critical = bcat(\n                        os.path.join(base, trip_point + \"_temp\"), fallback=None\n                    )\n                elif trip_type == 'high':\n                    high = bcat(\n                        os.path.join(base, trip_point + \"_temp\"), fallback=None\n                    )\n\n                if high is not None:\n                    try:\n                        high = float(high) / 1000.0\n                    except ValueError:\n                        high = None\n                if critical is not None:\n                    try:\n                        critical = float(critical) / 1000.0\n                    except ValueError:\n                        critical = None\n\n            ret[unit_name].append(('', current, high, critical))\n\n    return dict(ret)\n\n\ndef sensors_fans():\n    \"\"\"Return hardware fans info (for CPU and other peripherals) as a\n    dict including hardware label and current speed.\n\n    Implementation notes:\n    - /sys/class/hwmon looks like the most recent interface to\n      retrieve this info, and this implementation relies on it\n      only (old distros will probably use something else)\n    - lm-sensors on Ubuntu 16.04 relies on /sys/class/hwmon\n    \"\"\"\n    ret = collections.defaultdict(list)\n    basenames = glob.glob('/sys/class/hwmon/hwmon*/fan*_*')\n    if not basenames:\n        # CentOS has an intermediate /device directory:\n        # https://github.com/giampaolo/psutil/issues/971\n        basenames = glob.glob('/sys/class/hwmon/hwmon*/device/fan*_*')\n\n    basenames = sorted(set([x.split('_')[0] for x in basenames]))\n    for base in basenames:\n        try:\n            current = int(bcat(base + '_input'))\n        except (IOError, OSError) as err:\n            debug(err)\n            continue\n        unit_name = cat(os.path.join(os.path.dirname(base), 'name')).strip()\n        label = cat(base + '_label', fallback='').strip()\n        ret[unit_name].append(_common.sfan(label, current))\n\n    return dict(ret)\n\n\ndef sensors_battery():\n    \"\"\"Return battery information.\n    Implementation note: it appears /sys/class/power_supply/BAT0/\n    directory structure may vary and provide files with the same\n    meaning but under different names, see:\n    https://github.com/giampaolo/psutil/issues/966.\n    \"\"\"\n    null = object()\n\n    def multi_bcat(*paths):\n        \"\"\"Attempt to read the content of multiple files which may\n        not exist. If none of them exist return None.\n        \"\"\"\n        for path in paths:\n            ret = bcat(path, fallback=null)\n            if ret != null:\n                try:\n                    return int(ret)\n                except ValueError:\n                    return ret.strip()\n        return None\n\n    bats = [\n        x\n        for x in os.listdir(POWER_SUPPLY_PATH)\n        if x.startswith('BAT') or 'battery' in x.lower()\n    ]\n    if not bats:\n        return None\n    # Get the first available battery. Usually this is \"BAT0\", except\n    # some rare exceptions:\n    # https://github.com/giampaolo/psutil/issues/1238\n    root = os.path.join(POWER_SUPPLY_PATH, sorted(bats)[0])\n\n    # Base metrics.\n    energy_now = multi_bcat(root + \"/energy_now\", root + \"/charge_now\")\n    power_now = multi_bcat(root + \"/power_now\", root + \"/current_now\")\n    energy_full = multi_bcat(root + \"/energy_full\", root + \"/charge_full\")\n    time_to_empty = multi_bcat(root + \"/time_to_empty_now\")\n\n    # Percent. If we have energy_full the percentage will be more\n    # accurate compared to reading /capacity file (float vs. int).\n    if energy_full is not None and energy_now is not None:\n        try:\n            percent = 100.0 * energy_now / energy_full\n        except ZeroDivisionError:\n            percent = 0.0\n    else:\n        percent = int(cat(root + \"/capacity\", fallback=-1))\n        if percent == -1:\n            return None\n\n    # Is AC power cable plugged in?\n    # Note: AC0 is not always available and sometimes (e.g. CentOS7)\n    # it's called \"AC\".\n    power_plugged = None\n    online = multi_bcat(\n        os.path.join(POWER_SUPPLY_PATH, \"AC0/online\"),\n        os.path.join(POWER_SUPPLY_PATH, \"AC/online\"),\n    )\n    if online is not None:\n        power_plugged = online == 1\n    else:\n        status = cat(root + \"/status\", fallback=\"\").strip().lower()\n        if status == \"discharging\":\n            power_plugged = False\n        elif status in (\"charging\", \"full\"):\n            power_plugged = True\n\n    # Seconds left.\n    # Note to self: we may also calculate the charging ETA as per:\n    # https://github.com/thialfihar/dotfiles/blob/\n    #     013937745fd9050c30146290e8f963d65c0179e6/bin/battery.py#L55\n    if power_plugged:\n        secsleft = _common.POWER_TIME_UNLIMITED\n    elif energy_now is not None and power_now is not None:\n        try:\n            secsleft = int(energy_now / power_now * 3600)\n        except ZeroDivisionError:\n            secsleft = _common.POWER_TIME_UNKNOWN\n    elif time_to_empty is not None:\n        secsleft = int(time_to_empty * 60)\n        if secsleft < 0:\n            secsleft = _common.POWER_TIME_UNKNOWN\n    else:\n        secsleft = _common.POWER_TIME_UNKNOWN\n\n    return _common.sbattery(percent, secsleft, power_plugged)\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, tty, hostname, tstamp, pid = item\n        nt = _common.suser(user, tty or None, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\ndef boot_time():\n    \"\"\"Return the system boot time expressed in seconds since the epoch.\"\"\"\n    global BOOT_TIME\n    path = '%s/stat' % get_procfs_path()\n    with open_binary(path) as f:\n        for line in f:\n            if line.startswith(b'btime'):\n                ret = float(line.strip().split()[1])\n                BOOT_TIME = ret\n                return ret\n        raise RuntimeError(\"line 'btime' not found in %s\" % path)\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    return [int(x) for x in os.listdir(b(get_procfs_path())) if x.isdigit()]\n\n\ndef pid_exists(pid):\n    \"\"\"Check for the existence of a unix PID. Linux TIDs are not\n    supported (always return False).\n    \"\"\"\n    if not _psposix.pid_exists(pid):\n        return False\n    else:\n        # Linux's apparently does not distinguish between PIDs and TIDs\n        # (thread IDs).\n        # listdir(\"/proc\") won't show any TID (only PIDs) but\n        # os.stat(\"/proc/{tid}\") will succeed if {tid} exists.\n        # os.kill() can also be passed a TID. This is quite confusing.\n        # In here we want to enforce this distinction and support PIDs\n        # only, see:\n        # https://github.com/giampaolo/psutil/issues/687\n        try:\n            # Note: already checked that this is faster than using a\n            # regular expr. Also (a lot) faster than doing\n            # 'return pid in pids()'\n            path = \"%s/%s/status\" % (get_procfs_path(), pid)\n            with open_binary(path) as f:\n                for line in f:\n                    if line.startswith(b\"Tgid:\"):\n                        tgid = int(line.split()[1])\n                        # If tgid and pid are the same then we're\n                        # dealing with a process PID.\n                        return tgid == pid\n                raise ValueError(\"'Tgid' line not found in %s\" % path)\n        except (EnvironmentError, ValueError):\n            return pid in pids()\n\n\ndef ppid_map():\n    \"\"\"Obtain a {pid: ppid, ...} dict for all running processes in\n    one shot. Used to speed up Process.children().\n    \"\"\"\n    ret = {}\n    procfs_path = get_procfs_path()\n    for pid in pids():\n        try:\n            with open_binary(\"%s/%s/stat\" % (procfs_path, pid)) as f:\n                data = f.read()\n        except (FileNotFoundError, ProcessLookupError):\n            # Note: we should be able to access /stat for all processes\n            # aka it's unlikely we'll bump into EPERM, which is good.\n            pass\n        else:\n            rpar = data.rfind(b')')\n            dset = data[rpar + 2 :].split()\n            ppid = int(dset[1])\n            ret[pid] = ppid\n    return ret\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which translates bare OSError and IOError exceptions\n    into NoSuchProcess and AccessDenied.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n        except ProcessLookupError:\n            self._raise_if_zombie()\n            raise NoSuchProcess(self.pid, self._name)\n        except FileNotFoundError:\n            self._raise_if_zombie()\n            if not os.path.exists(\"%s/%s\" % (self._procfs_path, self.pid)):\n                raise NoSuchProcess(self.pid, self._name)\n            raise\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Linux process implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_procfs_path\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n        self._procfs_path = get_procfs_path()\n\n    def _is_zombie(self):\n        # Note: most of the times Linux is able to return info about the\n        # process even if it's a zombie, and /proc/{pid} will exist.\n        # There are some exceptions though, like exe(), cmdline() and\n        # memory_maps(). In these cases /proc/{pid}/{file} exists but\n        # it's empty. Instead of returning a \"null\" value we'll raise an\n        # exception.\n        try:\n            data = bcat(\"%s/%s/stat\" % (self._procfs_path, self.pid))\n        except (IOError, OSError):\n            return False\n        else:\n            rpar = data.rfind(b')')\n            status = data[rpar + 2 : rpar + 3]\n            return status == b\"Z\"\n\n    def _raise_if_zombie(self):\n        if self._is_zombie():\n            raise ZombieProcess(self.pid, self._name, self._ppid)\n\n    def _raise_if_not_alive(self):\n        \"\"\"Raise NSP if the process disappeared on us.\"\"\"\n        # For those C function who do not raise NSP, possibly returning\n        # incorrect or incomplete result.\n        os.stat('%s/%s' % (self._procfs_path, self.pid))\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _parse_stat_file(self):\n        \"\"\"Parse /proc/{pid}/stat file and return a dict with various\n        process info.\n        Using \"man proc\" as a reference: where \"man proc\" refers to\n        position N always subtract 3 (e.g ppid position 4 in\n        'man proc' == position 1 in here).\n        The return value is cached in case oneshot() ctx manager is\n        in use.\n        \"\"\"\n        data = bcat(\"%s/%s/stat\" % (self._procfs_path, self.pid))\n        # Process name is between parentheses. It can contain spaces and\n        # other parentheses. This is taken into account by looking for\n        # the first occurrence of \"(\" and the last occurrence of \")\".\n        rpar = data.rfind(b')')\n        name = data[data.find(b'(') + 1 : rpar]\n        fields = data[rpar + 2 :].split()\n\n        ret = {}\n        ret['name'] = name\n        ret['status'] = fields[0]\n        ret['ppid'] = fields[1]\n        ret['ttynr'] = fields[4]\n        ret['utime'] = fields[11]\n        ret['stime'] = fields[12]\n        ret['children_utime'] = fields[13]\n        ret['children_stime'] = fields[14]\n        ret['create_time'] = fields[19]\n        ret['cpu_num'] = fields[36]\n        ret['blkio_ticks'] = fields[39]  # aka 'delayacct_blkio_ticks'\n\n        return ret\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _read_status_file(self):\n        \"\"\"Read /proc/{pid}/stat file and return its content.\n        The return value is cached in case oneshot() ctx manager is\n        in use.\n        \"\"\"\n        with open_binary(\"%s/%s/status\" % (self._procfs_path, self.pid)) as f:\n            return f.read()\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _read_smaps_file(self):\n        with open_binary(\"%s/%s/smaps\" % (self._procfs_path, self.pid)) as f:\n            return f.read().strip()\n\n    def oneshot_enter(self):\n        self._parse_stat_file.cache_activate(self)\n        self._read_status_file.cache_activate(self)\n        self._read_smaps_file.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._parse_stat_file.cache_deactivate(self)\n        self._read_status_file.cache_deactivate(self)\n        self._read_smaps_file.cache_deactivate(self)\n\n    @wrap_exceptions\n    def name(self):\n        name = self._parse_stat_file()['name']\n        if PY3:\n            name = decode(name)\n        # XXX - gets changed later and probably needs refactoring\n        return name\n\n    @wrap_exceptions\n    def exe(self):\n        try:\n            return readlink(\"%s/%s/exe\" % (self._procfs_path, self.pid))\n        except (FileNotFoundError, ProcessLookupError):\n            self._raise_if_zombie()\n            # no such file error; might be raised also if the\n            # path actually exists for system processes with\n            # low pids (about 0-20)\n            if os.path.lexists(\"%s/%s\" % (self._procfs_path, self.pid)):\n                return \"\"\n            raise\n\n    @wrap_exceptions\n    def cmdline(self):\n        with open_text(\"%s/%s/cmdline\" % (self._procfs_path, self.pid)) as f:\n            data = f.read()\n        if not data:\n            # may happen in case of zombie process\n            self._raise_if_zombie()\n            return []\n        # 'man proc' states that args are separated by null bytes '\\0'\n        # and last char is supposed to be a null byte. Nevertheless\n        # some processes may change their cmdline after being started\n        # (via setproctitle() or similar), they are usually not\n        # compliant with this rule and use spaces instead. Google\n        # Chrome process is an example. See:\n        # https://github.com/giampaolo/psutil/issues/1179\n        sep = '\\x00' if data.endswith('\\x00') else ' '\n        if data.endswith(sep):\n            data = data[:-1]\n        cmdline = data.split(sep)\n        # Sometimes last char is a null byte '\\0' but the args are\n        # separated by spaces, see: https://github.com/giampaolo/psutil/\n        # issues/1179#issuecomment-552984549\n        if sep == '\\x00' and len(cmdline) == 1 and ' ' in data:\n            cmdline = data.split(' ')\n        return cmdline\n\n    @wrap_exceptions\n    def environ(self):\n        with open_text(\"%s/%s/environ\" % (self._procfs_path, self.pid)) as f:\n            data = f.read()\n        return parse_environ_block(data)\n\n    @wrap_exceptions\n    def terminal(self):\n        tty_nr = int(self._parse_stat_file()['ttynr'])\n        tmap = _psposix.get_terminal_map()\n        try:\n            return tmap[tty_nr]\n        except KeyError:\n            return None\n\n    # May not be available on old kernels.\n    if os.path.exists('/proc/%s/io' % os.getpid()):\n\n        @wrap_exceptions\n        def io_counters(self):\n            fname = \"%s/%s/io\" % (self._procfs_path, self.pid)\n            fields = {}\n            with open_binary(fname) as f:\n                for line in f:\n                    # https://github.com/giampaolo/psutil/issues/1004\n                    line = line.strip()\n                    if line:\n                        try:\n                            name, value = line.split(b': ')\n                        except ValueError:\n                            # https://github.com/giampaolo/psutil/issues/1004\n                            continue\n                        else:\n                            fields[name] = int(value)\n            if not fields:\n                raise RuntimeError(\"%s file was empty\" % fname)\n            try:\n                return pio(\n                    fields[b'syscr'],  # read syscalls\n                    fields[b'syscw'],  # write syscalls\n                    fields[b'read_bytes'],  # read bytes\n                    fields[b'write_bytes'],  # write bytes\n                    fields[b'rchar'],  # read chars\n                    fields[b'wchar'],  # write chars\n                )\n            except KeyError as err:\n                raise ValueError(\n                    \"%r field was not found in %s; found fields are %r\"\n                    % (err.args[0], fname, fields)\n                )\n\n    @wrap_exceptions\n    def cpu_times(self):\n        values = self._parse_stat_file()\n        utime = float(values['utime']) / CLOCK_TICKS\n        stime = float(values['stime']) / CLOCK_TICKS\n        children_utime = float(values['children_utime']) / CLOCK_TICKS\n        children_stime = float(values['children_stime']) / CLOCK_TICKS\n        iowait = float(values['blkio_ticks']) / CLOCK_TICKS\n        return pcputimes(utime, stime, children_utime, children_stime, iowait)\n\n    @wrap_exceptions\n    def cpu_num(self):\n        \"\"\"What CPU the process is on.\"\"\"\n        return int(self._parse_stat_file()['cpu_num'])\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    @wrap_exceptions\n    def create_time(self):\n        ctime = float(self._parse_stat_file()['create_time'])\n        # According to documentation, starttime is in field 21 and the\n        # unit is jiffies (clock ticks).\n        # We first divide it for clock ticks and then add uptime returning\n        # seconds since the epoch.\n        # Also use cached value if available.\n        bt = BOOT_TIME or boot_time()\n        return (ctime / CLOCK_TICKS) + bt\n\n    @wrap_exceptions\n    def memory_info(self):\n        #  ============================================================\n        # | FIELD  | DESCRIPTION                         | AKA  | TOP  |\n        #  ============================================================\n        # | rss    | resident set size                   |      | RES  |\n        # | vms    | total program size                  | size | VIRT |\n        # | shared | shared pages (from shared mappings) |      | SHR  |\n        # | text   | text ('code')                       | trs  | CODE |\n        # | lib    | library (unused in Linux 2.6)       | lrs  |      |\n        # | data   | data + stack                        | drs  | DATA |\n        # | dirty  | dirty pages (unused in Linux 2.6)   | dt   |      |\n        #  ============================================================\n        with open_binary(\"%s/%s/statm\" % (self._procfs_path, self.pid)) as f:\n            vms, rss, shared, text, lib, data, dirty = (\n                int(x) * PAGESIZE for x in f.readline().split()[:7]\n            )\n        return pmem(rss, vms, shared, text, lib, data, dirty)\n\n    if HAS_PROC_SMAPS_ROLLUP or HAS_PROC_SMAPS:\n\n        def _parse_smaps_rollup(self):\n            # /proc/pid/smaps_rollup was added to Linux in 2017. Faster\n            # than /proc/pid/smaps. It reports higher PSS than */smaps\n            # (from 1k up to 200k higher; tested against all processes).\n            # IMPORTANT: /proc/pid/smaps_rollup is weird, because it\n            # raises ESRCH / ENOENT for many PIDs, even if they're alive\n            # (also as root). In that case we'll use /proc/pid/smaps as\n            # fallback, which is slower but has a +50% success rate\n            # compared to /proc/pid/smaps_rollup.\n            uss = pss = swap = 0\n            with open_binary(\n                \"{}/{}/smaps_rollup\".format(self._procfs_path, self.pid)\n            ) as f:\n                for line in f:\n                    if line.startswith(b\"Private_\"):\n                        # Private_Clean, Private_Dirty, Private_Hugetlb\n                        uss += int(line.split()[1]) * 1024\n                    elif line.startswith(b\"Pss:\"):\n                        pss = int(line.split()[1]) * 1024\n                    elif line.startswith(b\"Swap:\"):\n                        swap = int(line.split()[1]) * 1024\n            return (uss, pss, swap)\n\n        @wrap_exceptions\n        def _parse_smaps(\n            self,\n            # Gets Private_Clean, Private_Dirty, Private_Hugetlb.\n            _private_re=re.compile(br\"\\nPrivate.*:\\s+(\\d+)\"),\n            _pss_re=re.compile(br\"\\nPss\\:\\s+(\\d+)\"),\n            _swap_re=re.compile(br\"\\nSwap\\:\\s+(\\d+)\"),\n        ):\n            # /proc/pid/smaps does not exist on kernels < 2.6.14 or if\n            # CONFIG_MMU kernel configuration option is not enabled.\n\n            # Note: using 3 regexes is faster than reading the file\n            # line by line.\n            # XXX: on Python 3 the 2 regexes are 30% slower than on\n            # Python 2 though. Figure out why.\n            #\n            # You might be tempted to calculate USS by subtracting\n            # the \"shared\" value from the \"resident\" value in\n            # /proc/<pid>/statm. But at least on Linux, statm's \"shared\"\n            # value actually counts pages backed by files, which has\n            # little to do with whether the pages are actually shared.\n            # /proc/self/smaps on the other hand appears to give us the\n            # correct information.\n            smaps_data = self._read_smaps_file()\n            # Note: smaps file can be empty for certain processes.\n            # The code below will not crash though and will result to 0.\n            uss = sum(map(int, _private_re.findall(smaps_data))) * 1024\n            pss = sum(map(int, _pss_re.findall(smaps_data))) * 1024\n            swap = sum(map(int, _swap_re.findall(smaps_data))) * 1024\n            return (uss, pss, swap)\n\n        @wrap_exceptions\n        def memory_full_info(self):\n            if HAS_PROC_SMAPS_ROLLUP:  # faster\n                try:\n                    uss, pss, swap = self._parse_smaps_rollup()\n                except (ProcessLookupError, FileNotFoundError):\n                    uss, pss, swap = self._parse_smaps()\n            else:\n                uss, pss, swap = self._parse_smaps()\n            basic_mem = self.memory_info()\n            return pfullmem(*basic_mem + (uss, pss, swap))\n\n    else:\n        memory_full_info = memory_info\n\n    if HAS_PROC_SMAPS:\n\n        @wrap_exceptions\n        def memory_maps(self):\n            \"\"\"Return process's mapped memory regions as a list of named\n            tuples. Fields are explained in 'man proc'; here is an updated\n            (Apr 2012) version: http://goo.gl/fmebo.\n\n            /proc/{PID}/smaps does not exist on kernels < 2.6.14 or if\n            CONFIG_MMU kernel configuration option is not enabled.\n            \"\"\"\n\n            def get_blocks(lines, current_block):\n                data = {}\n                for line in lines:\n                    fields = line.split(None, 5)\n                    if not fields[0].endswith(b':'):\n                        # new block section\n                        yield (current_block.pop(), data)\n                        current_block.append(line)\n                    else:\n                        try:\n                            data[fields[0]] = int(fields[1]) * 1024\n                        except ValueError:\n                            if fields[0].startswith(b'VmFlags:'):\n                                # see issue #369\n                                continue\n                            else:\n                                raise ValueError(\n                                    \"don't know how to interpret line %r\"\n                                    % line\n                                )\n                yield (current_block.pop(), data)\n\n            data = self._read_smaps_file()\n            # Note: smaps file can be empty for certain processes or for\n            # zombies.\n            if not data:\n                self._raise_if_zombie()\n                return []\n            lines = data.split(b'\\n')\n            ls = []\n            first_line = lines.pop(0)\n            current_block = [first_line]\n            for header, data in get_blocks(lines, current_block):\n                hfields = header.split(None, 5)\n                try:\n                    addr, perms, _offset, _dev, _inode, path = hfields\n                except ValueError:\n                    addr, perms, _offset, _dev, _inode, path = hfields + ['']\n                if not path:\n                    path = '[anon]'\n                else:\n                    if PY3:\n                        path = decode(path)\n                    path = path.strip()\n                    if path.endswith(' (deleted)') and not path_exists_strict(\n                        path\n                    ):\n                        path = path[:-10]\n                item = (\n                    decode(addr),\n                    decode(perms),\n                    path,\n                    data.get(b'Rss:', 0),\n                    data.get(b'Size:', 0),\n                    data.get(b'Pss:', 0),\n                    data.get(b'Shared_Clean:', 0),\n                    data.get(b'Shared_Dirty:', 0),\n                    data.get(b'Private_Clean:', 0),\n                    data.get(b'Private_Dirty:', 0),\n                    data.get(b'Referenced:', 0),\n                    data.get(b'Anonymous:', 0),\n                    data.get(b'Swap:', 0),\n                )\n                ls.append(item)\n            return ls\n\n    @wrap_exceptions\n    def cwd(self):\n        return readlink(\"%s/%s/cwd\" % (self._procfs_path, self.pid))\n\n    @wrap_exceptions\n    def num_ctx_switches(\n        self, _ctxsw_re=re.compile(br'ctxt_switches:\\t(\\d+)')\n    ):\n        data = self._read_status_file()\n        ctxsw = _ctxsw_re.findall(data)\n        if not ctxsw:\n            raise NotImplementedError(\n                \"'voluntary_ctxt_switches' and 'nonvoluntary_ctxt_switches'\"\n                \"lines were not found in %s/%s/status; the kernel is \"\n                \"probably older than 2.6.23\" % (self._procfs_path, self.pid)\n            )\n        else:\n            return _common.pctxsw(int(ctxsw[0]), int(ctxsw[1]))\n\n    @wrap_exceptions\n    def num_threads(self, _num_threads_re=re.compile(br'Threads:\\t(\\d+)')):\n        # Note: on Python 3 using a re is faster than iterating over file\n        # line by line. On Python 2 is the exact opposite, and iterating\n        # over a file on Python 3 is slower than on Python 2.\n        data = self._read_status_file()\n        return int(_num_threads_re.findall(data)[0])\n\n    @wrap_exceptions\n    def threads(self):\n        thread_ids = os.listdir(\"%s/%s/task\" % (self._procfs_path, self.pid))\n        thread_ids.sort()\n        retlist = []\n        hit_enoent = False\n        for thread_id in thread_ids:\n            fname = \"%s/%s/task/%s/stat\" % (\n                self._procfs_path,\n                self.pid,\n                thread_id,\n            )\n            try:\n                with open_binary(fname) as f:\n                    st = f.read().strip()\n            except (FileNotFoundError, ProcessLookupError):\n                # no such file or directory or no such process;\n                # it means thread disappeared on us\n                hit_enoent = True\n                continue\n            # ignore the first two values (\"pid (exe)\")\n            st = st[st.find(b')') + 2 :]\n            values = st.split(b' ')\n            utime = float(values[11]) / CLOCK_TICKS\n            stime = float(values[12]) / CLOCK_TICKS\n            ntuple = _common.pthread(int(thread_id), utime, stime)\n            retlist.append(ntuple)\n        if hit_enoent:\n            self._raise_if_not_alive()\n        return retlist\n\n    @wrap_exceptions\n    def nice_get(self):\n        # with open_text('%s/%s/stat' % (self._procfs_path, self.pid)) as f:\n        #   data = f.read()\n        #   return int(data.split()[18])\n\n        # Use C implementation\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    # starting from CentOS 6.\n    if HAS_CPU_AFFINITY:\n\n        @wrap_exceptions\n        def cpu_affinity_get(self):\n            return cext.proc_cpu_affinity_get(self.pid)\n\n        def _get_eligible_cpus(\n            self, _re=re.compile(br\"Cpus_allowed_list:\\t(\\d+)-(\\d+)\")\n        ):\n            # See: https://github.com/giampaolo/psutil/issues/956\n            data = self._read_status_file()\n            match = _re.findall(data)\n            if match:\n                return list(range(int(match[0][0]), int(match[0][1]) + 1))\n            else:\n                return list(range(len(per_cpu_times())))\n\n        @wrap_exceptions\n        def cpu_affinity_set(self, cpus):\n            try:\n                cext.proc_cpu_affinity_set(self.pid, cpus)\n            except (OSError, ValueError) as err:\n                if isinstance(err, ValueError) or err.errno == errno.EINVAL:\n                    eligible_cpus = self._get_eligible_cpus()\n                    all_cpus = tuple(range(len(per_cpu_times())))\n                    for cpu in cpus:\n                        if cpu not in all_cpus:\n                            raise ValueError(\n                                \"invalid CPU number %r; choose between %s\"\n                                % (cpu, eligible_cpus)\n                            )\n                        if cpu not in eligible_cpus:\n                            raise ValueError(\n                                \"CPU number %r is not eligible; choose \"\n                                \"between %s\" % (cpu, eligible_cpus)\n                            )\n                raise\n\n    # only starting from kernel 2.6.13\n    if HAS_PROC_IO_PRIORITY:\n\n        @wrap_exceptions\n        def ionice_get(self):\n            ioclass, value = cext.proc_ioprio_get(self.pid)\n            if enum is not None:\n                ioclass = IOPriority(ioclass)\n            return _common.pionice(ioclass, value)\n\n        @wrap_exceptions\n        def ionice_set(self, ioclass, value):\n            if value is None:\n                value = 0\n            if value and ioclass in (IOPRIO_CLASS_IDLE, IOPRIO_CLASS_NONE):\n                raise ValueError(\"%r ioclass accepts no value\" % ioclass)\n            if value < 0 or value > 7:\n                msg = \"value not in 0-7 range\"\n                raise ValueError(msg)\n            return cext.proc_ioprio_set(self.pid, ioclass, value)\n\n    if prlimit is not None:\n\n        @wrap_exceptions\n        def rlimit(self, resource_, limits=None):\n            # If pid is 0 prlimit() applies to the calling process and\n            # we don't want that. We should never get here though as\n            # PID 0 is not supported on Linux.\n            if self.pid == 0:\n                msg = \"can't use prlimit() against PID 0 process\"\n                raise ValueError(msg)\n            try:\n                if limits is None:\n                    # get\n                    return prlimit(self.pid, resource_)\n                else:\n                    # set\n                    if len(limits) != 2:\n                        msg = (\n                            \"second argument must be a (soft, hard) \"\n                            + \"tuple, got %s\" % repr(limits)\n                        )\n                        raise ValueError(msg)\n                    prlimit(self.pid, resource_, limits)\n            except OSError as err:\n                if err.errno == errno.ENOSYS:\n                    # I saw this happening on Travis:\n                    # https://travis-ci.org/giampaolo/psutil/jobs/51368273\n                    self._raise_if_zombie()\n                raise\n\n    @wrap_exceptions\n    def status(self):\n        letter = self._parse_stat_file()['status']\n        if PY3:\n            letter = letter.decode()\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(letter, '?')\n\n    @wrap_exceptions\n    def open_files(self):\n        retlist = []\n        files = os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid))\n        hit_enoent = False\n        for fd in files:\n            file = \"%s/%s/fd/%s\" % (self._procfs_path, self.pid, fd)\n            try:\n                path = readlink(file)\n            except (FileNotFoundError, ProcessLookupError):\n                # ENOENT == file which is gone in the meantime\n                hit_enoent = True\n                continue\n            except OSError as err:\n                if err.errno == errno.EINVAL:\n                    # not a link\n                    continue\n                if err.errno == errno.ENAMETOOLONG:\n                    # file name too long\n                    debug(err)\n                    continue\n                raise\n            else:\n                # If path is not an absolute there's no way to tell\n                # whether it's a regular file or not, so we skip it.\n                # A regular file is always supposed to be have an\n                # absolute path though.\n                if path.startswith('/') and isfile_strict(path):\n                    # Get file position and flags.\n                    file = \"%s/%s/fdinfo/%s\" % (\n                        self._procfs_path,\n                        self.pid,\n                        fd,\n                    )\n                    try:\n                        with open_binary(file) as f:\n                            pos = int(f.readline().split()[1])\n                            flags = int(f.readline().split()[1], 8)\n                    except (FileNotFoundError, ProcessLookupError):\n                        # fd gone in the meantime; process may\n                        # still be alive\n                        hit_enoent = True\n                    else:\n                        mode = file_flags_to_mode(flags)\n                        ntuple = popenfile(\n                            path, int(fd), int(pos), mode, flags\n                        )\n                        retlist.append(ntuple)\n        if hit_enoent:\n            self._raise_if_not_alive()\n        return retlist\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        ret = _net_connections.retrieve(kind, self.pid)\n        self._raise_if_not_alive()\n        return ret\n\n    @wrap_exceptions\n    def num_fds(self):\n        return len(os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid)))\n\n    @wrap_exceptions\n    def ppid(self):\n        return int(self._parse_stat_file()['ppid'])\n\n    @wrap_exceptions\n    def uids(self, _uids_re=re.compile(br'Uid:\\t(\\d+)\\t(\\d+)\\t(\\d+)')):\n        data = self._read_status_file()\n        real, effective, saved = _uids_re.findall(data)[0]\n        return _common.puids(int(real), int(effective), int(saved))\n\n    @wrap_exceptions\n    def gids(self, _gids_re=re.compile(br'Gid:\\t(\\d+)\\t(\\d+)\\t(\\d+)')):\n        data = self._read_status_file()\n        real, effective, saved = _gids_re.findall(data)[0]\n        return _common.pgids(int(real), int(effective), int(saved))\n", "psutil/_psosx.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"macOS platform implementation.\"\"\"\n\nimport errno\nimport functools\nimport os\nfrom collections import namedtuple\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_osx as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import conn_tmap\nfrom ._common import conn_to_ntuple\nfrom ._common import isfile_strict\nfrom ._common import memoize_when_activated\nfrom ._common import parse_environ_block\nfrom ._common import usage_percent\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\n\n\n__extra__all__ = []\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nPAGESIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RECEIVED: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nPROC_STATUSES = {\n    cext.SIDL: _common.STATUS_IDLE,\n    cext.SRUN: _common.STATUS_RUNNING,\n    cext.SSLEEP: _common.STATUS_SLEEPING,\n    cext.SSTOP: _common.STATUS_STOPPED,\n    cext.SZOMB: _common.STATUS_ZOMBIE,\n}\n\nkinfo_proc_map = dict(\n    ppid=0,\n    ruid=1,\n    euid=2,\n    suid=3,\n    rgid=4,\n    egid=5,\n    sgid=6,\n    ttynr=7,\n    ctime=8,\n    status=9,\n    name=10,\n)\n\npidtaskinfo_map = dict(\n    cpuutime=0,\n    cpustime=1,\n    rss=2,\n    vms=3,\n    pfaults=4,\n    pageins=5,\n    numthreads=6,\n    volctxsw=7,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.cpu_times()\nscputimes = namedtuple('scputimes', ['user', 'nice', 'system', 'idle'])\n# psutil.virtual_memory()\nsvmem = namedtuple(\n    'svmem', ['total', 'available', 'percent', 'used', 'free',\n              'active', 'inactive', 'wired'])\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms', 'pfaults', 'pageins'])\n# psutil.Process.memory_full_info()\npfullmem = namedtuple('pfullmem', pmem._fields + ('uss', ))\n# fmt: on\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"System virtual memory as a namedtuple.\"\"\"\n    total, active, inactive, wired, free, speculative = cext.virtual_mem()\n    # This is how Zabbix calculate avail and used mem:\n    # https://github.com/zabbix/zabbix/blob/trunk/src/libs/zbxsysinfo/\n    #     osx/memory.c\n    # Also see: https://github.com/giampaolo/psutil/issues/1277\n    avail = inactive + free\n    used = active + wired\n    # This is NOT how Zabbix calculates free mem but it matches \"free\"\n    # cmdline utility.\n    free -= speculative\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(total, avail, percent, used, free, active, inactive, wired)\n\n\ndef swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    total, used, free, sin, sout = cext.swap_mem()\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system CPU times as a namedtuple.\"\"\"\n    user, nice, system, idle = cext.cpu_times()\n    return scputimes(user, nice, system, idle)\n\n\ndef per_cpu_times():\n    \"\"\"Return system CPU times as a named tuple.\"\"\"\n    ret = []\n    for cpu_t in cext.per_cpu_times():\n        user, nice, system, idle = cpu_t\n        item = scputimes(user, nice, system, idle)\n        ret.append(item)\n    return ret\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    return cext.cpu_count_logical()\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    return cext.cpu_count_cores()\n\n\ndef cpu_stats():\n    ctx_switches, interrupts, soft_interrupts, syscalls, _traps = (\n        cext.cpu_stats()\n    )\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\ndef cpu_freq():\n    \"\"\"Return CPU frequency.\n    On macOS per-cpu frequency is not supported.\n    Also, the returned frequency never changes, see:\n    https://arstechnica.com/civis/viewtopic.php?f=19&t=465002.\n    \"\"\"\n    curr, min_, max_ = cext.cpu_freq()\n    return [_common.scpufreq(curr, min_, max_)]\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_usage = _psposix.disk_usage\ndisk_io_counters = cext.disk_io_counters\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted disk partitions as a list of namedtuples.\"\"\"\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if not all:\n            if not os.path.isabs(device) or not os.path.exists(device):\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\ndef sensors_battery():\n    \"\"\"Return battery information.\"\"\"\n    try:\n        percent, minsleft, power_plugged = cext.sensors_battery()\n    except NotImplementedError:\n        # no power source - return None according to interface\n        return None\n    power_plugged = power_plugged == 1\n    if power_plugged:\n        secsleft = _common.POWER_TIME_UNLIMITED\n    elif minsleft == -1:\n        secsleft = _common.POWER_TIME_UNKNOWN\n    else:\n        secsleft = minsleft * 60\n    return _common.sbattery(percent, secsleft, power_plugged)\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_io_counters = cext.net_io_counters\nnet_if_addrs = cext_posix.net_if_addrs\n\n\ndef net_connections(kind='inet'):\n    \"\"\"System-wide network connections.\"\"\"\n    # Note: on macOS this will fail with AccessDenied unless\n    # the process is owned by root.\n    ret = []\n    for pid in pids():\n        try:\n            cons = Process(pid).net_connections(kind)\n        except NoSuchProcess:\n            continue\n        else:\n            if cons:\n                for c in cons:\n                    c = list(c) + [pid]\n                    ret.append(_common.sconn(*c))\n    return ret\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    names = net_io_counters().keys()\n    ret = {}\n    for name in names:\n        try:\n            mtu = cext_posix.net_if_mtu(name)\n            flags = cext_posix.net_if_flags(name)\n            duplex, speed = cext_posix.net_if_duplex_speed(name)\n        except OSError as err:\n            # https://github.com/giampaolo/psutil/issues/1279\n            if err.errno != errno.ENODEV:\n                raise\n        else:\n            if hasattr(_common, 'NicDuplex'):\n                duplex = _common.NicDuplex(duplex)\n            output_flags = ','.join(flags)\n            isup = 'running' in flags\n            ret[name] = _common.snicstats(\n                isup, duplex, speed, mtu, output_flags\n            )\n    return ret\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, tty, hostname, tstamp, pid = item\n        if tty == '~':\n            continue  # reboot or shutdown\n        if not tstamp:\n            continue\n        nt = _common.suser(user, tty or None, hostname or None, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    ls = cext.pids()\n    if 0 not in ls:\n        # On certain macOS versions pids() C doesn't return PID 0 but\n        # \"ps\" does and the process is querable via sysctl():\n        # https://travis-ci.org/giampaolo/psutil/jobs/309619941\n        try:\n            Process(0).create_time()\n            ls.insert(0, 0)\n        except NoSuchProcess:\n            pass\n        except AccessDenied:\n            ls.insert(0, 0)\n    return ls\n\n\npid_exists = _psposix.pid_exists\n\n\ndef is_zombie(pid):\n    try:\n        st = cext.proc_kinfo_oneshot(pid)[kinfo_proc_map['status']]\n        return st == cext.SZOMB\n    except OSError:\n        return False\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which translates bare OSError exceptions into\n    NoSuchProcess and AccessDenied.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except ProcessLookupError:\n            if is_zombie(self.pid):\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n            else:\n                raise NoSuchProcess(self.pid, self._name)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _get_kinfo_proc(self):\n        # Note: should work with all PIDs without permission issues.\n        ret = cext.proc_kinfo_oneshot(self.pid)\n        assert len(ret) == len(kinfo_proc_map)\n        return ret\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _get_pidtaskinfo(self):\n        # Note: should work for PIDs owned by user only.\n        ret = cext.proc_pidtaskinfo_oneshot(self.pid)\n        assert len(ret) == len(pidtaskinfo_map)\n        return ret\n\n    def oneshot_enter(self):\n        self._get_kinfo_proc.cache_activate(self)\n        self._get_pidtaskinfo.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._get_kinfo_proc.cache_deactivate(self)\n        self._get_pidtaskinfo.cache_deactivate(self)\n\n    @wrap_exceptions\n    def name(self):\n        name = self._get_kinfo_proc()[kinfo_proc_map['name']]\n        return name if name is not None else cext.proc_name(self.pid)\n\n    @wrap_exceptions\n    def exe(self):\n        return cext.proc_exe(self.pid)\n\n    @wrap_exceptions\n    def cmdline(self):\n        return cext.proc_cmdline(self.pid)\n\n    @wrap_exceptions\n    def environ(self):\n        return parse_environ_block(cext.proc_environ(self.pid))\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self._get_kinfo_proc()[kinfo_proc_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def cwd(self):\n        return cext.proc_cwd(self.pid)\n\n    @wrap_exceptions\n    def uids(self):\n        rawtuple = self._get_kinfo_proc()\n        return _common.puids(\n            rawtuple[kinfo_proc_map['ruid']],\n            rawtuple[kinfo_proc_map['euid']],\n            rawtuple[kinfo_proc_map['suid']],\n        )\n\n    @wrap_exceptions\n    def gids(self):\n        rawtuple = self._get_kinfo_proc()\n        return _common.puids(\n            rawtuple[kinfo_proc_map['rgid']],\n            rawtuple[kinfo_proc_map['egid']],\n            rawtuple[kinfo_proc_map['sgid']],\n        )\n\n    @wrap_exceptions\n    def terminal(self):\n        tty_nr = self._get_kinfo_proc()[kinfo_proc_map['ttynr']]\n        tmap = _psposix.get_terminal_map()\n        try:\n            return tmap[tty_nr]\n        except KeyError:\n            return None\n\n    @wrap_exceptions\n    def memory_info(self):\n        rawtuple = self._get_pidtaskinfo()\n        return pmem(\n            rawtuple[pidtaskinfo_map['rss']],\n            rawtuple[pidtaskinfo_map['vms']],\n            rawtuple[pidtaskinfo_map['pfaults']],\n            rawtuple[pidtaskinfo_map['pageins']],\n        )\n\n    @wrap_exceptions\n    def memory_full_info(self):\n        basic_mem = self.memory_info()\n        uss = cext.proc_memory_uss(self.pid)\n        return pfullmem(*basic_mem + (uss,))\n\n    @wrap_exceptions\n    def cpu_times(self):\n        rawtuple = self._get_pidtaskinfo()\n        return _common.pcputimes(\n            rawtuple[pidtaskinfo_map['cpuutime']],\n            rawtuple[pidtaskinfo_map['cpustime']],\n            # children user / system times are not retrievable (set to 0)\n            0.0,\n            0.0,\n        )\n\n    @wrap_exceptions\n    def create_time(self):\n        return self._get_kinfo_proc()[kinfo_proc_map['ctime']]\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        # Unvoluntary value seems not to be available;\n        # getrusage() numbers seems to confirm this theory.\n        # We set it to 0.\n        vol = self._get_pidtaskinfo()[pidtaskinfo_map['volctxsw']]\n        return _common.pctxsw(vol, 0)\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._get_pidtaskinfo()[pidtaskinfo_map['numthreads']]\n\n    @wrap_exceptions\n    def open_files(self):\n        if self.pid == 0:\n            return []\n        files = []\n        rawlist = cext.proc_open_files(self.pid)\n        for path, fd in rawlist:\n            if isfile_strict(path):\n                ntuple = _common.popenfile(path, fd)\n                files.append(ntuple)\n        return files\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        if kind not in conn_tmap:\n            raise ValueError(\n                \"invalid %r kind argument; choose between %s\"\n                % (kind, ', '.join([repr(x) for x in conn_tmap]))\n            )\n        families, types = conn_tmap[kind]\n        rawlist = cext.proc_net_connections(self.pid, families, types)\n        ret = []\n        for item in rawlist:\n            fd, fam, type, laddr, raddr, status = item\n            nt = conn_to_ntuple(\n                fd, fam, type, laddr, raddr, status, TCP_STATUSES\n            )\n            ret.append(nt)\n        return ret\n\n    @wrap_exceptions\n    def num_fds(self):\n        if self.pid == 0:\n            return 0\n        return cext.proc_num_fds(self.pid)\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    @wrap_exceptions\n    def nice_get(self):\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def status(self):\n        code = self._get_kinfo_proc()[kinfo_proc_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    @wrap_exceptions\n    def threads(self):\n        rawlist = cext.proc_threads(self.pid)\n        retlist = []\n        for thread_id, utime, stime in rawlist:\n            ntuple = _common.pthread(thread_id, utime, stime)\n            retlist.append(ntuple)\n        return retlist\n", "psutil/_compat.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Module which provides compatibility with older Python versions.\nThis is more future-compatible rather than the opposite (prefer latest\nPython 3 way of doing things).\n\"\"\"\n\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport sys\nimport types\n\n\n# fmt: off\n__all__ = [\n    # constants\n    \"PY3\",\n    # builtins\n    \"long\", \"range\", \"super\", \"unicode\", \"basestring\",\n    # literals\n    \"b\",\n    # collections module\n    \"lru_cache\",\n    # shutil module\n    \"which\", \"get_terminal_size\",\n    # contextlib module\n    \"redirect_stderr\",\n    # python 3 exceptions\n    \"FileNotFoundError\", \"PermissionError\", \"ProcessLookupError\",\n    \"InterruptedError\", \"ChildProcessError\", \"FileExistsError\",\n]\n# fmt: on\n\n\nPY3 = sys.version_info[0] >= 3\n_SENTINEL = object()\n\nif PY3:\n    long = int\n    xrange = range\n    unicode = str\n    basestring = str\n    range = range\n\n    def b(s):\n        return s.encode(\"latin-1\")\n\nelse:\n    long = long\n    range = xrange\n    unicode = unicode\n    basestring = basestring\n\n    def b(s):\n        return s\n\n\n# --- builtins\n\n\n# Python 3 super().\n# Taken from \"future\" package.\n# Credit: Ryan Kelly\nif PY3:\n    super = super\nelse:\n    _builtin_super = super\n\n    def super(type_=_SENTINEL, type_or_obj=_SENTINEL, framedepth=1):\n        \"\"\"Like Python 3 builtin super(). If called without any arguments\n        it attempts to infer them at runtime.\n        \"\"\"\n        if type_ is _SENTINEL:\n            f = sys._getframe(framedepth)\n            try:\n                # Get the function's first positional argument.\n                type_or_obj = f.f_locals[f.f_code.co_varnames[0]]\n            except (IndexError, KeyError):\n                msg = 'super() used in a function with no args'\n                raise RuntimeError(msg)\n            try:\n                # Get the MRO so we can crawl it.\n                mro = type_or_obj.__mro__\n            except (AttributeError, RuntimeError):\n                try:\n                    mro = type_or_obj.__class__.__mro__\n                except AttributeError:\n                    msg = 'super() used in a non-newstyle class'\n                    raise RuntimeError(msg)\n            for type_ in mro:\n                #  Find the class that owns the currently-executing method.\n                for meth in type_.__dict__.values():\n                    # Drill down through any wrappers to the underlying func.\n                    # This handles e.g. classmethod() and staticmethod().\n                    try:\n                        while not isinstance(meth, types.FunctionType):\n                            if isinstance(meth, property):\n                                # Calling __get__ on the property will invoke\n                                # user code which might throw exceptions or\n                                # have side effects\n                                meth = meth.fget\n                            else:\n                                try:\n                                    meth = meth.__func__\n                                except AttributeError:\n                                    meth = meth.__get__(type_or_obj, type_)\n                    except (AttributeError, TypeError):\n                        continue\n                    if meth.func_code is f.f_code:\n                        break  # found\n                else:\n                    # Not found. Move onto the next class in MRO.\n                    continue\n                break  # found\n            else:\n                msg = 'super() called outside a method'\n                raise RuntimeError(msg)\n\n        # Dispatch to builtin super().\n        if type_or_obj is not _SENTINEL:\n            return _builtin_super(type_, type_or_obj)\n        return _builtin_super(type_)\n\n\n# --- exceptions\n\n\nif PY3:\n    FileNotFoundError = FileNotFoundError  # NOQA\n    PermissionError = PermissionError  # NOQA\n    ProcessLookupError = ProcessLookupError  # NOQA\n    InterruptedError = InterruptedError  # NOQA\n    ChildProcessError = ChildProcessError  # NOQA\n    FileExistsError = FileExistsError  # NOQA\nelse:\n    # https://github.com/PythonCharmers/python-future/blob/exceptions/\n    #     src/future/types/exceptions/pep3151.py\n    import platform\n\n    def _instance_checking_exception(base_exception=Exception):\n        def wrapped(instance_checker):\n            class TemporaryClass(base_exception):\n                def __init__(self, *args, **kwargs):\n                    if len(args) == 1 and isinstance(args[0], TemporaryClass):\n                        unwrap_me = args[0]\n                        for attr in dir(unwrap_me):\n                            if not attr.startswith('__'):\n                                setattr(self, attr, getattr(unwrap_me, attr))\n                    else:\n                        super(TemporaryClass, self).__init__(  # noqa\n                            *args, **kwargs\n                        )\n\n                class __metaclass__(type):\n                    def __instancecheck__(cls, inst):\n                        return instance_checker(inst)\n\n                    def __subclasscheck__(cls, classinfo):\n                        value = sys.exc_info()[1]\n                        return isinstance(value, cls)\n\n            TemporaryClass.__name__ = instance_checker.__name__\n            TemporaryClass.__doc__ = instance_checker.__doc__\n            return TemporaryClass\n\n        return wrapped\n\n    @_instance_checking_exception(EnvironmentError)\n    def FileNotFoundError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ENOENT\n\n    @_instance_checking_exception(EnvironmentError)\n    def ProcessLookupError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ESRCH\n\n    @_instance_checking_exception(EnvironmentError)\n    def PermissionError(inst):\n        return getattr(inst, 'errno', _SENTINEL) in (errno.EACCES, errno.EPERM)\n\n    @_instance_checking_exception(EnvironmentError)\n    def InterruptedError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.EINTR\n\n    @_instance_checking_exception(EnvironmentError)\n    def ChildProcessError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ECHILD\n\n    @_instance_checking_exception(EnvironmentError)\n    def FileExistsError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.EEXIST\n\n    if platform.python_implementation() != \"CPython\":\n        try:\n            raise OSError(errno.EEXIST, \"perm\")\n        except FileExistsError:\n            pass\n        except OSError:\n            msg = (\n                \"broken or incompatible Python implementation, see: \"\n                \"https://github.com/giampaolo/psutil/issues/1659\"\n            )\n            raise RuntimeError(msg)\n\n\n# --- stdlib additions\n\n\n# py 3.2 functools.lru_cache\n# Taken from: http://code.activestate.com/recipes/578078\n# Credit: Raymond Hettinger\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    try:\n        from threading import RLock\n    except ImportError:\n        from dummy_threading import RLock\n\n    _CacheInfo = collections.namedtuple(\n        \"CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"]\n    )\n\n    class _HashedSeq(list):\n        __slots__ = ('hashvalue',)\n\n        def __init__(self, tup, hash=hash):\n            self[:] = tup\n            self.hashvalue = hash(tup)\n\n        def __hash__(self):\n            return self.hashvalue\n\n    def _make_key(\n        args,\n        kwds,\n        typed,\n        kwd_mark=(_SENTINEL,),\n        fasttypes=set((int, str, frozenset, type(None))),  # noqa\n        sorted=sorted,\n        tuple=tuple,\n        type=type,\n        len=len,\n    ):\n        key = args\n        if kwds:\n            sorted_items = sorted(kwds.items())\n            key += kwd_mark\n            for item in sorted_items:\n                key += item\n        if typed:\n            key += tuple(type(v) for v in args)\n            if kwds:\n                key += tuple(type(v) for k, v in sorted_items)\n        elif len(key) == 1 and type(key[0]) in fasttypes:\n            return key[0]\n        return _HashedSeq(key)\n\n    def lru_cache(maxsize=100, typed=False):\n        \"\"\"Least-recently-used cache decorator, see:\n        http://docs.python.org/3/library/functools.html#functools.lru_cache.\n        \"\"\"\n\n        def decorating_function(user_function):\n            cache = {}\n            stats = [0, 0]\n            HITS, MISSES = 0, 1\n            make_key = _make_key\n            cache_get = cache.get\n            _len = len\n            lock = RLock()\n            root = []\n            root[:] = [root, root, None, None]\n            nonlocal_root = [root]\n            PREV, NEXT, KEY, RESULT = 0, 1, 2, 3\n            if maxsize == 0:\n\n                def wrapper(*args, **kwds):\n                    result = user_function(*args, **kwds)\n                    stats[MISSES] += 1\n                    return result\n\n            elif maxsize is None:\n\n                def wrapper(*args, **kwds):\n                    key = make_key(args, kwds, typed)\n                    result = cache_get(key, root)\n                    if result is not root:\n                        stats[HITS] += 1\n                        return result\n                    result = user_function(*args, **kwds)\n                    cache[key] = result\n                    stats[MISSES] += 1\n                    return result\n\n            else:\n\n                def wrapper(*args, **kwds):\n                    if kwds or typed:\n                        key = make_key(args, kwds, typed)\n                    else:\n                        key = args\n                    lock.acquire()\n                    try:\n                        link = cache_get(key)\n                        if link is not None:\n                            (root,) = nonlocal_root\n                            link_prev, link_next, key, result = link\n                            link_prev[NEXT] = link_next\n                            link_next[PREV] = link_prev\n                            last = root[PREV]\n                            last[NEXT] = root[PREV] = link\n                            link[PREV] = last\n                            link[NEXT] = root\n                            stats[HITS] += 1\n                            return result\n                    finally:\n                        lock.release()\n                    result = user_function(*args, **kwds)\n                    lock.acquire()\n                    try:\n                        (root,) = nonlocal_root\n                        if key in cache:\n                            pass\n                        elif _len(cache) >= maxsize:\n                            oldroot = root\n                            oldroot[KEY] = key\n                            oldroot[RESULT] = result\n                            root = nonlocal_root[0] = oldroot[NEXT]\n                            oldkey = root[KEY]\n                            root[KEY] = root[RESULT] = None\n                            del cache[oldkey]\n                            cache[key] = oldroot\n                        else:\n                            last = root[PREV]\n                            link = [last, root, key, result]\n                            last[NEXT] = root[PREV] = cache[key] = link\n                        stats[MISSES] += 1\n                    finally:\n                        lock.release()\n                    return result\n\n            def cache_info():\n                \"\"\"Report cache statistics.\"\"\"\n                lock.acquire()\n                try:\n                    return _CacheInfo(\n                        stats[HITS], stats[MISSES], maxsize, len(cache)\n                    )\n                finally:\n                    lock.release()\n\n            def cache_clear():\n                \"\"\"Clear the cache and cache statistics.\"\"\"\n                lock.acquire()\n                try:\n                    cache.clear()\n                    root = nonlocal_root[0]\n                    root[:] = [root, root, None, None]\n                    stats[:] = [0, 0]\n                finally:\n                    lock.release()\n\n            wrapper.__wrapped__ = user_function\n            wrapper.cache_info = cache_info\n            wrapper.cache_clear = cache_clear\n            return functools.update_wrapper(wrapper, user_function)\n\n        return decorating_function\n\n\n# python 3.3\ntry:\n    from shutil import which\nexcept ImportError:\n\n    def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n        \"\"\"Given a command, mode, and a PATH string, return the path which\n        conforms to the given mode on the PATH, or None if there is no such\n        file.\n\n        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n        of os.environ.get(\"PATH\"), or can be overridden with a custom search\n        path.\n        \"\"\"\n\n        def _access_check(fn, mode):\n            return (\n                os.path.exists(fn)\n                and os.access(fn, mode)\n                and not os.path.isdir(fn)\n            )\n\n        if os.path.dirname(cmd):\n            if _access_check(cmd, mode):\n                return cmd\n            return None\n\n        if path is None:\n            path = os.environ.get(\"PATH\", os.defpath)\n        if not path:\n            return None\n        path = path.split(os.pathsep)\n\n        if sys.platform == \"win32\":\n            if os.curdir not in path:\n                path.insert(0, os.curdir)\n\n            pathext = os.environ.get(\"PATHEXT\", \"\").split(os.pathsep)\n            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n                files = [cmd]\n            else:\n                files = [cmd + ext for ext in pathext]\n        else:\n            files = [cmd]\n\n        seen = set()\n        for dir in path:\n            normdir = os.path.normcase(dir)\n            if normdir not in seen:\n                seen.add(normdir)\n                for thefile in files:\n                    name = os.path.join(dir, thefile)\n                    if _access_check(name, mode):\n                        return name\n        return None\n\n\n# python 3.3\ntry:\n    from shutil import get_terminal_size\nexcept ImportError:\n\n    def get_terminal_size(fallback=(80, 24)):\n        try:\n            import fcntl\n            import struct\n            import termios\n        except ImportError:\n            return fallback\n        else:\n            try:\n                # This should work on Linux.\n                res = struct.unpack(\n                    'hh', fcntl.ioctl(1, termios.TIOCGWINSZ, '1234')\n                )\n                return (res[1], res[0])\n            except Exception:  # noqa: BLE001\n                return fallback\n\n\n# python 3.3\ntry:\n    from subprocess import TimeoutExpired as SubprocessTimeoutExpired\nexcept ImportError:\n\n    class SubprocessTimeoutExpired(Exception):\n        pass\n\n\n# python 3.5\ntry:\n    from contextlib import redirect_stderr\nexcept ImportError:\n\n    @contextlib.contextmanager\n    def redirect_stderr(new_target):\n        original = sys.stderr\n        try:\n            sys.stderr = new_target\n            yield new_target\n        finally:\n            sys.stderr = original\n", "psutil/__init__.py": "# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"psutil is a cross-platform library for retrieving information on\nrunning processes and system utilization (CPU, memory, disks, network,\nsensors) in Python. Supported platforms:\n\n - Linux\n - Windows\n - macOS\n - FreeBSD\n - OpenBSD\n - NetBSD\n - Sun Solaris\n - AIX\n\nWorks with Python versions 2.7 and 3.6+.\n\"\"\"\n\nfrom __future__ import division\n\nimport collections\nimport contextlib\nimport datetime\nimport functools\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\n\n\ntry:\n    import pwd\nexcept ImportError:\n    pwd = None\n\nfrom . import _common\nfrom ._common import AIX\nfrom ._common import BSD\nfrom ._common import CONN_CLOSE\nfrom ._common import CONN_CLOSE_WAIT\nfrom ._common import CONN_CLOSING\nfrom ._common import CONN_ESTABLISHED\nfrom ._common import CONN_FIN_WAIT1\nfrom ._common import CONN_FIN_WAIT2\nfrom ._common import CONN_LAST_ACK\nfrom ._common import CONN_LISTEN\nfrom ._common import CONN_NONE\nfrom ._common import CONN_SYN_RECV\nfrom ._common import CONN_SYN_SENT\nfrom ._common import CONN_TIME_WAIT\nfrom ._common import FREEBSD  # NOQA\nfrom ._common import LINUX\nfrom ._common import MACOS\nfrom ._common import NETBSD  # NOQA\nfrom ._common import NIC_DUPLEX_FULL\nfrom ._common import NIC_DUPLEX_HALF\nfrom ._common import NIC_DUPLEX_UNKNOWN\nfrom ._common import OPENBSD  # NOQA\nfrom ._common import OSX  # deprecated alias\nfrom ._common import POSIX  # NOQA\nfrom ._common import POWER_TIME_UNKNOWN\nfrom ._common import POWER_TIME_UNLIMITED\nfrom ._common import STATUS_DEAD\nfrom ._common import STATUS_DISK_SLEEP\nfrom ._common import STATUS_IDLE\nfrom ._common import STATUS_LOCKED\nfrom ._common import STATUS_PARKED\nfrom ._common import STATUS_RUNNING\nfrom ._common import STATUS_SLEEPING\nfrom ._common import STATUS_STOPPED\nfrom ._common import STATUS_TRACING_STOP\nfrom ._common import STATUS_WAITING\nfrom ._common import STATUS_WAKING\nfrom ._common import STATUS_ZOMBIE\nfrom ._common import SUNOS\nfrom ._common import WINDOWS\nfrom ._common import AccessDenied\nfrom ._common import Error\nfrom ._common import NoSuchProcess\nfrom ._common import TimeoutExpired\nfrom ._common import ZombieProcess\nfrom ._common import debug\nfrom ._common import memoize_when_activated\nfrom ._common import wrap_numbers as _wrap_numbers\nfrom ._compat import PY3 as _PY3\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import SubprocessTimeoutExpired as _SubprocessTimeoutExpired\nfrom ._compat import long\n\n\nif LINUX:\n    # This is public API and it will be retrieved from _pslinux.py\n    # via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\n    from . import _pslinux as _psplatform\n    from ._pslinux import IOPRIO_CLASS_BE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_IDLE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_NONE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_RT  # NOQA\n\nelif WINDOWS:\n    from . import _pswindows as _psplatform\n    from ._psutil_windows import ABOVE_NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import BELOW_NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import HIGH_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import IDLE_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import REALTIME_PRIORITY_CLASS  # NOQA\n    from ._pswindows import CONN_DELETE_TCB  # NOQA\n    from ._pswindows import IOPRIO_HIGH  # NOQA\n    from ._pswindows import IOPRIO_LOW  # NOQA\n    from ._pswindows import IOPRIO_NORMAL  # NOQA\n    from ._pswindows import IOPRIO_VERYLOW  # NOQA\n\nelif MACOS:\n    from . import _psosx as _psplatform\n\nelif BSD:\n    from . import _psbsd as _psplatform\n\nelif SUNOS:\n    from . import _pssunos as _psplatform\n    from ._pssunos import CONN_BOUND  # NOQA\n    from ._pssunos import CONN_IDLE  # NOQA\n\n    # This is public writable API which is read from _pslinux.py and\n    # _pssunos.py via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\nelif AIX:\n    from . import _psaix as _psplatform\n\n    # This is public API and it will be retrieved from _pslinux.py\n    # via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\nelse:  # pragma: no cover\n    raise NotImplementedError('platform %s is not supported' % sys.platform)\n\n\n# fmt: off\n__all__ = [\n    # exceptions\n    \"Error\", \"NoSuchProcess\", \"ZombieProcess\", \"AccessDenied\",\n    \"TimeoutExpired\",\n\n    # constants\n    \"version_info\", \"__version__\",\n\n    \"STATUS_RUNNING\", \"STATUS_IDLE\", \"STATUS_SLEEPING\", \"STATUS_DISK_SLEEP\",\n    \"STATUS_STOPPED\", \"STATUS_TRACING_STOP\", \"STATUS_ZOMBIE\", \"STATUS_DEAD\",\n    \"STATUS_WAKING\", \"STATUS_LOCKED\", \"STATUS_WAITING\", \"STATUS_LOCKED\",\n    \"STATUS_PARKED\",\n\n    \"CONN_ESTABLISHED\", \"CONN_SYN_SENT\", \"CONN_SYN_RECV\", \"CONN_FIN_WAIT1\",\n    \"CONN_FIN_WAIT2\", \"CONN_TIME_WAIT\", \"CONN_CLOSE\", \"CONN_CLOSE_WAIT\",\n    \"CONN_LAST_ACK\", \"CONN_LISTEN\", \"CONN_CLOSING\", \"CONN_NONE\",\n    # \"CONN_IDLE\", \"CONN_BOUND\",\n\n    \"AF_LINK\",\n\n    \"NIC_DUPLEX_FULL\", \"NIC_DUPLEX_HALF\", \"NIC_DUPLEX_UNKNOWN\",\n\n    \"POWER_TIME_UNKNOWN\", \"POWER_TIME_UNLIMITED\",\n\n    \"BSD\", \"FREEBSD\", \"LINUX\", \"NETBSD\", \"OPENBSD\", \"MACOS\", \"OSX\", \"POSIX\",\n    \"SUNOS\", \"WINDOWS\", \"AIX\",\n\n    # \"RLIM_INFINITY\", \"RLIMIT_AS\", \"RLIMIT_CORE\", \"RLIMIT_CPU\", \"RLIMIT_DATA\",\n    # \"RLIMIT_FSIZE\", \"RLIMIT_LOCKS\", \"RLIMIT_MEMLOCK\", \"RLIMIT_NOFILE\",\n    # \"RLIMIT_NPROC\", \"RLIMIT_RSS\", \"RLIMIT_STACK\", \"RLIMIT_MSGQUEUE\",\n    # \"RLIMIT_NICE\", \"RLIMIT_RTPRIO\", \"RLIMIT_RTTIME\", \"RLIMIT_SIGPENDING\",\n\n    # classes\n    \"Process\", \"Popen\",\n\n    # functions\n    \"pid_exists\", \"pids\", \"process_iter\", \"wait_procs\",             # proc\n    \"virtual_memory\", \"swap_memory\",                                # memory\n    \"cpu_times\", \"cpu_percent\", \"cpu_times_percent\", \"cpu_count\",   # cpu\n    \"cpu_stats\",  # \"cpu_freq\", \"getloadavg\"\n    \"net_io_counters\", \"net_connections\", \"net_if_addrs\",           # network\n    \"net_if_stats\",\n    \"disk_io_counters\", \"disk_partitions\", \"disk_usage\",            # disk\n    # \"sensors_temperatures\", \"sensors_battery\", \"sensors_fans\"     # sensors\n    \"users\", \"boot_time\",                                           # others\n]\n# fmt: on\n\n\n__all__.extend(_psplatform.__extra__all__)\n\n# Linux, FreeBSD\nif hasattr(_psplatform.Process, \"rlimit\"):\n    # Populate global namespace with RLIM* constants.\n    from . import _psutil_posix\n\n    _globals = globals()\n    _name = None\n    for _name in dir(_psutil_posix):\n        if _name.startswith('RLIM') and _name.isupper():\n            _globals[_name] = getattr(_psutil_posix, _name)\n            __all__.append(_name)\n    del _globals, _name\n\nAF_LINK = _psplatform.AF_LINK\n\n__author__ = \"Giampaolo Rodola'\"\n__version__ = \"6.0.1\"\nversion_info = tuple([int(num) for num in __version__.split('.')])\n\n_timer = getattr(time, 'monotonic', time.time)\n_TOTAL_PHYMEM = None\n_LOWEST_PID = None\n_SENTINEL = object()\n\n# Sanity check in case the user messed up with psutil installation\n# or did something weird with sys.path. In this case we might end\n# up importing a python module using a C extension module which\n# was compiled for a different version of psutil.\n# We want to prevent that by failing sooner rather than later.\n# See: https://github.com/giampaolo/psutil/issues/564\nif int(__version__.replace('.', '')) != getattr(\n    _psplatform.cext, 'version', None\n):\n    msg = \"version conflict: %r C extension \" % _psplatform.cext.__file__\n    msg += \"module was built for another version of psutil\"\n    if hasattr(_psplatform.cext, 'version'):\n        msg += \" (%s instead of %s)\" % (\n            '.'.join([x for x in str(_psplatform.cext.version)]),\n            __version__,\n        )\n    else:\n        msg += \" (different than %s)\" % __version__\n    msg += \"; you may try to 'pip uninstall psutil', manually remove %s\" % (\n        getattr(\n            _psplatform.cext,\n            \"__file__\",\n            \"the existing psutil install directory\",\n        )\n    )\n    msg += \" or clean the virtual env somehow, then reinstall\"\n    raise ImportError(msg)\n\n\n# =====================================================================\n# --- Utils\n# =====================================================================\n\n\nif hasattr(_psplatform, 'ppid_map'):\n    # Faster version (Windows and Linux).\n    _ppid_map = _psplatform.ppid_map\nelse:  # pragma: no cover\n\n    def _ppid_map():\n        \"\"\"Return a {pid: ppid, ...} dict for all running processes in\n        one shot. Used to speed up Process.children().\n        \"\"\"\n        ret = {}\n        for pid in pids():\n            try:\n                ret[pid] = _psplatform.Process(pid).ppid()\n            except (NoSuchProcess, ZombieProcess):\n                pass\n        return ret\n\n\ndef _pprint_secs(secs):\n    \"\"\"Format seconds in a human readable form.\"\"\"\n    now = time.time()\n    secs_ago = int(now - secs)\n    fmt = \"%H:%M:%S\" if secs_ago < 60 * 60 * 24 else \"%Y-%m-%d %H:%M:%S\"\n    return datetime.datetime.fromtimestamp(secs).strftime(fmt)\n\n\n# =====================================================================\n# --- Process class\n# =====================================================================\n\n\nclass Process(object):  # noqa: UP004\n    \"\"\"Represents an OS process with the given PID.\n    If PID is omitted current process PID (os.getpid()) is used.\n    Raise NoSuchProcess if PID does not exist.\n\n    Note that most of the methods of this class do not make sure that\n    the PID of the process being queried has been reused. That means\n    that you may end up retrieving information for another process.\n\n    The only exceptions for which process identity is pre-emptively\n    checked and guaranteed are:\n\n     - parent()\n     - children()\n     - nice() (set)\n     - ionice() (set)\n     - rlimit() (set)\n     - cpu_affinity (set)\n     - suspend()\n     - resume()\n     - send_signal()\n     - terminate()\n     - kill()\n\n    To prevent this problem for all other methods you can use\n    is_running() before querying the process.\n    \"\"\"\n\n    def __init__(self, pid=None):\n        self._init(pid)\n\n    def _init(self, pid, _ignore_nsp=False):\n        if pid is None:\n            pid = os.getpid()\n        else:\n            if not _PY3 and not isinstance(pid, (int, long)):\n                msg = \"pid must be an integer (got %r)\" % pid\n                raise TypeError(msg)\n            if pid < 0:\n                msg = \"pid must be a positive integer (got %s)\" % pid\n                raise ValueError(msg)\n            try:\n                _psplatform.cext.check_pid_range(pid)\n            except OverflowError:\n                msg = \"process PID out of range (got %s)\" % pid\n                raise NoSuchProcess(pid, msg=msg)\n\n        self._pid = pid\n        self._name = None\n        self._exe = None\n        self._create_time = None\n        self._gone = False\n        self._pid_reused = False\n        self._hash = None\n        self._lock = threading.RLock()\n        # used for caching on Windows only (on POSIX ppid may change)\n        self._ppid = None\n        # platform-specific modules define an _psplatform.Process\n        # implementation class\n        self._proc = _psplatform.Process(pid)\n        self._last_sys_cpu_times = None\n        self._last_proc_cpu_times = None\n        self._exitcode = _SENTINEL\n        # cache creation time for later use in is_running() method\n        try:\n            self.create_time()\n        except AccessDenied:\n            # We should never get here as AFAIK we're able to get\n            # process creation time on all platforms even as a\n            # limited user.\n            pass\n        except ZombieProcess:\n            # Zombies can still be queried by this class (although\n            # not always) and pids() return them so just go on.\n            pass\n        except NoSuchProcess:\n            if not _ignore_nsp:\n                msg = \"process PID not found\"\n                raise NoSuchProcess(pid, msg=msg)\n            else:\n                self._gone = True\n        # This pair is supposed to identify a Process instance\n        # univocally over time (the PID alone is not enough as\n        # it might refer to a process whose PID has been reused).\n        # This will be used later in __eq__() and is_running().\n        self._ident = (self.pid, self._create_time)\n\n    def __str__(self):\n        info = collections.OrderedDict()\n        info[\"pid\"] = self.pid\n        if self._name:\n            info['name'] = self._name\n        with self.oneshot():\n            if self._pid_reused:\n                info[\"status\"] = \"terminated + PID reused\"\n            else:\n                try:\n                    info[\"name\"] = self.name()\n                    info[\"status\"] = self.status()\n                except ZombieProcess:\n                    info[\"status\"] = \"zombie\"\n                except NoSuchProcess:\n                    info[\"status\"] = \"terminated\"\n                except AccessDenied:\n                    pass\n\n            if self._exitcode not in (_SENTINEL, None):\n                info[\"exitcode\"] = self._exitcode\n            if self._create_time is not None:\n                info['started'] = _pprint_secs(self._create_time)\n\n            return \"%s.%s(%s)\" % (\n                self.__class__.__module__,\n                self.__class__.__name__,\n                \", \".join([\"%s=%r\" % (k, v) for k, v in info.items()]),\n            )\n\n    __repr__ = __str__\n\n    def __eq__(self, other):\n        # Test for equality with another Process object based\n        # on PID and creation time.\n        if not isinstance(other, Process):\n            return NotImplemented\n        if OPENBSD or NETBSD:  # pragma: no cover\n            # Zombie processes on Open/NetBSD have a creation time of\n            # 0.0. This covers the case when a process started normally\n            # (so it has a ctime), then it turned into a zombie. It's\n            # important to do this because is_running() depends on\n            # __eq__.\n            pid1, ctime1 = self._ident\n            pid2, ctime2 = other._ident\n            if pid1 == pid2:\n                if ctime1 and not ctime2:\n                    try:\n                        return self.status() == STATUS_ZOMBIE\n                    except Error:\n                        pass\n        return self._ident == other._ident\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        if self._hash is None:\n            self._hash = hash(self._ident)\n        return self._hash\n\n    def _raise_if_pid_reused(self):\n        \"\"\"Raises NoSuchProcess in case process PID has been reused.\"\"\"\n        if self._pid_reused or (not self.is_running() and self._pid_reused):\n            # We may directly raise NSP in here already if PID is just\n            # not running, but I prefer NSP to be raised naturally by\n            # the actual Process API call. This way unit tests will tell\n            # us if the API is broken (aka don't raise NSP when it\n            # should). We also remain consistent with all other \"get\"\n            # APIs which don't use _raise_if_pid_reused().\n            msg = \"process no longer exists and its PID has been reused\"\n            raise NoSuchProcess(self.pid, self._name, msg=msg)\n\n    @property\n    def pid(self):\n        \"\"\"The process PID.\"\"\"\n        return self._pid\n\n    # --- utility methods\n\n    @contextlib.contextmanager\n    def oneshot(self):\n        \"\"\"Utility context manager which considerably speeds up the\n        retrieval of multiple process information at the same time.\n\n        Internally different process info (e.g. name, ppid, uids,\n        gids, ...) may be fetched by using the same routine, but\n        only one information is returned and the others are discarded.\n        When using this context manager the internal routine is\n        executed once (in the example below on name()) and the\n        other info are cached.\n\n        The cache is cleared when exiting the context manager block.\n        The advice is to use this every time you retrieve more than\n        one information about the process. If you're lucky, you'll\n        get a hell of a speedup.\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> with p.oneshot():\n        ...     p.name()  # collect multiple info\n        ...     p.cpu_times()  # return cached value\n        ...     p.cpu_percent()  # return cached value\n        ...     p.create_time()  # return cached value\n        ...\n        >>>\n        \"\"\"\n        with self._lock:\n            if hasattr(self, \"_cache\"):\n                # NOOP: this covers the use case where the user enters the\n                # context twice:\n                #\n                # >>> with p.oneshot():\n                # ...    with p.oneshot():\n                # ...\n                #\n                # Also, since as_dict() internally uses oneshot()\n                # I expect that the code below will be a pretty common\n                # \"mistake\" that the user will make, so let's guard\n                # against that:\n                #\n                # >>> with p.oneshot():\n                # ...    p.as_dict()\n                # ...\n                yield\n            else:\n                try:\n                    # cached in case cpu_percent() is used\n                    self.cpu_times.cache_activate(self)\n                    # cached in case memory_percent() is used\n                    self.memory_info.cache_activate(self)\n                    # cached in case parent() is used\n                    self.ppid.cache_activate(self)\n                    # cached in case username() is used\n                    if POSIX:\n                        self.uids.cache_activate(self)\n                    # specific implementation cache\n                    self._proc.oneshot_enter()\n                    yield\n                finally:\n                    self.cpu_times.cache_deactivate(self)\n                    self.memory_info.cache_deactivate(self)\n                    self.ppid.cache_deactivate(self)\n                    if POSIX:\n                        self.uids.cache_deactivate(self)\n                    self._proc.oneshot_exit()\n\n    def as_dict(self, attrs=None, ad_value=None):\n        \"\"\"Utility method returning process information as a\n        hashable dictionary.\n        If *attrs* is specified it must be a list of strings\n        reflecting available Process class' attribute names\n        (e.g. ['cpu_times', 'name']) else all public (read\n        only) attributes are assumed.\n        *ad_value* is the value which gets assigned in case\n        AccessDenied or ZombieProcess exception is raised when\n        retrieving that particular process information.\n        \"\"\"\n        valid_names = _as_dict_attrnames\n        if attrs is not None:\n            if not isinstance(attrs, (list, tuple, set, frozenset)):\n                msg = \"invalid attrs type %s\" % type(attrs)\n                raise TypeError(msg)\n            attrs = set(attrs)\n            invalid_names = attrs - valid_names\n            if invalid_names:\n                msg = \"invalid attr name%s %s\" % (\n                    \"s\" if len(invalid_names) > 1 else \"\",\n                    \", \".join(map(repr, invalid_names)),\n                )\n                raise ValueError(msg)\n\n        retdict = {}\n        ls = attrs or valid_names\n        with self.oneshot():\n            for name in ls:\n                try:\n                    if name == 'pid':\n                        ret = self.pid\n                    else:\n                        meth = getattr(self, name)\n                        ret = meth()\n                except (AccessDenied, ZombieProcess):\n                    ret = ad_value\n                except NotImplementedError:\n                    # in case of not implemented functionality (may happen\n                    # on old or exotic systems) we want to crash only if\n                    # the user explicitly asked for that particular attr\n                    if attrs:\n                        raise\n                    continue\n                retdict[name] = ret\n        return retdict\n\n    def parent(self):\n        \"\"\"Return the parent process as a Process object pre-emptively\n        checking whether PID has been reused.\n        If no parent is known return None.\n        \"\"\"\n        lowest_pid = _LOWEST_PID if _LOWEST_PID is not None else pids()[0]\n        if self.pid == lowest_pid:\n            return None\n        ppid = self.ppid()\n        if ppid is not None:\n            ctime = self.create_time()\n            try:\n                parent = Process(ppid)\n                if parent.create_time() <= ctime:\n                    return parent\n                # ...else ppid has been reused by another process\n            except NoSuchProcess:\n                pass\n\n    def parents(self):\n        \"\"\"Return the parents of this process as a list of Process\n        instances. If no parents are known return an empty list.\n        \"\"\"\n        parents = []\n        proc = self.parent()\n        while proc is not None:\n            parents.append(proc)\n            proc = proc.parent()\n        return parents\n\n    def is_running(self):\n        \"\"\"Return whether this process is running.\n\n        It also checks if PID has been reused by another process, in\n        which case it will remove the process from `process_iter()`\n        internal cache and return False.\n        \"\"\"\n        if self._gone or self._pid_reused:\n            return False\n        try:\n            # Checking if PID is alive is not enough as the PID might\n            # have been reused by another process. Process identity /\n            # uniqueness over time is guaranteed by (PID + creation\n            # time) and that is verified in __eq__.\n            self._pid_reused = self != Process(self.pid)\n            if self._pid_reused:\n                _pids_reused.add(self.pid)\n                raise NoSuchProcess(self.pid)\n            return True\n        except ZombieProcess:\n            # We should never get here as it's already handled in\n            # Process.__init__; here just for extra safety.\n            return True\n        except NoSuchProcess:\n            self._gone = True\n            return False\n\n    # --- actual API\n\n    @memoize_when_activated\n    def ppid(self):\n        \"\"\"The process parent PID.\n        On Windows the return value is cached after first call.\n        \"\"\"\n        # On POSIX we don't want to cache the ppid as it may unexpectedly\n        # change to 1 (init) in case this process turns into a zombie:\n        # https://github.com/giampaolo/psutil/issues/321\n        # http://stackoverflow.com/questions/356722/\n\n        # XXX should we check creation time here rather than in\n        # Process.parent()?\n        self._raise_if_pid_reused()\n        if POSIX:\n            return self._proc.ppid()\n        else:  # pragma: no cover\n            self._ppid = self._ppid or self._proc.ppid()\n            return self._ppid\n\n    def name(self):\n        \"\"\"The process name. The return value is cached after first call.\"\"\"\n        # Process name is only cached on Windows as on POSIX it may\n        # change, see:\n        # https://github.com/giampaolo/psutil/issues/692\n        if WINDOWS and self._name is not None:\n            return self._name\n        name = self._proc.name()\n        if POSIX and len(name) >= 15:\n            # On UNIX the name gets truncated to the first 15 characters.\n            # If it matches the first part of the cmdline we return that\n            # one instead because it's usually more explicative.\n            # Examples are \"gnome-keyring-d\" vs. \"gnome-keyring-daemon\".\n            try:\n                cmdline = self.cmdline()\n            except (AccessDenied, ZombieProcess):\n                # Just pass and return the truncated name: it's better\n                # than nothing. Note: there are actual cases where a\n                # zombie process can return a name() but not a\n                # cmdline(), see:\n                # https://github.com/giampaolo/psutil/issues/2239\n                pass\n            else:\n                if cmdline:\n                    extended_name = os.path.basename(cmdline[0])\n                    if extended_name.startswith(name):\n                        name = extended_name\n        self._name = name\n        self._proc._name = name\n        return name\n\n    def exe(self):\n        \"\"\"The process executable as an absolute path.\n        May also be an empty string.\n        The return value is cached after first call.\n        \"\"\"\n\n        def guess_it(fallback):\n            # try to guess exe from cmdline[0] in absence of a native\n            # exe representation\n            cmdline = self.cmdline()\n            if cmdline and hasattr(os, 'access') and hasattr(os, 'X_OK'):\n                exe = cmdline[0]  # the possible exe\n                # Attempt to guess only in case of an absolute path.\n                # It is not safe otherwise as the process might have\n                # changed cwd.\n                if (\n                    os.path.isabs(exe)\n                    and os.path.isfile(exe)\n                    and os.access(exe, os.X_OK)\n                ):\n                    return exe\n            if isinstance(fallback, AccessDenied):\n                raise fallback\n            return fallback\n\n        if self._exe is None:\n            try:\n                exe = self._proc.exe()\n            except AccessDenied as err:\n                return guess_it(fallback=err)\n            else:\n                if not exe:\n                    # underlying implementation can legitimately return an\n                    # empty string; if that's the case we don't want to\n                    # raise AD while guessing from the cmdline\n                    try:\n                        exe = guess_it(fallback=exe)\n                    except AccessDenied:\n                        pass\n                self._exe = exe\n        return self._exe\n\n    def cmdline(self):\n        \"\"\"The command line this process has been called with.\"\"\"\n        return self._proc.cmdline()\n\n    def status(self):\n        \"\"\"The process current status as a STATUS_* constant.\"\"\"\n        try:\n            return self._proc.status()\n        except ZombieProcess:\n            return STATUS_ZOMBIE\n\n    def username(self):\n        \"\"\"The name of the user that owns the process.\n        On UNIX this is calculated by using *real* process uid.\n        \"\"\"\n        if POSIX:\n            if pwd is None:\n                # might happen if python was installed from sources\n                msg = \"requires pwd module shipped with standard python\"\n                raise ImportError(msg)\n            real_uid = self.uids().real\n            try:\n                return pwd.getpwuid(real_uid).pw_name\n            except KeyError:\n                # the uid can't be resolved by the system\n                return str(real_uid)\n        else:\n            return self._proc.username()\n\n    def create_time(self):\n        \"\"\"The process creation time as a floating point number\n        expressed in seconds since the epoch.\n        The return value is cached after first call.\n        \"\"\"\n        if self._create_time is None:\n            self._create_time = self._proc.create_time()\n        return self._create_time\n\n    def cwd(self):\n        \"\"\"Process current working directory as an absolute path.\"\"\"\n        return self._proc.cwd()\n\n    def nice(self, value=None):\n        \"\"\"Get or set process niceness (priority).\"\"\"\n        if value is None:\n            return self._proc.nice_get()\n        else:\n            self._raise_if_pid_reused()\n            self._proc.nice_set(value)\n\n    if POSIX:\n\n        @memoize_when_activated\n        def uids(self):\n            \"\"\"Return process UIDs as a (real, effective, saved)\n            namedtuple.\n            \"\"\"\n            return self._proc.uids()\n\n        def gids(self):\n            \"\"\"Return process GIDs as a (real, effective, saved)\n            namedtuple.\n            \"\"\"\n            return self._proc.gids()\n\n        def terminal(self):\n            \"\"\"The terminal associated with this process, if any,\n            else None.\n            \"\"\"\n            return self._proc.terminal()\n\n        def num_fds(self):\n            \"\"\"Return the number of file descriptors opened by this\n            process (POSIX only).\n            \"\"\"\n            return self._proc.num_fds()\n\n    # Linux, BSD, AIX and Windows only\n    if hasattr(_psplatform.Process, \"io_counters\"):\n\n        def io_counters(self):\n            \"\"\"Return process I/O statistics as a\n            (read_count, write_count, read_bytes, write_bytes)\n            namedtuple.\n            Those are the number of read/write calls performed and the\n            amount of bytes read and written by the process.\n            \"\"\"\n            return self._proc.io_counters()\n\n    # Linux and Windows\n    if hasattr(_psplatform.Process, \"ionice_get\"):\n\n        def ionice(self, ioclass=None, value=None):\n            \"\"\"Get or set process I/O niceness (priority).\n\n            On Linux *ioclass* is one of the IOPRIO_CLASS_* constants.\n            *value* is a number which goes from 0 to 7. The higher the\n            value, the lower the I/O priority of the process.\n\n            On Windows only *ioclass* is used and it can be set to 2\n            (normal), 1 (low) or 0 (very low).\n\n            Available on Linux and Windows > Vista only.\n            \"\"\"\n            if ioclass is None:\n                if value is not None:\n                    msg = \"'ioclass' argument must be specified\"\n                    raise ValueError(msg)\n                return self._proc.ionice_get()\n            else:\n                self._raise_if_pid_reused()\n                return self._proc.ionice_set(ioclass, value)\n\n    # Linux / FreeBSD only\n    if hasattr(_psplatform.Process, \"rlimit\"):\n\n        def rlimit(self, resource, limits=None):\n            \"\"\"Get or set process resource limits as a (soft, hard)\n            tuple.\n\n            *resource* is one of the RLIMIT_* constants.\n            *limits* is supposed to be a (soft, hard) tuple.\n\n            See \"man prlimit\" for further info.\n            Available on Linux and FreeBSD only.\n            \"\"\"\n            if limits is not None:\n                self._raise_if_pid_reused()\n            return self._proc.rlimit(resource, limits)\n\n    # Windows, Linux and FreeBSD only\n    if hasattr(_psplatform.Process, \"cpu_affinity_get\"):\n\n        def cpu_affinity(self, cpus=None):\n            \"\"\"Get or set process CPU affinity.\n            If specified, *cpus* must be a list of CPUs for which you\n            want to set the affinity (e.g. [0, 1]).\n            If an empty list is passed, all egible CPUs are assumed\n            (and set).\n            (Windows, Linux and BSD only).\n            \"\"\"\n            if cpus is None:\n                return sorted(set(self._proc.cpu_affinity_get()))\n            else:\n                self._raise_if_pid_reused()\n                if not cpus:\n                    if hasattr(self._proc, \"_get_eligible_cpus\"):\n                        cpus = self._proc._get_eligible_cpus()\n                    else:\n                        cpus = tuple(range(len(cpu_times(percpu=True))))\n                self._proc.cpu_affinity_set(list(set(cpus)))\n\n    # Linux, FreeBSD, SunOS\n    if hasattr(_psplatform.Process, \"cpu_num\"):\n\n        def cpu_num(self):\n            \"\"\"Return what CPU this process is currently running on.\n            The returned number should be <= psutil.cpu_count()\n            and <= len(psutil.cpu_percent(percpu=True)).\n            It may be used in conjunction with\n            psutil.cpu_percent(percpu=True) to observe the system\n            workload distributed across CPUs.\n            \"\"\"\n            return self._proc.cpu_num()\n\n    # All platforms has it, but maybe not in the future.\n    if hasattr(_psplatform.Process, \"environ\"):\n\n        def environ(self):\n            \"\"\"The environment variables of the process as a dict.  Note: this\n            might not reflect changes made after the process started.\n            \"\"\"\n            return self._proc.environ()\n\n    if WINDOWS:\n\n        def num_handles(self):\n            \"\"\"Return the number of handles opened by this process\n            (Windows only).\n            \"\"\"\n            return self._proc.num_handles()\n\n    def num_ctx_switches(self):\n        \"\"\"Return the number of voluntary and involuntary context\n        switches performed by this process.\n        \"\"\"\n        return self._proc.num_ctx_switches()\n\n    def num_threads(self):\n        \"\"\"Return the number of threads used by this process.\"\"\"\n        return self._proc.num_threads()\n\n    if hasattr(_psplatform.Process, \"threads\"):\n\n        def threads(self):\n            \"\"\"Return threads opened by process as a list of\n            (id, user_time, system_time) namedtuples representing\n            thread id and thread CPU times (user/system).\n            On OpenBSD this method requires root access.\n            \"\"\"\n            return self._proc.threads()\n\n    def children(self, recursive=False):\n        \"\"\"Return the children of this process as a list of Process\n        instances, pre-emptively checking whether PID has been reused.\n        If *recursive* is True return all the parent descendants.\n\n        Example (A == this process):\n\n         A \u2500\u2510\n            \u2502\n            \u251c\u2500 B (child) \u2500\u2510\n            \u2502             \u2514\u2500 X (grandchild) \u2500\u2510\n            \u2502                                \u2514\u2500 Y (great grandchild)\n            \u251c\u2500 C (child)\n            \u2514\u2500 D (child)\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> p.children()\n        B, C, D\n        >>> p.children(recursive=True)\n        B, X, Y, C, D\n\n        Note that in the example above if process X disappears\n        process Y won't be listed as the reference to process A\n        is lost.\n        \"\"\"\n        self._raise_if_pid_reused()\n        ppid_map = _ppid_map()\n        ret = []\n        if not recursive:\n            for pid, ppid in ppid_map.items():\n                if ppid == self.pid:\n                    try:\n                        child = Process(pid)\n                        # if child happens to be older than its parent\n                        # (self) it means child's PID has been reused\n                        if self.create_time() <= child.create_time():\n                            ret.append(child)\n                    except (NoSuchProcess, ZombieProcess):\n                        pass\n        else:\n            # Construct a {pid: [child pids]} dict\n            reverse_ppid_map = collections.defaultdict(list)\n            for pid, ppid in ppid_map.items():\n                reverse_ppid_map[ppid].append(pid)\n            # Recursively traverse that dict, starting from self.pid,\n            # such that we only call Process() on actual children\n            seen = set()\n            stack = [self.pid]\n            while stack:\n                pid = stack.pop()\n                if pid in seen:\n                    # Since pids can be reused while the ppid_map is\n                    # constructed, there may be rare instances where\n                    # there's a cycle in the recorded process \"tree\".\n                    continue\n                seen.add(pid)\n                for child_pid in reverse_ppid_map[pid]:\n                    try:\n                        child = Process(child_pid)\n                        # if child happens to be older than its parent\n                        # (self) it means child's PID has been reused\n                        intime = self.create_time() <= child.create_time()\n                        if intime:\n                            ret.append(child)\n                            stack.append(child_pid)\n                    except (NoSuchProcess, ZombieProcess):\n                        pass\n        return ret\n\n    def cpu_percent(self, interval=None):\n        \"\"\"Return a float representing the current process CPU\n        utilization as a percentage.\n\n        When *interval* is 0.0 or None (default) compares process times\n        to system CPU times elapsed since last call, returning\n        immediately (non-blocking). That means that the first time\n        this is called it will return a meaningful 0.0 value.\n\n        When *interval* is > 0.0 compares process times to system CPU\n        times elapsed before and after the interval (blocking).\n\n        In this case is recommended for accuracy that this function\n        be called with at least 0.1 seconds between calls.\n\n        A value > 100.0 can be returned in case of processes running\n        multiple threads on different CPU cores.\n\n        The returned value is explicitly NOT split evenly between\n        all available logical CPUs. This means that a busy loop process\n        running on a system with 2 logical CPUs will be reported as\n        having 100% CPU utilization instead of 50%.\n\n        Examples:\n\n          >>> import psutil\n          >>> p = psutil.Process(os.getpid())\n          >>> # blocking\n          >>> p.cpu_percent(interval=1)\n          2.0\n          >>> # non-blocking (percentage since last call)\n          >>> p.cpu_percent(interval=None)\n          2.9\n          >>>\n        \"\"\"\n        blocking = interval is not None and interval > 0.0\n        if interval is not None and interval < 0:\n            msg = \"interval is not positive (got %r)\" % interval\n            raise ValueError(msg)\n        num_cpus = cpu_count() or 1\n\n        def timer():\n            return _timer() * num_cpus\n\n        if blocking:\n            st1 = timer()\n            pt1 = self._proc.cpu_times()\n            time.sleep(interval)\n            st2 = timer()\n            pt2 = self._proc.cpu_times()\n        else:\n            st1 = self._last_sys_cpu_times\n            pt1 = self._last_proc_cpu_times\n            st2 = timer()\n            pt2 = self._proc.cpu_times()\n            if st1 is None or pt1 is None:\n                self._last_sys_cpu_times = st2\n                self._last_proc_cpu_times = pt2\n                return 0.0\n\n        delta_proc = (pt2.user - pt1.user) + (pt2.system - pt1.system)\n        delta_time = st2 - st1\n        # reset values for next call in case of interval == None\n        self._last_sys_cpu_times = st2\n        self._last_proc_cpu_times = pt2\n\n        try:\n            # This is the utilization split evenly between all CPUs.\n            # E.g. a busy loop process on a 2-CPU-cores system at this\n            # point is reported as 50% instead of 100%.\n            overall_cpus_percent = (delta_proc / delta_time) * 100\n        except ZeroDivisionError:\n            # interval was too low\n            return 0.0\n        else:\n            # Note 1:\n            # in order to emulate \"top\" we multiply the value for the num\n            # of CPU cores. This way the busy process will be reported as\n            # having 100% (or more) usage.\n            #\n            # Note 2:\n            # taskmgr.exe on Windows differs in that it will show 50%\n            # instead.\n            #\n            # Note 3:\n            # a percentage > 100 is legitimate as it can result from a\n            # process with multiple threads running on different CPU\n            # cores (top does the same), see:\n            # http://stackoverflow.com/questions/1032357\n            # https://github.com/giampaolo/psutil/issues/474\n            single_cpu_percent = overall_cpus_percent * num_cpus\n            return round(single_cpu_percent, 1)\n\n    @memoize_when_activated\n    def cpu_times(self):\n        \"\"\"Return a (user, system, children_user, children_system)\n        namedtuple representing the accumulated process time, in\n        seconds.\n        This is similar to os.times() but per-process.\n        On macOS and Windows children_user and children_system are\n        always set to 0.\n        \"\"\"\n        return self._proc.cpu_times()\n\n    @memoize_when_activated\n    def memory_info(self):\n        \"\"\"Return a namedtuple with variable fields depending on the\n        platform, representing memory information about the process.\n\n        The \"portable\" fields available on all platforms are `rss` and `vms`.\n\n        All numbers are expressed in bytes.\n        \"\"\"\n        return self._proc.memory_info()\n\n    @_common.deprecated_method(replacement=\"memory_info\")\n    def memory_info_ex(self):\n        return self.memory_info()\n\n    def memory_full_info(self):\n        \"\"\"This method returns the same information as memory_info(),\n        plus, on some platform (Linux, macOS, Windows), also provides\n        additional metrics (USS, PSS and swap).\n        The additional metrics provide a better representation of actual\n        process memory usage.\n\n        Namely USS is the memory which is unique to a process and which\n        would be freed if the process was terminated right now.\n\n        It does so by passing through the whole process address.\n        As such it usually requires higher user privileges than\n        memory_info() and is considerably slower.\n        \"\"\"\n        return self._proc.memory_full_info()\n\n    def memory_percent(self, memtype=\"rss\"):\n        \"\"\"Compare process memory to total physical system memory and\n        calculate process memory utilization as a percentage.\n        *memtype* argument is a string that dictates what type of\n        process memory you want to compare against (defaults to \"rss\").\n        The list of available strings can be obtained like this:\n\n        >>> psutil.Process().memory_info()._fields\n        ('rss', 'vms', 'shared', 'text', 'lib', 'data', 'dirty', 'uss', 'pss')\n        \"\"\"\n        valid_types = list(_psplatform.pfullmem._fields)\n        if memtype not in valid_types:\n            msg = \"invalid memtype %r; valid types are %r\" % (\n                memtype,\n                tuple(valid_types),\n            )\n            raise ValueError(msg)\n        fun = (\n            self.memory_info\n            if memtype in _psplatform.pmem._fields\n            else self.memory_full_info\n        )\n        metrics = fun()\n        value = getattr(metrics, memtype)\n\n        # use cached value if available\n        total_phymem = _TOTAL_PHYMEM or virtual_memory().total\n        if not total_phymem > 0:\n            # we should never get here\n            msg = (\n                \"can't calculate process memory percent because total physical\"\n                \" system memory is not positive (%r)\" % (total_phymem)\n            )\n            raise ValueError(msg)\n        return (value / float(total_phymem)) * 100\n\n    if hasattr(_psplatform.Process, \"memory_maps\"):\n\n        def memory_maps(self, grouped=True):\n            \"\"\"Return process' mapped memory regions as a list of namedtuples\n            whose fields are variable depending on the platform.\n\n            If *grouped* is True the mapped regions with the same 'path'\n            are grouped together and the different memory fields are summed.\n\n            If *grouped* is False every mapped region is shown as a single\n            entity and the namedtuple will also include the mapped region's\n            address space ('addr') and permission set ('perms').\n            \"\"\"\n            it = self._proc.memory_maps()\n            if grouped:\n                d = {}\n                for tupl in it:\n                    path = tupl[2]\n                    nums = tupl[3:]\n                    try:\n                        d[path] = map(lambda x, y: x + y, d[path], nums)\n                    except KeyError:\n                        d[path] = nums\n                nt = _psplatform.pmmap_grouped\n                return [nt(path, *d[path]) for path in d]  # NOQA\n            else:\n                nt = _psplatform.pmmap_ext\n                return [nt(*x) for x in it]\n\n    def open_files(self):\n        \"\"\"Return files opened by process as a list of\n        (path, fd) namedtuples including the absolute file name\n        and file descriptor number.\n        \"\"\"\n        return self._proc.open_files()\n\n    def net_connections(self, kind='inet'):\n        \"\"\"Return socket connections opened by process as a list of\n        (fd, family, type, laddr, raddr, status) namedtuples.\n        The *kind* parameter filters for connections that match the\n        following criteria:\n\n        +------------+----------------------------------------------------+\n        | Kind Value | Connections using                                  |\n        +------------+----------------------------------------------------+\n        | inet       | IPv4 and IPv6                                      |\n        | inet4      | IPv4                                               |\n        | inet6      | IPv6                                               |\n        | tcp        | TCP                                                |\n        | tcp4       | TCP over IPv4                                      |\n        | tcp6       | TCP over IPv6                                      |\n        | udp        | UDP                                                |\n        | udp4       | UDP over IPv4                                      |\n        | udp6       | UDP over IPv6                                      |\n        | unix       | UNIX socket (both UDP and TCP protocols)           |\n        | all        | the sum of all the possible families and protocols |\n        +------------+----------------------------------------------------+\n        \"\"\"\n        return self._proc.net_connections(kind)\n\n    @_common.deprecated_method(replacement=\"net_connections\")\n    def connections(self, kind=\"inet\"):\n        return self.net_connections(kind=kind)\n\n    # --- signals\n\n    if POSIX:\n\n        def _send_signal(self, sig):\n            assert not self.pid < 0, self.pid\n            self._raise_if_pid_reused()\n            if self.pid == 0:\n                # see \"man 2 kill\"\n                msg = (\n                    \"preventing sending signal to process with PID 0 as it \"\n                    \"would affect every process in the process group of the \"\n                    \"calling process (os.getpid()) instead of PID 0\"\n                )\n                raise ValueError(msg)\n            try:\n                os.kill(self.pid, sig)\n            except ProcessLookupError:\n                if OPENBSD and pid_exists(self.pid):\n                    # We do this because os.kill() lies in case of\n                    # zombie processes.\n                    raise ZombieProcess(self.pid, self._name, self._ppid)\n                else:\n                    self._gone = True\n                    raise NoSuchProcess(self.pid, self._name)\n            except PermissionError:\n                raise AccessDenied(self.pid, self._name)\n\n    def send_signal(self, sig):\n        \"\"\"Send a signal *sig* to process pre-emptively checking\n        whether PID has been reused (see signal module constants) .\n        On Windows only SIGTERM is valid and is treated as an alias\n        for kill().\n        \"\"\"\n        if POSIX:\n            self._send_signal(sig)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            if sig != signal.SIGTERM and not self.is_running():\n                msg = \"process no longer exists\"\n                raise NoSuchProcess(self.pid, self._name, msg=msg)\n            self._proc.send_signal(sig)\n\n    def suspend(self):\n        \"\"\"Suspend process execution with SIGSTOP pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect of suspending all process threads.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGSTOP)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.suspend()\n\n    def resume(self):\n        \"\"\"Resume process execution with SIGCONT pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect of resuming all process threads.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGCONT)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.resume()\n\n    def terminate(self):\n        \"\"\"Terminate the process with SIGTERM pre-emptively checking\n        whether PID has been reused.\n        On Windows this is an alias for kill().\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGTERM)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.kill()\n\n    def kill(self):\n        \"\"\"Kill the current process with SIGKILL pre-emptively checking\n        whether PID has been reused.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGKILL)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.kill()\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for process to terminate and, if process is a children\n        of os.getpid(), also return its exit code, else None.\n        On Windows there's no such limitation (exit code is always\n        returned).\n\n        If the process is already terminated immediately return None\n        instead of raising NoSuchProcess.\n\n        If *timeout* (in seconds) is specified and process is still\n        alive raise TimeoutExpired.\n\n        To wait for multiple Process(es) use psutil.wait_procs().\n        \"\"\"\n        if timeout is not None and not timeout >= 0:\n            msg = \"timeout must be a positive integer\"\n            raise ValueError(msg)\n        if self._exitcode is not _SENTINEL:\n            return self._exitcode\n        self._exitcode = self._proc.wait(timeout)\n        return self._exitcode\n\n\n# The valid attr names which can be processed by Process.as_dict().\n# fmt: off\n_as_dict_attrnames = set(\n    [x for x in dir(Process) if not x.startswith('_') and x not in\n     {'send_signal', 'suspend', 'resume', 'terminate', 'kill', 'wait',\n      'is_running', 'as_dict', 'parent', 'parents', 'children', 'rlimit',\n      'memory_info_ex', 'connections', 'oneshot'}])\n# fmt: on\n\n\n# =====================================================================\n# --- Popen class\n# =====================================================================\n\n\nclass Popen(Process):\n    \"\"\"Same as subprocess.Popen, but in addition it provides all\n    psutil.Process methods in a single class.\n    For the following methods which are common to both classes, psutil\n    implementation takes precedence:\n\n    * send_signal()\n    * terminate()\n    * kill()\n\n    This is done in order to avoid killing another process in case its\n    PID has been reused, fixing BPO-6973.\n\n      >>> import psutil\n      >>> from subprocess import PIPE\n      >>> p = psutil.Popen([\"python\", \"-c\", \"print 'hi'\"], stdout=PIPE)\n      >>> p.name()\n      'python'\n      >>> p.uids()\n      user(real=1000, effective=1000, saved=1000)\n      >>> p.username()\n      'giampaolo'\n      >>> p.communicate()\n      ('hi', None)\n      >>> p.terminate()\n      >>> p.wait(timeout=2)\n      0\n      >>>\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Explicitly avoid to raise NoSuchProcess in case the process\n        # spawned by subprocess.Popen terminates too quickly, see:\n        # https://github.com/giampaolo/psutil/issues/193\n        self.__subproc = subprocess.Popen(*args, **kwargs)\n        self._init(self.__subproc.pid, _ignore_nsp=True)\n\n    def __dir__(self):\n        return sorted(set(dir(Popen) + dir(subprocess.Popen)))\n\n    def __enter__(self):\n        if hasattr(self.__subproc, '__enter__'):\n            self.__subproc.__enter__()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        if hasattr(self.__subproc, '__exit__'):\n            return self.__subproc.__exit__(*args, **kwargs)\n        else:\n            if self.stdout:\n                self.stdout.close()\n            if self.stderr:\n                self.stderr.close()\n            try:\n                # Flushing a BufferedWriter may raise an error.\n                if self.stdin:\n                    self.stdin.close()\n            finally:\n                # Wait for the process to terminate, to avoid zombies.\n                self.wait()\n\n    def __getattribute__(self, name):\n        try:\n            return object.__getattribute__(self, name)\n        except AttributeError:\n            try:\n                return object.__getattribute__(self.__subproc, name)\n            except AttributeError:\n                msg = \"%s instance has no attribute '%s'\" % (\n                    self.__class__.__name__,\n                    name,\n                )\n                raise AttributeError(msg)\n\n    def wait(self, timeout=None):\n        if self.__subproc.returncode is not None:\n            return self.__subproc.returncode\n        ret = super(Popen, self).wait(timeout)  # noqa\n        self.__subproc.returncode = ret\n        return ret\n\n\n# =====================================================================\n# --- system processes related functions\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Return a list of current running PIDs.\"\"\"\n    global _LOWEST_PID\n    ret = sorted(_psplatform.pids())\n    _LOWEST_PID = ret[0]\n    return ret\n\n\ndef pid_exists(pid):\n    \"\"\"Return True if given PID exists in the current process list.\n    This is faster than doing \"pid in psutil.pids()\" and\n    should be preferred.\n    \"\"\"\n    if pid < 0:\n        return False\n    elif pid == 0 and POSIX:\n        # On POSIX we use os.kill() to determine PID existence.\n        # According to \"man 2 kill\" PID 0 has a special meaning\n        # though: it refers to <<every process in the process\n        # group of the calling process>> and that is not we want\n        # to do here.\n        return pid in pids()\n    else:\n        return _psplatform.pid_exists(pid)\n\n\n_pmap = {}\n_pids_reused = set()\n\n\ndef process_iter(attrs=None, ad_value=None):\n    \"\"\"Return a generator yielding a Process instance for all\n    running processes.\n\n    Every new Process instance is only created once and then cached\n    into an internal table which is updated every time this is used.\n    Cache can optionally be cleared via `process_iter.clear_cache()`.\n\n    The sorting order in which processes are yielded is based on\n    their PIDs.\n\n    *attrs* and *ad_value* have the same meaning as in\n    Process.as_dict(). If *attrs* is specified as_dict() is called\n    and the resulting dict is stored as a 'info' attribute attached\n    to returned Process instance.\n    If *attrs* is an empty list it will retrieve all process info\n    (slow).\n    \"\"\"\n    global _pmap\n\n    def add(pid):\n        proc = Process(pid)\n        pmap[proc.pid] = proc\n        return proc\n\n    def remove(pid):\n        pmap.pop(pid, None)\n\n    pmap = _pmap.copy()\n    a = set(pids())\n    b = set(pmap.keys())\n    new_pids = a - b\n    gone_pids = b - a\n    for pid in gone_pids:\n        remove(pid)\n    while _pids_reused:\n        pid = _pids_reused.pop()\n        debug(\"refreshing Process instance for reused PID %s\" % pid)\n        remove(pid)\n    try:\n        ls = sorted(list(pmap.items()) + list(dict.fromkeys(new_pids).items()))\n        for pid, proc in ls:\n            try:\n                if proc is None:  # new process\n                    proc = add(pid)\n                if attrs is not None:\n                    proc.info = proc.as_dict(attrs=attrs, ad_value=ad_value)\n                yield proc\n            except NoSuchProcess:\n                remove(pid)\n    finally:\n        _pmap = pmap\n\n\nprocess_iter.cache_clear = lambda: _pmap.clear()  # noqa\nprocess_iter.cache_clear.__doc__ = \"Clear process_iter() internal cache.\"\n\n\ndef wait_procs(procs, timeout=None, callback=None):\n    \"\"\"Convenience function which waits for a list of processes to\n    terminate.\n\n    Return a (gone, alive) tuple indicating which processes\n    are gone and which ones are still alive.\n\n    The gone ones will have a new *returncode* attribute indicating\n    process exit status (may be None).\n\n    *callback* is a function which gets called every time a process\n    terminates (a Process instance is passed as callback argument).\n\n    Function will return as soon as all processes terminate or when\n    *timeout* occurs.\n    Differently from Process.wait() it will not raise TimeoutExpired if\n    *timeout* occurs.\n\n    Typical use case is:\n\n     - send SIGTERM to a list of processes\n     - give them some time to terminate\n     - send SIGKILL to those ones which are still alive\n\n    Example:\n\n    >>> def on_terminate(proc):\n    ...     print(\"process {} terminated\".format(proc))\n    ...\n    >>> for p in procs:\n    ...    p.terminate()\n    ...\n    >>> gone, alive = wait_procs(procs, timeout=3, callback=on_terminate)\n    >>> for p in alive:\n    ...     p.kill()\n    \"\"\"\n\n    def check_gone(proc, timeout):\n        try:\n            returncode = proc.wait(timeout=timeout)\n        except TimeoutExpired:\n            pass\n        except _SubprocessTimeoutExpired:\n            pass\n        else:\n            if returncode is not None or not proc.is_running():\n                # Set new Process instance attribute.\n                proc.returncode = returncode\n                gone.add(proc)\n                if callback is not None:\n                    callback(proc)\n\n    if timeout is not None and not timeout >= 0:\n        msg = \"timeout must be a positive integer, got %s\" % timeout\n        raise ValueError(msg)\n    gone = set()\n    alive = set(procs)\n    if callback is not None and not callable(callback):\n        msg = \"callback %r is not a callable\" % callback\n        raise TypeError(msg)\n    if timeout is not None:\n        deadline = _timer() + timeout\n\n    while alive:\n        if timeout is not None and timeout <= 0:\n            break\n        for proc in alive:\n            # Make sure that every complete iteration (all processes)\n            # will last max 1 sec.\n            # We do this because we don't want to wait too long on a\n            # single process: in case it terminates too late other\n            # processes may disappear in the meantime and their PID\n            # reused.\n            max_timeout = 1.0 / len(alive)\n            if timeout is not None:\n                timeout = min((deadline - _timer()), max_timeout)\n                if timeout <= 0:\n                    break\n                check_gone(proc, timeout)\n            else:\n                check_gone(proc, max_timeout)\n        alive = alive - gone  # noqa PLR6104\n\n    if alive:\n        # Last attempt over processes survived so far.\n        # timeout == 0 won't make this function wait any further.\n        for proc in alive:\n            check_gone(proc, 0)\n        alive = alive - gone  # noqa: PLR6104\n\n    return (list(gone), list(alive))\n\n\n# =====================================================================\n# --- CPU related functions\n# =====================================================================\n\n\ndef cpu_count(logical=True):\n    \"\"\"Return the number of logical CPUs in the system (same as\n    os.cpu_count() in Python 3.4).\n\n    If *logical* is False return the number of physical cores only\n    (e.g. hyper thread CPUs are excluded).\n\n    Return None if undetermined.\n\n    The return value is cached after first call.\n    If desired cache can be cleared like this:\n\n    >>> psutil.cpu_count.cache_clear()\n    \"\"\"\n    if logical:\n        ret = _psplatform.cpu_count_logical()\n    else:\n        ret = _psplatform.cpu_count_cores()\n    if ret is not None and ret < 1:\n        ret = None\n    return ret\n\n\ndef cpu_times(percpu=False):\n    \"\"\"Return system-wide CPU times as a namedtuple.\n    Every CPU time represents the seconds the CPU has spent in the\n    given mode. The namedtuple's fields availability varies depending on the\n    platform:\n\n     - user\n     - system\n     - idle\n     - nice (UNIX)\n     - iowait (Linux)\n     - irq (Linux, FreeBSD)\n     - softirq (Linux)\n     - steal (Linux >= 2.6.11)\n     - guest (Linux >= 2.6.24)\n     - guest_nice (Linux >= 3.2.0)\n\n    When *percpu* is True return a list of namedtuples for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n    \"\"\"\n    if not percpu:\n        return _psplatform.cpu_times()\n    else:\n        return _psplatform.per_cpu_times()\n\n\ntry:\n    _last_cpu_times = {threading.current_thread().ident: cpu_times()}\nexcept Exception:  # noqa: BLE001\n    # Don't want to crash at import time.\n    _last_cpu_times = {}\n\ntry:\n    _last_per_cpu_times = {\n        threading.current_thread().ident: cpu_times(percpu=True)\n    }\nexcept Exception:  # noqa: BLE001\n    # Don't want to crash at import time.\n    _last_per_cpu_times = {}\n\n\ndef _cpu_tot_time(times):\n    \"\"\"Given a cpu_time() ntuple calculates the total CPU time\n    (including idle time).\n    \"\"\"\n    tot = sum(times)\n    if LINUX:\n        # On Linux guest times are already accounted in \"user\" or\n        # \"nice\" times, so we subtract them from total.\n        # Htop does the same. References:\n        # https://github.com/giampaolo/psutil/pull/940\n        # http://unix.stackexchange.com/questions/178045\n        # https://github.com/torvalds/linux/blob/\n        #     447976ef4fd09b1be88b316d1a81553f1aa7cd07/kernel/sched/\n        #     cputime.c#L158\n        tot -= getattr(times, \"guest\", 0)  # Linux 2.6.24+\n        tot -= getattr(times, \"guest_nice\", 0)  # Linux 3.2.0+\n    return tot\n\n\ndef _cpu_busy_time(times):\n    \"\"\"Given a cpu_time() ntuple calculates the busy CPU time.\n    We do so by subtracting all idle CPU times.\n    \"\"\"\n    busy = _cpu_tot_time(times)\n    busy -= times.idle\n    # Linux: \"iowait\" is time during which the CPU does not do anything\n    # (waits for IO to complete). On Linux IO wait is *not* accounted\n    # in \"idle\" time so we subtract it. Htop does the same.\n    # References:\n    # https://github.com/torvalds/linux/blob/\n    #     447976ef4fd09b1be88b316d1a81553f1aa7cd07/kernel/sched/cputime.c#L244\n    busy -= getattr(times, \"iowait\", 0)\n    return busy\n\n\ndef _cpu_times_deltas(t1, t2):\n    assert t1._fields == t2._fields, (t1, t2)\n    field_deltas = []\n    for field in _psplatform.scputimes._fields:\n        field_delta = getattr(t2, field) - getattr(t1, field)\n        # CPU times are always supposed to increase over time\n        # or at least remain the same and that's because time\n        # cannot go backwards.\n        # Surprisingly sometimes this might not be the case (at\n        # least on Windows and Linux), see:\n        # https://github.com/giampaolo/psutil/issues/392\n        # https://github.com/giampaolo/psutil/issues/645\n        # https://github.com/giampaolo/psutil/issues/1210\n        # Trim negative deltas to zero to ignore decreasing fields.\n        # top does the same. Reference:\n        # https://gitlab.com/procps-ng/procps/blob/v3.3.12/top/top.c#L5063\n        field_delta = max(0, field_delta)\n        field_deltas.append(field_delta)\n    return _psplatform.scputimes(*field_deltas)\n\n\ndef cpu_percent(interval=None, percpu=False):\n    \"\"\"Return a float representing the current system-wide CPU\n    utilization as a percentage.\n\n    When *interval* is > 0.0 compares system CPU times elapsed before\n    and after the interval (blocking).\n\n    When *interval* is 0.0 or None compares system CPU times elapsed\n    since last call or module import, returning immediately (non\n    blocking). That means the first time this is called it will\n    return a meaningless 0.0 value which you should ignore.\n    In this case is recommended for accuracy that this function be\n    called with at least 0.1 seconds between calls.\n\n    When *percpu* is True returns a list of floats representing the\n    utilization as a percentage for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n\n    Examples:\n\n      >>> # blocking, system-wide\n      >>> psutil.cpu_percent(interval=1)\n      2.0\n      >>>\n      >>> # blocking, per-cpu\n      >>> psutil.cpu_percent(interval=1, percpu=True)\n      [2.0, 1.0]\n      >>>\n      >>> # non-blocking (percentage since last call)\n      >>> psutil.cpu_percent(interval=None)\n      2.9\n      >>>\n    \"\"\"\n    tid = threading.current_thread().ident\n    blocking = interval is not None and interval > 0.0\n    if interval is not None and interval < 0:\n        msg = \"interval is not positive (got %r)\" % interval\n        raise ValueError(msg)\n\n    def calculate(t1, t2):\n        times_delta = _cpu_times_deltas(t1, t2)\n        all_delta = _cpu_tot_time(times_delta)\n        busy_delta = _cpu_busy_time(times_delta)\n\n        try:\n            busy_perc = (busy_delta / all_delta) * 100\n        except ZeroDivisionError:\n            return 0.0\n        else:\n            return round(busy_perc, 1)\n\n    # system-wide usage\n    if not percpu:\n        if blocking:\n            t1 = cpu_times()\n            time.sleep(interval)\n        else:\n            t1 = _last_cpu_times.get(tid) or cpu_times()\n        _last_cpu_times[tid] = cpu_times()\n        return calculate(t1, _last_cpu_times[tid])\n    # per-cpu usage\n    else:\n        ret = []\n        if blocking:\n            tot1 = cpu_times(percpu=True)\n            time.sleep(interval)\n        else:\n            tot1 = _last_per_cpu_times.get(tid) or cpu_times(percpu=True)\n        _last_per_cpu_times[tid] = cpu_times(percpu=True)\n        for t1, t2 in zip(tot1, _last_per_cpu_times[tid]):\n            ret.append(calculate(t1, t2))\n        return ret\n\n\n# Use a separate dict for cpu_times_percent(), so it's independent from\n# cpu_percent() and they can both be used within the same program.\n_last_cpu_times_2 = _last_cpu_times.copy()\n_last_per_cpu_times_2 = _last_per_cpu_times.copy()\n\n\ndef cpu_times_percent(interval=None, percpu=False):\n    \"\"\"Same as cpu_percent() but provides utilization percentages\n    for each specific CPU time as is returned by cpu_times().\n    For instance, on Linux we'll get:\n\n      >>> cpu_times_percent()\n      cpupercent(user=4.8, nice=0.0, system=4.8, idle=90.5, iowait=0.0,\n                 irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)\n      >>>\n\n    *interval* and *percpu* arguments have the same meaning as in\n    cpu_percent().\n    \"\"\"\n    tid = threading.current_thread().ident\n    blocking = interval is not None and interval > 0.0\n    if interval is not None and interval < 0:\n        msg = \"interval is not positive (got %r)\" % interval\n        raise ValueError(msg)\n\n    def calculate(t1, t2):\n        nums = []\n        times_delta = _cpu_times_deltas(t1, t2)\n        all_delta = _cpu_tot_time(times_delta)\n        # \"scale\" is the value to multiply each delta with to get percentages.\n        # We use \"max\" to avoid division by zero (if all_delta is 0, then all\n        # fields are 0 so percentages will be 0 too. all_delta cannot be a\n        # fraction because cpu times are integers)\n        scale = 100.0 / max(1, all_delta)\n        for field_delta in times_delta:\n            field_perc = field_delta * scale\n            field_perc = round(field_perc, 1)\n            # make sure we don't return negative values or values over 100%\n            field_perc = min(max(0.0, field_perc), 100.0)\n            nums.append(field_perc)\n        return _psplatform.scputimes(*nums)\n\n    # system-wide usage\n    if not percpu:\n        if blocking:\n            t1 = cpu_times()\n            time.sleep(interval)\n        else:\n            t1 = _last_cpu_times_2.get(tid) or cpu_times()\n        _last_cpu_times_2[tid] = cpu_times()\n        return calculate(t1, _last_cpu_times_2[tid])\n    # per-cpu usage\n    else:\n        ret = []\n        if blocking:\n            tot1 = cpu_times(percpu=True)\n            time.sleep(interval)\n        else:\n            tot1 = _last_per_cpu_times_2.get(tid) or cpu_times(percpu=True)\n        _last_per_cpu_times_2[tid] = cpu_times(percpu=True)\n        for t1, t2 in zip(tot1, _last_per_cpu_times_2[tid]):\n            ret.append(calculate(t1, t2))\n        return ret\n\n\ndef cpu_stats():\n    \"\"\"Return CPU statistics.\"\"\"\n    return _psplatform.cpu_stats()\n\n\nif hasattr(_psplatform, \"cpu_freq\"):\n\n    def cpu_freq(percpu=False):\n        \"\"\"Return CPU frequency as a namedtuple including current,\n        min and max frequency expressed in Mhz.\n\n        If *percpu* is True and the system supports per-cpu frequency\n        retrieval (Linux only) a list of frequencies is returned for\n        each CPU. If not a list with one element is returned.\n        \"\"\"\n        ret = _psplatform.cpu_freq()\n        if percpu:\n            return ret\n        else:\n            num_cpus = float(len(ret))\n            if num_cpus == 0:\n                return None\n            elif num_cpus == 1:\n                return ret[0]\n            else:\n                currs, mins, maxs = 0.0, 0.0, 0.0\n                set_none = False\n                for cpu in ret:\n                    currs += cpu.current\n                    # On Linux if /proc/cpuinfo is used min/max are set\n                    # to None.\n                    if LINUX and cpu.min is None:\n                        set_none = True\n                        continue\n                    mins += cpu.min\n                    maxs += cpu.max\n\n                current = currs / num_cpus\n\n                if set_none:\n                    min_ = max_ = None\n                else:\n                    min_ = mins / num_cpus\n                    max_ = maxs / num_cpus\n\n                return _common.scpufreq(current, min_, max_)\n\n    __all__.append(\"cpu_freq\")\n\n\nif hasattr(os, \"getloadavg\") or hasattr(_psplatform, \"getloadavg\"):\n    # Perform this hasattr check once on import time to either use the\n    # platform based code or proxy straight from the os module.\n    if hasattr(os, \"getloadavg\"):\n        getloadavg = os.getloadavg\n    else:\n        getloadavg = _psplatform.getloadavg\n\n    __all__.append(\"getloadavg\")\n\n\n# =====================================================================\n# --- system memory related functions\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"Return statistics about system memory usage as a namedtuple\n    including the following fields, expressed in bytes:\n\n     - total:\n       total physical memory available.\n\n     - available:\n       the memory that can be given instantly to processes without the\n       system going into swap.\n       This is calculated by summing different memory values depending\n       on the platform and it is supposed to be used to monitor actual\n       memory usage in a cross platform fashion.\n\n     - percent:\n       the percentage usage calculated as (total - available) / total * 100\n\n     - used:\n        memory used, calculated differently depending on the platform and\n        designed for informational purposes only:\n        macOS: active + wired\n        BSD: active + wired + cached\n        Linux: total - free\n\n     - free:\n       memory not being used at all (zeroed) that is readily available;\n       note that this doesn't reflect the actual memory available\n       (use 'available' instead)\n\n    Platform-specific fields:\n\n     - active (UNIX):\n       memory currently in use or very recently used, and so it is in RAM.\n\n     - inactive (UNIX):\n       memory that is marked as not used.\n\n     - buffers (BSD, Linux):\n       cache for things like file system metadata.\n\n     - cached (BSD, macOS):\n       cache for various things.\n\n     - wired (macOS, BSD):\n       memory that is marked to always stay in RAM. It is never moved to disk.\n\n     - shared (BSD):\n       memory that may be simultaneously accessed by multiple processes.\n\n    The sum of 'used' and 'available' does not necessarily equal total.\n    On Windows 'available' and 'free' are the same.\n    \"\"\"\n    global _TOTAL_PHYMEM\n    ret = _psplatform.virtual_memory()\n    # cached for later use in Process.memory_percent()\n    _TOTAL_PHYMEM = ret.total\n    return ret\n\n\ndef swap_memory():\n    \"\"\"Return system swap memory statistics as a namedtuple including\n    the following fields:\n\n     - total:   total swap memory in bytes\n     - used:    used swap memory in bytes\n     - free:    free swap memory in bytes\n     - percent: the percentage usage\n     - sin:     no. of bytes the system has swapped in from disk (cumulative)\n     - sout:    no. of bytes the system has swapped out from disk (cumulative)\n\n    'sin' and 'sout' on Windows are meaningless and always set to 0.\n    \"\"\"\n    return _psplatform.swap_memory()\n\n\n# =====================================================================\n# --- disks/partitions related functions\n# =====================================================================\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage statistics about the given *path* as a\n    namedtuple including total, used and free space expressed in bytes\n    plus the percentage usage.\n    \"\"\"\n    return _psplatform.disk_usage(path)\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted partitions as a list of\n    (device, mountpoint, fstype, opts) namedtuple.\n    'opts' field is a raw string separated by commas indicating mount\n    options which may vary depending on the platform.\n\n    If *all* parameter is False return physical devices only and ignore\n    all others.\n    \"\"\"\n    return _psplatform.disk_partitions(all)\n\n\ndef disk_io_counters(perdisk=False, nowrap=True):\n    \"\"\"Return system disk I/O statistics as a namedtuple including\n    the following fields:\n\n     - read_count:  number of reads\n     - write_count: number of writes\n     - read_bytes:  number of bytes read\n     - write_bytes: number of bytes written\n     - read_time:   time spent reading from disk (in ms)\n     - write_time:  time spent writing to disk (in ms)\n\n    Platform specific:\n\n     - busy_time: (Linux, FreeBSD) time spent doing actual I/Os (in ms)\n     - read_merged_count (Linux): number of merged reads\n     - write_merged_count (Linux): number of merged writes\n\n    If *perdisk* is True return the same information for every\n    physical disk installed on the system as a dictionary\n    with partition names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add \"old value\" to \"new value\" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    \"disk_io_counters.cache_clear()\" can be used to invalidate the\n    cache.\n\n    On recent Windows versions 'diskperf -y' command may need to be\n    executed first otherwise this function won't find any disk.\n    \"\"\"\n    kwargs = dict(perdisk=perdisk) if LINUX else {}\n    rawdict = _psplatform.disk_io_counters(**kwargs)\n    if not rawdict:\n        return {} if perdisk else None\n    if nowrap:\n        rawdict = _wrap_numbers(rawdict, 'psutil.disk_io_counters')\n    nt = getattr(_psplatform, \"sdiskio\", _common.sdiskio)\n    if perdisk:\n        for disk, fields in rawdict.items():\n            rawdict[disk] = nt(*fields)\n        return rawdict\n    else:\n        return nt(*(sum(x) for x in zip(*rawdict.values())))\n\n\ndisk_io_counters.cache_clear = functools.partial(\n    _wrap_numbers.cache_clear, 'psutil.disk_io_counters'\n)\ndisk_io_counters.cache_clear.__doc__ = \"Clears nowrap argument cache\"\n\n\n# =====================================================================\n# --- network related functions\n# =====================================================================\n\n\ndef net_io_counters(pernic=False, nowrap=True):\n    \"\"\"Return network I/O statistics as a namedtuple including\n    the following fields:\n\n     - bytes_sent:   number of bytes sent\n     - bytes_recv:   number of bytes received\n     - packets_sent: number of packets sent\n     - packets_recv: number of packets received\n     - errin:        total number of errors while receiving\n     - errout:       total number of errors while sending\n     - dropin:       total number of incoming packets which were dropped\n     - dropout:      total number of outgoing packets which were dropped\n                     (always 0 on macOS and BSD)\n\n    If *pernic* is True return the same information for every\n    network interface installed on the system as a dictionary\n    with network interface names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add \"old value\" to \"new value\" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    \"net_io_counters.cache_clear()\" can be used to invalidate the\n    cache.\n    \"\"\"\n    rawdict = _psplatform.net_io_counters()\n    if not rawdict:\n        return {} if pernic else None\n    if nowrap:\n        rawdict = _wrap_numbers(rawdict, 'psutil.net_io_counters')\n    if pernic:\n        for nic, fields in rawdict.items():\n            rawdict[nic] = _common.snetio(*fields)\n        return rawdict\n    else:\n        return _common.snetio(*[sum(x) for x in zip(*rawdict.values())])\n\n\nnet_io_counters.cache_clear = functools.partial(\n    _wrap_numbers.cache_clear, 'psutil.net_io_counters'\n)\nnet_io_counters.cache_clear.__doc__ = \"Clears nowrap argument cache\"\n\n\ndef net_connections(kind='inet'):\n    \"\"\"Return system-wide socket connections as a list of\n    (fd, family, type, laddr, raddr, status, pid) namedtuples.\n    In case of limited privileges 'fd' and 'pid' may be set to -1\n    and None respectively.\n    The *kind* parameter filters for connections that fit the\n    following criteria:\n\n    +------------+----------------------------------------------------+\n    | Kind Value | Connections using                                  |\n    +------------+----------------------------------------------------+\n    | inet       | IPv4 and IPv6                                      |\n    | inet4      | IPv4                                               |\n    | inet6      | IPv6                                               |\n    | tcp        | TCP                                                |\n    | tcp4       | TCP over IPv4                                      |\n    | tcp6       | TCP over IPv6                                      |\n    | udp        | UDP                                                |\n    | udp4       | UDP over IPv4                                      |\n    | udp6       | UDP over IPv6                                      |\n    | unix       | UNIX socket (both UDP and TCP protocols)           |\n    | all        | the sum of all the possible families and protocols |\n    +------------+----------------------------------------------------+\n\n    On macOS this function requires root privileges.\n    \"\"\"\n    return _psplatform.net_connections(kind)\n\n\ndef net_if_addrs():\n    \"\"\"Return the addresses associated to each NIC (network interface\n    card) installed on the system as a dictionary whose keys are the\n    NIC names and value is a list of namedtuples for each address\n    assigned to the NIC. Each namedtuple includes 5 fields:\n\n     - family: can be either socket.AF_INET, socket.AF_INET6 or\n               psutil.AF_LINK, which refers to a MAC address.\n     - address: is the primary address and it is always set.\n     - netmask: and 'broadcast' and 'ptp' may be None.\n     - ptp: stands for \"point to point\" and references the\n            destination address on a point to point interface\n            (typically a VPN).\n     - broadcast: and *ptp* are mutually exclusive.\n\n    Note: you can have more than one address of the same family\n    associated with each interface.\n    \"\"\"\n    has_enums = _PY3\n    if has_enums:\n        import socket\n    rawlist = _psplatform.net_if_addrs()\n    rawlist.sort(key=lambda x: x[1])  # sort by family\n    ret = collections.defaultdict(list)\n    for name, fam, addr, mask, broadcast, ptp in rawlist:\n        if has_enums:\n            try:\n                fam = socket.AddressFamily(fam)\n            except ValueError:\n                if WINDOWS and fam == -1:\n                    fam = _psplatform.AF_LINK\n                elif (\n                    hasattr(_psplatform, \"AF_LINK\")\n                    and fam == _psplatform.AF_LINK\n                ):\n                    # Linux defines AF_LINK as an alias for AF_PACKET.\n                    # We re-set the family here so that repr(family)\n                    # will show AF_LINK rather than AF_PACKET\n                    fam = _psplatform.AF_LINK\n        if fam == _psplatform.AF_LINK:\n            # The underlying C function may return an incomplete MAC\n            # address in which case we fill it with null bytes, see:\n            # https://github.com/giampaolo/psutil/issues/786\n            separator = \":\" if POSIX else \"-\"\n            while addr.count(separator) < 5:\n                addr += \"%s00\" % separator\n        ret[name].append(_common.snicaddr(fam, addr, mask, broadcast, ptp))\n    return dict(ret)\n\n\ndef net_if_stats():\n    \"\"\"Return information about each NIC (network interface card)\n    installed on the system as a dictionary whose keys are the\n    NIC names and value is a namedtuple with the following fields:\n\n     - isup: whether the interface is up (bool)\n     - duplex: can be either NIC_DUPLEX_FULL, NIC_DUPLEX_HALF or\n               NIC_DUPLEX_UNKNOWN\n     - speed: the NIC speed expressed in mega bits (MB); if it can't\n              be determined (e.g. 'localhost') it will be set to 0.\n     - mtu: the maximum transmission unit expressed in bytes.\n    \"\"\"\n    return _psplatform.net_if_stats()\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\n# Linux, macOS\nif hasattr(_psplatform, \"sensors_temperatures\"):\n\n    def sensors_temperatures(fahrenheit=False):\n        \"\"\"Return hardware temperatures. Each entry is a namedtuple\n        representing a certain hardware sensor (it may be a CPU, an\n        hard disk or something else, depending on the OS and its\n        configuration).\n        All temperatures are expressed in celsius unless *fahrenheit*\n        is set to True.\n        \"\"\"\n\n        def convert(n):\n            if n is not None:\n                return (float(n) * 9 / 5) + 32 if fahrenheit else n\n\n        ret = collections.defaultdict(list)\n        rawdict = _psplatform.sensors_temperatures()\n\n        for name, values in rawdict.items():\n            while values:\n                label, current, high, critical = values.pop(0)\n                current = convert(current)\n                high = convert(high)\n                critical = convert(critical)\n\n                if high and not critical:\n                    critical = high\n                elif critical and not high:\n                    high = critical\n\n                ret[name].append(\n                    _common.shwtemp(label, current, high, critical)\n                )\n\n        return dict(ret)\n\n    __all__.append(\"sensors_temperatures\")\n\n\n# Linux\nif hasattr(_psplatform, \"sensors_fans\"):\n\n    def sensors_fans():\n        \"\"\"Return fans speed. Each entry is a namedtuple\n        representing a certain hardware sensor.\n        All speed are expressed in RPM (rounds per minute).\n        \"\"\"\n        return _psplatform.sensors_fans()\n\n    __all__.append(\"sensors_fans\")\n\n\n# Linux, Windows, FreeBSD, macOS\nif hasattr(_psplatform, \"sensors_battery\"):\n\n    def sensors_battery():\n        \"\"\"Return battery information. If no battery is installed\n        returns None.\n\n         - percent: battery power left as a percentage.\n         - secsleft: a rough approximation of how many seconds are left\n                     before the battery runs out of power. May be\n                     POWER_TIME_UNLIMITED or POWER_TIME_UNLIMITED.\n         - power_plugged: True if the AC power cable is connected.\n        \"\"\"\n        return _psplatform.sensors_battery()\n\n    __all__.append(\"sensors_battery\")\n\n\n# =====================================================================\n# --- other system related functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"Return the system boot time expressed in seconds since the epoch.\"\"\"\n    # Note: we are not caching this because it is subject to\n    # system clock updates.\n    return _psplatform.boot_time()\n\n\ndef users():\n    \"\"\"Return users currently connected on the system as a list of\n    namedtuples including the following fields.\n\n     - user: the name of the user\n     - terminal: the tty or pseudo-tty associated with the user, if any.\n     - host: the host name associated with the entry, if any.\n     - started: the creation time as a floating point number expressed in\n       seconds since the epoch.\n    \"\"\"\n    return _psplatform.users()\n\n\n# =====================================================================\n# --- Windows services\n# =====================================================================\n\n\nif WINDOWS:\n\n    def win_service_iter():\n        \"\"\"Return a generator yielding a WindowsService instance for all\n        Windows services installed.\n        \"\"\"\n        return _psplatform.win_service_iter()\n\n    def win_service_get(name):\n        \"\"\"Get a Windows service by *name*.\n        Raise NoSuchProcess if no service with such name exists.\n        \"\"\"\n        return _psplatform.win_service_get(name)\n\n\n# =====================================================================\n\n\ndef _set_debug(value):\n    \"\"\"Enable or disable PSUTIL_DEBUG option, which prints debugging\n    messages to stderr.\n    \"\"\"\n    import psutil._common\n\n    psutil._common.PSUTIL_DEBUG = bool(value)\n    _psplatform.cext.set_debug(bool(value))\n\n\ndef test():  # pragma: no cover\n    from ._common import bytes2human\n    from ._compat import get_terminal_size\n\n    today_day = datetime.date.today()\n    # fmt: off\n    templ = \"%-10s %5s %5s %7s %7s %5s %6s %6s %6s  %s\"\n    attrs = ['pid', 'memory_percent', 'name', 'cmdline', 'cpu_times',\n             'create_time', 'memory_info', 'status', 'nice', 'username']\n    print(templ % (\"USER\", \"PID\", \"%MEM\", \"VSZ\", \"RSS\", \"NICE\",  # NOQA\n                   \"STATUS\", \"START\", \"TIME\", \"CMDLINE\"))\n    # fmt: on\n    for p in process_iter(attrs, ad_value=None):\n        if p.info['create_time']:\n            ctime = datetime.datetime.fromtimestamp(p.info['create_time'])\n            if ctime.date() == today_day:\n                ctime = ctime.strftime(\"%H:%M\")\n            else:\n                ctime = ctime.strftime(\"%b%d\")\n        else:\n            ctime = ''\n        if p.info['cpu_times']:\n            cputime = time.strftime(\n                \"%M:%S\", time.localtime(sum(p.info['cpu_times']))\n            )\n        else:\n            cputime = ''\n\n        user = p.info['username'] or ''\n        if not user and POSIX:\n            try:\n                user = p.uids()[0]\n            except Error:\n                pass\n        if user and WINDOWS and '\\\\' in user:\n            user = user.split('\\\\')[1]\n        user = user[:9]\n        vms = (\n            bytes2human(p.info['memory_info'].vms)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        rss = (\n            bytes2human(p.info['memory_info'].rss)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        memp = (\n            round(p.info['memory_percent'], 1)\n            if p.info['memory_percent'] is not None\n            else ''\n        )\n        nice = int(p.info['nice']) if p.info['nice'] else ''\n        if p.info['cmdline']:\n            cmdline = ' '.join(p.info['cmdline'])\n        else:\n            cmdline = p.info['name']\n        status = p.info['status'][:5] if p.info['status'] else ''\n\n        line = templ % (\n            user[:10],\n            p.info['pid'],\n            memp,\n            vms,\n            rss,\n            nice,\n            status,\n            ctime,\n            cputime,\n            cmdline,\n        )\n        print(line[: get_terminal_size()[0]])  # NOQA\n\n\ndel memoize_when_activated, division\nif sys.version_info[0] < 3:\n    del num, x  # noqa\n\nif __name__ == \"__main__\":\n    test()\n", "psutil/tests/test_connections.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for psutil.net_connections() and Process.net_connections() APIs.\"\"\"\n\nimport os\nimport socket\nimport textwrap\nimport unittest\nfrom contextlib import closing\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\n\nimport psutil\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._common import supports_ipv6\nfrom psutil._compat import PY3\nfrom psutil.tests import AF_UNIX\nfrom psutil.tests import HAS_NET_CONNECTIONS_UNIX\nfrom psutil.tests import SKIP_SYSCONS\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import bind_socket\nfrom psutil.tests import bind_unix_socket\nfrom psutil.tests import check_connection_ntuple\nfrom psutil.tests import create_sockets\nfrom psutil.tests import filter_proc_net_connections\nfrom psutil.tests import reap_children\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import serialrun\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import tcp_socketpair\nfrom psutil.tests import unix_socketpair\nfrom psutil.tests import wait_for_file\n\n\nSOCK_SEQPACKET = getattr(socket, \"SOCK_SEQPACKET\", object())\n\n\ndef this_proc_net_connections(kind):\n    cons = psutil.Process().net_connections(kind=kind)\n    if kind in (\"all\", \"unix\"):\n        return filter_proc_net_connections(cons)\n    return cons\n\n\n@serialrun\nclass ConnectionTestCase(PsutilTestCase):\n    def setUp(self):\n        self.assertEqual(this_proc_net_connections(kind='all'), [])\n\n    def tearDown(self):\n        # Make sure we closed all resources.\n        self.assertEqual(this_proc_net_connections(kind='all'), [])\n\n    def compare_procsys_connections(self, pid, proc_cons, kind='all'):\n        \"\"\"Given a process PID and its list of connections compare\n        those against system-wide connections retrieved via\n        psutil.net_connections.\n        \"\"\"\n        try:\n            sys_cons = psutil.net_connections(kind=kind)\n        except psutil.AccessDenied:\n            # On MACOS, system-wide connections are retrieved by iterating\n            # over all processes\n            if MACOS:\n                return\n            else:\n                raise\n        # Filter for this proc PID and exlucde PIDs from the tuple.\n        sys_cons = [c[:-1] for c in sys_cons if c.pid == pid]\n        sys_cons.sort()\n        proc_cons.sort()\n        self.assertEqual(proc_cons, sys_cons)\n\n\nclass TestBasicOperations(ConnectionTestCase):\n    @unittest.skipIf(SKIP_SYSCONS, \"requires root\")\n    def test_system(self):\n        with create_sockets():\n            for conn in psutil.net_connections(kind='all'):\n                check_connection_ntuple(conn)\n\n    def test_process(self):\n        with create_sockets():\n            for conn in this_proc_net_connections(kind='all'):\n                check_connection_ntuple(conn)\n\n    def test_invalid_kind(self):\n        self.assertRaises(ValueError, this_proc_net_connections, kind='???')\n        self.assertRaises(ValueError, psutil.net_connections, kind='???')\n\n\n@serialrun\nclass TestUnconnectedSockets(ConnectionTestCase):\n    \"\"\"Tests sockets which are open but not connected to anything.\"\"\"\n\n    def get_conn_from_sock(self, sock):\n        cons = this_proc_net_connections(kind='all')\n        smap = dict([(c.fd, c) for c in cons])\n        if NETBSD or FREEBSD:\n            # NetBSD opens a UNIX socket to /var/log/run\n            # so there may be more connections.\n            return smap[sock.fileno()]\n        else:\n            self.assertEqual(len(cons), 1)\n            if cons[0].fd != -1:\n                self.assertEqual(smap[sock.fileno()].fd, sock.fileno())\n            return cons[0]\n\n    def check_socket(self, sock):\n        \"\"\"Given a socket, makes sure it matches the one obtained\n        via psutil. It assumes this process created one connection\n        only (the one supposed to be checked).\n        \"\"\"\n        conn = self.get_conn_from_sock(sock)\n        check_connection_ntuple(conn)\n\n        # fd, family, type\n        if conn.fd != -1:\n            self.assertEqual(conn.fd, sock.fileno())\n        self.assertEqual(conn.family, sock.family)\n        # see: http://bugs.python.org/issue30204\n        self.assertEqual(\n            conn.type, sock.getsockopt(socket.SOL_SOCKET, socket.SO_TYPE)\n        )\n\n        # local address\n        laddr = sock.getsockname()\n        if not laddr and PY3 and isinstance(laddr, bytes):\n            # See: http://bugs.python.org/issue30205\n            laddr = laddr.decode()\n        if sock.family == AF_INET6:\n            laddr = laddr[:2]\n        self.assertEqual(conn.laddr, laddr)\n\n        # XXX Solaris can't retrieve system-wide UNIX sockets\n        if sock.family == AF_UNIX and HAS_NET_CONNECTIONS_UNIX:\n            cons = this_proc_net_connections(kind='all')\n            self.compare_procsys_connections(os.getpid(), cons, kind='all')\n        return conn\n\n    def test_tcp_v4(self):\n        addr = (\"127.0.0.1\", 0)\n        with closing(bind_socket(AF_INET, SOCK_STREAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            self.assertEqual(conn.raddr, ())\n            self.assertEqual(conn.status, psutil.CONN_LISTEN)\n\n    @unittest.skipIf(not supports_ipv6(), \"IPv6 not supported\")\n    def test_tcp_v6(self):\n        addr = (\"::1\", 0)\n        with closing(bind_socket(AF_INET6, SOCK_STREAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            self.assertEqual(conn.raddr, ())\n            self.assertEqual(conn.status, psutil.CONN_LISTEN)\n\n    def test_udp_v4(self):\n        addr = (\"127.0.0.1\", 0)\n        with closing(bind_socket(AF_INET, SOCK_DGRAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            self.assertEqual(conn.raddr, ())\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n    @unittest.skipIf(not supports_ipv6(), \"IPv6 not supported\")\n    def test_udp_v6(self):\n        addr = (\"::1\", 0)\n        with closing(bind_socket(AF_INET6, SOCK_DGRAM, addr=addr)) as sock:\n            conn = self.check_socket(sock)\n            self.assertEqual(conn.raddr, ())\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_unix_tcp(self):\n        testfn = self.get_testfn()\n        with closing(bind_unix_socket(testfn, type=SOCK_STREAM)) as sock:\n            conn = self.check_socket(sock)\n            self.assertEqual(conn.raddr, \"\")\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_unix_udp(self):\n        testfn = self.get_testfn()\n        with closing(bind_unix_socket(testfn, type=SOCK_STREAM)) as sock:\n            conn = self.check_socket(sock)\n            self.assertEqual(conn.raddr, \"\")\n            self.assertEqual(conn.status, psutil.CONN_NONE)\n\n\n@serialrun\nclass TestConnectedSocket(ConnectionTestCase):\n    \"\"\"Test socket pairs which are actually connected to\n    each other.\n    \"\"\"\n\n    # On SunOS, even after we close() it, the server socket stays around\n    # in TIME_WAIT state.\n    @unittest.skipIf(SUNOS, \"unreliable on SUONS\")\n    def test_tcp(self):\n        addr = (\"127.0.0.1\", 0)\n        self.assertEqual(this_proc_net_connections(kind='tcp4'), [])\n        server, client = tcp_socketpair(AF_INET, addr=addr)\n        try:\n            cons = this_proc_net_connections(kind='tcp4')\n            self.assertEqual(len(cons), 2)\n            self.assertEqual(cons[0].status, psutil.CONN_ESTABLISHED)\n            self.assertEqual(cons[1].status, psutil.CONN_ESTABLISHED)\n            # May not be fast enough to change state so it stays\n            # commenteed.\n            # client.close()\n            # cons = this_proc_net_connections(kind='all')\n            # self.assertEqual(len(cons), 1)\n            # self.assertEqual(cons[0].status, psutil.CONN_CLOSE_WAIT)\n        finally:\n            server.close()\n            client.close()\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_unix(self):\n        testfn = self.get_testfn()\n        server, client = unix_socketpair(testfn)\n        try:\n            cons = this_proc_net_connections(kind='unix')\n            assert not (cons[0].laddr and cons[0].raddr), cons\n            assert not (cons[1].laddr and cons[1].raddr), cons\n            if NETBSD or FREEBSD:\n                # On NetBSD creating a UNIX socket will cause\n                # a UNIX connection to  /var/run/log.\n                cons = [c for c in cons if c.raddr != '/var/run/log']\n            self.assertEqual(len(cons), 2, msg=cons)\n            if LINUX or FREEBSD or SUNOS or OPENBSD:\n                # remote path is never set\n                self.assertEqual(cons[0].raddr, \"\")\n                self.assertEqual(cons[1].raddr, \"\")\n                # one local address should though\n                self.assertEqual(testfn, cons[0].laddr or cons[1].laddr)\n            else:\n                # On other systems either the laddr or raddr\n                # of both peers are set.\n                self.assertEqual(cons[0].laddr or cons[1].laddr, testfn)\n        finally:\n            server.close()\n            client.close()\n\n\nclass TestFilters(ConnectionTestCase):\n    def test_filters(self):\n        def check(kind, families, types):\n            for conn in this_proc_net_connections(kind=kind):\n                self.assertIn(conn.family, families)\n                self.assertIn(conn.type, types)\n            if not SKIP_SYSCONS:\n                for conn in psutil.net_connections(kind=kind):\n                    self.assertIn(conn.family, families)\n                    self.assertIn(conn.type, types)\n\n        with create_sockets():\n            check(\n                'all',\n                [AF_INET, AF_INET6, AF_UNIX],\n                [SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET],\n            )\n            check('inet', [AF_INET, AF_INET6], [SOCK_STREAM, SOCK_DGRAM])\n            check('inet4', [AF_INET], [SOCK_STREAM, SOCK_DGRAM])\n            check('tcp', [AF_INET, AF_INET6], [SOCK_STREAM])\n            check('tcp4', [AF_INET], [SOCK_STREAM])\n            check('tcp6', [AF_INET6], [SOCK_STREAM])\n            check('udp', [AF_INET, AF_INET6], [SOCK_DGRAM])\n            check('udp4', [AF_INET], [SOCK_DGRAM])\n            check('udp6', [AF_INET6], [SOCK_DGRAM])\n            if HAS_NET_CONNECTIONS_UNIX:\n                check(\n                    'unix',\n                    [AF_UNIX],\n                    [SOCK_STREAM, SOCK_DGRAM, SOCK_SEQPACKET],\n                )\n\n    @skip_on_access_denied(only_if=MACOS)\n    def test_combos(self):\n        reap_children()\n\n        def check_conn(proc, conn, family, type, laddr, raddr, status, kinds):\n            all_kinds = (\n                \"all\",\n                \"inet\",\n                \"inet4\",\n                \"inet6\",\n                \"tcp\",\n                \"tcp4\",\n                \"tcp6\",\n                \"udp\",\n                \"udp4\",\n                \"udp6\",\n            )\n            check_connection_ntuple(conn)\n            self.assertEqual(conn.family, family)\n            self.assertEqual(conn.type, type)\n            self.assertEqual(conn.laddr, laddr)\n            self.assertEqual(conn.raddr, raddr)\n            self.assertEqual(conn.status, status)\n            for kind in all_kinds:\n                cons = proc.net_connections(kind=kind)\n                if kind in kinds:\n                    self.assertNotEqual(cons, [])\n                else:\n                    self.assertEqual(cons, [])\n            # compare against system-wide connections\n            # XXX Solaris can't retrieve system-wide UNIX\n            # sockets.\n            if HAS_NET_CONNECTIONS_UNIX:\n                self.compare_procsys_connections(proc.pid, [conn])\n\n        tcp_template = textwrap.dedent(\"\"\"\n            import socket, time\n            s = socket.socket({family}, socket.SOCK_STREAM)\n            s.bind(('{addr}', 0))\n            s.listen(5)\n            with open('{testfn}', 'w') as f:\n                f.write(str(s.getsockname()[:2]))\n            [time.sleep(0.1) for x in range(100)]\n            \"\"\")\n\n        udp_template = textwrap.dedent(\"\"\"\n            import socket, time\n            s = socket.socket({family}, socket.SOCK_DGRAM)\n            s.bind(('{addr}', 0))\n            with open('{testfn}', 'w') as f:\n                f.write(str(s.getsockname()[:2]))\n            [time.sleep(0.1) for x in range(100)]\n            \"\"\")\n\n        # must be relative on Windows\n        testfile = os.path.basename(self.get_testfn(dir=os.getcwd()))\n        tcp4_template = tcp_template.format(\n            family=int(AF_INET), addr=\"127.0.0.1\", testfn=testfile\n        )\n        udp4_template = udp_template.format(\n            family=int(AF_INET), addr=\"127.0.0.1\", testfn=testfile\n        )\n        tcp6_template = tcp_template.format(\n            family=int(AF_INET6), addr=\"::1\", testfn=testfile\n        )\n        udp6_template = udp_template.format(\n            family=int(AF_INET6), addr=\"::1\", testfn=testfile\n        )\n\n        # launch various subprocess instantiating a socket of various\n        # families and types to enrich psutil results\n        tcp4_proc = self.pyrun(tcp4_template)\n        tcp4_addr = eval(wait_for_file(testfile, delete=True))  # noqa\n        udp4_proc = self.pyrun(udp4_template)\n        udp4_addr = eval(wait_for_file(testfile, delete=True))  # noqa\n        if supports_ipv6():\n            tcp6_proc = self.pyrun(tcp6_template)\n            tcp6_addr = eval(wait_for_file(testfile, delete=True))  # noqa\n            udp6_proc = self.pyrun(udp6_template)\n            udp6_addr = eval(wait_for_file(testfile, delete=True))  # noqa\n        else:\n            tcp6_proc = None\n            udp6_proc = None\n            tcp6_addr = None\n            udp6_addr = None\n\n        for p in psutil.Process().children():\n            cons = p.net_connections()\n            self.assertEqual(len(cons), 1)\n            for conn in cons:\n                # TCP v4\n                if p.pid == tcp4_proc.pid:\n                    check_conn(\n                        p,\n                        conn,\n                        AF_INET,\n                        SOCK_STREAM,\n                        tcp4_addr,\n                        (),\n                        psutil.CONN_LISTEN,\n                        (\"all\", \"inet\", \"inet4\", \"tcp\", \"tcp4\"),\n                    )\n                # UDP v4\n                elif p.pid == udp4_proc.pid:\n                    check_conn(\n                        p,\n                        conn,\n                        AF_INET,\n                        SOCK_DGRAM,\n                        udp4_addr,\n                        (),\n                        psutil.CONN_NONE,\n                        (\"all\", \"inet\", \"inet4\", \"udp\", \"udp4\"),\n                    )\n                # TCP v6\n                elif p.pid == getattr(tcp6_proc, \"pid\", None):\n                    check_conn(\n                        p,\n                        conn,\n                        AF_INET6,\n                        SOCK_STREAM,\n                        tcp6_addr,\n                        (),\n                        psutil.CONN_LISTEN,\n                        (\"all\", \"inet\", \"inet6\", \"tcp\", \"tcp6\"),\n                    )\n                # UDP v6\n                elif p.pid == getattr(udp6_proc, \"pid\", None):\n                    check_conn(\n                        p,\n                        conn,\n                        AF_INET6,\n                        SOCK_DGRAM,\n                        udp6_addr,\n                        (),\n                        psutil.CONN_NONE,\n                        (\"all\", \"inet\", \"inet6\", \"udp\", \"udp6\"),\n                    )\n\n    def test_count(self):\n        with create_sockets():\n            # tcp\n            cons = this_proc_net_connections(kind='tcp')\n            self.assertEqual(len(cons), 2 if supports_ipv6() else 1)\n            for conn in cons:\n                self.assertIn(conn.family, (AF_INET, AF_INET6))\n                self.assertEqual(conn.type, SOCK_STREAM)\n            # tcp4\n            cons = this_proc_net_connections(kind='tcp4')\n            self.assertEqual(len(cons), 1)\n            self.assertEqual(cons[0].family, AF_INET)\n            self.assertEqual(cons[0].type, SOCK_STREAM)\n            # tcp6\n            if supports_ipv6():\n                cons = this_proc_net_connections(kind='tcp6')\n                self.assertEqual(len(cons), 1)\n                self.assertEqual(cons[0].family, AF_INET6)\n                self.assertEqual(cons[0].type, SOCK_STREAM)\n            # udp\n            cons = this_proc_net_connections(kind='udp')\n            self.assertEqual(len(cons), 2 if supports_ipv6() else 1)\n            for conn in cons:\n                self.assertIn(conn.family, (AF_INET, AF_INET6))\n                self.assertEqual(conn.type, SOCK_DGRAM)\n            # udp4\n            cons = this_proc_net_connections(kind='udp4')\n            self.assertEqual(len(cons), 1)\n            self.assertEqual(cons[0].family, AF_INET)\n            self.assertEqual(cons[0].type, SOCK_DGRAM)\n            # udp6\n            if supports_ipv6():\n                cons = this_proc_net_connections(kind='udp6')\n                self.assertEqual(len(cons), 1)\n                self.assertEqual(cons[0].family, AF_INET6)\n                self.assertEqual(cons[0].type, SOCK_DGRAM)\n            # inet\n            cons = this_proc_net_connections(kind='inet')\n            self.assertEqual(len(cons), 4 if supports_ipv6() else 2)\n            for conn in cons:\n                self.assertIn(conn.family, (AF_INET, AF_INET6))\n                self.assertIn(conn.type, (SOCK_STREAM, SOCK_DGRAM))\n            # inet6\n            if supports_ipv6():\n                cons = this_proc_net_connections(kind='inet6')\n                self.assertEqual(len(cons), 2)\n                for conn in cons:\n                    self.assertEqual(conn.family, AF_INET6)\n                    self.assertIn(conn.type, (SOCK_STREAM, SOCK_DGRAM))\n            # Skipped on BSD becayse by default the Python process\n            # creates a UNIX socket to '/var/run/log'.\n            if HAS_NET_CONNECTIONS_UNIX and not (FREEBSD or NETBSD):\n                cons = this_proc_net_connections(kind='unix')\n                self.assertEqual(len(cons), 3)\n                for conn in cons:\n                    self.assertEqual(conn.family, AF_UNIX)\n                    self.assertIn(conn.type, (SOCK_STREAM, SOCK_DGRAM))\n\n\n@unittest.skipIf(SKIP_SYSCONS, \"requires root\")\nclass TestSystemWideConnections(ConnectionTestCase):\n    \"\"\"Tests for net_connections().\"\"\"\n\n    def test_it(self):\n        def check(cons, families, types_):\n            for conn in cons:\n                self.assertIn(conn.family, families, msg=conn)\n                if conn.family != AF_UNIX:\n                    self.assertIn(conn.type, types_, msg=conn)\n                check_connection_ntuple(conn)\n\n        with create_sockets():\n            from psutil._common import conn_tmap\n\n            for kind, groups in conn_tmap.items():\n                # XXX: SunOS does not retrieve UNIX sockets.\n                if kind == 'unix' and not HAS_NET_CONNECTIONS_UNIX:\n                    continue\n                families, types_ = groups\n                cons = psutil.net_connections(kind)\n                self.assertEqual(len(cons), len(set(cons)))\n                check(cons, families, types_)\n\n    @retry_on_failure()\n    def test_multi_sockets_procs(self):\n        # Creates multiple sub processes, each creating different\n        # sockets. For each process check that proc.net_connections()\n        # and psutil.net_connections() return the same results.\n        # This is done mainly to check whether net_connections()'s\n        # pid is properly set, see:\n        # https://github.com/giampaolo/psutil/issues/1013\n        with create_sockets() as socks:\n            expected = len(socks)\n        pids = []\n        times = 10\n        fnames = []\n        for _ in range(times):\n            fname = self.get_testfn()\n            fnames.append(fname)\n            src = textwrap.dedent(\"\"\"\\\n                import time, os\n                from psutil.tests import create_sockets\n                with create_sockets():\n                    with open(r'%s', 'w') as f:\n                        f.write(\"hello\")\n                    [time.sleep(0.1) for x in range(100)]\n                \"\"\" % fname)\n            sproc = self.pyrun(src)\n            pids.append(sproc.pid)\n\n        # sync\n        for fname in fnames:\n            wait_for_file(fname)\n\n        syscons = [\n            x for x in psutil.net_connections(kind='all') if x.pid in pids\n        ]\n        for pid in pids:\n            self.assertEqual(\n                len([x for x in syscons if x.pid == pid]), expected\n            )\n            p = psutil.Process(pid)\n            self.assertEqual(len(p.net_connections('all')), expected)\n\n\nclass TestMisc(PsutilTestCase):\n    def test_net_connection_constants(self):\n        ints = []\n        strs = []\n        for name in dir(psutil):\n            if name.startswith('CONN_'):\n                num = getattr(psutil, name)\n                str_ = str(num)\n                assert str_.isupper(), str_\n                self.assertNotIn(str, strs)\n                self.assertNotIn(num, ints)\n                ints.append(num)\n                strs.append(str_)\n        if SUNOS:\n            psutil.CONN_IDLE  # noqa\n            psutil.CONN_BOUND  # noqa\n        if WINDOWS:\n            psutil.CONN_DELETE_TCB  # noqa\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_aix.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'\n# Copyright (c) 2017, Arnon Yaari\n# All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"AIX specific tests.\"\"\"\n\nimport re\nimport unittest\n\nimport psutil\nfrom psutil import AIX\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import sh\n\n\n@unittest.skipIf(not AIX, \"AIX only\")\nclass AIXSpecificTestCase(PsutilTestCase):\n    def test_virtual_memory(self):\n        out = sh('/usr/bin/svmon -O unit=KB')\n        re_pattern = r\"memory\\s*\"\n        for field in (\"size inuse free pin virtual available mmode\").split():\n            re_pattern += r\"(?P<%s>\\S+)\\s+\" % (field,)\n        matchobj = re.search(re_pattern, out)\n\n        self.assertIsNotNone(\n            matchobj, \"svmon command returned unexpected output\"\n        )\n\n        KB = 1024\n        total = int(matchobj.group(\"size\")) * KB\n        available = int(matchobj.group(\"available\")) * KB\n        used = int(matchobj.group(\"inuse\")) * KB\n        free = int(matchobj.group(\"free\")) * KB\n\n        psutil_result = psutil.virtual_memory()\n\n        # TOLERANCE_SYS_MEM from psutil.tests is not enough. For some reason\n        # we're seeing differences of ~1.2 MB. 2 MB is still a good tolerance\n        # when compared to GBs.\n        TOLERANCE_SYS_MEM = 2 * KB * KB  # 2 MB\n        self.assertEqual(psutil_result.total, total)\n        self.assertAlmostEqual(\n            psutil_result.used, used, delta=TOLERANCE_SYS_MEM\n        )\n        self.assertAlmostEqual(\n            psutil_result.available, available, delta=TOLERANCE_SYS_MEM\n        )\n        self.assertAlmostEqual(\n            psutil_result.free, free, delta=TOLERANCE_SYS_MEM\n        )\n\n    def test_swap_memory(self):\n        out = sh('/usr/sbin/lsps -a')\n        # From the man page, \"The size is given in megabytes\" so we assume\n        # we'll always have 'MB' in the result\n        # TODO maybe try to use \"swap -l\" to check \"used\" too, but its units\n        # are not guaranteed to be \"MB\" so parsing may not be consistent\n        matchobj = re.search(\n            r\"(?P<space>\\S+)\\s+\"\n            r\"(?P<vol>\\S+)\\s+\"\n            r\"(?P<vg>\\S+)\\s+\"\n            r\"(?P<size>\\d+)MB\",\n            out,\n        )\n\n        self.assertIsNotNone(\n            matchobj, \"lsps command returned unexpected output\"\n        )\n\n        total_mb = int(matchobj.group(\"size\"))\n        MB = 1024**2\n        psutil_result = psutil.swap_memory()\n        # we divide our result by MB instead of multiplying the lsps value by\n        # MB because lsps may round down, so we round down too\n        self.assertEqual(int(psutil_result.total / MB), total_mb)\n\n    def test_cpu_stats(self):\n        out = sh('/usr/bin/mpstat -a')\n\n        re_pattern = r\"ALL\\s*\"\n        for field in (\n            \"min maj mpcs mpcr dev soft dec ph cs ics bound rq \"\n            \"push S3pull S3grd S0rd S1rd S2rd S3rd S4rd S5rd \"\n            \"sysc\"\n        ).split():\n            re_pattern += r\"(?P<%s>\\S+)\\s+\" % (field,)\n        matchobj = re.search(re_pattern, out)\n\n        self.assertIsNotNone(\n            matchobj, \"mpstat command returned unexpected output\"\n        )\n\n        # numbers are usually in the millions so 1000 is ok for tolerance\n        CPU_STATS_TOLERANCE = 1000\n        psutil_result = psutil.cpu_stats()\n        self.assertAlmostEqual(\n            psutil_result.ctx_switches,\n            int(matchobj.group(\"cs\")),\n            delta=CPU_STATS_TOLERANCE,\n        )\n        self.assertAlmostEqual(\n            psutil_result.syscalls,\n            int(matchobj.group(\"sysc\")),\n            delta=CPU_STATS_TOLERANCE,\n        )\n        self.assertAlmostEqual(\n            psutil_result.interrupts,\n            int(matchobj.group(\"dev\")),\n            delta=CPU_STATS_TOLERANCE,\n        )\n        self.assertAlmostEqual(\n            psutil_result.soft_interrupts,\n            int(matchobj.group(\"soft\")),\n            delta=CPU_STATS_TOLERANCE,\n        )\n\n    def test_cpu_count_logical(self):\n        out = sh('/usr/bin/mpstat -a')\n        mpstat_lcpu = int(re.search(r\"lcpu=(\\d+)\", out).group(1))\n        psutil_lcpu = psutil.cpu_count(logical=True)\n        self.assertEqual(mpstat_lcpu, psutil_lcpu)\n\n    def test_net_if_addrs_names(self):\n        out = sh('/etc/ifconfig -l')\n        ifconfig_names = set(out.split())\n        psutil_names = set(psutil.net_if_addrs().keys())\n        self.assertSetEqual(ifconfig_names, psutil_names)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_contracts.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Contracts tests. These tests mainly check API sanity in terms of\nreturned types and APIs availability.\nSome of these are duplicates of tests test_system.py and test_process.py.\n\"\"\"\n\nimport platform\nimport signal\nimport unittest\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._compat import long\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import PYPY\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import SKIP_SYSCONS\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import create_sockets\nfrom psutil.tests import enum\nfrom psutil.tests import is_namedtuple\nfrom psutil.tests import kernel_version\n\n\n# ===================================================================\n# --- APIs availability\n# ===================================================================\n\n# Make sure code reflects what doc promises in terms of APIs\n# availability.\n\n\nclass TestAvailConstantsAPIs(PsutilTestCase):\n    def test_PROCFS_PATH(self):\n        self.assertEqual(hasattr(psutil, \"PROCFS_PATH\"), LINUX or SUNOS or AIX)\n\n    def test_win_priority(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"ABOVE_NORMAL_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"BELOW_NORMAL_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"HIGH_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"IDLE_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"NORMAL_PRIORITY_CLASS\"), WINDOWS)\n        ae(hasattr(psutil, \"REALTIME_PRIORITY_CLASS\"), WINDOWS)\n\n    def test_linux_ioprio_linux(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"IOPRIO_CLASS_NONE\"), LINUX)\n        ae(hasattr(psutil, \"IOPRIO_CLASS_RT\"), LINUX)\n        ae(hasattr(psutil, \"IOPRIO_CLASS_BE\"), LINUX)\n        ae(hasattr(psutil, \"IOPRIO_CLASS_IDLE\"), LINUX)\n\n    def test_linux_ioprio_windows(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"IOPRIO_HIGH\"), WINDOWS)\n        ae(hasattr(psutil, \"IOPRIO_NORMAL\"), WINDOWS)\n        ae(hasattr(psutil, \"IOPRIO_LOW\"), WINDOWS)\n        ae(hasattr(psutil, \"IOPRIO_VERYLOW\"), WINDOWS)\n\n    @unittest.skipIf(\n        GITHUB_ACTIONS and LINUX, \"unsupported on GITHUB_ACTIONS + LINUX\"\n    )\n    def test_rlimit(self):\n        ae = self.assertEqual\n        ae(hasattr(psutil, \"RLIM_INFINITY\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_AS\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_CORE\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_CPU\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_DATA\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_FSIZE\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_MEMLOCK\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_NOFILE\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_NPROC\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_RSS\"), LINUX or FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_STACK\"), LINUX or FREEBSD)\n\n        ae(hasattr(psutil, \"RLIMIT_LOCKS\"), LINUX)\n        if POSIX:\n            if kernel_version() >= (2, 6, 8):\n                ae(hasattr(psutil, \"RLIMIT_MSGQUEUE\"), LINUX)\n            if kernel_version() >= (2, 6, 12):\n                ae(hasattr(psutil, \"RLIMIT_NICE\"), LINUX)\n            if kernel_version() >= (2, 6, 12):\n                ae(hasattr(psutil, \"RLIMIT_RTPRIO\"), LINUX)\n            if kernel_version() >= (2, 6, 25):\n                ae(hasattr(psutil, \"RLIMIT_RTTIME\"), LINUX)\n            if kernel_version() >= (2, 6, 8):\n                ae(hasattr(psutil, \"RLIMIT_SIGPENDING\"), LINUX)\n\n        ae(hasattr(psutil, \"RLIMIT_SWAP\"), FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_SBSIZE\"), FREEBSD)\n        ae(hasattr(psutil, \"RLIMIT_NPTS\"), FREEBSD)\n\n\nclass TestAvailSystemAPIs(PsutilTestCase):\n    def test_win_service_iter(self):\n        self.assertEqual(hasattr(psutil, \"win_service_iter\"), WINDOWS)\n\n    def test_win_service_get(self):\n        self.assertEqual(hasattr(psutil, \"win_service_get\"), WINDOWS)\n\n    def test_cpu_freq(self):\n        self.assertEqual(\n            hasattr(psutil, \"cpu_freq\"),\n            LINUX or MACOS or WINDOWS or FREEBSD or OPENBSD,\n        )\n\n    def test_sensors_temperatures(self):\n        self.assertEqual(\n            hasattr(psutil, \"sensors_temperatures\"), LINUX or FREEBSD\n        )\n\n    def test_sensors_fans(self):\n        self.assertEqual(hasattr(psutil, \"sensors_fans\"), LINUX)\n\n    def test_battery(self):\n        self.assertEqual(\n            hasattr(psutil, \"sensors_battery\"),\n            LINUX or WINDOWS or FREEBSD or MACOS,\n        )\n\n\nclass TestAvailProcessAPIs(PsutilTestCase):\n    def test_environ(self):\n        self.assertEqual(\n            hasattr(psutil.Process, \"environ\"),\n            LINUX\n            or MACOS\n            or WINDOWS\n            or AIX\n            or SUNOS\n            or FREEBSD\n            or OPENBSD\n            or NETBSD,\n        )\n\n    def test_uids(self):\n        self.assertEqual(hasattr(psutil.Process, \"uids\"), POSIX)\n\n    def test_gids(self):\n        self.assertEqual(hasattr(psutil.Process, \"uids\"), POSIX)\n\n    def test_terminal(self):\n        self.assertEqual(hasattr(psutil.Process, \"terminal\"), POSIX)\n\n    def test_ionice(self):\n        self.assertEqual(hasattr(psutil.Process, \"ionice\"), LINUX or WINDOWS)\n\n    @unittest.skipIf(\n        GITHUB_ACTIONS and LINUX, \"unsupported on GITHUB_ACTIONS + LINUX\"\n    )\n    def test_rlimit(self):\n        self.assertEqual(hasattr(psutil.Process, \"rlimit\"), LINUX or FREEBSD)\n\n    def test_io_counters(self):\n        hasit = hasattr(psutil.Process, \"io_counters\")\n        self.assertEqual(hasit, not (MACOS or SUNOS))\n\n    def test_num_fds(self):\n        self.assertEqual(hasattr(psutil.Process, \"num_fds\"), POSIX)\n\n    def test_num_handles(self):\n        self.assertEqual(hasattr(psutil.Process, \"num_handles\"), WINDOWS)\n\n    def test_cpu_affinity(self):\n        self.assertEqual(\n            hasattr(psutil.Process, \"cpu_affinity\"),\n            LINUX or WINDOWS or FREEBSD,\n        )\n\n    def test_cpu_num(self):\n        self.assertEqual(\n            hasattr(psutil.Process, \"cpu_num\"), LINUX or FREEBSD or SUNOS\n        )\n\n    def test_memory_maps(self):\n        hasit = hasattr(psutil.Process, \"memory_maps\")\n        self.assertEqual(hasit, not (OPENBSD or NETBSD or AIX or MACOS))\n\n\n# ===================================================================\n# --- API types\n# ===================================================================\n\n\nclass TestSystemAPITypes(PsutilTestCase):\n    \"\"\"Check the return types of system related APIs.\n    Mainly we want to test we never return unicode on Python 2, see:\n    https://github.com/giampaolo/psutil/issues/1039.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.proc = psutil.Process()\n\n    def assert_ntuple_of_nums(self, nt, type_=float, gezero=True):\n        assert is_namedtuple(nt)\n        for n in nt:\n            self.assertIsInstance(n, type_)\n            if gezero:\n                self.assertGreaterEqual(n, 0)\n\n    def test_cpu_times(self):\n        self.assert_ntuple_of_nums(psutil.cpu_times())\n        for nt in psutil.cpu_times(percpu=True):\n            self.assert_ntuple_of_nums(nt)\n\n    def test_cpu_percent(self):\n        self.assertIsInstance(psutil.cpu_percent(interval=None), float)\n        self.assertIsInstance(psutil.cpu_percent(interval=0.00001), float)\n\n    def test_cpu_times_percent(self):\n        self.assert_ntuple_of_nums(psutil.cpu_times_percent(interval=None))\n        self.assert_ntuple_of_nums(psutil.cpu_times_percent(interval=0.0001))\n\n    def test_cpu_count(self):\n        self.assertIsInstance(psutil.cpu_count(), int)\n\n    # TODO: remove this once 1892 is fixed\n    @unittest.skipIf(\n        MACOS and platform.machine() == 'arm64', \"skipped due to #1892\"\n    )\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_cpu_freq(self):\n        if psutil.cpu_freq() is None:\n            raise unittest.SkipTest(\"cpu_freq() returns None\")\n        self.assert_ntuple_of_nums(psutil.cpu_freq(), type_=(float, int, long))\n\n    def test_disk_io_counters(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for k, v in psutil.disk_io_counters(perdisk=True).items():\n            self.assertIsInstance(k, str)\n            self.assert_ntuple_of_nums(v, type_=(int, long))\n\n    def test_disk_partitions(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for disk in psutil.disk_partitions():\n            self.assertIsInstance(disk.device, str)\n            self.assertIsInstance(disk.mountpoint, str)\n            self.assertIsInstance(disk.fstype, str)\n            self.assertIsInstance(disk.opts, str)\n\n    @unittest.skipIf(SKIP_SYSCONS, \"requires root\")\n    def test_net_connections(self):\n        with create_sockets():\n            ret = psutil.net_connections('all')\n            self.assertEqual(len(ret), len(set(ret)))\n            for conn in ret:\n                assert is_namedtuple(conn)\n\n    def test_net_if_addrs(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for ifname, addrs in psutil.net_if_addrs().items():\n            self.assertIsInstance(ifname, str)\n            for addr in addrs:\n                if enum is not None and not PYPY:\n                    self.assertIsInstance(addr.family, enum.IntEnum)\n                else:\n                    self.assertIsInstance(addr.family, int)\n                self.assertIsInstance(addr.address, str)\n                self.assertIsInstance(addr.netmask, (str, type(None)))\n                self.assertIsInstance(addr.broadcast, (str, type(None)))\n\n    @unittest.skipIf(QEMU_USER, 'QEMU user not supported')\n    def test_net_if_stats(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for ifname, info in psutil.net_if_stats().items():\n            self.assertIsInstance(ifname, str)\n            self.assertIsInstance(info.isup, bool)\n            if enum is not None:\n                self.assertIsInstance(info.duplex, enum.IntEnum)\n            else:\n                self.assertIsInstance(info.duplex, int)\n            self.assertIsInstance(info.speed, int)\n            self.assertIsInstance(info.mtu, int)\n\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for ifname in psutil.net_io_counters(pernic=True):\n            self.assertIsInstance(ifname, str)\n\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_sensors_fans(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for name, units in psutil.sensors_fans().items():\n            self.assertIsInstance(name, str)\n            for unit in units:\n                self.assertIsInstance(unit.label, str)\n                self.assertIsInstance(unit.current, (float, int, type(None)))\n\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for name, units in psutil.sensors_temperatures().items():\n            self.assertIsInstance(name, str)\n            for unit in units:\n                self.assertIsInstance(unit.label, str)\n                self.assertIsInstance(unit.current, (float, int, type(None)))\n                self.assertIsInstance(unit.high, (float, int, type(None)))\n                self.assertIsInstance(unit.critical, (float, int, type(None)))\n\n    def test_boot_time(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        self.assertIsInstance(psutil.boot_time(), float)\n\n    def test_users(self):\n        # Duplicate of test_system.py. Keep it anyway.\n        for user in psutil.users():\n            self.assertIsInstance(user.name, str)\n            self.assertIsInstance(user.terminal, (str, type(None)))\n            self.assertIsInstance(user.host, (str, type(None)))\n            self.assertIsInstance(user.pid, (int, type(None)))\n\n\nclass TestProcessWaitType(PsutilTestCase):\n    @unittest.skipIf(not POSIX, \"not POSIX\")\n    def test_negative_signal(self):\n        p = psutil.Process(self.spawn_testproc().pid)\n        p.terminate()\n        code = p.wait()\n        self.assertEqual(code, -signal.SIGTERM)\n        if enum is not None:\n            self.assertIsInstance(code, enum.IntEnum)\n        else:\n            self.assertIsInstance(code, int)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_sunos.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Sun OS specific tests.\"\"\"\n\nimport os\nimport unittest\n\nimport psutil\nfrom psutil import SUNOS\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import sh\n\n\n@unittest.skipIf(not SUNOS, \"SUNOS only\")\nclass SunOSSpecificTestCase(PsutilTestCase):\n    def test_swap_memory(self):\n        out = sh('env PATH=/usr/sbin:/sbin:%s swap -l' % os.environ['PATH'])\n        lines = out.strip().split('\\n')[1:]\n        if not lines:\n            raise ValueError('no swap device(s) configured')\n        total = free = 0\n        for line in lines:\n            fields = line.split()\n            total = int(fields[3]) * 512\n            free = int(fields[4]) * 512\n        used = total - free\n\n        psutil_swap = psutil.swap_memory()\n        self.assertEqual(psutil_swap.total, total)\n        self.assertEqual(psutil_swap.used, used)\n        self.assertEqual(psutil_swap.free, free)\n\n    def test_cpu_count(self):\n        out = sh(\"/usr/sbin/psrinfo\")\n        self.assertEqual(psutil.cpu_count(), len(out.split('\\n')))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_system.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for system APIS.\"\"\"\n\nimport contextlib\nimport datetime\nimport errno\nimport os\nimport platform\nimport pprint\nimport shutil\nimport signal\nimport socket\nimport sys\nimport time\nimport unittest\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import long\nfrom psutil.tests import ASCII_FS\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import DEVNULL\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import IS_64BIT\nfrom psutil.tests import MACOS_12PLUS\nfrom psutil.tests import PYPY\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import UNICODE_SUFFIX\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import check_net_address\nfrom psutil.tests import enum\nfrom psutil.tests import mock\nfrom psutil.tests import retry_on_failure\n\n\n# ===================================================================\n# --- System-related API tests\n# ===================================================================\n\n\nclass TestProcessIter(PsutilTestCase):\n    def test_pid_presence(self):\n        self.assertIn(os.getpid(), [x.pid for x in psutil.process_iter()])\n        sproc = self.spawn_testproc()\n        self.assertIn(sproc.pid, [x.pid for x in psutil.process_iter()])\n        p = psutil.Process(sproc.pid)\n        p.kill()\n        p.wait()\n        self.assertNotIn(sproc.pid, [x.pid for x in psutil.process_iter()])\n\n    def test_no_duplicates(self):\n        ls = [x for x in psutil.process_iter()]\n        self.assertEqual(\n            sorted(ls, key=lambda x: x.pid),\n            sorted(set(ls), key=lambda x: x.pid),\n        )\n\n    def test_emulate_nsp(self):\n        list(psutil.process_iter())  # populate cache\n        for x in range(2):\n            with mock.patch(\n                'psutil.Process.as_dict',\n                side_effect=psutil.NoSuchProcess(os.getpid()),\n            ):\n                self.assertEqual(\n                    list(psutil.process_iter(attrs=[\"cpu_times\"])), []\n                )\n            psutil.process_iter.cache_clear()  # repeat test without cache\n\n    def test_emulate_access_denied(self):\n        list(psutil.process_iter())  # populate cache\n        for x in range(2):\n            with mock.patch(\n                'psutil.Process.as_dict',\n                side_effect=psutil.AccessDenied(os.getpid()),\n            ):\n                with self.assertRaises(psutil.AccessDenied):\n                    list(psutil.process_iter(attrs=[\"cpu_times\"]))\n            psutil.process_iter.cache_clear()  # repeat test without cache\n\n    def test_attrs(self):\n        for p in psutil.process_iter(attrs=['pid']):\n            self.assertEqual(list(p.info.keys()), ['pid'])\n        # yield again\n        for p in psutil.process_iter(attrs=['pid']):\n            self.assertEqual(list(p.info.keys()), ['pid'])\n        with self.assertRaises(ValueError):\n            list(psutil.process_iter(attrs=['foo']))\n        with mock.patch(\n            \"psutil._psplatform.Process.cpu_times\",\n            side_effect=psutil.AccessDenied(0, \"\"),\n        ) as m:\n            for p in psutil.process_iter(attrs=[\"pid\", \"cpu_times\"]):\n                self.assertIsNone(p.info['cpu_times'])\n                self.assertGreaterEqual(p.info['pid'], 0)\n            assert m.called\n        with mock.patch(\n            \"psutil._psplatform.Process.cpu_times\",\n            side_effect=psutil.AccessDenied(0, \"\"),\n        ) as m:\n            flag = object()\n            for p in psutil.process_iter(\n                attrs=[\"pid\", \"cpu_times\"], ad_value=flag\n            ):\n                self.assertIs(p.info['cpu_times'], flag)\n                self.assertGreaterEqual(p.info['pid'], 0)\n            assert m.called\n\n    def test_cache_clear(self):\n        list(psutil.process_iter())  # populate cache\n        assert psutil._pmap\n        psutil.process_iter.cache_clear()\n        assert not psutil._pmap\n\n\nclass TestProcessAPIs(PsutilTestCase):\n    @unittest.skipIf(\n        PYPY and WINDOWS, \"spawn_testproc() unreliable on PYPY + WINDOWS\"\n    )\n    def test_wait_procs(self):\n        def callback(p):\n            pids.append(p.pid)\n\n        pids = []\n        sproc1 = self.spawn_testproc()\n        sproc2 = self.spawn_testproc()\n        sproc3 = self.spawn_testproc()\n        procs = [psutil.Process(x.pid) for x in (sproc1, sproc2, sproc3)]\n        self.assertRaises(ValueError, psutil.wait_procs, procs, timeout=-1)\n        self.assertRaises(TypeError, psutil.wait_procs, procs, callback=1)\n        t = time.time()\n        gone, alive = psutil.wait_procs(procs, timeout=0.01, callback=callback)\n\n        self.assertLess(time.time() - t, 0.5)\n        self.assertEqual(gone, [])\n        self.assertEqual(len(alive), 3)\n        self.assertEqual(pids, [])\n        for p in alive:\n            self.assertFalse(hasattr(p, 'returncode'))\n\n        @retry_on_failure(30)\n        def test_1(procs, callback):\n            gone, alive = psutil.wait_procs(\n                procs, timeout=0.03, callback=callback\n            )\n            self.assertEqual(len(gone), 1)\n            self.assertEqual(len(alive), 2)\n            return gone, alive\n\n        sproc3.terminate()\n        gone, alive = test_1(procs, callback)\n        self.assertIn(sproc3.pid, [x.pid for x in gone])\n        if POSIX:\n            self.assertEqual(gone.pop().returncode, -signal.SIGTERM)\n        else:\n            self.assertEqual(gone.pop().returncode, 1)\n        self.assertEqual(pids, [sproc3.pid])\n        for p in alive:\n            self.assertFalse(hasattr(p, 'returncode'))\n\n        @retry_on_failure(30)\n        def test_2(procs, callback):\n            gone, alive = psutil.wait_procs(\n                procs, timeout=0.03, callback=callback\n            )\n            self.assertEqual(len(gone), 3)\n            self.assertEqual(len(alive), 0)\n            return gone, alive\n\n        sproc1.terminate()\n        sproc2.terminate()\n        gone, alive = test_2(procs, callback)\n        self.assertEqual(set(pids), set([sproc1.pid, sproc2.pid, sproc3.pid]))\n        for p in gone:\n            self.assertTrue(hasattr(p, 'returncode'))\n\n    @unittest.skipIf(\n        PYPY and WINDOWS, \"spawn_testproc() unreliable on PYPY + WINDOWS\"\n    )\n    def test_wait_procs_no_timeout(self):\n        sproc1 = self.spawn_testproc()\n        sproc2 = self.spawn_testproc()\n        sproc3 = self.spawn_testproc()\n        procs = [psutil.Process(x.pid) for x in (sproc1, sproc2, sproc3)]\n        for p in procs:\n            p.terminate()\n        psutil.wait_procs(procs)\n\n    def test_pid_exists(self):\n        sproc = self.spawn_testproc()\n        self.assertTrue(psutil.pid_exists(sproc.pid))\n        p = psutil.Process(sproc.pid)\n        p.kill()\n        p.wait()\n        self.assertFalse(psutil.pid_exists(sproc.pid))\n        self.assertFalse(psutil.pid_exists(-1))\n        self.assertEqual(psutil.pid_exists(0), 0 in psutil.pids())\n\n    def test_pid_exists_2(self):\n        pids = psutil.pids()\n        for pid in pids:\n            try:\n                assert psutil.pid_exists(pid)\n            except AssertionError:\n                # in case the process disappeared in meantime fail only\n                # if it is no longer in psutil.pids()\n                time.sleep(0.1)\n                self.assertNotIn(pid, psutil.pids())\n        pids = range(max(pids) + 15000, max(pids) + 16000)\n        for pid in pids:\n            self.assertFalse(psutil.pid_exists(pid), msg=pid)\n\n\nclass TestMiscAPIs(PsutilTestCase):\n    def test_boot_time(self):\n        bt = psutil.boot_time()\n        self.assertIsInstance(bt, float)\n        self.assertGreater(bt, 0)\n        self.assertLess(bt, time.time())\n\n    @unittest.skipIf(CI_TESTING and not psutil.users(), \"unreliable on CI\")\n    def test_users(self):\n        users = psutil.users()\n        self.assertNotEqual(users, [])\n        for user in users:\n            with self.subTest(user=user):\n                assert user.name\n                self.assertIsInstance(user.name, str)\n                self.assertIsInstance(user.terminal, (str, type(None)))\n                if user.host is not None:\n                    self.assertIsInstance(user.host, (str, type(None)))\n                user.terminal  # noqa\n                user.host  # noqa\n                self.assertGreater(user.started, 0.0)\n                datetime.datetime.fromtimestamp(user.started)\n                if WINDOWS or OPENBSD:\n                    self.assertIsNone(user.pid)\n                else:\n                    psutil.Process(user.pid)\n\n    def test_test(self):\n        # test for psutil.test() function\n        stdout = sys.stdout\n        sys.stdout = DEVNULL\n        try:\n            psutil.test()\n        finally:\n            sys.stdout = stdout\n\n    def test_os_constants(self):\n        names = [\n            \"POSIX\",\n            \"WINDOWS\",\n            \"LINUX\",\n            \"MACOS\",\n            \"FREEBSD\",\n            \"OPENBSD\",\n            \"NETBSD\",\n            \"BSD\",\n            \"SUNOS\",\n        ]\n        for name in names:\n            self.assertIsInstance(getattr(psutil, name), bool, msg=name)\n\n        if os.name == 'posix':\n            assert psutil.POSIX\n            assert not psutil.WINDOWS\n            names.remove(\"POSIX\")\n            if \"linux\" in sys.platform.lower():\n                assert psutil.LINUX\n                names.remove(\"LINUX\")\n            elif \"bsd\" in sys.platform.lower():\n                assert psutil.BSD\n                self.assertEqual(\n                    [psutil.FREEBSD, psutil.OPENBSD, psutil.NETBSD].count(\n                        True\n                    ),\n                    1,\n                )\n                names.remove(\"BSD\")\n                names.remove(\"FREEBSD\")\n                names.remove(\"OPENBSD\")\n                names.remove(\"NETBSD\")\n            elif (\n                \"sunos\" in sys.platform.lower()\n                or \"solaris\" in sys.platform.lower()\n            ):\n                assert psutil.SUNOS\n                names.remove(\"SUNOS\")\n            elif \"darwin\" in sys.platform.lower():\n                assert psutil.MACOS\n                names.remove(\"MACOS\")\n        else:\n            assert psutil.WINDOWS\n            assert not psutil.POSIX\n            names.remove(\"WINDOWS\")\n\n        # assert all other constants are set to False\n        for name in names:\n            self.assertFalse(getattr(psutil, name), msg=name)\n\n\nclass TestMemoryAPIs(PsutilTestCase):\n    def test_virtual_memory(self):\n        mem = psutil.virtual_memory()\n        assert mem.total > 0, mem\n        assert mem.available > 0, mem\n        assert 0 <= mem.percent <= 100, mem\n        assert mem.used > 0, mem\n        assert mem.free >= 0, mem\n        for name in mem._fields:\n            value = getattr(mem, name)\n            if name != 'percent':\n                self.assertIsInstance(value, (int, long))\n            if name != 'total':\n                if not value >= 0:\n                    raise self.fail(\"%r < 0 (%s)\" % (name, value))\n                if value > mem.total:\n                    raise self.fail(\n                        \"%r > total (total=%s, %s=%s)\"\n                        % (name, mem.total, name, value)\n                    )\n\n    def test_swap_memory(self):\n        mem = psutil.swap_memory()\n        self.assertEqual(\n            mem._fields, ('total', 'used', 'free', 'percent', 'sin', 'sout')\n        )\n\n        assert mem.total >= 0, mem\n        assert mem.used >= 0, mem\n        if mem.total > 0:\n            # likely a system with no swap partition\n            assert mem.free > 0, mem\n        else:\n            assert mem.free == 0, mem\n        assert 0 <= mem.percent <= 100, mem\n        assert mem.sin >= 0, mem\n        assert mem.sout >= 0, mem\n\n\nclass TestCpuAPIs(PsutilTestCase):\n    def test_cpu_count_logical(self):\n        logical = psutil.cpu_count()\n        self.assertIsNotNone(logical)\n        self.assertEqual(logical, len(psutil.cpu_times(percpu=True)))\n        self.assertGreaterEqual(logical, 1)\n\n        if os.path.exists(\"/proc/cpuinfo\"):\n            with open(\"/proc/cpuinfo\") as fd:\n                cpuinfo_data = fd.read()\n            if \"physical id\" not in cpuinfo_data:\n                raise unittest.SkipTest(\"cpuinfo doesn't include physical id\")\n\n    def test_cpu_count_cores(self):\n        logical = psutil.cpu_count()\n        cores = psutil.cpu_count(logical=False)\n        if cores is None:\n            raise unittest.SkipTest(\"cpu_count_cores() is None\")\n        if WINDOWS and sys.getwindowsversion()[:2] <= (6, 1):  # <= Vista\n            self.assertIsNone(cores)\n        else:\n            self.assertGreaterEqual(cores, 1)\n            self.assertGreaterEqual(logical, cores)\n\n    def test_cpu_count_none(self):\n        # https://github.com/giampaolo/psutil/issues/1085\n        for val in (-1, 0, None):\n            with mock.patch(\n                'psutil._psplatform.cpu_count_logical', return_value=val\n            ) as m:\n                self.assertIsNone(psutil.cpu_count())\n                assert m.called\n            with mock.patch(\n                'psutil._psplatform.cpu_count_cores', return_value=val\n            ) as m:\n                self.assertIsNone(psutil.cpu_count(logical=False))\n                assert m.called\n\n    def test_cpu_times(self):\n        # Check type, value >= 0, str().\n        total = 0\n        times = psutil.cpu_times()\n        sum(times)\n        for cp_time in times:\n            self.assertIsInstance(cp_time, float)\n            self.assertGreaterEqual(cp_time, 0.0)\n            total += cp_time\n        self.assertAlmostEqual(total, sum(times), places=6)\n        str(times)\n        # CPU times are always supposed to increase over time\n        # or at least remain the same and that's because time\n        # cannot go backwards.\n        # Surprisingly sometimes this might not be the case (at\n        # least on Windows and Linux), see:\n        # https://github.com/giampaolo/psutil/issues/392\n        # https://github.com/giampaolo/psutil/issues/645\n        # if not WINDOWS:\n        #     last = psutil.cpu_times()\n        #     for x in range(100):\n        #         new = psutil.cpu_times()\n        #         for field in new._fields:\n        #             new_t = getattr(new, field)\n        #             last_t = getattr(last, field)\n        #             self.assertGreaterEqual(new_t, last_t,\n        #                                     msg=\"%s %s\" % (new_t, last_t))\n        #         last = new\n\n    def test_cpu_times_time_increases(self):\n        # Make sure time increases between calls.\n        t1 = sum(psutil.cpu_times())\n        stop_at = time.time() + GLOBAL_TIMEOUT\n        while time.time() < stop_at:\n            t2 = sum(psutil.cpu_times())\n            if t2 > t1:\n                return\n        raise self.fail(\"time remained the same\")\n\n    def test_per_cpu_times(self):\n        # Check type, value >= 0, str().\n        for times in psutil.cpu_times(percpu=True):\n            total = 0\n            sum(times)\n            for cp_time in times:\n                self.assertIsInstance(cp_time, float)\n                self.assertGreaterEqual(cp_time, 0.0)\n                total += cp_time\n            self.assertAlmostEqual(total, sum(times), places=6)\n            str(times)\n        self.assertEqual(\n            len(psutil.cpu_times(percpu=True)[0]),\n            len(psutil.cpu_times(percpu=False)),\n        )\n\n        # Note: in theory CPU times are always supposed to increase over\n        # time or remain the same but never go backwards. In practice\n        # sometimes this is not the case.\n        # This issue seemd to be afflict Windows:\n        # https://github.com/giampaolo/psutil/issues/392\n        # ...but it turns out also Linux (rarely) behaves the same.\n        # last = psutil.cpu_times(percpu=True)\n        # for x in range(100):\n        #     new = psutil.cpu_times(percpu=True)\n        #     for index in range(len(new)):\n        #         newcpu = new[index]\n        #         lastcpu = last[index]\n        #         for field in newcpu._fields:\n        #             new_t = getattr(newcpu, field)\n        #             last_t = getattr(lastcpu, field)\n        #             self.assertGreaterEqual(\n        #                 new_t, last_t, msg=\"%s %s\" % (lastcpu, newcpu))\n        #     last = new\n\n    def test_per_cpu_times_2(self):\n        # Simulate some work load then make sure time have increased\n        # between calls.\n        tot1 = psutil.cpu_times(percpu=True)\n        giveup_at = time.time() + GLOBAL_TIMEOUT\n        while True:\n            if time.time() >= giveup_at:\n                return self.fail(\"timeout\")\n            tot2 = psutil.cpu_times(percpu=True)\n            for t1, t2 in zip(tot1, tot2):\n                t1, t2 = psutil._cpu_busy_time(t1), psutil._cpu_busy_time(t2)\n                difference = t2 - t1\n                if difference >= 0.05:\n                    return\n\n    @unittest.skipIf(CI_TESTING and OPENBSD, \"unreliable on OPENBSD + CI\")\n    def test_cpu_times_comparison(self):\n        # Make sure the sum of all per cpu times is almost equal to\n        # base \"one cpu\" times. On OpenBSD the sum of per-CPUs is\n        # higher for some reason.\n        base = psutil.cpu_times()\n        per_cpu = psutil.cpu_times(percpu=True)\n        summed_values = base._make([sum(num) for num in zip(*per_cpu)])\n        for field in base._fields:\n            with self.subTest(field=field, base=base, per_cpu=per_cpu):\n                self.assertAlmostEqual(\n                    getattr(base, field),\n                    getattr(summed_values, field),\n                    delta=1,\n                )\n\n    def _test_cpu_percent(self, percent, last_ret, new_ret):\n        try:\n            self.assertIsInstance(percent, float)\n            self.assertGreaterEqual(percent, 0.0)\n            self.assertIsNot(percent, -0.0)\n            self.assertLessEqual(percent, 100.0 * psutil.cpu_count())\n        except AssertionError as err:\n            raise AssertionError(\n                \"\\n%s\\nlast=%s\\nnew=%s\"\n                % (err, pprint.pformat(last_ret), pprint.pformat(new_ret))\n            )\n\n    def test_cpu_percent(self):\n        last = psutil.cpu_percent(interval=0.001)\n        for _ in range(100):\n            new = psutil.cpu_percent(interval=None)\n            self._test_cpu_percent(new, last, new)\n            last = new\n        with self.assertRaises(ValueError):\n            psutil.cpu_percent(interval=-1)\n\n    def test_per_cpu_percent(self):\n        last = psutil.cpu_percent(interval=0.001, percpu=True)\n        self.assertEqual(len(last), psutil.cpu_count())\n        for _ in range(100):\n            new = psutil.cpu_percent(interval=None, percpu=True)\n            for percent in new:\n                self._test_cpu_percent(percent, last, new)\n            last = new\n        with self.assertRaises(ValueError):\n            psutil.cpu_percent(interval=-1, percpu=True)\n\n    def test_cpu_times_percent(self):\n        last = psutil.cpu_times_percent(interval=0.001)\n        for _ in range(100):\n            new = psutil.cpu_times_percent(interval=None)\n            for percent in new:\n                self._test_cpu_percent(percent, last, new)\n            self._test_cpu_percent(sum(new), last, new)\n            last = new\n        with self.assertRaises(ValueError):\n            psutil.cpu_times_percent(interval=-1)\n\n    def test_per_cpu_times_percent(self):\n        last = psutil.cpu_times_percent(interval=0.001, percpu=True)\n        self.assertEqual(len(last), psutil.cpu_count())\n        for _ in range(100):\n            new = psutil.cpu_times_percent(interval=None, percpu=True)\n            for cpu in new:\n                for percent in cpu:\n                    self._test_cpu_percent(percent, last, new)\n                self._test_cpu_percent(sum(cpu), last, new)\n            last = new\n\n    def test_per_cpu_times_percent_negative(self):\n        # see: https://github.com/giampaolo/psutil/issues/645\n        psutil.cpu_times_percent(percpu=True)\n        zero_times = [\n            x._make([0 for x in range(len(x._fields))])\n            for x in psutil.cpu_times(percpu=True)\n        ]\n        with mock.patch('psutil.cpu_times', return_value=zero_times):\n            for cpu in psutil.cpu_times_percent(percpu=True):\n                for percent in cpu:\n                    self._test_cpu_percent(percent, None, None)\n\n    def test_cpu_stats(self):\n        # Tested more extensively in per-platform test modules.\n        infos = psutil.cpu_stats()\n        self.assertEqual(\n            infos._fields,\n            ('ctx_switches', 'interrupts', 'soft_interrupts', 'syscalls'),\n        )\n        for name in infos._fields:\n            value = getattr(infos, name)\n            self.assertGreaterEqual(value, 0)\n            # on AIX, ctx_switches is always 0\n            if not AIX and name in ('ctx_switches', 'interrupts'):\n                self.assertGreater(value, 0)\n\n    # TODO: remove this once 1892 is fixed\n    @unittest.skipIf(\n        MACOS and platform.machine() == 'arm64', \"skipped due to #1892\"\n    )\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_cpu_freq(self):\n        def check_ls(ls):\n            for nt in ls:\n                self.assertEqual(nt._fields, ('current', 'min', 'max'))\n                if nt.max != 0.0:\n                    self.assertLessEqual(nt.current, nt.max)\n                for name in nt._fields:\n                    value = getattr(nt, name)\n                    self.assertIsInstance(value, (int, long, float))\n                    self.assertGreaterEqual(value, 0)\n\n        ls = psutil.cpu_freq(percpu=True)\n        if FREEBSD and not ls:\n            raise unittest.SkipTest(\"returns empty list on FreeBSD\")\n\n        assert ls, ls\n        check_ls([psutil.cpu_freq(percpu=False)])\n\n        if LINUX:\n            self.assertEqual(len(ls), psutil.cpu_count())\n\n    @unittest.skipIf(not HAS_GETLOADAVG, \"not supported\")\n    def test_getloadavg(self):\n        loadavg = psutil.getloadavg()\n        self.assertEqual(len(loadavg), 3)\n        for load in loadavg:\n            self.assertIsInstance(load, float)\n            self.assertGreaterEqual(load, 0.0)\n\n\nclass TestDiskAPIs(PsutilTestCase):\n    @unittest.skipIf(PYPY and not IS_64BIT, \"unreliable on PYPY32 + 32BIT\")\n    def test_disk_usage(self):\n        usage = psutil.disk_usage(os.getcwd())\n        self.assertEqual(usage._fields, ('total', 'used', 'free', 'percent'))\n\n        assert usage.total > 0, usage\n        assert usage.used > 0, usage\n        assert usage.free > 0, usage\n        assert usage.total > usage.used, usage\n        assert usage.total > usage.free, usage\n        assert 0 <= usage.percent <= 100, usage.percent\n        if hasattr(shutil, 'disk_usage'):\n            # py >= 3.3, see: http://bugs.python.org/issue12442\n            shutil_usage = shutil.disk_usage(os.getcwd())\n            tolerance = 5 * 1024 * 1024  # 5MB\n            self.assertEqual(usage.total, shutil_usage.total)\n            self.assertAlmostEqual(\n                usage.free, shutil_usage.free, delta=tolerance\n            )\n            if not MACOS_12PLUS:\n                # see https://github.com/giampaolo/psutil/issues/2147\n                self.assertAlmostEqual(\n                    usage.used, shutil_usage.used, delta=tolerance\n                )\n\n        # if path does not exist OSError ENOENT is expected across\n        # all platforms\n        fname = self.get_testfn()\n        with self.assertRaises(FileNotFoundError):\n            psutil.disk_usage(fname)\n\n    @unittest.skipIf(not ASCII_FS, \"not an ASCII fs\")\n    def test_disk_usage_unicode(self):\n        # See: https://github.com/giampaolo/psutil/issues/416\n        with self.assertRaises(UnicodeEncodeError):\n            psutil.disk_usage(UNICODE_SUFFIX)\n\n    def test_disk_usage_bytes(self):\n        psutil.disk_usage(b'.')\n\n    def test_disk_partitions(self):\n        def check_ntuple(nt):\n            self.assertIsInstance(nt.device, str)\n            self.assertIsInstance(nt.mountpoint, str)\n            self.assertIsInstance(nt.fstype, str)\n            self.assertIsInstance(nt.opts, str)\n\n        # all = False\n        ls = psutil.disk_partitions(all=False)\n        self.assertTrue(ls, msg=ls)\n        for disk in ls:\n            check_ntuple(disk)\n            if WINDOWS and 'cdrom' in disk.opts:\n                continue\n            if not POSIX:\n                assert os.path.exists(disk.device), disk\n            else:\n                # we cannot make any assumption about this, see:\n                # http://goo.gl/p9c43\n                disk.device  # noqa\n            # on modern systems mount points can also be files\n            assert os.path.exists(disk.mountpoint), disk\n            assert disk.fstype, disk\n\n        # all = True\n        ls = psutil.disk_partitions(all=True)\n        self.assertTrue(ls, msg=ls)\n        for disk in psutil.disk_partitions(all=True):\n            check_ntuple(disk)\n            if not WINDOWS and disk.mountpoint:\n                try:\n                    os.stat(disk.mountpoint)\n                except OSError as err:\n                    if GITHUB_ACTIONS and MACOS and err.errno == errno.EIO:\n                        continue\n                    # http://mail.python.org/pipermail/python-dev/\n                    #     2012-June/120787.html\n                    if err.errno not in (errno.EPERM, errno.EACCES):\n                        raise\n                else:\n                    assert os.path.exists(disk.mountpoint), disk\n\n        # ---\n\n        def find_mount_point(path):\n            path = os.path.abspath(path)\n            while not os.path.ismount(path):\n                path = os.path.dirname(path)\n            return path.lower()\n\n        mount = find_mount_point(__file__)\n        mounts = [\n            x.mountpoint.lower()\n            for x in psutil.disk_partitions(all=True)\n            if x.mountpoint\n        ]\n        self.assertIn(mount, mounts)\n\n    @unittest.skipIf(\n        LINUX and not os.path.exists('/proc/diskstats'),\n        '/proc/diskstats not available on this linux version',\n    )\n    @unittest.skipIf(\n        CI_TESTING and not psutil.disk_io_counters(), \"unreliable on CI\"\n    )  # no visible disks\n    def test_disk_io_counters(self):\n        def check_ntuple(nt):\n            self.assertEqual(nt[0], nt.read_count)\n            self.assertEqual(nt[1], nt.write_count)\n            self.assertEqual(nt[2], nt.read_bytes)\n            self.assertEqual(nt[3], nt.write_bytes)\n            if not (OPENBSD or NETBSD):\n                self.assertEqual(nt[4], nt.read_time)\n                self.assertEqual(nt[5], nt.write_time)\n                if LINUX:\n                    self.assertEqual(nt[6], nt.read_merged_count)\n                    self.assertEqual(nt[7], nt.write_merged_count)\n                    self.assertEqual(nt[8], nt.busy_time)\n                elif FREEBSD:\n                    self.assertEqual(nt[6], nt.busy_time)\n            for name in nt._fields:\n                assert getattr(nt, name) >= 0, nt\n\n        ret = psutil.disk_io_counters(perdisk=False)\n        assert ret is not None, \"no disks on this system?\"\n        check_ntuple(ret)\n        ret = psutil.disk_io_counters(perdisk=True)\n        # make sure there are no duplicates\n        self.assertEqual(len(ret), len(set(ret)))\n        for key in ret:\n            assert key, key\n            check_ntuple(ret[key])\n\n    def test_disk_io_counters_no_disks(self):\n        # Emulate a case where no disks are installed, see:\n        # https://github.com/giampaolo/psutil/issues/1062\n        with mock.patch(\n            'psutil._psplatform.disk_io_counters', return_value={}\n        ) as m:\n            self.assertIsNone(psutil.disk_io_counters(perdisk=False))\n            self.assertEqual(psutil.disk_io_counters(perdisk=True), {})\n            assert m.called\n\n\nclass TestNetAPIs(PsutilTestCase):\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters(self):\n        def check_ntuple(nt):\n            self.assertEqual(nt[0], nt.bytes_sent)\n            self.assertEqual(nt[1], nt.bytes_recv)\n            self.assertEqual(nt[2], nt.packets_sent)\n            self.assertEqual(nt[3], nt.packets_recv)\n            self.assertEqual(nt[4], nt.errin)\n            self.assertEqual(nt[5], nt.errout)\n            self.assertEqual(nt[6], nt.dropin)\n            self.assertEqual(nt[7], nt.dropout)\n            assert nt.bytes_sent >= 0, nt\n            assert nt.bytes_recv >= 0, nt\n            assert nt.packets_sent >= 0, nt\n            assert nt.packets_recv >= 0, nt\n            assert nt.errin >= 0, nt\n            assert nt.errout >= 0, nt\n            assert nt.dropin >= 0, nt\n            assert nt.dropout >= 0, nt\n\n        ret = psutil.net_io_counters(pernic=False)\n        check_ntuple(ret)\n        ret = psutil.net_io_counters(pernic=True)\n        self.assertNotEqual(ret, [])\n        for key in ret:\n            self.assertTrue(key)\n            self.assertIsInstance(key, str)\n            check_ntuple(ret[key])\n\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters_no_nics(self):\n        # Emulate a case where no NICs are installed, see:\n        # https://github.com/giampaolo/psutil/issues/1062\n        with mock.patch(\n            'psutil._psplatform.net_io_counters', return_value={}\n        ) as m:\n            self.assertIsNone(psutil.net_io_counters(pernic=False))\n            self.assertEqual(psutil.net_io_counters(pernic=True), {})\n            assert m.called\n\n    @unittest.skipIf(QEMU_USER, 'QEMU user not supported')\n    def test_net_if_addrs(self):\n        nics = psutil.net_if_addrs()\n        assert nics, nics\n\n        nic_stats = psutil.net_if_stats()\n\n        # Not reliable on all platforms (net_if_addrs() reports more\n        # interfaces).\n        # self.assertEqual(sorted(nics.keys()),\n        #                  sorted(psutil.net_io_counters(pernic=True).keys()))\n\n        families = set([socket.AF_INET, socket.AF_INET6, psutil.AF_LINK])\n        for nic, addrs in nics.items():\n            self.assertIsInstance(nic, str)\n            self.assertEqual(len(set(addrs)), len(addrs))\n            for addr in addrs:\n                self.assertIsInstance(addr.family, int)\n                self.assertIsInstance(addr.address, str)\n                self.assertIsInstance(addr.netmask, (str, type(None)))\n                self.assertIsInstance(addr.broadcast, (str, type(None)))\n                self.assertIn(addr.family, families)\n                if PY3 and not PYPY:\n                    self.assertIsInstance(addr.family, enum.IntEnum)\n                if nic_stats[nic].isup:\n                    # Do not test binding to addresses of interfaces\n                    # that are down\n                    if addr.family == socket.AF_INET:\n                        s = socket.socket(addr.family)\n                        with contextlib.closing(s):\n                            s.bind((addr.address, 0))\n                    elif addr.family == socket.AF_INET6:\n                        info = socket.getaddrinfo(\n                            addr.address,\n                            0,\n                            socket.AF_INET6,\n                            socket.SOCK_STREAM,\n                            0,\n                            socket.AI_PASSIVE,\n                        )[0]\n                        af, socktype, proto, _canonname, sa = info\n                        s = socket.socket(af, socktype, proto)\n                        with contextlib.closing(s):\n                            s.bind(sa)\n                for ip in (\n                    addr.address,\n                    addr.netmask,\n                    addr.broadcast,\n                    addr.ptp,\n                ):\n                    if ip is not None:\n                        # TODO: skip AF_INET6 for now because I get:\n                        # AddressValueError: Only hex digits permitted in\n                        # u'c6f3%lxcbr0' in u'fe80::c8e0:fff:fe54:c6f3%lxcbr0'\n                        if addr.family != socket.AF_INET6:\n                            check_net_address(ip, addr.family)\n                # broadcast and ptp addresses are mutually exclusive\n                if addr.broadcast:\n                    self.assertIsNone(addr.ptp)\n                elif addr.ptp:\n                    self.assertIsNone(addr.broadcast)\n\n        if BSD or MACOS or SUNOS:\n            if hasattr(socket, \"AF_LINK\"):\n                self.assertEqual(psutil.AF_LINK, socket.AF_LINK)\n        elif LINUX:\n            self.assertEqual(psutil.AF_LINK, socket.AF_PACKET)\n        elif WINDOWS:\n            self.assertEqual(psutil.AF_LINK, -1)\n\n    def test_net_if_addrs_mac_null_bytes(self):\n        # Simulate that the underlying C function returns an incomplete\n        # MAC address. psutil is supposed to fill it with null bytes.\n        # https://github.com/giampaolo/psutil/issues/786\n        if POSIX:\n            ret = [('em1', psutil.AF_LINK, '06:3d:29', None, None, None)]\n        else:\n            ret = [('em1', -1, '06-3d-29', None, None, None)]\n        with mock.patch(\n            'psutil._psplatform.net_if_addrs', return_value=ret\n        ) as m:\n            addr = psutil.net_if_addrs()['em1'][0]\n            assert m.called\n            if POSIX:\n                self.assertEqual(addr.address, '06:3d:29:00:00:00')\n            else:\n                self.assertEqual(addr.address, '06-3d-29-00-00-00')\n\n    @unittest.skipIf(QEMU_USER, 'QEMU user not supported')\n    def test_net_if_stats(self):\n        nics = psutil.net_if_stats()\n        assert nics, nics\n        all_duplexes = (\n            psutil.NIC_DUPLEX_FULL,\n            psutil.NIC_DUPLEX_HALF,\n            psutil.NIC_DUPLEX_UNKNOWN,\n        )\n        for name, stats in nics.items():\n            self.assertIsInstance(name, str)\n            isup, duplex, speed, mtu, flags = stats\n            self.assertIsInstance(isup, bool)\n            self.assertIn(duplex, all_duplexes)\n            self.assertIn(duplex, all_duplexes)\n            self.assertGreaterEqual(speed, 0)\n            self.assertGreaterEqual(mtu, 0)\n            self.assertIsInstance(flags, str)\n\n    @unittest.skipIf(\n        not (LINUX or BSD or MACOS), \"LINUX or BSD or MACOS specific\"\n    )\n    def test_net_if_stats_enodev(self):\n        # See: https://github.com/giampaolo/psutil/issues/1279\n        with mock.patch(\n            'psutil._psutil_posix.net_if_mtu',\n            side_effect=OSError(errno.ENODEV, \"\"),\n        ) as m:\n            ret = psutil.net_if_stats()\n            self.assertEqual(ret, {})\n            assert m.called\n\n\nclass TestSensorsAPIs(PsutilTestCase):\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures(self):\n        temps = psutil.sensors_temperatures()\n        for name, entries in temps.items():\n            self.assertIsInstance(name, str)\n            for entry in entries:\n                self.assertIsInstance(entry.label, str)\n                if entry.current is not None:\n                    self.assertGreaterEqual(entry.current, 0)\n                if entry.high is not None:\n                    self.assertGreaterEqual(entry.high, 0)\n                if entry.critical is not None:\n                    self.assertGreaterEqual(entry.critical, 0)\n\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures_fahreneit(self):\n        d = {'coretemp': [('label', 50.0, 60.0, 70.0)]}\n        with mock.patch(\n            \"psutil._psplatform.sensors_temperatures\", return_value=d\n        ) as m:\n            temps = psutil.sensors_temperatures(fahrenheit=True)['coretemp'][0]\n            assert m.called\n            self.assertEqual(temps.current, 122.0)\n            self.assertEqual(temps.high, 140.0)\n            self.assertEqual(temps.critical, 158.0)\n\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery(self):\n        ret = psutil.sensors_battery()\n        self.assertGreaterEqual(ret.percent, 0)\n        self.assertLessEqual(ret.percent, 100)\n        if ret.secsleft not in (\n            psutil.POWER_TIME_UNKNOWN,\n            psutil.POWER_TIME_UNLIMITED,\n        ):\n            self.assertGreaterEqual(ret.secsleft, 0)\n        else:\n            if ret.secsleft == psutil.POWER_TIME_UNLIMITED:\n                self.assertTrue(ret.power_plugged)\n        self.assertIsInstance(ret.power_plugged, bool)\n\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_sensors_fans(self):\n        fans = psutil.sensors_fans()\n        for name, entries in fans.items():\n            self.assertIsInstance(name, str)\n            for entry in entries:\n                self.assertIsInstance(entry.label, str)\n                self.assertIsInstance(entry.current, (int, long))\n                self.assertGreaterEqual(entry.current, 0)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_misc.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Miscellaneous tests.\"\"\"\n\nimport ast\nimport collections\nimport errno\nimport json\nimport os\nimport pickle\nimport socket\nimport stat\nimport sys\nimport unittest\n\nimport psutil\nimport psutil.tests\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._common import bcat\nfrom psutil._common import cat\nfrom psutil._common import debug\nfrom psutil._common import isfile_strict\nfrom psutil._common import memoize\nfrom psutil._common import memoize_when_activated\nfrom psutil._common import parse_environ_block\nfrom psutil._common import supports_ipv6\nfrom psutil._common import wrap_numbers\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import redirect_stderr\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import SCRIPTS_DIR\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reload_module\nfrom psutil.tests import sh\nfrom psutil.tests import system_namespace\n\n\n# ===================================================================\n# --- Test classes' repr(), str(), ...\n# ===================================================================\n\n\nclass TestSpecialMethods(PsutilTestCase):\n    def test_check_pid_range(self):\n        with self.assertRaises(OverflowError):\n            psutil._psplatform.cext.check_pid_range(2**128)\n        with self.assertRaises(psutil.NoSuchProcess):\n            psutil.Process(2**128)\n\n    def test_process__repr__(self, func=repr):\n        p = psutil.Process(self.spawn_testproc().pid)\n        r = func(p)\n        self.assertIn(\"psutil.Process\", r)\n        self.assertIn(\"pid=%s\" % p.pid, r)\n        self.assertIn(\n            \"name='%s'\" % str(p.name()), r.replace(\"name=u'\", \"name='\")\n        )\n        self.assertIn(\"status=\", r)\n        self.assertNotIn(\"exitcode=\", r)\n        p.terminate()\n        p.wait()\n        r = func(p)\n        self.assertIn(\"status='terminated'\", r)\n        self.assertIn(\"exitcode=\", r)\n\n        with mock.patch.object(\n            psutil.Process,\n            \"name\",\n            side_effect=psutil.ZombieProcess(os.getpid()),\n        ):\n            p = psutil.Process()\n            r = func(p)\n            self.assertIn(\"pid=%s\" % p.pid, r)\n            self.assertIn(\"status='zombie'\", r)\n            self.assertNotIn(\"name=\", r)\n        with mock.patch.object(\n            psutil.Process,\n            \"name\",\n            side_effect=psutil.NoSuchProcess(os.getpid()),\n        ):\n            p = psutil.Process()\n            r = func(p)\n            self.assertIn(\"pid=%s\" % p.pid, r)\n            self.assertIn(\"terminated\", r)\n            self.assertNotIn(\"name=\", r)\n        with mock.patch.object(\n            psutil.Process,\n            \"name\",\n            side_effect=psutil.AccessDenied(os.getpid()),\n        ):\n            p = psutil.Process()\n            r = func(p)\n            self.assertIn(\"pid=%s\" % p.pid, r)\n            self.assertNotIn(\"name=\", r)\n\n    def test_process__str__(self):\n        self.test_process__repr__(func=str)\n\n    def test_error__repr__(self):\n        self.assertEqual(repr(psutil.Error()), \"psutil.Error()\")\n\n    def test_error__str__(self):\n        self.assertEqual(str(psutil.Error()), \"\")\n\n    def test_no_such_process__repr__(self):\n        self.assertEqual(\n            repr(psutil.NoSuchProcess(321)),\n            \"psutil.NoSuchProcess(pid=321, msg='process no longer exists')\",\n        )\n        self.assertEqual(\n            repr(psutil.NoSuchProcess(321, name=\"name\", msg=\"msg\")),\n            \"psutil.NoSuchProcess(pid=321, name='name', msg='msg')\",\n        )\n\n    def test_no_such_process__str__(self):\n        self.assertEqual(\n            str(psutil.NoSuchProcess(321)),\n            \"process no longer exists (pid=321)\",\n        )\n        self.assertEqual(\n            str(psutil.NoSuchProcess(321, name=\"name\", msg=\"msg\")),\n            \"msg (pid=321, name='name')\",\n        )\n\n    def test_zombie_process__repr__(self):\n        self.assertEqual(\n            repr(psutil.ZombieProcess(321)),\n            'psutil.ZombieProcess(pid=321, msg=\"PID still '\n            'exists but it\\'s a zombie\")',\n        )\n        self.assertEqual(\n            repr(psutil.ZombieProcess(321, name=\"name\", ppid=320, msg=\"foo\")),\n            \"psutil.ZombieProcess(pid=321, ppid=320, name='name', msg='foo')\",\n        )\n\n    def test_zombie_process__str__(self):\n        self.assertEqual(\n            str(psutil.ZombieProcess(321)),\n            \"PID still exists but it's a zombie (pid=321)\",\n        )\n        self.assertEqual(\n            str(psutil.ZombieProcess(321, name=\"name\", ppid=320, msg=\"foo\")),\n            \"foo (pid=321, ppid=320, name='name')\",\n        )\n\n    def test_access_denied__repr__(self):\n        self.assertEqual(\n            repr(psutil.AccessDenied(321)), \"psutil.AccessDenied(pid=321)\"\n        )\n        self.assertEqual(\n            repr(psutil.AccessDenied(321, name=\"name\", msg=\"msg\")),\n            \"psutil.AccessDenied(pid=321, name='name', msg='msg')\",\n        )\n\n    def test_access_denied__str__(self):\n        self.assertEqual(str(psutil.AccessDenied(321)), \"(pid=321)\")\n        self.assertEqual(\n            str(psutil.AccessDenied(321, name=\"name\", msg=\"msg\")),\n            \"msg (pid=321, name='name')\",\n        )\n\n    def test_timeout_expired__repr__(self):\n        self.assertEqual(\n            repr(psutil.TimeoutExpired(5)),\n            \"psutil.TimeoutExpired(seconds=5, msg='timeout after 5 seconds')\",\n        )\n        self.assertEqual(\n            repr(psutil.TimeoutExpired(5, pid=321, name=\"name\")),\n            \"psutil.TimeoutExpired(pid=321, name='name', seconds=5, \"\n            \"msg='timeout after 5 seconds')\",\n        )\n\n    def test_timeout_expired__str__(self):\n        self.assertEqual(\n            str(psutil.TimeoutExpired(5)), \"timeout after 5 seconds\"\n        )\n        self.assertEqual(\n            str(psutil.TimeoutExpired(5, pid=321, name=\"name\")),\n            \"timeout after 5 seconds (pid=321, name='name')\",\n        )\n\n    def test_process__eq__(self):\n        p1 = psutil.Process()\n        p2 = psutil.Process()\n        self.assertEqual(p1, p2)\n        p2._ident = (0, 0)\n        self.assertNotEqual(p1, p2)\n        self.assertNotEqual(p1, 'foo')\n\n    def test_process__hash__(self):\n        s = set([psutil.Process(), psutil.Process()])\n        self.assertEqual(len(s), 1)\n\n\n# ===================================================================\n# --- Misc, generic, corner cases\n# ===================================================================\n\n\nclass TestMisc(PsutilTestCase):\n    def test__all__(self):\n        dir_psutil = dir(psutil)\n        for name in dir_psutil:\n            if name in (\n                'debug',\n                'long',\n                'tests',\n                'test',\n                'PermissionError',\n                'ProcessLookupError',\n            ):\n                continue\n            if not name.startswith('_'):\n                try:\n                    __import__(name)\n                except ImportError:\n                    if name not in psutil.__all__:\n                        fun = getattr(psutil, name)\n                        if fun is None:\n                            continue\n                        if (\n                            fun.__doc__ is not None\n                            and 'deprecated' not in fun.__doc__.lower()\n                        ):\n                            raise self.fail('%r not in psutil.__all__' % name)\n\n        # Import 'star' will break if __all__ is inconsistent, see:\n        # https://github.com/giampaolo/psutil/issues/656\n        # Can't do `from psutil import *` as it won't work on python 3\n        # so we simply iterate over __all__.\n        for name in psutil.__all__:\n            self.assertIn(name, dir_psutil)\n\n    def test_version(self):\n        self.assertEqual(\n            '.'.join([str(x) for x in psutil.version_info]), psutil.__version__\n        )\n\n    def test_process_as_dict_no_new_names(self):\n        # See https://github.com/giampaolo/psutil/issues/813\n        p = psutil.Process()\n        p.foo = '1'\n        self.assertNotIn('foo', p.as_dict())\n\n    def test_serialization(self):\n        def check(ret):\n            json.loads(json.dumps(ret))\n\n            a = pickle.dumps(ret)\n            b = pickle.loads(a)\n            self.assertEqual(ret, b)\n\n        # --- process APIs\n\n        proc = psutil.Process()\n        check(psutil.Process().as_dict())\n\n        ns = process_namespace(proc)\n        for fun, name in ns.iter(ns.getters, clear_cache=True):\n            with self.subTest(proc=proc, name=name):\n                try:\n                    ret = fun()\n                except psutil.Error:\n                    pass\n                else:\n                    check(ret)\n\n        # --- system APIs\n\n        ns = system_namespace()\n        for fun, name in ns.iter(ns.getters):\n            if name in {\"win_service_iter\", \"win_service_get\"}:\n                continue\n            if QEMU_USER and name == \"net_if_stats\":\n                # OSError: [Errno 38] ioctl(SIOCETHTOOL) not implemented\n                continue\n            with self.subTest(name=name):\n                try:\n                    ret = fun()\n                except psutil.AccessDenied:\n                    pass\n                else:\n                    check(ret)\n\n        # --- exception classes\n\n        b = pickle.loads(\n            pickle.dumps(\n                psutil.NoSuchProcess(pid=4567, name='name', msg='msg')\n            )\n        )\n        self.assertIsInstance(b, psutil.NoSuchProcess)\n        self.assertEqual(b.pid, 4567)\n        self.assertEqual(b.name, 'name')\n        self.assertEqual(b.msg, 'msg')\n\n        b = pickle.loads(\n            pickle.dumps(\n                psutil.ZombieProcess(pid=4567, name='name', ppid=42, msg='msg')\n            )\n        )\n        self.assertIsInstance(b, psutil.ZombieProcess)\n        self.assertEqual(b.pid, 4567)\n        self.assertEqual(b.ppid, 42)\n        self.assertEqual(b.name, 'name')\n        self.assertEqual(b.msg, 'msg')\n\n        b = pickle.loads(\n            pickle.dumps(psutil.AccessDenied(pid=123, name='name', msg='msg'))\n        )\n        self.assertIsInstance(b, psutil.AccessDenied)\n        self.assertEqual(b.pid, 123)\n        self.assertEqual(b.name, 'name')\n        self.assertEqual(b.msg, 'msg')\n\n        b = pickle.loads(\n            pickle.dumps(\n                psutil.TimeoutExpired(seconds=33, pid=4567, name='name')\n            )\n        )\n        self.assertIsInstance(b, psutil.TimeoutExpired)\n        self.assertEqual(b.seconds, 33)\n        self.assertEqual(b.pid, 4567)\n        self.assertEqual(b.name, 'name')\n\n    # # XXX: https://github.com/pypa/setuptools/pull/2896\n    # @unittest.skipIf(APPVEYOR, \"temporarily disabled due to setuptools bug\")\n    # def test_setup_script(self):\n    #     setup_py = os.path.join(ROOT_DIR, 'setup.py')\n    #     if CI_TESTING and not os.path.exists(setup_py):\n    #         raise unittest.SkipTest(\"can't find setup.py\")\n    #     module = import_module_by_path(setup_py)\n    #     self.assertRaises(SystemExit, module.setup)\n    #     self.assertEqual(module.get_version(), psutil.__version__)\n\n    def test_ad_on_process_creation(self):\n        # We are supposed to be able to instantiate Process also in case\n        # of zombie processes or access denied.\n        with mock.patch.object(\n            psutil.Process, 'create_time', side_effect=psutil.AccessDenied\n        ) as meth:\n            psutil.Process()\n            assert meth.called\n        with mock.patch.object(\n            psutil.Process, 'create_time', side_effect=psutil.ZombieProcess(1)\n        ) as meth:\n            psutil.Process()\n            assert meth.called\n        with mock.patch.object(\n            psutil.Process, 'create_time', side_effect=ValueError\n        ) as meth:\n            with self.assertRaises(ValueError):\n                psutil.Process()\n            assert meth.called\n\n    def test_sanity_version_check(self):\n        # see: https://github.com/giampaolo/psutil/issues/564\n        with mock.patch(\n            \"psutil._psplatform.cext.version\", return_value=\"0.0.0\"\n        ):\n            with self.assertRaises(ImportError) as cm:\n                reload_module(psutil)\n            self.assertIn(\"version conflict\", str(cm.exception).lower())\n\n\n# ===================================================================\n# --- psutil/_common.py utils\n# ===================================================================\n\n\nclass TestMemoizeDecorator(PsutilTestCase):\n    def setUp(self):\n        self.calls = []\n\n    tearDown = setUp\n\n    def run_against(self, obj, expected_retval=None):\n        # no args\n        for _ in range(2):\n            ret = obj()\n            self.assertEqual(self.calls, [((), {})])\n            if expected_retval is not None:\n                self.assertEqual(ret, expected_retval)\n        # with args\n        for _ in range(2):\n            ret = obj(1)\n            self.assertEqual(self.calls, [((), {}), ((1,), {})])\n            if expected_retval is not None:\n                self.assertEqual(ret, expected_retval)\n        # with args + kwargs\n        for _ in range(2):\n            ret = obj(1, bar=2)\n            self.assertEqual(\n                self.calls, [((), {}), ((1,), {}), ((1,), {'bar': 2})]\n            )\n            if expected_retval is not None:\n                self.assertEqual(ret, expected_retval)\n        # clear cache\n        self.assertEqual(len(self.calls), 3)\n        obj.cache_clear()\n        ret = obj()\n        if expected_retval is not None:\n            self.assertEqual(ret, expected_retval)\n        self.assertEqual(len(self.calls), 4)\n        # docstring\n        self.assertEqual(obj.__doc__, \"My docstring.\")\n\n    def test_function(self):\n        @memoize\n        def foo(*args, **kwargs):\n            \"\"\"My docstring.\"\"\"\n            baseclass.calls.append((args, kwargs))\n            return 22\n\n        baseclass = self\n        self.run_against(foo, expected_retval=22)\n\n    def test_class(self):\n        @memoize\n        class Foo:\n            \"\"\"My docstring.\"\"\"\n\n            def __init__(self, *args, **kwargs):\n                baseclass.calls.append((args, kwargs))\n\n            def bar(self):\n                return 22\n\n        baseclass = self\n        self.run_against(Foo, expected_retval=None)\n        self.assertEqual(Foo().bar(), 22)\n\n    def test_class_singleton(self):\n        # @memoize can be used against classes to create singletons\n        @memoize\n        class Bar:\n            def __init__(self, *args, **kwargs):\n                pass\n\n        self.assertIs(Bar(), Bar())\n        self.assertEqual(id(Bar()), id(Bar()))\n        self.assertEqual(id(Bar(1)), id(Bar(1)))\n        self.assertEqual(id(Bar(1, foo=3)), id(Bar(1, foo=3)))\n        self.assertNotEqual(id(Bar(1)), id(Bar(2)))\n\n    def test_staticmethod(self):\n        class Foo:\n            @staticmethod\n            @memoize\n            def bar(*args, **kwargs):\n                \"\"\"My docstring.\"\"\"\n                baseclass.calls.append((args, kwargs))\n                return 22\n\n        baseclass = self\n        self.run_against(Foo().bar, expected_retval=22)\n\n    def test_classmethod(self):\n        class Foo:\n            @classmethod\n            @memoize\n            def bar(cls, *args, **kwargs):\n                \"\"\"My docstring.\"\"\"\n                baseclass.calls.append((args, kwargs))\n                return 22\n\n        baseclass = self\n        self.run_against(Foo().bar, expected_retval=22)\n\n    def test_original(self):\n        # This was the original test before I made it dynamic to test it\n        # against different types. Keeping it anyway.\n        @memoize\n        def foo(*args, **kwargs):\n            \"\"\"Foo docstring.\"\"\"\n            calls.append(None)\n            return (args, kwargs)\n\n        calls = []\n        # no args\n        for _ in range(2):\n            ret = foo()\n            expected = ((), {})\n            self.assertEqual(ret, expected)\n            self.assertEqual(len(calls), 1)\n        # with args\n        for _ in range(2):\n            ret = foo(1)\n            expected = ((1,), {})\n            self.assertEqual(ret, expected)\n            self.assertEqual(len(calls), 2)\n        # with args + kwargs\n        for _ in range(2):\n            ret = foo(1, bar=2)\n            expected = ((1,), {'bar': 2})\n            self.assertEqual(ret, expected)\n            self.assertEqual(len(calls), 3)\n        # clear cache\n        foo.cache_clear()\n        ret = foo()\n        expected = ((), {})\n        self.assertEqual(ret, expected)\n        self.assertEqual(len(calls), 4)\n        # docstring\n        self.assertEqual(foo.__doc__, \"Foo docstring.\")\n\n\nclass TestCommonModule(PsutilTestCase):\n    def test_memoize_when_activated(self):\n        class Foo:\n            @memoize_when_activated\n            def foo(self):\n                calls.append(None)\n\n        f = Foo()\n        calls = []\n        f.foo()\n        f.foo()\n        self.assertEqual(len(calls), 2)\n\n        # activate\n        calls = []\n        f.foo.cache_activate(f)\n        f.foo()\n        f.foo()\n        self.assertEqual(len(calls), 1)\n\n        # deactivate\n        calls = []\n        f.foo.cache_deactivate(f)\n        f.foo()\n        f.foo()\n        self.assertEqual(len(calls), 2)\n\n    def test_parse_environ_block(self):\n        def k(s):\n            return s.upper() if WINDOWS else s\n\n        self.assertEqual(parse_environ_block(\"a=1\\0\"), {k(\"a\"): \"1\"})\n        self.assertEqual(\n            parse_environ_block(\"a=1\\0b=2\\0\\0\"), {k(\"a\"): \"1\", k(\"b\"): \"2\"}\n        )\n        self.assertEqual(\n            parse_environ_block(\"a=1\\0b=\\0\\0\"), {k(\"a\"): \"1\", k(\"b\"): \"\"}\n        )\n        # ignore everything after \\0\\0\n        self.assertEqual(\n            parse_environ_block(\"a=1\\0b=2\\0\\0c=3\\0\"),\n            {k(\"a\"): \"1\", k(\"b\"): \"2\"},\n        )\n        # ignore everything that is not an assignment\n        self.assertEqual(parse_environ_block(\"xxx\\0a=1\\0\"), {k(\"a\"): \"1\"})\n        self.assertEqual(parse_environ_block(\"a=1\\0=b=2\\0\"), {k(\"a\"): \"1\"})\n        # do not fail if the block is incomplete\n        self.assertEqual(parse_environ_block(\"a=1\\0b=2\"), {k(\"a\"): \"1\"})\n\n    def test_supports_ipv6(self):\n        self.addCleanup(supports_ipv6.cache_clear)\n        if supports_ipv6():\n            with mock.patch('psutil._common.socket') as s:\n                s.has_ipv6 = False\n                supports_ipv6.cache_clear()\n                assert not supports_ipv6()\n\n            supports_ipv6.cache_clear()\n            with mock.patch(\n                'psutil._common.socket.socket', side_effect=socket.error\n            ) as s:\n                assert not supports_ipv6()\n                assert s.called\n\n            supports_ipv6.cache_clear()\n            with mock.patch(\n                'psutil._common.socket.socket', side_effect=socket.gaierror\n            ) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n\n            supports_ipv6.cache_clear()\n            with mock.patch(\n                'psutil._common.socket.socket.bind',\n                side_effect=socket.gaierror,\n            ) as s:\n                assert not supports_ipv6()\n                supports_ipv6.cache_clear()\n                assert s.called\n        else:\n            with self.assertRaises(socket.error):\n                sock = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n                try:\n                    sock.bind((\"::1\", 0))\n                finally:\n                    sock.close()\n\n    def test_isfile_strict(self):\n        this_file = os.path.abspath(__file__)\n        assert isfile_strict(this_file)\n        assert not isfile_strict(os.path.dirname(this_file))\n        with mock.patch(\n            'psutil._common.os.stat', side_effect=OSError(errno.EPERM, \"foo\")\n        ):\n            self.assertRaises(OSError, isfile_strict, this_file)\n        with mock.patch(\n            'psutil._common.os.stat', side_effect=OSError(errno.EACCES, \"foo\")\n        ):\n            self.assertRaises(OSError, isfile_strict, this_file)\n        with mock.patch(\n            'psutil._common.os.stat', side_effect=OSError(errno.ENOENT, \"foo\")\n        ):\n            assert not isfile_strict(this_file)\n        with mock.patch('psutil._common.stat.S_ISREG', return_value=False):\n            assert not isfile_strict(this_file)\n\n    def test_debug(self):\n        if PY3:\n            from io import StringIO\n        else:\n            from StringIO import StringIO\n\n        with redirect_stderr(StringIO()) as f:\n            debug(\"hello\")\n            sys.stderr.flush()\n        msg = f.getvalue()\n        assert msg.startswith(\"psutil-debug\"), msg\n        self.assertIn(\"hello\", msg)\n        self.assertIn(__file__.replace('.pyc', '.py'), msg)\n\n        # supposed to use repr(exc)\n        with redirect_stderr(StringIO()) as f:\n            debug(ValueError(\"this is an error\"))\n        msg = f.getvalue()\n        self.assertIn(\"ignoring ValueError\", msg)\n        self.assertIn(\"'this is an error'\", msg)\n\n        # supposed to use str(exc), because of extra info about file name\n        with redirect_stderr(StringIO()) as f:\n            exc = OSError(2, \"no such file\")\n            exc.filename = \"/foo\"\n            debug(exc)\n        msg = f.getvalue()\n        self.assertIn(\"no such file\", msg)\n        self.assertIn(\"/foo\", msg)\n\n    def test_cat_bcat(self):\n        testfn = self.get_testfn()\n        with open(testfn, \"w\") as f:\n            f.write(\"foo\")\n        self.assertEqual(cat(testfn), \"foo\")\n        self.assertEqual(bcat(testfn), b\"foo\")\n        self.assertRaises(FileNotFoundError, cat, testfn + '-invalid')\n        self.assertRaises(FileNotFoundError, bcat, testfn + '-invalid')\n        self.assertEqual(cat(testfn + '-invalid', fallback=\"bar\"), \"bar\")\n        self.assertEqual(bcat(testfn + '-invalid', fallback=\"bar\"), \"bar\")\n\n\n# ===================================================================\n# --- Tests for wrap_numbers() function.\n# ===================================================================\n\n\nnt = collections.namedtuple('foo', 'a b c')\n\n\nclass TestWrapNumbers(PsutilTestCase):\n    def setUp(self):\n        wrap_numbers.cache_clear()\n\n    tearDown = setUp\n\n    def test_first_call(self):\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_input_hasnt_changed(self):\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_increase_but_no_wrap(self):\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(10, 15, 20)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(20, 25, 30)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(20, 25, 30)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_wrap(self):\n        # let's say 100 is the threshold\n        input = {'disk1': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # first wrap restarts from 10\n        input = {'disk1': nt(100, 100, 10)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(100, 100, 110)}\n        )\n        # then it remains the same\n        input = {'disk1': nt(100, 100, 10)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(100, 100, 110)}\n        )\n        # then it goes up\n        input = {'disk1': nt(100, 100, 90)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(100, 100, 190)}\n        )\n        # then it wraps again\n        input = {'disk1': nt(100, 100, 20)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(100, 100, 210)}\n        )\n        # and remains the same\n        input = {'disk1': nt(100, 100, 20)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(100, 100, 210)}\n        )\n        # now wrap another num\n        input = {'disk1': nt(50, 100, 20)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(150, 100, 210)}\n        )\n        # and again\n        input = {'disk1': nt(40, 100, 20)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(190, 100, 210)}\n        )\n        # keep it the same\n        input = {'disk1': nt(40, 100, 20)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'), {'disk1': nt(190, 100, 210)}\n        )\n\n    def test_changing_keys(self):\n        # Emulate a case where the second call to disk_io()\n        # (or whatever) provides a new disk, then the new disk\n        # disappears on the third call.\n        input = {'disk1': nt(5, 5, 5)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(5, 5, 5), 'disk2': nt(7, 7, 7)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        input = {'disk1': nt(8, 8, 8)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n    def test_changing_keys_w_wrap(self):\n        input = {'disk1': nt(50, 50, 50), 'disk2': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # disk 2 wraps\n        input = {'disk1': nt(50, 50, 50), 'disk2': nt(100, 100, 10)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'),\n            {'disk1': nt(50, 50, 50), 'disk2': nt(100, 100, 110)},\n        )\n        # disk 2 disappears\n        input = {'disk1': nt(50, 50, 50)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n\n        # then it appears again; the old wrap is supposed to be\n        # gone.\n        input = {'disk1': nt(50, 50, 50), 'disk2': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # remains the same\n        input = {'disk1': nt(50, 50, 50), 'disk2': nt(100, 100, 100)}\n        self.assertEqual(wrap_numbers(input, 'disk_io'), input)\n        # and then wraps again\n        input = {'disk1': nt(50, 50, 50), 'disk2': nt(100, 100, 10)}\n        self.assertEqual(\n            wrap_numbers(input, 'disk_io'),\n            {'disk1': nt(50, 50, 50), 'disk2': nt(100, 100, 110)},\n        )\n\n    def test_real_data(self):\n        d = {\n            'nvme0n1': (300, 508, 640, 1571, 5970, 1987, 2049, 451751, 47048),\n            'nvme0n1p1': (1171, 2, 5600256, 1024, 516, 0, 0, 0, 8),\n            'nvme0n1p2': (54, 54, 2396160, 5165056, 4, 24, 30, 1207, 28),\n            'nvme0n1p3': (2389, 4539, 5154, 150, 4828, 1844, 2019, 398, 348),\n        }\n        self.assertEqual(wrap_numbers(d, 'disk_io'), d)\n        self.assertEqual(wrap_numbers(d, 'disk_io'), d)\n        # decrease this   \u2193\n        d = {\n            'nvme0n1': (100, 508, 640, 1571, 5970, 1987, 2049, 451751, 47048),\n            'nvme0n1p1': (1171, 2, 5600256, 1024, 516, 0, 0, 0, 8),\n            'nvme0n1p2': (54, 54, 2396160, 5165056, 4, 24, 30, 1207, 28),\n            'nvme0n1p3': (2389, 4539, 5154, 150, 4828, 1844, 2019, 398, 348),\n        }\n        out = wrap_numbers(d, 'disk_io')\n        self.assertEqual(out['nvme0n1'][0], 400)\n\n    # --- cache tests\n\n    def test_cache_first_call(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(cache[1], {'disk_io': {}})\n        self.assertEqual(cache[2], {'disk_io': {}})\n\n    def test_cache_call_twice(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        input = {'disk1': nt(10, 10, 10)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 0}},\n        )\n        self.assertEqual(cache[2], {'disk_io': {}})\n\n    def test_cache_wrap(self):\n        # let's say 100 is the threshold\n        input = {'disk1': nt(100, 100, 100)}\n        wrap_numbers(input, 'disk_io')\n\n        # first wrap restarts from 10\n        input = {'disk1': nt(100, 100, 10)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 100}},\n        )\n        self.assertEqual(cache[2], {'disk_io': {'disk1': set([('disk1', 2)])}})\n\n        def check_cache_info():\n            cache = wrap_numbers.cache_info()\n            self.assertEqual(\n                cache[1],\n                {\n                    'disk_io': {\n                        ('disk1', 0): 0,\n                        ('disk1', 1): 0,\n                        ('disk1', 2): 100,\n                    }\n                },\n            )\n            self.assertEqual(\n                cache[2], {'disk_io': {'disk1': set([('disk1', 2)])}}\n            )\n\n        # then it remains the same\n        input = {'disk1': nt(100, 100, 10)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        check_cache_info()\n\n        # then it goes up\n        input = {'disk1': nt(100, 100, 90)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        check_cache_info()\n\n        # then it wraps again\n        input = {'disk1': nt(100, 100, 20)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 190}},\n        )\n        self.assertEqual(cache[2], {'disk_io': {'disk1': set([('disk1', 2)])}})\n\n    def test_cache_changing_keys(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        input = {'disk1': nt(5, 5, 5), 'disk2': nt(7, 7, 7)}\n        wrap_numbers(input, 'disk_io')\n        cache = wrap_numbers.cache_info()\n        self.assertEqual(cache[0], {'disk_io': input})\n        self.assertEqual(\n            cache[1],\n            {'disk_io': {('disk1', 0): 0, ('disk1', 1): 0, ('disk1', 2): 0}},\n        )\n        self.assertEqual(cache[2], {'disk_io': {}})\n\n    def test_cache_clear(self):\n        input = {'disk1': nt(5, 5, 5)}\n        wrap_numbers(input, 'disk_io')\n        wrap_numbers(input, 'disk_io')\n        wrap_numbers.cache_clear('disk_io')\n        self.assertEqual(wrap_numbers.cache_info(), ({}, {}, {}))\n        wrap_numbers.cache_clear('disk_io')\n        wrap_numbers.cache_clear('?!?')\n\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_cache_clear_public_apis(self):\n        if not psutil.disk_io_counters() or not psutil.net_io_counters():\n            raise unittest.SkipTest(\"no disks or NICs available\")\n        psutil.disk_io_counters()\n        psutil.net_io_counters()\n        caches = wrap_numbers.cache_info()\n        for cache in caches:\n            self.assertIn('psutil.disk_io_counters', cache)\n            self.assertIn('psutil.net_io_counters', cache)\n\n        psutil.disk_io_counters.cache_clear()\n        caches = wrap_numbers.cache_info()\n        for cache in caches:\n            self.assertIn('psutil.net_io_counters', cache)\n            self.assertNotIn('psutil.disk_io_counters', cache)\n\n        psutil.net_io_counters.cache_clear()\n        caches = wrap_numbers.cache_info()\n        self.assertEqual(caches, ({}, {}, {}))\n\n\n# ===================================================================\n# --- Example script tests\n# ===================================================================\n\n\n@unittest.skipIf(\n    not os.path.exists(SCRIPTS_DIR), \"can't locate scripts directory\"\n)\nclass TestScripts(PsutilTestCase):\n    \"\"\"Tests for scripts in the \"scripts\" directory.\"\"\"\n\n    @staticmethod\n    def assert_stdout(exe, *args, **kwargs):\n        kwargs.setdefault(\"env\", PYTHON_EXE_ENV)\n        exe = '%s' % os.path.join(SCRIPTS_DIR, exe)\n        cmd = [PYTHON_EXE, exe]\n        for arg in args:\n            cmd.append(arg)\n        try:\n            out = sh(cmd, **kwargs).strip()\n        except RuntimeError as err:\n            if 'AccessDenied' in str(err):\n                return str(err)\n            else:\n                raise\n        assert out, out\n        return out\n\n    @staticmethod\n    def assert_syntax(exe):\n        exe = os.path.join(SCRIPTS_DIR, exe)\n        with open(exe, encoding=\"utf8\") if PY3 else open(exe) as f:\n            src = f.read()\n        ast.parse(src)\n\n    def test_coverage(self):\n        # make sure all example scripts have a test method defined\n        meths = dir(self)\n        for name in os.listdir(SCRIPTS_DIR):\n            if name.endswith('.py'):\n                if 'test_' + os.path.splitext(name)[0] not in meths:\n                    # self.assert_stdout(name)\n                    raise self.fail(\n                        'no test defined for %r script'\n                        % os.path.join(SCRIPTS_DIR, name)\n                    )\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_executable(self):\n        for root, dirs, files in os.walk(SCRIPTS_DIR):\n            for file in files:\n                if file.endswith('.py'):\n                    path = os.path.join(root, file)\n                    if not stat.S_IXUSR & os.stat(path)[stat.ST_MODE]:\n                        raise self.fail('%r is not executable' % path)\n\n    def test_disk_usage(self):\n        self.assert_stdout('disk_usage.py')\n\n    def test_free(self):\n        self.assert_stdout('free.py')\n\n    def test_meminfo(self):\n        self.assert_stdout('meminfo.py')\n\n    def test_procinfo(self):\n        self.assert_stdout('procinfo.py', str(os.getpid()))\n\n    @unittest.skipIf(CI_TESTING and not psutil.users(), \"no users\")\n    def test_who(self):\n        self.assert_stdout('who.py')\n\n    def test_ps(self):\n        self.assert_stdout('ps.py')\n\n    def test_pstree(self):\n        self.assert_stdout('pstree.py')\n\n    def test_netstat(self):\n        self.assert_stdout('netstat.py')\n\n    @unittest.skipIf(QEMU_USER, 'QEMU user not supported')\n    def test_ifconfig(self):\n        self.assert_stdout('ifconfig.py')\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    def test_pmap(self):\n        self.assert_stdout('pmap.py', str(os.getpid()))\n\n    def test_procsmem(self):\n        if 'uss' not in psutil.Process().memory_full_info()._fields:\n            raise unittest.SkipTest(\"not supported\")\n        self.assert_stdout('procsmem.py')\n\n    def test_killall(self):\n        self.assert_syntax('killall.py')\n\n    def test_nettop(self):\n        self.assert_syntax('nettop.py')\n\n    def test_top(self):\n        self.assert_syntax('top.py')\n\n    def test_iotop(self):\n        self.assert_syntax('iotop.py')\n\n    def test_pidof(self):\n        output = self.assert_stdout('pidof.py', psutil.Process().name())\n        self.assertIn(str(os.getpid()), output)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_winservices(self):\n        self.assert_stdout('winservices.py')\n\n    def test_cpu_distribution(self):\n        self.assert_syntax('cpu_distribution.py')\n\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_temperatures(self):\n        if not psutil.sensors_temperatures():\n            raise unittest.SkipTest(\"no temperatures\")\n        self.assert_stdout('temperatures.py')\n\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_fans(self):\n        if not psutil.sensors_fans():\n            raise unittest.SkipTest(\"no fans\")\n        self.assert_stdout('fans.py')\n\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_battery(self):\n        self.assert_stdout('battery.py')\n\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors(self):\n        self.assert_stdout('sensors.py')\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_testutils.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for testing utils (psutil.tests namespace).\"\"\"\n\nimport collections\nimport contextlib\nimport errno\nimport os\nimport socket\nimport stat\nimport subprocess\nimport unittest\n\nimport psutil\nimport psutil.tests\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import POSIX\nfrom psutil._common import open_binary\nfrom psutil._common import open_text\nfrom psutil._common import supports_ipv6\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import COVERAGE\nfrom psutil.tests import HAS_NET_CONNECTIONS_UNIX\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import TestMemoryLeak\nfrom psutil.tests import bind_socket\nfrom psutil.tests import bind_unix_socket\nfrom psutil.tests import call_until\nfrom psutil.tests import chdir\nfrom psutil.tests import create_sockets\nfrom psutil.tests import filter_proc_net_connections\nfrom psutil.tests import get_free_port\nfrom psutil.tests import is_namedtuple\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reap_children\nfrom psutil.tests import retry\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_mkdir\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import serialrun\nfrom psutil.tests import system_namespace\nfrom psutil.tests import tcp_socketpair\nfrom psutil.tests import terminate\nfrom psutil.tests import unix_socketpair\nfrom psutil.tests import wait_for_file\nfrom psutil.tests import wait_for_pid\n\n\n# ===================================================================\n# --- Unit tests for test utilities.\n# ===================================================================\n\n\nclass TestRetryDecorator(PsutilTestCase):\n    @mock.patch('time.sleep')\n    def test_retry_success(self, sleep):\n        # Fail 3 times out of 5; make sure the decorated fun returns.\n\n        @retry(retries=5, interval=1, logfun=None)\n        def foo():\n            while queue:\n                queue.pop()\n                1 / 0  # noqa\n            return 1\n\n        queue = list(range(3))\n        self.assertEqual(foo(), 1)\n        self.assertEqual(sleep.call_count, 3)\n\n    @mock.patch('time.sleep')\n    def test_retry_failure(self, sleep):\n        # Fail 6 times out of 5; th function is supposed to raise exc.\n        @retry(retries=5, interval=1, logfun=None)\n        def foo():\n            while queue:\n                queue.pop()\n                1 / 0  # noqa\n            return 1\n\n        queue = list(range(6))\n        self.assertRaises(ZeroDivisionError, foo)\n        self.assertEqual(sleep.call_count, 5)\n\n    @mock.patch('time.sleep')\n    def test_exception_arg(self, sleep):\n        @retry(exception=ValueError, interval=1)\n        def foo():\n            raise TypeError\n\n        self.assertRaises(TypeError, foo)\n        self.assertEqual(sleep.call_count, 0)\n\n    @mock.patch('time.sleep')\n    def test_no_interval_arg(self, sleep):\n        # if interval is not specified sleep is not supposed to be called\n\n        @retry(retries=5, interval=None, logfun=None)\n        def foo():\n            1 / 0  # noqa\n\n        self.assertRaises(ZeroDivisionError, foo)\n        self.assertEqual(sleep.call_count, 0)\n\n    @mock.patch('time.sleep')\n    def test_retries_arg(self, sleep):\n        @retry(retries=5, interval=1, logfun=None)\n        def foo():\n            1 / 0  # noqa\n\n        self.assertRaises(ZeroDivisionError, foo)\n        self.assertEqual(sleep.call_count, 5)\n\n    @mock.patch('time.sleep')\n    def test_retries_and_timeout_args(self, sleep):\n        self.assertRaises(ValueError, retry, retries=5, timeout=1)\n\n\nclass TestSyncTestUtils(PsutilTestCase):\n    def test_wait_for_pid(self):\n        wait_for_pid(os.getpid())\n        nopid = max(psutil.pids()) + 99999\n        with mock.patch('psutil.tests.retry.__iter__', return_value=iter([0])):\n            self.assertRaises(psutil.NoSuchProcess, wait_for_pid, nopid)\n\n    def test_wait_for_file(self):\n        testfn = self.get_testfn()\n        with open(testfn, 'w') as f:\n            f.write('foo')\n        wait_for_file(testfn)\n        assert not os.path.exists(testfn)\n\n    def test_wait_for_file_empty(self):\n        testfn = self.get_testfn()\n        with open(testfn, 'w'):\n            pass\n        wait_for_file(testfn, empty=True)\n        assert not os.path.exists(testfn)\n\n    def test_wait_for_file_no_file(self):\n        testfn = self.get_testfn()\n        with mock.patch('psutil.tests.retry.__iter__', return_value=iter([0])):\n            self.assertRaises(IOError, wait_for_file, testfn)\n\n    def test_wait_for_file_no_delete(self):\n        testfn = self.get_testfn()\n        with open(testfn, 'w') as f:\n            f.write('foo')\n        wait_for_file(testfn, delete=False)\n        assert os.path.exists(testfn)\n\n    def test_call_until(self):\n        ret = call_until(lambda: 1, \"ret == 1\")\n        self.assertEqual(ret, 1)\n\n\nclass TestFSTestUtils(PsutilTestCase):\n    def test_open_text(self):\n        with open_text(__file__) as f:\n            self.assertEqual(f.mode, 'r')\n\n    def test_open_binary(self):\n        with open_binary(__file__) as f:\n            self.assertEqual(f.mode, 'rb')\n\n    def test_safe_mkdir(self):\n        testfn = self.get_testfn()\n        safe_mkdir(testfn)\n        assert os.path.isdir(testfn)\n        safe_mkdir(testfn)\n        assert os.path.isdir(testfn)\n\n    def test_safe_rmpath(self):\n        # test file is removed\n        testfn = self.get_testfn()\n        open(testfn, 'w').close()\n        safe_rmpath(testfn)\n        assert not os.path.exists(testfn)\n        # test no exception if path does not exist\n        safe_rmpath(testfn)\n        # test dir is removed\n        os.mkdir(testfn)\n        safe_rmpath(testfn)\n        assert not os.path.exists(testfn)\n        # test other exceptions are raised\n        with mock.patch(\n            'psutil.tests.os.stat', side_effect=OSError(errno.EINVAL, \"\")\n        ) as m:\n            with self.assertRaises(OSError):\n                safe_rmpath(testfn)\n            assert m.called\n\n    def test_chdir(self):\n        testfn = self.get_testfn()\n        base = os.getcwd()\n        os.mkdir(testfn)\n        with chdir(testfn):\n            self.assertEqual(os.getcwd(), os.path.join(base, testfn))\n        self.assertEqual(os.getcwd(), base)\n\n\nclass TestProcessUtils(PsutilTestCase):\n    def test_reap_children(self):\n        subp = self.spawn_testproc()\n        p = psutil.Process(subp.pid)\n        assert p.is_running()\n        reap_children()\n        assert not p.is_running()\n        assert not psutil.tests._pids_started\n        assert not psutil.tests._subprocesses_started\n\n    def test_spawn_children_pair(self):\n        child, grandchild = self.spawn_children_pair()\n        self.assertNotEqual(child.pid, grandchild.pid)\n        assert child.is_running()\n        assert grandchild.is_running()\n        children = psutil.Process().children()\n        self.assertEqual(children, [child])\n        children = psutil.Process().children(recursive=True)\n        self.assertEqual(len(children), 2)\n        self.assertIn(child, children)\n        self.assertIn(grandchild, children)\n        self.assertEqual(child.ppid(), os.getpid())\n        self.assertEqual(grandchild.ppid(), child.pid)\n\n        terminate(child)\n        assert not child.is_running()\n        assert grandchild.is_running()\n\n        terminate(grandchild)\n        assert not grandchild.is_running()\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_spawn_zombie(self):\n        _parent, zombie = self.spawn_zombie()\n        self.assertEqual(zombie.status(), psutil.STATUS_ZOMBIE)\n\n    def test_terminate(self):\n        # by subprocess.Popen\n        p = self.spawn_testproc()\n        terminate(p)\n        self.assertPidGone(p.pid)\n        terminate(p)\n        # by psutil.Process\n        p = psutil.Process(self.spawn_testproc().pid)\n        terminate(p)\n        self.assertPidGone(p.pid)\n        terminate(p)\n        # by psutil.Popen\n        cmd = [\n            PYTHON_EXE,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)];\",\n        ]\n        p = psutil.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            env=PYTHON_EXE_ENV,\n        )\n        terminate(p)\n        self.assertPidGone(p.pid)\n        terminate(p)\n        # by PID\n        pid = self.spawn_testproc().pid\n        terminate(pid)\n        self.assertPidGone(p.pid)\n        terminate(pid)\n        # zombie\n        if POSIX:\n            parent, zombie = self.spawn_zombie()\n            terminate(parent)\n            terminate(zombie)\n            self.assertPidGone(parent.pid)\n            self.assertPidGone(zombie.pid)\n\n\nclass TestNetUtils(PsutilTestCase):\n    def bind_socket(self):\n        port = get_free_port()\n        with contextlib.closing(bind_socket(addr=('', port))) as s:\n            self.assertEqual(s.getsockname()[1], port)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_bind_unix_socket(self):\n        name = self.get_testfn()\n        sock = bind_unix_socket(name)\n        with contextlib.closing(sock):\n            self.assertEqual(sock.family, socket.AF_UNIX)\n            self.assertEqual(sock.type, socket.SOCK_STREAM)\n            self.assertEqual(sock.getsockname(), name)\n            assert os.path.exists(name)\n            assert stat.S_ISSOCK(os.stat(name).st_mode)\n        # UDP\n        name = self.get_testfn()\n        sock = bind_unix_socket(name, type=socket.SOCK_DGRAM)\n        with contextlib.closing(sock):\n            self.assertEqual(sock.type, socket.SOCK_DGRAM)\n\n    def tcp_tcp_socketpair(self):\n        addr = (\"127.0.0.1\", get_free_port())\n        server, client = tcp_socketpair(socket.AF_INET, addr=addr)\n        with contextlib.closing(server):\n            with contextlib.closing(client):\n                # Ensure they are connected and the positions are\n                # correct.\n                self.assertEqual(server.getsockname(), addr)\n                self.assertEqual(client.getpeername(), addr)\n                self.assertNotEqual(client.getsockname(), addr)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @unittest.skipIf(\n        NETBSD or FREEBSD, \"/var/run/log UNIX socket opened by default\"\n    )\n    def test_unix_socketpair(self):\n        p = psutil.Process()\n        num_fds = p.num_fds()\n        self.assertEqual(\n            filter_proc_net_connections(p.net_connections(kind='unix')), []\n        )\n        name = self.get_testfn()\n        server, client = unix_socketpair(name)\n        try:\n            assert os.path.exists(name)\n            assert stat.S_ISSOCK(os.stat(name).st_mode)\n            self.assertEqual(p.num_fds() - num_fds, 2)\n            self.assertEqual(\n                len(\n                    filter_proc_net_connections(p.net_connections(kind='unix'))\n                ),\n                2,\n            )\n            self.assertEqual(server.getsockname(), name)\n            self.assertEqual(client.getpeername(), name)\n        finally:\n            client.close()\n            server.close()\n\n    def test_create_sockets(self):\n        with create_sockets() as socks:\n            fams = collections.defaultdict(int)\n            types = collections.defaultdict(int)\n            for s in socks:\n                fams[s.family] += 1\n                # work around http://bugs.python.org/issue30204\n                types[s.getsockopt(socket.SOL_SOCKET, socket.SO_TYPE)] += 1\n            self.assertGreaterEqual(fams[socket.AF_INET], 2)\n            if supports_ipv6():\n                self.assertGreaterEqual(fams[socket.AF_INET6], 2)\n            if POSIX and HAS_NET_CONNECTIONS_UNIX:\n                self.assertGreaterEqual(fams[socket.AF_UNIX], 2)\n            self.assertGreaterEqual(types[socket.SOCK_STREAM], 2)\n            self.assertGreaterEqual(types[socket.SOCK_DGRAM], 2)\n\n\n@serialrun\nclass TestMemLeakClass(TestMemoryLeak):\n    @retry_on_failure()\n    def test_times(self):\n        def fun():\n            cnt['cnt'] += 1\n\n        cnt = {'cnt': 0}\n        self.execute(fun, times=10, warmup_times=15)\n        self.assertEqual(cnt['cnt'], 26)\n\n    def test_param_err(self):\n        self.assertRaises(ValueError, self.execute, lambda: 0, times=0)\n        self.assertRaises(ValueError, self.execute, lambda: 0, times=-1)\n        self.assertRaises(ValueError, self.execute, lambda: 0, warmup_times=-1)\n        self.assertRaises(ValueError, self.execute, lambda: 0, tolerance=-1)\n        self.assertRaises(ValueError, self.execute, lambda: 0, retries=-1)\n\n    @retry_on_failure()\n    @unittest.skipIf(CI_TESTING, \"skipped on CI\")\n    @unittest.skipIf(COVERAGE, \"skipped during test coverage\")\n    def test_leak_mem(self):\n        ls = []\n\n        def fun(ls=ls):\n            ls.append(\"x\" * 124 * 1024)\n\n        try:\n            # will consume around 30M in total\n            self.assertRaisesRegex(\n                AssertionError, \"extra-mem\", self.execute, fun, times=50\n            )\n        finally:\n            del ls\n\n    def test_unclosed_files(self):\n        def fun():\n            f = open(__file__)\n            self.addCleanup(f.close)\n            box.append(f)\n\n        box = []\n        kind = \"fd\" if POSIX else \"handle\"\n        self.assertRaisesRegex(\n            AssertionError, \"unclosed \" + kind, self.execute, fun\n        )\n\n    def test_tolerance(self):\n        def fun():\n            ls.append(\"x\" * 24 * 1024)\n\n        ls = []\n        times = 100\n        self.execute(\n            fun, times=times, warmup_times=0, tolerance=200 * 1024 * 1024\n        )\n        self.assertEqual(len(ls), times + 1)\n\n    def test_execute_w_exc(self):\n        def fun_1():\n            1 / 0  # noqa\n\n        self.execute_w_exc(ZeroDivisionError, fun_1)\n        with self.assertRaises(ZeroDivisionError):\n            self.execute_w_exc(OSError, fun_1)\n\n        def fun_2():\n            pass\n\n        with self.assertRaises(AssertionError):\n            self.execute_w_exc(ZeroDivisionError, fun_2)\n\n\nclass TestTestingUtils(PsutilTestCase):\n    def test_process_namespace(self):\n        p = psutil.Process()\n        ns = process_namespace(p)\n        ns.test()\n        fun = [x for x in ns.iter(ns.getters) if x[1] == 'ppid'][0][0]\n        self.assertEqual(fun(), p.ppid())\n\n    def test_system_namespace(self):\n        ns = system_namespace()\n        fun = [x for x in ns.iter(ns.getters) if x[1] == 'net_if_addrs'][0][0]\n        self.assertEqual(fun(), psutil.net_if_addrs())\n\n\nclass TestOtherUtils(PsutilTestCase):\n    def test_is_namedtuple(self):\n        assert is_namedtuple(collections.namedtuple('foo', 'a b c')(1, 2, 3))\n        assert not is_namedtuple(tuple())\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_osx.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"macOS specific tests.\"\"\"\n\nimport platform\nimport re\nimport time\nimport unittest\n\nimport psutil\nfrom psutil import MACOS\nfrom psutil import POSIX\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\n\n\nif POSIX:\n    from psutil._psutil_posix import getpagesize\n\n\ndef sysctl(cmdline):\n    \"\"\"Expects a sysctl command with an argument and parse the result\n    returning only the value of interest.\n    \"\"\"\n    out = sh(cmdline)\n    result = out.split()[1]\n    try:\n        return int(result)\n    except ValueError:\n        return result\n\n\ndef vm_stat(field):\n    \"\"\"Wrapper around 'vm_stat' cmdline utility.\"\"\"\n    out = sh('vm_stat')\n    for line in out.split('\\n'):\n        if field in line:\n            break\n    else:\n        raise ValueError(\"line not found\")\n    return int(re.search(r'\\d+', line).group(0)) * getpagesize()\n\n\n@unittest.skipIf(not MACOS, \"MACOS only\")\nclass TestProcess(PsutilTestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_process_create_time(self):\n        output = sh(\"ps -o lstart -p %s\" % self.pid)\n        start_ps = output.replace('STARTED', '').strip()\n        hhmmss = start_ps.split(' ')[-2]\n        year = start_ps.split(' ')[-1]\n        start_psutil = psutil.Process(self.pid).create_time()\n        self.assertEqual(\n            hhmmss, time.strftime(\"%H:%M:%S\", time.localtime(start_psutil))\n        )\n        self.assertEqual(\n            year, time.strftime(\"%Y\", time.localtime(start_psutil))\n        )\n\n\n@unittest.skipIf(not MACOS, \"MACOS only\")\nclass TestSystemAPIs(PsutilTestCase):\n\n    # --- disk\n\n    @retry_on_failure()\n    def test_disks(self):\n        # test psutil.disk_usage() and psutil.disk_partitions()\n        # against \"df -a\"\n        def df(path):\n            out = sh('df -k \"%s\"' % path).strip()\n            lines = out.split('\\n')\n            lines.pop(0)\n            line = lines.pop(0)\n            dev, total, used, free = line.split()[:4]\n            if dev == 'none':\n                dev = ''\n            total = int(total) * 1024\n            used = int(used) * 1024\n            free = int(free) * 1024\n            return dev, total, used, free\n\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            dev, total, used, free = df(part.mountpoint)\n            self.assertEqual(part.device, dev)\n            self.assertEqual(usage.total, total)\n            self.assertAlmostEqual(\n                usage.free, free, delta=TOLERANCE_DISK_USAGE\n            )\n            self.assertAlmostEqual(\n                usage.used, used, delta=TOLERANCE_DISK_USAGE\n            )\n\n    # --- cpu\n\n    def test_cpu_count_logical(self):\n        num = sysctl(\"sysctl hw.logicalcpu\")\n        self.assertEqual(num, psutil.cpu_count(logical=True))\n\n    def test_cpu_count_cores(self):\n        num = sysctl(\"sysctl hw.physicalcpu\")\n        self.assertEqual(num, psutil.cpu_count(logical=False))\n\n    # TODO: remove this once 1892 is fixed\n    @unittest.skipIf(\n        MACOS and platform.machine() == 'arm64', \"skipped due to #1892\"\n    )\n    def test_cpu_freq(self):\n        freq = psutil.cpu_freq()\n        self.assertEqual(\n            freq.current * 1000 * 1000, sysctl(\"sysctl hw.cpufrequency\")\n        )\n        self.assertEqual(\n            freq.min * 1000 * 1000, sysctl(\"sysctl hw.cpufrequency_min\")\n        )\n        self.assertEqual(\n            freq.max * 1000 * 1000, sysctl(\"sysctl hw.cpufrequency_max\")\n        )\n\n    # --- virtual mem\n\n    def test_vmem_total(self):\n        sysctl_hwphymem = sysctl('sysctl hw.memsize')\n        self.assertEqual(sysctl_hwphymem, psutil.virtual_memory().total)\n\n    @retry_on_failure()\n    def test_vmem_free(self):\n        vmstat_val = vm_stat(\"free\")\n        psutil_val = psutil.virtual_memory().free\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_active(self):\n        vmstat_val = vm_stat(\"active\")\n        psutil_val = psutil.virtual_memory().active\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_inactive(self):\n        vmstat_val = vm_stat(\"inactive\")\n        psutil_val = psutil.virtual_memory().inactive\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_vmem_wired(self):\n        vmstat_val = vm_stat(\"wired\")\n        psutil_val = psutil.virtual_memory().wired\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    # --- swap mem\n\n    @retry_on_failure()\n    def test_swapmem_sin(self):\n        vmstat_val = vm_stat(\"Pageins\")\n        psutil_val = psutil.swap_memory().sin\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    @retry_on_failure()\n    def test_swapmem_sout(self):\n        vmstat_val = vm_stat(\"Pageout\")\n        psutil_val = psutil.swap_memory().sout\n        self.assertAlmostEqual(psutil_val, vmstat_val, delta=TOLERANCE_SYS_MEM)\n\n    # --- network\n\n    def test_net_if_stats(self):\n        for name, stats in psutil.net_if_stats().items():\n            try:\n                out = sh(\"ifconfig %s\" % name)\n            except RuntimeError:\n                pass\n            else:\n                self.assertEqual(stats.isup, 'RUNNING' in out, msg=out)\n                self.assertEqual(\n                    stats.mtu, int(re.findall(r'mtu (\\d+)', out)[0])\n                )\n\n    # --- sensors_battery\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery(self):\n        out = sh(\"pmset -g batt\")\n        percent = re.search(r\"(\\d+)%\", out).group(1)\n        drawing_from = re.search(\"Now drawing from '([^']+)'\", out).group(1)\n        power_plugged = drawing_from == \"AC Power\"\n        psutil_result = psutil.sensors_battery()\n        self.assertEqual(psutil_result.power_plugged, power_plugged)\n        self.assertEqual(psutil_result.percent, int(percent))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_process_all.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Iterate over all process PIDs and for each one of them invoke and\ntest all psutil.Process() methods.\n\"\"\"\n\nimport enum\nimport errno\nimport multiprocessing\nimport os\nimport stat\nimport time\nimport traceback\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import OSX\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import long\nfrom psutil._compat import unicode\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import VALID_PROC_STATUSES\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import check_connection_ntuple\nfrom psutil.tests import create_sockets\nfrom psutil.tests import is_namedtuple\nfrom psutil.tests import is_win_secure_system_proc\nfrom psutil.tests import process_namespace\nfrom psutil.tests import serialrun\n\n\n# Cuts the time in half, but (e.g.) on macOS the process pool stays\n# alive after join() (multiprocessing bug?), messing up other tests.\nUSE_PROC_POOL = LINUX and not CI_TESTING\n\n\ndef proc_info(pid):\n    tcase = PsutilTestCase()\n\n    def check_exception(exc, proc, name, ppid):\n        tcase.assertEqual(exc.pid, pid)\n        if exc.name is not None:\n            tcase.assertEqual(exc.name, name)\n        if isinstance(exc, psutil.ZombieProcess):\n            tcase.assertProcessZombie(proc)\n            if exc.ppid is not None:\n                tcase.assertGreaterEqual(exc.ppid, 0)\n                tcase.assertEqual(exc.ppid, ppid)\n        elif isinstance(exc, psutil.NoSuchProcess):\n            tcase.assertProcessGone(proc)\n        str(exc)\n        repr(exc)\n\n    def do_wait():\n        if pid != 0:\n            try:\n                proc.wait(0)\n            except psutil.Error as exc:\n                check_exception(exc, proc, name, ppid)\n\n    try:\n        proc = psutil.Process(pid)\n    except psutil.NoSuchProcess:\n        tcase.assertPidGone(pid)\n        return {}\n    try:\n        d = proc.as_dict(['ppid', 'name'])\n    except psutil.NoSuchProcess:\n        tcase.assertProcessGone(proc)\n    else:\n        name, ppid = d['name'], d['ppid']\n        info = {'pid': proc.pid}\n        ns = process_namespace(proc)\n        # We don't use oneshot() because in order not to fool\n        # check_exception() in case of NSP.\n        for fun, fun_name in ns.iter(ns.getters, clear_cache=False):\n            try:\n                info[fun_name] = fun()\n            except psutil.Error as exc:\n                check_exception(exc, proc, name, ppid)\n                continue\n        do_wait()\n        return info\n\n\n@serialrun\nclass TestFetchAllProcesses(PsutilTestCase):\n    \"\"\"Test which iterates over all running processes and performs\n    some sanity checks against Process API's returned values.\n    Uses a process pool to get info about all processes.\n    \"\"\"\n\n    def setUp(self):\n        psutil._set_debug(False)\n        # Using a pool in a CI env may result in deadlock, see:\n        # https://github.com/giampaolo/psutil/issues/2104\n        if USE_PROC_POOL:\n            self.pool = multiprocessing.Pool()\n\n    def tearDown(self):\n        psutil._set_debug(True)\n        if USE_PROC_POOL:\n            self.pool.terminate()\n            self.pool.join()\n\n    def iter_proc_info(self):\n        # Fixes \"can't pickle <function proc_info>: it's not the\n        # same object as test_process_all.proc_info\".\n        from psutil.tests.test_process_all import proc_info\n\n        if USE_PROC_POOL:\n            return self.pool.imap_unordered(proc_info, psutil.pids())\n        else:\n            ls = []\n            for pid in psutil.pids():\n                ls.append(proc_info(pid))\n            return ls\n\n    def test_all(self):\n        failures = []\n        for info in self.iter_proc_info():\n            for name, value in info.items():\n                meth = getattr(self, name)\n                try:\n                    meth(value, info)\n                except Exception:  # noqa: BLE001\n                    s = '\\n' + '=' * 70 + '\\n'\n                    s += \"FAIL: name=test_%s, pid=%s, ret=%s\\ninfo=%s\\n\" % (\n                        name,\n                        info['pid'],\n                        repr(value),\n                        info,\n                    )\n                    s += '-' * 70\n                    s += \"\\n%s\" % traceback.format_exc()\n                    s = \"\\n\".join((\" \" * 4) + i for i in s.splitlines()) + \"\\n\"\n                    failures.append(s)\n                else:\n                    if value not in (0, 0.0, [], None, '', {}):\n                        assert value, value\n        if failures:\n            raise self.fail(''.join(failures))\n\n    def cmdline(self, ret, info):\n        self.assertIsInstance(ret, list)\n        for part in ret:\n            self.assertIsInstance(part, str)\n\n    def exe(self, ret, info):\n        self.assertIsInstance(ret, (str, unicode))\n        self.assertEqual(ret.strip(), ret)\n        if ret:\n            if WINDOWS and not ret.endswith('.exe'):\n                return  # May be \"Registry\", \"MemCompression\", ...\n            assert os.path.isabs(ret), ret\n            # Note: os.stat() may return False even if the file is there\n            # hence we skip the test, see:\n            # http://stackoverflow.com/questions/3112546/os-path-exists-lies\n            if POSIX and os.path.isfile(ret):\n                if hasattr(os, 'access') and hasattr(os, \"X_OK\"):\n                    # XXX: may fail on MACOS\n                    try:\n                        assert os.access(ret, os.X_OK)\n                    except AssertionError:\n                        if os.path.exists(ret) and not CI_TESTING:\n                            raise\n\n    def pid(self, ret, info):\n        self.assertIsInstance(ret, int)\n        self.assertGreaterEqual(ret, 0)\n\n    def ppid(self, ret, info):\n        self.assertIsInstance(ret, (int, long))\n        self.assertGreaterEqual(ret, 0)\n        proc_info(ret)\n\n    def name(self, ret, info):\n        self.assertIsInstance(ret, (str, unicode))\n        if WINDOWS and not ret and is_win_secure_system_proc(info['pid']):\n            # https://github.com/giampaolo/psutil/issues/2338\n            return\n        # on AIX, \"<exiting>\" processes don't have names\n        if not AIX:\n            assert ret, repr(ret)\n\n    def create_time(self, ret, info):\n        self.assertIsInstance(ret, float)\n        try:\n            self.assertGreaterEqual(ret, 0)\n        except AssertionError:\n            # XXX\n            if OPENBSD and info['status'] == psutil.STATUS_ZOMBIE:\n                pass\n            else:\n                raise\n        # this can't be taken for granted on all platforms\n        # self.assertGreaterEqual(ret, psutil.boot_time())\n        # make sure returned value can be pretty printed\n        # with strftime\n        time.strftime(\"%Y %m %d %H:%M:%S\", time.localtime(ret))\n\n    def uids(self, ret, info):\n        assert is_namedtuple(ret)\n        for uid in ret:\n            self.assertIsInstance(uid, int)\n            self.assertGreaterEqual(uid, 0)\n\n    def gids(self, ret, info):\n        assert is_namedtuple(ret)\n        # note: testing all gids as above seems not to be reliable for\n        # gid == 30 (nodoby); not sure why.\n        for gid in ret:\n            self.assertIsInstance(gid, int)\n            if not MACOS and not NETBSD:\n                self.assertGreaterEqual(gid, 0)\n\n    def username(self, ret, info):\n        self.assertIsInstance(ret, str)\n        self.assertEqual(ret.strip(), ret)\n        assert ret.strip()\n\n    def status(self, ret, info):\n        self.assertIsInstance(ret, str)\n        assert ret, ret\n        if QEMU_USER:\n            # status does not work under qemu user\n            return\n        self.assertNotEqual(ret, '?')  # XXX\n        self.assertIn(ret, VALID_PROC_STATUSES)\n\n    def io_counters(self, ret, info):\n        assert is_namedtuple(ret)\n        for field in ret:\n            self.assertIsInstance(field, (int, long))\n            if field != -1:\n                self.assertGreaterEqual(field, 0)\n\n    def ionice(self, ret, info):\n        if LINUX:\n            self.assertIsInstance(ret.ioclass, int)\n            self.assertIsInstance(ret.value, int)\n            self.assertGreaterEqual(ret.ioclass, 0)\n            self.assertGreaterEqual(ret.value, 0)\n        else:  # Windows, Cygwin\n            choices = [\n                psutil.IOPRIO_VERYLOW,\n                psutil.IOPRIO_LOW,\n                psutil.IOPRIO_NORMAL,\n                psutil.IOPRIO_HIGH,\n            ]\n            self.assertIsInstance(ret, int)\n            self.assertGreaterEqual(ret, 0)\n            self.assertIn(ret, choices)\n\n    def num_threads(self, ret, info):\n        self.assertIsInstance(ret, int)\n        if WINDOWS and ret == 0 and is_win_secure_system_proc(info['pid']):\n            # https://github.com/giampaolo/psutil/issues/2338\n            return\n        self.assertGreaterEqual(ret, 1)\n\n    def threads(self, ret, info):\n        self.assertIsInstance(ret, list)\n        for t in ret:\n            assert is_namedtuple(t)\n            self.assertGreaterEqual(t.id, 0)\n            self.assertGreaterEqual(t.user_time, 0)\n            self.assertGreaterEqual(t.system_time, 0)\n            for field in t:\n                self.assertIsInstance(field, (int, float))\n\n    def cpu_times(self, ret, info):\n        assert is_namedtuple(ret)\n        for n in ret:\n            self.assertIsInstance(n, float)\n            self.assertGreaterEqual(n, 0)\n        # TODO: check ntuple fields\n\n    def cpu_percent(self, ret, info):\n        self.assertIsInstance(ret, float)\n        assert 0.0 <= ret <= 100.0, ret\n\n    def cpu_num(self, ret, info):\n        self.assertIsInstance(ret, int)\n        if FREEBSD and ret == -1:\n            return\n        self.assertGreaterEqual(ret, 0)\n        if psutil.cpu_count() == 1:\n            self.assertEqual(ret, 0)\n        self.assertIn(ret, list(range(psutil.cpu_count())))\n\n    def memory_info(self, ret, info):\n        assert is_namedtuple(ret)\n        for value in ret:\n            self.assertIsInstance(value, (int, long))\n            self.assertGreaterEqual(value, 0)\n        if WINDOWS:\n            self.assertGreaterEqual(ret.peak_wset, ret.wset)\n            self.assertGreaterEqual(ret.peak_paged_pool, ret.paged_pool)\n            self.assertGreaterEqual(ret.peak_nonpaged_pool, ret.nonpaged_pool)\n            self.assertGreaterEqual(ret.peak_pagefile, ret.pagefile)\n\n    def memory_full_info(self, ret, info):\n        assert is_namedtuple(ret)\n        total = psutil.virtual_memory().total\n        for name in ret._fields:\n            value = getattr(ret, name)\n            self.assertIsInstance(value, (int, long))\n            self.assertGreaterEqual(value, 0, msg=(name, value))\n            if LINUX or OSX and name in ('vms', 'data'):\n                # On Linux there are processes (e.g. 'goa-daemon') whose\n                # VMS is incredibly high for some reason.\n                continue\n            self.assertLessEqual(value, total, msg=(name, value, total))\n\n        if LINUX:\n            self.assertGreaterEqual(ret.pss, ret.uss)\n\n    def open_files(self, ret, info):\n        self.assertIsInstance(ret, list)\n        for f in ret:\n            self.assertIsInstance(f.fd, int)\n            self.assertIsInstance(f.path, str)\n            self.assertEqual(f.path.strip(), f.path)\n            if WINDOWS:\n                self.assertEqual(f.fd, -1)\n            elif LINUX:\n                self.assertIsInstance(f.position, int)\n                self.assertIsInstance(f.mode, str)\n                self.assertIsInstance(f.flags, int)\n                self.assertGreaterEqual(f.position, 0)\n                self.assertIn(f.mode, ('r', 'w', 'a', 'r+', 'a+'))\n                self.assertGreater(f.flags, 0)\n            elif BSD and not f.path:\n                # XXX see: https://github.com/giampaolo/psutil/issues/595\n                continue\n            assert os.path.isabs(f.path), f\n            try:\n                st = os.stat(f.path)\n            except FileNotFoundError:\n                pass\n            else:\n                assert stat.S_ISREG(st.st_mode), f\n\n    def num_fds(self, ret, info):\n        self.assertIsInstance(ret, int)\n        self.assertGreaterEqual(ret, 0)\n\n    def net_connections(self, ret, info):\n        with create_sockets():\n            self.assertEqual(len(ret), len(set(ret)))\n            for conn in ret:\n                assert is_namedtuple(conn)\n                check_connection_ntuple(conn)\n\n    def cwd(self, ret, info):\n        self.assertIsInstance(ret, (str, unicode))\n        self.assertEqual(ret.strip(), ret)\n        if ret:\n            assert os.path.isabs(ret), ret\n            try:\n                st = os.stat(ret)\n            except OSError as err:\n                if WINDOWS and psutil._psplatform.is_permission_err(err):\n                    pass\n                # directory has been removed in mean time\n                elif err.errno != errno.ENOENT:\n                    raise\n            else:\n                assert stat.S_ISDIR(st.st_mode)\n\n    def memory_percent(self, ret, info):\n        self.assertIsInstance(ret, float)\n        assert 0 <= ret <= 100, ret\n\n    def is_running(self, ret, info):\n        self.assertIsInstance(ret, bool)\n\n    def cpu_affinity(self, ret, info):\n        self.assertIsInstance(ret, list)\n        self.assertNotEqual(ret, [])\n        cpus = list(range(psutil.cpu_count()))\n        for n in ret:\n            self.assertIsInstance(n, int)\n            self.assertIn(n, cpus)\n\n    def terminal(self, ret, info):\n        self.assertIsInstance(ret, (str, type(None)))\n        if ret is not None:\n            assert os.path.isabs(ret), ret\n            assert os.path.exists(ret), ret\n\n    def memory_maps(self, ret, info):\n        for nt in ret:\n            self.assertIsInstance(nt.addr, str)\n            self.assertIsInstance(nt.perms, str)\n            self.assertIsInstance(nt.path, str)\n            for fname in nt._fields:\n                value = getattr(nt, fname)\n                if fname == 'path':\n                    if not value.startswith((\"[\", \"anon_inode:\")):\n                        assert os.path.isabs(nt.path), nt.path\n                        # commented as on Linux we might get\n                        # '/foo/bar (deleted)'\n                        # assert os.path.exists(nt.path), nt.path\n                elif fname == 'addr':\n                    assert value, repr(value)\n                elif fname == 'perms':\n                    if not WINDOWS:\n                        assert value, repr(value)\n                else:\n                    self.assertIsInstance(value, (int, long))\n                    self.assertGreaterEqual(value, 0)\n\n    def num_handles(self, ret, info):\n        self.assertIsInstance(ret, int)\n        self.assertGreaterEqual(ret, 0)\n\n    def nice(self, ret, info):\n        self.assertIsInstance(ret, int)\n        if POSIX:\n            assert -20 <= ret <= 20, ret\n        else:\n            priorities = [\n                getattr(psutil, x)\n                for x in dir(psutil)\n                if x.endswith('_PRIORITY_CLASS')\n            ]\n            self.assertIn(ret, priorities)\n            if PY3:\n                self.assertIsInstance(ret, enum.IntEnum)\n            else:\n                self.assertIsInstance(ret, int)\n\n    def num_ctx_switches(self, ret, info):\n        assert is_namedtuple(ret)\n        for value in ret:\n            self.assertIsInstance(value, (int, long))\n            self.assertGreaterEqual(value, 0)\n\n    def rlimit(self, ret, info):\n        self.assertIsInstance(ret, tuple)\n        self.assertEqual(len(ret), 2)\n        self.assertGreaterEqual(ret[0], -1)\n        self.assertGreaterEqual(ret[1], -1)\n\n    def environ(self, ret, info):\n        self.assertIsInstance(ret, dict)\n        for k, v in ret.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n\n\nclass TestPidsRange(PsutilTestCase):\n    \"\"\"Given pid_exists() return value for a range of PIDs which may or\n    may not exist, make sure that psutil.Process() and psutil.pids()\n    agree with pid_exists(). This guarantees that the 3 APIs are all\n    consistent with each other. See:\n    https://github.com/giampaolo/psutil/issues/2359\n\n    XXX - Note about Windows: it turns out there are some \"hidden\" PIDs\n    which are not returned by psutil.pids() and are also not revealed\n    by taskmgr.exe and ProcessHacker, still they can be instantiated by\n    psutil.Process() and queried. One of such PIDs is \"conhost.exe\".\n    Running as_dict() for it reveals that some Process() APIs\n    erroneously raise NoSuchProcess, so we know we have problem there.\n    Let's ignore this for now, since it's quite a corner case (who even\n    imagined hidden PIDs existed on Windows?).\n    \"\"\"\n\n    def setUp(self):\n        psutil._set_debug(False)\n\n    def tearDown(self):\n        psutil._set_debug(True)\n\n    def test_it(self):\n        def is_linux_tid(pid):\n            try:\n                f = open(\"/proc/%s/status\" % pid, \"rb\")\n            except FileNotFoundError:\n                return False\n            else:\n                with f:\n                    for line in f:\n                        if line.startswith(b\"Tgid:\"):\n                            tgid = int(line.split()[1])\n                            # If tgid and pid are different then we're\n                            # dealing with a process TID.\n                            return tgid != pid\n                    raise ValueError(\"'Tgid' line not found\")\n\n        def check(pid):\n            # In case of failure retry up to 3 times in order to avoid\n            # race conditions, especially when running in a CI\n            # environment where PIDs may appear and disappear at any\n            # time.\n            x = 3\n            while True:\n                exists = psutil.pid_exists(pid)\n                try:\n                    if exists:\n                        psutil.Process(pid)\n                        if not WINDOWS:  # see docstring\n                            self.assertIn(pid, psutil.pids())\n                    else:\n                        # On OpenBSD thread IDs can be instantiated,\n                        # and oneshot() succeeds, but other APIs fail\n                        # with EINVAL.\n                        if not OPENBSD:\n                            with self.assertRaises(psutil.NoSuchProcess):\n                                psutil.Process(pid)\n                        if not WINDOWS:  # see docstring\n                            self.assertNotIn(pid, psutil.pids())\n                except (psutil.Error, AssertionError):\n                    x -= 1\n                    if x == 0:\n                        raise\n                else:\n                    return\n\n        for pid in range(1, 3000):\n            if LINUX and is_linux_tid(pid):\n                # On Linux a TID (thread ID) can be passed to the\n                # Process class and is querable like a PID (process\n                # ID). Skip it.\n                continue\n            with self.subTest(pid=pid):\n                check(pid)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_bsd.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n# TODO: (FreeBSD) add test for comparing connections with 'sockstat' cmd.\n\n\n\"\"\"Tests specific to all BSD platforms.\"\"\"\n\n\nimport datetime\nimport os\nimport re\nimport time\nimport unittest\n\nimport psutil\nfrom psutil import BSD\nfrom psutil import FREEBSD\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import which\n\n\nif BSD:\n    from psutil._psutil_posix import getpagesize\n\n    PAGESIZE = getpagesize()\n    # muse requires root privileges\n    MUSE_AVAILABLE = os.getuid() == 0 and which('muse')\nelse:\n    PAGESIZE = None\n    MUSE_AVAILABLE = False\n\n\ndef sysctl(cmdline):\n    \"\"\"Expects a sysctl command with an argument and parse the result\n    returning only the value of interest.\n    \"\"\"\n    result = sh(\"sysctl \" + cmdline)\n    if FREEBSD:\n        result = result[result.find(\": \") + 2 :]\n    elif OPENBSD or NETBSD:\n        result = result[result.find(\"=\") + 1 :]\n    try:\n        return int(result)\n    except ValueError:\n        return result\n\n\ndef muse(field):\n    \"\"\"Thin wrapper around 'muse' cmdline utility.\"\"\"\n    out = sh('muse')\n    for line in out.split('\\n'):\n        if line.startswith(field):\n            break\n    else:\n        raise ValueError(\"line not found\")\n    return int(line.split()[1])\n\n\n# =====================================================================\n# --- All BSD*\n# =====================================================================\n\n\n@unittest.skipIf(not BSD, \"BSD only\")\nclass BSDTestCase(PsutilTestCase):\n    \"\"\"Generic tests common to all BSD variants.\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    @unittest.skipIf(NETBSD, \"-o lstart doesn't work on NETBSD\")\n    def test_process_create_time(self):\n        output = sh(\"ps -o lstart -p %s\" % self.pid)\n        start_ps = output.replace('STARTED', '').strip()\n        start_psutil = psutil.Process(self.pid).create_time()\n        start_psutil = time.strftime(\n            \"%a %b %e %H:%M:%S %Y\", time.localtime(start_psutil)\n        )\n        self.assertEqual(start_ps, start_psutil)\n\n    def test_disks(self):\n        # test psutil.disk_usage() and psutil.disk_partitions()\n        # against \"df -a\"\n        def df(path):\n            out = sh('df -k \"%s\"' % path).strip()\n            lines = out.split('\\n')\n            lines.pop(0)\n            line = lines.pop(0)\n            dev, total, used, free = line.split()[:4]\n            if dev == 'none':\n                dev = ''\n            total = int(total) * 1024\n            used = int(used) * 1024\n            free = int(free) * 1024\n            return dev, total, used, free\n\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            dev, total, used, free = df(part.mountpoint)\n            self.assertEqual(part.device, dev)\n            self.assertEqual(usage.total, total)\n            # 10 MB tolerance\n            if abs(usage.free - free) > 10 * 1024 * 1024:\n                raise self.fail(\"psutil=%s, df=%s\" % (usage.free, free))\n            if abs(usage.used - used) > 10 * 1024 * 1024:\n                raise self.fail(\"psutil=%s, df=%s\" % (usage.used, used))\n\n    @unittest.skipIf(not which('sysctl'), \"sysctl cmd not available\")\n    def test_cpu_count_logical(self):\n        syst = sysctl(\"hw.ncpu\")\n        self.assertEqual(psutil.cpu_count(logical=True), syst)\n\n    @unittest.skipIf(not which('sysctl'), \"sysctl cmd not available\")\n    @unittest.skipIf(NETBSD, \"skipped on NETBSD\")  # we check /proc/meminfo\n    def test_virtual_memory_total(self):\n        num = sysctl('hw.physmem')\n        self.assertEqual(num, psutil.virtual_memory().total)\n\n    @unittest.skipIf(not which('ifconfig'), \"ifconfig cmd not available\")\n    def test_net_if_stats(self):\n        for name, stats in psutil.net_if_stats().items():\n            try:\n                out = sh(\"ifconfig %s\" % name)\n            except RuntimeError:\n                pass\n            else:\n                self.assertEqual(stats.isup, 'RUNNING' in out, msg=out)\n                if \"mtu\" in out:\n                    self.assertEqual(\n                        stats.mtu, int(re.findall(r'mtu (\\d+)', out)[0])\n                    )\n\n\n# =====================================================================\n# --- FreeBSD\n# =====================================================================\n\n\n@unittest.skipIf(not FREEBSD, \"FREEBSD only\")\nclass FreeBSDPsutilTestCase(PsutilTestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    @retry_on_failure()\n    def test_memory_maps(self):\n        out = sh('procstat -v %s' % self.pid)\n        maps = psutil.Process(self.pid).memory_maps(grouped=False)\n        lines = out.split('\\n')[1:]\n        while lines:\n            line = lines.pop()\n            fields = line.split()\n            _, start, stop, _perms, res = fields[:5]\n            map = maps.pop()\n            self.assertEqual(\"%s-%s\" % (start, stop), map.addr)\n            self.assertEqual(int(res), map.rss)\n            if not map.path.startswith('['):\n                self.assertEqual(fields[10], map.path)\n\n    def test_exe(self):\n        out = sh('procstat -b %s' % self.pid)\n        self.assertEqual(\n            psutil.Process(self.pid).exe(), out.split('\\n')[1].split()[-1]\n        )\n\n    def test_cmdline(self):\n        out = sh('procstat -c %s' % self.pid)\n        self.assertEqual(\n            ' '.join(psutil.Process(self.pid).cmdline()),\n            ' '.join(out.split('\\n')[1].split()[2:]),\n        )\n\n    def test_uids_gids(self):\n        out = sh('procstat -s %s' % self.pid)\n        euid, ruid, suid, egid, rgid, sgid = out.split('\\n')[1].split()[2:8]\n        p = psutil.Process(self.pid)\n        uids = p.uids()\n        gids = p.gids()\n        self.assertEqual(uids.real, int(ruid))\n        self.assertEqual(uids.effective, int(euid))\n        self.assertEqual(uids.saved, int(suid))\n        self.assertEqual(gids.real, int(rgid))\n        self.assertEqual(gids.effective, int(egid))\n        self.assertEqual(gids.saved, int(sgid))\n\n    @retry_on_failure()\n    def test_ctx_switches(self):\n        tested = []\n        out = sh('procstat -r %s' % self.pid)\n        p = psutil.Process(self.pid)\n        for line in out.split('\\n'):\n            line = line.lower().strip()\n            if ' voluntary context' in line:\n                pstat_value = int(line.split()[-1])\n                psutil_value = p.num_ctx_switches().voluntary\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n            elif ' involuntary context' in line:\n                pstat_value = int(line.split()[-1])\n                psutil_value = p.num_ctx_switches().involuntary\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n        if len(tested) != 2:\n            raise RuntimeError(\"couldn't find lines match in procstat out\")\n\n    @retry_on_failure()\n    def test_cpu_times(self):\n        tested = []\n        out = sh('procstat -r %s' % self.pid)\n        p = psutil.Process(self.pid)\n        for line in out.split('\\n'):\n            line = line.lower().strip()\n            if 'user time' in line:\n                pstat_value = float('0.' + line.split()[-1].split('.')[-1])\n                psutil_value = p.cpu_times().user\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n            elif 'system time' in line:\n                pstat_value = float('0.' + line.split()[-1].split('.')[-1])\n                psutil_value = p.cpu_times().system\n                self.assertEqual(pstat_value, psutil_value)\n                tested.append(None)\n        if len(tested) != 2:\n            raise RuntimeError(\"couldn't find lines match in procstat out\")\n\n\n@unittest.skipIf(not FREEBSD, \"FREEBSD only\")\nclass FreeBSDSystemTestCase(PsutilTestCase):\n    @staticmethod\n    def parse_swapinfo():\n        # the last line is always the total\n        output = sh(\"swapinfo -k\").splitlines()[-1]\n        parts = re.split(r'\\s+', output)\n\n        if not parts:\n            raise ValueError(\"Can't parse swapinfo: %s\" % output)\n\n        # the size is in 1k units, so multiply by 1024\n        total, used, free = (int(p) * 1024 for p in parts[1:4])\n        return total, used, free\n\n    def test_cpu_frequency_against_sysctl(self):\n        # Currently only cpu 0 is frequency is supported in FreeBSD\n        # All other cores use the same frequency.\n        sensor = \"dev.cpu.0.freq\"\n        try:\n            sysctl_result = int(sysctl(sensor))\n        except RuntimeError:\n            raise unittest.SkipTest(\"frequencies not supported by kernel\")\n        self.assertEqual(psutil.cpu_freq().current, sysctl_result)\n\n        sensor = \"dev.cpu.0.freq_levels\"\n        sysctl_result = sysctl(sensor)\n        # sysctl returns a string of the format:\n        # <freq_level_1>/<voltage_level_1> <freq_level_2>/<voltage_level_2>...\n        # Ordered highest available to lowest available.\n        max_freq = int(sysctl_result.split()[0].split(\"/\")[0])\n        min_freq = int(sysctl_result.split()[-1].split(\"/\")[0])\n        self.assertEqual(psutil.cpu_freq().max, max_freq)\n        self.assertEqual(psutil.cpu_freq().min, min_freq)\n\n    # --- virtual_memory(); tests against sysctl\n\n    @retry_on_failure()\n    def test_vmem_active(self):\n        syst = sysctl(\"vm.stats.vm.v_active_count\") * PAGESIZE\n        self.assertAlmostEqual(\n            psutil.virtual_memory().active, syst, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_vmem_inactive(self):\n        syst = sysctl(\"vm.stats.vm.v_inactive_count\") * PAGESIZE\n        self.assertAlmostEqual(\n            psutil.virtual_memory().inactive, syst, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_vmem_wired(self):\n        syst = sysctl(\"vm.stats.vm.v_wire_count\") * PAGESIZE\n        self.assertAlmostEqual(\n            psutil.virtual_memory().wired, syst, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_vmem_cached(self):\n        syst = sysctl(\"vm.stats.vm.v_cache_count\") * PAGESIZE\n        self.assertAlmostEqual(\n            psutil.virtual_memory().cached, syst, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_vmem_free(self):\n        syst = sysctl(\"vm.stats.vm.v_free_count\") * PAGESIZE\n        self.assertAlmostEqual(\n            psutil.virtual_memory().free, syst, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_vmem_buffers(self):\n        syst = sysctl(\"vfs.bufspace\")\n        self.assertAlmostEqual(\n            psutil.virtual_memory().buffers, syst, delta=TOLERANCE_SYS_MEM\n        )\n\n    # --- virtual_memory(); tests against muse\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    def test_muse_vmem_total(self):\n        num = muse('Total')\n        self.assertEqual(psutil.virtual_memory().total, num)\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_active(self):\n        num = muse('Active')\n        self.assertAlmostEqual(\n            psutil.virtual_memory().active, num, delta=TOLERANCE_SYS_MEM\n        )\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_inactive(self):\n        num = muse('Inactive')\n        self.assertAlmostEqual(\n            psutil.virtual_memory().inactive, num, delta=TOLERANCE_SYS_MEM\n        )\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_wired(self):\n        num = muse('Wired')\n        self.assertAlmostEqual(\n            psutil.virtual_memory().wired, num, delta=TOLERANCE_SYS_MEM\n        )\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_cached(self):\n        num = muse('Cache')\n        self.assertAlmostEqual(\n            psutil.virtual_memory().cached, num, delta=TOLERANCE_SYS_MEM\n        )\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_free(self):\n        num = muse('Free')\n        self.assertAlmostEqual(\n            psutil.virtual_memory().free, num, delta=TOLERANCE_SYS_MEM\n        )\n\n    @unittest.skipIf(not MUSE_AVAILABLE, \"muse not installed\")\n    @retry_on_failure()\n    def test_muse_vmem_buffers(self):\n        num = muse('Buffer')\n        self.assertAlmostEqual(\n            psutil.virtual_memory().buffers, num, delta=TOLERANCE_SYS_MEM\n        )\n\n    def test_cpu_stats_ctx_switches(self):\n        self.assertAlmostEqual(\n            psutil.cpu_stats().ctx_switches,\n            sysctl('vm.stats.sys.v_swtch'),\n            delta=1000,\n        )\n\n    def test_cpu_stats_interrupts(self):\n        self.assertAlmostEqual(\n            psutil.cpu_stats().interrupts,\n            sysctl('vm.stats.sys.v_intr'),\n            delta=1000,\n        )\n\n    def test_cpu_stats_soft_interrupts(self):\n        self.assertAlmostEqual(\n            psutil.cpu_stats().soft_interrupts,\n            sysctl('vm.stats.sys.v_soft'),\n            delta=1000,\n        )\n\n    @retry_on_failure()\n    def test_cpu_stats_syscalls(self):\n        # pretty high tolerance but it looks like it's OK.\n        self.assertAlmostEqual(\n            psutil.cpu_stats().syscalls,\n            sysctl('vm.stats.sys.v_syscall'),\n            delta=200000,\n        )\n\n    # def test_cpu_stats_traps(self):\n    #    self.assertAlmostEqual(psutil.cpu_stats().traps,\n    #                           sysctl('vm.stats.sys.v_trap'), delta=1000)\n\n    # --- swap memory\n\n    def test_swapmem_free(self):\n        _total, _used, free = self.parse_swapinfo()\n        self.assertAlmostEqual(\n            psutil.swap_memory().free, free, delta=TOLERANCE_SYS_MEM\n        )\n\n    def test_swapmem_used(self):\n        _total, used, _free = self.parse_swapinfo()\n        self.assertAlmostEqual(\n            psutil.swap_memory().used, used, delta=TOLERANCE_SYS_MEM\n        )\n\n    def test_swapmem_total(self):\n        total, _used, _free = self.parse_swapinfo()\n        self.assertAlmostEqual(\n            psutil.swap_memory().total, total, delta=TOLERANCE_SYS_MEM\n        )\n\n    # --- others\n\n    def test_boot_time(self):\n        s = sysctl('sysctl kern.boottime')\n        s = s[s.find(\" sec = \") + 7 :]\n        s = s[: s.find(',')]\n        btime = int(s)\n        self.assertEqual(btime, psutil.boot_time())\n\n    # --- sensors_battery\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery(self):\n        def secs2hours(secs):\n            m, _s = divmod(secs, 60)\n            h, m = divmod(m, 60)\n            return \"%d:%02d\" % (h, m)\n\n        out = sh(\"acpiconf -i 0\")\n        fields = dict(\n            [(x.split('\\t')[0], x.split('\\t')[-1]) for x in out.split(\"\\n\")]\n        )\n        metrics = psutil.sensors_battery()\n        percent = int(fields['Remaining capacity:'].replace('%', ''))\n        remaining_time = fields['Remaining time:']\n        self.assertEqual(metrics.percent, percent)\n        if remaining_time == 'unknown':\n            self.assertEqual(metrics.secsleft, psutil.POWER_TIME_UNLIMITED)\n        else:\n            self.assertEqual(secs2hours(metrics.secsleft), remaining_time)\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_sensors_battery_against_sysctl(self):\n        self.assertEqual(\n            psutil.sensors_battery().percent, sysctl(\"hw.acpi.battery.life\")\n        )\n        self.assertEqual(\n            psutil.sensors_battery().power_plugged,\n            sysctl(\"hw.acpi.acline\") == 1,\n        )\n        secsleft = psutil.sensors_battery().secsleft\n        if secsleft < 0:\n            self.assertEqual(sysctl(\"hw.acpi.battery.time\"), -1)\n        else:\n            self.assertEqual(secsleft, sysctl(\"hw.acpi.battery.time\") * 60)\n\n    @unittest.skipIf(HAS_BATTERY, \"has battery\")\n    def test_sensors_battery_no_battery(self):\n        # If no battery is present one of these calls is supposed\n        # to fail, see:\n        # https://github.com/giampaolo/psutil/issues/1074\n        with self.assertRaises(RuntimeError):\n            sysctl(\"hw.acpi.battery.life\")\n            sysctl(\"hw.acpi.battery.time\")\n            sysctl(\"hw.acpi.acline\")\n        self.assertIsNone(psutil.sensors_battery())\n\n    # --- sensors_temperatures\n\n    def test_sensors_temperatures_against_sysctl(self):\n        num_cpus = psutil.cpu_count(True)\n        for cpu in range(num_cpus):\n            sensor = \"dev.cpu.%s.temperature\" % cpu\n            # sysctl returns a string in the format 46.0C\n            try:\n                sysctl_result = int(float(sysctl(sensor)[:-1]))\n            except RuntimeError:\n                raise unittest.SkipTest(\"temperatures not supported by kernel\")\n            self.assertAlmostEqual(\n                psutil.sensors_temperatures()[\"coretemp\"][cpu].current,\n                sysctl_result,\n                delta=10,\n            )\n\n            sensor = \"dev.cpu.%s.coretemp.tjmax\" % cpu\n            sysctl_result = int(float(sysctl(sensor)[:-1]))\n            self.assertEqual(\n                psutil.sensors_temperatures()[\"coretemp\"][cpu].high,\n                sysctl_result,\n            )\n\n\n# =====================================================================\n# --- OpenBSD\n# =====================================================================\n\n\n@unittest.skipIf(not OPENBSD, \"OPENBSD only\")\nclass OpenBSDTestCase(PsutilTestCase):\n    def test_boot_time(self):\n        s = sysctl('kern.boottime')\n        sys_bt = datetime.datetime.strptime(s, \"%a %b %d %H:%M:%S %Y\")\n        psutil_bt = datetime.datetime.fromtimestamp(psutil.boot_time())\n        self.assertEqual(sys_bt, psutil_bt)\n\n\n# =====================================================================\n# --- NetBSD\n# =====================================================================\n\n\n@unittest.skipIf(not NETBSD, \"NETBSD only\")\nclass NetBSDTestCase(PsutilTestCase):\n    @staticmethod\n    def parse_meminfo(look_for):\n        with open('/proc/meminfo') as f:\n            for line in f:\n                if line.startswith(look_for):\n                    return int(line.split()[1]) * 1024\n        raise ValueError(\"can't find %s\" % look_for)\n\n    # --- virtual mem\n\n    def test_vmem_total(self):\n        self.assertEqual(\n            psutil.virtual_memory().total, self.parse_meminfo(\"MemTotal:\")\n        )\n\n    def test_vmem_free(self):\n        self.assertAlmostEqual(\n            psutil.virtual_memory().free,\n            self.parse_meminfo(\"MemFree:\"),\n            delta=TOLERANCE_SYS_MEM,\n        )\n\n    def test_vmem_buffers(self):\n        self.assertAlmostEqual(\n            psutil.virtual_memory().buffers,\n            self.parse_meminfo(\"Buffers:\"),\n            delta=TOLERANCE_SYS_MEM,\n        )\n\n    def test_vmem_shared(self):\n        self.assertAlmostEqual(\n            psutil.virtual_memory().shared,\n            self.parse_meminfo(\"MemShared:\"),\n            delta=TOLERANCE_SYS_MEM,\n        )\n\n    def test_vmem_cached(self):\n        self.assertAlmostEqual(\n            psutil.virtual_memory().cached,\n            self.parse_meminfo(\"Cached:\"),\n            delta=TOLERANCE_SYS_MEM,\n        )\n\n    # --- swap mem\n\n    def test_swapmem_total(self):\n        self.assertAlmostEqual(\n            psutil.swap_memory().total,\n            self.parse_meminfo(\"SwapTotal:\"),\n            delta=TOLERANCE_SYS_MEM,\n        )\n\n    def test_swapmem_free(self):\n        self.assertAlmostEqual(\n            psutil.swap_memory().free,\n            self.parse_meminfo(\"SwapFree:\"),\n            delta=TOLERANCE_SYS_MEM,\n        )\n\n    def test_swapmem_used(self):\n        smem = psutil.swap_memory()\n        self.assertEqual(smem.used, smem.total - smem.free)\n\n    # --- others\n\n    def test_cpu_stats_interrupts(self):\n        with open('/proc/stat', 'rb') as f:\n            for line in f:\n                if line.startswith(b'intr'):\n                    interrupts = int(line.split()[1])\n                    break\n            else:\n                raise ValueError(\"couldn't find line\")\n        self.assertAlmostEqual(\n            psutil.cpu_stats().interrupts, interrupts, delta=1000\n        )\n\n    def test_cpu_stats_ctx_switches(self):\n        with open('/proc/stat', 'rb') as f:\n            for line in f:\n                if line.startswith(b'ctxt'):\n                    ctx_switches = int(line.split()[1])\n                    break\n            else:\n                raise ValueError(\"couldn't find line\")\n        self.assertAlmostEqual(\n            psutil.cpu_stats().ctx_switches, ctx_switches, delta=1000\n        )\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/runner.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Unit test runner, providing new features on top of unittest module:\n- colourized output\n- parallel run (UNIX only)\n- print failures/tracebacks on CTRL+C\n- re-run failed tests only (make test-failed).\n\nInvocation examples:\n- make test\n- make test-failed\n\nParallel:\n- make test-parallel\n- make test-process ARGS=--parallel\n\"\"\"\n\nfrom __future__ import print_function\n\nimport atexit\nimport optparse\nimport os\nimport sys\nimport textwrap\nimport time\nimport unittest\n\n\ntry:\n    import ctypes\nexcept ImportError:\n    ctypes = None\n\ntry:\n    import concurrencytest  # pip install concurrencytest\nexcept ImportError:\n    concurrencytest = None\n\nimport psutil\nfrom psutil._common import hilite\nfrom psutil._common import print_color\nfrom psutil._common import term_supports_colors\nfrom psutil._compat import super\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import import_module_by_path\nfrom psutil.tests import print_sysinfo\nfrom psutil.tests import reap_children\nfrom psutil.tests import safe_rmpath\n\n\nVERBOSITY = 2\nFAILED_TESTS_FNAME = '.failed-tests.txt'\nNWORKERS = psutil.cpu_count() or 1\nUSE_COLORS = not CI_TESTING and term_supports_colors()\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nloadTestsFromTestCase = (  # noqa: N816\n    unittest.defaultTestLoader.loadTestsFromTestCase\n)\n\n\ndef cprint(msg, color, bold=False, file=None):\n    if file is None:\n        file = sys.stderr if color == 'red' else sys.stdout\n    if USE_COLORS:\n        print_color(msg, color, bold=bold, file=file)\n    else:\n        print(msg, file=file)\n\n\nclass TestLoader:\n\n    testdir = HERE\n    skip_files = ['test_memleaks.py']\n    if \"WHEELHOUSE_UPLOADER_USERNAME\" in os.environ:\n        skip_files.extend(['test_osx.py', 'test_linux.py', 'test_posix.py'])\n\n    def _get_testmods(self):\n        return [\n            os.path.join(self.testdir, x)\n            for x in os.listdir(self.testdir)\n            if x.startswith('test_')\n            and x.endswith('.py')\n            and x not in self.skip_files\n        ]\n\n    def _iter_testmod_classes(self):\n        \"\"\"Iterate over all test files in this directory and return\n        all TestCase classes in them.\n        \"\"\"\n        for path in self._get_testmods():\n            mod = import_module_by_path(path)\n            for name in dir(mod):\n                obj = getattr(mod, name)\n                if isinstance(obj, type) and issubclass(\n                    obj, unittest.TestCase\n                ):\n                    yield obj\n\n    def all(self):\n        suite = unittest.TestSuite()\n        for obj in self._iter_testmod_classes():\n            test = loadTestsFromTestCase(obj)\n            suite.addTest(test)\n        return suite\n\n    def last_failed(self):\n        # ...from previously failed test run\n        suite = unittest.TestSuite()\n        if not os.path.isfile(FAILED_TESTS_FNAME):\n            return suite\n        with open(FAILED_TESTS_FNAME) as f:\n            names = f.read().split()\n        for n in names:\n            test = unittest.defaultTestLoader.loadTestsFromName(n)\n            suite.addTest(test)\n        return suite\n\n    def from_name(self, name):\n        if name.endswith('.py'):\n            name = os.path.splitext(os.path.basename(name))[0]\n        return unittest.defaultTestLoader.loadTestsFromName(name)\n\n\nclass ColouredResult(unittest.TextTestResult):\n    def addSuccess(self, test):\n        unittest.TestResult.addSuccess(self, test)\n        cprint(\"OK\", \"green\")\n\n    def addError(self, test, err):\n        unittest.TestResult.addError(self, test, err)\n        cprint(\"ERROR\", \"red\", bold=True)\n\n    def addFailure(self, test, err):\n        unittest.TestResult.addFailure(self, test, err)\n        cprint(\"FAIL\", \"red\")\n\n    def addSkip(self, test, reason):\n        unittest.TestResult.addSkip(self, test, reason)\n        cprint(\"skipped: %s\" % reason.strip(), \"brown\")\n\n    def printErrorList(self, flavour, errors):\n        flavour = hilite(flavour, \"red\", bold=flavour == 'ERROR')\n        super().printErrorList(flavour, errors)\n\n\nclass ColouredTextRunner(unittest.TextTestRunner):\n    \"\"\"A coloured text runner which also prints failed tests on\n    KeyboardInterrupt and save failed tests in a file so that they can\n    be re-run.\n    \"\"\"\n\n    resultclass = ColouredResult if USE_COLORS else unittest.TextTestResult\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.failed_tnames = set()\n\n    def _makeResult(self):\n        # Store result instance so that it can be accessed on\n        # KeyboardInterrupt.\n        self.result = super()._makeResult()\n        return self.result\n\n    def _write_last_failed(self):\n        if self.failed_tnames:\n            with open(FAILED_TESTS_FNAME, \"w\") as f:\n                for tname in self.failed_tnames:\n                    f.write(tname + '\\n')\n\n    def _save_result(self, result):\n        if not result.wasSuccessful():\n            for t in result.errors + result.failures:\n                tname = t[0].id()\n                self.failed_tnames.add(tname)\n\n    def _run(self, suite):\n        try:\n            result = super().run(suite)\n        except (KeyboardInterrupt, SystemExit):\n            result = self.runner.result\n            result.printErrors()\n            raise sys.exit(1)\n        else:\n            self._save_result(result)\n            return result\n\n    def _exit(self, success):\n        if success:\n            cprint(\"SUCCESS\", \"green\", bold=True)\n            safe_rmpath(FAILED_TESTS_FNAME)\n            sys.exit(0)\n        else:\n            cprint(\"FAILED\", \"red\", bold=True)\n            self._write_last_failed()\n            sys.exit(1)\n\n    def run(self, suite):\n        result = self._run(suite)\n        self._exit(result.wasSuccessful())\n\n\nclass ParallelRunner(ColouredTextRunner):\n    @staticmethod\n    def _parallelize(suite):\n        def fdopen(fd, mode, *kwds):\n            stream = orig_fdopen(fd, mode)\n            atexit.register(stream.close)\n            return stream\n\n        # Monkey patch concurrencytest lib bug (fdopen() stream not closed).\n        # https://github.com/cgoldberg/concurrencytest/issues/11\n        orig_fdopen = os.fdopen\n        concurrencytest.os.fdopen = fdopen\n        forker = concurrencytest.fork_for_tests(NWORKERS)\n        return concurrencytest.ConcurrentTestSuite(suite, forker)\n\n    @staticmethod\n    def _split_suite(suite):\n        serial = unittest.TestSuite()\n        parallel = unittest.TestSuite()\n        for test in suite:\n            if test.countTestCases() == 0:\n                continue\n            if isinstance(test, unittest.TestSuite):\n                test_class = test._tests[0].__class__\n            elif isinstance(test, unittest.TestCase):\n                test_class = test\n            else:\n                raise TypeError(\"can't recognize type %r\" % test)\n\n            if getattr(test_class, '_serialrun', False):\n                serial.addTest(test)\n            else:\n                parallel.addTest(test)\n        return (serial, parallel)\n\n    def run(self, suite):\n        ser_suite, par_suite = self._split_suite(suite)\n        par_suite = self._parallelize(par_suite)\n\n        # run parallel\n        cprint(\n            \"starting parallel tests using %s workers\" % NWORKERS,\n            \"green\",\n            bold=True,\n        )\n        t = time.time()\n        par = self._run(par_suite)\n        par_elapsed = time.time() - t\n\n        # At this point we should have N zombies (the workers), which\n        # will disappear with wait().\n        orphans = psutil.Process().children()\n        _gone, alive = psutil.wait_procs(orphans, timeout=1)\n        if alive:\n            cprint(\"alive processes %s\" % alive, \"red\")\n            reap_children()\n\n        # run serial\n        t = time.time()\n        ser = self._run(ser_suite)\n        ser_elapsed = time.time() - t\n\n        # print\n        if not par.wasSuccessful() and ser_suite.countTestCases() > 0:\n            par.printErrors()  # print them again at the bottom\n        par_fails, par_errs, par_skips = map(\n            len, (par.failures, par.errors, par.skipped)\n        )\n        ser_fails, ser_errs, ser_skips = map(\n            len, (ser.failures, ser.errors, ser.skipped)\n        )\n        print(\n            textwrap.dedent(\n                \"\"\"\n            +----------+----------+----------+----------+----------+----------+\n            |          |    total | failures |   errors |  skipped |     time |\n            +----------+----------+----------+----------+----------+----------+\n            | parallel |      %3s |      %3s |      %3s |      %3s |    %.2fs |\n            +----------+----------+----------+----------+----------+----------+\n            | serial   |      %3s |      %3s |      %3s |      %3s |    %.2fs |\n            +----------+----------+----------+----------+----------+----------+\n            \"\"\"\n                % (\n                    par.testsRun,\n                    par_fails,\n                    par_errs,\n                    par_skips,\n                    par_elapsed,\n                    ser.testsRun,\n                    ser_fails,\n                    ser_errs,\n                    ser_skips,\n                    ser_elapsed,\n                )\n            )\n        )\n        print(\n            \"Ran %s tests in %.3fs using %s workers\"\n            % (\n                par.testsRun + ser.testsRun,\n                par_elapsed + ser_elapsed,\n                NWORKERS,\n            )\n        )\n        ok = par.wasSuccessful() and ser.wasSuccessful()\n        self._exit(ok)\n\n\ndef get_runner(parallel=False):\n    def warn(msg):\n        cprint(msg + \" Running serial tests instead.\", \"red\")\n\n    if parallel:\n        if psutil.WINDOWS:\n            warn(\"Can't run parallel tests on Windows.\")\n        elif concurrencytest is None:\n            warn(\"concurrencytest module is not installed.\")\n        elif NWORKERS == 1:\n            warn(\"Only 1 CPU available.\")\n        else:\n            return ParallelRunner(verbosity=VERBOSITY)\n    return ColouredTextRunner(verbosity=VERBOSITY)\n\n\n# Used by test_*,py modules.\ndef run_from_name(name):\n    if CI_TESTING:\n        print_sysinfo()\n    suite = TestLoader().from_name(name)\n    runner = get_runner()\n    runner.run(suite)\n\n\ndef setup():\n    psutil._set_debug(True)\n\n\ndef main():\n    setup()\n    usage = \"python3 -m psutil.tests [opts] [test-name]\"\n    parser = optparse.OptionParser(usage=usage, description=\"run unit tests\")\n    parser.add_option(\n        \"--last-failed\",\n        action=\"store_true\",\n        default=False,\n        help=\"only run last failed tests\",\n    )\n    parser.add_option(\n        \"--parallel\",\n        action=\"store_true\",\n        default=False,\n        help=\"run tests in parallel\",\n    )\n    opts, args = parser.parse_args()\n\n    if not opts.last_failed:\n        safe_rmpath(FAILED_TESTS_FNAME)\n\n    # loader\n    loader = TestLoader()\n    if args:\n        if len(args) > 1:\n            parser.print_usage()\n            return sys.exit(1)\n        else:\n            suite = loader.from_name(args[0])\n    elif opts.last_failed:\n        suite = loader.last_failed()\n    else:\n        suite = loader.all()\n\n    if CI_TESTING:\n        print_sysinfo()\n    runner = get_runner(opts.parallel)\n    runner.run(suite)\n\n\nif __name__ == '__main__':\n    main()\n", "psutil/tests/test_memleaks.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for detecting function memory leaks (typically the ones\nimplemented in C). It does so by calling a function many times and\nchecking whether process memory usage keeps increasing between\ncalls or over time.\nNote that this may produce false positives (especially on Windows\nfor some reason).\nPyPy appears to be completely unstable for this framework, probably\nbecause of how its JIT handles memory, so tests are skipped.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport functools\nimport os\nimport platform\nimport sys\nimport unittest\n\nimport psutil\nimport psutil._common\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._compat import ProcessLookupError\nfrom psutil._compat import super\nfrom psutil.tests import HAS_CPU_AFFINITY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_ENVIRON\nfrom psutil.tests import HAS_IONICE\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import HAS_PROC_CPU_NUM\nfrom psutil.tests import HAS_PROC_IO_COUNTERS\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import HAS_SENSORS_BATTERY\nfrom psutil.tests import HAS_SENSORS_FANS\nfrom psutil.tests import HAS_SENSORS_TEMPERATURES\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import TestMemoryLeak\nfrom psutil.tests import create_sockets\nfrom psutil.tests import get_testfn\nfrom psutil.tests import process_namespace\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import system_namespace\nfrom psutil.tests import terminate\n\n\ncext = psutil._psplatform.cext\nthisproc = psutil.Process()\nFEW_TIMES = 5\n\n\ndef fewtimes_if_linux():\n    \"\"\"Decorator for those Linux functions which are implemented in pure\n    Python, and which we want to run faster.\n    \"\"\"\n\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(self, *args, **kwargs):\n            if LINUX:\n                before = self.__class__.times\n                try:\n                    self.__class__.times = FEW_TIMES\n                    return fun(self, *args, **kwargs)\n                finally:\n                    self.__class__.times = before\n            else:\n                return fun(self, *args, **kwargs)\n\n        return wrapper\n\n    return decorator\n\n\n# ===================================================================\n# Process class\n# ===================================================================\n\n\nclass TestProcessObjectLeaks(TestMemoryLeak):\n    \"\"\"Test leaks of Process class methods.\"\"\"\n\n    proc = thisproc\n\n    def test_coverage(self):\n        ns = process_namespace(None)\n        ns.test_class_coverage(self, ns.getters + ns.setters)\n\n    @fewtimes_if_linux()\n    def test_name(self):\n        self.execute(self.proc.name)\n\n    @fewtimes_if_linux()\n    def test_cmdline(self):\n        self.execute(self.proc.cmdline)\n\n    @fewtimes_if_linux()\n    def test_exe(self):\n        self.execute(self.proc.exe)\n\n    @fewtimes_if_linux()\n    def test_ppid(self):\n        self.execute(self.proc.ppid)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_uids(self):\n        self.execute(self.proc.uids)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_gids(self):\n        self.execute(self.proc.gids)\n\n    @fewtimes_if_linux()\n    def test_status(self):\n        self.execute(self.proc.status)\n\n    def test_nice(self):\n        self.execute(self.proc.nice)\n\n    def test_nice_set(self):\n        niceness = thisproc.nice()\n        self.execute(lambda: self.proc.nice(niceness))\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    def test_ionice(self):\n        self.execute(self.proc.ionice)\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    def test_ionice_set(self):\n        if WINDOWS:\n            value = thisproc.ionice()\n            self.execute(lambda: self.proc.ionice(value))\n        else:\n            self.execute(lambda: self.proc.ionice(psutil.IOPRIO_CLASS_NONE))\n            fun = functools.partial(cext.proc_ioprio_set, os.getpid(), -1, 0)\n            self.execute_w_exc(OSError, fun)\n\n    @unittest.skipIf(not HAS_PROC_IO_COUNTERS, \"not supported\")\n    @fewtimes_if_linux()\n    def test_io_counters(self):\n        self.execute(self.proc.io_counters)\n\n    @unittest.skipIf(POSIX, \"worthless on POSIX\")\n    def test_username(self):\n        # always open 1 handle on Windows (only once)\n        psutil.Process().username()\n        self.execute(self.proc.username)\n\n    @fewtimes_if_linux()\n    def test_create_time(self):\n        self.execute(self.proc.create_time)\n\n    @fewtimes_if_linux()\n    @skip_on_access_denied(only_if=OPENBSD)\n    def test_num_threads(self):\n        self.execute(self.proc.num_threads)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_num_handles(self):\n        self.execute(self.proc.num_handles)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_num_fds(self):\n        self.execute(self.proc.num_fds)\n\n    @fewtimes_if_linux()\n    def test_num_ctx_switches(self):\n        self.execute(self.proc.num_ctx_switches)\n\n    @fewtimes_if_linux()\n    @skip_on_access_denied(only_if=OPENBSD)\n    def test_threads(self):\n        self.execute(self.proc.threads)\n\n    @fewtimes_if_linux()\n    def test_cpu_times(self):\n        self.execute(self.proc.cpu_times)\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_PROC_CPU_NUM, \"not supported\")\n    def test_cpu_num(self):\n        self.execute(self.proc.cpu_num)\n\n    @fewtimes_if_linux()\n    def test_memory_info(self):\n        self.execute(self.proc.memory_info)\n\n    @fewtimes_if_linux()\n    def test_memory_full_info(self):\n        self.execute(self.proc.memory_full_info)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @fewtimes_if_linux()\n    def test_terminal(self):\n        self.execute(self.proc.terminal)\n\n    def test_resume(self):\n        times = FEW_TIMES if POSIX else self.times\n        self.execute(self.proc.resume, times=times)\n\n    @fewtimes_if_linux()\n    def test_cwd(self):\n        self.execute(self.proc.cwd)\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, \"not supported\")\n    def test_cpu_affinity(self):\n        self.execute(self.proc.cpu_affinity)\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, \"not supported\")\n    def test_cpu_affinity_set(self):\n        affinity = thisproc.cpu_affinity()\n        self.execute(lambda: self.proc.cpu_affinity(affinity))\n        self.execute_w_exc(ValueError, lambda: self.proc.cpu_affinity([-1]))\n\n    @fewtimes_if_linux()\n    def test_open_files(self):\n        with open(get_testfn(), 'w'):\n            self.execute(self.proc.open_files)\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    @fewtimes_if_linux()\n    def test_memory_maps(self):\n        self.execute(self.proc.memory_maps)\n\n    @unittest.skipIf(not LINUX, \"LINUX only\")\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit(self):\n        self.execute(lambda: self.proc.rlimit(psutil.RLIMIT_NOFILE))\n\n    @unittest.skipIf(not LINUX, \"LINUX only\")\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_set(self):\n        limit = thisproc.rlimit(psutil.RLIMIT_NOFILE)\n        self.execute(lambda: self.proc.rlimit(psutil.RLIMIT_NOFILE, limit))\n        self.execute_w_exc((OSError, ValueError), lambda: self.proc.rlimit(-1))\n\n    @fewtimes_if_linux()\n    # Windows implementation is based on a single system-wide\n    # function (tested later).\n    @unittest.skipIf(WINDOWS, \"worthless on WINDOWS\")\n    def test_net_connections(self):\n        # TODO: UNIX sockets are temporarily implemented by parsing\n        # 'pfiles' cmd  output; we don't want that part of the code to\n        # be executed.\n        with create_sockets():\n            kind = 'inet' if SUNOS else 'all'\n            self.execute(lambda: self.proc.net_connections(kind))\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    def test_environ(self):\n        self.execute(self.proc.environ)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_proc_info(self):\n        self.execute(lambda: cext.proc_info(os.getpid()))\n\n\nclass TestTerminatedProcessLeaks(TestProcessObjectLeaks):\n    \"\"\"Repeat the tests above looking for leaks occurring when dealing\n    with terminated processes raising NoSuchProcess exception.\n    The C functions are still invoked but will follow different code\n    paths. We'll check those code paths.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.subp = spawn_testproc()\n        cls.proc = psutil.Process(cls.subp.pid)\n        cls.proc.kill()\n        cls.proc.wait()\n\n    @classmethod\n    def tearDownClass(cls):\n        super().tearDownClass()\n        terminate(cls.subp)\n\n    def call(self, fun):\n        try:\n            fun()\n        except psutil.NoSuchProcess:\n            pass\n\n    if WINDOWS:\n\n        def test_kill(self):\n            self.execute(self.proc.kill)\n\n        def test_terminate(self):\n            self.execute(self.proc.terminate)\n\n        def test_suspend(self):\n            self.execute(self.proc.suspend)\n\n        def test_resume(self):\n            self.execute(self.proc.resume)\n\n        def test_wait(self):\n            self.execute(self.proc.wait)\n\n        def test_proc_info(self):\n            # test dual implementation\n            def call():\n                try:\n                    return cext.proc_info(self.proc.pid)\n                except ProcessLookupError:\n                    pass\n\n            self.execute(call)\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass TestProcessDualImplementation(TestMemoryLeak):\n    def test_cmdline_peb_true(self):\n        self.execute(lambda: cext.proc_cmdline(os.getpid(), use_peb=True))\n\n    def test_cmdline_peb_false(self):\n        self.execute(lambda: cext.proc_cmdline(os.getpid(), use_peb=False))\n\n\n# ===================================================================\n# system APIs\n# ===================================================================\n\n\nclass TestModuleFunctionsLeaks(TestMemoryLeak):\n    \"\"\"Test leaks of psutil module functions.\"\"\"\n\n    def test_coverage(self):\n        ns = system_namespace()\n        ns.test_class_coverage(self, ns.all)\n\n    # --- cpu\n\n    @fewtimes_if_linux()\n    def test_cpu_count(self):  # logical\n        self.execute(lambda: psutil.cpu_count(logical=True))\n\n    @fewtimes_if_linux()\n    def test_cpu_count_cores(self):\n        self.execute(lambda: psutil.cpu_count(logical=False))\n\n    @fewtimes_if_linux()\n    def test_cpu_times(self):\n        self.execute(psutil.cpu_times)\n\n    @fewtimes_if_linux()\n    def test_per_cpu_times(self):\n        self.execute(lambda: psutil.cpu_times(percpu=True))\n\n    @fewtimes_if_linux()\n    def test_cpu_stats(self):\n        self.execute(psutil.cpu_stats)\n\n    @fewtimes_if_linux()\n    # TODO: remove this once 1892 is fixed\n    @unittest.skipIf(\n        MACOS and platform.machine() == 'arm64', \"skipped due to #1892\"\n    )\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_cpu_freq(self):\n        self.execute(psutil.cpu_freq)\n\n    @unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n    def test_getloadavg(self):\n        psutil.getloadavg()\n        self.execute(psutil.getloadavg)\n\n    # --- mem\n\n    def test_virtual_memory(self):\n        self.execute(psutil.virtual_memory)\n\n    # TODO: remove this skip when this gets fixed\n    @unittest.skipIf(SUNOS, \"worthless on SUNOS (uses a subprocess)\")\n    def test_swap_memory(self):\n        self.execute(psutil.swap_memory)\n\n    def test_pid_exists(self):\n        times = FEW_TIMES if POSIX else self.times\n        self.execute(lambda: psutil.pid_exists(os.getpid()), times=times)\n\n    # --- disk\n\n    def test_disk_usage(self):\n        times = FEW_TIMES if POSIX else self.times\n        self.execute(lambda: psutil.disk_usage('.'), times=times)\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    def test_disk_partitions(self):\n        self.execute(psutil.disk_partitions)\n\n    @unittest.skipIf(\n        LINUX and not os.path.exists('/proc/diskstats'),\n        '/proc/diskstats not available on this Linux version',\n    )\n    @fewtimes_if_linux()\n    def test_disk_io_counters(self):\n        self.execute(lambda: psutil.disk_io_counters(nowrap=False))\n\n    # --- proc\n\n    @fewtimes_if_linux()\n    def test_pids(self):\n        self.execute(psutil.pids)\n\n    # --- net\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, 'not supported')\n    def test_net_io_counters(self):\n        self.execute(lambda: psutil.net_io_counters(nowrap=False))\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(MACOS and os.getuid() != 0, \"need root access\")\n    def test_net_connections(self):\n        # always opens and handle on Windows() (once)\n        psutil.net_connections(kind='all')\n        with create_sockets():\n            self.execute(lambda: psutil.net_connections(kind='all'))\n\n    def test_net_if_addrs(self):\n        # Note: verified that on Windows this was a false positive.\n        tolerance = 80 * 1024 if WINDOWS else self.tolerance\n        self.execute(psutil.net_if_addrs, tolerance=tolerance)\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    def test_net_if_stats(self):\n        self.execute(psutil.net_if_stats)\n\n    # --- sensors\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_SENSORS_BATTERY, \"not supported\")\n    def test_sensors_battery(self):\n        self.execute(psutil.sensors_battery)\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_SENSORS_TEMPERATURES, \"not supported\")\n    def test_sensors_temperatures(self):\n        self.execute(psutil.sensors_temperatures)\n\n    @fewtimes_if_linux()\n    @unittest.skipIf(not HAS_SENSORS_FANS, \"not supported\")\n    def test_sensors_fans(self):\n        self.execute(psutil.sensors_fans)\n\n    # --- others\n\n    @fewtimes_if_linux()\n    def test_boot_time(self):\n        self.execute(psutil.boot_time)\n\n    def test_users(self):\n        self.execute(psutil.users)\n\n    def test_set_debug(self):\n        self.execute(lambda: psutil._set_debug(False))\n\n    if WINDOWS:\n\n        # --- win services\n\n        def test_win_service_iter(self):\n            self.execute(cext.winservice_enumerate)\n\n        def test_win_service_get(self):\n            pass\n\n        def test_win_service_get_config(self):\n            name = next(psutil.win_service_iter()).name()\n            self.execute(lambda: cext.winservice_query_config(name))\n\n        def test_win_service_get_status(self):\n            name = next(psutil.win_service_iter()).name()\n            self.execute(lambda: cext.winservice_query_status(name))\n\n        def test_win_service_get_description(self):\n            name = next(psutil.win_service_iter()).name()\n            self.execute(lambda: cext.winservice_query_descr(name))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import cprint\n    from psutil.tests.runner import run_from_name\n\n    if QEMU_USER:\n        cprint(\"skipping %s tests under QEMU_USER\" % __file__, \"brown\")\n        sys.exit(0)\n\n    run_from_name(__file__)\n", "psutil/tests/__main__.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Run unit tests. This is invoked by:\n$ python -m psutil.tests.\n\"\"\"\n\nfrom .runner import main\n\n\nmain()\n", "psutil/tests/__init__.py": "# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Test utilities.\"\"\"\n\nfrom __future__ import print_function\n\nimport atexit\nimport contextlib\nimport ctypes\nimport errno\nimport functools\nimport gc\nimport inspect\nimport os\nimport platform\nimport random\nimport re\nimport select\nimport shlex\nimport shutil\nimport signal\nimport socket\nimport stat\nimport subprocess\nimport sys\nimport tempfile\nimport textwrap\nimport threading\nimport time\nimport unittest\nimport warnings\nfrom socket import AF_INET\nfrom socket import AF_INET6\nfrom socket import SOCK_STREAM\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._common import bytes2human\nfrom psutil._common import debug\nfrom psutil._common import memoize\nfrom psutil._common import print_color\nfrom psutil._common import supports_ipv6\nfrom psutil._compat import PY3\nfrom psutil._compat import FileExistsError\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import range\nfrom psutil._compat import super\nfrom psutil._compat import unicode\nfrom psutil._compat import which\n\n\ntry:\n    from unittest import mock  # py3\nexcept ImportError:\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        import mock  # NOQA - requires \"pip install mock\"\n\nif PY3:\n    import enum\nelse:\n    enum = None\n\nif POSIX:\n    from psutil._psposix import wait_pid\n\n\n# fmt: off\n__all__ = [\n    # constants\n    'APPVEYOR', 'DEVNULL', 'GLOBAL_TIMEOUT', 'TOLERANCE_SYS_MEM', 'NO_RETRIES',\n    'PYPY', 'PYTHON_EXE', 'PYTHON_EXE_ENV', 'ROOT_DIR', 'SCRIPTS_DIR',\n    'TESTFN_PREFIX', 'UNICODE_SUFFIX', 'INVALID_UNICODE_SUFFIX',\n    'CI_TESTING', 'VALID_PROC_STATUSES', 'TOLERANCE_DISK_USAGE', 'IS_64BIT',\n    \"HAS_CPU_AFFINITY\", \"HAS_CPU_FREQ\", \"HAS_ENVIRON\", \"HAS_PROC_IO_COUNTERS\",\n    \"HAS_IONICE\", \"HAS_MEMORY_MAPS\", \"HAS_PROC_CPU_NUM\", \"HAS_RLIMIT\",\n    \"HAS_SENSORS_BATTERY\", \"HAS_BATTERY\", \"HAS_SENSORS_FANS\",\n    \"HAS_SENSORS_TEMPERATURES\", \"HAS_NET_CONNECTIONS_UNIX\", \"MACOS_11PLUS\",\n    \"MACOS_12PLUS\", \"COVERAGE\", 'AARCH64', \"QEMU_USER\",\n    # subprocesses\n    'pyrun', 'terminate', 'reap_children', 'spawn_testproc', 'spawn_zombie',\n    'spawn_children_pair',\n    # threads\n    'ThreadTask',\n    # test utils\n    'unittest', 'skip_on_access_denied', 'skip_on_not_implemented',\n    'retry_on_failure', 'TestMemoryLeak', 'PsutilTestCase',\n    'process_namespace', 'system_namespace', 'print_sysinfo',\n    'is_win_secure_system_proc',\n    # fs utils\n    'chdir', 'safe_rmpath', 'create_py_exe', 'create_c_exe', 'get_testfn',\n    # os\n    'get_winver', 'kernel_version',\n    # sync primitives\n    'call_until', 'wait_for_pid', 'wait_for_file',\n    # network\n    'check_net_address', 'filter_proc_net_connections',\n    'get_free_port', 'bind_socket', 'bind_unix_socket', 'tcp_socketpair',\n    'unix_socketpair', 'create_sockets',\n    # compat\n    'reload_module', 'import_module_by_path',\n    # others\n    'warn', 'copyload_shared_lib', 'is_namedtuple',\n]\n# fmt: on\n\n\n# ===================================================================\n# --- constants\n# ===================================================================\n\n# --- platforms\n\nPYPY = '__pypy__' in sys.builtin_module_names\n# whether we're running this test suite on a Continuous Integration service\nAPPVEYOR = 'APPVEYOR' in os.environ\nGITHUB_ACTIONS = 'GITHUB_ACTIONS' in os.environ or 'CIBUILDWHEEL' in os.environ\nCI_TESTING = APPVEYOR or GITHUB_ACTIONS\nCOVERAGE = 'COVERAGE_RUN' in os.environ\nif LINUX and GITHUB_ACTIONS:\n    with open('/proc/1/cmdline') as f:\n        QEMU_USER = \"/bin/qemu-\" in f.read()\nelse:\n    QEMU_USER = False\n# are we a 64 bit process?\nIS_64BIT = sys.maxsize > 2**32\nAARCH64 = platform.machine() == \"aarch64\"\n\n\n@memoize\ndef macos_version():\n    version_str = platform.mac_ver()[0]\n    version = tuple(map(int, version_str.split(\".\")[:2]))\n    if version == (10, 16):\n        # When built against an older macOS SDK, Python will report\n        # macOS 10.16 instead of the real version.\n        version_str = subprocess.check_output(\n            [\n                sys.executable,\n                \"-sS\",\n                \"-c\",\n                \"import platform; print(platform.mac_ver()[0])\",\n            ],\n            env={\"SYSTEM_VERSION_COMPAT\": \"0\"},\n            universal_newlines=True,\n        )\n        version = tuple(map(int, version_str.split(\".\")[:2]))\n    return version\n\n\nif MACOS:\n    MACOS_11PLUS = macos_version() > (10, 15)\n    MACOS_12PLUS = macos_version() >= (12, 0)\nelse:\n    MACOS_11PLUS = False\n    MACOS_12PLUS = False\n\n\n# --- configurable defaults\n\n# how many times retry_on_failure() decorator will retry\nNO_RETRIES = 10\n# bytes tolerance for system-wide related tests\nTOLERANCE_SYS_MEM = 5 * 1024 * 1024  # 5MB\nTOLERANCE_DISK_USAGE = 10 * 1024 * 1024  # 10MB\n# the timeout used in functions which have to wait\nGLOBAL_TIMEOUT = 5\n# be more tolerant if we're on CI in order to avoid false positives\nif CI_TESTING:\n    NO_RETRIES *= 3\n    GLOBAL_TIMEOUT *= 3\n    TOLERANCE_SYS_MEM *= 4\n    TOLERANCE_DISK_USAGE *= 3\n\n# --- file names\n\n# Disambiguate TESTFN for parallel testing.\nif os.name == 'java':\n    # Jython disallows @ in module names\n    TESTFN_PREFIX = '$psutil-%s-' % os.getpid()\nelse:\n    TESTFN_PREFIX = '@psutil-%s-' % os.getpid()\nUNICODE_SUFFIX = u\"-\u0192\u0151\u0151\"\n# An invalid unicode string.\nif PY3:\n    INVALID_UNICODE_SUFFIX = b\"f\\xc0\\x80\".decode('utf8', 'surrogateescape')\nelse:\n    INVALID_UNICODE_SUFFIX = \"f\\xc0\\x80\"\nASCII_FS = sys.getfilesystemencoding().lower() in ('ascii', 'us-ascii')\n\n# --- paths\n\nROOT_DIR = os.path.realpath(\n    os.path.join(os.path.dirname(__file__), '..', '..')\n)\nSCRIPTS_DIR = os.environ.get(\n    \"PSUTIL_SCRIPTS_DIR\", os.path.join(ROOT_DIR, 'scripts')\n)\nHERE = os.path.realpath(os.path.dirname(__file__))\n\n# --- support\n\nHAS_CPU_AFFINITY = hasattr(psutil.Process, \"cpu_affinity\")\nHAS_CPU_FREQ = hasattr(psutil, \"cpu_freq\")\nHAS_ENVIRON = hasattr(psutil.Process, \"environ\")\nHAS_GETLOADAVG = hasattr(psutil, \"getloadavg\")\nHAS_IONICE = hasattr(psutil.Process, \"ionice\")\nHAS_MEMORY_MAPS = hasattr(psutil.Process, \"memory_maps\")\nHAS_NET_CONNECTIONS_UNIX = POSIX and not SUNOS\nHAS_NET_IO_COUNTERS = hasattr(psutil, \"net_io_counters\")\nHAS_PROC_CPU_NUM = hasattr(psutil.Process, \"cpu_num\")\nHAS_PROC_IO_COUNTERS = hasattr(psutil.Process, \"io_counters\")\nHAS_RLIMIT = hasattr(psutil.Process, \"rlimit\")\nHAS_SENSORS_BATTERY = hasattr(psutil, \"sensors_battery\")\ntry:\n    HAS_BATTERY = HAS_SENSORS_BATTERY and bool(psutil.sensors_battery())\nexcept Exception:  # noqa: BLE001\n    HAS_BATTERY = False\nHAS_SENSORS_FANS = hasattr(psutil, \"sensors_fans\")\nHAS_SENSORS_TEMPERATURES = hasattr(psutil, \"sensors_temperatures\")\nHAS_THREADS = hasattr(psutil.Process, \"threads\")\nSKIP_SYSCONS = (MACOS or AIX) and os.getuid() != 0\n\n# --- misc\n\n\ndef _get_py_exe():\n    def attempt(exe):\n        try:\n            subprocess.check_call(\n                [exe, \"-V\"], stdout=subprocess.PIPE, stderr=subprocess.PIPE\n            )\n        except subprocess.CalledProcessError:\n            return None\n        else:\n            return exe\n\n    env = os.environ.copy()\n\n    # On Windows, starting with python 3.7, virtual environments use a\n    # venv launcher startup process. This does not play well when\n    # counting spawned processes, or when relying on the PID of the\n    # spawned process to do some checks, e.g. connections check per PID.\n    # Let's use the base python in this case.\n    base = getattr(sys, \"_base_executable\", None)\n    if WINDOWS and sys.version_info >= (3, 7) and base is not None:\n        # We need to set __PYVENV_LAUNCHER__ to sys.executable for the\n        # base python executable to know about the environment.\n        env[\"__PYVENV_LAUNCHER__\"] = sys.executable\n        return base, env\n    elif GITHUB_ACTIONS:\n        return sys.executable, env\n    elif MACOS:\n        exe = (\n            attempt(sys.executable)\n            or attempt(os.path.realpath(sys.executable))\n            or attempt(which(\"python%s.%s\" % sys.version_info[:2]))\n            or attempt(psutil.Process().exe())\n        )\n        if not exe:\n            raise ValueError(\"can't find python exe real abspath\")\n        return exe, env\n    else:\n        exe = os.path.realpath(sys.executable)\n        assert os.path.exists(exe), exe\n        return exe, env\n\n\nPYTHON_EXE, PYTHON_EXE_ENV = _get_py_exe()\nDEVNULL = open(os.devnull, 'r+')\natexit.register(DEVNULL.close)\n\nVALID_PROC_STATUSES = [\n    getattr(psutil, x) for x in dir(psutil) if x.startswith('STATUS_')\n]\nAF_UNIX = getattr(socket, \"AF_UNIX\", object())\n\n_subprocesses_started = set()\n_pids_started = set()\n\n\n# ===================================================================\n# --- threads\n# ===================================================================\n\n\nclass ThreadTask(threading.Thread):\n    \"\"\"A thread task which does nothing expect staying alive.\"\"\"\n\n    def __init__(self):\n        super().__init__()\n        self._running = False\n        self._interval = 0.001\n        self._flag = threading.Event()\n\n    def __repr__(self):\n        name = self.__class__.__name__\n        return '<%s running=%s at %#x>' % (name, self._running, id(self))\n\n    def __enter__(self):\n        self.start()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        self.stop()\n\n    def start(self):\n        \"\"\"Start thread and keep it running until an explicit\n        stop() request. Polls for shutdown every 'timeout' seconds.\n        \"\"\"\n        if self._running:\n            raise ValueError(\"already started\")\n        threading.Thread.start(self)\n        self._flag.wait()\n\n    def run(self):\n        self._running = True\n        self._flag.set()\n        while self._running:\n            time.sleep(self._interval)\n\n    def stop(self):\n        \"\"\"Stop thread execution and and waits until it is stopped.\"\"\"\n        if not self._running:\n            raise ValueError(\"already stopped\")\n        self._running = False\n        self.join()\n\n\n# ===================================================================\n# --- subprocesses\n# ===================================================================\n\n\ndef _reap_children_on_err(fun):\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        try:\n            return fun(*args, **kwargs)\n        except Exception:\n            reap_children()\n            raise\n\n    return wrapper\n\n\n@_reap_children_on_err\ndef spawn_testproc(cmd=None, **kwds):\n    \"\"\"Create a python subprocess which does nothing for some secs and\n    return it as a subprocess.Popen instance.\n    If \"cmd\" is specified that is used instead of python.\n    By default stdin and stdout are redirected to /dev/null.\n    It also attempts to make sure the process is in a reasonably\n    initialized state.\n    The process is registered for cleanup on reap_children().\n    \"\"\"\n    kwds.setdefault(\"stdin\", DEVNULL)\n    kwds.setdefault(\"stdout\", DEVNULL)\n    kwds.setdefault(\"cwd\", os.getcwd())\n    kwds.setdefault(\"env\", PYTHON_EXE_ENV)\n    if WINDOWS:\n        # Prevents the subprocess to open error dialogs. This will also\n        # cause stderr to be suppressed, which is suboptimal in order\n        # to debug broken tests.\n        CREATE_NO_WINDOW = 0x8000000\n        kwds.setdefault(\"creationflags\", CREATE_NO_WINDOW)\n    if cmd is None:\n        testfn = get_testfn(dir=os.getcwd())\n        try:\n            safe_rmpath(testfn)\n            pyline = (\n                \"import time;\"\n                + \"open(r'%s', 'w').close();\" % testfn\n                + \"[time.sleep(0.1) for x in range(100)];\"  # 10 secs\n            )\n            cmd = [PYTHON_EXE, \"-c\", pyline]\n            sproc = subprocess.Popen(cmd, **kwds)\n            _subprocesses_started.add(sproc)\n            wait_for_file(testfn, delete=True, empty=True)\n        finally:\n            safe_rmpath(testfn)\n    else:\n        sproc = subprocess.Popen(cmd, **kwds)\n        _subprocesses_started.add(sproc)\n        wait_for_pid(sproc.pid)\n    return sproc\n\n\n@_reap_children_on_err\ndef spawn_children_pair():\n    \"\"\"Create a subprocess which creates another one as in:\n    A (us) -> B (child) -> C (grandchild).\n    Return a (child, grandchild) tuple.\n    The 2 processes are fully initialized and will live for 60 secs\n    and are registered for cleanup on reap_children().\n    \"\"\"\n    tfile = None\n    testfn = get_testfn(dir=os.getcwd())\n    try:\n        s = textwrap.dedent(\"\"\"\\\n            import subprocess, os, sys, time\n            s = \"import os, time;\"\n            s += \"f = open('%s', 'w');\"\n            s += \"f.write(str(os.getpid()));\"\n            s += \"f.close();\"\n            s += \"[time.sleep(0.1) for x in range(100 * 6)];\"\n            p = subprocess.Popen([r'%s', '-c', s])\n            p.wait()\n            \"\"\" % (os.path.basename(testfn), PYTHON_EXE))\n        # On Windows if we create a subprocess with CREATE_NO_WINDOW flag\n        # set (which is the default) a \"conhost.exe\" extra process will be\n        # spawned as a child. We don't want that.\n        if WINDOWS:\n            subp, tfile = pyrun(s, creationflags=0)\n        else:\n            subp, tfile = pyrun(s)\n        child = psutil.Process(subp.pid)\n        grandchild_pid = int(wait_for_file(testfn, delete=True, empty=False))\n        _pids_started.add(grandchild_pid)\n        grandchild = psutil.Process(grandchild_pid)\n        return (child, grandchild)\n    finally:\n        safe_rmpath(testfn)\n        if tfile is not None:\n            safe_rmpath(tfile)\n\n\ndef spawn_zombie():\n    \"\"\"Create a zombie process and return a (parent, zombie) process tuple.\n    In order to kill the zombie parent must be terminate()d first, then\n    zombie must be wait()ed on.\n    \"\"\"\n    assert psutil.POSIX\n    unix_file = get_testfn()\n    src = textwrap.dedent(\"\"\"\\\n        import os, sys, time, socket, contextlib\n        child_pid = os.fork()\n        if child_pid > 0:\n            time.sleep(3000)\n        else:\n            # this is the zombie process\n            s = socket.socket(socket.AF_UNIX)\n            with contextlib.closing(s):\n                s.connect('%s')\n                if sys.version_info < (3, ):\n                    pid = str(os.getpid())\n                else:\n                    pid = bytes(str(os.getpid()), 'ascii')\n                s.sendall(pid)\n        \"\"\" % unix_file)\n    tfile = None\n    sock = bind_unix_socket(unix_file)\n    try:\n        sock.settimeout(GLOBAL_TIMEOUT)\n        parent, tfile = pyrun(src)\n        conn, _ = sock.accept()\n        try:\n            select.select([conn.fileno()], [], [], GLOBAL_TIMEOUT)\n            zpid = int(conn.recv(1024))\n            _pids_started.add(zpid)\n            zombie = psutil.Process(zpid)\n            call_until(zombie.status, \"ret == psutil.STATUS_ZOMBIE\")\n            return (parent, zombie)\n        finally:\n            conn.close()\n    finally:\n        sock.close()\n        safe_rmpath(unix_file)\n        if tfile is not None:\n            safe_rmpath(tfile)\n\n\n@_reap_children_on_err\ndef pyrun(src, **kwds):\n    \"\"\"Run python 'src' code string in a separate interpreter.\n    Returns a subprocess.Popen instance and the test file where the source\n    code was written.\n    \"\"\"\n    kwds.setdefault(\"stdout\", None)\n    kwds.setdefault(\"stderr\", None)\n    srcfile = get_testfn()\n    try:\n        with open(srcfile, \"w\") as f:\n            f.write(src)\n        subp = spawn_testproc([PYTHON_EXE, f.name], **kwds)\n        wait_for_pid(subp.pid)\n        return (subp, srcfile)\n    except Exception:\n        safe_rmpath(srcfile)\n        raise\n\n\n@_reap_children_on_err\ndef sh(cmd, **kwds):\n    \"\"\"Run cmd in a subprocess and return its output.\n    raises RuntimeError on error.\n    \"\"\"\n    # Prevents subprocess to open error dialogs in case of error.\n    flags = 0x8000000 if WINDOWS else 0\n    kwds.setdefault(\"stdout\", subprocess.PIPE)\n    kwds.setdefault(\"stderr\", subprocess.PIPE)\n    kwds.setdefault(\"universal_newlines\", True)\n    kwds.setdefault(\"creationflags\", flags)\n    if isinstance(cmd, str):\n        cmd = shlex.split(cmd)\n    p = subprocess.Popen(cmd, **kwds)\n    _subprocesses_started.add(p)\n    if PY3:\n        stdout, stderr = p.communicate(timeout=GLOBAL_TIMEOUT)\n    else:\n        stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    if stderr:\n        warn(stderr)\n    if stdout.endswith('\\n'):\n        stdout = stdout[:-1]\n    return stdout\n\n\ndef terminate(proc_or_pid, sig=signal.SIGTERM, wait_timeout=GLOBAL_TIMEOUT):\n    \"\"\"Terminate a process and wait() for it.\n    Process can be a PID or an instance of psutil.Process(),\n    subprocess.Popen() or psutil.Popen().\n    If it's a subprocess.Popen() or psutil.Popen() instance also closes\n    its stdin / stdout / stderr fds.\n    PID is wait()ed even if the process is already gone (kills zombies).\n    Does nothing if the process does not exist.\n    Return process exit status.\n    \"\"\"\n\n    def wait(proc, timeout):\n        if isinstance(proc, subprocess.Popen) and not PY3:\n            proc.wait()\n        else:\n            proc.wait(timeout)\n        if WINDOWS and isinstance(proc, subprocess.Popen):\n            # Otherwise PID may still hang around.\n            try:\n                return psutil.Process(proc.pid).wait(timeout)\n            except psutil.NoSuchProcess:\n                pass\n\n    def sendsig(proc, sig):\n        # XXX: otherwise the build hangs for some reason.\n        if MACOS and GITHUB_ACTIONS:\n            sig = signal.SIGKILL\n        # If the process received SIGSTOP, SIGCONT is necessary first,\n        # otherwise SIGTERM won't work.\n        if POSIX and sig != signal.SIGKILL:\n            proc.send_signal(signal.SIGCONT)\n        proc.send_signal(sig)\n\n    def term_subprocess_proc(proc, timeout):\n        try:\n            sendsig(proc, sig)\n        except OSError as err:\n            if WINDOWS and err.winerror == 6:  # \"invalid handle\"\n                pass\n            elif err.errno != errno.ESRCH:\n                raise\n        return wait(proc, timeout)\n\n    def term_psutil_proc(proc, timeout):\n        try:\n            sendsig(proc, sig)\n        except psutil.NoSuchProcess:\n            pass\n        return wait(proc, timeout)\n\n    def term_pid(pid, timeout):\n        try:\n            proc = psutil.Process(pid)\n        except psutil.NoSuchProcess:\n            # Needed to kill zombies.\n            if POSIX:\n                return wait_pid(pid, timeout)\n        else:\n            return term_psutil_proc(proc, timeout)\n\n    def flush_popen(proc):\n        if proc.stdout:\n            proc.stdout.close()\n        if proc.stderr:\n            proc.stderr.close()\n        # Flushing a BufferedWriter may raise an error.\n        if proc.stdin:\n            proc.stdin.close()\n\n    p = proc_or_pid\n    try:\n        if isinstance(p, int):\n            return term_pid(p, wait_timeout)\n        elif isinstance(p, (psutil.Process, psutil.Popen)):\n            return term_psutil_proc(p, wait_timeout)\n        elif isinstance(p, subprocess.Popen):\n            return term_subprocess_proc(p, wait_timeout)\n        else:\n            raise TypeError(\"wrong type %r\" % p)\n    finally:\n        if isinstance(p, (subprocess.Popen, psutil.Popen)):\n            flush_popen(p)\n        pid = p if isinstance(p, int) else p.pid\n        assert not psutil.pid_exists(pid), pid\n\n\ndef reap_children(recursive=False):\n    \"\"\"Terminate and wait() any subprocess started by this test suite\n    and any children currently running, ensuring that no processes stick\n    around to hog resources.\n    If recursive is True it also tries to terminate and wait()\n    all grandchildren started by this process.\n    \"\"\"\n    # Get the children here before terminating them, as in case of\n    # recursive=True we don't want to lose the intermediate reference\n    # pointing to the grandchildren.\n    children = psutil.Process().children(recursive=recursive)\n\n    # Terminate subprocess.Popen.\n    while _subprocesses_started:\n        subp = _subprocesses_started.pop()\n        terminate(subp)\n\n    # Collect started pids.\n    while _pids_started:\n        pid = _pids_started.pop()\n        terminate(pid)\n\n    # Terminate children.\n    if children:\n        for p in children:\n            terminate(p, wait_timeout=None)\n        _, alive = psutil.wait_procs(children, timeout=GLOBAL_TIMEOUT)\n        for p in alive:\n            warn(\"couldn't terminate process %r; attempting kill()\" % p)\n            terminate(p, sig=signal.SIGKILL)\n\n\n# ===================================================================\n# --- OS\n# ===================================================================\n\n\ndef kernel_version():\n    \"\"\"Return a tuple such as (2, 6, 36).\"\"\"\n    if not POSIX:\n        raise NotImplementedError(\"not POSIX\")\n    s = \"\"\n    uname = os.uname()[2]\n    for c in uname:\n        if c.isdigit() or c == '.':\n            s += c\n        else:\n            break\n    if not s:\n        raise ValueError(\"can't parse %r\" % uname)\n    minor = 0\n    micro = 0\n    nums = s.split('.')\n    major = int(nums[0])\n    if len(nums) >= 2:\n        minor = int(nums[1])\n    if len(nums) >= 3:\n        micro = int(nums[2])\n    return (major, minor, micro)\n\n\ndef get_winver():\n    if not WINDOWS:\n        raise NotImplementedError(\"not WINDOWS\")\n    wv = sys.getwindowsversion()\n    if hasattr(wv, 'service_pack_major'):  # python >= 2.7\n        sp = wv.service_pack_major or 0\n    else:\n        r = re.search(r\"\\s\\d$\", wv[4])\n        sp = int(r.group(0)) if r else 0\n    return (wv[0], wv[1], sp)\n\n\n# ===================================================================\n# --- sync primitives\n# ===================================================================\n\n\nclass retry:\n    \"\"\"A retry decorator.\"\"\"\n\n    def __init__(\n        self,\n        exception=Exception,\n        timeout=None,\n        retries=None,\n        interval=0.001,\n        logfun=None,\n    ):\n        if timeout and retries:\n            raise ValueError(\"timeout and retries args are mutually exclusive\")\n        self.exception = exception\n        self.timeout = timeout\n        self.retries = retries\n        self.interval = interval\n        self.logfun = logfun\n\n    def __iter__(self):\n        if self.timeout:\n            stop_at = time.time() + self.timeout\n            while time.time() < stop_at:\n                yield\n        elif self.retries:\n            for _ in range(self.retries):\n                yield\n        else:\n            while True:\n                yield\n\n    def sleep(self):\n        if self.interval is not None:\n            time.sleep(self.interval)\n\n    def __call__(self, fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            exc = None\n            for _ in self:\n                try:\n                    return fun(*args, **kwargs)\n                except self.exception as _:  # NOQA\n                    exc = _\n                    if self.logfun is not None:\n                        self.logfun(exc)\n                    self.sleep()\n                    continue\n            if PY3:\n                raise exc  # noqa: PLE0704\n            else:\n                raise  # noqa: PLE0704\n\n        # This way the user of the decorated function can change config\n        # parameters.\n        wrapper.decorator = self\n        return wrapper\n\n\n@retry(\n    exception=psutil.NoSuchProcess,\n    logfun=None,\n    timeout=GLOBAL_TIMEOUT,\n    interval=0.001,\n)\ndef wait_for_pid(pid):\n    \"\"\"Wait for pid to show up in the process list then return.\n    Used in the test suite to give time the sub process to initialize.\n    \"\"\"\n    if pid not in psutil.pids():\n        raise psutil.NoSuchProcess(pid)\n    psutil.Process(pid)\n\n\n@retry(\n    exception=(FileNotFoundError, AssertionError),\n    logfun=None,\n    timeout=GLOBAL_TIMEOUT,\n    interval=0.001,\n)\ndef wait_for_file(fname, delete=True, empty=False):\n    \"\"\"Wait for a file to be written on disk with some content.\"\"\"\n    with open(fname, \"rb\") as f:\n        data = f.read()\n    if not empty:\n        assert data\n    if delete:\n        safe_rmpath(fname)\n    return data\n\n\n@retry(\n    exception=AssertionError,\n    logfun=None,\n    timeout=GLOBAL_TIMEOUT,\n    interval=0.001,\n)\ndef call_until(fun, expr):\n    \"\"\"Keep calling function for timeout secs and exit if eval()\n    expression is True.\n    \"\"\"\n    ret = fun()\n    assert eval(expr)  # noqa\n    return ret\n\n\n# ===================================================================\n# --- fs\n# ===================================================================\n\n\ndef safe_rmpath(path):\n    \"\"\"Convenience function for removing temporary test files or dirs.\"\"\"\n\n    def retry_fun(fun):\n        # On Windows it could happen that the file or directory has\n        # open handles or references preventing the delete operation\n        # to succeed immediately, so we retry for a while. See:\n        # https://bugs.python.org/issue33240\n        stop_at = time.time() + GLOBAL_TIMEOUT\n        while time.time() < stop_at:\n            try:\n                return fun()\n            except FileNotFoundError:\n                pass\n            except WindowsError as _:\n                err = _\n                warn(\"ignoring %s\" % (str(err)))\n            time.sleep(0.01)\n        raise err\n\n    try:\n        st = os.stat(path)\n        if stat.S_ISDIR(st.st_mode):\n            fun = functools.partial(shutil.rmtree, path)\n        else:\n            fun = functools.partial(os.remove, path)\n        if POSIX:\n            fun()\n        else:\n            retry_fun(fun)\n    except FileNotFoundError:\n        pass\n\n\ndef safe_mkdir(dir):\n    \"\"\"Convenience function for creating a directory.\"\"\"\n    try:\n        os.mkdir(dir)\n    except FileExistsError:\n        pass\n\n\n@contextlib.contextmanager\ndef chdir(dirname):\n    \"\"\"Context manager which temporarily changes the current directory.\"\"\"\n    curdir = os.getcwd()\n    try:\n        os.chdir(dirname)\n        yield\n    finally:\n        os.chdir(curdir)\n\n\ndef create_py_exe(path):\n    \"\"\"Create a Python executable file in the given location.\"\"\"\n    assert not os.path.exists(path), path\n    atexit.register(safe_rmpath, path)\n    shutil.copyfile(PYTHON_EXE, path)\n    if POSIX:\n        st = os.stat(path)\n        os.chmod(path, st.st_mode | stat.S_IEXEC)\n    return path\n\n\ndef create_c_exe(path, c_code=None):\n    \"\"\"Create a compiled C executable in the given location.\"\"\"\n    assert not os.path.exists(path), path\n    if not which(\"gcc\"):\n        raise unittest.SkipTest(\"gcc is not installed\")\n    if c_code is None:\n        c_code = textwrap.dedent(\"\"\"\n            #include <unistd.h>\n            int main() {\n                pause();\n                return 1;\n            }\n            \"\"\")\n    else:\n        assert isinstance(c_code, str), c_code\n\n    atexit.register(safe_rmpath, path)\n    with open(get_testfn(suffix='.c'), \"w\") as f:\n        f.write(c_code)\n    try:\n        subprocess.check_call([\"gcc\", f.name, \"-o\", path])\n    finally:\n        safe_rmpath(f.name)\n    return path\n\n\ndef get_testfn(suffix=\"\", dir=None):\n    \"\"\"Return an absolute pathname of a file or dir that did not\n    exist at the time this call is made. Also schedule it for safe\n    deletion at interpreter exit. It's technically racy but probably\n    not really due to the time variant.\n    \"\"\"\n    while True:\n        name = tempfile.mktemp(prefix=TESTFN_PREFIX, suffix=suffix, dir=dir)\n        if not os.path.exists(name):  # also include dirs\n            path = os.path.realpath(name)  # needed for OSX\n            atexit.register(safe_rmpath, path)\n            return path\n\n\n# ===================================================================\n# --- testing\n# ===================================================================\n\n\nclass TestCase(unittest.TestCase):\n\n    # Print a full path representation of the single unit tests\n    # being run.\n    def __str__(self):\n        fqmod = self.__class__.__module__\n        if not fqmod.startswith('psutil.'):\n            fqmod = 'psutil.tests.' + fqmod\n        return \"%s.%s.%s\" % (\n            fqmod,\n            self.__class__.__name__,\n            self._testMethodName,\n        )\n\n    # assertRaisesRegexp renamed to assertRaisesRegex in 3.3;\n    # add support for the new name.\n    if not hasattr(unittest.TestCase, 'assertRaisesRegex'):\n        assertRaisesRegex = unittest.TestCase.assertRaisesRegexp  # noqa\n\n    # ...otherwise multiprocessing.Pool complains\n    if not PY3:\n\n        def runTest(self):\n            pass\n\n        @contextlib.contextmanager\n        def subTest(self, *args, **kw):\n            # fake it for python 2.7\n            yield\n\n\n# monkey patch default unittest.TestCase\nunittest.TestCase = TestCase\n\n\nclass PsutilTestCase(TestCase):\n    \"\"\"Test class providing auto-cleanup wrappers on top of process\n    test utilities.\n    \"\"\"\n\n    def get_testfn(self, suffix=\"\", dir=None):\n        fname = get_testfn(suffix=suffix, dir=dir)\n        self.addCleanup(safe_rmpath, fname)\n        return fname\n\n    def spawn_testproc(self, *args, **kwds):\n        sproc = spawn_testproc(*args, **kwds)\n        self.addCleanup(terminate, sproc)\n        return sproc\n\n    def spawn_children_pair(self):\n        child1, child2 = spawn_children_pair()\n        self.addCleanup(terminate, child2)\n        self.addCleanup(terminate, child1)  # executed first\n        return (child1, child2)\n\n    def spawn_zombie(self):\n        parent, zombie = spawn_zombie()\n        self.addCleanup(terminate, zombie)\n        self.addCleanup(terminate, parent)  # executed first\n        return (parent, zombie)\n\n    def pyrun(self, *args, **kwds):\n        sproc, srcfile = pyrun(*args, **kwds)\n        self.addCleanup(safe_rmpath, srcfile)\n        self.addCleanup(terminate, sproc)  # executed first\n        return sproc\n\n    def _check_proc_exc(self, proc, exc):\n        self.assertIsInstance(exc, psutil.Error)\n        self.assertEqual(exc.pid, proc.pid)\n        self.assertEqual(exc.name, proc._name)\n        if exc.name:\n            self.assertNotEqual(exc.name, \"\")\n        if isinstance(exc, psutil.ZombieProcess):\n            self.assertEqual(exc.ppid, proc._ppid)\n            if exc.ppid is not None:\n                self.assertGreaterEqual(exc.ppid, 0)\n        str(exc)\n        repr(exc)\n\n    def assertPidGone(self, pid):\n        with self.assertRaises(psutil.NoSuchProcess) as cm:\n            try:\n                psutil.Process(pid)\n            except psutil.ZombieProcess:\n                raise AssertionError(\"wasn't supposed to raise ZombieProcess\")\n        self.assertEqual(cm.exception.pid, pid)\n        self.assertEqual(cm.exception.name, None)\n        assert not psutil.pid_exists(pid), pid\n        self.assertNotIn(pid, psutil.pids())\n        self.assertNotIn(pid, [x.pid for x in psutil.process_iter()])\n\n    def assertProcessGone(self, proc):\n        self.assertPidGone(proc.pid)\n        ns = process_namespace(proc)\n        for fun, name in ns.iter(ns.all, clear_cache=True):\n            with self.subTest(proc=proc, name=name):\n                try:\n                    ret = fun()\n                except psutil.ZombieProcess:\n                    raise\n                except psutil.NoSuchProcess as exc:\n                    self._check_proc_exc(proc, exc)\n                else:\n                    msg = \"Process.%s() didn't raise NSP and returned %r\" % (\n                        name,\n                        ret,\n                    )\n                    raise AssertionError(msg)\n        proc.wait(timeout=0)  # assert not raise TimeoutExpired\n\n    def assertProcessZombie(self, proc):\n        # A zombie process should always be instantiable.\n        clone = psutil.Process(proc.pid)\n        # Cloned zombie on Open/NetBSD has null creation time, see:\n        # https://github.com/giampaolo/psutil/issues/2287\n        self.assertEqual(proc, clone)\n        if not (OPENBSD or NETBSD):\n            self.assertEqual(hash(proc), hash(clone))\n        # Its status always be querable.\n        self.assertEqual(proc.status(), psutil.STATUS_ZOMBIE)\n        # It should be considered 'running'.\n        assert proc.is_running()\n        assert psutil.pid_exists(proc.pid)\n        # as_dict() shouldn't crash.\n        proc.as_dict()\n        # It should show up in pids() and process_iter().\n        self.assertIn(proc.pid, psutil.pids())\n        self.assertIn(proc.pid, [x.pid for x in psutil.process_iter()])\n        psutil._pmap = {}\n        self.assertIn(proc.pid, [x.pid for x in psutil.process_iter()])\n        # Call all methods.\n        ns = process_namespace(proc)\n        for fun, name in ns.iter(ns.all, clear_cache=True):\n            with self.subTest(proc=proc, name=name):\n                try:\n                    fun()\n                except (psutil.ZombieProcess, psutil.AccessDenied) as exc:\n                    self._check_proc_exc(proc, exc)\n        if LINUX:\n            # https://github.com/giampaolo/psutil/pull/2288\n            with self.assertRaises(psutil.ZombieProcess) as cm:\n                proc.cmdline()\n            self._check_proc_exc(proc, cm.exception)\n            with self.assertRaises(psutil.ZombieProcess) as cm:\n                proc.exe()\n            self._check_proc_exc(proc, cm.exception)\n            with self.assertRaises(psutil.ZombieProcess) as cm:\n                proc.memory_maps()\n            self._check_proc_exc(proc, cm.exception)\n        # Zombie cannot be signaled or terminated.\n        proc.suspend()\n        proc.resume()\n        proc.terminate()\n        proc.kill()\n        assert proc.is_running()\n        assert psutil.pid_exists(proc.pid)\n        self.assertIn(proc.pid, psutil.pids())\n        self.assertIn(proc.pid, [x.pid for x in psutil.process_iter()])\n        psutil._pmap = {}\n        self.assertIn(proc.pid, [x.pid for x in psutil.process_iter()])\n\n        # Its parent should 'see' it (edit: not true on BSD and MACOS).\n        # descendants = [x.pid for x in psutil.Process().children(\n        #                recursive=True)]\n        # self.assertIn(proc.pid, descendants)\n\n        # __eq__ can't be relied upon because creation time may not be\n        # querable.\n        # self.assertEqual(proc, psutil.Process(proc.pid))\n\n        # XXX should we also assume ppid() to be usable? Note: this\n        # would be an important use case as the only way to get\n        # rid of a zombie is to kill its parent.\n        # self.assertEqual(proc.ppid(), os.getpid())\n\n\n@unittest.skipIf(PYPY, \"unreliable on PYPY\")\nclass TestMemoryLeak(PsutilTestCase):\n    \"\"\"Test framework class for detecting function memory leaks,\n    typically functions implemented in C which forgot to free() memory\n    from the heap. It does so by checking whether the process memory\n    usage increased before and after calling the function many times.\n\n    Note that this is hard (probably impossible) to do reliably, due\n    to how the OS handles memory, the GC and so on (memory can even\n    decrease!). In order to avoid false positives, in case of failure\n    (mem > 0) we retry the test for up to 5 times, increasing call\n    repetitions each time. If the memory keeps increasing then it's a\n    failure.\n\n    If available (Linux, OSX, Windows), USS memory is used for comparison,\n    since it's supposed to be more precise, see:\n    https://gmpy.dev/blog/2016/real-process-memory-and-environ-in-python\n    If not, RSS memory is used. mallinfo() on Linux and _heapwalk() on\n    Windows may give even more precision, but at the moment are not\n    implemented.\n\n    PyPy appears to be completely unstable for this framework, probably\n    because of its JIT, so tests on PYPY are skipped.\n\n    Usage:\n\n        class TestLeaks(psutil.tests.TestMemoryLeak):\n\n            def test_fun(self):\n                self.execute(some_function)\n    \"\"\"\n\n    # Configurable class attrs.\n    times = 200\n    warmup_times = 10\n    tolerance = 0  # memory\n    retries = 10 if CI_TESTING else 5\n    verbose = True\n    _thisproc = psutil.Process()\n    _psutil_debug_orig = bool(os.getenv('PSUTIL_DEBUG'))\n\n    @classmethod\n    def setUpClass(cls):\n        psutil._set_debug(False)  # avoid spamming to stderr\n\n    @classmethod\n    def tearDownClass(cls):\n        psutil._set_debug(cls._psutil_debug_orig)\n\n    def _get_mem(self):\n        # USS is the closest thing we have to \"real\" memory usage and it\n        # should be less likely to produce false positives.\n        mem = self._thisproc.memory_full_info()\n        return getattr(mem, \"uss\", mem.rss)\n\n    def _get_num_fds(self):\n        if POSIX:\n            return self._thisproc.num_fds()\n        else:\n            return self._thisproc.num_handles()\n\n    def _log(self, msg):\n        if self.verbose:\n            print_color(msg, color=\"yellow\", file=sys.stderr)\n\n    def _check_fds(self, fun):\n        \"\"\"Makes sure num_fds() (POSIX) or num_handles() (Windows) does\n        not increase after calling a function.  Used to discover forgotten\n        close(2) and CloseHandle syscalls.\n        \"\"\"\n        before = self._get_num_fds()\n        self.call(fun)\n        after = self._get_num_fds()\n        diff = after - before\n        if diff < 0:\n            raise self.fail(\n                \"negative diff %r (gc probably collected a \"\n                \"resource from a previous test)\" % diff\n            )\n        if diff > 0:\n            type_ = \"fd\" if POSIX else \"handle\"\n            if diff > 1:\n                type_ += \"s\"\n            msg = \"%s unclosed %s after calling %r\" % (diff, type_, fun)\n            raise self.fail(msg)\n\n    def _call_ntimes(self, fun, times):\n        \"\"\"Get 2 distinct memory samples, before and after having\n        called fun repeatedly, and return the memory difference.\n        \"\"\"\n        gc.collect(generation=1)\n        mem1 = self._get_mem()\n        for x in range(times):\n            ret = self.call(fun)\n            del x, ret\n        gc.collect(generation=1)\n        mem2 = self._get_mem()\n        self.assertEqual(gc.garbage, [])\n        diff = mem2 - mem1  # can also be negative\n        return diff\n\n    def _check_mem(self, fun, times, retries, tolerance):\n        messages = []\n        prev_mem = 0\n        increase = times\n        for idx in range(1, retries + 1):\n            mem = self._call_ntimes(fun, times)\n            msg = \"Run #%s: extra-mem=%s, per-call=%s, calls=%s\" % (\n                idx,\n                bytes2human(mem),\n                bytes2human(mem / times),\n                times,\n            )\n            messages.append(msg)\n            success = mem <= tolerance or mem <= prev_mem\n            if success:\n                if idx > 1:\n                    self._log(msg)\n                return\n            else:\n                if idx == 1:\n                    print()  # NOQA\n                self._log(msg)\n                times += increase\n                prev_mem = mem\n        raise self.fail(\". \".join(messages))\n\n    # ---\n\n    def call(self, fun):\n        return fun()\n\n    def execute(\n        self, fun, times=None, warmup_times=None, retries=None, tolerance=None\n    ):\n        \"\"\"Test a callable.\"\"\"\n        times = times if times is not None else self.times\n        warmup_times = (\n            warmup_times if warmup_times is not None else self.warmup_times\n        )\n        retries = retries if retries is not None else self.retries\n        tolerance = tolerance if tolerance is not None else self.tolerance\n        try:\n            assert times >= 1, \"times must be >= 1\"\n            assert warmup_times >= 0, \"warmup_times must be >= 0\"\n            assert retries >= 0, \"retries must be >= 0\"\n            assert tolerance >= 0, \"tolerance must be >= 0\"\n        except AssertionError as err:\n            raise ValueError(str(err))\n\n        self._call_ntimes(fun, warmup_times)  # warm up\n        self._check_fds(fun)\n        self._check_mem(fun, times=times, retries=retries, tolerance=tolerance)\n\n    def execute_w_exc(self, exc, fun, **kwargs):\n        \"\"\"Convenience method to test a callable while making sure it\n        raises an exception on every call.\n        \"\"\"\n\n        def call():\n            self.assertRaises(exc, fun)\n\n        self.execute(call, **kwargs)\n\n\ndef print_sysinfo():\n    import collections\n    import datetime\n    import getpass\n    import locale\n    import pprint\n\n    try:\n        import pip\n    except ImportError:\n        pip = None\n    try:\n        import wheel\n    except ImportError:\n        wheel = None\n\n    info = collections.OrderedDict()\n\n    # OS\n    if psutil.LINUX and which('lsb_release'):\n        info['OS'] = sh('lsb_release -d -s')\n    elif psutil.OSX:\n        info['OS'] = 'Darwin %s' % platform.mac_ver()[0]\n    elif psutil.WINDOWS:\n        info['OS'] = \"Windows \" + ' '.join(map(str, platform.win32_ver()))\n        if hasattr(platform, 'win32_edition'):\n            info['OS'] += \", \" + platform.win32_edition()\n    else:\n        info['OS'] = \"%s %s\" % (platform.system(), platform.version())\n    info['arch'] = ', '.join(\n        list(platform.architecture()) + [platform.machine()]\n    )\n    if psutil.POSIX:\n        info['kernel'] = platform.uname()[2]\n\n    # python\n    info['python'] = ', '.join([\n        platform.python_implementation(),\n        platform.python_version(),\n        platform.python_compiler(),\n    ])\n    info['pip'] = getattr(pip, '__version__', 'not installed')\n    if wheel is not None:\n        info['pip'] += \" (wheel=%s)\" % wheel.__version__\n\n    # UNIX\n    if psutil.POSIX:\n        if which('gcc'):\n            out = sh(['gcc', '--version'])\n            info['gcc'] = str(out).split('\\n')[0]\n        else:\n            info['gcc'] = 'not installed'\n        s = platform.libc_ver()[1]\n        if s:\n            info['glibc'] = s\n\n    # system\n    info['fs-encoding'] = sys.getfilesystemencoding()\n    lang = locale.getlocale()\n    info['lang'] = '%s, %s' % (lang[0], lang[1])\n    info['boot-time'] = datetime.datetime.fromtimestamp(\n        psutil.boot_time()\n    ).strftime(\"%Y-%m-%d %H:%M:%S\")\n    info['time'] = datetime.datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    info['user'] = getpass.getuser()\n    info['home'] = os.path.expanduser(\"~\")\n    info['cwd'] = os.getcwd()\n    info['pyexe'] = PYTHON_EXE\n    info['hostname'] = platform.node()\n    info['PID'] = os.getpid()\n\n    # metrics\n    info['cpus'] = psutil.cpu_count()\n    info['loadavg'] = \"%.1f%%, %.1f%%, %.1f%%\" % (\n        tuple([x / psutil.cpu_count() * 100 for x in psutil.getloadavg()])\n    )\n    mem = psutil.virtual_memory()\n    info['memory'] = \"%s%%, used=%s, total=%s\" % (\n        int(mem.percent),\n        bytes2human(mem.used),\n        bytes2human(mem.total),\n    )\n    swap = psutil.swap_memory()\n    info['swap'] = \"%s%%, used=%s, total=%s\" % (\n        int(swap.percent),\n        bytes2human(swap.used),\n        bytes2human(swap.total),\n    )\n    info['pids'] = len(psutil.pids())\n    pinfo = psutil.Process().as_dict()\n    pinfo.pop('memory_maps', None)\n    info['proc'] = pprint.pformat(pinfo)\n\n    print(\"=\" * 70, file=sys.stderr)  # NOQA\n    for k, v in info.items():\n        print(\"%-17s %s\" % (k + ':', v), file=sys.stderr)  # NOQA\n    print(\"=\" * 70, file=sys.stderr)  # NOQA\n    sys.stdout.flush()\n\n    if WINDOWS:\n        os.system(\"tasklist\")\n    elif which(\"ps\"):\n        os.system(\"ps aux\")\n    print(\"=\" * 70, file=sys.stderr)  # NOQA\n    sys.stdout.flush()\n\n\ndef is_win_secure_system_proc(pid):\n    # see: https://github.com/giampaolo/psutil/issues/2338\n    @memoize\n    def get_procs():\n        ret = {}\n        out = sh(\"tasklist.exe /NH /FO csv\")\n        for line in out.splitlines()[1:]:\n            bits = [x.replace('\"', \"\") for x in line.split(\",\")]\n            name, pid = bits[0], int(bits[1])\n            ret[pid] = name\n        return ret\n\n    try:\n        return get_procs()[pid] == \"Secure System\"\n    except KeyError:\n        return False\n\n\ndef _get_eligible_cpu():\n    p = psutil.Process()\n    if hasattr(p, \"cpu_num\"):\n        return p.cpu_num()\n    elif hasattr(p, \"cpu_affinity\"):\n        return random.choice(p.cpu_affinity())\n    return 0\n\n\nclass process_namespace:\n    \"\"\"A container that lists all Process class method names + some\n    reasonable parameters to be called with. Utility methods (parent(),\n    children(), ...) are excluded.\n\n    >>> ns = process_namespace(psutil.Process())\n    >>> for fun, name in ns.iter(ns.getters):\n    ...    fun()\n    \"\"\"\n\n    utils = [('cpu_percent', (), {}), ('memory_percent', (), {})]\n\n    ignored = [\n        ('as_dict', (), {}),\n        ('children', (), {'recursive': True}),\n        ('connections', (), {}),  # deprecated\n        ('is_running', (), {}),\n        ('memory_info_ex', (), {}),  # deprecated\n        ('oneshot', (), {}),\n        ('parent', (), {}),\n        ('parents', (), {}),\n        ('pid', (), {}),\n        ('wait', (0,), {}),\n    ]\n\n    getters = [\n        ('cmdline', (), {}),\n        ('cpu_times', (), {}),\n        ('create_time', (), {}),\n        ('cwd', (), {}),\n        ('exe', (), {}),\n        ('memory_full_info', (), {}),\n        ('memory_info', (), {}),\n        ('name', (), {}),\n        ('net_connections', (), {'kind': 'all'}),\n        ('nice', (), {}),\n        ('num_ctx_switches', (), {}),\n        ('num_threads', (), {}),\n        ('open_files', (), {}),\n        ('ppid', (), {}),\n        ('status', (), {}),\n        ('threads', (), {}),\n        ('username', (), {}),\n    ]\n    if POSIX:\n        getters += [('uids', (), {})]\n        getters += [('gids', (), {})]\n        getters += [('terminal', (), {})]\n        getters += [('num_fds', (), {})]\n    if HAS_PROC_IO_COUNTERS:\n        getters += [('io_counters', (), {})]\n    if HAS_IONICE:\n        getters += [('ionice', (), {})]\n    if HAS_RLIMIT:\n        getters += [('rlimit', (psutil.RLIMIT_NOFILE,), {})]\n    if HAS_CPU_AFFINITY:\n        getters += [('cpu_affinity', (), {})]\n    if HAS_PROC_CPU_NUM:\n        getters += [('cpu_num', (), {})]\n    if HAS_ENVIRON:\n        getters += [('environ', (), {})]\n    if WINDOWS:\n        getters += [('num_handles', (), {})]\n    if HAS_MEMORY_MAPS:\n        getters += [('memory_maps', (), {'grouped': False})]\n\n    setters = []\n    if POSIX:\n        setters += [('nice', (0,), {})]\n    else:\n        setters += [('nice', (psutil.NORMAL_PRIORITY_CLASS,), {})]\n    if HAS_RLIMIT:\n        setters += [('rlimit', (psutil.RLIMIT_NOFILE, (1024, 4096)), {})]\n    if HAS_IONICE:\n        if LINUX:\n            setters += [('ionice', (psutil.IOPRIO_CLASS_NONE, 0), {})]\n        else:\n            setters += [('ionice', (psutil.IOPRIO_NORMAL,), {})]\n    if HAS_CPU_AFFINITY:\n        setters += [('cpu_affinity', ([_get_eligible_cpu()],), {})]\n\n    killers = [\n        ('send_signal', (signal.SIGTERM,), {}),\n        ('suspend', (), {}),\n        ('resume', (), {}),\n        ('terminate', (), {}),\n        ('kill', (), {}),\n    ]\n    if WINDOWS:\n        killers += [('send_signal', (signal.CTRL_C_EVENT,), {})]\n        killers += [('send_signal', (signal.CTRL_BREAK_EVENT,), {})]\n\n    all = utils + getters + setters + killers\n\n    def __init__(self, proc):\n        self._proc = proc\n\n    def iter(self, ls, clear_cache=True):\n        \"\"\"Given a list of tuples yields a set of (fun, fun_name) tuples\n        in random order.\n        \"\"\"\n        ls = list(ls)\n        random.shuffle(ls)\n        for fun_name, args, kwds in ls:\n            if clear_cache:\n                self.clear_cache()\n            fun = getattr(self._proc, fun_name)\n            fun = functools.partial(fun, *args, **kwds)\n            yield (fun, fun_name)\n\n    def clear_cache(self):\n        \"\"\"Clear the cache of a Process instance.\"\"\"\n        self._proc._init(self._proc.pid, _ignore_nsp=True)\n\n    @classmethod\n    def test_class_coverage(cls, test_class, ls):\n        \"\"\"Given a TestCase instance and a list of tuples checks that\n        the class defines the required test method names.\n        \"\"\"\n        for fun_name, _, _ in ls:\n            meth_name = 'test_' + fun_name\n            if not hasattr(test_class, meth_name):\n                msg = \"%r class should define a '%s' method\" % (\n                    test_class.__class__.__name__,\n                    meth_name,\n                )\n                raise AttributeError(msg)\n\n    @classmethod\n    def test(cls):\n        this = set([x[0] for x in cls.all])\n        ignored = set([x[0] for x in cls.ignored])\n        klass = set([x for x in dir(psutil.Process) if x[0] != '_'])\n        leftout = (this | ignored) ^ klass\n        if leftout:\n            raise ValueError(\"uncovered Process class names: %r\" % leftout)\n\n\nclass system_namespace:\n    \"\"\"A container that lists all the module-level, system-related APIs.\n    Utilities such as cpu_percent() are excluded. Usage:\n\n    >>> ns = system_namespace\n    >>> for fun, name in ns.iter(ns.getters):\n    ...    fun()\n    \"\"\"\n\n    getters = [\n        ('boot_time', (), {}),\n        ('cpu_count', (), {'logical': False}),\n        ('cpu_count', (), {'logical': True}),\n        ('cpu_stats', (), {}),\n        ('cpu_times', (), {'percpu': False}),\n        ('cpu_times', (), {'percpu': True}),\n        ('disk_io_counters', (), {'perdisk': True}),\n        ('disk_partitions', (), {'all': True}),\n        ('disk_usage', (os.getcwd(),), {}),\n        ('net_connections', (), {'kind': 'all'}),\n        ('net_if_addrs', (), {}),\n        ('net_if_stats', (), {}),\n        ('net_io_counters', (), {'pernic': True}),\n        ('pid_exists', (os.getpid(),), {}),\n        ('pids', (), {}),\n        ('swap_memory', (), {}),\n        ('users', (), {}),\n        ('virtual_memory', (), {}),\n    ]\n    if HAS_CPU_FREQ:\n        if MACOS and platform.machine() == 'arm64':  # skipped due to #1892\n            pass\n        else:\n            getters += [('cpu_freq', (), {'percpu': True})]\n    if HAS_GETLOADAVG:\n        getters += [('getloadavg', (), {})]\n    if HAS_SENSORS_TEMPERATURES:\n        getters += [('sensors_temperatures', (), {})]\n    if HAS_SENSORS_FANS:\n        getters += [('sensors_fans', (), {})]\n    if HAS_SENSORS_BATTERY:\n        getters += [('sensors_battery', (), {})]\n    if WINDOWS:\n        getters += [('win_service_iter', (), {})]\n        getters += [('win_service_get', ('alg',), {})]\n\n    ignored = [\n        ('process_iter', (), {}),\n        ('wait_procs', ([psutil.Process()],), {}),\n        ('cpu_percent', (), {}),\n        ('cpu_times_percent', (), {}),\n    ]\n\n    all = getters\n\n    @staticmethod\n    def iter(ls):\n        \"\"\"Given a list of tuples yields a set of (fun, fun_name) tuples\n        in random order.\n        \"\"\"\n        ls = list(ls)\n        random.shuffle(ls)\n        for fun_name, args, kwds in ls:\n            fun = getattr(psutil, fun_name)\n            fun = functools.partial(fun, *args, **kwds)\n            yield (fun, fun_name)\n\n    test_class_coverage = process_namespace.test_class_coverage\n\n\ndef serialrun(klass):\n    \"\"\"A decorator to mark a TestCase class. When running parallel tests,\n    class' unit tests will be run serially (1 process).\n    \"\"\"\n    # assert issubclass(klass, unittest.TestCase), klass\n    assert inspect.isclass(klass), klass\n    klass._serialrun = True\n    return klass\n\n\ndef retry_on_failure(retries=NO_RETRIES):\n    \"\"\"Decorator which runs a test function and retries N times before\n    actually failing.\n    \"\"\"\n\n    def logfun(exc):\n        print(\"%r, retrying\" % exc, file=sys.stderr)  # NOQA\n\n    return retry(\n        exception=AssertionError, timeout=None, retries=retries, logfun=logfun\n    )\n\n\ndef skip_on_access_denied(only_if=None):\n    \"\"\"Decorator to Ignore AccessDenied exceptions.\"\"\"\n\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            try:\n                return fun(*args, **kwargs)\n            except psutil.AccessDenied:\n                if only_if is not None:\n                    if not only_if:\n                        raise\n                raise unittest.SkipTest(\"raises AccessDenied\")\n\n        return wrapper\n\n    return decorator\n\n\ndef skip_on_not_implemented(only_if=None):\n    \"\"\"Decorator to Ignore NotImplementedError exceptions.\"\"\"\n\n    def decorator(fun):\n        @functools.wraps(fun)\n        def wrapper(*args, **kwargs):\n            try:\n                return fun(*args, **kwargs)\n            except NotImplementedError:\n                if only_if is not None:\n                    if not only_if:\n                        raise\n                msg = (\n                    \"%r was skipped because it raised NotImplementedError\"\n                    % fun.__name__\n                )\n                raise unittest.SkipTest(msg)\n\n        return wrapper\n\n    return decorator\n\n\n# ===================================================================\n# --- network\n# ===================================================================\n\n\n# XXX: no longer used\ndef get_free_port(host='127.0.0.1'):\n    \"\"\"Return an unused TCP port. Subject to race conditions.\"\"\"\n    with contextlib.closing(socket.socket()) as sock:\n        sock.bind((host, 0))\n        return sock.getsockname()[1]\n\n\ndef bind_socket(family=AF_INET, type=SOCK_STREAM, addr=None):\n    \"\"\"Binds a generic socket.\"\"\"\n    if addr is None and family in (AF_INET, AF_INET6):\n        addr = (\"\", 0)\n    sock = socket.socket(family, type)\n    try:\n        if os.name not in ('nt', 'cygwin'):\n            sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        sock.bind(addr)\n        if type == socket.SOCK_STREAM:\n            sock.listen(5)\n        return sock\n    except Exception:\n        sock.close()\n        raise\n\n\ndef bind_unix_socket(name, type=socket.SOCK_STREAM):\n    \"\"\"Bind a UNIX socket.\"\"\"\n    assert psutil.POSIX\n    assert not os.path.exists(name), name\n    sock = socket.socket(socket.AF_UNIX, type)\n    try:\n        sock.bind(name)\n        if type == socket.SOCK_STREAM:\n            sock.listen(5)\n    except Exception:\n        sock.close()\n        raise\n    return sock\n\n\ndef tcp_socketpair(family, addr=(\"\", 0)):\n    \"\"\"Build a pair of TCP sockets connected to each other.\n    Return a (server, client) tuple.\n    \"\"\"\n    with contextlib.closing(socket.socket(family, SOCK_STREAM)) as ll:\n        ll.bind(addr)\n        ll.listen(5)\n        addr = ll.getsockname()\n        c = socket.socket(family, SOCK_STREAM)\n        try:\n            c.connect(addr)\n            caddr = c.getsockname()\n            while True:\n                a, addr = ll.accept()\n                # check that we've got the correct client\n                if addr == caddr:\n                    return (a, c)\n                a.close()\n        except OSError:\n            c.close()\n            raise\n\n\ndef unix_socketpair(name):\n    \"\"\"Build a pair of UNIX sockets connected to each other through\n    the same UNIX file name.\n    Return a (server, client) tuple.\n    \"\"\"\n    assert psutil.POSIX\n    server = client = None\n    try:\n        server = bind_unix_socket(name, type=socket.SOCK_STREAM)\n        server.setblocking(0)\n        client = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)\n        client.setblocking(0)\n        client.connect(name)\n        # new = server.accept()\n    except Exception:\n        if server is not None:\n            server.close()\n        if client is not None:\n            client.close()\n        raise\n    return (server, client)\n\n\n@contextlib.contextmanager\ndef create_sockets():\n    \"\"\"Open as many socket families / types as possible.\"\"\"\n    socks = []\n    fname1 = fname2 = None\n    try:\n        socks.append(bind_socket(socket.AF_INET, socket.SOCK_STREAM))\n        socks.append(bind_socket(socket.AF_INET, socket.SOCK_DGRAM))\n        if supports_ipv6():\n            socks.append(bind_socket(socket.AF_INET6, socket.SOCK_STREAM))\n            socks.append(bind_socket(socket.AF_INET6, socket.SOCK_DGRAM))\n        if POSIX and HAS_NET_CONNECTIONS_UNIX:\n            fname1 = get_testfn()\n            fname2 = get_testfn()\n            s1, s2 = unix_socketpair(fname1)\n            s3 = bind_unix_socket(fname2, type=socket.SOCK_DGRAM)\n            for s in (s1, s2, s3):\n                socks.append(s)\n        yield socks\n    finally:\n        for s in socks:\n            s.close()\n        for fname in (fname1, fname2):\n            if fname is not None:\n                safe_rmpath(fname)\n\n\ndef check_net_address(addr, family):\n    \"\"\"Check a net address validity. Supported families are IPv4,\n    IPv6 and MAC addresses.\n    \"\"\"\n    import ipaddress  # python >= 3.3 / requires \"pip install ipaddress\"\n\n    if enum and PY3 and not PYPY:\n        assert isinstance(family, enum.IntEnum), family\n    if family == socket.AF_INET:\n        octs = [int(x) for x in addr.split('.')]\n        assert len(octs) == 4, addr\n        for num in octs:\n            assert 0 <= num <= 255, addr\n        if not PY3:\n            addr = unicode(addr)\n        ipaddress.IPv4Address(addr)\n    elif family == socket.AF_INET6:\n        assert isinstance(addr, str), addr\n        if not PY3:\n            addr = unicode(addr)\n        ipaddress.IPv6Address(addr)\n    elif family == psutil.AF_LINK:\n        assert re.match(r'([a-fA-F0-9]{2}[:|\\-]?){6}', addr) is not None, addr\n    else:\n        raise ValueError(\"unknown family %r\" % family)\n\n\ndef check_connection_ntuple(conn):\n    \"\"\"Check validity of a connection namedtuple.\"\"\"\n\n    def check_ntuple(conn):\n        has_pid = len(conn) == 7\n        assert len(conn) in (6, 7), len(conn)\n        assert conn[0] == conn.fd, conn.fd\n        assert conn[1] == conn.family, conn.family\n        assert conn[2] == conn.type, conn.type\n        assert conn[3] == conn.laddr, conn.laddr\n        assert conn[4] == conn.raddr, conn.raddr\n        assert conn[5] == conn.status, conn.status\n        if has_pid:\n            assert conn[6] == conn.pid, conn.pid\n\n    def check_family(conn):\n        assert conn.family in (AF_INET, AF_INET6, AF_UNIX), conn.family\n        if enum is not None:\n            assert isinstance(conn.family, enum.IntEnum), conn\n        else:\n            assert isinstance(conn.family, int), conn\n        if conn.family == AF_INET:\n            # actually try to bind the local socket; ignore IPv6\n            # sockets as their address might be represented as\n            # an IPv4-mapped-address (e.g. \"::127.0.0.1\")\n            # and that's rejected by bind()\n            s = socket.socket(conn.family, conn.type)\n            with contextlib.closing(s):\n                try:\n                    s.bind((conn.laddr[0], 0))\n                except socket.error as err:\n                    if err.errno != errno.EADDRNOTAVAIL:\n                        raise\n        elif conn.family == AF_UNIX:\n            assert conn.status == psutil.CONN_NONE, conn.status\n\n    def check_type(conn):\n        # SOCK_SEQPACKET may happen in case of AF_UNIX socks\n        SOCK_SEQPACKET = getattr(socket, \"SOCK_SEQPACKET\", object())\n        assert conn.type in (\n            socket.SOCK_STREAM,\n            socket.SOCK_DGRAM,\n            SOCK_SEQPACKET,\n        ), conn.type\n        if enum is not None:\n            assert isinstance(conn.type, enum.IntEnum), conn\n        else:\n            assert isinstance(conn.type, int), conn\n        if conn.type == socket.SOCK_DGRAM:\n            assert conn.status == psutil.CONN_NONE, conn.status\n\n    def check_addrs(conn):\n        # check IP address and port sanity\n        for addr in (conn.laddr, conn.raddr):\n            if conn.family in (AF_INET, AF_INET6):\n                assert isinstance(addr, tuple), type(addr)\n                if not addr:\n                    continue\n                assert isinstance(addr.port, int), type(addr.port)\n                assert 0 <= addr.port <= 65535, addr.port\n                check_net_address(addr.ip, conn.family)\n            elif conn.family == AF_UNIX:\n                assert isinstance(addr, str), type(addr)\n\n    def check_status(conn):\n        assert isinstance(conn.status, str), conn.status\n        valids = [\n            getattr(psutil, x) for x in dir(psutil) if x.startswith('CONN_')\n        ]\n        assert conn.status in valids, conn.status\n        if conn.family in (AF_INET, AF_INET6) and conn.type == SOCK_STREAM:\n            assert conn.status != psutil.CONN_NONE, conn.status\n        else:\n            assert conn.status == psutil.CONN_NONE, conn.status\n\n    check_ntuple(conn)\n    check_family(conn)\n    check_type(conn)\n    check_addrs(conn)\n    check_status(conn)\n\n\ndef filter_proc_net_connections(cons):\n    \"\"\"Our process may start with some open UNIX sockets which are not\n    initialized by us, invalidating unit tests.\n    \"\"\"\n    new = []\n    for conn in cons:\n        if POSIX and conn.family == socket.AF_UNIX:\n            if MACOS and \"/syslog\" in conn.raddr:\n                debug(\"skipping %s\" % str(conn))\n                continue\n        new.append(conn)\n    return new\n\n\n# ===================================================================\n# --- compatibility\n# ===================================================================\n\n\ndef reload_module(module):\n    \"\"\"Backport of importlib.reload of Python 3.3+.\"\"\"\n    try:\n        import importlib\n\n        if not hasattr(importlib, 'reload'):  # python <=3.3\n            raise ImportError\n    except ImportError:\n        import imp\n\n        return imp.reload(module)\n    else:\n        return importlib.reload(module)\n\n\ndef import_module_by_path(path):\n    name = os.path.splitext(os.path.basename(path))[0]\n    if sys.version_info[0] < 3:\n        import imp\n\n        return imp.load_source(name, path)\n    else:\n        import importlib.util\n\n        spec = importlib.util.spec_from_file_location(name, path)\n        mod = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(mod)\n        return mod\n\n\n# ===================================================================\n# --- others\n# ===================================================================\n\n\ndef warn(msg):\n    \"\"\"Raise a warning msg.\"\"\"\n    warnings.warn(msg, UserWarning, stacklevel=2)\n\n\ndef is_namedtuple(x):\n    \"\"\"Check if object is an instance of namedtuple.\"\"\"\n    t = type(x)\n    b = t.__bases__\n    if len(b) != 1 or b[0] is not tuple:\n        return False\n    f = getattr(t, '_fields', None)\n    if not isinstance(f, tuple):\n        return False\n    return all(isinstance(n, str) for n in f)\n\n\nif POSIX:\n\n    @contextlib.contextmanager\n    def copyload_shared_lib(suffix=\"\"):\n        \"\"\"Ctx manager which picks up a random shared CO lib used\n        by this process, copies it in another location and loads it\n        in memory via ctypes. Return the new absolutized path.\n        \"\"\"\n        exe = 'pypy' if PYPY else 'python'\n        ext = \".so\"\n        dst = get_testfn(suffix=suffix + ext)\n        libs = [\n            x.path\n            for x in psutil.Process().memory_maps()\n            if os.path.splitext(x.path)[1] == ext and exe in x.path.lower()\n        ]\n        src = random.choice(libs)\n        shutil.copyfile(src, dst)\n        try:\n            ctypes.CDLL(dst)\n            yield dst\n        finally:\n            safe_rmpath(dst)\n\nelse:\n\n    @contextlib.contextmanager\n    def copyload_shared_lib(suffix=\"\"):\n        \"\"\"Ctx manager which picks up a random shared DLL lib used\n        by this process, copies it in another location and loads it\n        in memory via ctypes.\n        Return the new absolutized, normcased path.\n        \"\"\"\n        from ctypes import WinError\n        from ctypes import wintypes\n\n        ext = \".dll\"\n        dst = get_testfn(suffix=suffix + ext)\n        libs = [\n            x.path\n            for x in psutil.Process().memory_maps()\n            if x.path.lower().endswith(ext)\n            and 'python' in os.path.basename(x.path).lower()\n            and 'wow64' not in x.path.lower()\n        ]\n        if PYPY and not libs:\n            libs = [\n                x.path\n                for x in psutil.Process().memory_maps()\n                if 'pypy' in os.path.basename(x.path).lower()\n            ]\n        src = random.choice(libs)\n        shutil.copyfile(src, dst)\n        cfile = None\n        try:\n            cfile = ctypes.WinDLL(dst)\n            yield dst\n        finally:\n            # Work around OverflowError:\n            # - https://ci.appveyor.com/project/giampaolo/psutil/build/1207/\n            #       job/o53330pbnri9bcw7\n            # - http://bugs.python.org/issue30286\n            # - http://stackoverflow.com/questions/23522055\n            if cfile is not None:\n                FreeLibrary = ctypes.windll.kernel32.FreeLibrary\n                FreeLibrary.argtypes = [wintypes.HMODULE]\n                ret = FreeLibrary(cfile._handle)\n                if ret == 0:\n                    WinError()\n            safe_rmpath(dst)\n\n\n# ===================================================================\n# --- Exit funs (first is executed last)\n# ===================================================================\n\n\n# this is executed first\n@atexit.register\ndef cleanup_test_procs():\n    reap_children(recursive=True)\n\n\n# atexit module does not execute exit functions in case of SIGTERM, which\n# gets sent to test subprocesses, which is a problem if they import this\n# module. With this it will. See:\n# https://gmpy.dev/blog/2016/how-to-always-execute-exit-functions-in-python\nif POSIX:\n    signal.signal(signal.SIGTERM, lambda sig, _: sys.exit(sig))\n", "psutil/tests/test_posix.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"POSIX specific tests.\"\"\"\n\nimport datetime\nimport errno\nimport os\nimport re\nimport subprocess\nimport time\nimport unittest\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import OPENBSD\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil.tests import HAS_NET_IO_COUNTERS\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\nfrom psutil.tests import which\n\n\nif POSIX:\n    import mmap\n    import resource\n\n    from psutil._psutil_posix import getpagesize\n\n\ndef ps(fmt, pid=None):\n    \"\"\"Wrapper for calling the ps command with a little bit of cross-platform\n    support for a narrow range of features.\n    \"\"\"\n\n    cmd = ['ps']\n\n    if LINUX:\n        cmd.append('--no-headers')\n\n    if pid is not None:\n        cmd.extend(['-p', str(pid)])\n    else:\n        if SUNOS or AIX:\n            cmd.append('-A')\n        else:\n            cmd.append('ax')\n\n    if SUNOS:\n        fmt = fmt.replace(\"start\", \"stime\")\n\n    cmd.extend(['-o', fmt])\n\n    output = sh(cmd)\n\n    output = output.splitlines() if LINUX else output.splitlines()[1:]\n\n    all_output = []\n    for line in output:\n        line = line.strip()\n\n        try:\n            line = int(line)\n        except ValueError:\n            pass\n\n        all_output.append(line)\n\n    if pid is None:\n        return all_output\n    else:\n        return all_output[0]\n\n\n# ps \"-o\" field names differ wildly between platforms.\n# \"comm\" means \"only executable name\" but is not available on BSD platforms.\n# \"args\" means \"command with all its arguments\", and is also not available\n# on BSD platforms.\n# \"command\" is like \"args\" on most platforms, but like \"comm\" on AIX,\n# and not available on SUNOS.\n# so for the executable name we can use \"comm\" on Solaris and split \"command\"\n# on other platforms.\n# to get the cmdline (with args) we have to use \"args\" on AIX and\n# Solaris, and can use \"command\" on all others.\n\n\ndef ps_name(pid):\n    field = \"command\"\n    if SUNOS:\n        field = \"comm\"\n    command = ps(field, pid).split()\n    if QEMU_USER:\n        assert \"/bin/qemu-\" in command[0]\n        return command[1]\n    return command[0]\n\n\ndef ps_args(pid):\n    field = \"command\"\n    if AIX or SUNOS:\n        field = \"args\"\n    out = ps(field, pid)\n    # observed on BSD + Github CI: '/usr/local/bin/python3 -E -O (python3.9)'\n    out = re.sub(r\"\\(python.*?\\)$\", \"\", out)\n    return out.strip()\n\n\ndef ps_rss(pid):\n    field = \"rss\"\n    if AIX:\n        field = \"rssize\"\n    return ps(field, pid)\n\n\ndef ps_vsz(pid):\n    field = \"vsz\"\n    if AIX:\n        field = \"vsize\"\n    return ps(field, pid)\n\n\n@unittest.skipIf(not POSIX, \"POSIX only\")\nclass TestProcess(PsutilTestCase):\n    \"\"\"Compare psutil results against 'ps' command line utility (mainly).\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc(\n            [PYTHON_EXE, \"-E\", \"-O\"], stdin=subprocess.PIPE\n        ).pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_ppid(self):\n        ppid_ps = ps('ppid', self.pid)\n        ppid_psutil = psutil.Process(self.pid).ppid()\n        self.assertEqual(ppid_ps, ppid_psutil)\n\n    def test_uid(self):\n        uid_ps = ps('uid', self.pid)\n        uid_psutil = psutil.Process(self.pid).uids().real\n        self.assertEqual(uid_ps, uid_psutil)\n\n    def test_gid(self):\n        gid_ps = ps('rgid', self.pid)\n        gid_psutil = psutil.Process(self.pid).gids().real\n        self.assertEqual(gid_ps, gid_psutil)\n\n    def test_username(self):\n        username_ps = ps('user', self.pid)\n        username_psutil = psutil.Process(self.pid).username()\n        self.assertEqual(username_ps, username_psutil)\n\n    def test_username_no_resolution(self):\n        # Emulate a case where the system can't resolve the uid to\n        # a username in which case psutil is supposed to return\n        # the stringified uid.\n        p = psutil.Process()\n        with mock.patch(\"psutil.pwd.getpwuid\", side_effect=KeyError) as fun:\n            self.assertEqual(p.username(), str(p.uids().real))\n            assert fun.called\n\n    @skip_on_access_denied()\n    @retry_on_failure()\n    def test_rss_memory(self):\n        # give python interpreter some time to properly initialize\n        # so that the results are the same\n        time.sleep(0.1)\n        rss_ps = ps_rss(self.pid)\n        rss_psutil = psutil.Process(self.pid).memory_info()[0] / 1024\n        self.assertEqual(rss_ps, rss_psutil)\n\n    @skip_on_access_denied()\n    @retry_on_failure()\n    def test_vsz_memory(self):\n        # give python interpreter some time to properly initialize\n        # so that the results are the same\n        time.sleep(0.1)\n        vsz_ps = ps_vsz(self.pid)\n        vsz_psutil = psutil.Process(self.pid).memory_info()[1] / 1024\n        self.assertEqual(vsz_ps, vsz_psutil)\n\n    def test_name(self):\n        name_ps = ps_name(self.pid)\n        # remove path if there is any, from the command\n        name_ps = os.path.basename(name_ps).lower()\n        name_psutil = psutil.Process(self.pid).name().lower()\n        # ...because of how we calculate PYTHON_EXE; on MACOS this may\n        # be \"pythonX.Y\".\n        name_ps = re.sub(r\"\\d.\\d\", \"\", name_ps)\n        name_psutil = re.sub(r\"\\d.\\d\", \"\", name_psutil)\n        # ...may also be \"python.X\"\n        name_ps = re.sub(r\"\\d\", \"\", name_ps)\n        name_psutil = re.sub(r\"\\d\", \"\", name_psutil)\n        self.assertEqual(name_ps, name_psutil)\n\n    def test_name_long(self):\n        # On UNIX the kernel truncates the name to the first 15\n        # characters. In such a case psutil tries to determine the\n        # full name from the cmdline.\n        name = \"long-program-name\"\n        cmdline = [\"long-program-name-extended\", \"foo\", \"bar\"]\n        with mock.patch(\"psutil._psplatform.Process.name\", return_value=name):\n            with mock.patch(\n                \"psutil._psplatform.Process.cmdline\", return_value=cmdline\n            ):\n                p = psutil.Process()\n                self.assertEqual(p.name(), \"long-program-name-extended\")\n\n    def test_name_long_cmdline_ad_exc(self):\n        # Same as above but emulates a case where cmdline() raises\n        # AccessDenied in which case psutil is supposed to return\n        # the truncated name instead of crashing.\n        name = \"long-program-name\"\n        with mock.patch(\"psutil._psplatform.Process.name\", return_value=name):\n            with mock.patch(\n                \"psutil._psplatform.Process.cmdline\",\n                side_effect=psutil.AccessDenied(0, \"\"),\n            ):\n                p = psutil.Process()\n                self.assertEqual(p.name(), \"long-program-name\")\n\n    def test_name_long_cmdline_nsp_exc(self):\n        # Same as above but emulates a case where cmdline() raises NSP\n        # which is supposed to propagate.\n        name = \"long-program-name\"\n        with mock.patch(\"psutil._psplatform.Process.name\", return_value=name):\n            with mock.patch(\n                \"psutil._psplatform.Process.cmdline\",\n                side_effect=psutil.NoSuchProcess(0, \"\"),\n            ):\n                p = psutil.Process()\n                self.assertRaises(psutil.NoSuchProcess, p.name)\n\n    @unittest.skipIf(MACOS or BSD, 'ps -o start not available')\n    def test_create_time(self):\n        time_ps = ps('start', self.pid)\n        time_psutil = psutil.Process(self.pid).create_time()\n        time_psutil_tstamp = datetime.datetime.fromtimestamp(\n            time_psutil\n        ).strftime(\"%H:%M:%S\")\n        # sometimes ps shows the time rounded up instead of down, so we check\n        # for both possible values\n        round_time_psutil = round(time_psutil)\n        round_time_psutil_tstamp = datetime.datetime.fromtimestamp(\n            round_time_psutil\n        ).strftime(\"%H:%M:%S\")\n        self.assertIn(time_ps, [time_psutil_tstamp, round_time_psutil_tstamp])\n\n    def test_exe(self):\n        ps_pathname = ps_name(self.pid)\n        psutil_pathname = psutil.Process(self.pid).exe()\n        try:\n            self.assertEqual(ps_pathname, psutil_pathname)\n        except AssertionError:\n            # certain platforms such as BSD are more accurate returning:\n            # \"/usr/local/bin/python2.7\"\n            # ...instead of:\n            # \"/usr/local/bin/python\"\n            # We do not want to consider this difference in accuracy\n            # an error.\n            adjusted_ps_pathname = ps_pathname[: len(ps_pathname)]\n            self.assertEqual(ps_pathname, adjusted_ps_pathname)\n\n    # On macOS the official python installer exposes a python wrapper that\n    # executes a python executable hidden inside an application bundle inside\n    # the Python framework.\n    # There's a race condition between the ps call & the psutil call below\n    # depending on the completion of the execve call so let's retry on failure\n    @retry_on_failure()\n    def test_cmdline(self):\n        ps_cmdline = ps_args(self.pid)\n        psutil_cmdline = \" \".join(psutil.Process(self.pid).cmdline())\n        self.assertEqual(ps_cmdline, psutil_cmdline)\n\n    # On SUNOS \"ps\" reads niceness /proc/pid/psinfo which returns an\n    # incorrect value (20); the real deal is getpriority(2) which\n    # returns 0; psutil relies on it, see:\n    # https://github.com/giampaolo/psutil/issues/1082\n    # AIX has the same issue\n    @unittest.skipIf(SUNOS, \"not reliable on SUNOS\")\n    @unittest.skipIf(AIX, \"not reliable on AIX\")\n    def test_nice(self):\n        ps_nice = ps('nice', self.pid)\n        psutil_nice = psutil.Process().nice()\n        self.assertEqual(ps_nice, psutil_nice)\n\n\n@unittest.skipIf(not POSIX, \"POSIX only\")\nclass TestSystemAPIs(PsutilTestCase):\n    \"\"\"Test some system APIs.\"\"\"\n\n    @retry_on_failure()\n    def test_pids(self):\n        # Note: this test might fail if the OS is starting/killing\n        # other processes in the meantime\n        pids_ps = sorted(ps(\"pid\"))\n        pids_psutil = psutil.pids()\n\n        # on MACOS and OPENBSD ps doesn't show pid 0\n        if MACOS or OPENBSD and 0 not in pids_ps:\n            pids_ps.insert(0, 0)\n\n        # There will often be one more process in pids_ps for ps itself\n        if len(pids_ps) - len(pids_psutil) > 1:\n            difference = [x for x in pids_psutil if x not in pids_ps] + [\n                x for x in pids_ps if x not in pids_psutil\n            ]\n            raise self.fail(\"difference: \" + str(difference))\n\n    # for some reason ifconfig -a does not report all interfaces\n    # returned by psutil\n    @unittest.skipIf(SUNOS, \"unreliable on SUNOS\")\n    @unittest.skipIf(not which('ifconfig'), \"no ifconfig cmd\")\n    @unittest.skipIf(not HAS_NET_IO_COUNTERS, \"not supported\")\n    def test_nic_names(self):\n        output = sh(\"ifconfig -a\")\n        for nic in psutil.net_io_counters(pernic=True):\n            for line in output.split():\n                if line.startswith(nic):\n                    break\n            else:\n                raise self.fail(\n                    \"couldn't find %s nic in 'ifconfig -a' output\\n%s\"\n                    % (nic, output)\n                )\n\n    # @unittest.skipIf(CI_TESTING and not psutil.users(), \"unreliable on CI\")\n    @retry_on_failure()\n    def test_users(self):\n        out = sh(\"who -u\")\n        if not out.strip():\n            raise unittest.SkipTest(\"no users on this system\")\n        lines = out.split('\\n')\n        users = [x.split()[0] for x in lines]\n        terminals = [x.split()[1] for x in lines]\n        self.assertEqual(len(users), len(psutil.users()))\n        with self.subTest(psutil=psutil.users(), who=out):\n            for idx, u in enumerate(psutil.users()):\n                self.assertEqual(u.name, users[idx])\n                self.assertEqual(u.terminal, terminals[idx])\n                if u.pid is not None:  # None on OpenBSD\n                    psutil.Process(u.pid)\n\n    @retry_on_failure()\n    def test_users_started(self):\n        out = sh(\"who -u\")\n        if not out.strip():\n            raise unittest.SkipTest(\"no users on this system\")\n        tstamp = None\n        # '2023-04-11 09:31' (Linux)\n        started = re.findall(r\"\\d\\d\\d\\d-\\d\\d-\\d\\d \\d\\d:\\d\\d\", out)\n        if started:\n            tstamp = \"%Y-%m-%d %H:%M\"\n        else:\n            # 'Apr 10 22:27' (macOS)\n            started = re.findall(r\"[A-Z][a-z][a-z] \\d\\d \\d\\d:\\d\\d\", out)\n            if started:\n                tstamp = \"%b %d %H:%M\"\n            else:\n                # 'Apr 10'\n                started = re.findall(r\"[A-Z][a-z][a-z] \\d\\d\", out)\n                if started:\n                    tstamp = \"%b %d\"\n                else:\n                    # 'apr 10' (sunOS)\n                    started = re.findall(r\"[a-z][a-z][a-z] \\d\\d\", out)\n                    if started:\n                        tstamp = \"%b %d\"\n                        started = [x.capitalize() for x in started]\n\n        if not tstamp:\n            raise unittest.SkipTest(\n                \"cannot interpret tstamp in who output\\n%s\" % (out)\n            )\n\n        with self.subTest(psutil=psutil.users(), who=out):\n            for idx, u in enumerate(psutil.users()):\n                psutil_value = datetime.datetime.fromtimestamp(\n                    u.started\n                ).strftime(tstamp)\n                self.assertEqual(psutil_value, started[idx])\n\n    def test_pid_exists_let_raise(self):\n        # According to \"man 2 kill\" possible error values for kill\n        # are (EINVAL, EPERM, ESRCH). Test that any other errno\n        # results in an exception.\n        with mock.patch(\n            \"psutil._psposix.os.kill\", side_effect=OSError(errno.EBADF, \"\")\n        ) as m:\n            self.assertRaises(OSError, psutil._psposix.pid_exists, os.getpid())\n            assert m.called\n\n    def test_os_waitpid_let_raise(self):\n        # os.waitpid() is supposed to catch EINTR and ECHILD only.\n        # Test that any other errno results in an exception.\n        with mock.patch(\n            \"psutil._psposix.os.waitpid\", side_effect=OSError(errno.EBADF, \"\")\n        ) as m:\n            self.assertRaises(OSError, psutil._psposix.wait_pid, os.getpid())\n            assert m.called\n\n    def test_os_waitpid_eintr(self):\n        # os.waitpid() is supposed to \"retry\" on EINTR.\n        with mock.patch(\n            \"psutil._psposix.os.waitpid\", side_effect=OSError(errno.EINTR, \"\")\n        ) as m:\n            self.assertRaises(\n                psutil._psposix.TimeoutExpired,\n                psutil._psposix.wait_pid,\n                os.getpid(),\n                timeout=0.01,\n            )\n            assert m.called\n\n    def test_os_waitpid_bad_ret_status(self):\n        # Simulate os.waitpid() returning a bad status.\n        with mock.patch(\n            \"psutil._psposix.os.waitpid\", return_value=(1, -1)\n        ) as m:\n            self.assertRaises(\n                ValueError, psutil._psposix.wait_pid, os.getpid()\n            )\n            assert m.called\n\n    # AIX can return '-' in df output instead of numbers, e.g. for /proc\n    @unittest.skipIf(AIX, \"unreliable on AIX\")\n    @retry_on_failure()\n    def test_disk_usage(self):\n        def df(device):\n            try:\n                out = sh(\"df -k %s\" % device).strip()\n            except RuntimeError as err:\n                if \"device busy\" in str(err).lower():\n                    raise unittest.SkipTest(\"df returned EBUSY\")\n                raise\n            line = out.split('\\n')[1]\n            fields = line.split()\n            total = int(fields[1]) * 1024\n            used = int(fields[2]) * 1024\n            free = int(fields[3]) * 1024\n            percent = float(fields[4].replace('%', ''))\n            return (total, used, free, percent)\n\n        tolerance = 4 * 1024 * 1024  # 4MB\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            try:\n                total, used, free, percent = df(part.device)\n            except RuntimeError as err:\n                # see:\n                # https://travis-ci.org/giampaolo/psutil/jobs/138338464\n                # https://travis-ci.org/giampaolo/psutil/jobs/138343361\n                err = str(err).lower()\n                if (\n                    \"no such file or directory\" in err\n                    or \"raw devices not supported\" in err\n                    or \"permission denied\" in err\n                ):\n                    continue\n                raise\n            else:\n                self.assertAlmostEqual(usage.total, total, delta=tolerance)\n                self.assertAlmostEqual(usage.used, used, delta=tolerance)\n                self.assertAlmostEqual(usage.free, free, delta=tolerance)\n                self.assertAlmostEqual(usage.percent, percent, delta=1)\n\n\n@unittest.skipIf(not POSIX, \"POSIX only\")\nclass TestMisc(PsutilTestCase):\n    def test_getpagesize(self):\n        pagesize = getpagesize()\n        self.assertGreater(pagesize, 0)\n        self.assertEqual(pagesize, resource.getpagesize())\n        self.assertEqual(pagesize, mmap.PAGESIZE)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_linux.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Linux specific tests.\"\"\"\n\nfrom __future__ import division\n\nimport collections\nimport contextlib\nimport errno\nimport glob\nimport io\nimport os\nimport re\nimport shutil\nimport socket\nimport struct\nimport textwrap\nimport time\nimport unittest\nimport warnings\n\nimport psutil\nfrom psutil import LINUX\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import basestring\nfrom psutil.tests import AARCH64\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import HAS_CPU_FREQ\nfrom psutil.tests import HAS_GETLOADAVG\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import PYPY\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import mock\nfrom psutil.tests import reload_module\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import which\n\n\nif LINUX:\n    from psutil._pslinux import CLOCK_TICKS\n    from psutil._pslinux import RootFsDeviceFinder\n    from psutil._pslinux import calculate_avail_vmem\n    from psutil._pslinux import open_binary\n\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nSIOCGIFADDR = 0x8915\nSIOCGIFCONF = 0x8912\nSIOCGIFHWADDR = 0x8927\nSIOCGIFNETMASK = 0x891B\nSIOCGIFBRDADDR = 0x8919\nif LINUX:\n    SECTOR_SIZE = 512\nEMPTY_TEMPERATURES = not glob.glob('/sys/class/hwmon/hwmon*')\n\n\n# =====================================================================\n# --- utils\n# =====================================================================\n\n\ndef get_ipv4_address(ifname):\n    import fcntl\n\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(\n            fcntl.ioctl(s.fileno(), SIOCGIFADDR, struct.pack('256s', ifname))[\n                20:24\n            ]\n        )\n\n\ndef get_ipv4_netmask(ifname):\n    import fcntl\n\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(\n            fcntl.ioctl(\n                s.fileno(), SIOCGIFNETMASK, struct.pack('256s', ifname)\n            )[20:24]\n        )\n\n\ndef get_ipv4_broadcast(ifname):\n    import fcntl\n\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        return socket.inet_ntoa(\n            fcntl.ioctl(\n                s.fileno(), SIOCGIFBRDADDR, struct.pack('256s', ifname)\n            )[20:24]\n        )\n\n\ndef get_ipv6_addresses(ifname):\n    with open(\"/proc/net/if_inet6\") as f:\n        all_fields = []\n        for line in f:\n            fields = line.split()\n            if fields[-1] == ifname:\n                all_fields.append(fields)\n\n        if len(all_fields) == 0:\n            raise ValueError(\"could not find interface %r\" % ifname)\n\n    for i in range(len(all_fields)):\n        unformatted = all_fields[i][0]\n        groups = []\n        for j in range(0, len(unformatted), 4):\n            groups.append(unformatted[j : j + 4])\n        formatted = \":\".join(groups)\n        packed = socket.inet_pton(socket.AF_INET6, formatted)\n        all_fields[i] = socket.inet_ntop(socket.AF_INET6, packed)\n    return all_fields\n\n\ndef get_mac_address(ifname):\n    import fcntl\n\n    ifname = ifname[:15]\n    if PY3:\n        ifname = bytes(ifname, 'ascii')\n    s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)\n    with contextlib.closing(s):\n        info = fcntl.ioctl(\n            s.fileno(), SIOCGIFHWADDR, struct.pack('256s', ifname)\n        )\n        if PY3:\n\n            def ord(x):\n                return x\n\n        else:\n            import __builtin__\n\n            ord = __builtin__.ord\n        return ''.join(['%02x:' % ord(char) for char in info[18:24]])[:-1]\n\n\ndef free_swap():\n    \"\"\"Parse 'free' cmd and return swap memory's s total, used and free\n    values.\n    \"\"\"\n    out = sh([\"free\", \"-b\"], env={\"LANG\": \"C.UTF-8\"})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Swap'):\n            _, total, used, free = line.split()\n            nt = collections.namedtuple('free', 'total used free')\n            return nt(int(total), int(used), int(free))\n    raise ValueError(\n        \"can't find 'Swap' in 'free' output:\\n%s\" % '\\n'.join(lines)\n    )\n\n\ndef free_physmem():\n    \"\"\"Parse 'free' cmd and return physical memory's total, used\n    and free values.\n    \"\"\"\n    # Note: free can have 2 different formats, invalidating 'shared'\n    # and 'cached' memory which may have different positions so we\n    # do not return them.\n    # https://github.com/giampaolo/psutil/issues/538#issuecomment-57059946\n    out = sh([\"free\", \"-b\"], env={\"LANG\": \"C.UTF-8\"})\n    lines = out.split('\\n')\n    for line in lines:\n        if line.startswith('Mem'):\n            total, used, free, shared = (int(x) for x in line.split()[1:5])\n            nt = collections.namedtuple(\n                'free', 'total used free shared output'\n            )\n            return nt(total, used, free, shared, out)\n    raise ValueError(\n        \"can't find 'Mem' in 'free' output:\\n%s\" % '\\n'.join(lines)\n    )\n\n\ndef vmstat(stat):\n    out = sh([\"vmstat\", \"-s\"], env={\"LANG\": \"C.UTF-8\"})\n    for line in out.split(\"\\n\"):\n        line = line.strip()\n        if stat in line:\n            return int(line.split(' ')[0])\n    raise ValueError(\"can't find %r in 'vmstat' output\" % stat)\n\n\ndef get_free_version_info():\n    out = sh([\"free\", \"-V\"]).strip()\n    if 'UNKNOWN' in out:\n        raise unittest.SkipTest(\"can't determine free version\")\n    return tuple(map(int, re.findall(r'\\d+', out.split()[-1])))\n\n\n@contextlib.contextmanager\ndef mock_open_content(pairs):\n    \"\"\"Mock open() builtin and forces it to return a certain content\n    for a given path. `pairs` is a {\"path\": \"content\", ...} dict.\n    \"\"\"\n\n    def open_mock(name, *args, **kwargs):\n        if name in pairs:\n            content = pairs[name]\n            if PY3:\n                if isinstance(content, basestring):\n                    return io.StringIO(content)\n                else:\n                    return io.BytesIO(content)\n            else:\n                return io.BytesIO(content)\n        else:\n            return orig_open(name, *args, **kwargs)\n\n    orig_open = open\n    patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n    with mock.patch(patch_point, create=True, side_effect=open_mock) as m:\n        yield m\n\n\n@contextlib.contextmanager\ndef mock_open_exception(for_path, exc):\n    \"\"\"Mock open() builtin and raises `exc` if the path being opened\n    matches `for_path`.\n    \"\"\"\n\n    def open_mock(name, *args, **kwargs):\n        if name == for_path:\n            raise exc\n        else:\n            return orig_open(name, *args, **kwargs)\n\n    orig_open = open\n    patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n    with mock.patch(patch_point, create=True, side_effect=open_mock) as m:\n        yield m\n\n\n# =====================================================================\n# --- system virtual memory\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemVirtualMemoryAgainstFree(PsutilTestCase):\n    def test_total(self):\n        cli_value = free_physmem().total\n        psutil_value = psutil.virtual_memory().total\n        self.assertEqual(cli_value, psutil_value)\n\n    @retry_on_failure()\n    def test_used(self):\n        # Older versions of procps used slab memory to calculate used memory.\n        # This got changed in:\n        # https://gitlab.com/procps-ng/procps/commit/\n        #     05d751c4f076a2f0118b914c5e51cfbb4762ad8e\n        # Newer versions of procps are using yet another way to compute used\n        # memory.\n        # https://gitlab.com/procps-ng/procps/commit/\n        #     2184e90d2e7cdb582f9a5b706b47015e56707e4d\n        if get_free_version_info() < (3, 3, 12):\n            raise unittest.SkipTest(\"free version too old\")\n        if get_free_version_info() >= (4, 0, 0):\n            raise unittest.SkipTest(\"free version too recent\")\n        cli_value = free_physmem().used\n        psutil_value = psutil.virtual_memory().used\n        self.assertAlmostEqual(\n            cli_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_free(self):\n        cli_value = free_physmem().free\n        psutil_value = psutil.virtual_memory().free\n        self.assertAlmostEqual(\n            cli_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_shared(self):\n        free = free_physmem()\n        free_value = free.shared\n        if free_value == 0:\n            raise unittest.SkipTest(\"free does not support 'shared' column\")\n        psutil_value = psutil.virtual_memory().shared\n        self.assertAlmostEqual(\n            free_value,\n            psutil_value,\n            delta=TOLERANCE_SYS_MEM,\n            msg='%s %s \\n%s' % (free_value, psutil_value, free.output),\n        )\n\n    @retry_on_failure()\n    def test_available(self):\n        # \"free\" output format has changed at some point:\n        # https://github.com/giampaolo/psutil/issues/538#issuecomment-147192098\n        out = sh([\"free\", \"-b\"])\n        lines = out.split('\\n')\n        if 'available' not in lines[0]:\n            raise unittest.SkipTest(\"free does not support 'available' column\")\n        else:\n            free_value = int(lines[1].split()[-1])\n            psutil_value = psutil.virtual_memory().available\n            self.assertAlmostEqual(\n                free_value,\n                psutil_value,\n                delta=TOLERANCE_SYS_MEM,\n                msg='%s %s \\n%s' % (free_value, psutil_value, out),\n            )\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemVirtualMemoryAgainstVmstat(PsutilTestCase):\n    def test_total(self):\n        vmstat_value = vmstat('total memory') * 1024\n        psutil_value = psutil.virtual_memory().total\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_used(self):\n        # Older versions of procps used slab memory to calculate used memory.\n        # This got changed in:\n        # https://gitlab.com/procps-ng/procps/commit/\n        #     05d751c4f076a2f0118b914c5e51cfbb4762ad8e\n        # Newer versions of procps are using yet another way to compute used\n        # memory.\n        # https://gitlab.com/procps-ng/procps/commit/\n        #     2184e90d2e7cdb582f9a5b706b47015e56707e4d\n        if get_free_version_info() < (3, 3, 12):\n            raise unittest.SkipTest(\"free version too old\")\n        if get_free_version_info() >= (4, 0, 0):\n            raise unittest.SkipTest(\"free version too recent\")\n        vmstat_value = vmstat('used memory') * 1024\n        psutil_value = psutil.virtual_memory().used\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_free(self):\n        vmstat_value = vmstat('free memory') * 1024\n        psutil_value = psutil.virtual_memory().free\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_buffers(self):\n        vmstat_value = vmstat('buffer memory') * 1024\n        psutil_value = psutil.virtual_memory().buffers\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_active(self):\n        vmstat_value = vmstat('active memory') * 1024\n        psutil_value = psutil.virtual_memory().active\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_inactive(self):\n        vmstat_value = vmstat('inactive memory') * 1024\n        psutil_value = psutil.virtual_memory().inactive\n        self.assertAlmostEqual(\n            vmstat_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemVirtualMemoryMocks(PsutilTestCase):\n    def test_warnings_on_misses(self):\n        # Emulate a case where /proc/meminfo provides few info.\n        # psutil is supposed to set the missing fields to 0 and\n        # raise a warning.\n        content = textwrap.dedent(\"\"\"\\\n            Active(anon):    6145416 kB\n            Active(file):    2950064 kB\n            Inactive(anon):   574764 kB\n            Inactive(file):  1567648 kB\n            MemAvailable:         -1 kB\n            MemFree:         2057400 kB\n            MemTotal:       16325648 kB\n            SReclaimable:     346648 kB\n            \"\"\").encode()\n        with mock_open_content({'/proc/meminfo': content}) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                warnings.simplefilter(\"always\")\n                ret = psutil.virtual_memory()\n                assert m.called\n                self.assertEqual(len(ws), 1)\n                w = ws[0]\n                self.assertIn(\n                    \"memory stats couldn't be determined\", str(w.message)\n                )\n                self.assertIn(\"cached\", str(w.message))\n                self.assertIn(\"shared\", str(w.message))\n                self.assertIn(\"active\", str(w.message))\n                self.assertIn(\"inactive\", str(w.message))\n                self.assertIn(\"buffers\", str(w.message))\n                self.assertIn(\"available\", str(w.message))\n                self.assertEqual(ret.cached, 0)\n                self.assertEqual(ret.active, 0)\n                self.assertEqual(ret.inactive, 0)\n                self.assertEqual(ret.shared, 0)\n                self.assertEqual(ret.buffers, 0)\n                self.assertEqual(ret.available, 0)\n                self.assertEqual(ret.slab, 0)\n\n    @retry_on_failure()\n    def test_avail_old_percent(self):\n        # Make sure that our calculation of avail mem for old kernels\n        # is off by max 15%.\n        mems = {}\n        with open_binary('/proc/meminfo') as f:\n            for line in f:\n                fields = line.split()\n                mems[fields[0]] = int(fields[1]) * 1024\n\n        a = calculate_avail_vmem(mems)\n        if b'MemAvailable:' in mems:\n            b = mems[b'MemAvailable:']\n            diff_percent = abs(a - b) / a * 100\n            self.assertLess(diff_percent, 15)\n\n    def test_avail_old_comes_from_kernel(self):\n        # Make sure \"MemAvailable:\" coluimn is used instead of relying\n        # on our internal algorithm to calculate avail mem.\n        content = textwrap.dedent(\"\"\"\\\n            Active:          9444728 kB\n            Active(anon):    6145416 kB\n            Active(file):    2950064 kB\n            Buffers:          287952 kB\n            Cached:          4818144 kB\n            Inactive(file):  1578132 kB\n            Inactive(anon):   574764 kB\n            Inactive(file):  1567648 kB\n            MemAvailable:    6574984 kB\n            MemFree:         2057400 kB\n            MemTotal:       16325648 kB\n            Shmem:            577588 kB\n            SReclaimable:     346648 kB\n            \"\"\").encode()\n        with mock_open_content({'/proc/meminfo': content}) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                ret = psutil.virtual_memory()\n            assert m.called\n            self.assertEqual(ret.available, 6574984 * 1024)\n            w = ws[0]\n            self.assertIn(\n                \"inactive memory stats couldn't be determined\", str(w.message)\n            )\n\n    def test_avail_old_missing_fields(self):\n        # Remove Active(file), Inactive(file) and SReclaimable\n        # from /proc/meminfo and make sure the fallback is used\n        # (free + cached),\n        content = textwrap.dedent(\"\"\"\\\n            Active:          9444728 kB\n            Active(anon):    6145416 kB\n            Buffers:          287952 kB\n            Cached:          4818144 kB\n            Inactive(file):  1578132 kB\n            Inactive(anon):   574764 kB\n            MemFree:         2057400 kB\n            MemTotal:       16325648 kB\n            Shmem:            577588 kB\n            \"\"\").encode()\n        with mock_open_content({\"/proc/meminfo\": content}) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                ret = psutil.virtual_memory()\n            assert m.called\n            self.assertEqual(ret.available, 2057400 * 1024 + 4818144 * 1024)\n            w = ws[0]\n            self.assertIn(\n                \"inactive memory stats couldn't be determined\", str(w.message)\n            )\n\n    def test_avail_old_missing_zoneinfo(self):\n        # Remove /proc/zoneinfo file. Make sure fallback is used\n        # (free + cached).\n        content = textwrap.dedent(\"\"\"\\\n            Active:          9444728 kB\n            Active(anon):    6145416 kB\n            Active(file):    2950064 kB\n            Buffers:          287952 kB\n            Cached:          4818144 kB\n            Inactive(file):  1578132 kB\n            Inactive(anon):   574764 kB\n            Inactive(file):  1567648 kB\n            MemFree:         2057400 kB\n            MemTotal:       16325648 kB\n            Shmem:            577588 kB\n            SReclaimable:     346648 kB\n            \"\"\").encode()\n        with mock_open_content({\"/proc/meminfo\": content}):\n            with mock_open_exception(\n                \"/proc/zoneinfo\",\n                IOError(errno.ENOENT, 'no such file or directory'),\n            ):\n                with warnings.catch_warnings(record=True) as ws:\n                    ret = psutil.virtual_memory()\n                    self.assertEqual(\n                        ret.available, 2057400 * 1024 + 4818144 * 1024\n                    )\n                    w = ws[0]\n                    self.assertIn(\n                        \"inactive memory stats couldn't be determined\",\n                        str(w.message),\n                    )\n\n    def test_virtual_memory_mocked(self):\n        # Emulate /proc/meminfo because neither vmstat nor free return slab.\n        content = textwrap.dedent(\"\"\"\\\n            MemTotal:              100 kB\n            MemFree:               2 kB\n            MemAvailable:          3 kB\n            Buffers:               4 kB\n            Cached:                5 kB\n            SwapCached:            6 kB\n            Active:                7 kB\n            Inactive:              8 kB\n            Active(anon):          9 kB\n            Inactive(anon):        10 kB\n            Active(file):          11 kB\n            Inactive(file):        12 kB\n            Unevictable:           13 kB\n            Mlocked:               14 kB\n            SwapTotal:             15 kB\n            SwapFree:              16 kB\n            Dirty:                 17 kB\n            Writeback:             18 kB\n            AnonPages:             19 kB\n            Mapped:                20 kB\n            Shmem:                 21 kB\n            Slab:                  22 kB\n            SReclaimable:          23 kB\n            SUnreclaim:            24 kB\n            KernelStack:           25 kB\n            PageTables:            26 kB\n            NFS_Unstable:          27 kB\n            Bounce:                28 kB\n            WritebackTmp:          29 kB\n            CommitLimit:           30 kB\n            Committed_AS:          31 kB\n            VmallocTotal:          32 kB\n            VmallocUsed:           33 kB\n            VmallocChunk:          34 kB\n            HardwareCorrupted:     35 kB\n            AnonHugePages:         36 kB\n            ShmemHugePages:        37 kB\n            ShmemPmdMapped:        38 kB\n            CmaTotal:              39 kB\n            CmaFree:               40 kB\n            HugePages_Total:       41 kB\n            HugePages_Free:        42 kB\n            HugePages_Rsvd:        43 kB\n            HugePages_Surp:        44 kB\n            Hugepagesize:          45 kB\n            DirectMap46k:          46 kB\n            DirectMap47M:          47 kB\n            DirectMap48G:          48 kB\n            \"\"\").encode()\n        with mock_open_content({\"/proc/meminfo\": content}) as m:\n            mem = psutil.virtual_memory()\n            assert m.called\n            self.assertEqual(mem.total, 100 * 1024)\n            self.assertEqual(mem.free, 2 * 1024)\n            self.assertEqual(mem.buffers, 4 * 1024)\n            # cached mem also includes reclaimable memory\n            self.assertEqual(mem.cached, (5 + 23) * 1024)\n            self.assertEqual(mem.shared, 21 * 1024)\n            self.assertEqual(mem.active, 7 * 1024)\n            self.assertEqual(mem.inactive, 8 * 1024)\n            self.assertEqual(mem.slab, 22 * 1024)\n            self.assertEqual(mem.available, 3 * 1024)\n\n\n# =====================================================================\n# --- system swap memory\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemSwapMemory(PsutilTestCase):\n    @staticmethod\n    def meminfo_has_swap_info():\n        \"\"\"Return True if /proc/meminfo provides swap metrics.\"\"\"\n        with open(\"/proc/meminfo\") as f:\n            data = f.read()\n        return 'SwapTotal:' in data and 'SwapFree:' in data\n\n    def test_total(self):\n        free_value = free_swap().total\n        psutil_value = psutil.swap_memory().total\n        return self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_used(self):\n        free_value = free_swap().used\n        psutil_value = psutil.swap_memory().used\n        return self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    @retry_on_failure()\n    def test_free(self):\n        free_value = free_swap().free\n        psutil_value = psutil.swap_memory().free\n        return self.assertAlmostEqual(\n            free_value, psutil_value, delta=TOLERANCE_SYS_MEM\n        )\n\n    def test_missing_sin_sout(self):\n        with mock.patch('psutil._common.open', create=True) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                warnings.simplefilter(\"always\")\n                ret = psutil.swap_memory()\n                assert m.called\n                self.assertEqual(len(ws), 1)\n                w = ws[0]\n                self.assertIn(\n                    \"'sin' and 'sout' swap memory stats couldn't \"\n                    \"be determined\",\n                    str(w.message),\n                )\n                self.assertEqual(ret.sin, 0)\n                self.assertEqual(ret.sout, 0)\n\n    def test_no_vmstat_mocked(self):\n        # see https://github.com/giampaolo/psutil/issues/722\n        with mock_open_exception(\n            \"/proc/vmstat\", IOError(errno.ENOENT, 'no such file or directory')\n        ) as m:\n            with warnings.catch_warnings(record=True) as ws:\n                warnings.simplefilter(\"always\")\n                ret = psutil.swap_memory()\n                assert m.called\n                self.assertEqual(len(ws), 1)\n                w = ws[0]\n                self.assertIn(\n                    \"'sin' and 'sout' swap memory stats couldn't \"\n                    \"be determined and were set to 0\",\n                    str(w.message),\n                )\n                self.assertEqual(ret.sin, 0)\n                self.assertEqual(ret.sout, 0)\n\n    def test_meminfo_against_sysinfo(self):\n        # Make sure the content of /proc/meminfo about swap memory\n        # matches sysinfo() syscall, see:\n        # https://github.com/giampaolo/psutil/issues/1015\n        if not self.meminfo_has_swap_info():\n            return unittest.skip(\"/proc/meminfo has no swap metrics\")\n        with mock.patch('psutil._pslinux.cext.linux_sysinfo') as m:\n            swap = psutil.swap_memory()\n        assert not m.called\n        import psutil._psutil_linux as cext\n\n        _, _, _, _, total, free, unit_multiplier = cext.linux_sysinfo()\n        total *= unit_multiplier\n        free *= unit_multiplier\n        self.assertEqual(swap.total, total)\n        self.assertAlmostEqual(swap.free, free, delta=TOLERANCE_SYS_MEM)\n\n    def test_emulate_meminfo_has_no_metrics(self):\n        # Emulate a case where /proc/meminfo provides no swap metrics\n        # in which case sysinfo() syscall is supposed to be used\n        # as a fallback.\n        with mock_open_content({\"/proc/meminfo\": b\"\"}) as m:\n            psutil.swap_memory()\n            assert m.called\n\n\n# =====================================================================\n# --- system CPU\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUTimes(PsutilTestCase):\n    def test_fields(self):\n        fields = psutil.cpu_times()._fields\n        kernel_ver = re.findall(r'\\d+\\.\\d+\\.\\d+', os.uname()[2])[0]\n        kernel_ver_info = tuple(map(int, kernel_ver.split('.')))\n        if kernel_ver_info >= (2, 6, 11):\n            self.assertIn('steal', fields)\n        else:\n            self.assertNotIn('steal', fields)\n        if kernel_ver_info >= (2, 6, 24):\n            self.assertIn('guest', fields)\n        else:\n            self.assertNotIn('guest', fields)\n        if kernel_ver_info >= (3, 2, 0):\n            self.assertIn('guest_nice', fields)\n        else:\n            self.assertNotIn('guest_nice', fields)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUCountLogical(PsutilTestCase):\n    @unittest.skipIf(\n        not os.path.exists(\"/sys/devices/system/cpu/online\"),\n        \"/sys/devices/system/cpu/online does not exist\",\n    )\n    def test_against_sysdev_cpu_online(self):\n        with open(\"/sys/devices/system/cpu/online\") as f:\n            value = f.read().strip()\n        if \"-\" in str(value):\n            value = int(value.split('-')[1]) + 1\n            self.assertEqual(psutil.cpu_count(), value)\n\n    @unittest.skipIf(\n        not os.path.exists(\"/sys/devices/system/cpu\"),\n        \"/sys/devices/system/cpu does not exist\",\n    )\n    def test_against_sysdev_cpu_num(self):\n        ls = os.listdir(\"/sys/devices/system/cpu\")\n        count = len([x for x in ls if re.search(r\"cpu\\d+$\", x) is not None])\n        self.assertEqual(psutil.cpu_count(), count)\n\n    @unittest.skipIf(not which(\"nproc\"), \"nproc utility not available\")\n    def test_against_nproc(self):\n        num = int(sh(\"nproc --all\"))\n        self.assertEqual(psutil.cpu_count(logical=True), num)\n\n    @unittest.skipIf(not which(\"lscpu\"), \"lscpu utility not available\")\n    def test_against_lscpu(self):\n        out = sh(\"lscpu -p\")\n        num = len([x for x in out.split('\\n') if not x.startswith('#')])\n        self.assertEqual(psutil.cpu_count(logical=True), num)\n\n    def test_emulate_fallbacks(self):\n        import psutil._pslinux\n\n        original = psutil._pslinux.cpu_count_logical()\n        # Here we want to mock os.sysconf(\"SC_NPROCESSORS_ONLN\") in\n        # order to cause the parsing of /proc/cpuinfo and /proc/stat.\n        with mock.patch(\n            'psutil._pslinux.os.sysconf', side_effect=ValueError\n        ) as m:\n            self.assertEqual(psutil._pslinux.cpu_count_logical(), original)\n            assert m.called\n\n            # Let's have open() return empty data and make sure None is\n            # returned ('cause we mimic os.cpu_count()).\n            with mock.patch('psutil._common.open', create=True) as m:\n                self.assertIsNone(psutil._pslinux.cpu_count_logical())\n                self.assertEqual(m.call_count, 2)\n                # /proc/stat should be the last one\n                self.assertEqual(m.call_args[0][0], '/proc/stat')\n\n            # Let's push this a bit further and make sure /proc/cpuinfo\n            # parsing works as expected.\n            with open('/proc/cpuinfo', 'rb') as f:\n                cpuinfo_data = f.read()\n            fake_file = io.BytesIO(cpuinfo_data)\n            with mock.patch(\n                'psutil._common.open', return_value=fake_file, create=True\n            ) as m:\n                self.assertEqual(psutil._pslinux.cpu_count_logical(), original)\n\n            # Finally, let's make /proc/cpuinfo return meaningless data;\n            # this way we'll fall back on relying on /proc/stat\n            with mock_open_content({\"/proc/cpuinfo\": b\"\"}) as m:\n                self.assertEqual(psutil._pslinux.cpu_count_logical(), original)\n                assert m.called\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUCountCores(PsutilTestCase):\n    @unittest.skipIf(not which(\"lscpu\"), \"lscpu utility not available\")\n    def test_against_lscpu(self):\n        out = sh(\"lscpu -p\")\n        core_ids = set()\n        for line in out.split('\\n'):\n            if not line.startswith('#'):\n                fields = line.split(',')\n                core_ids.add(fields[1])\n        self.assertEqual(psutil.cpu_count(logical=False), len(core_ids))\n\n    def test_method_2(self):\n        meth_1 = psutil._pslinux.cpu_count_cores()\n        with mock.patch('glob.glob', return_value=[]) as m:\n            meth_2 = psutil._pslinux.cpu_count_cores()\n            assert m.called\n        if meth_1 is not None:\n            self.assertEqual(meth_1, meth_2)\n\n    def test_emulate_none(self):\n        with mock.patch('glob.glob', return_value=[]) as m1:\n            with mock.patch('psutil._common.open', create=True) as m2:\n                self.assertIsNone(psutil._pslinux.cpu_count_cores())\n        assert m1.called\n        assert m2.called\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUFrequency(PsutilTestCase):\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_use_second_file(self):\n        # https://github.com/giampaolo/psutil/issues/981\n        def path_exists_mock(path):\n            if path.startswith(\"/sys/devices/system/cpu/cpufreq/policy\"):\n                return False\n            else:\n                return orig_exists(path)\n\n        orig_exists = os.path.exists\n        with mock.patch(\n            \"os.path.exists\", side_effect=path_exists_mock, create=True\n        ):\n            assert psutil.cpu_freq()\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    @unittest.skipIf(AARCH64, \"aarch64 does not report mhz in /proc/cpuinfo\")\n    def test_emulate_use_cpuinfo(self):\n        # Emulate a case where /sys/devices/system/cpu/cpufreq* does not\n        # exist and /proc/cpuinfo is used instead.\n        def path_exists_mock(path):\n            if path.startswith('/sys/devices/system/cpu/'):\n                return False\n            else:\n                return os_path_exists(path)\n\n        os_path_exists = os.path.exists\n        try:\n            with mock.patch(\"os.path.exists\", side_effect=path_exists_mock):\n                reload_module(psutil._pslinux)\n                ret = psutil.cpu_freq()\n                assert ret, ret\n                self.assertEqual(ret.max, 0.0)\n                self.assertEqual(ret.min, 0.0)\n                for freq in psutil.cpu_freq(percpu=True):\n                    self.assertEqual(freq.max, 0.0)\n                    self.assertEqual(freq.min, 0.0)\n        finally:\n            reload_module(psutil._pslinux)\n            reload_module(psutil)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_data(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('/scaling_cur_freq') and name.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy\"\n            ):\n                return io.BytesIO(b\"500000\")\n            elif name.endswith('/scaling_min_freq') and name.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy\"\n            ):\n                return io.BytesIO(b\"600000\")\n            elif name.endswith('/scaling_max_freq') and name.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy\"\n            ):\n                return io.BytesIO(b\"700000\")\n            elif name == '/proc/cpuinfo':\n                return io.BytesIO(b\"cpu MHz     : 500\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('os.path.exists', return_value=True):\n                freq = psutil.cpu_freq()\n                self.assertEqual(freq.current, 500.0)\n                # when /proc/cpuinfo is used min and max frequencies are not\n                # available and are set to 0.\n                if freq.min != 0.0:\n                    self.assertEqual(freq.min, 600.0)\n                if freq.max != 0.0:\n                    self.assertEqual(freq.max, 700.0)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_multi_cpu(self):\n        def open_mock(name, *args, **kwargs):\n            n = name\n            if n.endswith('/scaling_cur_freq') and n.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy0\"\n            ):\n                return io.BytesIO(b\"100000\")\n            elif n.endswith('/scaling_min_freq') and n.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy0\"\n            ):\n                return io.BytesIO(b\"200000\")\n            elif n.endswith('/scaling_max_freq') and n.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy0\"\n            ):\n                return io.BytesIO(b\"300000\")\n            elif n.endswith('/scaling_cur_freq') and n.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy1\"\n            ):\n                return io.BytesIO(b\"400000\")\n            elif n.endswith('/scaling_min_freq') and n.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy1\"\n            ):\n                return io.BytesIO(b\"500000\")\n            elif n.endswith('/scaling_max_freq') and n.startswith(\n                \"/sys/devices/system/cpu/cpufreq/policy1\"\n            ):\n                return io.BytesIO(b\"600000\")\n            elif name == '/proc/cpuinfo':\n                return io.BytesIO(b\"cpu MHz     : 100\\ncpu MHz     : 400\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('os.path.exists', return_value=True):\n                with mock.patch(\n                    'psutil._pslinux.cpu_count_logical', return_value=2\n                ):\n                    freq = psutil.cpu_freq(percpu=True)\n                    self.assertEqual(freq[0].current, 100.0)\n                    if freq[0].min != 0.0:\n                        self.assertEqual(freq[0].min, 200.0)\n                    if freq[0].max != 0.0:\n                        self.assertEqual(freq[0].max, 300.0)\n                    self.assertEqual(freq[1].current, 400.0)\n                    if freq[1].min != 0.0:\n                        self.assertEqual(freq[1].min, 500.0)\n                    if freq[1].max != 0.0:\n                        self.assertEqual(freq[1].max, 600.0)\n\n    @unittest.skipIf(not HAS_CPU_FREQ, \"not supported\")\n    def test_emulate_no_scaling_cur_freq_file(self):\n        # See: https://github.com/giampaolo/psutil/issues/1071\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('/scaling_cur_freq'):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.endswith('/cpuinfo_cur_freq'):\n                return io.BytesIO(b\"200000\")\n            elif name == '/proc/cpuinfo':\n                return io.BytesIO(b\"cpu MHz     : 200\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('os.path.exists', return_value=True):\n                with mock.patch(\n                    'psutil._pslinux.cpu_count_logical', return_value=1\n                ):\n                    freq = psutil.cpu_freq()\n                    self.assertEqual(freq.current, 200)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemCPUStats(PsutilTestCase):\n    def test_ctx_switches(self):\n        vmstat_value = vmstat(\"context switches\")\n        psutil_value = psutil.cpu_stats().ctx_switches\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=500)\n\n    def test_interrupts(self):\n        vmstat_value = vmstat(\"interrupts\")\n        psutil_value = psutil.cpu_stats().interrupts\n        self.assertAlmostEqual(vmstat_value, psutil_value, delta=500)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestLoadAvg(PsutilTestCase):\n    @unittest.skipIf(not HAS_GETLOADAVG, \"not supported\")\n    def test_getloadavg(self):\n        psutil_value = psutil.getloadavg()\n        with open(\"/proc/loadavg\") as f:\n            proc_value = f.read().split()\n\n        self.assertAlmostEqual(float(proc_value[0]), psutil_value[0], delta=1)\n        self.assertAlmostEqual(float(proc_value[1]), psutil_value[1], delta=1)\n        self.assertAlmostEqual(float(proc_value[2]), psutil_value[2], delta=1)\n\n\n# =====================================================================\n# --- system network\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemNetIfAddrs(PsutilTestCase):\n    def test_ips(self):\n        for name, addrs in psutil.net_if_addrs().items():\n            for addr in addrs:\n                if addr.family == psutil.AF_LINK:\n                    self.assertEqual(addr.address, get_mac_address(name))\n                elif addr.family == socket.AF_INET:\n                    self.assertEqual(addr.address, get_ipv4_address(name))\n                    self.assertEqual(addr.netmask, get_ipv4_netmask(name))\n                    if addr.broadcast is not None:\n                        self.assertEqual(\n                            addr.broadcast, get_ipv4_broadcast(name)\n                        )\n                    else:\n                        self.assertEqual(get_ipv4_broadcast(name), '0.0.0.0')\n                elif addr.family == socket.AF_INET6:\n                    # IPv6 addresses can have a percent symbol at the end.\n                    # E.g. these 2 are equivalent:\n                    # \"fe80::1ff:fe23:4567:890a\"\n                    # \"fe80::1ff:fe23:4567:890a%eth0\"\n                    # That is the \"zone id\" portion, which usually is the name\n                    # of the network interface.\n                    address = addr.address.split('%')[0]\n                    self.assertIn(address, get_ipv6_addresses(name))\n\n    # XXX - not reliable when having virtual NICs installed by Docker.\n    # @unittest.skipIf(not which('ip'), \"'ip' utility not available\")\n    # def test_net_if_names(self):\n    #     out = sh(\"ip addr\").strip()\n    #     nics = [x for x in psutil.net_if_addrs().keys() if ':' not in x]\n    #     found = 0\n    #     for line in out.split('\\n'):\n    #         line = line.strip()\n    #         if re.search(r\"^\\d+:\", line):\n    #             found += 1\n    #             name = line.split(':')[1].strip()\n    #             self.assertIn(name, nics)\n    #     self.assertEqual(len(nics), found, msg=\"%s\\n---\\n%s\" % (\n    #         pprint.pformat(nics), out))\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\n@unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\nclass TestSystemNetIfStats(PsutilTestCase):\n    @unittest.skipIf(not which(\"ifconfig\"), \"ifconfig utility not available\")\n    def test_against_ifconfig(self):\n        for name, stats in psutil.net_if_stats().items():\n            try:\n                out = sh(\"ifconfig %s\" % name)\n            except RuntimeError:\n                pass\n            else:\n                self.assertEqual(stats.isup, 'RUNNING' in out, msg=out)\n                self.assertEqual(\n                    stats.mtu, int(re.findall(r'(?i)MTU[: ](\\d+)', out)[0])\n                )\n\n    def test_mtu(self):\n        for name, stats in psutil.net_if_stats().items():\n            with open(\"/sys/class/net/%s/mtu\" % name) as f:\n                self.assertEqual(stats.mtu, int(f.read().strip()))\n\n    @unittest.skipIf(not which(\"ifconfig\"), \"ifconfig utility not available\")\n    def test_flags(self):\n        # first line looks like this:\n        # \"eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500\"\n        matches_found = 0\n        for name, stats in psutil.net_if_stats().items():\n            try:\n                out = sh(\"ifconfig %s\" % name)\n            except RuntimeError:\n                pass\n            else:\n                match = re.search(r\"flags=(\\d+)?<(.*?)>\", out)\n                if match and len(match.groups()) >= 2:\n                    matches_found += 1\n                    ifconfig_flags = set(match.group(2).lower().split(\",\"))\n                    psutil_flags = set(stats.flags.split(\",\"))\n                    self.assertEqual(ifconfig_flags, psutil_flags)\n                else:\n                    # ifconfig has a different output on CentOS 6\n                    # let's try that\n                    match = re.search(r\"(.*)  MTU:(\\d+)  Metric:(\\d+)\", out)\n                    if match and len(match.groups()) >= 3:\n                        matches_found += 1\n                        ifconfig_flags = set(match.group(1).lower().split())\n                        psutil_flags = set(stats.flags.split(\",\"))\n                        self.assertEqual(ifconfig_flags, psutil_flags)\n\n        if not matches_found:\n            raise self.fail(\"no matches were found\")\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemNetIOCounters(PsutilTestCase):\n    @unittest.skipIf(not which(\"ifconfig\"), \"ifconfig utility not available\")\n    @retry_on_failure()\n    def test_against_ifconfig(self):\n        def ifconfig(nic):\n            ret = {}\n            out = sh(\"ifconfig %s\" % nic)\n            ret['packets_recv'] = int(\n                re.findall(r'RX packets[: ](\\d+)', out)[0]\n            )\n            ret['packets_sent'] = int(\n                re.findall(r'TX packets[: ](\\d+)', out)[0]\n            )\n            ret['errin'] = int(re.findall(r'errors[: ](\\d+)', out)[0])\n            ret['errout'] = int(re.findall(r'errors[: ](\\d+)', out)[1])\n            ret['dropin'] = int(re.findall(r'dropped[: ](\\d+)', out)[0])\n            ret['dropout'] = int(re.findall(r'dropped[: ](\\d+)', out)[1])\n            ret['bytes_recv'] = int(\n                re.findall(r'RX (?:packets \\d+ +)?bytes[: ](\\d+)', out)[0]\n            )\n            ret['bytes_sent'] = int(\n                re.findall(r'TX (?:packets \\d+ +)?bytes[: ](\\d+)', out)[0]\n            )\n            return ret\n\n        nio = psutil.net_io_counters(pernic=True, nowrap=False)\n        for name, stats in nio.items():\n            try:\n                ifconfig_ret = ifconfig(name)\n            except RuntimeError:\n                continue\n            self.assertAlmostEqual(\n                stats.bytes_recv, ifconfig_ret['bytes_recv'], delta=1024 * 10\n            )\n            self.assertAlmostEqual(\n                stats.bytes_sent, ifconfig_ret['bytes_sent'], delta=1024 * 10\n            )\n            self.assertAlmostEqual(\n                stats.packets_recv, ifconfig_ret['packets_recv'], delta=1024\n            )\n            self.assertAlmostEqual(\n                stats.packets_sent, ifconfig_ret['packets_sent'], delta=1024\n            )\n            self.assertAlmostEqual(\n                stats.errin, ifconfig_ret['errin'], delta=10\n            )\n            self.assertAlmostEqual(\n                stats.errout, ifconfig_ret['errout'], delta=10\n            )\n            self.assertAlmostEqual(\n                stats.dropin, ifconfig_ret['dropin'], delta=10\n            )\n            self.assertAlmostEqual(\n                stats.dropout, ifconfig_ret['dropout'], delta=10\n            )\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemNetConnections(PsutilTestCase):\n    @mock.patch('psutil._pslinux.socket.inet_ntop', side_effect=ValueError)\n    @mock.patch('psutil._pslinux.supports_ipv6', return_value=False)\n    def test_emulate_ipv6_unsupported(self, supports_ipv6, inet_ntop):\n        # see: https://github.com/giampaolo/psutil/issues/623\n        try:\n            s = socket.socket(socket.AF_INET6, socket.SOCK_STREAM)\n            self.addCleanup(s.close)\n            s.bind((\"::1\", 0))\n        except socket.error:\n            pass\n        psutil.net_connections(kind='inet6')\n\n    def test_emulate_unix(self):\n        content = textwrap.dedent(\"\"\"\\\n            0: 00000003 000 000 0001 03 462170 @/tmp/dbus-Qw2hMPIU3n\n            0: 00000003 000 000 0001 03 35010 @/tmp/dbus-tB2X8h69BQ\n            0: 00000003 000 000 0001 03 34424 @/tmp/dbus-cHy80Y8O\n            000000000000000000000000000000000000000000000000000000\n            \"\"\")\n        with mock_open_content({\"/proc/net/unix\": content}) as m:\n            psutil.net_connections(kind='unix')\n            assert m.called\n\n\n# =====================================================================\n# --- system disks\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemDiskPartitions(PsutilTestCase):\n    @unittest.skipIf(not hasattr(os, 'statvfs'), \"os.statvfs() not available\")\n    @skip_on_not_implemented()\n    def test_against_df(self):\n        # test psutil.disk_usage() and psutil.disk_partitions()\n        # against \"df -a\"\n        def df(path):\n            out = sh('df -P -B 1 \"%s\"' % path).strip()\n            lines = out.split('\\n')\n            lines.pop(0)\n            line = lines.pop(0)\n            dev, total, used, free = line.split()[:4]\n            if dev == 'none':\n                dev = ''\n            total, used, free = int(total), int(used), int(free)\n            return dev, total, used, free\n\n        for part in psutil.disk_partitions(all=False):\n            usage = psutil.disk_usage(part.mountpoint)\n            _, total, used, free = df(part.mountpoint)\n            self.assertEqual(usage.total, total)\n            self.assertAlmostEqual(\n                usage.free, free, delta=TOLERANCE_DISK_USAGE\n            )\n            self.assertAlmostEqual(\n                usage.used, used, delta=TOLERANCE_DISK_USAGE\n            )\n\n    def test_zfs_fs(self):\n        # Test that ZFS partitions are returned.\n        with open(\"/proc/filesystems\") as f:\n            data = f.read()\n        if 'zfs' in data:\n            for part in psutil.disk_partitions():\n                if part.fstype == 'zfs':\n                    break\n            else:\n                raise self.fail(\"couldn't find any ZFS partition\")\n        else:\n            # No ZFS partitions on this system. Let's fake one.\n            fake_file = io.StringIO(u\"nodev\\tzfs\\n\")\n            with mock.patch(\n                'psutil._common.open', return_value=fake_file, create=True\n            ) as m1:\n                with mock.patch(\n                    'psutil._pslinux.cext.disk_partitions',\n                    return_value=[('/dev/sdb3', '/', 'zfs', 'rw')],\n                ) as m2:\n                    ret = psutil.disk_partitions()\n                    assert m1.called\n                    assert m2.called\n                    assert ret\n                    self.assertEqual(ret[0].fstype, 'zfs')\n\n    def test_emulate_realpath_fail(self):\n        # See: https://github.com/giampaolo/psutil/issues/1307\n        try:\n            with mock.patch(\n                'os.path.realpath', return_value='/non/existent'\n            ) as m:\n                with self.assertRaises(FileNotFoundError):\n                    psutil.disk_partitions()\n                assert m.called\n        finally:\n            psutil.PROCFS_PATH = \"/proc\"\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSystemDiskIoCounters(PsutilTestCase):\n    def test_emulate_kernel_2_4(self):\n        # Tests /proc/diskstats parsing format for 2.4 kernels, see:\n        # https://github.com/giampaolo/psutil/issues/767\n        content = \"   3     0   1 hda 2 3 4 5 6 7 8 9 10 11 12\"\n        with mock_open_content({'/proc/diskstats': content}):\n            with mock.patch(\n                'psutil._pslinux.is_storage_device', return_value=True\n            ):\n                ret = psutil.disk_io_counters(nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.read_merged_count, 2)\n                self.assertEqual(ret.read_bytes, 3 * SECTOR_SIZE)\n                self.assertEqual(ret.read_time, 4)\n                self.assertEqual(ret.write_count, 5)\n                self.assertEqual(ret.write_merged_count, 6)\n                self.assertEqual(ret.write_bytes, 7 * SECTOR_SIZE)\n                self.assertEqual(ret.write_time, 8)\n                self.assertEqual(ret.busy_time, 10)\n\n    def test_emulate_kernel_2_6_full(self):\n        # Tests /proc/diskstats parsing format for 2.6 kernels,\n        # lines reporting all metrics:\n        # https://github.com/giampaolo/psutil/issues/767\n        content = \"   3    0   hda 1 2 3 4 5 6 7 8 9 10 11\"\n        with mock_open_content({\"/proc/diskstats\": content}):\n            with mock.patch(\n                'psutil._pslinux.is_storage_device', return_value=True\n            ):\n                ret = psutil.disk_io_counters(nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.read_merged_count, 2)\n                self.assertEqual(ret.read_bytes, 3 * SECTOR_SIZE)\n                self.assertEqual(ret.read_time, 4)\n                self.assertEqual(ret.write_count, 5)\n                self.assertEqual(ret.write_merged_count, 6)\n                self.assertEqual(ret.write_bytes, 7 * SECTOR_SIZE)\n                self.assertEqual(ret.write_time, 8)\n                self.assertEqual(ret.busy_time, 10)\n\n    def test_emulate_kernel_2_6_limited(self):\n        # Tests /proc/diskstats parsing format for 2.6 kernels,\n        # where one line of /proc/partitions return a limited\n        # amount of metrics when it bumps into a partition\n        # (instead of a disk). See:\n        # https://github.com/giampaolo/psutil/issues/767\n        with mock_open_content({\"/proc/diskstats\": \"   3    1   hda 1 2 3 4\"}):\n            with mock.patch(\n                'psutil._pslinux.is_storage_device', return_value=True\n            ):\n                ret = psutil.disk_io_counters(nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.read_bytes, 2 * SECTOR_SIZE)\n                self.assertEqual(ret.write_count, 3)\n                self.assertEqual(ret.write_bytes, 4 * SECTOR_SIZE)\n\n                self.assertEqual(ret.read_merged_count, 0)\n                self.assertEqual(ret.read_time, 0)\n                self.assertEqual(ret.write_merged_count, 0)\n                self.assertEqual(ret.write_time, 0)\n                self.assertEqual(ret.busy_time, 0)\n\n    def test_emulate_include_partitions(self):\n        # Make sure that when perdisk=True disk partitions are returned,\n        # see:\n        # https://github.com/giampaolo/psutil/pull/1313#issuecomment-408626842\n        content = textwrap.dedent(\"\"\"\\\n            3    0   nvme0n1 1 2 3 4 5 6 7 8 9 10 11\n            3    0   nvme0n1p1 1 2 3 4 5 6 7 8 9 10 11\n            \"\"\")\n        with mock_open_content({\"/proc/diskstats\": content}):\n            with mock.patch(\n                'psutil._pslinux.is_storage_device', return_value=False\n            ):\n                ret = psutil.disk_io_counters(perdisk=True, nowrap=False)\n                self.assertEqual(len(ret), 2)\n                self.assertEqual(ret['nvme0n1'].read_count, 1)\n                self.assertEqual(ret['nvme0n1p1'].read_count, 1)\n                self.assertEqual(ret['nvme0n1'].write_count, 5)\n                self.assertEqual(ret['nvme0n1p1'].write_count, 5)\n\n    def test_emulate_exclude_partitions(self):\n        # Make sure that when perdisk=False partitions (e.g. 'sda1',\n        # 'nvme0n1p1') are skipped and not included in the total count.\n        # https://github.com/giampaolo/psutil/pull/1313#issuecomment-408626842\n        content = textwrap.dedent(\"\"\"\\\n            3    0   nvme0n1 1 2 3 4 5 6 7 8 9 10 11\n            3    0   nvme0n1p1 1 2 3 4 5 6 7 8 9 10 11\n            \"\"\")\n        with mock_open_content({\"/proc/diskstats\": content}):\n            with mock.patch(\n                'psutil._pslinux.is_storage_device', return_value=False\n            ):\n                ret = psutil.disk_io_counters(perdisk=False, nowrap=False)\n                self.assertIsNone(ret)\n\n        def is_storage_device(name):\n            return name == 'nvme0n1'\n\n        content = textwrap.dedent(\"\"\"\\\n            3    0   nvme0n1 1 2 3 4 5 6 7 8 9 10 11\n            3    0   nvme0n1p1 1 2 3 4 5 6 7 8 9 10 11\n            \"\"\")\n        with mock_open_content({\"/proc/diskstats\": content}):\n            with mock.patch(\n                'psutil._pslinux.is_storage_device',\n                create=True,\n                side_effect=is_storage_device,\n            ):\n                ret = psutil.disk_io_counters(perdisk=False, nowrap=False)\n                self.assertEqual(ret.read_count, 1)\n                self.assertEqual(ret.write_count, 5)\n\n    def test_emulate_use_sysfs(self):\n        def exists(path):\n            return path == '/proc/diskstats'\n\n        wprocfs = psutil.disk_io_counters(perdisk=True)\n        with mock.patch(\n            'psutil._pslinux.os.path.exists', create=True, side_effect=exists\n        ):\n            wsysfs = psutil.disk_io_counters(perdisk=True)\n        self.assertEqual(len(wprocfs), len(wsysfs))\n\n    def test_emulate_not_impl(self):\n        def exists(path):\n            return False\n\n        with mock.patch(\n            'psutil._pslinux.os.path.exists', create=True, side_effect=exists\n        ):\n            self.assertRaises(NotImplementedError, psutil.disk_io_counters)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestRootFsDeviceFinder(PsutilTestCase):\n    def setUp(self):\n        dev = os.stat(\"/\").st_dev\n        self.major = os.major(dev)\n        self.minor = os.minor(dev)\n\n    def test_call_methods(self):\n        finder = RootFsDeviceFinder()\n        if os.path.exists(\"/proc/partitions\"):\n            finder.ask_proc_partitions()\n        else:\n            self.assertRaises(FileNotFoundError, finder.ask_proc_partitions)\n        if os.path.exists(\n            \"/sys/dev/block/%s:%s/uevent\" % (self.major, self.minor)\n        ):\n            finder.ask_sys_dev_block()\n        else:\n            self.assertRaises(FileNotFoundError, finder.ask_sys_dev_block)\n        finder.ask_sys_class_block()\n\n    @unittest.skipIf(GITHUB_ACTIONS, \"unsupported on GITHUB_ACTIONS\")\n    def test_comparisons(self):\n        finder = RootFsDeviceFinder()\n        self.assertIsNotNone(finder.find())\n\n        a = b = c = None\n        if os.path.exists(\"/proc/partitions\"):\n            a = finder.ask_proc_partitions()\n        if os.path.exists(\n            \"/sys/dev/block/%s:%s/uevent\" % (self.major, self.minor)\n        ):\n            b = finder.ask_sys_class_block()\n        c = finder.ask_sys_dev_block()\n\n        base = a or b or c\n        if base and a:\n            self.assertEqual(base, a)\n        if base and b:\n            self.assertEqual(base, b)\n        if base and c:\n            self.assertEqual(base, c)\n\n    @unittest.skipIf(not which(\"findmnt\"), \"findmnt utility not available\")\n    @unittest.skipIf(GITHUB_ACTIONS, \"unsupported on GITHUB_ACTIONS\")\n    def test_against_findmnt(self):\n        psutil_value = RootFsDeviceFinder().find()\n        findmnt_value = sh(\"findmnt -o SOURCE -rn /\")\n        self.assertEqual(psutil_value, findmnt_value)\n\n    def test_disk_partitions_mocked(self):\n        with mock.patch(\n            'psutil._pslinux.cext.disk_partitions',\n            return_value=[('/dev/root', '/', 'ext4', 'rw')],\n        ) as m:\n            part = psutil.disk_partitions()[0]\n            assert m.called\n            if not GITHUB_ACTIONS:\n                self.assertNotEqual(part.device, \"/dev/root\")\n                self.assertEqual(part.device, RootFsDeviceFinder().find())\n            else:\n                self.assertEqual(part.device, \"/dev/root\")\n\n\n# =====================================================================\n# --- misc\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestMisc(PsutilTestCase):\n    def test_boot_time(self):\n        vmstat_value = vmstat('boot time')\n        psutil_value = psutil.boot_time()\n        self.assertEqual(int(vmstat_value), int(psutil_value))\n\n    def test_no_procfs_on_import(self):\n        my_procfs = self.get_testfn()\n        os.mkdir(my_procfs)\n\n        with open(os.path.join(my_procfs, 'stat'), 'w') as f:\n            f.write('cpu   0 0 0 0 0 0 0 0 0 0\\n')\n            f.write('cpu0  0 0 0 0 0 0 0 0 0 0\\n')\n            f.write('cpu1  0 0 0 0 0 0 0 0 0 0\\n')\n\n        try:\n            orig_open = open\n\n            def open_mock(name, *args, **kwargs):\n                if name.startswith('/proc'):\n                    raise IOError(errno.ENOENT, 'rejecting access for test')\n                return orig_open(name, *args, **kwargs)\n\n            patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n            with mock.patch(patch_point, side_effect=open_mock):\n                reload_module(psutil)\n\n                self.assertRaises(IOError, psutil.cpu_times)\n                self.assertRaises(IOError, psutil.cpu_times, percpu=True)\n                self.assertRaises(IOError, psutil.cpu_percent)\n                self.assertRaises(IOError, psutil.cpu_percent, percpu=True)\n                self.assertRaises(IOError, psutil.cpu_times_percent)\n                self.assertRaises(\n                    IOError, psutil.cpu_times_percent, percpu=True\n                )\n\n                psutil.PROCFS_PATH = my_procfs\n\n                self.assertEqual(psutil.cpu_percent(), 0)\n                self.assertEqual(sum(psutil.cpu_times_percent()), 0)\n\n                # since we don't know the number of CPUs at import time,\n                # we awkwardly say there are none until the second call\n                per_cpu_percent = psutil.cpu_percent(percpu=True)\n                self.assertEqual(sum(per_cpu_percent), 0)\n\n                # ditto awkward length\n                per_cpu_times_percent = psutil.cpu_times_percent(percpu=True)\n                self.assertEqual(sum(map(sum, per_cpu_times_percent)), 0)\n\n                # much user, very busy\n                with open(os.path.join(my_procfs, 'stat'), 'w') as f:\n                    f.write('cpu   1 0 0 0 0 0 0 0 0 0\\n')\n                    f.write('cpu0  1 0 0 0 0 0 0 0 0 0\\n')\n                    f.write('cpu1  1 0 0 0 0 0 0 0 0 0\\n')\n\n                self.assertNotEqual(psutil.cpu_percent(), 0)\n                self.assertNotEqual(sum(psutil.cpu_percent(percpu=True)), 0)\n                self.assertNotEqual(sum(psutil.cpu_times_percent()), 0)\n                self.assertNotEqual(\n                    sum(map(sum, psutil.cpu_times_percent(percpu=True))), 0\n                )\n        finally:\n            shutil.rmtree(my_procfs)\n            reload_module(psutil)\n\n        self.assertEqual(psutil.PROCFS_PATH, '/proc')\n\n    def test_cpu_steal_decrease(self):\n        # Test cumulative cpu stats decrease. We should ignore this.\n        # See issue #1210.\n        content = textwrap.dedent(\"\"\"\\\n            cpu   0 0 0 0 0 0 0 1 0 0\n            cpu0  0 0 0 0 0 0 0 1 0 0\n            cpu1  0 0 0 0 0 0 0 1 0 0\n            \"\"\").encode()\n        with mock_open_content({\"/proc/stat\": content}) as m:\n            # first call to \"percent\" functions should read the new stat file\n            # and compare to the \"real\" file read at import time - so the\n            # values are meaningless\n            psutil.cpu_percent()\n            assert m.called\n            psutil.cpu_percent(percpu=True)\n            psutil.cpu_times_percent()\n            psutil.cpu_times_percent(percpu=True)\n\n        content = textwrap.dedent(\"\"\"\\\n            cpu   1 0 0 0 0 0 0 0 0 0\n            cpu0  1 0 0 0 0 0 0 0 0 0\n            cpu1  1 0 0 0 0 0 0 0 0 0\n            \"\"\").encode()\n        with mock_open_content({\"/proc/stat\": content}):\n            # Increase \"user\" while steal goes \"backwards\" to zero.\n            cpu_percent = psutil.cpu_percent()\n            assert m.called\n            cpu_percent_percpu = psutil.cpu_percent(percpu=True)\n            cpu_times_percent = psutil.cpu_times_percent()\n            cpu_times_percent_percpu = psutil.cpu_times_percent(percpu=True)\n            self.assertNotEqual(cpu_percent, 0)\n            self.assertNotEqual(sum(cpu_percent_percpu), 0)\n            self.assertNotEqual(sum(cpu_times_percent), 0)\n            self.assertNotEqual(sum(cpu_times_percent), 100.0)\n            self.assertNotEqual(sum(map(sum, cpu_times_percent_percpu)), 0)\n            self.assertNotEqual(sum(map(sum, cpu_times_percent_percpu)), 100.0)\n            self.assertEqual(cpu_times_percent.steal, 0)\n            self.assertNotEqual(cpu_times_percent.user, 0)\n\n    def test_boot_time_mocked(self):\n        with mock.patch('psutil._common.open', create=True) as m:\n            self.assertRaises(RuntimeError, psutil._pslinux.boot_time)\n            assert m.called\n\n    def test_users(self):\n        # Make sure the C extension converts ':0' and ':0.0' to\n        # 'localhost'.\n        for user in psutil.users():\n            self.assertNotIn(user.host, (\":0\", \":0.0\"))\n\n    def test_procfs_path(self):\n        tdir = self.get_testfn()\n        os.mkdir(tdir)\n        try:\n            psutil.PROCFS_PATH = tdir\n            self.assertRaises(IOError, psutil.virtual_memory)\n            self.assertRaises(IOError, psutil.cpu_times)\n            self.assertRaises(IOError, psutil.cpu_times, percpu=True)\n            self.assertRaises(IOError, psutil.boot_time)\n            # self.assertRaises(IOError, psutil.pids)\n            self.assertRaises(IOError, psutil.net_connections)\n            self.assertRaises(IOError, psutil.net_io_counters)\n            self.assertRaises(IOError, psutil.net_if_stats)\n            # self.assertRaises(IOError, psutil.disk_io_counters)\n            self.assertRaises(IOError, psutil.disk_partitions)\n            self.assertRaises(psutil.NoSuchProcess, psutil.Process)\n        finally:\n            psutil.PROCFS_PATH = \"/proc\"\n\n    @retry_on_failure()\n    def test_issue_687(self):\n        # In case of thread ID:\n        # - pid_exists() is supposed to return False\n        # - Process(tid) is supposed to work\n        # - pids() should not return the TID\n        # See: https://github.com/giampaolo/psutil/issues/687\n        with ThreadTask():\n            p = psutil.Process()\n            threads = p.threads()\n            self.assertEqual(len(threads), 3 if QEMU_USER else 2)\n            tid = sorted(threads, key=lambda x: x.id)[1].id\n            self.assertNotEqual(p.pid, tid)\n            pt = psutil.Process(tid)\n            pt.as_dict()\n            self.assertNotIn(tid, psutil.pids())\n\n    def test_pid_exists_no_proc_status(self):\n        # Internally pid_exists relies on /proc/{pid}/status.\n        # Emulate a case where this file is empty in which case\n        # psutil is supposed to fall back on using pids().\n        with mock_open_content({\"/proc/%s/status\": \"\"}) as m:\n            assert psutil.pid_exists(os.getpid())\n            assert m.called\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\n@unittest.skipIf(not HAS_BATTERY, \"no battery\")\nclass TestSensorsBattery(PsutilTestCase):\n    @unittest.skipIf(not which(\"acpi\"), \"acpi utility not available\")\n    def test_percent(self):\n        out = sh(\"acpi -b\")\n        acpi_value = int(out.split(\",\")[1].strip().replace('%', ''))\n        psutil_value = psutil.sensors_battery().percent\n        self.assertAlmostEqual(acpi_value, psutil_value, delta=1)\n\n    def test_emulate_power_plugged(self):\n        # Pretend the AC power cable is connected.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(('AC0/online', 'AC/online')):\n                return io.BytesIO(b\"1\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, True)\n            self.assertEqual(\n                psutil.sensors_battery().secsleft, psutil.POWER_TIME_UNLIMITED\n            )\n            assert m.called\n\n    def test_emulate_power_plugged_2(self):\n        # Same as above but pretend /AC0/online does not exist in which\n        # case code relies on /status file.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(('AC0/online', 'AC/online')):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.endswith(\"/status\"):\n                return io.StringIO(u\"charging\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, True)\n            assert m.called\n\n    def test_emulate_power_not_plugged(self):\n        # Pretend the AC power cable is not connected.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(('AC0/online', 'AC/online')):\n                return io.BytesIO(b\"0\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, False)\n            assert m.called\n\n    def test_emulate_power_not_plugged_2(self):\n        # Same as above but pretend /AC0/online does not exist in which\n        # case code relies on /status file.\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(('AC0/online', 'AC/online')):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.endswith(\"/status\"):\n                return io.StringIO(u\"discharging\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertEqual(psutil.sensors_battery().power_plugged, False)\n            assert m.called\n\n    def test_emulate_power_undetermined(self):\n        # Pretend we can't know whether the AC power cable not\n        # connected (assert fallback to False).\n        def open_mock(name, *args, **kwargs):\n            if name.startswith((\n                '/sys/class/power_supply/AC0/online',\n                '/sys/class/power_supply/AC/online',\n            )):\n                raise IOError(errno.ENOENT, \"\")\n            elif name.startswith(\"/sys/class/power_supply/BAT0/status\"):\n                return io.BytesIO(b\"???\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock) as m:\n            self.assertIsNone(psutil.sensors_battery().power_plugged)\n            assert m.called\n\n    def test_emulate_energy_full_0(self):\n        # Emulate a case where energy_full files returns 0.\n        with mock_open_content(\n            {\"/sys/class/power_supply/BAT0/energy_full\": b\"0\"}\n        ) as m:\n            self.assertEqual(psutil.sensors_battery().percent, 0)\n            assert m.called\n\n    def test_emulate_energy_full_not_avail(self):\n        # Emulate a case where energy_full file does not exist.\n        # Expected fallback on /capacity.\n        with mock_open_exception(\n            \"/sys/class/power_supply/BAT0/energy_full\",\n            IOError(errno.ENOENT, \"\"),\n        ):\n            with mock_open_exception(\n                \"/sys/class/power_supply/BAT0/charge_full\",\n                IOError(errno.ENOENT, \"\"),\n            ):\n                with mock_open_content(\n                    {\"/sys/class/power_supply/BAT0/capacity\": b\"88\"}\n                ):\n                    self.assertEqual(psutil.sensors_battery().percent, 88)\n\n    def test_emulate_no_power(self):\n        # Emulate a case where /AC0/online file nor /BAT0/status exist.\n        with mock_open_exception(\n            \"/sys/class/power_supply/AC/online\", IOError(errno.ENOENT, \"\")\n        ):\n            with mock_open_exception(\n                \"/sys/class/power_supply/AC0/online\", IOError(errno.ENOENT, \"\")\n            ):\n                with mock_open_exception(\n                    \"/sys/class/power_supply/BAT0/status\",\n                    IOError(errno.ENOENT, \"\"),\n                ):\n                    self.assertIsNone(psutil.sensors_battery().power_plugged)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSensorsBatteryEmulated(PsutilTestCase):\n    def test_it(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith(\"/energy_now\"):\n                return io.StringIO(u\"60000000\")\n            elif name.endswith(\"/power_now\"):\n                return io.StringIO(u\"0\")\n            elif name.endswith(\"/energy_full\"):\n                return io.StringIO(u\"60000001\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch('os.listdir', return_value=[\"BAT0\"]) as mlistdir:\n            with mock.patch(patch_point, side_effect=open_mock) as mopen:\n                self.assertIsNotNone(psutil.sensors_battery())\n        assert mlistdir.called\n        assert mopen.called\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSensorsTemperatures(PsutilTestCase):\n    def test_emulate_class_hwmon(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('/name'):\n                return io.StringIO(u\"name\")\n            elif name.endswith('/temp1_label'):\n                return io.StringIO(u\"label\")\n            elif name.endswith('/temp1_input'):\n                return io.BytesIO(b\"30000\")\n            elif name.endswith('/temp1_max'):\n                return io.BytesIO(b\"40000\")\n            elif name.endswith('/temp1_crit'):\n                return io.BytesIO(b\"50000\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            # Test case with /sys/class/hwmon\n            with mock.patch(\n                'glob.glob', return_value=['/sys/class/hwmon/hwmon0/temp1']\n            ):\n                temp = psutil.sensors_temperatures()['name'][0]\n                self.assertEqual(temp.label, 'label')\n                self.assertEqual(temp.current, 30.0)\n                self.assertEqual(temp.high, 40.0)\n                self.assertEqual(temp.critical, 50.0)\n\n    def test_emulate_class_thermal(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('0_temp'):\n                return io.BytesIO(b\"50000\")\n            elif name.endswith('temp'):\n                return io.BytesIO(b\"30000\")\n            elif name.endswith('0_type'):\n                return io.StringIO(u\"critical\")\n            elif name.endswith('type'):\n                return io.StringIO(u\"name\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        def glob_mock(path):\n            if path == '/sys/class/hwmon/hwmon*/temp*_*':  # noqa\n                return []\n            elif path == '/sys/class/hwmon/hwmon*/device/temp*_*':\n                return []\n            elif path == '/sys/class/thermal/thermal_zone*':\n                return ['/sys/class/thermal/thermal_zone0']\n            elif path == '/sys/class/thermal/thermal_zone0/trip_point*':\n                return [\n                    '/sys/class/thermal/thermal_zone1/trip_point_0_type',\n                    '/sys/class/thermal/thermal_zone1/trip_point_0_temp',\n                ]\n            return []\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch('glob.glob', create=True, side_effect=glob_mock):\n                temp = psutil.sensors_temperatures()['name'][0]\n                self.assertEqual(temp.label, '')\n                self.assertEqual(temp.current, 30.0)\n                self.assertEqual(temp.high, 50.0)\n                self.assertEqual(temp.critical, 50.0)\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestSensorsFans(PsutilTestCase):\n    def test_emulate_data(self):\n        def open_mock(name, *args, **kwargs):\n            if name.endswith('/name'):\n                return io.StringIO(u\"name\")\n            elif name.endswith('/fan1_label'):\n                return io.StringIO(u\"label\")\n            elif name.endswith('/fan1_input'):\n                return io.StringIO(u\"2000\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock):\n            with mock.patch(\n                'glob.glob', return_value=['/sys/class/hwmon/hwmon2/fan1']\n            ):\n                fan = psutil.sensors_fans()['name'][0]\n                self.assertEqual(fan.label, 'label')\n                self.assertEqual(fan.current, 2000)\n\n\n# =====================================================================\n# --- test process\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestProcess(PsutilTestCase):\n    @retry_on_failure()\n    def test_parse_smaps_vs_memory_maps(self):\n        sproc = self.spawn_testproc()\n        uss, pss, swap = psutil._pslinux.Process(sproc.pid)._parse_smaps()\n        maps = psutil.Process(sproc.pid).memory_maps(grouped=False)\n        self.assertAlmostEqual(\n            uss,\n            sum([x.private_dirty + x.private_clean for x in maps]),\n            delta=4096,\n        )\n        self.assertAlmostEqual(pss, sum([x.pss for x in maps]), delta=4096)\n        self.assertAlmostEqual(swap, sum([x.swap for x in maps]), delta=4096)\n\n    def test_parse_smaps_mocked(self):\n        # See: https://github.com/giampaolo/psutil/issues/1222\n        content = textwrap.dedent(\"\"\"\\\n            fffff0 r-xp 00000000 00:00 0                  [vsyscall]\n            Size:                  1 kB\n            Rss:                   2 kB\n            Pss:                   3 kB\n            Shared_Clean:          4 kB\n            Shared_Dirty:          5 kB\n            Private_Clean:         6 kB\n            Private_Dirty:         7 kB\n            Referenced:            8 kB\n            Anonymous:             9 kB\n            LazyFree:              10 kB\n            AnonHugePages:         11 kB\n            ShmemPmdMapped:        12 kB\n            Shared_Hugetlb:        13 kB\n            Private_Hugetlb:       14 kB\n            Swap:                  15 kB\n            SwapPss:               16 kB\n            KernelPageSize:        17 kB\n            MMUPageSize:           18 kB\n            Locked:                19 kB\n            VmFlags: rd ex\n            \"\"\").encode()\n        with mock_open_content({\"/proc/%s/smaps\" % os.getpid(): content}) as m:\n            p = psutil._pslinux.Process(os.getpid())\n            uss, pss, swap = p._parse_smaps()\n            assert m.called\n            self.assertEqual(uss, (6 + 7 + 14) * 1024)\n            self.assertEqual(pss, 3 * 1024)\n            self.assertEqual(swap, 15 * 1024)\n\n    # On PYPY file descriptors are not closed fast enough.\n    @unittest.skipIf(PYPY, \"unreliable on PYPY\")\n    def test_open_files_mode(self):\n        def get_test_file(fname):\n            p = psutil.Process()\n            giveup_at = time.time() + GLOBAL_TIMEOUT\n            while True:\n                for file in p.open_files():\n                    if file.path == os.path.abspath(fname):\n                        return file\n                    elif time.time() > giveup_at:\n                        break\n            raise RuntimeError(\"timeout looking for test file\")\n\n        testfn = self.get_testfn()\n        with open(testfn, \"w\"):\n            self.assertEqual(get_test_file(testfn).mode, \"w\")\n        with open(testfn):\n            self.assertEqual(get_test_file(testfn).mode, \"r\")\n        with open(testfn, \"a\"):\n            self.assertEqual(get_test_file(testfn).mode, \"a\")\n        with open(testfn, \"r+\"):\n            self.assertEqual(get_test_file(testfn).mode, \"r+\")\n        with open(testfn, \"w+\"):\n            self.assertEqual(get_test_file(testfn).mode, \"r+\")\n        with open(testfn, \"a+\"):\n            self.assertEqual(get_test_file(testfn).mode, \"a+\")\n        # note: \"x\" bit is not supported\n        if PY3:\n            safe_rmpath(testfn)\n            with open(testfn, \"x\"):\n                self.assertEqual(get_test_file(testfn).mode, \"w\")\n            safe_rmpath(testfn)\n            with open(testfn, \"x+\"):\n                self.assertEqual(get_test_file(testfn).mode, \"r+\")\n\n    def test_open_files_file_gone(self):\n        # simulates a file which gets deleted during open_files()\n        # execution\n        p = psutil.Process()\n        files = p.open_files()\n        with open(self.get_testfn(), 'w'):\n            # give the kernel some time to see the new file\n            call_until(p.open_files, \"len(ret) != %i\" % len(files))\n            with mock.patch(\n                'psutil._pslinux.os.readlink',\n                side_effect=OSError(errno.ENOENT, \"\"),\n            ) as m:\n                self.assertEqual(p.open_files(), [])\n                assert m.called\n            # also simulate the case where os.readlink() returns EINVAL\n            # in which case psutil is supposed to 'continue'\n            with mock.patch(\n                'psutil._pslinux.os.readlink',\n                side_effect=OSError(errno.EINVAL, \"\"),\n            ) as m:\n                self.assertEqual(p.open_files(), [])\n                assert m.called\n\n    def test_open_files_fd_gone(self):\n        # Simulate a case where /proc/{pid}/fdinfo/{fd} disappears\n        # while iterating through fds.\n        # https://travis-ci.org/giampaolo/psutil/jobs/225694530\n        p = psutil.Process()\n        files = p.open_files()\n        with open(self.get_testfn(), 'w'):\n            # give the kernel some time to see the new file\n            call_until(p.open_files, \"len(ret) != %i\" % len(files))\n            patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n            with mock.patch(\n                patch_point, side_effect=IOError(errno.ENOENT, \"\")\n            ) as m:\n                self.assertEqual(p.open_files(), [])\n                assert m.called\n\n    def test_open_files_enametoolong(self):\n        # Simulate a case where /proc/{pid}/fd/{fd} symlink\n        # points to a file with full path longer than PATH_MAX, see:\n        # https://github.com/giampaolo/psutil/issues/1940\n        p = psutil.Process()\n        files = p.open_files()\n        with open(self.get_testfn(), 'w'):\n            # give the kernel some time to see the new file\n            call_until(p.open_files, \"len(ret) != %i\" % len(files))\n            patch_point = 'psutil._pslinux.os.readlink'\n            with mock.patch(\n                patch_point, side_effect=OSError(errno.ENAMETOOLONG, \"\")\n            ) as m:\n                with mock.patch(\"psutil._pslinux.debug\"):\n                    self.assertEqual(p.open_files(), [])\n                    assert m.called\n\n    # --- mocked tests\n\n    def test_terminal_mocked(self):\n        with mock.patch(\n            'psutil._pslinux._psposix.get_terminal_map', return_value={}\n        ) as m:\n            self.assertIsNone(psutil._pslinux.Process(os.getpid()).terminal())\n            assert m.called\n\n    # TODO: re-enable this test.\n    # def test_num_ctx_switches_mocked(self):\n    #     with mock.patch('psutil._common.open', create=True) as m:\n    #         self.assertRaises(\n    #             NotImplementedError,\n    #             psutil._pslinux.Process(os.getpid()).num_ctx_switches)\n    #         assert m.called\n\n    def test_cmdline_mocked(self):\n        # see: https://github.com/giampaolo/psutil/issues/639\n        p = psutil.Process()\n        fake_file = io.StringIO(u'foo\\x00bar\\x00')\n        with mock.patch(\n            'psutil._common.open', return_value=fake_file, create=True\n        ) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar'])\n            assert m.called\n        fake_file = io.StringIO(u'foo\\x00bar\\x00\\x00')\n        with mock.patch(\n            'psutil._common.open', return_value=fake_file, create=True\n        ) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar', ''])\n            assert m.called\n\n    def test_cmdline_spaces_mocked(self):\n        # see: https://github.com/giampaolo/psutil/issues/1179\n        p = psutil.Process()\n        fake_file = io.StringIO(u'foo bar ')\n        with mock.patch(\n            'psutil._common.open', return_value=fake_file, create=True\n        ) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar'])\n            assert m.called\n        fake_file = io.StringIO(u'foo bar  ')\n        with mock.patch(\n            'psutil._common.open', return_value=fake_file, create=True\n        ) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar', ''])\n            assert m.called\n\n    def test_cmdline_mixed_separators(self):\n        # https://github.com/giampaolo/psutil/issues/\n        #    1179#issuecomment-552984549\n        p = psutil.Process()\n        fake_file = io.StringIO(u'foo\\x20bar\\x00')\n        with mock.patch(\n            'psutil._common.open', return_value=fake_file, create=True\n        ) as m:\n            self.assertEqual(p.cmdline(), ['foo', 'bar'])\n            assert m.called\n\n    def test_readlink_path_deleted_mocked(self):\n        with mock.patch(\n            'psutil._pslinux.os.readlink', return_value='/home/foo (deleted)'\n        ):\n            self.assertEqual(psutil.Process().exe(), \"/home/foo\")\n            self.assertEqual(psutil.Process().cwd(), \"/home/foo\")\n\n    def test_threads_mocked(self):\n        # Test the case where os.listdir() returns a file (thread)\n        # which no longer exists by the time we open() it (race\n        # condition). threads() is supposed to ignore that instead\n        # of raising NSP.\n        def open_mock_1(name, *args, **kwargs):\n            if name.startswith('/proc/%s/task' % os.getpid()):\n                raise IOError(errno.ENOENT, \"\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        orig_open = open\n        patch_point = 'builtins.open' if PY3 else '__builtin__.open'\n        with mock.patch(patch_point, side_effect=open_mock_1) as m:\n            ret = psutil.Process().threads()\n            assert m.called\n            self.assertEqual(ret, [])\n\n        # ...but if it bumps into something != ENOENT we want an\n        # exception.\n        def open_mock_2(name, *args, **kwargs):\n            if name.startswith('/proc/%s/task' % os.getpid()):\n                raise IOError(errno.EPERM, \"\")\n            else:\n                return orig_open(name, *args, **kwargs)\n\n        with mock.patch(patch_point, side_effect=open_mock_2):\n            self.assertRaises(psutil.AccessDenied, psutil.Process().threads)\n\n    def test_exe_mocked(self):\n        with mock.patch(\n            'psutil._pslinux.readlink', side_effect=OSError(errno.ENOENT, \"\")\n        ) as m:\n            ret = psutil.Process().exe()\n            assert m.called\n            self.assertEqual(ret, \"\")\n\n    def test_issue_1014(self):\n        # Emulates a case where smaps file does not exist. In this case\n        # wrap_exception decorator should not raise NoSuchProcess.\n        with mock_open_exception(\n            '/proc/%s/smaps' % os.getpid(), IOError(errno.ENOENT, \"\")\n        ) as m:\n            p = psutil.Process()\n            with self.assertRaises(FileNotFoundError):\n                p.memory_maps()\n            assert m.called\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_zombie(self):\n        # Emulate a case where rlimit() raises ENOSYS, which may\n        # happen in case of zombie process:\n        # https://travis-ci.org/giampaolo/psutil/jobs/51368273\n        with mock.patch(\n            \"psutil._pslinux.prlimit\", side_effect=OSError(errno.ENOSYS, \"\")\n        ) as m1:\n            with mock.patch(\n                \"psutil._pslinux.Process._is_zombie\", return_value=True\n            ) as m2:\n                p = psutil.Process()\n                p.name()\n                with self.assertRaises(psutil.ZombieProcess) as exc:\n                    p.rlimit(psutil.RLIMIT_NOFILE)\n        assert m1.called\n        assert m2.called\n        self.assertEqual(exc.exception.pid, p.pid)\n        self.assertEqual(exc.exception.name, p.name())\n\n    def test_stat_file_parsing(self):\n        args = [\n            \"0\",  # pid\n            \"(cat)\",  # name\n            \"Z\",  # status\n            \"1\",  # ppid\n            \"0\",  # pgrp\n            \"0\",  # session\n            \"0\",  # tty\n            \"0\",  # tpgid\n            \"0\",  # flags\n            \"0\",  # minflt\n            \"0\",  # cminflt\n            \"0\",  # majflt\n            \"0\",  # cmajflt\n            \"2\",  # utime\n            \"3\",  # stime\n            \"4\",  # cutime\n            \"5\",  # cstime\n            \"0\",  # priority\n            \"0\",  # nice\n            \"0\",  # num_threads\n            \"0\",  # itrealvalue\n            \"6\",  # starttime\n            \"0\",  # vsize\n            \"0\",  # rss\n            \"0\",  # rsslim\n            \"0\",  # startcode\n            \"0\",  # endcode\n            \"0\",  # startstack\n            \"0\",  # kstkesp\n            \"0\",  # kstkeip\n            \"0\",  # signal\n            \"0\",  # blocked\n            \"0\",  # sigignore\n            \"0\",  # sigcatch\n            \"0\",  # wchan\n            \"0\",  # nswap\n            \"0\",  # cnswap\n            \"0\",  # exit_signal\n            \"6\",  # processor\n            \"0\",  # rt priority\n            \"0\",  # policy\n            \"7\",  # delayacct_blkio_ticks\n        ]\n        content = \" \".join(args).encode()\n        with mock_open_content({\"/proc/%s/stat\" % os.getpid(): content}):\n            p = psutil.Process()\n            self.assertEqual(p.name(), 'cat')\n            self.assertEqual(p.status(), psutil.STATUS_ZOMBIE)\n            self.assertEqual(p.ppid(), 1)\n            self.assertEqual(\n                p.create_time(), 6 / CLOCK_TICKS + psutil.boot_time()\n            )\n            cpu = p.cpu_times()\n            self.assertEqual(cpu.user, 2 / CLOCK_TICKS)\n            self.assertEqual(cpu.system, 3 / CLOCK_TICKS)\n            self.assertEqual(cpu.children_user, 4 / CLOCK_TICKS)\n            self.assertEqual(cpu.children_system, 5 / CLOCK_TICKS)\n            self.assertEqual(cpu.iowait, 7 / CLOCK_TICKS)\n            self.assertEqual(p.cpu_num(), 6)\n\n    def test_status_file_parsing(self):\n        content = textwrap.dedent(\"\"\"\\\n            Uid:\\t1000\\t1001\\t1002\\t1003\n            Gid:\\t1004\\t1005\\t1006\\t1007\n            Threads:\\t66\n            Cpus_allowed:\\tf\n            Cpus_allowed_list:\\t0-7\n            voluntary_ctxt_switches:\\t12\n            nonvoluntary_ctxt_switches:\\t13\"\"\").encode()\n        with mock_open_content({\"/proc/%s/status\" % os.getpid(): content}):\n            p = psutil.Process()\n            self.assertEqual(p.num_ctx_switches().voluntary, 12)\n            self.assertEqual(p.num_ctx_switches().involuntary, 13)\n            self.assertEqual(p.num_threads(), 66)\n            uids = p.uids()\n            self.assertEqual(uids.real, 1000)\n            self.assertEqual(uids.effective, 1001)\n            self.assertEqual(uids.saved, 1002)\n            gids = p.gids()\n            self.assertEqual(gids.real, 1004)\n            self.assertEqual(gids.effective, 1005)\n            self.assertEqual(gids.saved, 1006)\n            self.assertEqual(p._proc._get_eligible_cpus(), list(range(8)))\n\n    def test_net_connections_enametoolong(self):\n        # Simulate a case where /proc/{pid}/fd/{fd} symlink points to\n        # a file with full path longer than PATH_MAX, see:\n        # https://github.com/giampaolo/psutil/issues/1940\n        with mock.patch(\n            'psutil._pslinux.os.readlink',\n            side_effect=OSError(errno.ENAMETOOLONG, \"\"),\n        ) as m:\n            p = psutil.Process()\n            with mock.patch(\"psutil._pslinux.debug\"):\n                self.assertEqual(p.net_connections(), [])\n                assert m.called\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestProcessAgainstStatus(PsutilTestCase):\n    \"\"\"/proc/pid/stat and /proc/pid/status have many values in common.\n    Whenever possible, psutil uses /proc/pid/stat (it's faster).\n    For all those cases we check that the value found in\n    /proc/pid/stat (by psutil) matches the one found in\n    /proc/pid/status.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.proc = psutil.Process()\n\n    def read_status_file(self, linestart):\n        with psutil._psplatform.open_text(\n            '/proc/%s/status' % self.proc.pid\n        ) as f:\n            for line in f:\n                line = line.strip()\n                if line.startswith(linestart):\n                    value = line.partition('\\t')[2]\n                    try:\n                        return int(value)\n                    except ValueError:\n                        return value\n            raise ValueError(\"can't find %r\" % linestart)\n\n    def test_name(self):\n        value = self.read_status_file(\"Name:\")\n        self.assertEqual(self.proc.name(), value)\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    def test_status(self):\n        value = self.read_status_file(\"State:\")\n        value = value[value.find('(') + 1 : value.rfind(')')]\n        value = value.replace(' ', '-')\n        self.assertEqual(self.proc.status(), value)\n\n    def test_ppid(self):\n        value = self.read_status_file(\"PPid:\")\n        self.assertEqual(self.proc.ppid(), value)\n\n    def test_num_threads(self):\n        value = self.read_status_file(\"Threads:\")\n        self.assertEqual(self.proc.num_threads(), value)\n\n    def test_uids(self):\n        value = self.read_status_file(\"Uid:\")\n        value = tuple(map(int, value.split()[1:4]))\n        self.assertEqual(self.proc.uids(), value)\n\n    def test_gids(self):\n        value = self.read_status_file(\"Gid:\")\n        value = tuple(map(int, value.split()[1:4]))\n        self.assertEqual(self.proc.gids(), value)\n\n    @retry_on_failure()\n    def test_num_ctx_switches(self):\n        value = self.read_status_file(\"voluntary_ctxt_switches:\")\n        self.assertEqual(self.proc.num_ctx_switches().voluntary, value)\n        value = self.read_status_file(\"nonvoluntary_ctxt_switches:\")\n        self.assertEqual(self.proc.num_ctx_switches().involuntary, value)\n\n    def test_cpu_affinity(self):\n        value = self.read_status_file(\"Cpus_allowed_list:\")\n        if '-' in str(value):\n            min_, max_ = map(int, value.split('-'))\n            self.assertEqual(\n                self.proc.cpu_affinity(), list(range(min_, max_ + 1))\n            )\n\n    def test_cpu_affinity_eligible_cpus(self):\n        value = self.read_status_file(\"Cpus_allowed_list:\")\n        with mock.patch(\"psutil._pslinux.per_cpu_times\") as m:\n            self.proc._proc._get_eligible_cpus()\n        if '-' in str(value):\n            assert not m.called\n        else:\n            assert m.called\n\n\n# =====================================================================\n# --- test utils\n# =====================================================================\n\n\n@unittest.skipIf(not LINUX, \"LINUX only\")\nclass TestUtils(PsutilTestCase):\n    def test_readlink(self):\n        with mock.patch(\"os.readlink\", return_value=\"foo (deleted)\") as m:\n            self.assertEqual(psutil._psplatform.readlink(\"bar\"), \"foo\")\n            assert m.called\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_windows.py": "#!/usr/bin/env python3\n# -*- coding: UTF-8 -*\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Windows specific tests.\"\"\"\n\nimport datetime\nimport errno\nimport glob\nimport os\nimport platform\nimport re\nimport signal\nimport subprocess\nimport sys\nimport time\nimport unittest\nimport warnings\n\nimport psutil\nfrom psutil import WINDOWS\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import super\nfrom psutil._compat import which\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import HAS_BATTERY\nfrom psutil.tests import IS_64BIT\nfrom psutil.tests import PY3\nfrom psutil.tests import PYPY\nfrom psutil.tests import TOLERANCE_DISK_USAGE\nfrom psutil.tests import TOLERANCE_SYS_MEM\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import mock\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\n\n\nif WINDOWS and not PYPY:\n    with warnings.catch_warnings():\n        warnings.simplefilter(\"ignore\")\n        import win32api  # requires \"pip install pywin32\"\n        import win32con\n        import win32process\n        import wmi  # requires \"pip install wmi\" / \"make setup-dev-env\"\n\nif WINDOWS:\n    from psutil._pswindows import convert_oserror\n\n\ncext = psutil._psplatform.cext\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\n@unittest.skipIf(PYPY, \"pywin32 not available on PYPY\")\n# https://github.com/giampaolo/psutil/pull/1762#issuecomment-632892692\n@unittest.skipIf(GITHUB_ACTIONS and not PY3, \"pywin32 broken on GITHUB + PY2\")\nclass WindowsTestCase(PsutilTestCase):\n    pass\n\n\ndef powershell(cmd):\n    \"\"\"Currently not used, but available just in case. Usage:\n\n    >>> powershell(\n        \"Get-CIMInstance Win32_PageFileUsage | Select AllocatedBaseSize\")\n    \"\"\"\n    if not which(\"powershell.exe\"):\n        raise unittest.SkipTest(\"powershell.exe not available\")\n    cmdline = (\n        'powershell.exe -ExecutionPolicy Bypass -NoLogo -NonInteractive '\n        + '-NoProfile -WindowStyle Hidden -Command \"%s\"' % cmd\n    )\n    return sh(cmdline)\n\n\ndef wmic(path, what, converter=int):\n    \"\"\"Currently not used, but available just in case. Usage:\n\n    >>> wmic(\"Win32_OperatingSystem\", \"FreePhysicalMemory\")\n    2134124534\n    \"\"\"\n    out = sh(\"wmic path %s get %s\" % (path, what)).strip()\n    data = \"\".join(out.splitlines()[1:]).strip()  # get rid of the header\n    if converter is not None:\n        if \",\" in what:\n            return tuple([converter(x) for x in data.split()])\n        else:\n            return converter(data)\n    else:\n        return data\n\n\n# ===================================================================\n# System APIs\n# ===================================================================\n\n\nclass TestCpuAPIs(WindowsTestCase):\n    @unittest.skipIf(\n        'NUMBER_OF_PROCESSORS' not in os.environ,\n        'NUMBER_OF_PROCESSORS env var is not available',\n    )\n    def test_cpu_count_vs_NUMBER_OF_PROCESSORS(self):\n        # Will likely fail on many-cores systems:\n        # https://stackoverflow.com/questions/31209256\n        num_cpus = int(os.environ['NUMBER_OF_PROCESSORS'])\n        self.assertEqual(num_cpus, psutil.cpu_count())\n\n    def test_cpu_count_vs_GetSystemInfo(self):\n        # Will likely fail on many-cores systems:\n        # https://stackoverflow.com/questions/31209256\n        sys_value = win32api.GetSystemInfo()[5]\n        psutil_value = psutil.cpu_count()\n        self.assertEqual(sys_value, psutil_value)\n\n    def test_cpu_count_logical_vs_wmi(self):\n        w = wmi.WMI()\n        procs = sum(\n            proc.NumberOfLogicalProcessors for proc in w.Win32_Processor()\n        )\n        self.assertEqual(psutil.cpu_count(), procs)\n\n    def test_cpu_count_cores_vs_wmi(self):\n        w = wmi.WMI()\n        cores = sum(proc.NumberOfCores for proc in w.Win32_Processor())\n        self.assertEqual(psutil.cpu_count(logical=False), cores)\n\n    def test_cpu_count_vs_cpu_times(self):\n        self.assertEqual(\n            psutil.cpu_count(), len(psutil.cpu_times(percpu=True))\n        )\n\n    def test_cpu_freq(self):\n        w = wmi.WMI()\n        proc = w.Win32_Processor()[0]\n        self.assertEqual(proc.CurrentClockSpeed, psutil.cpu_freq().current)\n        self.assertEqual(proc.MaxClockSpeed, psutil.cpu_freq().max)\n\n\nclass TestSystemAPIs(WindowsTestCase):\n    def test_nic_names(self):\n        out = sh('ipconfig /all')\n        nics = psutil.net_io_counters(pernic=True).keys()\n        for nic in nics:\n            if \"pseudo-interface\" in nic.replace(' ', '-').lower():\n                continue\n            if nic not in out:\n                raise self.fail(\n                    \"%r nic wasn't found in 'ipconfig /all' output\" % nic\n                )\n\n    def test_total_phymem(self):\n        w = wmi.WMI().Win32_ComputerSystem()[0]\n        self.assertEqual(\n            int(w.TotalPhysicalMemory), psutil.virtual_memory().total\n        )\n\n    def test_free_phymem(self):\n        w = wmi.WMI().Win32_PerfRawData_PerfOS_Memory()[0]\n        self.assertAlmostEqual(\n            int(w.AvailableBytes),\n            psutil.virtual_memory().free,\n            delta=TOLERANCE_SYS_MEM,\n        )\n\n    def test_total_swapmem(self):\n        w = wmi.WMI().Win32_PerfRawData_PerfOS_Memory()[0]\n        self.assertEqual(\n            int(w.CommitLimit) - psutil.virtual_memory().total,\n            psutil.swap_memory().total,\n        )\n        if psutil.swap_memory().total == 0:\n            self.assertEqual(0, psutil.swap_memory().free)\n            self.assertEqual(0, psutil.swap_memory().used)\n\n    def test_percent_swapmem(self):\n        if psutil.swap_memory().total > 0:\n            w = wmi.WMI().Win32_PerfRawData_PerfOS_PagingFile(Name=\"_Total\")[0]\n            # calculate swap usage to percent\n            percentSwap = int(w.PercentUsage) * 100 / int(w.PercentUsage_Base)\n            # exact percent may change but should be reasonable\n            # assert within +/- 5% and between 0 and 100%\n            self.assertGreaterEqual(psutil.swap_memory().percent, 0)\n            self.assertAlmostEqual(\n                psutil.swap_memory().percent, percentSwap, delta=5\n            )\n            self.assertLessEqual(psutil.swap_memory().percent, 100)\n\n    # @unittest.skipIf(wmi is None, \"wmi module is not installed\")\n    # def test__UPTIME(self):\n    #     # _UPTIME constant is not public but it is used internally\n    #     # as value to return for pid 0 creation time.\n    #     # WMI behaves the same.\n    #     w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n    #     p = psutil.Process(0)\n    #     wmic_create = str(w.CreationDate.split('.')[0])\n    #     psutil_create = time.strftime(\"%Y%m%d%H%M%S\",\n    #                                   time.localtime(p.create_time()))\n\n    # Note: this test is not very reliable\n    @unittest.skipIf(APPVEYOR, \"test not relieable on appveyor\")\n    @retry_on_failure()\n    def test_pids(self):\n        # Note: this test might fail if the OS is starting/killing\n        # other processes in the meantime\n        w = wmi.WMI().Win32_Process()\n        wmi_pids = set([x.ProcessId for x in w])\n        psutil_pids = set(psutil.pids())\n        self.assertEqual(wmi_pids, psutil_pids)\n\n    @retry_on_failure()\n    def test_disks(self):\n        ps_parts = psutil.disk_partitions(all=True)\n        wmi_parts = wmi.WMI().Win32_LogicalDisk()\n        for ps_part in ps_parts:\n            for wmi_part in wmi_parts:\n                if ps_part.device.replace('\\\\', '') == wmi_part.DeviceID:\n                    if not ps_part.mountpoint:\n                        # this is usually a CD-ROM with no disk inserted\n                        break\n                    if 'cdrom' in ps_part.opts:\n                        break\n                    if ps_part.mountpoint.startswith('A:'):\n                        break  # floppy\n                    try:\n                        usage = psutil.disk_usage(ps_part.mountpoint)\n                    except FileNotFoundError:\n                        # usually this is the floppy\n                        break\n                    self.assertEqual(usage.total, int(wmi_part.Size))\n                    wmi_free = int(wmi_part.FreeSpace)\n                    self.assertEqual(usage.free, wmi_free)\n                    # 10 MB tolerance\n                    if abs(usage.free - wmi_free) > 10 * 1024 * 1024:\n                        raise self.fail(\n                            \"psutil=%s, wmi=%s\" % (usage.free, wmi_free)\n                        )\n                    break\n            else:\n                raise self.fail(\"can't find partition %s\" % repr(ps_part))\n\n    @retry_on_failure()\n    def test_disk_usage(self):\n        for disk in psutil.disk_partitions():\n            if 'cdrom' in disk.opts:\n                continue\n            sys_value = win32api.GetDiskFreeSpaceEx(disk.mountpoint)\n            psutil_value = psutil.disk_usage(disk.mountpoint)\n            self.assertAlmostEqual(\n                sys_value[0], psutil_value.free, delta=TOLERANCE_DISK_USAGE\n            )\n            self.assertAlmostEqual(\n                sys_value[1], psutil_value.total, delta=TOLERANCE_DISK_USAGE\n            )\n            self.assertEqual(\n                psutil_value.used, psutil_value.total - psutil_value.free\n            )\n\n    def test_disk_partitions(self):\n        sys_value = [\n            x + '\\\\'\n            for x in win32api.GetLogicalDriveStrings().split(\"\\\\\\x00\")\n            if x and not x.startswith('A:')\n        ]\n        psutil_value = [\n            x.mountpoint\n            for x in psutil.disk_partitions(all=True)\n            if not x.mountpoint.startswith('A:')\n        ]\n        self.assertEqual(sys_value, psutil_value)\n\n    def test_net_if_stats(self):\n        ps_names = set(cext.net_if_stats())\n        wmi_adapters = wmi.WMI().Win32_NetworkAdapter()\n        wmi_names = set()\n        for wmi_adapter in wmi_adapters:\n            wmi_names.add(wmi_adapter.Name)\n            wmi_names.add(wmi_adapter.NetConnectionID)\n        self.assertTrue(\n            ps_names & wmi_names,\n            \"no common entries in %s, %s\" % (ps_names, wmi_names),\n        )\n\n    def test_boot_time(self):\n        wmi_os = wmi.WMI().Win32_OperatingSystem()\n        wmi_btime_str = wmi_os[0].LastBootUpTime.split('.')[0]\n        wmi_btime_dt = datetime.datetime.strptime(\n            wmi_btime_str, \"%Y%m%d%H%M%S\"\n        )\n        psutil_dt = datetime.datetime.fromtimestamp(psutil.boot_time())\n        diff = abs((wmi_btime_dt - psutil_dt).total_seconds())\n        self.assertLessEqual(diff, 5)\n\n    def test_boot_time_fluctuation(self):\n        # https://github.com/giampaolo/psutil/issues/1007\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=5):\n            self.assertEqual(psutil.boot_time(), 5)\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=4):\n            self.assertEqual(psutil.boot_time(), 5)\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=6):\n            self.assertEqual(psutil.boot_time(), 5)\n        with mock.patch('psutil._pswindows.cext.boot_time', return_value=333):\n            self.assertEqual(psutil.boot_time(), 333)\n\n\n# ===================================================================\n# sensors_battery()\n# ===================================================================\n\n\nclass TestSensorsBattery(WindowsTestCase):\n    def test_has_battery(self):\n        if win32api.GetPwrCapabilities()['SystemBatteriesPresent']:\n            self.assertIsNotNone(psutil.sensors_battery())\n        else:\n            self.assertIsNone(psutil.sensors_battery())\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_percent(self):\n        w = wmi.WMI()\n        battery_wmi = w.query('select * from Win32_Battery')[0]\n        battery_psutil = psutil.sensors_battery()\n        self.assertAlmostEqual(\n            battery_psutil.percent,\n            battery_wmi.EstimatedChargeRemaining,\n            delta=1,\n        )\n\n    @unittest.skipIf(not HAS_BATTERY, \"no battery\")\n    def test_power_plugged(self):\n        w = wmi.WMI()\n        battery_wmi = w.query('select * from Win32_Battery')[0]\n        battery_psutil = psutil.sensors_battery()\n        # Status codes:\n        # https://msdn.microsoft.com/en-us/library/aa394074(v=vs.85).aspx\n        self.assertEqual(\n            battery_psutil.power_plugged, battery_wmi.BatteryStatus == 2\n        )\n\n    def test_emulate_no_battery(self):\n        with mock.patch(\n            \"psutil._pswindows.cext.sensors_battery\",\n            return_value=(0, 128, 0, 0),\n        ) as m:\n            self.assertIsNone(psutil.sensors_battery())\n            assert m.called\n\n    def test_emulate_power_connected(self):\n        with mock.patch(\n            \"psutil._pswindows.cext.sensors_battery\", return_value=(1, 0, 0, 0)\n        ) as m:\n            self.assertEqual(\n                psutil.sensors_battery().secsleft, psutil.POWER_TIME_UNLIMITED\n            )\n            assert m.called\n\n    def test_emulate_power_charging(self):\n        with mock.patch(\n            \"psutil._pswindows.cext.sensors_battery\", return_value=(0, 8, 0, 0)\n        ) as m:\n            self.assertEqual(\n                psutil.sensors_battery().secsleft, psutil.POWER_TIME_UNLIMITED\n            )\n            assert m.called\n\n    def test_emulate_secs_left_unknown(self):\n        with mock.patch(\n            \"psutil._pswindows.cext.sensors_battery\",\n            return_value=(0, 0, 0, -1),\n        ) as m:\n            self.assertEqual(\n                psutil.sensors_battery().secsleft, psutil.POWER_TIME_UNKNOWN\n            )\n            assert m.called\n\n\n# ===================================================================\n# Process APIs\n# ===================================================================\n\n\nclass TestProcess(WindowsTestCase):\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_issue_24(self):\n        p = psutil.Process(0)\n        self.assertRaises(psutil.AccessDenied, p.kill)\n\n    def test_special_pid(self):\n        p = psutil.Process(4)\n        self.assertEqual(p.name(), 'System')\n        # use __str__ to access all common Process properties to check\n        # that nothing strange happens\n        str(p)\n        p.username()\n        self.assertGreaterEqual(p.create_time(), 0.0)\n        try:\n            rss, _vms = p.memory_info()[:2]\n        except psutil.AccessDenied:\n            # expected on Windows Vista and Windows 7\n            if platform.uname()[1] not in ('vista', 'win-7', 'win7'):\n                raise\n        else:\n            self.assertGreater(rss, 0)\n\n    def test_send_signal(self):\n        p = psutil.Process(self.pid)\n        self.assertRaises(ValueError, p.send_signal, signal.SIGINT)\n\n    def test_num_handles_increment(self):\n        p = psutil.Process(os.getpid())\n        before = p.num_handles()\n        handle = win32api.OpenProcess(\n            win32con.PROCESS_QUERY_INFORMATION, win32con.FALSE, os.getpid()\n        )\n        after = p.num_handles()\n        self.assertEqual(after, before + 1)\n        win32api.CloseHandle(handle)\n        self.assertEqual(p.num_handles(), before)\n\n    def test_ctrl_signals(self):\n        p = psutil.Process(self.spawn_testproc().pid)\n        p.send_signal(signal.CTRL_C_EVENT)\n        p.send_signal(signal.CTRL_BREAK_EVENT)\n        p.kill()\n        p.wait()\n        self.assertRaises(\n            psutil.NoSuchProcess, p.send_signal, signal.CTRL_C_EVENT\n        )\n        self.assertRaises(\n            psutil.NoSuchProcess, p.send_signal, signal.CTRL_BREAK_EVENT\n        )\n\n    def test_username(self):\n        name = win32api.GetUserNameEx(win32con.NameSamCompatible)\n        if name.endswith('$'):\n            # When running as a service account (most likely to be\n            # NetworkService), these user name calculations don't produce the\n            # same result, causing the test to fail.\n            raise unittest.SkipTest('running as service account')\n        self.assertEqual(psutil.Process().username(), name)\n\n    def test_cmdline(self):\n        sys_value = re.sub('[ ]+', ' ', win32api.GetCommandLine()).strip()\n        psutil_value = ' '.join(psutil.Process().cmdline())\n        if sys_value[0] == '\"' != psutil_value[0]:\n            # The PyWin32 command line may retain quotes around argv[0] if they\n            # were used unnecessarily, while psutil will omit them. So remove\n            # the first 2 quotes from sys_value if not in psutil_value.\n            # A path to an executable will not contain quotes, so this is safe.\n            sys_value = sys_value.replace('\"', '', 2)\n        self.assertEqual(sys_value, psutil_value)\n\n    # XXX - occasional failures\n\n    # def test_cpu_times(self):\n    #     handle = win32api.OpenProcess(win32con.PROCESS_QUERY_INFORMATION,\n    #                                   win32con.FALSE, os.getpid())\n    #     self.addCleanup(win32api.CloseHandle, handle)\n    #     sys_value = win32process.GetProcessTimes(handle)\n    #     psutil_value = psutil.Process().cpu_times()\n    #     self.assertAlmostEqual(\n    #         psutil_value.user, sys_value['UserTime'] / 10000000.0,\n    #         delta=0.2)\n    #     self.assertAlmostEqual(\n    #         psutil_value.user, sys_value['KernelTime'] / 10000000.0,\n    #         delta=0.2)\n\n    def test_nice(self):\n        handle = win32api.OpenProcess(\n            win32con.PROCESS_QUERY_INFORMATION, win32con.FALSE, os.getpid()\n        )\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = win32process.GetPriorityClass(handle)\n        psutil_value = psutil.Process().nice()\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_memory_info(self):\n        handle = win32api.OpenProcess(\n            win32con.PROCESS_QUERY_INFORMATION, win32con.FALSE, self.pid\n        )\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = win32process.GetProcessMemoryInfo(handle)\n        psutil_value = psutil.Process(self.pid).memory_info()\n        self.assertEqual(\n            sys_value['PeakWorkingSetSize'], psutil_value.peak_wset\n        )\n        self.assertEqual(sys_value['WorkingSetSize'], psutil_value.wset)\n        self.assertEqual(\n            sys_value['QuotaPeakPagedPoolUsage'], psutil_value.peak_paged_pool\n        )\n        self.assertEqual(\n            sys_value['QuotaPagedPoolUsage'], psutil_value.paged_pool\n        )\n        self.assertEqual(\n            sys_value['QuotaPeakNonPagedPoolUsage'],\n            psutil_value.peak_nonpaged_pool,\n        )\n        self.assertEqual(\n            sys_value['QuotaNonPagedPoolUsage'], psutil_value.nonpaged_pool\n        )\n        self.assertEqual(sys_value['PagefileUsage'], psutil_value.pagefile)\n        self.assertEqual(\n            sys_value['PeakPagefileUsage'], psutil_value.peak_pagefile\n        )\n\n        self.assertEqual(psutil_value.rss, psutil_value.wset)\n        self.assertEqual(psutil_value.vms, psutil_value.pagefile)\n\n    def test_wait(self):\n        handle = win32api.OpenProcess(\n            win32con.PROCESS_QUERY_INFORMATION, win32con.FALSE, self.pid\n        )\n        self.addCleanup(win32api.CloseHandle, handle)\n        p = psutil.Process(self.pid)\n        p.terminate()\n        psutil_value = p.wait()\n        sys_value = win32process.GetExitCodeProcess(handle)\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_cpu_affinity(self):\n        def from_bitmask(x):\n            return [i for i in range(64) if (1 << i) & x]\n\n        handle = win32api.OpenProcess(\n            win32con.PROCESS_QUERY_INFORMATION, win32con.FALSE, self.pid\n        )\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = from_bitmask(\n            win32process.GetProcessAffinityMask(handle)[0]\n        )\n        psutil_value = psutil.Process(self.pid).cpu_affinity()\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_io_counters(self):\n        handle = win32api.OpenProcess(\n            win32con.PROCESS_QUERY_INFORMATION, win32con.FALSE, os.getpid()\n        )\n        self.addCleanup(win32api.CloseHandle, handle)\n        sys_value = win32process.GetProcessIoCounters(handle)\n        psutil_value = psutil.Process().io_counters()\n        self.assertEqual(\n            psutil_value.read_count, sys_value['ReadOperationCount']\n        )\n        self.assertEqual(\n            psutil_value.write_count, sys_value['WriteOperationCount']\n        )\n        self.assertEqual(\n            psutil_value.read_bytes, sys_value['ReadTransferCount']\n        )\n        self.assertEqual(\n            psutil_value.write_bytes, sys_value['WriteTransferCount']\n        )\n        self.assertEqual(\n            psutil_value.other_count, sys_value['OtherOperationCount']\n        )\n        self.assertEqual(\n            psutil_value.other_bytes, sys_value['OtherTransferCount']\n        )\n\n    def test_num_handles(self):\n        import ctypes\n        import ctypes.wintypes\n\n        PROCESS_QUERY_INFORMATION = 0x400\n        handle = ctypes.windll.kernel32.OpenProcess(\n            PROCESS_QUERY_INFORMATION, 0, self.pid\n        )\n        self.addCleanup(ctypes.windll.kernel32.CloseHandle, handle)\n\n        hndcnt = ctypes.wintypes.DWORD()\n        ctypes.windll.kernel32.GetProcessHandleCount(\n            handle, ctypes.byref(hndcnt)\n        )\n        sys_value = hndcnt.value\n        psutil_value = psutil.Process(self.pid).num_handles()\n        self.assertEqual(psutil_value, sys_value)\n\n    def test_error_partial_copy(self):\n        # https://github.com/giampaolo/psutil/issues/875\n        exc = WindowsError()\n        exc.winerror = 299\n        with mock.patch(\"psutil._psplatform.cext.proc_cwd\", side_effect=exc):\n            with mock.patch(\"time.sleep\") as m:\n                p = psutil.Process()\n                self.assertRaises(psutil.AccessDenied, p.cwd)\n        self.assertGreaterEqual(m.call_count, 5)\n\n    def test_exe(self):\n        # NtQuerySystemInformation succeeds if process is gone. Make sure\n        # it raises NSP for a non existent pid.\n        pid = psutil.pids()[-1] + 99999\n        proc = psutil._psplatform.Process(pid)\n        self.assertRaises(psutil.NoSuchProcess, proc.exe)\n\n\nclass TestProcessWMI(WindowsTestCase):\n    \"\"\"Compare Process API results with WMI.\"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_name(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        self.assertEqual(p.name(), w.Caption)\n\n    # This fail on github because using virtualenv for test environment\n    @unittest.skipIf(GITHUB_ACTIONS, \"unreliable path on GITHUB_ACTIONS\")\n    def test_exe(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        # Note: wmi reports the exe as a lower case string.\n        # Being Windows paths case-insensitive we ignore that.\n        self.assertEqual(p.exe().lower(), w.ExecutablePath.lower())\n\n    def test_cmdline(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        self.assertEqual(' '.join(p.cmdline()), w.CommandLine.replace('\"', ''))\n\n    def test_username(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        domain, _, username = w.GetOwner()\n        username = \"%s\\\\%s\" % (domain, username)\n        self.assertEqual(p.username(), username)\n\n    @retry_on_failure()\n    def test_memory_rss(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        rss = p.memory_info().rss\n        self.assertEqual(rss, int(w.WorkingSetSize))\n\n    @retry_on_failure()\n    def test_memory_vms(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        vms = p.memory_info().vms\n        # http://msdn.microsoft.com/en-us/library/aa394372(VS.85).aspx\n        # ...claims that PageFileUsage is represented in Kilo\n        # bytes but funnily enough on certain platforms bytes are\n        # returned instead.\n        wmi_usage = int(w.PageFileUsage)\n        if vms not in (wmi_usage, wmi_usage * 1024):\n            raise self.fail(\"wmi=%s, psutil=%s\" % (wmi_usage, vms))\n\n    def test_create_time(self):\n        w = wmi.WMI().Win32_Process(ProcessId=self.pid)[0]\n        p = psutil.Process(self.pid)\n        wmic_create = str(w.CreationDate.split('.')[0])\n        psutil_create = time.strftime(\n            \"%Y%m%d%H%M%S\", time.localtime(p.create_time())\n        )\n        self.assertEqual(wmic_create, psutil_create)\n\n\n# ---\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass TestDualProcessImplementation(PsutilTestCase):\n    \"\"\"Certain APIs on Windows have 2 internal implementations, one\n    based on documented Windows APIs, another one based\n    NtQuerySystemInformation() which gets called as fallback in\n    case the first fails because of limited permission error.\n    Here we test that the two methods return the exact same value,\n    see:\n    https://github.com/giampaolo/psutil/issues/304.\n    \"\"\"\n\n    @classmethod\n    def setUpClass(cls):\n        cls.pid = spawn_testproc().pid\n\n    @classmethod\n    def tearDownClass(cls):\n        terminate(cls.pid)\n\n    def test_memory_info(self):\n        mem_1 = psutil.Process(self.pid).memory_info()\n        with mock.patch(\n            \"psutil._psplatform.cext.proc_memory_info\",\n            side_effect=OSError(errno.EPERM, \"msg\"),\n        ) as fun:\n            mem_2 = psutil.Process(self.pid).memory_info()\n            self.assertEqual(len(mem_1), len(mem_2))\n            for i in range(len(mem_1)):\n                self.assertGreaterEqual(mem_1[i], 0)\n                self.assertGreaterEqual(mem_2[i], 0)\n                self.assertAlmostEqual(mem_1[i], mem_2[i], delta=512)\n            assert fun.called\n\n    def test_create_time(self):\n        ctime = psutil.Process(self.pid).create_time()\n        with mock.patch(\n            \"psutil._psplatform.cext.proc_times\",\n            side_effect=OSError(errno.EPERM, \"msg\"),\n        ) as fun:\n            self.assertEqual(psutil.Process(self.pid).create_time(), ctime)\n            assert fun.called\n\n    def test_cpu_times(self):\n        cpu_times_1 = psutil.Process(self.pid).cpu_times()\n        with mock.patch(\n            \"psutil._psplatform.cext.proc_times\",\n            side_effect=OSError(errno.EPERM, \"msg\"),\n        ) as fun:\n            cpu_times_2 = psutil.Process(self.pid).cpu_times()\n            assert fun.called\n            self.assertAlmostEqual(\n                cpu_times_1.user, cpu_times_2.user, delta=0.01\n            )\n            self.assertAlmostEqual(\n                cpu_times_1.system, cpu_times_2.system, delta=0.01\n            )\n\n    def test_io_counters(self):\n        io_counters_1 = psutil.Process(self.pid).io_counters()\n        with mock.patch(\n            \"psutil._psplatform.cext.proc_io_counters\",\n            side_effect=OSError(errno.EPERM, \"msg\"),\n        ) as fun:\n            io_counters_2 = psutil.Process(self.pid).io_counters()\n            for i in range(len(io_counters_1)):\n                self.assertAlmostEqual(\n                    io_counters_1[i], io_counters_2[i], delta=5\n                )\n            assert fun.called\n\n    def test_num_handles(self):\n        num_handles = psutil.Process(self.pid).num_handles()\n        with mock.patch(\n            \"psutil._psplatform.cext.proc_num_handles\",\n            side_effect=OSError(errno.EPERM, \"msg\"),\n        ) as fun:\n            self.assertEqual(\n                psutil.Process(self.pid).num_handles(), num_handles\n            )\n            assert fun.called\n\n    def test_cmdline(self):\n        for pid in psutil.pids():\n            try:\n                a = cext.proc_cmdline(pid, use_peb=True)\n                b = cext.proc_cmdline(pid, use_peb=False)\n            except OSError as err:\n                err = convert_oserror(err)\n                if not isinstance(\n                    err, (psutil.AccessDenied, psutil.NoSuchProcess)\n                ):\n                    raise\n            else:\n                self.assertEqual(a, b)\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass RemoteProcessTestCase(PsutilTestCase):\n    \"\"\"Certain functions require calling ReadProcessMemory.\n    This trivially works when called on the current process.\n    Check that this works on other processes, especially when they\n    have a different bitness.\n    \"\"\"\n\n    @staticmethod\n    def find_other_interpreter():\n        # find a python interpreter that is of the opposite bitness from us\n        code = \"import sys; sys.stdout.write(str(sys.maxsize > 2**32))\"\n\n        # XXX: a different and probably more stable approach might be to access\n        # the registry but accessing 64 bit paths from a 32 bit process\n        for filename in glob.glob(r\"C:\\Python*\\python.exe\"):\n            proc = subprocess.Popen(\n                args=[filename, \"-c\", code],\n                stdout=subprocess.PIPE,\n                stderr=subprocess.STDOUT,\n            )\n            output, _ = proc.communicate()\n            proc.wait()\n            if output == str(not IS_64BIT):\n                return filename\n\n    test_args = [\"-c\", \"import sys; sys.stdin.read()\"]\n\n    def setUp(self):\n        super().setUp()\n\n        other_python = self.find_other_interpreter()\n        if other_python is None:\n            raise unittest.SkipTest(\n                \"could not find interpreter with opposite bitness\"\n            )\n        if IS_64BIT:\n            self.python64 = sys.executable\n            self.python32 = other_python\n        else:\n            self.python64 = other_python\n            self.python32 = sys.executable\n\n        env = os.environ.copy()\n        env[\"THINK_OF_A_NUMBER\"] = str(os.getpid())\n        self.proc32 = self.spawn_testproc(\n            [self.python32] + self.test_args, env=env, stdin=subprocess.PIPE\n        )\n        self.proc64 = self.spawn_testproc(\n            [self.python64] + self.test_args, env=env, stdin=subprocess.PIPE\n        )\n\n    def tearDown(self):\n        super().tearDown()\n        self.proc32.communicate()\n        self.proc64.communicate()\n\n    def test_cmdline_32(self):\n        p = psutil.Process(self.proc32.pid)\n        self.assertEqual(len(p.cmdline()), 3)\n        self.assertEqual(p.cmdline()[1:], self.test_args)\n\n    def test_cmdline_64(self):\n        p = psutil.Process(self.proc64.pid)\n        self.assertEqual(len(p.cmdline()), 3)\n        self.assertEqual(p.cmdline()[1:], self.test_args)\n\n    def test_cwd_32(self):\n        p = psutil.Process(self.proc32.pid)\n        self.assertEqual(p.cwd(), os.getcwd())\n\n    def test_cwd_64(self):\n        p = psutil.Process(self.proc64.pid)\n        self.assertEqual(p.cwd(), os.getcwd())\n\n    def test_environ_32(self):\n        p = psutil.Process(self.proc32.pid)\n        e = p.environ()\n        self.assertIn(\"THINK_OF_A_NUMBER\", e)\n        self.assertEqual(e[\"THINK_OF_A_NUMBER\"], str(os.getpid()))\n\n    def test_environ_64(self):\n        p = psutil.Process(self.proc64.pid)\n        try:\n            p.environ()\n        except psutil.AccessDenied:\n            pass\n\n\n# ===================================================================\n# Windows services\n# ===================================================================\n\n\n@unittest.skipIf(not WINDOWS, \"WINDOWS only\")\nclass TestServices(PsutilTestCase):\n    def test_win_service_iter(self):\n        valid_statuses = set([\n            \"running\",\n            \"paused\",\n            \"start\",\n            \"pause\",\n            \"continue\",\n            \"stop\",\n            \"stopped\",\n        ])\n        valid_start_types = set([\"automatic\", \"manual\", \"disabled\"])\n        valid_statuses = set([\n            \"running\",\n            \"paused\",\n            \"start_pending\",\n            \"pause_pending\",\n            \"continue_pending\",\n            \"stop_pending\",\n            \"stopped\",\n        ])\n        for serv in psutil.win_service_iter():\n            data = serv.as_dict()\n            self.assertIsInstance(data['name'], str)\n            self.assertNotEqual(data['name'].strip(), \"\")\n            self.assertIsInstance(data['display_name'], str)\n            self.assertIsInstance(data['username'], str)\n            self.assertIn(data['status'], valid_statuses)\n            if data['pid'] is not None:\n                psutil.Process(data['pid'])\n            self.assertIsInstance(data['binpath'], str)\n            self.assertIsInstance(data['username'], str)\n            self.assertIsInstance(data['start_type'], str)\n            self.assertIn(data['start_type'], valid_start_types)\n            self.assertIn(data['status'], valid_statuses)\n            self.assertIsInstance(data['description'], str)\n            pid = serv.pid()\n            if pid is not None:\n                p = psutil.Process(pid)\n                self.assertTrue(p.is_running())\n            # win_service_get\n            s = psutil.win_service_get(serv.name())\n            # test __eq__\n            self.assertEqual(serv, s)\n\n    def test_win_service_get(self):\n        ERROR_SERVICE_DOES_NOT_EXIST = (\n            psutil._psplatform.cext.ERROR_SERVICE_DOES_NOT_EXIST\n        )\n        ERROR_ACCESS_DENIED = psutil._psplatform.cext.ERROR_ACCESS_DENIED\n\n        name = next(psutil.win_service_iter()).name()\n        with self.assertRaises(psutil.NoSuchProcess) as cm:\n            psutil.win_service_get(name + '???')\n        self.assertEqual(cm.exception.name, name + '???')\n\n        # test NoSuchProcess\n        service = psutil.win_service_get(name)\n        if PY3:\n            args = (0, \"msg\", 0, ERROR_SERVICE_DOES_NOT_EXIST)\n        else:\n            args = (ERROR_SERVICE_DOES_NOT_EXIST, \"msg\")\n        exc = WindowsError(*args)\n        with mock.patch(\n            \"psutil._psplatform.cext.winservice_query_status\", side_effect=exc\n        ):\n            self.assertRaises(psutil.NoSuchProcess, service.status)\n        with mock.patch(\n            \"psutil._psplatform.cext.winservice_query_config\", side_effect=exc\n        ):\n            self.assertRaises(psutil.NoSuchProcess, service.username)\n\n        # test AccessDenied\n        if PY3:\n            args = (0, \"msg\", 0, ERROR_ACCESS_DENIED)\n        else:\n            args = (ERROR_ACCESS_DENIED, \"msg\")\n        exc = WindowsError(*args)\n        with mock.patch(\n            \"psutil._psplatform.cext.winservice_query_status\", side_effect=exc\n        ):\n            self.assertRaises(psutil.AccessDenied, service.status)\n        with mock.patch(\n            \"psutil._psplatform.cext.winservice_query_config\", side_effect=exc\n        ):\n            self.assertRaises(psutil.AccessDenied, service.username)\n\n        # test __str__ and __repr__\n        self.assertIn(service.name(), str(service))\n        self.assertIn(service.display_name(), str(service))\n        self.assertIn(service.name(), repr(service))\n        self.assertIn(service.display_name(), repr(service))\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_unicode.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Notes about unicode handling in psutil\n======================================.\n\nStarting from version 5.3.0 psutil adds unicode support, see:\nhttps://github.com/giampaolo/psutil/issues/1040\nThe notes below apply to *any* API returning a string such as\nprocess exe(), cwd() or username():\n\n* all strings are encoded by using the OS filesystem encoding\n  (sys.getfilesystemencoding()) which varies depending on the platform\n  (e.g. \"UTF-8\" on macOS, \"mbcs\" on Win)\n* no API call is supposed to crash with UnicodeDecodeError\n* instead, in case of badly encoded data returned by the OS, the\n  following error handlers are used to replace the corrupted characters in\n  the string:\n    * Python 3: sys.getfilesystemencodeerrors() (PY 3.6+) or\n      \"surrogatescape\" on POSIX and \"replace\" on Windows\n    * Python 2: \"replace\"\n* on Python 2 all APIs return bytes (str type), never unicode\n* on Python 2, you can go back to unicode by doing:\n\n    >>> unicode(p.exe(), sys.getdefaultencoding(), errors=\"replace\")\n\nFor a detailed explanation of how psutil handles unicode see #1040.\n\nTests\n=====\n\nList of APIs returning or dealing with a string:\n('not tested' means they are not tested to deal with non-ASCII strings):\n\n* Process.cmdline()\n* Process.cwd()\n* Process.environ()\n* Process.exe()\n* Process.memory_maps()\n* Process.name()\n* Process.net_connections('unix')\n* Process.open_files()\n* Process.username()             (not tested)\n\n* disk_io_counters()             (not tested)\n* disk_partitions()              (not tested)\n* disk_usage(str)\n* net_connections('unix')\n* net_if_addrs()                 (not tested)\n* net_if_stats()                 (not tested)\n* net_io_counters()              (not tested)\n* sensors_fans()                 (not tested)\n* sensors_temperatures()         (not tested)\n* users()                        (not tested)\n\n* WindowsService.binpath()       (not tested)\n* WindowsService.description()   (not tested)\n* WindowsService.display_name()  (not tested)\n* WindowsService.name()          (not tested)\n* WindowsService.status()        (not tested)\n* WindowsService.username()      (not tested)\n\nIn here we create a unicode path with a funky non-ASCII name and (where\npossible) make psutil return it back (e.g. on name(), exe(), open_files(),\netc.) and make sure that:\n\n* psutil never crashes with UnicodeDecodeError\n* the returned path matches\n\"\"\"\n\nimport os\nimport shutil\nimport traceback\nimport unittest\nimport warnings\nfrom contextlib import closing\n\nimport psutil\nfrom psutil import BSD\nfrom psutil import POSIX\nfrom psutil import WINDOWS\nfrom psutil._compat import PY3\nfrom psutil._compat import super\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import ASCII_FS\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import HAS_ENVIRON\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_NET_CONNECTIONS_UNIX\nfrom psutil.tests import INVALID_UNICODE_SUFFIX\nfrom psutil.tests import PYPY\nfrom psutil.tests import TESTFN_PREFIX\nfrom psutil.tests import UNICODE_SUFFIX\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import bind_unix_socket\nfrom psutil.tests import chdir\nfrom psutil.tests import copyload_shared_lib\nfrom psutil.tests import create_py_exe\nfrom psutil.tests import get_testfn\nfrom psutil.tests import safe_mkdir\nfrom psutil.tests import safe_rmpath\nfrom psutil.tests import serialrun\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import spawn_testproc\nfrom psutil.tests import terminate\n\n\nif APPVEYOR:\n\n    def safe_rmpath(path):  # NOQA\n        # TODO - this is quite random and I'm not sure why it happens,\n        # nor I can reproduce it locally:\n        # https://ci.appveyor.com/project/giampaolo/psutil/build/job/\n        #     jiq2cgd6stsbtn60\n        # safe_rmpath() happens after reap_children() so this is weird\n        # Perhaps wait_procs() on Windows is broken? Maybe because\n        # of STILL_ACTIVE?\n        # https://github.com/giampaolo/psutil/blob/\n        #     68c7a70728a31d8b8b58f4be6c4c0baa2f449eda/psutil/arch/\n        #     windows/process_info.c#L146\n        from psutil.tests import safe_rmpath as rm\n\n        try:\n            return rm(path)\n        except WindowsError:\n            traceback.print_exc()\n\n\ndef try_unicode(suffix):\n    \"\"\"Return True if both the fs and the subprocess module can\n    deal with a unicode file name.\n    \"\"\"\n    sproc = None\n    testfn = get_testfn(suffix=suffix)\n    try:\n        safe_rmpath(testfn)\n        create_py_exe(testfn)\n        sproc = spawn_testproc(cmd=[testfn])\n        shutil.copyfile(testfn, testfn + '-2')\n        safe_rmpath(testfn + '-2')\n    except (UnicodeEncodeError, IOError):\n        return False\n    else:\n        return True\n    finally:\n        if sproc is not None:\n            terminate(sproc)\n        safe_rmpath(testfn)\n\n\n# ===================================================================\n# FS APIs\n# ===================================================================\n\n\nclass BaseUnicodeTest(PsutilTestCase):\n    funky_suffix = None\n\n    @classmethod\n    def setUpClass(cls):\n        super().setUpClass()\n        cls.skip_tests = False\n        cls.funky_name = None\n        if cls.funky_suffix is not None:\n            if not try_unicode(cls.funky_suffix):\n                cls.skip_tests = True\n            else:\n                cls.funky_name = get_testfn(suffix=cls.funky_suffix)\n                create_py_exe(cls.funky_name)\n\n    def setUp(self):\n        super().setUp()\n        if self.skip_tests:\n            raise unittest.SkipTest(\"can't handle unicode str\")\n\n\n@serialrun\n@unittest.skipIf(ASCII_FS, \"ASCII fs\")\n@unittest.skipIf(PYPY and not PY3, \"too much trouble on PYPY2\")\nclass TestFSAPIs(BaseUnicodeTest):\n    \"\"\"Test FS APIs with a funky, valid, UTF8 path name.\"\"\"\n\n    funky_suffix = UNICODE_SUFFIX\n\n    def expect_exact_path_match(self):\n        # Do not expect psutil to correctly handle unicode paths on\n        # Python 2 if os.listdir() is not able either.\n        here = '.' if isinstance(self.funky_name, str) else u'.'\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            return self.funky_name in os.listdir(here)\n\n    # ---\n\n    def test_proc_exe(self):\n        cmd = [\n            self.funky_name,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)]\",\n        ]\n        subp = self.spawn_testproc(cmd)\n        p = psutil.Process(subp.pid)\n        exe = p.exe()\n        self.assertIsInstance(exe, str)\n        if self.expect_exact_path_match():\n            self.assertEqual(\n                os.path.normcase(exe), os.path.normcase(self.funky_name)\n            )\n\n    def test_proc_name(self):\n        cmd = [\n            self.funky_name,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)]\",\n        ]\n        subp = self.spawn_testproc(cmd)\n        name = psutil.Process(subp.pid).name()\n        self.assertIsInstance(name, str)\n        if self.expect_exact_path_match():\n            self.assertEqual(name, os.path.basename(self.funky_name))\n\n    def test_proc_cmdline(self):\n        cmd = [\n            self.funky_name,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)]\",\n        ]\n        subp = self.spawn_testproc(cmd)\n        p = psutil.Process(subp.pid)\n        cmdline = p.cmdline()\n        for part in cmdline:\n            self.assertIsInstance(part, str)\n        if self.expect_exact_path_match():\n            self.assertEqual(cmdline, cmd)\n\n    def test_proc_cwd(self):\n        dname = self.funky_name + \"2\"\n        self.addCleanup(safe_rmpath, dname)\n        safe_mkdir(dname)\n        with chdir(dname):\n            p = psutil.Process()\n            cwd = p.cwd()\n        self.assertIsInstance(p.cwd(), str)\n        if self.expect_exact_path_match():\n            self.assertEqual(cwd, dname)\n\n    @unittest.skipIf(PYPY and WINDOWS, \"fails on PYPY + WINDOWS\")\n    def test_proc_open_files(self):\n        p = psutil.Process()\n        start = set(p.open_files())\n        with open(self.funky_name, 'rb'):\n            new = set(p.open_files())\n        path = (new - start).pop().path\n        self.assertIsInstance(path, str)\n        if BSD and not path:\n            # XXX - see https://github.com/giampaolo/psutil/issues/595\n            raise unittest.SkipTest(\"open_files on BSD is broken\")\n        if self.expect_exact_path_match():\n            self.assertEqual(\n                os.path.normcase(path), os.path.normcase(self.funky_name)\n            )\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    def test_proc_net_connections(self):\n        name = self.get_testfn(suffix=self.funky_suffix)\n        try:\n            sock = bind_unix_socket(name)\n        except UnicodeEncodeError:\n            if PY3:\n                raise\n            else:\n                raise unittest.SkipTest(\"not supported\")\n        with closing(sock):\n            conn = psutil.Process().net_connections('unix')[0]\n            self.assertIsInstance(conn.laddr, str)\n            self.assertEqual(conn.laddr, name)\n\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @unittest.skipIf(not HAS_NET_CONNECTIONS_UNIX, \"can't list UNIX sockets\")\n    @skip_on_access_denied()\n    def test_net_connections(self):\n        def find_sock(cons):\n            for conn in cons:\n                if os.path.basename(conn.laddr).startswith(TESTFN_PREFIX):\n                    return conn\n            raise ValueError(\"connection not found\")\n\n        name = self.get_testfn(suffix=self.funky_suffix)\n        try:\n            sock = bind_unix_socket(name)\n        except UnicodeEncodeError:\n            if PY3:\n                raise\n            else:\n                raise unittest.SkipTest(\"not supported\")\n        with closing(sock):\n            cons = psutil.net_connections(kind='unix')\n            conn = find_sock(cons)\n            self.assertIsInstance(conn.laddr, str)\n            self.assertEqual(conn.laddr, name)\n\n    def test_disk_usage(self):\n        dname = self.funky_name + \"2\"\n        self.addCleanup(safe_rmpath, dname)\n        safe_mkdir(dname)\n        psutil.disk_usage(dname)\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    @unittest.skipIf(not PY3, \"ctypes does not support unicode on PY2\")\n    @unittest.skipIf(PYPY, \"unstable on PYPY\")\n    def test_memory_maps(self):\n        # XXX: on Python 2, using ctypes.CDLL with a unicode path\n        # opens a message box which blocks the test run.\n        with copyload_shared_lib(suffix=self.funky_suffix) as funky_path:\n\n            def normpath(p):\n                return os.path.realpath(os.path.normcase(p))\n\n            libpaths = [\n                normpath(x.path) for x in psutil.Process().memory_maps()\n            ]\n            # ...just to have a clearer msg in case of failure\n            libpaths = [x for x in libpaths if TESTFN_PREFIX in x]\n            self.assertIn(normpath(funky_path), libpaths)\n            for path in libpaths:\n                self.assertIsInstance(path, str)\n\n\n@unittest.skipIf(CI_TESTING, \"unreliable on CI\")\nclass TestFSAPIsWithInvalidPath(TestFSAPIs):\n    \"\"\"Test FS APIs with a funky, invalid path name.\"\"\"\n\n    funky_suffix = INVALID_UNICODE_SUFFIX\n\n    def expect_exact_path_match(self):\n        # Invalid unicode names are supposed to work on Python 2.\n        return True\n\n\n# ===================================================================\n# Non fs APIs\n# ===================================================================\n\n\nclass TestNonFSAPIS(BaseUnicodeTest):\n    \"\"\"Unicode tests for non fs-related APIs.\"\"\"\n\n    funky_suffix = UNICODE_SUFFIX if PY3 else '\u00e8'\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    @unittest.skipIf(PYPY and WINDOWS, \"segfaults on PYPY + WINDOWS\")\n    def test_proc_environ(self):\n        # Note: differently from others, this test does not deal\n        # with fs paths. On Python 2 subprocess module is broken as\n        # it's not able to handle with non-ASCII env vars, so\n        # we use \"\u00e8\", which is part of the extended ASCII table\n        # (unicode point <= 255).\n        env = os.environ.copy()\n        env['FUNNY_ARG'] = self.funky_suffix\n        sproc = self.spawn_testproc(env=env)\n        p = psutil.Process(sproc.pid)\n        env = p.environ()\n        for k, v in env.items():\n            self.assertIsInstance(k, str)\n            self.assertIsInstance(v, str)\n        self.assertEqual(env['FUNNY_ARG'], self.funky_suffix)\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", "psutil/tests/test_process.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Tests for psutil.Process class.\"\"\"\n\nimport collections\nimport errno\nimport getpass\nimport itertools\nimport os\nimport signal\nimport socket\nimport stat\nimport subprocess\nimport sys\nimport textwrap\nimport time\nimport types\nimport unittest\n\nimport psutil\nfrom psutil import AIX\nfrom psutil import BSD\nfrom psutil import LINUX\nfrom psutil import MACOS\nfrom psutil import NETBSD\nfrom psutil import OPENBSD\nfrom psutil import OSX\nfrom psutil import POSIX\nfrom psutil import SUNOS\nfrom psutil import WINDOWS\nfrom psutil._common import open_text\nfrom psutil._compat import PY3\nfrom psutil._compat import FileNotFoundError\nfrom psutil._compat import long\nfrom psutil._compat import redirect_stderr\nfrom psutil._compat import super\nfrom psutil.tests import APPVEYOR\nfrom psutil.tests import CI_TESTING\nfrom psutil.tests import GITHUB_ACTIONS\nfrom psutil.tests import GLOBAL_TIMEOUT\nfrom psutil.tests import HAS_CPU_AFFINITY\nfrom psutil.tests import HAS_ENVIRON\nfrom psutil.tests import HAS_IONICE\nfrom psutil.tests import HAS_MEMORY_MAPS\nfrom psutil.tests import HAS_PROC_CPU_NUM\nfrom psutil.tests import HAS_PROC_IO_COUNTERS\nfrom psutil.tests import HAS_RLIMIT\nfrom psutil.tests import HAS_THREADS\nfrom psutil.tests import MACOS_11PLUS\nfrom psutil.tests import PYPY\nfrom psutil.tests import PYTHON_EXE\nfrom psutil.tests import PYTHON_EXE_ENV\nfrom psutil.tests import QEMU_USER\nfrom psutil.tests import PsutilTestCase\nfrom psutil.tests import ThreadTask\nfrom psutil.tests import call_until\nfrom psutil.tests import copyload_shared_lib\nfrom psutil.tests import create_c_exe\nfrom psutil.tests import create_py_exe\nfrom psutil.tests import mock\nfrom psutil.tests import process_namespace\nfrom psutil.tests import reap_children\nfrom psutil.tests import retry_on_failure\nfrom psutil.tests import sh\nfrom psutil.tests import skip_on_access_denied\nfrom psutil.tests import skip_on_not_implemented\nfrom psutil.tests import wait_for_pid\n\n\n# ===================================================================\n# --- psutil.Process class tests\n# ===================================================================\n\n\nclass TestProcess(PsutilTestCase):\n    \"\"\"Tests for psutil.Process class.\"\"\"\n\n    def spawn_psproc(self, *args, **kwargs):\n        sproc = self.spawn_testproc(*args, **kwargs)\n        try:\n            return psutil.Process(sproc.pid)\n        except psutil.NoSuchProcess:\n            self.assertPidGone(sproc.pid)\n            raise\n\n    # ---\n\n    def test_pid(self):\n        p = psutil.Process()\n        self.assertEqual(p.pid, os.getpid())\n        with self.assertRaises(AttributeError):\n            p.pid = 33\n\n    def test_kill(self):\n        p = self.spawn_psproc()\n        p.kill()\n        code = p.wait()\n        if WINDOWS:\n            self.assertEqual(code, signal.SIGTERM)\n        else:\n            self.assertEqual(code, -signal.SIGKILL)\n        self.assertProcessGone(p)\n\n    def test_terminate(self):\n        p = self.spawn_psproc()\n        p.terminate()\n        code = p.wait()\n        if WINDOWS:\n            self.assertEqual(code, signal.SIGTERM)\n        else:\n            self.assertEqual(code, -signal.SIGTERM)\n        self.assertProcessGone(p)\n\n    def test_send_signal(self):\n        sig = signal.SIGKILL if POSIX else signal.SIGTERM\n        p = self.spawn_psproc()\n        p.send_signal(sig)\n        code = p.wait()\n        if WINDOWS:\n            self.assertEqual(code, sig)\n        else:\n            self.assertEqual(code, -sig)\n        self.assertProcessGone(p)\n\n    @unittest.skipIf(not POSIX, \"not POSIX\")\n    def test_send_signal_mocked(self):\n        sig = signal.SIGTERM\n        p = self.spawn_psproc()\n        with mock.patch(\n            'psutil.os.kill', side_effect=OSError(errno.ESRCH, \"\")\n        ):\n            self.assertRaises(psutil.NoSuchProcess, p.send_signal, sig)\n\n        p = self.spawn_psproc()\n        with mock.patch(\n            'psutil.os.kill', side_effect=OSError(errno.EPERM, \"\")\n        ):\n            self.assertRaises(psutil.AccessDenied, p.send_signal, sig)\n\n    def test_wait_exited(self):\n        # Test waitpid() + WIFEXITED -> WEXITSTATUS.\n        # normal return, same as exit(0)\n        cmd = [PYTHON_EXE, \"-c\", \"pass\"]\n        p = self.spawn_psproc(cmd)\n        code = p.wait()\n        self.assertEqual(code, 0)\n        self.assertProcessGone(p)\n        # exit(1), implicit in case of error\n        cmd = [PYTHON_EXE, \"-c\", \"1 / 0\"]\n        p = self.spawn_psproc(cmd, stderr=subprocess.PIPE)\n        code = p.wait()\n        self.assertEqual(code, 1)\n        self.assertProcessGone(p)\n        # via sys.exit()\n        cmd = [PYTHON_EXE, \"-c\", \"import sys; sys.exit(5);\"]\n        p = self.spawn_psproc(cmd)\n        code = p.wait()\n        self.assertEqual(code, 5)\n        self.assertProcessGone(p)\n        # via os._exit()\n        cmd = [PYTHON_EXE, \"-c\", \"import os; os._exit(5);\"]\n        p = self.spawn_psproc(cmd)\n        code = p.wait()\n        self.assertEqual(code, 5)\n        self.assertProcessGone(p)\n\n    @unittest.skipIf(NETBSD, \"fails on NETBSD\")\n    def test_wait_stopped(self):\n        p = self.spawn_psproc()\n        if POSIX:\n            # Test waitpid() + WIFSTOPPED and WIFCONTINUED.\n            # Note: if a process is stopped it ignores SIGTERM.\n            p.send_signal(signal.SIGSTOP)\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.send_signal(signal.SIGCONT)\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.send_signal(signal.SIGTERM)\n            self.assertEqual(p.wait(), -signal.SIGTERM)\n            self.assertEqual(p.wait(), -signal.SIGTERM)\n        else:\n            p.suspend()\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.resume()\n            self.assertRaises(psutil.TimeoutExpired, p.wait, timeout=0.001)\n            p.terminate()\n            self.assertEqual(p.wait(), signal.SIGTERM)\n            self.assertEqual(p.wait(), signal.SIGTERM)\n\n    def test_wait_non_children(self):\n        # Test wait() against a process which is not our direct\n        # child.\n        child, grandchild = self.spawn_children_pair()\n        self.assertRaises(psutil.TimeoutExpired, child.wait, 0.01)\n        self.assertRaises(psutil.TimeoutExpired, grandchild.wait, 0.01)\n        # We also terminate the direct child otherwise the\n        # grandchild will hang until the parent is gone.\n        child.terminate()\n        grandchild.terminate()\n        child_ret = child.wait()\n        grandchild_ret = grandchild.wait()\n        if POSIX:\n            self.assertEqual(child_ret, -signal.SIGTERM)\n            # For processes which are not our children we're supposed\n            # to get None.\n            self.assertEqual(grandchild_ret, None)\n        else:\n            self.assertEqual(child_ret, signal.SIGTERM)\n            self.assertEqual(child_ret, signal.SIGTERM)\n\n    def test_wait_timeout(self):\n        p = self.spawn_psproc()\n        p.name()\n        self.assertRaises(psutil.TimeoutExpired, p.wait, 0.01)\n        self.assertRaises(psutil.TimeoutExpired, p.wait, 0)\n        self.assertRaises(ValueError, p.wait, -1)\n\n    def test_wait_timeout_nonblocking(self):\n        p = self.spawn_psproc()\n        self.assertRaises(psutil.TimeoutExpired, p.wait, 0)\n        p.kill()\n        stop_at = time.time() + GLOBAL_TIMEOUT\n        while time.time() < stop_at:\n            try:\n                code = p.wait(0)\n                break\n            except psutil.TimeoutExpired:\n                pass\n        else:\n            raise self.fail('timeout')\n        if POSIX:\n            self.assertEqual(code, -signal.SIGKILL)\n        else:\n            self.assertEqual(code, signal.SIGTERM)\n        self.assertProcessGone(p)\n\n    def test_cpu_percent(self):\n        p = psutil.Process()\n        p.cpu_percent(interval=0.001)\n        p.cpu_percent(interval=0.001)\n        for _ in range(100):\n            percent = p.cpu_percent(interval=None)\n            self.assertIsInstance(percent, float)\n            self.assertGreaterEqual(percent, 0.0)\n        with self.assertRaises(ValueError):\n            p.cpu_percent(interval=-1)\n\n    def test_cpu_percent_numcpus_none(self):\n        # See: https://github.com/giampaolo/psutil/issues/1087\n        with mock.patch('psutil.cpu_count', return_value=None) as m:\n            psutil.Process().cpu_percent()\n            assert m.called\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    def test_cpu_times(self):\n        times = psutil.Process().cpu_times()\n        assert times.user >= 0.0, times\n        assert times.system >= 0.0, times\n        assert times.children_user >= 0.0, times\n        assert times.children_system >= 0.0, times\n        if LINUX:\n            assert times.iowait >= 0.0, times\n        # make sure returned values can be pretty printed with strftime\n        for name in times._fields:\n            time.strftime(\"%H:%M:%S\", time.localtime(getattr(times, name)))\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    def test_cpu_times_2(self):\n        user_time, kernel_time = psutil.Process().cpu_times()[:2]\n        utime, ktime = os.times()[:2]\n\n        # Use os.times()[:2] as base values to compare our results\n        # using a tolerance  of +/- 0.1 seconds.\n        # It will fail if the difference between the values is > 0.1s.\n        if (max([user_time, utime]) - min([user_time, utime])) > 0.1:\n            raise self.fail(\"expected: %s, found: %s\" % (utime, user_time))\n\n        if (max([kernel_time, ktime]) - min([kernel_time, ktime])) > 0.1:\n            raise self.fail(\"expected: %s, found: %s\" % (ktime, kernel_time))\n\n    @unittest.skipIf(not HAS_PROC_CPU_NUM, \"not supported\")\n    def test_cpu_num(self):\n        p = psutil.Process()\n        num = p.cpu_num()\n        self.assertGreaterEqual(num, 0)\n        if psutil.cpu_count() == 1:\n            self.assertEqual(num, 0)\n        self.assertIn(p.cpu_num(), range(psutil.cpu_count()))\n\n    def test_create_time(self):\n        p = self.spawn_psproc()\n        now = time.time()\n        create_time = p.create_time()\n\n        # Use time.time() as base value to compare our result using a\n        # tolerance of +/- 1 second.\n        # It will fail if the difference between the values is > 2s.\n        difference = abs(create_time - now)\n        if difference > 2:\n            raise self.fail(\n                \"expected: %s, found: %s, difference: %s\"\n                % (now, create_time, difference)\n            )\n\n        # make sure returned value can be pretty printed with strftime\n        time.strftime(\"%Y %m %d %H:%M:%S\", time.localtime(p.create_time()))\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_terminal(self):\n        terminal = psutil.Process().terminal()\n        if terminal is not None:\n            tty = os.path.realpath(sh('tty'))\n            self.assertEqual(terminal, tty)\n\n    @unittest.skipIf(not HAS_PROC_IO_COUNTERS, 'not supported')\n    @skip_on_not_implemented(only_if=LINUX)\n    def test_io_counters(self):\n        p = psutil.Process()\n        # test reads\n        io1 = p.io_counters()\n        with open(PYTHON_EXE, 'rb') as f:\n            f.read()\n        io2 = p.io_counters()\n        if not BSD and not AIX:\n            self.assertGreater(io2.read_count, io1.read_count)\n            self.assertEqual(io2.write_count, io1.write_count)\n            if LINUX:\n                self.assertGreater(io2.read_chars, io1.read_chars)\n                self.assertEqual(io2.write_chars, io1.write_chars)\n        else:\n            self.assertGreaterEqual(io2.read_bytes, io1.read_bytes)\n            self.assertGreaterEqual(io2.write_bytes, io1.write_bytes)\n\n        # test writes\n        io1 = p.io_counters()\n        with open(self.get_testfn(), 'wb') as f:\n            if PY3:\n                f.write(bytes(\"x\" * 1000000, 'ascii'))\n            else:\n                f.write(\"x\" * 1000000)\n        io2 = p.io_counters()\n        self.assertGreaterEqual(io2.write_count, io1.write_count)\n        self.assertGreaterEqual(io2.write_bytes, io1.write_bytes)\n        self.assertGreaterEqual(io2.read_count, io1.read_count)\n        self.assertGreaterEqual(io2.read_bytes, io1.read_bytes)\n        if LINUX:\n            self.assertGreater(io2.write_chars, io1.write_chars)\n            self.assertGreaterEqual(io2.read_chars, io1.read_chars)\n\n        # sanity check\n        for i in range(len(io2)):\n            if BSD and i >= 2:\n                # On BSD read_bytes and write_bytes are always set to -1.\n                continue\n            self.assertGreaterEqual(io2[i], 0)\n            self.assertGreaterEqual(io2[i], 0)\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    @unittest.skipIf(not LINUX, \"linux only\")\n    def test_ionice_linux(self):\n        def cleanup(init):\n            ioclass, value = init\n            if ioclass == psutil.IOPRIO_CLASS_NONE:\n                value = 0\n            p.ionice(ioclass, value)\n\n        p = psutil.Process()\n        if not CI_TESTING:\n            self.assertEqual(p.ionice()[0], psutil.IOPRIO_CLASS_NONE)\n        self.assertEqual(psutil.IOPRIO_CLASS_NONE, 0)\n        self.assertEqual(psutil.IOPRIO_CLASS_RT, 1)  # high\n        self.assertEqual(psutil.IOPRIO_CLASS_BE, 2)  # normal\n        self.assertEqual(psutil.IOPRIO_CLASS_IDLE, 3)  # low\n        init = p.ionice()\n        self.addCleanup(cleanup, init)\n\n        # low\n        p.ionice(psutil.IOPRIO_CLASS_IDLE)\n        self.assertEqual(tuple(p.ionice()), (psutil.IOPRIO_CLASS_IDLE, 0))\n        with self.assertRaises(ValueError):  # accepts no value\n            p.ionice(psutil.IOPRIO_CLASS_IDLE, value=7)\n        # normal\n        p.ionice(psutil.IOPRIO_CLASS_BE)\n        self.assertEqual(tuple(p.ionice()), (psutil.IOPRIO_CLASS_BE, 0))\n        p.ionice(psutil.IOPRIO_CLASS_BE, value=7)\n        self.assertEqual(tuple(p.ionice()), (psutil.IOPRIO_CLASS_BE, 7))\n        with self.assertRaises(ValueError):\n            p.ionice(psutil.IOPRIO_CLASS_BE, value=8)\n        try:\n            p.ionice(psutil.IOPRIO_CLASS_RT, value=7)\n        except psutil.AccessDenied:\n            pass\n        # errs\n        with self.assertRaisesRegex(ValueError, \"ioclass accepts no value\"):\n            p.ionice(psutil.IOPRIO_CLASS_NONE, 1)\n        with self.assertRaisesRegex(ValueError, \"ioclass accepts no value\"):\n            p.ionice(psutil.IOPRIO_CLASS_IDLE, 1)\n        with self.assertRaisesRegex(\n            ValueError, \"'ioclass' argument must be specified\"\n        ):\n            p.ionice(value=1)\n\n    @unittest.skipIf(not HAS_IONICE, \"not supported\")\n    @unittest.skipIf(not WINDOWS, 'not supported on this win version')\n    def test_ionice_win(self):\n        p = psutil.Process()\n        if not CI_TESTING:\n            self.assertEqual(p.ionice(), psutil.IOPRIO_NORMAL)\n        init = p.ionice()\n        self.addCleanup(p.ionice, init)\n\n        # base\n        p.ionice(psutil.IOPRIO_VERYLOW)\n        self.assertEqual(p.ionice(), psutil.IOPRIO_VERYLOW)\n        p.ionice(psutil.IOPRIO_LOW)\n        self.assertEqual(p.ionice(), psutil.IOPRIO_LOW)\n        try:\n            p.ionice(psutil.IOPRIO_HIGH)\n        except psutil.AccessDenied:\n            pass\n        else:\n            self.assertEqual(p.ionice(), psutil.IOPRIO_HIGH)\n        # errs\n        with self.assertRaisesRegex(\n            TypeError, \"value argument not accepted on Windows\"\n        ):\n            p.ionice(psutil.IOPRIO_NORMAL, value=1)\n        with self.assertRaisesRegex(ValueError, \"is not a valid priority\"):\n            p.ionice(psutil.IOPRIO_HIGH + 1)\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_get(self):\n        import resource\n\n        p = psutil.Process(os.getpid())\n        names = [x for x in dir(psutil) if x.startswith('RLIMIT')]\n        assert names, names\n        for name in names:\n            value = getattr(psutil, name)\n            self.assertGreaterEqual(value, 0)\n            if name in dir(resource):\n                self.assertEqual(value, getattr(resource, name))\n                # XXX - On PyPy RLIMIT_INFINITY returned by\n                # resource.getrlimit() is reported as a very big long\n                # number instead of -1. It looks like a bug with PyPy.\n                if PYPY:\n                    continue\n                self.assertEqual(p.rlimit(value), resource.getrlimit(value))\n            else:\n                ret = p.rlimit(value)\n                self.assertEqual(len(ret), 2)\n                self.assertGreaterEqual(ret[0], -1)\n                self.assertGreaterEqual(ret[1], -1)\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_set(self):\n        p = self.spawn_psproc()\n        p.rlimit(psutil.RLIMIT_NOFILE, (5, 5))\n        self.assertEqual(p.rlimit(psutil.RLIMIT_NOFILE), (5, 5))\n        # If pid is 0 prlimit() applies to the calling process and\n        # we don't want that.\n        if LINUX:\n            with self.assertRaisesRegex(ValueError, \"can't use prlimit\"):\n                psutil._psplatform.Process(0).rlimit(0)\n        with self.assertRaises(ValueError):\n            p.rlimit(psutil.RLIMIT_NOFILE, (5, 5, 5))\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit(self):\n        p = psutil.Process()\n        testfn = self.get_testfn()\n        soft, hard = p.rlimit(psutil.RLIMIT_FSIZE)\n        try:\n            p.rlimit(psutil.RLIMIT_FSIZE, (1024, hard))\n            with open(testfn, \"wb\") as f:\n                f.write(b\"X\" * 1024)\n            # write() or flush() doesn't always cause the exception\n            # but close() will.\n            with self.assertRaises(IOError) as exc:\n                with open(testfn, \"wb\") as f:\n                    f.write(b\"X\" * 1025)\n            self.assertEqual(\n                exc.exception.errno if PY3 else exc.exception[0], errno.EFBIG\n            )\n        finally:\n            p.rlimit(psutil.RLIMIT_FSIZE, (soft, hard))\n            self.assertEqual(p.rlimit(psutil.RLIMIT_FSIZE), (soft, hard))\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_infinity(self):\n        # First set a limit, then re-set it by specifying INFINITY\n        # and assume we overridden the previous limit.\n        p = psutil.Process()\n        soft, hard = p.rlimit(psutil.RLIMIT_FSIZE)\n        try:\n            p.rlimit(psutil.RLIMIT_FSIZE, (1024, hard))\n            p.rlimit(psutil.RLIMIT_FSIZE, (psutil.RLIM_INFINITY, hard))\n            with open(self.get_testfn(), \"wb\") as f:\n                f.write(b\"X\" * 2048)\n        finally:\n            p.rlimit(psutil.RLIMIT_FSIZE, (soft, hard))\n            self.assertEqual(p.rlimit(psutil.RLIMIT_FSIZE), (soft, hard))\n\n    @unittest.skipIf(not HAS_RLIMIT, \"not supported\")\n    def test_rlimit_infinity_value(self):\n        # RLIMIT_FSIZE should be RLIM_INFINITY, which will be a really\n        # big number on a platform with large file support.  On these\n        # platforms we need to test that the get/setrlimit functions\n        # properly convert the number to a C long long and that the\n        # conversion doesn't raise an error.\n        p = psutil.Process()\n        soft, hard = p.rlimit(psutil.RLIMIT_FSIZE)\n        self.assertEqual(psutil.RLIM_INFINITY, hard)\n        p.rlimit(psutil.RLIMIT_FSIZE, (soft, hard))\n\n    def test_num_threads(self):\n        # on certain platforms such as Linux we might test for exact\n        # thread number, since we always have with 1 thread per process,\n        # but this does not apply across all platforms (MACOS, Windows)\n        p = psutil.Process()\n        if OPENBSD:\n            try:\n                step1 = p.num_threads()\n            except psutil.AccessDenied:\n                raise unittest.SkipTest(\"on OpenBSD this requires root access\")\n        else:\n            step1 = p.num_threads()\n\n        with ThreadTask():\n            step2 = p.num_threads()\n            self.assertEqual(step2, step1 + 1)\n\n    @unittest.skipIf(not WINDOWS, 'WINDOWS only')\n    def test_num_handles(self):\n        # a better test is done later into test/_windows.py\n        p = psutil.Process()\n        self.assertGreater(p.num_handles(), 0)\n\n    @unittest.skipIf(not HAS_THREADS, 'not supported')\n    def test_threads(self):\n        p = psutil.Process()\n        if OPENBSD:\n            try:\n                step1 = p.threads()\n            except psutil.AccessDenied:\n                raise unittest.SkipTest(\"on OpenBSD this requires root access\")\n        else:\n            step1 = p.threads()\n\n        with ThreadTask():\n            step2 = p.threads()\n            self.assertEqual(len(step2), len(step1) + 1)\n            athread = step2[0]\n            # test named tuple\n            self.assertEqual(athread.id, athread[0])\n            self.assertEqual(athread.user_time, athread[1])\n            self.assertEqual(athread.system_time, athread[2])\n\n    @retry_on_failure()\n    @skip_on_access_denied(only_if=MACOS)\n    @unittest.skipIf(not HAS_THREADS, 'not supported')\n    def test_threads_2(self):\n        p = self.spawn_psproc()\n        if OPENBSD:\n            try:\n                p.threads()\n            except psutil.AccessDenied:\n                raise unittest.SkipTest(\"on OpenBSD this requires root access\")\n        self.assertAlmostEqual(\n            p.cpu_times().user,\n            sum([x.user_time for x in p.threads()]),\n            delta=0.1,\n        )\n        self.assertAlmostEqual(\n            p.cpu_times().system,\n            sum([x.system_time for x in p.threads()]),\n            delta=0.1,\n        )\n\n    @retry_on_failure()\n    def test_memory_info(self):\n        p = psutil.Process()\n\n        # step 1 - get a base value to compare our results\n        rss1, vms1 = p.memory_info()[:2]\n        percent1 = p.memory_percent()\n        self.assertGreater(rss1, 0)\n        self.assertGreater(vms1, 0)\n\n        # step 2 - allocate some memory\n        memarr = [None] * 1500000\n\n        rss2, vms2 = p.memory_info()[:2]\n        percent2 = p.memory_percent()\n\n        # step 3 - make sure that the memory usage bumped up\n        self.assertGreater(rss2, rss1)\n        self.assertGreaterEqual(vms2, vms1)  # vms might be equal\n        self.assertGreater(percent2, percent1)\n        del memarr\n\n        if WINDOWS:\n            mem = p.memory_info()\n            self.assertEqual(mem.rss, mem.wset)\n            self.assertEqual(mem.vms, mem.pagefile)\n\n        mem = p.memory_info()\n        for name in mem._fields:\n            self.assertGreaterEqual(getattr(mem, name), 0)\n\n    def test_memory_full_info(self):\n        p = psutil.Process()\n        total = psutil.virtual_memory().total\n        mem = p.memory_full_info()\n        for name in mem._fields:\n            value = getattr(mem, name)\n            self.assertGreaterEqual(value, 0, msg=(name, value))\n            if name == 'vms' and OSX or LINUX:\n                continue\n            self.assertLessEqual(value, total, msg=(name, value, total))\n        if LINUX or WINDOWS or MACOS:\n            self.assertGreaterEqual(mem.uss, 0)\n        if LINUX:\n            self.assertGreaterEqual(mem.pss, 0)\n            self.assertGreaterEqual(mem.swap, 0)\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    def test_memory_maps(self):\n        p = psutil.Process()\n        maps = p.memory_maps()\n        self.assertEqual(len(maps), len(set(maps)))\n        ext_maps = p.memory_maps(grouped=False)\n\n        for nt in maps:\n            if not nt.path.startswith('['):\n                if QEMU_USER and \"/bin/qemu-\" in nt.path:\n                    continue\n                assert os.path.isabs(nt.path), nt.path\n                if POSIX:\n                    try:\n                        assert os.path.exists(nt.path) or os.path.islink(\n                            nt.path\n                        ), nt.path\n                    except AssertionError:\n                        if not LINUX:\n                            raise\n                        else:\n                            # https://github.com/giampaolo/psutil/issues/759\n                            with open_text('/proc/self/smaps') as f:\n                                data = f.read()\n                            if \"%s (deleted)\" % nt.path not in data:\n                                raise\n                else:\n                    # XXX - On Windows we have this strange behavior with\n                    # 64 bit dlls: they are visible via explorer but cannot\n                    # be accessed via os.stat() (wtf?).\n                    if '64' not in os.path.basename(nt.path):\n                        try:\n                            st = os.stat(nt.path)\n                        except FileNotFoundError:\n                            pass\n                        else:\n                            assert stat.S_ISREG(st.st_mode), nt.path\n        for nt in ext_maps:\n            for fname in nt._fields:\n                value = getattr(nt, fname)\n                if fname == 'path':\n                    continue\n                if fname in ('addr', 'perms'):\n                    assert value, value\n                else:\n                    self.assertIsInstance(value, (int, long))\n                    assert value >= 0, value\n\n    @unittest.skipIf(not HAS_MEMORY_MAPS, \"not supported\")\n    def test_memory_maps_lists_lib(self):\n        # Make sure a newly loaded shared lib is listed.\n        p = psutil.Process()\n        with copyload_shared_lib() as path:\n\n            def normpath(p):\n                return os.path.realpath(os.path.normcase(p))\n\n            libpaths = [normpath(x.path) for x in p.memory_maps()]\n            self.assertIn(normpath(path), libpaths)\n\n    def test_memory_percent(self):\n        p = psutil.Process()\n        p.memory_percent()\n        self.assertRaises(ValueError, p.memory_percent, memtype=\"?!?\")\n        if LINUX or MACOS or WINDOWS:\n            p.memory_percent(memtype='uss')\n\n    def test_is_running(self):\n        p = self.spawn_psproc()\n        assert p.is_running()\n        assert p.is_running()\n        p.kill()\n        p.wait()\n        assert not p.is_running()\n        assert not p.is_running()\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    def test_exe(self):\n        p = self.spawn_psproc()\n        exe = p.exe()\n        try:\n            self.assertEqual(exe, PYTHON_EXE)\n        except AssertionError:\n            if WINDOWS and len(exe) == len(PYTHON_EXE):\n                # on Windows we don't care about case sensitivity\n                normcase = os.path.normcase\n                self.assertEqual(normcase(exe), normcase(PYTHON_EXE))\n            else:\n                # certain platforms such as BSD are more accurate returning:\n                # \"/usr/local/bin/python2.7\"\n                # ...instead of:\n                # \"/usr/local/bin/python\"\n                # We do not want to consider this difference in accuracy\n                # an error.\n                ver = \"%s.%s\" % (sys.version_info[0], sys.version_info[1])\n                try:\n                    self.assertEqual(\n                        exe.replace(ver, ''), PYTHON_EXE.replace(ver, '')\n                    )\n                except AssertionError:\n                    # Typically MACOS. Really not sure what to do here.\n                    pass\n\n        out = sh([exe, \"-c\", \"import os; print('hey')\"])\n        self.assertEqual(out, 'hey')\n\n    def test_cmdline(self):\n        cmdline = [\n            PYTHON_EXE,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)]\",\n        ]\n        p = self.spawn_psproc(cmdline)\n\n        if NETBSD and p.cmdline() == []:\n            # https://github.com/giampaolo/psutil/issues/2250\n            raise unittest.SkipTest(\"OPENBSD: returned EBUSY\")\n\n        # XXX - most of the times the underlying sysctl() call on Net\n        # and Open BSD returns a truncated string.\n        # Also /proc/pid/cmdline behaves the same so it looks\n        # like this is a kernel bug.\n        # XXX - AIX truncates long arguments in /proc/pid/cmdline\n        if NETBSD or OPENBSD or AIX:\n            self.assertEqual(p.cmdline()[0], PYTHON_EXE)\n        else:\n            if MACOS and CI_TESTING:\n                pyexe = p.cmdline()[0]\n                if pyexe != PYTHON_EXE:\n                    self.assertEqual(\n                        ' '.join(p.cmdline()[1:]), ' '.join(cmdline[1:])\n                    )\n                    return\n            if QEMU_USER:\n                self.assertEqual(' '.join(p.cmdline()[2:]), ' '.join(cmdline))\n                return\n            self.assertEqual(' '.join(p.cmdline()), ' '.join(cmdline))\n\n    @unittest.skipIf(PYPY, \"broken on PYPY\")\n    def test_long_cmdline(self):\n        cmdline = [PYTHON_EXE]\n        cmdline.extend([\"-v\"] * 50)\n        cmdline.extend(\n            [\"-c\", \"import time; [time.sleep(0.1) for x in range(100)]\"]\n        )\n        p = self.spawn_psproc(cmdline)\n        if OPENBSD:\n            # XXX: for some reason the test process may turn into a\n            # zombie (don't know why).\n            try:\n                self.assertEqual(p.cmdline(), cmdline)\n            except psutil.ZombieProcess:\n                raise unittest.SkipTest(\"OPENBSD: process turned into zombie\")\n        elif QEMU_USER:\n            self.assertEqual(p.cmdline()[2:], cmdline)\n        else:\n            ret = p.cmdline()\n            if NETBSD and ret == []:\n                # https://github.com/giampaolo/psutil/issues/2250\n                raise unittest.SkipTest(\"OPENBSD: returned EBUSY\")\n            self.assertEqual(ret, cmdline)\n\n    def test_name(self):\n        p = self.spawn_psproc()\n        name = p.name().lower()\n        pyexe = os.path.basename(os.path.realpath(sys.executable)).lower()\n        assert pyexe.startswith(name), (pyexe, name)\n\n    @unittest.skipIf(PYPY or QEMU_USER, \"unreliable on PYPY\")\n    @unittest.skipIf(QEMU_USER, \"unreliable on QEMU user\")\n    def test_long_name(self):\n        pyexe = create_py_exe(self.get_testfn(suffix=\"0123456789\" * 2))\n        cmdline = [\n            pyexe,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)]\",\n        ]\n        p = self.spawn_psproc(cmdline)\n        if OPENBSD:\n            # XXX: for some reason the test process may turn into a\n            # zombie (don't know why). Because the name() is long, all\n            # UNIX kernels truncate it to 15 chars, so internally psutil\n            # tries to guess the full name() from the cmdline(). But the\n            # cmdline() of a zombie on OpenBSD fails (internally), so we\n            # just compare the first 15 chars. Full explanation:\n            # https://github.com/giampaolo/psutil/issues/2239\n            try:\n                self.assertEqual(p.name(), os.path.basename(pyexe))\n            except AssertionError:\n                if p.status() == psutil.STATUS_ZOMBIE:\n                    assert os.path.basename(pyexe).startswith(p.name())\n                else:\n                    raise\n        else:\n            self.assertEqual(p.name(), os.path.basename(pyexe))\n\n    # XXX\n    @unittest.skipIf(SUNOS, \"broken on SUNOS\")\n    @unittest.skipIf(AIX, \"broken on AIX\")\n    @unittest.skipIf(PYPY, \"broken on PYPY\")\n    @unittest.skipIf(QEMU_USER, \"broken on QEMU user\")\n    def test_prog_w_funky_name(self):\n        # Test that name(), exe() and cmdline() correctly handle programs\n        # with funky chars such as spaces and \")\", see:\n        # https://github.com/giampaolo/psutil/issues/628\n        pyexe = create_py_exe(self.get_testfn(suffix='foo bar )'))\n        cmdline = [\n            pyexe,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)]\",\n        ]\n        p = self.spawn_psproc(cmdline)\n        self.assertEqual(p.cmdline(), cmdline)\n        self.assertEqual(p.name(), os.path.basename(pyexe))\n        self.assertEqual(os.path.normcase(p.exe()), os.path.normcase(pyexe))\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_uids(self):\n        p = psutil.Process()\n        real, effective, _saved = p.uids()\n        # os.getuid() refers to \"real\" uid\n        self.assertEqual(real, os.getuid())\n        # os.geteuid() refers to \"effective\" uid\n        self.assertEqual(effective, os.geteuid())\n        # No such thing as os.getsuid() (\"saved\" uid), but starting\n        # from python 2.7 we have os.getresuid() which returns all\n        # of them.\n        if hasattr(os, \"getresuid\"):\n            self.assertEqual(os.getresuid(), p.uids())\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_gids(self):\n        p = psutil.Process()\n        real, effective, _saved = p.gids()\n        # os.getuid() refers to \"real\" uid\n        self.assertEqual(real, os.getgid())\n        # os.geteuid() refers to \"effective\" uid\n        self.assertEqual(effective, os.getegid())\n        # No such thing as os.getsgid() (\"saved\" gid), but starting\n        # from python 2.7 we have os.getresgid() which returns all\n        # of them.\n        if hasattr(os, \"getresuid\"):\n            self.assertEqual(os.getresgid(), p.gids())\n\n    def test_nice(self):\n        def cleanup(init):\n            try:\n                p.nice(init)\n            except psutil.AccessDenied:\n                pass\n\n        p = psutil.Process()\n        self.assertRaises(TypeError, p.nice, \"str\")\n        init = p.nice()\n        self.addCleanup(cleanup, init)\n\n        if WINDOWS:\n            highest_prio = None\n            for prio in [\n                psutil.IDLE_PRIORITY_CLASS,\n                psutil.BELOW_NORMAL_PRIORITY_CLASS,\n                psutil.NORMAL_PRIORITY_CLASS,\n                psutil.ABOVE_NORMAL_PRIORITY_CLASS,\n                psutil.HIGH_PRIORITY_CLASS,\n                psutil.REALTIME_PRIORITY_CLASS,\n            ]:\n                with self.subTest(prio=prio):\n                    try:\n                        p.nice(prio)\n                    except psutil.AccessDenied:\n                        pass\n                    else:\n                        new_prio = p.nice()\n                        # The OS may limit our maximum priority,\n                        # even if the function succeeds. For higher\n                        # priorities, we match either the expected\n                        # value or the highest so far.\n                        if prio in (\n                            psutil.ABOVE_NORMAL_PRIORITY_CLASS,\n                            psutil.HIGH_PRIORITY_CLASS,\n                            psutil.REALTIME_PRIORITY_CLASS,\n                        ):\n                            if new_prio == prio or highest_prio is None:\n                                highest_prio = prio\n                                self.assertEqual(new_prio, highest_prio)\n                        else:\n                            self.assertEqual(new_prio, prio)\n        else:\n            try:\n                if hasattr(os, \"getpriority\"):\n                    self.assertEqual(\n                        os.getpriority(os.PRIO_PROCESS, os.getpid()), p.nice()\n                    )\n                p.nice(1)\n                self.assertEqual(p.nice(), 1)\n                if hasattr(os, \"getpriority\"):\n                    self.assertEqual(\n                        os.getpriority(os.PRIO_PROCESS, os.getpid()), p.nice()\n                    )\n                # XXX - going back to previous nice value raises\n                # AccessDenied on MACOS\n                if not MACOS:\n                    p.nice(0)\n                    self.assertEqual(p.nice(), 0)\n            except psutil.AccessDenied:\n                pass\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    def test_status(self):\n        p = psutil.Process()\n        self.assertEqual(p.status(), psutil.STATUS_RUNNING)\n\n    def test_username(self):\n        p = self.spawn_psproc()\n        username = p.username()\n        if WINDOWS:\n            domain, username = username.split('\\\\')\n            getpass_user = getpass.getuser()\n            if getpass_user.endswith('$'):\n                # When running as a service account (most likely to be\n                # NetworkService), these user name calculations don't produce\n                # the same result, causing the test to fail.\n                raise unittest.SkipTest('running as service account')\n            self.assertEqual(username, getpass_user)\n            if 'USERDOMAIN' in os.environ:\n                self.assertEqual(domain, os.environ['USERDOMAIN'])\n        else:\n            self.assertEqual(username, getpass.getuser())\n\n    def test_cwd(self):\n        p = self.spawn_psproc()\n        self.assertEqual(p.cwd(), os.getcwd())\n\n    def test_cwd_2(self):\n        cmd = [\n            PYTHON_EXE,\n            \"-c\",\n            (\n                \"import os, time; os.chdir('..'); [time.sleep(0.1) for x in\"\n                \" range(100)]\"\n            ),\n        ]\n        p = self.spawn_psproc(cmd)\n        call_until(p.cwd, \"ret == os.path.dirname(os.getcwd())\")\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, 'not supported')\n    def test_cpu_affinity(self):\n        p = psutil.Process()\n        initial = p.cpu_affinity()\n        assert initial, initial\n        self.addCleanup(p.cpu_affinity, initial)\n\n        if hasattr(os, \"sched_getaffinity\"):\n            self.assertEqual(initial, list(os.sched_getaffinity(p.pid)))\n        self.assertEqual(len(initial), len(set(initial)))\n\n        all_cpus = list(range(len(psutil.cpu_percent(percpu=True))))\n        for n in all_cpus:\n            p.cpu_affinity([n])\n            self.assertEqual(p.cpu_affinity(), [n])\n            if hasattr(os, \"sched_getaffinity\"):\n                self.assertEqual(\n                    p.cpu_affinity(), list(os.sched_getaffinity(p.pid))\n                )\n            # also test num_cpu()\n            if hasattr(p, \"num_cpu\"):\n                self.assertEqual(p.cpu_affinity()[0], p.num_cpu())\n\n        # [] is an alias for \"all eligible CPUs\"; on Linux this may\n        # not be equal to all available CPUs, see:\n        # https://github.com/giampaolo/psutil/issues/956\n        p.cpu_affinity([])\n        if LINUX:\n            self.assertEqual(p.cpu_affinity(), p._proc._get_eligible_cpus())\n        else:\n            self.assertEqual(p.cpu_affinity(), all_cpus)\n        if hasattr(os, \"sched_getaffinity\"):\n            self.assertEqual(\n                p.cpu_affinity(), list(os.sched_getaffinity(p.pid))\n            )\n\n        self.assertRaises(TypeError, p.cpu_affinity, 1)\n        p.cpu_affinity(initial)\n        # it should work with all iterables, not only lists\n        p.cpu_affinity(set(all_cpus))\n        p.cpu_affinity(tuple(all_cpus))\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, 'not supported')\n    def test_cpu_affinity_errs(self):\n        p = self.spawn_psproc()\n        invalid_cpu = [len(psutil.cpu_times(percpu=True)) + 10]\n        self.assertRaises(ValueError, p.cpu_affinity, invalid_cpu)\n        self.assertRaises(ValueError, p.cpu_affinity, range(10000, 11000))\n        self.assertRaises(TypeError, p.cpu_affinity, [0, \"1\"])\n        self.assertRaises(ValueError, p.cpu_affinity, [0, -1])\n\n    @unittest.skipIf(not HAS_CPU_AFFINITY, 'not supported')\n    def test_cpu_affinity_all_combinations(self):\n        p = psutil.Process()\n        initial = p.cpu_affinity()\n        assert initial, initial\n        self.addCleanup(p.cpu_affinity, initial)\n\n        # All possible CPU set combinations.\n        if len(initial) > 12:\n            initial = initial[:12]  # ...otherwise it will take forever\n        combos = []\n        for i in range(len(initial) + 1):\n            for subset in itertools.combinations(initial, i):\n                if subset:\n                    combos.append(list(subset))\n\n        for combo in combos:\n            p.cpu_affinity(combo)\n            self.assertEqual(sorted(p.cpu_affinity()), sorted(combo))\n\n    # TODO: #595\n    @unittest.skipIf(BSD, \"broken on BSD\")\n    # can't find any process file on Appveyor\n    @unittest.skipIf(APPVEYOR, \"unreliable on APPVEYOR\")\n    def test_open_files(self):\n        p = psutil.Process()\n        testfn = self.get_testfn()\n        files = p.open_files()\n        self.assertNotIn(testfn, files)\n        with open(testfn, 'wb') as f:\n            f.write(b'x' * 1024)\n            f.flush()\n            # give the kernel some time to see the new file\n            files = call_until(p.open_files, \"len(ret) != %i\" % len(files))\n            filenames = [os.path.normcase(x.path) for x in files]\n            self.assertIn(os.path.normcase(testfn), filenames)\n            if LINUX:\n                for file in files:\n                    if file.path == testfn:\n                        self.assertEqual(file.position, 1024)\n        for file in files:\n            assert os.path.isfile(file.path), file\n\n        # another process\n        cmdline = (\n            \"import time; f = open(r'%s', 'r'); [time.sleep(0.1) for x in\"\n            \" range(100)];\" % testfn\n        )\n        p = self.spawn_psproc([PYTHON_EXE, \"-c\", cmdline])\n\n        for x in range(100):\n            filenames = [os.path.normcase(x.path) for x in p.open_files()]\n            if testfn in filenames:\n                break\n            time.sleep(0.01)\n        else:\n            self.assertIn(os.path.normcase(testfn), filenames)\n        for file in filenames:\n            assert os.path.isfile(file), file\n\n    # TODO: #595\n    @unittest.skipIf(BSD, \"broken on BSD\")\n    # can't find any process file on Appveyor\n    @unittest.skipIf(APPVEYOR, \"unreliable on APPVEYOR\")\n    def test_open_files_2(self):\n        # test fd and path fields\n        p = psutil.Process()\n        normcase = os.path.normcase\n        testfn = self.get_testfn()\n        with open(testfn, 'w') as fileobj:\n            for file in p.open_files():\n                if (\n                    normcase(file.path) == normcase(fileobj.name)\n                    or file.fd == fileobj.fileno()\n                ):\n                    break\n            else:\n                raise self.fail(\n                    \"no file found; files=%s\" % (repr(p.open_files()))\n                )\n            self.assertEqual(normcase(file.path), normcase(fileobj.name))\n            if WINDOWS:\n                self.assertEqual(file.fd, -1)\n            else:\n                self.assertEqual(file.fd, fileobj.fileno())\n            # test positions\n            ntuple = p.open_files()[0]\n            self.assertEqual(ntuple[0], ntuple.path)\n            self.assertEqual(ntuple[1], ntuple.fd)\n            # test file is gone\n            self.assertNotIn(fileobj.name, p.open_files())\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_num_fds(self):\n        p = psutil.Process()\n        testfn = self.get_testfn()\n        start = p.num_fds()\n        file = open(testfn, 'w')\n        self.addCleanup(file.close)\n        self.assertEqual(p.num_fds(), start + 1)\n        sock = socket.socket()\n        self.addCleanup(sock.close)\n        self.assertEqual(p.num_fds(), start + 2)\n        file.close()\n        sock.close()\n        self.assertEqual(p.num_fds(), start)\n\n    @skip_on_not_implemented(only_if=LINUX)\n    @unittest.skipIf(OPENBSD or NETBSD, \"not reliable on OPENBSD & NETBSD\")\n    def test_num_ctx_switches(self):\n        p = psutil.Process()\n        before = sum(p.num_ctx_switches())\n        for _ in range(2):\n            time.sleep(0.05)  # this shall ensure a context switch happens\n            after = sum(p.num_ctx_switches())\n            if after > before:\n                return\n        raise self.fail(\"num ctx switches still the same after 2 iterations\")\n\n    def test_ppid(self):\n        p = psutil.Process()\n        if hasattr(os, 'getppid'):\n            self.assertEqual(p.ppid(), os.getppid())\n        p = self.spawn_psproc()\n        self.assertEqual(p.ppid(), os.getpid())\n\n    def test_parent(self):\n        p = self.spawn_psproc()\n        self.assertEqual(p.parent().pid, os.getpid())\n\n        lowest_pid = psutil.pids()[0]\n        self.assertIsNone(psutil.Process(lowest_pid).parent())\n\n    def test_parent_multi(self):\n        parent = psutil.Process()\n        child, grandchild = self.spawn_children_pair()\n        self.assertEqual(grandchild.parent(), child)\n        self.assertEqual(child.parent(), parent)\n\n    @unittest.skipIf(QEMU_USER, \"QEMU user not supported\")\n    @retry_on_failure()\n    def test_parents(self):\n        parent = psutil.Process()\n        assert parent.parents()\n        child, grandchild = self.spawn_children_pair()\n        self.assertEqual(child.parents()[0], parent)\n        self.assertEqual(grandchild.parents()[0], child)\n        self.assertEqual(grandchild.parents()[1], parent)\n\n    def test_children(self):\n        parent = psutil.Process()\n        self.assertEqual(parent.children(), [])\n        self.assertEqual(parent.children(recursive=True), [])\n        # On Windows we set the flag to 0 in order to cancel out the\n        # CREATE_NO_WINDOW flag (enabled by default) which creates\n        # an extra \"conhost.exe\" child.\n        child = self.spawn_psproc(creationflags=0)\n        children1 = parent.children()\n        children2 = parent.children(recursive=True)\n        for children in (children1, children2):\n            self.assertEqual(len(children), 1)\n            self.assertEqual(children[0].pid, child.pid)\n            self.assertEqual(children[0].ppid(), parent.pid)\n\n    def test_children_recursive(self):\n        # Test children() against two sub processes, p1 and p2, where\n        # p1 (our child) spawned p2 (our grandchild).\n        parent = psutil.Process()\n        child, grandchild = self.spawn_children_pair()\n        self.assertEqual(parent.children(), [child])\n        self.assertEqual(parent.children(recursive=True), [child, grandchild])\n        # If the intermediate process is gone there's no way for\n        # children() to recursively find it.\n        child.terminate()\n        child.wait()\n        self.assertEqual(parent.children(recursive=True), [])\n\n    def test_children_duplicates(self):\n        # find the process which has the highest number of children\n        table = collections.defaultdict(int)\n        for p in psutil.process_iter():\n            try:\n                table[p.ppid()] += 1\n            except psutil.Error:\n                pass\n        # this is the one, now let's make sure there are no duplicates\n        pid = sorted(table.items(), key=lambda x: x[1])[-1][0]\n        if LINUX and pid == 0:\n            raise unittest.SkipTest(\"PID 0\")\n        p = psutil.Process(pid)\n        try:\n            c = p.children(recursive=True)\n        except psutil.AccessDenied:  # windows\n            pass\n        else:\n            self.assertEqual(len(c), len(set(c)))\n\n    def test_parents_and_children(self):\n        parent = psutil.Process()\n        child, grandchild = self.spawn_children_pair()\n        # forward\n        children = parent.children(recursive=True)\n        self.assertEqual(len(children), 2)\n        self.assertEqual(children[0], child)\n        self.assertEqual(children[1], grandchild)\n        # backward\n        parents = grandchild.parents()\n        self.assertEqual(parents[0], child)\n        self.assertEqual(parents[1], parent)\n\n    def test_suspend_resume(self):\n        p = self.spawn_psproc()\n        p.suspend()\n        for _ in range(100):\n            if p.status() == psutil.STATUS_STOPPED:\n                break\n            time.sleep(0.01)\n        p.resume()\n        self.assertNotEqual(p.status(), psutil.STATUS_STOPPED)\n\n    def test_invalid_pid(self):\n        self.assertRaises(TypeError, psutil.Process, \"1\")\n        self.assertRaises(ValueError, psutil.Process, -1)\n\n    def test_as_dict(self):\n        p = psutil.Process()\n        d = p.as_dict(attrs=['exe', 'name'])\n        self.assertEqual(sorted(d.keys()), ['exe', 'name'])\n\n        p = psutil.Process(min(psutil.pids()))\n        d = p.as_dict(attrs=['net_connections'], ad_value='foo')\n        if not isinstance(d['net_connections'], list):\n            self.assertEqual(d['net_connections'], 'foo')\n\n        # Test ad_value is set on AccessDenied.\n        with mock.patch(\n            'psutil.Process.nice', create=True, side_effect=psutil.AccessDenied\n        ):\n            self.assertEqual(\n                p.as_dict(attrs=[\"nice\"], ad_value=1), {\"nice\": 1}\n            )\n\n        # Test that NoSuchProcess bubbles up.\n        with mock.patch(\n            'psutil.Process.nice',\n            create=True,\n            side_effect=psutil.NoSuchProcess(p.pid, \"name\"),\n        ):\n            self.assertRaises(psutil.NoSuchProcess, p.as_dict, attrs=[\"nice\"])\n\n        # Test that ZombieProcess is swallowed.\n        with mock.patch(\n            'psutil.Process.nice',\n            create=True,\n            side_effect=psutil.ZombieProcess(p.pid, \"name\"),\n        ):\n            self.assertEqual(\n                p.as_dict(attrs=[\"nice\"], ad_value=\"foo\"), {\"nice\": \"foo\"}\n            )\n\n        # By default APIs raising NotImplementedError are\n        # supposed to be skipped.\n        with mock.patch(\n            'psutil.Process.nice', create=True, side_effect=NotImplementedError\n        ):\n            d = p.as_dict()\n            self.assertNotIn('nice', list(d.keys()))\n            # ...unless the user explicitly asked for some attr.\n            with self.assertRaises(NotImplementedError):\n                p.as_dict(attrs=[\"nice\"])\n\n        # errors\n        with self.assertRaises(TypeError):\n            p.as_dict('name')\n        with self.assertRaises(ValueError):\n            p.as_dict(['foo'])\n        with self.assertRaises(ValueError):\n            p.as_dict(['foo', 'bar'])\n\n    def test_oneshot(self):\n        p = psutil.Process()\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m:\n            with p.oneshot():\n                p.cpu_times()\n                p.cpu_times()\n            self.assertEqual(m.call_count, 1)\n\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m:\n            p.cpu_times()\n            p.cpu_times()\n        self.assertEqual(m.call_count, 2)\n\n    def test_oneshot_twice(self):\n        # Test the case where the ctx manager is __enter__ed twice.\n        # The second __enter__ is supposed to resut in a NOOP.\n        p = psutil.Process()\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m1:\n            with mock.patch(\"psutil._psplatform.Process.oneshot_enter\") as m2:\n                with p.oneshot():\n                    p.cpu_times()\n                    p.cpu_times()\n                    with p.oneshot():\n                        p.cpu_times()\n                        p.cpu_times()\n                self.assertEqual(m1.call_count, 1)\n                self.assertEqual(m2.call_count, 1)\n\n        with mock.patch(\"psutil._psplatform.Process.cpu_times\") as m:\n            p.cpu_times()\n            p.cpu_times()\n        self.assertEqual(m.call_count, 2)\n\n    def test_oneshot_cache(self):\n        # Make sure oneshot() cache is nonglobal. Instead it's\n        # supposed to be bound to the Process instance, see:\n        # https://github.com/giampaolo/psutil/issues/1373\n        p1, p2 = self.spawn_children_pair()\n        p1_ppid = p1.ppid()\n        p2_ppid = p2.ppid()\n        self.assertNotEqual(p1_ppid, p2_ppid)\n        with p1.oneshot():\n            self.assertEqual(p1.ppid(), p1_ppid)\n            self.assertEqual(p2.ppid(), p2_ppid)\n        with p2.oneshot():\n            self.assertEqual(p1.ppid(), p1_ppid)\n            self.assertEqual(p2.ppid(), p2_ppid)\n\n    def test_halfway_terminated_process(self):\n        # Test that NoSuchProcess exception gets raised in case the\n        # process dies after we create the Process object.\n        # Example:\n        # >>> proc = Process(1234)\n        # >>> time.sleep(2)  # time-consuming task, process dies in meantime\n        # >>> proc.name()\n        # Refers to Issue #15\n        def assert_raises_nsp(fun, fun_name):\n            try:\n                ret = fun()\n            except psutil.ZombieProcess:  # differentiate from NSP\n                raise\n            except psutil.NoSuchProcess:\n                pass\n            except psutil.AccessDenied:\n                if OPENBSD and fun_name in ('threads', 'num_threads'):\n                    return\n                raise\n            else:\n                # NtQuerySystemInformation succeeds even if process is gone.\n                if WINDOWS and fun_name in ('exe', 'name'):\n                    return\n                raise self.fail(\n                    \"%r didn't raise NSP and returned %r instead\" % (fun, ret)\n                )\n\n        p = self.spawn_psproc()\n        p.terminate()\n        p.wait()\n        if WINDOWS:  # XXX\n            call_until(psutil.pids, \"%s not in ret\" % p.pid)\n        self.assertProcessGone(p)\n\n        ns = process_namespace(p)\n        for fun, name in ns.iter(ns.all):\n            assert_raises_nsp(fun, name)\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_zombie_process(self):\n        _parent, zombie = self.spawn_zombie()\n        self.assertProcessZombie(zombie)\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_zombie_process_is_running_w_exc(self):\n        # Emulate a case where internally is_running() raises\n        # ZombieProcess.\n        p = psutil.Process()\n        with mock.patch(\n            \"psutil.Process\", side_effect=psutil.ZombieProcess(0)\n        ) as m:\n            assert p.is_running()\n            assert m.called\n\n    @unittest.skipIf(not POSIX, 'POSIX only')\n    def test_zombie_process_status_w_exc(self):\n        # Emulate a case where internally status() raises\n        # ZombieProcess.\n        p = psutil.Process()\n        with mock.patch(\n            \"psutil._psplatform.Process.status\",\n            side_effect=psutil.ZombieProcess(0),\n        ) as m:\n            self.assertEqual(p.status(), psutil.STATUS_ZOMBIE)\n            assert m.called\n\n    def test_reused_pid(self):\n        # Emulate a case where PID has been reused by another process.\n        if PY3:\n            from io import StringIO\n        else:\n            from StringIO import StringIO\n\n        subp = self.spawn_testproc()\n        p = psutil.Process(subp.pid)\n        p._ident = (p.pid, p.create_time() + 100)\n\n        list(psutil.process_iter())\n        self.assertIn(p.pid, psutil._pmap)\n        assert not p.is_running()\n\n        # make sure is_running() removed PID from process_iter()\n        # internal cache\n        with redirect_stderr(StringIO()) as f:\n            list(psutil.process_iter())\n        self.assertIn(\n            \"refreshing Process instance for reused PID %s\" % p.pid,\n            f.getvalue(),\n        )\n        self.assertNotIn(p.pid, psutil._pmap)\n\n        assert p != psutil.Process(subp.pid)\n        msg = \"process no longer exists and its PID has been reused\"\n        ns = process_namespace(p)\n        for fun, name in ns.iter(ns.setters + ns.killers, clear_cache=False):\n            with self.subTest(name=name):\n                self.assertRaisesRegex(psutil.NoSuchProcess, msg, fun)\n\n        self.assertIn(\"terminated + PID reused\", str(p))\n        self.assertIn(\"terminated + PID reused\", repr(p))\n\n        self.assertRaisesRegex(psutil.NoSuchProcess, msg, p.ppid)\n        self.assertRaisesRegex(psutil.NoSuchProcess, msg, p.parent)\n        self.assertRaisesRegex(psutil.NoSuchProcess, msg, p.parents)\n        self.assertRaisesRegex(psutil.NoSuchProcess, msg, p.children)\n\n    def test_pid_0(self):\n        # Process(0) is supposed to work on all platforms except Linux\n        if 0 not in psutil.pids():\n            self.assertRaises(psutil.NoSuchProcess, psutil.Process, 0)\n            # These 2 are a contradiction, but \"ps\" says PID 1's parent\n            # is PID 0.\n            assert not psutil.pid_exists(0)\n            self.assertEqual(psutil.Process(1).ppid(), 0)\n            return\n\n        p = psutil.Process(0)\n        exc = psutil.AccessDenied if WINDOWS else ValueError\n        self.assertRaises(exc, p.wait)\n        self.assertRaises(exc, p.terminate)\n        self.assertRaises(exc, p.suspend)\n        self.assertRaises(exc, p.resume)\n        self.assertRaises(exc, p.kill)\n        self.assertRaises(exc, p.send_signal, signal.SIGTERM)\n\n        # test all methods\n        ns = process_namespace(p)\n        for fun, name in ns.iter(ns.getters + ns.setters):\n            try:\n                ret = fun()\n            except psutil.AccessDenied:\n                pass\n            else:\n                if name in (\"uids\", \"gids\"):\n                    self.assertEqual(ret.real, 0)\n                elif name == \"username\":\n                    user = 'NT AUTHORITY\\\\SYSTEM' if WINDOWS else 'root'\n                    self.assertEqual(p.username(), user)\n                elif name == \"name\":\n                    assert name, name\n\n        if not OPENBSD:\n            self.assertIn(0, psutil.pids())\n            assert psutil.pid_exists(0)\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    def test_environ(self):\n        def clean_dict(d):\n            # Most of these are problematic on Travis.\n            d.pop(\"PLAT\", None)\n            d.pop(\"HOME\", None)\n            if MACOS:\n                d.pop(\"__CF_USER_TEXT_ENCODING\", None)\n                d.pop(\"VERSIONER_PYTHON_PREFER_32_BIT\", None)\n                d.pop(\"VERSIONER_PYTHON_VERSION\", None)\n            return dict([\n                (\n                    k.replace(\"\\r\", \"\").replace(\"\\n\", \"\"),\n                    v.replace(\"\\r\", \"\").replace(\"\\n\", \"\"),\n                )\n                for k, v in d.items()\n            ])\n\n        self.maxDiff = None\n        p = psutil.Process()\n        d1 = clean_dict(p.environ())\n        d2 = clean_dict(os.environ.copy())\n        if not OSX and GITHUB_ACTIONS:\n            self.assertEqual(d1, d2)\n\n    @unittest.skipIf(not HAS_ENVIRON, \"not supported\")\n    @unittest.skipIf(not POSIX, \"POSIX only\")\n    @unittest.skipIf(\n        MACOS_11PLUS,\n        \"macOS 11+ can't get another process environment, issue #2084\",\n    )\n    @unittest.skipIf(NETBSD, \"sometimes fails on `assert is_running()`\")\n    def test_weird_environ(self):\n        # environment variables can contain values without an equals sign\n        code = textwrap.dedent(\"\"\"\n            #include <unistd.h>\n            #include <fcntl.h>\n\n            char * const argv[] = {\"cat\", 0};\n            char * const envp[] = {\"A=1\", \"X\", \"C=3\", 0};\n\n            int main(void) {\n                // Close stderr on exec so parent can wait for the\n                // execve to finish.\n                if (fcntl(2, F_SETFD, FD_CLOEXEC) != 0)\n                    return 0;\n                return execve(\"/bin/cat\", argv, envp);\n            }\n            \"\"\")\n        cexe = create_c_exe(self.get_testfn(), c_code=code)\n        sproc = self.spawn_testproc(\n            [cexe], stdin=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        p = psutil.Process(sproc.pid)\n        wait_for_pid(p.pid)\n        assert p.is_running()\n        # Wait for process to exec or exit.\n        self.assertEqual(sproc.stderr.read(), b\"\")\n        if MACOS and CI_TESTING:\n            try:\n                env = p.environ()\n            except psutil.AccessDenied:\n                # XXX: fails sometimes with:\n                # PermissionError from 'sysctl(KERN_PROCARGS2) -> EIO'\n                return\n        else:\n            env = p.environ()\n        self.assertEqual(env, {\"A\": \"1\", \"C\": \"3\"})\n        sproc.communicate()\n        self.assertEqual(sproc.returncode, 0)\n\n\n# ===================================================================\n# --- Limited user tests\n# ===================================================================\n\n\nif POSIX and os.getuid() == 0:\n\n    class LimitedUserTestCase(TestProcess):\n        \"\"\"Repeat the previous tests by using a limited user.\n        Executed only on UNIX and only if the user who run the test script\n        is root.\n        \"\"\"\n\n        # the uid/gid the test suite runs under\n        if hasattr(os, 'getuid'):\n            PROCESS_UID = os.getuid()\n            PROCESS_GID = os.getgid()\n\n        def __init__(self, *args, **kwargs):\n            super().__init__(*args, **kwargs)\n            # re-define all existent test methods in order to\n            # ignore AccessDenied exceptions\n            for attr in [x for x in dir(self) if x.startswith('test')]:\n                meth = getattr(self, attr)\n\n                def test_(self):\n                    try:\n                        meth()  # noqa\n                    except psutil.AccessDenied:\n                        pass\n\n                setattr(self, attr, types.MethodType(test_, self))\n\n        def setUp(self):\n            super().setUp()\n            os.setegid(1000)\n            os.seteuid(1000)\n\n        def tearDown(self):\n            os.setegid(self.PROCESS_UID)\n            os.seteuid(self.PROCESS_GID)\n            super().tearDown()\n\n        def test_nice(self):\n            try:\n                psutil.Process().nice(-1)\n            except psutil.AccessDenied:\n                pass\n            else:\n                raise self.fail(\"exception not raised\")\n\n        @unittest.skipIf(1, \"causes problem as root\")\n        def test_zombie_process(self):\n            pass\n\n\n# ===================================================================\n# --- psutil.Popen tests\n# ===================================================================\n\n\nclass TestPopen(PsutilTestCase):\n    \"\"\"Tests for psutil.Popen class.\"\"\"\n\n    @classmethod\n    def tearDownClass(cls):\n        reap_children()\n\n    def test_misc(self):\n        # XXX this test causes a ResourceWarning on Python 3 because\n        # psutil.__subproc instance doesn't get properly freed.\n        # Not sure what to do though.\n        cmd = [\n            PYTHON_EXE,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)];\",\n        ]\n        with psutil.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            env=PYTHON_EXE_ENV,\n        ) as proc:\n            proc.name()\n            proc.cpu_times()\n            proc.stdin  # noqa\n            self.assertTrue(dir(proc))\n            self.assertRaises(AttributeError, getattr, proc, 'foo')\n            proc.terminate()\n        if POSIX:\n            self.assertEqual(proc.wait(5), -signal.SIGTERM)\n        else:\n            self.assertEqual(proc.wait(5), signal.SIGTERM)\n\n    def test_ctx_manager(self):\n        with psutil.Popen(\n            [PYTHON_EXE, \"-V\"],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            stdin=subprocess.PIPE,\n            env=PYTHON_EXE_ENV,\n        ) as proc:\n            proc.communicate()\n        assert proc.stdout.closed\n        assert proc.stderr.closed\n        assert proc.stdin.closed\n        self.assertEqual(proc.returncode, 0)\n\n    def test_kill_terminate(self):\n        # subprocess.Popen()'s terminate(), kill() and send_signal() do\n        # not raise exception after the process is gone. psutil.Popen\n        # diverges from that.\n        cmd = [\n            PYTHON_EXE,\n            \"-c\",\n            \"import time; [time.sleep(0.1) for x in range(100)];\",\n        ]\n        with psutil.Popen(\n            cmd,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n            env=PYTHON_EXE_ENV,\n        ) as proc:\n            proc.terminate()\n            proc.wait()\n            self.assertRaises(psutil.NoSuchProcess, proc.terminate)\n            self.assertRaises(psutil.NoSuchProcess, proc.kill)\n            self.assertRaises(\n                psutil.NoSuchProcess, proc.send_signal, signal.SIGTERM\n            )\n            if WINDOWS:\n                self.assertRaises(\n                    psutil.NoSuchProcess, proc.send_signal, signal.CTRL_C_EVENT\n                )\n                self.assertRaises(\n                    psutil.NoSuchProcess,\n                    proc.send_signal,\n                    signal.CTRL_BREAK_EVENT,\n                )\n\n\nif __name__ == '__main__':\n    from psutil.tests.runner import run_from_name\n\n    run_from_name(__file__)\n", ".github/workflows/issues.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Bot triggered by Github Actions every time a new issue, PR or comment\nis created. Assign labels, provide replies, closes issues, etc. depending\non the situation.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport functools\nimport json\nimport os\nimport re\nfrom pprint import pprint as pp\n\nfrom github import Github\n\n\nROOT_DIR = os.path.realpath(\n    os.path.join(os.path.dirname(__file__), '..', '..')\n)\nSCRIPTS_DIR = os.path.join(ROOT_DIR, 'scripts')\n\n\n# --- constants\n\n# fmt: off\nLABELS_MAP = {\n    # platforms\n    \"linux\": [\n        \"linux\", \"ubuntu\", \"redhat\", \"mint\", \"centos\", \"red hat\", \"archlinux\",\n        \"debian\", \"alpine\", \"gentoo\", \"fedora\", \"slackware\", \"suse\", \"RHEL\",\n        \"opensuse\", \"manylinux\", \"apt \", \"apt-\", \"rpm\", \"yum\", \"kali\",\n        \"/sys/class\", \"/proc/net\", \"/proc/disk\", \"/proc/smaps\",\n        \"/proc/vmstat\",\n    ],\n    \"windows\": [\n        \"windows\", \"win32\", \"WinError\", \"WindowsError\", \"win10\", \"win7\",\n        \"win \", \"mingw\", \"msys\", \"studio\", \"microsoft\", \"make.bat\",\n        \"CloseHandle\", \"GetLastError\", \"NtQuery\", \"DLL\", \"MSVC\", \"TCHAR\",\n        \"WCHAR\", \".bat\", \"OpenProcess\", \"TerminateProcess\", \"appveyor\",\n        \"windows error\", \"NtWow64\", \"NTSTATUS\", \"Visual Studio\",\n    ],\n    \"macos\": [\n        \"macos\", \"mac \", \"osx\", \"os x\", \"mojave\", \"sierra\", \"capitan\",\n        \"yosemite\", \"catalina\", \"mojave\", \"big sur\", \"xcode\", \"darwin\",\n        \"dylib\", \"m1\",\n    ],\n    \"aix\": [\"aix\"],\n    \"cygwin\": [\"cygwin\"],\n    \"freebsd\": [\"freebsd\"],\n    \"netbsd\": [\"netbsd\"],\n    \"openbsd\": [\"openbsd\"],\n    \"sunos\": [\"sunos\", \"solaris\"],\n    \"wsl\": [\"wsl\"],\n    \"unix\": [\n        \"psposix\", \"_psutil_posix\", \"waitpid\", \"statvfs\", \"/dev/tty\",\n        \"/dev/pts\", \"posix\",\n    ],\n    \"pypy\": [\"pypy\"],\n    # types\n    \"enhancement\": [\"enhancement\"],\n    \"memleak\": [\"memory leak\", \"leaks memory\", \"memleak\", \"mem leak\"],\n    \"api\": [\"idea\", \"proposal\", \"api\", \"feature\"],\n    \"performance\": [\"performance\", \"speedup\", \"speed up\", \"slow\", \"fast\"],\n    \"wheels\": [\"wheel\", \"wheels\"],\n    \"scripts\": [\n        \"example script\", \"examples script\", \"example dir\", \"scripts/\",\n    ],\n    # bug\n    \"bug\": [\n        \"fail\", \"can't execute\", \"can't install\", \"cannot execute\",\n        \"cannot install\", \"install error\", \"crash\", \"critical\",\n    ],\n    # doc\n    \"doc\": [\n        \"doc \", \"document \", \"documentation\", \"readthedocs\", \"pythonhosted\",\n        \"HISTORY\", \"README\", \"dev guide\", \"devguide\", \"sphinx\", \"docfix\",\n        \"index.rst\",\n    ],\n    # tests\n    \"tests\": [\n        \" test \", \"tests\", \"travis\", \"coverage\", \"cirrus\", \"appveyor\",\n        \"continuous integration\", \"unittest\", \"pytest\", \"unit test\",\n    ],\n    # critical errors\n    \"priority-high\": [\n        \"WinError\", \"WindowsError\", \"RuntimeError\", \"ZeroDivisionError\",\n        \"SystemError\", \"MemoryError\", \"core dumped\",\n        \"segfault\", \"segmentation fault\",\n    ],\n}\n\nOS_LABELS = [\n    \"linux\", \"windows\", \"macos\", \"freebsd\", \"openbsd\", \"netbsd\", \"openbsd\",\n    \"bsd\", \"sunos\", \"unix\", \"wsl\", \"aix\", \"cygwin\",\n]\n# fmt: on\n\nLABELS_MAP['scripts'].extend(\n    [x for x in os.listdir(SCRIPTS_DIR) if x.endswith('.py')]\n)\n\nILLOGICAL_PAIRS = [\n    ('bug', 'enhancement'),\n    ('doc', 'tests'),\n    ('scripts', 'doc'),\n    ('scripts', 'tests'),\n    ('bsd', 'freebsd'),\n    ('bsd', 'openbsd'),\n    ('bsd', 'netbsd'),\n]\n\n# --- replies\n\nREPLY_MISSING_PYTHON_HEADERS = \"\"\"\\\nIt looks like you're missing `Python.h` headers. This usually means you have \\\nto install them first, then retry psutil installation.\nPlease read \\\n[INSTALL](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst) \\\ninstructions for your platform. \\\nThis is an auto-generated response based on the text you submitted. \\\nIf this was a mistake or you think there's a bug with psutil installation \\\nprocess, please add a comment to reopen this issue.\n\"\"\"\n\n# REPLY_UPDATE_CHANGELOG = \"\"\"\\\n# \"\"\"\n\n\n# --- github API utils\n\n\ndef is_pr(issue):\n    return issue.pull_request is not None\n\n\ndef has_label(issue, label):\n    assigned = [x.name for x in issue.labels]\n    return label in assigned\n\n\ndef has_os_label(issue):\n    labels = set([x.name for x in issue.labels])\n    return any(x in labels for x in OS_LABELS)\n\n\ndef get_repo():\n    repo = os.environ['GITHUB_REPOSITORY']\n    token = os.environ['GITHUB_TOKEN']\n    return Github(token).get_repo(repo)\n\n\n# --- event utils\n\n\n@functools.lru_cache()\ndef _get_event_data():\n    ret = json.load(open(os.environ[\"GITHUB_EVENT_PATH\"]))\n    pp(ret)\n    return ret\n\n\ndef is_event_new_issue():\n    data = _get_event_data()\n    try:\n        return data['action'] == 'opened' and 'issue' in data\n    except KeyError:\n        return False\n\n\ndef is_event_new_pr():\n    data = _get_event_data()\n    try:\n        return data['action'] == 'opened' and 'pull_request' in data\n    except KeyError:\n        return False\n\n\ndef get_issue():\n    data = _get_event_data()\n    try:\n        num = data['issue']['number']\n    except KeyError:\n        num = data['pull_request']['number']\n    return get_repo().get_issue(number=num)\n\n\n# --- actions\n\n\ndef log(msg):\n    if '\\n' in msg or \"\\r\\n\" in msg:\n        print(\">>>\\n%s\\n<<<\" % msg, flush=True)\n    else:\n        print(\">>> %s <<<\" % msg, flush=True)\n\n\ndef add_label(issue, label):\n    def should_add(issue, label):\n        if has_label(issue, label):\n            log(\"already has label %r\" % (label))\n            return False\n\n        for left, right in ILLOGICAL_PAIRS:\n            if label == left and has_label(issue, right):\n                log(\"already has label\" % (label))\n                return False\n\n        return not has_label(issue, label)\n\n    if not should_add(issue, label):\n        log(\"should not add label %r\" % label)\n        return\n\n    log(\"add label %r\" % label)\n    issue.add_to_labels(label)\n\n\ndef _guess_labels_from_text(text):\n    assert isinstance(text, str), text\n    for label, keywords in LABELS_MAP.items():\n        for keyword in keywords:\n            if keyword.lower() in text.lower():\n                yield (label, keyword)\n\n\ndef add_labels_from_text(issue, text):\n    assert isinstance(text, str), text\n    for label, keyword in _guess_labels_from_text(text):\n        add_label(issue, label)\n\n\ndef add_labels_from_new_body(issue, text):\n    assert isinstance(text, str), text\n    log(\"start searching for template lines in new issue/PR body\")\n    # add os label\n    r = re.search(r\"\\* OS:.*?\\n\", text)\n    log(\"search for 'OS: ...' line\")\n    if r:\n        log(\"found\")\n        add_labels_from_text(issue, r.group(0))\n    else:\n        log(\"not found\")\n\n    # add bug/enhancement label\n    log(\"search for 'Bug fix: y/n' line\")\n    r = re.search(r\"\\* Bug fix:.*?\\n\", text)\n    if (\n        is_pr(issue)\n        and r is not None\n        and not has_label(issue, \"bug\")\n        and not has_label(issue, \"enhancement\")\n    ):\n        log(\"found\")\n        s = r.group(0).lower()\n        if 'yes' in s:\n            add_label(issue, 'bug')\n        else:\n            add_label(issue, 'enhancement')\n    else:\n        log(\"not found\")\n\n    # add type labels\n    log(\"search for 'Type: ...' line\")\n    r = re.search(r\"\\* Type:.*?\\n\", text)\n    if r:\n        log(\"found\")\n        s = r.group(0).lower()\n        if 'doc' in s:\n            add_label(issue, 'doc')\n        if 'performance' in s:\n            add_label(issue, 'performance')\n        if 'scripts' in s:\n            add_label(issue, 'scripts')\n        if 'tests' in s:\n            add_label(issue, 'tests')\n        if 'wheels' in s:\n            add_label(issue, 'wheels')\n        if 'new-api' in s:\n            add_label(issue, 'new-api')\n        if 'new-platform' in s:\n            add_label(issue, 'new-platform')\n    else:\n        log(\"not found\")\n\n\n# --- events\n\n\ndef on_new_issue(issue):\n    def has_text(text):\n        return text in issue.title.lower() or (\n            issue.body and text in issue.body.lower()\n        )\n\n    def body_mentions_python_h():\n        if not issue.body:\n            return False\n        body = issue.body.replace(' ', '')\n        return (\n            \"#include<Python.h>\\n^~~~\" in body\n            or \"#include<Python.h>\\r\\n^~~~\" in body\n        )\n\n    log(\"searching for missing Python.h\")\n    if (\n        has_text(\"missing python.h\")\n        or has_text(\"python.h: no such file or directory\")\n        or body_mentions_python_h()\n    ):\n        log(\"found mention of Python.h\")\n        issue.create_comment(REPLY_MISSING_PYTHON_HEADERS)\n        issue.edit(state='closed')\n        return\n\n\ndef on_new_pr(issue):\n    pass\n    # pr = get_repo().get_pull(issue.number)\n    # files = [x.filename for x in list(pr.get_files())]\n    # if \"HISTORY.rst\" not in files:\n    #     issue.create_comment(REPLY_UPDATE_CHANGELOG)\n\n\ndef main():\n    issue = get_issue()\n    stype = \"PR\" if is_pr(issue) else \"issue\"\n    log(\"running issue bot for %s %r\" % (stype, issue))\n\n    if is_event_new_issue():\n        log(\"created new issue %s\" % issue)\n        add_labels_from_text(issue, issue.title)\n        if issue.body:\n            add_labels_from_new_body(issue, issue.body)\n        on_new_issue(issue)\n    elif is_event_new_pr():\n        log(\"created new PR %s\" % issue)\n        add_labels_from_text(issue, issue.title)\n        if issue.body:\n            add_labels_from_new_body(issue, issue.body)\n        on_new_pr(issue)\n    else:\n        log(\"unhandled event\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/nettop.py": "#!/usr/bin/env python3\n#\n# $Id: iotop.py 1160 2011-10-14 18:50:36Z g.rodola@gmail.com $\n#\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Shows real-time network statistics.\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n$ python3 scripts/nettop.py\n-----------------------------------------------------------\ntotal bytes:           sent: 1.49 G       received: 4.82 G\ntotal packets:         sent: 7338724      received: 8082712\n\nwlan0                     TOTAL         PER-SEC\n-----------------------------------------------------------\nbytes-sent               1.29 G        0.00 B/s\nbytes-recv               3.48 G        0.00 B/s\npkts-sent               7221782               0\npkts-recv               6753724               0\n\neth1                      TOTAL         PER-SEC\n-----------------------------------------------------------\nbytes-sent             131.77 M        0.00 B/s\nbytes-recv               1.28 G        0.00 B/s\npkts-sent                     0               0\npkts-recv               1214470               0\n\"\"\"\n\nimport sys\nimport time\n\n\ntry:\n    import curses\nexcept ImportError:\n    sys.exit('platform not supported')\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nlineno = 0\nwin = curses.initscr()\n\n\ndef printl(line, highlight=False):\n    \"\"\"A thin wrapper around curses's addstr().\"\"\"\n    global lineno\n    try:\n        if highlight:\n            line += \" \" * (win.getmaxyx()[1] - len(line))\n            win.addstr(lineno, 0, line, curses.A_REVERSE)\n        else:\n            win.addstr(lineno, 0, line, 0)\n    except curses.error:\n        lineno = 0\n        win.refresh()\n        raise\n    else:\n        lineno += 1\n\n\ndef poll(interval):\n    \"\"\"Retrieve raw stats within an interval window.\"\"\"\n    tot_before = psutil.net_io_counters()\n    pnic_before = psutil.net_io_counters(pernic=True)\n    # sleep some time\n    time.sleep(interval)\n    tot_after = psutil.net_io_counters()\n    pnic_after = psutil.net_io_counters(pernic=True)\n    return (tot_before, tot_after, pnic_before, pnic_after)\n\n\ndef refresh_window(tot_before, tot_after, pnic_before, pnic_after):\n    \"\"\"Print stats on screen.\"\"\"\n    global lineno\n\n    # totals\n    printl(\n        \"total bytes:           sent: %-10s   received: %s\"\n        % (\n            bytes2human(tot_after.bytes_sent),\n            bytes2human(tot_after.bytes_recv),\n        )\n    )\n\n    # per-network interface details: let's sort network interfaces so\n    # that the ones which generated more traffic are shown first\n    printl(\"\")\n    nic_names = list(pnic_after.keys())\n    nic_names.sort(key=lambda x: sum(pnic_after[x]), reverse=True)\n    for name in nic_names:\n        stats_before = pnic_before[name]\n        stats_after = pnic_after[name]\n        templ = \"%-15s %15s %15s\"\n        # fmt: off\n        printl(templ % (name, \"TOTAL\", \"PER-SEC\"), highlight=True)\n        printl(templ % (\n            \"bytes-sent\",\n            bytes2human(stats_after.bytes_sent),\n            bytes2human(\n                stats_after.bytes_sent - stats_before.bytes_sent) + '/s',\n        ))\n        printl(templ % (\n            \"bytes-recv\",\n            bytes2human(stats_after.bytes_recv),\n            bytes2human(\n                stats_after.bytes_recv - stats_before.bytes_recv) + '/s',\n        ))\n        printl(templ % (\n            \"pkts-sent\",\n            stats_after.packets_sent,\n            stats_after.packets_sent - stats_before.packets_sent,\n        ))\n        printl(templ % (\n            \"pkts-recv\",\n            stats_after.packets_recv,\n            stats_after.packets_recv - stats_before.packets_recv,\n        ))\n        printl(\"\")\n        # fmt: on\n    win.refresh()\n    lineno = 0\n\n\ndef setup():\n    curses.start_color()\n    curses.use_default_colors()\n    for i in range(curses.COLORS):\n        curses.init_pair(i + 1, i, -1)\n    curses.endwin()\n    win.nodelay(1)\n\n\ndef tear_down():\n    win.keypad(0)\n    curses.nocbreak()\n    curses.echo()\n    curses.endwin()\n\n\ndef main():\n    setup()\n    try:\n        interval = 0\n        while True:\n            if win.getch() == ord('q'):\n                break\n            args = poll(interval)\n            refresh_window(*args)\n            interval = 0.5\n    except (KeyboardInterrupt, SystemExit):\n        pass\n    finally:\n        tear_down()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/pstree.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Similar to 'ps aux --forest' on Linux, prints the process list\nas a tree structure.\n\n$ python3 scripts/pstree.py\n0 ?\n|- 1 init\n| |- 289 cgmanager\n| |- 616 upstart-socket-bridge\n| |- 628 rpcbind\n| |- 892 upstart-file-bridge\n| |- 907 dbus-daemon\n| |- 978 avahi-daemon\n| | `_ 979 avahi-daemon\n| |- 987 NetworkManager\n| | |- 2242 dnsmasq\n| | `_ 10699 dhclient\n| |- 993 polkitd\n| |- 1061 getty\n| |- 1066 su\n| | `_ 1190 salt-minion...\n...\n\"\"\"\n\nfrom __future__ import print_function\n\nimport collections\nimport sys\n\nimport psutil\n\n\ndef print_tree(parent, tree, indent=''):\n    try:\n        name = psutil.Process(parent).name()\n    except psutil.Error:\n        name = \"?\"\n    print(parent, name)\n    if parent not in tree:\n        return\n    children = tree[parent][:-1]\n    for child in children:\n        sys.stdout.write(indent + \"|- \")\n        print_tree(child, tree, indent + \"| \")\n    child = tree[parent][-1]\n    sys.stdout.write(indent + \"`_ \")\n    print_tree(child, tree, indent + \"  \")\n\n\ndef main():\n    # construct a dict where 'values' are all the processes\n    # having 'key' as their parent\n    tree = collections.defaultdict(list)\n    for p in psutil.process_iter():\n        try:\n            tree[p.ppid()].append(p.pid)\n        except (psutil.NoSuchProcess, psutil.ZombieProcess):\n            pass\n    # on systems supporting PID 0, PID 0's parent is usually 0\n    if 0 in tree and 0 in tree[0]:\n        tree[0].remove(0)\n    print_tree(min(tree), tree)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/battery.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Show battery information.\n\n$ python3 scripts/battery.py\ncharge:     74%\nleft:       2:11:31\nstatus:     discharging\nplugged in: no\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef secs2hours(secs):\n    mm, ss = divmod(secs, 60)\n    hh, mm = divmod(mm, 60)\n    return \"%d:%02d:%02d\" % (hh, mm, ss)\n\n\ndef main():\n    if not hasattr(psutil, \"sensors_battery\"):\n        return sys.exit(\"platform not supported\")\n    batt = psutil.sensors_battery()\n    if batt is None:\n        return sys.exit(\"no battery is installed\")\n\n    print(\"charge:     %s%%\" % round(batt.percent, 2))\n    if batt.power_plugged:\n        print(\n            \"status:     %s\"\n            % (\"charging\" if batt.percent < 100 else \"fully charged\")\n        )\n        print(\"plugged in: yes\")\n    else:\n        print(\"left:       %s\" % secs2hours(batt.secsleft))\n        print(\"status:     %s\" % \"discharging\")\n        print(\"plugged in: no\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/free.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'free' cmdline utility.\n\n$ python3 scripts/free.py\n             total       used       free     shared    buffers      cache\nMem:      10125520    8625996    1499524          0     349500    3307836\nSwap:            0          0          0\n\"\"\"\n\nimport psutil\n\n\ndef main():\n    virt = psutil.virtual_memory()\n    swap = psutil.swap_memory()\n    templ = \"%-7s %10s %10s %10s %10s %10s %10s\"\n    print(templ % ('', 'total', 'used', 'free', 'shared', 'buffers', 'cache'))\n    sect = templ % (\n        'Mem:',\n        int(virt.total / 1024),\n        int(virt.used / 1024),\n        int(virt.free / 1024),\n        int(getattr(virt, 'shared', 0) / 1024),\n        int(getattr(virt, 'buffers', 0) / 1024),\n        int(getattr(virt, 'cached', 0) / 1024),\n    )\n    print(sect)\n    sect = templ % (\n        'Swap:',\n        int(swap.total / 1024),\n        int(swap.used / 1024),\n        int(swap.free / 1024),\n        '',\n        '',\n        '',\n    )\n    print(sect)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/winservices.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\nr\"\"\"List all Windows services installed.\n\n$ python3 scripts/winservices.py\nAeLookupSvc (Application Experience)\nstatus: stopped, start: manual, username: localSystem, pid: None\nbinpath: C:\\Windows\\system32\\svchost.exe -k netsvcs\n\nALG (Application Layer Gateway Service)\nstatus: stopped, start: manual, username: NT AUTHORITY\\LocalService, pid: None\nbinpath: C:\\Windows\\System32\\alg.exe\n\nAPNMCP (Ask Update Service)\nstatus: running, start: automatic, username: LocalSystem, pid: 1108\nbinpath: \"C:\\Program Files (x86)\\AskPartnerNetwork\\Toolbar\\apnmcp.exe\"\n\nAppIDSvc (Application Identity)\nstatus: stopped, start: manual, username: NT Authority\\LocalService, pid: None\nbinpath: C:\\Windows\\system32\\svchost.exe -k LocalServiceAndNoImpersonation\n\nAppinfo (Application Information)\nstatus: stopped, start: manual, username: LocalSystem, pid: None\nbinpath: C:\\Windows\\system32\\svchost.exe -k netsvcs\n...\n\"\"\"\n\n\nimport os\nimport sys\n\nimport psutil\n\n\nif os.name != 'nt':\n    sys.exit(\"platform not supported (Windows only)\")\n\n\ndef main():\n    for service in psutil.win_service_iter():\n        info = service.as_dict()\n        print(\"%r (%r)\" % (info['name'], info['display_name']))\n        s = \"status: %s, start: %s, username: %s, pid: %s\" % (\n            info['status'],\n            info['start_type'],\n            info['username'],\n            info['pid'],\n        )\n        print(s)\n        print(\"binpath: %s\" % info['binpath'])\n        print()\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/cpu_distribution.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Shows CPU workload split across different CPUs.\n\n$ python3 scripts/cpu_workload.py\nCPU 0     CPU 1     CPU 2     CPU 3     CPU 4     CPU 5     CPU 6     CPU 7\n19.8      20.6      18.2      15.8      6.9       17.3      5.0       20.4\ngvfsd     pytho     kwork     chrom     unity     kwork     kwork     kwork\nchrom     chrom     indic     ibus-     whoop     nfsd      (sd-p     gvfsd\nibus-     cat       at-sp     chrom     Modem     nfsd4     light     upsta\nibus-     iprt-     ibus-     nacl_     cfg80     kwork     nfsd      bluet\nchrom     irqba     gpg-a     chrom     ext4-     biose     nfsd      dio/n\nchrom     acpid     bamfd     nvidi     kwork     scsi_     sshd      rpc.m\nupsta     rsysl     dbus-     nfsd      biose     scsi_     ext4-     polki\nrtkit     avahi     upowe     Netwo     scsi_     biose     UVM T     irq/9\nlight     rpcbi     snapd     cron      ipv6_     biose     kwork     dbus-\nagett     kvm-i     avahi     kwork     biose     biose     scsi_     syste\nnfsd      syste     rpc.i     biose     biose     kbloc     kthro     UVM g\nnfsd      kwork     kwork     biose     vmsta     kwork     crypt     kaudi\nnfsd      scsi_     charg     biose     md        ksoft     kwork     kwork\nmemca     biose     ksmd      ecryp     ksoft     watch     migra     nvme\ntherm     biose     kcomp     kswap     migra     cpuhp     watch     biose\nsyste     biose     kdevt     khuge     watch               cpuhp     biose\nled_w     devfr     kwork     write     cpuhp                         biose\nrpcio     oom_r     ksoft     kwork     syste                         biose\nkwork     kwork     watch     migra                                   acpi_\nbiose     ksoft     cpuhp     watch                                   watch\nbiose     migra               cpuhp                                   kinte\nbiose     watch               rcu_s                                   netns\nbiose     cpuhp               kthre                                   kwork\ncpuhp                                                                 ksoft\nwatch                                                                 migra\nrcu_b                                                                 cpuhp\nkwork\n\"\"\"\n\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport sys\nimport time\n\nimport psutil\nfrom psutil._compat import get_terminal_size\n\n\nif not hasattr(psutil.Process, \"cpu_num\"):\n    sys.exit(\"platform not supported\")\n\n\ndef clean_screen():\n    if psutil.POSIX:\n        os.system('clear')\n    else:\n        os.system('cls')\n\n\ndef main():\n    num_cpus = psutil.cpu_count()\n    if num_cpus > 8:\n        num_cpus = 8  # try to fit into screen\n        cpus_hidden = True\n    else:\n        cpus_hidden = False\n\n    while True:\n        # header\n        clean_screen()\n        cpus_percent = psutil.cpu_percent(percpu=True)\n        for i in range(num_cpus):\n            print(\"CPU %-6i\" % i, end=\"\")\n        if cpus_hidden:\n            print(\" (+ hidden)\", end=\"\")\n\n        print()\n        for _ in range(num_cpus):\n            print(\"%-10s\" % cpus_percent.pop(0), end=\"\")\n        print()\n\n        # processes\n        procs = collections.defaultdict(list)\n        for p in psutil.process_iter(['name', 'cpu_num']):\n            procs[p.info['cpu_num']].append(p.info['name'][:5])\n\n        curr_line = 3\n        while True:\n            for num in range(num_cpus):\n                try:\n                    pname = procs[num].pop()\n                except IndexError:\n                    pname = \"\"\n                print(\"%-10s\" % pname[:10], end=\"\")\n            print()\n            curr_line += 1\n            if curr_line >= get_terminal_size()[1]:\n                break\n\n        time.sleep(1)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/pmap.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'pmap' utility on Linux, 'vmmap' on macOS and 'procstat\n-v' on BSD. Report memory map of a process.\n\n$ python3 scripts/pmap.py 32402\nAddress                 RSS  Mode    Mapping\n0000000000400000      1200K  r-xp    /usr/bin/python2.7\n0000000000838000         4K  r--p    /usr/bin/python2.7\n0000000000839000       304K  rw-p    /usr/bin/python2.7\n00000000008ae000        68K  rw-p    [anon]\n000000000275e000      5396K  rw-p    [heap]\n00002b29bb1e0000       124K  r-xp    /lib/x86_64-linux-gnu/ld-2.17.so\n00002b29bb203000         8K  rw-p    [anon]\n00002b29bb220000       528K  rw-p    [anon]\n00002b29bb2d8000       768K  rw-p    [anon]\n00002b29bb402000         4K  r--p    /lib/x86_64-linux-gnu/ld-2.17.so\n00002b29bb403000         8K  rw-p    /lib/x86_64-linux-gnu/ld-2.17.so\n00002b29bb405000        60K  r-xp    /lib/x86_64-linux-gnu/libpthread-2.17.so\n00002b29bb41d000         0K  ---p    /lib/x86_64-linux-gnu/libpthread-2.17.so\n00007fff94be6000        48K  rw-p    [stack]\n00007fff94dd1000         4K  r-xp    [vdso]\nffffffffff600000         0K  r-xp    [vsyscall]\n...\n\"\"\"\n\nimport sys\n\nimport psutil\nfrom psutil._common import bytes2human\nfrom psutil._compat import get_terminal_size\n\n\ndef safe_print(s):\n    s = s[: get_terminal_size()[0]]\n    try:\n        print(s)\n    except UnicodeEncodeError:\n        print(s.encode('ascii', 'ignore').decode())\n\n\ndef main():\n    if len(sys.argv) != 2:\n        sys.exit('usage: pmap <pid>')\n    p = psutil.Process(int(sys.argv[1]))\n    templ = \"%-20s %10s  %-7s %s\"\n    print(templ % (\"Address\", \"RSS\", \"Mode\", \"Mapping\"))\n    total_rss = 0\n    for m in p.memory_maps(grouped=False):\n        total_rss += m.rss\n        line = templ % (\n            m.addr.split('-')[0].zfill(16),\n            bytes2human(m.rss),\n            m.perms,\n            m.path,\n        )\n        safe_print(line)\n    print(\"-\" * 31)\n    print(templ % (\"Total\", bytes2human(total_rss), '', ''))\n    safe_print(\"PID = %s, name = %s\" % (p.pid, p.name()))\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/iotop.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of iotop (http://guichaz.free.fr/iotop/) showing real time\ndisk I/O statistics.\n\nIt works on Linux only (FreeBSD and macOS are missing support for IO\ncounters).\nIt doesn't work on Windows as curses module is required.\n\nExample output:\n\n$ python3 scripts/iotop.py\nTotal DISK READ: 0.00 B/s | Total DISK WRITE: 472.00 K/s\nPID   USER      DISK READ  DISK WRITE  COMMAND\n13155 giampao    0.00 B/s  428.00 K/s  /usr/bin/google-chrome-beta\n3260  giampao    0.00 B/s    0.00 B/s  bash\n3779  giampao    0.00 B/s    0.00 B/s  gnome-session --session=ubuntu\n3830  giampao    0.00 B/s    0.00 B/s  /usr/bin/dbus-launch\n3831  giampao    0.00 B/s    0.00 B/s  //bin/dbus-daemon --fork --print-pid 5\n3841  giampao    0.00 B/s    0.00 B/s  /usr/lib/at-spi-bus-launcher\n3845  giampao    0.00 B/s    0.00 B/s  /bin/dbus-daemon\n3848  giampao    0.00 B/s    0.00 B/s  /usr/lib/at-spi2-core/at-spi2-registryd\n3862  giampao    0.00 B/s    0.00 B/s  /usr/lib/gnome-settings-daemon\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\"\"\"\n\nimport sys\nimport time\n\n\ntry:\n    import curses\nexcept ImportError:\n    sys.exit('platform not supported')\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nwin = curses.initscr()\nlineno = 0\n\n\ndef printl(line, highlight=False):\n    \"\"\"A thin wrapper around curses's addstr().\"\"\"\n    global lineno\n    try:\n        if highlight:\n            line += \" \" * (win.getmaxyx()[1] - len(line))\n            win.addstr(lineno, 0, line, curses.A_REVERSE)\n        else:\n            win.addstr(lineno, 0, line, 0)\n    except curses.error:\n        lineno = 0\n        win.refresh()\n        raise\n    else:\n        lineno += 1\n\n\ndef poll(interval):\n    \"\"\"Calculate IO usage by comparing IO statistics before and\n    after the interval.\n    Return a tuple including all currently running processes\n    sorted by IO activity and total disks I/O activity.\n    \"\"\"\n    # first get a list of all processes and disk io counters\n    procs = list(psutil.process_iter())\n    for p in procs[:]:\n        try:\n            p._before = p.io_counters()\n        except psutil.Error:\n            procs.remove(p)\n            continue\n    disks_before = psutil.disk_io_counters()\n\n    # sleep some time\n    time.sleep(interval)\n\n    # then retrieve the same info again\n    for p in procs[:]:\n        with p.oneshot():\n            try:\n                p._after = p.io_counters()\n                p._cmdline = ' '.join(p.cmdline())\n                if not p._cmdline:\n                    p._cmdline = p.name()\n                p._username = p.username()\n            except (psutil.NoSuchProcess, psutil.ZombieProcess):\n                procs.remove(p)\n    disks_after = psutil.disk_io_counters()\n\n    # finally calculate results by comparing data before and\n    # after the interval\n    for p in procs:\n        p._read_per_sec = p._after.read_bytes - p._before.read_bytes\n        p._write_per_sec = p._after.write_bytes - p._before.write_bytes\n        p._total = p._read_per_sec + p._write_per_sec\n\n    disks_read_per_sec = disks_after.read_bytes - disks_before.read_bytes\n    disks_write_per_sec = disks_after.write_bytes - disks_before.write_bytes\n\n    # sort processes by total disk IO so that the more intensive\n    # ones get listed first\n    processes = sorted(procs, key=lambda p: p._total, reverse=True)\n\n    return (processes, disks_read_per_sec, disks_write_per_sec)\n\n\ndef refresh_window(procs, disks_read, disks_write):\n    \"\"\"Print results on screen by using curses.\"\"\"\n    curses.endwin()\n    templ = \"%-5s %-7s %11s %11s  %s\"\n    win.erase()\n\n    disks_tot = \"Total DISK READ: %s | Total DISK WRITE: %s\" % (\n        bytes2human(disks_read),\n        bytes2human(disks_write),\n    )\n    printl(disks_tot)\n\n    header = templ % (\"PID\", \"USER\", \"DISK READ\", \"DISK WRITE\", \"COMMAND\")\n    printl(header, highlight=True)\n\n    for p in procs:\n        line = templ % (\n            p.pid,\n            p._username[:7],\n            bytes2human(p._read_per_sec),\n            bytes2human(p._write_per_sec),\n            p._cmdline,\n        )\n        try:\n            printl(line)\n        except curses.error:\n            break\n    win.refresh()\n\n\ndef setup():\n    curses.start_color()\n    curses.use_default_colors()\n    for i in range(curses.COLORS):\n        curses.init_pair(i + 1, i, -1)\n    curses.endwin()\n    win.nodelay(1)\n\n\ndef tear_down():\n    win.keypad(0)\n    curses.nocbreak()\n    curses.echo()\n    curses.endwin()\n\n\ndef main():\n    global lineno\n    setup()\n    try:\n        interval = 0\n        while True:\n            if win.getch() == ord('q'):\n                break\n            args = poll(interval)\n            refresh_window(*args)\n            lineno = 0\n            interval = 0.5\n            time.sleep(interval)\n    except (KeyboardInterrupt, SystemExit):\n        pass\n    finally:\n        tear_down()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/who.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'who' command; print information about users who are\ncurrently logged in.\n\n$ python3 scripts/who.py\ngiampaolo    console    2017-03-25 22:24                loginwindow\ngiampaolo    ttys000    2017-03-25 23:28 (10.0.2.2)     sshd\n\"\"\"\n\nfrom datetime import datetime\n\nimport psutil\n\n\ndef main():\n    users = psutil.users()\n    for user in users:\n        proc_name = psutil.Process(user.pid).name() if user.pid else \"\"\n        line = \"%-12s %-10s %-10s %-14s %s\" % (\n            user.name,\n            user.terminal or '-',\n            datetime.fromtimestamp(user.started).strftime(\"%Y-%m-%d %H:%M\"),\n            \"(%s)\" % user.host if user.host else \"\",\n            proc_name,\n        )\n        print(line)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/top.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of top / htop.\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n$ python3 scripts/top.py\n CPU0  [||||                                    ]  10.9%\n CPU1  [|||||                                   ]  13.1%\n CPU2  [|||||                                   ]  12.8%\n CPU3  [||||                                    ]  11.5%\n Mem   [|||||||||||||||||||||||||||||           ]  73.0% 11017M / 15936M\n Swap  [                                        ]   1.3%   276M / 20467M\n Processes: 347 (sleeping=273, running=1, idle=73)\n Load average: 1.10 1.28 1.34  Uptime: 8 days, 21:15:40\n\nPID    USER       NI   VIRT    RES  CPU%  MEM%     TIME+  NAME\n5368   giampaol    0   7.2G   4.3G  41.8  27.7  56:34.18  VirtualBox\n24976  giampaol    0   2.1G 487.2M  18.7   3.1  22:05.16  Web Content\n22731  giampaol    0   3.2G 596.2M  11.6   3.7  35:04.90  firefox\n1202   root        0 807.4M 288.5M  10.6   1.8  12:22.12  Xorg\n22811  giampaol    0   2.8G 741.8M   9.0   4.7   2:26.61  Web Content\n2590   giampaol    0   2.3G 579.4M   5.5   3.6  28:02.70  compiz\n22990  giampaol    0   3.0G   1.2G   4.2   7.6   4:30.32  Web Content\n18412  giampaol    0  90.1M  14.5M   3.5   0.1   0:00.26  python3\n26971  netdata     0  20.8M   3.9M   2.9   0.0   3:17.14  apps.plugin\n2421   giampaol    0   3.3G  36.9M   2.3   0.2  57:14.21  pulseaudio\n...\n\"\"\"\n\nimport datetime\nimport sys\nimport time\n\n\ntry:\n    import curses\nexcept ImportError:\n    sys.exit('platform not supported')\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nwin = curses.initscr()\nlineno = 0\ncolors_map = dict(green=3, red=10, yellow=4)\n\n\ndef printl(line, color=None, bold=False, highlight=False):\n    \"\"\"A thin wrapper around curses's addstr().\"\"\"\n    global lineno\n    try:\n        flags = 0\n        if color:\n            flags |= curses.color_pair(colors_map[color])\n        if bold:\n            flags |= curses.A_BOLD\n        if highlight:\n            line += \" \" * (win.getmaxyx()[1] - len(line))\n            flags |= curses.A_STANDOUT\n        win.addstr(lineno, 0, line, flags)\n    except curses.error:\n        lineno = 0\n        win.refresh()\n        raise\n    else:\n        lineno += 1\n\n\n# --- /curses stuff\n\n\ndef poll(interval):\n    # sleep some time\n    time.sleep(interval)\n    procs = []\n    procs_status = {}\n    for p in psutil.process_iter():\n        try:\n            p.dict = p.as_dict([\n                'username',\n                'nice',\n                'memory_info',\n                'memory_percent',\n                'cpu_percent',\n                'cpu_times',\n                'name',\n                'status',\n            ])\n            try:\n                procs_status[p.dict['status']] += 1\n            except KeyError:\n                procs_status[p.dict['status']] = 1\n        except psutil.NoSuchProcess:\n            pass\n        else:\n            procs.append(p)\n\n    # return processes sorted by CPU percent usage\n    processes = sorted(\n        procs, key=lambda p: p.dict['cpu_percent'], reverse=True\n    )\n    return (processes, procs_status)\n\n\ndef get_color(perc):\n    if perc <= 30:\n        return \"green\"\n    elif perc <= 80:\n        return \"yellow\"\n    else:\n        return \"red\"\n\n\ndef print_header(procs_status, num_procs):\n    \"\"\"Print system-related info, above the process list.\"\"\"\n\n    def get_dashes(perc):\n        dashes = \"|\" * int(float(perc) / 10 * 4)\n        empty_dashes = \" \" * (40 - len(dashes))\n        return dashes, empty_dashes\n\n    # cpu usage\n    percs = psutil.cpu_percent(interval=0, percpu=True)\n    for cpu_num, perc in enumerate(percs):\n        dashes, empty_dashes = get_dashes(perc)\n        line = \" CPU%-2s [%s%s] %5s%%\" % (cpu_num, dashes, empty_dashes, perc)\n        printl(line, color=get_color(perc))\n\n    # memory usage\n    mem = psutil.virtual_memory()\n    dashes, empty_dashes = get_dashes(mem.percent)\n    line = \" Mem   [%s%s] %5s%% %6s / %s\" % (\n        dashes,\n        empty_dashes,\n        mem.percent,\n        bytes2human(mem.used),\n        bytes2human(mem.total),\n    )\n    printl(line, color=get_color(mem.percent))\n\n    # swap usage\n    swap = psutil.swap_memory()\n    dashes, empty_dashes = get_dashes(swap.percent)\n    line = \" Swap  [%s%s] %5s%% %6s / %s\" % (\n        dashes,\n        empty_dashes,\n        swap.percent,\n        bytes2human(swap.used),\n        bytes2human(swap.total),\n    )\n    printl(line, color=get_color(swap.percent))\n\n    # processes number and status\n    st = []\n    for x, y in procs_status.items():\n        if y:\n            st.append(\"%s=%s\" % (x, y))\n    st.sort(key=lambda x: x[:3] in ('run', 'sle'), reverse=1)\n    printl(\" Processes: %s (%s)\" % (num_procs, ', '.join(st)))\n    # load average, uptime\n    uptime = datetime.datetime.now() - datetime.datetime.fromtimestamp(\n        psutil.boot_time()\n    )\n    av1, av2, av3 = psutil.getloadavg()\n    line = \" Load average: %.2f %.2f %.2f  Uptime: %s\" % (\n        av1,\n        av2,\n        av3,\n        str(uptime).split('.')[0],\n    )\n    printl(line)\n\n\ndef refresh_window(procs, procs_status):\n    \"\"\"Print results on screen by using curses.\"\"\"\n    curses.endwin()\n    templ = \"%-6s %-8s %4s %6s %6s %5s %5s %9s  %2s\"\n    win.erase()\n    header = templ % (\n        \"PID\",\n        \"USER\",\n        \"NI\",\n        \"VIRT\",\n        \"RES\",\n        \"CPU%\",\n        \"MEM%\",\n        \"TIME+\",\n        \"NAME\",\n    )\n    print_header(procs_status, len(procs))\n    printl(\"\")\n    printl(header, bold=True, highlight=True)\n    for p in procs:\n        # TIME+ column shows process CPU cumulative time and it\n        # is expressed as: \"mm:ss.ms\"\n        if p.dict['cpu_times'] is not None:\n            ctime = datetime.timedelta(seconds=sum(p.dict['cpu_times']))\n            ctime = \"%s:%s.%s\" % (\n                ctime.seconds // 60 % 60,\n                str(ctime.seconds % 60).zfill(2),\n                str(ctime.microseconds)[:2],\n            )\n        else:\n            ctime = ''\n        if p.dict['memory_percent'] is not None:\n            p.dict['memory_percent'] = round(p.dict['memory_percent'], 1)\n        else:\n            p.dict['memory_percent'] = ''\n        if p.dict['cpu_percent'] is None:\n            p.dict['cpu_percent'] = ''\n        username = p.dict['username'][:8] if p.dict['username'] else ''\n        line = templ % (\n            p.pid,\n            username,\n            p.dict['nice'],\n            bytes2human(getattr(p.dict['memory_info'], 'vms', 0)),\n            bytes2human(getattr(p.dict['memory_info'], 'rss', 0)),\n            p.dict['cpu_percent'],\n            p.dict['memory_percent'],\n            ctime,\n            p.dict['name'] or '',\n        )\n        try:\n            printl(line)\n        except curses.error:\n            break\n        win.refresh()\n\n\ndef setup():\n    curses.start_color()\n    curses.use_default_colors()\n    for i in range(curses.COLORS):\n        curses.init_pair(i + 1, i, -1)\n    curses.endwin()\n    win.nodelay(1)\n\n\ndef tear_down():\n    win.keypad(0)\n    curses.nocbreak()\n    curses.echo()\n    curses.endwin()\n\n\ndef main():\n    setup()\n    try:\n        interval = 0\n        while True:\n            if win.getch() == ord('q'):\n                break\n            args = poll(interval)\n            refresh_window(*args)\n            interval = 1\n    except (KeyboardInterrupt, SystemExit):\n        pass\n    finally:\n        tear_down()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/ifconfig.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'ifconfig' on UNIX.\n\n$ python3 scripts/ifconfig.py\nlo:\n    stats          : speed=0MB, duplex=?, mtu=65536, up=yes\n    incoming       : bytes=1.95M, pkts=22158, errs=0, drops=0\n    outgoing       : bytes=1.95M, pkts=22158, errs=0, drops=0\n    IPv4 address   : 127.0.0.1\n         netmask   : 255.0.0.0\n    IPv6 address   : ::1\n         netmask   : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\n    MAC  address   : 00:00:00:00:00:00\n\ndocker0:\n    stats          : speed=0MB, duplex=?, mtu=1500, up=yes\n    incoming       : bytes=3.48M, pkts=65470, errs=0, drops=0\n    outgoing       : bytes=164.06M, pkts=112993, errs=0, drops=0\n    IPv4 address   : 172.17.0.1\n         broadcast : 172.17.0.1\n         netmask   : 255.255.0.0\n    IPv6 address   : fe80::42:27ff:fe5e:799e%docker0\n         netmask   : ffff:ffff:ffff:ffff::\n    MAC  address   : 02:42:27:5e:79:9e\n         broadcast : ff:ff:ff:ff:ff:ff\n\nwlp3s0:\n    stats          : speed=0MB, duplex=?, mtu=1500, up=yes\n    incoming       : bytes=7.04G, pkts=5637208, errs=0, drops=0\n    outgoing       : bytes=372.01M, pkts=3200026, errs=0, drops=0\n    IPv4 address   : 10.0.0.2\n         broadcast : 10.255.255.255\n         netmask   : 255.0.0.0\n    IPv6 address   : fe80::ecb3:1584:5d17:937%wlp3s0\n         netmask   : ffff:ffff:ffff:ffff::\n    MAC  address   : 48:45:20:59:a4:0c\n         broadcast : ff:ff:ff:ff:ff:ff\n\"\"\"\n\nfrom __future__ import print_function\n\nimport socket\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\naf_map = {\n    socket.AF_INET: 'IPv4',\n    socket.AF_INET6: 'IPv6',\n    psutil.AF_LINK: 'MAC',\n}\n\nduplex_map = {\n    psutil.NIC_DUPLEX_FULL: \"full\",\n    psutil.NIC_DUPLEX_HALF: \"half\",\n    psutil.NIC_DUPLEX_UNKNOWN: \"?\",\n}\n\n\ndef main():\n    stats = psutil.net_if_stats()\n    io_counters = psutil.net_io_counters(pernic=True)\n    for nic, addrs in psutil.net_if_addrs().items():\n        print(\"%s:\" % (nic))\n        if nic in stats:\n            st = stats[nic]\n            print(\"    stats          : \", end='')\n            print(\n                \"speed=%sMB, duplex=%s, mtu=%s, up=%s\"\n                % (\n                    st.speed,\n                    duplex_map[st.duplex],\n                    st.mtu,\n                    \"yes\" if st.isup else \"no\",\n                )\n            )\n        if nic in io_counters:\n            io = io_counters[nic]\n            print(\"    incoming       : \", end='')\n            print(\n                \"bytes=%s, pkts=%s, errs=%s, drops=%s\"\n                % (\n                    bytes2human(io.bytes_recv),\n                    io.packets_recv,\n                    io.errin,\n                    io.dropin,\n                )\n            )\n            print(\"    outgoing       : \", end='')\n            print(\n                \"bytes=%s, pkts=%s, errs=%s, drops=%s\"\n                % (\n                    bytes2human(io.bytes_sent),\n                    io.packets_sent,\n                    io.errout,\n                    io.dropout,\n                )\n            )\n        for addr in addrs:\n            print(\"    %-4s\" % af_map.get(addr.family, addr.family), end=\"\")\n            print(\" address   : %s\" % addr.address)\n            if addr.broadcast:\n                print(\"         broadcast : %s\" % addr.broadcast)\n            if addr.netmask:\n                print(\"         netmask   : %s\" % addr.netmask)\n            if addr.ptp:\n                print(\"      p2p       : %s\" % addr.ptp)\n        print()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/temperatures.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'sensors' utility on Linux printing hardware temperatures.\n\n$ python3 scripts/sensors.py\nasus\n    asus                 47.0 \u00b0C (high = None \u00b0C, critical = None \u00b0C)\n\nacpitz\n    acpitz               47.0 \u00b0C (high = 103.0 \u00b0C, critical = 103.0 \u00b0C)\n\ncoretemp\n    Physical id 0        54.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 0               47.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 1               48.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 2               47.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 3               54.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef main():\n    if not hasattr(psutil, \"sensors_temperatures\"):\n        sys.exit(\"platform not supported\")\n    temps = psutil.sensors_temperatures()\n    if not temps:\n        sys.exit(\"can't read any temperature\")\n    for name, entries in temps.items():\n        print(name)\n        for entry in entries:\n            line = \"    %-20s %s \u00b0C (high = %s \u00b0C, critical = %s \u00b0C)\" % (\n                entry.label or name,\n                entry.current,\n                entry.high,\n                entry.critical,\n            )\n            print(line)\n        print()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/netstat.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'netstat -antp' on Linux.\n\n$ python3 scripts/netstat.py\nProto Local address      Remote address   Status        PID    Program name\ntcp   127.0.0.1:48256    127.0.0.1:45884  ESTABLISHED   13646  chrome\ntcp   127.0.0.1:47073    127.0.0.1:45884  ESTABLISHED   13646  chrome\ntcp   127.0.0.1:47072    127.0.0.1:45884  ESTABLISHED   13646  chrome\ntcp   127.0.0.1:45884    -                LISTEN        13651  GoogleTalkPlugi\ntcp   127.0.0.1:60948    -                LISTEN        13651  GoogleTalkPlugi\ntcp   172.17.42.1:49102  127.0.0.1:19305  CLOSE_WAIT    13651  GoogleTalkPlugi\ntcp   172.17.42.1:55797  127.0.0.1:443    CLOSE_WAIT    13651  GoogleTalkPlugi\n...\n\"\"\"\n\nimport socket\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\n\nimport psutil\n\n\nAD = \"-\"\nAF_INET6 = getattr(socket, 'AF_INET6', object())\nproto_map = {\n    (AF_INET, SOCK_STREAM): 'tcp',\n    (AF_INET6, SOCK_STREAM): 'tcp6',\n    (AF_INET, SOCK_DGRAM): 'udp',\n    (AF_INET6, SOCK_DGRAM): 'udp6',\n}\n\n\ndef main():\n    templ = \"%-5s %-30s %-30s %-13s %-6s %s\"\n    header = templ % (\n        \"Proto\",\n        \"Local address\",\n        \"Remote address\",\n        \"Status\",\n        \"PID\",\n        \"Program name\",\n    )\n    print(header)\n    proc_names = {}\n    for p in psutil.process_iter(['pid', 'name']):\n        proc_names[p.info['pid']] = p.info['name']\n    for c in psutil.net_connections(kind='inet'):\n        laddr = \"%s:%s\" % (c.laddr)\n        raddr = \"\"\n        if c.raddr:\n            raddr = \"%s:%s\" % (c.raddr)\n        name = proc_names.get(c.pid, '?') or ''\n        line = templ % (\n            proto_map[(c.family, c.type)],\n            laddr,\n            raddr or AD,\n            c.status,\n            c.pid or AD,\n            name[:15],\n        )\n        print(line)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/procsmem.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Show detailed memory usage about all (querable) processes.\n\nProcesses are sorted by their \"USS\" (Unique Set Size) memory, which is\nprobably the most representative metric for determining how much memory\nis actually being used by a process.\n\nThis is similar to \"smem\" cmdline utility on Linux:\nhttps://www.selenic.com/smem/\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n~/svn/psutil$ ./scripts/procsmem.py\nPID     User    Cmdline                            USS     PSS    Swap     RSS\n==============================================================================\n...\n3986    giampao /usr/bin/python3 /usr/bin/indi   15.3M   16.6M      0B   25.6M\n3906    giampao /usr/lib/ibus/ibus-ui-gtk3       17.6M   18.1M      0B   26.7M\n3991    giampao python /usr/bin/hp-systray -x    19.0M   23.3M      0B   40.7M\n3830    giampao /usr/bin/ibus-daemon --daemoni   19.0M   19.0M      0B   21.4M\n20529   giampao /opt/sublime_text/plugin_host    19.9M   20.1M      0B   22.0M\n3990    giampao nautilus -n                      20.6M   29.9M      0B   50.2M\n3898    giampao /usr/lib/unity/unity-panel-ser   27.1M   27.9M      0B   37.7M\n4176    giampao /usr/lib/evolution/evolution-c   35.7M   36.2M      0B   41.5M\n20712   giampao /usr/bin/python -B /home/giamp   45.6M   45.9M      0B   49.4M\n3880    giampao /usr/lib/x86_64-linux-gnu/hud/   51.6M   52.7M      0B   61.3M\n20513   giampao /opt/sublime_text/sublime_text   65.8M   73.0M      0B   87.9M\n3976    giampao compiz                          115.0M  117.0M      0B  130.9M\n32486   giampao skype                           145.1M  147.5M      0B  149.6M\n\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\nif not (psutil.LINUX or psutil.MACOS or psutil.WINDOWS):\n    sys.exit(\"platform not supported\")\n\n\ndef convert_bytes(n):\n    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')\n    prefix = {}\n    for i, s in enumerate(symbols):\n        prefix[s] = 1 << (i + 1) * 10\n    for s in reversed(symbols):\n        if n >= prefix[s]:\n            value = float(n) / prefix[s]\n            return '%.1f%s' % (value, s)\n    return \"%sB\" % n\n\n\ndef main():\n    ad_pids = []\n    procs = []\n    for p in psutil.process_iter():\n        with p.oneshot():\n            try:\n                mem = p.memory_full_info()\n                info = p.as_dict([\"cmdline\", \"username\"])\n            except psutil.AccessDenied:\n                ad_pids.append(p.pid)\n            except psutil.NoSuchProcess:\n                pass\n            else:\n                p._uss = mem.uss\n                p._rss = mem.rss\n                if not p._uss:\n                    continue\n                p._pss = getattr(mem, \"pss\", \"\")\n                p._swap = getattr(mem, \"swap\", \"\")\n                p._info = info\n                procs.append(p)\n\n    procs.sort(key=lambda p: p._uss)\n    templ = \"%-7s %-7s %7s %7s %7s %7s %7s\"\n    print(templ % (\"PID\", \"User\", \"USS\", \"PSS\", \"Swap\", \"RSS\", \"Cmdline\"))\n    print(\"=\" * 78)\n    for p in procs[:86]:\n        cmd = \" \".join(p._info[\"cmdline\"])[:50] if p._info[\"cmdline\"] else \"\"\n        line = templ % (\n            p.pid,\n            p._info[\"username\"][:7] if p._info[\"username\"] else \"\",\n            convert_bytes(p._uss),\n            convert_bytes(p._pss) if p._pss else \"\",\n            convert_bytes(p._swap) if p._swap else \"\",\n            convert_bytes(p._rss),\n            cmd,\n        )\n        print(line)\n    if ad_pids:\n        print(\n            \"warning: access denied for %s pids\" % (len(ad_pids)),\n            file=sys.stderr,\n        )\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/sensors.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'sensors' utility on Linux printing hardware temperatures,\nfans speed and battery info.\n\n$ python3 scripts/sensors.py\nasus\n    Temperatures:\n        asus                 57.0\u00b0C (high=None\u00b0C, critical=None\u00b0C)\n    Fans:\n        cpu_fan              3500 RPM\nacpitz\n    Temperatures:\n        acpitz               57.0\u00b0C (high=108.0\u00b0C, critical=108.0\u00b0C)\ncoretemp\n    Temperatures:\n        Physical id 0        61.0\u00b0C (high=87.0\u00b0C, critical=105.0\u00b0C)\n        Core 0               61.0\u00b0C (high=87.0\u00b0C, critical=105.0\u00b0C)\n        Core 1               59.0\u00b0C (high=87.0\u00b0C, critical=105.0\u00b0C)\nBattery:\n    charge:     84.95%\n    status:     charging\n    plugged in: yes\n\"\"\"\n\nfrom __future__ import print_function\n\nimport psutil\n\n\ndef secs2hours(secs):\n    mm, ss = divmod(secs, 60)\n    hh, mm = divmod(mm, 60)\n    return \"%d:%02d:%02d\" % (hh, mm, ss)\n\n\ndef main():\n    if hasattr(psutil, \"sensors_temperatures\"):\n        temps = psutil.sensors_temperatures()\n    else:\n        temps = {}\n    fans = psutil.sensors_fans() if hasattr(psutil, \"sensors_fans\") else {}\n    if hasattr(psutil, \"sensors_battery\"):\n        battery = psutil.sensors_battery()\n    else:\n        battery = None\n\n    if not any((temps, fans, battery)):\n        print(\"can't read any temperature, fans or battery info\")\n        return\n\n    names = set(list(temps.keys()) + list(fans.keys()))\n    for name in names:\n        print(name)\n        # Temperatures.\n        if name in temps:\n            print(\"    Temperatures:\")\n            for entry in temps[name]:\n                s = \"        %-20s %s\u00b0C (high=%s\u00b0C, critical=%s\u00b0C)\" % (\n                    entry.label or name,\n                    entry.current,\n                    entry.high,\n                    entry.critical,\n                )\n                print(s)\n        # Fans.\n        if name in fans:\n            print(\"    Fans:\")\n            for entry in fans[name]:\n                print(\n                    \"        %-20s %s RPM\"\n                    % (entry.label or name, entry.current)\n                )\n\n    # Battery.\n    if battery:\n        print(\"Battery:\")\n        print(\"    charge:     %s%%\" % round(battery.percent, 2))\n        if battery.power_plugged:\n            print(\n                \"    status:     %s\"\n                % (\"charging\" if battery.percent < 100 else \"fully charged\")\n            )\n            print(\"    plugged in: yes\")\n        else:\n            print(\"    left:       %s\" % secs2hours(battery.secsleft))\n            print(\"    status:     %s\" % \"discharging\")\n            print(\"    plugged in: no\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/meminfo.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Print system memory information.\n\n$ python3 scripts/meminfo.py\nMEMORY\n------\nTotal      :    9.7G\nAvailable  :    4.9G\nPercent    :    49.0\nUsed       :    8.2G\nFree       :    1.4G\nActive     :    5.6G\nInactive   :    2.1G\nBuffers    :  341.2M\nCached     :    3.2G\n\nSWAP\n----\nTotal      :      0B\nUsed       :      0B\nFree       :      0B\nPercent    :     0.0\nSin        :      0B\nSout       :      0B\n\"\"\"\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\ndef pprint_ntuple(nt):\n    for name in nt._fields:\n        value = getattr(nt, name)\n        if name != 'percent':\n            value = bytes2human(value)\n        print('%-10s : %7s' % (name.capitalize(), value))\n\n\ndef main():\n    print('MEMORY\\n------')\n    pprint_ntuple(psutil.virtual_memory())\n    print('\\nSWAP\\n----')\n    pprint_ntuple(psutil.swap_memory())\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/disk_usage.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"List all mounted disk partitions a-la \"df -h\" command.\n\n$ python3 scripts/disk_usage.py\nDevice               Total     Used     Free  Use %      Type  Mount\n/dev/sdb3            18.9G    14.7G     3.3G    77%      ext4  /\n/dev/sda6           345.9G    83.8G   244.5G    24%      ext4  /home\n/dev/sda1           296.0M    43.1M   252.9M    14%      vfat  /boot/efi\n/dev/sda2           600.0M   312.4M   287.6M    52%   fuseblk  /media/Recovery\n\n\"\"\"\n\nimport os\nimport sys\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\ndef main():\n    templ = \"%-17s %8s %8s %8s %5s%% %9s  %s\"\n    print(templ % (\"Device\", \"Total\", \"Used\", \"Free\", \"Use \", \"Type\", \"Mount\"))\n    for part in psutil.disk_partitions(all=False):\n        if os.name == 'nt':\n            if 'cdrom' in part.opts or not part.fstype:\n                # skip cd-rom drives with no disk in it; they may raise\n                # ENOENT, pop-up a Windows GUI error for a non-ready\n                # partition or just hang.\n                continue\n        usage = psutil.disk_usage(part.mountpoint)\n        line = templ % (\n            part.device,\n            bytes2human(usage.total),\n            bytes2human(usage.used),\n            bytes2human(usage.free),\n            int(usage.percent),\n            part.fstype,\n            part.mountpoint,\n        )\n        print(line)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/procinfo.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Print detailed information about a process.\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n$ python3 scripts/procinfo.py\npid           4600\nname          chrome\nparent        4554 (bash)\nexe           /opt/google/chrome/chrome\ncwd           /home/giampaolo\ncmdline       /opt/google/chrome/chrome\nstarted       2016-09-19 11:12\ncpu-tspent    27:27.68\ncpu-times     user=8914.32, system=3530.59,\n              children_user=1.46, children_system=1.31\ncpu-affinity  [0, 1, 2, 3, 4, 5, 6, 7]\nmemory        rss=520.5M, vms=1.9G, shared=132.6M, text=95.0M, lib=0B,\n              data=816.5M, dirty=0B\nmemory %      3.26\nuser          giampaolo\nuids          real=1000, effective=1000, saved=1000\nuids          real=1000, effective=1000, saved=1000\nterminal      /dev/pts/2\nstatus        sleeping\nnice          0\nionice        class=IOPriority.IOPRIO_CLASS_NONE, value=0\nnum-threads   47\nnum-fds       379\nI/O           read_count=96.6M, write_count=80.7M,\n              read_bytes=293.2M, write_bytes=24.5G\nctx-switches  voluntary=30426463, involuntary=460108\nchildren      PID    NAME\n              4605   cat\n              4606   cat\n              4609   chrome\n              4669   chrome\nopen-files    PATH\n              /opt/google/chrome/icudtl.dat\n              /opt/google/chrome/snapshot_blob.bin\n              /opt/google/chrome/natives_blob.bin\n              /opt/google/chrome/chrome_100_percent.pak\n              [...]\nconnections   PROTO LOCAL ADDR            REMOTE ADDR               STATUS\n              UDP   10.0.0.3:3693         *:*                       NONE\n              TCP   10.0.0.3:55102        172.217.22.14:443         ESTABLISHED\n              UDP   10.0.0.3:35172        *:*                       NONE\n              TCP   10.0.0.3:32922        172.217.16.163:443        ESTABLISHED\n              UDP   :::5353               *:*                       NONE\n              UDP   10.0.0.3:59925        *:*                       NONE\nthreads       TID              USER          SYSTEM\n              11795             0.7            1.35\n              11796            0.68            1.37\n              15887            0.74            0.03\n              19055            0.77            0.01\n              [...]\n              total=47\nres-limits    RLIMIT                     SOFT       HARD\n              virtualmem             infinity   infinity\n              coredumpsize                  0   infinity\n              cputime                infinity   infinity\n              datasize               infinity   infinity\n              filesize               infinity   infinity\n              locks                  infinity   infinity\n              memlock                   65536      65536\n              msgqueue                 819200     819200\n              nice                          0          0\n              openfiles                  8192      65536\n              maxprocesses              63304      63304\n              rss                    infinity   infinity\n              realtimeprio                  0          0\n              rtimesched             infinity   infinity\n              sigspending               63304      63304\n              stack                   8388608   infinity\nmem-maps      RSS      PATH\n              381.4M   [anon]\n              62.8M    /opt/google/chrome/chrome\n              15.8M    /home/giampaolo/.config/google-chrome/Default/History\n              6.6M     /home/giampaolo/.config/google-chrome/Default/Favicons\n              [...]\n\"\"\"\n\nimport argparse\nimport datetime\nimport socket\nimport sys\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nACCESS_DENIED = ''\nNON_VERBOSE_ITERATIONS = 4\nRLIMITS_MAP = {\n    \"RLIMIT_AS\": \"virtualmem\",\n    \"RLIMIT_CORE\": \"coredumpsize\",\n    \"RLIMIT_CPU\": \"cputime\",\n    \"RLIMIT_DATA\": \"datasize\",\n    \"RLIMIT_FSIZE\": \"filesize\",\n    \"RLIMIT_MEMLOCK\": \"memlock\",\n    \"RLIMIT_MSGQUEUE\": \"msgqueue\",\n    \"RLIMIT_NICE\": \"nice\",\n    \"RLIMIT_NOFILE\": \"openfiles\",\n    \"RLIMIT_NPROC\": \"maxprocesses\",\n    \"RLIMIT_NPTS\": \"pseudoterms\",\n    \"RLIMIT_RSS\": \"rss\",\n    \"RLIMIT_RTPRIO\": \"realtimeprio\",\n    \"RLIMIT_RTTIME\": \"rtimesched\",\n    \"RLIMIT_SBSIZE\": \"sockbufsize\",\n    \"RLIMIT_SIGPENDING\": \"sigspending\",\n    \"RLIMIT_STACK\": \"stack\",\n    \"RLIMIT_SWAP\": \"swapuse\",\n}\n\n\ndef print_(a, b):\n    if sys.stdout.isatty() and psutil.POSIX:\n        fmt = '\\x1b[1;32m%-13s\\x1b[0m %s' % (a, b)\n    else:\n        fmt = '%-11s %s' % (a, b)\n    print(fmt)\n\n\ndef str_ntuple(nt, convert_bytes=False):\n    if nt == ACCESS_DENIED:\n        return \"\"\n    if not convert_bytes:\n        return \", \".join([\"%s=%s\" % (x, getattr(nt, x)) for x in nt._fields])\n    else:\n        return \", \".join(\n            [\"%s=%s\" % (x, bytes2human(getattr(nt, x))) for x in nt._fields]\n        )\n\n\ndef run(pid, verbose=False):\n    try:\n        proc = psutil.Process(pid)\n        pinfo = proc.as_dict(ad_value=ACCESS_DENIED)\n    except psutil.NoSuchProcess as err:\n        sys.exit(str(err))\n\n    # collect other proc info\n    with proc.oneshot():\n        try:\n            parent = proc.parent()\n            parent = '(%s)' % parent.name() if parent else ''\n        except psutil.Error:\n            parent = ''\n        try:\n            pinfo['children'] = proc.children()\n        except psutil.Error:\n            pinfo['children'] = []\n        if pinfo['create_time']:\n            started = datetime.datetime.fromtimestamp(\n                pinfo['create_time']\n            ).strftime('%Y-%m-%d %H:%M')\n        else:\n            started = ACCESS_DENIED\n\n    # here we go\n    print_('pid', pinfo['pid'])\n    print_('name', pinfo['name'])\n    print_('parent', '%s %s' % (pinfo['ppid'], parent))\n    print_('exe', pinfo['exe'])\n    print_('cwd', pinfo['cwd'])\n    print_('cmdline', ' '.join(pinfo['cmdline']))\n    print_('started', started)\n\n    cpu_tot_time = datetime.timedelta(seconds=sum(pinfo['cpu_times']))\n    cpu_tot_time = \"%s:%s.%s\" % (\n        cpu_tot_time.seconds // 60 % 60,\n        str(cpu_tot_time.seconds % 60).zfill(2),\n        str(cpu_tot_time.microseconds)[:2],\n    )\n    print_('cpu-tspent', cpu_tot_time)\n    print_('cpu-times', str_ntuple(pinfo['cpu_times']))\n    if hasattr(proc, \"cpu_affinity\"):\n        print_(\"cpu-affinity\", pinfo[\"cpu_affinity\"])\n    if hasattr(proc, \"cpu_num\"):\n        print_(\"cpu-num\", pinfo[\"cpu_num\"])\n\n    print_('memory', str_ntuple(pinfo['memory_info'], convert_bytes=True))\n    print_('memory %', round(pinfo['memory_percent'], 2))\n    print_('user', pinfo['username'])\n    if psutil.POSIX:\n        print_('uids', str_ntuple(pinfo['uids']))\n    if psutil.POSIX:\n        print_('uids', str_ntuple(pinfo['uids']))\n    if psutil.POSIX:\n        print_('terminal', pinfo['terminal'] or '')\n\n    print_('status', pinfo['status'])\n    print_('nice', pinfo['nice'])\n    if hasattr(proc, \"ionice\"):\n        try:\n            ionice = proc.ionice()\n        except psutil.Error:\n            pass\n        else:\n            if psutil.WINDOWS:\n                print_(\"ionice\", ionice)\n            else:\n                print_(\n                    \"ionice\",\n                    \"class=%s, value=%s\" % (str(ionice.ioclass), ionice.value),\n                )\n\n    print_('num-threads', pinfo['num_threads'])\n    if psutil.POSIX:\n        print_('num-fds', pinfo['num_fds'])\n    if psutil.WINDOWS:\n        print_('num-handles', pinfo['num_handles'])\n\n    if 'io_counters' in pinfo:\n        print_('I/O', str_ntuple(pinfo['io_counters'], convert_bytes=True))\n    if 'num_ctx_switches' in pinfo:\n        print_(\"ctx-switches\", str_ntuple(pinfo['num_ctx_switches']))\n    if pinfo['children']:\n        template = \"%-6s %s\"\n        print_(\"children\", template % (\"PID\", \"NAME\"))\n        for child in pinfo['children']:\n            try:\n                print_('', template % (child.pid, child.name()))\n            except psutil.AccessDenied:\n                print_('', template % (child.pid, \"\"))\n            except psutil.NoSuchProcess:\n                pass\n\n    if pinfo['open_files']:\n        print_('open-files', 'PATH')\n        for i, file in enumerate(pinfo['open_files']):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_('', file.path)\n    else:\n        print_('open-files', '')\n\n    if pinfo['net_connections']:\n        template = '%-5s %-25s %-25s %s'\n        print_(\n            'connections',\n            template % ('PROTO', 'LOCAL ADDR', 'REMOTE ADDR', 'STATUS'),\n        )\n        for conn in pinfo['net_connections']:\n            if conn.type == socket.SOCK_STREAM:\n                type = 'TCP'\n            elif conn.type == socket.SOCK_DGRAM:\n                type = 'UDP'\n            else:\n                type = 'UNIX'\n            lip, lport = conn.laddr\n            if not conn.raddr:\n                rip, rport = '*', '*'\n            else:\n                rip, rport = conn.raddr\n            line = template % (\n                type,\n                \"%s:%s\" % (lip, lport),\n                \"%s:%s\" % (rip, rport),\n                conn.status,\n            )\n            print_('', line)\n    else:\n        print_('connections', '')\n\n    if pinfo['threads'] and len(pinfo['threads']) > 1:\n        template = \"%-5s %12s %12s\"\n        print_('threads', template % (\"TID\", \"USER\", \"SYSTEM\"))\n        for i, thread in enumerate(pinfo['threads']):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_('', template % thread)\n        print_('', \"total=%s\" % len(pinfo['threads']))\n    else:\n        print_('threads', '')\n\n    if hasattr(proc, \"rlimit\"):\n        res_names = [x for x in dir(psutil) if x.startswith(\"RLIMIT\")]\n        resources = []\n        for res_name in res_names:\n            try:\n                soft, hard = proc.rlimit(getattr(psutil, res_name))\n            except psutil.AccessDenied:\n                pass\n            else:\n                resources.append((res_name, soft, hard))\n        if resources:\n            template = \"%-12s %15s %15s\"\n            print_(\"res-limits\", template % (\"RLIMIT\", \"SOFT\", \"HARD\"))\n            for res_name, soft, hard in resources:\n                if soft == psutil.RLIM_INFINITY:\n                    soft = \"infinity\"\n                if hard == psutil.RLIM_INFINITY:\n                    hard = \"infinity\"\n                print_(\n                    '',\n                    template\n                    % (RLIMITS_MAP.get(res_name, res_name), soft, hard),\n                )\n\n    if hasattr(proc, \"environ\") and pinfo['environ']:\n        template = \"%-25s %s\"\n        print_(\"environ\", template % (\"NAME\", \"VALUE\"))\n        for i, k in enumerate(sorted(pinfo['environ'])):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_(\"\", template % (k, pinfo['environ'][k]))\n\n    if pinfo.get('memory_maps', None):\n        template = \"%-8s %s\"\n        print_(\"mem-maps\", template % (\"RSS\", \"PATH\"))\n        maps = sorted(pinfo['memory_maps'], key=lambda x: x.rss, reverse=True)\n        for i, region in enumerate(maps):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_(\"\", template % (bytes2human(region.rss), region.path))\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"print information about a process\"\n    )\n    parser.add_argument(\"pid\", type=int, help=\"process pid\", nargs='?')\n    parser.add_argument(\n        '--verbose', '-v', action='store_true', help=\"print more info\"\n    )\n    args = parser.parse_args()\n    run(args.pid, args.verbose)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/fans.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Show fans information.\n\n$ python fans.py\nasus\n    cpu_fan              3200 RPM\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef main():\n    if not hasattr(psutil, \"sensors_fans\"):\n        return sys.exit(\"platform not supported\")\n    fans = psutil.sensors_fans()\n    if not fans:\n        print(\"no fans detected\")\n        return\n    for name, entries in fans.items():\n        print(name)\n        for entry in entries:\n            print(\"    %-20s %s RPM\" % (entry.label or name, entry.current))\n        print()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/pidof.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola', karthikrev. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\n\"\"\"A clone of 'pidof' cmdline utility.\n\n$ pidof python\n1140 1138 1136 1134 1133 1129 1127 1125 1121 1120 1119\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef pidof(pgname):\n    pids = []\n    for proc in psutil.process_iter(['name', 'cmdline']):\n        # search for matches in the process name and cmdline\n        if (\n            proc.info['name'] == pgname\n            or proc.info['cmdline']\n            and proc.info['cmdline'][0] == pgname\n        ):\n            pids.append(str(proc.pid))\n    return pids\n\n\ndef main():\n    if len(sys.argv) != 2:\n        sys.exit('usage: %s pgname' % __file__)\n    else:\n        pgname = sys.argv[1]\n    pids = pidof(pgname)\n    if pids:\n        print(\" \".join(pids))\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/ps.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'ps aux'.\n\n$ python3 scripts/ps.py\nUSER         PID  %MEM     VSZ     RSS  NICE STATUS  START   TIME  CMDLINE\nroot           1   0.0  220.9M    6.5M        sleep  Mar27  09:10  /lib/systemd\nroot           2   0.0    0.0B    0.0B        sleep  Mar27  00:00  kthreadd\nroot           4   0.0    0.0B    0.0B   -20   idle  Mar27  00:00  kworker/0:0H\nroot           6   0.0    0.0B    0.0B   -20   idle  Mar27  00:00  mm_percpu_wq\nroot           7   0.0    0.0B    0.0B        sleep  Mar27  00:06  ksoftirqd/0\nroot           8   0.0    0.0B    0.0B         idle  Mar27  03:32  rcu_sched\nroot           9   0.0    0.0B    0.0B         idle  Mar27  00:00  rcu_bh\nroot          10   0.0    0.0B    0.0B        sleep  Mar27  00:00  migration/0\nroot          11   0.0    0.0B    0.0B        sleep  Mar27  00:00  watchdog/0\nroot          12   0.0    0.0B    0.0B        sleep  Mar27  00:00  cpuhp/0\nroot          13   0.0    0.0B    0.0B        sleep  Mar27  00:00  cpuhp/1\nroot          14   0.0    0.0B    0.0B        sleep  Mar27  00:01  watchdog/1\nroot          15   0.0    0.0B    0.0B        sleep  Mar27  00:00  migration/1\n[...]\ngiampaolo  19704   1.5    1.9G  235.6M        sleep  17:39  01:11  firefox\nroot       20414   0.0    0.0B    0.0B         idle  Apr04  00:00  kworker/4:2\ngiampaolo  20952   0.0   10.7M  100.0K        sleep  Mar28  00:00  sh -c /usr\ngiampaolo  20953   0.0  269.0M  528.0K        sleep  Mar28  00:00  /usr/lib/\ngiampaolo  22150   3.3    2.4G  525.5M        sleep  Apr02  49:09  /usr/lib/\nroot       22338   0.0    0.0B    0.0B         idle  02:04  00:00  kworker/1:2\ngiampaolo  24123   0.0   35.0M    7.0M        sleep  02:12  00:02  bash\n\"\"\"\n\nimport datetime\nimport time\n\nimport psutil\nfrom psutil._common import bytes2human\nfrom psutil._compat import get_terminal_size\n\n\ndef main():\n    today_day = datetime.date.today()\n    # fmt: off\n    templ = \"%-10s %5s %5s %7s %7s %5s %6s %6s %6s  %s\"\n    attrs = ['pid', 'memory_percent', 'name', 'cmdline', 'cpu_times',\n             'create_time', 'memory_info', 'status', 'nice', 'username']\n    print(templ % (\"USER\", \"PID\", \"%MEM\", \"VSZ\", \"RSS\", \"NICE\",\n                   \"STATUS\", \"START\", \"TIME\", \"CMDLINE\"))\n    # fmt: on\n    for p in psutil.process_iter(attrs, ad_value=None):\n        if p.info['create_time']:\n            ctime = datetime.datetime.fromtimestamp(p.info['create_time'])\n            if ctime.date() == today_day:\n                ctime = ctime.strftime(\"%H:%M\")\n            else:\n                ctime = ctime.strftime(\"%b%d\")\n        else:\n            ctime = ''\n        if p.info['cpu_times']:\n            cputime = time.strftime(\n                \"%M:%S\", time.localtime(sum(p.info['cpu_times']))\n            )\n        else:\n            cputime = ''\n\n        user = p.info['username']\n        if not user and psutil.POSIX:\n            try:\n                user = p.uids()[0]\n            except psutil.Error:\n                pass\n        if user and psutil.WINDOWS and '\\\\' in user:\n            user = user.split('\\\\')[1]\n        if not user:\n            user = ''\n        user = user[:9]\n        vms = (\n            bytes2human(p.info['memory_info'].vms)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        rss = (\n            bytes2human(p.info['memory_info'].rss)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        memp = (\n            round(p.info['memory_percent'], 1)\n            if p.info['memory_percent'] is not None\n            else ''\n        )\n        nice = int(p.info['nice']) if p.info['nice'] else ''\n        if p.info['cmdline']:\n            cmdline = ' '.join(p.info['cmdline'])\n        else:\n            cmdline = p.info['name']\n        status = p.info['status'][:5] if p.info['status'] else ''\n\n        line = templ % (\n            user,\n            p.info['pid'],\n            memp,\n            vms,\n            rss,\n            nice,\n            status,\n            ctime,\n            cputime,\n            cmdline,\n        )\n        print(line[: get_terminal_size()[0]])\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/killall.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Kill a process by name.\"\"\"\n\nimport os\nimport sys\n\nimport psutil\n\n\ndef main():\n    if len(sys.argv) != 2:\n        sys.exit('usage: %s name' % __file__)\n    else:\n        name = sys.argv[1]\n\n    killed = []\n    for proc in psutil.process_iter():\n        if proc.name() == name and proc.pid != os.getpid():\n            proc.kill()\n            killed.append(proc.pid)\n    if not killed:\n        sys.exit('%s: no process found' % name)\n    else:\n        sys.exit(0)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_api_speed.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Benchmark all API calls and print them from fastest to slowest.\n\n$ make print_api_speed\nSYSTEM APIS                NUM CALLS      SECONDS\n-------------------------------------------------\ndisk_usage                       300      0.00157\ncpu_count                        300      0.00255\npid_exists                       300      0.00792\ncpu_times                        300      0.01044\nboot_time                        300      0.01136\ncpu_percent                      300      0.01290\ncpu_times_percent                300      0.01515\nvirtual_memory                   300      0.01594\nusers                            300      0.01964\nnet_io_counters                  300      0.02027\ncpu_stats                        300      0.02034\nnet_if_addrs                     300      0.02962\nswap_memory                      300      0.03209\nsensors_battery                  300      0.05186\npids                             300      0.07954\nnet_if_stats                     300      0.09321\ndisk_io_counters                 300      0.09406\ncpu_count (cores)                300      0.10293\ndisk_partitions                  300      0.10345\ncpu_freq                         300      0.20817\nsensors_fans                     300      0.63476\nsensors_temperatures             231      2.00039\nprocess_iter (all)               171      2.01300\nnet_connections                   97      2.00206\n\nPROCESS APIS               NUM CALLS      SECONDS\n-------------------------------------------------\ncreate_time                      300      0.00009\nexe                              300      0.00015\nnice                             300      0.00057\nionice                           300      0.00091\ncpu_affinity                     300      0.00091\ncwd                              300      0.00151\nnum_fds                          300      0.00391\nmemory_info                      300      0.00597\nmemory_percent                   300      0.00648\nio_counters                      300      0.00707\nname                             300      0.00894\nstatus                           300      0.00900\nppid                             300      0.00906\nnum_threads                      300      0.00932\ncpu_num                          300      0.00933\nnum_ctx_switches                 300      0.00943\nuids                             300      0.00979\ngids                             300      0.01002\ncpu_times                        300      0.01008\ncmdline                          300      0.01009\nterminal                         300      0.01059\nis_running                       300      0.01063\nthreads                          300      0.01209\nconnections                      300      0.01276\ncpu_percent                      300      0.01463\nopen_files                       300      0.01630\nusername                         300      0.01655\nenviron                          300      0.02250\nmemory_full_info                 300      0.07066\nmemory_maps                      300      0.74281\n\"\"\"\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport argparse\nimport inspect\nimport os\nimport sys\nfrom timeit import default_timer as timer\n\nimport psutil\nfrom psutil._common import print_color\n\n\nTIMES = 300\ntimings = []\ntempl = \"%-25s %10s   %10s\"\n\n\ndef print_header(what):\n    s = templ % (what, \"NUM CALLS\", \"SECONDS\")\n    print_color(s, color=None, bold=True)\n    print(\"-\" * len(s))\n\n\ndef print_timings():\n    timings.sort(key=lambda x: (x[1], -x[2]), reverse=True)\n    i = 0\n    while timings[:]:\n        title, times, elapsed = timings.pop(0)\n        s = templ % (title, str(times), \"%.5f\" % elapsed)\n        if i > len(timings) - 5:\n            print_color(s, color=\"red\")\n        else:\n            print(s)\n\n\ndef timecall(title, fun, *args, **kw):\n    print(\"%-50s\" % title, end=\"\")\n    sys.stdout.flush()\n    t = timer()\n    for n in range(TIMES):\n        fun(*args, **kw)\n        elapsed = timer() - t\n        if elapsed > 2:\n            break\n    print(\"\\r\", end=\"\")\n    sys.stdout.flush()\n    timings.append((title, n + 1, elapsed))\n\n\ndef set_highest_priority():\n    \"\"\"Set highest CPU and I/O priority (requires root).\"\"\"\n    p = psutil.Process()\n    if psutil.WINDOWS:\n        p.nice(psutil.HIGH_PRIORITY_CLASS)\n    else:\n        p.nice(-20)\n\n    if psutil.LINUX:\n        p.ionice(psutil.IOPRIO_CLASS_RT, value=7)\n    elif psutil.WINDOWS:\n        p.ionice(psutil.IOPRIO_HIGH)\n\n\ndef main():\n    global TIMES\n\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawTextHelpFormatter\n    )\n    parser.add_argument('-t', '--times', type=int, default=TIMES)\n    args = parser.parse_args()\n    TIMES = args.times\n    assert TIMES > 1, TIMES\n\n    try:\n        set_highest_priority()\n    except psutil.AccessDenied:\n        prio_set = False\n    else:\n        prio_set = True\n\n    # --- system\n\n    public_apis = []\n    ignore = [\n        'wait_procs',\n        'process_iter',\n        'win_service_get',\n        'win_service_iter',\n    ]\n    if psutil.MACOS:\n        ignore.append('net_connections')  # raises AD\n    for name in psutil.__all__:\n        obj = getattr(psutil, name, None)\n        if inspect.isfunction(obj):\n            if name not in ignore:\n                public_apis.append(name)\n\n    print_header(\"SYSTEM APIS\")\n    for name in public_apis:\n        fun = getattr(psutil, name)\n        args = ()\n        if name == 'pid_exists':\n            args = (os.getpid(),)\n        elif name == 'disk_usage':\n            args = (os.getcwd(),)\n        timecall(name, fun, *args)\n    timecall('cpu_count (cores)', psutil.cpu_count, logical=False)\n    timecall('process_iter (all)', lambda: list(psutil.process_iter()))\n    print_timings()\n\n    # --- process\n    print()\n    print_header(\"PROCESS APIS\")\n    ignore = [\n        'send_signal',\n        'suspend',\n        'resume',\n        'terminate',\n        'kill',\n        'wait',\n        'as_dict',\n        'parent',\n        'parents',\n        'memory_info_ex',\n        'oneshot',\n        'pid',\n        'rlimit',\n        'children',\n    ]\n    if psutil.MACOS:\n        ignore.append('memory_maps')  # XXX\n    p = psutil.Process()\n    for name in sorted(dir(p)):\n        if not name.startswith('_') and name not in ignore:\n            fun = getattr(p, name)\n            timecall(name, fun)\n    print_timings()\n\n    if not prio_set:\n        msg = \"\\nWARN: couldn't set highest process priority \"\n        msg += \"(requires root)\"\n        print_color(msg, \"red\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/bench_oneshot.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A simple micro benchmark script which prints the speedup when using\nProcess.oneshot() ctx manager.\nSee: https://github.com/giampaolo/psutil/issues/799.\n\"\"\"\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\nimport textwrap\nimport timeit\n\nimport psutil\n\n\nITERATIONS = 1000\n\n# The list of Process methods which gets collected in one shot and\n# as such get advantage of the speedup.\nnames = [\n    'cpu_times',\n    'cpu_percent',\n    'memory_info',\n    'memory_percent',\n    'ppid',\n    'parent',\n]\n\nif psutil.POSIX:\n    names.append('uids')\n    names.append('username')\n\nif psutil.LINUX:\n    names += [\n        # 'memory_full_info',\n        # 'memory_maps',\n        'cpu_num',\n        'cpu_times',\n        'gids',\n        'name',\n        'num_ctx_switches',\n        'num_threads',\n        'ppid',\n        'status',\n        'terminal',\n        'uids',\n    ]\nelif psutil.BSD:\n    names = [\n        'cpu_times',\n        'gids',\n        'io_counters',\n        'memory_full_info',\n        'memory_info',\n        'name',\n        'num_ctx_switches',\n        'ppid',\n        'status',\n        'terminal',\n        'uids',\n    ]\n    if psutil.FREEBSD:\n        names.append('cpu_num')\nelif psutil.SUNOS:\n    names += [\n        'cmdline',\n        'gids',\n        'memory_full_info',\n        'memory_info',\n        'name',\n        'num_threads',\n        'ppid',\n        'status',\n        'terminal',\n        'uids',\n    ]\nelif psutil.MACOS:\n    names += [\n        'cpu_times',\n        'create_time',\n        'gids',\n        'memory_info',\n        'name',\n        'num_ctx_switches',\n        'num_threads',\n        'ppid',\n        'terminal',\n        'uids',\n    ]\nelif psutil.WINDOWS:\n    names += [\n        'num_ctx_switches',\n        'num_threads',\n        # dual implementation, called in case of AccessDenied\n        'num_handles',\n        'cpu_times',\n        'create_time',\n        'num_threads',\n        'io_counters',\n        'memory_info',\n    ]\n\nnames = sorted(set(names))\n\nsetup = textwrap.dedent(\"\"\"\n    from __main__ import names\n    import psutil\n\n    def call_normal(funs):\n        for fun in funs:\n            fun()\n\n    def call_oneshot(funs):\n        with p.oneshot():\n            for fun in funs:\n                fun()\n\n    p = psutil.Process()\n    funs = [getattr(p, n) for n in names]\n    \"\"\")\n\n\ndef main():\n    print(\n        \"%s methods involved on platform %r (%s iterations, psutil %s):\"\n        % (len(names), sys.platform, ITERATIONS, psutil.__version__)\n    )\n    for name in sorted(names):\n        print(\"    \" + name)\n\n    # \"normal\" run\n    elapsed1 = timeit.timeit(\n        \"call_normal(funs)\", setup=setup, number=ITERATIONS\n    )\n    print(\"normal:  %.3f secs\" % elapsed1)\n\n    # \"one shot\" run\n    elapsed2 = timeit.timeit(\n        \"call_oneshot(funs)\", setup=setup, number=ITERATIONS\n    )\n    print(\"onshot:  %.3f secs\" % elapsed2)\n\n    # done\n    if elapsed2 < elapsed1:\n        print(\"speedup: +%.2fx\" % (elapsed1 / elapsed2))\n    elif elapsed2 > elapsed1:\n        print(\"slowdown: -%.2fx\" % (elapsed2 / elapsed1))\n    else:\n        print(\"same speed\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/download_wheels_appveyor.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Script which downloads wheel files hosted on AppVeyor:\nhttps://ci.appveyor.com/project/giampaolo/psutil\nRe-adapted from the original recipe of Ibarra Corretge'\n<saghul@gmail.com>:\nhttp://code.saghul.net/index.php/2015/09/09/.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport concurrent.futures\nimport os\nimport sys\n\nimport requests\n\nfrom psutil import __version__\nfrom psutil._common import bytes2human\nfrom psutil._common import print_color\n\n\nUSER = \"giampaolo\"\nPROJECT = \"psutil\"\nPROJECT_VERSION = __version__\nBASE_URL = 'https://ci.appveyor.com/api'\nPY_VERSIONS = ['2.7']\nTIMEOUT = 30\n\n\ndef download_file(url):\n    local_fname = url.split('/')[-1]\n    local_fname = os.path.join('dist', local_fname)\n    os.makedirs('dist', exist_ok=True)\n    r = requests.get(url, stream=True, timeout=TIMEOUT)\n    tot_bytes = 0\n    with open(local_fname, 'wb') as f:\n        for chunk in r.iter_content(chunk_size=16384):\n            if chunk:  # filter out keep-alive new chunks\n                f.write(chunk)\n                tot_bytes += len(chunk)\n    return local_fname\n\n\ndef get_file_urls():\n    with requests.Session() as session:\n        data = session.get(\n            BASE_URL + '/projects/' + USER + '/' + PROJECT, timeout=TIMEOUT\n        )\n        data = data.json()\n\n        urls = []\n        for job in (job['jobId'] for job in data['build']['jobs']):\n            job_url = BASE_URL + '/buildjobs/' + job + '/artifacts'\n            data = session.get(job_url, timeout=TIMEOUT)\n            data = data.json()\n            for item in data:\n                file_url = job_url + '/' + item['fileName']\n                urls.append(file_url)\n        if not urls:\n            print_color(\"no artifacts found\", 'red')\n            sys.exit(1)\n        else:\n            for url in sorted(urls, key=os.path.basename):\n                yield url\n\n\ndef rename_win27_wheels():\n    # See: https://github.com/giampaolo/psutil/issues/810\n    src = 'dist/psutil-%s-cp27-cp27m-win32.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win32.whl' % PROJECT_VERSION\n    print(\"rename: %s\\n        %s\" % (src, dst))\n    os.rename(src, dst)\n    src = 'dist/psutil-%s-cp27-cp27m-win_amd64.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win_amd64.whl' % PROJECT_VERSION\n    print(\"rename: %s\\n        %s\" % (src, dst))\n    os.rename(src, dst)\n\n\ndef run():\n    urls = get_file_urls()\n    completed = 0\n    exc = None\n    with concurrent.futures.ThreadPoolExecutor() as e:\n        fut_to_url = {e.submit(download_file, url): url for url in urls}\n        for fut in concurrent.futures.as_completed(fut_to_url):\n            url = fut_to_url[fut]\n            try:\n                local_fname = fut.result()\n            except Exception:\n                print_color(\"error while downloading %s\" % (url), 'red')\n                raise\n            else:\n                completed += 1\n                print(\n                    \"downloaded %-45s %s\"\n                    % (local_fname, bytes2human(os.path.getsize(local_fname)))\n                )\n    # 2 wheels (32 and 64 bit) per supported python version\n    expected = len(PY_VERSIONS) * 2\n    if expected != completed:\n        return sys.exit(\"expected %s files, got %s\" % (expected, completed))\n    if exc:\n        return sys.exit()\n    rename_win27_wheels()\n\n\ndef main():\n    run()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/download_wheels_github.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Script which downloads wheel files hosted on GitHub:\nhttps://github.com/giampaolo/psutil/actions\nIt needs an access token string generated from personal GitHub profile:\nhttps://github.com/settings/tokens\nThe token must be created with at least \"public_repo\" scope/rights.\nIf you lose it, just generate a new token.\nREST API doc:\nhttps://developer.github.com/v3/actions/artifacts/.\n\"\"\"\n\nimport argparse\nimport json\nimport os\nimport sys\nimport zipfile\n\nimport requests\n\nfrom psutil import __version__\nfrom psutil._common import bytes2human\nfrom psutil.tests import safe_rmpath\n\n\nUSER = \"giampaolo\"\nPROJECT = \"psutil\"\nPROJECT_VERSION = __version__\nOUTFILE = \"wheels-github.zip\"\nTOKEN = \"\"\nTIMEOUT = 30\n\n\ndef get_artifacts():\n    base_url = \"https://api.github.com/repos/%s/%s\" % (USER, PROJECT)\n    url = base_url + \"/actions/artifacts\"\n    res = requests.get(\n        url=url, headers={\"Authorization\": \"token %s\" % TOKEN}, timeout=TIMEOUT\n    )\n    res.raise_for_status()\n    data = json.loads(res.content)\n    return data\n\n\ndef download_zip(url):\n    print(\"downloading: \" + url)\n    res = requests.get(\n        url=url, headers={\"Authorization\": \"token %s\" % TOKEN}, timeout=TIMEOUT\n    )\n    res.raise_for_status()\n    totbytes = 0\n    with open(OUTFILE, 'wb') as f:\n        for chunk in res.iter_content(chunk_size=16384):\n            f.write(chunk)\n            totbytes += len(chunk)\n    print(\"got %s, size %s)\" % (OUTFILE, bytes2human(totbytes)))\n\n\ndef rename_win27_wheels():\n    # See: https://github.com/giampaolo/psutil/issues/810\n    src = 'dist/psutil-%s-cp27-cp27m-win32.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win32.whl' % PROJECT_VERSION\n    if os.path.exists(src):\n        print(\"rename: %s\\n        %s\" % (src, dst))\n        os.rename(src, dst)\n    src = 'dist/psutil-%s-cp27-cp27m-win_amd64.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win_amd64.whl' % PROJECT_VERSION\n    if os.path.exists(src):\n        print(\"rename: %s\\n        %s\" % (src, dst))\n        os.rename(src, dst)\n\n\ndef run():\n    data = get_artifacts()\n    download_zip(data['artifacts'][0]['archive_download_url'])\n    os.makedirs('dist', exist_ok=True)\n    with zipfile.ZipFile(OUTFILE, 'r') as zf:\n        zf.extractall('dist')\n    rename_win27_wheels()\n\n\ndef main():\n    global TOKEN\n    parser = argparse.ArgumentParser(description='GitHub wheels downloader')\n    parser.add_argument('--token')\n    parser.add_argument('--tokenfile')\n    args = parser.parse_args()\n\n    if args.tokenfile:\n        with open(os.path.expanduser(args.tokenfile)) as f:\n            TOKEN = f.read().strip()\n    elif args.token:\n        TOKEN = args.token\n    else:\n        return sys.exit('specify --token or --tokenfile args')\n\n    try:\n        run()\n    finally:\n        safe_rmpath(OUTFILE)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/clinter.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A super simple linter to check C syntax.\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport sys\n\n\nwarned = False\n\n\ndef warn(path, line, lineno, msg):\n    global warned\n    warned = True\n    print(\"%s:%s: %s\" % (path, lineno, msg), file=sys.stderr)\n\n\ndef check_line(path, line, idx, lines):\n    s = line\n    lineno = idx + 1\n    eof = lineno == len(lines)\n    if s.endswith(' \\n'):\n        warn(path, line, lineno, \"extra space at EOL\")\n    elif '\\t' in line:\n        warn(path, line, lineno, \"line has a tab\")\n    elif s.endswith('\\r\\n'):\n        warn(path, line, lineno, \"Windows line ending\")\n    # end of global block, e.g. \"}newfunction...\":\n    elif s == \"}\\n\":\n        if not eof:\n            nextline = lines[idx + 1]\n            # \"#\" is a pre-processor line\n            if (\n                nextline != '\\n'\n                and nextline.strip()[0] != '#'\n                and nextline.strip()[:2] != '*/'\n            ):\n                warn(path, line, lineno, \"expected 1 blank line\")\n\n    sls = s.lstrip()\n    if sls.startswith('//') and sls[2] != ' ' and line.strip() != '//':\n        warn(path, line, lineno, \"no space after // comment\")\n    # e.g. \"if(...\" after keywords\n    keywords = (\"if\", \"else\", \"while\", \"do\", \"enum\", \"for\")\n    for kw in keywords:\n        if sls.startswith(kw + '('):\n            warn(path, line, lineno, \"missing space between %r and '('\" % kw)\n    # eof\n    if eof and not line.endswith('\\n'):\n        warn(path, line, lineno, \"no blank line at EOF\")\n\n    ss = s.strip()\n    if ss.startswith((\"printf(\", \"printf (\")):\n        if not ss.endswith((\"// NOQA\", \"//  NOQA\")):\n            warn(path, line, lineno, \"printf() statement\")\n\n\ndef process(path):\n    with open(path) as f:\n        lines = f.readlines()\n    for idx, line in enumerate(lines):\n        check_line(path, line, idx, lines)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('paths', nargs='+', help='path(s) to a file(s)')\n    args = parser.parse_args()\n    for path in args.paths:\n        process(path)\n    if warned:\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/check_broken_links.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola', Himanshu Shekhar.\n# All rights reserved. Use of this source code is governed by a\n# BSD-style license that can be found in the LICENSE file.\n\n\"\"\"Checks for broken links in file names specified as command line\nparameters.\n\nThere are a ton of a solutions available for validating URLs in string\nusing regex, but less for searching, of which very few are accurate.\nThis snippet is intended to just do the required work, and avoid\ncomplexities. Django Validator has pretty good regex for validation,\nbut we have to find urls instead of validating them (REFERENCES [7]).\nThere's always room for improvement.\n\nMethod:\n* Match URLs using regex (REFERENCES [1]])\n* Some URLs need to be fixed, as they have < (or) > due to inefficient\n  regex.\n* Remove duplicates (because regex is not 100% efficient as of now).\n* Check validity of URL, using HEAD request. (HEAD to save bandwidth)\n  Uses requests module for others are painful to use. REFERENCES[9]\n  Handles redirects, http, https, ftp as well.\n\nREFERENCES:\nUsing [1] with some modifications for including ftp\n[1] http://stackoverflow.com/a/6883094/5163807\n[2] http://stackoverflow.com/a/31952097/5163807\n[3] http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n[4] https://mathiasbynens.be/demo/url-regex\n[5] https://github.com/django/django/blob/master/django/core/validators.py\n[6] https://data.iana.org/TLD/tlds-alpha-by-domain.txt\n[7] https://codereview.stackexchange.com/questions/19663/http-url-validating\n[8] https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD\n[9] http://docs.python-requests.org/\n\nAuthor: Himanshu Shekhar <https://github.com/himanshub16> (2017)\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport concurrent.futures\nimport functools\nimport os\nimport re\nimport sys\nimport traceback\n\nimport requests\n\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nREGEX = re.compile(\n    r'(?:http|ftp|https)?://'\n    r'(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n)\nREQUEST_TIMEOUT = 15\n# There are some status codes sent by websites on HEAD request.\n# Like 503 by Microsoft, and 401 by Apple\n# They need to be sent GET request\nRETRY_STATUSES = [503, 401, 403]\n\n\ndef memoize(fun):\n    \"\"\"A memoize decorator.\"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = (args, frozenset(sorted(kwargs.items())))\n        try:\n            return cache[key]\n        except KeyError:\n            ret = cache[key] = fun(*args, **kwargs)\n            return ret\n\n    cache = {}\n    return wrapper\n\n\ndef sanitize_url(url):\n    url = url.rstrip(',')\n    url = url.rstrip('.')\n    url = url.lstrip('(')\n    url = url.rstrip(')')\n    url = url.lstrip('[')\n    url = url.rstrip(']')\n    url = url.lstrip('<')\n    url = url.rstrip('>')\n    return url\n\n\ndef find_urls(s):\n    matches = REGEX.findall(s) or []\n    return list(set([sanitize_url(x) for x in matches]))\n\n\ndef parse_rst(fname):\n    \"\"\"Look for links in a .rst file.\"\"\"\n    with open(fname) as f:\n        text = f.read()\n    urls = find_urls(text)\n    # HISTORY file has a lot of dead links.\n    if fname == 'HISTORY.rst' and urls:\n        urls = [\n            x\n            for x in urls\n            if not x.startswith('https://github.com/giampaolo/psutil/issues')\n        ]\n    return urls\n\n\ndef parse_py(fname):\n    \"\"\"Look for links in a .py file.\"\"\"\n    with open(fname) as f:\n        lines = f.readlines()\n    urls = set()\n    for i, line in enumerate(lines):\n        for url in find_urls(line):\n            # comment block\n            if line.lstrip().startswith('# '):\n                subidx = i + 1\n                while True:\n                    nextline = lines[subidx].strip()\n                    if re.match('^#     .+', nextline):\n                        url += nextline[1:].strip()\n                    else:\n                        break\n                    subidx += 1\n            urls.add(url)\n    return list(urls)\n\n\ndef parse_c(fname):\n    \"\"\"Look for links in a .py file.\"\"\"\n    with open(fname) as f:\n        lines = f.readlines()\n    urls = set()\n    for i, line in enumerate(lines):\n        for url in find_urls(line):\n            # comment block //\n            if line.lstrip().startswith('// '):\n                subidx = i + 1\n                while True:\n                    nextline = lines[subidx].strip()\n                    if re.match('^//     .+', nextline):\n                        url += nextline[2:].strip()\n                    else:\n                        break\n                    subidx += 1\n            # comment block /*\n            elif line.lstrip().startswith('* '):\n                subidx = i + 1\n                while True:\n                    nextline = lines[subidx].strip()\n                    if re.match(r'^\\*     .+', nextline):\n                        url += nextline[1:].strip()\n                    else:\n                        break\n                    subidx += 1\n            urls.add(url)\n    return list(urls)\n\n\ndef parse_generic(fname):\n    with open(fname, errors='ignore') as f:\n        text = f.read()\n    return find_urls(text)\n\n\ndef get_urls(fname):\n    \"\"\"Extracts all URLs in fname and return them as a list.\"\"\"\n    if fname.endswith('.rst'):\n        return parse_rst(fname)\n    elif fname.endswith('.py'):\n        return parse_py(fname)\n    elif fname.endswith(('.c', '.h')):\n        return parse_c(fname)\n    else:\n        with open(fname, errors='ignore') as f:\n            if f.readline().strip().startswith('#!/usr/bin/env python3'):\n                return parse_py(fname)\n        return parse_generic(fname)\n\n\n@memoize\ndef validate_url(url):\n    \"\"\"Validate the URL by attempting an HTTP connection.\n    Makes an HTTP-HEAD request for each URL.\n    \"\"\"\n    try:\n        res = requests.head(url, timeout=REQUEST_TIMEOUT)\n        # some websites deny 503, like Microsoft\n        # and some send 401, like Apple, observations\n        if (not res.ok) and (res.status_code in RETRY_STATUSES):\n            res = requests.get(url, timeout=REQUEST_TIMEOUT)\n        return res.ok\n    except requests.exceptions.RequestException:\n        return False\n\n\ndef parallel_validator(urls):\n    \"\"\"Validates all urls in parallel\n    urls: tuple(filename, url).\n    \"\"\"\n    fails = []  # list of tuples (filename, url)\n    current = 0\n    total = len(urls)\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        fut_to_url = {\n            executor.submit(validate_url, url[1]): url for url in urls\n        }\n        for fut in concurrent.futures.as_completed(fut_to_url):\n            current += 1\n            sys.stdout.write(\"\\r%s / %s\" % (current, total))\n            sys.stdout.flush()\n            fname, url = fut_to_url[fut]\n            try:\n                ok = fut.result()\n            except Exception:  # noqa: BLE001\n                fails.append((fname, url))\n                print()\n                print(\"warn: error while validating %s\" % url, file=sys.stderr)\n                traceback.print_exc()\n            else:\n                if not ok:\n                    fails.append((fname, url))\n\n    print()\n    return fails\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawTextHelpFormatter\n    )\n    parser.add_argument('files', nargs=\"+\")\n    parser.parse_args()\n    args = parser.parse_args()\n\n    all_urls = []\n    for fname in args.files:\n        urls = get_urls(fname)\n        if urls:\n            print(\"%4s %s\" % (len(urls), fname))\n            for url in urls:\n                all_urls.append((fname, url))\n\n    fails = parallel_validator(all_urls)\n    if not fails:\n        print(\"all links are valid; cheers!\")\n    else:\n        for fail in fails:\n            fname, url = fail\n            print(\"%-30s: %s \" % (fname, url))\n        print('-' * 20)\n        print(\"total: %s fails!\" % len(fails))\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except (KeyboardInterrupt, SystemExit):\n        os._exit(0)\n", "scripts/internal/git_pre_commit.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"This gets executed on 'git commit' and rejects the commit in case\nthe submitted code does not pass validation. Validation is run only\nagainst the files which were modified in the commit. Install this with\n\"make install-git-hooks\".\n\"\"\"\n\nfrom __future__ import print_function\n\nimport os\nimport shlex\nimport subprocess\nimport sys\n\n\nPYTHON = sys.executable\nPY3 = sys.version_info[0] >= 3\nTHIS_SCRIPT = os.path.realpath(__file__)\n\n\ndef term_supports_colors():\n    try:\n        import curses\n\n        assert sys.stderr.isatty()\n        curses.setupterm()\n        assert curses.tigetnum(\"colors\") > 0\n    except Exception:  # noqa: BLE001\n        return False\n    return True\n\n\ndef hilite(s, ok=True, bold=False):\n    \"\"\"Return an highlighted version of 'string'.\"\"\"\n    if not term_supports_colors():\n        return s\n    attr = []\n    if ok is None:  # no color\n        pass\n    elif ok:  # green\n        attr.append('32')\n    else:  # red\n        attr.append('31')\n    if bold:\n        attr.append('1')\n    return '\\x1b[%sm%s\\x1b[0m' % (';'.join(attr), s)\n\n\ndef exit(msg):\n    print(hilite(\"commit aborted: \" + msg, ok=False), file=sys.stderr)\n    sys.exit(1)\n\n\ndef sh(cmd):\n    if isinstance(cmd, str):\n        cmd = shlex.split(cmd)\n    p = subprocess.Popen(\n        cmd,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    if stderr:\n        print(stderr, file=sys.stderr)\n    if stdout.endswith('\\n'):\n        stdout = stdout[:-1]\n    return stdout\n\n\ndef open_text(path):\n    kw = {'encoding': 'utf8'} if PY3 else {}\n    return open(path, **kw)\n\n\ndef git_commit_files():\n    out = sh([\"git\", \"diff\", \"--cached\", \"--name-only\"])\n    py_files = [\n        x for x in out.split('\\n') if x.endswith('.py') and os.path.exists(x)\n    ]\n    c_files = [\n        x\n        for x in out.split('\\n')\n        if x.endswith(('.c', '.h')) and os.path.exists(x)\n    ]\n    rst_files = [\n        x for x in out.split('\\n') if x.endswith('.rst') and os.path.exists(x)\n    ]\n    toml_files = [\n        x for x in out.split(\"\\n\") if x.endswith(\".toml\") and os.path.exists(x)\n    ]\n    new_rm_mv = sh(\n        [\"git\", \"diff\", \"--name-only\", \"--diff-filter=ADR\", \"--cached\"]\n    )\n    # XXX: we should escape spaces and possibly other amenities here\n    new_rm_mv = new_rm_mv.split()\n    return (py_files, c_files, rst_files, toml_files, new_rm_mv)\n\n\ndef black(files):\n    print(\"running black (%s)\" % len(files))\n    cmd = [PYTHON, \"-m\", \"black\", \"--check\", \"--safe\"] + files\n    if subprocess.call(cmd) != 0:\n        return exit(\n            \"Python code didn't pass 'ruff' style check.\"\n            \"Try running 'make fix-ruff'.\"\n        )\n\n\ndef ruff(files):\n    print(\"running ruff (%s)\" % len(files))\n    cmd = [PYTHON, \"-m\", \"ruff\", \"check\", \"--no-cache\"] + files\n    if subprocess.call(cmd) != 0:\n        return exit(\n            \"Python code didn't pass 'ruff' style check.\"\n            \"Try running 'make fix-ruff'.\"\n        )\n\n\ndef c_linter(files):\n    print(\"running clinter (%s)\" % len(files))\n    # XXX: we should escape spaces and possibly other amenities here\n    cmd = [PYTHON, \"scripts/internal/clinter.py\"] + files\n    if subprocess.call(cmd) != 0:\n        return sys.exit(\"C code didn't pass style check\")\n\n\ndef toml_sort(files):\n    print(\"running toml linter (%s)\" % len(files))\n    cmd = [\"toml-sort\", \"--check\"] + files\n    if subprocess.call(cmd) != 0:\n        return sys.exit(\"%s didn't pass style check\" % ' '.join(files))\n\n\ndef rstcheck(files):\n    print(\"running rst linter (%s)\" % len(files))\n    cmd = [\"rstcheck\", \"--config=pyproject.toml\"] + files\n    if subprocess.call(cmd) != 0:\n        return sys.exit(\"RST code didn't pass style check\")\n\n\ndef main():\n    py_files, c_files, rst_files, toml_files, new_rm_mv = git_commit_files()\n    if py_files:\n        black(py_files)\n        ruff(py_files)\n    if c_files:\n        c_linter(c_files)\n    if rst_files:\n        rstcheck(rst_files)\n    if toml_files:\n        toml_sort(toml_files)\n    if new_rm_mv:\n        out = sh([PYTHON, \"scripts/internal/generate_manifest.py\"])\n        with open_text('MANIFEST.in') as f:\n            if out.strip() != f.read().strip():\n                sys.exit(\n                    \"some files were added, deleted or renamed; \"\n                    \"run 'make generate-manifest' and commit again\"\n                )\n\n\nmain()\n", "scripts/internal/print_hashes.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Prints files hashes, see:\nhttps://pip.pypa.io/en/stable/reference/pip_install/#hash-checking-mode.\n\"\"\"\n\nimport argparse\nimport hashlib\nimport os\n\n\ndef csum(file, kind):\n    h = hashlib.new(kind)\n    with open(file, \"rb\") as f:\n        h.update(f.read())\n        return h.hexdigest()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        'dir', type=str, help='directory containing tar.gz or wheel files'\n    )\n    args = parser.parse_args()\n    for name in sorted(os.listdir(args.dir)):\n        file = os.path.join(args.dir, name)\n        if os.path.isfile(file):\n            md5 = csum(file, \"md5\")\n            sha256 = csum(file, \"sha256\")\n            print(\n                \"%s\\nmd5: %s\\nsha256: %s\\n\"\n                % (os.path.basename(file), md5, sha256)\n            )\n        else:\n            print(\"skipping %r (not a file)\" % file)\n\n\nif __name__ == \"__main__\":\n    main()\n", "scripts/internal/convert_readme.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Remove raw HTML from README.rst to make it compatible with PyPI on\ndist upload.\n\"\"\"\n\nimport argparse\nimport re\n\n\nsummary = \"\"\"\\\nQuick links\n===========\n\n- `Home page <https://github.com/giampaolo/psutil>`_\n- `Install <https://github.com/giampaolo/psutil/blob/master/INSTALL.rst>`_\n- `Documentation <http://psutil.readthedocs.io>`_\n- `Download <https://pypi.org/project/psutil/#files>`_\n- `Forum <http://groups.google.com/group/psutil/topics>`_\n- `StackOverflow <https://stackoverflow.com/questions/tagged/psutil>`_\n- `Blog <https://gmpy.dev/tags/psutil>`_\n- `What's new <https://github.com/giampaolo/psutil/blob/master/HISTORY.rst>`_\n\"\"\"\n\nfunding = \"\"\"\\\nSponsors\n========\n\n.. image:: https://github.com/giampaolo/psutil/raw/master/docs/_static/tidelift-logo.png\n  :width: 200\n  :alt: Alternative text\n\n`Add your logo <https://github.com/sponsors/giampaolo>`__.\n\nExample usages\"\"\"  # noqa\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument('file', type=str)\n    args = parser.parse_args()\n    with open(args.file) as f:\n        data = f.read()\n    data = re.sub(r\".. raw:: html\\n+\\s+<div align[\\s\\S]*?/div>\", summary, data)\n    data = re.sub(r\"Sponsors\\n========[\\s\\S]*?Example usages\", funding, data)\n    print(data)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/generate_manifest.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Generate MANIFEST.in file.\"\"\"\n\nimport os\nimport shlex\nimport subprocess\n\n\nSKIP_EXTS = ('.png', '.jpg', '.jpeg', '.svg')\nSKIP_FILES = 'appveyor.yml'\nSKIP_PREFIXES = ('.ci/', '.github/')\n\n\ndef sh(cmd):\n    return subprocess.check_output(\n        shlex.split(cmd), universal_newlines=True\n    ).strip()\n\n\ndef main():\n    files = set()\n    for file in sh(\"git ls-files\").split('\\n'):\n        if (\n            file.startswith(SKIP_PREFIXES)\n            or os.path.splitext(file)[1].lower() in SKIP_EXTS\n            or file in SKIP_FILES\n        ):\n            continue\n        files.add(file)\n\n    for file in sorted(files):\n        print(\"include \" + file)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/purge_installation.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Purge psutil installation by removing psutil-related files and\ndirectories found in site-packages directories. This is needed mainly\nbecause sometimes \"import psutil\" imports a leftover installation\nfrom site-packages directory instead of the main working directory.\n\"\"\"\n\nimport os\nimport shutil\nimport site\n\n\nPKGNAME = \"psutil\"\n\n\ndef rmpath(path):\n    if os.path.isdir(path):\n        print(\"rmdir \" + path)\n        shutil.rmtree(path)\n    else:\n        print(\"rm \" + path)\n        os.remove(path)\n\n\ndef main():\n    locations = [site.getusersitepackages()]\n    locations += site.getsitepackages()\n    for root in locations:\n        if os.path.isdir(root):\n            for name in os.listdir(root):\n                if PKGNAME in name:\n                    abspath = os.path.join(root, name)\n                    rmpath(abspath)\n\n\nmain()\n", "scripts/internal/print_dist.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"List and pretty print tarball & wheel files in the dist/ directory.\"\"\"\n\nimport argparse\nimport collections\nimport os\n\nfrom psutil._common import bytes2human\nfrom psutil._common import print_color\n\n\nclass Wheel:\n    def __init__(self, path):\n        self._path = path\n        self._name = os.path.basename(path)\n\n    def __repr__(self):\n        return \"<%s(name=%s, plat=%s, arch=%s, pyver=%s)>\" % (\n            self.__class__.__name__,\n            self.name,\n            self.platform(),\n            self.arch(),\n            self.pyver(),\n        )\n\n    __str__ = __repr__\n\n    @property\n    def name(self):\n        return self._name\n\n    def platform(self):\n        plat = self.name.split('-')[-1]\n        pyimpl = self.name.split('-')[3]\n        ispypy = 'pypy' in pyimpl\n        if 'linux' in plat:\n            if ispypy:\n                return 'pypy_on_linux'\n            else:\n                return 'linux'\n        elif 'win' in plat:\n            if ispypy:\n                return 'pypy_on_windows'\n            else:\n                return 'windows'\n        elif 'macosx' in plat:\n            if ispypy:\n                return 'pypy_on_macos'\n            else:\n                return 'macos'\n        else:\n            raise ValueError(\"unknown platform %r\" % self.name)\n\n    def arch(self):\n        if self.name.endswith(('x86_64.whl', 'amd64.whl')):\n            return '64-bit'\n        if self.name.endswith((\"i686.whl\", \"win32.whl\")):\n            return '32-bit'\n        if self.name.endswith(\"arm64.whl\"):\n            return 'arm64'\n        if self.name.endswith(\"aarch64.whl\"):\n            return 'aarch64'\n        return '?'\n\n    def pyver(self):\n        pyver = 'pypy' if self.name.split('-')[3].startswith('pypy') else 'py'\n        pyver += self.name.split('-')[2][2:]\n        return pyver\n\n    def size(self):\n        return os.path.getsize(self._path)\n\n\nclass Tarball(Wheel):\n    def platform(self):\n        return \"source\"\n\n    def arch(self):\n        return \"-\"\n\n    def pyver(self):\n        return \"-\"\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        'dir',\n        nargs=\"?\",\n        default=\"dist\",\n        help='directory containing tar.gz or wheel files',\n    )\n    args = parser.parse_args()\n\n    groups = collections.defaultdict(list)\n    ls = sorted(os.listdir(args.dir), key=lambda x: x.endswith(\"tar.gz\"))\n    for name in ls:\n        path = os.path.join(args.dir, name)\n        if path.endswith(\".whl\"):\n            pkg = Wheel(path)\n        elif path.endswith(\".tar.gz\"):\n            pkg = Tarball(path)\n        else:\n            raise ValueError(\"invalid package %r\" % path)\n        groups[pkg.platform()].append(pkg)\n\n    tot_files = 0\n    tot_size = 0\n    templ = \"%-120s %7s %8s %7s\"\n    for platf, pkgs in groups.items():\n        ppn = \"%s (%s)\" % (platf, len(pkgs))\n        s = templ % (ppn, \"size\", \"arch\", \"pyver\")\n        print_color('\\n' + s, color=None, bold=True)\n        for pkg in sorted(pkgs, key=lambda x: x.name):\n            tot_files += 1\n            tot_size += pkg.size()\n            s = templ % (\n                \"  \" + pkg.name,\n                bytes2human(pkg.size()),\n                pkg.arch(),\n                pkg.pyver(),\n            )\n            if 'pypy' in pkg.pyver():\n                print_color(s, color='violet')\n            else:\n                print_color(s, color='brown')\n\n    print_color(\n        \"\\n\\ntotals: files=%s, size=%s\" % (tot_files, bytes2human(tot_size)),\n        bold=True,\n    )\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/winmake.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\n\"\"\"Shortcuts for various tasks, emulating UNIX \"make\" on Windows.\nThis is supposed to be invoked by \"make.bat\" and not used directly.\nThis was originally written as a bat file but they suck so much\nthat they should be deemed illegal!\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport atexit\nimport ctypes\nimport errno\nimport fnmatch\nimport os\nimport shutil\nimport site\nimport ssl\nimport subprocess\nimport sys\nimport tempfile\n\n\nAPPVEYOR = bool(os.environ.get('APPVEYOR'))\nPYTHON = sys.executable if APPVEYOR else os.getenv('PYTHON', sys.executable)\nRUNNER_PY = 'psutil\\\\tests\\\\runner.py'\nGET_PIP_URL = \"https://bootstrap.pypa.io/get-pip.py\"\nPY3 = sys.version_info[0] >= 3\nHERE = os.path.abspath(os.path.dirname(__file__))\nROOT_DIR = os.path.realpath(os.path.join(HERE, \"..\", \"..\"))\nPYPY = '__pypy__' in sys.builtin_module_names\nDEPS = [\n    \"coverage\",\n    \"pdbpp\",\n    \"pip\",\n    \"pyperf\",\n    \"pyreadline\",\n    \"requests\",\n    \"setuptools\",\n    \"wheel\",\n]\n\nif sys.version_info[0] < 3:\n    DEPS.append('mock')\n    DEPS.append('ipaddress')\n    DEPS.append('enum34')\n\nif not PYPY:\n    DEPS.append(\"pywin32\")\n    DEPS.append(\"wmi\")\n\n_cmds = {}\nif PY3:\n    basestring = str\n\nGREEN = 2\nLIGHTBLUE = 3\nYELLOW = 6\nRED = 4\nDEFAULT_COLOR = 7\n\n\n# ===================================================================\n# utils\n# ===================================================================\n\n\ndef safe_print(text, file=sys.stdout):\n    \"\"\"Prints a (unicode) string to the console, encoded depending on\n    the stdout/file encoding (eg. cp437 on Windows). This is to avoid\n    encoding errors in case of funky path names.\n    Works with Python 2 and 3.\n    \"\"\"\n    if not isinstance(text, basestring):\n        return print(text, file=file)\n    try:\n        file.write(text)\n    except UnicodeEncodeError:\n        bytes_string = text.encode(file.encoding, 'backslashreplace')\n        if hasattr(file, 'buffer'):\n            file.buffer.write(bytes_string)\n        else:\n            text = bytes_string.decode(file.encoding, 'strict')\n            file.write(text)\n    file.write(\"\\n\")\n\n\ndef stderr_handle():\n    GetStdHandle = ctypes.windll.Kernel32.GetStdHandle\n    STD_ERROR_HANDLE_ID = ctypes.c_ulong(0xFFFFFFF4)\n    GetStdHandle.restype = ctypes.c_ulong\n    handle = GetStdHandle(STD_ERROR_HANDLE_ID)\n    atexit.register(ctypes.windll.Kernel32.CloseHandle, handle)\n    return handle\n\n\ndef win_colorprint(s, color=LIGHTBLUE):\n    color += 8  # bold\n    handle = stderr_handle()\n    SetConsoleTextAttribute = ctypes.windll.Kernel32.SetConsoleTextAttribute\n    SetConsoleTextAttribute(handle, color)\n    try:\n        print(s)\n    finally:\n        SetConsoleTextAttribute(handle, DEFAULT_COLOR)\n\n\ndef sh(cmd, nolog=False):\n    if not nolog:\n        safe_print(\"cmd: \" + cmd)\n    p = subprocess.Popen(\n        cmd, shell=True, env=os.environ, cwd=os.getcwd()  # noqa\n    )\n    p.communicate()\n    if p.returncode != 0:\n        sys.exit(p.returncode)\n\n\ndef rm(pattern, directory=False):\n    \"\"\"Recursively remove a file or dir by pattern.\"\"\"\n\n    def safe_remove(path):\n        try:\n            os.remove(path)\n        except OSError as err:\n            if err.errno != errno.ENOENT:\n                raise\n        else:\n            safe_print(\"rm %s\" % path)\n\n    def safe_rmtree(path):\n        def onerror(fun, path, excinfo):\n            exc = excinfo[1]\n            if exc.errno != errno.ENOENT:\n                raise  # noqa: PLE0704\n\n        existed = os.path.isdir(path)\n        shutil.rmtree(path, onerror=onerror)\n        if existed:\n            safe_print(\"rmdir -f %s\" % path)\n\n    if \"*\" not in pattern:\n        if directory:\n            safe_rmtree(pattern)\n        else:\n            safe_remove(pattern)\n        return\n\n    for root, dirs, files in os.walk('.'):\n        root = os.path.normpath(root)\n        if root.startswith('.git/'):\n            continue\n        found = fnmatch.filter(dirs if directory else files, pattern)\n        for name in found:\n            path = os.path.join(root, name)\n            if directory:\n                safe_print(\"rmdir -f %s\" % path)\n                safe_rmtree(path)\n            else:\n                safe_print(\"rm %s\" % path)\n                safe_remove(path)\n\n\ndef safe_remove(path):\n    try:\n        os.remove(path)\n    except OSError as err:\n        if err.errno != errno.ENOENT:\n            raise\n    else:\n        safe_print(\"rm %s\" % path)\n\n\ndef safe_rmtree(path):\n    def onerror(fun, path, excinfo):\n        exc = excinfo[1]\n        if exc.errno != errno.ENOENT:\n            raise  # noqa: PLE0704\n\n    existed = os.path.isdir(path)\n    shutil.rmtree(path, onerror=onerror)\n    if existed:\n        safe_print(\"rmdir -f %s\" % path)\n\n\ndef recursive_rm(*patterns):\n    \"\"\"Recursively remove a file or matching a list of patterns.\"\"\"\n    for root, dirs, files in os.walk('.'):\n        root = os.path.normpath(root)\n        if root.startswith('.git/'):\n            continue\n        for file in files:\n            for pattern in patterns:\n                if fnmatch.fnmatch(file, pattern):\n                    safe_remove(os.path.join(root, file))\n        for dir in dirs:\n            for pattern in patterns:\n                if fnmatch.fnmatch(dir, pattern):\n                    safe_rmtree(os.path.join(root, dir))\n\n\n# ===================================================================\n# commands\n# ===================================================================\n\n\ndef build():\n    \"\"\"Build / compile.\"\"\"\n    # Make sure setuptools is installed (needed for 'develop' /\n    # edit mode).\n    sh('%s -c \"import setuptools\"' % PYTHON)\n\n    # \"build_ext -i\" copies compiled *.pyd files in ./psutil directory in\n    # order to allow \"import psutil\" when using the interactive interpreter\n    # from within psutil root directory.\n    cmd = [PYTHON, \"setup.py\", \"build_ext\", \"-i\"]\n    if sys.version_info[:2] >= (3, 6) and (os.cpu_count() or 1) > 1:\n        cmd += ['--parallel', str(os.cpu_count())]\n    # Print coloured warnings in real time.\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    try:\n        for line in iter(p.stdout.readline, b''):\n            if PY3:\n                line = line.decode()\n            line = line.strip()\n            if 'warning' in line:\n                win_colorprint(line, YELLOW)\n            elif 'error' in line:\n                win_colorprint(line, RED)\n            else:\n                print(line)\n        # retcode = p.poll()\n        p.communicate()\n        if p.returncode:\n            win_colorprint(\"failure\", RED)\n            sys.exit(p.returncode)\n    finally:\n        p.terminate()\n        p.wait()\n\n    # Make sure it actually worked.\n    sh('%s -c \"import psutil\"' % PYTHON)\n    win_colorprint(\"build + import successful\", GREEN)\n\n\ndef wheel():\n    \"\"\"Create wheel file.\"\"\"\n    build()\n    sh(\"%s setup.py bdist_wheel\" % PYTHON)\n\n\ndef upload_wheels():\n    \"\"\"Upload wheel files on PyPI.\"\"\"\n    build()\n    sh(\"%s -m twine upload dist/*.whl\" % PYTHON)\n\n\ndef install_pip():\n    \"\"\"Install pip.\"\"\"\n    try:\n        sh('%s -c \"import pip\"' % PYTHON)\n    except SystemExit:\n        if PY3:\n            from urllib.request import urlopen\n        else:\n            from urllib2 import urlopen\n\n        if hasattr(ssl, '_create_unverified_context'):\n            ctx = ssl._create_unverified_context()\n        else:\n            ctx = None\n        kw = dict(context=ctx) if ctx else {}\n        safe_print(\"downloading %s\" % GET_PIP_URL)\n        req = urlopen(GET_PIP_URL, **kw)\n        data = req.read()\n\n        tfile = os.path.join(tempfile.gettempdir(), 'get-pip.py')\n        with open(tfile, 'wb') as f:\n            f.write(data)\n\n        try:\n            sh('%s %s --user' % (PYTHON, tfile))\n        finally:\n            os.remove(tfile)\n\n\ndef install():\n    \"\"\"Install in develop / edit mode.\"\"\"\n    build()\n    sh(\"%s setup.py develop\" % PYTHON)\n\n\ndef uninstall():\n    \"\"\"Uninstall psutil.\"\"\"\n    # Uninstalling psutil on Windows seems to be tricky.\n    # On \"import psutil\" tests may import a psutil version living in\n    # C:\\PythonXY\\Lib\\site-packages which is not what we want, so\n    # we try both \"pip uninstall psutil\" and manually remove stuff\n    # from site-packages.\n    clean()\n    install_pip()\n    here = os.getcwd()\n    try:\n        os.chdir('C:\\\\')\n        while True:\n            try:\n                import psutil  # NOQA\n            except ImportError:\n                break\n            else:\n                sh(\"%s -m pip uninstall -y psutil\" % PYTHON)\n    finally:\n        os.chdir(here)\n\n    for dir in site.getsitepackages():\n        for name in os.listdir(dir):\n            if name.startswith('psutil'):\n                rm(os.path.join(dir, name))\n            elif name == 'easy-install.pth':\n                # easy_install can add a line (installation path) into\n                # easy-install.pth; that line alters sys.path.\n                path = os.path.join(dir, name)\n                with open(path) as f:\n                    lines = f.readlines()\n                    hasit = False\n                    for line in lines:\n                        if 'psutil' in line:\n                            hasit = True\n                            break\n                if hasit:\n                    with open(path, \"w\") as f:\n                        for line in lines:\n                            if 'psutil' not in line:\n                                f.write(line)\n                            else:\n                                print(\"removed line %r from %r\" % (line, path))\n\n\ndef clean():\n    \"\"\"Deletes dev files.\"\"\"\n    recursive_rm(\n        \"$testfn*\",\n        \"*.bak\",\n        \"*.core\",\n        \"*.egg-info\",\n        \"*.orig\",\n        \"*.pyc\",\n        \"*.pyd\",\n        \"*.pyo\",\n        \"*.rej\",\n        \"*.so\",\n        \"*.~\",\n        \"*__pycache__\",\n        \".coverage\",\n        \".failed-tests.txt\",\n    )\n    safe_rmtree(\"build\")\n    safe_rmtree(\".coverage\")\n    safe_rmtree(\"dist\")\n    safe_rmtree(\"docs/_build\")\n    safe_rmtree(\"htmlcov\")\n    safe_rmtree(\"tmp\")\n\n\ndef setup_dev_env():\n    \"\"\"Install useful deps.\"\"\"\n    install_pip()\n    install_git_hooks()\n    sh(\"%s -m pip install -U %s\" % (PYTHON, \" \".join(DEPS)))\n\n\ndef test(name=RUNNER_PY):\n    \"\"\"Run tests.\"\"\"\n    build()\n    sh(\"%s %s\" % (PYTHON, name))\n\n\ndef coverage():\n    \"\"\"Run coverage tests.\"\"\"\n    # Note: coverage options are controlled by .coveragerc file\n    build()\n    sh(\"%s -m coverage run %s\" % (PYTHON, RUNNER_PY))\n    sh(\"%s -m coverage report\" % PYTHON)\n    sh(\"%s -m coverage html\" % PYTHON)\n    sh(\"%s -m webbrowser -t htmlcov/index.html\" % PYTHON)\n\n\ndef test_process():\n    \"\"\"Run process tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_process.py\" % PYTHON)\n\n\ndef test_process_all():\n    \"\"\"Run process all tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_process_all.py\" % PYTHON)\n\n\ndef test_system():\n    \"\"\"Run system tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_system.py\" % PYTHON)\n\n\ndef test_platform():\n    \"\"\"Run windows only tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_windows.py\" % PYTHON)\n\n\ndef test_misc():\n    \"\"\"Run misc tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_misc.py\" % PYTHON)\n\n\ndef test_unicode():\n    \"\"\"Run unicode tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_unicode.py\" % PYTHON)\n\n\ndef test_connections():\n    \"\"\"Run connections tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_connections.py\" % PYTHON)\n\n\ndef test_contracts():\n    \"\"\"Run contracts tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_contracts.py\" % PYTHON)\n\n\ndef test_testutils():\n    \"\"\"Run test utilities tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_testutils.py\" % PYTHON)\n\n\ndef test_by_name(name):\n    \"\"\"Run test by name.\"\"\"\n    build()\n    sh(\"%s -m unittest -v %s\" % (PYTHON, name))\n\n\ndef test_last_failed():\n    \"\"\"Re-run tests which failed on last run.\"\"\"\n    build()\n    sh(\"%s %s --last-failed\" % (PYTHON, RUNNER_PY))\n\n\ndef test_memleaks():\n    \"\"\"Run memory leaks tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_memleaks.py\" % PYTHON)\n\n\ndef install_git_hooks():\n    \"\"\"Install GIT pre-commit hook.\"\"\"\n    if os.path.isdir('.git'):\n        src = os.path.join(\n            ROOT_DIR, \"scripts\", \"internal\", \"git_pre_commit.py\"\n        )\n        dst = os.path.realpath(\n            os.path.join(ROOT_DIR, \".git\", \"hooks\", \"pre-commit\")\n        )\n        with open(src) as s:\n            with open(dst, \"w\") as d:\n                d.write(s.read())\n\n\ndef bench_oneshot():\n    \"\"\"Benchmarks for oneshot() ctx manager (see #799).\"\"\"\n    sh(\"%s -Wa scripts\\\\internal\\\\bench_oneshot.py\" % PYTHON)\n\n\ndef bench_oneshot_2():\n    \"\"\"Same as above but using perf module (supposed to be more precise).\"\"\"\n    sh(\"%s -Wa scripts\\\\internal\\\\bench_oneshot_2.py\" % PYTHON)\n\n\ndef print_access_denied():\n    \"\"\"Print AD exceptions raised by all Process methods.\"\"\"\n    build()\n    sh(\"%s -Wa scripts\\\\internal\\\\print_access_denied.py\" % PYTHON)\n\n\ndef print_api_speed():\n    \"\"\"Benchmark all API calls.\"\"\"\n    build()\n    sh(\"%s -Wa scripts\\\\internal\\\\print_api_speed.py\" % PYTHON)\n\n\ndef download_appveyor_wheels():\n    \"\"\"Download appveyor wheels.\"\"\"\n    sh(\n        \"%s -Wa scripts\\\\internal\\\\download_wheels_appveyor.py \"\n        \"--user giampaolo --project psutil\" % PYTHON\n    )\n\n\ndef generate_manifest():\n    \"\"\"Generate MANIFEST.in file.\"\"\"\n    script = \"scripts\\\\internal\\\\generate_manifest.py\"\n    out = subprocess.check_output([PYTHON, script], text=True)\n    with open(\"MANIFEST.in\", \"w\", newline=\"\\n\") as f:\n        f.write(out)\n\n\ndef get_python(path):\n    if not path:\n        return sys.executable\n    if os.path.isabs(path):\n        return path\n    # try to look for a python installation given a shortcut name\n    path = path.replace('.', '')\n    vers = (\n        '27',\n        '27-32',\n        '27-64',\n        '310-32',\n        '310-64',\n        '311-32',\n        '311-64',\n        '312-32',\n        '312-64',\n    )\n    for v in vers:\n        pypath = r'C:\\\\python%s\\python.exe' % v\n        if path in pypath and os.path.isfile(pypath):\n            return pypath\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    # option shared by all commands\n    parser.add_argument('-p', '--python', help=\"use python executable path\")\n    sp = parser.add_subparsers(dest='command', title='targets')\n    sp.add_parser('bench-oneshot', help=\"benchmarks for oneshot()\")\n    sp.add_parser('bench-oneshot_2', help=\"benchmarks for oneshot() (perf)\")\n    sp.add_parser('build', help=\"build\")\n    sp.add_parser('clean', help=\"deletes dev files\")\n    sp.add_parser('coverage', help=\"run coverage tests.\")\n    sp.add_parser('download-appveyor-wheels', help=\"download wheels.\")\n    sp.add_parser('generate-manifest', help=\"generate MANIFEST.in file\")\n    sp.add_parser('help', help=\"print this help\")\n    sp.add_parser('install', help=\"build + install in develop/edit mode\")\n    sp.add_parser('install-git-hooks', help=\"install GIT pre-commit hook\")\n    sp.add_parser('install-pip', help=\"install pip\")\n    sp.add_parser('print-access-denied', help=\"print AD exceptions\")\n    sp.add_parser('print-api-speed', help=\"benchmark all API calls\")\n    sp.add_parser('setup-dev-env', help=\"install deps\")\n    test = sp.add_parser('test', help=\"[ARG] run tests\")\n    test_by_name = sp.add_parser('test-by-name', help=\"<ARG> run test by name\")\n    sp.add_parser('test-connections', help=\"run connections tests\")\n    sp.add_parser('test-contracts', help=\"run contracts tests\")\n    sp.add_parser(\n        'test-last-failed', help=\"re-run tests which failed on last run\"\n    )\n    sp.add_parser('test-memleaks', help=\"run memory leaks tests\")\n    sp.add_parser('test-misc', help=\"run misc tests\")\n    sp.add_parser('test-platform', help=\"run windows only tests\")\n    sp.add_parser('test-process', help=\"run process tests\")\n    sp.add_parser('test-process-all', help=\"run process all tests\")\n    sp.add_parser('test-system', help=\"run system tests\")\n    sp.add_parser('test-unicode', help=\"run unicode tests\")\n    sp.add_parser('test-testutils', help=\"run test utils tests\")\n    sp.add_parser('uninstall', help=\"uninstall psutil\")\n    sp.add_parser('upload-wheels', help=\"upload wheel files on PyPI\")\n    sp.add_parser('wheel', help=\"create wheel file\")\n\n    for p in (test, test_by_name):\n        p.add_argument('arg', type=str, nargs='?', default=\"\", help=\"arg\")\n\n    args = parser.parse_args()\n\n    if not args.command or args.command == 'help':\n        parser.print_help(sys.stderr)\n        sys.exit(1)\n\n    return args\n\n\ndef main():\n    global PYTHON\n    args = parse_args()\n    # set python exe\n    PYTHON = get_python(args.python)\n    if not PYTHON:\n        return sys.exit(\n            \"can't find any python installation matching %r\" % args.python\n        )\n    os.putenv('PYTHON', PYTHON)\n    win_colorprint(\"using \" + PYTHON)\n\n    fname = args.command.replace('-', '_')\n    fun = getattr(sys.modules[__name__], fname)  # err if fun not defined\n    funargs = []\n    # mandatory args\n    if args.command in ('test-by-name', 'test-script'):\n        if not args.arg:\n            sys.exit('command needs an argument')\n        funargs = [args.arg]\n    # optional args\n    if args.command == 'test' and args.arg:\n        funargs = [args.arg]\n    fun(*funargs)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_timeline.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Prints releases' timeline in RST format.\"\"\"\n\nimport shlex\nimport subprocess\n\n\nentry = \"\"\"\\\n- {date}:\n  `{ver} <https://pypi.org/project/psutil/{ver}/#files>`__ -\n  `what's new <https://github.com/giampaolo/psutil/blob/master/HISTORY.rst#{nodotver}>`__ -\n  `diff <https://github.com/giampaolo/psutil/compare/{prevtag}...{tag}#files_bucket>`__\"\"\"  # NOQA\n\n\ndef sh(cmd):\n    return subprocess.check_output(\n        shlex.split(cmd), universal_newlines=True\n    ).strip()\n\n\ndef get_tag_date(tag):\n    out = sh(r\"git log -1 --format=%ai {}\".format(tag))\n    return out.split(' ')[0]\n\n\ndef main():\n    releases = []\n    out = sh(\"git tag\")\n    for line in out.split('\\n'):\n        tag = line.split(' ')[0]\n        ver = tag.replace('release-', '')\n        nodotver = ver.replace('.', '')\n        date = get_tag_date(tag)\n        releases.append((tag, ver, nodotver, date))\n    releases.sort(reverse=True)\n\n    for i, rel in enumerate(releases):\n        tag, ver, nodotver, date = rel\n        try:\n            prevtag = releases[i + 1][0]\n        except IndexError:\n            # get first commit\n            prevtag = sh(\"git rev-list --max-parents=0 HEAD\")\n        print(entry.format(**locals()))\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_access_denied.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Helper script iterates over all processes and .\nIt prints how many AccessDenied exceptions are raised in total and\nfor what Process method.\n\n$ make print-access-denied\nAPI                  AD    Percent   Outcome\nmemory_info          0        0.0%   SUCCESS\nuids                 0        0.0%   SUCCESS\ncmdline              0        0.0%   SUCCESS\ncreate_time          0        0.0%   SUCCESS\nstatus               0        0.0%   SUCCESS\nnum_ctx_switches     0        0.0%   SUCCESS\nusername             0        0.0%   SUCCESS\nionice               0        0.0%   SUCCESS\nmemory_percent       0        0.0%   SUCCESS\ngids                 0        0.0%   SUCCESS\ncpu_times            0        0.0%   SUCCESS\nnice                 0        0.0%   SUCCESS\npid                  0        0.0%   SUCCESS\ncpu_percent          0        0.0%   SUCCESS\nnum_threads          0        0.0%   SUCCESS\ncpu_num              0        0.0%   SUCCESS\nppid                 0        0.0%   SUCCESS\nterminal             0        0.0%   SUCCESS\nname                 0        0.0%   SUCCESS\nthreads              0        0.0%   SUCCESS\ncpu_affinity         0        0.0%   SUCCESS\nmemory_maps          71      21.3%   ACCESS DENIED\nmemory_full_info     71      21.3%   ACCESS DENIED\nexe                  174     52.1%   ACCESS DENIED\nenviron              238     71.3%   ACCESS DENIED\nnum_fds              238     71.3%   ACCESS DENIED\nio_counters          238     71.3%   ACCESS DENIED\ncwd                  238     71.3%   ACCESS DENIED\nconnections          238     71.3%   ACCESS DENIED\nopen_files           238     71.3%   ACCESS DENIED\n--------------------------------------------------\nTotals: access-denied=1744, calls=10020, processes=334\n\"\"\"\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport time\nfrom collections import defaultdict\n\nimport psutil\nfrom psutil._common import print_color\n\n\ndef main():\n    # collect\n    tot_procs = 0\n    tot_ads = 0\n    tot_calls = 0\n    signaler = object()\n    d = defaultdict(int)\n    start = time.time()\n    for p in psutil.process_iter(attrs=[], ad_value=signaler):\n        tot_procs += 1\n        for methname, value in p.info.items():\n            tot_calls += 1\n            if value is signaler:\n                tot_ads += 1\n                d[methname] += 1\n            else:\n                d[methname] += 0\n    elapsed = time.time() - start\n\n    # print\n    templ = \"%-20s %-5s %-9s %s\"\n    s = templ % (\"API\", \"AD\", \"Percent\", \"Outcome\")\n    print_color(s, color=None, bold=True)\n    for methname, ads in sorted(d.items(), key=lambda x: (x[1], x[0])):\n        perc = (ads / tot_procs) * 100\n        outcome = \"SUCCESS\" if not ads else \"ACCESS DENIED\"\n        s = templ % (methname, ads, \"%6.1f%%\" % perc, outcome)\n        print_color(s, \"red\" if ads else None)\n    tot_perc = round((tot_ads / tot_calls) * 100, 1)\n    print(\"-\" * 50)\n    print(\n        \"Totals: access-denied=%s (%s%%), calls=%s, processes=%s, elapsed=%ss\"\n        % (tot_ads, tot_perc, tot_calls, tot_procs, round(elapsed, 2))\n    )\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_announce.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Prints release announce based on HISTORY.rst file content.\nSee: https://pip.pypa.io/en/stable/reference/pip_install/#hash-checking-mode.\n\n\"\"\"\n\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom psutil import __version__\n\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nROOT = os.path.realpath(os.path.join(HERE, '..', '..'))\nHISTORY = os.path.join(ROOT, 'HISTORY.rst')\nPRINT_HASHES_SCRIPT = os.path.join(\n    ROOT, 'scripts', 'internal', 'print_hashes.py'\n)\n\nPRJ_NAME = 'psutil'\nPRJ_VERSION = __version__\nPRJ_URL_HOME = 'https://github.com/giampaolo/psutil'\nPRJ_URL_DOC = 'http://psutil.readthedocs.io'\nPRJ_URL_DOWNLOAD = 'https://pypi.org/project/psutil/#files'\nPRJ_URL_WHATSNEW = (\n    'https://github.com/giampaolo/psutil/blob/master/HISTORY.rst'\n)\n\ntemplate = \"\"\"\\\nHello all,\nI'm glad to announce the release of {prj_name} {prj_version}:\n{prj_urlhome}\n\nAbout\n=====\n\npsutil (process and system utilities) is a cross-platform library for \\\nretrieving information on running processes and system utilization (CPU, \\\nmemory, disks, network) in Python. It is useful mainly for system \\\nmonitoring, profiling and limiting process resources and management of \\\nrunning processes. It implements many functionalities offered by command \\\nline tools such as: ps, top, lsof, netstat, ifconfig, who, df, kill, free, \\\nnice, ionice, iostat, iotop, uptime, pidof, tty, taskset, pmap. It \\\ncurrently supports Linux, Windows, macOS, Sun Solaris, FreeBSD, OpenBSD, \\\nNetBSD and AIX.  Supported Python versions are 2.7 and 3.6+. PyPy is also \\\nknown to work.\n\nWhat's new\n==========\n\n{changes}\n\nLinks\n=====\n\n- Home page: {prj_urlhome}\n- Download: {prj_urldownload}\n- Documentation: {prj_urldoc}\n- What's new: {prj_urlwhatsnew}\n\nHashes\n======\n\n{hashes}\n\n--\n\nGiampaolo - https://gmpy.dev/about\n\"\"\"\n\n\ndef get_changes():\n    \"\"\"Get the most recent changes for this release by parsing\n    HISTORY.rst file.\n    \"\"\"\n    with open(HISTORY) as f:\n        lines = f.readlines()\n\n    block = []\n\n    # eliminate the part preceding the first block\n    while lines:\n        line = lines.pop(0)\n        if line.startswith('===='):\n            break\n    else:\n        raise ValueError(\"something wrong\")\n\n    lines.pop(0)\n    while lines:\n        line = lines.pop(0)\n        line = line.rstrip()\n        if re.match(r\"^- \\d+_\", line):\n            line = re.sub(r\"^- (\\d+)_\", r\"- #\\1\", line)\n\n        if line.startswith('===='):\n            break\n        block.append(line)\n    else:\n        raise ValueError(\"something wrong\")\n\n    # eliminate bottom empty lines\n    block.pop(-1)\n    while not block[-1]:\n        block.pop(-1)\n\n    return \"\\n\".join(block)\n\n\ndef main():\n    changes = get_changes()\n    hashes = (\n        subprocess.check_output([sys.executable, PRINT_HASHES_SCRIPT, 'dist/'])\n        .strip()\n        .decode()\n    )\n    text = template.format(\n        prj_name=PRJ_NAME,\n        prj_version=PRJ_VERSION,\n        prj_urlhome=PRJ_URL_HOME,\n        prj_urldownload=PRJ_URL_DOWNLOAD,\n        prj_urldoc=PRJ_URL_DOC,\n        prj_urlwhatsnew=PRJ_URL_WHATSNEW,\n        changes=changes,\n        hashes=hashes,\n    )\n    print(text)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_downloads.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Print PYPI statistics in MarkDown format.\nUseful sites:\n* https://pepy.tech/project/psutil\n* https://pypistats.org/packages/psutil\n* https://hugovk.github.io/top-pypi-packages/.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport json\nimport os\nimport shlex\nimport subprocess\nimport sys\n\nimport pypinfo  # NOQA\n\nfrom psutil._common import memoize\n\n\nAUTH_FILE = os.path.expanduser(\"~/.pypinfo.json\")\nPKGNAME = 'psutil'\nDAYS = 30\nLIMIT = 100\nGITHUB_SCRIPT_URL = (\n    \"https://github.com/giampaolo/psutil/blob/master/\"\n    \"scripts/internal/pypistats.py\"\n)\nLAST_UPDATE = None\nbytes_billed = 0\n\n\n# --- get\n\n\n@memoize\ndef sh(cmd):\n    assert os.path.exists(AUTH_FILE)\n    env = os.environ.copy()\n    env['GOOGLE_APPLICATION_CREDENTIALS'] = AUTH_FILE\n    p = subprocess.Popen(\n        shlex.split(cmd),\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n        env=env,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    assert not stderr, stderr\n    return stdout.strip()\n\n\n@memoize\ndef query(cmd):\n    global bytes_billed\n    ret = json.loads(sh(cmd))\n    bytes_billed += ret['query']['bytes_billed']\n    return ret\n\n\ndef top_packages():\n    global LAST_UPDATE\n    ret = query(\n        \"pypinfo --all --json --days %s --limit %s '' project\" % (DAYS, LIMIT)\n    )\n    LAST_UPDATE = ret['last_update']\n    return [(x['project'], x['download_count']) for x in ret['rows']]\n\n\ndef ranking():\n    data = top_packages()\n    i = 1\n    for name, downloads in data:\n        if name == PKGNAME:\n            return i\n        i += 1\n    raise ValueError(\"can't find %s\" % PKGNAME)\n\n\ndef downloads():\n    data = top_packages()\n    for name, downloads in data:\n        if name == PKGNAME:\n            return downloads\n    raise ValueError(\"can't find %s\" % PKGNAME)\n\n\ndef downloads_pyver():\n    return query(\"pypinfo --json --days %s %s pyversion\" % (DAYS, PKGNAME))\n\n\ndef downloads_by_country():\n    return query(\"pypinfo --json --days %s %s country\" % (DAYS, PKGNAME))\n\n\ndef downloads_by_system():\n    return query(\"pypinfo --json --days %s %s system\" % (DAYS, PKGNAME))\n\n\ndef downloads_by_distro():\n    return query(\"pypinfo --json --days %s %s distro\" % (DAYS, PKGNAME))\n\n\n# --- print\n\n\ntempl = \"| %-30s | %15s |\"\n\n\ndef print_row(left, right):\n    if isinstance(right, int):\n        right = '{:,}'.format(right)\n    print(templ % (left, right))\n\n\ndef print_header(left, right=\"Downloads\"):\n    print_row(left, right)\n    s = templ % (\"-\" * 30, \"-\" * 15)\n    print(\"|:\" + s[2:-2] + \":|\")\n\n\ndef print_markdown_table(title, left, rows):\n    pleft = left.replace('_', ' ').capitalize()\n    print(\"### \" + title)\n    print()\n    print_header(pleft)\n    for row in rows:\n        lval = row[left]\n        print_row(lval, row['download_count'])\n    print()\n\n\ndef main():\n    downs = downloads()\n\n    print(\"# Download stats\")\n    print()\n    s = \"psutil download statistics of the last %s days (last update \" % DAYS\n    s += \"*%s*).\\n\" % LAST_UPDATE\n    s += \"Generated via [pypistats.py](%s) script.\\n\" % GITHUB_SCRIPT_URL\n    print(s)\n\n    data = [\n        {'what': 'Per month', 'download_count': downs},\n        {'what': 'Per day', 'download_count': int(downs / 30)},\n        {'what': 'PYPI ranking', 'download_count': ranking()},\n    ]\n    print_markdown_table('Overview', 'what', data)\n    print_markdown_table(\n        'Operating systems', 'system_name', downloads_by_system()['rows']\n    )\n    print_markdown_table(\n        'Distros', 'distro_name', downloads_by_distro()['rows']\n    )\n    print_markdown_table(\n        'Python versions', 'python_version', downloads_pyver()['rows']\n    )\n    print_markdown_table(\n        'Countries', 'country', downloads_by_country()['rows']\n    )\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    finally:\n        print(\"bytes billed: %s\" % bytes_billed, file=sys.stderr)\n", "scripts/internal/bench_oneshot_2.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Same as bench_oneshot.py but uses perf module instead, which is\nsupposed to be more precise.\n\"\"\"\n\nimport sys\n\nimport pyperf  # requires \"pip install pyperf\"\nfrom bench_oneshot import names\n\nimport psutil\n\n\np = psutil.Process()\nfuns = [getattr(p, n) for n in names]\n\n\ndef call_normal():\n    for fun in funs:\n        fun()\n\n\ndef call_oneshot():\n    with p.oneshot():\n        for fun in funs:\n            fun()\n\n\ndef add_cmdline_args(cmd, args):\n    cmd.append(args.benchmark)\n\n\ndef main():\n    runner = pyperf.Runner()\n\n    args = runner.parse_args()\n    if not args.worker:\n        print(\n            \"%s methods involved on platform %r (psutil %s):\"\n            % (len(names), sys.platform, psutil.__version__)\n        )\n        for name in sorted(names):\n            print(\"    \" + name)\n\n    runner.bench_func(\"normal\", call_normal)\n    runner.bench_func(\"oneshot\", call_oneshot)\n\n\nmain()\n", "docs/conf.py": "# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n# psutil documentation build configuration file, created by\n# sphinx-quickstart on Wed Oct 19 21:54:30 2016.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration ------------------------------------------------\n\nimport ast\nimport datetime\nimport os\n\n\nPROJECT_NAME = \"psutil\"\nAUTHOR = \"Giampaolo Rodola\"\nTHIS_YEAR = str(datetime.datetime.now().year)\nHERE = os.path.abspath(os.path.dirname(__file__))\n\n\ndef get_version():\n    INIT = os.path.abspath(os.path.join(HERE, '../psutil/__init__.py'))\n    with open(INIT) as f:\n        for line in f:\n            if line.startswith('__version__'):\n                ret = ast.literal_eval(line.strip().split(' = ')[1])\n                assert ret.count('.') == 2, ret\n                for num in ret.split('.'):\n                    assert num.isdigit(), ret\n                return ret\n        msg = \"couldn't find version string\"\n        raise ValueError(msg)\n\n\nVERSION = get_version()\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.coverage',\n    'sphinx.ext.imgmath',\n    'sphinx.ext.viewcode',\n    'sphinx.ext.intersphinx',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = PROJECT_NAME\ncopyright = '2009-%s, %s' % (THIS_YEAR, AUTHOR)\nauthor = AUTHOR\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = VERSION\n# The full version, including alpha/beta/rc tags.\nrelease = VERSION\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = \"eng\"\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#\n# today = ''\n#\n# Else, today_fmt is used as the format for a strftime call.\n#\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = ['_build', 'Thumbs.db', '.DS_Store', 'DEVGUIDE.rst']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = 'sphinx_rtd_theme'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.\n# \"<project> v<release> documentation\" by default.\n#\n# html_title = u'psutil v1.0'\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#\n# html_logo = None\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or\n# 32x32 pixels large.\n\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#\n# html_extra_path = []\n\n# If not None, a 'Last updated on:' timestamp is inserted at every page\n# bottom, using the given strftime format.\n# The empty string is equivalent to '%b %d, %Y'.\n#\n# html_last_updated_fmt = None\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n#\n# html_domain_indices = True\n\n# If false, no index is generated.\n#\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr', 'zh'\n#\n# html_search_language = 'en'\n\n# A dictionary with options for the search language support, empty by default.\n# 'ja' uses this config value.\n# 'zh' user can custom change `jieba` dictionary path.\n#\n# html_search_options = {'type': 'default'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#\n# html_search_scorer = 'scorer.js'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = '%s-doc' % PROJECT_NAME\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',\n    # Latex figure (float) alignment\n    #\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, 'psutil.tex', 'psutil Documentation', AUTHOR, 'manual')\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n#\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#\n# latex_appendices = []\n\n# It false, will not define \\strong, \\code,     itleref, \\crossref ... but only\n# \\sphinxstrong, ..., \\sphinxtitleref, ... To help avoid clash with user added\n# packages.\n#\n# latex_keep_old_macro_names = True\n\n# If false, no module index is generated.\n#\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, 'psutil', 'psutil Documentation', [author], 1)]\n\n# If true, show URL addresses after external links.\n#\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [(\n    master_doc,\n    'psutil',\n    'psutil Documentation',\n    author,\n    'psutil',\n    'One line description of project.',\n    'Miscellaneous',\n)]\n\n# Documents to append as an appendix to all manuals.\n#\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n#\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#\n# texinfo_no_detailmenu = False\n\n\nhtml_context = {\n    'css_files': [\n        'https://media.readthedocs.org/css/sphinx_rtd_theme.css',\n        'https://media.readthedocs.org/css/readthedocs-doc-embed.css',\n        '_static/css/custom.css',\n    ]\n}\n"}