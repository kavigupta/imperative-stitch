{"setup.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Cross-platform lib for process and system monitoring in Python.\"\"\"\n\nfrom __future__ import print_function\n\nimport ast\nimport contextlib\nimport glob\nimport io\nimport os\nimport platform\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport sysconfig\nimport tempfile\nimport warnings\n\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\")\n    try:\n        import setuptools\n        from setuptools import Extension\n        from setuptools import setup\n    except ImportError:\n        setuptools = None\n        from distutils.core import Extension\n        from distutils.core import setup\n    try:\n        from wheel.bdist_wheel import bdist_wheel\n    except ImportError:\n        if \"CIBUILDWHEEL\" in os.environ:\n            raise\n        bdist_wheel = None\n\nHERE = os.path.abspath(os.path.dirname(__file__))\n\n# ...so we can import _common.py and _compat.py\nsys.path.insert(0, os.path.join(HERE, \"psutil\"))\n\nfrom _common import AIX  # NOQA\nfrom _common import BSD  # NOQA\nfrom _common import FREEBSD  # NOQA\nfrom _common import LINUX  # NOQA\nfrom _common import MACOS  # NOQA\nfrom _common import NETBSD  # NOQA\nfrom _common import OPENBSD  # NOQA\nfrom _common import POSIX  # NOQA\nfrom _common import SUNOS  # NOQA\nfrom _common import WINDOWS  # NOQA\nfrom _common import hilite  # NOQA\nfrom _compat import PY3  # NOQA\nfrom _compat import which  # NOQA\n\n\nPYPY = '__pypy__' in sys.builtin_module_names\nPY36_PLUS = sys.version_info[:2] >= (3, 6)\nPY37_PLUS = sys.version_info[:2] >= (3, 7)\nCP36_PLUS = PY36_PLUS and sys.implementation.name == \"cpython\"\nCP37_PLUS = PY37_PLUS and sys.implementation.name == \"cpython\"\nPy_GIL_DISABLED = sysconfig.get_config_var(\"Py_GIL_DISABLED\")\n\nmacros = []\nif POSIX:\n    macros.append((\"PSUTIL_POSIX\", 1))\nif BSD:\n    macros.append((\"PSUTIL_BSD\", 1))\n\n# Needed to determine _Py_PARSE_PID in case it's missing (Python 2, PyPy).\n# Taken from Lib/test/test_fcntl.py.\n# XXX: not bullet proof as the (long long) case is missing.\nif struct.calcsize('l') <= 8:\n    macros.append(('PSUTIL_SIZEOF_PID_T', '4'))  # int\nelse:\n    macros.append(('PSUTIL_SIZEOF_PID_T', '8'))  # long\n\n\nsources = ['psutil/_psutil_common.c']\nif POSIX:\n    sources.append('psutil/_psutil_posix.c')\n\n\nextras_require = {\n    \"test\": [\n        \"enum34; python_version <= '3.4'\",\n        \"ipaddress; python_version < '3.0'\",\n        \"mock; python_version < '3.0'\",\n    ]\n}\nif not PYPY:\n    extras_require['test'].extend(\n        [\"pywin32; sys.platform == 'win32'\", \"wmi; sys.platform == 'win32'\"]\n    )\n\n\ndef get_version():\n    INIT = os.path.join(HERE, 'psutil/__init__.py')\n    with open(INIT) as f:\n        for line in f:\n            if line.startswith('__version__'):\n                ret = ast.literal_eval(line.strip().split(' = ')[1])\n                assert ret.count('.') == 2, ret\n                for num in ret.split('.'):\n                    assert num.isdigit(), ret\n                return ret\n        msg = \"couldn't find version string\"\n        raise ValueError(msg)\n\n\nVERSION = get_version()\nmacros.append(('PSUTIL_VERSION', int(VERSION.replace('.', ''))))\n\n# Py_LIMITED_API lets us create a single wheel which works with multiple\n# python versions, including unreleased ones.\nif bdist_wheel and CP36_PLUS and (MACOS or LINUX) and not Py_GIL_DISABLED:\n    py_limited_api = {\"py_limited_api\": True}\n    macros.append(('Py_LIMITED_API', '0x03060000'))\nelif bdist_wheel and CP37_PLUS and WINDOWS and not Py_GIL_DISABLED:\n    # PyErr_SetFromWindowsErr / PyErr_SetFromWindowsErrWithFilename are\n    # part of the stable API/ABI starting with CPython 3.7\n    py_limited_api = {\"py_limited_api\": True}\n    macros.append(('Py_LIMITED_API', '0x03070000'))\nelse:\n    py_limited_api = {}\n\n\ndef get_long_description():\n    script = os.path.join(HERE, \"scripts\", \"internal\", \"convert_readme.py\")\n    readme = os.path.join(HERE, 'README.rst')\n    p = subprocess.Popen(\n        [sys.executable, script, readme],\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    return stdout\n\n\n@contextlib.contextmanager\ndef silenced_output(stream_name):\n    class DummyFile(io.BytesIO):\n        # see: https://github.com/giampaolo/psutil/issues/678\n        errors = \"ignore\"\n\n        def write(self, s):\n            pass\n\n    orig = getattr(sys, stream_name)\n    try:\n        setattr(sys, stream_name, DummyFile())\n        yield\n    finally:\n        setattr(sys, stream_name, orig)\n\n\ndef missdeps(cmdline):\n    s = \"psutil could not be installed from sources\"\n    if not SUNOS and not which(\"gcc\"):\n        s += \" because gcc is not installed. \"\n    else:\n        s += \". Perhaps Python header files are not installed. \"\n    s += \"Try running:\\n\"\n    s += \"  %s\" % cmdline\n    print(hilite(s, color=\"red\", bold=True), file=sys.stderr)\n\n\ndef unix_can_compile(c_code):\n    from distutils.errors import CompileError\n    from distutils.unixccompiler import UnixCCompiler\n\n    with tempfile.NamedTemporaryFile(\n        suffix='.c', delete=False, mode=\"wt\"\n    ) as f:\n        f.write(c_code)\n\n    tempdir = tempfile.mkdtemp()\n    try:\n        compiler = UnixCCompiler()\n        # https://github.com/giampaolo/psutil/pull/1568\n        if os.getenv('CC'):\n            compiler.set_executable('compiler_so', os.getenv('CC'))\n        with silenced_output('stderr'):\n            with silenced_output('stdout'):\n                compiler.compile([f.name], output_dir=tempdir)\n    except CompileError:\n        return False\n    else:\n        return True\n    finally:\n        os.remove(f.name)\n        shutil.rmtree(tempdir)\n\n\nif WINDOWS:\n\n    def get_winver():\n        maj, min = sys.getwindowsversion()[0:2]\n        return '0x0%s' % ((maj * 100) + min)\n\n    if sys.getwindowsversion()[0] < 6:\n        msg = \"this Windows version is too old (< Windows Vista); \"\n        msg += \"psutil 3.4.2 is the latest version which supports Windows \"\n        msg += \"2000, XP and 2003 server\"\n        raise RuntimeError(msg)\n\n    macros.append((\"PSUTIL_WINDOWS\", 1))\n    macros.extend([\n        # be nice to mingw, see:\n        # http://www.mingw.org/wiki/Use_more_recent_defined_functions\n        ('_WIN32_WINNT', get_winver()),\n        ('_AVAIL_WINVER_', get_winver()),\n        ('_CRT_SECURE_NO_WARNINGS', None),\n        # see: https://github.com/giampaolo/psutil/issues/348\n        ('PSAPI_VERSION', 1),\n    ])\n\n    ext = Extension(\n        'psutil._psutil_windows',\n        sources=(\n            sources\n            + [\"psutil/_psutil_windows.c\"]\n            + glob.glob(\"psutil/arch/windows/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\n            \"psapi\",\n            \"kernel32\",\n            \"advapi32\",\n            \"shell32\",\n            \"netapi32\",\n            \"ws2_32\",\n            \"PowrProf\",\n            \"pdh\",\n        ],\n        # extra_compile_args=[\"/W 4\"],\n        # extra_link_args=[\"/DEBUG\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif MACOS:\n    macros.append((\"PSUTIL_OSX\", 1))\n    ext = Extension(\n        'psutil._psutil_osx',\n        sources=(\n            sources\n            + [\"psutil/_psutil_osx.c\"]\n            + glob.glob(\"psutil/arch/osx/*.c\")\n        ),\n        define_macros=macros,\n        extra_link_args=[\n            '-framework',\n            'CoreFoundation',\n            '-framework',\n            'IOKit',\n        ],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif FREEBSD:\n    macros.append((\"PSUTIL_FREEBSD\", 1))\n    ext = Extension(\n        'psutil._psutil_bsd',\n        sources=(\n            sources\n            + [\"psutil/_psutil_bsd.c\"]\n            + glob.glob(\"psutil/arch/bsd/*.c\")\n            + glob.glob(\"psutil/arch/freebsd/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\"devstat\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif OPENBSD:\n    macros.append((\"PSUTIL_OPENBSD\", 1))\n    ext = Extension(\n        'psutil._psutil_bsd',\n        sources=(\n            sources\n            + [\"psutil/_psutil_bsd.c\"]\n            + glob.glob(\"psutil/arch/bsd/*.c\")\n            + glob.glob(\"psutil/arch/openbsd/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\"kvm\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif NETBSD:\n    macros.append((\"PSUTIL_NETBSD\", 1))\n    ext = Extension(\n        'psutil._psutil_bsd',\n        sources=(\n            sources\n            + [\"psutil/_psutil_bsd.c\"]\n            + glob.glob(\"psutil/arch/bsd/*.c\")\n            + glob.glob(\"psutil/arch/netbsd/*.c\")\n        ),\n        define_macros=macros,\n        libraries=[\"kvm\"],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif LINUX:\n    # see: https://github.com/giampaolo/psutil/issues/659\n    if not unix_can_compile(\"#include <linux/ethtool.h>\"):\n        macros.append((\"PSUTIL_ETHTOOL_MISSING_TYPES\", 1))\n\n    macros.append((\"PSUTIL_LINUX\", 1))\n    ext = Extension(\n        'psutil._psutil_linux',\n        sources=(\n            sources\n            + [\"psutil/_psutil_linux.c\"]\n            + glob.glob(\"psutil/arch/linux/*.c\")\n        ),\n        define_macros=macros,\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif SUNOS:\n    macros.append((\"PSUTIL_SUNOS\", 1))\n    ext = Extension(\n        'psutil._psutil_sunos',\n        sources=sources\n        + [\n            'psutil/_psutil_sunos.c',\n            'psutil/arch/solaris/v10/ifaddrs.c',\n            'psutil/arch/solaris/environ.c',\n        ],\n        define_macros=macros,\n        libraries=['kstat', 'nsl', 'socket'],\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelif AIX:\n    macros.append((\"PSUTIL_AIX\", 1))\n    ext = Extension(\n        'psutil._psutil_aix',\n        sources=sources\n        + [\n            'psutil/_psutil_aix.c',\n            'psutil/arch/aix/net_connections.c',\n            'psutil/arch/aix/common.c',\n            'psutil/arch/aix/ifaddrs.c',\n        ],\n        libraries=['perfstat'],\n        define_macros=macros,\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n\nelse:\n    sys.exit('platform %s is not supported' % sys.platform)\n\n\nif POSIX:\n    posix_extension = Extension(\n        'psutil._psutil_posix',\n        define_macros=macros,\n        sources=sources,\n        # fmt: off\n        # python 2.7 compatibility requires no comma\n        **py_limited_api\n        # fmt: on\n    )\n    if SUNOS:\n\n        def get_sunos_update():\n            # See https://serverfault.com/q/524883\n            # for an explanation of Solaris /etc/release\n            with open('/etc/release') as f:\n                update = re.search(r'(?<=s10s_u)[0-9]{1,2}', f.readline())\n                return int(update.group(0)) if update else 0\n\n        posix_extension.libraries.append('socket')\n        if platform.release() == '5.10':\n            # Detect Solaris 5.10, update >= 4, see:\n            # https://github.com/giampaolo/psutil/pull/1638\n            if get_sunos_update() >= 4:\n                # MIB compliance starts with SunOS 5.10 Update 4:\n                posix_extension.define_macros.append(('NEW_MIB_COMPLIANT', 1))\n            posix_extension.sources.append('psutil/arch/solaris/v10/ifaddrs.c')\n            posix_extension.define_macros.append(('PSUTIL_SUNOS10', 1))\n        else:\n            # Other releases are by default considered to be new mib compliant.\n            posix_extension.define_macros.append(('NEW_MIB_COMPLIANT', 1))\n    elif AIX:\n        posix_extension.sources.append('psutil/arch/aix/ifaddrs.c')\n\n    extensions = [ext, posix_extension]\nelse:\n    extensions = [ext]\n\ncmdclass = {}\nif py_limited_api:\n\n    class bdist_wheel_abi3(bdist_wheel):\n        def get_tag(self):\n            python, _abi, plat = bdist_wheel.get_tag(self)\n            return python, \"abi3\", plat\n\n    cmdclass[\"bdist_wheel\"] = bdist_wheel_abi3\n\n\ndef main():\n    kwargs = dict(\n        name='psutil',\n        version=VERSION,\n        cmdclass=cmdclass,\n        description=__doc__.replace('\\n', ' ').strip() if __doc__ else '',\n        long_description=get_long_description(),\n        long_description_content_type='text/x-rst',\n        # fmt: off\n        keywords=[\n            'ps', 'top', 'kill', 'free', 'lsof', 'netstat', 'nice', 'tty',\n            'ionice', 'uptime', 'taskmgr', 'process', 'df', 'iotop', 'iostat',\n            'ifconfig', 'taskset', 'who', 'pidof', 'pmap', 'smem', 'pstree',\n            'monitoring', 'ulimit', 'prlimit', 'smem', 'performance',\n            'metrics', 'agent', 'observability',\n        ],\n        # fmt: on\n        author='Giampaolo Rodola',\n        author_email='g.rodola@gmail.com',\n        url='https://github.com/giampaolo/psutil',\n        platforms='Platform Independent',\n        license='BSD-3-Clause',\n        packages=['psutil', 'psutil.tests'],\n        ext_modules=extensions,\n        classifiers=[\n            'Development Status :: 5 - Production/Stable',\n            'Environment :: Console',\n            'Environment :: Win32 (MS Windows)',\n            'Intended Audience :: Developers',\n            'Intended Audience :: Information Technology',\n            'Intended Audience :: System Administrators',\n            'License :: OSI Approved :: BSD License',\n            'Operating System :: MacOS :: MacOS X',\n            'Operating System :: Microsoft :: Windows :: Windows 10',\n            'Operating System :: Microsoft :: Windows :: Windows 7',\n            'Operating System :: Microsoft :: Windows :: Windows 8',\n            'Operating System :: Microsoft :: Windows :: Windows 8.1',\n            'Operating System :: Microsoft :: Windows :: Windows Server 2003',\n            'Operating System :: Microsoft :: Windows :: Windows Server 2008',\n            'Operating System :: Microsoft :: Windows :: Windows Vista',\n            'Operating System :: Microsoft',\n            'Operating System :: OS Independent',\n            'Operating System :: POSIX :: AIX',\n            'Operating System :: POSIX :: BSD :: FreeBSD',\n            'Operating System :: POSIX :: BSD :: NetBSD',\n            'Operating System :: POSIX :: BSD :: OpenBSD',\n            'Operating System :: POSIX :: BSD',\n            'Operating System :: POSIX :: Linux',\n            'Operating System :: POSIX :: SunOS/Solaris',\n            'Operating System :: POSIX',\n            'Programming Language :: C',\n            'Programming Language :: Python :: 2',\n            'Programming Language :: Python :: 2.7',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: Implementation :: CPython',\n            'Programming Language :: Python :: Implementation :: PyPy',\n            'Programming Language :: Python',\n            'Topic :: Software Development :: Libraries :: Python Modules',\n            'Topic :: Software Development :: Libraries',\n            'Topic :: System :: Benchmark',\n            'Topic :: System :: Hardware :: Hardware Drivers',\n            'Topic :: System :: Hardware',\n            'Topic :: System :: Monitoring',\n            'Topic :: System :: Networking :: Monitoring :: Hardware Watchdog',\n            'Topic :: System :: Networking :: Monitoring',\n            'Topic :: System :: Networking',\n            'Topic :: System :: Operating System',\n            'Topic :: System :: Systems Administration',\n            'Topic :: Utilities',\n        ],\n    )\n    if setuptools is not None:\n        kwargs.update(\n            python_requires=(\n                \">=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*, !=3.4.*, !=3.5.*\"\n            ),\n            extras_require=extras_require,\n            zip_safe=False,\n        )\n    success = False\n    try:\n        setup(**kwargs)\n        success = True\n    finally:\n        cmd = sys.argv[1] if len(sys.argv) >= 2 else ''\n        if (\n            not success\n            and POSIX\n            and cmd.startswith(\n                (\"build\", \"install\", \"sdist\", \"bdist\", \"develop\")\n            )\n        ):\n            py3 = \"3\" if PY3 else \"\"\n            if LINUX:\n                pyimpl = \"pypy\" if PYPY else \"python\"\n                if which('dpkg'):\n                    missdeps(\n                        \"sudo apt-get install gcc %s%s-dev\" % (pyimpl, py3)\n                    )\n                elif which('rpm'):\n                    missdeps(\"sudo yum install gcc %s%s-devel\" % (pyimpl, py3))\n                elif which('apk'):\n                    missdeps(\n                        \"sudo apk add gcc %s%s-dev musl-dev linux-headers\"\n                        % (pyimpl, py3)\n                    )\n            elif MACOS:\n                msg = (\n                    \"XCode (https://developer.apple.com/xcode/)\"\n                    \" is not installed\"\n                )\n                print(hilite(msg, color=\"red\"), file=sys.stderr)\n            elif FREEBSD:\n                if which('pkg'):\n                    missdeps(\"pkg install gcc python%s\" % py3)\n                elif which('mport'):  # MidnightBSD\n                    missdeps(\"mport install gcc python%s\" % py3)\n            elif OPENBSD:\n                missdeps(\"pkg_add -v gcc python%s\" % py3)\n            elif NETBSD:\n                missdeps(\"pkgin install gcc python%s\" % py3)\n            elif SUNOS:\n                missdeps(\n                    \"sudo ln -s /usr/bin/gcc /usr/local/bin/cc && \"\n                    \"pkg install gcc\"\n                )\n\n\nif __name__ == '__main__':\n    main()\n", "psutil/_pswindows.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Windows platform implementation.\"\"\"\n\nimport contextlib\nimport errno\nimport functools\nimport os\nimport signal\nimport sys\nimport time\nfrom collections import namedtuple\n\nfrom . import _common\nfrom ._common import ENCODING\nfrom ._common import ENCODING_ERRS\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import TimeoutExpired\nfrom ._common import conn_tmap\nfrom ._common import conn_to_ntuple\nfrom ._common import debug\nfrom ._common import isfile_strict\nfrom ._common import memoize\nfrom ._common import memoize_when_activated\nfrom ._common import parse_environ_block\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import long\nfrom ._compat import lru_cache\nfrom ._compat import range\nfrom ._compat import unicode\nfrom ._psutil_windows import ABOVE_NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import BELOW_NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import HIGH_PRIORITY_CLASS\nfrom ._psutil_windows import IDLE_PRIORITY_CLASS\nfrom ._psutil_windows import NORMAL_PRIORITY_CLASS\nfrom ._psutil_windows import REALTIME_PRIORITY_CLASS\n\n\ntry:\n    from . import _psutil_windows as cext\nexcept ImportError as err:\n    if (\n        str(err).lower().startswith(\"dll load failed\")\n        and sys.getwindowsversion()[0] < 6\n    ):\n        # We may get here if:\n        # 1) we are on an old Windows version\n        # 2) psutil was installed via pip + wheel\n        # See: https://github.com/giampaolo/psutil/issues/811\n        msg = \"this Windows version is too old (< Windows Vista); \"\n        msg += \"psutil 3.4.2 is the latest version which supports Windows \"\n        msg += \"2000, XP and 2003 server\"\n        raise RuntimeError(msg)\n    else:\n        raise\n\nif PY3:\n    import enum\nelse:\n    enum = None\n\n# process priority constants, import from __init__.py:\n# http://msdn.microsoft.com/en-us/library/ms686219(v=vs.85).aspx\n# fmt: off\n__extra__all__ = [\n    \"win_service_iter\", \"win_service_get\",\n    # Process priority\n    \"ABOVE_NORMAL_PRIORITY_CLASS\", \"BELOW_NORMAL_PRIORITY_CLASS\",\n    \"HIGH_PRIORITY_CLASS\", \"IDLE_PRIORITY_CLASS\", \"NORMAL_PRIORITY_CLASS\",\n    \"REALTIME_PRIORITY_CLASS\",\n    # IO priority\n    \"IOPRIO_VERYLOW\", \"IOPRIO_LOW\", \"IOPRIO_NORMAL\", \"IOPRIO_HIGH\",\n    # others\n    \"CONN_DELETE_TCB\", \"AF_LINK\",\n]\n# fmt: on\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\nCONN_DELETE_TCB = \"DELETE_TCB\"\nERROR_PARTIAL_COPY = 299\nPYPY = '__pypy__' in sys.builtin_module_names\n\nif enum is None:\n    AF_LINK = -1\nelse:\n    AddressFamily = enum.IntEnum('AddressFamily', {'AF_LINK': -1})\n    AF_LINK = AddressFamily.AF_LINK\n\nTCP_STATUSES = {\n    cext.MIB_TCP_STATE_ESTAB: _common.CONN_ESTABLISHED,\n    cext.MIB_TCP_STATE_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.MIB_TCP_STATE_SYN_RCVD: _common.CONN_SYN_RECV,\n    cext.MIB_TCP_STATE_FIN_WAIT1: _common.CONN_FIN_WAIT1,\n    cext.MIB_TCP_STATE_FIN_WAIT2: _common.CONN_FIN_WAIT2,\n    cext.MIB_TCP_STATE_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.MIB_TCP_STATE_CLOSED: _common.CONN_CLOSE,\n    cext.MIB_TCP_STATE_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.MIB_TCP_STATE_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.MIB_TCP_STATE_LISTEN: _common.CONN_LISTEN,\n    cext.MIB_TCP_STATE_CLOSING: _common.CONN_CLOSING,\n    cext.MIB_TCP_STATE_DELETE_TCB: CONN_DELETE_TCB,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nif enum is not None:\n\n    class Priority(enum.IntEnum):\n        ABOVE_NORMAL_PRIORITY_CLASS = ABOVE_NORMAL_PRIORITY_CLASS\n        BELOW_NORMAL_PRIORITY_CLASS = BELOW_NORMAL_PRIORITY_CLASS\n        HIGH_PRIORITY_CLASS = HIGH_PRIORITY_CLASS\n        IDLE_PRIORITY_CLASS = IDLE_PRIORITY_CLASS\n        NORMAL_PRIORITY_CLASS = NORMAL_PRIORITY_CLASS\n        REALTIME_PRIORITY_CLASS = REALTIME_PRIORITY_CLASS\n\n    globals().update(Priority.__members__)\n\nif enum is None:\n    IOPRIO_VERYLOW = 0\n    IOPRIO_LOW = 1\n    IOPRIO_NORMAL = 2\n    IOPRIO_HIGH = 3\nelse:\n\n    class IOPriority(enum.IntEnum):\n        IOPRIO_VERYLOW = 0\n        IOPRIO_LOW = 1\n        IOPRIO_NORMAL = 2\n        IOPRIO_HIGH = 3\n\n    globals().update(IOPriority.__members__)\n\npinfo_map = dict(\n    num_handles=0,\n    ctx_switches=1,\n    user_time=2,\n    kernel_time=3,\n    create_time=4,\n    num_threads=5,\n    io_rcount=6,\n    io_wcount=7,\n    io_rbytes=8,\n    io_wbytes=9,\n    io_count_others=10,\n    io_bytes_others=11,\n    num_page_faults=12,\n    peak_wset=13,\n    wset=14,\n    peak_paged_pool=15,\n    paged_pool=16,\n    peak_non_paged_pool=17,\n    non_paged_pool=18,\n    pagefile=19,\n    peak_pagefile=20,\n    mem_private=21,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.cpu_times()\nscputimes = namedtuple('scputimes',\n                       ['user', 'system', 'idle', 'interrupt', 'dpc'])\n# psutil.virtual_memory()\nsvmem = namedtuple('svmem', ['total', 'available', 'percent', 'used', 'free'])\n# psutil.Process.memory_info()\npmem = namedtuple(\n    'pmem', ['rss', 'vms',\n             'num_page_faults', 'peak_wset', 'wset', 'peak_paged_pool',\n             'paged_pool', 'peak_nonpaged_pool', 'nonpaged_pool',\n             'pagefile', 'peak_pagefile', 'private'])\n# psutil.Process.memory_full_info()\npfullmem = namedtuple('pfullmem', pmem._fields + ('uss', ))\n# psutil.Process.memory_maps(grouped=True)\npmmap_grouped = namedtuple('pmmap_grouped', ['path', 'rss'])\n# psutil.Process.memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr perms ' + ' '.join(pmmap_grouped._fields))\n# psutil.Process.io_counters()\npio = namedtuple('pio', ['read_count', 'write_count',\n                         'read_bytes', 'write_bytes',\n                         'other_count', 'other_bytes'])\n# fmt: on\n\n\n# =====================================================================\n# --- utils\n# =====================================================================\n\n\n@lru_cache(maxsize=512)\ndef convert_dos_path(s):\n    r\"\"\"Convert paths using native DOS format like:\n        \"\\Device\\HarddiskVolume1\\Windows\\systemew\\file.txt\"\n    into:\n        \"C:\\Windows\\systemew\\file.txt\".\n    \"\"\"\n    rawdrive = '\\\\'.join(s.split('\\\\')[:3])\n    driveletter = cext.QueryDosDevice(rawdrive)\n    remainder = s[len(rawdrive) :]\n    return os.path.join(driveletter, remainder)\n\n\ndef py2_strencode(s):\n    \"\"\"Encode a unicode string to a byte string by using the default fs\n    encoding + \"replace\" error handler.\n    \"\"\"\n    if PY3:\n        return s\n    else:\n        if isinstance(s, str):\n            return s\n        else:\n            return s.encode(ENCODING, ENCODING_ERRS)\n\n\n@memoize\ndef getpagesize():\n    return cext.getpagesize()\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"System virtual memory as a namedtuple.\"\"\"\n    mem = cext.virtual_mem()\n    totphys, availphys, _totsys, _availsys = mem\n    total = totphys\n    avail = availphys\n    free = availphys\n    used = total - avail\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(total, avail, percent, used, free)\n\n\ndef swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    mem = cext.virtual_mem()\n\n    total_phys = mem[0]\n    total_system = mem[2]\n\n    # system memory (commit total/limit) is the sum of physical and swap\n    # thus physical memory values need to be subtracted to get swap values\n    total = total_system - total_phys\n    # commit total is incremented immediately (decrementing free_system)\n    # while the corresponding free physical value is not decremented until\n    # pages are accessed, so we can't use free system memory for swap.\n    # instead, we calculate page file usage based on performance counter\n    if total > 0:\n        percentswap = cext.swap_percent()\n        used = int(0.01 * percentswap * total)\n    else:\n        percentswap = 0.0\n        used = 0\n\n    free = total - used\n    percent = round(percentswap, 1)\n    return _common.sswap(total, used, free, percent, 0, 0)\n\n\n# =====================================================================\n# --- disk\n# =====================================================================\n\n\ndisk_io_counters = cext.disk_io_counters\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage associated with path.\"\"\"\n    if PY3 and isinstance(path, bytes):\n        # XXX: do we want to use \"strict\"? Probably yes, in order\n        # to fail immediately. After all we are accepting input here...\n        path = path.decode(ENCODING, errors=\"strict\")\n    total, free = cext.disk_usage(path)\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sdiskusage(total, used, free, percent)\n\n\ndef disk_partitions(all):\n    \"\"\"Return disk partitions.\"\"\"\n    rawlist = cext.disk_partitions(all)\n    return [_common.sdiskpart(*x) for x in rawlist]\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system CPU times as a named tuple.\"\"\"\n    user, system, idle = cext.cpu_times()\n    # Internally, GetSystemTimes() is used, and it doesn't return\n    # interrupt and dpc times. cext.per_cpu_times() does, so we\n    # rely on it to get those only.\n    percpu_summed = scputimes(*[sum(n) for n in zip(*cext.per_cpu_times())])\n    return scputimes(\n        user, system, idle, percpu_summed.interrupt, percpu_summed.dpc\n    )\n\n\ndef per_cpu_times():\n    \"\"\"Return system per-CPU times as a list of named tuples.\"\"\"\n    ret = []\n    for user, system, idle, interrupt, dpc in cext.per_cpu_times():\n        item = scputimes(user, system, idle, interrupt, dpc)\n        ret.append(item)\n    return ret\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    return cext.cpu_count_logical()\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    return cext.cpu_count_cores()\n\n\ndef cpu_stats():\n    \"\"\"Return CPU statistics.\"\"\"\n    ctx_switches, interrupts, _dpcs, syscalls = cext.cpu_stats()\n    soft_interrupts = 0\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\ndef cpu_freq():\n    \"\"\"Return CPU frequency.\n    On Windows per-cpu frequency is not supported.\n    \"\"\"\n    curr, max_ = cext.cpu_freq()\n    min_ = 0.0\n    return [_common.scpufreq(float(curr), min_, float(max_))]\n\n\n_loadavg_inititialized = False\n\n\ndef getloadavg():\n    \"\"\"Return the number of processes in the system run queue averaged\n    over the last 1, 5, and 15 minutes respectively as a tuple.\n    \"\"\"\n    global _loadavg_inititialized\n\n    if not _loadavg_inititialized:\n        cext.init_loadavg_counter()\n        _loadavg_inititialized = True\n\n    # Drop to 2 decimal points which is what Linux does\n    raw_loads = cext.getloadavg()\n    return tuple([round(load, 2) for load in raw_loads])\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\ndef net_connections(kind, _pid=-1):\n    \"\"\"Return socket connections.  If pid == -1 return system-wide\n    connections (as opposed to connections opened by one process only).\n    \"\"\"\n    if kind not in conn_tmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in conn_tmap]))\n        )\n    families, types = conn_tmap[kind]\n    rawlist = cext.net_connections(_pid, families, types)\n    ret = set()\n    for item in rawlist:\n        fd, fam, type, laddr, raddr, status, pid = item\n        nt = conn_to_ntuple(\n            fd,\n            fam,\n            type,\n            laddr,\n            raddr,\n            status,\n            TCP_STATUSES,\n            pid=pid if _pid == -1 else None,\n        )\n        ret.add(nt)\n    return list(ret)\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    ret = {}\n    rawdict = cext.net_if_stats()\n    for name, items in rawdict.items():\n        if not PY3:\n            assert isinstance(name, unicode), type(name)\n            name = py2_strencode(name)\n        isup, duplex, speed, mtu = items\n        if hasattr(_common, 'NicDuplex'):\n            duplex = _common.NicDuplex(duplex)\n        ret[name] = _common.snicstats(isup, duplex, speed, mtu, '')\n    return ret\n\n\ndef net_io_counters():\n    \"\"\"Return network I/O statistics for every network interface\n    installed on the system as a dict of raw tuples.\n    \"\"\"\n    ret = cext.net_io_counters()\n    return dict([(py2_strencode(k), v) for k, v in ret.items()])\n\n\ndef net_if_addrs():\n    \"\"\"Return the addresses associated to each NIC.\"\"\"\n    ret = []\n    for items in cext.net_if_addrs():\n        items = list(items)\n        items[0] = py2_strencode(items[0])\n        ret.append(items)\n    return ret\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\ndef sensors_battery():\n    \"\"\"Return battery information.\"\"\"\n    # For constants meaning see:\n    # https://msdn.microsoft.com/en-us/library/windows/desktop/\n    #     aa373232(v=vs.85).aspx\n    acline_status, flags, percent, secsleft = cext.sensors_battery()\n    power_plugged = acline_status == 1\n    no_battery = bool(flags & 128)\n    charging = bool(flags & 8)\n\n    if no_battery:\n        return None\n    if power_plugged or charging:\n        secsleft = _common.POWER_TIME_UNLIMITED\n    elif secsleft == -1:\n        secsleft = _common.POWER_TIME_UNKNOWN\n\n    return _common.sbattery(percent, secsleft, power_plugged)\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\n_last_btime = 0\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    # This dirty hack is to adjust the precision of the returned\n    # value which may have a 1 second fluctuation, see:\n    # https://github.com/giampaolo/psutil/issues/1007\n    global _last_btime\n    ret = float(cext.boot_time())\n    if abs(ret - _last_btime) <= 1:\n        return _last_btime\n    else:\n        _last_btime = ret\n        return ret\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, hostname, tstamp = item\n        user = py2_strencode(user)\n        nt = _common.suser(user, None, hostname, tstamp, None)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- Windows services\n# =====================================================================\n\n\ndef win_service_iter():\n    \"\"\"Yields a list of WindowsService instances.\"\"\"\n    for name, display_name in cext.winservice_enumerate():\n        yield WindowsService(py2_strencode(name), py2_strencode(display_name))\n\n\ndef win_service_get(name):\n    \"\"\"Open a Windows service and return it as a WindowsService instance.\"\"\"\n    service = WindowsService(name, None)\n    service._display_name = service._query_config()['display_name']\n    return service\n\n\nclass WindowsService:  # noqa: PLW1641\n    \"\"\"Represents an installed Windows service.\"\"\"\n\n    def __init__(self, name, display_name):\n        self._name = name\n        self._display_name = display_name\n\n    def __str__(self):\n        details = \"(name=%r, display_name=%r)\" % (\n            self._name,\n            self._display_name,\n        )\n        return \"%s%s\" % (self.__class__.__name__, details)\n\n    def __repr__(self):\n        return \"<%s at %s>\" % (self.__str__(), id(self))\n\n    def __eq__(self, other):\n        # Test for equality with another WindosService object based\n        # on name.\n        if not isinstance(other, WindowsService):\n            return NotImplemented\n        return self._name == other._name\n\n    def __ne__(self, other):\n        return not self == other\n\n    def _query_config(self):\n        with self._wrap_exceptions():\n            display_name, binpath, username, start_type = (\n                cext.winservice_query_config(self._name)\n            )\n        # XXX - update _self.display_name?\n        return dict(\n            display_name=py2_strencode(display_name),\n            binpath=py2_strencode(binpath),\n            username=py2_strencode(username),\n            start_type=py2_strencode(start_type),\n        )\n\n    def _query_status(self):\n        with self._wrap_exceptions():\n            status, pid = cext.winservice_query_status(self._name)\n        if pid == 0:\n            pid = None\n        return dict(status=status, pid=pid)\n\n    @contextlib.contextmanager\n    def _wrap_exceptions(self):\n        \"\"\"Ctx manager which translates bare OSError and WindowsError\n        exceptions into NoSuchProcess and AccessDenied.\n        \"\"\"\n        try:\n            yield\n        except OSError as err:\n            if is_permission_err(err):\n                msg = (\n                    \"service %r is not querable (not enough privileges)\"\n                    % self._name\n                )\n                raise AccessDenied(pid=None, name=self._name, msg=msg)\n            elif err.winerror in (\n                cext.ERROR_INVALID_NAME,\n                cext.ERROR_SERVICE_DOES_NOT_EXIST,\n            ):\n                msg = \"service %r does not exist\" % self._name\n                raise NoSuchProcess(pid=None, name=self._name, msg=msg)\n            else:\n                raise\n\n    # config query\n\n    def name(self):\n        \"\"\"The service name. This string is how a service is referenced\n        and can be passed to win_service_get() to get a new\n        WindowsService instance.\n        \"\"\"\n        return self._name\n\n    def display_name(self):\n        \"\"\"The service display name. The value is cached when this class\n        is instantiated.\n        \"\"\"\n        return self._display_name\n\n    def binpath(self):\n        \"\"\"The fully qualified path to the service binary/exe file as\n        a string, including command line arguments.\n        \"\"\"\n        return self._query_config()['binpath']\n\n    def username(self):\n        \"\"\"The name of the user that owns this service.\"\"\"\n        return self._query_config()['username']\n\n    def start_type(self):\n        \"\"\"A string which can either be \"automatic\", \"manual\" or\n        \"disabled\".\n        \"\"\"\n        return self._query_config()['start_type']\n\n    # status query\n\n    def pid(self):\n        \"\"\"The process PID, if any, else None. This can be passed\n        to Process class to control the service's process.\n        \"\"\"\n        return self._query_status()['pid']\n\n    def status(self):\n        \"\"\"Service status as a string.\"\"\"\n        return self._query_status()['status']\n\n    def description(self):\n        \"\"\"Service long description.\"\"\"\n        return py2_strencode(cext.winservice_query_descr(self.name()))\n\n    # utils\n\n    def as_dict(self):\n        \"\"\"Utility method retrieving all the information above as a\n        dictionary.\n        \"\"\"\n        d = self._query_config()\n        d.update(self._query_status())\n        d['name'] = self.name()\n        d['display_name'] = self.display_name()\n        d['description'] = self.description()\n        return d\n\n    # actions\n    # XXX: the necessary C bindings for start() and stop() are\n    # implemented but for now I prefer not to expose them.\n    # I may change my mind in the future. Reasons:\n    # - they require Administrator privileges\n    # - can't implement a timeout for stop() (unless by using a thread,\n    #   which sucks)\n    # - would require adding ServiceAlreadyStarted and\n    #   ServiceAlreadyStopped exceptions, adding two new APIs.\n    # - we might also want to have modify(), which would basically mean\n    #   rewriting win32serviceutil.ChangeServiceConfig, which involves a\n    #   lot of stuff (and API constants which would pollute the API), see:\n    #   http://pyxr.sourceforge.net/PyXR/c/python24/lib/site-packages/\n    #       win32/lib/win32serviceutil.py.html#0175\n    # - psutil is typically about \"read only\" monitoring stuff;\n    #   win_service_* APIs should only be used to retrieve a service and\n    #   check whether it's running\n\n    # def start(self, timeout=None):\n    #     with self._wrap_exceptions():\n    #         cext.winservice_start(self.name())\n    #         if timeout:\n    #             giveup_at = time.time() + timeout\n    #             while True:\n    #                 if self.status() == \"running\":\n    #                     return\n    #                 else:\n    #                     if time.time() > giveup_at:\n    #                         raise TimeoutExpired(timeout)\n    #                     else:\n    #                         time.sleep(.1)\n\n    # def stop(self):\n    #     # Note: timeout is not implemented because it's just not\n    #     # possible, see:\n    #     # http://stackoverflow.com/questions/11973228/\n    #     with self._wrap_exceptions():\n    #         return cext.winservice_stop(self.name())\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\npids = cext.pids\npid_exists = cext.pid_exists\nppid_map = cext.ppid_map  # used internally by Process.children()\n\n\ndef is_permission_err(exc):\n    \"\"\"Return True if this is a permission error.\"\"\"\n    assert isinstance(exc, OSError), exc\n    if exc.errno in (errno.EPERM, errno.EACCES):\n        return True\n    # On Python 2 OSError doesn't always have 'winerror'. Sometimes\n    # it does, in which case the original exception was WindowsError\n    # (which is a subclass of OSError).\n    return getattr(exc, \"winerror\", -1) in (\n        cext.ERROR_ACCESS_DENIED,\n        cext.ERROR_PRIVILEGE_NOT_HELD,\n    )\n\n\ndef convert_oserror(exc, pid=None, name=None):\n    \"\"\"Convert OSError into NoSuchProcess or AccessDenied.\"\"\"\n    assert isinstance(exc, OSError), exc\n    if is_permission_err(exc):\n        return AccessDenied(pid=pid, name=name)\n    if exc.errno == errno.ESRCH:\n        return NoSuchProcess(pid=pid, name=name)\n    raise exc\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which converts OSError into NoSuchProcess or AccessDenied.\"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except OSError as err:\n            raise convert_oserror(err, pid=self.pid, name=self._name)\n\n    return wrapper\n\n\ndef retry_error_partial_copy(fun):\n    \"\"\"Workaround for https://github.com/giampaolo/psutil/issues/875.\n    See: https://stackoverflow.com/questions/4457745#4457745.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        delay = 0.0001\n        times = 33\n        for _ in range(times):  # retries for roughly 1 second\n            try:\n                return fun(self, *args, **kwargs)\n            except WindowsError as _:\n                err = _\n                if err.winerror == ERROR_PARTIAL_COPY:\n                    time.sleep(delay)\n                    delay = min(delay * 2, 0.04)\n                    continue\n                raise\n        msg = (\n            \"{} retried {} times, converted to AccessDenied as it's still\"\n            \"returning {}\".format(fun, times, err)\n        )\n        raise AccessDenied(pid=self.pid, name=self._name, msg=msg)\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n\n    # --- oneshot() stuff\n\n    def oneshot_enter(self):\n        self._proc_info.cache_activate(self)\n        self.exe.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._proc_info.cache_deactivate(self)\n        self.exe.cache_deactivate(self)\n\n    @memoize_when_activated\n    def _proc_info(self):\n        \"\"\"Return multiple information about this process as a\n        raw tuple.\n        \"\"\"\n        ret = cext.proc_info(self.pid)\n        assert len(ret) == len(pinfo_map)\n        return ret\n\n    def name(self):\n        \"\"\"Return process name, which on Windows is always the final\n        part of the executable.\n        \"\"\"\n        # This is how PIDs 0 and 4 are always represented in taskmgr\n        # and process-hacker.\n        if self.pid == 0:\n            return \"System Idle Process\"\n        if self.pid == 4:\n            return \"System\"\n        return os.path.basename(self.exe())\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def exe(self):\n        if PYPY:\n            try:\n                exe = cext.proc_exe(self.pid)\n            except WindowsError as err:\n                # 24 = ERROR_TOO_MANY_OPEN_FILES. Not sure why this happens\n                # (perhaps PyPy's JIT delaying garbage collection of files?).\n                if err.errno == 24:\n                    debug(\"%r translated into AccessDenied\" % err)\n                    raise AccessDenied(self.pid, self._name)\n                raise\n        else:\n            exe = cext.proc_exe(self.pid)\n        if not PY3:\n            exe = py2_strencode(exe)\n        if exe.startswith('\\\\'):\n            return convert_dos_path(exe)\n        return exe  # May be \"Registry\", \"MemCompression\", ...\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def cmdline(self):\n        if cext.WINVER >= cext.WINDOWS_8_1:\n            # PEB method detects cmdline changes but requires more\n            # privileges: https://github.com/giampaolo/psutil/pull/1398\n            try:\n                ret = cext.proc_cmdline(self.pid, use_peb=True)\n            except OSError as err:\n                if is_permission_err(err):\n                    ret = cext.proc_cmdline(self.pid, use_peb=False)\n                else:\n                    raise\n        else:\n            ret = cext.proc_cmdline(self.pid, use_peb=True)\n        if PY3:\n            return ret\n        else:\n            return [py2_strencode(s) for s in ret]\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def environ(self):\n        ustr = cext.proc_environ(self.pid)\n        if ustr and not PY3:\n            assert isinstance(ustr, unicode), type(ustr)\n        return parse_environ_block(py2_strencode(ustr))\n\n    def ppid(self):\n        try:\n            return ppid_map()[self.pid]\n        except KeyError:\n            raise NoSuchProcess(self.pid, self._name)\n\n    def _get_raw_meminfo(self):\n        try:\n            return cext.proc_memory_info(self.pid)\n        except OSError as err:\n            if is_permission_err(err):\n                # TODO: the C ext can probably be refactored in order\n                # to get this from cext.proc_info()\n                debug(\"attempting memory_info() fallback (slower)\")\n                info = self._proc_info()\n                return (\n                    info[pinfo_map['num_page_faults']],\n                    info[pinfo_map['peak_wset']],\n                    info[pinfo_map['wset']],\n                    info[pinfo_map['peak_paged_pool']],\n                    info[pinfo_map['paged_pool']],\n                    info[pinfo_map['peak_non_paged_pool']],\n                    info[pinfo_map['non_paged_pool']],\n                    info[pinfo_map['pagefile']],\n                    info[pinfo_map['peak_pagefile']],\n                    info[pinfo_map['mem_private']],\n                )\n            raise\n\n    @wrap_exceptions\n    def memory_info(self):\n        # on Windows RSS == WorkingSetSize and VSM == PagefileUsage.\n        # Underlying C function returns fields of PROCESS_MEMORY_COUNTERS\n        # struct.\n        t = self._get_raw_meminfo()\n        rss = t[2]  # wset\n        vms = t[7]  # pagefile\n        return pmem(*(rss, vms) + t)\n\n    @wrap_exceptions\n    def memory_full_info(self):\n        basic_mem = self.memory_info()\n        uss = cext.proc_memory_uss(self.pid)\n        uss *= getpagesize()\n        return pfullmem(*basic_mem + (uss,))\n\n    def memory_maps(self):\n        try:\n            raw = cext.proc_memory_maps(self.pid)\n        except OSError as err:\n            # XXX - can't use wrap_exceptions decorator as we're\n            # returning a generator; probably needs refactoring.\n            raise convert_oserror(err, self.pid, self._name)\n        else:\n            for addr, perm, path, rss in raw:\n                path = convert_dos_path(path)\n                if not PY3:\n                    path = py2_strencode(path)\n                addr = hex(addr)\n                yield (addr, perm, path, rss)\n\n    @wrap_exceptions\n    def kill(self):\n        return cext.proc_kill(self.pid)\n\n    @wrap_exceptions\n    def send_signal(self, sig):\n        if sig == signal.SIGTERM:\n            cext.proc_kill(self.pid)\n        # py >= 2.7\n        elif sig in (\n            getattr(signal, \"CTRL_C_EVENT\", object()),\n            getattr(signal, \"CTRL_BREAK_EVENT\", object()),\n        ):\n            os.kill(self.pid, sig)\n        else:\n            msg = (\n                \"only SIGTERM, CTRL_C_EVENT and CTRL_BREAK_EVENT signals \"\n                \"are supported on Windows\"\n            )\n            raise ValueError(msg)\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        if timeout is None:\n            cext_timeout = cext.INFINITE\n        else:\n            # WaitForSingleObject() expects time in milliseconds.\n            cext_timeout = int(timeout * 1000)\n\n        timer = getattr(time, 'monotonic', time.time)\n        stop_at = timer() + timeout if timeout is not None else None\n\n        try:\n            # Exit code is supposed to come from GetExitCodeProcess().\n            # May also be None if OpenProcess() failed with\n            # ERROR_INVALID_PARAMETER, meaning PID is already gone.\n            exit_code = cext.proc_wait(self.pid, cext_timeout)\n        except cext.TimeoutExpired:\n            # WaitForSingleObject() returned WAIT_TIMEOUT. Just raise.\n            raise TimeoutExpired(timeout, self.pid, self._name)\n        except cext.TimeoutAbandoned:\n            # WaitForSingleObject() returned WAIT_ABANDONED, see:\n            # https://github.com/giampaolo/psutil/issues/1224\n            # We'll just rely on the internal polling and return None\n            # when the PID disappears. Subprocess module does the same\n            # (return None):\n            # https://github.com/python/cpython/blob/\n            #     be50a7b627d0aa37e08fa8e2d5568891f19903ce/\n            #     Lib/subprocess.py#L1193-L1194\n            exit_code = None\n\n        # At this point WaitForSingleObject() returned WAIT_OBJECT_0,\n        # meaning the process is gone. Stupidly there are cases where\n        # its PID may still stick around so we do a further internal\n        # polling.\n        delay = 0.0001\n        while True:\n            if not pid_exists(self.pid):\n                return exit_code\n            if stop_at and timer() >= stop_at:\n                raise TimeoutExpired(timeout, pid=self.pid, name=self._name)\n            time.sleep(delay)\n            delay = min(delay * 2, 0.04)  # incremental delay\n\n    @wrap_exceptions\n    def username(self):\n        if self.pid in (0, 4):\n            return 'NT AUTHORITY\\\\SYSTEM'\n        domain, user = cext.proc_username(self.pid)\n        return py2_strencode(domain) + '\\\\' + py2_strencode(user)\n\n    @wrap_exceptions\n    def create_time(self):\n        # Note: proc_times() not put under oneshot() 'cause create_time()\n        # is already cached by the main Process class.\n        try:\n            _user, _system, created = cext.proc_times(self.pid)\n            return created\n        except OSError as err:\n            if is_permission_err(err):\n                debug(\"attempting create_time() fallback (slower)\")\n                return self._proc_info()[pinfo_map['create_time']]\n            raise\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._proc_info()[pinfo_map['num_threads']]\n\n    @wrap_exceptions\n    def threads(self):\n        rawlist = cext.proc_threads(self.pid)\n        retlist = []\n        for thread_id, utime, stime in rawlist:\n            ntuple = _common.pthread(thread_id, utime, stime)\n            retlist.append(ntuple)\n        return retlist\n\n    @wrap_exceptions\n    def cpu_times(self):\n        try:\n            user, system, _created = cext.proc_times(self.pid)\n        except OSError as err:\n            if not is_permission_err(err):\n                raise\n            debug(\"attempting cpu_times() fallback (slower)\")\n            info = self._proc_info()\n            user = info[pinfo_map['user_time']]\n            system = info[pinfo_map['kernel_time']]\n        # Children user/system times are not retrievable (set to 0).\n        return _common.pcputimes(user, system, 0.0, 0.0)\n\n    @wrap_exceptions\n    def suspend(self):\n        cext.proc_suspend_or_resume(self.pid, True)\n\n    @wrap_exceptions\n    def resume(self):\n        cext.proc_suspend_or_resume(self.pid, False)\n\n    @wrap_exceptions\n    @retry_error_partial_copy\n    def cwd(self):\n        if self.pid in (0, 4):\n            raise AccessDenied(self.pid, self._name)\n        # return a normalized pathname since the native C function appends\n        # \"\\\\\" at the and of the path\n        path = cext.proc_cwd(self.pid)\n        return py2_strencode(os.path.normpath(path))\n\n    @wrap_exceptions\n    def open_files(self):\n        if self.pid in (0, 4):\n            return []\n        ret = set()\n        # Filenames come in in native format like:\n        # \"\\Device\\HarddiskVolume1\\Windows\\systemew\\file.txt\"\n        # Convert the first part in the corresponding drive letter\n        # (e.g. \"C:\\\") by using Windows's QueryDosDevice()\n        raw_file_names = cext.proc_open_files(self.pid)\n        for _file in raw_file_names:\n            _file = convert_dos_path(_file)\n            if isfile_strict(_file):\n                if not PY3:\n                    _file = py2_strencode(_file)\n                ntuple = _common.popenfile(_file, -1)\n                ret.add(ntuple)\n        return list(ret)\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        return net_connections(kind, _pid=self.pid)\n\n    @wrap_exceptions\n    def nice_get(self):\n        value = cext.proc_priority_get(self.pid)\n        if enum is not None:\n            value = Priority(value)\n        return value\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext.proc_priority_set(self.pid, value)\n\n    @wrap_exceptions\n    def ionice_get(self):\n        ret = cext.proc_io_priority_get(self.pid)\n        if enum is not None:\n            ret = IOPriority(ret)\n        return ret\n\n    @wrap_exceptions\n    def ionice_set(self, ioclass, value):\n        if value:\n            msg = \"value argument not accepted on Windows\"\n            raise TypeError(msg)\n        if ioclass not in (\n            IOPRIO_VERYLOW,\n            IOPRIO_LOW,\n            IOPRIO_NORMAL,\n            IOPRIO_HIGH,\n        ):\n            raise ValueError(\"%s is not a valid priority\" % ioclass)\n        cext.proc_io_priority_set(self.pid, ioclass)\n\n    @wrap_exceptions\n    def io_counters(self):\n        try:\n            ret = cext.proc_io_counters(self.pid)\n        except OSError as err:\n            if not is_permission_err(err):\n                raise\n            debug(\"attempting io_counters() fallback (slower)\")\n            info = self._proc_info()\n            ret = (\n                info[pinfo_map['io_rcount']],\n                info[pinfo_map['io_wcount']],\n                info[pinfo_map['io_rbytes']],\n                info[pinfo_map['io_wbytes']],\n                info[pinfo_map['io_count_others']],\n                info[pinfo_map['io_bytes_others']],\n            )\n        return pio(*ret)\n\n    @wrap_exceptions\n    def status(self):\n        suspended = cext.proc_is_suspended(self.pid)\n        if suspended:\n            return _common.STATUS_STOPPED\n        else:\n            return _common.STATUS_RUNNING\n\n    @wrap_exceptions\n    def cpu_affinity_get(self):\n        def from_bitmask(x):\n            return [i for i in range(64) if (1 << i) & x]\n\n        bitmask = cext.proc_cpu_affinity_get(self.pid)\n        return from_bitmask(bitmask)\n\n    @wrap_exceptions\n    def cpu_affinity_set(self, value):\n        def to_bitmask(ls):\n            if not ls:\n                raise ValueError(\"invalid argument %r\" % ls)\n            out = 0\n            for b in ls:\n                out |= 2**b\n            return out\n\n        # SetProcessAffinityMask() states that ERROR_INVALID_PARAMETER\n        # is returned for an invalid CPU but this seems not to be true,\n        # therefore we check CPUs validy beforehand.\n        allcpus = list(range(len(per_cpu_times())))\n        for cpu in value:\n            if cpu not in allcpus:\n                if not isinstance(cpu, (int, long)):\n                    raise TypeError(\n                        \"invalid CPU %r; an integer is required\" % cpu\n                    )\n                else:\n                    raise ValueError(\"invalid CPU %r\" % cpu)\n\n        bitmask = to_bitmask(value)\n        cext.proc_cpu_affinity_set(self.pid, bitmask)\n\n    @wrap_exceptions\n    def num_handles(self):\n        try:\n            return cext.proc_num_handles(self.pid)\n        except OSError as err:\n            if is_permission_err(err):\n                debug(\"attempting num_handles() fallback (slower)\")\n                return self._proc_info()[pinfo_map['num_handles']]\n            raise\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        ctx_switches = self._proc_info()[pinfo_map['ctx_switches']]\n        # only voluntary ctx switches are supported\n        return _common.pctxsw(ctx_switches, 0)\n", "psutil/_common.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Common objects shared by __init__.py and _ps*.py modules.\"\"\"\n\n# Note: this module is imported by setup.py so it should not import\n# psutil or third-party modules.\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport socket\nimport stat\nimport sys\nimport threading\nimport warnings\nfrom collections import namedtuple\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\n\n\ntry:\n    from socket import AF_INET6\nexcept ImportError:\n    AF_INET6 = None\ntry:\n    from socket import AF_UNIX\nexcept ImportError:\n    AF_UNIX = None\n\n\n# can't take it from _common.py as this script is imported by setup.py\nPY3 = sys.version_info[0] >= 3\nif PY3:\n    import enum\nelse:\n    enum = None\n\n\nPSUTIL_DEBUG = bool(os.getenv('PSUTIL_DEBUG'))\n_DEFAULT = object()\n\n# fmt: off\n__all__ = [\n    # OS constants\n    'FREEBSD', 'BSD', 'LINUX', 'NETBSD', 'OPENBSD', 'MACOS', 'OSX', 'POSIX',\n    'SUNOS', 'WINDOWS',\n    # connection constants\n    'CONN_CLOSE', 'CONN_CLOSE_WAIT', 'CONN_CLOSING', 'CONN_ESTABLISHED',\n    'CONN_FIN_WAIT1', 'CONN_FIN_WAIT2', 'CONN_LAST_ACK', 'CONN_LISTEN',\n    'CONN_NONE', 'CONN_SYN_RECV', 'CONN_SYN_SENT', 'CONN_TIME_WAIT',\n    # net constants\n    'NIC_DUPLEX_FULL', 'NIC_DUPLEX_HALF', 'NIC_DUPLEX_UNKNOWN',\n    # process status constants\n    'STATUS_DEAD', 'STATUS_DISK_SLEEP', 'STATUS_IDLE', 'STATUS_LOCKED',\n    'STATUS_RUNNING', 'STATUS_SLEEPING', 'STATUS_STOPPED', 'STATUS_SUSPENDED',\n    'STATUS_TRACING_STOP', 'STATUS_WAITING', 'STATUS_WAKE_KILL',\n    'STATUS_WAKING', 'STATUS_ZOMBIE', 'STATUS_PARKED',\n    # other constants\n    'ENCODING', 'ENCODING_ERRS', 'AF_INET6',\n    # named tuples\n    'pconn', 'pcputimes', 'pctxsw', 'pgids', 'pio', 'pionice', 'popenfile',\n    'pthread', 'puids', 'sconn', 'scpustats', 'sdiskio', 'sdiskpart',\n    'sdiskusage', 'snetio', 'snicaddr', 'snicstats', 'sswap', 'suser',\n    # utility functions\n    'conn_tmap', 'deprecated_method', 'isfile_strict', 'memoize',\n    'parse_environ_block', 'path_exists_strict', 'usage_percent',\n    'supports_ipv6', 'sockfam_to_enum', 'socktype_to_enum', \"wrap_numbers\",\n    'open_text', 'open_binary', 'cat', 'bcat',\n    'bytes2human', 'conn_to_ntuple', 'debug',\n    # shell utils\n    'hilite', 'term_supports_colors', 'print_color',\n]\n# fmt: on\n\n\n# ===================================================================\n# --- OS constants\n# ===================================================================\n\n\nPOSIX = os.name == \"posix\"\nWINDOWS = os.name == \"nt\"\nLINUX = sys.platform.startswith(\"linux\")\nMACOS = sys.platform.startswith(\"darwin\")\nOSX = MACOS  # deprecated alias\nFREEBSD = sys.platform.startswith((\"freebsd\", \"midnightbsd\"))\nOPENBSD = sys.platform.startswith(\"openbsd\")\nNETBSD = sys.platform.startswith(\"netbsd\")\nBSD = FREEBSD or OPENBSD or NETBSD\nSUNOS = sys.platform.startswith((\"sunos\", \"solaris\"))\nAIX = sys.platform.startswith(\"aix\")\n\n\n# ===================================================================\n# --- API constants\n# ===================================================================\n\n\n# Process.status()\nSTATUS_RUNNING = \"running\"\nSTATUS_SLEEPING = \"sleeping\"\nSTATUS_DISK_SLEEP = \"disk-sleep\"\nSTATUS_STOPPED = \"stopped\"\nSTATUS_TRACING_STOP = \"tracing-stop\"\nSTATUS_ZOMBIE = \"zombie\"\nSTATUS_DEAD = \"dead\"\nSTATUS_WAKE_KILL = \"wake-kill\"\nSTATUS_WAKING = \"waking\"\nSTATUS_IDLE = \"idle\"  # Linux, macOS, FreeBSD\nSTATUS_LOCKED = \"locked\"  # FreeBSD\nSTATUS_WAITING = \"waiting\"  # FreeBSD\nSTATUS_SUSPENDED = \"suspended\"  # NetBSD\nSTATUS_PARKED = \"parked\"  # Linux\n\n# Process.net_connections() and psutil.net_connections()\nCONN_ESTABLISHED = \"ESTABLISHED\"\nCONN_SYN_SENT = \"SYN_SENT\"\nCONN_SYN_RECV = \"SYN_RECV\"\nCONN_FIN_WAIT1 = \"FIN_WAIT1\"\nCONN_FIN_WAIT2 = \"FIN_WAIT2\"\nCONN_TIME_WAIT = \"TIME_WAIT\"\nCONN_CLOSE = \"CLOSE\"\nCONN_CLOSE_WAIT = \"CLOSE_WAIT\"\nCONN_LAST_ACK = \"LAST_ACK\"\nCONN_LISTEN = \"LISTEN\"\nCONN_CLOSING = \"CLOSING\"\nCONN_NONE = \"NONE\"\n\n# net_if_stats()\nif enum is None:\n    NIC_DUPLEX_FULL = 2\n    NIC_DUPLEX_HALF = 1\n    NIC_DUPLEX_UNKNOWN = 0\nelse:\n\n    class NicDuplex(enum.IntEnum):\n        NIC_DUPLEX_FULL = 2\n        NIC_DUPLEX_HALF = 1\n        NIC_DUPLEX_UNKNOWN = 0\n\n    globals().update(NicDuplex.__members__)\n\n# sensors_battery()\nif enum is None:\n    POWER_TIME_UNKNOWN = -1\n    POWER_TIME_UNLIMITED = -2\nelse:\n\n    class BatteryTime(enum.IntEnum):\n        POWER_TIME_UNKNOWN = -1\n        POWER_TIME_UNLIMITED = -2\n\n    globals().update(BatteryTime.__members__)\n\n# --- others\n\nENCODING = sys.getfilesystemencoding()\nif not PY3:\n    ENCODING_ERRS = \"replace\"\nelse:\n    try:\n        ENCODING_ERRS = sys.getfilesystemencodeerrors()  # py 3.6\n    except AttributeError:\n        ENCODING_ERRS = \"surrogateescape\" if POSIX else \"replace\"\n\n\n# ===================================================================\n# --- namedtuples\n# ===================================================================\n\n# --- for system functions\n\n# fmt: off\n# psutil.swap_memory()\nsswap = namedtuple('sswap', ['total', 'used', 'free', 'percent', 'sin',\n                             'sout'])\n# psutil.disk_usage()\nsdiskusage = namedtuple('sdiskusage', ['total', 'used', 'free', 'percent'])\n# psutil.disk_io_counters()\nsdiskio = namedtuple('sdiskio', ['read_count', 'write_count',\n                                 'read_bytes', 'write_bytes',\n                                 'read_time', 'write_time'])\n# psutil.disk_partitions()\nsdiskpart = namedtuple('sdiskpart', ['device', 'mountpoint', 'fstype', 'opts'])\n# psutil.net_io_counters()\nsnetio = namedtuple('snetio', ['bytes_sent', 'bytes_recv',\n                               'packets_sent', 'packets_recv',\n                               'errin', 'errout',\n                               'dropin', 'dropout'])\n# psutil.users()\nsuser = namedtuple('suser', ['name', 'terminal', 'host', 'started', 'pid'])\n# psutil.net_connections()\nsconn = namedtuple('sconn', ['fd', 'family', 'type', 'laddr', 'raddr',\n                             'status', 'pid'])\n# psutil.net_if_addrs()\nsnicaddr = namedtuple('snicaddr',\n                      ['family', 'address', 'netmask', 'broadcast', 'ptp'])\n# psutil.net_if_stats()\nsnicstats = namedtuple('snicstats',\n                       ['isup', 'duplex', 'speed', 'mtu', 'flags'])\n# psutil.cpu_stats()\nscpustats = namedtuple(\n    'scpustats', ['ctx_switches', 'interrupts', 'soft_interrupts', 'syscalls'])\n# psutil.cpu_freq()\nscpufreq = namedtuple('scpufreq', ['current', 'min', 'max'])\n# psutil.sensors_temperatures()\nshwtemp = namedtuple(\n    'shwtemp', ['label', 'current', 'high', 'critical'])\n# psutil.sensors_battery()\nsbattery = namedtuple('sbattery', ['percent', 'secsleft', 'power_plugged'])\n# psutil.sensors_fans()\nsfan = namedtuple('sfan', ['label', 'current'])\n# fmt: on\n\n# --- for Process methods\n\n# psutil.Process.cpu_times()\npcputimes = namedtuple(\n    'pcputimes', ['user', 'system', 'children_user', 'children_system']\n)\n# psutil.Process.open_files()\npopenfile = namedtuple('popenfile', ['path', 'fd'])\n# psutil.Process.threads()\npthread = namedtuple('pthread', ['id', 'user_time', 'system_time'])\n# psutil.Process.uids()\npuids = namedtuple('puids', ['real', 'effective', 'saved'])\n# psutil.Process.gids()\npgids = namedtuple('pgids', ['real', 'effective', 'saved'])\n# psutil.Process.io_counters()\npio = namedtuple(\n    'pio', ['read_count', 'write_count', 'read_bytes', 'write_bytes']\n)\n# psutil.Process.ionice()\npionice = namedtuple('pionice', ['ioclass', 'value'])\n# psutil.Process.ctx_switches()\npctxsw = namedtuple('pctxsw', ['voluntary', 'involuntary'])\n# psutil.Process.net_connections()\npconn = namedtuple(\n    'pconn', ['fd', 'family', 'type', 'laddr', 'raddr', 'status']\n)\n\n# psutil.net_connections() and psutil.Process.net_connections()\naddr = namedtuple('addr', ['ip', 'port'])\n\n\n# ===================================================================\n# --- Process.net_connections() 'kind' parameter mapping\n# ===================================================================\n\n\nconn_tmap = {\n    \"all\": ([AF_INET, AF_INET6, AF_UNIX], [SOCK_STREAM, SOCK_DGRAM]),\n    \"tcp\": ([AF_INET, AF_INET6], [SOCK_STREAM]),\n    \"tcp4\": ([AF_INET], [SOCK_STREAM]),\n    \"udp\": ([AF_INET, AF_INET6], [SOCK_DGRAM]),\n    \"udp4\": ([AF_INET], [SOCK_DGRAM]),\n    \"inet\": ([AF_INET, AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),\n    \"inet4\": ([AF_INET], [SOCK_STREAM, SOCK_DGRAM]),\n    \"inet6\": ([AF_INET6], [SOCK_STREAM, SOCK_DGRAM]),\n}\n\nif AF_INET6 is not None:\n    conn_tmap.update({\n        \"tcp6\": ([AF_INET6], [SOCK_STREAM]),\n        \"udp6\": ([AF_INET6], [SOCK_DGRAM]),\n    })\n\nif AF_UNIX is not None:\n    conn_tmap.update({\"unix\": ([AF_UNIX], [SOCK_STREAM, SOCK_DGRAM])})\n\n\n# =====================================================================\n# --- Exceptions\n# =====================================================================\n\n\nclass Error(Exception):\n    \"\"\"Base exception class. All other psutil exceptions inherit\n    from this one.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def _infodict(self, attrs):\n        info = collections.OrderedDict()\n        for name in attrs:\n            value = getattr(self, name, None)\n            if value:  # noqa\n                info[name] = value\n            elif name == \"pid\" and value == 0:\n                info[name] = value\n        return info\n\n    def __str__(self):\n        # invoked on `raise Error`\n        info = self._infodict((\"pid\", \"ppid\", \"name\"))\n        if info:\n            details = \"(%s)\" % \", \".join(\n                [\"%s=%r\" % (k, v) for k, v in info.items()]\n            )\n        else:\n            details = None\n        return \" \".join([x for x in (getattr(self, \"msg\", \"\"), details) if x])\n\n    def __repr__(self):\n        # invoked on `repr(Error)`\n        info = self._infodict((\"pid\", \"ppid\", \"name\", \"seconds\", \"msg\"))\n        details = \", \".join([\"%s=%r\" % (k, v) for k, v in info.items()])\n        return \"psutil.%s(%s)\" % (self.__class__.__name__, details)\n\n\nclass NoSuchProcess(Error):\n    \"\"\"Exception raised when a process with a certain PID doesn't\n    or no longer exists.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, pid, name=None, msg=None):\n        Error.__init__(self)\n        self.pid = pid\n        self.name = name\n        self.msg = msg or \"process no longer exists\"\n\n    def __reduce__(self):\n        return (self.__class__, (self.pid, self.name, self.msg))\n\n\nclass ZombieProcess(NoSuchProcess):\n    \"\"\"Exception raised when querying a zombie process. This is\n    raised on macOS, BSD and Solaris only, and not always: depending\n    on the query the OS may be able to succeed anyway.\n    On Linux all zombie processes are querable (hence this is never\n    raised). Windows doesn't have zombie processes.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, pid, name=None, ppid=None, msg=None):\n        NoSuchProcess.__init__(self, pid, name, msg)\n        self.ppid = ppid\n        self.msg = msg or \"PID still exists but it's a zombie\"\n\n    def __reduce__(self):\n        return (self.__class__, (self.pid, self.name, self.ppid, self.msg))\n\n\nclass AccessDenied(Error):\n    \"\"\"Exception raised when permission to perform an action is denied.\"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, pid=None, name=None, msg=None):\n        Error.__init__(self)\n        self.pid = pid\n        self.name = name\n        self.msg = msg or \"\"\n\n    def __reduce__(self):\n        return (self.__class__, (self.pid, self.name, self.msg))\n\n\nclass TimeoutExpired(Error):\n    \"\"\"Raised on Process.wait(timeout) if timeout expires and process\n    is still alive.\n    \"\"\"\n\n    __module__ = 'psutil'\n\n    def __init__(self, seconds, pid=None, name=None):\n        Error.__init__(self)\n        self.seconds = seconds\n        self.pid = pid\n        self.name = name\n        self.msg = \"timeout after %s seconds\" % seconds\n\n    def __reduce__(self):\n        return (self.__class__, (self.seconds, self.pid, self.name))\n\n\n# ===================================================================\n# --- utils\n# ===================================================================\n\n\n# This should be in _compat.py rather than here, but does not work well\n# with setup.py importing this module via a sys.path trick.\nif PY3:\n    if isinstance(__builtins__, dict):  # cpython\n        exec_ = __builtins__[\"exec\"]\n    else:  # pypy\n        exec_ = getattr(__builtins__, \"exec\")  # noqa\n\n    exec_(\"\"\"def raise_from(value, from_value):\n    try:\n        raise value from from_value\n    finally:\n        value = None\n    \"\"\")\nelse:\n\n    def raise_from(value, from_value):\n        raise value\n\n\ndef usage_percent(used, total, round_=None):\n    \"\"\"Calculate percentage usage of 'used' against 'total'.\"\"\"\n    try:\n        ret = (float(used) / total) * 100\n    except ZeroDivisionError:\n        return 0.0\n    else:\n        if round_ is not None:\n            ret = round(ret, round_)\n        return ret\n\n\ndef memoize(fun):\n    \"\"\"A simple memoize decorator for functions supporting (hashable)\n    positional arguments.\n    It also provides a cache_clear() function for clearing the cache:\n\n    >>> @memoize\n    ... def foo()\n    ...     return 1\n        ...\n    >>> foo()\n    1\n    >>> foo.cache_clear()\n    >>>\n\n    It supports:\n     - functions\n     - classes (acts as a @singleton)\n     - staticmethods\n     - classmethods\n\n    It does NOT support:\n     - methods\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = (args, frozenset(sorted(kwargs.items())))\n        try:\n            return cache[key]\n        except KeyError:\n            try:\n                ret = cache[key] = fun(*args, **kwargs)\n            except Exception as err:  # noqa: BLE001\n                raise raise_from(err, None)\n            return ret\n\n    def cache_clear():\n        \"\"\"Clear cache.\"\"\"\n        cache.clear()\n\n    cache = {}\n    wrapper.cache_clear = cache_clear\n    return wrapper\n\n\ndef memoize_when_activated(fun):\n    \"\"\"A memoize decorator which is disabled by default. It can be\n    activated and deactivated on request.\n    For efficiency reasons it can be used only against class methods\n    accepting no arguments.\n\n    >>> class Foo:\n    ...     @memoize\n    ...     def foo()\n    ...         print(1)\n    ...\n    >>> f = Foo()\n    >>> # deactivated (default)\n    >>> foo()\n    1\n    >>> foo()\n    1\n    >>>\n    >>> # activated\n    >>> foo.cache_activate(self)\n    >>> foo()\n    1\n    >>> foo()\n    >>> foo()\n    >>>\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self):\n        try:\n            # case 1: we previously entered oneshot() ctx\n            ret = self._cache[fun]\n        except AttributeError:\n            # case 2: we never entered oneshot() ctx\n            try:\n                return fun(self)\n            except Exception as err:  # noqa: BLE001\n                raise raise_from(err, None)\n        except KeyError:\n            # case 3: we entered oneshot() ctx but there's no cache\n            # for this entry yet\n            try:\n                ret = fun(self)\n            except Exception as err:  # noqa: BLE001\n                raise raise_from(err, None)\n            try:\n                self._cache[fun] = ret\n            except AttributeError:\n                # multi-threading race condition, see:\n                # https://github.com/giampaolo/psutil/issues/1948\n                pass\n        return ret\n\n    def cache_activate(proc):\n        \"\"\"Activate cache. Expects a Process instance. Cache will be\n        stored as a \"_cache\" instance attribute.\n        \"\"\"\n        proc._cache = {}\n\n    def cache_deactivate(proc):\n        \"\"\"Deactivate and clear cache.\"\"\"\n        try:\n            del proc._cache\n        except AttributeError:\n            pass\n\n    wrapper.cache_activate = cache_activate\n    wrapper.cache_deactivate = cache_deactivate\n    return wrapper\n\n\ndef isfile_strict(path):\n    \"\"\"Same as os.path.isfile() but does not swallow EACCES / EPERM\n    exceptions, see:\n    http://mail.python.org/pipermail/python-dev/2012-June/120787.html.\n    \"\"\"\n    try:\n        st = os.stat(path)\n    except OSError as err:\n        if err.errno in (errno.EPERM, errno.EACCES):\n            raise\n        return False\n    else:\n        return stat.S_ISREG(st.st_mode)\n\n\ndef path_exists_strict(path):\n    \"\"\"Same as os.path.exists() but does not swallow EACCES / EPERM\n    exceptions. See:\n    http://mail.python.org/pipermail/python-dev/2012-June/120787.html.\n    \"\"\"\n    try:\n        os.stat(path)\n    except OSError as err:\n        if err.errno in (errno.EPERM, errno.EACCES):\n            raise\n        return False\n    else:\n        return True\n\n\n@memoize\ndef supports_ipv6():\n    \"\"\"Return True if IPv6 is supported on this platform.\"\"\"\n    if not socket.has_ipv6 or AF_INET6 is None:\n        return False\n    try:\n        sock = socket.socket(AF_INET6, socket.SOCK_STREAM)\n        with contextlib.closing(sock):\n            sock.bind((\"::1\", 0))\n        return True\n    except socket.error:\n        return False\n\n\ndef parse_environ_block(data):\n    \"\"\"Parse a C environ block of environment variables into a dictionary.\"\"\"\n    # The block is usually raw data from the target process.  It might contain\n    # trailing garbage and lines that do not look like assignments.\n    ret = {}\n    pos = 0\n\n    # localize global variable to speed up access.\n    WINDOWS_ = WINDOWS\n    while True:\n        next_pos = data.find(\"\\0\", pos)\n        # nul byte at the beginning or double nul byte means finish\n        if next_pos <= pos:\n            break\n        # there might not be an equals sign\n        equal_pos = data.find(\"=\", pos, next_pos)\n        if equal_pos > pos:\n            key = data[pos:equal_pos]\n            value = data[equal_pos + 1 : next_pos]\n            # Windows expects environment variables to be uppercase only\n            if WINDOWS_:\n                key = key.upper()\n            ret[key] = value\n        pos = next_pos + 1\n\n    return ret\n\n\ndef sockfam_to_enum(num):\n    \"\"\"Convert a numeric socket family value to an IntEnum member.\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    if enum is None:\n        return num\n    else:  # pragma: no cover\n        try:\n            return socket.AddressFamily(num)\n        except ValueError:\n            return num\n\n\ndef socktype_to_enum(num):\n    \"\"\"Convert a numeric socket type value to an IntEnum member.\n    If it's not a known member, return the numeric value itself.\n    \"\"\"\n    if enum is None:\n        return num\n    else:  # pragma: no cover\n        try:\n            return socket.SocketKind(num)\n        except ValueError:\n            return num\n\n\ndef conn_to_ntuple(fd, fam, type_, laddr, raddr, status, status_map, pid=None):\n    \"\"\"Convert a raw connection tuple to a proper ntuple.\"\"\"\n    if fam in (socket.AF_INET, AF_INET6):\n        if laddr:\n            laddr = addr(*laddr)\n        if raddr:\n            raddr = addr(*raddr)\n    if type_ == socket.SOCK_STREAM and fam in (AF_INET, AF_INET6):\n        status = status_map.get(status, CONN_NONE)\n    else:\n        status = CONN_NONE  # ignore whatever C returned to us\n    fam = sockfam_to_enum(fam)\n    type_ = socktype_to_enum(type_)\n    if pid is None:\n        return pconn(fd, fam, type_, laddr, raddr, status)\n    else:\n        return sconn(fd, fam, type_, laddr, raddr, status, pid)\n\n\ndef deprecated_method(replacement):\n    \"\"\"A decorator which can be used to mark a method as deprecated\n    'replcement' is the method name which will be called instead.\n    \"\"\"\n\n    def outer(fun):\n        msg = \"%s() is deprecated and will be removed; use %s() instead\" % (\n            fun.__name__,\n            replacement,\n        )\n        if fun.__doc__ is None:\n            fun.__doc__ = msg\n\n        @functools.wraps(fun)\n        def inner(self, *args, **kwargs):\n            warnings.warn(msg, category=DeprecationWarning, stacklevel=2)\n            return getattr(self, replacement)(*args, **kwargs)\n\n        return inner\n\n    return outer\n\n\nclass _WrapNumbers:\n    \"\"\"Watches numbers so that they don't overflow and wrap\n    (reset to zero).\n    \"\"\"\n\n    def __init__(self):\n        self.lock = threading.Lock()\n        self.cache = {}\n        self.reminders = {}\n        self.reminder_keys = {}\n\n    def _add_dict(self, input_dict, name):\n        assert name not in self.cache\n        assert name not in self.reminders\n        assert name not in self.reminder_keys\n        self.cache[name] = input_dict\n        self.reminders[name] = collections.defaultdict(int)\n        self.reminder_keys[name] = collections.defaultdict(set)\n\n    def _remove_dead_reminders(self, input_dict, name):\n        \"\"\"In case the number of keys changed between calls (e.g. a\n        disk disappears) this removes the entry from self.reminders.\n        \"\"\"\n        old_dict = self.cache[name]\n        gone_keys = set(old_dict.keys()) - set(input_dict.keys())\n        for gone_key in gone_keys:\n            for remkey in self.reminder_keys[name][gone_key]:\n                del self.reminders[name][remkey]\n            del self.reminder_keys[name][gone_key]\n\n    def run(self, input_dict, name):\n        \"\"\"Cache dict and sum numbers which overflow and wrap.\n        Return an updated copy of `input_dict`.\n        \"\"\"\n        if name not in self.cache:\n            # This was the first call.\n            self._add_dict(input_dict, name)\n            return input_dict\n\n        self._remove_dead_reminders(input_dict, name)\n\n        old_dict = self.cache[name]\n        new_dict = {}\n        for key in input_dict:\n            input_tuple = input_dict[key]\n            try:\n                old_tuple = old_dict[key]\n            except KeyError:\n                # The input dict has a new key (e.g. a new disk or NIC)\n                # which didn't exist in the previous call.\n                new_dict[key] = input_tuple\n                continue\n\n            bits = []\n            for i in range(len(input_tuple)):\n                input_value = input_tuple[i]\n                old_value = old_tuple[i]\n                remkey = (key, i)\n                if input_value < old_value:\n                    # it wrapped!\n                    self.reminders[name][remkey] += old_value\n                    self.reminder_keys[name][key].add(remkey)\n                bits.append(input_value + self.reminders[name][remkey])\n\n            new_dict[key] = tuple(bits)\n\n        self.cache[name] = input_dict\n        return new_dict\n\n    def cache_clear(self, name=None):\n        \"\"\"Clear the internal cache, optionally only for function 'name'.\"\"\"\n        with self.lock:\n            if name is None:\n                self.cache.clear()\n                self.reminders.clear()\n                self.reminder_keys.clear()\n            else:\n                self.cache.pop(name, None)\n                self.reminders.pop(name, None)\n                self.reminder_keys.pop(name, None)\n\n    def cache_info(self):\n        \"\"\"Return internal cache dicts as a tuple of 3 elements.\"\"\"\n        with self.lock:\n            return (self.cache, self.reminders, self.reminder_keys)\n\n\ndef wrap_numbers(input_dict, name):\n    \"\"\"Given an `input_dict` and a function `name`, adjust the numbers\n    which \"wrap\" (restart from zero) across different calls by adding\n    \"old value\" to \"new value\" and return an updated dict.\n    \"\"\"\n    with _wn.lock:\n        return _wn.run(input_dict, name)\n\n\n_wn = _WrapNumbers()\nwrap_numbers.cache_clear = _wn.cache_clear\nwrap_numbers.cache_info = _wn.cache_info\n\n\n# The read buffer size for open() builtin. This (also) dictates how\n# much data we read(2) when iterating over file lines as in:\n#   >>> with open(file) as f:\n#   ...    for line in f:\n#   ...        ...\n# Default per-line buffer size for binary files is 1K. For text files\n# is 8K. We use a bigger buffer (32K) in order to have more consistent\n# results when reading /proc pseudo files on Linux, see:\n# https://github.com/giampaolo/psutil/issues/2050\n# On Python 2 this also speeds up the reading of big files:\n# (namely /proc/{pid}/smaps and /proc/net/*):\n# https://github.com/giampaolo/psutil/issues/708\nFILE_READ_BUFFER_SIZE = 32 * 1024\n\n\ndef open_binary(fname):\n    return open(fname, \"rb\", buffering=FILE_READ_BUFFER_SIZE)\n\n\ndef open_text(fname):\n    \"\"\"On Python 3 opens a file in text mode by using fs encoding and\n    a proper en/decoding errors handler.\n    On Python 2 this is just an alias for open(name, 'rt').\n    \"\"\"\n    if not PY3:\n        return open(fname, buffering=FILE_READ_BUFFER_SIZE)\n\n    # See:\n    # https://github.com/giampaolo/psutil/issues/675\n    # https://github.com/giampaolo/psutil/pull/733\n    fobj = open(\n        fname,\n        buffering=FILE_READ_BUFFER_SIZE,\n        encoding=ENCODING,\n        errors=ENCODING_ERRS,\n    )\n    try:\n        # Dictates per-line read(2) buffer size. Defaults is 8k. See:\n        # https://github.com/giampaolo/psutil/issues/2050#issuecomment-1013387546\n        fobj._CHUNK_SIZE = FILE_READ_BUFFER_SIZE\n    except AttributeError:\n        pass\n    except Exception:\n        fobj.close()\n        raise\n\n    return fobj\n\n\ndef cat(fname, fallback=_DEFAULT, _open=open_text):\n    \"\"\"Read entire file content and return it as a string. File is\n    opened in text mode. If specified, `fallback` is the value\n    returned in case of error, either if the file does not exist or\n    it can't be read().\n    \"\"\"\n    if fallback is _DEFAULT:\n        with _open(fname) as f:\n            return f.read()\n    else:\n        try:\n            with _open(fname) as f:\n                return f.read()\n        except (IOError, OSError):\n            return fallback\n\n\ndef bcat(fname, fallback=_DEFAULT):\n    \"\"\"Same as above but opens file in binary mode.\"\"\"\n    return cat(fname, fallback=fallback, _open=open_binary)\n\n\ndef bytes2human(n, format=\"%(value).1f%(symbol)s\"):\n    \"\"\"Used by various scripts. See: http://goo.gl/zeJZl.\n\n    >>> bytes2human(10000)\n    '9.8K'\n    >>> bytes2human(100001221)\n    '95.4M'\n    \"\"\"\n    symbols = ('B', 'K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')\n    prefix = {}\n    for i, s in enumerate(symbols[1:]):\n        prefix[s] = 1 << (i + 1) * 10\n    for symbol in reversed(symbols[1:]):\n        if abs(n) >= prefix[symbol]:\n            value = float(n) / prefix[symbol]\n            return format % locals()\n    return format % dict(symbol=symbols[0], value=n)\n\n\ndef get_procfs_path():\n    \"\"\"Return updated psutil.PROCFS_PATH constant.\"\"\"\n    return sys.modules['psutil'].PROCFS_PATH\n\n\nif PY3:\n\n    def decode(s):\n        return s.decode(encoding=ENCODING, errors=ENCODING_ERRS)\n\nelse:\n\n    def decode(s):\n        return s\n\n\n# =====================================================================\n# --- shell utils\n# =====================================================================\n\n\n@memoize\ndef term_supports_colors(file=sys.stdout):  # pragma: no cover\n    if os.name == 'nt':\n        return True\n    try:\n        import curses\n\n        assert file.isatty()\n        curses.setupterm()\n        assert curses.tigetnum(\"colors\") > 0\n    except Exception:  # noqa: BLE001\n        return False\n    else:\n        return True\n\n\ndef hilite(s, color=None, bold=False):  # pragma: no cover\n    \"\"\"Return an highlighted version of 'string'.\"\"\"\n    if not term_supports_colors():\n        return s\n    attr = []\n    colors = dict(\n        blue='34',\n        brown='33',\n        darkgrey='30',\n        green='32',\n        grey='37',\n        lightblue='36',\n        red='91',\n        violet='35',\n        yellow='93',\n    )\n    colors[None] = '29'\n    try:\n        color = colors[color]\n    except KeyError:\n        raise ValueError(\n            \"invalid color %r; choose between %s\" % (list(colors.keys()))\n        )\n    attr.append(color)\n    if bold:\n        attr.append('1')\n    return '\\x1b[%sm%s\\x1b[0m' % (';'.join(attr), s)\n\n\ndef print_color(\n    s, color=None, bold=False, file=sys.stdout\n):  # pragma: no cover\n    \"\"\"Print a colorized version of string.\"\"\"\n    if not term_supports_colors():\n        print(s, file=file)  # NOQA\n    elif POSIX:\n        print(hilite(s, color, bold), file=file)  # NOQA\n    else:\n        import ctypes\n\n        DEFAULT_COLOR = 7\n        GetStdHandle = ctypes.windll.Kernel32.GetStdHandle\n        SetConsoleTextAttribute = (\n            ctypes.windll.Kernel32.SetConsoleTextAttribute\n        )\n\n        colors = dict(green=2, red=4, brown=6, yellow=6)\n        colors[None] = DEFAULT_COLOR\n        try:\n            color = colors[color]\n        except KeyError:\n            raise ValueError(\n                \"invalid color %r; choose between %r\"\n                % (color, list(colors.keys()))\n            )\n        if bold and color <= 7:\n            color += 8\n\n        handle_id = -12 if file is sys.stderr else -11\n        GetStdHandle.restype = ctypes.c_ulong\n        handle = GetStdHandle(handle_id)\n        SetConsoleTextAttribute(handle, color)\n        try:\n            print(s, file=file)  # NOQA\n        finally:\n            SetConsoleTextAttribute(handle, DEFAULT_COLOR)\n\n\ndef debug(msg):\n    \"\"\"If PSUTIL_DEBUG env var is set, print a debug message to stderr.\"\"\"\n    if PSUTIL_DEBUG:\n        import inspect\n\n        fname, lineno, _, _lines, _index = inspect.getframeinfo(\n            inspect.currentframe().f_back\n        )\n        if isinstance(msg, Exception):\n            if isinstance(msg, (OSError, IOError, EnvironmentError)):\n                # ...because str(exc) may contain info about the file name\n                msg = \"ignoring %s\" % msg\n            else:\n                msg = \"ignoring %r\" % msg\n        print(  # noqa\n            \"psutil-debug [%s:%s]> %s\" % (fname, lineno, msg), file=sys.stderr\n        )\n", "psutil/_psposix.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Routines common to all posix systems.\"\"\"\n\nimport glob\nimport os\nimport signal\nimport sys\nimport time\n\nfrom ._common import MACOS\nfrom ._common import TimeoutExpired\nfrom ._common import memoize\nfrom ._common import sdiskusage\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import ChildProcessError\nfrom ._compat import FileNotFoundError\nfrom ._compat import InterruptedError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import unicode\n\n\nif MACOS:\n    from . import _psutil_osx\n\n\nif PY3:\n    import enum\nelse:\n    enum = None\n\n\n__all__ = ['pid_exists', 'wait_pid', 'disk_usage', 'get_terminal_map']\n\n\ndef pid_exists(pid):\n    \"\"\"Check whether pid exists in the current process table.\"\"\"\n    if pid == 0:\n        # According to \"man 2 kill\" PID 0 has a special meaning:\n        # it refers to <<every process in the process group of the\n        # calling process>> so we don't want to go any further.\n        # If we get here it means this UNIX platform *does* have\n        # a process with id 0.\n        return True\n    try:\n        os.kill(pid, 0)\n    except ProcessLookupError:\n        return False\n    except PermissionError:\n        # EPERM clearly means there's a process to deny access to\n        return True\n    # According to \"man 2 kill\" possible error values are\n    # (EINVAL, EPERM, ESRCH)\n    else:\n        return True\n\n\n# Python 3.5 signals enum (contributed by me ^^):\n# https://bugs.python.org/issue21076\nif enum is not None and hasattr(signal, \"Signals\"):\n    Negsignal = enum.IntEnum(\n        'Negsignal', dict([(x.name, -x.value) for x in signal.Signals])\n    )\n\n    def negsig_to_enum(num):\n        \"\"\"Convert a negative signal value to an enum.\"\"\"\n        try:\n            return Negsignal(num)\n        except ValueError:\n            return num\n\nelse:  # pragma: no cover\n\n    def negsig_to_enum(num):\n        return num\n\n\ndef wait_pid(\n    pid,\n    timeout=None,\n    proc_name=None,\n    _waitpid=os.waitpid,\n    _timer=getattr(time, 'monotonic', time.time),  # noqa: B008\n    _min=min,\n    _sleep=time.sleep,\n    _pid_exists=pid_exists,\n):\n    \"\"\"Wait for a process PID to terminate.\n\n    If the process terminated normally by calling exit(3) or _exit(2),\n    or by returning from main(), the return value is the positive integer\n    passed to *exit().\n\n    If it was terminated by a signal it returns the negated value of the\n    signal which caused the termination (e.g. -SIGTERM).\n\n    If PID is not a children of os.getpid() (current process) just\n    wait until the process disappears and return None.\n\n    If PID does not exist at all return None immediately.\n\n    If *timeout* != None and process is still alive raise TimeoutExpired.\n    timeout=0 is also possible (either return immediately or raise).\n    \"\"\"\n    if pid <= 0:\n        # see \"man waitpid\"\n        msg = \"can't wait for PID 0\"\n        raise ValueError(msg)\n    interval = 0.0001\n    flags = 0\n    if timeout is not None:\n        flags |= os.WNOHANG\n        stop_at = _timer() + timeout\n\n    def sleep(interval):\n        # Sleep for some time and return a new increased interval.\n        if timeout is not None:\n            if _timer() >= stop_at:\n                raise TimeoutExpired(timeout, pid=pid, name=proc_name)\n        _sleep(interval)\n        return _min(interval * 2, 0.04)\n\n    # See: https://linux.die.net/man/2/waitpid\n    while True:\n        try:\n            retpid, status = os.waitpid(pid, flags)\n        except InterruptedError:\n            interval = sleep(interval)\n        except ChildProcessError:\n            # This has two meanings:\n            # - PID is not a child of os.getpid() in which case\n            #   we keep polling until it's gone\n            # - PID never existed in the first place\n            # In both cases we'll eventually return None as we\n            # can't determine its exit status code.\n            while _pid_exists(pid):\n                interval = sleep(interval)\n            return\n        else:\n            if retpid == 0:\n                # WNOHANG flag was used and PID is still running.\n                interval = sleep(interval)\n                continue\n\n            if os.WIFEXITED(status):\n                # Process terminated normally by calling exit(3) or _exit(2),\n                # or by returning from main(). The return value is the\n                # positive integer passed to *exit().\n                return os.WEXITSTATUS(status)\n            elif os.WIFSIGNALED(status):\n                # Process exited due to a signal. Return the negative value\n                # of that signal.\n                return negsig_to_enum(-os.WTERMSIG(status))\n            # elif os.WIFSTOPPED(status):\n            #     # Process was stopped via SIGSTOP or is being traced, and\n            #     # waitpid() was called with WUNTRACED flag. PID is still\n            #     # alive. From now on waitpid() will keep returning (0, 0)\n            #     # until the process state doesn't change.\n            #     # It may make sense to catch/enable this since stopped PIDs\n            #     # ignore SIGTERM.\n            #     interval = sleep(interval)\n            #     continue\n            # elif os.WIFCONTINUED(status):\n            #     # Process was resumed via SIGCONT and waitpid() was called\n            #     # with WCONTINUED flag.\n            #     interval = sleep(interval)\n            #     continue\n            else:\n                # Should never happen.\n                raise ValueError(\"unknown process exit status %r\" % status)\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage associated with path.\n    Note: UNIX usually reserves 5% disk space which is not accessible\n    by user. In this function \"total\" and \"used\" values reflect the\n    total and used disk space whereas \"free\" and \"percent\" represent\n    the \"free\" and \"used percent\" user disk space.\n    \"\"\"\n    if PY3:\n        st = os.statvfs(path)\n    else:  # pragma: no cover\n        # os.statvfs() does not support unicode on Python 2:\n        # - https://github.com/giampaolo/psutil/issues/416\n        # - http://bugs.python.org/issue18695\n        try:\n            st = os.statvfs(path)\n        except UnicodeEncodeError:\n            if isinstance(path, unicode):\n                try:\n                    path = path.encode(sys.getfilesystemencoding())\n                except UnicodeEncodeError:\n                    pass\n                st = os.statvfs(path)\n            else:\n                raise\n\n    # Total space which is only available to root (unless changed\n    # at system level).\n    total = st.f_blocks * st.f_frsize\n    # Remaining free space usable by root.\n    avail_to_root = st.f_bfree * st.f_frsize\n    # Remaining free space usable by user.\n    avail_to_user = st.f_bavail * st.f_frsize\n    # Total space being used in general.\n    used = total - avail_to_root\n    if MACOS:\n        # see: https://github.com/giampaolo/psutil/pull/2152\n        used = _psutil_osx.disk_usage_used(path, used)\n    # Total space which is available to user (same as 'total' but\n    # for the user).\n    total_user = used + avail_to_user\n    # User usage percent compared to the total amount of space\n    # the user can use. This number would be higher if compared\n    # to root's because the user has less space (usually -5%).\n    usage_percent_user = usage_percent(used, total_user, round_=1)\n\n    # NB: the percentage is -5% than what shown by df due to\n    # reserved blocks that we are currently not considering:\n    # https://github.com/giampaolo/psutil/issues/829#issuecomment-223750462\n    return sdiskusage(\n        total=total, used=used, free=avail_to_user, percent=usage_percent_user\n    )\n\n\n@memoize\ndef get_terminal_map():\n    \"\"\"Get a map of device-id -> path as a dict.\n    Used by Process.terminal().\n    \"\"\"\n    ret = {}\n    ls = glob.glob('/dev/tty*') + glob.glob('/dev/pts/*')\n    for name in ls:\n        assert name not in ret, name\n        try:\n            ret[os.stat(name).st_rdev] = name\n        except FileNotFoundError:\n            pass\n    return ret\n", "psutil/_psbsd.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"FreeBSD, OpenBSD and NetBSD platforms implementation.\"\"\"\n\nimport contextlib\nimport errno\nimport functools\nimport os\nfrom collections import defaultdict\nfrom collections import namedtuple\nfrom xml.etree import ElementTree\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_bsd as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import FREEBSD\nfrom ._common import NETBSD\nfrom ._common import OPENBSD\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import conn_tmap\nfrom ._common import conn_to_ntuple\nfrom ._common import debug\nfrom ._common import memoize\nfrom ._common import memoize_when_activated\nfrom ._common import usage_percent\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import which\n\n\n__extra__all__ = []\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nif FREEBSD:\n    PROC_STATUSES = {\n        cext.SIDL: _common.STATUS_IDLE,\n        cext.SRUN: _common.STATUS_RUNNING,\n        cext.SSLEEP: _common.STATUS_SLEEPING,\n        cext.SSTOP: _common.STATUS_STOPPED,\n        cext.SZOMB: _common.STATUS_ZOMBIE,\n        cext.SWAIT: _common.STATUS_WAITING,\n        cext.SLOCK: _common.STATUS_LOCKED,\n    }\nelif OPENBSD:\n    PROC_STATUSES = {\n        cext.SIDL: _common.STATUS_IDLE,\n        cext.SSLEEP: _common.STATUS_SLEEPING,\n        cext.SSTOP: _common.STATUS_STOPPED,\n        # According to /usr/include/sys/proc.h SZOMB is unused.\n        # test_zombie_process() shows that SDEAD is the right\n        # equivalent. Also it appears there's no equivalent of\n        # psutil.STATUS_DEAD. SDEAD really means STATUS_ZOMBIE.\n        # cext.SZOMB: _common.STATUS_ZOMBIE,\n        cext.SDEAD: _common.STATUS_ZOMBIE,\n        cext.SZOMB: _common.STATUS_ZOMBIE,\n        # From http://www.eecs.harvard.edu/~margo/cs161/videos/proc.h.txt\n        # OpenBSD has SRUN and SONPROC: SRUN indicates that a process\n        # is runnable but *not* yet running, i.e. is on a run queue.\n        # SONPROC indicates that the process is actually executing on\n        # a CPU, i.e. it is no longer on a run queue.\n        # As such we'll map SRUN to STATUS_WAKING and SONPROC to\n        # STATUS_RUNNING\n        cext.SRUN: _common.STATUS_WAKING,\n        cext.SONPROC: _common.STATUS_RUNNING,\n    }\nelif NETBSD:\n    PROC_STATUSES = {\n        cext.SIDL: _common.STATUS_IDLE,\n        cext.SSLEEP: _common.STATUS_SLEEPING,\n        cext.SSTOP: _common.STATUS_STOPPED,\n        cext.SZOMB: _common.STATUS_ZOMBIE,\n        cext.SRUN: _common.STATUS_WAKING,\n        cext.SONPROC: _common.STATUS_RUNNING,\n    }\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RECEIVED: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nPAGESIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\n\nHAS_PER_CPU_TIMES = hasattr(cext, \"per_cpu_times\")\nHAS_PROC_NUM_THREADS = hasattr(cext, \"proc_num_threads\")\nHAS_PROC_OPEN_FILES = hasattr(cext, 'proc_open_files')\nHAS_PROC_NUM_FDS = hasattr(cext, 'proc_num_fds')\n\nkinfo_proc_map = dict(\n    ppid=0,\n    status=1,\n    real_uid=2,\n    effective_uid=3,\n    saved_uid=4,\n    real_gid=5,\n    effective_gid=6,\n    saved_gid=7,\n    ttynr=8,\n    create_time=9,\n    ctx_switches_vol=10,\n    ctx_switches_unvol=11,\n    read_io_count=12,\n    write_io_count=13,\n    user_time=14,\n    sys_time=15,\n    ch_user_time=16,\n    ch_sys_time=17,\n    rss=18,\n    vms=19,\n    memtext=20,\n    memdata=21,\n    memstack=22,\n    cpunum=23,\n    name=24,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.virtual_memory()\nsvmem = namedtuple(\n    'svmem', ['total', 'available', 'percent', 'used', 'free',\n              'active', 'inactive', 'buffers', 'cached', 'shared', 'wired'])\n# psutil.cpu_times()\nscputimes = namedtuple(\n    'scputimes', ['user', 'nice', 'system', 'idle', 'irq'])\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms', 'text', 'data', 'stack'])\n# psutil.Process.memory_full_info()\npfullmem = pmem\n# psutil.Process.cpu_times()\npcputimes = namedtuple('pcputimes',\n                       ['user', 'system', 'children_user', 'children_system'])\n# psutil.Process.memory_maps(grouped=True)\npmmap_grouped = namedtuple(\n    'pmmap_grouped', 'path rss, private, ref_count, shadow_count')\n# psutil.Process.memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr, perms path rss, private, ref_count, shadow_count')\n# psutil.disk_io_counters()\nif FREEBSD:\n    sdiskio = namedtuple('sdiskio', ['read_count', 'write_count',\n                                     'read_bytes', 'write_bytes',\n                                     'read_time', 'write_time',\n                                     'busy_time'])\nelse:\n    sdiskio = namedtuple('sdiskio', ['read_count', 'write_count',\n                                     'read_bytes', 'write_bytes'])\n# fmt: on\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    mem = cext.virtual_mem()\n    if NETBSD:\n        total, free, active, inactive, wired, cached = mem\n        # On NetBSD buffers and shared mem is determined via /proc.\n        # The C ext set them to 0.\n        with open('/proc/meminfo', 'rb') as f:\n            for line in f:\n                if line.startswith(b'Buffers:'):\n                    buffers = int(line.split()[1]) * 1024\n                elif line.startswith(b'MemShared:'):\n                    shared = int(line.split()[1]) * 1024\n        # Before avail was calculated as (inactive + cached + free),\n        # same as zabbix, but it turned out it could exceed total (see\n        # #2233), so zabbix seems to be wrong. Htop calculates it\n        # differently, and the used value seem more realistic, so let's\n        # match htop.\n        # https://github.com/htop-dev/htop/blob/e7f447b/netbsd/NetBSDProcessList.c#L162  # noqa\n        # https://github.com/zabbix/zabbix/blob/af5e0f8/src/libs/zbxsysinfo/netbsd/memory.c#L135  # noqa\n        used = active + wired\n        avail = total - used\n    else:\n        total, free, active, inactive, wired, cached, buffers, shared = mem\n        # matches freebsd-memory CLI:\n        # * https://people.freebsd.org/~rse/dist/freebsd-memory\n        # * https://www.cyberciti.biz/files/scripts/freebsd-memory.pl.txt\n        # matches zabbix:\n        # * https://github.com/zabbix/zabbix/blob/af5e0f8/src/libs/zbxsysinfo/freebsd/memory.c#L143  # noqa\n        avail = inactive + cached + free\n        used = active + wired + cached\n\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(\n        total,\n        avail,\n        percent,\n        used,\n        free,\n        active,\n        inactive,\n        buffers,\n        cached,\n        shared,\n        wired,\n    )\n\n\ndef swap_memory():\n    \"\"\"System swap memory as (total, used, free, sin, sout) namedtuple.\"\"\"\n    total, used, free, sin, sout = cext.swap_mem()\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system per-CPU times as a namedtuple.\"\"\"\n    user, nice, system, idle, irq = cext.cpu_times()\n    return scputimes(user, nice, system, idle, irq)\n\n\nif HAS_PER_CPU_TIMES:\n\n    def per_cpu_times():\n        \"\"\"Return system CPU times as a namedtuple.\"\"\"\n        ret = []\n        for cpu_t in cext.per_cpu_times():\n            user, nice, system, idle, irq = cpu_t\n            item = scputimes(user, nice, system, idle, irq)\n            ret.append(item)\n        return ret\n\nelse:\n    # XXX\n    # Ok, this is very dirty.\n    # On FreeBSD < 8 we cannot gather per-cpu information, see:\n    # https://github.com/giampaolo/psutil/issues/226\n    # If num cpus > 1, on first call we return single cpu times to avoid a\n    # crash at psutil import time.\n    # Next calls will fail with NotImplementedError\n    def per_cpu_times():\n        \"\"\"Return system CPU times as a namedtuple.\"\"\"\n        if cpu_count_logical() == 1:\n            return [cpu_times()]\n        if per_cpu_times.__called__:\n            msg = \"supported only starting from FreeBSD 8\"\n            raise NotImplementedError(msg)\n        per_cpu_times.__called__ = True\n        return [cpu_times()]\n\n    per_cpu_times.__called__ = False\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    return cext.cpu_count_logical()\n\n\nif OPENBSD or NETBSD:\n\n    def cpu_count_cores():\n        # OpenBSD and NetBSD do not implement this.\n        return 1 if cpu_count_logical() == 1 else None\n\nelse:\n\n    def cpu_count_cores():\n        \"\"\"Return the number of CPU cores in the system.\"\"\"\n        # From the C module we'll get an XML string similar to this:\n        # http://manpages.ubuntu.com/manpages/precise/man4/smp.4freebsd.html\n        # We may get None in case \"sysctl kern.sched.topology_spec\"\n        # is not supported on this BSD version, in which case we'll mimic\n        # os.cpu_count() and return None.\n        ret = None\n        s = cext.cpu_topology()\n        if s is not None:\n            # get rid of padding chars appended at the end of the string\n            index = s.rfind(\"</groups>\")\n            if index != -1:\n                s = s[: index + 9]\n                root = ElementTree.fromstring(s)\n                try:\n                    ret = len(root.findall('group/children/group/cpu')) or None\n                finally:\n                    # needed otherwise it will memleak\n                    root.clear()\n        if not ret:\n            # If logical CPUs == 1 it's obvious we' have only 1 core.\n            if cpu_count_logical() == 1:\n                return 1\n        return ret\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    if FREEBSD:\n        # Note: the C ext is returning some metrics we are not exposing:\n        # traps.\n        ctxsw, intrs, soft_intrs, syscalls, _traps = cext.cpu_stats()\n    elif NETBSD:\n        # XXX\n        # Note about intrs: the C extension returns 0. intrs\n        # can be determined via /proc/stat; it has the same value as\n        # soft_intrs thought so the kernel is faking it (?).\n        #\n        # Note about syscalls: the C extension always sets it to 0 (?).\n        #\n        # Note: the C ext is returning some metrics we are not exposing:\n        # traps, faults and forks.\n        ctxsw, intrs, soft_intrs, syscalls, _traps, _faults, _forks = (\n            cext.cpu_stats()\n        )\n        with open('/proc/stat', 'rb') as f:\n            for line in f:\n                if line.startswith(b'intr'):\n                    intrs = int(line.split()[1])\n    elif OPENBSD:\n        # Note: the C ext is returning some metrics we are not exposing:\n        # traps, faults and forks.\n        ctxsw, intrs, soft_intrs, syscalls, _traps, _faults, _forks = (\n            cext.cpu_stats()\n        )\n    return _common.scpustats(ctxsw, intrs, soft_intrs, syscalls)\n\n\nif FREEBSD:\n\n    def cpu_freq():\n        \"\"\"Return frequency metrics for CPUs. As of Dec 2018 only\n        CPU 0 appears to be supported by FreeBSD and all other cores\n        match the frequency of CPU 0.\n        \"\"\"\n        ret = []\n        num_cpus = cpu_count_logical()\n        for cpu in range(num_cpus):\n            try:\n                current, available_freq = cext.cpu_freq(cpu)\n            except NotImplementedError:\n                continue\n            if available_freq:\n                try:\n                    min_freq = int(available_freq.split(\" \")[-1].split(\"/\")[0])\n                except (IndexError, ValueError):\n                    min_freq = None\n                try:\n                    max_freq = int(available_freq.split(\" \")[0].split(\"/\")[0])\n                except (IndexError, ValueError):\n                    max_freq = None\n            ret.append(_common.scpufreq(current, min_freq, max_freq))\n        return ret\n\nelif OPENBSD:\n\n    def cpu_freq():\n        curr = float(cext.cpu_freq())\n        return [_common.scpufreq(curr, 0.0, 0.0)]\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted disk partitions as a list of namedtuples.\n    'all' argument is ignored, see:\n    https://github.com/giampaolo/psutil/issues/906.\n    \"\"\"\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\ndisk_usage = _psposix.disk_usage\ndisk_io_counters = cext.disk_io_counters\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_io_counters = cext.net_io_counters\nnet_if_addrs = cext_posix.net_if_addrs\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    names = net_io_counters().keys()\n    ret = {}\n    for name in names:\n        try:\n            mtu = cext_posix.net_if_mtu(name)\n            flags = cext_posix.net_if_flags(name)\n            duplex, speed = cext_posix.net_if_duplex_speed(name)\n        except OSError as err:\n            # https://github.com/giampaolo/psutil/issues/1279\n            if err.errno != errno.ENODEV:\n                raise\n        else:\n            if hasattr(_common, 'NicDuplex'):\n                duplex = _common.NicDuplex(duplex)\n            output_flags = ','.join(flags)\n            isup = 'running' in flags\n            ret[name] = _common.snicstats(\n                isup, duplex, speed, mtu, output_flags\n            )\n    return ret\n\n\ndef net_connections(kind):\n    \"\"\"System-wide network connections.\"\"\"\n    if kind not in _common.conn_tmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in conn_tmap]))\n        )\n    families, types = conn_tmap[kind]\n    ret = set()\n\n    if OPENBSD:\n        rawlist = cext.net_connections(-1, families, types)\n    elif NETBSD:\n        rawlist = cext.net_connections(-1, kind)\n    else:  # FreeBSD\n        rawlist = cext.net_connections(families, types)\n\n    for item in rawlist:\n        fd, fam, type, laddr, raddr, status, pid = item\n        nt = conn_to_ntuple(\n            fd, fam, type, laddr, raddr, status, TCP_STATUSES, pid\n        )\n        ret.add(nt)\n    return list(ret)\n\n\n# =====================================================================\n#  --- sensors\n# =====================================================================\n\n\nif FREEBSD:\n\n    def sensors_battery():\n        \"\"\"Return battery info.\"\"\"\n        try:\n            percent, minsleft, power_plugged = cext.sensors_battery()\n        except NotImplementedError:\n            # See: https://github.com/giampaolo/psutil/issues/1074\n            return None\n        power_plugged = power_plugged == 1\n        if power_plugged:\n            secsleft = _common.POWER_TIME_UNLIMITED\n        elif minsleft == -1:\n            secsleft = _common.POWER_TIME_UNKNOWN\n        else:\n            secsleft = minsleft * 60\n        return _common.sbattery(percent, secsleft, power_plugged)\n\n    def sensors_temperatures():\n        \"\"\"Return CPU cores temperatures if available, else an empty dict.\"\"\"\n        ret = defaultdict(list)\n        num_cpus = cpu_count_logical()\n        for cpu in range(num_cpus):\n            try:\n                current, high = cext.sensors_cpu_temperature(cpu)\n                if high <= 0:\n                    high = None\n                name = \"Core %s\" % cpu\n                ret[\"coretemp\"].append(\n                    _common.shwtemp(name, current, high, high)\n                )\n            except NotImplementedError:\n                pass\n\n        return ret\n\n\n# =====================================================================\n#  --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, tty, hostname, tstamp, pid = item\n        if pid == -1:\n            assert OPENBSD\n            pid = None\n        if tty == '~':\n            continue  # reboot or shutdown\n        nt = _common.suser(user, tty or None, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\n@memoize\ndef _pid_0_exists():\n    try:\n        Process(0).name()\n    except NoSuchProcess:\n        return False\n    except AccessDenied:\n        return True\n    else:\n        return True\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    ret = cext.pids()\n    if OPENBSD and (0 not in ret) and _pid_0_exists():\n        # On OpenBSD the kernel does not return PID 0 (neither does\n        # ps) but it's actually querable (Process(0) will succeed).\n        ret.insert(0, 0)\n    return ret\n\n\nif NETBSD:\n\n    def pid_exists(pid):\n        exists = _psposix.pid_exists(pid)\n        if not exists:\n            # We do this because _psposix.pid_exists() lies in case of\n            # zombie processes.\n            return pid in pids()\n        else:\n            return True\n\nelif OPENBSD:\n\n    def pid_exists(pid):\n        exists = _psposix.pid_exists(pid)\n        if not exists:\n            return False\n        else:\n            # OpenBSD seems to be the only BSD platform where\n            # _psposix.pid_exists() returns True for thread IDs (tids),\n            # so we can't use it.\n            return pid in pids()\n\nelse:  # FreeBSD\n    pid_exists = _psposix.pid_exists\n\n\ndef is_zombie(pid):\n    try:\n        st = cext.proc_oneshot_info(pid)[kinfo_proc_map['status']]\n        return PROC_STATUSES.get(st) == _common.STATUS_ZOMBIE\n    except OSError:\n        return False\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which translates bare OSError exceptions into\n    NoSuchProcess and AccessDenied.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except ProcessLookupError:\n            if is_zombie(self.pid):\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n            else:\n                raise NoSuchProcess(self.pid, self._name)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n        except OSError:\n            if self.pid == 0:\n                if 0 in pids():\n                    raise AccessDenied(self.pid, self._name)\n                else:\n                    raise\n            raise\n\n    return wrapper\n\n\n@contextlib.contextmanager\ndef wrap_exceptions_procfs(inst):\n    \"\"\"Same as above, for routines relying on reading /proc fs.\"\"\"\n    try:\n        yield\n    except (ProcessLookupError, FileNotFoundError):\n        # ENOENT (no such file or directory) gets raised on open().\n        # ESRCH (no such process) can get raised on read() if\n        # process is gone in meantime.\n        if is_zombie(inst.pid):\n            raise ZombieProcess(inst.pid, inst._name, inst._ppid)\n        else:\n            raise NoSuchProcess(inst.pid, inst._name)\n    except PermissionError:\n        raise AccessDenied(inst.pid, inst._name)\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n\n    def _assert_alive(self):\n        \"\"\"Raise NSP if the process disappeared on us.\"\"\"\n        # For those C function who do not raise NSP, possibly returning\n        # incorrect or incomplete result.\n        cext.proc_name(self.pid)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def oneshot(self):\n        \"\"\"Retrieves multiple process info in one shot as a raw tuple.\"\"\"\n        ret = cext.proc_oneshot_info(self.pid)\n        assert len(ret) == len(kinfo_proc_map)\n        return ret\n\n    def oneshot_enter(self):\n        self.oneshot.cache_activate(self)\n\n    def oneshot_exit(self):\n        self.oneshot.cache_deactivate(self)\n\n    @wrap_exceptions\n    def name(self):\n        name = self.oneshot()[kinfo_proc_map['name']]\n        return name if name is not None else cext.proc_name(self.pid)\n\n    @wrap_exceptions\n    def exe(self):\n        if FREEBSD:\n            if self.pid == 0:\n                return ''  # else NSP\n            return cext.proc_exe(self.pid)\n        elif NETBSD:\n            if self.pid == 0:\n                # /proc/0 dir exists but /proc/0/exe doesn't\n                return \"\"\n            with wrap_exceptions_procfs(self):\n                return os.readlink(\"/proc/%s/exe\" % self.pid)\n        else:\n            # OpenBSD: exe cannot be determined; references:\n            # https://chromium.googlesource.com/chromium/src/base/+/\n            #     master/base_paths_posix.cc\n            # We try our best guess by using which against the first\n            # cmdline arg (may return None).\n            cmdline = self.cmdline()\n            if cmdline:\n                return which(cmdline[0]) or \"\"\n            else:\n                return \"\"\n\n    @wrap_exceptions\n    def cmdline(self):\n        if OPENBSD and self.pid == 0:\n            return []  # ...else it crashes\n        elif NETBSD:\n            # XXX - most of the times the underlying sysctl() call on\n            # NetBSD and OpenBSD returns a truncated string. Also\n            # /proc/pid/cmdline behaves the same so it looks like this\n            # is a kernel bug.\n            try:\n                return cext.proc_cmdline(self.pid)\n            except OSError as err:\n                if err.errno == errno.EINVAL:\n                    if is_zombie(self.pid):\n                        raise ZombieProcess(self.pid, self._name, self._ppid)\n                    elif not pid_exists(self.pid):\n                        raise NoSuchProcess(self.pid, self._name, self._ppid)\n                    else:\n                        # XXX: this happens with unicode tests. It means the C\n                        # routine is unable to decode invalid unicode chars.\n                        debug(\"ignoring %r and returning an empty list\" % err)\n                        return []\n                else:\n                    raise\n        else:\n            return cext.proc_cmdline(self.pid)\n\n    @wrap_exceptions\n    def environ(self):\n        return cext.proc_environ(self.pid)\n\n    @wrap_exceptions\n    def terminal(self):\n        tty_nr = self.oneshot()[kinfo_proc_map['ttynr']]\n        tmap = _psposix.get_terminal_map()\n        try:\n            return tmap[tty_nr]\n        except KeyError:\n            return None\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self.oneshot()[kinfo_proc_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def uids(self):\n        rawtuple = self.oneshot()\n        return _common.puids(\n            rawtuple[kinfo_proc_map['real_uid']],\n            rawtuple[kinfo_proc_map['effective_uid']],\n            rawtuple[kinfo_proc_map['saved_uid']],\n        )\n\n    @wrap_exceptions\n    def gids(self):\n        rawtuple = self.oneshot()\n        return _common.pgids(\n            rawtuple[kinfo_proc_map['real_gid']],\n            rawtuple[kinfo_proc_map['effective_gid']],\n            rawtuple[kinfo_proc_map['saved_gid']],\n        )\n\n    @wrap_exceptions\n    def cpu_times(self):\n        rawtuple = self.oneshot()\n        return _common.pcputimes(\n            rawtuple[kinfo_proc_map['user_time']],\n            rawtuple[kinfo_proc_map['sys_time']],\n            rawtuple[kinfo_proc_map['ch_user_time']],\n            rawtuple[kinfo_proc_map['ch_sys_time']],\n        )\n\n    if FREEBSD:\n\n        @wrap_exceptions\n        def cpu_num(self):\n            return self.oneshot()[kinfo_proc_map['cpunum']]\n\n    @wrap_exceptions\n    def memory_info(self):\n        rawtuple = self.oneshot()\n        return pmem(\n            rawtuple[kinfo_proc_map['rss']],\n            rawtuple[kinfo_proc_map['vms']],\n            rawtuple[kinfo_proc_map['memtext']],\n            rawtuple[kinfo_proc_map['memdata']],\n            rawtuple[kinfo_proc_map['memstack']],\n        )\n\n    memory_full_info = memory_info\n\n    @wrap_exceptions\n    def create_time(self):\n        return self.oneshot()[kinfo_proc_map['create_time']]\n\n    @wrap_exceptions\n    def num_threads(self):\n        if HAS_PROC_NUM_THREADS:\n            # FreeBSD\n            return cext.proc_num_threads(self.pid)\n        else:\n            return len(self.threads())\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        rawtuple = self.oneshot()\n        return _common.pctxsw(\n            rawtuple[kinfo_proc_map['ctx_switches_vol']],\n            rawtuple[kinfo_proc_map['ctx_switches_unvol']],\n        )\n\n    @wrap_exceptions\n    def threads(self):\n        # Note: on OpenSBD this (/dev/mem) requires root access.\n        rawlist = cext.proc_threads(self.pid)\n        retlist = []\n        for thread_id, utime, stime in rawlist:\n            ntuple = _common.pthread(thread_id, utime, stime)\n            retlist.append(ntuple)\n        if OPENBSD:\n            self._assert_alive()\n        return retlist\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        if kind not in conn_tmap:\n            raise ValueError(\n                \"invalid %r kind argument; choose between %s\"\n                % (kind, ', '.join([repr(x) for x in conn_tmap]))\n            )\n        families, types = conn_tmap[kind]\n        ret = []\n\n        if NETBSD:\n            rawlist = cext.net_connections(self.pid, kind)\n        elif OPENBSD:\n            rawlist = cext.net_connections(self.pid, families, types)\n        else:\n            rawlist = cext.proc_net_connections(self.pid, families, types)\n\n        for item in rawlist:\n            fd, fam, type, laddr, raddr, status = item[:6]\n            if FREEBSD:\n                if (fam not in families) or (type not in types):\n                    continue\n            nt = conn_to_ntuple(\n                fd, fam, type, laddr, raddr, status, TCP_STATUSES\n            )\n            ret.append(nt)\n\n        self._assert_alive()\n        return ret\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    @wrap_exceptions\n    def nice_get(self):\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def status(self):\n        code = self.oneshot()[kinfo_proc_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    @wrap_exceptions\n    def io_counters(self):\n        rawtuple = self.oneshot()\n        return _common.pio(\n            rawtuple[kinfo_proc_map['read_io_count']],\n            rawtuple[kinfo_proc_map['write_io_count']],\n            -1,\n            -1,\n        )\n\n    @wrap_exceptions\n    def cwd(self):\n        \"\"\"Return process current working directory.\"\"\"\n        # sometimes we get an empty string, in which case we turn\n        # it into None\n        if OPENBSD and self.pid == 0:\n            return \"\"  # ...else it would raise EINVAL\n        elif NETBSD or HAS_PROC_OPEN_FILES:\n            # FreeBSD < 8 does not support functions based on\n            # kinfo_getfile() and kinfo_getvmmap()\n            return cext.proc_cwd(self.pid)\n        else:\n            raise NotImplementedError(\n                \"supported only starting from FreeBSD 8\" if FREEBSD else \"\"\n            )\n\n    nt_mmap_grouped = namedtuple(\n        'mmap', 'path rss, private, ref_count, shadow_count'\n    )\n    nt_mmap_ext = namedtuple(\n        'mmap', 'addr, perms path rss, private, ref_count, shadow_count'\n    )\n\n    def _not_implemented(self):\n        raise NotImplementedError\n\n    # FreeBSD < 8 does not support functions based on kinfo_getfile()\n    # and kinfo_getvmmap()\n    if HAS_PROC_OPEN_FILES:\n\n        @wrap_exceptions\n        def open_files(self):\n            \"\"\"Return files opened by process as a list of namedtuples.\"\"\"\n            rawlist = cext.proc_open_files(self.pid)\n            return [_common.popenfile(path, fd) for path, fd in rawlist]\n\n    else:\n        open_files = _not_implemented\n\n    # FreeBSD < 8 does not support functions based on kinfo_getfile()\n    # and kinfo_getvmmap()\n    if HAS_PROC_NUM_FDS:\n\n        @wrap_exceptions\n        def num_fds(self):\n            \"\"\"Return the number of file descriptors opened by this process.\"\"\"\n            ret = cext.proc_num_fds(self.pid)\n            if NETBSD:\n                self._assert_alive()\n            return ret\n\n    else:\n        num_fds = _not_implemented\n\n    # --- FreeBSD only APIs\n\n    if FREEBSD:\n\n        @wrap_exceptions\n        def cpu_affinity_get(self):\n            return cext.proc_cpu_affinity_get(self.pid)\n\n        @wrap_exceptions\n        def cpu_affinity_set(self, cpus):\n            # Pre-emptively check if CPUs are valid because the C\n            # function has a weird behavior in case of invalid CPUs,\n            # see: https://github.com/giampaolo/psutil/issues/586\n            allcpus = tuple(range(len(per_cpu_times())))\n            for cpu in cpus:\n                if cpu not in allcpus:\n                    raise ValueError(\n                        \"invalid CPU #%i (choose between %s)\" % (cpu, allcpus)\n                    )\n            try:\n                cext.proc_cpu_affinity_set(self.pid, cpus)\n            except OSError as err:\n                # 'man cpuset_setaffinity' about EDEADLK:\n                # <<the call would leave a thread without a valid CPU to run\n                # on because the set does not overlap with the thread's\n                # anonymous mask>>\n                if err.errno in (errno.EINVAL, errno.EDEADLK):\n                    for cpu in cpus:\n                        if cpu not in allcpus:\n                            raise ValueError(\n                                \"invalid CPU #%i (choose between %s)\"\n                                % (cpu, allcpus)\n                            )\n                raise\n\n        @wrap_exceptions\n        def memory_maps(self):\n            return cext.proc_memory_maps(self.pid)\n\n        @wrap_exceptions\n        def rlimit(self, resource, limits=None):\n            if limits is None:\n                return cext.proc_getrlimit(self.pid, resource)\n            else:\n                if len(limits) != 2:\n                    raise ValueError(\n                        \"second argument must be a (soft, hard) tuple, got %s\"\n                        % repr(limits)\n                    )\n                soft, hard = limits\n                return cext.proc_setrlimit(self.pid, resource, soft, hard)\n", "psutil/_pssunos.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Sun OS Solaris platform implementation.\"\"\"\n\nimport errno\nimport functools\nimport os\nimport socket\nimport subprocess\nimport sys\nfrom collections import namedtuple\nfrom socket import AF_INET\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_posix as cext_posix\nfrom . import _psutil_sunos as cext\nfrom ._common import AF_INET6\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import debug\nfrom ._common import get_procfs_path\nfrom ._common import isfile_strict\nfrom ._common import memoize_when_activated\nfrom ._common import sockfam_to_enum\nfrom ._common import socktype_to_enum\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import b\n\n\n__extra__all__ = [\"CONN_IDLE\", \"CONN_BOUND\", \"PROCFS_PATH\"]\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nPAGE_SIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\nIS_64_BIT = sys.maxsize > 2**32\n\nCONN_IDLE = \"IDLE\"\nCONN_BOUND = \"BOUND\"\n\nPROC_STATUSES = {\n    cext.SSLEEP: _common.STATUS_SLEEPING,\n    cext.SRUN: _common.STATUS_RUNNING,\n    cext.SZOMB: _common.STATUS_ZOMBIE,\n    cext.SSTOP: _common.STATUS_STOPPED,\n    cext.SIDL: _common.STATUS_IDLE,\n    cext.SONPROC: _common.STATUS_RUNNING,  # same as run\n    cext.SWAIT: _common.STATUS_WAITING,\n}\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RCVD: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n    cext.TCPS_IDLE: CONN_IDLE,  # sunos specific\n    cext.TCPS_BOUND: CONN_BOUND,  # sunos specific\n}\n\nproc_info_map = dict(\n    ppid=0,\n    rss=1,\n    vms=2,\n    create_time=3,\n    nice=4,\n    num_threads=5,\n    status=6,\n    ttynr=7,\n    uid=8,\n    euid=9,\n    gid=10,\n    egid=11,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# psutil.cpu_times()\nscputimes = namedtuple('scputimes', ['user', 'system', 'idle', 'iowait'])\n# psutil.cpu_times(percpu=True)\npcputimes = namedtuple(\n    'pcputimes', ['user', 'system', 'children_user', 'children_system']\n)\n# psutil.virtual_memory()\nsvmem = namedtuple('svmem', ['total', 'available', 'percent', 'used', 'free'])\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms'])\npfullmem = pmem\n# psutil.Process.memory_maps(grouped=True)\npmmap_grouped = namedtuple(\n    'pmmap_grouped', ['path', 'rss', 'anonymous', 'locked']\n)\n# psutil.Process.memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr perms ' + ' '.join(pmmap_grouped._fields)\n)\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"Report virtual memory metrics.\"\"\"\n    # we could have done this with kstat, but IMHO this is good enough\n    total = os.sysconf('SC_PHYS_PAGES') * PAGE_SIZE\n    # note: there's no difference on Solaris\n    free = avail = os.sysconf('SC_AVPHYS_PAGES') * PAGE_SIZE\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return svmem(total, avail, percent, used, free)\n\n\ndef swap_memory():\n    \"\"\"Report swap memory metrics.\"\"\"\n    sin, sout = cext.swap_mem()\n    # XXX\n    # we are supposed to get total/free by doing so:\n    # http://cvs.opensolaris.org/source/xref/onnv/onnv-gate/\n    #     usr/src/cmd/swap/swap.c\n    # ...nevertheless I can't manage to obtain the same numbers as 'swap'\n    # cmdline utility, so let's parse its output (sigh!)\n    p = subprocess.Popen(\n        [\n            '/usr/bin/env',\n            'PATH=/usr/sbin:/sbin:%s' % os.environ['PATH'],\n            'swap',\n            '-l',\n        ],\n        stdout=subprocess.PIPE,\n    )\n    stdout, _ = p.communicate()\n    if PY3:\n        stdout = stdout.decode(sys.stdout.encoding)\n    if p.returncode != 0:\n        raise RuntimeError(\"'swap -l' failed (retcode=%s)\" % p.returncode)\n\n    lines = stdout.strip().split('\\n')[1:]\n    if not lines:\n        msg = 'no swap device(s) configured'\n        raise RuntimeError(msg)\n    total = free = 0\n    for line in lines:\n        line = line.split()\n        t, f = line[3:5]\n        total += int(int(t) * 512)\n        free += int(int(f) * 512)\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(\n        total, used, free, percent, sin * PAGE_SIZE, sout * PAGE_SIZE\n    )\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system-wide CPU times as a named tuple.\"\"\"\n    ret = cext.per_cpu_times()\n    return scputimes(*[sum(x) for x in zip(*ret)])\n\n\ndef per_cpu_times():\n    \"\"\"Return system per-CPU times as a list of named tuples.\"\"\"\n    ret = cext.per_cpu_times()\n    return [scputimes(*x) for x in ret]\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_ONLN\")\n    except ValueError:\n        # mimic os.cpu_count() behavior\n        return None\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    return cext.cpu_count_cores()\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    ctx_switches, interrupts, syscalls, _traps = cext.cpu_stats()\n    soft_interrupts = 0\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_io_counters = cext.disk_io_counters\ndisk_usage = _psposix.disk_usage\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return system disk partitions.\"\"\"\n    # TODO - the filtering logic should be better checked so that\n    # it tries to reflect 'df' as much as possible\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if not all:\n            # Differently from, say, Linux, we don't have a list of\n            # common fs types so the best we can do, AFAIK, is to\n            # filter by filesystem having a total size > 0.\n            try:\n                if not disk_usage(mountpoint).total:\n                    continue\n            except OSError as err:\n                # https://github.com/giampaolo/psutil/issues/1674\n                debug(\"skipping %r: %s\" % (mountpoint, err))\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_io_counters = cext.net_io_counters\nnet_if_addrs = cext_posix.net_if_addrs\n\n\ndef net_connections(kind, _pid=-1):\n    \"\"\"Return socket connections.  If pid == -1 return system-wide\n    connections (as opposed to connections opened by one process only).\n    Only INET sockets are returned (UNIX are not).\n    \"\"\"\n    cmap = _common.conn_tmap.copy()\n    if _pid == -1:\n        cmap.pop('unix', 0)\n    if kind not in cmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in cmap]))\n        )\n    families, types = _common.conn_tmap[kind]\n    rawlist = cext.net_connections(_pid)\n    ret = set()\n    for item in rawlist:\n        fd, fam, type_, laddr, raddr, status, pid = item\n        if fam not in families:\n            continue\n        if type_ not in types:\n            continue\n        # TODO: refactor and use _common.conn_to_ntuple.\n        if fam in (AF_INET, AF_INET6):\n            if laddr:\n                laddr = _common.addr(*laddr)\n            if raddr:\n                raddr = _common.addr(*raddr)\n        status = TCP_STATUSES[status]\n        fam = sockfam_to_enum(fam)\n        type_ = socktype_to_enum(type_)\n        if _pid == -1:\n            nt = _common.sconn(fd, fam, type_, laddr, raddr, status, pid)\n        else:\n            nt = _common.pconn(fd, fam, type_, laddr, raddr, status)\n        ret.add(nt)\n    return list(ret)\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    ret = cext.net_if_stats()\n    for name, items in ret.items():\n        isup, duplex, speed, mtu = items\n        if hasattr(_common, 'NicDuplex'):\n            duplex = _common.NicDuplex(duplex)\n        ret[name] = _common.snicstats(isup, duplex, speed, mtu, '')\n    return ret\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    localhost = (':0.0', ':0')\n    for item in rawlist:\n        user, tty, hostname, tstamp, user_process, pid = item\n        # note: the underlying C function includes entries about\n        # system boot, run level and others.  We might want\n        # to use them in the future.\n        if not user_process:\n            continue\n        if hostname in localhost:\n            hostname = 'localhost'\n        nt = _common.suser(user, tty, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    return [int(x) for x in os.listdir(b(get_procfs_path())) if x.isdigit()]\n\n\ndef pid_exists(pid):\n    \"\"\"Check for the existence of a unix pid.\"\"\"\n    return _psposix.pid_exists(pid)\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Call callable into a try/except clause and translate ENOENT,\n    EACCES and EPERM in NoSuchProcess or AccessDenied exceptions.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except (FileNotFoundError, ProcessLookupError):\n            # ENOENT (no such file or directory) gets raised on open().\n            # ESRCH (no such process) can get raised on read() if\n            # process is gone in meantime.\n            if not pid_exists(self.pid):\n                raise NoSuchProcess(self.pid, self._name)\n            else:\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n        except OSError:\n            if self.pid == 0:\n                if 0 in pids():\n                    raise AccessDenied(self.pid, self._name)\n                else:\n                    raise\n            raise\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_procfs_path\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n        self._procfs_path = get_procfs_path()\n\n    def _assert_alive(self):\n        \"\"\"Raise NSP if the process disappeared on us.\"\"\"\n        # For those C function who do not raise NSP, possibly returning\n        # incorrect or incomplete result.\n        os.stat('%s/%s' % (self._procfs_path, self.pid))\n\n    def oneshot_enter(self):\n        self._proc_name_and_args.cache_activate(self)\n        self._proc_basic_info.cache_activate(self)\n        self._proc_cred.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._proc_name_and_args.cache_deactivate(self)\n        self._proc_basic_info.cache_deactivate(self)\n        self._proc_cred.cache_deactivate(self)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_name_and_args(self):\n        return cext.proc_name_and_args(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_basic_info(self):\n        if self.pid == 0 and not os.path.exists(\n            '%s/%s/psinfo' % (self._procfs_path, self.pid)\n        ):\n            raise AccessDenied(self.pid)\n        ret = cext.proc_basic_info(self.pid, self._procfs_path)\n        assert len(ret) == len(proc_info_map)\n        return ret\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_cred(self):\n        return cext.proc_cred(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def name(self):\n        # note: max len == 15\n        return self._proc_name_and_args()[0]\n\n    @wrap_exceptions\n    def exe(self):\n        try:\n            return os.readlink(\n                \"%s/%s/path/a.out\" % (self._procfs_path, self.pid)\n            )\n        except OSError:\n            pass  # continue and guess the exe name from the cmdline\n        # Will be guessed later from cmdline but we want to explicitly\n        # invoke cmdline here in order to get an AccessDenied\n        # exception if the user has not enough privileges.\n        self.cmdline()\n        return \"\"\n\n    @wrap_exceptions\n    def cmdline(self):\n        return self._proc_name_and_args()[1].split(' ')\n\n    @wrap_exceptions\n    def environ(self):\n        return cext.proc_environ(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def create_time(self):\n        return self._proc_basic_info()[proc_info_map['create_time']]\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._proc_basic_info()[proc_info_map['num_threads']]\n\n    @wrap_exceptions\n    def nice_get(self):\n        # Note #1: getpriority(3) doesn't work for realtime processes.\n        # Psinfo is what ps uses, see:\n        # https://github.com/giampaolo/psutil/issues/1194\n        return self._proc_basic_info()[proc_info_map['nice']]\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        if self.pid in (2, 3):\n            # Special case PIDs: internally setpriority(3) return ESRCH\n            # (no such process), no matter what.\n            # The process actually exists though, as it has a name,\n            # creation time, etc.\n            raise AccessDenied(self.pid, self._name)\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self._proc_basic_info()[proc_info_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def uids(self):\n        try:\n            real, effective, saved, _, _, _ = self._proc_cred()\n        except AccessDenied:\n            real = self._proc_basic_info()[proc_info_map['uid']]\n            effective = self._proc_basic_info()[proc_info_map['euid']]\n            saved = None\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def gids(self):\n        try:\n            _, _, _, real, effective, saved = self._proc_cred()\n        except AccessDenied:\n            real = self._proc_basic_info()[proc_info_map['gid']]\n            effective = self._proc_basic_info()[proc_info_map['egid']]\n            saved = None\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def cpu_times(self):\n        try:\n            times = cext.proc_cpu_times(self.pid, self._procfs_path)\n        except OSError as err:\n            if err.errno == errno.EOVERFLOW and not IS_64_BIT:\n                # We may get here if we attempt to query a 64bit process\n                # with a 32bit python.\n                # Error originates from read() and also tools like \"cat\"\n                # fail in the same way (!).\n                # Since there simply is no way to determine CPU times we\n                # return 0.0 as a fallback. See:\n                # https://github.com/giampaolo/psutil/issues/857\n                times = (0.0, 0.0, 0.0, 0.0)\n            else:\n                raise\n        return _common.pcputimes(*times)\n\n    @wrap_exceptions\n    def cpu_num(self):\n        return cext.proc_cpu_num(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def terminal(self):\n        procfs_path = self._procfs_path\n        hit_enoent = False\n        tty = wrap_exceptions(self._proc_basic_info()[proc_info_map['ttynr']])\n        if tty != cext.PRNODEV:\n            for x in (0, 1, 2, 255):\n                try:\n                    return os.readlink(\n                        '%s/%d/path/%d' % (procfs_path, self.pid, x)\n                    )\n                except FileNotFoundError:\n                    hit_enoent = True\n                    continue\n        if hit_enoent:\n            self._assert_alive()\n\n    @wrap_exceptions\n    def cwd(self):\n        # /proc/PID/path/cwd may not be resolved by readlink() even if\n        # it exists (ls shows it). If that's the case and the process\n        # is still alive return None (we can return None also on BSD).\n        # Reference: http://goo.gl/55XgO\n        procfs_path = self._procfs_path\n        try:\n            return os.readlink(\"%s/%s/path/cwd\" % (procfs_path, self.pid))\n        except FileNotFoundError:\n            os.stat(\"%s/%s\" % (procfs_path, self.pid))  # raise NSP or AD\n            return \"\"\n\n    @wrap_exceptions\n    def memory_info(self):\n        ret = self._proc_basic_info()\n        rss = ret[proc_info_map['rss']] * 1024\n        vms = ret[proc_info_map['vms']] * 1024\n        return pmem(rss, vms)\n\n    memory_full_info = memory_info\n\n    @wrap_exceptions\n    def status(self):\n        code = self._proc_basic_info()[proc_info_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    @wrap_exceptions\n    def threads(self):\n        procfs_path = self._procfs_path\n        ret = []\n        tids = os.listdir('%s/%d/lwp' % (procfs_path, self.pid))\n        hit_enoent = False\n        for tid in tids:\n            tid = int(tid)\n            try:\n                utime, stime = cext.query_process_thread(\n                    self.pid, tid, procfs_path\n                )\n            except EnvironmentError as err:\n                if err.errno == errno.EOVERFLOW and not IS_64_BIT:\n                    # We may get here if we attempt to query a 64bit process\n                    # with a 32bit python.\n                    # Error originates from read() and also tools like \"cat\"\n                    # fail in the same way (!).\n                    # Since there simply is no way to determine CPU times we\n                    # return 0.0 as a fallback. See:\n                    # https://github.com/giampaolo/psutil/issues/857\n                    continue\n                # ENOENT == thread gone in meantime\n                if err.errno == errno.ENOENT:\n                    hit_enoent = True\n                    continue\n                raise\n            else:\n                nt = _common.pthread(tid, utime, stime)\n                ret.append(nt)\n        if hit_enoent:\n            self._assert_alive()\n        return ret\n\n    @wrap_exceptions\n    def open_files(self):\n        retlist = []\n        hit_enoent = False\n        procfs_path = self._procfs_path\n        pathdir = '%s/%d/path' % (procfs_path, self.pid)\n        for fd in os.listdir('%s/%d/fd' % (procfs_path, self.pid)):\n            path = os.path.join(pathdir, fd)\n            if os.path.islink(path):\n                try:\n                    file = os.readlink(path)\n                except FileNotFoundError:\n                    hit_enoent = True\n                    continue\n                else:\n                    if isfile_strict(file):\n                        retlist.append(_common.popenfile(file, int(fd)))\n        if hit_enoent:\n            self._assert_alive()\n        return retlist\n\n    def _get_unix_sockets(self, pid):\n        \"\"\"Get UNIX sockets used by process by parsing 'pfiles' output.\"\"\"\n        # TODO: rewrite this in C (...but the damn netstat source code\n        # does not include this part! Argh!!)\n        cmd = [\"pfiles\", str(pid)]\n        p = subprocess.Popen(\n            cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        stdout, stderr = p.communicate()\n        if PY3:\n            stdout, stderr = (\n                x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n            )\n        if p.returncode != 0:\n            if 'permission denied' in stderr.lower():\n                raise AccessDenied(self.pid, self._name)\n            if 'no such process' in stderr.lower():\n                raise NoSuchProcess(self.pid, self._name)\n            raise RuntimeError(\"%r command error\\n%s\" % (cmd, stderr))\n\n        lines = stdout.split('\\n')[2:]\n        for i, line in enumerate(lines):\n            line = line.lstrip()\n            if line.startswith('sockname: AF_UNIX'):\n                path = line.split(' ', 2)[2]\n                type = lines[i - 2].strip()\n                if type == 'SOCK_STREAM':\n                    type = socket.SOCK_STREAM\n                elif type == 'SOCK_DGRAM':\n                    type = socket.SOCK_DGRAM\n                else:\n                    type = -1\n                yield (-1, socket.AF_UNIX, type, path, \"\", _common.CONN_NONE)\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        ret = net_connections(kind, _pid=self.pid)\n        # The underlying C implementation retrieves all OS connections\n        # and filters them by PID.  At this point we can't tell whether\n        # an empty list means there were no connections for process or\n        # process is no longer active so we force NSP in case the PID\n        # is no longer there.\n        if not ret:\n            # will raise NSP if process is gone\n            os.stat('%s/%s' % (self._procfs_path, self.pid))\n\n        # UNIX sockets\n        if kind in ('all', 'unix'):\n            ret.extend([\n                _common.pconn(*conn)\n                for conn in self._get_unix_sockets(self.pid)\n            ])\n        return ret\n\n    nt_mmap_grouped = namedtuple('mmap', 'path rss anon locked')\n    nt_mmap_ext = namedtuple('mmap', 'addr perms path rss anon locked')\n\n    @wrap_exceptions\n    def memory_maps(self):\n        def toaddr(start, end):\n            return '%s-%s' % (\n                hex(start)[2:].strip('L'),\n                hex(end)[2:].strip('L'),\n            )\n\n        procfs_path = self._procfs_path\n        retlist = []\n        try:\n            rawlist = cext.proc_memory_maps(self.pid, procfs_path)\n        except OSError as err:\n            if err.errno == errno.EOVERFLOW and not IS_64_BIT:\n                # We may get here if we attempt to query a 64bit process\n                # with a 32bit python.\n                # Error originates from read() and also tools like \"cat\"\n                # fail in the same way (!).\n                # Since there simply is no way to determine CPU times we\n                # return 0.0 as a fallback. See:\n                # https://github.com/giampaolo/psutil/issues/857\n                return []\n            else:\n                raise\n        hit_enoent = False\n        for item in rawlist:\n            addr, addrsize, perm, name, rss, anon, locked = item\n            addr = toaddr(addr, addrsize)\n            if not name.startswith('['):\n                try:\n                    name = os.readlink(\n                        '%s/%s/path/%s' % (procfs_path, self.pid, name)\n                    )\n                except OSError as err:\n                    if err.errno == errno.ENOENT:\n                        # sometimes the link may not be resolved by\n                        # readlink() even if it exists (ls shows it).\n                        # If that's the case we just return the\n                        # unresolved link path.\n                        # This seems an inconsistency with /proc similar\n                        # to: http://goo.gl/55XgO\n                        name = '%s/%s/path/%s' % (procfs_path, self.pid, name)\n                        hit_enoent = True\n                    else:\n                        raise\n            retlist.append((addr, perm, name, rss, anon, locked))\n        if hit_enoent:\n            self._assert_alive()\n        return retlist\n\n    @wrap_exceptions\n    def num_fds(self):\n        return len(os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid)))\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        return _common.pctxsw(\n            *cext.proc_num_ctx_switches(self.pid, self._procfs_path)\n        )\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n", "psutil/_psaix.py": "# Copyright (c) 2009, Giampaolo Rodola'\n# Copyright (c) 2017, Arnon Yaari\n# All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"AIX platform implementation.\"\"\"\n\nimport functools\nimport glob\nimport os\nimport re\nimport subprocess\nimport sys\nfrom collections import namedtuple\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_aix as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import NIC_DUPLEX_FULL\nfrom ._common import NIC_DUPLEX_HALF\nfrom ._common import NIC_DUPLEX_UNKNOWN\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import conn_to_ntuple\nfrom ._common import get_procfs_path\nfrom ._common import memoize_when_activated\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\n\n\n__extra__all__ = [\"PROCFS_PATH\"]\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nHAS_THREADS = hasattr(cext, \"proc_threads\")\nHAS_NET_IO_COUNTERS = hasattr(cext, \"net_io_counters\")\nHAS_PROC_IO_COUNTERS = hasattr(cext, \"proc_io_counters\")\n\nPAGE_SIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\n\nPROC_STATUSES = {\n    cext.SIDL: _common.STATUS_IDLE,\n    cext.SZOMB: _common.STATUS_ZOMBIE,\n    cext.SACTIVE: _common.STATUS_RUNNING,\n    cext.SSWAP: _common.STATUS_RUNNING,  # TODO what status is this?\n    cext.SSTOP: _common.STATUS_STOPPED,\n}\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RCVD: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nproc_info_map = dict(\n    ppid=0,\n    rss=1,\n    vms=2,\n    create_time=3,\n    nice=4,\n    num_threads=5,\n    status=6,\n    ttynr=7,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms'])\n# psutil.Process.memory_full_info()\npfullmem = pmem\n# psutil.Process.cpu_times()\nscputimes = namedtuple('scputimes', ['user', 'system', 'idle', 'iowait'])\n# psutil.virtual_memory()\nsvmem = namedtuple('svmem', ['total', 'available', 'percent', 'used', 'free'])\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    total, avail, free, _pinned, inuse = cext.virtual_mem()\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(total, avail, percent, inuse, free)\n\n\ndef swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    total, free, sin, sout = cext.swap_mem()\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system-wide CPU times as a named tuple.\"\"\"\n    ret = cext.per_cpu_times()\n    return scputimes(*[sum(x) for x in zip(*ret)])\n\n\ndef per_cpu_times():\n    \"\"\"Return system per-CPU times as a list of named tuples.\"\"\"\n    ret = cext.per_cpu_times()\n    return [scputimes(*x) for x in ret]\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_ONLN\")\n    except ValueError:\n        # mimic os.cpu_count() behavior\n        return None\n\n\ndef cpu_count_cores():\n    cmd = [\"lsdev\", \"-Cc\", \"processor\"]\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    stdout, stderr = p.communicate()\n    if PY3:\n        stdout, stderr = (\n            x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n        )\n    if p.returncode != 0:\n        raise RuntimeError(\"%r command error\\n%s\" % (cmd, stderr))\n    processors = stdout.strip().splitlines()\n    return len(processors) or None\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    ctx_switches, interrupts, soft_interrupts, syscalls = cext.cpu_stats()\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_io_counters = cext.disk_io_counters\ndisk_usage = _psposix.disk_usage\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return system disk partitions.\"\"\"\n    # TODO - the filtering logic should be better checked so that\n    # it tries to reflect 'df' as much as possible\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if not all:\n            # Differently from, say, Linux, we don't have a list of\n            # common fs types so the best we can do, AFAIK, is to\n            # filter by filesystem having a total size > 0.\n            if not disk_usage(mountpoint).total:\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_if_addrs = cext_posix.net_if_addrs\n\nif HAS_NET_IO_COUNTERS:\n    net_io_counters = cext.net_io_counters\n\n\ndef net_connections(kind, _pid=-1):\n    \"\"\"Return socket connections.  If pid == -1 return system-wide\n    connections (as opposed to connections opened by one process only).\n    \"\"\"\n    cmap = _common.conn_tmap\n    if kind not in cmap:\n        raise ValueError(\n            \"invalid %r kind argument; choose between %s\"\n            % (kind, ', '.join([repr(x) for x in cmap]))\n        )\n    families, types = _common.conn_tmap[kind]\n    rawlist = cext.net_connections(_pid)\n    ret = []\n    for item in rawlist:\n        fd, fam, type_, laddr, raddr, status, pid = item\n        if fam not in families:\n            continue\n        if type_ not in types:\n            continue\n        nt = conn_to_ntuple(\n            fd,\n            fam,\n            type_,\n            laddr,\n            raddr,\n            status,\n            TCP_STATUSES,\n            pid=pid if _pid == -1 else None,\n        )\n        ret.append(nt)\n    return ret\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    duplex_map = {\"Full\": NIC_DUPLEX_FULL, \"Half\": NIC_DUPLEX_HALF}\n    names = set([x[0] for x in net_if_addrs()])\n    ret = {}\n    for name in names:\n        mtu = cext_posix.net_if_mtu(name)\n        flags = cext_posix.net_if_flags(name)\n\n        # try to get speed and duplex\n        # TODO: rewrite this in C (entstat forks, so use truss -f to follow.\n        # looks like it is using an undocumented ioctl?)\n        duplex = \"\"\n        speed = 0\n        p = subprocess.Popen(\n            [\"/usr/bin/entstat\", \"-d\", name],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        stdout, stderr = p.communicate()\n        if PY3:\n            stdout, stderr = (\n                x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n            )\n        if p.returncode == 0:\n            re_result = re.search(\n                r\"Running: (\\d+) Mbps.*?(\\w+) Duplex\", stdout\n            )\n            if re_result is not None:\n                speed = int(re_result.group(1))\n                duplex = re_result.group(2)\n\n        output_flags = ','.join(flags)\n        isup = 'running' in flags\n        duplex = duplex_map.get(duplex, NIC_DUPLEX_UNKNOWN)\n        ret[name] = _common.snicstats(isup, duplex, speed, mtu, output_flags)\n    return ret\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    localhost = (':0.0', ':0')\n    for item in rawlist:\n        user, tty, hostname, tstamp, user_process, pid = item\n        # note: the underlying C function includes entries about\n        # system boot, run level and others.  We might want\n        # to use them in the future.\n        if not user_process:\n            continue\n        if hostname in localhost:\n            hostname = 'localhost'\n        nt = _common.suser(user, tty, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    return [int(x) for x in os.listdir(get_procfs_path()) if x.isdigit()]\n\n\ndef pid_exists(pid):\n    \"\"\"Check for the existence of a unix pid.\"\"\"\n    return os.path.exists(os.path.join(get_procfs_path(), str(pid), \"psinfo\"))\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Call callable into a try/except clause and translate ENOENT,\n    EACCES and EPERM in NoSuchProcess or AccessDenied exceptions.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except (FileNotFoundError, ProcessLookupError):\n            # ENOENT (no such file or directory) gets raised on open().\n            # ESRCH (no such process) can get raised on read() if\n            # process is gone in meantime.\n            if not pid_exists(self.pid):\n                raise NoSuchProcess(self.pid, self._name)\n            else:\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_procfs_path\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n        self._procfs_path = get_procfs_path()\n\n    def oneshot_enter(self):\n        self._proc_basic_info.cache_activate(self)\n        self._proc_cred.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._proc_basic_info.cache_deactivate(self)\n        self._proc_cred.cache_deactivate(self)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_basic_info(self):\n        return cext.proc_basic_info(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _proc_cred(self):\n        return cext.proc_cred(self.pid, self._procfs_path)\n\n    @wrap_exceptions\n    def name(self):\n        if self.pid == 0:\n            return \"swapper\"\n        # note: max 16 characters\n        return cext.proc_name(self.pid, self._procfs_path).rstrip(\"\\x00\")\n\n    @wrap_exceptions\n    def exe(self):\n        # there is no way to get executable path in AIX other than to guess,\n        # and guessing is more complex than what's in the wrapping class\n        cmdline = self.cmdline()\n        if not cmdline:\n            return ''\n        exe = cmdline[0]\n        if os.path.sep in exe:\n            # relative or absolute path\n            if not os.path.isabs(exe):\n                # if cwd has changed, we're out of luck - this may be wrong!\n                exe = os.path.abspath(os.path.join(self.cwd(), exe))\n            if (\n                os.path.isabs(exe)\n                and os.path.isfile(exe)\n                and os.access(exe, os.X_OK)\n            ):\n                return exe\n            # not found, move to search in PATH using basename only\n            exe = os.path.basename(exe)\n        # search for exe name PATH\n        for path in os.environ[\"PATH\"].split(\":\"):\n            possible_exe = os.path.abspath(os.path.join(path, exe))\n            if os.path.isfile(possible_exe) and os.access(\n                possible_exe, os.X_OK\n            ):\n                return possible_exe\n        return ''\n\n    @wrap_exceptions\n    def cmdline(self):\n        return cext.proc_args(self.pid)\n\n    @wrap_exceptions\n    def environ(self):\n        return cext.proc_environ(self.pid)\n\n    @wrap_exceptions\n    def create_time(self):\n        return self._proc_basic_info()[proc_info_map['create_time']]\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._proc_basic_info()[proc_info_map['num_threads']]\n\n    if HAS_THREADS:\n\n        @wrap_exceptions\n        def threads(self):\n            rawlist = cext.proc_threads(self.pid)\n            retlist = []\n            for thread_id, utime, stime in rawlist:\n                ntuple = _common.pthread(thread_id, utime, stime)\n                retlist.append(ntuple)\n            # The underlying C implementation retrieves all OS threads\n            # and filters them by PID.  At this point we can't tell whether\n            # an empty list means there were no connections for process or\n            # process is no longer active so we force NSP in case the PID\n            # is no longer there.\n            if not retlist:\n                # will raise NSP if process is gone\n                os.stat('%s/%s' % (self._procfs_path, self.pid))\n            return retlist\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        ret = net_connections(kind, _pid=self.pid)\n        # The underlying C implementation retrieves all OS connections\n        # and filters them by PID.  At this point we can't tell whether\n        # an empty list means there were no connections for process or\n        # process is no longer active so we force NSP in case the PID\n        # is no longer there.\n        if not ret:\n            # will raise NSP if process is gone\n            os.stat('%s/%s' % (self._procfs_path, self.pid))\n        return ret\n\n    @wrap_exceptions\n    def nice_get(self):\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self._proc_basic_info()[proc_info_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def uids(self):\n        real, effective, saved, _, _, _ = self._proc_cred()\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def gids(self):\n        _, _, _, real, effective, saved = self._proc_cred()\n        return _common.puids(real, effective, saved)\n\n    @wrap_exceptions\n    def cpu_times(self):\n        t = cext.proc_cpu_times(self.pid, self._procfs_path)\n        return _common.pcputimes(*t)\n\n    @wrap_exceptions\n    def terminal(self):\n        ttydev = self._proc_basic_info()[proc_info_map['ttynr']]\n        # convert from 64-bit dev_t to 32-bit dev_t and then map the device\n        ttydev = ((ttydev & 0x0000FFFF00000000) >> 16) | (ttydev & 0xFFFF)\n        # try to match rdev of /dev/pts/* files ttydev\n        for dev in glob.glob(\"/dev/**/*\"):\n            if os.stat(dev).st_rdev == ttydev:\n                return dev\n        return None\n\n    @wrap_exceptions\n    def cwd(self):\n        procfs_path = self._procfs_path\n        try:\n            result = os.readlink(\"%s/%s/cwd\" % (procfs_path, self.pid))\n            return result.rstrip('/')\n        except FileNotFoundError:\n            os.stat(\"%s/%s\" % (procfs_path, self.pid))  # raise NSP or AD\n            return \"\"\n\n    @wrap_exceptions\n    def memory_info(self):\n        ret = self._proc_basic_info()\n        rss = ret[proc_info_map['rss']] * 1024\n        vms = ret[proc_info_map['vms']] * 1024\n        return pmem(rss, vms)\n\n    memory_full_info = memory_info\n\n    @wrap_exceptions\n    def status(self):\n        code = self._proc_basic_info()[proc_info_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    def open_files(self):\n        # TODO rewrite without using procfiles (stat /proc/pid/fd/* and then\n        # find matching name of the inode)\n        p = subprocess.Popen(\n            [\"/usr/bin/procfiles\", \"-n\", str(self.pid)],\n            stdout=subprocess.PIPE,\n            stderr=subprocess.PIPE,\n        )\n        stdout, stderr = p.communicate()\n        if PY3:\n            stdout, stderr = (\n                x.decode(sys.stdout.encoding) for x in (stdout, stderr)\n            )\n        if \"no such process\" in stderr.lower():\n            raise NoSuchProcess(self.pid, self._name)\n        procfiles = re.findall(r\"(\\d+): S_IFREG.*\\s*.*name:(.*)\\n\", stdout)\n        retlist = []\n        for fd, path in procfiles:\n            path = path.strip()\n            if path.startswith(\"//\"):\n                path = path[1:]\n            if path.lower() == \"cannot be retrieved\":\n                continue\n            retlist.append(_common.popenfile(path, int(fd)))\n        return retlist\n\n    @wrap_exceptions\n    def num_fds(self):\n        if self.pid == 0:  # no /proc/0/fd\n            return 0\n        return len(os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid)))\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        return _common.pctxsw(*cext.proc_num_ctx_switches(self.pid))\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    if HAS_PROC_IO_COUNTERS:\n\n        @wrap_exceptions\n        def io_counters(self):\n            try:\n                rc, wc, rb, wb = cext.proc_io_counters(self.pid)\n            except OSError:\n                # if process is terminated, proc_io_counters returns OSError\n                # instead of NSP\n                if not pid_exists(self.pid):\n                    raise NoSuchProcess(self.pid, self._name)\n                raise\n            return _common.pio(rc, wc, rb, wb)\n", "psutil/_pslinux.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Linux platform implementation.\"\"\"\n\nfrom __future__ import division\n\nimport base64\nimport collections\nimport errno\nimport functools\nimport glob\nimport os\nimport re\nimport socket\nimport struct\nimport sys\nimport warnings\nfrom collections import defaultdict\nfrom collections import namedtuple\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_linux as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import NIC_DUPLEX_FULL\nfrom ._common import NIC_DUPLEX_HALF\nfrom ._common import NIC_DUPLEX_UNKNOWN\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import bcat\nfrom ._common import cat\nfrom ._common import debug\nfrom ._common import decode\nfrom ._common import get_procfs_path\nfrom ._common import isfile_strict\nfrom ._common import memoize\nfrom ._common import memoize_when_activated\nfrom ._common import open_binary\nfrom ._common import open_text\nfrom ._common import parse_environ_block\nfrom ._common import path_exists_strict\nfrom ._common import supports_ipv6\nfrom ._common import usage_percent\nfrom ._compat import PY3\nfrom ._compat import FileNotFoundError\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import b\nfrom ._compat import basestring\n\n\nif PY3:\n    import enum\nelse:\n    enum = None\n\n\n# fmt: off\n__extra__all__ = [\n    'PROCFS_PATH',\n    # io prio constants\n    \"IOPRIO_CLASS_NONE\", \"IOPRIO_CLASS_RT\", \"IOPRIO_CLASS_BE\",\n    \"IOPRIO_CLASS_IDLE\",\n    # connection status constants\n    \"CONN_ESTABLISHED\", \"CONN_SYN_SENT\", \"CONN_SYN_RECV\", \"CONN_FIN_WAIT1\",\n    \"CONN_FIN_WAIT2\", \"CONN_TIME_WAIT\", \"CONN_CLOSE\", \"CONN_CLOSE_WAIT\",\n    \"CONN_LAST_ACK\", \"CONN_LISTEN\", \"CONN_CLOSING\",\n]\n# fmt: on\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nPOWER_SUPPLY_PATH = \"/sys/class/power_supply\"\nHAS_PROC_SMAPS = os.path.exists('/proc/%s/smaps' % os.getpid())\nHAS_PROC_SMAPS_ROLLUP = os.path.exists('/proc/%s/smaps_rollup' % os.getpid())\nHAS_PROC_IO_PRIORITY = hasattr(cext, \"proc_ioprio_get\")\nHAS_CPU_AFFINITY = hasattr(cext, \"proc_cpu_affinity_get\")\n\n# Number of clock ticks per second\nCLOCK_TICKS = os.sysconf(\"SC_CLK_TCK\")\nPAGESIZE = cext_posix.getpagesize()\nBOOT_TIME = None  # set later\nLITTLE_ENDIAN = sys.byteorder == 'little'\n\n# \"man iostat\" states that sectors are equivalent with blocks and have\n# a size of 512 bytes. Despite this value can be queried at runtime\n# via /sys/block/{DISK}/queue/hw_sector_size and results may vary\n# between 1k, 2k, or 4k... 512 appears to be a magic constant used\n# throughout Linux source code:\n# * https://stackoverflow.com/a/38136179/376587\n# * https://lists.gt.net/linux/kernel/2241060\n# * https://github.com/giampaolo/psutil/issues/1305\n# * https://github.com/torvalds/linux/blob/\n#     4f671fe2f9523a1ea206f63fe60a7c7b3a56d5c7/include/linux/bio.h#L99\n# * https://lkml.org/lkml/2015/8/17/234\nDISK_SECTOR_SIZE = 512\n\nif enum is None:\n    AF_LINK = socket.AF_PACKET\nelse:\n    AddressFamily = enum.IntEnum(\n        'AddressFamily', {'AF_LINK': int(socket.AF_PACKET)}\n    )\n    AF_LINK = AddressFamily.AF_LINK\n\n# ioprio_* constants http://linux.die.net/man/2/ioprio_get\nif enum is None:\n    IOPRIO_CLASS_NONE = 0\n    IOPRIO_CLASS_RT = 1\n    IOPRIO_CLASS_BE = 2\n    IOPRIO_CLASS_IDLE = 3\nelse:\n\n    class IOPriority(enum.IntEnum):\n        IOPRIO_CLASS_NONE = 0\n        IOPRIO_CLASS_RT = 1\n        IOPRIO_CLASS_BE = 2\n        IOPRIO_CLASS_IDLE = 3\n\n    globals().update(IOPriority.__members__)\n\n# See:\n# https://github.com/torvalds/linux/blame/master/fs/proc/array.c\n# ...and (TASK_* constants):\n# https://github.com/torvalds/linux/blob/master/include/linux/sched.h\nPROC_STATUSES = {\n    \"R\": _common.STATUS_RUNNING,\n    \"S\": _common.STATUS_SLEEPING,\n    \"D\": _common.STATUS_DISK_SLEEP,\n    \"T\": _common.STATUS_STOPPED,\n    \"t\": _common.STATUS_TRACING_STOP,\n    \"Z\": _common.STATUS_ZOMBIE,\n    \"X\": _common.STATUS_DEAD,\n    \"x\": _common.STATUS_DEAD,\n    \"K\": _common.STATUS_WAKE_KILL,\n    \"W\": _common.STATUS_WAKING,\n    \"I\": _common.STATUS_IDLE,\n    \"P\": _common.STATUS_PARKED,\n}\n\n# https://github.com/torvalds/linux/blob/master/include/net/tcp_states.h\nTCP_STATUSES = {\n    \"01\": _common.CONN_ESTABLISHED,\n    \"02\": _common.CONN_SYN_SENT,\n    \"03\": _common.CONN_SYN_RECV,\n    \"04\": _common.CONN_FIN_WAIT1,\n    \"05\": _common.CONN_FIN_WAIT2,\n    \"06\": _common.CONN_TIME_WAIT,\n    \"07\": _common.CONN_CLOSE,\n    \"08\": _common.CONN_CLOSE_WAIT,\n    \"09\": _common.CONN_LAST_ACK,\n    \"0A\": _common.CONN_LISTEN,\n    \"0B\": _common.CONN_CLOSING,\n}\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.virtual_memory()\nsvmem = namedtuple(\n    'svmem', ['total', 'available', 'percent', 'used', 'free',\n              'active', 'inactive', 'buffers', 'cached', 'shared', 'slab'])\n# psutil.disk_io_counters()\nsdiskio = namedtuple(\n    'sdiskio', ['read_count', 'write_count',\n                'read_bytes', 'write_bytes',\n                'read_time', 'write_time',\n                'read_merged_count', 'write_merged_count',\n                'busy_time'])\n# psutil.Process().open_files()\npopenfile = namedtuple(\n    'popenfile', ['path', 'fd', 'position', 'mode', 'flags'])\n# psutil.Process().memory_info()\npmem = namedtuple('pmem', 'rss vms shared text lib data dirty')\n# psutil.Process().memory_full_info()\npfullmem = namedtuple('pfullmem', pmem._fields + ('uss', 'pss', 'swap'))\n# psutil.Process().memory_maps(grouped=True)\npmmap_grouped = namedtuple(\n    'pmmap_grouped',\n    ['path', 'rss', 'size', 'pss', 'shared_clean', 'shared_dirty',\n     'private_clean', 'private_dirty', 'referenced', 'anonymous', 'swap'])\n# psutil.Process().memory_maps(grouped=False)\npmmap_ext = namedtuple(\n    'pmmap_ext', 'addr perms ' + ' '.join(pmmap_grouped._fields))\n# psutil.Process.io_counters()\npio = namedtuple('pio', ['read_count', 'write_count',\n                         'read_bytes', 'write_bytes',\n                         'read_chars', 'write_chars'])\n# psutil.Process.cpu_times()\npcputimes = namedtuple('pcputimes',\n                       ['user', 'system', 'children_user', 'children_system',\n                        'iowait'])\n# fmt: on\n\n\n# =====================================================================\n# --- utils\n# =====================================================================\n\n\ndef readlink(path):\n    \"\"\"Wrapper around os.readlink().\"\"\"\n    assert isinstance(path, basestring), path\n    path = os.readlink(path)\n    # readlink() might return paths containing null bytes ('\\x00')\n    # resulting in \"TypeError: must be encoded string without NULL\n    # bytes, not str\" errors when the string is passed to other\n    # fs-related functions (os.*, open(), ...).\n    # Apparently everything after '\\x00' is garbage (we can have\n    # ' (deleted)', 'new' and possibly others), see:\n    # https://github.com/giampaolo/psutil/issues/717\n    path = path.split('\\x00')[0]\n    # Certain paths have ' (deleted)' appended. Usually this is\n    # bogus as the file actually exists. Even if it doesn't we\n    # don't care.\n    if path.endswith(' (deleted)') and not path_exists_strict(path):\n        path = path[:-10]\n    return path\n\n\ndef file_flags_to_mode(flags):\n    \"\"\"Convert file's open() flags into a readable string.\n    Used by Process.open_files().\n    \"\"\"\n    modes_map = {os.O_RDONLY: 'r', os.O_WRONLY: 'w', os.O_RDWR: 'w+'}\n    mode = modes_map[flags & (os.O_RDONLY | os.O_WRONLY | os.O_RDWR)]\n    if flags & os.O_APPEND:\n        mode = mode.replace('w', 'a', 1)\n    mode = mode.replace('w+', 'r+')\n    # possible values: r, w, a, r+, a+\n    return mode\n\n\ndef is_storage_device(name):\n    \"\"\"Return True if the given name refers to a root device (e.g.\n    \"sda\", \"nvme0n1\") as opposed to a logical partition (e.g.  \"sda1\",\n    \"nvme0n1p1\"). If name is a virtual device (e.g. \"loop1\", \"ram\")\n    return True.\n    \"\"\"\n    # Re-adapted from iostat source code, see:\n    # https://github.com/sysstat/sysstat/blob/\n    #     97912938cd476645b267280069e83b1c8dc0e1c7/common.c#L208\n    # Some devices may have a slash in their name (e.g. cciss/c0d0...).\n    name = name.replace('/', '!')\n    including_virtual = True\n    if including_virtual:\n        path = \"/sys/block/%s\" % name\n    else:\n        path = \"/sys/block/%s/device\" % name\n    return os.access(path, os.F_OK)\n\n\n@memoize\ndef set_scputimes_ntuple(procfs_path):\n    \"\"\"Set a namedtuple of variable fields depending on the CPU times\n    available on this Linux kernel version which may be:\n    (user, nice, system, idle, iowait, irq, softirq, [steal, [guest,\n     [guest_nice]]])\n    Used by cpu_times() function.\n    \"\"\"\n    global scputimes\n    with open_binary('%s/stat' % procfs_path) as f:\n        values = f.readline().split()[1:]\n    fields = ['user', 'nice', 'system', 'idle', 'iowait', 'irq', 'softirq']\n    vlen = len(values)\n    if vlen >= 8:\n        # Linux >= 2.6.11\n        fields.append('steal')\n    if vlen >= 9:\n        # Linux >= 2.6.24\n        fields.append('guest')\n    if vlen >= 10:\n        # Linux >= 3.2.0\n        fields.append('guest_nice')\n    scputimes = namedtuple('scputimes', fields)\n\n\ntry:\n    set_scputimes_ntuple(\"/proc\")\nexcept Exception as err:  # noqa: BLE001\n    # Don't want to crash at import time.\n    debug(\"ignoring exception on import: %r\" % err)\n    scputimes = namedtuple('scputimes', 'user system idle')(0.0, 0.0, 0.0)\n\n\n# =====================================================================\n# --- prlimit\n# =====================================================================\n\n# Backport of resource.prlimit() for Python 2. Originally this was done\n# in C, but CentOS-6 which we use to create manylinux wheels is too old\n# and does not support prlimit() syscall. As such the resulting wheel\n# would not include prlimit(), even when installed on newer systems.\n# This is the only part of psutil using ctypes.\n\nprlimit = None\ntry:\n    from resource import prlimit  # python >= 3.4\nexcept ImportError:\n    import ctypes\n\n    libc = ctypes.CDLL(None, use_errno=True)\n\n    if hasattr(libc, \"prlimit\"):\n\n        def prlimit(pid, resource_, limits=None):\n            class StructRlimit(ctypes.Structure):\n                _fields_ = [\n                    ('rlim_cur', ctypes.c_longlong),\n                    ('rlim_max', ctypes.c_longlong),\n                ]\n\n            current = StructRlimit()\n            if limits is None:\n                # get\n                ret = libc.prlimit(pid, resource_, None, ctypes.byref(current))\n            else:\n                # set\n                new = StructRlimit()\n                new.rlim_cur = limits[0]\n                new.rlim_max = limits[1]\n                ret = libc.prlimit(\n                    pid, resource_, ctypes.byref(new), ctypes.byref(current)\n                )\n\n            if ret != 0:\n                errno_ = ctypes.get_errno()\n                raise OSError(errno_, os.strerror(errno_))\n            return (current.rlim_cur, current.rlim_max)\n\n\nif prlimit is not None:\n    __extra__all__.extend(\n        [x for x in dir(cext) if x.startswith('RLIM') and x.isupper()]\n    )\n\n\n# =====================================================================\n# --- system memory\n# =====================================================================\n\n\ndef calculate_avail_vmem(mems):\n    \"\"\"Fallback for kernels < 3.14 where /proc/meminfo does not provide\n    \"MemAvailable\", see:\n    https://blog.famzah.net/2014/09/24/.\n\n    This code reimplements the algorithm outlined here:\n    https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/\n        commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773\n\n    We use this function also when \"MemAvailable\" returns 0 (possibly a\n    kernel bug, see: https://github.com/giampaolo/psutil/issues/1915).\n    In that case this routine matches \"free\" CLI tool result (\"available\"\n    column).\n\n    XXX: on recent kernels this calculation may differ by ~1.5% compared\n    to \"MemAvailable:\", as it's calculated slightly differently.\n    It is still way more realistic than doing (free + cached) though.\n    See:\n    * https://gitlab.com/procps-ng/procps/issues/42\n    * https://github.com/famzah/linux-memavailable-procfs/issues/2\n    \"\"\"\n    # Note about \"fallback\" value. According to:\n    # https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/\n    #     commit/?id=34e431b0ae398fc54ea69ff85ec700722c9da773\n    # ...long ago \"available\" memory was calculated as (free + cached),\n    # We use fallback when one of these is missing from /proc/meminfo:\n    # \"Active(file)\": introduced in 2.6.28 / Dec 2008\n    # \"Inactive(file)\": introduced in 2.6.28 / Dec 2008\n    # \"SReclaimable\": introduced in 2.6.19 / Nov 2006\n    # /proc/zoneinfo: introduced in 2.6.13 / Aug 2005\n    free = mems[b'MemFree:']\n    fallback = free + mems.get(b\"Cached:\", 0)\n    try:\n        lru_active_file = mems[b'Active(file):']\n        lru_inactive_file = mems[b'Inactive(file):']\n        slab_reclaimable = mems[b'SReclaimable:']\n    except KeyError as err:\n        debug(\n            \"%s is missing from /proc/meminfo; using an approximation for \"\n            \"calculating available memory\"\n            % err.args[0]\n        )\n        return fallback\n    try:\n        f = open_binary('%s/zoneinfo' % get_procfs_path())\n    except IOError:\n        return fallback  # kernel 2.6.13\n\n    watermark_low = 0\n    with f:\n        for line in f:\n            line = line.strip()\n            if line.startswith(b'low'):\n                watermark_low += int(line.split()[1])\n    watermark_low *= PAGESIZE\n\n    avail = free - watermark_low\n    pagecache = lru_active_file + lru_inactive_file\n    pagecache -= min(pagecache / 2, watermark_low)\n    avail += pagecache\n    avail += slab_reclaimable - min(slab_reclaimable / 2.0, watermark_low)\n    return int(avail)\n\n\ndef virtual_memory():\n    \"\"\"Report virtual memory stats.\n    This implementation mimics procps-ng-3.3.12, aka \"free\" CLI tool:\n    https://gitlab.com/procps-ng/procps/blob/\n        24fd2605c51fccc375ab0287cec33aa767f06718/proc/sysinfo.c#L778-791\n    The returned values are supposed to match both \"free\" and \"vmstat -s\"\n    CLI tools.\n    \"\"\"\n    missing_fields = []\n    mems = {}\n    with open_binary('%s/meminfo' % get_procfs_path()) as f:\n        for line in f:\n            fields = line.split()\n            mems[fields[0]] = int(fields[1]) * 1024\n\n    # /proc doc states that the available fields in /proc/meminfo vary\n    # by architecture and compile options, but these 3 values are also\n    # returned by sysinfo(2); as such we assume they are always there.\n    total = mems[b'MemTotal:']\n    free = mems[b'MemFree:']\n    try:\n        buffers = mems[b'Buffers:']\n    except KeyError:\n        # https://github.com/giampaolo/psutil/issues/1010\n        buffers = 0\n        missing_fields.append('buffers')\n    try:\n        cached = mems[b\"Cached:\"]\n    except KeyError:\n        cached = 0\n        missing_fields.append('cached')\n    else:\n        # \"free\" cmdline utility sums reclaimable to cached.\n        # Older versions of procps used to add slab memory instead.\n        # This got changed in:\n        # https://gitlab.com/procps-ng/procps/commit/\n        #     05d751c4f076a2f0118b914c5e51cfbb4762ad8e\n        cached += mems.get(b\"SReclaimable:\", 0)  # since kernel 2.6.19\n\n    try:\n        shared = mems[b'Shmem:']  # since kernel 2.6.32\n    except KeyError:\n        try:\n            shared = mems[b'MemShared:']  # kernels 2.4\n        except KeyError:\n            shared = 0\n            missing_fields.append('shared')\n\n    try:\n        active = mems[b\"Active:\"]\n    except KeyError:\n        active = 0\n        missing_fields.append('active')\n\n    try:\n        inactive = mems[b\"Inactive:\"]\n    except KeyError:\n        try:\n            inactive = (\n                mems[b\"Inact_dirty:\"]\n                + mems[b\"Inact_clean:\"]\n                + mems[b\"Inact_laundry:\"]\n            )\n        except KeyError:\n            inactive = 0\n            missing_fields.append('inactive')\n\n    try:\n        slab = mems[b\"Slab:\"]\n    except KeyError:\n        slab = 0\n\n    used = total - free - cached - buffers\n    if used < 0:\n        # May be symptomatic of running within a LCX container where such\n        # values will be dramatically distorted over those of the host.\n        used = total - free\n\n    # - starting from 4.4.0 we match free's \"available\" column.\n    #   Before 4.4.0 we calculated it as (free + buffers + cached)\n    #   which matched htop.\n    # - free and htop available memory differs as per:\n    #   http://askubuntu.com/a/369589\n    #   http://unix.stackexchange.com/a/65852/168884\n    # - MemAvailable has been introduced in kernel 3.14\n    try:\n        avail = mems[b'MemAvailable:']\n    except KeyError:\n        avail = calculate_avail_vmem(mems)\n    else:\n        if avail == 0:\n            # Yes, it can happen (probably a kernel bug):\n            # https://github.com/giampaolo/psutil/issues/1915\n            # In this case \"free\" CLI tool makes an estimate. We do the same,\n            # and it matches \"free\" CLI tool.\n            avail = calculate_avail_vmem(mems)\n\n    if avail < 0:\n        avail = 0\n        missing_fields.append('available')\n    elif avail > total:\n        # If avail is greater than total or our calculation overflows,\n        # that's symptomatic of running within a LCX container where such\n        # values will be dramatically distorted over those of the host.\n        # https://gitlab.com/procps-ng/procps/blob/\n        #     24fd2605c51fccc375ab0287cec33aa767f06718/proc/sysinfo.c#L764\n        avail = free\n\n    percent = usage_percent((total - avail), total, round_=1)\n\n    # Warn about missing metrics which are set to 0.\n    if missing_fields:\n        msg = \"%s memory stats couldn't be determined and %s set to 0\" % (\n            \", \".join(missing_fields),\n            \"was\" if len(missing_fields) == 1 else \"were\",\n        )\n        warnings.warn(msg, RuntimeWarning, stacklevel=2)\n\n    return svmem(\n        total,\n        avail,\n        percent,\n        used,\n        free,\n        active,\n        inactive,\n        buffers,\n        cached,\n        shared,\n        slab,\n    )\n\n\ndef swap_memory():\n    \"\"\"Return swap memory metrics.\"\"\"\n    mems = {}\n    with open_binary('%s/meminfo' % get_procfs_path()) as f:\n        for line in f:\n            fields = line.split()\n            mems[fields[0]] = int(fields[1]) * 1024\n    # We prefer /proc/meminfo over sysinfo() syscall so that\n    # psutil.PROCFS_PATH can be used in order to allow retrieval\n    # for linux containers, see:\n    # https://github.com/giampaolo/psutil/issues/1015\n    try:\n        total = mems[b'SwapTotal:']\n        free = mems[b'SwapFree:']\n    except KeyError:\n        _, _, _, _, total, free, unit_multiplier = cext.linux_sysinfo()\n        total *= unit_multiplier\n        free *= unit_multiplier\n\n    used = total - free\n    percent = usage_percent(used, total, round_=1)\n    # get pgin/pgouts\n    try:\n        f = open_binary(\"%s/vmstat\" % get_procfs_path())\n    except IOError as err:\n        # see https://github.com/giampaolo/psutil/issues/722\n        msg = (\n            \"'sin' and 'sout' swap memory stats couldn't \"\n            + \"be determined and were set to 0 (%s)\" % str(err)\n        )\n        warnings.warn(msg, RuntimeWarning, stacklevel=2)\n        sin = sout = 0\n    else:\n        with f:\n            sin = sout = None\n            for line in f:\n                # values are expressed in 4 kilo bytes, we want\n                # bytes instead\n                if line.startswith(b'pswpin'):\n                    sin = int(line.split(b' ')[1]) * 4 * 1024\n                elif line.startswith(b'pswpout'):\n                    sout = int(line.split(b' ')[1]) * 4 * 1024\n                if sin is not None and sout is not None:\n                    break\n            else:\n                # we might get here when dealing with exotic Linux\n                # flavors, see:\n                # https://github.com/giampaolo/psutil/issues/313\n                msg = \"'sin' and 'sout' swap memory stats couldn't \"\n                msg += \"be determined and were set to 0\"\n                warnings.warn(msg, RuntimeWarning, stacklevel=2)\n                sin = sout = 0\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return a named tuple representing the following system-wide\n    CPU times:\n    (user, nice, system, idle, iowait, irq, softirq [steal, [guest,\n     [guest_nice]]])\n    Last 3 fields may not be available on all Linux kernel versions.\n    \"\"\"\n    procfs_path = get_procfs_path()\n    set_scputimes_ntuple(procfs_path)\n    with open_binary('%s/stat' % procfs_path) as f:\n        values = f.readline().split()\n    fields = values[1 : len(scputimes._fields) + 1]\n    fields = [float(x) / CLOCK_TICKS for x in fields]\n    return scputimes(*fields)\n\n\ndef per_cpu_times():\n    \"\"\"Return a list of namedtuple representing the CPU times\n    for every CPU available on the system.\n    \"\"\"\n    procfs_path = get_procfs_path()\n    set_scputimes_ntuple(procfs_path)\n    cpus = []\n    with open_binary('%s/stat' % procfs_path) as f:\n        # get rid of the first line which refers to system wide CPU stats\n        f.readline()\n        for line in f:\n            if line.startswith(b'cpu'):\n                values = line.split()\n                fields = values[1 : len(scputimes._fields) + 1]\n                fields = [float(x) / CLOCK_TICKS for x in fields]\n                entry = scputimes(*fields)\n                cpus.append(entry)\n        return cpus\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    try:\n        return os.sysconf(\"SC_NPROCESSORS_ONLN\")\n    except ValueError:\n        # as a second fallback we try to parse /proc/cpuinfo\n        num = 0\n        with open_binary('%s/cpuinfo' % get_procfs_path()) as f:\n            for line in f:\n                if line.lower().startswith(b'processor'):\n                    num += 1\n\n        # unknown format (e.g. amrel/sparc architectures), see:\n        # https://github.com/giampaolo/psutil/issues/200\n        # try to parse /proc/stat as a last resort\n        if num == 0:\n            search = re.compile(r'cpu\\d')\n            with open_text('%s/stat' % get_procfs_path()) as f:\n                for line in f:\n                    line = line.split(' ')[0]\n                    if search.match(line):\n                        num += 1\n\n        if num == 0:\n            # mimic os.cpu_count()\n            return None\n        return num\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    # Method #1\n    ls = set()\n    # These 2 files are the same but */core_cpus_list is newer while\n    # */thread_siblings_list is deprecated and may disappear in the future.\n    # https://www.kernel.org/doc/Documentation/admin-guide/cputopology.rst\n    # https://github.com/giampaolo/psutil/pull/1727#issuecomment-707624964\n    # https://lkml.org/lkml/2019/2/26/41\n    p1 = \"/sys/devices/system/cpu/cpu[0-9]*/topology/core_cpus_list\"\n    p2 = \"/sys/devices/system/cpu/cpu[0-9]*/topology/thread_siblings_list\"\n    for path in glob.glob(p1) or glob.glob(p2):\n        with open_binary(path) as f:\n            ls.add(f.read().strip())\n    result = len(ls)\n    if result != 0:\n        return result\n\n    # Method #2\n    mapping = {}\n    current_info = {}\n    with open_binary('%s/cpuinfo' % get_procfs_path()) as f:\n        for line in f:\n            line = line.strip().lower()\n            if not line:\n                # new section\n                try:\n                    mapping[current_info[b'physical id']] = current_info[\n                        b'cpu cores'\n                    ]\n                except KeyError:\n                    pass\n                current_info = {}\n            else:\n                # ongoing section\n                if line.startswith((b'physical id', b'cpu cores')):\n                    key, value = line.split(b'\\t:', 1)\n                    current_info[key] = int(value)\n\n    result = sum(mapping.values())\n    return result or None  # mimic os.cpu_count()\n\n\ndef cpu_stats():\n    \"\"\"Return various CPU stats as a named tuple.\"\"\"\n    with open_binary('%s/stat' % get_procfs_path()) as f:\n        ctx_switches = None\n        interrupts = None\n        soft_interrupts = None\n        for line in f:\n            if line.startswith(b'ctxt'):\n                ctx_switches = int(line.split()[1])\n            elif line.startswith(b'intr'):\n                interrupts = int(line.split()[1])\n            elif line.startswith(b'softirq'):\n                soft_interrupts = int(line.split()[1])\n            if (\n                ctx_switches is not None\n                and soft_interrupts is not None\n                and interrupts is not None\n            ):\n                break\n    syscalls = 0\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\ndef _cpu_get_cpuinfo_freq():\n    \"\"\"Return current CPU frequency from cpuinfo if available.\"\"\"\n    ret = []\n    with open_binary('%s/cpuinfo' % get_procfs_path()) as f:\n        for line in f:\n            if line.lower().startswith(b'cpu mhz'):\n                ret.append(float(line.split(b':', 1)[1]))\n    return ret\n\n\nif os.path.exists(\"/sys/devices/system/cpu/cpufreq/policy0\") or os.path.exists(\n    \"/sys/devices/system/cpu/cpu0/cpufreq\"\n):\n\n    def cpu_freq():\n        \"\"\"Return frequency metrics for all CPUs.\n        Contrarily to other OSes, Linux updates these values in\n        real-time.\n        \"\"\"\n        cpuinfo_freqs = _cpu_get_cpuinfo_freq()\n        paths = glob.glob(\n            \"/sys/devices/system/cpu/cpufreq/policy[0-9]*\"\n        ) or glob.glob(\"/sys/devices/system/cpu/cpu[0-9]*/cpufreq\")\n        paths.sort(key=lambda x: int(re.search(r\"[0-9]+\", x).group()))\n        ret = []\n        pjoin = os.path.join\n        for i, path in enumerate(paths):\n            if len(paths) == len(cpuinfo_freqs):\n                # take cached value from cpuinfo if available, see:\n                # https://github.com/giampaolo/psutil/issues/1851\n                curr = cpuinfo_freqs[i] * 1000\n            else:\n                curr = bcat(pjoin(path, \"scaling_cur_freq\"), fallback=None)\n            if curr is None:\n                # Likely an old RedHat, see:\n                # https://github.com/giampaolo/psutil/issues/1071\n                curr = bcat(pjoin(path, \"cpuinfo_cur_freq\"), fallback=None)\n                if curr is None:\n                    online_path = (\n                        \"/sys/devices/system/cpu/cpu{}/online\".format(i)\n                    )\n                    # if cpu core is offline, set to all zeroes\n                    if cat(online_path, fallback=None) == \"0\\n\":\n                        ret.append(_common.scpufreq(0.0, 0.0, 0.0))\n                        continue\n                    msg = \"can't find current frequency file\"\n                    raise NotImplementedError(msg)\n            curr = int(curr) / 1000\n            max_ = int(bcat(pjoin(path, \"scaling_max_freq\"))) / 1000\n            min_ = int(bcat(pjoin(path, \"scaling_min_freq\"))) / 1000\n            ret.append(_common.scpufreq(curr, min_, max_))\n        return ret\n\nelse:\n\n    def cpu_freq():\n        \"\"\"Alternate implementation using /proc/cpuinfo.\n        min and max frequencies are not available and are set to None.\n        \"\"\"\n        return [_common.scpufreq(x, 0.0, 0.0) for x in _cpu_get_cpuinfo_freq()]\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_if_addrs = cext_posix.net_if_addrs\n\n\nclass _Ipv6UnsupportedError(Exception):\n    pass\n\n\nclass NetConnections:\n    \"\"\"A wrapper on top of /proc/net/* files, retrieving per-process\n    and system-wide open connections (TCP, UDP, UNIX) similarly to\n    \"netstat -an\".\n\n    Note: in case of UNIX sockets we're only able to determine the\n    local endpoint/path, not the one it's connected to.\n    According to [1] it would be possible but not easily.\n\n    [1] http://serverfault.com/a/417946\n    \"\"\"\n\n    def __init__(self):\n        # The string represents the basename of the corresponding\n        # /proc/net/{proto_name} file.\n        tcp4 = (\"tcp\", socket.AF_INET, socket.SOCK_STREAM)\n        tcp6 = (\"tcp6\", socket.AF_INET6, socket.SOCK_STREAM)\n        udp4 = (\"udp\", socket.AF_INET, socket.SOCK_DGRAM)\n        udp6 = (\"udp6\", socket.AF_INET6, socket.SOCK_DGRAM)\n        unix = (\"unix\", socket.AF_UNIX, None)\n        self.tmap = {\n            \"all\": (tcp4, tcp6, udp4, udp6, unix),\n            \"tcp\": (tcp4, tcp6),\n            \"tcp4\": (tcp4,),\n            \"tcp6\": (tcp6,),\n            \"udp\": (udp4, udp6),\n            \"udp4\": (udp4,),\n            \"udp6\": (udp6,),\n            \"unix\": (unix,),\n            \"inet\": (tcp4, tcp6, udp4, udp6),\n            \"inet4\": (tcp4, udp4),\n            \"inet6\": (tcp6, udp6),\n        }\n        self._procfs_path = None\n\n    def get_proc_inodes(self, pid):\n        inodes = defaultdict(list)\n        for fd in os.listdir(\"%s/%s/fd\" % (self._procfs_path, pid)):\n            try:\n                inode = readlink(\"%s/%s/fd/%s\" % (self._procfs_path, pid, fd))\n            except (FileNotFoundError, ProcessLookupError):\n                # ENOENT == file which is gone in the meantime;\n                # os.stat('/proc/%s' % self.pid) will be done later\n                # to force NSP (if it's the case)\n                continue\n            except OSError as err:\n                if err.errno == errno.EINVAL:\n                    # not a link\n                    continue\n                if err.errno == errno.ENAMETOOLONG:\n                    # file name too long\n                    debug(err)\n                    continue\n                raise\n            else:\n                if inode.startswith('socket:['):\n                    # the process is using a socket\n                    inode = inode[8:][:-1]\n                    inodes[inode].append((pid, int(fd)))\n        return inodes\n\n    def get_all_inodes(self):\n        inodes = {}\n        for pid in pids():\n            try:\n                inodes.update(self.get_proc_inodes(pid))\n            except (FileNotFoundError, ProcessLookupError, PermissionError):\n                # os.listdir() is gonna raise a lot of access denied\n                # exceptions in case of unprivileged user; that's fine\n                # as we'll just end up returning a connection with PID\n                # and fd set to None anyway.\n                # Both netstat -an and lsof does the same so it's\n                # unlikely we can do any better.\n                # ENOENT just means a PID disappeared on us.\n                continue\n        return inodes\n\n    @staticmethod\n    def decode_address(addr, family):\n        \"\"\"Accept an \"ip:port\" address as displayed in /proc/net/*\n        and convert it into a human readable form, like:\n\n        \"0500000A:0016\" -> (\"10.0.0.5\", 22)\n        \"0000000000000000FFFF00000100007F:9E49\" -> (\"::ffff:127.0.0.1\", 40521)\n\n        The IP address portion is a little or big endian four-byte\n        hexadecimal number; that is, the least significant byte is listed\n        first, so we need to reverse the order of the bytes to convert it\n        to an IP address.\n        The port is represented as a two-byte hexadecimal number.\n\n        Reference:\n        http://linuxdevcenter.com/pub/a/linux/2000/11/16/LinuxAdmin.html\n        \"\"\"\n        ip, port = addr.split(':')\n        port = int(port, 16)\n        # this usually refers to a local socket in listen mode with\n        # no end-points connected\n        if not port:\n            return ()\n        if PY3:\n            ip = ip.encode('ascii')\n        if family == socket.AF_INET:\n            # see: https://github.com/giampaolo/psutil/issues/201\n            if LITTLE_ENDIAN:\n                ip = socket.inet_ntop(family, base64.b16decode(ip)[::-1])\n            else:\n                ip = socket.inet_ntop(family, base64.b16decode(ip))\n        else:  # IPv6\n            ip = base64.b16decode(ip)\n            try:\n                # see: https://github.com/giampaolo/psutil/issues/201\n                if LITTLE_ENDIAN:\n                    ip = socket.inet_ntop(\n                        socket.AF_INET6,\n                        struct.pack('>4I', *struct.unpack('<4I', ip)),\n                    )\n                else:\n                    ip = socket.inet_ntop(\n                        socket.AF_INET6,\n                        struct.pack('<4I', *struct.unpack('<4I', ip)),\n                    )\n            except ValueError:\n                # see: https://github.com/giampaolo/psutil/issues/623\n                if not supports_ipv6():\n                    raise _Ipv6UnsupportedError\n                else:\n                    raise\n        return _common.addr(ip, port)\n\n    @staticmethod\n    def process_inet(file, family, type_, inodes, filter_pid=None):\n        \"\"\"Parse /proc/net/tcp* and /proc/net/udp* files.\"\"\"\n        if file.endswith('6') and not os.path.exists(file):\n            # IPv6 not supported\n            return\n        with open_text(file) as f:\n            f.readline()  # skip the first line\n            for lineno, line in enumerate(f, 1):\n                try:\n                    _, laddr, raddr, status, _, _, _, _, _, inode = (\n                        line.split()[:10]\n                    )\n                except ValueError:\n                    raise RuntimeError(\n                        \"error while parsing %s; malformed line %s %r\"\n                        % (file, lineno, line)\n                    )\n                if inode in inodes:\n                    # # We assume inet sockets are unique, so we error\n                    # # out if there are multiple references to the\n                    # # same inode. We won't do this for UNIX sockets.\n                    # if len(inodes[inode]) > 1 and family != socket.AF_UNIX:\n                    #     raise ValueError(\"ambiguous inode with multiple \"\n                    #                      \"PIDs references\")\n                    pid, fd = inodes[inode][0]\n                else:\n                    pid, fd = None, -1\n                if filter_pid is not None and filter_pid != pid:\n                    continue\n                else:\n                    if type_ == socket.SOCK_STREAM:\n                        status = TCP_STATUSES[status]\n                    else:\n                        status = _common.CONN_NONE\n                    try:\n                        laddr = NetConnections.decode_address(laddr, family)\n                        raddr = NetConnections.decode_address(raddr, family)\n                    except _Ipv6UnsupportedError:\n                        continue\n                    yield (fd, family, type_, laddr, raddr, status, pid)\n\n    @staticmethod\n    def process_unix(file, family, inodes, filter_pid=None):\n        \"\"\"Parse /proc/net/unix files.\"\"\"\n        with open_text(file) as f:\n            f.readline()  # skip the first line\n            for line in f:\n                tokens = line.split()\n                try:\n                    _, _, _, _, type_, _, inode = tokens[0:7]\n                except ValueError:\n                    if ' ' not in line:\n                        # see: https://github.com/giampaolo/psutil/issues/766\n                        continue\n                    raise RuntimeError(\n                        \"error while parsing %s; malformed line %r\"\n                        % (file, line)\n                    )\n                if inode in inodes:  # noqa\n                    # With UNIX sockets we can have a single inode\n                    # referencing many file descriptors.\n                    pairs = inodes[inode]\n                else:\n                    pairs = [(None, -1)]\n                for pid, fd in pairs:\n                    if filter_pid is not None and filter_pid != pid:\n                        continue\n                    else:\n                        path = tokens[-1] if len(tokens) == 8 else ''\n                        type_ = _common.socktype_to_enum(int(type_))\n                        # XXX: determining the remote endpoint of a\n                        # UNIX socket on Linux is not possible, see:\n                        # https://serverfault.com/questions/252723/\n                        raddr = \"\"\n                        status = _common.CONN_NONE\n                        yield (fd, family, type_, path, raddr, status, pid)\n\n    def retrieve(self, kind, pid=None):\n        if kind not in self.tmap:\n            raise ValueError(\n                \"invalid %r kind argument; choose between %s\"\n                % (kind, ', '.join([repr(x) for x in self.tmap]))\n            )\n        self._procfs_path = get_procfs_path()\n        if pid is not None:\n            inodes = self.get_proc_inodes(pid)\n            if not inodes:\n                # no connections for this process\n                return []\n        else:\n            inodes = self.get_all_inodes()\n        ret = set()\n        for proto_name, family, type_ in self.tmap[kind]:\n            path = \"%s/net/%s\" % (self._procfs_path, proto_name)\n            if family in (socket.AF_INET, socket.AF_INET6):\n                ls = self.process_inet(\n                    path, family, type_, inodes, filter_pid=pid\n                )\n            else:\n                ls = self.process_unix(path, family, inodes, filter_pid=pid)\n            for fd, family, type_, laddr, raddr, status, bound_pid in ls:\n                if pid:\n                    conn = _common.pconn(\n                        fd, family, type_, laddr, raddr, status\n                    )\n                else:\n                    conn = _common.sconn(\n                        fd, family, type_, laddr, raddr, status, bound_pid\n                    )\n                ret.add(conn)\n        return list(ret)\n\n\n_net_connections = NetConnections()\n\n\ndef net_connections(kind='inet'):\n    \"\"\"Return system-wide open connections.\"\"\"\n    return _net_connections.retrieve(kind)\n\n\ndef net_io_counters():\n    \"\"\"Return network I/O statistics for every network interface\n    installed on the system as a dict of raw tuples.\n    \"\"\"\n    with open_text(\"%s/net/dev\" % get_procfs_path()) as f:\n        lines = f.readlines()\n    retdict = {}\n    for line in lines[2:]:\n        colon = line.rfind(':')\n        assert colon > 0, repr(line)\n        name = line[:colon].strip()\n        fields = line[colon + 1 :].strip().split()\n\n        (\n            # in\n            bytes_recv,\n            packets_recv,\n            errin,\n            dropin,\n            _fifoin,  # unused\n            _framein,  # unused\n            _compressedin,  # unused\n            _multicastin,  # unused\n            # out\n            bytes_sent,\n            packets_sent,\n            errout,\n            dropout,\n            _fifoout,  # unused\n            _collisionsout,  # unused\n            _carrierout,  # unused\n            _compressedout,  # unused\n        ) = map(int, fields)\n\n        retdict[name] = (\n            bytes_sent,\n            bytes_recv,\n            packets_sent,\n            packets_recv,\n            errin,\n            errout,\n            dropin,\n            dropout,\n        )\n    return retdict\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    duplex_map = {\n        cext.DUPLEX_FULL: NIC_DUPLEX_FULL,\n        cext.DUPLEX_HALF: NIC_DUPLEX_HALF,\n        cext.DUPLEX_UNKNOWN: NIC_DUPLEX_UNKNOWN,\n    }\n    names = net_io_counters().keys()\n    ret = {}\n    for name in names:\n        try:\n            mtu = cext_posix.net_if_mtu(name)\n            flags = cext_posix.net_if_flags(name)\n            duplex, speed = cext.net_if_duplex_speed(name)\n        except OSError as err:\n            # https://github.com/giampaolo/psutil/issues/1279\n            if err.errno != errno.ENODEV:\n                raise\n            else:\n                debug(err)\n        else:\n            output_flags = ','.join(flags)\n            isup = 'running' in flags\n            ret[name] = _common.snicstats(\n                isup, duplex_map[duplex], speed, mtu, output_flags\n            )\n    return ret\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_usage = _psposix.disk_usage\n\n\ndef disk_io_counters(perdisk=False):\n    \"\"\"Return disk I/O statistics for every disk installed on the\n    system as a dict of raw tuples.\n    \"\"\"\n\n    def read_procfs():\n        # OK, this is a bit confusing. The format of /proc/diskstats can\n        # have 3 variations.\n        # On Linux 2.4 each line has always 15 fields, e.g.:\n        # \"3     0   8 hda 8 8 8 8 8 8 8 8 8 8 8\"\n        # On Linux 2.6+ each line *usually* has 14 fields, and the disk\n        # name is in another position, like this:\n        # \"3    0   hda 8 8 8 8 8 8 8 8 8 8 8\"\n        # ...unless (Linux 2.6) the line refers to a partition instead\n        # of a disk, in which case the line has less fields (7):\n        # \"3    1   hda1 8 8 8 8\"\n        # 4.18+ has 4 fields added:\n        # \"3    0   hda 8 8 8 8 8 8 8 8 8 8 8 0 0 0 0\"\n        # 5.5 has 2 more fields.\n        # See:\n        # https://www.kernel.org/doc/Documentation/iostats.txt\n        # https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats\n        with open_text(\"%s/diskstats\" % get_procfs_path()) as f:\n            lines = f.readlines()\n        for line in lines:\n            fields = line.split()\n            flen = len(fields)\n            # fmt: off\n            if flen == 15:\n                # Linux 2.4\n                name = fields[3]\n                reads = int(fields[2])\n                (reads_merged, rbytes, rtime, writes, writes_merged,\n                    wbytes, wtime, _, busy_time, _) = map(int, fields[4:14])\n            elif flen == 14 or flen >= 18:\n                # Linux 2.6+, line referring to a disk\n                name = fields[2]\n                (reads, reads_merged, rbytes, rtime, writes, writes_merged,\n                    wbytes, wtime, _, busy_time, _) = map(int, fields[3:14])\n            elif flen == 7:\n                # Linux 2.6+, line referring to a partition\n                name = fields[2]\n                reads, rbytes, writes, wbytes = map(int, fields[3:])\n                rtime = wtime = reads_merged = writes_merged = busy_time = 0\n            else:\n                raise ValueError(\"not sure how to interpret line %r\" % line)\n            yield (name, reads, writes, rbytes, wbytes, rtime, wtime,\n                   reads_merged, writes_merged, busy_time)\n            # fmt: on\n\n    def read_sysfs():\n        for block in os.listdir('/sys/block'):\n            for root, _, files in os.walk(os.path.join('/sys/block', block)):\n                if 'stat' not in files:\n                    continue\n                with open_text(os.path.join(root, 'stat')) as f:\n                    fields = f.read().strip().split()\n                name = os.path.basename(root)\n                # fmt: off\n                (reads, reads_merged, rbytes, rtime, writes, writes_merged,\n                    wbytes, wtime, _, busy_time) = map(int, fields[:10])\n                yield (name, reads, writes, rbytes, wbytes, rtime,\n                       wtime, reads_merged, writes_merged, busy_time)\n                # fmt: on\n\n    if os.path.exists('%s/diskstats' % get_procfs_path()):\n        gen = read_procfs()\n    elif os.path.exists('/sys/block'):\n        gen = read_sysfs()\n    else:\n        raise NotImplementedError(\n            \"%s/diskstats nor /sys/block filesystem are available on this \"\n            \"system\"\n            % get_procfs_path()\n        )\n\n    retdict = {}\n    for entry in gen:\n        # fmt: off\n        (name, reads, writes, rbytes, wbytes, rtime, wtime, reads_merged,\n            writes_merged, busy_time) = entry\n        if not perdisk and not is_storage_device(name):\n            # perdisk=False means we want to calculate totals so we skip\n            # partitions (e.g. 'sda1', 'nvme0n1p1') and only include\n            # base disk devices (e.g. 'sda', 'nvme0n1'). Base disks\n            # include a total of all their partitions + some extra size\n            # of their own:\n            #     $ cat /proc/diskstats\n            #     259       0 sda 10485760 ...\n            #     259       1 sda1 5186039 ...\n            #     259       1 sda2 5082039 ...\n            # See:\n            # https://github.com/giampaolo/psutil/pull/1313\n            continue\n\n        rbytes *= DISK_SECTOR_SIZE\n        wbytes *= DISK_SECTOR_SIZE\n        retdict[name] = (reads, writes, rbytes, wbytes, rtime, wtime,\n                         reads_merged, writes_merged, busy_time)\n        # fmt: on\n\n    return retdict\n\n\nclass RootFsDeviceFinder:\n    \"\"\"disk_partitions() may return partitions with device == \"/dev/root\"\n    or \"rootfs\". This container class uses different strategies to try to\n    obtain the real device path. Resources:\n    https://bootlin.com/blog/find-root-device/\n    https://www.systutorials.com/how-to-find-the-disk-where-root-is-on-in-bash-on-linux/.\n    \"\"\"\n\n    __slots__ = ['major', 'minor']\n\n    def __init__(self):\n        dev = os.stat(\"/\").st_dev\n        self.major = os.major(dev)\n        self.minor = os.minor(dev)\n\n    def ask_proc_partitions(self):\n        with open_text(\"%s/partitions\" % get_procfs_path()) as f:\n            for line in f.readlines()[2:]:\n                fields = line.split()\n                if len(fields) < 4:  # just for extra safety\n                    continue\n                major = int(fields[0]) if fields[0].isdigit() else None\n                minor = int(fields[1]) if fields[1].isdigit() else None\n                name = fields[3]\n                if major == self.major and minor == self.minor:\n                    if name:  # just for extra safety\n                        return \"/dev/%s\" % name\n\n    def ask_sys_dev_block(self):\n        path = \"/sys/dev/block/%s:%s/uevent\" % (self.major, self.minor)\n        with open_text(path) as f:\n            for line in f:\n                if line.startswith(\"DEVNAME=\"):\n                    name = line.strip().rpartition(\"DEVNAME=\")[2]\n                    if name:  # just for extra safety\n                        return \"/dev/%s\" % name\n\n    def ask_sys_class_block(self):\n        needle = \"%s:%s\" % (self.major, self.minor)\n        files = glob.iglob(\"/sys/class/block/*/dev\")\n        for file in files:\n            try:\n                f = open_text(file)\n            except FileNotFoundError:  # race condition\n                continue\n            else:\n                with f:\n                    data = f.read().strip()\n                    if data == needle:\n                        name = os.path.basename(os.path.dirname(file))\n                        return \"/dev/%s\" % name\n\n    def find(self):\n        path = None\n        if path is None:\n            try:\n                path = self.ask_proc_partitions()\n            except (IOError, OSError) as err:\n                debug(err)\n        if path is None:\n            try:\n                path = self.ask_sys_dev_block()\n            except (IOError, OSError) as err:\n                debug(err)\n        if path is None:\n            try:\n                path = self.ask_sys_class_block()\n            except (IOError, OSError) as err:\n                debug(err)\n        # We use exists() because the \"/dev/*\" part of the path is hard\n        # coded, so we want to be sure.\n        if path is not None and os.path.exists(path):\n            return path\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted disk partitions as a list of namedtuples.\"\"\"\n    fstypes = set()\n    procfs_path = get_procfs_path()\n    if not all:\n        with open_text(\"%s/filesystems\" % procfs_path) as f:\n            for line in f:\n                line = line.strip()\n                if not line.startswith(\"nodev\"):\n                    fstypes.add(line.strip())\n                else:\n                    # ignore all lines starting with \"nodev\" except \"nodev zfs\"\n                    fstype = line.split(\"\\t\")[1]\n                    if fstype == \"zfs\":\n                        fstypes.add(\"zfs\")\n\n    # See: https://github.com/giampaolo/psutil/issues/1307\n    if procfs_path == \"/proc\" and os.path.isfile('/etc/mtab'):\n        mounts_path = os.path.realpath(\"/etc/mtab\")\n    else:\n        mounts_path = os.path.realpath(\"%s/self/mounts\" % procfs_path)\n\n    retlist = []\n    partitions = cext.disk_partitions(mounts_path)\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if device in (\"/dev/root\", \"rootfs\"):\n            device = RootFsDeviceFinder().find() or device\n        if not all:\n            if not device or fstype not in fstypes:\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n\n    return retlist\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\ndef sensors_temperatures():\n    \"\"\"Return hardware (CPU and others) temperatures as a dict\n    including hardware name, label, current, max and critical\n    temperatures.\n\n    Implementation notes:\n    - /sys/class/hwmon looks like the most recent interface to\n      retrieve this info, and this implementation relies on it\n      only (old distros will probably use something else)\n    - lm-sensors on Ubuntu 16.04 relies on /sys/class/hwmon\n    - /sys/class/thermal/thermal_zone* is another one but it's more\n      difficult to parse\n    \"\"\"\n    ret = collections.defaultdict(list)\n    basenames = glob.glob('/sys/class/hwmon/hwmon*/temp*_*')\n    # CentOS has an intermediate /device directory:\n    # https://github.com/giampaolo/psutil/issues/971\n    # https://github.com/nicolargo/glances/issues/1060\n    basenames.extend(glob.glob('/sys/class/hwmon/hwmon*/device/temp*_*'))\n    basenames = sorted(set([x.split('_')[0] for x in basenames]))\n\n    # Only add the coretemp hwmon entries if they're not already in\n    # /sys/class/hwmon/\n    # https://github.com/giampaolo/psutil/issues/1708\n    # https://github.com/giampaolo/psutil/pull/1648\n    basenames2 = glob.glob(\n        '/sys/devices/platform/coretemp.*/hwmon/hwmon*/temp*_*'\n    )\n    repl = re.compile('/sys/devices/platform/coretemp.*/hwmon/')\n    for name in basenames2:\n        altname = repl.sub('/sys/class/hwmon/', name)\n        if altname not in basenames:\n            basenames.append(name)\n\n    for base in basenames:\n        try:\n            path = base + '_input'\n            current = float(bcat(path)) / 1000.0\n            path = os.path.join(os.path.dirname(base), 'name')\n            unit_name = cat(path).strip()\n        except (IOError, OSError, ValueError):\n            # A lot of things can go wrong here, so let's just skip the\n            # whole entry. Sure thing is Linux's /sys/class/hwmon really\n            # is a stinky broken mess.\n            # https://github.com/giampaolo/psutil/issues/1009\n            # https://github.com/giampaolo/psutil/issues/1101\n            # https://github.com/giampaolo/psutil/issues/1129\n            # https://github.com/giampaolo/psutil/issues/1245\n            # https://github.com/giampaolo/psutil/issues/1323\n            continue\n\n        high = bcat(base + '_max', fallback=None)\n        critical = bcat(base + '_crit', fallback=None)\n        label = cat(base + '_label', fallback='').strip()\n\n        if high is not None:\n            try:\n                high = float(high) / 1000.0\n            except ValueError:\n                high = None\n        if critical is not None:\n            try:\n                critical = float(critical) / 1000.0\n            except ValueError:\n                critical = None\n\n        ret[unit_name].append((label, current, high, critical))\n\n    # Indication that no sensors were detected in /sys/class/hwmon/\n    if not basenames:\n        basenames = glob.glob('/sys/class/thermal/thermal_zone*')\n        basenames = sorted(set(basenames))\n\n        for base in basenames:\n            try:\n                path = os.path.join(base, 'temp')\n                current = float(bcat(path)) / 1000.0\n                path = os.path.join(base, 'type')\n                unit_name = cat(path).strip()\n            except (IOError, OSError, ValueError) as err:\n                debug(err)\n                continue\n\n            trip_paths = glob.glob(base + '/trip_point*')\n            trip_points = set([\n                '_'.join(os.path.basename(p).split('_')[0:3])\n                for p in trip_paths\n            ])\n            critical = None\n            high = None\n            for trip_point in trip_points:\n                path = os.path.join(base, trip_point + \"_type\")\n                trip_type = cat(path, fallback='').strip()\n                if trip_type == 'critical':\n                    critical = bcat(\n                        os.path.join(base, trip_point + \"_temp\"), fallback=None\n                    )\n                elif trip_type == 'high':\n                    high = bcat(\n                        os.path.join(base, trip_point + \"_temp\"), fallback=None\n                    )\n\n                if high is not None:\n                    try:\n                        high = float(high) / 1000.0\n                    except ValueError:\n                        high = None\n                if critical is not None:\n                    try:\n                        critical = float(critical) / 1000.0\n                    except ValueError:\n                        critical = None\n\n            ret[unit_name].append(('', current, high, critical))\n\n    return dict(ret)\n\n\ndef sensors_fans():\n    \"\"\"Return hardware fans info (for CPU and other peripherals) as a\n    dict including hardware label and current speed.\n\n    Implementation notes:\n    - /sys/class/hwmon looks like the most recent interface to\n      retrieve this info, and this implementation relies on it\n      only (old distros will probably use something else)\n    - lm-sensors on Ubuntu 16.04 relies on /sys/class/hwmon\n    \"\"\"\n    ret = collections.defaultdict(list)\n    basenames = glob.glob('/sys/class/hwmon/hwmon*/fan*_*')\n    if not basenames:\n        # CentOS has an intermediate /device directory:\n        # https://github.com/giampaolo/psutil/issues/971\n        basenames = glob.glob('/sys/class/hwmon/hwmon*/device/fan*_*')\n\n    basenames = sorted(set([x.split('_')[0] for x in basenames]))\n    for base in basenames:\n        try:\n            current = int(bcat(base + '_input'))\n        except (IOError, OSError) as err:\n            debug(err)\n            continue\n        unit_name = cat(os.path.join(os.path.dirname(base), 'name')).strip()\n        label = cat(base + '_label', fallback='').strip()\n        ret[unit_name].append(_common.sfan(label, current))\n\n    return dict(ret)\n\n\ndef sensors_battery():\n    \"\"\"Return battery information.\n    Implementation note: it appears /sys/class/power_supply/BAT0/\n    directory structure may vary and provide files with the same\n    meaning but under different names, see:\n    https://github.com/giampaolo/psutil/issues/966.\n    \"\"\"\n    null = object()\n\n    def multi_bcat(*paths):\n        \"\"\"Attempt to read the content of multiple files which may\n        not exist. If none of them exist return None.\n        \"\"\"\n        for path in paths:\n            ret = bcat(path, fallback=null)\n            if ret != null:\n                try:\n                    return int(ret)\n                except ValueError:\n                    return ret.strip()\n        return None\n\n    bats = [\n        x\n        for x in os.listdir(POWER_SUPPLY_PATH)\n        if x.startswith('BAT') or 'battery' in x.lower()\n    ]\n    if not bats:\n        return None\n    # Get the first available battery. Usually this is \"BAT0\", except\n    # some rare exceptions:\n    # https://github.com/giampaolo/psutil/issues/1238\n    root = os.path.join(POWER_SUPPLY_PATH, sorted(bats)[0])\n\n    # Base metrics.\n    energy_now = multi_bcat(root + \"/energy_now\", root + \"/charge_now\")\n    power_now = multi_bcat(root + \"/power_now\", root + \"/current_now\")\n    energy_full = multi_bcat(root + \"/energy_full\", root + \"/charge_full\")\n    time_to_empty = multi_bcat(root + \"/time_to_empty_now\")\n\n    # Percent. If we have energy_full the percentage will be more\n    # accurate compared to reading /capacity file (float vs. int).\n    if energy_full is not None and energy_now is not None:\n        try:\n            percent = 100.0 * energy_now / energy_full\n        except ZeroDivisionError:\n            percent = 0.0\n    else:\n        percent = int(cat(root + \"/capacity\", fallback=-1))\n        if percent == -1:\n            return None\n\n    # Is AC power cable plugged in?\n    # Note: AC0 is not always available and sometimes (e.g. CentOS7)\n    # it's called \"AC\".\n    power_plugged = None\n    online = multi_bcat(\n        os.path.join(POWER_SUPPLY_PATH, \"AC0/online\"),\n        os.path.join(POWER_SUPPLY_PATH, \"AC/online\"),\n    )\n    if online is not None:\n        power_plugged = online == 1\n    else:\n        status = cat(root + \"/status\", fallback=\"\").strip().lower()\n        if status == \"discharging\":\n            power_plugged = False\n        elif status in (\"charging\", \"full\"):\n            power_plugged = True\n\n    # Seconds left.\n    # Note to self: we may also calculate the charging ETA as per:\n    # https://github.com/thialfihar/dotfiles/blob/\n    #     013937745fd9050c30146290e8f963d65c0179e6/bin/battery.py#L55\n    if power_plugged:\n        secsleft = _common.POWER_TIME_UNLIMITED\n    elif energy_now is not None and power_now is not None:\n        try:\n            secsleft = int(energy_now / power_now * 3600)\n        except ZeroDivisionError:\n            secsleft = _common.POWER_TIME_UNKNOWN\n    elif time_to_empty is not None:\n        secsleft = int(time_to_empty * 60)\n        if secsleft < 0:\n            secsleft = _common.POWER_TIME_UNKNOWN\n    else:\n        secsleft = _common.POWER_TIME_UNKNOWN\n\n    return _common.sbattery(percent, secsleft, power_plugged)\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, tty, hostname, tstamp, pid = item\n        nt = _common.suser(user, tty or None, hostname, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\ndef boot_time():\n    \"\"\"Return the system boot time expressed in seconds since the epoch.\"\"\"\n    global BOOT_TIME\n    path = '%s/stat' % get_procfs_path()\n    with open_binary(path) as f:\n        for line in f:\n            if line.startswith(b'btime'):\n                ret = float(line.strip().split()[1])\n                BOOT_TIME = ret\n                return ret\n        raise RuntimeError(\"line 'btime' not found in %s\" % path)\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Returns a list of PIDs currently running on the system.\"\"\"\n    return [int(x) for x in os.listdir(b(get_procfs_path())) if x.isdigit()]\n\n\ndef pid_exists(pid):\n    \"\"\"Check for the existence of a unix PID. Linux TIDs are not\n    supported (always return False).\n    \"\"\"\n    if not _psposix.pid_exists(pid):\n        return False\n    else:\n        # Linux's apparently does not distinguish between PIDs and TIDs\n        # (thread IDs).\n        # listdir(\"/proc\") won't show any TID (only PIDs) but\n        # os.stat(\"/proc/{tid}\") will succeed if {tid} exists.\n        # os.kill() can also be passed a TID. This is quite confusing.\n        # In here we want to enforce this distinction and support PIDs\n        # only, see:\n        # https://github.com/giampaolo/psutil/issues/687\n        try:\n            # Note: already checked that this is faster than using a\n            # regular expr. Also (a lot) faster than doing\n            # 'return pid in pids()'\n            path = \"%s/%s/status\" % (get_procfs_path(), pid)\n            with open_binary(path) as f:\n                for line in f:\n                    if line.startswith(b\"Tgid:\"):\n                        tgid = int(line.split()[1])\n                        # If tgid and pid are the same then we're\n                        # dealing with a process PID.\n                        return tgid == pid\n                raise ValueError(\"'Tgid' line not found in %s\" % path)\n        except (EnvironmentError, ValueError):\n            return pid in pids()\n\n\ndef ppid_map():\n    \"\"\"Obtain a {pid: ppid, ...} dict for all running processes in\n    one shot. Used to speed up Process.children().\n    \"\"\"\n    ret = {}\n    procfs_path = get_procfs_path()\n    for pid in pids():\n        try:\n            with open_binary(\"%s/%s/stat\" % (procfs_path, pid)) as f:\n                data = f.read()\n        except (FileNotFoundError, ProcessLookupError):\n            # Note: we should be able to access /stat for all processes\n            # aka it's unlikely we'll bump into EPERM, which is good.\n            pass\n        else:\n            rpar = data.rfind(b')')\n            dset = data[rpar + 2 :].split()\n            ppid = int(dset[1])\n            ret[pid] = ppid\n    return ret\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which translates bare OSError and IOError exceptions\n    into NoSuchProcess and AccessDenied.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n        except ProcessLookupError:\n            self._raise_if_zombie()\n            raise NoSuchProcess(self.pid, self._name)\n        except FileNotFoundError:\n            self._raise_if_zombie()\n            if not os.path.exists(\"%s/%s\" % (self._procfs_path, self.pid)):\n                raise NoSuchProcess(self.pid, self._name)\n            raise\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Linux process implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_procfs_path\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n        self._procfs_path = get_procfs_path()\n\n    def _is_zombie(self):\n        # Note: most of the times Linux is able to return info about the\n        # process even if it's a zombie, and /proc/{pid} will exist.\n        # There are some exceptions though, like exe(), cmdline() and\n        # memory_maps(). In these cases /proc/{pid}/{file} exists but\n        # it's empty. Instead of returning a \"null\" value we'll raise an\n        # exception.\n        try:\n            data = bcat(\"%s/%s/stat\" % (self._procfs_path, self.pid))\n        except (IOError, OSError):\n            return False\n        else:\n            rpar = data.rfind(b')')\n            status = data[rpar + 2 : rpar + 3]\n            return status == b\"Z\"\n\n    def _raise_if_zombie(self):\n        if self._is_zombie():\n            raise ZombieProcess(self.pid, self._name, self._ppid)\n\n    def _raise_if_not_alive(self):\n        \"\"\"Raise NSP if the process disappeared on us.\"\"\"\n        # For those C function who do not raise NSP, possibly returning\n        # incorrect or incomplete result.\n        os.stat('%s/%s' % (self._procfs_path, self.pid))\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _parse_stat_file(self):\n        \"\"\"Parse /proc/{pid}/stat file and return a dict with various\n        process info.\n        Using \"man proc\" as a reference: where \"man proc\" refers to\n        position N always subtract 3 (e.g ppid position 4 in\n        'man proc' == position 1 in here).\n        The return value is cached in case oneshot() ctx manager is\n        in use.\n        \"\"\"\n        data = bcat(\"%s/%s/stat\" % (self._procfs_path, self.pid))\n        # Process name is between parentheses. It can contain spaces and\n        # other parentheses. This is taken into account by looking for\n        # the first occurrence of \"(\" and the last occurrence of \")\".\n        rpar = data.rfind(b')')\n        name = data[data.find(b'(') + 1 : rpar]\n        fields = data[rpar + 2 :].split()\n\n        ret = {}\n        ret['name'] = name\n        ret['status'] = fields[0]\n        ret['ppid'] = fields[1]\n        ret['ttynr'] = fields[4]\n        ret['utime'] = fields[11]\n        ret['stime'] = fields[12]\n        ret['children_utime'] = fields[13]\n        ret['children_stime'] = fields[14]\n        ret['create_time'] = fields[19]\n        ret['cpu_num'] = fields[36]\n        ret['blkio_ticks'] = fields[39]  # aka 'delayacct_blkio_ticks'\n\n        return ret\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _read_status_file(self):\n        \"\"\"Read /proc/{pid}/stat file and return its content.\n        The return value is cached in case oneshot() ctx manager is\n        in use.\n        \"\"\"\n        with open_binary(\"%s/%s/status\" % (self._procfs_path, self.pid)) as f:\n            return f.read()\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _read_smaps_file(self):\n        with open_binary(\"%s/%s/smaps\" % (self._procfs_path, self.pid)) as f:\n            return f.read().strip()\n\n    def oneshot_enter(self):\n        self._parse_stat_file.cache_activate(self)\n        self._read_status_file.cache_activate(self)\n        self._read_smaps_file.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._parse_stat_file.cache_deactivate(self)\n        self._read_status_file.cache_deactivate(self)\n        self._read_smaps_file.cache_deactivate(self)\n\n    @wrap_exceptions\n    def name(self):\n        name = self._parse_stat_file()['name']\n        if PY3:\n            name = decode(name)\n        # XXX - gets changed later and probably needs refactoring\n        return name\n\n    @wrap_exceptions\n    def exe(self):\n        try:\n            return readlink(\"%s/%s/exe\" % (self._procfs_path, self.pid))\n        except (FileNotFoundError, ProcessLookupError):\n            self._raise_if_zombie()\n            # no such file error; might be raised also if the\n            # path actually exists for system processes with\n            # low pids (about 0-20)\n            if os.path.lexists(\"%s/%s\" % (self._procfs_path, self.pid)):\n                return \"\"\n            raise\n\n    @wrap_exceptions\n    def cmdline(self):\n        with open_text(\"%s/%s/cmdline\" % (self._procfs_path, self.pid)) as f:\n            data = f.read()\n        if not data:\n            # may happen in case of zombie process\n            self._raise_if_zombie()\n            return []\n        # 'man proc' states that args are separated by null bytes '\\0'\n        # and last char is supposed to be a null byte. Nevertheless\n        # some processes may change their cmdline after being started\n        # (via setproctitle() or similar), they are usually not\n        # compliant with this rule and use spaces instead. Google\n        # Chrome process is an example. See:\n        # https://github.com/giampaolo/psutil/issues/1179\n        sep = '\\x00' if data.endswith('\\x00') else ' '\n        if data.endswith(sep):\n            data = data[:-1]\n        cmdline = data.split(sep)\n        # Sometimes last char is a null byte '\\0' but the args are\n        # separated by spaces, see: https://github.com/giampaolo/psutil/\n        # issues/1179#issuecomment-552984549\n        if sep == '\\x00' and len(cmdline) == 1 and ' ' in data:\n            cmdline = data.split(' ')\n        return cmdline\n\n    @wrap_exceptions\n    def environ(self):\n        with open_text(\"%s/%s/environ\" % (self._procfs_path, self.pid)) as f:\n            data = f.read()\n        return parse_environ_block(data)\n\n    @wrap_exceptions\n    def terminal(self):\n        tty_nr = int(self._parse_stat_file()['ttynr'])\n        tmap = _psposix.get_terminal_map()\n        try:\n            return tmap[tty_nr]\n        except KeyError:\n            return None\n\n    # May not be available on old kernels.\n    if os.path.exists('/proc/%s/io' % os.getpid()):\n\n        @wrap_exceptions\n        def io_counters(self):\n            fname = \"%s/%s/io\" % (self._procfs_path, self.pid)\n            fields = {}\n            with open_binary(fname) as f:\n                for line in f:\n                    # https://github.com/giampaolo/psutil/issues/1004\n                    line = line.strip()\n                    if line:\n                        try:\n                            name, value = line.split(b': ')\n                        except ValueError:\n                            # https://github.com/giampaolo/psutil/issues/1004\n                            continue\n                        else:\n                            fields[name] = int(value)\n            if not fields:\n                raise RuntimeError(\"%s file was empty\" % fname)\n            try:\n                return pio(\n                    fields[b'syscr'],  # read syscalls\n                    fields[b'syscw'],  # write syscalls\n                    fields[b'read_bytes'],  # read bytes\n                    fields[b'write_bytes'],  # write bytes\n                    fields[b'rchar'],  # read chars\n                    fields[b'wchar'],  # write chars\n                )\n            except KeyError as err:\n                raise ValueError(\n                    \"%r field was not found in %s; found fields are %r\"\n                    % (err.args[0], fname, fields)\n                )\n\n    @wrap_exceptions\n    def cpu_times(self):\n        values = self._parse_stat_file()\n        utime = float(values['utime']) / CLOCK_TICKS\n        stime = float(values['stime']) / CLOCK_TICKS\n        children_utime = float(values['children_utime']) / CLOCK_TICKS\n        children_stime = float(values['children_stime']) / CLOCK_TICKS\n        iowait = float(values['blkio_ticks']) / CLOCK_TICKS\n        return pcputimes(utime, stime, children_utime, children_stime, iowait)\n\n    @wrap_exceptions\n    def cpu_num(self):\n        \"\"\"What CPU the process is on.\"\"\"\n        return int(self._parse_stat_file()['cpu_num'])\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    @wrap_exceptions\n    def create_time(self):\n        ctime = float(self._parse_stat_file()['create_time'])\n        # According to documentation, starttime is in field 21 and the\n        # unit is jiffies (clock ticks).\n        # We first divide it for clock ticks and then add uptime returning\n        # seconds since the epoch.\n        # Also use cached value if available.\n        bt = BOOT_TIME or boot_time()\n        return (ctime / CLOCK_TICKS) + bt\n\n    @wrap_exceptions\n    def memory_info(self):\n        #  ============================================================\n        # | FIELD  | DESCRIPTION                         | AKA  | TOP  |\n        #  ============================================================\n        # | rss    | resident set size                   |      | RES  |\n        # | vms    | total program size                  | size | VIRT |\n        # | shared | shared pages (from shared mappings) |      | SHR  |\n        # | text   | text ('code')                       | trs  | CODE |\n        # | lib    | library (unused in Linux 2.6)       | lrs  |      |\n        # | data   | data + stack                        | drs  | DATA |\n        # | dirty  | dirty pages (unused in Linux 2.6)   | dt   |      |\n        #  ============================================================\n        with open_binary(\"%s/%s/statm\" % (self._procfs_path, self.pid)) as f:\n            vms, rss, shared, text, lib, data, dirty = (\n                int(x) * PAGESIZE for x in f.readline().split()[:7]\n            )\n        return pmem(rss, vms, shared, text, lib, data, dirty)\n\n    if HAS_PROC_SMAPS_ROLLUP or HAS_PROC_SMAPS:\n\n        def _parse_smaps_rollup(self):\n            # /proc/pid/smaps_rollup was added to Linux in 2017. Faster\n            # than /proc/pid/smaps. It reports higher PSS than */smaps\n            # (from 1k up to 200k higher; tested against all processes).\n            # IMPORTANT: /proc/pid/smaps_rollup is weird, because it\n            # raises ESRCH / ENOENT for many PIDs, even if they're alive\n            # (also as root). In that case we'll use /proc/pid/smaps as\n            # fallback, which is slower but has a +50% success rate\n            # compared to /proc/pid/smaps_rollup.\n            uss = pss = swap = 0\n            with open_binary(\n                \"{}/{}/smaps_rollup\".format(self._procfs_path, self.pid)\n            ) as f:\n                for line in f:\n                    if line.startswith(b\"Private_\"):\n                        # Private_Clean, Private_Dirty, Private_Hugetlb\n                        uss += int(line.split()[1]) * 1024\n                    elif line.startswith(b\"Pss:\"):\n                        pss = int(line.split()[1]) * 1024\n                    elif line.startswith(b\"Swap:\"):\n                        swap = int(line.split()[1]) * 1024\n            return (uss, pss, swap)\n\n        @wrap_exceptions\n        def _parse_smaps(\n            self,\n            # Gets Private_Clean, Private_Dirty, Private_Hugetlb.\n            _private_re=re.compile(br\"\\nPrivate.*:\\s+(\\d+)\"),\n            _pss_re=re.compile(br\"\\nPss\\:\\s+(\\d+)\"),\n            _swap_re=re.compile(br\"\\nSwap\\:\\s+(\\d+)\"),\n        ):\n            # /proc/pid/smaps does not exist on kernels < 2.6.14 or if\n            # CONFIG_MMU kernel configuration option is not enabled.\n\n            # Note: using 3 regexes is faster than reading the file\n            # line by line.\n            # XXX: on Python 3 the 2 regexes are 30% slower than on\n            # Python 2 though. Figure out why.\n            #\n            # You might be tempted to calculate USS by subtracting\n            # the \"shared\" value from the \"resident\" value in\n            # /proc/<pid>/statm. But at least on Linux, statm's \"shared\"\n            # value actually counts pages backed by files, which has\n            # little to do with whether the pages are actually shared.\n            # /proc/self/smaps on the other hand appears to give us the\n            # correct information.\n            smaps_data = self._read_smaps_file()\n            # Note: smaps file can be empty for certain processes.\n            # The code below will not crash though and will result to 0.\n            uss = sum(map(int, _private_re.findall(smaps_data))) * 1024\n            pss = sum(map(int, _pss_re.findall(smaps_data))) * 1024\n            swap = sum(map(int, _swap_re.findall(smaps_data))) * 1024\n            return (uss, pss, swap)\n\n        @wrap_exceptions\n        def memory_full_info(self):\n            if HAS_PROC_SMAPS_ROLLUP:  # faster\n                try:\n                    uss, pss, swap = self._parse_smaps_rollup()\n                except (ProcessLookupError, FileNotFoundError):\n                    uss, pss, swap = self._parse_smaps()\n            else:\n                uss, pss, swap = self._parse_smaps()\n            basic_mem = self.memory_info()\n            return pfullmem(*basic_mem + (uss, pss, swap))\n\n    else:\n        memory_full_info = memory_info\n\n    if HAS_PROC_SMAPS:\n\n        @wrap_exceptions\n        def memory_maps(self):\n            \"\"\"Return process's mapped memory regions as a list of named\n            tuples. Fields are explained in 'man proc'; here is an updated\n            (Apr 2012) version: http://goo.gl/fmebo.\n\n            /proc/{PID}/smaps does not exist on kernels < 2.6.14 or if\n            CONFIG_MMU kernel configuration option is not enabled.\n            \"\"\"\n\n            def get_blocks(lines, current_block):\n                data = {}\n                for line in lines:\n                    fields = line.split(None, 5)\n                    if not fields[0].endswith(b':'):\n                        # new block section\n                        yield (current_block.pop(), data)\n                        current_block.append(line)\n                    else:\n                        try:\n                            data[fields[0]] = int(fields[1]) * 1024\n                        except ValueError:\n                            if fields[0].startswith(b'VmFlags:'):\n                                # see issue #369\n                                continue\n                            else:\n                                raise ValueError(\n                                    \"don't know how to interpret line %r\"\n                                    % line\n                                )\n                yield (current_block.pop(), data)\n\n            data = self._read_smaps_file()\n            # Note: smaps file can be empty for certain processes or for\n            # zombies.\n            if not data:\n                self._raise_if_zombie()\n                return []\n            lines = data.split(b'\\n')\n            ls = []\n            first_line = lines.pop(0)\n            current_block = [first_line]\n            for header, data in get_blocks(lines, current_block):\n                hfields = header.split(None, 5)\n                try:\n                    addr, perms, _offset, _dev, _inode, path = hfields\n                except ValueError:\n                    addr, perms, _offset, _dev, _inode, path = hfields + ['']\n                if not path:\n                    path = '[anon]'\n                else:\n                    if PY3:\n                        path = decode(path)\n                    path = path.strip()\n                    if path.endswith(' (deleted)') and not path_exists_strict(\n                        path\n                    ):\n                        path = path[:-10]\n                item = (\n                    decode(addr),\n                    decode(perms),\n                    path,\n                    data.get(b'Rss:', 0),\n                    data.get(b'Size:', 0),\n                    data.get(b'Pss:', 0),\n                    data.get(b'Shared_Clean:', 0),\n                    data.get(b'Shared_Dirty:', 0),\n                    data.get(b'Private_Clean:', 0),\n                    data.get(b'Private_Dirty:', 0),\n                    data.get(b'Referenced:', 0),\n                    data.get(b'Anonymous:', 0),\n                    data.get(b'Swap:', 0),\n                )\n                ls.append(item)\n            return ls\n\n    @wrap_exceptions\n    def cwd(self):\n        return readlink(\"%s/%s/cwd\" % (self._procfs_path, self.pid))\n\n    @wrap_exceptions\n    def num_ctx_switches(\n        self, _ctxsw_re=re.compile(br'ctxt_switches:\\t(\\d+)')\n    ):\n        data = self._read_status_file()\n        ctxsw = _ctxsw_re.findall(data)\n        if not ctxsw:\n            raise NotImplementedError(\n                \"'voluntary_ctxt_switches' and 'nonvoluntary_ctxt_switches'\"\n                \"lines were not found in %s/%s/status; the kernel is \"\n                \"probably older than 2.6.23\" % (self._procfs_path, self.pid)\n            )\n        else:\n            return _common.pctxsw(int(ctxsw[0]), int(ctxsw[1]))\n\n    @wrap_exceptions\n    def num_threads(self, _num_threads_re=re.compile(br'Threads:\\t(\\d+)')):\n        # Note: on Python 3 using a re is faster than iterating over file\n        # line by line. On Python 2 is the exact opposite, and iterating\n        # over a file on Python 3 is slower than on Python 2.\n        data = self._read_status_file()\n        return int(_num_threads_re.findall(data)[0])\n\n    @wrap_exceptions\n    def threads(self):\n        thread_ids = os.listdir(\"%s/%s/task\" % (self._procfs_path, self.pid))\n        thread_ids.sort()\n        retlist = []\n        hit_enoent = False\n        for thread_id in thread_ids:\n            fname = \"%s/%s/task/%s/stat\" % (\n                self._procfs_path,\n                self.pid,\n                thread_id,\n            )\n            try:\n                with open_binary(fname) as f:\n                    st = f.read().strip()\n            except (FileNotFoundError, ProcessLookupError):\n                # no such file or directory or no such process;\n                # it means thread disappeared on us\n                hit_enoent = True\n                continue\n            # ignore the first two values (\"pid (exe)\")\n            st = st[st.find(b')') + 2 :]\n            values = st.split(b' ')\n            utime = float(values[11]) / CLOCK_TICKS\n            stime = float(values[12]) / CLOCK_TICKS\n            ntuple = _common.pthread(int(thread_id), utime, stime)\n            retlist.append(ntuple)\n        if hit_enoent:\n            self._raise_if_not_alive()\n        return retlist\n\n    @wrap_exceptions\n    def nice_get(self):\n        # with open_text('%s/%s/stat' % (self._procfs_path, self.pid)) as f:\n        #   data = f.read()\n        #   return int(data.split()[18])\n\n        # Use C implementation\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    # starting from CentOS 6.\n    if HAS_CPU_AFFINITY:\n\n        @wrap_exceptions\n        def cpu_affinity_get(self):\n            return cext.proc_cpu_affinity_get(self.pid)\n\n        def _get_eligible_cpus(\n            self, _re=re.compile(br\"Cpus_allowed_list:\\t(\\d+)-(\\d+)\")\n        ):\n            # See: https://github.com/giampaolo/psutil/issues/956\n            data = self._read_status_file()\n            match = _re.findall(data)\n            if match:\n                return list(range(int(match[0][0]), int(match[0][1]) + 1))\n            else:\n                return list(range(len(per_cpu_times())))\n\n        @wrap_exceptions\n        def cpu_affinity_set(self, cpus):\n            try:\n                cext.proc_cpu_affinity_set(self.pid, cpus)\n            except (OSError, ValueError) as err:\n                if isinstance(err, ValueError) or err.errno == errno.EINVAL:\n                    eligible_cpus = self._get_eligible_cpus()\n                    all_cpus = tuple(range(len(per_cpu_times())))\n                    for cpu in cpus:\n                        if cpu not in all_cpus:\n                            raise ValueError(\n                                \"invalid CPU number %r; choose between %s\"\n                                % (cpu, eligible_cpus)\n                            )\n                        if cpu not in eligible_cpus:\n                            raise ValueError(\n                                \"CPU number %r is not eligible; choose \"\n                                \"between %s\" % (cpu, eligible_cpus)\n                            )\n                raise\n\n    # only starting from kernel 2.6.13\n    if HAS_PROC_IO_PRIORITY:\n\n        @wrap_exceptions\n        def ionice_get(self):\n            ioclass, value = cext.proc_ioprio_get(self.pid)\n            if enum is not None:\n                ioclass = IOPriority(ioclass)\n            return _common.pionice(ioclass, value)\n\n        @wrap_exceptions\n        def ionice_set(self, ioclass, value):\n            if value is None:\n                value = 0\n            if value and ioclass in (IOPRIO_CLASS_IDLE, IOPRIO_CLASS_NONE):\n                raise ValueError(\"%r ioclass accepts no value\" % ioclass)\n            if value < 0 or value > 7:\n                msg = \"value not in 0-7 range\"\n                raise ValueError(msg)\n            return cext.proc_ioprio_set(self.pid, ioclass, value)\n\n    if prlimit is not None:\n\n        @wrap_exceptions\n        def rlimit(self, resource_, limits=None):\n            # If pid is 0 prlimit() applies to the calling process and\n            # we don't want that. We should never get here though as\n            # PID 0 is not supported on Linux.\n            if self.pid == 0:\n                msg = \"can't use prlimit() against PID 0 process\"\n                raise ValueError(msg)\n            try:\n                if limits is None:\n                    # get\n                    return prlimit(self.pid, resource_)\n                else:\n                    # set\n                    if len(limits) != 2:\n                        msg = (\n                            \"second argument must be a (soft, hard) \"\n                            + \"tuple, got %s\" % repr(limits)\n                        )\n                        raise ValueError(msg)\n                    prlimit(self.pid, resource_, limits)\n            except OSError as err:\n                if err.errno == errno.ENOSYS:\n                    # I saw this happening on Travis:\n                    # https://travis-ci.org/giampaolo/psutil/jobs/51368273\n                    self._raise_if_zombie()\n                raise\n\n    @wrap_exceptions\n    def status(self):\n        letter = self._parse_stat_file()['status']\n        if PY3:\n            letter = letter.decode()\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(letter, '?')\n\n    @wrap_exceptions\n    def open_files(self):\n        retlist = []\n        files = os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid))\n        hit_enoent = False\n        for fd in files:\n            file = \"%s/%s/fd/%s\" % (self._procfs_path, self.pid, fd)\n            try:\n                path = readlink(file)\n            except (FileNotFoundError, ProcessLookupError):\n                # ENOENT == file which is gone in the meantime\n                hit_enoent = True\n                continue\n            except OSError as err:\n                if err.errno == errno.EINVAL:\n                    # not a link\n                    continue\n                if err.errno == errno.ENAMETOOLONG:\n                    # file name too long\n                    debug(err)\n                    continue\n                raise\n            else:\n                # If path is not an absolute there's no way to tell\n                # whether it's a regular file or not, so we skip it.\n                # A regular file is always supposed to be have an\n                # absolute path though.\n                if path.startswith('/') and isfile_strict(path):\n                    # Get file position and flags.\n                    file = \"%s/%s/fdinfo/%s\" % (\n                        self._procfs_path,\n                        self.pid,\n                        fd,\n                    )\n                    try:\n                        with open_binary(file) as f:\n                            pos = int(f.readline().split()[1])\n                            flags = int(f.readline().split()[1], 8)\n                    except (FileNotFoundError, ProcessLookupError):\n                        # fd gone in the meantime; process may\n                        # still be alive\n                        hit_enoent = True\n                    else:\n                        mode = file_flags_to_mode(flags)\n                        ntuple = popenfile(\n                            path, int(fd), int(pos), mode, flags\n                        )\n                        retlist.append(ntuple)\n        if hit_enoent:\n            self._raise_if_not_alive()\n        return retlist\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        ret = _net_connections.retrieve(kind, self.pid)\n        self._raise_if_not_alive()\n        return ret\n\n    @wrap_exceptions\n    def num_fds(self):\n        return len(os.listdir(\"%s/%s/fd\" % (self._procfs_path, self.pid)))\n\n    @wrap_exceptions\n    def ppid(self):\n        return int(self._parse_stat_file()['ppid'])\n\n    @wrap_exceptions\n    def uids(self, _uids_re=re.compile(br'Uid:\\t(\\d+)\\t(\\d+)\\t(\\d+)')):\n        data = self._read_status_file()\n        real, effective, saved = _uids_re.findall(data)[0]\n        return _common.puids(int(real), int(effective), int(saved))\n\n    @wrap_exceptions\n    def gids(self, _gids_re=re.compile(br'Gid:\\t(\\d+)\\t(\\d+)\\t(\\d+)')):\n        data = self._read_status_file()\n        real, effective, saved = _gids_re.findall(data)[0]\n        return _common.pgids(int(real), int(effective), int(saved))\n", "psutil/_psosx.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"macOS platform implementation.\"\"\"\n\nimport errno\nimport functools\nimport os\nfrom collections import namedtuple\n\nfrom . import _common\nfrom . import _psposix\nfrom . import _psutil_osx as cext\nfrom . import _psutil_posix as cext_posix\nfrom ._common import AccessDenied\nfrom ._common import NoSuchProcess\nfrom ._common import ZombieProcess\nfrom ._common import conn_tmap\nfrom ._common import conn_to_ntuple\nfrom ._common import isfile_strict\nfrom ._common import memoize_when_activated\nfrom ._common import parse_environ_block\nfrom ._common import usage_percent\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\n\n\n__extra__all__ = []\n\n\n# =====================================================================\n# --- globals\n# =====================================================================\n\n\nPAGESIZE = cext_posix.getpagesize()\nAF_LINK = cext_posix.AF_LINK\n\nTCP_STATUSES = {\n    cext.TCPS_ESTABLISHED: _common.CONN_ESTABLISHED,\n    cext.TCPS_SYN_SENT: _common.CONN_SYN_SENT,\n    cext.TCPS_SYN_RECEIVED: _common.CONN_SYN_RECV,\n    cext.TCPS_FIN_WAIT_1: _common.CONN_FIN_WAIT1,\n    cext.TCPS_FIN_WAIT_2: _common.CONN_FIN_WAIT2,\n    cext.TCPS_TIME_WAIT: _common.CONN_TIME_WAIT,\n    cext.TCPS_CLOSED: _common.CONN_CLOSE,\n    cext.TCPS_CLOSE_WAIT: _common.CONN_CLOSE_WAIT,\n    cext.TCPS_LAST_ACK: _common.CONN_LAST_ACK,\n    cext.TCPS_LISTEN: _common.CONN_LISTEN,\n    cext.TCPS_CLOSING: _common.CONN_CLOSING,\n    cext.PSUTIL_CONN_NONE: _common.CONN_NONE,\n}\n\nPROC_STATUSES = {\n    cext.SIDL: _common.STATUS_IDLE,\n    cext.SRUN: _common.STATUS_RUNNING,\n    cext.SSLEEP: _common.STATUS_SLEEPING,\n    cext.SSTOP: _common.STATUS_STOPPED,\n    cext.SZOMB: _common.STATUS_ZOMBIE,\n}\n\nkinfo_proc_map = dict(\n    ppid=0,\n    ruid=1,\n    euid=2,\n    suid=3,\n    rgid=4,\n    egid=5,\n    sgid=6,\n    ttynr=7,\n    ctime=8,\n    status=9,\n    name=10,\n)\n\npidtaskinfo_map = dict(\n    cpuutime=0,\n    cpustime=1,\n    rss=2,\n    vms=3,\n    pfaults=4,\n    pageins=5,\n    numthreads=6,\n    volctxsw=7,\n)\n\n\n# =====================================================================\n# --- named tuples\n# =====================================================================\n\n\n# fmt: off\n# psutil.cpu_times()\nscputimes = namedtuple('scputimes', ['user', 'nice', 'system', 'idle'])\n# psutil.virtual_memory()\nsvmem = namedtuple(\n    'svmem', ['total', 'available', 'percent', 'used', 'free',\n              'active', 'inactive', 'wired'])\n# psutil.Process.memory_info()\npmem = namedtuple('pmem', ['rss', 'vms', 'pfaults', 'pageins'])\n# psutil.Process.memory_full_info()\npfullmem = namedtuple('pfullmem', pmem._fields + ('uss', ))\n# fmt: on\n\n\n# =====================================================================\n# --- memory\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"System virtual memory as a namedtuple.\"\"\"\n    total, active, inactive, wired, free, speculative = cext.virtual_mem()\n    # This is how Zabbix calculate avail and used mem:\n    # https://github.com/zabbix/zabbix/blob/trunk/src/libs/zbxsysinfo/\n    #     osx/memory.c\n    # Also see: https://github.com/giampaolo/psutil/issues/1277\n    avail = inactive + free\n    used = active + wired\n    # This is NOT how Zabbix calculates free mem but it matches \"free\"\n    # cmdline utility.\n    free -= speculative\n    percent = usage_percent((total - avail), total, round_=1)\n    return svmem(total, avail, percent, used, free, active, inactive, wired)\n\n\ndef swap_memory():\n    \"\"\"Swap system memory as a (total, used, free, sin, sout) tuple.\"\"\"\n    total, used, free, sin, sout = cext.swap_mem()\n    percent = usage_percent(used, total, round_=1)\n    return _common.sswap(total, used, free, percent, sin, sout)\n\n\n# =====================================================================\n# --- CPU\n# =====================================================================\n\n\ndef cpu_times():\n    \"\"\"Return system CPU times as a namedtuple.\"\"\"\n    user, nice, system, idle = cext.cpu_times()\n    return scputimes(user, nice, system, idle)\n\n\ndef per_cpu_times():\n    \"\"\"Return system CPU times as a named tuple.\"\"\"\n    ret = []\n    for cpu_t in cext.per_cpu_times():\n        user, nice, system, idle = cpu_t\n        item = scputimes(user, nice, system, idle)\n        ret.append(item)\n    return ret\n\n\ndef cpu_count_logical():\n    \"\"\"Return the number of logical CPUs in the system.\"\"\"\n    return cext.cpu_count_logical()\n\n\ndef cpu_count_cores():\n    \"\"\"Return the number of CPU cores in the system.\"\"\"\n    return cext.cpu_count_cores()\n\n\ndef cpu_stats():\n    ctx_switches, interrupts, soft_interrupts, syscalls, _traps = (\n        cext.cpu_stats()\n    )\n    return _common.scpustats(\n        ctx_switches, interrupts, soft_interrupts, syscalls\n    )\n\n\ndef cpu_freq():\n    \"\"\"Return CPU frequency.\n    On macOS per-cpu frequency is not supported.\n    Also, the returned frequency never changes, see:\n    https://arstechnica.com/civis/viewtopic.php?f=19&t=465002.\n    \"\"\"\n    curr, min_, max_ = cext.cpu_freq()\n    return [_common.scpufreq(curr, min_, max_)]\n\n\n# =====================================================================\n# --- disks\n# =====================================================================\n\n\ndisk_usage = _psposix.disk_usage\ndisk_io_counters = cext.disk_io_counters\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted disk partitions as a list of namedtuples.\"\"\"\n    retlist = []\n    partitions = cext.disk_partitions()\n    for partition in partitions:\n        device, mountpoint, fstype, opts = partition\n        if device == 'none':\n            device = ''\n        if not all:\n            if not os.path.isabs(device) or not os.path.exists(device):\n                continue\n        ntuple = _common.sdiskpart(device, mountpoint, fstype, opts)\n        retlist.append(ntuple)\n    return retlist\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\ndef sensors_battery():\n    \"\"\"Return battery information.\"\"\"\n    try:\n        percent, minsleft, power_plugged = cext.sensors_battery()\n    except NotImplementedError:\n        # no power source - return None according to interface\n        return None\n    power_plugged = power_plugged == 1\n    if power_plugged:\n        secsleft = _common.POWER_TIME_UNLIMITED\n    elif minsleft == -1:\n        secsleft = _common.POWER_TIME_UNKNOWN\n    else:\n        secsleft = minsleft * 60\n    return _common.sbattery(percent, secsleft, power_plugged)\n\n\n# =====================================================================\n# --- network\n# =====================================================================\n\n\nnet_io_counters = cext.net_io_counters\nnet_if_addrs = cext_posix.net_if_addrs\n\n\ndef net_connections(kind='inet'):\n    \"\"\"System-wide network connections.\"\"\"\n    # Note: on macOS this will fail with AccessDenied unless\n    # the process is owned by root.\n    ret = []\n    for pid in pids():\n        try:\n            cons = Process(pid).net_connections(kind)\n        except NoSuchProcess:\n            continue\n        else:\n            if cons:\n                for c in cons:\n                    c = list(c) + [pid]\n                    ret.append(_common.sconn(*c))\n    return ret\n\n\ndef net_if_stats():\n    \"\"\"Get NIC stats (isup, duplex, speed, mtu).\"\"\"\n    names = net_io_counters().keys()\n    ret = {}\n    for name in names:\n        try:\n            mtu = cext_posix.net_if_mtu(name)\n            flags = cext_posix.net_if_flags(name)\n            duplex, speed = cext_posix.net_if_duplex_speed(name)\n        except OSError as err:\n            # https://github.com/giampaolo/psutil/issues/1279\n            if err.errno != errno.ENODEV:\n                raise\n        else:\n            if hasattr(_common, 'NicDuplex'):\n                duplex = _common.NicDuplex(duplex)\n            output_flags = ','.join(flags)\n            isup = 'running' in flags\n            ret[name] = _common.snicstats(\n                isup, duplex, speed, mtu, output_flags\n            )\n    return ret\n\n\n# =====================================================================\n# --- other system functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"The system boot time expressed in seconds since the epoch.\"\"\"\n    return cext.boot_time()\n\n\ndef users():\n    \"\"\"Return currently connected users as a list of namedtuples.\"\"\"\n    retlist = []\n    rawlist = cext.users()\n    for item in rawlist:\n        user, tty, hostname, tstamp, pid = item\n        if tty == '~':\n            continue  # reboot or shutdown\n        if not tstamp:\n            continue\n        nt = _common.suser(user, tty or None, hostname or None, tstamp, pid)\n        retlist.append(nt)\n    return retlist\n\n\n# =====================================================================\n# --- processes\n# =====================================================================\n\n\ndef pids():\n    ls = cext.pids()\n    if 0 not in ls:\n        # On certain macOS versions pids() C doesn't return PID 0 but\n        # \"ps\" does and the process is querable via sysctl():\n        # https://travis-ci.org/giampaolo/psutil/jobs/309619941\n        try:\n            Process(0).create_time()\n            ls.insert(0, 0)\n        except NoSuchProcess:\n            pass\n        except AccessDenied:\n            ls.insert(0, 0)\n    return ls\n\n\npid_exists = _psposix.pid_exists\n\n\ndef is_zombie(pid):\n    try:\n        st = cext.proc_kinfo_oneshot(pid)[kinfo_proc_map['status']]\n        return st == cext.SZOMB\n    except OSError:\n        return False\n\n\ndef wrap_exceptions(fun):\n    \"\"\"Decorator which translates bare OSError exceptions into\n    NoSuchProcess and AccessDenied.\n    \"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(self, *args, **kwargs):\n        try:\n            return fun(self, *args, **kwargs)\n        except ProcessLookupError:\n            if is_zombie(self.pid):\n                raise ZombieProcess(self.pid, self._name, self._ppid)\n            else:\n                raise NoSuchProcess(self.pid, self._name)\n        except PermissionError:\n            raise AccessDenied(self.pid, self._name)\n\n    return wrapper\n\n\nclass Process:\n    \"\"\"Wrapper class around underlying C implementation.\"\"\"\n\n    __slots__ = [\"pid\", \"_name\", \"_ppid\", \"_cache\"]\n\n    def __init__(self, pid):\n        self.pid = pid\n        self._name = None\n        self._ppid = None\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _get_kinfo_proc(self):\n        # Note: should work with all PIDs without permission issues.\n        ret = cext.proc_kinfo_oneshot(self.pid)\n        assert len(ret) == len(kinfo_proc_map)\n        return ret\n\n    @wrap_exceptions\n    @memoize_when_activated\n    def _get_pidtaskinfo(self):\n        # Note: should work for PIDs owned by user only.\n        ret = cext.proc_pidtaskinfo_oneshot(self.pid)\n        assert len(ret) == len(pidtaskinfo_map)\n        return ret\n\n    def oneshot_enter(self):\n        self._get_kinfo_proc.cache_activate(self)\n        self._get_pidtaskinfo.cache_activate(self)\n\n    def oneshot_exit(self):\n        self._get_kinfo_proc.cache_deactivate(self)\n        self._get_pidtaskinfo.cache_deactivate(self)\n\n    @wrap_exceptions\n    def name(self):\n        name = self._get_kinfo_proc()[kinfo_proc_map['name']]\n        return name if name is not None else cext.proc_name(self.pid)\n\n    @wrap_exceptions\n    def exe(self):\n        return cext.proc_exe(self.pid)\n\n    @wrap_exceptions\n    def cmdline(self):\n        return cext.proc_cmdline(self.pid)\n\n    @wrap_exceptions\n    def environ(self):\n        return parse_environ_block(cext.proc_environ(self.pid))\n\n    @wrap_exceptions\n    def ppid(self):\n        self._ppid = self._get_kinfo_proc()[kinfo_proc_map['ppid']]\n        return self._ppid\n\n    @wrap_exceptions\n    def cwd(self):\n        return cext.proc_cwd(self.pid)\n\n    @wrap_exceptions\n    def uids(self):\n        rawtuple = self._get_kinfo_proc()\n        return _common.puids(\n            rawtuple[kinfo_proc_map['ruid']],\n            rawtuple[kinfo_proc_map['euid']],\n            rawtuple[kinfo_proc_map['suid']],\n        )\n\n    @wrap_exceptions\n    def gids(self):\n        rawtuple = self._get_kinfo_proc()\n        return _common.puids(\n            rawtuple[kinfo_proc_map['rgid']],\n            rawtuple[kinfo_proc_map['egid']],\n            rawtuple[kinfo_proc_map['sgid']],\n        )\n\n    @wrap_exceptions\n    def terminal(self):\n        tty_nr = self._get_kinfo_proc()[kinfo_proc_map['ttynr']]\n        tmap = _psposix.get_terminal_map()\n        try:\n            return tmap[tty_nr]\n        except KeyError:\n            return None\n\n    @wrap_exceptions\n    def memory_info(self):\n        rawtuple = self._get_pidtaskinfo()\n        return pmem(\n            rawtuple[pidtaskinfo_map['rss']],\n            rawtuple[pidtaskinfo_map['vms']],\n            rawtuple[pidtaskinfo_map['pfaults']],\n            rawtuple[pidtaskinfo_map['pageins']],\n        )\n\n    @wrap_exceptions\n    def memory_full_info(self):\n        basic_mem = self.memory_info()\n        uss = cext.proc_memory_uss(self.pid)\n        return pfullmem(*basic_mem + (uss,))\n\n    @wrap_exceptions\n    def cpu_times(self):\n        rawtuple = self._get_pidtaskinfo()\n        return _common.pcputimes(\n            rawtuple[pidtaskinfo_map['cpuutime']],\n            rawtuple[pidtaskinfo_map['cpustime']],\n            # children user / system times are not retrievable (set to 0)\n            0.0,\n            0.0,\n        )\n\n    @wrap_exceptions\n    def create_time(self):\n        return self._get_kinfo_proc()[kinfo_proc_map['ctime']]\n\n    @wrap_exceptions\n    def num_ctx_switches(self):\n        # Unvoluntary value seems not to be available;\n        # getrusage() numbers seems to confirm this theory.\n        # We set it to 0.\n        vol = self._get_pidtaskinfo()[pidtaskinfo_map['volctxsw']]\n        return _common.pctxsw(vol, 0)\n\n    @wrap_exceptions\n    def num_threads(self):\n        return self._get_pidtaskinfo()[pidtaskinfo_map['numthreads']]\n\n    @wrap_exceptions\n    def open_files(self):\n        if self.pid == 0:\n            return []\n        files = []\n        rawlist = cext.proc_open_files(self.pid)\n        for path, fd in rawlist:\n            if isfile_strict(path):\n                ntuple = _common.popenfile(path, fd)\n                files.append(ntuple)\n        return files\n\n    @wrap_exceptions\n    def net_connections(self, kind='inet'):\n        if kind not in conn_tmap:\n            raise ValueError(\n                \"invalid %r kind argument; choose between %s\"\n                % (kind, ', '.join([repr(x) for x in conn_tmap]))\n            )\n        families, types = conn_tmap[kind]\n        rawlist = cext.proc_net_connections(self.pid, families, types)\n        ret = []\n        for item in rawlist:\n            fd, fam, type, laddr, raddr, status = item\n            nt = conn_to_ntuple(\n                fd, fam, type, laddr, raddr, status, TCP_STATUSES\n            )\n            ret.append(nt)\n        return ret\n\n    @wrap_exceptions\n    def num_fds(self):\n        if self.pid == 0:\n            return 0\n        return cext.proc_num_fds(self.pid)\n\n    @wrap_exceptions\n    def wait(self, timeout=None):\n        return _psposix.wait_pid(self.pid, timeout, self._name)\n\n    @wrap_exceptions\n    def nice_get(self):\n        return cext_posix.getpriority(self.pid)\n\n    @wrap_exceptions\n    def nice_set(self, value):\n        return cext_posix.setpriority(self.pid, value)\n\n    @wrap_exceptions\n    def status(self):\n        code = self._get_kinfo_proc()[kinfo_proc_map['status']]\n        # XXX is '?' legit? (we're not supposed to return it anyway)\n        return PROC_STATUSES.get(code, '?')\n\n    @wrap_exceptions\n    def threads(self):\n        rawlist = cext.proc_threads(self.pid)\n        retlist = []\n        for thread_id, utime, stime in rawlist:\n            ntuple = _common.pthread(thread_id, utime, stime)\n            retlist.append(ntuple)\n        return retlist\n", "psutil/_compat.py": "# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Module which provides compatibility with older Python versions.\nThis is more future-compatible rather than the opposite (prefer latest\nPython 3 way of doing things).\n\"\"\"\n\nimport collections\nimport contextlib\nimport errno\nimport functools\nimport os\nimport sys\nimport types\n\n\n# fmt: off\n__all__ = [\n    # constants\n    \"PY3\",\n    # builtins\n    \"long\", \"range\", \"super\", \"unicode\", \"basestring\",\n    # literals\n    \"b\",\n    # collections module\n    \"lru_cache\",\n    # shutil module\n    \"which\", \"get_terminal_size\",\n    # contextlib module\n    \"redirect_stderr\",\n    # python 3 exceptions\n    \"FileNotFoundError\", \"PermissionError\", \"ProcessLookupError\",\n    \"InterruptedError\", \"ChildProcessError\", \"FileExistsError\",\n]\n# fmt: on\n\n\nPY3 = sys.version_info[0] >= 3\n_SENTINEL = object()\n\nif PY3:\n    long = int\n    xrange = range\n    unicode = str\n    basestring = str\n    range = range\n\n    def b(s):\n        return s.encode(\"latin-1\")\n\nelse:\n    long = long\n    range = xrange\n    unicode = unicode\n    basestring = basestring\n\n    def b(s):\n        return s\n\n\n# --- builtins\n\n\n# Python 3 super().\n# Taken from \"future\" package.\n# Credit: Ryan Kelly\nif PY3:\n    super = super\nelse:\n    _builtin_super = super\n\n    def super(type_=_SENTINEL, type_or_obj=_SENTINEL, framedepth=1):\n        \"\"\"Like Python 3 builtin super(). If called without any arguments\n        it attempts to infer them at runtime.\n        \"\"\"\n        if type_ is _SENTINEL:\n            f = sys._getframe(framedepth)\n            try:\n                # Get the function's first positional argument.\n                type_or_obj = f.f_locals[f.f_code.co_varnames[0]]\n            except (IndexError, KeyError):\n                msg = 'super() used in a function with no args'\n                raise RuntimeError(msg)\n            try:\n                # Get the MRO so we can crawl it.\n                mro = type_or_obj.__mro__\n            except (AttributeError, RuntimeError):\n                try:\n                    mro = type_or_obj.__class__.__mro__\n                except AttributeError:\n                    msg = 'super() used in a non-newstyle class'\n                    raise RuntimeError(msg)\n            for type_ in mro:\n                #  Find the class that owns the currently-executing method.\n                for meth in type_.__dict__.values():\n                    # Drill down through any wrappers to the underlying func.\n                    # This handles e.g. classmethod() and staticmethod().\n                    try:\n                        while not isinstance(meth, types.FunctionType):\n                            if isinstance(meth, property):\n                                # Calling __get__ on the property will invoke\n                                # user code which might throw exceptions or\n                                # have side effects\n                                meth = meth.fget\n                            else:\n                                try:\n                                    meth = meth.__func__\n                                except AttributeError:\n                                    meth = meth.__get__(type_or_obj, type_)\n                    except (AttributeError, TypeError):\n                        continue\n                    if meth.func_code is f.f_code:\n                        break  # found\n                else:\n                    # Not found. Move onto the next class in MRO.\n                    continue\n                break  # found\n            else:\n                msg = 'super() called outside a method'\n                raise RuntimeError(msg)\n\n        # Dispatch to builtin super().\n        if type_or_obj is not _SENTINEL:\n            return _builtin_super(type_, type_or_obj)\n        return _builtin_super(type_)\n\n\n# --- exceptions\n\n\nif PY3:\n    FileNotFoundError = FileNotFoundError  # NOQA\n    PermissionError = PermissionError  # NOQA\n    ProcessLookupError = ProcessLookupError  # NOQA\n    InterruptedError = InterruptedError  # NOQA\n    ChildProcessError = ChildProcessError  # NOQA\n    FileExistsError = FileExistsError  # NOQA\nelse:\n    # https://github.com/PythonCharmers/python-future/blob/exceptions/\n    #     src/future/types/exceptions/pep3151.py\n    import platform\n\n    def _instance_checking_exception(base_exception=Exception):\n        def wrapped(instance_checker):\n            class TemporaryClass(base_exception):\n                def __init__(self, *args, **kwargs):\n                    if len(args) == 1 and isinstance(args[0], TemporaryClass):\n                        unwrap_me = args[0]\n                        for attr in dir(unwrap_me):\n                            if not attr.startswith('__'):\n                                setattr(self, attr, getattr(unwrap_me, attr))\n                    else:\n                        super(TemporaryClass, self).__init__(  # noqa\n                            *args, **kwargs\n                        )\n\n                class __metaclass__(type):\n                    def __instancecheck__(cls, inst):\n                        return instance_checker(inst)\n\n                    def __subclasscheck__(cls, classinfo):\n                        value = sys.exc_info()[1]\n                        return isinstance(value, cls)\n\n            TemporaryClass.__name__ = instance_checker.__name__\n            TemporaryClass.__doc__ = instance_checker.__doc__\n            return TemporaryClass\n\n        return wrapped\n\n    @_instance_checking_exception(EnvironmentError)\n    def FileNotFoundError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ENOENT\n\n    @_instance_checking_exception(EnvironmentError)\n    def ProcessLookupError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ESRCH\n\n    @_instance_checking_exception(EnvironmentError)\n    def PermissionError(inst):\n        return getattr(inst, 'errno', _SENTINEL) in (errno.EACCES, errno.EPERM)\n\n    @_instance_checking_exception(EnvironmentError)\n    def InterruptedError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.EINTR\n\n    @_instance_checking_exception(EnvironmentError)\n    def ChildProcessError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.ECHILD\n\n    @_instance_checking_exception(EnvironmentError)\n    def FileExistsError(inst):\n        return getattr(inst, 'errno', _SENTINEL) == errno.EEXIST\n\n    if platform.python_implementation() != \"CPython\":\n        try:\n            raise OSError(errno.EEXIST, \"perm\")\n        except FileExistsError:\n            pass\n        except OSError:\n            msg = (\n                \"broken or incompatible Python implementation, see: \"\n                \"https://github.com/giampaolo/psutil/issues/1659\"\n            )\n            raise RuntimeError(msg)\n\n\n# --- stdlib additions\n\n\n# py 3.2 functools.lru_cache\n# Taken from: http://code.activestate.com/recipes/578078\n# Credit: Raymond Hettinger\ntry:\n    from functools import lru_cache\nexcept ImportError:\n    try:\n        from threading import RLock\n    except ImportError:\n        from dummy_threading import RLock\n\n    _CacheInfo = collections.namedtuple(\n        \"CacheInfo\", [\"hits\", \"misses\", \"maxsize\", \"currsize\"]\n    )\n\n    class _HashedSeq(list):\n        __slots__ = ('hashvalue',)\n\n        def __init__(self, tup, hash=hash):\n            self[:] = tup\n            self.hashvalue = hash(tup)\n\n        def __hash__(self):\n            return self.hashvalue\n\n    def _make_key(\n        args,\n        kwds,\n        typed,\n        kwd_mark=(_SENTINEL,),\n        fasttypes=set((int, str, frozenset, type(None))),  # noqa\n        sorted=sorted,\n        tuple=tuple,\n        type=type,\n        len=len,\n    ):\n        key = args\n        if kwds:\n            sorted_items = sorted(kwds.items())\n            key += kwd_mark\n            for item in sorted_items:\n                key += item\n        if typed:\n            key += tuple(type(v) for v in args)\n            if kwds:\n                key += tuple(type(v) for k, v in sorted_items)\n        elif len(key) == 1 and type(key[0]) in fasttypes:\n            return key[0]\n        return _HashedSeq(key)\n\n    def lru_cache(maxsize=100, typed=False):\n        \"\"\"Least-recently-used cache decorator, see:\n        http://docs.python.org/3/library/functools.html#functools.lru_cache.\n        \"\"\"\n\n        def decorating_function(user_function):\n            cache = {}\n            stats = [0, 0]\n            HITS, MISSES = 0, 1\n            make_key = _make_key\n            cache_get = cache.get\n            _len = len\n            lock = RLock()\n            root = []\n            root[:] = [root, root, None, None]\n            nonlocal_root = [root]\n            PREV, NEXT, KEY, RESULT = 0, 1, 2, 3\n            if maxsize == 0:\n\n                def wrapper(*args, **kwds):\n                    result = user_function(*args, **kwds)\n                    stats[MISSES] += 1\n                    return result\n\n            elif maxsize is None:\n\n                def wrapper(*args, **kwds):\n                    key = make_key(args, kwds, typed)\n                    result = cache_get(key, root)\n                    if result is not root:\n                        stats[HITS] += 1\n                        return result\n                    result = user_function(*args, **kwds)\n                    cache[key] = result\n                    stats[MISSES] += 1\n                    return result\n\n            else:\n\n                def wrapper(*args, **kwds):\n                    if kwds or typed:\n                        key = make_key(args, kwds, typed)\n                    else:\n                        key = args\n                    lock.acquire()\n                    try:\n                        link = cache_get(key)\n                        if link is not None:\n                            (root,) = nonlocal_root\n                            link_prev, link_next, key, result = link\n                            link_prev[NEXT] = link_next\n                            link_next[PREV] = link_prev\n                            last = root[PREV]\n                            last[NEXT] = root[PREV] = link\n                            link[PREV] = last\n                            link[NEXT] = root\n                            stats[HITS] += 1\n                            return result\n                    finally:\n                        lock.release()\n                    result = user_function(*args, **kwds)\n                    lock.acquire()\n                    try:\n                        (root,) = nonlocal_root\n                        if key in cache:\n                            pass\n                        elif _len(cache) >= maxsize:\n                            oldroot = root\n                            oldroot[KEY] = key\n                            oldroot[RESULT] = result\n                            root = nonlocal_root[0] = oldroot[NEXT]\n                            oldkey = root[KEY]\n                            root[KEY] = root[RESULT] = None\n                            del cache[oldkey]\n                            cache[key] = oldroot\n                        else:\n                            last = root[PREV]\n                            link = [last, root, key, result]\n                            last[NEXT] = root[PREV] = cache[key] = link\n                        stats[MISSES] += 1\n                    finally:\n                        lock.release()\n                    return result\n\n            def cache_info():\n                \"\"\"Report cache statistics.\"\"\"\n                lock.acquire()\n                try:\n                    return _CacheInfo(\n                        stats[HITS], stats[MISSES], maxsize, len(cache)\n                    )\n                finally:\n                    lock.release()\n\n            def cache_clear():\n                \"\"\"Clear the cache and cache statistics.\"\"\"\n                lock.acquire()\n                try:\n                    cache.clear()\n                    root = nonlocal_root[0]\n                    root[:] = [root, root, None, None]\n                    stats[:] = [0, 0]\n                finally:\n                    lock.release()\n\n            wrapper.__wrapped__ = user_function\n            wrapper.cache_info = cache_info\n            wrapper.cache_clear = cache_clear\n            return functools.update_wrapper(wrapper, user_function)\n\n        return decorating_function\n\n\n# python 3.3\ntry:\n    from shutil import which\nexcept ImportError:\n\n    def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n        \"\"\"Given a command, mode, and a PATH string, return the path which\n        conforms to the given mode on the PATH, or None if there is no such\n        file.\n\n        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n        of os.environ.get(\"PATH\"), or can be overridden with a custom search\n        path.\n        \"\"\"\n\n        def _access_check(fn, mode):\n            return (\n                os.path.exists(fn)\n                and os.access(fn, mode)\n                and not os.path.isdir(fn)\n            )\n\n        if os.path.dirname(cmd):\n            if _access_check(cmd, mode):\n                return cmd\n            return None\n\n        if path is None:\n            path = os.environ.get(\"PATH\", os.defpath)\n        if not path:\n            return None\n        path = path.split(os.pathsep)\n\n        if sys.platform == \"win32\":\n            if os.curdir not in path:\n                path.insert(0, os.curdir)\n\n            pathext = os.environ.get(\"PATHEXT\", \"\").split(os.pathsep)\n            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n                files = [cmd]\n            else:\n                files = [cmd + ext for ext in pathext]\n        else:\n            files = [cmd]\n\n        seen = set()\n        for dir in path:\n            normdir = os.path.normcase(dir)\n            if normdir not in seen:\n                seen.add(normdir)\n                for thefile in files:\n                    name = os.path.join(dir, thefile)\n                    if _access_check(name, mode):\n                        return name\n        return None\n\n\n# python 3.3\ntry:\n    from shutil import get_terminal_size\nexcept ImportError:\n\n    def get_terminal_size(fallback=(80, 24)):\n        try:\n            import fcntl\n            import struct\n            import termios\n        except ImportError:\n            return fallback\n        else:\n            try:\n                # This should work on Linux.\n                res = struct.unpack(\n                    'hh', fcntl.ioctl(1, termios.TIOCGWINSZ, '1234')\n                )\n                return (res[1], res[0])\n            except Exception:  # noqa: BLE001\n                return fallback\n\n\n# python 3.3\ntry:\n    from subprocess import TimeoutExpired as SubprocessTimeoutExpired\nexcept ImportError:\n\n    class SubprocessTimeoutExpired(Exception):\n        pass\n\n\n# python 3.5\ntry:\n    from contextlib import redirect_stderr\nexcept ImportError:\n\n    @contextlib.contextmanager\n    def redirect_stderr(new_target):\n        original = sys.stderr\n        try:\n            sys.stderr = new_target\n            yield new_target\n        finally:\n            sys.stderr = original\n", "psutil/__init__.py": "# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"psutil is a cross-platform library for retrieving information on\nrunning processes and system utilization (CPU, memory, disks, network,\nsensors) in Python. Supported platforms:\n\n - Linux\n - Windows\n - macOS\n - FreeBSD\n - OpenBSD\n - NetBSD\n - Sun Solaris\n - AIX\n\nWorks with Python versions 2.7 and 3.6+.\n\"\"\"\n\nfrom __future__ import division\n\nimport collections\nimport contextlib\nimport datetime\nimport functools\nimport os\nimport signal\nimport subprocess\nimport sys\nimport threading\nimport time\n\n\ntry:\n    import pwd\nexcept ImportError:\n    pwd = None\n\nfrom . import _common\nfrom ._common import AIX\nfrom ._common import BSD\nfrom ._common import CONN_CLOSE\nfrom ._common import CONN_CLOSE_WAIT\nfrom ._common import CONN_CLOSING\nfrom ._common import CONN_ESTABLISHED\nfrom ._common import CONN_FIN_WAIT1\nfrom ._common import CONN_FIN_WAIT2\nfrom ._common import CONN_LAST_ACK\nfrom ._common import CONN_LISTEN\nfrom ._common import CONN_NONE\nfrom ._common import CONN_SYN_RECV\nfrom ._common import CONN_SYN_SENT\nfrom ._common import CONN_TIME_WAIT\nfrom ._common import FREEBSD  # NOQA\nfrom ._common import LINUX\nfrom ._common import MACOS\nfrom ._common import NETBSD  # NOQA\nfrom ._common import NIC_DUPLEX_FULL\nfrom ._common import NIC_DUPLEX_HALF\nfrom ._common import NIC_DUPLEX_UNKNOWN\nfrom ._common import OPENBSD  # NOQA\nfrom ._common import OSX  # deprecated alias\nfrom ._common import POSIX  # NOQA\nfrom ._common import POWER_TIME_UNKNOWN\nfrom ._common import POWER_TIME_UNLIMITED\nfrom ._common import STATUS_DEAD\nfrom ._common import STATUS_DISK_SLEEP\nfrom ._common import STATUS_IDLE\nfrom ._common import STATUS_LOCKED\nfrom ._common import STATUS_PARKED\nfrom ._common import STATUS_RUNNING\nfrom ._common import STATUS_SLEEPING\nfrom ._common import STATUS_STOPPED\nfrom ._common import STATUS_TRACING_STOP\nfrom ._common import STATUS_WAITING\nfrom ._common import STATUS_WAKING\nfrom ._common import STATUS_ZOMBIE\nfrom ._common import SUNOS\nfrom ._common import WINDOWS\nfrom ._common import AccessDenied\nfrom ._common import Error\nfrom ._common import NoSuchProcess\nfrom ._common import TimeoutExpired\nfrom ._common import ZombieProcess\nfrom ._common import debug\nfrom ._common import memoize_when_activated\nfrom ._common import wrap_numbers as _wrap_numbers\nfrom ._compat import PY3 as _PY3\nfrom ._compat import PermissionError\nfrom ._compat import ProcessLookupError\nfrom ._compat import SubprocessTimeoutExpired as _SubprocessTimeoutExpired\nfrom ._compat import long\n\n\nif LINUX:\n    # This is public API and it will be retrieved from _pslinux.py\n    # via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\n    from . import _pslinux as _psplatform\n    from ._pslinux import IOPRIO_CLASS_BE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_IDLE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_NONE  # NOQA\n    from ._pslinux import IOPRIO_CLASS_RT  # NOQA\n\nelif WINDOWS:\n    from . import _pswindows as _psplatform\n    from ._psutil_windows import ABOVE_NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import BELOW_NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import HIGH_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import IDLE_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import NORMAL_PRIORITY_CLASS  # NOQA\n    from ._psutil_windows import REALTIME_PRIORITY_CLASS  # NOQA\n    from ._pswindows import CONN_DELETE_TCB  # NOQA\n    from ._pswindows import IOPRIO_HIGH  # NOQA\n    from ._pswindows import IOPRIO_LOW  # NOQA\n    from ._pswindows import IOPRIO_NORMAL  # NOQA\n    from ._pswindows import IOPRIO_VERYLOW  # NOQA\n\nelif MACOS:\n    from . import _psosx as _psplatform\n\nelif BSD:\n    from . import _psbsd as _psplatform\n\nelif SUNOS:\n    from . import _pssunos as _psplatform\n    from ._pssunos import CONN_BOUND  # NOQA\n    from ._pssunos import CONN_IDLE  # NOQA\n\n    # This is public writable API which is read from _pslinux.py and\n    # _pssunos.py via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\nelif AIX:\n    from . import _psaix as _psplatform\n\n    # This is public API and it will be retrieved from _pslinux.py\n    # via sys.modules.\n    PROCFS_PATH = \"/proc\"\n\nelse:  # pragma: no cover\n    raise NotImplementedError('platform %s is not supported' % sys.platform)\n\n\n# fmt: off\n__all__ = [\n    # exceptions\n    \"Error\", \"NoSuchProcess\", \"ZombieProcess\", \"AccessDenied\",\n    \"TimeoutExpired\",\n\n    # constants\n    \"version_info\", \"__version__\",\n\n    \"STATUS_RUNNING\", \"STATUS_IDLE\", \"STATUS_SLEEPING\", \"STATUS_DISK_SLEEP\",\n    \"STATUS_STOPPED\", \"STATUS_TRACING_STOP\", \"STATUS_ZOMBIE\", \"STATUS_DEAD\",\n    \"STATUS_WAKING\", \"STATUS_LOCKED\", \"STATUS_WAITING\", \"STATUS_LOCKED\",\n    \"STATUS_PARKED\",\n\n    \"CONN_ESTABLISHED\", \"CONN_SYN_SENT\", \"CONN_SYN_RECV\", \"CONN_FIN_WAIT1\",\n    \"CONN_FIN_WAIT2\", \"CONN_TIME_WAIT\", \"CONN_CLOSE\", \"CONN_CLOSE_WAIT\",\n    \"CONN_LAST_ACK\", \"CONN_LISTEN\", \"CONN_CLOSING\", \"CONN_NONE\",\n    # \"CONN_IDLE\", \"CONN_BOUND\",\n\n    \"AF_LINK\",\n\n    \"NIC_DUPLEX_FULL\", \"NIC_DUPLEX_HALF\", \"NIC_DUPLEX_UNKNOWN\",\n\n    \"POWER_TIME_UNKNOWN\", \"POWER_TIME_UNLIMITED\",\n\n    \"BSD\", \"FREEBSD\", \"LINUX\", \"NETBSD\", \"OPENBSD\", \"MACOS\", \"OSX\", \"POSIX\",\n    \"SUNOS\", \"WINDOWS\", \"AIX\",\n\n    # \"RLIM_INFINITY\", \"RLIMIT_AS\", \"RLIMIT_CORE\", \"RLIMIT_CPU\", \"RLIMIT_DATA\",\n    # \"RLIMIT_FSIZE\", \"RLIMIT_LOCKS\", \"RLIMIT_MEMLOCK\", \"RLIMIT_NOFILE\",\n    # \"RLIMIT_NPROC\", \"RLIMIT_RSS\", \"RLIMIT_STACK\", \"RLIMIT_MSGQUEUE\",\n    # \"RLIMIT_NICE\", \"RLIMIT_RTPRIO\", \"RLIMIT_RTTIME\", \"RLIMIT_SIGPENDING\",\n\n    # classes\n    \"Process\", \"Popen\",\n\n    # functions\n    \"pid_exists\", \"pids\", \"process_iter\", \"wait_procs\",             # proc\n    \"virtual_memory\", \"swap_memory\",                                # memory\n    \"cpu_times\", \"cpu_percent\", \"cpu_times_percent\", \"cpu_count\",   # cpu\n    \"cpu_stats\",  # \"cpu_freq\", \"getloadavg\"\n    \"net_io_counters\", \"net_connections\", \"net_if_addrs\",           # network\n    \"net_if_stats\",\n    \"disk_io_counters\", \"disk_partitions\", \"disk_usage\",            # disk\n    # \"sensors_temperatures\", \"sensors_battery\", \"sensors_fans\"     # sensors\n    \"users\", \"boot_time\",                                           # others\n]\n# fmt: on\n\n\n__all__.extend(_psplatform.__extra__all__)\n\n# Linux, FreeBSD\nif hasattr(_psplatform.Process, \"rlimit\"):\n    # Populate global namespace with RLIM* constants.\n    from . import _psutil_posix\n\n    _globals = globals()\n    _name = None\n    for _name in dir(_psutil_posix):\n        if _name.startswith('RLIM') and _name.isupper():\n            _globals[_name] = getattr(_psutil_posix, _name)\n            __all__.append(_name)\n    del _globals, _name\n\nAF_LINK = _psplatform.AF_LINK\n\n__author__ = \"Giampaolo Rodola'\"\n__version__ = \"6.0.1\"\nversion_info = tuple([int(num) for num in __version__.split('.')])\n\n_timer = getattr(time, 'monotonic', time.time)\n_TOTAL_PHYMEM = None\n_LOWEST_PID = None\n_SENTINEL = object()\n\n# Sanity check in case the user messed up with psutil installation\n# or did something weird with sys.path. In this case we might end\n# up importing a python module using a C extension module which\n# was compiled for a different version of psutil.\n# We want to prevent that by failing sooner rather than later.\n# See: https://github.com/giampaolo/psutil/issues/564\nif int(__version__.replace('.', '')) != getattr(\n    _psplatform.cext, 'version', None\n):\n    msg = \"version conflict: %r C extension \" % _psplatform.cext.__file__\n    msg += \"module was built for another version of psutil\"\n    if hasattr(_psplatform.cext, 'version'):\n        msg += \" (%s instead of %s)\" % (\n            '.'.join([x for x in str(_psplatform.cext.version)]),\n            __version__,\n        )\n    else:\n        msg += \" (different than %s)\" % __version__\n    msg += \"; you may try to 'pip uninstall psutil', manually remove %s\" % (\n        getattr(\n            _psplatform.cext,\n            \"__file__\",\n            \"the existing psutil install directory\",\n        )\n    )\n    msg += \" or clean the virtual env somehow, then reinstall\"\n    raise ImportError(msg)\n\n\n# =====================================================================\n# --- Utils\n# =====================================================================\n\n\nif hasattr(_psplatform, 'ppid_map'):\n    # Faster version (Windows and Linux).\n    _ppid_map = _psplatform.ppid_map\nelse:  # pragma: no cover\n\n    def _ppid_map():\n        \"\"\"Return a {pid: ppid, ...} dict for all running processes in\n        one shot. Used to speed up Process.children().\n        \"\"\"\n        ret = {}\n        for pid in pids():\n            try:\n                ret[pid] = _psplatform.Process(pid).ppid()\n            except (NoSuchProcess, ZombieProcess):\n                pass\n        return ret\n\n\ndef _pprint_secs(secs):\n    \"\"\"Format seconds in a human readable form.\"\"\"\n    now = time.time()\n    secs_ago = int(now - secs)\n    fmt = \"%H:%M:%S\" if secs_ago < 60 * 60 * 24 else \"%Y-%m-%d %H:%M:%S\"\n    return datetime.datetime.fromtimestamp(secs).strftime(fmt)\n\n\n# =====================================================================\n# --- Process class\n# =====================================================================\n\n\nclass Process(object):  # noqa: UP004\n    \"\"\"Represents an OS process with the given PID.\n    If PID is omitted current process PID (os.getpid()) is used.\n    Raise NoSuchProcess if PID does not exist.\n\n    Note that most of the methods of this class do not make sure that\n    the PID of the process being queried has been reused. That means\n    that you may end up retrieving information for another process.\n\n    The only exceptions for which process identity is pre-emptively\n    checked and guaranteed are:\n\n     - parent()\n     - children()\n     - nice() (set)\n     - ionice() (set)\n     - rlimit() (set)\n     - cpu_affinity (set)\n     - suspend()\n     - resume()\n     - send_signal()\n     - terminate()\n     - kill()\n\n    To prevent this problem for all other methods you can use\n    is_running() before querying the process.\n    \"\"\"\n\n    def __init__(self, pid=None):\n        self._init(pid)\n\n    def _init(self, pid, _ignore_nsp=False):\n        if pid is None:\n            pid = os.getpid()\n        else:\n            if not _PY3 and not isinstance(pid, (int, long)):\n                msg = \"pid must be an integer (got %r)\" % pid\n                raise TypeError(msg)\n            if pid < 0:\n                msg = \"pid must be a positive integer (got %s)\" % pid\n                raise ValueError(msg)\n            try:\n                _psplatform.cext.check_pid_range(pid)\n            except OverflowError:\n                msg = \"process PID out of range (got %s)\" % pid\n                raise NoSuchProcess(pid, msg=msg)\n\n        self._pid = pid\n        self._name = None\n        self._exe = None\n        self._create_time = None\n        self._gone = False\n        self._pid_reused = False\n        self._hash = None\n        self._lock = threading.RLock()\n        # used for caching on Windows only (on POSIX ppid may change)\n        self._ppid = None\n        # platform-specific modules define an _psplatform.Process\n        # implementation class\n        self._proc = _psplatform.Process(pid)\n        self._last_sys_cpu_times = None\n        self._last_proc_cpu_times = None\n        self._exitcode = _SENTINEL\n        # cache creation time for later use in is_running() method\n        try:\n            self.create_time()\n        except AccessDenied:\n            # We should never get here as AFAIK we're able to get\n            # process creation time on all platforms even as a\n            # limited user.\n            pass\n        except ZombieProcess:\n            # Zombies can still be queried by this class (although\n            # not always) and pids() return them so just go on.\n            pass\n        except NoSuchProcess:\n            if not _ignore_nsp:\n                msg = \"process PID not found\"\n                raise NoSuchProcess(pid, msg=msg)\n            else:\n                self._gone = True\n        # This pair is supposed to identify a Process instance\n        # univocally over time (the PID alone is not enough as\n        # it might refer to a process whose PID has been reused).\n        # This will be used later in __eq__() and is_running().\n        self._ident = (self.pid, self._create_time)\n\n    def __str__(self):\n        info = collections.OrderedDict()\n        info[\"pid\"] = self.pid\n        if self._name:\n            info['name'] = self._name\n        with self.oneshot():\n            if self._pid_reused:\n                info[\"status\"] = \"terminated + PID reused\"\n            else:\n                try:\n                    info[\"name\"] = self.name()\n                    info[\"status\"] = self.status()\n                except ZombieProcess:\n                    info[\"status\"] = \"zombie\"\n                except NoSuchProcess:\n                    info[\"status\"] = \"terminated\"\n                except AccessDenied:\n                    pass\n\n            if self._exitcode not in (_SENTINEL, None):\n                info[\"exitcode\"] = self._exitcode\n            if self._create_time is not None:\n                info['started'] = _pprint_secs(self._create_time)\n\n            return \"%s.%s(%s)\" % (\n                self.__class__.__module__,\n                self.__class__.__name__,\n                \", \".join([\"%s=%r\" % (k, v) for k, v in info.items()]),\n            )\n\n    __repr__ = __str__\n\n    def __eq__(self, other):\n        # Test for equality with another Process object based\n        # on PID and creation time.\n        if not isinstance(other, Process):\n            return NotImplemented\n        if OPENBSD or NETBSD:  # pragma: no cover\n            # Zombie processes on Open/NetBSD have a creation time of\n            # 0.0. This covers the case when a process started normally\n            # (so it has a ctime), then it turned into a zombie. It's\n            # important to do this because is_running() depends on\n            # __eq__.\n            pid1, ctime1 = self._ident\n            pid2, ctime2 = other._ident\n            if pid1 == pid2:\n                if ctime1 and not ctime2:\n                    try:\n                        return self.status() == STATUS_ZOMBIE\n                    except Error:\n                        pass\n        return self._ident == other._ident\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        if self._hash is None:\n            self._hash = hash(self._ident)\n        return self._hash\n\n    def _raise_if_pid_reused(self):\n        \"\"\"Raises NoSuchProcess in case process PID has been reused.\"\"\"\n        if self._pid_reused or (not self.is_running() and self._pid_reused):\n            # We may directly raise NSP in here already if PID is just\n            # not running, but I prefer NSP to be raised naturally by\n            # the actual Process API call. This way unit tests will tell\n            # us if the API is broken (aka don't raise NSP when it\n            # should). We also remain consistent with all other \"get\"\n            # APIs which don't use _raise_if_pid_reused().\n            msg = \"process no longer exists and its PID has been reused\"\n            raise NoSuchProcess(self.pid, self._name, msg=msg)\n\n    @property\n    def pid(self):\n        \"\"\"The process PID.\"\"\"\n        return self._pid\n\n    # --- utility methods\n\n    @contextlib.contextmanager\n    def oneshot(self):\n        \"\"\"Utility context manager which considerably speeds up the\n        retrieval of multiple process information at the same time.\n\n        Internally different process info (e.g. name, ppid, uids,\n        gids, ...) may be fetched by using the same routine, but\n        only one information is returned and the others are discarded.\n        When using this context manager the internal routine is\n        executed once (in the example below on name()) and the\n        other info are cached.\n\n        The cache is cleared when exiting the context manager block.\n        The advice is to use this every time you retrieve more than\n        one information about the process. If you're lucky, you'll\n        get a hell of a speedup.\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> with p.oneshot():\n        ...     p.name()  # collect multiple info\n        ...     p.cpu_times()  # return cached value\n        ...     p.cpu_percent()  # return cached value\n        ...     p.create_time()  # return cached value\n        ...\n        >>>\n        \"\"\"\n        with self._lock:\n            if hasattr(self, \"_cache\"):\n                # NOOP: this covers the use case where the user enters the\n                # context twice:\n                #\n                # >>> with p.oneshot():\n                # ...    with p.oneshot():\n                # ...\n                #\n                # Also, since as_dict() internally uses oneshot()\n                # I expect that the code below will be a pretty common\n                # \"mistake\" that the user will make, so let's guard\n                # against that:\n                #\n                # >>> with p.oneshot():\n                # ...    p.as_dict()\n                # ...\n                yield\n            else:\n                try:\n                    # cached in case cpu_percent() is used\n                    self.cpu_times.cache_activate(self)\n                    # cached in case memory_percent() is used\n                    self.memory_info.cache_activate(self)\n                    # cached in case parent() is used\n                    self.ppid.cache_activate(self)\n                    # cached in case username() is used\n                    if POSIX:\n                        self.uids.cache_activate(self)\n                    # specific implementation cache\n                    self._proc.oneshot_enter()\n                    yield\n                finally:\n                    self.cpu_times.cache_deactivate(self)\n                    self.memory_info.cache_deactivate(self)\n                    self.ppid.cache_deactivate(self)\n                    if POSIX:\n                        self.uids.cache_deactivate(self)\n                    self._proc.oneshot_exit()\n\n    def as_dict(self, attrs=None, ad_value=None):\n        \"\"\"Utility method returning process information as a\n        hashable dictionary.\n        If *attrs* is specified it must be a list of strings\n        reflecting available Process class' attribute names\n        (e.g. ['cpu_times', 'name']) else all public (read\n        only) attributes are assumed.\n        *ad_value* is the value which gets assigned in case\n        AccessDenied or ZombieProcess exception is raised when\n        retrieving that particular process information.\n        \"\"\"\n        valid_names = _as_dict_attrnames\n        if attrs is not None:\n            if not isinstance(attrs, (list, tuple, set, frozenset)):\n                msg = \"invalid attrs type %s\" % type(attrs)\n                raise TypeError(msg)\n            attrs = set(attrs)\n            invalid_names = attrs - valid_names\n            if invalid_names:\n                msg = \"invalid attr name%s %s\" % (\n                    \"s\" if len(invalid_names) > 1 else \"\",\n                    \", \".join(map(repr, invalid_names)),\n                )\n                raise ValueError(msg)\n\n        retdict = {}\n        ls = attrs or valid_names\n        with self.oneshot():\n            for name in ls:\n                try:\n                    if name == 'pid':\n                        ret = self.pid\n                    else:\n                        meth = getattr(self, name)\n                        ret = meth()\n                except (AccessDenied, ZombieProcess):\n                    ret = ad_value\n                except NotImplementedError:\n                    # in case of not implemented functionality (may happen\n                    # on old or exotic systems) we want to crash only if\n                    # the user explicitly asked for that particular attr\n                    if attrs:\n                        raise\n                    continue\n                retdict[name] = ret\n        return retdict\n\n    def parent(self):\n        \"\"\"Return the parent process as a Process object pre-emptively\n        checking whether PID has been reused.\n        If no parent is known return None.\n        \"\"\"\n        lowest_pid = _LOWEST_PID if _LOWEST_PID is not None else pids()[0]\n        if self.pid == lowest_pid:\n            return None\n        ppid = self.ppid()\n        if ppid is not None:\n            ctime = self.create_time()\n            try:\n                parent = Process(ppid)\n                if parent.create_time() <= ctime:\n                    return parent\n                # ...else ppid has been reused by another process\n            except NoSuchProcess:\n                pass\n\n    def parents(self):\n        \"\"\"Return the parents of this process as a list of Process\n        instances. If no parents are known return an empty list.\n        \"\"\"\n        parents = []\n        proc = self.parent()\n        while proc is not None:\n            parents.append(proc)\n            proc = proc.parent()\n        return parents\n\n    def is_running(self):\n        \"\"\"Return whether this process is running.\n\n        It also checks if PID has been reused by another process, in\n        which case it will remove the process from `process_iter()`\n        internal cache and return False.\n        \"\"\"\n        if self._gone or self._pid_reused:\n            return False\n        try:\n            # Checking if PID is alive is not enough as the PID might\n            # have been reused by another process. Process identity /\n            # uniqueness over time is guaranteed by (PID + creation\n            # time) and that is verified in __eq__.\n            self._pid_reused = self != Process(self.pid)\n            if self._pid_reused:\n                _pids_reused.add(self.pid)\n                raise NoSuchProcess(self.pid)\n            return True\n        except ZombieProcess:\n            # We should never get here as it's already handled in\n            # Process.__init__; here just for extra safety.\n            return True\n        except NoSuchProcess:\n            self._gone = True\n            return False\n\n    # --- actual API\n\n    @memoize_when_activated\n    def ppid(self):\n        \"\"\"The process parent PID.\n        On Windows the return value is cached after first call.\n        \"\"\"\n        # On POSIX we don't want to cache the ppid as it may unexpectedly\n        # change to 1 (init) in case this process turns into a zombie:\n        # https://github.com/giampaolo/psutil/issues/321\n        # http://stackoverflow.com/questions/356722/\n\n        # XXX should we check creation time here rather than in\n        # Process.parent()?\n        self._raise_if_pid_reused()\n        if POSIX:\n            return self._proc.ppid()\n        else:  # pragma: no cover\n            self._ppid = self._ppid or self._proc.ppid()\n            return self._ppid\n\n    def name(self):\n        \"\"\"The process name. The return value is cached after first call.\"\"\"\n        # Process name is only cached on Windows as on POSIX it may\n        # change, see:\n        # https://github.com/giampaolo/psutil/issues/692\n        if WINDOWS and self._name is not None:\n            return self._name\n        name = self._proc.name()\n        if POSIX and len(name) >= 15:\n            # On UNIX the name gets truncated to the first 15 characters.\n            # If it matches the first part of the cmdline we return that\n            # one instead because it's usually more explicative.\n            # Examples are \"gnome-keyring-d\" vs. \"gnome-keyring-daemon\".\n            try:\n                cmdline = self.cmdline()\n            except (AccessDenied, ZombieProcess):\n                # Just pass and return the truncated name: it's better\n                # than nothing. Note: there are actual cases where a\n                # zombie process can return a name() but not a\n                # cmdline(), see:\n                # https://github.com/giampaolo/psutil/issues/2239\n                pass\n            else:\n                if cmdline:\n                    extended_name = os.path.basename(cmdline[0])\n                    if extended_name.startswith(name):\n                        name = extended_name\n        self._name = name\n        self._proc._name = name\n        return name\n\n    def exe(self):\n        \"\"\"The process executable as an absolute path.\n        May also be an empty string.\n        The return value is cached after first call.\n        \"\"\"\n\n        def guess_it(fallback):\n            # try to guess exe from cmdline[0] in absence of a native\n            # exe representation\n            cmdline = self.cmdline()\n            if cmdline and hasattr(os, 'access') and hasattr(os, 'X_OK'):\n                exe = cmdline[0]  # the possible exe\n                # Attempt to guess only in case of an absolute path.\n                # It is not safe otherwise as the process might have\n                # changed cwd.\n                if (\n                    os.path.isabs(exe)\n                    and os.path.isfile(exe)\n                    and os.access(exe, os.X_OK)\n                ):\n                    return exe\n            if isinstance(fallback, AccessDenied):\n                raise fallback\n            return fallback\n\n        if self._exe is None:\n            try:\n                exe = self._proc.exe()\n            except AccessDenied as err:\n                return guess_it(fallback=err)\n            else:\n                if not exe:\n                    # underlying implementation can legitimately return an\n                    # empty string; if that's the case we don't want to\n                    # raise AD while guessing from the cmdline\n                    try:\n                        exe = guess_it(fallback=exe)\n                    except AccessDenied:\n                        pass\n                self._exe = exe\n        return self._exe\n\n    def cmdline(self):\n        \"\"\"The command line this process has been called with.\"\"\"\n        return self._proc.cmdline()\n\n    def status(self):\n        \"\"\"The process current status as a STATUS_* constant.\"\"\"\n        try:\n            return self._proc.status()\n        except ZombieProcess:\n            return STATUS_ZOMBIE\n\n    def username(self):\n        \"\"\"The name of the user that owns the process.\n        On UNIX this is calculated by using *real* process uid.\n        \"\"\"\n        if POSIX:\n            if pwd is None:\n                # might happen if python was installed from sources\n                msg = \"requires pwd module shipped with standard python\"\n                raise ImportError(msg)\n            real_uid = self.uids().real\n            try:\n                return pwd.getpwuid(real_uid).pw_name\n            except KeyError:\n                # the uid can't be resolved by the system\n                return str(real_uid)\n        else:\n            return self._proc.username()\n\n    def create_time(self):\n        \"\"\"The process creation time as a floating point number\n        expressed in seconds since the epoch.\n        The return value is cached after first call.\n        \"\"\"\n        if self._create_time is None:\n            self._create_time = self._proc.create_time()\n        return self._create_time\n\n    def cwd(self):\n        \"\"\"Process current working directory as an absolute path.\"\"\"\n        return self._proc.cwd()\n\n    def nice(self, value=None):\n        \"\"\"Get or set process niceness (priority).\"\"\"\n        if value is None:\n            return self._proc.nice_get()\n        else:\n            self._raise_if_pid_reused()\n            self._proc.nice_set(value)\n\n    if POSIX:\n\n        @memoize_when_activated\n        def uids(self):\n            \"\"\"Return process UIDs as a (real, effective, saved)\n            namedtuple.\n            \"\"\"\n            return self._proc.uids()\n\n        def gids(self):\n            \"\"\"Return process GIDs as a (real, effective, saved)\n            namedtuple.\n            \"\"\"\n            return self._proc.gids()\n\n        def terminal(self):\n            \"\"\"The terminal associated with this process, if any,\n            else None.\n            \"\"\"\n            return self._proc.terminal()\n\n        def num_fds(self):\n            \"\"\"Return the number of file descriptors opened by this\n            process (POSIX only).\n            \"\"\"\n            return self._proc.num_fds()\n\n    # Linux, BSD, AIX and Windows only\n    if hasattr(_psplatform.Process, \"io_counters\"):\n\n        def io_counters(self):\n            \"\"\"Return process I/O statistics as a\n            (read_count, write_count, read_bytes, write_bytes)\n            namedtuple.\n            Those are the number of read/write calls performed and the\n            amount of bytes read and written by the process.\n            \"\"\"\n            return self._proc.io_counters()\n\n    # Linux and Windows\n    if hasattr(_psplatform.Process, \"ionice_get\"):\n\n        def ionice(self, ioclass=None, value=None):\n            \"\"\"Get or set process I/O niceness (priority).\n\n            On Linux *ioclass* is one of the IOPRIO_CLASS_* constants.\n            *value* is a number which goes from 0 to 7. The higher the\n            value, the lower the I/O priority of the process.\n\n            On Windows only *ioclass* is used and it can be set to 2\n            (normal), 1 (low) or 0 (very low).\n\n            Available on Linux and Windows > Vista only.\n            \"\"\"\n            if ioclass is None:\n                if value is not None:\n                    msg = \"'ioclass' argument must be specified\"\n                    raise ValueError(msg)\n                return self._proc.ionice_get()\n            else:\n                self._raise_if_pid_reused()\n                return self._proc.ionice_set(ioclass, value)\n\n    # Linux / FreeBSD only\n    if hasattr(_psplatform.Process, \"rlimit\"):\n\n        def rlimit(self, resource, limits=None):\n            \"\"\"Get or set process resource limits as a (soft, hard)\n            tuple.\n\n            *resource* is one of the RLIMIT_* constants.\n            *limits* is supposed to be a (soft, hard) tuple.\n\n            See \"man prlimit\" for further info.\n            Available on Linux and FreeBSD only.\n            \"\"\"\n            if limits is not None:\n                self._raise_if_pid_reused()\n            return self._proc.rlimit(resource, limits)\n\n    # Windows, Linux and FreeBSD only\n    if hasattr(_psplatform.Process, \"cpu_affinity_get\"):\n\n        def cpu_affinity(self, cpus=None):\n            \"\"\"Get or set process CPU affinity.\n            If specified, *cpus* must be a list of CPUs for which you\n            want to set the affinity (e.g. [0, 1]).\n            If an empty list is passed, all egible CPUs are assumed\n            (and set).\n            (Windows, Linux and BSD only).\n            \"\"\"\n            if cpus is None:\n                return sorted(set(self._proc.cpu_affinity_get()))\n            else:\n                self._raise_if_pid_reused()\n                if not cpus:\n                    if hasattr(self._proc, \"_get_eligible_cpus\"):\n                        cpus = self._proc._get_eligible_cpus()\n                    else:\n                        cpus = tuple(range(len(cpu_times(percpu=True))))\n                self._proc.cpu_affinity_set(list(set(cpus)))\n\n    # Linux, FreeBSD, SunOS\n    if hasattr(_psplatform.Process, \"cpu_num\"):\n\n        def cpu_num(self):\n            \"\"\"Return what CPU this process is currently running on.\n            The returned number should be <= psutil.cpu_count()\n            and <= len(psutil.cpu_percent(percpu=True)).\n            It may be used in conjunction with\n            psutil.cpu_percent(percpu=True) to observe the system\n            workload distributed across CPUs.\n            \"\"\"\n            return self._proc.cpu_num()\n\n    # All platforms has it, but maybe not in the future.\n    if hasattr(_psplatform.Process, \"environ\"):\n\n        def environ(self):\n            \"\"\"The environment variables of the process as a dict.  Note: this\n            might not reflect changes made after the process started.\n            \"\"\"\n            return self._proc.environ()\n\n    if WINDOWS:\n\n        def num_handles(self):\n            \"\"\"Return the number of handles opened by this process\n            (Windows only).\n            \"\"\"\n            return self._proc.num_handles()\n\n    def num_ctx_switches(self):\n        \"\"\"Return the number of voluntary and involuntary context\n        switches performed by this process.\n        \"\"\"\n        return self._proc.num_ctx_switches()\n\n    def num_threads(self):\n        \"\"\"Return the number of threads used by this process.\"\"\"\n        return self._proc.num_threads()\n\n    if hasattr(_psplatform.Process, \"threads\"):\n\n        def threads(self):\n            \"\"\"Return threads opened by process as a list of\n            (id, user_time, system_time) namedtuples representing\n            thread id and thread CPU times (user/system).\n            On OpenBSD this method requires root access.\n            \"\"\"\n            return self._proc.threads()\n\n    def children(self, recursive=False):\n        \"\"\"Return the children of this process as a list of Process\n        instances, pre-emptively checking whether PID has been reused.\n        If *recursive* is True return all the parent descendants.\n\n        Example (A == this process):\n\n         A \u2500\u2510\n            \u2502\n            \u251c\u2500 B (child) \u2500\u2510\n            \u2502             \u2514\u2500 X (grandchild) \u2500\u2510\n            \u2502                                \u2514\u2500 Y (great grandchild)\n            \u251c\u2500 C (child)\n            \u2514\u2500 D (child)\n\n        >>> import psutil\n        >>> p = psutil.Process()\n        >>> p.children()\n        B, C, D\n        >>> p.children(recursive=True)\n        B, X, Y, C, D\n\n        Note that in the example above if process X disappears\n        process Y won't be listed as the reference to process A\n        is lost.\n        \"\"\"\n        self._raise_if_pid_reused()\n        ppid_map = _ppid_map()\n        ret = []\n        if not recursive:\n            for pid, ppid in ppid_map.items():\n                if ppid == self.pid:\n                    try:\n                        child = Process(pid)\n                        # if child happens to be older than its parent\n                        # (self) it means child's PID has been reused\n                        if self.create_time() <= child.create_time():\n                            ret.append(child)\n                    except (NoSuchProcess, ZombieProcess):\n                        pass\n        else:\n            # Construct a {pid: [child pids]} dict\n            reverse_ppid_map = collections.defaultdict(list)\n            for pid, ppid in ppid_map.items():\n                reverse_ppid_map[ppid].append(pid)\n            # Recursively traverse that dict, starting from self.pid,\n            # such that we only call Process() on actual children\n            seen = set()\n            stack = [self.pid]\n            while stack:\n                pid = stack.pop()\n                if pid in seen:\n                    # Since pids can be reused while the ppid_map is\n                    # constructed, there may be rare instances where\n                    # there's a cycle in the recorded process \"tree\".\n                    continue\n                seen.add(pid)\n                for child_pid in reverse_ppid_map[pid]:\n                    try:\n                        child = Process(child_pid)\n                        # if child happens to be older than its parent\n                        # (self) it means child's PID has been reused\n                        intime = self.create_time() <= child.create_time()\n                        if intime:\n                            ret.append(child)\n                            stack.append(child_pid)\n                    except (NoSuchProcess, ZombieProcess):\n                        pass\n        return ret\n\n    def cpu_percent(self, interval=None):\n        \"\"\"Return a float representing the current process CPU\n        utilization as a percentage.\n\n        When *interval* is 0.0 or None (default) compares process times\n        to system CPU times elapsed since last call, returning\n        immediately (non-blocking). That means that the first time\n        this is called it will return a meaningful 0.0 value.\n\n        When *interval* is > 0.0 compares process times to system CPU\n        times elapsed before and after the interval (blocking).\n\n        In this case is recommended for accuracy that this function\n        be called with at least 0.1 seconds between calls.\n\n        A value > 100.0 can be returned in case of processes running\n        multiple threads on different CPU cores.\n\n        The returned value is explicitly NOT split evenly between\n        all available logical CPUs. This means that a busy loop process\n        running on a system with 2 logical CPUs will be reported as\n        having 100% CPU utilization instead of 50%.\n\n        Examples:\n\n          >>> import psutil\n          >>> p = psutil.Process(os.getpid())\n          >>> # blocking\n          >>> p.cpu_percent(interval=1)\n          2.0\n          >>> # non-blocking (percentage since last call)\n          >>> p.cpu_percent(interval=None)\n          2.9\n          >>>\n        \"\"\"\n        blocking = interval is not None and interval > 0.0\n        if interval is not None and interval < 0:\n            msg = \"interval is not positive (got %r)\" % interval\n            raise ValueError(msg)\n        num_cpus = cpu_count() or 1\n\n        def timer():\n            return _timer() * num_cpus\n\n        if blocking:\n            st1 = timer()\n            pt1 = self._proc.cpu_times()\n            time.sleep(interval)\n            st2 = timer()\n            pt2 = self._proc.cpu_times()\n        else:\n            st1 = self._last_sys_cpu_times\n            pt1 = self._last_proc_cpu_times\n            st2 = timer()\n            pt2 = self._proc.cpu_times()\n            if st1 is None or pt1 is None:\n                self._last_sys_cpu_times = st2\n                self._last_proc_cpu_times = pt2\n                return 0.0\n\n        delta_proc = (pt2.user - pt1.user) + (pt2.system - pt1.system)\n        delta_time = st2 - st1\n        # reset values for next call in case of interval == None\n        self._last_sys_cpu_times = st2\n        self._last_proc_cpu_times = pt2\n\n        try:\n            # This is the utilization split evenly between all CPUs.\n            # E.g. a busy loop process on a 2-CPU-cores system at this\n            # point is reported as 50% instead of 100%.\n            overall_cpus_percent = (delta_proc / delta_time) * 100\n        except ZeroDivisionError:\n            # interval was too low\n            return 0.0\n        else:\n            # Note 1:\n            # in order to emulate \"top\" we multiply the value for the num\n            # of CPU cores. This way the busy process will be reported as\n            # having 100% (or more) usage.\n            #\n            # Note 2:\n            # taskmgr.exe on Windows differs in that it will show 50%\n            # instead.\n            #\n            # Note 3:\n            # a percentage > 100 is legitimate as it can result from a\n            # process with multiple threads running on different CPU\n            # cores (top does the same), see:\n            # http://stackoverflow.com/questions/1032357\n            # https://github.com/giampaolo/psutil/issues/474\n            single_cpu_percent = overall_cpus_percent * num_cpus\n            return round(single_cpu_percent, 1)\n\n    @memoize_when_activated\n    def cpu_times(self):\n        \"\"\"Return a (user, system, children_user, children_system)\n        namedtuple representing the accumulated process time, in\n        seconds.\n        This is similar to os.times() but per-process.\n        On macOS and Windows children_user and children_system are\n        always set to 0.\n        \"\"\"\n        return self._proc.cpu_times()\n\n    @memoize_when_activated\n    def memory_info(self):\n        \"\"\"Return a namedtuple with variable fields depending on the\n        platform, representing memory information about the process.\n\n        The \"portable\" fields available on all platforms are `rss` and `vms`.\n\n        All numbers are expressed in bytes.\n        \"\"\"\n        return self._proc.memory_info()\n\n    @_common.deprecated_method(replacement=\"memory_info\")\n    def memory_info_ex(self):\n        return self.memory_info()\n\n    def memory_full_info(self):\n        \"\"\"This method returns the same information as memory_info(),\n        plus, on some platform (Linux, macOS, Windows), also provides\n        additional metrics (USS, PSS and swap).\n        The additional metrics provide a better representation of actual\n        process memory usage.\n\n        Namely USS is the memory which is unique to a process and which\n        would be freed if the process was terminated right now.\n\n        It does so by passing through the whole process address.\n        As such it usually requires higher user privileges than\n        memory_info() and is considerably slower.\n        \"\"\"\n        return self._proc.memory_full_info()\n\n    def memory_percent(self, memtype=\"rss\"):\n        \"\"\"Compare process memory to total physical system memory and\n        calculate process memory utilization as a percentage.\n        *memtype* argument is a string that dictates what type of\n        process memory you want to compare against (defaults to \"rss\").\n        The list of available strings can be obtained like this:\n\n        >>> psutil.Process().memory_info()._fields\n        ('rss', 'vms', 'shared', 'text', 'lib', 'data', 'dirty', 'uss', 'pss')\n        \"\"\"\n        valid_types = list(_psplatform.pfullmem._fields)\n        if memtype not in valid_types:\n            msg = \"invalid memtype %r; valid types are %r\" % (\n                memtype,\n                tuple(valid_types),\n            )\n            raise ValueError(msg)\n        fun = (\n            self.memory_info\n            if memtype in _psplatform.pmem._fields\n            else self.memory_full_info\n        )\n        metrics = fun()\n        value = getattr(metrics, memtype)\n\n        # use cached value if available\n        total_phymem = _TOTAL_PHYMEM or virtual_memory().total\n        if not total_phymem > 0:\n            # we should never get here\n            msg = (\n                \"can't calculate process memory percent because total physical\"\n                \" system memory is not positive (%r)\" % (total_phymem)\n            )\n            raise ValueError(msg)\n        return (value / float(total_phymem)) * 100\n\n    if hasattr(_psplatform.Process, \"memory_maps\"):\n\n        def memory_maps(self, grouped=True):\n            \"\"\"Return process' mapped memory regions as a list of namedtuples\n            whose fields are variable depending on the platform.\n\n            If *grouped* is True the mapped regions with the same 'path'\n            are grouped together and the different memory fields are summed.\n\n            If *grouped* is False every mapped region is shown as a single\n            entity and the namedtuple will also include the mapped region's\n            address space ('addr') and permission set ('perms').\n            \"\"\"\n            it = self._proc.memory_maps()\n            if grouped:\n                d = {}\n                for tupl in it:\n                    path = tupl[2]\n                    nums = tupl[3:]\n                    try:\n                        d[path] = map(lambda x, y: x + y, d[path], nums)\n                    except KeyError:\n                        d[path] = nums\n                nt = _psplatform.pmmap_grouped\n                return [nt(path, *d[path]) for path in d]  # NOQA\n            else:\n                nt = _psplatform.pmmap_ext\n                return [nt(*x) for x in it]\n\n    def open_files(self):\n        \"\"\"Return files opened by process as a list of\n        (path, fd) namedtuples including the absolute file name\n        and file descriptor number.\n        \"\"\"\n        return self._proc.open_files()\n\n    def net_connections(self, kind='inet'):\n        \"\"\"Return socket connections opened by process as a list of\n        (fd, family, type, laddr, raddr, status) namedtuples.\n        The *kind* parameter filters for connections that match the\n        following criteria:\n\n        +------------+----------------------------------------------------+\n        | Kind Value | Connections using                                  |\n        +------------+----------------------------------------------------+\n        | inet       | IPv4 and IPv6                                      |\n        | inet4      | IPv4                                               |\n        | inet6      | IPv6                                               |\n        | tcp        | TCP                                                |\n        | tcp4       | TCP over IPv4                                      |\n        | tcp6       | TCP over IPv6                                      |\n        | udp        | UDP                                                |\n        | udp4       | UDP over IPv4                                      |\n        | udp6       | UDP over IPv6                                      |\n        | unix       | UNIX socket (both UDP and TCP protocols)           |\n        | all        | the sum of all the possible families and protocols |\n        +------------+----------------------------------------------------+\n        \"\"\"\n        return self._proc.net_connections(kind)\n\n    @_common.deprecated_method(replacement=\"net_connections\")\n    def connections(self, kind=\"inet\"):\n        return self.net_connections(kind=kind)\n\n    # --- signals\n\n    if POSIX:\n\n        def _send_signal(self, sig):\n            assert not self.pid < 0, self.pid\n            self._raise_if_pid_reused()\n            if self.pid == 0:\n                # see \"man 2 kill\"\n                msg = (\n                    \"preventing sending signal to process with PID 0 as it \"\n                    \"would affect every process in the process group of the \"\n                    \"calling process (os.getpid()) instead of PID 0\"\n                )\n                raise ValueError(msg)\n            try:\n                os.kill(self.pid, sig)\n            except ProcessLookupError:\n                if OPENBSD and pid_exists(self.pid):\n                    # We do this because os.kill() lies in case of\n                    # zombie processes.\n                    raise ZombieProcess(self.pid, self._name, self._ppid)\n                else:\n                    self._gone = True\n                    raise NoSuchProcess(self.pid, self._name)\n            except PermissionError:\n                raise AccessDenied(self.pid, self._name)\n\n    def send_signal(self, sig):\n        \"\"\"Send a signal *sig* to process pre-emptively checking\n        whether PID has been reused (see signal module constants) .\n        On Windows only SIGTERM is valid and is treated as an alias\n        for kill().\n        \"\"\"\n        if POSIX:\n            self._send_signal(sig)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            if sig != signal.SIGTERM and not self.is_running():\n                msg = \"process no longer exists\"\n                raise NoSuchProcess(self.pid, self._name, msg=msg)\n            self._proc.send_signal(sig)\n\n    def suspend(self):\n        \"\"\"Suspend process execution with SIGSTOP pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect of suspending all process threads.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGSTOP)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.suspend()\n\n    def resume(self):\n        \"\"\"Resume process execution with SIGCONT pre-emptively checking\n        whether PID has been reused.\n        On Windows this has the effect of resuming all process threads.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGCONT)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.resume()\n\n    def terminate(self):\n        \"\"\"Terminate the process with SIGTERM pre-emptively checking\n        whether PID has been reused.\n        On Windows this is an alias for kill().\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGTERM)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.kill()\n\n    def kill(self):\n        \"\"\"Kill the current process with SIGKILL pre-emptively checking\n        whether PID has been reused.\n        \"\"\"\n        if POSIX:\n            self._send_signal(signal.SIGKILL)\n        else:  # pragma: no cover\n            self._raise_if_pid_reused()\n            self._proc.kill()\n\n    def wait(self, timeout=None):\n        \"\"\"Wait for process to terminate and, if process is a children\n        of os.getpid(), also return its exit code, else None.\n        On Windows there's no such limitation (exit code is always\n        returned).\n\n        If the process is already terminated immediately return None\n        instead of raising NoSuchProcess.\n\n        If *timeout* (in seconds) is specified and process is still\n        alive raise TimeoutExpired.\n\n        To wait for multiple Process(es) use psutil.wait_procs().\n        \"\"\"\n        if timeout is not None and not timeout >= 0:\n            msg = \"timeout must be a positive integer\"\n            raise ValueError(msg)\n        if self._exitcode is not _SENTINEL:\n            return self._exitcode\n        self._exitcode = self._proc.wait(timeout)\n        return self._exitcode\n\n\n# The valid attr names which can be processed by Process.as_dict().\n# fmt: off\n_as_dict_attrnames = set(\n    [x for x in dir(Process) if not x.startswith('_') and x not in\n     {'send_signal', 'suspend', 'resume', 'terminate', 'kill', 'wait',\n      'is_running', 'as_dict', 'parent', 'parents', 'children', 'rlimit',\n      'memory_info_ex', 'connections', 'oneshot'}])\n# fmt: on\n\n\n# =====================================================================\n# --- Popen class\n# =====================================================================\n\n\nclass Popen(Process):\n    \"\"\"Same as subprocess.Popen, but in addition it provides all\n    psutil.Process methods in a single class.\n    For the following methods which are common to both classes, psutil\n    implementation takes precedence:\n\n    * send_signal()\n    * terminate()\n    * kill()\n\n    This is done in order to avoid killing another process in case its\n    PID has been reused, fixing BPO-6973.\n\n      >>> import psutil\n      >>> from subprocess import PIPE\n      >>> p = psutil.Popen([\"python\", \"-c\", \"print 'hi'\"], stdout=PIPE)\n      >>> p.name()\n      'python'\n      >>> p.uids()\n      user(real=1000, effective=1000, saved=1000)\n      >>> p.username()\n      'giampaolo'\n      >>> p.communicate()\n      ('hi', None)\n      >>> p.terminate()\n      >>> p.wait(timeout=2)\n      0\n      >>>\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        # Explicitly avoid to raise NoSuchProcess in case the process\n        # spawned by subprocess.Popen terminates too quickly, see:\n        # https://github.com/giampaolo/psutil/issues/193\n        self.__subproc = subprocess.Popen(*args, **kwargs)\n        self._init(self.__subproc.pid, _ignore_nsp=True)\n\n    def __dir__(self):\n        return sorted(set(dir(Popen) + dir(subprocess.Popen)))\n\n    def __enter__(self):\n        if hasattr(self.__subproc, '__enter__'):\n            self.__subproc.__enter__()\n        return self\n\n    def __exit__(self, *args, **kwargs):\n        if hasattr(self.__subproc, '__exit__'):\n            return self.__subproc.__exit__(*args, **kwargs)\n        else:\n            if self.stdout:\n                self.stdout.close()\n            if self.stderr:\n                self.stderr.close()\n            try:\n                # Flushing a BufferedWriter may raise an error.\n                if self.stdin:\n                    self.stdin.close()\n            finally:\n                # Wait for the process to terminate, to avoid zombies.\n                self.wait()\n\n    def __getattribute__(self, name):\n        try:\n            return object.__getattribute__(self, name)\n        except AttributeError:\n            try:\n                return object.__getattribute__(self.__subproc, name)\n            except AttributeError:\n                msg = \"%s instance has no attribute '%s'\" % (\n                    self.__class__.__name__,\n                    name,\n                )\n                raise AttributeError(msg)\n\n    def wait(self, timeout=None):\n        if self.__subproc.returncode is not None:\n            return self.__subproc.returncode\n        ret = super(Popen, self).wait(timeout)  # noqa\n        self.__subproc.returncode = ret\n        return ret\n\n\n# =====================================================================\n# --- system processes related functions\n# =====================================================================\n\n\ndef pids():\n    \"\"\"Return a list of current running PIDs.\"\"\"\n    global _LOWEST_PID\n    ret = sorted(_psplatform.pids())\n    _LOWEST_PID = ret[0]\n    return ret\n\n\ndef pid_exists(pid):\n    \"\"\"Return True if given PID exists in the current process list.\n    This is faster than doing \"pid in psutil.pids()\" and\n    should be preferred.\n    \"\"\"\n    if pid < 0:\n        return False\n    elif pid == 0 and POSIX:\n        # On POSIX we use os.kill() to determine PID existence.\n        # According to \"man 2 kill\" PID 0 has a special meaning\n        # though: it refers to <<every process in the process\n        # group of the calling process>> and that is not we want\n        # to do here.\n        return pid in pids()\n    else:\n        return _psplatform.pid_exists(pid)\n\n\n_pmap = {}\n_pids_reused = set()\n\n\ndef process_iter(attrs=None, ad_value=None):\n    \"\"\"Return a generator yielding a Process instance for all\n    running processes.\n\n    Every new Process instance is only created once and then cached\n    into an internal table which is updated every time this is used.\n    Cache can optionally be cleared via `process_iter.clear_cache()`.\n\n    The sorting order in which processes are yielded is based on\n    their PIDs.\n\n    *attrs* and *ad_value* have the same meaning as in\n    Process.as_dict(). If *attrs* is specified as_dict() is called\n    and the resulting dict is stored as a 'info' attribute attached\n    to returned Process instance.\n    If *attrs* is an empty list it will retrieve all process info\n    (slow).\n    \"\"\"\n    global _pmap\n\n    def add(pid):\n        proc = Process(pid)\n        pmap[proc.pid] = proc\n        return proc\n\n    def remove(pid):\n        pmap.pop(pid, None)\n\n    pmap = _pmap.copy()\n    a = set(pids())\n    b = set(pmap.keys())\n    new_pids = a - b\n    gone_pids = b - a\n    for pid in gone_pids:\n        remove(pid)\n    while _pids_reused:\n        pid = _pids_reused.pop()\n        debug(\"refreshing Process instance for reused PID %s\" % pid)\n        remove(pid)\n    try:\n        ls = sorted(list(pmap.items()) + list(dict.fromkeys(new_pids).items()))\n        for pid, proc in ls:\n            try:\n                if proc is None:  # new process\n                    proc = add(pid)\n                if attrs is not None:\n                    proc.info = proc.as_dict(attrs=attrs, ad_value=ad_value)\n                yield proc\n            except NoSuchProcess:\n                remove(pid)\n    finally:\n        _pmap = pmap\n\n\nprocess_iter.cache_clear = lambda: _pmap.clear()  # noqa\nprocess_iter.cache_clear.__doc__ = \"Clear process_iter() internal cache.\"\n\n\ndef wait_procs(procs, timeout=None, callback=None):\n    \"\"\"Convenience function which waits for a list of processes to\n    terminate.\n\n    Return a (gone, alive) tuple indicating which processes\n    are gone and which ones are still alive.\n\n    The gone ones will have a new *returncode* attribute indicating\n    process exit status (may be None).\n\n    *callback* is a function which gets called every time a process\n    terminates (a Process instance is passed as callback argument).\n\n    Function will return as soon as all processes terminate or when\n    *timeout* occurs.\n    Differently from Process.wait() it will not raise TimeoutExpired if\n    *timeout* occurs.\n\n    Typical use case is:\n\n     - send SIGTERM to a list of processes\n     - give them some time to terminate\n     - send SIGKILL to those ones which are still alive\n\n    Example:\n\n    >>> def on_terminate(proc):\n    ...     print(\"process {} terminated\".format(proc))\n    ...\n    >>> for p in procs:\n    ...    p.terminate()\n    ...\n    >>> gone, alive = wait_procs(procs, timeout=3, callback=on_terminate)\n    >>> for p in alive:\n    ...     p.kill()\n    \"\"\"\n\n    def check_gone(proc, timeout):\n        try:\n            returncode = proc.wait(timeout=timeout)\n        except TimeoutExpired:\n            pass\n        except _SubprocessTimeoutExpired:\n            pass\n        else:\n            if returncode is not None or not proc.is_running():\n                # Set new Process instance attribute.\n                proc.returncode = returncode\n                gone.add(proc)\n                if callback is not None:\n                    callback(proc)\n\n    if timeout is not None and not timeout >= 0:\n        msg = \"timeout must be a positive integer, got %s\" % timeout\n        raise ValueError(msg)\n    gone = set()\n    alive = set(procs)\n    if callback is not None and not callable(callback):\n        msg = \"callback %r is not a callable\" % callback\n        raise TypeError(msg)\n    if timeout is not None:\n        deadline = _timer() + timeout\n\n    while alive:\n        if timeout is not None and timeout <= 0:\n            break\n        for proc in alive:\n            # Make sure that every complete iteration (all processes)\n            # will last max 1 sec.\n            # We do this because we don't want to wait too long on a\n            # single process: in case it terminates too late other\n            # processes may disappear in the meantime and their PID\n            # reused.\n            max_timeout = 1.0 / len(alive)\n            if timeout is not None:\n                timeout = min((deadline - _timer()), max_timeout)\n                if timeout <= 0:\n                    break\n                check_gone(proc, timeout)\n            else:\n                check_gone(proc, max_timeout)\n        alive = alive - gone  # noqa PLR6104\n\n    if alive:\n        # Last attempt over processes survived so far.\n        # timeout == 0 won't make this function wait any further.\n        for proc in alive:\n            check_gone(proc, 0)\n        alive = alive - gone  # noqa: PLR6104\n\n    return (list(gone), list(alive))\n\n\n# =====================================================================\n# --- CPU related functions\n# =====================================================================\n\n\ndef cpu_count(logical=True):\n    \"\"\"Return the number of logical CPUs in the system (same as\n    os.cpu_count() in Python 3.4).\n\n    If *logical* is False return the number of physical cores only\n    (e.g. hyper thread CPUs are excluded).\n\n    Return None if undetermined.\n\n    The return value is cached after first call.\n    If desired cache can be cleared like this:\n\n    >>> psutil.cpu_count.cache_clear()\n    \"\"\"\n    if logical:\n        ret = _psplatform.cpu_count_logical()\n    else:\n        ret = _psplatform.cpu_count_cores()\n    if ret is not None and ret < 1:\n        ret = None\n    return ret\n\n\ndef cpu_times(percpu=False):\n    \"\"\"Return system-wide CPU times as a namedtuple.\n    Every CPU time represents the seconds the CPU has spent in the\n    given mode. The namedtuple's fields availability varies depending on the\n    platform:\n\n     - user\n     - system\n     - idle\n     - nice (UNIX)\n     - iowait (Linux)\n     - irq (Linux, FreeBSD)\n     - softirq (Linux)\n     - steal (Linux >= 2.6.11)\n     - guest (Linux >= 2.6.24)\n     - guest_nice (Linux >= 3.2.0)\n\n    When *percpu* is True return a list of namedtuples for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n    \"\"\"\n    if not percpu:\n        return _psplatform.cpu_times()\n    else:\n        return _psplatform.per_cpu_times()\n\n\ntry:\n    _last_cpu_times = {threading.current_thread().ident: cpu_times()}\nexcept Exception:  # noqa: BLE001\n    # Don't want to crash at import time.\n    _last_cpu_times = {}\n\ntry:\n    _last_per_cpu_times = {\n        threading.current_thread().ident: cpu_times(percpu=True)\n    }\nexcept Exception:  # noqa: BLE001\n    # Don't want to crash at import time.\n    _last_per_cpu_times = {}\n\n\ndef _cpu_tot_time(times):\n    \"\"\"Given a cpu_time() ntuple calculates the total CPU time\n    (including idle time).\n    \"\"\"\n    tot = sum(times)\n    if LINUX:\n        # On Linux guest times are already accounted in \"user\" or\n        # \"nice\" times, so we subtract them from total.\n        # Htop does the same. References:\n        # https://github.com/giampaolo/psutil/pull/940\n        # http://unix.stackexchange.com/questions/178045\n        # https://github.com/torvalds/linux/blob/\n        #     447976ef4fd09b1be88b316d1a81553f1aa7cd07/kernel/sched/\n        #     cputime.c#L158\n        tot -= getattr(times, \"guest\", 0)  # Linux 2.6.24+\n        tot -= getattr(times, \"guest_nice\", 0)  # Linux 3.2.0+\n    return tot\n\n\ndef _cpu_busy_time(times):\n    \"\"\"Given a cpu_time() ntuple calculates the busy CPU time.\n    We do so by subtracting all idle CPU times.\n    \"\"\"\n    busy = _cpu_tot_time(times)\n    busy -= times.idle\n    # Linux: \"iowait\" is time during which the CPU does not do anything\n    # (waits for IO to complete). On Linux IO wait is *not* accounted\n    # in \"idle\" time so we subtract it. Htop does the same.\n    # References:\n    # https://github.com/torvalds/linux/blob/\n    #     447976ef4fd09b1be88b316d1a81553f1aa7cd07/kernel/sched/cputime.c#L244\n    busy -= getattr(times, \"iowait\", 0)\n    return busy\n\n\ndef _cpu_times_deltas(t1, t2):\n    assert t1._fields == t2._fields, (t1, t2)\n    field_deltas = []\n    for field in _psplatform.scputimes._fields:\n        field_delta = getattr(t2, field) - getattr(t1, field)\n        # CPU times are always supposed to increase over time\n        # or at least remain the same and that's because time\n        # cannot go backwards.\n        # Surprisingly sometimes this might not be the case (at\n        # least on Windows and Linux), see:\n        # https://github.com/giampaolo/psutil/issues/392\n        # https://github.com/giampaolo/psutil/issues/645\n        # https://github.com/giampaolo/psutil/issues/1210\n        # Trim negative deltas to zero to ignore decreasing fields.\n        # top does the same. Reference:\n        # https://gitlab.com/procps-ng/procps/blob/v3.3.12/top/top.c#L5063\n        field_delta = max(0, field_delta)\n        field_deltas.append(field_delta)\n    return _psplatform.scputimes(*field_deltas)\n\n\ndef cpu_percent(interval=None, percpu=False):\n    \"\"\"Return a float representing the current system-wide CPU\n    utilization as a percentage.\n\n    When *interval* is > 0.0 compares system CPU times elapsed before\n    and after the interval (blocking).\n\n    When *interval* is 0.0 or None compares system CPU times elapsed\n    since last call or module import, returning immediately (non\n    blocking). That means the first time this is called it will\n    return a meaningless 0.0 value which you should ignore.\n    In this case is recommended for accuracy that this function be\n    called with at least 0.1 seconds between calls.\n\n    When *percpu* is True returns a list of floats representing the\n    utilization as a percentage for each CPU.\n    First element of the list refers to first CPU, second element\n    to second CPU and so on.\n    The order of the list is consistent across calls.\n\n    Examples:\n\n      >>> # blocking, system-wide\n      >>> psutil.cpu_percent(interval=1)\n      2.0\n      >>>\n      >>> # blocking, per-cpu\n      >>> psutil.cpu_percent(interval=1, percpu=True)\n      [2.0, 1.0]\n      >>>\n      >>> # non-blocking (percentage since last call)\n      >>> psutil.cpu_percent(interval=None)\n      2.9\n      >>>\n    \"\"\"\n    tid = threading.current_thread().ident\n    blocking = interval is not None and interval > 0.0\n    if interval is not None and interval < 0:\n        msg = \"interval is not positive (got %r)\" % interval\n        raise ValueError(msg)\n\n    def calculate(t1, t2):\n        times_delta = _cpu_times_deltas(t1, t2)\n        all_delta = _cpu_tot_time(times_delta)\n        busy_delta = _cpu_busy_time(times_delta)\n\n        try:\n            busy_perc = (busy_delta / all_delta) * 100\n        except ZeroDivisionError:\n            return 0.0\n        else:\n            return round(busy_perc, 1)\n\n    # system-wide usage\n    if not percpu:\n        if blocking:\n            t1 = cpu_times()\n            time.sleep(interval)\n        else:\n            t1 = _last_cpu_times.get(tid) or cpu_times()\n        _last_cpu_times[tid] = cpu_times()\n        return calculate(t1, _last_cpu_times[tid])\n    # per-cpu usage\n    else:\n        ret = []\n        if blocking:\n            tot1 = cpu_times(percpu=True)\n            time.sleep(interval)\n        else:\n            tot1 = _last_per_cpu_times.get(tid) or cpu_times(percpu=True)\n        _last_per_cpu_times[tid] = cpu_times(percpu=True)\n        for t1, t2 in zip(tot1, _last_per_cpu_times[tid]):\n            ret.append(calculate(t1, t2))\n        return ret\n\n\n# Use a separate dict for cpu_times_percent(), so it's independent from\n# cpu_percent() and they can both be used within the same program.\n_last_cpu_times_2 = _last_cpu_times.copy()\n_last_per_cpu_times_2 = _last_per_cpu_times.copy()\n\n\ndef cpu_times_percent(interval=None, percpu=False):\n    \"\"\"Same as cpu_percent() but provides utilization percentages\n    for each specific CPU time as is returned by cpu_times().\n    For instance, on Linux we'll get:\n\n      >>> cpu_times_percent()\n      cpupercent(user=4.8, nice=0.0, system=4.8, idle=90.5, iowait=0.0,\n                 irq=0.0, softirq=0.0, steal=0.0, guest=0.0, guest_nice=0.0)\n      >>>\n\n    *interval* and *percpu* arguments have the same meaning as in\n    cpu_percent().\n    \"\"\"\n    tid = threading.current_thread().ident\n    blocking = interval is not None and interval > 0.0\n    if interval is not None and interval < 0:\n        msg = \"interval is not positive (got %r)\" % interval\n        raise ValueError(msg)\n\n    def calculate(t1, t2):\n        nums = []\n        times_delta = _cpu_times_deltas(t1, t2)\n        all_delta = _cpu_tot_time(times_delta)\n        # \"scale\" is the value to multiply each delta with to get percentages.\n        # We use \"max\" to avoid division by zero (if all_delta is 0, then all\n        # fields are 0 so percentages will be 0 too. all_delta cannot be a\n        # fraction because cpu times are integers)\n        scale = 100.0 / max(1, all_delta)\n        for field_delta in times_delta:\n            field_perc = field_delta * scale\n            field_perc = round(field_perc, 1)\n            # make sure we don't return negative values or values over 100%\n            field_perc = min(max(0.0, field_perc), 100.0)\n            nums.append(field_perc)\n        return _psplatform.scputimes(*nums)\n\n    # system-wide usage\n    if not percpu:\n        if blocking:\n            t1 = cpu_times()\n            time.sleep(interval)\n        else:\n            t1 = _last_cpu_times_2.get(tid) or cpu_times()\n        _last_cpu_times_2[tid] = cpu_times()\n        return calculate(t1, _last_cpu_times_2[tid])\n    # per-cpu usage\n    else:\n        ret = []\n        if blocking:\n            tot1 = cpu_times(percpu=True)\n            time.sleep(interval)\n        else:\n            tot1 = _last_per_cpu_times_2.get(tid) or cpu_times(percpu=True)\n        _last_per_cpu_times_2[tid] = cpu_times(percpu=True)\n        for t1, t2 in zip(tot1, _last_per_cpu_times_2[tid]):\n            ret.append(calculate(t1, t2))\n        return ret\n\n\ndef cpu_stats():\n    \"\"\"Return CPU statistics.\"\"\"\n    return _psplatform.cpu_stats()\n\n\nif hasattr(_psplatform, \"cpu_freq\"):\n\n    def cpu_freq(percpu=False):\n        \"\"\"Return CPU frequency as a namedtuple including current,\n        min and max frequency expressed in Mhz.\n\n        If *percpu* is True and the system supports per-cpu frequency\n        retrieval (Linux only) a list of frequencies is returned for\n        each CPU. If not a list with one element is returned.\n        \"\"\"\n        ret = _psplatform.cpu_freq()\n        if percpu:\n            return ret\n        else:\n            num_cpus = float(len(ret))\n            if num_cpus == 0:\n                return None\n            elif num_cpus == 1:\n                return ret[0]\n            else:\n                currs, mins, maxs = 0.0, 0.0, 0.0\n                set_none = False\n                for cpu in ret:\n                    currs += cpu.current\n                    # On Linux if /proc/cpuinfo is used min/max are set\n                    # to None.\n                    if LINUX and cpu.min is None:\n                        set_none = True\n                        continue\n                    mins += cpu.min\n                    maxs += cpu.max\n\n                current = currs / num_cpus\n\n                if set_none:\n                    min_ = max_ = None\n                else:\n                    min_ = mins / num_cpus\n                    max_ = maxs / num_cpus\n\n                return _common.scpufreq(current, min_, max_)\n\n    __all__.append(\"cpu_freq\")\n\n\nif hasattr(os, \"getloadavg\") or hasattr(_psplatform, \"getloadavg\"):\n    # Perform this hasattr check once on import time to either use the\n    # platform based code or proxy straight from the os module.\n    if hasattr(os, \"getloadavg\"):\n        getloadavg = os.getloadavg\n    else:\n        getloadavg = _psplatform.getloadavg\n\n    __all__.append(\"getloadavg\")\n\n\n# =====================================================================\n# --- system memory related functions\n# =====================================================================\n\n\ndef virtual_memory():\n    \"\"\"Return statistics about system memory usage as a namedtuple\n    including the following fields, expressed in bytes:\n\n     - total:\n       total physical memory available.\n\n     - available:\n       the memory that can be given instantly to processes without the\n       system going into swap.\n       This is calculated by summing different memory values depending\n       on the platform and it is supposed to be used to monitor actual\n       memory usage in a cross platform fashion.\n\n     - percent:\n       the percentage usage calculated as (total - available) / total * 100\n\n     - used:\n        memory used, calculated differently depending on the platform and\n        designed for informational purposes only:\n        macOS: active + wired\n        BSD: active + wired + cached\n        Linux: total - free\n\n     - free:\n       memory not being used at all (zeroed) that is readily available;\n       note that this doesn't reflect the actual memory available\n       (use 'available' instead)\n\n    Platform-specific fields:\n\n     - active (UNIX):\n       memory currently in use or very recently used, and so it is in RAM.\n\n     - inactive (UNIX):\n       memory that is marked as not used.\n\n     - buffers (BSD, Linux):\n       cache for things like file system metadata.\n\n     - cached (BSD, macOS):\n       cache for various things.\n\n     - wired (macOS, BSD):\n       memory that is marked to always stay in RAM. It is never moved to disk.\n\n     - shared (BSD):\n       memory that may be simultaneously accessed by multiple processes.\n\n    The sum of 'used' and 'available' does not necessarily equal total.\n    On Windows 'available' and 'free' are the same.\n    \"\"\"\n    global _TOTAL_PHYMEM\n    ret = _psplatform.virtual_memory()\n    # cached for later use in Process.memory_percent()\n    _TOTAL_PHYMEM = ret.total\n    return ret\n\n\ndef swap_memory():\n    \"\"\"Return system swap memory statistics as a namedtuple including\n    the following fields:\n\n     - total:   total swap memory in bytes\n     - used:    used swap memory in bytes\n     - free:    free swap memory in bytes\n     - percent: the percentage usage\n     - sin:     no. of bytes the system has swapped in from disk (cumulative)\n     - sout:    no. of bytes the system has swapped out from disk (cumulative)\n\n    'sin' and 'sout' on Windows are meaningless and always set to 0.\n    \"\"\"\n    return _psplatform.swap_memory()\n\n\n# =====================================================================\n# --- disks/partitions related functions\n# =====================================================================\n\n\ndef disk_usage(path):\n    \"\"\"Return disk usage statistics about the given *path* as a\n    namedtuple including total, used and free space expressed in bytes\n    plus the percentage usage.\n    \"\"\"\n    return _psplatform.disk_usage(path)\n\n\ndef disk_partitions(all=False):\n    \"\"\"Return mounted partitions as a list of\n    (device, mountpoint, fstype, opts) namedtuple.\n    'opts' field is a raw string separated by commas indicating mount\n    options which may vary depending on the platform.\n\n    If *all* parameter is False return physical devices only and ignore\n    all others.\n    \"\"\"\n    return _psplatform.disk_partitions(all)\n\n\ndef disk_io_counters(perdisk=False, nowrap=True):\n    \"\"\"Return system disk I/O statistics as a namedtuple including\n    the following fields:\n\n     - read_count:  number of reads\n     - write_count: number of writes\n     - read_bytes:  number of bytes read\n     - write_bytes: number of bytes written\n     - read_time:   time spent reading from disk (in ms)\n     - write_time:  time spent writing to disk (in ms)\n\n    Platform specific:\n\n     - busy_time: (Linux, FreeBSD) time spent doing actual I/Os (in ms)\n     - read_merged_count (Linux): number of merged reads\n     - write_merged_count (Linux): number of merged writes\n\n    If *perdisk* is True return the same information for every\n    physical disk installed on the system as a dictionary\n    with partition names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add \"old value\" to \"new value\" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    \"disk_io_counters.cache_clear()\" can be used to invalidate the\n    cache.\n\n    On recent Windows versions 'diskperf -y' command may need to be\n    executed first otherwise this function won't find any disk.\n    \"\"\"\n    kwargs = dict(perdisk=perdisk) if LINUX else {}\n    rawdict = _psplatform.disk_io_counters(**kwargs)\n    if not rawdict:\n        return {} if perdisk else None\n    if nowrap:\n        rawdict = _wrap_numbers(rawdict, 'psutil.disk_io_counters')\n    nt = getattr(_psplatform, \"sdiskio\", _common.sdiskio)\n    if perdisk:\n        for disk, fields in rawdict.items():\n            rawdict[disk] = nt(*fields)\n        return rawdict\n    else:\n        return nt(*(sum(x) for x in zip(*rawdict.values())))\n\n\ndisk_io_counters.cache_clear = functools.partial(\n    _wrap_numbers.cache_clear, 'psutil.disk_io_counters'\n)\ndisk_io_counters.cache_clear.__doc__ = \"Clears nowrap argument cache\"\n\n\n# =====================================================================\n# --- network related functions\n# =====================================================================\n\n\ndef net_io_counters(pernic=False, nowrap=True):\n    \"\"\"Return network I/O statistics as a namedtuple including\n    the following fields:\n\n     - bytes_sent:   number of bytes sent\n     - bytes_recv:   number of bytes received\n     - packets_sent: number of packets sent\n     - packets_recv: number of packets received\n     - errin:        total number of errors while receiving\n     - errout:       total number of errors while sending\n     - dropin:       total number of incoming packets which were dropped\n     - dropout:      total number of outgoing packets which were dropped\n                     (always 0 on macOS and BSD)\n\n    If *pernic* is True return the same information for every\n    network interface installed on the system as a dictionary\n    with network interface names as the keys and the namedtuple\n    described above as the values.\n\n    If *nowrap* is True it detects and adjust the numbers which overflow\n    and wrap (restart from 0) and add \"old value\" to \"new value\" so that\n    the returned numbers will always be increasing or remain the same,\n    but never decrease.\n    \"net_io_counters.cache_clear()\" can be used to invalidate the\n    cache.\n    \"\"\"\n    rawdict = _psplatform.net_io_counters()\n    if not rawdict:\n        return {} if pernic else None\n    if nowrap:\n        rawdict = _wrap_numbers(rawdict, 'psutil.net_io_counters')\n    if pernic:\n        for nic, fields in rawdict.items():\n            rawdict[nic] = _common.snetio(*fields)\n        return rawdict\n    else:\n        return _common.snetio(*[sum(x) for x in zip(*rawdict.values())])\n\n\nnet_io_counters.cache_clear = functools.partial(\n    _wrap_numbers.cache_clear, 'psutil.net_io_counters'\n)\nnet_io_counters.cache_clear.__doc__ = \"Clears nowrap argument cache\"\n\n\ndef net_connections(kind='inet'):\n    \"\"\"Return system-wide socket connections as a list of\n    (fd, family, type, laddr, raddr, status, pid) namedtuples.\n    In case of limited privileges 'fd' and 'pid' may be set to -1\n    and None respectively.\n    The *kind* parameter filters for connections that fit the\n    following criteria:\n\n    +------------+----------------------------------------------------+\n    | Kind Value | Connections using                                  |\n    +------------+----------------------------------------------------+\n    | inet       | IPv4 and IPv6                                      |\n    | inet4      | IPv4                                               |\n    | inet6      | IPv6                                               |\n    | tcp        | TCP                                                |\n    | tcp4       | TCP over IPv4                                      |\n    | tcp6       | TCP over IPv6                                      |\n    | udp        | UDP                                                |\n    | udp4       | UDP over IPv4                                      |\n    | udp6       | UDP over IPv6                                      |\n    | unix       | UNIX socket (both UDP and TCP protocols)           |\n    | all        | the sum of all the possible families and protocols |\n    +------------+----------------------------------------------------+\n\n    On macOS this function requires root privileges.\n    \"\"\"\n    return _psplatform.net_connections(kind)\n\n\ndef net_if_addrs():\n    \"\"\"Return the addresses associated to each NIC (network interface\n    card) installed on the system as a dictionary whose keys are the\n    NIC names and value is a list of namedtuples for each address\n    assigned to the NIC. Each namedtuple includes 5 fields:\n\n     - family: can be either socket.AF_INET, socket.AF_INET6 or\n               psutil.AF_LINK, which refers to a MAC address.\n     - address: is the primary address and it is always set.\n     - netmask: and 'broadcast' and 'ptp' may be None.\n     - ptp: stands for \"point to point\" and references the\n            destination address on a point to point interface\n            (typically a VPN).\n     - broadcast: and *ptp* are mutually exclusive.\n\n    Note: you can have more than one address of the same family\n    associated with each interface.\n    \"\"\"\n    has_enums = _PY3\n    if has_enums:\n        import socket\n    rawlist = _psplatform.net_if_addrs()\n    rawlist.sort(key=lambda x: x[1])  # sort by family\n    ret = collections.defaultdict(list)\n    for name, fam, addr, mask, broadcast, ptp in rawlist:\n        if has_enums:\n            try:\n                fam = socket.AddressFamily(fam)\n            except ValueError:\n                if WINDOWS and fam == -1:\n                    fam = _psplatform.AF_LINK\n                elif (\n                    hasattr(_psplatform, \"AF_LINK\")\n                    and fam == _psplatform.AF_LINK\n                ):\n                    # Linux defines AF_LINK as an alias for AF_PACKET.\n                    # We re-set the family here so that repr(family)\n                    # will show AF_LINK rather than AF_PACKET\n                    fam = _psplatform.AF_LINK\n        if fam == _psplatform.AF_LINK:\n            # The underlying C function may return an incomplete MAC\n            # address in which case we fill it with null bytes, see:\n            # https://github.com/giampaolo/psutil/issues/786\n            separator = \":\" if POSIX else \"-\"\n            while addr.count(separator) < 5:\n                addr += \"%s00\" % separator\n        ret[name].append(_common.snicaddr(fam, addr, mask, broadcast, ptp))\n    return dict(ret)\n\n\ndef net_if_stats():\n    \"\"\"Return information about each NIC (network interface card)\n    installed on the system as a dictionary whose keys are the\n    NIC names and value is a namedtuple with the following fields:\n\n     - isup: whether the interface is up (bool)\n     - duplex: can be either NIC_DUPLEX_FULL, NIC_DUPLEX_HALF or\n               NIC_DUPLEX_UNKNOWN\n     - speed: the NIC speed expressed in mega bits (MB); if it can't\n              be determined (e.g. 'localhost') it will be set to 0.\n     - mtu: the maximum transmission unit expressed in bytes.\n    \"\"\"\n    return _psplatform.net_if_stats()\n\n\n# =====================================================================\n# --- sensors\n# =====================================================================\n\n\n# Linux, macOS\nif hasattr(_psplatform, \"sensors_temperatures\"):\n\n    def sensors_temperatures(fahrenheit=False):\n        \"\"\"Return hardware temperatures. Each entry is a namedtuple\n        representing a certain hardware sensor (it may be a CPU, an\n        hard disk or something else, depending on the OS and its\n        configuration).\n        All temperatures are expressed in celsius unless *fahrenheit*\n        is set to True.\n        \"\"\"\n\n        def convert(n):\n            if n is not None:\n                return (float(n) * 9 / 5) + 32 if fahrenheit else n\n\n        ret = collections.defaultdict(list)\n        rawdict = _psplatform.sensors_temperatures()\n\n        for name, values in rawdict.items():\n            while values:\n                label, current, high, critical = values.pop(0)\n                current = convert(current)\n                high = convert(high)\n                critical = convert(critical)\n\n                if high and not critical:\n                    critical = high\n                elif critical and not high:\n                    high = critical\n\n                ret[name].append(\n                    _common.shwtemp(label, current, high, critical)\n                )\n\n        return dict(ret)\n\n    __all__.append(\"sensors_temperatures\")\n\n\n# Linux\nif hasattr(_psplatform, \"sensors_fans\"):\n\n    def sensors_fans():\n        \"\"\"Return fans speed. Each entry is a namedtuple\n        representing a certain hardware sensor.\n        All speed are expressed in RPM (rounds per minute).\n        \"\"\"\n        return _psplatform.sensors_fans()\n\n    __all__.append(\"sensors_fans\")\n\n\n# Linux, Windows, FreeBSD, macOS\nif hasattr(_psplatform, \"sensors_battery\"):\n\n    def sensors_battery():\n        \"\"\"Return battery information. If no battery is installed\n        returns None.\n\n         - percent: battery power left as a percentage.\n         - secsleft: a rough approximation of how many seconds are left\n                     before the battery runs out of power. May be\n                     POWER_TIME_UNLIMITED or POWER_TIME_UNLIMITED.\n         - power_plugged: True if the AC power cable is connected.\n        \"\"\"\n        return _psplatform.sensors_battery()\n\n    __all__.append(\"sensors_battery\")\n\n\n# =====================================================================\n# --- other system related functions\n# =====================================================================\n\n\ndef boot_time():\n    \"\"\"Return the system boot time expressed in seconds since the epoch.\"\"\"\n    # Note: we are not caching this because it is subject to\n    # system clock updates.\n    return _psplatform.boot_time()\n\n\ndef users():\n    \"\"\"Return users currently connected on the system as a list of\n    namedtuples including the following fields.\n\n     - user: the name of the user\n     - terminal: the tty or pseudo-tty associated with the user, if any.\n     - host: the host name associated with the entry, if any.\n     - started: the creation time as a floating point number expressed in\n       seconds since the epoch.\n    \"\"\"\n    return _psplatform.users()\n\n\n# =====================================================================\n# --- Windows services\n# =====================================================================\n\n\nif WINDOWS:\n\n    def win_service_iter():\n        \"\"\"Return a generator yielding a WindowsService instance for all\n        Windows services installed.\n        \"\"\"\n        return _psplatform.win_service_iter()\n\n    def win_service_get(name):\n        \"\"\"Get a Windows service by *name*.\n        Raise NoSuchProcess if no service with such name exists.\n        \"\"\"\n        return _psplatform.win_service_get(name)\n\n\n# =====================================================================\n\n\ndef _set_debug(value):\n    \"\"\"Enable or disable PSUTIL_DEBUG option, which prints debugging\n    messages to stderr.\n    \"\"\"\n    import psutil._common\n\n    psutil._common.PSUTIL_DEBUG = bool(value)\n    _psplatform.cext.set_debug(bool(value))\n\n\ndef test():  # pragma: no cover\n    from ._common import bytes2human\n    from ._compat import get_terminal_size\n\n    today_day = datetime.date.today()\n    # fmt: off\n    templ = \"%-10s %5s %5s %7s %7s %5s %6s %6s %6s  %s\"\n    attrs = ['pid', 'memory_percent', 'name', 'cmdline', 'cpu_times',\n             'create_time', 'memory_info', 'status', 'nice', 'username']\n    print(templ % (\"USER\", \"PID\", \"%MEM\", \"VSZ\", \"RSS\", \"NICE\",  # NOQA\n                   \"STATUS\", \"START\", \"TIME\", \"CMDLINE\"))\n    # fmt: on\n    for p in process_iter(attrs, ad_value=None):\n        if p.info['create_time']:\n            ctime = datetime.datetime.fromtimestamp(p.info['create_time'])\n            if ctime.date() == today_day:\n                ctime = ctime.strftime(\"%H:%M\")\n            else:\n                ctime = ctime.strftime(\"%b%d\")\n        else:\n            ctime = ''\n        if p.info['cpu_times']:\n            cputime = time.strftime(\n                \"%M:%S\", time.localtime(sum(p.info['cpu_times']))\n            )\n        else:\n            cputime = ''\n\n        user = p.info['username'] or ''\n        if not user and POSIX:\n            try:\n                user = p.uids()[0]\n            except Error:\n                pass\n        if user and WINDOWS and '\\\\' in user:\n            user = user.split('\\\\')[1]\n        user = user[:9]\n        vms = (\n            bytes2human(p.info['memory_info'].vms)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        rss = (\n            bytes2human(p.info['memory_info'].rss)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        memp = (\n            round(p.info['memory_percent'], 1)\n            if p.info['memory_percent'] is not None\n            else ''\n        )\n        nice = int(p.info['nice']) if p.info['nice'] else ''\n        if p.info['cmdline']:\n            cmdline = ' '.join(p.info['cmdline'])\n        else:\n            cmdline = p.info['name']\n        status = p.info['status'][:5] if p.info['status'] else ''\n\n        line = templ % (\n            user[:10],\n            p.info['pid'],\n            memp,\n            vms,\n            rss,\n            nice,\n            status,\n            ctime,\n            cputime,\n            cmdline,\n        )\n        print(line[: get_terminal_size()[0]])  # NOQA\n\n\ndel memoize_when_activated, division\nif sys.version_info[0] < 3:\n    del num, x  # noqa\n\nif __name__ == \"__main__\":\n    test()\n", ".github/workflows/issues.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Bot triggered by Github Actions every time a new issue, PR or comment\nis created. Assign labels, provide replies, closes issues, etc. depending\non the situation.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport functools\nimport json\nimport os\nimport re\nfrom pprint import pprint as pp\n\nfrom github import Github\n\n\nROOT_DIR = os.path.realpath(\n    os.path.join(os.path.dirname(__file__), '..', '..')\n)\nSCRIPTS_DIR = os.path.join(ROOT_DIR, 'scripts')\n\n\n# --- constants\n\n# fmt: off\nLABELS_MAP = {\n    # platforms\n    \"linux\": [\n        \"linux\", \"ubuntu\", \"redhat\", \"mint\", \"centos\", \"red hat\", \"archlinux\",\n        \"debian\", \"alpine\", \"gentoo\", \"fedora\", \"slackware\", \"suse\", \"RHEL\",\n        \"opensuse\", \"manylinux\", \"apt \", \"apt-\", \"rpm\", \"yum\", \"kali\",\n        \"/sys/class\", \"/proc/net\", \"/proc/disk\", \"/proc/smaps\",\n        \"/proc/vmstat\",\n    ],\n    \"windows\": [\n        \"windows\", \"win32\", \"WinError\", \"WindowsError\", \"win10\", \"win7\",\n        \"win \", \"mingw\", \"msys\", \"studio\", \"microsoft\", \"make.bat\",\n        \"CloseHandle\", \"GetLastError\", \"NtQuery\", \"DLL\", \"MSVC\", \"TCHAR\",\n        \"WCHAR\", \".bat\", \"OpenProcess\", \"TerminateProcess\", \"appveyor\",\n        \"windows error\", \"NtWow64\", \"NTSTATUS\", \"Visual Studio\",\n    ],\n    \"macos\": [\n        \"macos\", \"mac \", \"osx\", \"os x\", \"mojave\", \"sierra\", \"capitan\",\n        \"yosemite\", \"catalina\", \"mojave\", \"big sur\", \"xcode\", \"darwin\",\n        \"dylib\", \"m1\",\n    ],\n    \"aix\": [\"aix\"],\n    \"cygwin\": [\"cygwin\"],\n    \"freebsd\": [\"freebsd\"],\n    \"netbsd\": [\"netbsd\"],\n    \"openbsd\": [\"openbsd\"],\n    \"sunos\": [\"sunos\", \"solaris\"],\n    \"wsl\": [\"wsl\"],\n    \"unix\": [\n        \"psposix\", \"_psutil_posix\", \"waitpid\", \"statvfs\", \"/dev/tty\",\n        \"/dev/pts\", \"posix\",\n    ],\n    \"pypy\": [\"pypy\"],\n    # types\n    \"enhancement\": [\"enhancement\"],\n    \"memleak\": [\"memory leak\", \"leaks memory\", \"memleak\", \"mem leak\"],\n    \"api\": [\"idea\", \"proposal\", \"api\", \"feature\"],\n    \"performance\": [\"performance\", \"speedup\", \"speed up\", \"slow\", \"fast\"],\n    \"wheels\": [\"wheel\", \"wheels\"],\n    \"scripts\": [\n        \"example script\", \"examples script\", \"example dir\", \"scripts/\",\n    ],\n    # bug\n    \"bug\": [\n        \"fail\", \"can't execute\", \"can't install\", \"cannot execute\",\n        \"cannot install\", \"install error\", \"crash\", \"critical\",\n    ],\n    # doc\n    \"doc\": [\n        \"doc \", \"document \", \"documentation\", \"readthedocs\", \"pythonhosted\",\n        \"HISTORY\", \"README\", \"dev guide\", \"devguide\", \"sphinx\", \"docfix\",\n        \"index.rst\",\n    ],\n    # tests\n    \"tests\": [\n        \" test \", \"tests\", \"travis\", \"coverage\", \"cirrus\", \"appveyor\",\n        \"continuous integration\", \"unittest\", \"pytest\", \"unit test\",\n    ],\n    # critical errors\n    \"priority-high\": [\n        \"WinError\", \"WindowsError\", \"RuntimeError\", \"ZeroDivisionError\",\n        \"SystemError\", \"MemoryError\", \"core dumped\",\n        \"segfault\", \"segmentation fault\",\n    ],\n}\n\nOS_LABELS = [\n    \"linux\", \"windows\", \"macos\", \"freebsd\", \"openbsd\", \"netbsd\", \"openbsd\",\n    \"bsd\", \"sunos\", \"unix\", \"wsl\", \"aix\", \"cygwin\",\n]\n# fmt: on\n\nLABELS_MAP['scripts'].extend(\n    [x for x in os.listdir(SCRIPTS_DIR) if x.endswith('.py')]\n)\n\nILLOGICAL_PAIRS = [\n    ('bug', 'enhancement'),\n    ('doc', 'tests'),\n    ('scripts', 'doc'),\n    ('scripts', 'tests'),\n    ('bsd', 'freebsd'),\n    ('bsd', 'openbsd'),\n    ('bsd', 'netbsd'),\n]\n\n# --- replies\n\nREPLY_MISSING_PYTHON_HEADERS = \"\"\"\\\nIt looks like you're missing `Python.h` headers. This usually means you have \\\nto install them first, then retry psutil installation.\nPlease read \\\n[INSTALL](https://github.com/giampaolo/psutil/blob/master/INSTALL.rst) \\\ninstructions for your platform. \\\nThis is an auto-generated response based on the text you submitted. \\\nIf this was a mistake or you think there's a bug with psutil installation \\\nprocess, please add a comment to reopen this issue.\n\"\"\"\n\n# REPLY_UPDATE_CHANGELOG = \"\"\"\\\n# \"\"\"\n\n\n# --- github API utils\n\n\ndef is_pr(issue):\n    return issue.pull_request is not None\n\n\ndef has_label(issue, label):\n    assigned = [x.name for x in issue.labels]\n    return label in assigned\n\n\ndef has_os_label(issue):\n    labels = set([x.name for x in issue.labels])\n    return any(x in labels for x in OS_LABELS)\n\n\ndef get_repo():\n    repo = os.environ['GITHUB_REPOSITORY']\n    token = os.environ['GITHUB_TOKEN']\n    return Github(token).get_repo(repo)\n\n\n# --- event utils\n\n\n@functools.lru_cache()\ndef _get_event_data():\n    ret = json.load(open(os.environ[\"GITHUB_EVENT_PATH\"]))\n    pp(ret)\n    return ret\n\n\ndef is_event_new_issue():\n    data = _get_event_data()\n    try:\n        return data['action'] == 'opened' and 'issue' in data\n    except KeyError:\n        return False\n\n\ndef is_event_new_pr():\n    data = _get_event_data()\n    try:\n        return data['action'] == 'opened' and 'pull_request' in data\n    except KeyError:\n        return False\n\n\ndef get_issue():\n    data = _get_event_data()\n    try:\n        num = data['issue']['number']\n    except KeyError:\n        num = data['pull_request']['number']\n    return get_repo().get_issue(number=num)\n\n\n# --- actions\n\n\ndef log(msg):\n    if '\\n' in msg or \"\\r\\n\" in msg:\n        print(\">>>\\n%s\\n<<<\" % msg, flush=True)\n    else:\n        print(\">>> %s <<<\" % msg, flush=True)\n\n\ndef add_label(issue, label):\n    def should_add(issue, label):\n        if has_label(issue, label):\n            log(\"already has label %r\" % (label))\n            return False\n\n        for left, right in ILLOGICAL_PAIRS:\n            if label == left and has_label(issue, right):\n                log(\"already has label\" % (label))\n                return False\n\n        return not has_label(issue, label)\n\n    if not should_add(issue, label):\n        log(\"should not add label %r\" % label)\n        return\n\n    log(\"add label %r\" % label)\n    issue.add_to_labels(label)\n\n\ndef _guess_labels_from_text(text):\n    assert isinstance(text, str), text\n    for label, keywords in LABELS_MAP.items():\n        for keyword in keywords:\n            if keyword.lower() in text.lower():\n                yield (label, keyword)\n\n\ndef add_labels_from_text(issue, text):\n    assert isinstance(text, str), text\n    for label, keyword in _guess_labels_from_text(text):\n        add_label(issue, label)\n\n\ndef add_labels_from_new_body(issue, text):\n    assert isinstance(text, str), text\n    log(\"start searching for template lines in new issue/PR body\")\n    # add os label\n    r = re.search(r\"\\* OS:.*?\\n\", text)\n    log(\"search for 'OS: ...' line\")\n    if r:\n        log(\"found\")\n        add_labels_from_text(issue, r.group(0))\n    else:\n        log(\"not found\")\n\n    # add bug/enhancement label\n    log(\"search for 'Bug fix: y/n' line\")\n    r = re.search(r\"\\* Bug fix:.*?\\n\", text)\n    if (\n        is_pr(issue)\n        and r is not None\n        and not has_label(issue, \"bug\")\n        and not has_label(issue, \"enhancement\")\n    ):\n        log(\"found\")\n        s = r.group(0).lower()\n        if 'yes' in s:\n            add_label(issue, 'bug')\n        else:\n            add_label(issue, 'enhancement')\n    else:\n        log(\"not found\")\n\n    # add type labels\n    log(\"search for 'Type: ...' line\")\n    r = re.search(r\"\\* Type:.*?\\n\", text)\n    if r:\n        log(\"found\")\n        s = r.group(0).lower()\n        if 'doc' in s:\n            add_label(issue, 'doc')\n        if 'performance' in s:\n            add_label(issue, 'performance')\n        if 'scripts' in s:\n            add_label(issue, 'scripts')\n        if 'tests' in s:\n            add_label(issue, 'tests')\n        if 'wheels' in s:\n            add_label(issue, 'wheels')\n        if 'new-api' in s:\n            add_label(issue, 'new-api')\n        if 'new-platform' in s:\n            add_label(issue, 'new-platform')\n    else:\n        log(\"not found\")\n\n\n# --- events\n\n\ndef on_new_issue(issue):\n    def has_text(text):\n        return text in issue.title.lower() or (\n            issue.body and text in issue.body.lower()\n        )\n\n    def body_mentions_python_h():\n        if not issue.body:\n            return False\n        body = issue.body.replace(' ', '')\n        return (\n            \"#include<Python.h>\\n^~~~\" in body\n            or \"#include<Python.h>\\r\\n^~~~\" in body\n        )\n\n    log(\"searching for missing Python.h\")\n    if (\n        has_text(\"missing python.h\")\n        or has_text(\"python.h: no such file or directory\")\n        or body_mentions_python_h()\n    ):\n        log(\"found mention of Python.h\")\n        issue.create_comment(REPLY_MISSING_PYTHON_HEADERS)\n        issue.edit(state='closed')\n        return\n\n\ndef on_new_pr(issue):\n    pass\n    # pr = get_repo().get_pull(issue.number)\n    # files = [x.filename for x in list(pr.get_files())]\n    # if \"HISTORY.rst\" not in files:\n    #     issue.create_comment(REPLY_UPDATE_CHANGELOG)\n\n\ndef main():\n    issue = get_issue()\n    stype = \"PR\" if is_pr(issue) else \"issue\"\n    log(\"running issue bot for %s %r\" % (stype, issue))\n\n    if is_event_new_issue():\n        log(\"created new issue %s\" % issue)\n        add_labels_from_text(issue, issue.title)\n        if issue.body:\n            add_labels_from_new_body(issue, issue.body)\n        on_new_issue(issue)\n    elif is_event_new_pr():\n        log(\"created new PR %s\" % issue)\n        add_labels_from_text(issue, issue.title)\n        if issue.body:\n            add_labels_from_new_body(issue, issue.body)\n        on_new_pr(issue)\n    else:\n        log(\"unhandled event\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/nettop.py": "#!/usr/bin/env python3\n#\n# $Id: iotop.py 1160 2011-10-14 18:50:36Z g.rodola@gmail.com $\n#\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Shows real-time network statistics.\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n$ python3 scripts/nettop.py\n-----------------------------------------------------------\ntotal bytes:           sent: 1.49 G       received: 4.82 G\ntotal packets:         sent: 7338724      received: 8082712\n\nwlan0                     TOTAL         PER-SEC\n-----------------------------------------------------------\nbytes-sent               1.29 G        0.00 B/s\nbytes-recv               3.48 G        0.00 B/s\npkts-sent               7221782               0\npkts-recv               6753724               0\n\neth1                      TOTAL         PER-SEC\n-----------------------------------------------------------\nbytes-sent             131.77 M        0.00 B/s\nbytes-recv               1.28 G        0.00 B/s\npkts-sent                     0               0\npkts-recv               1214470               0\n\"\"\"\n\nimport sys\nimport time\n\n\ntry:\n    import curses\nexcept ImportError:\n    sys.exit('platform not supported')\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nlineno = 0\nwin = curses.initscr()\n\n\ndef printl(line, highlight=False):\n    \"\"\"A thin wrapper around curses's addstr().\"\"\"\n    global lineno\n    try:\n        if highlight:\n            line += \" \" * (win.getmaxyx()[1] - len(line))\n            win.addstr(lineno, 0, line, curses.A_REVERSE)\n        else:\n            win.addstr(lineno, 0, line, 0)\n    except curses.error:\n        lineno = 0\n        win.refresh()\n        raise\n    else:\n        lineno += 1\n\n\ndef poll(interval):\n    \"\"\"Retrieve raw stats within an interval window.\"\"\"\n    tot_before = psutil.net_io_counters()\n    pnic_before = psutil.net_io_counters(pernic=True)\n    # sleep some time\n    time.sleep(interval)\n    tot_after = psutil.net_io_counters()\n    pnic_after = psutil.net_io_counters(pernic=True)\n    return (tot_before, tot_after, pnic_before, pnic_after)\n\n\ndef refresh_window(tot_before, tot_after, pnic_before, pnic_after):\n    \"\"\"Print stats on screen.\"\"\"\n    global lineno\n\n    # totals\n    printl(\n        \"total bytes:           sent: %-10s   received: %s\"\n        % (\n            bytes2human(tot_after.bytes_sent),\n            bytes2human(tot_after.bytes_recv),\n        )\n    )\n\n    # per-network interface details: let's sort network interfaces so\n    # that the ones which generated more traffic are shown first\n    printl(\"\")\n    nic_names = list(pnic_after.keys())\n    nic_names.sort(key=lambda x: sum(pnic_after[x]), reverse=True)\n    for name in nic_names:\n        stats_before = pnic_before[name]\n        stats_after = pnic_after[name]\n        templ = \"%-15s %15s %15s\"\n        # fmt: off\n        printl(templ % (name, \"TOTAL\", \"PER-SEC\"), highlight=True)\n        printl(templ % (\n            \"bytes-sent\",\n            bytes2human(stats_after.bytes_sent),\n            bytes2human(\n                stats_after.bytes_sent - stats_before.bytes_sent) + '/s',\n        ))\n        printl(templ % (\n            \"bytes-recv\",\n            bytes2human(stats_after.bytes_recv),\n            bytes2human(\n                stats_after.bytes_recv - stats_before.bytes_recv) + '/s',\n        ))\n        printl(templ % (\n            \"pkts-sent\",\n            stats_after.packets_sent,\n            stats_after.packets_sent - stats_before.packets_sent,\n        ))\n        printl(templ % (\n            \"pkts-recv\",\n            stats_after.packets_recv,\n            stats_after.packets_recv - stats_before.packets_recv,\n        ))\n        printl(\"\")\n        # fmt: on\n    win.refresh()\n    lineno = 0\n\n\ndef setup():\n    curses.start_color()\n    curses.use_default_colors()\n    for i in range(curses.COLORS):\n        curses.init_pair(i + 1, i, -1)\n    curses.endwin()\n    win.nodelay(1)\n\n\ndef tear_down():\n    win.keypad(0)\n    curses.nocbreak()\n    curses.echo()\n    curses.endwin()\n\n\ndef main():\n    setup()\n    try:\n        interval = 0\n        while True:\n            if win.getch() == ord('q'):\n                break\n            args = poll(interval)\n            refresh_window(*args)\n            interval = 0.5\n    except (KeyboardInterrupt, SystemExit):\n        pass\n    finally:\n        tear_down()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/pstree.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Similar to 'ps aux --forest' on Linux, prints the process list\nas a tree structure.\n\n$ python3 scripts/pstree.py\n0 ?\n|- 1 init\n| |- 289 cgmanager\n| |- 616 upstart-socket-bridge\n| |- 628 rpcbind\n| |- 892 upstart-file-bridge\n| |- 907 dbus-daemon\n| |- 978 avahi-daemon\n| | `_ 979 avahi-daemon\n| |- 987 NetworkManager\n| | |- 2242 dnsmasq\n| | `_ 10699 dhclient\n| |- 993 polkitd\n| |- 1061 getty\n| |- 1066 su\n| | `_ 1190 salt-minion...\n...\n\"\"\"\n\nfrom __future__ import print_function\n\nimport collections\nimport sys\n\nimport psutil\n\n\ndef print_tree(parent, tree, indent=''):\n    try:\n        name = psutil.Process(parent).name()\n    except psutil.Error:\n        name = \"?\"\n    print(parent, name)\n    if parent not in tree:\n        return\n    children = tree[parent][:-1]\n    for child in children:\n        sys.stdout.write(indent + \"|- \")\n        print_tree(child, tree, indent + \"| \")\n    child = tree[parent][-1]\n    sys.stdout.write(indent + \"`_ \")\n    print_tree(child, tree, indent + \"  \")\n\n\ndef main():\n    # construct a dict where 'values' are all the processes\n    # having 'key' as their parent\n    tree = collections.defaultdict(list)\n    for p in psutil.process_iter():\n        try:\n            tree[p.ppid()].append(p.pid)\n        except (psutil.NoSuchProcess, psutil.ZombieProcess):\n            pass\n    # on systems supporting PID 0, PID 0's parent is usually 0\n    if 0 in tree and 0 in tree[0]:\n        tree[0].remove(0)\n    print_tree(min(tree), tree)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/battery.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Show battery information.\n\n$ python3 scripts/battery.py\ncharge:     74%\nleft:       2:11:31\nstatus:     discharging\nplugged in: no\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef secs2hours(secs):\n    mm, ss = divmod(secs, 60)\n    hh, mm = divmod(mm, 60)\n    return \"%d:%02d:%02d\" % (hh, mm, ss)\n\n\ndef main():\n    if not hasattr(psutil, \"sensors_battery\"):\n        return sys.exit(\"platform not supported\")\n    batt = psutil.sensors_battery()\n    if batt is None:\n        return sys.exit(\"no battery is installed\")\n\n    print(\"charge:     %s%%\" % round(batt.percent, 2))\n    if batt.power_plugged:\n        print(\n            \"status:     %s\"\n            % (\"charging\" if batt.percent < 100 else \"fully charged\")\n        )\n        print(\"plugged in: yes\")\n    else:\n        print(\"left:       %s\" % secs2hours(batt.secsleft))\n        print(\"status:     %s\" % \"discharging\")\n        print(\"plugged in: no\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/free.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'free' cmdline utility.\n\n$ python3 scripts/free.py\n             total       used       free     shared    buffers      cache\nMem:      10125520    8625996    1499524          0     349500    3307836\nSwap:            0          0          0\n\"\"\"\n\nimport psutil\n\n\ndef main():\n    virt = psutil.virtual_memory()\n    swap = psutil.swap_memory()\n    templ = \"%-7s %10s %10s %10s %10s %10s %10s\"\n    print(templ % ('', 'total', 'used', 'free', 'shared', 'buffers', 'cache'))\n    sect = templ % (\n        'Mem:',\n        int(virt.total / 1024),\n        int(virt.used / 1024),\n        int(virt.free / 1024),\n        int(getattr(virt, 'shared', 0) / 1024),\n        int(getattr(virt, 'buffers', 0) / 1024),\n        int(getattr(virt, 'cached', 0) / 1024),\n    )\n    print(sect)\n    sect = templ % (\n        'Swap:',\n        int(swap.total / 1024),\n        int(swap.used / 1024),\n        int(swap.free / 1024),\n        '',\n        '',\n        '',\n    )\n    print(sect)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/winservices.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\nr\"\"\"List all Windows services installed.\n\n$ python3 scripts/winservices.py\nAeLookupSvc (Application Experience)\nstatus: stopped, start: manual, username: localSystem, pid: None\nbinpath: C:\\Windows\\system32\\svchost.exe -k netsvcs\n\nALG (Application Layer Gateway Service)\nstatus: stopped, start: manual, username: NT AUTHORITY\\LocalService, pid: None\nbinpath: C:\\Windows\\System32\\alg.exe\n\nAPNMCP (Ask Update Service)\nstatus: running, start: automatic, username: LocalSystem, pid: 1108\nbinpath: \"C:\\Program Files (x86)\\AskPartnerNetwork\\Toolbar\\apnmcp.exe\"\n\nAppIDSvc (Application Identity)\nstatus: stopped, start: manual, username: NT Authority\\LocalService, pid: None\nbinpath: C:\\Windows\\system32\\svchost.exe -k LocalServiceAndNoImpersonation\n\nAppinfo (Application Information)\nstatus: stopped, start: manual, username: LocalSystem, pid: None\nbinpath: C:\\Windows\\system32\\svchost.exe -k netsvcs\n...\n\"\"\"\n\n\nimport os\nimport sys\n\nimport psutil\n\n\nif os.name != 'nt':\n    sys.exit(\"platform not supported (Windows only)\")\n\n\ndef main():\n    for service in psutil.win_service_iter():\n        info = service.as_dict()\n        print(\"%r (%r)\" % (info['name'], info['display_name']))\n        s = \"status: %s, start: %s, username: %s, pid: %s\" % (\n            info['status'],\n            info['start_type'],\n            info['username'],\n            info['pid'],\n        )\n        print(s)\n        print(\"binpath: %s\" % info['binpath'])\n        print()\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/cpu_distribution.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Shows CPU workload split across different CPUs.\n\n$ python3 scripts/cpu_workload.py\nCPU 0     CPU 1     CPU 2     CPU 3     CPU 4     CPU 5     CPU 6     CPU 7\n19.8      20.6      18.2      15.8      6.9       17.3      5.0       20.4\ngvfsd     pytho     kwork     chrom     unity     kwork     kwork     kwork\nchrom     chrom     indic     ibus-     whoop     nfsd      (sd-p     gvfsd\nibus-     cat       at-sp     chrom     Modem     nfsd4     light     upsta\nibus-     iprt-     ibus-     nacl_     cfg80     kwork     nfsd      bluet\nchrom     irqba     gpg-a     chrom     ext4-     biose     nfsd      dio/n\nchrom     acpid     bamfd     nvidi     kwork     scsi_     sshd      rpc.m\nupsta     rsysl     dbus-     nfsd      biose     scsi_     ext4-     polki\nrtkit     avahi     upowe     Netwo     scsi_     biose     UVM T     irq/9\nlight     rpcbi     snapd     cron      ipv6_     biose     kwork     dbus-\nagett     kvm-i     avahi     kwork     biose     biose     scsi_     syste\nnfsd      syste     rpc.i     biose     biose     kbloc     kthro     UVM g\nnfsd      kwork     kwork     biose     vmsta     kwork     crypt     kaudi\nnfsd      scsi_     charg     biose     md        ksoft     kwork     kwork\nmemca     biose     ksmd      ecryp     ksoft     watch     migra     nvme\ntherm     biose     kcomp     kswap     migra     cpuhp     watch     biose\nsyste     biose     kdevt     khuge     watch               cpuhp     biose\nled_w     devfr     kwork     write     cpuhp                         biose\nrpcio     oom_r     ksoft     kwork     syste                         biose\nkwork     kwork     watch     migra                                   acpi_\nbiose     ksoft     cpuhp     watch                                   watch\nbiose     migra               cpuhp                                   kinte\nbiose     watch               rcu_s                                   netns\nbiose     cpuhp               kthre                                   kwork\ncpuhp                                                                 ksoft\nwatch                                                                 migra\nrcu_b                                                                 cpuhp\nkwork\n\"\"\"\n\nfrom __future__ import print_function\n\nimport collections\nimport os\nimport sys\nimport time\n\nimport psutil\nfrom psutil._compat import get_terminal_size\n\n\nif not hasattr(psutil.Process, \"cpu_num\"):\n    sys.exit(\"platform not supported\")\n\n\ndef clean_screen():\n    if psutil.POSIX:\n        os.system('clear')\n    else:\n        os.system('cls')\n\n\ndef main():\n    num_cpus = psutil.cpu_count()\n    if num_cpus > 8:\n        num_cpus = 8  # try to fit into screen\n        cpus_hidden = True\n    else:\n        cpus_hidden = False\n\n    while True:\n        # header\n        clean_screen()\n        cpus_percent = psutil.cpu_percent(percpu=True)\n        for i in range(num_cpus):\n            print(\"CPU %-6i\" % i, end=\"\")\n        if cpus_hidden:\n            print(\" (+ hidden)\", end=\"\")\n\n        print()\n        for _ in range(num_cpus):\n            print(\"%-10s\" % cpus_percent.pop(0), end=\"\")\n        print()\n\n        # processes\n        procs = collections.defaultdict(list)\n        for p in psutil.process_iter(['name', 'cpu_num']):\n            procs[p.info['cpu_num']].append(p.info['name'][:5])\n\n        curr_line = 3\n        while True:\n            for num in range(num_cpus):\n                try:\n                    pname = procs[num].pop()\n                except IndexError:\n                    pname = \"\"\n                print(\"%-10s\" % pname[:10], end=\"\")\n            print()\n            curr_line += 1\n            if curr_line >= get_terminal_size()[1]:\n                break\n\n        time.sleep(1)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/pmap.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'pmap' utility on Linux, 'vmmap' on macOS and 'procstat\n-v' on BSD. Report memory map of a process.\n\n$ python3 scripts/pmap.py 32402\nAddress                 RSS  Mode    Mapping\n0000000000400000      1200K  r-xp    /usr/bin/python2.7\n0000000000838000         4K  r--p    /usr/bin/python2.7\n0000000000839000       304K  rw-p    /usr/bin/python2.7\n00000000008ae000        68K  rw-p    [anon]\n000000000275e000      5396K  rw-p    [heap]\n00002b29bb1e0000       124K  r-xp    /lib/x86_64-linux-gnu/ld-2.17.so\n00002b29bb203000         8K  rw-p    [anon]\n00002b29bb220000       528K  rw-p    [anon]\n00002b29bb2d8000       768K  rw-p    [anon]\n00002b29bb402000         4K  r--p    /lib/x86_64-linux-gnu/ld-2.17.so\n00002b29bb403000         8K  rw-p    /lib/x86_64-linux-gnu/ld-2.17.so\n00002b29bb405000        60K  r-xp    /lib/x86_64-linux-gnu/libpthread-2.17.so\n00002b29bb41d000         0K  ---p    /lib/x86_64-linux-gnu/libpthread-2.17.so\n00007fff94be6000        48K  rw-p    [stack]\n00007fff94dd1000         4K  r-xp    [vdso]\nffffffffff600000         0K  r-xp    [vsyscall]\n...\n\"\"\"\n\nimport sys\n\nimport psutil\nfrom psutil._common import bytes2human\nfrom psutil._compat import get_terminal_size\n\n\ndef safe_print(s):\n    s = s[: get_terminal_size()[0]]\n    try:\n        print(s)\n    except UnicodeEncodeError:\n        print(s.encode('ascii', 'ignore').decode())\n\n\ndef main():\n    if len(sys.argv) != 2:\n        sys.exit('usage: pmap <pid>')\n    p = psutil.Process(int(sys.argv[1]))\n    templ = \"%-20s %10s  %-7s %s\"\n    print(templ % (\"Address\", \"RSS\", \"Mode\", \"Mapping\"))\n    total_rss = 0\n    for m in p.memory_maps(grouped=False):\n        total_rss += m.rss\n        line = templ % (\n            m.addr.split('-')[0].zfill(16),\n            bytes2human(m.rss),\n            m.perms,\n            m.path,\n        )\n        safe_print(line)\n    print(\"-\" * 31)\n    print(templ % (\"Total\", bytes2human(total_rss), '', ''))\n    safe_print(\"PID = %s, name = %s\" % (p.pid, p.name()))\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/iotop.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of iotop (http://guichaz.free.fr/iotop/) showing real time\ndisk I/O statistics.\n\nIt works on Linux only (FreeBSD and macOS are missing support for IO\ncounters).\nIt doesn't work on Windows as curses module is required.\n\nExample output:\n\n$ python3 scripts/iotop.py\nTotal DISK READ: 0.00 B/s | Total DISK WRITE: 472.00 K/s\nPID   USER      DISK READ  DISK WRITE  COMMAND\n13155 giampao    0.00 B/s  428.00 K/s  /usr/bin/google-chrome-beta\n3260  giampao    0.00 B/s    0.00 B/s  bash\n3779  giampao    0.00 B/s    0.00 B/s  gnome-session --session=ubuntu\n3830  giampao    0.00 B/s    0.00 B/s  /usr/bin/dbus-launch\n3831  giampao    0.00 B/s    0.00 B/s  //bin/dbus-daemon --fork --print-pid 5\n3841  giampao    0.00 B/s    0.00 B/s  /usr/lib/at-spi-bus-launcher\n3845  giampao    0.00 B/s    0.00 B/s  /bin/dbus-daemon\n3848  giampao    0.00 B/s    0.00 B/s  /usr/lib/at-spi2-core/at-spi2-registryd\n3862  giampao    0.00 B/s    0.00 B/s  /usr/lib/gnome-settings-daemon\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\"\"\"\n\nimport sys\nimport time\n\n\ntry:\n    import curses\nexcept ImportError:\n    sys.exit('platform not supported')\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nwin = curses.initscr()\nlineno = 0\n\n\ndef printl(line, highlight=False):\n    \"\"\"A thin wrapper around curses's addstr().\"\"\"\n    global lineno\n    try:\n        if highlight:\n            line += \" \" * (win.getmaxyx()[1] - len(line))\n            win.addstr(lineno, 0, line, curses.A_REVERSE)\n        else:\n            win.addstr(lineno, 0, line, 0)\n    except curses.error:\n        lineno = 0\n        win.refresh()\n        raise\n    else:\n        lineno += 1\n\n\ndef poll(interval):\n    \"\"\"Calculate IO usage by comparing IO statistics before and\n    after the interval.\n    Return a tuple including all currently running processes\n    sorted by IO activity and total disks I/O activity.\n    \"\"\"\n    # first get a list of all processes and disk io counters\n    procs = list(psutil.process_iter())\n    for p in procs[:]:\n        try:\n            p._before = p.io_counters()\n        except psutil.Error:\n            procs.remove(p)\n            continue\n    disks_before = psutil.disk_io_counters()\n\n    # sleep some time\n    time.sleep(interval)\n\n    # then retrieve the same info again\n    for p in procs[:]:\n        with p.oneshot():\n            try:\n                p._after = p.io_counters()\n                p._cmdline = ' '.join(p.cmdline())\n                if not p._cmdline:\n                    p._cmdline = p.name()\n                p._username = p.username()\n            except (psutil.NoSuchProcess, psutil.ZombieProcess):\n                procs.remove(p)\n    disks_after = psutil.disk_io_counters()\n\n    # finally calculate results by comparing data before and\n    # after the interval\n    for p in procs:\n        p._read_per_sec = p._after.read_bytes - p._before.read_bytes\n        p._write_per_sec = p._after.write_bytes - p._before.write_bytes\n        p._total = p._read_per_sec + p._write_per_sec\n\n    disks_read_per_sec = disks_after.read_bytes - disks_before.read_bytes\n    disks_write_per_sec = disks_after.write_bytes - disks_before.write_bytes\n\n    # sort processes by total disk IO so that the more intensive\n    # ones get listed first\n    processes = sorted(procs, key=lambda p: p._total, reverse=True)\n\n    return (processes, disks_read_per_sec, disks_write_per_sec)\n\n\ndef refresh_window(procs, disks_read, disks_write):\n    \"\"\"Print results on screen by using curses.\"\"\"\n    curses.endwin()\n    templ = \"%-5s %-7s %11s %11s  %s\"\n    win.erase()\n\n    disks_tot = \"Total DISK READ: %s | Total DISK WRITE: %s\" % (\n        bytes2human(disks_read),\n        bytes2human(disks_write),\n    )\n    printl(disks_tot)\n\n    header = templ % (\"PID\", \"USER\", \"DISK READ\", \"DISK WRITE\", \"COMMAND\")\n    printl(header, highlight=True)\n\n    for p in procs:\n        line = templ % (\n            p.pid,\n            p._username[:7],\n            bytes2human(p._read_per_sec),\n            bytes2human(p._write_per_sec),\n            p._cmdline,\n        )\n        try:\n            printl(line)\n        except curses.error:\n            break\n    win.refresh()\n\n\ndef setup():\n    curses.start_color()\n    curses.use_default_colors()\n    for i in range(curses.COLORS):\n        curses.init_pair(i + 1, i, -1)\n    curses.endwin()\n    win.nodelay(1)\n\n\ndef tear_down():\n    win.keypad(0)\n    curses.nocbreak()\n    curses.echo()\n    curses.endwin()\n\n\ndef main():\n    global lineno\n    setup()\n    try:\n        interval = 0\n        while True:\n            if win.getch() == ord('q'):\n                break\n            args = poll(interval)\n            refresh_window(*args)\n            lineno = 0\n            interval = 0.5\n            time.sleep(interval)\n    except (KeyboardInterrupt, SystemExit):\n        pass\n    finally:\n        tear_down()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/who.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'who' command; print information about users who are\ncurrently logged in.\n\n$ python3 scripts/who.py\ngiampaolo    console    2017-03-25 22:24                loginwindow\ngiampaolo    ttys000    2017-03-25 23:28 (10.0.2.2)     sshd\n\"\"\"\n\nfrom datetime import datetime\n\nimport psutil\n\n\ndef main():\n    users = psutil.users()\n    for user in users:\n        proc_name = psutil.Process(user.pid).name() if user.pid else \"\"\n        line = \"%-12s %-10s %-10s %-14s %s\" % (\n            user.name,\n            user.terminal or '-',\n            datetime.fromtimestamp(user.started).strftime(\"%Y-%m-%d %H:%M\"),\n            \"(%s)\" % user.host if user.host else \"\",\n            proc_name,\n        )\n        print(line)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/top.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of top / htop.\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n$ python3 scripts/top.py\n CPU0  [||||                                    ]  10.9%\n CPU1  [|||||                                   ]  13.1%\n CPU2  [|||||                                   ]  12.8%\n CPU3  [||||                                    ]  11.5%\n Mem   [|||||||||||||||||||||||||||||           ]  73.0% 11017M / 15936M\n Swap  [                                        ]   1.3%   276M / 20467M\n Processes: 347 (sleeping=273, running=1, idle=73)\n Load average: 1.10 1.28 1.34  Uptime: 8 days, 21:15:40\n\nPID    USER       NI   VIRT    RES  CPU%  MEM%     TIME+  NAME\n5368   giampaol    0   7.2G   4.3G  41.8  27.7  56:34.18  VirtualBox\n24976  giampaol    0   2.1G 487.2M  18.7   3.1  22:05.16  Web Content\n22731  giampaol    0   3.2G 596.2M  11.6   3.7  35:04.90  firefox\n1202   root        0 807.4M 288.5M  10.6   1.8  12:22.12  Xorg\n22811  giampaol    0   2.8G 741.8M   9.0   4.7   2:26.61  Web Content\n2590   giampaol    0   2.3G 579.4M   5.5   3.6  28:02.70  compiz\n22990  giampaol    0   3.0G   1.2G   4.2   7.6   4:30.32  Web Content\n18412  giampaol    0  90.1M  14.5M   3.5   0.1   0:00.26  python3\n26971  netdata     0  20.8M   3.9M   2.9   0.0   3:17.14  apps.plugin\n2421   giampaol    0   3.3G  36.9M   2.3   0.2  57:14.21  pulseaudio\n...\n\"\"\"\n\nimport datetime\nimport sys\nimport time\n\n\ntry:\n    import curses\nexcept ImportError:\n    sys.exit('platform not supported')\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nwin = curses.initscr()\nlineno = 0\ncolors_map = dict(green=3, red=10, yellow=4)\n\n\ndef printl(line, color=None, bold=False, highlight=False):\n    \"\"\"A thin wrapper around curses's addstr().\"\"\"\n    global lineno\n    try:\n        flags = 0\n        if color:\n            flags |= curses.color_pair(colors_map[color])\n        if bold:\n            flags |= curses.A_BOLD\n        if highlight:\n            line += \" \" * (win.getmaxyx()[1] - len(line))\n            flags |= curses.A_STANDOUT\n        win.addstr(lineno, 0, line, flags)\n    except curses.error:\n        lineno = 0\n        win.refresh()\n        raise\n    else:\n        lineno += 1\n\n\n# --- /curses stuff\n\n\ndef poll(interval):\n    # sleep some time\n    time.sleep(interval)\n    procs = []\n    procs_status = {}\n    for p in psutil.process_iter():\n        try:\n            p.dict = p.as_dict([\n                'username',\n                'nice',\n                'memory_info',\n                'memory_percent',\n                'cpu_percent',\n                'cpu_times',\n                'name',\n                'status',\n            ])\n            try:\n                procs_status[p.dict['status']] += 1\n            except KeyError:\n                procs_status[p.dict['status']] = 1\n        except psutil.NoSuchProcess:\n            pass\n        else:\n            procs.append(p)\n\n    # return processes sorted by CPU percent usage\n    processes = sorted(\n        procs, key=lambda p: p.dict['cpu_percent'], reverse=True\n    )\n    return (processes, procs_status)\n\n\ndef get_color(perc):\n    if perc <= 30:\n        return \"green\"\n    elif perc <= 80:\n        return \"yellow\"\n    else:\n        return \"red\"\n\n\ndef print_header(procs_status, num_procs):\n    \"\"\"Print system-related info, above the process list.\"\"\"\n\n    def get_dashes(perc):\n        dashes = \"|\" * int(float(perc) / 10 * 4)\n        empty_dashes = \" \" * (40 - len(dashes))\n        return dashes, empty_dashes\n\n    # cpu usage\n    percs = psutil.cpu_percent(interval=0, percpu=True)\n    for cpu_num, perc in enumerate(percs):\n        dashes, empty_dashes = get_dashes(perc)\n        line = \" CPU%-2s [%s%s] %5s%%\" % (cpu_num, dashes, empty_dashes, perc)\n        printl(line, color=get_color(perc))\n\n    # memory usage\n    mem = psutil.virtual_memory()\n    dashes, empty_dashes = get_dashes(mem.percent)\n    line = \" Mem   [%s%s] %5s%% %6s / %s\" % (\n        dashes,\n        empty_dashes,\n        mem.percent,\n        bytes2human(mem.used),\n        bytes2human(mem.total),\n    )\n    printl(line, color=get_color(mem.percent))\n\n    # swap usage\n    swap = psutil.swap_memory()\n    dashes, empty_dashes = get_dashes(swap.percent)\n    line = \" Swap  [%s%s] %5s%% %6s / %s\" % (\n        dashes,\n        empty_dashes,\n        swap.percent,\n        bytes2human(swap.used),\n        bytes2human(swap.total),\n    )\n    printl(line, color=get_color(swap.percent))\n\n    # processes number and status\n    st = []\n    for x, y in procs_status.items():\n        if y:\n            st.append(\"%s=%s\" % (x, y))\n    st.sort(key=lambda x: x[:3] in ('run', 'sle'), reverse=1)\n    printl(\" Processes: %s (%s)\" % (num_procs, ', '.join(st)))\n    # load average, uptime\n    uptime = datetime.datetime.now() - datetime.datetime.fromtimestamp(\n        psutil.boot_time()\n    )\n    av1, av2, av3 = psutil.getloadavg()\n    line = \" Load average: %.2f %.2f %.2f  Uptime: %s\" % (\n        av1,\n        av2,\n        av3,\n        str(uptime).split('.')[0],\n    )\n    printl(line)\n\n\ndef refresh_window(procs, procs_status):\n    \"\"\"Print results on screen by using curses.\"\"\"\n    curses.endwin()\n    templ = \"%-6s %-8s %4s %6s %6s %5s %5s %9s  %2s\"\n    win.erase()\n    header = templ % (\n        \"PID\",\n        \"USER\",\n        \"NI\",\n        \"VIRT\",\n        \"RES\",\n        \"CPU%\",\n        \"MEM%\",\n        \"TIME+\",\n        \"NAME\",\n    )\n    print_header(procs_status, len(procs))\n    printl(\"\")\n    printl(header, bold=True, highlight=True)\n    for p in procs:\n        # TIME+ column shows process CPU cumulative time and it\n        # is expressed as: \"mm:ss.ms\"\n        if p.dict['cpu_times'] is not None:\n            ctime = datetime.timedelta(seconds=sum(p.dict['cpu_times']))\n            ctime = \"%s:%s.%s\" % (\n                ctime.seconds // 60 % 60,\n                str(ctime.seconds % 60).zfill(2),\n                str(ctime.microseconds)[:2],\n            )\n        else:\n            ctime = ''\n        if p.dict['memory_percent'] is not None:\n            p.dict['memory_percent'] = round(p.dict['memory_percent'], 1)\n        else:\n            p.dict['memory_percent'] = ''\n        if p.dict['cpu_percent'] is None:\n            p.dict['cpu_percent'] = ''\n        username = p.dict['username'][:8] if p.dict['username'] else ''\n        line = templ % (\n            p.pid,\n            username,\n            p.dict['nice'],\n            bytes2human(getattr(p.dict['memory_info'], 'vms', 0)),\n            bytes2human(getattr(p.dict['memory_info'], 'rss', 0)),\n            p.dict['cpu_percent'],\n            p.dict['memory_percent'],\n            ctime,\n            p.dict['name'] or '',\n        )\n        try:\n            printl(line)\n        except curses.error:\n            break\n        win.refresh()\n\n\ndef setup():\n    curses.start_color()\n    curses.use_default_colors()\n    for i in range(curses.COLORS):\n        curses.init_pair(i + 1, i, -1)\n    curses.endwin()\n    win.nodelay(1)\n\n\ndef tear_down():\n    win.keypad(0)\n    curses.nocbreak()\n    curses.echo()\n    curses.endwin()\n\n\ndef main():\n    setup()\n    try:\n        interval = 0\n        while True:\n            if win.getch() == ord('q'):\n                break\n            args = poll(interval)\n            refresh_window(*args)\n            interval = 1\n    except (KeyboardInterrupt, SystemExit):\n        pass\n    finally:\n        tear_down()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/ifconfig.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'ifconfig' on UNIX.\n\n$ python3 scripts/ifconfig.py\nlo:\n    stats          : speed=0MB, duplex=?, mtu=65536, up=yes\n    incoming       : bytes=1.95M, pkts=22158, errs=0, drops=0\n    outgoing       : bytes=1.95M, pkts=22158, errs=0, drops=0\n    IPv4 address   : 127.0.0.1\n         netmask   : 255.0.0.0\n    IPv6 address   : ::1\n         netmask   : ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\n    MAC  address   : 00:00:00:00:00:00\n\ndocker0:\n    stats          : speed=0MB, duplex=?, mtu=1500, up=yes\n    incoming       : bytes=3.48M, pkts=65470, errs=0, drops=0\n    outgoing       : bytes=164.06M, pkts=112993, errs=0, drops=0\n    IPv4 address   : 172.17.0.1\n         broadcast : 172.17.0.1\n         netmask   : 255.255.0.0\n    IPv6 address   : fe80::42:27ff:fe5e:799e%docker0\n         netmask   : ffff:ffff:ffff:ffff::\n    MAC  address   : 02:42:27:5e:79:9e\n         broadcast : ff:ff:ff:ff:ff:ff\n\nwlp3s0:\n    stats          : speed=0MB, duplex=?, mtu=1500, up=yes\n    incoming       : bytes=7.04G, pkts=5637208, errs=0, drops=0\n    outgoing       : bytes=372.01M, pkts=3200026, errs=0, drops=0\n    IPv4 address   : 10.0.0.2\n         broadcast : 10.255.255.255\n         netmask   : 255.0.0.0\n    IPv6 address   : fe80::ecb3:1584:5d17:937%wlp3s0\n         netmask   : ffff:ffff:ffff:ffff::\n    MAC  address   : 48:45:20:59:a4:0c\n         broadcast : ff:ff:ff:ff:ff:ff\n\"\"\"\n\nfrom __future__ import print_function\n\nimport socket\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\naf_map = {\n    socket.AF_INET: 'IPv4',\n    socket.AF_INET6: 'IPv6',\n    psutil.AF_LINK: 'MAC',\n}\n\nduplex_map = {\n    psutil.NIC_DUPLEX_FULL: \"full\",\n    psutil.NIC_DUPLEX_HALF: \"half\",\n    psutil.NIC_DUPLEX_UNKNOWN: \"?\",\n}\n\n\ndef main():\n    stats = psutil.net_if_stats()\n    io_counters = psutil.net_io_counters(pernic=True)\n    for nic, addrs in psutil.net_if_addrs().items():\n        print(\"%s:\" % (nic))\n        if nic in stats:\n            st = stats[nic]\n            print(\"    stats          : \", end='')\n            print(\n                \"speed=%sMB, duplex=%s, mtu=%s, up=%s\"\n                % (\n                    st.speed,\n                    duplex_map[st.duplex],\n                    st.mtu,\n                    \"yes\" if st.isup else \"no\",\n                )\n            )\n        if nic in io_counters:\n            io = io_counters[nic]\n            print(\"    incoming       : \", end='')\n            print(\n                \"bytes=%s, pkts=%s, errs=%s, drops=%s\"\n                % (\n                    bytes2human(io.bytes_recv),\n                    io.packets_recv,\n                    io.errin,\n                    io.dropin,\n                )\n            )\n            print(\"    outgoing       : \", end='')\n            print(\n                \"bytes=%s, pkts=%s, errs=%s, drops=%s\"\n                % (\n                    bytes2human(io.bytes_sent),\n                    io.packets_sent,\n                    io.errout,\n                    io.dropout,\n                )\n            )\n        for addr in addrs:\n            print(\"    %-4s\" % af_map.get(addr.family, addr.family), end=\"\")\n            print(\" address   : %s\" % addr.address)\n            if addr.broadcast:\n                print(\"         broadcast : %s\" % addr.broadcast)\n            if addr.netmask:\n                print(\"         netmask   : %s\" % addr.netmask)\n            if addr.ptp:\n                print(\"      p2p       : %s\" % addr.ptp)\n        print()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/temperatures.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'sensors' utility on Linux printing hardware temperatures.\n\n$ python3 scripts/sensors.py\nasus\n    asus                 47.0 \u00b0C (high = None \u00b0C, critical = None \u00b0C)\n\nacpitz\n    acpitz               47.0 \u00b0C (high = 103.0 \u00b0C, critical = 103.0 \u00b0C)\n\ncoretemp\n    Physical id 0        54.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 0               47.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 1               48.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 2               47.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n    Core 3               54.0 \u00b0C (high = 100.0 \u00b0C, critical = 100.0 \u00b0C)\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef main():\n    if not hasattr(psutil, \"sensors_temperatures\"):\n        sys.exit(\"platform not supported\")\n    temps = psutil.sensors_temperatures()\n    if not temps:\n        sys.exit(\"can't read any temperature\")\n    for name, entries in temps.items():\n        print(name)\n        for entry in entries:\n            line = \"    %-20s %s \u00b0C (high = %s \u00b0C, critical = %s \u00b0C)\" % (\n                entry.label or name,\n                entry.current,\n                entry.high,\n                entry.critical,\n            )\n            print(line)\n        print()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/netstat.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'netstat -antp' on Linux.\n\n$ python3 scripts/netstat.py\nProto Local address      Remote address   Status        PID    Program name\ntcp   127.0.0.1:48256    127.0.0.1:45884  ESTABLISHED   13646  chrome\ntcp   127.0.0.1:47073    127.0.0.1:45884  ESTABLISHED   13646  chrome\ntcp   127.0.0.1:47072    127.0.0.1:45884  ESTABLISHED   13646  chrome\ntcp   127.0.0.1:45884    -                LISTEN        13651  GoogleTalkPlugi\ntcp   127.0.0.1:60948    -                LISTEN        13651  GoogleTalkPlugi\ntcp   172.17.42.1:49102  127.0.0.1:19305  CLOSE_WAIT    13651  GoogleTalkPlugi\ntcp   172.17.42.1:55797  127.0.0.1:443    CLOSE_WAIT    13651  GoogleTalkPlugi\n...\n\"\"\"\n\nimport socket\nfrom socket import AF_INET\nfrom socket import SOCK_DGRAM\nfrom socket import SOCK_STREAM\n\nimport psutil\n\n\nAD = \"-\"\nAF_INET6 = getattr(socket, 'AF_INET6', object())\nproto_map = {\n    (AF_INET, SOCK_STREAM): 'tcp',\n    (AF_INET6, SOCK_STREAM): 'tcp6',\n    (AF_INET, SOCK_DGRAM): 'udp',\n    (AF_INET6, SOCK_DGRAM): 'udp6',\n}\n\n\ndef main():\n    templ = \"%-5s %-30s %-30s %-13s %-6s %s\"\n    header = templ % (\n        \"Proto\",\n        \"Local address\",\n        \"Remote address\",\n        \"Status\",\n        \"PID\",\n        \"Program name\",\n    )\n    print(header)\n    proc_names = {}\n    for p in psutil.process_iter(['pid', 'name']):\n        proc_names[p.info['pid']] = p.info['name']\n    for c in psutil.net_connections(kind='inet'):\n        laddr = \"%s:%s\" % (c.laddr)\n        raddr = \"\"\n        if c.raddr:\n            raddr = \"%s:%s\" % (c.raddr)\n        name = proc_names.get(c.pid, '?') or ''\n        line = templ % (\n            proto_map[(c.family, c.type)],\n            laddr,\n            raddr or AD,\n            c.status,\n            c.pid or AD,\n            name[:15],\n        )\n        print(line)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/procsmem.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Show detailed memory usage about all (querable) processes.\n\nProcesses are sorted by their \"USS\" (Unique Set Size) memory, which is\nprobably the most representative metric for determining how much memory\nis actually being used by a process.\n\nThis is similar to \"smem\" cmdline utility on Linux:\nhttps://www.selenic.com/smem/\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n~/svn/psutil$ ./scripts/procsmem.py\nPID     User    Cmdline                            USS     PSS    Swap     RSS\n==============================================================================\n...\n3986    giampao /usr/bin/python3 /usr/bin/indi   15.3M   16.6M      0B   25.6M\n3906    giampao /usr/lib/ibus/ibus-ui-gtk3       17.6M   18.1M      0B   26.7M\n3991    giampao python /usr/bin/hp-systray -x    19.0M   23.3M      0B   40.7M\n3830    giampao /usr/bin/ibus-daemon --daemoni   19.0M   19.0M      0B   21.4M\n20529   giampao /opt/sublime_text/plugin_host    19.9M   20.1M      0B   22.0M\n3990    giampao nautilus -n                      20.6M   29.9M      0B   50.2M\n3898    giampao /usr/lib/unity/unity-panel-ser   27.1M   27.9M      0B   37.7M\n4176    giampao /usr/lib/evolution/evolution-c   35.7M   36.2M      0B   41.5M\n20712   giampao /usr/bin/python -B /home/giamp   45.6M   45.9M      0B   49.4M\n3880    giampao /usr/lib/x86_64-linux-gnu/hud/   51.6M   52.7M      0B   61.3M\n20513   giampao /opt/sublime_text/sublime_text   65.8M   73.0M      0B   87.9M\n3976    giampao compiz                          115.0M  117.0M      0B  130.9M\n32486   giampao skype                           145.1M  147.5M      0B  149.6M\n\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\nif not (psutil.LINUX or psutil.MACOS or psutil.WINDOWS):\n    sys.exit(\"platform not supported\")\n\n\ndef convert_bytes(n):\n    symbols = ('K', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y')\n    prefix = {}\n    for i, s in enumerate(symbols):\n        prefix[s] = 1 << (i + 1) * 10\n    for s in reversed(symbols):\n        if n >= prefix[s]:\n            value = float(n) / prefix[s]\n            return '%.1f%s' % (value, s)\n    return \"%sB\" % n\n\n\ndef main():\n    ad_pids = []\n    procs = []\n    for p in psutil.process_iter():\n        with p.oneshot():\n            try:\n                mem = p.memory_full_info()\n                info = p.as_dict([\"cmdline\", \"username\"])\n            except psutil.AccessDenied:\n                ad_pids.append(p.pid)\n            except psutil.NoSuchProcess:\n                pass\n            else:\n                p._uss = mem.uss\n                p._rss = mem.rss\n                if not p._uss:\n                    continue\n                p._pss = getattr(mem, \"pss\", \"\")\n                p._swap = getattr(mem, \"swap\", \"\")\n                p._info = info\n                procs.append(p)\n\n    procs.sort(key=lambda p: p._uss)\n    templ = \"%-7s %-7s %7s %7s %7s %7s %7s\"\n    print(templ % (\"PID\", \"User\", \"USS\", \"PSS\", \"Swap\", \"RSS\", \"Cmdline\"))\n    print(\"=\" * 78)\n    for p in procs[:86]:\n        cmd = \" \".join(p._info[\"cmdline\"])[:50] if p._info[\"cmdline\"] else \"\"\n        line = templ % (\n            p.pid,\n            p._info[\"username\"][:7] if p._info[\"username\"] else \"\",\n            convert_bytes(p._uss),\n            convert_bytes(p._pss) if p._pss else \"\",\n            convert_bytes(p._swap) if p._swap else \"\",\n            convert_bytes(p._rss),\n            cmd,\n        )\n        print(line)\n    if ad_pids:\n        print(\n            \"warning: access denied for %s pids\" % (len(ad_pids)),\n            file=sys.stderr,\n        )\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/sensors.py": "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'sensors' utility on Linux printing hardware temperatures,\nfans speed and battery info.\n\n$ python3 scripts/sensors.py\nasus\n    Temperatures:\n        asus                 57.0\u00b0C (high=None\u00b0C, critical=None\u00b0C)\n    Fans:\n        cpu_fan              3500 RPM\nacpitz\n    Temperatures:\n        acpitz               57.0\u00b0C (high=108.0\u00b0C, critical=108.0\u00b0C)\ncoretemp\n    Temperatures:\n        Physical id 0        61.0\u00b0C (high=87.0\u00b0C, critical=105.0\u00b0C)\n        Core 0               61.0\u00b0C (high=87.0\u00b0C, critical=105.0\u00b0C)\n        Core 1               59.0\u00b0C (high=87.0\u00b0C, critical=105.0\u00b0C)\nBattery:\n    charge:     84.95%\n    status:     charging\n    plugged in: yes\n\"\"\"\n\nfrom __future__ import print_function\n\nimport psutil\n\n\ndef secs2hours(secs):\n    mm, ss = divmod(secs, 60)\n    hh, mm = divmod(mm, 60)\n    return \"%d:%02d:%02d\" % (hh, mm, ss)\n\n\ndef main():\n    if hasattr(psutil, \"sensors_temperatures\"):\n        temps = psutil.sensors_temperatures()\n    else:\n        temps = {}\n    fans = psutil.sensors_fans() if hasattr(psutil, \"sensors_fans\") else {}\n    if hasattr(psutil, \"sensors_battery\"):\n        battery = psutil.sensors_battery()\n    else:\n        battery = None\n\n    if not any((temps, fans, battery)):\n        print(\"can't read any temperature, fans or battery info\")\n        return\n\n    names = set(list(temps.keys()) + list(fans.keys()))\n    for name in names:\n        print(name)\n        # Temperatures.\n        if name in temps:\n            print(\"    Temperatures:\")\n            for entry in temps[name]:\n                s = \"        %-20s %s\u00b0C (high=%s\u00b0C, critical=%s\u00b0C)\" % (\n                    entry.label or name,\n                    entry.current,\n                    entry.high,\n                    entry.critical,\n                )\n                print(s)\n        # Fans.\n        if name in fans:\n            print(\"    Fans:\")\n            for entry in fans[name]:\n                print(\n                    \"        %-20s %s RPM\"\n                    % (entry.label or name, entry.current)\n                )\n\n    # Battery.\n    if battery:\n        print(\"Battery:\")\n        print(\"    charge:     %s%%\" % round(battery.percent, 2))\n        if battery.power_plugged:\n            print(\n                \"    status:     %s\"\n                % (\"charging\" if battery.percent < 100 else \"fully charged\")\n            )\n            print(\"    plugged in: yes\")\n        else:\n            print(\"    left:       %s\" % secs2hours(battery.secsleft))\n            print(\"    status:     %s\" % \"discharging\")\n            print(\"    plugged in: no\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/meminfo.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Print system memory information.\n\n$ python3 scripts/meminfo.py\nMEMORY\n------\nTotal      :    9.7G\nAvailable  :    4.9G\nPercent    :    49.0\nUsed       :    8.2G\nFree       :    1.4G\nActive     :    5.6G\nInactive   :    2.1G\nBuffers    :  341.2M\nCached     :    3.2G\n\nSWAP\n----\nTotal      :      0B\nUsed       :      0B\nFree       :      0B\nPercent    :     0.0\nSin        :      0B\nSout       :      0B\n\"\"\"\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\ndef pprint_ntuple(nt):\n    for name in nt._fields:\n        value = getattr(nt, name)\n        if name != 'percent':\n            value = bytes2human(value)\n        print('%-10s : %7s' % (name.capitalize(), value))\n\n\ndef main():\n    print('MEMORY\\n------')\n    pprint_ntuple(psutil.virtual_memory())\n    print('\\nSWAP\\n----')\n    pprint_ntuple(psutil.swap_memory())\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/disk_usage.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"List all mounted disk partitions a-la \"df -h\" command.\n\n$ python3 scripts/disk_usage.py\nDevice               Total     Used     Free  Use %      Type  Mount\n/dev/sdb3            18.9G    14.7G     3.3G    77%      ext4  /\n/dev/sda6           345.9G    83.8G   244.5G    24%      ext4  /home\n/dev/sda1           296.0M    43.1M   252.9M    14%      vfat  /boot/efi\n/dev/sda2           600.0M   312.4M   287.6M    52%   fuseblk  /media/Recovery\n\n\"\"\"\n\nimport os\nimport sys\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\ndef main():\n    templ = \"%-17s %8s %8s %8s %5s%% %9s  %s\"\n    print(templ % (\"Device\", \"Total\", \"Used\", \"Free\", \"Use \", \"Type\", \"Mount\"))\n    for part in psutil.disk_partitions(all=False):\n        if os.name == 'nt':\n            if 'cdrom' in part.opts or not part.fstype:\n                # skip cd-rom drives with no disk in it; they may raise\n                # ENOENT, pop-up a Windows GUI error for a non-ready\n                # partition or just hang.\n                continue\n        usage = psutil.disk_usage(part.mountpoint)\n        line = templ % (\n            part.device,\n            bytes2human(usage.total),\n            bytes2human(usage.used),\n            bytes2human(usage.free),\n            int(usage.percent),\n            part.fstype,\n            part.mountpoint,\n        )\n        print(line)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/procinfo.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Print detailed information about a process.\n\nAuthor: Giampaolo Rodola' <g.rodola@gmail.com>\n\n$ python3 scripts/procinfo.py\npid           4600\nname          chrome\nparent        4554 (bash)\nexe           /opt/google/chrome/chrome\ncwd           /home/giampaolo\ncmdline       /opt/google/chrome/chrome\nstarted       2016-09-19 11:12\ncpu-tspent    27:27.68\ncpu-times     user=8914.32, system=3530.59,\n              children_user=1.46, children_system=1.31\ncpu-affinity  [0, 1, 2, 3, 4, 5, 6, 7]\nmemory        rss=520.5M, vms=1.9G, shared=132.6M, text=95.0M, lib=0B,\n              data=816.5M, dirty=0B\nmemory %      3.26\nuser          giampaolo\nuids          real=1000, effective=1000, saved=1000\nuids          real=1000, effective=1000, saved=1000\nterminal      /dev/pts/2\nstatus        sleeping\nnice          0\nionice        class=IOPriority.IOPRIO_CLASS_NONE, value=0\nnum-threads   47\nnum-fds       379\nI/O           read_count=96.6M, write_count=80.7M,\n              read_bytes=293.2M, write_bytes=24.5G\nctx-switches  voluntary=30426463, involuntary=460108\nchildren      PID    NAME\n              4605   cat\n              4606   cat\n              4609   chrome\n              4669   chrome\nopen-files    PATH\n              /opt/google/chrome/icudtl.dat\n              /opt/google/chrome/snapshot_blob.bin\n              /opt/google/chrome/natives_blob.bin\n              /opt/google/chrome/chrome_100_percent.pak\n              [...]\nconnections   PROTO LOCAL ADDR            REMOTE ADDR               STATUS\n              UDP   10.0.0.3:3693         *:*                       NONE\n              TCP   10.0.0.3:55102        172.217.22.14:443         ESTABLISHED\n              UDP   10.0.0.3:35172        *:*                       NONE\n              TCP   10.0.0.3:32922        172.217.16.163:443        ESTABLISHED\n              UDP   :::5353               *:*                       NONE\n              UDP   10.0.0.3:59925        *:*                       NONE\nthreads       TID              USER          SYSTEM\n              11795             0.7            1.35\n              11796            0.68            1.37\n              15887            0.74            0.03\n              19055            0.77            0.01\n              [...]\n              total=47\nres-limits    RLIMIT                     SOFT       HARD\n              virtualmem             infinity   infinity\n              coredumpsize                  0   infinity\n              cputime                infinity   infinity\n              datasize               infinity   infinity\n              filesize               infinity   infinity\n              locks                  infinity   infinity\n              memlock                   65536      65536\n              msgqueue                 819200     819200\n              nice                          0          0\n              openfiles                  8192      65536\n              maxprocesses              63304      63304\n              rss                    infinity   infinity\n              realtimeprio                  0          0\n              rtimesched             infinity   infinity\n              sigspending               63304      63304\n              stack                   8388608   infinity\nmem-maps      RSS      PATH\n              381.4M   [anon]\n              62.8M    /opt/google/chrome/chrome\n              15.8M    /home/giampaolo/.config/google-chrome/Default/History\n              6.6M     /home/giampaolo/.config/google-chrome/Default/Favicons\n              [...]\n\"\"\"\n\nimport argparse\nimport datetime\nimport socket\nimport sys\n\nimport psutil\nfrom psutil._common import bytes2human\n\n\nACCESS_DENIED = ''\nNON_VERBOSE_ITERATIONS = 4\nRLIMITS_MAP = {\n    \"RLIMIT_AS\": \"virtualmem\",\n    \"RLIMIT_CORE\": \"coredumpsize\",\n    \"RLIMIT_CPU\": \"cputime\",\n    \"RLIMIT_DATA\": \"datasize\",\n    \"RLIMIT_FSIZE\": \"filesize\",\n    \"RLIMIT_MEMLOCK\": \"memlock\",\n    \"RLIMIT_MSGQUEUE\": \"msgqueue\",\n    \"RLIMIT_NICE\": \"nice\",\n    \"RLIMIT_NOFILE\": \"openfiles\",\n    \"RLIMIT_NPROC\": \"maxprocesses\",\n    \"RLIMIT_NPTS\": \"pseudoterms\",\n    \"RLIMIT_RSS\": \"rss\",\n    \"RLIMIT_RTPRIO\": \"realtimeprio\",\n    \"RLIMIT_RTTIME\": \"rtimesched\",\n    \"RLIMIT_SBSIZE\": \"sockbufsize\",\n    \"RLIMIT_SIGPENDING\": \"sigspending\",\n    \"RLIMIT_STACK\": \"stack\",\n    \"RLIMIT_SWAP\": \"swapuse\",\n}\n\n\ndef print_(a, b):\n    if sys.stdout.isatty() and psutil.POSIX:\n        fmt = '\\x1b[1;32m%-13s\\x1b[0m %s' % (a, b)\n    else:\n        fmt = '%-11s %s' % (a, b)\n    print(fmt)\n\n\ndef str_ntuple(nt, convert_bytes=False):\n    if nt == ACCESS_DENIED:\n        return \"\"\n    if not convert_bytes:\n        return \", \".join([\"%s=%s\" % (x, getattr(nt, x)) for x in nt._fields])\n    else:\n        return \", \".join(\n            [\"%s=%s\" % (x, bytes2human(getattr(nt, x))) for x in nt._fields]\n        )\n\n\ndef run(pid, verbose=False):\n    try:\n        proc = psutil.Process(pid)\n        pinfo = proc.as_dict(ad_value=ACCESS_DENIED)\n    except psutil.NoSuchProcess as err:\n        sys.exit(str(err))\n\n    # collect other proc info\n    with proc.oneshot():\n        try:\n            parent = proc.parent()\n            parent = '(%s)' % parent.name() if parent else ''\n        except psutil.Error:\n            parent = ''\n        try:\n            pinfo['children'] = proc.children()\n        except psutil.Error:\n            pinfo['children'] = []\n        if pinfo['create_time']:\n            started = datetime.datetime.fromtimestamp(\n                pinfo['create_time']\n            ).strftime('%Y-%m-%d %H:%M')\n        else:\n            started = ACCESS_DENIED\n\n    # here we go\n    print_('pid', pinfo['pid'])\n    print_('name', pinfo['name'])\n    print_('parent', '%s %s' % (pinfo['ppid'], parent))\n    print_('exe', pinfo['exe'])\n    print_('cwd', pinfo['cwd'])\n    print_('cmdline', ' '.join(pinfo['cmdline']))\n    print_('started', started)\n\n    cpu_tot_time = datetime.timedelta(seconds=sum(pinfo['cpu_times']))\n    cpu_tot_time = \"%s:%s.%s\" % (\n        cpu_tot_time.seconds // 60 % 60,\n        str(cpu_tot_time.seconds % 60).zfill(2),\n        str(cpu_tot_time.microseconds)[:2],\n    )\n    print_('cpu-tspent', cpu_tot_time)\n    print_('cpu-times', str_ntuple(pinfo['cpu_times']))\n    if hasattr(proc, \"cpu_affinity\"):\n        print_(\"cpu-affinity\", pinfo[\"cpu_affinity\"])\n    if hasattr(proc, \"cpu_num\"):\n        print_(\"cpu-num\", pinfo[\"cpu_num\"])\n\n    print_('memory', str_ntuple(pinfo['memory_info'], convert_bytes=True))\n    print_('memory %', round(pinfo['memory_percent'], 2))\n    print_('user', pinfo['username'])\n    if psutil.POSIX:\n        print_('uids', str_ntuple(pinfo['uids']))\n    if psutil.POSIX:\n        print_('uids', str_ntuple(pinfo['uids']))\n    if psutil.POSIX:\n        print_('terminal', pinfo['terminal'] or '')\n\n    print_('status', pinfo['status'])\n    print_('nice', pinfo['nice'])\n    if hasattr(proc, \"ionice\"):\n        try:\n            ionice = proc.ionice()\n        except psutil.Error:\n            pass\n        else:\n            if psutil.WINDOWS:\n                print_(\"ionice\", ionice)\n            else:\n                print_(\n                    \"ionice\",\n                    \"class=%s, value=%s\" % (str(ionice.ioclass), ionice.value),\n                )\n\n    print_('num-threads', pinfo['num_threads'])\n    if psutil.POSIX:\n        print_('num-fds', pinfo['num_fds'])\n    if psutil.WINDOWS:\n        print_('num-handles', pinfo['num_handles'])\n\n    if 'io_counters' in pinfo:\n        print_('I/O', str_ntuple(pinfo['io_counters'], convert_bytes=True))\n    if 'num_ctx_switches' in pinfo:\n        print_(\"ctx-switches\", str_ntuple(pinfo['num_ctx_switches']))\n    if pinfo['children']:\n        template = \"%-6s %s\"\n        print_(\"children\", template % (\"PID\", \"NAME\"))\n        for child in pinfo['children']:\n            try:\n                print_('', template % (child.pid, child.name()))\n            except psutil.AccessDenied:\n                print_('', template % (child.pid, \"\"))\n            except psutil.NoSuchProcess:\n                pass\n\n    if pinfo['open_files']:\n        print_('open-files', 'PATH')\n        for i, file in enumerate(pinfo['open_files']):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_('', file.path)\n    else:\n        print_('open-files', '')\n\n    if pinfo['net_connections']:\n        template = '%-5s %-25s %-25s %s'\n        print_(\n            'connections',\n            template % ('PROTO', 'LOCAL ADDR', 'REMOTE ADDR', 'STATUS'),\n        )\n        for conn in pinfo['net_connections']:\n            if conn.type == socket.SOCK_STREAM:\n                type = 'TCP'\n            elif conn.type == socket.SOCK_DGRAM:\n                type = 'UDP'\n            else:\n                type = 'UNIX'\n            lip, lport = conn.laddr\n            if not conn.raddr:\n                rip, rport = '*', '*'\n            else:\n                rip, rport = conn.raddr\n            line = template % (\n                type,\n                \"%s:%s\" % (lip, lport),\n                \"%s:%s\" % (rip, rport),\n                conn.status,\n            )\n            print_('', line)\n    else:\n        print_('connections', '')\n\n    if pinfo['threads'] and len(pinfo['threads']) > 1:\n        template = \"%-5s %12s %12s\"\n        print_('threads', template % (\"TID\", \"USER\", \"SYSTEM\"))\n        for i, thread in enumerate(pinfo['threads']):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_('', template % thread)\n        print_('', \"total=%s\" % len(pinfo['threads']))\n    else:\n        print_('threads', '')\n\n    if hasattr(proc, \"rlimit\"):\n        res_names = [x for x in dir(psutil) if x.startswith(\"RLIMIT\")]\n        resources = []\n        for res_name in res_names:\n            try:\n                soft, hard = proc.rlimit(getattr(psutil, res_name))\n            except psutil.AccessDenied:\n                pass\n            else:\n                resources.append((res_name, soft, hard))\n        if resources:\n            template = \"%-12s %15s %15s\"\n            print_(\"res-limits\", template % (\"RLIMIT\", \"SOFT\", \"HARD\"))\n            for res_name, soft, hard in resources:\n                if soft == psutil.RLIM_INFINITY:\n                    soft = \"infinity\"\n                if hard == psutil.RLIM_INFINITY:\n                    hard = \"infinity\"\n                print_(\n                    '',\n                    template\n                    % (RLIMITS_MAP.get(res_name, res_name), soft, hard),\n                )\n\n    if hasattr(proc, \"environ\") and pinfo['environ']:\n        template = \"%-25s %s\"\n        print_(\"environ\", template % (\"NAME\", \"VALUE\"))\n        for i, k in enumerate(sorted(pinfo['environ'])):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_(\"\", template % (k, pinfo['environ'][k]))\n\n    if pinfo.get('memory_maps', None):\n        template = \"%-8s %s\"\n        print_(\"mem-maps\", template % (\"RSS\", \"PATH\"))\n        maps = sorted(pinfo['memory_maps'], key=lambda x: x.rss, reverse=True)\n        for i, region in enumerate(maps):\n            if not verbose and i >= NON_VERBOSE_ITERATIONS:\n                print_(\"\", \"[...]\")\n                break\n            print_(\"\", template % (bytes2human(region.rss), region.path))\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=\"print information about a process\"\n    )\n    parser.add_argument(\"pid\", type=int, help=\"process pid\", nargs='?')\n    parser.add_argument(\n        '--verbose', '-v', action='store_true', help=\"print more info\"\n    )\n    args = parser.parse_args()\n    run(args.pid, args.verbose)\n\n\nif __name__ == '__main__':\n    sys.exit(main())\n", "scripts/fans.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Show fans information.\n\n$ python fans.py\nasus\n    cpu_fan              3200 RPM\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef main():\n    if not hasattr(psutil, \"sensors_fans\"):\n        return sys.exit(\"platform not supported\")\n    fans = psutil.sensors_fans()\n    if not fans:\n        print(\"no fans detected\")\n        return\n    for name, entries in fans.items():\n        print(name)\n        for entry in entries:\n            print(\"    %-20s %s RPM\" % (entry.label or name, entry.current))\n        print()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/pidof.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola', karthikrev. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\n\"\"\"A clone of 'pidof' cmdline utility.\n\n$ pidof python\n1140 1138 1136 1134 1133 1129 1127 1125 1121 1120 1119\n\"\"\"\n\nfrom __future__ import print_function\n\nimport sys\n\nimport psutil\n\n\ndef pidof(pgname):\n    pids = []\n    for proc in psutil.process_iter(['name', 'cmdline']):\n        # search for matches in the process name and cmdline\n        if (\n            proc.info['name'] == pgname\n            or proc.info['cmdline']\n            and proc.info['cmdline'][0] == pgname\n        ):\n            pids.append(str(proc.pid))\n    return pids\n\n\ndef main():\n    if len(sys.argv) != 2:\n        sys.exit('usage: %s pgname' % __file__)\n    else:\n        pgname = sys.argv[1]\n    pids = pidof(pgname)\n    if pids:\n        print(\" \".join(pids))\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/ps.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A clone of 'ps aux'.\n\n$ python3 scripts/ps.py\nUSER         PID  %MEM     VSZ     RSS  NICE STATUS  START   TIME  CMDLINE\nroot           1   0.0  220.9M    6.5M        sleep  Mar27  09:10  /lib/systemd\nroot           2   0.0    0.0B    0.0B        sleep  Mar27  00:00  kthreadd\nroot           4   0.0    0.0B    0.0B   -20   idle  Mar27  00:00  kworker/0:0H\nroot           6   0.0    0.0B    0.0B   -20   idle  Mar27  00:00  mm_percpu_wq\nroot           7   0.0    0.0B    0.0B        sleep  Mar27  00:06  ksoftirqd/0\nroot           8   0.0    0.0B    0.0B         idle  Mar27  03:32  rcu_sched\nroot           9   0.0    0.0B    0.0B         idle  Mar27  00:00  rcu_bh\nroot          10   0.0    0.0B    0.0B        sleep  Mar27  00:00  migration/0\nroot          11   0.0    0.0B    0.0B        sleep  Mar27  00:00  watchdog/0\nroot          12   0.0    0.0B    0.0B        sleep  Mar27  00:00  cpuhp/0\nroot          13   0.0    0.0B    0.0B        sleep  Mar27  00:00  cpuhp/1\nroot          14   0.0    0.0B    0.0B        sleep  Mar27  00:01  watchdog/1\nroot          15   0.0    0.0B    0.0B        sleep  Mar27  00:00  migration/1\n[...]\ngiampaolo  19704   1.5    1.9G  235.6M        sleep  17:39  01:11  firefox\nroot       20414   0.0    0.0B    0.0B         idle  Apr04  00:00  kworker/4:2\ngiampaolo  20952   0.0   10.7M  100.0K        sleep  Mar28  00:00  sh -c /usr\ngiampaolo  20953   0.0  269.0M  528.0K        sleep  Mar28  00:00  /usr/lib/\ngiampaolo  22150   3.3    2.4G  525.5M        sleep  Apr02  49:09  /usr/lib/\nroot       22338   0.0    0.0B    0.0B         idle  02:04  00:00  kworker/1:2\ngiampaolo  24123   0.0   35.0M    7.0M        sleep  02:12  00:02  bash\n\"\"\"\n\nimport datetime\nimport time\n\nimport psutil\nfrom psutil._common import bytes2human\nfrom psutil._compat import get_terminal_size\n\n\ndef main():\n    today_day = datetime.date.today()\n    # fmt: off\n    templ = \"%-10s %5s %5s %7s %7s %5s %6s %6s %6s  %s\"\n    attrs = ['pid', 'memory_percent', 'name', 'cmdline', 'cpu_times',\n             'create_time', 'memory_info', 'status', 'nice', 'username']\n    print(templ % (\"USER\", \"PID\", \"%MEM\", \"VSZ\", \"RSS\", \"NICE\",\n                   \"STATUS\", \"START\", \"TIME\", \"CMDLINE\"))\n    # fmt: on\n    for p in psutil.process_iter(attrs, ad_value=None):\n        if p.info['create_time']:\n            ctime = datetime.datetime.fromtimestamp(p.info['create_time'])\n            if ctime.date() == today_day:\n                ctime = ctime.strftime(\"%H:%M\")\n            else:\n                ctime = ctime.strftime(\"%b%d\")\n        else:\n            ctime = ''\n        if p.info['cpu_times']:\n            cputime = time.strftime(\n                \"%M:%S\", time.localtime(sum(p.info['cpu_times']))\n            )\n        else:\n            cputime = ''\n\n        user = p.info['username']\n        if not user and psutil.POSIX:\n            try:\n                user = p.uids()[0]\n            except psutil.Error:\n                pass\n        if user and psutil.WINDOWS and '\\\\' in user:\n            user = user.split('\\\\')[1]\n        if not user:\n            user = ''\n        user = user[:9]\n        vms = (\n            bytes2human(p.info['memory_info'].vms)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        rss = (\n            bytes2human(p.info['memory_info'].rss)\n            if p.info['memory_info'] is not None\n            else ''\n        )\n        memp = (\n            round(p.info['memory_percent'], 1)\n            if p.info['memory_percent'] is not None\n            else ''\n        )\n        nice = int(p.info['nice']) if p.info['nice'] else ''\n        if p.info['cmdline']:\n            cmdline = ' '.join(p.info['cmdline'])\n        else:\n            cmdline = p.info['name']\n        status = p.info['status'][:5] if p.info['status'] else ''\n\n        line = templ % (\n            user,\n            p.info['pid'],\n            memp,\n            vms,\n            rss,\n            nice,\n            status,\n            ctime,\n            cputime,\n            cmdline,\n        )\n        print(line[: get_terminal_size()[0]])\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/killall.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Kill a process by name.\"\"\"\n\nimport os\nimport sys\n\nimport psutil\n\n\ndef main():\n    if len(sys.argv) != 2:\n        sys.exit('usage: %s name' % __file__)\n    else:\n        name = sys.argv[1]\n\n    killed = []\n    for proc in psutil.process_iter():\n        if proc.name() == name and proc.pid != os.getpid():\n            proc.kill()\n            killed.append(proc.pid)\n    if not killed:\n        sys.exit('%s: no process found' % name)\n    else:\n        sys.exit(0)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_api_speed.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Benchmark all API calls and print them from fastest to slowest.\n\n$ make print_api_speed\nSYSTEM APIS                NUM CALLS      SECONDS\n-------------------------------------------------\ndisk_usage                       300      0.00157\ncpu_count                        300      0.00255\npid_exists                       300      0.00792\ncpu_times                        300      0.01044\nboot_time                        300      0.01136\ncpu_percent                      300      0.01290\ncpu_times_percent                300      0.01515\nvirtual_memory                   300      0.01594\nusers                            300      0.01964\nnet_io_counters                  300      0.02027\ncpu_stats                        300      0.02034\nnet_if_addrs                     300      0.02962\nswap_memory                      300      0.03209\nsensors_battery                  300      0.05186\npids                             300      0.07954\nnet_if_stats                     300      0.09321\ndisk_io_counters                 300      0.09406\ncpu_count (cores)                300      0.10293\ndisk_partitions                  300      0.10345\ncpu_freq                         300      0.20817\nsensors_fans                     300      0.63476\nsensors_temperatures             231      2.00039\nprocess_iter (all)               171      2.01300\nnet_connections                   97      2.00206\n\nPROCESS APIS               NUM CALLS      SECONDS\n-------------------------------------------------\ncreate_time                      300      0.00009\nexe                              300      0.00015\nnice                             300      0.00057\nionice                           300      0.00091\ncpu_affinity                     300      0.00091\ncwd                              300      0.00151\nnum_fds                          300      0.00391\nmemory_info                      300      0.00597\nmemory_percent                   300      0.00648\nio_counters                      300      0.00707\nname                             300      0.00894\nstatus                           300      0.00900\nppid                             300      0.00906\nnum_threads                      300      0.00932\ncpu_num                          300      0.00933\nnum_ctx_switches                 300      0.00943\nuids                             300      0.00979\ngids                             300      0.01002\ncpu_times                        300      0.01008\ncmdline                          300      0.01009\nterminal                         300      0.01059\nis_running                       300      0.01063\nthreads                          300      0.01209\nconnections                      300      0.01276\ncpu_percent                      300      0.01463\nopen_files                       300      0.01630\nusername                         300      0.01655\nenviron                          300      0.02250\nmemory_full_info                 300      0.07066\nmemory_maps                      300      0.74281\n\"\"\"\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport argparse\nimport inspect\nimport os\nimport sys\nfrom timeit import default_timer as timer\n\nimport psutil\nfrom psutil._common import print_color\n\n\nTIMES = 300\ntimings = []\ntempl = \"%-25s %10s   %10s\"\n\n\ndef print_header(what):\n    s = templ % (what, \"NUM CALLS\", \"SECONDS\")\n    print_color(s, color=None, bold=True)\n    print(\"-\" * len(s))\n\n\ndef print_timings():\n    timings.sort(key=lambda x: (x[1], -x[2]), reverse=True)\n    i = 0\n    while timings[:]:\n        title, times, elapsed = timings.pop(0)\n        s = templ % (title, str(times), \"%.5f\" % elapsed)\n        if i > len(timings) - 5:\n            print_color(s, color=\"red\")\n        else:\n            print(s)\n\n\ndef timecall(title, fun, *args, **kw):\n    print(\"%-50s\" % title, end=\"\")\n    sys.stdout.flush()\n    t = timer()\n    for n in range(TIMES):\n        fun(*args, **kw)\n        elapsed = timer() - t\n        if elapsed > 2:\n            break\n    print(\"\\r\", end=\"\")\n    sys.stdout.flush()\n    timings.append((title, n + 1, elapsed))\n\n\ndef set_highest_priority():\n    \"\"\"Set highest CPU and I/O priority (requires root).\"\"\"\n    p = psutil.Process()\n    if psutil.WINDOWS:\n        p.nice(psutil.HIGH_PRIORITY_CLASS)\n    else:\n        p.nice(-20)\n\n    if psutil.LINUX:\n        p.ionice(psutil.IOPRIO_CLASS_RT, value=7)\n    elif psutil.WINDOWS:\n        p.ionice(psutil.IOPRIO_HIGH)\n\n\ndef main():\n    global TIMES\n\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawTextHelpFormatter\n    )\n    parser.add_argument('-t', '--times', type=int, default=TIMES)\n    args = parser.parse_args()\n    TIMES = args.times\n    assert TIMES > 1, TIMES\n\n    try:\n        set_highest_priority()\n    except psutil.AccessDenied:\n        prio_set = False\n    else:\n        prio_set = True\n\n    # --- system\n\n    public_apis = []\n    ignore = [\n        'wait_procs',\n        'process_iter',\n        'win_service_get',\n        'win_service_iter',\n    ]\n    if psutil.MACOS:\n        ignore.append('net_connections')  # raises AD\n    for name in psutil.__all__:\n        obj = getattr(psutil, name, None)\n        if inspect.isfunction(obj):\n            if name not in ignore:\n                public_apis.append(name)\n\n    print_header(\"SYSTEM APIS\")\n    for name in public_apis:\n        fun = getattr(psutil, name)\n        args = ()\n        if name == 'pid_exists':\n            args = (os.getpid(),)\n        elif name == 'disk_usage':\n            args = (os.getcwd(),)\n        timecall(name, fun, *args)\n    timecall('cpu_count (cores)', psutil.cpu_count, logical=False)\n    timecall('process_iter (all)', lambda: list(psutil.process_iter()))\n    print_timings()\n\n    # --- process\n    print()\n    print_header(\"PROCESS APIS\")\n    ignore = [\n        'send_signal',\n        'suspend',\n        'resume',\n        'terminate',\n        'kill',\n        'wait',\n        'as_dict',\n        'parent',\n        'parents',\n        'memory_info_ex',\n        'oneshot',\n        'pid',\n        'rlimit',\n        'children',\n    ]\n    if psutil.MACOS:\n        ignore.append('memory_maps')  # XXX\n    p = psutil.Process()\n    for name in sorted(dir(p)):\n        if not name.startswith('_') and name not in ignore:\n            fun = getattr(p, name)\n            timecall(name, fun)\n    print_timings()\n\n    if not prio_set:\n        msg = \"\\nWARN: couldn't set highest process priority \"\n        msg += \"(requires root)\"\n        print_color(msg, \"red\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/bench_oneshot.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A simple micro benchmark script which prints the speedup when using\nProcess.oneshot() ctx manager.\nSee: https://github.com/giampaolo/psutil/issues/799.\n\"\"\"\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport sys\nimport textwrap\nimport timeit\n\nimport psutil\n\n\nITERATIONS = 1000\n\n# The list of Process methods which gets collected in one shot and\n# as such get advantage of the speedup.\nnames = [\n    'cpu_times',\n    'cpu_percent',\n    'memory_info',\n    'memory_percent',\n    'ppid',\n    'parent',\n]\n\nif psutil.POSIX:\n    names.append('uids')\n    names.append('username')\n\nif psutil.LINUX:\n    names += [\n        # 'memory_full_info',\n        # 'memory_maps',\n        'cpu_num',\n        'cpu_times',\n        'gids',\n        'name',\n        'num_ctx_switches',\n        'num_threads',\n        'ppid',\n        'status',\n        'terminal',\n        'uids',\n    ]\nelif psutil.BSD:\n    names = [\n        'cpu_times',\n        'gids',\n        'io_counters',\n        'memory_full_info',\n        'memory_info',\n        'name',\n        'num_ctx_switches',\n        'ppid',\n        'status',\n        'terminal',\n        'uids',\n    ]\n    if psutil.FREEBSD:\n        names.append('cpu_num')\nelif psutil.SUNOS:\n    names += [\n        'cmdline',\n        'gids',\n        'memory_full_info',\n        'memory_info',\n        'name',\n        'num_threads',\n        'ppid',\n        'status',\n        'terminal',\n        'uids',\n    ]\nelif psutil.MACOS:\n    names += [\n        'cpu_times',\n        'create_time',\n        'gids',\n        'memory_info',\n        'name',\n        'num_ctx_switches',\n        'num_threads',\n        'ppid',\n        'terminal',\n        'uids',\n    ]\nelif psutil.WINDOWS:\n    names += [\n        'num_ctx_switches',\n        'num_threads',\n        # dual implementation, called in case of AccessDenied\n        'num_handles',\n        'cpu_times',\n        'create_time',\n        'num_threads',\n        'io_counters',\n        'memory_info',\n    ]\n\nnames = sorted(set(names))\n\nsetup = textwrap.dedent(\"\"\"\n    from __main__ import names\n    import psutil\n\n    def call_normal(funs):\n        for fun in funs:\n            fun()\n\n    def call_oneshot(funs):\n        with p.oneshot():\n            for fun in funs:\n                fun()\n\n    p = psutil.Process()\n    funs = [getattr(p, n) for n in names]\n    \"\"\")\n\n\ndef main():\n    print(\n        \"%s methods involved on platform %r (%s iterations, psutil %s):\"\n        % (len(names), sys.platform, ITERATIONS, psutil.__version__)\n    )\n    for name in sorted(names):\n        print(\"    \" + name)\n\n    # \"normal\" run\n    elapsed1 = timeit.timeit(\n        \"call_normal(funs)\", setup=setup, number=ITERATIONS\n    )\n    print(\"normal:  %.3f secs\" % elapsed1)\n\n    # \"one shot\" run\n    elapsed2 = timeit.timeit(\n        \"call_oneshot(funs)\", setup=setup, number=ITERATIONS\n    )\n    print(\"onshot:  %.3f secs\" % elapsed2)\n\n    # done\n    if elapsed2 < elapsed1:\n        print(\"speedup: +%.2fx\" % (elapsed1 / elapsed2))\n    elif elapsed2 > elapsed1:\n        print(\"slowdown: -%.2fx\" % (elapsed2 / elapsed1))\n    else:\n        print(\"same speed\")\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/download_wheels_appveyor.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Script which downloads wheel files hosted on AppVeyor:\nhttps://ci.appveyor.com/project/giampaolo/psutil\nRe-adapted from the original recipe of Ibarra Corretge'\n<saghul@gmail.com>:\nhttp://code.saghul.net/index.php/2015/09/09/.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport concurrent.futures\nimport os\nimport sys\n\nimport requests\n\nfrom psutil import __version__\nfrom psutil._common import bytes2human\nfrom psutil._common import print_color\n\n\nUSER = \"giampaolo\"\nPROJECT = \"psutil\"\nPROJECT_VERSION = __version__\nBASE_URL = 'https://ci.appveyor.com/api'\nPY_VERSIONS = ['2.7']\nTIMEOUT = 30\n\n\ndef download_file(url):\n    local_fname = url.split('/')[-1]\n    local_fname = os.path.join('dist', local_fname)\n    os.makedirs('dist', exist_ok=True)\n    r = requests.get(url, stream=True, timeout=TIMEOUT)\n    tot_bytes = 0\n    with open(local_fname, 'wb') as f:\n        for chunk in r.iter_content(chunk_size=16384):\n            if chunk:  # filter out keep-alive new chunks\n                f.write(chunk)\n                tot_bytes += len(chunk)\n    return local_fname\n\n\ndef get_file_urls():\n    with requests.Session() as session:\n        data = session.get(\n            BASE_URL + '/projects/' + USER + '/' + PROJECT, timeout=TIMEOUT\n        )\n        data = data.json()\n\n        urls = []\n        for job in (job['jobId'] for job in data['build']['jobs']):\n            job_url = BASE_URL + '/buildjobs/' + job + '/artifacts'\n            data = session.get(job_url, timeout=TIMEOUT)\n            data = data.json()\n            for item in data:\n                file_url = job_url + '/' + item['fileName']\n                urls.append(file_url)\n        if not urls:\n            print_color(\"no artifacts found\", 'red')\n            sys.exit(1)\n        else:\n            for url in sorted(urls, key=os.path.basename):\n                yield url\n\n\ndef rename_win27_wheels():\n    # See: https://github.com/giampaolo/psutil/issues/810\n    src = 'dist/psutil-%s-cp27-cp27m-win32.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win32.whl' % PROJECT_VERSION\n    print(\"rename: %s\\n        %s\" % (src, dst))\n    os.rename(src, dst)\n    src = 'dist/psutil-%s-cp27-cp27m-win_amd64.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win_amd64.whl' % PROJECT_VERSION\n    print(\"rename: %s\\n        %s\" % (src, dst))\n    os.rename(src, dst)\n\n\ndef run():\n    urls = get_file_urls()\n    completed = 0\n    exc = None\n    with concurrent.futures.ThreadPoolExecutor() as e:\n        fut_to_url = {e.submit(download_file, url): url for url in urls}\n        for fut in concurrent.futures.as_completed(fut_to_url):\n            url = fut_to_url[fut]\n            try:\n                local_fname = fut.result()\n            except Exception:\n                print_color(\"error while downloading %s\" % (url), 'red')\n                raise\n            else:\n                completed += 1\n                print(\n                    \"downloaded %-45s %s\"\n                    % (local_fname, bytes2human(os.path.getsize(local_fname)))\n                )\n    # 2 wheels (32 and 64 bit) per supported python version\n    expected = len(PY_VERSIONS) * 2\n    if expected != completed:\n        return sys.exit(\"expected %s files, got %s\" % (expected, completed))\n    if exc:\n        return sys.exit()\n    rename_win27_wheels()\n\n\ndef main():\n    run()\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/download_wheels_github.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Script which downloads wheel files hosted on GitHub:\nhttps://github.com/giampaolo/psutil/actions\nIt needs an access token string generated from personal GitHub profile:\nhttps://github.com/settings/tokens\nThe token must be created with at least \"public_repo\" scope/rights.\nIf you lose it, just generate a new token.\nREST API doc:\nhttps://developer.github.com/v3/actions/artifacts/.\n\"\"\"\n\nimport argparse\nimport json\nimport os\nimport sys\nimport zipfile\n\nimport requests\n\nfrom psutil import __version__\nfrom psutil._common import bytes2human\nfrom psutil.tests import safe_rmpath\n\n\nUSER = \"giampaolo\"\nPROJECT = \"psutil\"\nPROJECT_VERSION = __version__\nOUTFILE = \"wheels-github.zip\"\nTOKEN = \"\"\nTIMEOUT = 30\n\n\ndef get_artifacts():\n    base_url = \"https://api.github.com/repos/%s/%s\" % (USER, PROJECT)\n    url = base_url + \"/actions/artifacts\"\n    res = requests.get(\n        url=url, headers={\"Authorization\": \"token %s\" % TOKEN}, timeout=TIMEOUT\n    )\n    res.raise_for_status()\n    data = json.loads(res.content)\n    return data\n\n\ndef download_zip(url):\n    print(\"downloading: \" + url)\n    res = requests.get(\n        url=url, headers={\"Authorization\": \"token %s\" % TOKEN}, timeout=TIMEOUT\n    )\n    res.raise_for_status()\n    totbytes = 0\n    with open(OUTFILE, 'wb') as f:\n        for chunk in res.iter_content(chunk_size=16384):\n            f.write(chunk)\n            totbytes += len(chunk)\n    print(\"got %s, size %s)\" % (OUTFILE, bytes2human(totbytes)))\n\n\ndef rename_win27_wheels():\n    # See: https://github.com/giampaolo/psutil/issues/810\n    src = 'dist/psutil-%s-cp27-cp27m-win32.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win32.whl' % PROJECT_VERSION\n    if os.path.exists(src):\n        print(\"rename: %s\\n        %s\" % (src, dst))\n        os.rename(src, dst)\n    src = 'dist/psutil-%s-cp27-cp27m-win_amd64.whl' % PROJECT_VERSION\n    dst = 'dist/psutil-%s-cp27-none-win_amd64.whl' % PROJECT_VERSION\n    if os.path.exists(src):\n        print(\"rename: %s\\n        %s\" % (src, dst))\n        os.rename(src, dst)\n\n\ndef run():\n    data = get_artifacts()\n    download_zip(data['artifacts'][0]['archive_download_url'])\n    os.makedirs('dist', exist_ok=True)\n    with zipfile.ZipFile(OUTFILE, 'r') as zf:\n        zf.extractall('dist')\n    rename_win27_wheels()\n\n\ndef main():\n    global TOKEN\n    parser = argparse.ArgumentParser(description='GitHub wheels downloader')\n    parser.add_argument('--token')\n    parser.add_argument('--tokenfile')\n    args = parser.parse_args()\n\n    if args.tokenfile:\n        with open(os.path.expanduser(args.tokenfile)) as f:\n            TOKEN = f.read().strip()\n    elif args.token:\n        TOKEN = args.token\n    else:\n        return sys.exit('specify --token or --tokenfile args')\n\n    try:\n        run()\n    finally:\n        safe_rmpath(OUTFILE)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/clinter.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"A super simple linter to check C syntax.\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport sys\n\n\nwarned = False\n\n\ndef warn(path, line, lineno, msg):\n    global warned\n    warned = True\n    print(\"%s:%s: %s\" % (path, lineno, msg), file=sys.stderr)\n\n\ndef check_line(path, line, idx, lines):\n    s = line\n    lineno = idx + 1\n    eof = lineno == len(lines)\n    if s.endswith(' \\n'):\n        warn(path, line, lineno, \"extra space at EOL\")\n    elif '\\t' in line:\n        warn(path, line, lineno, \"line has a tab\")\n    elif s.endswith('\\r\\n'):\n        warn(path, line, lineno, \"Windows line ending\")\n    # end of global block, e.g. \"}newfunction...\":\n    elif s == \"}\\n\":\n        if not eof:\n            nextline = lines[idx + 1]\n            # \"#\" is a pre-processor line\n            if (\n                nextline != '\\n'\n                and nextline.strip()[0] != '#'\n                and nextline.strip()[:2] != '*/'\n            ):\n                warn(path, line, lineno, \"expected 1 blank line\")\n\n    sls = s.lstrip()\n    if sls.startswith('//') and sls[2] != ' ' and line.strip() != '//':\n        warn(path, line, lineno, \"no space after // comment\")\n    # e.g. \"if(...\" after keywords\n    keywords = (\"if\", \"else\", \"while\", \"do\", \"enum\", \"for\")\n    for kw in keywords:\n        if sls.startswith(kw + '('):\n            warn(path, line, lineno, \"missing space between %r and '('\" % kw)\n    # eof\n    if eof and not line.endswith('\\n'):\n        warn(path, line, lineno, \"no blank line at EOF\")\n\n    ss = s.strip()\n    if ss.startswith((\"printf(\", \"printf (\")):\n        if not ss.endswith((\"// NOQA\", \"//  NOQA\")):\n            warn(path, line, lineno, \"printf() statement\")\n\n\ndef process(path):\n    with open(path) as f:\n        lines = f.readlines()\n    for idx, line in enumerate(lines):\n        check_line(path, line, idx, lines)\n\n\ndef main():\n    parser = argparse.ArgumentParser()\n    parser.add_argument('paths', nargs='+', help='path(s) to a file(s)')\n    args = parser.parse_args()\n    for path in args.paths:\n        process(path)\n    if warned:\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/check_broken_links.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola', Himanshu Shekhar.\n# All rights reserved. Use of this source code is governed by a\n# BSD-style license that can be found in the LICENSE file.\n\n\"\"\"Checks for broken links in file names specified as command line\nparameters.\n\nThere are a ton of a solutions available for validating URLs in string\nusing regex, but less for searching, of which very few are accurate.\nThis snippet is intended to just do the required work, and avoid\ncomplexities. Django Validator has pretty good regex for validation,\nbut we have to find urls instead of validating them (REFERENCES [7]).\nThere's always room for improvement.\n\nMethod:\n* Match URLs using regex (REFERENCES [1]])\n* Some URLs need to be fixed, as they have < (or) > due to inefficient\n  regex.\n* Remove duplicates (because regex is not 100% efficient as of now).\n* Check validity of URL, using HEAD request. (HEAD to save bandwidth)\n  Uses requests module for others are painful to use. REFERENCES[9]\n  Handles redirects, http, https, ftp as well.\n\nREFERENCES:\nUsing [1] with some modifications for including ftp\n[1] http://stackoverflow.com/a/6883094/5163807\n[2] http://stackoverflow.com/a/31952097/5163807\n[3] http://daringfireball.net/2010/07/improved_regex_for_matching_urls\n[4] https://mathiasbynens.be/demo/url-regex\n[5] https://github.com/django/django/blob/master/django/core/validators.py\n[6] https://data.iana.org/TLD/tlds-alpha-by-domain.txt\n[7] https://codereview.stackexchange.com/questions/19663/http-url-validating\n[8] https://developer.mozilla.org/en-US/docs/Web/HTTP/Methods/HEAD\n[9] http://docs.python-requests.org/\n\nAuthor: Himanshu Shekhar <https://github.com/himanshub16> (2017)\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport concurrent.futures\nimport functools\nimport os\nimport re\nimport sys\nimport traceback\n\nimport requests\n\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nREGEX = re.compile(\n    r'(?:http|ftp|https)?://'\n    r'(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+'\n)\nREQUEST_TIMEOUT = 15\n# There are some status codes sent by websites on HEAD request.\n# Like 503 by Microsoft, and 401 by Apple\n# They need to be sent GET request\nRETRY_STATUSES = [503, 401, 403]\n\n\ndef memoize(fun):\n    \"\"\"A memoize decorator.\"\"\"\n\n    @functools.wraps(fun)\n    def wrapper(*args, **kwargs):\n        key = (args, frozenset(sorted(kwargs.items())))\n        try:\n            return cache[key]\n        except KeyError:\n            ret = cache[key] = fun(*args, **kwargs)\n            return ret\n\n    cache = {}\n    return wrapper\n\n\ndef sanitize_url(url):\n    url = url.rstrip(',')\n    url = url.rstrip('.')\n    url = url.lstrip('(')\n    url = url.rstrip(')')\n    url = url.lstrip('[')\n    url = url.rstrip(']')\n    url = url.lstrip('<')\n    url = url.rstrip('>')\n    return url\n\n\ndef find_urls(s):\n    matches = REGEX.findall(s) or []\n    return list(set([sanitize_url(x) for x in matches]))\n\n\ndef parse_rst(fname):\n    \"\"\"Look for links in a .rst file.\"\"\"\n    with open(fname) as f:\n        text = f.read()\n    urls = find_urls(text)\n    # HISTORY file has a lot of dead links.\n    if fname == 'HISTORY.rst' and urls:\n        urls = [\n            x\n            for x in urls\n            if not x.startswith('https://github.com/giampaolo/psutil/issues')\n        ]\n    return urls\n\n\ndef parse_py(fname):\n    \"\"\"Look for links in a .py file.\"\"\"\n    with open(fname) as f:\n        lines = f.readlines()\n    urls = set()\n    for i, line in enumerate(lines):\n        for url in find_urls(line):\n            # comment block\n            if line.lstrip().startswith('# '):\n                subidx = i + 1\n                while True:\n                    nextline = lines[subidx].strip()\n                    if re.match('^#     .+', nextline):\n                        url += nextline[1:].strip()\n                    else:\n                        break\n                    subidx += 1\n            urls.add(url)\n    return list(urls)\n\n\ndef parse_c(fname):\n    \"\"\"Look for links in a .py file.\"\"\"\n    with open(fname) as f:\n        lines = f.readlines()\n    urls = set()\n    for i, line in enumerate(lines):\n        for url in find_urls(line):\n            # comment block //\n            if line.lstrip().startswith('// '):\n                subidx = i + 1\n                while True:\n                    nextline = lines[subidx].strip()\n                    if re.match('^//     .+', nextline):\n                        url += nextline[2:].strip()\n                    else:\n                        break\n                    subidx += 1\n            # comment block /*\n            elif line.lstrip().startswith('* '):\n                subidx = i + 1\n                while True:\n                    nextline = lines[subidx].strip()\n                    if re.match(r'^\\*     .+', nextline):\n                        url += nextline[1:].strip()\n                    else:\n                        break\n                    subidx += 1\n            urls.add(url)\n    return list(urls)\n\n\ndef parse_generic(fname):\n    with open(fname, errors='ignore') as f:\n        text = f.read()\n    return find_urls(text)\n\n\ndef get_urls(fname):\n    \"\"\"Extracts all URLs in fname and return them as a list.\"\"\"\n    if fname.endswith('.rst'):\n        return parse_rst(fname)\n    elif fname.endswith('.py'):\n        return parse_py(fname)\n    elif fname.endswith(('.c', '.h')):\n        return parse_c(fname)\n    else:\n        with open(fname, errors='ignore') as f:\n            if f.readline().strip().startswith('#!/usr/bin/env python3'):\n                return parse_py(fname)\n        return parse_generic(fname)\n\n\n@memoize\ndef validate_url(url):\n    \"\"\"Validate the URL by attempting an HTTP connection.\n    Makes an HTTP-HEAD request for each URL.\n    \"\"\"\n    try:\n        res = requests.head(url, timeout=REQUEST_TIMEOUT)\n        # some websites deny 503, like Microsoft\n        # and some send 401, like Apple, observations\n        if (not res.ok) and (res.status_code in RETRY_STATUSES):\n            res = requests.get(url, timeout=REQUEST_TIMEOUT)\n        return res.ok\n    except requests.exceptions.RequestException:\n        return False\n\n\ndef parallel_validator(urls):\n    \"\"\"Validates all urls in parallel\n    urls: tuple(filename, url).\n    \"\"\"\n    fails = []  # list of tuples (filename, url)\n    current = 0\n    total = len(urls)\n    with concurrent.futures.ThreadPoolExecutor() as executor:\n        fut_to_url = {\n            executor.submit(validate_url, url[1]): url for url in urls\n        }\n        for fut in concurrent.futures.as_completed(fut_to_url):\n            current += 1\n            sys.stdout.write(\"\\r%s / %s\" % (current, total))\n            sys.stdout.flush()\n            fname, url = fut_to_url[fut]\n            try:\n                ok = fut.result()\n            except Exception:  # noqa: BLE001\n                fails.append((fname, url))\n                print()\n                print(\"warn: error while validating %s\" % url, file=sys.stderr)\n                traceback.print_exc()\n            else:\n                if not ok:\n                    fails.append((fname, url))\n\n    print()\n    return fails\n\n\ndef main():\n    parser = argparse.ArgumentParser(\n        description=__doc__, formatter_class=argparse.RawTextHelpFormatter\n    )\n    parser.add_argument('files', nargs=\"+\")\n    parser.parse_args()\n    args = parser.parse_args()\n\n    all_urls = []\n    for fname in args.files:\n        urls = get_urls(fname)\n        if urls:\n            print(\"%4s %s\" % (len(urls), fname))\n            for url in urls:\n                all_urls.append((fname, url))\n\n    fails = parallel_validator(all_urls)\n    if not fails:\n        print(\"all links are valid; cheers!\")\n    else:\n        for fail in fails:\n            fname, url = fail\n            print(\"%-30s: %s \" % (fname, url))\n        print('-' * 20)\n        print(\"total: %s fails!\" % len(fails))\n        sys.exit(1)\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    except (KeyboardInterrupt, SystemExit):\n        os._exit(0)\n", "scripts/internal/git_pre_commit.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"This gets executed on 'git commit' and rejects the commit in case\nthe submitted code does not pass validation. Validation is run only\nagainst the files which were modified in the commit. Install this with\n\"make install-git-hooks\".\n\"\"\"\n\nfrom __future__ import print_function\n\nimport os\nimport shlex\nimport subprocess\nimport sys\n\n\nPYTHON = sys.executable\nPY3 = sys.version_info[0] >= 3\nTHIS_SCRIPT = os.path.realpath(__file__)\n\n\ndef term_supports_colors():\n    try:\n        import curses\n\n        assert sys.stderr.isatty()\n        curses.setupterm()\n        assert curses.tigetnum(\"colors\") > 0\n    except Exception:  # noqa: BLE001\n        return False\n    return True\n\n\ndef hilite(s, ok=True, bold=False):\n    \"\"\"Return an highlighted version of 'string'.\"\"\"\n    if not term_supports_colors():\n        return s\n    attr = []\n    if ok is None:  # no color\n        pass\n    elif ok:  # green\n        attr.append('32')\n    else:  # red\n        attr.append('31')\n    if bold:\n        attr.append('1')\n    return '\\x1b[%sm%s\\x1b[0m' % (';'.join(attr), s)\n\n\ndef exit(msg):\n    print(hilite(\"commit aborted: \" + msg, ok=False), file=sys.stderr)\n    sys.exit(1)\n\n\ndef sh(cmd):\n    if isinstance(cmd, str):\n        cmd = shlex.split(cmd)\n    p = subprocess.Popen(\n        cmd,\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    if stderr:\n        print(stderr, file=sys.stderr)\n    if stdout.endswith('\\n'):\n        stdout = stdout[:-1]\n    return stdout\n\n\ndef open_text(path):\n    kw = {'encoding': 'utf8'} if PY3 else {}\n    return open(path, **kw)\n\n\ndef git_commit_files():\n    out = sh([\"git\", \"diff\", \"--cached\", \"--name-only\"])\n    py_files = [\n        x for x in out.split('\\n') if x.endswith('.py') and os.path.exists(x)\n    ]\n    c_files = [\n        x\n        for x in out.split('\\n')\n        if x.endswith(('.c', '.h')) and os.path.exists(x)\n    ]\n    rst_files = [\n        x for x in out.split('\\n') if x.endswith('.rst') and os.path.exists(x)\n    ]\n    toml_files = [\n        x for x in out.split(\"\\n\") if x.endswith(\".toml\") and os.path.exists(x)\n    ]\n    new_rm_mv = sh(\n        [\"git\", \"diff\", \"--name-only\", \"--diff-filter=ADR\", \"--cached\"]\n    )\n    # XXX: we should escape spaces and possibly other amenities here\n    new_rm_mv = new_rm_mv.split()\n    return (py_files, c_files, rst_files, toml_files, new_rm_mv)\n\n\ndef black(files):\n    print(\"running black (%s)\" % len(files))\n    cmd = [PYTHON, \"-m\", \"black\", \"--check\", \"--safe\"] + files\n    if subprocess.call(cmd) != 0:\n        return exit(\n            \"Python code didn't pass 'ruff' style check.\"\n            \"Try running 'make fix-ruff'.\"\n        )\n\n\ndef ruff(files):\n    print(\"running ruff (%s)\" % len(files))\n    cmd = [PYTHON, \"-m\", \"ruff\", \"check\", \"--no-cache\"] + files\n    if subprocess.call(cmd) != 0:\n        return exit(\n            \"Python code didn't pass 'ruff' style check.\"\n            \"Try running 'make fix-ruff'.\"\n        )\n\n\ndef c_linter(files):\n    print(\"running clinter (%s)\" % len(files))\n    # XXX: we should escape spaces and possibly other amenities here\n    cmd = [PYTHON, \"scripts/internal/clinter.py\"] + files\n    if subprocess.call(cmd) != 0:\n        return sys.exit(\"C code didn't pass style check\")\n\n\ndef toml_sort(files):\n    print(\"running toml linter (%s)\" % len(files))\n    cmd = [\"toml-sort\", \"--check\"] + files\n    if subprocess.call(cmd) != 0:\n        return sys.exit(\"%s didn't pass style check\" % ' '.join(files))\n\n\ndef rstcheck(files):\n    print(\"running rst linter (%s)\" % len(files))\n    cmd = [\"rstcheck\", \"--config=pyproject.toml\"] + files\n    if subprocess.call(cmd) != 0:\n        return sys.exit(\"RST code didn't pass style check\")\n\n\ndef main():\n    py_files, c_files, rst_files, toml_files, new_rm_mv = git_commit_files()\n    if py_files:\n        black(py_files)\n        ruff(py_files)\n    if c_files:\n        c_linter(c_files)\n    if rst_files:\n        rstcheck(rst_files)\n    if toml_files:\n        toml_sort(toml_files)\n    if new_rm_mv:\n        out = sh([PYTHON, \"scripts/internal/generate_manifest.py\"])\n        with open_text('MANIFEST.in') as f:\n            if out.strip() != f.read().strip():\n                sys.exit(\n                    \"some files were added, deleted or renamed; \"\n                    \"run 'make generate-manifest' and commit again\"\n                )\n\n\nmain()\n", "scripts/internal/print_hashes.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Prints files hashes, see:\nhttps://pip.pypa.io/en/stable/reference/pip_install/#hash-checking-mode.\n\"\"\"\n\nimport argparse\nimport hashlib\nimport os\n\n\ndef csum(file, kind):\n    h = hashlib.new(kind)\n    with open(file, \"rb\") as f:\n        h.update(f.read())\n        return h.hexdigest()\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        'dir', type=str, help='directory containing tar.gz or wheel files'\n    )\n    args = parser.parse_args()\n    for name in sorted(os.listdir(args.dir)):\n        file = os.path.join(args.dir, name)\n        if os.path.isfile(file):\n            md5 = csum(file, \"md5\")\n            sha256 = csum(file, \"sha256\")\n            print(\n                \"%s\\nmd5: %s\\nsha256: %s\\n\"\n                % (os.path.basename(file), md5, sha256)\n            )\n        else:\n            print(\"skipping %r (not a file)\" % file)\n\n\nif __name__ == \"__main__\":\n    main()\n", "scripts/internal/convert_readme.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Remove raw HTML from README.rst to make it compatible with PyPI on\ndist upload.\n\"\"\"\n\nimport argparse\nimport re\n\n\nsummary = \"\"\"\\\nQuick links\n===========\n\n- `Home page <https://github.com/giampaolo/psutil>`_\n- `Install <https://github.com/giampaolo/psutil/blob/master/INSTALL.rst>`_\n- `Documentation <http://psutil.readthedocs.io>`_\n- `Download <https://pypi.org/project/psutil/#files>`_\n- `Forum <http://groups.google.com/group/psutil/topics>`_\n- `StackOverflow <https://stackoverflow.com/questions/tagged/psutil>`_\n- `Blog <https://gmpy.dev/tags/psutil>`_\n- `What's new <https://github.com/giampaolo/psutil/blob/master/HISTORY.rst>`_\n\"\"\"\n\nfunding = \"\"\"\\\nSponsors\n========\n\n.. image:: https://github.com/giampaolo/psutil/raw/master/docs/_static/tidelift-logo.png\n  :width: 200\n  :alt: Alternative text\n\n`Add your logo <https://github.com/sponsors/giampaolo>`__.\n\nExample usages\"\"\"  # noqa\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument('file', type=str)\n    args = parser.parse_args()\n    with open(args.file) as f:\n        data = f.read()\n    data = re.sub(r\".. raw:: html\\n+\\s+<div align[\\s\\S]*?/div>\", summary, data)\n    data = re.sub(r\"Sponsors\\n========[\\s\\S]*?Example usages\", funding, data)\n    print(data)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/generate_manifest.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Generate MANIFEST.in file.\"\"\"\n\nimport os\nimport shlex\nimport subprocess\n\n\nSKIP_EXTS = ('.png', '.jpg', '.jpeg', '.svg')\nSKIP_FILES = 'appveyor.yml'\nSKIP_PREFIXES = ('.ci/', '.github/')\n\n\ndef sh(cmd):\n    return subprocess.check_output(\n        shlex.split(cmd), universal_newlines=True\n    ).strip()\n\n\ndef main():\n    files = set()\n    for file in sh(\"git ls-files\").split('\\n'):\n        if (\n            file.startswith(SKIP_PREFIXES)\n            or os.path.splitext(file)[1].lower() in SKIP_EXTS\n            or file in SKIP_FILES\n        ):\n            continue\n        files.add(file)\n\n    for file in sorted(files):\n        print(\"include \" + file)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/purge_installation.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Purge psutil installation by removing psutil-related files and\ndirectories found in site-packages directories. This is needed mainly\nbecause sometimes \"import psutil\" imports a leftover installation\nfrom site-packages directory instead of the main working directory.\n\"\"\"\n\nimport os\nimport shutil\nimport site\n\n\nPKGNAME = \"psutil\"\n\n\ndef rmpath(path):\n    if os.path.isdir(path):\n        print(\"rmdir \" + path)\n        shutil.rmtree(path)\n    else:\n        print(\"rm \" + path)\n        os.remove(path)\n\n\ndef main():\n    locations = [site.getusersitepackages()]\n    locations += site.getsitepackages()\n    for root in locations:\n        if os.path.isdir(root):\n            for name in os.listdir(root):\n                if PKGNAME in name:\n                    abspath = os.path.join(root, name)\n                    rmpath(abspath)\n\n\nmain()\n", "scripts/internal/print_dist.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"List and pretty print tarball & wheel files in the dist/ directory.\"\"\"\n\nimport argparse\nimport collections\nimport os\n\nfrom psutil._common import bytes2human\nfrom psutil._common import print_color\n\n\nclass Wheel:\n    def __init__(self, path):\n        self._path = path\n        self._name = os.path.basename(path)\n\n    def __repr__(self):\n        return \"<%s(name=%s, plat=%s, arch=%s, pyver=%s)>\" % (\n            self.__class__.__name__,\n            self.name,\n            self.platform(),\n            self.arch(),\n            self.pyver(),\n        )\n\n    __str__ = __repr__\n\n    @property\n    def name(self):\n        return self._name\n\n    def platform(self):\n        plat = self.name.split('-')[-1]\n        pyimpl = self.name.split('-')[3]\n        ispypy = 'pypy' in pyimpl\n        if 'linux' in plat:\n            if ispypy:\n                return 'pypy_on_linux'\n            else:\n                return 'linux'\n        elif 'win' in plat:\n            if ispypy:\n                return 'pypy_on_windows'\n            else:\n                return 'windows'\n        elif 'macosx' in plat:\n            if ispypy:\n                return 'pypy_on_macos'\n            else:\n                return 'macos'\n        else:\n            raise ValueError(\"unknown platform %r\" % self.name)\n\n    def arch(self):\n        if self.name.endswith(('x86_64.whl', 'amd64.whl')):\n            return '64-bit'\n        if self.name.endswith((\"i686.whl\", \"win32.whl\")):\n            return '32-bit'\n        if self.name.endswith(\"arm64.whl\"):\n            return 'arm64'\n        if self.name.endswith(\"aarch64.whl\"):\n            return 'aarch64'\n        return '?'\n\n    def pyver(self):\n        pyver = 'pypy' if self.name.split('-')[3].startswith('pypy') else 'py'\n        pyver += self.name.split('-')[2][2:]\n        return pyver\n\n    def size(self):\n        return os.path.getsize(self._path)\n\n\nclass Tarball(Wheel):\n    def platform(self):\n        return \"source\"\n\n    def arch(self):\n        return \"-\"\n\n    def pyver(self):\n        return \"-\"\n\n\ndef main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        'dir',\n        nargs=\"?\",\n        default=\"dist\",\n        help='directory containing tar.gz or wheel files',\n    )\n    args = parser.parse_args()\n\n    groups = collections.defaultdict(list)\n    ls = sorted(os.listdir(args.dir), key=lambda x: x.endswith(\"tar.gz\"))\n    for name in ls:\n        path = os.path.join(args.dir, name)\n        if path.endswith(\".whl\"):\n            pkg = Wheel(path)\n        elif path.endswith(\".tar.gz\"):\n            pkg = Tarball(path)\n        else:\n            raise ValueError(\"invalid package %r\" % path)\n        groups[pkg.platform()].append(pkg)\n\n    tot_files = 0\n    tot_size = 0\n    templ = \"%-120s %7s %8s %7s\"\n    for platf, pkgs in groups.items():\n        ppn = \"%s (%s)\" % (platf, len(pkgs))\n        s = templ % (ppn, \"size\", \"arch\", \"pyver\")\n        print_color('\\n' + s, color=None, bold=True)\n        for pkg in sorted(pkgs, key=lambda x: x.name):\n            tot_files += 1\n            tot_size += pkg.size()\n            s = templ % (\n                \"  \" + pkg.name,\n                bytes2human(pkg.size()),\n                pkg.arch(),\n                pkg.pyver(),\n            )\n            if 'pypy' in pkg.pyver():\n                print_color(s, color='violet')\n            else:\n                print_color(s, color='brown')\n\n    print_color(\n        \"\\n\\ntotals: files=%s, size=%s\" % (tot_files, bytes2human(tot_size)),\n        bold=True,\n    )\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/winmake.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\n\"\"\"Shortcuts for various tasks, emulating UNIX \"make\" on Windows.\nThis is supposed to be invoked by \"make.bat\" and not used directly.\nThis was originally written as a bat file but they suck so much\nthat they should be deemed illegal!\n\"\"\"\n\nfrom __future__ import print_function\n\nimport argparse\nimport atexit\nimport ctypes\nimport errno\nimport fnmatch\nimport os\nimport shutil\nimport site\nimport ssl\nimport subprocess\nimport sys\nimport tempfile\n\n\nAPPVEYOR = bool(os.environ.get('APPVEYOR'))\nPYTHON = sys.executable if APPVEYOR else os.getenv('PYTHON', sys.executable)\nRUNNER_PY = 'psutil\\\\tests\\\\runner.py'\nGET_PIP_URL = \"https://bootstrap.pypa.io/get-pip.py\"\nPY3 = sys.version_info[0] >= 3\nHERE = os.path.abspath(os.path.dirname(__file__))\nROOT_DIR = os.path.realpath(os.path.join(HERE, \"..\", \"..\"))\nPYPY = '__pypy__' in sys.builtin_module_names\nDEPS = [\n    \"coverage\",\n    \"pdbpp\",\n    \"pip\",\n    \"pyperf\",\n    \"pyreadline\",\n    \"requests\",\n    \"setuptools\",\n    \"wheel\",\n]\n\nif sys.version_info[0] < 3:\n    DEPS.append('mock')\n    DEPS.append('ipaddress')\n    DEPS.append('enum34')\n\nif not PYPY:\n    DEPS.append(\"pywin32\")\n    DEPS.append(\"wmi\")\n\n_cmds = {}\nif PY3:\n    basestring = str\n\nGREEN = 2\nLIGHTBLUE = 3\nYELLOW = 6\nRED = 4\nDEFAULT_COLOR = 7\n\n\n# ===================================================================\n# utils\n# ===================================================================\n\n\ndef safe_print(text, file=sys.stdout):\n    \"\"\"Prints a (unicode) string to the console, encoded depending on\n    the stdout/file encoding (eg. cp437 on Windows). This is to avoid\n    encoding errors in case of funky path names.\n    Works with Python 2 and 3.\n    \"\"\"\n    if not isinstance(text, basestring):\n        return print(text, file=file)\n    try:\n        file.write(text)\n    except UnicodeEncodeError:\n        bytes_string = text.encode(file.encoding, 'backslashreplace')\n        if hasattr(file, 'buffer'):\n            file.buffer.write(bytes_string)\n        else:\n            text = bytes_string.decode(file.encoding, 'strict')\n            file.write(text)\n    file.write(\"\\n\")\n\n\ndef stderr_handle():\n    GetStdHandle = ctypes.windll.Kernel32.GetStdHandle\n    STD_ERROR_HANDLE_ID = ctypes.c_ulong(0xFFFFFFF4)\n    GetStdHandle.restype = ctypes.c_ulong\n    handle = GetStdHandle(STD_ERROR_HANDLE_ID)\n    atexit.register(ctypes.windll.Kernel32.CloseHandle, handle)\n    return handle\n\n\ndef win_colorprint(s, color=LIGHTBLUE):\n    color += 8  # bold\n    handle = stderr_handle()\n    SetConsoleTextAttribute = ctypes.windll.Kernel32.SetConsoleTextAttribute\n    SetConsoleTextAttribute(handle, color)\n    try:\n        print(s)\n    finally:\n        SetConsoleTextAttribute(handle, DEFAULT_COLOR)\n\n\ndef sh(cmd, nolog=False):\n    if not nolog:\n        safe_print(\"cmd: \" + cmd)\n    p = subprocess.Popen(\n        cmd, shell=True, env=os.environ, cwd=os.getcwd()  # noqa\n    )\n    p.communicate()\n    if p.returncode != 0:\n        sys.exit(p.returncode)\n\n\ndef rm(pattern, directory=False):\n    \"\"\"Recursively remove a file or dir by pattern.\"\"\"\n\n    def safe_remove(path):\n        try:\n            os.remove(path)\n        except OSError as err:\n            if err.errno != errno.ENOENT:\n                raise\n        else:\n            safe_print(\"rm %s\" % path)\n\n    def safe_rmtree(path):\n        def onerror(fun, path, excinfo):\n            exc = excinfo[1]\n            if exc.errno != errno.ENOENT:\n                raise  # noqa: PLE0704\n\n        existed = os.path.isdir(path)\n        shutil.rmtree(path, onerror=onerror)\n        if existed:\n            safe_print(\"rmdir -f %s\" % path)\n\n    if \"*\" not in pattern:\n        if directory:\n            safe_rmtree(pattern)\n        else:\n            safe_remove(pattern)\n        return\n\n    for root, dirs, files in os.walk('.'):\n        root = os.path.normpath(root)\n        if root.startswith('.git/'):\n            continue\n        found = fnmatch.filter(dirs if directory else files, pattern)\n        for name in found:\n            path = os.path.join(root, name)\n            if directory:\n                safe_print(\"rmdir -f %s\" % path)\n                safe_rmtree(path)\n            else:\n                safe_print(\"rm %s\" % path)\n                safe_remove(path)\n\n\ndef safe_remove(path):\n    try:\n        os.remove(path)\n    except OSError as err:\n        if err.errno != errno.ENOENT:\n            raise\n    else:\n        safe_print(\"rm %s\" % path)\n\n\ndef safe_rmtree(path):\n    def onerror(fun, path, excinfo):\n        exc = excinfo[1]\n        if exc.errno != errno.ENOENT:\n            raise  # noqa: PLE0704\n\n    existed = os.path.isdir(path)\n    shutil.rmtree(path, onerror=onerror)\n    if existed:\n        safe_print(\"rmdir -f %s\" % path)\n\n\ndef recursive_rm(*patterns):\n    \"\"\"Recursively remove a file or matching a list of patterns.\"\"\"\n    for root, dirs, files in os.walk('.'):\n        root = os.path.normpath(root)\n        if root.startswith('.git/'):\n            continue\n        for file in files:\n            for pattern in patterns:\n                if fnmatch.fnmatch(file, pattern):\n                    safe_remove(os.path.join(root, file))\n        for dir in dirs:\n            for pattern in patterns:\n                if fnmatch.fnmatch(dir, pattern):\n                    safe_rmtree(os.path.join(root, dir))\n\n\n# ===================================================================\n# commands\n# ===================================================================\n\n\ndef build():\n    \"\"\"Build / compile.\"\"\"\n    # Make sure setuptools is installed (needed for 'develop' /\n    # edit mode).\n    sh('%s -c \"import setuptools\"' % PYTHON)\n\n    # \"build_ext -i\" copies compiled *.pyd files in ./psutil directory in\n    # order to allow \"import psutil\" when using the interactive interpreter\n    # from within psutil root directory.\n    cmd = [PYTHON, \"setup.py\", \"build_ext\", \"-i\"]\n    if sys.version_info[:2] >= (3, 6) and (os.cpu_count() or 1) > 1:\n        cmd += ['--parallel', str(os.cpu_count())]\n    # Print coloured warnings in real time.\n    p = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\n    try:\n        for line in iter(p.stdout.readline, b''):\n            if PY3:\n                line = line.decode()\n            line = line.strip()\n            if 'warning' in line:\n                win_colorprint(line, YELLOW)\n            elif 'error' in line:\n                win_colorprint(line, RED)\n            else:\n                print(line)\n        # retcode = p.poll()\n        p.communicate()\n        if p.returncode:\n            win_colorprint(\"failure\", RED)\n            sys.exit(p.returncode)\n    finally:\n        p.terminate()\n        p.wait()\n\n    # Make sure it actually worked.\n    sh('%s -c \"import psutil\"' % PYTHON)\n    win_colorprint(\"build + import successful\", GREEN)\n\n\ndef wheel():\n    \"\"\"Create wheel file.\"\"\"\n    build()\n    sh(\"%s setup.py bdist_wheel\" % PYTHON)\n\n\ndef upload_wheels():\n    \"\"\"Upload wheel files on PyPI.\"\"\"\n    build()\n    sh(\"%s -m twine upload dist/*.whl\" % PYTHON)\n\n\ndef install_pip():\n    \"\"\"Install pip.\"\"\"\n    try:\n        sh('%s -c \"import pip\"' % PYTHON)\n    except SystemExit:\n        if PY3:\n            from urllib.request import urlopen\n        else:\n            from urllib2 import urlopen\n\n        if hasattr(ssl, '_create_unverified_context'):\n            ctx = ssl._create_unverified_context()\n        else:\n            ctx = None\n        kw = dict(context=ctx) if ctx else {}\n        safe_print(\"downloading %s\" % GET_PIP_URL)\n        req = urlopen(GET_PIP_URL, **kw)\n        data = req.read()\n\n        tfile = os.path.join(tempfile.gettempdir(), 'get-pip.py')\n        with open(tfile, 'wb') as f:\n            f.write(data)\n\n        try:\n            sh('%s %s --user' % (PYTHON, tfile))\n        finally:\n            os.remove(tfile)\n\n\ndef install():\n    \"\"\"Install in develop / edit mode.\"\"\"\n    build()\n    sh(\"%s setup.py develop\" % PYTHON)\n\n\ndef uninstall():\n    \"\"\"Uninstall psutil.\"\"\"\n    # Uninstalling psutil on Windows seems to be tricky.\n    # On \"import psutil\" tests may import a psutil version living in\n    # C:\\PythonXY\\Lib\\site-packages which is not what we want, so\n    # we try both \"pip uninstall psutil\" and manually remove stuff\n    # from site-packages.\n    clean()\n    install_pip()\n    here = os.getcwd()\n    try:\n        os.chdir('C:\\\\')\n        while True:\n            try:\n                import psutil  # NOQA\n            except ImportError:\n                break\n            else:\n                sh(\"%s -m pip uninstall -y psutil\" % PYTHON)\n    finally:\n        os.chdir(here)\n\n    for dir in site.getsitepackages():\n        for name in os.listdir(dir):\n            if name.startswith('psutil'):\n                rm(os.path.join(dir, name))\n            elif name == 'easy-install.pth':\n                # easy_install can add a line (installation path) into\n                # easy-install.pth; that line alters sys.path.\n                path = os.path.join(dir, name)\n                with open(path) as f:\n                    lines = f.readlines()\n                    hasit = False\n                    for line in lines:\n                        if 'psutil' in line:\n                            hasit = True\n                            break\n                if hasit:\n                    with open(path, \"w\") as f:\n                        for line in lines:\n                            if 'psutil' not in line:\n                                f.write(line)\n                            else:\n                                print(\"removed line %r from %r\" % (line, path))\n\n\ndef clean():\n    \"\"\"Deletes dev files.\"\"\"\n    recursive_rm(\n        \"$testfn*\",\n        \"*.bak\",\n        \"*.core\",\n        \"*.egg-info\",\n        \"*.orig\",\n        \"*.pyc\",\n        \"*.pyd\",\n        \"*.pyo\",\n        \"*.rej\",\n        \"*.so\",\n        \"*.~\",\n        \"*__pycache__\",\n        \".coverage\",\n        \".failed-tests.txt\",\n    )\n    safe_rmtree(\"build\")\n    safe_rmtree(\".coverage\")\n    safe_rmtree(\"dist\")\n    safe_rmtree(\"docs/_build\")\n    safe_rmtree(\"htmlcov\")\n    safe_rmtree(\"tmp\")\n\n\ndef setup_dev_env():\n    \"\"\"Install useful deps.\"\"\"\n    install_pip()\n    install_git_hooks()\n    sh(\"%s -m pip install -U %s\" % (PYTHON, \" \".join(DEPS)))\n\n\ndef test(name=RUNNER_PY):\n    \"\"\"Run tests.\"\"\"\n    build()\n    sh(\"%s %s\" % (PYTHON, name))\n\n\ndef coverage():\n    \"\"\"Run coverage tests.\"\"\"\n    # Note: coverage options are controlled by .coveragerc file\n    build()\n    sh(\"%s -m coverage run %s\" % (PYTHON, RUNNER_PY))\n    sh(\"%s -m coverage report\" % PYTHON)\n    sh(\"%s -m coverage html\" % PYTHON)\n    sh(\"%s -m webbrowser -t htmlcov/index.html\" % PYTHON)\n\n\ndef test_process():\n    \"\"\"Run process tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_process.py\" % PYTHON)\n\n\ndef test_process_all():\n    \"\"\"Run process all tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_process_all.py\" % PYTHON)\n\n\ndef test_system():\n    \"\"\"Run system tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_system.py\" % PYTHON)\n\n\ndef test_platform():\n    \"\"\"Run windows only tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_windows.py\" % PYTHON)\n\n\ndef test_misc():\n    \"\"\"Run misc tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_misc.py\" % PYTHON)\n\n\ndef test_unicode():\n    \"\"\"Run unicode tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_unicode.py\" % PYTHON)\n\n\ndef test_connections():\n    \"\"\"Run connections tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_connections.py\" % PYTHON)\n\n\ndef test_contracts():\n    \"\"\"Run contracts tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_contracts.py\" % PYTHON)\n\n\ndef test_testutils():\n    \"\"\"Run test utilities tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_testutils.py\" % PYTHON)\n\n\ndef test_by_name(name):\n    \"\"\"Run test by name.\"\"\"\n    build()\n    sh(\"%s -m unittest -v %s\" % (PYTHON, name))\n\n\ndef test_last_failed():\n    \"\"\"Re-run tests which failed on last run.\"\"\"\n    build()\n    sh(\"%s %s --last-failed\" % (PYTHON, RUNNER_PY))\n\n\ndef test_memleaks():\n    \"\"\"Run memory leaks tests.\"\"\"\n    build()\n    sh(\"%s psutil\\\\tests\\\\test_memleaks.py\" % PYTHON)\n\n\ndef install_git_hooks():\n    \"\"\"Install GIT pre-commit hook.\"\"\"\n    if os.path.isdir('.git'):\n        src = os.path.join(\n            ROOT_DIR, \"scripts\", \"internal\", \"git_pre_commit.py\"\n        )\n        dst = os.path.realpath(\n            os.path.join(ROOT_DIR, \".git\", \"hooks\", \"pre-commit\")\n        )\n        with open(src) as s:\n            with open(dst, \"w\") as d:\n                d.write(s.read())\n\n\ndef bench_oneshot():\n    \"\"\"Benchmarks for oneshot() ctx manager (see #799).\"\"\"\n    sh(\"%s -Wa scripts\\\\internal\\\\bench_oneshot.py\" % PYTHON)\n\n\ndef bench_oneshot_2():\n    \"\"\"Same as above but using perf module (supposed to be more precise).\"\"\"\n    sh(\"%s -Wa scripts\\\\internal\\\\bench_oneshot_2.py\" % PYTHON)\n\n\ndef print_access_denied():\n    \"\"\"Print AD exceptions raised by all Process methods.\"\"\"\n    build()\n    sh(\"%s -Wa scripts\\\\internal\\\\print_access_denied.py\" % PYTHON)\n\n\ndef print_api_speed():\n    \"\"\"Benchmark all API calls.\"\"\"\n    build()\n    sh(\"%s -Wa scripts\\\\internal\\\\print_api_speed.py\" % PYTHON)\n\n\ndef download_appveyor_wheels():\n    \"\"\"Download appveyor wheels.\"\"\"\n    sh(\n        \"%s -Wa scripts\\\\internal\\\\download_wheels_appveyor.py \"\n        \"--user giampaolo --project psutil\" % PYTHON\n    )\n\n\ndef generate_manifest():\n    \"\"\"Generate MANIFEST.in file.\"\"\"\n    script = \"scripts\\\\internal\\\\generate_manifest.py\"\n    out = subprocess.check_output([PYTHON, script], text=True)\n    with open(\"MANIFEST.in\", \"w\", newline=\"\\n\") as f:\n        f.write(out)\n\n\ndef get_python(path):\n    if not path:\n        return sys.executable\n    if os.path.isabs(path):\n        return path\n    # try to look for a python installation given a shortcut name\n    path = path.replace('.', '')\n    vers = (\n        '27',\n        '27-32',\n        '27-64',\n        '310-32',\n        '310-64',\n        '311-32',\n        '311-64',\n        '312-32',\n        '312-64',\n    )\n    for v in vers:\n        pypath = r'C:\\\\python%s\\python.exe' % v\n        if path in pypath and os.path.isfile(pypath):\n            return pypath\n\n\ndef parse_args():\n    parser = argparse.ArgumentParser()\n    # option shared by all commands\n    parser.add_argument('-p', '--python', help=\"use python executable path\")\n    sp = parser.add_subparsers(dest='command', title='targets')\n    sp.add_parser('bench-oneshot', help=\"benchmarks for oneshot()\")\n    sp.add_parser('bench-oneshot_2', help=\"benchmarks for oneshot() (perf)\")\n    sp.add_parser('build', help=\"build\")\n    sp.add_parser('clean', help=\"deletes dev files\")\n    sp.add_parser('coverage', help=\"run coverage tests.\")\n    sp.add_parser('download-appveyor-wheels', help=\"download wheels.\")\n    sp.add_parser('generate-manifest', help=\"generate MANIFEST.in file\")\n    sp.add_parser('help', help=\"print this help\")\n    sp.add_parser('install', help=\"build + install in develop/edit mode\")\n    sp.add_parser('install-git-hooks', help=\"install GIT pre-commit hook\")\n    sp.add_parser('install-pip', help=\"install pip\")\n    sp.add_parser('print-access-denied', help=\"print AD exceptions\")\n    sp.add_parser('print-api-speed', help=\"benchmark all API calls\")\n    sp.add_parser('setup-dev-env', help=\"install deps\")\n    test = sp.add_parser('test', help=\"[ARG] run tests\")\n    test_by_name = sp.add_parser('test-by-name', help=\"<ARG> run test by name\")\n    sp.add_parser('test-connections', help=\"run connections tests\")\n    sp.add_parser('test-contracts', help=\"run contracts tests\")\n    sp.add_parser(\n        'test-last-failed', help=\"re-run tests which failed on last run\"\n    )\n    sp.add_parser('test-memleaks', help=\"run memory leaks tests\")\n    sp.add_parser('test-misc', help=\"run misc tests\")\n    sp.add_parser('test-platform', help=\"run windows only tests\")\n    sp.add_parser('test-process', help=\"run process tests\")\n    sp.add_parser('test-process-all', help=\"run process all tests\")\n    sp.add_parser('test-system', help=\"run system tests\")\n    sp.add_parser('test-unicode', help=\"run unicode tests\")\n    sp.add_parser('test-testutils', help=\"run test utils tests\")\n    sp.add_parser('uninstall', help=\"uninstall psutil\")\n    sp.add_parser('upload-wheels', help=\"upload wheel files on PyPI\")\n    sp.add_parser('wheel', help=\"create wheel file\")\n\n    for p in (test, test_by_name):\n        p.add_argument('arg', type=str, nargs='?', default=\"\", help=\"arg\")\n\n    args = parser.parse_args()\n\n    if not args.command or args.command == 'help':\n        parser.print_help(sys.stderr)\n        sys.exit(1)\n\n    return args\n\n\ndef main():\n    global PYTHON\n    args = parse_args()\n    # set python exe\n    PYTHON = get_python(args.python)\n    if not PYTHON:\n        return sys.exit(\n            \"can't find any python installation matching %r\" % args.python\n        )\n    os.putenv('PYTHON', PYTHON)\n    win_colorprint(\"using \" + PYTHON)\n\n    fname = args.command.replace('-', '_')\n    fun = getattr(sys.modules[__name__], fname)  # err if fun not defined\n    funargs = []\n    # mandatory args\n    if args.command in ('test-by-name', 'test-script'):\n        if not args.arg:\n            sys.exit('command needs an argument')\n        funargs = [args.arg]\n    # optional args\n    if args.command == 'test' and args.arg:\n        funargs = [args.arg]\n    fun(*funargs)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_timeline.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Prints releases' timeline in RST format.\"\"\"\n\nimport shlex\nimport subprocess\n\n\nentry = \"\"\"\\\n- {date}:\n  `{ver} <https://pypi.org/project/psutil/{ver}/#files>`__ -\n  `what's new <https://github.com/giampaolo/psutil/blob/master/HISTORY.rst#{nodotver}>`__ -\n  `diff <https://github.com/giampaolo/psutil/compare/{prevtag}...{tag}#files_bucket>`__\"\"\"  # NOQA\n\n\ndef sh(cmd):\n    return subprocess.check_output(\n        shlex.split(cmd), universal_newlines=True\n    ).strip()\n\n\ndef get_tag_date(tag):\n    out = sh(r\"git log -1 --format=%ai {}\".format(tag))\n    return out.split(' ')[0]\n\n\ndef main():\n    releases = []\n    out = sh(\"git tag\")\n    for line in out.split('\\n'):\n        tag = line.split(' ')[0]\n        ver = tag.replace('release-', '')\n        nodotver = ver.replace('.', '')\n        date = get_tag_date(tag)\n        releases.append((tag, ver, nodotver, date))\n    releases.sort(reverse=True)\n\n    for i, rel in enumerate(releases):\n        tag, ver, nodotver, date = rel\n        try:\n            prevtag = releases[i + 1][0]\n        except IndexError:\n            # get first commit\n            prevtag = sh(\"git rev-list --max-parents=0 HEAD\")\n        print(entry.format(**locals()))\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_access_denied.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Helper script iterates over all processes and .\nIt prints how many AccessDenied exceptions are raised in total and\nfor what Process method.\n\n$ make print-access-denied\nAPI                  AD    Percent   Outcome\nmemory_info          0        0.0%   SUCCESS\nuids                 0        0.0%   SUCCESS\ncmdline              0        0.0%   SUCCESS\ncreate_time          0        0.0%   SUCCESS\nstatus               0        0.0%   SUCCESS\nnum_ctx_switches     0        0.0%   SUCCESS\nusername             0        0.0%   SUCCESS\nionice               0        0.0%   SUCCESS\nmemory_percent       0        0.0%   SUCCESS\ngids                 0        0.0%   SUCCESS\ncpu_times            0        0.0%   SUCCESS\nnice                 0        0.0%   SUCCESS\npid                  0        0.0%   SUCCESS\ncpu_percent          0        0.0%   SUCCESS\nnum_threads          0        0.0%   SUCCESS\ncpu_num              0        0.0%   SUCCESS\nppid                 0        0.0%   SUCCESS\nterminal             0        0.0%   SUCCESS\nname                 0        0.0%   SUCCESS\nthreads              0        0.0%   SUCCESS\ncpu_affinity         0        0.0%   SUCCESS\nmemory_maps          71      21.3%   ACCESS DENIED\nmemory_full_info     71      21.3%   ACCESS DENIED\nexe                  174     52.1%   ACCESS DENIED\nenviron              238     71.3%   ACCESS DENIED\nnum_fds              238     71.3%   ACCESS DENIED\nio_counters          238     71.3%   ACCESS DENIED\ncwd                  238     71.3%   ACCESS DENIED\nconnections          238     71.3%   ACCESS DENIED\nopen_files           238     71.3%   ACCESS DENIED\n--------------------------------------------------\nTotals: access-denied=1744, calls=10020, processes=334\n\"\"\"\n\nfrom __future__ import division\nfrom __future__ import print_function\n\nimport time\nfrom collections import defaultdict\n\nimport psutil\nfrom psutil._common import print_color\n\n\ndef main():\n    # collect\n    tot_procs = 0\n    tot_ads = 0\n    tot_calls = 0\n    signaler = object()\n    d = defaultdict(int)\n    start = time.time()\n    for p in psutil.process_iter(attrs=[], ad_value=signaler):\n        tot_procs += 1\n        for methname, value in p.info.items():\n            tot_calls += 1\n            if value is signaler:\n                tot_ads += 1\n                d[methname] += 1\n            else:\n                d[methname] += 0\n    elapsed = time.time() - start\n\n    # print\n    templ = \"%-20s %-5s %-9s %s\"\n    s = templ % (\"API\", \"AD\", \"Percent\", \"Outcome\")\n    print_color(s, color=None, bold=True)\n    for methname, ads in sorted(d.items(), key=lambda x: (x[1], x[0])):\n        perc = (ads / tot_procs) * 100\n        outcome = \"SUCCESS\" if not ads else \"ACCESS DENIED\"\n        s = templ % (methname, ads, \"%6.1f%%\" % perc, outcome)\n        print_color(s, \"red\" if ads else None)\n    tot_perc = round((tot_ads / tot_calls) * 100, 1)\n    print(\"-\" * 50)\n    print(\n        \"Totals: access-denied=%s (%s%%), calls=%s, processes=%s, elapsed=%ss\"\n        % (tot_ads, tot_perc, tot_calls, tot_procs, round(elapsed, 2))\n    )\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_announce.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Prints release announce based on HISTORY.rst file content.\nSee: https://pip.pypa.io/en/stable/reference/pip_install/#hash-checking-mode.\n\n\"\"\"\n\nimport os\nimport re\nimport subprocess\nimport sys\n\nfrom psutil import __version__\n\n\nHERE = os.path.abspath(os.path.dirname(__file__))\nROOT = os.path.realpath(os.path.join(HERE, '..', '..'))\nHISTORY = os.path.join(ROOT, 'HISTORY.rst')\nPRINT_HASHES_SCRIPT = os.path.join(\n    ROOT, 'scripts', 'internal', 'print_hashes.py'\n)\n\nPRJ_NAME = 'psutil'\nPRJ_VERSION = __version__\nPRJ_URL_HOME = 'https://github.com/giampaolo/psutil'\nPRJ_URL_DOC = 'http://psutil.readthedocs.io'\nPRJ_URL_DOWNLOAD = 'https://pypi.org/project/psutil/#files'\nPRJ_URL_WHATSNEW = (\n    'https://github.com/giampaolo/psutil/blob/master/HISTORY.rst'\n)\n\ntemplate = \"\"\"\\\nHello all,\nI'm glad to announce the release of {prj_name} {prj_version}:\n{prj_urlhome}\n\nAbout\n=====\n\npsutil (process and system utilities) is a cross-platform library for \\\nretrieving information on running processes and system utilization (CPU, \\\nmemory, disks, network) in Python. It is useful mainly for system \\\nmonitoring, profiling and limiting process resources and management of \\\nrunning processes. It implements many functionalities offered by command \\\nline tools such as: ps, top, lsof, netstat, ifconfig, who, df, kill, free, \\\nnice, ionice, iostat, iotop, uptime, pidof, tty, taskset, pmap. It \\\ncurrently supports Linux, Windows, macOS, Sun Solaris, FreeBSD, OpenBSD, \\\nNetBSD and AIX.  Supported Python versions are 2.7 and 3.6+. PyPy is also \\\nknown to work.\n\nWhat's new\n==========\n\n{changes}\n\nLinks\n=====\n\n- Home page: {prj_urlhome}\n- Download: {prj_urldownload}\n- Documentation: {prj_urldoc}\n- What's new: {prj_urlwhatsnew}\n\nHashes\n======\n\n{hashes}\n\n--\n\nGiampaolo - https://gmpy.dev/about\n\"\"\"\n\n\ndef get_changes():\n    \"\"\"Get the most recent changes for this release by parsing\n    HISTORY.rst file.\n    \"\"\"\n    with open(HISTORY) as f:\n        lines = f.readlines()\n\n    block = []\n\n    # eliminate the part preceding the first block\n    while lines:\n        line = lines.pop(0)\n        if line.startswith('===='):\n            break\n    else:\n        raise ValueError(\"something wrong\")\n\n    lines.pop(0)\n    while lines:\n        line = lines.pop(0)\n        line = line.rstrip()\n        if re.match(r\"^- \\d+_\", line):\n            line = re.sub(r\"^- (\\d+)_\", r\"- #\\1\", line)\n\n        if line.startswith('===='):\n            break\n        block.append(line)\n    else:\n        raise ValueError(\"something wrong\")\n\n    # eliminate bottom empty lines\n    block.pop(-1)\n    while not block[-1]:\n        block.pop(-1)\n\n    return \"\\n\".join(block)\n\n\ndef main():\n    changes = get_changes()\n    hashes = (\n        subprocess.check_output([sys.executable, PRINT_HASHES_SCRIPT, 'dist/'])\n        .strip()\n        .decode()\n    )\n    text = template.format(\n        prj_name=PRJ_NAME,\n        prj_version=PRJ_VERSION,\n        prj_urlhome=PRJ_URL_HOME,\n        prj_urldownload=PRJ_URL_DOWNLOAD,\n        prj_urldoc=PRJ_URL_DOC,\n        prj_urlwhatsnew=PRJ_URL_WHATSNEW,\n        changes=changes,\n        hashes=hashes,\n    )\n    print(text)\n\n\nif __name__ == '__main__':\n    main()\n", "scripts/internal/print_downloads.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009 Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Print PYPI statistics in MarkDown format.\nUseful sites:\n* https://pepy.tech/project/psutil\n* https://pypistats.org/packages/psutil\n* https://hugovk.github.io/top-pypi-packages/.\n\"\"\"\n\nfrom __future__ import print_function\n\nimport json\nimport os\nimport shlex\nimport subprocess\nimport sys\n\nimport pypinfo  # NOQA\n\nfrom psutil._common import memoize\n\n\nAUTH_FILE = os.path.expanduser(\"~/.pypinfo.json\")\nPKGNAME = 'psutil'\nDAYS = 30\nLIMIT = 100\nGITHUB_SCRIPT_URL = (\n    \"https://github.com/giampaolo/psutil/blob/master/\"\n    \"scripts/internal/pypistats.py\"\n)\nLAST_UPDATE = None\nbytes_billed = 0\n\n\n# --- get\n\n\n@memoize\ndef sh(cmd):\n    assert os.path.exists(AUTH_FILE)\n    env = os.environ.copy()\n    env['GOOGLE_APPLICATION_CREDENTIALS'] = AUTH_FILE\n    p = subprocess.Popen(\n        shlex.split(cmd),\n        stdout=subprocess.PIPE,\n        stderr=subprocess.PIPE,\n        universal_newlines=True,\n        env=env,\n    )\n    stdout, stderr = p.communicate()\n    if p.returncode != 0:\n        raise RuntimeError(stderr)\n    assert not stderr, stderr\n    return stdout.strip()\n\n\n@memoize\ndef query(cmd):\n    global bytes_billed\n    ret = json.loads(sh(cmd))\n    bytes_billed += ret['query']['bytes_billed']\n    return ret\n\n\ndef top_packages():\n    global LAST_UPDATE\n    ret = query(\n        \"pypinfo --all --json --days %s --limit %s '' project\" % (DAYS, LIMIT)\n    )\n    LAST_UPDATE = ret['last_update']\n    return [(x['project'], x['download_count']) for x in ret['rows']]\n\n\ndef ranking():\n    data = top_packages()\n    i = 1\n    for name, downloads in data:\n        if name == PKGNAME:\n            return i\n        i += 1\n    raise ValueError(\"can't find %s\" % PKGNAME)\n\n\ndef downloads():\n    data = top_packages()\n    for name, downloads in data:\n        if name == PKGNAME:\n            return downloads\n    raise ValueError(\"can't find %s\" % PKGNAME)\n\n\ndef downloads_pyver():\n    return query(\"pypinfo --json --days %s %s pyversion\" % (DAYS, PKGNAME))\n\n\ndef downloads_by_country():\n    return query(\"pypinfo --json --days %s %s country\" % (DAYS, PKGNAME))\n\n\ndef downloads_by_system():\n    return query(\"pypinfo --json --days %s %s system\" % (DAYS, PKGNAME))\n\n\ndef downloads_by_distro():\n    return query(\"pypinfo --json --days %s %s distro\" % (DAYS, PKGNAME))\n\n\n# --- print\n\n\ntempl = \"| %-30s | %15s |\"\n\n\ndef print_row(left, right):\n    if isinstance(right, int):\n        right = '{:,}'.format(right)\n    print(templ % (left, right))\n\n\ndef print_header(left, right=\"Downloads\"):\n    print_row(left, right)\n    s = templ % (\"-\" * 30, \"-\" * 15)\n    print(\"|:\" + s[2:-2] + \":|\")\n\n\ndef print_markdown_table(title, left, rows):\n    pleft = left.replace('_', ' ').capitalize()\n    print(\"### \" + title)\n    print()\n    print_header(pleft)\n    for row in rows:\n        lval = row[left]\n        print_row(lval, row['download_count'])\n    print()\n\n\ndef main():\n    downs = downloads()\n\n    print(\"# Download stats\")\n    print()\n    s = \"psutil download statistics of the last %s days (last update \" % DAYS\n    s += \"*%s*).\\n\" % LAST_UPDATE\n    s += \"Generated via [pypistats.py](%s) script.\\n\" % GITHUB_SCRIPT_URL\n    print(s)\n\n    data = [\n        {'what': 'Per month', 'download_count': downs},\n        {'what': 'Per day', 'download_count': int(downs / 30)},\n        {'what': 'PYPI ranking', 'download_count': ranking()},\n    ]\n    print_markdown_table('Overview', 'what', data)\n    print_markdown_table(\n        'Operating systems', 'system_name', downloads_by_system()['rows']\n    )\n    print_markdown_table(\n        'Distros', 'distro_name', downloads_by_distro()['rows']\n    )\n    print_markdown_table(\n        'Python versions', 'python_version', downloads_pyver()['rows']\n    )\n    print_markdown_table(\n        'Countries', 'country', downloads_by_country()['rows']\n    )\n\n\nif __name__ == '__main__':\n    try:\n        main()\n    finally:\n        print(\"bytes billed: %s\" % bytes_billed, file=sys.stderr)\n", "scripts/internal/bench_oneshot_2.py": "#!/usr/bin/env python3\n\n# Copyright (c) 2009, Giampaolo Rodola'. All rights reserved.\n# Use of this source code is governed by a BSD-style license that can be\n# found in the LICENSE file.\n\n\"\"\"Same as bench_oneshot.py but uses perf module instead, which is\nsupposed to be more precise.\n\"\"\"\n\nimport sys\n\nimport pyperf  # requires \"pip install pyperf\"\nfrom bench_oneshot import names\n\nimport psutil\n\n\np = psutil.Process()\nfuns = [getattr(p, n) for n in names]\n\n\ndef call_normal():\n    for fun in funs:\n        fun()\n\n\ndef call_oneshot():\n    with p.oneshot():\n        for fun in funs:\n            fun()\n\n\ndef add_cmdline_args(cmd, args):\n    cmd.append(args.benchmark)\n\n\ndef main():\n    runner = pyperf.Runner()\n\n    args = runner.parse_args()\n    if not args.worker:\n        print(\n            \"%s methods involved on platform %r (psutil %s):\"\n            % (len(names), sys.platform, psutil.__version__)\n        )\n        for name in sorted(names):\n            print(\"    \" + name)\n\n    runner.bench_func(\"normal\", call_normal)\n    runner.bench_func(\"oneshot\", call_oneshot)\n\n\nmain()\n"}