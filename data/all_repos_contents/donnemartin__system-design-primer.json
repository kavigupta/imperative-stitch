{"solutions/system_design/mint/mint_mapreduce.py": "# -*- coding: utf-8 -*-\n\nfrom mrjob.job import MRJob\n\n\nclass SpendingByCategory(MRJob):\n\n    def __init__(self, categorizer):\n        self.categorizer = categorizer\n        ...\n\n    def current_year_month(self):\n        \"\"\"Return the current year and month.\"\"\"\n        ...\n\n    def extract_year_month(self, timestamp):\n        \"\"\"Return the year and month portions of the timestamp.\"\"\"\n        ...\n\n    def handle_budget_notifications(self, key, total):\n        \"\"\"Call notification API if nearing or exceeded budget.\"\"\"\n        ...\n\n    def mapper(self, _, line):\n        \"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (2016-01, shopping), 25\n        (2016-01, shopping), 100\n        (2016-01, gas), 50\n        \"\"\"\n        timestamp, category, amount = line.split('\\t')\n        period = self. extract_year_month(timestamp)\n        if period == self.current_year_month():\n            yield (period, category), amount\n\n    def reducer(self, key, values):\n        \"\"\"Sum values for each key.\n\n        (2016-01, shopping), 125\n        (2016-01, gas), 50\n        \"\"\"\n        total = sum(values)\n        self.handle_budget_notifications(key, total)\n        yield key, sum(values)\n\n    def steps(self):\n        \"\"\"Run the map and reduce steps.\"\"\"\n        return [\n            self.mr(mapper=self.mapper,\n                    reducer=self.reducer)\n        ]\n\n\nif __name__ == '__main__':\n    SpendingByCategory.run()\n", "solutions/system_design/mint/mint_snippets.py": "# -*- coding: utf-8 -*-\n\nfrom enum import Enum\n\n\nclass DefaultCategories(Enum):\n\n    HOUSING = 0\n    FOOD = 1\n    GAS = 2\n    SHOPPING = 3\n    # ...\n\n\nseller_category_map = {}\nseller_category_map['Exxon'] = DefaultCategories.GAS\nseller_category_map['Target'] = DefaultCategories.SHOPPING\n\n\nclass Categorizer(object):\n\n    def __init__(self, seller_category_map, seller_category_overrides_map):\n        self.seller_category_map = seller_category_map\n        self.seller_category_overrides_map = seller_category_overrides_map\n\n    def categorize(self, transaction):\n        if transaction.seller in self.seller_category_map:\n            return self.seller_category_map[transaction.seller]\n        if transaction.seller in self.seller_category_overrides_map:\n            seller_category_map[transaction.seller] = \\\n                self.manual_overrides[transaction.seller].peek_min()\n            return self.seller_category_map[transaction.seller]\n        return None\n\n\nclass Transaction(object):\n\n    def __init__(self, timestamp, seller, amount):\n        self.timestamp = timestamp\n        self.seller = seller\n        self.amount = amount\n\n\nclass Budget(object):\n\n    def __init__(self, template_categories_to_budget_map):\n        self.categories_to_budget_map = template_categories_to_budget_map\n\n    def override_category_budget(self, category, amount):\n        self.categories_to_budget_map[category] = amount\n", "solutions/system_design/mint/__init__.py": "", "solutions/system_design/pastebin/pastebin.py": "# -*- coding: utf-8 -*-\n\nfrom mrjob.job import MRJob\n\n\nclass HitCounts(MRJob):\n\n    def extract_url(self, line):\n        \"\"\"Extract the generated url from the log line.\"\"\"\n        pass\n\n    def extract_year_month(self, line):\n        \"\"\"Return the year and month portions of the timestamp.\"\"\"\n        pass\n\n    def mapper(self, _, line):\n        \"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (2016-01, url0), 1\n        (2016-01, url0), 1\n        (2016-01, url1), 1\n        \"\"\"\n        url = self.extract_url(line)\n        period = self.extract_year_month(line)\n        yield (period, url), 1\n\n    def reducer(self, key, values):\n        \"\"\"Sum values for each key.\n\n        (2016-01, url0), 2\n        (2016-01, url1), 1\n        \"\"\"\n        yield key, sum(values)\n\n    def steps(self):\n        \"\"\"Run the map and reduce steps.\"\"\"\n        return [\n            self.mr(mapper=self.mapper,\n                    reducer=self.reducer)\n        ]\n\n\nif __name__ == '__main__':\n    HitCounts.run()\n", "solutions/system_design/pastebin/__init__.py": "", "solutions/system_design/query_cache/query_cache_snippets.py": "# -*- coding: utf-8 -*-\n\n\nclass QueryApi(object):\n\n    def __init__(self, memory_cache, reverse_index_cluster):\n        self.memory_cache = memory_cache\n        self.reverse_index_cluster = reverse_index_cluster\n\n    def parse_query(self, query):\n        \"\"\"Remove markup, break text into terms, deal with typos,\n        normalize capitalization, convert to use boolean operations.\n        \"\"\"\n        ...\n\n    def process_query(self, query):\n        query = self.parse_query(query)\n        results = self.memory_cache.get(query)\n        if results is None:\n            results = self.reverse_index_cluster.process_search(query)\n            self.memory_cache.set(query, results)\n        return results\n\n\nclass Node(object):\n\n    def __init__(self, query, results):\n        self.query = query\n        self.results = results\n\n\nclass LinkedList(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def move_to_front(self, node):\n        ...\n\n    def append_to_front(self, node):\n        ...\n\n    def remove_from_tail(self):\n        ...\n\n\nclass Cache(object):\n\n    def __init__(self, MAX_SIZE):\n        self.MAX_SIZE = MAX_SIZE\n        self.size = 0\n        self.lookup = {}\n        self.linked_list = LinkedList()\n\n    def get(self, query):\n        \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n        node = self.lookup[query]\n        if node is None:\n            return None\n        self.linked_list.move_to_front(node)\n        return node.results\n\n    def set(self, results, query):\n        \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n        node = self.map[query]\n        if node is not None:\n            # Key exists in cache, update the value\n            node.results = results\n            self.linked_list.move_to_front(node)\n        else:\n            # Key does not exist in cache\n            if self.size == self.MAX_SIZE:\n                # Remove the oldest entry from the linked list and lookup\n                self.lookup.pop(self.linked_list.tail.query, None)\n                self.linked_list.remove_from_tail()\n            else:\n                self.size += 1\n            # Add the new key and value\n            new_node = Node(query, results)\n            self.linked_list.append_to_front(new_node)\n            self.lookup[query] = new_node\n", "solutions/system_design/query_cache/__init__.py": "", "solutions/system_design/sales_rank/sales_rank_mapreduce.py": "# -*- coding: utf-8 -*-\n\nfrom mrjob.job import MRJob\n\n\nclass SalesRanker(MRJob):\n\n    def within_past_week(self, timestamp):\n        \"\"\"Return True if timestamp is within past week, False otherwise.\"\"\"\n        ...\n\n    def mapper(self, _, line):\n        \"\"\"Parse each log line, extract and transform relevant lines.\n\n        Emit key value pairs of the form:\n\n        (foo, p1), 2\n        (bar, p1), 2\n        (bar, p1), 1\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\n        timestamp, product_id, category, quantity = line.split('\\t')\n        if self.within_past_week(timestamp):\n            yield (category, product_id), quantity\n\n    def reducer(self, key, values):\n        \"\"\"Sum values for each key.\n\n        (foo, p1), 2\n        (bar, p1), 3\n        (foo, p2), 3\n        (bar, p3), 10\n        (foo, p4), 1\n        \"\"\"\n        yield key, sum(values)\n\n    def mapper_sort(self, key, value):\n        \"\"\"Construct key to ensure proper sorting.\n\n        Transform key and value to the form:\n\n        (foo, 2), p1\n        (bar, 3), p1\n        (foo, 3), p2\n        (bar, 10), p3\n        (foo, 1), p4\n\n        The shuffle/sort step of MapReduce will then do a\n        distributed sort on the keys, resulting in:\n\n        (category1, 1), product4\n        (category1, 2), product1\n        (category1, 3), product2\n        (category2, 3), product1\n        (category2, 7), product3\n        \"\"\"\n        category, product_id = key\n        quantity = value\n        yield (category, quantity), product_id\n\n    def reducer_identity(self, key, value):\n        yield key, value\n\n    def steps(self):\n        \"\"\"Run the map and reduce steps.\"\"\"\n        return [\n            self.mr(mapper=self.mapper,\n                    reducer=self.reducer),\n            self.mr(mapper=self.mapper_sort,\n                    reducer=self.reducer_identity),\n        ]\n\n\nif __name__ == '__main__':\n    SalesRanker.run()\n", "solutions/system_design/sales_rank/__init__.py": "", "solutions/system_design/web_crawler/web_crawler_mapreduce.py": "# -*- coding: utf-8 -*-\n\nfrom mrjob.job import MRJob\n\n\nclass RemoveDuplicateUrls(MRJob):\n\n    def mapper(self, _, line):\n        yield line, 1\n\n    def reducer(self, key, values):\n        total = sum(values)\n        if total == 1:\n            yield key, total\n\n    def steps(self):\n        \"\"\"Run the map and reduce steps.\"\"\"\n        return [\n            self.mr(mapper=self.mapper,\n                    reducer=self.reducer)\n        ]\n\n\nif __name__ == '__main__':\n    RemoveDuplicateUrls.run()\n", "solutions/system_design/web_crawler/web_crawler_snippets.py": "# -*- coding: utf-8 -*-\n\n\nclass PagesDataStore(object):\n\n    def __init__(self, db):\n        self.db = db\n        pass\n\n    def add_link_to_crawl(self, url):\n        \"\"\"Add the given link to `links_to_crawl`.\"\"\"\n        pass\n\n    def remove_link_to_crawl(self, url):\n        \"\"\"Remove the given link from `links_to_crawl`.\"\"\"\n        pass\n\n    def reduce_priority_link_to_crawl(self, url):\n        \"\"\"Reduce the priority of a link in `links_to_crawl` to avoid cycles.\"\"\"\n        pass\n\n    def extract_max_priority_page(self):\n        \"\"\"Return the highest priority link in `links_to_crawl`.\"\"\"\n        pass\n\n    def insert_crawled_link(self, url, signature):\n        \"\"\"Add the given link to `crawled_links`.\"\"\"\n        pass\n\n    def crawled_similar(self, signature):\n        \"\"\"Determine if we've already crawled a page matching the given signature\"\"\"\n        pass\n\n\nclass Page(object):\n\n    def __init__(self, url, contents, child_urls):\n        self.url = url\n        self.contents = contents\n        self.child_urls = child_urls\n        self.signature = self.create_signature()\n\n    def create_signature(self):\n        # Create signature based on url and contents\n        pass\n\n\nclass Crawler(object):\n\n    def __init__(self, pages, data_store, reverse_index_queue, doc_index_queue):\n        self.pages = pages\n        self.data_store = data_store\n        self.reverse_index_queue = reverse_index_queue\n        self.doc_index_queue = doc_index_queue\n\n    def crawl_page(self, page):\n        for url in page.child_urls:\n            self.data_store.add_link_to_crawl(url)\n        self.reverse_index_queue.generate(page)\n        self.doc_index_queue.generate(page)\n        self.data_store.remove_link_to_crawl(page.url)\n        self.data_store.insert_crawled_link(page.url, page.signature)\n\n    def crawl(self):\n        while True:\n            page = self.data_store.extract_max_priority_page()\n            if page is None:\n                break\n            if self.data_store.crawled_similar(page.signature):\n                self.data_store.reduce_priority_link_to_crawl(page.url)\n            else:\n                self.crawl_page(page)\n            page = self.data_store.extract_max_priority_page()\n", "solutions/system_design/web_crawler/__init__.py": "", "solutions/system_design/social_graph/social_graph_snippets.py": "# -*- coding: utf-8 -*-\nfrom collections import deque\nfrom enum import Enum\n\n\nclass State(Enum):\n    unvisited = 0\n    visited = 1\n\n\nclass Graph(object):\n\n    def bfs(self, source, dest):\n        if source is None:\n            return False\n        queue = deque()\n        queue.append(source)\n        source.visit_state = State.visited\n        while queue:\n            node = queue.popleft()\n            print(node)\n            if dest is node:\n                return True\n            for adjacent_node in node.adj_nodes.values():\n                if adjacent_node.visit_state == State.unvisited:\n                    queue.append(adjacent_node)\n                    adjacent_node.visit_state = State.visited\n        return False\n\n\nclass Person(object):\n\n    def __init__(self, id, name):\n        self.id = id\n        self.name = name\n        self.friend_ids = []\n\n\nclass LookupService(object):\n\n    def __init__(self):\n        self.lookup = {}  # key: person_id, value: person_server\n\n    def get_person(self, person_id):\n        person_server = self.lookup[person_id]\n        return person_server.people[person_id]\n\n\nclass PersonServer(object):\n\n    def __init__(self):\n        self.people = {}  # key: person_id, value: person\n\n    def get_people(self, ids):\n        results = []\n        for id in ids:\n            if id in self.people:\n                results.append(self.people[id])\n        return results\n\n\nclass UserGraphService(object):\n\n    def __init__(self, person_ids, lookup):\n        self.lookup = lookup\n        self.person_ids = person_ids\n        self.visited_ids = set()\n\n    def bfs(self, source, dest):\n        # Use self.visited_ids to track visited nodes\n        # Use self.lookup to translate a person_id to a Person\n        pass\n", "solutions/system_design/social_graph/__init__.py": "", "solutions/object_oriented_design/online_chat/online_chat.py": "from abc import ABCMeta\nfrom enum import Enum\n\n\nclass UserService(object):\n\n    def __init__(self):\n        self.users_by_id = {}  # key: user id, value: User\n\n    def add_user(self, user_id, name, pass_hash):\n        pass\n\n    def remove_user(self, user_id):\n        pass\n\n    def add_friend_request(self, from_user_id, to_user_id):\n        pass\n\n    def approve_friend_request(self, from_user_id, to_user_id):\n        pass\n\n    def reject_friend_request(self, from_user_id, to_user_id):\n        pass\n\n\nclass User(object):\n\n    def __init__(self, user_id, name, pass_hash):\n        self.user_id = user_id\n        self.name = name\n        self.pass_hash = pass_hash\n        self.friends_by_id = {}  # key: friend id, value: User\n        self.friend_ids_to_private_chats = {}  # key: friend id, value: private chats\n        self.group_chats_by_id = {}  # key: chat id, value: GroupChat\n        self.received_friend_requests_by_friend_id = {}  # key: friend id, value: AddRequest\n        self.sent_friend_requests_by_friend_id = {}  # key: friend id, value: AddRequest\n\n    def message_user(self, friend_id, message):\n        pass\n\n    def message_group(self, group_id, message):\n        pass\n\n    def send_friend_request(self, friend_id):\n        pass\n\n    def receive_friend_request(self, friend_id):\n        pass\n\n    def approve_friend_request(self, friend_id):\n        pass\n\n    def reject_friend_request(self, friend_id):\n        pass\n\n\nclass Chat(metaclass=ABCMeta):\n\n    def __init__(self, chat_id):\n        self.chat_id = chat_id\n        self.users = []\n        self.messages = []\n\n\nclass PrivateChat(Chat):\n\n    def __init__(self, first_user, second_user):\n        super(PrivateChat, self).__init__()\n        self.users.append(first_user)\n        self.users.append(second_user)\n\n\nclass GroupChat(Chat):\n\n    def add_user(self, user):\n        pass\n\n    def remove_user(self, user):\n        pass\n\n\nclass Message(object):\n\n    def __init__(self, message_id, message, timestamp):\n        self.message_id = message_id\n        self.message = message\n        self.timestamp = timestamp\n\n\nclass AddRequest(object):\n\n    def __init__(self, from_user_id, to_user_id, request_status, timestamp):\n        self.from_user_id = from_user_id\n        self.to_user_id = to_user_id\n        self.request_status = request_status\n        self.timestamp = timestamp\n\n\nclass RequestStatus(Enum):\n\n    UNREAD = 0\n    READ = 1\n    ACCEPTED = 2\n    REJECTED = 3\n", "solutions/object_oriented_design/online_chat/__init__.py": "", "solutions/object_oriented_design/parking_lot/parking_lot.py": "from abc import ABCMeta, abstractmethod\nfrom enum import Enum\n\n\nclass VehicleSize(Enum):\n\n    MOTORCYCLE = 0\n    COMPACT = 1\n    LARGE = 2\n\n\nclass Vehicle(metaclass=ABCMeta):\n\n    def __init__(self, vehicle_size, license_plate, spot_size):\n        self.vehicle_size = vehicle_size\n        self.license_plate = license_plate\n        self.spot_size\n        self.spots_taken = []\n\n    def clear_spots(self):\n        for spot in self.spots_taken:\n            spot.remove_vehicle(self)\n        self.spots_taken = []\n\n    def take_spot(self, spot):\n        self.spots_taken.append(spot)\n\n    @abstractmethod\n    def can_fit_in_spot(self, spot):\n        pass\n\n\nclass Motorcycle(Vehicle):\n\n    def __init__(self, license_plate):\n        super(Motorcycle, self).__init__(VehicleSize.MOTORCYCLE, license_plate, spot_size=1)\n\n    def can_fit_in_spot(self, spot):\n        return True\n\n\nclass Car(Vehicle):\n\n    def __init__(self, license_plate):\n        super(Car, self).__init__(VehicleSize.COMPACT, license_plate, spot_size=1)\n\n    def can_fit_in_spot(self, spot):\n        return spot.size in (VehicleSize.LARGE, VehicleSize.COMPACT)\n\n\nclass Bus(Vehicle):\n\n    def __init__(self, license_plate):\n        super(Bus, self).__init__(VehicleSize.LARGE, license_plate, spot_size=5)\n\n    def can_fit_in_spot(self, spot):\n        return spot.size == VehicleSize.LARGE\n\n\nclass ParkingLot(object):\n\n    def __init__(self, num_levels):\n        self.num_levels = num_levels\n        self.levels = []  # List of Levels\n\n    def park_vehicle(self, vehicle):\n        for level in self.levels:\n            if level.park_vehicle(vehicle):\n                return True\n        return False\n\n\nclass Level(object):\n\n    SPOTS_PER_ROW = 10\n\n    def __init__(self, floor, total_spots):\n        self.floor = floor\n        self.num_spots = total_spots\n        self.available_spots = 0\n        self.spots = []  # List of ParkingSpots\n\n    def spot_freed(self):\n        self.available_spots += 1\n\n    def park_vehicle(self, vehicle):\n        spot = self._find_available_spot(vehicle)\n        if spot is None:\n            return None\n        else:\n            spot.park_vehicle(vehicle)\n            return spot\n\n    def _find_available_spot(self, vehicle):\n        \"\"\"Find an available spot where vehicle can fit, or return None\"\"\"\n        pass\n\n    def _park_starting_at_spot(self, spot, vehicle):\n        \"\"\"Occupy starting at spot.spot_number to vehicle.spot_size.\"\"\"\n        pass\n\n\nclass ParkingSpot(object):\n\n    def __init__(self, level, row, spot_number, spot_size, vehicle_size):\n        self.level = level\n        self.row = row\n        self.spot_number = spot_number\n        self.spot_size = spot_size\n        self.vehicle_size = vehicle_size\n        self.vehicle = None\n\n    def is_available(self):\n        return True if self.vehicle is None else False\n\n    def can_fit_vehicle(self, vehicle):\n        if self.vehicle is not None:\n            return False\n        return vehicle.can_fit_in_spot(self)\n\n    def park_vehicle(self, vehicle):\n        pass\n\n    def remove_vehicle(self):\n        pass\n", "solutions/object_oriented_design/parking_lot/__init__.py": "", "solutions/object_oriented_design/lru_cache/__init__.py": "", "solutions/object_oriented_design/lru_cache/lru_cache.py": "class Node(object):\n\n    def __init__(self, results):\n        self.results = results\n        self.next = next\n\n\nclass LinkedList(object):\n\n    def __init__(self):\n        self.head = None\n        self.tail = None\n\n    def move_to_front(self, node):\n        pass\n\n    def append_to_front(self, node):\n        pass\n\n    def remove_from_tail(self):\n        pass\n\n\nclass Cache(object):\n\n    def __init__(self, MAX_SIZE):\n        self.MAX_SIZE = MAX_SIZE\n        self.size = 0\n        self.lookup = {}  # key: query, value: node\n        self.linked_list = LinkedList()\n\n    def get(self, query):\n        \"\"\"Get the stored query result from the cache.\n\n        Accessing a node updates its position to the front of the LRU list.\n        \"\"\"\n        node = self.lookup.get(query)\n        if node is None:\n            return None\n        self.linked_list.move_to_front(node)\n        return node.results\n\n    def set(self, results, query):\n        \"\"\"Set the result for the given query key in the cache.\n\n        When updating an entry, updates its position to the front of the LRU list.\n        If the entry is new and the cache is at capacity, removes the oldest entry\n        before the new entry is added.\n        \"\"\"\n        node = self.lookup.get(query)\n        if node is not None:\n            # Key exists in cache, update the value\n            node.results = results\n            self.linked_list.move_to_front(node)\n        else:\n            # Key does not exist in cache\n            if self.size == self.MAX_SIZE:\n                # Remove the oldest entry from the linked list and lookup\n                self.lookup.pop(self.linked_list.tail.query, None)\n                self.linked_list.remove_from_tail()\n            else:\n                self.size += 1\n            # Add the new key and value\n            new_node = Node(results)\n            self.linked_list.append_to_front(new_node)\n            self.lookup[query] = new_node\n", "solutions/object_oriented_design/deck_of_cards/deck_of_cards.py": "from abc import ABCMeta, abstractmethod\nfrom enum import Enum\nimport sys\n\n\nclass Suit(Enum):\n\n    HEART = 0\n    DIAMOND = 1\n    CLUBS = 2\n    SPADE = 3\n\n\nclass Card(metaclass=ABCMeta):\n\n    def __init__(self, value, suit):\n        self.value = value\n        self.suit = suit\n        self.is_available = True\n\n    @property\n    @abstractmethod\n    def value(self):\n        pass\n\n    @value.setter\n    @abstractmethod\n    def value(self, other):\n        pass\n\n\nclass BlackJackCard(Card):\n\n    def __init__(self, value, suit):\n        super(BlackJackCard, self).__init__(value, suit)\n\n    def is_ace(self):\n        return True if self._value == 1 else False\n\n    def is_face_card(self):\n        \"\"\"Jack = 11, Queen = 12, King = 13\"\"\"\n        return True if 10 < self._value <= 13 else False\n\n    @property\n    def value(self):\n        if self.is_ace() == 1:\n            return 1\n        elif self.is_face_card():\n            return 10\n        else:\n            return self._value\n\n    @value.setter\n    def value(self, new_value):\n        if 1 <= new_value <= 13:\n            self._value = new_value\n        else:\n            raise ValueError('Invalid card value: {}'.format(new_value))\n\n\nclass Hand(object):\n\n    def __init__(self, cards):\n        self.cards = cards\n\n    def add_card(self, card):\n        self.cards.append(card)\n\n    def score(self):\n        total_value = 0\n        for card in self.cards:\n            total_value += card.value\n        return total_value\n\n\nclass BlackJackHand(Hand):\n\n    BLACKJACK = 21\n\n    def __init__(self, cards):\n        super(BlackJackHand, self).__init__(cards)\n\n    def score(self):\n        min_over = sys.MAXSIZE\n        max_under = -sys.MAXSIZE\n        for score in self.possible_scores():\n            if self.BLACKJACK < score < min_over:\n                min_over = score\n            elif max_under < score <= self.BLACKJACK:\n                max_under = score\n        return max_under if max_under != -sys.MAXSIZE else min_over\n\n    def possible_scores(self):\n        \"\"\"Return a list of possible scores, taking Aces into account.\"\"\"\n        pass\n\n\nclass Deck(object):\n\n    def __init__(self, cards):\n        self.cards = cards\n        self.deal_index = 0\n\n    def remaining_cards(self):\n        return len(self.cards) - self.deal_index\n\n    def deal_card(self):\n        try:\n            card = self.cards[self.deal_index]\n            card.is_available = False\n            self.deal_index += 1\n        except IndexError:\n            return None\n        return card\n\n    def shuffle(self):\n        pass\n", "solutions/object_oriented_design/deck_of_cards/__init__.py": "", "solutions/object_oriented_design/hash_table/hash_map.py": "class Item(object):\n\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\n\nclass HashTable(object):\n\n    def __init__(self, size):\n        self.size = size\n        self.table = [[] for _ in range(self.size)]\n\n    def _hash_function(self, key):\n        return key % self.size\n\n    def set(self, key, value):\n        hash_index = self._hash_function(key)\n        for item in self.table[hash_index]:\n            if item.key == key:\n                item.value = value\n                return\n        self.table[hash_index].append(Item(key, value))\n\n    def get(self, key):\n        hash_index = self._hash_function(key)\n        for item in self.table[hash_index]:\n            if item.key == key:\n                return item.value\n        raise KeyError('Key not found')\n\n    def remove(self, key):\n        hash_index = self._hash_function(key)\n        for index, item in enumerate(self.table[hash_index]):\n            if item.key == key:\n                del self.table[hash_index][index]\n                return\n        raise KeyError('Key not found')\n", "solutions/object_oriented_design/hash_table/__init__.py": "", "solutions/object_oriented_design/call_center/call_center.py": "from abc import ABCMeta, abstractmethod\nfrom collections import deque\nfrom enum import Enum\n\n\nclass Rank(Enum):\n\n    OPERATOR = 0\n    SUPERVISOR = 1\n    DIRECTOR = 2\n\n\nclass Employee(metaclass=ABCMeta):\n\n    def __init__(self, employee_id, name, rank, call_center):\n        self.employee_id = employee_id\n        self.name = name\n        self.rank = rank\n        self.call = None\n        self.call_center = call_center\n\n    def take_call(self, call):\n        \"\"\"Assume the employee will always successfully take the call.\"\"\"\n        self.call = call\n        self.call.employee = self\n        self.call.state = CallState.IN_PROGRESS\n\n    def complete_call(self):\n        self.call.state = CallState.COMPLETE\n        self.call_center.notify_call_completed(self.call)\n\n    @abstractmethod\n    def escalate_call(self):\n        pass\n\n    def _escalate_call(self):\n        self.call.state = CallState.READY\n        call = self.call\n        self.call = None\n        self.call_center.notify_call_escalated(call)\n\n\nclass Operator(Employee):\n\n    def __init__(self, employee_id, name):\n        super(Operator, self).__init__(employee_id, name, Rank.OPERATOR)\n\n    def escalate_call(self):\n        self.call.level = Rank.SUPERVISOR\n        self._escalate_call()\n\n\nclass Supervisor(Employee):\n\n    def __init__(self, employee_id, name):\n        super(Operator, self).__init__(employee_id, name, Rank.SUPERVISOR)\n\n    def escalate_call(self):\n        self.call.level = Rank.DIRECTOR\n        self._escalate_call()\n\n\nclass Director(Employee):\n\n    def __init__(self, employee_id, name):\n        super(Operator, self).__init__(employee_id, name, Rank.DIRECTOR)\n\n    def escalate_call(self):\n        raise NotImplementedError('Directors must be able to handle any call')\n\n\nclass CallState(Enum):\n\n    READY = 0\n    IN_PROGRESS = 1\n    COMPLETE = 2\n\n\nclass Call(object):\n\n    def __init__(self, rank):\n        self.state = CallState.READY\n        self.rank = rank\n        self.employee = None\n\n\nclass CallCenter(object):\n\n    def __init__(self, operators, supervisors, directors):\n        self.operators = operators\n        self.supervisors = supervisors\n        self.directors = directors\n        self.queued_calls = deque()\n\n    def dispatch_call(self, call):\n        if call.rank not in (Rank.OPERATOR, Rank.SUPERVISOR, Rank.DIRECTOR):\n            raise ValueError('Invalid call rank: {}'.format(call.rank))\n        employee = None\n        if call.rank == Rank.OPERATOR:\n            employee = self._dispatch_call(call, self.operators)\n        if call.rank == Rank.SUPERVISOR or employee is None:\n            employee = self._dispatch_call(call, self.supervisors)\n        if call.rank == Rank.DIRECTOR or employee is None:\n            employee = self._dispatch_call(call, self.directors)\n        if employee is None:\n            self.queued_calls.append(call)\n\n    def _dispatch_call(self, call, employees):\n        for employee in employees:\n            if employee.call is None:\n                employee.take_call(call)\n                return employee\n        return None\n\n    def notify_call_escalated(self, call):\n        pass\n\n    def notify_call_completed(self, call):\n        pass\n\n    def dispatch_queued_call_to_newly_freed_employee(self, call, employee):\n        pass\n", "solutions/object_oriented_design/call_center/__init__.py": ""}