{"main.py": "if __name__ == \"__main__\":\n    # Fix for linux\n    import multiprocessing\n    multiprocessing.set_start_method(\"spawn\")\n\n    from core.leras import nn\n    nn.initialize_main_env()\n    import os\n    import sys\n    import time\n    import argparse\n\n    from core import pathex\n    from core import osex\n    from pathlib import Path\n    from core.interact import interact as io\n\n    if sys.version_info[0] < 3 or (sys.version_info[0] == 3 and sys.version_info[1] < 6):\n        raise Exception(\"This program requires at least Python 3.6\")\n\n    class fixPathAction(argparse.Action):\n        def __call__(self, parser, namespace, values, option_string=None):\n            setattr(namespace, self.dest, os.path.abspath(os.path.expanduser(values)))\n\n    exit_code = 0\n    \n    parser = argparse.ArgumentParser()\n    subparsers = parser.add_subparsers()\n\n    def process_extract(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import Extractor\n        Extractor.main( detector                = arguments.detector,\n                        input_path              = Path(arguments.input_dir),\n                        output_path             = Path(arguments.output_dir),\n                        output_debug            = arguments.output_debug,\n                        manual_fix              = arguments.manual_fix,\n                        manual_output_debug_fix = arguments.manual_output_debug_fix,\n                        manual_window_size      = arguments.manual_window_size,\n                        face_type               = arguments.face_type,\n                        max_faces_from_image    = arguments.max_faces_from_image,\n                        image_size              = arguments.image_size,\n                        jpeg_quality            = arguments.jpeg_quality,\n                        cpu_only                = arguments.cpu_only,\n                        force_gpu_idxs          = [ int(x) for x in arguments.force_gpu_idxs.split(',') ] if arguments.force_gpu_idxs is not None else None,\n                      )\n\n    p = subparsers.add_parser( \"extract\", help=\"Extract the faces from a pictures.\")\n    p.add_argument('--detector', dest=\"detector\", choices=['s3fd','manual'], default=None, help=\"Type of detector.\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input directory. A directory containing the files you wish to process.\")\n    p.add_argument('--output-dir', required=True, action=fixPathAction, dest=\"output_dir\", help=\"Output directory. This is where the extracted files will be stored.\")\n    p.add_argument('--output-debug', action=\"store_true\", dest=\"output_debug\", default=None, help=\"Writes debug images to <output-dir>_debug\\ directory.\")\n    p.add_argument('--no-output-debug', action=\"store_false\", dest=\"output_debug\", default=None, help=\"Don't writes debug images to <output-dir>_debug\\ directory.\")\n    p.add_argument('--face-type', dest=\"face_type\", choices=['half_face', 'full_face', 'whole_face', 'head', 'mark_only'], default=None)\n    p.add_argument('--max-faces-from-image', type=int, dest=\"max_faces_from_image\", default=None, help=\"Max faces from image.\")    \n    p.add_argument('--image-size', type=int, dest=\"image_size\", default=None, help=\"Output image size.\")\n    p.add_argument('--jpeg-quality', type=int, dest=\"jpeg_quality\", default=None, help=\"Jpeg quality.\")    \n    p.add_argument('--manual-fix', action=\"store_true\", dest=\"manual_fix\", default=False, help=\"Enables manual extract only frames where faces were not recognized.\")\n    p.add_argument('--manual-output-debug-fix', action=\"store_true\", dest=\"manual_output_debug_fix\", default=False, help=\"Performs manual reextract input-dir frames which were deleted from [output_dir]_debug\\ dir.\")\n    p.add_argument('--manual-window-size', type=int, dest=\"manual_window_size\", default=1368, help=\"Manual fix window size. Default: 1368.\")\n    p.add_argument('--cpu-only', action=\"store_true\", dest=\"cpu_only\", default=False, help=\"Extract on CPU..\")\n    p.add_argument('--force-gpu-idxs', dest=\"force_gpu_idxs\", default=None, help=\"Force to choose GPU indexes separated by comma.\")\n\n    p.set_defaults (func=process_extract)\n\n    def process_sort(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import Sorter\n        Sorter.main (input_path=Path(arguments.input_dir), sort_by_method=arguments.sort_by_method)\n\n    p = subparsers.add_parser( \"sort\", help=\"Sort faces in a directory.\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input directory. A directory containing the files you wish to process.\")\n    p.add_argument('--by', dest=\"sort_by_method\", default=None, choices=(\"blur\", \"motion-blur\", \"face-yaw\", \"face-pitch\", \"face-source-rect-size\", \"hist\", \"hist-dissim\", \"brightness\", \"hue\", \"black\", \"origname\", \"oneface\", \"final-by-blur\", \"final-by-size\", \"absdiff\"), help=\"Method of sorting. 'origname' sort by original filename to recover original sequence.\" )\n    p.set_defaults (func=process_sort)\n\n    def process_util(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import Util\n\n        if arguments.add_landmarks_debug_images:\n            Util.add_landmarks_debug_images (input_path=arguments.input_dir)\n\n        if arguments.recover_original_aligned_filename:\n            Util.recover_original_aligned_filename (input_path=arguments.input_dir)\n\n        if arguments.save_faceset_metadata:\n            Util.save_faceset_metadata_folder (input_path=arguments.input_dir)\n\n        if arguments.restore_faceset_metadata:\n            Util.restore_faceset_metadata_folder (input_path=arguments.input_dir)\n\n        if arguments.pack_faceset:\n            io.log_info (\"Performing faceset packing...\\r\\n\")\n            from samplelib import PackedFaceset\n            PackedFaceset.pack( Path(arguments.input_dir) )\n\n        if arguments.unpack_faceset:\n            io.log_info (\"Performing faceset unpacking...\\r\\n\")\n            from samplelib import PackedFaceset\n            PackedFaceset.unpack( Path(arguments.input_dir) )\n            \n        if arguments.export_faceset_mask:\n            io.log_info (\"Exporting faceset mask..\\r\\n\")\n            Util.export_faceset_mask( Path(arguments.input_dir) )\n\n    p = subparsers.add_parser( \"util\", help=\"Utilities.\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input directory. A directory containing the files you wish to process.\")\n    p.add_argument('--add-landmarks-debug-images', action=\"store_true\", dest=\"add_landmarks_debug_images\", default=False, help=\"Add landmarks debug image for aligned faces.\")\n    p.add_argument('--recover-original-aligned-filename', action=\"store_true\", dest=\"recover_original_aligned_filename\", default=False, help=\"Recover original aligned filename.\")\n    p.add_argument('--save-faceset-metadata', action=\"store_true\", dest=\"save_faceset_metadata\", default=False, help=\"Save faceset metadata to file.\")\n    p.add_argument('--restore-faceset-metadata', action=\"store_true\", dest=\"restore_faceset_metadata\", default=False, help=\"Restore faceset metadata to file. Image filenames must be the same as used with save.\")\n    p.add_argument('--pack-faceset', action=\"store_true\", dest=\"pack_faceset\", default=False, help=\"\")\n    p.add_argument('--unpack-faceset', action=\"store_true\", dest=\"unpack_faceset\", default=False, help=\"\")\n    p.add_argument('--export-faceset-mask', action=\"store_true\", dest=\"export_faceset_mask\", default=False, help=\"\")\n\n    p.set_defaults (func=process_util)\n\n    def process_train(arguments):\n        osex.set_process_lowest_prio()\n\n\n        kwargs = {'model_class_name'         : arguments.model_name,\n                  'saved_models_path'        : Path(arguments.model_dir),\n                  'training_data_src_path'   : Path(arguments.training_data_src_dir),\n                  'training_data_dst_path'   : Path(arguments.training_data_dst_dir),\n                  'pretraining_data_path'    : Path(arguments.pretraining_data_dir) if arguments.pretraining_data_dir is not None else None,\n                  'pretrained_model_path'    : Path(arguments.pretrained_model_dir) if arguments.pretrained_model_dir is not None else None,\n                  'no_preview'               : arguments.no_preview,\n                  'force_model_name'         : arguments.force_model_name,\n                  'force_gpu_idxs'           : [ int(x) for x in arguments.force_gpu_idxs.split(',') ] if arguments.force_gpu_idxs is not None else None,\n                  'cpu_only'                 : arguments.cpu_only,\n                  'silent_start'             : arguments.silent_start,\n                  'execute_programs'         : [ [int(x[0]), x[1] ] for x in arguments.execute_program ],\n                  'debug'                    : arguments.debug,\n                  }\n        from mainscripts import Trainer\n        Trainer.main(**kwargs)\n\n    p = subparsers.add_parser( \"train\", help=\"Trainer\")\n    p.add_argument('--training-data-src-dir', required=True, action=fixPathAction, dest=\"training_data_src_dir\", help=\"Dir of extracted SRC faceset.\")\n    p.add_argument('--training-data-dst-dir', required=True, action=fixPathAction, dest=\"training_data_dst_dir\", help=\"Dir of extracted DST faceset.\")\n    p.add_argument('--pretraining-data-dir', action=fixPathAction, dest=\"pretraining_data_dir\", default=None, help=\"Optional dir of extracted faceset that will be used in pretraining mode.\")\n    p.add_argument('--pretrained-model-dir', action=fixPathAction, dest=\"pretrained_model_dir\", default=None, help=\"Optional dir of pretrain model files. (Currently only for Quick96).\")\n    p.add_argument('--model-dir', required=True, action=fixPathAction, dest=\"model_dir\", help=\"Saved models dir.\")\n    p.add_argument('--model', required=True, dest=\"model_name\", choices=pathex.get_all_dir_names_startswith ( Path(__file__).parent / 'models' , 'Model_'), help=\"Model class name.\")\n    p.add_argument('--debug', action=\"store_true\", dest=\"debug\", default=False, help=\"Debug samples.\")\n    p.add_argument('--no-preview', action=\"store_true\", dest=\"no_preview\", default=False, help=\"Disable preview window.\")\n    p.add_argument('--force-model-name', dest=\"force_model_name\", default=None, help=\"Forcing to choose model name from model/ folder.\")\n    p.add_argument('--cpu-only', action=\"store_true\", dest=\"cpu_only\", default=False, help=\"Train on CPU.\")\n    p.add_argument('--force-gpu-idxs', dest=\"force_gpu_idxs\", default=None, help=\"Force to choose GPU indexes separated by comma.\")\n    p.add_argument('--silent-start', action=\"store_true\", dest=\"silent_start\", default=False, help=\"Silent start. Automatically chooses Best GPU and last used model.\")\n    \n    p.add_argument('--execute-program', dest=\"execute_program\", default=[], action='append', nargs='+')\n    p.set_defaults (func=process_train)\n    \n    def process_exportdfm(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import ExportDFM\n        ExportDFM.main(model_class_name = arguments.model_name, saved_models_path = Path(arguments.model_dir))\n\n    p = subparsers.add_parser( \"exportdfm\", help=\"Export model to use in DeepFaceLive.\")\n    p.add_argument('--model-dir', required=True, action=fixPathAction, dest=\"model_dir\", help=\"Saved models dir.\")\n    p.add_argument('--model', required=True, dest=\"model_name\", choices=pathex.get_all_dir_names_startswith ( Path(__file__).parent / 'models' , 'Model_'), help=\"Model class name.\")\n    p.set_defaults (func=process_exportdfm)\n\n    def process_merge(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import Merger\n        Merger.main ( model_class_name       = arguments.model_name,\n                      saved_models_path      = Path(arguments.model_dir),\n                      force_model_name       = arguments.force_model_name,\n                      input_path             = Path(arguments.input_dir),\n                      output_path            = Path(arguments.output_dir),\n                      output_mask_path       = Path(arguments.output_mask_dir),\n                      aligned_path           = Path(arguments.aligned_dir) if arguments.aligned_dir is not None else None,\n                      force_gpu_idxs         = arguments.force_gpu_idxs,\n                      cpu_only               = arguments.cpu_only)\n\n    p = subparsers.add_parser( \"merge\", help=\"Merger\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input directory. A directory containing the files you wish to process.\")\n    p.add_argument('--output-dir', required=True, action=fixPathAction, dest=\"output_dir\", help=\"Output directory. This is where the merged files will be stored.\")\n    p.add_argument('--output-mask-dir', required=True, action=fixPathAction, dest=\"output_mask_dir\", help=\"Output mask directory. This is where the mask files will be stored.\")\n    p.add_argument('--aligned-dir', action=fixPathAction, dest=\"aligned_dir\", default=None, help=\"Aligned directory. This is where the extracted of dst faces stored.\")\n    p.add_argument('--model-dir', required=True, action=fixPathAction, dest=\"model_dir\", help=\"Model dir.\")\n    p.add_argument('--model', required=True, dest=\"model_name\", choices=pathex.get_all_dir_names_startswith ( Path(__file__).parent / 'models' , 'Model_'), help=\"Model class name.\")\n    p.add_argument('--force-model-name', dest=\"force_model_name\", default=None, help=\"Forcing to choose model name from model/ folder.\")\n    p.add_argument('--cpu-only', action=\"store_true\", dest=\"cpu_only\", default=False, help=\"Merge on CPU.\")\n    p.add_argument('--force-gpu-idxs', dest=\"force_gpu_idxs\", default=None, help=\"Force to choose GPU indexes separated by comma.\")\n    p.set_defaults(func=process_merge)\n\n    videoed_parser = subparsers.add_parser( \"videoed\", help=\"Video processing.\").add_subparsers()\n\n    def process_videoed_extract_video(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import VideoEd\n        VideoEd.extract_video (arguments.input_file, arguments.output_dir, arguments.output_ext, arguments.fps)\n    p = videoed_parser.add_parser( \"extract-video\", help=\"Extract images from video file.\")\n    p.add_argument('--input-file', required=True, action=fixPathAction, dest=\"input_file\", help=\"Input file to be processed. Specify .*-extension to find first file.\")\n    p.add_argument('--output-dir', required=True, action=fixPathAction, dest=\"output_dir\", help=\"Output directory. This is where the extracted images will be stored.\")\n    p.add_argument('--output-ext', dest=\"output_ext\", default=None, help=\"Image format (extension) of output files.\")\n    p.add_argument('--fps', type=int, dest=\"fps\", default=None, help=\"How many frames of every second of the video will be extracted. 0 - full fps.\")\n    p.set_defaults(func=process_videoed_extract_video)\n\n    def process_videoed_cut_video(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import VideoEd\n        VideoEd.cut_video (arguments.input_file,\n                           arguments.from_time,\n                           arguments.to_time,\n                           arguments.audio_track_id,\n                           arguments.bitrate)\n    p = videoed_parser.add_parser( \"cut-video\", help=\"Cut video file.\")\n    p.add_argument('--input-file', required=True, action=fixPathAction, dest=\"input_file\", help=\"Input file to be processed. Specify .*-extension to find first file.\")\n    p.add_argument('--from-time', dest=\"from_time\", default=None, help=\"From time, for example 00:00:00.000\")\n    p.add_argument('--to-time', dest=\"to_time\", default=None, help=\"To time, for example 00:00:00.000\")\n    p.add_argument('--audio-track-id', type=int, dest=\"audio_track_id\", default=None, help=\"Specify audio track id.\")\n    p.add_argument('--bitrate', type=int, dest=\"bitrate\", default=None, help=\"Bitrate of output file in Megabits.\")\n    p.set_defaults(func=process_videoed_cut_video)\n\n    def process_videoed_denoise_image_sequence(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import VideoEd\n        VideoEd.denoise_image_sequence (arguments.input_dir, arguments.factor)\n    p = videoed_parser.add_parser( \"denoise-image-sequence\", help=\"Denoise sequence of images, keeping sharp edges. Helps to remove pixel shake from the predicted face.\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input directory to be processed.\")\n    p.add_argument('--factor', type=int, dest=\"factor\", default=None, help=\"Denoise factor (1-20).\")\n    p.set_defaults(func=process_videoed_denoise_image_sequence)\n\n    def process_videoed_video_from_sequence(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import VideoEd\n        VideoEd.video_from_sequence (input_dir      = arguments.input_dir,\n                                     output_file    = arguments.output_file,\n                                     reference_file = arguments.reference_file,\n                                     ext      = arguments.ext,\n                                     fps      = arguments.fps,\n                                     bitrate  = arguments.bitrate,\n                                     include_audio = arguments.include_audio,\n                                     lossless = arguments.lossless)\n\n    p = videoed_parser.add_parser( \"video-from-sequence\", help=\"Make video from image sequence.\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input file to be processed. Specify .*-extension to find first file.\")\n    p.add_argument('--output-file', required=True, action=fixPathAction, dest=\"output_file\", help=\"Input file to be processed. Specify .*-extension to find first file.\")\n    p.add_argument('--reference-file', action=fixPathAction, dest=\"reference_file\", help=\"Reference file used to determine proper FPS and transfer audio from it. Specify .*-extension to find first file.\")\n    p.add_argument('--ext', dest=\"ext\", default='png', help=\"Image format (extension) of input files.\")\n    p.add_argument('--fps', type=int, dest=\"fps\", default=None, help=\"FPS of output file. Overwritten by reference-file.\")\n    p.add_argument('--bitrate', type=int, dest=\"bitrate\", default=None, help=\"Bitrate of output file in Megabits.\")\n    p.add_argument('--include-audio', action=\"store_true\", dest=\"include_audio\", default=False, help=\"Include audio from reference file.\")\n    p.add_argument('--lossless', action=\"store_true\", dest=\"lossless\", default=False, help=\"PNG codec.\")\n\n    p.set_defaults(func=process_videoed_video_from_sequence)\n\n    facesettool_parser = subparsers.add_parser( \"facesettool\", help=\"Faceset tools.\").add_subparsers()\n\n    def process_faceset_enhancer(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import FacesetEnhancer\n        FacesetEnhancer.process_folder ( Path(arguments.input_dir),\n                                         cpu_only=arguments.cpu_only,\n                                         force_gpu_idxs=arguments.force_gpu_idxs\n                                       )\n\n    p = facesettool_parser.add_parser (\"enhance\", help=\"Enhance details in DFL faceset.\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input directory of aligned faces.\")\n    p.add_argument('--cpu-only', action=\"store_true\", dest=\"cpu_only\", default=False, help=\"Process on CPU.\")\n    p.add_argument('--force-gpu-idxs', dest=\"force_gpu_idxs\", default=None, help=\"Force to choose GPU indexes separated by comma.\")\n\n    p.set_defaults(func=process_faceset_enhancer)\n    \n    \n    p = facesettool_parser.add_parser (\"resize\", help=\"Resize DFL faceset.\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\", help=\"Input directory of aligned faces.\")\n\n    def process_faceset_resizer(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import FacesetResizer\n        FacesetResizer.process_folder ( Path(arguments.input_dir) )\n    p.set_defaults(func=process_faceset_resizer)\n\n    def process_dev_test(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import dev_misc\n        dev_misc.dev_gen_mask_files( arguments.input_dir )\n\n    p = subparsers.add_parser( \"dev_test\", help=\"\")\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\")\n    p.set_defaults (func=process_dev_test)\n    \n    # ========== XSeg\n    xseg_parser = subparsers.add_parser( \"xseg\", help=\"XSeg tools.\").add_subparsers()\n    \n    p = xseg_parser.add_parser( \"editor\", help=\"XSeg editor.\")\n\n    def process_xsegeditor(arguments):\n        osex.set_process_lowest_prio()\n        from XSegEditor import XSegEditor\n        global exit_code\n        exit_code = XSegEditor.start (Path(arguments.input_dir))\n        \n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\")\n\n    p.set_defaults (func=process_xsegeditor)\n  \n    p = xseg_parser.add_parser( \"apply\", help=\"Apply trained XSeg model to the extracted faces.\")\n\n    def process_xsegapply(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import XSegUtil\n        XSegUtil.apply_xseg (Path(arguments.input_dir), Path(arguments.model_dir))\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\")\n    p.add_argument('--model-dir', required=True, action=fixPathAction, dest=\"model_dir\")\n    p.set_defaults (func=process_xsegapply)\n    \n    \n    p = xseg_parser.add_parser( \"remove\", help=\"Remove applied XSeg masks from the extracted faces.\")\n    def process_xsegremove(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import XSegUtil\n        XSegUtil.remove_xseg (Path(arguments.input_dir) )\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\")\n    p.set_defaults (func=process_xsegremove)\n    \n    \n    p = xseg_parser.add_parser( \"remove_labels\", help=\"Remove XSeg labels from the extracted faces.\")\n    def process_xsegremovelabels(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import XSegUtil\n        XSegUtil.remove_xseg_labels (Path(arguments.input_dir) )\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\")\n    p.set_defaults (func=process_xsegremovelabels)\n    \n    \n    p = xseg_parser.add_parser( \"fetch\", help=\"Copies faces containing XSeg polygons in <input_dir>_xseg dir.\")\n\n    def process_xsegfetch(arguments):\n        osex.set_process_lowest_prio()\n        from mainscripts import XSegUtil\n        XSegUtil.fetch_xseg (Path(arguments.input_dir) )\n    p.add_argument('--input-dir', required=True, action=fixPathAction, dest=\"input_dir\")\n    p.set_defaults (func=process_xsegfetch)\n    \n    def bad_args(arguments):\n        parser.print_help()\n        exit(0)\n    parser.set_defaults(func=bad_args)\n\n    arguments = parser.parse_args()\n    arguments.func(arguments)\n\n    if exit_code == 0:\n        print (\"Done.\")\n        \n    exit(exit_code)\n    \n'''\nimport code\ncode.interact(local=dict(globals(), **locals()))\n'''\n", "merger/MergeAvatar.py": "import cv2\nimport numpy as np\n\nfrom core import imagelib\nfrom facelib import FaceType, LandmarksProcessor\nfrom core.cv2ex import *\n\ndef process_frame_info(frame_info, inp_sh):\n    img_uint8 = cv2_imread (frame_info.filename)\n    img_uint8 = imagelib.normalize_channels (img_uint8, 3)\n    img = img_uint8.astype(np.float32) / 255.0\n\n    img_mat = LandmarksProcessor.get_transform_mat (frame_info.landmarks_list[0], inp_sh[0], face_type=FaceType.FULL_NO_ALIGN)\n    img = cv2.warpAffine( img, img_mat, inp_sh[0:2], borderMode=cv2.BORDER_REPLICATE, flags=cv2.INTER_CUBIC )\n    return img\n\ndef MergeFaceAvatar (predictor_func, predictor_input_shape, cfg, prev_temporal_frame_infos, frame_info, next_temporal_frame_infos):\n    inp_sh = predictor_input_shape\n\n    prev_imgs=[]\n    next_imgs=[]\n    for i in range(cfg.temporal_face_count):\n        prev_imgs.append( process_frame_info(prev_temporal_frame_infos[i], inp_sh) )\n        next_imgs.append( process_frame_info(next_temporal_frame_infos[i], inp_sh) )\n    img = process_frame_info(frame_info, inp_sh)\n\n    prd_f = predictor_func ( prev_imgs, img, next_imgs )\n\n    #if cfg.super_resolution_mode != 0:\n    #    prd_f = cfg.superres_func(cfg.super_resolution_mode, prd_f)\n\n    if cfg.sharpen_mode != 0 and cfg.sharpen_amount != 0:\n        prd_f = cfg.sharpen_func ( prd_f, cfg.sharpen_mode, 3, cfg.sharpen_amount)\n\n    out_img = np.clip(prd_f, 0.0, 1.0)\n\n    if cfg.add_source_image:\n        out_img = np.concatenate ( [cv2.resize ( img, (prd_f.shape[1], prd_f.shape[0])  ),\n                                    out_img], axis=1 )\n\n    return (out_img*255).astype(np.uint8)\n", "merger/FrameInfo.py": "from pathlib import Path\n\nclass FrameInfo(object):\n    def __init__(self, filepath=None, landmarks_list=None):\n        self.filepath = filepath\n        self.landmarks_list = landmarks_list or []\n        self.motion_deg = 0\n        self.motion_power = 0", "merger/InteractiveMergerSubprocessor.py": "import multiprocessing\nimport os\nimport pickle\nimport sys\nimport traceback\nfrom pathlib import Path\n\nimport numpy as np\n\nfrom core import imagelib, pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor\nfrom merger import MergeFaceAvatar, MergeMasked, MergerConfig\n\nfrom .MergerScreen import Screen, ScreenManager\n\nMERGER_DEBUG = False\nclass InteractiveMergerSubprocessor(Subprocessor):\n\n    class Frame(object):\n        def __init__(self, prev_temporal_frame_infos=None,\n                           frame_info=None,\n                           next_temporal_frame_infos=None):\n            self.prev_temporal_frame_infos = prev_temporal_frame_infos\n            self.frame_info = frame_info\n            self.next_temporal_frame_infos = next_temporal_frame_infos\n            self.output_filepath = None\n            self.output_mask_filepath = None\n\n            self.idx = None\n            self.cfg = None\n            self.is_done = False\n            self.is_processing = False\n            self.is_shown = False\n            self.image = None\n\n    class ProcessingFrame(object):\n        def __init__(self, idx=None,\n                           cfg=None,\n                           prev_temporal_frame_infos=None,\n                           frame_info=None,\n                           next_temporal_frame_infos=None,\n                           output_filepath=None,\n                           output_mask_filepath=None,\n                           need_return_image = False):\n            self.idx = idx\n            self.cfg = cfg\n            self.prev_temporal_frame_infos = prev_temporal_frame_infos\n            self.frame_info = frame_info\n            self.next_temporal_frame_infos = next_temporal_frame_infos\n            self.output_filepath = output_filepath\n            self.output_mask_filepath = output_mask_filepath\n\n            self.need_return_image = need_return_image\n            if self.need_return_image:\n                self.image = None\n\n    class Cli(Subprocessor.Cli):\n\n        #override\n        def on_initialize(self, client_dict):\n            self.log_info ('Running on %s.' % (client_dict['device_name']) )\n            self.device_idx  = client_dict['device_idx']\n            self.device_name = client_dict['device_name']\n            self.predictor_func = client_dict['predictor_func']\n            self.predictor_input_shape = client_dict['predictor_input_shape']\n            self.face_enhancer_func = client_dict['face_enhancer_func']\n            self.xseg_256_extract_func = client_dict['xseg_256_extract_func']\n\n\n            #transfer and set stdin in order to work code.interact in debug subprocess\n            stdin_fd         = client_dict['stdin_fd']\n            if stdin_fd is not None:\n                sys.stdin = os.fdopen(stdin_fd)\n\n            return None\n\n        #override\n        def process_data(self, pf): #pf=ProcessingFrame\n            cfg = pf.cfg.copy()\n\n            frame_info = pf.frame_info\n            filepath = frame_info.filepath\n\n            if len(frame_info.landmarks_list) == 0:\n                \n                if cfg.mode == 'raw-predict':        \n                    h,w,c = self.predictor_input_shape\n                    img_bgr = np.zeros( (h,w,3), dtype=np.uint8)\n                    img_mask = np.zeros( (h,w,1), dtype=np.uint8)               \n                else:                \n                    self.log_info (f'no faces found for {filepath.name}, copying without faces')\n                    img_bgr = cv2_imread(filepath)\n                    imagelib.normalize_channels(img_bgr, 3)                    \n                    h,w,c = img_bgr.shape\n                    img_mask = np.zeros( (h,w,1), dtype=img_bgr.dtype)\n                    \n                cv2_imwrite (pf.output_filepath, img_bgr)\n                cv2_imwrite (pf.output_mask_filepath, img_mask)\n\n                if pf.need_return_image:\n                    pf.image = np.concatenate ([img_bgr, img_mask], axis=-1)\n\n            else:\n                if cfg.type == MergerConfig.TYPE_MASKED:\n                    try:\n                        final_img = MergeMasked (self.predictor_func, self.predictor_input_shape,\n                                                 face_enhancer_func=self.face_enhancer_func,\n                                                 xseg_256_extract_func=self.xseg_256_extract_func,\n                                                 cfg=cfg,\n                                                 frame_info=frame_info)\n                    except Exception as e:\n                        e_str = traceback.format_exc()\n                        if 'MemoryError' in e_str:\n                            raise Subprocessor.SilenceException\n                        else:\n                            raise Exception( f'Error while merging file [{filepath}]: {e_str}' )\n\n                elif cfg.type == MergerConfig.TYPE_FACE_AVATAR:\n                    final_img = MergeFaceAvatar (self.predictor_func, self.predictor_input_shape,\n                                                   cfg, pf.prev_temporal_frame_infos,\n                                                        pf.frame_info,\n                                                        pf.next_temporal_frame_infos )\n\n                cv2_imwrite (pf.output_filepath,      final_img[...,0:3] )\n                cv2_imwrite (pf.output_mask_filepath, final_img[...,3:4] )\n\n                if pf.need_return_image:\n                    pf.image = final_img\n\n            return pf\n\n        #overridable\n        def get_data_name (self, pf):\n            #return string identificator of your data\n            return pf.frame_info.filepath\n\n\n\n\n    #override\n    def __init__(self, is_interactive, merger_session_filepath, predictor_func, predictor_input_shape, face_enhancer_func, xseg_256_extract_func, merger_config, frames, frames_root_path, output_path, output_mask_path, model_iter, subprocess_count=4):\n        if len (frames) == 0:\n            raise ValueError (\"len (frames) == 0\")\n\n        super().__init__('Merger', InteractiveMergerSubprocessor.Cli, io_loop_sleep_time=0.001)\n\n        self.is_interactive = is_interactive\n        self.merger_session_filepath = Path(merger_session_filepath)\n        self.merger_config = merger_config\n\n        self.predictor_func = predictor_func\n        self.predictor_input_shape = predictor_input_shape\n\n        self.face_enhancer_func = face_enhancer_func\n        self.xseg_256_extract_func = xseg_256_extract_func\n\n        self.frames_root_path = frames_root_path\n        self.output_path = output_path\n        self.output_mask_path = output_mask_path\n        self.model_iter = model_iter\n\n        self.prefetch_frame_count = self.process_count = subprocess_count\n\n        session_data = None\n        if self.is_interactive and self.merger_session_filepath.exists():\n            io.input_skip_pending()\n            if io.input_bool (\"Use saved session?\", True):\n                try:\n                    with open( str(self.merger_session_filepath), \"rb\") as f:\n                        session_data = pickle.loads(f.read())\n\n                except Exception as e:\n                    pass\n\n        rewind_to_frame_idx = None\n        self.frames = frames\n        self.frames_idxs = [ *range(len(self.frames)) ]\n        self.frames_done_idxs = []\n\n        if self.is_interactive and session_data is not None:\n            # Loaded session data, check it\n            s_frames = session_data.get('frames', None)\n            s_frames_idxs = session_data.get('frames_idxs', None)\n            s_frames_done_idxs = session_data.get('frames_done_idxs', None)\n            s_model_iter = session_data.get('model_iter', None)\n\n            frames_equal = (s_frames is not None) and \\\n                           (s_frames_idxs is not None) and \\\n                           (s_frames_done_idxs is not None) and \\\n                           (s_model_iter is not None) and \\\n                           (len(frames) == len(s_frames)) # frames count must match\n\n            if frames_equal:\n                for i in range(len(frames)):\n                    frame = frames[i]\n                    s_frame = s_frames[i]\n                    # frames filenames must match\n                    if frame.frame_info.filepath.name != s_frame.frame_info.filepath.name:\n                        frames_equal = False\n                    if not frames_equal:\n                        break\n\n            if frames_equal:\n                io.log_info ('Using saved session from ' + '/'.join (self.merger_session_filepath.parts[-2:]) )\n\n                for frame in s_frames:\n                    if frame.cfg is not None:\n                        # recreate MergerConfig class using constructor with get_config() as dict params\n                        # so if any new param will be added, old merger session will work properly\n                        frame.cfg = frame.cfg.__class__( **frame.cfg.get_config() )\n\n                self.frames = s_frames\n                self.frames_idxs = s_frames_idxs\n                self.frames_done_idxs = s_frames_done_idxs\n\n                if self.model_iter != s_model_iter:\n                    # model was more trained, recompute all frames\n                    rewind_to_frame_idx = -1\n                    for frame in self.frames:\n                        frame.is_done = False\n                elif len(self.frames_idxs) == 0:\n                    # all frames are done?\n                    rewind_to_frame_idx = -1\n\n                if len(self.frames_idxs) != 0:\n                    cur_frame = self.frames[self.frames_idxs[0]]\n                    cur_frame.is_shown = False\n\n            if not frames_equal:\n                session_data = None\n\n        if session_data is None:\n            for filename in pathex.get_image_paths(self.output_path): #remove all images in output_path\n                Path(filename).unlink()\n\n            for filename in pathex.get_image_paths(self.output_mask_path): #remove all images in output_mask_path\n                Path(filename).unlink()\n\n\n            frames[0].cfg = self.merger_config.copy()\n\n        for i in range( len(self.frames) ):\n            frame = self.frames[i]\n            frame.idx = i\n            frame.output_filepath      = self.output_path      / ( frame.frame_info.filepath.stem + '.png' )\n            frame.output_mask_filepath = self.output_mask_path / ( frame.frame_info.filepath.stem + '.png' )\n\n            if not frame.output_filepath.exists() or \\\n               not frame.output_mask_filepath.exists():\n                # if some frame does not exist, recompute and rewind\n                frame.is_done = False\n                frame.is_shown = False\n\n                if rewind_to_frame_idx is None:\n                    rewind_to_frame_idx = i-1\n                else:\n                    rewind_to_frame_idx = min(rewind_to_frame_idx, i-1)\n\n        if rewind_to_frame_idx is not None:\n            while len(self.frames_done_idxs) > 0:\n                if self.frames_done_idxs[-1] > rewind_to_frame_idx:\n                    prev_frame = self.frames[self.frames_done_idxs.pop()]\n                    self.frames_idxs.insert(0, prev_frame.idx)\n                else:\n                    break\n    #override\n    def process_info_generator(self):\n        r = [0] if MERGER_DEBUG else range(self.process_count)\n\n        for i in r:\n            yield 'CPU%d' % (i), {}, {'device_idx': i,\n                                      'device_name': 'CPU%d' % (i),\n                                      'predictor_func': self.predictor_func,\n                                      'predictor_input_shape' : self.predictor_input_shape,\n                                      'face_enhancer_func': self.face_enhancer_func,\n                                      'xseg_256_extract_func' : self.xseg_256_extract_func,\n                                      'stdin_fd': sys.stdin.fileno() if MERGER_DEBUG else None\n                                      }\n\n    #overridable optional\n    def on_clients_initialized(self):\n        io.progress_bar (\"Merging\", len(self.frames_idxs)+len(self.frames_done_idxs), initial=len(self.frames_done_idxs) )\n\n        self.process_remain_frames = not self.is_interactive\n        self.is_interactive_quitting = not self.is_interactive\n\n        if self.is_interactive:\n            help_images = {\n                    MergerConfig.TYPE_MASKED :      cv2_imread ( str(Path(__file__).parent / 'gfx' / 'help_merger_masked.jpg') ),\n                    MergerConfig.TYPE_FACE_AVATAR : cv2_imread ( str(Path(__file__).parent / 'gfx' / 'help_merger_face_avatar.jpg') ),\n                }\n\n            self.main_screen = Screen(initial_scale_to_width=1368, image=None, waiting_icon=True)\n            self.help_screen = Screen(initial_scale_to_height=768, image=help_images[self.merger_config.type], waiting_icon=False)\n            self.screen_manager = ScreenManager( \"Merger\", [self.main_screen, self.help_screen], capture_keys=True )\n            self.screen_manager.set_current (self.help_screen)\n            self.screen_manager.show_current()\n\n            self.masked_keys_funcs = {\n                    '`' : lambda cfg,shift_pressed: cfg.set_mode(0),\n                    '1' : lambda cfg,shift_pressed: cfg.set_mode(1),\n                    '2' : lambda cfg,shift_pressed: cfg.set_mode(2),\n                    '3' : lambda cfg,shift_pressed: cfg.set_mode(3),\n                    '4' : lambda cfg,shift_pressed: cfg.set_mode(4),\n                    '5' : lambda cfg,shift_pressed: cfg.set_mode(5),\n                    '6' : lambda cfg,shift_pressed: cfg.set_mode(6),\n                    'q' : lambda cfg,shift_pressed: cfg.add_hist_match_threshold(1 if not shift_pressed else 5),\n                    'a' : lambda cfg,shift_pressed: cfg.add_hist_match_threshold(-1 if not shift_pressed else -5),\n                    'w' : lambda cfg,shift_pressed: cfg.add_erode_mask_modifier(1 if not shift_pressed else 5),\n                    's' : lambda cfg,shift_pressed: cfg.add_erode_mask_modifier(-1 if not shift_pressed else -5),\n                    'e' : lambda cfg,shift_pressed: cfg.add_blur_mask_modifier(1 if not shift_pressed else 5),\n                    'd' : lambda cfg,shift_pressed: cfg.add_blur_mask_modifier(-1 if not shift_pressed else -5),\n                    'r' : lambda cfg,shift_pressed: cfg.add_motion_blur_power(1 if not shift_pressed else 5),\n                    'f' : lambda cfg,shift_pressed: cfg.add_motion_blur_power(-1 if not shift_pressed else -5),\n                    't' : lambda cfg,shift_pressed: cfg.add_super_resolution_power(1 if not shift_pressed else 5),\n                    'g' : lambda cfg,shift_pressed: cfg.add_super_resolution_power(-1 if not shift_pressed else -5),\n                    'y' : lambda cfg,shift_pressed: cfg.add_blursharpen_amount(1 if not shift_pressed else 5),\n                    'h' : lambda cfg,shift_pressed: cfg.add_blursharpen_amount(-1 if not shift_pressed else -5),\n                    'u' : lambda cfg,shift_pressed: cfg.add_output_face_scale(1 if not shift_pressed else 5),\n                    'j' : lambda cfg,shift_pressed: cfg.add_output_face_scale(-1 if not shift_pressed else -5),\n                    'i' : lambda cfg,shift_pressed: cfg.add_image_denoise_power(1 if not shift_pressed else 5),\n                    'k' : lambda cfg,shift_pressed: cfg.add_image_denoise_power(-1 if not shift_pressed else -5),\n                    'o' : lambda cfg,shift_pressed: cfg.add_bicubic_degrade_power(1 if not shift_pressed else 5),\n                    'l' : lambda cfg,shift_pressed: cfg.add_bicubic_degrade_power(-1 if not shift_pressed else -5),\n                    'p' : lambda cfg,shift_pressed: cfg.add_color_degrade_power(1 if not shift_pressed else 5),\n                    ';' : lambda cfg,shift_pressed: cfg.add_color_degrade_power(-1),\n                    ':' : lambda cfg,shift_pressed: cfg.add_color_degrade_power(-5),\n                    'z' : lambda cfg,shift_pressed: cfg.toggle_masked_hist_match(),\n                    'x' : lambda cfg,shift_pressed: cfg.toggle_mask_mode(),\n                    'c' : lambda cfg,shift_pressed: cfg.toggle_color_transfer_mode(),\n                    'n' : lambda cfg,shift_pressed: cfg.toggle_sharpen_mode(),\n                    }\n            self.masked_keys = list(self.masked_keys_funcs.keys())\n\n    #overridable optional\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n        if self.is_interactive:\n            self.screen_manager.finalize()\n\n            for frame in self.frames:\n                frame.output_filepath = None\n                frame.output_mask_filepath = None\n                frame.image = None\n\n            session_data = {\n                'frames': self.frames,\n                'frames_idxs': self.frames_idxs,\n                'frames_done_idxs': self.frames_done_idxs,\n                'model_iter' : self.model_iter,\n            }\n            self.merger_session_filepath.write_bytes( pickle.dumps(session_data) )\n\n            io.log_info (\"Session is saved to \" + '/'.join (self.merger_session_filepath.parts[-2:]) )\n\n    #override\n    def on_tick(self):\n        io.process_messages()\n\n        go_prev_frame = False\n        go_first_frame = False\n        go_prev_frame_overriding_cfg = False\n        go_first_frame_overriding_cfg = False\n\n        go_next_frame = self.process_remain_frames\n        go_next_frame_overriding_cfg = False\n        go_last_frame_overriding_cfg = False\n\n        cur_frame = None\n        if len(self.frames_idxs) != 0:\n            cur_frame = self.frames[self.frames_idxs[0]]\n\n        if self.is_interactive:\n\n            screen_image = None if self.process_remain_frames else \\\n                                   self.main_screen.get_image()\n\n            self.main_screen.set_waiting_icon( self.process_remain_frames or \\\n                                               self.is_interactive_quitting )\n\n            if cur_frame is not None and not self.is_interactive_quitting:\n\n                if not self.process_remain_frames:\n                    if cur_frame.is_done:\n                        if not cur_frame.is_shown:\n                            if cur_frame.image is None:\n                                image      = cv2_imread (cur_frame.output_filepath, verbose=False)\n                                image_mask = cv2_imread (cur_frame.output_mask_filepath, verbose=False)\n                                if image is None or image_mask is None:\n                                    # unable to read? recompute then\n                                    cur_frame.is_done = False\n                                else:\n                                    image = imagelib.normalize_channels(image, 3)\n                                    image_mask = imagelib.normalize_channels(image_mask, 1)\n                                    cur_frame.image = np.concatenate([image, image_mask], -1)\n\n                            if cur_frame.is_done:\n                                io.log_info (cur_frame.cfg.to_string( cur_frame.frame_info.filepath.name) )\n                                cur_frame.is_shown = True\n                                screen_image = cur_frame.image\n                    else:\n                        self.main_screen.set_waiting_icon(True)\n\n            self.main_screen.set_image(screen_image)\n            self.screen_manager.show_current()\n\n            key_events = self.screen_manager.get_key_events()\n            key, chr_key, ctrl_pressed, alt_pressed, shift_pressed = key_events[-1] if len(key_events) > 0 else (0,0,False,False,False)\n\n            if key == 9: #tab\n                self.screen_manager.switch_screens()\n            else:\n                if key == 27: #esc\n                    self.is_interactive_quitting = True\n                elif self.screen_manager.get_current() is self.main_screen:\n\n                    if self.merger_config.type == MergerConfig.TYPE_MASKED and chr_key in self.masked_keys:\n                        self.process_remain_frames = False\n\n                        if cur_frame is not None:\n                            cfg = cur_frame.cfg\n                            prev_cfg = cfg.copy()\n\n                            if cfg.type == MergerConfig.TYPE_MASKED:\n                                self.masked_keys_funcs[chr_key](cfg, shift_pressed)\n\n                            if prev_cfg != cfg:\n                                io.log_info ( cfg.to_string(cur_frame.frame_info.filepath.name) )\n                                cur_frame.is_done = False\n                                cur_frame.is_shown = False\n                    else:\n\n                        if chr_key == ',' or chr_key == 'm':\n                            self.process_remain_frames = False\n                            go_prev_frame = True\n\n                            if chr_key == ',':\n                                if shift_pressed:\n                                    go_first_frame = True\n\n                            elif chr_key == 'm':\n                                if not shift_pressed:\n                                    go_prev_frame_overriding_cfg = True\n                                else:\n                                    go_first_frame_overriding_cfg = True\n\n                        elif chr_key == '.' or chr_key == '/':\n                            self.process_remain_frames = False\n                            go_next_frame = True\n\n                            if chr_key == '.':\n                                if shift_pressed:\n                                    self.process_remain_frames = not self.process_remain_frames\n\n                            elif chr_key == '/':\n                                if not shift_pressed:\n                                    go_next_frame_overriding_cfg = True\n                                else:\n                                    go_last_frame_overriding_cfg = True\n\n                        elif chr_key == '-':\n                            self.screen_manager.get_current().diff_scale(-0.1)\n                        elif chr_key == '=':\n                            self.screen_manager.get_current().diff_scale(0.1)\n                        elif chr_key == 'v':\n                            self.screen_manager.get_current().toggle_show_checker_board()\n\n        if go_prev_frame:\n            if cur_frame is None or cur_frame.is_done:\n                if cur_frame is not None:\n                    cur_frame.image = None\n\n                while True:\n                    if len(self.frames_done_idxs) > 0:\n                        prev_frame = self.frames[self.frames_done_idxs.pop()]\n                        self.frames_idxs.insert(0, prev_frame.idx)\n                        prev_frame.is_shown = False\n                        io.progress_bar_inc(-1)\n\n                        if cur_frame is not None and (go_prev_frame_overriding_cfg or go_first_frame_overriding_cfg):\n                            if prev_frame.cfg != cur_frame.cfg:\n                                prev_frame.cfg = cur_frame.cfg.copy()\n                                prev_frame.is_done = False\n\n                        cur_frame = prev_frame\n\n                    if go_first_frame_overriding_cfg or go_first_frame:\n                        if len(self.frames_done_idxs) > 0:\n                            continue\n                    break\n\n        elif go_next_frame:\n            if cur_frame is not None and cur_frame.is_done:\n                cur_frame.image = None\n                cur_frame.is_shown = True\n                self.frames_done_idxs.append(cur_frame.idx)\n                self.frames_idxs.pop(0)\n                io.progress_bar_inc(1)\n\n                f = self.frames\n\n                if len(self.frames_idxs) != 0:\n                    next_frame = f[ self.frames_idxs[0] ]\n                    next_frame.is_shown = False\n\n                    if go_next_frame_overriding_cfg or go_last_frame_overriding_cfg:\n\n                        if go_next_frame_overriding_cfg:\n                            to_frames = next_frame.idx+1\n                        else:\n                            to_frames = len(f)\n\n                        for i in range( next_frame.idx, to_frames ):\n                            f[i].cfg = None\n\n                    for i in range( min(len(self.frames_idxs), self.prefetch_frame_count) ):\n                        frame = f[ self.frames_idxs[i] ]\n                        if frame.cfg is None:\n                            if i == 0:\n                                frame.cfg = cur_frame.cfg.copy()\n                            else:\n                                frame.cfg = f[ self.frames_idxs[i-1] ].cfg.copy()\n\n                            frame.is_done = False #initiate solve again\n                            frame.is_shown = False\n\n            if len(self.frames_idxs) == 0:\n                self.process_remain_frames = False\n\n        return (self.is_interactive and self.is_interactive_quitting) or \\\n               (not self.is_interactive and self.process_remain_frames == False)\n\n\n    #override\n    def on_data_return (self, host_dict, pf):\n        frame = self.frames[pf.idx]\n        frame.is_done = False\n        frame.is_processing = False\n\n    #override\n    def on_result (self, host_dict, pf_sent, pf_result):\n        frame = self.frames[pf_result.idx]\n        frame.is_processing = False\n        if frame.cfg == pf_result.cfg:\n            frame.is_done = True\n            frame.image = pf_result.image\n\n    #override\n    def get_data(self, host_dict):\n        if self.is_interactive and self.is_interactive_quitting:\n            return None\n\n        for i in range ( min(len(self.frames_idxs), self.prefetch_frame_count) ):\n            frame = self.frames[ self.frames_idxs[i] ]\n\n            if not frame.is_done and not frame.is_processing and frame.cfg is not None:\n                frame.is_processing = True\n                return InteractiveMergerSubprocessor.ProcessingFrame(idx=frame.idx,\n                                                           cfg=frame.cfg.copy(),\n                                                           prev_temporal_frame_infos=frame.prev_temporal_frame_infos,\n                                                           frame_info=frame.frame_info,\n                                                           next_temporal_frame_infos=frame.next_temporal_frame_infos,\n                                                           output_filepath=frame.output_filepath,\n                                                           output_mask_filepath=frame.output_mask_filepath,\n                                                           need_return_image=True )\n\n        return None\n\n    #override\n    def get_result(self):\n        return 0", "merger/MergeMasked.py": "import sys\nimport traceback\n\nimport cv2\nimport numpy as np\n\nfrom core import imagelib\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom facelib import FaceType, LandmarksProcessor\n\nis_windows = sys.platform[0:3] == 'win'\nxseg_input_size = 256\n\ndef MergeMaskedFace (predictor_func, predictor_input_shape,\n                     face_enhancer_func,\n                     xseg_256_extract_func,\n                     cfg, frame_info, img_bgr_uint8, img_bgr, img_face_landmarks):\n\n    img_size = img_bgr.shape[1], img_bgr.shape[0]\n    img_face_mask_a = LandmarksProcessor.get_image_hull_mask (img_bgr.shape, img_face_landmarks)\n\n    input_size = predictor_input_shape[0]\n    mask_subres_size = input_size*4\n    output_size = input_size\n    if cfg.super_resolution_power != 0:\n        output_size *= 4\n\n    face_mat        = LandmarksProcessor.get_transform_mat (img_face_landmarks, output_size, face_type=cfg.face_type)\n    face_output_mat = LandmarksProcessor.get_transform_mat (img_face_landmarks, output_size, face_type=cfg.face_type, scale= 1.0 + 0.01*cfg.output_face_scale)\n\n    if mask_subres_size == output_size:\n        face_mask_output_mat = face_output_mat\n    else:\n        face_mask_output_mat = LandmarksProcessor.get_transform_mat (img_face_landmarks, mask_subres_size, face_type=cfg.face_type, scale= 1.0 + 0.01*cfg.output_face_scale)\n\n    dst_face_bgr      = cv2.warpAffine( img_bgr        , face_mat, (output_size, output_size), flags=cv2.INTER_CUBIC )\n    dst_face_bgr      = np.clip(dst_face_bgr, 0, 1)\n\n    dst_face_mask_a_0 = cv2.warpAffine( img_face_mask_a, face_mat, (output_size, output_size), flags=cv2.INTER_CUBIC )\n    dst_face_mask_a_0 = np.clip(dst_face_mask_a_0, 0, 1)\n\n    predictor_input_bgr      = cv2.resize (dst_face_bgr, (input_size,input_size) )\n\n    predicted = predictor_func (predictor_input_bgr)\n    prd_face_bgr          = np.clip (predicted[0], 0, 1.0)\n    prd_face_mask_a_0     = np.clip (predicted[1], 0, 1.0)\n    prd_face_dst_mask_a_0 = np.clip (predicted[2], 0, 1.0)\n\n    if cfg.super_resolution_power != 0:\n        prd_face_bgr_enhanced = face_enhancer_func(prd_face_bgr, is_tanh=True, preserve_size=False)\n        mod = cfg.super_resolution_power / 100.0\n        prd_face_bgr = cv2.resize(prd_face_bgr, (output_size,output_size))*(1.0-mod) + prd_face_bgr_enhanced*mod\n        prd_face_bgr = np.clip(prd_face_bgr, 0, 1)\n\n    if cfg.super_resolution_power != 0:\n        prd_face_mask_a_0     = cv2.resize (prd_face_mask_a_0,      (output_size, output_size), interpolation=cv2.INTER_CUBIC)\n        prd_face_dst_mask_a_0 = cv2.resize (prd_face_dst_mask_a_0,  (output_size, output_size), interpolation=cv2.INTER_CUBIC)\n\n    if cfg.mask_mode == 0: #full\n        wrk_face_mask_a_0 = np.ones_like(dst_face_mask_a_0)\n    elif cfg.mask_mode == 1: #dst\n        wrk_face_mask_a_0 = cv2.resize (dst_face_mask_a_0, (output_size,output_size), interpolation=cv2.INTER_CUBIC)\n    elif cfg.mask_mode == 2: #learned-prd\n        wrk_face_mask_a_0 = prd_face_mask_a_0\n    elif cfg.mask_mode == 3: #learned-dst\n        wrk_face_mask_a_0 = prd_face_dst_mask_a_0\n    elif cfg.mask_mode == 4: #learned-prd*learned-dst\n        wrk_face_mask_a_0 = prd_face_mask_a_0*prd_face_dst_mask_a_0\n    elif cfg.mask_mode == 5: #learned-prd+learned-dst\n        wrk_face_mask_a_0 = np.clip( prd_face_mask_a_0+prd_face_dst_mask_a_0, 0, 1)\n    elif cfg.mask_mode >= 6 and cfg.mask_mode <= 9:  #XSeg modes\n        if cfg.mask_mode == 6 or cfg.mask_mode == 8 or cfg.mask_mode == 9:\n            # obtain XSeg-prd\n            prd_face_xseg_bgr = cv2.resize (prd_face_bgr, (xseg_input_size,)*2, interpolation=cv2.INTER_CUBIC)\n            prd_face_xseg_mask = xseg_256_extract_func(prd_face_xseg_bgr)\n            X_prd_face_mask_a_0 = cv2.resize ( prd_face_xseg_mask, (output_size, output_size), interpolation=cv2.INTER_CUBIC)\n\n        if cfg.mask_mode >= 7 and cfg.mask_mode <= 9:\n            # obtain XSeg-dst\n            xseg_mat            = LandmarksProcessor.get_transform_mat (img_face_landmarks, xseg_input_size, face_type=cfg.face_type)\n            dst_face_xseg_bgr   = cv2.warpAffine(img_bgr, xseg_mat, (xseg_input_size,)*2, flags=cv2.INTER_CUBIC )\n            dst_face_xseg_mask  = xseg_256_extract_func(dst_face_xseg_bgr)\n            X_dst_face_mask_a_0 = cv2.resize (dst_face_xseg_mask, (output_size,output_size), interpolation=cv2.INTER_CUBIC)\n\n        if cfg.mask_mode == 6:   #'XSeg-prd'\n            wrk_face_mask_a_0 = X_prd_face_mask_a_0\n        elif cfg.mask_mode == 7: #'XSeg-dst'\n            wrk_face_mask_a_0 = X_dst_face_mask_a_0\n        elif cfg.mask_mode == 8: #'XSeg-prd*XSeg-dst'\n            wrk_face_mask_a_0 = X_prd_face_mask_a_0 * X_dst_face_mask_a_0\n        elif cfg.mask_mode == 9: #learned-prd*learned-dst*XSeg-prd*XSeg-dst\n            wrk_face_mask_a_0 = prd_face_mask_a_0 * prd_face_dst_mask_a_0 * X_prd_face_mask_a_0 * X_dst_face_mask_a_0\n\n    wrk_face_mask_a_0[ wrk_face_mask_a_0 < (1.0/255.0) ] = 0.0 # get rid of noise\n\n    # resize to mask_subres_size\n    if wrk_face_mask_a_0.shape[0] != mask_subres_size:\n        wrk_face_mask_a_0 = cv2.resize (wrk_face_mask_a_0, (mask_subres_size, mask_subres_size), interpolation=cv2.INTER_CUBIC)\n\n    # process mask in local predicted space\n    if 'raw' not in cfg.mode:\n        # add zero pad\n        wrk_face_mask_a_0 = np.pad (wrk_face_mask_a_0, input_size)\n\n        ero  = cfg.erode_mask_modifier\n        blur = cfg.blur_mask_modifier\n\n        if ero > 0:\n            wrk_face_mask_a_0 = cv2.erode(wrk_face_mask_a_0, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(ero,ero)), iterations = 1 )\n        elif ero < 0:\n            wrk_face_mask_a_0 = cv2.dilate(wrk_face_mask_a_0, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(-ero,-ero)), iterations = 1 )\n\n        # clip eroded/dilated mask in actual predict area\n        # pad with half blur size in order to accuratelly fade to zero at the boundary\n        clip_size = input_size + blur // 2\n\n        wrk_face_mask_a_0[:clip_size,:] = 0\n        wrk_face_mask_a_0[-clip_size:,:] = 0\n        wrk_face_mask_a_0[:,:clip_size] = 0\n        wrk_face_mask_a_0[:,-clip_size:] = 0\n\n        if blur > 0:\n            blur = blur + (1-blur % 2)\n            wrk_face_mask_a_0 = cv2.GaussianBlur(wrk_face_mask_a_0, (blur, blur) , 0)\n\n        wrk_face_mask_a_0 = wrk_face_mask_a_0[input_size:-input_size,input_size:-input_size]\n\n        wrk_face_mask_a_0 = np.clip(wrk_face_mask_a_0, 0, 1)\n\n    img_face_mask_a = cv2.warpAffine( wrk_face_mask_a_0, face_mask_output_mat, img_size, np.zeros(img_bgr.shape[0:2], dtype=np.float32), flags=cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC )[...,None]\n    img_face_mask_a = np.clip (img_face_mask_a, 0.0, 1.0)\n    img_face_mask_a [ img_face_mask_a < (1.0/255.0) ] = 0.0 # get rid of noise\n\n    if wrk_face_mask_a_0.shape[0] != output_size:\n        wrk_face_mask_a_0 = cv2.resize (wrk_face_mask_a_0, (output_size,output_size), interpolation=cv2.INTER_CUBIC)\n\n    wrk_face_mask_a = wrk_face_mask_a_0[...,None]\n\n    out_img = None\n    out_merging_mask_a = None\n    if cfg.mode == 'original':\n        return img_bgr, img_face_mask_a\n\n    elif 'raw' in cfg.mode:\n        if cfg.mode == 'raw-rgb':\n            out_img_face = cv2.warpAffine( prd_face_bgr, face_output_mat, img_size, np.empty_like(img_bgr), cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC)\n            out_img_face_mask = cv2.warpAffine( np.ones_like(prd_face_bgr), face_output_mat, img_size, np.empty_like(img_bgr), cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC)\n            out_img = img_bgr*(1-out_img_face_mask) + out_img_face*out_img_face_mask\n            out_merging_mask_a = img_face_mask_a\n        elif cfg.mode == 'raw-predict':\n            out_img = prd_face_bgr\n            out_merging_mask_a = wrk_face_mask_a\n        else:\n            raise ValueError(f\"undefined raw type {cfg.mode}\")\n\n        out_img = np.clip (out_img, 0.0, 1.0 )\n    else:\n\n        # Process if the mask meets minimum size\n        maxregion = np.argwhere( img_face_mask_a >= 0.1 )\n        if maxregion.size != 0:\n            miny,minx = maxregion.min(axis=0)[:2]\n            maxy,maxx = maxregion.max(axis=0)[:2]\n            lenx = maxx - minx\n            leny = maxy - miny\n            if min(lenx,leny) >= 4:\n                wrk_face_mask_area_a = wrk_face_mask_a.copy()\n                wrk_face_mask_area_a[wrk_face_mask_area_a>0] = 1.0\n\n                if 'seamless' not in cfg.mode and cfg.color_transfer_mode != 0:\n                    if cfg.color_transfer_mode == 1: #rct\n                        prd_face_bgr = imagelib.reinhard_color_transfer (prd_face_bgr, dst_face_bgr, target_mask=wrk_face_mask_area_a, source_mask=wrk_face_mask_area_a)\n                    elif cfg.color_transfer_mode == 2: #lct\n                        prd_face_bgr = imagelib.linear_color_transfer (prd_face_bgr, dst_face_bgr)\n                    elif cfg.color_transfer_mode == 3: #mkl\n                        prd_face_bgr = imagelib.color_transfer_mkl (prd_face_bgr, dst_face_bgr)\n                    elif cfg.color_transfer_mode == 4: #mkl-m\n                        prd_face_bgr = imagelib.color_transfer_mkl (prd_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a)\n                    elif cfg.color_transfer_mode == 5: #idt\n                        prd_face_bgr = imagelib.color_transfer_idt (prd_face_bgr, dst_face_bgr)\n                    elif cfg.color_transfer_mode == 6: #idt-m\n                        prd_face_bgr = imagelib.color_transfer_idt (prd_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a)\n                    elif cfg.color_transfer_mode == 7: #sot-m\n                        prd_face_bgr = imagelib.color_transfer_sot (prd_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a, steps=10, batch_size=30)\n                        prd_face_bgr = np.clip (prd_face_bgr, 0.0, 1.0)\n                    elif cfg.color_transfer_mode == 8: #mix-m\n                        prd_face_bgr = imagelib.color_transfer_mix (prd_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a)\n\n                if cfg.mode == 'hist-match':\n                    hist_mask_a = np.ones ( prd_face_bgr.shape[:2] + (1,) , dtype=np.float32)\n\n                    if cfg.masked_hist_match:\n                        hist_mask_a *= wrk_face_mask_area_a\n\n                    white =  (1.0-hist_mask_a)* np.ones ( prd_face_bgr.shape[:2] + (1,) , dtype=np.float32)\n\n                    hist_match_1 = prd_face_bgr*hist_mask_a + white\n                    hist_match_1[ hist_match_1 > 1.0 ] = 1.0\n\n                    hist_match_2 = dst_face_bgr*hist_mask_a + white\n                    hist_match_2[ hist_match_1 > 1.0 ] = 1.0\n\n                    prd_face_bgr = imagelib.color_hist_match(hist_match_1, hist_match_2, cfg.hist_match_threshold ).astype(dtype=np.float32)\n\n                if 'seamless' in cfg.mode:\n                    #mask used for cv2.seamlessClone\n                    img_face_seamless_mask_a = None\n                    for i in range(1,10):\n                        a = img_face_mask_a > i / 10.0\n                        if len(np.argwhere(a)) == 0:\n                            continue\n                        img_face_seamless_mask_a = img_face_mask_a.copy()\n                        img_face_seamless_mask_a[a] = 1.0\n                        img_face_seamless_mask_a[img_face_seamless_mask_a <= i / 10.0] = 0.0\n                        break\n\n                out_img = cv2.warpAffine( prd_face_bgr, face_output_mat, img_size, np.empty_like(img_bgr), cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC )\n                out_img = np.clip(out_img, 0.0, 1.0)\n\n                if 'seamless' in cfg.mode:\n                    try:\n                        #calc same bounding rect and center point as in cv2.seamlessClone to prevent jittering (not flickering)\n                        l,t,w,h = cv2.boundingRect( (img_face_seamless_mask_a*255).astype(np.uint8) )\n                        s_maskx, s_masky = int(l+w/2), int(t+h/2)\n                        out_img = cv2.seamlessClone( (out_img*255).astype(np.uint8), img_bgr_uint8, (img_face_seamless_mask_a*255).astype(np.uint8), (s_maskx,s_masky) , cv2.NORMAL_CLONE )\n                        out_img = out_img.astype(dtype=np.float32) / 255.0\n                    except Exception as e:\n                        #seamlessClone may fail in some cases\n                        e_str = traceback.format_exc()\n\n                        if 'MemoryError' in e_str:\n                            raise Exception(\"Seamless fail: \" + e_str) #reraise MemoryError in order to reprocess this data by other processes\n                        else:\n                            print (\"Seamless fail: \" + e_str)\n\n                cfg_mp = cfg.motion_blur_power / 100.0\n\n                out_img = img_bgr*(1-img_face_mask_a) + (out_img*img_face_mask_a)\n\n                if ('seamless' in cfg.mode and cfg.color_transfer_mode != 0) or \\\n                   cfg.mode == 'seamless-hist-match' or \\\n                   cfg_mp != 0 or \\\n                   cfg.blursharpen_amount != 0 or \\\n                   cfg.image_denoise_power != 0 or \\\n                   cfg.bicubic_degrade_power != 0:\n\n                    out_face_bgr = cv2.warpAffine( out_img, face_mat, (output_size, output_size), flags=cv2.INTER_CUBIC )\n\n                    if 'seamless' in cfg.mode and cfg.color_transfer_mode != 0:\n                        if cfg.color_transfer_mode == 1:\n                            out_face_bgr = imagelib.reinhard_color_transfer (out_face_bgr, dst_face_bgr, target_mask=wrk_face_mask_area_a, source_mask=wrk_face_mask_area_a)\n                        elif cfg.color_transfer_mode == 2: #lct\n                            out_face_bgr = imagelib.linear_color_transfer (out_face_bgr, dst_face_bgr)\n                        elif cfg.color_transfer_mode == 3: #mkl\n                            out_face_bgr = imagelib.color_transfer_mkl (out_face_bgr, dst_face_bgr)\n                        elif cfg.color_transfer_mode == 4: #mkl-m\n                            out_face_bgr = imagelib.color_transfer_mkl (out_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a)\n                        elif cfg.color_transfer_mode == 5: #idt\n                            out_face_bgr = imagelib.color_transfer_idt (out_face_bgr, dst_face_bgr)\n                        elif cfg.color_transfer_mode == 6: #idt-m\n                            out_face_bgr = imagelib.color_transfer_idt (out_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a)\n                        elif cfg.color_transfer_mode == 7: #sot-m\n                            out_face_bgr = imagelib.color_transfer_sot (out_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a, steps=10, batch_size=30)\n                            out_face_bgr = np.clip (out_face_bgr, 0.0, 1.0)\n                        elif cfg.color_transfer_mode == 8: #mix-m\n                            out_face_bgr = imagelib.color_transfer_mix (out_face_bgr*wrk_face_mask_area_a, dst_face_bgr*wrk_face_mask_area_a)\n\n                    if cfg.mode == 'seamless-hist-match':\n                        out_face_bgr = imagelib.color_hist_match(out_face_bgr, dst_face_bgr, cfg.hist_match_threshold)\n\n                    if cfg_mp != 0:\n                        k_size = int(frame_info.motion_power*cfg_mp)\n                        if k_size >= 1:\n                            k_size = np.clip (k_size+1, 2, 50)\n                            if cfg.super_resolution_power != 0:\n                                k_size *= 2\n                            out_face_bgr = imagelib.LinearMotionBlur (out_face_bgr, k_size , frame_info.motion_deg)\n\n                    if cfg.blursharpen_amount != 0:\n                        out_face_bgr = imagelib.blursharpen ( out_face_bgr, cfg.sharpen_mode, 3, cfg.blursharpen_amount)\n\n                    if cfg.image_denoise_power != 0:\n                        n = cfg.image_denoise_power\n                        while n > 0:\n                            img_bgr_denoised = cv2.medianBlur(img_bgr, 5)\n                            if int(n / 100) != 0:\n                                img_bgr = img_bgr_denoised\n                            else:\n                                pass_power = (n % 100) / 100.0\n                                img_bgr = img_bgr*(1.0-pass_power)+img_bgr_denoised*pass_power\n                            n = max(n-10,0)\n\n                    if cfg.bicubic_degrade_power != 0:\n                        p = 1.0 - cfg.bicubic_degrade_power / 101.0\n                        img_bgr_downscaled = cv2.resize (img_bgr, ( int(img_size[0]*p), int(img_size[1]*p ) ), interpolation=cv2.INTER_CUBIC)\n                        img_bgr = cv2.resize (img_bgr_downscaled, img_size, interpolation=cv2.INTER_CUBIC)\n\n                    new_out = cv2.warpAffine( out_face_bgr, face_mat, img_size, np.empty_like(img_bgr), cv2.WARP_INVERSE_MAP | cv2.INTER_CUBIC )\n\n                    out_img =  np.clip( img_bgr*(1-img_face_mask_a) + (new_out*img_face_mask_a) , 0, 1.0 )\n\n                if cfg.color_degrade_power != 0:\n                    out_img_reduced = imagelib.reduce_colors(out_img, 256)\n                    if cfg.color_degrade_power == 100:\n                        out_img = out_img_reduced\n                    else:\n                        alpha = cfg.color_degrade_power / 100.0\n                        out_img = (out_img*(1.0-alpha) + out_img_reduced*alpha)\n        out_merging_mask_a = img_face_mask_a\n\n    if out_img is None:\n        out_img = img_bgr.copy()\n        \n    return out_img, out_merging_mask_a\n\n\ndef MergeMasked (predictor_func,\n                 predictor_input_shape,\n                 face_enhancer_func,\n                 xseg_256_extract_func,\n                 cfg,\n                 frame_info):\n    img_bgr_uint8 = cv2_imread(frame_info.filepath)\n    img_bgr_uint8 = imagelib.normalize_channels (img_bgr_uint8, 3)\n    img_bgr = img_bgr_uint8.astype(np.float32) / 255.0\n\n    outs = []\n    for face_num, img_landmarks in enumerate( frame_info.landmarks_list ):\n        out_img, out_img_merging_mask = MergeMaskedFace (predictor_func, predictor_input_shape, face_enhancer_func, xseg_256_extract_func, cfg, frame_info, img_bgr_uint8, img_bgr, img_landmarks)\n        outs += [ (out_img, out_img_merging_mask) ]\n\n    #Combining multiple face outputs\n    final_img = None\n    final_mask = None\n    for img, merging_mask in outs:\n        h,w,c = img.shape\n\n        if final_img is None:\n            final_img = img\n            final_mask = merging_mask\n        else:\n            final_img = final_img*(1-merging_mask) + img*merging_mask\n            final_mask = np.clip (final_mask + merging_mask, 0, 1 )\n\n    final_img = np.concatenate ( [final_img, final_mask], -1)\n\n    return (final_img*255).astype(np.uint8)\n", "merger/MergerConfig.py": "import numpy as np\nimport copy\n\nfrom facelib import FaceType\nfrom core.interact import interact as io\n\n\nclass MergerConfig(object):\n    TYPE_NONE = 0\n    TYPE_MASKED = 1\n    TYPE_FACE_AVATAR = 2\n    ####\n\n    TYPE_IMAGE = 3\n    TYPE_IMAGE_WITH_LANDMARKS = 4\n\n    def __init__(self, type=0,\n                       sharpen_mode=0,\n                       blursharpen_amount=0,\n                       **kwargs\n                       ):\n        self.type = type\n\n        self.sharpen_dict = {0:\"None\", 1:'box', 2:'gaussian'}\n\n        #default changeable params\n        self.sharpen_mode = sharpen_mode\n        self.blursharpen_amount = blursharpen_amount\n\n    def copy(self):\n        return copy.copy(self)\n\n    #overridable\n    def ask_settings(self):\n        s = \"\"\"Choose sharpen mode: \\n\"\"\"\n        for key in self.sharpen_dict.keys():\n            s += f\"\"\"({key}) {self.sharpen_dict[key]}\\n\"\"\"\n        io.log_info(s)\n        self.sharpen_mode = io.input_int (\"\", 0, valid_list=self.sharpen_dict.keys(), help_message=\"Enhance details by applying sharpen filter.\")\n\n        if self.sharpen_mode != 0:\n            self.blursharpen_amount = np.clip ( io.input_int (\"Choose blur/sharpen amount\", 0, add_info=\"-100..100\"), -100, 100 )\n\n    def toggle_sharpen_mode(self):\n        a = list( self.sharpen_dict.keys() )\n        self.sharpen_mode = a[ (a.index(self.sharpen_mode)+1) % len(a) ]\n\n    def add_blursharpen_amount(self, diff):\n        self.blursharpen_amount = np.clip ( self.blursharpen_amount+diff, -100, 100)\n\n    #overridable\n    def get_config(self):\n        d = self.__dict__.copy()\n        d.pop('type')\n        return d\n\n    #overridable\n    def __eq__(self, other):\n        #check equality of changeable params\n\n        if isinstance(other, MergerConfig):\n            return self.sharpen_mode == other.sharpen_mode and \\\n                   self.blursharpen_amount == other.blursharpen_amount\n\n        return False\n\n    #overridable\n    def to_string(self, filename):\n        r = \"\"\n        r += f\"sharpen_mode : {self.sharpen_dict[self.sharpen_mode]}\\n\"\n        r += f\"blursharpen_amount : {self.blursharpen_amount}\\n\"\n        return r\n\nmode_dict = {0:'original',\n             1:'overlay',\n             2:'hist-match',\n             3:'seamless',\n             4:'seamless-hist-match',\n             5:'raw-rgb',\n             6:'raw-predict'}\n\nmode_str_dict = { mode_dict[key] : key for key in mode_dict.keys() }\n\nmask_mode_dict = {0:'full',\n                  1:'dst',\n                  2:'learned-prd',\n                  3:'learned-dst',\n                  4:'learned-prd*learned-dst',\n                  5:'learned-prd+learned-dst',\n                  6:'XSeg-prd',\n                  7:'XSeg-dst',\n                  8:'XSeg-prd*XSeg-dst',\n                  9:'learned-prd*learned-dst*XSeg-prd*XSeg-dst'\n                  }\n\n\nctm_dict = { 0: \"None\", 1:\"rct\", 2:\"lct\", 3:\"mkl\", 4:\"mkl-m\", 5:\"idt\", 6:\"idt-m\", 7:\"sot-m\", 8:\"mix-m\" }\nctm_str_dict = {None:0, \"rct\":1, \"lct\":2, \"mkl\":3, \"mkl-m\":4, \"idt\":5, \"idt-m\":6, \"sot-m\":7, \"mix-m\":8 }\n\nclass MergerConfigMasked(MergerConfig):\n\n    def __init__(self, face_type=FaceType.FULL,\n                       default_mode = 'overlay',\n                       mode='overlay',\n                       masked_hist_match=True,\n                       hist_match_threshold = 238,\n                       mask_mode = 4,\n                       erode_mask_modifier = 0,\n                       blur_mask_modifier = 0,\n                       motion_blur_power = 0,\n                       output_face_scale = 0,\n                       super_resolution_power = 0,\n                       color_transfer_mode = ctm_str_dict['rct'],\n                       image_denoise_power = 0,\n                       bicubic_degrade_power = 0,\n                       color_degrade_power = 0,\n                       **kwargs\n                       ):\n\n        super().__init__(type=MergerConfig.TYPE_MASKED, **kwargs)\n\n        self.face_type = face_type\n        if self.face_type not in [FaceType.HALF, FaceType.MID_FULL, FaceType.FULL, FaceType.WHOLE_FACE, FaceType.HEAD ]:\n            raise ValueError(\"MergerConfigMasked does not support this type of face.\")\n\n        self.default_mode = default_mode\n\n        #default changeable params\n        if mode not in mode_str_dict:\n            mode = mode_dict[1]\n\n        self.mode = mode\n        self.masked_hist_match = masked_hist_match\n        self.hist_match_threshold = hist_match_threshold\n        self.mask_mode = mask_mode\n        self.erode_mask_modifier = erode_mask_modifier\n        self.blur_mask_modifier = blur_mask_modifier\n        self.motion_blur_power = motion_blur_power\n        self.output_face_scale = output_face_scale\n        self.super_resolution_power = super_resolution_power\n        self.color_transfer_mode = color_transfer_mode\n        self.image_denoise_power = image_denoise_power\n        self.bicubic_degrade_power = bicubic_degrade_power\n        self.color_degrade_power = color_degrade_power\n\n    def copy(self):\n        return copy.copy(self)\n\n    def set_mode (self, mode):\n        self.mode = mode_dict.get (mode, self.default_mode)\n\n    def toggle_masked_hist_match(self):\n        if self.mode == 'hist-match':\n            self.masked_hist_match = not self.masked_hist_match\n\n    def add_hist_match_threshold(self, diff):\n        if self.mode == 'hist-match' or self.mode == 'seamless-hist-match':\n            self.hist_match_threshold = np.clip ( self.hist_match_threshold+diff , 0, 255)\n\n    def toggle_mask_mode(self):\n        a = list( mask_mode_dict.keys() )\n        self.mask_mode = a[ (a.index(self.mask_mode)+1) % len(a) ]\n\n    def add_erode_mask_modifier(self, diff):\n        self.erode_mask_modifier = np.clip ( self.erode_mask_modifier+diff , -400, 400)\n\n    def add_blur_mask_modifier(self, diff):\n        self.blur_mask_modifier = np.clip ( self.blur_mask_modifier+diff , 0, 400)\n\n    def add_motion_blur_power(self, diff):\n        self.motion_blur_power = np.clip ( self.motion_blur_power+diff, 0, 100)\n\n    def add_output_face_scale(self, diff):\n        self.output_face_scale = np.clip ( self.output_face_scale+diff , -50, 50)\n\n    def toggle_color_transfer_mode(self):\n        self.color_transfer_mode = (self.color_transfer_mode+1) % ( max(ctm_dict.keys())+1 )\n\n    def add_super_resolution_power(self, diff):\n        self.super_resolution_power = np.clip ( self.super_resolution_power+diff , 0, 100)\n\n    def add_color_degrade_power(self, diff):\n        self.color_degrade_power = np.clip ( self.color_degrade_power+diff , 0, 100)\n\n    def add_image_denoise_power(self, diff):\n        self.image_denoise_power = np.clip ( self.image_denoise_power+diff, 0, 500)\n\n    def add_bicubic_degrade_power(self, diff):\n        self.bicubic_degrade_power = np.clip ( self.bicubic_degrade_power+diff, 0, 100)\n\n    def ask_settings(self):\n        s = \"\"\"Choose mode: \\n\"\"\"\n        for key in mode_dict.keys():\n            s += f\"\"\"({key}) {mode_dict[key]}\\n\"\"\"\n        io.log_info(s)\n        mode = io.input_int (\"\", mode_str_dict.get(self.default_mode, 1) )\n\n        self.mode = mode_dict.get (mode, self.default_mode )\n\n        if 'raw' not in self.mode:\n            if self.mode == 'hist-match':\n                self.masked_hist_match = io.input_bool(\"Masked hist match?\", True)\n\n            if self.mode == 'hist-match' or self.mode == 'seamless-hist-match':\n                self.hist_match_threshold = np.clip ( io.input_int(\"Hist match threshold\", 255, add_info=\"0..255\"), 0, 255)\n\n        s = \"\"\"Choose mask mode: \\n\"\"\"\n        for key in mask_mode_dict.keys():\n            s += f\"\"\"({key}) {mask_mode_dict[key]}\\n\"\"\"\n        io.log_info(s)\n        self.mask_mode = io.input_int (\"\", 1, valid_list=mask_mode_dict.keys() )\n\n        if 'raw' not in self.mode:\n            self.erode_mask_modifier = np.clip ( io.input_int (\"Choose erode mask modifier\", 0, add_info=\"-400..400\"), -400, 400)\n            self.blur_mask_modifier =  np.clip ( io.input_int (\"Choose blur mask modifier\", 0, add_info=\"0..400\"), 0, 400)\n            self.motion_blur_power = np.clip ( io.input_int (\"Choose motion blur power\", 0, add_info=\"0..100\"), 0, 100)\n\n        self.output_face_scale = np.clip (io.input_int (\"Choose output face scale modifier\", 0, add_info=\"-50..50\" ), -50, 50)\n\n        if 'raw' not in self.mode:\n            self.color_transfer_mode = io.input_str ( \"Color transfer to predicted face\", None, valid_list=list(ctm_str_dict.keys())[1:] )\n            self.color_transfer_mode = ctm_str_dict[self.color_transfer_mode]\n\n        super().ask_settings()\n\n        self.super_resolution_power = np.clip ( io.input_int (\"Choose super resolution power\", 0, add_info=\"0..100\", help_message=\"Enhance details by applying superresolution network.\"), 0, 100)\n\n        if 'raw' not in self.mode:\n            self.image_denoise_power = np.clip ( io.input_int (\"Choose image degrade by denoise power\", 0, add_info=\"0..500\"), 0, 500)\n            self.bicubic_degrade_power = np.clip ( io.input_int (\"Choose image degrade by bicubic rescale power\", 0, add_info=\"0..100\"), 0, 100)\n            self.color_degrade_power = np.clip (  io.input_int (\"Degrade color power of final image\", 0, add_info=\"0..100\"), 0, 100)\n\n        io.log_info (\"\")\n\n    def __eq__(self, other):\n        #check equality of changeable params\n\n        if isinstance(other, MergerConfigMasked):\n            return super().__eq__(other) and \\\n                   self.mode == other.mode and \\\n                   self.masked_hist_match == other.masked_hist_match and \\\n                   self.hist_match_threshold == other.hist_match_threshold and \\\n                   self.mask_mode == other.mask_mode and \\\n                   self.erode_mask_modifier == other.erode_mask_modifier and \\\n                   self.blur_mask_modifier == other.blur_mask_modifier and \\\n                   self.motion_blur_power == other.motion_blur_power and \\\n                   self.output_face_scale == other.output_face_scale and \\\n                   self.color_transfer_mode == other.color_transfer_mode and \\\n                   self.super_resolution_power == other.super_resolution_power and \\\n                   self.image_denoise_power == other.image_denoise_power and \\\n                   self.bicubic_degrade_power == other.bicubic_degrade_power and \\\n                   self.color_degrade_power == other.color_degrade_power\n\n        return False\n\n    def to_string(self, filename):\n        r = (\n            f\"\"\"MergerConfig {filename}:\\n\"\"\"\n            f\"\"\"Mode: {self.mode}\\n\"\"\"\n            )\n\n        if self.mode == 'hist-match':\n            r += f\"\"\"masked_hist_match: {self.masked_hist_match}\\n\"\"\"\n\n        if self.mode == 'hist-match' or self.mode == 'seamless-hist-match':\n            r += f\"\"\"hist_match_threshold: {self.hist_match_threshold}\\n\"\"\"\n\n        r += f\"\"\"mask_mode: { mask_mode_dict[self.mask_mode] }\\n\"\"\"\n\n        if 'raw' not in self.mode:\n            r += (f\"\"\"erode_mask_modifier: {self.erode_mask_modifier}\\n\"\"\"\n                  f\"\"\"blur_mask_modifier: {self.blur_mask_modifier}\\n\"\"\"\n                  f\"\"\"motion_blur_power: {self.motion_blur_power}\\n\"\"\")\n\n        r += f\"\"\"output_face_scale: {self.output_face_scale}\\n\"\"\"\n\n        if 'raw' not in self.mode:\n            r += f\"\"\"color_transfer_mode: {ctm_dict[self.color_transfer_mode]}\\n\"\"\"\n            r += super().to_string(filename)\n\n        r += f\"\"\"super_resolution_power: {self.super_resolution_power}\\n\"\"\"\n\n        if 'raw' not in self.mode:\n            r += (f\"\"\"image_denoise_power: {self.image_denoise_power}\\n\"\"\"\n                  f\"\"\"bicubic_degrade_power: {self.bicubic_degrade_power}\\n\"\"\"\n                  f\"\"\"color_degrade_power: {self.color_degrade_power}\\n\"\"\")\n\n        r += \"================\"\n\n        return r\n\n\nclass MergerConfigFaceAvatar(MergerConfig):\n\n    def __init__(self, temporal_face_count=0,\n                       add_source_image=False):\n        super().__init__(type=MergerConfig.TYPE_FACE_AVATAR)\n        self.temporal_face_count = temporal_face_count\n\n        #changeable params\n        self.add_source_image = add_source_image\n\n    def copy(self):\n        return copy.copy(self)\n\n    #override\n    def ask_settings(self):\n        self.add_source_image = io.input_bool(\"Add source image?\", False, help_message=\"Add source image for comparison.\")\n        super().ask_settings()\n\n    def toggle_add_source_image(self):\n        self.add_source_image = not self.add_source_image\n\n    #override\n    def __eq__(self, other):\n        #check equality of changeable params\n\n        if isinstance(other, MergerConfigFaceAvatar):\n            return super().__eq__(other) and \\\n                   self.add_source_image == other.add_source_image\n\n        return False\n\n    #override\n    def to_string(self, filename):\n        return (f\"MergerConfig {filename}:\\n\"\n                f\"add_source_image : {self.add_source_image}\\n\") + \\\n                super().to_string(filename) + \"================\"\n\n", "merger/__init__.py": "from .FrameInfo import FrameInfo\nfrom .MergerConfig import MergerConfig, MergerConfigMasked, MergerConfigFaceAvatar\nfrom .MergeMasked import MergeMasked\nfrom .MergeAvatar import MergeFaceAvatar\nfrom .InteractiveMergerSubprocessor import InteractiveMergerSubprocessor", "merger/MergerScreen/MergerScreen.py": "import math\nfrom pathlib import Path\n\nimport numpy as np\n\nfrom core import imagelib\nfrom core.interact import interact as io\nfrom core.cv2ex import *\nfrom core import osex\n\n\nclass ScreenAssets(object):\n    waiting_icon_image = cv2_imread ( str(Path(__file__).parent / 'gfx' / 'sand_clock_64.png') )\n\n    @staticmethod\n    def build_checkerboard_a( sh, size=5):\n        h,w = sh[0], sh[1]\n        tile = np.array([[0,1],[1,0]]).repeat(size, axis=0).repeat(size, axis=1)\n        grid = np.tile(tile,(int(math.ceil((h+0.0)/(2*size))),int(math.ceil((w+0.0)/(2*size)))))\n        return grid[:h,:w,None]\n\nclass Screen(object):\n    def __init__(self, initial_scale_to_width=0, initial_scale_to_height=0, image=None, waiting_icon=False, **kwargs):\n        self.initial_scale_to_width = initial_scale_to_width\n        self.initial_scale_to_height = initial_scale_to_height\n        self.image = image\n        self.waiting_icon = waiting_icon\n\n        self.state = -1\n        self.scale = 1\n        self.force_update = True\n        self.is_first_appear = True\n        self.show_checker_board = False\n\n        self.last_screen_shape = (480,640,3)\n        self.checkerboard_image = None\n        self.set_image (image)\n        self.scrn_manager = None\n\n    def set_waiting_icon(self, b):\n        self.waiting_icon = b\n\n    def toggle_show_checker_board(self):\n        self.show_checker_board = not self.show_checker_board\n        self.force_update = True\n    \n    def get_image(self):\n        return self.image\n        \n    def set_image(self, img):\n        if not img is self.image:\n            self.force_update = True\n\n        self.image = img\n\n        if self.image is not None:\n            self.last_screen_shape = self.image.shape\n\n            if self.initial_scale_to_width != 0:\n                if self.last_screen_shape[1] > self.initial_scale_to_width:\n                    self.scale = self.initial_scale_to_width / self.last_screen_shape[1]\n                    self.force_update = True\n                self.initial_scale_to_width = 0\n\n            elif self.initial_scale_to_height != 0:\n                if self.last_screen_shape[0] > self.initial_scale_to_height:\n                    self.scale = self.initial_scale_to_height / self.last_screen_shape[0]\n                    self.force_update = True\n                self.initial_scale_to_height = 0\n\n\n    def diff_scale(self, diff):\n        self.scale = np.clip (self.scale + diff, 0.1, 4.0)\n        self.force_update = True\n\n    def show(self, force=False):\n        new_state = 0 | self.waiting_icon\n\n        if self.state != new_state or self.force_update or force:\n            self.state = new_state\n            self.force_update = False\n\n            if self.image is None:\n                screen = np.zeros ( self.last_screen_shape, dtype=np.uint8 )\n            else:\n                screen = self.image.copy()\n\n            if self.waiting_icon:\n                imagelib.overlay_alpha_image (screen, ScreenAssets.waiting_icon_image, (0,0) )\n\n            h,w,c = screen.shape\n            if self.scale != 1.0:\n                screen = cv2.resize ( screen, ( int(w*self.scale), int(h*self.scale) ) )\n\n            if c == 4:\n                if not self.show_checker_board:\n                    screen = screen[...,0:3]\n                else:\n                    if self.checkerboard_image is None or self.checkerboard_image.shape[0:2] != screen.shape[0:2]:\n                        self.checkerboard_image = ScreenAssets.build_checkerboard_a(screen.shape)\n\n                    screen = screen[...,0:3]*0.75 + 64*self.checkerboard_image*(1- (screen[...,3:4].astype(np.float32)/255.0) )\n                    screen = screen.astype(np.uint8)\n\n            io.show_image(self.scrn_manager.wnd_name, screen)\n\n            if self.is_first_appear:\n                self.is_first_appear = False\n                #center window\n                desktop_w, desktop_h = osex.get_screen_size()\n                h,w,c = screen.shape\n                cv2.moveWindow(self.scrn_manager.wnd_name, max(0,(desktop_w-w) // 2), max(0, (desktop_h-h) // 2) )\n\n            io.process_messages(0.0001)\n\nclass ScreenManager(object):\n    def __init__(self, window_name=\"ScreenManager\", screens=None, capture_keys=False ):\n        self.screens = screens or []\n        self.current_screen_id = 0\n\n        if self.screens is not None:\n            for screen in self.screens:\n                screen.scrn_manager = self\n\n        self.wnd_name = window_name\n        io.named_window(self.wnd_name)\n\n\n        if capture_keys:\n            io.capture_keys(self.wnd_name)\n\n    def finalize(self):\n        io.destroy_all_windows()\n\n    def get_key_events(self):\n        return io.get_key_events(self.wnd_name)\n\n    def switch_screens(self):\n        self.current_screen_id = (self.current_screen_id + 1) % len(self.screens)\n        self.screens[self.current_screen_id].show(force=True)\n\n    def show_current(self):\n        self.screens[self.current_screen_id].show()\n\n    def get_current(self):\n        return self.screens[self.current_screen_id]\n\n    def set_current(self, screen):\n        self.current_screen_id = self.screens.index(screen)\n", "merger/MergerScreen/__init__.py": "from .MergerScreen import Screen, ScreenManager", "models/__init__.py": "from .ModelBase import ModelBase\n\ndef import_model(model_class_name):\n    module = __import__('Model_'+model_class_name, globals(), locals(), [], 1)\n    return getattr(module, 'Model')\n", "models/ModelBase.py": "import colorsys\nimport inspect\nimport json\nimport multiprocessing\nimport operator\nimport os\nimport pickle\nimport shutil\nimport tempfile\nimport time\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\n\nfrom core import imagelib, pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.leras import nn\nfrom samplelib import SampleGeneratorBase\n\n\nclass ModelBase(object):\n    def __init__(self, is_training=False,\n                       is_exporting=False,\n                       saved_models_path=None,\n                       training_data_src_path=None,\n                       training_data_dst_path=None,\n                       pretraining_data_path=None,\n                       pretrained_model_path=None,\n                       no_preview=False,\n                       force_model_name=None,\n                       force_gpu_idxs=None,\n                       cpu_only=False,\n                       debug=False,\n                       force_model_class_name=None,\n                       silent_start=False,\n                       **kwargs):\n        self.is_training = is_training\n        self.is_exporting = is_exporting\n        self.saved_models_path = saved_models_path\n        self.training_data_src_path = training_data_src_path\n        self.training_data_dst_path = training_data_dst_path\n        self.pretraining_data_path = pretraining_data_path\n        self.pretrained_model_path = pretrained_model_path\n        self.no_preview = no_preview\n        self.debug = debug\n\n        self.model_class_name = model_class_name = Path(inspect.getmodule(self).__file__).parent.name.rsplit(\"_\", 1)[1]\n\n        if force_model_class_name is None:\n            if force_model_name is not None:\n                self.model_name = force_model_name\n            else:\n                while True:\n                    # gather all model dat files\n                    saved_models_names = []\n                    for filepath in pathex.get_file_paths(saved_models_path):\n                        filepath_name = filepath.name\n                        if filepath_name.endswith(f'{model_class_name}_data.dat'):\n                            saved_models_names += [ (filepath_name.split('_')[0], os.path.getmtime(filepath)) ]\n\n                    # sort by modified datetime\n                    saved_models_names = sorted(saved_models_names, key=operator.itemgetter(1), reverse=True )\n                    saved_models_names = [ x[0] for x in saved_models_names ]\n\n\n                    if len(saved_models_names) != 0:\n                        if silent_start:\n                            self.model_name = saved_models_names[0]\n                            io.log_info(f'Silent start: choosed model \"{self.model_name}\"')\n                        else:\n                            io.log_info (\"Choose one of saved models, or enter a name to create a new model.\")\n                            io.log_info (\"[r] : rename\")\n                            io.log_info (\"[d] : delete\")\n                            io.log_info (\"\")\n                            for i, model_name in enumerate(saved_models_names):\n                                s = f\"[{i}] : {model_name} \"\n                                if i == 0:\n                                    s += \"- latest\"\n                                io.log_info (s)\n\n                            inp = io.input_str(f\"\", \"0\", show_default_value=False )\n                            model_idx = -1\n                            try:\n                                model_idx = np.clip ( int(inp), 0, len(saved_models_names)-1 )\n                            except:\n                                pass\n\n                            if model_idx == -1:\n                                if len(inp) == 1:\n                                    is_rename = inp[0] == 'r'\n                                    is_delete = inp[0] == 'd'\n\n                                    if is_rename or is_delete:\n                                        if len(saved_models_names) != 0:\n\n                                            if is_rename:\n                                                name = io.input_str(f\"Enter the name of the model you want to rename\")\n                                            elif is_delete:\n                                                name = io.input_str(f\"Enter the name of the model you want to delete\")\n\n                                            if name in saved_models_names:\n\n                                                if is_rename:\n                                                    new_model_name = io.input_str(f\"Enter new name of the model\")\n\n                                                for filepath in pathex.get_paths(saved_models_path):\n                                                    filepath_name = filepath.name\n\n                                                    model_filename, remain_filename = filepath_name.split('_', 1)\n                                                    if model_filename == name:\n\n                                                        if is_rename:\n                                                            new_filepath = filepath.parent / ( new_model_name + '_' + remain_filename )\n                                                            filepath.rename (new_filepath)\n                                                        elif is_delete:\n                                                            filepath.unlink()\n                                        continue\n\n                                self.model_name = inp\n                            else:\n                                self.model_name = saved_models_names[model_idx]\n\n                    else:\n                        self.model_name = io.input_str(f\"No saved models found. Enter a name of a new model\", \"new\")\n                        self.model_name = self.model_name.replace('_', ' ')\n                    break\n\n\n            self.model_name = self.model_name + '_' + self.model_class_name\n        else:\n            self.model_name = force_model_class_name\n\n        self.iter = 0\n        self.options = {}\n        self.options_show_override = {}\n        self.loss_history = []\n        self.sample_for_preview = None\n        self.choosed_gpu_indexes = None\n\n        model_data = {}\n        self.model_data_path = Path( self.get_strpath_storage_for_file('data.dat') )\n        if self.model_data_path.exists():\n            io.log_info (f\"Loading {self.model_name} model...\")\n            model_data = pickle.loads ( self.model_data_path.read_bytes() )\n            self.iter = model_data.get('iter',0)\n            if self.iter != 0:\n                self.options = model_data['options']\n                self.loss_history = model_data.get('loss_history', [])\n                self.sample_for_preview = model_data.get('sample_for_preview', None)\n                self.choosed_gpu_indexes = model_data.get('choosed_gpu_indexes', None)\n\n        if self.is_first_run():\n            io.log_info (\"\\nModel first run.\")\n\n        if silent_start:\n            self.device_config = nn.DeviceConfig.BestGPU()\n            io.log_info (f\"Silent start: choosed device {'CPU' if self.device_config.cpu_only else self.device_config.devices[0].name}\")\n        else:\n            self.device_config = nn.DeviceConfig.GPUIndexes( force_gpu_idxs or nn.ask_choose_device_idxs(suggest_best_multi_gpu=True)) \\\n                                if not cpu_only else nn.DeviceConfig.CPU()\n\n        nn.initialize(self.device_config)\n\n        ####\n        self.default_options_path = saved_models_path / f'{self.model_class_name}_default_options.dat'\n        self.default_options = {}\n        if self.default_options_path.exists():\n            try:\n                self.default_options = pickle.loads ( self.default_options_path.read_bytes() )\n            except:\n                pass\n\n        self.choose_preview_history = False\n        self.batch_size = self.load_or_def_option('batch_size', 1)\n        #####\n\n        io.input_skip_pending()\n        self.on_initialize_options()\n\n        if self.is_first_run():\n            # save as default options only for first run model initialize\n            self.default_options_path.write_bytes( pickle.dumps (self.options) )\n\n        self.autobackup_hour = self.options.get('autobackup_hour', 0)\n        self.write_preview_history = self.options.get('write_preview_history', False)\n        self.target_iter = self.options.get('target_iter',0)\n        self.random_flip = self.options.get('random_flip',True)\n        self.random_src_flip = self.options.get('random_src_flip', False)\n        self.random_dst_flip = self.options.get('random_dst_flip', True)\n        \n        self.on_initialize()\n        self.options['batch_size'] = self.batch_size\n\n        self.preview_history_writer = None\n        if self.is_training:\n            self.preview_history_path = self.saved_models_path / ( f'{self.get_model_name()}_history' )\n            self.autobackups_path     = self.saved_models_path / ( f'{self.get_model_name()}_autobackups' )\n\n            if self.write_preview_history or io.is_colab():\n                if not self.preview_history_path.exists():\n                    self.preview_history_path.mkdir(exist_ok=True)\n                else:\n                    if self.iter == 0:\n                        for filename in pathex.get_image_paths(self.preview_history_path):\n                            Path(filename).unlink()\n\n            if self.generator_list is None:\n                raise ValueError( 'You didnt set_training_data_generators()')\n            else:\n                for i, generator in enumerate(self.generator_list):\n                    if not isinstance(generator, SampleGeneratorBase):\n                        raise ValueError('training data generator is not subclass of SampleGeneratorBase')\n\n            self.update_sample_for_preview(choose_preview_history=self.choose_preview_history)\n\n            if self.autobackup_hour != 0:\n                self.autobackup_start_time = time.time()\n\n                if not self.autobackups_path.exists():\n                    self.autobackups_path.mkdir(exist_ok=True)\n\n        io.log_info( self.get_summary_text() )\n\n    def update_sample_for_preview(self, choose_preview_history=False, force_new=False):\n        if self.sample_for_preview is None or choose_preview_history or force_new:\n            if choose_preview_history and io.is_support_windows():\n                wnd_name = \"[p] - next. [space] - switch preview type. [enter] - confirm.\"\n                io.log_info (f\"Choose image for the preview history. {wnd_name}\")\n                io.named_window(wnd_name)\n                io.capture_keys(wnd_name)\n                choosed = False\n                preview_id_counter = 0\n                while not choosed:\n                    self.sample_for_preview = self.generate_next_samples()\n                    previews = self.get_history_previews()\n\n                    io.show_image( wnd_name, ( previews[preview_id_counter % len(previews) ][1] *255).astype(np.uint8) )\n\n                    while True:\n                        key_events = io.get_key_events(wnd_name)\n                        key, chr_key, ctrl_pressed, alt_pressed, shift_pressed = key_events[-1] if len(key_events) > 0 else (0,0,False,False,False)\n                        if key == ord('\\n') or key == ord('\\r'):\n                            choosed = True\n                            break\n                        elif key == ord(' '):\n                            preview_id_counter += 1\n                            break\n                        elif key == ord('p'):\n                            break\n\n                        try:\n                            io.process_messages(0.1)\n                        except KeyboardInterrupt:\n                            choosed = True\n\n                io.destroy_window(wnd_name)\n            else:\n                self.sample_for_preview = self.generate_next_samples()\n\n        try:\n            self.get_history_previews()\n        except:\n            self.sample_for_preview = self.generate_next_samples()\n\n        self.last_sample = self.sample_for_preview\n\n    def load_or_def_option(self, name, def_value):\n        options_val = self.options.get(name, None)\n        if options_val is not None:\n            return options_val\n\n        def_opt_val = self.default_options.get(name, None)\n        if def_opt_val is not None:\n            return def_opt_val\n\n        return def_value\n\n    def ask_override(self):\n        return self.is_training and self.iter != 0 and io.input_in_time (\"Press enter in 2 seconds to override model settings.\", 5 if io.is_colab() else 2 )\n\n    def ask_autobackup_hour(self, default_value=0):\n        default_autobackup_hour = self.options['autobackup_hour'] = self.load_or_def_option('autobackup_hour', default_value)\n        self.options['autobackup_hour'] = io.input_int(f\"Autobackup every N hour\", default_autobackup_hour, add_info=\"0..24\", help_message=\"Autobackup model files with preview every N hour. Latest backup located in model/<>_autobackups/01\")\n\n    def ask_write_preview_history(self, default_value=False):\n        default_write_preview_history = self.load_or_def_option('write_preview_history', default_value)\n        self.options['write_preview_history'] = io.input_bool(f\"Write preview history\", default_write_preview_history, help_message=\"Preview history will be writed to <ModelName>_history folder.\")\n\n        if self.options['write_preview_history']:\n            if io.is_support_windows():\n                self.choose_preview_history = io.input_bool(\"Choose image for the preview history\", False)\n            elif io.is_colab():\n                self.choose_preview_history = io.input_bool(\"Randomly choose new image for preview history\", False, help_message=\"Preview image history will stay stuck with old faces if you reuse the same model on different celebs. Choose no unless you are changing src/dst to a new person\")\n\n    def ask_target_iter(self, default_value=0):\n        default_target_iter = self.load_or_def_option('target_iter', default_value)\n        self.options['target_iter'] = max(0, io.input_int(\"Target iteration\", default_target_iter))\n\n    def ask_random_flip(self):\n        default_random_flip = self.load_or_def_option('random_flip', True)\n        self.options['random_flip'] = io.input_bool(\"Flip faces randomly\", default_random_flip, help_message=\"Predicted face will look more naturally without this option, but src faceset should cover all face directions as dst faceset.\")\n    \n    def ask_random_src_flip(self):\n        default_random_src_flip = self.load_or_def_option('random_src_flip', False)\n        self.options['random_src_flip'] = io.input_bool(\"Flip SRC faces randomly\", default_random_src_flip, help_message=\"Random horizontal flip SRC faceset. Covers more angles, but the face may look less naturally.\")\n\n    def ask_random_dst_flip(self):\n        default_random_dst_flip = self.load_or_def_option('random_dst_flip', True)\n        self.options['random_dst_flip'] = io.input_bool(\"Flip DST faces randomly\", default_random_dst_flip, help_message=\"Random horizontal flip DST faceset. Makes generalization of src->dst better, if src random flip is not enabled.\")\n\n    def ask_batch_size(self, suggest_batch_size=None, range=None):\n        default_batch_size = self.load_or_def_option('batch_size', suggest_batch_size or self.batch_size)\n\n        batch_size = max(0, io.input_int(\"Batch_size\", default_batch_size, valid_range=range, help_message=\"Larger batch size is better for NN's generalization, but it can cause Out of Memory error. Tune this value for your videocard manually.\"))\n\n        if range is not None:\n            batch_size = np.clip(batch_size, range[0], range[1])\n\n        self.options['batch_size'] = self.batch_size = batch_size\n\n\n    #overridable\n    def on_initialize_options(self):\n        pass\n\n    #overridable\n    def on_initialize(self):\n        '''\n        initialize your models\n\n        store and retrieve your model options in self.options['']\n\n        check example\n        '''\n        pass\n\n    #overridable\n    def onSave(self):\n        #save your models here\n        pass\n\n    #overridable\n    def onTrainOneIter(self, sample, generator_list):\n        #train your models here\n\n        #return array of losses\n        return ( ('loss_src', 0), ('loss_dst', 0) )\n\n    #overridable\n    def onGetPreview(self, sample, for_history=False):\n        #you can return multiple previews\n        #return [ ('preview_name',preview_rgb), ... ]\n        return []\n\n    #overridable if you want model name differs from folder name\n    def get_model_name(self):\n        return self.model_name\n\n    #overridable , return [ [model, filename],... ]  list\n    def get_model_filename_list(self):\n        return []\n\n    #overridable\n    def get_MergerConfig(self):\n        #return predictor_func, predictor_input_shape, MergerConfig() for the model\n        raise NotImplementedError\n\n    def get_pretraining_data_path(self):\n        return self.pretraining_data_path\n\n    def get_target_iter(self):\n        return self.target_iter\n\n    def is_reached_iter_goal(self):\n        return self.target_iter != 0 and self.iter >= self.target_iter\n\n    def get_previews(self):\n        return self.onGetPreview ( self.last_sample )\n\n    def get_history_previews(self):\n        return self.onGetPreview (self.sample_for_preview, for_history=True)\n\n    def get_preview_history_writer(self):\n        if self.preview_history_writer is None:\n            self.preview_history_writer = PreviewHistoryWriter()\n        return self.preview_history_writer\n\n    def save(self):\n        Path( self.get_summary_path() ).write_text( self.get_summary_text() )\n\n        self.onSave()\n\n        model_data = {\n            'iter': self.iter,\n            'options': self.options,\n            'loss_history': self.loss_history,\n            'sample_for_preview' : self.sample_for_preview,\n            'choosed_gpu_indexes' : self.choosed_gpu_indexes,\n        }\n        pathex.write_bytes_safe (self.model_data_path, pickle.dumps(model_data) )\n\n        if self.autobackup_hour != 0:\n            diff_hour = int ( (time.time() - self.autobackup_start_time) // 3600 )\n\n            if diff_hour > 0 and diff_hour % self.autobackup_hour == 0:\n                self.autobackup_start_time += self.autobackup_hour*3600\n                self.create_backup()\n\n    def create_backup(self):\n        io.log_info (\"Creating backup...\", end='\\r')\n\n        if not self.autobackups_path.exists():\n            self.autobackups_path.mkdir(exist_ok=True)\n\n        bckp_filename_list = [ self.get_strpath_storage_for_file(filename) for _, filename in self.get_model_filename_list() ]\n        bckp_filename_list += [ str(self.get_summary_path()), str(self.model_data_path) ]\n\n        for i in range(24,0,-1):\n            idx_str = '%.2d' % i\n            next_idx_str = '%.2d' % (i+1)\n\n            idx_backup_path = self.autobackups_path / idx_str\n            next_idx_packup_path = self.autobackups_path / next_idx_str\n\n            if idx_backup_path.exists():\n                if i == 24:\n                    pathex.delete_all_files(idx_backup_path)\n                else:\n                    next_idx_packup_path.mkdir(exist_ok=True)\n                    pathex.move_all_files (idx_backup_path, next_idx_packup_path)\n\n            if i == 1:\n                idx_backup_path.mkdir(exist_ok=True)\n                for filename in bckp_filename_list:\n                    shutil.copy ( str(filename), str(idx_backup_path / Path(filename).name) )\n\n                previews = self.get_previews()\n                plist = []\n                for i in range(len(previews)):\n                    name, bgr = previews[i]\n                    plist += [ (bgr, idx_backup_path / ( ('preview_%s.jpg') % (name))  )  ]\n\n                if len(plist) != 0:\n                    self.get_preview_history_writer().post(plist, self.loss_history, self.iter)\n\n    def debug_one_iter(self):\n        images = []\n        for generator in self.generator_list:\n            for i,batch in enumerate(next(generator)):\n                if len(batch.shape) == 4:\n                    images.append( batch[0] )\n\n        return imagelib.equalize_and_stack_square (images)\n\n    def generate_next_samples(self):\n        sample = []\n        for generator in self.generator_list:\n            if generator.is_initialized():\n                sample.append ( generator.generate_next() )\n            else:\n                sample.append ( [] )\n        self.last_sample = sample\n        return sample\n\n    #overridable\n    def should_save_preview_history(self):\n        return (not io.is_colab() and self.iter % 10 == 0) or (io.is_colab() and self.iter % 100 == 0)\n\n    def train_one_iter(self):\n\n        iter_time = time.time()\n        losses = self.onTrainOneIter()\n        iter_time = time.time() - iter_time\n\n        self.loss_history.append ( [float(loss[1]) for loss in losses] )\n\n        if self.should_save_preview_history():\n            plist = []\n\n            if io.is_colab():\n                previews = self.get_previews()\n                for i in range(len(previews)):\n                    name, bgr = previews[i]\n                    plist += [ (bgr, self.get_strpath_storage_for_file('preview_%s.jpg' % (name) ) ) ]\n\n            if self.write_preview_history:\n                previews = self.get_history_previews()\n                for i in range(len(previews)):\n                    name, bgr = previews[i]\n                    path = self.preview_history_path / name\n                    plist += [ ( bgr, str ( path / ( f'{self.iter:07d}.jpg') ) ) ]\n                    if not io.is_colab():\n                        plist += [ ( bgr, str ( path / ( '_last.jpg' ) )) ]\n\n            if len(plist) != 0:\n                self.get_preview_history_writer().post(plist, self.loss_history, self.iter)\n\n        self.iter += 1\n\n        return self.iter, iter_time\n\n    def pass_one_iter(self):\n        self.generate_next_samples()\n\n    def finalize(self):\n        nn.close_session()\n\n    def is_first_run(self):\n        return self.iter == 0\n\n    def is_debug(self):\n        return self.debug\n\n    def set_batch_size(self, batch_size):\n        self.batch_size = batch_size\n\n    def get_batch_size(self):\n        return self.batch_size\n\n    def get_iter(self):\n        return self.iter\n\n    def set_iter(self, iter):\n        self.iter = iter\n        self.loss_history = self.loss_history[:iter]\n\n    def get_loss_history(self):\n        return self.loss_history\n\n    def set_training_data_generators (self, generator_list):\n        self.generator_list = generator_list\n\n    def get_training_data_generators (self):\n        return self.generator_list\n\n    def get_model_root_path(self):\n        return self.saved_models_path\n\n    def get_strpath_storage_for_file(self, filename):\n        return str( self.saved_models_path / ( self.get_model_name() + '_' + filename) )\n\n    def get_summary_path(self):\n        return self.get_strpath_storage_for_file('summary.txt')\n\n    def get_summary_text(self):\n        visible_options = self.options.copy()\n        visible_options.update(self.options_show_override)\n        \n        ###Generate text summary of model hyperparameters\n        #Find the longest key name and value string. Used as column widths.\n        width_name = max([len(k) for k in visible_options.keys()] + [17]) + 1 # Single space buffer to left edge. Minimum of 17, the length of the longest static string used \"Current iteration\"\n        width_value = max([len(str(x)) for x in visible_options.values()] + [len(str(self.get_iter())), len(self.get_model_name())]) + 1 # Single space buffer to right edge\n        if len(self.device_config.devices) != 0: #Check length of GPU names\n            width_value = max([len(device.name)+1 for device in self.device_config.devices] + [width_value])\n        width_total = width_name + width_value + 2 #Plus 2 for \": \"\n\n        summary_text = []\n        summary_text += [f'=={\" Model Summary \":=^{width_total}}=='] # Model/status summary\n        summary_text += [f'=={\" \"*width_total}==']\n        summary_text += [f'=={\"Model name\": >{width_name}}: {self.get_model_name(): <{width_value}}=='] # Name\n        summary_text += [f'=={\" \"*width_total}==']\n        summary_text += [f'=={\"Current iteration\": >{width_name}}: {str(self.get_iter()): <{width_value}}=='] # Iter\n        summary_text += [f'=={\" \"*width_total}==']\n\n        summary_text += [f'=={\" Model Options \":-^{width_total}}=='] # Model options\n        summary_text += [f'=={\" \"*width_total}==']\n        for key in visible_options.keys():\n            summary_text += [f'=={key: >{width_name}}: {str(visible_options[key]): <{width_value}}=='] # visible_options key/value pairs\n        summary_text += [f'=={\" \"*width_total}==']\n\n        summary_text += [f'=={\" Running On \":-^{width_total}}=='] # Training hardware info\n        summary_text += [f'=={\" \"*width_total}==']\n        if len(self.device_config.devices) == 0:\n            summary_text += [f'=={\"Using device\": >{width_name}}: {\"CPU\": <{width_value}}=='] # cpu_only\n        else:\n            for device in self.device_config.devices:\n                summary_text += [f'=={\"Device index\": >{width_name}}: {device.index: <{width_value}}=='] # GPU hardware device index\n                summary_text += [f'=={\"Name\": >{width_name}}: {device.name: <{width_value}}=='] # GPU name\n                vram_str = f'{device.total_mem_gb:.2f}GB' # GPU VRAM - Formated as #.## (or ##.##)\n                summary_text += [f'=={\"VRAM\": >{width_name}}: {vram_str: <{width_value}}==']\n        summary_text += [f'=={\" \"*width_total}==']\n        summary_text += [f'=={\"=\"*width_total}==']\n        summary_text = \"\\n\".join (summary_text)\n        return summary_text\n\n    @staticmethod\n    def get_loss_history_preview(loss_history, iter, w, c):\n        loss_history = np.array (loss_history.copy())\n\n        lh_height = 100\n        lh_img = np.ones ( (lh_height,w,c) ) * 0.1\n\n        if len(loss_history) != 0:\n            loss_count = len(loss_history[0])\n            lh_len = len(loss_history)\n\n            l_per_col = lh_len / w\n            plist_max = [   [   max (0.0, loss_history[int(col*l_per_col)][p],\n                                                *[  loss_history[i_ab][p]\n                                                    for i_ab in range( int(col*l_per_col), int((col+1)*l_per_col) )\n                                                ]\n                                    )\n                                for p in range(loss_count)\n                            ]\n                            for col in range(w)\n                        ]\n\n            plist_min = [   [   min (plist_max[col][p], loss_history[int(col*l_per_col)][p],\n                                                *[  loss_history[i_ab][p]\n                                                    for i_ab in range( int(col*l_per_col), int((col+1)*l_per_col) )\n                                                ]\n                                    )\n                                for p in range(loss_count)\n                            ]\n                            for col in range(w)\n                        ]\n\n            plist_abs_max = np.mean(loss_history[ len(loss_history) // 5 : ]) * 2\n\n            for col in range(0, w):\n                for p in range(0,loss_count):\n                    point_color = [1.0]*c\n                    point_color[0:3] = colorsys.hsv_to_rgb ( p * (1.0/loss_count), 1.0, 1.0 )\n\n                    ph_max = int ( (plist_max[col][p] / plist_abs_max) * (lh_height-1) )\n                    ph_max = np.clip( ph_max, 0, lh_height-1 )\n\n                    ph_min = int ( (plist_min[col][p] / plist_abs_max) * (lh_height-1) )\n                    ph_min = np.clip( ph_min, 0, lh_height-1 )\n\n                    for ph in range(ph_min, ph_max+1):\n                        lh_img[ (lh_height-ph-1), col ] = point_color\n\n        lh_lines = 5\n        lh_line_height = (lh_height-1)/lh_lines\n        for i in range(0,lh_lines+1):\n            lh_img[ int(i*lh_line_height), : ] = (0.8,)*c\n\n        last_line_t = int((lh_lines-1)*lh_line_height)\n        last_line_b = int(lh_lines*lh_line_height)\n\n        lh_text = 'Iter: %d' % (iter) if iter != 0 else ''\n\n        lh_img[last_line_t:last_line_b, 0:w] += imagelib.get_text_image (  (last_line_b-last_line_t,w,c), lh_text, color=[0.8]*c )\n        return lh_img\n\nclass PreviewHistoryWriter():\n    def __init__(self):\n        self.sq = multiprocessing.Queue()\n        self.p = multiprocessing.Process(target=self.process, args=( self.sq, ))\n        self.p.daemon = True\n        self.p.start()\n\n    def process(self, sq):\n        while True:\n            while not sq.empty():\n                plist, loss_history, iter = sq.get()\n\n                preview_lh_cache = {}\n                for preview, filepath in plist:\n                    filepath = Path(filepath)\n                    i = (preview.shape[1], preview.shape[2])\n\n                    preview_lh = preview_lh_cache.get(i, None)\n                    if preview_lh is None:\n                        preview_lh = ModelBase.get_loss_history_preview(loss_history, iter, preview.shape[1], preview.shape[2])\n                        preview_lh_cache[i] = preview_lh\n\n                    img = (np.concatenate ( [preview_lh, preview], axis=0 ) * 255).astype(np.uint8)\n\n                    filepath.parent.mkdir(parents=True, exist_ok=True)\n                    cv2_imwrite (filepath, img )\n\n            time.sleep(0.01)\n\n    def post(self, plist, loss_history, iter):\n        self.sq.put ( (plist, loss_history, iter) )\n\n    # disable pickling\n    def __getstate__(self):\n        return dict()\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n", "models/Model_XSeg/__init__.py": "from .Model import Model\n", "models/Model_XSeg/Model.py": "import multiprocessing\nimport operator\nfrom functools import partial\n\nimport numpy as np\n\nfrom core import mathlib\nfrom core.interact import interact as io\nfrom core.leras import nn\nfrom facelib import FaceType, XSegNet\nfrom models import ModelBase\nfrom samplelib import *\n\nclass XSegModel(ModelBase):\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, force_model_class_name='XSeg', **kwargs)\n\n    #override\n    def on_initialize_options(self):\n        ask_override = self.ask_override()\n\n        if not self.is_first_run() and ask_override:\n            if io.input_bool(f\"Restart training?\", False, help_message=\"Reset model weights and start training from scratch.\"):\n                self.set_iter(0)\n\n        default_face_type          = self.options['face_type']          = self.load_or_def_option('face_type', 'wf')\n        default_pretrain           = self.options['pretrain']           = self.load_or_def_option('pretrain', False)\n\n        if self.is_first_run():\n            self.options['face_type'] = io.input_str (\"Face type\", default_face_type, ['h','mf','f','wf','head'], help_message=\"Half / mid face / full face / whole face / head. Choose the same as your deepfake model.\").lower()\n\n        if self.is_first_run() or ask_override:\n            self.ask_batch_size(4, range=[2,16])\n            self.options['pretrain'] = io.input_bool (\"Enable pretraining mode\", default_pretrain)\n        \n        if not self.is_exporting and (self.options['pretrain'] and self.get_pretraining_data_path() is None):\n            raise Exception(\"pretraining_data_path is not defined\")\n            \n        self.pretrain_just_disabled = (default_pretrain == True and self.options['pretrain'] == False)\n        \n    #override\n    def on_initialize(self):\n        device_config = nn.getCurrentDeviceConfig()\n        self.model_data_format = \"NCHW\" if self.is_exporting or (len(device_config.devices) != 0 and not self.is_debug()) else \"NHWC\"\n        nn.initialize(data_format=self.model_data_format)\n        tf = nn.tf\n\n        device_config = nn.getCurrentDeviceConfig()\n        devices = device_config.devices\n\n        self.resolution = resolution = 256\n\n\n        self.face_type = {'h'  : FaceType.HALF,\n                          'mf' : FaceType.MID_FULL,\n                          'f'  : FaceType.FULL,\n                          'wf' : FaceType.WHOLE_FACE,\n                          'head' : FaceType.HEAD}[ self.options['face_type'] ]\n        \n            \n        place_model_on_cpu = len(devices) == 0\n        models_opt_device = '/CPU:0' if place_model_on_cpu else nn.tf_default_device_name\n\n        bgr_shape = nn.get4Dshape(resolution,resolution,3)\n        mask_shape = nn.get4Dshape(resolution,resolution,1)\n\n        # Initializing model classes\n        self.model = XSegNet(name='XSeg',\n                               resolution=resolution,\n                               load_weights=not self.is_first_run(),\n                               weights_file_root=self.get_model_root_path(),\n                               training=True,\n                               place_model_on_cpu=place_model_on_cpu,\n                               optimizer=nn.RMSprop(lr=0.0001, lr_dropout=0.3, name='opt'),\n                               data_format=nn.data_format)\n        \n        self.pretrain = self.options['pretrain']\n        if self.pretrain_just_disabled:\n            self.set_iter(0)\n            \n        if self.is_training:\n            # Adjust batch size for multiple GPU\n            gpu_count = max(1, len(devices) )\n            bs_per_gpu = max(1, self.get_batch_size() // gpu_count)\n            self.set_batch_size( gpu_count*bs_per_gpu)\n\n            # Compute losses per GPU\n            gpu_pred_list = []\n\n            gpu_losses = []\n            gpu_loss_gvs = []\n\n            for gpu_id in range(gpu_count):\n                with tf.device(f'/{devices[gpu_id].tf_dev_type}:{gpu_id}' if len(devices) != 0 else f'/CPU:0' ):\n                    with tf.device(f'/CPU:0'):\n                        # slice on CPU, otherwise all batch data will be transfered to GPU first\n                        batch_slice = slice( gpu_id*bs_per_gpu, (gpu_id+1)*bs_per_gpu )\n                        gpu_input_t       = self.model.input_t [batch_slice,:,:,:]\n                        gpu_target_t      = self.model.target_t [batch_slice,:,:,:]\n\n                    # process model tensors\n                    gpu_pred_logits_t, gpu_pred_t = self.model.flow(gpu_input_t, pretrain=self.pretrain)\n                    gpu_pred_list.append(gpu_pred_t)\n                    \n                    \n                    if self.pretrain:\n                        # Structural loss\n                        gpu_loss =  tf.reduce_mean (5*nn.dssim(gpu_target_t, gpu_pred_t, max_val=1.0, filter_size=int(resolution/11.6)), axis=[1])\n                        gpu_loss += tf.reduce_mean (5*nn.dssim(gpu_target_t, gpu_pred_t, max_val=1.0, filter_size=int(resolution/23.2)), axis=[1])\n                        # Pixel loss\n                        gpu_loss += tf.reduce_mean (10*tf.square(gpu_target_t-gpu_pred_t), axis=[1,2,3])\n                    else:\n                        gpu_loss = tf.reduce_mean( tf.nn.sigmoid_cross_entropy_with_logits(labels=gpu_target_t, logits=gpu_pred_logits_t), axis=[1,2,3])\n                      \n                    gpu_losses += [gpu_loss]\n\n                    gpu_loss_gvs += [ nn.gradients ( gpu_loss, self.model.get_weights() ) ]\n\n\n            # Average losses and gradients, and create optimizer update ops\n            #with tf.device(f'/CPU:0'): # Temporary fix. Unknown bug with training freeze starts from 2.4.0, but 2.3.1 was ok\n            with tf.device (models_opt_device):\n                pred = tf.concat(gpu_pred_list, 0)\n                loss = tf.concat(gpu_losses, 0)\n                loss_gv_op = self.model.opt.get_update_op (nn.average_gv_list (gpu_loss_gvs))\n\n\n            # Initializing training and view functions\n            if self.pretrain:\n                def train(input_np, target_np):\n                    l, _ = nn.tf_sess.run ( [loss, loss_gv_op], feed_dict={self.model.input_t :input_np, self.model.target_t :target_np})\n                    return l\n            else:\n                def train(input_np, target_np):\n                    l, _ = nn.tf_sess.run ( [loss, loss_gv_op], feed_dict={self.model.input_t :input_np, self.model.target_t :target_np })\n                    return l\n            self.train = train\n\n            def view(input_np):\n                return nn.tf_sess.run ( [pred], feed_dict={self.model.input_t :input_np})\n            self.view = view\n\n            # initializing sample generators\n            cpu_count = min(multiprocessing.cpu_count(), 8)\n            src_dst_generators_count = cpu_count // 2\n            src_generators_count = cpu_count // 2\n            dst_generators_count = cpu_count // 2\n            \n            if self.pretrain:\n                pretrain_gen = SampleGeneratorFace(self.get_pretraining_data_path(), debug=self.is_debug(), batch_size=self.get_batch_size(),\n                                    sample_process_options=SampleProcessor.Options(random_flip=True),\n                                    output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':True, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                            {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':True, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},                                                            \n                                                          ],\n                                    uniform_yaw_distribution=False,\n                                    generators_count=cpu_count )\n                self.set_training_data_generators ([pretrain_gen])\n            else:   \n                srcdst_generator = SampleGeneratorFaceXSeg([self.training_data_src_path, self.training_data_dst_path],\n                                                            debug=self.is_debug(),\n                                                            batch_size=self.get_batch_size(),\n                                                            resolution=resolution,\n                                                            face_type=self.face_type,\n                                                            generators_count=src_dst_generators_count,\n                                                            data_format=nn.data_format)\n\n                src_generator = SampleGeneratorFace(self.training_data_src_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                                                    sample_process_options=SampleProcessor.Options(random_flip=False),\n                                                    output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,  'warp':False, 'transform':False, 'channel_type' : SampleProcessor.ChannelType.BGR, 'border_replicate':False, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                                        ],\n                                                    generators_count=src_generators_count,\n                                                    raise_on_no_data=False )\n                dst_generator = SampleGeneratorFace(self.training_data_dst_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                                                    sample_process_options=SampleProcessor.Options(random_flip=False),\n                                                    output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,  'warp':False, 'transform':False, 'channel_type' : SampleProcessor.ChannelType.BGR, 'border_replicate':False, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                                        ],\n                                                    generators_count=dst_generators_count,\n                                                    raise_on_no_data=False )\n\n                self.set_training_data_generators ([srcdst_generator, src_generator, dst_generator])\n\n    #override\n    def get_model_filename_list(self):\n        return self.model.model_filename_list\n\n    #override\n    def onSave(self):\n        self.model.save_weights()\n\n    #override\n    def onTrainOneIter(self):\n        image_np, target_np = self.generate_next_samples()[0]\n        loss = self.train (image_np, target_np)\n        \n        return ( ('loss', np.mean(loss) ), )\n\n    #override\n    def onGetPreview(self, samples, for_history=False):\n        n_samples = min(4, self.get_batch_size(), 800 // self.resolution )\n        \n        if self.pretrain:\n            srcdst_samples, = samples       \n            image_np, mask_np = srcdst_samples     \n        else:\n            srcdst_samples, src_samples, dst_samples = samples\n            image_np, mask_np = srcdst_samples\n\n        I, M, IM, = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in ([image_np,mask_np] + self.view (image_np) ) ]\n        M, IM, = [ np.repeat (x, (3,), -1) for x in [M, IM] ]\n\n        green_bg = np.tile( np.array([0,1,0], dtype=np.float32)[None,None,...], (self.resolution,self.resolution,1) )\n\n        result = []\n        st = []\n        for i in range(n_samples):\n            if self.pretrain:\n                ar = I[i], IM[i]\n            else:\n                ar = I[i]*M[i]+0.5*I[i]*(1-M[i])+0.5*green_bg*(1-M[i]), IM[i], I[i]*IM[i]+0.5*I[i]*(1-IM[i]) + 0.5*green_bg*(1-IM[i])\n            st.append ( np.concatenate ( ar, axis=1) )\n        result += [ ('XSeg training faces', np.concatenate (st, axis=0 )), ]\n\n        if not self.pretrain and len(src_samples) != 0:\n            src_np, = src_samples\n\n\n            D, DM, = [ np.clip(nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in ([src_np] + self.view (src_np) ) ]\n            DM, = [ np.repeat (x, (3,), -1) for x in [DM] ]\n\n            st = []\n            for i in range(n_samples):\n                ar = D[i], DM[i], D[i]*DM[i] + 0.5*D[i]*(1-DM[i]) + 0.5*green_bg*(1-DM[i])\n                st.append ( np.concatenate ( ar, axis=1) )\n\n            result += [ ('XSeg src faces', np.concatenate (st, axis=0 )), ]\n\n        if not self.pretrain and len(dst_samples) != 0:\n            dst_np, = dst_samples\n\n\n            D, DM, = [ np.clip(nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in ([dst_np] + self.view (dst_np) ) ]\n            DM, = [ np.repeat (x, (3,), -1) for x in [DM] ]\n\n            st = []\n            for i in range(n_samples):\n                ar = D[i], DM[i], D[i]*DM[i]  + 0.5*D[i]*(1-DM[i]) + 0.5*green_bg*(1-DM[i])\n                st.append ( np.concatenate ( ar, axis=1) )\n\n            result += [ ('XSeg dst faces', np.concatenate (st, axis=0 )), ]\n\n        return result\n        \n    def export_dfm (self):\n        output_path = self.get_strpath_storage_for_file(f'model.onnx')\n        io.log_info(f'Dumping .onnx to {output_path}')\n        tf = nn.tf\n        \n        with tf.device (nn.tf_default_device_name):\n            input_t = tf.placeholder (nn.floatx, (None, self.resolution, self.resolution, 3), name='in_face')\n            input_t = tf.transpose(input_t, (0,3,1,2))\n            _, pred_t = self.model.flow(input_t)\n            pred_t = tf.transpose(pred_t, (0,2,3,1))\n            \n        tf.identity(pred_t, name='out_mask')\n        \n        output_graph_def = tf.graph_util.convert_variables_to_constants(\n            nn.tf_sess, \n            tf.get_default_graph().as_graph_def(), \n            ['out_mask']\n        ) \n        \n        import tf2onnx\n        with tf.device(\"/CPU:0\"):\n            model_proto, _ = tf2onnx.convert._convert_common(\n                output_graph_def,\n                name='XSeg',\n                input_names=['in_face:0'],\n                output_names=['out_mask:0'],\n                opset=13,\n                output_path=output_path)\n                \nModel = XSegModel", "models/Model_SAEHD/__init__.py": "from .Model import Model\n", "models/Model_SAEHD/Model.py": "import multiprocessing\nimport operator\nfrom functools import partial\n\nimport numpy as np\n\nfrom core import mathlib\nfrom core.interact import interact as io\nfrom core.leras import nn\nfrom facelib import FaceType\nfrom models import ModelBase\nfrom samplelib import *\n\nclass SAEHDModel(ModelBase):\n\n    #override\n    def on_initialize_options(self):\n        device_config = nn.getCurrentDeviceConfig()\n\n        lowest_vram = 2\n        if len(device_config.devices) != 0:\n            lowest_vram = device_config.devices.get_worst_device().total_mem_gb\n\n        if lowest_vram >= 4:\n            suggest_batch_size = 8\n        else:\n            suggest_batch_size = 4\n\n        yn_str = {True:'y',False:'n'}\n        min_res = 64\n        max_res = 640\n\n        #default_usefp16            = self.options['use_fp16']           = self.load_or_def_option('use_fp16', False)\n        default_resolution         = self.options['resolution']         = self.load_or_def_option('resolution', 128)\n        default_face_type          = self.options['face_type']          = self.load_or_def_option('face_type', 'f')\n        default_models_opt_on_gpu  = self.options['models_opt_on_gpu']  = self.load_or_def_option('models_opt_on_gpu', True)\n\n        default_archi              = self.options['archi']              = self.load_or_def_option('archi', 'liae-ud')\n\n        default_ae_dims            = self.options['ae_dims']            = self.load_or_def_option('ae_dims', 256)\n        default_e_dims             = self.options['e_dims']             = self.load_or_def_option('e_dims', 64)\n        default_d_dims             = self.options['d_dims']             = self.options.get('d_dims', None)\n        default_d_mask_dims        = self.options['d_mask_dims']        = self.options.get('d_mask_dims', None)\n        default_masked_training    = self.options['masked_training']    = self.load_or_def_option('masked_training', True)\n        default_eyes_mouth_prio    = self.options['eyes_mouth_prio']    = self.load_or_def_option('eyes_mouth_prio', False)\n        default_uniform_yaw        = self.options['uniform_yaw']        = self.load_or_def_option('uniform_yaw', False)\n        default_blur_out_mask      = self.options['blur_out_mask']      = self.load_or_def_option('blur_out_mask', False)\n\n        default_adabelief          = self.options['adabelief']          = self.load_or_def_option('adabelief', True)\n\n        lr_dropout = self.load_or_def_option('lr_dropout', 'n')\n        lr_dropout = {True:'y', False:'n'}.get(lr_dropout, lr_dropout) #backward comp\n        default_lr_dropout         = self.options['lr_dropout'] = lr_dropout\n\n        default_random_warp        = self.options['random_warp']        = self.load_or_def_option('random_warp', True)\n        default_random_hsv_power   = self.options['random_hsv_power']   = self.load_or_def_option('random_hsv_power', 0.0)\n        default_true_face_power    = self.options['true_face_power']    = self.load_or_def_option('true_face_power', 0.0)\n        default_face_style_power   = self.options['face_style_power']   = self.load_or_def_option('face_style_power', 0.0)\n        default_bg_style_power     = self.options['bg_style_power']     = self.load_or_def_option('bg_style_power', 0.0)\n        default_ct_mode            = self.options['ct_mode']            = self.load_or_def_option('ct_mode', 'none')\n        default_clipgrad           = self.options['clipgrad']           = self.load_or_def_option('clipgrad', False)\n        default_pretrain           = self.options['pretrain']           = self.load_or_def_option('pretrain', False)\n\n        ask_override = self.ask_override()\n        if self.is_first_run() or ask_override:\n            self.ask_autobackup_hour()\n            self.ask_write_preview_history()\n            self.ask_target_iter()\n            self.ask_random_src_flip()\n            self.ask_random_dst_flip()\n            self.ask_batch_size(suggest_batch_size)\n            #self.options['use_fp16'] = io.input_bool (\"Use fp16\", default_usefp16, help_message='Increases training/inference speed, reduces model size. Model may crash. Enable it after 1-5k iters.')\n\n        if self.is_first_run():\n            resolution = io.input_int(\"Resolution\", default_resolution, add_info=\"64-640\", help_message=\"More resolution requires more VRAM and time to train. Value will be adjusted to multiple of 16 and 32 for -d archi.\")\n            resolution = np.clip ( (resolution // 16) * 16, min_res, max_res)\n            self.options['resolution'] = resolution\n\n\n\n            self.options['face_type'] = io.input_str (\"Face type\", default_face_type, ['h','mf','f','wf','head'], help_message=\"Half / mid face / full face / whole face / head. Half face has better resolution, but covers less area of cheeks. Mid face is 30% wider than half face. 'Whole face' covers full area of face include forehead. 'head' covers full head, but requires XSeg for src and dst faceset.\").lower()\n\n            while True:\n                archi = io.input_str (\"AE architecture\", default_archi, help_message=\\\n\"\"\"\n'df' keeps more identity-preserved face.\n'liae' can fix overly different face shapes.\n'-u' increased likeness of the face.\n'-d' (experimental) doubling the resolution using the same computation cost.\nExamples: df, liae, df-d, df-ud, liae-ud, ...\n\"\"\").lower()\n\n                archi_split = archi.split('-')\n\n                if len(archi_split) == 2:\n                    archi_type, archi_opts = archi_split\n                elif len(archi_split) == 1:\n                    archi_type, archi_opts = archi_split[0], None\n                else:\n                    continue\n\n                if archi_type not in ['df', 'liae']:\n                    continue\n\n                if archi_opts is not None:\n                    if len(archi_opts) == 0:\n                        continue\n                    if len([ 1 for opt in archi_opts if opt not in ['u','d','t','c'] ]) != 0:\n                        continue\n\n                    if 'd' in archi_opts:\n                        self.options['resolution'] = np.clip ( (self.options['resolution'] // 32) * 32, min_res, max_res)\n\n                break\n            self.options['archi'] = archi\n\n        default_d_dims             = self.options['d_dims']             = self.load_or_def_option('d_dims', 64)\n\n        default_d_mask_dims        = default_d_dims // 3\n        default_d_mask_dims        += default_d_mask_dims % 2\n        default_d_mask_dims        = self.options['d_mask_dims']        = self.load_or_def_option('d_mask_dims', default_d_mask_dims)\n\n        if self.is_first_run():\n            self.options['ae_dims'] = np.clip ( io.input_int(\"AutoEncoder dimensions\", default_ae_dims, add_info=\"32-1024\", help_message=\"All face information will packed to AE dims. If amount of AE dims are not enough, then for example closed eyes will not be recognized. More dims are better, but require more VRAM. You can fine-tune model size to fit your GPU.\" ), 32, 1024 )\n\n            e_dims = np.clip ( io.input_int(\"Encoder dimensions\", default_e_dims, add_info=\"16-256\", help_message=\"More dims help to recognize more facial features and achieve sharper result, but require more VRAM. You can fine-tune model size to fit your GPU.\" ), 16, 256 )\n            self.options['e_dims'] = e_dims + e_dims % 2\n\n            d_dims = np.clip ( io.input_int(\"Decoder dimensions\", default_d_dims, add_info=\"16-256\", help_message=\"More dims help to recognize more facial features and achieve sharper result, but require more VRAM. You can fine-tune model size to fit your GPU.\" ), 16, 256 )\n            self.options['d_dims'] = d_dims + d_dims % 2\n\n            d_mask_dims = np.clip ( io.input_int(\"Decoder mask dimensions\", default_d_mask_dims, add_info=\"16-256\", help_message=\"Typical mask dimensions = decoder dimensions / 3. If you manually cut out obstacles from the dst mask, you can increase this parameter to achieve better quality.\" ), 16, 256 )\n            self.options['d_mask_dims'] = d_mask_dims + d_mask_dims % 2\n\n        if self.is_first_run() or ask_override:\n            if self.options['face_type'] == 'wf' or self.options['face_type'] == 'head':\n                self.options['masked_training']  = io.input_bool (\"Masked training\", default_masked_training, help_message=\"This option is available only for 'whole_face' or 'head' type. Masked training clips training area to full_face mask or XSeg mask, thus network will train the faces properly.\")\n\n            self.options['eyes_mouth_prio'] = io.input_bool (\"Eyes and mouth priority\", default_eyes_mouth_prio, help_message='Helps to fix eye problems during training like \"alien eyes\" and wrong eyes direction. Also makes the detail of the teeth higher.')\n            self.options['uniform_yaw'] = io.input_bool (\"Uniform yaw distribution of samples\", default_uniform_yaw, help_message='Helps to fix blurry side faces due to small amount of them in the faceset.')\n            self.options['blur_out_mask'] = io.input_bool (\"Blur out mask\", default_blur_out_mask, help_message='Blurs nearby area outside of applied face mask of training samples. The result is the background near the face is smoothed and less noticeable on swapped face. The exact xseg mask in src and dst faceset is required.')\n\n        default_gan_power          = self.options['gan_power']          = self.load_or_def_option('gan_power', 0.0)\n        default_gan_patch_size     = self.options['gan_patch_size']     = self.load_or_def_option('gan_patch_size', self.options['resolution'] // 8)\n        default_gan_dims           = self.options['gan_dims']           = self.load_or_def_option('gan_dims', 16)\n\n        if self.is_first_run() or ask_override:\n            self.options['models_opt_on_gpu'] = io.input_bool (\"Place models and optimizer on GPU\", default_models_opt_on_gpu, help_message=\"When you train on one GPU, by default model and optimizer weights are placed on GPU to accelerate the process. You can place they on CPU to free up extra VRAM, thus set bigger dimensions.\")\n\n            self.options['adabelief'] = io.input_bool (\"Use AdaBelief optimizer?\", default_adabelief, help_message=\"Use AdaBelief optimizer. It requires more VRAM, but the accuracy and the generalization of the model is higher.\")\n\n            self.options['lr_dropout']  = io.input_str (f\"Use learning rate dropout\", default_lr_dropout, ['n','y','cpu'], help_message=\"When the face is trained enough, you can enable this option to get extra sharpness and reduce subpixel shake for less amount of iterations. Enabled it before `disable random warp` and before GAN. \\nn - disabled.\\ny - enabled\\ncpu - enabled on CPU. This allows not to use extra VRAM, sacrificing 20% time of iteration.\")\n\n            self.options['random_warp'] = io.input_bool (\"Enable random warp of samples\", default_random_warp, help_message=\"Random warp is required to generalize facial expressions of both faces. When the face is trained enough, you can disable it to get extra sharpness and reduce subpixel shake for less amount of iterations.\")\n\n            self.options['random_hsv_power'] = np.clip ( io.input_number (\"Random hue/saturation/light intensity\", default_random_hsv_power, add_info=\"0.0 .. 0.3\", help_message=\"Random hue/saturation/light intensity applied to the src face set only at the input of the neural network. Stabilizes color perturbations during face swapping. Reduces the quality of the color transfer by selecting the closest one in the src faceset. Thus the src faceset must be diverse enough. Typical fine value is 0.05\"), 0.0, 0.3 )\n\n            self.options['gan_power'] = np.clip ( io.input_number (\"GAN power\", default_gan_power, add_info=\"0.0 .. 5.0\", help_message=\"Forces the neural network to learn small details of the face. Enable it only when the face is trained enough with lr_dropout(on) and random_warp(off), and don't disable. The higher the value, the higher the chances of artifacts. Typical fine value is 0.1\"), 0.0, 5.0 )\n\n            if self.options['gan_power'] != 0.0:\n                gan_patch_size = np.clip ( io.input_int(\"GAN patch size\", default_gan_patch_size, add_info=\"3-640\", help_message=\"The higher patch size, the higher the quality, the more VRAM is required. You can get sharper edges even at the lowest setting. Typical fine value is resolution / 8.\" ), 3, 640 )\n                self.options['gan_patch_size'] = gan_patch_size\n\n                gan_dims = np.clip ( io.input_int(\"GAN dimensions\", default_gan_dims, add_info=\"4-512\", help_message=\"The dimensions of the GAN network. The higher dimensions, the more VRAM is required. You can get sharper edges even at the lowest setting. Typical fine value is 16.\" ), 4, 512 )\n                self.options['gan_dims'] = gan_dims\n\n            if 'df' in self.options['archi']:\n                self.options['true_face_power'] = np.clip ( io.input_number (\"'True face' power.\", default_true_face_power, add_info=\"0.0000 .. 1.0\", help_message=\"Experimental option. Discriminates result face to be more like src face. Higher value - stronger discrimination. Typical value is 0.01 . Comparison - https://i.imgur.com/czScS9q.png\"), 0.0, 1.0 )\n            else:\n                self.options['true_face_power'] = 0.0\n\n            self.options['face_style_power'] = np.clip ( io.input_number(\"Face style power\", default_face_style_power, add_info=\"0.0..100.0\", help_message=\"Learn the color of the predicted face to be the same as dst inside mask. If you want to use this option with 'whole_face' you have to use XSeg trained mask. Warning: Enable it only after 10k iters, when predicted face is clear enough to start learn style. Start from 0.001 value and check history changes. Enabling this option increases the chance of model collapse.\"), 0.0, 100.0 )\n            self.options['bg_style_power'] = np.clip ( io.input_number(\"Background style power\", default_bg_style_power, add_info=\"0.0..100.0\", help_message=\"Learn the area outside mask of the predicted face to be the same as dst. If you want to use this option with 'whole_face' you have to use XSeg trained mask. For whole_face you have to use XSeg trained mask. This can make face more like dst. Enabling this option increases the chance of model collapse. Typical value is 2.0\"), 0.0, 100.0 )\n\n            self.options['ct_mode'] = io.input_str (f\"Color transfer for src faceset\", default_ct_mode, ['none','rct','lct','mkl','idt','sot'], help_message=\"Change color distribution of src samples close to dst samples. Try all modes to find the best.\")\n            self.options['clipgrad'] = io.input_bool (\"Enable gradient clipping\", default_clipgrad, help_message=\"Gradient clipping reduces chance of model collapse, sacrificing speed of training.\")\n\n            self.options['pretrain'] = io.input_bool (\"Enable pretraining mode\", default_pretrain, help_message=\"Pretrain the model with large amount of various faces. After that, model can be used to train the fakes more quickly. Forces random_warp=N, random_flips=Y, gan_power=0.0, lr_dropout=N, styles=0.0, uniform_yaw=Y\")\n\n        if self.options['pretrain'] and self.get_pretraining_data_path() is None:\n            raise Exception(\"pretraining_data_path is not defined\")\n\n        self.gan_model_changed = (default_gan_patch_size != self.options['gan_patch_size']) or (default_gan_dims != self.options['gan_dims'])\n\n        self.pretrain_just_disabled = (default_pretrain == True and self.options['pretrain'] == False)\n\n    #override\n    def on_initialize(self):\n        device_config = nn.getCurrentDeviceConfig()\n        devices = device_config.devices\n        self.model_data_format = \"NCHW\" if len(devices) != 0 and not self.is_debug() else \"NHWC\"\n        nn.initialize(data_format=self.model_data_format)\n        tf = nn.tf\n\n        self.resolution = resolution = self.options['resolution']\n        self.face_type = {'h'  : FaceType.HALF,\n                          'mf' : FaceType.MID_FULL,\n                          'f'  : FaceType.FULL,\n                          'wf' : FaceType.WHOLE_FACE,\n                          'head' : FaceType.HEAD}[ self.options['face_type'] ]\n\n        if 'eyes_prio' in self.options:\n            self.options.pop('eyes_prio')\n\n        eyes_mouth_prio = self.options['eyes_mouth_prio']\n\n        archi_split = self.options['archi'].split('-')\n\n        if len(archi_split) == 2:\n            archi_type, archi_opts = archi_split\n        elif len(archi_split) == 1:\n            archi_type, archi_opts = archi_split[0], None\n\n        self.archi_type = archi_type\n\n        ae_dims = self.options['ae_dims']\n        e_dims = self.options['e_dims']\n        d_dims = self.options['d_dims']\n        d_mask_dims = self.options['d_mask_dims']\n        self.pretrain = self.options['pretrain']\n        if self.pretrain_just_disabled:\n            self.set_iter(0)\n\n        adabelief = self.options['adabelief']\n\n        use_fp16 = False\n        if self.is_exporting:\n            use_fp16 = io.input_bool (\"Export quantized?\", False, help_message='Makes the exported model faster. If you have problems, disable this option.')\n\n        self.gan_power = gan_power = 0.0 if self.pretrain else self.options['gan_power']\n        random_warp = False if self.pretrain else self.options['random_warp']\n        random_src_flip = self.random_src_flip if not self.pretrain else True\n        random_dst_flip = self.random_dst_flip if not self.pretrain else True\n        random_hsv_power = self.options['random_hsv_power'] if not self.pretrain else 0.0\n        blur_out_mask = self.options['blur_out_mask']\n\n        if self.pretrain:\n            self.options_show_override['lr_dropout'] = 'n'\n            self.options_show_override['random_warp'] = False\n            self.options_show_override['gan_power'] = 0.0\n            self.options_show_override['random_hsv_power'] = 0.0\n            self.options_show_override['face_style_power'] = 0.0\n            self.options_show_override['bg_style_power'] = 0.0\n            self.options_show_override['uniform_yaw'] = True\n\n        masked_training = self.options['masked_training']\n        ct_mode = self.options['ct_mode']\n        if ct_mode == 'none':\n            ct_mode = None\n\n\n        models_opt_on_gpu = False if len(devices) == 0 else self.options['models_opt_on_gpu']\n        models_opt_device = nn.tf_default_device_name if models_opt_on_gpu and self.is_training else '/CPU:0'\n        optimizer_vars_on_cpu = models_opt_device=='/CPU:0'\n\n        input_ch=3\n        bgr_shape = self.bgr_shape = nn.get4Dshape(resolution,resolution,input_ch)\n        mask_shape = nn.get4Dshape(resolution,resolution,1)\n        self.model_filename_list = []\n\n        with tf.device ('/CPU:0'):\n            #Place holders on CPU\n            self.warped_src = tf.placeholder (nn.floatx, bgr_shape, name='warped_src')\n            self.warped_dst = tf.placeholder (nn.floatx, bgr_shape, name='warped_dst')\n\n            self.target_src = tf.placeholder (nn.floatx, bgr_shape, name='target_src')\n            self.target_dst = tf.placeholder (nn.floatx, bgr_shape, name='target_dst')\n\n            self.target_srcm    = tf.placeholder (nn.floatx, mask_shape, name='target_srcm')\n            self.target_srcm_em = tf.placeholder (nn.floatx, mask_shape, name='target_srcm_em')\n            self.target_dstm    = tf.placeholder (nn.floatx, mask_shape, name='target_dstm')\n            self.target_dstm_em = tf.placeholder (nn.floatx, mask_shape, name='target_dstm_em')\n\n        # Initializing model classes\n        model_archi = nn.DeepFakeArchi(resolution, use_fp16=use_fp16, opts=archi_opts)\n\n        with tf.device (models_opt_device):\n            if 'df' in archi_type:\n                self.encoder = model_archi.Encoder(in_ch=input_ch, e_ch=e_dims, name='encoder')\n                encoder_out_ch = self.encoder.get_out_ch()*self.encoder.get_out_res(resolution)**2\n\n                self.inter = model_archi.Inter (in_ch=encoder_out_ch, ae_ch=ae_dims, ae_out_ch=ae_dims, name='inter')\n                inter_out_ch = self.inter.get_out_ch()\n\n                self.decoder_src = model_archi.Decoder(in_ch=inter_out_ch, d_ch=d_dims, d_mask_ch=d_mask_dims, name='decoder_src')\n                self.decoder_dst = model_archi.Decoder(in_ch=inter_out_ch, d_ch=d_dims, d_mask_ch=d_mask_dims, name='decoder_dst')\n\n                self.model_filename_list += [ [self.encoder,     'encoder.npy'    ],\n                                              [self.inter,       'inter.npy'      ],\n                                              [self.decoder_src, 'decoder_src.npy'],\n                                              [self.decoder_dst, 'decoder_dst.npy']  ]\n\n                if self.is_training:\n                    if self.options['true_face_power'] != 0:\n                        self.code_discriminator = nn.CodeDiscriminator(ae_dims, code_res=self.inter.get_out_res(), name='dis' )\n                        self.model_filename_list += [ [self.code_discriminator, 'code_discriminator.npy'] ]\n\n            elif 'liae' in archi_type:\n                self.encoder = model_archi.Encoder(in_ch=input_ch, e_ch=e_dims, name='encoder')\n                encoder_out_ch = self.encoder.get_out_ch()*self.encoder.get_out_res(resolution)**2\n\n                self.inter_AB = model_archi.Inter(in_ch=encoder_out_ch, ae_ch=ae_dims, ae_out_ch=ae_dims*2, name='inter_AB')\n                self.inter_B  = model_archi.Inter(in_ch=encoder_out_ch, ae_ch=ae_dims, ae_out_ch=ae_dims*2, name='inter_B')\n\n                inter_out_ch = self.inter_AB.get_out_ch()\n                inters_out_ch = inter_out_ch*2\n                self.decoder = model_archi.Decoder(in_ch=inters_out_ch, d_ch=d_dims, d_mask_ch=d_mask_dims, name='decoder')\n\n                self.model_filename_list += [ [self.encoder,  'encoder.npy'],\n                                              [self.inter_AB, 'inter_AB.npy'],\n                                              [self.inter_B , 'inter_B.npy'],\n                                              [self.decoder , 'decoder.npy'] ]\n\n            if self.is_training:\n                if gan_power != 0:\n                    self.D_src = nn.UNetPatchDiscriminator(patch_size=self.options['gan_patch_size'], in_ch=input_ch, base_ch=self.options['gan_dims'], name=\"D_src\")\n                    self.model_filename_list += [ [self.D_src, 'GAN.npy'] ]\n\n                # Initialize optimizers\n                lr=5e-5\n                if self.options['lr_dropout'] in ['y','cpu'] and not self.pretrain:\n                    lr_cos = 500\n                    lr_dropout = 0.3\n                else:\n                    lr_cos = 0\n                    lr_dropout = 1.0\n                OptimizerClass = nn.AdaBelief if adabelief else nn.RMSprop\n                clipnorm = 1.0 if self.options['clipgrad'] else 0.0\n\n                if 'df' in archi_type:\n                    self.src_dst_saveable_weights = self.encoder.get_weights() + self.inter.get_weights() + self.decoder_src.get_weights() + self.decoder_dst.get_weights()\n                    self.src_dst_trainable_weights = self.src_dst_saveable_weights\n                elif 'liae' in archi_type:\n                    self.src_dst_saveable_weights = self.encoder.get_weights() + self.inter_AB.get_weights() + self.inter_B.get_weights() + self.decoder.get_weights()\n                    if random_warp:\n                        self.src_dst_trainable_weights = self.src_dst_saveable_weights\n                    else:\n                        self.src_dst_trainable_weights = self.encoder.get_weights() + self.inter_B.get_weights() + self.decoder.get_weights()\n\n                self.src_dst_opt = OptimizerClass(lr=lr, lr_dropout=lr_dropout, lr_cos=lr_cos, clipnorm=clipnorm, name='src_dst_opt')\n                self.src_dst_opt.initialize_variables (self.src_dst_saveable_weights, vars_on_cpu=optimizer_vars_on_cpu, lr_dropout_on_cpu=self.options['lr_dropout']=='cpu')\n                self.model_filename_list += [ (self.src_dst_opt, 'src_dst_opt.npy') ]\n\n                if self.options['true_face_power'] != 0:\n                    self.D_code_opt = OptimizerClass(lr=lr, lr_dropout=lr_dropout, lr_cos=lr_cos, clipnorm=clipnorm, name='D_code_opt')\n                    self.D_code_opt.initialize_variables ( self.code_discriminator.get_weights(), vars_on_cpu=optimizer_vars_on_cpu, lr_dropout_on_cpu=self.options['lr_dropout']=='cpu')\n                    self.model_filename_list += [ (self.D_code_opt, 'D_code_opt.npy') ]\n\n                if gan_power != 0:\n                    self.D_src_dst_opt = OptimizerClass(lr=lr, lr_dropout=lr_dropout, lr_cos=lr_cos, clipnorm=clipnorm, name='GAN_opt')\n                    self.D_src_dst_opt.initialize_variables ( self.D_src.get_weights(), vars_on_cpu=optimizer_vars_on_cpu, lr_dropout_on_cpu=self.options['lr_dropout']=='cpu')#+self.D_src_x2.get_weights()\n                    self.model_filename_list += [ (self.D_src_dst_opt, 'GAN_opt.npy') ]\n\n        if self.is_training:\n            # Adjust batch size for multiple GPU\n            gpu_count = max(1, len(devices) )\n            bs_per_gpu = max(1, self.get_batch_size() // gpu_count)\n            self.set_batch_size( gpu_count*bs_per_gpu)\n\n            # Compute losses per GPU\n            gpu_pred_src_src_list = []\n            gpu_pred_dst_dst_list = []\n            gpu_pred_src_dst_list = []\n            gpu_pred_src_srcm_list = []\n            gpu_pred_dst_dstm_list = []\n            gpu_pred_src_dstm_list = []\n\n            gpu_src_losses = []\n            gpu_dst_losses = []\n            gpu_G_loss_gvs = []\n            gpu_D_code_loss_gvs = []\n            gpu_D_src_dst_loss_gvs = []\n\n            for gpu_id in range(gpu_count):\n                with tf.device( f'/{devices[gpu_id].tf_dev_type}:{gpu_id}' if len(devices) != 0 else f'/CPU:0' ):\n                    with tf.device(f'/CPU:0'):\n                        # slice on CPU, otherwise all batch data will be transfered to GPU first\n                        batch_slice = slice( gpu_id*bs_per_gpu, (gpu_id+1)*bs_per_gpu )\n                        gpu_warped_src      = self.warped_src [batch_slice,:,:,:]\n                        gpu_warped_dst      = self.warped_dst [batch_slice,:,:,:]\n                        gpu_target_src      = self.target_src [batch_slice,:,:,:]\n                        gpu_target_dst      = self.target_dst [batch_slice,:,:,:]\n                        gpu_target_srcm     = self.target_srcm[batch_slice,:,:,:]\n                        gpu_target_srcm_em  = self.target_srcm_em[batch_slice,:,:,:]\n                        gpu_target_dstm     = self.target_dstm[batch_slice,:,:,:]\n                        gpu_target_dstm_em  = self.target_dstm_em[batch_slice,:,:,:]\n\n                    gpu_target_srcm_anti = 1-gpu_target_srcm\n                    gpu_target_dstm_anti = 1-gpu_target_dstm\n\n                    if blur_out_mask:\n                        sigma = resolution / 128\n\n                        x = nn.gaussian_blur(gpu_target_src*gpu_target_srcm_anti, sigma)\n                        y = 1-nn.gaussian_blur(gpu_target_srcm, sigma)\n                        y = tf.where(tf.equal(y, 0), tf.ones_like(y), y)\n                        gpu_target_src = gpu_target_src*gpu_target_srcm + (x/y)*gpu_target_srcm_anti\n\n                        x = nn.gaussian_blur(gpu_target_dst*gpu_target_dstm_anti, sigma)\n                        y = 1-nn.gaussian_blur(gpu_target_dstm, sigma)\n                        y = tf.where(tf.equal(y, 0), tf.ones_like(y), y)\n                        gpu_target_dst = gpu_target_dst*gpu_target_dstm + (x/y)*gpu_target_dstm_anti\n\n\n                    # process model tensors\n                    if 'df' in archi_type:\n                        gpu_src_code     = self.inter(self.encoder(gpu_warped_src))\n                        gpu_dst_code     = self.inter(self.encoder(gpu_warped_dst))\n                        gpu_pred_src_src, gpu_pred_src_srcm = self.decoder_src(gpu_src_code)\n                        gpu_pred_dst_dst, gpu_pred_dst_dstm = self.decoder_dst(gpu_dst_code)\n                        gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder_src(gpu_dst_code)\n                        gpu_pred_src_dst_no_code_grad, _ = self.decoder_src(tf.stop_gradient(gpu_dst_code))\n\n                    elif 'liae' in archi_type:\n                        gpu_src_code = self.encoder (gpu_warped_src)\n                        gpu_src_inter_AB_code = self.inter_AB (gpu_src_code)\n                        gpu_src_code = tf.concat([gpu_src_inter_AB_code,gpu_src_inter_AB_code], nn.conv2d_ch_axis  )\n                        gpu_dst_code = self.encoder (gpu_warped_dst)\n                        gpu_dst_inter_B_code = self.inter_B (gpu_dst_code)\n                        gpu_dst_inter_AB_code = self.inter_AB (gpu_dst_code)\n                        gpu_dst_code = tf.concat([gpu_dst_inter_B_code,gpu_dst_inter_AB_code], nn.conv2d_ch_axis )\n                        gpu_src_dst_code = tf.concat([gpu_dst_inter_AB_code,gpu_dst_inter_AB_code], nn.conv2d_ch_axis )\n\n                        gpu_pred_src_src, gpu_pred_src_srcm = self.decoder(gpu_src_code)\n                        gpu_pred_dst_dst, gpu_pred_dst_dstm = self.decoder(gpu_dst_code)\n                        gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder(gpu_src_dst_code)\n                        gpu_pred_src_dst_no_code_grad, _ = self.decoder(tf.stop_gradient(gpu_src_dst_code))\n\n                    gpu_pred_src_src_list.append(gpu_pred_src_src)\n                    gpu_pred_dst_dst_list.append(gpu_pred_dst_dst)\n                    gpu_pred_src_dst_list.append(gpu_pred_src_dst)\n\n                    gpu_pred_src_srcm_list.append(gpu_pred_src_srcm)\n                    gpu_pred_dst_dstm_list.append(gpu_pred_dst_dstm)\n                    gpu_pred_src_dstm_list.append(gpu_pred_src_dstm)\n\n                    gpu_target_srcm_blur = nn.gaussian_blur(gpu_target_srcm,  max(1, resolution // 32) )\n                    gpu_target_srcm_blur = tf.clip_by_value(gpu_target_srcm_blur, 0, 0.5) * 2\n                    gpu_target_srcm_anti_blur = 1.0-gpu_target_srcm_blur\n\n                    gpu_target_dstm_blur = nn.gaussian_blur(gpu_target_dstm,  max(1, resolution // 32) )\n                    gpu_target_dstm_blur = tf.clip_by_value(gpu_target_dstm_blur, 0, 0.5) * 2\n\n                    gpu_style_mask_blur = nn.gaussian_blur(gpu_pred_src_dstm*gpu_pred_dst_dstm,  max(1, resolution // 32) )\n                    gpu_style_mask_blur = tf.stop_gradient(tf.clip_by_value(gpu_target_srcm_blur, 0, 1.0))\n                    gpu_style_mask_anti_blur = 1.0 - gpu_style_mask_blur\n\n                    gpu_target_dst_masked = gpu_target_dst*gpu_target_dstm_blur\n\n                    gpu_target_src_anti_masked = gpu_target_src*gpu_target_srcm_anti_blur\n                    gpu_pred_src_src_anti_masked = gpu_pred_src_src*gpu_target_srcm_anti_blur\n\n                    gpu_target_src_masked_opt  = gpu_target_src*gpu_target_srcm_blur if masked_training else gpu_target_src\n                    gpu_target_dst_masked_opt  = gpu_target_dst_masked if masked_training else gpu_target_dst\n                    gpu_pred_src_src_masked_opt = gpu_pred_src_src*gpu_target_srcm_blur if masked_training else gpu_pred_src_src\n                    gpu_pred_dst_dst_masked_opt = gpu_pred_dst_dst*gpu_target_dstm_blur if masked_training else gpu_pred_dst_dst\n\n                    if resolution < 256:\n                        gpu_src_loss =  tf.reduce_mean ( 10*nn.dssim(gpu_target_src_masked_opt, gpu_pred_src_src_masked_opt, max_val=1.0, filter_size=int(resolution/11.6)), axis=[1])\n                    else:\n                        gpu_src_loss =  tf.reduce_mean ( 5*nn.dssim(gpu_target_src_masked_opt, gpu_pred_src_src_masked_opt, max_val=1.0, filter_size=int(resolution/11.6)), axis=[1])\n                        gpu_src_loss += tf.reduce_mean ( 5*nn.dssim(gpu_target_src_masked_opt, gpu_pred_src_src_masked_opt, max_val=1.0, filter_size=int(resolution/23.2)), axis=[1])\n                    gpu_src_loss += tf.reduce_mean ( 10*tf.square ( gpu_target_src_masked_opt - gpu_pred_src_src_masked_opt ), axis=[1,2,3])\n\n                    if eyes_mouth_prio:\n                        gpu_src_loss += tf.reduce_mean ( 300*tf.abs ( gpu_target_src*gpu_target_srcm_em - gpu_pred_src_src*gpu_target_srcm_em ), axis=[1,2,3])\n\n                    gpu_src_loss += tf.reduce_mean ( 10*tf.square( gpu_target_srcm - gpu_pred_src_srcm ),axis=[1,2,3] )\n\n                    face_style_power = self.options['face_style_power'] / 100.0\n                    if face_style_power != 0 and not self.pretrain:\n                        gpu_src_loss += nn.style_loss(gpu_pred_src_dst_no_code_grad*tf.stop_gradient(gpu_pred_src_dstm), tf.stop_gradient(gpu_pred_dst_dst*gpu_pred_dst_dstm), gaussian_blur_radius=resolution//8, loss_weight=10000*face_style_power)\n\n                    bg_style_power = self.options['bg_style_power'] / 100.0\n                    if bg_style_power != 0 and not self.pretrain:\n                        gpu_target_dst_style_anti_masked = gpu_target_dst*gpu_style_mask_anti_blur\n                        gpu_psd_style_anti_masked = gpu_pred_src_dst*gpu_style_mask_anti_blur\n\n                        gpu_src_loss += tf.reduce_mean( (10*bg_style_power)*nn.dssim( gpu_psd_style_anti_masked,  gpu_target_dst_style_anti_masked, max_val=1.0, filter_size=int(resolution/11.6)), axis=[1])\n                        gpu_src_loss += tf.reduce_mean( (10*bg_style_power)*tf.square(gpu_psd_style_anti_masked - gpu_target_dst_style_anti_masked), axis=[1,2,3] )\n\n                    if resolution < 256:\n                        gpu_dst_loss = tf.reduce_mean ( 10*nn.dssim(gpu_target_dst_masked_opt, gpu_pred_dst_dst_masked_opt, max_val=1.0, filter_size=int(resolution/11.6) ), axis=[1])\n                    else:\n                        gpu_dst_loss = tf.reduce_mean ( 5*nn.dssim(gpu_target_dst_masked_opt, gpu_pred_dst_dst_masked_opt, max_val=1.0, filter_size=int(resolution/11.6) ), axis=[1])\n                        gpu_dst_loss += tf.reduce_mean ( 5*nn.dssim(gpu_target_dst_masked_opt, gpu_pred_dst_dst_masked_opt, max_val=1.0, filter_size=int(resolution/23.2) ), axis=[1])\n                    gpu_dst_loss += tf.reduce_mean ( 10*tf.square(  gpu_target_dst_masked_opt- gpu_pred_dst_dst_masked_opt ), axis=[1,2,3])\n\n                    if eyes_mouth_prio:\n                        gpu_dst_loss += tf.reduce_mean ( 300*tf.abs ( gpu_target_dst*gpu_target_dstm_em - gpu_pred_dst_dst*gpu_target_dstm_em ), axis=[1,2,3])\n\n                    gpu_dst_loss += tf.reduce_mean ( 10*tf.square( gpu_target_dstm - gpu_pred_dst_dstm ),axis=[1,2,3] )\n\n                    gpu_src_losses += [gpu_src_loss]\n                    gpu_dst_losses += [gpu_dst_loss]\n\n                    gpu_G_loss = gpu_src_loss + gpu_dst_loss\n\n                    def DLoss(labels,logits):\n                        return tf.reduce_mean( tf.nn.sigmoid_cross_entropy_with_logits(labels=labels, logits=logits), axis=[1,2,3])\n\n                    if self.options['true_face_power'] != 0:\n                        gpu_src_code_d = self.code_discriminator( gpu_src_code )\n                        gpu_src_code_d_ones  = tf.ones_like (gpu_src_code_d)\n                        gpu_src_code_d_zeros = tf.zeros_like(gpu_src_code_d)\n                        gpu_dst_code_d = self.code_discriminator( gpu_dst_code )\n                        gpu_dst_code_d_ones = tf.ones_like(gpu_dst_code_d)\n\n                        gpu_G_loss += self.options['true_face_power']*DLoss(gpu_src_code_d_ones, gpu_src_code_d)\n\n                        gpu_D_code_loss = (DLoss(gpu_dst_code_d_ones , gpu_dst_code_d) + \\\n                                           DLoss(gpu_src_code_d_zeros, gpu_src_code_d) ) * 0.5\n\n                        gpu_D_code_loss_gvs += [ nn.gradients (gpu_D_code_loss, self.code_discriminator.get_weights() ) ]\n\n                    if gan_power != 0:\n                        gpu_pred_src_src_d, \\\n                        gpu_pred_src_src_d2           = self.D_src(gpu_pred_src_src_masked_opt)\n\n                        gpu_pred_src_src_d_ones  = tf.ones_like (gpu_pred_src_src_d)\n                        gpu_pred_src_src_d_zeros = tf.zeros_like(gpu_pred_src_src_d)\n\n                        gpu_pred_src_src_d2_ones  = tf.ones_like (gpu_pred_src_src_d2)\n                        gpu_pred_src_src_d2_zeros = tf.zeros_like(gpu_pred_src_src_d2)\n\n                        gpu_target_src_d, \\\n                        gpu_target_src_d2            = self.D_src(gpu_target_src_masked_opt)\n\n                        gpu_target_src_d_ones    = tf.ones_like(gpu_target_src_d)\n                        gpu_target_src_d2_ones    = tf.ones_like(gpu_target_src_d2)\n\n                        gpu_D_src_dst_loss = (DLoss(gpu_target_src_d_ones      , gpu_target_src_d) + \\\n                                              DLoss(gpu_pred_src_src_d_zeros   , gpu_pred_src_src_d) ) * 0.5 + \\\n                                             (DLoss(gpu_target_src_d2_ones      , gpu_target_src_d2) + \\\n                                              DLoss(gpu_pred_src_src_d2_zeros   , gpu_pred_src_src_d2) ) * 0.5\n\n                        gpu_D_src_dst_loss_gvs += [ nn.gradients (gpu_D_src_dst_loss, self.D_src.get_weights() ) ]#+self.D_src_x2.get_weights()\n\n                        gpu_G_loss += gan_power*(DLoss(gpu_pred_src_src_d_ones, gpu_pred_src_src_d)  + \\\n                                                 DLoss(gpu_pred_src_src_d2_ones, gpu_pred_src_src_d2))\n\n                        if masked_training:\n                            # Minimal src-src-bg rec with total_variation_mse to suppress random bright dots from gan\n                            gpu_G_loss += 0.000001*nn.total_variation_mse(gpu_pred_src_src)\n                            gpu_G_loss += 0.02*tf.reduce_mean(tf.square(gpu_pred_src_src_anti_masked-gpu_target_src_anti_masked),axis=[1,2,3] )\n\n                    gpu_G_loss_gvs += [ nn.gradients ( gpu_G_loss, self.src_dst_trainable_weights )]\n\n\n\n\n            # Average losses and gradients, and create optimizer update ops\n            with tf.device(f'/CPU:0'):\n                pred_src_src  = nn.concat(gpu_pred_src_src_list, 0)\n                pred_dst_dst  = nn.concat(gpu_pred_dst_dst_list, 0)\n                pred_src_dst  = nn.concat(gpu_pred_src_dst_list, 0)\n                pred_src_srcm = nn.concat(gpu_pred_src_srcm_list, 0)\n                pred_dst_dstm = nn.concat(gpu_pred_dst_dstm_list, 0)\n                pred_src_dstm = nn.concat(gpu_pred_src_dstm_list, 0)\n\n            with tf.device (models_opt_device):\n                src_loss = tf.concat(gpu_src_losses, 0)\n                dst_loss = tf.concat(gpu_dst_losses, 0)\n                src_dst_loss_gv_op = self.src_dst_opt.get_update_op (nn.average_gv_list (gpu_G_loss_gvs))\n\n                if self.options['true_face_power'] != 0:\n                    D_loss_gv_op = self.D_code_opt.get_update_op (nn.average_gv_list(gpu_D_code_loss_gvs))\n\n                if gan_power != 0:\n                    src_D_src_dst_loss_gv_op = self.D_src_dst_opt.get_update_op (nn.average_gv_list(gpu_D_src_dst_loss_gvs) )\n\n\n            # Initializing training and view functions\n            def src_dst_train(warped_src, target_src, target_srcm, target_srcm_em,  \\\n                              warped_dst, target_dst, target_dstm, target_dstm_em, ):\n                s, d = nn.tf_sess.run ( [ src_loss, dst_loss, src_dst_loss_gv_op],\n                                            feed_dict={self.warped_src :warped_src,\n                                                       self.target_src :target_src,\n                                                       self.target_srcm:target_srcm,\n                                                       self.target_srcm_em:target_srcm_em,\n                                                       self.warped_dst :warped_dst,\n                                                       self.target_dst :target_dst,\n                                                       self.target_dstm:target_dstm,\n                                                       self.target_dstm_em:target_dstm_em,\n                                                       })[:2]\n                return s, d\n            self.src_dst_train = src_dst_train\n\n            if self.options['true_face_power'] != 0:\n                def D_train(warped_src, warped_dst):\n                    nn.tf_sess.run ([D_loss_gv_op], feed_dict={self.warped_src: warped_src, self.warped_dst: warped_dst})\n                self.D_train = D_train\n\n            if gan_power != 0:\n                def D_src_dst_train(warped_src, target_src, target_srcm, target_srcm_em,  \\\n                                    warped_dst, target_dst, target_dstm, target_dstm_em, ):\n                    nn.tf_sess.run ([src_D_src_dst_loss_gv_op], feed_dict={self.warped_src :warped_src,\n                                                                           self.target_src :target_src,\n                                                                           self.target_srcm:target_srcm,\n                                                                           self.target_srcm_em:target_srcm_em,\n                                                                           self.warped_dst :warped_dst,\n                                                                           self.target_dst :target_dst,\n                                                                           self.target_dstm:target_dstm,\n                                                                           self.target_dstm_em:target_dstm_em})\n                self.D_src_dst_train = D_src_dst_train\n\n\n            def AE_view(warped_src, warped_dst):\n                return nn.tf_sess.run ( [pred_src_src, pred_dst_dst, pred_dst_dstm, pred_src_dst, pred_src_dstm],\n                                            feed_dict={self.warped_src:warped_src,\n                                                    self.warped_dst:warped_dst})\n            self.AE_view = AE_view\n        else:\n            # Initializing merge function\n            with tf.device( nn.tf_default_device_name if len(devices) != 0 else f'/CPU:0'):\n                if 'df' in archi_type:\n                    gpu_dst_code     = self.inter(self.encoder(self.warped_dst))\n                    gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder_src(gpu_dst_code)\n                    _, gpu_pred_dst_dstm = self.decoder_dst(gpu_dst_code)\n\n                elif 'liae' in archi_type:\n                    gpu_dst_code = self.encoder (self.warped_dst)\n                    gpu_dst_inter_B_code = self.inter_B (gpu_dst_code)\n                    gpu_dst_inter_AB_code = self.inter_AB (gpu_dst_code)\n                    gpu_dst_code = tf.concat([gpu_dst_inter_B_code,gpu_dst_inter_AB_code], nn.conv2d_ch_axis)\n                    gpu_src_dst_code = tf.concat([gpu_dst_inter_AB_code,gpu_dst_inter_AB_code], nn.conv2d_ch_axis)\n\n                    gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder(gpu_src_dst_code)\n                    _, gpu_pred_dst_dstm = self.decoder(gpu_dst_code)\n\n\n            def AE_merge( warped_dst):\n                return nn.tf_sess.run ( [gpu_pred_src_dst, gpu_pred_dst_dstm, gpu_pred_src_dstm], feed_dict={self.warped_dst:warped_dst})\n\n            self.AE_merge = AE_merge\n\n        # Loading/initializing all models/optimizers weights\n        for model, filename in io.progress_bar_generator(self.model_filename_list, \"Initializing models\"):\n            if self.pretrain_just_disabled:\n                do_init = False\n                if 'df' in archi_type:\n                    if model == self.inter:\n                        do_init = True\n                elif 'liae' in archi_type:\n                    if model == self.inter_AB or model == self.inter_B:\n                        do_init = True\n            else:\n                do_init = self.is_first_run()\n                if self.is_training and gan_power != 0 and model == self.D_src:\n                    if self.gan_model_changed:\n                        do_init = True\n\n            if not do_init:\n                do_init = not model.load_weights( self.get_strpath_storage_for_file(filename) )\n\n            if do_init:\n                model.init_weights()\n\n\n        ###############\n\n        # initializing sample generators\n        if self.is_training:\n            training_data_src_path = self.training_data_src_path if not self.pretrain else self.get_pretraining_data_path()\n            training_data_dst_path = self.training_data_dst_path if not self.pretrain else self.get_pretraining_data_path()\n\n            random_ct_samples_path=training_data_dst_path if ct_mode is not None and not self.pretrain else None\n\n            cpu_count = multiprocessing.cpu_count()\n            src_generators_count = cpu_count // 2\n            dst_generators_count = cpu_count // 2\n            if ct_mode is not None:\n                src_generators_count = int(src_generators_count * 1.5)\n\n            self.set_training_data_generators ([\n                    SampleGeneratorFace(training_data_src_path, random_ct_samples_path=random_ct_samples_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                        sample_process_options=SampleProcessor.Options(scale_range=[-0.15, 0.15], random_flip=random_src_flip),\n                        output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':random_warp, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR, 'ct_mode': ct_mode,   'random_hsv_shift_amount' : random_hsv_power,                                        'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':False                      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR, 'ct_mode': ct_mode,                           'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False                      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.FULL_FACE, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False                      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.EYES_MOUTH, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                              ],\n                        uniform_yaw_distribution=self.options['uniform_yaw'] or self.pretrain,\n                        generators_count=src_generators_count ),\n\n                    SampleGeneratorFace(training_data_dst_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                        sample_process_options=SampleProcessor.Options(scale_range=[-0.15, 0.15], random_flip=random_dst_flip),\n                        output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':random_warp, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                                'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':False                      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False                      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.FULL_FACE, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False                      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.EYES_MOUTH, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                              ],\n                        uniform_yaw_distribution=self.options['uniform_yaw'] or self.pretrain,\n                        generators_count=dst_generators_count )\n                             ])\n\n            if self.pretrain_just_disabled:\n                self.update_sample_for_preview(force_new=True)\n\n    def export_dfm (self):\n        output_path=self.get_strpath_storage_for_file('model.dfm')\n\n        io.log_info(f'Dumping .dfm to {output_path}')\n\n        tf = nn.tf\n        nn.set_data_format('NCHW')\n\n        with tf.device (nn.tf_default_device_name):\n            warped_dst = tf.placeholder (nn.floatx, (None, self.resolution, self.resolution, 3), name='in_face')\n            warped_dst = tf.transpose(warped_dst, (0,3,1,2))\n\n\n            if 'df' in self.archi_type:\n                gpu_dst_code     = self.inter(self.encoder(warped_dst))\n                gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder_src(gpu_dst_code)\n                _, gpu_pred_dst_dstm = self.decoder_dst(gpu_dst_code)\n\n            elif 'liae' in self.archi_type:\n                gpu_dst_code = self.encoder (warped_dst)\n                gpu_dst_inter_B_code = self.inter_B (gpu_dst_code)\n                gpu_dst_inter_AB_code = self.inter_AB (gpu_dst_code)\n                gpu_dst_code = tf.concat([gpu_dst_inter_B_code,gpu_dst_inter_AB_code], nn.conv2d_ch_axis)\n                gpu_src_dst_code = tf.concat([gpu_dst_inter_AB_code,gpu_dst_inter_AB_code], nn.conv2d_ch_axis)\n\n                gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder(gpu_src_dst_code)\n                _, gpu_pred_dst_dstm = self.decoder(gpu_dst_code)\n\n            gpu_pred_src_dst = tf.transpose(gpu_pred_src_dst, (0,2,3,1))\n            gpu_pred_dst_dstm = tf.transpose(gpu_pred_dst_dstm, (0,2,3,1))\n            gpu_pred_src_dstm = tf.transpose(gpu_pred_src_dstm, (0,2,3,1))\n\n        tf.identity(gpu_pred_dst_dstm, name='out_face_mask')\n        tf.identity(gpu_pred_src_dst, name='out_celeb_face')\n        tf.identity(gpu_pred_src_dstm, name='out_celeb_face_mask')\n\n        output_graph_def = tf.graph_util.convert_variables_to_constants(\n            nn.tf_sess,\n            tf.get_default_graph().as_graph_def(),\n            ['out_face_mask','out_celeb_face','out_celeb_face_mask']\n        )\n\n        import tf2onnx\n        with tf.device(\"/CPU:0\"):\n            model_proto, _ = tf2onnx.convert._convert_common(\n                output_graph_def,\n                name='SAEHD',\n                input_names=['in_face:0'],\n                output_names=['out_face_mask:0','out_celeb_face:0','out_celeb_face_mask:0'],\n                opset=12,\n                output_path=output_path)\n\n    #override\n    def get_model_filename_list(self):\n        return self.model_filename_list\n\n    #override\n    def onSave(self):\n        for model, filename in io.progress_bar_generator(self.get_model_filename_list(), \"Saving\", leave=False):\n            model.save_weights ( self.get_strpath_storage_for_file(filename) )\n\n    #override\n    def should_save_preview_history(self):\n        return (not io.is_colab() and self.iter % ( 10*(max(1,self.resolution // 64)) ) == 0) or \\\n               (io.is_colab() and self.iter % 100 == 0)\n\n    #override\n    def onTrainOneIter(self):\n        if self.get_iter() == 0 and not self.pretrain and not self.pretrain_just_disabled:\n            io.log_info('You are training the model from scratch. It is strongly recommended to use a pretrained model to speed up the training and improve the quality.\\n')\n\n        ( (warped_src, target_src, target_srcm, target_srcm_em), \\\n          (warped_dst, target_dst, target_dstm, target_dstm_em) ) = self.generate_next_samples()\n\n        src_loss, dst_loss = self.src_dst_train (warped_src, target_src, target_srcm, target_srcm_em, warped_dst, target_dst, target_dstm, target_dstm_em)\n\n        if self.options['true_face_power'] != 0 and not self.pretrain:\n            self.D_train (warped_src, warped_dst)\n\n        if self.gan_power != 0:\n            self.D_src_dst_train (warped_src, target_src, target_srcm, target_srcm_em, warped_dst, target_dst, target_dstm, target_dstm_em)\n\n        return ( ('src_loss', np.mean(src_loss) ), ('dst_loss', np.mean(dst_loss) ), )\n\n    #override\n    def onGetPreview(self, samples, for_history=False):\n        ( (warped_src, target_src, target_srcm, target_srcm_em),\n          (warped_dst, target_dst, target_dstm, target_dstm_em) ) = samples\n\n        S, D, SS, DD, DDM, SD, SDM = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in ([target_src,target_dst] + self.AE_view (target_src, target_dst) ) ]\n        DDM, SDM, = [ np.repeat (x, (3,), -1) for x in [DDM, SDM] ]\n\n        target_srcm, target_dstm = [ nn.to_data_format(x,\"NHWC\", self.model_data_format) for x in ([target_srcm, target_dstm] )]\n\n        n_samples = min(4, self.get_batch_size(), 800 // self.resolution )\n\n        if self.resolution <= 256:\n            result = []\n\n            st = []\n            for i in range(n_samples):\n                ar = S[i], SS[i], D[i], DD[i], SD[i]\n                st.append ( np.concatenate ( ar, axis=1) )\n            result += [ ('SAEHD', np.concatenate (st, axis=0 )), ]\n\n\n            st_m = []\n            for i in range(n_samples):\n                SD_mask = DDM[i]*SDM[i] if self.face_type < FaceType.HEAD else SDM[i]\n\n                ar = S[i]*target_srcm[i], SS[i], D[i]*target_dstm[i], DD[i]*DDM[i], SD[i]*SD_mask\n                st_m.append ( np.concatenate ( ar, axis=1) )\n\n            result += [ ('SAEHD masked', np.concatenate (st_m, axis=0 )), ]\n        else:\n            result = []\n\n            st = []\n            for i in range(n_samples):\n                ar = S[i], SS[i]\n                st.append ( np.concatenate ( ar, axis=1) )\n            result += [ ('SAEHD src-src', np.concatenate (st, axis=0 )), ]\n\n            st = []\n            for i in range(n_samples):\n                ar = D[i], DD[i]\n                st.append ( np.concatenate ( ar, axis=1) )\n            result += [ ('SAEHD dst-dst', np.concatenate (st, axis=0 )), ]\n\n            st = []\n            for i in range(n_samples):\n                ar = D[i], SD[i]\n                st.append ( np.concatenate ( ar, axis=1) )\n            result += [ ('SAEHD pred', np.concatenate (st, axis=0 )), ]\n\n\n            st_m = []\n            for i in range(n_samples):\n                ar = S[i]*target_srcm[i], SS[i]\n                st_m.append ( np.concatenate ( ar, axis=1) )\n            result += [ ('SAEHD masked src-src', np.concatenate (st_m, axis=0 )), ]\n\n            st_m = []\n            for i in range(n_samples):\n                ar = D[i]*target_dstm[i], DD[i]*DDM[i]\n                st_m.append ( np.concatenate ( ar, axis=1) )\n            result += [ ('SAEHD masked dst-dst', np.concatenate (st_m, axis=0 )), ]\n\n            st_m = []\n            for i in range(n_samples):\n                SD_mask = DDM[i]*SDM[i] if self.face_type < FaceType.HEAD else SDM[i]\n                ar = D[i]*target_dstm[i], SD[i]*SD_mask\n                st_m.append ( np.concatenate ( ar, axis=1) )\n            result += [ ('SAEHD masked pred', np.concatenate (st_m, axis=0 )), ]\n\n        return result\n\n    def predictor_func (self, face=None):\n        face = nn.to_data_format(face[None,...], self.model_data_format, \"NHWC\")\n\n        bgr, mask_dst_dstm, mask_src_dstm = [ nn.to_data_format(x,\"NHWC\", self.model_data_format).astype(np.float32) for x in self.AE_merge (face) ]\n\n        return bgr[0], mask_src_dstm[0][...,0], mask_dst_dstm[0][...,0]\n\n    #override\n    def get_MergerConfig(self):\n        import merger\n        return self.predictor_func, (self.options['resolution'], self.options['resolution'], 3), merger.MergerConfigMasked(face_type=self.face_type, default_mode = 'overlay')\n\nModel = SAEHDModel\n", "models/Model_AMP/__init__.py": "from .Model import Model\n", "models/Model_AMP/Model.py": "import multiprocessing\nimport operator\nfrom functools import partial\n\nimport numpy as np\n\nfrom core import mathlib\nfrom core.interact import interact as io\nfrom core.leras import nn\nfrom facelib import FaceType\nfrom models import ModelBase\nfrom samplelib import *\nfrom core.cv2ex import *\n\nclass AMPModel(ModelBase):\n\n    #override\n    def on_initialize_options(self):\n        default_resolution         = self.options['resolution']         = self.load_or_def_option('resolution', 224)\n        default_face_type          = self.options['face_type']          = self.load_or_def_option('face_type', 'wf')\n        default_models_opt_on_gpu  = self.options['models_opt_on_gpu']  = self.load_or_def_option('models_opt_on_gpu', True)\n\n        default_ae_dims            = self.options['ae_dims']            = self.load_or_def_option('ae_dims', 256)\n        default_inter_dims         = self.options['inter_dims']         = self.load_or_def_option('inter_dims', 1024)\n\n        default_e_dims             = self.options['e_dims']             = self.load_or_def_option('e_dims', 64)\n        default_d_dims             = self.options['d_dims']             = self.options.get('d_dims', None)\n        default_d_mask_dims        = self.options['d_mask_dims']        = self.options.get('d_mask_dims', None)\n        default_morph_factor       = self.options['morph_factor']       = self.options.get('morph_factor', 0.5)\n        default_uniform_yaw        = self.options['uniform_yaw']        = self.load_or_def_option('uniform_yaw', False)\n        default_blur_out_mask      = self.options['blur_out_mask']      = self.load_or_def_option('blur_out_mask', False)\n        default_lr_dropout         = self.options['lr_dropout']         = self.load_or_def_option('lr_dropout', 'n')\n        default_random_warp        = self.options['random_warp']        = self.load_or_def_option('random_warp', True)\n        default_ct_mode            = self.options['ct_mode']            = self.load_or_def_option('ct_mode', 'none')\n        default_clipgrad           = self.options['clipgrad']           = self.load_or_def_option('clipgrad', False)\n\n        ask_override = self.ask_override()\n        if self.is_first_run() or ask_override:\n            self.ask_autobackup_hour()\n            self.ask_write_preview_history()\n            self.ask_target_iter()\n            self.ask_random_src_flip()\n            self.ask_random_dst_flip()\n            self.ask_batch_size(8)\n\n        if self.is_first_run():\n            resolution = io.input_int(\"Resolution\", default_resolution, add_info=\"64-640\", help_message=\"More resolution requires more VRAM and time to train. Value will be adjusted to multiple of 32 .\")\n            resolution = np.clip ( (resolution // 32) * 32, 64, 640)\n            self.options['resolution'] = resolution\n            self.options['face_type'] = io.input_str (\"Face type\", default_face_type, ['f','wf','head'], help_message=\"whole face / head\").lower()\n\n\n        default_d_dims             = self.options['d_dims']             = self.load_or_def_option('d_dims', 64)\n\n        default_d_mask_dims        = default_d_dims // 3\n        default_d_mask_dims        += default_d_mask_dims % 2\n        default_d_mask_dims        = self.options['d_mask_dims']        = self.load_or_def_option('d_mask_dims', default_d_mask_dims)\n\n        if self.is_first_run():\n            self.options['ae_dims']    = np.clip ( io.input_int(\"AutoEncoder dimensions\", default_ae_dims, add_info=\"32-1024\", help_message=\"All face information will packed to AE dims. If amount of AE dims are not enough, then for example closed eyes will not be recognized. More dims are better, but require more VRAM. You can fine-tune model size to fit your GPU.\" ), 32, 1024 )\n            self.options['inter_dims'] = np.clip ( io.input_int(\"Inter dimensions\", default_inter_dims, add_info=\"32-2048\", help_message=\"Should be equal or more than AutoEncoder dimensions. More dims are better, but require more VRAM. You can fine-tune model size to fit your GPU.\" ), 32, 2048 )\n\n            e_dims = np.clip ( io.input_int(\"Encoder dimensions\", default_e_dims, add_info=\"16-256\", help_message=\"More dims help to recognize more facial features and achieve sharper result, but require more VRAM. You can fine-tune model size to fit your GPU.\" ), 16, 256 )\n            self.options['e_dims'] = e_dims + e_dims % 2\n\n            d_dims = np.clip ( io.input_int(\"Decoder dimensions\", default_d_dims, add_info=\"16-256\", help_message=\"More dims help to recognize more facial features and achieve sharper result, but require more VRAM. You can fine-tune model size to fit your GPU.\" ), 16, 256 )\n            self.options['d_dims'] = d_dims + d_dims % 2\n\n            d_mask_dims = np.clip ( io.input_int(\"Decoder mask dimensions\", default_d_mask_dims, add_info=\"16-256\", help_message=\"Typical mask dimensions = decoder dimensions / 3. If you manually cut out obstacles from the dst mask, you can increase this parameter to achieve better quality.\" ), 16, 256 )\n            self.options['d_mask_dims'] = d_mask_dims + d_mask_dims % 2\n\n            morph_factor = np.clip ( io.input_number (\"Morph factor.\", default_morph_factor, add_info=\"0.1 .. 0.5\", help_message=\"Typical fine value is 0.5\"), 0.1, 0.5 )\n            self.options['morph_factor'] = morph_factor\n\n        if self.is_first_run() or ask_override:\n            self.options['uniform_yaw'] = io.input_bool (\"Uniform yaw distribution of samples\", default_uniform_yaw, help_message='Helps to fix blurry side faces due to small amount of them in the faceset.')\n            self.options['blur_out_mask'] = io.input_bool (\"Blur out mask\", default_blur_out_mask, help_message='Blurs nearby area outside of applied face mask of training samples. The result is the background near the face is smoothed and less noticeable on swapped face. The exact xseg mask in src and dst faceset is required.')\n            self.options['lr_dropout']  = io.input_str (f\"Use learning rate dropout\", default_lr_dropout, ['n','y','cpu'], help_message=\"When the face is trained enough, you can enable this option to get extra sharpness and reduce subpixel shake for less amount of iterations. Enabled it before `disable random warp` and before GAN. \\nn - disabled.\\ny - enabled\\ncpu - enabled on CPU. This allows not to use extra VRAM, sacrificing 20% time of iteration.\")\n\n        default_gan_power          = self.options['gan_power']          = self.load_or_def_option('gan_power', 0.0)\n        default_gan_patch_size     = self.options['gan_patch_size']     = self.load_or_def_option('gan_patch_size', self.options['resolution'] // 8)\n        default_gan_dims           = self.options['gan_dims']           = self.load_or_def_option('gan_dims', 16)\n\n        if self.is_first_run() or ask_override:\n            self.options['models_opt_on_gpu'] = io.input_bool (\"Place models and optimizer on GPU\", default_models_opt_on_gpu, help_message=\"When you train on one GPU, by default model and optimizer weights are placed on GPU to accelerate the process. You can place they on CPU to free up extra VRAM, thus set bigger dimensions.\")\n\n            self.options['random_warp'] = io.input_bool (\"Enable random warp of samples\", default_random_warp, help_message=\"Random warp is required to generalize facial expressions of both faces. When the face is trained enough, you can disable it to get extra sharpness and reduce subpixel shake for less amount of iterations.\")\n\n            self.options['gan_power'] = np.clip ( io.input_number (\"GAN power\", default_gan_power, add_info=\"0.0 .. 5.0\", help_message=\"Forces the neural network to learn small details of the face. Enable it only when the face is trained enough with random_warp(off), and don't disable. The higher the value, the higher the chances of artifacts. Typical fine value is 0.1\"), 0.0, 5.0 )\n\n            if self.options['gan_power'] != 0.0:\n                gan_patch_size = np.clip ( io.input_int(\"GAN patch size\", default_gan_patch_size, add_info=\"3-640\", help_message=\"The higher patch size, the higher the quality, the more VRAM is required. You can get sharper edges even at the lowest setting. Typical fine value is resolution / 8.\" ), 3, 640 )\n                self.options['gan_patch_size'] = gan_patch_size\n\n                gan_dims = np.clip ( io.input_int(\"GAN dimensions\", default_gan_dims, add_info=\"4-512\", help_message=\"The dimensions of the GAN network. The higher dimensions, the more VRAM is required. You can get sharper edges even at the lowest setting. Typical fine value is 16.\" ), 4, 512 )\n                self.options['gan_dims'] = gan_dims\n\n            self.options['ct_mode'] = io.input_str (f\"Color transfer for src faceset\", default_ct_mode, ['none','rct','lct','mkl','idt','sot'], help_message=\"Change color distribution of src samples close to dst samples. If src faceset is deverse enough, then lct mode is fine in most cases.\")\n            self.options['clipgrad'] = io.input_bool (\"Enable gradient clipping\", default_clipgrad, help_message=\"Gradient clipping reduces chance of model collapse, sacrificing speed of training.\")\n\n        self.gan_model_changed = (default_gan_patch_size != self.options['gan_patch_size']) or (default_gan_dims != self.options['gan_dims'])\n\n    #override\n    def on_initialize(self):\n        device_config = nn.getCurrentDeviceConfig()\n        devices = device_config.devices\n        self.model_data_format = \"NCHW\"\n        nn.initialize(data_format=self.model_data_format)\n        tf = nn.tf\n\n        input_ch=3\n        resolution  = self.resolution = self.options['resolution']\n        e_dims      = self.options['e_dims']\n        ae_dims     = self.options['ae_dims']\n        inter_dims  = self.inter_dims = self.options['inter_dims']\n        inter_res   = self.inter_res = resolution // 32\n        d_dims      = self.options['d_dims']\n        d_mask_dims = self.options['d_mask_dims']\n        face_type   = self.face_type = {'f'    : FaceType.FULL,\n                                        'wf'   : FaceType.WHOLE_FACE,\n                                        'head' : FaceType.HEAD}[ self.options['face_type'] ]\n        morph_factor = self.options['morph_factor']\n        gan_power    = self.gan_power = self.options['gan_power']\n        random_warp  = self.options['random_warp']\n\n        blur_out_mask = self.options['blur_out_mask']\n\n        ct_mode = self.options['ct_mode']\n        if ct_mode == 'none':\n            ct_mode = None\n\n        use_fp16 = False\n        if self.is_exporting:\n            use_fp16 = io.input_bool (\"Export quantized?\", False, help_message='Makes the exported model faster. If you have problems, disable this option.')\n\n        conv_dtype = tf.float16 if use_fp16 else tf.float32\n\n        class Downscale(nn.ModelBase):\n            def on_build(self, in_ch, out_ch, kernel_size=5 ):\n                self.conv1 = nn.Conv2D( in_ch, out_ch, kernel_size=kernel_size, strides=2, padding='SAME', dtype=conv_dtype)\n\n            def forward(self, x):\n                return tf.nn.leaky_relu(self.conv1(x), 0.1)\n\n        class Upscale(nn.ModelBase):\n            def on_build(self, in_ch, out_ch, kernel_size=3 ):\n                self.conv1 = nn.Conv2D(in_ch, out_ch*4, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n\n            def forward(self, x):\n                x = nn.depth_to_space(tf.nn.leaky_relu(self.conv1(x), 0.1), 2)\n                return x\n\n        class ResidualBlock(nn.ModelBase):\n            def on_build(self, ch, kernel_size=3 ):\n                self.conv1 = nn.Conv2D( ch, ch, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n                self.conv2 = nn.Conv2D( ch, ch, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n\n            def forward(self, inp):\n                x = self.conv1(inp)\n                x = tf.nn.leaky_relu(x, 0.2)\n                x = self.conv2(x)\n                x = tf.nn.leaky_relu(inp+x, 0.2)\n                return x\n\n        class Encoder(nn.ModelBase):\n            def on_build(self):\n                self.down1 = Downscale(input_ch, e_dims, kernel_size=5)\n                self.res1 = ResidualBlock(e_dims)\n                self.down2 = Downscale(e_dims, e_dims*2, kernel_size=5)\n                self.down3 = Downscale(e_dims*2, e_dims*4, kernel_size=5)\n                self.down4 = Downscale(e_dims*4, e_dims*8, kernel_size=5)\n                self.down5 = Downscale(e_dims*8, e_dims*8, kernel_size=5)\n                self.res5 = ResidualBlock(e_dims*8)\n                self.dense1 = nn.Dense( (( resolution//(2**5) )**2) * e_dims*8, ae_dims )\n\n            def forward(self, x):\n                if use_fp16:\n                    x = tf.cast(x, tf.float16)\n                x = self.down1(x)\n                x = self.res1(x)\n                x = self.down2(x)\n                x = self.down3(x)\n                x = self.down4(x)\n                x = self.down5(x)\n                x = self.res5(x)\n                if use_fp16:\n                    x = tf.cast(x, tf.float32)\n                x = nn.pixel_norm(nn.flatten(x), axes=-1)\n                x = self.dense1(x)\n                return x\n\n\n        class Inter(nn.ModelBase):\n            def on_build(self):\n                self.dense2 = nn.Dense(ae_dims, inter_res * inter_res * inter_dims)\n\n            def forward(self, inp):\n                x = inp\n                x = self.dense2(x)\n                x = nn.reshape_4D (x, inter_res, inter_res, inter_dims)\n                return x\n\n\n        class Decoder(nn.ModelBase):\n            def on_build(self ):\n                self.upscale0 = Upscale(inter_dims, d_dims*8, kernel_size=3)\n                self.upscale1 = Upscale(d_dims*8, d_dims*8, kernel_size=3)\n                self.upscale2 = Upscale(d_dims*8, d_dims*4, kernel_size=3)\n                self.upscale3 = Upscale(d_dims*4, d_dims*2, kernel_size=3)\n\n                self.res0 = ResidualBlock(d_dims*8, kernel_size=3)\n                self.res1 = ResidualBlock(d_dims*8, kernel_size=3)\n                self.res2 = ResidualBlock(d_dims*4, kernel_size=3)\n                self.res3 = ResidualBlock(d_dims*2, kernel_size=3)\n\n                self.upscalem0 = Upscale(inter_dims, d_mask_dims*8, kernel_size=3)\n                self.upscalem1 = Upscale(d_mask_dims*8, d_mask_dims*8, kernel_size=3)\n                self.upscalem2 = Upscale(d_mask_dims*8, d_mask_dims*4, kernel_size=3)\n                self.upscalem3 = Upscale(d_mask_dims*4, d_mask_dims*2, kernel_size=3)\n                self.upscalem4 = Upscale(d_mask_dims*2, d_mask_dims*1, kernel_size=3)\n                self.out_convm = nn.Conv2D( d_mask_dims*1, 1, kernel_size=1, padding='SAME', dtype=conv_dtype)\n\n                self.out_conv  = nn.Conv2D( d_dims*2, 3, kernel_size=1, padding='SAME', dtype=conv_dtype)\n                self.out_conv1 = nn.Conv2D( d_dims*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                self.out_conv2 = nn.Conv2D( d_dims*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                self.out_conv3 = nn.Conv2D( d_dims*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n\n            def forward(self, z):\n                if use_fp16:\n                    z = tf.cast(z, tf.float16)\n\n                x = self.upscale0(z)\n                x = self.res0(x)\n                x = self.upscale1(x)\n                x = self.res1(x)\n                x = self.upscale2(x)\n                x = self.res2(x)\n                x = self.upscale3(x)\n                x = self.res3(x)\n\n                x = tf.nn.sigmoid( nn.depth_to_space(tf.concat( (self.out_conv(x),\n                                                                 self.out_conv1(x),\n                                                                 self.out_conv2(x),\n                                                                 self.out_conv3(x)), nn.conv2d_ch_axis), 2) )\n                m = self.upscalem0(z)\n                m = self.upscalem1(m)\n                m = self.upscalem2(m)\n                m = self.upscalem3(m)\n                m = self.upscalem4(m)\n                m = tf.nn.sigmoid(self.out_convm(m))\n\n                if use_fp16:\n                    x = tf.cast(x, tf.float32)\n                    m = tf.cast(m, tf.float32)\n                return x, m\n\n        models_opt_on_gpu = False if len(devices) == 0 else self.options['models_opt_on_gpu']\n        models_opt_device = nn.tf_default_device_name if models_opt_on_gpu and self.is_training else '/CPU:0'\n        optimizer_vars_on_cpu = models_opt_device=='/CPU:0'\n\n        bgr_shape = self.bgr_shape = nn.get4Dshape(resolution,resolution,input_ch)\n        mask_shape = nn.get4Dshape(resolution,resolution,1)\n        self.model_filename_list = []\n\n        with tf.device ('/CPU:0'):\n            #Place holders on CPU\n            self.warped_src = tf.placeholder (nn.floatx, bgr_shape, name='warped_src')\n            self.warped_dst = tf.placeholder (nn.floatx, bgr_shape, name='warped_dst')\n\n            self.target_src = tf.placeholder (nn.floatx, bgr_shape, name='target_src')\n            self.target_dst = tf.placeholder (nn.floatx, bgr_shape, name='target_dst')\n\n            self.target_srcm    = tf.placeholder (nn.floatx, mask_shape, name='target_srcm')\n            self.target_srcm_em = tf.placeholder (nn.floatx, mask_shape, name='target_srcm_em')\n            self.target_dstm    = tf.placeholder (nn.floatx, mask_shape, name='target_dstm')\n            self.target_dstm_em = tf.placeholder (nn.floatx, mask_shape, name='target_dstm_em')\n\n            self.morph_value_t = tf.placeholder (nn.floatx, (1,), name='morph_value_t')\n\n        # Initializing model classes\n        with tf.device (models_opt_device):\n            self.encoder = Encoder(name='encoder')\n            self.inter_src = Inter(name='inter_src')\n            self.inter_dst = Inter(name='inter_dst')\n            self.decoder = Decoder(name='decoder')\n\n            self.model_filename_list += [   [self.encoder,  'encoder.npy'],\n                                            [self.inter_src, 'inter_src.npy'],\n                                            [self.inter_dst , 'inter_dst.npy'],\n                                            [self.decoder , 'decoder.npy'] ]\n\n            if self.is_training:\n                # Initialize optimizers\n                clipnorm = 1.0 if self.options['clipgrad'] else 0.0\n                if self.options['lr_dropout'] in ['y','cpu']:\n                    lr_cos = 500\n                    lr_dropout = 0.3\n                else:\n                    lr_cos = 0\n                    lr_dropout = 1.0\n                self.G_weights = self.encoder.get_weights() + self.decoder.get_weights()\n\n                self.src_dst_opt = nn.AdaBelief(lr=5e-5, lr_dropout=lr_dropout, lr_cos=lr_cos, clipnorm=clipnorm, name='src_dst_opt')\n                self.src_dst_opt.initialize_variables (self.G_weights, vars_on_cpu=optimizer_vars_on_cpu)\n                self.model_filename_list += [ (self.src_dst_opt, 'src_dst_opt.npy') ]\n\n                if gan_power != 0:\n                    self.GAN = nn.UNetPatchDiscriminator(patch_size=self.options['gan_patch_size'], in_ch=input_ch, base_ch=self.options['gan_dims'], name=\"GAN\")\n                    self.GAN_opt = nn.AdaBelief(lr=5e-5, lr_dropout=lr_dropout, lr_cos=lr_cos, clipnorm=clipnorm, name='GAN_opt')\n                    self.GAN_opt.initialize_variables ( self.GAN.get_weights(), vars_on_cpu=optimizer_vars_on_cpu)\n                    self.model_filename_list += [ [self.GAN, 'GAN.npy'],\n                                                  [self.GAN_opt, 'GAN_opt.npy'] ]\n\n        if self.is_training:\n            # Adjust batch size for multiple GPU\n            gpu_count = max(1, len(devices) )\n            bs_per_gpu = max(1, self.get_batch_size() // gpu_count)\n            self.set_batch_size( gpu_count*bs_per_gpu)\n\n            # Compute losses per GPU\n            gpu_pred_src_src_list = []\n            gpu_pred_dst_dst_list = []\n            gpu_pred_src_dst_list = []\n            gpu_pred_src_srcm_list = []\n            gpu_pred_dst_dstm_list = []\n            gpu_pred_src_dstm_list = []\n\n            gpu_src_losses = []\n            gpu_dst_losses = []\n            gpu_G_loss_gradients = []\n            gpu_GAN_loss_gradients = []\n\n            def DLossOnes(logits):\n                return tf.reduce_mean( tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.ones_like(logits), logits=logits), axis=[1,2,3])\n\n            def DLossZeros(logits):\n                return tf.reduce_mean( tf.nn.sigmoid_cross_entropy_with_logits(labels=tf.zeros_like(logits), logits=logits), axis=[1,2,3])\n\n            for gpu_id in range(gpu_count):\n                with tf.device( f'/{devices[gpu_id].tf_dev_type}:{gpu_id}' if len(devices) != 0 else f'/CPU:0' ):\n                    with tf.device(f'/CPU:0'):\n                        # slice on CPU, otherwise all batch data will be transfered to GPU first\n                        batch_slice = slice( gpu_id*bs_per_gpu, (gpu_id+1)*bs_per_gpu )\n                        gpu_warped_src      = self.warped_src [batch_slice,:,:,:]\n                        gpu_warped_dst      = self.warped_dst [batch_slice,:,:,:]\n                        gpu_target_src      = self.target_src [batch_slice,:,:,:]\n                        gpu_target_dst      = self.target_dst [batch_slice,:,:,:]\n                        gpu_target_srcm     = self.target_srcm[batch_slice,:,:,:]\n                        gpu_target_srcm_em  = self.target_srcm_em[batch_slice,:,:,:]\n                        gpu_target_dstm     = self.target_dstm[batch_slice,:,:,:]\n                        gpu_target_dstm_em  = self.target_dstm_em[batch_slice,:,:,:]\n\n                    # process model tensors\n                    gpu_src_code = self.encoder (gpu_warped_src)\n                    gpu_dst_code = self.encoder (gpu_warped_dst)\n\n                    gpu_src_inter_src_code, gpu_src_inter_dst_code = self.inter_src (gpu_src_code), self.inter_dst (gpu_src_code)\n                    gpu_dst_inter_src_code, gpu_dst_inter_dst_code = self.inter_src (gpu_dst_code), self.inter_dst (gpu_dst_code)\n\n                    inter_dims_bin = int(inter_dims*morph_factor)\n                    with tf.device(f'/CPU:0'):\n                        inter_rnd_binomial = tf.stack([tf.random.shuffle(tf.concat([tf.tile(tf.constant([1], tf.float32), ( inter_dims_bin, )),\n                                                                                    tf.tile(tf.constant([0], tf.float32), ( inter_dims-inter_dims_bin, ))], 0 )) for _ in range(bs_per_gpu)], 0)\n\n                        inter_rnd_binomial = tf.stop_gradient(inter_rnd_binomial[...,None,None])\n\n                    gpu_src_code = gpu_src_inter_src_code * inter_rnd_binomial + gpu_src_inter_dst_code * (1-inter_rnd_binomial)\n                    gpu_dst_code = gpu_dst_inter_dst_code\n\n                    inter_dims_slice = tf.cast(inter_dims*self.morph_value_t[0], tf.int32)\n                    gpu_src_dst_code = tf.concat( (tf.slice(gpu_dst_inter_src_code, [0,0,0,0],   [-1, inter_dims_slice , inter_res, inter_res]),\n                                                   tf.slice(gpu_dst_inter_dst_code, [0,inter_dims_slice,0,0], [-1,inter_dims-inter_dims_slice, inter_res,inter_res]) ), 1 )\n\n                    gpu_pred_src_src, gpu_pred_src_srcm = self.decoder(gpu_src_code)\n                    gpu_pred_dst_dst, gpu_pred_dst_dstm = self.decoder(gpu_dst_code)\n                    gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder(gpu_src_dst_code)\n\n                    gpu_pred_src_src_list.append(gpu_pred_src_src), gpu_pred_src_srcm_list.append(gpu_pred_src_srcm)\n                    gpu_pred_dst_dst_list.append(gpu_pred_dst_dst), gpu_pred_dst_dstm_list.append(gpu_pred_dst_dstm)\n                    gpu_pred_src_dst_list.append(gpu_pred_src_dst), gpu_pred_src_dstm_list.append(gpu_pred_src_dstm)\n\n                    gpu_target_srcm_anti = 1-gpu_target_srcm\n                    gpu_target_dstm_anti = 1-gpu_target_dstm\n\n                    gpu_target_srcm_gblur = nn.gaussian_blur(gpu_target_srcm, resolution // 32)\n                    gpu_target_dstm_gblur = nn.gaussian_blur(gpu_target_dstm, resolution // 32)\n\n                    gpu_target_srcm_blur = tf.clip_by_value(gpu_target_srcm_gblur, 0, 0.5) * 2\n                    gpu_target_dstm_blur = tf.clip_by_value(gpu_target_dstm_gblur, 0, 0.5) * 2\n                    gpu_target_srcm_anti_blur = 1.0-gpu_target_srcm_blur\n                    gpu_target_dstm_anti_blur = 1.0-gpu_target_dstm_blur\n\n                    if blur_out_mask:\n                        sigma = resolution / 128\n\n                        x = nn.gaussian_blur(gpu_target_src*gpu_target_srcm_anti, sigma)\n                        y = 1-nn.gaussian_blur(gpu_target_srcm, sigma)\n                        y = tf.where(tf.equal(y, 0), tf.ones_like(y), y)\n                        gpu_target_src = gpu_target_src*gpu_target_srcm + (x/y)*gpu_target_srcm_anti\n\n                        x = nn.gaussian_blur(gpu_target_dst*gpu_target_dstm_anti, sigma)\n                        y = 1-nn.gaussian_blur(gpu_target_dstm, sigma)\n                        y = tf.where(tf.equal(y, 0), tf.ones_like(y), y)\n                        gpu_target_dst = gpu_target_dst*gpu_target_dstm + (x/y)*gpu_target_dstm_anti\n\n                    gpu_target_src_masked = gpu_target_src*gpu_target_srcm_blur\n                    gpu_target_dst_masked = gpu_target_dst*gpu_target_dstm_blur\n                    gpu_target_src_anti_masked = gpu_target_src*gpu_target_srcm_anti_blur\n                    gpu_target_dst_anti_masked = gpu_target_dst*gpu_target_dstm_anti_blur\n\n                    gpu_pred_src_src_masked = gpu_pred_src_src*gpu_target_srcm_blur\n                    gpu_pred_dst_dst_masked = gpu_pred_dst_dst*gpu_target_dstm_blur\n                    gpu_pred_src_src_anti_masked = gpu_pred_src_src*gpu_target_srcm_anti_blur\n                    gpu_pred_dst_dst_anti_masked = gpu_pred_dst_dst*gpu_target_dstm_anti_blur\n\n                    # Structural loss\n                    gpu_src_loss =  tf.reduce_mean (5*nn.dssim(gpu_target_src_masked, gpu_pred_src_src_masked, max_val=1.0, filter_size=int(resolution/11.6)), axis=[1])\n                    gpu_src_loss += tf.reduce_mean (5*nn.dssim(gpu_target_src_masked, gpu_pred_src_src_masked, max_val=1.0, filter_size=int(resolution/23.2)), axis=[1])\n                    gpu_dst_loss =  tf.reduce_mean (5*nn.dssim(gpu_target_dst_masked, gpu_pred_dst_dst_masked, max_val=1.0, filter_size=int(resolution/11.6) ), axis=[1])\n                    gpu_dst_loss += tf.reduce_mean (5*nn.dssim(gpu_target_dst_masked, gpu_pred_dst_dst_masked, max_val=1.0, filter_size=int(resolution/23.2) ), axis=[1])\n\n                    # Pixel loss\n                    gpu_src_loss += tf.reduce_mean (10*tf.square(gpu_target_src_masked-gpu_pred_src_src_masked), axis=[1,2,3])\n                    gpu_dst_loss += tf.reduce_mean (10*tf.square(gpu_target_dst_masked-gpu_pred_dst_dst_masked), axis=[1,2,3])\n\n                    # Eyes+mouth prio loss\n                    gpu_src_loss += tf.reduce_mean (300*tf.abs (gpu_target_src*gpu_target_srcm_em-gpu_pred_src_src*gpu_target_srcm_em), axis=[1,2,3])\n                    gpu_dst_loss += tf.reduce_mean (300*tf.abs (gpu_target_dst*gpu_target_dstm_em-gpu_pred_dst_dst*gpu_target_dstm_em), axis=[1,2,3])\n\n                    # Mask loss\n                    gpu_src_loss += tf.reduce_mean ( 10*tf.square( gpu_target_srcm - gpu_pred_src_srcm ),axis=[1,2,3] )\n                    gpu_dst_loss += tf.reduce_mean ( 10*tf.square( gpu_target_dstm - gpu_pred_dst_dstm ),axis=[1,2,3] )\n\n                    gpu_src_losses += [gpu_src_loss]\n                    gpu_dst_losses += [gpu_dst_loss]\n                    gpu_G_loss = gpu_src_loss + gpu_dst_loss\n                    # dst-dst background weak loss\n                    gpu_G_loss += tf.reduce_mean(0.1*tf.square(gpu_pred_dst_dst_anti_masked-gpu_target_dst_anti_masked),axis=[1,2,3] )\n                    gpu_G_loss += 0.000001*nn.total_variation_mse(gpu_pred_dst_dst_anti_masked)\n\n\n                    if gan_power != 0:\n                        gpu_pred_src_src_d, gpu_pred_src_src_d2 = self.GAN(gpu_pred_src_src_masked)\n                        gpu_pred_dst_dst_d, gpu_pred_dst_dst_d2 = self.GAN(gpu_pred_dst_dst_masked)\n                        gpu_target_src_d, gpu_target_src_d2 = self.GAN(gpu_target_src_masked)\n                        gpu_target_dst_d, gpu_target_dst_d2 = self.GAN(gpu_target_dst_masked)\n\n                        gpu_GAN_loss = (DLossOnes (gpu_target_src_d)   + DLossOnes (gpu_target_src_d2) + \\\n                                        DLossZeros(gpu_pred_src_src_d) + DLossZeros(gpu_pred_src_src_d2) + \\\n                                        DLossOnes (gpu_target_dst_d)   + DLossOnes (gpu_target_dst_d2) + \\\n                                        DLossZeros(gpu_pred_dst_dst_d) + DLossZeros(gpu_pred_dst_dst_d2)\n                                        ) * (1.0 / 8)\n\n                        gpu_GAN_loss_gradients += [ nn.gradients (gpu_GAN_loss, self.GAN.get_weights() ) ]\n\n                        gpu_G_loss += (DLossOnes(gpu_pred_src_src_d) + DLossOnes(gpu_pred_src_src_d2) + \\\n                                       DLossOnes(gpu_pred_dst_dst_d) + DLossOnes(gpu_pred_dst_dst_d2)\n                                      ) * gan_power\n\n                        # Minimal src-src-bg rec with total_variation_mse to suppress random bright dots from gan\n                        gpu_G_loss += 0.000001*nn.total_variation_mse(gpu_pred_src_src)\n                        gpu_G_loss += 0.02*tf.reduce_mean(tf.square(gpu_pred_src_src_anti_masked-gpu_target_src_anti_masked),axis=[1,2,3] )\n\n                    gpu_G_loss_gradients += [ nn.gradients ( gpu_G_loss, self.G_weights ) ]\n\n            # Average losses and gradients, and create optimizer update ops\n            with tf.device(f'/CPU:0'):\n                pred_src_src  = nn.concat(gpu_pred_src_src_list, 0)\n                pred_dst_dst  = nn.concat(gpu_pred_dst_dst_list, 0)\n                pred_src_dst  = nn.concat(gpu_pred_src_dst_list, 0)\n                pred_src_srcm = nn.concat(gpu_pred_src_srcm_list, 0)\n                pred_dst_dstm = nn.concat(gpu_pred_dst_dstm_list, 0)\n                pred_src_dstm = nn.concat(gpu_pred_src_dstm_list, 0)\n\n            with tf.device (models_opt_device):\n                src_loss = tf.concat(gpu_src_losses, 0)\n                dst_loss = tf.concat(gpu_dst_losses, 0)\n                train_op = self.src_dst_opt.get_update_op (nn.average_gv_list (gpu_G_loss_gradients))\n\n                if gan_power != 0:\n                    GAN_train_op = self.GAN_opt.get_update_op (nn.average_gv_list(gpu_GAN_loss_gradients) )\n\n            # Initializing training and view functions\n            def train(warped_src, target_src, target_srcm, target_srcm_em,  \\\n                              warped_dst, target_dst, target_dstm, target_dstm_em, ):\n                s, d, _ = nn.tf_sess.run ([src_loss, dst_loss, train_op],\n                                            feed_dict={self.warped_src :warped_src,\n                                                       self.target_src :target_src,\n                                                       self.target_srcm:target_srcm,\n                                                       self.target_srcm_em:target_srcm_em,\n                                                       self.warped_dst :warped_dst,\n                                                       self.target_dst :target_dst,\n                                                       self.target_dstm:target_dstm,\n                                                       self.target_dstm_em:target_dstm_em,\n                                                       })\n                return s, d\n            self.train = train\n\n            if gan_power != 0:\n                def GAN_train(warped_src, target_src, target_srcm, target_srcm_em,  \\\n                              warped_dst, target_dst, target_dstm, target_dstm_em, ):\n                    nn.tf_sess.run ([GAN_train_op], feed_dict={self.warped_src :warped_src,\n                                                               self.target_src :target_src,\n                                                               self.target_srcm:target_srcm,\n                                                               self.target_srcm_em:target_srcm_em,\n                                                               self.warped_dst :warped_dst,\n                                                               self.target_dst :target_dst,\n                                                               self.target_dstm:target_dstm,\n                                                               self.target_dstm_em:target_dstm_em})\n                self.GAN_train = GAN_train\n\n            def AE_view(warped_src, warped_dst, morph_value):\n                return nn.tf_sess.run ( [pred_src_src, pred_dst_dst, pred_dst_dstm, pred_src_dst, pred_src_dstm],\n                                            feed_dict={self.warped_src:warped_src, self.warped_dst:warped_dst, self.morph_value_t:[morph_value] })\n\n            self.AE_view = AE_view\n        else:\n            #Initializing merge function\n            with tf.device( nn.tf_default_device_name if len(devices) != 0 else f'/CPU:0'):\n                gpu_dst_code = self.encoder (self.warped_dst)\n                gpu_dst_inter_src_code = self.inter_src (gpu_dst_code)\n                gpu_dst_inter_dst_code = self.inter_dst (gpu_dst_code)\n\n                inter_dims_slice = tf.cast(inter_dims*self.morph_value_t[0], tf.int32)\n                gpu_src_dst_code =  tf.concat( ( tf.slice(gpu_dst_inter_src_code, [0,0,0,0],   [-1, inter_dims_slice , inter_res, inter_res]),\n                                                 tf.slice(gpu_dst_inter_dst_code, [0,inter_dims_slice,0,0], [-1,inter_dims-inter_dims_slice, inter_res,inter_res]) ), 1 )\n\n                gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder(gpu_src_dst_code)\n                _, gpu_pred_dst_dstm = self.decoder(gpu_dst_inter_dst_code)\n\n            def AE_merge(warped_dst, morph_value):\n                return nn.tf_sess.run ( [gpu_pred_src_dst, gpu_pred_dst_dstm, gpu_pred_src_dstm], feed_dict={self.warped_dst:warped_dst, self.morph_value_t:[morph_value] })\n\n            self.AE_merge = AE_merge\n\n        # Loading/initializing all models/optimizers weights\n        for model, filename in io.progress_bar_generator(self.model_filename_list, \"Initializing models\"):\n            do_init = self.is_first_run()\n            if self.is_training and gan_power != 0 and model == self.GAN:\n                if self.gan_model_changed:\n                    do_init = True\n            if not do_init:\n                do_init = not model.load_weights( self.get_strpath_storage_for_file(filename) )\n            if do_init:\n                model.init_weights()\n        ###############\n\n        # initializing sample generators\n        if self.is_training:\n            training_data_src_path = self.training_data_src_path #if not self.pretrain else self.get_pretraining_data_path()\n            training_data_dst_path = self.training_data_dst_path #if not self.pretrain else self.get_pretraining_data_path()\n\n            random_ct_samples_path=training_data_dst_path if ct_mode is not None else None #and not self.pretrain\n\n            cpu_count = multiprocessing.cpu_count()\n            src_generators_count = cpu_count // 2\n            dst_generators_count = cpu_count // 2\n            if ct_mode is not None:\n                src_generators_count = int(src_generators_count * 1.5)\n\n\n\n            self.set_training_data_generators ([\n                    SampleGeneratorFace(training_data_src_path, random_ct_samples_path=random_ct_samples_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                        sample_process_options=SampleProcessor.Options(scale_range=[-0.15, 0.15], random_flip=self.random_src_flip),\n                        output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':random_warp, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR, 'ct_mode': ct_mode,                                         'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':False      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR, 'ct_mode': ct_mode,                                         'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.FULL_FACE,  'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.EYES_MOUTH, 'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                              ],\n                        uniform_yaw_distribution=self.options['uniform_yaw'],# or self.pretrain,\n                        generators_count=src_generators_count ),\n\n                    SampleGeneratorFace(training_data_dst_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                        sample_process_options=SampleProcessor.Options(scale_range=[-0.15, 0.15], random_flip=self.random_dst_flip),\n                        output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':random_warp, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                             'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':False      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                             'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.FULL_FACE,  'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False      , 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.EYES_MOUTH, 'face_type':face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                              ],\n                        uniform_yaw_distribution=self.options['uniform_yaw'],# or self.pretrain,\n                        generators_count=dst_generators_count )\n                             ])\n\n    def export_dfm (self):\n        output_path=self.get_strpath_storage_for_file('model.dfm')\n\n        io.log_info(f'Dumping .dfm to {output_path}')\n\n        tf = nn.tf\n        with tf.device (nn.tf_default_device_name):\n            warped_dst = tf.placeholder (nn.floatx, (None, self.resolution, self.resolution, 3), name='in_face')\n            warped_dst = tf.transpose(warped_dst, (0,3,1,2))\n            morph_value = tf.placeholder (nn.floatx, (1,), name='morph_value')\n\n            gpu_dst_code = self.encoder (warped_dst)\n            gpu_dst_inter_src_code = self.inter_src ( gpu_dst_code)\n            gpu_dst_inter_dst_code = self.inter_dst ( gpu_dst_code)\n\n            inter_dims_slice = tf.cast(self.inter_dims*morph_value[0], tf.int32)\n            gpu_src_dst_code =  tf.concat( (tf.slice(gpu_dst_inter_src_code, [0,0,0,0],   [-1, inter_dims_slice , self.inter_res, self.inter_res]),\n                                            tf.slice(gpu_dst_inter_dst_code, [0,inter_dims_slice,0,0], [-1,self.inter_dims-inter_dims_slice, self.inter_res,self.inter_res]) ), 1 )\n\n            gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder(gpu_src_dst_code)\n            _, gpu_pred_dst_dstm = self.decoder(gpu_dst_inter_dst_code)\n\n            gpu_pred_src_dst = tf.transpose(gpu_pred_src_dst, (0,2,3,1))\n            gpu_pred_dst_dstm = tf.transpose(gpu_pred_dst_dstm, (0,2,3,1))\n            gpu_pred_src_dstm = tf.transpose(gpu_pred_src_dstm, (0,2,3,1))\n\n        tf.identity(gpu_pred_dst_dstm, name='out_face_mask')\n        tf.identity(gpu_pred_src_dst, name='out_celeb_face')\n        tf.identity(gpu_pred_src_dstm, name='out_celeb_face_mask')\n\n        output_graph_def = tf.graph_util.convert_variables_to_constants(\n            nn.tf_sess,\n            tf.get_default_graph().as_graph_def(),\n            ['out_face_mask','out_celeb_face','out_celeb_face_mask']\n        )\n\n        import tf2onnx\n        with tf.device(\"/CPU:0\"):\n            model_proto, _ = tf2onnx.convert._convert_common(\n                output_graph_def,\n                name='AMP',\n                input_names=['in_face:0','morph_value:0'],\n                output_names=['out_face_mask:0','out_celeb_face:0','out_celeb_face_mask:0'],\n                opset=12,\n                output_path=output_path)\n\n    #override\n    def get_model_filename_list(self):\n        return self.model_filename_list\n\n    #override\n    def onSave(self):\n        for model, filename in io.progress_bar_generator(self.get_model_filename_list(), \"Saving\", leave=False):\n            model.save_weights ( self.get_strpath_storage_for_file(filename) )\n\n    #override\n    def should_save_preview_history(self):\n        return (not io.is_colab() and self.iter % ( 10*(max(1,self.resolution // 64)) ) == 0) or \\\n               (io.is_colab() and self.iter % 100 == 0)\n\n    #override\n    def onTrainOneIter(self):\n        bs = self.get_batch_size()\n\n        ( (warped_src, target_src, target_srcm, target_srcm_em), \\\n          (warped_dst, target_dst, target_dstm, target_dstm_em) ) = self.generate_next_samples()\n\n        src_loss, dst_loss = self.train (warped_src, target_src, target_srcm, target_srcm_em, warped_dst, target_dst, target_dstm, target_dstm_em)\n\n        if self.gan_power != 0:\n            self.GAN_train (warped_src, target_src, target_srcm, target_srcm_em, warped_dst, target_dst, target_dstm, target_dstm_em)\n\n        return ( ('src_loss', np.mean(src_loss) ), ('dst_loss', np.mean(dst_loss) ), )\n\n    #override\n    def onGetPreview(self, samples, for_history=False):\n        ( (warped_src, target_src, target_srcm, target_srcm_em),\n          (warped_dst, target_dst, target_dstm, target_dstm_em) ) = samples\n\n        S, D, SS, DD, DDM_000, _, _ = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in ([target_src,target_dst] + self.AE_view (target_src, target_dst, 0.0)  ) ]\n\n        _, _, DDM_025, SD_025, SDM_025 = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in self.AE_view (target_src, target_dst, 0.25) ]\n        _, _, DDM_050, SD_050, SDM_050 = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in self.AE_view (target_src, target_dst, 0.50) ]\n        _, _, DDM_065, SD_065, SDM_065 = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in self.AE_view (target_src, target_dst, 0.65) ]\n        _, _, DDM_075, SD_075, SDM_075 = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in self.AE_view (target_src, target_dst, 0.75) ]\n        _, _, DDM_100, SD_100, SDM_100 = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in self.AE_view (target_src, target_dst, 1.00) ]\n\n        (DDM_000,\n         DDM_025, SDM_025,\n         DDM_050, SDM_050,\n         DDM_065, SDM_065,\n         DDM_075, SDM_075,\n         DDM_100, SDM_100) = [ np.repeat (x, (3,), -1) for x in (DDM_000,\n                                                                 DDM_025, SDM_025,\n                                                                 DDM_050, SDM_050,\n                                                                 DDM_065, SDM_065,\n                                                                 DDM_075, SDM_075,\n                                                                 DDM_100, SDM_100) ]\n\n        target_srcm, target_dstm = [ nn.to_data_format(x,\"NHWC\", self.model_data_format) for x in ([target_srcm, target_dstm] )]\n\n        n_samples = min(4, self.get_batch_size(), 800 // self.resolution )\n\n        result = []\n\n        i = np.random.randint(n_samples) if not for_history else 0\n\n        st =  [ np.concatenate ((S[i],  D[i],  DD[i]*DDM_000[i]), axis=1) ]\n        st += [ np.concatenate ((SS[i], DD[i], SD_100[i] ), axis=1) ]\n\n        result += [ ('AMP morph 1.0', np.concatenate (st, axis=0 )), ]\n\n        st =  [ np.concatenate ((DD[i], SD_025[i],  SD_050[i]), axis=1) ]\n        st += [ np.concatenate ((SD_065[i], SD_075[i], SD_100[i]), axis=1) ]\n        result += [ ('AMP morph list', np.concatenate (st, axis=0 )), ]\n\n        st =  [ np.concatenate ((DD[i], SD_025[i]*DDM_025[i]*SDM_025[i],  SD_050[i]*DDM_050[i]*SDM_050[i]), axis=1) ]\n        st += [ np.concatenate ((SD_065[i]*DDM_065[i]*SDM_065[i], SD_075[i]*DDM_075[i]*SDM_075[i], SD_100[i]*DDM_100[i]*SDM_100[i]), axis=1) ]\n        result += [ ('AMP morph list masked', np.concatenate (st, axis=0 )), ]\n\n        return result\n\n    def predictor_func (self, face, morph_value):\n        face = nn.to_data_format(face[None,...], self.model_data_format, \"NHWC\")\n\n        bgr, mask_dst_dstm, mask_src_dstm = [ nn.to_data_format(x,\"NHWC\", self.model_data_format).astype(np.float32) for x in self.AE_merge (face, morph_value) ]\n\n        return bgr[0], mask_src_dstm[0][...,0], mask_dst_dstm[0][...,0]\n\n    #override\n    def get_MergerConfig(self):\n        morph_factor = np.clip ( io.input_number (\"Morph factor\", 1.0, add_info=\"0.0 .. 1.0\"), 0.0, 1.0 )\n\n        def predictor_morph(face):\n            return self.predictor_func(face, morph_factor)\n\n\n        import merger\n        return predictor_morph, (self.options['resolution'], self.options['resolution'], 3), merger.MergerConfigMasked(face_type=self.face_type, default_mode = 'overlay')\n\nModel = AMPModel\n", "models/Model_Quick96/__init__.py": "from .Model import Model\n", "models/Model_Quick96/Model.py": "import multiprocessing\nfrom functools import partial\n\nimport numpy as np\n\nfrom core import mathlib\nfrom core.interact import interact as io\nfrom core.leras import nn\nfrom facelib import FaceType\nfrom models import ModelBase\nfrom samplelib import *\n\nclass QModel(ModelBase):\n    #override\n    def on_initialize(self):\n        device_config = nn.getCurrentDeviceConfig()\n        devices = device_config.devices\n        self.model_data_format = \"NCHW\" if len(devices) != 0 and not self.is_debug() else \"NHWC\"\n        nn.initialize(data_format=self.model_data_format)\n        tf = nn.tf\n\n        resolution = self.resolution = 96\n        self.face_type = FaceType.FULL\n        ae_dims = 128\n        e_dims = 64\n        d_dims = 64\n        d_mask_dims = 16\n        self.pretrain = False\n        self.pretrain_just_disabled = False\n\n        masked_training = True\n\n        models_opt_on_gpu = len(devices) >= 1 and all([dev.total_mem_gb >= 4 for dev in devices])\n        models_opt_device = nn.tf_default_device_name if models_opt_on_gpu and self.is_training else '/CPU:0'\n        optimizer_vars_on_cpu = models_opt_device=='/CPU:0'\n\n        input_ch = 3\n        bgr_shape = nn.get4Dshape(resolution,resolution,input_ch)\n        mask_shape = nn.get4Dshape(resolution,resolution,1)\n\n        self.model_filename_list = []\n        \n        model_archi = nn.DeepFakeArchi(resolution, opts='ud')\n\n        with tf.device ('/CPU:0'):\n            #Place holders on CPU\n            self.warped_src = tf.placeholder (nn.floatx, bgr_shape)\n            self.warped_dst = tf.placeholder (nn.floatx, bgr_shape)\n\n            self.target_src = tf.placeholder (nn.floatx, bgr_shape)\n            self.target_dst = tf.placeholder (nn.floatx, bgr_shape)\n\n            self.target_srcm = tf.placeholder (nn.floatx, mask_shape)\n            self.target_dstm = tf.placeholder (nn.floatx, mask_shape)\n\n        # Initializing model classes\n        with tf.device (models_opt_device):\n            self.encoder = model_archi.Encoder(in_ch=input_ch, e_ch=e_dims, name='encoder')\n            encoder_out_ch = self.encoder.get_out_ch()*self.encoder.get_out_res(resolution)**2\n\n            self.inter = model_archi.Inter (in_ch=encoder_out_ch, ae_ch=ae_dims, ae_out_ch=ae_dims, name='inter')\n            inter_out_ch = self.inter.get_out_ch()\n\n            self.decoder_src = model_archi.Decoder(in_ch=inter_out_ch, d_ch=d_dims, d_mask_ch=d_mask_dims, name='decoder_src')\n            self.decoder_dst = model_archi.Decoder(in_ch=inter_out_ch, d_ch=d_dims, d_mask_ch=d_mask_dims, name='decoder_dst')\n\n            self.model_filename_list += [ [self.encoder,     'encoder.npy'    ],\n                                          [self.inter,       'inter.npy'      ],\n                                          [self.decoder_src, 'decoder_src.npy'],\n                                          [self.decoder_dst, 'decoder_dst.npy']  ]\n\n            if self.is_training:\n                self.src_dst_trainable_weights = self.encoder.get_weights() + self.inter.get_weights() + self.decoder_src.get_weights() + self.decoder_dst.get_weights()\n\n                # Initialize optimizers\n                self.src_dst_opt = nn.RMSprop(lr=2e-4, lr_dropout=0.3, name='src_dst_opt')\n                self.src_dst_opt.initialize_variables(self.src_dst_trainable_weights, vars_on_cpu=optimizer_vars_on_cpu )\n                self.model_filename_list += [ (self.src_dst_opt, 'src_dst_opt.npy') ]\n\n        if self.is_training:\n            # Adjust batch size for multiple GPU\n            gpu_count = max(1, len(devices) )\n            bs_per_gpu = max(1, 4 // gpu_count)\n            self.set_batch_size( gpu_count*bs_per_gpu)\n\n            # Compute losses per GPU\n            gpu_pred_src_src_list = []\n            gpu_pred_dst_dst_list = []\n            gpu_pred_src_dst_list = []\n            gpu_pred_src_srcm_list = []\n            gpu_pred_dst_dstm_list = []\n            gpu_pred_src_dstm_list = []\n\n            gpu_src_losses = []\n            gpu_dst_losses = []\n            gpu_src_dst_loss_gvs = []\n            \n            for gpu_id in range(gpu_count):\n                with tf.device( f'/{devices[gpu_id].tf_dev_type}:{gpu_id}' if len(devices) != 0 else f'/CPU:0' ):\n                    batch_slice = slice( gpu_id*bs_per_gpu, (gpu_id+1)*bs_per_gpu )\n                    with tf.device(f'/CPU:0'):\n                        # slice on CPU, otherwise all batch data will be transfered to GPU first\n                        gpu_warped_src   = self.warped_src [batch_slice,:,:,:]\n                        gpu_warped_dst   = self.warped_dst [batch_slice,:,:,:]\n                        gpu_target_src   = self.target_src [batch_slice,:,:,:]\n                        gpu_target_dst   = self.target_dst [batch_slice,:,:,:]\n                        gpu_target_srcm  = self.target_srcm[batch_slice,:,:,:]\n                        gpu_target_dstm  = self.target_dstm[batch_slice,:,:,:]\n\n                    # process model tensors\n                    gpu_src_code     = self.inter(self.encoder(gpu_warped_src))\n                    gpu_dst_code     = self.inter(self.encoder(gpu_warped_dst))\n                    gpu_pred_src_src, gpu_pred_src_srcm = self.decoder_src(gpu_src_code)\n                    gpu_pred_dst_dst, gpu_pred_dst_dstm = self.decoder_dst(gpu_dst_code)\n                    gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder_src(gpu_dst_code)\n\n                    gpu_pred_src_src_list.append(gpu_pred_src_src)\n                    gpu_pred_dst_dst_list.append(gpu_pred_dst_dst)\n                    gpu_pred_src_dst_list.append(gpu_pred_src_dst)\n\n                    gpu_pred_src_srcm_list.append(gpu_pred_src_srcm)\n                    gpu_pred_dst_dstm_list.append(gpu_pred_dst_dstm)\n                    gpu_pred_src_dstm_list.append(gpu_pred_src_dstm)\n\n                    gpu_target_srcm_blur = nn.gaussian_blur(gpu_target_srcm,  max(1, resolution // 32) )\n                    gpu_target_dstm_blur = nn.gaussian_blur(gpu_target_dstm,  max(1, resolution // 32) )\n\n                    gpu_target_dst_masked      = gpu_target_dst*gpu_target_dstm_blur\n                    gpu_target_dst_anti_masked = gpu_target_dst*(1.0 - gpu_target_dstm_blur)\n\n                    gpu_target_src_masked_opt  = gpu_target_src*gpu_target_srcm_blur if masked_training else gpu_target_src\n                    gpu_target_dst_masked_opt = gpu_target_dst_masked if masked_training else gpu_target_dst\n\n                    gpu_pred_src_src_masked_opt = gpu_pred_src_src*gpu_target_srcm_blur if masked_training else gpu_pred_src_src\n                    gpu_pred_dst_dst_masked_opt = gpu_pred_dst_dst*gpu_target_dstm_blur if masked_training else gpu_pred_dst_dst\n\n                    gpu_psd_target_dst_masked = gpu_pred_src_dst*gpu_target_dstm_blur\n                    gpu_psd_target_dst_anti_masked = gpu_pred_src_dst*(1.0 - gpu_target_dstm_blur)\n\n                    gpu_src_loss =  tf.reduce_mean ( 10*nn.dssim(gpu_target_src_masked_opt, gpu_pred_src_src_masked_opt, max_val=1.0, filter_size=int(resolution/11.6)), axis=[1])\n                    gpu_src_loss += tf.reduce_mean ( 10*tf.square ( gpu_target_src_masked_opt - gpu_pred_src_src_masked_opt ), axis=[1,2,3])\n                    gpu_src_loss += tf.reduce_mean ( 10*tf.square( gpu_target_srcm - gpu_pred_src_srcm ),axis=[1,2,3] )\n\n                    gpu_dst_loss  = tf.reduce_mean ( 10*nn.dssim(gpu_target_dst_masked_opt, gpu_pred_dst_dst_masked_opt, max_val=1.0, filter_size=int(resolution/11.6) ), axis=[1])\n                    gpu_dst_loss += tf.reduce_mean ( 10*tf.square(  gpu_target_dst_masked_opt- gpu_pred_dst_dst_masked_opt ), axis=[1,2,3])\n                    gpu_dst_loss += tf.reduce_mean ( 10*tf.square( gpu_target_dstm - gpu_pred_dst_dstm ),axis=[1,2,3] )\n\n                    gpu_src_losses += [gpu_src_loss]\n                    gpu_dst_losses += [gpu_dst_loss]\n\n                    gpu_G_loss = gpu_src_loss + gpu_dst_loss\n                    gpu_src_dst_loss_gvs += [ nn.gradients ( gpu_G_loss, self.src_dst_trainable_weights ) ]\n\n\n            # Average losses and gradients, and create optimizer update ops\n            with tf.device (models_opt_device):\n                pred_src_src  = nn.concat(gpu_pred_src_src_list, 0)\n                pred_dst_dst  = nn.concat(gpu_pred_dst_dst_list, 0)\n                pred_src_dst  = nn.concat(gpu_pred_src_dst_list, 0)\n                pred_src_srcm = nn.concat(gpu_pred_src_srcm_list, 0)\n                pred_dst_dstm = nn.concat(gpu_pred_dst_dstm_list, 0)\n                pred_src_dstm = nn.concat(gpu_pred_src_dstm_list, 0)\n\n                src_loss = nn.average_tensor_list(gpu_src_losses)\n                dst_loss = nn.average_tensor_list(gpu_dst_losses)\n                src_dst_loss_gv = nn.average_gv_list (gpu_src_dst_loss_gvs)\n                src_dst_loss_gv_op = self.src_dst_opt.get_update_op (src_dst_loss_gv)\n\n            # Initializing training and view functions\n            def src_dst_train(warped_src, target_src, target_srcm, \\\n                              warped_dst, target_dst, target_dstm):\n                s, d, _ = nn.tf_sess.run ( [ src_loss, dst_loss, src_dst_loss_gv_op],\n                                            feed_dict={self.warped_src :warped_src,\n                                                       self.target_src :target_src,\n                                                       self.target_srcm:target_srcm,\n                                                       self.warped_dst :warped_dst,\n                                                       self.target_dst :target_dst,\n                                                       self.target_dstm:target_dstm,\n                                                       })\n                s = np.mean(s)\n                d = np.mean(d)\n                return s, d\n            self.src_dst_train = src_dst_train\n\n            def AE_view(warped_src, warped_dst):\n                return nn.tf_sess.run ( [pred_src_src, pred_dst_dst, pred_dst_dstm, pred_src_dst, pred_src_dstm],\n                                            feed_dict={self.warped_src:warped_src,\n                                                    self.warped_dst:warped_dst})\n\n            self.AE_view = AE_view\n        else:\n            # Initializing merge function\n            with tf.device( nn.tf_default_device_name if len(devices) != 0 else f'/CPU:0'):\n                gpu_dst_code     = self.inter(self.encoder(self.warped_dst))\n                gpu_pred_src_dst, gpu_pred_src_dstm = self.decoder_src(gpu_dst_code)\n                _, gpu_pred_dst_dstm = self.decoder_dst(gpu_dst_code)\n\n            def AE_merge( warped_dst):\n\n                return nn.tf_sess.run ( [gpu_pred_src_dst, gpu_pred_dst_dstm, gpu_pred_src_dstm], feed_dict={self.warped_dst:warped_dst})\n\n            self.AE_merge = AE_merge\n\n        # Loading/initializing all models/optimizers weights\n        for model, filename in io.progress_bar_generator(self.model_filename_list, \"Initializing models\"):\n            if self.pretrain_just_disabled:\n                do_init = False\n                if model == self.inter:\n                    do_init = True\n            else:\n                do_init = self.is_first_run()\n\n            if not do_init:\n                do_init = not model.load_weights( self.get_strpath_storage_for_file(filename) )\n\n            if do_init and self.pretrained_model_path is not None:\n                pretrained_filepath = self.pretrained_model_path / filename\n                if pretrained_filepath.exists():\n                    do_init = not model.load_weights(pretrained_filepath)\n\n            if do_init:\n                model.init_weights()\n\n        # initializing sample generators\n        if self.is_training:\n            training_data_src_path = self.training_data_src_path if not self.pretrain else self.get_pretraining_data_path()\n            training_data_dst_path = self.training_data_dst_path if not self.pretrain else self.get_pretraining_data_path()\n\n            cpu_count = min(multiprocessing.cpu_count(), 8)\n            src_generators_count = cpu_count // 2\n            dst_generators_count = cpu_count // 2\n\n            self.set_training_data_generators ([\n                    SampleGeneratorFace(training_data_src_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                        sample_process_options=SampleProcessor.Options(random_flip=True if self.pretrain else False),\n                        output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':True,  'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                           'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':False, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                           'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.FULL_FACE, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution}\n                                              ],\n                        generators_count=src_generators_count ),\n\n                    SampleGeneratorFace(training_data_dst_path, debug=self.is_debug(), batch_size=self.get_batch_size(),\n                        sample_process_options=SampleProcessor.Options(random_flip=True if self.pretrain else False),\n                        output_sample_types = [ {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':True,  'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                           'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_IMAGE,'warp':False, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.BGR,                                                           'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution},\n                                                {'sample_type': SampleProcessor.SampleType.FACE_MASK, 'warp':False, 'transform':True, 'channel_type' : SampleProcessor.ChannelType.G,   'face_mask_type' : SampleProcessor.FaceMaskType.FULL_FACE, 'face_type':self.face_type, 'data_format':nn.data_format, 'resolution': resolution}\n                                               ],\n                        generators_count=dst_generators_count )\n                             ])\n\n            self.last_samples = None\n\n    #override\n    def get_model_filename_list(self):\n        return self.model_filename_list\n\n    #override\n    def onSave(self):\n        for model, filename in io.progress_bar_generator(self.get_model_filename_list(), \"Saving\", leave=False):\n            model.save_weights ( self.get_strpath_storage_for_file(filename) )\n\n    #override\n    def onTrainOneIter(self):\n\n        if self.get_iter() % 3 == 0 and self.last_samples is not None:\n            ( (warped_src, target_src, target_srcm), \\\n              (warped_dst, target_dst, target_dstm) ) = self.last_samples\n            warped_src = target_src\n            warped_dst = target_dst\n        else:\n            samples = self.last_samples = self.generate_next_samples()\n            ( (warped_src, target_src, target_srcm), \\\n              (warped_dst, target_dst, target_dstm) ) = samples\n\n        src_loss, dst_loss = self.src_dst_train (warped_src, target_src, target_srcm,\n                                                 warped_dst, target_dst, target_dstm)\n\n        return ( ('src_loss', src_loss), ('dst_loss', dst_loss), )\n\n    #override\n    def onGetPreview(self, samples, for_history=False):\n        ( (warped_src, target_src, target_srcm),\n          (warped_dst, target_dst, target_dstm) ) = samples\n\n        S, D, SS, DD, DDM, SD, SDM = [ np.clip( nn.to_data_format(x,\"NHWC\", self.model_data_format), 0.0, 1.0) for x in ([target_src,target_dst] + self.AE_view (target_src, target_dst) ) ]\n        DDM, SDM, = [ np.repeat (x, (3,), -1) for x in [DDM, SDM] ]\n\n        target_srcm, target_dstm = [ nn.to_data_format(x,\"NHWC\", self.model_data_format) for x in ([target_srcm, target_dstm] )]\n\n        n_samples = min(4, self.get_batch_size() )\n        result = []\n        st = []\n        for i in range(n_samples):\n            ar = S[i], SS[i], D[i], DD[i], SD[i]\n            st.append ( np.concatenate ( ar, axis=1) )\n\n        result += [ ('Quick96', np.concatenate (st, axis=0 )), ]\n\n        st_m = []\n        for i in range(n_samples):\n            ar = S[i]*target_srcm[i], SS[i], D[i]*target_dstm[i], DD[i]*DDM[i], SD[i]*(DDM[i]*SDM[i])\n            st_m.append ( np.concatenate ( ar, axis=1) )\n\n        result += [ ('Quick96 masked', np.concatenate (st_m, axis=0 )), ]\n\n        return result\n\n    def predictor_func (self, face=None):\n        face = nn.to_data_format(face[None,...], self.model_data_format, \"NHWC\")\n\n        bgr, mask_dst_dstm, mask_src_dstm = [ nn.to_data_format(x, \"NHWC\", self.model_data_format).astype(np.float32) for x in self.AE_merge (face) ]\n        return bgr[0], mask_src_dstm[0][...,0], mask_dst_dstm[0][...,0]\n\n    #override\n    def get_MergerConfig(self):\n        import merger\n        return self.predictor_func, (self.resolution, self.resolution, 3), merger.MergerConfigMasked(face_type=self.face_type,\n                                     default_mode = 'overlay',\n                                    )\n\nModel = QModel\n", "localization/localization.py": "\ufeffimport sys\nimport locale\n\nsystem_locale = locale.getdefaultlocale()[0]\n# system_locale may be nil\nsystem_language = system_locale[0:2] if system_locale is not None else \"en\"\nif system_language not in ['en','ru','zh']:\n    system_language = 'en'\n\nwindows_font_name_map = {\n    'en' : 'cour',\n    'ru' : 'cour',\n    'zh' : 'simsun_01'\n}\n\ndarwin_font_name_map = {\n    'en' : 'cour',\n    'ru' : 'cour',\n    'zh' : 'Apple LiSung Light'\n}\n\nlinux_font_name_map = {\n    'en' : 'cour',\n    'ru' : 'cour',\n    'zh' : 'cour'\n}\n\ndef get_default_ttf_font_name():\n    platform = sys.platform\n    if platform[0:3] == 'win': return windows_font_name_map.get(system_language, 'cour')\n    elif platform == 'darwin': return darwin_font_name_map.get(system_language, 'cour')\n    else: return linux_font_name_map.get(system_language, 'cour')\n\nSID_HOT_KEY = 1\n\nif system_language == 'en':\n    StringsDB = {'S_HOT_KEY' : 'hot key'}\nelif system_language == 'ru':\n    StringsDB = {'S_HOT_KEY' : '\u0433\u043e\u0440\u044f\u0447\u0430\u044f \u043a\u043b\u0430\u0432\u0438\u0448\u0430'}    \nelif system_language == 'zh':\n    StringsDB = {'S_HOT_KEY' : '\u70ed\u952e'}   \n    ", "localization/__init__.py": "from .localization import StringsDB, system_language, get_default_ttf_font_name\n\n", "DFLIMG/DFLJPG.py": "import pickle\nimport struct\nimport traceback\n\nimport cv2\nimport numpy as np\n\nfrom core import imagelib\nfrom core.cv2ex import *\nfrom core.imagelib import SegIEPolys\nfrom core.interact import interact as io\nfrom core.structex import *\nfrom facelib import FaceType\n\n\nclass DFLJPG(object):\n    def __init__(self, filename):\n        self.filename = filename\n        self.data = b\"\"\n        self.length = 0\n        self.chunks = []\n        self.dfl_dict = None\n        self.shape = None\n        self.img = None\n\n    @staticmethod\n    def load_raw(filename, loader_func=None):\n        try:\n            if loader_func is not None:\n                data = loader_func(filename)\n            else:\n                with open(filename, \"rb\") as f:\n                    data = f.read()\n        except:\n            raise FileNotFoundError(filename)\n\n        try:\n            inst = DFLJPG(filename)\n            inst.data = data\n            inst.length = len(data)\n            inst_length = inst.length\n            chunks = []\n            data_counter = 0\n            while data_counter < inst_length:\n                chunk_m_l, chunk_m_h = struct.unpack (\"BB\", data[data_counter:data_counter+2])\n                data_counter += 2\n\n                if chunk_m_l != 0xFF:\n                    raise ValueError(f\"No Valid JPG info in {filename}\")\n\n                chunk_name = None\n                chunk_size = None\n                chunk_data = None\n                chunk_ex_data = None\n                is_unk_chunk = False\n\n                if chunk_m_h & 0xF0 == 0xD0:\n                    n = chunk_m_h & 0x0F\n\n                    if n >= 0 and n <= 7:\n                        chunk_name = \"RST%d\" % (n)\n                        chunk_size = 0\n                    elif n == 0x8:\n                        chunk_name = \"SOI\"\n                        chunk_size = 0\n                        if len(chunks) != 0:\n                            raise Exception(\"\")\n                    elif n == 0x9:\n                        chunk_name = \"EOI\"\n                        chunk_size = 0\n                    elif n == 0xA:\n                        chunk_name = \"SOS\"\n                    elif n == 0xB:\n                        chunk_name = \"DQT\"\n                    elif n == 0xD:\n                        chunk_name = \"DRI\"\n                        chunk_size = 2\n                    else:\n                        is_unk_chunk = True\n                elif chunk_m_h & 0xF0 == 0xC0:\n                    n = chunk_m_h & 0x0F\n                    if n == 0:\n                        chunk_name = \"SOF0\"\n                    elif n == 2:\n                        chunk_name = \"SOF2\"\n                    elif n == 4:\n                        chunk_name = \"DHT\"\n                    else:\n                        is_unk_chunk = True\n                elif chunk_m_h & 0xF0 == 0xE0:\n                    n = chunk_m_h & 0x0F\n                    chunk_name = \"APP%d\" % (n)\n                else:\n                    is_unk_chunk = True\n\n                #if is_unk_chunk:\n                #    #raise ValueError(f\"Unknown chunk {chunk_m_h} in {filename}\")\n                #    io.log_info(f\"Unknown chunk {chunk_m_h} in {filename}\")\n\n                if chunk_size == None: #variable size\n                    chunk_size, = struct.unpack (\">H\", data[data_counter:data_counter+2])\n                    chunk_size -= 2\n                    data_counter += 2\n\n                if chunk_size > 0:\n                    chunk_data = data[data_counter:data_counter+chunk_size]\n                    data_counter += chunk_size\n\n                if chunk_name == \"SOS\":\n                    c = data_counter\n                    while c < inst_length and (data[c] != 0xFF or data[c+1] != 0xD9):\n                        c += 1\n\n                    chunk_ex_data = data[data_counter:c]\n                    data_counter = c\n\n                chunks.append ({'name' : chunk_name,\n                                'm_h' : chunk_m_h,\n                                'data' : chunk_data,\n                                'ex_data' : chunk_ex_data,\n                                })\n            inst.chunks = chunks\n\n            return inst\n        except Exception as e:\n            raise Exception (f\"Corrupted JPG file {filename} {e}\")\n\n    @staticmethod\n    def load(filename, loader_func=None):\n        try:\n            inst = DFLJPG.load_raw (filename, loader_func=loader_func)\n            inst.dfl_dict = {}\n\n            for chunk in inst.chunks:\n                if chunk['name'] == 'APP0':\n                    d, c = chunk['data'], 0\n                    c, id, _ = struct_unpack (d, c, \"=4sB\")\n\n                    if id == b\"JFIF\":\n                        c, ver_major, ver_minor, units, Xdensity, Ydensity, Xthumbnail, Ythumbnail = struct_unpack (d, c, \"=BBBHHBB\")\n                    else:\n                        raise Exception(\"Unknown jpeg ID: %s\" % (id) )\n                elif chunk['name'] == 'SOF0' or chunk['name'] == 'SOF2':\n                    d, c = chunk['data'], 0\n                    c, precision, height, width = struct_unpack (d, c, \">BHH\")\n                    inst.shape = (height, width, 3)\n\n                elif chunk['name'] == 'APP15':\n                    if type(chunk['data']) == bytes:\n                        inst.dfl_dict = pickle.loads(chunk['data'])\n\n            return inst\n        except Exception as e:\n            io.log_err (f'Exception occured while DFLJPG.load : {traceback.format_exc()}')\n            return None\n\n    def has_data(self):\n        return len(self.dfl_dict.keys()) != 0\n\n    def save(self):\n        try:\n            with open(self.filename, \"wb\") as f:\n                f.write ( self.dump() )\n        except:\n            raise Exception( f'cannot save {self.filename}' )\n\n    def dump(self):\n        data = b\"\"\n\n        dict_data = self.dfl_dict\n\n        # Remove None keys\n        for key in list(dict_data.keys()):\n            if dict_data[key] is None:\n                dict_data.pop(key)\n\n        for chunk in self.chunks:\n            if chunk['name'] == 'APP15':\n                self.chunks.remove(chunk)\n                break\n\n        last_app_chunk = 0\n        for i, chunk in enumerate (self.chunks):\n            if chunk['m_h'] & 0xF0 == 0xE0:\n                last_app_chunk = i\n\n        dflchunk = {'name' : 'APP15',\n                    'm_h' : 0xEF,\n                    'data' : pickle.dumps(dict_data),\n                    'ex_data' : None,\n                    }\n        self.chunks.insert (last_app_chunk+1, dflchunk)\n\n\n        for chunk in self.chunks:\n            data += struct.pack (\"BB\", 0xFF, chunk['m_h'] )\n            chunk_data = chunk['data']\n            if chunk_data is not None:\n                data += struct.pack (\">H\", len(chunk_data)+2 )\n                data += chunk_data\n\n            chunk_ex_data = chunk['ex_data']\n            if chunk_ex_data is not None:\n                data += chunk_ex_data\n\n        return data\n\n    def get_img(self):\n        if self.img is None:\n            self.img = cv2_imread(self.filename)\n        return self.img\n\n    def get_shape(self):\n        if self.shape is None:\n            img = self.get_img()\n            if img is not None:\n                self.shape = img.shape\n        return self.shape\n\n    def get_height(self):\n        for chunk in self.chunks:\n            if type(chunk) == IHDR:\n                return chunk.height\n        return 0\n\n    def get_dict(self):\n        return self.dfl_dict\n\n    def set_dict (self, dict_data=None):\n        self.dfl_dict = dict_data\n\n    def get_face_type(self):            return self.dfl_dict.get('face_type', FaceType.toString (FaceType.FULL) )\n    def set_face_type(self, face_type): self.dfl_dict['face_type'] = face_type\n\n    def get_landmarks(self):            return np.array ( self.dfl_dict['landmarks'] )\n    def set_landmarks(self, landmarks): self.dfl_dict['landmarks'] = landmarks\n\n    def get_eyebrows_expand_mod(self):                      return self.dfl_dict.get ('eyebrows_expand_mod', 1.0)\n    def set_eyebrows_expand_mod(self, eyebrows_expand_mod): self.dfl_dict['eyebrows_expand_mod'] = eyebrows_expand_mod\n\n    def get_source_filename(self):                  return self.dfl_dict.get ('source_filename', None)\n    def set_source_filename(self, source_filename): self.dfl_dict['source_filename'] = source_filename\n\n    def get_source_rect(self):              return self.dfl_dict.get ('source_rect', None)\n    def set_source_rect(self, source_rect): self.dfl_dict['source_rect'] = source_rect\n\n    def get_source_landmarks(self):                     return np.array ( self.dfl_dict.get('source_landmarks', None) )\n    def set_source_landmarks(self, source_landmarks):   self.dfl_dict['source_landmarks'] = source_landmarks\n\n    def get_image_to_face_mat(self):\n        mat = self.dfl_dict.get ('image_to_face_mat', None)\n        if mat is not None:\n            return np.array (mat)\n        return None\n    def set_image_to_face_mat(self, image_to_face_mat):   self.dfl_dict['image_to_face_mat'] = image_to_face_mat\n\n    def has_seg_ie_polys(self):\n        return self.dfl_dict.get('seg_ie_polys',None) is not None\n\n    def get_seg_ie_polys(self):\n        d = self.dfl_dict.get('seg_ie_polys',None)\n        if d is not None:\n            d = SegIEPolys.load(d)\n        else:\n            d = SegIEPolys()\n\n        return d\n\n    def set_seg_ie_polys(self, seg_ie_polys):\n        if seg_ie_polys is not None:\n            if not isinstance(seg_ie_polys, SegIEPolys):\n                raise ValueError('seg_ie_polys should be instance of SegIEPolys')\n\n            if seg_ie_polys.has_polys():\n                seg_ie_polys = seg_ie_polys.dump()\n            else:\n                seg_ie_polys = None\n\n        self.dfl_dict['seg_ie_polys'] = seg_ie_polys\n\n    def has_xseg_mask(self):\n        return self.dfl_dict.get('xseg_mask',None) is not None\n\n    def get_xseg_mask_compressed(self):\n        mask_buf = self.dfl_dict.get('xseg_mask',None)\n        if mask_buf is None:\n            return None\n\n        return mask_buf\n        \n    def get_xseg_mask(self):\n        mask_buf = self.dfl_dict.get('xseg_mask',None)\n        if mask_buf is None:\n            return None\n\n        img = cv2.imdecode(mask_buf, cv2.IMREAD_UNCHANGED)\n        if len(img.shape) == 2:\n            img = img[...,None]\n\n        return img.astype(np.float32) / 255.0\n\n\n    def set_xseg_mask(self, mask_a):\n        if mask_a is None:\n            self.dfl_dict['xseg_mask'] = None\n            return\n\n        mask_a = imagelib.normalize_channels(mask_a, 1)\n        img_data = np.clip( mask_a*255, 0, 255 ).astype(np.uint8)\n\n        data_max_len = 50000\n\n        ret, buf = cv2.imencode('.png', img_data)\n\n        if not ret or len(buf) > data_max_len:\n            for jpeg_quality in range(100,-1,-1):\n                ret, buf = cv2.imencode( '.jpg', img_data, [int(cv2.IMWRITE_JPEG_QUALITY), jpeg_quality] )\n                if ret and len(buf) <= data_max_len:\n                    break\n\n        if not ret:\n            raise Exception(\"set_xseg_mask: unable to generate image data for set_xseg_mask\")\n\n        self.dfl_dict['xseg_mask'] = buf\n", "DFLIMG/DFLIMG.py": "from pathlib import Path\n\nfrom .DFLJPG import DFLJPG\n\nclass DFLIMG():\n\n    @staticmethod\n    def load(filepath, loader_func=None):\n        if filepath.suffix == '.jpg':\n            return DFLJPG.load ( str(filepath), loader_func=loader_func )\n        else:\n            return None\n", "DFLIMG/__init__.py": "from .DFLIMG import DFLIMG\nfrom .DFLJPG import DFLJPG", "mainscripts/Sorter.py": "\ufeffimport math\nimport multiprocessing\nimport operator\nimport os\nimport sys\nimport tempfile\nfrom functools import cmp_to_key\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\nfrom numpy import linalg as npla\n\nfrom core import imagelib, mathlib, pathex\nfrom core.cv2ex import *\nfrom core.imagelib import estimate_sharpness\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor\nfrom core.leras import nn\nfrom DFLIMG import *\nfrom facelib import LandmarksProcessor\n\n\nclass BlurEstimatorSubprocessor(Subprocessor):\n    class Cli(Subprocessor.Cli):\n        def on_initialize(self, client_dict):\n            self.estimate_motion_blur = client_dict['estimate_motion_blur']\n        \n        #override\n        def process_data(self, data):\n            filepath = Path( data[0] )\n            dflimg = DFLIMG.load (filepath)\n\n            if dflimg is None or not dflimg.has_data():\n                self.log_err (f\"{filepath.name} is not a dfl image file\")\n                return [ str(filepath), 0 ]\n            else:\n                image = cv2_imread( str(filepath) )\n                \n                face_mask = LandmarksProcessor.get_image_hull_mask (image.shape, dflimg.get_landmarks())\n                image = (image*face_mask).astype(np.uint8)\n                \n                \n                if self.estimate_motion_blur:\n                    value = cv2.Laplacian(image, cv2.CV_64F, ksize=11).var()    \n                else:\n                    value = estimate_sharpness(image)\n                \n                return [ str(filepath), value ]\n\n\n        #override\n        def get_data_name (self, data):\n            #return string identificator of your data\n            return data[0]\n\n    #override\n    def __init__(self, input_data, estimate_motion_blur=False ):\n        self.input_data = input_data\n        self.estimate_motion_blur = estimate_motion_blur\n        self.img_list = []\n        self.trash_img_list = []\n        super().__init__('BlurEstimator', BlurEstimatorSubprocessor.Cli, 60)\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"\", len (self.input_data))\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close ()\n\n    #override\n    def process_info_generator(self):\n        cpu_count = multiprocessing.cpu_count()\n        io.log_info(f'Running on {cpu_count} CPUs')\n\n        for i in range(cpu_count):\n            yield 'CPU%d' % (i), {}, {'estimate_motion_blur':self.estimate_motion_blur}\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.input_data) > 0:\n            return self.input_data.pop(0)\n\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.input_data.insert(0, data)\n\n    #override\n    def on_result (self, host_dict, data, result):\n        if result[1] == 0:\n            self.trash_img_list.append ( result )\n        else:\n            self.img_list.append ( result )\n\n        io.progress_bar_inc(1)\n\n    #override\n    def get_result(self):\n        return self.img_list, self.trash_img_list\n\n\ndef sort_by_blur(input_path):\n    io.log_info (\"Sorting by blur...\")\n\n    img_list = [ (filename,[]) for filename in pathex.get_image_paths(input_path) ]\n    img_list, trash_img_list = BlurEstimatorSubprocessor (img_list).run()\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n\n    return img_list, trash_img_list\n    \ndef sort_by_motion_blur(input_path):\n    io.log_info (\"Sorting by motion blur...\")\n\n    img_list = [ (filename,[]) for filename in pathex.get_image_paths(input_path) ]\n    img_list, trash_img_list = BlurEstimatorSubprocessor (img_list, estimate_motion_blur=True).run()\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n\n    return img_list, trash_img_list\n    \ndef sort_by_face_yaw(input_path):\n    io.log_info (\"Sorting by face yaw...\")\n    img_list = []\n    trash_img_list = []\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\"):\n        filepath = Path(filepath)\n\n        dflimg = DFLIMG.load (filepath)\n\n        if dflimg is None or not dflimg.has_data():\n            io.log_err (f\"{filepath.name} is not a dfl image file\")\n            trash_img_list.append ( [str(filepath)] )\n            continue\n\n        pitch, yaw, roll = LandmarksProcessor.estimate_pitch_yaw_roll ( dflimg.get_landmarks(), size=dflimg.get_shape()[1] )\n\n        img_list.append( [str(filepath), yaw ] )\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n\n    return img_list, trash_img_list\n\ndef sort_by_face_pitch(input_path):\n    io.log_info (\"Sorting by face pitch...\")\n    img_list = []\n    trash_img_list = []\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\"):\n        filepath = Path(filepath)\n\n        dflimg = DFLIMG.load (filepath)\n\n        if dflimg is None or not dflimg.has_data():\n            io.log_err (f\"{filepath.name} is not a dfl image file\")\n            trash_img_list.append ( [str(filepath)] )\n            continue\n\n        pitch, yaw, roll = LandmarksProcessor.estimate_pitch_yaw_roll ( dflimg.get_landmarks(), size=dflimg.get_shape()[1] )\n\n        img_list.append( [str(filepath), pitch ] )\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n\n    return img_list, trash_img_list\n\ndef sort_by_face_source_rect_size(input_path):\n    io.log_info (\"Sorting by face rect size...\")\n    img_list = []\n    trash_img_list = []\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\"):\n        filepath = Path(filepath)\n\n        dflimg = DFLIMG.load (filepath)\n\n        if dflimg is None or not dflimg.has_data():\n            io.log_err (f\"{filepath.name} is not a dfl image file\")\n            trash_img_list.append ( [str(filepath)] )\n            continue\n\n        source_rect = dflimg.get_source_rect()\n        rect_area = mathlib.polygon_area(np.array(source_rect[[0,2,2,0]]).astype(np.float32), np.array(source_rect[[1,1,3,3]]).astype(np.float32))\n\n        img_list.append( [str(filepath), rect_area ] )\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n\n    return img_list, trash_img_list\n\n\n\nclass HistSsimSubprocessor(Subprocessor):\n    class Cli(Subprocessor.Cli):\n        #override\n        def process_data(self, data):\n            img_list = []\n            for x in data:\n                img = cv2_imread(x)\n                img_list.append ([x, cv2.calcHist([img], [0], None, [256], [0, 256]),\n                                     cv2.calcHist([img], [1], None, [256], [0, 256]),\n                                     cv2.calcHist([img], [2], None, [256], [0, 256])\n                                 ])\n\n            img_list_len = len(img_list)\n            for i in range(img_list_len-1):\n                min_score = float(\"inf\")\n                j_min_score = i+1\n                for j in range(i+1,len(img_list)):\n                    score = cv2.compareHist(img_list[i][1], img_list[j][1], cv2.HISTCMP_BHATTACHARYYA) + \\\n                            cv2.compareHist(img_list[i][2], img_list[j][2], cv2.HISTCMP_BHATTACHARYYA) + \\\n                            cv2.compareHist(img_list[i][3], img_list[j][3], cv2.HISTCMP_BHATTACHARYYA)\n                    if score < min_score:\n                        min_score = score\n                        j_min_score = j\n                img_list[i+1], img_list[j_min_score] = img_list[j_min_score], img_list[i+1]\n\n                self.progress_bar_inc(1)\n\n            return img_list\n\n        #override\n        def get_data_name (self, data):\n            return \"Bunch of images\"\n\n    #override\n    def __init__(self, img_list ):\n        self.img_list = img_list\n        self.img_list_len = len(img_list)\n\n        slice_count = 20000\n        sliced_count = self.img_list_len // slice_count\n\n        if sliced_count > 12:\n            sliced_count = 11.9\n            slice_count = int(self.img_list_len / sliced_count)\n            sliced_count = self.img_list_len // slice_count\n\n        self.img_chunks_list = [ self.img_list[i*slice_count : (i+1)*slice_count] for i in range(sliced_count) ] + \\\n                               [ self.img_list[sliced_count*slice_count:] ]\n\n        self.result = []\n        super().__init__('HistSsim', HistSsimSubprocessor.Cli, 0)\n\n    #override\n    def process_info_generator(self):\n        cpu_count = len(self.img_chunks_list)\n        io.log_info(f'Running on {cpu_count} threads')\n        for i in range(cpu_count):\n            yield 'CPU%d' % (i), {'i':i}, {}\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"Sorting\", len(self.img_list))\n        io.progress_bar_inc(len(self.img_chunks_list))\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.img_chunks_list) > 0:\n            return self.img_chunks_list.pop(0)\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        raise Exception(\"Fail to process data. Decrease number of images and try again.\")\n\n    #override\n    def on_result (self, host_dict, data, result):\n        self.result += result\n        return 0\n\n    #override\n    def get_result(self):\n        return self.result\n\ndef sort_by_hist(input_path):\n    io.log_info (\"Sorting by histogram similarity...\")\n    img_list = HistSsimSubprocessor(pathex.get_image_paths(input_path)).run()\n    return img_list, []\n\nclass HistDissimSubprocessor(Subprocessor):\n    class Cli(Subprocessor.Cli):\n        #override\n        def on_initialize(self, client_dict):\n            self.img_list = client_dict['img_list']\n            self.img_list_len = len(self.img_list)\n\n        #override\n        def process_data(self, data):\n            i = data[0]\n            score_total = 0\n            for j in range( 0, self.img_list_len):\n                if i == j:\n                    continue\n                score_total += cv2.compareHist(self.img_list[i][1], self.img_list[j][1], cv2.HISTCMP_BHATTACHARYYA)\n\n            return score_total\n\n        #override\n        def get_data_name (self, data):\n            #return string identificator of your data\n            return self.img_list[data[0]][0]\n\n    #override\n    def __init__(self, img_list ):\n        self.img_list = img_list\n        self.img_list_range = [i for i in range(0, len(img_list) )]\n        self.result = []\n        super().__init__('HistDissim', HistDissimSubprocessor.Cli, 60)\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"Sorting\", len (self.img_list) )\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def process_info_generator(self):\n        cpu_count = min(multiprocessing.cpu_count(), 8)\n        io.log_info(f'Running on {cpu_count} CPUs')\n        for i in range(cpu_count):\n            yield 'CPU%d' % (i), {}, {'img_list' : self.img_list}\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.img_list_range) > 0:\n            return [self.img_list_range.pop(0)]\n\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.img_list_range.insert(0, data[0])\n\n    #override\n    def on_result (self, host_dict, data, result):\n        self.img_list[data[0]][2] = result\n        io.progress_bar_inc(1)\n\n    #override\n    def get_result(self):\n        return self.img_list\n\ndef sort_by_hist_dissim(input_path):\n    io.log_info (\"Sorting by histogram dissimilarity...\")\n\n    img_list = []\n    trash_img_list = []\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\"):\n        filepath = Path(filepath)\n\n        dflimg = DFLIMG.load (filepath)\n\n        image = cv2_imread(str(filepath))\n\n        if dflimg is not None and dflimg.has_data():\n            face_mask = LandmarksProcessor.get_image_hull_mask (image.shape, dflimg.get_landmarks())\n            image = (image*face_mask).astype(np.uint8)\n\n        img_list.append ([str(filepath), cv2.calcHist([cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)], [0], None, [256], [0, 256]), 0 ])\n\n    img_list = HistDissimSubprocessor(img_list).run()\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(2), reverse=True)\n\n    return img_list, trash_img_list\n\ndef sort_by_brightness(input_path):\n    io.log_info (\"Sorting by brightness...\")\n    img_list = [ [x, np.mean ( cv2.cvtColor(cv2_imread(x), cv2.COLOR_BGR2HSV)[...,2].flatten()  )] for x in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\") ]\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n    return img_list, []\n\ndef sort_by_hue(input_path):\n    io.log_info (\"Sorting by hue...\")\n    img_list = [ [x, np.mean ( cv2.cvtColor(cv2_imread(x), cv2.COLOR_BGR2HSV)[...,0].flatten()  )] for x in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\") ]\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n    return img_list, []\n\ndef sort_by_black(input_path):\n    io.log_info (\"Sorting by amount of black pixels...\")\n\n    img_list = []\n    for x in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\"):\n        img = cv2_imread(x)\n        img_list.append ([x, img[(img == 0)].size ])\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1), reverse=False)\n\n    return img_list, []\n\ndef sort_by_origname(input_path):\n    io.log_info (\"Sort by original filename...\")\n\n    img_list = []\n    trash_img_list = []\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Loading\"):\n        filepath = Path(filepath)\n\n        dflimg = DFLIMG.load (filepath)\n\n        if dflimg is None or not dflimg.has_data():\n            io.log_err (f\"{filepath.name} is not a dfl image file\")\n            trash_img_list.append( [str(filepath)] )\n            continue\n\n        img_list.append( [str(filepath), dflimg.get_source_filename()] )\n\n    io.log_info (\"Sorting...\")\n    img_list = sorted(img_list, key=operator.itemgetter(1))\n    return img_list, trash_img_list\n\ndef sort_by_oneface_in_image(input_path):\n    io.log_info (\"Sort by one face in images...\")\n    image_paths = pathex.get_image_paths(input_path)\n    a = np.array ([ ( int(x[0]), int(x[1]) ) \\\n                      for x in [ Path(filepath).stem.split('_') for filepath in image_paths ] if len(x) == 2\n                  ])\n    if len(a) > 0:\n        idxs = np.ndarray.flatten ( np.argwhere ( a[:,1] != 0 ) )\n        idxs = np.unique ( a[idxs][:,0] )\n        idxs = np.ndarray.flatten ( np.argwhere ( np.array([ x[0] in idxs for x in a ]) == True ) )\n        if len(idxs) > 0:\n            io.log_info (\"Found %d images.\" % (len(idxs)) )\n            img_list = [ (path,) for i,path in enumerate(image_paths) if i not in idxs ]\n            trash_img_list = [ (image_paths[x],) for x in idxs ]\n            return img_list, trash_img_list\n\n    io.log_info (\"Nothing found. Possible recover original filenames first.\")\n    return [], []\n\nclass FinalLoaderSubprocessor(Subprocessor):\n    class Cli(Subprocessor.Cli):\n        #override\n        def on_initialize(self, client_dict):\n            self.faster = client_dict['faster']\n\n        #override\n        def process_data(self, data):\n            filepath = Path(data[0])\n\n            try:\n                dflimg = DFLIMG.load (filepath)\n\n                if dflimg is None or not dflimg.has_data():\n                    self.log_err (f\"{filepath.name} is not a dfl image file\")\n                    return [ 1, [str(filepath)] ]\n\n                bgr = cv2_imread(str(filepath))\n                if bgr is None:\n                    raise Exception (\"Unable to load %s\" % (filepath.name) )\n\n                gray = cv2.cvtColor(bgr, cv2.COLOR_BGR2GRAY)\n                if self.faster:\n                    source_rect = dflimg.get_source_rect()\n                    sharpness = mathlib.polygon_area(np.array(source_rect[[0,2,2,0]]).astype(np.float32), np.array(source_rect[[1,1,3,3]]).astype(np.float32))\n                else:\n                    face_mask = LandmarksProcessor.get_image_hull_mask (gray.shape, dflimg.get_landmarks())     \n                    sharpness = estimate_sharpness( (gray[...,None]*face_mask).astype(np.uint8) )\n\n                pitch, yaw, roll = LandmarksProcessor.estimate_pitch_yaw_roll ( dflimg.get_landmarks(), size=dflimg.get_shape()[1] )\n\n                hist = cv2.calcHist([gray], [0], None, [256], [0, 256])\n            except Exception as e:\n                self.log_err (e)\n                return [ 1, [str(filepath)] ]\n\n            return [ 0, [str(filepath), sharpness, hist, yaw, pitch ] ]\n\n        #override\n        def get_data_name (self, data):\n            #return string identificator of your data\n            return data[0]\n\n    #override\n    def __init__(self, img_list, faster ):\n        self.img_list = img_list\n\n        self.faster = faster\n        self.result = []\n        self.result_trash = []\n\n        super().__init__('FinalLoader', FinalLoaderSubprocessor.Cli, 60)\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"Loading\", len (self.img_list))\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def process_info_generator(self):\n        cpu_count = min(multiprocessing.cpu_count(), 8)\n        io.log_info(f'Running on {cpu_count} CPUs')\n\n        for i in range(cpu_count):\n            yield 'CPU%d' % (i), {}, {'faster': self.faster}\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.img_list) > 0:\n            return [self.img_list.pop(0)]\n\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.img_list.insert(0, data[0])\n\n    #override\n    def on_result (self, host_dict, data, result):\n        if result[0] == 0:\n            self.result.append (result[1])\n        else:\n            self.result_trash.append (result[1])\n        io.progress_bar_inc(1)\n\n    #override\n    def get_result(self):\n        return self.result, self.result_trash\n\nclass FinalHistDissimSubprocessor(Subprocessor):\n    class Cli(Subprocessor.Cli):\n        #override\n        def process_data(self, data):\n            idx, pitch_yaw_img_list = data\n\n            for p in range ( len(pitch_yaw_img_list) ):\n\n                img_list = pitch_yaw_img_list[p]\n                if img_list is not None:\n                    for i in range( len(img_list) ):\n                        score_total = 0\n                        for j in range( len(img_list) ):\n                            if i == j:\n                                continue\n                            score_total += cv2.compareHist(img_list[i][2], img_list[j][2], cv2.HISTCMP_BHATTACHARYYA)\n                        img_list[i][3] = score_total\n\n                    pitch_yaw_img_list[p] = sorted(img_list, key=operator.itemgetter(3), reverse=True)\n\n            return idx, pitch_yaw_img_list\n\n        #override\n        def get_data_name (self, data):\n            return \"Bunch of images\"\n\n    #override\n    def __init__(self, pitch_yaw_sample_list ):\n        self.pitch_yaw_sample_list = pitch_yaw_sample_list\n        self.pitch_yaw_sample_list_len = len(pitch_yaw_sample_list)\n\n        self.pitch_yaw_sample_list_idxs = [ i for i in range(self.pitch_yaw_sample_list_len) if self.pitch_yaw_sample_list[i] is not None ]\n        self.result = [ None for _ in range(self.pitch_yaw_sample_list_len) ]\n        super().__init__('FinalHistDissimSubprocessor', FinalHistDissimSubprocessor.Cli)\n\n    #override\n    def process_info_generator(self):\n        cpu_count = min(multiprocessing.cpu_count(), 8)\n        io.log_info(f'Running on {cpu_count} CPUs')\n        for i in range(cpu_count):\n            yield 'CPU%d' % (i), {}, {}\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"Sort by hist-dissim\", len(self.pitch_yaw_sample_list_idxs) )\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.pitch_yaw_sample_list_idxs) > 0:\n            idx = self.pitch_yaw_sample_list_idxs.pop(0)\n\n            return idx, self.pitch_yaw_sample_list[idx]\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.pitch_yaw_sample_list_idxs.insert(0, data[0])\n\n    #override\n    def on_result (self, host_dict, data, result):\n        idx, yaws_sample_list = data\n        self.result[idx] = yaws_sample_list\n        io.progress_bar_inc(1)\n\n    #override\n    def get_result(self):\n        return self.result\n\ndef sort_best_faster(input_path):\n    return sort_best(input_path, faster=True)\n\ndef sort_best(input_path, faster=False):\n    target_count = io.input_int (\"Target number of faces?\", 2000)\n\n    io.log_info (\"Performing sort by best faces.\")\n    if faster:\n        io.log_info(\"Using faster algorithm. Faces will be sorted by source-rect-area instead of blur.\")\n\n    img_list, trash_img_list = FinalLoaderSubprocessor( pathex.get_image_paths(input_path), faster ).run()\n    final_img_list = []\n\n    grads = 128\n    imgs_per_grad = round (target_count / grads)\n\n    #instead of math.pi / 2, using -1.2,+1.2 because actually maximum yaw for 2DFAN landmarks are -1.2+1.2\n    grads_space = np.linspace (-1.2, 1.2,grads)\n\n    yaws_sample_list = [None]*grads\n    for g in io.progress_bar_generator ( range(grads), \"Sort by yaw\"):\n        yaw = grads_space[g]\n        next_yaw = grads_space[g+1] if g < grads-1 else yaw\n\n        yaw_samples = []\n        for img in img_list:\n            s_yaw = -img[3]\n            if (g == 0          and s_yaw < next_yaw) or \\\n               (g < grads-1     and s_yaw >= yaw and s_yaw < next_yaw) or \\\n               (g == grads-1    and s_yaw >= yaw):\n                yaw_samples += [ img ]\n        if len(yaw_samples) > 0:\n            yaws_sample_list[g] = yaw_samples\n\n    total_lack = 0\n    for g in io.progress_bar_generator ( range(grads), \"\"):\n        img_list = yaws_sample_list[g]\n        img_list_len = len(img_list) if img_list is not None else 0\n\n        lack = imgs_per_grad - img_list_len\n        total_lack += max(lack, 0)\n\n    imgs_per_grad += total_lack // grads\n\n\n    sharpned_imgs_per_grad = imgs_per_grad*10\n    for g in io.progress_bar_generator ( range (grads), \"Sort by blur\"):\n        img_list = yaws_sample_list[g]\n        if img_list is None:\n            continue\n\n        img_list = sorted(img_list, key=operator.itemgetter(1), reverse=True)\n\n        if len(img_list) > sharpned_imgs_per_grad:\n            trash_img_list += img_list[sharpned_imgs_per_grad:]\n            img_list = img_list[0:sharpned_imgs_per_grad]\n\n        yaws_sample_list[g] = img_list\n\n\n    yaw_pitch_sample_list = [None]*grads\n    pitch_grads = imgs_per_grad\n\n    for g in io.progress_bar_generator ( range (grads), \"Sort by pitch\"):\n        img_list = yaws_sample_list[g]\n        if img_list is None:\n            continue\n\n        pitch_sample_list = [None]*pitch_grads\n\n        grads_space = np.linspace (-math.pi / 2,math.pi / 2, pitch_grads )\n\n        for pg in range (pitch_grads):\n\n            pitch = grads_space[pg]\n            next_pitch = grads_space[pg+1] if pg < pitch_grads-1 else pitch\n\n            pitch_samples = []\n            for img in img_list:\n                s_pitch = img[4]\n                if (pg == 0                and s_pitch < next_pitch) or \\\n                   (pg < pitch_grads-1     and s_pitch >= pitch and s_pitch < next_pitch) or \\\n                   (pg == pitch_grads-1    and s_pitch >= pitch):\n                    pitch_samples += [ img ]\n\n            if len(pitch_samples) > 0:\n                pitch_sample_list[pg] = pitch_samples\n        yaw_pitch_sample_list[g] = pitch_sample_list\n\n    yaw_pitch_sample_list = FinalHistDissimSubprocessor(yaw_pitch_sample_list).run()\n\n    for g in io.progress_bar_generator (range (grads), \"Fetching the best\"):\n        pitch_sample_list = yaw_pitch_sample_list[g]\n        if pitch_sample_list is None:\n            continue\n\n        n = imgs_per_grad\n\n        while n > 0:\n            n_prev = n\n            for pg in range(pitch_grads):\n                img_list = pitch_sample_list[pg]\n                if img_list is None:\n                    continue\n                final_img_list += [ img_list.pop(0) ]\n                if len(img_list) == 0:\n                    pitch_sample_list[pg] = None\n                n -= 1\n                if n == 0:\n                    break\n            if n_prev == n:\n                break\n\n        for pg in range(pitch_grads):\n            img_list = pitch_sample_list[pg]\n            if img_list is None:\n                continue\n            trash_img_list += img_list\n\n    return final_img_list, trash_img_list\n\n\"\"\"\ndef sort_by_vggface(input_path):\n    io.log_info (\"Sorting by face similarity using VGGFace model...\")\n\n    model = VGGFace()\n\n    final_img_list = []\n    trash_img_list = []\n\n    image_paths = pathex.get_image_paths(input_path)\n    img_list = [ (x,) for x in image_paths ]\n    img_list_len = len(img_list)\n    img_list_range = [*range(img_list_len)]\n\n    feats = [None]*img_list_len\n    for i in io.progress_bar_generator(img_list_range, \"Loading\"):\n        img = cv2_imread( img_list[i][0] ).astype(np.float32)\n        img = imagelib.normalize_channels (img, 3)\n        img = cv2.resize (img, (224,224) )\n        img = img[..., ::-1]\n        img[..., 0] -= 93.5940\n        img[..., 1] -= 104.7624\n        img[..., 2] -= 129.1863\n        feats[i] = model.predict( img[None,...] )[0]\n\n    tmp = np.zeros( (img_list_len,) )\n    float_inf = float(\"inf\")\n    for i in io.progress_bar_generator ( range(img_list_len-1), \"Sorting\" ):\n        i_feat = feats[i]\n\n        for j in img_list_range:\n            tmp[j] = npla.norm(i_feat-feats[j]) if j >= i+1 else float_inf\n\n        idx = np.argmin(tmp)\n\n        img_list[i+1], img_list[idx] = img_list[idx], img_list[i+1]\n        feats[i+1], feats[idx] = feats[idx], feats[i+1]\n\n    return img_list, trash_img_list\n\"\"\"\n\ndef sort_by_absdiff(input_path):\n    io.log_info (\"Sorting by absolute difference...\")\n\n    is_sim = io.input_bool (\"Sort by similar?\", True, help_message=\"Otherwise sort by dissimilar.\")\n\n    from core.leras import nn\n\n    device_config = nn.DeviceConfig.ask_choose_device(choose_only_one=True)\n    nn.initialize( device_config=device_config, data_format=\"NHWC\" )\n    tf = nn.tf\n\n    image_paths = pathex.get_image_paths(input_path)\n    image_paths_len = len(image_paths)\n\n    batch_size = 512\n    batch_size_remain = image_paths_len % batch_size\n\n    i_t = tf.placeholder (tf.float32, (None,None,None,None) )\n    j_t = tf.placeholder (tf.float32, (None,None,None,None) )\n\n    outputs_full = []\n    outputs_remain = []\n\n    for i in range(batch_size):\n        diff_t = tf.reduce_sum( tf.abs(i_t-j_t[i]), axis=[1,2,3] )\n        outputs_full.append(diff_t)\n        if i < batch_size_remain:\n            outputs_remain.append(diff_t)\n\n    def func_bs_full(i,j):\n        return nn.tf_sess.run (outputs_full, feed_dict={i_t:i,j_t:j})\n\n    def func_bs_remain(i,j):\n        return nn.tf_sess.run (outputs_remain, feed_dict={i_t:i,j_t:j})\n\n    import h5py\n    db_file_path = Path(tempfile.gettempdir()) / 'sort_cache.hdf5'\n    db_file = h5py.File( str(db_file_path), \"w\")\n    db = db_file.create_dataset(\"results\", (image_paths_len,image_paths_len), compression=\"gzip\")\n\n    pg_len = image_paths_len // batch_size\n    if batch_size_remain != 0:\n        pg_len += 1\n\n    pg_len = int( (  pg_len*pg_len - pg_len ) / 2 + pg_len )\n\n    io.progress_bar (\"Computing\", pg_len)\n    j=0\n    while j < image_paths_len:\n        j_images = [ cv2_imread(x) for x in image_paths[j:j+batch_size] ]\n        j_images_len = len(j_images)\n\n        func = func_bs_remain if image_paths_len-j < batch_size else func_bs_full\n\n        i=0\n        while i < image_paths_len:\n            if i >= j:\n                i_images = [ cv2_imread(x) for x in image_paths[i:i+batch_size] ]\n                i_images_len = len(i_images)\n                result = func (i_images,j_images)\n                db[j:j+j_images_len,i:i+i_images_len] = np.array(result)\n                io.progress_bar_inc(1)\n\n            i += batch_size\n        db_file.flush()\n        j += batch_size\n\n    io.progress_bar_close()\n\n    next_id = 0\n    sorted = [next_id]\n    for i in io.progress_bar_generator ( range(image_paths_len-1), \"Sorting\" ):\n        id_ar = np.concatenate ( [ db[:next_id,next_id], db[next_id,next_id:] ] )\n        id_ar = np.argsort(id_ar)\n\n\n        next_id = np.setdiff1d(id_ar, sorted, True)[ 0 if is_sim else -1]\n        sorted += [next_id]\n    db_file.close()\n    db_file_path.unlink()\n\n    img_list = [ (image_paths[x],) for x in sorted]\n    return img_list, []\n\ndef final_process(input_path, img_list, trash_img_list):\n    if len(trash_img_list) != 0:\n        parent_input_path = input_path.parent\n        trash_path = parent_input_path / (input_path.stem + '_trash')\n        trash_path.mkdir (exist_ok=True)\n\n        io.log_info (\"Trashing %d items to %s\" % ( len(trash_img_list), str(trash_path) ) )\n\n        for filename in pathex.get_image_paths(trash_path):\n            Path(filename).unlink()\n\n        for i in io.progress_bar_generator( range(len(trash_img_list)), \"Moving trash\", leave=False):\n            src = Path (trash_img_list[i][0])\n            dst = trash_path / src.name\n            try:\n                src.rename (dst)\n            except:\n                io.log_info ('fail to trashing %s' % (src.name) )\n\n        io.log_info (\"\")\n\n    if len(img_list) != 0:\n        for i in io.progress_bar_generator( [*range(len(img_list))], \"Renaming\", leave=False):\n            src = Path (img_list[i][0])\n            dst = input_path / ('%.5d_%s' % (i, src.name ))\n            try:\n                src.rename (dst)\n            except:\n                io.log_info ('fail to rename %s' % (src.name) )\n\n        for i in io.progress_bar_generator( [*range(len(img_list))], \"Renaming\"):\n            src = Path (img_list[i][0])\n            src = input_path / ('%.5d_%s' % (i, src.name))\n            dst = input_path / ('%.5d%s' % (i, src.suffix))\n            try:\n                src.rename (dst)\n            except:\n                io.log_info ('fail to rename %s' % (src.name) )\n\nsort_func_methods = {\n    'blur':        (\"blur\", sort_by_blur),\n    'motion-blur': (\"motion_blur\", sort_by_motion_blur),\n    'face-yaw':    (\"face yaw direction\", sort_by_face_yaw),\n    'face-pitch':  (\"face pitch direction\", sort_by_face_pitch),\n    'face-source-rect-size' : (\"face rect size in source image\", sort_by_face_source_rect_size),\n    'hist':        (\"histogram similarity\", sort_by_hist),\n    'hist-dissim': (\"histogram dissimilarity\", sort_by_hist_dissim),\n    'brightness':  (\"brightness\", sort_by_brightness),\n    'hue':         (\"hue\", sort_by_hue),\n    'black':       (\"amount of black pixels\", sort_by_black),\n    'origname':    (\"original filename\", sort_by_origname),\n    'oneface':     (\"one face in image\", sort_by_oneface_in_image),\n    'absdiff':     (\"absolute pixel difference\", sort_by_absdiff),\n    'final':       (\"best faces\", sort_best),\n    'final-fast':  (\"best faces faster\", sort_best_faster),\n}\n\ndef main (input_path, sort_by_method=None):\n    io.log_info (\"Running sort tool.\\r\\n\")\n\n    if sort_by_method is None:\n        io.log_info(f\"Choose sorting method:\")\n\n        key_list = list(sort_func_methods.keys())\n        for i, key in enumerate(key_list):\n            desc, func = sort_func_methods[key]\n            io.log_info(f\"[{i}] {desc}\")\n\n        io.log_info(\"\")\n        id = io.input_int(\"\", 5, valid_list=[*range(len(key_list))] )\n\n        sort_by_method = key_list[id]\n    else:\n        sort_by_method = sort_by_method.lower()\n\n    desc, func = sort_func_methods[sort_by_method]\n    img_list, trash_img_list = func(input_path)\n\n    final_process (input_path, img_list, trash_img_list)\n", "mainscripts/Util.py": "\ufeffimport pickle\nfrom pathlib import Path\n\nimport cv2\n\nfrom DFLIMG import *\nfrom facelib import LandmarksProcessor, FaceType\nfrom core.interact import interact as io\nfrom core import pathex\nfrom core.cv2ex import *\n\n\ndef save_faceset_metadata_folder(input_path):\n    input_path = Path(input_path)\n\n    metadata_filepath = input_path / 'meta.dat'\n\n    io.log_info (f\"Saving metadata to {str(metadata_filepath)}\\r\\n\")\n\n    d = {}\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Processing\"):\n        filepath = Path(filepath)\n        dflimg = DFLIMG.load (filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f\"{filepath} is not a dfl image file\")\n            continue\n            \n        dfl_dict = dflimg.get_dict()\n        d[filepath.name] = ( dflimg.get_shape(), dfl_dict )\n\n    try:\n        with open(metadata_filepath, \"wb\") as f:\n            f.write ( pickle.dumps(d) )\n    except:\n        raise Exception( 'cannot save %s' % (filename) )\n\n    io.log_info(\"Now you can edit images.\")\n    io.log_info(\"!!! Keep same filenames in the folder.\")\n    io.log_info(\"You can change size of images, restoring process will downscale back to original size.\")\n    io.log_info(\"After that, use restore metadata.\")\n\ndef restore_faceset_metadata_folder(input_path):\n    input_path = Path(input_path)\n\n    metadata_filepath = input_path / 'meta.dat'\n    io.log_info (f\"Restoring metadata from {str(metadata_filepath)}.\\r\\n\")\n\n    if not metadata_filepath.exists():\n        io.log_err(f\"Unable to find {str(metadata_filepath)}.\")\n\n    try:\n        with open(metadata_filepath, \"rb\") as f:\n            d = pickle.loads(f.read())\n    except:\n        raise FileNotFoundError(filename)\n\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path, image_extensions=['.jpg'], return_Path_class=True), \"Processing\"):\n        saved_data = d.get(filepath.name, None)\n        if saved_data is None:\n            io.log_info(f\"No saved metadata for {filepath}\")\n            continue\n        \n        shape, dfl_dict = saved_data\n\n        img = cv2_imread (filepath)\n        if img.shape != shape:\n            img = cv2.resize (img, (shape[1], shape[0]), interpolation=cv2.INTER_LANCZOS4 )\n\n            cv2_imwrite (str(filepath), img, [int(cv2.IMWRITE_JPEG_QUALITY), 100] )\n\n        if filepath.suffix == '.jpg':\n            dflimg = DFLJPG.load(filepath)\n            dflimg.set_dict(dfl_dict)\n            dflimg.save()\n        else:\n            continue\n\n    metadata_filepath.unlink()\n\ndef add_landmarks_debug_images(input_path):\n    io.log_info (\"Adding landmarks debug images...\")\n\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Processing\"):\n        filepath = Path(filepath)\n\n        img = cv2_imread(str(filepath))\n\n        dflimg = DFLIMG.load (filepath)\n\n        if dflimg is None or not dflimg.has_data():\n            io.log_err (f\"{filepath.name} is not a dfl image file\")\n            continue\n        \n        if img is not None:\n            face_landmarks = dflimg.get_landmarks()\n            face_type = FaceType.fromString ( dflimg.get_face_type() )\n            \n            if face_type == FaceType.MARK_ONLY:\n                rect = dflimg.get_source_rect()\n                LandmarksProcessor.draw_rect_landmarks(img, rect, face_landmarks, FaceType.FULL )\n            else:\n                LandmarksProcessor.draw_landmarks(img, face_landmarks, transparent_mask=True )\n            \n            \n            \n            output_file = '{}{}'.format( str(Path(str(input_path)) / filepath.stem),  '_debug.jpg')\n            cv2_imwrite(output_file, img, [int(cv2.IMWRITE_JPEG_QUALITY), 50] )\n\ndef recover_original_aligned_filename(input_path):\n    io.log_info (\"Recovering original aligned filename...\")\n\n    files = []\n    for filepath in io.progress_bar_generator( pathex.get_image_paths(input_path), \"Processing\"):\n        filepath = Path(filepath)\n\n        dflimg = DFLIMG.load (filepath)\n\n        if dflimg is None or not dflimg.has_data():\n            io.log_err (f\"{filepath.name} is not a dfl image file\")\n            continue\n\n        files += [ [filepath, None, dflimg.get_source_filename(), False] ]\n\n    files_len = len(files)\n    for i in io.progress_bar_generator( range(files_len), \"Sorting\" ):\n        fp, _, sf, converted = files[i]\n\n        if converted:\n            continue\n\n        sf_stem = Path(sf).stem\n\n        files[i][1] = fp.parent / ( sf_stem + '_0' + fp.suffix )\n        files[i][3] = True\n        c = 1\n\n        for j in range(i+1, files_len):\n            fp_j, _, sf_j, converted_j = files[j]\n            if converted_j:\n                continue\n\n            if sf_j == sf:\n                files[j][1] = fp_j.parent / ( sf_stem + ('_%d' % (c)) + fp_j.suffix )\n                files[j][3] = True\n                c += 1\n\n    for file in io.progress_bar_generator( files, \"Renaming\", leave=False ):\n        fs, _, _, _ = file\n        dst = fs.parent / ( fs.stem + '_tmp' + fs.suffix )\n        try:\n            fs.rename (dst)\n        except:\n            io.log_err ('fail to rename %s' % (fs.name) )\n\n    for file in io.progress_bar_generator( files, \"Renaming\" ):\n        fs, fd, _, _ = file\n        fs = fs.parent / ( fs.stem + '_tmp' + fs.suffix )\n        try:\n            fs.rename (fd)\n        except:\n            io.log_err ('fail to rename %s' % (fs.name) )\n\ndef export_faceset_mask(input_dir):\n    for filename in io.progress_bar_generator(pathex.get_image_paths (input_dir), \"Processing\"):\n        filepath = Path(filename)\n        \n        if '_mask' in filepath.stem:\n            continue\n        \n        mask_filepath = filepath.parent / (filepath.stem+'_mask'+filepath.suffix)\n        \n        dflimg = DFLJPG.load(filepath)\n        \n        H,W,C = dflimg.shape\n        \n        seg_ie_polys = dflimg.get_seg_ie_polys()\n        \n        if dflimg.has_xseg_mask():\n            mask = dflimg.get_xseg_mask()\n            mask[mask < 0.5] = 0.0\n            mask[mask >= 0.5] = 1.0\n        elif seg_ie_polys.has_polys():\n            mask = np.zeros ((H,W,1), dtype=np.float32)\n            seg_ie_polys.overlay_mask(mask)\n        else:\n            raise Exception(f'no mask in file {filepath}')\n        \n        \n        cv2_imwrite(mask_filepath, (mask*255).astype(np.uint8), [int(cv2.IMWRITE_JPEG_QUALITY), 100] )\n                ", "mainscripts/Trainer.py": "\ufeffimport os\nimport sys\nimport traceback\nimport queue\nimport threading\nimport time\nimport numpy as np\nimport itertools\nfrom pathlib import Path\nfrom core import pathex\nfrom core import imagelib\nimport cv2\nimport models\nfrom core.interact import interact as io\n\ndef trainerThread (s2c, c2s, e,\n                    model_class_name = None,\n                    saved_models_path = None,\n                    training_data_src_path = None,\n                    training_data_dst_path = None,\n                    pretraining_data_path = None,\n                    pretrained_model_path = None,\n                    no_preview=False,\n                    force_model_name=None,\n                    force_gpu_idxs=None,\n                    cpu_only=None,\n                    silent_start=False,\n                    execute_programs = None,\n                    debug=False,\n                    **kwargs):\n    while True:\n        try:\n            start_time = time.time()\n\n            save_interval_min = 25\n\n            if not training_data_src_path.exists():\n                training_data_src_path.mkdir(exist_ok=True, parents=True)\n\n            if not training_data_dst_path.exists():\n                training_data_dst_path.mkdir(exist_ok=True, parents=True)\n\n            if not saved_models_path.exists():\n                saved_models_path.mkdir(exist_ok=True, parents=True)\n                            \n            model = models.import_model(model_class_name)(\n                        is_training=True,\n                        saved_models_path=saved_models_path,\n                        training_data_src_path=training_data_src_path,\n                        training_data_dst_path=training_data_dst_path,\n                        pretraining_data_path=pretraining_data_path,\n                        pretrained_model_path=pretrained_model_path,\n                        no_preview=no_preview,\n                        force_model_name=force_model_name,\n                        force_gpu_idxs=force_gpu_idxs,\n                        cpu_only=cpu_only,\n                        silent_start=silent_start,\n                        debug=debug)\n\n            is_reached_goal = model.is_reached_iter_goal()\n\n            shared_state = { 'after_save' : False }\n            loss_string = \"\"\n            save_iter =  model.get_iter()\n            def model_save():\n                if not debug and not is_reached_goal:\n                    io.log_info (\"Saving....\", end='\\r')\n                    model.save()\n                    shared_state['after_save'] = True\n                    \n            def model_backup():\n                if not debug and not is_reached_goal:\n                    model.create_backup()             \n\n            def send_preview():\n                if not debug:\n                    previews = model.get_previews()\n                    c2s.put ( {'op':'show', 'previews': previews, 'iter':model.get_iter(), 'loss_history': model.get_loss_history().copy() } )\n                else:\n                    previews = [( 'debug, press update for new', model.debug_one_iter())]\n                    c2s.put ( {'op':'show', 'previews': previews} )\n                e.set() #Set the GUI Thread as Ready\n\n            if model.get_target_iter() != 0:\n                if is_reached_goal:\n                    io.log_info('Model already trained to target iteration. You can use preview.')\n                else:\n                    io.log_info('Starting. Target iteration: %d. Press \"Enter\" to stop training and save model.' % ( model.get_target_iter()  ) )\n            else:\n                io.log_info('Starting. Press \"Enter\" to stop training and save model.')\n\n            last_save_time = time.time()\n\n            execute_programs = [ [x[0], x[1], time.time() ] for x in execute_programs ]\n\n            for i in itertools.count(0,1):\n                if not debug:\n                    cur_time = time.time()\n\n                    for x in execute_programs:\n                        prog_time, prog, last_time = x\n                        exec_prog = False\n                        if prog_time > 0 and (cur_time - start_time) >= prog_time:\n                            x[0] = 0\n                            exec_prog = True\n                        elif prog_time < 0 and (cur_time - last_time)  >= -prog_time:\n                            x[2] = cur_time\n                            exec_prog = True\n\n                        if exec_prog:\n                            try:\n                                exec(prog)\n                            except Exception as e:\n                                print(\"Unable to execute program: %s\" % (prog) )\n\n                    if not is_reached_goal:\n\n                        if model.get_iter() == 0:\n                            io.log_info(\"\")\n                            io.log_info(\"Trying to do the first iteration. If an error occurs, reduce the model parameters.\")\n                            io.log_info(\"\")\n                            \n                            if sys.platform[0:3] == 'win':\n                                io.log_info(\"!!!\")\n                                io.log_info(\"Windows 10 users IMPORTANT notice. You should set this setting in order to work correctly.\")\n                                io.log_info(\"https://i.imgur.com/B7cmDCB.jpg\")\n                                io.log_info(\"!!!\")\n\n                        iter, iter_time = model.train_one_iter()\n\n                        loss_history = model.get_loss_history()\n                        time_str = time.strftime(\"[%H:%M:%S]\")\n                        if iter_time >= 10:\n                            loss_string = \"{0}[#{1:06d}][{2:.5s}s]\".format ( time_str, iter, '{:0.4f}'.format(iter_time) )\n                        else:\n                            loss_string = \"{0}[#{1:06d}][{2:04d}ms]\".format ( time_str, iter, int(iter_time*1000) )\n\n                        if shared_state['after_save']:\n                            shared_state['after_save'] = False\n                            \n                            mean_loss = np.mean ( loss_history[save_iter:iter], axis=0)\n\n                            for loss_value in mean_loss:\n                                loss_string += \"[%.4f]\" % (loss_value)\n\n                            io.log_info (loss_string)\n\n                            save_iter = iter\n                        else:\n                            for loss_value in loss_history[-1]:\n                                loss_string += \"[%.4f]\" % (loss_value)\n\n                            if io.is_colab():\n                                io.log_info ('\\r' + loss_string, end='')\n                            else:\n                                io.log_info (loss_string, end='\\r')\n\n                        if model.get_iter() == 1:\n                            model_save()\n\n                        if model.get_target_iter() != 0 and model.is_reached_iter_goal():\n                            io.log_info ('Reached target iteration.')\n                            model_save()\n                            is_reached_goal = True\n                            io.log_info ('You can use preview now.')\n                \n                need_save = False\n                while time.time() - last_save_time >= save_interval_min*60:\n                    last_save_time += save_interval_min*60\n                    need_save = True\n                \n                if not is_reached_goal and need_save:\n                    model_save()\n                    send_preview()\n\n                if i==0:\n                    if is_reached_goal:\n                        model.pass_one_iter()\n                    send_preview()\n\n                if debug:\n                    time.sleep(0.005)\n\n                while not s2c.empty():\n                    input = s2c.get()\n                    op = input['op']\n                    if op == 'save':\n                        model_save()\n                    elif op == 'backup':\n                        model_backup()\n                    elif op == 'preview':\n                        if is_reached_goal:\n                            model.pass_one_iter()\n                        send_preview()\n                    elif op == 'close':\n                        model_save()\n                        i = -1\n                        break\n\n                if i == -1:\n                    break\n\n\n\n            model.finalize()\n\n        except Exception as e:\n            print ('Error: %s' % (str(e)))\n            traceback.print_exc()\n        break\n    c2s.put ( {'op':'close'} )\n\n\n\ndef main(**kwargs):\n    io.log_info (\"Running trainer.\\r\\n\")\n\n    no_preview = kwargs.get('no_preview', False)\n\n    s2c = queue.Queue()\n    c2s = queue.Queue()\n\n    e = threading.Event()\n    thread = threading.Thread(target=trainerThread, args=(s2c, c2s, e), kwargs=kwargs )\n    thread.start()\n\n    e.wait() #Wait for inital load to occur.\n\n    if no_preview:\n        while True:\n            if not c2s.empty():\n                input = c2s.get()\n                op = input.get('op','')\n                if op == 'close':\n                    break\n            try:\n                io.process_messages(0.1)\n            except KeyboardInterrupt:\n                s2c.put ( {'op': 'close'} )\n    else:\n        wnd_name = \"Training preview\"\n        io.named_window(wnd_name)\n        io.capture_keys(wnd_name)\n\n        previews = None\n        loss_history = None\n        selected_preview = 0\n        update_preview = False\n        is_showing = False\n        is_waiting_preview = False\n        show_last_history_iters_count = 0\n        iter = 0\n        while True:\n            if not c2s.empty():\n                input = c2s.get()\n                op = input['op']\n                if op == 'show':\n                    is_waiting_preview = False\n                    loss_history = input['loss_history'] if 'loss_history' in input.keys() else None\n                    previews = input['previews'] if 'previews' in input.keys() else None\n                    iter = input['iter'] if 'iter' in input.keys() else 0\n                    if previews is not None:\n                        max_w = 0\n                        max_h = 0\n                        for (preview_name, preview_rgb) in previews:\n                            (h, w, c) = preview_rgb.shape\n                            max_h = max (max_h, h)\n                            max_w = max (max_w, w)\n\n                        max_size = 800\n                        if max_h > max_size:\n                            max_w = int( max_w / (max_h / max_size) )\n                            max_h = max_size\n\n                        #make all previews size equal\n                        for preview in previews[:]:\n                            (preview_name, preview_rgb) = preview\n                            (h, w, c) = preview_rgb.shape\n                            if h != max_h or w != max_w:\n                                previews.remove(preview)\n                                previews.append ( (preview_name, cv2.resize(preview_rgb, (max_w, max_h))) )\n                        selected_preview = selected_preview % len(previews)\n                        update_preview = True\n                elif op == 'close':\n                    break\n\n            if update_preview:\n                update_preview = False\n\n                selected_preview_name = previews[selected_preview][0]\n                selected_preview_rgb = previews[selected_preview][1]\n                (h,w,c) = selected_preview_rgb.shape\n\n                # HEAD\n                head_lines = [\n                    '[s]:save [b]:backup [enter]:exit',\n                    '[p]:update [space]:next preview [l]:change history range',\n                    'Preview: \"%s\" [%d/%d]' % (selected_preview_name,selected_preview+1, len(previews) )\n                    ]\n                head_line_height = 15\n                head_height = len(head_lines) * head_line_height\n                head = np.ones ( (head_height,w,c) ) * 0.1\n\n                for i in range(0, len(head_lines)):\n                    t = i*head_line_height\n                    b = (i+1)*head_line_height\n                    head[t:b, 0:w] += imagelib.get_text_image (  (head_line_height,w,c) , head_lines[i], color=[0.8]*c )\n\n                final = head\n\n                if loss_history is not None:\n                    if show_last_history_iters_count == 0:\n                        loss_history_to_show = loss_history\n                    else:\n                        loss_history_to_show = loss_history[-show_last_history_iters_count:]\n\n                    lh_img = models.ModelBase.get_loss_history_preview(loss_history_to_show, iter, w, c)\n                    final = np.concatenate ( [final, lh_img], axis=0 )\n\n                final = np.concatenate ( [final, selected_preview_rgb], axis=0 )\n                final = np.clip(final, 0, 1)\n\n                io.show_image( wnd_name, (final*255).astype(np.uint8) )\n                is_showing = True\n\n            key_events = io.get_key_events(wnd_name)\n            key, chr_key, ctrl_pressed, alt_pressed, shift_pressed = key_events[-1] if len(key_events) > 0 else (0,0,False,False,False)\n\n            if key == ord('\\n') or key == ord('\\r'):\n                s2c.put ( {'op': 'close'} )\n            elif key == ord('s'):\n                s2c.put ( {'op': 'save'} )\n            elif key == ord('b'):\n                s2c.put ( {'op': 'backup'} )\n            elif key == ord('p'):\n                if not is_waiting_preview:\n                    is_waiting_preview = True\n                    s2c.put ( {'op': 'preview'} )\n            elif key == ord('l'):\n                if show_last_history_iters_count == 0:\n                    show_last_history_iters_count = 5000\n                elif show_last_history_iters_count == 5000:\n                    show_last_history_iters_count = 10000\n                elif show_last_history_iters_count == 10000:\n                    show_last_history_iters_count = 50000\n                elif show_last_history_iters_count == 50000:\n                    show_last_history_iters_count = 100000\n                elif show_last_history_iters_count == 100000:\n                    show_last_history_iters_count = 0\n                update_preview = True\n            elif key == ord(' '):\n                selected_preview = (selected_preview + 1) % len(previews)\n                update_preview = True\n\n            try:\n                io.process_messages(0.1)\n            except KeyboardInterrupt:\n                s2c.put ( {'op': 'close'} )\n\n        io.destroy_all_windows()", "mainscripts/dev_misc.py": "import traceback\nimport json\nimport multiprocessing\nimport shutil\nfrom pathlib import Path\nimport cv2\nimport numpy as np\n\nfrom core import imagelib, pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor\nfrom core.leras import nn\nfrom DFLIMG import *\nfrom facelib import FaceType, LandmarksProcessor\nfrom . import Extractor, Sorter\nfrom .Extractor import ExtractSubprocessor\n\n\ndef extract_vggface2_dataset(input_dir, device_args={} ):\n    multi_gpu = device_args.get('multi_gpu', False)\n    cpu_only = device_args.get('cpu_only', False)\n\n    input_path = Path(input_dir)\n    if not input_path.exists():\n        raise ValueError('Input directory not found. Please ensure it exists.')\n\n    bb_csv = input_path / 'loose_bb_train.csv'\n    if not bb_csv.exists():\n        raise ValueError('loose_bb_train.csv found. Please ensure it exists.')\n\n    bb_lines = bb_csv.read_text().split('\\n')\n    bb_lines.pop(0)\n\n    bb_dict = {}\n    for line in bb_lines:\n        name, l, t, w, h = line.split(',')\n        name = name[1:-1]\n        l, t, w, h = [ int(x) for x in (l, t, w, h) ]\n        bb_dict[name] = (l,t,w, h)\n\n\n    output_path = input_path.parent / (input_path.name + '_out')\n\n    dir_names = pathex.get_all_dir_names(input_path)\n\n    if not output_path.exists():\n        output_path.mkdir(parents=True, exist_ok=True)\n\n    data = []\n    for dir_name in io.progress_bar_generator(dir_names, \"Collecting\"):\n        cur_input_path = input_path / dir_name\n        cur_output_path = output_path / dir_name\n\n        if not cur_output_path.exists():\n            cur_output_path.mkdir(parents=True, exist_ok=True)\n\n        input_path_image_paths = pathex.get_image_paths(cur_input_path)\n\n        for filename in input_path_image_paths:\n            filename_path = Path(filename)\n\n            name = filename_path.parent.name + '/' + filename_path.stem\n            if name not in bb_dict:\n                continue\n\n            l,t,w,h = bb_dict[name]\n            if min(w,h) < 128:\n                continue\n\n            data += [ ExtractSubprocessor.Data(filename=filename,rects=[ (l,t,l+w,t+h) ], landmarks_accurate=False, force_output_path=cur_output_path ) ]\n\n    face_type = FaceType.fromString('full_face')\n\n    io.log_info ('Performing 2nd pass...')\n    data = ExtractSubprocessor (data, 'landmarks', 256, face_type, debug_dir=None, multi_gpu=multi_gpu, cpu_only=cpu_only, manual=False).run()\n\n    io.log_info ('Performing 3rd pass...')\n    ExtractSubprocessor (data, 'final', 256, face_type, debug_dir=None, multi_gpu=multi_gpu, cpu_only=cpu_only, manual=False, final_output_path=None).run()\n\n\n\"\"\"\n    import code\n    code.interact(local=dict(globals(), **locals()))\n\n    data_len = len(data)\n    i = 0\n    while i < data_len-1:\n        i_name = Path(data[i].filename).parent.name\n\n        sub_data = []\n\n        for j in range (i, data_len):\n            j_name = Path(data[j].filename).parent.name\n            if i_name == j_name:\n                sub_data += [ data[j] ]\n            else:\n                break\n        i = j\n\n        cur_output_path = output_path / i_name\n\n        io.log_info (f\"Processing: {str(cur_output_path)}, {i}/{data_len} \")\n\n        if not cur_output_path.exists():\n            cur_output_path.mkdir(parents=True, exist_ok=True)\n\n\n\n\n\n\n\n\n    for dir_name in dir_names:\n\n        cur_input_path = input_path / dir_name\n        cur_output_path = output_path / dir_name\n\n        input_path_image_paths = pathex.get_image_paths(cur_input_path)\n        l = len(input_path_image_paths)\n        #if l < 250 or l > 350:\n        #    continue\n\n        io.log_info (f\"Processing: {str(cur_input_path)} \")\n\n        if not cur_output_path.exists():\n            cur_output_path.mkdir(parents=True, exist_ok=True)\n\n\n        data = []\n        for filename in input_path_image_paths:\n            filename_path = Path(filename)\n\n            name = filename_path.parent.name + '/' + filename_path.stem\n            if name not in bb_dict:\n                continue\n\n            bb = bb_dict[name]\n            l,t,w,h = bb\n            if min(w,h) < 128:\n                continue\n\n            data += [ ExtractSubprocessor.Data(filename=filename,rects=[ (l,t,l+w,t+h) ], landmarks_accurate=False ) ]\n\n\n\n        io.log_info ('Performing 2nd pass...')\n        data = ExtractSubprocessor (data, 'landmarks', 256, face_type, debug_dir=None, multi_gpu=False, cpu_only=False, manual=False).run()\n\n        io.log_info ('Performing 3rd pass...')\n        data = ExtractSubprocessor (data, 'final', 256, face_type, debug_dir=None, multi_gpu=False, cpu_only=False, manual=False, final_output_path=cur_output_path).run()\n\n\n        io.log_info (f\"Sorting: {str(cur_output_path)} \")\n        Sorter.main (input_path=str(cur_output_path), sort_by_method='hist')\n\n        import code\n        code.interact(local=dict(globals(), **locals()))\n\n        #try:\n        #    io.log_info (f\"Removing: {str(cur_input_path)} \")\n        #    shutil.rmtree(cur_input_path)\n        #except:\n        #    io.log_info (f\"unable to remove: {str(cur_input_path)} \")\n\n\n\n\ndef extract_vggface2_dataset(input_dir, device_args={} ):\n    multi_gpu = device_args.get('multi_gpu', False)\n    cpu_only = device_args.get('cpu_only', False)\n\n    input_path = Path(input_dir)\n    if not input_path.exists():\n        raise ValueError('Input directory not found. Please ensure it exists.')\n\n    output_path = input_path.parent / (input_path.name + '_out')\n\n    dir_names = pathex.get_all_dir_names(input_path)\n\n    if not output_path.exists():\n        output_path.mkdir(parents=True, exist_ok=True)\n\n\n\n    for dir_name in dir_names:\n\n        cur_input_path = input_path / dir_name\n        cur_output_path = output_path / dir_name\n\n        l = len(pathex.get_image_paths(cur_input_path))\n        if l < 250 or l > 350:\n            continue\n\n        io.log_info (f\"Processing: {str(cur_input_path)} \")\n\n        if not cur_output_path.exists():\n            cur_output_path.mkdir(parents=True, exist_ok=True)\n\n        Extractor.main( str(cur_input_path),\n              str(cur_output_path),\n              detector='s3fd',\n              image_size=256,\n              face_type='full_face',\n              max_faces_from_image=1,\n              device_args=device_args )\n\n        io.log_info (f\"Sorting: {str(cur_input_path)} \")\n        Sorter.main (input_path=str(cur_output_path), sort_by_method='hist')\n\n        try:\n            io.log_info (f\"Removing: {str(cur_input_path)} \")\n            shutil.rmtree(cur_input_path)\n        except:\n            io.log_info (f\"unable to remove: {str(cur_input_path)} \")\n\n\"\"\"\n\n#unused in end user workflow\ndef dev_test_68(input_dir ):\n    # process 68 landmarks dataset with .pts files\n    input_path = Path(input_dir)\n    if not input_path.exists():\n        raise ValueError('input_dir not found. Please ensure it exists.')\n\n    output_path = input_path.parent / (input_path.name+'_aligned')\n\n    io.log_info(f'Output dir is % {output_path}')\n\n    if output_path.exists():\n        output_images_paths = pathex.get_image_paths(output_path)\n        if len(output_images_paths) > 0:\n            io.input_bool(\"WARNING !!! \\n %s contains files! \\n They will be deleted. \\n Press enter to continue.\" % (str(output_path)), False )\n            for filename in output_images_paths:\n                Path(filename).unlink()\n    else:\n        output_path.mkdir(parents=True, exist_ok=True)\n\n    images_paths = pathex.get_image_paths(input_path)\n\n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        filepath = Path(filepath)\n\n\n        pts_filepath = filepath.parent / (filepath.stem+'.pts')\n        if pts_filepath.exists():\n            pts = pts_filepath.read_text()\n            pts_lines = pts.split('\\n')\n\n            lmrk_lines = None\n            for pts_line in pts_lines:\n                if pts_line == '{':\n                    lmrk_lines = []\n                elif pts_line == '}':\n                    break\n                else:\n                    if lmrk_lines is not None:\n                        lmrk_lines.append (pts_line)\n\n            if lmrk_lines is not None and len(lmrk_lines) == 68:\n                try:\n                    lmrks = [ np.array ( lmrk_line.strip().split(' ') ).astype(np.float32).tolist() for lmrk_line in lmrk_lines]\n                except Exception as e:\n                    print(e)\n                    print(filepath)\n                    continue\n\n                rect = LandmarksProcessor.get_rect_from_landmarks(lmrks)\n\n                output_filepath = output_path / (filepath.stem+'.jpg')\n\n                img = cv2_imread(filepath)\n                img = imagelib.normalize_channels(img, 3)\n                cv2_imwrite(output_filepath, img, [int(cv2.IMWRITE_JPEG_QUALITY), 95] )\n                \n                raise Exception(\"unimplemented\")\n                #DFLJPG.x(output_filepath, face_type=FaceType.toString(FaceType.MARK_ONLY),\n                #                                landmarks=lmrks,\n                #                                source_filename=filepath.name,\n                #                                source_rect=rect,\n                #                                source_landmarks=lmrks\n                #                    )\n\n    io.log_info(\"Done.\")\n\n#unused in end user workflow\ndef extract_umd_csv(input_file_csv,\n                    face_type='full_face',\n                    device_args={} ):\n\n    #extract faces from umdfaces.io dataset csv file with pitch,yaw,roll info.\n    multi_gpu = device_args.get('multi_gpu', False)\n    cpu_only = device_args.get('cpu_only', False)\n    face_type = FaceType.fromString(face_type)\n\n    input_file_csv_path = Path(input_file_csv)\n    if not input_file_csv_path.exists():\n        raise ValueError('input_file_csv not found. Please ensure it exists.')\n\n    input_file_csv_root_path = input_file_csv_path.parent\n    output_path = input_file_csv_path.parent / ('aligned_' + input_file_csv_path.name)\n\n    io.log_info(\"Output dir is %s.\" % (str(output_path)) )\n\n    if output_path.exists():\n        output_images_paths = pathex.get_image_paths(output_path)\n        if len(output_images_paths) > 0:\n            io.input_bool(\"WARNING !!! \\n %s contains files! \\n They will be deleted. \\n Press enter to continue.\" % (str(output_path)), False )\n            for filename in output_images_paths:\n                Path(filename).unlink()\n    else:\n        output_path.mkdir(parents=True, exist_ok=True)\n\n    try:\n        with open( str(input_file_csv_path), 'r') as f:\n            csv_file = f.read()\n    except Exception as e:\n        io.log_err(\"Unable to open or read file \" + str(input_file_csv_path) + \": \" + str(e) )\n        return\n\n    strings = csv_file.split('\\n')\n    keys = strings[0].split(',')\n    keys_len = len(keys)\n    csv_data = []\n    for i in range(1, len(strings)):\n        values = strings[i].split(',')\n        if keys_len != len(values):\n            io.log_err(\"Wrong string in csv file, skipping.\")\n            continue\n\n        csv_data += [ { keys[n] : values[n] for n in range(keys_len) } ]\n\n    data = []\n    for d in csv_data:\n        filename = input_file_csv_root_path / d['FILE']\n\n\n        x,y,w,h = float(d['FACE_X']), float(d['FACE_Y']), float(d['FACE_WIDTH']), float(d['FACE_HEIGHT'])\n\n        data += [ ExtractSubprocessor.Data(filename=filename, rects=[ [x,y,x+w,y+h] ]) ]\n\n    images_found = len(data)\n    faces_detected = 0\n    if len(data) > 0:\n        io.log_info (\"Performing 2nd pass from csv file...\")\n        data = ExtractSubprocessor (data, 'landmarks', multi_gpu=multi_gpu, cpu_only=cpu_only).run()\n\n        io.log_info ('Performing 3rd pass...')\n        data = ExtractSubprocessor (data, 'final', face_type, None, multi_gpu=multi_gpu, cpu_only=cpu_only, manual=False, final_output_path=output_path).run()\n        faces_detected += sum([d.faces_detected for d in data])\n\n\n    io.log_info ('-------------------------')\n    io.log_info ('Images found:        %d' % (images_found) )\n    io.log_info ('Faces detected:      %d' % (faces_detected) )\n    io.log_info ('-------------------------')\n\n\n    \ndef dev_test1(input_dir):\n    # LaPa dataset\n    \n    image_size = 1024\n    face_type = FaceType.HEAD\n    \n    input_path = Path(input_dir)\n    images_path = input_path / 'images'    \n    if not images_path.exists:\n        raise ValueError('LaPa dataset: images folder not found.')\n    labels_path = input_path / 'labels'    \n    if not labels_path.exists:\n        raise ValueError('LaPa dataset: labels folder not found.')\n    landmarks_path = input_path / 'landmarks'    \n    if not landmarks_path.exists:\n        raise ValueError('LaPa dataset: landmarks folder not found.')\n    \n    output_path = input_path / 'out'    \n    if output_path.exists():\n        output_images_paths = pathex.get_image_paths(output_path)\n        if len(output_images_paths) != 0:\n            io.input(f\"\\n WARNING !!! \\n {output_path} contains files! \\n They will be deleted. \\n Press enter to continue.\\n\")\n            for filename in output_images_paths:\n                Path(filename).unlink()\n    output_path.mkdir(parents=True, exist_ok=True)\n    \n    data = []\n    \n    img_paths = pathex.get_image_paths (images_path)\n    for filename in img_paths:\n        filepath = Path(filename)\n\n        landmark_filepath = landmarks_path / (filepath.stem + '.txt')\n        if not landmark_filepath.exists():\n            raise ValueError(f'no landmarks for {filepath}')\n        \n        #img = cv2_imread(filepath)\n        \n        lm = landmark_filepath.read_text()\n        lm = lm.split('\\n')\n        if int(lm[0]) != 106:\n            raise ValueError(f'wrong landmarks format in {landmark_filepath}')\n        \n        lmrks = []\n        for i in range(106):\n            x,y = lm[i+1].split(' ')\n            x,y = float(x), float(y)\n            lmrks.append ( (x,y) )\n            \n        lmrks = np.array(lmrks)\n        \n        l,t = np.min(lmrks, 0)\n        r,b = np.max(lmrks, 0)\n        \n        l,t,r,b = ( int(x) for x in (l,t,r,b) )\n        \n        #for x, y in lmrks:\n        #    x,y = int(x), int(y)\n        #    cv2.circle(img, (x, y), 1, (0,255,0) , 1, lineType=cv2.LINE_AA)   \n         \n        #imagelib.draw_rect(img, (l,t,r,b), (0,255,0) )\n         \n        \n        data += [ ExtractSubprocessor.Data(filepath=filepath, rects=[ (l,t,r,b) ]) ]\n\n        #cv2.imshow(\"\", img) \n        #cv2.waitKey(0)\n \n    if len(data) > 0:\n        device_config = nn.DeviceConfig.BestGPU()\n        \n        io.log_info (\"Performing 2nd pass...\")\n        data = ExtractSubprocessor (data, 'landmarks', image_size, 95, face_type,  device_config=device_config).run()\n        io.log_info (\"Performing 3rd pass...\")\n        data = ExtractSubprocessor (data, 'final', image_size, 95, face_type, final_output_path=output_path, device_config=device_config).run()\n\n\n        for filename in pathex.get_image_paths (output_path):\n            filepath = Path(filename)\n            \n            \n            dflimg = DFLJPG.load(filepath)\n            \n            src_filename = dflimg.get_source_filename()\n            image_to_face_mat = dflimg.get_image_to_face_mat()\n\n            label_filepath = labels_path / ( Path(src_filename).stem + '.png')        \n            if not label_filepath.exists():\n                raise ValueError(f'{label_filepath} does not exist')\n            \n            mask = cv2_imread(label_filepath)        \n            #mask[mask == 10] = 0 # remove hair\n            mask[mask > 0] = 1\n            mask = cv2.warpAffine(mask, image_to_face_mat, (image_size, image_size), cv2.INTER_LINEAR)\n            mask = cv2.blur(mask, (3,3) )\n            \n            #cv2.imshow(\"\", (mask*255).astype(np.uint8) ) \n            #cv2.waitKey(0)\n            \n            dflimg.set_xseg_mask(mask)\n            dflimg.save()\n        \n    \n    import code\n    code.interact(local=dict(globals(), **locals()))\n                    \n\ndef dev_resave_pngs(input_dir):\n    input_path = Path(input_dir)\n    if not input_path.exists():\n        raise ValueError('input_dir not found. Please ensure it exists.')\n\n    images_paths = pathex.get_image_paths(input_path, image_extensions=['.png'], subdirs=True, return_Path_class=True)\n\n    for filepath in io.progress_bar_generator(images_paths,\"Processing\"):\n        cv2_imwrite(filepath, cv2_imread(filepath))\n\n\ndef dev_segmented_trash(input_dir):\n    input_path = Path(input_dir)\n    if not input_path.exists():\n        raise ValueError('input_dir not found. Please ensure it exists.')\n\n    output_path = input_path.parent / (input_path.name+'_trash')\n    output_path.mkdir(parents=True, exist_ok=True)\n\n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n\n    trash_paths = []\n    for filepath in images_paths:\n        json_file = filepath.parent / (filepath.stem +'.json')\n        if not json_file.exists():\n            trash_paths.append(filepath)\n\n    for filepath in trash_paths:\n\n        try:\n            filepath.rename ( output_path / filepath.name )\n        except:\n            io.log_info ('fail to trashing %s' % (src.name) )\n\n\n\ndef dev_test(input_dir):\n    \"\"\"\n    extract FaceSynthetics dataset https://github.com/microsoft/FaceSynthetics\n    \n    BACKGROUND = 0\n    SKIN = 1\n    NOSE = 2\n    RIGHT_EYE = 3\n    LEFT_EYE = 4\n    RIGHT_BROW = 5\n    LEFT_BROW = 6\n    RIGHT_EAR = 7\n    LEFT_EAR = 8\n    MOUTH_INTERIOR = 9\n    TOP_LIP = 10\n    BOTTOM_LIP = 11\n    NECK = 12\n    HAIR = 13\n    BEARD = 14\n    CLOTHING = 15\n    GLASSES = 16\n    HEADWEAR = 17\n    FACEWEAR = 18\n    IGNORE = 255\n    \"\"\"\n    \n    \n    image_size = 1024\n    face_type = FaceType.WHOLE_FACE\n    \n    input_path = Path(input_dir)\n    \n    \n    \n    output_path = input_path.parent / f'{input_path.name}_out'    \n    if output_path.exists():\n        output_images_paths = pathex.get_image_paths(output_path)\n        if len(output_images_paths) != 0:\n            io.input(f\"\\n WARNING !!! \\n {output_path} contains files! \\n They will be deleted. \\n Press enter to continue.\\n\")\n            for filename in output_images_paths:\n                Path(filename).unlink()\n    output_path.mkdir(parents=True, exist_ok=True)\n    \n    data = []\n    \n    for filepath in io.progress_bar_generator(pathex.get_paths(input_path), \"Processing\"):\n        if filepath.suffix == '.txt':\n            \n            image_filepath = filepath.parent / f'{filepath.name.split(\"_\")[0]}.png'\n            if not image_filepath.exists():\n                print(f'{image_filepath} does not exist, skipping') \n                \n            lmrks = []\n            for lmrk_line in filepath.read_text().split('\\n'):\n                if len(lmrk_line) == 0:\n                    continue\n                    \n                x, y = lmrk_line.split(' ')\n                x, y = float(x), float(y)\n                \n                lmrks.append( (x,y) )\n                \n            lmrks = np.array(lmrks[:68], np.float32)\n            rect = LandmarksProcessor.get_rect_from_landmarks(lmrks)\n            data += [ ExtractSubprocessor.Data(filepath=image_filepath, rects=[rect], landmarks=[ lmrks ] ) ]\n\n    if len(data) > 0:\n        io.log_info (\"Performing 3rd pass...\")\n        data = ExtractSubprocessor (data, 'final', image_size, 95, face_type, final_output_path=output_path, device_config=nn.DeviceConfig.CPU()).run()\n\n        for filename in io.progress_bar_generator(pathex.get_image_paths (output_path), \"Processing\"):\n            filepath = Path(filename)\n            \n            dflimg = DFLJPG.load(filepath)\n            \n            src_filename = dflimg.get_source_filename()\n            image_to_face_mat = dflimg.get_image_to_face_mat()\n            \n            seg_filepath = input_path / ( Path(src_filename).stem + '_seg.png')        \n            if not seg_filepath.exists():\n                raise ValueError(f'{seg_filepath} does not exist')\n            \n            seg = cv2_imread(seg_filepath)     \n            seg_inds = np.isin(seg, [1,2,3,4,5,6,9,10,11]) \n            seg[~seg_inds] = 0\n            seg[seg_inds] = 1\n            seg = seg.astype(np.float32)\n            seg = cv2.warpAffine(seg, image_to_face_mat, (image_size, image_size), cv2.INTER_LANCZOS4)\n            dflimg.set_xseg_mask(seg)\n            dflimg.save()\n            ", "mainscripts/FacesetEnhancer.py": "import multiprocessing\nimport shutil\n\nfrom DFLIMG import *\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor\nfrom core.leras import nn\nfrom core import pathex\nfrom core.cv2ex import *\n\n\nclass FacesetEnhancerSubprocessor(Subprocessor):\n\n    #override\n    def __init__(self, image_paths, output_dirpath, device_config):\n        self.image_paths = image_paths\n        self.output_dirpath = output_dirpath\n        self.result = []\n        self.nn_initialize_mp_lock = multiprocessing.Lock()\n        self.devices = FacesetEnhancerSubprocessor.get_devices_for_config(device_config)\n\n        super().__init__('FacesetEnhancer', FacesetEnhancerSubprocessor.Cli, 600)\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (None, len (self.image_paths))\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def process_info_generator(self):\n        base_dict = {'output_dirpath':self.output_dirpath,\n                     'nn_initialize_mp_lock': self.nn_initialize_mp_lock,}\n\n        for (device_idx, device_type, device_name, device_total_vram_gb) in self.devices:\n            client_dict = base_dict.copy()\n            client_dict['device_idx'] = device_idx\n            client_dict['device_name'] = device_name\n            client_dict['device_type'] = device_type\n            yield client_dict['device_name'], {}, client_dict\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.image_paths) > 0:\n            return self.image_paths.pop(0)\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.image_paths.insert(0, data)\n\n    #override\n    def on_result (self, host_dict, data, result):\n        io.progress_bar_inc(1)\n        if result[0] == 1:\n            self.result +=[ (result[1], result[2]) ]\n\n    #override\n    def get_result(self):\n        return self.result\n\n    @staticmethod\n    def get_devices_for_config (device_config):\n        devices = device_config.devices\n        cpu_only = len(devices) == 0\n\n        if not cpu_only:\n            return [ (device.index, 'GPU', device.name, device.total_mem_gb) for device in devices ]\n        else:\n            return [ (i, 'CPU', 'CPU%d' % (i), 0 ) for i in range( min(8, multiprocessing.cpu_count() // 2) ) ]\n\n    class Cli(Subprocessor.Cli):\n\n        #override\n        def on_initialize(self, client_dict):\n            device_idx   = client_dict['device_idx']\n            cpu_only     = client_dict['device_type'] == 'CPU'\n            self.output_dirpath = client_dict['output_dirpath']\n            nn_initialize_mp_lock = client_dict['nn_initialize_mp_lock']\n\n            if cpu_only:\n                device_config = nn.DeviceConfig.CPU()\n                device_vram = 99\n            else:\n                device_config = nn.DeviceConfig.GPUIndexes ([device_idx])\n                device_vram = device_config.devices[0].total_mem_gb\n\n            nn.initialize (device_config)\n\n            intro_str = 'Running on %s.' % (client_dict['device_name'])\n\n            self.log_info (intro_str)\n\n            from facelib import FaceEnhancer\n            self.fe = FaceEnhancer( place_model_on_cpu=(device_vram<=2 or cpu_only), run_on_cpu=cpu_only )\n\n        #override\n        def process_data(self, filepath):\n            try:\n                dflimg = DFLIMG.load (filepath)\n                if dflimg is None or not dflimg.has_data():\n                    self.log_err (f\"{filepath.name} is not a dfl image file\")\n                else:\n                    dfl_dict = dflimg.get_dict()\n\n                    img = cv2_imread(filepath).astype(np.float32) / 255.0\n                    img = self.fe.enhance(img)\n                    img = np.clip (img*255, 0, 255).astype(np.uint8)\n\n                    output_filepath = self.output_dirpath / filepath.name\n\n                    cv2_imwrite ( str(output_filepath), img, [int(cv2.IMWRITE_JPEG_QUALITY), 100] )\n\n                    dflimg = DFLIMG.load (output_filepath)\n                    dflimg.set_dict(dfl_dict)\n                    dflimg.save()\n\n                    return (1, filepath, output_filepath)\n            except:\n                self.log_err (f\"Exception occured while processing file {filepath}. Error: {traceback.format_exc()}\")\n\n            return (0, filepath, None)\n\ndef process_folder ( dirpath, cpu_only=False, force_gpu_idxs=None ):\n    device_config = nn.DeviceConfig.GPUIndexes( force_gpu_idxs or nn.ask_choose_device_idxs(suggest_all_gpu=True) ) \\\n                    if not cpu_only else nn.DeviceConfig.CPU()\n\n    output_dirpath = dirpath.parent / (dirpath.name + '_enhanced')\n    output_dirpath.mkdir (exist_ok=True, parents=True)\n\n    dirpath_parts = '/'.join( dirpath.parts[-2:])\n    output_dirpath_parts = '/'.join( output_dirpath.parts[-2:] )\n    io.log_info (f\"Enhancing faceset in {dirpath_parts}\")\n    io.log_info ( f\"Processing to {output_dirpath_parts}\")\n\n    output_images_paths = pathex.get_image_paths(output_dirpath)\n    if len(output_images_paths) > 0:\n        for filename in output_images_paths:\n            Path(filename).unlink()\n\n    image_paths = [Path(x) for x in pathex.get_image_paths( dirpath )]\n    result = FacesetEnhancerSubprocessor ( image_paths, output_dirpath, device_config=device_config).run()\n\n    is_merge = io.input_bool (f\"\\r\\nMerge {output_dirpath_parts} to {dirpath_parts} ?\", True)\n    if is_merge:\n        io.log_info (f\"Copying processed files to {dirpath_parts}\")\n\n        for (filepath, output_filepath) in result:\n            try:\n                shutil.copy (output_filepath, filepath)\n            except:\n                pass\n\n        io.log_info (f\"Removing {output_dirpath_parts}\")\n        shutil.rmtree(output_dirpath)\n", "mainscripts/VideoEd.py": "import subprocess\nimport numpy as np\nimport ffmpeg\nfrom pathlib import Path\nfrom core import pathex\nfrom core.interact import interact as io\n\ndef extract_video(input_file, output_dir, output_ext=None, fps=None):\n    input_file_path = Path(input_file)\n    output_path = Path(output_dir)\n\n    if not output_path.exists():\n        output_path.mkdir(exist_ok=True)\n\n\n    if input_file_path.suffix == '.*':\n        input_file_path = pathex.get_first_file_by_stem (input_file_path.parent, input_file_path.stem)\n    else:\n        if not input_file_path.exists():\n            input_file_path = None\n\n    if input_file_path is None:\n        io.log_err(\"input_file not found.\")\n        return\n\n    if fps is None:\n        fps = io.input_int (\"Enter FPS\", 0, help_message=\"How many frames of every second of the video will be extracted. 0 - full fps\")\n\n    if output_ext is None:\n        output_ext = io.input_str (\"Output image format\", \"png\", [\"png\",\"jpg\"], help_message=\"png is lossless, but extraction is x10 slower for HDD, requires x10 more disk space than jpg.\")\n\n    for filename in pathex.get_image_paths (output_path, ['.'+output_ext]):\n        Path(filename).unlink()\n\n    job = ffmpeg.input(str(input_file_path))\n\n    kwargs = {'pix_fmt': 'rgb24'}\n    if fps != 0:\n        kwargs.update ({'r':str(fps)})\n\n    if output_ext == 'jpg':\n        kwargs.update ({'q:v':'2'}) #highest quality for jpg\n\n    job = job.output( str (output_path / ('%5d.'+output_ext)), **kwargs )\n\n    try:\n        job = job.run()\n    except:\n        io.log_err (\"ffmpeg fail, job commandline:\" + str(job.compile()) )\n\ndef cut_video ( input_file, from_time=None, to_time=None, audio_track_id=None, bitrate=None):\n    input_file_path = Path(input_file)\n    if input_file_path is None:\n        io.log_err(\"input_file not found.\")\n        return\n\n    output_file_path = input_file_path.parent / (input_file_path.stem + \"_cut\" + input_file_path.suffix)\n\n    if from_time is None:\n        from_time = io.input_str (\"From time\", \"00:00:00.000\")\n\n    if to_time is None:\n        to_time = io.input_str (\"To time\", \"00:00:00.000\")\n\n    if audio_track_id is None:\n        audio_track_id = io.input_int (\"Specify audio track id.\", 0)\n\n    if bitrate is None:\n        bitrate = max (1, io.input_int (\"Bitrate of output file in MB/s\", 25) )\n\n    kwargs = {\"c:v\": \"libx264\",\n              \"b:v\": \"%dM\" %(bitrate),\n              \"pix_fmt\": \"yuv420p\",\n             }\n\n    job = ffmpeg.input(str(input_file_path), ss=from_time, to=to_time)\n\n    job_v = job['v:0']\n    job_a = job['a:' + str(audio_track_id) + '?' ]\n\n    job = ffmpeg.output(job_v, job_a, str(output_file_path), **kwargs).overwrite_output()\n\n    try:\n        job = job.run()\n    except:\n        io.log_err (\"ffmpeg fail, job commandline:\" + str(job.compile()) )\n\ndef denoise_image_sequence( input_dir, ext=None, factor=None ):\n    input_path = Path(input_dir)\n\n    if not input_path.exists():\n        io.log_err(\"input_dir not found.\")\n        return\n\n    image_paths = [ Path(filepath) for filepath in pathex.get_image_paths(input_path) ]\n\n    # Check extension of all images\n    image_paths_suffix = None\n    for filepath in image_paths:\n        if image_paths_suffix is None:\n            image_paths_suffix = filepath.suffix\n        else:\n            if filepath.suffix != image_paths_suffix:\n                io.log_err(f\"All images in {input_path.name} should be with the same extension.\")\n                return\n\n    if factor is None:\n        factor = np.clip ( io.input_int (\"Denoise factor?\", 7, add_info=\"1-20\"), 1, 20 )\n\n    # Rename to temporary filenames\n    for i,filepath in io.progress_bar_generator( enumerate(image_paths), \"Renaming\", leave=False):\n        src = filepath\n        dst = filepath.parent / ( f'{i+1:06}_{filepath.name}' )\n        try:\n            src.rename (dst)\n        except:\n            io.log_error ('fail to rename %s' % (src.name) )\n            return\n\n    # Rename to sequental filenames\n    for i,filepath in io.progress_bar_generator( enumerate(image_paths), \"Renaming\", leave=False):\n\n        src = filepath.parent / ( f'{i+1:06}_{filepath.name}' )\n        dst = filepath.parent / ( f'{i+1:06}{filepath.suffix}' )\n        try:\n            src.rename (dst)\n        except:\n            io.log_error ('fail to rename %s' % (src.name) )\n            return\n\n    # Process image sequence in ffmpeg\n    kwargs = {}\n    if image_paths_suffix == '.jpg':\n        kwargs.update ({'q:v':'2'})\n\n    job = ( ffmpeg\n            .input(str ( input_path / ('%6d'+image_paths_suffix) ) )\n            .filter(\"hqdn3d\", factor, factor, 5,5)\n            .output(str ( input_path / ('%6d'+image_paths_suffix) ), **kwargs )\n           )\n\n    try:\n        job = job.run()\n    except:\n        io.log_err (\"ffmpeg fail, job commandline:\" + str(job.compile()) )\n\n    # Rename to temporary filenames\n    for i,filepath in io.progress_bar_generator( enumerate(image_paths), \"Renaming\", leave=False):\n        src = filepath.parent / ( f'{i+1:06}{filepath.suffix}' )\n        dst = filepath.parent / ( f'{i+1:06}_{filepath.name}' )\n        try:\n            src.rename (dst)\n        except:\n            io.log_error ('fail to rename %s' % (src.name) )\n            return\n\n    # Rename to initial filenames\n    for i,filepath in io.progress_bar_generator( enumerate(image_paths), \"Renaming\", leave=False):\n        src = filepath.parent / ( f'{i+1:06}_{filepath.name}' )\n        dst = filepath\n\n        try:\n            src.rename (dst)\n        except:\n            io.log_error ('fail to rename %s' % (src.name) )\n            return\n\ndef video_from_sequence( input_dir, output_file, reference_file=None, ext=None, fps=None, bitrate=None, include_audio=False, lossless=None ):\n    input_path = Path(input_dir)\n    output_file_path = Path(output_file)\n    reference_file_path = Path(reference_file) if reference_file is not None else None\n\n    if not input_path.exists():\n        io.log_err(\"input_dir not found.\")\n        return\n\n    if not output_file_path.parent.exists():\n        output_file_path.parent.mkdir(parents=True, exist_ok=True)\n        return\n\n    out_ext = output_file_path.suffix\n\n    if ext is None:\n        ext = io.input_str (\"Input image format (extension)\", \"png\")\n\n    if lossless is None:\n        lossless = io.input_bool (\"Use lossless codec\", False)\n\n    video_id = None\n    audio_id = None\n    ref_in_a = None\n    if reference_file_path is not None:\n        if reference_file_path.suffix == '.*':\n            reference_file_path = pathex.get_first_file_by_stem (reference_file_path.parent, reference_file_path.stem)\n        else:\n            if not reference_file_path.exists():\n                reference_file_path = None\n\n        if reference_file_path is None:\n            io.log_err(\"reference_file not found.\")\n            return\n\n        #probing reference file\n        probe = ffmpeg.probe (str(reference_file_path))\n\n        #getting first video and audio streams id with fps\n        for stream in probe['streams']:\n            if video_id is None and stream['codec_type'] == 'video':\n                video_id = stream['index']\n                fps = stream['r_frame_rate']\n\n            if audio_id is None and stream['codec_type'] == 'audio':\n                audio_id = stream['index']\n\n        if audio_id is not None:\n            #has audio track\n            ref_in_a = ffmpeg.input (str(reference_file_path))[str(audio_id)]\n\n    if fps is None:\n        #if fps not specified and not overwritten by reference-file\n        fps = max (1, io.input_int (\"Enter FPS\", 25) )\n\n    if not lossless and bitrate is None:\n        bitrate = max (1, io.input_int (\"Bitrate of output file in MB/s\", 16) )\n\n    input_image_paths = pathex.get_image_paths(input_path)\n\n    i_in = ffmpeg.input('pipe:', format='image2pipe', r=fps)\n\n    output_args = [i_in]\n\n    if include_audio and ref_in_a is not None:\n        output_args += [ref_in_a]\n\n    output_args += [str (output_file_path)]\n\n    output_kwargs = {}\n\n    if lossless:\n        output_kwargs.update ({\"c:v\": \"libx264\",\n                               \"crf\": \"0\",\n                               \"pix_fmt\": \"yuv420p\",\n                              })\n    else:\n        output_kwargs.update ({\"c:v\": \"libx264\",\n                               \"b:v\": \"%dM\" %(bitrate),\n                               \"pix_fmt\": \"yuv420p\",\n                              })\n\n    if include_audio and ref_in_a is not None:\n        output_kwargs.update ({\"c:a\": \"aac\",\n                               \"b:a\": \"192k\",\n                               \"ar\" : \"48000\",\n                               \"strict\": \"experimental\"\n                               })\n\n    job = ( ffmpeg.output(*output_args, **output_kwargs).overwrite_output() )\n\n    try:\n        job_run = job.run_async(pipe_stdin=True)\n\n        for image_path in input_image_paths:\n            with open (image_path, \"rb\") as f:\n                image_bytes = f.read()\n                job_run.stdin.write (image_bytes)\n\n        job_run.stdin.close()\n        job_run.wait()\n    except:\n        io.log_err (\"ffmpeg fail, job commandline:\" + str(job.compile()) )\n", "mainscripts/FacesetResizer.py": "import multiprocessing\nimport shutil\n\nimport cv2\nfrom core import pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor\nfrom DFLIMG import *\nfrom facelib import FaceType, LandmarksProcessor\n\n\nclass FacesetResizerSubprocessor(Subprocessor):\n\n    #override\n    def __init__(self, image_paths, output_dirpath, image_size, face_type=None):\n        self.image_paths = image_paths\n        self.output_dirpath = output_dirpath\n        self.image_size = image_size\n        self.face_type = face_type\n        self.result = []\n\n        super().__init__('FacesetResizer', FacesetResizerSubprocessor.Cli, 600)\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (None, len (self.image_paths))\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def process_info_generator(self):\n        base_dict = {'output_dirpath':self.output_dirpath, 'image_size':self.image_size, 'face_type':self.face_type}\n\n        for device_idx in range( min(8, multiprocessing.cpu_count()) ):\n            client_dict = base_dict.copy()\n            device_name = f'CPU #{device_idx}'\n            client_dict['device_name'] = device_name\n            yield device_name, {}, client_dict\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.image_paths) > 0:\n            return self.image_paths.pop(0)\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.image_paths.insert(0, data)\n\n    #override\n    def on_result (self, host_dict, data, result):\n        io.progress_bar_inc(1)\n        if result[0] == 1:\n            self.result +=[ (result[1], result[2]) ]\n\n    #override\n    def get_result(self):\n        return self.result\n\n    class Cli(Subprocessor.Cli):\n\n        #override\n        def on_initialize(self, client_dict):\n            self.output_dirpath = client_dict['output_dirpath']\n            self.image_size = client_dict['image_size']\n            self.face_type = client_dict['face_type']\n            self.log_info (f\"Running on { client_dict['device_name'] }\")\n\n        #override\n        def process_data(self, filepath):\n            try:\n                dflimg = DFLIMG.load (filepath)\n                if dflimg is None or not dflimg.has_data():\n                    self.log_err (f\"{filepath.name} is not a dfl image file\")\n                else:\n                    img = cv2_imread(filepath)\n                    h,w = img.shape[:2]\n                    if h != w:\n                        raise Exception(f'w != h in {filepath}')\n                    \n                    image_size = self.image_size\n                    face_type = self.face_type\n                    output_filepath = self.output_dirpath / filepath.name\n                    \n                    if face_type is not None:\n                        lmrks = dflimg.get_landmarks()\n                        mat = LandmarksProcessor.get_transform_mat(lmrks, image_size, face_type)\n                        \n                        img = cv2.warpAffine(img, mat, (image_size, image_size), flags=cv2.INTER_LANCZOS4 )\n                        img = np.clip(img, 0, 255).astype(np.uint8)\n                        \n                        cv2_imwrite ( str(output_filepath), img, [int(cv2.IMWRITE_JPEG_QUALITY), 100] )\n\n                        dfl_dict = dflimg.get_dict()\n                        dflimg = DFLIMG.load (output_filepath)\n                        dflimg.set_dict(dfl_dict)\n                        \n                        xseg_mask = dflimg.get_xseg_mask()\n                        if xseg_mask is not None:\n                            xseg_res = 256\n                            \n                            xseg_lmrks = lmrks.copy()\n                            xseg_lmrks *= (xseg_res / w)\n                            xseg_mat = LandmarksProcessor.get_transform_mat(xseg_lmrks, xseg_res, face_type)\n                            \n                            xseg_mask = cv2.warpAffine(xseg_mask, xseg_mat, (xseg_res, xseg_res), flags=cv2.INTER_LANCZOS4 )\n                            xseg_mask[xseg_mask < 0.5] = 0\n                            xseg_mask[xseg_mask >= 0.5] = 1\n\n                            dflimg.set_xseg_mask(xseg_mask)\n                        \n                        seg_ie_polys = dflimg.get_seg_ie_polys()\n                        \n                        for poly in seg_ie_polys.get_polys():\n                            poly_pts = poly.get_pts()\n                            poly_pts = LandmarksProcessor.transform_points(poly_pts, mat)\n                            poly.set_points(poly_pts)\n                            \n                        dflimg.set_seg_ie_polys(seg_ie_polys)\n                        \n                        lmrks = LandmarksProcessor.transform_points(lmrks, mat)\n                        dflimg.set_landmarks(lmrks)\n    \n                        image_to_face_mat = dflimg.get_image_to_face_mat()\n                        if image_to_face_mat is not None:\n                            image_to_face_mat = LandmarksProcessor.get_transform_mat ( dflimg.get_source_landmarks(), image_size, face_type )\n                            dflimg.set_image_to_face_mat(image_to_face_mat)\n                        dflimg.set_face_type( FaceType.toString(face_type) )\n                        dflimg.save()\n                        \n                    else:\n                        dfl_dict = dflimg.get_dict()\n                         \n                        scale = w / image_size\n                        \n                        img = cv2.resize(img, (image_size, image_size), interpolation=cv2.INTER_LANCZOS4)                    \n                        \n                        cv2_imwrite ( str(output_filepath), img, [int(cv2.IMWRITE_JPEG_QUALITY), 100] )\n\n                        dflimg = DFLIMG.load (output_filepath)\n                        dflimg.set_dict(dfl_dict)\n                        \n                        lmrks = dflimg.get_landmarks()                    \n                        lmrks /= scale\n                        dflimg.set_landmarks(lmrks)\n                        \n                        seg_ie_polys = dflimg.get_seg_ie_polys()\n                        seg_ie_polys.mult_points( 1.0 / scale)\n                        dflimg.set_seg_ie_polys(seg_ie_polys)\n                        \n                        image_to_face_mat = dflimg.get_image_to_face_mat()\n    \n                        if image_to_face_mat is not None:\n                            face_type = FaceType.fromString ( dflimg.get_face_type() )\n                            image_to_face_mat = LandmarksProcessor.get_transform_mat ( dflimg.get_source_landmarks(), image_size, face_type )\n                            dflimg.set_image_to_face_mat(image_to_face_mat)\n                        dflimg.save()\n\n                    return (1, filepath, output_filepath)\n            except:\n                self.log_err (f\"Exception occured while processing file {filepath}. Error: {traceback.format_exc()}\")\n\n            return (0, filepath, None)\n\ndef process_folder ( dirpath):\n    \n    image_size = io.input_int(f\"New image size\", 512, valid_range=[128,2048])\n    \n    face_type = io.input_str (\"Change face type\", 'same', ['h','mf','f','wf','head','same']).lower()\n    if face_type == 'same':\n        face_type = None\n    else:\n        face_type = {'h'  : FaceType.HALF,\n                     'mf' : FaceType.MID_FULL,\n                     'f'  : FaceType.FULL,\n                     'wf' : FaceType.WHOLE_FACE,\n                     'head' : FaceType.HEAD}[face_type]\n                     \n\n    output_dirpath = dirpath.parent / (dirpath.name + '_resized')\n    output_dirpath.mkdir (exist_ok=True, parents=True)\n\n    dirpath_parts = '/'.join( dirpath.parts[-2:])\n    output_dirpath_parts = '/'.join( output_dirpath.parts[-2:] )\n    io.log_info (f\"Resizing faceset in {dirpath_parts}\")\n    io.log_info ( f\"Processing to {output_dirpath_parts}\")\n\n    output_images_paths = pathex.get_image_paths(output_dirpath)\n    if len(output_images_paths) > 0:\n        for filename in output_images_paths:\n            Path(filename).unlink()\n\n    image_paths = [Path(x) for x in pathex.get_image_paths( dirpath )]\n    result = FacesetResizerSubprocessor ( image_paths, output_dirpath, image_size, face_type).run()\n\n    is_merge = io.input_bool (f\"\\r\\nMerge {output_dirpath_parts} to {dirpath_parts} ?\", True)\n    if is_merge:\n        io.log_info (f\"Copying processed files to {dirpath_parts}\")\n\n        for (filepath, output_filepath) in result:\n            try:\n                shutil.copy (output_filepath, filepath)\n            except:\n                pass\n\n        io.log_info (f\"Removing {output_dirpath_parts}\")\n        shutil.rmtree(output_dirpath)\n", "mainscripts/ExportDFM.py": "import os\nimport sys\nimport traceback\nimport queue\nimport threading\nimport time\nimport numpy as np\nimport itertools\nfrom pathlib import Path\nfrom core import pathex\nfrom core import imagelib\nimport cv2\nimport models\nfrom core.interact import interact as io\n\n\ndef main(model_class_name, saved_models_path):\n    model = models.import_model(model_class_name)(\n                        is_exporting=True,\n                        saved_models_path=saved_models_path,\n                        cpu_only=True)\n    model.export_dfm () \n", "mainscripts/XSegUtil.py": "import json\nimport shutil\nimport traceback\nfrom pathlib import Path\n\nimport numpy as np\n\nfrom core import pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.leras import nn\nfrom DFLIMG import *\nfrom facelib import XSegNet, LandmarksProcessor, FaceType\nimport pickle\n\ndef apply_xseg(input_path, model_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n\n    if not model_path.exists():\n        raise ValueError(f'{model_path} not found. Please ensure it exists.')\n        \n    face_type = None\n    \n    model_dat = model_path / 'XSeg_data.dat'\n    if model_dat.exists():\n        dat = pickle.loads( model_dat.read_bytes() )\n        dat_options = dat.get('options', None)\n        if dat_options is not None:\n            face_type = dat_options.get('face_type', None)\n        \n        \n        \n    if face_type is None:\n        face_type = io.input_str (\"XSeg model face type\", 'same', ['h','mf','f','wf','head','same'], help_message=\"Specify face type of trained XSeg model. For example if XSeg model trained as WF, but faceset is HEAD, specify WF to apply xseg only on WF part of HEAD. Default is 'same'\").lower()\n        if face_type == 'same':\n            face_type = None\n    \n    if face_type is not None:\n        face_type = {'h'  : FaceType.HALF,\n                     'mf' : FaceType.MID_FULL,\n                     'f'  : FaceType.FULL,\n                     'wf' : FaceType.WHOLE_FACE,\n                     'head' : FaceType.HEAD}[face_type]\n                     \n    io.log_info(f'Applying trained XSeg model to {input_path.name}/ folder.')\n\n    device_config = nn.DeviceConfig.ask_choose_device(choose_only_one=True)\n    nn.initialize(device_config)\n        \n    \n    \n    xseg = XSegNet(name='XSeg', \n                    load_weights=True,\n                    weights_file_root=model_path,\n                    data_format=nn.data_format,\n                    raise_on_no_model_files=True)\n    xseg_res = xseg.get_resolution()\n              \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n        \n        img = cv2_imread(filepath).astype(np.float32) / 255.0\n        h,w,c = img.shape\n        \n        img_face_type = FaceType.fromString( dflimg.get_face_type() )\n        if face_type is not None and img_face_type != face_type:\n            lmrks = dflimg.get_source_landmarks()\n            \n            fmat = LandmarksProcessor.get_transform_mat(lmrks, w, face_type)\n            imat = LandmarksProcessor.get_transform_mat(lmrks, w, img_face_type)\n            \n            g_p = LandmarksProcessor.transform_points (np.float32([(0,0),(w,0),(0,w) ]), fmat, True)\n            g_p2 = LandmarksProcessor.transform_points (g_p, imat)\n            \n            mat = cv2.getAffineTransform( g_p2, np.float32([(0,0),(w,0),(0,w) ]) )\n            \n            img = cv2.warpAffine(img, mat, (w, w), cv2.INTER_LANCZOS4)\n            img = cv2.resize(img, (xseg_res, xseg_res), interpolation=cv2.INTER_LANCZOS4)\n        else:\n            if w != xseg_res:\n                img = cv2.resize( img, (xseg_res,xseg_res), interpolation=cv2.INTER_LANCZOS4 )    \n                    \n        if len(img.shape) == 2:\n            img = img[...,None]            \n    \n        mask = xseg.extract(img)\n        \n        if face_type is not None and img_face_type != face_type:\n            mask = cv2.resize(mask, (w, w), interpolation=cv2.INTER_LANCZOS4)\n            mask = cv2.warpAffine( mask, mat, (w,w), np.zeros( (h,w,c), dtype=np.float), cv2.WARP_INVERSE_MAP | cv2.INTER_LANCZOS4)\n            mask = cv2.resize(mask, (xseg_res, xseg_res), interpolation=cv2.INTER_LANCZOS4)\n        mask[mask < 0.5]=0\n        mask[mask >= 0.5]=1    \n        dflimg.set_xseg_mask(mask)\n        dflimg.save()\n\n\n        \ndef fetch_xseg(input_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n    \n    output_path = input_path.parent / (input_path.name + '_xseg')\n    output_path.mkdir(exist_ok=True, parents=True)\n    \n    io.log_info(f'Copying faces containing XSeg polygons to {output_path.name}/ folder.')\n    \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    \n    files_copied = []\n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n        \n        ie_polys = dflimg.get_seg_ie_polys()\n\n        if ie_polys.has_polys():\n            files_copied.append(filepath)\n            shutil.copy ( str(filepath), str(output_path / filepath.name) )\n    \n    io.log_info(f'Files copied: {len(files_copied)}')\n    \n    is_delete = io.input_bool (f\"\\r\\nDelete original files?\", True)\n    if is_delete:\n        for filepath in files_copied:\n            Path(filepath).unlink()\n            \n    \ndef remove_xseg(input_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n    \n    io.log_info(f'Processing folder {input_path}')\n    io.log_info('!!! WARNING : APPLIED XSEG MASKS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : APPLIED XSEG MASKS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : APPLIED XSEG MASKS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.input_str('Press enter to continue.')\n                               \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    files_processed = 0\n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n        \n        if dflimg.has_xseg_mask():\n            dflimg.set_xseg_mask(None)\n            dflimg.save()\n            files_processed += 1\n    io.log_info(f'Files processed: {files_processed}')\n    \ndef remove_xseg_labels(input_path):\n    if not input_path.exists():\n        raise ValueError(f'{input_path} not found. Please ensure it exists.')\n    \n    io.log_info(f'Processing folder {input_path}')\n    io.log_info('!!! WARNING : LABELED XSEG POLYGONS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : LABELED XSEG POLYGONS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.log_info('!!! WARNING : LABELED XSEG POLYGONS WILL BE REMOVED FROM THE FRAMES !!!')\n    io.input_str('Press enter to continue.')\n    \n    images_paths = pathex.get_image_paths(input_path, return_Path_class=True)\n    \n    files_processed = 0\n    for filepath in io.progress_bar_generator(images_paths, \"Processing\"):\n        dflimg = DFLIMG.load(filepath)\n        if dflimg is None or not dflimg.has_data():\n            io.log_info(f'{filepath} is not a DFLIMG')\n            continue\n\n        if dflimg.has_seg_ie_polys():\n            dflimg.set_seg_ie_polys(None)\n            dflimg.save()            \n            files_processed += 1\n            \n    io.log_info(f'Files processed: {files_processed}')", "mainscripts/Merger.py": "\ufeffimport math\nimport multiprocessing\nimport traceback\nfrom pathlib import Path\n\nimport numpy as np\nimport numpy.linalg as npla\n\nimport samplelib\nfrom core import pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.joblib import MPClassFuncOnDemand, MPFunc\nfrom core.leras import nn\nfrom DFLIMG import DFLIMG\nfrom facelib import FaceEnhancer, FaceType, LandmarksProcessor, XSegNet\nfrom merger import FrameInfo, InteractiveMergerSubprocessor, MergerConfig\n\n\ndef main (model_class_name=None,\n          saved_models_path=None,\n          training_data_src_path=None,\n          force_model_name=None,\n          input_path=None,\n          output_path=None,\n          output_mask_path=None,\n          aligned_path=None,\n          force_gpu_idxs=None,\n          cpu_only=None):\n    io.log_info (\"Running merger.\\r\\n\")\n\n    try:\n        if not input_path.exists():\n            io.log_err('Input directory not found. Please ensure it exists.')\n            return\n\n        if not output_path.exists():\n            output_path.mkdir(parents=True, exist_ok=True)\n\n        if not output_mask_path.exists():\n            output_mask_path.mkdir(parents=True, exist_ok=True)\n\n        if not saved_models_path.exists():\n            io.log_err('Model directory not found. Please ensure it exists.')\n            return\n\n        # Initialize model\n        import models\n        model = models.import_model(model_class_name)(is_training=False,\n                                                      saved_models_path=saved_models_path,\n                                                      force_gpu_idxs=force_gpu_idxs,\n                                                      force_model_name=force_model_name,\n                                                      cpu_only=cpu_only)\n\n        predictor_func, predictor_input_shape, cfg = model.get_MergerConfig()\n\n        # Preparing MP functions\n        predictor_func = MPFunc(predictor_func)\n\n        run_on_cpu = len(nn.getCurrentDeviceConfig().devices) == 0\n        xseg_256_extract_func = MPClassFuncOnDemand(XSegNet, 'extract',\n                                                    name='XSeg',\n                                                    resolution=256,\n                                                    weights_file_root=saved_models_path,\n                                                    place_model_on_cpu=True,\n                                                    run_on_cpu=run_on_cpu)\n\n        face_enhancer_func = MPClassFuncOnDemand(FaceEnhancer, 'enhance',\n                                                    place_model_on_cpu=True,\n                                                    run_on_cpu=run_on_cpu)\n\n        is_interactive = io.input_bool (\"Use interactive merger?\", True) if not io.is_colab() else False\n\n        if not is_interactive:\n            cfg.ask_settings()\n            \n        subprocess_count = io.input_int(\"Number of workers?\", max(8, multiprocessing.cpu_count()), \n                                        valid_range=[1, multiprocessing.cpu_count()], help_message=\"Specify the number of threads to process. A low value may affect performance. A high value may result in memory error. The value may not be greater than CPU cores.\" )\n\n        input_path_image_paths = pathex.get_image_paths(input_path)\n\n        if cfg.type == MergerConfig.TYPE_MASKED:\n            if not aligned_path.exists():\n                io.log_err('Aligned directory not found. Please ensure it exists.')\n                return\n\n            packed_samples = None\n            try:\n                packed_samples = samplelib.PackedFaceset.load(aligned_path)\n            except:\n                io.log_err(f\"Error occured while loading samplelib.PackedFaceset.load {str(aligned_path)}, {traceback.format_exc()}\")\n\n\n            if packed_samples is not None:\n                io.log_info (\"Using packed faceset.\")\n                def generator():\n                    for sample in io.progress_bar_generator( packed_samples, \"Collecting alignments\"):\n                        filepath = Path(sample.filename)\n                        yield filepath, DFLIMG.load(filepath, loader_func=lambda x: sample.read_raw_file()  )\n            else:\n                def generator():\n                    for filepath in io.progress_bar_generator( pathex.get_image_paths(aligned_path), \"Collecting alignments\"):\n                        filepath = Path(filepath)\n                        yield filepath, DFLIMG.load(filepath)\n\n            alignments = {}\n            multiple_faces_detected = False\n\n            for filepath, dflimg in generator():\n                if dflimg is None or not dflimg.has_data():\n                    io.log_err (f\"{filepath.name} is not a dfl image file\")\n                    continue\n\n                source_filename = dflimg.get_source_filename()\n                if source_filename is None:\n                    continue\n\n                source_filepath = Path(source_filename)\n                source_filename_stem = source_filepath.stem\n\n                if source_filename_stem not in alignments.keys():\n                    alignments[ source_filename_stem ] = []\n\n                alignments_ar = alignments[ source_filename_stem ]\n                alignments_ar.append ( (dflimg.get_source_landmarks(), filepath, source_filepath ) )\n\n                if len(alignments_ar) > 1:\n                    multiple_faces_detected = True\n\n            if multiple_faces_detected:\n                io.log_info (\"\")\n                io.log_info (\"Warning: multiple faces detected. Only one alignment file should refer one source file.\")\n                io.log_info (\"\")\n\n            for a_key in list(alignments.keys()):\n                a_ar = alignments[a_key]\n                if len(a_ar) > 1:\n                    for _, filepath, source_filepath in a_ar:\n                        io.log_info (f\"alignment {filepath.name} refers to {source_filepath.name} \")\n                    io.log_info (\"\")\n\n                alignments[a_key] = [ a[0] for a in a_ar]\n\n            if multiple_faces_detected:\n                io.log_info (\"It is strongly recommended to process the faces separatelly.\")\n                io.log_info (\"Use 'recover original filename' to determine the exact duplicates.\")\n                io.log_info (\"\")\n\n            frames = [ InteractiveMergerSubprocessor.Frame( frame_info=FrameInfo(filepath=Path(p),\n                                                                     landmarks_list=alignments.get(Path(p).stem, None)\n                                                                    )\n                                              )\n                       for p in input_path_image_paths ]\n\n            if multiple_faces_detected:\n                io.log_info (\"Warning: multiple faces detected. Motion blur will not be used.\")\n                io.log_info (\"\")\n            else:\n                s = 256\n                local_pts = [ (s//2-1, s//2-1), (s//2-1,0) ] #center+up\n                frames_len = len(frames)\n                for i in io.progress_bar_generator( range(len(frames)) , \"Computing motion vectors\"):\n                    fi_prev = frames[max(0, i-1)].frame_info\n                    fi      = frames[i].frame_info\n                    fi_next = frames[min(i+1, frames_len-1)].frame_info\n                    if len(fi_prev.landmarks_list) == 0 or \\\n                       len(fi.landmarks_list) == 0 or \\\n                       len(fi_next.landmarks_list) == 0:\n                            continue\n\n                    mat_prev = LandmarksProcessor.get_transform_mat ( fi_prev.landmarks_list[0], s, face_type=FaceType.FULL)\n                    mat      = LandmarksProcessor.get_transform_mat ( fi.landmarks_list[0]     , s, face_type=FaceType.FULL)\n                    mat_next = LandmarksProcessor.get_transform_mat ( fi_next.landmarks_list[0], s, face_type=FaceType.FULL)\n\n                    pts_prev = LandmarksProcessor.transform_points (local_pts, mat_prev, True)\n                    pts      = LandmarksProcessor.transform_points (local_pts, mat, True)\n                    pts_next = LandmarksProcessor.transform_points (local_pts, mat_next, True)\n\n                    prev_vector = pts[0]-pts_prev[0]\n                    next_vector = pts_next[0]-pts[0]\n\n                    motion_vector = pts_next[0] - pts_prev[0]\n                    fi.motion_power = npla.norm(motion_vector)\n\n                    motion_vector = motion_vector / fi.motion_power if fi.motion_power != 0 else np.array([0,0],dtype=np.float32)\n\n                    fi.motion_deg = -math.atan2(motion_vector[1],motion_vector[0])*180 / math.pi\n\n\n        if len(frames) == 0:\n            io.log_info (\"No frames to merge in input_dir.\")\n        else:\n            if False:\n                pass\n            else:\n                InteractiveMergerSubprocessor (\n                            is_interactive         = is_interactive,\n                            merger_session_filepath = model.get_strpath_storage_for_file('merger_session.dat'),\n                            predictor_func         = predictor_func,\n                            predictor_input_shape  = predictor_input_shape,\n                            face_enhancer_func     = face_enhancer_func,\n                            xseg_256_extract_func = xseg_256_extract_func,\n                            merger_config          = cfg,\n                            frames                 = frames,\n                            frames_root_path       = input_path,\n                            output_path            = output_path,\n                            output_mask_path       = output_mask_path,\n                            model_iter             = model.get_iter(),\n                            subprocess_count       = subprocess_count,\n                        ).run()\n\n        model.finalize()\n\n    except Exception as e:\n        print ( traceback.format_exc() )\n\n\n\"\"\"\nelif cfg.type == MergerConfig.TYPE_FACE_AVATAR:\nfilesdata = []\nfor filepath in io.progress_bar_generator(input_path_image_paths, \"Collecting info\"):\n    filepath = Path(filepath)\n\n    dflimg = DFLIMG.x(filepath)\n    if dflimg is None:\n        io.log_err (\"%s is not a dfl image file\" % (filepath.name) )\n        continue\n    filesdata += [ ( FrameInfo(filepath=filepath, landmarks_list=[dflimg.get_landmarks()] ), dflimg.get_source_filename() ) ]\n\nfilesdata = sorted(filesdata, key=operator.itemgetter(1)) #sort by source_filename\nframes = []\nfilesdata_len = len(filesdata)\nfor i in range(len(filesdata)):\n    frame_info = filesdata[i][0]\n\n    prev_temporal_frame_infos = []\n    next_temporal_frame_infos = []\n\n    for t in range (cfg.temporal_face_count):\n        prev_frame_info = filesdata[ max(i -t, 0) ][0]\n        next_frame_info = filesdata[ min(i +t, filesdata_len-1 )][0]\n\n        prev_temporal_frame_infos.insert (0, prev_frame_info )\n        next_temporal_frame_infos.append (   next_frame_info )\n\n    frames.append ( InteractiveMergerSubprocessor.Frame(prev_temporal_frame_infos=prev_temporal_frame_infos,\n                                                frame_info=frame_info,\n                                                next_temporal_frame_infos=next_temporal_frame_infos) )\n\"\"\"\n\n#interpolate landmarks\n#from facelib import LandmarksProcessor\n#from facelib import FaceType\n#a = sorted(alignments.keys())\n#a_len = len(a)\n#\n#box_pts = 3\n#box = np.ones(box_pts)/box_pts\n#for i in range( a_len ):\n#    if i >= box_pts and i <= a_len-box_pts-1:\n#        af0 = alignments[ a[i] ][0] ##first face\n#        m0 = LandmarksProcessor.get_transform_mat (af0, 256, face_type=FaceType.FULL)\n#\n#        points = []\n#\n#        for j in range(-box_pts, box_pts+1):\n#            af = alignments[ a[i+j] ][0] ##first face\n#            m = LandmarksProcessor.get_transform_mat (af, 256, face_type=FaceType.FULL)\n#            p = LandmarksProcessor.transform_points (af, m)\n#            points.append (p)\n#\n#        points = np.array(points)\n#        points_len = len(points)\n#        t_points = np.transpose(points, [1,0,2])\n#\n#        p1 = np.array ( [ int(np.convolve(x[:,0], box, mode='same')[points_len//2]) for x in t_points ] )\n#        p2 = np.array ( [ int(np.convolve(x[:,1], box, mode='same')[points_len//2]) for x in t_points ] )\n#\n#        new_points = np.concatenate( [np.expand_dims(p1,-1),np.expand_dims(p2,-1)], -1 )\n#\n#        alignments[ a[i] ][0]  = LandmarksProcessor.transform_points (new_points, m0, True).astype(np.int32)\n", "mainscripts/Extractor.py": "\ufeffimport traceback\nimport math\nimport multiprocessing\nimport operator\nimport os\nimport shutil\nimport sys\nimport time\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\nfrom numpy import linalg as npla\n\nimport facelib\nfrom core import imagelib\nfrom core import mathlib\nfrom facelib import FaceType, LandmarksProcessor\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor\nfrom core.leras import nn\nfrom core import pathex\nfrom core.cv2ex import *\nfrom DFLIMG import *\n\nDEBUG = False\n\nclass ExtractSubprocessor(Subprocessor):\n    class Data(object):\n        def __init__(self, filepath=None, rects=None, landmarks = None, landmarks_accurate=True, manual=False, force_output_path=None, final_output_files = None):\n            self.filepath = filepath\n            self.rects = rects or []\n            self.rects_rotation = 0\n            self.landmarks_accurate = landmarks_accurate\n            self.manual = manual\n            self.landmarks = landmarks or []\n            self.force_output_path = force_output_path\n            self.final_output_files = final_output_files or []\n            self.faces_detected = 0\n\n    class Cli(Subprocessor.Cli):\n\n        #override\n        def on_initialize(self, client_dict):\n            self.type                 = client_dict['type']\n            self.image_size           = client_dict['image_size']\n            self.jpeg_quality         = client_dict['jpeg_quality']\n            self.face_type            = client_dict['face_type']\n            self.max_faces_from_image = client_dict['max_faces_from_image']\n            self.device_idx           = client_dict['device_idx']\n            self.cpu_only             = client_dict['device_type'] == 'CPU'\n            self.final_output_path    = client_dict['final_output_path']\n            self.output_debug_path    = client_dict['output_debug_path']\n\n            #transfer and set stdin in order to work code.interact in debug subprocess\n            stdin_fd         = client_dict['stdin_fd']\n            if stdin_fd is not None and DEBUG:\n                sys.stdin = os.fdopen(stdin_fd)\n\n            if self.cpu_only:\n                device_config = nn.DeviceConfig.CPU()\n                place_model_on_cpu = True\n            else:\n                device_config = nn.DeviceConfig.GPUIndexes ([self.device_idx])\n                place_model_on_cpu = device_config.devices[0].total_mem_gb < 4\n\n            if self.type == 'all' or 'rects' in self.type or 'landmarks' in self.type:\n                nn.initialize (device_config)\n\n            self.log_info (f\"Running on {client_dict['device_name'] }\")\n\n            if self.type == 'all' or self.type == 'rects-s3fd' or 'landmarks' in self.type:\n                self.rects_extractor = facelib.S3FDExtractor(place_model_on_cpu=place_model_on_cpu)\n\n            if self.type == 'all' or 'landmarks' in self.type:\n                # for head type, extract \"3D landmarks\"\n                self.landmarks_extractor = facelib.FANExtractor(landmarks_3D=self.face_type >= FaceType.HEAD,\n                                                                place_model_on_cpu=place_model_on_cpu)\n\n            self.cached_image = (None, None)\n\n        #override\n        def process_data(self, data):\n            if 'landmarks' in self.type and len(data.rects) == 0:\n                return data\n\n            filepath = data.filepath\n            cached_filepath, image = self.cached_image\n            if cached_filepath != filepath:\n                image = cv2_imread( filepath )\n                if image is None:\n                    self.log_err (f'Failed to open {filepath}, reason: cv2_imread() fail.')\n                    return data\n                image = imagelib.normalize_channels(image, 3)\n                image = imagelib.cut_odd_image(image)\n                self.cached_image = ( filepath, image )\n\n            h, w, c = image.shape\n\n            if 'rects' in self.type or self.type == 'all':\n                data = ExtractSubprocessor.Cli.rects_stage (data=data,\n                                                            image=image,\n                                                            max_faces_from_image=self.max_faces_from_image,\n                                                            rects_extractor=self.rects_extractor,\n                                                            )\n\n            if 'landmarks' in self.type or self.type == 'all':\n                data = ExtractSubprocessor.Cli.landmarks_stage (data=data,\n                                                                image=image,\n                                                                landmarks_extractor=self.landmarks_extractor,\n                                                                rects_extractor=self.rects_extractor,\n                                                                )\n\n            if self.type == 'final' or self.type == 'all':\n                data = ExtractSubprocessor.Cli.final_stage(data=data,\n                                                           image=image,\n                                                           face_type=self.face_type,\n                                                           image_size=self.image_size,\n                                                           jpeg_quality=self.jpeg_quality,\n                                                           output_debug_path=self.output_debug_path,\n                                                           final_output_path=self.final_output_path,\n                                                           )\n            return data\n\n        @staticmethod\n        def rects_stage(data,\n                        image,\n                        max_faces_from_image,\n                        rects_extractor,\n                        ):\n            h,w,c = image.shape\n            if min(h,w) < 128:\n                # Image is too small\n                data.rects = []\n            else:\n                for rot in ([0, 90, 270, 180]):\n                    if rot == 0:\n                        rotated_image = image\n                    elif rot == 90:\n                        rotated_image = image.swapaxes( 0,1 )[:,::-1,:]\n                    elif rot == 180:\n                        rotated_image = image[::-1,::-1,:]\n                    elif rot == 270:\n                        rotated_image = image.swapaxes( 0,1 )[::-1,:,:]\n                    rects = data.rects = rects_extractor.extract (rotated_image, is_bgr=True)\n                    if len(rects) != 0:\n                        data.rects_rotation = rot\n                        break\n                if max_faces_from_image is not None and \\\n                   max_faces_from_image > 0 and \\\n                   len(data.rects) > 0:\n                    data.rects = data.rects[0:max_faces_from_image]\n            return data\n\n\n        @staticmethod\n        def landmarks_stage(data,\n                            image,\n                            landmarks_extractor,\n                            rects_extractor,\n                            ):\n            h, w, ch = image.shape\n\n            if data.rects_rotation == 0:\n                rotated_image = image\n            elif data.rects_rotation == 90:\n                rotated_image = image.swapaxes( 0,1 )[:,::-1,:]\n            elif data.rects_rotation == 180:\n                rotated_image = image[::-1,::-1,:]\n            elif data.rects_rotation == 270:\n                rotated_image = image.swapaxes( 0,1 )[::-1,:,:]\n\n            data.landmarks = landmarks_extractor.extract (rotated_image, data.rects, rects_extractor if (data.landmarks_accurate) else None, is_bgr=True)\n            if data.rects_rotation != 0:\n                for i, (rect, lmrks) in enumerate(zip(data.rects, data.landmarks)):\n                    new_rect, new_lmrks = rect, lmrks\n                    (l,t,r,b) = rect\n                    if data.rects_rotation == 90:\n                        new_rect = ( t, h-l, b, h-r)\n                        if lmrks is not None:\n                            new_lmrks = lmrks[:,::-1].copy()\n                            new_lmrks[:,1] = h - new_lmrks[:,1]\n                    elif data.rects_rotation == 180:\n                        if lmrks is not None:\n                            new_rect = ( w-l, h-t, w-r, h-b)\n                            new_lmrks = lmrks.copy()\n                            new_lmrks[:,0] = w - new_lmrks[:,0]\n                            new_lmrks[:,1] = h - new_lmrks[:,1]\n                    elif data.rects_rotation == 270:\n                        new_rect = ( w-b, l, w-t, r )\n                        if lmrks is not None:\n                            new_lmrks = lmrks[:,::-1].copy()\n                            new_lmrks[:,0] = w - new_lmrks[:,0]\n                    data.rects[i], data.landmarks[i] = new_rect, new_lmrks\n\n            return data\n\n        @staticmethod\n        def final_stage(data,\n                        image,\n                        face_type,\n                        image_size,\n                        jpeg_quality,\n                        output_debug_path=None,\n                        final_output_path=None,\n                        ):\n            data.final_output_files = []\n            filepath = data.filepath\n            rects = data.rects\n            landmarks = data.landmarks\n\n            if output_debug_path is not None:\n                debug_image = image.copy()\n\n            face_idx = 0\n            for rect, image_landmarks in zip( rects, landmarks ):\n                if image_landmarks is None:\n                    continue\n\n                rect = np.array(rect)\n\n                if face_type == FaceType.MARK_ONLY:\n                    image_to_face_mat = None\n                    face_image = image\n                    face_image_landmarks = image_landmarks\n                else:\n                    image_to_face_mat = LandmarksProcessor.get_transform_mat (image_landmarks, image_size, face_type)\n\n                    face_image = cv2.warpAffine(image, image_to_face_mat, (image_size, image_size), cv2.INTER_LANCZOS4)\n                    face_image_landmarks = LandmarksProcessor.transform_points (image_landmarks, image_to_face_mat)\n\n                    landmarks_bbox = LandmarksProcessor.transform_points ( [ (0,0), (0,image_size-1), (image_size-1, image_size-1), (image_size-1,0) ], image_to_face_mat, True)\n\n                    rect_area      = mathlib.polygon_area(np.array(rect[[0,2,2,0]]).astype(np.float32), np.array(rect[[1,1,3,3]]).astype(np.float32))\n                    landmarks_area = mathlib.polygon_area(landmarks_bbox[:,0].astype(np.float32), landmarks_bbox[:,1].astype(np.float32) )\n\n                    if not data.manual and face_type <= FaceType.FULL_NO_ALIGN and landmarks_area > 4*rect_area: #get rid of faces which umeyama-landmark-area > 4*detector-rect-area\n                        continue\n\n                    if output_debug_path is not None:\n                        LandmarksProcessor.draw_rect_landmarks (debug_image, rect, image_landmarks, face_type, image_size, transparent_mask=True)\n\n                output_path = final_output_path\n                if data.force_output_path is not None:\n                    output_path = data.force_output_path\n\n                output_filepath = output_path / f\"{filepath.stem}_{face_idx}.jpg\"\n                cv2_imwrite(output_filepath, face_image, [int(cv2.IMWRITE_JPEG_QUALITY), jpeg_quality ] )\n\n                dflimg = DFLJPG.load(output_filepath)\n                dflimg.set_face_type(FaceType.toString(face_type))\n                dflimg.set_landmarks(face_image_landmarks.tolist())\n                dflimg.set_source_filename(filepath.name)\n                dflimg.set_source_rect(rect)\n                dflimg.set_source_landmarks(image_landmarks.tolist())\n                dflimg.set_image_to_face_mat(image_to_face_mat)\n                dflimg.save()\n\n                data.final_output_files.append (output_filepath)\n                face_idx += 1\n            data.faces_detected = face_idx\n\n            if output_debug_path is not None:\n                cv2_imwrite( output_debug_path / (filepath.stem+'.jpg'), debug_image, [int(cv2.IMWRITE_JPEG_QUALITY), 50] )\n\n            return data\n\n        #overridable\n        def get_data_name (self, data):\n            #return string identificator of your data\n            return data.filepath\n\n    @staticmethod\n    def get_devices_for_config (type, device_config):\n        devices = device_config.devices\n        cpu_only = len(devices) == 0\n\n        if 'rects'     in type or \\\n           'landmarks' in type or \\\n           'all'       in type:\n\n            if not cpu_only:\n                if type == 'landmarks-manual':\n                    devices = [devices.get_best_device()]\n\n                result = []\n\n                for device in devices:\n                    count = 1\n\n                    if count == 1:\n                        result += [ (device.index, 'GPU', device.name, device.total_mem_gb) ]\n                    else:\n                        for i in range(count):\n                            result += [ (device.index, 'GPU', f\"{device.name} #{i}\", device.total_mem_gb) ]\n\n                return result\n            else:\n                if type == 'landmarks-manual':\n                    return [ (0, 'CPU', 'CPU', 0 ) ]\n                else:\n                    return [ (i, 'CPU', 'CPU%d' % (i), 0 ) for i in range( min(8, multiprocessing.cpu_count() // 2) ) ]\n\n        elif type == 'final':\n            return [ (i, 'CPU', 'CPU%d' % (i), 0 ) for i in (range(min(8, multiprocessing.cpu_count())) if not DEBUG else [0]) ]\n\n    def __init__(self, input_data, type, image_size=None, jpeg_quality=None, face_type=None, output_debug_path=None, manual_window_size=0, max_faces_from_image=0, final_output_path=None, device_config=None):\n        if type == 'landmarks-manual':\n            for x in input_data:\n                x.manual = True\n\n        self.input_data = input_data\n\n        self.type = type\n        self.image_size = image_size\n        self.jpeg_quality = jpeg_quality\n        self.face_type = face_type\n        self.output_debug_path = output_debug_path\n        self.final_output_path = final_output_path\n        self.manual_window_size = manual_window_size\n        self.max_faces_from_image = max_faces_from_image\n        self.result = []\n\n        self.devices = ExtractSubprocessor.get_devices_for_config(self.type, device_config)\n\n        super().__init__('Extractor', ExtractSubprocessor.Cli,\n                             999999 if type == 'landmarks-manual' or DEBUG else 120)\n\n    #override\n    def on_clients_initialized(self):\n        if self.type == 'landmarks-manual':\n            self.wnd_name = 'Manual pass'\n            io.named_window(self.wnd_name)\n            io.capture_mouse(self.wnd_name)\n            io.capture_keys(self.wnd_name)\n\n            self.cache_original_image = (None, None)\n            self.cache_image = (None, None)\n            self.cache_text_lines_img = (None, None)\n            self.hide_help = False\n            self.landmarks_accurate = True\n            self.force_landmarks = False\n\n            self.landmarks = None\n            self.x = 0\n            self.y = 0\n            self.rect_size = 100\n            self.rect_locked = False\n            self.extract_needed = True\n\n            self.image = None\n            self.image_filepath = None\n\n        io.progress_bar (None, len (self.input_data))\n\n    #override\n    def on_clients_finalized(self):\n        if self.type == 'landmarks-manual':\n            io.destroy_all_windows()\n\n        io.progress_bar_close()\n\n    #override\n    def process_info_generator(self):\n        base_dict = {'type' : self.type,\n                     'image_size': self.image_size,\n                     'jpeg_quality' : self.jpeg_quality,\n                     'face_type': self.face_type,\n                     'max_faces_from_image':self.max_faces_from_image,\n                     'output_debug_path': self.output_debug_path,\n                     'final_output_path': self.final_output_path,\n                     'stdin_fd': sys.stdin.fileno() }\n\n\n        for (device_idx, device_type, device_name, device_total_vram_gb) in self.devices:\n            client_dict = base_dict.copy()\n            client_dict['device_idx'] = device_idx\n            client_dict['device_name'] = device_name\n            client_dict['device_type'] = device_type\n            yield client_dict['device_name'], {}, client_dict\n\n    #override\n    def get_data(self, host_dict):\n        if self.type == 'landmarks-manual':\n            need_remark_face = False\n            while len (self.input_data) > 0:\n                data = self.input_data[0]\n                filepath, data_rects, data_landmarks = data.filepath, data.rects, data.landmarks\n                is_frame_done = False\n\n                if self.image_filepath != filepath:\n                    self.image_filepath = filepath\n                    if self.cache_original_image[0] == filepath:\n                        self.original_image = self.cache_original_image[1]\n                    else:\n                        self.original_image = imagelib.normalize_channels( cv2_imread( filepath ), 3 )\n\n                        self.cache_original_image = (filepath, self.original_image )\n\n                    (h,w,c) = self.original_image.shape\n                    self.view_scale = 1.0 if self.manual_window_size == 0 else self.manual_window_size / ( h * (16.0/9.0) )\n\n                    if self.cache_image[0] == (h,w,c) + (self.view_scale,filepath):\n                        self.image = self.cache_image[1]\n                    else:\n                        self.image = cv2.resize (self.original_image, ( int(w*self.view_scale), int(h*self.view_scale) ), interpolation=cv2.INTER_LINEAR)\n                        self.cache_image = ( (h,w,c) + (self.view_scale,filepath), self.image )\n\n                    (h,w,c) = self.image.shape\n\n                    sh = (0,0, w, min(100, h) )\n                    if self.cache_text_lines_img[0] == sh:\n                        self.text_lines_img = self.cache_text_lines_img[1]\n                    else:\n                        self.text_lines_img = (imagelib.get_draw_text_lines ( self.image, sh,\n                                                        [   '[L Mouse click] - lock/unlock selection. [Mouse wheel] - change rect',\n                                                            '[R Mouse Click] - manual face rectangle',\n                                                            '[Enter] / [Space] - confirm / skip frame',\n                                                            '[,] [.]- prev frame, next frame. [Q] - skip remaining frames',\n                                                            '[a] - accuracy on/off (more fps)',\n                                                            '[h] - hide this help'\n                                                        ], (1, 1, 1) )*255).astype(np.uint8)\n\n                        self.cache_text_lines_img = (sh, self.text_lines_img)\n\n                if need_remark_face: # need remark image from input data that already has a marked face?\n                    need_remark_face = False\n                    if len(data_rects) != 0: # If there was already a face then lock the rectangle to it until the mouse is clicked\n                        self.rect = data_rects.pop()\n                        self.landmarks = data_landmarks.pop()\n                        data_rects.clear()\n                        data_landmarks.clear()\n\n                        self.rect_locked = True\n                        self.rect_size = ( self.rect[2] - self.rect[0] ) / 2\n                        self.x = ( self.rect[0] + self.rect[2] ) / 2\n                        self.y = ( self.rect[1] + self.rect[3] ) / 2\n                        self.redraw()\n\n                if len(data_rects) == 0:\n                    (h,w,c) = self.image.shape\n                    while True:\n                        io.process_messages(0.0001)\n\n                        if not self.force_landmarks:\n                            new_x = self.x\n                            new_y = self.y\n\n                        new_rect_size = self.rect_size\n\n                        mouse_events = io.get_mouse_events(self.wnd_name)\n                        for ev in mouse_events:\n                            (x, y, ev, flags) = ev\n                            if ev == io.EVENT_MOUSEWHEEL and not self.rect_locked:\n                                mod = 1 if flags > 0 else -1\n                                diff = 1 if new_rect_size <= 40 else np.clip(new_rect_size / 10, 1, 10)\n                                new_rect_size = max (5, new_rect_size + diff*mod)\n                            elif ev == io.EVENT_LBUTTONDOWN:\n                                if self.force_landmarks:\n                                    self.x = new_x\n                                    self.y = new_y\n                                    self.force_landmarks = False\n                                    self.rect_locked = True\n                                    self.redraw()\n                                else:\n                                    self.rect_locked = not self.rect_locked\n                                    self.extract_needed = True\n                            elif ev == io.EVENT_RBUTTONDOWN:\n                                self.force_landmarks = not self.force_landmarks\n                                if self.force_landmarks:\n                                    self.rect_locked = False\n                            elif not self.rect_locked:\n                                new_x = np.clip (x, 0, w-1) / self.view_scale\n                                new_y = np.clip (y, 0, h-1) / self.view_scale\n\n                        key_events = io.get_key_events(self.wnd_name)\n                        key, chr_key, ctrl_pressed, alt_pressed, shift_pressed = key_events[-1] if len(key_events) > 0 else (0,0,False,False,False)\n\n                        if key == ord('\\r') or key == ord('\\n'):\n                            #confirm frame\n                            is_frame_done = True\n                            data_rects.append (self.rect)\n                            data_landmarks.append (self.landmarks)\n                            break\n                        elif key == ord(' '):\n                            #confirm skip frame\n                            is_frame_done = True\n                            break\n                        elif key == ord(',')  and len(self.result) > 0:\n                            #go prev frame\n\n                            if self.rect_locked:\n                                self.rect_locked = False\n                                # Only save the face if the rect is still locked\n                                data_rects.append (self.rect)\n                                data_landmarks.append (self.landmarks)\n\n\n                            self.input_data.insert(0, self.result.pop() )\n                            io.progress_bar_inc(-1)\n                            need_remark_face = True\n\n                            break\n                        elif key == ord('.'):\n                            #go next frame\n\n                            if self.rect_locked:\n                                self.rect_locked = False\n                                # Only save the face if the rect is still locked\n                                data_rects.append (self.rect)\n                                data_landmarks.append (self.landmarks)\n\n                            need_remark_face = True\n                            is_frame_done = True\n                            break\n                        elif key == ord('q'):\n                            #skip remaining\n\n                            if self.rect_locked:\n                                self.rect_locked = False\n                                data_rects.append (self.rect)\n                                data_landmarks.append (self.landmarks)\n\n                            while len(self.input_data) > 0:\n                                self.result.append( self.input_data.pop(0) )\n                                io.progress_bar_inc(1)\n\n                            break\n\n                        elif key == ord('h'):\n                            self.hide_help = not self.hide_help\n                            break\n                        elif key == ord('a'):\n                            self.landmarks_accurate = not self.landmarks_accurate\n                            break\n\n                        if self.force_landmarks:\n                            pt2 = np.float32([new_x, new_y])\n                            pt1 = np.float32([self.x, self.y])\n\n                            pt_vec_len = npla.norm(pt2-pt1)\n                            pt_vec = pt2-pt1\n                            if pt_vec_len != 0:\n                                pt_vec /= pt_vec_len\n\n                            self.rect_size = pt_vec_len\n                            self.rect = ( int(self.x-self.rect_size),\n                                          int(self.y-self.rect_size),\n                                          int(self.x+self.rect_size),\n                                          int(self.y+self.rect_size) )\n\n                            if pt_vec_len > 0:\n                                lmrks = np.concatenate ( (np.zeros ((17,2), np.float32), LandmarksProcessor.landmarks_2D), axis=0 )\n                                lmrks -= lmrks[30:31,:]\n                                mat = cv2.getRotationMatrix2D( (0, 0), -np.arctan2( pt_vec[1], pt_vec[0] )*180/math.pi , pt_vec_len)\n                                mat[:, 2] += (self.x, self.y)\n                                self.landmarks = LandmarksProcessor.transform_points(lmrks, mat )\n\n\n                            self.redraw()\n\n                        elif self.x != new_x or \\\n                           self.y != new_y or \\\n                           self.rect_size != new_rect_size or \\\n                           self.extract_needed:\n                            self.x = new_x\n                            self.y = new_y\n                            self.rect_size = new_rect_size\n                            self.rect = ( int(self.x-self.rect_size),\n                                          int(self.y-self.rect_size),\n                                          int(self.x+self.rect_size),\n                                          int(self.y+self.rect_size) )\n\n                            return ExtractSubprocessor.Data (filepath, rects=[self.rect], landmarks_accurate=self.landmarks_accurate)\n\n                else:\n                    is_frame_done = True\n\n                if is_frame_done:\n                    self.result.append ( data )\n                    self.input_data.pop(0)\n                    io.progress_bar_inc(1)\n                    self.extract_needed = True\n                    self.rect_locked = False\n        else:\n            if len (self.input_data) > 0:\n                return self.input_data.pop(0)\n\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        if not self.type != 'landmarks-manual':\n            self.input_data.insert(0, data)\n\n    def redraw(self):\n        (h,w,c) = self.image.shape\n\n        if not self.hide_help:\n            image = cv2.addWeighted (self.image,1.0,self.text_lines_img,1.0,0)\n        else:\n            image = self.image.copy()\n\n        view_rect = (np.array(self.rect) * self.view_scale).astype(np.int).tolist()\n        view_landmarks  = (np.array(self.landmarks) * self.view_scale).astype(np.int).tolist()\n\n        if self.rect_size <= 40:\n            scaled_rect_size = h // 3 if w > h else w // 3\n\n            p1 = (self.x - self.rect_size, self.y - self.rect_size)\n            p2 = (self.x + self.rect_size, self.y - self.rect_size)\n            p3 = (self.x - self.rect_size, self.y + self.rect_size)\n\n            wh = h if h < w else w\n            np1 = (w / 2 - wh / 4, h / 2 - wh / 4)\n            np2 = (w / 2 + wh / 4, h / 2 - wh / 4)\n            np3 = (w / 2 - wh / 4, h / 2 + wh / 4)\n\n            mat = cv2.getAffineTransform( np.float32([p1,p2,p3])*self.view_scale, np.float32([np1,np2,np3]) )\n            image = cv2.warpAffine(image, mat,(w,h) )\n            view_landmarks = LandmarksProcessor.transform_points (view_landmarks, mat)\n\n        landmarks_color = (255,255,0) if self.rect_locked else (0,255,0)\n        LandmarksProcessor.draw_rect_landmarks (image, view_rect, view_landmarks, self.face_type, self.image_size, landmarks_color=landmarks_color)\n        self.extract_needed = False\n\n        io.show_image (self.wnd_name, image)\n\n\n    #override\n    def on_result (self, host_dict, data, result):\n        if self.type == 'landmarks-manual':\n            filepath, landmarks = result.filepath, result.landmarks\n\n            if len(landmarks) != 0 and landmarks[0] is not None:\n                self.landmarks = landmarks[0]\n\n            self.redraw()\n        else:\n            self.result.append ( result )\n            io.progress_bar_inc(1)\n\n\n\n    #override\n    def get_result(self):\n        return self.result\n\n\nclass DeletedFilesSearcherSubprocessor(Subprocessor):\n    class Cli(Subprocessor.Cli):\n        #override\n        def on_initialize(self, client_dict):\n            self.debug_paths_stems = client_dict['debug_paths_stems']\n            return None\n\n        #override\n        def process_data(self, data):\n            input_path_stem = Path(data[0]).stem\n            return any ( [ input_path_stem == d_stem for d_stem in self.debug_paths_stems] )\n\n        #override\n        def get_data_name (self, data):\n            #return string identificator of your data\n            return data[0]\n\n    #override\n    def __init__(self, input_paths, debug_paths ):\n        self.input_paths = input_paths\n        self.debug_paths_stems = [ Path(d).stem for d in debug_paths]\n        self.result = []\n        super().__init__('DeletedFilesSearcherSubprocessor', DeletedFilesSearcherSubprocessor.Cli, 60)\n\n    #override\n    def process_info_generator(self):\n        for i in range(min(multiprocessing.cpu_count(), 8)):\n            yield 'CPU%d' % (i), {}, {'debug_paths_stems' : self.debug_paths_stems}\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"Searching deleted files\", len (self.input_paths))\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.input_paths) > 0:\n            return [self.input_paths.pop(0)]\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.input_paths.insert(0, data[0])\n\n    #override\n    def on_result (self, host_dict, data, result):\n        if result == False:\n            self.result.append( data[0] )\n        io.progress_bar_inc(1)\n\n    #override\n    def get_result(self):\n        return self.result\n\ndef main(detector=None,\n         input_path=None,\n         output_path=None,\n         output_debug=None,\n         manual_fix=False,\n         manual_output_debug_fix=False,\n         manual_window_size=1368,\n         face_type='full_face',\n         max_faces_from_image=None,\n         image_size=None,\n         jpeg_quality=None,\n         cpu_only = False,\n         force_gpu_idxs = None,\n         ):\n\n    if not input_path.exists():\n        io.log_err ('Input directory not found. Please ensure it exists.')\n        return\n\n    if not output_path.exists():\n        output_path.mkdir(parents=True, exist_ok=True)\n\n    if face_type is not None:\n        face_type = FaceType.fromString(face_type)\n\n    if face_type is None:\n        if manual_output_debug_fix:\n            files = pathex.get_image_paths(output_path)\n            if len(files) != 0:\n                dflimg = DFLIMG.load(Path(files[0]))\n                if dflimg is not None and dflimg.has_data():\n                     face_type = FaceType.fromString ( dflimg.get_face_type() )\n\n    input_image_paths = pathex.get_image_unique_filestem_paths(input_path, verbose_print_func=io.log_info)\n    output_images_paths = pathex.get_image_paths(output_path)\n    output_debug_path = output_path.parent / (output_path.name + '_debug')\n\n    continue_extraction = False\n    if not manual_output_debug_fix and len(output_images_paths) > 0:\n        if len(output_images_paths) > 128:\n            continue_extraction = io.input_bool (\"Continue extraction?\", True, help_message=\"Extraction can be continued, but you must specify the same options again.\")\n\n        if len(output_images_paths) > 128 and continue_extraction:\n            try:\n                input_image_paths = input_image_paths[ [ Path(x).stem for x in input_image_paths ].index ( Path(output_images_paths[-128]).stem.split('_')[0] ) : ]\n            except:\n                io.log_err(\"Error in fetching the last index. Extraction cannot be continued.\")\n                return\n        elif input_path != output_path:\n                io.input(f\"\\n WARNING !!! \\n {output_path} contains files! \\n They will be deleted. \\n Press enter to continue.\\n\")\n                for filename in output_images_paths:\n                    Path(filename).unlink()\n\n    device_config = nn.DeviceConfig.GPUIndexes( force_gpu_idxs or nn.ask_choose_device_idxs(choose_only_one=detector=='manual', suggest_all_gpu=True) ) \\\n                    if not cpu_only else nn.DeviceConfig.CPU()\n\n    if face_type is None:\n        face_type = io.input_str (\"Face type\", 'wf', ['f','wf','head'], help_message=\"Full face / whole face / head. 'Whole face' covers full area of face include forehead. 'head' covers full head, but requires XSeg for src and dst faceset.\").lower()\n        face_type = {'f'  : FaceType.FULL,\n                     'wf' : FaceType.WHOLE_FACE,\n                     'head' : FaceType.HEAD}[face_type]\n\n    if max_faces_from_image is None:\n        max_faces_from_image = io.input_int(f\"Max number of faces from image\", 0, help_message=\"If you extract a src faceset that has frames with a large number of faces, it is advisable to set max faces to 3 to speed up extraction. 0 - unlimited\")\n\n    if image_size is None:\n        image_size = io.input_int(f\"Image size\", 512 if face_type < FaceType.HEAD else 768, valid_range=[256,2048], help_message=\"Output image size. The higher image size, the worse face-enhancer works. Use higher than 512 value only if the source image is sharp enough and the face does not need to be enhanced.\")\n\n    if jpeg_quality is None:\n        jpeg_quality = io.input_int(f\"Jpeg quality\", 90, valid_range=[1,100], help_message=\"Jpeg quality. The higher jpeg quality the larger the output file size.\")\n\n    if detector is None:\n        io.log_info (\"Choose detector type.\")\n        io.log_info (\"[0] S3FD\")\n        io.log_info (\"[1] manual\")\n        detector = {0:'s3fd', 1:'manual'}[ io.input_int(\"\", 0, [0,1]) ]\n\n\n    if output_debug is None:\n        output_debug = io.input_bool (f\"Write debug images to {output_debug_path.name}?\", False)\n\n    if output_debug:\n        output_debug_path.mkdir(parents=True, exist_ok=True)\n\n    if manual_output_debug_fix:\n        if not output_debug_path.exists():\n            io.log_err(f'{output_debug_path} not found. Re-extract faces with \"Write debug images\" option.')\n            return\n        else:\n            detector = 'manual'\n            io.log_info('Performing re-extract frames which were deleted from _debug directory.')\n\n            input_image_paths = DeletedFilesSearcherSubprocessor (input_image_paths, pathex.get_image_paths(output_debug_path) ).run()\n            input_image_paths = sorted (input_image_paths)\n            io.log_info('Found %d images.' % (len(input_image_paths)))\n    else:\n        if not continue_extraction and output_debug_path.exists():\n            for filename in pathex.get_image_paths(output_debug_path):\n                Path(filename).unlink()\n\n    images_found = len(input_image_paths)\n    faces_detected = 0\n    if images_found != 0:\n        if detector == 'manual':\n            io.log_info ('Performing manual extract...')\n            data = ExtractSubprocessor ([ ExtractSubprocessor.Data(Path(filename)) for filename in input_image_paths ], 'landmarks-manual', image_size, jpeg_quality, face_type, output_debug_path if output_debug else None, manual_window_size=manual_window_size, device_config=device_config).run()\n\n            io.log_info ('Performing 3rd pass...')\n            data = ExtractSubprocessor (data, 'final', image_size, jpeg_quality, face_type, output_debug_path if output_debug else None, final_output_path=output_path, device_config=device_config).run()\n\n        else:\n            io.log_info ('Extracting faces...')\n            data = ExtractSubprocessor ([ ExtractSubprocessor.Data(Path(filename)) for filename in input_image_paths ],\n                                         'all',\n                                         image_size,\n                                         jpeg_quality,\n                                         face_type,\n                                         output_debug_path if output_debug else None,\n                                         max_faces_from_image=max_faces_from_image,\n                                         final_output_path=output_path,\n                                         device_config=device_config).run()\n\n        faces_detected += sum([d.faces_detected for d in data])\n\n        if manual_fix:\n            if all ( np.array ( [ d.faces_detected > 0 for d in data] ) == True ):\n                io.log_info ('All faces are detected, manual fix not needed.')\n            else:\n                fix_data = [ ExtractSubprocessor.Data(d.filepath) for d in data if d.faces_detected == 0 ]\n                io.log_info ('Performing manual fix for %d images...' % (len(fix_data)) )\n                fix_data = ExtractSubprocessor (fix_data, 'landmarks-manual', image_size, jpeg_quality, face_type, output_debug_path if output_debug else None, manual_window_size=manual_window_size, device_config=device_config).run()\n                fix_data = ExtractSubprocessor (fix_data, 'final', image_size, jpeg_quality, face_type, output_debug_path if output_debug else None, final_output_path=output_path, device_config=device_config).run()\n                faces_detected += sum([d.faces_detected for d in fix_data])\n\n\n    io.log_info ('-------------------------')\n    io.log_info ('Images found:        %d' % (images_found) )\n    io.log_info ('Faces detected:      %d' % (faces_detected) )\n    io.log_info ('-------------------------')\n", "core/cv2ex.py": "import cv2\nimport numpy as np\nfrom pathlib import Path\nfrom core.interact import interact as io\nfrom core import imagelib \nimport traceback\n\ndef cv2_imread(filename, flags=cv2.IMREAD_UNCHANGED, loader_func=None, verbose=True):\n    \"\"\"\n    allows to open non-english characters path\n    \"\"\"\n    try:\n        if loader_func is not None:\n            bytes = bytearray(loader_func(filename))\n        else:\n            with open(filename, \"rb\") as stream:\n                bytes = bytearray(stream.read())\n        numpyarray = np.asarray(bytes, dtype=np.uint8)\n        return cv2.imdecode(numpyarray, flags)\n    except:\n        if verbose:\n            io.log_err(f\"Exception occured in cv2_imread : {traceback.format_exc()}\")\n        return None\n\ndef cv2_imwrite(filename, img, *args):\n    ret, buf = cv2.imencode( Path(filename).suffix, img, *args)\n    if ret == True:\n        try:\n            with open(filename, \"wb\") as stream:\n                stream.write( buf )\n        except:\n            pass\n\ndef cv2_resize(x, *args, **kwargs):\n    h,w,c = x.shape\n    x = cv2.resize(x, *args, **kwargs)\n    \n    x = imagelib.normalize_channels(x, c)\n    return x\n    ", "core/randomex.py": "import numpy as np\n\ndef random_normal( size=(1,), trunc_val = 2.5, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n    len = np.array(size).prod()\n    result = np.empty ( (len,) , dtype=np.float32)\n\n    for i in range (len):\n        while True:\n            x = rnd_state.normal()\n            if x >= -trunc_val and x <= trunc_val:\n                break\n        result[i] = (x / trunc_val)\n\n    return result.reshape ( size )", "core/stdex.py": "import os\nimport sys\n\nclass suppress_stdout_stderr(object):\n    def __enter__(self):\n        self.outnull_file = open(os.devnull, 'w')\n        self.errnull_file = open(os.devnull, 'w')\n\n        self.old_stdout_fileno_undup    = sys.stdout.fileno()\n        self.old_stderr_fileno_undup    = sys.stderr.fileno()\n\n        self.old_stdout_fileno = os.dup ( sys.stdout.fileno() )\n        self.old_stderr_fileno = os.dup ( sys.stderr.fileno() )\n\n        self.old_stdout = sys.stdout\n        self.old_stderr = sys.stderr\n\n        os.dup2 ( self.outnull_file.fileno(), self.old_stdout_fileno_undup )\n        os.dup2 ( self.errnull_file.fileno(), self.old_stderr_fileno_undup )\n\n        sys.stdout = self.outnull_file\n        sys.stderr = self.errnull_file\n        return self\n\n    def __exit__(self, *_):\n        sys.stdout = self.old_stdout\n        sys.stderr = self.old_stderr\n\n        os.dup2 ( self.old_stdout_fileno, self.old_stdout_fileno_undup )\n        os.dup2 ( self.old_stderr_fileno, self.old_stderr_fileno_undup )\n\n        os.close ( self.old_stdout_fileno )\n        os.close ( self.old_stderr_fileno )\n\n        self.outnull_file.close()\n        self.errnull_file.close()\n", "core/structex.py": "import struct\n\ndef struct_unpack(data, counter, fmt):\n    fmt_size = struct.calcsize(fmt)\n    return (counter+fmt_size,) + struct.unpack (fmt, data[counter:counter+fmt_size])\n", "core/osex.py": "import os\nimport sys\n\nif sys.platform[0:3] == 'win':\n    from ctypes import windll\n    from ctypes import wintypes\n\ndef set_process_lowest_prio():\n    try:\n        if sys.platform[0:3] == 'win':\n            GetCurrentProcess = windll.kernel32.GetCurrentProcess\n            GetCurrentProcess.restype = wintypes.HANDLE\n            SetPriorityClass = windll.kernel32.SetPriorityClass\n            SetPriorityClass.argtypes = (wintypes.HANDLE, wintypes.DWORD)\n            SetPriorityClass ( GetCurrentProcess(), 0x00000040 )\n        elif 'darwin' in sys.platform:\n            os.nice(10)\n        elif 'linux' in sys.platform:\n            os.nice(20)\n    except:\n        print(\"Unable to set lowest process priority\")\n\ndef set_process_dpi_aware():\n    if sys.platform[0:3] == 'win':\n        windll.user32.SetProcessDPIAware(True)\n\ndef get_screen_size():\n    if sys.platform[0:3] == 'win':\n        user32 = windll.user32\n        return user32.GetSystemMetrics(0), user32.GetSystemMetrics(1)\n    elif 'darwin' in sys.platform:\n        pass\n    elif 'linux' in sys.platform:\n        pass\n        \n    return (1366, 768)\n        ", "core/pathex.py": "from pathlib import Path\nfrom os import scandir\n\nimage_extensions = [\".jpg\", \".jpeg\", \".png\", \".tif\", \".tiff\"]\n\ndef write_bytes_safe(p, bytes_data):\n    \"\"\"\n    writes to .tmp first and then rename to target filename\n    \"\"\"\n    p_tmp = p.parent / (p.name + '.tmp')\n    p_tmp.write_bytes(bytes_data)\n    if p.exists():\n        p.unlink()\n    p_tmp.rename (p)\n\ndef scantree(path):\n    \"\"\"Recursively yield DirEntry objects for given directory.\"\"\"\n    for entry in scandir(path):\n        if entry.is_dir(follow_symlinks=False):\n            yield from scantree(entry.path)  # see below for Python 2.x\n        else:\n            yield entry\n\ndef get_image_paths(dir_path, image_extensions=image_extensions, subdirs=False, return_Path_class=False):\n    dir_path = Path (dir_path)\n\n    result = []\n    if dir_path.exists():\n\n        if subdirs:\n            gen = scantree(str(dir_path))\n        else:\n            gen = scandir(str(dir_path))\n\n        for x in list(gen):\n            if any([x.name.lower().endswith(ext) for ext in image_extensions]):\n                result.append( x.path if not return_Path_class else Path(x.path) )\n    return sorted(result)\n\ndef get_image_unique_filestem_paths(dir_path, verbose_print_func=None):\n    result = get_image_paths(dir_path)\n    result_dup = set()\n\n    for f in result[:]:\n        f_stem = Path(f).stem\n        if f_stem in result_dup:\n            result.remove(f)\n            if verbose_print_func is not None:\n                verbose_print_func (\"Duplicate filenames are not allowed, skipping: %s\" % Path(f).name )\n            continue\n        result_dup.add(f_stem)\n\n    return sorted(result)\n\ndef get_paths(dir_path):\n    dir_path = Path (dir_path)\n\n    if dir_path.exists():\n        return [ Path(x) for x in sorted([ x.path for x in list(scandir(str(dir_path))) ]) ]\n    else:\n        return []\n        \ndef get_file_paths(dir_path):\n    dir_path = Path (dir_path)\n\n    if dir_path.exists():\n        return [ Path(x) for x in sorted([ x.path for x in list(scandir(str(dir_path))) if x.is_file() ]) ]\n    else:\n        return []\n\ndef get_all_dir_names (dir_path):\n    dir_path = Path (dir_path)\n\n    if dir_path.exists():\n        return sorted([ x.name for x in list(scandir(str(dir_path))) if x.is_dir() ])\n    else:\n        return []\n\ndef get_all_dir_names_startswith (dir_path, startswith):\n    dir_path = Path (dir_path)\n    startswith = startswith.lower()\n\n    result = []\n    if dir_path.exists():\n        for x in list(scandir(str(dir_path))):\n            if x.name.lower().startswith(startswith):\n                result.append ( x.name[len(startswith):] )\n    return sorted(result)\n\ndef get_first_file_by_stem (dir_path, stem, exts=None):\n    dir_path = Path (dir_path)\n    stem = stem.lower()\n\n    if dir_path.exists():\n        for x in sorted(list(scandir(str(dir_path))), key=lambda x: x.name):\n            if not x.is_file():\n                continue\n            xp = Path(x.path)\n            if xp.stem.lower() == stem and (exts is None or xp.suffix.lower() in exts):\n                return xp\n\n    return None\n\ndef move_all_files (src_dir_path, dst_dir_path):\n    paths = get_file_paths(src_dir_path)\n    for p in paths:\n        p = Path(p)\n        p.rename ( Path(dst_dir_path) / p.name )\n\ndef delete_all_files (dir_path):\n    paths = get_file_paths(dir_path)\n    for p in paths:\n        p = Path(p)\n        p.unlink()\n", "core/qtex/qtex.py": "import numpy as np\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\nfrom localization import StringsDB\n\nfrom .QXMainWindow import *\n            \n                \nclass QActionEx(QAction):\n    def __init__(self, icon, text, shortcut=None, trigger_func=None, shortcut_in_tooltip=False, is_checkable=False, is_auto_repeat=False ):\n        super().__init__(icon, text)\n        if shortcut is not None:\n            self.setShortcut(shortcut)\n            if shortcut_in_tooltip:\n                \n                self.setToolTip( f\"{text} ( {StringsDB['S_HOT_KEY'] }: {shortcut} )\")\n                \n        if trigger_func is not None:\n            self.triggered.connect(trigger_func)\n        if is_checkable:            \n            self.setCheckable(True)\n        self.setAutoRepeat(is_auto_repeat)\n            \ndef QImage_from_np(img):\n    if img.dtype != np.uint8:\n        raise ValueError(\"img should be in np.uint8 format\")\n        \n    h,w,c = img.shape\n    if c == 1:\n        fmt = QImage.Format_Grayscale8\n    elif c == 3:\n        fmt = QImage.Format_BGR888\n    elif c == 4:\n        fmt = QImage.Format_ARGB32\n    else:\n      raise ValueError(\"unsupported channel count\")  \n    \n    return QImage(img.data, w, h, c*w, fmt )\n        \ndef QImage_to_np(q_img, fmt=QImage.Format_BGR888):\n    q_img = q_img.convertToFormat(fmt)\n\n    width = q_img.width()\n    height = q_img.height()\n    \n    b = q_img.constBits()\n    b.setsize(height * width * 3)\n    arr = np.frombuffer(b, np.uint8).reshape((height, width, 3))\n    return arr#[::-1]\n        \ndef QPixmap_from_np(img):    \n    return QPixmap.fromImage(QImage_from_np(img))\n    \ndef QPoint_from_np(n):\n    return QPoint(*n.astype(np.int))\n    \ndef QPoint_to_np(q):\n    return np.int32( [q.x(), q.y()] )\n    \ndef QSize_to_np(q):\n    return np.int32( [q.width(), q.height()] )\n    \nclass QDarkPalette(QPalette):\n    def __init__(self):\n        super().__init__()\n        text_color = QColor(200,200,200)\n        self.setColor(QPalette.Window, QColor(53, 53, 53))\n        self.setColor(QPalette.WindowText, text_color )\n        self.setColor(QPalette.Base, QColor(25, 25, 25))\n        self.setColor(QPalette.AlternateBase, QColor(53, 53, 53))\n        self.setColor(QPalette.ToolTipBase, text_color )\n        self.setColor(QPalette.ToolTipText, text_color )\n        self.setColor(QPalette.Text, text_color ) \n        self.setColor(QPalette.Button, QColor(53, 53, 53))\n        self.setColor(QPalette.ButtonText, Qt.white)\n        self.setColor(QPalette.BrightText, Qt.red)\n        self.setColor(QPalette.Link, QColor(42, 130, 218))\n        self.setColor(QPalette.Highlight, QColor(42, 130, 218))\n        self.setColor(QPalette.HighlightedText, Qt.black)", "core/qtex/QXIconButton.py": "from PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\nfrom localization import StringsDB\nfrom .QXMainWindow import *\n\nclass QXIconButton(QPushButton):\n    \"\"\"\n    Custom Icon button that works through keyEvent system, without shortcut of QAction\n    works only with QXMainWindow as global window class\n    currently works only with one-key shortcut\n    \"\"\"\n\n    def __init__(self, icon, \n                    tooltip=None, \n                    shortcut=None,                    \n                    click_func=None,                  \n                    first_repeat_delay=300,\n                    repeat_delay=20,\n                    ):\n\n        super().__init__(icon, \"\")\n\n        self.setIcon(icon)\n        \n        if shortcut is not None:\n            tooltip = f\"{tooltip} ( {StringsDB['S_HOT_KEY'] }: {shortcut} )\"\n        \n        self.setToolTip(tooltip)\n            \n        \n        self.seq = QKeySequence(shortcut) if shortcut is not None else None\n        \n        QXMainWindow.inst.add_keyPressEvent_listener ( self.on_keyPressEvent )\n        QXMainWindow.inst.add_keyReleaseEvent_listener ( self.on_keyReleaseEvent )\n        \n        self.click_func = click_func\n        self.first_repeat_delay = first_repeat_delay\n        self.repeat_delay = repeat_delay\n        self.repeat_timer = None\n        \n        self.op_device = None\n        \n        self.pressed.connect( lambda : self.action(is_pressed=True)  )\n        self.released.connect( lambda : self.action(is_pressed=False)  )\n        \n    def action(self, is_pressed=None, op_device=None):\n        if self.click_func is None:\n            return\n\n        if is_pressed is not None:\n            if is_pressed:\n                if self.repeat_timer is None:\n                    self.click_func()\n                    self.repeat_timer = QTimer()\n                    self.repeat_timer.timeout.connect(self.action)\n                    self.repeat_timer.start(self.first_repeat_delay)\n            else:\n                if self.repeat_timer is not None:\n                    self.repeat_timer.stop()\n                    self.repeat_timer = None\n        else:\n            self.click_func()\n            if self.repeat_timer is not None:\n                self.repeat_timer.setInterval(self.repeat_delay)\n        \n    def on_keyPressEvent(self, ev):              \n        key = ev.nativeVirtualKey()\n        if ev.isAutoRepeat():\n            return\n            \n        if self.seq is not None:\n            if key == self.seq[0]:\n                self.action(is_pressed=True)\n\n    def on_keyReleaseEvent(self, ev):\n        key = ev.nativeVirtualKey()\n        if ev.isAutoRepeat():\n            return\n        if self.seq is not None:\n            if key == self.seq[0]:\n                self.action(is_pressed=False)\n", "core/qtex/QXMainWindow.py": "from PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\nclass QXMainWindow(QWidget):\n    \"\"\"\n    Custom mainwindow class that provides global single instance and event listeners\n    \"\"\"\n    inst = None\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)        \n        if QXMainWindow.inst is not None:\n            raise Exception(\"QXMainWindow can only be one.\")        \n        QXMainWindow.inst = self\n        \n        self.keyPressEvent_listeners = []\n        self.keyReleaseEvent_listeners = []\n        self.setFocusPolicy(Qt.WheelFocus)\n        \n    def add_keyPressEvent_listener(self, func):\n        self.keyPressEvent_listeners.append (func)\n        \n    def add_keyReleaseEvent_listener(self, func):\n        self.keyReleaseEvent_listeners.append (func)\n        \n    def keyPressEvent(self, ev):\n        super().keyPressEvent(ev)        \n        for func in self.keyPressEvent_listeners:\n            func(ev)\n            \n    def keyReleaseEvent(self, ev):\n        super().keyReleaseEvent(ev)        \n        for func in self.keyReleaseEvent_listeners:\n            func(ev)", "core/qtex/__init__.py": "from .qtex import *\nfrom .QSubprocessor import *\nfrom .QXIconButton import *", "core/qtex/QSubprocessor.py": "import multiprocessing\nimport sys\nimport time\nimport traceback\n\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\nfrom core.interact import interact as io\n\nfrom .qtex import *\n\nclass QSubprocessor(object):\n    \"\"\"\n    \n    \"\"\"\n\n    class Cli(object):\n        def __init__ ( self, client_dict ):\n            s2c = multiprocessing.Queue()\n            c2s = multiprocessing.Queue()\n            self.p = multiprocessing.Process(target=self._subprocess_run, args=(client_dict,s2c,c2s) )\n            self.s2c = s2c\n            self.c2s = c2s\n            self.p.daemon = True\n            self.p.start()\n\n            self.state = None\n            self.sent_time = None\n            self.sent_data = None\n            self.name = None\n            self.host_dict = None\n\n        def kill(self):\n            self.p.terminate()\n            self.p.join()\n\n        #overridable optional\n        def on_initialize(self, client_dict):\n            #initialize your subprocess here using client_dict\n            pass\n\n        #overridable optional\n        def on_finalize(self):\n            #finalize your subprocess here\n            pass\n\n        #overridable\n        def process_data(self, data):\n            #process 'data' given from host and return result\n            raise NotImplementedError\n\n        #overridable optional\n        def get_data_name (self, data):\n            #return string identificator of your 'data'\n            return \"undefined\"\n\n        def log_info(self, msg): self.c2s.put ( {'op': 'log_info', 'msg':msg } )\n        def log_err(self, msg):  self.c2s.put ( {'op': 'log_err' , 'msg':msg } )\n        def progress_bar_inc(self, c): self.c2s.put ( {'op': 'progress_bar_inc' , 'c':c } )\n\n        def _subprocess_run(self, client_dict, s2c, c2s):\n            self.c2s = c2s\n            data = None\n            try:\n                self.on_initialize(client_dict)\n                c2s.put ( {'op': 'init_ok'} )\n                while True:\n                    msg = s2c.get()\n                    op = msg.get('op','')\n                    if op == 'data':\n                        data = msg['data']\n                        result = self.process_data (data)\n                        c2s.put ( {'op': 'success', 'data' : data, 'result' : result} )\n                        data = None\n                    elif op == 'close':\n                        break\n                    time.sleep(0.001)\n                self.on_finalize()\n                c2s.put ( {'op': 'finalized'} )\n            except Exception as e:\n                c2s.put ( {'op': 'error', 'data' : data} )\n                if data is not None:\n                    print ('Exception while process data [%s]: %s' % (self.get_data_name(data), traceback.format_exc()) )\n                else:\n                    print ('Exception: %s' % (traceback.format_exc()) )\n            c2s.close()\n            s2c.close()\n            self.c2s = None\n\n        # disable pickling\n        def __getstate__(self):\n            return dict()\n        def __setstate__(self, d):\n            self.__dict__.update(d)\n\n    #overridable\n    def __init__(self, name, SubprocessorCli_class, no_response_time_sec = 0, io_loop_sleep_time=0.005):\n        if not issubclass(SubprocessorCli_class, QSubprocessor.Cli):\n            raise ValueError(\"SubprocessorCli_class must be subclass of QSubprocessor.Cli\")\n\n        self.name = name\n        self.SubprocessorCli_class = SubprocessorCli_class\n        self.no_response_time_sec = no_response_time_sec\n        self.io_loop_sleep_time = io_loop_sleep_time\n\n        self.clis = []\n\n        #getting info about name of subprocesses, host and client dicts, and spawning them\n        for name, host_dict, client_dict in self.process_info_generator():\n            try:\n                cli = self.SubprocessorCli_class(client_dict)\n                cli.state = 1\n                cli.sent_time = 0\n                cli.sent_data = None\n                cli.name = name\n                cli.host_dict = host_dict\n\n                self.clis.append (cli)\n            except:\n                raise Exception (f\"Unable to start subprocess {name}. Error: {traceback.format_exc()}\")\n\n        if len(self.clis) == 0:\n            raise Exception (\"Unable to start QSubprocessor '%s' \" % (self.name))\n\n        #waiting subprocesses their success(or not) initialization\n        while True:\n            for cli in self.clis[:]:\n                while not cli.c2s.empty():\n                    obj = cli.c2s.get()\n                    op = obj.get('op','')\n                    if op == 'init_ok':\n                        cli.state = 0\n                    elif op == 'log_info':\n                        io.log_info(obj['msg'])\n                    elif op == 'log_err':\n                        io.log_err(obj['msg'])\n                    elif op == 'error':\n                        cli.kill()\n                        self.clis.remove(cli)\n                        break\n            if all ([cli.state == 0 for cli in self.clis]):\n                break\n            io.process_messages(0.005)\n\n        if len(self.clis) == 0:\n            raise Exception ( \"Unable to start subprocesses.\" )\n\n        #ok some processes survived, initialize host logic\n        self.on_clients_initialized()\n                \n        self.q_timer = QTimer()\n        self.q_timer.timeout.connect(self.tick)\n        self.q_timer.start(5)\n        \n    #overridable\n    def process_info_generator(self):\n        #yield per process (name, host_dict, client_dict)\n        for i in range(min(multiprocessing.cpu_count(), 8) ):\n            yield 'CPU%d' % (i), {}, {}\n\n    #overridable optional\n    def on_clients_initialized(self):\n        #logic when all subprocesses initialized and ready\n        pass\n\n    #overridable optional\n    def on_clients_finalized(self):\n        #logic when all subprocess finalized\n        pass\n\n    #overridable\n    def get_data(self, host_dict):\n        #return data for processing here\n        raise NotImplementedError\n\n    #overridable\n    def on_data_return (self, host_dict, data):\n        #you have to place returned 'data' back to your queue\n        raise NotImplementedError\n\n    #overridable\n    def on_result (self, host_dict, data, result):\n        #your logic what to do with 'result' of 'data'\n        raise NotImplementedError\n\n    def tick(self):\n        for cli in self.clis[:]:\n            while not cli.c2s.empty():\n                obj = cli.c2s.get()\n                op = obj.get('op','')\n                if op == 'success':\n                    #success processed data, return data and result to on_result\n                    self.on_result (cli.host_dict, obj['data'], obj['result'])\n                    self.sent_data = None\n                    cli.state = 0\n                elif op == 'error':\n                    #some error occured while process data, returning chunk to on_data_return\n                    if 'data' in obj.keys():\n                        self.on_data_return (cli.host_dict, obj['data'] )\n                    #and killing process\n                    cli.kill()\n                    self.clis.remove(cli)\n                elif op == 'log_info':\n                    io.log_info(obj['msg'])\n                elif op == 'log_err':\n                    io.log_err(obj['msg'])\n                elif op == 'progress_bar_inc':\n                    io.progress_bar_inc(obj['c'])\n\n        for cli in self.clis[:]:\n            if cli.state == 1:\n                if cli.sent_time != 0 and self.no_response_time_sec != 0 and (time.time() - cli.sent_time) > self.no_response_time_sec:\n                    #subprocess busy too long\n                    io.log_info ( '%s doesnt response, terminating it.' % (cli.name) )\n                    self.on_data_return (cli.host_dict, cli.sent_data )\n                    cli.kill()\n                    self.clis.remove(cli)\n\n        for cli in self.clis[:]:\n            if cli.state == 0:\n                #free state of subprocess, get some data from get_data\n                data = self.get_data(cli.host_dict)\n                if data is not None:\n                    #and send it to subprocess\n                    cli.s2c.put ( {'op': 'data', 'data' : data} )\n                    cli.sent_time = time.time()\n                    cli.sent_data = data\n                    cli.state = 1\n\n        if all ([cli.state == 0 for cli in self.clis]):\n            #gracefully terminating subprocesses\n            for cli in self.clis[:]:\n                cli.s2c.put ( {'op': 'close'} )\n                cli.sent_time = time.time()\n\n            while True:\n                for cli in self.clis[:]:\n                    terminate_it = False\n                    while not cli.c2s.empty():\n                        obj = cli.c2s.get()\n                        obj_op = obj['op']\n                        if obj_op == 'finalized':\n                            terminate_it = True\n                            break\n\n                    if (time.time() - cli.sent_time) > 30:\n                        terminate_it = True\n\n                    if terminate_it:\n                        cli.state = 2\n                        cli.kill()\n\n                if all ([cli.state == 2 for cli in self.clis]):\n                    break\n\n            #finalizing host logic\n            self.q_timer.stop()\n            self.q_timer = None\n            self.on_clients_finalized()\n            \n", "core/mathlib/umeyama.py": "import numpy as np\n\ndef umeyama(src, dst, estimate_scale):\n    \"\"\"Estimate N-D similarity transformation with or without scaling.\n    Parameters\n    ----------\n    src : (M, N) array\n        Source coordinates.\n    dst : (M, N) array\n        Destination coordinates.\n    estimate_scale : bool\n        Whether to estimate scaling factor.\n    Returns\n    -------\n    T : (N + 1, N + 1)\n        The homogeneous similarity transformation matrix. The matrix contains\n        NaN values only if the problem is not well-conditioned.\n    References\n    ----------\n    .. [1] \"Least-squares estimation of transformation parameters between two\n            point patterns\", Shinji Umeyama, PAMI 1991, DOI: 10.1109/34.88573\n    \"\"\"\n\n    num = src.shape[0]\n    dim = src.shape[1]\n\n    # Compute mean of src and dst.\n    src_mean = src.mean(axis=0)\n    dst_mean = dst.mean(axis=0)\n\n    # Subtract mean from src and dst.\n    src_demean = src - src_mean\n    dst_demean = dst - dst_mean\n\n    # Eq. (38).\n    A = np.dot(dst_demean.T, src_demean) / num\n\n    # Eq. (39).\n    d = np.ones((dim,), dtype=np.double)\n    if np.linalg.det(A) < 0:\n        d[dim - 1] = -1\n\n    T = np.eye(dim + 1, dtype=np.double)\n\n    U, S, V = np.linalg.svd(A)\n\n    # Eq. (40) and (43).\n    rank = np.linalg.matrix_rank(A)\n    if rank == 0:\n        return np.nan * T\n    elif rank == dim - 1:\n        if np.linalg.det(U) * np.linalg.det(V) > 0:\n            T[:dim, :dim] = np.dot(U, V)\n        else:\n            s = d[dim - 1]\n            d[dim - 1] = -1\n            T[:dim, :dim] = np.dot(U, np.dot(np.diag(d), V))\n            d[dim - 1] = s\n    else:\n        T[:dim, :dim] = np.dot(U, np.dot(np.diag(d), V))\n\n    if estimate_scale:\n        # Eq. (41) and (42).\n        scale = 1.0 / src_demean.var(axis=0).sum() * np.dot(S, d)\n    else:\n        scale = 1.0\n\n    T[:dim, dim] = dst_mean - scale * np.dot(T[:dim, :dim], src_mean.T)\n    T[:dim, :dim] *= scale\n\n    return T\n", "core/mathlib/__init__.py": "import math\n\nimport cv2\nimport numpy as np\nimport numpy.linalg as npla\n\nfrom .umeyama import umeyama\n\n\ndef get_power_of_two(x):\n    i = 0\n    while (1 << i) < x:\n        i += 1\n    return i\n\ndef rotationMatrixToEulerAngles(R) :\n    sy = math.sqrt(R[0,0] * R[0,0] +  R[1,0] * R[1,0])\n    singular = sy < 1e-6\n    if  not singular :\n        x = math.atan2(R[2,1] , R[2,2])\n        y = math.atan2(-R[2,0], sy)\n        z = math.atan2(R[1,0], R[0,0])\n    else :\n        x = math.atan2(-R[1,2], R[1,1])\n        y = math.atan2(-R[2,0], sy)\n        z = 0\n    return np.array([x, y, z])\n\ndef polygon_area(x,y):\n    return 0.5*np.abs(np.dot(x,np.roll(y,1))-np.dot(y,np.roll(x,1)))\n\ndef rotate_point(origin, point, deg):\n    \"\"\"\n    Rotate a point counterclockwise by a given angle around a given origin.\n\n    The angle should be given in radians.\n    \"\"\"\n    ox, oy = origin\n    px, py = point\n\n    rad = deg * math.pi / 180.0\n    qx = ox + math.cos(rad) * (px - ox) - math.sin(rad) * (py - oy)\n    qy = oy + math.sin(rad) * (px - ox) + math.cos(rad) * (py - oy)\n    return np.float32([qx, qy])\n    \ndef transform_points(points, mat, invert=False):\n    if invert:\n        mat = cv2.invertAffineTransform (mat)\n    points = np.expand_dims(points, axis=1)\n    points = cv2.transform(points, mat, points.shape)\n    points = np.squeeze(points)\n    return points\n\n    \ndef transform_mat(mat, res, tx, ty, rotation, scale):\n    \"\"\"\n    transform mat in local space of res\n    scale -> translate -> rotate\n    \n        tx,ty       float\n        rotation    int degrees\n        scale       float\n    \"\"\"\n    \n    \n    lt, rt, lb, ct = transform_points (  np.float32([(0,0),(res,0),(0,res),(res / 2, res/2) ]),mat, True)\n    \n    hor_v = (rt-lt).astype(np.float32)\n    hor_size = npla.norm(hor_v)\n    hor_v /= hor_size\n    \n    ver_v = (lb-lt).astype(np.float32)\n    ver_size = npla.norm(ver_v)\n    ver_v /= ver_size\n    \n    bt_diag_vec = (rt-ct).astype(np.float32)\n    half_diag_len = npla.norm(bt_diag_vec)\n    bt_diag_vec /= half_diag_len\n    \n    tb_diag_vec = np.float32( [ -bt_diag_vec[1], bt_diag_vec[0] ]  )\n\n    rt = ct + bt_diag_vec*half_diag_len*scale \n    lb = ct - bt_diag_vec*half_diag_len*scale\n    lt = ct - tb_diag_vec*half_diag_len*scale\n    \n    rt[0] += tx*hor_size\n    lb[0] += tx*hor_size\n    lt[0] += tx*hor_size\n    rt[1] += ty*ver_size\n    lb[1] += ty*ver_size\n    lt[1] += ty*ver_size\n    \n    rt = rotate_point(ct, rt, rotation)\n    lb = rotate_point(ct, lb, rotation)\n    lt = rotate_point(ct, lt, rotation)\n    \n    return cv2.getAffineTransform( np.float32([lt, rt, lb]), np.float32([ [0,0], [res,0], [0,res] ]) )\n", "core/interact/interact.py": "import multiprocessing\nimport os\nimport sys\nimport threading\nimport time\nimport types\n\nimport colorama\nimport cv2\nimport numpy as np\nfrom tqdm import tqdm\n\nfrom core import stdex\n\ntry:\n    import IPython #if success we are in colab\n    from IPython.display import display, clear_output\n    import PIL\n    import matplotlib.pyplot as plt\n    is_colab = True\nexcept:\n    is_colab = False\n\nyn_str = {True:'y',False:'n'}\n\nclass InteractBase(object):\n    EVENT_LBUTTONDOWN = 1\n    EVENT_LBUTTONUP = 2\n    EVENT_MBUTTONDOWN = 3\n    EVENT_MBUTTONUP = 4\n    EVENT_RBUTTONDOWN = 5\n    EVENT_RBUTTONUP = 6\n    EVENT_MOUSEWHEEL = 10\n\n    def __init__(self):\n        self.named_windows = {}\n        self.capture_mouse_windows = {}\n        self.capture_keys_windows = {}\n        self.mouse_events = {}\n        self.key_events = {}\n        self.pg_bar = None\n        self.focus_wnd_name = None\n        self.error_log_line_prefix = '/!\\\\ '\n\n        self.process_messages_callbacks = {}\n\n    def is_support_windows(self):\n        return False\n\n    def is_colab(self):\n        return False\n\n    def on_destroy_all_windows(self):\n        raise NotImplemented\n\n    def on_create_window (self, wnd_name):\n        raise NotImplemented\n\n    def on_destroy_window (self, wnd_name):\n        raise NotImplemented\n\n    def on_show_image (self, wnd_name, img):\n        raise NotImplemented\n\n    def on_capture_mouse (self, wnd_name):\n        raise NotImplemented\n\n    def on_capture_keys (self, wnd_name):\n        raise NotImplemented\n\n    def on_process_messages(self, sleep_time=0):\n        raise NotImplemented\n\n    def on_wait_any_key(self):\n        raise NotImplemented\n\n    def log_info(self, msg, end='\\n'):\n        if self.pg_bar is not None:\n            print (\"\\n\")\n        print (msg, end=end)\n\n    def log_err(self, msg, end='\\n'):\n        if self.pg_bar is not None:\n            print (\"\\n\")\n        print (f'{self.error_log_line_prefix}{msg}', end=end)\n\n    def named_window(self, wnd_name):\n        if wnd_name not in self.named_windows:\n            #we will show window only on first show_image\n            self.named_windows[wnd_name] = 0\n            self.focus_wnd_name = wnd_name\n        else: print(\"named_window: \", wnd_name, \" already created.\")\n\n    def destroy_all_windows(self):\n        if len( self.named_windows ) != 0:\n            self.on_destroy_all_windows()\n            self.named_windows = {}\n            self.capture_mouse_windows = {}\n            self.capture_keys_windows = {}\n            self.mouse_events = {}\n            self.key_events = {}\n            self.focus_wnd_name = None\n\n    def destroy_window(self, wnd_name):\n        if wnd_name in self.named_windows:\n            self.on_destroy_window(wnd_name)\n            self.named_windows.pop(wnd_name)\n\n            if wnd_name == self.focus_wnd_name:\n                self.focus_wnd_name = list(self.named_windows.keys())[-1] if len( self.named_windows ) != 0 else None\n\n            if wnd_name in self.capture_mouse_windows:\n                self.capture_mouse_windows.pop(wnd_name)\n\n            if wnd_name in self.capture_keys_windows:\n                self.capture_keys_windows.pop(wnd_name)\n\n            if wnd_name in self.mouse_events:\n                self.mouse_events.pop(wnd_name)\n\n            if wnd_name in self.key_events:\n                self.key_events.pop(wnd_name)\n\n    def show_image(self, wnd_name, img):\n        if wnd_name in self.named_windows:\n            if self.named_windows[wnd_name] == 0:\n                self.named_windows[wnd_name] = 1\n                self.on_create_window(wnd_name)\n                if wnd_name in self.capture_mouse_windows:\n                    self.capture_mouse(wnd_name)\n            self.on_show_image(wnd_name,img)\n        else: print(\"show_image: named_window \", wnd_name, \" not found.\")\n\n    def capture_mouse(self, wnd_name):\n        if wnd_name in self.named_windows:\n            self.capture_mouse_windows[wnd_name] = True\n            if self.named_windows[wnd_name] == 1:\n                self.on_capture_mouse(wnd_name)\n        else: print(\"capture_mouse: named_window \", wnd_name, \" not found.\")\n\n    def capture_keys(self, wnd_name):\n        if wnd_name in self.named_windows:\n            if wnd_name not in self.capture_keys_windows:\n                self.capture_keys_windows[wnd_name] = True\n                self.on_capture_keys(wnd_name)\n            else: print(\"capture_keys: already set for window \", wnd_name)\n        else: print(\"capture_keys: named_window \", wnd_name, \" not found.\")\n\n    def progress_bar(self, desc, total, leave=True, initial=0):\n        if self.pg_bar is None:\n            self.pg_bar = tqdm( total=total, desc=desc, leave=leave, ascii=True, initial=initial )\n        else: print(\"progress_bar: already set.\")\n\n    def progress_bar_inc(self, c):\n        if self.pg_bar is not None:\n            self.pg_bar.n += c\n            self.pg_bar.refresh()\n        else: print(\"progress_bar not set.\")\n\n    def progress_bar_close(self):\n        if self.pg_bar is not None:\n            self.pg_bar.close()\n            self.pg_bar = None\n        else: print(\"progress_bar not set.\")\n\n    def progress_bar_generator(self, data, desc=None, leave=True, initial=0):\n        self.pg_bar = tqdm( data, desc=desc, leave=leave, ascii=True, initial=initial )\n        for x in self.pg_bar:\n            yield x\n        self.pg_bar.close()\n        self.pg_bar = None\n\n    def add_process_messages_callback(self, func ):\n        tid = threading.get_ident()\n        callbacks = self.process_messages_callbacks.get(tid, None)\n        if callbacks is None:\n            callbacks = []\n            self.process_messages_callbacks[tid] = callbacks\n\n        callbacks.append ( func )\n\n    def process_messages(self, sleep_time=0):\n        callbacks = self.process_messages_callbacks.get(threading.get_ident(), None)\n        if callbacks is not None:\n            for func in callbacks:\n                func()\n\n        self.on_process_messages(sleep_time)\n\n    def wait_any_key(self):\n        self.on_wait_any_key()\n\n    def add_mouse_event(self, wnd_name, x, y, ev, flags):\n        if wnd_name not in self.mouse_events:\n            self.mouse_events[wnd_name] = []\n        self.mouse_events[wnd_name] += [ (x, y, ev, flags) ]\n\n    def add_key_event(self, wnd_name, ord_key, ctrl_pressed, alt_pressed, shift_pressed):\n        if wnd_name not in self.key_events:\n            self.key_events[wnd_name] = []\n        self.key_events[wnd_name] += [ (ord_key, chr(ord_key) if ord_key <= 255 else chr(0), ctrl_pressed, alt_pressed, shift_pressed) ]\n\n    def get_mouse_events(self, wnd_name):\n        ar = self.mouse_events.get(wnd_name, [])\n        self.mouse_events[wnd_name] = []\n        return ar\n\n    def get_key_events(self, wnd_name):\n        ar = self.key_events.get(wnd_name, [])\n        self.key_events[wnd_name] = []\n        return ar\n\n    def input(self, s):\n        return input(s)\n\n    def input_number(self, s, default_value, valid_list=None, show_default_value=True, add_info=None, help_message=None):\n        if show_default_value and default_value is not None:\n            s = f\"[{default_value}] {s}\"\n\n        if add_info is not None or \\\n           help_message is not None:\n            s += \" (\"\n\n        if add_info is not None:\n            s += f\" {add_info}\"\n        if help_message is not None:\n            s += \" ?:help\"\n\n        if add_info is not None or \\\n           help_message is not None:\n            s += \" )\"\n\n        s += \" : \"\n\n        while True:\n            try:\n                inp = input(s)\n                if len(inp) == 0:\n                    result = default_value\n                    break\n\n                if help_message is not None and inp == '?':\n                    print (help_message)\n                    continue\n\n                i = float(inp)\n                if (valid_list is not None) and (i not in valid_list):\n                    result = default_value\n                    break\n                result = i\n                break\n            except:\n                result = default_value\n                break\n\n        print(result)\n        return result\n\n    def input_int(self, s, default_value, valid_range=None, valid_list=None, add_info=None, show_default_value=True, help_message=None):\n        if show_default_value:\n            if len(s) != 0:\n                s = f\"[{default_value}] {s}\"\n            else:\n                s = f\"[{default_value}]\"\n\n        if add_info is not None or \\\n           valid_range is not None or \\\n           help_message is not None:\n            s += \" (\"\n\n        if valid_range is not None:\n            s += f\" {valid_range[0]}-{valid_range[1]}\"\n\n        if add_info is not None:\n            s += f\" {add_info}\"\n\n        if help_message is not None:\n            s += \" ?:help\"\n\n        if add_info is not None or \\\n           valid_range is not None or \\\n           help_message is not None:\n            s += \" )\"\n\n        s += \" : \"\n\n        while True:\n            try:\n                inp = input(s)\n                if len(inp) == 0:\n                    raise ValueError(\"\")\n\n                if help_message is not None and inp == '?':\n                    print (help_message)\n                    continue\n\n                i = int(inp)\n                if valid_range is not None:\n                    i = int(np.clip(i, valid_range[0], valid_range[1]))\n\n                if (valid_list is not None) and (i not in valid_list):\n                    i = default_value\n\n                result = i\n                break\n            except:\n                result = default_value\n                break\n        print (result)\n        return result\n\n    def input_bool(self, s, default_value, help_message=None):\n        s = f\"[{yn_str[default_value]}] {s} ( y/n\"\n\n        if help_message is not None:\n            s += \" ?:help\"\n        s += \" ) : \"\n\n        while True:\n            try:\n                inp = input(s)\n                if len(inp) == 0:\n                    raise ValueError(\"\")\n\n                if help_message is not None and inp == '?':\n                    print (help_message)\n                    continue\n\n                return bool ( {\"y\":True,\"n\":False}.get(inp.lower(), default_value) )\n            except:\n                print ( \"y\" if default_value else \"n\" )\n                return default_value\n\n    def input_str(self, s, default_value=None, valid_list=None, show_default_value=True, help_message=None):\n        if show_default_value and default_value is not None:\n            s = f\"[{default_value}] {s}\"\n\n        if valid_list is not None or \\\n           help_message is not None:\n            s += \" (\"\n\n        if valid_list is not None:\n            s += \" \" + \"/\".join(valid_list)\n\n        if help_message is not None:\n            s += \" ?:help\"\n\n        if valid_list is not None or \\\n           help_message is not None:\n            s += \" )\"\n\n        s += \" : \"\n\n\n        while True:\n            try:\n                inp = input(s)\n\n                if len(inp) == 0:\n                    if default_value is None:\n                        print(\"\")\n                        return None\n                    result = default_value\n                    break\n\n                if help_message is not None and inp == '?':\n                    print(help_message)\n                    continue\n\n                if valid_list is not None:\n                    if inp.lower() in valid_list:\n                        result = inp.lower()\n                        break\n                    if inp in valid_list:\n                        result = inp\n                        break\n                    continue\n\n                result = inp\n                break\n            except:\n                result = default_value\n                break\n\n        print(result)\n        return result\n\n    def input_process(self, stdin_fd, sq, str):\n        sys.stdin = os.fdopen(stdin_fd)\n        try:\n            inp = input (str)\n            sq.put (True)\n        except:\n            sq.put (False)\n\n    def input_in_time (self, str, max_time_sec):\n        sq = multiprocessing.Queue()\n        p = multiprocessing.Process(target=self.input_process, args=( sys.stdin.fileno(), sq, str))\n        p.daemon = True\n        p.start()\n        t = time.time()\n        inp = False\n        while True:\n            if not sq.empty():\n                inp = sq.get()\n                break\n            if time.time() - t > max_time_sec:\n                break\n\n\n        p.terminate()\n        p.join()\n\n        old_stdin = sys.stdin\n        sys.stdin = os.fdopen( os.dup(sys.stdin.fileno()) )\n        old_stdin.close()\n        return inp\n\n    def input_process_skip_pending(self, stdin_fd):\n        sys.stdin = os.fdopen(stdin_fd)\n        while True:\n            try:\n                if sys.stdin.isatty():\n                    sys.stdin.read()\n            except:\n                pass\n\n    def input_skip_pending(self):\n        if is_colab:\n            # currently it does not work on Colab\n            return\n        \"\"\"\n        skips unnecessary inputs between the dialogs\n        \"\"\"\n        p = multiprocessing.Process(target=self.input_process_skip_pending, args=( sys.stdin.fileno(), ))\n        p.daemon = True\n        p.start()\n        time.sleep(0.5)\n        p.terminate()\n        p.join()\n        sys.stdin = os.fdopen( sys.stdin.fileno() )\n\n\nclass InteractDesktop(InteractBase):\n    def __init__(self):\n        colorama.init()\n        super().__init__()\n\n    def color_red(self):\n        pass\n\n\n    def is_support_windows(self):\n        return True\n\n    def on_destroy_all_windows(self):\n        cv2.destroyAllWindows()\n\n    def on_create_window (self, wnd_name):\n        cv2.namedWindow(wnd_name)\n\n    def on_destroy_window (self, wnd_name):\n        cv2.destroyWindow(wnd_name)\n\n    def on_show_image (self, wnd_name, img):\n        cv2.imshow (wnd_name, img)\n\n    def on_capture_mouse (self, wnd_name):\n        self.last_xy = (0,0)\n\n        def onMouse(event, x, y, flags, param):\n            (inst, wnd_name) = param\n            if event == cv2.EVENT_LBUTTONDOWN: ev = InteractBase.EVENT_LBUTTONDOWN\n            elif event == cv2.EVENT_LBUTTONUP: ev = InteractBase.EVENT_LBUTTONUP\n            elif event == cv2.EVENT_RBUTTONDOWN: ev = InteractBase.EVENT_RBUTTONDOWN\n            elif event == cv2.EVENT_RBUTTONUP: ev = InteractBase.EVENT_RBUTTONUP\n            elif event == cv2.EVENT_MBUTTONDOWN: ev = InteractBase.EVENT_MBUTTONDOWN\n            elif event == cv2.EVENT_MBUTTONUP: ev = InteractBase.EVENT_MBUTTONUP\n            elif event == cv2.EVENT_MOUSEWHEEL:\n                ev = InteractBase.EVENT_MOUSEWHEEL\n                x,y = self.last_xy #fix opencv bug when window size more than screen size\n            else: ev = 0\n\n            self.last_xy = (x,y)\n            inst.add_mouse_event (wnd_name, x, y, ev, flags)\n        cv2.setMouseCallback(wnd_name, onMouse, (self,wnd_name) )\n\n    def on_capture_keys (self, wnd_name):\n        pass\n\n    def on_process_messages(self, sleep_time=0):\n\n        has_windows = False\n        has_capture_keys = False\n\n        if len(self.named_windows) != 0:\n            has_windows = True\n\n        if len(self.capture_keys_windows) != 0:\n            has_capture_keys = True\n\n        if has_windows or has_capture_keys:\n            wait_key_time = max(1, int(sleep_time*1000) )\n            ord_key = cv2.waitKeyEx(wait_key_time)\n            \n            shift_pressed = False\n            if ord_key != -1:\n                chr_key = chr(ord_key) if ord_key <= 255 else chr(0)\n\n                if chr_key >= 'A' and chr_key <= 'Z':\n                    shift_pressed = True\n                    ord_key += 32\n                elif chr_key == '?':\n                    shift_pressed = True\n                    ord_key = ord('/')\n                elif chr_key == '<':\n                    shift_pressed = True\n                    ord_key = ord(',')\n                elif chr_key == '>':\n                    shift_pressed = True\n                    ord_key = ord('.')\n        else:\n            if sleep_time != 0:\n                time.sleep(sleep_time)\n\n        if has_capture_keys and ord_key != -1:\n            self.add_key_event ( self.focus_wnd_name, ord_key, False, False, shift_pressed)\n\n    def on_wait_any_key(self):\n        cv2.waitKey(0)\n\nclass InteractColab(InteractBase):\n\n    def is_support_windows(self):\n        return False\n\n    def is_colab(self):\n        return True\n\n    def on_destroy_all_windows(self):\n        pass\n        #clear_output()\n\n    def on_create_window (self, wnd_name):\n        pass\n        #clear_output()\n\n    def on_destroy_window (self, wnd_name):\n        pass\n\n    def on_show_image (self, wnd_name, img):\n        pass\n        # # cv2 stores colors as BGR; convert to RGB\n        # if img.ndim == 3:\n        #     if img.shape[2] == 4:\n        #         img = cv2.cvtColor(img, cv2.COLOR_BGRA2RGBA)\n        #     else:\n        #         img = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)\n        # img = PIL.Image.fromarray(img)\n        # plt.imshow(img)\n        # plt.show()\n\n    def on_capture_mouse (self, wnd_name):\n        pass\n        #print(\"on_capture_mouse(): Colab does not support\")\n\n    def on_capture_keys (self, wnd_name):\n        pass\n        #print(\"on_capture_keys(): Colab does not support\")\n\n    def on_process_messages(self, sleep_time=0):\n        time.sleep(sleep_time)\n\n    def on_wait_any_key(self):\n        pass\n        #print(\"on_wait_any_key(): Colab does not support\")\n\nif is_colab:\n    interact = InteractColab()\nelse:\n    interact = InteractDesktop()\n", "core/interact/__init__.py": "from .interact import interact\n", "core/leras/nn.py": "\"\"\"\nLeras.\n\nlike lighter keras.\nThis is my lightweight neural network library written from scratch\nbased on pure tensorflow without keras.\n\nProvides:\n+ full freedom of tensorflow operations without keras model's restrictions\n+ easy model operations like in PyTorch, but in graph mode (no eager execution)\n+ convenient and understandable logic\n\nReasons why we cannot import tensorflow or any tensorflow.sub modules right here:\n1) program is changing env variables based on DeviceConfig before import tensorflow\n2) multiprocesses will import tensorflow every spawn\n\nNCHW speed up training for 10-20%.\n\"\"\"\n\nimport os\nimport sys\nimport warnings\nwarnings.simplefilter(action='ignore', category=FutureWarning)\nfrom pathlib import Path\nimport numpy as np\nfrom core.interact import interact as io\nfrom .device import Devices\n\n\nclass nn():\n    current_DeviceConfig = None\n\n    tf = None\n    tf_sess = None\n    tf_sess_config = None\n    tf_default_device_name = None\n    \n    data_format = None\n    conv2d_ch_axis = None\n    conv2d_spatial_axes = None\n\n    floatx = None\n    \n    @staticmethod\n    def initialize(device_config=None, floatx=\"float32\", data_format=\"NHWC\"):\n\n        if nn.tf is None:\n            if device_config is None:\n                device_config = nn.getCurrentDeviceConfig()\n            nn.setCurrentDeviceConfig(device_config)\n\n            # Manipulate environment variables before import tensorflow\n\n            first_run = False\n            if len(device_config.devices) != 0:\n                if sys.platform[0:3] == 'win':\n                    # Windows specific env vars\n                    if all( [ x.name == device_config.devices[0].name for x in device_config.devices ] ):\n                        devices_str = \"_\" + device_config.devices[0].name.replace(' ','_')\n                    else:\n                        devices_str = \"\"\n                        for device in device_config.devices:\n                            devices_str += \"_\" + device.name.replace(' ','_')\n\n                    compute_cache_path = Path(os.environ['APPDATA']) / 'NVIDIA' / ('ComputeCache' + devices_str)\n                    if not compute_cache_path.exists():\n                        first_run = True\n                        compute_cache_path.mkdir(parents=True, exist_ok=True)\n                    os.environ['CUDA_CACHE_PATH'] = str(compute_cache_path)\n            \n            if first_run:\n                io.log_info(\"Caching GPU kernels...\")\n\n            import tensorflow\n\n            tf_version = tensorflow.version.VERSION\n            #if tf_version is None:\n            #    tf_version = tensorflow.version.GIT_VERSION\n            if tf_version[0] == 'v':\n                tf_version = tf_version[1:]\n            if tf_version[0] == '2':\n                tf = tensorflow.compat.v1\n            else:\n                tf = tensorflow\n\n            import logging\n            # Disable tensorflow warnings\n            tf_logger = logging.getLogger('tensorflow')\n            tf_logger.setLevel(logging.ERROR)\n            \n            if tf_version[0] == '2':\n                tf.disable_v2_behavior()\n            nn.tf = tf\n\n            # Initialize framework\n            import core.leras.ops\n            import core.leras.layers\n            import core.leras.initializers\n            import core.leras.optimizers\n            import core.leras.models\n            import core.leras.archis\n            \n            # Configure tensorflow session-config\n            if len(device_config.devices) == 0:\n                config = tf.ConfigProto(device_count={'GPU': 0})\n                nn.tf_default_device_name = '/CPU:0'\n            else:\n                nn.tf_default_device_name = f'/{device_config.devices[0].tf_dev_type}:0'\n                \n                config = tf.ConfigProto()\n                config.gpu_options.visible_device_list = ','.join([str(device.index) for device in device_config.devices])\n                \n            config.gpu_options.force_gpu_compatible = True\n            config.gpu_options.allow_growth = True\n            nn.tf_sess_config = config\n            \n        if nn.tf_sess is None:\n            nn.tf_sess = tf.Session(config=nn.tf_sess_config)\n\n        if floatx == \"float32\":\n            floatx = nn.tf.float32\n        elif floatx == \"float16\":\n            floatx = nn.tf.float16\n        else:\n            raise ValueError(f\"unsupported floatx {floatx}\")\n        nn.set_floatx(floatx)\n        nn.set_data_format(data_format)\n\n    @staticmethod\n    def initialize_main_env():\n        Devices.initialize_main_env()\n\n    @staticmethod\n    def set_floatx(tf_dtype):\n        \"\"\"\n        set default float type for all layers when dtype is None for them\n        \"\"\"\n        nn.floatx = tf_dtype\n\n    @staticmethod\n    def set_data_format(data_format):\n        if data_format != \"NHWC\" and data_format != \"NCHW\":\n            raise ValueError(f\"unsupported data_format {data_format}\")\n        nn.data_format = data_format\n\n        if data_format == \"NHWC\":\n            nn.conv2d_ch_axis = 3\n            nn.conv2d_spatial_axes = [1,2]\n        elif data_format == \"NCHW\":\n            nn.conv2d_ch_axis = 1\n            nn.conv2d_spatial_axes = [2,3]\n\n    @staticmethod\n    def get4Dshape ( w, h, c ):\n        \"\"\"\n        returns 4D shape based on current data_format\n        \"\"\"\n        if nn.data_format == \"NHWC\":\n            return (None,h,w,c)\n        else:\n            return (None,c,h,w)\n\n    @staticmethod\n    def to_data_format( x, to_data_format, from_data_format):\n        if to_data_format == from_data_format:\n            return x\n\n        if to_data_format == \"NHWC\":\n            return np.transpose(x, (0,2,3,1) )\n        elif to_data_format == \"NCHW\":\n            return np.transpose(x, (0,3,1,2) )\n        else:\n            raise ValueError(f\"unsupported to_data_format {to_data_format}\")\n\n    @staticmethod\n    def getCurrentDeviceConfig():\n        if nn.current_DeviceConfig is None:\n            nn.current_DeviceConfig = DeviceConfig.BestGPU()\n        return nn.current_DeviceConfig\n\n    @staticmethod\n    def setCurrentDeviceConfig(device_config):\n        nn.current_DeviceConfig = device_config\n\n    @staticmethod\n    def reset_session():\n        if nn.tf is not None:\n            if nn.tf_sess is not None:\n                nn.tf.reset_default_graph()\n                nn.tf_sess.close()\n                nn.tf_sess = nn.tf.Session(config=nn.tf_sess_config)\n\n    @staticmethod\n    def close_session():\n        if nn.tf_sess is not None:\n            nn.tf.reset_default_graph()\n            nn.tf_sess.close()\n            nn.tf_sess = None\n\n    @staticmethod\n    def ask_choose_device_idxs(choose_only_one=False, allow_cpu=True, suggest_best_multi_gpu=False, suggest_all_gpu=False):\n        devices = Devices.getDevices()\n        if len(devices) == 0:\n            return []\n\n        all_devices_indexes = [device.index for device in devices]\n\n        if choose_only_one:\n            suggest_best_multi_gpu = False\n            suggest_all_gpu = False\n\n        if suggest_all_gpu:\n            best_device_indexes = all_devices_indexes\n        elif suggest_best_multi_gpu:\n            best_device_indexes = [device.index for device in devices.get_equal_devices(devices.get_best_device()) ]\n        else:\n            best_device_indexes = [ devices.get_best_device().index ]\n        best_device_indexes = \",\".join([str(x) for x in best_device_indexes])\n\n        io.log_info (\"\")\n        if choose_only_one:\n            io.log_info (\"Choose one GPU idx.\")\n        else:\n            io.log_info (\"Choose one or several GPU idxs (separated by comma).\")\n        io.log_info (\"\")\n\n        if allow_cpu:\n            io.log_info (\"[CPU] : CPU\")\n        for device in devices:\n            io.log_info (f\"  [{device.index}] : {device.name}\")\n\n        io.log_info (\"\")\n\n        while True:\n            try:\n                if choose_only_one:\n                    choosed_idxs = io.input_str(\"Which GPU index to choose?\", best_device_indexes)\n                else:\n                    choosed_idxs = io.input_str(\"Which GPU indexes to choose?\", best_device_indexes)\n\n                if allow_cpu and choosed_idxs.lower() == \"cpu\":\n                    choosed_idxs = []\n                    break\n\n                choosed_idxs = [ int(x) for x in choosed_idxs.split(',') ]\n\n                if choose_only_one:\n                    if len(choosed_idxs) == 1:\n                        break\n                else:\n                    if all( [idx in all_devices_indexes for idx in choosed_idxs] ):\n                        break\n            except:\n                pass\n        io.log_info (\"\")\n\n        return choosed_idxs\n\n    class DeviceConfig():\n        @staticmethod\n        def ask_choose_device(*args, **kwargs):\n            return nn.DeviceConfig.GPUIndexes( nn.ask_choose_device_idxs(*args,**kwargs) )\n        \n        def __init__ (self, devices=None):\n            devices = devices or []\n\n            if not isinstance(devices, Devices):\n                devices = Devices(devices)\n\n            self.devices = devices\n            self.cpu_only = len(devices) == 0\n\n        @staticmethod\n        def BestGPU():\n            devices = Devices.getDevices()\n            if len(devices) == 0:\n                return nn.DeviceConfig.CPU()\n\n            return nn.DeviceConfig([devices.get_best_device()])\n\n        @staticmethod\n        def WorstGPU():\n            devices = Devices.getDevices()\n            if len(devices) == 0:\n                return nn.DeviceConfig.CPU()\n\n            return nn.DeviceConfig([devices.get_worst_device()])\n\n        @staticmethod\n        def GPUIndexes(indexes):\n            if len(indexes) != 0:\n                devices = Devices.getDevices().get_devices_from_index_list(indexes)\n            else:\n                devices = []\n\n            return nn.DeviceConfig(devices)\n\n        @staticmethod\n        def CPU():\n            return nn.DeviceConfig([])\n", "core/leras/device.py": "import sys\nimport ctypes\nimport os\nimport multiprocessing\nimport json\nimport time\nfrom pathlib import Path\nfrom core.interact import interact as io\n\n\nclass Device(object):\n    def __init__(self, index, tf_dev_type, name, total_mem, free_mem):\n        self.index = index\n        self.tf_dev_type = tf_dev_type\n        self.name = name\n        \n        self.total_mem = total_mem\n        self.total_mem_gb = total_mem / 1024**3\n        self.free_mem = free_mem\n        self.free_mem_gb = free_mem / 1024**3\n\n    def __str__(self):\n        return f\"[{self.index}]:[{self.name}][{self.free_mem_gb:.3}/{self.total_mem_gb :.3}]\"\n\nclass Devices(object):\n    all_devices = None\n\n    def __init__(self, devices):\n        self.devices = devices\n\n    def __len__(self):\n        return len(self.devices)\n\n    def __getitem__(self, key):\n        result = self.devices[key]\n        if isinstance(key, slice):\n            return Devices(result)\n        return result\n\n    def __iter__(self):\n        for device in self.devices:\n            yield device\n\n    def get_best_device(self):\n        result = None\n        idx_mem = 0\n        for device in self.devices:\n            mem = device.total_mem\n            if mem > idx_mem:\n                result = device\n                idx_mem = mem\n        return result\n\n    def get_worst_device(self):\n        result = None\n        idx_mem = sys.maxsize\n        for device in self.devices:\n            mem = device.total_mem\n            if mem < idx_mem:\n                result = device\n                idx_mem = mem\n        return result\n\n    def get_device_by_index(self, idx):\n        for device in self.devices:\n            if device.index == idx:\n                return device\n        return None\n\n    def get_devices_from_index_list(self, idx_list):\n        result = []\n        for device in self.devices:\n            if device.index in idx_list:\n                result += [device]\n        return Devices(result)\n\n    def get_equal_devices(self, device):\n        device_name = device.name\n        result = []\n        for device in self.devices:\n            if device.name == device_name:\n                result.append (device)\n        return Devices(result)\n\n    def get_devices_at_least_mem(self, totalmemsize_gb):\n        result = []\n        for device in self.devices:\n            if device.total_mem >= totalmemsize_gb*(1024**3):\n                result.append (device)\n        return Devices(result)\n\n    @staticmethod\n    def _get_tf_devices_proc(q : multiprocessing.Queue):\n        \n        if sys.platform[0:3] == 'win':\n            compute_cache_path = Path(os.environ['APPDATA']) / 'NVIDIA' / ('ComputeCache_ALL')\n            os.environ['CUDA_CACHE_PATH'] = str(compute_cache_path)\n            if not compute_cache_path.exists():\n                io.log_info(\"Caching GPU kernels...\")\n                compute_cache_path.mkdir(parents=True, exist_ok=True)\n                \n        import tensorflow\n        \n        tf_version = tensorflow.version.VERSION\n        #if tf_version is None:\n        #    tf_version = tensorflow.version.GIT_VERSION\n        if tf_version[0] == 'v':\n            tf_version = tf_version[1:]\n        if tf_version[0] == '2':\n            tf = tensorflow.compat.v1\n        else:\n            tf = tensorflow\n        \n        import logging\n        # Disable tensorflow warnings\n        tf_logger = logging.getLogger('tensorflow')\n        tf_logger.setLevel(logging.ERROR)\n\n        from tensorflow.python.client import device_lib\n\n        devices = []\n        \n        physical_devices = device_lib.list_local_devices()\n        physical_devices_f = {}\n        for dev in physical_devices:\n            dev_type = dev.device_type\n            dev_tf_name = dev.name\n            dev_tf_name = dev_tf_name[ dev_tf_name.index(dev_type) : ]\n            \n            dev_idx = int(dev_tf_name.split(':')[-1])\n            \n            if dev_type in ['GPU','DML']:\n                dev_name = dev_tf_name\n                \n                dev_desc = dev.physical_device_desc\n                if len(dev_desc) != 0:\n                    if dev_desc[0] == '{':\n                        dev_desc_json = json.loads(dev_desc)\n                        dev_desc_json_name = dev_desc_json.get('name',None)\n                        if dev_desc_json_name is not None:\n                            dev_name = dev_desc_json_name\n                    else:\n                        for param, value in ( v.split(':') for v in dev_desc.split(',') ):\n                            param = param.strip()\n                            value = value.strip()\n                            if param == 'name':\n                                dev_name = value\n                                break\n                \n                physical_devices_f[dev_idx] = (dev_type, dev_name, dev.memory_limit)\n                        \n        q.put(physical_devices_f)\n        time.sleep(0.1)\n        \n        \n    @staticmethod\n    def initialize_main_env():\n        if int(os.environ.get(\"NN_DEVICES_INITIALIZED\", 0)) != 0:\n            return\n            \n        if 'CUDA_VISIBLE_DEVICES' in os.environ.keys():\n            os.environ.pop('CUDA_VISIBLE_DEVICES')\n        \n        os.environ['TF_DIRECTML_KERNEL_CACHE_SIZE'] = '2500'\n        os.environ['CUDA_\u200bCACHE_\u200bMAXSIZE'] = '2147483647'\n        os.environ['TF_MIN_GPU_MULTIPROCESSOR_COUNT'] = '2'\n        os.environ['TF_CPP_MIN_LOG_LEVEL'] = '3' # tf log errors only\n        \n        q = multiprocessing.Queue()\n        p = multiprocessing.Process(target=Devices._get_tf_devices_proc, args=(q,), daemon=True)\n        p.start()\n        p.join()\n        \n        visible_devices = q.get()\n\n        os.environ['NN_DEVICES_INITIALIZED'] = '1'\n        os.environ['NN_DEVICES_COUNT'] = str(len(visible_devices))\n        \n        for i in visible_devices:\n            dev_type, name, total_mem = visible_devices[i]\n\n            os.environ[f'NN_DEVICE_{i}_TF_DEV_TYPE'] = dev_type\n            os.environ[f'NN_DEVICE_{i}_NAME'] = name\n            os.environ[f'NN_DEVICE_{i}_TOTAL_MEM'] = str(total_mem)\n            os.environ[f'NN_DEVICE_{i}_FREE_MEM'] = str(total_mem)\n            \n        \n\n    @staticmethod\n    def getDevices():\n        if Devices.all_devices is None:\n            if int(os.environ.get(\"NN_DEVICES_INITIALIZED\", 0)) != 1:\n                raise Exception(\"nn devices are not initialized. Run initialize_main_env() in main process.\")\n            devices = []\n            for i in range ( int(os.environ['NN_DEVICES_COUNT']) ):\n                devices.append ( Device(index=i,\n                                        tf_dev_type=os.environ[f'NN_DEVICE_{i}_TF_DEV_TYPE'],\n                                        name=os.environ[f'NN_DEVICE_{i}_NAME'],\n                                        total_mem=int(os.environ[f'NN_DEVICE_{i}_TOTAL_MEM']),\n                                        free_mem=int(os.environ[f'NN_DEVICE_{i}_FREE_MEM']), )\n                                )\n            Devices.all_devices = Devices(devices)\n\n        return Devices.all_devices\n\n\"\"\"\n\n        \n        # {'name'      : name.split(b'\\0', 1)[0].decode(),\n        #     'total_mem' : totalMem.value\n        # }\n\n        \n        \n        \n        \n        return\n\n        \n        \n        \n        min_cc = int(os.environ.get(\"TF_MIN_REQ_CAP\", 35))\n        libnames = ('libcuda.so', 'libcuda.dylib', 'nvcuda.dll')\n        for libname in libnames:\n            try:\n                cuda = ctypes.CDLL(libname)\n            except:\n                continue\n            else:\n                break\n        else:\n            return Devices([])\n\n        nGpus = ctypes.c_int()\n        name = b' ' * 200\n        cc_major = ctypes.c_int()\n        cc_minor = ctypes.c_int()\n        freeMem = ctypes.c_size_t()\n        totalMem = ctypes.c_size_t()\n\n        result = ctypes.c_int()\n        device = ctypes.c_int()\n        context = ctypes.c_void_p()\n        error_str = ctypes.c_char_p()\n\n        devices = []\n\n        if cuda.cuInit(0) == 0 and \\\n            cuda.cuDeviceGetCount(ctypes.byref(nGpus)) == 0:\n            for i in range(nGpus.value):\n                if cuda.cuDeviceGet(ctypes.byref(device), i) != 0 or \\\n                    cuda.cuDeviceGetName(ctypes.c_char_p(name), len(name), device) != 0 or \\\n                    cuda.cuDeviceComputeCapability(ctypes.byref(cc_major), ctypes.byref(cc_minor), device) != 0:\n                    continue\n\n                if cuda.cuCtxCreate_v2(ctypes.byref(context), 0, device) == 0:\n                    if cuda.cuMemGetInfo_v2(ctypes.byref(freeMem), ctypes.byref(totalMem)) == 0:\n                        cc = cc_major.value * 10 + cc_minor.value\n                        if cc >= min_cc:\n                            devices.append ( {'name'      : name.split(b'\\0', 1)[0].decode(),\n                                              'total_mem' : totalMem.value,\n                                              'free_mem'  : freeMem.value,\n                                              'cc'        : cc\n                                              })\n                    cuda.cuCtxDetach(context)\n\n        os.environ['NN_DEVICES_COUNT'] = str(len(devices))\n        for i, device in enumerate(devices):\n            os.environ[f'NN_DEVICE_{i}_NAME'] = device['name']\n            os.environ[f'NN_DEVICE_{i}_TOTAL_MEM'] = str(device['total_mem'])\n            os.environ[f'NN_DEVICE_{i}_FREE_MEM'] = str(device['free_mem'])\n            os.environ[f'NN_DEVICE_{i}_CC'] = str(device['cc'])\n\"\"\"", "core/leras/__init__.py": "from .nn import nn", "core/leras/models/XSeg.py": "from core.leras import nn\ntf = nn.tf\n\nclass XSeg(nn.ModelBase):\n    \n    def on_build (self, in_ch, base_ch, out_ch):\n        \n        class ConvBlock(nn.ModelBase):\n            def on_build(self, in_ch, out_ch):              \n                self.conv = nn.Conv2D (in_ch, out_ch, kernel_size=3, padding='SAME')\n                self.frn = nn.FRNorm2D(out_ch)\n                self.tlu = nn.TLU(out_ch)\n\n            def forward(self, x):                \n                x = self.conv(x)\n                x = self.frn(x)\n                x = self.tlu(x)\n                return x\n\n        class UpConvBlock(nn.ModelBase):\n            def on_build(self, in_ch, out_ch):\n                self.conv = nn.Conv2DTranspose (in_ch, out_ch, kernel_size=3, padding='SAME')\n                self.frn = nn.FRNorm2D(out_ch)\n                self.tlu = nn.TLU(out_ch)\n\n            def forward(self, x):\n                x = self.conv(x)\n                x = self.frn(x)\n                x = self.tlu(x)\n                return x\n                \n        self.base_ch = base_ch\n\n        self.conv01 = ConvBlock(in_ch, base_ch)\n        self.conv02 = ConvBlock(base_ch, base_ch)\n        self.bp0 = nn.BlurPool (filt_size=4)\n\n        self.conv11 = ConvBlock(base_ch, base_ch*2)\n        self.conv12 = ConvBlock(base_ch*2, base_ch*2)\n        self.bp1 = nn.BlurPool (filt_size=3)\n\n        self.conv21 = ConvBlock(base_ch*2, base_ch*4)\n        self.conv22 = ConvBlock(base_ch*4, base_ch*4)\n        self.bp2 = nn.BlurPool (filt_size=2)\n\n        self.conv31 = ConvBlock(base_ch*4, base_ch*8)\n        self.conv32 = ConvBlock(base_ch*8, base_ch*8)\n        self.conv33 = ConvBlock(base_ch*8, base_ch*8)\n        self.bp3 = nn.BlurPool (filt_size=2)\n\n        self.conv41 = ConvBlock(base_ch*8, base_ch*8)\n        self.conv42 = ConvBlock(base_ch*8, base_ch*8)\n        self.conv43 = ConvBlock(base_ch*8, base_ch*8)\n        self.bp4 = nn.BlurPool (filt_size=2)\n        \n        self.conv51 = ConvBlock(base_ch*8, base_ch*8)\n        self.conv52 = ConvBlock(base_ch*8, base_ch*8)\n        self.conv53 = ConvBlock(base_ch*8, base_ch*8)\n        self.bp5 = nn.BlurPool (filt_size=2)\n        \n        self.dense1 = nn.Dense ( 4*4* base_ch*8, 512)\n        self.dense2 = nn.Dense ( 512, 4*4* base_ch*8)\n                \n        self.up5 = UpConvBlock (base_ch*8, base_ch*4)\n        self.uconv53 = ConvBlock(base_ch*12, base_ch*8)\n        self.uconv52 = ConvBlock(base_ch*8, base_ch*8)\n        self.uconv51 = ConvBlock(base_ch*8, base_ch*8)\n        \n        self.up4 = UpConvBlock (base_ch*8, base_ch*4)\n        self.uconv43 = ConvBlock(base_ch*12, base_ch*8)\n        self.uconv42 = ConvBlock(base_ch*8, base_ch*8)\n        self.uconv41 = ConvBlock(base_ch*8, base_ch*8)\n\n        self.up3 = UpConvBlock (base_ch*8, base_ch*4)\n        self.uconv33 = ConvBlock(base_ch*12, base_ch*8)\n        self.uconv32 = ConvBlock(base_ch*8, base_ch*8)\n        self.uconv31 = ConvBlock(base_ch*8, base_ch*8)\n\n        self.up2 = UpConvBlock (base_ch*8, base_ch*4)\n        self.uconv22 = ConvBlock(base_ch*8, base_ch*4)\n        self.uconv21 = ConvBlock(base_ch*4, base_ch*4)\n\n        self.up1 = UpConvBlock (base_ch*4, base_ch*2)\n        self.uconv12 = ConvBlock(base_ch*4, base_ch*2)\n        self.uconv11 = ConvBlock(base_ch*2, base_ch*2)\n\n        self.up0 = UpConvBlock (base_ch*2, base_ch)\n        self.uconv02 = ConvBlock(base_ch*2, base_ch)\n        self.uconv01 = ConvBlock(base_ch, base_ch)\n        self.out_conv = nn.Conv2D (base_ch, out_ch, kernel_size=3, padding='SAME')\n    \n        \n    def forward(self, inp, pretrain=False):\n        x = inp\n\n        x = self.conv01(x)\n        x = x0 = self.conv02(x)\n        x = self.bp0(x)\n\n        x = self.conv11(x)\n        x = x1 = self.conv12(x)\n        x = self.bp1(x)\n\n        x = self.conv21(x)\n        x = x2 = self.conv22(x)\n        x = self.bp2(x)\n\n        x = self.conv31(x)\n        x = self.conv32(x)\n        x = x3 = self.conv33(x)\n        x = self.bp3(x)\n\n        x = self.conv41(x)\n        x = self.conv42(x)\n        x = x4 = self.conv43(x)\n        x = self.bp4(x)\n\n        x = self.conv51(x)\n        x = self.conv52(x)\n        x = x5 = self.conv53(x)\n        x = self.bp5(x)\n        \n        x = nn.flatten(x)\n        x = self.dense1(x)\n        x = self.dense2(x)\n        x = nn.reshape_4D (x, 4, 4, self.base_ch*8 )\n                          \n        x = self.up5(x)\n        if pretrain:\n            x5 = tf.zeros_like(x5)\n        x = self.uconv53(tf.concat([x,x5],axis=nn.conv2d_ch_axis))\n        x = self.uconv52(x)\n        x = self.uconv51(x)\n        \n        x = self.up4(x)\n        if pretrain:\n            x4 = tf.zeros_like(x4)\n        x = self.uconv43(tf.concat([x,x4],axis=nn.conv2d_ch_axis))\n        x = self.uconv42(x)\n        x = self.uconv41(x)\n\n        x = self.up3(x)\n        if pretrain:\n            x3 = tf.zeros_like(x3)\n        x = self.uconv33(tf.concat([x,x3],axis=nn.conv2d_ch_axis))\n        x = self.uconv32(x)\n        x = self.uconv31(x)\n\n        x = self.up2(x)\n        if pretrain:\n            x2 = tf.zeros_like(x2)\n        x = self.uconv22(tf.concat([x,x2],axis=nn.conv2d_ch_axis))\n        x = self.uconv21(x)\n\n        x = self.up1(x)\n        if pretrain:\n            x1 = tf.zeros_like(x1)\n        x = self.uconv12(tf.concat([x,x1],axis=nn.conv2d_ch_axis))\n        x = self.uconv11(x)\n\n        x = self.up0(x)\n        if pretrain:\n            x0 = tf.zeros_like(x0)\n        x = self.uconv02(tf.concat([x,x0],axis=nn.conv2d_ch_axis))\n        x = self.uconv01(x)\n\n        logits = self.out_conv(x)\n        return logits, tf.nn.sigmoid(logits)\n\nnn.XSeg = XSeg", "core/leras/models/PatchDiscriminator.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\n\npatch_discriminator_kernels = \\\n    { 1  : (512, [ [1,1] ]),\n      2  : (512, [ [2,1] ]),\n      3  : (512, [ [2,1], [2,1] ]),\n      4  : (512, [ [2,2], [2,2] ]),\n      5  : (512, [ [3,2], [2,2] ]),\n      6  : (512, [ [4,2], [2,2] ]),\n      7  : (512, [ [3,2], [3,2] ]),\n      8  : (512, [ [4,2], [3,2] ]),\n      9  : (512, [ [3,2], [4,2] ]),\n      10 : (512, [ [4,2], [4,2] ]),\n      11 : (512, [ [3,2], [3,2], [2,1] ]),\n      12 : (512, [ [4,2], [3,2], [2,1] ]),\n      13 : (512, [ [3,2], [4,2], [2,1] ]),\n      14 : (512, [ [4,2], [4,2], [2,1] ]),\n      15 : (512, [ [3,2], [3,2], [3,1] ]),\n      16 : (512, [ [4,2], [3,2], [3,1] ]),\n      17 : (512, [ [3,2], [4,2], [3,1] ]),\n      18 : (512, [ [4,2], [4,2], [3,1] ]),\n      19 : (512, [ [3,2], [3,2], [4,1] ]),\n      20 : (512, [ [4,2], [3,2], [4,1] ]),\n      21 : (512, [ [3,2], [4,2], [4,1] ]),\n      22 : (512, [ [4,2], [4,2], [4,1] ]),\n      23 : (256, [ [3,2], [3,2], [3,2], [2,1] ]),\n      24 : (256, [ [4,2], [3,2], [3,2], [2,1] ]),\n      25 : (256, [ [3,2], [4,2], [3,2], [2,1] ]),\n      26 : (256, [ [4,2], [4,2], [3,2], [2,1] ]),\n      27 : (256, [ [3,2], [4,2], [4,2], [2,1] ]),\n      28 : (256, [ [4,2], [3,2], [4,2], [2,1] ]),\n      29 : (256, [ [3,2], [4,2], [4,2], [2,1] ]),\n      30 : (256, [ [4,2], [4,2], [4,2], [2,1] ]),\n      31 : (256, [ [3,2], [3,2], [3,2], [3,1] ]),\n      32 : (256, [ [4,2], [3,2], [3,2], [3,1] ]),\n      33 : (256, [ [3,2], [4,2], [3,2], [3,1] ]),\n      34 : (256, [ [4,2], [4,2], [3,2], [3,1] ]),\n      35 : (256, [ [3,2], [4,2], [4,2], [3,1] ]),\n      36 : (256, [ [4,2], [3,2], [4,2], [3,1] ]),\n      37 : (256, [ [3,2], [4,2], [4,2], [3,1] ]),\n      38 : (256, [ [4,2], [4,2], [4,2], [3,1] ]),\n      39 : (256, [ [3,2], [3,2], [3,2], [4,1] ]),\n      40 : (256, [ [4,2], [3,2], [3,2], [4,1] ]),\n      41 : (256, [ [3,2], [4,2], [3,2], [4,1] ]),\n      42 : (256, [ [4,2], [4,2], [3,2], [4,1] ]),\n      43 : (256, [ [3,2], [4,2], [4,2], [4,1] ]),\n      44 : (256, [ [4,2], [3,2], [4,2], [4,1] ]),\n      45 : (256, [ [3,2], [4,2], [4,2], [4,1] ]),\n      46 : (256, [ [4,2], [4,2], [4,2], [4,1] ]),\n    }\n\n\nclass PatchDiscriminator(nn.ModelBase):\n    def on_build(self, patch_size, in_ch, base_ch=None, conv_kernel_initializer=None):\n        suggested_base_ch, kernels_strides = patch_discriminator_kernels[patch_size]\n\n        if base_ch is None:\n            base_ch = suggested_base_ch\n\n        prev_ch = in_ch\n        self.convs = []\n        for i, (kernel_size, strides) in enumerate(kernels_strides):\n            cur_ch = base_ch * min( (2**i), 8 )\n\n            self.convs.append ( nn.Conv2D( prev_ch, cur_ch, kernel_size=kernel_size, strides=strides, padding='SAME', kernel_initializer=conv_kernel_initializer) )\n            prev_ch = cur_ch\n\n        self.out_conv =  nn.Conv2D( prev_ch, 1, kernel_size=1, padding='VALID', kernel_initializer=conv_kernel_initializer)\n\n    def forward(self, x):\n        for conv in self.convs:\n            x = tf.nn.leaky_relu( conv(x), 0.1 )\n        return self.out_conv(x)\n\nnn.PatchDiscriminator = PatchDiscriminator\n\nclass UNetPatchDiscriminator(nn.ModelBase):\n    \"\"\"\n    Inspired by https://arxiv.org/abs/2002.12655 \"A U-Net Based Discriminator for Generative Adversarial Networks\"\n    \"\"\"\n    def calc_receptive_field_size(self, layers):\n        \"\"\"\n        result the same as https://fomoro.com/research/article/receptive-field-calculatorindex.html\n        \"\"\"\n        rf = 0\n        ts = 1\n        for i, (k, s) in enumerate(layers):\n            if i == 0:\n                rf = k\n            else:\n                rf += (k-1)*ts\n            ts *= s\n        return rf\n\n    def find_archi(self, target_patch_size, max_layers=9):\n        \"\"\"\n        Find the best configuration of layers using only 3x3 convs for target patch size\n        \"\"\"\n        s = {}\n        for layers_count in range(1,max_layers+1):\n            val = 1 << (layers_count-1)\n            while True:\n                val -= 1\n\n                layers = []\n                sum_st = 0\n                layers.append ( [3, 2])\n                sum_st += 2\n                for i in range(layers_count-1):\n                    st = 1 + (1 if val & (1 << i) !=0 else 0 )\n                    layers.append ( [3, st ])\n                    sum_st += st                \n\n                rf = self.calc_receptive_field_size(layers)\n\n                s_rf = s.get(rf, None)\n                if s_rf is None:\n                    s[rf] = (layers_count, sum_st, layers)\n                else:\n                    if layers_count < s_rf[0] or \\\n                    ( layers_count == s_rf[0] and sum_st > s_rf[1] ):\n                        s[rf] = (layers_count, sum_st, layers)\n\n                if val == 0:\n                    break\n\n        x = sorted(list(s.keys()))\n        q=x[np.abs(np.array(x)-target_patch_size).argmin()]\n        return s[q][2]\n\n    def on_build(self, patch_size, in_ch, base_ch = 16, use_fp16 = False):\n        self.use_fp16 = use_fp16\n        conv_dtype = tf.float16 if use_fp16 else tf.float32 \n        \n        class ResidualBlock(nn.ModelBase):\n            def on_build(self, ch, kernel_size=3 ):\n                self.conv1 = nn.Conv2D( ch, ch, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n                self.conv2 = nn.Conv2D( ch, ch, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n\n            def forward(self, inp):\n                x = self.conv1(inp)\n                x = tf.nn.leaky_relu(x, 0.2)\n                x = self.conv2(x)\n                x = tf.nn.leaky_relu(inp + x, 0.2)\n                return x\n\n        prev_ch = in_ch\n        self.convs = []\n        self.upconvs = []\n        layers = self.find_archi(patch_size)\n        \n        level_chs = { i-1:v for i,v in enumerate([ min( base_ch * (2**i), 512 ) for i in range(len(layers)+1)]) }\n\n        self.in_conv = nn.Conv2D( in_ch, level_chs[-1], kernel_size=1, padding='VALID', dtype=conv_dtype)\n\n        for i, (kernel_size, strides) in enumerate(layers):\n            self.convs.append ( nn.Conv2D( level_chs[i-1], level_chs[i], kernel_size=kernel_size, strides=strides, padding='SAME', dtype=conv_dtype) )\n\n            self.upconvs.insert (0, nn.Conv2DTranspose( level_chs[i]*(2 if i != len(layers)-1 else 1), level_chs[i-1], kernel_size=kernel_size, strides=strides, padding='SAME', dtype=conv_dtype) )\n\n        self.out_conv = nn.Conv2D( level_chs[-1]*2, 1, kernel_size=1, padding='VALID', dtype=conv_dtype)\n\n        self.center_out  =  nn.Conv2D( level_chs[len(layers)-1], 1, kernel_size=1, padding='VALID', dtype=conv_dtype)\n        self.center_conv =  nn.Conv2D( level_chs[len(layers)-1], level_chs[len(layers)-1], kernel_size=1, padding='VALID', dtype=conv_dtype)\n\n\n    def forward(self, x):\n        if self.use_fp16:\n            x = tf.cast(x, tf.float16)\n            \n        x = tf.nn.leaky_relu( self.in_conv(x), 0.2 )\n\n        encs = []\n        for conv in self.convs:\n            encs.insert(0, x)\n            x = tf.nn.leaky_relu( conv(x), 0.2 )\n            \n        center_out, x = self.center_out(x), tf.nn.leaky_relu( self.center_conv(x), 0.2 )\n\n        for i, (upconv, enc) in enumerate(zip(self.upconvs, encs)):\n            x = tf.nn.leaky_relu( upconv(x), 0.2 )\n            x = tf.concat( [enc, x], axis=nn.conv2d_ch_axis)\n\n        x = self.out_conv(x)\n        \n        if self.use_fp16:\n            center_out = tf.cast(center_out, tf.float32)\n            x = tf.cast(x, tf.float32)\n\n        return center_out, x\n\nnn.UNetPatchDiscriminator = UNetPatchDiscriminator\n", "core/leras/models/CodeDiscriminator.py": "from core.leras import nn\ntf = nn.tf\n\nclass CodeDiscriminator(nn.ModelBase):\n    def on_build(self, in_ch, code_res, ch=256, conv_kernel_initializer=None):            \n        n_downscales = 1 + code_res // 8\n\n        self.convs = []\n        prev_ch = in_ch\n        for i in range(n_downscales):\n            cur_ch = ch * min( (2**i), 8 )\n            self.convs.append ( nn.Conv2D( prev_ch, cur_ch, kernel_size=4 if i == 0 else 3, strides=2, padding='SAME', kernel_initializer=conv_kernel_initializer) )\n            prev_ch = cur_ch\n\n        self.out_conv =  nn.Conv2D( prev_ch, 1, kernel_size=1, padding='VALID', kernel_initializer=conv_kernel_initializer)\n\n    def forward(self, x):\n        for conv in self.convs:\n            x = tf.nn.leaky_relu( conv(x), 0.1 )\n        return self.out_conv(x)\n        \nnn.CodeDiscriminator = CodeDiscriminator", "core/leras/models/__init__.py": "from .ModelBase import *\nfrom .PatchDiscriminator import *\nfrom .CodeDiscriminator import *\nfrom .XSeg import *", "core/leras/models/ModelBase.py": "import types\nimport numpy as np\nfrom core.interact import interact as io\nfrom core.leras import nn\ntf = nn.tf\n\nclass ModelBase(nn.Saveable):\n    def __init__(self, *args, name=None, **kwargs):\n        super().__init__(name=name)\n        self.layers = []\n        self.layers_by_name = {}\n        self.built = False\n        self.args = args\n        self.kwargs = kwargs\n        self.run_placeholders = None\n\n    def _build_sub(self, layer, name):\n        if isinstance (layer, list):\n            for i,sublayer in enumerate(layer):\n                self._build_sub(sublayer, f\"{name}_{i}\")\n        elif isinstance (layer, dict):\n            for subname in layer.keys():\n                sublayer = layer[subname]\n                self._build_sub(sublayer, f\"{name}_{subname}\")\n        elif isinstance (layer, nn.LayerBase) or \\\n                isinstance (layer, ModelBase):\n\n            if layer.name is None:\n                layer.name = name\n\n            if isinstance (layer, nn.LayerBase):\n                with tf.variable_scope(layer.name):\n                    layer.build_weights()\n            elif isinstance (layer, ModelBase):\n                layer.build()\n\n            self.layers.append (layer)\n            self.layers_by_name[layer.name] = layer\n\n    def xor_list(self, lst1, lst2):\n        return  [value for value in lst1+lst2 if (value not in lst1) or (value not in lst2)  ]\n\n    def build(self):\n        with tf.variable_scope(self.name):\n\n            current_vars = []\n            generator = None\n            while True:\n\n                if generator is None:\n                    generator = self.on_build(*self.args, **self.kwargs)\n                    if not isinstance(generator, types.GeneratorType):\n                        generator = None\n\n                if generator is not None:\n                    try:\n                        next(generator)\n                    except StopIteration:\n                        generator = None\n\n                v = vars(self)\n                new_vars = self.xor_list (current_vars, list(v.keys()) )\n\n                for name in new_vars:\n                    self._build_sub(v[name],name)\n\n                current_vars += new_vars\n\n                if generator is None:\n                    break\n\n        self.built = True\n\n    #override\n    def get_weights(self):\n        if not self.built:\n            self.build()\n\n        weights = []\n        for layer in self.layers:\n            weights += layer.get_weights()\n        return weights\n\n    def get_layer_by_name(self, name):\n        return self.layers_by_name.get(name, None)\n\n    def get_layers(self):\n        if not self.built:\n            self.build()\n        layers = []\n        for layer in self.layers:\n            if isinstance (layer, nn.LayerBase):\n                layers.append(layer)\n            else:\n                layers += layer.get_layers()\n        return layers\n\n    #override\n    def on_build(self, *args, **kwargs):\n        \"\"\"\n        init model layers here\n\n        return 'yield' if build is not finished\n                    therefore dependency models will be initialized\n        \"\"\"\n        pass\n\n    #override\n    def forward(self, *args, **kwargs):\n        #flow layers/models/tensors here\n        pass\n\n    def __call__(self, *args, **kwargs):\n        if not self.built:\n            self.build()\n\n        return self.forward(*args, **kwargs)\n\n    # def compute_output_shape(self, shapes):\n    #     if not self.built:\n    #         self.build()\n\n    #     not_list = False\n    #     if not isinstance(shapes, list):\n    #         not_list = True\n    #         shapes = [shapes]\n\n    #     with tf.device('/CPU:0'):\n    #         # CPU tensors will not impact any performance, only slightly RAM \"leakage\"\n    #         phs = []\n    #         for dtype,sh in shapes:\n    #             phs += [ tf.placeholder(dtype, sh) ]\n\n    #         result = self.__call__(phs[0] if not_list else phs)\n\n    #         if not isinstance(result, list):\n    #             result = [result]\n\n    #         result_shapes = []\n\n    #         for t in result:\n    #             result_shapes += [ t.shape.as_list() ]\n\n    #         return result_shapes[0] if not_list else result_shapes\n\n    def build_for_run(self, shapes_list):\n        if not isinstance(shapes_list, list):\n            raise ValueError(\"shapes_list must be a list.\")\n\n        self.run_placeholders = []\n        for dtype,sh in shapes_list:\n            self.run_placeholders.append ( tf.placeholder(dtype, sh) )\n\n        self.run_output = self.__call__(self.run_placeholders)\n\n    def run (self, inputs):\n        if self.run_placeholders is None:\n            raise Exception (\"Model didn't build for run.\")\n\n        if len(inputs) != len(self.run_placeholders):\n            raise ValueError(\"len(inputs) != self.run_placeholders\")\n\n        feed_dict = {}\n        for ph, inp in zip(self.run_placeholders, inputs):\n            feed_dict[ph] = inp\n\n        return nn.tf_sess.run ( self.run_output, feed_dict=feed_dict)\n\n    def summary(self):\n        layers = self.get_layers()\n        layers_names = []\n        layers_params = []\n\n        max_len_str = 0\n        max_len_param_str = 0\n        delim_str = \"-\"\n\n        total_params = 0\n\n        #Get layers names and str lenght for delim\n        for l in layers:\n            if len(str(l))>max_len_str:\n                max_len_str = len(str(l))\n            layers_names+=[str(l).capitalize()]\n\n        #Get params for each layer\n        layers_params = [ int(np.sum(np.prod(w.shape) for w in l.get_weights())) for l in layers ]\n        total_params = np.sum(layers_params)\n\n        #Get str lenght for delim\n        for p in layers_params:\n            if len(str(p))>max_len_param_str:\n                max_len_param_str=len(str(p))\n\n        #Set delim\n        for i in range(max_len_str+max_len_param_str+3):\n            delim_str += \"-\"\n\n        output = \"\\n\"+delim_str+\"\\n\"\n\n        #Format model name str\n        model_name_str = \"| \"+self.name.capitalize()\n        len_model_name_str = len(model_name_str)\n        for i in range(len(delim_str)-len_model_name_str):\n            model_name_str+= \" \" if i!=(len(delim_str)-len_model_name_str-2) else \" |\"\n\n        output += model_name_str +\"\\n\"\n        output += delim_str +\"\\n\"\n\n\n        #Format layers table\n        for i in range(len(layers_names)):\n            output += delim_str +\"\\n\"\n\n            l_name = layers_names[i]\n            l_param = str(layers_params[i])\n            l_param_str = \"\"\n            if len(l_name)<=max_len_str:\n                for i in range(max_len_str - len(l_name)):\n                    l_name+= \" \"\n\n            if len(l_param)<=max_len_param_str:\n                for i in range(max_len_param_str - len(l_param)):\n                    l_param_str+= \" \"\n\n            l_param_str += l_param\n\n\n            output +=\"| \"+l_name+\"|\"+l_param_str+\"| \\n\"\n\n        output += delim_str +\"\\n\"\n\n        #Format sum of params\n        total_params_str = \"| Total params count: \"+str(total_params)\n        len_total_params_str = len(total_params_str)\n        for i in range(len(delim_str)-len_total_params_str):\n            total_params_str+= \" \" if i!=(len(delim_str)-len_total_params_str-2) else \" |\"\n\n        output += total_params_str +\"\\n\"\n        output += delim_str +\"\\n\"\n\n        io.log_info(output)\n\nnn.ModelBase = ModelBase\n", "core/leras/layers/BatchNorm2D.py": "from core.leras import nn\ntf = nn.tf\n\nclass BatchNorm2D(nn.LayerBase):\n    \"\"\"\n    currently not for training\n    \"\"\"\n    def __init__(self, dim, eps=1e-05, momentum=0.1, dtype=None, **kwargs):\n        self.dim = dim\n        self.eps = eps\n        self.momentum = momentum\n        if dtype is None:\n            dtype = nn.floatx\n        self.dtype = dtype\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        self.weight       = tf.get_variable(\"weight\",   (self.dim,), dtype=self.dtype, initializer=tf.initializers.ones() )\n        self.bias         = tf.get_variable(\"bias\",     (self.dim,), dtype=self.dtype, initializer=tf.initializers.zeros() )\n        self.running_mean = tf.get_variable(\"running_mean\", (self.dim,), dtype=self.dtype, initializer=tf.initializers.zeros(), trainable=False )\n        self.running_var  = tf.get_variable(\"running_var\",  (self.dim,), dtype=self.dtype, initializer=tf.initializers.zeros(), trainable=False )\n\n    def get_weights(self):\n        return [self.weight, self.bias, self.running_mean, self.running_var]\n\n    def forward(self, x):\n        if nn.data_format == \"NHWC\":\n            shape = (1,1,1,self.dim)\n        else:\n            shape = (1,self.dim,1,1)\n\n        weight       = tf.reshape ( self.weight      , shape )\n        bias         = tf.reshape ( self.bias        , shape )\n        running_mean = tf.reshape ( self.running_mean, shape )\n        running_var  = tf.reshape ( self.running_var , shape )\n\n        x = (x - running_mean) / tf.sqrt( running_var + self.eps )\n        x *= weight\n        x += bias\n        return x\n\nnn.BatchNorm2D = BatchNorm2D", "core/leras/layers/Conv2DTranspose.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\n\nclass Conv2DTranspose(nn.LayerBase):\n    \"\"\"\n    use_wscale      enables weight scale (equalized learning rate)\n                    if kernel_initializer is None, it will be forced to random_normal\n    \"\"\"\n    def __init__(self, in_ch, out_ch, kernel_size, strides=2, padding='SAME', use_bias=True, use_wscale=False, kernel_initializer=None, bias_initializer=None, trainable=True, dtype=None, **kwargs ):\n        if not isinstance(strides, int):\n            raise ValueError (\"strides must be an int type\")\n        kernel_size = int(kernel_size)\n\n        if dtype is None:\n            dtype = nn.floatx\n\n        self.in_ch = in_ch\n        self.out_ch = out_ch\n        self.kernel_size = kernel_size\n        self.strides = strides\n        self.padding = padding\n        self.use_bias = use_bias\n        self.use_wscale = use_wscale\n        self.kernel_initializer = kernel_initializer\n        self.bias_initializer = bias_initializer\n        self.trainable = trainable\n        self.dtype = dtype\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        kernel_initializer = self.kernel_initializer\n        if self.use_wscale:\n            gain = 1.0 if self.kernel_size == 1 else np.sqrt(2)\n            fan_in = self.kernel_size*self.kernel_size*self.in_ch\n            he_std = gain / np.sqrt(fan_in) # He init\n            self.wscale = tf.constant(he_std, dtype=self.dtype )\n            if kernel_initializer is None:\n                kernel_initializer = tf.initializers.random_normal(0, 1.0, dtype=self.dtype)\n\n        #if kernel_initializer is None:\n        #    kernel_initializer = nn.initializers.ca()\n        self.weight = tf.get_variable(\"weight\", (self.kernel_size,self.kernel_size,self.out_ch,self.in_ch), dtype=self.dtype, initializer=kernel_initializer, trainable=self.trainable )\n\n        if self.use_bias:\n            bias_initializer = self.bias_initializer\n            if bias_initializer is None:\n                bias_initializer = tf.initializers.zeros(dtype=self.dtype)\n\n            self.bias = tf.get_variable(\"bias\", (self.out_ch,), dtype=self.dtype, initializer=bias_initializer, trainable=self.trainable )\n\n    def get_weights(self):\n        weights = [self.weight]\n        if self.use_bias:\n            weights += [self.bias]\n        return weights\n\n    def forward(self, x):\n        shape = x.shape\n\n        if nn.data_format == \"NHWC\":\n            h,w,c = shape[1], shape[2], shape[3]\n            output_shape = tf.stack ( (tf.shape(x)[0],\n                                    self.deconv_length(w, self.strides, self.kernel_size, self.padding),\n                                    self.deconv_length(h, self.strides, self.kernel_size, self.padding),\n                                    self.out_ch) )\n\n            strides = [1,self.strides,self.strides,1]\n        else:\n            c,h,w = shape[1], shape[2], shape[3]\n            output_shape = tf.stack ( (tf.shape(x)[0],\n                                        self.out_ch,\n                                        self.deconv_length(w, self.strides, self.kernel_size, self.padding),\n                                        self.deconv_length(h, self.strides, self.kernel_size, self.padding),\n                                        ) )\n            strides = [1,1,self.strides,self.strides]\n        weight = self.weight\n        if self.use_wscale:\n            weight = weight * self.wscale\n\n        x = tf.nn.conv2d_transpose(x, weight, output_shape, strides, padding=self.padding, data_format=nn.data_format)\n\n        if self.use_bias:\n            if nn.data_format == \"NHWC\":\n                bias = tf.reshape (self.bias, (1,1,1,self.out_ch) )\n            else:\n                bias = tf.reshape (self.bias, (1,self.out_ch,1,1) )\n            x = tf.add(x, bias)\n        return x\n\n    def __str__(self):\n        r = f\"{self.__class__.__name__} : in_ch:{self.in_ch} out_ch:{self.out_ch} \"\n\n        return r\n\n    def deconv_length(self, dim_size, stride_size, kernel_size, padding):\n        assert padding in {'SAME', 'VALID', 'FULL'}\n        if dim_size is None:\n            return None\n        if padding == 'VALID':\n            dim_size = dim_size * stride_size + max(kernel_size - stride_size, 0)\n        elif padding == 'FULL':\n            dim_size = dim_size * stride_size - (stride_size + kernel_size - 2)\n        elif padding == 'SAME':\n            dim_size = dim_size * stride_size\n        return dim_size\nnn.Conv2DTranspose = Conv2DTranspose", "core/leras/layers/BlurPool.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\n\nclass BlurPool(nn.LayerBase):\n    def __init__(self, filt_size=3, stride=2, **kwargs ):\n\n        if nn.data_format == \"NHWC\":\n            self.strides = [1,stride,stride,1]\n        else:\n            self.strides = [1,1,stride,stride]\n\n        self.filt_size = filt_size\n        pad = [ int(1.*(filt_size-1)/2), int(np.ceil(1.*(filt_size-1)/2)) ]\n\n        if nn.data_format == \"NHWC\":\n            self.padding = [ [0,0], pad, pad, [0,0] ]\n        else:\n            self.padding = [ [0,0], [0,0], pad, pad ]\n\n        if(self.filt_size==1):\n            a = np.array([1.,])\n        elif(self.filt_size==2):\n            a = np.array([1., 1.])\n        elif(self.filt_size==3):\n            a = np.array([1., 2., 1.])\n        elif(self.filt_size==4):\n            a = np.array([1., 3., 3., 1.])\n        elif(self.filt_size==5):\n            a = np.array([1., 4., 6., 4., 1.])\n        elif(self.filt_size==6):\n            a = np.array([1., 5., 10., 10., 5., 1.])\n        elif(self.filt_size==7):\n            a = np.array([1., 6., 15., 20., 15., 6., 1.])\n\n        a = a[:,None]*a[None,:]\n        a = a / np.sum(a)\n        a = a[:,:,None,None]\n        self.a = a\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        self.k = tf.constant (self.a, dtype=nn.floatx )\n\n    def forward(self, x):\n        k = tf.tile (self.k, (1,1,x.shape[nn.conv2d_ch_axis],1) )\n        x = tf.pad(x, self.padding )\n        x = tf.nn.depthwise_conv2d(x, k, self.strides, 'VALID', data_format=nn.data_format)\n        return x\nnn.BlurPool = BlurPool", "core/leras/layers/ScaleAdd.py": "from core.leras import nn\ntf = nn.tf\n\nclass ScaleAdd(nn.LayerBase):\n    def __init__(self, ch, dtype=None, **kwargs):\n        if dtype is None:\n            dtype = nn.floatx\n        self.dtype = dtype\n        self.ch = ch\n\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        self.weight = tf.get_variable(\"weight\",(self.ch,), dtype=self.dtype, initializer=tf.initializers.zeros() )\n\n    def get_weights(self):\n        return [self.weight]\n\n    def forward(self, inputs):\n        if nn.data_format == \"NHWC\":\n            shape = (1,1,1,self.ch)\n        else:\n            shape = (1,self.ch,1,1)\n\n        weight = tf.reshape ( self.weight, shape )\n\n        x0, x1 = inputs\n        x = x0 + x1*weight\n\n        return x\nnn.ScaleAdd = ScaleAdd", "core/leras/layers/AdaIN.py": "from core.leras import nn\ntf = nn.tf\n\nclass AdaIN(nn.LayerBase):\n    \"\"\"\n    \"\"\"\n    def __init__(self, in_ch, mlp_ch, kernel_initializer=None, dtype=None, **kwargs):\n        self.in_ch = in_ch\n        self.mlp_ch = mlp_ch\n        self.kernel_initializer = kernel_initializer\n\n        if dtype is None:\n            dtype = nn.floatx\n        self.dtype = dtype\n\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        kernel_initializer = self.kernel_initializer\n        if kernel_initializer is None:\n            kernel_initializer = tf.initializers.he_normal()\n\n        self.weight1   = tf.get_variable(\"weight1\", (self.mlp_ch, self.in_ch), dtype=self.dtype, initializer=kernel_initializer)\n        self.bias1     = tf.get_variable(\"bias1\",   (self.in_ch,), dtype=self.dtype, initializer=tf.initializers.zeros())\n        self.weight2   = tf.get_variable(\"weight2\", (self.mlp_ch, self.in_ch), dtype=self.dtype, initializer=kernel_initializer)\n        self.bias2     = tf.get_variable(\"bias2\",   (self.in_ch,), dtype=self.dtype, initializer=tf.initializers.zeros())\n\n    def get_weights(self):\n        return [self.weight1, self.bias1, self.weight2, self.bias2]\n\n    def forward(self, inputs):\n        x, mlp = inputs\n\n        gamma = tf.matmul(mlp, self.weight1)\n        gamma = tf.add(gamma, tf.reshape(self.bias1, (1,self.in_ch) ) )\n\n        beta = tf.matmul(mlp, self.weight2)\n        beta = tf.add(beta, tf.reshape(self.bias2, (1,self.in_ch) ) )\n\n\n        if nn.data_format == \"NHWC\":\n            shape = (-1,1,1,self.in_ch)\n        else:\n            shape = (-1,self.in_ch,1,1)\n\n        x_mean = tf.reduce_mean(x, axis=nn.conv2d_spatial_axes, keepdims=True )\n        x_std  = tf.math.reduce_std(x, axis=nn.conv2d_spatial_axes, keepdims=True ) + 1e-5\n\n        x = (x - x_mean) / x_std\n        x *= tf.reshape(gamma, shape)\n\n        x += tf.reshape(beta, shape)\n\n        return x\n\nnn.AdaIN = AdaIN", "core/leras/layers/LayerBase.py": "from core.leras import nn\ntf = nn.tf\n\nclass LayerBase(nn.Saveable):\n    #override\n    def build_weights(self):\n        pass\n    \n    #override\n    def forward(self, *args, **kwargs):\n        pass\n    \n    def __call__(self, *args, **kwargs):\n        return self.forward(*args, **kwargs)\n\nnn.LayerBase = LayerBase", "core/leras/layers/DepthwiseConv2D.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\n\nclass DepthwiseConv2D(nn.LayerBase):\n    \"\"\"\n    default kernel_initializer - CA\n    use_wscale  bool enables equalized learning rate, if kernel_initializer is None, it will be forced to random_normal\n    \"\"\"\n    def __init__(self, in_ch, kernel_size, strides=1, padding='SAME', depth_multiplier=1, dilations=1, use_bias=True, use_wscale=False, kernel_initializer=None, bias_initializer=None, trainable=True, dtype=None, **kwargs ):\n        if not isinstance(strides, int):\n            raise ValueError (\"strides must be an int type\")\n        if not isinstance(dilations, int):\n            raise ValueError (\"dilations must be an int type\")\n        kernel_size = int(kernel_size)\n\n        if dtype is None:\n            dtype = nn.floatx\n\n        if isinstance(padding, str):\n            if padding == \"SAME\":\n                padding = ( (kernel_size - 1) * dilations + 1 ) // 2\n            elif padding == \"VALID\":\n                padding = 0\n            else:\n                raise ValueError (\"Wrong padding type. Should be VALID SAME or INT or 4x INTs\")\n\n        if isinstance(padding, int):\n            if padding != 0:\n                if nn.data_format == \"NHWC\":\n                    padding = [ [0,0], [padding,padding], [padding,padding], [0,0] ]\n                else:\n                    padding = [ [0,0], [0,0], [padding,padding], [padding,padding] ]\n            else:\n                padding = None\n\n        if nn.data_format == \"NHWC\":\n            strides = [1,strides,strides,1]\n        else:\n            strides = [1,1,strides,strides]\n\n        if nn.data_format == \"NHWC\":\n            dilations = [1,dilations,dilations,1]\n        else:\n            dilations = [1,1,dilations,dilations]\n\n        self.in_ch = in_ch\n        self.depth_multiplier = depth_multiplier\n        self.kernel_size = kernel_size\n        self.strides = strides\n        self.padding = padding\n        self.dilations = dilations\n        self.use_bias = use_bias\n        self.use_wscale = use_wscale\n        self.kernel_initializer = kernel_initializer\n        self.bias_initializer = bias_initializer\n        self.trainable = trainable\n        self.dtype = dtype\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        kernel_initializer = self.kernel_initializer\n        if self.use_wscale:\n            gain = 1.0 if self.kernel_size == 1 else np.sqrt(2)\n            fan_in = self.kernel_size*self.kernel_size*self.in_ch\n            he_std = gain / np.sqrt(fan_in)\n            self.wscale = tf.constant(he_std, dtype=self.dtype )\n            if kernel_initializer is None:\n                kernel_initializer = tf.initializers.random_normal(0, 1.0, dtype=self.dtype)\n\n        #if kernel_initializer is None:\n        #    kernel_initializer = nn.initializers.ca()\n\n        self.weight = tf.get_variable(\"weight\", (self.kernel_size,self.kernel_size,self.in_ch,self.depth_multiplier), dtype=self.dtype, initializer=kernel_initializer, trainable=self.trainable )\n\n        if self.use_bias:\n            bias_initializer = self.bias_initializer\n            if bias_initializer is None:\n                bias_initializer = tf.initializers.zeros(dtype=self.dtype)\n\n            self.bias = tf.get_variable(\"bias\", (self.in_ch*self.depth_multiplier,), dtype=self.dtype, initializer=bias_initializer, trainable=self.trainable )\n\n    def get_weights(self):\n        weights = [self.weight]\n        if self.use_bias:\n            weights += [self.bias]\n        return weights\n\n    def forward(self, x):\n        weight = self.weight\n        if self.use_wscale:\n            weight = weight * self.wscale\n\n        if self.padding is not None:\n            x = tf.pad (x, self.padding, mode='CONSTANT')\n\n        x = tf.nn.depthwise_conv2d(x, weight, self.strides, 'VALID', data_format=nn.data_format)\n        if self.use_bias:\n            if nn.data_format == \"NHWC\":\n                bias = tf.reshape (self.bias, (1,1,1,self.in_ch*self.depth_multiplier) )\n            else:\n                bias = tf.reshape (self.bias, (1,self.in_ch*self.depth_multiplier,1,1) )\n            x = tf.add(x, bias)\n        return x\n\n    def __str__(self):\n        r = f\"{self.__class__.__name__} : in_ch:{self.in_ch} depth_multiplier:{self.depth_multiplier} \"\n        return r\n\nnn.DepthwiseConv2D = DepthwiseConv2D", "core/leras/layers/Dense.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\n\nclass Dense(nn.LayerBase):\n    def __init__(self, in_ch, out_ch, use_bias=True, use_wscale=False, maxout_ch=0, kernel_initializer=None, bias_initializer=None, trainable=True, dtype=None, **kwargs ):\n        \"\"\"\n        use_wscale          enables weight scale (equalized learning rate)\n                            if kernel_initializer is None, it will be forced to random_normal\n\n        maxout_ch     https://link.springer.com/article/10.1186/s40537-019-0233-0\n                            typical 2-4 if you want to enable DenseMaxout behaviour\n        \"\"\"\n        self.in_ch = in_ch\n        self.out_ch = out_ch\n        self.use_bias = use_bias\n        self.use_wscale = use_wscale\n        self.maxout_ch = maxout_ch\n        self.kernel_initializer = kernel_initializer\n        self.bias_initializer = bias_initializer\n        self.trainable = trainable\n        if dtype is None:\n            dtype = nn.floatx\n\n        self.dtype = dtype\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        if self.maxout_ch > 1:\n            weight_shape = (self.in_ch,self.out_ch*self.maxout_ch)\n        else:\n            weight_shape = (self.in_ch,self.out_ch)\n\n        kernel_initializer = self.kernel_initializer\n\n        if self.use_wscale:\n            gain = 1.0\n            fan_in = np.prod( weight_shape[:-1] )\n            he_std = gain / np.sqrt(fan_in) # He init\n            self.wscale = tf.constant(he_std, dtype=self.dtype )\n            if kernel_initializer is None:\n                kernel_initializer = tf.initializers.random_normal(0, 1.0, dtype=self.dtype)\n\n        if kernel_initializer is None:\n            kernel_initializer = tf.initializers.glorot_uniform(dtype=self.dtype)\n\n        self.weight = tf.get_variable(\"weight\", weight_shape, dtype=self.dtype, initializer=kernel_initializer, trainable=self.trainable )\n\n        if self.use_bias:\n            bias_initializer = self.bias_initializer\n            if bias_initializer is None:\n                bias_initializer = tf.initializers.zeros(dtype=self.dtype)\n            self.bias = tf.get_variable(\"bias\", (self.out_ch,), dtype=self.dtype, initializer=bias_initializer, trainable=self.trainable )\n\n    def get_weights(self):\n        weights = [self.weight]\n        if self.use_bias:\n            weights += [self.bias]\n        return weights\n\n    def forward(self, x):\n        weight = self.weight\n        if self.use_wscale:\n            weight = weight * self.wscale\n\n        x = tf.matmul(x, weight)\n\n        if self.maxout_ch > 1:\n            x = tf.reshape (x, (-1, self.out_ch, self.maxout_ch) )\n            x = tf.reduce_max(x, axis=-1)\n\n        if self.use_bias:\n            x = tf.add(x, tf.reshape(self.bias, (1,self.out_ch) ) )\n\n        return x\nnn.Dense = Dense", "core/leras/layers/Saveable.py": "import pickle\nfrom pathlib import Path\nfrom core import pathex\nimport numpy as np\n\nfrom core.leras import nn\n\ntf = nn.tf\n\nclass Saveable():\n    def __init__(self, name=None):\n        self.name = name\n\n    #override\n    def get_weights(self):\n        #return tf tensors that should be initialized/loaded/saved\n        return []\n\n    #override\n    def get_weights_np(self):\n        weights = self.get_weights()\n        if len(weights) == 0:\n            return []\n        return nn.tf_sess.run (weights)\n\n    def set_weights(self, new_weights):\n        weights = self.get_weights()\n        if len(weights) != len(new_weights):\n            raise ValueError ('len of lists mismatch')\n\n        tuples = []\n        for w, new_w in zip(weights, new_weights):\n\n            if len(w.shape) != new_w.shape:\n                new_w = new_w.reshape(w.shape)\n\n            tuples.append ( (w, new_w) )\n\n        nn.batch_set_value (tuples)\n\n    def save_weights(self, filename, force_dtype=None):\n        d = {}\n        weights = self.get_weights()\n\n        if self.name is None:\n            raise Exception(\"name must be defined.\")\n\n        name = self.name\n\n        for w in weights:\n            w_val = nn.tf_sess.run (w).copy()\n            w_name_split = w.name.split('/', 1)\n            if name != w_name_split[0]:\n                raise Exception(\"weight first name != Saveable.name\")\n\n            if force_dtype is not None:\n                w_val = w_val.astype(force_dtype)\n\n            d[ w_name_split[1] ] = w_val\n\n        d_dumped = pickle.dumps (d, 4)\n        pathex.write_bytes_safe ( Path(filename), d_dumped )\n\n    def load_weights(self, filename):\n        \"\"\"\n        returns True if file exists\n        \"\"\"\n        filepath = Path(filename)\n        if filepath.exists():\n            result = True\n            d_dumped = filepath.read_bytes()\n            d = pickle.loads(d_dumped)\n        else:\n            return False\n\n        weights = self.get_weights()\n\n        if self.name is None:\n            raise Exception(\"name must be defined.\")\n\n        try:\n            tuples = []\n            for w in weights:\n                w_name_split = w.name.split('/')\n                if self.name != w_name_split[0]:\n                    raise Exception(\"weight first name != Saveable.name\")\n\n                sub_w_name = \"/\".join(w_name_split[1:])\n\n                w_val = d.get(sub_w_name, None)\n\n                if w_val is None:\n                    #io.log_err(f\"Weight {w.name} was not loaded from file {filename}\")\n                    tuples.append ( (w, w.initializer) )\n                else:\n                    w_val = np.reshape( w_val, w.shape.as_list() )\n                    tuples.append ( (w, w_val) )\n\n            nn.batch_set_value(tuples)\n        except:\n            return False\n\n        return True\n\n    def init_weights(self):\n        nn.init_weights(self.get_weights())\n\nnn.Saveable = Saveable\n", "core/leras/layers/FRNorm2D.py": "from core.leras import nn\ntf = nn.tf\n\nclass FRNorm2D(nn.LayerBase):\n    \"\"\"\n    Tensorflow implementation of\n    Filter Response Normalization Layer: Eliminating Batch Dependence in theTraining of Deep Neural Networks\n    https://arxiv.org/pdf/1911.09737.pdf\n    \"\"\"\n    def __init__(self, in_ch, dtype=None, **kwargs):\n        self.in_ch = in_ch\n\n        if dtype is None:\n            dtype = nn.floatx\n        self.dtype = dtype\n\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        self.weight      = tf.get_variable(\"weight\", (self.in_ch,), dtype=self.dtype, initializer=tf.initializers.ones() )\n        self.bias        = tf.get_variable(\"bias\",   (self.in_ch,), dtype=self.dtype, initializer=tf.initializers.zeros() )\n        self.eps         = tf.get_variable(\"eps\",    (1,), dtype=self.dtype, initializer=tf.initializers.constant(1e-6) )\n\n    def get_weights(self):\n        return [self.weight, self.bias, self.eps]\n\n    def forward(self, x):\n        if nn.data_format == \"NHWC\":\n            shape = (1,1,1,self.in_ch)\n        else:\n            shape = (1,self.in_ch,1,1)\n        weight       = tf.reshape ( self.weight, shape )\n        bias         = tf.reshape ( self.bias  , shape )\n        nu2 = tf.reduce_mean(tf.square(x), axis=nn.conv2d_spatial_axes, keepdims=True)\n        x = x * ( 1.0/tf.sqrt(nu2 + tf.abs(self.eps) ) )\n\n        return x*weight + bias\nnn.FRNorm2D = FRNorm2D", "core/leras/layers/TanhPolar.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\n\nclass TanhPolar(nn.LayerBase):\n    \"\"\"\n    RoI Tanh-polar Transformer Network for Face Parsing in the Wild\n    https://github.com/hhj1897/roi_tanh_warping\n    \"\"\"\n\n    def __init__(self, width, height, angular_offset_deg=270, **kwargs):\n        self.width = width\n        self.height = height\n\n        warp_gridx, warp_gridy = TanhPolar._get_tanh_polar_warp_grids(width,height,angular_offset_deg=angular_offset_deg)\n        restore_gridx, restore_gridy = TanhPolar._get_tanh_polar_restore_grids(width,height,angular_offset_deg=angular_offset_deg)\n\n        self.warp_gridx_t = tf.constant(warp_gridx[None, ...])\n        self.warp_gridy_t = tf.constant(warp_gridy[None, ...])\n        self.restore_gridx_t = tf.constant(restore_gridx[None, ...])\n        self.restore_gridy_t = tf.constant(restore_gridy[None, ...])\n\n        super().__init__(**kwargs)\n\n    def warp(self, inp_t):\n        batch_t = tf.shape(inp_t)[0]\n        warp_gridx_t = tf.tile(self.warp_gridx_t, (batch_t,1,1) )\n        warp_gridy_t = tf.tile(self.warp_gridy_t, (batch_t,1,1) )\n\n        if nn.data_format == \"NCHW\":\n            inp_t = tf.transpose(inp_t,(0,2,3,1))\n\n        out_t = nn.bilinear_sampler(inp_t, warp_gridx_t, warp_gridy_t)\n\n        if nn.data_format == \"NCHW\":\n            out_t = tf.transpose(out_t,(0,3,1,2))\n\n        return out_t\n\n    def restore(self, inp_t):\n        batch_t = tf.shape(inp_t)[0]\n        restore_gridx_t = tf.tile(self.restore_gridx_t, (batch_t,1,1) )\n        restore_gridy_t = tf.tile(self.restore_gridy_t, (batch_t,1,1) )\n\n        if nn.data_format == \"NCHW\":\n            inp_t = tf.transpose(inp_t,(0,2,3,1))\n\n        inp_t = tf.pad(inp_t, [(0,0), (1, 1), (1, 0), (0, 0)], \"SYMMETRIC\")\n\n        out_t = nn.bilinear_sampler(inp_t, restore_gridx_t, restore_gridy_t)\n\n        if nn.data_format == \"NCHW\":\n            out_t = tf.transpose(out_t,(0,3,1,2))\n\n        return out_t\n\n    @staticmethod\n    def _get_tanh_polar_warp_grids(W,H,angular_offset_deg):\n        angular_offset_pi = angular_offset_deg * np.pi / 180.0\n\n        roi_center = np.array([ W//2, H//2], np.float32 )\n        roi_radii = np.array([W, H], np.float32 ) / np.pi ** 0.5\n        cos_offset, sin_offset = np.cos(angular_offset_pi), np.sin(angular_offset_pi)\n        normalised_dest_indices = np.stack(np.meshgrid(np.arange(0.0, 1.0, 1.0 / W),np.arange(0.0, 2.0 * np.pi, 2.0 * np.pi / H)), axis=-1)\n        radii = normalised_dest_indices[..., 0]\n        orientation_x = np.cos(normalised_dest_indices[..., 1])\n        orientation_y = np.sin(normalised_dest_indices[..., 1])\n\n        src_radii = np.arctanh(radii) * (roi_radii[0] * roi_radii[1] / np.sqrt(roi_radii[1] ** 2 * orientation_x ** 2 + roi_radii[0] ** 2 * orientation_y ** 2))\n        src_x_indices = src_radii * orientation_x\n        src_y_indices = src_radii * orientation_y\n        src_x_indices, src_y_indices = (roi_center[0] + cos_offset * src_x_indices - sin_offset * src_y_indices,\n                                        roi_center[1] + cos_offset * src_y_indices + sin_offset * src_x_indices)\n\n        return src_x_indices.astype(np.float32), src_y_indices.astype(np.float32)\n\n    @staticmethod\n    def _get_tanh_polar_restore_grids(W,H,angular_offset_deg):\n        angular_offset_pi = angular_offset_deg * np.pi / 180.0\n\n        roi_center = np.array([ W//2, H//2], np.float32 )\n        roi_radii = np.array([W, H], np.float32 ) / np.pi ** 0.5\n        cos_offset, sin_offset = np.cos(angular_offset_pi), np.sin(angular_offset_pi)\n\n        dest_indices = np.stack(np.meshgrid(np.arange(W), np.arange(H)), axis=-1).astype(float)\n        normalised_dest_indices = np.matmul(dest_indices - roi_center, np.array([[cos_offset, -sin_offset],\n                                                                                [sin_offset, cos_offset]]))\n        radii = np.linalg.norm(normalised_dest_indices, axis=-1)\n        normalised_dest_indices[..., 0] /= np.clip(radii, 1e-9, None)\n        normalised_dest_indices[..., 1] /= np.clip(radii, 1e-9, None)\n        radii *= np.sqrt(roi_radii[1] ** 2 * normalised_dest_indices[..., 0] ** 2 +\n                        roi_radii[0] ** 2 * normalised_dest_indices[..., 1] ** 2) / roi_radii[0] / roi_radii[1]\n\n        src_radii = np.tanh(radii)\n\n\n        src_x_indices = src_radii * W + 1.0\n        src_y_indices = np.mod((np.arctan2(normalised_dest_indices[..., 1], normalised_dest_indices[..., 0]) /\n                                2.0 / np.pi) * H, H) + 1.0\n\n        return src_x_indices.astype(np.float32), src_y_indices.astype(np.float32)\n\n\nnn.TanhPolar = TanhPolar", "core/leras/layers/TLU.py": "from core.leras import nn\ntf = nn.tf\n\nclass TLU(nn.LayerBase):\n    \"\"\"\n    Tensorflow implementation of\n    Filter Response Normalization Layer: Eliminating Batch Dependence in theTraining of Deep Neural Networks\n    https://arxiv.org/pdf/1911.09737.pdf\n    \"\"\"\n    def __init__(self, in_ch, dtype=None, **kwargs):\n        self.in_ch = in_ch\n\n        if dtype is None:\n            dtype = nn.floatx\n        self.dtype = dtype\n\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        self.tau = tf.get_variable(\"tau\", (self.in_ch,), dtype=self.dtype, initializer=tf.initializers.zeros() )\n\n    def get_weights(self):\n        return [self.tau]\n\n    def forward(self, x):\n        if nn.data_format == \"NHWC\":\n            shape = (1,1,1,self.in_ch)\n        else:\n            shape = (1,self.in_ch,1,1)\n\n        tau = tf.reshape ( self.tau, shape )\n        return tf.math.maximum(x, tau)\nnn.TLU = TLU", "core/leras/layers/Conv2D.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\n\nclass Conv2D(nn.LayerBase):\n    \"\"\"\n    default kernel_initializer - CA\n    use_wscale  bool enables equalized learning rate, if kernel_initializer is None, it will be forced to random_normal\n\n\n    \"\"\"\n    def __init__(self, in_ch, out_ch, kernel_size, strides=1, padding='SAME', dilations=1, use_bias=True, use_wscale=False, kernel_initializer=None, bias_initializer=None, trainable=True, dtype=None, **kwargs ):\n        if not isinstance(strides, int):\n            raise ValueError (\"strides must be an int type\")\n        if not isinstance(dilations, int):\n            raise ValueError (\"dilations must be an int type\")\n        kernel_size = int(kernel_size)\n\n        if dtype is None:\n            dtype = nn.floatx\n\n        if isinstance(padding, str):\n            if padding == \"SAME\":\n                padding = ( (kernel_size - 1) * dilations + 1 ) // 2\n            elif padding == \"VALID\":\n                padding = None\n            else:\n                raise ValueError (\"Wrong padding type. Should be VALID SAME or INT or 4x INTs\")\n        else:\n            padding = int(padding)\n            \n        \n\n        self.in_ch = in_ch\n        self.out_ch = out_ch\n        self.kernel_size = kernel_size\n        self.strides = strides\n        self.padding = padding\n        self.dilations = dilations\n        self.use_bias = use_bias\n        self.use_wscale = use_wscale\n        self.kernel_initializer = kernel_initializer\n        self.bias_initializer = bias_initializer\n        self.trainable = trainable\n        self.dtype = dtype\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        kernel_initializer = self.kernel_initializer\n        if self.use_wscale:\n            gain = 1.0 if self.kernel_size == 1 else np.sqrt(2)\n            fan_in = self.kernel_size*self.kernel_size*self.in_ch\n            he_std = gain / np.sqrt(fan_in)\n            self.wscale = tf.constant(he_std, dtype=self.dtype )\n            if kernel_initializer is None:\n                kernel_initializer = tf.initializers.random_normal(0, 1.0, dtype=self.dtype)\n\n        #if kernel_initializer is None:\n        #    kernel_initializer = nn.initializers.ca()\n\n        self.weight = tf.get_variable(\"weight\", (self.kernel_size,self.kernel_size,self.in_ch,self.out_ch), dtype=self.dtype, initializer=kernel_initializer, trainable=self.trainable )\n\n        if self.use_bias:\n            bias_initializer = self.bias_initializer\n            if bias_initializer is None:\n                bias_initializer = tf.initializers.zeros(dtype=self.dtype)\n\n            self.bias = tf.get_variable(\"bias\", (self.out_ch,), dtype=self.dtype, initializer=bias_initializer, trainable=self.trainable )\n\n    def get_weights(self):\n        weights = [self.weight]\n        if self.use_bias:\n            weights += [self.bias]\n        return weights\n\n    def forward(self, x):\n        weight = self.weight\n        if self.use_wscale:\n            weight = weight * self.wscale\n\n        padding = self.padding\n        if padding is not None:\n            if nn.data_format == \"NHWC\":\n                padding = [ [0,0], [padding,padding], [padding,padding], [0,0] ]\n            else:\n                padding = [ [0,0], [0,0], [padding,padding], [padding,padding] ]\n            x = tf.pad (x, padding, mode='CONSTANT')\n        \n        strides = self.strides\n        if nn.data_format == \"NHWC\":\n            strides = [1,strides,strides,1]\n        else:\n            strides = [1,1,strides,strides]\n\n        dilations = self.dilations\n        if nn.data_format == \"NHWC\":\n            dilations = [1,dilations,dilations,1]\n        else:\n            dilations = [1,1,dilations,dilations]\n            \n        x = tf.nn.conv2d(x, weight, strides, 'VALID', dilations=dilations, data_format=nn.data_format)\n        if self.use_bias:\n            if nn.data_format == \"NHWC\":\n                bias = tf.reshape (self.bias, (1,1,1,self.out_ch) )\n            else:\n                bias = tf.reshape (self.bias, (1,self.out_ch,1,1) )\n            x = tf.add(x, bias)\n        return x\n\n    def __str__(self):\n        r = f\"{self.__class__.__name__} : in_ch:{self.in_ch} out_ch:{self.out_ch} \"\n\n        return r\nnn.Conv2D = Conv2D", "core/leras/layers/DenseNorm.py": "from core.leras import nn\ntf = nn.tf\n\nclass DenseNorm(nn.LayerBase):\n    def __init__(self, dense=False, eps=1e-06, dtype=None, **kwargs):\n        self.dense = dense        \n        if dtype is None:\n            dtype = nn.floatx\n        self.eps = tf.constant(eps, dtype=dtype, name=\"epsilon\")\n\n        super().__init__(**kwargs)\n\n    def __call__(self, x):\n        return x * tf.rsqrt(tf.reduce_mean(tf.square(x), axis=-1, keepdims=True) + self.eps)\n        \nnn.DenseNorm = DenseNorm", "core/leras/layers/__init__.py": "from .Saveable import *\nfrom .LayerBase import *\n\nfrom .Conv2D import *\nfrom .Conv2DTranspose import *\nfrom .DepthwiseConv2D import *\nfrom .Dense import *\nfrom .BlurPool import *\n\nfrom .BatchNorm2D import *\nfrom .InstanceNorm2D import *\nfrom .FRNorm2D import *\n\nfrom .TLU import *\nfrom .ScaleAdd import *\nfrom .DenseNorm import *\nfrom .AdaIN import *\nfrom .TanhPolar import *", "core/leras/layers/InstanceNorm2D.py": "from core.leras import nn\ntf = nn.tf\n\nclass InstanceNorm2D(nn.LayerBase):\n    def __init__(self, in_ch, dtype=None, **kwargs):\n        self.in_ch = in_ch\n\n        if dtype is None:\n            dtype = nn.floatx\n        self.dtype = dtype\n\n        super().__init__(**kwargs)\n\n    def build_weights(self):\n        kernel_initializer = tf.initializers.glorot_uniform(dtype=self.dtype)\n        self.weight       = tf.get_variable(\"weight\",   (self.in_ch,), dtype=self.dtype, initializer=kernel_initializer )\n        self.bias         = tf.get_variable(\"bias\",     (self.in_ch,), dtype=self.dtype, initializer=tf.initializers.zeros() )\n\n    def get_weights(self):\n        return [self.weight, self.bias]\n\n    def forward(self, x):\n        if nn.data_format == \"NHWC\":\n            shape = (1,1,1,self.in_ch)\n        else:\n            shape = (1,self.in_ch,1,1)\n\n        weight       = tf.reshape ( self.weight      , shape )\n        bias         = tf.reshape ( self.bias        , shape )\n\n        x_mean = tf.reduce_mean(x, axis=nn.conv2d_spatial_axes, keepdims=True )\n        x_std  = tf.math.reduce_std(x, axis=nn.conv2d_spatial_axes, keepdims=True ) + 1e-5\n\n        x = (x - x_mean) / x_std\n        x *= weight\n        x += bias\n\n        return x\n\nnn.InstanceNorm2D = InstanceNorm2D", "core/leras/optimizers/RMSprop.py": "import numpy as np\nfrom tensorflow.python.ops import control_flow_ops, state_ops\nfrom core.leras import nn\ntf = nn.tf\n\nclass RMSprop(nn.OptimizerBase):\n    def __init__(self, lr=0.001, rho=0.9, lr_dropout=1.0, lr_cos=0, clipnorm=0.0, name=None, **kwargs):\n        super().__init__(name=name)\n\n        if name is None:\n            raise ValueError('name must be defined.')\n\n        self.lr_dropout = lr_dropout\n        self.lr_cos = lr_cos\n        self.lr = lr\n        self.rho = rho\n        self.clipnorm = clipnorm\n\n        with tf.device('/CPU:0') :\n            with tf.variable_scope(self.name):\n                \n                self.iterations = tf.Variable(0, dtype=tf.int64, name='iters')\n\n        self.accumulators_dict = {}\n        self.lr_rnds_dict = {}\n\n    def get_weights(self):\n        return [self.iterations] + list(self.accumulators_dict.values())\n\n    def initialize_variables(self, trainable_weights, vars_on_cpu=True, lr_dropout_on_cpu=False):\n        # Initialize here all trainable variables used in training\n        e = tf.device('/CPU:0') if vars_on_cpu else None\n        if e: e.__enter__()\n        with tf.variable_scope(self.name):\n            accumulators = { v.name : tf.get_variable ( f'acc_{v.name}'.replace(':','_'), v.shape, dtype=v.dtype, initializer=tf.initializers.constant(0.0), trainable=False) for v in trainable_weights }\n            self.accumulators_dict.update ( accumulators)\n\n            if self.lr_dropout != 1.0:\n                e = tf.device('/CPU:0') if lr_dropout_on_cpu else None\n                if e: e.__enter__()                    \n                lr_rnds = [ nn.random_binomial( v.shape, p=self.lr_dropout, dtype=v.dtype) for v in trainable_weights ]\n                if e: e.__exit__(None, None, None)                \n                self.lr_rnds_dict.update ( { v.name : rnd for v,rnd in zip(trainable_weights,lr_rnds) } )\n        if e: e.__exit__(None, None, None)\n\n    def get_update_op(self, grads_vars):\n        updates = []\n\n        if self.clipnorm > 0.0:\n            norm = tf.sqrt( sum([tf.reduce_sum(tf.square(tf.cast(g, tf.float32))) for g,v in grads_vars]))\n        updates += [ state_ops.assign_add( self.iterations, 1) ]\n        for i, (g,v) in enumerate(grads_vars):\n            if self.clipnorm > 0.0:\n                g = self.tf_clip_norm(g, self.clipnorm, tf.cast(norm, g.dtype) )\n\n            a = self.accumulators_dict[ v.name ]\n\n            new_a = self.rho * a + (1. - self.rho) * tf.square(g)\n\n            lr = tf.constant(self.lr, g.dtype)\n            if self.lr_cos != 0:\n                lr *= (tf.cos(  tf.cast(self.iterations, g.dtype) * (2*3.1415926535/ float(self.lr_cos) )  ) + 1.0) / 2.0\n\n            v_diff = - lr * g / (tf.sqrt(new_a) + np.finfo( g.dtype.as_numpy_dtype ).resolution  )\n            if self.lr_dropout != 1.0:\n                lr_rnd = self.lr_rnds_dict[v.name]\n                v_diff *= lr_rnd\n            new_v = v + v_diff\n\n            updates.append (state_ops.assign(a, new_a))\n            updates.append (state_ops.assign(v, new_v))\n\n        return control_flow_ops.group ( *updates, name=self.name+'_updates')\nnn.RMSprop = RMSprop", "core/leras/optimizers/__init__.py": "from .OptimizerBase import *\nfrom .RMSprop import *\nfrom .AdaBelief import *", "core/leras/optimizers/OptimizerBase.py": "import copy\nfrom core.leras import nn\ntf = nn.tf\n\nclass OptimizerBase(nn.Saveable):\n    def __init__(self, name=None):\n        super().__init__(name=name)\n\n    def tf_clip_norm(self, g, c, n):\n        \"\"\"Clip the gradient `g` if the L2 norm `n` exceeds `c`.\n        # Arguments\n            g: Tensor, the gradient tensor\n            c: float >= 0. Gradients will be clipped\n                when their L2 norm exceeds this value.\n            n: Tensor, actual norm of `g`.\n        # Returns\n            Tensor, the gradient clipped if required.\n        \"\"\"\n        if c <= 0:  # if clipnorm == 0 no need to add ops to the graph\n            return g\n\n        condition = n >= c\n        then_expression = tf.scalar_mul(c / n, g)\n        else_expression = g\n\n        # saving the shape to avoid converting sparse tensor to dense\n        if isinstance(then_expression, tf.Tensor):\n            g_shape = copy.copy(then_expression.get_shape())\n        elif isinstance(then_expression, tf.IndexedSlices):\n            g_shape = copy.copy(then_expression.dense_shape)\n        if condition.dtype != tf.bool:\n            condition = tf.cast(condition, 'bool')\n        g = tf.cond(condition,\n                    lambda: then_expression,\n                    lambda: else_expression)\n        if isinstance(then_expression, tf.Tensor):\n            g.set_shape(g_shape)\n        elif isinstance(then_expression, tf.IndexedSlices):\n            g._dense_shape = g_shape\n\n        return g\nnn.OptimizerBase = OptimizerBase\n", "core/leras/optimizers/AdaBelief.py": "import numpy as np\nfrom core.leras import nn\nfrom tensorflow.python.ops import control_flow_ops, state_ops\n\ntf = nn.tf\n\nclass AdaBelief(nn.OptimizerBase):\n    def __init__(self, lr=0.001, beta_1=0.9, beta_2=0.999, lr_dropout=1.0, lr_cos=0, clipnorm=0.0, name=None, **kwargs):\n        super().__init__(name=name)\n\n        if name is None:\n            raise ValueError('name must be defined.')\n\n        self.lr = lr\n        self.beta_1 = beta_1\n        self.beta_2 = beta_2\n        self.lr_dropout = lr_dropout\n        self.lr_cos = lr_cos\n        self.clipnorm = clipnorm\n\n        with tf.device('/CPU:0') :\n            with tf.variable_scope(self.name):\n                self.iterations = tf.Variable(0, dtype=tf.int64, name='iters')\n\n        self.ms_dict = {}\n        self.vs_dict = {}\n        self.lr_rnds_dict = {}\n\n    def get_weights(self):\n        return [self.iterations] + list(self.ms_dict.values()) + list(self.vs_dict.values())\n\n    def initialize_variables(self, trainable_weights, vars_on_cpu=True, lr_dropout_on_cpu=False):\n        # Initialize here all trainable variables used in training\n        e = tf.device('/CPU:0') if vars_on_cpu else None\n        if e: e.__enter__()\n        with tf.variable_scope(self.name):\n            ms = { v.name : tf.get_variable ( f'ms_{v.name}'.replace(':','_'), v.shape, dtype=v.dtype, initializer=tf.initializers.constant(0.0), trainable=False) for v in trainable_weights }\n            vs = { v.name : tf.get_variable ( f'vs_{v.name}'.replace(':','_'), v.shape, dtype=v.dtype, initializer=tf.initializers.constant(0.0), trainable=False) for v in trainable_weights }\n            self.ms_dict.update (ms)\n            self.vs_dict.update (vs)\n            \n            if self.lr_dropout != 1.0:\n                e = tf.device('/CPU:0') if lr_dropout_on_cpu else None\n                if e: e.__enter__()                    \n                lr_rnds = [ nn.random_binomial( v.shape, p=self.lr_dropout, dtype=v.dtype) for v in trainable_weights ]\n                if e: e.__exit__(None, None, None)                \n                self.lr_rnds_dict.update ( { v.name : rnd for v,rnd in zip(trainable_weights,lr_rnds) } )\n        if e: e.__exit__(None, None, None)\n\n    def get_update_op(self, grads_vars):\n        updates = []\n\n        if self.clipnorm > 0.0:\n            norm = tf.sqrt( sum([tf.reduce_sum(tf.square(tf.cast(g, tf.float32))) for g,v in grads_vars]))\n        updates += [ state_ops.assign_add( self.iterations, 1) ]\n        for i, (g,v) in enumerate(grads_vars):\n            if self.clipnorm > 0.0:\n                g = self.tf_clip_norm(g, self.clipnorm, tf.cast(norm, g.dtype) )\n\n            ms = self.ms_dict[ v.name ]\n            vs = self.vs_dict[ v.name ]\n            \n            m_t = self.beta_1*ms + (1.0-self.beta_1) * g\n            v_t = self.beta_2*vs + (1.0-self.beta_2) * tf.square(g-m_t)\n\n            lr = tf.constant(self.lr, g.dtype)\n            if self.lr_cos != 0:\n                lr *= (tf.cos(  tf.cast(self.iterations, g.dtype) * (2*3.1415926535/ float(self.lr_cos) )  ) + 1.0) / 2.0\n\n            v_diff = - lr * m_t / (tf.sqrt(v_t) + np.finfo( g.dtype.as_numpy_dtype ).resolution )\n            if self.lr_dropout != 1.0:\n                lr_rnd = self.lr_rnds_dict[v.name]\n                v_diff *= lr_rnd\n            new_v = v + v_diff\n\n            updates.append (state_ops.assign(ms, m_t))\n            updates.append (state_ops.assign(vs, v_t))\n            updates.append (state_ops.assign(v, new_v))\n\n        return control_flow_ops.group ( *updates, name=self.name+'_updates')\nnn.AdaBelief = AdaBelief\n", "core/leras/archis/DeepFakeArchi.py": "from core.leras import nn\ntf = nn.tf\n\nclass DeepFakeArchi(nn.ArchiBase):\n    \"\"\"\n    resolution\n\n    mod     None - default\n            'quick'\n\n    opts    ''\n            ''\n            't'\n    \"\"\"\n    def __init__(self, resolution, use_fp16=False, mod=None, opts=None):\n        super().__init__()\n\n        if opts is None:\n            opts = ''\n\n\n        conv_dtype = tf.float16 if use_fp16 else tf.float32\n        \n        if 'c' in opts:\n            def act(x, alpha=0.1):\n                return x*tf.cos(x)\n        else:\n            def act(x, alpha=0.1):\n                return tf.nn.leaky_relu(x, alpha)\n                \n        if mod is None:\n            class Downscale(nn.ModelBase):\n                def __init__(self, in_ch, out_ch, kernel_size=5, *kwargs ):\n                    self.in_ch = in_ch\n                    self.out_ch = out_ch\n                    self.kernel_size = kernel_size\n                    super().__init__(*kwargs)\n\n                def on_build(self, *args, **kwargs ):\n                    self.conv1 = nn.Conv2D( self.in_ch, self.out_ch, kernel_size=self.kernel_size, strides=2, padding='SAME', dtype=conv_dtype)\n\n                def forward(self, x):\n                    x = self.conv1(x)\n                    x = act(x, 0.1)\n                    return x\n\n                def get_out_ch(self):\n                    return self.out_ch\n\n            class DownscaleBlock(nn.ModelBase):\n                def on_build(self, in_ch, ch, n_downscales, kernel_size):\n                    self.downs = []\n\n                    last_ch = in_ch\n                    for i in range(n_downscales):\n                        cur_ch = ch*( min(2**i, 8)  )\n                        self.downs.append ( Downscale(last_ch, cur_ch, kernel_size=kernel_size))\n                        last_ch = self.downs[-1].get_out_ch()\n\n                def forward(self, inp):\n                    x = inp\n                    for down in self.downs:\n                        x = down(x)\n                    return x\n\n            class Upscale(nn.ModelBase):\n                def on_build(self, in_ch, out_ch, kernel_size=3):\n                    self.conv1 = nn.Conv2D( in_ch, out_ch*4, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n\n                def forward(self, x):\n                    x = self.conv1(x)\n                    x = act(x, 0.1)\n                    x = nn.depth_to_space(x, 2)\n                    return x\n\n            class ResidualBlock(nn.ModelBase):\n                def on_build(self, ch, kernel_size=3):\n                    self.conv1 = nn.Conv2D( ch, ch, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n                    self.conv2 = nn.Conv2D( ch, ch, kernel_size=kernel_size, padding='SAME', dtype=conv_dtype)\n\n                def forward(self, inp):\n                    x = self.conv1(inp)\n                    x = act(x, 0.2)\n                    x = self.conv2(x)\n                    x = act(inp + x, 0.2)\n                    return x\n\n            class Encoder(nn.ModelBase):\n                def __init__(self, in_ch, e_ch, **kwargs ):\n                    self.in_ch = in_ch\n                    self.e_ch = e_ch\n                    super().__init__(**kwargs)\n\n                def on_build(self):\n                    if 't' in opts:\n                        self.down1 = Downscale(self.in_ch, self.e_ch, kernel_size=5)\n                        self.res1 = ResidualBlock(self.e_ch)\n                        self.down2 = Downscale(self.e_ch, self.e_ch*2, kernel_size=5)\n                        self.down3 = Downscale(self.e_ch*2, self.e_ch*4, kernel_size=5)\n                        self.down4 = Downscale(self.e_ch*4, self.e_ch*8, kernel_size=5)\n                        self.down5 = Downscale(self.e_ch*8, self.e_ch*8, kernel_size=5)\n                        self.res5 = ResidualBlock(self.e_ch*8)\n                    else:\n                        self.down1 = DownscaleBlock(self.in_ch, self.e_ch, n_downscales=4 if 't' not in opts else 5, kernel_size=5)\n\n                def forward(self, x):\n                    if use_fp16:\n                        x = tf.cast(x, tf.float16)\n\n                    if 't' in opts:\n                        x = self.down1(x)\n                        x = self.res1(x)\n                        x = self.down2(x)\n                        x = self.down3(x)\n                        x = self.down4(x)\n                        x = self.down5(x)\n                        x = self.res5(x)\n                    else:\n                        x = self.down1(x)\n                    x = nn.flatten(x)\n                    if 'u' in opts:\n                        x = nn.pixel_norm(x, axes=-1)\n\n                    if use_fp16:\n                        x = tf.cast(x, tf.float32)\n                    return x\n\n                def get_out_res(self, res):\n                    return res // ( (2**4) if 't' not in opts else (2**5) )\n\n                def get_out_ch(self):\n                    return self.e_ch * 8\n\n            lowest_dense_res = resolution // (32 if 'd' in opts else 16)\n\n            class Inter(nn.ModelBase):\n                def __init__(self, in_ch, ae_ch, ae_out_ch, **kwargs):\n                    self.in_ch, self.ae_ch, self.ae_out_ch = in_ch, ae_ch, ae_out_ch\n                    super().__init__(**kwargs)\n\n                def on_build(self):\n                    in_ch, ae_ch, ae_out_ch = self.in_ch, self.ae_ch, self.ae_out_ch\n\n                    self.dense1 = nn.Dense( in_ch, ae_ch )\n                    self.dense2 = nn.Dense( ae_ch, lowest_dense_res * lowest_dense_res * ae_out_ch )\n                    if 't' not in opts:\n                        self.upscale1 = Upscale(ae_out_ch, ae_out_ch)\n\n                def forward(self, inp):\n                    x = inp\n                    x = self.dense1(x)\n                    x = self.dense2(x)\n                    x = nn.reshape_4D (x, lowest_dense_res, lowest_dense_res, self.ae_out_ch)\n\n                    if use_fp16:\n                        x = tf.cast(x, tf.float16)\n\n                    if 't' not in opts:\n                        x = self.upscale1(x)\n\n                    return x\n\n                def get_out_res(self):\n                    return lowest_dense_res * 2 if 't' not in opts else lowest_dense_res\n\n                def get_out_ch(self):\n                    return self.ae_out_ch\n\n            class Decoder(nn.ModelBase):\n                def on_build(self, in_ch, d_ch, d_mask_ch):\n                    if 't' not in opts:\n                        self.upscale0 = Upscale(in_ch, d_ch*8, kernel_size=3)\n                        self.upscale1 = Upscale(d_ch*8, d_ch*4, kernel_size=3)\n                        self.upscale2 = Upscale(d_ch*4, d_ch*2, kernel_size=3)\n                        self.res0 = ResidualBlock(d_ch*8, kernel_size=3)\n                        self.res1 = ResidualBlock(d_ch*4, kernel_size=3)\n                        self.res2 = ResidualBlock(d_ch*2, kernel_size=3)\n\n                        self.upscalem0 = Upscale(in_ch, d_mask_ch*8, kernel_size=3)\n                        self.upscalem1 = Upscale(d_mask_ch*8, d_mask_ch*4, kernel_size=3)\n                        self.upscalem2 = Upscale(d_mask_ch*4, d_mask_ch*2, kernel_size=3)\n\n                        self.out_conv  = nn.Conv2D( d_ch*2, 3, kernel_size=1, padding='SAME', dtype=conv_dtype)\n\n                        if 'd' in opts:\n                            self.out_conv1 = nn.Conv2D( d_ch*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                            self.out_conv2 = nn.Conv2D( d_ch*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                            self.out_conv3 = nn.Conv2D( d_ch*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                            self.upscalem3 = Upscale(d_mask_ch*2, d_mask_ch*1, kernel_size=3)\n                            self.out_convm = nn.Conv2D( d_mask_ch*1, 1, kernel_size=1, padding='SAME', dtype=conv_dtype)\n                        else:\n                            self.out_convm = nn.Conv2D( d_mask_ch*2, 1, kernel_size=1, padding='SAME', dtype=conv_dtype)\n                    else:\n                        self.upscale0 = Upscale(in_ch, d_ch*8, kernel_size=3)\n                        self.upscale1 = Upscale(d_ch*8, d_ch*8, kernel_size=3)\n                        self.upscale2 = Upscale(d_ch*8, d_ch*4, kernel_size=3)\n                        self.upscale3 = Upscale(d_ch*4, d_ch*2, kernel_size=3)\n                        self.res0 = ResidualBlock(d_ch*8, kernel_size=3)\n                        self.res1 = ResidualBlock(d_ch*8, kernel_size=3)\n                        self.res2 = ResidualBlock(d_ch*4, kernel_size=3)\n                        self.res3 = ResidualBlock(d_ch*2, kernel_size=3)\n\n                        self.upscalem0 = Upscale(in_ch, d_mask_ch*8, kernel_size=3)\n                        self.upscalem1 = Upscale(d_mask_ch*8, d_mask_ch*8, kernel_size=3)\n                        self.upscalem2 = Upscale(d_mask_ch*8, d_mask_ch*4, kernel_size=3)\n                        self.upscalem3 = Upscale(d_mask_ch*4, d_mask_ch*2, kernel_size=3)\n                        self.out_conv  = nn.Conv2D( d_ch*2, 3, kernel_size=1, padding='SAME', dtype=conv_dtype)\n\n                        if 'd' in opts:\n                            self.out_conv1 = nn.Conv2D( d_ch*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                            self.out_conv2 = nn.Conv2D( d_ch*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                            self.out_conv3 = nn.Conv2D( d_ch*2, 3, kernel_size=3, padding='SAME', dtype=conv_dtype)\n                            self.upscalem4 = Upscale(d_mask_ch*2, d_mask_ch*1, kernel_size=3)\n                            self.out_convm = nn.Conv2D( d_mask_ch*1, 1, kernel_size=1, padding='SAME', dtype=conv_dtype)\n                        else:\n                            self.out_convm = nn.Conv2D( d_mask_ch*2, 1, kernel_size=1, padding='SAME', dtype=conv_dtype)\n\n                \n                    \n                def forward(self, z):\n                    x = self.upscale0(z)\n                    x = self.res0(x)\n                    x = self.upscale1(x)\n                    x = self.res1(x)\n                    x = self.upscale2(x)\n                    x = self.res2(x)\n\n                    if 't' in opts:\n                        x = self.upscale3(x)\n                        x = self.res3(x)\n\n                    if 'd' in opts:\n                        x = tf.nn.sigmoid( nn.depth_to_space(tf.concat( (self.out_conv(x),\n                                                                         self.out_conv1(x),\n                                                                         self.out_conv2(x),\n                                                                         self.out_conv3(x)), nn.conv2d_ch_axis), 2) )\n                    else:\n                        x = tf.nn.sigmoid(self.out_conv(x))\n\n\n                    m = self.upscalem0(z)\n                    m = self.upscalem1(m)\n                    m = self.upscalem2(m)\n\n                    if 't' in opts:\n                        m = self.upscalem3(m)\n                        if 'd' in opts:\n                            m = self.upscalem4(m)\n                    else:\n                        if 'd' in opts:\n                            m = self.upscalem3(m)\n\n                    m = tf.nn.sigmoid(self.out_convm(m))\n\n                    if use_fp16:\n                        x = tf.cast(x, tf.float32)\n                        m = tf.cast(m, tf.float32)\n\n                    return x, m\n\n        self.Encoder = Encoder\n        self.Inter = Inter\n        self.Decoder = Decoder\n\nnn.DeepFakeArchi = DeepFakeArchi", "core/leras/archis/__init__.py": "from .ArchiBase import *\nfrom .DeepFakeArchi import *", "core/leras/archis/ArchiBase.py": "from core.leras import nn\n\nclass ArchiBase():\n    \n    def __init__(self, *args, name=None, **kwargs):\n        self.name=name\n        \n       \n    #overridable \n    def flow(self, *args, **kwargs):\n        raise Exception(\"this archi does not support flow. Use model classes directly.\")\n    \n    #overridable\n    def get_weights(self):\n        pass\n    \nnn.ArchiBase = ArchiBase", "core/leras/initializers/CA.py": "import multiprocessing\nfrom core.joblib import Subprocessor\nimport numpy as np\n\nclass CAInitializerSubprocessor(Subprocessor):\n    @staticmethod\n    def generate(shape, dtype=np.float32, eps_std=0.05):\n        \"\"\"\n        Super fast implementation of Convolution Aware Initialization for 4D shapes\n        Convolution Aware Initialization https://arxiv.org/abs/1702.06295\n        \"\"\"\n        if len(shape) != 4:\n            raise ValueError(\"only shape with rank 4 supported.\")\n\n        row, column, stack_size, filters_size = shape\n\n        fan_in = stack_size * (row * column)\n\n        kernel_shape = (row, column)\n\n        kernel_fft_shape = np.fft.rfft2(np.zeros(kernel_shape)).shape\n\n        basis_size = np.prod(kernel_fft_shape)\n        if basis_size == 1:\n            x = np.random.normal( 0.0, eps_std, (filters_size, stack_size, basis_size) )\n        else:\n            nbb = stack_size // basis_size + 1\n            x = np.random.normal(0.0, 1.0, (filters_size, nbb, basis_size, basis_size))\n            x = x + np.transpose(x, (0,1,3,2) ) * (1-np.eye(basis_size))\n            u, _, v = np.linalg.svd(x)\n            x = np.transpose(u, (0,1,3,2) )\n            x = np.reshape(x, (filters_size, -1, basis_size) )\n            x = x[:,:stack_size,:]\n\n        x = np.reshape(x, ( (filters_size,stack_size,) + kernel_fft_shape ) )\n\n        x = np.fft.irfft2( x, kernel_shape ) \\\n            + np.random.normal(0, eps_std, (filters_size,stack_size,)+kernel_shape)\n\n        x = x * np.sqrt( (2/fan_in) / np.var(x) )\n        x = np.transpose( x, (2, 3, 1, 0) )\n        return x.astype(dtype)\n\n    class Cli(Subprocessor.Cli):\n        #override\n        def process_data(self, data):\n            idx, shape, dtype = data\n            weights = CAInitializerSubprocessor.generate (shape, dtype)\n            return idx, weights\n\n    #override\n    def __init__(self, data_list):\n        self.data_list = data_list\n        self.data_list_idxs = [*range(len(data_list))]\n        self.result = [None]*len(data_list)\n        super().__init__('CAInitializerSubprocessor', CAInitializerSubprocessor.Cli)\n\n    #override\n    def process_info_generator(self):\n        for i in range( min(multiprocessing.cpu_count(), len(self.data_list)) ):\n            yield 'CPU%d' % (i), {}, {}\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.data_list_idxs) > 0:\n            idx = self.data_list_idxs.pop(0)\n            shape, dtype = self.data_list[idx]\n            return idx, shape, dtype\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.data_list_idxs.insert(0, data)\n\n    #override\n    def on_result (self, host_dict, data, result):\n        idx, weights = result\n        self.result[idx] = weights\n\n    #override\n    def get_result(self):\n        return self.result\n", "core/leras/initializers/__init__.py": "import numpy as np\nfrom tensorflow.python.ops import init_ops\n\nfrom core.leras import nn\n\ntf = nn.tf\n\nfrom .CA import CAInitializerSubprocessor\n\nclass initializers():\n    class ca (init_ops.Initializer):\n        def __call__(self, shape, dtype=None, partition_info=None):\n            return tf.zeros( shape, dtype=dtype, name=\"_cai_\")\n\n        @staticmethod\n        def generate_batch( data_list, eps_std=0.05 ):\n            # list of (shape, np.dtype)\n            return CAInitializerSubprocessor (data_list).run()\n\nnn.initializers = initializers\n", "core/leras/ops/__init__.py": "import numpy as np\nfrom core.leras import nn\ntf = nn.tf\nfrom tensorflow.python.ops import array_ops, random_ops, math_ops, sparse_ops, gradients\nfrom tensorflow.python.framework import sparse_tensor\n\ndef tf_get_value(tensor):\n    return nn.tf_sess.run (tensor)\nnn.tf_get_value = tf_get_value\n\n\ndef batch_set_value(tuples):\n    if len(tuples) != 0:\n        with nn.tf.device('/CPU:0'):\n            assign_ops = []\n            feed_dict = {}\n\n            for x, value in tuples:\n                if isinstance(value, nn.tf.Operation) or \\\n                    isinstance(value, nn.tf.Variable):\n                    assign_ops.append(value)\n                else:\n                    value = np.asarray(value, dtype=x.dtype.as_numpy_dtype)\n                    assign_placeholder = nn.tf.placeholder( x.dtype.base_dtype, shape=[None]*value.ndim )\n                    assign_op = nn.tf.assign (x, assign_placeholder )\n                    assign_ops.append(assign_op)\n                    feed_dict[assign_placeholder] = value\n\n            nn.tf_sess.run(assign_ops, feed_dict=feed_dict)\nnn.batch_set_value = batch_set_value\n\ndef init_weights(weights):\n    ops = []\n\n    ca_tuples_w = []\n    ca_tuples = []\n    for w in weights:\n        initializer = w.initializer\n        for input in initializer.inputs:\n            if \"_cai_\" in input.name:\n                ca_tuples_w.append (w)\n                ca_tuples.append ( (w.shape.as_list(), w.dtype.as_numpy_dtype) )\n                break\n        else:\n            ops.append (initializer)\n\n    if len(ops) != 0:\n        nn.tf_sess.run (ops)\n\n    if len(ca_tuples) != 0:\n        nn.batch_set_value( [*zip(ca_tuples_w, nn.initializers.ca.generate_batch (ca_tuples))] )\nnn.init_weights = init_weights\n\ndef tf_gradients ( loss, vars ):\n    grads = gradients.gradients(loss, vars, colocate_gradients_with_ops=True )\n    gv = [*zip(grads,vars)]\n    for g,v in gv:\n        if g is None:\n            raise Exception(f\"Variable {v.name} is declared as trainable, but no tensors flow through it.\")\n    return gv\nnn.gradients = tf_gradients\n\ndef average_gv_list(grad_var_list, tf_device_string=None):\n    if len(grad_var_list) == 1:\n        return grad_var_list[0]\n\n    e = tf.device(tf_device_string) if tf_device_string is not None else None\n    if e is not None: e.__enter__()\n    result = []\n    for i, (gv) in enumerate(grad_var_list):\n        for j,(g,v) in enumerate(gv):\n            g = tf.expand_dims(g, 0)\n            if i == 0:\n                result += [ [[g], v]  ]\n            else:\n                result[j][0] += [g]\n\n    for i,(gs,v) in enumerate(result):\n        result[i] = ( tf.reduce_mean( tf.concat (gs, 0), 0 ), v )\n    if e is not None: e.__exit__(None,None,None)\n    return result\nnn.average_gv_list = average_gv_list\n\ndef average_tensor_list(tensors_list, tf_device_string=None):\n    if len(tensors_list) == 1:\n        return tensors_list[0]\n\n    e = tf.device(tf_device_string) if tf_device_string is not None else None\n    if e is not None: e.__enter__()\n    result = tf.reduce_mean(tf.concat ([tf.expand_dims(t, 0) for t in tensors_list], 0), 0)\n    if e is not None: e.__exit__(None,None,None)\n    return result\nnn.average_tensor_list = average_tensor_list\n\ndef concat (tensors_list, axis):\n    \"\"\"\n    Better version.\n    \"\"\"\n    if len(tensors_list) == 1:\n        return tensors_list[0]\n    return tf.concat(tensors_list, axis)\nnn.concat = concat\n\ndef gelu(x):\n    cdf = 0.5 * (1.0 + tf.nn.tanh((np.sqrt(2 / np.pi) * (x + 0.044715 * tf.pow(x, 3)))))\n    return x * cdf\nnn.gelu = gelu\n\ndef upsample2d(x, size=2):\n    if nn.data_format == \"NCHW\":\n        x = tf.transpose(x, (0,2,3,1))\n        x = tf.image.resize_nearest_neighbor(x, (x.shape[1]*size, x.shape[2]*size) )\n        x = tf.transpose(x, (0,3,1,2))\n        \n        \n        # b,c,h,w = x.shape.as_list()\n        # x = tf.reshape (x, (-1,c,h,1,w,1) )\n        # x = tf.tile(x, (1,1,1,size,1,size) )\n        # x = tf.reshape (x, (-1,c,h*size,w*size) )\n        return x\n    else:\n        return tf.image.resize_nearest_neighbor(x, (x.shape[1]*size, x.shape[2]*size) )\nnn.upsample2d = upsample2d\n\ndef resize2d_bilinear(x, size=2):\n    h = x.shape[nn.conv2d_spatial_axes[0]].value\n    w = x.shape[nn.conv2d_spatial_axes[1]].value\n\n    if nn.data_format == \"NCHW\":\n        x = tf.transpose(x, (0,2,3,1))\n\n    if size > 0:\n        new_size = (h*size,w*size)\n    else:\n        new_size = (h//-size,w//-size)\n\n    x = tf.image.resize(x, new_size, method=tf.image.ResizeMethod.BILINEAR)\n\n    if nn.data_format == \"NCHW\":\n        x = tf.transpose(x, (0,3,1,2))\n\n    return x\nnn.resize2d_bilinear = resize2d_bilinear\n\ndef resize2d_nearest(x, size=2):\n    if size in [-1,0,1]:\n        return x\n\n\n    if size > 0:\n        raise Exception(\"\")\n    else:\n        if nn.data_format == \"NCHW\":\n            x = x[:,:,::-size,::-size]\n        else:\n            x = x[:,::-size,::-size,:]\n    return x\n\n    h = x.shape[nn.conv2d_spatial_axes[0]].value\n    w = x.shape[nn.conv2d_spatial_axes[1]].value\n\n    if nn.data_format == \"NCHW\":\n        x = tf.transpose(x, (0,2,3,1))\n\n    if size > 0:\n        new_size = (h*size,w*size)\n    else:\n        new_size = (h//-size,w//-size)\n\n    x = tf.image.resize(x, new_size, method=tf.image.ResizeMethod.NEAREST_NEIGHBOR)\n\n    if nn.data_format == \"NCHW\":\n        x = tf.transpose(x, (0,3,1,2))\n\n    return x\nnn.resize2d_nearest = resize2d_nearest\n\ndef flatten(x):\n    if nn.data_format == \"NHWC\":\n        # match NCHW version in order to switch data_format without problems\n        x = tf.transpose(x, (0,3,1,2) )\n    return tf.reshape (x, (-1, np.prod(x.shape[1:])) )\n\nnn.flatten = flatten\n\ndef max_pool(x, kernel_size=2, strides=2):\n    if nn.data_format == \"NHWC\":\n        return tf.nn.max_pool(x, [1,kernel_size,kernel_size,1], [1,strides,strides,1], 'SAME', data_format=nn.data_format)\n    else:\n        return tf.nn.max_pool(x, [1,1,kernel_size,kernel_size], [1,1,strides,strides], 'SAME', data_format=nn.data_format)\n\nnn.max_pool = max_pool\n\ndef reshape_4D(x, w,h,c):\n    if nn.data_format == \"NHWC\":\n        # match NCHW version in order to switch data_format without problems\n        x = tf.reshape (x, (-1,c,h,w))\n        x = tf.transpose(x, (0,2,3,1) )\n        return x\n    else:\n        return tf.reshape (x, (-1,c,h,w))\nnn.reshape_4D = reshape_4D\n\ndef random_binomial(shape, p=0.0, dtype=None, seed=None):\n    if dtype is None:\n        dtype=tf.float32\n\n    if seed is None:\n        seed = np.random.randint(10e6)\n    return array_ops.where(\n        random_ops.random_uniform(shape, dtype=tf.float16, seed=seed) < p,\n             array_ops.ones(shape, dtype=dtype), array_ops.zeros(shape, dtype=dtype))\nnn.random_binomial = random_binomial\n\ndef gaussian_blur(input, radius=2.0):\n    def gaussian(x, mu, sigma):\n        return np.exp(-(float(x) - float(mu)) ** 2 / (2 * sigma ** 2))\n\n    def make_kernel(sigma):\n        kernel_size = max(3, int(2 * 2 * sigma))\n        if kernel_size % 2 == 0:\n            kernel_size += 1\n        mean = np.floor(0.5 * kernel_size)\n        kernel_1d = np.array([gaussian(x, mean, sigma) for x in range(kernel_size)])\n        np_kernel = np.outer(kernel_1d, kernel_1d).astype(np.float32)\n        kernel = np_kernel / np.sum(np_kernel)\n        return kernel, kernel_size\n\n    gauss_kernel, kernel_size = make_kernel(radius)\n    padding = kernel_size//2\n    if padding != 0:\n        if nn.data_format == \"NHWC\":\n            padding = [ [0,0], [padding,padding], [padding,padding], [0,0] ]\n        else:\n            padding = [ [0,0], [0,0], [padding,padding], [padding,padding] ]\n    else:\n        padding = None\n    gauss_kernel = gauss_kernel[:,:,None,None]\n\n    x = input\n    k = tf.tile (gauss_kernel, (1,1,x.shape[nn.conv2d_ch_axis],1) )\n    x = tf.pad(x, padding )\n    x = tf.nn.depthwise_conv2d(x, k, strides=[1,1,1,1], padding='VALID', data_format=nn.data_format)\n    return x\nnn.gaussian_blur = gaussian_blur\n\ndef style_loss(target, style, gaussian_blur_radius=0.0, loss_weight=1.0, step_size=1):\n    def sd(content, style, loss_weight):\n        content_nc = content.shape[ nn.conv2d_ch_axis ]\n        style_nc = style.shape[nn.conv2d_ch_axis]\n        if content_nc != style_nc:\n            raise Exception(\"style_loss() content_nc != style_nc\")\n        c_mean, c_var = tf.nn.moments(content, axes=nn.conv2d_spatial_axes, keep_dims=True)\n        s_mean, s_var = tf.nn.moments(style, axes=nn.conv2d_spatial_axes, keep_dims=True)\n        c_std, s_std = tf.sqrt(c_var + 1e-5), tf.sqrt(s_var + 1e-5)\n        mean_loss = tf.reduce_sum(tf.square(c_mean-s_mean), axis=[1,2,3])\n        std_loss  = tf.reduce_sum(tf.square(c_std-s_std), axis=[1,2,3])\n        return (mean_loss + std_loss) * ( loss_weight / content_nc.value )\n\n    if gaussian_blur_radius > 0.0:\n        target = gaussian_blur(target, gaussian_blur_radius)\n        style = gaussian_blur(style, gaussian_blur_radius)\n\n    return sd( target, style, loss_weight=loss_weight )\n\nnn.style_loss = style_loss\n\ndef dssim(img1,img2, max_val, filter_size=11, filter_sigma=1.5, k1=0.01, k2=0.03):\n    if img1.dtype != img2.dtype:\n        raise ValueError(\"img1.dtype != img2.dtype\")\n\n    not_float32 = img1.dtype != tf.float32\n\n    if not_float32:\n        img_dtype = img1.dtype\n        img1 = tf.cast(img1, tf.float32)\n        img2 = tf.cast(img2, tf.float32)\n\n    filter_size = max(1, filter_size)\n\n    kernel = np.arange(0, filter_size, dtype=np.float32)\n    kernel -= (filter_size - 1 ) / 2.0\n    kernel = kernel**2\n    kernel *= ( -0.5 / (filter_sigma**2) )\n    kernel = np.reshape (kernel, (1,-1)) + np.reshape(kernel, (-1,1) )\n    kernel = tf.constant ( np.reshape (kernel, (1,-1)), dtype=tf.float32 )\n    kernel = tf.nn.softmax(kernel)\n    kernel = tf.reshape (kernel, (filter_size, filter_size, 1, 1))\n    kernel = tf.tile (kernel, (1,1, img1.shape[ nn.conv2d_ch_axis ] ,1))\n\n    def reducer(x):\n        return tf.nn.depthwise_conv2d(x, kernel, strides=[1,1,1,1], padding='VALID', data_format=nn.data_format)\n\n    c1 = (k1 * max_val) ** 2\n    c2 = (k2 * max_val) ** 2\n\n    mean0 = reducer(img1)\n    mean1 = reducer(img2)\n    num0 = mean0 * mean1 * 2.0\n    den0 = tf.square(mean0) + tf.square(mean1)\n    luminance = (num0 + c1) / (den0 + c1)\n\n    num1 = reducer(img1 * img2) * 2.0\n    den1 = reducer(tf.square(img1) + tf.square(img2))\n    c2 *= 1.0 #compensation factor\n    cs = (num1 - num0 + c2) / (den1 - den0 + c2)\n\n    ssim_val = tf.reduce_mean(luminance * cs, axis=nn.conv2d_spatial_axes )\n    dssim = (1.0 - ssim_val ) / 2.0\n\n    if not_float32:\n        dssim = tf.cast(dssim, img_dtype)\n    return dssim\n\nnn.dssim = dssim\n\ndef space_to_depth(x, size):\n    if nn.data_format == \"NHWC\":\n        # match NCHW version in order to switch data_format without problems\n        b,h,w,c = x.shape.as_list()\n        oh, ow = h // size, w // size\n        x = tf.reshape(x, (-1, size, oh, size, ow, c))\n        x = tf.transpose(x, (0, 2, 4, 1, 3, 5))\n        x = tf.reshape(x, (-1, oh, ow, size* size* c ))\n        return x\n    else:\n        return tf.space_to_depth(x, size, data_format=nn.data_format)\nnn.space_to_depth = space_to_depth\n\ndef depth_to_space(x, size):\n    if nn.data_format == \"NHWC\":\n        # match NCHW version in order to switch data_format without problems\n\n        b,h,w,c = x.shape.as_list()\n        oh, ow = h * size, w * size\n        oc = c // (size * size)\n\n        x = tf.reshape(x, (-1, h, w, size, size, oc, ) )\n        x = tf.transpose(x, (0, 1, 3, 2, 4, 5))\n        x = tf.reshape(x, (-1, oh, ow, oc, ))\n        return x\n    else:\n        cfg = nn.getCurrentDeviceConfig()\n        if not cfg.cpu_only:\n            return tf.depth_to_space(x, size, data_format=nn.data_format)\n        b,c,h,w = x.shape.as_list()\n        oh, ow = h * size, w * size\n        oc = c // (size * size)\n\n        x = tf.reshape(x, (-1, size, size, oc, h, w, ) )\n        x = tf.transpose(x, (0, 3, 4, 1, 5, 2))\n        x = tf.reshape(x, (-1, oc, oh, ow))\n        return x\nnn.depth_to_space = depth_to_space\n\ndef rgb_to_lab(srgb):\n    srgb_pixels = tf.reshape(srgb, [-1, 3])\n    linear_mask = tf.cast(srgb_pixels <= 0.04045, dtype=tf.float32)\n    exponential_mask = tf.cast(srgb_pixels > 0.04045, dtype=tf.float32)\n    rgb_pixels = (srgb_pixels / 12.92 * linear_mask) + (((srgb_pixels + 0.055) / 1.055) ** 2.4) * exponential_mask\n    rgb_to_xyz = tf.constant([\n        #    X        Y          Z\n        [0.412453, 0.212671, 0.019334], # R\n        [0.357580, 0.715160, 0.119193], # G\n        [0.180423, 0.072169, 0.950227], # B\n    ])\n    xyz_pixels = tf.matmul(rgb_pixels, rgb_to_xyz)\n\n    xyz_normalized_pixels = tf.multiply(xyz_pixels, [1/0.950456, 1.0, 1/1.088754])\n\n    epsilon = 6/29\n    linear_mask = tf.cast(xyz_normalized_pixels <= (epsilon**3), dtype=tf.float32)\n    exponential_mask = tf.cast(xyz_normalized_pixels > (epsilon**3), dtype=tf.float32)\n    fxfyfz_pixels = (xyz_normalized_pixels / (3 * epsilon**2) + 4/29) * linear_mask + (xyz_normalized_pixels ** (1/3)) * exponential_mask\n\n    fxfyfz_to_lab = tf.constant([\n        #  l       a       b\n        [  0.0,  500.0,    0.0], # fx\n        [116.0, -500.0,  200.0], # fy\n        [  0.0,    0.0, -200.0], # fz\n    ])\n    lab_pixels = tf.matmul(fxfyfz_pixels, fxfyfz_to_lab) + tf.constant([-16.0, 0.0, 0.0])\n    return tf.reshape(lab_pixels, tf.shape(srgb))\nnn.rgb_to_lab = rgb_to_lab\n\ndef total_variation_mse(images):\n    \"\"\"\n    Same as generic total_variation, but MSE diff instead of MAE\n    \"\"\"\n    pixel_dif1 = images[:, 1:, :, :] - images[:, :-1, :, :]\n    pixel_dif2 = images[:, :, 1:, :] - images[:, :, :-1, :]\n    \n    tot_var = ( tf.reduce_sum(tf.square(pixel_dif1), axis=[1,2,3]) +\n                tf.reduce_sum(tf.square(pixel_dif2), axis=[1,2,3]) )\n    return tot_var\nnn.total_variation_mse = total_variation_mse\n\n\ndef pixel_norm(x, axes):\n    return x * tf.rsqrt(tf.reduce_mean(tf.square(x), axis=axes, keepdims=True) + 1e-06)\nnn.pixel_norm = pixel_norm\n        \n\"\"\"\ndef tf_suppress_lower_mean(t, eps=0.00001):\n    if t.shape.ndims != 1:\n        raise ValueError(\"tf_suppress_lower_mean: t rank must be 1\")\n    t_mean_eps = tf.reduce_mean(t) - eps\n    q = tf.clip_by_value(t, t_mean_eps, tf.reduce_max(t) )\n    q = tf.clip_by_value(q-t_mean_eps, 0, eps)\n    q = q * (t/eps)\n    return q\n\"\"\"\n\n\n\ndef _get_pixel_value(img, x, y):\n    shape = tf.shape(x)\n    batch_size = shape[0]\n    height = shape[1]\n    width = shape[2]\n\n    batch_idx = tf.range(0, batch_size)\n    batch_idx = tf.reshape(batch_idx, (batch_size, 1, 1))\n    b = tf.tile(batch_idx, (1, height, width))\n\n    indices = tf.stack([b, y, x], 3)\n    \n    return tf.gather_nd(img, indices)\n    \ndef bilinear_sampler(img, x, y):\n    H = tf.shape(img)[1]\n    W = tf.shape(img)[2]\n    H_MAX = tf.cast(H - 1, tf.int32)\n    W_MAX = tf.cast(W - 1, tf.int32)\n\n    # grab 4 nearest corner points for each (x_i, y_i)\n    x0 = tf.cast(tf.floor(x), tf.int32)\n    x1 = x0 + 1\n    y0 = tf.cast(tf.floor(y), tf.int32)\n    y1 = y0 + 1\n\n    # clip to range [0, H-1/W-1] to not violate img boundaries\n    x0 = tf.clip_by_value(x0, 0, W_MAX)\n    x1 = tf.clip_by_value(x1, 0, W_MAX)\n    y0 = tf.clip_by_value(y0, 0, H_MAX)\n    y1 = tf.clip_by_value(y1, 0, H_MAX)\n\n    # get pixel value at corner coords\n    Ia = _get_pixel_value(img, x0, y0)\n    Ib = _get_pixel_value(img, x0, y1)\n    Ic = _get_pixel_value(img, x1, y0)\n    Id = _get_pixel_value(img, x1, y1)\n\n    # recast as float for delta calculation\n    x0 = tf.cast(x0, tf.float32)\n    x1 = tf.cast(x1, tf.float32)\n    y0 = tf.cast(y0, tf.float32)\n    y1 = tf.cast(y1, tf.float32)\n\n    # calculate deltas\n    wa = (x1-x) * (y1-y)\n    wb = (x1-x) * (y-y0)\n    wc = (x-x0) * (y1-y)\n    wd = (x-x0) * (y-y0)\n\n    # add dimension for addition\n    wa = tf.expand_dims(wa, axis=3)\n    wb = tf.expand_dims(wb, axis=3)\n    wc = tf.expand_dims(wc, axis=3)\n    wd = tf.expand_dims(wd, axis=3)\n\n    # compute output\n    out = tf.add_n([wa*Ia, wb*Ib, wc*Ic, wd*Id])\n\n    return out\n    \nnn.bilinear_sampler = bilinear_sampler\n\n", "core/mplib/MPSharedList.py": "import multiprocessing\nimport pickle\nimport struct\nfrom core.joblib import Subprocessor\n\nclass MPSharedList():\n    \"\"\"\n    Provides read-only pickled list of constant objects via shared memory aka 'multiprocessing.Array'\n    Thus no 4GB limit for subprocesses.\n\n    supports list concat via + or sum()\n    \"\"\"\n\n    def __init__(self, obj_list):\n        if obj_list is None:\n            self.obj_counts    = None\n            self.table_offsets = None\n            self.data_offsets  = None\n            self.sh_bs         = None\n        else:\n            obj_count, table_offset, data_offset, sh_b = MPSharedList.bake_data(obj_list)\n\n            self.obj_counts    = [obj_count]\n            self.table_offsets = [table_offset]\n            self.data_offsets  = [data_offset]\n            self.sh_bs         = [sh_b]\n\n    def __add__(self, o):\n        if isinstance(o, MPSharedList):\n            m = MPSharedList(None)\n            m.obj_counts    = self.obj_counts    + o.obj_counts\n            m.table_offsets = self.table_offsets + o.table_offsets\n            m.data_offsets  = self.data_offsets  + o.data_offsets\n            m.sh_bs         = self.sh_bs         + o.sh_bs\n            return m\n        elif isinstance(o, int):\n            return self\n        else:\n            raise ValueError(f\"MPSharedList object of class {o.__class__} is not supported for __add__ operator.\")\n\n    def __radd__(self, o):\n        return self+o\n\n    def __len__(self):\n        return sum(self.obj_counts)\n\n    def __getitem__(self, key):\n        obj_count = sum(self.obj_counts)\n        if key < 0:\n            key = obj_count+key\n        if key < 0 or key >= obj_count:\n            raise ValueError(\"out of range\")\n\n        for i in range(len(self.obj_counts)):\n\n            if key < self.obj_counts[i]:\n                table_offset = self.table_offsets[i]\n                data_offset = self.data_offsets[i]\n                sh_b = self.sh_bs[i]\n                break\n            key -= self.obj_counts[i]\n\n        sh_b = memoryview(sh_b).cast('B')\n\n        offset_start, offset_end = struct.unpack('<QQ', sh_b[ table_offset + key*8     : table_offset + (key+2)*8].tobytes() )\n\n        return pickle.loads( sh_b[ data_offset + offset_start : data_offset + offset_end ].tobytes() )\n\n    def __iter__(self):\n        for i in range(self.__len__()):\n            yield self.__getitem__(i)\n\n    @staticmethod\n    def bake_data(obj_list):\n        if not isinstance(obj_list, list):\n            raise ValueError(\"MPSharedList: obj_list should be list type.\")\n\n        obj_count = len(obj_list)\n\n        if obj_count != 0:\n            obj_pickled_ar = [pickle.dumps(o, 4) for o in obj_list]\n\n            table_offset = 0\n            table_size   = (obj_count+1)*8\n            data_offset  = table_offset + table_size\n            data_size    = sum([len(x) for x in obj_pickled_ar])\n\n            sh_b = multiprocessing.RawArray('B', table_size + data_size)\n            #sh_b[0:8] = struct.pack('<Q', obj_count)\n            sh_b_view = memoryview(sh_b).cast('B')\n\n            offset = 0\n\n            sh_b_table = bytes()\n            offsets = []\n\n            offset = 0\n            for i in range(obj_count):\n                offsets.append(offset)\n                offset += len(obj_pickled_ar[i])\n            offsets.append(offset)\n\n            sh_b_view[table_offset:table_offset+table_size] = struct.pack( '<'+'Q'*len(offsets), *offsets )\n\n            for i, obj_pickled in enumerate(obj_pickled_ar):\n                offset = data_offset+offsets[i]\n                sh_b_view[offset:offset+len(obj_pickled)] = obj_pickled_ar[i]\n\n            return obj_count, table_offset, data_offset, sh_b\n        return 0, 0, 0, None\n\n", "core/mplib/__init__.py": "from .MPSharedList import MPSharedList\nimport multiprocessing\nimport threading\nimport time\n\nimport numpy as np\n\n\nclass IndexHost():\n    \"\"\"\n    Provides random shuffled indexes for multiprocesses\n    \"\"\"\n    def __init__(self, indexes_count, rnd_seed=None):\n        self.sq = multiprocessing.Queue()\n        self.cqs = []\n        self.clis = []\n        self.thread = threading.Thread(target=self.host_thread, args=(indexes_count,rnd_seed) )\n        self.thread.daemon = True\n        self.thread.start()\n\n    def host_thread(self, indexes_count, rnd_seed):\n        rnd_state = np.random.RandomState(rnd_seed) if rnd_seed is not None else np.random\n\n        idxs = [*range(indexes_count)]\n        shuffle_idxs = []\n        sq = self.sq\n\n        while True:\n            while not sq.empty():\n                obj = sq.get()\n                cq_id, count = obj[0], obj[1]\n\n                result = []\n                for i in range(count):\n                    if len(shuffle_idxs) == 0:\n                        shuffle_idxs = idxs.copy()\n                        rnd_state.shuffle(shuffle_idxs)\n                    result.append(shuffle_idxs.pop())\n                self.cqs[cq_id].put (result)\n\n            time.sleep(0.001)\n\n    def create_cli(self):\n        cq = multiprocessing.Queue()\n        self.cqs.append ( cq )\n        cq_id = len(self.cqs)-1\n        return IndexHost.Cli(self.sq, cq, cq_id)\n\n    # disable pickling\n    def __getstate__(self):\n        return dict()\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n\n    class Cli():\n        def __init__(self, sq, cq, cq_id):\n            self.sq = sq\n            self.cq = cq\n            self.cq_id = cq_id\n\n        def multi_get(self, count):\n            self.sq.put ( (self.cq_id,count) )\n\n            while True:\n                if not self.cq.empty():\n                    return self.cq.get()\n                time.sleep(0.001)\n\nclass Index2DHost():\n    \"\"\"\n    Provides random shuffled indexes for multiprocesses\n    \"\"\"\n    def __init__(self, indexes2D):\n        self.sq = multiprocessing.Queue()\n        self.cqs = []\n        self.clis = []\n        self.thread = threading.Thread(target=self.host_thread, args=(indexes2D,) )\n        self.thread.daemon = True\n        self.thread.start()\n\n    def host_thread(self, indexes2D):\n        indexes2D_len = len(indexes2D)\n\n        idxs = [*range(indexes2D_len)]\n        idxs_2D = [None]*indexes2D_len\n        shuffle_idxs = []\n        shuffle_idxs_2D = [None]*indexes2D_len\n        for i in range(indexes2D_len):\n            idxs_2D[i] = [*range(len(indexes2D[i]))]\n            shuffle_idxs_2D[i] = []\n\n        #print(idxs)\n        #print(idxs_2D)\n        sq = self.sq\n\n        while True:\n            while not sq.empty():\n                obj = sq.get()\n                cq_id, count = obj[0], obj[1]\n\n                result = []\n                for i in range(count):\n                    if len(shuffle_idxs) == 0:\n                        shuffle_idxs = idxs.copy()\n                        np.random.shuffle(shuffle_idxs)\n\n                    idx_1D = shuffle_idxs.pop()\n                    \n                    #print(f'idx_1D = {idx_1D}, len(shuffle_idxs_2D[idx_1D])= {len(shuffle_idxs_2D[idx_1D])}')\n                    \n                    if len(shuffle_idxs_2D[idx_1D]) == 0:\n                        shuffle_idxs_2D[idx_1D] = idxs_2D[idx_1D].copy()\n                        #print(f'new shuffle_idxs_2d for {idx_1D} = { shuffle_idxs_2D[idx_1D] }')\n                        \n                        #print(f'len(shuffle_idxs_2D[idx_1D])= {len(shuffle_idxs_2D[idx_1D])}')\n                    \n                        np.random.shuffle( shuffle_idxs_2D[idx_1D] )\n\n                    idx_2D = shuffle_idxs_2D[idx_1D].pop()\n                    \n                    #print(f'len(shuffle_idxs_2D[idx_1D])= {len(shuffle_idxs_2D[idx_1D])}')\n                    \n                    #print(f'idx_2D = {idx_2D}')\n                    \n\n                    result.append( indexes2D[idx_1D][idx_2D])\n\n                self.cqs[cq_id].put (result)\n\n            time.sleep(0.001)\n\n    def create_cli(self):\n        cq = multiprocessing.Queue()\n        self.cqs.append ( cq )\n        cq_id = len(self.cqs)-1\n        return Index2DHost.Cli(self.sq, cq, cq_id)\n\n    # disable pickling\n    def __getstate__(self):\n        return dict()\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n\n    class Cli():\n        def __init__(self, sq, cq, cq_id):\n            self.sq = sq\n            self.cq = cq\n            self.cq_id = cq_id\n\n        def multi_get(self, count):\n            self.sq.put ( (self.cq_id,count) )\n\n            while True:\n                if not self.cq.empty():\n                    return self.cq.get()\n                time.sleep(0.001)\n\nclass ListHost():\n    def __init__(self, list_):\n        self.sq = multiprocessing.Queue()\n        self.cqs = []\n        self.clis = []\n        self.m_list = list_\n        self.thread = threading.Thread(target=self.host_thread)\n        self.thread.daemon = True\n        self.thread.start()\n\n    def host_thread(self):\n        sq = self.sq\n        while True:\n            while not sq.empty():\n                obj = sq.get()\n                cq_id, cmd = obj[0], obj[1]\n\n                if cmd == 0:\n                    self.cqs[cq_id].put ( len(self.m_list) )\n                elif cmd == 1:\n                    idx = obj[2]\n                    item = self.m_list[idx ]\n                    self.cqs[cq_id].put ( item )\n                elif cmd == 2:\n                    result = []\n                    for item in obj[2]:\n                        result.append ( self.m_list[item] )\n                    self.cqs[cq_id].put ( result )\n                elif cmd == 3:\n                    self.m_list.insert(obj[2], obj[3])\n                elif cmd == 4:\n                    self.m_list.append(obj[2])\n                elif cmd == 5:\n                    self.m_list.extend(obj[2])\n\n            time.sleep(0.005)\n\n    def create_cli(self):\n        cq = multiprocessing.Queue()\n        self.cqs.append ( cq )\n        cq_id = len(self.cqs)-1\n        return ListHost.Cli(self.sq, cq, cq_id)\n\n    def get_list(self):\n        return self.list_\n\n    # disable pickling\n    def __getstate__(self):\n        return dict()\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n\n    class Cli():\n        def __init__(self, sq, cq, cq_id):\n            self.sq = sq\n            self.cq = cq\n            self.cq_id = cq_id\n\n        def __len__(self):\n            self.sq.put ( (self.cq_id,0) )\n\n            while True:\n                if not self.cq.empty():\n                    return self.cq.get()\n                time.sleep(0.001)\n\n        def __getitem__(self, key):\n            self.sq.put ( (self.cq_id,1,key) )\n\n            while True:\n                if not self.cq.empty():\n                    return self.cq.get()\n                time.sleep(0.001)\n\n        def multi_get(self, keys):\n            self.sq.put ( (self.cq_id,2,keys) )\n\n            while True:\n                if not self.cq.empty():\n                    return self.cq.get()\n                time.sleep(0.001)\n\n        def insert(self, index, item):\n            self.sq.put ( (self.cq_id,3,index,item) )\n\n        def append(self, item):\n            self.sq.put ( (self.cq_id,4,item) )\n\n        def extend(self, items):\n            self.sq.put ( (self.cq_id,5,items) )\n\n\n\nclass DictHost():\n    def __init__(self, d, num_users):\n        self.sqs = [ multiprocessing.Queue() for _ in range(num_users) ]\n        self.cqs = [ multiprocessing.Queue() for _ in range(num_users) ]\n\n        self.thread = threading.Thread(target=self.host_thread, args=(d,) )\n        self.thread.daemon = True\n        self.thread.start()\n\n        self.clis = [ DictHostCli(sq,cq) for sq, cq in zip(self.sqs, self.cqs) ]\n\n    def host_thread(self, d):\n        while True:\n            for sq, cq in zip(self.sqs, self.cqs):\n                if not sq.empty():\n                    obj = sq.get()\n                    cmd = obj[0]\n                    if cmd == 0:\n                        cq.put (d[ obj[1] ])\n                    elif cmd == 1:\n                        cq.put ( list(d.keys()) )\n\n            time.sleep(0.005)\n\n\n    def get_cli(self, n_user):\n        return self.clis[n_user]\n\n    # disable pickling\n    def __getstate__(self):\n        return dict()\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n\nclass DictHostCli():\n    def __init__(self, sq, cq):\n        self.sq = sq\n        self.cq = cq\n\n    def __getitem__(self, key):\n        self.sq.put ( (0,key) )\n\n        while True:\n            if not self.cq.empty():\n                return self.cq.get()\n            time.sleep(0.001)\n\n    def keys(self):\n        self.sq.put ( (1,) )\n        while True:\n            if not self.cq.empty():\n                return self.cq.get()\n            time.sleep(0.001)\n", "core/joblib/SubprocessorBase.py": "import traceback\nimport multiprocessing\nimport time\nimport sys\nfrom core.interact import interact as io\n\n\nclass Subprocessor(object):\n\n    class SilenceException(Exception):\n        pass\n\n    class Cli(object):\n        def __init__ ( self, client_dict ):\n            s2c = multiprocessing.Queue()\n            c2s = multiprocessing.Queue()\n            self.p = multiprocessing.Process(target=self._subprocess_run, args=(client_dict,s2c,c2s) )\n            self.s2c = s2c\n            self.c2s = c2s\n            self.p.daemon = True\n            self.p.start()\n\n            self.state = None\n            self.sent_time = None\n            self.sent_data = None\n            self.name = None\n            self.host_dict = None\n\n        def kill(self):\n            self.p.terminate()\n            self.p.join()\n\n        #overridable optional\n        def on_initialize(self, client_dict):\n            #initialize your subprocess here using client_dict\n            pass\n\n        #overridable optional\n        def on_finalize(self):\n            #finalize your subprocess here\n            pass\n\n        #overridable\n        def process_data(self, data):\n            #process 'data' given from host and return result\n            raise NotImplementedError\n\n        #overridable optional\n        def get_data_name (self, data):\n            #return string identificator of your 'data'\n            return \"undefined\"\n\n        def log_info(self, msg): self.c2s.put ( {'op': 'log_info', 'msg':msg } )\n        def log_err(self, msg): self.c2s.put ( {'op': 'log_err' , 'msg':msg } )\n        def progress_bar_inc(self, c): self.c2s.put ( {'op': 'progress_bar_inc' , 'c':c } )\n\n        def _subprocess_run(self, client_dict, s2c, c2s):\n            self.c2s = c2s\n            data = None\n            is_error = False\n            try:\n                self.on_initialize(client_dict)\n\n                c2s.put ( {'op': 'init_ok'} )\n\n                while True:\n                    msg = s2c.get()\n                    op = msg.get('op','')\n                    if op == 'data':\n                        data = msg['data']\n                        result = self.process_data (data)\n                        c2s.put ( {'op': 'success', 'data' : data, 'result' : result} )\n                        data = None\n                    elif op == 'close':\n                        break\n\n                    time.sleep(0.001)\n\n                self.on_finalize()\n                c2s.put ( {'op': 'finalized'} )\n            except Subprocessor.SilenceException as e:\n                c2s.put ( {'op': 'error', 'data' : data} )\n            except Exception as e:\n                err_msg = traceback.format_exc()\n                c2s.put ( {'op': 'error', 'data' : data, 'err_msg' : err_msg} )\n\n            c2s.close()\n            s2c.close()\n            self.c2s = None\n\n        # disable pickling\n        def __getstate__(self):\n            return dict()\n        def __setstate__(self, d):\n            self.__dict__.update(d)\n\n    #overridable\n    def __init__(self, name, SubprocessorCli_class, no_response_time_sec = 0, io_loop_sleep_time=0.005, initialize_subprocesses_in_serial=False):\n        if not issubclass(SubprocessorCli_class, Subprocessor.Cli):\n            raise ValueError(\"SubprocessorCli_class must be subclass of Subprocessor.Cli\")\n\n        self.name = name\n        self.SubprocessorCli_class = SubprocessorCli_class\n        self.no_response_time_sec = no_response_time_sec\n        self.io_loop_sleep_time = io_loop_sleep_time\n        self.initialize_subprocesses_in_serial = initialize_subprocesses_in_serial\n\n    #overridable\n    def process_info_generator(self):\n        #yield per process (name, host_dict, client_dict)\n        raise NotImplementedError\n\n    #overridable optional\n    def on_clients_initialized(self):\n        #logic when all subprocesses initialized and ready\n        pass\n\n    #overridable optional\n    def on_clients_finalized(self):\n        #logic when all subprocess finalized\n        pass\n\n    #overridable\n    def get_data(self, host_dict):\n        #return data for processing here\n        raise NotImplementedError\n\n    #overridable\n    def on_data_return (self, host_dict, data):\n        #you have to place returned 'data' back to your queue\n        raise NotImplementedError\n\n    #overridable\n    def on_result (self, host_dict, data, result):\n        #your logic what to do with 'result' of 'data'\n        raise NotImplementedError\n\n    #overridable\n    def get_result(self):\n        #return result that will be returned in func run()\n        return None\n\n    #overridable\n    def on_tick(self):\n        #tick in main loop\n        #return True if system can be finalized when no data in get_data, orelse False\n        return True\n\n    #overridable\n    def on_check_run(self):\n        return True\n\n    def run(self):\n        if not self.on_check_run():\n            return self.get_result()\n\n        self.clis = []\n\n        def cli_init_dispatcher(cli):\n            while not cli.c2s.empty():\n                obj = cli.c2s.get()\n                op = obj.get('op','')\n                if op == 'init_ok':\n                    cli.state = 0\n                elif op == 'log_info':\n                    io.log_info(obj['msg'])\n                elif op == 'log_err':\n                    io.log_err(obj['msg'])\n                elif op == 'error':\n                    err_msg = obj.get('err_msg', None)\n                    if err_msg is not None:\n                        io.log_info(f'Error while subprocess initialization: {err_msg}')\n                    cli.kill()\n                    self.clis.remove(cli)\n                    break\n\n        #getting info about name of subprocesses, host and client dicts, and spawning them\n        for name, host_dict, client_dict in self.process_info_generator():\n            try:\n                cli = self.SubprocessorCli_class(client_dict)\n                cli.state = 1\n                cli.sent_time = 0\n                cli.sent_data = None\n                cli.name = name\n                cli.host_dict = host_dict\n\n                self.clis.append (cli)\n\n                if self.initialize_subprocesses_in_serial:\n                    while True:\n                        cli_init_dispatcher(cli)\n                        if cli.state == 0:\n                            break\n                        io.process_messages(0.005)\n            except:\n                raise Exception (f\"Unable to start subprocess {name}. Error: {traceback.format_exc()}\")\n\n        if len(self.clis) == 0:\n            raise Exception (\"Unable to start Subprocessor '%s' \" % (self.name))\n\n        #waiting subprocesses their success(or not) initialization\n        while True:\n            for cli in self.clis[:]:\n                cli_init_dispatcher(cli)\n            if all ([cli.state == 0 for cli in self.clis]):\n                break\n            io.process_messages(0.005)\n\n        if len(self.clis) == 0:\n            raise Exception ( \"Unable to start subprocesses.\" )\n\n        #ok some processes survived, initialize host logic\n\n        self.on_clients_initialized()\n\n        #main loop of data processing\n        while True:\n            for cli in self.clis[:]:\n                while not cli.c2s.empty():\n                    obj = cli.c2s.get()\n                    op = obj.get('op','')\n                    if op == 'success':\n                        #success processed data, return data and result to on_result\n                        self.on_result (cli.host_dict, obj['data'], obj['result'])\n                        self.sent_data = None\n                        cli.state = 0\n                    elif op == 'error':\n                        #some error occured while process data, returning chunk to on_data_return\n                        err_msg = obj.get('err_msg', None)\n                        if err_msg is not None:\n                            io.log_info(f'Error while processing data: {err_msg}')\n                            \n                        if 'data' in obj.keys():\n                            self.on_data_return (cli.host_dict, obj['data'] )                        \n                        #and killing process\n                        cli.kill()\n                        self.clis.remove(cli)\n                    elif op == 'log_info':\n                        io.log_info(obj['msg'])\n                    elif op == 'log_err':\n                        io.log_err(obj['msg'])\n                    elif op == 'progress_bar_inc':\n                        io.progress_bar_inc(obj['c'])\n\n            for cli in self.clis[:]:\n                if cli.state == 1:\n                    if cli.sent_time != 0 and self.no_response_time_sec != 0 and (time.time() - cli.sent_time) > self.no_response_time_sec:\n                        #subprocess busy too long\n                        print ( '%s doesnt response, terminating it.' % (cli.name) )\n                        self.on_data_return (cli.host_dict, cli.sent_data )\n                        cli.kill()\n                        self.clis.remove(cli)\n\n            for cli in self.clis[:]:\n                if cli.state == 0:\n                    #free state of subprocess, get some data from get_data\n                    data = self.get_data(cli.host_dict)\n                    if data is not None:\n                        #and send it to subprocess\n                        cli.s2c.put ( {'op': 'data', 'data' : data} )\n                        cli.sent_time = time.time()\n                        cli.sent_data = data\n                        cli.state = 1\n\n            if self.io_loop_sleep_time != 0:\n                io.process_messages(self.io_loop_sleep_time)\n\n            if self.on_tick() and all ([cli.state == 0 for cli in self.clis]):\n                #all subprocesses free and no more data available to process, ending loop\n                break\n\n\n\n        #gracefully terminating subprocesses\n        for cli in self.clis[:]:\n            cli.s2c.put ( {'op': 'close'} )\n            cli.sent_time = time.time()\n\n        while True:\n            for cli in self.clis[:]:\n                terminate_it = False\n                while not cli.c2s.empty():\n                    obj = cli.c2s.get()\n                    obj_op = obj['op']\n                    if obj_op == 'finalized':\n                        terminate_it = True\n                        break\n\n                if (time.time() - cli.sent_time) > 30:\n                    terminate_it = True\n\n                if terminate_it:\n                    cli.state = 2\n                    cli.kill()\n\n            if all ([cli.state == 2 for cli in self.clis]):\n                break\n\n        #finalizing host logic and return result\n        self.on_clients_finalized()\n\n        return self.get_result()\n", "core/joblib/MPFunc.py": "import multiprocessing\nfrom core.interact import interact as io\n\nclass MPFunc():\n    def __init__(self, func):\n        self.func = func\n        \n        self.s2c = multiprocessing.Queue()\n        self.c2s = multiprocessing.Queue()\n        self.lock = multiprocessing.Lock()\n        \n        io.add_process_messages_callback(self.io_callback)\n\n    def io_callback(self):        \n        while not self.c2s.empty():\n            func_args, func_kwargs = self.c2s.get()\n            self.s2c.put ( self.func (*func_args, **func_kwargs) )\n\n    def __call__(self, *args, **kwargs):\n        with self.lock:\n            self.c2s.put ( (args, kwargs) )\n            return self.s2c.get()\n\n    def __getstate__(self):\n        return {'s2c':self.s2c, 'c2s':self.c2s, 'lock':self.lock}\n", "core/joblib/SubprocessGenerator.py": "import multiprocessing\nimport queue as Queue\nimport threading\nimport time\n\n\nclass SubprocessGenerator(object):\n    \n    @staticmethod\n    def launch_thread(generator): \n        generator._start()\n        \n    @staticmethod\n    def start_in_parallel( generator_list ):\n        \"\"\"\n        Start list of generators in parallel\n        \"\"\"\n        for generator in generator_list:\n            thread = threading.Thread(target=SubprocessGenerator.launch_thread, args=(generator,) )\n            thread.daemon = True\n            thread.start()\n\n        while not all ([generator._is_started() for generator in generator_list]):\n            time.sleep(0.005)\n    \n    def __init__(self, generator_func, user_param=None, prefetch=2, start_now=True):\n        super().__init__()\n        self.prefetch = prefetch\n        self.generator_func = generator_func\n        self.user_param = user_param\n        self.sc_queue = multiprocessing.Queue()\n        self.cs_queue = multiprocessing.Queue()\n        self.p = None\n        if start_now:\n            self._start()\n\n    def _start(self):\n        if self.p == None:\n            user_param = self.user_param\n            self.user_param = None\n            p = multiprocessing.Process(target=self.process_func, args=(user_param,) )\n            p.daemon = True\n            p.start()\n            self.p = p\n            \n    def _is_started(self):\n        return self.p is not None\n        \n    def process_func(self, user_param):\n        self.generator_func = self.generator_func(user_param)\n        while True:\n            while self.prefetch > -1:\n                try:\n                    gen_data = next (self.generator_func)\n                except StopIteration:\n                    self.cs_queue.put (None)\n                    return\n                self.cs_queue.put (gen_data)\n                self.prefetch -= 1\n            self.sc_queue.get()\n            self.prefetch += 1\n\n    def __iter__(self):\n        return self\n\n    def __getstate__(self):\n        self_dict = self.__dict__.copy()\n        del self_dict['p']\n        return self_dict\n\n    def __next__(self):\n        self._start()\n        gen_data = self.cs_queue.get()\n        if gen_data is None:\n            self.p.terminate()\n            self.p.join()\n            raise StopIteration()\n        self.sc_queue.put (1)\n        return gen_data\n", "core/joblib/__init__.py": "from .SubprocessorBase import Subprocessor\nfrom .ThisThreadGenerator import ThisThreadGenerator\nfrom .SubprocessGenerator import SubprocessGenerator\nfrom .MPFunc import MPFunc\nfrom .MPClassFuncOnDemand import MPClassFuncOnDemand", "core/joblib/ThisThreadGenerator.py": "class ThisThreadGenerator(object):\n    def __init__(self, generator_func, user_param=None):\n        super().__init__()\n        self.generator_func = generator_func\n        self.user_param = user_param\n        self.initialized = False\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if not self.initialized:\n            self.initialized = True\n            self.generator_func = self.generator_func(self.user_param)\n\n        return next(self.generator_func)", "core/joblib/MPClassFuncOnDemand.py": "import multiprocessing\nfrom core.interact import interact as io\n\nclass MPClassFuncOnDemand():\n    def __init__(self, class_handle, class_func_name, **class_kwargs):\n        self.class_handle = class_handle\n        self.class_func_name = class_func_name\n        self.class_kwargs = class_kwargs\n   \n        self.class_func = None\n        \n        self.s2c = multiprocessing.Queue()\n        self.c2s = multiprocessing.Queue()\n        self.lock = multiprocessing.Lock()\n        \n        io.add_process_messages_callback(self.io_callback)\n\n    def io_callback(self):        \n        while not self.c2s.empty():\n            func_args, func_kwargs = self.c2s.get()\n            if self.class_func is None:\n                self.class_func = getattr( self.class_handle(**self.class_kwargs), self.class_func_name)\n            self.s2c.put ( self.class_func (*func_args, **func_kwargs) )\n\n    def __call__(self, *args, **kwargs):\n        with self.lock:\n            self.c2s.put ( (args, kwargs) )\n            return self.s2c.get()\n\n    def __getstate__(self):\n        return {'s2c':self.s2c, 'c2s':self.c2s, 'lock':self.lock}\n\n", "core/imagelib/color_transfer.py": "import cv2\nimport numexpr as ne\nimport numpy as np\nimport scipy as sp\nfrom numpy import linalg as npla\n\n\ndef color_transfer_sot(src,trg, steps=10, batch_size=5, reg_sigmaXY=16.0, reg_sigmaV=5.0):\n    \"\"\"\n    Color Transform via Sliced Optimal Transfer\n    ported by @iperov from https://github.com/dcoeurjo/OTColorTransfer\n\n    src         - any float range any channel image\n    dst         - any float range any channel image, same shape as src\n    steps       - number of solver steps\n    batch_size  - solver batch size\n    reg_sigmaXY - apply regularization and sigmaXY of filter, otherwise set to 0.0\n    reg_sigmaV  - sigmaV of filter\n\n    return value - clip it manually\n    \"\"\"\n    if not np.issubdtype(src.dtype, np.floating):\n        raise ValueError(\"src value must be float\")\n    if not np.issubdtype(trg.dtype, np.floating):\n        raise ValueError(\"trg value must be float\")\n\n    if len(src.shape) != 3:\n        raise ValueError(\"src shape must have rank 3 (h,w,c)\")\n\n    if src.shape != trg.shape:\n        raise ValueError(\"src and trg shapes must be equal\")\n\n    src_dtype = src.dtype\n    h,w,c = src.shape\n    new_src = src.copy()\n\n    advect = np.empty ( (h*w,c), dtype=src_dtype )\n    for step in range (steps):\n        advect.fill(0)\n        for batch in range (batch_size):\n            dir = np.random.normal(size=c).astype(src_dtype)\n            dir /= npla.norm(dir)\n\n            projsource = np.sum( new_src*dir, axis=-1).reshape ((h*w))\n            projtarget = np.sum( trg*dir, axis=-1).reshape ((h*w))\n\n            idSource = np.argsort (projsource)\n            idTarget = np.argsort (projtarget)\n\n            a = projtarget[idTarget]-projsource[idSource]\n            for i_c in range(c):\n                advect[idSource,i_c] += a * dir[i_c]\n        new_src += advect.reshape( (h,w,c) ) / batch_size\n\n    if reg_sigmaXY != 0.0:\n        src_diff = new_src-src\n        src_diff_filt = cv2.bilateralFilter (src_diff, 0, reg_sigmaV, reg_sigmaXY )\n        if len(src_diff_filt.shape) == 2:\n            src_diff_filt = src_diff_filt[...,None]\n        new_src = src + src_diff_filt\n    return new_src\n\ndef color_transfer_mkl(x0, x1):\n    eps = np.finfo(float).eps\n\n    h,w,c = x0.shape\n    h1,w1,c1 = x1.shape\n\n    x0 = x0.reshape ( (h*w,c) )\n    x1 = x1.reshape ( (h1*w1,c1) )\n\n    a = np.cov(x0.T)\n    b = np.cov(x1.T)\n\n    Da2, Ua = np.linalg.eig(a)\n    Da = np.diag(np.sqrt(Da2.clip(eps, None)))\n\n    C = np.dot(np.dot(np.dot(np.dot(Da, Ua.T), b), Ua), Da)\n\n    Dc2, Uc = np.linalg.eig(C)\n    Dc = np.diag(np.sqrt(Dc2.clip(eps, None)))\n\n    Da_inv = np.diag(1./(np.diag(Da)))\n\n    t = np.dot(np.dot(np.dot(np.dot(np.dot(np.dot(Ua, Da_inv), Uc), Dc), Uc.T), Da_inv), Ua.T)\n\n    mx0 = np.mean(x0, axis=0)\n    mx1 = np.mean(x1, axis=0)\n\n    result = np.dot(x0-mx0, t) + mx1\n    return np.clip ( result.reshape ( (h,w,c) ).astype(x0.dtype), 0, 1)\n\ndef color_transfer_idt(i0, i1, bins=256, n_rot=20):\n    import scipy.stats\n    \n    relaxation = 1 / n_rot\n    h,w,c = i0.shape\n    h1,w1,c1 = i1.shape\n\n    i0 = i0.reshape ( (h*w,c) )\n    i1 = i1.reshape ( (h1*w1,c1) )\n\n    n_dims = c\n\n    d0 = i0.T\n    d1 = i1.T\n\n    for i in range(n_rot):\n\n        r = sp.stats.special_ortho_group.rvs(n_dims).astype(np.float32)\n\n        d0r = np.dot(r, d0)\n        d1r = np.dot(r, d1)\n        d_r = np.empty_like(d0)\n\n        for j in range(n_dims):\n\n            lo = min(d0r[j].min(), d1r[j].min())\n            hi = max(d0r[j].max(), d1r[j].max())\n\n            p0r, edges = np.histogram(d0r[j], bins=bins, range=[lo, hi])\n            p1r, _     = np.histogram(d1r[j], bins=bins, range=[lo, hi])\n\n            cp0r = p0r.cumsum().astype(np.float32)\n            cp0r /= cp0r[-1]\n\n            cp1r = p1r.cumsum().astype(np.float32)\n            cp1r /= cp1r[-1]\n\n            f = np.interp(cp0r, cp1r, edges[1:])\n\n            d_r[j] = np.interp(d0r[j], edges[1:], f, left=0, right=bins)\n\n        d0 = relaxation * np.linalg.solve(r, (d_r - d0r)) + d0\n\n    return np.clip ( d0.T.reshape ( (h,w,c) ).astype(i0.dtype) , 0, 1)\n\ndef reinhard_color_transfer(target : np.ndarray, source : np.ndarray, target_mask : np.ndarray = None, source_mask : np.ndarray = None, mask_cutoff=0.5) -> np.ndarray:\n    \"\"\"\n    Transfer color using rct method.\n\n        target      np.ndarray H W 3C   (BGR)   np.float32\n        source      np.ndarray H W 3C   (BGR)   np.float32\n\n        target_mask(None)   np.ndarray H W 1C  np.float32\n        source_mask(None)   np.ndarray H W 1C  np.float32\n        \n        mask_cutoff(0.5)    float\n\n    masks are used to limit the space where color statistics will be computed to adjust the target\n\n    reference: Color Transfer between Images https://www.cs.tau.ac.il/~turkel/imagepapers/ColorTransfer.pdf\n    \"\"\"\n    source = cv2.cvtColor(source, cv2.COLOR_BGR2LAB)\n    target = cv2.cvtColor(target, cv2.COLOR_BGR2LAB)\n\n    source_input = source\n    if source_mask is not None:\n        source_input = source_input.copy()\n        source_input[source_mask[...,0] < mask_cutoff] = [0,0,0]\n    \n    target_input = target\n    if target_mask is not None:\n        target_input = target_input.copy()\n        target_input[target_mask[...,0] < mask_cutoff] = [0,0,0]\n\n    target_l_mean, target_l_std, target_a_mean, target_a_std, target_b_mean, target_b_std, \\\n        = target_input[...,0].mean(), target_input[...,0].std(), target_input[...,1].mean(), target_input[...,1].std(), target_input[...,2].mean(), target_input[...,2].std()\n    \n    source_l_mean, source_l_std, source_a_mean, source_a_std, source_b_mean, source_b_std, \\\n        = source_input[...,0].mean(), source_input[...,0].std(), source_input[...,1].mean(), source_input[...,1].std(), source_input[...,2].mean(), source_input[...,2].std()\n    \n    # not as in the paper: scale by the standard deviations using reciprocal of paper proposed factor\n    target_l = target[...,0]\n    target_l = ne.evaluate('(target_l - target_l_mean) * source_l_std / target_l_std + source_l_mean')\n\n    target_a = target[...,1]\n    target_a = ne.evaluate('(target_a - target_a_mean) * source_a_std / target_a_std + source_a_mean')\n    \n    target_b = target[...,2]\n    target_b = ne.evaluate('(target_b - target_b_mean) * source_b_std / target_b_std + source_b_mean')\n\n    np.clip(target_l,    0, 100, out=target_l)\n    np.clip(target_a, -127, 127, out=target_a)\n    np.clip(target_b, -127, 127, out=target_b)\n\n    return cv2.cvtColor(np.stack([target_l,target_a,target_b], -1), cv2.COLOR_LAB2BGR)\n\n\ndef linear_color_transfer(target_img, source_img, mode='pca', eps=1e-5):\n    '''\n    Matches the colour distribution of the target image to that of the source image\n    using a linear transform.\n    Images are expected to be of form (w,h,c) and float in [0,1].\n    Modes are chol, pca or sym for different choices of basis.\n    '''\n    mu_t = target_img.mean(0).mean(0)\n    t = target_img - mu_t\n    t = t.transpose(2,0,1).reshape( t.shape[-1],-1)\n    Ct = t.dot(t.T) / t.shape[1] + eps * np.eye(t.shape[0])\n    mu_s = source_img.mean(0).mean(0)\n    s = source_img - mu_s\n    s = s.transpose(2,0,1).reshape( s.shape[-1],-1)\n    Cs = s.dot(s.T) / s.shape[1] + eps * np.eye(s.shape[0])\n    if mode == 'chol':\n        chol_t = np.linalg.cholesky(Ct)\n        chol_s = np.linalg.cholesky(Cs)\n        ts = chol_s.dot(np.linalg.inv(chol_t)).dot(t)\n    if mode == 'pca':\n        eva_t, eve_t = np.linalg.eigh(Ct)\n        Qt = eve_t.dot(np.sqrt(np.diag(eva_t))).dot(eve_t.T)\n        eva_s, eve_s = np.linalg.eigh(Cs)\n        Qs = eve_s.dot(np.sqrt(np.diag(eva_s))).dot(eve_s.T)\n        ts = Qs.dot(np.linalg.inv(Qt)).dot(t)\n    if mode == 'sym':\n        eva_t, eve_t = np.linalg.eigh(Ct)\n        Qt = eve_t.dot(np.sqrt(np.diag(eva_t))).dot(eve_t.T)\n        Qt_Cs_Qt = Qt.dot(Cs).dot(Qt)\n        eva_QtCsQt, eve_QtCsQt = np.linalg.eigh(Qt_Cs_Qt)\n        QtCsQt = eve_QtCsQt.dot(np.sqrt(np.diag(eva_QtCsQt))).dot(eve_QtCsQt.T)\n        ts = np.linalg.inv(Qt).dot(QtCsQt).dot(np.linalg.inv(Qt)).dot(t)\n    matched_img = ts.reshape(*target_img.transpose(2,0,1).shape).transpose(1,2,0)\n    matched_img += mu_s\n    matched_img[matched_img>1] = 1\n    matched_img[matched_img<0] = 0\n    return np.clip(matched_img.astype(source_img.dtype), 0, 1)\n\ndef lab_image_stats(image):\n    # compute the mean and standard deviation of each channel\n    (l, a, b) = cv2.split(image)\n    (lMean, lStd) = (l.mean(), l.std())\n    (aMean, aStd) = (a.mean(), a.std())\n    (bMean, bStd) = (b.mean(), b.std())\n\n    # return the color statistics\n    return (lMean, lStd, aMean, aStd, bMean, bStd)\n\ndef _scale_array(arr, clip=True):\n    if clip:\n        return np.clip(arr, 0, 255)\n\n    mn = arr.min()\n    mx = arr.max()\n    scale_range = (max([mn, 0]), min([mx, 255]))\n\n    if mn < scale_range[0] or mx > scale_range[1]:\n        return (scale_range[1] - scale_range[0]) * (arr - mn) / (mx - mn) + scale_range[0]\n\n    return arr\n\ndef channel_hist_match(source, template, hist_match_threshold=255, mask=None):\n    # Code borrowed from:\n    # https://stackoverflow.com/questions/32655686/histogram-matching-of-two-images-in-python-2-x\n    masked_source = source\n    masked_template = template\n\n    if mask is not None:\n        masked_source = source * mask\n        masked_template = template * mask\n\n    oldshape = source.shape\n    source = source.ravel()\n    template = template.ravel()\n    masked_source = masked_source.ravel()\n    masked_template = masked_template.ravel()\n    s_values, bin_idx, s_counts = np.unique(source, return_inverse=True,\n                                            return_counts=True)\n    t_values, t_counts = np.unique(template, return_counts=True)\n\n    s_quantiles = np.cumsum(s_counts).astype(np.float64)\n    s_quantiles = hist_match_threshold * s_quantiles / s_quantiles[-1]\n    t_quantiles = np.cumsum(t_counts).astype(np.float64)\n    t_quantiles = 255 * t_quantiles / t_quantiles[-1]\n    interp_t_values = np.interp(s_quantiles, t_quantiles, t_values)\n\n    return interp_t_values[bin_idx].reshape(oldshape)\n\ndef color_hist_match(src_im, tar_im, hist_match_threshold=255):\n    h,w,c = src_im.shape\n    matched_R = channel_hist_match(src_im[:,:,0], tar_im[:,:,0], hist_match_threshold, None)\n    matched_G = channel_hist_match(src_im[:,:,1], tar_im[:,:,1], hist_match_threshold, None)\n    matched_B = channel_hist_match(src_im[:,:,2], tar_im[:,:,2], hist_match_threshold, None)\n\n    to_stack = (matched_R, matched_G, matched_B)\n    for i in range(3, c):\n        to_stack += ( src_im[:,:,i],)\n\n\n    matched = np.stack(to_stack, axis=-1).astype(src_im.dtype)\n    return matched\n\ndef color_transfer_mix(img_src,img_trg):\n    img_src = np.clip(img_src*255.0, 0, 255).astype(np.uint8)\n    img_trg = np.clip(img_trg*255.0, 0, 255).astype(np.uint8)\n\n    img_src_lab = cv2.cvtColor(img_src, cv2.COLOR_BGR2LAB)\n    img_trg_lab = cv2.cvtColor(img_trg, cv2.COLOR_BGR2LAB)\n\n    rct_light = np.clip ( linear_color_transfer(img_src_lab[...,0:1].astype(np.float32)/255.0,\n                                                img_trg_lab[...,0:1].astype(np.float32)/255.0 )[...,0]*255.0,\n                          0, 255).astype(np.uint8)\n\n    img_src_lab[...,0] = (np.ones_like (rct_light)*100).astype(np.uint8)\n    img_src_lab = cv2.cvtColor(img_src_lab, cv2.COLOR_LAB2BGR)\n\n    img_trg_lab[...,0] = (np.ones_like (rct_light)*100).astype(np.uint8)\n    img_trg_lab = cv2.cvtColor(img_trg_lab, cv2.COLOR_LAB2BGR)\n\n    img_rct = color_transfer_sot( img_src_lab.astype(np.float32), img_trg_lab.astype(np.float32) )\n    img_rct = np.clip(img_rct, 0, 255).astype(np.uint8)\n\n    img_rct = cv2.cvtColor(img_rct, cv2.COLOR_BGR2LAB)\n    img_rct[...,0] = rct_light\n    img_rct = cv2.cvtColor(img_rct, cv2.COLOR_LAB2BGR)\n\n\n    return (img_rct / 255.0).astype(np.float32)\n\ndef color_transfer(ct_mode, img_src, img_trg):\n    \"\"\"\n    color transfer for [0,1] float32 inputs\n    \"\"\"\n    if ct_mode == 'lct':\n        out = linear_color_transfer (img_src, img_trg)\n    elif ct_mode == 'rct':\n        out = reinhard_color_transfer(img_src, img_trg)\n    elif ct_mode == 'mkl':\n        out = color_transfer_mkl (img_src, img_trg)\n    elif ct_mode == 'idt':\n        out = color_transfer_idt (img_src, img_trg)\n    elif ct_mode == 'sot':\n        out = color_transfer_sot (img_src, img_trg)\n        out = np.clip( out, 0.0, 1.0)\n    else:\n        raise ValueError(f\"unknown ct_mode {ct_mode}\")\n    return out\n", "core/imagelib/common.py": "import numpy as np\n\ndef random_crop(img, w, h):\n    height, width = img.shape[:2]\n    \n    h_rnd = height - h\n    w_rnd = width - w\n    \n    y = np.random.randint(0, h_rnd) if h_rnd > 0 else 0\n    x = np.random.randint(0, w_rnd) if w_rnd > 0 else 0\n    \n    return img[y:y+height, x:x+width]\n                        \ndef normalize_channels(img, target_channels):\n    img_shape_len = len(img.shape)\n    if img_shape_len == 2:\n        h, w = img.shape\n        c = 0\n    elif img_shape_len == 3:\n        h, w, c = img.shape\n    else:\n        raise ValueError(\"normalize: incorrect image dimensions.\")\n\n    if c == 0 and target_channels > 0:\n        img = img[...,np.newaxis]\n        c = 1\n\n    if c == 1 and target_channels > 1:\n        img = np.repeat (img, target_channels, -1)\n        c = target_channels\n\n    if c > target_channels:\n        img = img[...,0:target_channels]\n        c = target_channels\n\n    return img\n\ndef cut_odd_image(img):\n    h, w, c = img.shape\n    wm, hm = w % 2, h % 2\n    if wm + hm != 0:\n        img = img[0:h-hm,0:w-wm,:]\n    return img\n\ndef overlay_alpha_image(img_target, img_source, xy_offset=(0,0) ):\n    (h,w,c) = img_source.shape\n    if c != 4:\n        raise ValueError(\"overlay_alpha_image, img_source must have 4 channels\")\n\n    x1, x2 = xy_offset[0], xy_offset[0] + w\n    y1, y2 = xy_offset[1], xy_offset[1] + h\n\n    alpha_s = img_source[:, :, 3] / 255.0\n    alpha_l = 1.0 - alpha_s\n\n    for c in range(0, 3):\n        img_target[y1:y2, x1:x2, c] = (alpha_s * img_source[:, :, c] +\n                                        alpha_l * img_target[y1:y2, x1:x2, c])", "core/imagelib/filters.py": "import numpy as np\nfrom .blursharpen import LinearMotionBlur, blursharpen\nimport cv2\n\ndef apply_random_rgb_levels(img, mask=None, rnd_state=None):\n    if rnd_state is None:\n        rnd_state = np.random\n    np_rnd = rnd_state.rand\n\n    inBlack  = np.array([np_rnd()*0.25    , np_rnd()*0.25    , np_rnd()*0.25], dtype=np.float32)\n    inWhite  = np.array([1.0-np_rnd()*0.25, 1.0-np_rnd()*0.25, 1.0-np_rnd()*0.25], dtype=np.float32)\n    inGamma  = np.array([0.5+np_rnd(), 0.5+np_rnd(), 0.5+np_rnd()], dtype=np.float32)\n\n    outBlack  = np.array([np_rnd()*0.25    , np_rnd()*0.25    , np_rnd()*0.25], dtype=np.float32)\n    outWhite  = np.array([1.0-np_rnd()*0.25, 1.0-np_rnd()*0.25, 1.0-np_rnd()*0.25], dtype=np.float32)\n\n    result = np.clip( (img - inBlack) / (inWhite - inBlack), 0, 1 )\n    result = ( result ** (1/inGamma) ) *  (outWhite - outBlack) + outBlack\n    result = np.clip(result, 0, 1)\n\n    if mask is not None:\n        result = img*(1-mask) + result*mask\n\n    return result\n\ndef apply_random_hsv_shift(img, mask=None, rnd_state=None):\n    if rnd_state is None:\n        rnd_state = np.random\n\n    h, s, v = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))\n    h = ( h + rnd_state.randint(360) ) % 360\n    s = np.clip ( s + rnd_state.random()-0.5, 0, 1 )\n    v = np.clip ( v + rnd_state.random()-0.5, 0, 1 )\n\n    result = np.clip( cv2.cvtColor(cv2.merge([h, s, v]), cv2.COLOR_HSV2BGR) , 0, 1 )\n    if mask is not None:\n        result = img*(1-mask) + result*mask\n\n    return result\n\ndef apply_random_sharpen( img, chance, kernel_max_size, mask=None, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n\n    sharp_rnd_kernel = rnd_state.randint(kernel_max_size)+1\n\n    result = img\n    if rnd_state.randint(100) < np.clip(chance, 0, 100):\n        if rnd_state.randint(2) == 0:\n            result = blursharpen(result, 1, sharp_rnd_kernel, rnd_state.randint(10) )\n        else:\n            result = blursharpen(result, 2, sharp_rnd_kernel, rnd_state.randint(50) )\n                \n        if mask is not None:\n            result = img*(1-mask) + result*mask\n\n    return result\n\ndef apply_random_motion_blur( img, chance, mb_max_size, mask=None, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n\n    mblur_rnd_kernel = rnd_state.randint(mb_max_size)+1\n    mblur_rnd_deg    = rnd_state.randint(360)\n\n    result = img\n    if rnd_state.randint(100) < np.clip(chance, 0, 100):\n        result = LinearMotionBlur (result, mblur_rnd_kernel, mblur_rnd_deg )\n        if mask is not None:\n            result = img*(1-mask) + result*mask\n\n    return result\n\ndef apply_random_gaussian_blur( img, chance, kernel_max_size, mask=None, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n\n    result = img\n    if rnd_state.randint(100) < np.clip(chance, 0, 100):\n        gblur_rnd_kernel = rnd_state.randint(kernel_max_size)*2+1\n        result = cv2.GaussianBlur(result, (gblur_rnd_kernel,)*2 , 0)\n        if mask is not None:\n            result = img*(1-mask) + result*mask\n\n    return result\n\ndef apply_random_resize( img, chance, max_size_per, interpolation=cv2.INTER_LINEAR, mask=None, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n\n    result = img\n    if rnd_state.randint(100) < np.clip(chance, 0, 100):\n        h,w,c = result.shape\n\n        trg = rnd_state.rand()\n        rw = w - int( trg * int(w*(max_size_per/100.0)) )\n        rh = h - int( trg * int(h*(max_size_per/100.0)) )\n\n        result = cv2.resize (result, (rw,rh), interpolation=interpolation )\n        result = cv2.resize (result, (w,h), interpolation=interpolation )\n        if mask is not None:\n            result = img*(1-mask) + result*mask\n\n    return result\n\ndef apply_random_nearest_resize( img, chance, max_size_per, mask=None, rnd_state=None ):\n    return apply_random_resize( img, chance, max_size_per, interpolation=cv2.INTER_NEAREST, mask=mask, rnd_state=rnd_state )\n\ndef apply_random_bilinear_resize( img, chance, max_size_per, mask=None, rnd_state=None ):\n    return apply_random_resize( img, chance, max_size_per, interpolation=cv2.INTER_LINEAR, mask=mask, rnd_state=rnd_state )\n\ndef apply_random_jpeg_compress( img, chance, mask=None, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n\n    result = img\n    if rnd_state.randint(100) < np.clip(chance, 0, 100):\n        h,w,c = result.shape\n\n        quality = rnd_state.randint(10,101)\n\n        ret, result = cv2.imencode('.jpg', np.clip(img*255, 0,255).astype(np.uint8), [int(cv2.IMWRITE_JPEG_QUALITY), quality] )\n        if ret == True:\n            result = cv2.imdecode(result, flags=cv2.IMREAD_UNCHANGED)\n            result = result.astype(np.float32) / 255.0\n            if mask is not None:\n                result = img*(1-mask) + result*mask\n\n    return result\n    \ndef apply_random_overlay_triangle( img, max_alpha, mask=None, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n\n    h,w,c = img.shape\n    pt1 = [rnd_state.randint(w), rnd_state.randint(h) ]\n    pt2 = [rnd_state.randint(w), rnd_state.randint(h) ]\n    pt3 = [rnd_state.randint(w), rnd_state.randint(h) ]\n    \n    alpha = rnd_state.uniform()*max_alpha\n    \n    tri_mask = cv2.fillPoly( np.zeros_like(img), [ np.array([pt1,pt2,pt3], np.int32) ], (alpha,)*c )\n    \n    if rnd_state.randint(2) == 0:\n        result = np.clip(img+tri_mask, 0, 1)\n    else:\n        result = np.clip(img-tri_mask, 0, 1)\n    \n    if mask is not None:\n        result = img*(1-mask) + result*mask\n\n    return result\n    \ndef _min_resize(x, m):\n    if x.shape[0] < x.shape[1]:\n        s0 = m\n        s1 = int(float(m) / float(x.shape[0]) * float(x.shape[1]))\n    else:\n        s0 = int(float(m) / float(x.shape[1]) * float(x.shape[0]))\n        s1 = m\n    new_max = min(s1, s0)\n    raw_max = min(x.shape[0], x.shape[1])\n    return cv2.resize(x, (s1, s0), interpolation=cv2.INTER_LANCZOS4)\n    \ndef _d_resize(x, d, fac=1.0):\n    new_min = min(int(d[1] * fac), int(d[0] * fac))\n    raw_min = min(x.shape[0], x.shape[1])\n    if new_min < raw_min:\n        interpolation = cv2.INTER_AREA\n    else:\n        interpolation = cv2.INTER_LANCZOS4\n    y = cv2.resize(x, (int(d[1] * fac), int(d[0] * fac)), interpolation=interpolation)\n    return y\n    \ndef _get_image_gradient(dist):\n    cols = cv2.filter2D(dist, cv2.CV_32F, np.array([[-1, 0, +1], [-2, 0, +2], [-1, 0, +1]]))\n    rows = cv2.filter2D(dist, cv2.CV_32F, np.array([[-1, -2, -1], [0, 0, 0], [+1, +2, +1]]))\n    return cols, rows\n\ndef _generate_lighting_effects(content):\n    h512 = content\n    h256 = cv2.pyrDown(h512)\n    h128 = cv2.pyrDown(h256)\n    h64 = cv2.pyrDown(h128)\n    h32 = cv2.pyrDown(h64)\n    h16 = cv2.pyrDown(h32)\n    c512, r512 = _get_image_gradient(h512)\n    c256, r256 = _get_image_gradient(h256)\n    c128, r128 = _get_image_gradient(h128)\n    c64, r64 = _get_image_gradient(h64)\n    c32, r32 = _get_image_gradient(h32)\n    c16, r16 = _get_image_gradient(h16)\n    c = c16\n    c = _d_resize(cv2.pyrUp(c), c32.shape) * 4.0 + c32\n    c = _d_resize(cv2.pyrUp(c), c64.shape) * 4.0 + c64\n    c = _d_resize(cv2.pyrUp(c), c128.shape) * 4.0 + c128\n    c = _d_resize(cv2.pyrUp(c), c256.shape) * 4.0 + c256\n    c = _d_resize(cv2.pyrUp(c), c512.shape) * 4.0 + c512\n    r = r16\n    r = _d_resize(cv2.pyrUp(r), r32.shape) * 4.0 + r32\n    r = _d_resize(cv2.pyrUp(r), r64.shape) * 4.0 + r64\n    r = _d_resize(cv2.pyrUp(r), r128.shape) * 4.0 + r128\n    r = _d_resize(cv2.pyrUp(r), r256.shape) * 4.0 + r256\n    r = _d_resize(cv2.pyrUp(r), r512.shape) * 4.0 + r512\n    coarse_effect_cols = c\n    coarse_effect_rows = r\n    EPS = 1e-10\n\n    max_effect = np.max((coarse_effect_cols**2 + coarse_effect_rows**2)**0.5, axis=0, keepdims=True, ).max(1, keepdims=True)\n    coarse_effect_cols = (coarse_effect_cols + EPS) / (max_effect + EPS)\n    coarse_effect_rows = (coarse_effect_rows + EPS) / (max_effect + EPS)\n\n    return np.stack([ np.zeros_like(coarse_effect_rows), coarse_effect_rows, coarse_effect_cols], axis=-1)\n    \ndef apply_random_relight(img, mask=None, rnd_state=None):\n    if rnd_state is None:\n        rnd_state = np.random\n        \n    def_img = img\n        \n    if rnd_state.randint(2) == 0:\n        light_pos_y = 1.0 if rnd_state.randint(2) == 0 else -1.0\n        light_pos_x = rnd_state.uniform()*2-1.0\n    else:\n        light_pos_y = rnd_state.uniform()*2-1.0\n        light_pos_x = 1.0 if rnd_state.randint(2) == 0 else -1.0\n                    \n    light_source_height = 0.3*rnd_state.uniform()*0.7\n    light_intensity = 1.0+rnd_state.uniform()\n    ambient_intensity = 0.5\n    \n    light_source_location = np.array([[[light_source_height, light_pos_y, light_pos_x ]]], dtype=np.float32)\n    light_source_direction = light_source_location / np.sqrt(np.sum(np.square(light_source_location)))\n\n    lighting_effect = _generate_lighting_effects(img)\n    lighting_effect = np.sum(lighting_effect * light_source_direction, axis=-1).clip(0, 1)\n    lighting_effect = np.mean(lighting_effect, axis=-1, keepdims=True)\n\n    result = def_img * (ambient_intensity + lighting_effect * light_intensity) #light_source_color\n    result = np.clip(result, 0, 1)\n    \n    if mask is not None:\n        result = def_img*(1-mask) + result*mask\n    \n    return result", "core/imagelib/equalize_and_stack_square.py": "import numpy as np\nimport cv2\n\ndef equalize_and_stack_square (images, axis=1):\n    max_c = max ([ 1 if len(image.shape) == 2 else image.shape[2]  for image in images ] )\n\n    target_wh = 99999\n    for i,image in enumerate(images):\n        if len(image.shape) == 2:\n            h,w = image.shape\n            c = 1\n        else:\n            h,w,c = image.shape\n\n        if h < target_wh:\n            target_wh = h\n\n        if w < target_wh:\n            target_wh = w\n\n    for i,image in enumerate(images):\n        if len(image.shape) == 2:\n            h,w = image.shape\n            c = 1\n        else:\n            h,w,c = image.shape\n\n        if c < max_c:\n            if c == 1:\n                if len(image.shape) == 2:\n                    image = np.expand_dims ( image, -1 )\n                image = np.concatenate ( (image,)*max_c, -1 )\n            elif c == 2: #GA\n                image = np.expand_dims ( image[...,0], -1 )\n                image = np.concatenate ( (image,)*max_c, -1 )\n            else:\n                image = np.concatenate ( (image, np.ones((h,w,max_c - c))), -1 )\n\n        if h != target_wh or w != target_wh:\n            image = cv2.resize ( image, (target_wh, target_wh) )\n            h,w,c = image.shape\n\n        images[i] = image\n\n    return np.concatenate ( images, axis = 1 )", "core/imagelib/SegIEPolys.py": "import numpy as np\nimport cv2\nfrom enum import IntEnum\n\n\nclass SegIEPolyType(IntEnum):\n    EXCLUDE = 0\n    INCLUDE = 1\n    \n\n\nclass SegIEPoly():\n    def __init__(self, type=None, pts=None, **kwargs):\n        self.type = type\n        \n        if pts is None:\n            pts = np.empty( (0,2), dtype=np.float32 )\n        else:\n            pts = np.float32(pts)\n        self.pts = pts\n        self.n_max = self.n = len(pts)\n\n    def dump(self):\n        return {'type': int(self.type),\n                'pts' : self.get_pts(),\n               }\n    \n    def identical(self, b):\n        if self.n != b.n:\n            return False            \n        return (self.pts[0:self.n] == b.pts[0:b.n]).all()        \n        \n    def get_type(self):\n        return self.type\n\n    def add_pt(self, x, y):\n        self.pts = np.append(self.pts[0:self.n], [ ( float(x), float(y) ) ], axis=0).astype(np.float32)\n        self.n_max = self.n = self.n + 1\n\n    def undo(self):\n        self.n = max(0, self.n-1)\n        return self.n\n\n    def redo(self):\n        self.n = min(len(self.pts), self.n+1)\n        return self.n\n\n    def redo_clip(self):\n        self.pts = self.pts[0:self.n]\n        self.n_max = self.n\n\n    def insert_pt(self, n, pt):\n        if n < 0 or n > self.n:\n            raise ValueError(\"insert_pt out of range\")\n        self.pts = np.concatenate( (self.pts[0:n], pt[None,...].astype(np.float32), self.pts[n:]), axis=0)\n        self.n_max = self.n = self.n+1\n        \n    def remove_pt(self, n):\n        if n < 0 or n >= self.n:\n            raise ValueError(\"remove_pt out of range\")\n        self.pts = np.concatenate( (self.pts[0:n], self.pts[n+1:]), axis=0)\n        self.n_max = self.n = self.n-1\n        \n    def get_last_point(self):\n        return self.pts[self.n-1].copy()\n\n    def get_pts(self):\n        return self.pts[0:self.n].copy()\n        \n    def get_pts_count(self):\n        return self.n\n\n    def set_point(self, id, pt):\n        self.pts[id] = pt\n        \n    def set_points(self, pts):\n        self.pts = np.array(pts)\n        self.n_max = self.n = len(pts)\n        \n    def mult_points(self, val):\n        self.pts *= val       \n    \n        \n\nclass SegIEPolys():\n    def __init__(self):\n        self.polys = []\n\n    def identical(self, b):\n        polys_len = len(self.polys)\n        o_polys_len = len(b.polys)\n        if polys_len != o_polys_len:\n            return False\n        \n        return all ([ a_poly.identical(b_poly) for a_poly, b_poly in zip(self.polys, b.polys) ])\n        \n    def add_poly(self, ie_poly_type):       \n        poly = SegIEPoly(ie_poly_type)\n        self.polys.append (poly)\n        return poly\n\n    def remove_poly(self, poly):\n        if poly in self.polys:\n            self.polys.remove(poly)\n\n    def has_polys(self):\n        return len(self.polys) != 0\n        \n    def get_poly(self, id):\n        return self.polys[id]\n\n    def get_polys(self):\n        return self.polys\n        \n    def get_pts_count(self):\n        return sum([poly.get_pts_count() for poly in self.polys])\n        \n    def sort(self):\n        poly_by_type = { SegIEPolyType.EXCLUDE : [], SegIEPolyType.INCLUDE : [] }\n\n        for poly in self.polys:\n            poly_by_type[poly.type].append(poly)\n            \n        self.polys = poly_by_type[SegIEPolyType.INCLUDE] + poly_by_type[SegIEPolyType.EXCLUDE]\n\n    def __iter__(self):\n        for poly in self.polys:\n            yield poly\n\n    def overlay_mask(self, mask):\n        h,w,c = mask.shape\n        white = (1,)*c\n        black = (0,)*c\n        for poly in self.polys:\n            pts = poly.get_pts().astype(np.int32)\n            if len(pts) != 0:\n                cv2.fillPoly(mask, [pts], white if poly.type == SegIEPolyType.INCLUDE else black )\n\n    def dump(self):\n        return {'polys' : [ poly.dump() for poly in self.polys ] }\n    \n    def mult_points(self, val):\n        for poly in self.polys:\n            poly.mult_points(val)\n        \n    @staticmethod\n    def load(data=None):\n        ie_polys = SegIEPolys()\n        if data is not None:\n            if isinstance(data, list):\n                # Backward comp\n                ie_polys.polys = [ SegIEPoly(type=type, pts=pts) for (type, pts) in data ]\n            elif isinstance(data, dict):                \n                ie_polys.polys = [ SegIEPoly(**poly_cfg) for poly_cfg in data['polys'] ]\n                \n        ie_polys.sort()   \n                \n        return ie_polys", "core/imagelib/estimate_sharpness.py": "\"\"\"\nCopyright (c) 2009-2010 Arizona Board of Regents.  All Rights Reserved.\n Contact: Lina Karam (karam@asu.edu) and Niranjan Narvekar (nnarveka@asu.edu)\n Image, Video, and Usabilty (IVU) Lab, http://ivulab.asu.edu , Arizona State University\n This copyright statement may not be removed from any file containing it or from modifications to these files.\n This copyright notice must also be included in any file or product that is derived from the source files.\n\n Redistribution and use of this code in source and binary forms,  with or without modification, are permitted provided that the\n following conditions are met:\n - Redistribution's of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n - Redistribution's in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer\nin the documentation and/or other materials provided with the distribution.\n - The Image, Video, and Usability Laboratory (IVU Lab, http://ivulab.asu.edu) is acknowledged in any publication that\n reports research results using this code, copies of this code, or modifications of this code.\n The code and our papers are to be cited in the bibliography as:\n\nN. D. Narvekar and L. J. Karam, \"CPBD Sharpness Metric Software\", http://ivulab.asu.edu/Quality/CPBD\n\nN. D. Narvekar and L. J. Karam, \"A No-Reference Image Blur Metric Based on the Cumulative\nProbability of Blur Detection (CPBD),\" accepted and to appear in the IEEE Transactions on Image Processing,  2011.\n\nN. D. Narvekar and L. J. Karam, \"An Improved No-Reference Sharpness Metric Based on the Probability of Blur Detection,\" International Workshop on Video Processing and Quality Metrics for Consumer Electronics (VPQM), January 2010, http://www.vpqm.org (pdf)\n\nN. D. Narvekar and L. J. Karam, \"A No Reference Perceptual Quality Metric based on Cumulative Probability of Blur Detection,\" First International Workshop on the Quality of Multimedia Experience (QoMEX), pp. 87-91, July 2009.\n\n DISCLAIMER:\n This software is provided by the copyright holders and contributors \"as is\" and any express or implied warranties, including, but not limited to, the implied warranties of merchantability and fitness for a particular purpose are disclaimed. In no event shall the Arizona Board of Regents, Arizona State University, IVU Lab members, authors or contributors be liable for any direct, indirect, incidental, special, exemplary, or consequential damages (including, but not limited to, procurement of substitute\ngoods or services; loss of use, data, or profits; or business interruption) however caused and on any theory of liability, whether in contract, strict liability, or tort (including negligence or otherwise) arising in any way out of the use of this software, even if advised of the possibility of such damage.\n\"\"\"\n\nimport numpy as np\nimport cv2\nfrom math import atan2, pi\n\n\ndef sobel(image):\n    # type: (numpy.ndarray) -> numpy.ndarray\n    \"\"\"\n    Find edges using the Sobel approximation to the derivatives.\n\n    Inspired by the [Octave implementation](https://sourceforge.net/p/octave/image/ci/default/tree/inst/edge.m#l196).\n    \"\"\"\n    from skimage.filters.edges import HSOBEL_WEIGHTS\n    h1 = np.array(HSOBEL_WEIGHTS)\n    h1 /= np.sum(abs(h1))  # normalize h1\n    \n    from scipy.ndimage import convolve\n    strength2 = np.square(convolve(image, h1.T))\n\n    # Note: https://sourceforge.net/p/octave/image/ci/default/tree/inst/edge.m#l59\n    thresh2 = 2 * np.sqrt(np.mean(strength2))\n\n    strength2[strength2 <= thresh2] = 0\n    return _simple_thinning(strength2)\n\n\ndef _simple_thinning(strength):\n    # type: (numpy.ndarray) -> numpy.ndarray\n    \"\"\"\n    Perform a very simple thinning.\n\n    Inspired by the [Octave implementation](https://sourceforge.net/p/octave/image/ci/default/tree/inst/edge.m#l512).\n    \"\"\"\n    num_rows, num_cols = strength.shape\n\n    zero_column = np.zeros((num_rows, 1))\n    zero_row = np.zeros((1, num_cols))\n\n    x = (\n        (strength > np.c_[zero_column, strength[:, :-1]]) &\n        (strength > np.c_[strength[:, 1:], zero_column])\n    )\n\n    y = (\n        (strength > np.r_[zero_row, strength[:-1, :]]) &\n        (strength > np.r_[strength[1:, :], zero_row])\n    )\n\n    return x | y\n\n\n\n\n\n# threshold to characterize blocks as edge/non-edge blocks\nTHRESHOLD = 0.002\n# fitting parameter\nBETA = 3.6\n# block size\nBLOCK_HEIGHT, BLOCK_WIDTH = (64, 64)\n# just noticeable widths based on the perceptual experiments\nWIDTH_JNB = np.concatenate([5*np.ones(51), 3*np.ones(205)])\n\n\ndef compute(image):\n    # type: (numpy.ndarray) -> float\n    \"\"\"Compute the sharpness metric for the given data.\"\"\"\n\n    # convert the image to double for further processing\n    image = image.astype(np.float64)\n\n    # edge detection using canny and sobel canny edge detection is done to\n    # classify the blocks as edge or non-edge blocks and sobel edge\n    # detection is done for the purpose of edge width measurement.\n    from skimage.feature import canny\n    canny_edges = canny(image)\n    sobel_edges = sobel(image)\n\n    # edge width calculation\n    marziliano_widths = marziliano_method(sobel_edges, image)\n\n    # sharpness metric calculation\n    return _calculate_sharpness_metric(image, canny_edges, marziliano_widths)\n\n\ndef marziliano_method(edges, image):\n    # type: (numpy.ndarray, numpy.ndarray) -> numpy.ndarray\n    \"\"\"\n    Calculate the widths of the given edges.\n\n    :return: A matrix with the same dimensions as the given image with 0's at\n        non-edge locations and edge-widths at the edge locations.\n    \"\"\"\n\n    # `edge_widths` consists of zero and non-zero values. A zero value\n    # indicates that there is no edge at that position and a non-zero value\n    # indicates that there is an edge at that position and the value itself\n    # gives the edge width.\n    edge_widths = np.zeros(image.shape)\n\n    # find the gradient for the image\n    gradient_y, gradient_x = np.gradient(image)\n\n    # dimensions of the image\n    img_height, img_width = image.shape\n\n    # holds the angle information of the edges\n    edge_angles = np.zeros(image.shape)\n\n    # calculate the angle of the edges\n    for row in range(img_height):\n        for col in range(img_width):\n            if gradient_x[row, col] != 0:\n                edge_angles[row, col] = atan2(gradient_y[row, col], gradient_x[row, col]) * (180 / pi)\n            elif gradient_x[row, col] == 0 and gradient_y[row, col] == 0:\n                edge_angles[row,col] = 0\n            elif gradient_x[row, col] == 0 and gradient_y[row, col] == pi/2:\n                edge_angles[row, col] = 90\n\n\n    if np.any(edge_angles):\n\n        # quantize the angle\n        quantized_angles = 45 * np.round(edge_angles / 45)\n\n        for row in range(1, img_height - 1):\n            for col in range(1, img_width - 1):\n                if edges[row, col] == 1:\n\n                    # gradient angle = 180 or -180\n                    if quantized_angles[row, col] == 180 or quantized_angles[row, col] == -180:\n                        for margin in range(100 + 1):\n                            inner_border = (col - 1) - margin\n                            outer_border = (col - 2) - margin\n\n                            # outside image or intensity increasing from left to right\n                            if outer_border < 0 or (image[row, outer_border] - image[row, inner_border]) <= 0:\n                                break\n\n                        width_left = margin + 1\n\n                        for margin in range(100 + 1):\n                            inner_border = (col + 1) + margin\n                            outer_border = (col + 2) + margin\n\n                            # outside image or intensity increasing from left to right\n                            if outer_border >= img_width or (image[row, outer_border] - image[row, inner_border]) >= 0:\n                                break\n\n                        width_right = margin + 1\n\n                        edge_widths[row, col] = width_left + width_right\n\n\n                    # gradient angle = 0\n                    if quantized_angles[row, col] == 0:\n                        for margin in range(100 + 1):\n                            inner_border = (col - 1) - margin\n                            outer_border = (col - 2) - margin\n\n                            # outside image or intensity decreasing from left to right\n                            if outer_border < 0 or (image[row, outer_border] - image[row, inner_border]) >= 0:\n                                break\n\n                        width_left = margin + 1\n\n                        for margin in range(100 + 1):\n                            inner_border = (col + 1) + margin\n                            outer_border = (col + 2) + margin\n\n                            # outside image or intensity decreasing from left to right\n                            if outer_border >= img_width or (image[row, outer_border] - image[row, inner_border]) <= 0:\n                                break\n\n                        width_right = margin + 1\n\n                        edge_widths[row, col] = width_right + width_left\n\n    return edge_widths\n\n\ndef _calculate_sharpness_metric(image, edges, edge_widths):\n    # type: (numpy.array, numpy.array, numpy.array) -> numpy.float64\n\n    # get the size of image\n    img_height, img_width = image.shape\n\n    total_num_edges = 0\n    hist_pblur = np.zeros(101)\n\n    # maximum block indices\n    num_blocks_vertically = int(img_height / BLOCK_HEIGHT)\n    num_blocks_horizontally = int(img_width / BLOCK_WIDTH)\n\n    #  loop over the blocks\n    for i in range(num_blocks_vertically):\n        for j in range(num_blocks_horizontally):\n\n            # get the row and col indices for the block pixel positions\n            rows = slice(BLOCK_HEIGHT * i, BLOCK_HEIGHT * (i + 1))\n            cols = slice(BLOCK_WIDTH * j, BLOCK_WIDTH * (j + 1))\n\n            if is_edge_block(edges[rows, cols], THRESHOLD):\n                block_widths = edge_widths[rows, cols]\n                # rotate block to simulate column-major boolean indexing\n                block_widths = np.rot90(np.flipud(block_widths), 3)\n                block_widths = block_widths[block_widths != 0]\n\n                block_contrast = get_block_contrast(image[rows, cols])\n                block_jnb = WIDTH_JNB[block_contrast]\n\n                # calculate the probability of blur detection at the edges\n                # detected in the block\n                prob_blur_detection = 1 - np.exp(-abs(block_widths/block_jnb) ** BETA)\n\n                # update the statistics using the block information\n                for probability in prob_blur_detection:\n                    bucket = int(round(probability * 100))\n                    hist_pblur[bucket] += 1\n                    total_num_edges += 1\n\n    # normalize the pdf\n    if total_num_edges > 0:\n        hist_pblur = hist_pblur / total_num_edges\n\n    # calculate the sharpness metric\n    return np.sum(hist_pblur[:64])\n\n\ndef is_edge_block(block, threshold):\n    # type: (numpy.ndarray, float) -> bool\n    \"\"\"Decide whether the given block is an edge block.\"\"\"\n    return np.count_nonzero(block) > (block.size * threshold)\n\n\ndef get_block_contrast(block):\n    # type: (numpy.ndarray) -> int\n    return int(np.max(block) - np.min(block))\n\n\ndef estimate_sharpness(image):\n    if image.ndim == 3:\n        if image.shape[2] > 1:\n            image = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)\n        else:\n            image = image[...,0]\n        \n    return compute(image)\n", "core/imagelib/warp.py": "import numpy as np\nimport numpy.linalg as npla\nimport cv2\nfrom core import randomex\n\ndef mls_rigid_deformation(vy, vx, src_pts, dst_pts, alpha=1.0, eps=1e-8):\n    dst_pts = dst_pts[..., ::-1].astype(np.int16)\n    src_pts = src_pts[..., ::-1].astype(np.int16)\n\n    src_pts, dst_pts = dst_pts, src_pts\n\n    grow = vx.shape[0]\n    gcol = vx.shape[1]\n    ctrls = src_pts.shape[0]\n\n    reshaped_p = src_pts.reshape(ctrls, 2, 1, 1)\n    reshaped_v = np.vstack((vx.reshape(1, grow, gcol), vy.reshape(1, grow, gcol)))\n\n    w = 1.0 / (np.sum((reshaped_p - reshaped_v).astype(np.float32) ** 2, axis=1) + eps) ** alpha\n    w /= np.sum(w, axis=0, keepdims=True)\n\n    pstar = np.zeros((2, grow, gcol), np.float32)\n    for i in range(ctrls):\n        pstar += w[i] * reshaped_p[i]\n\n    vpstar = reshaped_v - pstar\n\n    reshaped_mul_right = np.concatenate((vpstar[:,None,...],\n                                         np.concatenate((vpstar[1:2,None,...],-vpstar[0:1,None,...]), 0)\n                                         ), axis=1).transpose(2, 3, 0, 1)\n\n    reshaped_q = dst_pts.reshape((ctrls, 2, 1, 1))\n    \n    qstar = np.zeros((2, grow, gcol), np.float32)\n    for i in range(ctrls):\n        qstar += w[i] * reshaped_q[i]   \n        \n    temp = np.zeros((grow, gcol, 2), np.float32)\n    for i in range(ctrls):\n        phat = reshaped_p[i] - pstar\n        qhat = reshaped_q[i] - qstar\n\n        temp += np.matmul(qhat.reshape(1, 2, grow, gcol).transpose(2, 3, 0, 1), \n                          \n                          np.matmul( ( w[None, i:i+1,...] *\n                                       np.concatenate((phat.reshape(1, 2, grow, gcol),\n                                                       np.concatenate( (phat[None,1:2], -phat[None,0:1]), 1 )), 0)\n                                      ).transpose(2, 3, 0, 1), reshaped_mul_right\n                                   )\n                         ).reshape(grow, gcol, 2)\n\n    temp = temp.transpose(2, 0, 1)\n\n    normed_temp = np.linalg.norm(temp, axis=0, keepdims=True)\n    normed_vpstar = np.linalg.norm(vpstar, axis=0, keepdims=True)\n    nan_mask = normed_temp[0]==0\n\n    transformers = np.true_divide(temp, normed_temp, out=np.zeros_like(temp), where= ~nan_mask) * normed_vpstar + qstar\n    nan_mask_flat = np.flatnonzero(nan_mask)\n    nan_mask_anti_flat = np.flatnonzero(~nan_mask)\n\n    transformers[0][nan_mask] = np.interp(nan_mask_flat, nan_mask_anti_flat, transformers[0][~nan_mask])\n    transformers[1][nan_mask] = np.interp(nan_mask_flat, nan_mask_anti_flat, transformers[1][~nan_mask])\n\n    return transformers    \n\ndef gen_pts(W, H, rnd_state=None):\n    \n    if rnd_state is None:\n        rnd_state = np.random\n        \n    min_pts, max_pts = 4, 8\n    n_pts = rnd_state.randint(min_pts, max_pts)\n    \n    min_radius_per = 0.00\n    max_radius_per = 0.10\n    pts = []\n    \n    for i in range(n_pts):\n        while True:\n            x, y = rnd_state.randint(W), rnd_state.randint(H)\n            rad = min_radius_per + rnd_state.rand()*(max_radius_per-min_radius_per)\n            \n            intersect = False\n            for px,py,prad,_,_ in pts:\n                \n                dist = npla.norm([x-px, y-py])\n                if dist <= (rad+prad)*2:\n                    intersect = True\n                    break\n            if intersect:\n                continue   \n            \n            angle = rnd_state.rand()*(2*np.pi)\n            x2 = int(x+np.cos(angle)*W*rad)\n            y2 = int(y+np.sin(angle)*H*rad)\n            \n            break\n        pts.append( (x,y,rad, x2,y2) )\n        \n    pts1 = np.array( [ [pt[0],pt[1]] for pt in pts ] )\n    pts2 = np.array( [ [pt[-2],pt[-1]] for pt in pts ] )\n    \n    return pts1, pts2\n    \n    \ndef gen_warp_params (w, flip=False, rotation_range=[-10,10], scale_range=[-0.5, 0.5], tx_range=[-0.05, 0.05], ty_range=[-0.05, 0.05], rnd_state=None, warp_rnd_state=None  ):\n    if rnd_state is None:\n        rnd_state = np.random\n    if warp_rnd_state is None:\n        warp_rnd_state = np.random\n    rw = None\n    if w < 64:        \n        rw = w\n        w = 64\n        \n    rotation = rnd_state.uniform( rotation_range[0], rotation_range[1] )\n    scale = rnd_state.uniform( 1/(1-scale_range[0]) , 1+scale_range[1] )\n    tx = rnd_state.uniform( tx_range[0], tx_range[1] )\n    ty = rnd_state.uniform( ty_range[0], ty_range[1] )\n    p_flip = flip and rnd_state.randint(10) < 4\n\n    #random warp V1\n    cell_size = [ w // (2**i) for i in range(1,4) ] [ warp_rnd_state.randint(3) ]\n    cell_count = w // cell_size + 1\n    grid_points = np.linspace( 0, w, cell_count)\n    mapx = np.broadcast_to(grid_points, (cell_count, cell_count)).copy()\n    mapy = mapx.T\n    mapx[1:-1,1:-1] = mapx[1:-1,1:-1] + randomex.random_normal( size=(cell_count-2, cell_count-2), rnd_state=warp_rnd_state )*(cell_size*0.24)\n    mapy[1:-1,1:-1] = mapy[1:-1,1:-1] + randomex.random_normal( size=(cell_count-2, cell_count-2), rnd_state=warp_rnd_state )*(cell_size*0.24)\n    half_cell_size = cell_size // 2\n    mapx = cv2.resize(mapx, (w+cell_size,)*2 )[half_cell_size:-half_cell_size,half_cell_size:-half_cell_size].astype(np.float32)\n    mapy = cv2.resize(mapy, (w+cell_size,)*2 )[half_cell_size:-half_cell_size,half_cell_size:-half_cell_size].astype(np.float32)\n    ##############\n    \n    # random warp V2\n    # pts1, pts2 = gen_pts(w, w, rnd_state)\n    # gridX = np.arange(w, dtype=np.int16)\n    # gridY = np.arange(w, dtype=np.int16)\n    # vy, vx = np.meshgrid(gridX, gridY)\n    # drigid = mls_rigid_deformation(vy, vx, pts1, pts2)\n    # mapy, mapx = drigid.astype(np.float32)\n    ################\n    \n    #random transform\n    random_transform_mat = cv2.getRotationMatrix2D((w // 2, w // 2), rotation, scale)\n    random_transform_mat[:, 2] += (tx*w, ty*w)\n\n    params = dict()\n    params['mapx'] = mapx\n    params['mapy'] = mapy\n    params['rmat'] = random_transform_mat\n    u_mat = random_transform_mat.copy()\n    u_mat[:,2] /= w\n    params['umat'] = u_mat\n    params['w'] = w\n    params['rw'] = rw\n    params['flip'] = p_flip\n\n    return params\n\ndef warp_by_params (params, img, can_warp, can_transform, can_flip, border_replicate, cv2_inter=cv2.INTER_CUBIC):\n    rw = params['rw']\n    \n    if (can_warp or can_transform) and rw is not None:\n        img = cv2.resize(img, (64,64), interpolation=cv2_inter)\n        \n    if can_warp:\n        img = cv2.remap(img, params['mapx'], params['mapy'], cv2_inter )\n    if can_transform:\n        img = cv2.warpAffine( img, params['rmat'], (params['w'], params['w']), borderMode=(cv2.BORDER_REPLICATE if border_replicate else cv2.BORDER_CONSTANT), flags=cv2_inter )\n    \n    \n    if (can_warp or can_transform) and rw is not None:\n        img = cv2.resize(img, (rw,rw), interpolation=cv2_inter)\n    \n    if len(img.shape) == 2:\n        img = img[...,None]\n    if can_flip and params['flip']:\n        img = img[:,::-1,...]\n    return img", "core/imagelib/blursharpen.py": "import cv2\nimport numpy as np\n\ndef LinearMotionBlur(image, size, angle):\n    k = np.zeros((size, size), dtype=np.float32)\n    k[ (size-1)// 2 , :] = np.ones(size, dtype=np.float32)\n    k = cv2.warpAffine(k, cv2.getRotationMatrix2D( (size / 2 -0.5 , size / 2 -0.5 ) , angle, 1.0), (size, size) )\n    k = k * ( 1.0 / np.sum(k) )\n    return cv2.filter2D(image, -1, k)\n    \ndef blursharpen (img, sharpen_mode=0, kernel_size=3, amount=100):\n    if kernel_size % 2 == 0:\n        kernel_size += 1\n    if amount > 0:\n        if sharpen_mode == 1: #box\n            kernel = np.zeros( (kernel_size, kernel_size), dtype=np.float32)\n            kernel[ kernel_size//2, kernel_size//2] = 1.0\n            box_filter = np.ones( (kernel_size, kernel_size), dtype=np.float32) / (kernel_size**2)\n            kernel = kernel + (kernel - box_filter) * amount\n            return cv2.filter2D(img, -1, kernel)\n        elif sharpen_mode == 2: #gaussian\n            blur = cv2.GaussianBlur(img, (kernel_size, kernel_size) , 0)\n            img = cv2.addWeighted(img, 1.0 + (0.5 * amount), blur, -(0.5 * amount), 0)\n            return img\n    elif amount < 0:\n        n = -amount\n        while n > 0:\n\n            img_blur = cv2.medianBlur(img, 5)\n            if int(n / 10) != 0:\n                img = img_blur\n            else:\n                pass_power = (n % 10) / 10.0\n                img = img*(1.0-pass_power)+img_blur*pass_power\n            n = max(n-10,0)\n\n        return img\n    return img", "core/imagelib/__init__.py": "from .estimate_sharpness import estimate_sharpness\n\nfrom .equalize_and_stack_square import equalize_and_stack_square\n\nfrom .text import get_text_image, get_draw_text_lines\n\nfrom .draw import draw_polygon, draw_rect\n\nfrom .morph import morph_by_points\n\nfrom .warp import gen_warp_params, warp_by_params\n\nfrom .reduce_colors import reduce_colors\n\nfrom .color_transfer import color_transfer, color_transfer_mix, color_transfer_sot, color_transfer_mkl, color_transfer_idt, color_hist_match, reinhard_color_transfer, linear_color_transfer\n\nfrom .common import random_crop, normalize_channels, cut_odd_image, overlay_alpha_image\n\nfrom .SegIEPolys import *\n\nfrom .blursharpen import LinearMotionBlur, blursharpen\n\nfrom .filters import apply_random_rgb_levels, \\\n                     apply_random_overlay_triangle, \\\n                     apply_random_hsv_shift, \\\n                     apply_random_sharpen, \\\n                     apply_random_motion_blur, \\\n                     apply_random_gaussian_blur, \\\n                     apply_random_nearest_resize, \\\n                     apply_random_bilinear_resize, \\\n                     apply_random_jpeg_compress, \\\n                     apply_random_relight\n", "core/imagelib/text.py": "import localization\nimport numpy as np\nfrom PIL import Image, ImageDraw, ImageFont\n\npil_fonts = {}\ndef _get_pil_font (font, size):\n    global pil_fonts\n    try:\n        font_str_id = '%s_%d' % (font, size)\n        if font_str_id not in pil_fonts.keys():\n            pil_fonts[font_str_id] = ImageFont.truetype(font + \".ttf\", size=size, encoding=\"unic\")\n        pil_font = pil_fonts[font_str_id]\n        return pil_font\n    except:\n        return ImageFont.load_default()\n\ndef get_text_image( shape, text, color=(1,1,1), border=0.2, font=None):\n    h,w,c = shape\n    try:\n        pil_font = _get_pil_font( localization.get_default_ttf_font_name() , h-2)\n\n        canvas = Image.new('RGB', (w,h) , (0,0,0) )\n        draw = ImageDraw.Draw(canvas)\n        offset = ( 0, 0)\n        draw.text(offset, text, font=pil_font, fill=tuple((np.array(color)*255).astype(np.int)) )\n\n        result = np.asarray(canvas) / 255\n\n        if c > 3:\n            result = np.concatenate ( (result, np.ones ((h,w,c-3)) ), axis=-1 )\n        elif c < 3:\n            result = result[...,0:c]\n        return result\n    except:\n        return np.zeros ( (h,w,c) )\n\ndef draw_text( image, rect, text, color=(1,1,1), border=0.2, font=None):\n    h,w,c = image.shape\n\n    l,t,r,b = rect\n    l = np.clip (l, 0, w-1)\n    r = np.clip (r, 0, w-1)\n    t = np.clip (t, 0, h-1)\n    b = np.clip (b, 0, h-1)\n\n    image[t:b, l:r] += get_text_image (  (b-t,r-l,c) , text, color, border, font )\n\n\ndef draw_text_lines (image, rect, text_lines, color=(1,1,1), border=0.2, font=None):\n    text_lines_len = len(text_lines)\n    if text_lines_len == 0:\n        return\n\n    l,t,r,b = rect\n    h = b-t\n    h_per_line = h // text_lines_len\n\n    for i in range(0, text_lines_len):\n        draw_text (image, (l, i*h_per_line, r, (i+1)*h_per_line), text_lines[i], color, border, font)\n\ndef get_draw_text_lines ( image, rect, text_lines, color=(1,1,1), border=0.2, font=None):\n    image = np.zeros ( image.shape, dtype=np.float )\n    draw_text_lines ( image, rect, text_lines, color, border, font)\n    return image\n", "core/imagelib/morph.py": "import numpy as np\nimport cv2\nfrom scipy.spatial import Delaunay\n\n\ndef applyAffineTransform(src, srcTri, dstTri, size) :\n    warpMat = cv2.getAffineTransform( np.float32(srcTri), np.float32(dstTri) )\n    return cv2.warpAffine( src, warpMat, (size[0], size[1]), None, flags=cv2.INTER_LINEAR, borderMode=cv2.BORDER_REFLECT_101 )\n\ndef morphTriangle(dst_img, src_img, st, dt) :\n    (h,w,c) = dst_img.shape\n    sr = np.array( cv2.boundingRect(np.float32(st)) )\n    dr = np.array( cv2.boundingRect(np.float32(dt)) )\n    sRect = st - sr[0:2]\n    dRect = dt - dr[0:2]\n    d_mask = np.zeros((dr[3], dr[2], c), dtype = np.float32)\n    cv2.fillConvexPoly(d_mask, np.int32(dRect), (1.0,)*c, 8, 0);\n    imgRect = src_img[sr[1]:sr[1] + sr[3], sr[0]:sr[0] + sr[2]]\n    size = (dr[2], dr[3])\n    warpImage1 = applyAffineTransform(imgRect, sRect, dRect, size)\n\n    if c == 1:\n        warpImage1 = np.expand_dims( warpImage1, -1 )\n\n    dst_img[dr[1]:dr[1]+dr[3], dr[0]:dr[0]+dr[2]] = dst_img[dr[1]:dr[1]+dr[3], dr[0]:dr[0]+dr[2]]*(1-d_mask) + warpImage1 * d_mask\n\ndef morph_by_points (image, sp, dp):\n    if sp.shape != dp.shape:\n        raise ValueError ('morph_by_points() sp.shape != dp.shape')\n    (h,w,c) = image.shape\n\n    result_image = np.zeros(image.shape, dtype = image.dtype)\n\n    for tri in Delaunay(dp).simplices:\n        morphTriangle(result_image, image, sp[tri], dp[tri])\n\n    return result_image", "core/imagelib/draw.py": "import numpy as np\nimport cv2\n\ndef draw_polygon (image, points, color, thickness = 1):\n    points_len = len(points)\n    for i in range (0, points_len):\n        p0 = tuple( points[i] )\n        p1 = tuple( points[ (i+1) % points_len] )\n        cv2.line (image, p0, p1, color, thickness=thickness)\n\ndef draw_rect(image, rect, color, thickness=1):\n    l,t,r,b = rect\n    draw_polygon (image, [ (l,t), (r,t), (r,b), (l,b ) ], color, thickness)\n", "core/imagelib/reduce_colors.py": "import numpy as np\nimport cv2\nfrom PIL import Image\n\n#n_colors = [0..256]\ndef reduce_colors (img_bgr, n_colors):\n    img_rgb = (img_bgr[...,::-1] * 255.0).astype(np.uint8)\n    img_rgb_pil = Image.fromarray(img_rgb)\n    img_rgb_pil_p = img_rgb_pil.convert('P', palette=Image.ADAPTIVE, colors=n_colors)\n\n    img_rgb_p = img_rgb_pil_p.convert('RGB')\n    img_bgr = cv2.cvtColor( np.array(img_rgb_p, dtype=np.float32) / 255.0, cv2.COLOR_RGB2BGR )\n\n    return img_bgr\n", "core/imagelib/sd/calc.py": "import numpy as np\nimport numpy.linalg as npla\n\ndef dist_to_edges(pts, pt, is_closed=False):\n    \"\"\"\n    returns array of dist from pt to edge and projection pt to edges\n    \"\"\"\n    if is_closed:\n        a = pts\n        b = np.concatenate( (pts[1:,:], pts[0:1,:]), axis=0 )\n    else:\n        a = pts[:-1,:]\n        b = pts[1:,:]\n\n    pa = pt-a\n    ba = b-a\n    \n    div = np.einsum('ij,ij->i', ba, ba)\n    div[div==0]=1\n    h = np.clip( np.einsum('ij,ij->i', pa, ba) / div, 0, 1 )\n    \n    x = npla.norm ( pa - ba*h[...,None], axis=1 )\n    \n    return x, a+ba*h[...,None]\n    \n", "core/imagelib/sd/__init__.py": "from .draw import circle_faded, random_circle_faded, bezier, random_bezier_split_faded, random_faded\nfrom .calc import *", "core/imagelib/sd/draw.py": "\"\"\"\nSigned distance drawing functions using numpy.\n\"\"\"\nimport math\n\nimport numpy as np\nfrom numpy import linalg as npla\n\n\ndef vector2_dot(a,b):\n    return a[...,0]*b[...,0]+a[...,1]*b[...,1]\n    \ndef vector2_dot2(a):\n    return a[...,0]*a[...,0]+a[...,1]*a[...,1]\n    \ndef vector2_cross(a,b):\n    return a[...,0]*b[...,1]-a[...,1]*b[...,0]\n\n\ndef circle_faded( wh, center, fade_dists ):\n    \"\"\"\n    returns drawn circle in [h,w,1] output range [0..1.0] float32\n    \n    wh         = [w,h]                      resolution\n    center     = [x,y]                      center of circle\n    fade_dists = [fade_start, fade_end]     fade values\n    \"\"\"\n    w,h = wh      \n    \n    pts = np.empty( (h,w,2), dtype=np.float32 )\n    pts[...,0] = np.arange(w)[:,None]\n    pts[...,1] = np.arange(h)[None,:]\n    \n    pts = pts.reshape ( (h*w, -1) )\n\n    pts_dists = np.abs ( npla.norm(pts-center, axis=-1) )\n    \n    if fade_dists[1] == 0:\n        fade_dists[1] = 1\n        \n    pts_dists = ( pts_dists - fade_dists[0] ) / fade_dists[1]\n        \n    pts_dists = np.clip( 1-pts_dists, 0, 1)\n    \n    return pts_dists.reshape ( (h,w,1) ).astype(np.float32)\n\n\ndef bezier( wh, A, B, C ):\n    \"\"\"\n    returns drawn bezier in [h,w,1] output range float32, \n    every pixel contains signed distance to bezier line\n\n        wh      [w,h]       resolution\n        A,B,C   points [x,y]\n    \"\"\"\n    \n    width,height = wh\n    \n    A = np.float32(A)\n    B = np.float32(B)\n    C = np.float32(C)\n    \n\n    pos = np.empty( (height,width,2), dtype=np.float32 )\n    pos[...,0] = np.arange(width)[:,None]\n    pos[...,1] = np.arange(height)[None,:]\n    \n\n    a = B-A\n    b = A - 2.0*B + C\n    c = a * 2.0\n    d = A - pos\n\n    b_dot = vector2_dot(b,b)\n    if b_dot == 0.0:\n        return np.zeros( (height,width), dtype=np.float32 )\n    \n    kk = 1.0 / b_dot\n\n    kx = kk * vector2_dot(a,b)\n    ky = kk * (2.0*vector2_dot(a,a)+vector2_dot(d,b))/3.0;\n    kz = kk * vector2_dot(d,a);\n\n    res = 0.0;\n    sgn = 0.0;\n\n    p = ky - kx*kx;\n    \n    p3 = p*p*p;\n    q = kx*(2.0*kx*kx - 3.0*ky) + kz;\n    h = q*q + 4.0*p3;\n    \n    hp_sel = h >= 0.0\n    \n    hp_p = h[hp_sel]\n    hp_p = np.sqrt(hp_p)\n    \n    hp_x = ( np.stack( (hp_p,-hp_p), -1) -q[hp_sel,None] ) / 2.0\n    hp_uv = np.sign(hp_x) * np.power( np.abs(hp_x), [1.0/3.0, 1.0/3.0] )\n    hp_t = np.clip( hp_uv[...,0] + hp_uv[...,1] - kx, 0.0, 1.0 )\n    \n    hp_t = hp_t[...,None]\n    hp_q = d[hp_sel]+(c+b*hp_t)*hp_t\n    hp_res = vector2_dot2(hp_q)\n    hp_sgn = vector2_cross(c+2.0*b*hp_t,hp_q)\n    \n    hl_sel = h < 0.0\n    \n    hl_q = q[hl_sel]\n    hl_p = p[hl_sel]\n    hl_z = np.sqrt(-hl_p)\n    hl_v = np.arccos( hl_q / (hl_p*hl_z*2.0)) / 3.0\n    \n    hl_m = np.cos(hl_v)\n    hl_n = np.sin(hl_v)*1.732050808;\n    \n    hl_t = np.clip( np.stack( (hl_m+hl_m,-hl_n-hl_m,hl_n-hl_m), -1)*hl_z[...,None]-kx, 0.0, 1.0 );\n    \n    hl_d = d[hl_sel]\n    \n    hl_qx = hl_d+(c+b*hl_t[...,0:1])*hl_t[...,0:1]\n    \n    hl_dx = vector2_dot2(hl_qx)\n    hl_sx = vector2_cross(c+2.0*b*hl_t[...,0:1], hl_qx)\n    \n    hl_qy = hl_d+(c+b*hl_t[...,1:2])*hl_t[...,1:2]\n    hl_dy = vector2_dot2(hl_qy)\n    hl_sy = vector2_cross(c+2.0*b*hl_t[...,1:2],hl_qy);\n    \n    hl_dx_l_dy = hl_dx<hl_dy\n    hl_dx_ge_dy = hl_dx>=hl_dy\n    \n    hl_res = np.empty_like(hl_dx)\n    hl_res[hl_dx_l_dy] = hl_dx[hl_dx_l_dy]\n    hl_res[hl_dx_ge_dy] = hl_dy[hl_dx_ge_dy]\n    \n    hl_sgn = np.empty_like(hl_sx)\n    hl_sgn[hl_dx_l_dy] = hl_sx[hl_dx_l_dy]\n    hl_sgn[hl_dx_ge_dy] = hl_sy[hl_dx_ge_dy]\n    \n    res = np.empty( (height, width), np.float32 )\n    res[hp_sel] = hp_res\n    res[hl_sel] = hl_res\n    \n    sgn = np.empty( (height, width), np.float32 )\n    sgn[hp_sel] = hp_sgn\n    sgn[hl_sel] = hl_sgn\n    \n    sgn = np.sign(sgn)\n    res = np.sqrt(res)*sgn\n    \n    return res[...,None]\n        \ndef random_faded(wh):\n    \"\"\"\n    apply one of them:\n     random_circle_faded\n     random_bezier_split_faded\n    \"\"\"\n    rnd = np.random.randint(2)\n    if rnd == 0:\n        return random_circle_faded(wh)\n    elif rnd == 1:\n        return random_bezier_split_faded(wh)\n    \ndef random_circle_faded ( wh, rnd_state=None ):\n    if rnd_state is None:\n        rnd_state = np.random\n        \n    w,h = wh\n    wh_max = max(w,h)\n    fade_start = rnd_state.randint(wh_max)\n    fade_end = fade_start + rnd_state.randint(wh_max- fade_start)\n    \n    return circle_faded (wh, [ rnd_state.randint(h), rnd_state.randint(w) ], \n                             [fade_start, fade_end] ) \n                             \ndef random_bezier_split_faded( wh ):\n    width, height = wh\n    \n    degA = np.random.randint(360)\n    degB = np.random.randint(360)\n    degC = np.random.randint(360)\n    \n    deg_2_rad = math.pi / 180.0\n    \n    center = np.float32([width / 2.0, height / 2.0])\n    \n    radius = max(width, height)\n    \n    A = center + radius*np.float32([ math.sin( degA * deg_2_rad), math.cos( degA * deg_2_rad) ] ) \n    B = center + np.random.randint(radius)*np.float32([ math.sin( degB * deg_2_rad), math.cos( degB * deg_2_rad) ] ) \n    C = center + radius*np.float32([ math.sin( degC * deg_2_rad), math.cos( degC * deg_2_rad) ] ) \n    \n    x = bezier( (width,height), A, B, C )\n    \n    x = x / (1+np.random.randint(radius)) + 0.5\n    \n    x = np.clip(x, 0, 1)\n    return x\n", "samplelib/Sample.py": "from enum import IntEnum\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\n\nfrom core.cv2ex import *\nfrom facelib import LandmarksProcessor\nfrom core import imagelib\nfrom core.imagelib import SegIEPolys\n\nclass SampleType(IntEnum):\n    IMAGE = 0 #raw image\n\n    FACE_BEGIN = 1\n    FACE = 1                        #aligned face unsorted\n    FACE_PERSON = 2                 #aligned face person\n    FACE_TEMPORAL_SORTED = 3        #sorted by source filename\n    FACE_END = 3\n\n    QTY = 4\n\nclass Sample(object):\n    __slots__ = ['sample_type',\n                 'filename',\n                 'face_type',\n                 'shape',\n                 'landmarks',\n                 'seg_ie_polys',\n                 'xseg_mask',\n                 'xseg_mask_compressed',\n                 'eyebrows_expand_mod',\n                 'source_filename',\n                 'person_name',\n                 'pitch_yaw_roll',\n                 '_filename_offset_size',\n                ]\n\n    def __init__(self, sample_type=None,\n                       filename=None,\n                       face_type=None,\n                       shape=None,\n                       landmarks=None,\n                       seg_ie_polys=None,\n                       xseg_mask=None,\n                       xseg_mask_compressed=None,\n                       eyebrows_expand_mod=None,\n                       source_filename=None,\n                       person_name=None,\n                       pitch_yaw_roll=None,\n                       **kwargs):\n\n        self.sample_type = sample_type if sample_type is not None else SampleType.IMAGE\n        self.filename = filename\n        self.face_type = face_type\n        self.shape = shape\n        self.landmarks = np.array(landmarks) if landmarks is not None else None\n        \n        if isinstance(seg_ie_polys, SegIEPolys):\n            self.seg_ie_polys = seg_ie_polys\n        else:\n            self.seg_ie_polys = SegIEPolys.load(seg_ie_polys)\n        \n        self.xseg_mask = xseg_mask\n        self.xseg_mask_compressed = xseg_mask_compressed\n        \n        if self.xseg_mask_compressed is None and self.xseg_mask is not None:\n            xseg_mask = np.clip( imagelib.normalize_channels(xseg_mask, 1)*255, 0, 255 ).astype(np.uint8)        \n            ret, xseg_mask_compressed = cv2.imencode('.png', xseg_mask)\n            if not ret:\n                raise Exception(\"Sample(): unable to generate xseg_mask_compressed\")\n            self.xseg_mask_compressed = xseg_mask_compressed\n            self.xseg_mask = None\n \n        self.eyebrows_expand_mod = eyebrows_expand_mod if eyebrows_expand_mod is not None else 1.0\n        self.source_filename = source_filename\n        self.person_name = person_name\n        self.pitch_yaw_roll = pitch_yaw_roll\n\n        self._filename_offset_size = None\n\n    def has_xseg_mask(self):\n        return self.xseg_mask is not None or self.xseg_mask_compressed is not None\n        \n    def get_xseg_mask(self):\n        if self.xseg_mask_compressed is not None:\n            xseg_mask = cv2.imdecode(self.xseg_mask_compressed, cv2.IMREAD_UNCHANGED)\n            if len(xseg_mask.shape) == 2:\n                xseg_mask = xseg_mask[...,None]\n            return xseg_mask.astype(np.float32) / 255.0\n        return self.xseg_mask\n        \n    def get_pitch_yaw_roll(self):\n        if self.pitch_yaw_roll is None:\n            self.pitch_yaw_roll = LandmarksProcessor.estimate_pitch_yaw_roll(self.landmarks, size=self.shape[1])\n        return self.pitch_yaw_roll\n\n    def set_filename_offset_size(self, filename, offset, size):\n        self._filename_offset_size = (filename, offset, size)\n\n    def read_raw_file(self, filename=None):\n        if self._filename_offset_size is not None:\n            filename, offset, size = self._filename_offset_size\n            with open(filename, \"rb\") as f:\n                f.seek( offset, 0)\n                return f.read (size)\n        else:\n            with open(filename, \"rb\") as f:\n                return f.read()\n\n    def load_bgr(self):\n        img = cv2_imread (self.filename, loader_func=self.read_raw_file).astype(np.float32) / 255.0\n        return img\n\n    def get_config(self):\n        return {'sample_type': self.sample_type,\n                'filename': self.filename,\n                'face_type': self.face_type,\n                'shape': self.shape,\n                'landmarks': self.landmarks.tolist(),\n                'seg_ie_polys': self.seg_ie_polys.dump(),\n                'xseg_mask' : self.xseg_mask,\n                'xseg_mask_compressed' : self.xseg_mask_compressed,\n                'eyebrows_expand_mod': self.eyebrows_expand_mod,\n                'source_filename': self.source_filename,\n                'person_name': self.person_name\n               }\n", "samplelib/SampleProcessor.py": "import collections\nimport math\nfrom enum import IntEnum\n\nimport cv2\nimport numpy as np\n\nfrom core import imagelib\nfrom core.cv2ex import *\nfrom core.imagelib import sd\nfrom facelib import FaceType, LandmarksProcessor\n\n\nclass SampleProcessor(object):\n    class SampleType(IntEnum):\n        NONE = 0\n        IMAGE = 1\n        FACE_IMAGE = 2\n        FACE_MASK  = 3\n        LANDMARKS_ARRAY            = 4\n        PITCH_YAW_ROLL             = 5\n        PITCH_YAW_ROLL_SIGMOID     = 6\n\n    class ChannelType(IntEnum):\n        NONE = 0\n        BGR                   = 1  #BGR\n        G                     = 2  #Grayscale\n        GGG                   = 3  #3xGrayscale\n\n    class FaceMaskType(IntEnum):\n        NONE          = 0\n        FULL_FACE      = 1  # mask all hull as grayscale\n        EYES           = 2  # mask eyes hull as grayscale\n        EYES_MOUTH     = 3  # eyes and mouse\n\n    class Options(object):\n        def __init__(self, random_flip = True, rotation_range=[-10,10], scale_range=[-0.05, 0.05], tx_range=[-0.05, 0.05], ty_range=[-0.05, 0.05] ):\n            self.random_flip = random_flip\n            self.rotation_range = rotation_range\n            self.scale_range = scale_range\n            self.tx_range = tx_range\n            self.ty_range = ty_range\n\n    @staticmethod\n    def process (samples, sample_process_options, output_sample_types, debug, ct_sample=None):\n        SPST = SampleProcessor.SampleType\n        SPCT = SampleProcessor.ChannelType\n        SPFMT = SampleProcessor.FaceMaskType\n\n        \n        outputs = []\n        for sample in samples:\n            sample_rnd_seed = np.random.randint(0x80000000)\n            \n            sample_face_type = sample.face_type\n            sample_bgr = sample.load_bgr()\n            sample_landmarks = sample.landmarks\n            ct_sample_bgr = None\n            h,w,c = sample_bgr.shape\n            \n            def get_full_face_mask():   \n                xseg_mask = sample.get_xseg_mask()                                     \n                if xseg_mask is not None:           \n                    if xseg_mask.shape[0] != h or xseg_mask.shape[1] != w:\n                        xseg_mask = cv2.resize(xseg_mask, (w,h), interpolation=cv2.INTER_CUBIC)                    \n                        xseg_mask = imagelib.normalize_channels(xseg_mask, 1)\n                    return np.clip(xseg_mask, 0, 1)\n                else:\n                    full_face_mask = LandmarksProcessor.get_image_hull_mask (sample_bgr.shape, sample_landmarks, eyebrows_expand_mod=sample.eyebrows_expand_mod )\n                    return np.clip(full_face_mask, 0, 1)\n                \n            def get_eyes_mask():\n                eyes_mask = LandmarksProcessor.get_image_eye_mask (sample_bgr.shape, sample_landmarks)\n                return np.clip(eyes_mask, 0, 1)\n            \n            def get_eyes_mouth_mask():                \n                eyes_mask = LandmarksProcessor.get_image_eye_mask (sample_bgr.shape, sample_landmarks)\n                mouth_mask = LandmarksProcessor.get_image_mouth_mask (sample_bgr.shape, sample_landmarks)\n                mask = eyes_mask + mouth_mask\n                return np.clip(mask, 0, 1)\n                \n            is_face_sample = sample_landmarks is not None\n\n            if debug and is_face_sample:\n                LandmarksProcessor.draw_landmarks (sample_bgr, sample_landmarks, (0, 1, 0))\n\n            outputs_sample = []\n            for opts in output_sample_types:\n                resolution     = opts.get('resolution', 0)\n                sample_type    = opts.get('sample_type', SPST.NONE)\n                channel_type   = opts.get('channel_type', SPCT.NONE)                \n                nearest_resize_to = opts.get('nearest_resize_to', None)\n                warp           = opts.get('warp', False)\n                transform      = opts.get('transform', False)\n                random_hsv_shift_amount = opts.get('random_hsv_shift_amount', 0)\n                normalize_tanh = opts.get('normalize_tanh', False)\n                ct_mode        = opts.get('ct_mode', None)\n                data_format    = opts.get('data_format', 'NHWC')\n                \n                rnd_seed_shift      = opts.get('rnd_seed_shift', 0)\n                warp_rnd_seed_shift = opts.get('warp_rnd_seed_shift', rnd_seed_shift)\n                \n                rnd_state      = np.random.RandomState (sample_rnd_seed+rnd_seed_shift)\n                warp_rnd_state = np.random.RandomState (sample_rnd_seed+warp_rnd_seed_shift)\n                \n                warp_params = imagelib.gen_warp_params(resolution, \n                                                       sample_process_options.random_flip, \n                                                       rotation_range=sample_process_options.rotation_range, \n                                                       scale_range=sample_process_options.scale_range, \n                                                       tx_range=sample_process_options.tx_range, \n                                                       ty_range=sample_process_options.ty_range, \n                                                       rnd_state=rnd_state,\n                                                       warp_rnd_state=warp_rnd_state,\n                                                       )\n                \n                if sample_type == SPST.FACE_MASK or sample_type == SPST.IMAGE: \n                    border_replicate = False\n                elif sample_type == SPST.FACE_IMAGE:\n                    border_replicate = True\n                    \n                    \n                border_replicate = opts.get('border_replicate', border_replicate)\n                borderMode = cv2.BORDER_REPLICATE if border_replicate else cv2.BORDER_CONSTANT\n                \n                \n                if sample_type == SPST.FACE_IMAGE or sample_type == SPST.FACE_MASK:\n                    if not is_face_sample:    \n                        raise ValueError(\"face_samples should be provided for sample_type FACE_*\")\n\n                if sample_type == SPST.FACE_IMAGE or sample_type == SPST.FACE_MASK:\n                    face_type      = opts.get('face_type', None)\n                    face_mask_type = opts.get('face_mask_type', SPFMT.NONE)\n                \n                    if face_type is None:\n                        raise ValueError(\"face_type must be defined for face samples\")\n\n                    if sample_type == SPST.FACE_MASK: \n                        if face_mask_type == SPFMT.FULL_FACE:\n                            img = get_full_face_mask()\n                        elif face_mask_type == SPFMT.EYES:\n                            img = get_eyes_mask()\n                        elif face_mask_type == SPFMT.EYES_MOUTH:\n                            mask = get_full_face_mask().copy()\n                            mask[mask != 0.0] = 1.0                            \n                            img = get_eyes_mouth_mask()*mask\n                        else:\n                            img = np.zeros ( sample_bgr.shape[0:2]+(1,), dtype=np.float32)\n\n                        if sample_face_type == FaceType.MARK_ONLY:\n                            raise NotImplementedError()\n                            mat  = LandmarksProcessor.get_transform_mat (sample_landmarks, warp_resolution, face_type)\n                            img = cv2.warpAffine( img, mat, (warp_resolution, warp_resolution), flags=cv2.INTER_LINEAR )\n                            \n                            img = imagelib.warp_by_params (warp_params, img, warp, transform, can_flip=True, border_replicate=border_replicate, cv2_inter=cv2.INTER_LINEAR)\n                            img = cv2.resize( img, (resolution,resolution), interpolation=cv2.INTER_LINEAR )\n                        else:\n                            if face_type != sample_face_type:\n                                mat = LandmarksProcessor.get_transform_mat (sample_landmarks, resolution, face_type)                            \n                                img = cv2.warpAffine( img, mat, (resolution,resolution), borderMode=borderMode, flags=cv2.INTER_LINEAR )\n                            else:\n                                if w != resolution:\n                                    img = cv2.resize( img, (resolution, resolution), interpolation=cv2.INTER_LINEAR )\n                                \n                            img = imagelib.warp_by_params (warp_params, img, warp, transform, can_flip=True, border_replicate=border_replicate, cv2_inter=cv2.INTER_LINEAR)\n\n                        if face_mask_type == SPFMT.EYES_MOUTH:\n                            div = img.max()\n                            if div != 0.0:\n                                img = img / div # normalize to 1.0 after warp\n                            \n                        if len(img.shape) == 2:\n                            img = img[...,None]\n                            \n                        if channel_type == SPCT.G:\n                            out_sample = img.astype(np.float32)\n                        else:\n                            raise ValueError(\"only channel_type.G supported for the mask\")\n\n                    elif sample_type == SPST.FACE_IMAGE:\n                        img = sample_bgr                      \n                            \n                        if face_type != sample_face_type:\n                            mat = LandmarksProcessor.get_transform_mat (sample_landmarks, resolution, face_type)\n                            img = cv2.warpAffine( img, mat, (resolution,resolution), borderMode=borderMode, flags=cv2.INTER_CUBIC )\n                        else:\n                            if w != resolution:\n                                img = cv2.resize( img, (resolution, resolution), interpolation=cv2.INTER_CUBIC )\n                                \n                        # Apply random color transfer                        \n                        if ct_mode is not None and ct_sample is not None:\n                            if ct_sample_bgr is None:\n                               ct_sample_bgr = ct_sample.load_bgr()\n                            img = imagelib.color_transfer (ct_mode, img, cv2.resize( ct_sample_bgr, (resolution,resolution), interpolation=cv2.INTER_LINEAR ) )\n                        \n                        if random_hsv_shift_amount != 0:\n                            a = random_hsv_shift_amount\n                            h_amount = max(1, int(360*a*0.5))\n                            img_h, img_s, img_v = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))\n                            img_h = (img_h + rnd_state.randint(-h_amount, h_amount+1) ) % 360\n                            img_s = np.clip (img_s + (rnd_state.random()-0.5)*a, 0, 1 )\n                            img_v = np.clip (img_v + (rnd_state.random()-0.5)*a, 0, 1 )\n                            img = np.clip( cv2.cvtColor(cv2.merge([img_h, img_s, img_v]), cv2.COLOR_HSV2BGR) , 0, 1 )\n\n                        img  = imagelib.warp_by_params (warp_params, img,  warp, transform, can_flip=True, border_replicate=border_replicate)\n  \n                        img = np.clip(img.astype(np.float32), 0, 1)\n\n                        # Transform from BGR to desired channel_type\n                        if channel_type == SPCT.BGR:\n                            out_sample = img\n                        elif channel_type == SPCT.G:\n                            out_sample = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)[...,None]\n                        elif channel_type == SPCT.GGG:\n                            out_sample = np.repeat ( np.expand_dims(cv2.cvtColor(img, cv2.COLOR_BGR2GRAY),-1), (3,), -1)\n\n                    # Final transformations\n                    if nearest_resize_to is not None:\n                        out_sample = cv2_resize(out_sample, (nearest_resize_to,nearest_resize_to), interpolation=cv2.INTER_NEAREST)\n                        \n                    if not debug:\n                        if normalize_tanh:\n                            out_sample = np.clip (out_sample * 2.0 - 1.0, -1.0, 1.0)\n                    if data_format == \"NCHW\":\n                        out_sample = np.transpose(out_sample, (2,0,1) )\n                elif sample_type == SPST.IMAGE:\n                    img = sample_bgr      \n                    img  = imagelib.warp_by_params (warp_params, img,  warp, transform, can_flip=True, border_replicate=True)\n                    img  = cv2.resize( img,  (resolution, resolution), interpolation=cv2.INTER_CUBIC )\n                    out_sample = img\n                    \n                    if data_format == \"NCHW\":\n                        out_sample = np.transpose(out_sample, (2,0,1) )\n                    \n                    \n                elif sample_type == SPST.LANDMARKS_ARRAY:\n                    l = sample_landmarks\n                    l = np.concatenate ( [ np.expand_dims(l[:,0] / w,-1), np.expand_dims(l[:,1] / h,-1) ], -1 )\n                    l = np.clip(l, 0.0, 1.0)\n                    out_sample = l\n                elif sample_type == SPST.PITCH_YAW_ROLL or sample_type == SPST.PITCH_YAW_ROLL_SIGMOID:\n                    pitch,yaw,roll = sample.get_pitch_yaw_roll()\n                    if warp_params['flip']:\n                        yaw = -yaw\n\n                    if sample_type == SPST.PITCH_YAW_ROLL_SIGMOID:\n                        pitch = np.clip( (pitch / math.pi) / 2.0 + 0.5, 0, 1)\n                        yaw   = np.clip( (yaw / math.pi) / 2.0 + 0.5, 0, 1)\n                        roll  = np.clip( (roll / math.pi) / 2.0 + 0.5, 0, 1)\n\n                    out_sample = (pitch, yaw)\n                else:\n                    raise ValueError ('expected sample_type')\n\n                outputs_sample.append ( out_sample )\n            outputs += [outputs_sample]\n\n        return outputs\n\n", "samplelib/SampleGeneratorFacePerson.py": "import copy\nimport multiprocessing\nimport traceback\n\nimport cv2\nimport numpy as np\n\nfrom core import mplib\nfrom core.joblib import SubprocessGenerator, ThisThreadGenerator\nfrom facelib import LandmarksProcessor\nfrom samplelib import (SampleGeneratorBase, SampleLoader, SampleProcessor,\n                       SampleType)\n\n\n\nclass Index2DHost():\n    \"\"\"\n    Provides random shuffled 2D indexes for multiprocesses\n    \"\"\"\n    def __init__(self, indexes2D):\n        self.sq = multiprocessing.Queue()\n        self.cqs = []\n        self.clis = []\n        self.thread = threading.Thread(target=self.host_thread, args=(indexes2D,) )\n        self.thread.daemon = True\n        self.thread.start()\n\n    def host_thread(self, indexes2D):\n        indexes_counts_len = len(indexes2D)\n\n        idxs = [*range(indexes_counts_len)]\n        idxs_2D = [None]*indexes_counts_len\n        shuffle_idxs = []\n        shuffle_idxs_2D = [None]*indexes_counts_len\n        for i in range(indexes_counts_len):\n            idxs_2D[i] = indexes2D[i]\n            shuffle_idxs_2D[i] = []\n\n        sq = self.sq\n\n        while True:\n            while not sq.empty():\n                obj = sq.get()\n                cq_id, cmd = obj[0], obj[1]\n\n                if cmd == 0: #get_1D\n                    count = obj[2]\n\n                    result = []\n                    for i in range(count):\n                        if len(shuffle_idxs) == 0:\n                            shuffle_idxs = idxs.copy()\n                            np.random.shuffle(shuffle_idxs)\n                        result.append(shuffle_idxs.pop())\n                    self.cqs[cq_id].put (result)\n                elif cmd == 1: #get_2D\n                    targ_idxs,count = obj[2], obj[3]\n                    result = []\n\n                    for targ_idx in targ_idxs:\n                        sub_idxs = []\n                        for i in range(count):\n                            ar = shuffle_idxs_2D[targ_idx]\n                            if len(ar) == 0:\n                                ar = shuffle_idxs_2D[targ_idx] = idxs_2D[targ_idx].copy()\n                                np.random.shuffle(ar)\n                            sub_idxs.append(ar.pop())\n                        result.append (sub_idxs)\n                    self.cqs[cq_id].put (result)\n\n            time.sleep(0.001)\n\n    def create_cli(self):\n        cq = multiprocessing.Queue()\n        self.cqs.append ( cq )\n        cq_id = len(self.cqs)-1\n        return Index2DHost.Cli(self.sq, cq, cq_id)\n\n    # disable pickling\n    def __getstate__(self):\n        return dict()\n    def __setstate__(self, d):\n        self.__dict__.update(d)\n\n    class Cli():\n        def __init__(self, sq, cq, cq_id):\n            self.sq = sq\n            self.cq = cq\n            self.cq_id = cq_id\n\n        def get_1D(self, count):\n            self.sq.put ( (self.cq_id,0, count) )\n\n            while True:\n                if not self.cq.empty():\n                    return self.cq.get()\n                time.sleep(0.001)\n\n        def get_2D(self, idxs, count):\n            self.sq.put ( (self.cq_id,1,idxs,count) )\n\n            while True:\n                if not self.cq.empty():\n                    return self.cq.get()\n                time.sleep(0.001)\n                \n'''\narg\noutput_sample_types = [\n                        [SampleProcessor.TypeFlags, size, (optional) {} opts ] ,\n                        ...\n                      ]\n'''\nclass SampleGeneratorFacePerson(SampleGeneratorBase):\n    def __init__ (self, samples_path, debug=False, batch_size=1,\n                        sample_process_options=SampleProcessor.Options(),\n                        output_sample_types=[],\n                        person_id_mode=1,\n                        **kwargs):\n\n        super().__init__(debug, batch_size)\n        self.sample_process_options = sample_process_options\n        self.output_sample_types = output_sample_types\n        self.person_id_mode = person_id_mode\n\n        raise NotImplementedError(\"Currently SampleGeneratorFacePerson is not implemented.\")\n\n        samples_host = SampleLoader.mp_host (SampleType.FACE, samples_path)\n        samples = samples_host.get_list()\n        self.samples_len = len(samples)\n\n        if self.samples_len == 0:\n            raise ValueError('No training data provided.')\n\n        unique_person_names = { sample.person_name for sample in samples }\n        persons_name_idxs = { person_name : [] for person_name in unique_person_names }\n        for i,sample in enumerate(samples):\n            persons_name_idxs[sample.person_name].append (i)\n        indexes2D = [ persons_name_idxs[person_name] for person_name in unique_person_names ]\n        index2d_host = Index2DHost(indexes2D)\n\n        if self.debug:\n            self.generators_count = 1\n            self.generators = [iter_utils.ThisThreadGenerator ( self.batch_func, (samples_host.create_cli(), index2d_host.create_cli(),) )]\n        else:\n            self.generators_count = np.clip(multiprocessing.cpu_count(), 2, 4)\n            self.generators = [iter_utils.SubprocessGenerator ( self.batch_func, (samples_host.create_cli(), index2d_host.create_cli(),) ) for i in range(self.generators_count) ]\n\n        self.generator_counter = -1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.generator_counter += 1\n        generator = self.generators[self.generator_counter % len(self.generators) ]\n        return next(generator)\n\n    def batch_func(self, param ):\n        samples, index2d_host, = param\n        bs = self.batch_size\n\n        while True:\n            person_idxs = index2d_host.get_1D(bs)\n            samples_idxs = index2d_host.get_2D(person_idxs, 1)\n\n            batches = None\n            for n_batch in range(bs):\n                person_id = person_idxs[n_batch]\n                sample_idx = samples_idxs[n_batch][0]\n\n                sample = samples[ sample_idx ]\n                try:\n                    x, = SampleProcessor.process ([sample], self.sample_process_options, self.output_sample_types, self.debug)\n                except:\n                    raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample.filename, traceback.format_exc() ) )\n\n                if batches is None:\n                    batches = [ [] for _ in range(len(x)) ]\n\n                    batches += [ [] ]\n                    i_person_id = len(batches)-1\n\n                for i in range(len(x)):\n                    batches[i].append ( x[i] )\n\n                batches[i_person_id].append ( np.array([person_id]) )\n\n            yield [ np.array(batch) for batch in batches]\n\n    @staticmethod\n    def get_person_id_max_count(samples_path):\n        return SampleLoader.get_person_id_max_count(samples_path)\n\n\"\"\"\nif self.person_id_mode==1:\n            samples_len = len(samples)\n            samples_idxs = [*range(samples_len)]\n            shuffle_idxs = []\n        elif self.person_id_mode==2:\n            persons_count = len(samples)\n\n            person_idxs = []\n            for j in range(persons_count):\n                for i in range(j+1,persons_count):\n                    person_idxs += [ [i,j] ]\n\n            shuffle_person_idxs = []\n\n            samples_idxs = [None]*persons_count\n            shuffle_idxs = [None]*persons_count\n\n            for i in range(persons_count):\n                samples_idxs[i] = [*range(len(samples[i]))]\n                shuffle_idxs[i] = []\n        elif self.person_id_mode==3:\n            persons_count = len(samples)\n\n            person_idxs = [ *range(persons_count) ]\n            shuffle_person_idxs = []\n\n            samples_idxs = [None]*persons_count\n            shuffle_idxs = [None]*persons_count\n\n            for i in range(persons_count):\n                samples_idxs[i] = [*range(len(samples[i]))]\n                shuffle_idxs[i] = []\n\nif self.person_id_mode==2:\n                if len(shuffle_person_idxs) == 0:\n                    shuffle_person_idxs = person_idxs.copy()\n                    np.random.shuffle(shuffle_person_idxs)\n                person_ids = shuffle_person_idxs.pop()\n\n\n            batches = None\n            for n_batch in range(self.batch_size):\n\n                if self.person_id_mode==1:\n                    if len(shuffle_idxs) == 0:\n                        shuffle_idxs = samples_idxs.copy()\n                        np.random.shuffle(shuffle_idxs) ###\n\n                    idx = shuffle_idxs.pop()\n                    sample = samples[ idx ]\n\n                    try:\n                        x, = SampleProcessor.process ([sample], self.sample_process_options, self.output_sample_types, self.debug)\n                    except:\n                        raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample.filename, traceback.format_exc() ) )\n\n                    if type(x) != tuple and type(x) != list:\n                        raise Exception('SampleProcessor.process returns NOT tuple/list')\n\n                    if batches is None:\n                        batches = [ [] for _ in range(len(x)) ]\n\n                        batches += [ [] ]\n                        i_person_id = len(batches)-1\n\n                    for i in range(len(x)):\n                        batches[i].append ( x[i] )\n\n                    batches[i_person_id].append ( np.array([sample.person_id]) )\n\n\n                elif self.person_id_mode==2:\n                    person_id1, person_id2 = person_ids\n\n                    if len(shuffle_idxs[person_id1]) == 0:\n                        shuffle_idxs[person_id1] = samples_idxs[person_id1].copy()\n                        np.random.shuffle(shuffle_idxs[person_id1])\n\n                    idx = shuffle_idxs[person_id1].pop()\n                    sample1 = samples[person_id1][idx]\n\n                    if len(shuffle_idxs[person_id2]) == 0:\n                        shuffle_idxs[person_id2] = samples_idxs[person_id2].copy()\n                        np.random.shuffle(shuffle_idxs[person_id2])\n\n                    idx = shuffle_idxs[person_id2].pop()\n                    sample2 = samples[person_id2][idx]\n\n                    if sample1 is not None and sample2 is not None:\n                        try:\n                            x1, = SampleProcessor.process ([sample1], self.sample_process_options, self.output_sample_types, self.debug)\n                        except:\n                            raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample1.filename, traceback.format_exc() ) )\n\n                        try:\n                            x2, = SampleProcessor.process ([sample2], self.sample_process_options, self.output_sample_types, self.debug)\n                        except:\n                            raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample2.filename, traceback.format_exc() ) )\n\n                        x1_len = len(x1)\n                        if batches is None:\n                            batches = [ [] for _ in range(x1_len) ]\n                            batches += [ [] ]\n                            i_person_id1 = len(batches)-1\n\n                            batches += [ [] for _ in range(len(x2)) ]\n                            batches += [ [] ]\n                            i_person_id2 = len(batches)-1\n\n                        for i in range(x1_len):\n                            batches[i].append ( x1[i] )\n\n                        for i in range(len(x2)):\n                            batches[x1_len+1+i].append ( x2[i] )\n\n                        batches[i_person_id1].append ( np.array([sample1.person_id]) )\n\n                        batches[i_person_id2].append ( np.array([sample2.person_id]) )\n\n                elif self.person_id_mode==3:\n                    if len(shuffle_person_idxs) == 0:\n                        shuffle_person_idxs = person_idxs.copy()\n                        np.random.shuffle(shuffle_person_idxs)\n                    person_id = shuffle_person_idxs.pop()\n\n                    if len(shuffle_idxs[person_id]) == 0:\n                        shuffle_idxs[person_id] = samples_idxs[person_id].copy()\n                        np.random.shuffle(shuffle_idxs[person_id])\n\n                    idx = shuffle_idxs[person_id].pop()\n                    sample1 = samples[person_id][idx]\n\n                    if len(shuffle_idxs[person_id]) == 0:\n                        shuffle_idxs[person_id] = samples_idxs[person_id].copy()\n                        np.random.shuffle(shuffle_idxs[person_id])\n\n                    idx = shuffle_idxs[person_id].pop()\n                    sample2 = samples[person_id][idx]\n\n                    if sample1 is not None and sample2 is not None:\n                        try:\n                            x1, = SampleProcessor.process ([sample1], self.sample_process_options, self.output_sample_types, self.debug)\n                        except:\n                            raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample1.filename, traceback.format_exc() ) )\n\n                        try:\n                            x2, = SampleProcessor.process ([sample2], self.sample_process_options, self.output_sample_types, self.debug)\n                        except:\n                            raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample2.filename, traceback.format_exc() ) )\n\n                        x1_len = len(x1)\n                        if batches is None:\n                            batches = [ [] for _ in range(x1_len) ]\n                            batches += [ [] ]\n                            i_person_id1 = len(batches)-1\n\n                            batches += [ [] for _ in range(len(x2)) ]\n                            batches += [ [] ]\n                            i_person_id2 = len(batches)-1\n\n                        for i in range(x1_len):\n                            batches[i].append ( x1[i] )\n\n                        for i in range(len(x2)):\n                            batches[x1_len+1+i].append ( x2[i] )\n\n                        batches[i_person_id1].append ( np.array([sample1.person_id]) )\n\n                        batches[i_person_id2].append ( np.array([sample2.person_id]) )\n\"\"\"\n", "samplelib/SampleGeneratorFace.py": "import multiprocessing\nimport time\nimport traceback\n\nimport cv2\nimport numpy as np\n\nfrom core import mplib\nfrom core.interact import interact as io\nfrom core.joblib import SubprocessGenerator, ThisThreadGenerator\nfrom facelib import LandmarksProcessor\nfrom samplelib import (SampleGeneratorBase, SampleLoader, SampleProcessor,\n                       SampleType)\n\n\n'''\narg\noutput_sample_types = [\n                        [SampleProcessor.TypeFlags, size, (optional) {} opts ] ,\n                        ...\n                      ]\n'''\nclass SampleGeneratorFace(SampleGeneratorBase):\n    def __init__ (self, samples_path, debug=False, batch_size=1,\n                        random_ct_samples_path=None,\n                        sample_process_options=SampleProcessor.Options(),\n                        output_sample_types=[],\n                        uniform_yaw_distribution=False,\n                        generators_count=4,\n                        raise_on_no_data=True,                        \n                        **kwargs):\n\n        super().__init__(debug, batch_size)\n        self.initialized = False\n        self.sample_process_options = sample_process_options\n        self.output_sample_types = output_sample_types\n        \n        if self.debug:\n            self.generators_count = 1\n        else:\n            self.generators_count = max(1, generators_count)\n\n        samples = SampleLoader.load (SampleType.FACE, samples_path)\n        self.samples_len = len(samples)\n        \n        if self.samples_len == 0:\n            if raise_on_no_data:\n                raise ValueError('No training data provided.')\n            else:\n                return\n                \n        if uniform_yaw_distribution:\n            samples_pyr = [ ( idx, sample.get_pitch_yaw_roll() ) for idx, sample in enumerate(samples) ]\n            \n            grads = 128\n            #instead of math.pi / 2, using -1.2,+1.2 because actually maximum yaw for 2DFAN landmarks are -1.2+1.2\n            grads_space = np.linspace (-1.2, 1.2,grads)\n\n            yaws_sample_list = [None]*grads\n            for g in io.progress_bar_generator ( range(grads), \"Sort by yaw\"):\n                yaw = grads_space[g]\n                next_yaw = grads_space[g+1] if g < grads-1 else yaw\n\n                yaw_samples = []\n                for idx, pyr in samples_pyr:\n                    s_yaw = -pyr[1]\n                    if (g == 0          and s_yaw < next_yaw) or \\\n                    (g < grads-1     and s_yaw >= yaw and s_yaw < next_yaw) or \\\n                    (g == grads-1    and s_yaw >= yaw):\n                        yaw_samples += [ idx ]\n                if len(yaw_samples) > 0:\n                    yaws_sample_list[g] = yaw_samples\n            \n            yaws_sample_list = [ y for y in yaws_sample_list if y is not None ]\n            \n            index_host = mplib.Index2DHost( yaws_sample_list )\n        else:\n            index_host = mplib.IndexHost(self.samples_len)\n\n        if random_ct_samples_path is not None:\n            ct_samples = SampleLoader.load (SampleType.FACE, random_ct_samples_path)\n            ct_index_host = mplib.IndexHost( len(ct_samples) )\n        else:\n            ct_samples = None\n            ct_index_host = None\n\n        if self.debug:\n            self.generators = [ThisThreadGenerator ( self.batch_func, (samples, index_host.create_cli(), ct_samples, ct_index_host.create_cli() if ct_index_host is not None else None) )]\n        else:\n            self.generators = [SubprocessGenerator ( self.batch_func, (samples, index_host.create_cli(), ct_samples, ct_index_host.create_cli() if ct_index_host is not None else None), start_now=False ) \\\n                               for i in range(self.generators_count) ]\n                               \n            SubprocessGenerator.start_in_parallel( self.generators )\n\n        self.generator_counter = -1\n        \n        self.initialized = True\n        \n    #overridable\n    def is_initialized(self):\n        return self.initialized\n        \n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        if not self.initialized:\n            return []\n            \n        self.generator_counter += 1\n        generator = self.generators[self.generator_counter % len(self.generators) ]\n        return next(generator)\n\n    def batch_func(self, param ):\n        samples, index_host, ct_samples, ct_index_host = param\n \n        bs = self.batch_size\n        while True:\n            batches = None\n\n            indexes = index_host.multi_get(bs)\n            ct_indexes = ct_index_host.multi_get(bs) if ct_samples is not None else None\n\n            t = time.time()\n            for n_batch in range(bs):\n                sample_idx = indexes[n_batch]\n                sample = samples[sample_idx]\n\n                ct_sample = None\n                if ct_samples is not None:\n                    ct_sample = ct_samples[ct_indexes[n_batch]]\n\n                try:\n                    x, = SampleProcessor.process ([sample], self.sample_process_options, self.output_sample_types, self.debug, ct_sample=ct_sample)\n                except:\n                    raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample.filename, traceback.format_exc() ) )\n\n                if batches is None:\n                    batches = [ [] for _ in range(len(x)) ]\n\n                for i in range(len(x)):\n                    batches[i].append ( x[i] )\n\n            yield [ np.array(batch) for batch in batches]\n", "samplelib/SampleGeneratorFaceCelebAMaskHQ.py": "import multiprocessing\nimport pickle\nimport time\nimport traceback\nfrom enum import IntEnum\n\nimport cv2\nimport numpy as np\n\nfrom core import imagelib, mplib, pathex\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.joblib import SubprocessGenerator, ThisThreadGenerator\nfrom facelib import LandmarksProcessor\nfrom samplelib import SampleGeneratorBase\n\n\nclass MaskType(IntEnum):\n    none   = 0,\n    cloth  = 1,\n    ear_r  = 2,\n    eye_g  = 3,\n    hair   = 4,\n    hat    = 5,\n    l_brow = 6,\n    l_ear  = 7,\n    l_eye  = 8,\n    l_lip  = 9,\n    mouth  = 10,\n    neck   = 11,\n    neck_l = 12,\n    nose   = 13,\n    r_brow = 14,\n    r_ear  = 15,\n    r_eye  = 16,\n    skin   = 17,\n    u_lip  = 18\n\n\n\nMaskType_to_name = {\n    int(MaskType.none  ) : 'none',\n    int(MaskType.cloth ) : 'cloth',\n    int(MaskType.ear_r ) : 'ear_r',\n    int(MaskType.eye_g ) : 'eye_g',\n    int(MaskType.hair  ) : 'hair',\n    int(MaskType.hat   ) : 'hat',\n    int(MaskType.l_brow) : 'l_brow',\n    int(MaskType.l_ear ) : 'l_ear',\n    int(MaskType.l_eye ) : 'l_eye',\n    int(MaskType.l_lip ) : 'l_lip',\n    int(MaskType.mouth ) : 'mouth',\n    int(MaskType.neck  ) : 'neck',\n    int(MaskType.neck_l) : 'neck_l',\n    int(MaskType.nose  ) : 'nose',\n    int(MaskType.r_brow) : 'r_brow',\n    int(MaskType.r_ear ) : 'r_ear',\n    int(MaskType.r_eye ) : 'r_eye',\n    int(MaskType.skin  ) : 'skin',\n    int(MaskType.u_lip ) : 'u_lip',\n}\n\nMaskType_from_name = { MaskType_to_name[k] : k for k in MaskType_to_name.keys() }\n\nclass SampleGeneratorFaceCelebAMaskHQ(SampleGeneratorBase):\n    def __init__ (self, root_path, debug=False, batch_size=1, resolution=256,\n                        generators_count=4, data_format=\"NHWC\",\n                        **kwargs):\n\n        super().__init__(debug, batch_size)\n        self.initialized = False\n\n        dataset_path = root_path / 'CelebAMask-HQ'\n        if not dataset_path.exists():\n            raise ValueError(f'Unable to find {dataset_path}')\n\n        images_path = dataset_path /'CelebA-HQ-img'\n        if not images_path.exists():\n            raise ValueError(f'Unable to find {images_path}')\n\n        masks_path = dataset_path / 'CelebAMask-HQ-mask-anno'\n        if not masks_path.exists():\n            raise ValueError(f'Unable to find {masks_path}')\n\n\n        if self.debug:\n            self.generators_count = 1\n        else:\n            self.generators_count = max(1, generators_count)\n\n        source_images_paths = pathex.get_image_paths(images_path, return_Path_class=True)\n        source_images_paths_len = len(source_images_paths)\n        mask_images_paths = pathex.get_image_paths(masks_path, subdirs=True, return_Path_class=True)\n\n        if source_images_paths_len == 0 or len(mask_images_paths) == 0:\n            raise ValueError('No training data provided.')\n\n        mask_file_id_hash = {}\n\n        for filepath in io.progress_bar_generator(mask_images_paths, \"Loading\"):\n            stem = filepath.stem\n\n            file_id, mask_type = stem.split('_', 1)\n            file_id = int(file_id)\n\n            if file_id not in mask_file_id_hash:\n                mask_file_id_hash[file_id] = {}\n\n            mask_file_id_hash[file_id][ MaskType_from_name[mask_type] ] = str(filepath.relative_to(masks_path))\n\n        source_file_id_set = set()\n\n        for filepath in source_images_paths:\n            stem = filepath.stem\n\n            file_id = int(stem)\n            source_file_id_set.update ( {file_id} )\n\n        for k in mask_file_id_hash.keys():\n            if k not in source_file_id_set:\n                io.log_err (f\"Corrupted dataset: {k} not in {images_path}\")\n\n\n\n        if self.debug:\n            self.generators = [ThisThreadGenerator ( self.batch_func, (images_path, masks_path, mask_file_id_hash, data_format) )]\n        else:\n            self.generators = [SubprocessGenerator ( self.batch_func, (images_path, masks_path, mask_file_id_hash, data_format), start_now=False ) \\\n                               for i in range(self.generators_count) ]\n\n            SubprocessGenerator.start_in_parallel( self.generators )\n\n        self.generator_counter = -1\n\n        self.initialized = True\n\n    #overridable\n    def is_initialized(self):\n        return self.initialized\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.generator_counter += 1\n        generator = self.generators[self.generator_counter % len(self.generators) ]\n        return next(generator)\n\n    def batch_func(self, param ):\n        images_path, masks_path, mask_file_id_hash, data_format = param\n\n        file_ids = list(mask_file_id_hash.keys())\n\n        shuffle_file_ids = []\n\n        resolution = 256\n        random_flip = True\n        rotation_range=[-15,15]\n        scale_range=[-0.10, 0.95]\n        tx_range=[-0.3, 0.3]\n        ty_range=[-0.3, 0.3]\n\n        random_bilinear_resize = (25,75)\n        motion_blur = (25, 5)\n        gaussian_blur = (25, 5)\n\n        bs = self.batch_size\n        while True:\n            batches = None\n\n            n_batch = 0\n            while n_batch < bs:\n                try:\n                    if len(shuffle_file_ids) == 0:\n                        shuffle_file_ids = file_ids.copy()\n                        np.random.shuffle(shuffle_file_ids)\n\n                    file_id = shuffle_file_ids.pop()\n                    masks = mask_file_id_hash[file_id]\n                    image_path = images_path / f'{file_id}.jpg'\n\n                    skin_path = masks.get(MaskType.skin, None)\n                    hair_path = masks.get(MaskType.hair, None)\n                    hat_path = masks.get(MaskType.hat, None)\n                    #neck_path = masks.get(MaskType.neck, None)\n\n                    img = cv2_imread(image_path).astype(np.float32) / 255.0\n                    mask = cv2_imread(masks_path / skin_path)[...,0:1].astype(np.float32) / 255.0\n\n                    if hair_path is not None:\n                        hair_path = masks_path / hair_path\n                        if hair_path.exists():\n                            hair = cv2_imread(hair_path)[...,0:1].astype(np.float32) / 255.0\n                            mask *= (1-hair)\n\n                    if hat_path is not None:\n                        hat_path = masks_path / hat_path\n                        if hat_path.exists():\n                            hat = cv2_imread(hat_path)[...,0:1].astype(np.float32) / 255.0\n                            mask *= (1-hat)\n                    \n                    #if neck_path is not None:\n                    #    neck_path = masks_path / neck_path\n                    #    if neck_path.exists():\n                    #        neck = cv2_imread(neck_path)[...,0:1].astype(np.float32) / 255.0\n                    #        mask = np.clip(mask+neck, 0, 1)\n                            \n                    warp_params = imagelib.gen_warp_params(resolution, random_flip, rotation_range=rotation_range, scale_range=scale_range, tx_range=tx_range, ty_range=ty_range )\n  \n                    img = cv2.resize( img, (resolution,resolution), cv2.INTER_LANCZOS4 )\n                    h, s, v = cv2.split(cv2.cvtColor(img, cv2.COLOR_BGR2HSV))\n                    h = ( h + np.random.randint(360) ) % 360\n                    s = np.clip ( s + np.random.random()-0.5, 0, 1 )\n                    v = np.clip ( v + np.random.random()/2-0.25, 0, 1 )                    \n                    img = np.clip( cv2.cvtColor(cv2.merge([h, s, v]), cv2.COLOR_HSV2BGR) , 0, 1 )\n                            \n                    if motion_blur is not None:\n                        chance, mb_max_size = motion_blur\n                        chance = np.clip(chance, 0, 100)\n\n                        mblur_rnd_chance = np.random.randint(100)\n                        mblur_rnd_kernel = np.random.randint(mb_max_size)+1\n                        mblur_rnd_deg    = np.random.randint(360)\n\n                        if mblur_rnd_chance < chance:\n                            img = imagelib.LinearMotionBlur (img, mblur_rnd_kernel, mblur_rnd_deg )\n\n                    img = imagelib.warp_by_params (warp_params, img,  can_warp=True, can_transform=True, can_flip=True, border_replicate=False, cv2_inter=cv2.INTER_LANCZOS4)\n                    \n                    if gaussian_blur is not None:\n                        chance, kernel_max_size = gaussian_blur\n                        chance = np.clip(chance, 0, 100)\n\n                        gblur_rnd_chance = np.random.randint(100)\n                        gblur_rnd_kernel = np.random.randint(kernel_max_size)*2+1\n\n                        if gblur_rnd_chance < chance:\n                            img = cv2.GaussianBlur(img, (gblur_rnd_kernel,) *2 , 0)\n                            \n                    if random_bilinear_resize is not None:\n                        chance, max_size_per = random_bilinear_resize\n                        chance = np.clip(chance, 0, 100)                        \n                        pick_chance = np.random.randint(100)                        \n                        resize_to = resolution - int( np.random.rand()* int(resolution*(max_size_per/100.0)) )                        \n                        img = cv2.resize (img, (resize_to,resize_to), cv2.INTER_LINEAR )\n                        img = cv2.resize (img, (resolution,resolution), cv2.INTER_LINEAR )\n                        \n                            \n                    mask = cv2.resize( mask, (resolution,resolution), cv2.INTER_LANCZOS4 )[...,None]\n                    mask = imagelib.warp_by_params (warp_params, mask, can_warp=True, can_transform=True, can_flip=True, border_replicate=False, cv2_inter=cv2.INTER_LANCZOS4)\n                    mask[mask < 0.5] = 0.0\n                    mask[mask >= 0.5] = 1.0\n                    mask = np.clip(mask, 0, 1)\n\n                    if data_format == \"NCHW\":\n                        img = np.transpose(img, (2,0,1) )\n                        mask = np.transpose(mask, (2,0,1) )\n                        \n                    if batches is None:\n                        batches = [ [], [] ]\n                    \n                    batches[0].append ( img )\n                    batches[1].append ( mask )\n\n                    n_batch += 1\n                except:\n                    io.log_err ( traceback.format_exc() )\n\n            yield [ np.array(batch) for batch in batches]\n", "samplelib/PackedFaceset.py": "import pickle\nimport shutil\nimport struct\nfrom pathlib import Path\n\nimport samplelib.SampleLoader\nfrom core.interact import interact as io\nfrom samplelib import Sample\nfrom core import pathex\n\npacked_faceset_filename = 'faceset.pak'\n\nclass PackedFaceset():\n    VERSION = 1\n\n    @staticmethod\n    def pack(samples_path):\n        samples_dat_path = samples_path / packed_faceset_filename\n\n        if samples_dat_path.exists():\n            io.log_info(f\"{samples_dat_path} : file already exists !\")\n            io.input(\"Press enter to continue and overwrite.\")\n\n        as_person_faceset = False\n        dir_names = pathex.get_all_dir_names(samples_path)\n        if len(dir_names) != 0:\n            as_person_faceset = io.input_bool(f\"{len(dir_names)} subdirectories found, process as person faceset?\", True)\n\n        if as_person_faceset:\n            image_paths = []\n\n            for dir_name in dir_names:\n                image_paths += pathex.get_image_paths(samples_path / dir_name)\n        else:\n            image_paths = pathex.get_image_paths(samples_path)\n\n        samples = samplelib.SampleLoader.load_face_samples(image_paths)\n        samples_len = len(samples)\n\n        samples_configs = []\n        for sample in io.progress_bar_generator (samples, \"Processing\"):\n            sample_filepath = Path(sample.filename)\n            sample.filename = sample_filepath.name\n\n            if as_person_faceset:\n                sample.person_name = sample_filepath.parent.name\n            samples_configs.append ( sample.get_config() )\n        samples_bytes = pickle.dumps(samples_configs, 4)\n\n        of = open(samples_dat_path, \"wb\")\n        of.write ( struct.pack (\"Q\", PackedFaceset.VERSION ) )\n        of.write ( struct.pack (\"Q\", len(samples_bytes) ) )\n        of.write ( samples_bytes )\n\n        del samples_bytes   #just free mem\n        del samples_configs\n\n        sample_data_table_offset = of.tell()\n        of.write ( bytes( 8*(samples_len+1) ) ) #sample data offset table\n\n        data_start_offset = of.tell()\n        offsets = []\n\n        for sample in io.progress_bar_generator(samples, \"Packing\"):\n            try:\n                if sample.person_name is not None:\n                    sample_path = samples_path / sample.person_name / sample.filename\n                else:\n                    sample_path = samples_path / sample.filename\n\n\n                with open(sample_path, \"rb\") as f:\n                   b = f.read()\n\n                offsets.append ( of.tell() - data_start_offset )\n                of.write(b)\n            except:\n                raise Exception(f\"error while processing sample {sample_path}\")\n\n        offsets.append ( of.tell() )\n\n        of.seek(sample_data_table_offset, 0)\n        for offset in offsets:\n            of.write ( struct.pack(\"Q\", offset) )\n        of.seek(0,2)\n        of.close()\n        \n        if io.input_bool(f\"Delete original files?\", True):\n            for filename in io.progress_bar_generator(image_paths, \"Deleting files\"):\n                Path(filename).unlink()\n\n            if as_person_faceset:\n                for dir_name in io.progress_bar_generator(dir_names, \"Deleting dirs\"):\n                    dir_path = samples_path / dir_name\n                    try:\n                        shutil.rmtree(dir_path)\n                    except:\n                        io.log_info (f\"unable to remove: {dir_path} \")\n\n    @staticmethod\n    def unpack(samples_path):\n        samples_dat_path = samples_path / packed_faceset_filename\n        if not samples_dat_path.exists():\n            io.log_info(f\"{samples_dat_path} : file not found.\")\n            return\n\n        samples = PackedFaceset.load(samples_path)\n\n        for sample in io.progress_bar_generator(samples, \"Unpacking\"):\n            person_name = sample.person_name\n            if person_name is not None:\n                person_path = samples_path / person_name\n                person_path.mkdir(parents=True, exist_ok=True)\n\n                target_filepath = person_path / sample.filename\n            else:\n                target_filepath = samples_path / sample.filename\n\n            with open(target_filepath, \"wb\") as f:\n                f.write( sample.read_raw_file() )\n\n        samples_dat_path.unlink()\n\n    @staticmethod\n    def path_contains(samples_path):\n        samples_dat_path = samples_path / packed_faceset_filename\n        return samples_dat_path.exists()\n    \n    @staticmethod\n    def load(samples_path):\n        samples_dat_path = samples_path / packed_faceset_filename\n        if not samples_dat_path.exists():\n            return None\n\n        f = open(samples_dat_path, \"rb\")\n        version, = struct.unpack(\"Q\", f.read(8) )\n        if version != PackedFaceset.VERSION:\n            raise NotImplementedError\n\n        sizeof_samples_bytes, = struct.unpack(\"Q\", f.read(8) )\n\n        samples_configs = pickle.loads ( f.read(sizeof_samples_bytes) )\n        samples = []\n        for sample_config in samples_configs:\n            sample_config = pickle.loads(pickle.dumps (sample_config))\n            samples.append ( Sample (**sample_config) )\n\n        offsets = [ struct.unpack(\"Q\", f.read(8) )[0] for _ in range(len(samples)+1) ]\n        data_start_offset = f.tell()\n        f.close()\n\n        for i, sample in enumerate(samples):\n            start_offset, end_offset = offsets[i], offsets[i+1]\n            sample.set_filename_offset_size( str(samples_dat_path), data_start_offset+start_offset, end_offset-start_offset )\n\n        return samples\n", "samplelib/SampleLoader.py": "import multiprocessing\nimport operator\nimport pickle\nimport traceback\nfrom pathlib import Path\n\nimport samplelib.PackedFaceset\nfrom core import pathex\nfrom core.mplib import MPSharedList\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor\nfrom DFLIMG import *\nfrom facelib import FaceType, LandmarksProcessor\n\nfrom .Sample import Sample, SampleType\n\n\nclass SampleLoader:\n    samples_cache = dict()\n    @staticmethod\n    def get_person_id_max_count(samples_path):\n        samples = None\n        try:\n            samples = samplelib.PackedFaceset.load(samples_path)\n        except:\n            io.log_err(f\"Error occured while loading samplelib.PackedFaceset.load {str(samples_path)}, {traceback.format_exc()}\")\n\n        if samples is None:\n            raise ValueError(\"packed faceset not found.\")\n        persons_name_idxs = {}\n        for sample in samples:\n            persons_name_idxs[sample.person_name] = 0\n        return len(list(persons_name_idxs.keys()))\n\n    @staticmethod\n    def load(sample_type, samples_path, subdirs=False):\n        \"\"\"\n        Return MPSharedList of samples\n        \"\"\"\n        samples_cache = SampleLoader.samples_cache\n\n        if str(samples_path) not in samples_cache.keys():\n            samples_cache[str(samples_path)] = [None]*SampleType.QTY\n\n        samples = samples_cache[str(samples_path)]\n\n        if            sample_type == SampleType.IMAGE:\n            if  samples[sample_type] is None:\n                samples[sample_type] = [ Sample(filename=filename) for filename in io.progress_bar_generator( pathex.get_image_paths(samples_path, subdirs=subdirs), \"Loading\") ]\n\n        elif          sample_type == SampleType.FACE:\n            if  samples[sample_type] is None:\n                try:\n                    result = samplelib.PackedFaceset.load(samples_path)\n                except:\n                    io.log_err(f\"Error occured while loading samplelib.PackedFaceset.load {str(samples_dat_path)}, {traceback.format_exc()}\")\n\n                if result is not None:\n                    io.log_info (f\"Loaded {len(result)} packed faces from {samples_path}\")\n\n                if result is None:\n                    result = SampleLoader.load_face_samples( pathex.get_image_paths(samples_path, subdirs=subdirs) )\n\n                samples[sample_type] = MPSharedList(result)\n        elif          sample_type == SampleType.FACE_TEMPORAL_SORTED:\n                result = SampleLoader.load (SampleType.FACE, samples_path)\n                result = SampleLoader.upgradeToFaceTemporalSortedSamples(result)\n                samples[sample_type] = MPSharedList(result)\n\n        return samples[sample_type]\n\n    @staticmethod\n    def load_face_samples ( image_paths):\n        result = FaceSamplesLoaderSubprocessor(image_paths).run()\n        sample_list = []\n\n        for filename, data in result:\n            if data is None:\n                continue\n            ( face_type,\n              shape,\n              landmarks,\n              seg_ie_polys,\n              xseg_mask_compressed,\n              eyebrows_expand_mod,\n              source_filename ) = data\n              \n            sample_list.append( Sample(filename=filename,\n                                        sample_type=SampleType.FACE,\n                                        face_type=FaceType.fromString (face_type),\n                                        shape=shape,\n                                        landmarks=landmarks,\n                                        seg_ie_polys=seg_ie_polys,\n                                        xseg_mask_compressed=xseg_mask_compressed,\n                                        eyebrows_expand_mod=eyebrows_expand_mod,\n                                        source_filename=source_filename,\n                                    ))\n        return sample_list\n\n    @staticmethod\n    def upgradeToFaceTemporalSortedSamples( samples ):\n        new_s = [ (s, s.source_filename) for s in samples]\n        new_s = sorted(new_s, key=operator.itemgetter(1))\n\n        return [ s[0] for s in new_s]\n\n\nclass FaceSamplesLoaderSubprocessor(Subprocessor):\n    #override\n    def __init__(self, image_paths ):\n        self.image_paths = image_paths\n        self.image_paths_len = len(image_paths)\n        self.idxs = [*range(self.image_paths_len)]\n        self.result = [None]*self.image_paths_len\n        super().__init__('FaceSamplesLoader', FaceSamplesLoaderSubprocessor.Cli, 60)\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"Loading samples\", len (self.image_paths))\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def process_info_generator(self):\n        for i in range(min(multiprocessing.cpu_count(), 8) ):\n            yield 'CPU%d' % (i), {}, {}\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.idxs) > 0:\n            idx = self.idxs.pop(0)\n            return idx, self.image_paths[idx]\n\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.idxs.insert(0, data[0])\n\n    #override\n    def on_result (self, host_dict, data, result):\n        idx, dflimg = result\n        self.result[idx] = (self.image_paths[idx], dflimg)\n        io.progress_bar_inc(1)\n\n    #override\n    def get_result(self):\n        return self.result\n\n    class Cli(Subprocessor.Cli):\n        #override\n        def process_data(self, data):\n            idx, filename = data\n            dflimg = DFLIMG.load (Path(filename))\n\n            if dflimg is None or not dflimg.has_data():\n                self.log_err (f\"FaceSamplesLoader: {filename} is not a dfl image file.\")\n                data = None\n            else:\n                data = (dflimg.get_face_type(),\n                        dflimg.get_shape(),\n                        dflimg.get_landmarks(),\n                        dflimg.get_seg_ie_polys(),\n                        dflimg.get_xseg_mask_compressed(),\n                        dflimg.get_eyebrows_expand_mod(),\n                        dflimg.get_source_filename() )\n\n            return idx, data\n\n        #override\n        def get_data_name (self, data):\n            #return string identificator of your data\n            return data[1]\n", "samplelib/SampleGeneratorBase.py": "from pathlib import Path\n\n'''\nYou can implement your own SampleGenerator\n'''\nclass SampleGeneratorBase(object):\n\n\n    def __init__ (self, debug=False, batch_size=1):\n        self.debug = debug\n        self.batch_size = 1 if self.debug else batch_size\n        self.last_generation = None\n        self.active = True\n\n    def set_active(self, is_active):\n        self.active = is_active\n\n    def generate_next(self):\n        if not self.active and self.last_generation is not None:\n            return self.last_generation\n        self.last_generation = next(self)\n        return self.last_generation\n\n    #overridable\n    def __iter__(self):\n        #implement your own iterator\n        return self\n\n    def __next__(self):\n        #implement your own iterator\n        return None\n    \n    #overridable\n    def is_initialized(self):\n        return True", "samplelib/SampleGeneratorImage.py": "import traceback\n\nimport cv2\nimport numpy as np\n\nfrom core.joblib import SubprocessGenerator, ThisThreadGenerator\nfrom samplelib import (SampleGeneratorBase, SampleLoader, SampleProcessor,\n                       SampleType)\n\n\nclass SampleGeneratorImage(SampleGeneratorBase):\n    def __init__ (self, samples_path, debug, batch_size, sample_process_options=SampleProcessor.Options(), output_sample_types=[], raise_on_no_data=True, **kwargs):\n        super().__init__(debug, batch_size)\n        self.initialized = False\n        self.sample_process_options = sample_process_options\n        self.output_sample_types = output_sample_types\n\n        samples = SampleLoader.load (SampleType.IMAGE, samples_path)\n        \n        if len(samples) == 0:\n            if raise_on_no_data:\n                raise ValueError('No training data provided.')\n            return\n        \n        self.generators = [ThisThreadGenerator ( self.batch_func, samples )] if self.debug else \\\n                          [SubprocessGenerator ( self.batch_func, samples )]\n\n        self.generator_counter = -1\n        self.initialized = True\n        \n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.generator_counter += 1\n        generator = self.generators[self.generator_counter % len(self.generators) ]\n        return next(generator)\n\n    def batch_func(self, samples):\n        samples_len = len(samples)\n        \n\n        idxs = [ *range(samples_len) ]\n        shuffle_idxs = []\n\n        while True:\n\n            batches = None\n            for n_batch in range(self.batch_size):\n\n                if len(shuffle_idxs) == 0:\n                    shuffle_idxs = idxs.copy()\n                    np.random.shuffle (shuffle_idxs)\n\n                idx = shuffle_idxs.pop()\n                sample = samples[idx]\n                \n                x, = SampleProcessor.process ([sample], self.sample_process_options, self.output_sample_types, self.debug)\n\n                if batches is None:\n                    batches = [ [] for _ in range(len(x)) ]\n\n                for i in range(len(x)):\n                    batches[i].append ( x[i] )\n\n            yield [ np.array(batch) for batch in batches]\n", "samplelib/SampleGeneratorImageTemporal.py": "import traceback\n\nimport cv2\nimport numpy as np\n\nfrom core.joblib import SubprocessGenerator, ThisThreadGenerator\nfrom samplelib import (SampleGeneratorBase, SampleLoader, SampleProcessor,\n                       SampleType)\n\n\n'''\noutput_sample_types = [\n                        [SampleProcessor.TypeFlags, size, (optional)random_sub_size] ,\n                        ...\n                      ]\n'''\nclass SampleGeneratorImageTemporal(SampleGeneratorBase):\n    def __init__ (self, samples_path, debug, batch_size, temporal_image_count, sample_process_options=SampleProcessor.Options(), output_sample_types=[], **kwargs):\n        super().__init__(debug, batch_size)\n\n        self.temporal_image_count = temporal_image_count\n        self.sample_process_options = sample_process_options\n        self.output_sample_types = output_sample_types\n\n        self.samples = SampleLoader.load (SampleType.IMAGE, samples_path)\n\n        self.generator_samples = [ self.samples ]\n        self.generators = [iter_utils.ThisThreadGenerator ( self.batch_func, 0 )] if self.debug else \\\n                          [iter_utils.SubprocessGenerator ( self.batch_func, 0 )]\n\n        self.generator_counter = -1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.generator_counter += 1\n        generator = self.generators[self.generator_counter % len(self.generators) ]\n        return next(generator)\n\n    def batch_func(self, generator_id):\n        samples = self.generator_samples[generator_id]\n        samples_len = len(samples)\n        if samples_len == 0:\n            raise ValueError('No training data provided.')\n\n        mult_max = 4\n        samples_sub_len = samples_len - ( (self.temporal_image_count)*mult_max - (mult_max-1)  )\n\n        if samples_sub_len <= 0:\n            raise ValueError('Not enough samples to fit temporal line.')\n\n        shuffle_idxs = []\n\n        while True:\n\n            batches = None\n            for n_batch in range(self.batch_size):\n\n                if len(shuffle_idxs) == 0:\n                    shuffle_idxs = [ *range(samples_sub_len) ]\n                    np.random.shuffle (shuffle_idxs)\n\n                idx = shuffle_idxs.pop()\n\n                temporal_samples = []\n                mult = np.random.randint(mult_max)+1\n                for i in range( self.temporal_image_count ):\n                    sample = samples[ idx+i*mult ]\n                    try:\n                        temporal_samples += SampleProcessor.process ([sample], self.sample_process_options, self.output_sample_types, self.debug)[0]\n                    except:\n                        raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample.filename, traceback.format_exc() ) )\n\n                if batches is None:\n                    batches = [ [] for _ in range(len(temporal_samples)) ]\n\n                for i in range(len(temporal_samples)):\n                    batches[i].append ( temporal_samples[i] )\n\n            yield [ np.array(batch) for batch in batches]\n", "samplelib/SampleGeneratorFaceTemporal.py": "import multiprocessing\nimport pickle\nimport time\nimport traceback\n\nimport cv2\nimport numpy as np\n\nfrom core import mplib\nfrom core.joblib import SubprocessGenerator, ThisThreadGenerator\nfrom facelib import LandmarksProcessor\nfrom samplelib import (SampleGeneratorBase, SampleLoader, SampleProcessor,\n                       SampleType)\n\n\nclass SampleGeneratorFaceTemporal(SampleGeneratorBase):\n    def __init__ (self, samples_path, debug, batch_size,\n                        temporal_image_count=3,\n                        sample_process_options=SampleProcessor.Options(),\n                        output_sample_types=[],\n                        generators_count=2,\n                        **kwargs):\n        super().__init__(debug, batch_size)\n\n        self.temporal_image_count = temporal_image_count\n        self.sample_process_options = sample_process_options\n        self.output_sample_types = output_sample_types\n\n        if self.debug:\n            self.generators_count = 1\n        else:\n            self.generators_count = generators_count\n\n        samples = SampleLoader.load (SampleType.FACE_TEMPORAL_SORTED, samples_path)\n        samples_len = len(samples)\n        if samples_len == 0:\n            raise ValueError('No training data provided.')\n\n        mult_max = 1\n        l = samples_len - ( (self.temporal_image_count)*mult_max - (mult_max-1)  )\n        index_host = mplib.IndexHost(l+1)\n\n        pickled_samples = pickle.dumps(samples, 4)\n        if self.debug:\n            self.generators = [ThisThreadGenerator ( self.batch_func, (pickled_samples, index_host.create_cli(),) )]\n        else:\n            self.generators = [SubprocessGenerator ( self.batch_func, (pickled_samples, index_host.create_cli(),) ) for i in range(self.generators_count) ]\n\n        self.generator_counter = -1\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.generator_counter += 1\n        generator = self.generators[self.generator_counter % len(self.generators) ]\n        return next(generator)\n\n    def batch_func(self, param):\n        mult_max = 1\n        bs = self.batch_size\n        pickled_samples, index_host = param\n        samples = pickle.loads(pickled_samples)\n\n        while True:\n            batches = None\n\n            indexes = index_host.multi_get(bs)\n\n            for n_batch in range(self.batch_size):\n                idx = indexes[n_batch]\n\n                temporal_samples = []\n                mult = np.random.randint(mult_max)+1\n                for i in range( self.temporal_image_count ):\n                    sample = samples[ idx+i*mult ]\n                    try:\n                        temporal_samples += SampleProcessor.process ([sample], self.sample_process_options, self.output_sample_types, self.debug)[0]\n                    except:\n                        raise Exception (\"Exception occured in sample %s. Error: %s\" % (sample.filename, traceback.format_exc() ) )\n\n                if batches is None:\n                    batches = [ [] for _ in range(len(temporal_samples)) ]\n\n                for i in range(len(temporal_samples)):\n                    batches[i].append ( temporal_samples[i] )\n\n            yield [ np.array(batch) for batch in batches]\n", "samplelib/SampleGeneratorFaceXSeg.py": "import multiprocessing\nimport pickle\nimport time\nimport traceback\nfrom enum import IntEnum\n\nimport cv2\nimport numpy as np\nfrom pathlib import Path\nfrom core import imagelib, mplib, pathex\nfrom core.imagelib import sd\nfrom core.cv2ex import *\nfrom core.interact import interact as io\nfrom core.joblib import Subprocessor, SubprocessGenerator, ThisThreadGenerator\nfrom facelib import LandmarksProcessor\nfrom samplelib import (SampleGeneratorBase, SampleLoader, SampleProcessor, SampleType)\n\nclass SampleGeneratorFaceXSeg(SampleGeneratorBase):\n    def __init__ (self, paths, debug=False, batch_size=1, resolution=256, face_type=None,\n                        generators_count=4, data_format=\"NHWC\",\n                        **kwargs):\n\n        super().__init__(debug, batch_size)\n        self.initialized = False\n\n        samples = sum([ SampleLoader.load (SampleType.FACE, path) for path in paths ]  )\n        seg_sample_idxs = SegmentedSampleFilterSubprocessor(samples).run()\n\n        if len(seg_sample_idxs) == 0:\n            seg_sample_idxs = SegmentedSampleFilterSubprocessor(samples, count_xseg_mask=True).run()\n            if len(seg_sample_idxs) == 0:\n                raise Exception(f\"No segmented faces found.\")\n            else:\n                io.log_info(f\"Using {len(seg_sample_idxs)} xseg labeled samples.\")\n        else:\n            io.log_info(f\"Using {len(seg_sample_idxs)} segmented samples.\")\n\n        if self.debug:\n            self.generators_count = 1\n        else:\n            self.generators_count = max(1, generators_count)\n\n        args = (samples, seg_sample_idxs, resolution, face_type, data_format)\n        if self.debug:\n            self.generators = [ThisThreadGenerator ( self.batch_func, args )]\n        else:\n            self.generators = [SubprocessGenerator ( self.batch_func, args, start_now=False ) for i in range(self.generators_count) ]\n\n            SubprocessGenerator.start_in_parallel( self.generators )\n\n        self.generator_counter = -1\n\n        self.initialized = True\n\n    #overridable\n    def is_initialized(self):\n        return self.initialized\n\n    def __iter__(self):\n        return self\n\n    def __next__(self):\n        self.generator_counter += 1\n        generator = self.generators[self.generator_counter % len(self.generators) ]\n        return next(generator)\n\n    def batch_func(self, param ):\n        samples, seg_sample_idxs, resolution, face_type, data_format = param\n\n        shuffle_idxs = []\n        bg_shuffle_idxs = []\n\n        random_flip = True\n        rotation_range=[-10,10]\n        scale_range=[-0.05, 0.05]\n        tx_range=[-0.05, 0.05]\n        ty_range=[-0.05, 0.05]\n\n        random_bilinear_resize_chance, random_bilinear_resize_max_size_per = 25,75\n        sharpen_chance, sharpen_kernel_max_size = 25, 5\n        motion_blur_chance, motion_blur_mb_max_size = 25, 5\n        gaussian_blur_chance, gaussian_blur_kernel_max_size = 25, 5\n        random_jpeg_compress_chance = 25\n\n        def gen_img_mask(sample):\n            img = sample.load_bgr()\n            h,w,c = img.shape\n\n            if sample.seg_ie_polys.has_polys():\n                mask = np.zeros ((h,w,1), dtype=np.float32)\n                sample.seg_ie_polys.overlay_mask(mask)\n            elif sample.has_xseg_mask():\n                mask = sample.get_xseg_mask()\n                mask[mask < 0.5] = 0.0\n                mask[mask >= 0.5] = 1.0\n            else:\n                raise Exception(f'no mask in sample {sample.filename}')\n\n            if face_type == sample.face_type:\n                if w != resolution:\n                    img = cv2.resize( img, (resolution, resolution), interpolation=cv2.INTER_LANCZOS4 )\n                    mask = cv2.resize( mask, (resolution, resolution), interpolation=cv2.INTER_LANCZOS4 )\n            else:\n                mat = LandmarksProcessor.get_transform_mat (sample.landmarks, resolution, face_type)\n                img  = cv2.warpAffine( img,  mat, (resolution,resolution), borderMode=cv2.BORDER_CONSTANT, flags=cv2.INTER_LANCZOS4 )\n                mask = cv2.warpAffine( mask, mat, (resolution,resolution), borderMode=cv2.BORDER_CONSTANT, flags=cv2.INTER_LANCZOS4 )\n\n            if len(mask.shape) == 2:\n                mask = mask[...,None]\n            return img, mask\n\n        bs = self.batch_size\n        while True:\n            batches = [ [], [] ]\n\n            n_batch = 0\n            while n_batch < bs:\n                try:\n                    if len(shuffle_idxs) == 0:\n                        shuffle_idxs = seg_sample_idxs.copy()\n                        np.random.shuffle(shuffle_idxs)\n                    sample = samples[shuffle_idxs.pop()]\n                    img, mask = gen_img_mask(sample)\n\n                    if np.random.randint(2) == 0:\n                        if len(bg_shuffle_idxs) == 0:\n                            bg_shuffle_idxs = seg_sample_idxs.copy()\n                            np.random.shuffle(bg_shuffle_idxs)\n                        bg_sample = samples[bg_shuffle_idxs.pop()]\n\n                        bg_img, bg_mask = gen_img_mask(bg_sample)\n\n                        bg_wp   = imagelib.gen_warp_params(resolution, True, rotation_range=[-180,180], scale_range=[-0.10, 0.10], tx_range=[-0.10, 0.10], ty_range=[-0.10, 0.10] )\n                        bg_img  = imagelib.warp_by_params (bg_wp, bg_img,  can_warp=False, can_transform=True, can_flip=True, border_replicate=True)\n                        bg_mask = imagelib.warp_by_params (bg_wp, bg_mask, can_warp=False, can_transform=True, can_flip=True, border_replicate=False)\n                        bg_img = bg_img*(1-bg_mask)\n                        if np.random.randint(2) == 0:\n                            bg_img = imagelib.apply_random_hsv_shift(bg_img)\n                        else:\n                            bg_img = imagelib.apply_random_rgb_levels(bg_img)\n\n                        c_mask = 1.0 - (1-bg_mask) * (1-mask)\n                        rnd = 0.15 + np.random.uniform()*0.85\n                        img = img*(c_mask) + img*(1-c_mask)*rnd + bg_img*(1-c_mask)*(1-rnd)\n\n                    warp_params = imagelib.gen_warp_params(resolution, random_flip, rotation_range=rotation_range, scale_range=scale_range, tx_range=tx_range, ty_range=ty_range )\n                    img   = imagelib.warp_by_params (warp_params, img,  can_warp=True, can_transform=True, can_flip=True, border_replicate=True)\n                    mask  = imagelib.warp_by_params (warp_params, mask, can_warp=True, can_transform=True, can_flip=True, border_replicate=False)\n\n                    img = np.clip(img.astype(np.float32), 0, 1)\n                    mask[mask < 0.5] = 0.0\n                    mask[mask >= 0.5] = 1.0\n                    mask = np.clip(mask, 0, 1)\n                    \n                    if np.random.randint(2) == 0:\n                        # random face flare\n                        krn = np.random.randint( resolution//4, resolution )\n                        krn = krn - krn % 2 + 1\n                        img = img + cv2.GaussianBlur(img*mask, (krn,krn), 0)\n\n                    if np.random.randint(2) == 0:\n                        # random bg flare\n                        krn = np.random.randint( resolution//4, resolution )\n                        krn = krn - krn % 2 + 1\n                        img = img + cv2.GaussianBlur(img*(1-mask), (krn,krn), 0)\n\n                    if np.random.randint(2) == 0:\n                        img = imagelib.apply_random_hsv_shift(img, mask=sd.random_circle_faded ([resolution,resolution]))\n                    else:\n                        img = imagelib.apply_random_rgb_levels(img, mask=sd.random_circle_faded ([resolution,resolution]))\n                        \n                    if np.random.randint(2) == 0:\n                        img = imagelib.apply_random_sharpen( img, sharpen_chance, sharpen_kernel_max_size, mask=sd.random_circle_faded ([resolution,resolution]))\n                    else:\n                        img = imagelib.apply_random_motion_blur( img, motion_blur_chance, motion_blur_mb_max_size, mask=sd.random_circle_faded ([resolution,resolution]))\n                        img = imagelib.apply_random_gaussian_blur( img, gaussian_blur_chance, gaussian_blur_kernel_max_size, mask=sd.random_circle_faded ([resolution,resolution]))\n                        \n                    if np.random.randint(2) == 0:\n                        img = imagelib.apply_random_nearest_resize( img, random_bilinear_resize_chance, random_bilinear_resize_max_size_per, mask=sd.random_circle_faded ([resolution,resolution]))\n                    else:\n                        img = imagelib.apply_random_bilinear_resize( img, random_bilinear_resize_chance, random_bilinear_resize_max_size_per, mask=sd.random_circle_faded ([resolution,resolution]))\n                    img = np.clip(img, 0, 1)\n\n                    img = imagelib.apply_random_jpeg_compress( img, random_jpeg_compress_chance, mask=sd.random_circle_faded ([resolution,resolution]))\n\n                    if data_format == \"NCHW\":\n                        img = np.transpose(img, (2,0,1) )\n                        mask = np.transpose(mask, (2,0,1) )\n\n                    batches[0].append ( img )\n                    batches[1].append ( mask )\n\n                    n_batch += 1\n                except:\n                    io.log_err ( traceback.format_exc() )\n\n            yield [ np.array(batch) for batch in batches]\n\nclass SegmentedSampleFilterSubprocessor(Subprocessor):\n    #override\n    def __init__(self, samples, count_xseg_mask=False ):\n        self.samples = samples\n        self.samples_len = len(self.samples)\n        self.count_xseg_mask = count_xseg_mask\n\n        self.idxs = [*range(self.samples_len)]\n        self.result = []\n        super().__init__('SegmentedSampleFilterSubprocessor', SegmentedSampleFilterSubprocessor.Cli, 60)\n\n    #override\n    def process_info_generator(self):\n        for i in range(multiprocessing.cpu_count()):\n            yield 'CPU%d' % (i), {}, {'samples':self.samples, 'count_xseg_mask':self.count_xseg_mask}\n\n    #override\n    def on_clients_initialized(self):\n        io.progress_bar (\"Filtering\", self.samples_len)\n\n    #override\n    def on_clients_finalized(self):\n        io.progress_bar_close()\n\n    #override\n    def get_data(self, host_dict):\n        if len (self.idxs) > 0:\n            return self.idxs.pop(0)\n\n        return None\n\n    #override\n    def on_data_return (self, host_dict, data):\n        self.idxs.insert(0, data)\n\n    #override\n    def on_result (self, host_dict, data, result):\n        idx, is_ok = result\n        if is_ok:\n            self.result.append(idx)\n        io.progress_bar_inc(1)\n    def get_result(self):\n        return self.result\n\n    class Cli(Subprocessor.Cli):\n        #overridable optional\n        def on_initialize(self, client_dict):\n            self.samples = client_dict['samples']\n            self.count_xseg_mask = client_dict['count_xseg_mask']\n\n        def process_data(self, idx):\n            if self.count_xseg_mask:\n                return idx, self.samples[idx].has_xseg_mask()\n            else:\n                return idx, self.samples[idx].seg_ie_polys.get_pts_count() != 0\n\n\"\"\"\n  bg_path = None\n        for path in paths:\n            bg_path = Path(path) / 'backgrounds'\n            if bg_path.exists():\n\n                break\n        if bg_path is None:\n            io.log_info(f'Random backgrounds will not be used. Place no face jpg images to aligned\\backgrounds folder. ')\n            bg_pathes = None\n        else:\n            bg_pathes = pathex.get_image_paths(bg_path, image_extensions=['.jpg'], return_Path_class=True)\n            io.log_info(f'Using {len(bg_pathes)} random backgrounds from {bg_path}')\n\nif bg_pathes is not None:\n            bg_path = bg_pathes[ np.random.randint(len(bg_pathes)) ]\n\n            bg_img = cv2_imread(bg_path)\n            if bg_img is not None:\n                bg_img = bg_img.astype(np.float32) / 255.0\n                bg_img = imagelib.normalize_channels(bg_img, 3)\n\n                bg_img = imagelib.random_crop(bg_img, resolution, resolution)\n                bg_img = cv2.resize(bg_img, (resolution, resolution), interpolation=cv2.INTER_LINEAR)\n\n            if np.random.randint(2) == 0:\n                bg_img = imagelib.apply_random_hsv_shift(bg_img)\n            else:\n                bg_img = imagelib.apply_random_rgb_levels(bg_img)\n\n            bg_wp   = imagelib.gen_warp_params(resolution, True, rotation_range=[-180,180], scale_range=[0,0], tx_range=[0,0], ty_range=[0,0])\n            bg_img  = imagelib.warp_by_params (bg_wp, bg_img,  can_warp=False, can_transform=True, can_flip=True, border_replicate=True)\n\n            bg = img*(1-mask)\n            fg = img*mask\n\n            c_mask = sd.random_circle_faded ([resolution,resolution])\n            bg = ( bg_img*c_mask + bg*(1-c_mask) )*(1-mask)\n\n            img = fg+bg\n\n        else:\n\"\"\"", "samplelib/__init__.py": "from .Sample import Sample\nfrom .Sample import SampleType\nfrom .SampleLoader import SampleLoader\nfrom .SampleProcessor import SampleProcessor\nfrom .SampleGeneratorBase import SampleGeneratorBase\nfrom .SampleGeneratorFace import SampleGeneratorFace\nfrom .SampleGeneratorFacePerson import SampleGeneratorFacePerson\nfrom .SampleGeneratorFaceTemporal import SampleGeneratorFaceTemporal\nfrom .SampleGeneratorImage import SampleGeneratorImage\nfrom .SampleGeneratorImageTemporal import SampleGeneratorImageTemporal\nfrom .SampleGeneratorFaceCelebAMaskHQ import SampleGeneratorFaceCelebAMaskHQ\nfrom .SampleGeneratorFaceXSeg import SampleGeneratorFaceXSeg\nfrom .PackedFaceset import PackedFaceset", "facelib/XSegNet.py": "import os\nimport pickle\nfrom functools import partial\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\n\nfrom core.interact import interact as io\nfrom core.leras import nn\n\n\nclass XSegNet(object):\n    VERSION = 1\n\n    def __init__ (self, name, \n                        resolution=256, \n                        load_weights=True, \n                        weights_file_root=None, \n                        training=False, \n                        place_model_on_cpu=False, \n                        run_on_cpu=False, \n                        optimizer=None, \n                        data_format=\"NHWC\",\n                        raise_on_no_model_files=False):\n                \n        self.resolution = resolution\n        self.weights_file_root = Path(weights_file_root) if weights_file_root is not None else Path(__file__).parent\n        \n        nn.initialize(data_format=data_format)\n        tf = nn.tf\n        \n        model_name = f'{name}_{resolution}'\n        self.model_filename_list = []\n        \n        with tf.device ('/CPU:0'):\n            #Place holders on CPU\n            self.input_t  = tf.placeholder (nn.floatx, nn.get4Dshape(resolution,resolution,3) )\n            self.target_t = tf.placeholder (nn.floatx, nn.get4Dshape(resolution,resolution,1) )\n\n        # Initializing model classes\n        with tf.device ('/CPU:0' if place_model_on_cpu else nn.tf_default_device_name):\n            self.model = nn.XSeg(3, 32, 1, name=name)\n            self.model_weights = self.model.get_weights()\n            if training:\n                if optimizer is None:\n                    raise ValueError(\"Optimizer should be provided for training mode.\")                \n                self.opt = optimizer              \n                self.opt.initialize_variables (self.model_weights, vars_on_cpu=place_model_on_cpu)                    \n                self.model_filename_list += [ [self.opt, f'{model_name}_opt.npy' ] ]\n                \n        \n        self.model_filename_list += [ [self.model, f'{model_name}.npy'] ]\n\n        if not training:\n            with tf.device ('/CPU:0' if run_on_cpu else nn.tf_default_device_name):\n                _, pred = self.model(self.input_t)\n\n            def net_run(input_np):\n                return nn.tf_sess.run ( [pred], feed_dict={self.input_t :input_np})[0]\n            self.net_run = net_run\n\n        self.initialized = True\n        # Loading/initializing all models/optimizers weights\n        for model, filename in self.model_filename_list:\n            do_init = not load_weights\n\n            if not do_init:\n                model_file_path = self.weights_file_root / filename\n                do_init = not model.load_weights( model_file_path )\n                if do_init:\n                    if raise_on_no_model_files:\n                        raise Exception(f'{model_file_path} does not exists.')\n                    if not training:\n                        self.initialized = False\n                        break\n\n            if do_init:\n                model.init_weights()\n        \n    def get_resolution(self):\n        return self.resolution\n        \n    def flow(self, x, pretrain=False):\n        return self.model(x, pretrain=pretrain)\n\n    def get_weights(self):\n        return self.model_weights\n\n    def save_weights(self):\n        for model, filename in io.progress_bar_generator(self.model_filename_list, \"Saving\", leave=False):\n            model.save_weights( self.weights_file_root / filename )\n\n    def extract (self, input_image):\n        if not self.initialized:\n            return 0.5*np.ones ( (self.resolution, self.resolution, 1), nn.floatx.as_numpy_dtype )\n            \n        input_shape_len = len(input_image.shape)            \n        if input_shape_len == 3:\n            input_image = input_image[None,...]\n\n        result = np.clip ( self.net_run(input_image), 0, 1.0 )\n        result[result < 0.1] = 0 #get rid of noise\n\n        if input_shape_len == 3:\n            result = result[0]\n\n        return result", "facelib/FANExtractor.py": "import os\nimport traceback\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\nfrom numpy import linalg as npla\n\nfrom facelib import FaceType, LandmarksProcessor\nfrom core.leras import nn\n\n\"\"\"\nported from https://github.com/1adrianb/face-alignment\n\"\"\"\nclass FANExtractor(object):\n    def __init__ (self, landmarks_3D=False, place_model_on_cpu=False):\n        \n        model_path = Path(__file__).parent / ( \"2DFAN.npy\" if not landmarks_3D else \"3DFAN.npy\")\n        if not model_path.exists():\n            raise Exception(\"Unable to load FANExtractor model\")\n\n        nn.initialize(data_format=\"NHWC\")\n        tf = nn.tf\n\n        class ConvBlock(nn.ModelBase):\n            def on_build(self, in_planes, out_planes):\n                self.in_planes = in_planes\n                self.out_planes = out_planes\n\n                self.bn1 = nn.BatchNorm2D(in_planes)\n                self.conv1 = nn.Conv2D (in_planes, out_planes//2, kernel_size=3, strides=1, padding='SAME', use_bias=False )\n\n                self.bn2 = nn.BatchNorm2D(out_planes//2)\n                self.conv2 = nn.Conv2D (out_planes//2, out_planes//4, kernel_size=3, strides=1, padding='SAME', use_bias=False )\n\n                self.bn3 = nn.BatchNorm2D(out_planes//4)\n                self.conv3 = nn.Conv2D (out_planes//4, out_planes//4, kernel_size=3, strides=1, padding='SAME', use_bias=False )\n\n                if self.in_planes != self.out_planes:\n                    self.down_bn1 = nn.BatchNorm2D(in_planes)\n                    self.down_conv1 = nn.Conv2D (in_planes, out_planes, kernel_size=1, strides=1, padding='VALID', use_bias=False )\n                else:\n                    self.down_bn1 = None\n                    self.down_conv1 = None\n\n            def forward(self, input):\n                x = input\n                x = self.bn1(x)\n                x = tf.nn.relu(x)\n                x = out1 = self.conv1(x)\n\n                x = self.bn2(x)\n                x = tf.nn.relu(x)\n                x = out2 = self.conv2(x)\n\n                x = self.bn3(x)\n                x = tf.nn.relu(x)\n                x = out3 = self.conv3(x)\n\n                x = tf.concat ([out1, out2, out3], axis=-1)\n\n                if self.in_planes != self.out_planes:\n                    downsample = self.down_bn1(input)\n                    downsample = tf.nn.relu (downsample)\n                    downsample = self.down_conv1 (downsample)\n                    x = x + downsample\n                else:\n                    x = x + input\n\n                return x\n\n        class HourGlass (nn.ModelBase):\n            def on_build(self, in_planes, depth):\n                self.b1 = ConvBlock (in_planes, 256)\n                self.b2 = ConvBlock (in_planes, 256)\n\n                if depth > 1:\n                    self.b2_plus = HourGlass(256, depth-1)\n                else:\n                    self.b2_plus = ConvBlock(256, 256)\n\n                self.b3 = ConvBlock(256, 256)\n\n            def forward(self, input):\n                up1 = self.b1(input)\n\n                low1 = tf.nn.avg_pool(input, [1,2,2,1], [1,2,2,1], 'VALID')\n                low1 = self.b2 (low1)\n\n                low2 = self.b2_plus(low1)\n                low3 = self.b3(low2)\n\n                up2 = nn.upsample2d(low3)\n\n                return up1+up2\n\n        class FAN (nn.ModelBase):\n            def __init__(self):\n                super().__init__(name='FAN')\n\n            def on_build(self):\n                self.conv1 = nn.Conv2D (3, 64, kernel_size=7, strides=2, padding='SAME')\n                self.bn1 = nn.BatchNorm2D(64)\n\n                self.conv2 = ConvBlock(64, 128)\n                self.conv3 = ConvBlock(128, 128)\n                self.conv4 = ConvBlock(128, 256)\n\n                self.m = []\n                self.top_m = []\n                self.conv_last = []\n                self.bn_end = []\n                self.l = []\n                self.bl = []\n                self.al = []\n                for i in range(4):\n                    self.m += [ HourGlass(256, 4) ]\n                    self.top_m += [ ConvBlock(256, 256) ]\n\n                    self.conv_last += [ nn.Conv2D (256, 256, kernel_size=1, strides=1, padding='VALID') ]\n                    self.bn_end += [ nn.BatchNorm2D(256) ]\n\n                    self.l += [ nn.Conv2D (256, 68, kernel_size=1, strides=1, padding='VALID') ]\n\n                    if i < 4-1:\n                        self.bl += [ nn.Conv2D (256, 256, kernel_size=1, strides=1, padding='VALID') ]\n                        self.al += [ nn.Conv2D (68, 256, kernel_size=1, strides=1, padding='VALID') ]\n\n            def forward(self, inp) :\n                x, = inp\n                x = self.conv1(x)\n                x = self.bn1(x)\n                x = tf.nn.relu(x)\n\n                x = self.conv2(x)\n                x = tf.nn.avg_pool(x, [1,2,2,1], [1,2,2,1], 'VALID')\n                x = self.conv3(x)\n                x = self.conv4(x)\n\n                outputs = []\n                previous = x\n                for i in range(4):\n                    ll = self.m[i] (previous)\n                    ll = self.top_m[i] (ll)\n                    ll = self.conv_last[i] (ll)\n                    ll = self.bn_end[i] (ll)\n                    ll = tf.nn.relu(ll)\n                    tmp_out = self.l[i](ll)\n                    outputs.append(tmp_out)\n                    if i < 4 - 1:\n                        ll = self.bl[i](ll)\n                        previous = previous + ll + self.al[i](tmp_out)\n                x = outputs[-1]\n                x = tf.transpose(x, (0,3,1,2) )\n                return x\n\n        e = None\n        if place_model_on_cpu:\n            e = tf.device(\"/CPU:0\")\n\n        if e is not None: e.__enter__()\n        self.model = FAN()\n        self.model.load_weights(str(model_path))\n        if e is not None: e.__exit__(None,None,None)\n\n        self.model.build_for_run ([ ( tf.float32, (None,256,256,3) ) ])\n\n    def extract (self, input_image, rects, second_pass_extractor=None, is_bgr=True, multi_sample=False):\n        if len(rects) == 0:\n            return []\n\n        if is_bgr:\n            input_image = input_image[:,:,::-1]\n            is_bgr = False\n\n        (h, w, ch) = input_image.shape\n\n        landmarks = []\n        for (left, top, right, bottom) in rects:\n            scale = (right - left + bottom - top) / 195.0\n\n            center = np.array( [ (left + right) / 2.0, (top + bottom) / 2.0] )\n            centers = [ center ]\n\n            if multi_sample:\n                centers += [ center + [-1,-1],\n                             center + [1,-1],\n                             center + [1,1],\n                             center + [-1,1],\n                           ]\n\n            images = []\n            ptss = []\n\n            try:\n                for c in centers:\n                    images += [ self.crop(input_image, c, scale)  ]\n\n                images = np.stack (images)\n                images = images.astype(np.float32) / 255.0\n\n                predicted = []\n                for i in range( len(images) ):\n                    predicted += [ self.model.run ( [ images[i][None,...] ]  )[0] ]\n\n                predicted = np.stack(predicted)\n\n                for i, pred in enumerate(predicted):\n                    ptss += [ self.get_pts_from_predict ( pred, centers[i], scale) ]\n                pts_img = np.mean ( np.array(ptss), 0 )\n\n                landmarks.append (pts_img)\n            except:\n                landmarks.append (None)\n\n        if second_pass_extractor is not None:\n            for i, lmrks in enumerate(landmarks):\n                try:\n                    if lmrks is not None:\n                        image_to_face_mat = LandmarksProcessor.get_transform_mat (lmrks, 256, FaceType.FULL)\n                        face_image = cv2.warpAffine(input_image, image_to_face_mat, (256, 256), cv2.INTER_CUBIC )\n\n                        rects2 = second_pass_extractor.extract(face_image, is_bgr=is_bgr)\n                        if len(rects2) == 1: #dont do second pass if faces != 1 detected in cropped image\n                            lmrks2 = self.extract (face_image, [ rects2[0] ], is_bgr=is_bgr, multi_sample=True)[0]\n                            landmarks[i] = LandmarksProcessor.transform_points (lmrks2, image_to_face_mat, True)\n                except:\n                    pass\n\n        return landmarks\n\n    def transform(self, point, center, scale, resolution):\n        pt = np.array ( [point[0], point[1], 1.0] )\n        h = 200.0 * scale\n        m = np.eye(3)\n        m[0,0] = resolution / h\n        m[1,1] = resolution / h\n        m[0,2] = resolution * ( -center[0] / h + 0.5 )\n        m[1,2] = resolution * ( -center[1] / h + 0.5 )\n        m = np.linalg.inv(m)\n        return np.matmul (m, pt)[0:2]\n\n    def crop(self, image, center, scale, resolution=256.0):\n        ul = self.transform([1, 1], center, scale, resolution).astype( np.int )\n        br = self.transform([resolution, resolution], center, scale, resolution).astype( np.int )\n\n        if image.ndim > 2:\n            newDim = np.array([br[1] - ul[1], br[0] - ul[0], image.shape[2]], dtype=np.int32)\n            newImg = np.zeros(newDim, dtype=np.uint8)\n        else:\n            newDim = np.array([br[1] - ul[1], br[0] - ul[0]], dtype=np.int)\n            newImg = np.zeros(newDim, dtype=np.uint8)\n        ht = image.shape[0]\n        wd = image.shape[1]\n        newX = np.array([max(1, -ul[0] + 1), min(br[0], wd) - ul[0]], dtype=np.int32)\n        newY = np.array([max(1, -ul[1] + 1), min(br[1], ht) - ul[1]], dtype=np.int32)\n        oldX = np.array([max(1, ul[0] + 1), min(br[0], wd)], dtype=np.int32)\n        oldY = np.array([max(1, ul[1] + 1), min(br[1], ht)], dtype=np.int32)\n        newImg[newY[0] - 1:newY[1], newX[0] - 1:newX[1] ] = image[oldY[0] - 1:oldY[1], oldX[0] - 1:oldX[1], :]\n\n        newImg = cv2.resize(newImg, dsize=(int(resolution), int(resolution)), interpolation=cv2.INTER_LINEAR)\n        return newImg\n\n    def get_pts_from_predict(self, a, center, scale):\n        a_ch, a_h, a_w = a.shape\n\n        b = a.reshape ( (a_ch, a_h*a_w) )\n        c = b.argmax(1).reshape ( (a_ch, 1) ).repeat(2, axis=1).astype(np.float)\n        c[:,0] %= a_w\n        c[:,1] = np.apply_along_axis ( lambda x: np.floor(x / a_w), 0, c[:,1] )\n\n        for i in range(a_ch):\n            pX, pY = int(c[i,0]), int(c[i,1])\n            if pX > 0 and pX < 63 and pY > 0 and pY < 63:\n                diff = np.array ( [a[i,pY,pX+1]-a[i,pY,pX-1], a[i,pY+1,pX]-a[i,pY-1,pX]] )\n                c[i] += np.sign(diff)*0.25\n\n        c += 0.5\n\n        return np.array( [ self.transform (c[i], center, scale, a_w) for i in range(a_ch) ] )\n", "facelib/S3FDExtractor.py": "import operator\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\n\nfrom core.leras import nn\n\nclass S3FDExtractor(object):\n    def __init__(self, place_model_on_cpu=False):\n        nn.initialize(data_format=\"NHWC\")\n        tf = nn.tf\n\n        model_path = Path(__file__).parent / \"S3FD.npy\"\n        if not model_path.exists():\n            raise Exception(\"Unable to load S3FD.npy\")\n\n        class L2Norm(nn.LayerBase):\n            def __init__(self, n_channels, **kwargs):\n                self.n_channels = n_channels\n                super().__init__(**kwargs)\n\n            def build_weights(self):\n                self.weight = tf.get_variable (\"weight\", (1, 1, 1, self.n_channels), dtype=nn.floatx, initializer=tf.initializers.ones )\n\n            def get_weights(self):\n                return [self.weight]\n\n            def __call__(self, inputs):\n                x = inputs\n                x = x / (tf.sqrt( tf.reduce_sum( tf.pow(x, 2), axis=-1, keepdims=True ) ) + 1e-10) * self.weight\n                return x\n\n        class S3FD(nn.ModelBase):\n            def __init__(self):\n                super().__init__(name='S3FD')\n\n            def on_build(self):\n                self.minus = tf.constant([104,117,123], dtype=nn.floatx )\n                self.conv1_1 = nn.Conv2D(3, 64, kernel_size=3, strides=1, padding='SAME')\n                self.conv1_2 = nn.Conv2D(64, 64, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv2_1 = nn.Conv2D(64, 128, kernel_size=3, strides=1, padding='SAME')\n                self.conv2_2 = nn.Conv2D(128, 128, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv3_1 = nn.Conv2D(128, 256, kernel_size=3, strides=1, padding='SAME')\n                self.conv3_2 = nn.Conv2D(256, 256, kernel_size=3, strides=1, padding='SAME')\n                self.conv3_3 = nn.Conv2D(256, 256, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv4_1 = nn.Conv2D(256, 512, kernel_size=3, strides=1, padding='SAME')\n                self.conv4_2 = nn.Conv2D(512, 512, kernel_size=3, strides=1, padding='SAME')\n                self.conv4_3 = nn.Conv2D(512, 512, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv5_1 = nn.Conv2D(512, 512, kernel_size=3, strides=1, padding='SAME')\n                self.conv5_2 = nn.Conv2D(512, 512, kernel_size=3, strides=1, padding='SAME')\n                self.conv5_3 = nn.Conv2D(512, 512, kernel_size=3, strides=1, padding='SAME')\n\n                self.fc6 = nn.Conv2D(512, 1024, kernel_size=3, strides=1, padding=3)\n                self.fc7 = nn.Conv2D(1024, 1024, kernel_size=1, strides=1, padding='SAME')\n\n                self.conv6_1 = nn.Conv2D(1024, 256, kernel_size=1, strides=1, padding='SAME')\n                self.conv6_2 = nn.Conv2D(256, 512, kernel_size=3, strides=2, padding='SAME')\n\n                self.conv7_1 = nn.Conv2D(512, 128, kernel_size=1, strides=1, padding='SAME')\n                self.conv7_2 = nn.Conv2D(128, 256, kernel_size=3, strides=2, padding='SAME')\n\n                self.conv3_3_norm = L2Norm(256)\n                self.conv4_3_norm = L2Norm(512)\n                self.conv5_3_norm = L2Norm(512)\n\n\n                self.conv3_3_norm_mbox_conf = nn.Conv2D(256, 4, kernel_size=3, strides=1, padding='SAME')\n                self.conv3_3_norm_mbox_loc = nn.Conv2D(256, 4, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv4_3_norm_mbox_conf = nn.Conv2D(512, 2, kernel_size=3, strides=1, padding='SAME')\n                self.conv4_3_norm_mbox_loc = nn.Conv2D(512, 4, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv5_3_norm_mbox_conf = nn.Conv2D(512, 2, kernel_size=3, strides=1, padding='SAME')\n                self.conv5_3_norm_mbox_loc = nn.Conv2D(512, 4, kernel_size=3, strides=1, padding='SAME')\n\n                self.fc7_mbox_conf = nn.Conv2D(1024, 2, kernel_size=3, strides=1, padding='SAME')\n                self.fc7_mbox_loc = nn.Conv2D(1024, 4, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv6_2_mbox_conf = nn.Conv2D(512, 2, kernel_size=3, strides=1, padding='SAME')\n                self.conv6_2_mbox_loc = nn.Conv2D(512, 4, kernel_size=3, strides=1, padding='SAME')\n\n                self.conv7_2_mbox_conf = nn.Conv2D(256, 2, kernel_size=3, strides=1, padding='SAME')\n                self.conv7_2_mbox_loc = nn.Conv2D(256, 4, kernel_size=3, strides=1, padding='SAME')\n\n            def forward(self, inp):\n                x, = inp\n                x = x - self.minus\n                x = tf.nn.relu(self.conv1_1(x))\n                x = tf.nn.relu(self.conv1_2(x))\n                x = tf.nn.max_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n\n                x = tf.nn.relu(self.conv2_1(x))\n                x = tf.nn.relu(self.conv2_2(x))\n                x = tf.nn.max_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n\n                x = tf.nn.relu(self.conv3_1(x))\n                x = tf.nn.relu(self.conv3_2(x))\n                x = tf.nn.relu(self.conv3_3(x))\n                f3_3 = x\n                x = tf.nn.max_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n\n                x = tf.nn.relu(self.conv4_1(x))\n                x = tf.nn.relu(self.conv4_2(x))\n                x = tf.nn.relu(self.conv4_3(x))\n                f4_3 = x\n                x = tf.nn.max_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n\n                x = tf.nn.relu(self.conv5_1(x))\n                x = tf.nn.relu(self.conv5_2(x))\n                x = tf.nn.relu(self.conv5_3(x))\n                f5_3 = x\n                x = tf.nn.max_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n\n                x = tf.nn.relu(self.fc6(x))\n                x = tf.nn.relu(self.fc7(x))\n                ffc7 = x\n\n                x = tf.nn.relu(self.conv6_1(x))\n                x = tf.nn.relu(self.conv6_2(x))\n                f6_2 = x\n\n                x = tf.nn.relu(self.conv7_1(x))\n                x = tf.nn.relu(self.conv7_2(x))\n                f7_2 = x\n\n                f3_3 = self.conv3_3_norm(f3_3)\n                f4_3 = self.conv4_3_norm(f4_3)\n                f5_3 = self.conv5_3_norm(f5_3)\n\n                cls1 = self.conv3_3_norm_mbox_conf(f3_3)\n                reg1 = self.conv3_3_norm_mbox_loc(f3_3)\n\n                cls2 = tf.nn.softmax(self.conv4_3_norm_mbox_conf(f4_3))\n                reg2 = self.conv4_3_norm_mbox_loc(f4_3)\n\n                cls3 = tf.nn.softmax(self.conv5_3_norm_mbox_conf(f5_3))\n                reg3 = self.conv5_3_norm_mbox_loc(f5_3)\n\n                cls4 = tf.nn.softmax(self.fc7_mbox_conf(ffc7))\n                reg4 = self.fc7_mbox_loc(ffc7)\n\n                cls5 = tf.nn.softmax(self.conv6_2_mbox_conf(f6_2))\n                reg5 = self.conv6_2_mbox_loc(f6_2)\n\n                cls6 = tf.nn.softmax(self.conv7_2_mbox_conf(f7_2))\n                reg6 = self.conv7_2_mbox_loc(f7_2)\n\n                # max-out background label\n                bmax = tf.maximum(tf.maximum(cls1[:,:,:,0:1], cls1[:,:,:,1:2]), cls1[:,:,:,2:3])\n\n                cls1 = tf.concat ([bmax, cls1[:,:,:,3:4] ], axis=-1)\n                cls1 = tf.nn.softmax(cls1)\n\n                return [cls1, reg1, cls2, reg2, cls3, reg3, cls4, reg4, cls5, reg5, cls6, reg6]\n\n        e = None\n        if place_model_on_cpu:\n            e = tf.device(\"/CPU:0\")\n\n        if e is not None: e.__enter__()\n        self.model = S3FD()\n        self.model.load_weights (model_path)\n        if e is not None: e.__exit__(None,None,None)\n\n        self.model.build_for_run ([ ( tf.float32, nn.get4Dshape (None,None,3) ) ])\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type=None, exc_value=None, traceback=None):\n        return False #pass exception between __enter__ and __exit__ to outter level\n\n    def extract (self, input_image, is_bgr=True, is_remove_intersects=False):\n\n        if is_bgr:\n            input_image = input_image[:,:,::-1]\n            is_bgr = False\n\n        (h, w, ch) = input_image.shape\n\n        d = max(w, h)\n        scale_to = 640 if d >= 1280 else d / 2\n        scale_to = max(64, scale_to)\n\n        input_scale = d / scale_to\n        input_image = cv2.resize (input_image, ( int(w/input_scale), int(h/input_scale) ), interpolation=cv2.INTER_LINEAR)\n\n        olist = self.model.run ([ input_image[None,...] ] )\n\n        detected_faces = []\n        for ltrb in self.refine (olist):\n            l,t,r,b = [ x*input_scale for x in ltrb]\n            bt = b-t\n            if min(r-l,bt) < 40: #filtering faces < 40pix by any side\n                continue\n            b += bt*0.1 #enlarging bottom line a bit for 2DFAN-4, because default is not enough covering a chin\n            detected_faces.append ( [int(x) for x in (l,t,r,b) ] )\n\n        #sort by largest area first\n        detected_faces = [ [(l,t,r,b), (r-l)*(b-t) ]  for (l,t,r,b) in detected_faces ]\n        detected_faces = sorted(detected_faces, key=operator.itemgetter(1), reverse=True )\n        detected_faces = [ x[0] for x in detected_faces]\n\n        if is_remove_intersects:\n            for i in range( len(detected_faces)-1, 0, -1):\n                l1,t1,r1,b1 = detected_faces[i]\n                l0,t0,r0,b0 = detected_faces[i-1]\n\n                dx = min(r0, r1) - max(l0, l1)\n                dy = min(b0, b1) - max(t0, t1)\n                if (dx>=0) and (dy>=0):\n                    detected_faces.pop(i)\n\n        return detected_faces\n\n    def refine(self, olist):\n        bboxlist = []\n        for i, ((ocls,), (oreg,)) in enumerate ( zip ( olist[::2], olist[1::2] ) ):\n            stride = 2**(i + 2)    # 4,8,16,32,64,128\n            s_d2 = stride / 2\n            s_m4 = stride * 4\n\n            for hindex, windex in zip(*np.where(ocls[...,1] > 0.05)):\n                score = ocls[hindex, windex, 1]\n                loc   = oreg[hindex, windex, :]\n                priors = np.array([windex * stride + s_d2, hindex * stride + s_d2, s_m4, s_m4])\n                priors_2p = priors[2:]\n                box = np.concatenate((priors[:2] + loc[:2] * 0.1 * priors_2p,\n                                      priors_2p * np.exp(loc[2:] * 0.2)) )\n                box[:2] -= box[2:] / 2\n                box[2:] += box[:2]\n\n                bboxlist.append([*box, score])\n\n        bboxlist = np.array(bboxlist)\n        if len(bboxlist) == 0:\n            bboxlist = np.zeros((1, 5))\n\n        bboxlist = bboxlist[self.refine_nms(bboxlist, 0.3), :]\n        bboxlist = [ x[:-1].astype(np.int) for x in bboxlist if x[-1] >= 0.5]\n        return bboxlist\n\n    def refine_nms(self, dets, thresh):\n        keep = list()\n        if len(dets) == 0:\n            return keep\n\n        x_1, y_1, x_2, y_2, scores = dets[:, 0], dets[:, 1], dets[:, 2], dets[:, 3], dets[:, 4]\n        areas = (x_2 - x_1 + 1) * (y_2 - y_1 + 1)\n        order = scores.argsort()[::-1]\n\n        keep = []\n        while order.size > 0:\n            i = order[0]\n            keep.append(i)\n            xx_1, yy_1 = np.maximum(x_1[i], x_1[order[1:]]), np.maximum(y_1[i], y_1[order[1:]])\n            xx_2, yy_2 = np.minimum(x_2[i], x_2[order[1:]]), np.minimum(y_2[i], y_2[order[1:]])\n\n            width, height = np.maximum(0.0, xx_2 - xx_1 + 1), np.maximum(0.0, yy_2 - yy_1 + 1)\n            ovr = width * height / (areas[i] + areas[order[1:]] - width * height)\n\n            inds = np.where(ovr <= thresh)[0]\n            order = order[inds + 1]\n        return keep\n", "facelib/FaceType.py": "from enum import IntEnum\n\nclass FaceType(IntEnum):\n    #enumerating in order \"next contains prev\"\n    HALF = 0\n    MID_FULL = 1\n    FULL = 2\n    FULL_NO_ALIGN = 3\n    WHOLE_FACE = 4\n    HEAD = 10\n    HEAD_NO_ALIGN = 20\n\n    MARK_ONLY = 100, #no align at all, just embedded faceinfo\n\n    @staticmethod\n    def fromString (s):\n        r = from_string_dict.get (s.lower())\n        if r is None:\n            raise Exception ('FaceType.fromString value error')\n        return r\n\n    @staticmethod\n    def toString (face_type):\n        return to_string_dict[face_type]\n\nto_string_dict = { FaceType.HALF : 'half_face',\n                   FaceType.MID_FULL : 'midfull_face',\n                   FaceType.FULL : 'full_face',\n                   FaceType.FULL_NO_ALIGN : 'full_face_no_align',\n                   FaceType.WHOLE_FACE : 'whole_face',\n                   FaceType.HEAD : 'head',\n                   FaceType.HEAD_NO_ALIGN : 'head_no_align',\n                   \n                   FaceType.MARK_ONLY :'mark_only',  \n                 }\n\nfrom_string_dict = { to_string_dict[x] : x for x in to_string_dict.keys() }  ", "facelib/FaceEnhancer.py": "import operator\nfrom pathlib import Path\n\nimport cv2\nimport numpy as np\n\nfrom core.leras import nn\n\nclass FaceEnhancer(object):\n    \"\"\"\n    x4 face enhancer\n    \"\"\"\n    def __init__(self, place_model_on_cpu=False, run_on_cpu=False):\n        nn.initialize(data_format=\"NHWC\")\n        tf = nn.tf\n\n        class FaceEnhancer (nn.ModelBase):\n            def __init__(self, name='FaceEnhancer'):\n                super().__init__(name=name)\n\n            def on_build(self):\n                self.conv1 = nn.Conv2D (3, 64, kernel_size=3, strides=1, padding='SAME')\n\n                self.dense1 = nn.Dense (1, 64, use_bias=False)\n                self.dense2 = nn.Dense (1, 64, use_bias=False)\n\n                self.e0_conv0 = nn.Conv2D (64, 64, kernel_size=3, strides=1, padding='SAME')\n                self.e0_conv1 = nn.Conv2D (64, 64, kernel_size=3, strides=1, padding='SAME')\n\n                self.e1_conv0 = nn.Conv2D (64, 112, kernel_size=3, strides=1, padding='SAME')\n                self.e1_conv1 = nn.Conv2D (112, 112, kernel_size=3, strides=1, padding='SAME')\n\n                self.e2_conv0 = nn.Conv2D (112, 192, kernel_size=3, strides=1, padding='SAME')\n                self.e2_conv1 = nn.Conv2D (192, 192, kernel_size=3, strides=1, padding='SAME')\n\n                self.e3_conv0 = nn.Conv2D (192, 336, kernel_size=3, strides=1, padding='SAME')\n                self.e3_conv1 = nn.Conv2D (336, 336, kernel_size=3, strides=1, padding='SAME')\n\n                self.e4_conv0 = nn.Conv2D (336, 512, kernel_size=3, strides=1, padding='SAME')\n                self.e4_conv1 = nn.Conv2D (512, 512, kernel_size=3, strides=1, padding='SAME')\n\n                self.center_conv0 = nn.Conv2D (512, 512, kernel_size=3, strides=1, padding='SAME')\n                self.center_conv1 = nn.Conv2D (512, 512, kernel_size=3, strides=1, padding='SAME')\n                self.center_conv2 = nn.Conv2D (512, 512, kernel_size=3, strides=1, padding='SAME')\n                self.center_conv3 = nn.Conv2D (512, 512, kernel_size=3, strides=1, padding='SAME')\n\n                self.d4_conv0 = nn.Conv2D (1024, 512, kernel_size=3, strides=1, padding='SAME')\n                self.d4_conv1 = nn.Conv2D (512, 512, kernel_size=3, strides=1, padding='SAME')\n\n                self.d3_conv0 = nn.Conv2D (848, 512, kernel_size=3, strides=1, padding='SAME')\n                self.d3_conv1 = nn.Conv2D (512, 512, kernel_size=3, strides=1, padding='SAME')\n\n                self.d2_conv0 = nn.Conv2D (704, 288, kernel_size=3, strides=1, padding='SAME')\n                self.d2_conv1 = nn.Conv2D (288, 288, kernel_size=3, strides=1, padding='SAME')\n\n                self.d1_conv0 = nn.Conv2D (400, 160, kernel_size=3, strides=1, padding='SAME')\n                self.d1_conv1 = nn.Conv2D (160, 160, kernel_size=3, strides=1, padding='SAME')\n\n                self.d0_conv0 = nn.Conv2D (224, 96, kernel_size=3, strides=1, padding='SAME')\n                self.d0_conv1 = nn.Conv2D (96, 96, kernel_size=3, strides=1, padding='SAME')\n\n                self.out1x_conv0 = nn.Conv2D (96, 48, kernel_size=3, strides=1, padding='SAME')\n                self.out1x_conv1 = nn.Conv2D (48, 3, kernel_size=3, strides=1, padding='SAME')\n\n                self.dec2x_conv0 = nn.Conv2D (96, 96, kernel_size=3, strides=1, padding='SAME')\n                self.dec2x_conv1 = nn.Conv2D (96, 96, kernel_size=3, strides=1, padding='SAME')\n\n                self.out2x_conv0 = nn.Conv2D (96, 48, kernel_size=3, strides=1, padding='SAME')\n                self.out2x_conv1 = nn.Conv2D (48, 3, kernel_size=3, strides=1, padding='SAME')\n\n                self.dec4x_conv0 = nn.Conv2D (96, 72, kernel_size=3, strides=1, padding='SAME')\n                self.dec4x_conv1 = nn.Conv2D (72, 72, kernel_size=3, strides=1, padding='SAME')\n\n                self.out4x_conv0 = nn.Conv2D (72, 36, kernel_size=3, strides=1, padding='SAME')\n                self.out4x_conv1 = nn.Conv2D (36, 3 , kernel_size=3, strides=1, padding='SAME')\n\n            def forward(self, inp):\n                bgr, param, param1 = inp\n\n                x = self.conv1(bgr)\n                a = self.dense1(param)\n                a = tf.reshape(a, (-1,1,1,64) )\n\n                b = self.dense2(param1)\n                b = tf.reshape(b, (-1,1,1,64) )\n\n                x = tf.nn.leaky_relu(x+a+b, 0.1)\n\n                x = tf.nn.leaky_relu(self.e0_conv0(x), 0.1)\n                x = e0 = tf.nn.leaky_relu(self.e0_conv1(x), 0.1)\n\n                x = tf.nn.avg_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n                x = tf.nn.leaky_relu(self.e1_conv0(x), 0.1)\n                x = e1 = tf.nn.leaky_relu(self.e1_conv1(x), 0.1)\n\n                x = tf.nn.avg_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n                x = tf.nn.leaky_relu(self.e2_conv0(x), 0.1)\n                x = e2 = tf.nn.leaky_relu(self.e2_conv1(x), 0.1)\n\n                x = tf.nn.avg_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n                x = tf.nn.leaky_relu(self.e3_conv0(x), 0.1)\n                x = e3 = tf.nn.leaky_relu(self.e3_conv1(x), 0.1)\n\n                x = tf.nn.avg_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n                x = tf.nn.leaky_relu(self.e4_conv0(x), 0.1)\n                x = e4 = tf.nn.leaky_relu(self.e4_conv1(x), 0.1)\n\n                x = tf.nn.avg_pool(x, [1,2,2,1], [1,2,2,1], \"VALID\")\n                x = tf.nn.leaky_relu(self.center_conv0(x), 0.1)\n                x = tf.nn.leaky_relu(self.center_conv1(x), 0.1)\n                x = tf.nn.leaky_relu(self.center_conv2(x), 0.1)\n                x = tf.nn.leaky_relu(self.center_conv3(x), 0.1)\n\n                x = tf.concat( [nn.resize2d_bilinear(x), e4], -1 )\n                x = tf.nn.leaky_relu(self.d4_conv0(x), 0.1)\n                x = tf.nn.leaky_relu(self.d4_conv1(x), 0.1)\n\n                x = tf.concat( [nn.resize2d_bilinear(x), e3], -1 )\n                x = tf.nn.leaky_relu(self.d3_conv0(x), 0.1)\n                x = tf.nn.leaky_relu(self.d3_conv1(x), 0.1)\n\n                x = tf.concat( [nn.resize2d_bilinear(x), e2], -1 )\n                x = tf.nn.leaky_relu(self.d2_conv0(x), 0.1)\n                x = tf.nn.leaky_relu(self.d2_conv1(x), 0.1)\n\n                x = tf.concat( [nn.resize2d_bilinear(x), e1], -1 )\n                x = tf.nn.leaky_relu(self.d1_conv0(x), 0.1)\n                x = tf.nn.leaky_relu(self.d1_conv1(x), 0.1)\n\n                x = tf.concat( [nn.resize2d_bilinear(x), e0], -1 )\n                x = tf.nn.leaky_relu(self.d0_conv0(x), 0.1)\n                x = d0 = tf.nn.leaky_relu(self.d0_conv1(x), 0.1)\n\n                x = tf.nn.leaky_relu(self.out1x_conv0(x), 0.1)\n                x = self.out1x_conv1(x)\n                out1x = bgr + tf.nn.tanh(x)\n\n                x = d0\n                x = tf.nn.leaky_relu(self.dec2x_conv0(x), 0.1)\n                x = tf.nn.leaky_relu(self.dec2x_conv1(x), 0.1)\n                x = d2x = nn.resize2d_bilinear(x)\n\n                x = tf.nn.leaky_relu(self.out2x_conv0(x), 0.1)\n                x = self.out2x_conv1(x)\n\n                out2x = nn.resize2d_bilinear(out1x) + tf.nn.tanh(x)\n\n                x = d2x\n                x = tf.nn.leaky_relu(self.dec4x_conv0(x), 0.1)\n                x = tf.nn.leaky_relu(self.dec4x_conv1(x), 0.1)\n                x = d4x = nn.resize2d_bilinear(x)\n\n                x = tf.nn.leaky_relu(self.out4x_conv0(x), 0.1)\n                x = self.out4x_conv1(x)\n\n                out4x = nn.resize2d_bilinear(out2x) + tf.nn.tanh(x)\n\n                return out4x\n\n        model_path = Path(__file__).parent / \"FaceEnhancer.npy\"\n        if not model_path.exists():\n            raise Exception(\"Unable to load FaceEnhancer.npy\")\n\n        with tf.device ('/CPU:0' if place_model_on_cpu else nn.tf_default_device_name):\n            self.model = FaceEnhancer()\n            self.model.load_weights (model_path)\n        \n        with tf.device ('/CPU:0' if run_on_cpu else nn.tf_default_device_name):\n            self.model.build_for_run ([ (tf.float32, nn.get4Dshape (192,192,3) ),\n                                        (tf.float32, (None,1,) ),\n                                        (tf.float32, (None,1,) ),\n                                    ])\n\n    def enhance (self, inp_img, is_tanh=False, preserve_size=True):\n        if not is_tanh:\n            inp_img = np.clip( inp_img * 2 -1, -1, 1 )\n\n        param = np.array([0.2])\n        param1 = np.array([1.0])\n        up_res = 4\n        patch_size = 192\n        patch_size_half = patch_size // 2\n\n        ih,iw,ic = inp_img.shape\n        h,w,c = ih,iw,ic\n\n        th,tw = h*up_res, w*up_res\n\n        t_padding = 0\n        b_padding = 0\n        l_padding = 0\n        r_padding = 0\n\n        if h < patch_size:\n            t_padding = (patch_size-h)//2\n            b_padding = (patch_size-h) - t_padding\n\n        if w < patch_size:\n            l_padding = (patch_size-w)//2\n            r_padding = (patch_size-w) - l_padding\n\n        if t_padding != 0:\n            inp_img = np.concatenate ([ np.zeros ( (t_padding,w,c), dtype=np.float32 ), inp_img ], axis=0 )\n            h,w,c = inp_img.shape\n\n        if b_padding != 0:\n            inp_img = np.concatenate ([ inp_img, np.zeros ( (b_padding,w,c), dtype=np.float32 ) ], axis=0 )\n            h,w,c = inp_img.shape\n\n        if l_padding != 0:\n            inp_img = np.concatenate ([ np.zeros ( (h,l_padding,c), dtype=np.float32 ), inp_img ], axis=1 )\n            h,w,c = inp_img.shape\n\n        if r_padding != 0:\n            inp_img = np.concatenate ([ inp_img, np.zeros ( (h,r_padding,c), dtype=np.float32 ) ], axis=1 )\n            h,w,c = inp_img.shape\n\n\n        i_max = w-patch_size+1\n        j_max = h-patch_size+1\n\n        final_img = np.zeros ( (h*up_res,w*up_res,c), dtype=np.float32 )\n        final_img_div = np.zeros ( (h*up_res,w*up_res,1), dtype=np.float32 )\n\n        x = np.concatenate ( [ np.linspace (0,1,patch_size_half*up_res), np.linspace (1,0,patch_size_half*up_res) ] )\n        x,y = np.meshgrid(x,x)\n        patch_mask = (x*y)[...,None]\n\n        j=0\n        while j < j_max:\n            i = 0\n            while i < i_max:\n                patch_img = inp_img[j:j+patch_size, i:i+patch_size,:]\n                x = self.model.run( [ patch_img[None,...], [param], [param1] ] )[0]\n                final_img    [j*up_res:(j+patch_size)*up_res, i*up_res:(i+patch_size)*up_res,:] += x*patch_mask\n                final_img_div[j*up_res:(j+patch_size)*up_res, i*up_res:(i+patch_size)*up_res,:] += patch_mask\n                if i == i_max-1:\n                    break\n                i = min( i+patch_size_half, i_max-1)\n            if j == j_max-1:\n                break\n            j = min( j+patch_size_half, j_max-1)\n\n        final_img_div[final_img_div==0] = 1.0\n        final_img /= final_img_div\n\n        if t_padding+b_padding+l_padding+r_padding != 0:\n            final_img = final_img [t_padding*up_res:(h-b_padding)*up_res, l_padding*up_res:(w-r_padding)*up_res,:]\n\n        if preserve_size:\n            final_img = cv2.resize (final_img, (iw,ih), interpolation=cv2.INTER_LANCZOS4)\n\n        if not is_tanh:\n            final_img = np.clip( final_img/2+0.5, 0, 1 )\n\n        return final_img\n\n\n\"\"\"\n\n    def enhance (self, inp_img, is_tanh=False, preserve_size=True):\n        if not is_tanh:\n            inp_img = np.clip( inp_img * 2 -1, -1, 1 )\n\n        param = np.array([0.2])\n        param1 = np.array([1.0])\n        up_res = 4\n        patch_size = 192\n        patch_size_half = patch_size // 2\n\n        h,w,c = inp_img.shape\n\n        th,tw = h*up_res, w*up_res\n\n        preupscale_rate = 1.0\n\n        if h < patch_size or w < patch_size:\n            preupscale_rate = 1.0 / ( max(h,w) / patch_size )\n\n        if preupscale_rate != 1.0:\n            inp_img = cv2.resize (inp_img, ( int(w*preupscale_rate), int(h*preupscale_rate) ), interpolation=cv2.INTER_LANCZOS4)\n            h,w,c = inp_img.shape\n\n        i_max = w-patch_size+1\n        j_max = h-patch_size+1\n\n        final_img = np.zeros ( (h*up_res,w*up_res,c), dtype=np.float32 )\n        final_img_div = np.zeros ( (h*up_res,w*up_res,1), dtype=np.float32 )\n\n        x = np.concatenate ( [ np.linspace (0,1,patch_size_half*up_res), np.linspace (1,0,patch_size_half*up_res) ] )\n        x,y = np.meshgrid(x,x)\n        patch_mask = (x*y)[...,None]\n\n        j=0\n        while j < j_max:\n            i = 0\n            while i < i_max:\n                patch_img = inp_img[j:j+patch_size, i:i+patch_size,:]\n                x = self.model.run( [ patch_img[None,...], [param], [param1] ] )[0]\n                final_img    [j*up_res:(j+patch_size)*up_res, i*up_res:(i+patch_size)*up_res,:] += x*patch_mask\n                final_img_div[j*up_res:(j+patch_size)*up_res, i*up_res:(i+patch_size)*up_res,:] += patch_mask\n                if i == i_max-1:\n                    break\n                i = min( i+patch_size_half, i_max-1)\n            if j == j_max-1:\n                break\n            j = min( j+patch_size_half, j_max-1)\n\n        final_img_div[final_img_div==0] = 1.0\n        final_img /= final_img_div\n\n        if preserve_size:\n            final_img = cv2.resize (final_img, (w,h), interpolation=cv2.INTER_LANCZOS4)\n        else:\n            if preupscale_rate != 1.0:\n                final_img = cv2.resize (final_img, (tw,th), interpolation=cv2.INTER_LANCZOS4)\n\n        if not is_tanh:\n            final_img = np.clip( final_img/2+0.5, 0, 1 )\n\n        return final_img\n\"\"\"", "facelib/__init__.py": "from .FaceType import FaceType\nfrom .S3FDExtractor import S3FDExtractor\nfrom .FANExtractor import FANExtractor\nfrom .FaceEnhancer import FaceEnhancer\nfrom .XSegNet import XSegNet", "facelib/LandmarksProcessor.py": "import colorsys\nimport math\nfrom enum import IntEnum\n\nimport cv2\nimport numpy as np\nimport numpy.linalg as npla\n\nfrom core import imagelib\nfrom core import mathlib\nfrom facelib import FaceType\nfrom core.mathlib.umeyama import umeyama\n\nlandmarks_2D = np.array([\n[ 0.000213256,  0.106454  ], #17\n[ 0.0752622,    0.038915  ], #18\n[ 0.18113,      0.0187482 ], #19\n[ 0.29077,      0.0344891 ], #20\n[ 0.393397,     0.0773906 ], #21\n[ 0.586856,     0.0773906 ], #22\n[ 0.689483,     0.0344891 ], #23\n[ 0.799124,     0.0187482 ], #24\n[ 0.904991,     0.038915  ], #25\n[ 0.98004,      0.106454  ], #26\n[ 0.490127,     0.203352  ], #27\n[ 0.490127,     0.307009  ], #28\n[ 0.490127,     0.409805  ], #29\n[ 0.490127,     0.515625  ], #30\n[ 0.36688,      0.587326  ], #31\n[ 0.426036,     0.609345  ], #32\n[ 0.490127,     0.628106  ], #33\n[ 0.554217,     0.609345  ], #34\n[ 0.613373,     0.587326  ], #35\n[ 0.121737,     0.216423  ], #36\n[ 0.187122,     0.178758  ], #37\n[ 0.265825,     0.179852  ], #38\n[ 0.334606,     0.231733  ], #39\n[ 0.260918,     0.245099  ], #40\n[ 0.182743,     0.244077  ], #41\n[ 0.645647,     0.231733  ], #42\n[ 0.714428,     0.179852  ], #43\n[ 0.793132,     0.178758  ], #44\n[ 0.858516,     0.216423  ], #45\n[ 0.79751,      0.244077  ], #46\n[ 0.719335,     0.245099  ], #47\n[ 0.254149,     0.780233  ], #48\n[ 0.340985,     0.745405  ], #49\n[ 0.428858,     0.727388  ], #50\n[ 0.490127,     0.742578  ], #51\n[ 0.551395,     0.727388  ], #52\n[ 0.639268,     0.745405  ], #53\n[ 0.726104,     0.780233  ], #54\n[ 0.642159,     0.864805  ], #55\n[ 0.556721,     0.902192  ], #56\n[ 0.490127,     0.909281  ], #57\n[ 0.423532,     0.902192  ], #58\n[ 0.338094,     0.864805  ], #59\n[ 0.290379,     0.784792  ], #60\n[ 0.428096,     0.778746  ], #61\n[ 0.490127,     0.785343  ], #62\n[ 0.552157,     0.778746  ], #63\n[ 0.689874,     0.784792  ], #64\n[ 0.553364,     0.824182  ], #65\n[ 0.490127,     0.831803  ], #66\n[ 0.42689 ,     0.824182  ]  #67\n], dtype=np.float32)\n\n\nlandmarks_2D_new = np.array([\n[ 0.000213256,  0.106454  ], #17\n[ 0.0752622,    0.038915  ], #18\n[ 0.18113,      0.0187482 ], #19\n[ 0.29077,      0.0344891 ], #20\n[ 0.393397,     0.0773906 ], #21\n[ 0.586856,     0.0773906 ], #22\n[ 0.689483,     0.0344891 ], #23\n[ 0.799124,     0.0187482 ], #24\n[ 0.904991,     0.038915  ], #25\n[ 0.98004,      0.106454  ], #26\n[ 0.490127,     0.203352  ], #27\n[ 0.490127,     0.307009  ], #28\n[ 0.490127,     0.409805  ], #29\n[ 0.490127,     0.515625  ], #30\n[ 0.36688,      0.587326  ], #31\n[ 0.426036,     0.609345  ], #32\n[ 0.490127,     0.628106  ], #33\n[ 0.554217,     0.609345  ], #34\n[ 0.613373,     0.587326  ], #35\n[ 0.121737,     0.216423  ], #36\n[ 0.187122,     0.178758  ], #37\n[ 0.265825,     0.179852  ], #38\n[ 0.334606,     0.231733  ], #39\n[ 0.260918,     0.245099  ], #40\n[ 0.182743,     0.244077  ], #41\n[ 0.645647,     0.231733  ], #42\n[ 0.714428,     0.179852  ], #43\n[ 0.793132,     0.178758  ], #44\n[ 0.858516,     0.216423  ], #45\n[ 0.79751,      0.244077  ], #46\n[ 0.719335,     0.245099  ], #47\n[ 0.254149,     0.780233  ], #48\n[ 0.726104,     0.780233  ], #54\n], dtype=np.float32)\n\nmouth_center_landmarks_2D = np.array([\n    [-4.4202591e-07,  4.4916576e-01],  #48\n    [ 1.8399176e-01,  3.7537053e-01],  #49\n    [ 3.7018123e-01,  3.3719531e-01],  #50\n    [ 5.0000089e-01,  3.6938059e-01],  #51\n    [ 6.2981832e-01,  3.3719531e-01],  #52\n    [ 8.1600773e-01,  3.7537053e-01],  #53\n    [ 1.0000000e+00,  4.4916576e-01],  #54\n    [ 8.2213330e-01,  6.2836081e-01],  #55\n    [ 6.4110327e-01,  7.0757812e-01],  #56\n    [ 5.0000089e-01,  7.2259867e-01],  #57\n    [ 3.5889623e-01,  7.0757812e-01],  #58\n    [ 1.7786618e-01,  6.2836081e-01],  #59\n    [ 7.6765373e-02,  4.5882553e-01],  #60\n    [ 3.6856663e-01,  4.4601500e-01],  #61\n    [ 5.0000089e-01,  4.5999300e-01],  #62\n    [ 6.3143289e-01,  4.4601500e-01],  #63\n    [ 9.2323411e-01,  4.5882553e-01],  #64\n    [ 6.3399029e-01,  5.4228687e-01],  #65\n    [ 5.0000089e-01,  5.5843467e-01],  #66\n    [ 3.6601129e-01,  5.4228687e-01]   #67\n], dtype=np.float32)\n\n# 68 point landmark definitions\nlandmarks_68_pt = { \"mouth\": (48,68),\n                    \"right_eyebrow\": (17, 22),\n                    \"left_eyebrow\": (22, 27),\n                    \"right_eye\": (36, 42),\n                    \"left_eye\": (42, 48),\n                    \"nose\": (27, 36), # missed one point\n                    \"jaw\": (0, 17) }\n\nlandmarks_68_3D = np.array( [\n[-73.393523  , -29.801432   , 47.667532   ], #00\n[-72.775014  , -10.949766   , 45.909403   ], #01\n[-70.533638  , 7.929818     , 44.842580   ], #02\n[-66.850058  , 26.074280    , 43.141114   ], #03\n[-59.790187  , 42.564390    , 38.635298   ], #04\n[-48.368973  , 56.481080    , 30.750622   ], #05\n[-34.121101  , 67.246992    , 18.456453   ], #06\n[-17.875411  , 75.056892    , 3.609035    ], #07\n[0.098749    , 77.061286    , -0.881698   ], #08\n[17.477031   , 74.758448    , 5.181201    ], #09\n[32.648966   , 66.929021    , 19.176563   ], #10\n[46.372358   , 56.311389    , 30.770570   ], #11\n[57.343480   , 42.419126    , 37.628629   ], #12\n[64.388482   , 25.455880    , 40.886309   ], #13\n[68.212038   , 6.990805     , 42.281449   ], #14\n[70.486405   , -11.666193   , 44.142567   ], #15\n[71.375822   , -30.365191   , 47.140426   ], #16\n[-61.119406  , -49.361602   , 14.254422   ], #17\n[-51.287588  , -58.769795   , 7.268147    ], #18\n[-37.804800  , -61.996155   , 0.442051    ], #19\n[-24.022754  , -61.033399   , -6.606501   ], #20\n[-11.635713  , -56.686759   , -11.967398  ], #21\n[12.056636   , -57.391033   , -12.051204  ], #22\n[25.106256   , -61.902186   , -7.315098   ], #23\n[38.338588   , -62.777713   , -1.022953   ], #24\n[51.191007   , -59.302347   , 5.349435    ], #25\n[60.053851   , -50.190255   , 11.615746   ], #26\n[0.653940    , -42.193790   , -13.380835  ], #27\n[0.804809    , -30.993721   , -21.150853  ], #28\n[0.992204    , -19.944596   , -29.284036  ], #29\n[1.226783    , -8.414541    , -36.948060  ], #00\n[-14.772472  , 2.598255     , -20.132003  ], #01\n[-7.180239   , 4.751589     , -23.536684  ], #02\n[0.555920    , 6.562900     , -25.944448  ], #03\n[8.272499    , 4.661005     , -23.695741  ], #04\n[15.214351   , 2.643046     , -20.858157  ], #05\n[-46.047290  , -37.471411   , 7.037989    ], #06\n[-37.674688  , -42.730510   , 3.021217    ], #07\n[-27.883856  , -42.711517   , 1.353629    ], #08\n[-19.648268  , -36.754742   , -0.111088   ], #09\n[-28.272965  , -35.134493   , -0.147273   ], #10\n[-38.082418  , -34.919043   , 1.476612    ], #11\n[19.265868   , -37.032306   , -0.665746   ], #12\n[27.894191   , -43.342445   , 0.247660    ], #13\n[37.437529   , -43.110822   , 1.696435    ], #14\n[45.170805   , -38.086515   , 4.894163    ], #15\n[38.196454   , -35.532024   , 0.282961    ], #16\n[28.764989   , -35.484289   , -1.172675   ], #17\n[-28.916267  , 28.612716    , -2.240310   ], #18\n[-17.533194  , 22.172187    , -15.934335  ], #19\n[-6.684590   , 19.029051    , -22.611355  ], #20\n[0.381001    , 20.721118    , -23.748437  ], #21\n[8.375443    , 19.035460    , -22.721995  ], #22\n[18.876618   , 22.394109    , -15.610679  ], #23\n[28.794412   , 28.079924    , -3.217393   ], #24\n[19.057574   , 36.298248    , -14.987997  ], #25\n[8.956375    , 39.634575    , -22.554245  ], #26\n[0.381549    , 40.395647    , -23.591626  ], #27\n[-7.428895   , 39.836405    , -22.406106  ], #28\n[-18.160634  , 36.677899    , -15.121907  ], #29\n[-24.377490  , 28.677771    , -4.785684   ], #30\n[-6.897633   , 25.475976    , -20.893742  ], #31\n[0.340663    , 26.014269    , -22.220479  ], #32\n[8.444722    , 25.326198    , -21.025520  ], #33\n[24.474473   , 28.323008    , -5.712776   ], #34\n[8.449166    , 30.596216    , -20.671489  ], #35\n[0.205322    , 31.408738    , -21.903670  ], #36 \n[-7.198266   , 30.844876    , -20.328022  ]  #37\n], dtype=np.float32)\n\nFaceType_to_padding_remove_align = {\n    FaceType.HALF: (0.0, False),\n    FaceType.MID_FULL: (0.0675, False),\n    FaceType.FULL: (0.2109375, False),\n    FaceType.FULL_NO_ALIGN: (0.2109375, True),\n    FaceType.WHOLE_FACE: (0.40, False),\n    FaceType.HEAD: (0.70, False),\n    FaceType.HEAD_NO_ALIGN: (0.70, True),\n}\n\ndef convert_98_to_68(lmrks):\n    #jaw\n    result = [ lmrks[0] ]\n    for i in range(2,16,2):\n        result += [ ( lmrks[i] + (lmrks[i-1]+lmrks[i+1])/2 ) / 2  ]\n    result += [ lmrks[16] ]\n    for i in range(18,32,2):\n        result += [ ( lmrks[i] + (lmrks[i-1]+lmrks[i+1])/2 ) / 2  ]\n    result += [ lmrks[32] ]\n\n    #eyebrows averaging\n    result += [ lmrks[33],\n                (lmrks[34]+lmrks[41])/2,\n                (lmrks[35]+lmrks[40])/2,\n                (lmrks[36]+lmrks[39])/2,\n                (lmrks[37]+lmrks[38])/2,\n              ]\n\n    result += [ (lmrks[42]+lmrks[50])/2,\n                (lmrks[43]+lmrks[49])/2,\n                (lmrks[44]+lmrks[48])/2,\n                (lmrks[45]+lmrks[47])/2,\n                lmrks[46]\n              ]\n\n    #nose\n    result += list ( lmrks[51:60] )\n\n    #left eye (from our view)\n    result += [ lmrks[60],\n                lmrks[61],\n                lmrks[63],\n                lmrks[64],\n                lmrks[65],\n                lmrks[67] ]\n\n    #right eye\n    result += [ lmrks[68],\n                lmrks[69],\n                lmrks[71],\n                lmrks[72],\n                lmrks[73],\n                lmrks[75] ]\n\n    #mouth\n    result += list ( lmrks[76:96] )\n\n    return np.concatenate (result).reshape ( (68,2) )\n\ndef transform_points(points, mat, invert=False):\n    if invert:\n        mat = cv2.invertAffineTransform (mat)\n    points = np.expand_dims(points, axis=1)\n    points = cv2.transform(points, mat, points.shape)\n    points = np.squeeze(points)\n    return points\n\ndef get_transform_mat (image_landmarks, output_size, face_type, scale=1.0):\n    if not isinstance(image_landmarks, np.ndarray):\n        image_landmarks = np.array (image_landmarks)\n\n\n    # estimate landmarks transform from global space to local aligned space with bounds [0..1]\n    mat = umeyama( np.concatenate ( [ image_landmarks[17:49] , image_landmarks[54:55] ] ) , landmarks_2D_new, True)[0:2]\n\n    # get corner points in global space\n    g_p = transform_points (  np.float32([(0,0),(1,0),(1,1),(0,1),(0.5,0.5) ]) , mat, True)\n    g_c = g_p[4]\n\n    # calc diagonal vectors between corners in global space\n    tb_diag_vec = (g_p[2]-g_p[0]).astype(np.float32)\n    tb_diag_vec /= npla.norm(tb_diag_vec)\n    bt_diag_vec = (g_p[1]-g_p[3]).astype(np.float32)\n    bt_diag_vec /= npla.norm(bt_diag_vec)\n\n    # calc modifier of diagonal vectors for scale and padding value\n    padding, remove_align = FaceType_to_padding_remove_align.get(face_type, 0.0)\n    mod = (1.0 / scale)* ( npla.norm(g_p[0]-g_p[2])*(padding*np.sqrt(2.0) + 0.5) )\n\n    if face_type == FaceType.WHOLE_FACE:\n        # adjust vertical offset for WHOLE_FACE, 7% below in order to cover more forehead\n        vec = (g_p[0]-g_p[3]).astype(np.float32)\n        vec_len = npla.norm(vec)\n        vec /= vec_len\n        g_c += vec*vec_len*0.07\n\n    elif face_type == FaceType.HEAD:\n        # assuming image_landmarks are 3D_Landmarks extracted for HEAD,\n        # adjust horizontal offset according to estimated yaw        \n        yaw = estimate_averaged_yaw(transform_points (image_landmarks, mat, False))\n        \n        hvec = (g_p[0]-g_p[1]).astype(np.float32)\n        hvec_len = npla.norm(hvec)\n        hvec /= hvec_len        \n\n        yaw *= np.abs(math.tanh(yaw*2)) # Damp near zero\n        \n        g_c -= hvec * (yaw * hvec_len / 2.0)                     \n\n        # adjust vertical offset for HEAD, 50% below\n        vvec = (g_p[0]-g_p[3]).astype(np.float32)\n        vvec_len = npla.norm(vvec)\n        vvec /= vvec_len\n        g_c += vvec*vvec_len*0.50\n\n    # calc 3 points in global space to estimate 2d affine transform\n    if not remove_align:\n        l_t = np.array( [ g_c - tb_diag_vec*mod,\n                          g_c + bt_diag_vec*mod,\n                          g_c + tb_diag_vec*mod ] )\n    else:\n        # remove_align - face will be centered in the frame but not aligned\n        l_t = np.array( [ g_c - tb_diag_vec*mod,\n                          g_c + bt_diag_vec*mod,\n                          g_c + tb_diag_vec*mod,\n                          g_c - bt_diag_vec*mod,\n                         ] )\n\n        # get area of face square in global space\n        area = mathlib.polygon_area(l_t[:,0], l_t[:,1] )\n\n        # calc side of square\n        side = np.float32(math.sqrt(area) / 2)\n\n        # calc 3 points with unrotated square\n        l_t = np.array( [ g_c + [-side,-side],\n                          g_c + [ side,-side],\n                          g_c + [ side, side] ] )\n\n    # calc affine transform from 3 global space points to 3 local space points size of 'output_size'\n    pts2 = np.float32(( (0,0),(output_size,0),(output_size,output_size) ))\n    mat = cv2.getAffineTransform(l_t,pts2)\n    return mat\n\ndef get_rect_from_landmarks(image_landmarks):\n    mat = get_transform_mat(image_landmarks, 256, FaceType.FULL_NO_ALIGN)\n\n    g_p = transform_points (  np.float32([(0,0),(255,255) ]) , mat, True)\n\n    (l,t,r,b) = g_p[0][0], g_p[0][1], g_p[1][0], g_p[1][1]\n\n    return (l,t,r,b)\n\ndef expand_eyebrows(lmrks, eyebrows_expand_mod=1.0):\n    if len(lmrks) != 68:\n        raise Exception('works only with 68 landmarks')\n    lmrks = np.array( lmrks.copy(), dtype=np.int )\n\n    # #nose\n    ml_pnt = (lmrks[36] + lmrks[0]) // 2\n    mr_pnt = (lmrks[16] + lmrks[45]) // 2\n\n    # mid points between the mid points and eye\n    ql_pnt = (lmrks[36] + ml_pnt) // 2\n    qr_pnt = (lmrks[45] + mr_pnt) // 2\n\n    # Top of the eye arrays\n    bot_l = np.array((ql_pnt, lmrks[36], lmrks[37], lmrks[38], lmrks[39]))\n    bot_r = np.array((lmrks[42], lmrks[43], lmrks[44], lmrks[45], qr_pnt))\n\n    # Eyebrow arrays\n    top_l = lmrks[17:22]\n    top_r = lmrks[22:27]\n\n    # Adjust eyebrow arrays\n    lmrks[17:22] = top_l + eyebrows_expand_mod * 0.5 * (top_l - bot_l)\n    lmrks[22:27] = top_r + eyebrows_expand_mod * 0.5 * (top_r - bot_r)\n    return lmrks\n\n\n\n\ndef get_image_hull_mask (image_shape, image_landmarks, eyebrows_expand_mod=1.0 ):\n    hull_mask = np.zeros(image_shape[0:2]+(1,),dtype=np.float32)\n\n    lmrks = expand_eyebrows(image_landmarks, eyebrows_expand_mod)\n\n    r_jaw = (lmrks[0:9], lmrks[17:18])\n    l_jaw = (lmrks[8:17], lmrks[26:27])\n    r_cheek = (lmrks[17:20], lmrks[8:9])\n    l_cheek = (lmrks[24:27], lmrks[8:9])\n    nose_ridge = (lmrks[19:25], lmrks[8:9],)\n    r_eye = (lmrks[17:22], lmrks[27:28], lmrks[31:36], lmrks[8:9])\n    l_eye = (lmrks[22:27], lmrks[27:28], lmrks[31:36], lmrks[8:9])\n    nose = (lmrks[27:31], lmrks[31:36])\n    parts = [r_jaw, l_jaw, r_cheek, l_cheek, nose_ridge, r_eye, l_eye, nose]\n\n    for item in parts:\n        merged = np.concatenate(item)\n        cv2.fillConvexPoly(hull_mask, cv2.convexHull(merged), (1,) )\n\n    return hull_mask\n\ndef get_image_eye_mask (image_shape, image_landmarks):\n    if len(image_landmarks) != 68:\n        raise Exception('get_image_eye_mask works only with 68 landmarks')\n\n    h,w,c = image_shape\n\n    hull_mask = np.zeros( (h,w,1),dtype=np.float32)\n\n    image_landmarks = image_landmarks.astype(np.int)\n\n    cv2.fillConvexPoly( hull_mask, cv2.convexHull( image_landmarks[36:42]), (1,) )\n    cv2.fillConvexPoly( hull_mask, cv2.convexHull( image_landmarks[42:48]), (1,) )\n\n    dilate = h // 32\n    hull_mask = cv2.dilate(hull_mask, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(dilate,dilate)), iterations = 1 )\n\n    blur = h // 16\n    blur = blur + (1-blur % 2)\n    hull_mask = cv2.GaussianBlur(hull_mask, (blur, blur) , 0)\n    hull_mask = hull_mask[...,None]\n\n    return hull_mask\n\ndef get_image_mouth_mask (image_shape, image_landmarks):\n    if len(image_landmarks) != 68:\n        raise Exception('get_image_eye_mask works only with 68 landmarks')\n\n    h,w,c = image_shape\n\n    hull_mask = np.zeros( (h,w,1),dtype=np.float32)\n\n    image_landmarks = image_landmarks.astype(np.int)\n\n    cv2.fillConvexPoly( hull_mask, cv2.convexHull( image_landmarks[60:]), (1,) )\n\n    dilate = h // 32\n    hull_mask = cv2.dilate(hull_mask, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(dilate,dilate)), iterations = 1 )\n\n    blur = h // 16\n    blur = blur + (1-blur % 2)\n    hull_mask = cv2.GaussianBlur(hull_mask, (blur, blur) , 0)\n    hull_mask = hull_mask[...,None]\n\n    return hull_mask\n    \ndef alpha_to_color (img_alpha, color):\n    if len(img_alpha.shape) == 2:\n        img_alpha = img_alpha[...,None]\n    h,w,c = img_alpha.shape\n    result = np.zeros( (h,w, len(color) ), dtype=np.float32 )\n    result[:,:] = color\n\n    return result * img_alpha\n\n\n\ndef get_cmask (image_shape, lmrks, eyebrows_expand_mod=1.0):\n    h,w,c = image_shape\n\n    hull = get_image_hull_mask (image_shape, lmrks, eyebrows_expand_mod )\n\n    result = np.zeros( (h,w,3), dtype=np.float32 )\n\n\n\n    def process(w,h, data ):\n        d = {}\n        cur_lc = 0\n        all_lines = []\n        for s, pts_loop_ar in data:\n            lines = []\n            for pts, loop in pts_loop_ar:\n                pts_len = len(pts)\n                lines.append ( [ [ pts[i], pts[(i+1) % pts_len ] ]  for i in range(pts_len - (0 if loop else 1) ) ] )\n            lines = np.concatenate (lines)\n\n            lc = lines.shape[0]\n            all_lines.append(lines)\n            d[s] = cur_lc, cur_lc+lc\n            cur_lc += lc\n        all_lines = np.concatenate (all_lines, 0)\n\n        #calculate signed distance for all points and lines\n        line_count = all_lines.shape[0]\n        pts_count = w*h\n\n        all_lines = np.repeat ( all_lines[None,...], pts_count, axis=0 ).reshape ( (pts_count*line_count,2,2) )\n\n        pts = np.empty( (h,w,line_count,2), dtype=np.float32 )\n        pts[...,1] = np.arange(h)[:,None,None]\n        pts[...,0] = np.arange(w)[:,None]\n        pts = pts.reshape ( (h*w*line_count, -1) )\n\n        a = all_lines[:,0,:]\n        b = all_lines[:,1,:]\n        pa = pts-a\n        ba = b-a\n        ph = np.clip ( np.einsum('ij,ij->i', pa, ba) / np.einsum('ij,ij->i', ba, ba), 0, 1 )\n        dists = npla.norm ( pa - ba*ph[...,None], axis=1).reshape ( (h,w,line_count) )\n\n        def get_dists(name, thickness=0):\n            s,e = d[name]\n            result = dists[...,s:e]\n            if thickness != 0:\n                result = np.abs(result)-thickness\n            return np.min (result, axis=-1)\n\n        return get_dists\n\n    l_eye = lmrks[42:48]\n    r_eye = lmrks[36:42]\n    l_brow = lmrks[22:27]\n    r_brow = lmrks[17:22]\n    mouth = lmrks[48:60]\n\n    up_nose = np.concatenate( (lmrks[27:31], lmrks[33:34]) )\n    down_nose = lmrks[31:36]\n    nose = np.concatenate ( (up_nose, down_nose) )\n\n    gdf = process ( w,h,\n                         (\n                          ('eyes',  ((l_eye, True), (r_eye, True)) ),\n                          ('brows', ((l_brow, False), (r_brow,False)) ),\n                          ('up_nose', ((up_nose, False),) ),\n                          ('down_nose', ((down_nose, False),) ),\n                          ('mouth', ((mouth, True),) ),\n                         )\n                        )\n\n    eyes_fall_dist = w // 32\n    eyes_thickness = max( w // 64, 1 )\n\n    brows_fall_dist = w // 32\n    brows_thickness = max( w // 256, 1 )\n\n    nose_fall_dist = w / 12\n    nose_thickness = max( w // 96, 1 )\n\n    mouth_fall_dist = w // 32\n    mouth_thickness = max( w // 64, 1 )\n\n    eyes_mask = gdf('eyes',eyes_thickness)\n    eyes_mask = 1-np.clip( eyes_mask/ eyes_fall_dist, 0, 1)\n    #eyes_mask = np.clip ( 1- ( np.sqrt( np.maximum(eyes_mask,0) ) / eyes_fall_dist ), 0, 1)\n    #eyes_mask = np.clip ( 1- ( np.cbrt( np.maximum(eyes_mask,0) ) / eyes_fall_dist ), 0, 1)\n\n    brows_mask = gdf('brows', brows_thickness)\n    brows_mask = 1-np.clip( brows_mask / brows_fall_dist, 0, 1)\n    #brows_mask = np.clip ( 1- ( np.sqrt( np.maximum(brows_mask,0) ) / brows_fall_dist ), 0, 1)\n\n    mouth_mask = gdf('mouth', mouth_thickness)\n    mouth_mask = 1-np.clip( mouth_mask / mouth_fall_dist, 0, 1)\n    #mouth_mask = np.clip ( 1- ( np.sqrt( np.maximum(mouth_mask,0) ) / mouth_fall_dist ), 0, 1)\n\n    def blend(a,b,k):\n        x = np.clip ( 0.5+0.5*(b-a)/k, 0.0, 1.0 )\n        return (a-b)*x+b - k*x*(1.0-x)\n\n\n    #nose_mask = (a-b)*x+b - k*x*(1.0-x)\n\n    #nose_mask = np.minimum (up_nose_mask , down_nose_mask )\n    #nose_mask = 1-np.clip( nose_mask / nose_fall_dist, 0, 1)\n\n    nose_mask = blend ( gdf('up_nose', nose_thickness), gdf('down_nose', nose_thickness), nose_thickness*3 )\n    nose_mask = 1-np.clip( nose_mask / nose_fall_dist, 0, 1)\n\n    up_nose_mask = gdf('up_nose', nose_thickness)\n    up_nose_mask = 1-np.clip( up_nose_mask / nose_fall_dist, 0, 1)\n    #up_nose_mask = np.clip ( 1- ( np.cbrt( np.maximum(up_nose_mask,0) ) / nose_fall_dist ), 0, 1)\n\n    down_nose_mask = gdf('down_nose', nose_thickness)\n    down_nose_mask = 1-np.clip( down_nose_mask / nose_fall_dist, 0, 1)\n    #down_nose_mask = np.clip ( 1- ( np.cbrt( np.maximum(down_nose_mask,0) ) / nose_fall_dist ), 0, 1)\n\n    #nose_mask = np.clip( up_nose_mask + down_nose_mask, 0, 1 )\n    #nose_mask /= np.max(nose_mask)\n    #nose_mask = np.maximum (up_nose_mask , down_nose_mask )\n    #nose_mask = down_nose_mask\n\n    #nose_mask = np.zeros_like(nose_mask)\n\n    eyes_mask = eyes_mask * (1-mouth_mask)\n    nose_mask = nose_mask * (1-eyes_mask)\n\n    hull_mask = hull[...,0].copy()\n    hull_mask = hull_mask * (1-eyes_mask) * (1-brows_mask) * (1-nose_mask) * (1-mouth_mask)\n\n    #eyes_mask = eyes_mask * (1-nose_mask)\n\n    mouth_mask= mouth_mask * (1-nose_mask)\n\n    brows_mask = brows_mask * (1-nose_mask)* (1-eyes_mask )\n\n    hull_mask = alpha_to_color(hull_mask, (0,1,0) )\n    eyes_mask = alpha_to_color(eyes_mask, (1,0,0) )\n    brows_mask = alpha_to_color(brows_mask, (0,0,1) )\n    nose_mask = alpha_to_color(nose_mask, (0,1,1) )\n    mouth_mask = alpha_to_color(mouth_mask, (0,0,1) )\n\n    #nose_mask = np.maximum( up_nose_mask, down_nose_mask )\n\n    result = hull_mask + mouth_mask+ nose_mask + brows_mask  + eyes_mask\n    result *= hull\n    #result = np.clip (result, 0, 1)\n    return result\n\ndef blur_image_hull_mask (hull_mask):\n\n    maxregion = np.argwhere(hull_mask==1.0)\n    miny,minx = maxregion.min(axis=0)[:2]\n    maxy,maxx = maxregion.max(axis=0)[:2]\n    lenx = maxx - minx;\n    leny = maxy - miny;\n    masky = int(minx+(lenx//2))\n    maskx = int(miny+(leny//2))\n    lowest_len = min (lenx, leny)\n    ero = int( lowest_len * 0.085 )\n    blur = int( lowest_len * 0.10 )\n\n    hull_mask = cv2.erode(hull_mask, cv2.getStructuringElement(cv2.MORPH_ELLIPSE,(ero,ero)), iterations = 1 )\n    hull_mask = cv2.blur(hull_mask, (blur, blur) )\n    hull_mask = np.expand_dims (hull_mask,-1)\n\n    return hull_mask\n\nmirror_idxs = [\n    [0,16],\n    [1,15],\n    [2,14],\n    [3,13],\n    [4,12],\n    [5,11],\n    [6,10],\n    [7,9],\n\n    [17,26],\n    [18,25],\n    [19,24],\n    [20,23],\n    [21,22],\n\n    [36,45],\n    [37,44],\n    [38,43],\n    [39,42],\n    [40,47],\n    [41,46],\n\n    [31,35],\n    [32,34],\n\n    [50,52],\n    [49,53],\n    [48,54],\n    [59,55],\n    [58,56],\n    [67,65],\n    [60,64],\n    [61,63] ]\n\ndef mirror_landmarks (landmarks, val):\n    result = landmarks.copy()\n\n    for idx in mirror_idxs:\n        result [ idx ] = result [ idx[::-1] ]\n\n    result[:,0] = val - result[:,0] - 1\n    return result\n\ndef get_face_struct_mask (image_shape, image_landmarks, eyebrows_expand_mod=1.0, color=(1,) ):\n    mask = np.zeros(image_shape[0:2]+( len(color),),dtype=np.float32)\n    lmrks = expand_eyebrows(image_landmarks, eyebrows_expand_mod)\n    draw_landmarks (mask, image_landmarks, color=color, draw_circles=False, thickness=2)\n    return mask\n\ndef draw_landmarks (image, image_landmarks, color=(0,255,0), draw_circles=True, thickness=1, transparent_mask=False):\n    if len(image_landmarks) != 68:\n        raise Exception('get_image_eye_mask works only with 68 landmarks')\n\n    int_lmrks = np.array(image_landmarks, dtype=np.int)\n\n    jaw = int_lmrks[slice(*landmarks_68_pt[\"jaw\"])]\n    right_eyebrow = int_lmrks[slice(*landmarks_68_pt[\"right_eyebrow\"])]\n    left_eyebrow = int_lmrks[slice(*landmarks_68_pt[\"left_eyebrow\"])]\n    mouth = int_lmrks[slice(*landmarks_68_pt[\"mouth\"])]\n    right_eye = int_lmrks[slice(*landmarks_68_pt[\"right_eye\"])]\n    left_eye = int_lmrks[slice(*landmarks_68_pt[\"left_eye\"])]\n    nose = int_lmrks[slice(*landmarks_68_pt[\"nose\"])]\n\n    # open shapes\n    cv2.polylines(image, tuple(np.array([v]) for v in ( right_eyebrow, jaw, left_eyebrow, np.concatenate((nose, [nose[-6]])) )),\n                  False, color, thickness=thickness, lineType=cv2.LINE_AA)\n    # closed shapes\n    cv2.polylines(image, tuple(np.array([v]) for v in (right_eye, left_eye, mouth)),\n                  True, color, thickness=thickness, lineType=cv2.LINE_AA)\n\n    if draw_circles:\n        # the rest of the cicles\n        for x, y in np.concatenate((right_eyebrow, left_eyebrow, mouth, right_eye, left_eye, nose), axis=0):\n            cv2.circle(image, (x, y), 1, color, 1, lineType=cv2.LINE_AA)\n        # jaw big circles\n        for x, y in jaw:\n            cv2.circle(image, (x, y), 2, color, lineType=cv2.LINE_AA)\n\n    if transparent_mask:\n        mask = get_image_hull_mask (image.shape, image_landmarks)\n        image[...] = ( image * (1-mask) + image * mask / 2 )[...]\n\ndef draw_rect_landmarks (image, rect, image_landmarks, face_type, face_size=256, transparent_mask=False, landmarks_color=(0,255,0)):\n    draw_landmarks(image, image_landmarks, color=landmarks_color, transparent_mask=transparent_mask)\n    imagelib.draw_rect (image, rect, (255,0,0), 2 )\n\n    image_to_face_mat = get_transform_mat (image_landmarks, face_size, face_type)\n    points = transform_points ( [ (0,0), (0,face_size-1), (face_size-1, face_size-1), (face_size-1,0) ], image_to_face_mat, True)\n    imagelib.draw_polygon (image, points, (0,0,255), 2)\n\n    points = transform_points ( [ ( int(face_size*0.05), 0), ( int(face_size*0.1), int(face_size*0.1) ), ( 0, int(face_size*0.1) ) ], image_to_face_mat, True)\n    imagelib.draw_polygon (image, points, (0,0,255), 2)\n\ndef calc_face_pitch(landmarks):\n    if not isinstance(landmarks, np.ndarray):\n        landmarks = np.array (landmarks)\n    t = ( (landmarks[6][1]-landmarks[8][1]) + (landmarks[10][1]-landmarks[8][1]) ) / 2.0\n    b = landmarks[8][1]\n    return float(b-t)\n\ndef estimate_averaged_yaw(landmarks):\n    # Works much better than solvePnP if landmarks from \"3DFAN\"\n    if not isinstance(landmarks, np.ndarray):\n        landmarks = np.array (landmarks)\n    l = ( (landmarks[27][0]-landmarks[0][0]) + (landmarks[28][0]-landmarks[1][0]) + (landmarks[29][0]-landmarks[2][0]) ) / 3.0   \n    r = ( (landmarks[16][0]-landmarks[27][0]) + (landmarks[15][0]-landmarks[28][0]) + (landmarks[14][0]-landmarks[29][0]) ) / 3.0\n    return float(r-l)\n    \ndef estimate_pitch_yaw_roll(aligned_landmarks, size=256):\n    \"\"\"\n    returns pitch,yaw,roll [-pi/2...+pi/2]\n    \"\"\"\n    shape = (size,size)\n    focal_length = shape[1]\n    camera_center = (shape[1] / 2, shape[0] / 2)\n    camera_matrix = np.array(\n        [[focal_length, 0, camera_center[0]],\n         [0, focal_length, camera_center[1]],\n         [0, 0, 1]], dtype=np.float32)\n\n    (_, rotation_vector, _) = cv2.solvePnP(\n        np.concatenate( (landmarks_68_3D[:27],   landmarks_68_3D[30:36]) , axis=0) ,\n        np.concatenate( (aligned_landmarks[:27], aligned_landmarks[30:36]) , axis=0).astype(np.float32),\n        camera_matrix,\n        np.zeros((4, 1)) )\n\n    pitch, yaw, roll = mathlib.rotationMatrixToEulerAngles( cv2.Rodrigues(rotation_vector)[0] )\n   \n    half_pi = math.pi / 2.0\n    pitch = np.clip ( pitch, -half_pi, half_pi )\n    yaw   = np.clip ( yaw ,  -half_pi, half_pi )\n    roll  = np.clip ( roll,  -half_pi, half_pi )\n\n    return -pitch, yaw, roll\n\n#if remove_align:\n#    bbox = transform_points ( [ (0,0), (0,output_size), (output_size, output_size), (output_size,0) ], mat, True)\n#    #import code\n#    #code.interact(local=dict(globals(), **locals()))\n#    area = mathlib.polygon_area(bbox[:,0], bbox[:,1] )\n#    side = math.sqrt(area) / 2\n#    center = transform_points ( [(output_size/2,output_size/2)], mat, True)\n#    pts1 = np.float32(( center+[-side,-side], center+[side,-side], center+[side,-side] ))\n#    pts2 = np.float32([[0,0],[output_size,0],[0,output_size]])\n#    mat = cv2.getAffineTransform(pts1,pts2)\n#if full_face_align_top and (face_type == FaceType.FULL or face_type == FaceType.FULL_NO_ALIGN):\n#    #lmrks2 = expand_eyebrows(image_landmarks)\n#    #lmrks2_ = transform_points( [ lmrks2[19], lmrks2[24] ], mat, False )\n#    #y_diff = np.float32( (0,np.min(lmrks2_[:,1])) )\n#    #y_diff = transform_points( [ np.float32( (0,0) ), y_diff], mat, True)\n#    #y_diff = y_diff[1]-y_diff[0]\n#\n#    x_diff = np.float32((0,0))\n#\n#    lmrks2_ = transform_points( [ image_landmarks[0], image_landmarks[16] ], mat, False )\n#    if lmrks2_[0,0] < 0:\n#        x_diff = lmrks2_[0,0]\n#        x_diff = transform_points( [ np.float32( (0,0) ), np.float32((x_diff,0)) ], mat, True)\n#        x_diff = x_diff[1]-x_diff[0]\n#    elif lmrks2_[1,0] >= output_size:\n#        x_diff = lmrks2_[1,0]-(output_size-1)\n#        x_diff = transform_points( [ np.float32( (0,0) ), np.float32((x_diff,0)) ], mat, True)\n#        x_diff = x_diff[1]-x_diff[0]\n#\n#    mat = cv2.getAffineTransform( l_t+y_diff+x_diff ,pts2)\n\n\n\"\"\"\ndef get_averaged_transform_mat (img_landmarks,\n                                img_landmarks_prev,\n                                img_landmarks_next,\n                                average_frame_count,\n                                average_center_frame_count,\n                                output_size, face_type, scale=1.0):\n\n    l_c_list = []\n    tb_diag_vec_list = []\n    bt_diag_vec_list = []\n    mod_list = []\n\n    count = max(average_frame_count,average_center_frame_count)\n    for i in range ( -count, count+1, 1 ):\n        if i < 0:\n            lmrks = img_landmarks_prev[i] if -i < len(img_landmarks_prev) else None\n        elif i > 0:\n            lmrks = img_landmarks_next[i] if i < len(img_landmarks_next) else None\n        else:\n            lmrks = img_landmarks\n\n        if lmrks is None:\n            continue\n\n        l_c, tb_diag_vec, bt_diag_vec, mod = get_transform_mat_data (lmrks, face_type, scale=scale)\n\n        if i >= -average_frame_count and i <= average_frame_count:\n            tb_diag_vec_list.append(tb_diag_vec)\n            bt_diag_vec_list.append(bt_diag_vec)\n            mod_list.append(mod)\n\n        if i >= -average_center_frame_count and i <= average_center_frame_count:\n            l_c_list.append(l_c)\n\n    tb_diag_vec = np.mean( np.array(tb_diag_vec_list), axis=0 )\n    bt_diag_vec = np.mean( np.array(bt_diag_vec_list), axis=0 )\n    mod         = np.mean( np.array(mod_list), axis=0 )\n    l_c         = np.mean( np.array(l_c_list), axis=0 )\n\n    return get_transform_mat_by_data (l_c, tb_diag_vec, bt_diag_vec, mod, output_size, face_type)\n\n\ndef get_transform_mat (image_landmarks, output_size, face_type, scale=1.0):\n    if not isinstance(image_landmarks, np.ndarray):\n        image_landmarks = np.array (image_landmarks)\n\n    # get face padding value for FaceType\n    padding, remove_align = FaceType_to_padding_remove_align.get(face_type, 0.0)\n\n    # estimate landmarks transform from global space to local aligned space with bounds [0..1]\n    mat = umeyama( np.concatenate ( [ image_landmarks[17:49] , image_landmarks[54:55] ] ) , landmarks_2D_new, True)[0:2]\n\n    # get corner points in global space\n    l_p = transform_points (  np.float32([(0,0),(1,0),(1,1),(0,1),(0.5,0.5)]) , mat, True)\n    l_c = l_p[4]\n\n    # calc diagonal vectors between corners in global space\n    tb_diag_vec = (l_p[2]-l_p[0]).astype(np.float32)\n    tb_diag_vec /= npla.norm(tb_diag_vec)\n    bt_diag_vec = (l_p[1]-l_p[3]).astype(np.float32)\n    bt_diag_vec /= npla.norm(bt_diag_vec)\n\n    # calc modifier of diagonal vectors for scale and padding value\n    mod = (1.0 / scale)* ( npla.norm(l_p[0]-l_p[2])*(padding*np.sqrt(2.0) + 0.5) )\n\n    # calc 3 points in global space to estimate 2d affine transform\n    if not remove_align:\n        l_t = np.array( [ np.round( l_c - tb_diag_vec*mod ),\n                          np.round( l_c + bt_diag_vec*mod ),\n                          np.round( l_c + tb_diag_vec*mod ) ] )\n    else:\n        # remove_align - face will be centered in the frame but not aligned\n        l_t = np.array( [ np.round( l_c - tb_diag_vec*mod ),\n                          np.round( l_c + bt_diag_vec*mod ),\n                          np.round( l_c + tb_diag_vec*mod ),\n                          np.round( l_c - bt_diag_vec*mod ),\n                         ] )\n\n        # get area of face square in global space\n        area = mathlib.polygon_area(l_t[:,0], l_t[:,1] )\n\n        # calc side of square\n        side = np.float32(math.sqrt(area) / 2)\n\n        # calc 3 points with unrotated square\n        l_t = np.array( [ np.round( l_c + [-side,-side] ),\n                          np.round( l_c + [ side,-side] ),\n                          np.round( l_c + [ side, side] ) ] )\n\n    # calc affine transform from 3 global space points to 3 local space points size of 'output_size'\n    pts2 = np.float32(( (0,0),(output_size,0),(output_size,output_size) ))\n    mat = cv2.getAffineTransform(l_t,pts2)\n\n    return mat\n\"\"\"", "XSegEditor/QIconDB.py": "from PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\n\nclass QIconDB():\n    @staticmethod\n    def initialize(icon_path):\n        QIconDB.app_icon         = QIcon ( str(icon_path / 'app_icon.png') )\n        QIconDB.delete_poly      = QIcon ( str(icon_path / 'delete_poly.png') )\n        QIconDB.undo_pt          = QIcon ( str(icon_path / 'undo_pt.png') )\n        QIconDB.redo_pt          = QIcon ( str(icon_path / 'redo_pt.png') )\n        QIconDB.poly_color_red   = QIcon ( str(icon_path / 'poly_color_red.png') )\n        QIconDB.poly_color_green = QIcon ( str(icon_path / 'poly_color_green.png') )\n        QIconDB.poly_color_blue  = QIcon ( str(icon_path / 'poly_color_blue.png') )\n        QIconDB.poly_type_include = QIcon ( str(icon_path / 'poly_type_include.png') )\n        QIconDB.poly_type_exclude = QIcon ( str(icon_path / 'poly_type_exclude.png') )\n        QIconDB.left  = QIcon ( str(icon_path / 'left.png') )\n        QIconDB.right = QIcon ( str(icon_path / 'right.png') )\n        QIconDB.trashcan = QIcon ( str(icon_path / 'trashcan.png') )\n        QIconDB.pt_edit_mode = QIcon ( str(icon_path / 'pt_edit_mode.png') )\n        QIconDB.view_lock_center = QIcon ( str(icon_path / 'view_lock_center.png') )\n        QIconDB.view_baked = QIcon ( str(icon_path / 'view_baked.png') )\n        QIconDB.view_xseg = QIcon ( str(icon_path / 'view_xseg.png') )\n        QIconDB.view_xseg_overlay = QIcon ( str(icon_path / 'view_xseg_overlay.png') )\n        ", "XSegEditor/QCursorDB.py": "from PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n                                       \nclass QCursorDB():\n    @staticmethod\n    def initialize(cursor_path):\n        QCursorDB.cross_red = QCursor ( QPixmap ( str(cursor_path / 'cross_red.png') ) )\n        QCursorDB.cross_green = QCursor ( QPixmap ( str(cursor_path / 'cross_green.png') ) )\n        QCursorDB.cross_blue = QCursor ( QPixmap ( str(cursor_path / 'cross_blue.png') ) )\n", "XSegEditor/QImageDB.py": "from PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\nclass QImageDB():\n    @staticmethod\n    def initialize(image_path):\n        QImageDB.intro = QImage ( str(image_path / 'intro.png') )\n", "XSegEditor/QStringDB.py": "from localization import system_language\n\n\nclass QStringDB():\n    \n    @staticmethod\n    def initialize():\n        lang = system_language\n        \n        if lang not in ['en','ru','zh']:\n            lang = 'en'\n        \n        QStringDB.btn_poly_color_red_tip = {    'en' : 'Poly color scheme red',\n                                                'ru' : '\u041a\u0440\u0430\u0441\u043d\u0430\u044f \u0446\u0432\u0435\u0442\u043e\u0432\u0430\u044f \u0441\u0445\u0435\u043c\u0430 \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432',\n                                                'zh' : '\u9009\u533a\u914d\u8272\u65b9\u6848\u7ea2\u8272',\n                                           }[lang]\n                                           \n        QStringDB.btn_poly_color_green_tip = {  'en' : 'Poly color scheme green',\n                                                'ru' : '\u0417\u0435\u043b\u0451\u043d\u0430\u044f \u0446\u0432\u0435\u0442\u043e\u0432\u0430\u044f \u0441\u0445\u0435\u043c\u0430 \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432',\n                                                'zh' : '\u9009\u533a\u914d\u8272\u65b9\u6848\u7eff\u8272',\n                                           }[lang]\n                                           \n        QStringDB.btn_poly_color_blue_tip = {   'en' : 'Poly color scheme blue',\n                                                'ru' : '\u0421\u0438\u043d\u044f\u044f \u0446\u0432\u0435\u0442\u043e\u0432\u0430\u044f \u0441\u0445\u0435\u043c\u0430 \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432',\n                                                'zh' : '\u9009\u533a\u914d\u8272\u65b9\u6848\u84dd\u8272',\n                                           }[lang]\n                                           \n        QStringDB.btn_view_baked_mask_tip = {   'en' : 'View baked mask',\n                                                'ru' : '\u041f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0437\u0430\u043f\u0435\u0447\u0451\u043d\u0443\u044e \u043c\u0430\u0441\u043a\u0443',\n                                                'zh' : '\u67e5\u770b\u906e\u7f69\u901a\u9053',\n                                           }[lang]\n                                           \n        QStringDB.btn_view_xseg_mask_tip =  {   'en' : 'View trained XSeg mask',\n                                                'ru' : '\u041f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0442\u0440\u0435\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0443\u044e XSeg \u043c\u0430\u0441\u043a\u0443',\n                                                'zh' : '\u67e5\u770b\u5bfc\u5165\u540e\u7684XSeg\u906e\u7f69',\n                                            }[lang]\n                                            \n        QStringDB.btn_view_xseg_overlay_mask_tip =  {   'en' : 'View trained XSeg mask overlay face',\n                                                        'ru' : '\u041f\u043e\u0441\u043c\u043e\u0442\u0440\u0435\u0442\u044c \u0442\u0440\u0435\u043d\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0443\u044e XSeg \u043c\u0430\u0441\u043a\u0443 \u043f\u043e\u0432\u0435\u0440\u0445 \u043b\u0438\u0446\u0430',\n                                                        'zh' : '\u67e5\u770b\u5bfc\u5165\u540e\u7684XSeg\u906e\u7f69\u4e8e\u8138\u4e0a\u65b9',\n                                                    }[lang]\n                                           \n        QStringDB.btn_poly_type_include_tip = { 'en' : 'Poly include mode',\n                                                'ru' : '\u0420\u0435\u0436\u0438\u043c \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432 - \u0432\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435',\n                                                'zh' : '\u5305\u542b\u9009\u533a\u6a21\u5f0f',\n                                           }[lang]\n                                           \n        QStringDB.btn_poly_type_exclude_tip = { 'en' : 'Poly exclude mode',\n                                                'ru' : '\u0420\u0435\u0436\u0438\u043c \u043f\u043e\u043b\u0438\u0433\u043e\u043d\u043e\u0432 - \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435',\n                                                'zh' : '\u6392\u9664\u9009\u533a\u6a21\u5f0f',\n                                           }[lang]        \n                                           \n        QStringDB.btn_undo_pt_tip = {   'en' : 'Undo point',\n                                        'ru' : '\u041e\u0442\u043c\u0435\u043d\u0438\u0442\u044c \u0442\u043e\u0447\u043a\u0443',\n                                        'zh' : '\u64a4\u6d88\u70b9',\n                                    }[lang]      \n                                     \n        QStringDB.btn_redo_pt_tip = {   'en' : 'Redo point',\n                                        'ru' : '\u041f\u043e\u0432\u0442\u043e\u0440\u0438\u0442\u044c \u0442\u043e\u0447\u043a\u0443',\n                                        'zh' : '\u91cd\u505a\u70b9',\n                                     }[lang]      \n                                      \n        QStringDB.btn_delete_poly_tip = {   'en' : 'Delete poly',\n                                            'ru' : '\u0423\u0434\u0430\u043b\u0438\u0442\u044c \u043f\u043e\u043b\u0438\u0433\u043e\u043d',\n                                            'zh' : '\u5220\u9664\u9009\u533a',\n                                           }[lang]     \n                                              \n        QStringDB.btn_pt_edit_mode_tip = {  'en' : 'Add/delete point mode ( HOLD CTRL )',\n                                            'ru' : '\u0420\u0435\u0436\u0438\u043c \u0434\u043e\u0431\u0430\u0432\u043b\u0435\u043d\u0438\u044f/\u0443\u0434\u0430\u043b\u0435\u043d\u0438\u044f \u0442\u043e\u0447\u0435\u043a ( \u0443\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0439\u0442\u0435 CTRL )',\n                                            'zh' : '\u70b9\u52a0/\u5220\u9664\u6a21\u5f0f ( \u6309\u4f4fCTRL )',\n                                           }[lang]    \n                                           \n        QStringDB.btn_view_lock_center_tip = { 'en' : 'Lock cursor at the center ( HOLD SHIFT )',\n                                               'ru' : '\u0417\u0430\u0431\u043b\u043e\u043a\u0438\u0440\u043e\u0432\u0430\u0442\u044c \u043a\u0443\u0440\u0441\u043e\u0440 \u0432 \u0446\u0435\u043d\u0442\u0440\u0435 ( \u0443\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0439\u0442\u0435 SHIFT )',\n                                               'zh' : '\u5c06\u5149\u6807\u9501\u5b9a\u5728\u4e2d\u5fc3 ( \u6309\u4f4fSHIFT )',\n                                             }[lang]                    \n                                        \n                                           \n        QStringDB.btn_prev_image_tip = {    'en' : 'Save and Prev image\\nHold SHIFT : accelerate\\nHold CTRL : skip non masked\\n',\n                                            'ru' : '\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0438 \u043f\u0440\u0435\u0434\u044b\u0434\u0443\u0449\u0435\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\\n\u0423\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0442\u044c SHIFT : \u0443\u0441\u043a\u043e\u0440\u0438\u0442\u044c\\n\u0423\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0442\u044c CTRL : \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043d\u0435\u0440\u0430\u0437\u043c\u0435\u0447\u0435\u043d\u043d\u044b\u0435\\n',\n                                            'zh' : '\u4fdd\u5b58\u5e76\u8f6c\u5230\u4e0a\u4e00\u5f20\u56fe\u7247\\n\u6309\u4f4fSHIFT : \u52a0\u5feb\\n\u6309\u4f4fCTRL : \u8df3\u8fc7\u672a\u6807\u8bb0\u7684\\n',\n                                           }[lang]   \n        QStringDB.btn_next_image_tip = {    'en' : 'Save and Next image\\nHold SHIFT : accelerate\\nHold CTRL : skip non masked\\n',\n                                            'ru' : '\u0421\u043e\u0445\u0440\u0430\u043d\u0438\u0442\u044c \u0438 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\\n\u0423\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0442\u044c SHIFT : \u0443\u0441\u043a\u043e\u0440\u0438\u0442\u044c\\n\u0423\u0434\u0435\u0440\u0436\u0438\u0432\u0430\u0442\u044c CTRL : \u043f\u0440\u043e\u043f\u0443\u0441\u0442\u0438\u0442\u044c \u043d\u0435\u0440\u0430\u0437\u043c\u0435\u0447\u0435\u043d\u043d\u044b\u0435\\n',\n                                            'zh' : '\u4fdd\u5b58\u5e76\u8f6c\u5230\u4e0b\u4e00\u5f20\u56fe\u7247\\n\u6309\u4f4fSHIFT : \u52a0\u5feb\\n\u6309\u4f4fCTRL : \u8df3\u8fc7\u672a\u6807\u8bb0\u7684\\n',\n                                           }[lang]  \n        \n        QStringDB.btn_delete_image_tip = {  'en' : 'Move to _trash and Next image\\n',\n                                            'ru' : '\u041f\u0435\u0440\u0435\u043c\u0435\u0441\u0442\u0438\u0442\u044c \u0432 _trash \u0438 \u0441\u043b\u0435\u0434\u0443\u044e\u0449\u0435\u0435 \u0438\u0437\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435\\n',\n                                            'zh' : '\u79fb\u81f3_trash\uff0c\u8f6c\u5230\u4e0b\u4e00\u5f20\u56fe\u7247 ',\n                                           }[lang]  \n                                           \n        QStringDB.loading_tip = {'en' : 'Loading',\n                                 'ru' : '\u0417\u0430\u0433\u0440\u0443\u0437\u043a\u0430',\n                                 'zh' : '\u6b63\u5728\u8f7d\u5165',\n                                }[lang]   \n                                \n        QStringDB.labeled_tip = {'en' : 'labeled',\n                                 'ru' : '\u0440\u0430\u0437\u043c\u0435\u0447\u0435\u043d\u043e',\n                                 'zh' : '\u6807\u8bb0\u7684',\n                                }[lang]   \n                                           \n", "XSegEditor/XSegEditor.py": "import json\nimport multiprocessing\nimport os\nimport pickle\nimport sys\nimport tempfile\nimport time\nimport traceback\nfrom enum import IntEnum\nfrom types import SimpleNamespace as sn\n\nimport cv2\nimport numpy as np\nimport numpy.linalg as npla\nfrom PyQt5.QtCore import *\nfrom PyQt5.QtGui import *\nfrom PyQt5.QtWidgets import *\n\nfrom core import imagelib, pathex\nfrom core.cv2ex import *\nfrom core.imagelib import SegIEPoly, SegIEPolys, SegIEPolyType, sd\nfrom core.qtex import *\nfrom DFLIMG import *\nfrom localization import StringsDB, system_language\nfrom samplelib import PackedFaceset\n\nfrom .QCursorDB import QCursorDB\nfrom .QIconDB import QIconDB\nfrom .QStringDB import QStringDB\nfrom .QImageDB import QImageDB\n\nclass OpMode(IntEnum):\n    NONE = 0\n    DRAW_PTS = 1\n    EDIT_PTS = 2\n    VIEW_BAKED = 3\n    VIEW_XSEG_MASK = 4\n\nclass PTEditMode(IntEnum):\n    MOVE = 0\n    ADD_DEL = 1\n\nclass DragType(IntEnum):\n    NONE = 0\n    IMAGE_LOOK = 1\n    POLY_PT = 2\n\nclass ViewLock(IntEnum):\n    NONE = 0\n    CENTER = 1\n\nclass QUIConfig():\n    @staticmethod\n    def initialize(icon_size = 48, icon_spacer_size=16, preview_bar_icon_size=64):\n        QUIConfig.icon_q_size = QSize(icon_size, icon_size)\n        QUIConfig.icon_spacer_q_size = QSize(icon_spacer_size, icon_spacer_size)\n        QUIConfig.preview_bar_icon_q_size = QSize(preview_bar_icon_size, preview_bar_icon_size)\n\nclass ImagePreviewSequenceBar(QFrame):\n    def __init__(self, preview_images_count, icon_size):\n        super().__init__()\n        self.preview_images_count = preview_images_count = max(1, preview_images_count + (preview_images_count % 2 -1) )\n\n        self.icon_size = icon_size\n\n        black_q_img = QImage(np.zeros( (icon_size,icon_size,3) ).data, icon_size, icon_size, 3*icon_size, QImage.Format_RGB888)\n        self.black_q_pixmap = QPixmap.fromImage(black_q_img)\n\n        self.image_containers = [ QLabel() for i in range(preview_images_count)]\n\n        main_frame_l_cont_hl = QGridLayout()\n        main_frame_l_cont_hl.setContentsMargins(0,0,0,0)\n        #main_frame_l_cont_hl.setSpacing(0)\n\n\n\n        for i in range(len(self.image_containers)):\n            q_label = self.image_containers[i]\n            q_label.setScaledContents(True)\n            if i == preview_images_count//2:\n                q_label.setMinimumSize(icon_size+16, icon_size+16 )\n                q_label.setMaximumSize(icon_size+16, icon_size+16 )\n            else:\n                q_label.setMinimumSize(icon_size, icon_size )\n                q_label.setMaximumSize(icon_size, icon_size )\n                opacity_effect = QGraphicsOpacityEffect()\n                opacity_effect.setOpacity(0.5)\n                q_label.setGraphicsEffect(opacity_effect)\n\n            q_label.setSizePolicy (QSizePolicy.Fixed, QSizePolicy.Fixed)\n\n            main_frame_l_cont_hl.addWidget (q_label, 0, i)\n\n        self.setLayout(main_frame_l_cont_hl)\n\n        self.prev_img_conts = self.image_containers[(preview_images_count//2) -1::-1]\n        self.next_img_conts = self.image_containers[preview_images_count//2:]\n\n        self.update_images()\n\n    def get_preview_images_count(self):\n        return self.preview_images_count\n\n    def update_images(self, prev_imgs=None, next_imgs=None):\n        # Fix arrays\n        if prev_imgs is None:\n            prev_imgs = []\n        prev_img_conts_len = len(self.prev_img_conts)\n        prev_q_imgs_len = len(prev_imgs)\n        if prev_q_imgs_len < prev_img_conts_len:\n            for i in range ( prev_img_conts_len - prev_q_imgs_len ):\n                prev_imgs.append(None)\n        elif prev_q_imgs_len > prev_img_conts_len:\n            prev_imgs = prev_imgs[:prev_img_conts_len]\n\n        if next_imgs is None:\n            next_imgs = []\n        next_img_conts_len = len(self.next_img_conts)\n        next_q_imgs_len = len(next_imgs)\n        if next_q_imgs_len < next_img_conts_len:\n            for i in range ( next_img_conts_len - next_q_imgs_len ):\n                next_imgs.append(None)\n        elif next_q_imgs_len > next_img_conts_len:\n            next_imgs = next_imgs[:next_img_conts_len]\n\n        for i,img in enumerate(prev_imgs):\n            self.prev_img_conts[i].setPixmap( QPixmap.fromImage( QImage_from_np(img) ) if img is not None else self.black_q_pixmap )\n\n        for i,img in enumerate(next_imgs):\n            self.next_img_conts[i].setPixmap( QPixmap.fromImage( QImage_from_np(img) ) if img is not None else self.black_q_pixmap )\n\nclass ColorScheme():\n    def __init__(self, unselected_color, selected_color, outline_color, outline_width, pt_outline_color, cross_cursor):\n        self.poly_unselected_brush = QBrush(unselected_color)\n        self.poly_selected_brush = QBrush(selected_color)\n\n        self.poly_outline_solid_pen = QPen(outline_color, outline_width, Qt.SolidLine, Qt.RoundCap, Qt.RoundJoin)\n        self.poly_outline_dot_pen = QPen(outline_color, outline_width, Qt.DotLine, Qt.RoundCap, Qt.RoundJoin)\n\n        self.pt_outline_pen = QPen(pt_outline_color)\n        self.cross_cursor = cross_cursor\n\nclass CanvasConfig():\n\n    def __init__(self,\n                 pt_radius=4,\n                 pt_select_radius=8,\n                 color_schemes=None,\n                 **kwargs):\n        self.pt_radius = pt_radius\n        self.pt_select_radius = pt_select_radius\n\n        if color_schemes is None:\n            color_schemes = [\n                    ColorScheme( QColor(192,0,0,alpha=0), QColor(192,0,0,alpha=72), QColor(192,0,0), 2, QColor(255,255,255), QCursorDB.cross_red ),\n                    ColorScheme( QColor(0,192,0,alpha=0), QColor(0,192,0,alpha=72), QColor(0,192,0), 2, QColor(255,255,255), QCursorDB.cross_green ),\n                    ColorScheme( QColor(0,0,192,alpha=0), QColor(0,0,192,alpha=72), QColor(0,0,192), 2, QColor(255,255,255), QCursorDB.cross_blue ),\n                    ]\n        self.color_schemes = color_schemes\n\nclass QCanvasControlsLeftBar(QFrame):\n\n    def __init__(self):\n        super().__init__()\n        #==============================================\n        btn_poly_type_include = QToolButton()\n        self.btn_poly_type_include_act = QActionEx( QIconDB.poly_type_include, QStringDB.btn_poly_type_include_tip, shortcut='Q', shortcut_in_tooltip=True, is_checkable=True)\n        btn_poly_type_include.setDefaultAction(self.btn_poly_type_include_act)\n        btn_poly_type_include.setIconSize(QUIConfig.icon_q_size)\n\n        btn_poly_type_exclude = QToolButton()\n        self.btn_poly_type_exclude_act = QActionEx( QIconDB.poly_type_exclude, QStringDB.btn_poly_type_exclude_tip, shortcut='W', shortcut_in_tooltip=True, is_checkable=True)\n        btn_poly_type_exclude.setDefaultAction(self.btn_poly_type_exclude_act)\n        btn_poly_type_exclude.setIconSize(QUIConfig.icon_q_size)\n\n        self.btn_poly_type_act_grp = QActionGroup (self)\n        self.btn_poly_type_act_grp.addAction(self.btn_poly_type_include_act)\n        self.btn_poly_type_act_grp.addAction(self.btn_poly_type_exclude_act)\n        self.btn_poly_type_act_grp.setExclusive(True)\n        #==============================================\n        btn_undo_pt = QToolButton()\n        self.btn_undo_pt_act = QActionEx( QIconDB.undo_pt, QStringDB.btn_undo_pt_tip, shortcut='Ctrl+Z', shortcut_in_tooltip=True, is_auto_repeat=True)\n        btn_undo_pt.setDefaultAction(self.btn_undo_pt_act)\n        btn_undo_pt.setIconSize(QUIConfig.icon_q_size)\n\n        btn_redo_pt = QToolButton()\n        self.btn_redo_pt_act = QActionEx( QIconDB.redo_pt, QStringDB.btn_redo_pt_tip, shortcut='Ctrl+Shift+Z',  shortcut_in_tooltip=True, is_auto_repeat=True)\n        btn_redo_pt.setDefaultAction(self.btn_redo_pt_act)\n        btn_redo_pt.setIconSize(QUIConfig.icon_q_size)\n\n        btn_delete_poly = QToolButton()\n        self.btn_delete_poly_act = QActionEx( QIconDB.delete_poly, QStringDB.btn_delete_poly_tip, shortcut='Delete', shortcut_in_tooltip=True)\n        btn_delete_poly.setDefaultAction(self.btn_delete_poly_act)\n        btn_delete_poly.setIconSize(QUIConfig.icon_q_size)\n        #==============================================\n        btn_pt_edit_mode = QToolButton()\n        self.btn_pt_edit_mode_act = QActionEx( QIconDB.pt_edit_mode, QStringDB.btn_pt_edit_mode_tip, shortcut_in_tooltip=True, is_checkable=True)\n        btn_pt_edit_mode.setDefaultAction(self.btn_pt_edit_mode_act)\n        btn_pt_edit_mode.setIconSize(QUIConfig.icon_q_size)\n        #==============================================\n\n        controls_bar_frame2_l = QVBoxLayout()\n        controls_bar_frame2_l.addWidget ( btn_poly_type_include )\n        controls_bar_frame2_l.addWidget ( btn_poly_type_exclude )\n        controls_bar_frame2 = QFrame()\n        controls_bar_frame2.setFrameShape(QFrame.StyledPanel)\n        controls_bar_frame2.setSizePolicy (QSizePolicy.Fixed, QSizePolicy.Fixed)\n        controls_bar_frame2.setLayout(controls_bar_frame2_l)\n\n        controls_bar_frame3_l = QVBoxLayout()\n        controls_bar_frame3_l.addWidget ( btn_undo_pt )\n        controls_bar_frame3_l.addWidget ( btn_redo_pt )\n        controls_bar_frame3_l.addWidget ( btn_delete_poly )\n        controls_bar_frame3 = QFrame()\n        controls_bar_frame3.setFrameShape(QFrame.StyledPanel)\n        controls_bar_frame3.setSizePolicy (QSizePolicy.Fixed, QSizePolicy.Fixed)\n        controls_bar_frame3.setLayout(controls_bar_frame3_l)\n\n        controls_bar_frame4_l = QVBoxLayout()\n        controls_bar_frame4_l.addWidget ( btn_pt_edit_mode )\n        controls_bar_frame4 = QFrame()\n        controls_bar_frame4.setFrameShape(QFrame.StyledPanel)\n        controls_bar_frame4.setSizePolicy (QSizePolicy.Fixed, QSizePolicy.Fixed)\n        controls_bar_frame4.setLayout(controls_bar_frame4_l)\n\n        controls_bar_l = QVBoxLayout()\n        controls_bar_l.setContentsMargins(0,0,0,0)\n        controls_bar_l.addWidget(controls_bar_frame2)\n        controls_bar_l.addWidget(controls_bar_frame3)\n        controls_bar_l.addWidget(controls_bar_frame4)\n\n        self.setSizePolicy ( QSizePolicy.Fixed, QSizePolicy.Expanding )\n        self.setLayout(controls_bar_l)\n\nclass QCanvasControlsRightBar(QFrame):\n\n    def __init__(self):\n        super().__init__()\n        #==============================================\n        btn_poly_color_red = QToolButton()\n        self.btn_poly_color_red_act = QActionEx( QIconDB.poly_color_red, QStringDB.btn_poly_color_red_tip, shortcut='1', shortcut_in_tooltip=True, is_checkable=True)\n        btn_poly_color_red.setDefaultAction(self.btn_poly_color_red_act)\n        btn_poly_color_red.setIconSize(QUIConfig.icon_q_size)\n\n        btn_poly_color_green = QToolButton()\n        self.btn_poly_color_green_act = QActionEx( QIconDB.poly_color_green, QStringDB.btn_poly_color_green_tip, shortcut='2', shortcut_in_tooltip=True, is_checkable=True)\n        btn_poly_color_green.setDefaultAction(self.btn_poly_color_green_act)\n        btn_poly_color_green.setIconSize(QUIConfig.icon_q_size)\n\n        btn_poly_color_blue = QToolButton()\n        self.btn_poly_color_blue_act = QActionEx( QIconDB.poly_color_blue, QStringDB.btn_poly_color_blue_tip, shortcut='3', shortcut_in_tooltip=True, is_checkable=True)\n        btn_poly_color_blue.setDefaultAction(self.btn_poly_color_blue_act)\n        btn_poly_color_blue.setIconSize(QUIConfig.icon_q_size)\n\n        btn_view_baked_mask = QToolButton()\n        self.btn_view_baked_mask_act = QActionEx( QIconDB.view_baked, QStringDB.btn_view_baked_mask_tip, shortcut='4', shortcut_in_tooltip=True, is_checkable=True)\n        btn_view_baked_mask.setDefaultAction(self.btn_view_baked_mask_act)\n        btn_view_baked_mask.setIconSize(QUIConfig.icon_q_size)\n\n        btn_view_xseg_mask = QToolButton()\n        self.btn_view_xseg_mask_act = QActionEx( QIconDB.view_xseg, QStringDB.btn_view_xseg_mask_tip, shortcut='5', shortcut_in_tooltip=True, is_checkable=True)\n        btn_view_xseg_mask.setDefaultAction(self.btn_view_xseg_mask_act)\n        btn_view_xseg_mask.setIconSize(QUIConfig.icon_q_size)\n\n        btn_view_xseg_overlay_mask = QToolButton()\n        self.btn_view_xseg_overlay_mask_act = QActionEx( QIconDB.view_xseg_overlay, QStringDB.btn_view_xseg_overlay_mask_tip, shortcut='`', shortcut_in_tooltip=True, is_checkable=True)\n        btn_view_xseg_overlay_mask.setDefaultAction(self.btn_view_xseg_overlay_mask_act)\n        btn_view_xseg_overlay_mask.setIconSize(QUIConfig.icon_q_size)\n\n        self.btn_poly_color_act_grp = QActionGroup (self)\n        self.btn_poly_color_act_grp.addAction(self.btn_poly_color_red_act)\n        self.btn_poly_color_act_grp.addAction(self.btn_poly_color_green_act)\n        self.btn_poly_color_act_grp.addAction(self.btn_poly_color_blue_act)\n        self.btn_poly_color_act_grp.addAction(self.btn_view_baked_mask_act)\n        self.btn_poly_color_act_grp.addAction(self.btn_view_xseg_mask_act)\n        self.btn_poly_color_act_grp.setExclusive(True)\n        #==============================================\n        btn_view_lock_center = QToolButton()\n        self.btn_view_lock_center_act = QActionEx( QIconDB.view_lock_center, QStringDB.btn_view_lock_center_tip, shortcut_in_tooltip=True, is_checkable=True)\n        btn_view_lock_center.setDefaultAction(self.btn_view_lock_center_act)\n        btn_view_lock_center.setIconSize(QUIConfig.icon_q_size)\n\n        controls_bar_frame2_l = QVBoxLayout()\n        controls_bar_frame2_l.addWidget ( btn_view_xseg_overlay_mask )\n        controls_bar_frame2 = QFrame()\n        controls_bar_frame2.setFrameShape(QFrame.StyledPanel)\n        controls_bar_frame2.setSizePolicy (QSizePolicy.Fixed, QSizePolicy.Fixed)\n        controls_bar_frame2.setLayout(controls_bar_frame2_l)\n        \n        controls_bar_frame1_l = QVBoxLayout()\n        controls_bar_frame1_l.addWidget ( btn_poly_color_red )\n        controls_bar_frame1_l.addWidget ( btn_poly_color_green )\n        controls_bar_frame1_l.addWidget ( btn_poly_color_blue )\n        controls_bar_frame1_l.addWidget ( btn_view_baked_mask )\n        controls_bar_frame1_l.addWidget ( btn_view_xseg_mask )\n        controls_bar_frame1 = QFrame()\n        controls_bar_frame1.setFrameShape(QFrame.StyledPanel)\n        controls_bar_frame1.setSizePolicy (QSizePolicy.Fixed, QSizePolicy.Fixed)\n        controls_bar_frame1.setLayout(controls_bar_frame1_l)\n        \n        controls_bar_frame3_l = QVBoxLayout()\n        controls_bar_frame3_l.addWidget ( btn_view_lock_center )\n        controls_bar_frame3 = QFrame()\n        controls_bar_frame3.setFrameShape(QFrame.StyledPanel)\n        controls_bar_frame3.setSizePolicy (QSizePolicy.Fixed, QSizePolicy.Fixed)\n        controls_bar_frame3.setLayout(controls_bar_frame3_l)\n\n        controls_bar_l = QVBoxLayout()\n        controls_bar_l.setContentsMargins(0,0,0,0)\n        controls_bar_l.addWidget(controls_bar_frame2)\n        controls_bar_l.addWidget(controls_bar_frame1)\n        controls_bar_l.addWidget(controls_bar_frame3)\n        \n        self.setSizePolicy ( QSizePolicy.Fixed, QSizePolicy.Expanding )\n        self.setLayout(controls_bar_l)\n\nclass QCanvasOperator(QWidget):\n    def __init__(self, cbar):\n        super().__init__()\n        self.cbar = cbar\n\n        self.set_cbar_disabled()\n\n        self.cbar.btn_poly_color_red_act.triggered.connect ( lambda : self.set_color_scheme_id(0) )\n        self.cbar.btn_poly_color_green_act.triggered.connect ( lambda : self.set_color_scheme_id(1) )\n        self.cbar.btn_poly_color_blue_act.triggered.connect ( lambda : self.set_color_scheme_id(2) )\n        self.cbar.btn_view_baked_mask_act.triggered.connect ( lambda : self.set_op_mode(OpMode.VIEW_BAKED) )\n        self.cbar.btn_view_xseg_mask_act.triggered.connect ( lambda : self.set_op_mode(OpMode.VIEW_XSEG_MASK) )\n\n        self.cbar.btn_view_xseg_overlay_mask_act.toggled.connect ( lambda is_checked: self.update() )\n\n        self.cbar.btn_poly_type_include_act.triggered.connect ( lambda : self.set_poly_include_type(SegIEPolyType.INCLUDE) )\n        self.cbar.btn_poly_type_exclude_act.triggered.connect ( lambda : self.set_poly_include_type(SegIEPolyType.EXCLUDE) )\n\n        self.cbar.btn_undo_pt_act.triggered.connect ( lambda : self.action_undo_pt() )\n        self.cbar.btn_redo_pt_act.triggered.connect ( lambda : self.action_redo_pt() )\n\n        self.cbar.btn_delete_poly_act.triggered.connect ( lambda : self.action_delete_poly() )\n\n        self.cbar.btn_pt_edit_mode_act.toggled.connect ( lambda is_checked: self.set_pt_edit_mode( PTEditMode.ADD_DEL if is_checked else PTEditMode.MOVE ) )\n        self.cbar.btn_view_lock_center_act.toggled.connect ( lambda is_checked: self.set_view_lock( ViewLock.CENTER if is_checked else ViewLock.NONE ) )\n\n        self.mouse_in_widget = False\n\n        QXMainWindow.inst.add_keyPressEvent_listener ( self.on_keyPressEvent )\n        QXMainWindow.inst.add_keyReleaseEvent_listener ( self.on_keyReleaseEvent )\n\n        self.qp = QPainter()\n        self.initialized = False\n        self.last_state = None\n\n    def initialize(self, img, img_look_pt=None, view_scale=None, ie_polys=None, xseg_mask=None, canvas_config=None ):\n        q_img = self.q_img = QImage_from_np(img)\n        self.img_pixmap = QPixmap.fromImage(q_img)\n\n        self.xseg_mask_pixmap = None\n        self.xseg_overlay_mask_pixmap = None\n        if xseg_mask is not None:\n            h,w,c = img.shape\n            xseg_mask = cv2.resize(xseg_mask, (w,h), interpolation=cv2.INTER_CUBIC)\n            xseg_mask = imagelib.normalize_channels(xseg_mask, 1)\n            xseg_img = img.astype(np.float32)/255.0\n            xseg_overlay_mask = xseg_img*(1-xseg_mask)*0.5 + xseg_img*xseg_mask\n            xseg_overlay_mask = np.clip(xseg_overlay_mask*255, 0, 255).astype(np.uint8)\n            xseg_mask = np.clip(xseg_mask*255, 0, 255).astype(np.uint8)\n            self.xseg_mask_pixmap = QPixmap.fromImage(QImage_from_np(xseg_mask))\n            self.xseg_overlay_mask_pixmap = QPixmap.fromImage(QImage_from_np(xseg_overlay_mask))\n\n        self.img_size = QSize_to_np (self.img_pixmap.size())\n\n        self.img_look_pt = img_look_pt\n        self.view_scale = view_scale\n\n        if ie_polys is None:\n            ie_polys = SegIEPolys()\n        self.ie_polys = ie_polys\n\n        if canvas_config is None:\n            canvas_config = CanvasConfig()\n        self.canvas_config = canvas_config\n\n        # UI init\n        self.set_cbar_disabled()\n        self.cbar.btn_poly_color_act_grp.setDisabled(False)\n        self.cbar.btn_view_xseg_overlay_mask_act.setDisabled(False)\n        self.cbar.btn_poly_type_act_grp.setDisabled(False)\n\n        # Initial vars\n        self.current_cursor = None\n        self.mouse_hull_poly = None\n        self.mouse_wire_poly = None\n        self.drag_type = DragType.NONE\n        self.mouse_cli_pt = np.zeros((2,), np.float32 )\n\n        # Initial state\n        self.set_op_mode(OpMode.NONE)\n        self.set_color_scheme_id(1)\n        self.set_poly_include_type(SegIEPolyType.INCLUDE)\n        self.set_pt_edit_mode(PTEditMode.MOVE)\n        self.set_view_lock(ViewLock.NONE)\n\n        # Apply last state\n        if self.last_state is not None:\n            self.set_color_scheme_id(self.last_state.color_scheme_id)\n            if self.last_state.op_mode is not None:\n                self.set_op_mode(self.last_state.op_mode)\n\n        self.initialized = True\n\n        self.setMouseTracking(True)\n        self.update_cursor()\n        self.update()\n\n\n    def finalize(self):\n        if self.initialized:\n            if self.op_mode == OpMode.DRAW_PTS:\n                self.set_op_mode(OpMode.EDIT_PTS)\n\n            self.last_state = sn(op_mode = self.op_mode if self.op_mode in [OpMode.VIEW_BAKED, OpMode.VIEW_XSEG_MASK] else None,\n                                 color_scheme_id = self.color_scheme_id)\n\n            self.img_pixmap = None\n            self.update_cursor(is_finalize=True)\n            self.setMouseTracking(False)\n            self.setFocusPolicy(Qt.NoFocus)\n            self.set_cbar_disabled()\n            self.initialized = False\n            self.update()\n\n    # ====================================================================================\n    # ====================================================================================\n    # ====================================== GETTERS =====================================\n    # ====================================================================================\n    # ====================================================================================\n    def is_initialized(self):\n        return self.initialized\n\n    def get_ie_polys(self):\n        return self.ie_polys\n\n    def get_cli_center_pt(self):\n        return np.round(QSize_to_np(self.size())/2.0)\n\n    def get_img_look_pt(self):\n        img_look_pt = self.img_look_pt\n        if img_look_pt is None:\n            img_look_pt = self.img_size / 2\n        return img_look_pt\n\n    def get_view_scale(self):\n        view_scale = self.view_scale\n        if view_scale is None:\n            # Calc as scale to fit\n            min_cli_size = np.min(QSize_to_np(self.size()))\n            max_img_size = np.max(self.img_size)\n            view_scale =  min_cli_size / max_img_size\n\n        return view_scale\n\n    def get_current_color_scheme(self):\n        return self.canvas_config.color_schemes[self.color_scheme_id]\n\n    def get_poly_pt_id_under_pt(self, poly, cli_pt):\n        w = np.argwhere ( npla.norm ( cli_pt - self.img_to_cli_pt( poly.get_pts() ), axis=1 )  <= self.canvas_config.pt_select_radius )\n        return None if len(w) == 0 else w[-1][0]\n\n    def get_poly_edge_id_pt_under_pt(self, poly, cli_pt):\n        cli_pts = self.img_to_cli_pt(poly.get_pts())\n        if len(cli_pts) >= 3:\n            edge_dists, projs = sd.dist_to_edges(cli_pts, cli_pt, is_closed=True)\n            edge_id = np.argmin(edge_dists)\n            dist = edge_dists[edge_id]\n            pt = projs[edge_id]\n            if dist <= self.canvas_config.pt_select_radius:\n                return edge_id, pt\n        return None, None\n\n    def get_poly_by_pt_near_wire(self, cli_pt):\n        pt_select_radius = self.canvas_config.pt_select_radius\n\n        for poly in reversed(self.ie_polys.get_polys()):\n            pts = poly.get_pts()\n            if len(pts) >= 3:\n                cli_pts = self.img_to_cli_pt(pts)\n\n                edge_dists, _ = sd.dist_to_edges(cli_pts, cli_pt, is_closed=True)\n\n                if np.min(edge_dists) <= pt_select_radius or \\\n                   any( npla.norm ( cli_pt - cli_pts, axis=1 ) <= pt_select_radius ):\n                    return poly\n        return None\n\n    def get_poly_by_pt_in_hull(self, cli_pos):\n        img_pos = self.cli_to_img_pt(cli_pos)\n\n        for poly in reversed(self.ie_polys.get_polys()):\n            pts = poly.get_pts()\n            if len(pts) >= 3:\n                if cv2.pointPolygonTest( pts, tuple(img_pos), False) >= 0:\n                    return poly\n\n        return None\n\n    def img_to_cli_pt(self, p):\n        return (p - self.get_img_look_pt()) * self.get_view_scale() + self.get_cli_center_pt()# QSize_to_np(self.size())/2.0\n\n    def cli_to_img_pt(self, p):\n        return (p - self.get_cli_center_pt() ) / self.get_view_scale() + self.get_img_look_pt()\n\n    def img_to_cli_rect(self, rect):\n        tl = QPoint_to_np(rect.topLeft())\n        xy = self.img_to_cli_pt(tl)\n        xy2 = self.img_to_cli_pt(tl + QSize_to_np(rect.size()) ) - xy\n        return QRect ( *xy.astype(np.int), *xy2.astype(np.int) )\n\n    # ====================================================================================\n    # ====================================================================================\n    # ====================================== SETTERS =====================================\n    # ====================================================================================\n    # ====================================================================================\n    def set_op_mode(self, op_mode, op_poly=None):\n        if not hasattr(self,'op_mode'):\n            self.op_mode = None\n            self.op_poly = None\n\n        if self.op_mode != op_mode:\n            # Finalize prev mode\n            if self.op_mode == OpMode.NONE:\n                self.cbar.btn_poly_type_act_grp.setDisabled(True)\n            elif self.op_mode == OpMode.DRAW_PTS:\n                self.cbar.btn_undo_pt_act.setDisabled(True)\n                self.cbar.btn_redo_pt_act.setDisabled(True)\n                self.cbar.btn_view_lock_center_act.setDisabled(True)\n                # Reset view_lock when exit from DRAW_PTS\n                self.set_view_lock(ViewLock.NONE)\n                # Remove unfinished poly\n                if self.op_poly.get_pts_count() < 3:\n                    self.ie_polys.remove_poly(self.op_poly)\n\n            elif self.op_mode == OpMode.EDIT_PTS:\n                self.cbar.btn_pt_edit_mode_act.setDisabled(True)\n                self.cbar.btn_delete_poly_act.setDisabled(True)\n                # Reset pt_edit_move when exit from EDIT_PTS\n                self.set_pt_edit_mode(PTEditMode.MOVE)\n            elif self.op_mode == OpMode.VIEW_BAKED:\n                self.cbar.btn_view_baked_mask_act.setChecked(False)\n            elif self.op_mode == OpMode.VIEW_XSEG_MASK:\n                self.cbar.btn_view_xseg_mask_act.setChecked(False)\n\n            self.op_mode = op_mode\n\n            # Initialize new mode\n            if op_mode == OpMode.NONE:\n                self.cbar.btn_poly_type_act_grp.setDisabled(False)\n            elif op_mode == OpMode.DRAW_PTS:\n                self.cbar.btn_undo_pt_act.setDisabled(False)\n                self.cbar.btn_redo_pt_act.setDisabled(False)\n                self.cbar.btn_view_lock_center_act.setDisabled(False)\n            elif op_mode == OpMode.EDIT_PTS:\n                self.cbar.btn_pt_edit_mode_act.setDisabled(False)\n                self.cbar.btn_delete_poly_act.setDisabled(False)\n            elif op_mode == OpMode.VIEW_BAKED:\n                self.cbar.btn_view_baked_mask_act.setChecked(True )\n                n = QImage_to_np ( self.q_img ).astype(np.float32) / 255.0\n                h,w,c = n.shape\n                mask = np.zeros( (h,w,1), dtype=np.float32 )\n                self.ie_polys.overlay_mask(mask)\n                n = (mask*255).astype(np.uint8)\n                self.img_baked_pixmap = QPixmap.fromImage(QImage_from_np(n))\n            elif op_mode == OpMode.VIEW_XSEG_MASK:\n                self.cbar.btn_view_xseg_mask_act.setChecked(True)\n\n            if op_mode in [OpMode.DRAW_PTS, OpMode.EDIT_PTS]:\n                self.mouse_op_poly_pt_id = None\n                self.mouse_op_poly_edge_id = None\n                self.mouse_op_poly_edge_id_pt = None\n\n            self.op_poly = op_poly\n            if op_poly is not None:\n                self.update_mouse_info()\n\n            self.update_cursor()\n            self.update()\n\n    def set_pt_edit_mode(self, pt_edit_mode):\n        if not hasattr(self, 'pt_edit_mode') or self.pt_edit_mode != pt_edit_mode:\n            self.pt_edit_mode = pt_edit_mode\n            self.update_cursor()\n            self.update()\n        self.cbar.btn_pt_edit_mode_act.setChecked( self.pt_edit_mode == PTEditMode.ADD_DEL )\n\n    def set_view_lock(self, view_lock):\n        if not hasattr(self, 'view_lock') or self.view_lock != view_lock:\n            if hasattr(self, 'view_lock') and self.view_lock != view_lock:\n                if view_lock == ViewLock.CENTER:\n                    self.img_look_pt = self.mouse_img_pt\n                    QCursor.setPos ( self.mapToGlobal( QPoint_from_np(self.img_to_cli_pt(self.img_look_pt)) ))\n\n            self.view_lock = view_lock\n            self.update()\n        self.cbar.btn_view_lock_center_act.setChecked( self.view_lock == ViewLock.CENTER )\n\n    def set_cbar_disabled(self):\n        self.cbar.btn_delete_poly_act.setDisabled(True)\n        self.cbar.btn_undo_pt_act.setDisabled(True)\n        self.cbar.btn_redo_pt_act.setDisabled(True)\n        self.cbar.btn_pt_edit_mode_act.setDisabled(True)\n        self.cbar.btn_view_lock_center_act.setDisabled(True)\n        self.cbar.btn_poly_color_act_grp.setDisabled(True)\n        self.cbar.btn_view_xseg_overlay_mask_act.setDisabled(True)\n        self.cbar.btn_poly_type_act_grp.setDisabled(True)\n\n\n    def set_color_scheme_id(self, id):\n        if self.op_mode == OpMode.VIEW_BAKED or self.op_mode == OpMode.VIEW_XSEG_MASK:\n            self.set_op_mode(OpMode.NONE)\n\n        if not hasattr(self, 'color_scheme_id') or self.color_scheme_id != id:\n            self.color_scheme_id = id\n            self.update_cursor()\n            self.update()\n\n        if self.color_scheme_id == 0:\n            self.cbar.btn_poly_color_red_act.setChecked( True )\n        elif self.color_scheme_id == 1:\n            self.cbar.btn_poly_color_green_act.setChecked( True )\n        elif self.color_scheme_id == 2:\n            self.cbar.btn_poly_color_blue_act.setChecked( True )\n\n    def set_poly_include_type(self, poly_include_type):\n        if not hasattr(self, 'poly_include_type' ) or \\\n           ( self.poly_include_type != poly_include_type and \\\n             self.op_mode in [OpMode.NONE, OpMode.EDIT_PTS] ):\n            self.poly_include_type = poly_include_type\n            self.update()\n        self.cbar.btn_poly_type_include_act.setChecked(self.poly_include_type == SegIEPolyType.INCLUDE)\n        self.cbar.btn_poly_type_exclude_act.setChecked(self.poly_include_type == SegIEPolyType.EXCLUDE)\n\n    # ====================================================================================\n    # ====================================================================================\n    # ====================================== METHODS =====================================\n    # ====================================================================================\n    # ====================================================================================\n\n    def update_cursor(self, is_finalize=False):\n        if not self.initialized:\n            return\n\n        if not self.mouse_in_widget or is_finalize:\n            if self.current_cursor is not None:\n                QApplication.restoreOverrideCursor()\n                self.current_cursor = None\n        else:\n            color_cc = self.get_current_color_scheme().cross_cursor\n            nc = Qt.ArrowCursor\n\n            if self.drag_type == DragType.IMAGE_LOOK:\n                nc = Qt.ClosedHandCursor\n            else:\n\n                if self.op_mode == OpMode.NONE:\n                    nc = color_cc\n                    if self.mouse_wire_poly is not None:\n                        nc = Qt.PointingHandCursor\n\n                elif self.op_mode == OpMode.DRAW_PTS:\n                    nc = color_cc\n                elif self.op_mode == OpMode.EDIT_PTS:\n                    nc = Qt.ArrowCursor\n\n                    if self.mouse_op_poly_pt_id is not None:\n                        nc = Qt.PointingHandCursor\n\n                    if self.pt_edit_mode == PTEditMode.ADD_DEL:\n\n                        if self.mouse_op_poly_edge_id is not None and \\\n                        self.mouse_op_poly_pt_id is None:\n                            nc = color_cc\n            if self.current_cursor != nc:\n                if self.current_cursor is None:\n                    QApplication.setOverrideCursor(nc)\n                else:\n                    QApplication.changeOverrideCursor(nc)\n                self.current_cursor = nc\n\n    def update_mouse_info(self, mouse_cli_pt=None):\n        \"\"\"\n        Update selected polys/edges/points by given mouse position\n        \"\"\"\n        if mouse_cli_pt is not None:\n            self.mouse_cli_pt = mouse_cli_pt.astype(np.float32)\n\n        self.mouse_img_pt = self.cli_to_img_pt(self.mouse_cli_pt)\n\n        new_mouse_hull_poly = self.get_poly_by_pt_in_hull(self.mouse_cli_pt)\n\n        if self.mouse_hull_poly != new_mouse_hull_poly:\n            self.mouse_hull_poly = new_mouse_hull_poly\n            self.update_cursor()\n            self.update()\n\n        new_mouse_wire_poly = self.get_poly_by_pt_near_wire(self.mouse_cli_pt)\n\n        if self.mouse_wire_poly != new_mouse_wire_poly:\n            self.mouse_wire_poly = new_mouse_wire_poly\n            self.update_cursor()\n            self.update()\n\n        if self.op_mode in [OpMode.DRAW_PTS, OpMode.EDIT_PTS]:\n            new_mouse_op_poly_pt_id = self.get_poly_pt_id_under_pt (self.op_poly, self.mouse_cli_pt)\n            if self.mouse_op_poly_pt_id != new_mouse_op_poly_pt_id:\n                self.mouse_op_poly_pt_id = new_mouse_op_poly_pt_id\n                self.update_cursor()\n                self.update()\n\n            new_mouse_op_poly_edge_id,\\\n            new_mouse_op_poly_edge_id_pt = self.get_poly_edge_id_pt_under_pt (self.op_poly, self.mouse_cli_pt)\n            if self.mouse_op_poly_edge_id != new_mouse_op_poly_edge_id:\n                self.mouse_op_poly_edge_id = new_mouse_op_poly_edge_id\n                self.update_cursor()\n                self.update()\n\n            if (self.mouse_op_poly_edge_id_pt.__class__ != new_mouse_op_poly_edge_id_pt.__class__) or \\\n               (isinstance(self.mouse_op_poly_edge_id_pt, np.ndarray) and \\\n                all(self.mouse_op_poly_edge_id_pt != new_mouse_op_poly_edge_id_pt)):\n\n                self.mouse_op_poly_edge_id_pt = new_mouse_op_poly_edge_id_pt\n                self.update_cursor()\n                self.update()\n\n\n    def action_undo_pt(self):\n        if self.drag_type == DragType.NONE:\n            if self.op_mode == OpMode.DRAW_PTS:\n                if self.op_poly.undo() == 0:\n                    self.ie_polys.remove_poly (self.op_poly)\n                    self.set_op_mode(OpMode.NONE)\n                self.update()\n\n    def action_redo_pt(self):\n        if self.drag_type == DragType.NONE:\n            if self.op_mode == OpMode.DRAW_PTS:\n                self.op_poly.redo()\n                self.update()\n\n    def action_delete_poly(self):\n        if self.op_mode == OpMode.EDIT_PTS and \\\n            self.drag_type == DragType.NONE and \\\n            self.pt_edit_mode == PTEditMode.MOVE:\n            # Delete current poly\n            self.ie_polys.remove_poly (self.op_poly)\n            self.set_op_mode(OpMode.NONE)\n\n    # ====================================================================================\n    # ====================================================================================\n    # ================================== OVERRIDE QT METHODS =============================\n    # ====================================================================================\n    # ====================================================================================\n    def on_keyPressEvent(self, ev):\n        if not self.initialized:\n            return\n        key = ev.key()\n        key_mods = int(ev.modifiers())\n        if self.op_mode == OpMode.DRAW_PTS:\n            self.set_view_lock(ViewLock.CENTER if key_mods == Qt.ShiftModifier else ViewLock.NONE )\n        elif self.op_mode == OpMode.EDIT_PTS:\n            self.set_pt_edit_mode(PTEditMode.ADD_DEL if key_mods == Qt.ControlModifier else PTEditMode.MOVE )\n\n    def on_keyReleaseEvent(self, ev):\n        if not self.initialized:\n            return\n        key = ev.key()\n        key_mods = int(ev.modifiers())\n        if self.op_mode == OpMode.DRAW_PTS:\n            self.set_view_lock(ViewLock.CENTER if key_mods == Qt.ShiftModifier else ViewLock.NONE )\n        elif self.op_mode == OpMode.EDIT_PTS:\n            self.set_pt_edit_mode(PTEditMode.ADD_DEL if key_mods == Qt.ControlModifier else PTEditMode.MOVE )\n\n    def enterEvent(self, ev):\n        super().enterEvent(ev)\n        self.mouse_in_widget = True\n        self.update_cursor()\n\n    def leaveEvent(self, ev):\n        super().leaveEvent(ev)\n        self.mouse_in_widget = False\n        self.update_cursor()\n\n    def mousePressEvent(self, ev):\n        super().mousePressEvent(ev)\n        if not self.initialized:\n            return\n\n        self.update_mouse_info(QPoint_to_np(ev.pos()))\n\n        btn = ev.button()\n\n        if btn == Qt.LeftButton:\n            if self.op_mode == OpMode.NONE:\n                # Clicking in NO OPERATION mode\n                if self.mouse_wire_poly is not None:\n                    # Click on wire on any poly -> switch to EDIT_MODE\n                    self.set_op_mode(OpMode.EDIT_PTS, op_poly=self.mouse_wire_poly)\n                else:\n                    # Click on empty space -> create new poly with one point\n                    new_poly = self.ie_polys.add_poly(self.poly_include_type)\n                    self.ie_polys.sort()\n                    new_poly.add_pt(*self.mouse_img_pt)\n                    self.set_op_mode(OpMode.DRAW_PTS, op_poly=new_poly )\n\n            elif self.op_mode == OpMode.DRAW_PTS:\n                # Clicking in DRAW_PTS mode\n                if len(self.op_poly.get_pts()) >= 3 and self.mouse_op_poly_pt_id == 0:\n                    # Click on first point -> close poly and switch to edit mode\n                    self.set_op_mode(OpMode.EDIT_PTS, op_poly=self.op_poly)\n                else:\n                    # Click on empty space -> add point to current poly\n                    self.op_poly.add_pt(*self.mouse_img_pt)\n                    self.update()\n\n            elif self.op_mode == OpMode.EDIT_PTS:\n                # Clicking in EDIT_PTS mode\n\n                if self.mouse_op_poly_pt_id is not None:\n                    # Click on point of op_poly\n                    if self.pt_edit_mode == PTEditMode.ADD_DEL:\n                        # in mode 'delete point'\n                        self.op_poly.remove_pt(self.mouse_op_poly_pt_id)\n                        if self.op_poly.get_pts_count() < 3:\n                            # not enough points after delete -> remove poly\n                            self.ie_polys.remove_poly (self.op_poly)\n                            self.set_op_mode(OpMode.NONE)\n                        self.update()\n\n                    elif self.drag_type == DragType.NONE:\n                        # otherwise -> start drag\n                        self.drag_type = DragType.POLY_PT\n                        self.drag_cli_pt     = self.mouse_cli_pt\n                        self.drag_poly_pt_id = self.mouse_op_poly_pt_id\n                        self.drag_poly_pt    = self.op_poly.get_pts()[ self.drag_poly_pt_id ]\n                elif self.mouse_op_poly_edge_id is not None:\n                    # Click on edge of op_poly\n                    if self.pt_edit_mode == PTEditMode.ADD_DEL:\n                        # in mode 'insert new point'\n                        edge_img_pt = self.cli_to_img_pt(self.mouse_op_poly_edge_id_pt)\n                        self.op_poly.insert_pt (self.mouse_op_poly_edge_id+1, edge_img_pt)\n                        self.update()\n                    else:\n                        # Otherwise do nothing\n                        pass\n                else:\n                    # other cases -> unselect poly\n                    self.set_op_mode(OpMode.NONE)\n\n        elif btn == Qt.MiddleButton:\n            if self.drag_type == DragType.NONE:\n                # Start image drag\n                self.drag_type = DragType.IMAGE_LOOK\n                self.drag_cli_pt = self.mouse_cli_pt\n                self.drag_img_look_pt = self.get_img_look_pt()\n                self.update_cursor()\n\n\n    def mouseReleaseEvent(self, ev):\n        super().mouseReleaseEvent(ev)\n        if not self.initialized:\n            return\n\n        self.update_mouse_info(QPoint_to_np(ev.pos()))\n\n        btn = ev.button()\n\n        if btn == Qt.LeftButton:\n            if self.op_mode == OpMode.EDIT_PTS:\n                if self.drag_type == DragType.POLY_PT:\n                    self.drag_type = DragType.NONE\n                    self.update()\n\n        elif btn == Qt.MiddleButton:\n            if self.drag_type == DragType.IMAGE_LOOK:\n                self.drag_type = DragType.NONE\n                self.update_cursor()\n                self.update()\n\n    def mouseMoveEvent(self, ev):\n        super().mouseMoveEvent(ev)\n        if not self.initialized:\n            return\n\n        prev_mouse_cli_pt = self.mouse_cli_pt\n        self.update_mouse_info(QPoint_to_np(ev.pos()))\n\n        if self.view_lock == ViewLock.CENTER:\n            if npla.norm(self.mouse_cli_pt - prev_mouse_cli_pt) >= 1:\n                self.img_look_pt = self.mouse_img_pt\n                QCursor.setPos ( self.mapToGlobal( QPoint_from_np(self.img_to_cli_pt(self.img_look_pt)) ))\n            self.update()\n\n        if self.drag_type == DragType.IMAGE_LOOK:\n            delta_pt = self.cli_to_img_pt(self.mouse_cli_pt) - self.cli_to_img_pt(self.drag_cli_pt)\n            self.img_look_pt = self.drag_img_look_pt - delta_pt\n            self.update()\n\n        if self.op_mode == OpMode.DRAW_PTS:\n            self.update()\n        elif self.op_mode == OpMode.EDIT_PTS:\n            if self.drag_type == DragType.POLY_PT:\n                delta_pt = self.cli_to_img_pt(self.mouse_cli_pt) - self.cli_to_img_pt(self.drag_cli_pt)\n                self.op_poly.set_point(self.drag_poly_pt_id, self.drag_poly_pt + delta_pt)\n                self.update()\n\n    def wheelEvent(self, ev):\n        super().wheelEvent(ev)\n\n        if not self.initialized:\n            return\n\n        mods = int(ev.modifiers())\n        delta = ev.angleDelta()\n\n        cli_pt = QPoint_to_np(ev.pos())\n\n        if self.drag_type == DragType.NONE:\n            sign = np.sign( delta.y() )\n            prev_img_pos = self.cli_to_img_pt (cli_pt)\n            delta_scale = sign*0.2 + sign * self.get_view_scale() / 10.0\n            self.view_scale = np.clip(self.get_view_scale() + delta_scale, 1.0, 20.0)\n            new_img_pos = self.cli_to_img_pt (cli_pt)\n            if sign > 0:\n                self.img_look_pt = self.get_img_look_pt() + (prev_img_pos-new_img_pos)#*1.5\n            else:\n                QCursor.setPos ( self.mapToGlobal(QPoint_from_np(self.img_to_cli_pt(prev_img_pos))) )\n            self.update()\n\n    def paintEvent(self, event):\n        super().paintEvent(event)\n        if not self.initialized:\n            return\n\n        qp = self.qp\n        qp.begin(self)\n        qp.setRenderHint(QPainter.Antialiasing)\n        qp.setRenderHint(QPainter.HighQualityAntialiasing)\n        qp.setRenderHint(QPainter.SmoothPixmapTransform)\n\n        src_rect = QRect(0, 0, *self.img_size)\n        dst_rect = self.img_to_cli_rect( src_rect )\n\n        if self.op_mode == OpMode.VIEW_BAKED:\n            qp.drawPixmap(dst_rect, self.img_baked_pixmap, src_rect)\n        elif self.op_mode == OpMode.VIEW_XSEG_MASK:\n            if self.xseg_mask_pixmap is not None:\n                qp.drawPixmap(dst_rect, self.xseg_mask_pixmap, src_rect)\n        else:\n            if self.cbar.btn_view_xseg_overlay_mask_act.isChecked() and \\\n               self.xseg_overlay_mask_pixmap is not None:\n                qp.drawPixmap(dst_rect, self.xseg_overlay_mask_pixmap, src_rect)\n            elif self.img_pixmap is not None:\n                qp.drawPixmap(dst_rect, self.img_pixmap, src_rect)\n\n            polys = self.ie_polys.get_polys()\n            polys_len = len(polys)\n\n            color_scheme = self.get_current_color_scheme()\n\n            pt_rad = self.canvas_config.pt_radius\n            pt_rad_x2 = pt_rad*2\n\n            pt_select_radius = self.canvas_config.pt_select_radius\n\n            op_mode = self.op_mode\n            op_poly = self.op_poly\n\n            for i,poly in enumerate(polys):\n\n                selected_pt_path = QPainterPath()\n                poly_line_path = QPainterPath()\n                pts_line_path = QPainterPath()\n\n                pt_remove_cli_pt = None\n                poly_pts = poly.get_pts()\n                for pt_id, img_pt in enumerate(poly_pts):\n                    cli_pt = self.img_to_cli_pt(img_pt)\n                    q_cli_pt = QPoint_from_np(cli_pt)\n\n                    if pt_id == 0:\n                        poly_line_path.moveTo(q_cli_pt)\n                    else:\n                        poly_line_path.lineTo(q_cli_pt)\n\n\n                    if poly == op_poly:\n                        if self.op_mode == OpMode.DRAW_PTS or \\\n                            (self.op_mode == OpMode.EDIT_PTS and \\\n                            (self.pt_edit_mode == PTEditMode.MOVE) or \\\n                            (self.pt_edit_mode == PTEditMode.ADD_DEL and self.mouse_op_poly_pt_id == pt_id) \\\n                            ):\n                            pts_line_path.moveTo( QPoint_from_np(cli_pt + np.float32([0,-pt_rad])) )\n                            pts_line_path.lineTo( QPoint_from_np(cli_pt + np.float32([0,pt_rad])) )\n                            pts_line_path.moveTo( QPoint_from_np(cli_pt + np.float32([-pt_rad,0])) )\n                            pts_line_path.lineTo( QPoint_from_np(cli_pt + np.float32([pt_rad,0])) )\n\n                        if (self.op_mode == OpMode.EDIT_PTS and \\\n                            self.pt_edit_mode == PTEditMode.ADD_DEL and \\\n                            self.mouse_op_poly_pt_id == pt_id):\n                            pt_remove_cli_pt = cli_pt\n\n                        if self.op_mode == OpMode.DRAW_PTS and \\\n                            len(op_poly.get_pts()) >= 3 and pt_id == 0 and self.mouse_op_poly_pt_id == pt_id:\n                            # Circle around poly point\n                            selected_pt_path.addEllipse(q_cli_pt, pt_rad_x2, pt_rad_x2)\n\n\n                if poly == op_poly:\n                    if op_mode == OpMode.DRAW_PTS:\n                        # Line from last point to mouse\n                        poly_line_path.lineTo( QPoint_from_np(self.mouse_cli_pt) )\n\n                    if self.mouse_op_poly_pt_id is not None:\n                        pass\n\n                    if self.mouse_op_poly_edge_id_pt is not None:\n                        if self.pt_edit_mode == PTEditMode.ADD_DEL and self.mouse_op_poly_pt_id is None:\n                            # Ready to insert point on edge\n                            m_cli_pt = self.mouse_op_poly_edge_id_pt\n                            pts_line_path.moveTo( QPoint_from_np(m_cli_pt + np.float32([0,-pt_rad])) )\n                            pts_line_path.lineTo( QPoint_from_np(m_cli_pt + np.float32([0,pt_rad])) )\n                            pts_line_path.moveTo( QPoint_from_np(m_cli_pt + np.float32([-pt_rad,0])) )\n                            pts_line_path.lineTo( QPoint_from_np(m_cli_pt + np.float32([pt_rad,0])) )\n\n                if len(poly_pts) >= 2:\n                    # Closing poly line\n                    poly_line_path.lineTo( QPoint_from_np(self.img_to_cli_pt(poly_pts[0])) )\n\n                # Draw calls\n                qp.setPen(color_scheme.pt_outline_pen)\n                qp.setBrush(QBrush())\n                qp.drawPath(selected_pt_path)\n\n                qp.setPen(color_scheme.poly_outline_solid_pen)\n                qp.setBrush(QBrush())\n                qp.drawPath(pts_line_path)\n\n                if poly.get_type() == SegIEPolyType.INCLUDE:\n                    qp.setPen(color_scheme.poly_outline_solid_pen)\n                else:\n                    qp.setPen(color_scheme.poly_outline_dot_pen)\n\n                qp.setBrush(color_scheme.poly_unselected_brush)\n                if op_mode == OpMode.NONE:\n                    if poly == self.mouse_wire_poly:\n                        qp.setBrush(color_scheme.poly_selected_brush)\n                #else:\n                #    if poly == op_poly:\n                #        qp.setBrush(color_scheme.poly_selected_brush)\n\n                qp.drawPath(poly_line_path)\n\n                if pt_remove_cli_pt is not None:\n                    qp.setPen(color_scheme.poly_outline_solid_pen)\n                    qp.setBrush(QBrush())\n\n                    qp.drawLine( *(pt_remove_cli_pt + np.float32([-pt_rad_x2,-pt_rad_x2])), *(pt_remove_cli_pt + np.float32([pt_rad_x2,pt_rad_x2])) )\n                    qp.drawLine( *(pt_remove_cli_pt + np.float32([-pt_rad_x2,pt_rad_x2])), *(pt_remove_cli_pt + np.float32([pt_rad_x2,-pt_rad_x2])) )\n\n        qp.end()\n\nclass QCanvas(QFrame):\n    def __init__(self):\n        super().__init__()\n\n        self.canvas_control_left_bar = QCanvasControlsLeftBar()\n        self.canvas_control_right_bar = QCanvasControlsRightBar()\n\n        cbar = sn( btn_poly_color_red_act   = self.canvas_control_right_bar.btn_poly_color_red_act,\n                   btn_poly_color_green_act = self.canvas_control_right_bar.btn_poly_color_green_act,\n                   btn_poly_color_blue_act  = self.canvas_control_right_bar.btn_poly_color_blue_act,\n                   btn_view_baked_mask_act  = self.canvas_control_right_bar.btn_view_baked_mask_act,\n                   btn_view_xseg_mask_act  = self.canvas_control_right_bar.btn_view_xseg_mask_act,\n                   btn_view_xseg_overlay_mask_act  = self.canvas_control_right_bar.btn_view_xseg_overlay_mask_act,\n                   btn_poly_color_act_grp = self.canvas_control_right_bar.btn_poly_color_act_grp,\n                   btn_view_lock_center_act = self.canvas_control_right_bar.btn_view_lock_center_act,\n\n                   btn_poly_type_include_act = self.canvas_control_left_bar.btn_poly_type_include_act,\n                   btn_poly_type_exclude_act = self.canvas_control_left_bar.btn_poly_type_exclude_act,\n                   btn_poly_type_act_grp = self.canvas_control_left_bar.btn_poly_type_act_grp,\n                   btn_undo_pt_act = self.canvas_control_left_bar.btn_undo_pt_act,\n                   btn_redo_pt_act = self.canvas_control_left_bar.btn_redo_pt_act,\n                   btn_delete_poly_act = self.canvas_control_left_bar.btn_delete_poly_act,\n                   btn_pt_edit_mode_act = self.canvas_control_left_bar.btn_pt_edit_mode_act )\n\n        self.op = QCanvasOperator(cbar)\n        self.l = QHBoxLayout()\n        self.l.setContentsMargins(0,0,0,0)\n        self.l.addWidget(self.canvas_control_left_bar)\n        self.l.addWidget(self.op)\n        self.l.addWidget(self.canvas_control_right_bar)\n        self.setLayout(self.l)\n\nclass LoaderQSubprocessor(QSubprocessor):\n    def __init__(self, image_paths, q_label, q_progressbar, on_finish_func ):\n\n        self.image_paths = image_paths\n        self.image_paths_len = len(image_paths)\n        self.idxs = [*range(self.image_paths_len)]\n\n        self.filtered_image_paths = self.image_paths.copy()\n\n        self.image_paths_has_ie_polys = { image_path : False for image_path in self.image_paths }\n\n        self.q_label = q_label\n        self.q_progressbar = q_progressbar\n        self.q_progressbar.setRange(0, self.image_paths_len)\n        self.q_progressbar.setValue(0)\n        self.q_progressbar.update()\n        self.on_finish_func = on_finish_func\n        self.done_count = 0\n        super().__init__('LoaderQSubprocessor', LoaderQSubprocessor.Cli, 60)\n\n    def get_data(self, host_dict):\n        if len (self.idxs) > 0:\n            idx = self.idxs.pop(0)\n            image_path = self.image_paths[idx]\n            self.q_label.setText(f'{QStringDB.loading_tip}... {image_path.name}')\n\n            return idx, image_path\n\n        return None\n\n    def on_clients_finalized(self):\n        self.on_finish_func([x for x in self.filtered_image_paths if x is not None], self.image_paths_has_ie_polys)\n\n    def on_data_return (self, host_dict, data):\n        self.idxs.insert(0, data[0])\n\n    def on_result (self, host_dict, data, result):\n        idx, has_dflimg, has_ie_polys = result\n\n        if not has_dflimg:\n            self.filtered_image_paths[idx] = None\n        self.image_paths_has_ie_polys[self.image_paths[idx]] = has_ie_polys\n\n        self.done_count += 1\n        if self.q_progressbar is not None:\n            self.q_progressbar.setValue(self.done_count)\n\n    class Cli(QSubprocessor.Cli):\n        def process_data(self, data):\n            idx, filename = data\n            dflimg = DFLIMG.load(filename)\n            if dflimg is not None and dflimg.has_data():\n                ie_polys = dflimg.get_seg_ie_polys()\n\n                return idx, True, ie_polys.has_polys()\n            return idx, False, False\n\nclass MainWindow(QXMainWindow):\n\n    def __init__(self, input_dirpath, cfg_root_path):\n        self.loading_frame = None\n        self.help_frame = None\n\n        super().__init__()\n\n        self.input_dirpath = input_dirpath\n        self.trash_dirpath = input_dirpath.parent / (input_dirpath.name + '_trash')\n        self.cfg_root_path = cfg_root_path\n\n        self.cfg_path = cfg_root_path / 'MainWindow_cfg.dat'\n        self.cfg_dict = pickle.loads(self.cfg_path.read_bytes()) if self.cfg_path.exists() else {}\n\n        self.cached_images = {}\n        self.cached_has_ie_polys = {}\n\n        self.initialize_ui()\n\n        # Loader\n        self.loading_frame = QFrame(self.main_canvas_frame)\n        self.loading_frame.setAutoFillBackground(True)\n        self.loading_frame.setFrameShape(QFrame.StyledPanel)\n        self.loader_label = QLabel()\n        self.loader_progress_bar = QProgressBar()\n\n        intro_image = QLabel()\n        intro_image.setPixmap( QPixmap.fromImage(QImageDB.intro) )\n\n        intro_image_frame_l = QVBoxLayout()\n        intro_image_frame_l.addWidget(intro_image, alignment=Qt.AlignCenter)\n        intro_image_frame = QFrame()\n        intro_image_frame.setSizePolicy (QSizePolicy.Expanding, QSizePolicy.Expanding)\n        intro_image_frame.setLayout(intro_image_frame_l)\n\n        loading_frame_l = QVBoxLayout()\n        loading_frame_l.addWidget (intro_image_frame)\n        loading_frame_l.addWidget (self.loader_label)\n        loading_frame_l.addWidget (self.loader_progress_bar)\n        self.loading_frame.setLayout(loading_frame_l)\n\n        self.loader_subprocessor = LoaderQSubprocessor( image_paths=pathex.get_image_paths(input_dirpath, return_Path_class=True),\n                                                        q_label=self.loader_label,\n                                                        q_progressbar=self.loader_progress_bar,\n                                                        on_finish_func=self.on_loader_finish )\n\n\n    def on_loader_finish(self, image_paths, image_paths_has_ie_polys):\n        self.image_paths_done = []\n        self.image_paths = image_paths\n        self.image_paths_has_ie_polys = image_paths_has_ie_polys\n        self.set_has_ie_polys_count ( len([ 1 for x in self.image_paths_has_ie_polys if self.image_paths_has_ie_polys[x] == True]) )\n        self.loading_frame.hide()\n        self.loading_frame = None\n\n        self.process_next_image(first_initialization=True)\n\n    def closeEvent(self, ev):\n        self.cfg_dict['geometry'] = self.saveGeometry().data()\n        self.cfg_path.write_bytes( pickle.dumps(self.cfg_dict) )\n\n\n    def update_cached_images (self, count=5):\n        d = self.cached_images\n\n        for image_path in self.image_paths_done[:-count]+self.image_paths[count:]:\n            if image_path in d:\n                del d[image_path]\n\n        for image_path in self.image_paths[:count]+self.image_paths_done[-count:]:\n            if image_path not in d:\n                img = cv2_imread(image_path)\n                if img is not None:\n                    d[image_path] = img\n\n    def load_image(self, image_path):\n        try:\n            img = self.cached_images.get(image_path, None)\n            if img is None:\n                img = cv2_imread(image_path)\n                self.cached_images[image_path] = img\n            if img is None:\n                io.log_err(f'Unable to load {image_path}')\n        except:\n            img = None\n\n        return img\n\n    def update_preview_bar(self):\n        count = self.image_bar.get_preview_images_count()\n        d = self.cached_images\n        prev_imgs = [ d.get(image_path, None) for image_path in self.image_paths_done[-1:-count:-1] ]\n        next_imgs = [ d.get(image_path, None) for image_path in self.image_paths[:count] ]\n        self.image_bar.update_images(prev_imgs, next_imgs)\n\n\n    def canvas_initialize(self, image_path, only_has_polys=False):\n        if only_has_polys and not self.image_paths_has_ie_polys[image_path]:\n            return False\n\n        dflimg = DFLIMG.load(image_path)\n        if not dflimg or not dflimg.has_data():\n            return False\n\n        ie_polys = dflimg.get_seg_ie_polys()\n        xseg_mask = dflimg.get_xseg_mask()\n        img = self.load_image(image_path)\n        if img is None:\n            return False\n\n        self.canvas.op.initialize ( img,  ie_polys=ie_polys, xseg_mask=xseg_mask )\n\n        self.filename_label.setText(f\"{image_path.name}\")\n\n        return True\n\n    def canvas_finalize(self, image_path):\n        self.canvas.op.finalize()\n\n        if image_path.exists():\n            dflimg = DFLIMG.load(image_path)\n            ie_polys = dflimg.get_seg_ie_polys()\n            new_ie_polys = self.canvas.op.get_ie_polys()\n\n            if not new_ie_polys.identical(ie_polys):\n                prev_has_polys = self.image_paths_has_ie_polys[image_path]\n                self.image_paths_has_ie_polys[image_path] = new_ie_polys.has_polys()\n                new_has_polys = self.image_paths_has_ie_polys[image_path]\n\n                if not prev_has_polys and new_has_polys:\n                    self.set_has_ie_polys_count ( self.get_has_ie_polys_count() +1)\n                elif prev_has_polys and not new_has_polys:\n                    self.set_has_ie_polys_count ( self.get_has_ie_polys_count() -1)\n\n                dflimg.set_seg_ie_polys( new_ie_polys )\n                dflimg.save()\n\n        self.filename_label.setText(f\"\")\n\n    def process_prev_image(self):\n        key_mods = QApplication.keyboardModifiers()\n        step = 5 if key_mods == Qt.ShiftModifier else 1\n        only_has_polys = key_mods == Qt.ControlModifier\n\n        if self.canvas.op.is_initialized():\n            self.canvas_finalize(self.image_paths[0])\n\n        while True:\n            for _ in range(step):\n                if len(self.image_paths_done) != 0:\n                    self.image_paths.insert (0, self.image_paths_done.pop(-1))\n                else:\n                    break\n            if len(self.image_paths) == 0:\n                break\n\n            ret = self.canvas_initialize(self.image_paths[0], len(self.image_paths_done) != 0 and only_has_polys)\n\n            if ret or len(self.image_paths_done) == 0:\n                break\n\n        self.update_cached_images()\n        self.update_preview_bar()\n\n    def process_next_image(self, first_initialization=False):\n        key_mods = QApplication.keyboardModifiers()\n\n        step = 0 if first_initialization else 5 if key_mods == Qt.ShiftModifier else 1\n        only_has_polys = False if first_initialization else key_mods == Qt.ControlModifier\n\n        if self.canvas.op.is_initialized():\n            self.canvas_finalize(self.image_paths[0])\n\n        while True:\n            for _ in range(step):\n                if len(self.image_paths) != 0:\n                    self.image_paths_done.append(self.image_paths.pop(0))\n                else:\n                    break\n            if len(self.image_paths) == 0:\n                break\n            if self.canvas_initialize(self.image_paths[0], only_has_polys):\n                break\n\n        self.update_cached_images()\n        self.update_preview_bar()\n        \n    def trash_current_image(self):\n        self.process_next_image()\n        \n        img_path = self.image_paths_done.pop(-1)\n        img_path = Path(img_path)\n        self.trash_dirpath.mkdir(parents=True, exist_ok=True)\n        img_path.rename( self.trash_dirpath / img_path.name )\n        \n        self.update_cached_images()\n        self.update_preview_bar()\n        \n    def initialize_ui(self):\n\n        self.canvas = QCanvas()\n\n        image_bar = self.image_bar = ImagePreviewSequenceBar(preview_images_count=9, icon_size=QUIConfig.preview_bar_icon_q_size.width())\n        image_bar.setSizePolicy ( QSizePolicy.Fixed, QSizePolicy.Fixed )\n\n\n        btn_prev_image = QXIconButton(QIconDB.left, QStringDB.btn_prev_image_tip, shortcut='A', click_func=self.process_prev_image)\n        btn_prev_image.setIconSize(QUIConfig.preview_bar_icon_q_size)\n\n        btn_next_image = QXIconButton(QIconDB.right, QStringDB.btn_next_image_tip, shortcut='D', click_func=self.process_next_image)\n        btn_next_image.setIconSize(QUIConfig.preview_bar_icon_q_size)\n\n        btn_delete_image = QXIconButton(QIconDB.trashcan, QStringDB.btn_delete_image_tip, shortcut='X', click_func=self.trash_current_image)\n        btn_delete_image.setIconSize(QUIConfig.preview_bar_icon_q_size)\n    \n        pad_image = QWidget()\n        pad_image.setFixedSize(QUIConfig.preview_bar_icon_q_size)\n        \n        preview_image_bar_frame_l = QHBoxLayout()\n        preview_image_bar_frame_l.setContentsMargins(0,0,0,0)\n        preview_image_bar_frame_l.addWidget ( pad_image, alignment=Qt.AlignCenter)\n        preview_image_bar_frame_l.addWidget ( btn_prev_image, alignment=Qt.AlignCenter)\n        preview_image_bar_frame_l.addWidget ( image_bar)\n        preview_image_bar_frame_l.addWidget ( btn_next_image, alignment=Qt.AlignCenter)\n        #preview_image_bar_frame_l.addWidget ( btn_delete_image, alignment=Qt.AlignCenter)\n\n        preview_image_bar_frame = QFrame()\n        preview_image_bar_frame.setSizePolicy ( QSizePolicy.Fixed, QSizePolicy.Fixed )\n        preview_image_bar_frame.setLayout(preview_image_bar_frame_l)\n\n        preview_image_bar_frame2_l = QHBoxLayout()\n        preview_image_bar_frame2_l.setContentsMargins(0,0,0,0)\n        preview_image_bar_frame2_l.addWidget ( btn_delete_image, alignment=Qt.AlignCenter)\n\n        preview_image_bar_frame2 = QFrame()\n        preview_image_bar_frame2.setSizePolicy ( QSizePolicy.Fixed, QSizePolicy.Fixed )\n        preview_image_bar_frame2.setLayout(preview_image_bar_frame2_l)\n        \n        preview_image_bar_l = QHBoxLayout()\n        preview_image_bar_l.addWidget (preview_image_bar_frame, alignment=Qt.AlignCenter)\n        preview_image_bar_l.addWidget (preview_image_bar_frame2)\n        \n        preview_image_bar = QFrame()\n        preview_image_bar.setFrameShape(QFrame.StyledPanel)\n        preview_image_bar.setSizePolicy ( QSizePolicy.Expanding, QSizePolicy.Fixed )\n        preview_image_bar.setLayout(preview_image_bar_l)\n\n        label_font = QFont('Courier New')\n        self.filename_label = QLabel()\n        self.filename_label.setFont(label_font)\n\n        self.has_ie_polys_count_label = QLabel()\n\n        status_frame_l = QHBoxLayout()\n        status_frame_l.setContentsMargins(0,0,0,0)\n        status_frame_l.addWidget ( QLabel(), alignment=Qt.AlignCenter)\n        status_frame_l.addWidget (self.filename_label, alignment=Qt.AlignCenter)\n        status_frame_l.addWidget (self.has_ie_polys_count_label, alignment=Qt.AlignCenter)\n        status_frame = QFrame()\n        status_frame.setLayout(status_frame_l)\n\n        main_canvas_l = QVBoxLayout()\n        main_canvas_l.setContentsMargins(0,0,0,0)\n        main_canvas_l.addWidget (self.canvas)\n        main_canvas_l.addWidget (status_frame)\n        main_canvas_l.addWidget (preview_image_bar)\n\n        self.main_canvas_frame = QFrame()\n        self.main_canvas_frame.setLayout(main_canvas_l)\n\n        self.main_l = QHBoxLayout()\n        self.main_l.setContentsMargins(0,0,0,0)\n        self.main_l.addWidget (self.main_canvas_frame)\n\n        self.setLayout(self.main_l)\n\n        geometry = self.cfg_dict.get('geometry', None)\n        if geometry is not None:\n            self.restoreGeometry(geometry)\n        else:\n            self.move( QPoint(0,0))\n\n    def get_has_ie_polys_count(self):\n        return self.has_ie_polys_count\n\n    def set_has_ie_polys_count(self, c):\n        self.has_ie_polys_count = c\n        self.has_ie_polys_count_label.setText(f\"{c} {QStringDB.labeled_tip}\")\n\n    def resizeEvent(self, ev):\n        if self.loading_frame is not None:\n            self.loading_frame.resize( ev.size() )\n        if self.help_frame is not None:\n            self.help_frame.resize( ev.size() )\n\ndef start(input_dirpath):\n    \"\"\"\n    returns exit_code\n    \"\"\"\n    io.log_info(\"Running XSeg editor.\")\n\n    if PackedFaceset.path_contains(input_dirpath):\n        io.log_info (f'\\n{input_dirpath} contains packed faceset! Unpack it first.\\n')\n        return 1\n\n    root_path = Path(__file__).parent\n    cfg_root_path = Path(tempfile.gettempdir())\n\n    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling, True)\n    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps, True)\n\n    app = QApplication([])\n    app.setApplicationName(\"XSegEditor\")\n    app.setStyle('Fusion')\n\n    QFontDatabase.addApplicationFont( str(root_path / 'gfx' / 'fonts' / 'NotoSans-Medium.ttf') )\n\n    app.setFont( QFont('NotoSans'))\n\n    QUIConfig.initialize()\n    QStringDB.initialize()\n\n    QIconDB.initialize( root_path / 'gfx' / 'icons' )\n    QCursorDB.initialize( root_path / 'gfx' / 'cursors' )\n    QImageDB.initialize( root_path / 'gfx' / 'images' )\n\n    app.setWindowIcon(QIconDB.app_icon)\n    app.setPalette( QDarkPalette() )\n\n    win = MainWindow( input_dirpath=input_dirpath, cfg_root_path=cfg_root_path)\n\n    win.show()\n    win.raise_()\n\n    app.exec_()\n    return 0\n"}