{"setup.py": "import sys, os, platform\nimport subprocess\nimport errno\n\n# the setuptools distutils shim should make distutils available, but this will definitely do\n# it, since setuptools is now required at build-time\nimport setuptools\n\n\nsources = ['src/c/_cffi_backend.c']\nlibraries = ['ffi']\ninclude_dirs = ['/usr/include/ffi',\n                '/usr/include/libffi']    # may be changed by pkg-config\ndefine_macros = [('FFI_BUILDING', '1')]   # for linking with libffi static library\nlibrary_dirs = []\nextra_compile_args = []\nextra_link_args = []\n\n\ndef _ask_pkg_config(resultlist, option, result_prefix='', sysroot=False):\n    pkg_config = os.environ.get('PKG_CONFIG','pkg-config')\n    try:\n        p = subprocess.Popen([pkg_config, option, 'libffi'],\n                             stdout=subprocess.PIPE)\n    except OSError as e:\n        if e.errno not in [errno.ENOENT, errno.EACCES]:\n            raise\n    else:\n        t = p.stdout.read().decode().strip()\n        p.stdout.close()\n        if p.wait() == 0:\n            res = t.split()\n            # '-I/usr/...' -> '/usr/...'\n            for x in res:\n                assert x.startswith(result_prefix)\n            res = [x[len(result_prefix):] for x in res]\n            #print 'PKG_CONFIG:', option, res\n            #\n            sysroot = sysroot and os.environ.get('PKG_CONFIG_SYSROOT_DIR', '')\n            if sysroot:\n                # old versions of pkg-config don't support this env var,\n                # so here we emulate its effect if needed\n                res = [path if path.startswith(sysroot)\n                            else sysroot + path\n                         for path in res]\n            #\n            resultlist[:] = res\n\nno_compiler_found = False\ndef no_working_compiler_found():\n    sys.stderr.write(\"\"\"\n    No working compiler found, or bogus compiler options passed to\n    the compiler from Python's standard \"distutils\" module.  See\n    the error messages above.  Likely, the problem is not related\n    to CFFI but generic to the setup.py of any Python package that\n    tries to compile C code.  (Hints: on OS/X 10.8, for errors about\n    -mno-fused-madd see http://stackoverflow.com/questions/22313407/\n    Otherwise, see https://wiki.python.org/moin/CompLangPython or\n    the IRC channel #python on irc.libera.chat.)\n\n    Trying to continue anyway.  If you are trying to install CFFI from\n    a build done in a different context, you can ignore this warning.\n    \\n\"\"\")\n    global no_compiler_found\n    no_compiler_found = True\n\ndef get_config():\n    from distutils.core import Distribution\n    from distutils.sysconfig import get_config_vars\n    get_config_vars()      # workaround for a bug of distutils, e.g. on OS/X\n    config = Distribution().get_command_obj('config')\n    return config\n\ndef ask_supports_thread():\n    config = get_config()\n    ok = (sys.platform != 'win32' and\n          config.try_compile('__thread int some_threadlocal_variable_42;'))\n    if ok:\n        define_macros.append(('USE__THREAD', None))\n    else:\n        ok1 = config.try_compile('int some_regular_variable_42;')\n        if not ok1:\n            no_working_compiler_found()\n        else:\n            sys.stderr.write(\"Note: will not use '__thread' in the C code\\n\")\n            _safe_to_ignore()\n\ndef ask_supports_sync_synchronize():\n    if sys.platform == 'win32' or no_compiler_found:\n        return\n    config = get_config()\n    ok = config.try_link('int main(void) { __sync_synchronize(); return 0; }')\n    if ok:\n        define_macros.append(('HAVE_SYNC_SYNCHRONIZE', None))\n    else:\n        sys.stderr.write(\"Note: will not use '__sync_synchronize()'\"\n                         \" in the C code\\n\")\n        _safe_to_ignore()\n\ndef _safe_to_ignore():\n    sys.stderr.write(\"***** The above error message can be safely ignored.\\n\\n\")\n\ndef uses_msvc():\n    config = get_config()\n    return config.try_compile('#ifndef _MSC_VER\\n#error \"not MSVC\"\\n#endif')\n\ndef use_pkg_config():\n    if sys.platform == 'darwin' and os.path.exists('/usr/local/bin/brew'):\n        use_homebrew_for_libffi()\n\n    _ask_pkg_config(include_dirs,       '--cflags-only-I', '-I', sysroot=True)\n    _ask_pkg_config(extra_compile_args, '--cflags-only-other')\n    _ask_pkg_config(library_dirs,       '--libs-only-L', '-L', sysroot=True)\n    _ask_pkg_config(extra_link_args,    '--libs-only-other')\n    _ask_pkg_config(libraries,          '--libs-only-l', '-l')\n\ndef use_homebrew_for_libffi():\n    # We can build by setting:\n    # PKG_CONFIG_PATH = $(brew --prefix libffi)/lib/pkgconfig\n    with os.popen('brew --prefix libffi') as brew_prefix_cmd:\n        prefix = brew_prefix_cmd.read().strip()\n    pkgconfig = os.path.join(prefix, 'lib', 'pkgconfig')\n    os.environ['PKG_CONFIG_PATH'] = (\n        os.environ.get('PKG_CONFIG_PATH', '') + ':' + pkgconfig)\n\nif sys.platform == \"win32\" and uses_msvc():\n    if platform.machine() == \"ARM64\":\n        include_dirs.append(os.path.join(\"src/c/libffi_arm64/include\"))\n        library_dirs.append(os.path.join(\"src/c/libffi_arm64\"))\n    else:\n        COMPILE_LIBFFI = 'src/c/libffi_x86_x64'    # from the CPython distribution\n        assert os.path.isdir(COMPILE_LIBFFI), \"directory not found!\"\n        include_dirs[:] = [COMPILE_LIBFFI]\n        libraries[:] = []\n        _filenames = [filename.lower() for filename in os.listdir(COMPILE_LIBFFI)]\n        _filenames = [filename for filename in _filenames\n                            if filename.endswith('.c')]\n        if sys.maxsize > 2**32:\n            # 64-bit: unlist win32.c, and add instead win64.obj.  If the obj\n            # happens to get outdated at some point in the future, you need to\n            # rebuild it manually from win64.asm.\n            _filenames.remove('win32.c')\n            extra_link_args.append(os.path.join(COMPILE_LIBFFI, 'win64.obj'))\n        sources.extend(os.path.join(COMPILE_LIBFFI, filename)\n                    for filename in _filenames)\nelse:\n    use_pkg_config()\n    ask_supports_thread()\n    ask_supports_sync_synchronize()\n\nif 'darwin' in sys.platform:\n    # priority is given to `pkg_config`, but always fall back on SDK's libffi.\n    extra_compile_args += ['-iwithsysroot/usr/include/ffi']\n\nif 'freebsd' in sys.platform:\n    include_dirs.append('/usr/local/include')\n    library_dirs.append('/usr/local/lib')\n\nforced_extra_objs = os.environ.get('CFFI_FORCE_STATIC', [])\nif forced_extra_objs:\n    forced_extra_objs = forced_extra_objs.split(';')\n\n\nif __name__ == '__main__':\n    from setuptools import setup, Distribution, Extension\n\n    class CFFIDistribution(Distribution):\n        def has_ext_modules(self):\n            # Event if we don't have extension modules (e.g. on PyPy) we want to\n            # claim that we do so that wheels get properly tagged as Python\n            # specific.  (thanks dstufft!)\n            return True\n\n    # On PyPy, cffi is preinstalled and it is not possible, at least for now,\n    # to install a different version.  We work around it by making the setup()\n    # arguments mostly empty in this case.\n    cpython = ('_cffi_backend' not in sys.builtin_module_names)\n\n    install_requires = []\n    if cpython:\n        install_requires.append('pycparser')\n\n    setup(\n        name='cffi',\n        description='Foreign Function Interface for Python calling C code.',\n        long_description=\"\"\"\nCFFI\n====\n\nForeign Function Interface for Python calling C code.\nPlease see the `Documentation <http://cffi.readthedocs.org/>`_.\n\nContact\n-------\n\n`Mailing list <https://groups.google.com/forum/#!forum/python-cffi>`_\n\"\"\",\n        version='1.17.0.dev0',\n        python_requires='>=3.8',\n        packages=['cffi'] if cpython else [],\n        package_dir={\"\": \"src\"},\n        package_data={'cffi': ['_cffi_include.h', 'parse_c_type.h', \n                               '_embedding.h', '_cffi_errors.h']}\n                     if cpython else {},\n        zip_safe=False,\n\n        url='http://cffi.readthedocs.org',\n        author='Armin Rigo, Maciej Fijalkowski',\n        author_email='python-cffi@googlegroups.com',\n\n        license='MIT',\n\n        distclass=CFFIDistribution,\n        ext_modules=[Extension(\n            name='_cffi_backend',\n            include_dirs=include_dirs,\n            sources=sources,\n            libraries=libraries,\n            define_macros=define_macros,\n            library_dirs=library_dirs,\n            extra_compile_args=extra_compile_args,\n            extra_link_args=extra_link_args,\n            extra_objects=forced_extra_objs,\n        )] if cpython else [],\n\n        install_requires=install_requires,\n\n        entry_points = {\n            \"distutils.setup_keywords\": [\n                \"cffi_modules = cffi.setuptools_ext:cffi_modules\",\n            ],\n        },\n\n        classifiers=[\n            'Programming Language :: Python',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Programming Language :: Python :: 3.13',\n            'Programming Language :: Python :: Implementation :: CPython',\n            'Programming Language :: Python :: Implementation :: PyPy',\n            'License :: OSI Approved :: MIT License',\n        ],\n    )\n", "setup_base.py": "import sys, os\n\n\nfrom setup import include_dirs, sources, libraries, define_macros\nfrom setup import library_dirs, extra_compile_args, extra_link_args\n\n\nif __name__ == '__main__':\n    from distutils.core import setup\n    from distutils.extension import Extension\n\n    standard = '__pypy__' not in sys.builtin_module_names\n    setup(packages=['cffi'],\n          requires=['pycparser'],\n          ext_modules=[Extension(name = '_cffi_backend',\n                                 include_dirs=include_dirs,\n                                 sources=sources,\n                                 libraries=libraries,\n                                 define_macros=define_macros,\n                                 library_dirs=library_dirs,\n                                 extra_compile_args=extra_compile_args,\n                                 extra_link_args=extra_link_args,\n                                 )] * standard)\n", "tools/version.py": "#!/usr/bin/env python\n\"\"\"A simple script to update the version embedded in the source.\"\"\"\n\nimport argparse\nimport pathlib\nimport re\n\nfrom packaging.version import Version\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument('version', type=Version, help='version number to embed in source files')\n    args = parser.parse_args()\n    version: Version = args.version\n\n    major_minor_version = f'{version.major}.{version.minor}'\n    version_info = ', '.join(map(repr, get_version_info(version)))\n\n    updates: list[tuple[str, re.Pattern, str | Version]] = [\n        ('doc/source/conf.py', re.compile(r\"^(version = ')[^']*(')$\", flags=re.MULTILINE), major_minor_version),\n        ('doc/source/conf.py', re.compile(r\"^(release = ')[^']*(')$\", flags=re.MULTILINE), version),\n        ('setup.py', re.compile(r\"^( +version=')[^']*(',)$\", flags=re.MULTILINE), version),\n        ('src/c/_cffi_backend.c', re.compile(r'^(#define CFFI_VERSION +\")[^\"]*(\")$', flags=re.MULTILINE), version),\n        ('src/c/test_c.py', re.compile(r'^(assert __version__ == \")[^\"]*(\", .*)$', flags=re.MULTILINE), version),\n        ('src/cffi/__init__.py', re.compile(r'^(__version__ = \")[^\"]*(\")$', flags=re.MULTILINE), version),\n        ('src/cffi/__init__.py', re.compile(r'^(__version_info__ = \\()[^)]*(\\))$', flags=re.MULTILINE), version_info),\n        ('src/cffi/_embedding.h', re.compile(r'^( +\"\\\\ncompiled with cffi version: )[^\"]*(\")$', flags=re.MULTILINE), version),\n    ]\n\n    repo_root = pathlib.Path(__file__).parent.parent\n\n    for relative_path, pattern, replacement in updates:\n        path = repo_root / relative_path\n        original_content = path.read_text()\n\n        if not pattern.search(original_content):\n            raise RuntimeError(f'{relative_path}: no match found for pattern: {pattern.pattern}')\n\n        updated_content = pattern.sub(rf'\\g<1>{replacement}\\g<2>', original_content)\n\n        if updated_content == original_content:\n            print(f'{relative_path}: unchanged')\n        else:\n            path.write_text(updated_content)\n            print(f'{relative_path}: updated')\n\n\ndef get_version_info(version: Version) -> tuple:\n    \"\"\"Return a tuple representing the given version.\"\"\"\n    version_info = list(version.release)\n\n    if version.pre is not None:\n        version_info.append(''.join(map(str, version.pre)))\n\n    if version.post is not None:\n        version_info.append(f'post{version.post}')\n\n    if version.dev is not None:\n        version_info.append(f'dev{version.dev}')\n\n    if version.local is not None:\n        version_info.append(f'+{version.local}')\n\n    return tuple(version_info)\n\n\nif __name__ == '__main__':\n    main()\n", "doc/source/conf.py": "# -*- coding: utf-8 -*-\n#\n# CFFI documentation build configuration file, created by\n# sphinx-quickstart on Thu Jun 14 16:37:47 2012.\n#\n# This file is execfile()d with the current directory set to its containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys, os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#sys.path.append(os.path.abspath('.'))\n\n# -- General configuration -----------------------------------------------------\n\n# Add any Sphinx extension module names here, as strings. They can be extensions\n# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.\nextensions = ['sphinx.ext.autodoc']\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'CFFI'\ncopyright = u'2012-2018, Armin Rigo, Maciej Fijalkowski'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '1.17'\n# The full version, including alpha/beta/rc tags.\nrelease = '1.17.0.dev0'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of documents that shouldn't be included in the build.\n#unused_docs = []\n\n# List of directories, relative to source directory, that shouldn't be searched\n# for source files.\nexclude_trees = []\n\n# The reST default role (used for this markup: `text`) to use for all documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n\n# -- Options for HTML output ---------------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  Major themes that come with\n# Sphinx are currently 'default' and 'sphinxdoc'.\n#html_theme = 'default'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\n#html_static_path = ['_static']\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_use_modindex = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# If nonempty, this is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = ''\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'CFFIdoc'\n\n\n# -- Options for LaTeX output --------------------------------------------------\n\n# The paper size ('letter' or 'a4').\n#latex_paper_size = 'letter'\n\n# The font size ('10pt', '11pt' or '12pt').\n#latex_font_size = '10pt'\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title, author, documentclass [howto/manual]).\nlatex_documents = [\n  ('index', 'CFFI.tex', u'CFFI Documentation',\n   u'Armin Rigo, Maciej Fijalkowski', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# Additional stuff for the LaTeX preamble.\n#latex_preamble = ''\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_use_modindex = True\n", "demo/_curses_build.py": "import sys\nif sys.platform == 'win32':\n    #This module does not exist in windows\n    raise ImportError('No module named _curses')\n\nfrom cffi import FFI\n\nffi = FFI()\n\nffi.cdef(\"\"\"\ntypedef ... WINDOW;\ntypedef ... SCREEN;\ntypedef unsigned long... mmask_t;\ntypedef unsigned char bool;\ntypedef unsigned long... chtype;\ntypedef chtype attr_t;\n\ntypedef struct\n{\n    short id;           /* ID to distinguish multiple devices */\n    int x, y, z;        /* event coordinates (character-cell) */\n    mmask_t bstate;     /* button state bits */\n}\nMEVENT;\n\nstatic const int ERR, OK;\nstatic const int TRUE, FALSE;\nstatic const int KEY_MIN, KEY_MAX;\n\nstatic const int COLOR_BLACK;\nstatic const int COLOR_RED;\nstatic const int COLOR_GREEN;\nstatic const int COLOR_YELLOW;\nstatic const int COLOR_BLUE;\nstatic const int COLOR_MAGENTA;\nstatic const int COLOR_CYAN;\nstatic const int COLOR_WHITE;\n\nstatic const chtype A_ATTRIBUTES;\nstatic const chtype A_NORMAL;\nstatic const chtype A_STANDOUT;\nstatic const chtype A_UNDERLINE;\nstatic const chtype A_REVERSE;\nstatic const chtype A_BLINK;\nstatic const chtype A_DIM;\nstatic const chtype A_BOLD;\nstatic const chtype A_ALTCHARSET;\nstatic const chtype A_INVIS;\nstatic const chtype A_PROTECT;\nstatic const chtype A_CHARTEXT;\nstatic const chtype A_COLOR;\n\nstatic const int BUTTON1_RELEASED;\nstatic const int BUTTON1_PRESSED;\nstatic const int BUTTON1_CLICKED;\nstatic const int BUTTON1_DOUBLE_CLICKED;\nstatic const int BUTTON1_TRIPLE_CLICKED;\nstatic const int BUTTON2_RELEASED;\nstatic const int BUTTON2_PRESSED;\nstatic const int BUTTON2_CLICKED;\nstatic const int BUTTON2_DOUBLE_CLICKED;\nstatic const int BUTTON2_TRIPLE_CLICKED;\nstatic const int BUTTON3_RELEASED;\nstatic const int BUTTON3_PRESSED;\nstatic const int BUTTON3_CLICKED;\nstatic const int BUTTON3_DOUBLE_CLICKED;\nstatic const int BUTTON3_TRIPLE_CLICKED;\nstatic const int BUTTON4_RELEASED;\nstatic const int BUTTON4_PRESSED;\nstatic const int BUTTON4_CLICKED;\nstatic const int BUTTON4_DOUBLE_CLICKED;\nstatic const int BUTTON4_TRIPLE_CLICKED;\nstatic const int BUTTON_SHIFT;\nstatic const int BUTTON_CTRL;\nstatic const int BUTTON_ALT;\nstatic const int ALL_MOUSE_EVENTS;\nstatic const int REPORT_MOUSE_POSITION;\n\nint setupterm(char *, int, int *);\n\nWINDOW *stdscr;\nint COLORS;\nint COLOR_PAIRS;\nint COLS;\nint LINES;\n\nint baudrate(void);\nint beep(void);\nint box(WINDOW *, chtype, chtype);\nbool can_change_color(void);\nint cbreak(void);\nint clearok(WINDOW *, bool);\nint color_content(short, short*, short*, short*);\nint copywin(const WINDOW*, WINDOW*, int, int, int, int, int, int, int);\nint curs_set(int);\nint def_prog_mode(void);\nint def_shell_mode(void);\nint delay_output(int);\nint delwin(WINDOW *);\nWINDOW * derwin(WINDOW *, int, int, int, int);\nint doupdate(void);\nint echo(void);\nint endwin(void);\nchar erasechar(void);\nvoid filter(void);\nint flash(void);\nint flushinp(void);\nchtype getbkgd(WINDOW *);\nWINDOW * getwin(FILE *);\nint halfdelay(int);\nbool has_colors(void);\nbool has_ic(void);\nbool has_il(void);\nvoid idcok(WINDOW *, bool);\nint idlok(WINDOW *, bool);\nvoid immedok(WINDOW *, bool);\nWINDOW * initscr(void);\nint init_color(short, short, short, short);\nint init_pair(short, short, short);\nint intrflush(WINDOW *, bool);\nbool isendwin(void);\nbool is_linetouched(WINDOW *, int);\nbool is_wintouched(WINDOW *);\nconst char * keyname(int);\nint keypad(WINDOW *, bool);\nchar killchar(void);\nint leaveok(WINDOW *, bool);\nchar * longname(void);\nint meta(WINDOW *, bool);\nint mvderwin(WINDOW *, int, int);\nint mvwaddch(WINDOW *, int, int, const chtype);\nint mvwaddnstr(WINDOW *, int, int, const char *, int);\nint mvwaddstr(WINDOW *, int, int, const char *);\nint mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);\nint mvwdelch(WINDOW *, int, int);\nint mvwgetch(WINDOW *, int, int);\nint mvwgetnstr(WINDOW *, int, int, char *, int);\nint mvwin(WINDOW *, int, int);\nchtype mvwinch(WINDOW *, int, int);\nint mvwinnstr(WINDOW *, int, int, char *, int);\nint mvwinsch(WINDOW *, int, int, chtype);\nint mvwinsnstr(WINDOW *, int, int, const char *, int);\nint mvwinsstr(WINDOW *, int, int, const char *);\nint napms(int);\nWINDOW * newpad(int, int);\nWINDOW * newwin(int, int, int, int);\nint nl(void);\nint nocbreak(void);\nint nodelay(WINDOW *, bool);\nint noecho(void);\nint nonl(void);\nvoid noqiflush(void);\nint noraw(void);\nint notimeout(WINDOW *, bool);\nint overlay(const WINDOW*, WINDOW *);\nint overwrite(const WINDOW*, WINDOW *);\nint pair_content(short, short*, short*);\nint pechochar(WINDOW *, const chtype);\nint pnoutrefresh(WINDOW*, int, int, int, int, int, int);\nint prefresh(WINDOW *, int, int, int, int, int, int);\nint putwin(WINDOW *, FILE *);\nvoid qiflush(void);\nint raw(void);\nint redrawwin(WINDOW *);\nint resetty(void);\nint reset_prog_mode(void);\nint reset_shell_mode(void);\nint savetty(void);\nint scroll(WINDOW *);\nint scrollok(WINDOW *, bool);\nint start_color(void);\nWINDOW * subpad(WINDOW *, int, int, int, int);\nWINDOW * subwin(WINDOW *, int, int, int, int);\nint syncok(WINDOW *, bool);\nchtype termattrs(void);\nchar * termname(void);\nint touchline(WINDOW *, int, int);\nint touchwin(WINDOW *);\nint typeahead(int);\nint ungetch(int);\nint untouchwin(WINDOW *);\nvoid use_env(bool);\nint waddch(WINDOW *, const chtype);\nint waddnstr(WINDOW *, const char *, int);\nint waddstr(WINDOW *, const char *);\nint wattron(WINDOW *, int);\nint wattroff(WINDOW *, int);\nint wattrset(WINDOW *, int);\nint wbkgd(WINDOW *, chtype);\nvoid wbkgdset(WINDOW *, chtype);\nint wborder(WINDOW *, chtype, chtype, chtype, chtype,\n            chtype, chtype, chtype, chtype);\nint wchgat(WINDOW *, int, attr_t, short, const void *);\nint wclear(WINDOW *);\nint wclrtobot(WINDOW *);\nint wclrtoeol(WINDOW *);\nvoid wcursyncup(WINDOW *);\nint wdelch(WINDOW *);\nint wdeleteln(WINDOW *);\nint wechochar(WINDOW *, const chtype);\nint werase(WINDOW *);\nint wgetch(WINDOW *);\nint wgetnstr(WINDOW *, char *, int);\nint whline(WINDOW *, chtype, int);\nchtype winch(WINDOW *);\nint winnstr(WINDOW *, char *, int);\nint winsch(WINDOW *, chtype);\nint winsdelln(WINDOW *, int);\nint winsertln(WINDOW *);\nint winsnstr(WINDOW *, const char *, int);\nint winsstr(WINDOW *, const char *);\nint wmove(WINDOW *, int, int);\nint wresize(WINDOW *, int, int);\nint wnoutrefresh(WINDOW *);\nint wredrawln(WINDOW *, int, int);\nint wrefresh(WINDOW *);\nint wscrl(WINDOW *, int);\nint wsetscrreg(WINDOW *, int, int);\nint wstandout(WINDOW *);\nint wstandend(WINDOW *);\nvoid wsyncdown(WINDOW *);\nvoid wsyncup(WINDOW *);\nvoid wtimeout(WINDOW *, int);\nint wtouchln(WINDOW *, int, int, int);\nint wvline(WINDOW *, chtype, int);\nint tigetflag(char *);\nint tigetnum(char *);\nchar * tigetstr(char *);\nint putp(const char *);\nchar * tparm(const char *, ...);\nint getattrs(const WINDOW *);\nint getcurx(const WINDOW *);\nint getcury(const WINDOW *);\nint getbegx(const WINDOW *);\nint getbegy(const WINDOW *);\nint getmaxx(const WINDOW *);\nint getmaxy(const WINDOW *);\nint getparx(const WINDOW *);\nint getpary(const WINDOW *);\n\nint getmouse(MEVENT *);\nint ungetmouse(MEVENT *);\nmmask_t mousemask(mmask_t, mmask_t *);\nbool wenclose(const WINDOW *, int, int);\nint mouseinterval(int);\n\nvoid setsyx(int y, int x);\nconst char *unctrl(chtype);\nint use_default_colors(void);\n\nint has_key(int);\nbool is_term_resized(int, int);\n\n#define _m_STRICT_SYSV_CURSES ...\n#define _m_NCURSES_MOUSE_VERSION ...\n#define _m_NetBSD ...\nint _m_ispad(WINDOW *);\n\nchtype acs_map[];\n\n// For _curses_panel:\n\ntypedef ... PANEL;\n\nWINDOW *panel_window(const PANEL *);\nvoid update_panels(void);\nint hide_panel(PANEL *);\nint show_panel(PANEL *);\nint del_panel(PANEL *);\nint top_panel(PANEL *);\nint bottom_panel(PANEL *);\nPANEL *new_panel(WINDOW *);\nPANEL *panel_above(const PANEL *);\nPANEL *panel_below(const PANEL *);\nint set_panel_userptr(PANEL *, void *);\nconst void *panel_userptr(const PANEL *);\nint move_panel(PANEL *, int, int);\nint replace_panel(PANEL *,WINDOW *);\nint panel_hidden(const PANEL *);\n\nvoid _m_getsyx(int *yx);\n\"\"\")\n\n\nffi.set_source(\"_curses_cffi\", \"\"\"\n#ifdef __APPLE__\n/* the following define is necessary for OS X 10.6+; without it, the\n   Apple-supplied ncurses.h sets NCURSES_OPAQUE to 1, and then Python\n   can't get at the WINDOW flags field. */\n#define NCURSES_OPAQUE 0\n#endif\n\n#include <ncurses.h>\n#include <panel.h>\n#include <term.h>\n\n#if defined STRICT_SYSV_CURSES\n#define _m_STRICT_SYSV_CURSES TRUE\n#else\n#define _m_STRICT_SYSV_CURSES FALSE\n#endif\n\n#if defined NCURSES_MOUSE_VERSION\n#define _m_NCURSES_MOUSE_VERSION TRUE\n#else\n#define _m_NCURSES_MOUSE_VERSION FALSE\n#endif\n\n#if defined __NetBSD__\n#define _m_NetBSD TRUE\n#else\n#define _m_NetBSD FALSE\n#endif\n\nint _m_ispad(WINDOW *win) {\n    // <curses.h> may not have _flags (and possibly _ISPAD),\n    // but for now let's assume that <ncurses.h> always has it\n    return (win->_flags & _ISPAD);\n}\n\nvoid _m_getsyx(int *yx) {\n    getsyx(yx[0], yx[1]);\n}\n\"\"\", libraries=['ncurses', 'panel'])\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/btrfs-snap.py": "\"\"\"\nbtrfs-snap.py: source target newname\n\ncreates a exactly named snapshots and bails out if they exist\n\"\"\"\n\nimport argparse\nimport fcntl\nimport os\nimport sys\n\nimport cffi\n\nffi = cffi.FFI()\n\nffi.cdef(\"\"\"\n    #define BTRFS_IOC_SNAP_CREATE_V2 ...\n    struct btrfs_ioctl_vol_args_v2 {\n        int64_t fd;\n        char name[];\n        ...;\n    };\n\"\"\")\n\nffi.set_source(\"_btrfs_cffi\", \"#include <btrfs/ioctl.h>\")\nffi.compile()\n\n# ____________________________________________________________\n\n\nfrom _btrfs_cffi import ffi, lib\n\nparser = argparse.ArgumentParser(usage=__doc__.strip())\nparser.add_argument('source', help='source subvolume')\nparser.add_argument('target', help='target directory')\nparser.add_argument('newname', help='name of the new snapshot')\nopts = parser.parse_args()\n\nsource = os.open(opts.source, os.O_DIRECTORY)\ntarget = os.open(opts.target, os.O_DIRECTORY)\n\n\nargs = ffi.new('struct btrfs_ioctl_vol_args_v2 *')\nargs.name = opts.newname\nargs.fd = source\nargs_buffer = ffi.buffer(args)\ntry:\n    fcntl.ioctl(target, lib.BTRFS_IOC_SNAP_CREATE_V2, args_buffer)\nexcept IOError as e:\n    print e\n    sys.exit(1)\n\n", "demo/pyobj.py": "\nreferents = []     # list \"object descriptor -> python object\"\nfreelist = None\n\ndef store(x):\n    \"Store the object 'x' and returns a new object descriptor for it.\"\n    global freelist\n    p = freelist\n    if p is None:\n        p = len(referents)\n        referents.append(x)\n    else:\n        freelist = referents[p]\n        referents[p] = x\n    return p\n\ndef discard(p):\n    \"\"\"Discard (i.e. close) the object descriptor 'p'.\n    Return the original object that was attached to 'p'.\"\"\"\n    global freelist\n    x = referents[p]\n    referents[p] = freelist\n    freelist = p\n    return x\n\nclass Ref(object):\n    \"\"\"For use in 'with Ref(x) as ob': open an object descriptor\n    and returns it in 'ob', and close it automatically when the\n    'with' statement finishes.\"\"\"\n    def __init__(self, x):\n        self.x = x\n    def __enter__(self):\n        self.p = p = store(self.x)\n        return p\n    def __exit__(self, *args):\n        discard(self.p)\n\ndef count_pyobj_alive():\n    result = len(referents)\n    p = freelist\n    while p is not None:\n        assert result > 0\n        result -= 1\n        p = referents[p]\n    return result\n\n# ------------------------------------------------------------\n\nif __name__ == '__main__':\n    import api\n\n    ffi = api.PythonFFI()\n\n    ffi.cdef(\"\"\"\n        typedef int pyobj_t;\n        int sum_integers(pyobj_t p_list);\n        pyobj_t sum_objects(pyobj_t p_list, pyobj_t p_initial);\n    \"\"\")\n\n    @ffi.pyexport(\"int(pyobj_t)\")\n    def length(p_list):\n        list = referents[p_list]\n        return len(list)\n\n    @ffi.pyexport(\"int(pyobj_t, int)\")\n    def getitem(p_list, index):\n        list = referents[p_list]\n        return list[index]\n\n    @ffi.pyexport(\"pyobj_t(pyobj_t)\")\n    def pyobj_dup(p):\n        return store(referents[p])\n\n    @ffi.pyexport(\"void(pyobj_t)\")\n    def pyobj_close(p):\n        discard(p)\n\n    @ffi.pyexport(\"pyobj_t(pyobj_t, int)\")\n    def pyobj_getitem(p_list, index):\n        list = referents[p_list]\n        return store(list[index])\n\n    @ffi.pyexport(\"pyobj_t(pyobj_t, pyobj_t)\")\n    def pyobj_add(p1, p2):\n        return store(referents[p1] + referents[p2])\n\n    lib = ffi.verify(\"\"\"\n        typedef int pyobj_t;    /* an \"object descriptor\" number */\n\n        int sum_integers(pyobj_t p_list) {\n            /* this a demo function written in C, using the API\n               defined above: length() and getitem(). */\n            int i, result = 0;\n            int count = length(p_list);\n            for (i=0; i<count; i++) {\n                int n = getitem(p_list, i);\n                result += n;\n            }\n            return result;\n        }\n\n        pyobj_t sum_objects(pyobj_t p_list, pyobj_t p_initial) {\n            /* same as above, but keeps all additions as Python objects */\n            int i;\n            int count = length(p_list);\n            pyobj_t p1 = pyobj_dup(p_initial);\n            for (i=0; i<count; i++) {\n                pyobj_t p2 = pyobj_getitem(p_list, i);\n                pyobj_t p3 = pyobj_add(p1, p2);\n                pyobj_close(p2);\n                pyobj_close(p1);\n                p1 = p3;\n            }\n            return p1;\n        }\n    \"\"\")\n\n    with Ref([10, 20, 30, 40]) as p_list:\n        print lib.sum_integers(p_list)\n        with Ref(5) as p_initial:\n            result = discard(lib.sum_objects(p_list, p_initial))\n            print result\n\n    assert count_pyobj_alive() == 0\n", "demo/setup_manual.py": "from distutils.core import setup\nfrom distutils.extension import Extension\nsetup(name='manual',\n      ext_modules=[Extension(name='manual',\n                             sources=['manual.c'])])\n", "demo/pwuid_build.py": "from cffi import FFI\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...; \n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\n\nffi.set_source('_pwuid_cffi', \"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\")\n\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/xclient.py": "import sys, os\n\n# run xclient_build first, then make sure the shared object is on sys.path\nfrom _xclient_cffi import ffi, lib\n\n\n# ffi \"knows\" about the declared variables and functions from the\n#     cdef parts of the module xclient_build created,\n# lib \"knows\" how to call the functions from the set_source parts\n#     of the module.\n\n\nclass XError(Exception):\n    pass\n\ndef main():\n    display = lib.XOpenDisplay(ffi.NULL)\n    if display == ffi.NULL:\n        raise XError(\"cannot open display\")\n    w = lib.XCreateSimpleWindow(display, lib.DefaultRootWindow(display),\n                            10, 10, 500, 350, 0, 0, 0)\n    lib.XMapRaised(display, w)\n    event = ffi.new(\"XEvent *\")\n    lib.XNextEvent(display, event)\n\nif __name__ == '__main__':\n    main()\n", "demo/bsdopendirtype_build.py": "from cffi import FFI\n\nffibuilder = FFI()\nffibuilder.cdef(\"\"\"\n    typedef ... DIR;\n    struct dirent {\n        unsigned char d_type;   /* type of file */\n        char d_name[];          /* filename */\n        ...;\n    };\n    DIR *opendir(const char *name);\n    int closedir(DIR *dirp);\n    struct dirent *readdir(DIR *dirp);\n    static const int DT_BLK, DT_CHR, DT_DIR, DT_FIFO, DT_LNK, DT_REG, DT_SOCK;\n\"\"\")\n\nffibuilder.set_source(\"_bsdopendirtype\", \"\"\"\n    #include <sys/types.h>\n    #include <dirent.h>\n\"\"\")\n\nif __name__ == '__main__':\n    ffibuilder.compile(verbose=True)\n", "demo/pwuid.py": "import sys, os\n\n# run pwuid_build first, then make sure the shared object is on sys.path\nfrom _pwuid_cffi import ffi, lib\n\n\nprint ffi.string(lib.getpwuid(0).pw_name)\n", "demo/readdir2_build.py": "from cffi import FFI\n\nffi = FFI()\nffi.cdef(\"\"\"\n\n    typedef ... DIR;\n\n    struct dirent {\n        unsigned char  d_type;      /* type of file; not supported\n                                       by all file system types */\n        char           d_name[...]; /* filename */\n        ...;\n    };\n\n    int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);\n    int openat(int dirfd, const char *pathname, int flags);\n    DIR *fdopendir(int fd);\n    int closedir(DIR *dirp);\n\n    static const int DT_DIR;\n\n\"\"\")\nffi.set_source(\"_readdir2_cffi\", \"\"\"\n#ifndef _ATFILE_SOURCE\n#  define _ATFILE_SOURCE\n#endif\n#ifndef _BSD_SOURCE\n#  define _BSD_SOURCE\n#endif\n#include <fcntl.h>\n#include <sys/types.h>\n#include <dirent.h>\n\"\"\")\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/recopendirtype.py": "from _recopendirtype import ffi, lib\n\n\ndef _posix_error():\n    raise OSError(ffi.errno, os.strerror(ffi.errno))\n\n_dtype_to_smode = {\n    lib.DT_BLK:  0o060000,\n    lib.DT_CHR:  0o020000,\n    lib.DT_DIR:  0o040000,\n    lib.DT_FIFO: 0o010000,\n    lib.DT_LNK:  0o120000,\n    lib.DT_REG:  0o100000,\n    lib.DT_SOCK: 0o140000,\n}\n\ndef opendir(dir):\n    if len(dir) == 0:\n        dir = b'.'\n    dirname = dir\n    if not dirname.endswith(b'/'):\n        dirname += b'/'\n    dirp = lib.opendir(dir)\n    if dirp == ffi.NULL:\n        raise _posix_error()\n    dirent = ffi.new(\"struct dirent *\")\n    result = ffi.new(\"struct dirent **\")\n    try:\n        while True:\n            ffi.errno = 0\n            err = lib.readdir_r(dirp, dirent, result)\n            if err:       # really got an error\n                raise OSError(err, os.strerror(err))\n            if result[0] == ffi.NULL:\n                return    # \n            name = ffi.string(dirent.d_name)\n            if name == b'.' or name == b'..':\n                continue\n            name = dirname + name\n            try:\n                smode = _dtype_to_smode[dirent.d_type]\n            except KeyError:\n                smode = os.lstat(name).st_mode\n            yield name, smode\n    finally:\n        lib.closedir(dirp)\n\nif __name__ == '__main__':\n    for name, smode in opendir(b'/tmp'):\n        print(hex(smode), name)\n", "demo/cffi-cocoa.py": "# Based on http://cocoawithlove.com/2010/09/minimalist-cocoa-programming.html\n# by Juraj Sukop.  This demo was eventually expanded into a more complete\n# Cocoa library available at https://bitbucket.org/sukop/nspython .\n\nfrom cffi import FFI\n\nffi = FFI()\nffi.cdef('''\n    \n    typedef signed char BOOL;\n    \n    typedef long NSInteger;\n    typedef unsigned long NSUInteger;\n    typedef NSInteger NSApplicationActivationPolicy;\n    typedef NSUInteger NSBackingStoreType;\n    typedef NSUInteger NSStringEncoding;\n    \n    typedef double CGFloat;\n    struct CGPoint {\n        CGFloat x;\n        CGFloat y;\n    };\n    typedef struct CGPoint CGPoint;\n    struct CGSize {\n        CGFloat width;\n        CGFloat height;\n    };\n    typedef struct CGSize CGSize;\n    struct CGRect {\n        CGPoint origin;\n        CGSize size;\n    };\n    typedef struct CGRect CGRect;\n    \n    typedef CGPoint NSPoint;\n    typedef CGSize NSSize;\n    typedef CGRect NSRect;\n    \n    typedef struct objc_class *Class;\n    typedef struct objc_object {\n        Class isa;\n    } *id;\n    typedef struct objc_selector *SEL;\n\n    SEL sel_registerName(const char *str);\n    id objc_getClass(const char *name);\n    id objc_msgSend(id theReceiver, SEL theSelector, ...);\n    \n''')\n\nobjc = ffi.dlopen('objc')\nappkit = ffi.dlopen('AppKit')\n\nnil = ffi.NULL\nYES = ffi.cast('BOOL', 1)\nNO = ffi.cast('BOOL', 0)\n\nNSASCIIStringEncoding = ffi.cast('NSStringEncoding', 1)\nNSApplicationActivationPolicyRegular = ffi.cast('NSApplicationActivationPolicy', 0)\nNSTitledWindowMask = ffi.cast('NSUInteger', 1)\nNSBackingStoreBuffered = ffi.cast('NSBackingStoreType', 2)\n\nNSMakePoint = lambda x, y: ffi.new('NSPoint *', (x, y))[0]\nNSMakeRect = lambda x, y, w, h: ffi.new('NSRect *', ((x, y), (w, h)))[0]\n\nget, send, sel = objc.objc_getClass, objc.objc_msgSend, objc.sel_registerName\nat = lambda s: send(\n    get('NSString'),\n    sel('stringWithCString:encoding:'),\n    ffi.new('char[]', s), NSASCIIStringEncoding)\n\nsend(get('NSAutoreleasePool'), sel('new'))\napp = send(get('NSApplication'), sel('sharedApplication'))\nsend(app, sel('setActivationPolicy:'), NSApplicationActivationPolicyRegular)\n\nmenubar = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappMenuItem = send(send(get('NSMenuItem'), sel('new')), sel('autorelease'))\nsend(menubar, sel('addItem:'), appMenuItem)\nsend(app, sel('setMainMenu:'), menubar)\n\nappMenu = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappName = send(send(get('NSProcessInfo'), sel('processInfo')), sel('processName'))\nquitTitle = send(at('Quit '), sel('stringByAppendingString:'), appName)\nquitMenuItem = send(send(send(\n            get('NSMenuItem'), sel('alloc')),\n        sel('initWithTitle:action:keyEquivalent:'),\n        quitTitle, sel('terminate:'), at('q')),\n    sel('autorelease'))\nsend(appMenu, sel('addItem:'), quitMenuItem)\nsend(appMenuItem, sel('setSubmenu:'), appMenu)\n\nwindow = send(send(send(\n            get('NSWindow'), sel('alloc')),\n        sel('initWithContentRect:styleMask:backing:defer:'),\n        NSMakeRect(0, 0, 200, 200), NSTitledWindowMask, NSBackingStoreBuffered, NO),\n    sel('autorelease'))\nsend(window, sel('cascadeTopLeftFromPoint:'), NSMakePoint(20, 20))\nsend(window, sel('setTitle:'), appName)\nsend(window, sel('makeKeyAndOrderFront:'), nil)\n\nsend(app, sel('activateIgnoringOtherApps:'), YES)\nsend(app, sel('run'))\n", "demo/recopendirtype_build.py": "from cffi import FFI\nimport bsdopendirtype_build\n\nffi = FFI()\n\n# ========== This is a demo of ffi.include() ==========\nffi.include(bsdopendirtype_build.ffi)\n\nffi.cdef(\"\"\"\n    int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);\n\"\"\")\n\nffi.set_source(\"_recopendirtype\", \"\"\"\n    #include <sys/types.h>\n    #include <dirent.h>\n\"\"\")\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/readdir_build.py": "import sys\nfrom cffi import FFI\n\nif not sys.platform.startswith('linux'):\n    raise Exception(\"Linux-only demo\")\n\n\nffi = FFI()\nffi.cdef(\"\"\"\n\n    typedef void DIR;\n    typedef long ino_t;\n    typedef long off_t;\n\n    struct dirent {\n        ino_t          d_ino;       /* inode number */\n        off_t          d_off;       /* offset to the next dirent */\n        unsigned short d_reclen;    /* length of this record */\n        unsigned char  d_type;      /* type of file; not supported\n                                       by all file system types */\n        char           d_name[256]; /* filename */\n    };\n\n    int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);\n    int openat(int dirfd, const char *pathname, int flags);\n    DIR *fdopendir(int fd);\n    int closedir(DIR *dirp);\n\n\"\"\")\nffi.set_source(\"_readdir\", None)\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/api.py": "import cffi\nfrom cffi import FFI\n\nclass PythonFFI(FFI):\n\n    def __init__(self, backend=None):\n        FFI.__init__(self, backend=backend)\n        self._pyexports = {}\n\n    def pyexport(self, signature):\n        tp = self._typeof(signature, consider_function_as_funcptr=True)\n        def decorator(func):\n            name = func.__name__\n            if name in self._pyexports:\n                raise cffi.CDefError(\"duplicate pyexport'ed function %r\"\n                                     % (name,))\n            callback_var = self.getctype(tp, name)\n            self.cdef(\"%s;\" % callback_var)\n            self._pyexports[name] = _PyExport(tp, func)\n        return decorator\n\n    def verify(self, source='', **kwargs):\n        extras = []\n        pyexports = sorted(self._pyexports.items())\n        for name, export in pyexports:\n            callback_var = self.getctype(export.tp, name)\n            extras.append(\"%s;\" % callback_var)\n        extras.append(source)\n        source = '\\n'.join(extras)\n        lib = FFI.verify(self, source, **kwargs)\n        for name, export in pyexports:\n            cb = self.callback(export.tp, export.func)\n            export.cb = cb\n            setattr(lib, name, cb)\n        return lib\n\n\nclass _PyExport(object):\n    def __init__(self, tp, func):\n        self.tp = tp\n        self.func = func\n\n\nif __name__ == '__main__':\n    ffi = PythonFFI()\n\n    @ffi.pyexport(\"int(int)\")\n    def add1(n):\n        print n\n        return n + 1\n\n    ffi.cdef(\"\"\"\n        int f(int);\n    \"\"\")\n\n    lib = ffi.verify(\"\"\"\n        int f(int x) {\n            return add1(add1(x));\n        }\n    \"\"\")\n\n    assert lib.f(5) == 7\n", "demo/bsdopendirtype.py": "from _bsdopendirtype import ffi, lib\n\n\ndef _posix_error():\n    raise OSError(ffi.errno, os.strerror(ffi.errno))\n\n_dtype_to_smode = {\n    lib.DT_BLK:  0o060000,\n    lib.DT_CHR:  0o020000,\n    lib.DT_DIR:  0o040000,\n    lib.DT_FIFO: 0o010000,\n    lib.DT_LNK:  0o120000,\n    lib.DT_REG:  0o100000,\n    lib.DT_SOCK: 0o140000,\n}\n\ndef opendir(dir):\n    if len(dir) == 0:\n        dir = b'.'\n    dirname = dir\n    if not dirname.endswith(b'/'):\n        dirname += b'/'\n    dirp = lib.opendir(dir)\n    if dirp == ffi.NULL:\n        raise _posix_error()\n    try:\n        while True:\n            ffi.errno = 0\n            dirent = lib.readdir(dirp)\n            if dirent == ffi.NULL:\n                if ffi.errno != 0:\n                    raise _posix_error()\n                return\n            name = ffi.string(dirent.d_name)\n            if name == b'.' or name == b'..':\n                continue\n            name = dirname + name\n            try:\n                smode = _dtype_to_smode[dirent.d_type]\n            except KeyError:\n                smode = os.lstat(name).st_mode\n            yield name, smode\n    finally:\n        lib.closedir(dirp)\n\nif __name__ == '__main__':\n    for name, smode in opendir(b'/tmp'):\n        print(hex(smode), name)\n", "demo/winclipboard.py": "__author__ = \"Israel Fruchter <israel.fruchter@gmail.com>\"\n\nimport sys, os\n\nif not sys.platform == 'win32':\n    raise Exception(\"Windows-only demo\")\n\ntry:\n    from _winclipboard_cffi import ffi, lib\nexcept ImportError:\n    print 'run winclipboard_build first, then make sure the shared object is on sys.path'\n    sys.exit(1)\n\n# ffi \"knows\" about the declared variables and functions from the\n#     cdef parts of the module _winclipboard_cffi created,\n# lib \"knows\" how to call the functions from the set_source parts\n#     of the module.\n\ndef CopyToClipboard(string):\n    '''\n        use win32 api to copy `string` to the clipboard\n    '''\n    hWnd = lib.GetConsoleWindow()\n  \n    if lib.OpenClipboard(hWnd):\n        cstring = ffi.new(\"char[]\", string)\n        size = ffi.sizeof(cstring)\n        \n        # make it a moveable memory for other processes\n        hGlobal = lib.GlobalAlloc(lib.GMEM_MOVEABLE, size)\n        buffer = lib.GlobalLock(hGlobal)\n        lib.memcpy(buffer, cstring, size)\n        lib.GlobalUnlock(hGlobal)\n        \n        res = lib.EmptyClipboard()\n        res = lib.SetClipboardData(lib.CF_TEXT, buffer)\n \n        lib.CloseClipboard()\n        \nCopyToClipboard(\"hello world from cffi\")\n", "demo/readdir2.py": "# A Linux-only demo, using set_source() instead of hard-coding the exact layouts\n#\nimport sys\n\nif not sys.platform.startswith('linux'):\n    raise Exception(\"Linux-only demo\")\n\n# run readdir2_build first, then make sure the shared object is on sys.path\nfrom _readdir2_cffi import ffi, lib\n\n\ndef walk(basefd, path):\n    print '{', path\n    dirfd = lib.openat(basefd, path, 0)\n    if dirfd < 0:\n        # error in openat()\n        return\n    dir = lib.fdopendir(dirfd)\n    dirent = ffi.new(\"struct dirent *\")\n    result = ffi.new(\"struct dirent **\")\n    while True:\n        if lib.readdir_r(dir, dirent, result):\n            # error in readdir_r()\n            break\n        if result[0] == ffi.NULL:\n            break\n        name = ffi.string(dirent.d_name)\n        print '%3d %s' % (dirent.d_type, name)\n        if dirent.d_type == lib.DT_DIR and name != '.' and name != '..':\n            walk(dirfd, name)\n    lib.closedir(dir)\n    print '}'\n\n\nwalk(-1, \"/tmp\")\n", "demo/_curses_setup.py": "from setuptools import setup\n\nsetup(\n    name=\"_curses\",\n    version=\"0.1\",\n    py_modules=[\"_curses\"],\n    setup_requires=[\"cffi>=1.0.dev0\"],\n    cffi_modules=[\n        \"_curses_build.py:ffi\",\n    ],\n    install_requires=[\"cffi>=1.0.dev0\"],   # should maybe be \"cffi-backend\" only?\n    zip_safe=False,\n)\n", "demo/xclient_build.py": "from cffi import FFI\nffi = FFI()\nffi.cdef(\"\"\"\n\ntypedef ... Display;\ntypedef struct { ...; } Window;\n\ntypedef struct { int type; ...; } XEvent;\n\nDisplay *XOpenDisplay(char *display_name);\nWindow DefaultRootWindow(Display *display);\nint XMapRaised(Display *display, Window w);\nWindow XCreateSimpleWindow(Display *display, Window parent, int x, int y,\n                           unsigned int width, unsigned int height,\n                           unsigned int border_width, unsigned long border,\n                           unsigned long background);\nint XNextEvent(Display *display, XEvent *event_return);\n\"\"\")\n\nffi.set_source('_xclient_cffi', \"\"\"\n            #include <X11/Xlib.h>\n\"\"\", libraries=['X11'])\n\nif __name__ == '__main__':\n    ffi.compile(verbose=True)\n", "demo/gmp_build.py": "import cffi\n\n#\n# This is only a demo based on the GMP library.\n# There is a rather more complete (but perhaps outdated) version available at:\n# http://bazaar.launchpad.net/~tolot-solar-empire/+junk/gmpy_cffi/files\n#\n\nffibuilder = cffi.FFI()\n\nffibuilder.cdef(\"\"\"\n\n    typedef struct { ...; } MP_INT;\n    typedef MP_INT mpz_t[1];\n\n    int mpz_init_set_str (MP_INT *dest_integer, char *src_cstring, int base);\n    void mpz_add (MP_INT *sum, MP_INT *addend1, MP_INT *addend2);\n    char * mpz_get_str (char *string, int base, MP_INT *integer);\n\n\"\"\")\n\nffibuilder.set_source('_gmp_cffi', \"#include <gmp.h>\",\n                 libraries=['gmp', 'm'])\n\nif __name__ == '__main__':\n    ffibuilder.compile(verbose=True)\n", "demo/bsdopendirtype_setup.py": "from setuptools import setup\n\nsetup(\n    name=\"example\",\n    version=\"0.1\",\n    py_modules=[\"bsdopendirtype\"],\n    setup_requires=[\"cffi>=1.0.dev0\"],\n    cffi_modules=[\n        \"bsdopendirtype_build.py:ffibuilder\",\n    ],\n    install_requires=[\"cffi>=1.0.dev0\"],   # should maybe be \"cffi-backend\" only?\n    zip_safe=False,\n)\n", "demo/extern_python.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.cdef(\"\"\"int my_algo(int); extern \"Python\" int f(int);\"\"\")\n\nffi.set_source(\"_extern_python_cffi\", \"\"\"\n    static int f(int);\n    static int my_algo(int n) {\n        int i, sum = 0;\n        for (i = 0; i < n; i++)\n            sum += f(i);\n        return sum;\n    }\n\"\"\")\n\nffi.compile()\n\n\nfrom _extern_python_cffi import ffi, lib\n\n@ffi.def_extern()\ndef f(n):\n    return n * n\n\nassert lib.my_algo(10) == 0+1+4+9+16+25+36+49+64+81\n", "demo/manual2.py": "import _cffi_backend\n\nffi = _cffi_backend.FFI(b\"manual2\",\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x01\\x0D\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F\\x00\\x00\\x00\\x09\\x00\\x00\\x00\\x0B\\x00\\x00\\x01\\x03',\n    _globals = (b'\\xff\\xff\\xff\\x0bAA',0,b'\\xff\\xff\\xff\\x0bBB',-1,b'\\xff\\xff\\xff\\x0bCC',2,b'\\xff\\xff\\xff\\x1fFOO',0x9999999999999999,b'\\x00\\x00\\x00#close',0,b'\\x00\\x00\\x05#stdout',0),\n    _struct_unions = ((b'\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x00point_s',b'\\x00\\x00\\x01\\x11\\xff\\xff\\xff\\xffx',b'\\x00\\x00\\x01\\x11\\xff\\xff\\xff\\xffy'),),\n    _enums = (b'\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x07myenum_e\\x00AA,BB,CC',),\n    _typenames = (b'\\x00\\x00\\x00\\x01myint_t',),\n)\n\n\n\n# trying it out\nlib = ffi.dlopen(None)\nassert lib.AA == 0\nassert lib.BB == -1\nassert lib.FOO == 0x9999999999999999\nx = lib.close(-42)\nassert x == -1\n\nprint lib.stdout\n\nprint ffi.new(\"struct point_s *\")\nprint ffi.offsetof(\"struct point_s\", \"x\")\nprint ffi.offsetof(\"struct point_s\", \"y\")\nprint ffi.new(\"struct point_s[CC]\")\nassert ffi.sizeof(\"struct point_s[CC]\") == 2 * ffi.sizeof(\"struct point_s\")\n\nprint ffi.cast(\"enum myenum_e\", 2)\nprint ffi.cast(\"myint_t\", -2)\nassert ffi.typeof(\"myint_t\") == ffi.typeof(\"int\")\n\ndel ffi, lib\n", "demo/winclipboard_build.py": "from cffi import FFI\n\nffi = FFI()\nffi.cdef('''\n    typedef void * HANDLE;\n    typedef HANDLE HWND;\n    typedef int BOOL;\n    typedef unsigned int UINT;\n    typedef int SIZE_T;\n    typedef char * LPTSTR;\n    typedef HANDLE HGLOBAL;\n    typedef HANDLE LPVOID;\n\n    HWND GetConsoleWindow(void);\n\n    LPVOID GlobalLock( HGLOBAL hMem );\n    BOOL GlobalUnlock( HGLOBAL hMem );\n    HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes);\n\n    BOOL  OpenClipboard(HWND hWndNewOwner);\n    BOOL  CloseClipboard(void);\n    BOOL  EmptyClipboard(void);\n    HANDLE  SetClipboardData(UINT uFormat, HANDLE hMem);\n\n    #define CF_TEXT ...\n    #define GMEM_MOVEABLE ...\n\n    void * memcpy(void * s1, void * s2, int n);\n    ''')\n\nffi.set_source('_winclipboard_cffi', '''\n    #include <windows.h>\n''', libraries=[\"user32\"])\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/gmp.py": "import sys\n#\n# This is only a demo based on the GMP library.\n# There is a rather more complete (but perhaps outdated) version available at:\n# http://bazaar.launchpad.net/~tolot-solar-empire/+junk/gmpy_cffi/files\n#\n\ntry:\n    from _gmp_cffi import ffi, lib\nexcept ImportError:\n    print 'run gmp_build first, then make sure the shared object is on sys.path'\n    sys.exit(1)\n\n# ffi \"knows\" about the declared variables and functions from the\n#     cdef parts of the module created from gmp_build\n# lib \"knows\" how to call the functions from the set_source parts\n#     of the module.\n\n# ____________________________________________________________\n\na = ffi.new(\"mpz_t\")\nb = ffi.new(\"mpz_t\")\n\nif len(sys.argv) < 3:\n    print 'call as %s bigint1, bigint2' % sys.argv[0]\n    sys.exit(2)\n\nlib.mpz_init_set_str(a, sys.argv[1], 10)\t# Assume decimal integers\nlib.mpz_init_set_str(b, sys.argv[2], 10)\t# Assume decimal integers\nlib.mpz_add(a, a, b)\t\t\t# a=a+b\n\ns = lib.mpz_get_str(ffi.NULL, 10, a)\nprint ffi.string(s)\n", "demo/embedding.py": "import cffi\n\nffibuilder = cffi.FFI()\n\nffibuilder.embedding_api(\"\"\"\n    int add(int, int);\n\"\"\")\n\nffibuilder.embedding_init_code(\"\"\"\n    from _embedding_cffi import ffi\n    print(\"preparing\")   # printed once\n\n    @ffi.def_extern()\n    def add(x, y):\n        print(\"adding %d and %d\" % (x, y))\n        return x + y\n\"\"\")\n\nffibuilder.set_source(\"_embedding_cffi\", \"\")\n\nffibuilder.compile(verbose=True)\n", "demo/extern_python_varargs.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.cdef(\"\"\"\n    int my_algo(int);\n    typedef ... va_list;\n    extern \"Python\" int f(int, va_list *);\n\n    int fetch_int(va_list *);\n    double fetch_double(va_list *);\n    void *fetch_ptr(va_list *);\n\"\"\")\n\nffi.set_source(\"_extern_python_cffi\", \"\"\"\n    #include <stdarg.h>\n\n    static int f(int, va_list *);\n\n    static int f1(int n, ...)\n    {\n        va_list ap;\n        va_start(ap, n);\n        int res = f(n, &ap);\n        va_end(ap);\n        return res;\n    }\n\n    static int fetch_int(va_list *va) { return va_arg((*va), int); }\n    static double fetch_double(va_list *va) { return va_arg((*va), double); }\n    static void * fetch_ptr(va_list *va) { return va_arg((*va), void *); }\n    \n    static int my_algo(int n) {\n        return f1(3, n, n+1, n+2) + f1(1, &n) + f1(2, 12.3, 45.6);\n    }\n\"\"\")\n\nffi.compile()\n\n\nfrom _extern_python_cffi import ffi, lib\n\n@ffi.def_extern()\ndef f(n, va):\n    if n == 3:\n        x = lib.fetch_int(va)\n        y = lib.fetch_int(va)\n        z = lib.fetch_int(va)\n        print (x, y, z)\n    elif n == 1:\n        ptr = lib.fetch_ptr(va)\n        print 'ptr to:', ffi.cast(\"int *\", ptr)[0]\n    elif n == 2:\n        x = lib.fetch_double(va)\n        y = lib.fetch_double(va)\n        print (x, y)\n    else:\n        raise AssertionError(n)\n    return 14\n\nprint lib.my_algo(10)\n", "demo/readdir2_setup.py": "from distutils.core import setup\nimport readdir2_build\n\nsetup(\n    name=\"readdir2\",\n    version=\"0.1\",\n    py_modules=[\"readdir2\"],\n    ext_modules=[readdir2_build.ffi.distutils_extension('build')],\n)\n", "demo/_curses.py": "\"\"\"Reimplementation of the standard extension module '_curses' using cffi.\"\"\"\n\nimport sys\nfrom functools import wraps\n\nfrom _curses_cffi import ffi, lib\n\n\ndef _copy_to_globals(name):\n    globals()[name] = getattr(lib, name)\n\n\ndef _setup():\n    for name in ['ERR', 'OK', 'KEY_MIN', 'KEY_MAX',\n                 'A_ATTRIBUTES', 'A_NORMAL', 'A_STANDOUT', 'A_UNDERLINE',\n                 'A_REVERSE', 'A_BLINK', 'A_DIM', 'A_BOLD', 'A_ALTCHARSET',\n                 'A_PROTECT', 'A_CHARTEXT', 'A_COLOR',\n                 'COLOR_BLACK', 'COLOR_RED', 'COLOR_GREEN', 'COLOR_YELLOW',\n                 'COLOR_BLUE', 'COLOR_MAGENTA', 'COLOR_CYAN', 'COLOR_WHITE',\n                 ]:\n        _copy_to_globals(name)\n\n    if not lib._m_NetBSD:\n        _copy_to_globals('A_INVIS')\n\n    for name in ['A_HORIZONTAL', 'A_LEFT', 'A_LOW', 'A_RIGHT', 'A_TOP',\n                 'A_VERTICAL',\n                 ]:\n        if hasattr(lib, name):\n            _copy_to_globals(name)\n\n    if lib._m_NCURSES_MOUSE_VERSION:\n        for name in [\"BUTTON1_PRESSED\", \"BUTTON1_RELEASED\", \"BUTTON1_CLICKED\",\n                     \"BUTTON1_DOUBLE_CLICKED\", \"BUTTON1_TRIPLE_CLICKED\",\n                     \"BUTTON2_PRESSED\", \"BUTTON2_RELEASED\", \"BUTTON2_CLICKED\",\n                     \"BUTTON2_DOUBLE_CLICKED\", \"BUTTON2_TRIPLE_CLICKED\",\n                     \"BUTTON3_PRESSED\", \"BUTTON3_RELEASED\", \"BUTTON3_CLICKED\",\n                     \"BUTTON3_DOUBLE_CLICKED\", \"BUTTON3_TRIPLE_CLICKED\",\n                     \"BUTTON4_PRESSED\", \"BUTTON4_RELEASED\", \"BUTTON4_CLICKED\",\n                     \"BUTTON4_DOUBLE_CLICKED\", \"BUTTON4_TRIPLE_CLICKED\",\n                     \"BUTTON_SHIFT\", \"BUTTON_CTRL\", \"BUTTON_ALT\",\n                     \"ALL_MOUSE_EVENTS\", \"REPORT_MOUSE_POSITION\",\n                     ]:\n            _copy_to_globals(name)\n\n    if not lib._m_NetBSD:\n        for key in range(lib.KEY_MIN, lib.KEY_MAX):\n            key_n = lib.keyname(key)\n            if key_n == ffi.NULL:\n                continue\n            key_n = ffi.string(key_n)\n            if key_n == b\"UNKNOWN KEY\":\n                continue\n            if not isinstance(key_n, str):   # python 3\n                key_n = key_n.decode()\n            key_n = key_n.replace('(', '').replace(')', '')\n            globals()[key_n] = key\n\n_setup()\n\n# Do we want this?\n# version = \"2.2\"\n# __version__ = \"2.2\"\n\n\n# ____________________________________________________________\n\n\n_initialised_setupterm = False\n_initialised = False\n_initialised_color = False\n\n\ndef _ensure_initialised_setupterm():\n    if not _initialised_setupterm:\n        raise error(\"must call (at least) setupterm() first\")\n\n\ndef _ensure_initialised():\n    if not _initialised:\n        raise error(\"must call initscr() first\")\n\n\ndef _ensure_initialised_color():\n    if not _initialised and _initialised_color:\n        raise error(\"must call start_color() first\")\n\n\ndef _check_ERR(code, fname):\n    if code != lib.ERR:\n        return None\n    elif fname is None:\n        raise error(\"curses function returned ERR\")\n    else:\n        raise error(\"%s() returned ERR\" % (fname,))\n\n\ndef _check_NULL(rval):\n    if rval == ffi.NULL:\n        raise error(\"curses function returned NULL\")\n    return rval\n\n\ndef _call_lib(method_name, *args):\n    return getattr(lib, method_name)(*args)\n\n\ndef _call_lib_check_ERR(method_name, *args):\n    return _check_ERR(_call_lib(method_name, *args), method_name)\n\n\ndef _mk_no_return(method_name):\n    def _execute():\n        _ensure_initialised()\n        return _call_lib_check_ERR(method_name)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_flag_func(method_name):\n    # This is in the CPython implementation, but not documented anywhere.\n    # We have to support it, though, even if it make me sad.\n    def _execute(flag=True):\n        _ensure_initialised()\n        if flag:\n            return _call_lib_check_ERR(method_name)\n        else:\n            return _call_lib_check_ERR('no' + method_name)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_return_val(method_name):\n    def _execute():\n        return _call_lib(method_name)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_w_getyx(method_name):\n    def _execute(self):\n        y = _call_lib(method_name + 'y', self._win)\n        x = _call_lib(method_name + 'x', self._win)\n        return (y, x)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_w_no_return(method_name):\n    def _execute(self, *args):\n        return _call_lib_check_ERR(method_name, self._win, *args)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_w_return_val(method_name):\n    def _execute(self, *args):\n        return _call_lib(method_name, self._win, *args)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _chtype(ch):\n    return int(ffi.cast(\"chtype\", ch))\n\ndef _texttype(text):\n    if isinstance(text, str):\n        return text\n    elif isinstance(text, unicode):\n        return str(text)   # default encoding\n    else:\n        raise TypeError(\"str or unicode expected, got a '%s' object\"\n                        % (type(text).__name__,))\n\n\ndef _extract_yx(args):\n    if len(args) >= 2:\n        return (args[0], args[1], args[2:])\n    return (None, None, args)\n\n\ndef _process_args(funcname, args, count, optcount, frontopt=0):\n    outargs = []\n    if frontopt:\n        if len(args) > count + optcount:\n            # We have the front optional args here.\n            outargs.extend(args[:frontopt])\n            args = args[frontopt:]\n        else:\n            # No front optional args, so make them None.\n            outargs.extend([None] * frontopt)\n    if (len(args) < count) or (len(args) > count + optcount):\n        raise error(\"%s requires %s to %s arguments\" % (\n                funcname, count, count + optcount + frontopt))\n    outargs.extend(args)\n    return outargs\n\n\ndef _argspec(count, optcount=0, frontopt=0):\n    def _argspec_deco(func):\n        @wraps(func)\n        def _wrapped(self, *args):\n            outargs = _process_args(\n                func.__name__, args, count, optcount, frontopt)\n            return func(self, *outargs)\n        return _wrapped\n    return _argspec_deco\n\n\n# ____________________________________________________________\n\n\nclass error(Exception):\n    pass\n\n\nclass Window(object):\n    def __init__(self, window):\n        self._win = window\n\n    def __del__(self):\n        if self._win != lib.stdscr:\n            lib.delwin(self._win)\n\n    untouchwin = _mk_w_no_return(\"untouchwin\")\n    touchwin = _mk_w_no_return(\"touchwin\")\n    redrawwin = _mk_w_no_return(\"redrawwin\")\n    insertln = _mk_w_no_return(\"winsertln\")\n    erase = _mk_w_no_return(\"werase\")\n    deleteln = _mk_w_no_return(\"wdeleteln\")\n\n    is_wintouched = _mk_w_return_val(\"is_wintouched\")\n\n    syncdown = _mk_w_return_val(\"wsyncdown\")\n    syncup = _mk_w_return_val(\"wsyncup\")\n    standend = _mk_w_return_val(\"wstandend\")\n    standout = _mk_w_return_val(\"wstandout\")\n    cursyncup = _mk_w_return_val(\"wcursyncup\")\n    clrtoeol = _mk_w_return_val(\"wclrtoeol\")\n    clrtobot = _mk_w_return_val(\"wclrtobot\")\n    clear = _mk_w_return_val(\"wclear\")\n\n    idcok = _mk_w_no_return(\"idcok\")\n    immedok = _mk_w_no_return(\"immedok\")\n    timeout = _mk_w_no_return(\"wtimeout\")\n\n    getyx = _mk_w_getyx(\"getcur\")\n    getbegyx = _mk_w_getyx(\"getbeg\")\n    getmaxyx = _mk_w_getyx(\"getmax\")\n    getparyx = _mk_w_getyx(\"getpar\")\n\n    clearok = _mk_w_no_return(\"clearok\")\n    idlok = _mk_w_no_return(\"idlok\")\n    leaveok = _mk_w_no_return(\"leaveok\")\n    notimeout = _mk_w_no_return(\"notimeout\")\n    scrollok = _mk_w_no_return(\"scrollok\")\n    insdelln = _mk_w_no_return(\"winsdelln\")\n    syncok = _mk_w_no_return(\"syncok\")\n\n    mvwin = _mk_w_no_return(\"mvwin\")\n    mvderwin = _mk_w_no_return(\"mvderwin\")\n    move = _mk_w_no_return(\"wmove\")\n\n    if not lib._m_STRICT_SYSV_CURSES:\n        resize = _mk_w_no_return(\"wresize\")\n\n    if lib._m_NetBSD:\n        keypad = _mk_w_return_val(\"keypad\")\n        nodelay = _mk_w_return_val(\"nodelay\")\n    else:\n        keypad = _mk_w_no_return(\"keypad\")\n        nodelay = _mk_w_no_return(\"nodelay\")\n\n    @_argspec(1, 1, 2)\n    def addch(self, y, x, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        ch = _chtype(ch)\n\n        if y is not None:\n            code = lib.mvwaddch(self._win, y, x, ch | attr)\n        else:\n            code = lib.waddch(self._win, ch | attr)\n        return _check_ERR(code, \"addch\")\n\n    @_argspec(1, 1, 2)\n    def addstr(self, y, x, text, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwaddstr(self._win, y, x, text)\n        else:\n            code = lib.waddstr(self._win, text)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"addstr\")\n\n    @_argspec(2, 1, 2)\n    def addnstr(self, y, x, text, n, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwaddnstr(self._win, y, x, text, n)\n        else:\n            code = lib.waddnstr(self._win, text, n)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"addnstr\")\n\n    def bkgd(self, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        return _check_ERR(lib.wbkgd(self._win, _chtype(ch) | attr), \"bkgd\")\n\n    attroff = _mk_w_no_return(\"wattroff\")\n    attron = _mk_w_no_return(\"wattron\")\n    attrset = _mk_w_no_return(\"wattrset\")\n\n    def bkgdset(self, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        lib.wbkgdset(self._win, _chtype(ch) | attr)\n        return None\n\n    def border(self, ls=0, rs=0, ts=0, bs=0, tl=0, tr=0, bl=0, br=0):\n        lib.wborder(self._win,\n                    _chtype(ls), _chtype(rs), _chtype(ts), _chtype(bs),\n                    _chtype(tl), _chtype(tr), _chtype(bl), _chtype(br))\n        return None\n\n    def box(self, vertint=0, horint=0):\n        lib.box(self._win, vertint, horint)\n        return None\n\n    @_argspec(1, 1, 2)\n    def chgat(self, y, x, num, attr=None):\n        # These optional args are in a weird order.\n        if attr is None:\n            attr = num\n            num = -1\n\n        color = ((attr >> 8) & 0xff)\n        attr = attr - (color << 8)\n\n        if y is not None:\n            code = lib.mvwchgat(self._win, y, x, num, attr, color, ffi.NULL)\n            lib.touchline(self._win, y, 1)\n        else:\n            yy, _ = self.getyx()\n            code = lib.wchgat(self._win, num, attr, color, ffi.NULL)\n            lib.touchline(self._win, yy, 1)\n        return _check_ERR(code, \"chgat\")\n\n    def delch(self, *args):\n        if len(args) == 0:\n            code = lib.wdelch(self._win)\n        elif len(args) == 2:\n            code = lib.mvwdelch(self._win, *args)\n        else:\n            raise error(\"delch requires 0 or 2 arguments\")\n        return _check_ERR(code, \"[mv]wdelch\")\n\n    def derwin(self, *args):\n        nlines = 0\n        ncols = 0\n        if len(args) == 2:\n            begin_y, begin_x = args\n        elif len(args) == 4:\n            nlines, ncols, begin_y, begin_x = args\n        else:\n            raise error(\"derwin requires 2 or 4 arguments\")\n\n        win = lib.derwin(self._win, nlines, ncols, begin_y, begin_x)\n        return Window(_check_NULL(win))\n\n    def echochar(self, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        ch = _chtype(ch)\n\n        if lib._m_ispad(self._win):\n            code = lib.pechochar(self._win, ch | attr)\n        else:\n            code = lib.wechochar(self._win, ch | attr)\n        return _check_ERR(code, \"echochar\")\n\n    if lib._m_NCURSES_MOUSE_VERSION:\n        enclose = _mk_w_return_val(\"wenclose\")\n\n    getbkgd = _mk_w_return_val(\"getbkgd\")\n\n    def getch(self, *args):\n        if len(args) == 0:\n            val = lib.wgetch(self._win)\n        elif len(args) == 2:\n            val = lib.mvwgetch(self._win, *args)\n        else:\n            raise error(\"getch requires 0 or 2 arguments\")\n        return val\n\n    def getkey(self, *args):\n        if len(args) == 0:\n            val = lib.wgetch(self._win)\n        elif len(args) == 2:\n            val = lib.mvwgetch(self._win, *args)\n        else:\n            raise error(\"getkey requires 0 or 2 arguments\")\n\n        if val == lib.ERR:\n            raise error(\"no input\")\n        elif val <= 255:\n            return chr(val)\n        else:\n            # XXX: The following line is different if `__NetBSD__` is defined.\n            val = lib.keyname(val)\n            if val == ffi.NULL:\n                return \"\"\n            return ffi.string(val)\n\n    @_argspec(0, 1, 2)\n    def getstr(self, y, x, n=1023):\n        n = min(n, 1023)\n        buf = ffi.new(\"char[1024]\")  # /* This should be big enough.. I hope */\n\n        if y is None:\n            val = lib.wgetnstr(self._win, buf, n)\n        else:\n            val = lib.mvwgetnstr(self._win, y, x, buf, n)\n\n        if val == lib.ERR:\n            return \"\"\n        return ffi.string(buf)\n\n    @_argspec(2, 1, 2)\n    def hline(self, y, x, ch, n, attr=None):\n        ch = _chtype(ch)\n        if attr is None:\n            attr = lib.A_NORMAL\n        if y is not None:\n            _check_ERR(lib.wmove(self._win, y, x), \"wmove\")\n        return _check_ERR(lib.whline(self._win, ch | attr, n), \"hline\")\n\n    @_argspec(1, 1, 2)\n    def insch(self, y, x, ch, attr=None):\n        ch = _chtype(ch)\n        if attr is None:\n            attr = lib.A_NORMAL\n        if y is not None:\n            code = lib.mvwinsch(self._win, y, x, ch | attr)\n        else:\n            code = lib.winsch(self._win, ch | attr)\n        return _check_ERR(code, \"insch\")\n\n    def inch(self, *args):\n        if len(args) == 0:\n            return lib.winch(self._win)\n        elif len(args) == 2:\n            return lib.mvwinch(self._win, *args)\n        else:\n            raise error(\"inch requires 0 or 2 arguments\")\n\n    @_argspec(0, 1, 2)\n    def instr(self, y, x, n=1023):\n        n = min(n, 1023)\n        buf = ffi.new(\"char[1024]\")  # /* This should be big enough.. I hope */\n        if y is None:\n            code = lib.winnstr(self._win, buf, n)\n        else:\n            code = lib.mvwinnstr(self._win, y, x, buf, n)\n\n        if code == lib.ERR:\n            return \"\"\n        return ffi.string(buf)\n\n    @_argspec(1, 1, 2)\n    def insstr(self, y, x, text, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwinsstr(self._win, y, x, text)\n        else:\n            code = lib.winsstr(self._win, text)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"insstr\")\n\n    @_argspec(2, 1, 2)\n    def insnstr(self, y, x, text, n, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwinsnstr(self._win, y, x, text, n)\n        else:\n            code = lib.winsnstr(self._win, text, n)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"insnstr\")\n\n    def is_linetouched(self, line):\n        code = lib.is_linetouched(self._win, line)\n        if code == lib.ERR:\n            raise error(\"is_linetouched: line number outside of boundaries\")\n        if code == lib.FALSE:\n            return False\n        return True\n\n    def noutrefresh(self, *args):\n        if lib._m_ispad(self._win):\n            if len(args) != 6:\n                raise error(\n                    \"noutrefresh() called for a pad requires 6 arguments\")\n            return _check_ERR(lib.pnoutrefresh(self._win, *args),\n                              \"pnoutrefresh\")\n        else:\n            # XXX: Better args check here? We need zero args.\n            return _check_ERR(lib.wnoutrefresh(self._win, *args),\n                              \"wnoutrefresh\")\n\n    nooutrefresh = noutrefresh  # \"to be removed in 2.3\", but in 2.7, 3.x.\n\n    def _copywin(self, dstwin, overlay,\n                 sminr, sminc, dminr, dminc, dmaxr, dmaxc):\n        return _check_ERR(lib.copywin(self._win, dstwin._win,\n                                      sminr, sminc, dminr, dminc, dmaxr, dmaxc,\n                                      overlay), \"copywin\")\n\n    def overlay(self, dstwin, *args):\n        if len(args) == 6:\n            return self._copywin(dstwin, True, *args)\n        elif len(args) == 0:\n            return _check_ERR(lib.overlay(self._win, dstwin._win), \"overlay\")\n        else:\n            raise error(\"overlay requires one or seven arguments\")\n\n    def overwrite(self, dstwin, *args):\n        if len(args) == 6:\n            return self._copywin(dstwin, False, *args)\n        elif len(args) == 0:\n            return _check_ERR(lib.overwrite(self._win, dstwin._win),\n                              \"overwrite\")\n        else:\n            raise error(\"overwrite requires one or seven arguments\")\n\n    def putwin(self, filep):\n        # filestar = ffi.new(\"FILE *\", filep)\n        return _check_ERR(lib.putwin(self._win, filep), \"putwin\")\n\n    def redrawln(self, beg, num):\n        return _check_ERR(lib.wredrawln(self._win, beg, num), \"redrawln\")\n\n    def refresh(self, *args):\n        if lib._m_ispad(self._win):\n            if len(args) != 6:\n                raise error(\n                    \"noutrefresh() called for a pad requires 6 arguments\")\n            return _check_ERR(lib.prefresh(self._win, *args), \"prefresh\")\n        else:\n            # XXX: Better args check here? We need zero args.\n            return _check_ERR(lib.wrefresh(self._win, *args), \"wrefresh\")\n\n    def setscrreg(self, y, x):\n        return _check_ERR(lib.wsetscrreg(self._win, y, x), \"wsetscrreg\")\n\n    def subwin(self, *args):\n        nlines = 0\n        ncols = 0\n        if len(args) == 2:\n            begin_y, begin_x = args\n        elif len(args) == 4:\n            nlines, ncols, begin_y, begin_x = args\n        else:\n            raise error(\"subwin requires 2 or 4 arguments\")\n\n        if lib._m_ispad(self._win):\n            win = lib.subpad(self._win, nlines, ncols, begin_y, begin_x)\n        else:\n            win = lib.subwin(self._win, nlines, ncols, begin_y, begin_x)\n        return Window(_check_NULL(win))\n\n    def scroll(self, nlines=None):\n        if nlines is None:\n            return _check_ERR(lib.scroll(self._win), \"scroll\")\n        else:\n            return _check_ERR(lib.wscrl(self._win, nlines), \"scroll\")\n\n    def touchline(self, st, cnt, val=None):\n        if val is None:\n            return _check_ERR(lib.touchline(self._win, st, cnt), \"touchline\")\n        else:\n            return _check_ERR(lib.wtouchln(self._win, st, cnt, val),\n                              \"touchline\")\n\n    @_argspec(2, 1, 2)\n    def vline(self, y, x, ch, n, attr=None):\n        ch = _chtype(ch)\n        if attr is None:\n            attr = lib.A_NORMAL\n        if y is not None:\n            _check_ERR(lib.wmove(self._win, y, x), \"wmove\")\n        return _check_ERR(lib.wvline(self._win, ch | attr, n), \"vline\")\n\n\nbeep = _mk_no_return(\"beep\")\ndef_prog_mode = _mk_no_return(\"def_prog_mode\")\ndef_shell_mode = _mk_no_return(\"def_shell_mode\")\ndoupdate = _mk_no_return(\"doupdate\")\nendwin = _mk_no_return(\"endwin\")\nflash = _mk_no_return(\"flash\")\nnocbreak = _mk_no_return(\"nocbreak\")\nnoecho = _mk_no_return(\"noecho\")\nnonl = _mk_no_return(\"nonl\")\nnoraw = _mk_no_return(\"noraw\")\nreset_prog_mode = _mk_no_return(\"reset_prog_mode\")\nreset_shell_mode = _mk_no_return(\"reset_shell_mode\")\nresetty = _mk_no_return(\"resetty\")\nsavetty = _mk_no_return(\"savetty\")\n\ncbreak = _mk_flag_func(\"cbreak\")\necho = _mk_flag_func(\"echo\")\nnl = _mk_flag_func(\"nl\")\nraw = _mk_flag_func(\"raw\")\n\nbaudrate = _mk_return_val(\"baudrate\")\ntermattrs = _mk_return_val(\"termattrs\")\n\ntermname = _mk_return_val(\"termname\")\nlongname = _mk_return_val(\"longname\")\n\ncan_change_color = _mk_return_val(\"can_change_color\")\nhas_colors = _mk_return_val(\"has_colors\")\nhas_ic = _mk_return_val(\"has_ic\")\nhas_il = _mk_return_val(\"has_il\")\nisendwin = _mk_return_val(\"isendwin\")\nflushinp = _mk_return_val(\"flushinp\")\nnoqiflush = _mk_return_val(\"noqiflush\")\n\n\ndef filter():\n    lib.filter()\n    return None\n\n\ndef color_content(color):\n    _ensure_initialised_color()\n    r, g, b = ffi.new(\"short *\"), ffi.new(\"short *\"), ffi.new(\"short *\")\n    if lib.color_content(color, r, g, b) == lib.ERR:\n        raise error(\"Argument 1 was out of range. Check value of COLORS.\")\n    return (r[0], g[0], b[0])\n\n\ndef color_pair(n):\n    _ensure_initialised_color()\n    return (n << 8)\n\n\ndef curs_set(vis):\n    _ensure_initialised()\n    val = lib.curs_set(vis)\n    _check_ERR(val, \"curs_set\")\n    return val\n\n\ndef delay_output(ms):\n    _ensure_initialised()\n    return _check_ERR(lib.delay_output(ms), \"delay_output\")\n\n\ndef erasechar():\n    _ensure_initialised()\n    return lib.erasechar()\n\n\ndef getsyx():\n    _ensure_initialised()\n    yx = ffi.new(\"int[2]\")\n    lib._m_getsyx(yx)\n    return (yx[0], yx[1])\n\n\nif lib._m_NCURSES_MOUSE_VERSION:\n\n    def getmouse():\n        _ensure_initialised()\n        mevent = ffi.new(\"MEVENT *\")\n        _check_ERR(lib.getmouse(mevent), \"getmouse\")\n        return (mevent.id, mevent.x, mevent.y, mevent.z, mevent.bstate)\n\n    def ungetmouse(id, x, y, z, bstate):\n        _ensure_initialised()\n        mevent = ffi.new(\"MEVENT *\")\n        mevent.id, mevent.x, mevent.y, mevent.z, mevent.bstate = (\n            id, x, y, z, bstate)\n        return _check_ERR(lib.ungetmouse(mevent), \"ungetmouse\")\n\n\ndef getwin(filep):\n    return Window(_check_NULL(lib.getwin(filep)))\n\n\ndef halfdelay(tenths):\n    _ensure_initialised()\n    return _check_ERR(lib.halfdelay(tenths), \"halfdelay\")\n\n\nif not lib._m_STRICT_SYSV_CURSES:\n    def has_key(ch):\n        _ensure_initialised()\n        return lib.has_key(ch)\n\n\ndef init_color(color, r, g, b):\n    _ensure_initialised_color()\n    return _check_ERR(lib.init_color(color, r, g, b), \"init_color\")\n\n\ndef init_pair(pair, f, b):\n    _ensure_initialised_color()\n    return _check_ERR(lib.init_pair(pair, f, b), \"init_pair\")\n\n\ndef _mk_acs(name, ichar):\n    if len(ichar) == 1:\n        globals()[name] = lib.acs_map[ord(ichar)]\n    else:\n        globals()[name] = globals()[ichar]\n\n\ndef _map_acs():\n    _mk_acs(\"ACS_ULCORNER\", 'l')\n    _mk_acs(\"ACS_LLCORNER\", 'm')\n    _mk_acs(\"ACS_URCORNER\", 'k')\n    _mk_acs(\"ACS_LRCORNER\", 'j')\n    _mk_acs(\"ACS_LTEE\", 't')\n    _mk_acs(\"ACS_RTEE\", 'u')\n    _mk_acs(\"ACS_BTEE\", 'v')\n    _mk_acs(\"ACS_TTEE\", 'w')\n    _mk_acs(\"ACS_HLINE\", 'q')\n    _mk_acs(\"ACS_VLINE\", 'x')\n    _mk_acs(\"ACS_PLUS\", 'n')\n    _mk_acs(\"ACS_S1\", 'o')\n    _mk_acs(\"ACS_S9\", 's')\n    _mk_acs(\"ACS_DIAMOND\", '`')\n    _mk_acs(\"ACS_CKBOARD\", 'a')\n    _mk_acs(\"ACS_DEGREE\", 'f')\n    _mk_acs(\"ACS_PLMINUS\", 'g')\n    _mk_acs(\"ACS_BULLET\", '~')\n    _mk_acs(\"ACS_LARROW\", ',')\n    _mk_acs(\"ACS_RARROW\", '+')\n    _mk_acs(\"ACS_DARROW\", '.')\n    _mk_acs(\"ACS_UARROW\", '-')\n    _mk_acs(\"ACS_BOARD\", 'h')\n    _mk_acs(\"ACS_LANTERN\", 'i')\n    _mk_acs(\"ACS_BLOCK\", '0')\n    _mk_acs(\"ACS_S3\", 'p')\n    _mk_acs(\"ACS_S7\", 'r')\n    _mk_acs(\"ACS_LEQUAL\", 'y')\n    _mk_acs(\"ACS_GEQUAL\", 'z')\n    _mk_acs(\"ACS_PI\", '{')\n    _mk_acs(\"ACS_NEQUAL\", '|')\n    _mk_acs(\"ACS_STERLING\", '}')\n    _mk_acs(\"ACS_BSSB\", \"ACS_ULCORNER\")\n    _mk_acs(\"ACS_SSBB\", \"ACS_LLCORNER\")\n    _mk_acs(\"ACS_BBSS\", \"ACS_URCORNER\")\n    _mk_acs(\"ACS_SBBS\", \"ACS_LRCORNER\")\n    _mk_acs(\"ACS_SBSS\", \"ACS_RTEE\")\n    _mk_acs(\"ACS_SSSB\", \"ACS_LTEE\")\n    _mk_acs(\"ACS_SSBS\", \"ACS_BTEE\")\n    _mk_acs(\"ACS_BSSS\", \"ACS_TTEE\")\n    _mk_acs(\"ACS_BSBS\", \"ACS_HLINE\")\n    _mk_acs(\"ACS_SBSB\", \"ACS_VLINE\")\n    _mk_acs(\"ACS_SSSS\", \"ACS_PLUS\")\n\n\ndef initscr():\n    if _initialised:\n        lib.wrefresh(lib.stdscr)\n        return Window(lib.stdscr)\n\n    win = _check_NULL(lib.initscr())\n    globals()['_initialised_setupterm'] = True\n    globals()['_initialised'] = True\n\n    _map_acs()\n\n    globals()[\"LINES\"] = lib.LINES\n    globals()[\"COLS\"] = lib.COLS\n\n    return Window(win)\n\n\ndef setupterm(term=None, fd=-1):\n    if fd == -1:\n        # XXX: Check for missing stdout here?\n        fd = sys.stdout.fileno()\n\n    if _initialised_setupterm:\n        return None\n\n    if term is None:\n        term = ffi.NULL\n    err = ffi.new(\"int *\")\n    if lib.setupterm(term, fd, err) == lib.ERR:\n        err = err[0]\n        if err == 0:\n            raise error(\"setupterm: could not find terminal\")\n        elif err == -1:\n            raise error(\"setupterm: could not find terminfo database\")\n        else:\n            raise error(\"setupterm: unknown error\")\n\n    globals()[\"_initialised_setupterm\"] = True\n    return None\n\n\ndef intrflush(ch):\n    _ensure_initialised()\n    return _check_ERR(lib.intrflush(ffi.NULL, ch), \"intrflush\")\n\n\n# XXX: #ifdef HAVE_CURSES_IS_TERM_RESIZED\ndef is_term_resized(lines, columns):\n    _ensure_initialised()\n    return lib.is_term_resized(lines, columns)\n\n\nif not lib._m_NetBSD:\n    def keyname(ch):\n        _ensure_initialised()\n        if ch < 0:\n            raise error(\"invalid key number\")\n        knp = lib.keyname(ch)\n        if knp == ffi.NULL:\n            return \"\"\n        return ffi.string(knp)\n\n\ndef killchar():\n    return lib.killchar()\n\n\ndef meta(ch):\n    return _check_ERR(lib.meta(lib.stdscr, ch), \"meta\")\n\n\nif lib._m_NCURSES_MOUSE_VERSION:\n\n    def mouseinterval(interval):\n        _ensure_initialised()\n        return _check_ERR(lib.mouseinterval(interval), \"mouseinterval\")\n\n    def mousemask(newmask):\n        _ensure_initialised()\n        oldmask = ffi.new(\"mmask_t *\")\n        availmask = lib.mousemask(newmask, oldmask)\n        return (availmask, oldmask)\n\n\ndef napms(ms):\n    _ensure_initialised()\n    return lib.napms(ms)\n\n\ndef newpad(nlines, ncols):\n    _ensure_initialised()\n    return Window(_check_NULL(lib.newpad(nlines, ncols)))\n\n\ndef newwin(nlines, ncols, begin_y=None, begin_x=None):\n    _ensure_initialised()\n    if begin_x is None:\n        if begin_y is not None:\n            raise error(\"newwin requires 2 or 4 arguments\")\n        begin_y = begin_x = 0\n\n    return Window(_check_NULL(lib.newwin(nlines, ncols, begin_y, begin_x)))\n\n\ndef pair_content(pair):\n    _ensure_initialised_color()\n    f = ffi.new(\"short *\")\n    b = ffi.new(\"short *\")\n    if lib.pair_content(pair, f, b) == lib.ERR:\n        raise error(\"Argument 1 was out of range. (1..COLOR_PAIRS-1)\")\n    return (f, b)\n\n\ndef pair_number(pairvalue):\n    _ensure_initialised_color()\n    return (pairvalue & lib.A_COLOR) >> 8\n\n\ndef putp(text):\n    text = _texttype(text)\n    return _check_ERR(lib.putp(text), \"putp\")\n\n\ndef qiflush(flag=True):\n    _ensure_initialised()\n    if flag:\n        lib.qiflush()\n    else:\n        lib.noqiflush()\n    return None\n\n\n# XXX: Do something about the following?\n# /* Internal helper used for updating curses.LINES, curses.COLS, _curses.LINES\n#  * and _curses.COLS */\n# #if defined(HAVE_CURSES_RESIZETERM) || defined(HAVE_CURSES_RESIZE_TERM)\n# static int\n# update_lines_cols(void)\n# {\n#     PyObject *o;\n#     PyObject *m = PyImport_ImportModuleNoBlock(\"curses\");\n\n#     if (!m)\n#         return 0;\n\n#     o = PyInt_FromLong(LINES);\n#     if (!o) {\n#         Py_DECREF(m);\n#         return 0;\n#     }\n#     if (PyObject_SetAttrString(m, \"LINES\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     if (PyDict_SetItemString(ModDict, \"LINES\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     Py_DECREF(o);\n#     o = PyInt_FromLong(COLS);\n#     if (!o) {\n#         Py_DECREF(m);\n#         return 0;\n#     }\n#     if (PyObject_SetAttrString(m, \"COLS\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     if (PyDict_SetItemString(ModDict, \"COLS\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     Py_DECREF(o);\n#     Py_DECREF(m);\n#     return 1;\n# }\n# #endif\n\n# #ifdef HAVE_CURSES_RESIZETERM\n# static PyObject *\n# PyCurses_ResizeTerm(PyObject *self, PyObject *args)\n# {\n#     int lines;\n#     int columns;\n#     PyObject *result;\n\n#     PyCursesInitialised;\n\n#     if (!PyArg_ParseTuple(args,\"ii:resizeterm\", &lines, &columns))\n#         return NULL;\n\n#     result = PyCursesCheckERR(resizeterm(lines, columns), \"resizeterm\");\n#     if (!result)\n#         return NULL;\n#     if (!update_lines_cols())\n#         return NULL;\n#     return result;\n# }\n\n# #endif\n\n# #ifdef HAVE_CURSES_RESIZE_TERM\n# static PyObject *\n# PyCurses_Resize_Term(PyObject *self, PyObject *args)\n# {\n#     int lines;\n#     int columns;\n\n#     PyObject *result;\n\n#     PyCursesInitialised;\n\n#     if (!PyArg_ParseTuple(args,\"ii:resize_term\", &lines, &columns))\n#         return NULL;\n\n#     result = PyCursesCheckERR(resize_term(lines, columns), \"resize_term\");\n#     if (!result)\n#         return NULL;\n#     if (!update_lines_cols())\n#         return NULL;\n#     return result;\n# }\n# #endif /* HAVE_CURSES_RESIZE_TERM */\n\n\ndef setsyx(y, x):\n    _ensure_initialised()\n    lib.setsyx(y, x)\n    return None\n\n\ndef start_color():\n    _check_ERR(lib.start_color(), \"start_color\")\n    globals()[\"COLORS\"] = lib.COLORS\n    globals()[\"COLOR_PAIRS\"] = lib.COLOR_PAIRS\n    globals()[\"_initialised_color\"] = True\n    return None\n\n\ndef tigetflag(capname):\n    _ensure_initialised_setupterm()\n    return lib.tigetflag(capname)\n\n\ndef tigetnum(capname):\n    _ensure_initialised_setupterm()\n    return lib.tigetnum(capname)\n\n\ndef tigetstr(capname):\n    _ensure_initialised_setupterm()\n    val = lib.tigetstr(capname)\n    if int(ffi.cast(\"intptr_t\", val)) in (0, -1):\n        return None\n    return ffi.string(val)\n\n\ndef tparm(fmt, i1=0, i2=0, i3=0, i4=0, i5=0, i6=0, i7=0, i8=0, i9=0):\n    args = [ffi.cast(\"int\", i) for i in (i1, i2, i3, i4, i5, i6, i7, i8, i9)]\n    result = lib.tparm(fmt, *args)\n    if result == ffi.NULL:\n        raise error(\"tparm() returned NULL\")\n    return ffi.string(result)\n\n\ndef typeahead(fd):\n    _ensure_initialised()\n    return _check_ERR(lib.typeahead(fd), \"typeahead\")\n\n\ndef unctrl(ch):\n    _ensure_initialised()\n    return lib.unctrl(_chtype(ch))\n\n\ndef ungetch(ch):\n    _ensure_initialised()\n    return _check_ERR(lib.ungetch(_chtype(ch)), \"ungetch\")\n\n\ndef use_env(flag):\n    lib.use_env(flag)\n    return None\n\n\nif not lib._m_STRICT_SYSV_CURSES:\n\n    def use_default_colors():\n        _ensure_initialised_color()\n        return _check_ERR(lib.use_default_colors(), \"use_default_colors\")\n", "demo/readdir_setup.py": "from setuptools import setup\n\nsetup(\n    name=\"example\",\n    version=\"0.1\",\n    py_modules=[\"readdir\"],\n    setup_requires=[\"cffi>=1.0.dev0\"],\n    cffi_modules=[\"readdir_build.py:ffi\"],\n    install_requires=[\"cffi>=1.0.dev0\"],\n    zip_safe=False,\n)\n", "demo/readdir_ctypes.py": "# A Linux-only demo\n#\n# For comparison purposes, this is a ctypes version of readdir.py.\nimport sys\nimport ctypes\n\nif not sys.platform.startswith('linux'):\n    raise Exception(\"Linux-only demo\")\n\n\nDIR_p = ctypes.c_void_p\nino_t = ctypes.c_long\noff_t = ctypes.c_long\n\nclass DIRENT(ctypes.Structure):\n    _fields_ = [\n        ('d_ino', ino_t),                 # inode number\n        ('d_off', off_t),                 # offset to the next dirent\n        ('d_reclen', ctypes.c_ushort),    # length of this record\n        ('d_type', ctypes.c_ubyte),       # type of file; not supported\n                                          #   by all file system types\n        ('d_name', ctypes.c_char * 256),  # filename\n        ]\nDIRENT_p = ctypes.POINTER(DIRENT)\nDIRENT_pp = ctypes.POINTER(DIRENT_p)\n\nC = ctypes.CDLL(None)\n\nreaddir_r = C.readdir_r\nreaddir_r.argtypes = [DIR_p, DIRENT_p, DIRENT_pp]\nreaddir_r.restype = ctypes.c_int\n\nopenat = C.openat\nopenat.argtypes = [ctypes.c_int, ctypes.c_char_p, ctypes.c_int]\nopenat.restype = ctypes.c_int\n\nfdopendir = C.fdopendir\nfdopendir.argtypes = [ctypes.c_int]\nfdopendir.restype = DIR_p\n\nclosedir = C.closedir\nclosedir.argtypes = [DIR_p]\nclosedir.restype = ctypes.c_int\n\n\ndef walk(basefd, path):\n    print '{', path\n    dirfd = openat(basefd, path, 0)\n    if dirfd < 0:\n        # error in openat()\n        return\n    dir = fdopendir(dirfd)\n    dirent = DIRENT()\n    result = DIRENT_p()\n    while True:\n        if readdir_r(dir, dirent, result):\n            # error in readdir_r()\n            break\n        if not result:\n            break\n        name = dirent.d_name\n        print '%3d %s' % (dirent.d_type, name)\n        if dirent.d_type == 4 and name != '.' and name != '..':\n            walk(dirfd, name)\n    closedir(dir)\n    print '}'\n\n\nwalk(-1, \"/tmp\")\n", "demo/readdir.py": "# A Linux-only demo\n#\nimport sys\n\nif not sys.platform.startswith('linux'):\n    raise Exception(\"Linux-only demo\")\n\nfrom _readdir import ffi\nlib = ffi.dlopen(None)\n\n\ndef walk(basefd, path):\n    print '{', path\n    dirfd = lib.openat(basefd, path, 0)\n    if dirfd < 0:\n        # error in openat()\n        return\n    dir = lib.fdopendir(dirfd)\n    dirent = ffi.new(\"struct dirent *\")\n    result = ffi.new(\"struct dirent **\")\n    while True:\n        if lib.readdir_r(dir, dirent, result):\n            # error in readdir_r()\n            break\n        if result[0] == ffi.NULL:\n            break\n        name = ffi.string(dirent.d_name)\n        print '%3d %s' % (dirent.d_type, name)\n        if dirent.d_type == 4 and name != '.' and name != '..':\n            walk(dirfd, name)\n    lib.closedir(dir)\n    print '}'\n\n\nwalk(-1, \"/tmp\")\n", "demo/fastcsv.py": "import csv\nimport cffi\n\n# IN-PROGRESS.  See the demo at the end of the file\n\n\ndef _make_ffi_from_dialect(dialect_name):\n    dialect = csv.get_dialect(dialect_name)\n\n    ffi = cffi.FFI()\n\n    ffi.cdef(\"\"\"\n        long parse_line(char *rawline, long inputlength);\n    \"\"\")\n\n    d = {'quotechar': ord(dialect.quotechar),\n         'quoting': int(dialect.quoting),\n         'skipinitialspace': int(dialect.skipinitialspace),\n         'delimiter': ord(dialect.delimiter),\n         'doublequote': int(dialect.doublequote),\n         'strict': int(dialect.strict),\n         }\n    if dialect.escapechar is not None:\n        d['is_escape_char'] = '== %d' % ord(dialect.escapechar)\n    else:\n        d['is_escape_char'] = '&& 0'\n\n    ffi.set_source('_fastcsv_' + dialect_name, r'''\n\n    typedef enum {\n        START_RECORD, START_FIELD, ESCAPED_CHAR, IN_FIELD,\n        IN_QUOTED_FIELD, ESCAPE_IN_QUOTED_FIELD, QUOTE_IN_QUOTED_FIELD,\n        EAT_CRNL\n    } ParserState;\n\n    typedef enum {\n        QUOTE_MINIMAL, QUOTE_ALL, QUOTE_NONNUMERIC, QUOTE_NONE\n    } QuoteStyle;\n\n    typedef struct {\n        ParserState state;          /* current CSV parse state */\n        char *field;                /* build current field in here */\n        int field_size;             /* size of allocated buffer */\n        int field_len;              /* length of current field */\n        int numeric_field;          /* treat field as numeric */\n    } ReaderObj;\n\n    static void\n    parse_add_char(ReaderObj *self, char c)\n    {\n        *self->field++ = c;\n    }\n\n    static void\n    parse_save_field(ReaderObj *self)\n    {\n        *self->field++ = 0;\n    }\n\n    static int\n    parse_process_char(ReaderObj *self, char c)\n    {\n        switch (self->state) {\n        case START_RECORD:\n            /* start of record */\n            if (c == '\\0')\n                /* empty line - return [] */\n                break;\n            else if (c == '\\n' || c == '\\r') {\n                self->state = EAT_CRNL;\n                break;\n            }\n            /* normal character - handle as START_FIELD */\n            self->state = START_FIELD;\n            /* fallthru */\n        case START_FIELD:\n            /* expecting field */\n            if (c == '\\n' || c == '\\r' || c == '\\0') {\n                /* save empty field - return [fields] */\n                parse_save_field(self);\n                self->state = (c == '\\0' ? START_RECORD : EAT_CRNL);\n            }\n            else if (c == %(quotechar)d &&\n                     %(quoting)d != QUOTE_NONE) {\n                /* start quoted field */\n                self->state = IN_QUOTED_FIELD;\n            }\n            else if (c %(is_escape_char)s) {\n                /* possible escaped character */\n                self->state = ESCAPED_CHAR;\n            }\n            else if (c == ' ' && %(skipinitialspace)d)\n                /* ignore space at start of field */\n                ;\n            else if (c == %(delimiter)d) {\n                /* save empty field */\n                parse_save_field(self);\n            }\n            else {\n                /* begin new unquoted field */\n                if (%(quoting)d == QUOTE_NONNUMERIC)\n                    self->numeric_field = 1;\n                parse_add_char(self, c);\n                self->state = IN_FIELD;\n            }\n            break;\n\n        case ESCAPED_CHAR:\n            if (c == '\\0')\n                c = '\\n';\n            parse_add_char(self, c);\n            self->state = IN_FIELD;\n            break;\n\n        case IN_FIELD:\n            /* in unquoted field */\n            if (c == '\\n' || c == '\\r' || c == '\\0') {\n                /* end of line - return [fields] */\n                parse_save_field(self);\n                self->state = (c == '\\0' ? START_RECORD : EAT_CRNL);\n            }\n            else if (c %(is_escape_char)s) {\n                /* possible escaped character */\n                self->state = ESCAPED_CHAR;\n            }\n            else if (c == %(delimiter)d) {\n                /* save field - wait for new field */\n                parse_save_field(self);\n                self->state = START_FIELD;\n            }\n            else {\n                /* normal character - save in field */\n                parse_add_char(self, c);\n            }\n            break;\n\n        case IN_QUOTED_FIELD:\n            /* in quoted field */\n            if (c == '\\0')\n                ;\n            else if (c %(is_escape_char)s) {\n                /* Possible escape character */\n                self->state = ESCAPE_IN_QUOTED_FIELD;\n            }\n            else if (c == %(quotechar)d &&\n                     %(quoting)d != QUOTE_NONE) {\n                if (%(doublequote)d) {\n                    /* doublequote; \" represented by \"\" */\n                    self->state = QUOTE_IN_QUOTED_FIELD;\n                }\n                else {\n                    /* end of quote part of field */\n                    self->state = IN_FIELD;\n                }\n            }\n            else {\n                /* normal character - save in field */\n                parse_add_char(self, c);\n            }\n            break;\n\n        case ESCAPE_IN_QUOTED_FIELD:\n            if (c == '\\0')\n                c = '\\n';\n            parse_add_char(self, c);\n            self->state = IN_QUOTED_FIELD;\n            break;\n\n        case QUOTE_IN_QUOTED_FIELD:\n            /* doublequote - seen a quote in an quoted field */\n            if (%(quoting)d != QUOTE_NONE &&\n                c == %(quotechar)d) {\n                /* save \"\" as \" */\n                parse_add_char(self, c);\n                self->state = IN_QUOTED_FIELD;\n            }\n            else if (c == %(delimiter)d) {\n                /* save field - wait for new field */\n                parse_save_field(self);\n                self->state = START_FIELD;\n            }\n            else if (c == '\\n' || c == '\\r' || c == '\\0') {\n                /* end of line - return [fields] */\n                parse_save_field(self);\n                self->state = (c == '\\0' ? START_RECORD : EAT_CRNL);\n            }\n            else if (!%(strict)d) {\n                parse_add_char(self, c);\n                self->state = IN_FIELD;\n            }\n            else {\n                /* illegal */\n                /*PyErr_Format(error_obj, \"'%%c' expected after '%%c'\",\n                                dialect->delimiter,\n                                dialect->quotechar);*/\n                return -1;\n            }\n            break;\n\n        case EAT_CRNL:\n            if (c == '\\n' || c == '\\r')\n                ;\n            else if (c == '\\0')\n                self->state = START_RECORD;\n            else {\n                /*PyErr_Format(error_obj, \"new-line character seen in unquoted field - do you need to open the file in universal-newline mode?\");*/\n                return -1;\n            }\n            break;\n\n        }\n        return 0;\n    }\n\n    static void\n    parse_reset(ReaderObj *self, char *rawline)\n    {\n        self->field = rawline;\n        self->state = START_RECORD;\n        self->numeric_field = 0;\n    }\n\n    long parse_line(char *rawline, long inputlength)\n    {\n        char *p;\n        ReaderObj reader;\n        parse_reset(&reader, rawline);\n\n        for (p=rawline; inputlength > 0; inputlength--, p++) {\n            if (parse_process_char(&reader, *p) < 0)\n                return -1;\n        }\n        if (parse_process_char(&reader, 0) < 0)\n            return -1;\n        return reader.field - rawline - 1;\n    }\n    ''' % d)\n\n    ffi.compile()\n\n\ndef fastcsv_reader(f, dialect_name):\n    try:\n        module = __import__('_fastcsv_' + dialect_name)\n    except ImportError:\n        _make_ffi_from_dialect(dialect_name)\n        module = __import__('_fastcsv_' + dialect_name)\n    ffi, lib = module.ffi, module.lib\n    #\n    linelen = -1\n    for line in f:\n        if linelen <= len(line):\n            linelen = 2 * len(line)\n            rawline = ffi.new(\"char[]\", linelen)\n        ffi.buffer(rawline, len(line))[:] = line\n        n = lib.parse_line(rawline, len(line))\n        assert n >= 0\n        yield ffi.buffer(rawline, n)[:].split('\\x00')\n\n\nif __name__ == '__main__':\n    csv.register_dialect('unixpwd', delimiter=':', quoting=csv.QUOTE_NONE)\n    with open('/etc/passwd', 'rb') as f:\n        reader = fastcsv_reader(f, 'unixpwd')\n        for row in reader:\n            print row\n", ".github/actions/dynamatrix/matrix_yaml_to_json.py": "from __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport pathlib\nimport sys\nimport typing as t\nimport yaml\n\nfrom collections.abc import MutableMapping, Sequence\n\nskipped_entries = []\n\ndef _filter_omit_entries(value):\n    if isinstance(value, MutableMapping):\n        if (omit_value := value.pop('omit', ...)) is not ...:\n            if omit_value is True or str(omit_value).lower().strip() == 'true':\n                print(f'omitting {value} from matrix')\n                skipped_entries.append(value)\n                return ...\n\n        return {k: v for k, v in ((k, _filter_omit_entries(v)) for k, v in value.items()) if v is not ...}\n\n    if isinstance(value, str):\n        return value\n\n    if isinstance(value, Sequence):\n        return [v for v in (_filter_omit_entries(v) for v in value) if v is not ...]\n\n    return value\n\ndef main():\n    p = argparse.ArgumentParser(description='GHA YAML matrix filter')\n    required_grp = p.add_mutually_exclusive_group(required=True)\n    required_grp.add_argument('--from-stdin', action='store_true', help='read input YAML from stdin')\n    required_grp.add_argument('--from-file', type=pathlib.Path, help='read input YAML from file path')\n\n    args = p.parse_args()\n\n    path: pathlib.Path | None\n\n    matrix_yaml: str\n\n    if path := args.from_file:\n        matrix_yaml = path.read_text()\n    elif args.from_stdin:\n        matrix_yaml = sys.stdin.read()\n    else:\n        raise Exception('no source provided for matrix yaml')\n\n    raw_matrix = yaml.safe_load(matrix_yaml)\n    filtered_matrix = _filter_omit_entries(raw_matrix)\n\n    output_matrix_json = json.dumps(filtered_matrix)\n    output_skipped_matrix_json = json.dumps(skipped_entries)\n\n    print(f'filtered matrix: {output_matrix_json}')\n    print(f'skipped entries: {output_skipped_matrix_json}')\n\n    if (gh_output := os.environ.get('GITHUB_OUTPUT')):\n        print('setting step output var matrix_json; skipped_matrix_json...')\n        with pathlib.Path(gh_output).open('a') as env_fd:\n            env_fd.write(f'matrix_json<<__MATRIX_EOF\\n{output_matrix_json}\\n__MATRIX_EOF\\n')\n            env_fd.write(f'skipped_matrix_json<<__MATRIX_EOF\\n{output_skipped_matrix_json}\\n__MATRIX_EOF\\n')\n    else:\n        print(\"GITHUB_OUTPUT not set; skipping variable output\")\n\n\nif __name__ == '__main__':\n    main()\n", "testing/support.py": "import sys, os\nfrom cffi._imp_emulation import load_dynamic\n\nif sys.version_info < (3,):\n    __all__ = ['u', 'arraytostring', 'load_dynamic']\n\n    class U(object):\n        def __add__(self, other):\n            return eval('u'+repr(other).replace(r'\\\\u', r'\\u')\n                                       .replace(r'\\\\U', r'\\U'))\n    u = U()\n    long = long     # for further \"from testing.support import long\"\n    assert u+'a\\x00b' == eval(r\"u'a\\x00b'\")\n    assert u+'a\\u1234b' == eval(r\"u'a\\u1234b'\")\n    assert u+'a\\U00012345b' == eval(r\"u'a\\U00012345b'\")\n    def arraytostring(a):\n        return a.tostring()\n\nelse:\n    __all__ = ['u', 'unicode', 'long', 'arraytostring', 'load_dynamic']\n    u = \"\"\n    unicode = str\n    long = int\n    def arraytostring(a):\n        return a.tobytes()\n\n\nclass StdErrCapture(object):\n    \"\"\"Capture writes to sys.stderr (not to the underlying file descriptor).\"\"\"\n    def __enter__(self):\n        try:\n            from StringIO import StringIO\n        except ImportError:\n            from io import StringIO\n        self.old_stderr = sys.stderr\n        sys.stderr = f = StringIO()\n        if hasattr(sys, '__unraisablehook__'):           # work around pytest\n            self.old_unraisablebook = sys.unraisablehook # on recent CPythons\n            sys.unraisablehook = sys.__unraisablehook__\n        return f\n    def __exit__(self, *args):\n        sys.stderr = self.old_stderr\n        if hasattr(self, 'old_unraisablebook'):\n            sys.unraisablehook = self.old_unraisablebook\n\n\nclass FdWriteCapture(object):\n    \"\"\"xxx limited to capture at most 512 bytes of output, according\n    to the Posix manual.\"\"\"\n\n    def __init__(self, capture_fd=2):    # stderr by default\n        if sys.platform == 'win32':\n            import pytest\n            pytest.skip(\"seems not to work, too bad\")\n        self.capture_fd = capture_fd\n\n    def __enter__(self):\n        import os\n        self.read_fd, self.write_fd = os.pipe()\n        self.copy_fd = os.dup(self.capture_fd)\n        os.dup2(self.write_fd, self.capture_fd)\n        return self\n\n    def __exit__(self, *args):\n        import os\n        os.dup2(self.copy_fd, self.capture_fd)\n        os.close(self.copy_fd)\n        os.close(self.write_fd)\n        self._value = os.read(self.read_fd, 512)\n        os.close(self.read_fd)\n\n    def getvalue(self):\n        return self._value\n\ndef _verify(ffi, module_name, preamble, *args, **kwds):\n    from cffi.recompiler import recompile\n    from .udir import udir\n    assert module_name not in sys.modules, \"module name conflict: %r\" % (\n        module_name,)\n    kwds.setdefault('tmpdir', str(udir))\n    outputfilename = recompile(ffi, module_name, preamble, *args, **kwds)\n    module = load_dynamic(module_name, outputfilename)\n    #\n    # hack hack hack: copy all *bound methods* from module.ffi back to the\n    # ffi instance.  Then calls like ffi.new() will invoke module.ffi.new().\n    for name in dir(module.ffi):\n        if not name.startswith('_'):\n            attr = getattr(module.ffi, name)\n            if attr is not getattr(ffi, name, object()):\n                setattr(ffi, name, attr)\n    def typeof_disabled(*args, **kwds):\n        raise NotImplementedError\n    ffi._typeof = typeof_disabled\n    for name in dir(ffi):\n        if not name.startswith('_') and not hasattr(module.ffi, name):\n            setattr(ffi, name, NotImplemented)\n    return module.lib\n\n\n# For testing, we call gcc with \"-Werror\".  This is fragile because newer\n# versions of gcc are always better at producing warnings, particularly for\n# auto-generated code.  We need here to adapt and silence them as needed.\n\nif sys.platform == 'win32':\n    extra_compile_args = []      # no obvious -Werror equivalent on MSVC\nelse:\n    if (sys.platform == 'darwin' and\n          [int(x) for x in os.uname()[2].split('.')] >= [11, 0, 0]):\n        # assume a standard clang or gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion',\n                              '-Wno-unused-parameter',\n                              '-Wno-unreachable-code']\n        # special things for clang\n        extra_compile_args.append('-Qunused-arguments')\n    else:\n        # assume a standard gcc\n        extra_compile_args = ['-Werror', '-Wall', '-Wextra', '-Wconversion',\n                              '-Wno-unused-parameter',\n                              '-Wno-unreachable-code']\n\nis_musl = False\nif sys.platform == 'linux':\n    try:\n        from packaging.tags import platform_tags\n    except ImportError:\n        pass\n    else:\n        tagset = frozenset(platform_tags())\n        is_musl = any(t.startswith('musllinux') for t in tagset)\n        if is_musl and sys.version_info >= (3, 12):\n            if any(t.startswith('musllinux_1_1_') for t in tagset) and not any(t.startswith('musllinux_1_2_') for t in tagset):\n                # gcc 9.2.0 in the musllinux_1_1 build container has a bug in its sign-conversion warning detection that\n                # bombs on the definition of _PyLong_CompactValue under Python 3.12; disable warnings-as-errors for that\n                # specific error on musl 1.1\n                extra_compile_args.append('-Wno-error=sign-conversion')\n\n        del platform_tags\n", "testing/conftest.py": "import pytest\nimport sys\n\nfrom ctypes import util\n\n# this problem was supposedly fixed in a newer Python 3.8 release, but after binary installer support expired\n# https://github.com/python/cpython/pull/28054\nif sys.platform == 'darwin' and sys.version_info[:2] == (3, 8):\n    orig_find_library = util.find_library\n\n    def hacked_find_library(*args, **kwargs):\n        res = orig_find_library(*args, **kwargs)\n\n        if res is None:\n            pytest.xfail(\"busted find_library on MacOS Python 3.8\")\n\n        return res\n\n    util.find_library = hacked_find_library\n", "testing/udir.py": "import py\nimport sys, os, atexit\n\n\n# This is copied from PyPy's vendored py lib.  The latest py lib release\n# (1.8.1) contains a bug and crashes if it sees another temporary directory\n# in which we don't have write permission (e.g. because it's owned by someone\n# else).\ndef make_numbered_dir(prefix='session-', rootdir=None, keep=3,\n                      lock_timeout = 172800,   # two days\n                      min_timeout = 300):      # five minutes\n    \"\"\" return unique directory with a number greater than the current\n        maximum one.  The number is assumed to start directly after prefix.\n        if keep is true directories with a number less than (maxnum-keep)\n        will be removed.\n    \"\"\"\n    if rootdir is None:\n        rootdir = py.path.local.get_temproot()\n\n    def parse_num(path):\n        \"\"\" parse the number out of a path (if it matches the prefix) \"\"\"\n        bn = path.basename\n        if bn.startswith(prefix):\n            try:\n                return int(bn[len(prefix):])\n            except ValueError:\n                pass\n\n    # compute the maximum number currently in use with the\n    # prefix\n    lastmax = None\n    while True:\n        maxnum = -1\n        for path in rootdir.listdir():\n            num = parse_num(path)\n            if num is not None:\n                maxnum = max(maxnum, num)\n\n        # make the new directory\n        try:\n            udir = rootdir.mkdir(prefix + str(maxnum+1))\n        except py.error.EEXIST:\n            # race condition: another thread/process created the dir\n            # in the meantime.  Try counting again\n            if lastmax == maxnum:\n                raise\n            lastmax = maxnum\n            continue\n        break\n\n    # put a .lock file in the new directory that will be removed at\n    # process exit\n    if lock_timeout:\n        lockfile = udir.join('.lock')\n        mypid = os.getpid()\n        if hasattr(lockfile, 'mksymlinkto'):\n            lockfile.mksymlinkto(str(mypid))\n        else:\n            lockfile.write(str(mypid))\n        def try_remove_lockfile():\n            # in a fork() situation, only the last process should\n            # remove the .lock, otherwise the other processes run the\n            # risk of seeing their temporary dir disappear.  For now\n            # we remove the .lock in the parent only (i.e. we assume\n            # that the children finish before the parent).\n            if os.getpid() != mypid:\n                return\n            try:\n                lockfile.remove()\n            except py.error.Error:\n                pass\n        atexit.register(try_remove_lockfile)\n\n    # prune old directories\n    if keep:\n        for path in rootdir.listdir():\n            num = parse_num(path)\n            if num is not None and num <= (maxnum - keep):\n                if min_timeout:\n                    # NB: doing this is needed to prevent (or reduce\n                    # a lot the chance of) the following situation:\n                    # 'keep+1' processes call make_numbered_dir() at\n                    # the same time, they create dirs, but then the\n                    # last process notices the first dir doesn't have\n                    # (yet) a .lock in it and kills it.\n                    try:\n                        t1 = path.lstat().mtime\n                        t2 = lockfile.lstat().mtime\n                        if abs(t2-t1) < min_timeout:\n                            continue   # skip directories too recent\n                    except py.error.Error:\n                        continue   # failure to get a time, better skip\n                lf = path.join('.lock')\n                try:\n                    t1 = lf.lstat().mtime\n                    t2 = lockfile.lstat().mtime\n                    if not lock_timeout or abs(t2-t1) < lock_timeout:\n                        continue   # skip directories still locked\n                except py.error.Error:\n                    pass   # assume that it means that there is no 'lf'\n                try:\n                    path.remove(rec=1)\n                except KeyboardInterrupt:\n                    raise\n                except: # this might be py.error.Error, WindowsError ...\n                    pass\n\n    # make link...\n    try:\n        username = os.environ['USER']           #linux, et al\n    except KeyError:\n        try:\n            username = os.environ['USERNAME']   #windows\n        except KeyError:\n            username = 'current'\n\n    src  = str(udir)\n    dest = src[:src.rfind('-')] + '-' + username\n    try:\n        os.unlink(dest)\n    except OSError:\n        pass\n    try:\n        os.symlink(src, dest)\n    except (OSError, AttributeError, NotImplementedError):\n        pass\n\n    return udir\n\n\nudir = make_numbered_dir(prefix = 'ffi-')\n\n\n# Windows-only workaround for some configurations: see\n# https://bugs.python.org/issue23246 (Python 2.7.9)\nif sys.platform == 'win32':\n    try:\n        import setuptools\n    except ImportError:\n        pass\n", "testing/__init__.py": "", "testing/cffi1/test_dlopen.py": "import pytest\nfrom cffi import FFI, VerificationError, CDefError\nfrom cffi.recompiler import make_py_source\nfrom testing.udir import udir\n\n\ndef test_simple():\n    ffi = FFI()\n    ffi.cdef(\"int close(int); static const int BB = 42; extern int somevar;\")\n    target = udir.join('test_simple.py')\n    make_py_source(ffi, 'test_simple', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_simple',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x01\\x0D\\x00\\x00\\x07\\x01\\x00\\x00\\x00\\x0F',\n    _globals = (b'\\xFF\\xFF\\xFF\\x1FBB',42,b'\\x00\\x00\\x00\\x23close',0,b'\\x00\\x00\\x01\\x21somevar',0),\n)\n\"\"\"\n\ndef test_global_constant():\n    ffi = FFI()\n    ffi.cdef(\"static const long BB; static const float BF = 12;\")\n    target = udir.join('test_valid_global_constant.py')\n    make_py_source(ffi, 'test_valid_global_constant', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_valid_global_constant',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x0D\\x01\\x00\\x00\\x09\\x01',\n    _globals = (b'\\x00\\x00\\x01\\x25BB',0,b'\\x00\\x00\\x00\\x25BF',0),\n)\n\"\"\"\n\ndef test_invalid_global_constant_3():\n    ffi = FFI()\n    e = pytest.raises(CDefError, ffi.cdef, \"#define BB 12.34\")\n    assert str(e.value).startswith(\n        \"only supports one of the following syntax:\")\n\ndef test_invalid_dotdotdot_in_macro():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO ...\")\n    target = udir.join('test_invalid_dotdotdot_in_macro.py')\n    e = pytest.raises(VerificationError, make_py_source, ffi,\n                       'test_invalid_dotdotdot_in_macro', str(target))\n    assert str(e.value) == (\"macro FOO: cannot use the syntax '...' in \"\n                            \"'#define FOO ...' when using the ABI mode\")\n\ndef test_typename():\n    ffi = FFI()\n    ffi.cdef(\"typedef int foobar_t;\")\n    target = udir.join('test_typename.py')\n    make_py_source(ffi, 'test_typename', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_typename',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x07\\x01',\n    _typenames = (b'\\x00\\x00\\x00\\x00foobar_t',),\n)\n\"\"\"\n\ndef test_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum myenum_e { AA, BB, CC=-42 };\")\n    target = udir.join('test_enum.py')\n    make_py_source(ffi, 'test_enum', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_enum',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x00\\x0B',\n    _globals = (b'\\xFF\\xFF\\xFF\\x0BAA',0,b'\\xFF\\xFF\\xFF\\x0BBB',1,b'\\xFF\\xFF\\xFF\\x0BCC',-42),\n    _enums = (b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x15myenum_e\\x00AA,BB,CC',),\n)\n\"\"\"\n\ndef test_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a; signed char b[]; }; struct bar_s;\")\n    target = udir.join('test_struct.py')\n    make_py_source(ffi, 'test_struct', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_struct',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x07\\x01\\x00\\x00\\x03\\x01\\x00\\x00\\x01\\x07\\x00\\x00\\x00\\x09\\x00\\x00\\x01\\x09',\n    _struct_unions = ((b'\\x00\\x00\\x00\\x03\\x00\\x00\\x00\\x10bar_s',),(b'\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x02foo_s',b'\\x00\\x00\\x00\\x11a',b'\\x00\\x00\\x02\\x11b')),\n)\n\"\"\"\n\ndef test_include():\n    ffi = FFI()\n    ffi.cdef(\"#define ABC 123\")\n    ffi.set_source('test_include', None)\n    target = udir.join('test_include.py')\n    make_py_source(ffi, 'test_include', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_include',\n    _version = 0x2601,\n    _types = b'',\n    _globals = (b'\\xFF\\xFF\\xFF\\x1FABC',123,),\n)\n\"\"\"\n    #\n    ffi2 = FFI()\n    ffi2.include(ffi)\n    target2 = udir.join('test2_include.py')\n    make_py_source(ffi2, 'test2_include', str(target2))\n    assert target2.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\nfrom test_include import ffi as _ffi0\n\nffi = _cffi_backend.FFI('test2_include',\n    _version = 0x2601,\n    _types = b'',\n    _includes = (_ffi0,),\n)\n\"\"\"\n\ndef test_negative_constant():\n    ffi = FFI()\n    ffi.cdef(\"static const int BB = -42;\")\n    target = udir.join('test_negative_constant.py')\n    make_py_source(ffi, 'test_negative_constant', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_negative_constant',\n    _version = 0x2601,\n    _types = b'',\n    _globals = (b'\\xFF\\xFF\\xFF\\x1FBB',-42,),\n)\n\"\"\"\n\ndef test_struct_included():\n    baseffi = FFI()\n    baseffi.cdef(\"struct foo_s { int x; };\")\n    baseffi.set_source('test_struct_included_base', None)\n    #\n    ffi = FFI()\n    ffi.include(baseffi)\n    target = udir.join('test_struct_included.py')\n    make_py_source(ffi, 'test_struct_included', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\nfrom test_struct_included_base import ffi as _ffi0\n\nffi = _cffi_backend.FFI('test_struct_included',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x00\\x09',\n    _struct_unions = ((b'\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x08foo_s',),),\n    _includes = (_ffi0,),\n)\n\"\"\"\n\ndef test_no_cross_include():\n    baseffi = FFI()\n    baseffi.set_source('test_no_cross_include_base', \"..source..\")\n    #\n    ffi = FFI()\n    ffi.include(baseffi)\n    target = udir.join('test_no_cross_include.py')\n    pytest.raises(VerificationError, make_py_source,\n                   ffi, 'test_no_cross_include', str(target))\n\ndef test_array():\n    ffi = FFI()\n    ffi.cdef(\"typedef int32_t my_array_t[42];\")\n    target = udir.join('test_array.py')\n    make_py_source(ffi, 'test_array', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_array',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x15\\x01\\x00\\x00\\x00\\x05\\x00\\x00\\x00\\x2A',\n    _typenames = (b'\\x00\\x00\\x00\\x01my_array_t',),\n)\n\"\"\"\n\ndef test_array_overflow():\n    ffi = FFI()\n    ffi.cdef(\"typedef int32_t my_array_t[3000000000];\")\n    target = udir.join('test_array_overflow.py')\n    pytest.raises(OverflowError, make_py_source,\n                   ffi, 'test_array_overflow', str(target))\n\ndef test_global_var():\n    ffi = FFI()\n    ffi.cdef(\"extern int myglob;\")\n    target = udir.join('test_global_var.py')\n    make_py_source(ffi, 'test_global_var', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_global_var',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x07\\x01',\n    _globals = (b'\\x00\\x00\\x00\\x21myglob',0,),\n)\n\"\"\"\n\ndef test_bitfield():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int y:10; short x:5; };\")\n    target = udir.join('test_bitfield.py')\n    make_py_source(ffi, 'test_bitfield', str(target))\n    assert target.read() == r\"\"\"# auto-generated file\nimport _cffi_backend\n\nffi = _cffi_backend.FFI('test_bitfield',\n    _version = 0x2601,\n    _types = b'\\x00\\x00\\x07\\x01\\x00\\x00\\x05\\x01\\x00\\x00\\x00\\x09',\n    _struct_unions = ((b'\\x00\\x00\\x00\\x02\\x00\\x00\\x00\\x02foo_s',b'\\x00\\x00\\x00\\x13\\x00\\x00\\x00\\x0Ay',b'\\x00\\x00\\x01\\x13\\x00\\x00\\x00\\x05x'),),\n)\n\"\"\"\n", "testing/cffi1/test_recompiler.py": "\nimport sys, os\nimport pytest\nfrom cffi import FFI, VerificationError, FFIError, CDefError\nfrom cffi import recompiler\nfrom testing.udir import udir\nfrom testing.support import u, long\nfrom testing.support import FdWriteCapture, StdErrCapture, _verify\n\ntry:\n    import importlib\nexcept ImportError:\n    importlib = None\n\n\ndef check_type_table(input, expected_output, included=None):\n    ffi = FFI()\n    if included:\n        ffi1 = FFI()\n        ffi1.cdef(included)\n        ffi.include(ffi1)\n    ffi.cdef(input)\n    recomp = recompiler.Recompiler(ffi, 'testmod')\n    recomp.collect_type_table()\n    assert ''.join(map(str, recomp.cffi_types)) == expected_output\n\ndef verify(ffi, module_name, source, *args, **kwds):\n    no_cpp = kwds.pop('no_cpp', False)\n    ignore_warnings = kwds.pop('ignore_warnings', False)\n    kwds.setdefault('undef_macros', ['NDEBUG'])\n    module_name = '_CFFI_' + module_name\n    ffi.set_source(module_name, source)\n    if not os.environ.get('NO_CPP') and not no_cpp:   # test the .cpp mode too\n        kwds.setdefault('source_extension', '.cpp')\n        source = 'extern \"C\" {\\n%s\\n}' % (source,)\n    elif sys.platform != 'win32' and not ignore_warnings:\n        # add '-Werror' to the existing 'extra_compile_args' flags\n        from testing.support import extra_compile_args\n        kwds['extra_compile_args'] = (kwds.get('extra_compile_args', []) +\n                                      extra_compile_args)\n    if sys.platform == 'darwin':\n        kwds['extra_link_args'] = (kwds.get('extra_link_args', []) +\n                                     ['-stdlib=libc++'])\n    return _verify(ffi, module_name, source, *args, **kwds)\n\ndef test_set_source_no_slashes():\n    ffi = FFI()\n    pytest.raises(ValueError, ffi.set_source, \"abc/def\", None)\n    pytest.raises(ValueError, ffi.set_source, \"abc/def\", \"C code\")\n\n\ndef test_type_table_func():\n    check_type_table(\"double sin(double);\",\n                     \"(FUNCTION 1)(PRIMITIVE 14)(FUNCTION_END 0)\")\n    check_type_table(\"float sin(double);\",\n                     \"(FUNCTION 3)(PRIMITIVE 14)(FUNCTION_END 0)(PRIMITIVE 13)\")\n    check_type_table(\"float sin(void);\",\n                     \"(FUNCTION 2)(FUNCTION_END 0)(PRIMITIVE 13)\")\n    check_type_table(\"double sin(float); double cos(float);\",\n                     \"(FUNCTION 3)(PRIMITIVE 13)(FUNCTION_END 0)(PRIMITIVE 14)\")\n    check_type_table(\"double sin(float); double cos(double);\",\n                     \"(FUNCTION 1)(PRIMITIVE 14)(FUNCTION_END 0)\"   # cos\n                     \"(FUNCTION 1)(PRIMITIVE 13)(FUNCTION_END 0)\")  # sin\n    check_type_table(\"float sin(double); float cos(float);\",\n                     \"(FUNCTION 4)(PRIMITIVE 14)(FUNCTION_END 0)\"   # sin\n                     \"(FUNCTION 4)(PRIMITIVE 13)(FUNCTION_END 0)\")  # cos\n\ndef test_type_table_use_noop_for_repeated_args():\n    check_type_table(\"double sin(double *, double *);\",\n                     \"(FUNCTION 4)(POINTER 4)(NOOP 1)(FUNCTION_END 0)\"\n                     \"(PRIMITIVE 14)\")\n    check_type_table(\"double sin(double *, double *, double);\",\n                     \"(FUNCTION 3)(POINTER 3)(NOOP 1)(PRIMITIVE 14)\"\n                     \"(FUNCTION_END 0)\")\n\ndef test_type_table_dont_use_noop_for_primitives():\n    check_type_table(\"double sin(double, double);\",\n                     \"(FUNCTION 1)(PRIMITIVE 14)(PRIMITIVE 14)(FUNCTION_END 0)\")\n\ndef test_type_table_funcptr_as_argument():\n    check_type_table(\"int sin(double(float));\",\n                     \"(FUNCTION 6)(PRIMITIVE 13)(FUNCTION_END 0)\"\n                     \"(FUNCTION 7)(POINTER 0)(FUNCTION_END 0)\"\n                     \"(PRIMITIVE 14)(PRIMITIVE 7)\")\n\ndef test_type_table_variadic_function():\n    check_type_table(\"int sin(int, ...);\",\n                     \"(FUNCTION 1)(PRIMITIVE 7)(FUNCTION_END 1)(POINTER 0)\")\n\ndef test_type_table_array():\n    check_type_table(\"extern int a[100];\",\n                     \"(PRIMITIVE 7)(ARRAY 0)(None 100)\")\n\ndef test_type_table_typedef():\n    check_type_table(\"typedef int foo_t;\",\n                     \"(PRIMITIVE 7)\")\n\ndef test_type_table_prebuilt_type():\n    check_type_table(\"int32_t f(void);\",\n                     \"(FUNCTION 2)(FUNCTION_END 0)(PRIMITIVE 21)\")\n\ndef test_type_table_struct_opaque():\n    check_type_table(\"struct foo_s;\",\n                     \"(STRUCT_UNION 0)\")\n\ndef test_type_table_struct():\n    check_type_table(\"struct foo_s { int a; long b; };\",\n                     \"(PRIMITIVE 7)(PRIMITIVE 9)(STRUCT_UNION 0)\")\n\ndef test_type_table_union():\n    check_type_table(\"union foo_u { int a; long b; };\",\n                     \"(PRIMITIVE 7)(PRIMITIVE 9)(STRUCT_UNION 0)\")\n\ndef test_type_table_struct_used():\n    check_type_table(\"struct foo_s { int a; long b; }; int f(struct foo_s*);\",\n                     \"(FUNCTION 3)(POINTER 5)(FUNCTION_END 0)\"\n                     \"(PRIMITIVE 7)(PRIMITIVE 9)\"\n                     \"(STRUCT_UNION 0)\")\n\ndef test_type_table_anonymous_struct_with_typedef():\n    check_type_table(\"typedef struct { int a; long b; } foo_t;\",\n                     \"(STRUCT_UNION 0)(PRIMITIVE 7)(PRIMITIVE 9)\")\n\ndef test_type_table_enum():\n    check_type_table(\"enum foo_e { AA, BB, ... };\",\n                     \"(ENUM 0)\")\n\ndef test_type_table_include_1():\n    check_type_table(\"foo_t sin(foo_t);\",\n                     \"(FUNCTION 1)(PRIMITIVE 14)(FUNCTION_END 0)\",\n                     included=\"typedef double foo_t;\")\n\ndef test_type_table_include_2():\n    check_type_table(\"struct foo_s *sin(struct foo_s *);\",\n                     \"(FUNCTION 1)(POINTER 3)(FUNCTION_END 0)(STRUCT_UNION 0)\",\n                     included=\"struct foo_s { int x, y; };\")\n\n\ndef test_math_sin():\n    import math\n    ffi = FFI()\n    ffi.cdef(\"float sin(double); double cos(double);\")\n    lib = verify(ffi, 'test_math_sin', '#include <math.h>',\n                 ignore_warnings=True)\n    assert lib.cos(1.43) == math.cos(1.43)\n\ndef test_repr_lib():\n    ffi = FFI()\n    lib = verify(ffi, 'test_repr_lib', '')\n    assert repr(lib) == \"<Lib object for '_CFFI_test_repr_lib'>\"\n\ndef test_funcarg_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int *);\")\n    lib = verify(ffi, 'test_funcarg_ptr', 'int foo(int *p) { return *p; }')\n    assert lib.foo([-12345]) == -12345\n\ndef test_funcres_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(void);\")\n    lib = verify(ffi, 'test_funcres_ptr',\n                 'int *foo(void) { static int x=-12345; return &x; }')\n    assert lib.foo()[0] == -12345\n\ndef test_global_var_array():\n    ffi = FFI()\n    ffi.cdef(\"extern int a[100];\")\n    lib = verify(ffi, 'test_global_var_array', 'int a[100] = { 9999 };')\n    lib.a[42] = 123456\n    assert lib.a[42] == 123456\n    assert lib.a[0] == 9999\n\ndef test_verify_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int **foo_t;\")\n    lib = verify(ffi, 'test_verify_typedef', 'typedef int **foo_t;')\n    assert ffi.sizeof(\"foo_t\") == ffi.sizeof(\"void *\")\n\ndef test_verify_typedef_dotdotdot():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t;\")\n    verify(ffi, 'test_verify_typedef_dotdotdot', 'typedef int **foo_t;')\n\ndef test_verify_typedef_star_dotdotdot():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... *foo_t;\")\n    verify(ffi, 'test_verify_typedef_star_dotdotdot', 'typedef int **foo_t;')\n\ndef test_global_var_int():\n    ffi = FFI()\n    ffi.cdef(\"extern int a, b, c;\")\n    lib = verify(ffi, 'test_global_var_int', 'int a = 999, b, c;')\n    assert lib.a == 999\n    lib.a -= 1001\n    assert lib.a == -2\n    lib.a = -2147483648\n    assert lib.a == -2147483648\n    with pytest.raises(OverflowError):\n        lib.a = 2147483648\n    with pytest.raises(OverflowError):\n        lib.a = -2147483649\n    lib.b = 525      # try with the first access being in setattr, too\n    assert lib.b == 525\n    with pytest.raises(AttributeError):\n        del lib.a\n    with pytest.raises(AttributeError):\n        del lib.c\n    with pytest.raises(AttributeError):\n        del lib.foobarbaz\n\ndef test_macro():\n    ffi = FFI()\n    ffi.cdef(\"#define FOOBAR ...\")\n    lib = verify(ffi, 'test_macro', \"#define FOOBAR (-6912)\")\n    assert lib.FOOBAR == -6912\n    with pytest.raises(AttributeError):\n        lib.FOOBAR = 2\n\ndef test_macro_check_value():\n    # the value '-0x80000000' in C sources does not have a clear meaning\n    # to me; it appears to have a different effect than '-2147483648'...\n    # Moreover, on 32-bits, -2147483648 is actually equal to\n    # -2147483648U, which in turn is equal to 2147483648U and so positive.\n    vals = ['42', '-42', '0x80000000', '-2147483648',\n            '0', '9223372036854775809ULL',\n            '-9223372036854775807LL']\n    if sys.maxsize <= 2**32 or sys.platform == 'win32':\n        vals.remove('-2147483648')\n    ffi = FFI()\n    cdef_lines = ['#define FOO_%d_%d %s' % (i, j, vals[i])\n                  for i in range(len(vals))\n                  for j in range(len(vals))]\n    ffi.cdef('\\n'.join(cdef_lines))\n\n    verify_lines = ['#define FOO_%d_%d %s' % (i, j, vals[j])  # [j], not [i]\n                    for i in range(len(vals))\n                    for j in range(len(vals))]\n    lib = verify(ffi, 'test_macro_check_value_ok',\n                 '\\n'.join(verify_lines))\n    #\n    for j in range(len(vals)):\n        c_got = int(vals[j].replace('U', '').replace('L', ''), 0)\n        c_compiler_msg = str(c_got)\n        if c_got > 0:\n            c_compiler_msg += ' (0x%x)' % (c_got,)\n        #\n        for i in range(len(vals)):\n            attrname = 'FOO_%d_%d' % (i, j)\n            if i == j:\n                x = getattr(lib, attrname)\n                assert x == c_got\n            else:\n                e = pytest.raises(ffi.error, getattr, lib, attrname)\n                assert str(e.value) == (\n                    \"the C compiler says '%s' is equal to \"\n                    \"%s, but the cdef disagrees\" % (attrname, c_compiler_msg))\n\ndef test_constant():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOOBAR;\")\n    lib = verify(ffi, 'test_constant', \"#define FOOBAR (-6912)\")\n    assert lib.FOOBAR == -6912\n    with pytest.raises(AttributeError):\n        lib.FOOBAR = 2\n\ndef test_check_value_of_static_const():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOOBAR = 042;\")\n    lib = verify(ffi, 'test_check_value_of_static_const',\n                 \"#define FOOBAR (-6912)\")\n    e = pytest.raises(ffi.error, getattr, lib, 'FOOBAR')\n    assert str(e.value) == (\n       \"the C compiler says 'FOOBAR' is equal to -6912, but the cdef disagrees\")\n\ndef test_constant_nonint():\n    ffi = FFI()\n    ffi.cdef(\"static const double FOOBAR;\")\n    lib = verify(ffi, 'test_constant_nonint', \"#define FOOBAR (-6912.5)\")\n    assert lib.FOOBAR == -6912.5\n    with pytest.raises(AttributeError):\n        lib.FOOBAR = 2\n\ndef test_constant_ptr():\n    ffi = FFI()\n    ffi.cdef(\"static double *const FOOBAR;\")\n    lib = verify(ffi, 'test_constant_ptr', \"#define FOOBAR NULL\")\n    assert lib.FOOBAR == ffi.NULL\n    assert ffi.typeof(lib.FOOBAR) == ffi.typeof(\"double *\")\n\ndef test_dir():\n    ffi = FFI()\n    ffi.cdef(\"int ff(int); extern int aa; static const int my_constant;\")\n    lib = verify(ffi, 'test_dir', \"\"\"\n        #define my_constant  (-45)\n        int aa;\n        int ff(int x) { return x+aa; }\n    \"\"\")\n    lib.aa = 5\n    assert dir(lib) == ['aa', 'ff', 'my_constant']\n    #\n    aaobj = lib.__dict__['aa']\n    assert not isinstance(aaobj, int)    # some internal object instead\n    assert lib.__dict__ == {\n        'ff': lib.ff,\n        'aa': aaobj,\n        'my_constant': -45}\n    lib.__dict__['ff'] = \"??\"\n    assert lib.ff(10) == 15\n\ndef test_verify_opaque_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s;\")\n    lib = verify(ffi, 'test_verify_opaque_struct', \"struct foo_s;\")\n    assert ffi.typeof(\"struct foo_s\").cname == \"struct foo_s\"\n\ndef test_verify_opaque_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_s;\")\n    lib = verify(ffi, 'test_verify_opaque_union', \"union foo_s;\")\n    assert ffi.typeof(\"union foo_s\").cname == \"union foo_s\"\n\ndef test_verify_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { int b; short a; ...; };\n                struct bar_s { struct foo_s *f; };\"\"\")\n    lib = verify(ffi, 'test_verify_struct',\n                 \"\"\"struct foo_s { short a; int b; };\n                    struct bar_s { struct foo_s *f; };\"\"\")\n    ffi.typeof(\"struct bar_s *\")\n    p = ffi.new(\"struct foo_s *\", {'a': -32768, 'b': -2147483648})\n    assert p.a == -32768\n    assert p.b == -2147483648\n    with pytest.raises(OverflowError):\n        p.a -= 1\n    with pytest.raises(OverflowError):\n        p.b -= 1\n    q = ffi.new(\"struct bar_s *\", {'f': p})\n    assert q.f == p\n    #\n    assert ffi.offsetof(\"struct foo_s\", \"a\") == 0\n    assert ffi.offsetof(\"struct foo_s\", \"b\") == 4\n    assert ffi.offsetof(u+\"struct foo_s\", u+\"b\") == 4\n    #\n    pytest.raises(TypeError, ffi.addressof, p)\n    assert ffi.addressof(p[0]) == p\n    assert ffi.typeof(ffi.addressof(p[0])) is ffi.typeof(\"struct foo_s *\")\n    assert ffi.typeof(ffi.addressof(p, \"b\")) is ffi.typeof(\"int *\")\n    assert ffi.addressof(p, \"b\")[0] == p.b\n\ndef test_verify_exact_field_offset():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { int b; short a; };\"\"\")\n    lib = verify(ffi, 'test_verify_exact_field_offset',\n                 \"\"\"struct foo_s { short a; int b; };\"\"\")\n    e = pytest.raises(ffi.error, ffi.new, \"struct foo_s *\", [])    # lazily\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong offset for field 'b' (cdef \"\n        'says 0, but C compiler says 4). fix it or use \"...;\" ')\n\ndef test_type_caching():\n    ffi1 = FFI(); ffi1.cdef(\"struct foo_s;\")\n    ffi2 = FFI(); ffi2.cdef(\"struct foo_s;\")    # different one!\n    lib1 = verify(ffi1, 'test_type_caching_1', 'struct foo_s;')\n    lib2 = verify(ffi2, 'test_type_caching_2', 'struct foo_s;')\n    # shared types\n    assert ffi1.typeof(\"long\") is ffi2.typeof(\"long\")\n    assert ffi1.typeof(\"long**\") is ffi2.typeof(\"long * *\")\n    assert ffi1.typeof(\"long(*)(int, ...)\") is ffi2.typeof(\"long(*)(int, ...)\")\n    # non-shared types\n    assert ffi1.typeof(\"struct foo_s\") is not ffi2.typeof(\"struct foo_s\")\n    assert ffi1.typeof(\"struct foo_s *\") is not ffi2.typeof(\"struct foo_s *\")\n    assert ffi1.typeof(\"struct foo_s*(*)()\") is not (\n        ffi2.typeof(\"struct foo_s*(*)()\"))\n    assert ffi1.typeof(\"void(*)(struct foo_s*)\") is not (\n        ffi2.typeof(\"void(*)(struct foo_s*)\"))\n\ndef test_verify_enum():\n    ffi = FFI()\n    ffi.cdef(\"\"\"enum e1 { B1, A1, ... }; enum e2 { B2, A2, ... };\"\"\")\n    lib = verify(ffi, 'test_verify_enum',\n                 \"enum e1 { A1, B1, C1=%d };\" % sys.maxsize +\n                 \"enum e2 { A2, B2, C2 };\")\n    ffi.typeof(\"enum e1\")\n    ffi.typeof(\"enum e2\")\n    assert lib.A1 == 0\n    assert lib.B1 == 1\n    assert lib.A2 == 0\n    assert lib.B2 == 1\n    assert ffi.sizeof(\"enum e1\") == ffi.sizeof(\"long\")\n    assert ffi.sizeof(\"enum e2\") == ffi.sizeof(\"int\")\n    assert repr(ffi.cast(\"enum e1\", 0)) == \"<cdata 'enum e1' 0: A1>\"\n\ndef test_duplicate_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum e1 { A1, ... }; enum e2 { A1, ... };\")\n    pytest.raises(VerificationError, verify, ffi, 'test_duplicate_enum',\n                    \"enum e1 { A1 }; enum e2 { B1 };\")\n\ndef test_dotdotdot_length_of_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...]; int b[...]; };\")\n    verify(ffi, 'test_dotdotdot_length_of_array_field',\n           \"struct foo_s { int a[42]; int b[11]; };\")\n    assert ffi.sizeof(\"struct foo_s\") == (42 + 11) * 4\n    p = ffi.new(\"struct foo_s *\")\n    assert p.a[41] == p.b[10] == 0\n    with pytest.raises(IndexError):\n        p.a[42]\n    with pytest.raises(IndexError):\n        p.b[11]\n\ndef test_dotdotdot_global_array():\n    ffi = FFI()\n    ffi.cdef(\"extern int aa[...]; extern int bb[...];\")\n    lib = verify(ffi, 'test_dotdotdot_global_array',\n                 \"int aa[41]; int bb[12];\")\n    assert ffi.sizeof(lib.aa) == 41 * 4\n    assert ffi.sizeof(lib.bb) == 12 * 4\n    assert lib.aa[40] == lib.bb[11] == 0\n    with pytest.raises(IndexError):\n        lib.aa[41]\n    with pytest.raises(IndexError):\n        lib.bb[12]\n\ndef test_misdeclared_field_1():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[5]; };\")\n    try:\n        verify(ffi, 'test_misdeclared_field_1',\n               \"struct foo_s { int a[6]; };\")\n    except VerificationError:\n        pass    # ok, fail during compilation already (e.g. C++)\n    else:\n        assert ffi.sizeof(\"struct foo_s\") == 24  # found by the actual C code\n        try:\n            # lazily build the fields and boom:\n            p = ffi.new(\"struct foo_s *\")\n            p.a\n            assert False, \"should have raised\"\n        except ffi.error as e:\n            assert str(e).startswith(\"struct foo_s: wrong size for field 'a' \"\n                                     \"(cdef says 20, but C compiler says 24)\")\n\ndef test_open_array_in_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int b; int a[]; };\")\n    verify(ffi, 'test_open_array_in_struct',\n           \"struct foo_s { int b; int a[]; };\")\n    assert ffi.sizeof(\"struct foo_s\") == 4\n    p = ffi.new(\"struct foo_s *\", [5, [10, 20, 30, 40]])\n    assert p.a[2] == 30\n    assert ffi.sizeof(p) == ffi.sizeof(\"void *\")\n    assert ffi.sizeof(p[0]) == 5 * ffi.sizeof(\"int\")\n\ndef test_math_sin_type():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double); void *xxtestfunc();\")\n    lib = verify(ffi, 'test_math_sin_type', \"\"\"\n        #include <math.h>\n        void *xxtestfunc(void) { return 0; }\n    \"\"\")\n    # 'lib.sin' is typed as a <built-in method> object on lib\n    assert ffi.typeof(lib.sin).cname == \"double(*)(double)\"\n    # 'x' is another <built-in method> object on lib, made very indirectly\n    x = type(lib).__dir__.__get__(lib)\n    pytest.raises(TypeError, ffi.typeof, x)\n    #\n    # present on built-in functions on CPython; must be emulated on PyPy:\n    assert lib.sin.__name__ == 'sin'\n    assert lib.sin.__module__ == '_CFFI_test_math_sin_type'\n    assert lib.sin.__doc__ == (\n        \"double sin(double);\\n\"\n        \"\\n\"\n        \"CFFI C function from _CFFI_test_math_sin_type.lib\")\n\n    assert ffi.typeof(lib.xxtestfunc).cname == \"void *(*)()\"\n    assert lib.xxtestfunc.__doc__ == (\n        \"void *xxtestfunc();\\n\"\n        \"\\n\"\n        \"CFFI C function from _CFFI_test_math_sin_type.lib\")\n\ndef test_verify_anonymous_struct_with_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int a; long b; ...; } foo_t;\")\n    verify(ffi, 'test_verify_anonymous_struct_with_typedef',\n           \"typedef struct { long b; int hidden, a; } foo_t;\")\n    p = ffi.new(\"foo_t *\", {'b': 42})\n    assert p.b == 42\n    assert repr(p).startswith(\"<cdata 'foo_t *' \")\n\ndef test_verify_anonymous_struct_with_star_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int a; long b; } *foo_t;\")\n    verify(ffi, 'test_verify_anonymous_struct_with_star_typedef',\n           \"typedef struct { int a; long b; } *foo_t;\")\n    p = ffi.new(\"foo_t\", {'b': 42})\n    assert p.b == 42\n\ndef test_verify_anonymous_enum_with_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, ... } e1;\")\n    lib = verify(ffi, 'test_verify_anonymous_enum_with_typedef1',\n                 \"typedef enum { BB, CC, AA } e1;\")\n    assert lib.AA == 2\n    assert ffi.sizeof(\"e1\") == ffi.sizeof(\"int\")\n    assert repr(ffi.cast(\"e1\", 2)) == \"<cdata 'e1' 2: AA>\"\n    #\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA=%d } e1;\" % sys.maxsize)\n    lib = verify(ffi, 'test_verify_anonymous_enum_with_typedef2',\n                 \"typedef enum { AA=%d } e1;\" % sys.maxsize)\n    assert lib.AA == int(ffi.cast(\"long\", sys.maxsize))\n    assert ffi.sizeof(\"e1\") == ffi.sizeof(\"long\")\n\ndef test_unique_types():\n    CDEF = \"struct foo_s; union foo_u; enum foo_e { AA };\"\n    ffi1 = FFI(); ffi1.cdef(CDEF); verify(ffi1, \"test_unique_types_1\", CDEF)\n    ffi2 = FFI(); ffi2.cdef(CDEF); verify(ffi2, \"test_unique_types_2\", CDEF)\n    #\n    assert ffi1.typeof(\"char\") is ffi2.typeof(\"char \")\n    assert ffi1.typeof(\"long\") is ffi2.typeof(\"signed long int\")\n    assert ffi1.typeof(\"double *\") is ffi2.typeof(\"double*\")\n    assert ffi1.typeof(\"int ***\") is ffi2.typeof(\" int * * *\")\n    assert ffi1.typeof(\"int[]\") is ffi2.typeof(\"signed int[]\")\n    assert ffi1.typeof(\"signed int*[17]\") is ffi2.typeof(\"int *[17]\")\n    assert ffi1.typeof(\"void\") is ffi2.typeof(\"void\")\n    assert ffi1.typeof(\"int(*)(int,int)\") is ffi2.typeof(\"int(*)(int,int)\")\n    #\n    # these depend on user-defined data, so should not be shared\n    for name in [\"struct foo_s\",\n                 \"union foo_u *\",\n                 \"enum foo_e\",\n                 \"struct foo_s *(*)()\",\n                 \"void(*)(struct foo_s *)\",\n                 \"struct foo_s *(*[5])[8]\",\n                 ]:\n        assert ffi1.typeof(name) is not ffi2.typeof(name)\n    # sanity check: twice 'ffi1'\n    assert ffi1.typeof(\"struct foo_s*\") is ffi1.typeof(\"struct foo_s *\")\n\ndef test_module_name_in_package():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    recompiler.recompile(ffi, \"test_module_name_in_package.mymod\",\n                         \"int foo(int x) { return x + 32; }\",\n                         tmpdir=str(udir))\n    old_sys_path = sys.path[:]\n    try:\n        package_dir = udir.join('test_module_name_in_package')\n        for name in os.listdir(str(udir)):\n            assert not name.startswith('test_module_name_in_package.')\n        assert os.path.isdir(str(package_dir))\n        assert len(os.listdir(str(package_dir))) > 0\n        assert os.path.exists(str(package_dir.join('mymod.c')))\n        package_dir.join('__init__.py').write('')\n        #\n        getattr(importlib, 'invalidate_caches', object)()\n        #\n        sys.path.insert(0, str(udir))\n        import test_module_name_in_package.mymod\n        assert test_module_name_in_package.mymod.lib.foo(10) == 42\n        assert test_module_name_in_package.mymod.__name__ == (\n            'test_module_name_in_package.mymod')\n    finally:\n        sys.path[:] = old_sys_path\n\ndef test_bad_size_of_global_1():\n    ffi = FFI()\n    ffi.cdef(\"extern short glob;\")\n    pytest.raises(VerificationError, verify, ffi,\n                   \"test_bad_size_of_global_1\", \"long glob;\")\n\ndef test_bad_size_of_global_2():\n    ffi = FFI()\n    ffi.cdef(\"extern int glob[10];\")\n    pytest.raises(VerificationError, verify, ffi,\n                   \"test_bad_size_of_global_2\", \"int glob[9];\")\n\ndef test_unspecified_size_of_global_1():\n    ffi = FFI()\n    ffi.cdef(\"extern int glob[];\")\n    lib = verify(ffi, \"test_unspecified_size_of_global_1\", \"int glob[10];\")\n    assert ffi.typeof(lib.glob) == ffi.typeof(\"int *\")\n\ndef test_unspecified_size_of_global_2():\n    ffi = FFI()\n    ffi.cdef(\"extern int glob[][5];\")\n    lib = verify(ffi, \"test_unspecified_size_of_global_2\", \"int glob[10][5];\")\n    assert ffi.typeof(lib.glob) == ffi.typeof(\"int(*)[5]\")\n\ndef test_unspecified_size_of_global_3():\n    ffi = FFI()\n    ffi.cdef(\"extern int glob[][...];\")\n    lib = verify(ffi, \"test_unspecified_size_of_global_3\", \"int glob[10][5];\")\n    assert ffi.typeof(lib.glob) == ffi.typeof(\"int(*)[5]\")\n\ndef test_unspecified_size_of_global_4():\n    ffi = FFI()\n    ffi.cdef(\"extern int glob[...][...];\")\n    lib = verify(ffi, \"test_unspecified_size_of_global_4\", \"int glob[10][5];\")\n    assert ffi.typeof(lib.glob) == ffi.typeof(\"int[10][5]\")\n\ndef test_include_1():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef double foo_t;\")\n    verify(ffi1, \"test_include_1_parent\", \"typedef double foo_t;\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"foo_t ff1(foo_t);\")\n    lib = verify(ffi, \"test_include_1\", \"double ff1(double x) { return 42.5; }\")\n    assert lib.ff1(0) == 42.5\n    assert ffi1.typeof(\"foo_t\") is ffi.typeof(\"foo_t\") is ffi.typeof(\"double\")\n\ndef test_include_1b():\n    ffi1 = FFI()\n    ffi1.cdef(\"int foo1(int);\")\n    lib1 = verify(ffi1, \"test_include_1b_parent\",\n                  \"int foo1(int x) { return x + 10; }\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"int foo2(int);\")\n    lib = verify(ffi, \"test_include_1b\", \"int foo2(int x) { return x - 5; }\")\n    assert lib.foo2(42) == 37\n    assert lib.foo1(42) == 52\n    assert lib.foo1 is lib1.foo1\n\ndef test_include_2():\n    ffi1 = FFI()\n    ffi1.cdef(\"struct foo_s { int x, y; };\")\n    verify(ffi1, \"test_include_2_parent\", \"struct foo_s { int x, y; };\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"struct foo_s *ff2(struct foo_s *);\")\n    lib = verify(ffi, \"test_include_2\",\n                 \"struct foo_s { int x, y; }; //usually from a #include\\n\"\n                 \"struct foo_s *ff2(struct foo_s *p) { p->y++; return p; }\")\n    p = ffi.new(\"struct foo_s *\")\n    p.y = 41\n    q = lib.ff2(p)\n    assert q == p\n    assert p.y == 42\n    assert ffi1.typeof(\"struct foo_s\") is ffi.typeof(\"struct foo_s\")\n\ndef test_include_3():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef short sshort_t;\")\n    verify(ffi1, \"test_include_3_parent\", \"typedef short sshort_t;\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"sshort_t ff3(sshort_t);\")\n    lib = verify(ffi, \"test_include_3\",\n                 \"typedef short sshort_t; //usually from a #include\\n\"\n                 \"sshort_t ff3(sshort_t x) { return (sshort_t)(x + 42); }\")\n    assert lib.ff3(10) == 52\n    assert ffi.typeof(ffi.cast(\"sshort_t\", 42)) is ffi.typeof(\"short\")\n    assert ffi1.typeof(\"sshort_t\") is ffi.typeof(\"sshort_t\")\n\ndef test_include_4():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x; } mystruct_t;\")\n    verify(ffi1, \"test_include_4_parent\",\n           \"typedef struct { int x; } mystruct_t;\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"mystruct_t *ff4(mystruct_t *);\")\n    lib = verify(ffi, \"test_include_4\",\n           \"typedef struct {int x; } mystruct_t; //usually from a #include\\n\"\n           \"mystruct_t *ff4(mystruct_t *p) { p->x += 42; return p; }\")\n    p = ffi.new(\"mystruct_t *\", [10])\n    q = lib.ff4(p)\n    assert q == p\n    assert p.x == 52\n    assert ffi1.typeof(\"mystruct_t\") is ffi.typeof(\"mystruct_t\")\n\ndef test_include_5():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x[2]; int y; } *mystruct_p;\")\n    verify(ffi1, \"test_include_5_parent\",\n           \"typedef struct { int x[2]; int y; } *mystruct_p;\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"mystruct_p ff5(mystruct_p);\")\n    lib = verify(ffi, \"test_include_5\",\n        \"typedef struct {int x[2]; int y; } *mystruct_p; //usually #include\\n\"\n        \"mystruct_p ff5(mystruct_p p) { p->x[1] += 42; return p; }\")\n    assert ffi.alignof(ffi.typeof(\"mystruct_p\").item) == 4\n    assert ffi1.typeof(\"mystruct_p\") is ffi.typeof(\"mystruct_p\")\n    p = ffi.new(\"mystruct_p\", [[5, 10], -17])\n    q = lib.ff5(p)\n    assert q == p\n    assert p.x[0] == 5\n    assert p.x[1] == 52\n    assert p.y == -17\n    assert ffi.alignof(ffi.typeof(p[0])) == 4\n\ndef test_include_6():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef ... mystruct_t;\")\n    verify(ffi1, \"test_include_6_parent\",\n           \"typedef struct _mystruct_s mystruct_t;\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"mystruct_t *ff6(void); int ff6b(mystruct_t *);\")\n    lib = verify(ffi, \"test_include_6\",\n           \"typedef struct _mystruct_s mystruct_t; //usually from a #include\\n\"\n           \"struct _mystruct_s { int x; };\\n\"\n           \"static mystruct_t result_struct = { 42 };\\n\"\n           \"mystruct_t *ff6(void) { return &result_struct; }\\n\"\n           \"int ff6b(mystruct_t *p) { return p->x; }\")\n    p = lib.ff6()\n    assert ffi.cast(\"int *\", p)[0] == 42\n    assert lib.ff6b(p) == 42\n\ndef test_include_7():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef ... mystruct_t;\\n\"\n              \"int ff7b(mystruct_t *);\")\n    verify(ffi1, \"test_include_7_parent\",\n           \"typedef struct { int x; } mystruct_t;\\n\"\n           \"int ff7b(mystruct_t *p) { return p->x; }\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"mystruct_t *ff7(void);\")\n    lib = verify(ffi, \"test_include_7\",\n           \"typedef struct { int x; } mystruct_t; //usually from a #include\\n\"\n           \"static mystruct_t result_struct = { 42 };\"\n           \"mystruct_t *ff7(void) { return &result_struct; }\")\n    p = lib.ff7()\n    assert ffi.cast(\"int *\", p)[0] == 42\n    assert lib.ff7b(p) == 42\n\ndef test_include_8():\n    ffi1 = FFI()\n    ffi1.cdef(\"struct foo_s;\")\n    verify(ffi1, \"test_include_8_parent\", \"struct foo_s;\")\n    ffi = FFI()\n    ffi.include(ffi1)\n    ffi.cdef(\"struct foo_s { int x, y; };\")\n    verify(ffi, \"test_include_8\", \"struct foo_s { int x, y; };\")\n    e = pytest.raises(NotImplementedError, ffi.new, \"struct foo_s *\")\n    assert str(e.value) == (\n        \"'struct foo_s' is opaque in the ffi.include(), but no longer in \"\n        \"the ffi doing the include (workaround: don't use ffi.include() but\"\n        \" duplicate the declarations of everything using struct foo_s)\")\n\ndef test_unicode_libraries():\n    try:\n        unicode\n    except NameError:\n        pytest.skip(\"for python 2.x\")\n    #\n    import math\n    lib_m = \"m\"\n    if sys.platform == 'win32':\n        #there is a small chance this fails on Mingw via environ $CC\n        import distutils.ccompiler\n        if distutils.ccompiler.get_default_compiler() == 'msvc':\n            lib_m = 'msvcrt'\n    ffi = FFI()\n    ffi.cdef(unicode(\"float sin(double); double cos(double);\"))\n    lib = verify(ffi, 'test_math_sin_unicode', unicode('#include <math.h>'),\n                 libraries=[unicode(lib_m)], ignore_warnings=True)\n    assert lib.cos(1.43) == math.cos(1.43)\n\ndef test_incomplete_struct_as_arg():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; int f(int, struct foo_s);\")\n    lib = verify(ffi, \"test_incomplete_struct_as_arg\",\n                 \"struct foo_s { int a, x, z; };\\n\"\n                 \"int f(int b, struct foo_s s) { return s.x * b; }\")\n    s = ffi.new(\"struct foo_s *\", [21])\n    assert s.x == 21\n    assert ffi.sizeof(s[0]) == 12\n    assert ffi.offsetof(ffi.typeof(s), 'x') == 4\n    assert lib.f(2, s[0]) == 42\n    assert ffi.typeof(lib.f) == ffi.typeof(\"int(*)(int, struct foo_s)\")\n\ndef test_incomplete_struct_as_result():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; struct foo_s f(int);\")\n    lib = verify(ffi, \"test_incomplete_struct_as_result\",\n            \"struct foo_s { int a, x, z; };\\n\"\n            \"struct foo_s f(int x) { struct foo_s r; r.x = x * 2; return r; }\")\n    s = lib.f(21)\n    assert s.x == 42\n    assert ffi.typeof(lib.f) == ffi.typeof(\"struct foo_s(*)(int)\")\n\ndef test_incomplete_struct_as_both():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; struct bar_s { int y; ...; };\\n\"\n             \"struct foo_s f(int, struct bar_s);\")\n    lib = verify(ffi, \"test_incomplete_struct_as_both\",\n            \"struct foo_s { int a, x, z; };\\n\"\n            \"struct bar_s { int b, c, y, d; };\\n\"\n            \"struct foo_s f(int x, struct bar_s b) {\\n\"\n            \"  struct foo_s r; r.x = x * b.y; return r;\\n\"\n            \"}\")\n    b = ffi.new(\"struct bar_s *\", [7])\n    s = lib.f(6, b[0])\n    assert s.x == 42\n    assert ffi.typeof(lib.f) == ffi.typeof(\n        \"struct foo_s(*)(int, struct bar_s)\")\n    s = lib.f(14, {'y': -3})\n    assert s.x == -42\n\ndef test_name_of_unnamed_struct():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } foo_t;\\n\"\n             \"typedef struct { int y; } *bar_p;\\n\"\n             \"typedef struct { int y; } **baz_pp;\\n\")\n    verify(ffi, \"test_name_of_unnamed_struct\",\n             \"typedef struct { int x; } foo_t;\\n\"\n             \"typedef struct { int y; } *bar_p;\\n\"\n             \"typedef struct { int y; } **baz_pp;\\n\")\n    assert repr(ffi.typeof(\"foo_t\")) == \"<ctype 'foo_t'>\"\n    assert repr(ffi.typeof(\"bar_p\")) == \"<ctype 'struct $1 *'>\"\n    assert repr(ffi.typeof(\"baz_pp\")) == \"<ctype 'struct $2 * *'>\"\n\ndef test_address_of_global_var():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        extern long bottom, bottoms[2];\n        long FetchRectBottom(void);\n        long FetchRectBottoms1(void);\n        #define FOOBAR 42\n    \"\"\")\n    lib = verify(ffi, \"test_address_of_global_var\", \"\"\"\n        long bottom, bottoms[2];\n        long FetchRectBottom(void) { return bottom; }\n        long FetchRectBottoms1(void) { return bottoms[1]; }\n        #define FOOBAR 42\n    \"\"\")\n    lib.bottom = 300\n    assert lib.FetchRectBottom() == 300\n    lib.bottom += 1\n    assert lib.FetchRectBottom() == 301\n    lib.bottoms[1] = 500\n    assert lib.FetchRectBottoms1() == 500\n    lib.bottoms[1] += 2\n    assert lib.FetchRectBottoms1() == 502\n    #\n    p = ffi.addressof(lib, 'bottom')\n    assert ffi.typeof(p) == ffi.typeof(\"long *\")\n    assert p[0] == 301\n    p[0] += 1\n    assert lib.FetchRectBottom() == 302\n    p = ffi.addressof(lib, 'bottoms')\n    assert ffi.typeof(p) == ffi.typeof(\"long(*)[2]\")\n    assert p[0] == lib.bottoms\n    #\n    pytest.raises(AttributeError, ffi.addressof, lib, 'unknown_var')\n    pytest.raises(AttributeError, ffi.addressof, lib, \"FOOBAR\")\n\ndef test_defines__CFFI_():\n    # Check that we define the macro _CFFI_ automatically.\n    # It should be done before including Python.h, so that PyPy's Python.h\n    # can check for it.\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        #define CORRECT 1\n    \"\"\")\n    lib = verify(ffi, \"test_defines__CFFI_\", \"\"\"\n    #ifdef _CFFI_\n    #    define CORRECT 1\n    #endif\n    \"\"\")\n    assert lib.CORRECT == 1\n\ndef test_unpack_args():\n    ffi = FFI()\n    ffi.cdef(\"void foo0(void); void foo1(int); void foo2(int, int);\")\n    lib = verify(ffi, \"test_unpack_args\", \"\"\"\n    void foo0(void) { }\n    void foo1(int x) { }\n    void foo2(int x, int y) { }\n    \"\"\")\n    assert 'foo0' in repr(lib.foo0)\n    assert 'foo1' in repr(lib.foo1)\n    assert 'foo2' in repr(lib.foo2)\n    lib.foo0()\n    lib.foo1(42)\n    lib.foo2(43, 44)\n    e1 = pytest.raises(TypeError, lib.foo0, 42)\n    e2 = pytest.raises(TypeError, lib.foo0, 43, 44)\n    e3 = pytest.raises(TypeError, lib.foo1)\n    e4 = pytest.raises(TypeError, lib.foo1, 43, 44)\n    e5 = pytest.raises(TypeError, lib.foo2)\n    e6 = pytest.raises(TypeError, lib.foo2, 42)\n    e7 = pytest.raises(TypeError, lib.foo2, 45, 46, 47)\n    def st1(s):\n        s = str(s)\n        if s.startswith(\"_CFFI_test_unpack_args.Lib.\"):\n            s = s[len(\"_CFFI_test_unpack_args.Lib.\"):]\n        return s\n    assert st1(e1.value) == \"foo0() takes no arguments (1 given)\"\n    assert st1(e2.value) == \"foo0() takes no arguments (2 given)\"\n    assert st1(e3.value) == \"foo1() takes exactly one argument (0 given)\"\n    assert st1(e4.value) == \"foo1() takes exactly one argument (2 given)\"\n    assert st1(e5.value) in [\"foo2 expected 2 arguments, got 0\",\n                             \"foo2() takes exactly 2 arguments (0 given)\"]\n    assert st1(e6.value) in [\"foo2 expected 2 arguments, got 1\",\n                             \"foo2() takes exactly 2 arguments (1 given)\"]\n    assert st1(e7.value) in [\"foo2 expected 2 arguments, got 3\",\n                             \"foo2() takes exactly 2 arguments (3 given)\"]\n\ndef test_address_of_function():\n    ffi = FFI()\n    ffi.cdef(\"long myfunc(long x);\")\n    lib = verify(ffi, \"test_addressof_function\", \"\"\"\n        char myfunc(char x) { return (char)(x + 42); }\n    \"\"\", ignore_warnings=True)\n    assert lib.myfunc(5) == 47\n    assert lib.myfunc(0xABC05) == 47\n    assert not isinstance(lib.myfunc, ffi.CData)\n    assert ffi.typeof(lib.myfunc) == ffi.typeof(\"long(*)(long)\")\n    addr = ffi.addressof(lib, 'myfunc')\n    assert addr(5) == 47\n    assert addr(0xABC05) == 47\n    assert isinstance(addr, ffi.CData)\n    assert ffi.typeof(addr) == ffi.typeof(\"long(*)(long)\")\n\ndef test_address_of_function_with_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; }; long myfunc(struct foo_s);\")\n    lib = verify(ffi, \"test_addressof_function_with_struct\", \"\"\"\n        struct foo_s { int x; };\n        char myfunc(struct foo_s input) { return (char)(input.x + 42); }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [5])[0]\n    assert lib.myfunc(s) == 47\n    assert not isinstance(lib.myfunc, ffi.CData)\n    assert ffi.typeof(lib.myfunc) == ffi.typeof(\"long(*)(struct foo_s)\")\n    addr = ffi.addressof(lib, 'myfunc')\n    assert addr(s) == 47\n    assert isinstance(addr, ffi.CData)\n    assert ffi.typeof(addr) == ffi.typeof(\"long(*)(struct foo_s)\")\n\ndef test_issue198():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct{...;} opaque_t;\n        const opaque_t CONSTANT;\n        int toint(opaque_t);\n    \"\"\")\n    lib = verify(ffi, 'test_issue198', \"\"\"\n        typedef int opaque_t;\n        #define CONSTANT ((opaque_t)42)\n        static int toint(opaque_t o) { return o; }\n    \"\"\")\n    def random_stuff():\n        pass\n    assert lib.toint(lib.CONSTANT) == 42\n    random_stuff()\n    assert lib.toint(lib.CONSTANT) == 42\n\ndef test_constant_is_not_a_compiler_constant():\n    ffi = FFI()\n    ffi.cdef(\"static const float almost_forty_two;\")\n    lib = verify(ffi, 'test_constant_is_not_a_compiler_constant', \"\"\"\n        static float f(void) { return 42.25; }\n        #define almost_forty_two (f())\n    \"\"\")\n    assert lib.almost_forty_two == 42.25\n\ndef test_constant_of_unknown_size():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... opaque_t;\n        const opaque_t CONSTANT;\n    \"\"\")\n    lib = verify(ffi, 'test_constant_of_unknown_size',\n                 \"typedef int opaque_t;\"\n                 \"const int CONSTANT = 42;\")\n    e = pytest.raises(ffi.error, getattr, lib, 'CONSTANT')\n    assert str(e.value) == (\"constant 'CONSTANT' is of \"\n                            \"type 'opaque_t', whose size is not known\")\n\ndef test_variable_of_unknown_size():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... opaque_t;\n        extern opaque_t globvar;\n    \"\"\")\n    lib = verify(ffi, 'test_variable_of_unknown_size', \"\"\"\n        typedef char opaque_t[6];\n        opaque_t globvar = \"hello\";\n    \"\"\")\n    # can't read or write it at all\n    e = pytest.raises(TypeError, getattr, lib, 'globvar')\n    assert str(e.value) in [\"cdata 'opaque_t' is opaque\",\n                            \"'opaque_t' is opaque or not completed yet\"] #pypy\n    e = pytest.raises(TypeError, setattr, lib, 'globvar', [])\n    assert str(e.value) in [\"'opaque_t' is opaque\",\n                            \"'opaque_t' is opaque or not completed yet\"] #pypy\n    # but we can get its address\n    p = ffi.addressof(lib, 'globvar')\n    assert ffi.typeof(p) == ffi.typeof('opaque_t *')\n    assert ffi.string(ffi.cast(\"char *\", p), 8) == b\"hello\"\n\ndef test_constant_of_value_unknown_to_the_compiler():\n    extra_c_source = udir.join(\n        'extra_test_constant_of_value_unknown_to_the_compiler.c')\n    extra_c_source.write('const int external_foo = 42;\\n')\n    ffi = FFI()\n    ffi.cdef(\"const int external_foo;\")\n    lib = verify(ffi, 'test_constant_of_value_unknown_to_the_compiler', \"\"\"\n        extern const int external_foo;\n    \"\"\", sources=[str(extra_c_source)])\n    assert lib.external_foo == 42\n\ndef test_dotdot_in_source_file_names():\n    extra_c_source = udir.join(\n        'extra_test_dotdot_in_source_file_names.c')\n    extra_c_source.write('const int external_foo = 42;\\n')\n    ffi = FFI()\n    ffi.cdef(\"const int external_foo;\")\n    lib = verify(ffi, 'test_dotdot_in_source_file_names', \"\"\"\n        extern const int external_foo;\n    \"\"\", sources=[os.path.join(os.path.dirname(str(extra_c_source)),\n                               'foobar', '..',\n                               os.path.basename(str(extra_c_source)))])\n    assert lib.external_foo == 42\n\ndef test_call_with_incomplete_structs():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct {...;} foo_t; \"\n             \"extern foo_t myglob; \"\n             \"foo_t increment(foo_t s); \"\n             \"double getx(foo_t s);\")\n    lib = verify(ffi, 'test_call_with_incomplete_structs', \"\"\"\n        typedef double foo_t;\n        double myglob = 42.5;\n        double getx(double x) { return x; }\n        double increment(double x) { return x + 1; }\n    \"\"\")\n    assert lib.getx(lib.myglob) == 42.5\n    assert lib.getx(lib.increment(lib.myglob)) == 43.5\n\ndef test_struct_array_guess_length_2():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...][...]; };\")\n    lib = verify(ffi, 'test_struct_array_guess_length_2',\n                 \"struct foo_s { int x; int a[5][8]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 42 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) == ffi.typeof(\"int[5][8]\")\n    assert ffi.sizeof(s.a) == 40 * ffi.sizeof('int')\n    assert s.a[4][7] == 0\n    with pytest.raises(IndexError):\n        s.a[4][8]\n    with pytest.raises(IndexError):\n        s.a[5][0]\n    assert ffi.typeof(s.a) == ffi.typeof(\"int[5][8]\")\n    assert ffi.typeof(s.a[0]) == ffi.typeof(\"int[8]\")\n\ndef test_struct_array_guess_length_3():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[][...]; };\")\n    lib = verify(ffi, 'test_struct_array_guess_length_3',\n                 \"struct foo_s { int x; int a[5][7]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 37 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) == ffi.typeof(\"int[][7]\")\n    assert s.a[4][6] == 0\n    with pytest.raises(IndexError):\n        s.a[4][7]\n    assert ffi.typeof(s.a[0]) == ffi.typeof(\"int[7]\")\n\ndef test_global_var_array_2():\n    ffi = FFI()\n    ffi.cdef(\"extern int a[...][...];\")\n    lib = verify(ffi, 'test_global_var_array_2', 'int a[10][8];')\n    lib.a[9][7] = 123456\n    assert lib.a[9][7] == 123456\n    with pytest.raises(IndexError):\n        lib.a[0][8]\n    with pytest.raises(IndexError):\n        lib.a[10][0]\n    assert ffi.typeof(lib.a) == ffi.typeof(\"int[10][8]\")\n    assert ffi.typeof(lib.a[0]) == ffi.typeof(\"int[8]\")\n\ndef test_global_var_array_3():\n    ffi = FFI()\n    ffi.cdef(\"extern int a[][...];\")\n    lib = verify(ffi, 'test_global_var_array_3', 'int a[10][8];')\n    lib.a[9][7] = 123456\n    assert lib.a[9][7] == 123456\n    with pytest.raises(IndexError):\n        lib.a[0][8]\n    assert ffi.typeof(lib.a) == ffi.typeof(\"int(*)[8]\")\n    assert ffi.typeof(lib.a[0]) == ffi.typeof(\"int[8]\")\n\ndef test_global_var_array_4():\n    ffi = FFI()\n    ffi.cdef(\"extern int a[10][...];\")\n    lib = verify(ffi, 'test_global_var_array_4', 'int a[10][8];')\n    lib.a[9][7] = 123456\n    assert lib.a[9][7] == 123456\n    with pytest.raises(IndexError):\n        lib.a[0][8]\n    with pytest.raises(IndexError):\n        lib.a[10][8]\n    assert ffi.typeof(lib.a) == ffi.typeof(\"int[10][8]\")\n    assert ffi.typeof(lib.a[0]) == ffi.typeof(\"int[8]\")\n\ndef test_some_integer_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef int... foo_t;\n        typedef unsigned long... bar_t;\n        typedef struct { foo_t a, b; } mystruct_t;\n        foo_t foobar(bar_t, mystruct_t);\n        static const bar_t mu = -20;\n        static const foo_t nu = 20;\n    \"\"\")\n    lib = verify(ffi, 'test_some_integer_type', \"\"\"\n        typedef unsigned long long foo_t;\n        typedef short bar_t;\n        typedef struct { foo_t a, b; } mystruct_t;\n        static foo_t foobar(bar_t x, mystruct_t s) {\n            return (foo_t)x + s.a + s.b;\n        }\n        static const bar_t mu = -20;\n        static const foo_t nu = 20;\n    \"\"\")\n    assert ffi.sizeof(\"foo_t\") == ffi.sizeof(\"unsigned long long\")\n    assert ffi.sizeof(\"bar_t\") == ffi.sizeof(\"short\")\n    maxulonglong = 2 ** 64 - 1\n    assert int(ffi.cast(\"foo_t\", -1)) == maxulonglong\n    assert int(ffi.cast(\"bar_t\", -1)) == -1\n    assert lib.foobar(-1, [0, 0]) == maxulonglong\n    assert lib.foobar(2 ** 15 - 1, [0, 0]) == 2 ** 15 - 1\n    assert lib.foobar(10, [20, 31]) == 61\n    assert lib.foobar(0, [0, maxulonglong]) == maxulonglong\n    pytest.raises(OverflowError, lib.foobar, 2 ** 15, [0, 0])\n    pytest.raises(OverflowError, lib.foobar, -(2 ** 15) - 1, [0, 0])\n    pytest.raises(OverflowError, ffi.new, \"mystruct_t *\", [0, -1])\n    assert lib.mu == -20\n    assert lib.nu == 20\n\ndef test_some_float_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef double... foo_t;\n        typedef float... bar_t;\n        foo_t sum(foo_t[]);\n        bar_t neg(bar_t);\n        \"\"\")\n    lib = verify(ffi, 'test_some_float_type', \"\"\"\n        typedef float foo_t;\n        static foo_t sum(foo_t x[]) { return x[0] + x[1]; }\n        typedef double bar_t;\n        static double neg(double x) { return -x; }\n    \"\"\")\n    assert lib.sum([40.0, 2.25]) == 42.25\n    assert lib.sum([12.3, 45.6]) != 12.3 + 45.6     # precision loss\n    assert lib.neg(12.3) == -12.3                   # no precision loss\n    assert ffi.sizeof(\"foo_t\") == ffi.sizeof(\"float\")\n    assert ffi.sizeof(\"bar_t\") == ffi.sizeof(\"double\")\n\ndef test_some_float_invalid_1():\n    ffi = FFI()\n    pytest.raises((FFIError,      # with pycparser <= 2.17\n                    CDefError),    # with pycparser >= 2.18\n                   ffi.cdef, \"typedef long double... foo_t;\")\n\ndef test_some_float_invalid_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef double... foo_t; foo_t neg(foo_t);\")\n    lib = verify(ffi, 'test_some_float_invalid_2', \"\"\"\n        typedef unsigned long foo_t;\n        foo_t neg(foo_t x) { return -x; }\n    \"\"\")\n    e = pytest.raises(ffi.error, getattr, lib, 'neg')\n    assert str(e.value) == (\"primitive floating-point type with an unexpected \"\n                            \"size (or not a float type at all)\")\n\ndef test_some_float_invalid_3():\n    ffi = FFI()\n    ffi.cdef(\"typedef double... foo_t; foo_t neg(foo_t);\")\n    lib = verify(ffi, 'test_some_float_invalid_3', \"\"\"\n        typedef long double foo_t;\n        foo_t neg(foo_t x) { return -x; }\n    \"\"\", ignore_warnings=True)\n    if ffi.sizeof(\"long double\") == ffi.sizeof(\"double\"):\n        assert lib.neg(12.3) == -12.3\n    else:\n        e = pytest.raises(ffi.error, getattr, lib, 'neg')\n        assert str(e.value) == (\"primitive floating-point type is \"\n                                \"'long double', not supported for now with \"\n                                \"the syntax 'typedef double... xxx;'\")\n\ndef test_issue200():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef void (function_t)(void*);\n        void function(void *);\n    \"\"\")\n    lib = verify(ffi, 'test_issue200', \"\"\"\n        static void function(void *p) { (void)p; }\n    \"\"\")\n    ffi.typeof('function_t*')\n    lib.function(ffi.NULL)\n    # assert did not crash\n\ndef test_alignment_of_longlong():\n    ffi = FFI()\n    x1 = ffi.alignof('unsigned long long')\n    assert x1 in [4, 8]\n    ffi.cdef(\"struct foo_s { unsigned long long x; };\")\n    lib = verify(ffi, 'test_alignment_of_longlong',\n                 \"struct foo_s { unsigned long long x; };\")\n    assert ffi.alignof('unsigned long long') == x1\n    assert ffi.alignof('struct foo_s') == x1\n\ndef test_import_from_lib():\n    ffi = FFI()\n    ffi.cdef(\"int mybar(int); static int myvar;\\n#define MYFOO ...\")\n    lib = verify(ffi, 'test_import_from_lib',\n                 \"#define MYFOO 42\\n\"\n                 \"static int mybar(int x) { return x + 1; }\\n\"\n                 \"static int myvar = -5;\")\n    assert sys.modules['_CFFI_test_import_from_lib'].lib is lib\n    assert sys.modules['_CFFI_test_import_from_lib.lib'] is lib\n    from _CFFI_test_import_from_lib.lib import MYFOO\n    assert MYFOO == 42\n    assert hasattr(lib, '__dict__')\n    assert lib.__all__ == ['MYFOO', 'mybar']   # but not 'myvar'\n    assert lib.__name__ == '_CFFI_test_import_from_lib.lib'\n    assert lib.__class__ is type(sys)   # !! hack for help()\n\ndef test_macro_var_callback():\n    ffi = FFI()\n    ffi.cdef(\"extern int my_value; extern int *(*get_my_value)(void);\")\n    lib = verify(ffi, 'test_macro_var_callback',\n                 \"int *(*get_my_value)(void);\\n\"\n                 \"#define my_value (*get_my_value())\")\n    #\n    values = ffi.new(\"int[50]\")\n    def it():\n        for i in range(50):\n            yield i\n    it = it()\n    #\n    @ffi.callback(\"int *(*)(void)\")\n    def get_my_value():\n        for nextvalue in it:\n            return values + nextvalue\n    lib.get_my_value = get_my_value\n    #\n    values[0] = 41\n    assert lib.my_value == 41            # [0]\n    p = ffi.addressof(lib, 'my_value')   # [1]\n    assert p == values + 1\n    assert p[-1] == 41\n    assert p[+1] == 0\n    lib.my_value = 42                    # [2]\n    assert values[2] == 42\n    assert p[-1] == 41\n    assert p[+1] == 42\n    #\n    # if get_my_value raises or returns nonsense, the exception is printed\n    # to stderr like with any callback, but then the C expression 'my_value'\n    # expand to '*NULL'.  We assume here that '&my_value' will return NULL\n    # without segfaulting, and check for NULL when accessing the variable.\n    @ffi.callback(\"int *(*)(void)\")\n    def get_my_value():\n        raise LookupError\n    lib.get_my_value = get_my_value\n    pytest.raises(ffi.error, getattr, lib, 'my_value')\n    pytest.raises(ffi.error, setattr, lib, 'my_value', 50)\n    pytest.raises(ffi.error, ffi.addressof, lib, 'my_value')\n    @ffi.callback(\"int *(*)(void)\")\n    def get_my_value():\n        return \"hello\"\n    lib.get_my_value = get_my_value\n    pytest.raises(ffi.error, getattr, lib, 'my_value')\n    e = pytest.raises(ffi.error, setattr, lib, 'my_value', 50)\n    assert str(e.value) == \"global variable 'my_value' is at address NULL\"\n\ndef test_const_fields():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { const int a; void *const b; };\"\"\")\n    lib = verify(ffi, 'test_const_fields', \"\"\"\n        struct foo_s { const int a; void *const b; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'a'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"int\")\n    assert foo_s.fields[1][0] == 'b'\n    assert foo_s.fields[1][1].type is ffi.typeof(\"void *\")\n\ndef test_restrict_fields():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { void * restrict b; };\"\"\")\n    lib = verify(ffi, 'test_restrict_fields', \"\"\"\n        struct foo_s { void * __restrict b; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'b'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"void *\")\n\ndef test_volatile_fields():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { void * volatile b; };\"\"\")\n    lib = verify(ffi, 'test_volatile_fields', \"\"\"\n        struct foo_s { void * volatile b; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'b'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"void *\")\n\ndef test_const_array_fields():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { const int a[4]; };\"\"\")\n    lib = verify(ffi, 'test_const_array_fields', \"\"\"\n        struct foo_s { const int a[4]; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'a'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"int[4]\")\n\ndef test_const_array_fields_varlength():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { const int a[]; ...; };\"\"\")\n    lib = verify(ffi, 'test_const_array_fields_varlength', \"\"\"\n        struct foo_s { const int a[4]; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'a'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"int[]\")\n\ndef test_const_array_fields_unknownlength():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { const int a[...]; ...; };\"\"\")\n    lib = verify(ffi, 'test_const_array_fields_unknownlength', \"\"\"\n        struct foo_s { const int a[4]; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'a'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"int[4]\")\n\ndef test_const_function_args():\n    ffi = FFI()\n    ffi.cdef(\"\"\"int foobar(const int a, const int *b, const int c[]);\"\"\")\n    lib = verify(ffi, 'test_const_function_args', \"\"\"\n        int foobar(const int a, const int *b, const int c[]) {\n            return a + *b + *c;\n        }\n    \"\"\")\n    assert lib.foobar(100, ffi.new(\"int *\", 40), ffi.new(\"int *\", 2)) == 142\n\ndef test_const_function_type_args():\n    ffi = FFI()\n    ffi.cdef(\"\"\"extern int(*foobar)(const int a,const int*b,const int c[]);\"\"\")\n    lib = verify(ffi, 'test_const_function_type_args', \"\"\"\n        int (*foobar)(const int a, const int *b, const int c[]);\n    \"\"\")\n    t = ffi.typeof(lib.foobar)\n    assert t.args[0] is ffi.typeof(\"int\")\n    assert t.args[1] is ffi.typeof(\"int *\")\n    assert t.args[2] is ffi.typeof(\"int *\")\n\ndef test_const_constant():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { int x,y; }; const struct foo_s myfoo;\"\"\")\n    lib = verify(ffi, 'test_const_constant', \"\"\"\n        struct foo_s { int x,y; }; const struct foo_s myfoo = { 40, 2 };\n    \"\"\")\n    assert lib.myfoo.x == 40\n    assert lib.myfoo.y == 2\n\ndef test_const_via_typedef():\n    ffi = FFI()\n    ffi.cdef(\"\"\"typedef const int const_t; const_t aaa;\"\"\")\n    lib = verify(ffi, 'test_const_via_typedef', \"\"\"\n        typedef const int const_t;\n        #define aaa 42\n    \"\"\")\n    assert lib.aaa == 42\n    with pytest.raises(AttributeError):\n        lib.aaa = 43\n\ndef test_win32_calling_convention_0():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int call1(int(__cdecl   *cb)(int));\n        int (*const call2)(int(__stdcall *cb)(int));\n    \"\"\")\n    lib = verify(ffi, 'test_win32_calling_convention_0', r\"\"\"\n        #ifndef _MSC_VER\n        #  define __stdcall  /* nothing */\n        #endif\n        int call1(int(*cb)(int)) {\n            int i, result = 0;\n            //printf(\"call1: cb = %p\\n\", cb);\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n        int call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            //printf(\"call2: cb = %p\\n\", cb);\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n    \"\"\")\n    @ffi.callback(\"int(int)\")\n    def cb1(x):\n        return x * 2\n    @ffi.callback(\"int __stdcall(int)\")\n    def cb2(x):\n        return x * 3\n    res = lib.call1(cb1)\n    assert res == 500*999*2\n    assert res == ffi.addressof(lib, 'call1')(cb1)\n    res = lib.call2(cb2)\n    assert res == -500*999*3\n    assert res == ffi.addressof(lib, 'call2')(cb2)\n    if sys.platform == 'win32' and not sys.maxsize > 2**32:\n        assert '__stdcall' in str(ffi.typeof(cb2))\n        assert '__stdcall' not in str(ffi.typeof(cb1))\n        pytest.raises(TypeError, lib.call1, cb2)\n        pytest.raises(TypeError, lib.call2, cb1)\n    else:\n        assert '__stdcall' not in str(ffi.typeof(cb2))\n        assert ffi.typeof(cb2) is ffi.typeof(cb1)\n\ndef test_win32_calling_convention_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int __cdecl   call1(int(__cdecl   *cb)(int));\n        int __stdcall call2(int(__stdcall *cb)(int));\n        int (__cdecl   *const cb1)(int);\n        int (__stdcall *const cb2)(int);\n    \"\"\")\n    lib = verify(ffi, 'test_win32_calling_convention_1', r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        int __cdecl   cb1(int x) { return x * 2; }\n        int __stdcall cb2(int x) { return x * 3; }\n\n        int __cdecl call1(int(__cdecl *cb)(int)) {\n            int i, result = 0;\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb1 = %p\\n\", cb, (void *)cb1);\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n        int __stdcall call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb2 = %p\\n\", cb, (void *)cb2);\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n    \"\"\")\n    #print '<<< cb1 =', ffi.addressof(lib, 'cb1')\n    ptr_call1 = ffi.addressof(lib, 'call1')\n    assert lib.call1(ffi.addressof(lib, 'cb1')) == 500*999*2\n    assert ptr_call1(ffi.addressof(lib, 'cb1')) == 500*999*2\n    #print '<<< cb2 =', ffi.addressof(lib, 'cb2')\n    ptr_call2 = ffi.addressof(lib, 'call2')\n    assert lib.call2(ffi.addressof(lib, 'cb2')) == -500*999*3\n    assert ptr_call2(ffi.addressof(lib, 'cb2')) == -500*999*3\n    #print '<<< done'\n\ndef test_win32_calling_convention_2():\n    # any mistake in the declaration of plain function (including the\n    # precise argument types and, here, the calling convention) are\n    # automatically corrected.  But this does not apply to the 'cb'\n    # function pointer argument.\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int __stdcall call1(int(__cdecl   *cb)(int));\n        int __cdecl   call2(int(__stdcall *cb)(int));\n        int (__cdecl   *const cb1)(int);\n        int (__stdcall *const cb2)(int);\n    \"\"\")\n    lib = verify(ffi, 'test_win32_calling_convention_2', \"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        int __cdecl call1(int(__cdecl *cb)(int)) {\n            int i, result = 0;\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            return result;\n        }\n        int __stdcall call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            return result;\n        }\n        int __cdecl   cb1(int x) { return x * 2; }\n        int __stdcall cb2(int x) { return x * 3; }\n    \"\"\")\n    ptr_call1 = ffi.addressof(lib, 'call1')\n    ptr_call2 = ffi.addressof(lib, 'call2')\n    if sys.platform == 'win32' and not sys.maxsize > 2**32:\n        pytest.raises(TypeError, lib.call1, ffi.addressof(lib, 'cb2'))\n        pytest.raises(TypeError, ptr_call1, ffi.addressof(lib, 'cb2'))\n        pytest.raises(TypeError, lib.call2, ffi.addressof(lib, 'cb1'))\n        pytest.raises(TypeError, ptr_call2, ffi.addressof(lib, 'cb1'))\n    assert lib.call1(ffi.addressof(lib, 'cb1')) == 500*999*2\n    assert ptr_call1(ffi.addressof(lib, 'cb1')) == 500*999*2\n    assert lib.call2(ffi.addressof(lib, 'cb2')) == -500*999*3\n    assert ptr_call2(ffi.addressof(lib, 'cb2')) == -500*999*3\n\ndef test_win32_calling_convention_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point { int x, y; };\n\n        int (*const cb1)(struct point);\n        int (__stdcall *const cb2)(struct point);\n\n        struct point __stdcall call1(int(*cb)(struct point));\n        struct point call2(int(__stdcall *cb)(struct point));\n    \"\"\")\n    lib = verify(ffi, 'test_win32_calling_convention_3', r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        struct point { int x, y; };\n        int           cb1(struct point pt) { return pt.x + 10 * pt.y; }\n        int __stdcall cb2(struct point pt) { return pt.x + 100 * pt.y; }\n        struct point __stdcall call1(int(__cdecl *cb)(struct point)) {\n            int i;\n            struct point result = { 0, 0 };\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb1 = %p\\n\", cb, (void *)cb1);\n            for (i = 0; i < 1000; i++) {\n                struct point p = { i, -i };\n                int r = cb(p);\n                result.x += r;\n                result.y -= r;\n            }\n            return result;\n        }\n        struct point __cdecl call2(int(__stdcall *cb)(struct point)) {\n            int i;\n            struct point result = { 0, 0 };\n            for (i = 0; i < 1000; i++) {\n                struct point p = { -i, i };\n                int r = cb(p);\n                result.x += r;\n                result.y -= r;\n            }\n            return result;\n        }\n    \"\"\")\n    ptr_call1 = ffi.addressof(lib, 'call1')\n    ptr_call2 = ffi.addressof(lib, 'call2')\n    if sys.platform == 'win32' and not sys.maxsize > 2**32:\n        pytest.raises(TypeError, lib.call1, ffi.addressof(lib, 'cb2'))\n        pytest.raises(TypeError, ptr_call1, ffi.addressof(lib, 'cb2'))\n        pytest.raises(TypeError, lib.call2, ffi.addressof(lib, 'cb1'))\n        pytest.raises(TypeError, ptr_call2, ffi.addressof(lib, 'cb1'))\n    pt = lib.call1(ffi.addressof(lib, 'cb1'))\n    assert (pt.x, pt.y) == (-9*500*999, 9*500*999)\n    pt = ptr_call1(ffi.addressof(lib, 'cb1'))\n    assert (pt.x, pt.y) == (-9*500*999, 9*500*999)\n    pt = lib.call2(ffi.addressof(lib, 'cb2'))\n    assert (pt.x, pt.y) == (99*500*999, -99*500*999)\n    pt = ptr_call2(ffi.addressof(lib, 'cb2'))\n    assert (pt.x, pt.y) == (99*500*999, -99*500*999)\n\ndef test_extern_python_1():\n    import warnings\n    ffi = FFI()\n    with warnings.catch_warnings(record=True) as log:\n        ffi.cdef(\"\"\"\n        extern \"Python\" {\n            int bar(int, int);\n            void baz(int, int);\n            int bok(void);\n            void boz(void);\n        }\n        \"\"\")\n    assert len(log) == 0, \"got a warning: %r\" % (log,)\n    lib = verify(ffi, 'test_extern_python_1', \"\"\"\n        static void baz(int, int);   /* forward */\n    \"\"\")\n    assert ffi.typeof(lib.bar) == ffi.typeof(\"int(*)(int, int)\")\n    with FdWriteCapture() as f:\n        res = lib.bar(4, 5)\n    assert res == 0\n    assert f.getvalue() == (\n        b\"extern \\\"Python\\\": function _CFFI_test_extern_python_1.bar() called, \"\n        b\"but no code was attached \"\n        b\"to it yet with @ffi.def_extern().  Returning 0.\\n\")\n\n    @ffi.def_extern(\"bar\")\n    def my_bar(x, y):\n        seen.append((\"Bar\", x, y))\n        return x * y\n    assert my_bar != lib.bar\n    seen = []\n    res = lib.bar(6, 7)\n    assert seen == [(\"Bar\", 6, 7)]\n    assert res == 42\n\n    def baz(x, y):\n        seen.append((\"Baz\", x, y))\n    baz1 = ffi.def_extern()(baz)\n    assert baz1 is baz\n    seen = []\n    baz(long(40), long(4))\n    res = lib.baz(long(50), long(8))\n    assert res is None\n    assert seen == [(\"Baz\", 40, 4), (\"Baz\", 50, 8)]\n    assert type(seen[0][1]) is type(seen[0][2]) is long\n    assert type(seen[1][1]) is type(seen[1][2]) is int\n\n    @ffi.def_extern(name=\"bok\")\n    def bokk():\n        seen.append(\"Bok\")\n        return 42\n    seen = []\n    assert lib.bok() == 42\n    assert seen == [\"Bok\"]\n\n    @ffi.def_extern()\n    def boz():\n        seen.append(\"Boz\")\n    seen = []\n    assert lib.boz() is None\n    assert seen == [\"Boz\"]\n\ndef test_extern_python_bogus_name():\n    ffi = FFI()\n    ffi.cdef(\"extern int abc;\")\n    lib = verify(ffi, 'test_extern_python_bogus_name', \"int abc;\")\n    def fn():\n        pass\n    pytest.raises(ffi.error, ffi.def_extern(\"unknown_name\"), fn)\n    pytest.raises(ffi.error, ffi.def_extern(\"abc\"), fn)\n    assert lib.abc == 0\n    e = pytest.raises(ffi.error, ffi.def_extern(\"abc\"), fn)\n    assert str(e.value) == (\"ffi.def_extern('abc'): no 'extern \\\"Python\\\"' \"\n                            \"function with this name\")\n    e = pytest.raises(ffi.error, ffi.def_extern(), fn)\n    assert str(e.value) == (\"ffi.def_extern('fn'): no 'extern \\\"Python\\\"' \"\n                            \"function with this name\")\n    #\n    pytest.raises(TypeError, ffi.def_extern(42), fn)\n    pytest.raises((TypeError, AttributeError), ffi.def_extern(), \"foo\")\n    class X:\n        pass\n    x = X()\n    x.__name__ = x\n    pytest.raises(TypeError, ffi.def_extern(), x)\n\ndef test_extern_python_bogus_result_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"extern \"Python\" void bar(int);\"\"\")\n    lib = verify(ffi, 'test_extern_python_bogus_result_type', \"\")\n    #\n    @ffi.def_extern()\n    def bar(n):\n        return n * 10\n    with StdErrCapture() as f:\n        res = lib.bar(321)\n    assert res is None\n    msg = f.getvalue()\n    assert \"rom cffi callback %r\" % (bar,) in msg\n    assert \"rying to convert the result back to C:\\n\" in msg\n    assert msg.endswith(\n        \"TypeError: callback with the return type 'void' must return None\\n\")\n\ndef test_extern_python_redefine():\n    ffi = FFI()\n    ffi.cdef(\"\"\"extern \"Python\" int bar(int);\"\"\")\n    lib = verify(ffi, 'test_extern_python_redefine', \"\")\n    #\n    @ffi.def_extern()\n    def bar(n):\n        return n * 10\n    assert lib.bar(42) == 420\n    #\n    @ffi.def_extern()\n    def bar(n):\n        return -n\n    assert lib.bar(42) == -42\n\ndef test_extern_python_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { int a, b, c; };\n        extern \"Python\" int bar(int, struct foo_s, int);\n        extern \"Python\" { struct foo_s baz(int, int);\n                          struct foo_s bok(void); }\n    \"\"\")\n    lib = verify(ffi, 'test_extern_python_struct',\n                 \"struct foo_s { int a, b, c; };\")\n    #\n    @ffi.def_extern()\n    def bar(x, s, z):\n        return x + s.a + s.b + s.c + z\n    res = lib.bar(1000, [1001, 1002, 1004], 1008)\n    assert res == 5015\n    #\n    @ffi.def_extern()\n    def baz(x, y):\n        return [x + y, x - y, x * y]\n    res = lib.baz(1000, 42)\n    assert res.a == 1042\n    assert res.b == 958\n    assert res.c == 42000\n    #\n    @ffi.def_extern()\n    def bok():\n        return [10, 20, 30]\n    res = lib.bok()\n    assert [res.a, res.b, res.c] == [10, 20, 30]\n\ndef test_extern_python_long_double():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        extern \"Python\" int bar(int, long double, int);\n        extern \"Python\" long double baz(int, int);\n        extern \"Python\" long double bok(void);\n    \"\"\")\n    lib = verify(ffi, 'test_extern_python_long_double', \"\")\n    #\n    @ffi.def_extern()\n    def bar(x, l, z):\n        seen.append((x, l, z))\n        return 6\n    seen = []\n    lib.bar(10, 3.5, 20)\n    expected = ffi.cast(\"long double\", 3.5)\n    assert repr(seen) == repr([(10, expected, 20)])\n    #\n    @ffi.def_extern()\n    def baz(x, z):\n        assert x == 10 and z == 20\n        return expected\n    res = lib.baz(10, 20)\n    assert repr(res) == repr(expected)\n    #\n    @ffi.def_extern()\n    def bok():\n        return expected\n    res = lib.bok()\n    assert repr(res) == repr(expected)\n\ndef test_extern_python_signature():\n    ffi = FFI()\n    lib = verify(ffi, 'test_extern_python_signature', \"\")\n    pytest.raises(TypeError, ffi.def_extern(425), None)\n    pytest.raises(TypeError, ffi.def_extern, 'a', 'b', 'c', 'd')\n\ndef test_extern_python_errors():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        extern \"Python\" int bar(int);\n    \"\"\")\n    lib = verify(ffi, 'test_extern_python_errors', \"\")\n\n    seen = []\n    def oops(*args):\n        seen.append(args)\n\n    @ffi.def_extern(onerror=oops)\n    def bar(x):\n        return x + \"\"\n    assert lib.bar(10) == 0\n\n    @ffi.def_extern(name=\"bar\", onerror=oops, error=-66)\n    def bar2(x):\n        return x + \"\"\n    assert lib.bar(10) == -66\n\n    assert len(seen) == 2\n    exc, val, tb = seen[0]\n    assert exc is TypeError\n    assert isinstance(val, TypeError)\n    assert tb.tb_frame.f_code.co_name == \"bar\"\n    exc, val, tb = seen[1]\n    assert exc is TypeError\n    assert isinstance(val, TypeError)\n    assert tb.tb_frame.f_code.co_name == \"bar2\"\n    #\n    # a case where 'onerror' is not callable\n    pytest.raises(TypeError, ffi.def_extern(name='bar', onerror=42),\n                   lambda x: x)\n\ndef test_extern_python_stdcall():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        extern \"Python\" int __stdcall foo(int);\n        extern \"Python\" int WINAPI bar(int);\n        static int (__stdcall * mycb1)(int);\n        static int indirect_call(int);\n    \"\"\")\n    lib = verify(ffi, 'test_extern_python_stdcall', \"\"\"\n        #ifndef _MSC_VER\n        #  define __stdcall\n        #endif\n        static int (__stdcall * mycb1)(int);\n        static int indirect_call(int x) {\n            return mycb1(x);\n        }\n    \"\"\")\n    #\n    @ffi.def_extern()\n    def foo(x):\n        return x + 42\n    @ffi.def_extern()\n    def bar(x):\n        return x + 43\n    assert lib.foo(100) == 142\n    assert lib.bar(100) == 143\n    lib.mycb1 = lib.foo\n    assert lib.mycb1(200) == 242\n    assert lib.indirect_call(300) == 342\n\ndef test_extern_python_plus_c():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        extern \"Python+C\" int foo(int);\n        extern \"C +\\tPython\" int bar(int);\n        int call_me(int);\n    \"\"\")\n    lib = verify(ffi, 'test_extern_python_plus_c', \"\"\"\n        int foo(int);\n        #ifdef __GNUC__\n        __attribute__((visibility(\"hidden\")))\n        #endif\n        int bar(int);\n\n        static int call_me(int x) {\n            return foo(x) - bar(x);\n        }\n    \"\"\")\n    #\n    @ffi.def_extern()\n    def foo(x):\n        return x * 42\n    @ffi.def_extern()\n    def bar(x):\n        return x * 63\n    assert lib.foo(100) == 4200\n    assert lib.bar(100) == 6300\n    assert lib.call_me(100) == -2100\n\ndef test_introspect_function():\n    ffi = FFI()\n    ffi.cdef(\"float f1(double);\")\n    lib = verify(ffi, 'test_introspect_function', \"\"\"\n        float f1(double x) { return (float)x; }\n    \"\"\")\n    assert dir(lib) == ['f1']\n    FUNC = ffi.typeof(lib.f1)\n    assert FUNC.kind == 'function'\n    assert FUNC.args[0].cname == 'double'\n    assert FUNC.result.cname == 'float'\n    assert ffi.typeof(ffi.addressof(lib, 'f1')) is FUNC\n\ndef test_introspect_global_var():\n    ffi = FFI()\n    ffi.cdef(\"extern float g1;\")\n    lib = verify(ffi, 'test_introspect_global_var', \"\"\"\n        float g1;\n    \"\"\")\n    assert dir(lib) == ['g1']\n    FLOATPTR = ffi.typeof(ffi.addressof(lib, 'g1'))\n    assert FLOATPTR.kind == 'pointer'\n    assert FLOATPTR.item.cname == 'float'\n\ndef test_introspect_global_var_array():\n    ffi = FFI()\n    ffi.cdef(\"extern float g1[100];\")\n    lib = verify(ffi, 'test_introspect_global_var_array', \"\"\"\n        float g1[100];\n    \"\"\")\n    assert dir(lib) == ['g1']\n    FLOATARRAYPTR = ffi.typeof(ffi.addressof(lib, 'g1'))\n    assert FLOATARRAYPTR.kind == 'pointer'\n    assert FLOATARRAYPTR.item.kind == 'array'\n    assert FLOATARRAYPTR.item.length == 100\n    assert ffi.typeof(lib.g1) is FLOATARRAYPTR.item\n\ndef test_introspect_integer_const():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 42\")\n    lib = verify(ffi, 'test_introspect_integer_const', \"\"\"\n        #define FOO 42\n    \"\"\")\n    assert dir(lib) == ['FOO']\n    assert lib.FOO == ffi.integer_const('FOO') == 42\n\ndef test_introspect_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int foo_t;\")\n    lib = verify(ffi, 'test_introspect_typedef', \"\"\"\n        typedef int foo_t;\n    \"\"\")\n    assert ffi.list_types() == (['foo_t'], [], [])\n    assert ffi.typeof('foo_t').kind == 'primitive'\n    assert ffi.typeof('foo_t').cname == 'int'\n\ndef test_introspect_typedef_multiple():\n    ffi = FFI()\n    ffi.cdef(\"typedef signed char a_t, c_t, g_t, b_t;\")\n    lib = verify(ffi, 'test_introspect_typedef_multiple', \"\"\"\n        typedef signed char a_t, c_t, g_t, b_t;\n    \"\"\")\n    assert ffi.list_types() == (['a_t', 'b_t', 'c_t', 'g_t'], [], [])\n\ndef test_introspect_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a; };\")\n    lib = verify(ffi, 'test_introspect_struct', \"\"\"\n        struct foo_s { int a; };\n    \"\"\")\n    assert ffi.list_types() == ([], ['foo_s'], [])\n    assert ffi.typeof('struct foo_s').kind == 'struct'\n    assert ffi.typeof('struct foo_s').cname == 'struct foo_s'\n\ndef test_introspect_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_s { int a; };\")\n    lib = verify(ffi, 'test_introspect_union', \"\"\"\n        union foo_s { int a; };\n    \"\"\")\n    assert ffi.list_types() == ([], [], ['foo_s'])\n    assert ffi.typeof('union foo_s').kind == 'union'\n    assert ffi.typeof('union foo_s').cname == 'union foo_s'\n\ndef test_introspect_struct_and_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int a; } foo_t;\")\n    lib = verify(ffi, 'test_introspect_struct_and_typedef', \"\"\"\n        typedef struct { int a; } foo_t;\n    \"\"\")\n    assert ffi.list_types() == (['foo_t'], [], [])\n    assert ffi.typeof('foo_t').kind == 'struct'\n    assert ffi.typeof('foo_t').cname == 'foo_t'\n\ndef test_introspect_included_type():\n    SOURCE = \"\"\"\n        typedef signed char schar_t;\n        struct sint_t { int x; };\n    \"\"\"\n    ffi1 = FFI()\n    ffi1.cdef(SOURCE)\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    verify(ffi1, \"test_introspect_included_type_parent\", SOURCE)\n    verify(ffi2, \"test_introspect_included_type\", SOURCE)\n    assert ffi1.list_types() == ffi2.list_types() == (\n            ['schar_t'], ['sint_t'], [])\n\ndef test_introspect_order():\n    ffi = FFI()\n    ffi.cdef(\"union CFFIaaa { int a; }; typedef struct CFFIccc { int a; } CFFIb;\")\n    ffi.cdef(\"union CFFIg   { int a; }; typedef struct CFFIcc  { int a; } CFFIbbb;\")\n    ffi.cdef(\"union CFFIaa  { int a; }; typedef struct CFFIa   { int a; } CFFIbb;\")\n    verify(ffi, \"test_introspect_order\", \"\"\"\n        union CFFIaaa { int a; }; typedef struct CFFIccc { int a; } CFFIb;\n        union CFFIg   { int a; }; typedef struct CFFIcc  { int a; } CFFIbbb;\n        union CFFIaa  { int a; }; typedef struct CFFIa   { int a; } CFFIbb;\n    \"\"\")\n    assert ffi.list_types() == (['CFFIb', 'CFFIbb', 'CFFIbbb'],\n                                ['CFFIa', 'CFFIcc', 'CFFIccc'],\n                                ['CFFIaa', 'CFFIaaa', 'CFFIg'])\n\ndef test_bool_in_cpp():\n    # this works when compiled as C, but in cffi < 1.7 it fails as C++\n    ffi = FFI()\n    ffi.cdef(\"bool f(void);\")\n    lib = verify(ffi, \"test_bool_in_cpp\", \"char f(void) { return 2; }\")\n    assert lib.f() is True\n\ndef test_bool_in_cpp_2():\n    ffi = FFI()\n    ffi.cdef('int add(int a, int b);')\n    lib = verify(ffi, \"test_bool_bug_cpp\", '''\n        typedef bool _Bool;  /* there is a Windows header with this line */\n        int add(int a, int b)\n        {\n            return a + b;\n        }''', source_extension='.cpp')\n    c = lib.add(2, 3)\n    assert c == 5\n\ndef test_struct_field_opaque():\n    ffi = FFI()\n    ffi.cdef(\"struct a { struct b b; };\")\n    e = pytest.raises(TypeError, verify,\n                       ffi, \"test_struct_field_opaque\", \"?\")\n    assert str(e.value) == (\"struct a: field 'a.b' is of an opaque\"\n                            \" type (not declared in cdef())\")\n    ffi = FFI()\n    ffi.cdef(\"struct a { struct b b[2]; };\")\n    e = pytest.raises(TypeError, verify,\n                       ffi, \"test_struct_field_opaque\", \"?\")\n    assert str(e.value) == (\"struct a: field 'a.b' is of an opaque\"\n                            \" type (not declared in cdef())\")\n    ffi = FFI()\n    ffi.cdef(\"struct a { struct b b[]; };\")\n    e = pytest.raises(TypeError, verify,\n                       ffi, \"test_struct_field_opaque\", \"?\")\n    assert str(e.value) == (\"struct a: field 'a.b' is of an opaque\"\n                            \" type (not declared in cdef())\")\n\ndef test_function_arg_opaque():\n    pytest.skip(\"can currently declare a function with an opaque struct \"\n                 \"as argument, but AFAICT it's impossible to call it later\")\n\ndef test_function_returns_opaque():\n    ffi = FFI()\n    ffi.cdef(\"struct a foo(int);\")\n    e = pytest.raises(TypeError, verify,\n                       ffi, \"test_function_returns_opaque\", \"?\")\n    assert str(e.value) == (\"function foo: 'struct a' is used as result type,\"\n                            \" but is opaque\")\n\ndef test_function_returns_union():\n    ffi = FFI()\n    ffi.cdef(\"union u1 { int a, b; }; union u1 f1(int);\")\n    lib = verify(ffi, \"test_function_returns_union\", \"\"\"\n        union u1 { int a, b; };\n        static union u1 f1(int x) { union u1 u; u.b = x; return u; }\n    \"\"\")\n    assert lib.f1(51).a == 51\n\ndef test_function_returns_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct aaa { int a; ...; }; struct aaa f1(int);\")\n    lib = verify(ffi, \"test_function_returns_partial_struct\", \"\"\"\n        struct aaa { int b, a, c; };\n        static struct aaa f1(int x) { struct aaa s = {0}; s.a = x; return s; }\n    \"\"\")\n    assert lib.f1(52).a == 52\n\ndef test_function_returns_float_complex():\n    ffi = FFI()\n    ffi.cdef(\"float _Complex f1(float a, float b);\");\n    if sys.platform == 'win32':\n        lib = verify(ffi, \"test_function_returns_float_complex\", \"\"\"\n            #include <complex.h>\n            static _Fcomplex f1(float a, float b) { return _FCbuild(a, 2.0f*b); }\n        \"\"\")\n    else:\n        lib = verify(ffi, \"test_function_returns_float_complex\", \"\"\"\n            #include <complex.h>\n            static float _Complex f1(float a, float b) { return a + I*2.0f*b; }\n        \"\"\", no_cpp=True)    # <complex.h> fails on some systems with C++\n    result = lib.f1(1.25, 5.1)\n    assert type(result) == complex\n    assert result.real == 1.25   # exact\n    assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-5) # inexact\n\ndef test_function_returns_double_complex():\n    ffi = FFI()\n    ffi.cdef(\"double _Complex f1(double a, double b);\");\n    if sys.platform == 'win32':\n        lib = verify(ffi, \"test_function_returns_double_complex\", \"\"\"\n            #include <complex.h>\n            static _Dcomplex f1(double a, double b) { return _Cbuild(a, 2.0*b); }\n        \"\"\")\n    else:\n        lib = verify(ffi, \"test_function_returns_double_complex\", \"\"\"\n            #include <complex.h>\n            static double _Complex f1(double a, double b) { return a + I*2.0*b; }\n        \"\"\", no_cpp=True)    # <complex.h> fails on some systems with C++\n    result = lib.f1(1.25, 5.1)\n    assert type(result) == complex\n    assert result.real == 1.25   # exact\n    assert result.imag == 2*5.1  # exact\n\ndef test_cdef_using_windows_complex():\n    if sys.platform != 'win32':\n        pytest.skip(\"only for MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"_Fcomplex f1(float a, float b); _Dcomplex f2(double a, double b);\");\n    lib = verify(ffi, \"test_cdef_using_windows_complex\", \"\"\"\n        #include <complex.h>\n        static _Fcomplex f1(float a, float b) { return _FCbuild(a, 2.0f*b); }\n        static _Dcomplex f2(double a, double b) { return _Cbuild(a, 2.0*b); }\n    \"\"\")\n    result = lib.f1(1.25, 5.1)\n    assert type(result) == complex\n    assert result.real == 1.25   # exact\n    assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-5) # inexact\n    result = lib.f2(1.25, 5.1)\n    assert type(result) == complex\n    assert result.real == 1.25   # exact\n    assert result.imag == 2*5.1  # exact\n\ndef test_function_argument_float_complex():\n    ffi = FFI()\n    ffi.cdef(\"float f1(float _Complex x);\");\n    if sys.platform == 'win32':\n        lib = verify(ffi, \"test_function_argument_float_complex\", \"\"\"\n            #include <complex.h>\n            static float f1(_Fcomplex x) { return cabsf(x); }\n        \"\"\")\n    else:\n        lib = verify(ffi, \"test_function_argument_float_complex\", \"\"\"\n            #include <complex.h>\n            static float f1(float _Complex x) { return cabsf(x); }\n        \"\"\", no_cpp=True)    # <complex.h> fails on some systems with C++\n    x = complex(12.34, 56.78)\n    result = lib.f1(x)\n    assert abs(result - abs(x)) < 1e-5\n\ndef test_function_argument_double_complex():\n    ffi = FFI()\n    ffi.cdef(\"double f1(double _Complex);\");\n    if sys.platform == 'win32':\n        lib = verify(ffi, \"test_function_argument_double_complex\", \"\"\"\n            #include <complex.h>\n            static double f1(_Dcomplex x) { return cabs(x); }\n        \"\"\")\n    else:\n        lib = verify(ffi, \"test_function_argument_double_complex\", \"\"\"\n            #include <complex.h>\n            static double f1(double _Complex x) { return cabs(x); }\n        \"\"\", no_cpp=True)    # <complex.h> fails on some systems with C++\n    x = complex(12.34, 56.78)\n    result = lib.f1(x)\n    assert abs(result - abs(x)) < 1e-11\n\ndef test_typedef_array_dotdotdot():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef int foo_t[...], bar_t[...];\n        extern int gv[...];\n        typedef int mat_t[...][...];\n        typedef int vmat_t[][...];\n        \"\"\")\n    lib = verify(ffi, \"test_typedef_array_dotdotdot\", \"\"\"\n        typedef int foo_t[50], bar_t[50];\n        int gv[23];\n        typedef int mat_t[6][7];\n        typedef int vmat_t[][8];\n    \"\"\")\n    assert ffi.sizeof(\"foo_t\") == 50 * ffi.sizeof(\"int\")\n    assert ffi.sizeof(\"bar_t\") == 50 * ffi.sizeof(\"int\")\n    assert len(ffi.new(\"foo_t\")) == 50\n    assert len(ffi.new(\"bar_t\")) == 50\n    assert ffi.sizeof(lib.gv) == 23 * ffi.sizeof(\"int\")\n    assert ffi.sizeof(\"mat_t\") == 6 * 7 * ffi.sizeof(\"int\")\n    assert len(ffi.new(\"mat_t\")) == 6\n    assert len(ffi.new(\"mat_t\")[3]) == 7\n    pytest.raises(ffi.error, ffi.sizeof, \"vmat_t\")\n    p = ffi.new(\"vmat_t\", 4)\n    assert ffi.sizeof(p[3]) == 8 * ffi.sizeof(\"int\")\n\ndef test_typedef_array_dotdotdot_usage():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef int foo_t[...];\n        typedef int mat_t[...][...];\n        struct s { foo_t a; foo_t *b; foo_t **c; };\n        int myfunc(foo_t a, foo_t *b, foo_t **c);\n        struct sm { mat_t a; mat_t *b; mat_t **c; };\n        int myfuncm(mat_t a, mat_t *b, mat_t **c);\n        \"\"\")\n    lib = verify(ffi, \"test_typedef_array_dotdotdot_usage\", \"\"\"\n        typedef int foo_t[50];\n        typedef int mat_t[6][7];\n        struct s { foo_t a; foo_t *b; foo_t **c; };\n        static int myfunc(foo_t a, foo_t *b, foo_t **c) { return (**c)[49]; }\n        struct sm { mat_t a; mat_t *b; mat_t **c; };\n        static int myfuncm(mat_t a, mat_t *b, mat_t **c) { return (**c)[5][6]; }\n    \"\"\")\n    assert ffi.sizeof(\"foo_t\") == 50 * ffi.sizeof(\"int\")\n    p = ffi.new(\"struct s *\")\n    assert ffi.sizeof(p[0]) == 50 * ffi.sizeof(\"int\") + 2 * ffi.sizeof(\"void *\")\n    p.a[49] = 321\n    p.b = ffi.addressof(p, 'a')\n    p.c = ffi.addressof(p, 'b')\n    assert lib.myfunc(ffi.NULL, ffi.NULL, p.c) == 321\n    #\n    assert ffi.sizeof(\"mat_t\") == 42 * ffi.sizeof(\"int\")\n    p = ffi.new(\"struct sm *\")\n    assert ffi.sizeof(p[0]) == 42 * ffi.sizeof(\"int\") + 2 * ffi.sizeof(\"void *\")\n    p.a[5][6] = -321\n    p.b = ffi.addressof(p, 'a')\n    p.c = ffi.addressof(p, 'b')\n    assert lib.myfuncm(ffi.NULL, ffi.NULL, p.c) == -321\n\ndef test_call_with_custom_field_pos():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo { int x; ...; };\n        struct foo f(void);\n        struct foo g(int, ...);\n    \"\"\")\n    lib = verify(ffi, \"test_call_with_custom_field_pos\", \"\"\"\n        struct foo { int y, x; };\n        struct foo f(void) {\n            struct foo s = { 40, 200 };\n            return s;\n        }\n        struct foo g(int a, ...) { return f(); }\n    \"\"\")\n    assert lib.f().x == 200\n    e = pytest.raises(NotImplementedError, lib.g, 0)\n    assert str(e.value) == (\n        'ctype \\'struct foo\\' not supported as return value.  It is a '\n        'struct declared with \"...;\", but the C calling convention may '\n        'depend on the missing fields; or, it contains anonymous '\n        'struct/unions.  Such structs are only supported '\n        'as return value if the function is \\'API mode\\' and non-variadic '\n        '(i.e. declared inside ffibuilder.cdef()+ffibuilder.set_source() '\n        'and not taking a final \\'...\\' argument)')\n\ndef test_call_with_nested_anonymous_struct():\n    if sys.platform == 'win32':\n        pytest.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo { int a; union { int b, c; }; };\n        struct foo f(void);\n        struct foo g(int, ...);\n    \"\"\")\n    lib = verify(ffi, \"test_call_with_nested_anonymous_struct\", \"\"\"\n        struct foo { int a; union { int b, c; }; };\n        struct foo f(void) {\n            struct foo s;\n            s.a = 40;\n            s.b = 200;\n            return s;\n        }\n        struct foo g(int a, ...) { return f(); }\n    \"\"\")\n    assert lib.f().b == 200\n    e = pytest.raises(NotImplementedError, lib.g, 0)\n    assert str(e.value) == (\n        'ctype \\'struct foo\\' not supported as return value.  It is a '\n        'struct declared with \"...;\", but the C calling convention may '\n        'depend on the missing fields; or, it contains anonymous '\n        'struct/unions.  Such structs are only supported '\n        'as return value if the function is \\'API mode\\' and non-variadic '\n        '(i.e. declared inside ffibuilder.cdef()+ffibuilder.set_source() '\n        'and not taking a final \\'...\\' argument)')\n\ndef test_call_with_bitfield():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo { int x:5; };\n        struct foo f(void);\n        struct foo g(int, ...);\n    \"\"\")\n    lib = verify(ffi, \"test_call_with_bitfield\", \"\"\"\n        struct foo { int x:5; };\n        struct foo f(void) {\n            struct foo s = { 11 };\n            return s;\n        }\n        struct foo g(int a, ...) { return f(); }\n    \"\"\")\n    assert lib.f().x == 11\n    e = pytest.raises(NotImplementedError, lib.g, 0)\n    assert str(e.value) == (\n        \"ctype 'struct foo' not supported as return value.  It is a struct \"\n        \"with bit fields, which libffi does not support.  Such structs are \"\n        \"only supported as return value if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+ffibuilder.\"\n        \"set_source() and not taking a final '...' argument)\")\n\ndef test_call_with_zero_length_field():\n    if sys.platform == 'win32':\n        pytest.skip(\"zero-length field not supported by MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo { int a; int x[0]; };\n        struct foo f(void);\n        struct foo g(int, ...);\n    \"\"\")\n    lib = verify(ffi, \"test_call_with_zero_length_field\", \"\"\"\n        struct foo { int a; int x[0]; };\n        struct foo f(void) {\n            struct foo s = { 42 };\n            return s;\n        }\n        struct foo g(int a, ...) { return f(); }\n    \"\"\")\n    assert lib.f().a == 42\n    e = pytest.raises(NotImplementedError, lib.g, 0)\n    assert str(e.value) == (\n        \"ctype 'struct foo' not supported as return value.  It is a \"\n        \"struct with a zero-length array, which libffi does not support.\"\n        \"  Such structs are only supported as return value if the function is \"\n        \"'API mode' and non-variadic (i.e. declared inside ffibuilder.cdef()\"\n        \"+ffibuilder.set_source() and not taking a final '...' argument)\")\n\ndef test_call_with_union():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        union foo { int a; char b; };\n        union foo f(void);\n        union foo g(int, ...);\n    \"\"\")\n    lib = verify(ffi, \"test_call_with_union\", \"\"\"\n        union foo { int a; char b; };\n        union foo f(void) {\n            union foo s = { 42 };\n            return s;\n        }\n        union foo g(int a, ...) { return f(); }\n    \"\"\")\n    assert lib.f().a == 42\n    e = pytest.raises(NotImplementedError, lib.g, 0)\n    assert str(e.value) == (\n        \"ctype 'union foo' not supported as return value by libffi.  \"\n        \"Unions are only supported as return value if the function is \"\n        \"'API mode' and non-variadic (i.e. declared inside ffibuilder.cdef()\"\n        \"+ffibuilder.set_source() and not taking a final '...' argument)\")\n\ndef test_call_with_packed_struct():\n    if sys.platform == 'win32':\n        pytest.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo { char y; int x; };\n        struct foo f(void);\n        struct foo g(int, ...);\n    \"\"\", packed=True)\n    lib = verify(ffi, \"test_call_with_packed_struct\", \"\"\"\n        struct foo { char y; int x; } __attribute__((packed));\n        struct foo f(void) {\n            struct foo s = { 40, 200 };\n            return s;\n        }\n        struct foo g(int a, ...) {\n            struct foo s = { 41, 201 };\n            return s;\n        }\n    \"\"\")\n    assert ord(lib.f().y) == 40\n    assert lib.f().x == 200\n    e = pytest.raises(NotImplementedError, lib.g, 0)\n    assert str(e.value) == (\n        \"ctype 'struct foo' not supported as return value.  It is a \"\n        \"'packed' structure, with a different layout than expected by libffi.\"\n        \"  Such structs are only supported as return value if the function is \"\n        \"'API mode' and non-variadic (i.e. declared inside ffibuilder.cdef()\"\n        \"+ffibuilder.set_source() and not taking a final '...' argument)\")\n\ndef test_pack_not_supported():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo { char y; int x; };\"\"\", pack=2)\n    pytest.raises(NotImplementedError, verify,\n                   ffi, \"test_pack_not_supported\", \"\")\n\ndef test_gcc_visibility_hidden():\n    if sys.platform == 'win32':\n        pytest.skip(\"test for gcc/clang\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    int f(int);\n    \"\"\")\n    lib = verify(ffi, \"test_gcc_visibility_hidden\", \"\"\"\n    int f(int a) { return a + 40; }\n    \"\"\", extra_compile_args=['-fvisibility=hidden'])\n    assert lib.f(2) == 42\n\ndef test_override_default_definition():\n    ffi = FFI()\n    ffi.cdef(\"typedef long int16_t, char16_t;\")\n    lib = verify(ffi, \"test_override_default_definition\", \"\")\n    assert ffi.typeof(\"int16_t\") is ffi.typeof(\"char16_t\") is ffi.typeof(\"long\")\n\ndef test_char16_char32_type(no_cpp=False):\n    if no_cpp is False and sys.platform == \"win32\":\n        pytest.skip(\"aaaaaaa why do modern MSVC compilers still define \"\n                     \"a very old __cplusplus value\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        char16_t foo_2bytes(char16_t);\n        char32_t foo_4bytes(char32_t);\n    \"\"\")\n    lib = verify(ffi, \"test_char16_char32_type\" + no_cpp * \"_nocpp\", \"\"\"\n    #if !defined(__cplusplus) || (!defined(_LIBCPP_VERSION) && __cplusplus < 201103L)\n    typedef uint_least16_t char16_t;\n    typedef uint_least32_t char32_t;\n    #endif\n\n    char16_t foo_2bytes(char16_t a) { return (char16_t)(a + 42); }\n    char32_t foo_4bytes(char32_t a) { return (char32_t)(a + 42); }\n    \"\"\", no_cpp=no_cpp)\n    assert lib.foo_2bytes(u+'\\u1234') == u+'\\u125e'\n    assert lib.foo_4bytes(u+'\\u1234') == u+'\\u125e'\n    assert lib.foo_4bytes(u+'\\U00012345') == u+'\\U0001236f'\n    pytest.raises(TypeError, lib.foo_2bytes, u+'\\U00012345')\n    pytest.raises(TypeError, lib.foo_2bytes, 1234)\n    pytest.raises(TypeError, lib.foo_4bytes, 1234)\n\ndef test_char16_char32_plain_c():\n    test_char16_char32_type(no_cpp=True)\n\ndef test_loader_spec():\n    ffi = FFI()\n    lib = verify(ffi, \"test_loader_spec\", \"\")\n    if sys.version_info < (3,):\n        assert not hasattr(lib, '__loader__')\n        assert not hasattr(lib, '__spec__')\n    else:\n        assert lib.__loader__ is None\n        assert lib.__spec__ is None\n\ndef test_realize_struct_error():\n    ffi = FFI()\n    ffi.cdef(\"\"\"typedef ... foo_t; struct foo_s { void (*x)(foo_t); };\"\"\")\n    lib = verify(ffi, \"test_realize_struct_error\", \"\"\"\n        typedef int foo_t; struct foo_s { void (*x)(foo_t); };\n    \"\"\")\n    pytest.raises(TypeError, ffi.new, \"struct foo_s *\")\n\ndef test_from_buffer_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { int a, b; };\"\"\")\n    lib = verify(ffi, \"test_from_buffer_struct_p\", \"\"\"\n        struct foo_s { int a, b; };\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\", [-219239, 58974983])\n    q = ffi.from_buffer(\"struct foo_s[]\", ffi.buffer(p))\n    assert ffi.typeof(q) == ffi.typeof(\"struct foo_s[]\")\n    assert len(q) == 1\n    assert q[0].a == p.a\n    assert q[0].b == p.b\n    assert q == p\n    q = ffi.from_buffer(\"struct foo_s *\", ffi.buffer(p))\n    assert ffi.typeof(q) == ffi.typeof(\"struct foo_s *\")\n    assert q.a == p.a\n    assert q.b == p.b\n    assert q[0].a == p.a\n    assert q[0].b == p.b\n    assert q == p\n\ndef test_unnamed_bitfield_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct A { char : 1; };\"\"\")\n    lib = verify(ffi, \"test_unnamed_bitfield_1\", \"\"\"\n        struct A { char : 1; };\n    \"\"\")\n    p = ffi.new(\"struct A *\")\n    assert ffi.sizeof(p[0]) == 1\n    # Note: on gcc, the type name is ignored for anonymous bitfields\n    # and that's why the result is 1.  On MSVC, the result is\n    # sizeof(\"char\") which is also 1.\n\ndef test_unnamed_bitfield_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct A {\n        short c : 1; short : 1; short d : 1; short : 1; };\"\"\")\n    lib = verify(ffi, \"test_unnamed_bitfield_2\", \"\"\"\n        struct A {\n            short c : 1; short : 1; short d : 1; short : 1;\n        };\n    \"\"\")\n    p = ffi.new(\"struct A *\")\n    assert ffi.sizeof(p[0]) == ffi.sizeof(\"short\")\n\ndef test_unnamed_bitfield_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct A { struct { char : 1; char : 1; } b; };\"\"\")\n    lib = verify(ffi, \"test_unnamed_bitfield_3\", \"\"\"\n        struct A { struct { char : 1; char : 1; } b; };\n    \"\"\")\n    p = ffi.new(\"struct A *\")\n    assert ffi.sizeof(p[0]) == 1\n    # Note: on gcc, the type name is ignored for anonymous bitfields\n    # and that's why the result is 1.  On MSVC, the result is\n    # sizeof(\"char\") which is also 1.\n\ndef test_unnamed_bitfield_4():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct A { struct {\n        unsigned c : 1; unsigned : 1; unsigned d : 1; unsigned : 1; } a;\n        };\n        struct B { struct A a; };\"\"\")\n    lib = verify(ffi, \"test_unnamed_bitfield_4\", \"\"\"\n        struct A { struct {\n            unsigned c : 1; unsigned : 1; unsigned d : 1; unsigned : 1; } a;\n        };\n        struct B { struct A a; };\n    \"\"\")\n    b = ffi.new(\"struct B *\")\n    a = ffi.new(\"struct A *\")\n    assert ffi.sizeof(a[0]) == ffi.sizeof(\"unsigned\")\n    assert ffi.sizeof(b[0]) == ffi.sizeof(a[0])\n\ndef test_struct_with_func_with_struct_pointer_arg():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct BinaryTree {\n            int (* CompareKey)(struct BinaryTree *tree);\n        };\"\"\")\n    lib = verify(ffi, \"test_struct_with_func_with_struct_pointer_arg\", \"\"\"\n        struct BinaryTree {\n            int (* CompareKey)(struct BinaryTree *tree);\n        };\n    \"\"\")\n    ffi.new(\"struct BinaryTree *\")\n\ndef test_struct_with_func_with_struct_arg():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct BinaryTree {\n            int (* CompareKey)(struct BinaryTree tree);\n        };\"\"\")\n    lib = verify(ffi, \"test_struct_with_func_with_struct_arg\", \"\"\"\n        struct BinaryTree {\n            int (* CompareKey)(struct BinaryTree tree);\n        };\n    \"\"\")\n    pytest.raises(RuntimeError, ffi.new, \"struct BinaryTree *\")\n\ndef test_passing_large_list():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void passing_large_list(long[]);\"\"\")\n    lib = verify(ffi, \"test_passing_large_list\", \"\"\"\n        static void passing_large_list(long a[]) { }\n    \"\"\")\n    arg = list(range(20000000))\n    lib.passing_large_list(arg)\n    # assert did not segfault\n\ndef test_convert_api_mode_builtin_function_to_cdata():\n    ffi = FFI()\n    ffi.cdef(\n        \"\"\"struct s { int x; };\n        struct s add1(struct s); struct s add2(struct s);\n        int mycall(struct s(*)(struct s)); int mycall2(void *);\"\"\")\n    lib = verify(ffi, \"test_convert_api_mode_builtin_function_to_cdata\", \"\"\"\n        struct s { int x; };\n        static struct s add1(struct s a) {\n            struct s r; r.x = a.x + 1; return r;\n        }\n        static struct s add2(struct s a) {\n            struct s r; r.x = a.x + 2; return r;\n        }\n        static int mycall(struct s(*cb)(struct s)) {\n            struct s a; a.x = 100;\n            return cb(a).x;\n        }\n        static int mycall2(void *cb) {\n            struct s a; a.x = 200;\n            return ((struct s(*)(struct s))cb)(a).x;\n        }\n    \"\"\")\n    s_ptr = ffi.new(\"struct s *\", [42])\n    s = s_ptr[0]\n    assert lib.add1(s).x == 43\n    assert lib.add2(s).x == 44\n    assert lib.mycall(lib.add1) == 101\n    assert lib.mycall(lib.add2) == 102\n    assert lib.mycall2(lib.add1) == 201\n    assert lib.mycall2(lib.add2) == 202\n    s.x = -42\n    my_array = ffi.new(\"struct s(*[2])(struct s)\")\n    my_array[0] = lib.add1\n    my_array[1] = lib.add2\n    assert my_array[0](s).x == -41\n    assert my_array[1](s).x == -40\n    s.x = 84\n    p = ffi.cast(\"void *\", lib.add1)\n    assert ffi.cast(\"struct s(*)(struct s)\", p)(s).x == 85\n    q = ffi.cast(\"intptr_t\", lib.add2)\n    assert ffi.cast(\"struct s(*)(struct s)\", q)(s).x == 86\n    s.x = 300\n    my_array_2 = ffi.new(\"void *[]\", [lib.add1, lib.add2])\n    assert ffi.cast(\"struct s(*)(struct s)\", my_array_2[1])(s).x == 302\n    assert ffi.typeof(lib.add1) == ffi.typeof(\"struct s(*)(struct s)\")\n", "testing/cffi1/test_function_args.py": "import pytest, sys\ntry:\n    # comment out the following line to run this test.\n    # the latest on x86-64 linux: https://github.com/libffi/libffi/issues/574\n    if sys.platform != 'win32':\n        raise ImportError(\"this test is skipped because it keeps finding \"\n                          \"failures in libffi, instead of cffi\")\n\n    from hypothesis import given, settings, example\n    from hypothesis import strategies as st\nexcept ImportError as e:\n    e1 = e\n    def test_types():\n        pytest.skip(str(e1))\nelse:\n\n    from cffi import FFI\n    import sys, random\n    from .test_recompiler import verify\n\n    ALL_PRIMITIVES = [\n        'unsigned char',\n        'short',\n        'int',\n        'long',\n        'long long',\n        'float',\n        'double',\n        #'long double',   --- on x86 it can give libffi crashes\n    ]\n    def _make_struct(s):\n        return st.lists(s, min_size=1)\n    types = st.one_of(st.sampled_from(ALL_PRIMITIVES),\n                      st.lists(st.sampled_from(ALL_PRIMITIVES), min_size=1))\n    # NB. 'types' could be st.recursive instead, but it doesn't\n    # really seem useful\n\n    def draw_primitive(ffi, typename):\n        value = random.random() * 2**40\n        if typename != 'long double':\n            return ffi.cast(typename, value)\n        else:\n            return value\n\n    TEST_RUN_COUNTER = 0\n\n\n    @given(st.lists(types), types)\n    @settings(max_examples=100, deadline=5000)   # 5000ms\n    def test_types(tp_args, tp_result):\n        global TEST_RUN_COUNTER\n        print(tp_args, tp_result)\n        cdefs = []\n        structs = {}\n\n        def build_type(tp):\n            if type(tp) is list:\n                field_types = [build_type(tp1) for tp1 in tp]\n                fields = ['%s f%d;' % (ftp, j)\n                          for (j, ftp) in enumerate(field_types)]\n                fields = '\\n    '.join(fields)\n                name = 's%d' % len(cdefs)\n                cdefs.append(\"typedef struct {\\n    %s\\n} %s;\" % (fields, name))\n                structs[name] = field_types\n                return name\n            else:\n                return tp\n\n        args = [build_type(tp) for tp in tp_args]\n        result = build_type(tp_result)\n\n        TEST_RUN_COUNTER += 1\n        signature = \"%s testfargs(%s)\" % (result,\n            ', '.join(['%s a%d' % (arg, i) for (i, arg) in enumerate(args)])\n            or 'void')\n\n        source = list(cdefs)\n\n        cdefs.append(\"%s;\" % signature)\n        cdefs.append(\"extern %s testfargs_result;\" % result)\n        for i, arg in enumerate(args):\n            cdefs.append(\"extern %s testfargs_arg%d;\" % (arg, i))\n        source.append(\"%s testfargs_result;\" % result)\n        for i, arg in enumerate(args):\n            source.append(\"%s testfargs_arg%d;\" % (arg, i))\n        source.append(signature)\n        source.append(\"{\")\n        for i, arg in enumerate(args):\n            source.append(\"    testfargs_arg%d = a%d;\" % (i, i))\n        source.append(\"    return testfargs_result;\")\n        source.append(\"}\")\n\n        typedef_line = \"typedef %s;\" % (signature.replace('testfargs',\n                                                          '(*mycallback_t)'),)\n        assert signature.endswith(')')\n        sig_callback = \"%s testfcallback(mycallback_t callback)\" % result\n        cdefs.append(typedef_line)\n        cdefs.append(\"%s;\" % sig_callback)\n        source.append(typedef_line)\n        source.append(sig_callback)\n        source.append(\"{\")\n        source.append(\"    return callback(%s);\" %\n                ', '.join([\"testfargs_arg%d\" % i for i in range(len(args))]))\n        source.append(\"}\")\n\n        ffi = FFI()\n        ffi.cdef(\"\\n\".join(cdefs))\n        lib = verify(ffi, 'test_function_args_%d' % TEST_RUN_COUNTER,\n                     \"\\n\".join(source), no_cpp=True)\n\n        # when getting segfaults, enable this:\n        if False:\n            from testing.udir import udir\n            import subprocess\n            f = open(str(udir.join('run1.py')), 'w')\n            f.write('import sys; sys.path = %r\\n' % (sys.path,))\n            f.write('from _CFFI_test_function_args_%d import ffi, lib\\n' %\n                    TEST_RUN_COUNTER)\n            for i in range(len(args)):\n                f.write('a%d = ffi.new(\"%s *\")\\n' % (i, args[i]))\n            aliststr = ', '.join(['a%d[0]' % i for i in range(len(args))])\n            f.write('lib.testfargs(%s)\\n' % aliststr)\n            f.write('ffi.addressof(lib, \"testfargs\")(%s)\\n' % aliststr)\n            f.close()\n            print(\"checking for segfault for direct call...\")\n            rc = subprocess.call([sys.executable, 'run1.py'], cwd=str(udir))\n            assert rc == 0, rc\n\n        def make_arg(tp):\n            if tp in structs:\n                return [make_arg(tp1) for tp1 in structs[tp]]\n            else:\n                return draw_primitive(ffi, tp)\n\n        passed_args = [make_arg(arg) for arg in args]\n        returned_value = make_arg(result)\n\n        def write(p, v):\n            if type(v) is list:\n                for i, v1 in enumerate(v):\n                    write(ffi.addressof(p, 'f%d' % i), v1)\n            else:\n                p[0] = v\n\n        write(ffi.addressof(lib, 'testfargs_result'), returned_value)\n\n        ## CALL forcing libffi\n        print(\"CALL forcing libffi\")\n        received_return = ffi.addressof(lib, 'testfargs')(*passed_args)\n        ##\n\n        _tp_long_double = ffi.typeof(\"long double\")\n        def check(p, v):\n            if type(v) is list:\n                for i, v1 in enumerate(v):\n                    check(ffi.addressof(p, 'f%d' % i), v1)\n            else:\n                if ffi.typeof(p).item is _tp_long_double:\n                    assert ffi.cast(\"double\", p[0]) == v\n                else:\n                    assert p[0] == v\n\n        for i, arg in enumerate(passed_args):\n            check(ffi.addressof(lib, 'testfargs_arg%d' % i), arg)\n        ret = ffi.new(result + \"*\", received_return)\n        check(ret, returned_value)\n\n        ## CALLBACK\n        def expand(value):\n            if isinstance(value, ffi.CData):\n                t = ffi.typeof(value)\n                if t is _tp_long_double:\n                    return float(ffi.cast(\"double\", value))\n                return [expand(getattr(value, 'f%d' % i))\n                        for i in range(len(t.fields))]\n            else:\n                return value\n\n        # when getting segfaults, enable this:\n        if False:\n            from testing.udir import udir\n            import subprocess\n            f = open(str(udir.join('run1.py')), 'w')\n            f.write('import sys; sys.path = %r\\n' % (sys.path,))\n            f.write('from _CFFI_test_function_args_%d import ffi, lib\\n' %\n                    TEST_RUN_COUNTER)\n            f.write('def callback(*args): return ffi.new(\"%s *\")[0]\\n' % result)\n            f.write('fptr = ffi.callback(\"%s(%s)\", callback)\\n' % (result,\n                                                                ','.join(args)))\n            f.write('print(lib.testfcallback(fptr))\\n')\n            f.close()\n            print(\"checking for segfault for callback...\")\n            rc = subprocess.call([sys.executable, 'run1.py'], cwd=str(udir))\n            assert rc == 0, rc\n\n        seen_args = []\n        def callback(*args):\n            seen_args.append([expand(arg) for arg in args])\n            return returned_value\n\n        fptr = ffi.callback(\"%s(%s)\" % (result, ','.join(args)), callback)\n        print(\"CALL with callback\")\n        received_return = lib.testfcallback(fptr)\n\n        assert len(seen_args) == 1\n        assert passed_args == seen_args[0]\n        ret = ffi.new(result + \"*\", received_return)\n        check(ret, returned_value)\n", "testing/cffi1/test_re_python.py": "import sys, os\nimport pytest\nfrom cffi import FFI\nfrom cffi import recompiler, ffiplatform, VerificationMissing\nfrom testing.udir import udir\nfrom testing.support import u, is_musl\n\n\ndef setup_module(mod):\n    SRC = \"\"\"\n    #include <string.h>\n    #define FOOBAR (-42)\n    static const int FOOBAZ = -43;\n    #define BIGPOS 420000000000L\n    #define BIGNEG -420000000000L\n    int add42(int x) { return x + 42; }\n    int add43(int x, ...) { return x; }\n    int globalvar42 = 1234;\n    const int globalconst42 = 4321;\n    const char *const globalconsthello = \"hello\";\n    struct foo_s;\n    typedef struct bar_s { int x; signed char a[]; } bar_t;\n    enum foo_e { AA, BB, CC };\n\n    void init_test_re_python(void) { }      /* windows hack */\n    void PyInit__test_re_python(void) { }   /* windows hack */\n    \"\"\"\n    tmpdir = udir.join('test_re_python')\n    tmpdir.ensure(dir=1)\n    c_file = tmpdir.join('_test_re_python.c')\n    c_file.write(SRC)\n    ext = ffiplatform.get_extension(\n        str(c_file),\n        '_test_re_python',\n        export_symbols=['add42', 'add43', 'globalvar42',\n                        'globalconst42', 'globalconsthello']\n    )\n    outputfilename = ffiplatform.compile(str(tmpdir), ext)\n\n    # test with a non-ascii char\n    ofn, oext = os.path.splitext(outputfilename)\n    if sys.platform == \"win32\":\n        unicode_name = ofn + (u+'\\u03be') + oext\n    else:\n        unicode_name = ofn + (u+'\\xe9') + oext\n        try:\n            unicode_name.encode(sys.getfilesystemencoding())\n        except UnicodeEncodeError:\n            unicode_name = None\n    if unicode_name is not None:\n        print(repr(outputfilename) + ' ==> ' + repr(unicode_name))\n        os.rename(outputfilename, unicode_name)\n        outputfilename = unicode_name\n\n    mod.extmod = outputfilename\n    mod.tmpdir = tmpdir\n    #\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    #define FOOBAR -42\n    static const int FOOBAZ = -43;\n    #define BIGPOS 420000000000L\n    #define BIGNEG -420000000000L\n    int add42(int);\n    int add43(int, ...);\n    extern int globalvar42;\n    const int globalconst42;\n    const char *const globalconsthello;\n    int no_such_function(int);\n    extern int no_such_globalvar;\n    struct foo_s;\n    typedef struct bar_s { int x; signed char a[]; } bar_t;\n    enum foo_e { AA, BB, CC };\n    int strlen(const char *);\n    struct with_union { union { int a; char b; }; };\n    union with_struct { struct { int a; char b; }; };\n    struct with_struct_with_union { struct { union { int x; }; } cp; };\n    struct NVGcolor { union { float rgba[4]; struct { float r,g,b,a; }; }; };\n    typedef struct selfref { struct selfref *next; } *selfref_ptr_t;\n    \"\"\")\n    ffi.set_source('re_python_pysrc', None)\n    ffi.emit_python_code(str(tmpdir.join('re_python_pysrc.py')))\n    mod.original_ffi = ffi\n    #\n    sys.path.insert(0, str(tmpdir))\n\n\ndef test_constant():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const('FOOBAR') == -42\n    assert ffi.integer_const('FOOBAZ') == -43\n\ndef test_large_constant():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const('BIGPOS') == 420000000000\n    assert ffi.integer_const('BIGNEG') == -420000000000\n\ndef test_function():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.add42(-10) == 32\n    assert type(lib.add42) is _cffi_backend.FFI.CData\n\ndef test_function_with_varargs():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod, 0)\n    assert lib.add43(45, ffi.cast(\"int\", -5)) == 45\n    assert type(lib.add43) is _cffi_backend.FFI.CData\n\ndef test_dlopen_none():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    name = None\n    if sys.platform == 'win32':\n        import ctypes.util\n        name = ctypes.util.find_msvcrt()\n        if name is None:\n            pytest.skip(\"dlopen(None) cannot work on Windows with Python 3\")\n    lib = ffi.dlopen(name)\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_dlclose():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    ffi.dlclose(lib)\n    if type(extmod) is not str:   # unicode, on python 2\n        str_extmod = extmod.encode('utf-8')\n    else:\n        str_extmod = extmod\n    e = pytest.raises(ffi.error, getattr, lib, 'add42')\n    assert str(e.value) == (\n        \"library '%s' has been closed\" % (str_extmod,))\n    ffi.dlclose(lib)   # does not raise\n\ndef test_constant_via_lib():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.FOOBAR == -42\n    assert lib.FOOBAZ == -43\n\ndef test_opaque_struct():\n    from re_python_pysrc import ffi\n    ffi.cast(\"struct foo_s *\", 0)\n    pytest.raises(TypeError, ffi.new, \"struct foo_s *\")\n\ndef test_nonopaque_struct():\n    from re_python_pysrc import ffi\n    for p in [ffi.new(\"struct bar_s *\", [5, b\"foobar\"]),\n              ffi.new(\"bar_t *\", [5, b\"foobar\"])]:\n        assert p.x == 5\n        assert p.a[0] == ord('f')\n        assert p.a[5] == ord('r')\n\ndef test_enum():\n    from re_python_pysrc import ffi\n    assert ffi.integer_const(\"BB\") == 1\n    e = ffi.cast(\"enum foo_e\", 2)\n    assert ffi.string(e) == \"CC\"\n\ndef test_include_1():\n    sub_ffi = FFI()\n    sub_ffi.cdef(\"static const int k2 = 121212;\")\n    sub_ffi.include(original_ffi)\n    assert 'macro FOOBAR' in original_ffi._parser._declarations\n    assert 'macro FOOBAZ' in original_ffi._parser._declarations\n    sub_ffi.set_source('re_python_pysrc', None)\n    sub_ffi.emit_python_code(str(tmpdir.join('_re_include_1.py')))\n    #\n    if sys.version_info[:2] >= (3, 3):\n        import importlib\n        importlib.invalidate_caches()  # issue 197 (but can't reproduce myself)\n    #\n    from _re_include_1 import ffi\n    assert ffi.integer_const('FOOBAR') == -42\n    assert ffi.integer_const('FOOBAZ') == -43\n    assert ffi.integer_const('k2') == 121212\n    lib = ffi.dlopen(extmod)     # <- a random unrelated library would be fine\n    assert lib.FOOBAR == -42\n    assert lib.FOOBAZ == -43\n    assert lib.k2 == 121212\n    #\n    p = ffi.new(\"bar_t *\", [5, b\"foobar\"])\n    assert p.a[4] == ord('a')\n\ndef test_global_var():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.globalvar42 == 1234\n    p = ffi.addressof(lib, 'globalvar42')\n    lib.globalvar42 += 5\n    assert p[0] == 1239\n    p[0] -= 1\n    assert lib.globalvar42 == 1238\n\ndef test_global_const_int():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert lib.globalconst42 == 4321\n    pytest.raises(AttributeError, ffi.addressof, lib, 'globalconst42')\n\ndef test_global_const_nonint():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    assert ffi.string(lib.globalconsthello, 8) == b\"hello\"\n    pytest.raises(AttributeError, ffi.addressof, lib, 'globalconsthello')\n\ndef test_rtld_constants():\n    from re_python_pysrc import ffi\n    ffi.RTLD_NOW    # check that we have the attributes\n    ffi.RTLD_LAZY\n    ffi.RTLD_GLOBAL\n\ndef test_no_such_function_or_global_var():\n    from re_python_pysrc import ffi\n    lib = ffi.dlopen(extmod)\n    e = pytest.raises(ffi.error, getattr, lib, 'no_such_function')\n    assert str(e.value).startswith(\n        \"symbol 'no_such_function' not found in library '\")\n    e = pytest.raises(ffi.error, getattr, lib, 'no_such_globalvar')\n    assert str(e.value).startswith(\n        \"symbol 'no_such_globalvar' not found in library '\")\n\ndef test_check_version():\n    import _cffi_backend\n    e = pytest.raises(ImportError, _cffi_backend.FFI,\n                       \"foobar\", _version=0x2594)\n    assert str(e.value).startswith(\n        \"cffi out-of-line Python module 'foobar' has unknown version\")\n\ndef test_partial_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum foo { A, B, ... };\")\n    ffi.set_source('test_partial_enum', None)\n    pytest.raises(VerificationMissing, ffi.emit_python_code,\n                   str(tmpdir.join('test_partial_enum.py')))\n\ndef test_anonymous_union_inside_struct():\n    # based on issue #357\n    from re_python_pysrc import ffi\n    INT = ffi.sizeof(\"int\")\n    assert ffi.offsetof(\"struct with_union\", \"a\") == 0\n    assert ffi.offsetof(\"struct with_union\", \"b\") == 0\n    assert ffi.sizeof(\"struct with_union\") == INT\n    #\n    assert ffi.offsetof(\"union with_struct\", \"a\") == 0\n    assert ffi.offsetof(\"union with_struct\", \"b\") == INT\n    assert ffi.sizeof(\"union with_struct\") >= INT + 1\n    #\n    assert ffi.sizeof(\"struct with_struct_with_union\") == INT\n    p = ffi.new(\"struct with_struct_with_union *\")\n    assert p.cp.x == 0\n    #\n    FLOAT = ffi.sizeof(\"float\")\n    assert ffi.sizeof(\"struct NVGcolor\") == FLOAT * 4\n    assert ffi.offsetof(\"struct NVGcolor\", \"rgba\") == 0\n    assert ffi.offsetof(\"struct NVGcolor\", \"r\") == 0\n    assert ffi.offsetof(\"struct NVGcolor\", \"g\") == FLOAT\n    assert ffi.offsetof(\"struct NVGcolor\", \"b\") == FLOAT * 2\n    assert ffi.offsetof(\"struct NVGcolor\", \"a\") == FLOAT * 3\n\ndef test_selfref():\n    # based on issue #429\n    from re_python_pysrc import ffi\n    ffi.new(\"selfref_ptr_t\")\n\ndef test_dlopen_handle():\n    import _cffi_backend\n    from re_python_pysrc import ffi\n    if sys.platform == 'win32' or is_musl:\n        pytest.skip(\"uses 'dl' explicitly\")\n    ffi1 = FFI()\n    ffi1.cdef(\"\"\"void *dlopen(const char *filename, int flags);\n                 int dlclose(void *handle);\"\"\")\n    lib1 = ffi1.dlopen('dl')\n    handle = lib1.dlopen(extmod.encode(sys.getfilesystemencoding()),\n                         _cffi_backend.RTLD_LAZY)\n    assert ffi1.typeof(handle) == ffi1.typeof(\"void *\")\n    assert handle\n\n    lib = ffi.dlopen(handle)\n    assert lib.add42(-10) == 32\n    assert type(lib.add42) is _cffi_backend.FFI.CData\n\n    err = lib1.dlclose(handle)\n    assert err == 0\n", "testing/cffi1/test_realize_c_type.py": "import sys\nimport pytest\nfrom cffi import cffi_opcode\n\n\ndef check(input, expected_output=None, expected_ffi_error=False):\n    import _cffi_backend\n    ffi = _cffi_backend.FFI()\n    if not expected_ffi_error:\n        ct = ffi.typeof(input)\n        assert isinstance(ct, ffi.CType)\n        assert ct.cname == (expected_output or input)\n    else:\n        e = pytest.raises(ffi.error, ffi.typeof, input)\n        if isinstance(expected_ffi_error, str):\n            assert str(e.value) == expected_ffi_error\n\ndef test_void():\n    check(\"void\", \"void\")\n    check(\"  void  \", \"void\")\n\ndef test_int_star():\n    check(\"int\")\n    check(\"int *\")\n    check(\"int*\", \"int *\")\n    check(\"long int\", \"long\")\n    check(\"long\")\n\ndef test_noop():\n    check(\"int(*)\", \"int *\")\n\ndef test_array():\n    check(\"int[6]\")\n\ndef test_funcptr():\n    check(\"int(*)(long)\")\n    check(\"int(long)\", expected_ffi_error=\"the type 'int(long)' is a\"\n          \" function type, not a pointer-to-function type\")\n    check(\"int(void)\", expected_ffi_error=\"the type 'int()' is a\"\n          \" function type, not a pointer-to-function type\")\n\ndef test_funcptr_rewrite_args():\n    check(\"int(*)(int(int))\", \"int(*)(int(*)(int))\")\n    check(\"int(*)(long[])\", \"int(*)(long *)\")\n    check(\"int(*)(long[5])\", \"int(*)(long *)\")\n\ndef test_all_primitives():\n    mapping = {\"_cffi_float_complex_t\": \"float _Complex\",\n               \"_cffi_double_complex_t\": \"double _Complex\"}\n    for name in cffi_opcode.PRIMITIVE_TO_INDEX:\n        check(name, mapping.get(name, name))\n\ndef check_func(input, expected_output=None):\n    import _cffi_backend\n    ffi = _cffi_backend.FFI()\n    ct = ffi.typeof(ffi.callback(input, lambda: None))\n    assert isinstance(ct, ffi.CType)\n    if sys.platform != 'win32' or sys.maxsize > 2**32:\n        expected_output = expected_output.replace('__stdcall *', '*')\n    assert ct.cname == expected_output\n\ndef test_funcptr_stdcall():\n    check_func(\"int(int)\", \"int(*)(int)\")\n    check_func(\"int foobar(int)\", \"int(*)(int)\")\n    check_func(\"int __stdcall(int)\", \"int(__stdcall *)(int)\")\n    check_func(\"int __stdcall foobar(int)\", \"int(__stdcall *)(int)\")\n    check_func(\"void __cdecl(void)\", \"void(*)()\")\n    check_func(\"void __cdecl foobar(void)\", \"void(*)()\")\n    check_func(\"void __stdcall(void)\", \"void(__stdcall *)()\")\n    check_func(\"void __stdcall foobar(long, short)\",\n                   \"void(__stdcall *)(long, short)\")\n    check_func(\"void(void __cdecl(void), void __stdcall(void))\",\n                   \"void(*)(void(*)(), void(__stdcall *)())\")\n\ndef test_variadic_overrides_stdcall():\n    check(\"void (__stdcall*)(int, ...)\", \"void(*)(int, ...)\")\n", "testing/cffi1/test_pkgconfig.py": "import sys\nimport subprocess\nimport pytest\nimport cffi.pkgconfig as pkgconfig\nfrom cffi import PkgConfigError\n\n\ndef mock_call(libname, flag):\n    assert libname==\"foobarbaz\"\n    flags = {\n        \"--cflags\": \"-I/usr/include/python3.6m -DABCD -DCFFI_TEST=1 -O42\\n\",\n        \"--libs\": \"-L/usr/lib64 -lpython3.6 -shared\\n\",\n    }\n    return flags[flag]\n\n\ndef test_merge_flags():\n    d1 = {\"ham\": [1, 2, 3], \"spam\" : [\"a\", \"b\", \"c\"], \"foo\" : []}\n    d2 = {\"spam\" : [\"spam\", \"spam\", \"spam\"], \"bar\" : [\"b\", \"a\", \"z\"]}\n\n    pkgconfig.merge_flags(d1, d2)\n    assert d1 == {\n        \"ham\": [1, 2, 3],\n        \"spam\" : [\"a\", \"b\", \"c\", \"spam\", \"spam\", \"spam\"],\n        \"bar\" : [\"b\", \"a\", \"z\"],\n        \"foo\" : []}\n\n\ndef test_pkgconfig():\n    assert pkgconfig.flags_from_pkgconfig([]) == {}\n\n    saved = pkgconfig.call\n    try:\n        pkgconfig.call = mock_call\n        flags = pkgconfig.flags_from_pkgconfig([\"foobarbaz\"])\n    finally:\n        pkgconfig.call = saved\n    assert flags == {\n        'include_dirs': ['/usr/include/python3.6m'],\n        'library_dirs': ['/usr/lib64'],\n        'libraries': ['python3.6'],\n        'define_macros': [('ABCD', None), ('CFFI_TEST', '1')],\n        'extra_compile_args': ['-O42'],\n        'extra_link_args': ['-shared']\n    }\n\nclass mock_subprocess:\n    PIPE = Ellipsis\n    class Popen:\n        def __init__(self, cmd, stdout, stderr):\n            if mock_subprocess.RESULT is None:\n                raise OSError(\"oops can't run\")\n            assert cmd == ['pkg-config', '--print-errors', '--cflags', 'libfoo']\n        def communicate(self):\n            bout, berr, rc = mock_subprocess.RESULT\n            self.returncode = rc\n            return bout, berr\n\ndef test_call():\n    saved = pkgconfig.subprocess\n    try:\n        pkgconfig.subprocess = mock_subprocess\n\n        mock_subprocess.RESULT = None\n        e = pytest.raises(PkgConfigError, pkgconfig.call, \"libfoo\", \"--cflags\")\n        assert str(e.value) == \"cannot run pkg-config: oops can't run\"\n\n        mock_subprocess.RESULT = b\"\", \"Foo error!\\n\", 1\n        e = pytest.raises(PkgConfigError, pkgconfig.call, \"libfoo\", \"--cflags\")\n        assert str(e.value) == \"Foo error!\"\n\n        mock_subprocess.RESULT = b\"abc\\\\def\\n\", \"\", 0\n        e = pytest.raises(PkgConfigError, pkgconfig.call, \"libfoo\", \"--cflags\")\n        assert str(e.value).startswith(\"pkg-config --cflags libfoo returned an \"\n                                       \"unsupported backslash-escaped output:\")\n\n        mock_subprocess.RESULT = b\"abc def\\n\", \"\", 0\n        result = pkgconfig.call(\"libfoo\", \"--cflags\")\n        assert result == \"abc def\\n\"\n\n        mock_subprocess.RESULT = b\"abc def\\n\", \"\", 0\n        result = pkgconfig.call(\"libfoo\", \"--cflags\")\n        assert result == \"abc def\\n\"\n\n        if sys.version_info >= (3,):\n            mock_subprocess.RESULT = b\"\\xff\\n\", \"\", 0\n            e = pytest.raises(PkgConfigError, pkgconfig.call,\n                               \"libfoo\", \"--cflags\", encoding=\"utf-8\")\n            assert str(e.value) == (\n                \"pkg-config --cflags libfoo returned bytes that cannot be \"\n                \"decoded with encoding 'utf-8':\\nb'\\\\xff\\\\n'\")\n\n    finally:\n        pkgconfig.subprocess = saved\n", "testing/cffi1/test_ffi_obj.py": "import sys\nimport pytest\nimport _cffi_backend as _cffi1_backend\n\n\ndef test_ffi_new():\n    ffi = _cffi1_backend.FFI()\n    p = ffi.new(\"int *\")\n    p[0] = -42\n    assert p[0] == -42\n    assert type(ffi) is ffi.__class__ is _cffi1_backend.FFI\n\ndef test_ffi_subclass():\n    class FOO(_cffi1_backend.FFI):\n        def __init__(self, x):\n            self.x = x\n    foo = FOO(42)\n    assert foo.x == 42\n    p = foo.new(\"int *\")\n    assert p[0] == 0\n    assert type(foo) is foo.__class__ is FOO\n\ndef test_ffi_no_argument():\n    pytest.raises(TypeError, _cffi1_backend.FFI, 42)\n\ndef test_ffi_cache_type():\n    ffi = _cffi1_backend.FFI()\n    t1 = ffi.typeof(\"int **\")\n    t2 = ffi.typeof(\"int *\")\n    assert t2.item is t1.item.item\n    assert t2 is t1.item\n    assert ffi.typeof(\"int[][10]\") is ffi.typeof(\"int[][10]\")\n    assert ffi.typeof(\"int(*)()\") is ffi.typeof(\"int(*)()\")\n\ndef test_ffi_type_not_immortal():\n    import weakref, gc\n    ffi = _cffi1_backend.FFI()\n    t1 = ffi.typeof(\"int **\")\n    t2 = ffi.typeof(\"int *\")\n    w1 = weakref.ref(t1)\n    w2 = weakref.ref(t2)\n    del t1, ffi\n    gc.collect()\n    assert w1() is None\n    assert w2() is t2\n    ffi = _cffi1_backend.FFI()\n    assert ffi.typeof(ffi.new(\"int **\")[0]) is t2\n    #\n    ffi = _cffi1_backend.FFI()\n    t1 = ffi.typeof(\"int ***\")\n    t2 = ffi.typeof(\"int **\")\n    w1 = weakref.ref(t1)\n    w2 = weakref.ref(t2)\n    del t2, ffi\n    gc.collect()\n    assert w1() is t1\n    assert w2() is not None   # kept alive by t1\n    ffi = _cffi1_backend.FFI()\n    assert ffi.typeof(\"int * *\") is t1.item\n\ndef test_ffi_cache_type_globally():\n    ffi1 = _cffi1_backend.FFI()\n    ffi2 = _cffi1_backend.FFI()\n    t1 = ffi1.typeof(\"int *\")\n    t2 = ffi2.typeof(\"int *\")\n    assert t1 is t2\n\ndef test_ffi_invalid():\n    ffi = _cffi1_backend.FFI()\n    # array of 10 times an \"int[]\" is invalid\n    pytest.raises(ValueError, ffi.typeof, \"int[10][]\")\n\ndef test_ffi_docstrings():\n    # check that all methods of the FFI class have a docstring.\n    check_type = type(_cffi1_backend.FFI.new)\n    for methname in dir(_cffi1_backend.FFI):\n        if not methname.startswith('_'):\n            method = getattr(_cffi1_backend.FFI, methname)\n            if isinstance(method, check_type):\n                assert method.__doc__, \"method FFI.%s() has no docstring\" % (\n                    methname,)\n\ndef test_ffi_NULL():\n    NULL = _cffi1_backend.FFI.NULL\n    assert _cffi1_backend.FFI().typeof(NULL).cname == \"void *\"\n\ndef test_ffi_no_attr():\n    ffi = _cffi1_backend.FFI()\n    with pytest.raises(AttributeError):\n        ffi.no_such_name\n    with pytest.raises(AttributeError):\n        ffi.no_such_name = 42\n    with pytest.raises(AttributeError):\n        del ffi.no_such_name\n\ndef test_ffi_string():\n    ffi = _cffi1_backend.FFI()\n    p = ffi.new(\"char[]\", init=b\"foobar\\x00baz\")\n    assert ffi.string(p) == b\"foobar\"\n    assert ffi.string(cdata=p, maxlen=3) == b\"foo\"\n\ndef test_ffi_errno():\n    # xxx not really checking errno, just checking that we can read/write it\n    ffi = _cffi1_backend.FFI()\n    ffi.errno = 42\n    assert ffi.errno == 42\n\ndef test_ffi_alignof():\n    ffi = _cffi1_backend.FFI()\n    assert ffi.alignof(\"int\") == 4\n    assert ffi.alignof(\"int[]\") == 4\n    assert ffi.alignof(\"int[41]\") == 4\n    assert ffi.alignof(\"short[41]\") == 2\n    assert ffi.alignof(ffi.new(\"int[41]\")) == 4\n    assert ffi.alignof(ffi.new(\"int[]\", 41)) == 4\n\ndef test_ffi_sizeof():\n    ffi = _cffi1_backend.FFI()\n    assert ffi.sizeof(\"int\") == 4\n    pytest.raises(ffi.error, ffi.sizeof, \"int[]\")\n    assert ffi.sizeof(\"int[41]\") == 41 * 4\n    assert ffi.sizeof(ffi.new(\"int[41]\")) == 41 * 4\n    assert ffi.sizeof(ffi.new(\"int[]\", 41)) == 41 * 4\n\ndef test_ffi_callback():\n    ffi = _cffi1_backend.FFI()\n    assert ffi.callback(\"int(int)\", lambda x: x + 42)(10) == 52\n    assert ffi.callback(\"int(*)(int)\", lambda x: x + 42)(10) == 52\n    assert ffi.callback(\"int(int)\", lambda x: x + \"\", -66)(10) == -66\n    assert ffi.callback(\"int(int)\", lambda x: x + \"\", error=-66)(10) == -66\n\ndef test_ffi_callback_decorator():\n    ffi = _cffi1_backend.FFI()\n    assert ffi.callback(ffi.typeof(\"int(*)(int)\"))(lambda x: x + 42)(10) == 52\n    deco = ffi.callback(\"int(int)\", error=-66)\n    assert deco(lambda x: x + \"\")(10) == -66\n    assert deco(lambda x: x + 42)(10) == 52\n\ndef test_ffi_callback_onerror():\n    ffi = _cffi1_backend.FFI()\n    seen = []\n    def oops(*args):\n        seen.append(args)\n\n    @ffi.callback(\"int(int)\", onerror=oops)\n    def fn1(x):\n        return x + \"\"\n    assert fn1(10) == 0\n\n    @ffi.callback(\"int(int)\", onerror=oops, error=-66)\n    def fn2(x):\n        return x + \"\"\n    assert fn2(10) == -66\n\n    assert len(seen) == 2\n    exc, val, tb = seen[0]\n    assert exc is TypeError\n    assert isinstance(val, TypeError)\n    assert tb.tb_frame.f_code.co_name == \"fn1\"\n    exc, val, tb = seen[1]\n    assert exc is TypeError\n    assert isinstance(val, TypeError)\n    assert tb.tb_frame.f_code.co_name == \"fn2\"\n    #\n    pytest.raises(TypeError, ffi.callback, \"int(int)\",\n                   lambda x: x, onerror=42)   # <- not callable\n\ndef test_ffi_getctype():\n    ffi = _cffi1_backend.FFI()\n    assert ffi.getctype(\"int\") == \"int\"\n    assert ffi.getctype(\"int\", 'x') == \"int x\"\n    assert ffi.getctype(\"int*\") == \"int *\"\n    assert ffi.getctype(\"int*\", '') == \"int *\"\n    assert ffi.getctype(\"int*\", 'x') == \"int * x\"\n    assert ffi.getctype(\"int\", '*') == \"int *\"\n    assert ffi.getctype(\"int\", replace_with=' * x ') == \"int * x\"\n    assert ffi.getctype(ffi.typeof(\"int*\"), '*') == \"int * *\"\n    assert ffi.getctype(\"int\", '[5]') == \"int[5]\"\n    assert ffi.getctype(\"int[5]\", '[6]') == \"int[6][5]\"\n    assert ffi.getctype(\"int[5]\", '(*)') == \"int(*)[5]\"\n    # special-case for convenience: automatically put '()' around '*'\n    assert ffi.getctype(\"int[5]\", '*') == \"int(*)[5]\"\n    assert ffi.getctype(\"int[5]\", '*foo') == \"int(*foo)[5]\"\n    assert ffi.getctype(\"int[5]\", ' ** foo ') == \"int(** foo)[5]\"\n\ndef test_addressof():\n    ffi = _cffi1_backend.FFI()\n    a = ffi.new(\"int[10]\")\n    b = ffi.addressof(a, 5)\n    b[2] = -123\n    assert a[7] == -123\n\ndef test_handle():\n    ffi = _cffi1_backend.FFI()\n    x = [2, 4, 6]\n    xp = ffi.new_handle(x)\n    assert ffi.typeof(xp) == ffi.typeof(\"void *\")\n    assert ffi.from_handle(xp) is x\n    yp = ffi.new_handle([6, 4, 2])\n    assert ffi.from_handle(yp) == [6, 4, 2]\n\ndef test_handle_unique():\n    ffi = _cffi1_backend.FFI()\n    assert ffi.new_handle(None) is not ffi.new_handle(None)\n    assert ffi.new_handle(None) != ffi.new_handle(None)\n\ndef test_ffi_cast():\n    ffi = _cffi1_backend.FFI()\n    assert ffi.cast(\"int(*)(int)\", 0) == ffi.NULL\n    ffi.callback(\"int(int)\")      # side-effect of registering this string\n    pytest.raises(ffi.error, ffi.cast, \"int(int)\", 0)\n\ndef test_ffi_invalid_type():\n    ffi = _cffi1_backend.FFI()\n    e = pytest.raises(ffi.error, ffi.cast, \"\", 0)\n    assert str(e.value) == (\"identifier expected\\n\"\n                            \"\\n\"\n                            \"^\")\n    e = pytest.raises(ffi.error, ffi.cast, \"struct struct\", 0)\n    assert str(e.value) == (\"struct or union name expected\\n\"\n                            \"struct struct\\n\"\n                            \"       ^\")\n    e = pytest.raises(ffi.error, ffi.cast, \"struct never_heard_of_s\", 0)\n    assert str(e.value) == (\"undefined struct/union name\\n\"\n                            \"struct never_heard_of_s\\n\"\n                            \"       ^\")\n    e = pytest.raises(ffi.error, ffi.cast, \"\\t\\n\\x01\\x1f~\\x7f\\x80\\xff\", 0)\n    marks = \"?\" if sys.version_info < (3,) else \"??\"\n    assert str(e.value) == (\"identifier expected\\n\"\n                            \"  ??~?%s%s\\n\"\n                            \"  ^\" % (marks, marks))\n    e = pytest.raises(ffi.error, ffi.cast, \"X\" * 600, 0)\n    assert str(e.value) == (\"undefined type name\")\n\ndef test_ffi_buffer():\n    ffi = _cffi1_backend.FFI()\n    a = ffi.new(\"signed char[]\", [5, 6, 7])\n    assert ffi.buffer(a)[:] == b'\\x05\\x06\\x07'\n    assert ffi.buffer(cdata=a, size=2)[:] == b'\\x05\\x06'\n    assert type(ffi.buffer(a)) is ffi.buffer\n\ndef test_ffi_from_buffer():\n    import array\n    ffi = _cffi1_backend.FFI()\n    a = array.array('H', [10000, 20000, 30000, 40000])\n    c = ffi.from_buffer(a)\n    assert ffi.typeof(c) is ffi.typeof(\"char[]\")\n    assert len(c) == 8\n    ffi.cast(\"unsigned short *\", c)[1] += 500\n    assert list(a) == [10000, 20500, 30000, 40000]\n    pytest.raises(TypeError, ffi.from_buffer, a, True)\n    assert c == ffi.from_buffer(\"char[]\", a, True)\n    assert c == ffi.from_buffer(a, require_writable=True)\n    #\n    c = ffi.from_buffer(\"unsigned short[]\", a)\n    assert len(c) == 4\n    assert c[1] == 20500\n    #\n    c = ffi.from_buffer(\"unsigned short[2][2]\", a)\n    assert len(c) == 2\n    assert len(c[0]) == 2\n    assert c[0][1] == 20500\n    #\n    p = ffi.from_buffer(b\"abcd\")\n    assert p[2] == b\"c\"\n    #\n    assert p == ffi.from_buffer(b\"abcd\", require_writable=False)\n    pytest.raises((TypeError, BufferError), ffi.from_buffer,\n                                             \"char[]\", b\"abcd\", True)\n    pytest.raises((TypeError, BufferError), ffi.from_buffer, b\"abcd\",\n                                             require_writable=True)\n\ndef test_memmove():\n    ffi = _cffi1_backend.FFI()\n    p = ffi.new(\"short[]\", [-1234, -2345, -3456, -4567, -5678])\n    ffi.memmove(p, p + 1, 4)\n    assert list(p) == [-2345, -3456, -3456, -4567, -5678]\n    p[2] = 999\n    ffi.memmove(p + 2, p, 6)\n    assert list(p) == [-2345, -3456, -2345, -3456, 999]\n    ffi.memmove(p + 4, ffi.new(\"char[]\", b\"\\x71\\x72\"), 2)\n    if sys.byteorder == 'little':\n        assert list(p) == [-2345, -3456, -2345, -3456, 0x7271]\n    else:\n        assert list(p) == [-2345, -3456, -2345, -3456, 0x7172]\n\ndef test_memmove_buffer():\n    import array\n    ffi = _cffi1_backend.FFI()\n    a = array.array('H', [10000, 20000, 30000])\n    p = ffi.new(\"short[]\", 5)\n    ffi.memmove(p, a, 6)\n    assert list(p) == [10000, 20000, 30000, 0, 0]\n    ffi.memmove(p + 1, a, 6)\n    assert list(p) == [10000, 10000, 20000, 30000, 0]\n    b = array.array('h', [-1000, -2000, -3000])\n    ffi.memmove(b, a, 4)\n    assert b.tolist() == [10000, 20000, -3000]\n    assert a.tolist() == [10000, 20000, 30000]\n    p[0] = 999\n    p[1] = 998\n    p[2] = 997\n    p[3] = 996\n    p[4] = 995\n    ffi.memmove(b, p, 2)\n    assert b.tolist() == [999, 20000, -3000]\n    ffi.memmove(b, p + 2, 4)\n    assert b.tolist() == [997, 996, -3000]\n    p[2] = -p[2]\n    p[3] = -p[3]\n    ffi.memmove(b, p + 2, 6)\n    assert b.tolist() == [-997, -996, 995]\n\ndef test_memmove_readonly_readwrite():\n    ffi = _cffi1_backend.FFI()\n    p = ffi.new(\"signed char[]\", 5)\n    ffi.memmove(p, b\"abcde\", 3)\n    assert list(p) == [ord(\"a\"), ord(\"b\"), ord(\"c\"), 0, 0]\n    ffi.memmove(p, bytearray(b\"ABCDE\"), 2)\n    assert list(p) == [ord(\"A\"), ord(\"B\"), ord(\"c\"), 0, 0]\n    pytest.raises((TypeError, BufferError), ffi.memmove, b\"abcde\", p, 3)\n    ba = bytearray(b\"xxxxx\")\n    ffi.memmove(dest=ba, src=p, n=3)\n    assert ba == bytearray(b\"ABcxx\")\n\ndef test_ffi_types():\n    CData = _cffi1_backend.FFI.CData\n    CType = _cffi1_backend.FFI.CType\n    ffi = _cffi1_backend.FFI()\n    assert isinstance(ffi.cast(\"int\", 42), CData)\n    assert isinstance(ffi.typeof(\"int\"), CType)\n\ndef test_ffi_getwinerror():\n    if sys.platform != \"win32\":\n        pytest.skip(\"for windows\")\n    ffi = _cffi1_backend.FFI()\n    n = (1 << 29) + 42\n    code, message = ffi.getwinerror(code=n)\n    assert code == n\n\ndef test_ffi_new_allocator_1():\n    ffi = _cffi1_backend.FFI()\n    alloc1 = ffi.new_allocator()\n    alloc2 = ffi.new_allocator(should_clear_after_alloc=False)\n    for retry in range(400):\n        p1 = alloc1(\"int[10]\")\n        p2 = alloc2(\"int[]\", 10 + retry * 13)\n        combination = 0\n        for i in range(10):\n            assert p1[i] == 0\n            combination |= p2[i]\n            p1[i] = -42\n            p2[i] = -43\n        if combination != 0:\n            break\n    else:\n        raise AssertionError(\"cannot seem to get an int[10] not \"\n                             \"completely cleared\")\n\ndef test_ffi_new_allocator_2():\n    ffi = _cffi1_backend.FFI()\n    seen = []\n    def myalloc(size):\n        seen.append(size)\n        return ffi.new(\"char[]\", b\"X\" * size)\n    def myfree(raw):\n        seen.append(raw)\n    alloc1 = ffi.new_allocator(myalloc, myfree)\n    alloc2 = ffi.new_allocator(alloc=myalloc, free=myfree,\n                               should_clear_after_alloc=False)\n    p1 = alloc1(\"int[10]\")\n    p2 = alloc2(\"int[]\", 10)\n    assert seen == [40, 40]\n    assert ffi.typeof(p1) == ffi.typeof(\"int[10]\")\n    assert ffi.sizeof(p1) == 40\n    assert ffi.typeof(p2) == ffi.typeof(\"int[]\")\n    assert ffi.sizeof(p2) == 40\n    assert p1[5] == 0\n    assert p2[6] == ord('X') * 0x01010101\n    raw1 = ffi.cast(\"char *\", p1)\n    raw2 = ffi.cast(\"char *\", p2)\n    del p1, p2\n    retries = 0\n    while len(seen) != 4:\n        retries += 1\n        assert retries <= 5\n        import gc; gc.collect()\n    assert (seen == [40, 40, raw1, raw2] or\n            seen == [40, 40, raw2, raw1])\n    assert repr(seen[2]) == \"<cdata 'char[]' owning 41 bytes>\"\n    assert repr(seen[3]) == \"<cdata 'char[]' owning 41 bytes>\"\n\ndef test_ffi_new_allocator_3():\n    ffi = _cffi1_backend.FFI()\n    seen = []\n    def myalloc(size):\n        seen.append(size)\n        return ffi.new(\"char[]\", b\"X\" * size)\n    alloc1 = ffi.new_allocator(myalloc)    # no 'free'\n    p1 = alloc1(\"int[10]\")\n    assert seen == [40]\n    assert ffi.typeof(p1) == ffi.typeof(\"int[10]\")\n    assert ffi.sizeof(p1) == 40\n    assert p1[5] == 0\n\ndef test_ffi_new_allocator_4():\n    ffi = _cffi1_backend.FFI()\n    pytest.raises(TypeError, ffi.new_allocator, free=lambda x: None)\n    #\n    def myalloc2(size):\n        raise LookupError\n    alloc2 = ffi.new_allocator(myalloc2)\n    pytest.raises(LookupError, alloc2, \"int[5]\")\n    #\n    def myalloc3(size):\n        return 42\n    alloc3 = ffi.new_allocator(myalloc3)\n    e = pytest.raises(TypeError, alloc3, \"int[5]\")\n    assert str(e.value) == \"alloc() must return a cdata object (got int)\"\n    #\n    def myalloc4(size):\n        return ffi.cast(\"int\", 42)\n    alloc4 = ffi.new_allocator(myalloc4)\n    e = pytest.raises(TypeError, alloc4, \"int[5]\")\n    assert str(e.value) == \"alloc() must return a cdata pointer, not 'int'\"\n    #\n    def myalloc5(size):\n        return ffi.NULL\n    alloc5 = ffi.new_allocator(myalloc5)\n    pytest.raises(MemoryError, alloc5, \"int[5]\")\n\ndef test_bool_issue228():\n    ffi = _cffi1_backend.FFI()\n    fntype = ffi.typeof(\"int(*callback)(bool is_valid)\")\n    assert repr(fntype.args[0]) == \"<ctype '_Bool'>\"\n\ndef test_FILE_issue228():\n    fntype1 = _cffi1_backend.FFI().typeof(\"FILE *\")\n    fntype2 = _cffi1_backend.FFI().typeof(\"FILE *\")\n    assert repr(fntype1) == \"<ctype 'FILE *'>\"\n    assert fntype1 is fntype2\n\ndef test_cast_from_int_type_to_bool():\n    ffi = _cffi1_backend.FFI()\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 0))) == 0\n\ndef test_init_once():\n    def do_init():\n        seen.append(1)\n        return 42\n    ffi = _cffi1_backend.FFI()\n    seen = []\n    for i in range(3):\n        res = ffi.init_once(do_init, \"tag1\")\n        assert res == 42\n        assert seen == [1]\n    for i in range(3):\n        res = ffi.init_once(do_init, \"tag2\")\n        assert res == 42\n        assert seen == [1, 1]\n\ndef test_init_once_multithread():\n    if sys.version_info < (3,):\n        import thread\n    else:\n        import _thread as thread\n    import time\n    #\n    def do_init():\n        print('init!')\n        seen.append('init!')\n        time.sleep(1)\n        seen.append('init done')\n        print('init done')\n        return 7\n    ffi = _cffi1_backend.FFI()\n    seen = []\n    for i in range(6):\n        def f():\n            res = ffi.init_once(do_init, \"tag\")\n            seen.append(res)\n        thread.start_new_thread(f, ())\n    time.sleep(1.5)\n    assert seen == ['init!', 'init done'] + 6 * [7]\n\ndef test_init_once_failure():\n    def do_init():\n        seen.append(1)\n        raise ValueError\n    ffi = _cffi1_backend.FFI()\n    seen = []\n    for i in range(5):\n        pytest.raises(ValueError, ffi.init_once, do_init, \"tag\")\n        assert seen == [1] * (i + 1)\n\ndef test_init_once_multithread_failure():\n    if sys.version_info < (3,):\n        import thread\n    else:\n        import _thread as thread\n    import time\n    def do_init():\n        seen.append('init!')\n        time.sleep(1)\n        seen.append('oops')\n        raise ValueError\n    ffi = _cffi1_backend.FFI()\n    seen = []\n    for i in range(3):\n        def f():\n            pytest.raises(ValueError, ffi.init_once, do_init, \"tag\")\n        thread.start_new_thread(f, ())\n    i = 0\n    while len(seen) < 6:\n        i += 1\n        assert i < 20\n        time.sleep(0.51)\n    assert seen == ['init!', 'oops'] * 3\n\ndef test_unpack():\n    ffi = _cffi1_backend.FFI()\n    p = ffi.new(\"char[]\", b\"abc\\x00def\")\n    assert ffi.unpack(p+1, 7) == b\"bc\\x00def\\x00\"\n    p = ffi.new(\"int[]\", [-123456789])\n    assert ffi.unpack(p, 1) == [-123456789]\n\ndef test_negative_array_size():\n    ffi = _cffi1_backend.FFI()\n    pytest.raises(ffi.error, ffi.cast, \"int[-5]\", 0)\n", "testing/cffi1/test_zdist.py": "import sys, os\nimport pytest\nimport subprocess\nimport cffi\nfrom testing.udir import udir\nfrom shutil import rmtree\nfrom tempfile import mkdtemp\n\n\ndef chdir_to_tmp(f):\n    f.chdir_to_tmp = True\n    return f\n\ndef from_outside(f):\n    f.chdir_to_tmp = False\n    return f\n\n\nclass TestDist(object):\n\n    def setup_method(self, meth):\n        self.executable = os.path.abspath(sys.executable)\n        self.rootdir = os.path.abspath(os.path.dirname(os.path.dirname(\n            cffi.__file__)))\n        self.udir = udir.join(meth.__name__)\n        os.mkdir(str(self.udir))\n        if meth.chdir_to_tmp:\n            self.saved_cwd = os.getcwd()\n            os.chdir(str(self.udir))\n\n    def teardown_method(self, meth):\n        if hasattr(self, 'saved_cwd'):\n            os.chdir(self.saved_cwd)\n\n    def run(self, args, cwd=None):\n        env = os.environ.copy()\n        # a horrible hack to prevent distutils from finding ~/.pydistutils.cfg\n        # (there is the --no-user-cfg option, but not in Python 2.6...)\n        # NOTE: pointing $HOME to a nonexistent directory can break certain things\n        # that look there for configuration (like ccache).\n        tmp_home = mkdtemp()\n        assert tmp_home != None, \"cannot create temporary homedir\"\n        env['HOME'] = tmp_home\n        pathlist = sys.path[:]\n        if cwd is None:\n            pathlist.insert(0, self.rootdir)\n        env['PYTHONPATH'] = os.pathsep.join(pathlist)\n        try:\n            subprocess.check_call([self.executable] + args, cwd=cwd, env=env)\n        finally:\n            rmtree(tmp_home)\n\n    def _prepare_setuptools(self):\n        if hasattr(TestDist, '_setuptools_ready'):\n            return\n        try:\n            import setuptools\n        except ImportError:\n            pytest.skip(\"setuptools not found\")\n        if os.path.exists(os.path.join(self.rootdir, 'setup.py')):\n            self.run(['setup.py', 'egg_info'], cwd=self.rootdir)\n        TestDist._setuptools_ready = True\n\n    def check_produced_files(self, content, curdir=None):\n        if curdir is None:\n            curdir = str(self.udir)\n        found_so = None\n        for name in os.listdir(curdir):\n            if (name.endswith('.so') or name.endswith('.pyd') or\n                name.endswith('.dylib') or name.endswith('.dll')):\n                found_so = os.path.join(curdir, name)\n                # foo.so => foo\n                parts = name.split('.')\n                del parts[-1]\n                if len(parts) > 1 and parts[-1] != 'bar':\n                    # foo.cpython-34m.so => foo, but foo.bar.so => foo.bar\n                    del parts[-1]\n                name = '.'.join(parts)\n                # foo_d => foo (Python 2 debug builds)\n                if name.endswith('_d') and hasattr(sys, 'gettotalrefcount'):\n                    name = name[:-2]\n                name += '.SO'\n            if name.startswith('pycparser') and name.endswith('.egg'):\n                continue    # no clue why this shows up sometimes and not others\n            if name == '.eggs':\n                continue    # seems new in 3.5, ignore it\n            assert name in content, \"found unexpected file %r\" % (\n                os.path.join(curdir, name),)\n            value = content.pop(name)\n            if value is None:\n                assert name.endswith('.SO') or (\n                    os.path.isfile(os.path.join(curdir, name)))\n            else:\n                subdir = os.path.join(curdir, name)\n                assert os.path.isdir(subdir)\n                if value == '?':\n                    continue\n                found_so = self.check_produced_files(value, subdir) or found_so\n        assert content == {}, \"files or dirs not produced in %r: %r\" % (\n            curdir, content.keys())\n        return found_so\n\n    @chdir_to_tmp\n    def test_empty(self):\n        self.check_produced_files({})\n\n    @chdir_to_tmp\n    def test_abi_emit_python_code_1(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"package_name_1.mymod\", None)\n        ffi.emit_python_code('xyz.py')\n        self.check_produced_files({'xyz.py': None})\n\n    @chdir_to_tmp\n    def test_abi_emit_python_code_2(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"package_name_1.mymod\", None)\n        pytest.raises(IOError, ffi.emit_python_code, 'unexisting/xyz.py')\n\n    @from_outside\n    def test_abi_emit_python_code_3(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"package_name_1.mymod\", None)\n        ffi.emit_python_code(str(self.udir.join('xyt.py')))\n        self.check_produced_files({'xyt.py': None})\n\n    @chdir_to_tmp\n    def test_abi_compile_1(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", None)\n        x = ffi.compile()\n        self.check_produced_files({'mod_name_in_package': {'mymod.py': None}})\n        assert x == os.path.join('.', 'mod_name_in_package', 'mymod.py')\n\n    @chdir_to_tmp\n    def test_abi_compile_2(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", None)\n        x = ffi.compile('build2')\n        self.check_produced_files({'build2': {\n            'mod_name_in_package': {'mymod.py': None}}})\n        assert x == os.path.join('build2', 'mod_name_in_package', 'mymod.py')\n\n    @from_outside\n    def test_abi_compile_3(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", None)\n        tmpdir = str(self.udir.join('build3'))\n        x = ffi.compile(tmpdir)\n        self.check_produced_files({'build3': {\n            'mod_name_in_package': {'mymod.py': None}}})\n        assert x == os.path.join(tmpdir, 'mod_name_in_package', 'mymod.py')\n\n    @chdir_to_tmp\n    def test_api_emit_c_code_1(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"package_name_1.mymod\", \"/*code would be here*/\")\n        ffi.emit_c_code('xyz.c')\n        self.check_produced_files({'xyz.c': None})\n\n    @chdir_to_tmp\n    def test_api_emit_c_code_2(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"package_name_1.mymod\", \"/*code would be here*/\")\n        pytest.raises(IOError, ffi.emit_c_code, 'unexisting/xyz.c')\n\n    @from_outside\n    def test_api_emit_c_code_3(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"package_name_1.mymod\", \"/*code would be here*/\")\n        ffi.emit_c_code(str(self.udir.join('xyu.c')))\n        self.check_produced_files({'xyu.c': None})\n\n    @chdir_to_tmp\n    def test_api_compile_1(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", \"/*code would be here*/\")\n        x = ffi.compile()\n        if sys.platform != 'win32':\n            sofile = self.check_produced_files({\n                'mod_name_in_package': {'mymod.SO': None,\n                                        'mymod.c': None,\n                                        'mymod.o': None}})\n            assert os.path.isabs(x) and os.path.samefile(x, sofile)\n        else:\n            self.check_produced_files({\n                'mod_name_in_package': {'mymod.SO': None,\n                                        'mymod.c': None},\n                'Release': '?'})\n\n    @chdir_to_tmp\n    def test_api_compile_2(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", \"/*code would be here*/\")\n        x = ffi.compile('output')\n        if sys.platform != 'win32':\n            sofile = self.check_produced_files({\n                'output': {'mod_name_in_package': {'mymod.SO': None,\n                                                   'mymod.c': None,\n                                                   'mymod.o': None}}})\n            assert os.path.isabs(x) and os.path.samefile(x, sofile)\n        else:\n            self.check_produced_files({\n                'output': {'mod_name_in_package': {'mymod.SO': None,\n                                                   'mymod.c': None},\n                           'Release': '?'}})\n\n    @from_outside\n    def test_api_compile_3(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", \"/*code would be here*/\")\n        x = ffi.compile(str(self.udir.join('foo')))\n        if sys.platform != 'win32':\n            sofile = self.check_produced_files({\n                'foo': {'mod_name_in_package': {'mymod.SO': None,\n                                                'mymod.c': None,\n                                                'mymod.o': None}}})\n            assert os.path.isabs(x) and os.path.samefile(x, sofile)\n        else:\n            self.check_produced_files({\n                'foo': {'mod_name_in_package': {'mymod.SO': None,\n                                                'mymod.c': None},\n                        'Release': '?'}})\n\n    @chdir_to_tmp\n    def test_api_compile_explicit_target_1(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", \"/*code would be here*/\")\n        x = ffi.compile(target=\"foo.bar.*\")\n        if sys.platform != 'win32':\n            sofile = self.check_produced_files({\n                'mod_name_in_package': {'foo.bar.SO': None,\n                                        'mymod.c': None,\n                                        'mymod.o': None}})\n            assert os.path.isabs(x) and os.path.samefile(x, sofile)\n        else:\n            self.check_produced_files({\n                'mod_name_in_package': {'foo.bar.SO': None,\n                                        'mymod.c': None},\n                'Release': '?'})\n\n    @chdir_to_tmp\n    def test_api_compile_explicit_target_3(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", \"/*code would be here*/\")\n        x = ffi.compile(target=\"foo.bar.baz\")\n        if sys.platform != 'win32':\n            self.check_produced_files({\n                'mod_name_in_package': {'foo.bar.baz': None,\n                                        'mymod.c': None,\n                                        'mymod.o': None}})\n            sofile = os.path.join(str(self.udir),\n                                  'mod_name_in_package', 'foo.bar.baz')\n            assert os.path.isabs(x) and os.path.samefile(x, sofile)\n        else:\n            self.check_produced_files({\n                'mod_name_in_package': {'foo.bar.baz': None,\n                                        'mymod.c': None},\n                'Release': '?'})\n\n    @chdir_to_tmp\n    def test_api_distutils_extension_1(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", \"/*code would be here*/\")\n        ext = ffi.distutils_extension()\n        self.check_produced_files({'build': {\n            'mod_name_in_package': {'mymod.c': None}}})\n        if hasattr(os.path, 'samefile'):\n            assert os.path.samefile(ext.sources[0],\n                                    'build/mod_name_in_package/mymod.c')\n\n    @from_outside\n    def test_api_distutils_extension_2(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"mod_name_in_package.mymod\", \"/*code would be here*/\")\n        ext = ffi.distutils_extension(str(self.udir.join('foo')))\n        self.check_produced_files({'foo': {\n            'mod_name_in_package': {'mymod.c': None}}})\n        if hasattr(os.path, 'samefile'):\n            assert os.path.samefile(ext.sources[0],\n                str(self.udir.join('foo/mod_name_in_package/mymod.c')))\n\n\n    def _make_distutils_api(self):\n        os.mkdir(\"src\")\n        os.mkdir(os.path.join(\"src\", \"pack1\"))\n        with open(os.path.join(\"src\", \"pack1\", \"__init__.py\"), \"w\") as f:\n            pass\n        with open(\"setup.py\", \"w\") as f:\n            f.write(\"\"\"if 1:\n                # https://bugs.python.org/issue23246\n                import setuptools\n                import cffi\n                ffi = cffi.FFI()\n                ffi.set_source(\"pack1.mymod\", \"/*code would be here*/\")\n\n                from distutils.core import setup\n                setup(name='example1',\n                      version='0.1',\n                      packages=['pack1'],\n                      package_dir={'': 'src'},\n                      ext_modules=[ffi.distutils_extension()])\n            \"\"\")\n\n    @chdir_to_tmp\n    def test_distutils_api_1(self):\n        self._make_distutils_api()\n        self.run([\"setup.py\", \"build\"])\n        self.check_produced_files({'setup.py': None,\n                                   'build': '?',\n                                   'src': {'pack1': {'__init__.py': None}}})\n\n    @chdir_to_tmp\n    def test_distutils_api_2(self):\n        self._make_distutils_api()\n        self.run([\"setup.py\", \"build_ext\", \"-i\"])\n        self.check_produced_files({'setup.py': None,\n                                   'build': '?',\n                                   'src': {'pack1': {'__init__.py': None,\n                                                     'mymod.SO': None}}})\n\n    def _make_setuptools_abi(self):\n        self._prepare_setuptools()\n        os.mkdir(\"src0\")\n        os.mkdir(os.path.join(\"src0\", \"pack2\"))\n        with open(os.path.join(\"src0\", \"pack2\", \"__init__.py\"), \"w\") as f:\n            pass\n        with open(os.path.join(\"src0\", \"pack2\", \"_build.py\"), \"w\") as f:\n            f.write(\"\"\"if 1:\n                import cffi\n                ffi = cffi.FFI()\n                ffi.set_source(\"pack2.mymod\", None)\n            \"\"\")\n        with open(\"setup.py\", \"w\") as f:\n            f.write(\"\"\"if 1:\n                from setuptools import setup\n                setup(name='example1',\n                      version='0.1',\n                      packages=['pack2'],\n                      package_dir={'': 'src0'},\n                      cffi_modules=[\"src0/pack2/_build.py:ffi\"])\n            \"\"\")\n\n    @chdir_to_tmp\n    def test_setuptools_abi_1(self):\n        self._make_setuptools_abi()\n        self.run([\"setup.py\", \"build\"])\n        self.check_produced_files({'setup.py': None,\n                                   'build': '?',\n                                   'src0': {'pack2': {'__init__.py': None,\n                                                      '_build.py': None}}})\n\n    @chdir_to_tmp\n    def test_setuptools_abi_2(self):\n        self._make_setuptools_abi()\n        self.run([\"setup.py\", \"build_ext\", \"-i\"])\n        self.check_produced_files({'setup.py': None,\n                                   'src0': {'pack2': {'__init__.py': None,\n                                                      '_build.py': None,\n                                                      'mymod.py': None}}})\n\n    def _make_setuptools_api(self):\n        self._prepare_setuptools()\n        os.mkdir(\"src1\")\n        os.mkdir(os.path.join(\"src1\", \"pack3\"))\n        with open(os.path.join(\"src1\", \"pack3\", \"__init__.py\"), \"w\") as f:\n            pass\n        with open(os.path.join(\"src1\", \"pack3\", \"_build.py\"), \"w\") as f:\n            f.write(\"\"\"if 1:\n                import cffi\n                ffi = cffi.FFI()\n                ffi.set_source(\"pack3.mymod\", \"/*code would be here*/\")\n                ffi._hi_there = 42\n            \"\"\")\n        with open(\"setup.py\", \"w\") as f:\n            f.write(\"from __future__ import print_function\\n\"\n                \"\"\"if 1:\n                from setuptools import setup\n                from distutils.command.build_ext import build_ext\n                import os\n\n                class TestBuildExt(build_ext):\n                    def pre_run(self, ext, ffi):\n                        print('_make_setuptools_api: in pre_run:', end=\" \")\n                        assert ffi._hi_there == 42\n                        assert ext.name == \"pack3.mymod\"\n                        fn = os.path.join(os.path.dirname(self.build_lib),\n                                          '..', 'see_me')\n                        print('creating %r' % (fn,))\n                        open(fn, 'w').close()\n\n                setup(name='example1',\n                      version='0.1',\n                      packages=['pack3'],\n                      package_dir={'': 'src1'},\n                      cffi_modules=[\"src1/pack3/_build.py:ffi\"],\n                      cmdclass={'build_ext': TestBuildExt},\n                      )\n            \"\"\")\n\n    @chdir_to_tmp\n    def test_setuptools_api_1(self):\n        self._make_setuptools_api()\n        self.run([\"setup.py\", \"build\"])\n        self.check_produced_files({'setup.py': None,\n                                   'build': '?',\n                                   'see_me': None,\n                                   'src1': {'pack3': {'__init__.py': None,\n                                                      '_build.py': None}}})\n\n    @chdir_to_tmp\n    def test_setuptools_api_2(self):\n        self._make_setuptools_api()\n        self.run([\"setup.py\", \"build_ext\", \"-i\"])\n        self.check_produced_files({'setup.py': None,\n                                   'build': '?',\n                                   'see_me': None,\n                                   'src1': {'pack3': {'__init__.py': None,\n                                                      '_build.py': None,\n                                                      'mymod.SO': None}}})\n", "testing/cffi1/test_commontypes.py": "import os, cffi, re\nimport pytest\nimport _cffi_backend\n\n\ndef getlines():\n    try:\n        f = open(os.path.join(os.path.dirname(cffi.__file__),\n                              '..', 'c', 'commontypes.c'))\n    except IOError:\n        pytest.skip(\"cannot find ../c/commontypes.c\")\n    lines = [line for line in f.readlines() if line.strip().startswith('EQ(')]\n    f.close()\n    return lines\n\ndef test_alphabetical_order():\n    lines = getlines()\n    assert lines == sorted(lines)\n\ndef test_dependencies():\n    r = re.compile(r'EQ[(]\"([^\"]+)\",(?:\\s*\"([A-Z0-9_]+)\\s*[*]*\"[)])?')\n    lines = getlines()\n    d = {}\n    for line in lines:\n        match = r.search(line)\n        if match is not None:\n            d[match.group(1)] = match.group(2)\n    for value in d.values():\n        if value:\n            assert value in d\n\ndef test_get_common_types():\n    d = {}\n    _cffi_backend._get_common_types(d)\n    assert d[\"bool\"] == \"_Bool\"\n", "testing/cffi1/test_unicode_literals.py": "#\n# ----------------------------------------------\n# WARNING, ALL LITERALS IN THIS FILE ARE UNICODE\n# ----------------------------------------------\n#\nfrom __future__ import unicode_literals\n#\n#\n#\nfrom _cffi_backend import FFI\n\n\ndef test_cast():\n    ffi = FFI()\n    assert int(ffi.cast(\"int\", 3.14)) == 3        # unicode literal\n\ndef test_new():\n    ffi = FFI()\n    assert ffi.new(\"int[]\", [3, 4, 5])[2] == 5    # unicode literal\n\ndef test_typeof():\n    ffi = FFI()\n    tp = ffi.typeof(\"int[51]\")                    # unicode literal\n    assert tp.length == 51\n\ndef test_sizeof():\n    ffi = FFI()\n    assert ffi.sizeof(\"int[51]\") == 51 * 4        # unicode literal\n\ndef test_alignof():\n    ffi = FFI()\n    assert ffi.alignof(\"int[51]\") == 4            # unicode literal\n\ndef test_getctype():\n    ffi = FFI()\n    assert ffi.getctype(\"int**\") == \"int * *\"     # unicode literal\n    assert type(ffi.getctype(\"int**\")) is str\n\ndef test_callback():\n    ffi = FFI()\n    cb = ffi.callback(\"int(int)\",                 # unicode literal\n                      lambda x: x + 42)\n    assert cb(5) == 47\n", "testing/cffi1/test_cffi_binary.py": "import sys, os\nimport pytest\nimport _cffi_backend\nfrom testing.support import is_musl\n\ndef test_no_unknown_exported_symbols():\n    if not hasattr(_cffi_backend, '__file__'):\n        pytest.skip(\"_cffi_backend module is built-in\")\n    if not sys.platform.startswith('linux') or is_musl:\n        pytest.skip(\"linux-only\")\n    g = os.popen(\"objdump -T '%s'\" % _cffi_backend.__file__, 'r')\n    for line in g:\n        if not line.startswith('0'):\n            continue\n        if line[line.find(' ') + 1] == 'l':\n            continue\n        if '*UND*' in line:\n            continue\n        name = line.split()[-1]\n        if name.startswith('_') or name.startswith('.'):\n            continue\n        # a statically-linked libffi will always appear here without header hackage, ignore it if it's internal\n        if name.startswith('ffi_') and 'Base' in line:\n            continue\n        if name not in ('init_cffi_backend', 'PyInit__cffi_backend', 'cffistatic_ffi_call'):\n            raise Exception(\"Unexpected exported name %r\" % (name,))\n    g.close()\n", "testing/cffi1/test_new_ffi_1.py": "import pytest\nimport platform\nimport sys, os, ctypes\nimport cffi\nfrom testing.udir import udir\nfrom testing.support import *\nfrom cffi.recompiler import recompile\nfrom cffi.cffi_opcode import PRIMITIVE_TO_INDEX\n\nSIZE_OF_INT   = ctypes.sizeof(ctypes.c_int)\nSIZE_OF_LONG  = ctypes.sizeof(ctypes.c_long)\nSIZE_OF_SHORT = ctypes.sizeof(ctypes.c_short)\nSIZE_OF_PTR   = ctypes.sizeof(ctypes.c_void_p)\nSIZE_OF_WCHAR = ctypes.sizeof(ctypes.c_wchar)\n\n\ndef setup_module():\n    global ffi, construction_params\n    ffi1 = cffi.FFI()\n    DEFS = r\"\"\"\n        struct repr { short a, b, c; };\n        struct simple { int a; short b, c; };\n        struct array { int a[2]; char b[3]; };\n        struct recursive { int value; struct recursive *next; };\n        union simple_u { int a; short b, c; };\n        union init_u { char a; int b; };\n        struct four_s { int a; short b, c, d; };\n        union four_u { int a; short b, c, d; };\n        struct string { const char *name; };\n        struct ustring { const wchar_t *name; };\n        struct voidp { void *p; int *q; short *r; };\n        struct ab { int a, b; };\n        struct abc { int a, b, c; };\n\n        /* don't use A0, B0, CC0, D0 because termios.h might be included\n           and it has its own #defines for these names */\n        enum foq { cffiA0, cffiB0, cffiCC0, cffiD0 };\n        enum bar { A1, B1=-2, CC1, D1, E1 };\n        enum baz { A2=0x1000, B2=0x2000 };\n        enum foo2 { A3, B3, C3, D3 };\n        struct bar_with_e { enum foo2 e; };\n        enum noncont { A4, B4=42, C4 };\n        enum etypes {A5='!', B5='\\'', C5=0x10, D5=010, E5=- 0x10, F5=-010};\n        typedef enum { Value0 = 0 } e_t, *pe_t;\n        enum e_noninj { AA3=0, BB3=0, CC3=0, DD3=0 };\n        enum e_prev { AA4, BB4=2, CC4=4, DD4=BB4, EE4, FF4=CC4, GG4=FF4 };\n\n        struct nesting { struct abc d, e; };\n        struct array2 { int a, b; int c[99]; };\n        struct align { char a; short b; char c; };\n        struct bitfield { int a:10, b:20, c:3; };\n        typedef enum { AA2, BB2, CC2 } foo_e_t;\n        typedef struct { foo_e_t f:2; } bfenum_t;\n        typedef struct { int a; } anon_foo_t;\n        typedef struct { char b, c; } anon_bar_t;\n        typedef struct named_foo_s { int a; } named_foo_t, *named_foo_p;\n        typedef struct { int a; } unnamed_foo_t, *unnamed_foo_p;\n        struct nonpacked { char a; int b; };\n        struct array0 { int len; short data[0]; };\n        struct array_no_length { int x; int a[]; };\n\n        struct nested_anon {\n            struct { int a, b; };\n            union { int c, d; };\n        };\n        struct nested_field_ofs_s {\n            struct { int a; char b; };\n            union { char c; };\n        };\n        union nested_anon_u {\n            struct { int a, b; };\n            union { int c, d; };\n        };\n        struct abc50 { int a, b; int c[50]; };\n        struct ints_and_bitfield { int a,b,c,d,e; int x:1; };\n    \"\"\"\n    DEFS_PACKED = \"\"\"\n        struct is_packed { char a; int b; } /*here*/;\n    \"\"\"\n    if sys.platform == \"win32\":\n        DEFS = DEFS.replace('data[0]', 'data[1]')   # not supported\n        CCODE = (DEFS + \"\\n#pragma pack(push,1)\\n\" + DEFS_PACKED +\n                 \"\\n#pragma pack(pop)\\n\")\n    else:\n        CCODE = (DEFS +\n                 DEFS_PACKED.replace('/*here*/', '__attribute__((packed))'))\n\n    ffi1.cdef(DEFS)\n    ffi1.cdef(DEFS_PACKED, packed=True)\n    ffi1.set_source(\"test_new_ffi_1\", CCODE)\n\n    outputfilename = recompile(ffi1, \"test_new_ffi_1\", CCODE,\n                               tmpdir=str(udir))\n    module = load_dynamic(\"test_new_ffi_1\", outputfilename)\n    ffi = module.ffi\n    construction_params = (ffi1, CCODE)\n\n\nclass TestNewFFI1:\n\n    def test_integer_ranges(self):\n        for (c_type, size) in [('char', 1),\n                               ('short', 2),\n                               ('short int', 2),\n                               ('', 4),\n                               ('int', 4),\n                               ('long', SIZE_OF_LONG),\n                               ('long int', SIZE_OF_LONG),\n                               ('long long', 8),\n                               ('long long int', 8),\n                               ]:\n            for unsigned in [None, False, True]:\n                c_decl = {None: '',\n                          False: 'signed ',\n                          True: 'unsigned '}[unsigned] + c_type\n                if c_decl == 'char' or c_decl == '':\n                    continue\n                self._test_int_type(ffi, c_decl, size, unsigned)\n\n    def test_fixedsize_int(self):\n        for size in [1, 2, 4, 8]:\n            self._test_int_type(ffi, 'int%d_t' % (8*size), size, False)\n            self._test_int_type(ffi, 'uint%d_t' % (8*size), size, True)\n        self._test_int_type(ffi, 'intptr_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'uintptr_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ptrdiff_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'size_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ssize_t', SIZE_OF_PTR, False)\n\n    def _test_int_type(self, ffi, c_decl, size, unsigned):\n        if unsigned:\n            min = 0\n            max = (1 << (8*size)) - 1\n        else:\n            min = -(1 << (8*size-1))\n            max = (1 << (8*size-1)) - 1\n        min = int(min)\n        max = int(max)\n        p = ffi.cast(c_decl, min)\n        assert p == min\n        assert bool(p) is bool(min)\n        assert int(p) == min\n        p = ffi.cast(c_decl, max)\n        assert int(p) == max\n        p = ffi.cast(c_decl, long(max))\n        assert int(p) == max\n        q = ffi.cast(c_decl, min - 1)\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        q = ffi.cast(c_decl, long(min - 1))\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        assert q == p\n        assert int(q) == int(p)\n        assert hash(q) == hash(p)\n        c_decl_ptr = '%s *' % c_decl\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))\n        assert ffi.new(c_decl_ptr, min)[0] == min\n        assert ffi.new(c_decl_ptr, max)[0] == max\n        assert ffi.new(c_decl_ptr, long(min))[0] == min\n        assert ffi.new(c_decl_ptr, long(max))[0] == max\n\n    def test_new_unsupported_type(self):\n        e = pytest.raises(TypeError, ffi.new, \"int\")\n        assert str(e.value) == \"expected a pointer or array ctype, got 'int'\"\n\n    def test_new_single_integer(self):\n        p = ffi.new(\"int *\")     # similar to ffi.new(\"int[1]\")\n        assert p[0] == 0\n        p[0] = -123\n        assert p[0] == -123\n        p = ffi.new(\"int *\", -42)\n        assert p[0] == -42\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n\n    def test_new_array_no_arg(self):\n        p = ffi.new(\"int[10]\")\n        # the object was zero-initialized:\n        for i in range(10):\n            assert p[i] == 0\n\n    def test_array_indexing(self):\n        p = ffi.new(\"int[10]\")\n        p[0] = 42\n        p[9] = 43\n        assert p[0] == 42\n        assert p[9] == 43\n        with pytest.raises(IndexError):\n            p[10]\n        with pytest.raises(IndexError):\n            p[10] = 44\n        with pytest.raises(IndexError):\n            p[-1]\n        with pytest.raises(IndexError):\n            p[-1] = 44\n\n    def test_new_array_args(self):\n        # this tries to be closer to C: where we say \"int x[5] = {10, 20, ..}\"\n        # then here we must enclose the items in a list\n        p = ffi.new(\"int[5]\", [10, 20, 30, 40, 50])\n        assert p[0] == 10\n        assert p[1] == 20\n        assert p[2] == 30\n        assert p[3] == 40\n        assert p[4] == 50\n        p = ffi.new(\"int[4]\", [25])\n        assert p[0] == 25\n        assert p[1] == 0     # follow C convention rather than LuaJIT's\n        assert p[2] == 0\n        assert p[3] == 0\n        p = ffi.new(\"int[4]\", [ffi.cast(\"int\", -5)])\n        assert p[0] == -5\n        assert repr(p) == \"<cdata 'int[4]' owning %d bytes>\" % (4*SIZE_OF_INT)\n\n    def test_new_array_varsize(self):\n        p = ffi.new(\"int[]\", 10)     # a single integer is the length\n        assert p[9] == 0\n        with pytest.raises(IndexError):\n            p[10]\n        #\n        pytest.raises(TypeError, ffi.new, \"int[]\")\n        #\n        p = ffi.new(\"int[]\", [-6, -7])    # a list is all the items, like C\n        assert p[0] == -6\n        assert p[1] == -7\n        with pytest.raises(IndexError):\n            p[2]\n        assert repr(p) == \"<cdata 'int[]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        #\n        p = ffi.new(\"int[]\", 0)\n        with pytest.raises(IndexError):\n            p[0]\n        pytest.raises(ValueError, ffi.new, \"int[]\", -1)\n        assert repr(p) == \"<cdata 'int[]' owning 0 bytes>\"\n\n    def test_pointer_init(self):\n        n = ffi.new(\"int *\", 24)\n        a = ffi.new(\"int *[10]\", [ffi.NULL, ffi.NULL, n, n, ffi.NULL])\n        for i in range(10):\n            if i not in (2, 3):\n                assert a[i] == ffi.NULL\n        assert a[2] == a[3] == n\n\n    def test_cannot_cast(self):\n        a = ffi.new(\"short int[10]\")\n        e = pytest.raises(TypeError, ffi.new, \"long int **\", a)\n        msg = str(e.value)\n        assert \"'short[10]'\" in msg and \"'long *'\" in msg\n\n    def test_new_pointer_to_array(self):\n        a = ffi.new(\"int[4]\", [100, 102, 104, 106])\n        p = ffi.new(\"int **\", a)\n        assert p[0] == ffi.cast(\"int *\", a)\n        assert p[0][2] == 104\n        p = ffi.cast(\"int *\", a)\n        assert p[0] == 100\n        assert p[1] == 102\n        assert p[2] == 104\n        assert p[3] == 106\n        # keepalive: a\n\n    def test_pointer_direct(self):\n        p = ffi.cast(\"int*\", 0)\n        assert p is not None\n        assert bool(p) is False\n        assert p == ffi.cast(\"int*\", 0)\n        assert p != None\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        a = ffi.new(\"int[]\", [123, 456])\n        p = ffi.cast(\"int*\", a)\n        assert bool(p) is True\n        assert p == ffi.cast(\"int*\", a)\n        assert p != ffi.cast(\"int*\", 0)\n        assert p[0] == 123\n        assert p[1] == 456\n\n    def test_repr(self):\n        typerepr = \"<ctype '%s'>\"\n        p = ffi.cast(\"short unsigned int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"unsigned short int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"int*\", 0)\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        #\n        p = ffi.new(\"int*\")\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        p = ffi.new(\"int**\")\n        assert repr(p) == \"<cdata 'int * *' owning %d bytes>\" % SIZE_OF_PTR\n        assert repr(ffi.typeof(p)) == typerepr % \"int * *\"\n        p = ffi.new(\"int [2]\")\n        assert repr(p) == \"<cdata 'int[2]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        assert repr(ffi.typeof(p)) == typerepr % \"int[2]\"\n        p = ffi.new(\"int*[2][3]\")\n        assert repr(p) == \"<cdata 'int *[2][3]' owning %d bytes>\" % (\n            6*SIZE_OF_PTR)\n        assert repr(ffi.typeof(p)) == typerepr % \"int *[2][3]\"\n        p = ffi.new(\"struct repr *\")\n        assert repr(p) == \"<cdata 'struct repr *' owning %d bytes>\" % (\n            3*SIZE_OF_SHORT)\n        assert repr(ffi.typeof(p)) == typerepr % \"struct repr *\"\n        #\n        q = ffi.cast(\"short\", -123)\n        assert repr(q) == \"<cdata 'short' -123>\"\n        assert repr(ffi.typeof(q)) == typerepr % \"short\"\n        p = ffi.new(\"int*\")\n        q = ffi.cast(\"short*\", p)\n        assert repr(q).startswith(\"<cdata 'short *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"short *\"\n        p = ffi.new(\"int [2]\")\n        q = ffi.cast(\"int*\", p)\n        assert repr(q).startswith(\"<cdata 'int *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"int *\"\n        p = ffi.new(\"struct repr*\")\n        q = ffi.cast(\"struct repr *\", p)\n        assert repr(q).startswith(\"<cdata 'struct repr *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"struct repr *\"\n        prevrepr = repr(q)\n        q = q[0]\n        assert repr(q) == prevrepr.replace(' *', ' &')\n        assert repr(ffi.typeof(q)) == typerepr % \"struct repr\"\n\n    def test_new_array_of_array(self):\n        p = ffi.new(\"int[3][4]\")\n        p[0][0] = 10\n        p[2][3] = 33\n        assert p[0][0] == 10\n        assert p[2][3] == 33\n        with pytest.raises(IndexError):\n            p[1][-1]\n\n    def test_constructor_array_of_array(self):\n        p = ffi.new(\"int[3][2]\", [[10, 11], [12, 13], [14, 15]])\n        assert p[2][1] == 15\n\n    def test_new_array_of_pointer_1(self):\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_new_array_of_pointer_2(self):\n        n = ffi.new(\"int[1]\", [99])\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_char(self):\n        assert ffi.new(\"char*\", b\"\\xff\")[0] == b'\\xff'\n        assert ffi.new(\"char*\")[0] == b'\\x00'\n        assert int(ffi.cast(\"char\", 300)) == 300 - 256\n        assert not bool(ffi.cast(\"char\", 0))\n        assert bool(ffi.cast(\"char\", 1))\n        assert bool(ffi.cast(\"char\", 255))\n        pytest.raises(TypeError, ffi.new, \"char*\", 32)\n        pytest.raises(TypeError, ffi.new, \"char*\", u+\"x\")\n        pytest.raises(TypeError, ffi.new, \"char*\", b\"foo\")\n        #\n        p = ffi.new(\"char[]\", [b'a', b'b', b'\\x9c'])\n        assert len(p) == 3\n        assert p[0] == b'a'\n        assert p[1] == b'b'\n        assert p[2] == b'\\x9c'\n        p[0] = b'\\xff'\n        assert p[0] == b'\\xff'\n        p = ffi.new(\"char[]\", b\"abcd\")\n        assert len(p) == 5\n        assert p[4] == b'\\x00'    # like in C, with:  char[] p = \"abcd\";\n        #\n        p = ffi.new(\"char[4]\", b\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [b'a', b'b', b'\\x00', b'\\x00']\n        p = ffi.new(\"char[2]\", b\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [b'a', b'b']\n        pytest.raises(IndexError, ffi.new, \"char[2]\", b\"abc\")\n\n    def check_wchar_t(self, ffi):\n        try:\n            ffi.cast(\"wchar_t\", 0)\n        except NotImplementedError:\n            pytest.skip(\"NotImplementedError: wchar_t\")\n\n    def test_wchar_t(self):\n        self.check_wchar_t(ffi)\n        assert ffi.new(\"wchar_t*\", u+'x')[0] == u+'x'\n        assert ffi.new(\"wchar_t*\", u+'\\u1234')[0] == u+'\\u1234'\n        if SIZE_OF_WCHAR > 2:\n            assert ffi.new(\"wchar_t*\", u+'\\U00012345')[0] == u+'\\U00012345'\n        else:\n            pytest.raises(TypeError, ffi.new, \"wchar_t*\", u+'\\U00012345')\n        assert ffi.new(\"wchar_t*\")[0] == u+'\\x00'\n        assert int(ffi.cast(\"wchar_t\", 300)) == 300\n        assert not bool(ffi.cast(\"wchar_t\", 0))\n        assert bool(ffi.cast(\"wchar_t\", 1))\n        assert bool(ffi.cast(\"wchar_t\", 65535))\n        if SIZE_OF_WCHAR > 2:\n            assert bool(ffi.cast(\"wchar_t\", 65536))\n        pytest.raises(TypeError, ffi.new, \"wchar_t*\", 32)\n        pytest.raises(TypeError, ffi.new, \"wchar_t*\", \"foo\")\n        #\n        p = ffi.new(\"wchar_t[]\", [u+'a', u+'b', u+'\\u1234'])\n        assert len(p) == 3\n        assert p[0] == u+'a'\n        assert p[1] == u+'b' and type(p[1]) is unicode\n        assert p[2] == u+'\\u1234'\n        p[0] = u+'x'\n        assert p[0] == u+'x' and type(p[0]) is unicode\n        p[1] = u+'\\u1357'\n        assert p[1] == u+'\\u1357'\n        p = ffi.new(\"wchar_t[]\", u+\"abcd\")\n        assert len(p) == 5\n        assert p[4] == u+'\\x00'\n        p = ffi.new(\"wchar_t[]\", u+\"a\\u1234b\")\n        assert len(p) == 4\n        assert p[1] == u+'\\u1234'\n        #\n        p = ffi.new(\"wchar_t[]\", u+'\\U00023456')\n        if SIZE_OF_WCHAR == 2:\n            assert len(p) == 3\n            assert p[0] == u+'\\ud84d'\n            assert p[1] == u+'\\udc56'\n            assert p[2] == u+'\\x00'\n        else:\n            assert len(p) == 2\n            assert p[0] == u+'\\U00023456'\n            assert p[1] == u+'\\x00'\n        #\n        p = ffi.new(\"wchar_t[4]\", u+\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [u+'a', u+'b', u+'\\x00', u+'\\x00']\n        p = ffi.new(\"wchar_t[2]\", u+\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [u+'a', u+'b']\n        pytest.raises(IndexError, ffi.new, \"wchar_t[2]\", u+\"abc\")\n\n    def test_none_as_null_doesnt_work(self):\n        p = ffi.new(\"int*[1]\")\n        assert p[0] is not None\n        assert p[0] != None\n        assert p[0] == ffi.NULL\n        assert repr(p[0]) == \"<cdata 'int *' NULL>\"\n        #\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[]\", [n])\n        assert p[0][0] == 99\n        with pytest.raises(TypeError):\n            p[0] = None\n        p[0] = ffi.NULL\n        assert p[0] == ffi.NULL\n\n    def test_float(self):\n        p = ffi.new(\"float[]\", [-2, -2.5])\n        assert p[0] == -2.0\n        assert p[1] == -2.5\n        p[1] += 17.75\n        assert p[1] == 15.25\n        #\n        p = ffi.new(\"float*\", 15.75)\n        assert p[0] == 15.75\n        pytest.raises(TypeError, int, p)\n        pytest.raises(TypeError, float, p)\n        p[0] = 0.0\n        assert bool(p) is True\n        #\n        p = ffi.new(\"float*\", 1.1)\n        f = p[0]\n        assert f != 1.1      # because of rounding effect\n        assert abs(f - 1.1) < 1E-7\n        #\n        INF = 1E200 * 1E200\n        assert 1E200 != INF\n        p[0] = 1E200\n        assert p[0] == INF     # infinite, not enough precision\n\n    def test_struct_simple(self):\n        s = ffi.new(\"struct simple*\")\n        assert s.a == s.b == s.c == 0\n        s.b = -23\n        assert s.b == -23\n        with pytest.raises(OverflowError):\n            s.b = 32768\n        #\n        s = ffi.new(\"struct simple*\", [-2, -3])\n        assert s.a == -2\n        assert s.b == -3\n        assert s.c == 0\n        with pytest.raises((AttributeError, TypeError)):\n            del s.a\n        assert repr(s) == \"<cdata 'struct simple *' owning %d bytes>\" % (\n            SIZE_OF_INT + 2 * SIZE_OF_SHORT)\n        #\n        pytest.raises(ValueError, ffi.new, \"struct simple*\", [1, 2, 3, 4])\n\n    def test_constructor_struct_from_dict(self):\n        s = ffi.new(\"struct simple*\", {'b': 123, 'c': 456})\n        assert s.a == 0\n        assert s.b == 123\n        assert s.c == 456\n        pytest.raises(KeyError, ffi.new, \"struct simple*\", {'d': 456})\n\n    def test_struct_pointer(self):\n        s = ffi.new(\"struct simple*\")\n        assert s[0].a == s[0].b == s[0].c == 0\n        s[0].b = -23\n        assert s[0].b == s.b == -23\n        with pytest.raises(OverflowError):\n            s[0].b = -32769\n        with pytest.raises(IndexError):\n            s[1]\n\n    def test_struct_opaque(self):\n        pytest.raises(ffi.error, ffi.new, \"struct baz*\")\n        # should 'ffi.new(\"struct baz **\") work?  it used to, but it was\n        # not particularly useful...\n        pytest.raises(ffi.error, ffi.new, \"struct baz**\")\n\n    def test_pointer_to_struct(self):\n        s = ffi.new(\"struct simple *\")\n        s.a = -42\n        assert s[0].a == -42\n        p = ffi.new(\"struct simple **\", s)\n        assert p[0].a == -42\n        assert p[0][0].a == -42\n        p[0].a = -43\n        assert s.a == -43\n        assert s[0].a == -43\n        p[0][0].a = -44\n        assert s.a == -44\n        assert s[0].a == -44\n        s.a = -45\n        assert p[0].a == -45\n        assert p[0][0].a == -45\n        s[0].a = -46\n        assert p[0].a == -46\n        assert p[0][0].a == -46\n\n    def test_constructor_struct_of_array(self):\n        s = ffi.new(\"struct array *\", [[10, 11], [b'a', b'b', b'c']])\n        assert s.a[1] == 11\n        assert s.b[2] == b'c'\n        s.b[1] = b'X'\n        assert s.b[0] == b'a'\n        assert s.b[1] == b'X'\n        assert s.b[2] == b'c'\n\n    def test_recursive_struct(self):\n        s = ffi.new(\"struct recursive*\")\n        t = ffi.new(\"struct recursive*\")\n        s.value = 123\n        s.next = t\n        t.value = 456\n        assert s.value == 123\n        assert s.next.value == 456\n\n    def test_union_simple(self):\n        u = ffi.new(\"union simple_u*\")\n        assert u.a == u.b == u.c == 0\n        u.b = -23\n        assert u.b == -23\n        assert u.a != 0\n        with pytest.raises(OverflowError):\n            u.b = 32768\n        #\n        u = ffi.new(\"union simple_u*\", [-2])\n        assert u.a == -2\n        with pytest.raises((AttributeError, TypeError)):\n            del u.a\n        assert repr(u) == \"<cdata 'union simple_u *' owning %d bytes>\" % (\n            SIZE_OF_INT,)\n\n    def test_union_opaque(self):\n        pytest.raises(ffi.error, ffi.new, \"union baz*\")\n        # should 'ffi.new(\"union baz **\") work?  it used to, but it was\n        # not particularly useful...\n        pytest.raises(ffi.error, ffi.new, \"union baz**\")\n\n    def test_union_initializer(self):\n        pytest.raises(TypeError, ffi.new, \"union init_u*\", b'A')\n        pytest.raises(TypeError, ffi.new, \"union init_u*\", 5)\n        pytest.raises(ValueError, ffi.new, \"union init_u*\", [b'A', 5])\n        u = ffi.new(\"union init_u*\", [b'A'])\n        assert u.a == b'A'\n        pytest.raises(TypeError, ffi.new, \"union init_u*\", [1005])\n        u = ffi.new(\"union init_u*\", {'b': 12345})\n        assert u.b == 12345\n        u = ffi.new(\"union init_u*\", [])\n        assert u.a == b'\\x00'\n        assert u.b == 0\n\n    def test_sizeof_type(self):\n        for c_type, expected_size in [\n            ('char', 1),\n            ('unsigned int', 4),\n            ('char *', SIZE_OF_PTR),\n            ('int[5]', 20),\n            ('struct four_s', 12),\n            ('union four_u', 4),\n            ]:\n            size = ffi.sizeof(c_type)\n            assert size == expected_size, (size, expected_size, ctype)\n\n    def test_sizeof_cdata(self):\n        assert ffi.sizeof(ffi.new(\"short*\")) == SIZE_OF_PTR\n        assert ffi.sizeof(ffi.cast(\"short\", 123)) == SIZE_OF_SHORT\n        #\n        a = ffi.new(\"int[]\", [10, 11, 12, 13, 14])\n        assert len(a) == 5\n        assert ffi.sizeof(a) == 5 * SIZE_OF_INT\n\n    def test_string_from_char_pointer(self):\n        x = ffi.new(\"char*\", b\"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == b\"x\"\n        assert ffi.string(ffi.new(\"char*\", b\"\\x00\")) == b\"\"\n        pytest.raises(TypeError, ffi.new, \"char*\", unicode(\"foo\"))\n\n    def test_unicode_from_wchar_pointer(self):\n        self.check_wchar_t(ffi)\n        x = ffi.new(\"wchar_t*\", u+\"x\")\n        assert unicode(x) == unicode(repr(x))\n        assert ffi.string(x) == u+\"x\"\n        assert ffi.string(ffi.new(\"wchar_t*\", u+\"\\x00\")) == u+\"\"\n\n    def test_string_from_char_array(self):\n        p = ffi.new(\"char[]\", b\"hello.\")\n        p[5] = b'!'\n        assert ffi.string(p) == b\"hello!\"\n        p[6] = b'?'\n        assert ffi.string(p) == b\"hello!?\"\n        p[3] = b'\\x00'\n        assert ffi.string(p) == b\"hel\"\n        assert ffi.string(p, 2) == b\"he\"\n        with pytest.raises(IndexError):\n            p[7] = b'X'\n        #\n        a = ffi.new(\"char[]\", b\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"char *\", a)\n        assert ffi.string(p) == b'hello'\n\n    def test_string_from_wchar_array(self):\n        self.check_wchar_t(ffi)\n        assert ffi.string(ffi.cast(\"wchar_t\", \"x\")) == u+\"x\"\n        assert ffi.string(ffi.cast(\"wchar_t\", u+\"x\")) == u+\"x\"\n        x = ffi.cast(\"wchar_t\", \"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == u+\"x\"\n        #\n        p = ffi.new(\"wchar_t[]\", u+\"hello.\")\n        p[5] = u+'!'\n        assert ffi.string(p) == u+\"hello!\"\n        p[6] = u+'\\u04d2'\n        assert ffi.string(p) == u+\"hello!\\u04d2\"\n        p[3] = u+'\\x00'\n        assert ffi.string(p) == u+\"hel\"\n        assert ffi.string(p, 123) == u+\"hel\"\n        with pytest.raises(IndexError):\n            p[7] = u+'X'\n        #\n        a = ffi.new(\"wchar_t[]\", u+\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"wchar_t *\", a)\n        assert ffi.string(p) == u+'hello'\n        assert ffi.string(p, 123) == u+'hello'\n        assert ffi.string(p, 5) == u+'hello'\n        assert ffi.string(p, 2) == u+'he'\n\n    def test_fetch_const_char_p_field(self):\n        # 'const' is ignored so far, in the declaration of 'struct string'\n        t = ffi.new(\"const char[]\", b\"testing\")\n        s = ffi.new(\"struct string*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == b\"testing\"\n        with pytest.raises(TypeError):\n            s.name = None\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_fetch_const_wchar_p_field(self):\n        # 'const' is ignored so far\n        self.check_wchar_t(ffi)\n        t = ffi.new(\"const wchar_t[]\", u+\"testing\")\n        s = ffi.new(\"struct ustring*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == u+\"testing\"\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_voidp(self):\n        pytest.raises(TypeError, ffi.new, \"void*\")\n        p = ffi.new(\"void **\")\n        assert p[0] == ffi.NULL\n        a = ffi.new(\"int[]\", [10, 11, 12])\n        p = ffi.new(\"void **\", a)\n        vp = p[0]\n        with pytest.raises(TypeError):\n            vp[0]\n        pytest.raises(TypeError, ffi.new, \"short **\", a)\n        #\n        s = ffi.new(\"struct voidp *\")\n        s.p = a    # works\n        s.q = a    # works\n        with pytest.raises(TypeError):\n            s.r = a    # fails\n        b = ffi.cast(\"int *\", a)\n        s.p = b    # works\n        s.q = b    # works\n        with pytest.raises(TypeError):\n            s.r = b    # fails\n\n    def test_functionptr_simple(self):\n        pytest.raises(TypeError, ffi.callback, \"int(*)(int)\", 0)\n        def cb(n):\n            return n + 1\n        cb.__qualname__ = 'cb'\n        p = ffi.callback(\"int(*)(int)\", cb)\n        res = p(41)     # calling an 'int(*)(int)', i.e. a function pointer\n        assert res == 42 and type(res) is int\n        res = p(ffi.cast(\"int\", -41))\n        assert res == -40 and type(res) is int\n        assert repr(p).startswith(\n            \"<cdata 'int(*)(int)' calling <function cb at 0x\")\n        assert ffi.typeof(p) is ffi.typeof(\"int(*)(int)\")\n        q = ffi.new(\"int(**)(int)\", p)\n        assert repr(q) == \"<cdata 'int(* *)(int)' owning %d bytes>\" % (\n            SIZE_OF_PTR)\n        with pytest.raises(TypeError):\n            q(43)\n        res = q[0](43)\n        assert res == 44\n        q = ffi.cast(\"int(*)(int)\", p)\n        assert repr(q).startswith(\"<cdata 'int(*)(int)' 0x\")\n        res = q(45)\n        assert res == 46\n\n    def test_functionptr_advanced(self):\n        t = ffi.typeof(\"int(*(*)(int))(int)\")\n        assert repr(t) == \"<ctype '%s'>\" % \"int(*(*)(int))(int)\"\n\n    def test_functionptr_voidptr_return(self):\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res is not None\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        void_ptr = ffi.cast('void*', int_ptr)\n        def cb():\n            return void_ptr\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res == void_ptr\n\n    def test_functionptr_intptr_return(self):\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        def cb():\n            return int_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_ptr\n        int_array_ptr = ffi.new('int[1]')\n        def cb():\n            return int_array_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_array_ptr\n\n    def test_functionptr_void_return(self):\n        def foo():\n            pass\n        foo_cb = ffi.callback(\"void foo()\", foo)\n        result = foo_cb()\n        assert result is None\n\n    def test_char_cast(self):\n        p = ffi.cast(\"int\", b'\\x01')\n        assert ffi.typeof(p) is ffi.typeof(\"int\")\n        assert int(p) == 1\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"a\"))\n        assert int(p) == ord(\"a\")\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"\\x80\"))\n        assert int(p) == 0x80     # \"char\" is considered unsigned in this case\n        p = ffi.cast(\"int\", b\"\\x81\")\n        assert int(p) == 0x81\n\n    def test_wchar_cast(self):\n        self.check_wchar_t(ffi)\n        p = ffi.cast(\"int\", ffi.cast(\"wchar_t\", u+'\\u1234'))\n        assert int(p) == 0x1234\n        p = ffi.cast(\"long long\", ffi.cast(\"wchar_t\", -1))\n        if SIZE_OF_WCHAR == 2:      # 2 bytes, unsigned\n            assert int(p) == 0xffff\n        elif (sys.platform.startswith('linux') and\n              platform.machine().startswith('x86')):   # known to be signed\n            assert int(p) == -1\n        else:                     # in general, it can be either signed or not\n            assert int(p) in [-1, 0xffffffff]  # e.g. on arm, both cases occur\n        p = ffi.cast(\"int\", u+'\\u1234')\n        assert int(p) == 0x1234\n\n    def test_cast_array_to_charp(self):\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"char*\", a)\n        data = b''.join([p[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_between_pointers(self):\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"short*\", a)\n        p2 = ffi.cast(\"int*\", p)\n        q = ffi.cast(\"char*\", p2)\n        data = b''.join([q[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_pointer_and_int(self):\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        l1 = ffi.cast(\"intptr_t\", a)\n        p = ffi.cast(\"short*\", a)\n        l2 = ffi.cast(\"intptr_t\", p)\n        assert int(l1) == int(l2) != 0\n        q = ffi.cast(\"short*\", l1)\n        assert q == ffi.cast(\"short*\", int(l1))\n        assert q[0] == 0x1234\n        assert int(ffi.cast(\"intptr_t\", ffi.NULL)) == 0\n\n    def test_cast_functionptr_and_int(self):\n        def cb(n):\n            return n + 1\n        a = ffi.callback(\"int(*)(int)\", cb)\n        p = ffi.cast(\"void *\", a)\n        assert p\n        b = ffi.cast(\"int(*)(int)\", p)\n        assert b(41) == 42\n        assert a == b\n        assert hash(a) == hash(b)\n\n    def test_callback_crash(self):\n        def cb(n):\n            raise Exception\n        a = ffi.callback(\"int(*)(int)\", cb, error=42)\n        res = a(1)    # and the error reported to stderr\n        assert res == 42\n\n    def test_structptr_argument(self):\n        def cb(p):\n            return p[0].a * 1000 + p[0].b * 100 + p[1].a * 10 + p[1].b\n        a = ffi.callback(\"int(*)(struct ab[])\", cb)\n        res = a([[5, 6], {'a': 7, 'b': 8}])\n        assert res == 5678\n        res = a([[5], {'b': 8}])\n        assert res == 5008\n\n    def test_array_argument_as_list(self):\n        seen = []\n        def cb(argv):\n            seen.append(ffi.string(argv[0]))\n            seen.append(ffi.string(argv[1]))\n        a = ffi.callback(\"void(*)(char *[])\", cb)\n        a([ffi.new(\"char[]\", b\"foobar\"), ffi.new(\"char[]\", b\"baz\")])\n        assert seen == [b\"foobar\", b\"baz\"]\n\n    def test_cast_float(self):\n        a = ffi.cast(\"float\", 12)\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", 12.5)\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", b\"A\")\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", 12.9)\n        assert int(a) == 12\n        a = ffi.cast(\"char\", 66.9 + 256)\n        assert ffi.string(a) == b\"B\"\n        #\n        a = ffi.cast(\"float\", ffi.cast(\"int\", 12))\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", ffi.cast(\"double\", 12.5))\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", ffi.cast(\"char\", b\"A\"))\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", ffi.cast(\"double\", 12.9))\n        assert int(a) == 12\n        a = ffi.cast(\"char\", ffi.cast(\"double\", 66.9 + 256))\n        assert ffi.string(a) == b\"B\"\n\n    def test_enum(self):\n        # enum foq { A0, B0, CC0, D0 };\n        assert ffi.string(ffi.cast(\"enum foq\", 0)) == \"cffiA0\"\n        assert ffi.string(ffi.cast(\"enum foq\", 2)) == \"cffiCC0\"\n        assert ffi.string(ffi.cast(\"enum foq\", 3)) == \"cffiD0\"\n        assert ffi.string(ffi.cast(\"enum foq\", 4)) == \"4\"\n        # enum bar { A1, B1=-2, CC1, D1, E1 };\n        assert ffi.string(ffi.cast(\"enum bar\", 0)) == \"A1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -2)) == \"B1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -1)) == \"CC1\"\n        assert ffi.string(ffi.cast(\"enum bar\", 1)) == \"E1\"\n        assert ffi.cast(\"enum bar\", -2) == ffi.cast(\"enum bar\", -2)\n        assert ffi.cast(\"enum foq\", 0) == ffi.cast(\"enum bar\", 0)\n        assert ffi.cast(\"enum bar\", 0) == ffi.cast(\"int\", 0)\n        assert repr(ffi.cast(\"enum bar\", -1)) == \"<cdata 'enum bar' -1: CC1>\"\n        assert repr(ffi.cast(\"enum foq\", -1)) == (  # enums are unsigned, if\n            \"<cdata 'enum foq' 4294967295>\") or (   # they contain no neg value\n                sys.platform == \"win32\")            # (but not on msvc)\n        # enum baz { A2=0x1000, B2=0x2000 };\n        assert ffi.string(ffi.cast(\"enum baz\", 0x1000)) == \"A2\"\n        assert ffi.string(ffi.cast(\"enum baz\", 0x2000)) == \"B2\"\n\n    def test_enum_in_struct(self):\n        # enum foo2 { A3, B3, C3, D3 };\n        # struct bar_with_e { enum foo2 e; };\n        s = ffi.new(\"struct bar_with_e *\")\n        s.e = 0\n        assert s.e == 0\n        s.e = 3\n        assert s.e == 3\n        assert s[0].e == 3\n        s[0].e = 2\n        assert s.e == 2\n        assert s[0].e == 2\n        s.e = ffi.cast(\"enum foo2\", -1)\n        assert s.e in (4294967295, -1)     # two choices\n        assert s[0].e in (4294967295, -1)\n        s.e = s.e\n        with pytest.raises(TypeError):\n            s.e = 'B3'\n        with pytest.raises(TypeError):\n            s.e = '2'\n        with pytest.raises(TypeError):\n            s.e = '#2'\n        with pytest.raises(TypeError):\n            s.e = '#7'\n\n    def test_enum_non_contiguous(self):\n        # enum noncont { A4, B4=42, C4 };\n        assert ffi.string(ffi.cast(\"enum noncont\", 0)) == \"A4\"\n        assert ffi.string(ffi.cast(\"enum noncont\", 42)) == \"B4\"\n        assert ffi.string(ffi.cast(\"enum noncont\", 43)) == \"C4\"\n        invalid_value = ffi.cast(\"enum noncont\", 2)\n        assert int(invalid_value) == 2\n        assert ffi.string(invalid_value) == \"2\"\n\n    def test_enum_char_hex_oct(self):\n        # enum etypes {A5='!', B5='\\'', C5=0x10, D5=010, E5=- 0x10, F5=-010};\n        assert ffi.string(ffi.cast(\"enum etypes\", ord('!'))) == \"A5\"\n        assert ffi.string(ffi.cast(\"enum etypes\", ord(\"'\"))) == \"B5\"\n        assert ffi.string(ffi.cast(\"enum etypes\", 16)) == \"C5\"\n        assert ffi.string(ffi.cast(\"enum etypes\", 8)) == \"D5\"\n        assert ffi.string(ffi.cast(\"enum etypes\", -16)) == \"E5\"\n        assert ffi.string(ffi.cast(\"enum etypes\", -8)) == \"F5\"\n\n    def test_array_of_struct(self):\n        s = ffi.new(\"struct ab[1]\")\n        with pytest.raises(AttributeError):\n            s.b\n        with pytest.raises(AttributeError):\n            s.b = 412\n        s[0].b = 412\n        assert s[0].b == 412\n        with pytest.raises(IndexError):\n            s[1]\n\n    def test_pointer_to_array(self):\n        p = ffi.new(\"int(**)[5]\")\n        assert repr(p) == \"<cdata 'int(* *)[5]' owning %d bytes>\" % SIZE_OF_PTR\n\n    def test_iterate_array(self):\n        a = ffi.new(\"char[]\", b\"hello\")\n        assert list(a) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        assert list(iter(a)) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        #\n        pytest.raises(TypeError, iter, ffi.cast(\"char *\", a))\n        pytest.raises(TypeError, list, ffi.cast(\"char *\", a))\n        pytest.raises(TypeError, iter, ffi.new(\"int *\"))\n        pytest.raises(TypeError, list, ffi.new(\"int *\"))\n\n    def test_offsetof(self):\n        # struct abc { int a, b, c; };\n        assert ffi.offsetof(\"struct abc\", \"a\") == 0\n        assert ffi.offsetof(\"struct abc\", \"b\") == 4\n        assert ffi.offsetof(\"struct abc\", \"c\") == 8\n\n    def test_offsetof_nested(self):\n        # struct nesting { struct abc d, e; };\n        assert ffi.offsetof(\"struct nesting\", \"e\") == 12\n        pytest.raises(KeyError, ffi.offsetof, \"struct nesting\", \"e.a\")\n        assert ffi.offsetof(\"struct nesting\", \"e\", \"a\") == 12\n        assert ffi.offsetof(\"struct nesting\", \"e\", \"b\") == 16\n        assert ffi.offsetof(\"struct nesting\", \"e\", \"c\") == 20\n\n    def test_offsetof_array(self):\n        assert ffi.offsetof(\"int[]\", 51) == 51 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"int *\", 51) == 51 * ffi.sizeof(\"int\")\n        # struct array2 { int a, b; int c[99]; };\n        assert ffi.offsetof(\"struct array2\", \"c\") == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct array2\", \"c\", 0) == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct array2\", \"c\", 51) == 53 * ffi.sizeof(\"int\")\n\n    def test_alignof(self):\n        # struct align { char a; short b; char c; };\n        assert ffi.alignof(\"int\") == 4\n        assert ffi.alignof(\"double\") in (4, 8)\n        assert ffi.alignof(\"struct align\") == 2\n\n    def test_bitfield(self):\n        # struct bitfield { int a:10, b:20, c:3; };\n        assert ffi.sizeof(\"struct bitfield\") == 8\n        s = ffi.new(\"struct bitfield *\")\n        s.a = 511\n        with pytest.raises(OverflowError):\n            s.a = 512\n        with pytest.raises(OverflowError):\n            s[0].a = 512\n        assert s.a == 511\n        s.a = -512\n        with pytest.raises(OverflowError):\n            s.a = -513\n        with pytest.raises(OverflowError):\n            s[0].a = -513\n        assert s.a == -512\n        s.c = 3\n        assert s.c == 3\n        with pytest.raises(OverflowError):\n            s.c = 4\n        with pytest.raises(OverflowError):\n            s[0].c = 4\n        s.c = -4\n        assert s.c == -4\n\n    def test_bitfield_enum(self):\n        # typedef enum { AA1, BB1, CC1 } foo_e_t;\n        # typedef struct { foo_e_t f:2; } bfenum_t;\n        if sys.platform == \"win32\":\n            pytest.skip(\"enums are not unsigned\")\n        s = ffi.new(\"bfenum_t *\")\n        s.f = 2\n        assert s.f == 2\n\n    def test_anonymous_struct(self):\n        # typedef struct { int a; } anon_foo_t;\n        # typedef struct { char b, c; } anon_bar_t;\n        f = ffi.new(\"anon_foo_t *\", [12345])\n        b = ffi.new(\"anon_bar_t *\", [b\"B\", b\"C\"])\n        assert f.a == 12345\n        assert b.b == b\"B\"\n        assert b.c == b\"C\"\n        assert repr(b).startswith(\"<cdata 'anon_bar_t *'\")\n\n    def test_struct_with_two_usages(self):\n        # typedef struct named_foo_s { int a; } named_foo_t, *named_foo_p;\n        # typedef struct { int a; } unnamed_foo_t, *unnamed_foo_p;\n        f = ffi.new(\"named_foo_t *\", [12345])\n        ps = ffi.new(\"named_foo_p[]\", [f])\n        f = ffi.new(\"unnamed_foo_t *\", [12345])\n        ps = ffi.new(\"unnamed_foo_p[]\", [f])\n\n    def test_pointer_arithmetic(self):\n        s = ffi.new(\"short[]\", list(range(100, 110)))\n        p = ffi.cast(\"short *\", s)\n        assert p[2] == 102\n        assert p+1 == p+1\n        assert p+1 != p+0\n        assert p == p+0 == p-0\n        assert (p+1)[0] == 101\n        assert (p+19)[-10] == 109\n        assert (p+5) - (p+1) == 4\n        assert p == s+0\n        assert p+1 == s+1\n\n    def test_pointer_comparison(self):\n        s = ffi.new(\"short[]\", list(range(100)))\n        p = ffi.cast(\"short *\", s)\n        assert (p <  s) is False\n        assert (p <= s) is True\n        assert (p == s) is True\n        assert (p != s) is False\n        assert (p >  s) is False\n        assert (p >= s) is True\n        assert (s <  p) is False\n        assert (s <= p) is True\n        assert (s == p) is True\n        assert (s != p) is False\n        assert (s >  p) is False\n        assert (s >= p) is True\n        q = p + 1\n        assert (q <  s) is False\n        assert (q <= s) is False\n        assert (q == s) is False\n        assert (q != s) is True\n        assert (q >  s) is True\n        assert (q >= s) is True\n        assert (s <  q) is True\n        assert (s <= q) is True\n        assert (s == q) is False\n        assert (s != q) is True\n        assert (s >  q) is False\n        assert (s >= q) is False\n        assert (q <  p) is False\n        assert (q <= p) is False\n        assert (q == p) is False\n        assert (q != p) is True\n        assert (q >  p) is True\n        assert (q >= p) is True\n        assert (p <  q) is True\n        assert (p <= q) is True\n        assert (p == q) is False\n        assert (p != q) is True\n        assert (p >  q) is False\n        assert (p >= q) is False\n        #\n        assert (None == s) is False\n        assert (None != s) is True\n        assert (s == None) is False\n        assert (s != None) is True\n        assert (None == q) is False\n        assert (None != q) is True\n        assert (q == None) is False\n        assert (q != None) is True\n\n    def test_integer_comparison(self):\n        x = ffi.cast(\"int\", 123)\n        y = ffi.cast(\"int\", 456)\n        assert x < y\n        #\n        z = ffi.cast(\"double\", 78.9)\n        assert x > z\n        assert y > z\n\n    def test_ffi_buffer_ptr(self):\n        a = ffi.new(\"short *\", 100)\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        content = b[:]\n        assert len(content) == len(b) == 2\n        if sys.byteorder == 'little':\n            assert content == b'\\x64\\x00'\n            assert b[0] == b'\\x64'\n            b[0] = b'\\x65'\n        else:\n            assert content == b'\\x00\\x64'\n            assert b[1] == b'\\x64'\n            b[1] = b'\\x65'\n        assert a[0] == 101\n\n    def test_ffi_buffer_array(self):\n        a = ffi.new(\"int[]\", list(range(100, 110)))\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        content = b[:]\n        if sys.byteorder == 'little':\n            assert content.startswith(b'\\x64\\x00\\x00\\x00\\x65\\x00\\x00\\x00')\n            b[4] = b'\\x45'\n        else:\n            assert content.startswith(b'\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x65')\n            b[7] = b'\\x45'\n        assert len(content) == 4 * 10\n        assert a[1] == 0x45\n\n    def test_ffi_buffer_ptr_size(self):\n        a = ffi.new(\"short *\", 0x4243)\n        try:\n            b = ffi.buffer(a, 1)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        content = b[:]\n        assert len(content) == 1\n        if sys.byteorder == 'little':\n            assert content == b'\\x43'\n            b[0] = b'\\x62'\n            assert a[0] == 0x4262\n        else:\n            assert content == b'\\x42'\n            b[0] = b'\\x63'\n            assert a[0] == 0x6343\n\n    def test_ffi_buffer_array_size(self):\n        a1 = ffi.new(\"int[]\", list(range(100, 110)))\n        a2 = ffi.new(\"int[]\", list(range(100, 115)))\n        try:\n            ffi.buffer(a1)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        assert ffi.buffer(a1)[:] == ffi.buffer(a2, 4*10)[:]\n\n    def test_ffi_buffer_with_file(self):\n        import tempfile, os, array\n        fd, filename = tempfile.mkstemp()\n        f = os.fdopen(fd, 'r+b')\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == arraytostring(array.array('i', range(1000)))\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n        os.unlink(filename)\n\n    def test_ffi_buffer_with_io(self):\n        import io, array\n        f = io.BytesIO()\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == arraytostring(array.array('i', range(1000)))\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n\n    def test_array_in_struct(self):\n        # struct array { int a[2]; char b[3]; };\n        p = ffi.new(\"struct array *\")\n        p.a[1] = 5\n        assert p.a[1] == 5\n        assert repr(p.a).startswith(\"<cdata 'int[2]' 0x\")\n\n    def test_struct_containing_array_varsize_workaround(self):\n        if sys.platform == \"win32\":\n            pytest.skip(\"array of length 0 not supported\")\n        # struct array0 { int len; short data[0]; };\n        p = ffi.new(\"char[]\", ffi.sizeof(\"struct array0\") + 7 * SIZE_OF_SHORT)\n        q = ffi.cast(\"struct array0 *\", p)\n        assert q.len == 0\n        # 'q.data' gets not a 'short[0]', but just a 'short *' instead\n        assert repr(q.data).startswith(\"<cdata 'short *' 0x\")\n        assert q.data[6] == 0\n        q.data[6] = 15\n        assert q.data[6] == 15\n\n    def test_new_struct_containing_array_varsize(self):\n        pytest.skip(\"later?\")\n        ffi.cdef(\"struct foo_s { int len; short data[]; };\")\n        p = ffi.new(\"struct foo_s *\", 10)     # a single integer is the length\n        assert p.len == 0\n        assert p.data[9] == 0\n        with pytest.raises(IndexError):\n            p.data[10]\n\n    def test_ffi_typeof_getcname(self):\n        assert ffi.getctype(\"int\") == \"int\"\n        assert ffi.getctype(\"int\", 'x') == \"int x\"\n        assert ffi.getctype(\"int*\") == \"int *\"\n        assert ffi.getctype(\"int*\", '') == \"int *\"\n        assert ffi.getctype(\"int*\", 'x') == \"int * x\"\n        assert ffi.getctype(\"int\", '*') == \"int *\"\n        assert ffi.getctype(\"int\", ' * x ') == \"int * x\"\n        assert ffi.getctype(ffi.typeof(\"int*\"), '*') == \"int * *\"\n        assert ffi.getctype(\"int\", '[5]') == \"int[5]\"\n        assert ffi.getctype(\"int[5]\", '[6]') == \"int[6][5]\"\n        assert ffi.getctype(\"int[5]\", '(*)') == \"int(*)[5]\"\n        # special-case for convenience: automatically put '()' around '*'\n        assert ffi.getctype(\"int[5]\", '*') == \"int(*)[5]\"\n        assert ffi.getctype(\"int[5]\", '*foo') == \"int(*foo)[5]\"\n        assert ffi.getctype(\"int[5]\", ' ** foo ') == \"int(** foo)[5]\"\n\n    def test_array_of_func_ptr(self):\n        f = ffi.cast(\"int(*)(int)\", 42)\n        assert f != ffi.NULL\n        pytest.raises(ffi.error, ffi.cast, \"int(int)\", 42)\n        pytest.raises(ffi.error, ffi.new, \"int([5])(int)\")\n        a = ffi.new(\"int(*[5])(int)\", [f])\n        assert ffi.getctype(ffi.typeof(a)) == \"int(*[5])(int)\"\n        assert len(a) == 5\n        assert a[0] == f\n        assert a[1] == ffi.NULL\n        pytest.raises(TypeError, ffi.cast, \"int(*)(int)[5]\", 0)\n        #\n        def cb(n):\n            return n + 1\n        f = ffi.callback(\"int(*)(int)\", cb)\n        a = ffi.new(\"int(*[5])(int)\", [f, f])\n        assert a[1](42) == 43\n\n    def test_callback_as_function_argument(self):\n        # In C, function arguments can be declared with a function type,\n        # which is automatically replaced with the ptr-to-function type.\n        def cb(a, b):\n            return chr(ord(a) + ord(b)).encode()\n        f = ffi.callback(\"char cb(char, char)\", cb)\n        assert f(b'A', b'\\x01') == b'B'\n        def g(callback):\n            return callback(b'A', b'\\x01')\n        g = ffi.callback(\"char g(char cb(char, char))\", g)\n        assert g(f) == b'B'\n\n    def test_vararg_callback(self):\n        pytest.skip(\"callback with '...'\")\n        def cb(i, va_list):\n            j = ffi.va_arg(va_list, \"int\")\n            k = ffi.va_arg(va_list, \"long long\")\n            return i * 2 + j * 3 + k * 5\n        f = ffi.callback(\"long long cb(long i, ...)\", cb)\n        res = f(10, ffi.cast(\"int\", 100), ffi.cast(\"long long\", 1000))\n        assert res == 20 + 300 + 5000\n\n    def test_callback_decorator(self):\n        #\n        @ffi.callback(\"long(long, long)\", error=42)\n        def cb(a, b):\n            return a - b\n        #\n        assert cb(-100, -10) == -90\n        sz = ffi.sizeof(\"long\")\n        assert cb((1 << (sz*8-1)) - 1, -10) == 42\n\n    def test_anonymous_enum(self):\n        # typedef enum { Value0 = 0 } e_t, *pe_t;\n        assert ffi.getctype(\"e_t*\") == 'e_t *'\n        assert ffi.getctype(\"pe_t\") == 'e_t *'\n        assert ffi.getctype(\"foo_e_t*\") == 'foo_e_t *'\n\n    def test_new_ctype(self):\n        p = ffi.new(\"int *\")\n        pytest.raises(TypeError, ffi.new, p)\n        p = ffi.new(ffi.typeof(\"int *\"), 42)\n        assert p[0] == 42\n\n    def test_enum_with_non_injective_mapping(self):\n        # enum e_noninj { AA3=0, BB3=0, CC3=0, DD3=0 };\n        e = ffi.cast(\"enum e_noninj\", 0)\n        assert ffi.string(e) == \"AA3\"     # pick the first one arbitrarily\n\n    def test_enum_refer_previous_enum_value(self):\n        # enum e_prev { AA4, BB4=2, CC4=4, DD4=BB4, EE4, FF4=CC4, GG4=FF4 };\n        assert ffi.string(ffi.cast(\"enum e_prev\", 2)) == \"BB4\"\n        assert ffi.string(ffi.cast(\"enum e_prev\", 3)) == \"EE4\"\n        assert ffi.sizeof(\"char[DD4]\") == 2\n        assert ffi.sizeof(\"char[EE4]\") == 3\n        assert ffi.sizeof(\"char[FF4]\") == 4\n        assert ffi.sizeof(\"char[GG4]\") == 4\n\n    def test_nested_anonymous_struct(self):\n        # struct nested_anon {\n        #     struct { int a, b; };\n        #     union { int c, d; };\n        # };\n        assert ffi.sizeof(\"struct nested_anon\") == 3 * SIZE_OF_INT\n        p = ffi.new(\"struct nested_anon *\", [1, 2, 3])\n        assert p.a == 1\n        assert p.b == 2\n        assert p.c == 3\n        assert p.d == 3\n        p.d = 17\n        assert p.c == 17\n        p.b = 19\n        assert p.a == 1\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"struct nested_anon *\", {'b': 12, 'd': 14})\n        assert p.a == 0\n        assert p.b == 12\n        assert p.c == 14\n        assert p.d == 14\n\n    def test_nested_field_offset_align(self):\n        # struct nested_field_ofs_s {\n        #    struct { int a; char b; };\n        #    union { char c; };\n        # };\n        assert ffi.offsetof(\"struct nested_field_ofs_s\", \"c\") == 2 * SIZE_OF_INT\n        assert ffi.sizeof(\"struct nested_field_ofs_s\") == 3 * SIZE_OF_INT\n\n    def test_nested_anonymous_union(self):\n        # union nested_anon_u {\n        #     struct { int a, b; };\n        #     union { int c, d; };\n        # };\n        assert ffi.sizeof(\"union nested_anon_u\") == 2 * SIZE_OF_INT\n        p = ffi.new(\"union nested_anon_u *\", [5])\n        assert p.a == 5\n        assert p.b == 0\n        assert p.c == 5\n        assert p.d == 5\n        p.d = 17\n        assert p.c == 17\n        assert p.a == 17\n        p.b = 19\n        assert p.a == 17\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"union nested_anon_u *\", {'d': 14})\n        assert p.a == 14\n        assert p.b == 0\n        assert p.c == 14\n        assert p.d == 14\n        p = ffi.new(\"union nested_anon_u *\", {'b': 12})\n        assert p.a == 0\n        assert p.b == 12\n        assert p.c == 0\n        assert p.d == 0\n        # we cannot specify several items in the dict, even though\n        # in theory in this particular case it would make sense\n        # to give both 'a' and 'b'\n\n    def test_cast_to_array_type(self):\n        p = ffi.new(\"int[4]\", [-5])\n        q = ffi.cast(\"int[3]\", p)\n        assert q[0] == -5\n        assert repr(q).startswith(\"<cdata 'int[3]' 0x\")\n\n    def test_gc(self):\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        def destructor(p1):\n            assert p1 is p\n            assert p1[0] == 123\n            seen.append(1)\n        q = ffi.gc(p, destructor=destructor)\n        import gc; gc.collect()\n        assert seen == []\n        del q\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [1]\n\n    def test_gc_2(self):\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q2\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [2, 1]\n\n    def test_gc_3(self):\n        p = ffi.new(\"int *\", 123)\n        r = ffi.new(\"int *\", 123)\n        seen = []\n        seen_r = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        s1 = ffi.gc(r, lambda r: seen_r.append(4))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        s2 = ffi.gc(s1, lambda r: seen_r.append(5))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        assert seen_r == []\n        del q1, q2, q3, s2, s1\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3, 2, 1]\n        assert seen_r == [5, 4]\n\n    def test_gc_4(self):\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q3     # q2 remains, and has a hard ref to q1\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3]\n\n    def test_release(self):\n        p = ffi.new(\"int[]\", 123)\n        ffi.release(p)\n        # here, reading p[0] might give garbage or segfault...\n        ffi.release(p)   # no effect\n\n    def test_release_new_allocator(self):\n        seen = []\n        def myalloc(size):\n            seen.append(size)\n            return ffi.new(\"char[]\", b\"X\" * size)\n        def myfree(raw):\n            seen.append(raw)\n        alloc2 = ffi.new_allocator(alloc=myalloc, free=myfree)\n        p = alloc2(\"int[]\", 15)\n        assert seen == [15 * 4]\n        ffi.release(p)\n        assert seen == [15 * 4, p]\n        ffi.release(p)    # no effect\n        assert seen == [15 * 4, p]\n        #\n        del seen[:]\n        p = alloc2(\"struct ab *\")\n        assert seen == [2 * 4]\n        ffi.release(p)\n        assert seen == [2 * 4, p]\n        ffi.release(p)    # no effect\n        assert seen == [2 * 4, p]\n\n    def test_CData_CType(self):\n        assert isinstance(ffi.cast(\"int\", 0), ffi.CData)\n        assert isinstance(ffi.new(\"int *\"), ffi.CData)\n        assert not isinstance(ffi.typeof(\"int\"), ffi.CData)\n        assert not isinstance(ffi.cast(\"int\", 0), ffi.CType)\n        assert not isinstance(ffi.new(\"int *\"), ffi.CType)\n\n    def test_CData_CType_2(self):\n        assert isinstance(ffi.typeof(\"int\"), ffi.CType)\n\n    def test_bool(self):\n        assert int(ffi.cast(\"_Bool\", 0.1)) == 1\n        assert int(ffi.cast(\"_Bool\", -0.0)) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x02')) == 1\n        assert int(ffi.cast(\"_Bool\", b'\\x00')) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x80')) == 1\n        assert ffi.new(\"_Bool *\", False)[0] == 0\n        assert ffi.new(\"_Bool *\", 1)[0] == 1\n        pytest.raises(OverflowError, ffi.new, \"_Bool *\", 2)\n        pytest.raises(TypeError, ffi.string, ffi.cast(\"_Bool\", 2))\n\n    def test_addressof(self):\n        p = ffi.new(\"struct ab *\")\n        a = ffi.addressof(p[0])\n        assert repr(a).startswith(\"<cdata 'struct ab *' 0x\")\n        assert a == p\n        pytest.raises(TypeError, ffi.addressof, p)\n        pytest.raises((AttributeError, TypeError), ffi.addressof, 5)\n        pytest.raises(TypeError, ffi.addressof, ffi.cast(\"int\", 5))\n\n    def test_addressof_field(self):\n        p = ffi.new(\"struct ab *\")\n        b = ffi.addressof(p[0], 'b')\n        assert repr(b).startswith(\"<cdata 'int *' 0x\")\n        assert int(ffi.cast(\"uintptr_t\", b)) == (\n            int(ffi.cast(\"uintptr_t\", p)) + ffi.sizeof(\"int\"))\n        assert b == ffi.addressof(p, 'b')\n        assert b != ffi.addressof(p, 'a')\n\n    def test_addressof_field_nested(self):\n        # struct nesting { struct abc d, e; };\n        p = ffi.new(\"struct nesting *\")\n        pytest.raises(KeyError, ffi.addressof, p[0], 'e.b')\n        a = ffi.addressof(p[0], 'e', 'b')\n        assert int(ffi.cast(\"uintptr_t\", a)) == (\n            int(ffi.cast(\"uintptr_t\", p)) +\n            ffi.sizeof(\"struct abc\") + ffi.sizeof(\"int\"))\n\n    def test_addressof_anonymous_struct(self):\n        # typedef struct { int a; } anon_foo_t;\n        p = ffi.new(\"anon_foo_t *\")\n        a = ffi.addressof(p[0])\n        assert a == p\n\n    def test_addressof_array(self):\n        p = ffi.new(\"int[52]\")\n        p0 = ffi.addressof(p)\n        assert p0 == p\n        assert ffi.typeof(p0) is ffi.typeof(\"int(*)[52]\")\n        pytest.raises(TypeError, ffi.addressof, p0)\n        #\n        p1 = ffi.addressof(p, 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert (p1 - p) == 25\n        assert ffi.addressof(p, 0) == p\n\n    def test_addressof_pointer(self):\n        array = ffi.new(\"int[50]\")\n        p = ffi.cast(\"int *\", array)\n        pytest.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n        #\n        array = ffi.new(\"struct ab[50]\")\n        p = ffi.cast(\"int *\", array)\n        pytest.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n\n    def test_addressof_array_in_struct(self):\n        # struct abc50 { int a, b; int c[50]; };\n        p = ffi.new(\"struct abc50 *\")\n        p1 = ffi.addressof(p, \"c\", 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert p1 == ffi.cast(\"int *\", p) + 27\n        assert ffi.addressof(p, \"c\") == ffi.cast(\"int *\", p) + 2\n        assert ffi.addressof(p, \"c\", 0) == ffi.cast(\"int *\", p) + 2\n        p2 = ffi.addressof(p, 1)\n        assert ffi.typeof(p2) is ffi.typeof(\"struct abc50 *\")\n        assert p2 == p + 1\n\n    def test_multiple_independent_structs(self):\n        CDEF2 = \"struct ab { int x; };\"\n        ffi2 = cffi.FFI(); ffi2.cdef(CDEF2)\n        outputfilename = recompile(ffi2, \"test_multiple_independent_structs\",\n                                   CDEF2, tmpdir=str(udir))\n        module = load_dynamic(\"test_multiple_independent_structs\",\n                                  outputfilename)\n        ffi1 = module.ffi\n        foo1 = ffi1.new(\"struct ab *\", [10])\n        foo2 = ffi .new(\"struct ab *\", [20, 30])\n        assert foo1.x == 10\n        assert foo2.a == 20\n        assert foo2.b == 30\n\n    def test_include_struct_union_enum_typedef(self):\n        ffi1, CCODE = construction_params\n        ffi2 = cffi.FFI()\n        ffi2.include(ffi1)\n        outputfilename = recompile(ffi2,\n                                   \"test_include_struct_union_enum_typedef\",\n                                   CCODE, tmpdir=str(udir))\n        module = load_dynamic(\"test_include_struct_union_enum_typedef\",\n                                  outputfilename)\n        ffi2 = module.ffi\n        #\n        p = ffi2.new(\"struct nonpacked *\", [b'A', -43141])\n        assert p.a == b'A'\n        assert p.b == -43141\n        #\n        p = ffi.new(\"union simple_u *\", [-52525])\n        assert p.a == -52525\n        #\n        p = ffi.cast(\"enum foq\", 2)\n        assert ffi.string(p) == \"cffiCC0\"\n        assert ffi2.sizeof(\"char[cffiCC0]\") == 2\n        #\n        p = ffi.new(\"anon_foo_t *\", [-52526])\n        assert p.a == -52526\n        p = ffi.new(\"named_foo_p\", [-52527])\n        assert p.a == -52527\n\n    def test_struct_packed(self):\n        # struct nonpacked { char a; int b; };\n        # struct is_packed { char a; int b; } __attribute__((packed));\n        assert ffi.sizeof(\"struct nonpacked\") == 8\n        assert ffi.sizeof(\"struct is_packed\") == 5\n        assert ffi.alignof(\"struct nonpacked\") == 4\n        assert ffi.alignof(\"struct is_packed\") == 1\n        s = ffi.new(\"struct is_packed[2]\")\n        s[0].b = 42623381\n        s[0].a = b'X'\n        s[1].b = -4892220\n        s[1].a = b'Y'\n        assert s[0].b == 42623381\n        assert s[0].a == b'X'\n        assert s[1].b == -4892220\n        assert s[1].a == b'Y'\n\n    def test_not_supported_bitfield_in_result(self):\n        # struct ints_and_bitfield { int a,b,c,d,e; int x:1; };\n        e = pytest.raises(NotImplementedError, ffi.callback,\n                           \"struct ints_and_bitfield foo(void)\", lambda: 42)\n        assert str(e.value) == (\"struct ints_and_bitfield(*)(): \"\n            \"callback with unsupported argument or return type or with '...'\")\n\n    def test_inspecttype(self):\n        assert ffi.typeof(\"long\").kind == \"primitive\"\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").cname == (\n            \"long(*)(long, long * *, ...)\")\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").ellipsis is True\n\n    def test_new_handle(self):\n        o = [2, 3, 4]\n        p = ffi.new_handle(o)\n        assert ffi.typeof(p) == ffi.typeof(\"void *\")\n        assert ffi.from_handle(p) is o\n        assert ffi.from_handle(ffi.cast(\"char *\", p)) is o\n        pytest.raises(RuntimeError, ffi.from_handle, ffi.NULL)\n\n    def test_struct_array_no_length(self):\n        # struct array_no_length { int x; int a[]; };\n        p = ffi.new(\"struct array_no_length *\", [100, [200, 300, 400]])\n        assert p.x == 100\n        assert ffi.typeof(p.a) is ffi.typeof(\"int[]\")   # length available\n        assert p.a[0] == 200\n        assert p.a[1] == 300\n        assert p.a[2] == 400\n        assert len(p.a) == 3\n        assert list(p.a) == [200, 300, 400]\n        q = ffi.cast(\"struct array_no_length *\", p)\n        assert ffi.typeof(q.a) is ffi.typeof(\"int *\")   # no length available\n        assert q.a[0] == 200\n        assert q.a[1] == 300\n        assert q.a[2] == 400\n        pytest.raises(TypeError, len, q.a)\n        pytest.raises(TypeError, list, q.a)\n\n    def test_all_primitives(self):\n        assert set(PRIMITIVE_TO_INDEX) == set([\n            \"char\",\n            \"short\",\n            \"int\",\n            \"long\",\n            \"long long\",\n            \"signed char\",\n            \"unsigned char\",\n            \"unsigned short\",\n            \"unsigned int\",\n            \"unsigned long\",\n            \"unsigned long long\",\n            \"float\",\n            \"double\",\n            \"long double\",\n            \"wchar_t\",\n            \"char16_t\",\n            \"char32_t\",\n            \"_Bool\",\n            \"int8_t\",\n            \"uint8_t\",\n            \"int16_t\",\n            \"uint16_t\",\n            \"int32_t\",\n            \"uint32_t\",\n            \"int64_t\",\n            \"uint64_t\",\n            \"int_least8_t\",\n            \"uint_least8_t\",\n            \"int_least16_t\",\n            \"uint_least16_t\",\n            \"int_least32_t\",\n            \"uint_least32_t\",\n            \"int_least64_t\",\n            \"uint_least64_t\",\n            \"int_fast8_t\",\n            \"uint_fast8_t\",\n            \"int_fast16_t\",\n            \"uint_fast16_t\",\n            \"int_fast32_t\",\n            \"uint_fast32_t\",\n            \"int_fast64_t\",\n            \"uint_fast64_t\",\n            \"intptr_t\",\n            \"uintptr_t\",\n            \"intmax_t\",\n            \"uintmax_t\",\n            \"ptrdiff_t\",\n            \"size_t\",\n            \"ssize_t\",\n            '_cffi_float_complex_t',\n            '_cffi_double_complex_t',\n            ])\n        for name in PRIMITIVE_TO_INDEX:\n            x = ffi.sizeof(name)\n            assert 1 <= x <= 16\n\n    def test_emit_c_code(self):\n        ffi = cffi.FFI()\n        ffi.set_source(\"foobar\", \"??\")\n        c_file = str(udir.join('test_emit_c_code'))\n        ffi.emit_c_code(c_file)\n        assert os.path.isfile(c_file)\n\n    def test_import_from_lib(self):\n        ffi2 = cffi.FFI()\n        ffi2.cdef(\"int myfunc(int); extern int myvar;\\n#define MYFOO ...\\n\")\n        outputfilename = recompile(ffi2, \"_test_import_from_lib\",\n                                   \"int myfunc(int x) { return x + 1; }\\n\"\n                                   \"int myvar = -5;\\n\"\n                                   \"#define MYFOO 42\", tmpdir=str(udir))\n        load_dynamic(\"_test_import_from_lib\", outputfilename)\n        from _test_import_from_lib.lib import myfunc, myvar, MYFOO\n        assert MYFOO == 42\n        assert myfunc(43) == 44\n        assert myvar == -5     # but can't be changed, so not very useful\n        with pytest.raises(ImportError):\n            from _test_import_from_lib.lib import bar\n        d = {}\n        exec(\"from _test_import_from_lib.lib import *\", d)\n        assert (set(key for key in d if not key.startswith('_')) ==\n                set(['myfunc', 'MYFOO']))\n        #\n        # also test \"import *\" on the module itself, which should be\n        # equivalent to \"import ffi, lib\"\n        d = {}\n        exec(\"from _test_import_from_lib import *\", d)\n        assert (sorted([x for x in d.keys() if not x.startswith('__')]) ==\n                ['ffi', 'lib'])\n\n    def test_char16_t(self):\n        x = ffi.new(\"char16_t[]\", 5)\n        assert len(x) == 5 and ffi.sizeof(x) == 10\n        x[2] = u+'\\u1324'\n        assert x[2] == u+'\\u1324'\n        y = ffi.new(\"char16_t[]\", u+'\\u1234\\u5678')\n        assert len(y) == 3\n        assert list(y) == [u+'\\u1234', u+'\\u5678', u+'\\x00']\n        assert ffi.string(y) == u+'\\u1234\\u5678'\n        z = ffi.new(\"char16_t[]\", u+'\\U00012345')\n        assert len(z) == 3\n        assert list(z) == [u+'\\ud808', u+'\\udf45', u+'\\x00']\n        assert ffi.string(z) == u+'\\U00012345'\n\n    def test_char32_t(self):\n        x = ffi.new(\"char32_t[]\", 5)\n        assert len(x) == 5 and ffi.sizeof(x) == 20\n        x[3] = u+'\\U00013245'\n        assert x[3] == u+'\\U00013245'\n        y = ffi.new(\"char32_t[]\", u+'\\u1234\\u5678')\n        assert len(y) == 3\n        assert list(y) == [u+'\\u1234', u+'\\u5678', u+'\\x00']\n        z = ffi.new(\"char32_t[]\", u+'\\U00012345')\n        assert len(z) == 2\n        assert list(z) == [u+'\\U00012345', u+'\\x00'] # maybe a 2-unichars strin\n        assert ffi.string(z) == u+'\\U00012345'\n", "testing/cffi1/test_dlopen_unicode_literals.py": "import os\n\ns = \"\"\"from __future__ import unicode_literals\n\"\"\"\n\nwith open(os.path.join(os.path.dirname(__file__), 'test_dlopen.py')) as f:\n    s += f.read()\n\nexec(compile(s, filename='test_dlopen.py', mode='exec'))\n", "testing/cffi1/__init__.py": "", "testing/cffi1/test_parse_c_type.py": "import sys, re, os\nimport pytest\nimport cffi\nfrom cffi import cffi_opcode\nfrom pathlib import Path\n\nif '__pypy__' in sys.builtin_module_names:\n    try:\n        # pytest >= 4.0\n        pytest.skip(\"not available on pypy\", allow_module_level=True)\n    except TypeError:\n        # older pytest\n        pytest.skip(\"not available on pypy\")\n\ncffi_dir = str(Path(os.path.dirname(__file__)).parent.parent / \"src/cffi\")\n\nr_macro = re.compile(r\"#define \\w+[(][^\\n]*|#include [^\\n]*\")\nr_define = re.compile(r\"(#define \\w+) [^\\n]*\")\nr_ifdefs = re.compile(r\"(#ifdef |#endif)[^\\n]*\")\nheader = open(os.path.join(cffi_dir, 'parse_c_type.h')).read()\nheader = r_macro.sub(r\"\", header)\nheader = r_define.sub(r\"\\1 ...\", header)\nheader = r_ifdefs.sub(r\"\", header)\n\nffi = cffi.FFI()\nffi.cdef(header)\n\nlib = ffi.verify(\n        open(os.path.join(cffi_dir, '..', 'c', 'parse_c_type.c')).read() + \"\"\"\nstatic const char *get_common_type(const char *search, size_t search_len) {\n    return NULL;\n}\n\"\"\",    include_dirs=[cffi_dir])\n\nclass ParseError(Exception):\n    pass\n\nstruct_names = [\"bar_s\", \"foo\", \"foo_\", \"foo_s\", \"foo_s1\", \"foo_s12\"]\nassert struct_names == sorted(struct_names)\n\nenum_names = [\"ebar_s\", \"efoo\", \"efoo_\", \"efoo_s\", \"efoo_s1\", \"efoo_s12\"]\nassert enum_names == sorted(enum_names)\n\nidentifier_names = [\"id\", \"id0\", \"id05\", \"id05b\", \"tail\"]\nassert identifier_names == sorted(identifier_names)\n\nglobal_names = [\"FIVE\", \"NEG\", \"ZERO\"]\nassert global_names == sorted(global_names)\n\nctx = ffi.new(\"struct _cffi_type_context_s *\")\nc_struct_names = [ffi.new(\"char[]\", _n.encode('ascii')) for _n in struct_names]\nctx_structs = ffi.new(\"struct _cffi_struct_union_s[]\", len(struct_names))\nfor _i in range(len(struct_names)):\n    ctx_structs[_i].name = c_struct_names[_i]\nctx_structs[3].flags = lib._CFFI_F_UNION\nctx.struct_unions = ctx_structs\nctx.num_struct_unions = len(struct_names)\n\nc_enum_names = [ffi.new(\"char[]\", _n.encode('ascii')) for _n in enum_names]\nctx_enums = ffi.new(\"struct _cffi_enum_s[]\", len(enum_names))\nfor _i in range(len(enum_names)):\n    ctx_enums[_i].name = c_enum_names[_i]\nctx.enums = ctx_enums\nctx.num_enums = len(enum_names)\n\nc_identifier_names = [ffi.new(\"char[]\", _n.encode('ascii'))\n                      for _n in identifier_names]\nctx_identifiers = ffi.new(\"struct _cffi_typename_s[]\", len(identifier_names))\nfor _i in range(len(identifier_names)):\n    ctx_identifiers[_i].name = c_identifier_names[_i]\n    ctx_identifiers[_i].type_index = 100 + _i\nctx.typenames = ctx_identifiers\nctx.num_typenames = len(identifier_names)\n\n@ffi.callback(\"int(unsigned long long *)\")\ndef fetch_constant_five(p):\n    p[0] = 5\n    return 0\n@ffi.callback(\"int(unsigned long long *)\")\ndef fetch_constant_zero(p):\n    p[0] = 0\n    return 1\n@ffi.callback(\"int(unsigned long long *)\")\ndef fetch_constant_neg(p):\n    p[0] = 123321\n    return 1\n\nctx_globals = ffi.new(\"struct _cffi_global_s[]\", len(global_names))\nc_glob_names = [ffi.new(\"char[]\", _n.encode('ascii')) for _n in global_names]\nfor _i, _fn in enumerate([fetch_constant_five,\n                          fetch_constant_neg,\n                          fetch_constant_zero]):\n    ctx_globals[_i].name = c_glob_names[_i]\n    ctx_globals[_i].address = _fn\n    ctx_globals[_i].type_op = ffi.cast(\"_cffi_opcode_t\",\n                                       cffi_opcode.OP_CONSTANT_INT if _i != 1\n                                       else cffi_opcode.OP_ENUM)\nctx.globals = ctx_globals\nctx.num_globals = len(global_names)\n\n\ndef parse(input):\n    out = ffi.new(\"_cffi_opcode_t[]\", 100)\n    info = ffi.new(\"struct _cffi_parse_info_s *\")\n    info.ctx = ctx\n    info.output = out\n    info.output_size = len(out)\n    for j in range(len(out)):\n        out[j] = ffi.cast(\"void *\", -424242)\n    res = lib.parse_c_type(info, input.encode('ascii'))\n    if res < 0:\n        raise ParseError(ffi.string(info.error_message).decode('ascii'),\n                         info.error_location)\n    assert 0 <= res < len(out)\n    result = []\n    for j in range(len(out)):\n        if out[j] == ffi.cast(\"void *\", -424242):\n            assert res < j\n            break\n        i = int(ffi.cast(\"intptr_t\", out[j]))\n        if j == res:\n            result.append('->')\n        result.append(i)\n    return result\n\ndef parsex(input):\n    result = parse(input)\n    def str_if_int(x):\n        if isinstance(x, str):\n            return x\n        return '%d,%d' % (x & 255, x >> 8)\n    return '  '.join(map(str_if_int, result))\n\ndef parse_error(input, expected_msg, expected_location):\n    e = pytest.raises(ParseError, parse, input)\n    assert e.value.args[0] == expected_msg\n    assert e.value.args[1] == expected_location\n\ndef make_getter(name):\n    opcode = getattr(lib, '_CFFI_OP_' + name)\n    def getter(value):\n        return opcode | (value << 8)\n    return getter\n\nPrim = make_getter('PRIMITIVE')\nPointer = make_getter('POINTER')\nArray = make_getter('ARRAY')\nOpenArray = make_getter('OPEN_ARRAY')\nNoOp = make_getter('NOOP')\nFunc = make_getter('FUNCTION')\nFuncEnd = make_getter('FUNCTION_END')\nStruct = make_getter('STRUCT_UNION')\nEnum = make_getter('ENUM')\nTypename = make_getter('TYPENAME')\n\n\ndef test_simple():\n    for simple_type, expected in [\n            (\"int\", lib._CFFI_PRIM_INT),\n            (\"signed int\", lib._CFFI_PRIM_INT),\n            (\"  long  \", lib._CFFI_PRIM_LONG),\n            (\"long int\", lib._CFFI_PRIM_LONG),\n            (\"unsigned short\", lib._CFFI_PRIM_USHORT),\n            (\"long double\", lib._CFFI_PRIM_LONGDOUBLE),\n            (\" float  _Complex\", lib._CFFI_PRIM_FLOATCOMPLEX),\n            (\"double _Complex \", lib._CFFI_PRIM_DOUBLECOMPLEX),\n            ]:\n        assert parse(simple_type) == ['->', Prim(expected)]\n\ndef test_array():\n    assert parse(\"int[5]\") == [Prim(lib._CFFI_PRIM_INT), '->', Array(0), 5]\n    assert parse(\"int[]\") == [Prim(lib._CFFI_PRIM_INT), '->', OpenArray(0)]\n    assert parse(\"int[5][8]\") == [Prim(lib._CFFI_PRIM_INT),\n                                  '->', Array(3),\n                                  5,\n                                  Array(0),\n                                  8]\n    assert parse(\"int[][8]\") == [Prim(lib._CFFI_PRIM_INT),\n                                 '->', OpenArray(2),\n                                 Array(0),\n                                 8]\n\ndef test_pointer():\n    assert parse(\"int*\") == [Prim(lib._CFFI_PRIM_INT), '->', Pointer(0)]\n    assert parse(\"int***\") == [Prim(lib._CFFI_PRIM_INT),\n                               Pointer(0), Pointer(1), '->', Pointer(2)]\n\ndef test_grouping():\n    assert parse(\"int*[]\") == [Prim(lib._CFFI_PRIM_INT),\n                               Pointer(0), '->', OpenArray(1)]\n    assert parse(\"int**[][8]\") == [Prim(lib._CFFI_PRIM_INT),\n                                   Pointer(0), Pointer(1),\n                                   '->', OpenArray(4), Array(2), 8]\n    assert parse(\"int(*)[]\") == [Prim(lib._CFFI_PRIM_INT),\n                                 NoOp(3), '->', Pointer(1), OpenArray(0)]\n    assert parse(\"int(*)[][8]\") == [Prim(lib._CFFI_PRIM_INT),\n                                    NoOp(3), '->', Pointer(1),\n                                    OpenArray(4), Array(0), 8]\n    assert parse(\"int**(**)\") == [Prim(lib._CFFI_PRIM_INT),\n                                  Pointer(0), Pointer(1),\n                                  NoOp(2), Pointer(3), '->', Pointer(4)]\n    assert parse(\"int**(**)[]\") == [Prim(lib._CFFI_PRIM_INT),\n                                    Pointer(0), Pointer(1),\n                                    NoOp(6), Pointer(3), '->', Pointer(4),\n                                    OpenArray(2)]\n\ndef test_simple_function():\n    assert parse(\"int()\") == [Prim(lib._CFFI_PRIM_INT),\n                              '->', Func(0), FuncEnd(0), 0]\n    assert parse(\"int(int)\") == [Prim(lib._CFFI_PRIM_INT),\n                                 '->', Func(0), NoOp(4), FuncEnd(0),\n                                 Prim(lib._CFFI_PRIM_INT)]\n    assert parse(\"int(long, char)\") == [\n                                 Prim(lib._CFFI_PRIM_INT),\n                                 '->', Func(0), NoOp(5), NoOp(6), FuncEnd(0),\n                                 Prim(lib._CFFI_PRIM_LONG),\n                                 Prim(lib._CFFI_PRIM_CHAR)]\n    assert parse(\"int(int*)\") == [Prim(lib._CFFI_PRIM_INT),\n                                  '->', Func(0), NoOp(5), FuncEnd(0),\n                                  Prim(lib._CFFI_PRIM_INT),\n                                  Pointer(4)]\n    assert parse(\"int*(void)\") == [Prim(lib._CFFI_PRIM_INT),\n                                   Pointer(0),\n                                   '->', Func(1), FuncEnd(0), 0]\n    assert parse(\"int(int, ...)\") == [Prim(lib._CFFI_PRIM_INT),\n                                      '->', Func(0), NoOp(5), FuncEnd(1), 0,\n                                      Prim(lib._CFFI_PRIM_INT)]\n\ndef test_internal_function():\n    assert parse(\"int(*)()\") == [Prim(lib._CFFI_PRIM_INT),\n                                 NoOp(3), '->', Pointer(1),\n                                 Func(0), FuncEnd(0), 0]\n    assert parse(\"int(*())[]\") == [Prim(lib._CFFI_PRIM_INT),\n                                   NoOp(6), Pointer(1),\n                                   '->', Func(2), FuncEnd(0), 0,\n                                   OpenArray(0)]\n    assert parse(\"int(char(*)(long, short))\") == [\n        Prim(lib._CFFI_PRIM_INT),\n        '->', Func(0), NoOp(6), FuncEnd(0),\n        Prim(lib._CFFI_PRIM_CHAR),\n        NoOp(7), Pointer(5),\n        Func(4), NoOp(11), NoOp(12), FuncEnd(0),\n        Prim(lib._CFFI_PRIM_LONG),\n        Prim(lib._CFFI_PRIM_SHORT)]\n\ndef test_fix_arg_types():\n    assert parse(\"int(char(long, short))\") == [\n        Prim(lib._CFFI_PRIM_INT),\n        '->', Func(0), Pointer(5), FuncEnd(0),\n        Prim(lib._CFFI_PRIM_CHAR),\n        Func(4), NoOp(9), NoOp(10), FuncEnd(0),\n        Prim(lib._CFFI_PRIM_LONG),\n        Prim(lib._CFFI_PRIM_SHORT)]\n    assert parse(\"int(char[])\") == [\n        Prim(lib._CFFI_PRIM_INT),\n        '->', Func(0), Pointer(4), FuncEnd(0),\n        Prim(lib._CFFI_PRIM_CHAR),\n        OpenArray(4)]\n\ndef test_enum():\n    for i in range(len(enum_names)):\n        assert parse(\"enum %s\" % (enum_names[i],)) == ['->', Enum(i)]\n        assert parse(\"enum %s*\" % (enum_names[i],)) == [Enum(i),\n                                                        '->', Pointer(0)]\n\ndef test_error():\n    parse_error(\"short short int\", \"'short' after another 'short' or 'long'\", 6)\n    parse_error(\"long long long\", \"'long long long' is too long\", 10)\n    parse_error(\"short long\", \"'long' after 'short'\", 6)\n    parse_error(\"signed unsigned int\", \"multiple 'signed' or 'unsigned'\", 7)\n    parse_error(\"unsigned signed int\", \"multiple 'signed' or 'unsigned'\", 9)\n    parse_error(\"long char\", \"invalid combination of types\", 5)\n    parse_error(\"short char\", \"invalid combination of types\", 6)\n    parse_error(\"signed void\", \"invalid combination of types\", 7)\n    parse_error(\"unsigned struct\", \"invalid combination of types\", 9)\n    #\n    parse_error(\"\", \"identifier expected\", 0)\n    parse_error(\"]\", \"identifier expected\", 0)\n    parse_error(\"*\", \"identifier expected\", 0)\n    parse_error(\"int ]**\", \"unexpected symbol\", 4)\n    parse_error(\"char char\", \"unexpected symbol\", 5)\n    parse_error(\"int(int]\", \"expected ')'\", 7)\n    parse_error(\"int(*]\", \"expected ')'\", 5)\n    parse_error(\"int(]\", \"identifier expected\", 4)\n    parse_error(\"int[?]\", \"expected a positive integer constant\", 4)\n    parse_error(\"int[24)\", \"expected ']'\", 6)\n    parse_error(\"struct\", \"struct or union name expected\", 6)\n    parse_error(\"struct 24\", \"struct or union name expected\", 7)\n    parse_error(\"int[5](*)\", \"unexpected symbol\", 6)\n    parse_error(\"int a(*)\", \"identifier expected\", 6)\n    parse_error(\"int[123456789012345678901234567890]\", \"number too large\", 4)\n    #\n    parse_error(\"_Complex\", \"identifier expected\", 0)\n    parse_error(\"int _Complex\", \"_Complex type combination unsupported\", 4)\n    parse_error(\"long double _Complex\", \"_Complex type combination unsupported\",\n                12)\n\ndef test_number_too_large():\n    num_max = sys.maxsize\n    assert parse(\"char[%d]\" % num_max) == [Prim(lib._CFFI_PRIM_CHAR),\n                                          '->', Array(0), num_max]\n    parse_error(\"char[%d]\" % (num_max + 1), \"number too large\", 5)\n\ndef test_complexity_limit():\n    parse_error(\"int\" + \"[]\" * 2500, \"internal type complexity limit reached\",\n                202)\n\ndef test_struct():\n    for i in range(len(struct_names)):\n        if i == 3:\n            tag = \"union\"\n        else:\n            tag = \"struct\"\n        assert parse(\"%s %s\" % (tag, struct_names[i])) == ['->', Struct(i)]\n        assert parse(\"%s %s*\" % (tag, struct_names[i])) == [Struct(i),\n                                                            '->', Pointer(0)]\n\ndef test_exchanging_struct_union():\n    parse_error(\"union %s\" % (struct_names[0],),\n                \"wrong kind of tag: struct vs union\", 6)\n    parse_error(\"struct %s\" % (struct_names[3],),\n                \"wrong kind of tag: struct vs union\", 7)\n\ndef test_identifier():\n    for i in range(len(identifier_names)):\n        assert parse(\"%s\" % (identifier_names[i])) == ['->', Typename(i)]\n        assert parse(\"%s*\" % (identifier_names[i])) == [Typename(i),\n                                                        '->', Pointer(0)]\n\ndef test_cffi_opcode_sync():\n    import cffi.model\n    for name in dir(lib):\n        if name.startswith('_CFFI_'):\n            assert getattr(cffi_opcode, name[6:]) == getattr(lib, name)\n    assert sorted(cffi_opcode.PRIMITIVE_TO_INDEX.keys()) == (\n        sorted(cffi.model.PrimitiveType.ALL_PRIMITIVE_TYPES.keys()))\n\ndef test_array_length_from_constant():\n    parse_error(\"int[UNKNOWN]\", \"expected a positive integer constant\", 4)\n    assert parse(\"int[FIVE]\") == [Prim(lib._CFFI_PRIM_INT), '->', Array(0), 5]\n    assert parse(\"int[ZERO]\") == [Prim(lib._CFFI_PRIM_INT), '->', Array(0), 0]\n    parse_error(\"int[NEG]\", \"expected a positive integer constant\", 4)\n\ndef test_various_constant_exprs():\n    def array(n):\n        return [Prim(lib._CFFI_PRIM_CHAR), '->', Array(0), n]\n    assert parse(\"char[21]\") == array(21)\n    assert parse(\"char[0x10]\") == array(16)\n    assert parse(\"char[0X21]\") == array(33)\n    assert parse(\"char[0Xb]\") == array(11)\n    assert parse(\"char[0x1C]\") == array(0x1C)\n    assert parse(\"char[0xc6]\") == array(0xC6)\n    assert parse(\"char[010]\") == array(8)\n    assert parse(\"char[021]\") == array(17)\n    parse_error(\"char[08]\", \"invalid number\", 5)\n    parse_error(\"char[1C]\", \"invalid number\", 5)\n    parse_error(\"char[0C]\", \"invalid number\", 5)\n    # not supported (really obscure):\n    #    \"char[+5]\"\n    #    \"char['A']\"\n\ndef test_stdcall_cdecl():\n    assert parse(\"int __stdcall(int)\") == [Prim(lib._CFFI_PRIM_INT),\n                                           '->', Func(0), NoOp(4), FuncEnd(2),\n                                           Prim(lib._CFFI_PRIM_INT)]\n    assert parse(\"int __stdcall func(int)\") == parse(\"int __stdcall(int)\")\n    assert parse(\"int (__stdcall *)()\") == [Prim(lib._CFFI_PRIM_INT),\n                                            NoOp(3), '->', Pointer(1),\n                                            Func(0), FuncEnd(2), 0]\n    assert parse(\"int (__stdcall *p)()\") == parse(\"int (__stdcall*)()\")\n    parse_error(\"__stdcall int\", \"identifier expected\", 0)\n    parse_error(\"__cdecl int\", \"identifier expected\", 0)\n    parse_error(\"int __stdcall\", \"expected '('\", 13)\n    parse_error(\"int __cdecl\", \"expected '('\", 11)\n", "testing/cffi1/test_verify1.py": "import os, sys, math\nimport pytest\nfrom cffi import FFI, FFIError, VerificationError, VerificationMissing, model\nfrom cffi import CDefError\nfrom cffi import recompiler\nfrom testing.support import *\nfrom testing.support import _verify, extra_compile_args, is_musl\nimport _cffi_backend\n\nlib_m = ['m']\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = ['msvcrt']\n\nclass FFI(FFI):\n    error = _cffi_backend.FFI.error\n    _extra_compile_args = extra_compile_args\n    _verify_counter = 0\n\n    def verify(self, preamble='', *args, **kwds):\n        # HACK to reuse the tests from ../cffi0/test_verify.py\n        FFI._verify_counter += 1\n        module_name = 'verify%d' % FFI._verify_counter\n        try:\n            del self._assigned_source\n        except AttributeError:\n            pass\n        self.set_source(module_name, preamble)\n        return _verify(self, module_name, preamble, *args,\n                       extra_compile_args=self._extra_compile_args, **kwds)\n\nclass FFI_warnings_not_error(FFI):\n    _extra_compile_args = []\n\n\ndef test_missing_function(ffi=None):\n    # uses the FFI hacked above with '-Werror'\n    if ffi is None:\n        ffi = FFI()\n    ffi.cdef(\"void some_completely_unknown_function();\")\n    try:\n        lib = ffi.verify()\n    except (VerificationError, OSError, ImportError):\n        pass     # expected case: we get a VerificationError\n    else:\n        # but depending on compiler and loader details, maybe\n        # 'lib' could actually be imported but will fail if we\n        # actually try to call the unknown function...  Hard\n        # to test anything more.\n        pass\n\ndef test_missing_function_import_error():\n    # uses the original FFI that just gives a warning during compilation\n    test_missing_function(ffi=FFI_warnings_not_error())\n\ndef test_simple_case():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef _Wconversion(cdef, source, **kargs):\n    if sys.platform in ('win32', 'darwin'):\n        pytest.skip(\"needs GCC\")\n    if '-Wno-error=sign-conversion' in extra_compile_args:\n        pytest.skip(\"gcc 9.2.0 compiler bug exposed by Python 3.12+ prevents compilation with sign-conversion warnings-as-errors\")\n    ffi = FFI()\n    ffi.cdef(cdef)\n    pytest.raises(VerificationError, ffi.verify, source, **kargs)\n    extra_compile_args_orig = extra_compile_args[:]\n    extra_compile_args.remove('-Wconversion')\n    try:\n        lib = ffi.verify(source, **kargs)\n    finally:\n        extra_compile_args[:] = extra_compile_args_orig\n    return lib\n\ndef test_Wconversion_unsigned():\n    _Wconversion(\"unsigned foo(void);\",\n                 \"int foo(void) { return -1;}\")\n\ndef test_Wconversion_integer():\n    _Wconversion(\"short foo(void);\",\n                 \"long long foo(void) { return 1<<sizeof(short);}\")\n\ndef test_Wconversion_floating():\n    lib = _Wconversion(\"float sin(double);\",\n                       \"#include <math.h>\", libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_Wconversion_float2int():\n    _Wconversion(\"int sinf(float);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_Wconversion_double2int():\n    _Wconversion(\"int sin(double);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_rounding_1():\n    ffi = FFI()\n    ffi.cdef(\"double sinf(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sinf(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_rounding_2():\n    ffi = FFI()\n    ffi.cdef(\"double sin(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_strlen_exact():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(const char *s);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_strlen_approximate():\n    lib = _Wconversion(\"int strlen(char *s);\",\n                       \"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_return_approximate():\n    for typename in ['short', 'int', 'long', 'long long']:\n        ffi = FFI()\n        ffi.cdef(\"%s foo(signed char x);\" % typename)\n        lib = ffi.verify(\"signed char foo(signed char x) { return x;}\")\n        assert lib.foo(-128) == -128\n        assert lib.foo(+127) == +127\n\ndef test_strlen_array_of_char():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(char[]);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_longdouble():\n    ffi = FFI()\n    ffi.cdef(\"long double sinl(long double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    for input in [1.23,\n                  ffi.cast(\"double\", 1.23),\n                  ffi.cast(\"long double\", 1.23)]:\n        x = lib.sinl(input)\n        assert repr(x).startswith(\"<cdata 'long double'\")\n        assert (float(x) - math.sin(1.23)) < 1E-10\n\ndef test_longdouble_precision():\n    # Test that we don't loose any precision of 'long double' when\n    # passing through Python and CFFI.\n    ffi = FFI()\n    ffi.cdef(\"long double step1(long double x);\")\n    SAME_SIZE = ffi.sizeof(\"long double\") == ffi.sizeof(\"double\")\n    lib = ffi.verify(\"\"\"\n        long double step1(long double x)\n        {\n            return 4*x-x*x;\n        }\n    \"\"\")\n    def do(cast_to_double):\n        x = 0.9789\n        for i in range(10000):\n            x = lib.step1(x)\n            if cast_to_double:\n                x = float(x)\n        return float(x)\n\n    more_precise = do(False)\n    less_precise = do(True)\n    if SAME_SIZE:\n        assert more_precise == less_precise\n    else:\n        assert abs(more_precise - less_precise) > 0.1\n        # Check the particular results on Intel\n        import platform\n        if (platform.machine().startswith('i386') or\n            platform.machine().startswith('i486') or\n            platform.machine().startswith('i586') or\n            platform.machine().startswith('i686') or\n            platform.machine().startswith('x86')):\n            assert abs(more_precise - 0.656769) < 0.001\n            assert abs(less_precise - 3.99091) < 0.001\n        else:\n            pytest.skip(\"don't know the very exact precision of 'long double'\")\n\n\nall_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES\nif sys.platform == 'win32':\n    all_primitive_types = all_primitive_types.copy()\n    del all_primitive_types['ssize_t']\nall_integer_types = sorted(tp for tp in all_primitive_types\n                           if all_primitive_types[tp] == 'i')\nall_float_types = sorted(tp for tp in all_primitive_types\n                            if all_primitive_types[tp] == 'f')\n\ndef all_signed_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) < 0]\n\ndef all_unsigned_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) > 0]\n\n\ndef test_primitive_category():\n    for typename in all_primitive_types:\n        tp = model.PrimitiveType(typename)\n        C = tp.is_char_type()\n        F = tp.is_float_type()\n        X = tp.is_complex_type()\n        I = tp.is_integer_type()\n        assert C == (typename in ('char', 'wchar_t', 'char16_t', 'char32_t'))\n        assert F == (typename in ('float', 'double', 'long double'))\n        assert X == (typename in ('_cffi_float_complex_t', '_cffi_double_complex_t'))\n        assert I + F + C + X == 1      # one and only one of them is true\n\ndef test_all_integer_and_float_types():\n    typenames = []\n    for typename in all_primitive_types:\n        if (all_primitive_types[typename] == 'c' or\n            all_primitive_types[typename] == 'j' or    # complex\n            typename == '_Bool' or typename == 'long double'):\n            pass\n        else:\n            typenames.append(typename)\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    lib = ffi.verify('\\n'.join([\"%s foo_%s(%s x) { return (%s)(x+1); }\" %\n                                (tp, tp.replace(' ', '_'), tp, tp)\n                                for tp in typenames]))\n    for typename in typenames:\n        foo = getattr(lib, 'foo_%s' % typename.replace(' ', '_'))\n        assert foo(42) == 43\n        if sys.version < '3':\n            assert foo(long(44)) == 45\n        assert foo(ffi.cast(typename, 46)) == 47\n        pytest.raises(TypeError, foo, ffi.NULL)\n        #\n        # check for overflow cases\n        if all_primitive_types[typename] == 'f':\n            continue\n        for value in [-2**80, -2**40, -2**20, -2**10, -2**5, -1,\n                      2**5, 2**10, 2**20, 2**40, 2**80]:\n            overflows = int(ffi.cast(typename, value)) != value\n            if overflows:\n                pytest.raises(OverflowError, foo, value)\n            else:\n                assert foo(value) == value + 1\n\ndef test_all_complex_types():\n    if sys.platform == 'win32':\n        typenames = ['_Fcomplex', '_Dcomplex']\n        header = '#include <complex.h>\\n'\n    else:\n        typenames = ['float _Complex', 'double _Complex']\n        header = ''\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    lib = ffi.verify(\n            header + '\\n'.join([\"%s foo_%s(%s x) { return x; }\" %\n                                (tp, tp.replace(' ', '_'), tp)\n                                for tp in typenames]))\n    for typename in typenames:\n        foo = getattr(lib, 'foo_%s' % typename.replace(' ', '_'))\n        assert foo(42 + 1j) == 42 + 1j\n        assert foo(ffi.cast(typename, 46 - 3j)) == 46 - 3j\n        pytest.raises(TypeError, foo, ffi.NULL)\n\ndef test_var_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    csource = \"\\n\".join([\"static %s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, min)\n        assert getattr(lib, varname) == min\n        pytest.raises(OverflowError, setattr, lib, varname, max+1)\n        pytest.raises(OverflowError, setattr, lib, varname, min-1)\n\ndef test_var_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    csource = \"\\n\".join([\"static %s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, 0)\n        assert getattr(lib, varname) == 0\n        pytest.raises(OverflowError, setattr, lib, varname, max+1)\n        pytest.raises(OverflowError, setattr, lib, varname, -1)\n\ndef test_fn_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(min) == min\n        pytest.raises(OverflowError, fn, max + 1)\n        pytest.raises(OverflowError, fn, min - 1)\n\ndef test_fn_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(0) == 0\n        pytest.raises(OverflowError, fn, max + 1)\n        pytest.raises(OverflowError, fn, -1)\n\ndef test_char_type():\n    ffi = FFI()\n    ffi.cdef(\"char foo(char);\")\n    lib = ffi.verify(\"char foo(char x) { return ++x; }\")\n    assert lib.foo(b\"A\") == b\"B\"\n    pytest.raises(TypeError, lib.foo, b\"bar\")\n    pytest.raises(TypeError, lib.foo, \"bar\")\n\ndef test_wchar_type():\n    ffi = FFI()\n    if ffi.sizeof('wchar_t') == 2:\n        uniexample1 = u+'\\u1234'\n        uniexample2 = u+'\\u1235'\n    else:\n        uniexample1 = u+'\\U00012345'\n        uniexample2 = u+'\\U00012346'\n    #\n    ffi.cdef(\"wchar_t foo(wchar_t);\")\n    lib = ffi.verify(\"wchar_t foo(wchar_t x) { return x+1; }\")\n    assert lib.foo(uniexample1) == uniexample2\n\ndef test_no_argument():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\")\n    lib = ffi.verify(\"int foo(void) { return 42; }\")\n    assert lib.foo() == 42\n\ndef test_two_arguments():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"int foo(int a, int b) { return a - b; }\")\n    assert lib.foo(40, -2) == 42\n\ndef test_macro():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"#define foo(a, b) ((a) * (b))\")\n    assert lib.foo(-6, -7) == 42\n\ndef test_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    assert lib.foo(ffi.NULL) == ffi.NULL\n    p = ffi.new(\"int *\", 42)\n    q = ffi.new(\"int *\", 42)\n    assert lib.foo(p) == p\n    assert lib.foo(q) != p\n\ndef test_bogus_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    pytest.raises(TypeError, lib.foo, ffi.new(\"short *\", 42))\n\n\ndef test_verify_typedefs():\n    pytest.skip(\"ignored so far\")\n    types = ['signed char', 'unsigned char', 'int', 'long']\n    for cdefed in types:\n        for real in types:\n            ffi = FFI()\n            ffi.cdef(\"typedef %s foo_t;\" % cdefed)\n            if cdefed == real:\n                ffi.verify(\"typedef %s foo_t;\" % real)\n            else:\n                pytest.raises(VerificationError, ffi.verify,\n                               \"typedef %s foo_t;\" % real)\n\ndef test_nondecl_struct():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct foo_s foo_t; int bar(foo_t *);\")\n    lib = ffi.verify(\"typedef struct foo_s foo_t;\\n\"\n                     \"int bar(foo_t *f) { (void)f; return 42; }\\n\")\n    assert lib.bar(ffi.NULL) == 42\n\ndef test_ffi_full_struct():\n    def check(verified_code):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { char x; int y; long *z; };\")\n        ffi.verify(verified_code)\n        ffi.new(\"struct foo_s *\", {})\n\n    check(\"struct foo_s { char x; int y; long *z; };\")\n    #\n    if sys.platform != 'win32':  # XXX fixme: only gives warnings\n        pytest.raises(VerificationError, check,\n            \"struct foo_s { char x; int y; int *z; };\")\n    #\n    pytest.raises(VerificationError, check,\n        \"struct foo_s { int y; long *z; };\")     # cdef'ed field x is missing\n    #\n    e = pytest.raises(FFI.error, check,\n                       \"struct foo_s { int y; char x; long *z; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong offset for field 'x'\"\n        \" (cdef says 0, but C compiler says 4)\")\n    #\n    e = pytest.raises(FFI.error, check,\n        \"struct foo_s { char x; int y; long *z; char extra; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong total size\"\n        \" (cdef says %d, but C compiler says %d)\" % (\n            8 + FFI().sizeof('long *'),\n            8 + FFI().sizeof('long *') * 2))\n    #\n    # a corner case that we cannot really detect, but where it has no\n    # bad consequences: the size is the same, but there is an extra field\n    # that replaces what is just padding in our declaration above\n    check(\"struct foo_s { char x, extra; int y; long *z; };\")\n    #\n    e = pytest.raises(FFI.error, check,\n        \"struct foo_s { char x; short pad; short y; long *z; };\")\n    assert str(e.value).startswith(\n        \"struct foo_s: wrong size for field 'y'\"\n        \" (cdef says 4, but C compiler says 2)\")\n\ndef test_ffi_nonfull_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    struct foo_s {\n       int x;\n       ...;\n    };\n    \"\"\")\n    pytest.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')\n    pytest.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')\n    pytest.raises(VerificationMissing, ffi.new, 'struct foo_s *')\n    ffi.verify(\"\"\"\n    struct foo_s {\n       int a, b, x, c, d, e;\n    };\n    \"\"\")\n    assert ffi.sizeof('struct foo_s') == 6 * ffi.sizeof('int')\n    assert ffi.offsetof('struct foo_s', 'x') == 2 * ffi.sizeof('int')\n\ndef test_ffi_nonfull_alignment():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; ...; };\")\n    ffi.verify(\"struct foo_s { int a, b; char x; };\")\n    assert ffi.sizeof('struct foo_s') == 3 * ffi.sizeof('int')\n    assert ffi.alignof('struct foo_s') == ffi.sizeof('int')\n\ndef _check_field_match(typename, real, expect_mismatch):\n    ffi = FFI()\n    testing_by_size = (expect_mismatch == 'by_size')\n    if testing_by_size:\n        expect_mismatch = ffi.sizeof(typename) != ffi.sizeof(real)\n    ffi.cdef(\"struct foo_s { %s x; ...; };\" % typename)\n    try:\n        ffi.verify(\"struct foo_s { %s x; };\" % real)\n        ffi.new(\"struct foo_s *\", [])  # because some mismatches show up lazily\n    except (VerificationError, ffi.error):\n        if not expect_mismatch:\n            if testing_by_size and typename != real:\n                print(\"ignoring mismatch between %s* and %s* even though \"\n                      \"they have the same size\" % (typename, real))\n                return\n            raise AssertionError(\"unexpected mismatch: %s should be accepted \"\n                                 \"as equal to %s\" % (typename, real))\n    else:\n        if expect_mismatch:\n            raise AssertionError(\"mismatch not detected: \"\n                                 \"%s != %s\" % (typename, real))\n\ndef test_struct_bad_sized_integer():\n    for typename in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n        for real in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_bad_sized_float():\n    for typename in all_float_types:\n        for real in all_float_types:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_signedness_ignored():\n    _check_field_match(\"int\", \"unsigned int\", expect_mismatch=False)\n    _check_field_match(\"unsigned short\", \"signed short\", expect_mismatch=False)\n\ndef test_struct_float_vs_int():\n    if sys.platform == 'win32':\n        pytest.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    for typename in all_signed_integer_types(ffi):\n        for real in all_float_types:\n            _check_field_match(typename, real, expect_mismatch=True)\n    for typename in all_float_types:\n        for real in all_signed_integer_types(ffi):\n            _check_field_match(typename, real, expect_mismatch=True)\n\ndef test_struct_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[17]; ...; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n\ndef test_struct_array_no_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[]; int y; ...; };\\n\"\n             \"int bar(struct foo_s *);\\n\")\n    lib = ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\\n\"\n                     \"int bar(struct foo_s *f) { return f->a[14]; }\\n\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) is ffi.typeof('int[]')   # implicit max length\n    assert len(s.a) == 18  # max length, computed from the size and start offset\n    s.a[14] = 4242\n    assert lib.bar(s) == 4242\n    # with no declared length, out-of-bound accesses are not detected\n    s.a[17] = -521\n    assert s.y == s.a[17] == -521\n    #\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(17))})\n    assert s.a[16] == 16\n    # overflows at construction time not detected either\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(18))})\n    assert s.y == s.a[17] == 17\n\ndef test_struct_array_guess_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n    with pytest.raises(IndexError):\n        s.a[17]\n\ndef test_struct_array_c99_1():\n    if sys.platform == 'win32':\n        pytest.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(ffi.typeof(s[0])) == 1 * ffi.sizeof('int')\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    # ^^^ explanation: if you write in C: \"char x[5];\", then\n    # \"sizeof(x)\" will evaluate to 5.  The behavior above is\n    # a generalization of that to \"struct foo_s[len(a)=5] x;\"\n    # if you could do that in C.\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n\ndef test_struct_array_c99_2():\n    if sys.platform == 'win32':\n        pytest.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; ...; };\")\n    ffi.verify(\"struct foo_s { int x, y; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n\ndef test_struct_ptr_to_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int (*a)[17]; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct foo_s { int x; int (*a)[17]; int y; };\\n\"\n               \"struct bar_s { int x; int *a; int y; };\")\n    assert ffi.sizeof('struct foo_s') == ffi.sizeof(\"struct bar_s\")\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == ffi.sizeof('int(*)[17]') == ffi.sizeof(\"int *\")\n\ndef test_struct_with_bitfield_exact():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a:2, b:3; };\")\n    ffi.verify(\"struct foo_s { int a:2, b:3; };\")\n    s = ffi.new(\"struct foo_s *\")\n    s.b = 3\n    with pytest.raises(OverflowError):\n        s.b = 4\n    assert s.b == 3\n\ndef test_struct_with_bitfield_enum():\n    ffi = FFI()\n    code = \"\"\"\n        typedef enum { AA, BB, CC } foo_e;\n        typedef struct { foo_e f:2; } foo_s;\n    \"\"\"\n    ffi.cdef(code)\n    ffi.verify(code)\n    s = ffi.new(\"foo_s *\")\n    s.f = 1\n    assert s.f == 1\n    if int(ffi.cast(\"foo_e\", -1)) < 0:\n        two = -2\n    else:\n        two = 2\n    s.f = two\n    assert s.f == two\n\ndef test_unsupported_struct_with_bitfield_ellipsis():\n    ffi = FFI()\n    pytest.raises(NotImplementedError, ffi.cdef,\n                   \"struct foo_s { int a:2, b:3; ...; };\")\n\ndef test_global_constants():\n    ffi = FFI()\n    # use 'static const int', as generally documented, although in this\n    # case the 'static' is completely ignored.\n    ffi.cdef(\"static const int AA, BB, CC, DD;\")\n    lib = ffi.verify(\"#define AA 42\\n\"\n                     \"#define BB (-43)   // blah\\n\"\n                     \"#define CC (22*2)  /* foobar */\\n\"\n                     \"#define DD ((unsigned int)142)  /* foo\\nbar */\\n\")\n    assert lib.AA == 42\n    assert lib.BB == -43\n    assert lib.CC == 44\n    assert lib.DD == 142\n\ndef test_global_const_int_size():\n    # integer constants: ignore the declared type, always just use the value\n    for value in [-2**63, -2**31, -2**15,\n                  2**15-1, 2**15, 2**31-1, 2**31, 2**32-1, 2**32,\n                  2**63-1, 2**63, 2**64-1]:\n        ffi = FFI()\n        if value == int(ffi.cast(\"long long\", value)):\n            if value < 0:\n                vstr = '(-%dLL-1)' % (~value,)\n            else:\n                vstr = '%dLL' % value\n        elif value == int(ffi.cast(\"unsigned long long\", value)):\n            vstr = '%dULL' % value\n        else:\n            raise AssertionError(value)\n        ffi.cdef(\"static const unsigned short AA;\")\n        lib = ffi.verify(\"#define AA %s\\n\" % vstr)\n        assert lib.AA == value\n        assert type(lib.AA) is type(int(lib.AA))\n\ndef test_global_constants_non_int():\n    ffi = FFI()\n    ffi.cdef(\"static char *const PP;\")\n    lib = ffi.verify('static char *const PP = \"testing!\";\\n')\n    assert ffi.typeof(lib.PP) == ffi.typeof(\"char *\")\n    assert ffi.string(lib.PP) == b\"testing!\"\n\ndef test_nonfull_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3, ... \\n \\t };\")\n    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    assert ffi.string(ffi.cast('enum ee', -10)) == \"EE3\"\n    #\n    assert ffi.typeof(\"enum ee\").relements == {'EE1': 10, 'EE2': 11, 'EE3': -10}\n    assert ffi.typeof(\"enum ee\").elements == {10: 'EE1', 11: 'EE2', -10: 'EE3'}\n\ndef test_full_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3 };\")\n    lib = ffi.verify(\"enum ee { EE1, EE2, EE3 };\")\n    assert [lib.EE1, lib.EE2, lib.EE3] == [0, 1, 2]\n\ndef test_enum_usage():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    lib = ffi.verify(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    assert lib.EE2 == 1\n    s = ffi.new(\"sp\", [lib.EE2])\n    assert s.x == 1\n    s.x = 17\n    assert s.x == 17\n\ndef test_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1 }; enum { EE2, EE3 };\")\n    lib = ffi.verify(\"enum { EE1 }; enum { EE2, EE3 };\")\n    assert lib.EE1 == 0\n    assert lib.EE2 == 0\n    assert lib.EE3 == 1\n\ndef test_nonfull_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1, ... }; enum { EE3, ... };\")\n    lib = ffi.verify(\"enum { EE2, EE1 }; enum { EE3 };\")\n    assert lib.EE1 == 1\n    assert lib.EE3 == 0\n\ndef test_nonfull_enum_syntax2():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t..., EE3 };\")\n    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t... };\")\n    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=..., ... };\")\n    ffi.verify(\"enum ee2 { EE4=-1234-5, EE5 }; \")\n    assert ffi.string(ffi.cast('enum ee2', -1239)) == 'EE4'\n    assert ffi.string(ffi.cast('enum ee2', -1238)) == 'EE5'\n\ndef test_get_set_errno():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"\"\"\n        static int foo(int x)\n        {\n            errno += 1;\n            return x * 7;\n        }\n    \"\"\")\n    ffi.errno = 15\n    assert lib.foo(6) == 42\n    assert ffi.errno == 16\n\ndef test_define_int():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO ...\\n\"\n             \"\\t#\\tdefine\\tBAR\\t...\\t\\n\"\n             \"#define BAZ ...\\n\")\n    lib = ffi.verify(\"#define FOO 42\\n\"\n                     \"#define BAR (-44)\\n\"\n                     \"#define BAZ 0xffffffffffffffffULL\\n\")\n    assert lib.FOO == 42\n    assert lib.BAR == -44\n    assert lib.BAZ == 0xffffffffffffffff\n\ndef test_access_variable():\n    ffi = FFI()\n    ffi.cdef(\"static int foo(void);\\n\"\n             \"static int somenumber;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        static int foo(void) {\n            return somenumber * 7;\n        }\n    \"\"\")\n    assert lib.somenumber == 2\n    assert lib.foo() == 14\n    lib.somenumber = -6\n    assert lib.foo() == -42\n    assert lib.somenumber == -6\n    lib.somenumber = 2   # reset for the next run, if any\n\ndef test_access_address_of_variable():\n    # access the address of 'somenumber': need a trick\n    ffi = FFI()\n    ffi.cdef(\"static int somenumber; static int *const somenumberptr;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        #define somenumberptr (&somenumber)\n    \"\"\")\n    assert lib.somenumber == 2\n    lib.somenumberptr[0] = 42\n    assert lib.somenumber == 42\n    lib.somenumber = 2    # reset for the next run, if any\n\ndef test_access_array_variable(length=5):\n    ffi = FFI()\n    ffi.cdef(\"static int foo(int);\\n\"\n             \"static int somenumber[%s];\" % (length,))\n    lib = ffi.verify(\"\"\"\n        static int somenumber[] = {2, 2, 3, 4, 5};\n        static int foo(int i) {\n            return somenumber[i] * 7;\n        }\n    \"\"\")\n    if length == '':\n        # a global variable of an unknown array length is implicitly\n        # transformed into a global pointer variable, because we can only\n        # work with array instances whose length we know.  using a pointer\n        # instead of an array gives the correct effects.\n        assert repr(lib.somenumber).startswith(\"<cdata 'int *' 0x\")\n        pytest.raises(TypeError, len, lib.somenumber)\n    else:\n        assert repr(lib.somenumber).startswith(\"<cdata 'int[%s]' 0x\" % length)\n        assert len(lib.somenumber) == 5\n    assert lib.somenumber[3] == 4\n    assert lib.foo(3) == 28\n    lib.somenumber[3] = -6\n    assert lib.foo(3) == -42\n    assert lib.somenumber[3] == -6\n    assert lib.somenumber[4] == 5\n    lib.somenumber[3] = 4    # reset for the next run, if any\n\ndef test_access_array_variable_length_hidden():\n    test_access_array_variable(length='')\n\ndef test_access_struct_variable():\n    ffi = FFI()\n    ffi.cdef(\"struct foo { int x; ...; };\\n\"\n             \"static int foo(int);\\n\"\n             \"static struct foo stuff;\")\n    lib = ffi.verify(\"\"\"\n        struct foo { int x, y, z; };\n        static struct foo stuff = {2, 5, 8};\n        static int foo(int i) {\n            switch (i) {\n            case 0: return stuff.x * 7;\n            case 1: return stuff.y * 7;\n            case 2: return stuff.z * 7;\n            }\n            return -1;\n        }\n    \"\"\")\n    assert lib.stuff.x == 2\n    assert lib.foo(0) == 14\n    assert lib.foo(1) == 35\n    assert lib.foo(2) == 56\n    lib.stuff.x = -6\n    assert lib.foo(0) == -42\n    assert lib.foo(1) == 35\n    lib.stuff.x = 2      # reset for the next run, if any\n\ndef test_access_callback():\n    ffi = FFI()\n    ffi.cdef(\"static int (*cb)(int);\\n\"\n             \"static int foo(int);\\n\"\n             \"static void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_access_callback_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int mycallback_t(int);\\n\"\n             \"static mycallback_t *cb;\\n\"\n             \"static int foo(int);\\n\"\n             \"static void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_call_with_struct_ptr():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } foo_t; int foo(foo_t *);\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        static int foo(foo_t *f) { return f->x * 7; }\n    \"\"\")\n    f = ffi.new(\"foo_t *\")\n    f.x = 6\n    assert lib.foo(f) == 42\n\ndef test_unknown_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... token_t;\n        int foo(token_t *);\n        #define TOKEN_SIZE ...\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef float token_t;\n        static int foo(token_t *tk) {\n            if (!tk)\n                return -42;\n            *tk += 1.601f;\n            return (int)*tk;\n        }\n        #define TOKEN_SIZE sizeof(token_t)\n    \"\"\")\n    # we cannot let ffi.new(\"token_t *\") work, because we don't know ahead of\n    # time if it's ok to ask 'sizeof(token_t)' in the C code or not.\n    # See test_unknown_type_2.  Workaround.\n    tkmem = ffi.new(\"char[]\", lib.TOKEN_SIZE)    # zero-initialized\n    tk = ffi.cast(\"token_t *\", tkmem)\n    results = [lib.foo(tk) for i in range(6)]\n    assert results == [1, 3, 4, 6, 8, 9]\n    assert lib.foo(ffi.NULL) == -42\n\ndef test_unknown_type_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... token_t;\")\n    lib = ffi.verify(\"typedef struct token_s token_t;\")\n    # assert did not crash, even though 'sizeof(token_t)' is not valid in C.\n\ndef test_unknown_type_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... *token_p;\n        token_p foo(token_p);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct _token_s *token_p;\n        token_p foo(token_p arg) {\n            if (arg)\n                return (token_p)0x12347;\n            else\n                return (token_p)0x12345;\n        }\n    \"\"\")\n    p = lib.foo(ffi.NULL)\n    assert int(ffi.cast(\"intptr_t\", p)) == 0x12345\n    q = lib.foo(p)\n    assert int(ffi.cast(\"intptr_t\", q)) == 0x12347\n\ndef test_varargs():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        int foo(int x, ...) {\n            va_list vargs;\n            va_start(vargs, x);\n            x -= va_arg(vargs, int);\n            x -= va_arg(vargs, int);\n            va_end(vargs);\n            return x;\n        }\n    \"\"\")\n    assert lib.foo(50, ffi.cast(\"int\", 5), ffi.cast(\"int\", 3)) == 42\n\ndef test_varargs_exact():\n    if sys.platform == 'win32':\n        pytest.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    pytest.raises(VerificationError, ffi.verify, \"\"\"\n        int foo(long long x, ...) {\n            return x;\n        }\n    \"\"\")\n\ndef test_varargs_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char a; int b; }; int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            char a; int b;\n        };\n        int foo(int x, ...) {\n            va_list vargs;\n            struct foo_s s;\n            va_start(vargs, x);\n            s = va_arg(vargs, struct foo_s);\n            va_end(vargs);\n            return s.a - s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [b'B', 1])\n    assert lib.foo(50, s[0]) == ord('A')\n\ndef test_autofilled_struct_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; double b; ...; };\\n\"\n             \"int foo(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [100, 1])\n    assert lib.foo(s[0]) == 99\n    assert lib.foo([100, 1]) == 99\n\ndef test_autofilled_struct_as_argument_dynamic():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; ...; };\\n\"\n             \"static int (*foo)(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo1(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n        static int (*foo)(struct foo_s s) = &foo1;\n    \"\"\")\n    e = pytest.raises(NotImplementedError, lib.foo, \"?\")\n    msg = (\"ctype 'struct foo_s' not supported as argument.  It is a struct \"\n           'declared with \"...;\", but the C calling convention may depend on '\n           \"the missing fields; or, it contains anonymous struct/unions.  \"\n           \"Such structs are only supported as argument \"\n           \"if the function is 'API mode' and non-variadic (i.e. declared \"\n           \"inside ffibuilder.cdef()+ffibuilder.set_source() and not taking \"\n           \"a final '...' argument)\")\n    assert str(e.value) == msg\n\ndef test_func_returns_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b) {\n            struct foo_s r;\n            r.aa = a*a;\n            r.bb = b*b;\n            return r;\n        }\n    \"\"\")\n    s = lib.foo(6, 7)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 8 bytes>\"\n    assert s.aa == 36\n    assert s.bb == 49\n\ndef test_func_as_funcptr():\n    ffi = FFI()\n    ffi.cdef(\"int *(*const fooptr)(void);\")\n    lib = ffi.verify(\"\"\"\n        int *foo(void) {\n            return (int*)\"foobar\";\n        }\n        int *(*fooptr)(void) = foo;\n    \"\"\")\n    foochar = ffi.cast(\"char *(*)(void)\", lib.fooptr)\n    s = foochar()\n    assert ffi.string(s) == b\"foobar\"\n\ndef test_funcptr_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int (*compar)(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_func_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int compar(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_array_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        size_t strlen(char string[]);\n    \"\"\")\n    ffi.verify(\"#include <string.h>\")\n\ndef test_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        int foo_func(enum foo_e);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        int foo_func(enum foo_e e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == 2\n    pytest.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        enum foo_e foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        enum foo_e foo_func(int x) { return (enum foo_e)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_enum_values():\n    ffi = FFI()\n    ffi.cdef(\"enum enum1_e { AA, BB };\")\n    lib = ffi.verify(\"enum enum1_e { AA, BB };\")\n    assert lib.AA == 0\n    assert lib.BB == 1\n    assert ffi.string(ffi.cast(\"enum enum1_e\", 1)) == 'BB'\n\ndef test_typedef_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 1\n\ndef test_typedef_broken_complete_enum():\n    # xxx this is broken in old cffis, but works with recompiler.py\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_incomplete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB, ... } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == '1'\n    assert ffi.string(ffi.cast(\"enum1_t\", 2)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        int foo_func(foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        int foo_func(foo_t e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n    pytest.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_typedef_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        foo_t foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        foo_t foo_func(int x) { return (foo_t)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef double func_t(double);\n        func_t sin;\n    \"\"\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef test_opaque_integer_as_function_result():\n    #import platform\n    #if platform.machine().startswith('sparc'):\n    #    pytest.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')\n    #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:\n    #    pytest.skip('Segfaults on mips64el')\n    # XXX bad abuse of \"struct { ...; }\".  It only works a bit by chance\n    # anyway.  XXX think about something better :-(\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { ...; } myhandle_t;\n        myhandle_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef short myhandle_t;\n        myhandle_t foo(void) { return 42; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == ffi.sizeof(\"short\")\n\ndef test_return_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(void) { foo_t r = { 45, 81 }; return r; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 81\n\ndef test_take_and_return_partial_structs():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(foo_t, foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(foo_t a, foo_t b) {\n            foo_t r = { 100, a.x * 5 + b.x * 7 };\n            return r;\n        }\n    \"\"\")\n    args = ffi.new(\"foo_t[3]\")\n    args[0].x = 1000\n    args[2].x = -498\n    h = lib.foo(args[0], args[2])\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 1000 * 5 - 498 * 7\n\ndef test_cannot_name_struct_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } **sp; void foo(sp);\")\n    e = pytest.raises(VerificationError, ffi.verify,\n                       \"typedef struct { int x; } **sp; void foo(sp x) { }\")\n    assert 'in argument of foo: unknown type name' in str(e.value)\n\ndef test_dont_check_unnamable_fields():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct { int x; } someone; };\")\n    ffi.verify(\"struct foo_s { struct { int x; } someone; };\")\n    # assert did not crash\n\ndef test_nested_anonymous_struct_exact():\n    if sys.platform == 'win32':\n        pytest.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    assert ffi.offsetof(\"struct foo_s\", \"c\") == 2 * ffi.sizeof(\"int\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n    ffi.verify(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(p[0]) == 3 * ffi.sizeof(\"int\")    # with alignment\n    p.a = 1234567\n    p.b = b'X'\n    p.c = b'Y'\n    assert p.a == 1234567\n    assert p.b == b'X'\n    assert p.c == b'Y'\n    assert p.d == b'Y'\n\ndef test_nested_anonymous_struct_exact_error():\n    if sys.platform == 'win32':\n        pytest.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    pytest.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; short b; }; union { char c, d; }; };\n    \"\"\")\n    # works fine now\n    #pytest.raises(VerificationError, ffi.verify, \"\"\"\n    #    struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };\n    #\"\"\")\n\ndef test_nested_anonymous_struct_inexact_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { char b; ...; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_nested_anonymous_struct_inexact_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { union { char c, d; }; struct { int a; char b; }; ...; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_ffi_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; long *z; };\")\n    ffi.verify(\"union foo_u { char x; int y; long *z; };\")\n\ndef test_ffi_union_partial():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; ...; };\")\n    ffi.verify(\"union foo_u { char x; int y; };\")\n    assert ffi.sizeof(\"union foo_u\") == 4\n\ndef test_ffi_union_with_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; union foo_u { struct foo_s s; };\")\n    ffi.verify(\"struct foo_s { int a; int x; }; \"\n               \"union foo_u { char b[32]; struct foo_s s; };\")\n    assert ffi.sizeof(\"struct foo_s\") == 8\n    assert ffi.sizeof(\"union foo_u\") == 32\n\ndef test_ffi_union_partial_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { char x; ...; } u1;\")\n    ffi.verify(\"typedef union { char x; int y; } u1;\")\n    assert ffi.sizeof(\"u1\") == 4\n\ndef test_ffi_union_with_partial_struct_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } s1;\"\n             \"typedef union { s1 s; } u1;\")\n    ffi.verify(\"typedef struct { int a; int x; } s1; \"\n               \"typedef union { char b[32]; s1 s; } u1;\")\n    assert ffi.sizeof(\"s1\") == 8\n    assert ffi.sizeof(\"u1\") == 32\n    assert ffi.offsetof(\"u1\", \"s\") == 0\n\ndef test_ffi_struct_packed():\n    if sys.platform == 'win32':\n        pytest.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int b; ...; };\")\n    ffi.verify(\"\"\"\n        struct foo_s {\n            char a;\n            int b;\n        } __attribute__((packed));\n    \"\"\")\n\ndef test_tmpdir():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"int foo(int a) { return a + 42; }\", tmpdir=tmpdir)\n    assert os.listdir(tmpdir)\n    assert lib.foo(100) == 142\n\ndef test_relative_to():\n    pytest.skip(\"not available\")\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    f = open(os.path.join(tmpdir, 'foo.h'), 'w')\n    f.write(\"int foo(int a) { return a + 42; }\\n\")\n    f.close()\n    lib = ffi.verify('#include \"foo.h\"',\n                     include_dirs=['.'],\n                     relative_to=os.path.join(tmpdir, 'x'))\n    assert lib.foo(100) == 142\n\ndef test_bug1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct tdlhandle_s { ...; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n    ffi.verify(\"\"\"\n        typedef struct tdlhandle_s { int foo; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n\ndef test_bool():\n    if sys.platform == 'win32':\n        pytest.skip(\"_Bool not in MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { _Bool x; };\"\n             \"_Bool foo(_Bool); static _Bool (*foop)(_Bool);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { _Bool x; };\n        int foo(int arg) {\n            return !arg;\n        }\n        _Bool _foofunc(_Bool x) {\n            return !x;\n        }\n        static _Bool (*foop)(_Bool) = _foofunc;\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.x = 1\n    assert p.x is True\n    with pytest.raises(OverflowError):\n        p.x = -1\n    with pytest.raises(TypeError):\n        p.x = 0.0\n    assert lib.foop(1) is False\n    assert lib.foop(True) is False\n    assert lib.foop(0) is True\n    pytest.raises(OverflowError, lib.foop, 42)\n    pytest.raises(TypeError, lib.foop, 0.0)\n    assert lib.foo(1) is False\n    assert lib.foo(True) is False\n    assert lib.foo(0) is True\n    pytest.raises(OverflowError, lib.foo, 42)\n    pytest.raises(TypeError, lib.foo, 0.0)\n    assert int(ffi.cast(\"_Bool\", long(1))) == 1\n    assert int(ffi.cast(\"_Bool\", long(0))) == 0\n    assert int(ffi.cast(\"_Bool\", long(-1))) == 1\n    assert int(ffi.cast(\"_Bool\", 10**200)) == 1\n    assert int(ffi.cast(\"_Bool\", 10**40000)) == 1\n    #\n    class Foo(object):\n        def __int__(self):\n            self.seen = 1\n            return result\n    f = Foo()\n    f.seen = 0\n    result = 42\n    assert int(ffi.cast(\"_Bool\", f)) == 1\n    assert f.seen\n    f.seen = 0\n    result = 0\n    assert int(ffi.cast(\"_Bool\", f)) == 0\n    assert f.seen\n    #\n    pytest.raises(TypeError, ffi.cast, \"_Bool\", [])\n\ndef test_bool_on_long_double():\n    if sys.platform == 'win32':\n        pytest.skip(\"_Bool not in MSVC\")\n    f = 1E-250\n    if f == 0.0 or f*f != 0.0:\n        pytest.skip(\"unexpected precision\")\n    ffi = FFI()\n    ffi.cdef(\"long double square(long double f); _Bool opposite(_Bool);\")\n    lib = ffi.verify(\"long double square(long double f) { return f*f; }\\n\"\n                     \"_Bool opposite(_Bool x) { return !x; }\")\n    f0 = lib.square(0.0)\n    f2 = lib.square(f)\n    f3 = lib.square(f * 2.0)\n    if repr(f2) == repr(f3):\n        pytest.skip(\"long double doesn't have enough precision\")\n    assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'\n    assert int(ffi.cast(\"_Bool\", f2)) == 1\n    assert int(ffi.cast(\"_Bool\", f3)) == 1\n    assert int(ffi.cast(\"_Bool\", f0)) == 0\n    pytest.raises(TypeError, lib.opposite, f2)\n\ndef test_cannot_pass_float():\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            ffi = FFI()\n            ffi.cdef(\"struct foo_s { %s x; };\\n\"\n                     \"int foo(%s);\" % (type, type))\n            lib = ffi.verify(\"\"\"\n                struct foo_s { %s x; };\n                int foo(%s arg) {\n                    return !arg;\n                }\n            \"\"\" % (type, type))\n            p = ffi.new(\"struct foo_s *\")\n            with pytest.raises(TypeError):\n                p.x = 0.0\n            assert lib.foo(42) == 0\n            assert lib.foo(0) == 1\n            pytest.raises(TypeError, lib.foo, 0.0)\n\ndef test_addressof():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *point) {\n            struct point_s r;\n            r.x = point->x + point->y;\n            r.y = point->x - point->y;\n            return r;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.point.x = 16\n    p.point.y = 9\n    pytest.raises(TypeError, lib.sum_coord, p.point)\n    res = lib.sum_coord(ffi.addressof(p.point))\n    assert res.x == 25\n    assert res.y == 7\n    res2 = lib.sum_coord(ffi.addressof(res))\n    assert res2.x == 32\n    assert res2.y == 18\n    pytest.raises(TypeError, lib.sum_coord, res2)\n\ndef test_callback_in_thread():\n    pytest.xfail(\"adapt or remove\")\n    if sys.platform == 'win32':\n        pytest.skip(\"pthread only\")\n    import os, subprocess\n    from cffi import _imp_emulation as imp\n    arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')\n    g = subprocess.Popen([sys.executable, arg,\n                          os.path.dirname(imp.find_module('cffi')[1])])\n    result = g.wait()\n    assert result == 0\n\ndef test_keepalive_lib():\n    pytest.xfail(\"adapt or remove\")\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del ffi\n    import gc; gc.collect()       # lib stays alive\n    assert lib_r() is not None\n    assert ffi_r() is not None\n    assert func() == 42\n\ndef test_keepalive_ffi():\n    pytest.xfail(\"adapt or remove\")\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del lib\n    import gc; gc.collect()       # ffi stays alive\n    assert ffi_r() is not None\n    assert lib_r() is not None\n    assert func() == 42\n\ndef test_FILE_stored_in_stdout():\n    if not sys.platform.startswith('linux') or is_musl:\n        pytest.skip(\"likely, we cannot assign to stdout\")\n    ffi = FFI()\n    ffi.cdef(\"int printf(const char *, ...); FILE *setstdout(FILE *);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *setstdout(FILE *f) {\n            FILE *result = stdout;\n            stdout = f;\n            return result;\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    old_stdout = lib.setstdout(fw1)\n    try:\n        #\n        fw1.write(b\"X\")\n        r = lib.printf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n        fw1.close()\n        assert r == len(\"hello, 42!\\n\")\n        #\n    finally:\n        lib.setstdout(old_stdout)\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_FILE_stored_explicitly():\n    ffi = FFI()\n    ffi.cdef(\"int myprintf11(const char *, int); extern FILE *myfile;\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *myfile;\n        int myprintf11(const char *out, int value) {\n            return fprintf(myfile, out, value);\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    lib.myfile = ffi.cast(\"FILE *\", fw1)\n    #\n    fw1.write(b\"X\")\n    r = lib.myprintf11(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n    fw1.close()\n    assert r == len(\"hello, 42!\\n\")\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_global_array_with_missing_length():\n    ffi = FFI()\n    ffi.cdef(\"extern int fooarray[];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int *'\")\n\ndef test_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"extern int fooarray[...];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int[50]'\")\n\ndef test_bad_global_array_with_dotdotdot_length():\n    pytest.xfail(\"was detected only because 23 bytes cannot be divided by 4; \"\n                  \"redo more generally\")\n    ffi = FFI()\n    ffi.cdef(\"extern int fooarray[...];\")\n    pytest.raises(VerificationError, ffi.verify, \"char fooarray[23];\")\n\ndef test_struct_containing_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { ...; }; struct bar_s { struct foo_s f; ...; };\")\n    ffi.verify(\"struct foo_s { int x; }; struct bar_s { struct foo_s f; };\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct bar_s f; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct bar_s { int x; }; struct foo_s { struct bar_s f; };\")\n\ndef test_struct_returned_by_func():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; foo_t myfunc(void);\")\n    e = pytest.raises(TypeError, ffi.verify,\n                       \"typedef struct { int x; } foo_t; \"\n                       \"foo_t myfunc(void) { foo_t x = { 42 }; return x; }\")\n    assert str(e.value) == (\n        \"function myfunc: 'foo_t' is used as result type, but is opaque\")\n\ndef test_include():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x; ...; } foo_t;\")\n    ffi1.verify(\"typedef struct { int y, x; } foo_t;\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(foo_t *);\")\n    lib = ffi2.verify(\"typedef struct { int y, x; } foo_t;\"\n                      \"int myfunc(foo_t *p) { return 42 * p->x; }\")\n    res = lib.myfunc(ffi2.new(\"foo_t *\", {'x': 10}))\n    assert res == 420\n    res = lib.myfunc(ffi1.new(\"foo_t *\", {'x': -10}))\n    assert res == -420\n\ndef test_include_enum():\n    ffi1 = FFI()\n    ffi1.cdef(\"enum foo_e { AA, ... };\")\n    lib1 = ffi1.verify(\"enum foo_e { CC, BB, AA };\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(enum foo_e);\")\n    lib2 = ffi2.verify(\"enum foo_e { CC, BB, AA };\"\n                       \"int myfunc(enum foo_e x) { return (int)x; }\")\n    res = lib2.myfunc(lib2.AA)\n    assert res == 2\n\ndef test_named_pointer_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } *mystruct_p;\\n\"\n             \"mystruct_p ff5a(mystruct_p);\")\n    lib = ffi.verify(\"typedef struct { int x; } *mystruct_p;\\n\"\n                     \"mystruct_p ff5a(mystruct_p p) { p->x += 40; return p; }\")\n    p = ffi.new(\"mystruct_p\", [-2])\n    q = lib.ff5a(p)\n    assert q == p\n    assert p.x == 38\n\ndef test_enum_size():\n    cases = [('123',           4, 4294967295),\n             ('4294967295U',   4, 4294967295),\n             ('-123',          4, -1),\n             ('-2147483647-1', 4, -1),\n             ]\n    if FFI().sizeof(\"long\") == 8:\n        cases += [('4294967296L',        8, 2**64-1),\n                  ('%dUL' % (2**64-1),   8, 2**64-1),\n                  ('-2147483649L',       8, -1),\n                  ('%dL-1L' % (1-2**63), 8, -1)]\n    for hidden_value, expected_size, expected_minus1 in cases:\n        if sys.platform == 'win32' and 'U' in hidden_value:\n            continue   # skipped on Windows\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n        assert lib.AA == 0\n        assert lib.BB == eval(hidden_value.replace('U', '').replace('L', ''))\n        assert ffi.sizeof(\"enum foo_e\") == expected_size\n        if sys.platform != 'win32':\n            assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n    # test with the large value hidden:\n    # disabled so far, doesn't work\n##    for hidden_value, expected_size, expected_minus1 in cases:\n##        ffi = FFI()\n##        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n##        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n##        assert lib.AA == 0\n##        assert ffi.sizeof(\"enum foo_e\") == expected_size\n##        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n\ndef test_enum_bug118():\n    maxulong = 256 ** FFI().sizeof(\"unsigned long\") - 1\n    for c2, c2c in [(-1, ''),\n                    (-1, ''),\n                    (0xffffffff, 'U'),\n                    (maxulong, 'UL'),\n                    (-int(maxulong / 3), 'L')]:\n        if c2c and sys.platform == 'win32':\n            continue     # enums may always be signed with MSVC\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA };\")\n        lib = ffi.verify(\"enum foo_e { AA=%s%s };\" % (c2, c2c))\n        assert lib.AA == c2\n\ndef test_string_to_voidp_arg():\n    ffi = FFI()\n    ffi.cdef(\"int myfunc(void *);\")\n    lib = ffi.verify(\"int myfunc(void *p) { return ((signed char *)p)[0]; }\")\n    res = lib.myfunc(b\"hi!\")\n    assert res == ord(b\"h\")\n    p = ffi.new(\"char[]\", b\"gah\")\n    res = lib.myfunc(p)\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"void *\", p))\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"int *\", p))\n    assert res == ord(b\"g\")\n\ndef test_callback_indirection():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        static int (*python_callback)(int how_many, int *values);\n        int (*const c_callback)(int,...);   /* pass this ptr to C routines */\n        int some_c_function(int(*cb)(int,...));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #include <stdarg.h>\n        #ifdef _WIN32\n        #include <malloc.h>\n        #define alloca _alloca\n        #else\n        # ifdef __FreeBSD__\n        #  include <stdlib.h>\n        # else\n        #  include <alloca.h>\n        # endif\n        #endif\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca((size_t)how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n        int some_c_function(int(*cb)(int,...)) {\n            int result = cb(2, 10, 20);\n            result += cb(3, 30, 40, 50);\n            return result;\n        }\n    \"\"\")\n    seen = []\n    @ffi.callback(\"int(int, int*)\")\n    def python_callback(how_many, values):\n        seen.append([values[i] for i in range(how_many)])\n        return 42\n    lib.python_callback = python_callback\n\n    res = lib.some_c_function(lib.c_callback)\n    assert res == 84\n    assert seen == [[10, 20], [30, 40, 50]]\n\ndef test_floatstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"float sum3floats(float *);\")\n    lib = ffi.verify(\"\"\"\n        float sum3floats(float *f) {\n            return f[0] + f[1] + f[2];\n        }\n    \"\"\")\n    assert lib.sum3floats((1.5, 2.5, 3.5)) == 7.5\n    p = ffi.new(\"float[]\", (1.5, 2.5, 3.5))\n    assert lib.sum3floats(p) == 7.5\n\ndef test_charstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"char sum3chars(char *);\")\n    lib = ffi.verify(\"\"\"\n        char sum3chars(char *f) {\n            return (char)(f[0] + f[1] + f[2]);\n        }\n    \"\"\")\n    assert lib.sum3chars((b'\\x10', b'\\x20', b'\\x30')) == b'\\x60'\n    p = ffi.new(\"char[]\", b'\\x10\\x20\\x30')\n    assert lib.sum3chars(p) == b'\\x60'\n\ndef test_passing_string_or_NULL():\n    ffi = FFI()\n    ffi.cdef(\"int seeme1(char *); int seeme2(int *);\")\n    lib = ffi.verify(\"\"\"\n        int seeme1(char *x) {\n            return (x == NULL);\n        }\n        int seeme2(int *x) {\n            return (x == NULL);\n        }\n    \"\"\")\n    assert lib.seeme1(b\"foo\") == 0\n    assert lib.seeme1(ffi.NULL) == 1\n    assert lib.seeme2([42, 43]) == 0\n    assert lib.seeme2(ffi.NULL) == 1\n    pytest.raises(TypeError, lib.seeme1, None)\n    pytest.raises(TypeError, lib.seeme2, None)\n    pytest.raises(TypeError, lib.seeme1, 0.0)\n    pytest.raises(TypeError, lib.seeme2, 0.0)\n    pytest.raises(TypeError, lib.seeme1, 0)\n    pytest.raises(TypeError, lib.seeme2, 0)\n    zeroL  = 99999999999999999999\n    zeroL -= 99999999999999999999\n    pytest.raises(TypeError, lib.seeme2, zeroL)\n\ndef test_typeof_function():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, char);\")\n    lib = ffi.verify(\"int foo(int x, char y) { (void)x; (void)y; return 42; }\")\n    ctype = ffi.typeof(lib.foo)\n    assert len(ctype.args) == 2\n    assert ctype.result == ffi.typeof(\"int\")\n\ndef test_call_with_voidstar_arg():\n    ffi = FFI()\n    ffi.cdef(\"int f(void *);\")\n    lib = ffi.verify(\"int f(void *x) { return ((char*)x)[0]; }\")\n    assert lib.f(b\"foobar\") == ord(b\"f\")\n\ndef test_dir():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void somefunc(void);\n                extern int somevar, somearray[2];\n                static char *const sv2;\n                enum my_e { AA, BB, ... };\n                #define FOO ...\"\"\")\n    lib = ffi.verify(\"\"\"void somefunc(void) { }\n                        int somevar, somearray[2];\n                        #define sv2 \"text\"\n                        enum my_e { AA, BB };\n                        #define FOO 42\"\"\")\n    assert dir(lib) == ['AA', 'BB', 'FOO', 'somearray',\n                        'somefunc', 'somevar', 'sv2']\n\ndef test_typeof_func_with_struct_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct s { int a; }; int foo(struct s);\"\"\")\n    lib = ffi.verify(\"\"\"struct s { int a; };\n                        int foo(struct s x) { return x.a; }\"\"\")\n    s = ffi.new(\"struct s *\", [-1234])\n    m = lib.foo(s[0])\n    assert m == -1234\n    assert repr(ffi.typeof(lib.foo)) == \"<ctype 'int(*)(struct s)'>\"\n\ndef test_bug_const_char_ptr_array_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"extern const char *a[...];\"\"\")\n    lib = ffi.verify(\"\"\"const char *a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'char *[5]'>\"\n\ndef test_bug_const_char_ptr_array_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"extern const int a[];\"\"\")\n    lib = ffi.verify(\"\"\"const int a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'int *'>\"\n\ndef _test_various_calls(force_libffi):\n    cdef_source = \"\"\"\n    extern int xvalue;\n    extern long long ivalue, rvalue;\n    extern float fvalue;\n    extern double dvalue;\n    extern long double Dvalue;\n    signed char tf_bb(signed char x, signed char c);\n    unsigned char tf_bB(signed char x, unsigned char c);\n    short tf_bh(signed char x, short c);\n    unsigned short tf_bH(signed char x, unsigned short c);\n    int tf_bi(signed char x, int c);\n    unsigned int tf_bI(signed char x, unsigned int c);\n    long tf_bl(signed char x, long c);\n    unsigned long tf_bL(signed char x, unsigned long c);\n    long long tf_bq(signed char x, long long c);\n    unsigned long long tf_bQ(signed char x, unsigned long long c);\n    float tf_bf(signed char x, float c);\n    double tf_bd(signed char x, double c);\n    long double tf_bD(signed char x, long double c);\n    \"\"\"\n    if force_libffi:\n        cdef_source = (cdef_source\n            .replace('tf_', '(*const tf_')\n            .replace('(signed char x', ')(signed char x'))\n    ffi = FFI()\n    ffi.cdef(cdef_source)\n    lib = ffi.verify(\"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n\n    typedef signed char b_t;\n    typedef unsigned char B_t;\n    typedef short h_t;\n    typedef unsigned short H_t;\n    typedef int i_t;\n    typedef unsigned int I_t;\n    typedef long l_t;\n    typedef unsigned long L_t;\n    typedef long long q_t;\n    typedef unsigned long long Q_t;\n    typedef float f_t;\n    typedef double d_t;\n    typedef long double D_t;\n    #define S(letter)  xvalue = (int)x; letter##value = (letter##_t)c;\n    #define R(letter)  return (letter##_t)rvalue;\n\n    signed char tf_bb(signed char x, signed char c) { S(i) R(b) }\n    unsigned char tf_bB(signed char x, unsigned char c) { S(i) R(B) }\n    short tf_bh(signed char x, short c) { S(i) R(h) }\n    unsigned short tf_bH(signed char x, unsigned short c) { S(i) R(H) }\n    int tf_bi(signed char x, int c) { S(i) R(i) }\n    unsigned int tf_bI(signed char x, unsigned int c) { S(i) R(I) }\n    long tf_bl(signed char x, long c) { S(i) R(l) }\n    unsigned long tf_bL(signed char x, unsigned long c) { S(i) R(L) }\n    long long tf_bq(signed char x, long long c) { S(i) R(q) }\n    unsigned long long tf_bQ(signed char x, unsigned long long c) { S(i) R(Q) }\n    float tf_bf(signed char x, float c) { S(f) R(f) }\n    double tf_bd(signed char x, double c) { S(d) R(d) }\n    long double tf_bD(signed char x, long double c) { S(D) R(D) }\n    \"\"\")\n    lib.rvalue = 0x7182838485868788\n    for kind, cname in [('b', 'signed char'),\n                        ('B', 'unsigned char'),\n                        ('h', 'short'),\n                        ('H', 'unsigned short'),\n                        ('i', 'int'),\n                        ('I', 'unsigned int'),\n                        ('l', 'long'),\n                        ('L', 'unsigned long'),\n                        ('q', 'long long'),\n                        ('Q', 'unsigned long long'),\n                        ('f', 'float'),\n                        ('d', 'double'),\n                        ('D', 'long double')]:\n        sign = +1 if 'unsigned' in cname else -1\n        lib.xvalue = 0\n        lib.ivalue = 0\n        lib.fvalue = 0\n        lib.dvalue = 0\n        lib.Dvalue = 0\n        fun = getattr(lib, 'tf_b' + kind)\n        res = fun(-42, sign * 99)\n        if kind == 'D':\n            res = float(res)\n        assert res == int(ffi.cast(cname, 0x7182838485868788))\n        assert lib.xvalue == -42\n        if kind in 'fdD':\n            assert float(getattr(lib, kind + 'value')) == -99.0\n        else:\n            assert lib.ivalue == sign * 99\n\ndef test_various_calls_direct():\n    _test_various_calls(force_libffi=False)\n\ndef test_various_calls_libffi():\n    _test_various_calls(force_libffi=True)\n\ndef test_ptr_to_opaque():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; int f1(foo_t*); foo_t *f2(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdlib.h>\n        typedef struct { int x; } foo_t;\n        int f1(foo_t* p) {\n            int x = p->x;\n            free(p);\n            return x;\n        }\n        foo_t *f2(int x) {\n            foo_t *p = malloc(sizeof(foo_t));\n            p->x = x;\n            return p;\n        }\n    \"\"\")\n    p = lib.f2(42)\n    x = lib.f1(p)\n    assert x == 42\n\ndef _run_in_multiple_threads(test1):\n    test1()\n    import sys\n    try:\n        import thread\n    except ImportError:\n        import _thread as thread\n    errors = []\n    def wrapper(lock):\n        try:\n            test1()\n        except:\n            errors.append(sys.exc_info())\n        lock.release()\n    locks = []\n    for i in range(10):\n        _lock = thread.allocate_lock()\n        _lock.acquire()\n        thread.start_new_thread(wrapper, (_lock,))\n        locks.append(_lock)\n    for _lock in locks:\n        _lock.acquire()\n        if errors:\n            raise errors[0][1]\n\ndef test_errno_working_even_with_pypys_jit():\n    ffi = FFI()\n    ffi.cdef(\"int f(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <errno.h>\n        int f(int x) { return (errno = errno + x); }\n    \"\"\")\n    @_run_in_multiple_threads\n    def test1():\n        ffi.errno = 0\n        for i in range(10000):\n            e = lib.f(1)\n            assert e == i + 1\n            assert ffi.errno == e\n        for i in range(10000):\n            ffi.errno = i\n            e = lib.f(42)\n            assert e == i + 42\n\ndef test_getlasterror_working_even_with_pypys_jit():\n    if sys.platform != 'win32':\n        pytest.skip(\"win32-only test\")\n    ffi = FFI()\n    ffi.cdef(\"void SetLastError(DWORD);\")\n    lib = ffi.dlopen(\"Kernel32.dll\")\n    @_run_in_multiple_threads\n    def test1():\n        for i in range(10000):\n            n = (1 << 29) + i\n            lib.SetLastError(n)\n            assert ffi.getwinerror()[0] == n\n\ndef test_verify_dlopen_flags():\n    if not hasattr(sys, 'setdlopenflags'):\n        pytest.skip(\"requires sys.setdlopenflags()\")\n    # Careful with RTLD_GLOBAL.  If by chance the FFI is not deleted\n    # promptly, like on PyPy, then other tests may see the same\n    # exported symbols as well.  So we must not export a simple name\n    # like 'foo'!\n    old = sys.getdlopenflags()\n    try:\n        ffi1 = FFI()\n        ffi1.cdef(\"extern int foo_verify_dlopen_flags_1;\")\n        sys.setdlopenflags(ffi1.RTLD_GLOBAL | ffi1.RTLD_NOW)\n        lib1 = ffi1.verify(\"int foo_verify_dlopen_flags_1;\")\n    finally:\n        sys.setdlopenflags(old)\n\n    ffi2 = FFI()\n    ffi2.cdef(\"int *getptr(void);\")\n    lib2 = ffi2.verify(\"\"\"\n        extern int foo_verify_dlopen_flags_1;\n        static int *getptr(void) { return &foo_verify_dlopen_flags_1; }\n    \"\"\")\n    p = lib2.getptr()\n    assert ffi1.addressof(lib1, 'foo_verify_dlopen_flags_1') == p\n\ndef test_consider_not_implemented_function_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { int a; float b; } Data;\"\n             \"typedef struct { int a:2; } MyStr;\"\n             \"typedef void (*foofunc_t)(Data);\"\n             \"typedef Data (*bazfunc_t)(void);\"\n             \"typedef MyStr (*barfunc_t)(void);\")\n    fooptr = ffi.cast(\"foofunc_t\", 123)\n    bazptr = ffi.cast(\"bazfunc_t\", 123)\n    barptr = ffi.cast(\"barfunc_t\", 123)\n    # assert did not crash so far\n    e = pytest.raises(NotImplementedError, fooptr, ffi.new(\"Data *\"))\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as argument by libffi.  Unions are only \"\n        \"supported as argument if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = pytest.raises(NotImplementedError, bazptr)\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as return value by libffi.  Unions are \"\n        \"only supported as return value if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = pytest.raises(NotImplementedError, barptr)\n    assert str(e.value) == (\n        \"ctype 'MyStr' not supported as return value.  It is a struct with \"\n        \"bit fields, which libffi does not support.  Such structs are only \"\n        \"supported as return value if the function is 'API mode' and non-\"\n        \"variadic (i.e. declared inside ffibuilder.cdef()+ffibuilder.\"\n        \"set_source() and not taking a final '...' argument)\")\n\ndef test_verify_extra_arguments():\n    ffi = FFI()\n    ffi.cdef(\"#define ABA ...\")\n    lib = ffi.verify(\"\", define_macros=[('ABA', '42')])\n    assert lib.ABA == 42\n\ndef test_implicit_unicode_on_windows():\n    from cffi import FFIError\n    if sys.platform != 'win32':\n        pytest.skip(\"win32-only test\")\n    ffi = FFI()\n    e = pytest.raises(FFIError, ffi.cdef, \"int foo(LPTSTR);\")\n    assert str(e.value) == (\"The Windows type 'LPTSTR' is only available after\"\n                            \" you call ffi.set_unicode()\")\n    for with_unicode in [True, False]:\n        ffi = FFI()\n        ffi.set_unicode(with_unicode)\n        ffi.cdef(\"\"\"\n            DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename,\n                                    DWORD nSize);\n        \"\"\")\n        lib = ffi.verify(\"\"\"\n            #include <windows.h>\n        \"\"\", libraries=['Kernel32'])\n        outbuf = ffi.new(\"TCHAR[]\", 200)\n        n = lib.GetModuleFileName(ffi.NULL, outbuf, 500)\n        assert 0 < n < 500\n        for i in range(n):\n            #print repr(outbuf[i])\n            assert ord(outbuf[i]) != 0\n        assert ord(outbuf[n]) == 0\n        assert ord(outbuf[0]) < 128     # should be a letter, or '\\'\n\ndef test_define_known_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 0x123\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_define_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 123\")\n    lib = ffi.verify(\"#define FOO 124\")     # used to complain\n    with pytest.raises(ffi.error) as e:\n        lib.FOO\n    assert str(e.value) == (\"the C compiler says 'FOO' is equal to 124 (0x7c),\"\n                            \" but the cdef disagrees\")\n\ndef test_some_integer_type_for_issue73():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef int... AnIntegerWith32Bits;\n        typedef AnIntegerWith32Bits (*AFunctionReturningInteger) (void);\n        AnIntegerWith32Bits InvokeFunction(AFunctionReturningInteger);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #ifdef __LP64__\n        typedef int AnIntegerWith32Bits;\n        #else\n        typedef long AnIntegerWith32Bits;\n        #endif\n        typedef AnIntegerWith32Bits (*AFunctionReturningInteger) (void);\n        AnIntegerWith32Bits InvokeFunction(AFunctionReturningInteger f) {\n            return f();\n        }\n    \"\"\")\n    @ffi.callback(\"AFunctionReturningInteger\")\n    def add():\n        return 3 + 4\n    x = lib.InvokeFunction(add)\n    assert x == 7\n\ndef test_unsupported_some_primitive_types():\n    ffi = FFI()\n    pytest.raises((FFIError,      # with pycparser <= 2.17\n                    CDefError),    # with pycparser >= 2.18\n                   ffi.cdef, \"\"\"typedef void... foo_t;\"\"\")\n    #\n    ffi.cdef(\"typedef int... foo_t;\")\n    pytest.raises(VerificationError, ffi.verify, \"typedef float foo_t;\")\n\ndef test_windows_dllimport_data():\n    if sys.platform != 'win32':\n        pytest.skip(\"Windows only\")\n    from testing.udir import udir\n    tmpfile = udir.join('dllimport_data.c')\n    tmpfile.write('int my_value = 42;\\n')\n    ffi = FFI()\n    ffi.cdef(\"int my_value;\")\n    lib = ffi.verify(\"extern __declspec(dllimport) int my_value;\",\n                     sources = [str(tmpfile)])\n    assert lib.my_value == 42\n\ndef test_macro_var():\n    ffi = FFI()\n    ffi.cdef(\"extern int myarray[50], my_value;\")\n    lib = ffi.verify(\"\"\"\n        int myarray[50];\n        int *get_my_value(void) {\n            static int index = 0;\n            return &myarray[index++];\n        }\n        #define my_value (*get_my_value())\n    \"\"\")\n    assert lib.my_value == 0             # [0]\n    lib.my_value = 42                    # [1]\n    assert lib.myarray[1] == 42\n    assert lib.my_value == 0             # [2]\n    lib.myarray[3] = 63\n    assert lib.my_value == 63            # [3]\n    p = ffi.addressof(lib, 'my_value')   # [4]\n    assert p[-1] == 63\n    assert p[0] == 0\n    assert p == lib.myarray + 4\n    p[1] = 82\n    assert lib.my_value == 82            # [5]\n\ndef test_const_pointer_to_pointer():\n    ffi = FFI()\n    ffi.cdef(\"struct s { char *const *a; };\")\n    ffi.verify(\"struct s { char *const *a; };\")\n\ndef test_share_FILE():\n    ffi1 = FFI()\n    ffi1.cdef(\"void do_stuff(FILE *);\")\n    lib1 = ffi1.verify(\"void do_stuff(FILE *f) { (void)f; }\")\n    ffi2 = FFI()\n    ffi2.cdef(\"FILE *barize(void);\")\n    lib2 = ffi2.verify(\"FILE *barize(void) { return NULL; }\")\n    lib1.do_stuff(lib2.barize())\n\ndef test_win_common_types():\n    if sys.platform != 'win32':\n        pytest.skip(\"Windows only\")\n    ffi = FFI()\n    ffi.set_unicode(True)\n    ffi.verify(\"\")\n    assert ffi.typeof(\"PBYTE\") is ffi.typeof(\"unsigned char *\")\n    if sys.maxsize > 2**32:\n        expected = \"unsigned long long\"\n    else:\n        expected = \"unsigned int\"\n    assert ffi.typeof(\"UINT_PTR\") is ffi.typeof(expected)\n    assert ffi.typeof(\"PTSTR\") is ffi.typeof(\"wchar_t *\")\n\ndef _only_test_on_linux_intel():\n    if not sys.platform.startswith('linux'):\n        pytest.skip('only running the memory-intensive test on Linux')\n    import platform\n    machine = platform.machine()\n    if 'x86' not in machine and 'x64' not in machine:\n        pytest.skip('only running the memory-intensive test on x86/x64')\n\ndef test_ffi_gc_size_arg():\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    for i in range(2000):\n        p = lib.malloc(20*1024*1024)    # 20 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 20*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 20*1024*1024)\n        del p\n        # with PyPy's GC, the above would rapidly consume 40 GB of RAM\n        # without the third argument to ffi.gc()\n\ndef test_ffi_gc_size_arg_2():\n    # a variant of the above: this \"attack\" works on cpython's cyclic gc too\n    # and I found no obvious way to prevent that.  So for now, this test\n    # is skipped on CPython, where it eats all the memory.\n    if '__pypy__' not in sys.builtin_module_names:\n        pytest.skip(\"find a way to tweak the cyclic GC of CPython\")\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = lib.malloc(50*1024*1024)    # 50 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 50*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 50*1024*1024)\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n\ndef test_ffi_new_with_cycles():\n    # still another variant, with ffi.new()\n    if '__pypy__' not in sys.builtin_module_names:\n        pytest.skip(\"find a way to tweak the cyclic GC of CPython\")\n    ffi = FFI()\n    ffi.cdef(\"\")\n    lib = ffi.verify(\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = ffi.new(\"char[]\", 50*1024*1024)    # 50 MB\n        for j in range(0, 50*1024*1024, 4096):\n            p[j] = b'!'\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n", "testing/embedding/add2.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\"\"\n    int add2(int, int, int);\n\"\"\")\n\nffi.embedding_init_code(r\"\"\"\n    import sys\n    sys.stdout.write(\"prepADD2\\n\")\n\n    assert '_add2_cffi' in sys.modules\n    m = sys.modules['_add2_cffi']\n    import _add2_cffi\n    ffi = _add2_cffi.ffi\n\n    @ffi.def_extern()\n    def add2(x, y, z):\n        sys.stdout.write(\"adding %d and %d and %d\\n\" % (x, y, z))\n        sys.stdout.flush()\n        return x + y + z\n\"\"\")\n\nffi.set_source(\"_add2_cffi\", \"\"\"\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/test_basic.py": "import sys, os, re\nimport shutil, subprocess, time\nimport pytest\nfrom testing.udir import udir\nimport cffi\n\n\nlocal_dir = os.path.dirname(os.path.abspath(__file__))\n_link_error = '?'\n\ndef check_lib_python_found(tmpdir):\n    global _link_error\n    if _link_error == '?':\n        ffi = cffi.FFI()\n        kwds = {}\n        ffi._apply_embedding_fix(kwds)\n        ffi.set_source(\"_test_lib_python_found\", \"\", **kwds)\n        try:\n            ffi.compile(tmpdir=tmpdir, verbose=True)\n        except cffi.VerificationError as e:\n            _link_error = e\n        else:\n            _link_error = None\n    if _link_error:\n        pytest.skip(str(_link_error))\n\n\ndef prefix_pythonpath():\n    cffi_base = os.path.dirname(os.path.dirname(local_dir))\n    pythonpath = org_env.get('PYTHONPATH', '').split(os.pathsep)\n    if cffi_base not in pythonpath:\n        pythonpath.insert(0, cffi_base)\n    return os.pathsep.join(pythonpath)\n\ndef copy_away_env():\n    global org_env\n    try:\n        org_env\n    except NameError:\n        org_env = os.environ.copy()\n\n\nclass EmbeddingTests:\n    _compiled_modules = {}\n\n    def setup_method(self, meth):\n        check_lib_python_found(str(udir.ensure('embedding', dir=1)))\n        self._path = udir.join('embedding', meth.__name__)\n        if sys.platform == \"win32\" or sys.platform == \"darwin\":\n            self._compiled_modules.clear()   # workaround\n\n    def get_path(self):\n        return str(self._path.ensure(dir=1))\n\n    def _run_base(self, args, **kwds):\n        print('RUNNING:', args, kwds)\n        return subprocess.Popen(args, **kwds)\n\n    def _run(self, args):\n        popen = self._run_base(args, cwd=self.get_path(),\n                                 stdout=subprocess.PIPE,\n                                 universal_newlines=True)\n        output = popen.stdout.read()\n        err = popen.wait()\n        if err:\n            raise OSError((\"popen failed with exit code %r: %r\\n\\n%s\" % (\n                err, args, output)).rstrip())\n        print(output.rstrip())\n        return output\n\n    def prepare_module(self, name):\n        self.patch_environment()\n        if name not in self._compiled_modules:\n            path = self.get_path()\n            filename = '%s.py' % name\n            # NOTE: if you have an .egg globally installed with an older\n            # version of cffi, this will not work, because sys.path ends\n            # up with the .egg before the PYTHONPATH entries.  I didn't\n            # find a solution to that: we could hack sys.path inside the\n            # script run here, but we can't hack it in the same way in\n            # execute().\n            pathname = os.path.join(path, filename)\n            with open(pathname, 'w') as g:\n                g.write('''\n# https://bugs.python.org/issue23246\nimport sys\nif sys.platform == 'win32':\n    try:\n        import setuptools\n    except ImportError:\n        pass\n''')\n                with open(os.path.join(local_dir, filename), 'r') as f:\n                    g.write(f.read())\n\n            output = self._run([sys.executable, pathname])\n            match = re.compile(r\"\\bFILENAME: (.+)\").search(output)\n            assert match\n            dynamic_lib_name = match.group(1)\n            if sys.platform == 'win32':\n                assert dynamic_lib_name.endswith('_cffi.dll')\n            elif sys.platform == 'darwin':\n                assert dynamic_lib_name.endswith('_cffi.dylib')\n            else:\n                assert dynamic_lib_name.endswith('_cffi.so')\n            self._compiled_modules[name] = dynamic_lib_name\n        return self._compiled_modules[name]\n\n    def compile(self, name, modules, opt=False, threads=False, defines={}):\n        path = self.get_path()\n        filename = '%s.c' % name\n        shutil.copy(os.path.join(local_dir, filename), path)\n        shutil.copy(os.path.join(local_dir, 'thread-test.h'), path)\n        import distutils.ccompiler\n        curdir = os.getcwd()\n        try:\n            os.chdir(self.get_path())\n            c = distutils.ccompiler.new_compiler()\n            print('compiling %s with %r' % (name, modules))\n            extra_preargs = []\n            debug = True\n            if sys.platform == 'win32':\n                libfiles = []\n                for m in modules:\n                    m = os.path.basename(m)\n                    assert m.endswith('.dll')\n                    libfiles.append('Release\\\\%s.lib' % m[:-4])\n                modules = libfiles\n                extra_preargs.append('/MANIFEST')\n                debug = False    # you need to install extra stuff\n                                 # for this to work\n            elif threads:\n                extra_preargs.append('-pthread')\n            objects = c.compile([filename], macros=sorted(defines.items()),\n                                debug=debug)\n            c.link_executable(objects + modules, name, extra_preargs=extra_preargs)\n        finally:\n            os.chdir(curdir)\n\n    def patch_environment(self):\n        copy_away_env()\n        path = self.get_path()\n        # for libpypy-c.dll or Python27.dll\n        path = os.path.split(sys.executable)[0] + os.path.pathsep + path\n        env_extra = {'PYTHONPATH': prefix_pythonpath()}\n        if sys.platform == 'win32':\n            envname = 'PATH'\n        else:\n            envname = 'LD_LIBRARY_PATH'\n        libpath = org_env.get(envname)\n        if libpath:\n            libpath = path + os.path.pathsep + libpath\n        else:\n            libpath = path\n        env_extra[envname] = libpath\n        for key, value in sorted(env_extra.items()):\n            if os.environ.get(key) != value:\n                print('* setting env var %r to %r' % (key, value))\n                os.environ[key] = value\n\n    def execute(self, name):\n        path = self.get_path()\n        print('running %r in %r' % (name, path))\n        executable_name = name\n        if sys.platform == 'win32':\n            executable_name = os.path.join(path, executable_name + '.exe')\n        else:\n            executable_name = os.path.join('.', executable_name)\n        popen = self._run_base([executable_name], cwd=path,\n                               stdout=subprocess.PIPE,\n                               universal_newlines=True)\n        result = popen.stdout.read()\n        err = popen.wait()\n        if err:\n            raise OSError(\"%r failed with exit code %r\" % (\n                os.path.join(path, executable_name), err))\n        return result\n\n\nclass TestBasic(EmbeddingTests):\n    def test_empty(self):\n        empty_cffi = self.prepare_module('empty')\n        self.compile('empty-test', [empty_cffi])\n        output = self.execute('empty-test')\n        assert output == 'OK\\n'\n\n    def test_basic(self):\n        add1_cffi = self.prepare_module('add1')\n        self.compile('add1-test', [add1_cffi])\n        output = self.execute('add1-test')\n        assert output == (\"preparing...\\n\"\n                          \"adding 40 and 2\\n\"\n                          \"adding 100 and -5\\n\"\n                          \"got: 42 95\\n\")\n\n    def test_two_modules(self):\n        add1_cffi = self.prepare_module('add1')\n        add2_cffi = self.prepare_module('add2')\n        self.compile('add2-test', [add1_cffi, add2_cffi])\n        output = self.execute('add2-test')\n        assert output == (\"preparing...\\n\"\n                          \"adding 40 and 2\\n\"\n                          \"prepADD2\\n\"\n                          \"adding 100 and -5 and -20\\n\"\n                          \"got: 42 75\\n\")\n\n    def test_init_time_error(self):\n        initerror_cffi = self.prepare_module('initerror')\n        self.compile('add1-test', [initerror_cffi])\n        output = self.execute('add1-test')\n        assert output == \"got: 0 0\\n\"    # plus lots of info to stderr\n\n    def test_embedding_with_unicode(self):\n        withunicode_cffi = self.prepare_module('withunicode')\n        self.compile('add1-test', [withunicode_cffi])\n        output = self.execute('add1-test')\n        assert output == \"255\\n4660\\n65244\\ngot: 0 0\\n\"\n", "testing/embedding/initerror.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\"\"\n    int add1(int, int);\n\"\"\")\n\nffi.embedding_init_code(r\"\"\"\n    raise KeyError\n\"\"\")\n\nffi.set_source(\"_initerror_cffi\", \"\"\"\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n\n", "testing/embedding/withunicode.py": "import sys, cffi\nif sys.version_info < (3,):\n    u_prefix = \"u\"\nelse:\n    u_prefix = \"\"\n    unichr = chr\n\n\nffi = cffi.FFI()\n\nffi.embedding_api(u\"\"\"\n    int add1(int, int);\n\"\"\")\n\nffi.embedding_init_code((\"\"\"\n    import sys, time\n    for c in %s'\"\"\" + unichr(0x00ff) + unichr(0x1234) + unichr(0xfedc) + \"\"\"':\n        sys.stdout.write(str(ord(c)) + '\\\\n')\n    sys.stdout.flush()\n\"\"\") % u_prefix)\n\nffi.set_source(\"_withunicode_cffi\", \"\"\"\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/add3.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\"\"\n    int add3(int, int, int, int);\n\"\"\")\n\nffi.embedding_init_code(r\"\"\"\n    from _add3_cffi import ffi\n    import sys\n\n    @ffi.def_extern()\n    def add3(x, y, z, t):\n        sys.stdout.write(\"adding %d, %d, %d, %d\\n\" % (x, y, z, t))\n        sys.stdout.flush()\n        return x + y + z + t\n\"\"\")\n\nffi.set_source(\"_add3_cffi\", \"\"\"\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/test_performance.py": "import sys\nfrom testing.embedding.test_basic import EmbeddingTests\n\nif sys.platform == 'win32':\n    import pytest\n    pytestmark = pytest.mark.skip(\"written with POSIX functions\")\n\n\nclass TestPerformance(EmbeddingTests):\n    def test_perf_single_threaded(self):\n        perf_cffi = self.prepare_module('perf')\n        self.compile('perf-test', [perf_cffi], opt=True)\n        output = self.execute('perf-test')\n        print('='*79)\n        print(output.rstrip())\n        print('='*79)\n\n    def test_perf_in_1_thread(self):\n        perf_cffi = self.prepare_module('perf')\n        self.compile('perf-test', [perf_cffi], opt=True, threads=True,\n                     defines={'PTEST_USE_THREAD': '1'})\n        output = self.execute('perf-test')\n        print('='*79)\n        print(output.rstrip())\n        print('='*79)\n\n    def test_perf_in_2_threads(self):\n        perf_cffi = self.prepare_module('perf')\n        self.compile('perf-test', [perf_cffi], opt=True, threads=True,\n                     defines={'PTEST_USE_THREAD': '2'})\n        output = self.execute('perf-test')\n        print('='*79)\n        print(output.rstrip())\n        print('='*79)\n\n    def test_perf_in_4_threads(self):\n        perf_cffi = self.prepare_module('perf')\n        self.compile('perf-test', [perf_cffi], opt=True, threads=True,\n                     defines={'PTEST_USE_THREAD': '4'})\n        output = self.execute('perf-test')\n        print('='*79)\n        print(output.rstrip())\n        print('='*79)\n\n    def test_perf_in_8_threads(self):\n        perf_cffi = self.prepare_module('perf')\n        self.compile('perf-test', [perf_cffi], opt=True, threads=True,\n                     defines={'PTEST_USE_THREAD': '8'})\n        output = self.execute('perf-test')\n        print('='*79)\n        print(output.rstrip())\n        print('='*79)\n", "testing/embedding/add1.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\"\"\n    int add1(int, int);\n\"\"\")\n\nffi.embedding_init_code(r\"\"\"\n    import sys, time\n    sys.stdout.write(\"preparing\")\n    for i in range(3):\n        sys.stdout.flush()\n        # Windows: sometimes time.sleep() doesn't sleep at all.\n        # This appears to occur on recent versions of python only.\n        t_end = time.time() + 0.19\n        while time.time() < t_end:\n            time.sleep(0.2)\n        sys.stdout.write(\".\")\n    sys.stdout.write(\"\\n\")\n\n    from _add1_cffi import ffi\n\n    int(ord(\"A\"))    # check that built-ins are there\n\n    @ffi.def_extern()\n    def add1(x, y):\n        sys.stdout.write(\"adding %d and %d\\n\" % (x, y))\n        sys.stdout.flush()\n        return x + y\n\"\"\")\n\nffi.set_source(\"_add1_cffi\", \"\"\"\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/test_recursive.py": "from testing.embedding.test_basic import EmbeddingTests\n\n\nclass TestRecursive(EmbeddingTests):\n    def test_recursive(self):\n        add_recursive_cffi = self.prepare_module('add_recursive')\n        self.compile('add_recursive-test', [add_recursive_cffi])\n        output = self.execute('add_recursive-test')\n        assert output == (\"preparing REC\\n\"\n                          \"some_callback(400)\\n\"\n                          \"adding 400 and 9\\n\"\n                          \"<<< 409 >>>\\n\"\n                          \"adding 40 and 2\\n\"\n                          \"adding 100 and -5\\n\"\n                          \"got: 42 95\\n\")\n", "testing/embedding/add_recursive.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\"\"\n    extern int (*my_callback)(int);\n    int add_rec(int, int);\n\"\"\")\n\nffi.embedding_init_code(r\"\"\"\n    from _add_recursive_cffi import ffi, lib\n    import sys\n    print(\"preparing REC\")\n    sys.stdout.flush()\n\n    @ffi.def_extern()\n    def add_rec(x, y):\n        print(\"adding %d and %d\" % (x, y))\n        sys.stdout.flush()\n        return x + y\n\n    x = lib.my_callback(400)\n    print('<<< %d >>>' % (x,))\n\"\"\")\n\nffi.set_source(\"_add_recursive_cffi\", \"\"\"\n/* use CFFI_DLLEXPORT: on windows, it expands to __declspec(dllexport),\n   which is needed to export a variable from a dll */\nCFFI_DLLEXPORT int (*my_callback)(int);\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/tlocal.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\"\"\n    int add1(int, int);\n\"\"\")\n\nffi.embedding_init_code(r\"\"\"\n    from _tlocal_cffi import ffi\n    import itertools\n    try:\n        import thread\n        g_seen = itertools.count().next\n    except ImportError:\n        import _thread as thread      # py3\n        g_seen = itertools.count().__next__\n    tloc = thread._local()\n\n    @ffi.def_extern()\n    def add1(x, y):\n        try:\n            num = tloc.num\n        except AttributeError:\n            num = tloc.num = g_seen() * 1000\n        return x + y + num\n\"\"\")\n\nffi.set_source(\"_tlocal_cffi\", \"\"\"\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/empty.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\")\n\nffi.set_source(\"_empty_cffi\", \"\"\"\nvoid initialize_my_empty_cffi(void) {\n    if (cffi_start_python() != 0) {\n        printf(\"oops, cffi_start_python() returned non-0\\\\n\");\n        abort();\n    }\n}\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/test_tlocal.py": "from testing.embedding.test_basic import EmbeddingTests\n\n\nclass TestThreadLocal(EmbeddingTests):\n    def test_thread_local(self):\n        tlocal_cffi = self.prepare_module('tlocal')\n        self.compile('tlocal-test', [tlocal_cffi], threads=True)\n        for i in range(10):\n            output = self.execute('tlocal-test')\n            assert output == \"done\\n\"\n", "testing/embedding/__init__.py": "", "testing/embedding/perf.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.embedding_api(\"\"\"\n    int add1(int, int);\n\"\"\")\n\nffi.embedding_init_code(r\"\"\"\n    from _perf_cffi import ffi\n\n    @ffi.def_extern()\n    def add1(x, y):\n        return x + y\n\"\"\")\n\nffi.set_source(\"_perf_cffi\", \"\"\"\n\"\"\")\n\nfn = ffi.compile(verbose=True)\nprint('FILENAME: %s' % (fn,))\n", "testing/embedding/test_thread.py": "from testing.embedding.test_basic import EmbeddingTests\n\n\nclass TestThread(EmbeddingTests):\n    def test_first_calls_in_parallel(self):\n        add1_cffi = self.prepare_module('add1')\n        self.compile('thread1-test', [add1_cffi], threads=True)\n        for i in range(20):\n            output = self.execute('thread1-test')\n            assert output == (\"starting\\n\"\n                              \"preparing...\\n\" +\n                              \"adding 40 and 2\\n\" * 10 +\n                              \"done\\n\")\n\n    def _take_out(self, text, content):\n        assert content in text\n        i = text.index(content)\n        return text[:i] + text[i+len(content):]\n\n    def test_init_different_modules_in_different_threads(self):\n        add1_cffi = self.prepare_module('add1')\n        add2_cffi = self.prepare_module('add2')\n        self.compile('thread2-test', [add1_cffi, add2_cffi], threads=True)\n        for i in range(3):\n            output = self.execute('thread2-test')\n            print('='*79)\n            print(output)\n            print('='*79)\n            output = self._take_out(output, \"preparing\")\n            output = self._take_out(output, \".\")\n            output = self._take_out(output, \".\")\n            # at least the 3rd dot should be after everything from ADD2\n            assert output == (\"starting\\n\"\n                              \"prepADD2\\n\"\n                              \"adding 1000 and 200 and 30\\n\"\n                              \".\\n\"\n                              \"adding 40 and 2\\n\"\n                              \"done\\n\")\n\n    def test_alt_issue(self):\n        add1_cffi = self.prepare_module('add1')\n        add2_cffi = self.prepare_module('add2')\n        self.compile('thread2-test', [add1_cffi, add2_cffi],\n                     threads=True, defines={'T2TEST_AGAIN_ADD1': '1'})\n        output = self.execute('thread2-test')\n        output = self._take_out(output, \"adding 40 and 2\\n\")\n        assert output == (\"starting\\n\"\n                          \"preparing...\\n\"\n                          \"adding -1 and -1\\n\"\n                          \"prepADD2\\n\"\n                          \"adding 1000 and 200 and 30\\n\"\n                          \"done\\n\")\n\n    def test_load_in_parallel_more(self):\n        add2_cffi = self.prepare_module('add2')\n        add3_cffi = self.prepare_module('add3')\n        self.compile('thread3-test', [add2_cffi, add3_cffi], threads=True)\n        for i in range(150):\n            output = self.execute('thread3-test')\n            for j in range(10):\n                output = self._take_out(output, \"adding 40 and 2 and 100\\n\")\n                output = self._take_out(output, \"adding 1000, 200, 30, 4\\n\")\n            assert output == (\"starting\\n\"\n                              \"prepADD2\\n\"\n                              \"done\\n\")\n", "testing/cffi0/test_ffi_backend.py": "import sys, platform\nimport pytest\nfrom testing.cffi0 import backend_tests, test_function, test_ownlib\nfrom testing.support import u\nfrom cffi import FFI\nimport _cffi_backend\n\n\nclass TestFFI(backend_tests.BackendTests,\n              test_function.TestFunction,\n              test_ownlib.TestOwnLib):\n    TypeRepr = \"<ctype '%s'>\"\n\n    @staticmethod\n    def Backend():\n        return _cffi_backend\n\n    def test_not_supported_bitfield_in_result(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a,b,c,d,e; int x:1; };\")\n        e = pytest.raises(NotImplementedError, ffi.callback,\n                           \"struct foo_s foo(void)\", lambda: 42)\n        assert str(e.value) == (\"struct foo_s(*)(): \"\n            \"callback with unsupported argument or return type or with '...'\")\n\n    def test_inspecttype(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.typeof(\"long\").kind == \"primitive\"\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").cname == (\n            \"long(*)(long, long * *, ...)\")\n        assert ffi.typeof(\"long(*)(long, long**, ...)\").ellipsis is True\n\n    def test_new_handle(self):\n        ffi = FFI(backend=self.Backend())\n        o = [2, 3, 4]\n        p = ffi.new_handle(o)\n        assert ffi.typeof(p) == ffi.typeof(\"void *\")\n        assert ffi.from_handle(p) is o\n        assert ffi.from_handle(ffi.cast(\"char *\", p)) is o\n        pytest.raises(RuntimeError, ffi.from_handle, ffi.NULL)\n\n    def test_callback_onerror(self):\n        ffi = FFI(backend=self.Backend())\n        seen = []\n        def oops(*args):\n            seen.append(args)\n        def otherfunc():\n            raise LookupError\n        def cb(n):\n            otherfunc()\n        a = ffi.callback(\"int(*)(int)\", cb, error=42, onerror=oops)\n        res = a(234)\n        assert res == 42\n        assert len(seen) == 1\n        exc, val, tb = seen[0]\n        assert exc is LookupError\n        assert isinstance(val, LookupError)\n        assert tb.tb_frame.f_code.co_name == 'cb'\n        assert tb.tb_frame.f_locals['n'] == 234\n\n    def test_ffi_new_allocator_2(self):\n        ffi = FFI(backend=self.Backend())\n        seen = []\n        def myalloc(size):\n            seen.append(size)\n            return ffi.new(\"char[]\", b\"X\" * size)\n        def myfree(raw):\n            seen.append(raw)\n        alloc1 = ffi.new_allocator(myalloc, myfree)\n        alloc2 = ffi.new_allocator(alloc=myalloc, free=myfree,\n                                   should_clear_after_alloc=False)\n        p1 = alloc1(\"int[10]\")\n        p2 = alloc2(\"int[]\", 10)\n        assert seen == [40, 40]\n        assert ffi.typeof(p1) == ffi.typeof(\"int[10]\")\n        assert ffi.sizeof(p1) == 40\n        assert ffi.typeof(p2) == ffi.typeof(\"int[]\")\n        assert ffi.sizeof(p2) == 40\n        assert p1[5] == 0\n        assert p2[6] == ord('X') * 0x01010101\n        raw1 = ffi.cast(\"char *\", p1)\n        raw2 = ffi.cast(\"char *\", p2)\n        del p1, p2\n        retries = 0\n        while len(seen) != 4:\n            retries += 1\n            assert retries <= 5\n            import gc; gc.collect()\n        assert seen == [40, 40, raw1, raw2]\n        assert repr(seen[2]) == \"<cdata 'char[]' owning 41 bytes>\"\n        assert repr(seen[3]) == \"<cdata 'char[]' owning 41 bytes>\"\n\n    def test_ffi_new_allocator_3(self):\n        ffi = FFI(backend=self.Backend())\n        seen = []\n        def myalloc(size):\n            seen.append(size)\n            return ffi.new(\"char[]\", b\"X\" * size)\n        alloc1 = ffi.new_allocator(myalloc)    # no 'free'\n        p1 = alloc1(\"int[10]\")\n        assert seen == [40]\n        assert ffi.typeof(p1) == ffi.typeof(\"int[10]\")\n        assert ffi.sizeof(p1) == 40\n        assert p1[5] == 0\n\n    def test_ffi_new_allocator_4(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(TypeError, ffi.new_allocator, free=lambda x: None)\n        #\n        def myalloc2(size):\n            raise LookupError\n        alloc2 = ffi.new_allocator(myalloc2)\n        pytest.raises(LookupError, alloc2, \"int[5]\")\n        #\n        def myalloc3(size):\n            return 42\n        alloc3 = ffi.new_allocator(myalloc3)\n        e = pytest.raises(TypeError, alloc3, \"int[5]\")\n        assert str(e.value) == \"alloc() must return a cdata object (got int)\"\n        #\n        def myalloc4(size):\n            return ffi.cast(\"int\", 42)\n        alloc4 = ffi.new_allocator(myalloc4)\n        e = pytest.raises(TypeError, alloc4, \"int[5]\")\n        assert str(e.value) == \"alloc() must return a cdata pointer, not 'int'\"\n        #\n        def myalloc5(size):\n            return ffi.NULL\n        alloc5 = ffi.new_allocator(myalloc5)\n        pytest.raises(MemoryError, alloc5, \"int[5]\")\n\n    def test_new_struct_containing_struct_containing_array_varsize(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s { int len[100]; short data[]; };\n            struct bar_s { int abc[100]; struct foo_s tail; };\n        \"\"\")\n        # loop to try to detect heap overwrites, if the size allocated\n        # is too small\n        for i in range(1, 501, 100):\n            p = ffi.new(\"struct bar_s *\", [[10], [[20], [3,4,5,6,7,8,9] * i]])\n            assert p.abc[0] == 10\n            assert p.tail.len[0] == 20\n            assert p.tail.data[0] == 3\n            assert p.tail.data[6] == 9\n            assert p.tail.data[7 * i - 1] == 9\n\n    def test_bogus_struct_containing_struct_containing_array_varsize(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s { signed char len; signed char data[]; };\n            struct bar_s { struct foo_s foo; int bcd; };\n        \"\"\")\n        p = ffi.new(\"struct bar_s *\", [[123, [45, 56, 67, 78]], 9999999])\n        assert p.foo.len == 123\n        assert p.foo.data[0] == 45\n        assert p.foo.data[1] == 56\n        assert p.foo.data[2] == 67\n        assert p.bcd == 9999999\n        assert p.foo.data[3] != 78   # has been overwritten with 9999999\n\n    def test_issue553(self):\n        import gc, warnings\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        with warnings.catch_warnings(record=True) as w:\n            ffi.gc(p, lambda x: None)\n            gc.collect()\n        assert w == []\n\n    def test_issue553_from_buffer(self):\n        import gc, warnings\n        ffi = FFI(backend=self.Backend())\n        buf = b\"123\"\n        with warnings.catch_warnings(record=True) as w:\n            ffi.from_buffer(buf)\n            gc.collect()\n        assert w == []\n\n\nclass TestBitfield:\n    def check(self, source, expected_ofs_y, expected_align, expected_size):\n        # NOTE: 'expected_*' is the numbers expected from GCC.\n        # The numbers expected from MSVC are not explicitly written\n        # in this file, and will just be taken from the compiler.\n        ffi = FFI()\n        ffi.cdef(\"struct s1 { %s };\" % source)\n        ctype = ffi.typeof(\"struct s1\")\n        # verify the information with gcc\n        ffi1 = FFI()\n        ffi1.cdef(\"\"\"\n            static const int Gofs_y, Galign, Gsize;\n            struct s1 *try_with_value(int fieldnum, long long value);\n        \"\"\")\n        fnames = [name for name, cfield in ctype.fields\n                       if name and cfield.bitsize > 0]\n        setters = ['case %d: s.%s = value; break;' % iname\n                   for iname in enumerate(fnames)]\n        lib = ffi1.verify(\"\"\"\n            #include <string.h>\n            struct s1 { %s };\n            struct sa { char a; struct s1 b; };\n            #define Gofs_y  offsetof(struct s1, y)\n            #define Galign  offsetof(struct sa, b)\n            #define Gsize   sizeof(struct s1)\n            struct s1 *try_with_value(int fieldnum, long long value)\n            {\n                static struct s1 s;\n                memset(&s, 0, sizeof(s));\n                switch (fieldnum) { %s }\n                return &s;\n            }\n        \"\"\" % (source, ' '.join(setters)))\n        if sys.platform == 'win32':\n            expected_ofs_y = lib.Gofs_y\n            expected_align = lib.Galign\n            expected_size  = lib.Gsize\n        else:\n            assert (lib.Gofs_y, lib.Galign, lib.Gsize) == (\n                expected_ofs_y, expected_align, expected_size)\n        # the real test follows\n        assert ffi.offsetof(\"struct s1\", \"y\") == expected_ofs_y\n        assert ffi.alignof(\"struct s1\") == expected_align\n        assert ffi.sizeof(\"struct s1\") == expected_size\n        # compare the actual storage of the two\n        for name, cfield in ctype.fields:\n            if cfield.bitsize < 0 or not name:\n                continue\n            if int(ffi.cast(cfield.type, -1)) == -1:   # signed\n                min_value = -(1 << (cfield.bitsize-1))\n                max_value = (1 << (cfield.bitsize-1)) - 1\n            else:\n                min_value = 0\n                max_value = (1 << cfield.bitsize) - 1\n            for t in [1, 2, 4, 8, 16, 128, 2813, 89728, 981729,\n                     -1,-2,-4,-8,-16,-128,-2813,-89728,-981729]:\n                if min_value <= t <= max_value:\n                    self._fieldcheck(ffi, lib, fnames, name, t)\n\n    def _fieldcheck(self, ffi, lib, fnames, name, value):\n        s = ffi.new(\"struct s1 *\")\n        setattr(s, name, value)\n        assert getattr(s, name) == value\n        raw1 = ffi.buffer(s)[:]\n        buff1 = ffi.buffer(s)\n        t = lib.try_with_value(fnames.index(name), value)\n        raw2 = ffi.buffer(t, len(raw1))[:]\n        assert raw1 == raw2\n        buff2 = ffi.buffer(t, len(buff1))\n        assert buff1 == buff2\n\n    def test_bitfield_basic(self):\n        self.check(\"int a; int b:9; int c:20; int y;\", 8, 4, 12)\n        self.check(\"int a; short b:9; short c:7; int y;\", 8, 4, 12)\n        self.check(\"int a; short b:9; short c:9; int y;\", 8, 4, 12)\n\n    def test_bitfield_reuse_if_enough_space(self):\n        self.check(\"int a:2; char y;\", 1, 4, 4)\n        self.check(\"int a:1; char b  ; int c:1; char y;\", 3, 4, 4)\n        self.check(\"int a:1; char b:8; int c:1; char y;\", 3, 4, 4)\n        self.check(\"char a; int b:9; char y;\", 3, 4, 4)\n        self.check(\"char a; short b:9; char y;\", 4, 2, 6)\n        self.check(\"int a:2; char b:6; char y;\", 1, 4, 4)\n        self.check(\"int a:2; char b:7; char y;\", 2, 4, 4)\n        self.check(\"int a:2; short b:15; char c:2; char y;\", 5, 4, 8)\n        self.check(\"int a:2; char b:1; char c:1; char y;\", 1, 4, 4)\n\n    @pytest.mark.skipif(\n        \"not (sys.platform == 'darwin' and platform.machine() == 'arm64')\"\n        \" and \"\n        \"platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_anonymous_no_align(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :1;\", 0, 1, 2)\n        self.check(\"char x; int z:1; char y;\", 2, 4, 4)\n        self.check(\"char x; int  :1; char y;\", 2, 1, 3)\n        self.check(\"char x; long long z:48; char y;\", 7, L, 8)\n        self.check(\"char x; long long  :48; char y;\", 7, 1, 8)\n        self.check(\"char x; long long z:56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long  :56; char y;\", 8, 1, 9)\n        self.check(\"char x; long long z:57; char y;\", L + 8, L, L + 8 + L)\n        self.check(\"char x; long long  :57; char y;\", L + 8, 1, L + 9)\n\n    @pytest.mark.skipif(\n        \"(sys.platform == 'darwin' and platform.machine() == 'arm64')\"\n        \" or \"\n        \"not platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_anonymous_align_arm(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :1;\", 0, 4, 4)\n        self.check(\"char x; int z:1; char y;\", 2, 4, 4)\n        self.check(\"char x; int  :1; char y;\", 2, 4, 4)\n        self.check(\"char x; long long z:48; char y;\", 7, L, 8)\n        self.check(\"char x; long long  :48; char y;\", 7, 8, 8)\n        self.check(\"char x; long long z:56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long  :56; char y;\", 8, L, 8 + L)\n        self.check(\"char x; long long z:57; char y;\", L + 8, L, L + 8 + L)\n        self.check(\"char x; long long  :57; char y;\", L + 8, L, L + 8 + L)\n\n    @pytest.mark.skipif(\n        \"not (sys.platform == 'darwin' and platform.machine() == 'arm64')\"\n        \" and \"\n        \"platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_zero(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :0;\", 0, 1, 4)\n        self.check(\"char x; int :0; char y;\", 4, 1, 5)\n        self.check(\"char x; int :0; int :0; char y;\", 4, 1, 5)\n        self.check(\"char x; long long :0; char y;\", L, 1, L + 1)\n        self.check(\"short x, y; int :0; int :0;\", 2, 2, 4)\n        self.check(\"char x; int :0; short b:1; char y;\", 5, 2, 6)\n        self.check(\"int a:1; int :0; int b:1; char y;\", 5, 4, 8)\n\n    @pytest.mark.skipif(\n        \"(sys.platform == 'darwin' and platform.machine() == 'arm64')\"\n        \" or \"\n        \"not platform.machine().startswith(('arm', 'aarch64'))\")\n    def test_bitfield_zero_arm(self):\n        L = FFI().alignof(\"long long\")\n        self.check(\"char y; int :0;\", 0, 4, 4)\n        self.check(\"char x; int :0; char y;\", 4, 4, 8)\n        self.check(\"char x; int :0; int :0; char y;\", 4, 4, 8)\n        self.check(\"char x; long long :0; char y;\", L, 8, L + 8)\n        self.check(\"short x, y; int :0; int :0;\", 2, 4, 4)\n        self.check(\"char x; int :0; short b:1; char y;\", 5, 4, 8)\n        self.check(\"int a:1; int :0; int b:1; char y;\", 5, 4, 8)\n\n    def test_error_cases(self):\n        ffi = FFI()\n        ffi.cdef(\"struct s1 { float x:1; };\")\n        with pytest.raises(TypeError):\n            ffi.new(\"struct s1 *\")\n        ffi.cdef(\"struct s2 { char x:0; };\")\n        with pytest.raises(TypeError):\n            ffi.new(\"struct s2 *\")\n        ffi.cdef(\"struct s3 { char x:9; };\")\n        with pytest.raises(TypeError):\n            ffi.new(\"struct s3 *\")\n\n    def test_struct_with_typedef(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { float x; } foo_t;\")\n        p = ffi.new(\"foo_t *\", [5.2])\n        assert repr(p).startswith(\"<cdata 'foo_t *' \")\n\n    def test_struct_array_no_length(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n        p = ffi.new(\"struct foo_s *\", [100, [200, 300, 400]])\n        assert p.x == 100\n        assert ffi.typeof(p.a) is ffi.typeof(\"int[]\")\n        assert len(p.a) == 3                            # length recorded\n        assert p.a[0] == 200\n        assert p.a[1] == 300\n        assert p.a[2] == 400\n        assert list(p.a) == [200, 300, 400]\n        q = ffi.cast(\"struct foo_s *\", p)\n        assert q.x == 100\n        assert ffi.typeof(q.a) is ffi.typeof(\"int *\")   # no length recorded\n        pytest.raises(TypeError, len, q.a)\n        assert q.a[0] == 200\n        assert q.a[1] == 300\n        assert q.a[2] == 400\n        pytest.raises(TypeError, list, q.a)\n\n    @pytest.mark.skipif(\"sys.platform != 'win32'\")\n    def test_getwinerror(self):\n        ffi = FFI()\n        code, message = ffi.getwinerror(1155)\n        assert code == 1155\n        assert message == (\"No application is associated with the \"\n                           \"specified file for this operation\")\n        ffi.cdef(\"void SetLastError(int);\")\n        lib = ffi.dlopen(\"Kernel32.dll\")\n        lib.SetLastError(2)\n        code, message = ffi.getwinerror()\n        assert code == 2\n        assert message == \"The system cannot find the file specified\"\n        code, message = ffi.getwinerror(-1)\n        assert code == 2\n        assert message == \"The system cannot find the file specified\"\n\n    def test_from_buffer(self):\n        import array\n        ffi = FFI()\n        a = array.array('H', [10000, 20000, 30000])\n        c = ffi.from_buffer(a)\n        assert ffi.typeof(c) is ffi.typeof(\"char[]\")\n        assert len(c) == 6\n        ffi.cast(\"unsigned short *\", c)[1] += 500\n        assert list(a) == [10000, 20500, 30000]\n        assert c == ffi.from_buffer(\"char[]\", a, True)\n        assert c == ffi.from_buffer(a, require_writable=True)\n        #\n        c = ffi.from_buffer(\"unsigned short[]\", a)\n        assert len(c) == 3\n        assert c[1] == 20500\n        #\n        p = ffi.from_buffer(b\"abcd\")\n        assert p[2] == b\"c\"\n        #\n        assert p == ffi.from_buffer(b\"abcd\", require_writable=False)\n        pytest.raises((TypeError, BufferError), ffi.from_buffer,\n                                                 \"char[]\", b\"abcd\", True)\n        pytest.raises((TypeError, BufferError), ffi.from_buffer, b\"abcd\",\n                                                 require_writable=True)\n\n    def test_release(self):\n        ffi = FFI()\n        p = ffi.new(\"int[]\", 123)\n        ffi.release(p)\n        # here, reading p[0] might give garbage or segfault...\n        ffi.release(p)   # no effect\n\n    def test_memmove(self):\n        ffi = FFI()\n        p = ffi.new(\"short[]\", [-1234, -2345, -3456, -4567, -5678])\n        ffi.memmove(p, p + 1, 4)\n        assert list(p) == [-2345, -3456, -3456, -4567, -5678]\n        p[2] = 999\n        ffi.memmove(p + 2, p, 6)\n        assert list(p) == [-2345, -3456, -2345, -3456, 999]\n        ffi.memmove(p + 4, ffi.new(\"char[]\", b\"\\x71\\x72\"), 2)\n        if sys.byteorder == 'little':\n            assert list(p) == [-2345, -3456, -2345, -3456, 0x7271]\n        else:\n            assert list(p) == [-2345, -3456, -2345, -3456, 0x7172]\n\n    def test_memmove_buffer(self):\n        import array\n        ffi = FFI()\n        a = array.array('H', [10000, 20000, 30000])\n        p = ffi.new(\"short[]\", 5)\n        ffi.memmove(p, a, 6)\n        assert list(p) == [10000, 20000, 30000, 0, 0]\n        ffi.memmove(p + 1, a, 6)\n        assert list(p) == [10000, 10000, 20000, 30000, 0]\n        b = array.array('h', [-1000, -2000, -3000])\n        ffi.memmove(b, a, 4)\n        assert b.tolist() == [10000, 20000, -3000]\n        assert a.tolist() == [10000, 20000, 30000]\n        p[0] = 999\n        p[1] = 998\n        p[2] = 997\n        p[3] = 996\n        p[4] = 995\n        ffi.memmove(b, p, 2)\n        assert b.tolist() == [999, 20000, -3000]\n        ffi.memmove(b, p + 2, 4)\n        assert b.tolist() == [997, 996, -3000]\n        p[2] = -p[2]\n        p[3] = -p[3]\n        ffi.memmove(b, p + 2, 6)\n        assert b.tolist() == [-997, -996, 995]\n\n    def test_memmove_readonly_readwrite(self):\n        ffi = FFI()\n        p = ffi.new(\"signed char[]\", 5)\n        ffi.memmove(p, b\"abcde\", 3)\n        assert list(p) == [ord(\"a\"), ord(\"b\"), ord(\"c\"), 0, 0]\n        ffi.memmove(p, bytearray(b\"ABCDE\"), 2)\n        assert list(p) == [ord(\"A\"), ord(\"B\"), ord(\"c\"), 0, 0]\n        pytest.raises((TypeError, BufferError), ffi.memmove, b\"abcde\", p, 3)\n        ba = bytearray(b\"xxxxx\")\n        ffi.memmove(dest=ba, src=p, n=3)\n        assert ba == bytearray(b\"ABcxx\")\n\n    def test_all_primitives(self):\n        ffi = FFI()\n        for name in [\n            \"char\",\n            \"short\",\n            \"int\",\n            \"long\",\n            \"long long\",\n            \"signed char\",\n            \"unsigned char\",\n            \"unsigned short\",\n            \"unsigned int\",\n            \"unsigned long\",\n            \"unsigned long long\",\n            \"float\",\n            \"double\",\n            \"long double\",\n            \"wchar_t\",\n            \"char16_t\",\n            \"char32_t\",\n            \"_Bool\",\n            \"int8_t\",\n            \"uint8_t\",\n            \"int16_t\",\n            \"uint16_t\",\n            \"int32_t\",\n            \"uint32_t\",\n            \"int64_t\",\n            \"uint64_t\",\n            \"int_least8_t\",\n            \"uint_least8_t\",\n            \"int_least16_t\",\n            \"uint_least16_t\",\n            \"int_least32_t\",\n            \"uint_least32_t\",\n            \"int_least64_t\",\n            \"uint_least64_t\",\n            \"int_fast8_t\",\n            \"uint_fast8_t\",\n            \"int_fast16_t\",\n            \"uint_fast16_t\",\n            \"int_fast32_t\",\n            \"uint_fast32_t\",\n            \"int_fast64_t\",\n            \"uint_fast64_t\",\n            \"intptr_t\",\n            \"uintptr_t\",\n            \"intmax_t\",\n            \"uintmax_t\",\n            \"ptrdiff_t\",\n            \"size_t\",\n            \"ssize_t\",\n            ]:\n            x = ffi.sizeof(name)\n            assert 1 <= x <= 16\n\n    def test_ffi_def_extern(self):\n        ffi = FFI()\n        pytest.raises(ValueError, ffi.def_extern)\n\n    def test_introspect_typedef(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef int foo_t;\")\n        assert ffi.list_types() == (['foo_t'], [], [])\n        assert ffi.typeof('foo_t').kind == 'primitive'\n        assert ffi.typeof('foo_t').cname == 'int'\n        #\n        ffi.cdef(\"typedef signed char a_t, c_t, g_t, b_t;\")\n        assert ffi.list_types() == (['a_t', 'b_t', 'c_t', 'foo_t', 'g_t'],\n                                    [], [])\n\n    def test_introspect_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo_s { int a; };\")\n        assert ffi.list_types() == ([], ['foo_s'], [])\n        assert ffi.typeof('struct foo_s').kind == 'struct'\n        assert ffi.typeof('struct foo_s').cname == 'struct foo_s'\n\n    def test_introspect_union(self):\n        ffi = FFI()\n        ffi.cdef(\"union foo_s { int a; };\")\n        assert ffi.list_types() == ([], [], ['foo_s'])\n        assert ffi.typeof('union foo_s').kind == 'union'\n        assert ffi.typeof('union foo_s').cname == 'union foo_s'\n\n    def test_introspect_struct_and_typedef(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { int a; } foo_t;\")\n        assert ffi.list_types() == (['foo_t'], [], [])\n        assert ffi.typeof('foo_t').kind == 'struct'\n        assert ffi.typeof('foo_t').cname == 'foo_t'\n\n    def test_introspect_included_type(self):\n        ffi1 = FFI()\n        ffi2 = FFI()\n        ffi1.cdef(\"typedef signed char schar_t; struct sint_t { int x; };\")\n        ffi2.include(ffi1)\n        assert ffi1.list_types() == ffi2.list_types() == (\n            ['schar_t'], ['sint_t'], [])\n\n    def test_introspect_order(self):\n        ffi = FFI()\n        ffi.cdef(\"union CFFIaaa { int a; }; typedef struct CFFIccc { int a; } CFFIb;\")\n        ffi.cdef(\"union CFFIg   { int a; }; typedef struct CFFIcc  { int a; } CFFIbbb;\")\n        ffi.cdef(\"union CFFIaa  { int a; }; typedef struct CFFIa   { int a; } CFFIbb;\")\n        assert ffi.list_types() == (['CFFIb', 'CFFIbb', 'CFFIbbb'],\n                                    ['CFFIa', 'CFFIcc', 'CFFIccc'],\n                                    ['CFFIaa', 'CFFIaaa', 'CFFIg'])\n\n    def test_unpack(self):\n        ffi = FFI()\n        p = ffi.new(\"char[]\", b\"abc\\x00def\")\n        assert ffi.unpack(p+1, 7) == b\"bc\\x00def\\x00\"\n        p = ffi.new(\"int[]\", [-123456789])\n        assert ffi.unpack(p, 1) == [-123456789]\n\n    def test_negative_array_size(self):\n        ffi = FFI()\n        pytest.raises(ValueError, ffi.cast, \"int[-5]\", 0)\n\n    def test_cannot_instantiate_manually(self):\n        ffi = FFI()\n        ct = type(ffi.typeof(\"void *\"))\n        pytest.raises(TypeError, ct)\n        pytest.raises(TypeError, ct, ffi.NULL)\n        for cd in [type(ffi.cast(\"void *\", 0)),\n                   type(ffi.new(\"char[]\", 3)),\n                   type(ffi.gc(ffi.NULL, lambda x: None))]:\n            pytest.raises(TypeError, cd)\n            pytest.raises(TypeError, cd, ffi.NULL)\n            pytest.raises(TypeError, cd, ffi.typeof(\"void *\"))\n\n    def test_explicitly_defined_char16_t(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef uint16_t char16_t;\")\n        x = ffi.cast(\"char16_t\", 1234)\n        assert ffi.typeof(x) is ffi.typeof(\"uint16_t\")\n\n    def test_char16_t(self):\n        ffi = FFI()\n        x = ffi.new(\"char16_t[]\", 5)\n        assert len(x) == 5 and ffi.sizeof(x) == 10\n        x[2] = u+'\\u1324'\n        assert x[2] == u+'\\u1324'\n        y = ffi.new(\"char16_t[]\", u+'\\u1234\\u5678')\n        assert len(y) == 3\n        assert list(y) == [u+'\\u1234', u+'\\u5678', u+'\\x00']\n        assert ffi.string(y) == u+'\\u1234\\u5678'\n        z = ffi.new(\"char16_t[]\", u+'\\U00012345')\n        assert len(z) == 3\n        assert list(z) == [u+'\\ud808', u+'\\udf45', u+'\\x00']\n        assert ffi.string(z) == u+'\\U00012345'\n\n    def test_char32_t(self):\n        ffi = FFI()\n        x = ffi.new(\"char32_t[]\", 5)\n        assert len(x) == 5 and ffi.sizeof(x) == 20\n        x[3] = u+'\\U00013245'\n        assert x[3] == u+'\\U00013245'\n        y = ffi.new(\"char32_t[]\", u+'\\u1234\\u5678')\n        assert len(y) == 3\n        assert list(y) == [u+'\\u1234', u+'\\u5678', u+'\\x00']\n        py_uni = u+'\\U00012345'\n        z = ffi.new(\"char32_t[]\", py_uni)\n        assert len(z) == 2\n        assert list(z) == [py_uni, u+'\\x00']    # maybe a 2-unichars string\n        assert ffi.string(z) == py_uni\n        if len(py_uni) == 1:    # 4-bytes unicodes in Python\n            s = ffi.new(\"char32_t[]\", u+'\\ud808\\udf00')\n            assert len(s) == 3\n            assert list(s) == [u+'\\ud808', u+'\\udf00', u+'\\x00']\n", "testing/cffi0/test_vgen2.py": "import cffi.verifier\nfrom .test_vgen import *\n\n# This test file runs normally after test_vgen.  We only clean up the .c\n# sources, to check that it also works when we have only the .so.  The\n# tests should run much faster than test_vgen.\n\ndef setup_module():\n    cffi.verifier.cleanup_tmpdir(keep_so=True)\n    cffi.verifier._FORCE_GENERIC_ENGINE = True\n\ndef teardown_module():\n    cffi.verifier._FORCE_GENERIC_ENGINE = False\n", "testing/cffi0/test_cdata.py": "from cffi import FFI\n\nclass FakeBackend(object):\n\n    def nonstandard_integer_types(self):\n        return {}\n\n    def sizeof(self, name):\n        return 1\n\n    def load_library(self, path):\n        return \"fake library\"\n\n    def new_primitive_type(self, name):\n        return FakeType(\"primitive \" + name)\n\n    def new_void_type(self):\n        return FakeType(\"void\")\n    def new_pointer_type(self, x):\n        return FakeType('ptr-to-%r' % (x,))\n    def new_array_type(self, x, y):\n        return FakeType('array-from-%r-len-%r' % (x, y))\n    def cast(self, x, y):\n        return 'casted!'\n    def _get_types(self):\n        return \"CData\", \"CType\"\n\n    buffer = \"buffer type\"\n\n\nclass FakeType(object):\n    def __init__(self, cdecl):\n        self.cdecl = cdecl\n\n\ndef test_typeof():\n    ffi = FFI(backend=FakeBackend())\n    clong = ffi.typeof(\"signed long int\")\n    assert isinstance(clong, FakeType)\n    assert clong.cdecl == 'primitive long'\n", "testing/cffi0/test_version.py": "import os, sys\nimport pytest\nimport cffi, _cffi_backend\nfrom pathlib import Path\n\ndef setup_module(mod):\n    if '_cffi_backend' in sys.builtin_module_names:\n        pytest.skip(\"this is embedded version\")\n\n#BACKEND_VERSIONS = {\n#    '0.4.2': '0.4',     # did not change\n#    '0.7.1': '0.7',     # did not change\n#    '0.7.2': '0.7',     # did not change\n#    '0.8.1': '0.8',     # did not change (essentially)\n#    '0.8.4': '0.8.3',   # did not change\n#    }\n\ndef test_version():\n    v = cffi.__version__\n    version_info = '.'.join(str(i) for i in cffi.__version_info__)\n    version_info = version_info.replace('.beta.', 'b')\n    version_info = version_info.replace('.plus', '+')\n    version_info = version_info.replace('.rc', 'rc')\n    assert v == version_info\n    #v = BACKEND_VERSIONS.get(v, v)\n    assert v == _cffi_backend.__version__\n\ndef test_doc_version():\n    cffi_root = Path(os.path.dirname(__file__)).parent.parent\n    p = cffi_root / 'doc/source/conf.py'\n    content = open(p).read()\n    #\n    v = cffi.__version__\n    assert (\"version = '%s'\\n\" % v[:4]) in content\n    assert (\"release = '%s'\\n\" % v) in content\n\ndef test_setup_version():\n    cffi_root = Path(os.path.dirname(__file__)).parent.parent\n    p = cffi_root / 'setup.py'\n    content = open(p).read()\n    #\n    v = cffi.__version__.replace('+', '')\n    assert (\"version='%s'\" % v) in content\n\ndef test_c_version():\n    cffi_root = Path(os.path.dirname(__file__)).parent.parent\n    v = cffi.__version__\n    p = cffi_root / 'src/c/test_c.py'\n    content = open(p).read()\n    #v = BACKEND_VERSIONS.get(v, v)\n    assert (('assert __version__ == \"%s\"' % v) in content)\n\ndef test_embedding_h():\n    cffi_root = Path(os.path.dirname(__file__)).parent.parent\n    v = cffi.__version__\n    p = cffi_root / 'src/cffi/_embedding.h'\n    content = open(p).read()\n    assert ('cffi version: %s\"' % (v,)) in content\n", "testing/cffi0/test_verify2.py": "import pytest\nfrom .test_verify import *\n\n# eliminate warning noise from common test modules that are repeatedly re-imported\npytestmark = pytest.mark.filterwarnings(\"ignore:reimporting:UserWarning\")\n\n# This test file runs normally after test_verify.  We only clean up the .c\n# sources, to check that it also works when we have only the .so.  The\n# tests should run much faster than test_verify.\n\ndef setup_module():\n    import cffi.verifier\n    cffi.verifier.cleanup_tmpdir(keep_so=True)\n", "testing/cffi0/test_zdistutils.py": "import sys, os, math, shutil\nimport pytest\nfrom cffi import FFI, FFIError\nfrom cffi.verifier import Verifier, _locate_engine_class, _get_so_suffixes\nfrom cffi.ffiplatform import maybe_relative_path\nfrom testing.udir import udir\nfrom testing.support import load_dynamic\n\n\nclass DistUtilsTest(object):\n    def setup_class(self):\n        self.lib_m = \"m\"\n        if sys.platform == 'win32':\n            #there is a small chance this fails on Mingw via environ $CC\n            import distutils.ccompiler\n            if distutils.ccompiler.get_default_compiler() == 'msvc':\n                self.lib_m = 'msvcrt'\n\n    def teardown_class(self):\n        if udir.isdir():\n            udir.remove(ignore_errors=True)\n        udir.ensure(dir=1)\n\n    def test_locate_engine_class(self):\n        cls = _locate_engine_class(FFI(), self.generic)\n        if self.generic:\n            # asked for the generic engine, which must not generate a\n            # CPython extension module\n            assert not cls._gen_python_module\n        else:\n            # asked for the CPython engine: check that we got it, unless\n            # we are running on top of PyPy, where the generic engine is\n            # always better\n            if '__pypy__' not in sys.builtin_module_names:\n                assert cls._gen_python_module\n\n    def test_write_source(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there %s!*/\\n#include <math.h>\\n' % self\n        v = Verifier(ffi, csrc, force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        v.write_source()\n        with open(v.sourcefilename, 'r') as f:\n            data = f.read()\n        assert csrc in data\n\n    def test_write_source_explicit_filename(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there %s!*/\\n#include <math.h>\\n' % self\n        v = Verifier(ffi, csrc, force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        v.sourcefilename = filename = str(udir.join('write_source.c'))\n        v.write_source()\n        assert filename == v.sourcefilename\n        with open(filename, 'r') as f:\n            data = f.read()\n        assert csrc in data\n\n    def test_write_source_to_file_obj(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there %s!*/\\n#include <math.h>\\n' % self\n        v = Verifier(ffi, csrc, force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        try:\n            from StringIO import StringIO\n        except ImportError:\n            from io import StringIO\n        f = StringIO()\n        v.write_source(file=f)\n        assert csrc in f.getvalue()\n\n    def test_compile_module(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there %s!*/\\n#include <math.h>\\n' % self\n        v = Verifier(ffi, csrc, force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        v.compile_module()\n        assert v.get_module_name().startswith('_cffi_')\n        if v.generates_python_module():\n            mod = load_dynamic(v.get_module_name(), v.modulefilename)\n            assert hasattr(mod, '_cffi_setup')\n\n    def test_compile_module_explicit_filename(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there %s!2*/\\n#include <math.h>\\n' % self\n        v = Verifier(ffi, csrc, force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        basename = self.__class__.__name__[:10] + '_test_compile_module'\n        v.modulefilename = filename = str(udir.join(basename + '.so'))\n        v.compile_module()\n        assert filename == v.modulefilename\n        assert v.get_module_name() == basename\n        if v.generates_python_module():\n            mod = load_dynamic(v.get_module_name(), v.modulefilename)\n            assert hasattr(mod, '_cffi_setup')\n\n    def test_name_from_checksum_of_cdef(self):\n        names = []\n        for csrc in ['double', 'double', 'float']:\n            ffi = FFI()\n            ffi.cdef(\"%s sin(double x);\" % csrc)\n            v = Verifier(ffi, \"#include <math.h>\",\n                         force_generic_engine=self.generic,\n                         libraries=[self.lib_m])\n            names.append(v.get_module_name())\n        assert names[0] == names[1] != names[2]\n\n    def test_name_from_checksum_of_csrc(self):\n        names = []\n        for csrc in ['123', '123', '1234']:\n            ffi = FFI()\n            ffi.cdef(\"double sin(double x);\")\n            v = Verifier(ffi, csrc, force_generic_engine=self.generic)\n            names.append(v.get_module_name())\n        assert names[0] == names[1] != names[2]\n\n    def test_load_library(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there %s!3*/\\n#include <math.h>\\n' % self\n        v = Verifier(ffi, csrc, force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        library = v.load_library()\n        assert library.sin(12.3) == math.sin(12.3)\n\n    def test_verifier_args(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there %s!4*/#include \"test_verifier_args.h\"\\n' % self\n        udir.join('test_verifier_args.h').write('#include <math.h>\\n')\n        v = Verifier(ffi, csrc, include_dirs=[str(udir)],\n                     force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        library = v.load_library()\n        assert library.sin(12.3) == math.sin(12.3)\n\n    def test_verifier_object_from_ffi(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = \"/*6%s*/\\n#include <math.h>\" % self\n        lib = ffi.verify(csrc, force_generic_engine=self.generic,\n                         libraries=[self.lib_m])\n        assert lib.sin(12.3) == math.sin(12.3)\n        assert isinstance(ffi.verifier, Verifier)\n        with open(ffi.verifier.sourcefilename, 'r') as f:\n            data = f.read()\n        assert csrc in data\n\n    def test_extension_object(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*7%s*/' % self + '''\n    #include <math.h>\n    #ifndef TEST_EXTENSION_OBJECT\n    # error \"define_macros missing\"\n    #endif\n    '''\n        lib = ffi.verify(csrc, define_macros=[('TEST_EXTENSION_OBJECT', '1')],\n                         force_generic_engine=self.generic,\n                         libraries=[self.lib_m])\n        assert lib.sin(12.3) == math.sin(12.3)\n        v = ffi.verifier\n        ext = v.get_extension()\n        assert 'distutils.extension.Extension' in str(ext.__class__) or \\\n               'setuptools.extension.Extension' in str(ext.__class__)\n        assert ext.sources == [maybe_relative_path(v.sourcefilename)]\n        assert ext.name == v.get_module_name()\n        assert ext.define_macros == [('TEST_EXTENSION_OBJECT', '1')]\n\n    def test_extension_forces_write_source(self):\n        ffi = FFI()\n        ffi.cdef(\"double sin(double x);\")\n        csrc = '/*hi there9!%s*/\\n#include <math.h>\\n' % self\n        v = Verifier(ffi, csrc, force_generic_engine=self.generic,\n                     libraries=[self.lib_m])\n        assert not os.path.exists(v.sourcefilename)\n        v.get_extension()\n        assert os.path.exists(v.sourcefilename)\n\n    def test_extension_object_extra_sources(self):\n        ffi = FFI()\n        ffi.cdef(\"double test1eoes(double x);\")\n        extra_source = str(udir.join('extension_extra_sources.c'))\n        with open(extra_source, 'w') as f:\n            f.write('double test1eoes(double x) { return x * 6.0; }\\n')\n        csrc = '/*9%s*/' % self + '''\n        double test1eoes(double x);   /* or #include \"extra_sources.h\" */\n        '''\n        lib = ffi.verify(csrc, sources=[extra_source],\n                         force_generic_engine=self.generic)\n        assert lib.test1eoes(7.0) == 42.0\n        v = ffi.verifier\n        ext = v.get_extension()\n        assert 'distutils.extension.Extension' in str(ext.__class__) or \\\n               'setuptools.extension.Extension' in str(ext.__class__)\n        assert ext.sources == [maybe_relative_path(v.sourcefilename),\n                               extra_source]\n        assert ext.name == v.get_module_name()\n\n    def test_install_and_reload_module(self, targetpackage='', ext_package=''):\n        KEY = repr(self)\n        if not hasattr(os, 'fork'):\n            pytest.skip(\"test requires os.fork()\")\n\n        if targetpackage:\n            udir.ensure(targetpackage, dir=1).ensure('__init__.py')\n        sys.path.insert(0, str(udir))\n\n        def make_ffi(**verifier_args):\n            ffi = FFI()\n            ffi.cdef(\"/* %s, %s, %s */\" % (KEY, targetpackage, ext_package))\n            ffi.cdef(\"double test1iarm(double x);\")\n            csrc = \"double test1iarm(double x) { return x * 42.0; }\"\n            lib = ffi.verify(csrc, force_generic_engine=self.generic,\n                             ext_package=ext_package,\n                             **verifier_args)\n            return ffi, lib\n\n        childpid = os.fork()\n        if childpid == 0:\n            # in the child\n            ffi, lib = make_ffi()\n            assert lib.test1iarm(1.5) == 63.0\n            # \"install\" the module by moving it into udir (/targetpackage)\n            if targetpackage:\n                target = udir.join(targetpackage)\n            else:\n                target = udir\n            shutil.move(ffi.verifier.modulefilename, str(target))\n            os._exit(0)\n        # in the parent\n        _, status = os.waitpid(childpid, 0)\n        if not (os.WIFEXITED(status) and os.WEXITSTATUS(status) == 0):\n            raise AssertionError   # see error above in subprocess\n\n        from cffi import ffiplatform\n        prev_compile = ffiplatform.compile\n        try:\n            if targetpackage == ext_package:\n                ffiplatform.compile = lambda *args: dont_call_me_any_more\n            # won't find it in tmpdir, but should find it correctly\n            # installed in udir\n            ffi, lib = make_ffi()\n            assert lib.test1iarm(0.5) == 21.0\n        finally:\n            ffiplatform.compile = prev_compile\n\n    def test_install_and_reload_module_package(self):\n        self.test_install_and_reload_module(targetpackage='foo_iarmp',\n                                            ext_package='foo_iarmp')\n\n    def test_install_and_reload_module_ext_package_not_found(self):\n        self.test_install_and_reload_module(targetpackage='foo_epnf',\n                                            ext_package='not_found')\n\n    def test_tag(self):\n        ffi = FFI()\n        ffi.cdef(\"/* %s test_tag */ double test1tag(double x);\" % self)\n        csrc = \"double test1tag(double x) { return x - 42.0; }\"\n        lib = ffi.verify(csrc, force_generic_engine=self.generic,\n                         tag='xxtest_tagxx')\n        assert lib.test1tag(143) == 101.0\n        assert '_cffi_xxtest_tagxx_' in ffi.verifier.modulefilename\n\n    def test_modulename(self):\n        ffi = FFI()\n        ffi.cdef(\"/* %s test_modulename */ double test1foo(double x);\" % self)\n        csrc = \"double test1foo(double x) { return x - 63.0; }\"\n        modname = 'xxtest_modulenamexx%d' % (self.generic,)\n        lib = ffi.verify(csrc, force_generic_engine=self.generic,\n                         modulename=modname)\n        assert lib.test1foo(143) == 80.0\n        suffix = _get_so_suffixes()[0]\n        fn1 = os.path.join(ffi.verifier.tmpdir, modname + '.c')\n        fn2 = os.path.join(ffi.verifier.tmpdir, modname + suffix)\n        assert ffi.verifier.sourcefilename == fn1\n        assert ffi.verifier.modulefilename == fn2\n\n\nclass TestDistUtilsCPython(DistUtilsTest):\n    generic = False\n\nclass TestDistUtilsGeneric(DistUtilsTest):\n    generic = True\n", "testing/cffi0/test_model.py": "from cffi.model import *\n\n\ndef test_void_type():\n    assert void_type.get_c_name() == \"void\"\n    assert void_type.get_c_name(\"foo\") == \"void foo\"\n    assert void_type.get_c_name(\"*foo\") == \"void *foo\"\n\ndef test_primitive_type():\n    int_type = PrimitiveType(\"int\")\n    assert int_type.get_c_name() == \"int\"\n    assert int_type.get_c_name(\"foo\") == \"int foo\"\n    assert int_type.get_c_name(\"*foo\") == \"int *foo\"\n    assert int_type.get_c_name(\"[5]\") == \"int[5]\"\n\ndef test_raw_function_type():\n    int_type = PrimitiveType(\"int\")\n    fn_type = RawFunctionType([], int_type, False)\n    assert fn_type.get_c_name() == \"int()(void)\"\n    assert fn_type.get_c_name(\"*\") == \"int( *)(void)\"\n    assert fn_type.get_c_name(\"*foo\") == \"int( *foo)(void)\"\n    fn_type = RawFunctionType([int_type], int_type, False)\n    assert fn_type.get_c_name() == \"int()(int)\"\n    fn_type = RawFunctionType([int_type] * 2, int_type, False)\n    assert fn_type.get_c_name() == \"int()(int, int)\"\n    #\n    fn_type = RawFunctionType([int_type], int_type, True)\n    assert fn_type.get_c_name() == \"int()(int, ...)\"\n    assert fn_type.get_c_name(\"*foo\") == \"int( *foo)(int, ...)\"\n    #\n    res_type = FunctionPtrType([int_type], int_type, True)\n    fn_type = RawFunctionType([int_type], res_type, True)\n    assert fn_type.get_c_name(\"x\") == \"int(*( x)(int, ...))(int, ...)\"\n\ndef test_function_ptr_type():\n    int_type = PrimitiveType(\"int\")\n    fn_type = FunctionPtrType([], int_type, False)\n    assert fn_type.get_c_name() == \"int(*)(void)\"\n    assert fn_type.get_c_name(\"*\") == \"int(* *)(void)\"\n    assert fn_type.get_c_name(\"*foo\") == \"int(* *foo)(void)\"\n    fn_type = FunctionPtrType([int_type], int_type, False)\n    assert fn_type.get_c_name() == \"int(*)(int)\"\n    fn_type = FunctionPtrType([int_type] * 2, int_type, False)\n    assert fn_type.get_c_name() == \"int(*)(int, int)\"\n    #\n    fn_type = FunctionPtrType([int_type], int_type, True)\n    assert fn_type.get_c_name() == \"int(*)(int, ...)\"\n\ndef test_pointer_type():\n    ptr_type = PointerType(PrimitiveType(\"int\"))\n    assert ptr_type.get_c_name(\"x\") == \"int * x\"\n\ndef test_const_pointer_type():\n    ptr_type = ConstPointerType(PrimitiveType(\"int\"))\n    assert ptr_type.get_c_name(\"x\") == \"int const * x\"\n    ptr_type = ConstPointerType(ArrayType(PrimitiveType(\"int\"), 5))\n    assert ptr_type.get_c_name(\"\") == \"int const (*)[5]\"\n    assert ptr_type.get_c_name(\"*x\") == \"int const (* *x)[5]\"\n    ptr_type = ConstPointerType(ArrayType(\n        ConstPointerType(PrimitiveType(\"int\")), 5))\n    assert ptr_type.get_c_name(\"x\") == \"int const * const (* x)[5]\"\n    ptr_type = PointerType(ArrayType(\n        ConstPointerType(PrimitiveType(\"int\")), 5))\n    assert ptr_type.get_c_name(\"x\") == \"int const *(* x)[5]\"\n    ptr_type = ConstPointerType(ArrayType(\n        PointerType(PrimitiveType(\"int\")), 5))\n    assert ptr_type.get_c_name(\"x\") == \"int * const (* x)[5]\"\n\ndef test_qual_pointer_type():\n    ptr_type = PointerType(PrimitiveType(\"long long\"), Q_RESTRICT)\n    assert ptr_type.get_c_name(\"\") == \"long long __restrict *\"\n    assert const_voidp_type.get_c_name(\"\") == \"void const *\"\n\ndef test_unknown_pointer_type():\n    ptr_type = unknown_ptr_type(\"foo_p\")\n    assert ptr_type.get_c_name(\"\") == \"foo_p\"\n    assert ptr_type.get_c_name(\"x\") == \"foo_p x\"\n\ndef test_unknown_type():\n    u_type = unknown_type(\"foo_t\")\n    assert u_type.get_c_name(\"\") == \"foo_t\"\n    assert u_type.get_c_name(\"x\") == \"foo_t x\"\n\ndef test_array_type():\n    a_type = ArrayType(PrimitiveType(\"int\"), None)\n    assert a_type.get_c_name(\"\") == \"int[]\"\n    assert a_type.get_c_name(\"x\") == \"int x[]\"\n    assert a_type.get_c_name(\"*x\") == \"int(*x)[]\"\n    assert a_type.get_c_name(\" *x\") == \"int(*x)[]\"\n    assert a_type.get_c_name(\"[5]\") == \"int[5][]\"\n    a_type = ArrayType(unknown_type(\"foo_t\"), 5)\n    assert a_type.get_c_name(\"\") == \"foo_t[5]\"\n    assert a_type.get_c_name(\"x\") == \"foo_t x[5]\"\n    assert a_type.get_c_name(\"*x\") == \"foo_t(*x)[5]\"\n    a_type = ArrayType(unknown_ptr_type(\"foo_p\"), None)\n    assert a_type.get_c_name(\"\") == \"foo_p[]\"\n    assert a_type.get_c_name(\"x\") == \"foo_p x[]\"\n    assert a_type.get_c_name(\"*x\") == \"foo_p(*x)[]\"\n    a_type = ArrayType(ConstPointerType(PrimitiveType(\"int\")), None)\n    assert a_type.get_c_name(\"\") == \"int const *[]\"\n    assert a_type.get_c_name(\"x\") == \"int const * x[]\"\n    assert a_type.get_c_name(\"*x\") == \"int const *(*x)[]\"\n    fn_type = FunctionPtrType([], PrimitiveType(\"int\"), False)\n    a_type = ArrayType(fn_type, 5)\n    assert a_type.get_c_name(\"\") == \"int(*[5])(void)\"\n    assert a_type.get_c_name(\"x\") == \"int(* x[5])(void)\"\n    assert a_type.get_c_name(\"*x\") == \"int(*(*x)[5])(void)\"\n\ndef test_struct_type():\n    struct_type = StructType(\"foo_s\", None, None, None)\n    assert struct_type.get_c_name() == \"struct foo_s\"\n    assert struct_type.get_c_name(\"*x\") == \"struct foo_s *x\"\n\ndef test_union_type():\n    union_type = UnionType(\"foo_s\", None, None, None)\n    assert union_type.get_c_name() == \"union foo_s\"\n\ndef test_enum_type():\n    enum_type = EnumType(\"foo_e\", [], [])\n    assert enum_type.get_c_name() == \"enum foo_e\"\n", "testing/cffi0/backend_tests.py": "import pytest\nimport platform\nimport sys, ctypes, ctypes.util\nfrom cffi import FFI, CDefError, FFIError, VerificationMissing\nfrom testing.support import *\n\nSIZE_OF_INT   = ctypes.sizeof(ctypes.c_int)\nSIZE_OF_LONG  = ctypes.sizeof(ctypes.c_long)\nSIZE_OF_SHORT = ctypes.sizeof(ctypes.c_short)\nSIZE_OF_PTR   = ctypes.sizeof(ctypes.c_void_p)\nSIZE_OF_WCHAR = ctypes.sizeof(ctypes.c_wchar)\n\ndef needs_dlopen_none():\n    if sys.platform == 'win32' and not ctypes.util.find_library('c'):\n        pytest.skip(\"dlopen(None) cannot work on Windows with this runtime\")\n\n\nclass BackendTests:\n\n    def test_integer_ranges(self):\n        ffi = FFI(backend=self.Backend())\n        for (c_type, size) in [('char', 1),\n                               ('short', 2),\n                               ('short int', 2),\n                               ('', 4),\n                               ('int', 4),\n                               ('long', SIZE_OF_LONG),\n                               ('long int', SIZE_OF_LONG),\n                               ('long long', 8),\n                               ('long long int', 8),\n                               ]:\n            for unsigned in [None, False, True]:\n                c_decl = {None: '',\n                          False: 'signed ',\n                          True: 'unsigned '}[unsigned] + c_type\n                if c_decl == 'char' or c_decl == '':\n                    continue\n                self._test_int_type(ffi, c_decl, size, unsigned)\n\n    def test_fixedsize_int(self):\n        ffi = FFI(backend=self.Backend())\n        for size in [1, 2, 4, 8]:\n            self._test_int_type(ffi, 'int%d_t' % (8*size), size, False)\n            self._test_int_type(ffi, 'uint%d_t' % (8*size), size, True)\n        self._test_int_type(ffi, 'intptr_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'uintptr_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ptrdiff_t', SIZE_OF_PTR, False)\n        self._test_int_type(ffi, 'size_t', SIZE_OF_PTR, True)\n        self._test_int_type(ffi, 'ssize_t', SIZE_OF_PTR, False)\n\n    def _test_int_type(self, ffi, c_decl, size, unsigned):\n        if unsigned:\n            min = 0\n            max = (1 << (8*size)) - 1\n        else:\n            min = -(1 << (8*size-1))\n            max = (1 << (8*size-1)) - 1\n        min = int(min)\n        max = int(max)\n        p = ffi.cast(c_decl, min)\n        assert p == min\n        assert hash(p) == hash(min)\n        assert bool(p) is bool(min)\n        assert int(p) == min\n        p = ffi.cast(c_decl, max)\n        assert int(p) == max\n        p = ffi.cast(c_decl, long(max))\n        assert int(p) == max\n        q = ffi.cast(c_decl, min - 1)\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        q = ffi.cast(c_decl, long(min - 1))\n        assert ffi.typeof(q) is ffi.typeof(p) and int(q) == max\n        assert q == p\n        assert int(q) == int(p)\n        assert hash(q) == hash(p)\n        c_decl_ptr = '%s *' % c_decl\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, min - 1)\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, max + 1)\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(min - 1))\n        pytest.raises(OverflowError, ffi.new, c_decl_ptr, long(max + 1))\n        assert ffi.new(c_decl_ptr, min)[0] == min\n        assert ffi.new(c_decl_ptr, max)[0] == max\n        assert ffi.new(c_decl_ptr, long(min))[0] == min\n        assert ffi.new(c_decl_ptr, long(max))[0] == max\n\n    def test_new_unsupported_type(self):\n        ffi = FFI(backend=self.Backend())\n        e = pytest.raises(TypeError, ffi.new, \"int\")\n        assert str(e.value) == \"expected a pointer or array ctype, got 'int'\"\n\n    def test_new_single_integer(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\")     # similar to ffi.new(\"int[1]\")\n        assert p[0] == 0\n        p[0] = -123\n        assert p[0] == -123\n        p = ffi.new(\"int *\", -42)\n        assert p[0] == -42\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n\n    def test_new_array_no_arg(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[10]\")\n        # the object was zero-initialized:\n        for i in range(10):\n            assert p[i] == 0\n\n    def test_array_indexing(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[10]\")\n        p[0] = 42\n        p[9] = 43\n        assert p[0] == 42\n        assert p[9] == 43\n        with pytest.raises(IndexError):\n            p[10]\n        with pytest.raises(IndexError):\n            p[10] = 44\n        with pytest.raises(IndexError):\n            p[-1]\n        with pytest.raises(IndexError):\n            p[-1] = 44\n\n    def test_new_array_args(self):\n        ffi = FFI(backend=self.Backend())\n        # this tries to be closer to C: where we say \"int x[5] = {10, 20, ..}\"\n        # then here we must enclose the items in a list\n        p = ffi.new(\"int[5]\", [10, 20, 30, 40, 50])\n        assert p[0] == 10\n        assert p[1] == 20\n        assert p[2] == 30\n        assert p[3] == 40\n        assert p[4] == 50\n        p = ffi.new(\"int[4]\", [25])\n        assert p[0] == 25\n        assert p[1] == 0     # follow C convention rather than LuaJIT's\n        assert p[2] == 0\n        assert p[3] == 0\n        p = ffi.new(\"int[4]\", [ffi.cast(\"int\", -5)])\n        assert p[0] == -5\n        assert repr(p) == \"<cdata 'int[4]' owning %d bytes>\" % (4*SIZE_OF_INT)\n\n    def test_new_array_varsize(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[]\", 10)     # a single integer is the length\n        assert p[9] == 0\n        with pytest.raises(IndexError):\n            p[10]\n        #\n        pytest.raises(TypeError, ffi.new, \"int[]\")\n        #\n        p = ffi.new(\"int[]\", [-6, -7])    # a list is all the items, like C\n        assert p[0] == -6\n        assert p[1] == -7\n        with pytest.raises(IndexError):\n            p[2]\n        assert repr(p) == \"<cdata 'int[]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        #\n        p = ffi.new(\"int[]\", 0)\n        with pytest.raises(IndexError):\n            p[0]\n        pytest.raises(ValueError, ffi.new, \"int[]\", -1)\n        assert repr(p) == \"<cdata 'int[]' owning 0 bytes>\"\n\n    def test_pointer_init(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int *\", 24)\n        a = ffi.new(\"int *[10]\", [ffi.NULL, ffi.NULL, n, n, ffi.NULL])\n        for i in range(10):\n            if i not in (2, 3):\n                assert a[i] == ffi.NULL\n        assert a[2] == a[3] == n\n\n    def test_cannot_cast(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[10]\")\n        e = pytest.raises(TypeError, ffi.new, \"long int **\", a)\n        msg = str(e.value)\n        assert \"'short[10]'\" in msg and \"'long *'\" in msg\n\n    def test_new_pointer_to_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"int[4]\", [100, 102, 104, 106])\n        p = ffi.new(\"int **\", a)\n        assert p[0] == ffi.cast(\"int *\", a)\n        assert p[0][2] == 104\n        p = ffi.cast(\"int *\", a)\n        assert p[0] == 100\n        assert p[1] == 102\n        assert p[2] == 104\n        assert p[3] == 106\n        # keepalive: a\n\n    def test_pointer_direct(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.cast(\"int*\", 0)\n        assert p is not None\n        assert bool(p) is False\n        assert p == ffi.cast(\"int*\", 0)\n        assert p != None\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        a = ffi.new(\"int[]\", [123, 456])\n        p = ffi.cast(\"int*\", a)\n        assert bool(p) is True\n        assert p == ffi.cast(\"int*\", a)\n        assert p != ffi.cast(\"int*\", 0)\n        assert p[0] == 123\n        assert p[1] == 456\n\n    def test_repr(self):\n        typerepr = self.TypeRepr\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { short a, b, c; };\")\n        p = ffi.cast(\"short unsigned int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"unsigned short int\", 0)\n        assert repr(p) == \"<cdata 'unsigned short' 0>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"unsigned short\"\n        p = ffi.cast(\"int*\", 0)\n        assert repr(p) == \"<cdata 'int *' NULL>\"\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        #\n        p = ffi.new(\"int*\")\n        assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % SIZE_OF_INT\n        assert repr(ffi.typeof(p)) == typerepr % \"int *\"\n        p = ffi.new(\"int**\")\n        assert repr(p) == \"<cdata 'int * *' owning %d bytes>\" % SIZE_OF_PTR\n        assert repr(ffi.typeof(p)) == typerepr % \"int * *\"\n        p = ffi.new(\"int [2]\")\n        assert repr(p) == \"<cdata 'int[2]' owning %d bytes>\" % (2*SIZE_OF_INT)\n        assert repr(ffi.typeof(p)) == typerepr % \"int[2]\"\n        p = ffi.new(\"int*[2][3]\")\n        assert repr(p) == \"<cdata 'int *[2][3]' owning %d bytes>\" % (\n            6*SIZE_OF_PTR)\n        assert repr(ffi.typeof(p)) == typerepr % \"int *[2][3]\"\n        p = ffi.new(\"struct foo *\")\n        assert repr(p) == \"<cdata 'struct foo *' owning %d bytes>\" % (\n            3*SIZE_OF_SHORT)\n        assert repr(ffi.typeof(p)) == typerepr % \"struct foo *\"\n        #\n        q = ffi.cast(\"short\", -123)\n        assert repr(q) == \"<cdata 'short' -123>\"\n        assert repr(ffi.typeof(q)) == typerepr % \"short\"\n        p = ffi.new(\"int*\")\n        q = ffi.cast(\"short*\", p)\n        assert repr(q).startswith(\"<cdata 'short *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"short *\"\n        p = ffi.new(\"int [2]\")\n        q = ffi.cast(\"int*\", p)\n        assert repr(q).startswith(\"<cdata 'int *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"int *\"\n        p = ffi.new(\"struct foo*\")\n        q = ffi.cast(\"struct foo *\", p)\n        assert repr(q).startswith(\"<cdata 'struct foo *' 0x\")\n        assert repr(ffi.typeof(q)) == typerepr % \"struct foo *\"\n        prevrepr = repr(q)\n        q = q[0]\n        assert repr(q) == prevrepr.replace(' *', ' &')\n        assert repr(ffi.typeof(q)) == typerepr % \"struct foo\"\n\n    def test_new_array_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[3][4]\")\n        p[0][0] = 10\n        p[2][3] = 33\n        assert p[0][0] == 10\n        assert p[2][3] == 33\n        with pytest.raises(IndexError):\n            p[1][-1]\n\n    def test_constructor_array_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[3][2]\", [[10, 11], [12, 13], [14, 15]])\n        assert p[2][1] == 15\n\n    def test_new_array_of_pointer_1(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_new_array_of_pointer_2(self):\n        ffi = FFI(backend=self.Backend())\n        n = ffi.new(\"int[1]\", [99])\n        p = ffi.new(\"int*[4]\")\n        p[3] = n\n        a = p[3]\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert a[0] == 99\n\n    def test_char(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.new(\"char*\", b\"\\xff\")[0] == b'\\xff'\n        assert ffi.new(\"char*\")[0] == b'\\x00'\n        assert int(ffi.cast(\"char\", 300)) == 300 - 256\n        assert not bool(ffi.cast(\"char\", 0))\n        assert bool(ffi.cast(\"char\", 1))\n        assert bool(ffi.cast(\"char\", 255))\n        pytest.raises(TypeError, ffi.new, \"char*\", 32)\n        pytest.raises(TypeError, ffi.new, \"char*\", u+\"x\")\n        pytest.raises(TypeError, ffi.new, \"char*\", b\"foo\")\n        #\n        p = ffi.new(\"char[]\", [b'a', b'b', b'\\x9c'])\n        assert len(p) == 3\n        assert p[0] == b'a'\n        assert p[1] == b'b'\n        assert p[2] == b'\\x9c'\n        p[0] = b'\\xff'\n        assert p[0] == b'\\xff'\n        p = ffi.new(\"char[]\", b\"abcd\")\n        assert len(p) == 5\n        assert p[4] == b'\\x00'    # like in C, with:  char[] p = \"abcd\";\n        #\n        p = ffi.new(\"char[4]\", b\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [b'a', b'b', b'\\x00', b'\\x00']\n        p = ffi.new(\"char[2]\", b\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [b'a', b'b']\n        pytest.raises(IndexError, ffi.new, \"char[2]\", b\"abc\")\n\n    def check_wchar_t(self, ffi):\n        try:\n            ffi.cast(\"wchar_t\", 0)\n        except NotImplementedError:\n            pytest.skip(\"NotImplementedError: wchar_t\")\n\n    def test_wchar_t(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        assert ffi.new(\"wchar_t*\", u+'x')[0] == u+'x'\n        assert ffi.new(\"wchar_t*\", u+'\\u1234')[0] == u+'\\u1234'\n        if SIZE_OF_WCHAR > 2:\n            assert ffi.new(\"wchar_t*\", u+'\\U00012345')[0] == u+'\\U00012345'\n        else:\n            pytest.raises(TypeError, ffi.new, \"wchar_t*\", u+'\\U00012345')\n        assert ffi.new(\"wchar_t*\")[0] == u+'\\x00'\n        assert int(ffi.cast(\"wchar_t\", 300)) == 300\n        assert not bool(ffi.cast(\"wchar_t\", 0))\n        assert bool(ffi.cast(\"wchar_t\", 1))\n        assert bool(ffi.cast(\"wchar_t\", 65535))\n        if SIZE_OF_WCHAR > 2:\n            assert bool(ffi.cast(\"wchar_t\", 65536))\n        pytest.raises(TypeError, ffi.new, \"wchar_t*\", 32)\n        pytest.raises(TypeError, ffi.new, \"wchar_t*\", \"foo\")\n        #\n        p = ffi.new(\"wchar_t[]\", [u+'a', u+'b', u+'\\u1234'])\n        assert len(p) == 3\n        assert p[0] == u+'a'\n        assert p[1] == u+'b' and type(p[1]) is unicode\n        assert p[2] == u+'\\u1234'\n        p[0] = u+'x'\n        assert p[0] == u+'x' and type(p[0]) is unicode\n        p[1] = u+'\\u1357'\n        assert p[1] == u+'\\u1357'\n        p = ffi.new(\"wchar_t[]\", u+\"abcd\")\n        assert len(p) == 5\n        assert p[4] == u+'\\x00'\n        p = ffi.new(\"wchar_t[]\", u+\"a\\u1234b\")\n        assert len(p) == 4\n        assert p[1] == u+'\\u1234'\n        #\n        p = ffi.new(\"wchar_t[]\", u+'\\U00023456')\n        if SIZE_OF_WCHAR == 2:\n            assert len(p) == 3\n            assert p[0] == u+'\\ud84d'\n            assert p[1] == u+'\\udc56'\n            assert p[2] == u+'\\x00'\n        else:\n            assert len(p) == 2\n            assert p[0] == u+'\\U00023456'\n            assert p[1] == u+'\\x00'\n        #\n        p = ffi.new(\"wchar_t[4]\", u+\"ab\")\n        assert len(p) == 4\n        assert [p[i] for i in range(4)] == [u+'a', u+'b', u+'\\x00', u+'\\x00']\n        p = ffi.new(\"wchar_t[2]\", u+\"ab\")\n        assert len(p) == 2\n        assert [p[i] for i in range(2)] == [u+'a', u+'b']\n        pytest.raises(IndexError, ffi.new, \"wchar_t[2]\", u+\"abc\")\n\n    def test_none_as_null_doesnt_work(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int*[1]\")\n        assert p[0] is not None\n        assert p[0] != None\n        assert p[0] == ffi.NULL\n        assert repr(p[0]) == \"<cdata 'int *' NULL>\"\n        #\n        n = ffi.new(\"int*\", 99)\n        p = ffi.new(\"int*[]\", [n])\n        assert p[0][0] == 99\n        with pytest.raises(TypeError):\n            p[0] = None\n        p[0] = ffi.NULL\n        assert p[0] == ffi.NULL\n\n    def test_float(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"float[]\", [-2, -2.5])\n        assert p[0] == -2.0\n        assert p[1] == -2.5\n        p[1] += 17.75\n        assert p[1] == 15.25\n        #\n        p = ffi.new(\"float*\", 15.75)\n        assert p[0] == 15.75\n        pytest.raises(TypeError, int, p)\n        pytest.raises(TypeError, float, p)\n        p[0] = 0.0\n        assert bool(p) is True\n        #\n        p = ffi.new(\"float*\", 1.1)\n        f = p[0]\n        assert f != 1.1      # because of rounding effect\n        assert abs(f - 1.1) < 1E-7\n        #\n        INF = 1E200 * 1E200\n        assert 1E200 != INF\n        p[0] = 1E200\n        assert p[0] == INF     # infinite, not enough precision\n\n    def test_struct_simple(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\")\n        assert s.a == s.b == s.c == 0\n        s.b = -23\n        assert s.b == -23\n        with pytest.raises(OverflowError):\n            s.b = 32768\n        #\n        s = ffi.new(\"struct foo*\", [-2, -3])\n        assert s.a == -2\n        assert s.b == -3\n        assert s.c == 0\n        with pytest.raises((AttributeError, TypeError)):\n            del s.a\n        assert repr(s) == \"<cdata 'struct foo *' owning %d bytes>\" % (\n            SIZE_OF_INT + 2 * SIZE_OF_SHORT)\n        #\n        pytest.raises(ValueError, ffi.new, \"struct foo*\", [1, 2, 3, 4])\n\n    def test_constructor_struct_from_dict(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\", {'b': 123, 'c': 456})\n        assert s.a == 0\n        assert s.b == 123\n        assert s.c == 456\n        pytest.raises(KeyError, ffi.new, \"struct foo*\", {'d': 456})\n\n    def test_struct_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo*\")\n        assert s[0].a == s[0].b == s[0].c == 0\n        s[0].b = -23\n        assert s[0].b == s.b == -23\n        with pytest.raises(OverflowError):\n            s[0].b = -32769\n        with pytest.raises(IndexError):\n            s[1]\n\n    def test_struct_opaque(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(TypeError, ffi.new, \"struct baz*\")\n        p = ffi.new(\"struct baz **\")    # this works\n        assert p[0] == ffi.NULL\n\n    def test_pointer_to_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a; short b, c; };\")\n        s = ffi.new(\"struct foo *\")\n        s.a = -42\n        assert s[0].a == -42\n        p = ffi.new(\"struct foo **\", s)\n        assert p[0].a == -42\n        assert p[0][0].a == -42\n        p[0].a = -43\n        assert s.a == -43\n        assert s[0].a == -43\n        p[0][0].a = -44\n        assert s.a == -44\n        assert s[0].a == -44\n        s.a = -45\n        assert p[0].a == -45\n        assert p[0][0].a == -45\n        s[0].a = -46\n        assert p[0].a == -46\n        assert p[0][0].a == -46\n\n    def test_constructor_struct_of_array(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a[2]; char b[3]; };\")\n        s = ffi.new(\"struct foo *\", [[10, 11], [b'a', b'b', b'c']])\n        assert s.a[1] == 11\n        assert s.b[2] == b'c'\n        s.b[1] = b'X'\n        assert s.b[0] == b'a'\n        assert s.b[1] == b'X'\n        assert s.b[2] == b'c'\n\n    def test_recursive_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int value; struct foo *next; };\")\n        s = ffi.new(\"struct foo*\")\n        t = ffi.new(\"struct foo*\")\n        s.value = 123\n        s.next = t\n        t.value = 456\n        assert s.value == 123\n        assert s.next.value == 456\n\n    def test_union_simple(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"union foo { int a; short b, c; };\")\n        u = ffi.new(\"union foo*\")\n        assert u.a == u.b == u.c == 0\n        u.b = -23\n        assert u.b == -23\n        assert u.a != 0\n        with pytest.raises(OverflowError):\n            u.b = 32768\n        #\n        u = ffi.new(\"union foo*\", [-2])\n        assert u.a == -2\n        with pytest.raises((AttributeError, TypeError)):\n            del u.a\n        assert repr(u) == \"<cdata 'union foo *' owning %d bytes>\" % SIZE_OF_INT\n\n    def test_union_opaque(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(TypeError, ffi.new, \"union baz *\")\n        u = ffi.new(\"union baz **\")   # this works\n        assert u[0] == ffi.NULL\n\n    def test_union_initializer(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"union foo { char a; int b; };\")\n        pytest.raises(TypeError, ffi.new, \"union foo*\", b'A')\n        pytest.raises(TypeError, ffi.new, \"union foo*\", 5)\n        pytest.raises(ValueError, ffi.new, \"union foo*\", [b'A', 5])\n        u = ffi.new(\"union foo*\", [b'A'])\n        assert u.a == b'A'\n        pytest.raises(TypeError, ffi.new, \"union foo*\", [1005])\n        u = ffi.new(\"union foo*\", {'b': 12345})\n        assert u.b == 12345\n        u = ffi.new(\"union foo*\", [])\n        assert u.a == b'\\x00'\n        assert u.b == 0\n\n    def test_sizeof_type(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo { int a; short b, c, d; };\n            union foo { int a; short b, c, d; };\n        \"\"\")\n        for c_type, expected_size in [\n            ('char', 1),\n            ('unsigned int', 4),\n            ('char *', SIZE_OF_PTR),\n            ('int[5]', 20),\n            ('struct foo', 12),\n            ('union foo', 4),\n            ]:\n            size = ffi.sizeof(c_type)\n            assert size == expected_size, (size, expected_size, ctype)\n\n    def test_sizeof_cdata(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.sizeof(ffi.new(\"short*\")) == SIZE_OF_PTR\n        assert ffi.sizeof(ffi.cast(\"short\", 123)) == SIZE_OF_SHORT\n        #\n        a = ffi.new(\"int[]\", [10, 11, 12, 13, 14])\n        assert len(a) == 5\n        assert ffi.sizeof(a) == 5 * SIZE_OF_INT\n\n    def test_string_from_char_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        x = ffi.new(\"char*\", b\"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == b\"x\"\n        assert ffi.string(ffi.new(\"char*\", b\"\\x00\")) == b\"\"\n        pytest.raises(TypeError, ffi.new, \"char*\", unicode(\"foo\"))\n\n    def test_unicode_from_wchar_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        x = ffi.new(\"wchar_t*\", u+\"x\")\n        assert unicode(x) == unicode(repr(x))\n        assert ffi.string(x) == u+\"x\"\n        assert ffi.string(ffi.new(\"wchar_t*\", u+\"\\x00\")) == u+\"\"\n\n    def test_string_from_char_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"char[]\", b\"hello.\")\n        p[5] = b'!'\n        assert ffi.string(p) == b\"hello!\"\n        p[6] = b'?'\n        assert ffi.string(p) == b\"hello!?\"\n        p[3] = b'\\x00'\n        assert ffi.string(p) == b\"hel\"\n        assert ffi.string(p, 2) == b\"he\"\n        with pytest.raises(IndexError):\n            p[7] = b'X'\n        #\n        a = ffi.new(\"char[]\", b\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"char *\", a)\n        assert ffi.string(p) == b'hello'\n\n    def test_string_from_wchar_array(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        assert ffi.string(ffi.cast(\"wchar_t\", \"x\")) == u+\"x\"\n        assert ffi.string(ffi.cast(\"wchar_t\", u+\"x\")) == u+\"x\"\n        x = ffi.cast(\"wchar_t\", \"x\")\n        assert str(x) == repr(x)\n        assert ffi.string(x) == u+\"x\"\n        #\n        p = ffi.new(\"wchar_t[]\", u+\"hello.\")\n        p[5] = u+'!'\n        assert ffi.string(p) == u+\"hello!\"\n        p[6] = u+'\\u04d2'\n        assert ffi.string(p) == u+\"hello!\\u04d2\"\n        p[3] = u+'\\x00'\n        assert ffi.string(p) == u+\"hel\"\n        assert ffi.string(p, 123) == u+\"hel\"\n        with pytest.raises(IndexError):\n            p[7] = u+'X'\n        #\n        a = ffi.new(\"wchar_t[]\", u+\"hello\\x00world\")\n        assert len(a) == 12\n        p = ffi.cast(\"wchar_t *\", a)\n        assert ffi.string(p) == u+'hello'\n        assert ffi.string(p, 123) == u+'hello'\n        assert ffi.string(p, 5) == u+'hello'\n        assert ffi.string(p, 2) == u+'he'\n\n    def test_fetch_const_char_p_field(self):\n        # 'const' is ignored so far\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { const char *name; };\")\n        t = ffi.new(\"const char[]\", b\"testing\")\n        s = ffi.new(\"struct foo*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == b\"testing\"\n        with pytest.raises(TypeError):\n            s.name = None\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_fetch_const_wchar_p_field(self):\n        # 'const' is ignored so far\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        ffi.cdef(\"struct foo { const wchar_t *name; };\")\n        t = ffi.new(\"const wchar_t[]\", u+\"testing\")\n        s = ffi.new(\"struct foo*\", [t])\n        assert type(s.name) not in (bytes, str, unicode)\n        assert ffi.string(s.name) == u+\"testing\"\n        s.name = ffi.NULL\n        assert s.name == ffi.NULL\n\n    def test_voidp(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(TypeError, ffi.new, \"void*\")\n        p = ffi.new(\"void **\")\n        assert p[0] == ffi.NULL\n        a = ffi.new(\"int[]\", [10, 11, 12])\n        p = ffi.new(\"void **\", a)\n        vp = p[0]\n        with pytest.raises(TypeError):\n            vp[0]\n        pytest.raises(TypeError, ffi.new, \"short **\", a)\n        #\n        ffi.cdef(\"struct foo { void *p; int *q; short *r; };\")\n        s = ffi.new(\"struct foo *\")\n        s.p = a    # works\n        s.q = a    # works\n        with pytest.raises(TypeError):\n            s.r = a    # fails\n        b = ffi.cast(\"int *\", a)\n        s.p = b    # works\n        s.q = b    # works\n        with pytest.raises(TypeError):\n            s.r = b    # fails\n\n    def test_functionptr_simple(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(TypeError, ffi.callback, \"int(*)(int)\", 0)\n        def cb(n):\n            return n + 1\n        cb.__qualname__ = 'cb'\n        p = ffi.callback(\"int(*)(int)\", cb)\n        res = p(41)     # calling an 'int(*)(int)', i.e. a function pointer\n        assert res == 42 and type(res) is int\n        res = p(ffi.cast(\"int\", -41))\n        assert res == -40 and type(res) is int\n        assert repr(p).startswith(\n            \"<cdata 'int(*)(int)' calling <function cb at 0x\")\n        assert ffi.typeof(p) is ffi.typeof(\"int(*)(int)\")\n        q = ffi.new(\"int(**)(int)\", p)\n        assert repr(q) == \"<cdata 'int(* *)(int)' owning %d bytes>\" % (\n            SIZE_OF_PTR)\n        with pytest.raises(TypeError):\n            q(43)\n        res = q[0](43)\n        assert res == 44\n        q = ffi.cast(\"int(*)(int)\", p)\n        assert repr(q).startswith(\"<cdata 'int(*)(int)' 0x\")\n        res = q(45)\n        assert res == 46\n\n    def test_functionptr_advanced(self):\n        ffi = FFI(backend=self.Backend())\n        t = ffi.typeof(\"int(*(*)(int))(int)\")\n        assert repr(t) == self.TypeRepr % \"int(*(*)(int))(int)\"\n\n    def test_functionptr_voidptr_return(self):\n        ffi = FFI(backend=self.Backend())\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res is not None\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        void_ptr = ffi.cast('void*', int_ptr)\n        def cb():\n            return void_ptr\n        p = ffi.callback(\"void*(*)()\", cb)\n        res = p()\n        assert res == void_ptr\n\n    def test_functionptr_intptr_return(self):\n        ffi = FFI(backend=self.Backend())\n        def cb():\n            return ffi.NULL\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert res == ffi.NULL\n        int_ptr = ffi.new('int*')\n        def cb():\n            return int_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_ptr\n        int_array_ptr = ffi.new('int[1]')\n        def cb():\n            return int_array_ptr\n        p = ffi.callback(\"int*(*)()\", cb)\n        res = p()\n        assert repr(res).startswith(\"<cdata 'int *' 0x\")\n        assert res == int_array_ptr\n\n    def test_functionptr_void_return(self):\n        ffi = FFI(backend=self.Backend())\n        def foo():\n            pass\n        foo_cb = ffi.callback(\"void foo()\", foo)\n        result = foo_cb()\n        assert result is None\n\n    def test_char_cast(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.cast(\"int\", b'\\x01')\n        assert ffi.typeof(p) is ffi.typeof(\"int\")\n        assert int(p) == 1\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"a\"))\n        assert int(p) == ord(\"a\")\n        p = ffi.cast(\"int\", ffi.cast(\"char\", b\"\\x80\"))\n        assert int(p) == 0x80     # \"char\" is considered unsigned in this case\n        p = ffi.cast(\"int\", b\"\\x81\")\n        assert int(p) == 0x81\n\n    def test_wchar_cast(self):\n        ffi = FFI(backend=self.Backend())\n        self.check_wchar_t(ffi)\n        p = ffi.cast(\"int\", ffi.cast(\"wchar_t\", u+'\\u1234'))\n        assert int(p) == 0x1234\n        p = ffi.cast(\"long long\", ffi.cast(\"wchar_t\", -1))\n        if SIZE_OF_WCHAR == 2:      # 2 bytes, unsigned\n            assert int(p) == 0xffff\n        elif (sys.platform.startswith('linux') and\n              platform.machine().startswith('x86')):   # known to be signed\n            assert int(p) == -1\n        else:                     # in general, it can be either signed or not\n            assert int(p) in [-1, 0xffffffff]  # e.g. on arm, both cases occur\n        p = ffi.cast(\"int\", u+'\\u1234')\n        assert int(p) == 0x1234\n\n    def test_cast_array_to_charp(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"char*\", a)\n        data = b''.join([p[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_between_pointers(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        p = ffi.cast(\"short*\", a)\n        p2 = ffi.cast(\"int*\", p)\n        q = ffi.cast(\"char*\", p2)\n        data = b''.join([q[i] for i in range(4)])\n        if sys.byteorder == 'little':\n            assert data == b'\\x34\\x12\\x78\\x56'\n        else:\n            assert data == b'\\x12\\x34\\x56\\x78'\n\n    def test_cast_pointer_and_int(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short int[]\", [0x1234, 0x5678])\n        l1 = ffi.cast(\"intptr_t\", a)\n        p = ffi.cast(\"short*\", a)\n        l2 = ffi.cast(\"intptr_t\", p)\n        assert int(l1) == int(l2) != 0\n        q = ffi.cast(\"short*\", l1)\n        assert q == ffi.cast(\"short*\", int(l1))\n        assert q[0] == 0x1234\n        assert int(ffi.cast(\"intptr_t\", ffi.NULL)) == 0\n\n    def test_cast_functionptr_and_int(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(n):\n            return n + 1\n        a = ffi.callback(\"int(*)(int)\", cb)\n        p = ffi.cast(\"void *\", a)\n        assert p\n        b = ffi.cast(\"int(*)(int)\", p)\n        assert b(41) == 42\n        assert a == b\n        assert hash(a) == hash(b)\n\n    def test_callback_crash(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(n):\n            raise Exception\n        a = ffi.callback(\"int(*)(int)\", cb, error=42)\n        res = a(1)    # and the error reported to stderr\n        assert res == 42\n\n    def test_structptr_argument(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a, b; };\")\n        def cb(p):\n            return p[0].a * 1000 + p[0].b * 100 + p[1].a * 10 + p[1].b\n        a = ffi.callback(\"int(*)(struct foo_s[])\", cb)\n        res = a([[5, 6], {'a': 7, 'b': 8}])\n        assert res == 5678\n        res = a([[5], {'b': 8}])\n        assert res == 5008\n\n    def test_array_argument_as_list(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int a, b; };\")\n        seen = []\n        def cb(argv):\n            seen.append(ffi.string(argv[0]))\n            seen.append(ffi.string(argv[1]))\n        a = ffi.callback(\"void(*)(char *[])\", cb)\n        a([ffi.new(\"char[]\", b\"foobar\"), ffi.new(\"char[]\", b\"baz\")])\n        assert seen == [b\"foobar\", b\"baz\"]\n\n    def test_cast_float(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.cast(\"float\", 12)\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", 12.5)\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", b\"A\")\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", 12.9)\n        assert int(a) == 12\n        a = ffi.cast(\"char\", 66.9 + 256)\n        assert ffi.string(a) == b\"B\"\n        #\n        a = ffi.cast(\"float\", ffi.cast(\"int\", 12))\n        assert float(a) == 12.0\n        a = ffi.cast(\"float\", ffi.cast(\"double\", 12.5))\n        assert float(a) == 12.5\n        a = ffi.cast(\"float\", ffi.cast(\"char\", b\"A\"))\n        assert float(a) == ord(\"A\")\n        a = ffi.cast(\"int\", ffi.cast(\"double\", 12.9))\n        assert int(a) == 12\n        a = ffi.cast(\"char\", ffi.cast(\"double\", 66.9 + 256))\n        assert ffi.string(a) == b\"B\"\n\n    def test_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A0, B0, CC0, D0 };\")\n        assert ffi.string(ffi.cast(\"enum foo\", 0)) == \"A0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 2)) == \"CC0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 3)) == \"D0\"\n        assert ffi.string(ffi.cast(\"enum foo\", 4)) == \"4\"\n        ffi.cdef(\"enum bar { A1, B1=-2, CC1, D1, E1 };\")\n        assert ffi.string(ffi.cast(\"enum bar\", 0)) == \"A1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -2)) == \"B1\"\n        assert ffi.string(ffi.cast(\"enum bar\", -1)) == \"CC1\"\n        assert ffi.string(ffi.cast(\"enum bar\", 1)) == \"E1\"\n        assert ffi.cast(\"enum bar\", -2) == ffi.cast(\"enum bar\", -2)\n        assert ffi.cast(\"enum foo\", 0) == ffi.cast(\"enum bar\", 0)\n        assert ffi.cast(\"enum bar\", 0) == ffi.cast(\"int\", 0)\n        assert repr(ffi.cast(\"enum bar\", -1)) == \"<cdata 'enum bar' -1: CC1>\"\n        assert repr(ffi.cast(\"enum foo\", -1)) == (  # enums are unsigned, if\n            \"<cdata 'enum foo' 4294967295>\")        # they contain no neg value\n        ffi.cdef(\"enum baz { A2=0x1000, B2=0x2000 };\")\n        assert ffi.string(ffi.cast(\"enum baz\", 0x1000)) == \"A2\"\n        assert ffi.string(ffi.cast(\"enum baz\", 0x2000)) == \"B2\"\n\n    def test_enum_in_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A, B, C, D }; struct bar { enum foo e; };\")\n        s = ffi.new(\"struct bar *\")\n        s.e = 0\n        assert s.e == 0\n        s.e = 3\n        assert s.e == 3\n        assert s[0].e == 3\n        s[0].e = 2\n        assert s.e == 2\n        assert s[0].e == 2\n        s.e = ffi.cast(\"enum foo\", -1)\n        assert s.e == 4294967295\n        assert s[0].e == 4294967295\n        s.e = s.e\n        with pytest.raises(TypeError):\n            s.e = 'B'\n        with pytest.raises(TypeError):\n            s.e = '2'\n        with pytest.raises(TypeError):\n            s.e = '#2'\n        with pytest.raises(TypeError):\n            s.e = '#7'\n\n    def test_enum_non_contiguous(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo { A, B=42, C };\")\n        assert ffi.string(ffi.cast(\"enum foo\", 0)) == \"A\"\n        assert ffi.string(ffi.cast(\"enum foo\", 42)) == \"B\"\n        assert ffi.string(ffi.cast(\"enum foo\", 43)) == \"C\"\n        invalid_value = ffi.cast(\"enum foo\", 2)\n        assert int(invalid_value) == 2\n        assert ffi.string(invalid_value) == \"2\"\n\n    def test_enum_char_hex_oct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(r\"enum foo{A='!', B='\\'', C=0x10, D=010, E=- 0x10, F=-010};\")\n        assert ffi.string(ffi.cast(\"enum foo\", ord('!'))) == \"A\"\n        assert ffi.string(ffi.cast(\"enum foo\", ord(\"'\"))) == \"B\"\n        assert ffi.string(ffi.cast(\"enum foo\", 16)) == \"C\"\n        assert ffi.string(ffi.cast(\"enum foo\", 8)) == \"D\"\n        assert ffi.string(ffi.cast(\"enum foo\", -16)) == \"E\"\n        assert ffi.string(ffi.cast(\"enum foo\", -8)) == \"F\"\n\n    def test_enum_partial(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(r\"enum foo {A, ...}; enum bar { B, C };\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert lib.B == 0\n        pytest.raises(VerificationMissing, getattr, lib, \"A\")\n        assert lib.C == 1\n\n    def test_array_of_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b; };\")\n        s = ffi.new(\"struct foo[1]\")\n        with pytest.raises(AttributeError):\n            s.b\n        with pytest.raises(AttributeError):\n            s.b = 412\n        s[0].b = 412\n        assert s[0].b == 412\n        with pytest.raises(IndexError):\n            s[1]\n\n    def test_pointer_to_array(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int(**)[5]\")\n        assert repr(p) == \"<cdata 'int(* *)[5]' owning %d bytes>\" % SIZE_OF_PTR\n\n    def test_iterate_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"char[]\", b\"hello\")\n        assert list(a) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        assert list(iter(a)) == [b\"h\", b\"e\", b\"l\", b\"l\", b\"o\", b\"\\0\"]\n        #\n        pytest.raises(TypeError, iter, ffi.cast(\"char *\", a))\n        pytest.raises(TypeError, list, ffi.cast(\"char *\", a))\n        pytest.raises(TypeError, iter, ffi.new(\"int *\"))\n        pytest.raises(TypeError, list, ffi.new(\"int *\"))\n\n    def test_offsetof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b, c; };\")\n        assert ffi.offsetof(\"struct foo\", \"a\") == 0\n        assert ffi.offsetof(\"struct foo\", \"b\") == 4\n        assert ffi.offsetof(\"struct foo\", \"c\") == 8\n\n    def test_offsetof_nested(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a, b, c; };\"\n                 \"struct bar { struct foo d, e; };\")\n        assert ffi.offsetof(\"struct bar\", \"e\") == 12\n        pytest.raises(KeyError, ffi.offsetof, \"struct bar\", \"e.a\")\n        assert ffi.offsetof(\"struct bar\", \"e\", \"a\") == 12\n        assert ffi.offsetof(\"struct bar\", \"e\", \"b\") == 16\n        assert ffi.offsetof(\"struct bar\", \"e\", \"c\") == 20\n\n    def test_offsetof_array(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.offsetof(\"int[]\", 51) == 51 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"int *\", 51) == 51 * ffi.sizeof(\"int\")\n        ffi.cdef(\"struct bar { int a, b; int c[99]; };\")\n        assert ffi.offsetof(\"struct bar\", \"c\") == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct bar\", \"c\", 0) == 2 * ffi.sizeof(\"int\")\n        assert ffi.offsetof(\"struct bar\", \"c\", 51) == 53 * ffi.sizeof(\"int\")\n\n    def test_alignof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { char a; short b; char c; };\")\n        assert ffi.alignof(\"int\") == 4\n        assert ffi.alignof(\"double\") in (4, 8)\n        assert ffi.alignof(\"struct foo\") == 2\n\n    def test_bitfield(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo { int a:10, b:20, c:3; };\")\n        assert ffi.sizeof(\"struct foo\") == 8\n        s = ffi.new(\"struct foo *\")\n        s.a = 511\n        with pytest.raises(OverflowError):\n            s.a = 512\n        with pytest.raises(OverflowError):\n            s[0].a = 512\n        assert s.a == 511\n        s.a = -512\n        with pytest.raises(OverflowError):\n            s.a = -513\n        with pytest.raises(OverflowError):\n            s[0].a = -513\n        assert s.a == -512\n        s.c = 3\n        assert s.c == 3\n        with pytest.raises(OverflowError):\n            s.c = 4\n        with pytest.raises(OverflowError):\n            s[0].c = 4\n        s.c = -4\n        assert s.c == -4\n\n    def test_bitfield_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef enum { AA, BB, CC } foo_e;\n            typedef struct { foo_e f:2; } foo_s;\n        \"\"\")\n        s = ffi.new(\"foo_s *\")\n        s.f = 2\n        assert s.f == 2\n\n    def test_anonymous_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef struct { int a; } foo_t;\")\n        ffi.cdef(\"typedef struct { char b, c; } bar_t;\")\n        f = ffi.new(\"foo_t *\", [12345])\n        b = ffi.new(\"bar_t *\", [b\"B\", b\"C\"])\n        assert f.a == 12345\n        assert b.b == b\"B\"\n        assert b.c == b\"C\"\n        assert repr(b).startswith(\"<cdata 'bar_t *'\")\n\n    def test_struct_with_two_usages(self):\n        for name in ['foo_s', '']:    # anonymous or not\n            ffi = FFI(backend=self.Backend())\n            ffi.cdef(\"typedef struct %s { int a; } foo_t, *foo_p;\" % name)\n            f = ffi.new(\"foo_t *\", [12345])\n            ps = ffi.new(\"foo_p[]\", [f])\n\n    def test_pointer_arithmetic(self):\n        ffi = FFI(backend=self.Backend())\n        s = ffi.new(\"short[]\", list(range(100, 110)))\n        p = ffi.cast(\"short *\", s)\n        assert p[2] == 102\n        assert p+1 == p+1\n        assert p+1 != p+0\n        assert p == p+0 == p-0\n        assert (p+1)[0] == 101\n        assert (p+19)[-10] == 109\n        assert (p+5) - (p+1) == 4\n        assert p == s+0\n        assert p+1 == s+1\n\n    def test_pointer_comparison(self):\n        ffi = FFI(backend=self.Backend())\n        s = ffi.new(\"short[]\", list(range(100)))\n        p = ffi.cast(\"short *\", s)\n        assert (p <  s) is False\n        assert (p <= s) is True\n        assert (p == s) is True\n        assert (p != s) is False\n        assert (p >  s) is False\n        assert (p >= s) is True\n        assert (s <  p) is False\n        assert (s <= p) is True\n        assert (s == p) is True\n        assert (s != p) is False\n        assert (s >  p) is False\n        assert (s >= p) is True\n        q = p + 1\n        assert (q <  s) is False\n        assert (q <= s) is False\n        assert (q == s) is False\n        assert (q != s) is True\n        assert (q >  s) is True\n        assert (q >= s) is True\n        assert (s <  q) is True\n        assert (s <= q) is True\n        assert (s == q) is False\n        assert (s != q) is True\n        assert (s >  q) is False\n        assert (s >= q) is False\n        assert (q <  p) is False\n        assert (q <= p) is False\n        assert (q == p) is False\n        assert (q != p) is True\n        assert (q >  p) is True\n        assert (q >= p) is True\n        assert (p <  q) is True\n        assert (p <= q) is True\n        assert (p == q) is False\n        assert (p != q) is True\n        assert (p >  q) is False\n        assert (p >= q) is False\n        #\n        assert (None == s) is False\n        assert (None != s) is True\n        assert (s == None) is False\n        assert (s != None) is True\n        assert (None == q) is False\n        assert (None != q) is True\n        assert (q == None) is False\n        assert (q != None) is True\n\n    def test_integer_comparison(self):\n        ffi = FFI(backend=self.Backend())\n        x = ffi.cast(\"int\", 123)\n        y = ffi.cast(\"int\", 456)\n        assert x < y\n        #\n        z = ffi.cast(\"double\", 78.9)\n        assert x > z\n        assert y > z\n\n    def test_ffi_buffer_ptr(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short *\", 100)\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        assert type(b) is ffi.buffer\n        content = b[:]\n        assert len(content) == len(b) == 2\n        if sys.byteorder == 'little':\n            assert content == b'\\x64\\x00'\n            assert b[0] == b'\\x64'\n            b[0] = b'\\x65'\n        else:\n            assert content == b'\\x00\\x64'\n            assert b[1] == b'\\x64'\n            b[1] = b'\\x65'\n        assert a[0] == 101\n\n    def test_ffi_buffer_array(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"int[]\", list(range(100, 110)))\n        try:\n            b = ffi.buffer(a)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        content = b[:]\n        if sys.byteorder == 'little':\n            assert content.startswith(b'\\x64\\x00\\x00\\x00\\x65\\x00\\x00\\x00')\n            b[4] = b'\\x45'\n        else:\n            assert content.startswith(b'\\x00\\x00\\x00\\x64\\x00\\x00\\x00\\x65')\n            b[7] = b'\\x45'\n        assert len(content) == 4 * 10\n        assert a[1] == 0x45\n\n    def test_ffi_buffer_ptr_size(self):\n        ffi = FFI(backend=self.Backend())\n        a = ffi.new(\"short *\", 0x4243)\n        try:\n            b = ffi.buffer(a, 1)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        content = b[:]\n        assert len(content) == 1\n        if sys.byteorder == 'little':\n            assert content == b'\\x43'\n            b[0] = b'\\x62'\n            assert a[0] == 0x4262\n        else:\n            assert content == b'\\x42'\n            b[0] = b'\\x63'\n            assert a[0] == 0x6343\n\n    def test_ffi_buffer_array_size(self):\n        ffi = FFI(backend=self.Backend())\n        a1 = ffi.new(\"int[]\", list(range(100, 110)))\n        a2 = ffi.new(\"int[]\", list(range(100, 115)))\n        try:\n            ffi.buffer(a1)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        assert ffi.buffer(a1)[:] == ffi.buffer(a2, 4*10)[:]\n\n    def test_ffi_buffer_with_file(self):\n        ffi = FFI(backend=self.Backend())\n        import tempfile, os, array\n        fd, filename = tempfile.mkstemp()\n        f = os.fdopen(fd, 'r+b')\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == arraytostring(array.array('i', range(1000)))\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n        os.unlink(filename)\n\n    def test_ffi_buffer_with_io(self):\n        ffi = FFI(backend=self.Backend())\n        import io, array\n        f = io.BytesIO()\n        a = ffi.new(\"int[]\", list(range(1005)))\n        try:\n            ffi.buffer(a, 512)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        f.write(ffi.buffer(a, 1000 * ffi.sizeof(\"int\")))\n        f.seek(0)\n        assert f.read() == arraytostring(array.array('i', range(1000)))\n        f.seek(0)\n        b = ffi.new(\"int[]\", 1005)\n        f.readinto(ffi.buffer(b, 1000 * ffi.sizeof(\"int\")))\n        assert list(a)[:1000] + [0] * (len(a)-1000) == list(b)\n        f.close()\n\n    def test_ffi_buffer_comparisons(self):\n        ffi = FFI(backend=self.Backend())\n        ba = bytearray(range(100, 110))\n        if sys.version_info >= (2, 7):\n            assert ba == memoryview(ba)    # justification for the following\n        a = ffi.new(\"uint8_t[]\", list(ba))\n        c = ffi.new(\"uint8_t[]\", [99] + list(ba))\n        try:\n            b_full = ffi.buffer(a)\n            b_short = ffi.buffer(a, 3)\n            b_mid = ffi.buffer(a, 6)\n            b_other = ffi.buffer(c, 6)\n        except NotImplementedError as e:\n            pytest.skip(str(e))\n        else:\n            content = b_full[:]\n            assert content == b_full == ba\n            assert b_other < b_short < b_mid < b_full\n            assert ba > b_mid > ba[0:2]\n            assert b_short != ba[1:4]\n\n    def test_array_in_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[5]; };\")\n        p = ffi.new(\"struct foo_s *\")\n        p.data[3] = 5\n        assert p.data[3] == 5\n        assert repr(p.data).startswith(\"<cdata 'short[5]' 0x\")\n\n    def test_struct_containing_array_varsize_workaround(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[0]; };\")\n        p = ffi.new(\"char[]\", ffi.sizeof(\"struct foo_s\") + 7 * SIZE_OF_SHORT)\n        q = ffi.cast(\"struct foo_s *\", p)\n        assert q.len == 0\n        # 'q.data' gets not a 'short[0]', but just a 'short *' instead\n        assert repr(q.data).startswith(\"<cdata 'short *' 0x\")\n        assert q.data[6] == 0\n        q.data[6] = 15\n        assert q.data[6] == 15\n\n    def test_new_struct_containing_array_varsize(self):\n        pytest.skip(\"later?\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int len; short data[]; };\")\n        p = ffi.new(\"struct foo_s *\", 10)     # a single integer is the length\n        assert p.len == 0\n        assert p.data[9] == 0\n        with pytest.raises(IndexError):\n            p.data[10]\n\n    def test_ffi_typeof_getcname(self):\n        ffi = FFI(backend=self.Backend())\n        assert ffi.getctype(\"int\") == \"int\"\n        assert ffi.getctype(\"int\", 'x') == \"int x\"\n        assert ffi.getctype(\"int*\") == \"int *\"\n        assert ffi.getctype(\"int*\", '') == \"int *\"\n        assert ffi.getctype(\"int*\", 'x') == \"int * x\"\n        assert ffi.getctype(\"int\", '*') == \"int *\"\n        assert ffi.getctype(\"int\", ' * x ') == \"int * x\"\n        assert ffi.getctype(ffi.typeof(\"int*\"), '*') == \"int * *\"\n        assert ffi.getctype(\"int\", '[5]') == \"int[5]\"\n        assert ffi.getctype(\"int[5]\", '[6]') == \"int[6][5]\"\n        assert ffi.getctype(\"int[5]\", '(*)') == \"int(*)[5]\"\n        # special-case for convenience: automatically put '()' around '*'\n        assert ffi.getctype(\"int[5]\", '*') == \"int(*)[5]\"\n        assert ffi.getctype(\"int[5]\", '*foo') == \"int(*foo)[5]\"\n        assert ffi.getctype(\"int[5]\", ' ** foo ') == \"int(** foo)[5]\"\n\n    def test_array_of_func_ptr(self):\n        ffi = FFI(backend=self.Backend())\n        f = ffi.cast(\"int(*)(int)\", 42)\n        assert f != ffi.NULL\n        pytest.raises(CDefError, ffi.cast, \"int(int)\", 42)\n        pytest.raises(CDefError, ffi.new, \"int([5])(int)\")\n        a = ffi.new(\"int(*[5])(int)\", [f])\n        assert ffi.getctype(ffi.typeof(a)) == \"int(*[5])(int)\"\n        assert len(a) == 5\n        assert a[0] == f\n        assert a[1] == ffi.NULL\n        pytest.raises(TypeError, ffi.cast, \"int(*)(int)[5]\", 0)\n        #\n        def cb(n):\n            return n + 1\n        f = ffi.callback(\"int(*)(int)\", cb)\n        a = ffi.new(\"int(*[5])(int)\", [f, f])\n        assert a[1](42) == 43\n\n    def test_callback_as_function_argument(self):\n        # In C, function arguments can be declared with a function type,\n        # which is automatically replaced with the ptr-to-function type.\n        ffi = FFI(backend=self.Backend())\n        def cb(a, b):\n            return chr(ord(a) + ord(b)).encode()\n        f = ffi.callback(\"char cb(char, char)\", cb)\n        assert f(b'A', b'\\x01') == b'B'\n        def g(callback):\n            return callback(b'A', b'\\x01')\n        g = ffi.callback(\"char g(char cb(char, char))\", g)\n        assert g(f) == b'B'\n\n    def test_vararg_callback(self):\n        pytest.skip(\"callback with '...'\")\n        ffi = FFI(backend=self.Backend())\n        def cb(i, va_list):\n            j = ffi.va_arg(va_list, \"int\")\n            k = ffi.va_arg(va_list, \"long long\")\n            return i * 2 + j * 3 + k * 5\n        f = ffi.callback(\"long long cb(long i, ...)\", cb)\n        res = f(10, ffi.cast(\"int\", 100), ffi.cast(\"long long\", 1000))\n        assert res == 20 + 300 + 5000\n\n    def test_callback_decorator(self):\n        ffi = FFI(backend=self.Backend())\n        #\n        @ffi.callback(\"long(long, long)\", error=42)\n        def cb(a, b):\n            return a - b\n        #\n        assert cb(-100, -10) == -90\n        sz = ffi.sizeof(\"long\")\n        assert cb((1 << (sz*8-1)) - 1, -10) == 42\n\n    def test_unique_types(self):\n        ffi1 = FFI(backend=self.Backend())\n        ffi2 = FFI(backend=self.Backend())\n        assert ffi1.typeof(\"char\") is ffi2.typeof(\"char \")\n        assert ffi1.typeof(\"long\") is ffi2.typeof(\"signed long int\")\n        assert ffi1.typeof(\"double *\") is ffi2.typeof(\"double*\")\n        assert ffi1.typeof(\"int ***\") is ffi2.typeof(\" int * * *\")\n        assert ffi1.typeof(\"int[]\") is ffi2.typeof(\"signed int[]\")\n        assert ffi1.typeof(\"signed int*[17]\") is ffi2.typeof(\"int *[17]\")\n        assert ffi1.typeof(\"void\") is ffi2.typeof(\"void\")\n        assert ffi1.typeof(\"int(*)(int,int)\") is ffi2.typeof(\"int(*)(int,int)\")\n        #\n        # these depend on user-defined data, so should not be shared\n        assert ffi1.typeof(\"struct foo\") is not ffi2.typeof(\"struct foo\")\n        assert ffi1.typeof(\"union foo *\") is not ffi2.typeof(\"union foo*\")\n        # the following test is an opaque enum, which we no longer support\n        #assert ffi1.typeof(\"enum foo\") is not ffi2.typeof(\"enum foo\")\n        # sanity check: twice 'ffi1'\n        assert ffi1.typeof(\"struct foo*\") is ffi1.typeof(\"struct foo *\")\n\n    def test_anonymous_enum(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef enum { Value0 = 0 } e, *pe;\\n\"\n                 \"typedef enum { Value1 = 1 } e1;\")\n        assert ffi.getctype(\"e*\") == 'e *'\n        assert ffi.getctype(\"pe\") == 'e *'\n        assert ffi.getctype(\"e1*\") == 'e1 *'\n\n    def test_opaque_enum(self):\n        import warnings\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum foo;\")\n        with warnings.catch_warnings(record=True) as log:\n            warnings.simplefilter(\"always\")\n            n = ffi.cast(\"enum foo\", -1)\n            assert int(n) == 0xffffffff\n        assert str(log[0].message) == (\n            \"'enum foo' has no values explicitly defined; \"\n            \"guessing that it is equivalent to 'unsigned int'\")\n\n    def test_new_ctype(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\")\n        pytest.raises(TypeError, ffi.new, p)\n        p = ffi.new(ffi.typeof(\"int *\"), 42)\n        assert p[0] == 42\n\n    def test_enum_with_non_injective_mapping(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum e { AA=0, BB=0, CC=0, DD=0 };\")\n        e = ffi.cast(\"enum e\", 0)\n        assert ffi.string(e) == \"AA\"     # pick the first one arbitrarily\n\n    def test_enum_refer_previous_enum_value(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"enum e { AA, BB=2, CC=4, DD=BB, EE, FF=CC, GG=FF };\")\n        assert ffi.string(ffi.cast(\"enum e\", 2)) == \"BB\"\n        assert ffi.string(ffi.cast(\"enum e\", 3)) == \"EE\"\n        assert ffi.sizeof(\"char[DD]\") == 2\n        assert ffi.sizeof(\"char[EE]\") == 3\n        assert ffi.sizeof(\"char[FF]\") == 4\n        assert ffi.sizeof(\"char[GG]\") == 4\n\n    def test_nested_anonymous_struct(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct { int a, b; };\n                union { int c, d; };\n            };\n        \"\"\")\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n        p = ffi.new(\"struct foo_s *\", [1, 2, 3])\n        assert p.a == 1\n        assert p.b == 2\n        assert p.c == 3\n        assert p.d == 3\n        p.d = 17\n        assert p.c == 17\n        p.b = 19\n        assert p.a == 1\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"struct foo_s *\", {'b': 12, 'd': 14})\n        assert p.a == 0\n        assert p.b == 12\n        assert p.c == 14\n        assert p.d == 14\n        pytest.raises(ValueError, ffi.new, \"struct foo_s *\", [0, 0, 0, 0])\n\n    def test_nested_field_offset_align(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct { int a; char b; };\n                union { char c; };\n            };\n        \"\"\")\n        assert ffi.offsetof(\"struct foo_s\", \"c\") == 2 * SIZE_OF_INT\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n\n    def test_nested_anonymous_union(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            union foo_u {\n                struct { int a, b; };\n                union { int c, d; };\n            };\n        \"\"\")\n        assert ffi.sizeof(\"union foo_u\") == 2 * SIZE_OF_INT\n        p = ffi.new(\"union foo_u *\", [5])\n        assert p.a == 5\n        assert p.b == 0\n        assert p.c == 5\n        assert p.d == 5\n        p.d = 17\n        assert p.c == 17\n        assert p.a == 17\n        p.b = 19\n        assert p.a == 17\n        assert p.b == 19\n        assert p.c == 17\n        assert p.d == 17\n        p = ffi.new(\"union foo_u *\", {'d': 14})\n        assert p.a == 14\n        assert p.b == 0\n        assert p.c == 14\n        assert p.d == 14\n        p = ffi.new(\"union foo_u *\", {'a': -63, 'b': 12})\n        assert p.a == -63\n        assert p.b == 12\n        assert p.c == -63\n        assert p.d == -63\n        p = ffi.new(\"union foo_u *\", [123, 456])\n        assert p.a == 123\n        assert p.b == 456\n        assert p.c == 123\n        assert p.d == 123\n        pytest.raises(ValueError, ffi.new, \"union foo_u *\", [0, 0, 0])\n\n    def test_nested_anonymous_struct_2(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                int a;\n                union { int b; union { int c, d; }; };\n                int e;\n            };\n        \"\"\")\n        assert ffi.sizeof(\"struct foo_s\") == 3 * SIZE_OF_INT\n        p = ffi.new(\"struct foo_s *\", [11, 22, 33])\n        assert p.a == 11\n        assert p.b == p.c == p.d == 22\n        assert p.e == 33\n        pytest.raises(ValueError, ffi.new, \"struct foo_s *\", [11, 22, 33, 44])\n        FOO = ffi.typeof(\"struct foo_s\")\n        fields = [(name, fld.offset, fld.flags) for (name, fld) in FOO.fields]\n        assert fields == [\n            ('a', 0 * SIZE_OF_INT, 0),\n            ('b', 1 * SIZE_OF_INT, 0),\n            ('c', 1 * SIZE_OF_INT, 1),\n            ('d', 1 * SIZE_OF_INT, 1),\n            ('e', 2 * SIZE_OF_INT, 0),\n        ]\n\n    def test_cast_to_array_type(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[4]\", [-5])\n        q = ffi.cast(\"int[3]\", p)\n        assert q[0] == -5\n        assert repr(q).startswith(\"<cdata 'int[3]' 0x\")\n\n    def test_gc(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        def destructor(p1):\n            assert p1 is p\n            assert p1[0] == 123\n            seen.append(1)\n        q = ffi.gc(p, destructor)\n        assert ffi.typeof(q) is ffi.typeof(p)\n        import gc; gc.collect()\n        assert seen == []\n        del q\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [1]\n\n    def test_gc_2(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q2\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [2, 1]\n\n    def test_gc_3(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        r = ffi.new(\"int *\", 123)\n        seen = []\n        seen_r = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        s1 = ffi.gc(r, lambda r: seen_r.append(4))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        s2 = ffi.gc(s1, lambda r: seen_r.append(5))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        assert seen_r == []\n        del q1, q2, q3, s2, s1\n        import gc; gc.collect(); gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3, 2, 1]\n        assert seen_r == [5, 4]\n\n    def test_gc_4(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        q3 = ffi.gc(q2, lambda p: seen.append(3))\n        import gc; gc.collect()\n        assert seen == []\n        del q1, q3     # q2 remains, and has a hard ref to q1\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [3]\n\n    def test_gc_disable(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        pytest.raises(TypeError, ffi.gc, p, None)\n        seen = []\n        q1 = ffi.gc(p, lambda p: seen.append(1))\n        q2 = ffi.gc(q1, lambda p: seen.append(2))\n        import gc; gc.collect()\n        assert seen == []\n        assert ffi.gc(q1, None) is None\n        del q1, q2\n        import gc; gc.collect(); gc.collect(); gc.collect()\n        assert seen == [2]\n\n    def test_gc_finite_list(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int *\", 123)\n        keepalive = []\n        for i in range(10):\n            keepalive.append(ffi.gc(p, lambda p: None))\n        del keepalive[:]\n        import gc; gc.collect(); gc.collect()\n        for i in range(10):\n            keepalive.append(ffi.gc(p, lambda p: None))\n\n    def test_CData_CType(self):\n        ffi = FFI(backend=self.Backend())\n        assert isinstance(ffi.cast(\"int\", 0), ffi.CData)\n        assert isinstance(ffi.new(\"int *\"), ffi.CData)\n        assert not isinstance(ffi.typeof(\"int\"), ffi.CData)\n        assert not isinstance(ffi.cast(\"int\", 0), ffi.CType)\n        assert not isinstance(ffi.new(\"int *\"), ffi.CType)\n\n    def test_CData_CType_2(self):\n        ffi = FFI(backend=self.Backend())\n        assert isinstance(ffi.typeof(\"int\"), ffi.CType)\n\n    def test_bool(self):\n        ffi = FFI(backend=self.Backend())\n        assert int(ffi.cast(\"_Bool\", 0.1)) == 1\n        assert int(ffi.cast(\"_Bool\", -0.0)) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x02')) == 1\n        assert int(ffi.cast(\"_Bool\", b'\\x00')) == 0\n        assert int(ffi.cast(\"_Bool\", b'\\x80')) == 1\n        assert ffi.new(\"_Bool *\", False)[0] == 0\n        assert ffi.new(\"_Bool *\", 1)[0] == 1\n        pytest.raises(OverflowError, ffi.new, \"_Bool *\", 2)\n        pytest.raises(TypeError, ffi.string, ffi.cast(\"_Bool\", 2))\n\n    def test_use_own_bool(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"typedef int bool;\"\"\")\n\n    def test_ordering_bug1(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct foo_s {\n                struct bar_s *p;\n            };\n            struct bar_s {\n                struct foo_s foo;\n            };\n        \"\"\")\n        q = ffi.new(\"struct foo_s *\")\n        bar = ffi.new(\"struct bar_s *\")\n        q.p = bar\n        assert q.p.foo.p == ffi.NULL\n\n    def test_ordering_bug2(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct bar_s;\n\n            struct foo_s {\n                void (*foo)(struct bar_s[]);\n            };\n\n            struct bar_s {\n                struct foo_s foo;\n            };\n        \"\"\")\n        q = ffi.new(\"struct foo_s *\")\n\n    def test_addressof(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\")\n        p = ffi.new(\"struct foo_s *\")\n        a = ffi.addressof(p[0])\n        assert repr(a).startswith(\"<cdata 'struct foo_s *' 0x\")\n        assert a == p\n        pytest.raises(TypeError, ffi.addressof, p)\n        pytest.raises((AttributeError, TypeError), ffi.addressof, 5)\n        pytest.raises(TypeError, ffi.addressof, ffi.cast(\"int\", 5))\n\n    def test_addressof_field(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\")\n        p = ffi.new(\"struct foo_s *\")\n        a = ffi.addressof(p[0], 'y')\n        assert repr(a).startswith(\"<cdata 'int *' 0x\")\n        assert int(ffi.cast(\"uintptr_t\", a)) == (\n            int(ffi.cast(\"uintptr_t\", p)) + ffi.sizeof(\"int\"))\n        assert a == ffi.addressof(p, 'y')\n        assert a != ffi.addressof(p, 'x')\n\n    def test_addressof_field_nested(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s { int x, y; };\"\n                 \"struct bar_s { struct foo_s a, b; };\")\n        p = ffi.new(\"struct bar_s *\")\n        pytest.raises(KeyError, ffi.addressof, p[0], 'b.y')\n        a = ffi.addressof(p[0], 'b', 'y')\n        assert int(ffi.cast(\"uintptr_t\", a)) == (\n            int(ffi.cast(\"uintptr_t\", p)) +\n            ffi.sizeof(\"struct foo_s\") + ffi.sizeof(\"int\"))\n\n    def test_addressof_anonymous_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"typedef struct { int x; } foo_t;\")\n        p = ffi.new(\"foo_t *\")\n        a = ffi.addressof(p[0])\n        assert a == p\n\n    def test_addressof_array(self):\n        ffi = FFI()\n        p = ffi.new(\"int[52]\")\n        p0 = ffi.addressof(p)\n        assert p0 == p\n        assert ffi.typeof(p0) is ffi.typeof(\"int(*)[52]\")\n        pytest.raises(TypeError, ffi.addressof, p0)\n        #\n        p1 = ffi.addressof(p, 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert (p1 - p) == 25\n        assert ffi.addressof(p, 0) == p\n\n    def test_addressof_pointer(self):\n        ffi = FFI()\n        array = ffi.new(\"int[50]\")\n        p = ffi.cast(\"int *\", array)\n        pytest.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n        #\n        ffi.cdef(\"struct foo { int a, b; };\")\n        array = ffi.new(\"struct foo[50]\")\n        p = ffi.cast(\"int *\", array)\n        pytest.raises(TypeError, ffi.addressof, p)\n        assert ffi.addressof(p, 0) == p\n        assert ffi.addressof(p, 25) == p + 25\n        assert ffi.typeof(ffi.addressof(p, 25)) == ffi.typeof(p)\n\n    def test_addressof_array_in_struct(self):\n        ffi = FFI()\n        ffi.cdef(\"struct foo { int a, b; int c[50]; };\")\n        p = ffi.new(\"struct foo *\")\n        p1 = ffi.addressof(p, \"c\", 25)\n        assert ffi.typeof(p1) is ffi.typeof(\"int *\")\n        assert p1 == ffi.cast(\"int *\", p) + 27\n        assert ffi.addressof(p, \"c\") == ffi.cast(\"int *\", p) + 2\n        assert ffi.addressof(p, \"c\", 0) == ffi.cast(\"int *\", p) + 2\n        p2 = ffi.addressof(p, 1)\n        assert ffi.typeof(p2) is ffi.typeof(\"struct foo *\")\n        assert p2 == p + 1\n\n    def test_multiple_independent_structs(self):\n        ffi1 = FFI(); ffi1.cdef(\"struct foo { int x; };\")\n        ffi2 = FFI(); ffi2.cdef(\"struct foo { int y, z; };\")\n        foo1 = ffi1.new(\"struct foo *\", [10])\n        foo2 = ffi2.new(\"struct foo *\", [20, 30])\n        assert foo1.x == 10\n        assert foo2.y == 20\n        assert foo2.z == 30\n\n    def test_missing_include(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef signed char schar_t;\")\n        pytest.raises(CDefError, ffi2.cast, \"schar_t\", 142)\n\n    def test_include_typedef(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef signed char schar_t;\")\n        ffi2.include(ffi1)\n        p = ffi2.cast(\"schar_t\", 142)\n        assert int(p) == 142 - 256\n\n    def test_include_struct(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"struct foo { int x; };\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"struct foo *\", [142])\n        assert p.x == 142\n\n    def test_include_union(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"union foo { int x; };\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"union foo *\", [142])\n        assert p.x == 142\n\n    def test_include_enum(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"enum foo { FA, FB, FC };\")\n        ffi2.include(ffi1)\n        p = ffi2.cast(\"enum foo\", 1)\n        assert ffi2.string(p) == \"FB\"\n        assert ffi2.sizeof(\"char[FC]\") == 2\n\n    def test_include_typedef_2(self):\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi2 = FFI(backend=backend)\n        ffi1.cdef(\"typedef struct { int x; } *foo_p;\")\n        ffi2.include(ffi1)\n        p = ffi2.new(\"foo_p\", [142])\n        assert p.x == 142\n\n    def test_ignore_multiple_declarations_of_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"#define FOO 42\")\n        ffi.cdef(\"#define FOO 42\")\n        pytest.raises(FFIError, ffi.cdef, \"#define FOO 43\")\n\n    def test_struct_packed(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct nonpacked { char a; int b; };\")\n        ffi.cdef(\"struct is_packed { char a; int b; };\", packed=True)\n        ffi.cdef(\"struct is_packed1 { char a; int b; };\", pack=1)\n        ffi.cdef(\"struct is_packed2 { char a; int b; };\", pack=2)\n        ffi.cdef(\"struct is_packed4 { char a; int b; };\", pack=4)\n        ffi.cdef(\"struct is_packed8 { char a; int b; };\", pack=8)\n        assert ffi.sizeof(\"struct nonpacked\") == 8\n        assert ffi.sizeof(\"struct is_packed\") == 5\n        assert ffi.sizeof(\"struct is_packed1\") == 5\n        assert ffi.sizeof(\"struct is_packed2\") == 6\n        assert ffi.sizeof(\"struct is_packed4\") == 8\n        assert ffi.sizeof(\"struct is_packed8\") == 8\n        assert ffi.alignof(\"struct nonpacked\") == 4\n        assert ffi.alignof(\"struct is_packed\") == 1\n        assert ffi.alignof(\"struct is_packed1\") == 1\n        assert ffi.alignof(\"struct is_packed2\") == 2\n        assert ffi.alignof(\"struct is_packed4\") == 4\n        assert ffi.alignof(\"struct is_packed8\") == 4\n        for name in ['is_packed', 'is_packed1', 'is_packed2',\n                     'is_packed4', 'is_packed8']:\n            s = ffi.new(\"struct %s[2]\" % name)\n            s[0].b = 42623381\n            s[0].a = b'X'\n            s[1].b = -4892220\n            s[1].a = b'Y'\n            assert s[0].b == 42623381\n            assert s[0].a == b'X'\n            assert s[1].b == -4892220\n            assert s[1].a == b'Y'\n\n    def test_pack_valueerror(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(ValueError, ffi.cdef, \"\", pack=3)\n        pytest.raises(ValueError, ffi.cdef, \"\", packed=2)\n        pytest.raises(ValueError, ffi.cdef, \"\", packed=True, pack=1)\n\n    def test_define_integer_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            #define DOT_0 0\n            #define DOT 100\n            #define DOT_OCT 0100l\n            #define DOT_HEX 0x100u\n            #define DOT_HEX2 0X10\n            #define DOT_UL 1000UL\n            enum foo {AA, BB=DOT, CC};\n        \"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert ffi.string(ffi.cast(\"enum foo\", 100)) == \"BB\"\n        assert lib.DOT_0 == 0\n        assert lib.DOT == 100\n        assert lib.DOT_OCT == 0o100\n        assert lib.DOT_HEX == 0x100\n        assert lib.DOT_HEX2 == 0x10\n        assert lib.DOT_UL == 1000\n\n    def test_opaque_struct_becomes_nonopaque(self):\n        # Issue #193: if we use a struct between the first cdef() where it is\n        # declared and another cdef() where its fields are defined, then the\n        # definition was ignored.\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"struct foo_s;\")\n        pytest.raises(TypeError, ffi.new, \"struct foo_s *\")\n        ffi.cdef(\"struct foo_s { int x; };\")\n        ffi.new(\"struct foo_s *\")\n\n    def test_ffi_self_include(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(ValueError, ffi.include, ffi)\n\n    def test_anonymous_enum_include(self):\n        ffi1 = FFI()\n        ffi1.cdef(\"enum { EE1 };\")\n        ffi = FFI()\n        ffi.include(ffi1)\n        ffi.cdef(\"enum { EE2, EE3 };\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert lib.EE1 == 0\n        assert lib.EE2 == 0\n        assert lib.EE3 == 1\n\n    def test_init_once(self):\n        def do_init():\n            seen.append(1)\n            return 42\n        ffi = FFI()\n        seen = []\n        for i in range(3):\n            res = ffi.init_once(do_init, \"tag1\")\n            assert res == 42\n            assert seen == [1]\n        for i in range(3):\n            res = ffi.init_once(do_init, \"tag2\")\n            assert res == 42\n            assert seen == [1, 1]\n\n    def test_init_once_multithread(self):\n        import sys, time\n        if sys.version_info < (3,):\n            import thread\n        else:\n            import _thread as thread\n        #\n        def do_init():\n            seen.append('init!')\n            time.sleep(1)\n            seen.append('init done')\n            return 7\n        ffi = FFI()\n        seen = []\n        for i in range(6):\n            def f():\n                res = ffi.init_once(do_init, \"tag\")\n                seen.append(res)\n            thread.start_new_thread(f, ())\n        time.sleep(1.5)\n        assert seen == ['init!', 'init done'] + 6 * [7]\n\n    def test_sizeof_struct_directly(self):\n        # only works with the Python FFI instances\n        ffi = FFI(backend=self.Backend())\n        assert ffi.sizeof(\"struct{int a;}\") == ffi.sizeof(\"int\")\n\n    def test_callback_large_struct(self):\n        ffi = FFI(backend=self.Backend())\n        # more than 8 bytes\n        ffi.cdef(\"struct foo_s { unsigned long a, b, c; };\")\n        #\n        @ffi.callback(\"void(struct foo_s)\")\n        def cb(s):\n            seen.append(ffi.typeof(s))\n            s.a += 1\n            s.b += 2\n            s.c += 3\n            seen.append(s.a)\n            seen.append(s.b)\n            seen.append(s.c)\n        #\n        s1 = ffi.new(\"struct foo_s *\", {'a': 100, 'b': 200, 'c': 300})\n        seen = []\n        cb(s1[0])\n        assert len(seen) == 4\n        assert s1.a == 100     # unmodified\n        assert s1.b == 200\n        assert s1.c == 300\n        assert seen[0] == ffi.typeof(\"struct foo_s\")\n        assert seen[1] == 101\n        assert seen[2] == 202\n        assert seen[3] == 303\n\n    def test_ffi_array_as_init(self):\n        ffi = FFI(backend=self.Backend())\n        p = ffi.new(\"int[4]\", [10, 20, 30, 400])\n        q = ffi.new(\"int[4]\", p)\n        assert list(q) == [10, 20, 30, 400]\n        pytest.raises(TypeError, ffi.new, \"int[3]\", p)\n        pytest.raises(TypeError, ffi.new, \"int[5]\", p)\n        pytest.raises(TypeError, ffi.new, \"int16_t[4]\", p)\n        s = ffi.new(\"struct {int i[4];}*\", {'i': p})\n        assert list(s.i) == [10, 20, 30, 400]\n\n    def test_too_many_initializers(self):\n        ffi = FFI(backend=self.Backend())\n        pytest.raises(IndexError, ffi.new, \"int[4]\", [10, 20, 30, 40, 50])\n", "testing/cffi0/test_ctypes.py": "import sys\nimport pytest\nfrom testing.cffi0 import backend_tests\nfrom cffi.backend_ctypes import CTypesBackend\n\n\nclass TestCTypes(backend_tests.BackendTests):\n    # for individual tests see\n    # ====> backend_tests.py\n    \n    Backend = CTypesBackend\n    TypeRepr = \"<class 'ffi.CData<%s>'>\"\n\n    def test_array_of_func_ptr(self):\n        pytest.skip(\"ctypes backend: not supported: \"\n                     \"initializers for function pointers\")\n\n    def test_structptr_argument(self):\n        pytest.skip(\"ctypes backend: not supported: passing a list \"\n                     \"for a pointer argument\")\n\n    def test_array_argument_as_list(self):\n        pytest.skip(\"ctypes backend: not supported: passing a list \"\n                     \"for a pointer argument\")\n\n    def test_cast_to_array_type(self):\n        pytest.skip(\"ctypes backend: not supported: casting to array\")\n\n    def test_nested_anonymous_struct(self):\n        pytest.skip(\"ctypes backend: not supported: nested anonymous struct\")\n\n    def test_nested_field_offset_align(self):\n        pytest.skip(\"ctypes backend: not supported: nested anonymous struct\")\n\n    def test_nested_anonymous_union(self):\n        pytest.skip(\"ctypes backend: not supported: nested anonymous union\")\n\n    def test_nested_anonymous_struct_2(self):\n        pytest.skip(\"ctypes backend: not supported: nested anonymous union\")\n\n    def test_CData_CType_2(self):\n        if sys.version_info >= (3,):\n            pytest.skip(\"ctypes backend: not supported in Python 3: CType\")\n        backend_tests.BackendTests.test_CData_CType_2(self)\n", "testing/cffi0/test_unicode_literals.py": "#\n# ----------------------------------------------\n# WARNING, ALL LITERALS IN THIS FILE ARE UNICODE\n# ----------------------------------------------\n#\nfrom __future__ import unicode_literals\n#\n#\n#\nimport sys, math\nfrom cffi import FFI\nfrom testing.support import is_musl\n\n\nlib_m = \"m\"\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\nelif is_musl:\n    lib_m = 'c'\n\n\ndef test_cast():\n    ffi = FFI()\n    assert int(ffi.cast(\"int\", 3.14)) == 3        # unicode literal\n\ndef test_new():\n    ffi = FFI()\n    assert ffi.new(\"int[]\", [3, 4, 5])[2] == 5    # unicode literal\n\ndef test_typeof():\n    ffi = FFI()\n    tp = ffi.typeof(\"int[51]\")                    # unicode literal\n    assert tp.length == 51\n\ndef test_sizeof():\n    ffi = FFI()\n    assert ffi.sizeof(\"int[51]\") == 51 * 4        # unicode literal\n\ndef test_alignof():\n    ffi = FFI()\n    assert ffi.alignof(\"int[51]\") == 4            # unicode literal\n\ndef test_getctype():\n    ffi = FFI()\n    assert ffi.getctype(\"int**\") == \"int * *\"     # unicode literal\n    assert type(ffi.getctype(\"int**\")) is str\n\ndef test_cdef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int foo_t[50];\")            # unicode literal\n\ndef test_offsetof():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x, y; } foo_t;\")\n    assert ffi.offsetof(\"foo_t\", \"y\") == 4        # unicode literal\n\ndef test_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum foo_e { AA, BB, CC };\")        # unicode literal\n    x = ffi.cast(\"enum foo_e\", 1)\n    assert int(ffi.cast(\"int\", x)) == 1\n\ndef test_dlopen():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    m = ffi.dlopen(lib_m)                           # unicode literal\n    x = m.sin(1.23)\n    assert x == math.sin(1.23)\n\ndef test_verify():\n    ffi = FFI()\n    ffi.cdef(\"double test_verify_1(double x);\")   # unicode literal\n    lib = ffi.verify(\"double test_verify_1(double x) { return x * 42.0; }\")\n    assert lib.test_verify_1(-1.5) == -63.0\n\ndef test_callback():\n    ffi = FFI()\n    cb = ffi.callback(\"int(int)\",                 # unicode literal\n                      lambda x: x + 42)\n    assert cb(5) == 47\n", "testing/cffi0/test_platform.py": "import os\nfrom cffi.ffiplatform import maybe_relative_path, flatten\n\n\ndef test_not_absolute():\n    assert maybe_relative_path('foo/bar') == 'foo/bar'\n    assert maybe_relative_path('test_platform.py') == 'test_platform.py'\n\ndef test_different_absolute():\n    p = os.path.join('..', 'baz.py')\n    assert maybe_relative_path(p) == p\n\ndef test_absolute_mapping():\n    p = os.path.abspath('baz.py')\n    assert maybe_relative_path(p) == 'baz.py'\n    foobaz = os.path.join('foo', 'baz.py')\n    assert maybe_relative_path(os.path.abspath(foobaz)) == foobaz\n\ndef test_flatten():\n    assert flatten(\"foo\") == \"3sfoo\"\n    assert flatten(-10000000000000000000000000000) == \\\n           \"-10000000000000000000000000000i\"\n    assert flatten([4, 5]) == \"2l4i5i\"\n    assert flatten({4: 5}) == \"1d4i5i\"\n    assert flatten({\"foo\": (\"bar\", \"baaz\")}) == \"1d3sfoo2l3sbar4sbaaz\"\n", "testing/cffi0/__init__.py": "", "testing/cffi0/test_verify.py": "import re\nimport pytest\nimport sys, os, math, weakref\nfrom cffi import FFI, VerificationError, VerificationMissing, model, FFIError\nfrom testing.support import *\nfrom testing.support import extra_compile_args, is_musl\n\n# eliminate warning noise from common test modules that are repeatedly re-imported\npytestmark = [\n    pytest.mark.filterwarnings(\"ignore:reimporting:UserWarning\"),\n    #pytest.mark.filterwarnings(\"ignore:Deprecated:_DeprecatedConfig\")\n]\n\nlib_m = ['m']\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = ['msvcrt']\n    pass      # no obvious -Werror equivalent on MSVC\nelse:\n    class FFI(FFI):\n        def verify(self, *args, **kwds):\n            return super(FFI, self).verify(\n                *args, extra_compile_args=extra_compile_args, **kwds)\n\ndef setup_module():\n    import cffi.verifier\n    cffi.verifier.cleanup_tmpdir()\n    #\n    # check that no $ sign is produced in the C file; it used to be the\n    # case that anonymous enums would produce '$enum_$1', which was\n    # used as part of a function name.  GCC accepts such names, but it's\n    # apparently non-standard.\n    _r_comment = re.compile(r\"/\\*.*?\\*/|//.*?$\", re.DOTALL | re.MULTILINE)\n    _r_string = re.compile(r'\\\".*?\\\"')\n    def _write_source_and_check(self, file=None):\n        base_write_source(self, file)\n        if file is None:\n            f = open(self.sourcefilename)\n            data = f.read()\n            f.close()\n            data = _r_comment.sub(' ', data)\n            data = _r_string.sub('\"skipped\"', data)\n            assert '$' not in data\n    base_write_source = cffi.verifier.Verifier._write_source\n    cffi.verifier.Verifier._write_source = _write_source_and_check\n\n\ndef test_module_type():\n    import cffi.verifier\n    ffi = FFI()\n    lib = ffi.verify()\n    if hasattr(lib, '_cffi_python_module'):\n        print('verify got a PYTHON module')\n    if hasattr(lib, '_cffi_generic_module'):\n        print('verify got a GENERIC module')\n    expected_generic = (cffi.verifier._FORCE_GENERIC_ENGINE or\n                        '__pypy__' in sys.builtin_module_names)\n    assert hasattr(lib, '_cffi_python_module') == (not expected_generic)\n    assert hasattr(lib, '_cffi_generic_module') == expected_generic\n\ndef test_missing_function(ffi=None):\n    # uses the FFI hacked above with '-Werror'\n    if ffi is None:\n        ffi = FFI()\n    ffi.cdef(\"void some_completely_unknown_function();\")\n    try:\n        lib = ffi.verify()\n    except (VerificationError, OSError):\n        pass     # expected case: we get a VerificationError\n    else:\n        # but depending on compiler and loader details, maybe\n        # 'lib' could actually be imported but will fail if we\n        # actually try to call the unknown function...  Hard\n        # to test anything more.\n        pass\n\ndef test_missing_function_import_error():\n    # uses the original FFI that just gives a warning during compilation\n    import cffi\n    test_missing_function(ffi=cffi.FFI())\n\ndef test_simple_case():\n    ffi = FFI()\n    ffi.cdef(\"double sin(double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef _Wconversion(cdef, source, **kargs):\n    if sys.platform in ('win32', 'darwin'):\n        pytest.skip(\"needs GCC\")\n    if '-Wno-error=sign-conversion' in extra_compile_args:\n        pytest.skip(\"gcc 9.2.0 compiler bug exposed by Python 3.12+ prevents compilation with sign-conversion warnings-as-errors\")\n    ffi = FFI()\n    ffi.cdef(cdef)\n    pytest.raises(VerificationError, ffi.verify, source, **kargs)\n    extra_compile_args_orig = extra_compile_args[:]\n    extra_compile_args.remove('-Wconversion')\n    try:\n        lib = ffi.verify(source, **kargs)\n    finally:\n        extra_compile_args[:] = extra_compile_args_orig\n    return lib\n\ndef test_Wconversion_unsigned():\n    _Wconversion(\"unsigned foo(void);\",\n                 \"int foo(void) { return -1;}\")\n\ndef test_Wconversion_integer():\n    _Wconversion(\"short foo(void);\",\n                 \"long long foo(void) { return 1<<sizeof(short);}\")\n\ndef test_Wconversion_floating():\n    lib = _Wconversion(\"float sin(double);\",\n                       \"#include <math.h>\", libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_Wconversion_float2int():\n    _Wconversion(\"int sinf(float);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_Wconversion_double2int():\n    _Wconversion(\"int sin(double);\",\n                 \"#include <math.h>\", libraries=lib_m)\n\ndef test_rounding_1():\n    ffi = FFI()\n    ffi.cdef(\"double sinf(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sinf(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_rounding_2():\n    ffi = FFI()\n    ffi.cdef(\"double sin(float x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    res = lib.sin(1.23)\n    assert res != math.sin(1.23)     # not exact, because of double->float\n    assert abs(res - math.sin(1.23)) < 1E-5\n\ndef test_strlen_exact():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(const char *s);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_strlen_approximate():\n    lib = _Wconversion(\"int strlen(char *s);\",\n                       \"#include <string.h>\")\n    assert lib.strlen(b\"hi there!\") == 9\n\ndef test_return_approximate():\n    for typename in ['short', 'int', 'long', 'long long']:\n        ffi = FFI()\n        ffi.cdef(\"%s foo(signed char x);\" % typename)\n        lib = ffi.verify(\"signed char foo(signed char x) { return x;}\")\n        assert lib.foo(-128) == -128\n        assert lib.foo(+127) == +127\n\ndef test_strlen_array_of_char():\n    ffi = FFI()\n    ffi.cdef(\"size_t strlen(char[]);\")\n    lib = ffi.verify(\"#include <string.h>\")\n    assert lib.strlen(b\"hello\") == 5\n\ndef test_longdouble():\n    ffi = FFI()\n    ffi.cdef(\"long double sinl(long double x);\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    for input in [1.23,\n                  ffi.cast(\"double\", 1.23),\n                  ffi.cast(\"long double\", 1.23)]:\n        x = lib.sinl(input)\n        assert repr(x).startswith(\"<cdata 'long double'\")\n        assert (float(x) - math.sin(1.23)) < 1E-10\n\ndef test_longdouble_precision():\n    # Test that we don't loose any precision of 'long double' when\n    # passing through Python and CFFI.\n    ffi = FFI()\n    ffi.cdef(\"long double step1(long double x);\")\n    SAME_SIZE = ffi.sizeof(\"long double\") == ffi.sizeof(\"double\")\n    lib = ffi.verify(\"\"\"\n        long double step1(long double x)\n        {\n            return 4*x-x*x;\n        }\n    \"\"\")\n    def do(cast_to_double):\n        x = 0.9789\n        for i in range(10000):\n            x = lib.step1(x)\n            if cast_to_double:\n                x = float(x)\n        return float(x)\n\n    more_precise = do(False)\n    less_precise = do(True)\n    if SAME_SIZE:\n        assert more_precise == less_precise\n    else:\n        assert abs(more_precise - less_precise) > 0.1\n        # Check the particular results on Intel\n        import platform\n        if (platform.machine().startswith('i386') or\n            platform.machine().startswith('i486') or\n            platform.machine().startswith('i586') or\n            platform.machine().startswith('i686') or\n            platform.machine().startswith('x86')):\n            assert abs(more_precise - 0.656769) < 0.001\n            assert abs(less_precise - 3.99091) < 0.001\n        else:\n            pytest.skip(\"don't know the very exact precision of 'long double'\")\n\n\nall_primitive_types = model.PrimitiveType.ALL_PRIMITIVE_TYPES\nif sys.platform == 'win32':\n    all_primitive_types = all_primitive_types.copy()\n    del all_primitive_types['ssize_t']\nall_integer_types = sorted(tp for tp in all_primitive_types\n                           if all_primitive_types[tp] == 'i')\nall_float_types = sorted(tp for tp in all_primitive_types\n                            if all_primitive_types[tp] == 'f')\n\ndef all_signed_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) < 0]\n\ndef all_unsigned_integer_types(ffi):\n    return [x for x in all_integer_types if int(ffi.cast(x, -1)) > 0]\n\n\ndef test_primitive_category():\n    for typename in all_primitive_types:\n        tp = model.PrimitiveType(typename)\n        C = tp.is_char_type()\n        F = tp.is_float_type()\n        X = tp.is_complex_type()\n        I = tp.is_integer_type()\n        assert C == (typename in ('char', 'wchar_t', 'char16_t', 'char32_t'))\n        assert F == (typename in ('float', 'double', 'long double'))\n        assert X == (typename in ('_cffi_float_complex_t', '_cffi_double_complex_t'))\n        assert I + F + C + X == 1      # one and only one of them is true\n\ndef test_all_integer_and_float_types():\n    typenames = []\n    for typename in all_primitive_types:\n        if (all_primitive_types[typename] == 'c' or\n            all_primitive_types[typename] == 'j' or    # complex\n            typename == '_Bool' or typename == 'long double'):\n            pass\n        else:\n            typenames.append(typename)\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    lib = ffi.verify('\\n'.join([\"%s foo_%s(%s x) { return (%s)(x+1); }\" %\n                                (tp, tp.replace(' ', '_'), tp, tp)\n                                for tp in typenames]))\n    for typename in typenames:\n        foo = getattr(lib, 'foo_%s' % typename.replace(' ', '_'))\n        assert foo(42) == 43\n        if sys.version < '3':\n            assert foo(long(44)) == 45\n        assert foo(ffi.cast(typename, 46)) == 47\n        pytest.raises(TypeError, foo, ffi.NULL)\n        #\n        # check for overflow cases\n        if all_primitive_types[typename] == 'f':\n            continue\n        for value in [-2**80, -2**40, -2**20, -2**10, -2**5, -1,\n                      2**5, 2**10, 2**20, 2**40, 2**80]:\n            overflows = int(ffi.cast(typename, value)) != value\n            if overflows:\n                pytest.raises(OverflowError, foo, value)\n            else:\n                assert foo(value) == value + 1\n\ndef test_all_complex_types():\n    pytest.skip(\"not implemented in verify(): complex types\")\n    if sys.platform == 'win32':\n        typenames = ['_Fcomplex', '_Dcomplex']\n        header = '#include <complex.h>\\n'\n    else:\n        typenames = ['float _Complex', 'double _Complex']\n        header = ''\n    #\n    ffi = FFI()\n    ffi.cdef('\\n'.join([\"%s foo_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                       for tp in typenames]))\n    e = pytest.raises(VerificationError, ffi.verify,\n            header + '\\n'.join([\"%s foo_%s(%s x) { return x; }\" %\n                                (tp, tp.replace(' ', '_'), tp)\n                                for tp in typenames]))\n\ndef test_var_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    csource = \"\\n\".join([\"static %s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, min)\n        assert getattr(lib, varname) == min\n        pytest.raises(OverflowError, setattr, lib, varname, max+1)\n        pytest.raises(OverflowError, setattr, lib, varname, min-1)\n\ndef test_var_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    csource = \"\\n\".join([\"static %s somevar_%s;\" % (tp, tp.replace(' ', '_'))\n                         for tp in lst])\n    ffi.cdef(csource)\n    lib = ffi.verify(csource)\n    for tp in lst:\n        varname = 'somevar_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        setattr(lib, varname, max)\n        assert getattr(lib, varname) == max\n        setattr(lib, varname, 0)\n        assert getattr(lib, varname) == 0\n        pytest.raises(OverflowError, setattr, lib, varname, max+1)\n        pytest.raises(OverflowError, setattr, lib, varname, -1)\n\ndef test_fn_signed_integer_types():\n    ffi = FFI()\n    lst = all_signed_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        max = (1 << (8*sz-1)) - 1\n        min = -(1 << (8*sz-1))\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(min) == min\n        pytest.raises(OverflowError, fn, max + 1)\n        pytest.raises(OverflowError, fn, min - 1)\n\ndef test_fn_unsigned_integer_types():\n    ffi = FFI()\n    lst = all_unsigned_integer_types(ffi)\n    cdefsrc = \"\\n\".join([\"%s somefn_%s(%s);\" % (tp, tp.replace(' ', '_'), tp)\n                         for tp in lst])\n    ffi.cdef(cdefsrc)\n    verifysrc = \"\\n\".join([\"%s somefn_%s(%s x) { return x; }\" %\n                           (tp, tp.replace(' ', '_'), tp) for tp in lst])\n    lib = ffi.verify(verifysrc)\n    for tp in lst:\n        fnname = 'somefn_%s' % tp.replace(' ', '_')\n        sz = ffi.sizeof(tp)\n        if tp != '_Bool':\n            max = (1 << (8*sz)) - 1\n        else:\n            max = 1\n        fn = getattr(lib, fnname)\n        assert fn(max) == max\n        assert fn(0) == 0\n        pytest.raises(OverflowError, fn, max + 1)\n        pytest.raises(OverflowError, fn, -1)\n\ndef test_char_type():\n    ffi = FFI()\n    ffi.cdef(\"char foo(char);\")\n    lib = ffi.verify(\"char foo(char x) { return ++x; }\")\n    assert lib.foo(b\"A\") == b\"B\"\n    pytest.raises(TypeError, lib.foo, b\"bar\")\n    pytest.raises(TypeError, lib.foo, \"bar\")\n\ndef test_wchar_type():\n    ffi = FFI()\n    if ffi.sizeof('wchar_t') == 2:\n        uniexample1 = u+'\\u1234'\n        uniexample2 = u+'\\u1235'\n    else:\n        uniexample1 = u+'\\U00012345'\n        uniexample2 = u+'\\U00012346'\n    #\n    ffi.cdef(\"wchar_t foo(wchar_t);\")\n    lib = ffi.verify(\"wchar_t foo(wchar_t x) { return x+1; }\")\n    assert lib.foo(uniexample1) == uniexample2\n\ndef test_char16_char32_type():\n    pytest.skip(\"XXX test or fully prevent char16_t and char32_t from \"\n                 \"working in ffi.verify() mode\")\n\ndef test_no_argument():\n    ffi = FFI()\n    ffi.cdef(\"int foo(void);\")\n    lib = ffi.verify(\"int foo(void) { return 42; }\")\n    assert lib.foo() == 42\n\ndef test_two_arguments():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"int foo(int a, int b) { return a - b; }\")\n    assert lib.foo(40, -2) == 42\n\ndef test_macro():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, int);\")\n    lib = ffi.verify(\"#define foo(a, b) ((a) * (b))\")\n    assert lib.foo(-6, -7) == 42\n\ndef test_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    assert lib.foo(ffi.NULL) == ffi.NULL\n    p = ffi.new(\"int *\", 42)\n    q = ffi.new(\"int *\", 42)\n    assert lib.foo(p) == p\n    assert lib.foo(q) != p\n\ndef test_bogus_ptr():\n    ffi = FFI()\n    ffi.cdef(\"int *foo(int *);\")\n    lib = ffi.verify(\"int *foo(int *a) { return a; }\")\n    pytest.raises(TypeError, lib.foo, ffi.new(\"short *\", 42))\n\n\ndef test_verify_typedefs():\n    pytest.skip(\"ignored so far\")\n    types = ['signed char', 'unsigned char', 'int', 'long']\n    for cdefed in types:\n        for real in types:\n            ffi = FFI()\n            ffi.cdef(\"typedef %s foo_t;\" % cdefed)\n            if cdefed == real:\n                ffi.verify(\"typedef %s foo_t;\" % real)\n            else:\n                pytest.raises(VerificationError, ffi.verify,\n                               \"typedef %s foo_t;\" % real)\n\ndef test_nondecl_struct():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct foo_s foo_t; int bar(foo_t *);\")\n    lib = ffi.verify(\"typedef struct foo_s foo_t;\\n\"\n                     \"int bar(foo_t *f) { (void)f; return 42; }\\n\")\n    assert lib.bar(ffi.NULL) == 42\n\ndef test_ffi_full_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; int y; long *z; };\")\n    ffi.verify(\"struct foo_s { char x; int y; long *z; };\")\n    #\n    if sys.platform != 'win32':  # XXX fixme: only gives warnings\n        pytest.raises(VerificationError, ffi.verify,\n            \"struct foo_s { char x; int y; int *z; };\")\n    #\n    pytest.raises(VerificationError, ffi.verify,\n        \"struct foo_s { int y; long *z; };\")\n    #\n    e = pytest.raises(VerificationError, ffi.verify,\n        \"struct foo_s { int y; char x; long *z; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong offset for field 'x'\"\n        \" (we have 0, but C compiler says 4)\")\n    #\n    e = pytest.raises(VerificationError, ffi.verify,\n        \"struct foo_s { char x; int y; long *z; char extra; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong total size\"\n        \" (we have %d, but C compiler says %d)\" % (\n            ffi.sizeof(\"struct foo_s\"),\n            ffi.sizeof(\"struct foo_s\") + ffi.sizeof(\"long*\")))\n    #\n    # a corner case that we cannot really detect, but where it has no\n    # bad consequences: the size is the same, but there is an extra field\n    # that replaces what is just padding in our declaration above\n    ffi.verify(\"struct foo_s { char x, extra; int y; long *z; };\")\n    #\n    e = pytest.raises(VerificationError, ffi.verify,\n        \"struct foo_s { char x; short pad; short y; long *z; };\")\n    assert str(e.value) == (\n        \"struct foo_s: wrong size for field 'y'\"\n        \" (we have 4, but C compiler says 2)\")\n\ndef test_ffi_nonfull_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n    struct foo_s {\n       int x;\n       ...;\n    };\n    \"\"\")\n    pytest.raises(VerificationMissing, ffi.sizeof, 'struct foo_s')\n    pytest.raises(VerificationMissing, ffi.offsetof, 'struct foo_s', 'x')\n    pytest.raises(VerificationMissing, ffi.new, 'struct foo_s *')\n    ffi.verify(\"\"\"\n    struct foo_s {\n       int a, b, x, c, d, e;\n    };\n    \"\"\")\n    assert ffi.sizeof('struct foo_s') == 6 * ffi.sizeof('int')\n    assert ffi.offsetof('struct foo_s', 'x') == 2 * ffi.sizeof('int')\n\ndef test_ffi_nonfull_alignment():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char x; ...; };\")\n    ffi.verify(\"struct foo_s { int a, b; char x; };\")\n    assert ffi.sizeof('struct foo_s') == 3 * ffi.sizeof('int')\n    assert ffi.alignof('struct foo_s') == ffi.sizeof('int')\n\ndef _check_field_match(typename, real, expect_mismatch):\n    ffi = FFI()\n    testing_by_size = (expect_mismatch == 'by_size')\n    if testing_by_size:\n        expect_mismatch = ffi.sizeof(typename) != ffi.sizeof(real)\n    ffi.cdef(\"struct foo_s { %s x; ...; };\" % typename)\n    try:\n        ffi.verify(\"struct foo_s { %s x; };\" % real)\n    except VerificationError:\n        if not expect_mismatch:\n            if testing_by_size and typename != real:\n                print(\"ignoring mismatch between %s* and %s* even though \"\n                      \"they have the same size\" % (typename, real))\n                return\n            raise AssertionError(\"unexpected mismatch: %s should be accepted \"\n                                 \"as equal to %s\" % (typename, real))\n    else:\n        if expect_mismatch:\n            raise AssertionError(\"mismatch not detected: \"\n                                 \"%s != %s\" % (typename, real))\n\ndef test_struct_bad_sized_integer():\n    for typename in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n        for real in ['int8_t', 'int16_t', 'int32_t', 'int64_t']:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_bad_sized_float():\n    for typename in all_float_types:\n        for real in all_float_types:\n            _check_field_match(typename, real, \"by_size\")\n\ndef test_struct_signedness_ignored():\n    _check_field_match(\"int\", \"unsigned int\", expect_mismatch=False)\n    _check_field_match(\"unsigned short\", \"signed short\", expect_mismatch=False)\n\ndef test_struct_float_vs_int():\n    if sys.platform == 'win32':\n        pytest.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    for typename in all_signed_integer_types(ffi):\n        for real in all_float_types:\n            _check_field_match(typename, real, expect_mismatch=True)\n    for typename in all_float_types:\n        for real in all_signed_integer_types(ffi):\n            _check_field_match(typename, real, expect_mismatch=True)\n\ndef test_struct_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[17]; ...; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n\ndef test_struct_array_no_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[]; int y; ...; };\\n\"\n             \"int bar(struct foo_s *);\\n\")\n    lib = ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\\n\"\n                     \"int bar(struct foo_s *f) { return f->a[14]; }\\n\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.typeof(s.a) is ffi.typeof('int[]')   # implicit max length\n    assert len(s.a) == 18  # max length, computed from the size and start offset\n    s.a[14] = 4242\n    assert lib.bar(s) == 4242\n    # with no declared length, out-of-bound accesses are not detected\n    s.a[17] = -521\n    assert s.y == s.a[17] == -521\n    #\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(17))})\n    assert s.a[16] == 16\n    # overflows at construction time not detected either\n    s = ffi.new(\"struct foo_s *\", {'a': list(range(18))})\n    assert s.y == s.a[17] == 17\n\ndef test_struct_array_guess_length():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a[...]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[17]; int y; };\")\n    assert ffi.sizeof('struct foo_s') == 19 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == 17 * ffi.sizeof('int')\n    with pytest.raises(IndexError):\n        s.a[17]\n\ndef test_struct_array_c99_1():\n    if sys.platform == 'win32':\n        pytest.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; };\")\n    ffi.verify(\"struct foo_s { int x; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(ffi.typeof(s[0])) == 1 * ffi.sizeof('int')\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    # ^^^ explanation: if you write in C: \"char x[5];\", then\n    # \"sizeof(x)\" will evaluate to 5.  The behavior above is\n    # a generalization of that to \"struct foo_s[len(a)=5] x;\"\n    # if you could do that in C.\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 5 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 1 * ffi.sizeof('int')\n\ndef test_struct_array_c99_2():\n    if sys.platform == 'win32':\n        pytest.skip(\"requires C99\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; int a[]; ...; };\")\n    ffi.verify(\"struct foo_s { int x, y; int a[]; };\")\n    assert ffi.sizeof('struct foo_s') == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242, 4])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == 0\n    s = ffi.new(\"struct foo_s *\", [424242, [-40, -30, -20, -10]])\n    assert ffi.sizeof(s[0]) == 6 * ffi.sizeof('int')\n    assert s.a[3] == -10\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n    s = ffi.new(\"struct foo_s *\", [424242])\n    assert ffi.sizeof(s[0]) == 2 * ffi.sizeof('int')\n\ndef test_struct_ptr_to_array_field():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int (*a)[17]; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct foo_s { int x; int (*a)[17]; int y; };\\n\"\n               \"struct bar_s { int x; int *a; int y; };\")\n    assert ffi.sizeof('struct foo_s') == ffi.sizeof(\"struct bar_s\")\n    s = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(s.a) == ffi.sizeof('int(*)[17]') == ffi.sizeof(\"int *\")\n\ndef test_struct_with_bitfield_exact():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int a:2, b:3; };\")\n    ffi.verify(\"struct foo_s { int a:2, b:3; };\")\n    s = ffi.new(\"struct foo_s *\")\n    s.b = 3\n    with pytest.raises(OverflowError):\n        s.b = 4\n    assert s.b == 3\n\ndef test_struct_with_bitfield_enum():\n    ffi = FFI()\n    code = \"\"\"\n        typedef enum { AA, BB, CC } foo_e;\n        typedef struct { foo_e f:2; } foo_s;\n    \"\"\"\n    ffi.cdef(code)\n    ffi.verify(code)\n    s = ffi.new(\"foo_s *\")\n    s.f = 2\n    assert s.f == 2\n\ndef test_unsupported_struct_with_bitfield_ellipsis():\n    ffi = FFI()\n    pytest.raises(NotImplementedError, ffi.cdef,\n                   \"struct foo_s { int a:2, b:3; ...; };\")\n\ndef test_global_constants():\n    ffi = FFI()\n    # use 'static const int', as generally documented, although in this\n    # case the 'static' is completely ignored.\n    ffi.cdef(\"static const int AA, BB, CC, DD;\")\n    lib = ffi.verify(\"#define AA 42\\n\"\n                     \"#define BB (-43)   // blah\\n\"\n                     \"#define CC (22*2)  /* foobar */\\n\"\n                     \"#define DD ((unsigned int)142)  /* foo\\nbar */\\n\")\n    assert lib.AA == 42\n    assert lib.BB == -43\n    assert lib.CC == 44\n    assert lib.DD == 142\n\ndef test_global_const_int_size():\n    # integer constants: ignore the declared type, always just use the value\n    for value in [-2**63, -2**31, -2**15,\n                  2**15-1, 2**15, 2**31-1, 2**31, 2**32-1, 2**32,\n                  2**63-1, 2**63, 2**64-1]:\n        ffi = FFI()\n        if value == int(ffi.cast(\"long long\", value)):\n            if value < 0:\n                vstr = '(-%dLL-1)' % (~value,)\n            else:\n                vstr = '%dLL' % value\n        elif value == int(ffi.cast(\"unsigned long long\", value)):\n            vstr = '%dULL' % value\n        else:\n            raise AssertionError(value)\n        ffi.cdef(\"static const unsigned short AA;\")\n        lib = ffi.verify(\"#define AA %s\\n\" % vstr)\n        assert lib.AA == value\n        assert type(lib.AA) is type(int(lib.AA))\n\ndef test_global_constants_non_int():\n    ffi = FFI()\n    ffi.cdef(\"static char *const PP;\")\n    lib = ffi.verify('static char *const PP = \"testing!\";\\n')\n    assert ffi.typeof(lib.PP) == ffi.typeof(\"char *\")\n    assert ffi.string(lib.PP) == b\"testing!\"\n\ndef test_nonfull_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3, ... \\n \\t };\")\n    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE2')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    assert ffi.string(ffi.cast('enum ee', -10)) == \"EE3\"\n    #\n    # try again\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == \"EE2\"\n    #\n    assert ffi.typeof(\"enum ee\").relements == {'EE1': 10, 'EE2': 11, 'EE3': -10}\n    assert ffi.typeof(\"enum ee\").elements == {10: 'EE1', 11: 'EE2', -10: 'EE3'}\n\ndef test_full_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2, EE3 };\")\n    ffi.verify(\"enum ee { EE1, EE2, EE3 };\")\n    pytest.raises(VerificationError, ffi.verify, \"enum ee { EE1, EE2 };\")\n    e = pytest.raises(VerificationError, ffi.verify,\n                       \"enum ee { EE1, EE3, EE2 };\")\n    assert str(e.value) == 'enum ee: EE2 has the real value 2, not 1'\n    # extra items cannot be seen and have no bad consequence anyway\n    lib = ffi.verify(\"enum ee { EE1, EE2, EE3, EE4 };\")\n    assert lib.EE3 == 2\n\ndef test_enum_usage():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    lib = ffi.verify(\"enum ee { EE1,EE2 }; typedef struct { enum ee x; } *sp;\")\n    assert lib.EE2 == 1\n    s = ffi.new(\"sp\", [lib.EE2])\n    assert s.x == 1\n    s.x = 17\n    assert s.x == 17\n\ndef test_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1 }; enum { EE2, EE3 };\")\n    lib = ffi.verify(\"enum { EE1 }; enum { EE2, EE3 };\")\n    assert lib.EE1 == 0\n    assert lib.EE2 == 0\n    assert lib.EE3 == 1\n\ndef test_nonfull_anonymous_enum():\n    ffi = FFI()\n    ffi.cdef(\"enum { EE1, ... }; enum { EE3, ... };\")\n    lib = ffi.verify(\"enum { EE2, EE1 }; enum { EE3 };\")\n    assert lib.EE1 == 1\n    assert lib.EE3 == 0\n\ndef test_nonfull_enum_syntax2():\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t..., EE3 };\")\n    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    assert ffi.string(ffi.cast('enum ee', -10)) == 'EE3'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee { EE1, EE2=\\t... };\")\n    pytest.raises(VerificationMissing, ffi.cast, 'enum ee', 'EE1')\n    ffi.verify(\"enum ee { EE1=10, EE2, EE3=-10, EE4 };\")\n    assert ffi.string(ffi.cast('enum ee', 11)) == 'EE2'\n    #\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=..., ... };\")\n    ffi.verify(\"enum ee2 { EE4=-1234-5, EE5 }; \")\n    assert ffi.string(ffi.cast('enum ee2', -1239)) == 'EE4'\n    assert ffi.string(ffi.cast('enum ee2', -1238)) == 'EE5'\n\ndef test_nonfull_enum_bug3():\n    ffi = FFI()\n    ffi.cdef(\"enum ee2 { EE4=..., EE5=... };\")\n    ffi.cdef(\"enum ee6 { EE7=10, EE8=..., EE9=... };\")\n\ndef test_get_set_errno():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"\"\"\n        static int foo(int x)\n        {\n            errno += 1;\n            return x * 7;\n        }\n    \"\"\")\n    ffi.errno = 15\n    assert lib.foo(6) == 42\n    assert ffi.errno == 16\n\ndef test_define_int():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO ...\\n\"\n             \"\\t#\\tdefine\\tBAR\\t...\\t\\n\"\n             \"#define BAZ ...\\n\")\n    lib = ffi.verify(\"#define FOO 42\\n\"\n                     \"#define BAR (-44)\\n\"\n                     \"#define BAZ 0xffffffffffffffffULL\\n\")\n    assert lib.FOO == 42\n    assert lib.BAR == -44\n    assert lib.BAZ == 0xffffffffffffffff\n\ndef test_access_variable():\n    ffi = FFI()\n    ffi.cdef(\"static int foo(void);\\n\"\n             \"static int somenumber;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        static int foo(void) {\n            return somenumber * 7;\n        }\n    \"\"\")\n    assert lib.somenumber == 2\n    assert lib.foo() == 14\n    lib.somenumber = -6\n    assert lib.foo() == -42\n    assert lib.somenumber == -6\n    lib.somenumber = 2   # reset for the next run, if any\n\ndef test_access_address_of_variable():\n    # access the address of 'somenumber': need a trick\n    ffi = FFI()\n    ffi.cdef(\"static int somenumber; static int *const somenumberptr;\")\n    lib = ffi.verify(\"\"\"\n        static int somenumber = 2;\n        #define somenumberptr (&somenumber)\n    \"\"\")\n    assert lib.somenumber == 2\n    lib.somenumberptr[0] = 42\n    assert lib.somenumber == 42\n    lib.somenumber = 2    # reset for the next run, if any\n\ndef test_access_array_variable(length=5):\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\\n\"\n             \"static int somenumber[%s];\" % (length,))\n    lib = ffi.verify(\"\"\"\n        static int somenumber[] = {2, 2, 3, 4, 5};\n        static int foo(int i) {\n            return somenumber[i] * 7;\n        }\n    \"\"\")\n    if length == '':\n        # a global variable of an unknown array length is implicitly\n        # transformed into a global pointer variable, because we can only\n        # work with array instances whose length we know.  using a pointer\n        # instead of an array gives the correct effects.\n        assert repr(lib.somenumber).startswith(\"<cdata 'int *' 0x\")\n        pytest.raises(TypeError, len, lib.somenumber)\n    else:\n        assert repr(lib.somenumber).startswith(\"<cdata 'int[%s]' 0x\" % length)\n        assert len(lib.somenumber) == 5\n    assert lib.somenumber[3] == 4\n    assert lib.foo(3) == 28\n    lib.somenumber[3] = -6\n    assert lib.foo(3) == -42\n    assert lib.somenumber[3] == -6\n    assert lib.somenumber[4] == 5\n    lib.somenumber[3] = 4    # reset for the next run, if any\n\ndef test_access_array_variable_length_hidden():\n    test_access_array_variable(length='')\n\ndef test_access_struct_variable():\n    ffi = FFI()\n    ffi.cdef(\"struct foo { int x; ...; };\\n\"\n             \"int foo(int);\\n\"\n             \"static struct foo stuff;\")\n    lib = ffi.verify(\"\"\"\n        struct foo { int x, y, z; };\n        static struct foo stuff = {2, 5, 8};\n        static int foo(int i) {\n            switch (i) {\n            case 0: return stuff.x * 7;\n            case 1: return stuff.y * 7;\n            case 2: return stuff.z * 7;\n            }\n            return -1;\n        }\n    \"\"\")\n    assert lib.stuff.x == 2\n    assert lib.foo(0) == 14\n    assert lib.foo(1) == 35\n    assert lib.foo(2) == 56\n    lib.stuff.x = -6\n    assert lib.foo(0) == -42\n    assert lib.foo(1) == 35\n    lib.stuff.x = 2      # reset for the next run, if any\n\ndef test_access_callback():\n    ffi = FFI()\n    ffi.cdef(\"static int (*cb)(int);\\n\"\n             \"static int foo(int);\\n\"\n             \"static void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_access_callback_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"typedef int mycallback_t(int);\\n\"\n             \"static mycallback_t *cb;\\n\"\n             \"static int foo(int);\\n\"\n             \"static void reset_cb(void);\")\n    lib = ffi.verify(\"\"\"\n        static int g(int x) { return x * 7; }\n        static int (*cb)(int);\n        static int foo(int i) { return cb(i) - 1; }\n        static void reset_cb(void) { cb = g; }\n    \"\"\")\n    lib.reset_cb()\n    assert lib.foo(6) == 41\n    my_callback = ffi.callback(\"int(*)(int)\", lambda n: n * 222)\n    lib.cb = my_callback\n    assert lib.foo(4) == 887\n\ndef test_ctypes_backend_forces_generic_engine():\n    from cffi.backend_ctypes import CTypesBackend\n    ffi = FFI(backend=CTypesBackend())\n    ffi.cdef(\"int func(int a);\")\n    lib = ffi.verify(\"int func(int a) { return a * 42; }\")\n    assert not hasattr(lib, '_cffi_python_module')\n    assert hasattr(lib, '_cffi_generic_module')\n    assert lib.func(100) == 4200\n\ndef test_call_with_struct_ptr():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } foo_t; int foo(foo_t *);\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        static int foo(foo_t *f) { return f->x * 7; }\n    \"\"\")\n    f = ffi.new(\"foo_t *\")\n    f.x = 6\n    assert lib.foo(f) == 42\n\ndef test_unknown_type():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... token_t;\n        int foo(token_t *);\n        #define TOKEN_SIZE ...\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef float token_t;\n        static int foo(token_t *tk) {\n            if (!tk)\n                return -42;\n            *tk += 1.601f;\n            return (int)*tk;\n        }\n        #define TOKEN_SIZE sizeof(token_t)\n    \"\"\")\n    # we cannot let ffi.new(\"token_t *\") work, because we don't know ahead of\n    # time if it's ok to ask 'sizeof(token_t)' in the C code or not.\n    # See test_unknown_type_2.  Workaround.\n    tkmem = ffi.new(\"char[]\", lib.TOKEN_SIZE)    # zero-initialized\n    tk = ffi.cast(\"token_t *\", tkmem)\n    results = [lib.foo(tk) for i in range(6)]\n    assert results == [1, 3, 4, 6, 8, 9]\n    assert lib.foo(ffi.NULL) == -42\n\ndef test_unknown_type_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... token_t;\")\n    lib = ffi.verify(\"typedef struct token_s token_t;\")\n    # assert did not crash, even though 'sizeof(token_t)' is not valid in C.\n\ndef test_unknown_type_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef ... *token_p;\n        token_p foo(token_p);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct _token_s *token_p;\n        token_p foo(token_p arg) {\n            if (arg)\n                return (token_p)0x12347;\n            else\n                return (token_p)0x12345;\n        }\n    \"\"\")\n    p = lib.foo(ffi.NULL)\n    assert int(ffi.cast(\"intptr_t\", p)) == 0x12345\n    q = lib.foo(p)\n    assert int(ffi.cast(\"intptr_t\", q)) == 0x12347\n\ndef test_varargs():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        int foo(int x, ...) {\n            va_list vargs;\n            va_start(vargs, x);\n            x -= va_arg(vargs, int);\n            x -= va_arg(vargs, int);\n            va_end(vargs);\n            return x;\n        }\n    \"\"\")\n    assert lib.foo(50, ffi.cast(\"int\", 5), ffi.cast(\"int\", 3)) == 42\n\ndef test_varargs_exact():\n    if sys.platform == 'win32':\n        pytest.skip(\"XXX fixme: only gives warnings\")\n    ffi = FFI()\n    ffi.cdef(\"int foo(int x, ...);\")\n    pytest.raises(VerificationError, ffi.verify, \"\"\"\n        int foo(long long x, ...) {\n            return x;\n        }\n    \"\"\")\n\ndef test_varargs_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { char a; int b; }; int foo(int x, ...);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            char a; int b;\n        };\n        int foo(int x, ...) {\n            va_list vargs;\n            struct foo_s s;\n            va_start(vargs, x);\n            s = va_arg(vargs, struct foo_s);\n            va_end(vargs);\n            return s.a - s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [b'B', 1])\n    assert lib.foo(50, s[0]) == ord('A')\n\ndef test_autofilled_struct_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; double b; ...; };\\n\"\n             \"int foo(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n    \"\"\")\n    s = ffi.new(\"struct foo_s *\", [100, 1])\n    assert lib.foo(s[0]) == 99\n    assert lib.foo([100, 1]) == 99\n\ndef test_autofilled_struct_as_argument_dynamic():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { long a; ...; };\\n\"\n             \"static int (*foo)(struct foo_s);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s {\n            double b;\n            long a;\n        };\n        int foo1(struct foo_s s) {\n            return (int)s.a - (int)s.b;\n        }\n        static int (*foo)(struct foo_s s) = &foo1;\n    \"\"\")\n    e = pytest.raises(NotImplementedError, lib.foo, \"?\")\n    msg = (\"ctype 'struct foo_s' not supported as argument.  It is a struct \"\n           'declared with \"...;\", but the C calling convention may depend on '\n           \"the missing fields; or, it contains anonymous struct/unions.  \"\n           \"Such structs are only supported as argument \"\n           \"if the function is 'API mode' and non-variadic (i.e. declared \"\n           \"inside ffibuilder.cdef()+ffibuilder.set_source() and not taking \"\n           \"a final '...' argument)\")\n    assert str(e.value) == msg\n\ndef test_func_returns_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { int aa, bb; };\n        struct foo_s foo(int a, int b) {\n            struct foo_s r;\n            r.aa = a*a;\n            r.bb = b*b;\n            return r;\n        }\n    \"\"\")\n    s = lib.foo(6, 7)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 8 bytes>\"\n    assert s.aa == 36\n    assert s.bb == 49\n\ndef test_func_as_funcptr():\n    ffi = FFI()\n    ffi.cdef(\"int *(*const fooptr)(void);\")\n    lib = ffi.verify(\"\"\"\n        int *foo(void) {\n            return (int*)\"foobar\";\n        }\n        int *(*fooptr)(void) = foo;\n    \"\"\")\n    foochar = ffi.cast(\"char *(*)(void)\", lib.fooptr)\n    s = foochar()\n    assert ffi.string(s) == b\"foobar\"\n\ndef test_funcptr_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int (*compar)(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_func_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        void qsort(void *base, size_t nel, size_t width,\n            int compar(const void *, const void *));\n    \"\"\")\n    ffi.verify(\"#include <stdlib.h>\")\n\ndef test_array_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        size_t strlen(char string[]);\n    \"\"\")\n    ffi.verify(\"#include <string.h>\")\n\ndef test_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        int foo_func(enum foo_e);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        int foo_func(enum foo_e e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == 2\n    pytest.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum foo_e { AA, BB, ... };\n        enum foo_e foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        enum foo_e { AA, CC, BB };\n        enum foo_e foo_func(int x) { return (enum foo_e)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_enum_values():\n    ffi = FFI()\n    ffi.cdef(\"enum enum1_e { AA, BB };\")\n    lib = ffi.verify(\"enum enum1_e { AA, BB };\")\n    assert lib.AA == 0\n    assert lib.BB == 1\n    assert ffi.string(ffi.cast(\"enum enum1_e\", 1)) == 'BB'\n\ndef test_typedef_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 1\n\ndef test_typedef_broken_complete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB } enum1_t;\")\n    pytest.raises(VerificationError, ffi.verify,\n                   \"typedef enum { AA, CC, BB } enum1_t;\")\n\ndef test_typedef_incomplete_enum():\n    ffi = FFI()\n    ffi.cdef(\"typedef enum { AA, BB, ... } enum1_t;\")\n    lib = ffi.verify(\"typedef enum { AA, CC, BB } enum1_t;\")\n    assert ffi.string(ffi.cast(\"enum1_t\", 1)) == '1'\n    assert ffi.string(ffi.cast(\"enum1_t\", 2)) == 'BB'\n    assert lib.AA == 0\n    assert lib.BB == 2\n\ndef test_typedef_enum_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        int foo_func(foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        int foo_func(foo_t e) { return (int)e; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n    pytest.raises(TypeError, lib.foo_func, \"BB\")\n\ndef test_typedef_enum_as_function_result():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef enum { AA, BB, ... } foo_t;\n        foo_t foo_func(int x);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef enum { AA, CC, BB } foo_t;\n        foo_t foo_func(int x) { return (foo_t)x; }\n    \"\"\")\n    assert lib.foo_func(lib.BB) == lib.BB == 2\n\ndef test_function_typedef():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef double func_t(double);\n        func_t sin;\n    \"\"\")\n    lib = ffi.verify('#include <math.h>', libraries=lib_m)\n    assert lib.sin(1.23) == math.sin(1.23)\n\ndef test_opaque_integer_as_function_result():\n    #import platform\n    #if platform.machine().startswith('sparc'):\n    #    pytest.skip('Breaks horribly on sparc (SIGILL + corrupted stack)')\n    #elif platform.machine() == 'mips64' and sys.maxsize > 2**32:\n    #    pytest.skip('Segfaults on mips64el')\n    # XXX bad abuse of \"struct { ...; }\".  It only works a bit by chance\n    # anyway.  XXX think about something better :-(\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { ...; } myhandle_t;\n        myhandle_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef short myhandle_t;\n        myhandle_t foo(void) { return 42; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == ffi.sizeof(\"short\")\n\ndef test_return_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(void);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(void) { foo_t r = { 45, 81 }; return r; }\n    \"\"\")\n    h = lib.foo()\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 81\n\ndef test_take_and_return_partial_structs():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct { int x; ...; } foo_t;\n        foo_t foo(foo_t, foo_t);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        typedef struct { int y, x; } foo_t;\n        foo_t foo(foo_t a, foo_t b) {\n            foo_t r = { 100, a.x * 5 + b.x * 7 };\n            return r;\n        }\n    \"\"\")\n    args = ffi.new(\"foo_t[3]\")\n    args[0].x = 1000\n    args[2].x = -498\n    h = lib.foo(args[0], args[2])\n    assert ffi.sizeof(h) == 2 * ffi.sizeof(\"int\")\n    assert h.x == 1000 * 5 - 498 * 7\n\ndef test_cannot_name_struct_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } **sp; void foo(sp);\")\n    e = pytest.raises(VerificationError, ffi.verify,\n                       \"typedef struct { int x; } **sp; void foo(sp x) { }\")\n    assert 'in argument of foo: unknown type name' in str(e.value)\n\ndef test_dont_check_unnamable_fields():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct { int x; } someone; };\")\n    ffi.verify(\"struct foo_s { struct { int x; } someone; };\")\n    # assert did not crash\n\ndef test_nested_anonymous_struct_exact():\n    if sys.platform == 'win32':\n        pytest.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    assert ffi.sizeof(p[0]) == 3 * ffi.sizeof(\"int\")    # with alignment\n    p.a = 1234567\n    p.b = b'X'\n    p.c = b'Y'\n    assert p.a == 1234567\n    assert p.b == b'X'\n    assert p.c == b'Y'\n    assert p.d == b'Y'\n\ndef test_nested_anonymous_struct_exact_error():\n    if sys.platform == 'win32':\n        pytest.skip(\"nested anonymous struct/union\")\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { int a; char b; }; union { char c, d; }; };\n    \"\"\")\n    pytest.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; short b; }; union { char c, d; }; };\n    \"\"\")\n    pytest.raises(VerificationError, ffi.verify, \"\"\"\n        struct foo_s { struct { int a; char e, b; }; union { char c, d; }; };\n    \"\"\")\n\ndef test_nested_anonymous_struct_inexact_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { struct { char b; ...; }; union { char c, d; }; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_nested_anonymous_struct_inexact_2():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct foo_s { union { char c, d; }; struct { int a; char b; }; ...; };\n    \"\"\")\n    ffi.verify(\"\"\"\n        struct foo_s { int a, padding; char c, d, b; };\n    \"\"\")\n    assert ffi.sizeof(\"struct foo_s\") == 3 * ffi.sizeof(\"int\")\n\ndef test_ffi_union():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; long *z; };\")\n    ffi.verify(\"union foo_u { char x; int y; long *z; };\")\n\ndef test_ffi_union_partial():\n    ffi = FFI()\n    ffi.cdef(\"union foo_u { char x; ...; };\")\n    ffi.verify(\"union foo_u { char x; int y; };\")\n    assert ffi.sizeof(\"union foo_u\") == 4\n\ndef test_ffi_union_with_partial_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int x; ...; }; union foo_u { struct foo_s s; };\")\n    ffi.verify(\"struct foo_s { int a; int x; }; \"\n               \"union foo_u { char b[32]; struct foo_s s; };\")\n    assert ffi.sizeof(\"struct foo_s\") == 8\n    assert ffi.sizeof(\"union foo_u\") == 32\n\ndef test_ffi_union_partial_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { char x; ...; } u1;\")\n    ffi.verify(\"typedef union { char x; int y; } u1;\")\n    assert ffi.sizeof(\"u1\") == 4\n\ndef test_ffi_union_with_partial_struct_2():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } s1;\"\n             \"typedef union { s1 s; } u1;\")\n    ffi.verify(\"typedef struct { int a; int x; } s1; \"\n               \"typedef union { char b[32]; s1 s; } u1;\")\n    assert ffi.sizeof(\"s1\") == 8\n    assert ffi.sizeof(\"u1\") == 32\n    assert ffi.offsetof(\"u1\", \"s\") == 0\n\ndef test_ffi_struct_packed():\n    if sys.platform == 'win32':\n        pytest.skip(\"needs a GCC extension\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { int b; ...; };\")\n    ffi.verify(\"\"\"\n        struct foo_s {\n            char a;\n            int b;\n        } __attribute__((packed));\n    \"\"\")\n\ndef test_tmpdir():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    lib = ffi.verify(\"int foo(int a) { return a + 42; }\", tmpdir=tmpdir)\n    assert os.listdir(tmpdir)\n    assert lib.foo(100) == 142\n\ndef test_relative_to():\n    import tempfile, os\n    from testing.udir import udir\n    tmpdir = tempfile.mkdtemp(dir=str(udir))\n    ffi = FFI()\n    ffi.cdef(\"int foo(int);\")\n    f = open(os.path.join(tmpdir, 'foo.h'), 'w')\n    f.write(\"int foo(int a) { return a + 42; }\\n\")\n    f.close()\n    lib = ffi.verify('#include \"foo.h\"',\n                     include_dirs=['.'],\n                     relative_to=os.path.join(tmpdir, 'x'))\n    assert lib.foo(100) == 142\n\ndef test_bug1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef struct tdlhandle_s { ...; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n    ffi.verify(\"\"\"\n        typedef struct tdlhandle_s { int foo; } *tdl_handle_t;\n        typedef struct my_error_code_ {\n            tdl_handle_t *rh;\n        } my_error_code_t;\n    \"\"\")\n\ndef test_bool():\n    if sys.platform == 'win32':\n        pytest.skip(\"_Bool not in MSVC\")\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { _Bool x; };\"\n             \"_Bool foo(_Bool); static _Bool (*foop)(_Bool);\")\n    lib = ffi.verify(\"\"\"\n        struct foo_s { _Bool x; };\n        int foo(int arg) {\n            return !arg;\n        }\n        _Bool _foofunc(_Bool x) {\n            return !x;\n        }\n        static _Bool (*foop)(_Bool) = _foofunc;\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.x = 1\n    assert p.x is True\n    with pytest.raises(OverflowError):\n        p.x = -1\n    with pytest.raises(TypeError):\n        p.x = 0.0\n    assert lib.foop(1) is False\n    assert lib.foop(True) is False\n    assert lib.foop(0) is True\n    pytest.raises(OverflowError, lib.foop, 42)\n    pytest.raises(TypeError, lib.foop, 0.0)\n    assert lib.foo(1) is False\n    assert lib.foo(True) is False\n    assert lib.foo(0) is True\n    pytest.raises(OverflowError, lib.foo, 42)\n    pytest.raises(TypeError, lib.foo, 0.0)\n    assert int(ffi.cast(\"_Bool\", long(1))) == 1\n    assert int(ffi.cast(\"_Bool\", long(0))) == 0\n    assert int(ffi.cast(\"_Bool\", long(-1))) == 1\n    assert int(ffi.cast(\"_Bool\", 10**200)) == 1\n    assert int(ffi.cast(\"_Bool\", 10**40000)) == 1\n    #\n    class Foo(object):\n        def __int__(self):\n            self.seen = 1\n            return result\n    f = Foo()\n    f.seen = 0\n    result = 42\n    assert int(ffi.cast(\"_Bool\", f)) == 1\n    assert f.seen\n    f.seen = 0\n    result = 0\n    assert int(ffi.cast(\"_Bool\", f)) == 0\n    assert f.seen\n    #\n    pytest.raises(TypeError, ffi.cast, \"_Bool\", [])\n\ndef test_bool_on_long_double():\n    if sys.platform == 'win32':\n        pytest.skip(\"_Bool not in MSVC\")\n    f = 1E-250\n    if f == 0.0 or f*f != 0.0:\n        pytest.skip(\"unexpected precision\")\n    ffi = FFI()\n    ffi.cdef(\"long double square(long double f); _Bool opposite(_Bool);\")\n    lib = ffi.verify(\"long double square(long double f) { return f*f; }\\n\"\n                     \"_Bool opposite(_Bool x) { return !x; }\")\n    f0 = lib.square(0.0)\n    f2 = lib.square(f)\n    f3 = lib.square(f * 2.0)\n    if repr(f2) == repr(f3):\n        pytest.skip(\"long double doesn't have enough precision\")\n    assert float(f0) == float(f2) == float(f3) == 0.0  # too tiny for 'double'\n    assert int(ffi.cast(\"_Bool\", f2)) == 1\n    assert int(ffi.cast(\"_Bool\", f3)) == 1\n    assert int(ffi.cast(\"_Bool\", f0)) == 0\n    pytest.raises(TypeError, lib.opposite, f2)\n\ndef test_cannot_pass_float():\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            ffi = FFI()\n            ffi.cdef(\"struct foo_s { %s x; };\\n\"\n                     \"int foo(%s);\" % (type, type))\n            lib = ffi.verify(\"\"\"\n                struct foo_s { %s x; };\n                int foo(%s arg) {\n                    return !arg;\n                }\n            \"\"\" % (type, type))\n            p = ffi.new(\"struct foo_s *\")\n            with pytest.raises(TypeError):\n                p.x = 0.0\n            assert lib.foo(42) == 0\n            assert lib.foo(0) == 1\n            pytest.raises(TypeError, lib.foo, 0.0)\n\ndef test_cast_from_int_type_to_bool():\n    ffi = FFI()\n    for basetype in ['char', 'short', 'int', 'long', 'long long']:\n        for sign in ['signed', 'unsigned']:\n            type = '%s %s' % (sign, basetype)\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"bool\", ffi.cast(type, 42))) == 1\n            assert int(ffi.cast(\"_Bool\", ffi.cast(type, 0))) == 0\n\ndef test_addressof():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        struct point_s { int x, y; };\n        struct foo_s { int z; struct point_s point; };\n        struct point_s sum_coord(struct point_s *point) {\n            struct point_s r;\n            r.x = point->x + point->y;\n            r.y = point->x - point->y;\n            return r;\n        }\n    \"\"\")\n    p = ffi.new(\"struct foo_s *\")\n    p.point.x = 16\n    p.point.y = 9\n    pytest.raises(TypeError, lib.sum_coord, p.point)\n    res = lib.sum_coord(ffi.addressof(p.point))\n    assert res.x == 25\n    assert res.y == 7\n    res2 = lib.sum_coord(ffi.addressof(res))\n    assert res2.x == 32\n    assert res2.y == 18\n    pytest.raises(TypeError, lib.sum_coord, res2)\n\ndef test_callback_in_thread():\n    if sys.platform == 'win32':\n        pytest.skip(\"pthread only\")\n    import os, subprocess\n    from cffi import _imp_emulation as imp\n    arg = os.path.join(os.path.dirname(__file__), 'callback_in_thread.py')\n    g = subprocess.Popen([sys.executable, arg,\n                          os.path.dirname(imp.find_module('cffi')[1])])\n    result = g.wait()\n    assert result == 0\n\ndef test_keepalive_lib():\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del ffi\n    import gc; gc.collect()       # lib stays alive\n    assert lib_r() is not None\n    assert ffi_r() is not None\n    assert func() == 42\n\ndef test_keepalive_ffi():\n    ffi = FFI()\n    ffi.cdef(\"int foobar(void);\")\n    lib = ffi.verify(\"int foobar(void) { return 42; }\")\n    func = lib.foobar\n    ffi_r = weakref.ref(ffi)\n    lib_r = weakref.ref(lib)\n    del lib\n    import gc; gc.collect()       # ffi stays alive\n    assert ffi_r() is not None\n    assert lib_r() is not None\n    assert func() == 42\n\ndef test_FILE_stored_in_stdout():\n    if not sys.platform.startswith('linux') or is_musl:\n        pytest.skip(\"likely, we cannot assign to stdout\")\n    ffi = FFI()\n    ffi.cdef(\"int printf(const char *, ...); FILE *setstdout(FILE *);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *setstdout(FILE *f) {\n            FILE *result = stdout;\n            stdout = f;\n            return result;\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    old_stdout = lib.setstdout(fw1)\n    try:\n        #\n        fw1.write(b\"X\")\n        r = lib.printf(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n        fw1.close()\n        assert r == len(\"hello, 42!\\n\")\n        #\n    finally:\n        lib.setstdout(old_stdout)\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_FILE_stored_explicitly():\n    ffi = FFI()\n    ffi.cdef(\"int myprintf11(const char *, int); extern FILE *myfile;\")\n    lib = ffi.verify(\"\"\"\n        #include <stdio.h>\n        FILE *myfile;\n        int myprintf11(const char *out, int value) {\n            return fprintf(myfile, out, value);\n        }\n    \"\"\")\n    import os\n    fdr, fdw = os.pipe()\n    fw1 = os.fdopen(fdw, 'wb', 256)\n    lib.myfile = ffi.cast(\"FILE *\", fw1)\n    #\n    fw1.write(b\"X\")\n    r = lib.myprintf11(b\"hello, %d!\\n\", ffi.cast(\"int\", 42))\n    fw1.close()\n    assert r == len(\"hello, 42!\\n\")\n    #\n    result = os.read(fdr, 256)\n    os.close(fdr)\n    # the 'X' might remain in the user-level buffer of 'fw1' and\n    # end up showing up after the 'hello, 42!\\n'\n    assert result == b\"Xhello, 42!\\n\" or result == b\"hello, 42!\\nX\"\n\ndef test_global_array_with_missing_length():\n    ffi = FFI()\n    ffi.cdef(\"extern int fooarray[];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int *'\")\n\ndef test_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"extern int fooarray[...];\")\n    lib = ffi.verify(\"int fooarray[50];\")\n    assert repr(lib.fooarray).startswith(\"<cdata 'int[50]'\")\n\ndef test_bad_global_array_with_dotdotdot_length():\n    ffi = FFI()\n    ffi.cdef(\"extern int fooarray[...];\")\n    pytest.raises(VerificationError, ffi.verify, \"char fooarray[23];\")\n\ndef test_struct_containing_struct():\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { ...; }; struct bar_s { struct foo_s f; ...; };\")\n    ffi.verify(\"struct foo_s { int x; }; struct bar_s { struct foo_s f; };\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"struct foo_s { struct bar_s f; ...; }; struct bar_s { ...; };\")\n    ffi.verify(\"struct bar_s { int x; }; struct foo_s { struct bar_s f; };\")\n\ndef test_struct_returned_by_func():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; foo_t myfunc(void);\")\n    e = pytest.raises(TypeError, ffi.verify,\n                       \"typedef struct { int x; } foo_t; \"\n                       \"foo_t myfunc(void) { foo_t x = { 42 }; return x; }\")\n    assert str(e.value) == (\n        \"function myfunc: 'foo_t' is used as result type, but is opaque\")\n\ndef test_include():\n    ffi1 = FFI()\n    ffi1.cdef(\"typedef struct { int x; ...; } foo_t;\")\n    ffi1.verify(\"typedef struct { int y, x; } foo_t;\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(foo_t *);\")\n    lib = ffi2.verify(\"typedef struct { int y, x; } foo_t;\"\n                      \"int myfunc(foo_t *p) { return 42 * p->x; }\")\n    res = lib.myfunc(ffi2.new(\"foo_t *\", {'x': 10}))\n    assert res == 420\n    res = lib.myfunc(ffi1.new(\"foo_t *\", {'x': -10}))\n    assert res == -420\n\ndef test_include_enum():\n    ffi1 = FFI()\n    ffi1.cdef(\"enum foo_e { AA, ... };\")\n    lib1 = ffi1.verify(\"enum foo_e { CC, BB, AA };\")\n    ffi2 = FFI()\n    ffi2.include(ffi1)\n    ffi2.cdef(\"int myfunc(enum foo_e);\")\n    lib2 = ffi2.verify(\"enum foo_e { CC, BB, AA };\"\n                       \"int myfunc(enum foo_e x) { return (int)x; }\")\n    res = lib2.myfunc(lib2.AA)\n    assert res == 2\n\ndef test_named_pointer_as_argument():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; } *mystruct_p;\\n\"\n             \"mystruct_p ff5a(mystruct_p);\")\n    lib = ffi.verify(\"typedef struct { int x; } *mystruct_p;\\n\"\n                     \"mystruct_p ff5a(mystruct_p p) { p->x += 40; return p; }\")\n    p = ffi.new(\"mystruct_p\", [-2])\n    q = lib.ff5a(p)\n    assert q == p\n    assert p.x == 38\n\ndef test_enum_size():\n    cases = [('123',           4, 4294967295),\n             ('4294967295U',   4, 4294967295),\n             ('-123',          4, -1),\n             ('-2147483647-1', 4, -1),\n             ]\n    if FFI().sizeof(\"long\") == 8:\n        cases += [('4294967296L',        8, 2**64-1),\n                  ('%dUL' % (2**64-1),   8, 2**64-1),\n                  ('-2147483649L',       8, -1),\n                  ('%dL-1L' % (1-2**63), 8, -1)]\n    for hidden_value, expected_size, expected_minus1 in cases:\n        if sys.platform == 'win32' and 'U' in hidden_value:\n            continue   # skipped on Windows\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n        assert lib.AA == 0\n        assert lib.BB == eval(hidden_value.replace('U', '').replace('L', ''))\n        assert ffi.sizeof(\"enum foo_e\") == expected_size\n        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n    # test with the large value hidden:\n    # disabled so far, doesn't work\n##    for hidden_value, expected_size, expected_minus1 in cases:\n##        ffi = FFI()\n##        ffi.cdef(\"enum foo_e { AA, BB, ... };\")\n##        lib = ffi.verify(\"enum foo_e { AA, BB=%s };\" % hidden_value)\n##        assert lib.AA == 0\n##        assert ffi.sizeof(\"enum foo_e\") == expected_size\n##        assert int(ffi.cast(\"enum foo_e\", -1)) == expected_minus1\n\ndef test_enum_bug118():\n    maxulong = 256 ** FFI().sizeof(\"unsigned long\") - 1\n    for c1, c2, c2c in [(0xffffffff, -1, ''),\n                        (maxulong, -1, ''),\n                        (-1, 0xffffffff, 'U'),\n                        (-1, maxulong, 'UL')]:\n        if c2c and sys.platform == 'win32':\n            continue     # enums may always be signed with MSVC\n        ffi = FFI()\n        ffi.cdef(\"enum foo_e { AA=%s };\" % c1)\n        e = pytest.raises(VerificationError, ffi.verify,\n                           \"enum foo_e { AA=%s%s };\" % (c2, c2c))\n        assert str(e.value) == ('enum foo_e: AA has the real value %d, not %d'\n                                % (c2, c1))\n\ndef test_string_to_voidp_arg():\n    ffi = FFI()\n    ffi.cdef(\"int myfunc(void *);\")\n    lib = ffi.verify(\"int myfunc(void *p) { return ((signed char *)p)[0]; }\")\n    res = lib.myfunc(b\"hi!\")\n    assert res == ord(b\"h\")\n    p = ffi.new(\"char[]\", b\"gah\")\n    res = lib.myfunc(p)\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"void *\", p))\n    assert res == ord(b\"g\")\n    res = lib.myfunc(ffi.cast(\"int *\", p))\n    assert res == ord(b\"g\")\n\ndef test_callback_indirection():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        static int (*python_callback)(int how_many, int *values);\n        int (*const c_callback)(int,...);   /* pass this ptr to C routines */\n        int some_c_function(int(*cb)(int,...));\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #include <stdarg.h>\n        #ifdef _WIN32\n        #include <malloc.h>\n        #define alloca _alloca\n        #else\n        # ifdef __FreeBSD__\n        #  include <stdlib.h>\n        # else\n        #  include <alloca.h>\n        # endif\n        #endif\n        static int (*python_callback)(int how_many, int *values);\n        static int c_callback(int how_many, ...) {\n            va_list ap;\n            /* collect the \"...\" arguments into the values[] array */\n            int i, *values = alloca((size_t)how_many * sizeof(int));\n            va_start(ap, how_many);\n            for (i=0; i<how_many; i++)\n                values[i] = va_arg(ap, int);\n            va_end(ap);\n            return python_callback(how_many, values);\n        }\n        int some_c_function(int(*cb)(int,...)) {\n            int result = cb(2, 10, 20);\n            result += cb(3, 30, 40, 50);\n            return result;\n        }\n    \"\"\")\n    seen = []\n    @ffi.callback(\"int(int, int*)\")\n    def python_callback(how_many, values):\n        seen.append([values[i] for i in range(how_many)])\n        return 42\n    lib.python_callback = python_callback\n\n    res = lib.some_c_function(lib.c_callback)\n    assert res == 84\n    assert seen == [[10, 20], [30, 40, 50]]\n\ndef test_floatstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"float sum3floats(float *);\")\n    lib = ffi.verify(\"\"\"\n        float sum3floats(float *f) {\n            return f[0] + f[1] + f[2];\n        }\n    \"\"\")\n    assert lib.sum3floats((1.5, 2.5, 3.5)) == 7.5\n    p = ffi.new(\"float[]\", (1.5, 2.5, 3.5))\n    assert lib.sum3floats(p) == 7.5\n\ndef test_charstar_argument():\n    ffi = FFI()\n    ffi.cdef(\"char sum3chars(char *);\")\n    lib = ffi.verify(\"\"\"\n        char sum3chars(char *f) {\n            return (char)(f[0] + f[1] + f[2]);\n        }\n    \"\"\")\n    assert lib.sum3chars((b'\\x10', b'\\x20', b'\\x30')) == b'\\x60'\n    p = ffi.new(\"char[]\", b'\\x10\\x20\\x30')\n    assert lib.sum3chars(p) == b'\\x60'\n\ndef test_passing_string_or_NULL():\n    ffi = FFI()\n    ffi.cdef(\"int seeme1(char *); int seeme2(int *);\")\n    lib = ffi.verify(\"\"\"\n        int seeme1(char *x) {\n            return (x == NULL);\n        }\n        int seeme2(int *x) {\n            return (x == NULL);\n        }\n    \"\"\")\n    assert lib.seeme1(b\"foo\") == 0\n    assert lib.seeme1(ffi.NULL) == 1\n    assert lib.seeme2([42, 43]) == 0\n    assert lib.seeme2(ffi.NULL) == 1\n    pytest.raises(TypeError, lib.seeme1, None)\n    pytest.raises(TypeError, lib.seeme2, None)\n    pytest.raises(TypeError, lib.seeme1, 0.0)\n    pytest.raises(TypeError, lib.seeme2, 0.0)\n    pytest.raises(TypeError, lib.seeme1, 0)\n    pytest.raises(TypeError, lib.seeme2, 0)\n    zeroL  = 99999999999999999999\n    zeroL -= 99999999999999999999\n    pytest.raises(TypeError, lib.seeme2, zeroL)\n\ndef test_typeof_function():\n    ffi = FFI()\n    ffi.cdef(\"int foo(int, char);\")\n    lib = ffi.verify(\"int foo(int x, char y) { (void)x; (void)y; return 42; }\")\n    ctype = ffi.typeof(lib.foo)\n    assert len(ctype.args) == 2\n    assert ctype.result == ffi.typeof(\"int\")\n\ndef test_call_with_voidstar_arg():\n    ffi = FFI()\n    ffi.cdef(\"int f(void *);\")\n    lib = ffi.verify(\"int f(void *x) { return ((char*)x)[0]; }\")\n    assert lib.f(b\"foobar\") == ord(b\"f\")\n\ndef test_dir():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void somefunc(void);\n                extern int somevar, somearray[2];\n                static char *const sv2;\n                enum my_e { AA, BB, ... };\n                #define FOO ...\"\"\")\n    lib = ffi.verify(\"\"\"void somefunc(void) { }\n                        int somevar, somearray[2];\n                        #define sv2 \"text\"\n                        enum my_e { AA, BB };\n                        #define FOO 42\"\"\")\n    assert dir(lib) == ['AA', 'BB', 'FOO', 'somearray',\n                        'somefunc', 'somevar', 'sv2']\n\ndef test_typeof_func_with_struct_argument():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct s { int a; }; int foo(struct s);\"\"\")\n    lib = ffi.verify(\"\"\"struct s { int a; };\n                        int foo(struct s x) { return x.a; }\"\"\")\n    s = ffi.new(\"struct s *\", [-1234])\n    m = lib.foo(s[0])\n    assert m == -1234\n    assert repr(ffi.typeof(lib.foo)) == \"<ctype 'int(*)(struct s)'>\"\n\ndef test_bug_const_char_ptr_array_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"extern const char *a[...];\"\"\")\n    lib = ffi.verify(\"\"\"const char *a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'char *[5]'>\"\n\ndef test_bug_const_char_ptr_array_2():\n    from cffi import FFI     # ignore warnings\n    ffi = FFI()\n    ffi.cdef(\"\"\"extern const int a[];\"\"\")\n    lib = ffi.verify(\"\"\"const int a[5];\"\"\")\n    assert repr(ffi.typeof(lib.a)) == \"<ctype 'int *'>\"\n\ndef _test_various_calls(force_libffi):\n    cdef_source = \"\"\"\n    extern int xvalue;\n    extern long long ivalue, rvalue;\n    extern float fvalue;\n    extern double dvalue;\n    extern long double Dvalue;\n    signed char tf_bb(signed char x, signed char c);\n    unsigned char tf_bB(signed char x, unsigned char c);\n    short tf_bh(signed char x, short c);\n    unsigned short tf_bH(signed char x, unsigned short c);\n    int tf_bi(signed char x, int c);\n    unsigned int tf_bI(signed char x, unsigned int c);\n    long tf_bl(signed char x, long c);\n    unsigned long tf_bL(signed char x, unsigned long c);\n    long long tf_bq(signed char x, long long c);\n    unsigned long long tf_bQ(signed char x, unsigned long long c);\n    float tf_bf(signed char x, float c);\n    double tf_bd(signed char x, double c);\n    long double tf_bD(signed char x, long double c);\n    \"\"\"\n    if force_libffi:\n        cdef_source = (cdef_source\n            .replace('tf_', '(*const tf_')\n            .replace('(signed char x', ')(signed char x'))\n    ffi = FFI()\n    ffi.cdef(cdef_source)\n    lib = ffi.verify(\"\"\"\n    int xvalue;\n    long long ivalue, rvalue;\n    float fvalue;\n    double dvalue;\n    long double Dvalue;\n\n    typedef signed char b_t;\n    typedef unsigned char B_t;\n    typedef short h_t;\n    typedef unsigned short H_t;\n    typedef int i_t;\n    typedef unsigned int I_t;\n    typedef long l_t;\n    typedef unsigned long L_t;\n    typedef long long q_t;\n    typedef unsigned long long Q_t;\n    typedef float f_t;\n    typedef double d_t;\n    typedef long double D_t;\n    #define S(letter)  xvalue = (int)x; letter##value = (letter##_t)c;\n    #define R(letter)  return (letter##_t)rvalue;\n\n    signed char tf_bb(signed char x, signed char c) { S(i) R(b) }\n    unsigned char tf_bB(signed char x, unsigned char c) { S(i) R(B) }\n    short tf_bh(signed char x, short c) { S(i) R(h) }\n    unsigned short tf_bH(signed char x, unsigned short c) { S(i) R(H) }\n    int tf_bi(signed char x, int c) { S(i) R(i) }\n    unsigned int tf_bI(signed char x, unsigned int c) { S(i) R(I) }\n    long tf_bl(signed char x, long c) { S(i) R(l) }\n    unsigned long tf_bL(signed char x, unsigned long c) { S(i) R(L) }\n    long long tf_bq(signed char x, long long c) { S(i) R(q) }\n    unsigned long long tf_bQ(signed char x, unsigned long long c) { S(i) R(Q) }\n    float tf_bf(signed char x, float c) { S(f) R(f) }\n    double tf_bd(signed char x, double c) { S(d) R(d) }\n    long double tf_bD(signed char x, long double c) { S(D) R(D) }\n    \"\"\")\n    lib.rvalue = 0x7182838485868788\n    for kind, cname in [('b', 'signed char'),\n                        ('B', 'unsigned char'),\n                        ('h', 'short'),\n                        ('H', 'unsigned short'),\n                        ('i', 'int'),\n                        ('I', 'unsigned int'),\n                        ('l', 'long'),\n                        ('L', 'unsigned long'),\n                        ('q', 'long long'),\n                        ('Q', 'unsigned long long'),\n                        ('f', 'float'),\n                        ('d', 'double'),\n                        ('D', 'long double')]:\n        sign = +1 if 'unsigned' in cname else -1\n        lib.xvalue = 0\n        lib.ivalue = 0\n        lib.fvalue = 0\n        lib.dvalue = 0\n        lib.Dvalue = 0\n        fun = getattr(lib, 'tf_b' + kind)\n        res = fun(-42, sign * 99)\n        if kind == 'D':\n            res = float(res)\n        assert res == int(ffi.cast(cname, 0x7182838485868788))\n        assert lib.xvalue == -42\n        if kind in 'fdD':\n            assert float(getattr(lib, kind + 'value')) == -99.0\n        else:\n            assert lib.ivalue == sign * 99\n\ndef test_various_calls_direct():\n    _test_various_calls(force_libffi=False)\n\ndef test_various_calls_libffi():\n    _test_various_calls(force_libffi=True)\n\ndef test_ptr_to_opaque():\n    ffi = FFI()\n    ffi.cdef(\"typedef ... foo_t; int f1(foo_t*); foo_t *f2(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <stdlib.h>\n        typedef struct { int x; } foo_t;\n        int f1(foo_t* p) {\n            int x = p->x;\n            free(p);\n            return x;\n        }\n        foo_t *f2(int x) {\n            foo_t *p = malloc(sizeof(foo_t));\n            p->x = x;\n            return p;\n        }\n    \"\"\")\n    p = lib.f2(42)\n    x = lib.f1(p)\n    assert x == 42\n\ndef _run_in_multiple_threads(test1):\n    test1()\n    import sys\n    try:\n        import thread\n    except ImportError:\n        import _thread as thread\n    errors = []\n    def wrapper(lock):\n        try:\n            test1()\n        except:\n            errors.append(sys.exc_info())\n        lock.release()\n    locks = []\n    for i in range(10):\n        _lock = thread.allocate_lock()\n        _lock.acquire()\n        thread.start_new_thread(wrapper, (_lock,))\n        locks.append(_lock)\n    for _lock in locks:\n        _lock.acquire()\n        if errors:\n            raise errors[0][1]\n\ndef test_errno_working_even_with_pypys_jit():\n    # NOTE: on some platforms, to work correctly, this test needs to be\n    # compiled with -pthread.  Otherwise, the accesses to errno done from f()\n    # are compiled by assuming this small library won't be used from multiple\n    # threads, which is wrong.  If you see failures _and_ if you pass your\n    # own CFLAGS environment variable, please make sure \"-pthread\" is in it.\n    ffi = FFI()\n    ffi.cdef(\"int f(int);\")\n    lib = ffi.verify(\"\"\"\n        #include <errno.h>\n        int f(int x) { return (errno = errno + x); }\n    \"\"\")\n    @_run_in_multiple_threads\n    def test1():\n        ffi.errno = 0\n        for i in range(10000):\n            e = lib.f(1)\n            assert e == i + 1\n            assert ffi.errno == e\n        for i in range(10000):\n            ffi.errno = i\n            e = lib.f(42)\n            assert e == i + 42\n\ndef test_getlasterror_working_even_with_pypys_jit():\n    if sys.platform != 'win32':\n        pytest.skip(\"win32-only test\")\n    ffi = FFI()\n    ffi.cdef(\"void SetLastError(DWORD);\")\n    lib = ffi.dlopen(\"Kernel32.dll\")\n    @_run_in_multiple_threads\n    def test1():\n        for i in range(10000):\n            n = (1 << 29) + i\n            lib.SetLastError(n)\n            assert ffi.getwinerror()[0] == n\n\ndef test_verify_dlopen_flags():\n    # Careful with RTLD_GLOBAL.  If by chance the FFI is not deleted\n    # promptly, like on PyPy, then other tests may see the same\n    # exported symbols as well.  So we must not export a simple name\n    # like 'foo'!\n    ffi1 = FFI()\n    ffi1.cdef(\"extern int foo_verify_dlopen_flags;\")\n\n    lib1 = ffi1.verify(\"int foo_verify_dlopen_flags;\",\n                       flags=ffi1.RTLD_GLOBAL | ffi1.RTLD_LAZY)\n    lib2 = get_second_lib()\n\n    lib1.foo_verify_dlopen_flags = 42\n    assert lib2.foo_verify_dlopen_flags == 42\n    lib2.foo_verify_dlopen_flags += 1\n    assert lib1.foo_verify_dlopen_flags == 43\n\ndef get_second_lib():\n    # Hack, using modulename makes the test fail\n    ffi2 = FFI()\n    ffi2.cdef(\"extern int foo_verify_dlopen_flags;\")\n    lib2 = ffi2.verify(\"int foo_verify_dlopen_flags;\",\n                       flags=ffi2.RTLD_GLOBAL | ffi2.RTLD_LAZY)\n    return lib2\n\ndef test_consider_not_implemented_function_type():\n    ffi = FFI()\n    ffi.cdef(\"typedef union { int a; float b; } Data;\"\n             \"typedef struct { int a:2; } MyStr;\"\n             \"typedef void (*foofunc_t)(Data);\"\n             \"typedef Data (*bazfunc_t)(void);\"\n             \"typedef MyStr (*barfunc_t)(void);\")\n    fooptr = ffi.cast(\"foofunc_t\", 123)\n    bazptr = ffi.cast(\"bazfunc_t\", 123)\n    barptr = ffi.cast(\"barfunc_t\", 123)\n    # assert did not crash so far\n    e = pytest.raises(NotImplementedError, fooptr, ffi.new(\"Data *\"))\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as argument by libffi.  Unions are only \"\n        \"supported as argument if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = pytest.raises(NotImplementedError, bazptr)\n    assert str(e.value) == (\n        \"ctype 'Data' not supported as return value by libffi.  Unions are \"\n        \"only supported as return value if the function is 'API mode' and \"\n        \"non-variadic (i.e. declared inside ffibuilder.cdef()+\"\n        \"ffibuilder.set_source() and not taking a final '...' argument)\")\n    e = pytest.raises(NotImplementedError, barptr)\n    assert str(e.value) == (\n        \"ctype 'MyStr' not supported as return value.  It is a struct with \"\n        \"bit fields, which libffi does not support.  Such structs are only \"\n        \"supported as return value if the function is 'API mode' and non-\"\n        \"variadic (i.e. declared inside ffibuilder.cdef()+ffibuilder.\"\n        \"set_source() and not taking a final '...' argument)\")\n\ndef test_verify_extra_arguments():\n    ffi = FFI()\n    ffi.cdef(\"#define ABA ...\")\n    lib = ffi.verify(\"\", define_macros=[('ABA', '42')])\n    assert lib.ABA == 42\n\ndef test_implicit_unicode_on_windows():\n    if sys.platform != 'win32':\n        pytest.skip(\"win32-only test\")\n    ffi = FFI()\n    e = pytest.raises(FFIError, ffi.cdef, \"int foo(LPTSTR);\")\n    assert str(e.value) == (\"The Windows type 'LPTSTR' is only available after\"\n                            \" you call ffi.set_unicode()\")\n    for with_unicode in [True, False]:\n        ffi = FFI()\n        ffi.set_unicode(with_unicode)\n        ffi.cdef(\"\"\"\n            DWORD GetModuleFileName(HMODULE hModule, LPTSTR lpFilename,\n                                    DWORD nSize);\n        \"\"\")\n        lib = ffi.verify(\"\"\"\n            #include <windows.h>\n        \"\"\", libraries=['Kernel32'])\n        outbuf = ffi.new(\"TCHAR[]\", 200)\n        n = lib.GetModuleFileName(ffi.NULL, outbuf, 500)\n        assert 0 < n < 500\n        for i in range(n):\n            #print repr(outbuf[i])\n            assert ord(outbuf[i]) != 0\n        assert ord(outbuf[n]) == 0\n        assert ord(outbuf[0]) < 128     # should be a letter, or '\\'\n\ndef test_use_local_dir():\n    ffi = FFI()\n    lib = ffi.verify(\"\", modulename=\"test_use_local_dir\")\n    this_dir = os.path.dirname(__file__)\n    pycache_files = os.listdir(os.path.join(this_dir, '__pycache__'))\n    assert any('test_use_local_dir' in s for s in pycache_files)\n\ndef test_define_known_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 0x123\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_define_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"#define FOO 123\")\n    e = pytest.raises(VerificationError, ffi.verify, \"#define FOO 124\")\n    assert str(e.value).endswith(\"FOO has the real value 124, not 123\")\n\ndef test_static_const_int_known_value():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOO = 0x123;\")\n    lib = ffi.verify(\"#define FOO 0x123\")\n    assert lib.FOO == 0x123\n\ndef test_static_const_int_wrong_value():\n    ffi = FFI()\n    ffi.cdef(\"static const int FOO = 123;\")\n    e = pytest.raises(VerificationError, ffi.verify, \"#define FOO 124\")\n    assert str(e.value).endswith(\"FOO has the real value 124, not 123\")\n\ndef test_const_struct_global():\n    ffi = FFI()\n    ffi.cdef(\"typedef struct { int x; ...; } T; const T myglob;\")\n    lib = ffi.verify(\"typedef struct { double y; int x; } T;\"\n                     \"const T myglob = { 0.1, 42 };\")\n    assert ffi.typeof(lib.myglob) == ffi.typeof(\"T\")\n    assert lib.myglob.x == 42\n\ndef test_dont_support_int_dotdotdot():\n    ffi = FFI()\n    ffi.cdef(\"typedef int... t1;\")\n    e = pytest.raises(VerificationError, ffi.verify, \"\")\n    assert str(e.value) == (\"feature not supported with ffi.verify(), but only \"\n                            \"with ffi.set_source(): 'typedef int... t1'\")\n    ffi = FFI()\n    ffi.cdef(\"typedef double ... t1;\")\n    e = pytest.raises(VerificationError, ffi.verify, \"\")\n    assert str(e.value) == (\"feature not supported with ffi.verify(), but only \"\n                         \"with ffi.set_source(): 'typedef float... t1'\")\n\ndef test_const_fields():\n    ffi = FFI()\n    ffi.cdef(\"\"\"struct foo_s { const int a; void *const b; };\"\"\")\n    ffi.verify(\"\"\"struct foo_s { const int a; void *const b; };\"\"\")\n    foo_s = ffi.typeof(\"struct foo_s\")\n    assert foo_s.fields[0][0] == 'a'\n    assert foo_s.fields[0][1].type is ffi.typeof(\"int\")\n    assert foo_s.fields[1][0] == 'b'\n    assert foo_s.fields[1][1].type is ffi.typeof(\"void *\")\n\ndef test_win32_calling_convention_0():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int call1(int(__cdecl   *cb)(int));\n        int (*const call2)(int(__stdcall *cb)(int));\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __stdcall  /* nothing */\n        #endif\n        int call1(int(*cb)(int)) {\n            int i, result = 0;\n            //printf(\"call1: cb = %p\\n\", cb);\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n        int call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            //printf(\"call2: cb = %p\\n\", cb);\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n    \"\"\")\n    @ffi.callback(\"int(int)\")\n    def cb1(x):\n        return x * 2\n    @ffi.callback(\"int __stdcall(int)\")\n    def cb2(x):\n        return x * 3\n    #print 'cb1 =', cb1\n    res = lib.call1(cb1)\n    assert res == 500*999*2\n    #print 'cb2 =', cb2\n    #print ffi.typeof(lib.call2)\n    #print 'call2 =', lib.call2\n    res = lib.call2(cb2)\n    #print '...'\n    assert res == -500*999*3\n    #print 'done'\n    if sys.platform == 'win32' and sys.maxsize < 2**32:\n        assert '__stdcall' in str(ffi.typeof(cb2))\n        assert '__stdcall' not in str(ffi.typeof(cb1))\n        pytest.raises(TypeError, lib.call1, cb2)\n        pytest.raises(TypeError, lib.call2, cb1)\n    else:\n        assert '__stdcall' not in str(ffi.typeof(cb2))\n        assert ffi.typeof(cb2) is ffi.typeof(cb1)\n\ndef test_win32_calling_convention_1():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int __cdecl   call1(int(__cdecl   *cb)(int));\n        int __stdcall call2(int(__stdcall *cb)(int));\n        int (__cdecl   *const cb1)(int);\n        int (__stdcall *const cb2)(int);\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        int __cdecl   cb1(int x) { return x * 2; }\n        int __stdcall cb2(int x) { return x * 3; }\n\n        int __cdecl call1(int(__cdecl *cb)(int)) {\n            int i, result = 0;\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb1 = %p\\n\", cb, (void *)cb1);\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n        int __stdcall call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb2 = %p\\n\", cb, (void *)cb2);\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            //printf(\"result = %d\\n\", result);\n            return result;\n        }\n    \"\"\")\n    assert lib.call1(lib.cb1) == 500*999*2\n    assert lib.call2(lib.cb2) == -500*999*3\n\ndef test_win32_calling_convention_2():\n    # any mistake in the declaration of plain function (including the\n    # precise argument types and, here, the calling convention) are\n    # automatically corrected.  But this does not apply to the 'cb'\n    # function pointer argument.\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int __stdcall call1(int(__cdecl   *cb)(int));\n        int __cdecl   call2(int(__stdcall *cb)(int));\n        int (__cdecl   *const cb1)(int);\n        int (__stdcall *const cb2)(int);\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        int __cdecl call1(int(__cdecl *cb)(int)) {\n            int i, result = 0;\n            for (i = 0; i < 1000; i++)\n                result += cb(i);\n            return result;\n        }\n        int __stdcall call2(int(__stdcall *cb)(int)) {\n            int i, result = 0;\n            for (i = 0; i < 1000; i++)\n                result += cb(-i);\n            return result;\n        }\n        int __cdecl   cb1(int x) { return x * 2; }\n        int __stdcall cb2(int x) { return x * 3; }\n    \"\"\")\n    assert lib.call1(lib.cb1) == 500*999*2\n    assert lib.call2(lib.cb2) == -500*999*3\n\ndef test_win32_calling_convention_3():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        struct point { int x, y; };\n\n        int (*const cb1)(struct point);\n        int (__stdcall *const cb2)(struct point);\n\n        struct point __stdcall call1(int(*cb)(struct point));\n        struct point call2(int(__stdcall *cb)(struct point));\n    \"\"\")\n    lib = ffi.verify(r\"\"\"\n        #ifndef _MSC_VER\n        #  define __cdecl\n        #  define __stdcall\n        #endif\n        struct point { int x, y; };\n        int           cb1(struct point pt) { return pt.x + 10 * pt.y; }\n        int __stdcall cb2(struct point pt) { return pt.x + 100 * pt.y; }\n        struct point __stdcall call1(int(__cdecl *cb)(struct point)) {\n            int i;\n            struct point result = { 0, 0 };\n            //printf(\"here1\\n\");\n            //printf(\"cb = %p, cb1 = %p\\n\", cb, (void *)cb1);\n            for (i = 0; i < 1000; i++) {\n                struct point p = { i, -i };\n                int r = cb(p);\n                result.x += r;\n                result.y -= r;\n            }\n            return result;\n        }\n        struct point __cdecl call2(int(__stdcall *cb)(struct point)) {\n            int i;\n            struct point result = { 0, 0 };\n            for (i = 0; i < 1000; i++) {\n                struct point p = { -i, i };\n                int r = cb(p);\n                result.x += r;\n                result.y -= r;\n            }\n            return result;\n        }\n    \"\"\")\n    if sys.platform == 'win32' and sys.maxsize < 2**32:\n        pytest.raises(TypeError, lib.call1, lib.cb2)\n        pytest.raises(TypeError, lib.call2, lib.cb1)\n    pt = lib.call1(lib.cb1)\n    assert (pt.x, pt.y) == (-9*500*999, 9*500*999)\n    pt = lib.call2(lib.cb2)\n    assert (pt.x, pt.y) == (99*500*999, -99*500*999)\n\ndef _only_test_on_linux_intel():\n    if not sys.platform.startswith('linux'):\n        pytest.skip('only running the memory-intensive test on Linux')\n    import platform\n    machine = platform.machine()\n    if 'x86' not in machine and 'x64' not in machine:\n        pytest.skip('only running the memory-intensive test on x86/x64')\n\ndef test_ffi_gc_size_arg():\n    # with PyPy's GC, these calls to ffi.gc() would rapidly consume\n    # 40 GB of RAM without the third argument\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    for i in range(2000):\n        p = lib.malloc(20*1024*1024)    # 20 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 20*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 20*1024*1024)\n        del p\n\ndef test_ffi_gc_size_arg_2():\n    # a variant of the above: this \"attack\" works on cpython's cyclic gc too\n    # and I found no obvious way to prevent that.  So for now, this test\n    # is skipped on CPython, where it eats all the memory.\n    if '__pypy__' not in sys.builtin_module_names:\n        pytest.skip(\"find a way to tweak the cyclic GC of CPython\")\n    _only_test_on_linux_intel()\n    ffi = FFI()\n    ffi.cdef(\"void *malloc(size_t); void free(void *);\")\n    lib = ffi.verify(r\"\"\"\n        #include <stdlib.h>\n    \"\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = lib.malloc(50*1024*1024)    # 50 MB\n        p1 = ffi.cast(\"char *\", p)\n        for j in range(0, 50*1024*1024, 4096):\n            p1[j] = b'!'\n        p = ffi.gc(p, lib.free, 50*1024*1024)\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n\ndef test_ffi_new_with_cycles():\n    # still another variant, with ffi.new()\n    if '__pypy__' not in sys.builtin_module_names:\n        pytest.skip(\"find a way to tweak the cyclic GC of CPython\")\n    ffi = FFI()\n    ffi.cdef(\"\")\n    lib = ffi.verify(\"\")\n    class X(object):\n        pass\n    for i in range(2000):\n        p = ffi.new(\"char[]\", 50*1024*1024)    # 50 MB\n        for j in range(0, 50*1024*1024, 4096):\n            p[j] = b'!'\n        x = X()\n        x.p = p\n        x.cyclic = x\n        del p, x\n\ndef test_arithmetic_in_cdef():\n    for a in [0, 11, 15]:\n        ffi = FFI()\n        ffi.cdef(\"\"\"\n            enum FOO {\n                DIVNN = ((-?) / (-3)),\n                DIVNP = ((-?) / (+3)),\n                DIVPN = ((+?) / (-3)),\n                MODNN = ((-?) % (-3)),\n                MODNP = ((-?) % (+3)),\n                MODPN = ((+?) % (-3)),\n                };\n        \"\"\".replace('?', str(a)))\n        lib = ffi.verify(\"\"\"\n            enum FOO {\n                DIVNN = ((-?) / (-3)),\n                DIVNP = ((-?) / (+3)),\n                DIVPN = ((+?) / (-3)),\n                MODNN = ((-?) % (-3)),\n                MODNP = ((-?) % (+3)),\n                MODPN = ((+?) % (-3)),\n                };\n        \"\"\".replace('?', str(a)))\n        # the verify() crashes if the values in the enum are different from\n        # the values we computed ourselves from the cdef()\n\ndef test_passing_large_list():\n    ffi = FFI()\n    ffi.cdef(\"\"\"void passing_large_list(long[]);\"\"\")\n    lib = ffi.verify(\"\"\"\n        static void passing_large_list(long a[]) { }\n    \"\"\")\n    arg = list(range(20000000))\n    lib.passing_large_list(arg)\n    # assert did not segfault\n", "testing/cffi0/test_parsing.py": "import sys, re\nimport pytest\nfrom cffi import FFI, FFIError, CDefError, VerificationError\nfrom .backend_tests import needs_dlopen_none\nfrom testing.support import is_musl\n\n\nclass FakeBackend(object):\n\n    def nonstandard_integer_types(self):\n        return {}\n\n    def sizeof(self, name):\n        return 1\n\n    def load_library(self, name, flags):\n        if sys.platform == 'win32':\n            assert name is None or \"msvcr\" in name\n        else:\n            assert name is None or \"libc\" in name or \"libm\" in name\n        return FakeLibrary()\n\n    def new_function_type(self, args, result, has_varargs):\n        args = [arg.cdecl for arg in args]\n        result = result.cdecl\n        return FakeType(\n            '<func (%s), %s, %s>' % (', '.join(args), result, has_varargs))\n\n    def new_primitive_type(self, name):\n        assert name == name.lower()\n        return FakeType('<%s>' % name)\n\n    def new_pointer_type(self, itemtype):\n        return FakeType('<pointer to %s>' % (itemtype,))\n\n    def new_struct_type(self, name):\n        return FakeStruct(name)\n\n    def complete_struct_or_union(self, s, fields, tp=None,\n                                 totalsize=-1, totalalignment=-1, sflags=0):\n        assert isinstance(s, FakeStruct)\n        s.fields = fields\n\n    def new_array_type(self, ptrtype, length):\n        return FakeType('<array %s x %s>' % (ptrtype, length))\n\n    def new_void_type(self):\n        return FakeType(\"<void>\")\n    def cast(self, x, y):\n        return 'casted!'\n    def _get_types(self):\n        return \"CData\", \"CType\"\n\n    buffer = \"buffer type\"\n\nclass FakeType(object):\n    def __init__(self, cdecl):\n        self.cdecl = cdecl\n    def __str__(self):\n        return self.cdecl\n\nclass FakeStruct(object):\n    def __init__(self, name):\n        self.name = name\n    def __str__(self):\n        return ', '.join([str(y) + str(x) for x, y, z in self.fields])\n\nclass FakeLibrary(object):\n\n    def load_function(self, BType, name):\n        return FakeFunction(BType, name)\n\nclass FakeFunction(object):\n\n    def __init__(self, BType, name):\n        self.BType = str(BType)\n        self.name = name\n\nlib_m = \"m\"\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\nelif is_musl:\n    lib_m = 'c'\n\n\ndef test_simple():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"double sin(double x);\")\n    m = ffi.dlopen(lib_m)\n    func = m.sin    # should be a callable on real backends\n    assert func.name == 'sin'\n    assert func.BType == '<func (<double>), <double>, False>'\n\ndef test_pipe():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"int pipe(int pipefd[2]);\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    func = C.pipe\n    assert func.name == 'pipe'\n    assert func.BType == '<func (<pointer to <int>>), <int>, False>'\n\ndef test_vararg():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"short foo(int, ...);\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    func = C.foo\n    assert func.name == 'foo'\n    assert func.BType == '<func (<int>), <short>, True>'\n\ndef test_no_args():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        int foo(void);\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert C.foo.BType == '<func (), <int>, False>'\n\ndef test_typedef():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef unsigned int UInt;\n        typedef UInt UIntReally;\n        UInt foo(void);\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert str(ffi.typeof(\"UIntReally\")) == '<unsigned int>'\n    assert C.foo.BType == '<func (), <unsigned int>, False>'\n\ndef test_typedef_more_complex():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef struct { int a, b; } foo_t, *foo_p;\n        int foo(foo_p[]);\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert str(ffi.typeof(\"foo_t\")) == '<int>a, <int>b'\n    assert str(ffi.typeof(\"foo_p\")) == '<pointer to <int>a, <int>b>'\n    assert C.foo.BType == ('<func (<pointer to <pointer to '\n                           '<int>a, <int>b>>), <int>, False>')\n\ndef test_typedef_array_convert_array_to_pointer():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        typedef int (*fn_t)(int[5]);\n        \"\"\")\n    with ffi._lock:\n        type = ffi._parser.parse_type(\"fn_t\")\n        BType = ffi._get_cached_btype(type)\n    assert str(BType) == '<func (<pointer to <int>>), <int>, False>'\n\ndef test_remove_comments():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        double /*comment here*/ sin   // blah blah\n        /* multi-\n           line-\n           //comment */  (\n        // foo\n        double // bar      /* <- ignored, because it's in a comment itself\n        x, double/*several*//*comment*/y) /*on the same line*/\n        ;\n    \"\"\")\n    m = ffi.dlopen(lib_m)\n    func = m.sin\n    assert func.name == 'sin'\n    assert func.BType == '<func (<double>, <double>), <double>, False>'\n\ndef test_remove_line_continuation_comments():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        double // blah \\\\\n                  more comments\n        x(void);\n        double // blah // blah\\\\\\\\\n        y(void);\n        double // blah\\\\ \\\n                  etc\n        z(void);\n    \"\"\")\n    m = ffi.dlopen(lib_m)\n    m.x\n    m.y\n    m.z\n\ndef test_dont_remove_comment_in_line_directives():\n    ffi = FFI(backend=FakeBackend())\n    e = pytest.raises(CDefError, ffi.cdef, \"\"\"\n        \\t # \\t line \\t 8 \\t \"baz.c\" \\t\n\n        some syntax error here\n    \"\"\")\n    assert str(e.value) == \"parse error\\nbaz.c:9:14: before: syntax\"\n    #\n    e = pytest.raises(CDefError, ffi.cdef, \"\"\"\n        #line 7 \"foo//bar.c\"\n\n        some syntax error here\n    \"\"\")\n    #\n    assert str(e.value) == \"parse error\\nfoo//bar.c:8:14: before: syntax\"\n    ffi = FFI(backend=FakeBackend())\n    e = pytest.raises(CDefError, ffi.cdef, \"\"\"\n        \\t # \\t 8 \\t \"baz.c\" \\t\n\n        some syntax error here\n    \"\"\")\n    assert str(e.value) == \"parse error\\nbaz.c:9:14: before: syntax\"\n    #\n    e = pytest.raises(CDefError, ffi.cdef, \"\"\"\n        # 7 \"foo//bar.c\"\n\n        some syntax error here\n    \"\"\")\n    assert str(e.value) == \"parse error\\nfoo//bar.c:8:14: before: syntax\"\n\ndef test_multiple_line_directives():\n    ffi = FFI(backend=FakeBackend())\n    e = pytest.raises(CDefError, ffi.cdef,\n    \"\"\" #line 5 \"foo.c\"\n        extern int xx;\n        #line 6 \"bar.c\"\n        extern int yy;\n        #line 7 \"baz.c\"\n        some syntax error here\n        #line 8 \"yadda.c\"\n        extern int zz;\n    \"\"\")\n    assert str(e.value) == \"parse error\\nbaz.c:7:14: before: syntax\"\n    #\n    e = pytest.raises(CDefError, ffi.cdef,\n    \"\"\" # 5 \"foo.c\"\n        extern int xx;\n        # 6 \"bar.c\"\n        extern int yy;\n        # 7 \"baz.c\"\n        some syntax error here\n        # 8 \"yadda.c\"\n        extern int zz;\n    \"\"\")\n    assert str(e.value) == \"parse error\\nbaz.c:7:14: before: syntax\"\n\ndef test_commented_line_directive():\n    ffi = FFI(backend=FakeBackend())\n    e = pytest.raises(CDefError, ffi.cdef, \"\"\"\n        /*\n        #line 5 \"foo.c\"\n        */\n        void xx(void);\n\n        #line 6 \"bar.c\"\n        /*\n        #line 35 \"foo.c\"\n        */\n        some syntax error\n    \"\"\")\n    #\n    assert str(e.value) == \"parse error\\nbar.c:9:14: before: syntax\"\n    e = pytest.raises(CDefError, ffi.cdef, \"\"\"\n        /*\n        # 5 \"foo.c\"\n        */\n        void xx(void);\n\n        # 6 \"bar.c\"\n        /*\n        # 35 \"foo.c\"\n        */\n        some syntax error\n    \"\"\")\n    assert str(e.value) == \"parse error\\nbar.c:9:14: before: syntax\"\n\ndef test_line_continuation_in_defines():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"\"\"\n        #define ABC\\\\\n            42\n        #define BCD   \\\\\n            43\n    \"\"\")\n    m = ffi.dlopen(lib_m)\n    assert m.ABC == 42\n    assert m.BCD == 43\n\ndef test_define_not_supported_for_now():\n    ffi = FFI(backend=FakeBackend())\n    e = pytest.raises(CDefError, ffi.cdef, '#define FOO \"blah\"')\n    assert str(e.value) == (\n        'only supports one of the following syntax:\\n'\n        '  #define FOO ...     (literally dot-dot-dot)\\n'\n        '  #define FOO NUMBER  (with NUMBER an integer'\n                                    ' constant, decimal/hex/octal)\\n'\n        'got:\\n'\n        '  #define FOO \"blah\"')\n\ndef test_unnamed_struct():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"typedef struct { int x; } foo_t;\\n\"\n             \"typedef struct { int y; } *bar_p;\\n\")\n    assert 'typedef foo_t' in ffi._parser._declarations\n    assert 'typedef bar_p' in ffi._parser._declarations\n    assert 'anonymous foo_t' in ffi._parser._declarations\n    type_foo = ffi._parser.parse_type(\"foo_t\")\n    type_bar = ffi._parser.parse_type(\"bar_p\").totype\n    assert repr(type_foo) == \"<foo_t>\"\n    assert repr(type_bar) == \"<struct $1>\"\n    pytest.raises(VerificationError, type_bar.get_c_name)\n    assert type_foo.get_c_name() == \"foo_t\"\n\ndef test_override():\n    ffi = FFI(backend=FakeBackend())\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    ffi.cdef(\"int foo(void);\")\n    pytest.raises(FFIError, ffi.cdef, \"long foo(void);\")\n    assert C.foo.BType == '<func (), <int>, False>'\n    ffi.cdef(\"long foo(void);\", override=True)\n    assert C.foo.BType == '<func (), <long>, False>'\n\ndef test_cannot_have_only_variadic_part():\n    # this checks that we get a sensible error if we try \"int foo(...);\"\n    ffi = FFI()\n    e = pytest.raises(CDefError, ffi.cdef, \"int foo(...);\")\n    assert str(e.value) == (\n           \"<cdef source string>:1: foo: a function with only '(...)' \"\n           \"as argument is not correct C\")\n\ndef test_parse_error():\n    ffi = FFI()\n    e = pytest.raises(CDefError, ffi.cdef, \" x y z \")\n    assert str(e.value).startswith(\n        'cannot parse \"x y z\"\\n<cdef source string>:1:')\n    e = pytest.raises(CDefError, ffi.cdef, \"\\n\\n\\n x y z \")\n    assert str(e.value).startswith(\n        'cannot parse \"x y z\"\\n<cdef source string>:4:')\n\ndef test_error_custom_lineno():\n    ffi = FFI()\n    e = pytest.raises(CDefError, ffi.cdef, \"\"\"\n# 42 \"foobar\"\n\n    a b c d\n    \"\"\")\n    assert str(e.value).startswith('parse error\\nfoobar:43:')\n\ndef test_cannot_declare_enum_later():\n    ffi = FFI()\n    e = pytest.raises(NotImplementedError, ffi.cdef,\n                       \"typedef enum foo_e foo_t; enum foo_e { AA, BB };\")\n    assert str(e.value) == (\n           \"enum foo_e: the '{}' declaration should appear on the \"\n           \"first time the enum is mentioned, not later\")\n\ndef test_unknown_name():\n    ffi = FFI()\n    e = pytest.raises(CDefError, ffi.cast, \"foobarbazunknown\", 0)\n    assert str(e.value) == \"unknown identifier 'foobarbazunknown'\"\n    e = pytest.raises(CDefError, ffi.cast, \"foobarbazunknown*\", 0)\n    assert str(e.value).startswith('cannot parse \"foobarbazunknown*\"')\n    e = pytest.raises(CDefError, ffi.cast, \"int(*)(foobarbazunknown)\", 0)\n    assert str(e.value).startswith('cannot parse \"int(*)(foobarbazunknown)\"')\n\ndef test_redefine_common_type():\n    prefix = \"\" if sys.version_info < (3,) else \"b\"\n    ffi = FFI()\n    ffi.cdef(\"typedef char FILE;\")\n    assert repr(ffi.cast(\"FILE\", 123)) == \"<cdata 'char' %s'{'>\" % prefix\n    ffi.cdef(\"typedef char int32_t;\")\n    assert repr(ffi.cast(\"int32_t\", 123)) == \"<cdata 'char' %s'{'>\" % prefix\n    ffi = FFI()\n    ffi.cdef(\"typedef int bool, *FILE;\")\n    assert repr(ffi.cast(\"bool\", 123)) == \"<cdata 'int' 123>\"\n    assert re.match(r\"<cdata 'int [*]' 0[xX]?0*7[bB]>\",\n                    repr(ffi.cast(\"FILE\", 123)))\n    ffi = FFI()\n    ffi.cdef(\"typedef bool (*fn_t)(bool, bool);\")   # \"bool,\" but within \"( )\"\n\ndef test_bool():\n    ffi = FFI()\n    ffi.cdef(\"void f(bool);\")\n    #\n    ffi = FFI()\n    ffi.cdef(\"typedef _Bool bool; void f(bool);\")\n\ndef test_unknown_argument_type():\n    ffi = FFI()\n    e = pytest.raises(CDefError, ffi.cdef, \"void f(foobarbazzz);\")\n    assert str(e.value) == (\"<cdef source string>:1: f arg 1:\"\n                            \" unknown type 'foobarbazzz' (if you meant\"\n                            \" to use the old C syntax of giving untyped\"\n                            \" arguments, it is not supported)\")\n\ndef test_void_renamed_as_only_arg():\n    ffi = FFI()\n    ffi.cdef(\"typedef void void_t1;\"\n             \"typedef void_t1 void_t;\"\n             \"typedef int (*func_t)(void_t);\")\n    assert ffi.typeof(\"func_t\").args == ()\n\ndef test_WPARAM_on_windows():\n    if sys.platform != 'win32':\n        pytest.skip(\"Only for Windows\")\n    ffi = FFI()\n    ffi.cdef(\"void f(WPARAM);\")\n    #\n    # WPARAM -> UINT_PTR -> unsigned 32/64-bit integer\n    ffi = FFI()\n    value = int(ffi.cast(\"WPARAM\", -42))\n    assert value == sys.maxsize * 2 - 40\n\ndef test__is_constant_globalvar():\n    import warnings\n    for input, expected_output in [\n        (\"int a;\",          False),\n        (\"const int a;\",    True),\n        (\"int *a;\",         False),\n        (\"const int *a;\",   False),\n        (\"int const *a;\",   False),\n        (\"int *const a;\",   True),\n        (\"int a[5];\",       False),\n        (\"const int a[5];\", False),\n        (\"int *a[5];\",      False),\n        (\"const int *a[5];\", False),\n        (\"int const *a[5];\", False),\n        (\"int *const a[5];\", False),\n        (\"int a[5][6];\",       False),\n        (\"const int a[5][6];\", False),\n        ]:\n        ffi = FFI()\n        with warnings.catch_warnings(record=True) as log:\n            warnings.simplefilter(\"always\")\n            ffi.cdef(input)\n        declarations = ffi._parser._declarations\n        assert ('constant a' in declarations) == expected_output\n        assert ('variable a' in declarations) == (not expected_output)\n        assert len(log) == (1 - expected_output)\n\ndef test_restrict():\n    from cffi import model\n    for input, expected_output in [\n        (\"int a;\",             False),\n        (\"restrict int a;\",    True),\n        (\"int *a;\",            False),\n        ]:\n        ffi = FFI()\n        ffi.cdef(\"extern \" + input)\n        tp, quals = ffi._parser._declarations['variable a']\n        assert bool(quals & model.Q_RESTRICT) == expected_output\n\ndef test_different_const_funcptr_types():\n    lst = []\n    for input in [\n        \"int(*)(int *a)\",\n        \"int(*)(int const *a)\",\n        \"int(*)(int * const a)\",\n        \"int(*)(int const a[])\"]:\n        ffi = FFI(backend=FakeBackend())\n        lst.append(ffi._parser.parse_type(input))\n    assert lst[0] != lst[1]\n    assert lst[0] == lst[2]\n    assert lst[1] == lst[3]\n\ndef test_const_pointer_to_pointer():\n    from cffi import model\n    ffi = FFI(backend=FakeBackend())\n    #\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * * (* const)\")\n    assert (str(tp), qual) == (\"<char * * *>\", model.Q_CONST)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * (* const (*))\")\n    assert (str(tp), qual) == (\"<char * * const *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char (* const (* (*)))\")\n    assert (str(tp), qual) == (\"<char * const * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char const * * *\")\n    assert (str(tp), qual) == (\"<char const * * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"const char * * *\")\n    assert (str(tp), qual) == (\"<char const * * *>\", 0)\n    #\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * * * const const\")\n    assert (str(tp), qual) == (\"<char * * *>\", model.Q_CONST)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * * volatile *\")\n    assert (str(tp), qual) == (\"<char * * volatile *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char * volatile restrict * *\")\n    assert (str(tp), qual) == (\"<char * __restrict volatile * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"char const volatile * * *\")\n    assert (str(tp), qual) == (\"<char volatile const * * *>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\"const char * * *\")\n    assert (str(tp), qual) == (\"<char const * * *>\", 0)\n    #\n    tp, qual = ffi._parser.parse_type_and_quals(\n        \"int(char*const*, short****const*)\")\n    assert (str(tp), qual) == (\n        \"<int()(char * const *, short * * * * const *)>\", 0)\n    tp, qual = ffi._parser.parse_type_and_quals(\n        \"char*const*(short*const****)\")\n    assert (str(tp), qual) == (\n        \"<char * const *()(short * const * * * *)>\", 0)\n\ndef test_enum():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        enum Enum {\n            POS = +1,\n            TWO = 2,\n            NIL = 0,\n            NEG = -1,\n            ADDSUB = (POS+TWO)-1,\n            DIVMULINT = (3 * 3) / 2,\n            SHIFT = (1 << 3) >> 1,\n            BINOPS = (0x7 & 0x1) | 0x8,\n            XOR = 0xf ^ 0xa\n        };\n        \"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    assert C.POS == 1\n    assert C.TWO == 2\n    assert C.NIL == 0\n    assert C.NEG == -1\n    assert C.ADDSUB == 2\n    assert C.DIVMULINT == 4\n    assert C.SHIFT == 4\n    assert C.BINOPS == 0b1001\n    assert C.XOR == 0b0101\n\ndef test_stdcall():\n    ffi = FFI()\n    tp = ffi.typeof(\"int(*)(int __stdcall x(int),\"\n                    \"       long (__cdecl*y)(void),\"\n                    \"       short(WINAPI *z)(short))\")\n    if sys.platform == 'win32' and sys.maxsize < 2**32:\n        stdcall = '__stdcall '\n    else:\n        stdcall = ''\n    assert str(tp) == (\n        \"<ctype 'int(*)(int(%s*)(int), \"\n                        \"long(*)(), \"\n                        \"short(%s*)(short))'>\" % (stdcall, stdcall))\n\ndef test_extern_python():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int bok(int, int);\n        extern \"Python\" int foobar(int, int);\n        int baz(int, int);\n    \"\"\")\n    assert sorted(ffi._parser._declarations) == [\n        'extern_python foobar', 'function baz', 'function bok']\n    assert (ffi._parser._declarations['function bok'] ==\n            ffi._parser._declarations['extern_python foobar'] ==\n            ffi._parser._declarations['function baz'])\n\ndef test_extern_python_group():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        int bok(int);\n        extern \"Python\" {int foobar(int, int);int bzrrr(int);}\n        int baz(int, int);\n    \"\"\")\n    assert sorted(ffi._parser._declarations) == [\n        'extern_python bzrrr', 'extern_python foobar',\n        'function baz', 'function bok']\n    assert (ffi._parser._declarations['function baz'] ==\n            ffi._parser._declarations['extern_python foobar'] !=\n            ffi._parser._declarations['function bok'] ==\n            ffi._parser._declarations['extern_python bzrrr'])\n\ndef test_error_invalid_syntax_for_cdef():\n    ffi = FFI()\n    e = pytest.raises(CDefError, ffi.cdef, 'void foo(void) {}')\n    assert str(e.value) == ('<cdef source string>:1: unexpected <FuncDef>: '\n                            'this construct is valid C but not valid in cdef()')\n\ndef test_unsigned_int_suffix_for_constant():\n    ffi = FFI()\n    ffi.cdef(\"\"\"enum e {\n                    bin_0=0b10,\n                    bin_1=0b10u,\n                    bin_2=0b10U,\n                    bin_3=0b10l,\n                    bin_4=0b10L,\n                    bin_5=0b10ll,\n                    bin_6=0b10LL,\n                    oct_0=010,\n                    oct_1=010u,\n                    oct_2=010U,\n                    oct_3=010l,\n                    oct_4=010L,\n                    oct_5=010ll,\n                    oct_6=010LL,\n                    dec_0=10,\n                    dec_1=10u,\n                    dec_2=10U,\n                    dec_3=10l,\n                    dec_4=10L,\n                    dec_5=10ll,\n                    dec_6=10LL,\n                    hex_0=0x10,\n                    hex_1=0x10u,\n                    hex_2=0x10U,\n                    hex_3=0x10l,\n                    hex_4=0x10L,\n                    hex_5=0x10ll,\n                    hex_6=0x10LL,};\"\"\")\n    needs_dlopen_none()\n    C = ffi.dlopen(None)\n    for base, expected_result in (('bin', 2), ('oct', 8), ('dec', 10), ('hex', 16)):\n        for index in range(7):\n            assert getattr(C, '{base}_{index}'.format(base=base, index=index)) == expected_result\n\ndef test_missing_newline_bug():\n    ffi = FFI(backend=FakeBackend())\n    ffi.cdef(\"#pragma foobar\")\n    ffi.cdef(\"#pragma foobar\")    # used to crash the second time\n", "testing/cffi0/callback_in_thread.py": "import sys, time\nsys.path.insert(0, sys.argv[1])\nfrom cffi import FFI\n\ndef _run_callback_in_thread():\n    ffi = FFI()\n    ffi.cdef(\"\"\"\n        typedef int (*mycallback_func_t)(int, int);\n        int threaded_ballback_test(mycallback_func_t mycb);\n    \"\"\")\n    lib = ffi.verify(\"\"\"\n        #include <pthread.h>\n        typedef int (*mycallback_func_t)(int, int);\n        void *my_wait_function(void *ptr) {\n            mycallback_func_t cbfunc = (mycallback_func_t)ptr;\n            cbfunc(10, 10);\n            cbfunc(12, 15);\n            return NULL;\n        }\n        int threaded_ballback_test(mycallback_func_t mycb) {\n            pthread_t thread;\n            pthread_create(&thread, NULL, my_wait_function, (void*)mycb);\n            return 0;\n        }\n    \"\"\", extra_compile_args=['-pthread'])\n    seen = []\n    @ffi.callback('int(*)(int,int)')\n    def mycallback(x, y):\n        time.sleep(0.022)\n        seen.append((x, y))\n        return 0\n    lib.threaded_ballback_test(mycallback)\n    count = 300\n    while len(seen) != 2:\n        time.sleep(0.01)\n        count -= 1\n        assert count > 0, \"timeout\"\n    assert seen == [(10, 10), (12, 15)]\n\nprint('STARTING')\n_run_callback_in_thread()\nprint('DONE')\n", "testing/cffi0/test_ownlib.py": "import sys, os\nimport subprocess, weakref\nimport pytest\nfrom cffi import FFI\nfrom cffi.backend_ctypes import CTypesBackend\nfrom testing.support import u, is_musl\n\n\nSOURCE = \"\"\"\\\n#include <errno.h>\n\n#ifdef _WIN32\n#define EXPORT __declspec(dllexport)\n#else\n#define EXPORT\n#endif\n\nEXPORT int test_getting_errno(void) {\n    errno = 123;\n    return -1;\n}\n\nEXPORT int test_setting_errno(void) {\n    return errno;\n};\n\ntypedef struct {\n    long x;\n    long y;\n} POINT;\n\ntypedef struct {\n    long left;\n    long top;\n    long right;\n    long bottom;\n} RECT;\n\ntypedef struct {\n    unsigned char a, b, c;\n} THREEBYTES;\n\n\nEXPORT int PointInRect(RECT *prc, POINT pt)\n{\n    if (pt.x < prc->left)\n        return 0;\n    if (pt.x > prc->right)\n        return 0;\n    if (pt.y < prc->top)\n        return 0;\n    if (pt.y > prc->bottom)\n        return 0;\n    return 1;\n};\n\nEXPORT long left = 10;\nEXPORT long top = 20;\nEXPORT long right = 30;\nEXPORT long bottom = 40;\n\nEXPORT RECT ReturnRect(int i, RECT ar, RECT* br, POINT cp, RECT dr,\n                        RECT *er, POINT fp, RECT gr)\n{\n    /*Check input */\n    if (ar.left + br->left + dr.left + er->left + gr.left != left * 5)\n    {\n        ar.left = 100;\n        return ar;\n    }\n    if (ar.right + br->right + dr.right + er->right + gr.right != right * 5)\n    {\n        ar.right = 100;\n        return ar;\n    }\n    if (cp.x != fp.x)\n    {\n        ar.left = -100;\n    }\n    if (cp.y != fp.y)\n    {\n        ar.left = -200;\n    }\n    switch(i)\n    {\n    case 0:\n        return ar;\n        break;\n    case 1:\n        return dr;\n        break;\n    case 2:\n        return gr;\n        break;\n\n    }\n    return ar;\n}\n\nEXPORT int my_array[7] = {0, 1, 2, 3, 4, 5, 6};\n\nEXPORT unsigned short foo_2bytes(unsigned short a)\n{\n    return (unsigned short)(a + 42);\n}\nEXPORT unsigned int foo_4bytes(unsigned int a)\n{\n    return (unsigned int)(a + 42);\n}\n\nEXPORT void modify_struct_value(RECT r)\n{\n    r.left = r.right = r.top = r.bottom = 500;\n}\n\nEXPORT THREEBYTES return_three_bytes(void)\n{\n    THREEBYTES result;\n    result.a = 12;\n    result.b = 34;\n    result.c = 56;\n    return result;\n}\n\"\"\"\n\nclass TestOwnLib(object):\n    Backend = CTypesBackend\n\n    def setup_class(cls):\n        cls.module = None\n        from testing.udir import udir\n        udir.join('testownlib.c').write(SOURCE)\n        if sys.platform == 'win32':\n            # did we already build it?\n            if cls.Backend is CTypesBackend:\n                dll_path = str(udir) + '\\\\testownlib1.dll'   # only ascii for the ctypes backend\n            else:\n                dll_path = str(udir) + '\\\\' + (u+'testownlib\\u03be.dll')   # non-ascii char\n            if os.path.exists(dll_path):\n                cls.module = dll_path\n                return\n            # try (not too hard) to find the version used to compile this python\n            # no mingw\n            from distutils.msvc9compiler import get_build_version\n            version = get_build_version()\n            toolskey = \"VS%0.f0COMNTOOLS\" % version\n            toolsdir = os.environ.get(toolskey, None)\n            if toolsdir is None:\n                return\n            productdir = os.path.join(toolsdir, os.pardir, os.pardir, \"VC\")\n            productdir = os.path.abspath(productdir)\n            vcvarsall = os.path.join(productdir, \"vcvarsall.bat\")\n            # 64?\n            arch = 'x86'\n            if sys.maxsize > 2**32:\n                arch = 'amd64'\n            if os.path.isfile(vcvarsall):\n                cmd = '\"%s\" %s' % (vcvarsall, arch) + ' & cl.exe testownlib.c ' \\\n                        ' /LD /Fetestownlib.dll'\n                subprocess.check_call(cmd, cwd = str(udir), shell=True)\n                os.rename(str(udir) + '\\\\testownlib.dll', dll_path)\n                cls.module = dll_path\n        else:\n            encoded = None\n            if cls.Backend is not CTypesBackend:\n                try:\n                    unicode_name = u+'testownlibcaf\\xe9'\n                    encoded = unicode_name.encode(sys.getfilesystemencoding())\n                    if sys.version_info >= (3,):\n                        encoded = str(unicode_name)\n                except UnicodeEncodeError:\n                    pass\n            if encoded is None:\n                unicode_name = u+'testownlib'\n                encoded = str(unicode_name)\n            subprocess.check_call(\n                \"cc testownlib.c -shared -fPIC -o '%s.so'\" % (encoded,),\n                cwd=str(udir), shell=True)\n            cls.module = os.path.join(str(udir), unicode_name + (u+'.so'))\n        print(repr(cls.module))\n\n    def test_getting_errno(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if sys.platform == 'win32':\n            pytest.skip(\"fails, errno at multiple addresses\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        res = ownlib.test_getting_errno()\n        assert res == -1\n        assert ffi.errno == 123\n\n    def test_setting_errno(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if sys.platform == 'win32':\n            pytest.skip(\"fails, errno at multiple addresses\")\n        if self.Backend is CTypesBackend and '__pypy__' in sys.modules:\n            pytest.skip(\"XXX errno issue with ctypes on pypy?\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_setting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi.errno = 42\n        res = ownlib.test_setting_errno()\n        assert res == 42\n        assert ffi.errno == 42\n\n    def test_my_array_7(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            extern int my_array[7];\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n        assert len(ownlib.my_array) == 7\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not supported by the ctypes backend\")\n        ownlib.my_array = list(range(10, 17))\n        for i in range(7):\n            assert ownlib.my_array[i] == 10 + i\n        ownlib.my_array = list(range(7))\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n\n    def test_my_array_no_length(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            extern int my_array[];\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n        pytest.raises(TypeError, len, ownlib.my_array)\n        ownlib.my_array = list(range(10, 17))\n        for i in range(7):\n            assert ownlib.my_array[i] == 10 + i\n        ownlib.my_array = list(range(7))\n        for i in range(7):\n            assert ownlib.my_array[i] == i\n\n    def test_keepalive_lib(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi_r = weakref.ref(ffi)\n        ownlib_r = weakref.ref(ownlib)\n        func = ownlib.test_getting_errno\n        del ffi\n        import gc; gc.collect()       # ownlib stays alive\n        assert ownlib_r() is not None\n        assert ffi_r() is not None    # kept alive by ownlib\n        res = func()\n        assert res == -1\n\n    def test_keepalive_ffi(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int test_getting_errno(void);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n        ffi_r = weakref.ref(ffi)\n        ownlib_r = weakref.ref(ownlib)\n        func = ownlib.test_getting_errno\n        del ownlib\n        import gc; gc.collect()       # ffi stays alive\n        assert ffi_r() is not None\n        assert ownlib_r() is not None # kept alive by ffi\n        res = func()\n        assert res == -1\n        if sys.platform != 'win32':  # else, errno at multiple addresses\n            assert ffi.errno == 123\n\n    def test_struct_by_value(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef struct {\n                long x;\n                long y;\n            } POINT;\n\n            typedef struct {\n                long left;\n                long top;\n                long right;\n                long bottom;\n            } RECT;\n            \n            extern long left, top, right, bottom;\n\n            RECT ReturnRect(int i, RECT ar, RECT* br, POINT cp, RECT dr,\n                        RECT *er, POINT fp, RECT gr);\n        \"\"\")\n        ownlib = ffi.dlopen(self.module)\n\n        rect = ffi.new('RECT[1]')\n        pt = ffi.new('POINT[1]')\n        pt[0].x = 15\n        pt[0].y = 25\n        rect[0].left = ownlib.left\n        rect[0].right = ownlib.right\n        rect[0].top = ownlib.top\n        rect[0].bottom = ownlib.bottom\n        \n        for i in range(4):\n            ret = ownlib.ReturnRect(i, rect[0], rect, pt[0], rect[0],\n                                    rect, pt[0], rect[0])\n            assert ret.left == ownlib.left\n            assert ret.right == ownlib.right\n            assert ret.top == ownlib.top\n            assert ret.bottom == ownlib.bottom\n\n    def test_addressof_lib(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not implemented with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"extern long left; int test_getting_errno(void);\")\n        lib = ffi.dlopen(self.module)\n        lib.left = 123456\n        p = ffi.addressof(lib, \"left\")\n        assert ffi.typeof(p) == ffi.typeof(\"long *\")\n        assert p[0] == 123456\n        p[0] += 1\n        assert lib.left == 123457\n        pfn = ffi.addressof(lib, \"test_getting_errno\")\n        assert ffi.typeof(pfn) == ffi.typeof(\"int(*)(void)\")\n        assert pfn == lib.test_getting_errno\n\n    def test_char16_char32_t(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not implemented with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            char16_t foo_2bytes(char16_t);\n            char32_t foo_4bytes(char32_t);\n        \"\"\")\n        lib = ffi.dlopen(self.module)\n        assert lib.foo_2bytes(u+'\\u1234') == u+'\\u125e'\n        assert lib.foo_4bytes(u+'\\u1234') == u+'\\u125e'\n        assert lib.foo_4bytes(u+'\\U00012345') == u+'\\U0001236f'\n\n    def test_modify_struct_value(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"fails with the ctypes backend on some architectures\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef struct {\n                long left;\n                long top;\n                long right;\n                long bottom;\n            } RECT;\n\n            void modify_struct_value(RECT r);\n        \"\"\")\n        lib = ffi.dlopen(self.module)\n        s = ffi.new(\"RECT *\", [11, 22, 33, 44])\n        lib.modify_struct_value(s[0])\n        assert s.left == 11\n        assert s.top == 22\n        assert s.right == 33\n        assert s.bottom == 44\n\n    def test_dlopen_handle(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if sys.platform == 'win32' or is_musl:\n            pytest.skip(\"uses 'dl' explicitly\")\n        if self.__class__.Backend is CTypesBackend:\n            pytest.skip(\"not for the ctypes backend\")\n        backend = self.Backend()\n        ffi1 = FFI(backend=backend)\n        ffi1.cdef(\"\"\"void *dlopen(const char *filename, int flags);\n                     int dlclose(void *handle);\"\"\")\n        lib1 = ffi1.dlopen('dl')\n        handle = lib1.dlopen(self.module.encode(sys.getfilesystemencoding()),\n                             backend.RTLD_LAZY)\n        assert ffi1.typeof(handle) == ffi1.typeof(\"void *\")\n        assert handle\n\n        ffi = FFI(backend=backend)\n        ffi.cdef(\"\"\"unsigned short foo_2bytes(unsigned short a);\"\"\")\n        lib = ffi.dlopen(handle)\n        x = lib.foo_2bytes(1000)\n        assert x == 1042\n\n        err = lib1.dlclose(handle)\n        assert err == 0\n\n    def test_return_three_bytes(self):\n        if self.module is None:\n            pytest.skip(\"fix the auto-generation of the tiny test lib\")\n        if self.__class__.Backend is CTypesBackend:\n            pytest.skip(\"not working on win32 on the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef struct {\n                unsigned char a, b, c;\n            } THREEBYTES;\n\n            THREEBYTES return_three_bytes(void);\n        \"\"\")\n        lib = ffi.dlopen(self.module)\n        tb = lib.return_three_bytes()\n        assert tb.a == 12\n        assert tb.b == 34\n        assert tb.c == 56\n", "testing/cffi0/test_function.py": "import pytest\nfrom cffi import FFI, CDefError\nimport math, os, sys\nimport ctypes.util\nfrom cffi.backend_ctypes import CTypesBackend\nfrom testing.udir import udir\nfrom testing.support import FdWriteCapture, StdErrCapture, is_musl\nfrom .backend_tests import needs_dlopen_none\n\ntry:\n    from StringIO import StringIO\nexcept ImportError:\n    from io import StringIO\n\ntry:\n    from packaging.tags import platform_tags\n    _platform_tags_cached = set(platform_tags())\n    _is_musl = any(t.startswith('musllinux') for t in _platform_tags_cached)\nexcept ImportError:\n    _is_musl = False\n\nlib_m = 'm'\nif sys.platform == 'win32':\n    #there is a small chance this fails on Mingw via environ $CC\n    import distutils.ccompiler\n    if distutils.ccompiler.get_default_compiler() == 'msvc':\n        lib_m = 'msvcrt'\nelif is_musl:\n    lib_m = 'c'\n\nclass TestFunction(object):\n    Backend = CTypesBackend\n\n    def test_sin(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double sin(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_sinf(self):\n        if sys.platform == 'win32':\n            pytest.skip(\"no sinf found in the Windows stdlib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            float sinf(float x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sinf(1.23)\n        assert type(x) is float\n        assert x != math.sin(1.23)    # rounding effects\n        assert abs(x - math.sin(1.23)) < 1E-6\n\n    def test_getenv_no_return_value(self):\n        # check that 'void'-returning functions work too\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            void getenv(char *);\n        \"\"\")\n        needs_dlopen_none()\n        m = ffi.dlopen(None)\n        x = m.getenv(b\"FOO\")\n        assert x is None\n\n    def test_dlopen_filename(self):\n        path = ctypes.util.find_library(lib_m)\n        if not path:\n            pytest.skip(\"%s not found\" % lib_m)\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double cos(double x);\n        \"\"\")\n        m = ffi.dlopen(path)\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n        m = ffi.dlopen(os.path.basename(path))\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n    def test_dlopen_flags(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double cos(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m, ffi.RTLD_LAZY | ffi.RTLD_LOCAL)\n        x = m.cos(1.23)\n        assert x == math.cos(1.23)\n\n    def test_dlopen_constant(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            #define FOOBAR 42\n            static const float baz = 42.5;   /* not visible */\n            double sin(double x);\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert m.FOOBAR == 42\n        with pytest.raises(NotImplementedError):\n            m.baz\n\n    def test_tlsalloc(self):\n        if sys.platform != 'win32':\n            pytest.skip(\"win32 only\")\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"ctypes complains on wrong calling conv\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"long TlsAlloc(void); int TlsFree(long);\")\n        lib = ffi.dlopen('KERNEL32.DLL')\n        x = lib.TlsAlloc()\n        assert x != 0\n        y = lib.TlsFree(x)\n        assert y != 0\n\n    def test_fputs(self):\n        if not sys.platform.startswith('linux'):\n            pytest.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int fputs(const char *, void *);\n            extern void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        ffi.C.fputs   # fetch before capturing, for easier debugging\n        with FdWriteCapture() as fd:\n            ffi.C.fputs(b\"hello\\n\", ffi.C.stderr)\n            ffi.C.fputs(b\"  world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'hello\\n  world\\n'\n\n    def test_fputs_without_const(self):\n        if not sys.platform.startswith('linux'):\n            pytest.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int fputs(char *, void *);\n            extern void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        ffi.C.fputs   # fetch before capturing, for easier debugging\n        with FdWriteCapture() as fd:\n            ffi.C.fputs(b\"hello\\n\", ffi.C.stderr)\n            ffi.C.fputs(b\"  world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'hello\\n  world\\n'\n\n    def test_vararg(self):\n        if not sys.platform.startswith('linux'):\n            pytest.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n           int fprintf(void *, const char *format, ...);\n           extern void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        with FdWriteCapture() as fd:\n            ffi.C.fprintf(ffi.C.stderr, b\"hello with no arguments\\n\")\n            ffi.C.fprintf(ffi.C.stderr,\n                          b\"hello, %s!\\n\", ffi.new(\"char[]\", b\"world\"))\n            ffi.C.fprintf(ffi.C.stderr,\n                          ffi.new(\"char[]\", b\"hello, %s!\\n\"),\n                          ffi.new(\"char[]\", b\"world2\"))\n            ffi.C.fprintf(ffi.C.stderr,\n                          b\"hello int %d long %ld long long %lld\\n\",\n                          ffi.cast(\"int\", 42),\n                          ffi.cast(\"long\", 84),\n                          ffi.cast(\"long long\", 168))\n            ffi.C.fprintf(ffi.C.stderr, b\"hello %p\\n\", ffi.NULL)\n        res = fd.getvalue()\n        if is_musl:\n            nil_repr = b'0'\n        else:\n            nil_repr = b'(nil)'\n        assert res == (b\"hello with no arguments\\n\"\n                       b\"hello, world!\\n\"\n                       b\"hello, world2!\\n\"\n                       b\"hello int 42 long 84 long long 168\\n\"\n                       b\"hello \" + nil_repr + b\"\\n\")\n\n    def test_must_specify_type_of_vararg(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n           int printf(const char *format, ...);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        e = pytest.raises(TypeError, ffi.C.printf, b\"hello %d\\n\", 42)\n        assert str(e.value) == (\"argument 2 passed in the variadic part \"\n                                \"needs to be a cdata object (got int)\")\n\n    def test_function_has_a_c_type(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int puts(const char *);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        fptr = ffi.C.puts\n        assert ffi.typeof(fptr) == ffi.typeof(\"int(*)(const char*)\")\n        if self.Backend is CTypesBackend:\n            assert repr(fptr).startswith(\"<cdata 'int puts(char *)' 0x\")\n\n    def test_function_pointer(self):\n        ffi = FFI(backend=self.Backend())\n        def cb(charp):\n            assert repr(charp).startswith(\"<cdata 'char *' 0x\")\n            return 42\n        fptr = ffi.callback(\"int(*)(const char *txt)\", cb)\n        assert fptr != ffi.callback(\"int(*)(const char *)\", cb)\n        assert repr(fptr) == \"<cdata 'int(*)(char *)' calling %r>\" % (cb,)\n        res = fptr(b\"Hello\")\n        assert res == 42\n        #\n        if not sys.platform.startswith('linux'):\n            pytest.skip(\"probably no symbol 'stderr' in the lib\")\n        ffi.cdef(\"\"\"\n            int fputs(const char *, void *);\n            extern void *stderr;\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        fptr = ffi.cast(\"int(*)(const char *txt, void *)\", ffi.C.fputs)\n        assert fptr == ffi.C.fputs\n        assert repr(fptr).startswith(\"<cdata 'int(*)(char *, void *)' 0x\")\n        with FdWriteCapture() as fd:\n            fptr(b\"world\\n\", ffi.C.stderr)\n        res = fd.getvalue()\n        assert res == b'world\\n'\n\n    def test_callback_returning_void(self):\n        ffi = FFI(backend=self.Backend())\n        for returnvalue in [None, 42]:\n            def cb():\n                return returnvalue\n            fptr = ffi.callback(\"void(*)(void)\", cb)\n            with StdErrCapture() as f:\n                returned = fptr()\n            printed = f.getvalue()\n            assert returned is None\n            if returnvalue is None:\n                assert printed == ''\n            else:\n                assert \"None\" in printed\n\n    def test_callback_returning_struct_three_bytes(self):\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not supported with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef struct {\n                unsigned char a, b, c;\n            } THREEBYTES;\n        \"\"\")\n        def cb():\n            return (12, 34, 56)\n        fptr = ffi.callback(\"THREEBYTES(*)(void)\", cb)\n        tb = fptr()\n        assert tb.a == 12\n        assert tb.b == 34\n        assert tb.c == 56\n\n    def test_passing_array(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int strlen(char[]);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        p = ffi.new(\"char[]\", b\"hello\")\n        res = ffi.C.strlen(p)\n        assert res == 5\n\n    def test_write_variable(self):\n        if not sys.platform.startswith('linux') or _is_musl:\n            pytest.skip(\"probably no symbol 'stdout' in the lib\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            extern void *stdout;\n        \"\"\")\n        needs_dlopen_none()\n        C = ffi.dlopen(None)\n        pout = C.stdout\n        C.stdout = ffi.NULL\n        assert C.stdout == ffi.NULL\n        C.stdout = pout\n        assert C.stdout == pout\n\n    def test_strchr(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            char *strchr(const char *s, int c);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        p = ffi.new(\"char[]\", b\"hello world!\")\n        q = ffi.C.strchr(p, ord('w'))\n        assert ffi.string(q) == b\"world!\"\n\n    def test_function_with_struct_argument(self):\n        if sys.platform == 'win32':\n            pytest.skip(\"no 'inet_ntoa'\")\n        if (self.Backend is CTypesBackend and\n            '__pypy__' in sys.builtin_module_names):\n            pytest.skip(\"ctypes limitation on pypy\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            struct in_addr { unsigned int s_addr; };\n            char *inet_ntoa(struct in_addr in);\n        \"\"\")\n        needs_dlopen_none()\n        ffi.C = ffi.dlopen(None)\n        ina = ffi.new(\"struct in_addr *\", [0x04040404])\n        a = ffi.C.inet_ntoa(ina[0])\n        assert ffi.string(a) == b'4.4.4.4'\n\n    def test_function_typedef(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef double func_t(double);\n            func_t sin;\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_fputs_custom_FILE(self):\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"FILE not supported with the ctypes backend\")\n        filename = str(udir.join('fputs_custom_FILE'))\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"int fputs(const char *, FILE *);\")\n        needs_dlopen_none()\n        C = ffi.dlopen(None)\n        with open(filename, 'wb') as f:\n            f.write(b'[')\n            C.fputs(b\"hello from custom file\", f)\n            f.write(b'][')\n            C.fputs(b\"some more output\", f)\n            f.write(b']')\n        with open(filename, 'rb') as f:\n            res = f.read()\n        assert res == b'[hello from custom file][some more output]'\n\n    def test_constants_on_lib(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"enum foo_e { AA, BB, CC=5, DD };\n                    typedef enum { EE=-5, FF } some_enum_t;\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        assert lib.AA == 0\n        assert lib.BB == 1\n        assert lib.CC == 5\n        assert lib.DD == 6\n        assert lib.EE == -5\n        assert lib.FF == -4\n\n    def test_void_star_accepts_string(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(const void *);\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_signed_char_star_accepts_string(self):\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(signed char *);\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_unsigned_char_star_accepts_string(self):\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not supported by the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"int strlen(unsigned char *);\"\"\")\n        needs_dlopen_none()\n        lib = ffi.dlopen(None)\n        res = lib.strlen(b\"hello\")\n        assert res == 5\n\n    def test_missing_function(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            int nonexistent();\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert not hasattr(m, 'nonexistent')\n\n    def test_wraps_from_stdlib(self):\n        import functools\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            double sin(double x);\n        \"\"\")\n        def my_decorator(f):\n            @functools.wraps(f)\n            def wrapper(*args):\n                return f(*args) + 100\n            return wrapper\n        m = ffi.dlopen(lib_m)\n        sin100 = my_decorator(m.sin)\n        x = sin100(1.23)\n        assert x == math.sin(1.23) + 100\n\n    def test_free_callback_cycle(self):\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"seems to fail with the ctypes backend on windows\")\n        import weakref\n        def make_callback(data):\n            container = [data]\n            callback = ffi.callback('int()', lambda: len(container))\n            container.append(callback)\n            # Ref cycle: callback -> lambda (closure) -> container -> callback\n            return callback\n\n        class Data(object):\n            pass\n        ffi = FFI(backend=self.Backend())\n        data = Data()\n        callback = make_callback(data)\n        wr = weakref.ref(data)\n        del callback, data\n        for i in range(3):\n            if wr() is not None:\n                import gc; gc.collect()\n        assert wr() is None    # 'data' does not leak\n\n    def test_windows_stdcall(self):\n        if sys.platform != 'win32':\n            pytest.skip(\"Windows-only test\")\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        p_freq = ffi.new(\"LONGLONG *\")\n        res = m.QueryPerformanceFrequency(p_freq)\n        assert res != 0\n        assert p_freq[0] != 0\n\n    def test_explicit_cdecl_stdcall(self):\n        if sys.platform != 'win32':\n            pytest.skip(\"Windows-only test\")\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not with the ctypes backend\")\n        win64 = (sys.maxsize > 2**32)\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        tp = ffi.typeof(m.QueryPerformanceFrequency)\n        assert str(tp) == \"<ctype 'int(*)(long long *)'>\"\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL __cdecl QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        tpc = ffi.typeof(m.QueryPerformanceFrequency)\n        assert tpc is tp\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            BOOL WINAPI QueryPerformanceFrequency(LONGLONG *lpFrequency);\n        \"\"\")\n        m = ffi.dlopen(\"Kernel32.dll\")\n        tps = ffi.typeof(m.QueryPerformanceFrequency)\n        if win64:\n            assert tps is tpc\n        else:\n            assert tps is not tpc\n            assert str(tps) == \"<ctype 'int(__stdcall *)(long long *)'>\"\n        #\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"typedef int (__cdecl *fnc_t)(int);\")\n        ffi.cdef(\"typedef int (__stdcall *fns_t)(int);\")\n        tpc = ffi.typeof(\"fnc_t\")\n        tps = ffi.typeof(\"fns_t\")\n        assert str(tpc) == \"<ctype 'int(*)(int)'>\"\n        if win64:\n            assert tps is tpc\n        else:\n            assert str(tps) == \"<ctype 'int(__stdcall *)(int)'>\"\n        #\n        fnc = ffi.cast(\"fnc_t\", 0)\n        fns = ffi.cast(\"fns_t\", 0)\n        ffi.new(\"fnc_t[]\", [fnc])\n        if not win64:\n            pytest.raises(TypeError, ffi.new, \"fnc_t[]\", [fns])\n            pytest.raises(TypeError, ffi.new, \"fns_t[]\", [fnc])\n        ffi.new(\"fns_t[]\", [fns])\n\n    def test_stdcall_only_on_windows(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"double __stdcall sin(double x);\")     # stdcall ignored\n        m = ffi.dlopen(lib_m)\n        if (sys.platform == 'win32' and sys.maxsize < 2**32 and\n                self.Backend is not CTypesBackend):\n            assert \"double(__stdcall *)(double)\" in str(ffi.typeof(m.sin))\n        else:\n            assert \"double(*)(double)\" in str(ffi.typeof(m.sin))\n        x = m.sin(1.23)\n        assert x == math.sin(1.23)\n\n    def test_dir_on_dlopen_lib(self):\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            typedef enum { MYE1, MYE2 } myenum_t;\n            double myfunc(double);\n            extern double myvar;\n            const double myconst;\n            #define MYFOO 42\n        \"\"\")\n        m = ffi.dlopen(lib_m)\n        assert dir(m) == ['MYE1', 'MYE2', 'MYFOO', 'myconst', 'myfunc', 'myvar']\n\n    def test_dlclose(self):\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"not with the ctypes backend\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"int foobar(void); extern int foobaz;\")\n        lib = ffi.dlopen(lib_m)\n        ffi.dlclose(lib)\n        e = pytest.raises(ValueError, getattr, lib, 'foobar')\n        assert str(e.value).startswith(\"library '\")\n        assert str(e.value).endswith(\"' has already been closed\")\n        e = pytest.raises(ValueError, getattr, lib, 'foobaz')\n        assert str(e.value).startswith(\"library '\")\n        assert str(e.value).endswith(\"' has already been closed\")\n        e = pytest.raises(ValueError, setattr, lib, 'foobaz', 42)\n        assert str(e.value).startswith(\"library '\")\n        assert str(e.value).endswith(\"' has already been closed\")\n        ffi.dlclose(lib)    # does not raise\n\n    def test_passing_large_list(self):\n        if self.Backend is CTypesBackend:\n            pytest.skip(\"the ctypes backend doesn't support this\")\n        ffi = FFI(backend=self.Backend())\n        ffi.cdef(\"\"\"\n            void getenv(char *);\n        \"\"\")\n        needs_dlopen_none()\n        m = ffi.dlopen(None)\n        arg = [b\"F\", b\"O\", b\"O\"] + [b\"\\x00\"] * 20000000\n        x = m.getenv(arg)\n        assert x is None\n", "testing/cffi0/test_vgen.py": "import cffi.verifier\nfrom .test_verify import *\n\n\ndef setup_module():\n    cffi.verifier.cleanup_tmpdir()\n    cffi.verifier._FORCE_GENERIC_ENGINE = True\n    # Runs all tests with _FORCE_GENERIC_ENGINE = True, to make sure we\n    # also test vengine_gen.py.\n\ndef teardown_module():\n    cffi.verifier._FORCE_GENERIC_ENGINE = False\n", "testing/cffi0/test_zintegration.py": "import py, os, sys, shutil\nimport subprocess\nimport textwrap\nfrom testing.udir import udir\nimport pytest\n\nif sys.platform == 'win32':\n    pytestmark = pytest.mark.skip('snippets do not run on win32')\nif sys.version_info < (2, 7):\n    pytestmark = pytest.mark.skip(\n                 'fails e.g. on a Debian/Ubuntu which patches virtualenv'\n                 ' in a non-2.6-friendly way')\n\ndef create_venv(name):\n    tmpdir = udir.join(name)\n    try:\n        # FUTURE: we should probably update this to use venv for at least more modern Pythons, and\n        # install setuptools/pip/etc explicitly for the tests that require them (as venv has stopped including\n        # setuptools and wheel by default for newer versions).\n        subprocess.check_call(['virtualenv', \n            #'--never-download', <= could be added, but causes failures\n            # in random cases on random machines\n                               '-p', os.path.abspath(sys.executable),\n                               str(tmpdir)])\n\n        # Python 3.12 venv/virtualenv no longer include setuptools and wheel by default, which\n        # breaks a number of these tests; ensure it's always present for 3.12+\n        if sys.version_info >= (3, 12):\n            subprocess.check_call([\n                os.path.join(tmpdir, 'bin/python'),\n                '-m',\n                'pip',\n                'install',\n                'setuptools',\n                'wheel',\n                '--upgrade'\n            ])\n\n    except OSError as e:\n        pytest.skip(\"Cannot execute virtualenv: %s\" % (e,))\n\n    site_packages = None\n    for dirpath, dirnames, filenames in os.walk(str(tmpdir)):\n        if os.path.basename(dirpath) == 'site-packages':\n            site_packages = dirpath\n            break\n    paths = \"\"\n    if site_packages:\n        try:\n            from cffi import _pycparser\n            modules = ('cffi', '_cffi_backend')\n        except ImportError:\n            modules = ('cffi', '_cffi_backend', 'pycparser')\n            try:\n                import ply\n            except ImportError:\n                pass\n            else:\n                modules += ('ply',)   # needed for older versions of pycparser\n        paths = []\n        for module in modules:\n            target = __import__(module, None, None, [])\n            if not hasattr(target, '__file__'):   # for _cffi_backend on pypy\n                continue\n            src = os.path.abspath(target.__file__)\n            for end in ['__init__.pyc', '__init__.pyo', '__init__.py']:\n                if src.lower().endswith(end):\n                    src = src[:-len(end)-1]\n                    break\n            paths.append(os.path.dirname(src))\n        paths = os.pathsep.join(paths)\n    return tmpdir, paths\n\nSNIPPET_DIR = py.path.local(__file__).join('..', 'snippets')\n\ndef really_run_setup_and_program(dirname, venv_dir_and_paths, python_snippet):\n    venv_dir, paths = venv_dir_and_paths\n    def remove(dir):\n        dir = str(SNIPPET_DIR.join(dirname, dir))\n        shutil.rmtree(dir, ignore_errors=True)\n    remove('build')\n    remove('__pycache__')\n    for basedir in os.listdir(str(SNIPPET_DIR.join(dirname))):\n        remove(os.path.join(basedir, '__pycache__'))\n    olddir = os.getcwd()\n    python_f = udir.join('x.py')\n    python_f.write(textwrap.dedent(python_snippet))\n    try:\n        os.chdir(str(SNIPPET_DIR.join(dirname)))\n        if os.name == 'nt':\n            bindir = 'Scripts'\n        else:\n            bindir = 'bin'\n        vp = str(venv_dir.join(bindir).join('python'))\n        env = os.environ.copy()\n        env['PYTHONPATH'] = paths\n        subprocess.check_call((vp, 'setup.py', 'clean'), env=env)\n        # there's a setuptools/easy_install bug that causes this to fail when the build/install occur together and\n        # we're in the same directory with the build (it tries to look up dependencies for itself on PyPI);\n        # subsequent runs will succeed because this test doesn't properly clean up the build- use pip for now.\n        subprocess.check_call((vp, '-m', 'pip', 'install', '.'), env=env)\n        subprocess.check_call((vp, str(python_f)), env=env)\n    finally:\n        os.chdir(olddir)\n\ndef run_setup_and_program(dirname, python_snippet):\n    venv_dir = create_venv(dirname + '-cpy')\n    really_run_setup_and_program(dirname, venv_dir, python_snippet)\n    #\n    sys._force_generic_engine_ = True\n    try:\n        venv_dir = create_venv(dirname + '-gen')\n        really_run_setup_and_program(dirname, venv_dir, python_snippet)\n    finally:\n        del sys._force_generic_engine_\n    # the two files lextab.py and yacctab.py are created by not-correctly-\n    # installed versions of pycparser.\n    assert not os.path.exists(str(SNIPPET_DIR.join(dirname, 'lextab.py')))\n    assert not os.path.exists(str(SNIPPET_DIR.join(dirname, 'yacctab.py')))\n\nclass TestZIntegration(object):\n    def teardown_class(self):\n        if udir.isdir():\n            udir.remove(ignore_errors=True)\n        udir.ensure(dir=1)\n\n    def test_infrastructure(self):\n        run_setup_and_program('infrastructure', '''\n        import snip_infrastructure\n        assert snip_infrastructure.func() == 42\n        ''')\n\n    def test_distutils_module(self):\n        run_setup_and_program(\"distutils_module\", '''\n        import snip_basic_verify\n        p = snip_basic_verify.C.getpwuid(0)\n        assert snip_basic_verify.ffi.string(p.pw_name) == b\"root\"\n        ''')\n\n    def test_distutils_package_1(self):\n        run_setup_and_program(\"distutils_package_1\", '''\n        import snip_basic_verify1\n        p = snip_basic_verify1.C.getpwuid(0)\n        assert snip_basic_verify1.ffi.string(p.pw_name) == b\"root\"\n        ''')\n\n    def test_distutils_package_2(self):\n        run_setup_and_program(\"distutils_package_2\", '''\n        import snip_basic_verify2\n        p = snip_basic_verify2.C.getpwuid(0)\n        assert snip_basic_verify2.ffi.string(p.pw_name) == b\"root\"\n        ''')\n\n    def test_setuptools_module(self):\n        run_setup_and_program(\"setuptools_module\", '''\n        import snip_setuptools_verify\n        p = snip_setuptools_verify.C.getpwuid(0)\n        assert snip_setuptools_verify.ffi.string(p.pw_name) == b\"root\"\n        ''')\n\n    def test_setuptools_package_1(self):\n        run_setup_and_program(\"setuptools_package_1\", '''\n        import snip_setuptools_verify1\n        p = snip_setuptools_verify1.C.getpwuid(0)\n        assert snip_setuptools_verify1.ffi.string(p.pw_name) == b\"root\"\n        ''')\n\n    def test_setuptools_package_2(self):\n        run_setup_and_program(\"setuptools_package_2\", '''\n        import snip_setuptools_verify2\n        p = snip_setuptools_verify2.C.getpwuid(0)\n        assert snip_setuptools_verify2.ffi.string(p.pw_name) == b\"root\"\n        ''')\n\n    def test_set_py_limited_api(self):\n        from cffi.setuptools_ext import _set_py_limited_api\n        try:\n            import setuptools\n        except ImportError as e:\n            pytest.skip(str(e))\n        orig_version = setuptools.__version__\n        expecting_limited_api = not hasattr(sys, 'gettotalrefcount')\n        try:\n            setuptools.__version__ = '26.0.0'\n            from setuptools import Extension\n\n            kwds = _set_py_limited_api(Extension, {})\n            assert kwds.get('py_limited_api', False) == expecting_limited_api\n\n            setuptools.__version__ = '25.0'\n            kwds = _set_py_limited_api(Extension, {})\n            assert kwds.get('py_limited_api', False) == False\n\n            setuptools.__version__ = 'development'\n            kwds = _set_py_limited_api(Extension, {})\n            assert kwds.get('py_limited_api', False) == expecting_limited_api\n\n        finally:\n            setuptools.__version__ = orig_version\n", "testing/cffi0/snippets/distutils_package_2/setup.py": "\nfrom distutils.core import setup\nimport snip_basic_verify2\n\nsetup(\n    packages=['snip_basic_verify2'],\n    ext_package='snip_basic_verify2',\n    ext_modules=[snip_basic_verify2.ffi.verifier.get_extension()])\n", "testing/cffi0/snippets/distutils_package_2/snip_basic_verify2/__init__.py": "\nfrom cffi import FFI\nimport sys\n\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...;\n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\nC = ffi.verify(\"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\", libraries=[],    # or a list of libraries to link with\n     ext_package='snip_basic_verify2',\n     force_generic_engine=hasattr(sys, '_force_generic_engine_'))\n", "testing/cffi0/snippets/infrastructure/setup.py": "\nfrom distutils.core import setup\n\nsetup(packages=['snip_infrastructure'],\n      requires=['cffi'])\n", "testing/cffi0/snippets/infrastructure/snip_infrastructure/__init__.py": "\ndef func():\n    return 42\n", "testing/cffi0/snippets/distutils_package_1/setup.py": "\nfrom distutils.core import setup\nimport snip_basic_verify1\n\nsetup(\n    packages=['snip_basic_verify1'],\n    ext_modules=[snip_basic_verify1.ffi.verifier.get_extension()])\n", "testing/cffi0/snippets/distutils_package_1/snip_basic_verify1/__init__.py": "\nfrom cffi import FFI\nimport sys\n\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...;\n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\nC = ffi.verify(\"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\", libraries=[],    # or a list of libraries to link with\n     force_generic_engine=hasattr(sys, '_force_generic_engine_'))\n", "testing/cffi0/snippets/distutils_module/setup.py": "\nfrom distutils.core import setup\nimport snip_basic_verify\n\nsetup(\n    py_modules=['snip_basic_verify'],\n    ext_modules=[snip_basic_verify.ffi.verifier.get_extension()])\n", "testing/cffi0/snippets/distutils_module/snip_basic_verify.py": "\nfrom cffi import FFI\nimport sys\n\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...;\n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\nC = ffi.verify(\"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\", libraries=[],    # or a list of libraries to link with\n     force_generic_engine=hasattr(sys, '_force_generic_engine_'))\n", "testing/cffi0/snippets/setuptools_module/setup.py": "\nfrom setuptools import setup\nimport snip_setuptools_verify\n\nsetup(\n    zip_safe=False,\n    py_modules=['snip_setuptools_verify'],\n    ext_modules=[snip_setuptools_verify.ffi.verifier.get_extension()])\n", "testing/cffi0/snippets/setuptools_module/snip_setuptools_verify.py": "\nfrom cffi import FFI\nimport sys\n\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...;\n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\nC = ffi.verify(\"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\", libraries=[],    # or a list of libraries to link with\n     force_generic_engine=hasattr(sys, '_force_generic_engine_'))\n", "testing/cffi0/snippets/setuptools_package_2/setup.py": "\nfrom setuptools import setup\nimport snip_setuptools_verify2\n\nsetup(\n    zip_safe=False,\n    packages=['snip_setuptools_verify2'],\n    ext_package='snip_setuptools_verify2',\n    ext_modules=[snip_setuptools_verify2.ffi.verifier.get_extension()])\n", "testing/cffi0/snippets/setuptools_package_2/snip_setuptools_verify2/__init__.py": "\nfrom cffi import FFI\nimport sys\n\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...;\n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\nC = ffi.verify(\"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\", libraries=[],    # or a list of libraries to link with\n     ext_package='snip_setuptools_verify2',\n     force_generic_engine=hasattr(sys, '_force_generic_engine_'))\n", "testing/cffi0/snippets/setuptools_package_1/setup.py": "\nfrom setuptools import setup\nimport snip_setuptools_verify1\n\nsetup(\n    zip_safe=False,\n    packages=['snip_setuptools_verify1'],\n    ext_modules=[snip_setuptools_verify1.ffi.verifier.get_extension()])\n", "testing/cffi0/snippets/setuptools_package_1/snip_setuptools_verify1/__init__.py": "\nfrom cffi import FFI\nimport sys\n\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...;\n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\nC = ffi.verify(\"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\", libraries=[],    # or a list of libraries to link with\n     force_generic_engine=hasattr(sys, '_force_generic_engine_'))\n", "src/c/test_c.py": "from __future__ import annotations\n\nimport contextlib\nimport traceback\nimport unittest.mock\n\nimport pytest\nimport sys\nimport typing as t\n\nis_musl = False\nif sys.platform == 'linux':\n    try:\n        from packaging.tags import platform_tags\n        is_musl = any(t.startswith('musllinux') for t in platform_tags())\n        del platform_tags\n    except ImportError:\n        pass\n\ndef _setup_path():\n    import os, sys\n    sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))\n_setup_path()\nfrom _cffi_backend import *\nfrom _cffi_backend import _get_types, _get_common_types\ntry:\n    from _cffi_backend import _testfunc\nexcept ImportError:\n    def _testfunc(num):\n        pytest.skip(\"_testunc() not available\")\nfrom _cffi_backend import __version__\n\n\n@contextlib.contextmanager\ndef _assert_unraisable(error_type: type[Exception] | None, message: str = '', traceback_tokens: list[str] | None = None):\n    \"\"\"Assert that a given sys.unraisablehook interaction occurred (or did not occur, if error_type is None) while this context was active\"\"\"\n    raised_errors: list[Exception] = []\n    raised_traceback: str = ''\n\n    # sys.unraisablehook is called more than once for chained exceptions; accumulate the errors and tracebacks for inspection\n    def _capture_unraisable_hook(ur_args):\n        nonlocal raised_traceback\n        raised_errors.append(ur_args.exc_value)\n\n        # NB: need to use the old etype/value/tb form until 3.10 is the minimum\n        raised_traceback += (ur_args.err_msg or '' + '\\n') + ''.join(traceback.format_exception(None, ur_args.exc_value, ur_args.exc_traceback))\n\n\n    with pytest.MonkeyPatch.context() as mp:\n        mp.setattr(sys, 'unraisablehook', _capture_unraisable_hook)\n        yield\n\n    if error_type is None:\n        assert not raised_errors\n        assert not raised_traceback\n        return\n\n    assert any(type(raised_error) is error_type for raised_error in raised_errors)\n    assert any(message in str(raised_error) for raised_error in raised_errors)\n    for t in traceback_tokens or []:\n        assert t in raised_traceback\n\n# ____________________________________________________________\n\nimport sys\nassert __version__ == \"1.17.0.dev0\", (\"This test_c.py file is for testing a version\"\n                                 \" of cffi that differs from the one that we\"\n                                 \" get from 'import _cffi_backend'\")\nif sys.version_info < (3,):\n    type_or_class = \"type\"\n    mandatory_b_prefix = ''\n    mandatory_u_prefix = 'u'\n    bytechr = chr\n    bitem2bchr = lambda x: x\n    class U(object):\n        def __add__(self, other):\n            return eval('u'+repr(other).replace(r'\\\\u', r'\\u')\n                                       .replace(r'\\\\U', r'\\U'))\n    u = U()\n    str2bytes = str\n    strict_compare = False\nelse:\n    type_or_class = \"class\"\n    long = int\n    unicode = str\n    unichr = chr\n    mandatory_b_prefix = 'b'\n    mandatory_u_prefix = ''\n    bytechr = lambda n: bytes([n])\n    bitem2bchr = bytechr\n    u = \"\"\n    str2bytes = lambda s: bytes(s, \"ascii\")\n    strict_compare = True\n\ndef size_of_int():\n    BInt = new_primitive_type(\"int\")\n    return sizeof(BInt)\n\ndef size_of_long():\n    BLong = new_primitive_type(\"long\")\n    return sizeof(BLong)\n\ndef size_of_ptr():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    return sizeof(BPtr)\n\n\ndef find_and_load_library(name, flags=RTLD_NOW):\n    import ctypes.util\n    if name is None:\n        path = None\n    else:\n        path = ctypes.util.find_library(name)\n        if path is None and sys.platform == 'darwin' and sys.version_info[:2] == (3, 8):\n            pytest.xfail(\"find_library usually broken on MacOS Python 3.8\")\n        if path is None and name == 'c':\n            assert sys.platform == 'win32'\n            assert (sys.version_info >= (3,) or\n                    '__pypy__' in sys.builtin_module_names)\n            pytest.skip(\"dlopen(None) cannot work on Windows \"\n                         \"with PyPy or Python 3\")\n    return load_library(path, flags)\n\ndef test_load_library():\n    x = find_and_load_library('c')\n    assert repr(x).startswith(\"<clibrary '\")\n    x = find_and_load_library('c', RTLD_NOW | RTLD_GLOBAL)\n    assert repr(x).startswith(\"<clibrary '\")\n    x = find_and_load_library('c', RTLD_LAZY)\n    assert repr(x).startswith(\"<clibrary '\")\n\ndef test_all_rtld_symbols():\n    import sys\n    FFI_DEFAULT_ABI        # these symbols must be defined\n    FFI_CDECL\n    RTLD_LAZY\n    RTLD_NOW\n    RTLD_GLOBAL\n    RTLD_LOCAL\n    if sys.platform.startswith(\"linux\"):\n        RTLD_NODELETE\n        RTLD_NOLOAD\n        if not is_musl:\n            RTLD_DEEPBIND\n\ndef test_new_primitive_type():\n    pytest.raises(KeyError, new_primitive_type, \"foo\")\n    p = new_primitive_type(\"signed char\")\n    assert repr(p) == \"<ctype 'signed char'>\"\n\ndef check_dir(p, expected):\n    got = [name for name in dir(p) if not name.startswith('_')]\n    assert got == sorted(expected)\n\ndef test_inspect_primitive_type():\n    p = new_primitive_type(\"signed char\")\n    assert p.kind == \"primitive\"\n    assert p.cname == \"signed char\"\n    check_dir(p, ['cname', 'kind'])\n\ndef test_cast_to_signed_char():\n    p = new_primitive_type(\"signed char\")\n    x = cast(p, -65 + 17*256)\n    assert repr(x) == \"<cdata 'signed char' -65>\"\n    assert repr(type(x)) == \"<%s '_cffi_backend._CDataBase'>\" % type_or_class\n    assert int(x) == -65\n    x = cast(p, -66 + (1<<199)*256)\n    assert repr(x) == \"<cdata 'signed char' -66>\"\n    assert int(x) == -66\n    assert (x == cast(p, -66)) is True\n    assert (x != cast(p, -66)) is False\n    q = new_primitive_type(\"short\")\n    assert (x == cast(q, -66)) is True\n    assert (x != cast(q, -66)) is False\n\ndef test_sizeof_type():\n    pytest.raises(TypeError, sizeof, 42.5)\n    p = new_primitive_type(\"short\")\n    assert sizeof(p) == 2\n\ndef test_integer_types():\n    for name in ['signed char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type(name)\n        size = sizeof(p)\n        min = -(1 << (8*size-1))\n        max = (1 << (8*size-1)) - 1\n        assert int(cast(p, min)) == min\n        assert int(cast(p, max)) == max\n        assert int(cast(p, min - 1)) == max\n        assert int(cast(p, max + 1)) == min\n        pytest.raises(TypeError, cast, p, None)\n        assert long(cast(p, min - 1)) == max\n        assert int(cast(p, b'\\x08')) == 8\n        assert int(cast(p, u+'\\x08')) == 8\n    for name in ['char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type('unsigned ' + name)\n        size = sizeof(p)\n        max = (1 << (8*size)) - 1\n        assert int(cast(p, 0)) == 0\n        assert int(cast(p, max)) == max\n        assert int(cast(p, -1)) == max\n        assert int(cast(p, max + 1)) == 0\n        assert long(cast(p, -1)) == max\n        assert int(cast(p, b'\\xFE')) == 254\n        assert int(cast(p, u+'\\xFE')) == 254\n\ndef test_no_float_on_int_types():\n    p = new_primitive_type('long')\n    pytest.raises(TypeError, float, cast(p, 42))\n    pytest.raises(TypeError, complex, cast(p, 42))\n\ndef test_float_types():\n    INF = 1E200 * 1E200\n    for name in [\"float\", \"double\"]:\n        p = new_primitive_type(name)\n        assert bool(cast(p, 0)) is False      # since 1.7\n        assert bool(cast(p, -0.0)) is False   # since 1.7\n        assert bool(cast(p, 1e-42)) is True\n        assert bool(cast(p, -1e-42)) is True\n        assert bool(cast(p, INF))\n        assert bool(cast(p, -INF))\n        assert bool(cast(p, float(\"nan\")))\n        assert int(cast(p, -150)) == -150\n        assert int(cast(p, 61.91)) == 61\n        assert long(cast(p, 61.91)) == 61\n        assert type(int(cast(p, 61.91))) is int\n        assert type(int(cast(p, 1E22))) is long\n        assert type(long(cast(p, 61.91))) is long\n        assert type(long(cast(p, 1E22))) is long\n        pytest.raises(OverflowError, int, cast(p, INF))\n        pytest.raises(OverflowError, int, cast(p, -INF))\n        assert float(cast(p, 1.25)) == 1.25\n        assert float(cast(p, INF)) == INF\n        assert float(cast(p, -INF)) == -INF\n        if name == \"float\":\n            assert float(cast(p, 1.1)) != 1.1     # rounding error\n            assert float(cast(p, 1E200)) == INF   # limited range\n\n        assert cast(p, -1.1) == cast(p, -1.1)\n        assert repr(float(cast(p, -0.0))) == '-0.0'\n        assert float(cast(p, b'\\x09')) == 9.0\n        assert float(cast(p, u+'\\x09')) == 9.0\n        assert float(cast(p, True)) == 1.0\n        pytest.raises(TypeError, cast, p, None)\n\ndef test_complex_types():\n    INF = 1E200 * 1E200\n    for name in [\"float\", \"double\"]:\n        p = new_primitive_type(name + \" _Complex\")\n        assert bool(cast(p, 0)) is False\n        assert bool(cast(p, INF))\n        assert bool(cast(p, -INF))\n        assert bool(cast(p, 0j)) is False\n        assert bool(cast(p, INF*1j))\n        assert bool(cast(p, -INF*1j))\n        # \"can't convert complex to float\", like CPython's \"float(0j)\"\n        pytest.raises(TypeError, int, cast(p, -150))\n        pytest.raises(TypeError, long, cast(p, -150))\n        pytest.raises(TypeError, float, cast(p, -150))\n        assert complex(cast(p, 1.25)) == 1.25\n        assert complex(cast(p, 1.25j)) == 1.25j\n        assert complex(cast(p, complex(0,INF))) == complex(0,INF)\n        assert complex(cast(p, -INF)) == -INF\n        if name == \"float\":\n            assert complex(cast(p, 1.1j)) != 1.1j         # rounding error\n            assert complex(cast(p, 1E200+3j)) == INF+3j   # limited range\n            assert complex(cast(p, complex(3,1E200))) == complex(3,INF) # limited range\n\n        assert cast(p, -1.1j) == cast(p, -1.1j)\n        assert repr(complex(cast(p, -0.0)).real) == '-0.0'\n        #assert repr(complex(cast(p, -0j))) == '-0j'   # http://bugs.python.org/issue29602\n        assert complex(cast(p, b'\\x09')) == 9.0 + 0j\n        assert complex(cast(p, u+'\\x09')) == 9.0 + 0j\n        assert complex(cast(p, True)) == 1.0 + 0j\n        pytest.raises(TypeError, cast, p, None)\n        #\n        pytest.raises(TypeError, cast, new_primitive_type(name), 1+0j)\n        #\n        for basetype in [\"char\", \"int\", \"uint64_t\", \"float\",\n                         \"double\", \"long double\"]:\n            baseobj = cast(new_primitive_type(basetype), 65)\n            pytest.raises(TypeError, complex, baseobj)\n        #\n        BArray = new_array_type(new_pointer_type(p), 10)\n        x = newp(BArray, None)\n        x[5] = 12.34 + 56.78j\n        assert type(x[5]) is complex\n        assert abs(x[5] - (12.34 + 56.78j)) < 1e-5\n        assert (x[5] == 12.34 + 56.78j) == (name == \"double\")  # rounding error\n        #\n        class Foo:\n            def __complex__(self):\n                return 2 + 3j\n        assert complex(Foo()) == 2 + 3j\n        assert complex(cast(p, Foo())) == 2 + 3j\n    pytest.raises(TypeError, cast, new_primitive_type(\"int\"), 1+0j)\n\ndef test_character_type():\n    p = new_primitive_type(\"char\")\n    assert bool(cast(p, 'A')) is True\n    assert bool(cast(p, '\\x00')) is False    # since 1.7\n    assert cast(p, '\\x00') == cast(p, -17*256)\n    assert int(cast(p, 'A')) == 65\n    assert long(cast(p, 'A')) == 65\n    assert type(int(cast(p, 'A'))) is int\n    assert type(long(cast(p, 'A'))) is long\n    assert str(cast(p, 'A')) == repr(cast(p, 'A'))\n    assert repr(cast(p, 'A')) == \"<cdata 'char' %s'A'>\" % mandatory_b_prefix\n    assert repr(cast(p, 255)) == r\"<cdata 'char' %s'\\xff'>\" % mandatory_b_prefix\n    assert repr(cast(p, 0)) == r\"<cdata 'char' %s'\\x00'>\" % mandatory_b_prefix\n\ndef test_pointer_type():\n    p = new_primitive_type(\"int\")\n    assert repr(p) == \"<ctype 'int'>\"\n    p = new_pointer_type(p)\n    assert repr(p) == \"<ctype 'int *'>\"\n    p = new_pointer_type(p)\n    assert repr(p) == \"<ctype 'int * *'>\"\n    p = new_pointer_type(p)\n    assert repr(p) == \"<ctype 'int * * *'>\"\n\ndef test_inspect_pointer_type():\n    p1 = new_primitive_type(\"int\")\n    p2 = new_pointer_type(p1)\n    assert p2.kind == \"pointer\"\n    assert p2.cname == \"int *\"\n    assert p2.item is p1\n    check_dir(p2, ['cname', 'kind', 'item'])\n    p3 = new_pointer_type(p2)\n    assert p3.item is p2\n\ndef test_pointer_to_int():\n    BInt = new_primitive_type(\"int\")\n    pytest.raises(TypeError, newp, BInt)\n    pytest.raises(TypeError, newp, BInt, None)\n    BPtr = new_pointer_type(BInt)\n    p = newp(BPtr)\n    assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % size_of_int()\n    p = newp(BPtr, None)\n    assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % size_of_int()\n    p = newp(BPtr, 5000)\n    assert repr(p) == \"<cdata 'int *' owning %d bytes>\" % size_of_int()\n    q = cast(BPtr, p)\n    assert repr(q).startswith(\"<cdata 'int *' 0x\")\n    assert p == q\n    assert hash(p) == hash(q)\n    e = pytest.raises(TypeError, newp, new_array_type(BPtr, None), None)\n    assert str(e.value) == (\n        \"expected new array length or list/tuple/str, not NoneType\")\n\ndef test_pointer_bool():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    p = cast(BPtr, 0)\n    assert bool(p) is False\n    p = cast(BPtr, 42)\n    assert bool(p) is True\n\ndef test_pointer_to_pointer():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    BPtrPtr = new_pointer_type(BPtr)\n    p = newp(BPtrPtr, None)\n    assert repr(p) == \"<cdata 'int * *' owning %d bytes>\" % size_of_ptr()\n\ndef test_reading_pointer_to_int():\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    p = newp(BPtr, None)\n    assert p[0] == 0\n    p = newp(BPtr, 5000)\n    assert p[0] == 5000\n    with pytest.raises(IndexError):\n        p[1]\n    with pytest.raises(IndexError):\n        p[-1]\n\ndef test_reading_pointer_to_float():\n    BFloat = new_primitive_type(\"float\")\n    pytest.raises(TypeError, newp, BFloat, None)\n    BPtr = new_pointer_type(BFloat)\n    p = newp(BPtr, None)\n    assert p[0] == 0.0 and type(p[0]) is float\n    p = newp(BPtr, 1.25)\n    assert p[0] == 1.25 and type(p[0]) is float\n    p = newp(BPtr, 1.1)\n    assert p[0] != 1.1 and abs(p[0] - 1.1) < 1E-5   # rounding errors\n\ndef test_cast_float_to_int():\n    for type in [\"int\", \"unsigned int\", \"long\", \"unsigned long\",\n                 \"long long\", \"unsigned long long\"]:\n        p = new_primitive_type(type)\n        assert int(cast(p, 4.2)) == 4\n        pytest.raises(TypeError, newp, new_pointer_type(p), 4.2)\n\ndef test_newp_integer_types():\n    for name in ['signed char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type(name)\n        pp = new_pointer_type(p)\n        size = sizeof(p)\n        min = -(1 << (8*size-1))\n        max = (1 << (8*size-1)) - 1\n        assert newp(pp, min)[0] == min\n        assert newp(pp, max)[0] == max\n        pytest.raises(OverflowError, newp, pp, min - 2 ** 32)\n        pytest.raises(OverflowError, newp, pp, min - 2 ** 64)\n        pytest.raises(OverflowError, newp, pp, max + 2 ** 32)\n        pytest.raises(OverflowError, newp, pp, max + 2 ** 64)\n        pytest.raises(OverflowError, newp, pp, min - 1)\n        pytest.raises(OverflowError, newp, pp, max + 1)\n        pytest.raises(OverflowError, newp, pp, min - 1 - 2 ** 32)\n        pytest.raises(OverflowError, newp, pp, min - 1 - 2 ** 64)\n        pytest.raises(OverflowError, newp, pp, max + 1)\n        pytest.raises(OverflowError, newp, pp, max + 1 + 2 ** 32)\n        pytest.raises(OverflowError, newp, pp, max + 1 + 2 ** 64)\n        pytest.raises(TypeError, newp, pp, 1.0)\n    for name in ['char', 'short', 'int', 'long', 'long long']:\n        p = new_primitive_type('unsigned ' + name)\n        pp = new_pointer_type(p)\n        size = sizeof(p)\n        max = (1 << (8*size)) - 1\n        assert newp(pp, 0)[0] == 0\n        assert newp(pp, max)[0] == max\n        pytest.raises(OverflowError, newp, pp, -1)\n        pytest.raises(OverflowError, newp, pp, max + 1)\n\ndef test_reading_pointer_to_char():\n    BChar = new_primitive_type(\"char\")\n    pytest.raises(TypeError, newp, BChar, None)\n    BPtr = new_pointer_type(BChar)\n    p = newp(BPtr, None)\n    assert p[0] == b'\\x00'\n    p = newp(BPtr, b'A')\n    assert p[0] == b'A'\n    pytest.raises(TypeError, newp, BPtr, 65)\n    pytest.raises(TypeError, newp, BPtr, b\"foo\")\n    pytest.raises(TypeError, newp, BPtr, u+\"foo\")\n    c = cast(BChar, b'A')\n    assert str(c) == repr(c)\n    assert int(c) == ord(b'A')\n    pytest.raises(TypeError, cast, BChar, b'foo')\n    pytest.raises(TypeError, cast, BChar, u+'foo')\n    e = pytest.raises(TypeError, newp, new_array_type(BPtr, None), 12.3)\n    assert str(e.value) == (\n        \"expected new array length or list/tuple/str, not float\")\n\ndef test_reading_pointer_to_pointer():\n    BVoidP = new_pointer_type(new_void_type())\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BIntPtrPtr = new_pointer_type(BIntPtr)\n    q = newp(BIntPtr, 42)\n    assert q[0] == 42\n    p = newp(BIntPtrPtr, None)\n    assert p[0] is not None\n    assert p[0] == cast(BVoidP, 0)\n    assert p[0] == cast(BCharP, 0)\n    assert p[0] != None\n    assert repr(p[0]) == \"<cdata 'int *' NULL>\"\n    p[0] = q\n    assert p[0] != cast(BVoidP, 0)\n    assert p[0] != cast(BCharP, 0)\n    assert p[0][0] == 42\n    q[0] += 1\n    assert p[0][0] == 43\n    p = newp(BIntPtrPtr, q)\n    assert p[0][0] == 43\n\ndef test_load_standard_library():\n    if sys.platform == \"win32\":\n        pytest.raises(OSError, find_and_load_library, None)\n        return\n    x = find_and_load_library(None)\n    BVoidP = new_pointer_type(new_void_type())\n    assert x.load_function(BVoidP, 'strcpy')\n    pytest.raises(AttributeError, x.load_function,\n                   BVoidP, 'xxx_this_function_does_not_exist')\n    # the next one is from 'libm', not 'libc', but we assume\n    # that it is already loaded too, so it should work\n    assert x.load_function(BVoidP, 'sqrt')\n    #\n    x.close_lib()\n    pytest.raises(ValueError, x.load_function, BVoidP, 'sqrt')\n    x.close_lib()\n\ndef test_no_len_on_nonarray():\n    p = new_primitive_type(\"int\")\n    pytest.raises(TypeError, len, cast(p, 42))\n\ndef test_cmp_none():\n    p = new_primitive_type(\"int\")\n    x = cast(p, 42)\n    assert (x == None) is False\n    assert (x != None) is True\n    assert (x == [\"hello\"]) is False\n    assert (x != [\"hello\"]) is True\n    y = cast(p, 0)\n    assert (y == None) is False\n\ndef test_invalid_indexing():\n    p = new_primitive_type(\"int\")\n    x = cast(p, 42)\n    with pytest.raises(TypeError):\n        x[0]\n\ndef test_default_str():\n    BChar = new_primitive_type(\"char\")\n    x = cast(BChar, 42)\n    assert str(x) == repr(x)\n    BInt = new_primitive_type(\"int\")\n    x = cast(BInt, 42)\n    assert str(x) == repr(x)\n    BArray = new_array_type(new_pointer_type(BInt), 10)\n    x = newp(BArray, None)\n    assert str(x) == repr(x)\n\ndef test_default_unicode():\n    BInt = new_primitive_type(\"int\")\n    x = cast(BInt, 42)\n    assert unicode(x) == unicode(repr(x))\n    BArray = new_array_type(new_pointer_type(BInt), 10)\n    x = newp(BArray, None)\n    assert unicode(x) == unicode(repr(x))\n\ndef test_cast_from_cdataint():\n    BInt = new_primitive_type(\"int\")\n    x = cast(BInt, 0)\n    y = cast(new_pointer_type(BInt), x)\n    assert bool(y) is False\n    #\n    x = cast(BInt, 42)\n    y = cast(BInt, x)\n    assert int(y) == 42\n    y = cast(new_primitive_type(\"char\"), x)\n    assert int(y) == 42\n    y = cast(new_primitive_type(\"float\"), x)\n    assert float(y) == 42.0\n    #\n    z = cast(BInt, 42.5)\n    assert int(z) == 42\n    z = cast(BInt, y)\n    assert int(z) == 42\n\ndef test_void_type():\n    p = new_void_type()\n    assert p.kind == \"void\"\n    assert p.cname == \"void\"\n    check_dir(p, ['kind', 'cname'])\n\ndef test_array_type():\n    p = new_primitive_type(\"int\")\n    assert repr(p) == \"<ctype 'int'>\"\n    #\n    pytest.raises(TypeError, new_array_type, new_pointer_type(p), \"foo\")\n    pytest.raises(ValueError, new_array_type, new_pointer_type(p), -42)\n    #\n    p1 = new_array_type(new_pointer_type(p), None)\n    assert repr(p1) == \"<ctype 'int[]'>\"\n    pytest.raises(ValueError, new_array_type, new_pointer_type(p1), 42)\n    #\n    p1 = new_array_type(new_pointer_type(p), 42)\n    p2 = new_array_type(new_pointer_type(p1), 25)\n    assert repr(p2) == \"<ctype 'int[25][42]'>\"\n    p2 = new_array_type(new_pointer_type(p1), None)\n    assert repr(p2) == \"<ctype 'int[][42]'>\"\n    #\n    pytest.raises(OverflowError,\n                   new_array_type, new_pointer_type(p), sys.maxsize+1)\n    pytest.raises(OverflowError,\n                   new_array_type, new_pointer_type(p), sys.maxsize // 3)\n\ndef test_inspect_array_type():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    assert p1.kind == \"array\"\n    assert p1.cname == \"int[]\"\n    assert p1.item is p\n    assert p1.length is None\n    check_dir(p1, ['cname', 'kind', 'item', 'length'])\n    p1 = new_array_type(new_pointer_type(p), 42)\n    assert p1.kind == \"array\"\n    assert p1.cname == \"int[42]\"\n    assert p1.item is p\n    assert p1.length == 42\n    check_dir(p1, ['cname', 'kind', 'item', 'length'])\n\ndef test_array_instance():\n    LENGTH = 1423\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), LENGTH)\n    a = newp(p1, None)\n    assert repr(a) == \"<cdata 'int[%d]' owning %d bytes>\" % (\n        LENGTH, LENGTH * size_of_int())\n    assert len(a) == LENGTH\n    for i in range(LENGTH):\n        assert a[i] == 0\n    with pytest.raises(IndexError):\n        a[LENGTH]\n    with pytest.raises(IndexError):\n        a[-1]\n    for i in range(LENGTH):\n        a[i] = i * i + 1\n    for i in range(LENGTH):\n        assert a[i] == i * i + 1\n    with pytest.raises(IndexError) as e:\n        a[LENGTH+100] = 500\n    assert ('(expected %d < %d)' % (LENGTH+100, LENGTH)) in str(e.value)\n    pytest.raises(TypeError, int, a)\n\ndef test_array_of_unknown_length_instance():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    pytest.raises(TypeError, newp, p1, None)\n    pytest.raises(ValueError, newp, p1, -42)\n    a = newp(p1, 42)\n    assert len(a) == 42\n    for i in range(42):\n        a[i] -= i\n    for i in range(42):\n        assert a[i] == -i\n    with pytest.raises(IndexError):\n        a[42]\n    with pytest.raises(IndexError):\n        a[-1]\n    with pytest.raises(IndexError):\n        a[42] = 123\n    with pytest.raises(IndexError):\n        a[-1] = 456\n\ndef test_array_of_unknown_length_instance_with_initializer():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    a = newp(p1, list(range(42)))\n    assert len(a) == 42\n    a = newp(p1, tuple(range(142)))\n    assert len(a) == 142\n\ndef test_array_initializer():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), None)\n    a = newp(p1, list(range(100, 142)))\n    for i in range(42):\n        assert a[i] == 100 + i\n    #\n    p2 = new_array_type(new_pointer_type(p), 43)\n    a = newp(p2, tuple(range(100, 142)))\n    for i in range(42):\n        assert a[i] == 100 + i\n    assert a[42] == 0      # extra uninitialized item\n\ndef test_array_add():\n    p = new_primitive_type(\"int\")\n    p1 = new_array_type(new_pointer_type(p), 5)    # int[5]\n    p2 = new_array_type(new_pointer_type(p1), 3)   # int[3][5]\n    a = newp(p2, [list(range(n, n+5)) for n in [100, 200, 300]])\n    assert repr(a) == \"<cdata 'int[3][5]' owning %d bytes>\" % (\n        3*5*size_of_int(),)\n    assert repr(a + 0).startswith(\"<cdata 'int(*)[5]' 0x\")\n    assert 0 + a == a + 0 != 1 + a == a + 1\n    assert repr(a[0]).startswith(\"<cdata 'int[5]' 0x\")\n    assert repr((a + 0)[0]).startswith(\"<cdata 'int[5]' 0x\")\n    assert repr(a[0] + 0).startswith(\"<cdata 'int *' 0x\")\n    assert type(a[0][0]) is int\n    assert type((a[0] + 0)[0]) is int\n\ndef test_array_sub():\n    BInt = new_primitive_type(\"int\")\n    BArray = new_array_type(new_pointer_type(BInt), 5)   # int[5]\n    a = newp(BArray, None)\n    p = a + 1\n    assert p - a == 1\n    assert p - (a+0) == 1\n    assert a == (p - 1)\n    BPtr = new_pointer_type(new_primitive_type(\"short\"))\n    q = newp(BPtr, None)\n    with pytest.raises(TypeError):\n        p - q\n    with pytest.raises(TypeError):\n        q - p\n    with pytest.raises(TypeError):\n        a - q\n    with pytest.raises(TypeError) as e:\n        q - a\n    assert str(e.value) == \"cannot subtract cdata 'short *' and cdata 'int *'\"\n\ndef test_ptr_sub_unaligned():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    a = cast(BIntPtr, 1240)\n    for bi in range(1430, 1438):\n        b = cast(BIntPtr, bi)\n        if ((bi - 1240) % size_of_int()) == 0:\n            assert b - a == (bi - 1240) // size_of_int()\n            assert a - b == (1240 - bi) // size_of_int()\n        else:\n            with pytest.raises(ValueError):\n                b - a\n            with pytest.raises(ValueError):\n                a - b\n\ndef test_cast_primitive_from_cdata():\n    p = new_primitive_type(\"int\")\n    n = cast(p, cast(p, -42))\n    assert int(n) == -42\n    #\n    p = new_primitive_type(\"unsigned int\")\n    n = cast(p, cast(p, 42))\n    assert int(n) == 42\n    #\n    p = new_primitive_type(\"long long\")\n    n = cast(p, cast(p, -(1<<60)))\n    assert int(n) == -(1<<60)\n    #\n    p = new_primitive_type(\"unsigned long long\")\n    n = cast(p, cast(p, 1<<63))\n    assert int(n) == 1<<63\n    #\n    p = new_primitive_type(\"float\")\n    n = cast(p, cast(p, 42.5))\n    assert float(n) == 42.5\n    #\n    p = new_primitive_type(\"char\")\n    n = cast(p, cast(p, \"A\"))\n    assert int(n) == ord(\"A\")\n\ndef test_new_primitive_from_cdata():\n    p = new_primitive_type(\"int\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, -42))\n    assert n[0] == -42\n    #\n    p = new_primitive_type(\"unsigned int\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, 42))\n    assert n[0] == 42\n    #\n    p = new_primitive_type(\"float\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, 42.5))\n    assert n[0] == 42.5\n    #\n    p = new_primitive_type(\"char\")\n    p1 = new_pointer_type(p)\n    n = newp(p1, cast(p, \"A\"))\n    assert n[0] == b\"A\"\n\ndef test_cast_between_pointers():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntA = new_array_type(BIntP, None)\n    a = newp(BIntA, [40, 41, 42, 43, 44])\n    BShortP = new_pointer_type(new_primitive_type(\"short\"))\n    b = cast(BShortP, a)\n    c = cast(BIntP, b)\n    assert c[3] == 43\n    BLongLong = new_primitive_type(\"long long\")\n    d = cast(BLongLong, c)\n    e = cast(BIntP, d)\n    assert e[3] == 43\n    f = cast(BIntP, int(d))\n    assert f[3] == 43\n    #\n    b = cast(BShortP, 0)\n    assert not b\n    c = cast(BIntP, b)\n    assert not c\n    assert int(cast(BLongLong, c)) == 0\n\ndef test_alignof():\n    BInt = new_primitive_type(\"int\")\n    assert alignof(BInt) == sizeof(BInt)\n    BPtr = new_pointer_type(BInt)\n    assert alignof(BPtr) == sizeof(BPtr)\n    BArray = new_array_type(BPtr, None)\n    assert alignof(BArray) == alignof(BInt)\n\ndef test_new_struct_type():\n    BStruct = new_struct_type(\"foo\")\n    assert repr(BStruct) == \"<ctype 'foo'>\"\n    BStruct = new_struct_type(\"struct foo\")\n    assert repr(BStruct) == \"<ctype 'struct foo'>\"\n    BPtr = new_pointer_type(BStruct)\n    assert repr(BPtr) == \"<ctype 'struct foo *'>\"\n    pytest.raises(ValueError, sizeof, BStruct)\n    pytest.raises(ValueError, alignof, BStruct)\n\ndef test_new_union_type():\n    BUnion = new_union_type(\"union foo\")\n    assert repr(BUnion) == \"<ctype 'union foo'>\"\n    BPtr = new_pointer_type(BUnion)\n    assert repr(BPtr) == \"<ctype 'union foo *'>\"\n\ndef test_complete_struct():\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    assert BStruct.kind == \"struct\"\n    assert BStruct.cname == \"struct foo\"\n    assert BStruct.fields is None\n    check_dir(BStruct, ['cname', 'kind', 'fields'])\n    #\n    complete_struct_or_union(BStruct, [('a1', BLong, -1),\n                                       ('a2', BChar, -1),\n                                       ('a3', BShort, -1)])\n    d = BStruct.fields\n    assert len(d) == 3\n    assert d[0][0] == 'a1'\n    assert d[0][1].type is BLong\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'a2'\n    assert d[1][1].type is BChar\n    assert d[1][1].offset == sizeof(BLong)\n    assert d[1][1].bitshift == -1\n    assert d[1][1].bitsize == -1\n    assert d[2][0] == 'a3'\n    assert d[2][1].type is BShort\n    assert d[2][1].offset == sizeof(BLong) + sizeof(BShort)\n    assert d[2][1].bitshift == -1\n    assert d[2][1].bitsize == -1\n    assert sizeof(BStruct) == 2 * sizeof(BLong)\n    assert alignof(BStruct) == alignof(BLong)\n\ndef test_complete_union():\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BUnion = new_union_type(\"union foo\")\n    assert BUnion.kind == \"union\"\n    assert BUnion.cname == \"union foo\"\n    assert BUnion.fields is None\n    complete_struct_or_union(BUnion, [('a1', BLong, -1),\n                                      ('a2', BChar, -1)])\n    d = BUnion.fields\n    assert len(d) == 2\n    assert d[0][0] == 'a1'\n    assert d[0][1].type is BLong\n    assert d[0][1].offset == 0\n    assert d[1][0] == 'a2'\n    assert d[1][1].type is BChar\n    assert d[1][1].offset == 0\n    assert sizeof(BUnion) == sizeof(BLong)\n    assert alignof(BUnion) == alignof(BLong)\n\ndef test_struct_instance():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    p = cast(BStructPtr, 42)\n    with pytest.raises(AttributeError) as e:\n        p.a1    # opaque\n    assert str(e.value) == (\"cdata 'struct foo *' points to an opaque type: \"\n                            \"cannot read fields\")\n    with pytest.raises(AttributeError) as e:\n        p.a1 = 10    # opaque\n    assert str(e.value) == (\"cdata 'struct foo *' points to an opaque type: \"\n                            \"cannot write fields\")\n\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    p = newp(BStructPtr, None)\n    s = p[0]\n    assert s.a1 == 0\n    s.a2 = 123\n    assert s.a1 == 0\n    assert s.a2 == 123\n    with pytest.raises(OverflowError):\n        s.a1 = sys.maxsize+1\n    assert s.a1 == 0\n    with pytest.raises(AttributeError) as e:\n        p.foobar\n    assert str(e.value) == \"cdata 'struct foo *' has no field 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        p.foobar = 42\n    assert str(e.value) == \"cdata 'struct foo *' has no field 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        s.foobar\n    assert str(e.value) == \"cdata 'struct foo' has no field 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        s.foobar = 42\n    assert str(e.value) == \"cdata 'struct foo' has no field 'foobar'\"\n    j = cast(BInt, 42)\n    with pytest.raises(AttributeError) as e:\n        j.foobar\n    assert str(e.value) == \"cdata 'int' has no attribute 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        j.foobar = 42\n    assert str(e.value) == \"cdata 'int' has no attribute 'foobar'\"\n    j = cast(new_pointer_type(BInt), 42)\n    with pytest.raises(AttributeError) as e:\n        j.foobar\n    assert str(e.value) == \"cdata 'int *' has no attribute 'foobar'\"\n    with pytest.raises(AttributeError) as e:\n        j.foobar = 42\n    assert str(e.value) == \"cdata 'int *' has no attribute 'foobar'\"\n    pp = newp(new_pointer_type(BStructPtr), p)\n    with pytest.raises(AttributeError) as e:\n        pp.a1\n    assert str(e.value) == \"cdata 'struct foo * *' has no attribute 'a1'\"\n    with pytest.raises(AttributeError) as e:\n        pp.a1 = 42\n    assert str(e.value) == \"cdata 'struct foo * *' has no attribute 'a1'\"\n\ndef test_union_instance():\n    BInt = new_primitive_type(\"int\")\n    BUInt = new_primitive_type(\"unsigned int\")\n    BUnion = new_union_type(\"union bar\")\n    complete_struct_or_union(BUnion, [('a1', BInt, -1), ('a2', BUInt, -1)])\n    p = newp(new_pointer_type(BUnion), [-42])\n    bigval = -42 + (1 << (8*size_of_int()))\n    assert p.a1 == -42\n    assert p.a2 == bigval\n    p = newp(new_pointer_type(BUnion), {'a2': bigval})\n    assert p.a1 == -42\n    assert p.a2 == bigval\n    pytest.raises(OverflowError, newp, new_pointer_type(BUnion),\n                   {'a1': bigval})\n    p = newp(new_pointer_type(BUnion), [])\n    assert p.a1 == p.a2 == 0\n\ndef test_struct_pointer():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    p = newp(BStructPtr, None)\n    assert p.a1 == 0      # read/write via the pointer (C equivalent: '->')\n    p.a2 = 123\n    assert p.a1 == 0\n    assert p.a2 == 123\n\ndef test_struct_init_list():\n    BVoidP = new_pointer_type(new_void_type())\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1),\n                                       ('a3', BInt, -1),\n                                       ('p4', BIntPtr, -1)])\n    s = newp(BStructPtr, [123, 456])\n    assert s.a1 == 123\n    assert s.a2 == 456\n    assert s.a3 == 0\n    assert s.p4 == cast(BVoidP, 0)\n    assert s.p4 != 0\n    #\n    s = newp(BStructPtr, {'a2': 41122, 'a3': -123})\n    assert s.a1 == 0\n    assert s.a2 == 41122\n    assert s.a3 == -123\n    assert s.p4 == cast(BVoidP, 0)\n    #\n    pytest.raises(KeyError, newp, BStructPtr, {'foobar': 0})\n    #\n    p = newp(BIntPtr, 14141)\n    s = newp(BStructPtr, [12, 34, 56, p])\n    assert s.p4 == p\n    assert s.p4\n    #\n    s = newp(BStructPtr, [12, 34, 56, cast(BVoidP, 0)])\n    assert s.p4 == cast(BVoidP, 0)\n    assert not s.p4\n    #\n    pytest.raises(TypeError, newp, BStructPtr, [12, 34, 56, None])\n\ndef test_array_in_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BArrayInt5 = new_array_type(new_pointer_type(BInt), 5)\n    complete_struct_or_union(BStruct, [('a1', BArrayInt5, -1)])\n    s = newp(new_pointer_type(BStruct), [[20, 24, 27, 29, 30]])\n    assert s.a1[2] == 27\n    assert repr(s.a1).startswith(\"<cdata 'int[5]' 0x\")\n\ndef test_offsetof():\n    def offsetof(BType, fieldname):\n        return typeoffsetof(BType, fieldname)[1]\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    pytest.raises(TypeError, offsetof, BInt, \"abc\")\n    pytest.raises(TypeError, offsetof, BStruct, \"abc\")\n    complete_struct_or_union(BStruct, [('abc', BInt, -1), ('def', BInt, -1)])\n    assert offsetof(BStruct, 'abc') == 0\n    assert offsetof(BStruct, 'def') == size_of_int()\n    pytest.raises(KeyError, offsetof, BStruct, \"ghi\")\n    assert offsetof(new_pointer_type(BStruct), \"def\") == size_of_int()\n\ndef test_function_type():\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    assert repr(BFunc) == \"<ctype 'int(*)(int, int)'>\"\n    BFunc2 = new_function_type((), BFunc, False)\n    assert repr(BFunc2) == \"<ctype 'int(*(*)())(int, int)'>\"\n\ndef test_inspect_function_type():\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    assert BFunc.kind == \"function\"\n    assert BFunc.cname == \"int(*)(int, int)\"\n    assert BFunc.args == (BInt, BInt)\n    assert BFunc.result is BInt\n    assert BFunc.ellipsis is False\n    assert BFunc.abi == FFI_DEFAULT_ABI\n\ndef test_function_type_taking_struct():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc = new_function_type((BStruct,), BShort, False)\n    assert repr(BFunc) == \"<ctype 'short(*)(struct foo)'>\"\n\ndef test_function_void_result():\n    BVoid = new_void_type()\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BVoid, False)\n    assert repr(BFunc) == \"<ctype 'void(*)(int, int)'>\"\n\ndef test_function_void_arg():\n    BVoid = new_void_type()\n    BInt = new_primitive_type(\"int\")\n    pytest.raises(TypeError, new_function_type, (BVoid,), BInt, False)\n\ndef test_call_function_0():\n    BSignedChar = new_primitive_type(\"signed char\")\n    BFunc0 = new_function_type((BSignedChar, BSignedChar), BSignedChar, False)\n    f = cast(BFunc0, _testfunc(0))\n    assert f(40, 2) == 42\n    assert f(-100, -100) == -200 + 256\n    pytest.raises(OverflowError, f, 128, 0)\n    pytest.raises(OverflowError, f, 0, 128)\n\ndef test_call_function_0_pretend_bool_result():\n    BSignedChar = new_primitive_type(\"signed char\")\n    BBool = new_primitive_type(\"_Bool\")\n    BFunc0 = new_function_type((BSignedChar, BSignedChar), BBool, False)\n    f = cast(BFunc0, _testfunc(0))\n    assert f(40, -39) is True\n    assert f(40, -40) is False\n    pytest.raises(ValueError, f, 40, 2)\n\ndef test_call_function_1():\n    BInt = new_primitive_type(\"int\")\n    BLong = new_primitive_type(\"long\")\n    BFunc1 = new_function_type((BInt, BLong), BLong, False)\n    f = cast(BFunc1, _testfunc(1))\n    assert f(40, 2) == 42\n    assert f(-100, -100) == -200\n    int_max = (1 << (8*size_of_int()-1)) - 1\n    long_max = (1 << (8*size_of_long()-1)) - 1\n    if int_max == long_max:\n        assert f(int_max, 1) == - int_max - 1\n    else:\n        assert f(int_max, 1) == int_max + 1\n\ndef test_call_function_2():\n    BLongLong = new_primitive_type(\"long long\")\n    BFunc2 = new_function_type((BLongLong, BLongLong), BLongLong, False)\n    f = cast(BFunc2, _testfunc(2))\n    longlong_max = (1 << (8*sizeof(BLongLong)-1)) - 1\n    assert f(longlong_max - 42, 42) == longlong_max\n    assert f(43, longlong_max - 42) == - longlong_max - 1\n\ndef test_call_function_3():\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"double\")\n    BFunc3 = new_function_type((BFloat, BDouble), BDouble, False)\n    f = cast(BFunc3, _testfunc(3))\n    assert f(1.25, 5.1) == 1.25 + 5.1     # exact\n    res = f(1.3, 5.1)\n    assert res != 6.4 and abs(res - 6.4) < 1E-5    # inexact\n\ndef test_call_function_4():\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"double\")\n    BFunc4 = new_function_type((BFloat, BDouble), BFloat, False)\n    f = cast(BFunc4, _testfunc(4))\n    res = f(1.25, 5.1)\n    assert res != 6.35 and abs(res - 6.35) < 1E-5    # inexact\n\ndef test_call_function_5():\n    BVoid = new_void_type()\n    BFunc5 = new_function_type((), BVoid, False)\n    f = cast(BFunc5, _testfunc(5))\n    f()   # did not crash\n\ndef test_call_function_6():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BFunc6 = new_function_type((BIntPtr,), BIntPtr, False)\n    f = cast(BFunc6, _testfunc(6))\n    x = newp(BIntPtr, 42)\n    res = f(x)\n    assert typeof(res) is BIntPtr\n    assert res[0] == 42 - 1000\n    #\n    BIntArray = new_array_type(BIntPtr, None)\n    BFunc6bis = new_function_type((BIntArray,), BIntPtr, False)\n    f = cast(BFunc6bis, _testfunc(6))\n    #\n    res = f([142])\n    assert typeof(res) is BIntPtr\n    assert res[0] == 142 - 1000\n    #\n    res = f((143,))\n    assert typeof(res) is BIntPtr\n    assert res[0] == 143 - 1000\n    #\n    x = newp(BIntArray, [242])\n    res = f(x)\n    assert typeof(res) is BIntPtr\n    assert res[0] == 242 - 1000\n    #\n    pytest.raises(TypeError, f, 123456)\n    pytest.raises(TypeError, f, \"foo\")\n    pytest.raises(TypeError, f, u+\"bar\")\n\ndef test_call_function_7():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc7 = new_function_type((BStruct,), BShort, False)\n    f = cast(BFunc7, _testfunc(7))\n    res = f({'a1': b'A', 'a2': -4042})\n    assert res == -4042 + ord(b'A')\n    #\n    x = newp(BStructPtr, {'a1': b'A', 'a2': -4042})\n    res = f(x[0])\n    assert res == -4042 + ord(b'A')\n\ndef test_call_function_20():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc20 = new_function_type((BStructPtr,), BShort, False)\n    f = cast(BFunc20, _testfunc(20))\n    x = newp(BStructPtr, {'a1': b'A', 'a2': -4042})\n    # can't pass a 'struct foo'\n    pytest.raises(TypeError, f, x[0])\n\ndef test_call_function_21():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a', BInt, -1),\n                                       ('b', BInt, -1),\n                                       ('c', BInt, -1),\n                                       ('d', BInt, -1),\n                                       ('e', BInt, -1),\n                                       ('f', BInt, -1),\n                                       ('g', BInt, -1),\n                                       ('h', BInt, -1),\n                                       ('i', BInt, -1),\n                                       ('j', BInt, -1)])\n    BFunc21 = new_function_type((BStruct,), BInt, False)\n    f = cast(BFunc21, _testfunc(21))\n    res = f(list(range(13, 3, -1)))\n    lst = [(n << i) for (i, n) in enumerate(range(13, 3, -1))]\n    assert res == sum(lst)\n\ndef test_call_function_22():\n    BInt = new_primitive_type(\"int\")\n    BArray10 = new_array_type(new_pointer_type(BInt), 10)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BArray10, -1)])\n    BFunc22 = new_function_type((BStruct, BStruct), BStruct, False)\n    f = cast(BFunc22, _testfunc(22))\n    p1 = newp(BStructP, {'a': list(range(100, 110))})\n    p2 = newp(BStructP, {'a': list(range(1000, 1100, 10))})\n    res = f(p1[0], p2[0])\n    for i in range(10):\n        assert res.a[i] == p1.a[i] - p2.a[i]\n\ndef test_call_function_23():\n    BVoid = new_void_type()          # declaring the function as int(void*)\n    BVoidP = new_pointer_type(BVoid)\n    BInt = new_primitive_type(\"int\")\n    BFunc23 = new_function_type((BVoidP,), BInt, False)\n    f = cast(BFunc23, _testfunc(23))\n    res = f(b\"foo\")\n    assert res == 1000 * ord(b'f')\n    res = f(cast(BVoidP, 0))        # NULL\n    assert res == -42\n    pytest.raises(TypeError, f, None)\n    pytest.raises(TypeError, f, 0)\n    pytest.raises(TypeError, f, 0.0)\n\ndef test_call_function_23_bis():\n    # declaring the function as int(unsigned char*)\n    BUChar = new_primitive_type(\"unsigned char\")\n    BUCharP = new_pointer_type(BUChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc23 = new_function_type((BUCharP,), BInt, False)\n    f = cast(BFunc23, _testfunc(23))\n    res = f(b\"foo\")\n    assert res == 1000 * ord(b'f')\n\ndef test_call_function_23_bool_array():\n    # declaring the function as int(_Bool*)\n    BBool = new_primitive_type(\"_Bool\")\n    BBoolP = new_pointer_type(BBool)\n    BInt = new_primitive_type(\"int\")\n    BFunc23 = new_function_type((BBoolP,), BInt, False)\n    f = cast(BFunc23, _testfunc(23))\n    res = f(b\"\\x01\\x01\")\n    assert res == 1000\n    pytest.raises(ValueError, f, b\"\\x02\\x02\")\n\ndef test_cannot_pass_struct_with_array_of_length_0():\n    BInt = new_primitive_type(\"int\")\n    BArray0 = new_array_type(new_pointer_type(BInt), 0)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BArray0)])\n    BFunc = new_function_type((BStruct,), BInt, False)\n    pytest.raises(NotImplementedError, cast(BFunc, 123), cast(BStructP, 123))\n    BFunc2 = new_function_type((BInt,), BStruct, False)\n    pytest.raises(NotImplementedError, cast(BFunc2, 123), 123)\n\ndef test_call_function_9():\n    BInt = new_primitive_type(\"int\")\n    BFunc9 = new_function_type((BInt,), BInt, True)    # vararg\n    f = cast(BFunc9, _testfunc(9))\n    assert f(0) == 0\n    assert f(1, cast(BInt, 42)) == 42\n    assert f(2, cast(BInt, 40), cast(BInt, 2)) == 42\n    pytest.raises(TypeError, f, 1, 42)\n    pytest.raises(TypeError, f, 2, None)\n    # promotion of chars and shorts to ints\n    BSChar = new_primitive_type(\"signed char\")\n    BUChar = new_primitive_type(\"unsigned char\")\n    BSShort = new_primitive_type(\"short\")\n    assert f(3, cast(BSChar, -3), cast(BUChar, 200), cast(BSShort, -5)) == 192\n\ndef test_call_function_24():\n    BFloat = new_primitive_type(\"float\")\n    BFloatComplex = new_primitive_type(\"float _Complex\")\n    BFunc3 = new_function_type((BFloat, BFloat), BFloatComplex, False)\n    if 0:   # libffi returning nonsense silently, so logic disabled for now\n        f = cast(BFunc3, _testfunc(24))\n        result = f(1.25, 5.1)\n        assert type(result) == complex\n        assert result.real == 1.25   # exact\n        assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-5) # inexact\n    else:\n        f = cast(BFunc3, _testfunc(9))\n        pytest.raises(NotImplementedError, f, 12.3, 34.5)\n\ndef test_call_function_25():\n    BDouble = new_primitive_type(\"double\")\n    BDoubleComplex = new_primitive_type(\"double _Complex\")\n    BFunc3 = new_function_type((BDouble, BDouble), BDoubleComplex, False)\n    if 0:   # libffi returning nonsense silently, so logic disabled for now\n        f = cast(BFunc3, _testfunc(25))\n        result = f(1.25, 5.1)\n        assert type(result) == complex\n        assert result.real == 1.25   # exact\n        assert (result.imag != 2*5.1) and (abs(result.imag - 2*5.1) < 1e-10) # inexact\n    else:\n        f = cast(BFunc3, _testfunc(9))\n        pytest.raises(NotImplementedError, f, 12.3, 34.5)\n\ndef test_cannot_call_with_a_autocompleted_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BDouble = new_primitive_type(\"double\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('c', BDouble, -1, 8),\n                                       ('a', BSChar, -1, 2),\n                                       ('b', BSChar, -1, 0)])\n    BFunc = new_function_type((BStruct,), BDouble)   # internally not callable\n    dummy_func = cast(BFunc, 42)\n    e = pytest.raises(NotImplementedError, dummy_func, \"?\")\n    msg = (\"ctype 'struct foo' not supported as argument.  It is a struct \"\n           'declared with \"...;\", but the C calling convention may depend '\n           \"on the missing fields; or, it contains anonymous struct/unions.  \"\n           \"Such structs are only supported as argument if the function is \"\n           \"'API mode' and non-variadic (i.e. declared inside ffibuilder.\"\n           \"cdef()+ffibuilder.set_source() and not taking a final '...' \"\n           \"argument)\")\n    assert str(e.value) == msg\n\ndef test_new_charp():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    x = newp(BCharA, 42)\n    assert len(x) == 42\n    x = newp(BCharA, b\"foobar\")\n    assert len(x) == 7\n\ndef test_load_and_call_function():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BLong = new_primitive_type(\"long\")\n    BFunc = new_function_type((BCharP,), BLong, False)\n    ll = find_and_load_library('c')\n    strlen = ll.load_function(BFunc, \"strlen\")\n    input = newp(new_array_type(BCharP, None), b\"foobar\")\n    assert strlen(input) == 6\n    #\n    assert strlen(b\"foobarbaz\") == 9\n    #\n    BVoidP = new_pointer_type(new_void_type())\n    strlenaddr = ll.load_function(BVoidP, \"strlen\")\n    assert strlenaddr == cast(BVoidP, strlen)\n\ndef test_read_variable():\n    ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard\n    ## https://bugs.pypy.org/issue1643\n    if not sys.platform.startswith(\"linux\"):\n        pytest.skip(\"untested\")\n    BVoidP = new_pointer_type(new_void_type())\n    ll = find_and_load_library('c')\n    stderr = ll.read_variable(BVoidP, \"stderr\")\n    assert stderr == cast(BVoidP, _testfunc(8))\n    #\n    ll.close_lib()\n    pytest.raises(ValueError, ll.read_variable, BVoidP, \"stderr\")\n\ndef test_read_variable_as_unknown_length_array():\n    ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard\n    ## https://bugs.pypy.org/issue1643\n    if not sys.platform.startswith(\"linux\"):\n        pytest.skip(\"untested\")\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BArray = new_array_type(BCharP, None)\n    ll = find_and_load_library('c')\n    stderr = ll.read_variable(BArray, \"stderr\")\n    assert repr(stderr).startswith(\"<cdata 'char *' 0x\")\n    # ^^ and not 'char[]', which is basically not allowed and would crash\n\ndef test_write_variable():\n    ## FIXME: this test assumes glibc specific behavior, it's not compliant with C standard\n    ## https://bugs.pypy.org/issue1643\n    if not sys.platform.startswith(\"linux\") or is_musl:\n        pytest.skip(\"untested\")\n    BVoidP = new_pointer_type(new_void_type())\n    ll = find_and_load_library('c')\n    stderr = ll.read_variable(BVoidP, \"stderr\")\n    ll.write_variable(BVoidP, \"stderr\", cast(BVoidP, 0))\n    assert ll.read_variable(BVoidP, \"stderr\") is not None\n    assert not ll.read_variable(BVoidP, \"stderr\")\n    ll.write_variable(BVoidP, \"stderr\", stderr)\n    assert ll.read_variable(BVoidP, \"stderr\") == stderr\n    #\n    ll.close_lib()\n    pytest.raises(ValueError, ll.write_variable, BVoidP, \"stderr\", stderr)\n\n\ndef test_callback():\n    BInt = new_primitive_type(\"int\")\n    def make_callback():\n        def cb(n):\n            return n + 1\n        BFunc = new_function_type((BInt,), BInt, False)\n        return callback(BFunc, cb, 42)    # 'cb' and 'BFunc' go out of scope\n    f = make_callback()\n    assert f(-142) == -141\n    assert repr(f).startswith(\n        \"<cdata 'int(*)(int)' calling <function \")\n    assert \"cb at 0x\" in repr(f)\n    e = pytest.raises(TypeError, f)\n    assert str(e.value) == \"'int(*)(int)' expects 1 arguments, got 0\"\n\n\ndef test_callback_exception():\n    def check_value(x):\n        if x == 10000:\n            raise ValueError(42)\n    def Zcb1(x):\n        check_value(x)\n        return x * 3\n    BShort = new_primitive_type(\"short\")\n    BFunc = new_function_type((BShort,), BShort, False)\n\n    f = callback(BFunc, Zcb1, -42)\n    seen = []\n    oops_result = None\n    def oops(*args):\n        seen.append(args)\n        return oops_result\n    ff = callback(BFunc, Zcb1, -42, oops)\n    with _assert_unraisable(None):\n        assert f(100) == 300\n    with _assert_unraisable(ValueError, '42', ['in Zcb1', 'in check_value']):\n        assert f(10000) == -42\n\n    bigvalue = 20000\n    with _assert_unraisable(OverflowError, \"integer 60000 does not fit 'short'\", ['callback', 'Zcb1']):\n        assert f(bigvalue) == -42\n    assert len(seen) == 0\n\n    with _assert_unraisable(None):\n        assert ff(bigvalue) == -42\n    assert len(seen) == 1\n    exc, val, tb = seen[0]\n    assert exc is OverflowError\n    assert str(val) == \"integer 60000 does not fit 'short'\"\n\n    del seen[:]\n    oops_result = 81\n    with _assert_unraisable(None):\n        assert ff(bigvalue) == 81\n\n    assert len(seen) == 1\n    exc, val, tb = seen[0]\n    assert exc is OverflowError\n    assert str(val) == \"integer 60000 does not fit 'short'\"\n\n    del seen[:]\n    oops_result = \"xy\"     # not None and not an int!\n\n    with _assert_unraisable(TypeError, \"an integer is required\", [\"integer 60000 does not fit 'short'\"]):\n        assert ff(bigvalue) == -42\n\n    seen = \"not a list\"    # this makes the oops() function crash\n    oops_result = None\n    with _assert_unraisable(AttributeError, \"'str' object has no attribute 'append\", ['Zcb1', 'ff', 'oops']):\n        assert ff(bigvalue) == -42\n\n\ndef test_callback_return_type():\n    for rettype in [\"signed char\", \"short\", \"int\", \"long\", \"long long\",\n                    \"unsigned char\", \"unsigned short\", \"unsigned int\",\n                    \"unsigned long\", \"unsigned long long\"]:\n        BRet = new_primitive_type(rettype)\n        def cb(n):\n            return n + 1\n        BFunc = new_function_type((BRet,), BRet)\n        f = callback(BFunc, cb, 42)\n        assert f(41) == 42\n        if rettype.startswith(\"unsigned \"):\n            min = 0\n            max = (1 << (8*sizeof(BRet))) - 1\n        else:\n            min = -(1 << (8*sizeof(BRet)-1))\n            max = (1 << (8*sizeof(BRet)-1)) - 1\n        assert f(min) == min + 1\n        assert f(max - 1) == max\n        assert f(max) == 42\n\ndef test_a_lot_of_callbacks():\n    BIGNUM = 10000\n    if 'PY_DOT_PY' in globals(): BIGNUM = 100   # tests on py.py\n    #\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt,), BInt, False)\n    def make_callback(m):\n        def cb(n):\n            return n + m\n        return callback(BFunc, cb, 42)    # 'cb' goes out of scope\n    #\n    flist = [make_callback(i) for i in range(BIGNUM)]\n    for i, f in enumerate(flist):\n        assert f(-142) == -142 + i\n\ndef test_callback_receiving_tiny_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BSChar, -1)])\n    def cb(s):\n        return s.a + 10 * s.b\n    BFunc = new_function_type((BStruct,), BInt)\n    f = callback(BFunc, cb)\n    p = newp(BStructPtr, [-2, -4])\n    n = f(p[0])\n    assert n == -42\n\ndef test_callback_returning_tiny_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BSChar, -1)])\n    def cb(n):\n        return newp(BStructPtr, [-n, -3*n])[0]\n    BFunc = new_function_type((BInt,), BStruct)\n    f = callback(BFunc, cb)\n    s = f(10)\n    assert typeof(s) is BStruct\n    assert repr(s) == \"<cdata 'struct foo' owning 2 bytes>\"\n    assert s.a == -10\n    assert s.b == -30\n\ndef test_callback_receiving_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BDouble = new_primitive_type(\"double\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BDouble, -1)])\n    def cb(s):\n        return s.a + int(s.b)\n    BFunc = new_function_type((BStruct,), BInt)\n    f = callback(BFunc, cb)\n    p = newp(BStructPtr, [-2, 44.444])\n    n = f(p[0])\n    assert n == 42\n\ndef test_callback_returning_struct():\n    BSChar = new_primitive_type(\"signed char\")\n    BInt = new_primitive_type(\"int\")\n    BDouble = new_primitive_type(\"double\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BSChar, -1),\n                                       ('b', BDouble, -1)])\n    def cb(n):\n        return newp(BStructPtr, [-n, 1E-42])[0]\n    BFunc = new_function_type((BInt,), BStruct)\n    f = callback(BFunc, cb)\n    s = f(10)\n    assert typeof(s) is BStruct\n    assert repr(s) in [\"<cdata 'struct foo' owning 12 bytes>\",\n                       \"<cdata 'struct foo' owning 16 bytes>\"]\n    assert s.a == -10\n    assert s.b == 1E-42\n\ndef test_callback_receiving_big_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BInt, -1),\n                                       ('b', BInt, -1),\n                                       ('c', BInt, -1),\n                                       ('d', BInt, -1),\n                                       ('e', BInt, -1),\n                                       ('f', BInt, -1),\n                                       ('g', BInt, -1),\n                                       ('h', BInt, -1),\n                                       ('i', BInt, -1),\n                                       ('j', BInt, -1)])\n    def cb(s):\n        for i, name in enumerate(\"abcdefghij\"):\n            assert getattr(s, name) == 13 - i\n        return 42\n    BFunc = new_function_type((BStruct,), BInt)\n    f = callback(BFunc, cb)\n    p = newp(BStructPtr, list(range(13, 3, -1)))\n    n = f(p[0])\n    assert n == 42\n\ndef test_callback_returning_big_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a', BInt, -1),\n                                       ('b', BInt, -1),\n                                       ('c', BInt, -1),\n                                       ('d', BInt, -1),\n                                       ('e', BInt, -1),\n                                       ('f', BInt, -1),\n                                       ('g', BInt, -1),\n                                       ('h', BInt, -1),\n                                       ('i', BInt, -1),\n                                       ('j', BInt, -1)])\n    def cb():\n        return newp(BStructPtr, list(range(13, 3, -1)))[0]\n    BFunc = new_function_type((), BStruct)\n    f = callback(BFunc, cb)\n    s = f()\n    assert typeof(s) is BStruct\n    assert repr(s) in [\"<cdata 'struct foo' owning 40 bytes>\",\n                       \"<cdata 'struct foo' owning 80 bytes>\"]\n    for i, name in enumerate(\"abcdefghij\"):\n        assert getattr(s, name) == 13 - i\n\ndef test_callback_returning_void():\n    BVoid = new_void_type()\n    BFunc = new_function_type((), BVoid, False)\n    def cb():\n        seen.append(42)\n    f = callback(BFunc, cb)\n    seen = []\n    f()\n    assert seen == [42]\n    pytest.raises(TypeError, callback, BFunc, cb, -42)\n\ndef test_enum_type():\n    BUInt = new_primitive_type(\"unsigned int\")\n    BEnum = new_enum_type(\"foo\", (), (), BUInt)\n    assert repr(BEnum) == \"<ctype 'foo'>\"\n    assert BEnum.kind == \"enum\"\n    assert BEnum.cname == \"foo\"\n    assert BEnum.elements == {}\n    #\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    assert BEnum.kind == \"enum\"\n    assert BEnum.cname == \"enum foo\"\n    assert BEnum.elements == {-20: 'ab', 0: 'def', 1: 'c'}\n    # 'elements' is not the real dict, but merely a copy\n    BEnum.elements[2] = '??'\n    assert BEnum.elements == {-20: 'ab', 0: 'def', 1: 'c'}\n    #\n    BEnum = new_enum_type(\"enum bar\", ('ab', 'cd'), (5, 5), BUInt)\n    assert BEnum.elements == {5: 'ab'}\n    assert BEnum.relements == {'ab': 5, 'cd': 5}\n\ndef test_cast_to_enum():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    assert sizeof(BEnum) == sizeof(BInt)\n    e = cast(BEnum, 0)\n    assert repr(e) == \"<cdata 'enum foo' 0: def>\"\n    assert repr(cast(BEnum, -42)) == \"<cdata 'enum foo' -42>\"\n    assert repr(cast(BEnum, -20)) == \"<cdata 'enum foo' -20: ab>\"\n    assert string(e) == 'def'\n    assert string(cast(BEnum, -20)) == 'ab'\n    assert int(cast(BEnum, 1)) == 1\n    assert int(cast(BEnum, 0)) == 0\n    assert int(cast(BEnum, -242 + 2**128)) == -242\n    assert string(cast(BEnum, -242 + 2**128)) == '-242'\n    #\n    BUInt = new_primitive_type(\"unsigned int\")\n    BEnum = new_enum_type(\"enum bar\", ('def', 'c', 'ab'), (0, 1, 20), BUInt)\n    e = cast(BEnum, -1)\n    assert repr(e) == \"<cdata 'enum bar' 4294967295>\"     # unsigned int\n    #\n    BLong = new_primitive_type(\"long\")\n    BEnum = new_enum_type(\"enum baz\", (), (), BLong)\n    assert sizeof(BEnum) == sizeof(BLong)\n    e = cast(BEnum, -1)\n    assert repr(e) == \"<cdata 'enum baz' -1>\"\n\ndef test_enum_with_non_injective_mapping():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('ab', 'cd'), (7, 7), BInt)\n    e = cast(BEnum, 7)\n    assert repr(e) == \"<cdata 'enum foo' 7: ab>\"\n    assert string(e) == 'ab'\n\ndef test_enum_in_struct():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"enum foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    BStruct = new_struct_type(\"struct bar\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BEnum, -1)])\n    p = newp(BStructPtr, [-20])\n    assert p.a1 == -20\n    p = newp(BStructPtr, [12])\n    assert p.a1 == 12\n    e = pytest.raises(TypeError, newp, BStructPtr, [None])\n    msg = str(e.value)\n    assert (\"an integer is required\" in msg or  # CPython\n            \"unsupported operand type for int(): 'NoneType'\" in msg or  # old PyPys\n            \"expected integer, got NoneType object\" in msg) # newer PyPys\n    with pytest.raises(TypeError):\n        p.a1 = \"def\"\n    if sys.version_info < (3,):\n        BEnum2 = new_enum_type(unicode(\"foo\"), (unicode('abc'),), (5,), BInt)\n        assert string(cast(BEnum2, 5)) == 'abc'\n        assert type(string(cast(BEnum2, 5))) is str\n\ndef test_enum_overflow():\n    max_uint = 2 ** (size_of_int()*8) - 1\n    max_int = max_uint // 2\n    max_ulong = 2 ** (size_of_long()*8) - 1\n    max_long = max_ulong // 2\n    for BPrimitive in [new_primitive_type(\"int\"),\n                       new_primitive_type(\"unsigned int\"),\n                       new_primitive_type(\"long\"),\n                       new_primitive_type(\"unsigned long\")]:\n        for x in [max_uint, max_int, max_ulong, max_long]:\n            for testcase in [x, x+1, -x-1, -x-2]:\n                if int(cast(BPrimitive, testcase)) == testcase:\n                    # fits\n                    BEnum = new_enum_type(\"foo\", (\"AA\",), (testcase,),\n                                          BPrimitive)\n                    assert int(cast(BEnum, testcase)) == testcase\n                else:\n                    # overflows\n                    pytest.raises(OverflowError, new_enum_type,\n                                   \"foo\", (\"AA\",), (testcase,), BPrimitive)\n\ndef test_callback_returning_enum():\n    BInt = new_primitive_type(\"int\")\n    BEnum = new_enum_type(\"foo\", ('def', 'c', 'ab'), (0, 1, -20), BInt)\n    def cb(n):\n        if n & 1:\n            return cast(BEnum, n)\n        else:\n            return n\n    BFunc = new_function_type((BInt,), BEnum)\n    f = callback(BFunc, cb)\n    assert f(0) == 0\n    assert f(1) == 1\n    assert f(-20) == -20\n    assert f(20) == 20\n    assert f(21) == 21\n\ndef test_callback_returning_enum_unsigned():\n    BInt = new_primitive_type(\"int\")\n    BUInt = new_primitive_type(\"unsigned int\")\n    BEnum = new_enum_type(\"foo\", ('def', 'c', 'ab'), (0, 1, 20), BUInt)\n    def cb(n):\n        if n & 1:\n            return cast(BEnum, n)\n        else:\n            return n\n    BFunc = new_function_type((BInt,), BEnum)\n    f = callback(BFunc, cb)\n    assert f(0) == 0\n    assert f(1) == 1\n    assert f(-21) == 2**32 - 21\n    assert f(20) == 20\n    assert f(21) == 21\n\ndef test_callback_returning_char():\n    BInt = new_primitive_type(\"int\")\n    BChar = new_primitive_type(\"char\")\n    def cb(n):\n        return bytechr(n)\n    BFunc = new_function_type((BInt,), BChar)\n    f = callback(BFunc, cb)\n    assert f(0) == b'\\x00'\n    assert f(255) == b'\\xFF'\n\ndef _hacked_pypy_uni4():\n    pyuni4 = {1: True, 2: False}[len(u+'\\U00012345')]\n    return 'PY_DOT_PY' in globals() and not pyuni4\n\ndef test_callback_returning_wchar_t():\n    BInt = new_primitive_type(\"int\")\n    BWChar = new_primitive_type(\"wchar_t\")\n    def cb(n):\n        if n == -1:\n            return u+'\\U00012345'\n        if n == -2:\n            raise ValueError\n        return unichr(n)\n    BFunc = new_function_type((BInt,), BWChar)\n    f = callback(BFunc, cb)\n    assert f(0) == unichr(0)\n    assert f(255) == unichr(255)\n    assert f(0x1234) == u+'\\u1234'\n    if sizeof(BWChar) == 4 and not _hacked_pypy_uni4():\n        assert f(-1) == u+'\\U00012345'\n    assert f(-2) == u+'\\x00'   # and an exception printed to stderr\n\ndef test_struct_with_bitfields():\n    BLong = new_primitive_type(\"long\")\n    BStruct = new_struct_type(\"struct foo\")\n    LONGBITS = 8 * sizeof(BLong)\n    complete_struct_or_union(BStruct, [('a1', BLong, 1),\n                                       ('a2', BLong, 2),\n                                       ('a3', BLong, 3),\n                                       ('a4', BLong, LONGBITS - 5)])\n    d = BStruct.fields\n    assert d[0][1].offset == d[1][1].offset == d[2][1].offset == 0\n    assert d[3][1].offset == sizeof(BLong)\n    def f(m, r):\n        if sys.byteorder == 'little':\n            return r\n        else:\n            return LONGBITS - m - r\n    assert d[0][1].bitshift == f(1, 0)\n    assert d[0][1].bitsize == 1\n    assert d[1][1].bitshift == f(2, 1)\n    assert d[1][1].bitsize == 2\n    assert d[2][1].bitshift == f(3, 3)\n    assert d[2][1].bitsize == 3\n    assert d[3][1].bitshift == f(LONGBITS - 5, 0)\n    assert d[3][1].bitsize == LONGBITS - 5\n    assert sizeof(BStruct) == 2 * sizeof(BLong)\n    assert alignof(BStruct) == alignof(BLong)\n\ndef test_bitfield_instance():\n    BInt = new_primitive_type(\"int\")\n    BUnsignedInt = new_primitive_type(\"unsigned int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, 1),\n                                       ('a2', BUnsignedInt, 2),\n                                       ('a3', BInt, 3)])\n    p = newp(new_pointer_type(BStruct), None)\n    p.a1 = -1\n    assert p.a1 == -1\n    p.a1 = 0\n    with pytest.raises(OverflowError):\n        p.a1 = 2\n    assert p.a1 == 0\n    #\n    p.a1 = -1\n    p.a2 = 3\n    p.a3 = -4\n    with pytest.raises(OverflowError):\n        p.a3 = 4\n    with pytest.raises(OverflowError) as e:\n        p.a3 = -5\n    assert str(e.value) == (\"value -5 outside the range allowed by the \"\n                            \"bit field width: -4 <= x <= 3\")\n    assert p.a1 == -1 and p.a2 == 3 and p.a3 == -4\n    #\n    # special case for convenience: \"int x:1\", while normally signed,\n    # allows also setting the value \"1\" (it still gets read back as -1)\n    p.a1 = 1\n    assert p.a1 == -1\n    with pytest.raises(OverflowError) as e:\n        p.a1 = -2\n    assert str(e.value) == (\"value -2 outside the range allowed by the \"\n                            \"bit field width: -1 <= x <= 1\")\n\ndef test_bitfield_instance_init():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, 1)])\n    p = newp(new_pointer_type(BStruct), [-1])\n    assert p.a1 == -1\n    p = newp(new_pointer_type(BStruct), {'a1': -1})\n    assert p.a1 == -1\n    #\n    BUnion = new_union_type(\"union bar\")\n    complete_struct_or_union(BUnion, [('a1', BInt, 1)])\n    p = newp(new_pointer_type(BUnion), [-1])\n    assert p.a1 == -1\n\ndef test_weakref():\n    import _weakref\n    BInt = new_primitive_type(\"int\")\n    BPtr = new_pointer_type(BInt)\n    rlist = [_weakref.ref(BInt),\n             _weakref.ref(newp(BPtr, 42)),\n             _weakref.ref(cast(BPtr, 42)),\n             _weakref.ref(cast(BInt, 42)),\n             _weakref.ref(buffer(newp(BPtr, 42))),\n             ]\n    for i in range(5):\n        import gc; gc.collect()\n        if [r() for r in rlist] == [None for r in rlist]:\n            break\n\ndef test_no_inheritance():\n    BInt = new_primitive_type(\"int\")\n    try:\n        class foo(type(BInt)): pass\n    except TypeError:\n        pass\n    else:\n        raise AssertionError\n    x = cast(BInt, 42)\n    try:\n        class foo(type(x)): pass\n    except TypeError:\n        pass\n    else:\n        raise AssertionError\n\ndef test_assign_string():\n    BChar = new_primitive_type(\"char\")\n    BArray1 = new_array_type(new_pointer_type(BChar), 5)\n    BArray2 = new_array_type(new_pointer_type(BArray1), 5)\n    a = newp(BArray2, [b\"abc\", b\"de\", b\"ghij\"])\n    assert string(a[1]) == b\"de\"\n    assert string(a[2]) == b\"ghij\"\n    a[2] = b\".\"\n    assert string(a[2]) == b\".\"\n    a[2] = b\"12345\"\n    assert string(a[2]) == b\"12345\"\n    with pytest.raises(IndexError) as e:\n        a[2] = b\"123456\"\n    assert 'char[5]' in str(e.value)\n    assert 'got 6 characters' in str(e.value)\n\ndef test_add_error():\n    x = cast(new_primitive_type(\"int\"), 42)\n    with pytest.raises(TypeError):\n        x + 1\n    with pytest.raises(TypeError):\n        x - 1\n\ndef test_void_errors():\n    pytest.raises(ValueError, alignof, new_void_type())\n    pytest.raises(TypeError, newp, new_pointer_type(new_void_type()), None)\n\ndef test_too_many_items():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), 5)\n    pytest.raises(IndexError, newp, BArray, tuple(b'123456'))\n    pytest.raises(IndexError, newp, BArray, list(b'123456'))\n    pytest.raises(IndexError, newp, BArray, b'123456')\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [])\n    pytest.raises(TypeError, newp, new_pointer_type(BStruct), b'')\n    pytest.raises(ValueError, newp, new_pointer_type(BStruct), [b'1'])\n\ndef test_more_type_errors():\n    BInt = new_primitive_type(\"int\")\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), 5)\n    pytest.raises(TypeError, newp, BArray, 12.34)\n    BArray = new_array_type(new_pointer_type(BInt), 5)\n    pytest.raises(TypeError, newp, BArray, 12.34)\n    BFloat = new_primitive_type(\"float\")\n    pytest.raises(TypeError, cast, BFloat, newp(BArray, None))\n\ndef test_more_overflow_errors():\n    BUInt = new_primitive_type(\"unsigned int\")\n    pytest.raises(OverflowError, newp, new_pointer_type(BUInt), -1)\n    pytest.raises(OverflowError, newp, new_pointer_type(BUInt), 2**32)\n\ndef test_newp_copying():\n    \"\"\"Test that we can do newp(<type>, <cdata of the given type>) for most\n    types, including same-type arrays.\n    \"\"\"\n    BInt = new_primitive_type(\"int\")\n    p = newp(new_pointer_type(BInt), cast(BInt, 42))\n    assert p[0] == 42\n    #\n    BUInt = new_primitive_type(\"unsigned int\")\n    p = newp(new_pointer_type(BUInt), cast(BUInt, 42))\n    assert p[0] == 42\n    #\n    BChar = new_primitive_type(\"char\")\n    p = newp(new_pointer_type(BChar), cast(BChar, '!'))\n    assert p[0] == b'!'\n    #\n    BFloat = new_primitive_type(\"float\")\n    p = newp(new_pointer_type(BFloat), cast(BFloat, 12.25))\n    assert p[0] == 12.25\n    #\n    BStruct = new_struct_type(\"struct foo_s\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BInt, -1)])\n    s1 = newp(BStructPtr, [42])\n    p1 = newp(new_pointer_type(BStructPtr), s1)\n    assert p1[0] == s1\n    #\n    BArray = new_array_type(new_pointer_type(BInt), None)\n    a1 = newp(BArray, [1, 2, 3, 4])\n    pytest.raises(TypeError, newp, BArray, a1)\n    BArray6 = new_array_type(new_pointer_type(BInt), 6)\n    a1 = newp(BArray6, [10, 20, 30])\n    a2 = newp(BArray6, a1)\n    assert list(a2) == [10, 20, 30, 0, 0, 0]\n    #\n    s1 = newp(BStructPtr, [42])\n    s2 = newp(BStructPtr, s1[0])\n    assert s2.a1 == 42\n    #\n    BUnion = new_union_type(\"union foo_u\")\n    BUnionPtr = new_pointer_type(BUnion)\n    complete_struct_or_union(BUnion, [('a1', BInt, -1)])\n    u1 = newp(BUnionPtr, [42])\n    u2 = newp(BUnionPtr, u1[0])\n    assert u2.a1 == 42\n    #\n    BFunc = new_function_type((BInt,), BUInt)\n    p1 = cast(BFunc, 42)\n    p2 = newp(new_pointer_type(BFunc), p1)\n    assert p2[0] == p1\n\ndef test_string():\n    BChar = new_primitive_type(\"char\")\n    assert string(cast(BChar, 42)) == b'*'\n    assert string(cast(BChar, 0)) == b'\\x00'\n    BCharP = new_pointer_type(BChar)\n    BArray = new_array_type(BCharP, 10)\n    a = newp(BArray, b\"hello\")\n    assert len(a) == 10\n    assert string(a) == b\"hello\"\n    p = a + 2\n    assert string(p) == b\"llo\"\n    assert string(newp(new_array_type(BCharP, 4), b\"abcd\")) == b\"abcd\"\n    pytest.raises(RuntimeError, string, cast(BCharP, 0))\n    assert string(a, 4) == b\"hell\"\n    assert string(a, 5) == b\"hello\"\n    assert string(a, 6) == b\"hello\"\n\ndef test_string_byte():\n    BByte = new_primitive_type(\"signed char\")\n    assert string(cast(BByte, 42)) == b'*'\n    assert string(cast(BByte, 0)) == b'\\x00'\n    BArray = new_array_type(new_pointer_type(BByte), None)\n    a = newp(BArray, [65, 66, 67])\n    assert type(string(a)) is bytes and string(a) == b'ABC'\n    #\n    BByte = new_primitive_type(\"unsigned char\")\n    assert string(cast(BByte, 42)) == b'*'\n    assert string(cast(BByte, 0)) == b'\\x00'\n    BArray = new_array_type(new_pointer_type(BByte), None)\n    a = newp(BArray, [65, 66, 67])\n    assert type(string(a)) is bytes and string(a) == b'ABC'\n    if 'PY_DOT_PY' not in globals() and sys.version_info < (3,):\n        assert string(a, 8).startswith(b'ABC')  # may contain additional garbage\n\ndef test_string_wchar():\n    for typename in [\"wchar_t\", \"char16_t\", \"char32_t\"]:\n        _test_string_wchar_variant(typename)\n\ndef _test_string_wchar_variant(typename):\n    BWChar = new_primitive_type(typename)\n    assert string(cast(BWChar, 42)) == u+'*'\n    assert string(cast(BWChar, 0x4253)) == u+'\\u4253'\n    assert string(cast(BWChar, 0)) == u+'\\x00'\n    BArray = new_array_type(new_pointer_type(BWChar), None)\n    a = newp(BArray, [u+'A', u+'B', u+'C'])\n    assert type(string(a)) is unicode and string(a) == u+'ABC'\n    if 'PY_DOT_PY' not in globals() and sys.version_info < (3,):\n        try:\n            # may contain additional garbage\n            assert string(a, 8).startswith(u+'ABC')\n        except ValueError:    # garbage contains values > 0x10FFFF\n            assert sizeof(BWChar) == 4\n\ndef test_string_typeerror():\n    BShort = new_primitive_type(\"short\")\n    BArray = new_array_type(new_pointer_type(BShort), None)\n    a = newp(BArray, [65, 66, 67])\n    pytest.raises(TypeError, string, a)\n\ndef test_bug_convert_to_ptr():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BDouble = new_primitive_type(\"double\")\n    x = cast(BDouble, 42)\n    pytest.raises(TypeError, newp, new_pointer_type(BCharP), x)\n\ndef test_set_struct_fields():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharArray10 = new_array_type(BCharP, 10)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BCharArray10, -1)])\n    p = newp(BStructPtr, None)\n    assert string(p.a1) == b''\n    p.a1 = b'foo'\n    assert string(p.a1) == b'foo'\n    assert list(p.a1) == [b'f', b'o', b'o'] + [b'\\x00'] * 7\n    p.a1 = [b'x', b'y']\n    assert string(p.a1) == b'xyo'\n\ndef test_invalid_function_result_types():\n    BFunc = new_function_type((), new_void_type())\n    BArray = new_array_type(new_pointer_type(BFunc), 5)        # works\n    new_function_type((), BFunc)    # works\n    new_function_type((), new_primitive_type(\"int\"))\n    new_function_type((), new_pointer_type(BFunc))\n    BUnion = new_union_type(\"union foo_u\")\n    complete_struct_or_union(BUnion, [])\n    BFunc = new_function_type((), BUnion)\n    pytest.raises(NotImplementedError, cast(BFunc, 123))\n    pytest.raises(TypeError, new_function_type, (), BArray)\n\ndef test_struct_return_in_func():\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"double\")\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo_s\")\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BShort, -1)])\n    BFunc10 = new_function_type((BInt,), BStruct)\n    f = cast(BFunc10, _testfunc(10))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct foo_s' owning 4 bytes>\"\n    assert s.a1 == bytechr(40)\n    assert s.a2 == 40 * 40\n    #\n    BStruct11 = new_struct_type(\"struct test11\")\n    complete_struct_or_union(BStruct11, [('a1', BInt, -1),\n                                         ('a2', BInt, -1)])\n    BFunc11 = new_function_type((BInt,), BStruct11)\n    f = cast(BFunc11, _testfunc(11))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test11' owning 8 bytes>\"\n    assert s.a1 == 40\n    assert s.a2 == 40 * 40\n    #\n    BStruct12 = new_struct_type(\"struct test12\")\n    complete_struct_or_union(BStruct12, [('a1', BDouble, -1),\n                                         ])\n    BFunc12 = new_function_type((BInt,), BStruct12)\n    f = cast(BFunc12, _testfunc(12))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test12' owning 8 bytes>\"\n    assert s.a1 == 40.0\n    #\n    BStruct13 = new_struct_type(\"struct test13\")\n    complete_struct_or_union(BStruct13, [('a1', BInt, -1),\n                                         ('a2', BInt, -1),\n                                         ('a3', BInt, -1)])\n    BFunc13 = new_function_type((BInt,), BStruct13)\n    f = cast(BFunc13, _testfunc(13))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test13' owning 12 bytes>\"\n    assert s.a1 == 40\n    assert s.a2 == 40 * 40\n    assert s.a3 == 40 * 40 * 40\n    #\n    BStruct14 = new_struct_type(\"struct test14\")\n    complete_struct_or_union(BStruct14, [('a1', BFloat, -1),\n                                         ])\n    BFunc14 = new_function_type((BInt,), BStruct14)\n    f = cast(BFunc14, _testfunc(14))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test14' owning 4 bytes>\"\n    assert s.a1 == 40.0\n    #\n    BStruct15 = new_struct_type(\"struct test15\")\n    complete_struct_or_union(BStruct15, [('a1', BFloat, -1),\n                                         ('a2', BInt, -1)])\n    BFunc15 = new_function_type((BInt,), BStruct15)\n    f = cast(BFunc15, _testfunc(15))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test15' owning 8 bytes>\"\n    assert s.a1 == 40.0\n    assert s.a2 == 40 * 40\n    #\n    BStruct16 = new_struct_type(\"struct test16\")\n    complete_struct_or_union(BStruct16, [('a1', BFloat, -1),\n                                         ('a2', BFloat, -1)])\n    BFunc16 = new_function_type((BInt,), BStruct16)\n    f = cast(BFunc16, _testfunc(16))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test16' owning 8 bytes>\"\n    assert s.a1 == 40.0\n    assert s.a2 == -40.0\n    #\n    BStruct17 = new_struct_type(\"struct test17\")\n    complete_struct_or_union(BStruct17, [('a1', BInt, -1),\n                                         ('a2', BFloat, -1)])\n    BFunc17 = new_function_type((BInt,), BStruct17)\n    f = cast(BFunc17, _testfunc(17))\n    s = f(40)\n    assert repr(s) == \"<cdata 'struct test17' owning 8 bytes>\"\n    assert s.a1 == 40\n    assert s.a2 == 40.0 * 40.0\n    #\n    BStruct17Ptr = new_pointer_type(BStruct17)\n    BFunc18 = new_function_type((BStruct17Ptr,), BInt)\n    f = cast(BFunc18, _testfunc(18))\n    x = f([[40, 2.5]])\n    assert x == 42\n    x = f([{'a2': 43.1}])\n    assert x == 43\n\ndef test_cast_with_functionptr():\n    BFunc = new_function_type((), new_void_type())\n    BFunc2 = new_function_type((), new_primitive_type(\"short\"))\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BFunc, -1)])\n    newp(BStructPtr, [cast(BFunc, 0)])\n    newp(BStructPtr, [cast(BCharP, 0)])\n    pytest.raises(TypeError, newp, BStructPtr, [cast(BIntP, 0)])\n    pytest.raises(TypeError, newp, BStructPtr, [cast(BFunc2, 0)])\n\ndef test_wchar():\n    _test_wchar_variant(\"wchar_t\")\n    if sys.platform.startswith(\"linux\"):\n        BWChar = new_primitive_type(\"wchar_t\")\n        assert sizeof(BWChar) == 4\n        # wchar_t is often signed on Linux, but not always (e.g. on ARM)\n        assert int(cast(BWChar, -1)) in (-1, 4294967295)\n\ndef test_char16():\n    BChar16 = new_primitive_type(\"char16_t\")\n    assert sizeof(BChar16) == 2\n    _test_wchar_variant(\"char16_t\")\n    assert int(cast(BChar16, -1)) == 0xffff       # always unsigned\n\ndef test_char32():\n    BChar32 = new_primitive_type(\"char32_t\")\n    assert sizeof(BChar32) == 4\n    _test_wchar_variant(\"char32_t\")\n    assert int(cast(BChar32, -1)) == 0xffffffff   # always unsigned\n\ndef _test_wchar_variant(typename):\n    BWChar = new_primitive_type(typename)\n    BInt = new_primitive_type(\"int\")\n    pyuni4 = {1: True, 2: False}[len(u+'\\U00012345')]\n    wchar4 = {2: False, 4: True}[sizeof(BWChar)]\n    assert str(cast(BWChar, 0x45)) == \"<cdata '%s' %s'E'>\" % (\n        typename, mandatory_u_prefix)\n    assert str(cast(BWChar, 0x1234)) == \"<cdata '%s' %s'\\u1234'>\" % (\n        typename, mandatory_u_prefix)\n    if not _hacked_pypy_uni4():\n        if wchar4:\n            x = cast(BWChar, 0x12345)\n            assert str(x) == \"<cdata '%s' %s'\\U00012345'>\" % (\n                typename, mandatory_u_prefix)\n            assert int(x) == 0x12345\n        else:\n            x = cast(BWChar, 0x18345)\n            assert str(x) == \"<cdata '%s' %s'\\u8345'>\" % (\n                typename, mandatory_u_prefix)\n            assert int(x) == 0x8345\n    #\n    BWCharP = new_pointer_type(BWChar)\n    BStruct = new_struct_type(\"struct foo_s\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BWChar, -1),\n                                       ('a2', BWCharP, -1)])\n    s = newp(BStructPtr)\n    s.a1 = u+'\\x00'\n    assert s.a1 == u+'\\x00'\n    with pytest.raises(TypeError):\n        s.a1 = b'a'\n    with pytest.raises(TypeError):\n        s.a1 = bytechr(0xFF)\n    s.a1 = u+'\\u1234'\n    assert s.a1 == u+'\\u1234'\n    if pyuni4:\n        if wchar4:\n            s.a1 = u+'\\U00012345'\n            assert s.a1 == u+'\\U00012345'\n    elif wchar4:\n        if not _hacked_pypy_uni4():\n            s.a1 = cast(BWChar, 0x12345)\n            assert s.a1 == u+'\\ud808\\udf45'\n            s.a1 = u+'\\ud807\\udf44'\n            assert s.a1 == u+'\\U00011f44'\n    else:\n        with pytest.raises(TypeError):\n            s.a1 = u+'\\U00012345'\n    #\n    BWCharArray = new_array_type(BWCharP, None)\n    a = newp(BWCharArray, u+'hello \\u1234 world')\n    assert len(a) == 14   # including the final null\n    assert string(a) == u+'hello \\u1234 world'\n    a[13] = u+'!'\n    assert string(a) == u+'hello \\u1234 world!'\n    assert str(a) == repr(a)\n    assert a[6] == u+'\\u1234'\n    a[6] = u+'-'\n    assert string(a) == u+'hello - world!'\n    assert str(a) == repr(a)\n    #\n    if wchar4 and not _hacked_pypy_uni4():\n        u1 = u+'\\U00012345\\U00012346\\U00012347'\n        a = newp(BWCharArray, u1)\n        assert len(a) == 4\n        assert string(a) == u1\n        assert len(list(a)) == 4\n        expected = [u+'\\U00012345', u+'\\U00012346', u+'\\U00012347', unichr(0)]\n        assert list(a) == expected\n        got = [a[i] for i in range(4)]\n        assert got == expected\n        with pytest.raises(IndexError):\n            a[4]\n    #\n    w = cast(BWChar, 'a')\n    assert repr(w) == \"<cdata '%s' %s'a'>\" % (typename, mandatory_u_prefix)\n    assert str(w) == repr(w)\n    assert string(w) == u+'a'\n    assert int(w) == ord('a')\n    w = cast(BWChar, 0x1234)\n    assert repr(w) == \"<cdata '%s' %s'\\u1234'>\" % (typename, mandatory_u_prefix)\n    assert str(w) == repr(w)\n    assert string(w) == u+'\\u1234'\n    assert int(w) == 0x1234\n    w = cast(BWChar, u+'\\u8234')\n    assert repr(w) == \"<cdata '%s' %s'\\u8234'>\" % (typename, mandatory_u_prefix)\n    assert str(w) == repr(w)\n    assert string(w) == u+'\\u8234'\n    assert int(w) == 0x8234\n    w = cast(BInt, u+'\\u1234')\n    assert repr(w) == \"<cdata 'int' 4660>\"\n    if wchar4 and not _hacked_pypy_uni4():\n        w = cast(BWChar, u+'\\U00012345')\n        assert repr(w) == \"<cdata '%s' %s'\\U00012345'>\" % (\n            typename, mandatory_u_prefix)\n        assert str(w) == repr(w)\n        assert string(w) == u+'\\U00012345'\n        assert int(w) == 0x12345\n        w = cast(BInt, u+'\\U00012345')\n        assert repr(w) == \"<cdata 'int' 74565>\"\n    pytest.raises(TypeError, cast, BInt, u+'')\n    pytest.raises(TypeError, cast, BInt, u+'XX')\n    assert int(cast(BInt, u+'a')) == ord('a')\n    #\n    a = newp(BWCharArray, u+'hello - world')\n    p = cast(BWCharP, a)\n    assert string(p) == u+'hello - world'\n    p[6] = u+'\\u2345'\n    assert string(p) == u+'hello \\u2345 world'\n    #\n    s = newp(BStructPtr, [u+'\\u1234', p])\n    assert s.a1 == u+'\\u1234'\n    assert s.a2 == p\n    assert str(s.a2) == repr(s.a2)\n    assert string(s.a2) == u+'hello \\u2345 world'\n    #\n    q = cast(BWCharP, 0)\n    assert str(q) == repr(q)\n    pytest.raises(RuntimeError, string, q)\n    #\n    def cb(p):\n        assert repr(p).startswith(\"<cdata '%s *' 0x\" % typename)\n        return len(string(p))\n    BFunc = new_function_type((BWCharP,), BInt, False)\n    f = callback(BFunc, cb, -42)\n    assert f(u+'a\\u1234b') == 3\n    #\n    if wchar4 and not pyuni4 and not _hacked_pypy_uni4():\n        # try out-of-range wchar_t values\n        x = cast(BWChar, 1114112)\n        pytest.raises(ValueError, string, x)\n        x = cast(BWChar, -1)\n        pytest.raises(ValueError, string, x)\n\ndef test_wchar_variants_mix():\n    BWChar  = new_primitive_type(\"wchar_t\")\n    BChar16 = new_primitive_type(\"char16_t\")\n    BChar32 = new_primitive_type(\"char32_t\")\n    assert int(cast(BChar32, cast(BChar16, -2))) == 0xfffe\n    assert int(cast(BWChar, cast(BChar16, -2))) == 0xfffe\n    assert int(cast(BChar16, cast(BChar32, 0x0001f345))) == 0xf345\n    assert int(cast(BChar16, cast(BWChar, 0x0001f345))) == 0xf345\n    #\n    BChar16A = new_array_type(new_pointer_type(BChar16), None)\n    BChar32A = new_array_type(new_pointer_type(BChar32), None)\n    x = cast(BChar32, 'A')\n    pytest.raises(TypeError, newp, BChar16A, [x])\n    x = cast(BChar16, 'A')\n    pytest.raises(TypeError, newp, BChar32A, [x])\n    #\n    a = newp(BChar16A, u+'\\U00012345')\n    assert len(a) == 3\n    a = newp(BChar32A, u+'\\U00012345')\n    assert len(a) == 2   # even if the Python unicode string above is 2 chars\n\ndef test_keepalive_struct():\n    # exception to the no-keepalive rule: p=newp(BStructPtr) returns a\n    # pointer owning the memory, and p[0] returns a pointer to the\n    # struct that *also* owns the memory\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', new_primitive_type(\"int\"), -1),\n                                       ('a2', new_primitive_type(\"int\"), -1),\n                                       ('a3', new_primitive_type(\"int\"), -1)])\n    p = newp(BStructPtr)\n    assert repr(p) == \"<cdata 'struct foo *' owning 12 bytes>\"\n    q = p[0]\n    assert repr(q) == \"<cdata 'struct foo' owning 12 bytes>\"\n    q.a1 = 123456\n    assert p.a1 == 123456\n    r = cast(BStructPtr, p)\n    assert repr(r[0]).startswith(\"<cdata 'struct foo &' 0x\")\n    del p\n    import gc; gc.collect()\n    assert q.a1 == 123456\n    assert repr(q) == \"<cdata 'struct foo' owning 12 bytes>\"\n    assert q.a1 == 123456\n\ndef test_nokeepalive_struct():\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    BStructPtrPtr = new_pointer_type(BStructPtr)\n    complete_struct_or_union(BStruct, [('a1', new_primitive_type(\"int\"), -1)])\n    p = newp(BStructPtr)\n    pp = newp(BStructPtrPtr)\n    pp[0] = p\n    s = pp[0][0]\n    assert repr(s).startswith(\"<cdata 'struct foo &' 0x\")\n\ndef test_owning_repr():\n    BInt = new_primitive_type(\"int\")\n    BArray = new_array_type(new_pointer_type(BInt), None)   # int[]\n    p = newp(BArray, 7)\n    assert repr(p) == \"<cdata 'int[]' owning 28 bytes>\"\n    assert sizeof(p) == 28\n    #\n    BArray = new_array_type(new_pointer_type(BInt), 7)   # int[7]\n    p = newp(BArray, None)\n    assert repr(p) == \"<cdata 'int[7]' owning 28 bytes>\"\n    assert sizeof(p) == 28\n\ndef test_cannot_dereference_void():\n    BVoidP = new_pointer_type(new_void_type())\n    p = cast(BVoidP, 123456)\n    with pytest.raises(TypeError):\n        p[0]\n    p = cast(BVoidP, 0)\n    with pytest.raises((TypeError, RuntimeError)):\n        p[0]\n\ndef test_iter():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)   # int[]\n    p = newp(BArray, 7)\n    assert list(p) == list(iter(p)) == [0] * 7\n    #\n    pytest.raises(TypeError, iter, cast(BInt, 5))\n    pytest.raises(TypeError, iter, cast(BIntP, 123456))\n\ndef test_cmp():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BVoidP = new_pointer_type(new_void_type())\n    p = newp(BIntP, 123)\n    q = cast(BInt, 124)\n    assert (p == q) is False\n    assert (p != q) is True\n    assert (q == p) is False\n    assert (q != p) is True\n    if strict_compare:\n        with pytest.raises(TypeError): p < q\n        with pytest.raises(TypeError): p <= q\n        with pytest.raises(TypeError): q < p\n        with pytest.raises(TypeError): q <= p\n        with pytest.raises(TypeError): p > q\n        with pytest.raises(TypeError): p >= q\n    r = cast(BVoidP, p)\n    assert (p <  r) is False\n    assert (p <= r) is True\n    assert (p == r) is True\n    assert (p != r) is False\n    assert (p >  r) is False\n    assert (p >= r) is True\n    s = newp(BIntP, 125)\n    assert (p == s) is False\n    assert (p != s) is True\n    assert (p < s) is (p <= s) is (s > p) is (s >= p)\n    assert (p > s) is (p >= s) is (s < p) is (s <= p)\n    assert (p < s) ^ (p > s)\n\ndef test_buffer():\n    try:\n        import __builtin__\n    except ImportError:\n        import builtins as __builtin__\n    BShort = new_primitive_type(\"short\")\n    s = newp(new_pointer_type(BShort), 100)\n    assert sizeof(s) == size_of_ptr()\n    assert sizeof(BShort) == 2\n    assert len(buffer(s)) == 2\n    #\n    BChar = new_primitive_type(\"char\")\n    BCharArray = new_array_type(new_pointer_type(BChar), None)\n    c = newp(BCharArray, b\"hi there\")\n    #\n    buf = buffer(c)\n    assert repr(buf).startswith('<_cffi_backend.buffer object at 0x')\n    assert bytes(buf) == b\"hi there\\x00\"\n    assert type(buf) is buffer\n    if sys.version_info < (3,):\n        assert str(buf) == \"hi there\\x00\"\n        assert unicode(buf) == u+\"hi there\\x00\"\n    else:\n        assert str(buf) == repr(buf)\n    # --mb_length--\n    assert len(buf) == len(b\"hi there\\x00\")\n    # --mb_item--\n    for i in range(-12, 12):\n        try:\n            expected = b\"hi there\\x00\"[i]\n        except IndexError:\n            with pytest.raises(IndexError):\n                buf[i]\n        else:\n            assert buf[i] == bitem2bchr(expected)\n    # --mb_slice--\n    assert buf[:] == b\"hi there\\x00\"\n    for i in range(-12, 12):\n        assert buf[i:] == b\"hi there\\x00\"[i:]\n        assert buf[:i] == b\"hi there\\x00\"[:i]\n        for j in range(-12, 12):\n            assert buf[i:j] == b\"hi there\\x00\"[i:j]\n    # --misc--\n    assert list(buf) == list(map(bitem2bchr, b\"hi there\\x00\"))\n    # --mb_as_buffer--\n    if hasattr(__builtin__, 'buffer'):          # Python <= 2.7\n        pytest.raises(TypeError, __builtin__.buffer, c)\n        bf1 = __builtin__.buffer(buf)\n        assert len(bf1) == len(buf) and bf1[3] == \"t\"\n    if hasattr(__builtin__, 'memoryview'):      # Python >= 2.7\n        pytest.raises(TypeError, memoryview, c)\n        mv1 = memoryview(buf)\n        assert len(mv1) == len(buf) and mv1[3] in (b\"t\", ord(b\"t\"))\n    # --mb_ass_item--\n    expected = list(map(bitem2bchr, b\"hi there\\x00\"))\n    for i in range(-12, 12):\n        try:\n            expected[i] = bytechr(i & 0xff)\n        except IndexError:\n            with pytest.raises(IndexError):\n                buf[i] = bytechr(i & 0xff)\n        else:\n            buf[i] = bytechr(i & 0xff)\n        assert list(buf) == expected\n    # --mb_ass_slice--\n    buf[:] = b\"hi there\\x00\"\n    assert list(buf) == list(c) == list(map(bitem2bchr, b\"hi there\\x00\"))\n    with pytest.raises(ValueError):\n        buf[:] = b\"shorter\"\n    with pytest.raises(ValueError):\n        buf[:] = b\"this is much too long!\"\n    buf[4:2] = b\"\"   # no effect, but should work\n    assert buf[:] == b\"hi there\\x00\"\n    buf[:2] = b\"HI\"\n    assert buf[:] == b\"HI there\\x00\"\n    buf[:2] = b\"hi\"\n    expected = list(map(bitem2bchr, b\"hi there\\x00\"))\n    x = 0\n    for i in range(-12, 12):\n        for j in range(-12, 12):\n            start = i if i >= 0 else i + len(buf)\n            stop  = j if j >= 0 else j + len(buf)\n            start = max(0, min(len(buf), start))\n            stop  = max(0, min(len(buf), stop))\n            sample = bytechr(x & 0xff) * (stop - start)\n            x += 1\n            buf[i:j] = sample\n            expected[i:j] = map(bitem2bchr, sample)\n            assert list(buf) == expected\n\ndef test_getcname():\n    BUChar = new_primitive_type(\"unsigned char\")\n    BArray = new_array_type(new_pointer_type(BUChar), 123)\n    assert getcname(BArray, \"<-->\") == \"unsigned char<-->[123]\"\n\ndef test_errno():\n    BVoid = new_void_type()\n    BFunc5 = new_function_type((), BVoid)\n    f = cast(BFunc5, _testfunc(5))\n    set_errno(50)\n    f()\n    assert get_errno() == 65\n    f(); f()\n    assert get_errno() == 95\n\ndef test_errno_callback():\n    if globals().get('PY_DOT_PY'):\n        pytest.skip(\"cannot run this test on py.py (e.g. fails on Windows)\")\n    set_errno(95)\n    def cb():\n        e = get_errno()\n        set_errno(e - 6)\n    BVoid = new_void_type()\n    BFunc5 = new_function_type((), BVoid)\n    f = callback(BFunc5, cb)\n    f()\n    assert get_errno() == 89\n    f(); f()\n    assert get_errno() == 77\n\ndef test_cast_to_array():\n    # not valid in C!  extension to get a non-owning <cdata 'int[3]'>\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, 3)\n    x = cast(BArray, 0)\n    assert repr(x) == \"<cdata 'int[3]' NULL>\"\n\ndef test_cast_invalid():\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [])\n    p = cast(new_pointer_type(BStruct), 123456)\n    s = p[0]\n    pytest.raises(TypeError, cast, BStruct, s)\n\ndef test_bug_float_convertion():\n    BDouble = new_primitive_type(\"double\")\n    BDoubleP = new_pointer_type(BDouble)\n    pytest.raises(TypeError, newp, BDoubleP, \"foobar\")\n\ndef test_bug_delitem():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    x = newp(BCharP)\n    with pytest.raises(TypeError):\n        del x[0]\n\ndef test_bug_delattr():\n    BLong = new_primitive_type(\"long\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BLong, -1)])\n    x = newp(new_pointer_type(BStruct))\n    with pytest.raises(AttributeError):\n        del x.a1\n\ndef test_variable_length_struct():\n    pytest.skip(\"later\")\n    BLong = new_primitive_type(\"long\")\n    BArray = new_array_type(new_pointer_type(BLong), None)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BLong, -1),\n                                       ('a2', BArray, -1)])\n    assert sizeof(BStruct) == size_of_long()\n    assert alignof(BStruct) == alignof(BLong)\n    #\n    pytest.raises(TypeError, newp, BStructP, None)\n    x = newp(BStructP, 5)\n    assert sizeof(x) == 6 * size_of_long()\n    x[4] = 123\n    assert x[4] == 123\n    with pytest.raises(IndexError):\n        x[5]\n    assert len(x.a2) == 5\n    #\n    pytest.raises(TypeError, newp, BStructP, [123])\n    x = newp(BStructP, [123, 5])\n    assert x.a1 == 123\n    assert len(x.a2) == 5\n    assert list(x.a2) == [0] * 5\n    #\n    x = newp(BStructP, {'a2': 5})\n    assert x.a1 == 0\n    assert len(x.a2) == 5\n    assert list(x.a2) == [0] * 5\n    #\n    x = newp(BStructP, [123, (4, 5)])\n    assert x.a1 == 123\n    assert len(x.a2) == 2\n    assert list(x.a2) == [4, 5]\n    #\n    x = newp(BStructP, {'a2': (4, 5)})\n    assert x.a1 == 0\n    assert len(x.a2) == 2\n    assert list(x.a2) == [4, 5]\n\ndef test_autocast_int():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    BLongLong = new_primitive_type(\"long long\")\n    BULongLong = new_primitive_type(\"unsigned long long\")\n    BULongLongPtr = new_pointer_type(BULongLong)\n    x = newp(BIntPtr, cast(BInt, 42))\n    assert x[0] == 42\n    x = newp(BIntPtr, cast(BLongLong, 42))\n    assert x[0] == 42\n    x = newp(BIntPtr, cast(BULongLong, 42))\n    assert x[0] == 42\n    x = newp(BULongLongPtr, cast(BInt, 42))\n    assert x[0] == 42\n    pytest.raises(OverflowError, newp, BULongLongPtr, cast(BInt, -42))\n    x = cast(BInt, cast(BInt, 42))\n    assert int(x) == 42\n    x = cast(BInt, cast(BLongLong, 42))\n    assert int(x) == 42\n    x = cast(BInt, cast(BULongLong, 42))\n    assert int(x) == 42\n    x = cast(BULongLong, cast(BInt, 42))\n    assert int(x) == 42\n    x = cast(BULongLong, cast(BInt, -42))\n    assert int(x) == 2 ** 64 - 42\n    x = cast(BIntPtr, cast(BInt, 42))\n    assert int(cast(BInt, x)) == 42\n\ndef test_autocast_float():\n    BFloat = new_primitive_type(\"float\")\n    BDouble = new_primitive_type(\"float\")\n    BFloatPtr = new_pointer_type(BFloat)\n    x = newp(BFloatPtr, cast(BDouble, 12.5))\n    assert x[0] == 12.5\n    x = cast(BFloat, cast(BDouble, 12.5))\n    assert float(x) == 12.5\n\ndef test_longdouble():\n    py_py = 'PY_DOT_PY' in globals()\n    BInt = new_primitive_type(\"int\")\n    BLongDouble = new_primitive_type(\"long double\")\n    BLongDoublePtr = new_pointer_type(BLongDouble)\n    BLongDoubleArray = new_array_type(BLongDoublePtr, None)\n    a = newp(BLongDoubleArray, 1)\n    x = a[0]\n    if not py_py:\n        assert repr(x).startswith(\"<cdata 'long double' 0.0\")\n    assert float(x) == 0.0\n    assert int(x) == 0\n    #\n    b = newp(BLongDoubleArray, [1.23])\n    x = b[0]\n    if not py_py:\n        assert repr(x).startswith(\"<cdata 'long double' 1.23\")\n    assert float(x) == 1.23\n    assert int(x) == 1\n    #\n    BFunc19 = new_function_type((BLongDouble, BInt), BLongDouble)\n    f = cast(BFunc19, _testfunc(19))\n    start = lstart = 1.5\n    for i in range(107):\n        start = 4 * start - start * start\n        lstart = f(lstart, 1)\n    lother = f(1.5, 107)\n    if not py_py:\n        assert float(lstart) == float(lother)\n        assert repr(lstart) == repr(lother)\n        if sizeof(BLongDouble) > sizeof(new_primitive_type(\"double\")):\n            assert float(lstart) != start\n            assert repr(lstart).startswith(\"<cdata 'long double' \")\n    #\n    c = newp(BLongDoubleArray, [lstart])\n    x = c[0]\n    assert float(f(lstart, 107)) == float(f(x, 107))\n\ndef test_get_array_of_length_zero():\n    for length in [0, 5, 10]:\n        BLong = new_primitive_type(\"long\")\n        BLongP = new_pointer_type(BLong)\n        BArray0 = new_array_type(BLongP, length)\n        BStruct = new_struct_type(\"struct foo\")\n        BStructPtr = new_pointer_type(BStruct)\n        complete_struct_or_union(BStruct, [('a1', BArray0, -1)])\n        p = newp(BStructPtr, None)\n        if length == 0:\n            assert repr(p.a1).startswith(\"<cdata 'long *' 0x\")\n        else:\n            assert repr(p.a1).startswith(\"<cdata 'long[%d]' 0x\" % length)\n\ndef test_nested_anonymous_struct():\n    BInt = new_primitive_type(\"int\")\n    BChar = new_primitive_type(\"char\")\n    BStruct = new_struct_type(\"struct foo\")\n    BInnerStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BInnerStruct, [('a1', BInt, -1),\n                                            ('a2', BChar, -1)])\n    complete_struct_or_union(BStruct, [('', BInnerStruct, -1),\n                                       ('a3', BChar, -1)])\n    assert sizeof(BInnerStruct) == sizeof(BInt) * 2   # with alignment\n    assert sizeof(BStruct) == sizeof(BInt) * 3        # 'a3' is placed after\n    d = BStruct.fields\n    assert len(d) == 3\n    assert d[0][0] == 'a1'\n    assert d[0][1].type is BInt\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'a2'\n    assert d[1][1].type is BChar\n    assert d[1][1].offset == sizeof(BInt)\n    assert d[1][1].bitshift == -1\n    assert d[1][1].bitsize == -1\n    assert d[2][0] == 'a3'\n    assert d[2][1].type is BChar\n    assert d[2][1].offset == sizeof(BInt) * 2\n    assert d[2][1].bitshift == -1\n    assert d[2][1].bitsize == -1\n\ndef test_nested_anonymous_struct_2():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    BInnerUnion = new_union_type(\"union bar\")\n    complete_struct_or_union(BInnerUnion, [('a1', BInt, -1),\n                                           ('a2', BInt, -1)])\n    complete_struct_or_union(BStruct, [('b1', BInt, -1),\n                                       ('', BInnerUnion, -1),\n                                       ('b2', BInt, -1)])\n    assert sizeof(BInnerUnion) == sizeof(BInt)\n    assert sizeof(BStruct) == sizeof(BInt) * 3\n    fields = [(name, fld.offset, fld.flags) for (name, fld) in BStruct.fields]\n    assert fields == [\n        ('b1', 0 * sizeof(BInt), 0),\n        ('a1', 1 * sizeof(BInt), 0),\n        ('a2', 1 * sizeof(BInt), 1),\n        ('b2', 2 * sizeof(BInt), 0),\n    ]\n\ndef test_sizeof_union():\n    # a union has the largest alignment of its members, and a total size\n    # that is the largest of its items *possibly further aligned* if\n    # another smaller item has a larger alignment...\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    assert sizeof(BShort) == alignof(BShort) == 2\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BChar),\n                                       ('a2', BChar),\n                                       ('a3', BChar)])\n    assert sizeof(BStruct) == 3 and alignof(BStruct) == 1\n    BUnion = new_union_type(\"union u\")\n    complete_struct_or_union(BUnion, [('s', BStruct),\n                                      ('i', BShort)])\n    assert sizeof(BUnion) == 4\n    assert alignof(BUnion) == 2\n\ndef test_unaligned_struct():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('b', BInt, -1, 1)],\n                             None, 5, 1)\n\ndef test_CData_CType():\n    CData, CType = _get_types()\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    nullchr = cast(BChar, 0)\n    chrref = newp(BCharP, None)\n    assert isinstance(nullchr, CData)\n    assert isinstance(chrref, CData)\n    assert not isinstance(BChar, CData)\n    assert not isinstance(nullchr, CType)\n    assert not isinstance(chrref, CType)\n    assert isinstance(BChar, CType)\n\ndef test_no_cdata_float():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BUInt = new_primitive_type(\"unsigned int\")\n    BUIntP = new_pointer_type(BUInt)\n    BFloat = new_primitive_type(\"float\")\n    pytest.raises(TypeError, newp, BIntP, cast(BFloat, 0.0))\n    pytest.raises(TypeError, newp, BUIntP, cast(BFloat, 0.0))\n\ndef test_bool():\n    BBool = new_primitive_type(\"_Bool\")\n    BBoolP = new_pointer_type(BBool)\n    assert int(cast(BBool, False)) == 0\n    assert int(cast(BBool, True)) == 1\n    assert bool(cast(BBool, False)) is False    # since 1.7\n    assert bool(cast(BBool, True)) is True\n    assert int(cast(BBool, 3)) == 1\n    assert int(cast(BBool, long(3))) == 1\n    assert int(cast(BBool, long(10)**4000)) == 1\n    assert int(cast(BBool, -0.1)) == 1\n    assert int(cast(BBool, -0.0)) == 0\n    assert int(cast(BBool, '\\x00')) == 0\n    assert int(cast(BBool, '\\xff')) == 1\n    assert newp(BBoolP, False)[0] == 0\n    assert newp(BBoolP, True)[0] == 1\n    assert newp(BBoolP, 0)[0] == 0\n    assert newp(BBoolP, 1)[0] == 1\n    pytest.raises(TypeError, newp, BBoolP, 1.0)\n    pytest.raises(TypeError, newp, BBoolP, '\\x00')\n    pytest.raises(OverflowError, newp, BBoolP, 2)\n    pytest.raises(OverflowError, newp, BBoolP, -1)\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    p = newp(BCharP, b'\\x01')\n    q = cast(BBoolP, p)\n    assert q[0] is True\n    p = newp(BCharP, b'\\x00')\n    q = cast(BBoolP, p)\n    assert q[0] is False\n    pytest.raises(TypeError, string, cast(BBool, False))\n    BDouble = new_primitive_type(\"double\")\n    assert int(cast(BBool, cast(BDouble, 0.1))) == 1\n    assert int(cast(BBool, cast(BDouble, 0.0))) == 0\n    BBoolA = new_array_type(BBoolP, None)\n    p = newp(BBoolA, b'\\x01\\x00')\n    assert p[0] is True\n    assert p[1] is False\n\ndef test_bool_forbidden_cases():\n    BBool = new_primitive_type(\"_Bool\")\n    BBoolP = new_pointer_type(BBool)\n    BBoolA = new_array_type(BBoolP, None)\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    p = newp(BCharP, b'X')\n    q = cast(BBoolP, p)\n    with pytest.raises(ValueError):\n        q[0]\n    pytest.raises(TypeError, newp, BBoolP, b'\\x00')\n    assert newp(BBoolP, 0)[0] is False\n    assert newp(BBoolP, 1)[0] is True\n    pytest.raises(OverflowError, newp, BBoolP, 2)\n    pytest.raises(OverflowError, newp, BBoolP, -1)\n    pytest.raises(ValueError, newp, BBoolA, b'\\x00\\x01\\x02')\n    pytest.raises(OverflowError, newp, BBoolA, [0, 1, 2])\n    pytest.raises(TypeError, string, newp(BBoolP, 1))\n    pytest.raises(TypeError, string, newp(BBoolA, [1]))\n\ndef test_typeoffsetof():\n    BChar = new_primitive_type(\"char\")\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BChar, -1),\n                                       ('a3', BChar, -1)])\n    pytest.raises(TypeError, typeoffsetof, BStructPtr, None)\n    pytest.raises(TypeError, typeoffsetof, BStruct, None)\n    assert typeoffsetof(BStructPtr, 'a1') == (BChar, 0)\n    assert typeoffsetof(BStruct, 'a1') == (BChar, 0)\n    assert typeoffsetof(BStructPtr, 'a2') == (BChar, 1)\n    assert typeoffsetof(BStruct, 'a3') == (BChar, 2)\n    assert typeoffsetof(BStructPtr, 'a2', 0) == (BChar, 1)\n    assert typeoffsetof(BStruct, u+'a3') == (BChar, 2)\n    pytest.raises(TypeError, typeoffsetof, BStructPtr, 'a2', 1)\n    pytest.raises(KeyError, typeoffsetof, BStructPtr, 'a4')\n    pytest.raises(KeyError, typeoffsetof, BStruct, 'a5')\n    pytest.raises(TypeError, typeoffsetof, BStruct, 42)\n    pytest.raises(TypeError, typeoffsetof, BChar, 'a1')\n\ndef test_typeoffsetof_array():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)\n    pytest.raises(TypeError, typeoffsetof, BArray, None)\n    pytest.raises(TypeError, typeoffsetof, BArray, 'a1')\n    assert typeoffsetof(BArray, 51) == (BInt, 51 * size_of_int())\n    assert typeoffsetof(BIntP, 51) == (BInt, 51 * size_of_int())\n    assert typeoffsetof(BArray, -51) == (BInt, -51 * size_of_int())\n    MAX = sys.maxsize // size_of_int()\n    assert typeoffsetof(BArray, MAX) == (BInt, MAX * size_of_int())\n    assert typeoffsetof(BIntP, MAX) == (BInt, MAX * size_of_int())\n    pytest.raises(OverflowError, typeoffsetof, BArray, MAX + 1)\n\ndef test_typeoffsetof_no_bitfield():\n    BInt = new_primitive_type(\"int\")\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, 4)])\n    pytest.raises(TypeError, typeoffsetof, BStruct, 'a1')\n\ndef test_rawaddressof():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('a1', BChar, -1),\n                                       ('a2', BChar, -1),\n                                       ('a3', BChar, -1)])\n    p = newp(BStructPtr)\n    assert repr(p) == \"<cdata 'struct foo *' owning 3 bytes>\"\n    s = p[0]\n    assert repr(s) == \"<cdata 'struct foo' owning 3 bytes>\"\n    a = rawaddressof(BStructPtr, s, 0)\n    assert repr(a).startswith(\"<cdata 'struct foo *' 0x\")\n    pytest.raises(TypeError, rawaddressof, BStruct, s, 0)\n    b = rawaddressof(BCharP, s, 0)\n    assert b == cast(BCharP, p)\n    c = rawaddressof(BStructPtr, a, 0)\n    assert c == a\n    pytest.raises(TypeError, rawaddressof, BStructPtr, cast(BChar, '?'), 0)\n    #\n    d = rawaddressof(BCharP, s, 1)\n    assert d == cast(BCharP, p) + 1\n    #\n    e = cast(BCharP, 109238)\n    f = rawaddressof(BCharP, e, 42)\n    assert f == e + 42\n    #\n    BCharA = new_array_type(BCharP, None)\n    e = newp(BCharA, 50)\n    f = rawaddressof(BCharP, e, 42)\n    assert f == e + 42\n\ndef test_newp_signed_unsigned_char():\n    BCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"char\")), None)\n    p = newp(BCharArray, b\"foo\")\n    assert len(p) == 4\n    assert list(p) == [b\"f\", b\"o\", b\"o\", b\"\\x00\"]\n    #\n    BUCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"unsigned char\")), None)\n    p = newp(BUCharArray, b\"fo\\xff\")\n    assert len(p) == 4\n    assert list(p) == [ord(\"f\"), ord(\"o\"), 0xff, 0]\n    #\n    BSCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"signed char\")), None)\n    p = newp(BSCharArray, b\"fo\\xff\")\n    assert len(p) == 4\n    assert list(p) == [ord(\"f\"), ord(\"o\"), -1, 0]\n\ndef test_newp_from_bytearray_doesnt_work():\n    BCharArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"char\")), None)\n    pytest.raises(TypeError, newp, BCharArray, bytearray(b\"foo\"))\n    p = newp(BCharArray, 5)\n    buffer(p)[:] = bytearray(b\"foo.\\x00\")\n    assert len(p) == 5\n    assert list(p) == [b\"f\", b\"o\", b\"o\", b\".\", b\"\\x00\"]\n    p[1:3] = bytearray(b\"XY\")\n    assert list(p) == [b\"f\", b\"X\", b\"Y\", b\".\", b\"\\x00\"]\n\ndef test_string_assignment_to_byte_array():\n    BByteArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"unsigned char\")), None)\n    p = newp(BByteArray, 5)\n    p[0:3] = bytearray(b\"XYZ\")\n    assert list(p) == [ord(\"X\"), ord(\"Y\"), ord(\"Z\"), 0, 0]\n\n# XXX hack\nif sys.version_info >= (3,):\n    try:\n        import posix, io\n        posix.fdopen = io.open\n    except ImportError:\n        pass   # win32\n\ndef test_FILE():\n    if sys.platform == \"win32\":\n        pytest.skip(\"testing FILE not implemented\")\n    #\n    BFILE = new_struct_type(\"struct _IO_FILE\")\n    BFILEP = new_pointer_type(BFILE)\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BCharP, BFILEP), BInt, False)\n    BFunc2 = new_function_type((BFILEP, BCharP), BInt, True)\n    ll = find_and_load_library('c')\n    fputs = ll.load_function(BFunc, \"fputs\")\n    fscanf = ll.load_function(BFunc2, \"fscanf\")\n    #\n    import posix\n    fdr, fdw = posix.pipe()\n    fr1 = posix.fdopen(fdr, 'rb', 256)\n    fw1 = posix.fdopen(fdw, 'wb', 256)\n    #\n    fw1.write(b\"X\")\n    res = fputs(b\"hello world\\n\", fw1)\n    assert res >= 0\n    fw1.flush()     # should not be needed\n    #\n    p = newp(new_array_type(BCharP, 100), None)\n    res = fscanf(fr1, b\"%s\\n\", p)\n    assert res == 1\n    assert string(p) == b\"Xhello\"\n    fr1.close()\n    fw1.close()\n\ndef test_FILE_only_for_FILE_arg():\n    if sys.platform == \"win32\":\n        pytest.skip(\"testing FILE not implemented\")\n    #\n    B_NOT_FILE = new_struct_type(\"struct NOT_FILE\")\n    B_NOT_FILEP = new_pointer_type(B_NOT_FILE)\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BCharP, B_NOT_FILEP), BInt, False)\n    ll = find_and_load_library('c')\n    fputs = ll.load_function(BFunc, \"fputs\")\n    #\n    import posix\n    fdr, fdw = posix.pipe()\n    fr1 = posix.fdopen(fdr, 'r')\n    fw1 = posix.fdopen(fdw, 'w')\n    #\n    e = pytest.raises(TypeError, fputs, b\"hello world\\n\", fw1)\n    assert str(e.value).startswith(\n        \"initializer for ctype 'struct NOT_FILE *' must \"\n        \"be a cdata pointer, not \")\n\ndef test_FILE_object():\n    if sys.platform == \"win32\":\n        pytest.skip(\"testing FILE not implemented\")\n    #\n    BFILE = new_struct_type(\"FILE\")\n    BFILEP = new_pointer_type(BFILE)\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BCharP, BFILEP), BInt, False)\n    BFunc2 = new_function_type((BFILEP,), BInt, False)\n    ll = find_and_load_library('c')\n    fputs = ll.load_function(BFunc, \"fputs\")\n    fileno = ll.load_function(BFunc2, \"fileno\")\n    #\n    import posix\n    fdr, fdw = posix.pipe()\n    fw1 = posix.fdopen(fdw, 'wb', 256)\n    #\n    fw1p = cast(BFILEP, fw1)\n    fw1.write(b\"X\")\n    fw1.flush()\n    res = fputs(b\"hello\\n\", fw1p)\n    assert res >= 0\n    res = fileno(fw1p)\n    assert (res == fdw) == (sys.version_info < (3,))\n    fw1.close()\n    #\n    data = posix.read(fdr, 256)\n    assert data == b\"Xhello\\n\"\n    posix.close(fdr)\n\ndef test_errno_saved():\n    set_errno(42)\n    # a random function that will reset errno to 0 (at least on non-windows)\n    import os; os.stat('.')\n    #\n    res = get_errno()\n    assert res == 42\n\ndef test_GetLastError():\n    if sys.platform != \"win32\":\n        pytest.skip(\"GetLastError(): only for Windows\")\n    #\n    lib = find_and_load_library('KERNEL32.DLL')\n    BInt = new_primitive_type(\"int\")\n    BVoid = new_void_type()\n    BFunc1 = new_function_type((BInt,), BVoid, False)\n    BFunc2 = new_function_type((), BInt, False)\n    SetLastError = lib.load_function(BFunc1, \"SetLastError\")\n    GetLastError = lib.load_function(BFunc2, \"GetLastError\")\n    #\n    SetLastError(42)\n    # a random function that will reset the real GetLastError() to 0\n    import nt; nt.stat('.')\n    #\n    res = GetLastError()\n    assert res == 42\n    #\n    SetLastError(2)\n    code, message = getwinerror()\n    assert code == 2\n    assert message == \"The system cannot find the file specified\"\n    #\n    code, message = getwinerror(1155)\n    assert code == 1155\n    assert message == (\"No application is associated with the \"\n                       \"specified file for this operation\")\n\ndef test_nonstandard_integer_types():\n    for typename in ['int8_t', 'uint8_t', 'int16_t', 'uint16_t', 'int32_t',\n                     'uint32_t', 'int64_t', 'uint64_t', 'intptr_t',\n                     'uintptr_t', 'ptrdiff_t', 'size_t', 'ssize_t',\n                     'int_least8_t',  'uint_least8_t',\n                     'int_least16_t', 'uint_least16_t',\n                     'int_least32_t', 'uint_least32_t',\n                     'int_least64_t', 'uint_least64_t',\n                     'int_fast8_t',  'uint_fast8_t',\n                     'int_fast16_t', 'uint_fast16_t',\n                     'int_fast32_t', 'uint_fast32_t',\n                     'int_fast64_t', 'uint_fast64_t',\n                     'intmax_t', 'uintmax_t']:\n        new_primitive_type(typename)    # works\n\ndef test_cannot_convert_unicode_to_charp():\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BCharArray = new_array_type(BCharP, None)\n    pytest.raises(TypeError, newp, BCharArray, u+'foobar')\n\ndef test_buffer_keepalive():\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BCharArray = new_array_type(BCharP, None)\n    buflist = []\n    for i in range(20):\n        c = newp(BCharArray, str2bytes(\"hi there %d\" % i))\n        buflist.append(buffer(c))\n    import gc; gc.collect()\n    for i in range(20):\n        buf = buflist[i]\n        assert buf[:] == str2bytes(\"hi there %d\\x00\" % i)\n\ndef test_slice():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    assert len(c) == 5\n    assert repr(c) == \"<cdata 'int[]' owning 20 bytes>\"\n    d = c[1:4]\n    assert len(d) == 3\n    assert repr(d) == \"<cdata 'int[]' sliced length 3>\"\n    d[0] = 123\n    d[2] = 456\n    assert c[1] == 123\n    assert c[3] == 456\n    assert d[2] == 456\n    with pytest.raises(IndexError):\n        d[3]\n    with pytest.raises(IndexError):\n        d[-1]\n\ndef test_slice_ptr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    d = (c+1)[0:2]\n    assert len(d) == 2\n    assert repr(d) == \"<cdata 'int[]' sliced length 2>\"\n    d[1] += 50\n    assert c[2] == 50\n\ndef test_slice_array_checkbounds():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    c[0:5]\n    assert len(c[5:5]) == 0\n    with pytest.raises(IndexError):\n        c[-1:1]\n    cp = c + 0\n    cp[-1:1]\n\ndef test_nonstandard_slice():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    with pytest.raises(IndexError) as e:\n        c[:5]\n    assert str(e.value) == \"slice start must be specified\"\n    with pytest.raises(IndexError) as e:\n        c[4:]\n    assert str(e.value) == \"slice stop must be specified\"\n    with pytest.raises(IndexError) as e:\n        c[1:2:3]\n    assert str(e.value) == \"slice with step not supported\"\n    with pytest.raises(IndexError) as e:\n        c[1:2:1]\n    assert str(e.value) == \"slice with step not supported\"\n    with pytest.raises(IndexError) as e:\n        c[4:2]\n    assert str(e.value) == \"slice start > stop\"\n    with pytest.raises(IndexError) as e:\n        c[6:6]\n    assert str(e.value) == \"index too large (expected 6 <= 5)\"\n\ndef test_setslice():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    c[1:3] = [100, 200]\n    assert list(c) == [0, 100, 200, 0, 0]\n    cp = c + 3\n    cp[-1:1] = [300, 400]\n    assert list(c) == [0, 100, 300, 400, 0]\n    cp[-1:1] = iter([500, 600])\n    assert list(c) == [0, 100, 500, 600, 0]\n    with pytest.raises(ValueError):\n        cp[-1:1] = [1000]\n    assert list(c) == [0, 100, 1000, 600, 0]\n    with pytest.raises(ValueError):\n        cp[-1:1] = (700, 800, 900)\n    assert list(c) == [0, 100, 700, 800, 0]\n\ndef test_setslice_array():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BIntArray = new_array_type(BIntP, None)\n    c = newp(BIntArray, 5)\n    d = newp(BIntArray, [10, 20, 30])\n    c[1:4] = d\n    assert list(c) == [0, 10, 20, 30, 0]\n    #\n    BShortP = new_pointer_type(new_primitive_type(\"short\"))\n    BShortArray = new_array_type(BShortP, None)\n    d = newp(BShortArray, [40, 50])\n    c[1:3] = d\n    assert list(c) == [0, 40, 50, 30, 0]\n\ndef test_cdata_name_module_doc():\n    p = new_primitive_type(\"signed char\")\n    x = cast(p, 17)\n    assert x.__module__ == '_cffi_backend'\n    assert x.__name__ == '<cdata>'\n    assert hasattr(x, '__doc__')\n\ndef test_different_types_of_ptr_equality():\n    BVoidP = new_pointer_type(new_void_type())\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    x = cast(BVoidP, 12345)\n    assert x == cast(BIntP, 12345)\n    assert x != cast(BIntP, 12344)\n    assert hash(x) == hash(cast(BIntP, 12345))\n\ndef test_new_handle():\n    import _weakref\n    BVoidP = new_pointer_type(new_void_type())\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    class mylist(list):\n        pass\n    o = mylist([2, 3, 4])\n    x = newp_handle(BVoidP, o)\n    assert repr(x) == \"<cdata 'void *' handle to [2, 3, 4]>\"\n    assert x\n    assert from_handle(x) is o\n    assert from_handle(cast(BCharP, x)) is o\n    wr = _weakref.ref(o)\n    del o\n    import gc; gc.collect()\n    assert wr() is not None\n    assert from_handle(x) == list((2, 3, 4))\n    assert from_handle(cast(BCharP, x)) == list((2, 3, 4))\n    del x\n    for i in range(3):\n        if wr() is not None:\n            import gc; gc.collect()\n    assert wr() is None\n    pytest.raises(RuntimeError, from_handle, cast(BCharP, 0))\n\ndef test_new_handle_cycle():\n    import _weakref\n    BVoidP = new_pointer_type(new_void_type())\n    class A(object):\n        pass\n    o = A()\n    o.cycle = newp_handle(BVoidP, o)\n    wr = _weakref.ref(o)\n    del o\n    for i in range(3):\n        if wr() is not None:\n            import gc; gc.collect()\n    assert wr() is None\n\ndef _test_bitfield_details(flag):\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    BInt = new_primitive_type(\"int\")\n    BUInt = new_primitive_type(\"unsigned int\")\n    BStruct = new_struct_type(\"struct foo1\")\n    complete_struct_or_union(BStruct, [('a', BChar, -1),\n                                       ('b1', BInt, 9),\n                                       ('b2', BUInt, 7),\n                                       ('c', BChar, -1)], -1, -1, -1, flag)\n    if not (flag & SF_MSVC_BITFIELDS):   # gcc, any variant\n        assert typeoffsetof(BStruct, 'c') == (BChar, 3)\n        assert sizeof(BStruct) == 4\n    else:               # msvc\n        assert typeoffsetof(BStruct, 'c') == (BChar, 8)\n        assert sizeof(BStruct) == 12\n    assert alignof(BStruct) == 4\n    #\n    p = newp(new_pointer_type(BStruct), None)\n    p.a = b'A'\n    p.b1 = -201\n    p.b2 = 99\n    p.c = b'\\x9D'\n    raw = buffer(p)[:]\n    if sys.byteorder == 'little':\n        if flag & SF_MSVC_BITFIELDS:\n            assert raw == b'A\\x00\\x00\\x007\\xC7\\x00\\x00\\x9D\\x00\\x00\\x00'\n        elif flag & SF_GCC_LITTLE_ENDIAN:\n            assert raw == b'A7\\xC7\\x9D'\n        elif flag & SF_GCC_BIG_ENDIAN:\n            assert raw == b'A\\xE3\\x9B\\x9D'\n        else:\n            raise AssertionError(\"bad flag\")\n    else:\n        if flag & SF_MSVC_BITFIELDS:\n            assert raw == b'A\\x00\\x00\\x00\\x00\\x00\\xC77\\x9D\\x00\\x00\\x00'\n        elif flag & SF_GCC_LITTLE_ENDIAN:\n            assert raw == b'A\\xC77\\x9D'\n        elif flag & SF_GCC_BIG_ENDIAN:\n            assert raw == b'A\\x9B\\xE3\\x9D'\n        else:\n            raise AssertionError(\"bad flag\")\n    #\n    BStruct = new_struct_type(\"struct foo2\")\n    complete_struct_or_union(BStruct, [('a', BChar, -1),\n                                       ('',  BShort, 9),\n                                       ('c', BChar, -1)], -1, -1, -1, flag)\n    assert typeoffsetof(BStruct, 'c') == (BChar, 4)\n    if flag & SF_MSVC_BITFIELDS:\n        assert sizeof(BStruct) == 6\n        assert alignof(BStruct) == 2\n    elif flag & SF_GCC_X86_BITFIELDS:\n        assert sizeof(BStruct) == 5\n        assert alignof(BStruct) == 1\n    elif flag & SF_GCC_ARM_BITFIELDS:\n        assert sizeof(BStruct) == 6\n        assert alignof(BStruct) == 2\n    else:\n        raise AssertionError(\"bad flag\")\n    #\n    BStruct = new_struct_type(\"struct foo2\")\n    complete_struct_or_union(BStruct, [('a', BChar, -1),\n                                       ('',  BInt, 0),\n                                       ('',  BInt, 0),\n                                       ('c', BChar, -1)], -1, -1, -1, flag)\n    if flag & SF_MSVC_BITFIELDS:\n        assert typeoffsetof(BStruct, 'c') == (BChar, 1)\n        assert sizeof(BStruct) == 2\n        assert alignof(BStruct) == 1\n    elif flag & SF_GCC_X86_BITFIELDS:\n        assert typeoffsetof(BStruct, 'c') == (BChar, 4)\n        assert sizeof(BStruct) == 5\n        assert alignof(BStruct) == 1\n    elif flag & SF_GCC_ARM_BITFIELDS:\n        assert typeoffsetof(BStruct, 'c') == (BChar, 4)\n        assert sizeof(BStruct) == 8\n        assert alignof(BStruct) == 4\n    else:\n        raise AssertionError(\"bad flag\")\n\n\nSF_MSVC_BITFIELDS     = 0x01\nSF_GCC_ARM_BITFIELDS  = 0x02\nSF_GCC_X86_BITFIELDS  = 0x10\n\nSF_GCC_BIG_ENDIAN     = 0x04\nSF_GCC_LITTLE_ENDIAN  = 0x40\n\nSF_PACKED             = 0x08\n\ndef test_bitfield_as_x86_gcc():\n    _test_bitfield_details(flag=SF_GCC_X86_BITFIELDS|SF_GCC_LITTLE_ENDIAN)\n\ndef test_bitfield_as_msvc():\n    _test_bitfield_details(flag=SF_MSVC_BITFIELDS|SF_GCC_LITTLE_ENDIAN)\n\ndef test_bitfield_as_arm_gcc():\n    _test_bitfield_details(flag=SF_GCC_ARM_BITFIELDS|SF_GCC_LITTLE_ENDIAN)\n\ndef test_bitfield_as_ppc_gcc():\n    # PowerPC uses the same format as X86, but is big-endian\n    _test_bitfield_details(flag=SF_GCC_X86_BITFIELDS|SF_GCC_BIG_ENDIAN)\n\n\ndef buffer_warning(cdata):\n    import warnings\n    buf = buffer(cdata)\n    bytes = len(buf)\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(\"always\")\n        buffer(cdata, bytes)\n        assert len(w) == 0\n        buffer(cdata, bytes + 1)\n        assert len(w) <= 1\n        return len(w) == 1\n\ndef test_struct_array_no_length():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)\n    BStruct = new_struct_type(\"foo\")\n    pytest.raises(TypeError, complete_struct_or_union,\n                   BStruct, [('x', BArray),\n                             ('y', BInt)])\n    #\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('x', BInt),\n                                       ('y', BArray)])\n    assert sizeof(BStruct) == size_of_int()\n    d = BStruct.fields\n    assert len(d) == 2\n    assert d[0][0] == 'x'\n    assert d[0][1].type is BInt\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'y'\n    assert d[1][1].type is BArray\n    assert d[1][1].offset == size_of_int()\n    assert d[1][1].bitshift == -2\n    assert d[1][1].bitsize == -1\n    #\n    p = newp(new_pointer_type(BStruct))\n    p.x = 42\n    assert p.x == 42\n    assert typeof(p.y) is BArray\n    assert len(p.y) == 0\n    assert p.y == cast(BIntP, p) + 1\n    #\n    p = newp(new_pointer_type(BStruct), [100])\n    assert p.x == 100\n    assert len(p.y) == 0\n    #\n    # Tests for\n    #    ffi.new(\"struct_with_var_array *\", [field.., [the_array_items..]])\n    #    ffi.new(\"struct_with_var_array *\", [field.., array_size])\n    plist = []\n    for i in range(20):\n        if i % 2 == 0:\n            p = newp(new_pointer_type(BStruct), [100, [200, i, 400]])\n        else:\n            p = newp(new_pointer_type(BStruct), [100, 3])\n            p.y[1] = i\n            p.y[0] = 200\n            assert p.y[2] == 0\n            p.y[2] = 400\n        assert len(p.y) == 3\n        assert len(p[0].y) == 3\n        assert len(buffer(p)) == sizeof(BInt) * 4\n        assert sizeof(p[0]) == sizeof(BInt) * 4\n        plist.append(p)\n    for i in range(20):\n        p = plist[i]\n        assert p.x == 100\n        assert p.y[0] == 200\n        assert p.y[1] == i\n        assert p.y[2] == 400\n        assert list(p.y) == [200, i, 400]\n    #\n    # the following assignment works, as it normally would, for any array field\n    p.y = [501, 601]\n    assert list(p.y) == [501, 601, 400]\n    p[0].y = [500, 600]\n    assert list(p[0].y) == [500, 600, 400]\n    assert repr(p) == \"<cdata 'foo *' owning %d bytes>\" % (\n        sizeof(BStruct) + 3 * sizeof(BInt),)\n    assert repr(p[0]) == \"<cdata 'foo' owning %d bytes>\" % (\n        sizeof(BStruct) + 3 * sizeof(BInt),)\n    assert sizeof(p[0]) == sizeof(BStruct) + 3 * sizeof(BInt)\n    #\n    # from a non-owning pointer, we can't get the length\n    q = cast(new_pointer_type(BStruct), p)\n    assert q.y[0] == 500\n    assert q[0].y[0] == 500\n    pytest.raises(TypeError, len, q.y)\n    pytest.raises(TypeError, len, q[0].y)\n    assert typeof(q.y) is BIntP\n    assert typeof(q[0].y) is BIntP\n    assert sizeof(q[0]) == sizeof(BStruct)\n    #\n    # error cases\n    with pytest.raises(IndexError):\n        p.y[4]\n    with pytest.raises(TypeError):\n        p.y = cast(BIntP, 0)\n    with pytest.raises(TypeError):\n        p.y = 15\n    with pytest.raises(TypeError):\n        p.y = None\n    #\n    # accepting this may be specified by the C99 standard,\n    # or a GCC strangeness...\n    BStruct2 = new_struct_type(\"bar\")\n    complete_struct_or_union(BStruct2, [('f', BStruct),\n                                        ('n', BInt)])\n    p = newp(new_pointer_type(BStruct2), {'n': 42})\n    assert p.n == 42\n    #\n    # more error cases\n    pytest.raises(TypeError, newp, new_pointer_type(BStruct), [100, None])\n    BArray4 = new_array_type(BIntP, 4)\n    BStruct4 = new_struct_type(\"test4\")\n    complete_struct_or_union(BStruct4, [('a', BArray4)])   # not varsized\n    pytest.raises(TypeError, newp, new_pointer_type(BStruct4), [None])\n    pytest.raises(TypeError, newp, new_pointer_type(BStruct4), [4])\n    p = newp(new_pointer_type(BStruct4), [[10, 20, 30]])\n    assert p.a[0] == 10\n    assert p.a[1] == 20\n    assert p.a[2] == 30\n    assert p.a[3] == 0\n    assert buffer_warning(p)\n    #\n    # struct of struct of varsized array\n    BStruct2 = new_struct_type(\"bar\")\n    complete_struct_or_union(BStruct2, [('head', BInt),\n                                        ('tail', BStruct)])\n    for i in range(2):   # try to detect heap overwrites\n        p = newp(new_pointer_type(BStruct2), [100, [200, list(range(50))]])\n        assert p.tail.y[49] == 49\n    assert buffer_warning(p)\n    assert not buffer_warning(cast(new_pointer_type(BStruct2), p))\n    assert not buffer_warning(cast(BIntP, p))\n\ndef test_more_buffer_warning():\n    BChar = new_primitive_type(\"unsigned char\")\n    BCharP = new_pointer_type(BChar)\n    BArray = new_array_type(BCharP, 10)   # char[10]\n    p = newp(BArray)\n    assert buffer_warning(p)\n    assert not buffer_warning(cast(BCharP, p))\n    p = newp(BCharP)\n    assert buffer_warning(p)\n    assert not buffer_warning(cast(BCharP, p))\n\n\ndef test_struct_array_no_length_explicit_position():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BArray = new_array_type(BIntP, None)\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('x', BArray, -1, 0), # actually 3 items\n                                       ('y', BInt, -1, 12)])\n    p = newp(new_pointer_type(BStruct), [[10, 20], 30])\n    assert p.x[0] == 10\n    assert p.x[1] == 20\n    assert p.x[2] == 0\n    assert p.y == 30\n    p = newp(new_pointer_type(BStruct), {'x': [40], 'y': 50})\n    assert p.x[0] == 40\n    assert p.x[1] == 0\n    assert p.x[2] == 0\n    assert p.y == 50\n    p = newp(new_pointer_type(BStruct), {'y': 60})\n    assert p.x[0] == 0\n    assert p.x[1] == 0\n    assert p.x[2] == 0\n    assert p.y == 60\n    #\n    # This \"should\" work too, allocating a larger structure\n    # (a bit strange in this case, but useful in general)\n    plist = []\n    for i in range(20):\n        p = newp(new_pointer_type(BStruct), [[10, 20, 30, 40, 50, 60, 70]])\n        plist.append(p)\n    for i in range(20):\n        p = plist[i]\n        assert p.x[0] == 10\n        assert p.x[1] == 20\n        assert p.x[2] == 30\n        assert p.x[3] == 40 == p.y\n        assert p.x[4] == 50\n        assert p.x[5] == 60\n        assert p.x[6] == 70\n\ndef test_struct_array_not_aligned():\n    # struct a { int x; char y; char z[]; };\n    # ends up of size 8, but 'z' is at offset 5\n    BChar = new_primitive_type(\"char\")\n    BInt = new_primitive_type(\"int\")\n    BCharP = new_pointer_type(BChar)\n    BArray = new_array_type(BCharP, None)\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('x', BInt),\n                                       ('y', BChar),\n                                       ('z', BArray)])\n    assert sizeof(BStruct) == 2 * size_of_int()\n    def offsetof(BType, fieldname):\n        return typeoffsetof(BType, fieldname)[1]\n    base = offsetof(BStruct, 'z')\n    assert base == size_of_int() + 1\n    #\n    p = newp(new_pointer_type(BStruct), {'z': 3})\n    assert sizeof(p[0]) == base + 3\n    q = newp(new_pointer_type(BStruct), {'z': size_of_int()})\n    assert sizeof(q) == size_of_ptr()\n    assert sizeof(q[0]) == base + size_of_int()\n    assert len(p.z) == 3\n    assert len(p[0].z) == 3\n    assert len(q.z) == size_of_int()\n    assert len(q[0].z) == size_of_int()\n\ndef test_ass_slice():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), None)\n    p = newp(BArray, b\"foobar\")\n    p[2:5] = [b\"*\", b\"Z\", b\"T\"]\n    p[1:3] = b\"XY\"\n    assert list(p) == [b\"f\", b\"X\", b\"Y\", b\"Z\", b\"T\", b\"r\", b\"\\x00\"]\n    with pytest.raises(TypeError):\n        p[1:5] = u+'XYZT'\n    with pytest.raises(TypeError):\n        p[1:5] = [1, 2, 3, 4]\n    #\n    for typename in [\"wchar_t\", \"char16_t\", \"char32_t\"]:\n        BUniChar = new_primitive_type(typename)\n        BArray = new_array_type(new_pointer_type(BUniChar), None)\n        p = newp(BArray, u+\"foobar\")\n        p[2:5] = [u+\"*\", u+\"Z\", u+\"T\"]\n        p[1:3] = u+\"XY\"\n        assert list(p) == [u+\"f\", u+\"X\", u+\"Y\", u+\"Z\", u+\"T\", u+\"r\", u+\"\\x00\"]\n        with pytest.raises(TypeError):\n            p[1:5] = b'XYZT'\n        with pytest.raises(TypeError):\n            p[1:5] = [1, 2, 3, 4]\n\ndef test_void_p_arithmetic():\n    BVoid = new_void_type()\n    BInt = new_primitive_type(\"intptr_t\")\n    p = cast(new_pointer_type(BVoid), 100000)\n    assert int(cast(BInt, p)) == 100000\n    assert int(cast(BInt, p + 42)) == 100042\n    assert int(cast(BInt, p - (-42))) == 100042\n    assert (p + 42) - p == 42\n    q = cast(new_pointer_type(new_primitive_type(\"char\")), 100000)\n    with pytest.raises(TypeError):\n        p - q\n    with pytest.raises(TypeError):\n        q - p\n    with pytest.raises(TypeError):\n        p + cast(new_primitive_type('int'), 42)\n    with pytest.raises(TypeError):\n        p - cast(new_primitive_type('int'), 42)\n\ndef test_sizeof_sliced_array():\n    BInt = new_primitive_type(\"int\")\n    BArray = new_array_type(new_pointer_type(BInt), 10)\n    p = newp(BArray, None)\n    assert sizeof(p[2:9]) == 7 * sizeof(BInt)\n\ndef test_packed():\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BShort = new_primitive_type(\"short\")\n    for extra_args in [(SF_PACKED,), (0, 1)]:\n        BStruct = new_struct_type(\"struct foo\")\n        complete_struct_or_union(BStruct, [('a1', BLong, -1),\n                                           ('a2', BChar, -1),\n                                           ('a3', BShort, -1)],\n                                 None, -1, -1, *extra_args)\n        d = BStruct.fields\n        assert len(d) == 3\n        assert d[0][0] == 'a1'\n        assert d[0][1].type is BLong\n        assert d[0][1].offset == 0\n        assert d[0][1].bitshift == -1\n        assert d[0][1].bitsize == -1\n        assert d[1][0] == 'a2'\n        assert d[1][1].type is BChar\n        assert d[1][1].offset == sizeof(BLong)\n        assert d[1][1].bitshift == -1\n        assert d[1][1].bitsize == -1\n        assert d[2][0] == 'a3'\n        assert d[2][1].type is BShort\n        assert d[2][1].offset == sizeof(BLong) + sizeof(BChar)\n        assert d[2][1].bitshift == -1\n        assert d[2][1].bitsize == -1\n        assert sizeof(BStruct) == sizeof(BLong) + sizeof(BChar) + sizeof(BShort)\n        assert alignof(BStruct) == 1\n    #\n    BStruct2 = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct2, [('b1', BChar, -1),\n                                        ('b2', BLong, -1)],\n                             None, -1, -1, 0, 2)\n    d = BStruct2.fields\n    assert len(d) == 2\n    assert d[0][0] == 'b1'\n    assert d[0][1].type is BChar\n    assert d[0][1].offset == 0\n    assert d[0][1].bitshift == -1\n    assert d[0][1].bitsize == -1\n    assert d[1][0] == 'b2'\n    assert d[1][1].type is BLong\n    assert d[1][1].offset == 2\n    assert d[1][1].bitshift == -1\n    assert d[1][1].bitsize == -1\n    assert sizeof(BStruct2) == 2 + sizeof(BLong)\n    assert alignof(BStruct2) == 2\n\ndef test_packed_with_bitfields():\n    if sys.platform == \"win32\":\n        pytest.skip(\"testing gcc behavior\")\n    BLong = new_primitive_type(\"long\")\n    BChar = new_primitive_type(\"char\")\n    BStruct = new_struct_type(\"struct foo\")\n    pytest.raises(NotImplementedError,\n                   complete_struct_or_union,\n                   BStruct, [('a1', BLong, 30),\n                             ('a2', BChar, 5)],\n                   None, -1, -1, SF_PACKED)\n\ndef test_from_buffer():\n    import array\n    a = array.array('H', [10000, 20000, 30000])\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    c = from_buffer(BCharA, a)\n    assert typeof(c) is BCharA\n    assert len(c) == 6\n    assert repr(c) == \"<cdata 'char[]' buffer len 6 from 'array.array' object>\"\n    p = new_pointer_type(new_primitive_type(\"unsigned short\"))\n    cast(p, c)[1] += 500\n    assert list(a) == [10000, 20500, 30000]\n\ndef test_from_buffer_not_str_unicode():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p1 = from_buffer(BCharA, b\"foo\")\n    assert p1 == from_buffer(BCharA, b\"foo\")\n    import gc; gc.collect()\n    assert p1 == from_buffer(BCharA, b\"foo\")\n    pytest.raises(TypeError, from_buffer, BCharA, u+\"foo\")\n    try:\n        from __builtin__ import buffer\n    except ImportError:\n        pass\n    else:\n        # Python 2 only\n        contents = from_buffer(BCharA, buffer(b\"foo\"))\n        assert len(contents) == len(p1)\n        for i in range(len(contents)):\n            assert contents[i] == p1[i]\n        p4 = buffer(u+\"foo\")\n        contents = from_buffer(BCharA, buffer(u+\"foo\"))\n        assert len(contents) == len(p4)\n        for i in range(len(contents)):\n            assert contents[i] == p4[i]\n    try:\n        from __builtin__ import memoryview\n    except ImportError:\n        pass\n    else:\n        contents = from_buffer(BCharA, memoryview(b\"foo\"))\n        assert len(contents) == len(p1)\n        for i in range(len(contents)):\n            assert contents[i] == p1[i]\n\n\ndef test_from_buffer_bytearray():\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p = from_buffer(BCharA, a)\n    assert typeof(p) is BCharA\n    assert len(p) == 3\n    assert repr(p) == \"<cdata 'char[]' buffer len 3 from 'bytearray' object>\"\n    assert p[2] == b\"z\"\n    p[2] = b\".\"\n    assert a[2] == ord(\".\")\n    a[2] = ord(\"?\")\n    assert p[2] == b\"?\"\n\ndef test_from_buffer_more_cases():\n    try:\n        from _cffi_backend import _testbuff\n    except ImportError:\n        pytest.skip(\"not for pypy\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    #\n    def check1(bufobj, expected):\n        c = from_buffer(BCharA, bufobj)\n        assert typeof(c) is BCharA\n        if sys.version_info >= (3,):\n            expected = [bytes(c, \"ascii\") for c in expected]\n        assert list(c) == list(expected)\n    #\n    def check(methods, expected, expected_for_memoryview=None):\n        if sys.version_info >= (3,):\n            if methods <= 7:\n                return\n            if expected_for_memoryview is not None:\n                expected = expected_for_memoryview\n        class X(object):\n            pass\n        _testbuff(X, methods)\n        bufobj = X()\n        check1(bufobj, expected)\n        try:\n            from __builtin__ import buffer\n            bufobjb = buffer(bufobj)\n        except (TypeError, ImportError):\n            pass\n        else:\n            check1(bufobjb, expected)\n        try:\n            bufobjm = memoryview(bufobj)\n        except (TypeError, NameError):\n            pass\n        else:\n            check1(bufobjm, expected_for_memoryview or expected)\n    #\n    check(1, \"RDB\")\n    check(2, \"WRB\")\n    check(4, \"CHB\")\n    check(8, \"GTB\")\n    check(16, \"ROB\")\n    #\n    check(1 | 2,  \"RDB\")\n    check(1 | 4,  \"RDB\")\n    check(2 | 4,  \"CHB\")\n    check(1 | 8,  \"RDB\", \"GTB\")\n    check(1 | 16, \"RDB\", \"ROB\")\n    check(2 | 8,  \"WRB\", \"GTB\")\n    check(2 | 16, \"WRB\", \"ROB\")\n    check(4 | 8,  \"CHB\", \"GTB\")\n    check(4 | 16, \"CHB\", \"ROB\")\n\ndef test_from_buffer_require_writable():\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p1 = from_buffer(BCharA, b\"foo\", False)\n    assert p1 == from_buffer(BCharA, b\"foo\", False)\n    pytest.raises((TypeError, BufferError), from_buffer, BCharA, b\"foo\", True)\n    ba = bytearray(b\"foo\")\n    p1 = from_buffer(BCharA, ba, True)\n    p1[0] = b\"g\"\n    assert ba == b\"goo\"\n\ndef test_from_buffer_types():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BIntA = new_array_type(BIntP, None)\n    lst = [-12345678, 87654321, 489148]\n    bytestring = bytearray(buffer(newp(BIntA, lst))[:] + b'XYZ')\n    lst2 = lst + [42, -999999999]\n    bytestring2 = bytearray(buffer(newp(BIntA, lst2))[:] + b'XYZ')\n    #\n    p1 = from_buffer(BIntA, bytestring)      # int[]\n    assert typeof(p1) is BIntA\n    assert len(p1) == 3\n    assert p1[0] == lst[0]\n    assert p1[1] == lst[1]\n    assert p1[2] == lst[2]\n    with pytest.raises(IndexError):\n        p1[3]\n    with pytest.raises(IndexError):\n        p1[-1]\n    #\n    pytest.raises(TypeError, from_buffer, BInt, bytestring)\n    #\n    p2 = from_buffer(BIntP, bytestring)      # int *\n    assert p2 == p1 or 'PY_DOT_PY' in globals()\n    # note: on py.py ^^^, bytearray buffers are not emulated well enough\n    assert typeof(p2) is BIntP\n    assert p2[0] == lst[0]\n    assert p2[1] == lst[1]\n    assert p2[2] == lst[2]\n    # hopefully does not crash, but doesn't raise an exception:\n    p2[3]\n    p2[-1]\n    # not enough data even for one, but this is not enforced:\n    from_buffer(BIntP, b\"\")\n    #\n    BIntA2 = new_array_type(BIntP, 2)\n    p2 = from_buffer(BIntA2, bytestring)     # int[2]\n    assert typeof(p2) is BIntA2\n    assert len(p2) == 2\n    assert p2[0] == lst[0]\n    assert p2[1] == lst[1]\n    with pytest.raises(IndexError):\n        p2[2]\n    with pytest.raises(IndexError):\n        p2[-1]\n    assert p2 == p1 or 'PY_DOT_PY' in globals()\n    #\n    BIntA4 = new_array_type(BIntP, 4)        # int[4]: too big\n    pytest.raises(ValueError, from_buffer, BIntA4, bytestring)\n    #\n    BStruct = new_struct_type(\"foo\")\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    BStructP = new_pointer_type(BStruct)\n    BStructA = new_array_type(BStructP, None)\n    p1 = from_buffer(BStructA, bytestring2)   # struct[]\n    assert len(p1) == 2\n    assert typeof(p1) is BStructA\n    assert p1[0].a1 == lst2[0]\n    assert p1[0].a2 == lst2[1]\n    assert p1[1].a1 == lst2[2]\n    assert p1[1].a2 == lst2[3]\n    with pytest.raises(IndexError):\n        p1[2]\n    with pytest.raises(IndexError):\n        p1[-1]\n    assert repr(p1) == \"<cdata 'foo[]' buffer len 2 from 'bytearray' object>\"\n    #\n    p2 = from_buffer(BStructP, bytestring2)    # 'struct *'\n    assert p2 == p1 or 'PY_DOT_PY' in globals()\n    assert typeof(p2) is BStructP\n    assert p2.a1 == lst2[0]\n    assert p2.a2 == lst2[1]\n    assert p2[0].a1 == lst2[0]\n    assert p2[0].a2 == lst2[1]\n    assert p2[1].a1 == lst2[2]\n    assert p2[1].a2 == lst2[3]\n    # does not crash:\n    p2[2]\n    p2[-1]\n    # not enough data even for one, but this is not enforced:\n    from_buffer(BStructP, b\"\")\n    from_buffer(BStructP, b\"1234567\")\n    #\n    release(p1)\n    assert repr(p1) == \"<cdata 'foo[]' buffer RELEASED>\"\n    #\n    BEmptyStruct = new_struct_type(\"empty\")\n    complete_struct_or_union(BEmptyStruct, [], Ellipsis, 0)\n    assert sizeof(BEmptyStruct) == 0\n    BEmptyStructP = new_pointer_type(BEmptyStruct)\n    BEmptyStructA = new_array_type(BEmptyStructP, None)\n    pytest.raises(ZeroDivisionError, from_buffer,      # empty[]\n                                      BEmptyStructA, bytestring)\n    #\n    BEmptyStructA5 = new_array_type(BEmptyStructP, 5)\n    p1 = from_buffer(BEmptyStructA5, bytestring)   # struct empty[5]\n    assert typeof(p1) is BEmptyStructA5\n    assert len(p1) == 5\n    assert (cast(BIntP, p1) == from_buffer(BIntA, bytestring)\n            or 'PY_DOT_PY' in globals())\n    #\n    BVarStruct = new_struct_type(\"varfoo\")\n    BVarStructP = new_pointer_type(BVarStruct)\n    complete_struct_or_union(BVarStruct, [('a1', BInt, -1),\n                                          ('va', BIntA, -1)])\n    with pytest.raises(TypeError):\n        from_buffer(BVarStruct, bytestring)\n    pv = from_buffer(BVarStructP, bytestring)    # varfoo *\n    assert pv.a1 == lst[0]\n    assert pv.va[0] == lst[1]\n    assert pv.va[1] == lst[2]\n    assert sizeof(pv[0]) == 1 * size_of_int()\n    with pytest.raises(TypeError):\n        len(pv.va)\n    # hopefully does not crash, but doesn't raise an exception:\n    pv.va[2]\n    pv.va[-1]\n    # not enough data even for one, but this is not enforced:\n    from_buffer(BVarStructP, b\"\")\n    assert repr(pv) == \"<cdata 'varfoo *' buffer from 'bytearray' object>\"\n    assert repr(pv[0]).startswith(\"<cdata 'varfoo &' \")\n    #\n    release(pv)\n    assert repr(pv) == \"<cdata 'varfoo *' buffer RELEASED>\"\n    assert repr(pv[0]).startswith(\"<cdata 'varfoo &' \")\n    #\n    pv = from_buffer(BVarStructP, bytestring)    # make a fresh one\n    with pytest.raises(ValueError):\n        release(pv[0])\n\ndef test_issue483():\n    BInt = new_primitive_type(\"int\")\n    BIntP = new_pointer_type(BInt)\n    BIntA = new_array_type(BIntP, None)\n    lst = list(range(25))\n    bytestring = bytearray(buffer(newp(BIntA, lst))[:] + b'XYZ')\n    p1 = from_buffer(BIntA, bytestring)      # int[]\n    assert len(buffer(p1)) == 25 * size_of_int()\n    assert sizeof(p1) == 25 * size_of_int()\n    #\n    p2 = from_buffer(BIntP, bytestring)\n    assert sizeof(p2) == size_of_ptr()\n    assert len(buffer(p2)) == size_of_int()  # first element only, by default\n\ndef test_memmove():\n    Short = new_primitive_type(\"short\")\n    ShortA = new_array_type(new_pointer_type(Short), None)\n    Char = new_primitive_type(\"char\")\n    CharA = new_array_type(new_pointer_type(Char), None)\n    p = newp(ShortA, [-1234, -2345, -3456, -4567, -5678])\n    memmove(p, p + 1, 4)\n    assert list(p) == [-2345, -3456, -3456, -4567, -5678]\n    p[2] = 999\n    memmove(p + 2, p, 6)\n    assert list(p) == [-2345, -3456, -2345, -3456, 999]\n    memmove(p + 4, newp(CharA, b\"\\x71\\x72\"), 2)\n    if sys.byteorder == 'little':\n        assert list(p) == [-2345, -3456, -2345, -3456, 0x7271]\n    else:\n        assert list(p) == [-2345, -3456, -2345, -3456, 0x7172]\n\ndef test_memmove_buffer():\n    import array\n    Short = new_primitive_type(\"short\")\n    ShortA = new_array_type(new_pointer_type(Short), None)\n    a = array.array('H', [10000, 20000, 30000])\n    p = newp(ShortA, 5)\n    memmove(p, a, 6)\n    assert list(p) == [10000, 20000, 30000, 0, 0]\n    memmove(p + 1, a, 6)\n    assert list(p) == [10000, 10000, 20000, 30000, 0]\n    b = array.array('h', [-1000, -2000, -3000])\n    memmove(b, a, 4)\n    assert b.tolist() == [10000, 20000, -3000]\n    assert a.tolist() == [10000, 20000, 30000]\n    p[0] = 999\n    p[1] = 998\n    p[2] = 997\n    p[3] = 996\n    p[4] = 995\n    memmove(b, p, 2)\n    assert b.tolist() == [999, 20000, -3000]\n    memmove(b, p + 2, 4)\n    assert b.tolist() == [997, 996, -3000]\n    p[2] = -p[2]\n    p[3] = -p[3]\n    memmove(b, p + 2, 6)\n    assert b.tolist() == [-997, -996, 995]\n\ndef test_memmove_readonly_readwrite():\n    SignedChar = new_primitive_type(\"signed char\")\n    SignedCharA = new_array_type(new_pointer_type(SignedChar), None)\n    p = newp(SignedCharA, 5)\n    memmove(p, b\"abcde\", 3)\n    assert list(p) == [ord(\"a\"), ord(\"b\"), ord(\"c\"), 0, 0]\n    memmove(p, bytearray(b\"ABCDE\"), 2)\n    assert list(p) == [ord(\"A\"), ord(\"B\"), ord(\"c\"), 0, 0]\n    pytest.raises((TypeError, BufferError), memmove, b\"abcde\", p, 3)\n    ba = bytearray(b\"xxxxx\")\n    memmove(dest=ba, src=p, n=3)\n    assert ba == bytearray(b\"ABcxx\")\n    memmove(ba, b\"EFGH\", 4)\n    assert ba == bytearray(b\"EFGHx\")\n\ndef test_memmove_sign_check():\n    SignedChar = new_primitive_type(\"signed char\")\n    SignedCharA = new_array_type(new_pointer_type(SignedChar), None)\n    p = newp(SignedCharA, 5)\n    pytest.raises(ValueError, memmove, p, p + 1, -1)   # not segfault\n\ndef test_memmove_bad_cdata():\n    BInt = new_primitive_type(\"int\")\n    p = cast(BInt, 42)\n    pytest.raises(TypeError, memmove, p, bytearray(b'a'), 1)\n    pytest.raises(TypeError, memmove, bytearray(b'a'), p, 1)\n\ndef test_dereference_null_ptr():\n    BInt = new_primitive_type(\"int\")\n    BIntPtr = new_pointer_type(BInt)\n    p = cast(BIntPtr, 0)\n    with pytest.raises(RuntimeError):\n        p[0]\n    with pytest.raises(RuntimeError):\n        p[0] = 42\n    with pytest.raises(RuntimeError):\n        p[42]\n    with pytest.raises(RuntimeError):\n        p[42] = -1\n\ndef test_mixup():\n    BStruct1 = new_struct_type(\"foo\")\n    BStruct2 = new_struct_type(\"foo\")   # <= same name as BStruct1\n    BStruct3 = new_struct_type(\"bar\")\n    BStruct1Ptr = new_pointer_type(BStruct1)\n    BStruct2Ptr = new_pointer_type(BStruct2)\n    BStruct3Ptr = new_pointer_type(BStruct3)\n    BStruct1PtrPtr = new_pointer_type(BStruct1Ptr)\n    BStruct2PtrPtr = new_pointer_type(BStruct2Ptr)\n    BStruct3PtrPtr = new_pointer_type(BStruct3Ptr)\n    pp1 = newp(BStruct1PtrPtr)\n    pp2 = newp(BStruct2PtrPtr)\n    pp3 = newp(BStruct3PtrPtr)\n    pp1[0] = pp1[0]\n    with pytest.raises(TypeError) as e:\n        pp3[0] = pp1[0]\n    assert str(e.value).startswith(\"initializer for ctype 'bar *' must be a \")\n    assert str(e.value).endswith(\", not cdata 'foo *'\")\n    with pytest.raises(TypeError) as e:\n        pp2[0] = pp1[0]\n    assert str(e.value) == (\"initializer for ctype 'foo *' appears indeed to \"\n                            \"be 'foo *', but the types are different (check \"\n                            \"that you are not e.g. mixing up different ffi \"\n                            \"instances)\")\n\ndef test_stdcall_function_type():\n    assert FFI_CDECL == FFI_DEFAULT_ABI\n    try:\n        stdcall = FFI_STDCALL\n    except NameError:\n        stdcall = FFI_DEFAULT_ABI\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False, stdcall)\n    if stdcall != FFI_DEFAULT_ABI:\n        assert repr(BFunc) == \"<ctype 'int(__stdcall *)(int, int)'>\"\n    else:\n        assert repr(BFunc) == \"<ctype 'int(*)(int, int)'>\"\n\ndef test_get_common_types():\n    d = {}\n    _get_common_types(d)\n    assert d['bool'] == '_Bool'\n\ndef test_unpack():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), 10)   # char[10]\n    p = newp(BArray, b\"abc\\x00def\")\n    p0 = p\n    assert unpack(p, 10) == b\"abc\\x00def\\x00\\x00\\x00\"\n    assert unpack(p+1, 5) == b\"bc\\x00de\"\n\n    for typename in [\"wchar_t\", \"char16_t\", \"char32_t\"]:\n        BWChar = new_primitive_type(typename)\n        BArray = new_array_type(new_pointer_type(BWChar), 10)   # wchar_t[10]\n        p = newp(BArray, u\"abc\\x00def\")\n        assert unpack(p, 10) == u\"abc\\x00def\\x00\\x00\\x00\"\n\n    for typename, samples in [\n            (\"uint8_t\",  [0, 2**8-1]),\n            (\"uint16_t\", [0, 2**16-1]),\n            (\"uint32_t\", [0, 2**32-1]),\n            (\"uint64_t\", [0, 2**64-1]),\n            (\"int8_t\",  [-2**7, 2**7-1]),\n            (\"int16_t\", [-2**15, 2**15-1]),\n            (\"int32_t\", [-2**31, 2**31-1]),\n            (\"int64_t\", [-2**63, 2**63-1]),\n            (\"_Bool\", [False, True]),\n            (\"float\", [0.0, 10.5]),\n            (\"double\", [12.34, 56.78]),\n            ]:\n        BItem = new_primitive_type(typename)\n        BArray = new_array_type(new_pointer_type(BItem), 10)\n        p = newp(BArray, samples)\n        result = unpack(p, len(samples))\n        assert result == samples\n        for i in range(len(samples)):\n            assert result[i] == p[i] and type(result[i]) is type(p[i])\n            assert (type(result[i]) is bool) == (type(samples[i]) is bool)\n    #\n    BInt = new_primitive_type(\"int\")\n    pytest.raises(TypeError, unpack, p)\n    pytest.raises(TypeError, unpack, b\"foobar\", 6)\n    pytest.raises(TypeError, unpack, cast(BInt, 42), 1)\n    #\n    BPtr = new_pointer_type(BInt)\n    random_ptr = cast(BPtr, -424344)\n    other_ptr = cast(BPtr, 54321)\n    BArray = new_array_type(new_pointer_type(BPtr), None)\n    lst = unpack(newp(BArray, [random_ptr, other_ptr]), 2)\n    assert lst == [random_ptr, other_ptr]\n    #\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    BFuncPtr = new_pointer_type(BFunc)\n    lst = unpack(newp(new_array_type(BFuncPtr, None), 2), 2)\n    assert len(lst) == 2\n    assert not lst[0] and not lst[1]\n    assert typeof(lst[0]) is BFunc\n    #\n    BStruct = new_struct_type(\"foo\")\n    BStructPtr = new_pointer_type(BStruct)\n    e = pytest.raises(ValueError, unpack, cast(BStructPtr, 42), 5)\n    assert str(e.value) == \"'foo *' points to items of unknown size\"\n    complete_struct_or_union(BStruct, [('a1', BInt, -1),\n                                       ('a2', BInt, -1)])\n    array_of_structs = newp(new_array_type(BStructPtr, None), [[4,5], [6,7]])\n    lst = unpack(array_of_structs, 2)\n    assert typeof(lst[0]) is BStruct\n    assert lst[0].a1 == 4 and lst[1].a2 == 7\n    #\n    pytest.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 0)\n    pytest.raises(RuntimeError, unpack, cast(new_pointer_type(BChar), 0), 10)\n    #\n    pytest.raises(ValueError, unpack, p0, -1)\n    pytest.raises(ValueError, unpack, p, -1)\n\ndef test_cdata_dir():\n    BInt = new_primitive_type(\"int\")\n    p = cast(BInt, 42)\n    check_dir(p, [])\n    p = newp(new_array_type(new_pointer_type(BInt), None), 5)\n    check_dir(p, [])\n    BStruct = new_struct_type(\"foo\")\n    p = cast(new_pointer_type(BStruct), 0)\n    check_dir(p, [])    # opaque\n    complete_struct_or_union(BStruct, [('a2', BInt, -1),\n                                       ('a1', BInt, -1)])\n    check_dir(p, ['a1', 'a2'])   # always sorted\n    p = newp(new_pointer_type(BStruct), None)\n    check_dir(p, ['a1', 'a2'])\n    check_dir(p[0], ['a1', 'a2'])\n    pp = newp(new_pointer_type(new_pointer_type(BStruct)), p)\n    check_dir(pp, [])\n    check_dir(pp[0], ['a1', 'a2'])\n    check_dir(pp[0][0], ['a1', 'a2'])\n\ndef test_char_pointer_conversion():\n    import warnings\n    assert __version__.startswith(\"1.\"), (\n        \"the warning will be an error if we ever release cffi 2.x\")\n    BCharP = new_pointer_type(new_primitive_type(\"char\"))\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    BVoidP = new_pointer_type(new_void_type())\n    BUCharP = new_pointer_type(new_primitive_type(\"unsigned char\"))\n    z1 = cast(BCharP, 0)\n    z2 = cast(BIntP, 0)\n    z3 = cast(BVoidP, 0)\n    z4 = cast(BUCharP, 0)\n    with warnings.catch_warnings(record=True) as w:\n        warnings.simplefilter(\"always\")\n        newp(new_pointer_type(BIntP), z1)    # warn\n        assert len(w) == 1\n        newp(new_pointer_type(BVoidP), z1)   # fine\n        assert len(w) == 1\n        newp(new_pointer_type(BCharP), z2)   # warn\n        assert len(w) == 2\n        newp(new_pointer_type(BVoidP), z2)   # fine\n        assert len(w) == 2\n        newp(new_pointer_type(BCharP), z3)   # fine\n        assert len(w) == 2\n        newp(new_pointer_type(BIntP), z3)    # fine\n        assert len(w) == 2\n        newp(new_pointer_type(BCharP), z4)   # fine (ignore signedness here)\n        assert len(w) == 2\n        newp(new_pointer_type(BUCharP), z1)  # fine (ignore signedness here)\n        assert len(w) == 2\n        newp(new_pointer_type(BUCharP), z3)  # fine\n        assert len(w) == 2\n    # check that the warnings are associated with lines in this file\n    assert w[1].lineno == w[0].lineno + 4\n\ndef test_primitive_comparison():\n    def assert_eq(a, b):\n        assert (a == b) is True\n        assert (b == a) is True\n        assert (a != b) is False\n        assert (b != a) is False\n        assert (a < b) is False\n        assert (a <= b) is True\n        assert (a > b) is False\n        assert (a >= b) is True\n        assert (b < a) is False\n        assert (b <= a) is True\n        assert (b > a) is False\n        assert (b >= a) is True\n        assert hash(a) == hash(b)\n    def assert_lt(a, b, check_hash=True):\n        assert (a == b) is False\n        assert (b == a) is False\n        assert (a != b) is True\n        assert (b != a) is True\n        assert (a < b) is True\n        assert (a <= b) is True\n        assert (a > b) is False\n        assert (a >= b) is False\n        assert (b < a) is False\n        assert (b <= a) is False\n        assert (b > a) is True\n        assert (b >= a) is True\n        if check_hash:\n            assert hash(a) != hash(b)    # (or at least, it is unlikely)\n    def assert_gt(a, b, check_hash=True):\n        assert_lt(b, a, check_hash)\n    def assert_ne(a, b):\n        assert (a == b) is False\n        assert (b == a) is False\n        assert (a != b) is True\n        assert (b != a) is True\n        if strict_compare:\n            with pytest.raises(TypeError): a < b\n            with pytest.raises(TypeError): a <= b\n            with pytest.raises(TypeError): a > b\n            with pytest.raises(TypeError): a >= b\n            with pytest.raises(TypeError): b < a\n            with pytest.raises(TypeError): b <= a\n            with pytest.raises(TypeError): b > a\n            with pytest.raises(TypeError): b >= a\n        elif a < b:\n            assert_lt(a, b)\n        else:\n            assert_lt(b, a)\n    assert_eq(5, 5)\n    assert_lt(3, 5)\n    assert_ne('5', 5)\n    #\n    t1 = new_primitive_type(\"char\")\n    t2 = new_primitive_type(\"int\")\n    t3 = new_primitive_type(\"unsigned char\")\n    t4 = new_primitive_type(\"unsigned int\")\n    t5 = new_primitive_type(\"float\")\n    t6 = new_primitive_type(\"double\")\n    assert_eq(cast(t1, 65), b'A')\n    assert_lt(cast(t1, 64), b'\\x99')\n    assert_gt(cast(t1, 200), b'A')\n    assert_ne(cast(t1, 65), 65)\n    assert_eq(cast(t2, -25), -25)\n    assert_lt(cast(t2, -25), -24)\n    assert_gt(cast(t2, -25), -26)\n    assert_eq(cast(t3, 65), 65)\n    assert_ne(cast(t3, 65), b'A')\n    assert_ne(cast(t3, 65), cast(t1, 65))\n    assert_gt(cast(t4, -1), -1, check_hash=False)\n    assert_gt(cast(t4, -1), cast(t2, -1), check_hash=False)\n    assert_gt(cast(t4, -1), 99999)\n    assert_eq(cast(t4, -1), 256 ** size_of_int() - 1)\n    assert_eq(cast(t5, 3.0), 3)\n    assert_eq(cast(t5, 3.5), 3.5)\n    assert_lt(cast(t5, 3.3), 3.3)   # imperfect rounding\n    assert_eq(cast(t6, 3.3), 3.3)\n    assert_eq(cast(t5, 3.5), cast(t6, 3.5))\n    assert_lt(cast(t5, 3.1), cast(t6, 3.1))   # imperfect rounding\n    assert_eq(cast(t5, 7.0), cast(t3, 7))\n    assert_lt(cast(t5, 3.1), 3.101)\n    assert_gt(cast(t5, 3.1), 3)\n\ndef test_explicit_release_new():\n    # release() on a ffi.new() object has no effect on CPython, but\n    # really releases memory on PyPy.  We can't test that effect\n    # though, because a released cdata is not marked.\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    p = newp(BIntP)\n    p[0] = 42\n    with pytest.raises(IndexError):\n        p[1]\n    release(p)\n    # here, reading p[0] might give garbage or segfault...\n    release(p)   # no effect\n    #\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('p', BIntP, -1)])\n    pstruct = newp(BStructP)\n    assert pstruct.p == cast(BIntP, 0)\n    release(pstruct)\n    # here, reading pstruct.p might give garbage or segfault...\n    release(pstruct)   # no effect\n\ndef test_explicit_release_new_contextmgr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    with newp(BIntP) as p:\n        p[0] = 42\n        assert p[0] == 42\n    # here, reading p[0] might give garbage or segfault...\n    release(p)   # no effect\n\ndef test_explicit_release_badtype():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    p = cast(BIntP, 12345)\n    pytest.raises(ValueError, release, p)\n    pytest.raises(ValueError, release, p)\n    BStruct = new_struct_type(\"struct foo\")\n    BStructP = new_pointer_type(BStruct)\n    complete_struct_or_union(BStruct, [('p', BIntP, -1)])\n    pstruct = newp(BStructP)\n    pytest.raises(ValueError, release, pstruct[0])\n\ndef test_explicit_release_badtype_contextmgr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    p = cast(BIntP, 12345)\n    with pytest.raises(ValueError):\n        with p:\n            pass\n    with pytest.raises(ValueError):\n        with p:\n            pass\n\ndef test_explicit_release_gc():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    seen = []\n    intp1 = newp(BIntP, 12345)\n    p1 = cast(BIntP, intp1)\n    p = gcp(p1, seen.append)\n    assert seen == []\n    release(p)\n    assert seen == [p1]\n    assert p1[0] == 12345\n    assert p[0] == 12345  # true so far, but might change to raise RuntimeError\n    release(p)   # no effect\n\ndef test_explicit_release_gc_contextmgr():\n    BIntP = new_pointer_type(new_primitive_type(\"int\"))\n    seen = []\n    intp1 = newp(BIntP, 12345)\n    p1 = cast(BIntP, intp1)\n    p = gcp(p1, seen.append)\n    with p:\n        assert p[0] == 12345\n        assert seen == []\n    assert seen == [p1]\n    assert p1[0] == 12345\n    assert p[0] == 12345  # true so far, but might change to raise RuntimeError\n    release(p)   # no effect\n\ndef test_explicit_release_from_buffer():\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p = from_buffer(BCharA, a)\n    assert p[2] == b\"z\"\n    assert repr(p) == \"<cdata 'char[]' buffer len 3 from 'bytearray' object>\"\n    release(p)\n    assert p[2] == b\"z\"  # true so far, but might change to raise RuntimeError\n    assert repr(p) == \"<cdata 'char[]' buffer RELEASED>\"\n    release(p)   # no effect\n\ndef test_explicit_release_from_buffer_contextmgr():\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    p = from_buffer(BCharA, a)\n    with p:\n        assert p[2] == b\"z\"\n    assert p[2] == b\"z\"  # true so far, but might change to raise RuntimeError\n    assert repr(p) == \"<cdata 'char[]' buffer RELEASED>\"\n    release(p)   # no effect\n\ndef test_explicit_release_bytearray_on_cpython():\n    if '__pypy__' in sys.builtin_module_names:\n        pytest.skip(\"pypy's bytearray are never locked\")\n    a = bytearray(b\"xyz\")\n    BChar = new_primitive_type(\"char\")\n    BCharP = new_pointer_type(BChar)\n    BCharA = new_array_type(BCharP, None)\n    a += b't' * 10\n    p = from_buffer(BCharA, a)\n    with pytest.raises(BufferError):\n        a += b'u' * 100\n    release(p)\n    a += b'v' * 100\n    release(p)   # no effect\n    a += b'w' * 1000\n    assert a == bytearray(b\"xyz\" + b't' * 10 + b'v' * 100 + b'w' * 1000)\n\ndef test_int_doesnt_give_bool():\n    BBool = new_primitive_type(\"_Bool\")\n    x = int(cast(BBool, 42))\n    assert type(x) is int and x == 1\n    x = long(cast(BBool, 42))\n    assert type(x) is long and x == 1\n    with pytest.raises(TypeError):\n        float(cast(BBool, 42))\n    with pytest.raises(TypeError):\n        complex(cast(BBool, 42))\n\ndef test_cannot_call_null_function_pointer():\n    BInt = new_primitive_type(\"int\")\n    BFunc = new_function_type((BInt, BInt), BInt, False)\n    f = cast(BFunc, 0)\n    with pytest.raises(RuntimeError):\n        f(40, 2)\n\ndef test_huge_structure():\n    BChar = new_primitive_type(\"char\")\n    BArray = new_array_type(new_pointer_type(BChar), sys.maxsize)\n    assert sizeof(BArray) == sys.maxsize\n    BStruct = new_struct_type(\"struct foo\")\n    complete_struct_or_union(BStruct, [('a1', BArray, -1)])\n    assert sizeof(BStruct) == sys.maxsize\n\ndef test_get_types():\n    import _cffi_backend\n    CData, CType = _get_types()\n    assert CData is _cffi_backend._CDataBase\n    assert CType is _cffi_backend.CType\n\ndef test_type_available_with_correct_names():\n    import _cffi_backend\n    check_names = [\n        'CType',\n        'CField',\n        'CLibrary',\n        '_CDataBase',\n        'FFI',\n        'Lib',\n        'buffer',\n    ]\n    if '__pypy__' in sys.builtin_module_names:\n        check_names += [\n            '__CData_iterator',\n            '__FFIGlobSupport',\n            '__FFIAllocator',\n            '__FFIFunctionWrapper',\n        ]\n    else:\n        check_names += [\n            '__CDataOwn',\n            '__CDataOwnGC',\n            '__CDataFromBuf',\n            '__CDataGCP',\n            '__CData_iterator',\n            '__FFIGlobSupport',\n        ]\n    for name in check_names:\n        tp = getattr(_cffi_backend, name)\n        assert isinstance(tp, type)\n        assert (tp.__module__, tp.__name__) == ('_cffi_backend', name)\n\ndef test_unaligned_types():\n    BByteArray = new_array_type(\n        new_pointer_type(new_primitive_type(\"unsigned char\")), None)\n    pbuf = newp(BByteArray, 40)\n    buf = buffer(pbuf)\n    #\n    for name in ['short', 'int', 'long', 'long long', 'float', 'double',\n                 'float _Complex', 'double _Complex']:\n        p = new_primitive_type(name)\n        if name.endswith(' _Complex'):\n            num = cast(p, 1.23 - 4.56j)\n        else:\n            num = cast(p, 0x0123456789abcdef)\n        size = sizeof(p)\n        buf[0:40] = b\"\\x00\" * 40\n        pbuf1 = cast(new_pointer_type(p), pbuf + 1)\n        pbuf1[0] = num\n        assert pbuf1[0] == num\n        assert buf[0] == b'\\x00'\n        assert buf[1 + size] == b'\\x00'\n", "src/cffi/cffi_opcode.py": "from .error import VerificationError\n\nclass CffiOp(object):\n    def __init__(self, op, arg):\n        self.op = op\n        self.arg = arg\n\n    def as_c_expr(self):\n        if self.op is None:\n            assert isinstance(self.arg, str)\n            return '(_cffi_opcode_t)(%s)' % (self.arg,)\n        classname = CLASS_NAME[self.op]\n        return '_CFFI_OP(_CFFI_OP_%s, %s)' % (classname, self.arg)\n\n    def as_python_bytes(self):\n        if self.op is None and self.arg.isdigit():\n            value = int(self.arg)     # non-negative: '-' not in self.arg\n            if value >= 2**31:\n                raise OverflowError(\"cannot emit %r: limited to 2**31-1\"\n                                    % (self.arg,))\n            return format_four_bytes(value)\n        if isinstance(self.arg, str):\n            raise VerificationError(\"cannot emit to Python: %r\" % (self.arg,))\n        return format_four_bytes((self.arg << 8) | self.op)\n\n    def __str__(self):\n        classname = CLASS_NAME.get(self.op, self.op)\n        return '(%s %s)' % (classname, self.arg)\n\ndef format_four_bytes(num):\n    return '\\\\x%02X\\\\x%02X\\\\x%02X\\\\x%02X' % (\n        (num >> 24) & 0xFF,\n        (num >> 16) & 0xFF,\n        (num >>  8) & 0xFF,\n        (num      ) & 0xFF)\n\nOP_PRIMITIVE       = 1\nOP_POINTER         = 3\nOP_ARRAY           = 5\nOP_OPEN_ARRAY      = 7\nOP_STRUCT_UNION    = 9\nOP_ENUM            = 11\nOP_FUNCTION        = 13\nOP_FUNCTION_END    = 15\nOP_NOOP            = 17\nOP_BITFIELD        = 19\nOP_TYPENAME        = 21\nOP_CPYTHON_BLTN_V  = 23   # varargs\nOP_CPYTHON_BLTN_N  = 25   # noargs\nOP_CPYTHON_BLTN_O  = 27   # O  (i.e. a single arg)\nOP_CONSTANT        = 29\nOP_CONSTANT_INT    = 31\nOP_GLOBAL_VAR      = 33\nOP_DLOPEN_FUNC     = 35\nOP_DLOPEN_CONST    = 37\nOP_GLOBAL_VAR_F    = 39\nOP_EXTERN_PYTHON   = 41\n\nPRIM_VOID          = 0\nPRIM_BOOL          = 1\nPRIM_CHAR          = 2\nPRIM_SCHAR         = 3\nPRIM_UCHAR         = 4\nPRIM_SHORT         = 5\nPRIM_USHORT        = 6\nPRIM_INT           = 7\nPRIM_UINT          = 8\nPRIM_LONG          = 9\nPRIM_ULONG         = 10\nPRIM_LONGLONG      = 11\nPRIM_ULONGLONG     = 12\nPRIM_FLOAT         = 13\nPRIM_DOUBLE        = 14\nPRIM_LONGDOUBLE    = 15\n\nPRIM_WCHAR         = 16\nPRIM_INT8          = 17\nPRIM_UINT8         = 18\nPRIM_INT16         = 19\nPRIM_UINT16        = 20\nPRIM_INT32         = 21\nPRIM_UINT32        = 22\nPRIM_INT64         = 23\nPRIM_UINT64        = 24\nPRIM_INTPTR        = 25\nPRIM_UINTPTR       = 26\nPRIM_PTRDIFF       = 27\nPRIM_SIZE          = 28\nPRIM_SSIZE         = 29\nPRIM_INT_LEAST8    = 30\nPRIM_UINT_LEAST8   = 31\nPRIM_INT_LEAST16   = 32\nPRIM_UINT_LEAST16  = 33\nPRIM_INT_LEAST32   = 34\nPRIM_UINT_LEAST32  = 35\nPRIM_INT_LEAST64   = 36\nPRIM_UINT_LEAST64  = 37\nPRIM_INT_FAST8     = 38\nPRIM_UINT_FAST8    = 39\nPRIM_INT_FAST16    = 40\nPRIM_UINT_FAST16   = 41\nPRIM_INT_FAST32    = 42\nPRIM_UINT_FAST32   = 43\nPRIM_INT_FAST64    = 44\nPRIM_UINT_FAST64   = 45\nPRIM_INTMAX        = 46\nPRIM_UINTMAX       = 47\nPRIM_FLOATCOMPLEX  = 48\nPRIM_DOUBLECOMPLEX = 49\nPRIM_CHAR16        = 50\nPRIM_CHAR32        = 51\n\n_NUM_PRIM          = 52\n_UNKNOWN_PRIM          = -1\n_UNKNOWN_FLOAT_PRIM    = -2\n_UNKNOWN_LONG_DOUBLE   = -3\n\n_IO_FILE_STRUCT        = -1\n\nPRIMITIVE_TO_INDEX = {\n    'char':               PRIM_CHAR,\n    'short':              PRIM_SHORT,\n    'int':                PRIM_INT,\n    'long':               PRIM_LONG,\n    'long long':          PRIM_LONGLONG,\n    'signed char':        PRIM_SCHAR,\n    'unsigned char':      PRIM_UCHAR,\n    'unsigned short':     PRIM_USHORT,\n    'unsigned int':       PRIM_UINT,\n    'unsigned long':      PRIM_ULONG,\n    'unsigned long long': PRIM_ULONGLONG,\n    'float':              PRIM_FLOAT,\n    'double':             PRIM_DOUBLE,\n    'long double':        PRIM_LONGDOUBLE,\n    '_cffi_float_complex_t': PRIM_FLOATCOMPLEX,\n    '_cffi_double_complex_t': PRIM_DOUBLECOMPLEX,\n    '_Bool':              PRIM_BOOL,\n    'wchar_t':            PRIM_WCHAR,\n    'char16_t':           PRIM_CHAR16,\n    'char32_t':           PRIM_CHAR32,\n    'int8_t':             PRIM_INT8,\n    'uint8_t':            PRIM_UINT8,\n    'int16_t':            PRIM_INT16,\n    'uint16_t':           PRIM_UINT16,\n    'int32_t':            PRIM_INT32,\n    'uint32_t':           PRIM_UINT32,\n    'int64_t':            PRIM_INT64,\n    'uint64_t':           PRIM_UINT64,\n    'intptr_t':           PRIM_INTPTR,\n    'uintptr_t':          PRIM_UINTPTR,\n    'ptrdiff_t':          PRIM_PTRDIFF,\n    'size_t':             PRIM_SIZE,\n    'ssize_t':            PRIM_SSIZE,\n    'int_least8_t':       PRIM_INT_LEAST8,\n    'uint_least8_t':      PRIM_UINT_LEAST8,\n    'int_least16_t':      PRIM_INT_LEAST16,\n    'uint_least16_t':     PRIM_UINT_LEAST16,\n    'int_least32_t':      PRIM_INT_LEAST32,\n    'uint_least32_t':     PRIM_UINT_LEAST32,\n    'int_least64_t':      PRIM_INT_LEAST64,\n    'uint_least64_t':     PRIM_UINT_LEAST64,\n    'int_fast8_t':        PRIM_INT_FAST8,\n    'uint_fast8_t':       PRIM_UINT_FAST8,\n    'int_fast16_t':       PRIM_INT_FAST16,\n    'uint_fast16_t':      PRIM_UINT_FAST16,\n    'int_fast32_t':       PRIM_INT_FAST32,\n    'uint_fast32_t':      PRIM_UINT_FAST32,\n    'int_fast64_t':       PRIM_INT_FAST64,\n    'uint_fast64_t':      PRIM_UINT_FAST64,\n    'intmax_t':           PRIM_INTMAX,\n    'uintmax_t':          PRIM_UINTMAX,\n    }\n\nF_UNION         = 0x01\nF_CHECK_FIELDS  = 0x02\nF_PACKED        = 0x04\nF_EXTERNAL      = 0x08\nF_OPAQUE        = 0x10\n\nG_FLAGS = dict([('_CFFI_' + _key, globals()[_key])\n                for _key in ['F_UNION', 'F_CHECK_FIELDS', 'F_PACKED',\n                             'F_EXTERNAL', 'F_OPAQUE']])\n\nCLASS_NAME = {}\nfor _name, _value in list(globals().items()):\n    if _name.startswith('OP_') and isinstance(_value, int):\n        CLASS_NAME[_value] = _name[3:]\n", "src/cffi/verifier.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys, os, binascii, shutil, io\nfrom . import __version_verifier_modules__\nfrom . import ffiplatform\nfrom .error import VerificationError\n\nif sys.version_info >= (3, 3):\n    import importlib.machinery\n    def _extension_suffixes():\n        return importlib.machinery.EXTENSION_SUFFIXES[:]\nelse:\n    import imp\n    def _extension_suffixes():\n        return [suffix for suffix, _, type in imp.get_suffixes()\n                if type == imp.C_EXTENSION]\n\n\nif sys.version_info >= (3,):\n    NativeIO = io.StringIO\nelse:\n    class NativeIO(io.BytesIO):\n        def write(self, s):\n            if isinstance(s, unicode):\n                s = s.encode('ascii')\n            super(NativeIO, self).write(s)\n\n\nclass Verifier(object):\n\n    def __init__(self, ffi, preamble, tmpdir=None, modulename=None,\n                 ext_package=None, tag='', force_generic_engine=False,\n                 source_extension='.c', flags=None, relative_to=None, **kwds):\n        if ffi._parser._uses_new_feature:\n            raise VerificationError(\n                \"feature not supported with ffi.verify(), but only \"\n                \"with ffi.set_source(): %s\" % (ffi._parser._uses_new_feature,))\n        self.ffi = ffi\n        self.preamble = preamble\n        if not modulename:\n            flattened_kwds = ffiplatform.flatten(kwds)\n        vengine_class = _locate_engine_class(ffi, force_generic_engine)\n        self._vengine = vengine_class(self)\n        self._vengine.patch_extension_kwds(kwds)\n        self.flags = flags\n        self.kwds = self.make_relative_to(kwds, relative_to)\n        #\n        if modulename:\n            if tag:\n                raise TypeError(\"can't specify both 'modulename' and 'tag'\")\n        else:\n            key = '\\x00'.join(['%d.%d' % sys.version_info[:2],\n                               __version_verifier_modules__,\n                               preamble, flattened_kwds] +\n                              ffi._cdefsources)\n            if sys.version_info >= (3,):\n                key = key.encode('utf-8')\n            k1 = hex(binascii.crc32(key[0::2]) & 0xffffffff)\n            k1 = k1.lstrip('0x').rstrip('L')\n            k2 = hex(binascii.crc32(key[1::2]) & 0xffffffff)\n            k2 = k2.lstrip('0').rstrip('L')\n            modulename = '_cffi_%s_%s%s%s' % (tag, self._vengine._class_key,\n                                              k1, k2)\n        suffix = _get_so_suffixes()[0]\n        self.tmpdir = tmpdir or _caller_dir_pycache()\n        self.sourcefilename = os.path.join(self.tmpdir, modulename + source_extension)\n        self.modulefilename = os.path.join(self.tmpdir, modulename + suffix)\n        self.ext_package = ext_package\n        self._has_source = False\n        self._has_module = False\n\n    def write_source(self, file=None):\n        \"\"\"Write the C source code.  It is produced in 'self.sourcefilename',\n        which can be tweaked beforehand.\"\"\"\n        with self.ffi._lock:\n            if self._has_source and file is None:\n                raise VerificationError(\n                    \"source code already written\")\n            self._write_source(file)\n\n    def compile_module(self):\n        \"\"\"Write the C source code (if not done already) and compile it.\n        This produces a dynamic link library in 'self.modulefilename'.\"\"\"\n        with self.ffi._lock:\n            if self._has_module:\n                raise VerificationError(\"module already compiled\")\n            if not self._has_source:\n                self._write_source()\n            self._compile_module()\n\n    def load_library(self):\n        \"\"\"Get a C module from this Verifier instance.\n        Returns an instance of a FFILibrary class that behaves like the\n        objects returned by ffi.dlopen(), but that delegates all\n        operations to the C module.  If necessary, the C code is written\n        and compiled first.\n        \"\"\"\n        with self.ffi._lock:\n            if not self._has_module:\n                self._locate_module()\n                if not self._has_module:\n                    if not self._has_source:\n                        self._write_source()\n                    self._compile_module()\n            return self._load_library()\n\n    def get_module_name(self):\n        basename = os.path.basename(self.modulefilename)\n        # kill both the .so extension and the other .'s, as introduced\n        # by Python 3: 'basename.cpython-33m.so'\n        basename = basename.split('.', 1)[0]\n        # and the _d added in Python 2 debug builds --- but try to be\n        # conservative and not kill a legitimate _d\n        if basename.endswith('_d') and hasattr(sys, 'gettotalrefcount'):\n            basename = basename[:-2]\n        return basename\n\n    def get_extension(self):\n        if not self._has_source:\n            with self.ffi._lock:\n                if not self._has_source:\n                    self._write_source()\n        sourcename = ffiplatform.maybe_relative_path(self.sourcefilename)\n        modname = self.get_module_name()\n        return ffiplatform.get_extension(sourcename, modname, **self.kwds)\n\n    def generates_python_module(self):\n        return self._vengine._gen_python_module\n\n    def make_relative_to(self, kwds, relative_to):\n        if relative_to and os.path.dirname(relative_to):\n            dirname = os.path.dirname(relative_to)\n            kwds = kwds.copy()\n            for key in ffiplatform.LIST_OF_FILE_NAMES:\n                if key in kwds:\n                    lst = kwds[key]\n                    if not isinstance(lst, (list, tuple)):\n                        raise TypeError(\"keyword '%s' should be a list or tuple\"\n                                        % (key,))\n                    lst = [os.path.join(dirname, fn) for fn in lst]\n                    kwds[key] = lst\n        return kwds\n\n    # ----------\n\n    def _locate_module(self):\n        if not os.path.isfile(self.modulefilename):\n            if self.ext_package:\n                try:\n                    pkg = __import__(self.ext_package, None, None, ['__doc__'])\n                except ImportError:\n                    return      # cannot import the package itself, give up\n                    # (e.g. it might be called differently before installation)\n                path = pkg.__path__\n            else:\n                path = None\n            filename = self._vengine.find_module(self.get_module_name(), path,\n                                                 _get_so_suffixes())\n            if filename is None:\n                return\n            self.modulefilename = filename\n        self._vengine.collect_types()\n        self._has_module = True\n\n    def _write_source_to(self, file):\n        self._vengine._f = file\n        try:\n            self._vengine.write_source_to_f()\n        finally:\n            del self._vengine._f\n\n    def _write_source(self, file=None):\n        if file is not None:\n            self._write_source_to(file)\n        else:\n            # Write our source file to an in memory file.\n            f = NativeIO()\n            self._write_source_to(f)\n            source_data = f.getvalue()\n\n            # Determine if this matches the current file\n            if os.path.exists(self.sourcefilename):\n                with open(self.sourcefilename, \"r\") as fp:\n                    needs_written = not (fp.read() == source_data)\n            else:\n                needs_written = True\n\n            # Actually write the file out if it doesn't match\n            if needs_written:\n                _ensure_dir(self.sourcefilename)\n                with open(self.sourcefilename, \"w\") as fp:\n                    fp.write(source_data)\n\n            # Set this flag\n            self._has_source = True\n\n    def _compile_module(self):\n        # compile this C source\n        tmpdir = os.path.dirname(self.sourcefilename)\n        outputfilename = ffiplatform.compile(tmpdir, self.get_extension())\n        try:\n            same = ffiplatform.samefile(outputfilename, self.modulefilename)\n        except OSError:\n            same = False\n        if not same:\n            _ensure_dir(self.modulefilename)\n            shutil.move(outputfilename, self.modulefilename)\n        self._has_module = True\n\n    def _load_library(self):\n        assert self._has_module\n        if self.flags is not None:\n            return self._vengine.load_library(self.flags)\n        else:\n            return self._vengine.load_library()\n\n# ____________________________________________________________\n\n_FORCE_GENERIC_ENGINE = False      # for tests\n\ndef _locate_engine_class(ffi, force_generic_engine):\n    if _FORCE_GENERIC_ENGINE:\n        force_generic_engine = True\n    if not force_generic_engine:\n        if '__pypy__' in sys.builtin_module_names:\n            force_generic_engine = True\n        else:\n            try:\n                import _cffi_backend\n            except ImportError:\n                _cffi_backend = '?'\n            if ffi._backend is not _cffi_backend:\n                force_generic_engine = True\n    if force_generic_engine:\n        from . import vengine_gen\n        return vengine_gen.VGenericEngine\n    else:\n        from . import vengine_cpy\n        return vengine_cpy.VCPythonEngine\n\n# ____________________________________________________________\n\n_TMPDIR = None\n\ndef _caller_dir_pycache():\n    if _TMPDIR:\n        return _TMPDIR\n    result = os.environ.get('CFFI_TMPDIR')\n    if result:\n        return result\n    filename = sys._getframe(2).f_code.co_filename\n    return os.path.abspath(os.path.join(os.path.dirname(filename),\n                           '__pycache__'))\n\ndef set_tmpdir(dirname):\n    \"\"\"Set the temporary directory to use instead of __pycache__.\"\"\"\n    global _TMPDIR\n    _TMPDIR = dirname\n\ndef cleanup_tmpdir(tmpdir=None, keep_so=False):\n    \"\"\"Clean up the temporary directory by removing all files in it\n    called `_cffi_*.{c,so}` as well as the `build` subdirectory.\"\"\"\n    tmpdir = tmpdir or _caller_dir_pycache()\n    try:\n        filelist = os.listdir(tmpdir)\n    except OSError:\n        return\n    if keep_so:\n        suffix = '.c'   # only remove .c files\n    else:\n        suffix = _get_so_suffixes()[0].lower()\n    for fn in filelist:\n        if fn.lower().startswith('_cffi_') and (\n                fn.lower().endswith(suffix) or fn.lower().endswith('.c')):\n            try:\n                os.unlink(os.path.join(tmpdir, fn))\n            except OSError:\n                pass\n    clean_dir = [os.path.join(tmpdir, 'build')]\n    for dir in clean_dir:\n        try:\n            for fn in os.listdir(dir):\n                fn = os.path.join(dir, fn)\n                if os.path.isdir(fn):\n                    clean_dir.append(fn)\n                else:\n                    os.unlink(fn)\n        except OSError:\n            pass\n\ndef _get_so_suffixes():\n    suffixes = _extension_suffixes()\n    if not suffixes:\n        # bah, no C_EXTENSION available.  Occurs on pypy without cpyext\n        if sys.platform == 'win32':\n            suffixes = [\".pyd\"]\n        else:\n            suffixes = [\".so\"]\n\n    return suffixes\n\ndef _ensure_dir(filename):\n    dirname = os.path.dirname(filename)\n    if dirname and not os.path.isdir(dirname):\n        os.makedirs(dirname)\n", "src/cffi/model.py": "import types\nimport weakref\n\nfrom .lock import allocate_lock\nfrom .error import CDefError, VerificationError, VerificationMissing\n\n# type qualifiers\nQ_CONST    = 0x01\nQ_RESTRICT = 0x02\nQ_VOLATILE = 0x04\n\ndef qualify(quals, replace_with):\n    if quals & Q_CONST:\n        replace_with = ' const ' + replace_with.lstrip()\n    if quals & Q_VOLATILE:\n        replace_with = ' volatile ' + replace_with.lstrip()\n    if quals & Q_RESTRICT:\n        # It seems that __restrict is supported by gcc and msvc.\n        # If you hit some different compiler, add a #define in\n        # _cffi_include.h for it (and in its copies, documented there)\n        replace_with = ' __restrict ' + replace_with.lstrip()\n    return replace_with\n\n\nclass BaseTypeByIdentity(object):\n    is_array_type = False\n    is_raw_function = False\n\n    def get_c_name(self, replace_with='', context='a C file', quals=0):\n        result = self.c_name_with_marker\n        assert result.count('&') == 1\n        # some logic duplication with ffi.getctype()... :-(\n        replace_with = replace_with.strip()\n        if replace_with:\n            if replace_with.startswith('*') and '&[' in result:\n                replace_with = '(%s)' % replace_with\n            elif not replace_with[0] in '[(':\n                replace_with = ' ' + replace_with\n        replace_with = qualify(quals, replace_with)\n        result = result.replace('&', replace_with)\n        if '$' in result:\n            raise VerificationError(\n                \"cannot generate '%s' in %s: unknown type name\"\n                % (self._get_c_name(), context))\n        return result\n\n    def _get_c_name(self):\n        return self.c_name_with_marker.replace('&', '')\n\n    def has_c_name(self):\n        return '$' not in self._get_c_name()\n\n    def is_integer_type(self):\n        return False\n\n    def get_cached_btype(self, ffi, finishlist, can_delay=False):\n        try:\n            BType = ffi._cached_btypes[self]\n        except KeyError:\n            BType = self.build_backend_type(ffi, finishlist)\n            BType2 = ffi._cached_btypes.setdefault(self, BType)\n            assert BType2 is BType\n        return BType\n\n    def __repr__(self):\n        return '<%s>' % (self._get_c_name(),)\n\n    def _get_items(self):\n        return [(name, getattr(self, name)) for name in self._attrs_]\n\n\nclass BaseType(BaseTypeByIdentity):\n\n    def __eq__(self, other):\n        return (self.__class__ == other.__class__ and\n                self._get_items() == other._get_items())\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((self.__class__, tuple(self._get_items())))\n\n\nclass VoidType(BaseType):\n    _attrs_ = ()\n\n    def __init__(self):\n        self.c_name_with_marker = 'void&'\n\n    def build_backend_type(self, ffi, finishlist):\n        return global_cache(self, ffi, 'new_void_type')\n\nvoid_type = VoidType()\n\n\nclass BasePrimitiveType(BaseType):\n    def is_complex_type(self):\n        return False\n\n\nclass PrimitiveType(BasePrimitiveType):\n    _attrs_ = ('name',)\n\n    ALL_PRIMITIVE_TYPES = {\n        'char':               'c',\n        'short':              'i',\n        'int':                'i',\n        'long':               'i',\n        'long long':          'i',\n        'signed char':        'i',\n        'unsigned char':      'i',\n        'unsigned short':     'i',\n        'unsigned int':       'i',\n        'unsigned long':      'i',\n        'unsigned long long': 'i',\n        'float':              'f',\n        'double':             'f',\n        'long double':        'f',\n        '_cffi_float_complex_t': 'j',\n        '_cffi_double_complex_t': 'j',\n        '_Bool':              'i',\n        # the following types are not primitive in the C sense\n        'wchar_t':            'c',\n        'char16_t':           'c',\n        'char32_t':           'c',\n        'int8_t':             'i',\n        'uint8_t':            'i',\n        'int16_t':            'i',\n        'uint16_t':           'i',\n        'int32_t':            'i',\n        'uint32_t':           'i',\n        'int64_t':            'i',\n        'uint64_t':           'i',\n        'int_least8_t':       'i',\n        'uint_least8_t':      'i',\n        'int_least16_t':      'i',\n        'uint_least16_t':     'i',\n        'int_least32_t':      'i',\n        'uint_least32_t':     'i',\n        'int_least64_t':      'i',\n        'uint_least64_t':     'i',\n        'int_fast8_t':        'i',\n        'uint_fast8_t':       'i',\n        'int_fast16_t':       'i',\n        'uint_fast16_t':      'i',\n        'int_fast32_t':       'i',\n        'uint_fast32_t':      'i',\n        'int_fast64_t':       'i',\n        'uint_fast64_t':      'i',\n        'intptr_t':           'i',\n        'uintptr_t':          'i',\n        'intmax_t':           'i',\n        'uintmax_t':          'i',\n        'ptrdiff_t':          'i',\n        'size_t':             'i',\n        'ssize_t':            'i',\n        }\n\n    def __init__(self, name):\n        assert name in self.ALL_PRIMITIVE_TYPES\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n    def is_char_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'c'\n    def is_integer_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'i'\n    def is_float_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'f'\n    def is_complex_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'j'\n\n    def build_backend_type(self, ffi, finishlist):\n        return global_cache(self, ffi, 'new_primitive_type', self.name)\n\n\nclass UnknownIntegerType(BasePrimitiveType):\n    _attrs_ = ('name',)\n\n    def __init__(self, name):\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n    def is_integer_type(self):\n        return True\n\n    def build_backend_type(self, ffi, finishlist):\n        raise NotImplementedError(\"integer type '%s' can only be used after \"\n                                  \"compilation\" % self.name)\n\nclass UnknownFloatType(BasePrimitiveType):\n    _attrs_ = ('name', )\n\n    def __init__(self, name):\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n    def build_backend_type(self, ffi, finishlist):\n        raise NotImplementedError(\"float type '%s' can only be used after \"\n                                  \"compilation\" % self.name)\n\n\nclass BaseFunctionType(BaseType):\n    _attrs_ = ('args', 'result', 'ellipsis', 'abi')\n\n    def __init__(self, args, result, ellipsis, abi=None):\n        self.args = args\n        self.result = result\n        self.ellipsis = ellipsis\n        self.abi = abi\n        #\n        reprargs = [arg._get_c_name() for arg in self.args]\n        if self.ellipsis:\n            reprargs.append('...')\n        reprargs = reprargs or ['void']\n        replace_with = self._base_pattern % (', '.join(reprargs),)\n        if abi is not None:\n            replace_with = replace_with[:1] + abi + ' ' + replace_with[1:]\n        self.c_name_with_marker = (\n            self.result.c_name_with_marker.replace('&', replace_with))\n\n\nclass RawFunctionType(BaseFunctionType):\n    # Corresponds to a C type like 'int(int)', which is the C type of\n    # a function, but not a pointer-to-function.  The backend has no\n    # notion of such a type; it's used temporarily by parsing.\n    _base_pattern = '(&)(%s)'\n    is_raw_function = True\n\n    def build_backend_type(self, ffi, finishlist):\n        raise CDefError(\"cannot render the type %r: it is a function \"\n                        \"type, not a pointer-to-function type\" % (self,))\n\n    def as_function_pointer(self):\n        return FunctionPtrType(self.args, self.result, self.ellipsis, self.abi)\n\n\nclass FunctionPtrType(BaseFunctionType):\n    _base_pattern = '(*&)(%s)'\n\n    def build_backend_type(self, ffi, finishlist):\n        result = self.result.get_cached_btype(ffi, finishlist)\n        args = []\n        for tp in self.args:\n            args.append(tp.get_cached_btype(ffi, finishlist))\n        abi_args = ()\n        if self.abi == \"__stdcall\":\n            if not self.ellipsis:    # __stdcall ignored for variadic funcs\n                try:\n                    abi_args = (ffi._backend.FFI_STDCALL,)\n                except AttributeError:\n                    pass\n        return global_cache(self, ffi, 'new_function_type',\n                            tuple(args), result, self.ellipsis, *abi_args)\n\n    def as_raw_function(self):\n        return RawFunctionType(self.args, self.result, self.ellipsis, self.abi)\n\n\nclass PointerType(BaseType):\n    _attrs_ = ('totype', 'quals')\n\n    def __init__(self, totype, quals=0):\n        self.totype = totype\n        self.quals = quals\n        extra = \" *&\"\n        if totype.is_array_type:\n            extra = \"(%s)\" % (extra.lstrip(),)\n        extra = qualify(quals, extra)\n        self.c_name_with_marker = totype.c_name_with_marker.replace('&', extra)\n\n    def build_backend_type(self, ffi, finishlist):\n        BItem = self.totype.get_cached_btype(ffi, finishlist, can_delay=True)\n        return global_cache(self, ffi, 'new_pointer_type', BItem)\n\nvoidp_type = PointerType(void_type)\n\ndef ConstPointerType(totype):\n    return PointerType(totype, Q_CONST)\n\nconst_voidp_type = ConstPointerType(void_type)\n\n\nclass NamedPointerType(PointerType):\n    _attrs_ = ('totype', 'name')\n\n    def __init__(self, totype, name, quals=0):\n        PointerType.__init__(self, totype, quals)\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n\nclass ArrayType(BaseType):\n    _attrs_ = ('item', 'length')\n    is_array_type = True\n\n    def __init__(self, item, length):\n        self.item = item\n        self.length = length\n        #\n        if length is None:\n            brackets = '&[]'\n        elif length == '...':\n            brackets = '&[/*...*/]'\n        else:\n            brackets = '&[%s]' % length\n        self.c_name_with_marker = (\n            self.item.c_name_with_marker.replace('&', brackets))\n\n    def length_is_unknown(self):\n        return isinstance(self.length, str)\n\n    def resolve_length(self, newlength):\n        return ArrayType(self.item, newlength)\n\n    def build_backend_type(self, ffi, finishlist):\n        if self.length_is_unknown():\n            raise CDefError(\"cannot render the type %r: unknown length\" %\n                            (self,))\n        self.item.get_cached_btype(ffi, finishlist)   # force the item BType\n        BPtrItem = PointerType(self.item).get_cached_btype(ffi, finishlist)\n        return global_cache(self, ffi, 'new_array_type', BPtrItem, self.length)\n\nchar_array_type = ArrayType(PrimitiveType('char'), None)\n\n\nclass StructOrUnionOrEnum(BaseTypeByIdentity):\n    _attrs_ = ('name',)\n    forcename = None\n\n    def build_c_name_with_marker(self):\n        name = self.forcename or '%s %s' % (self.kind, self.name)\n        self.c_name_with_marker = name + '&'\n\n    def force_the_name(self, forcename):\n        self.forcename = forcename\n        self.build_c_name_with_marker()\n\n    def get_official_name(self):\n        assert self.c_name_with_marker.endswith('&')\n        return self.c_name_with_marker[:-1]\n\n\nclass StructOrUnion(StructOrUnionOrEnum):\n    fixedlayout = None\n    completed = 0\n    partial = False\n    packed = 0\n\n    def __init__(self, name, fldnames, fldtypes, fldbitsize, fldquals=None):\n        self.name = name\n        self.fldnames = fldnames\n        self.fldtypes = fldtypes\n        self.fldbitsize = fldbitsize\n        self.fldquals = fldquals\n        self.build_c_name_with_marker()\n\n    def anonymous_struct_fields(self):\n        if self.fldtypes is not None:\n            for name, type in zip(self.fldnames, self.fldtypes):\n                if name == '' and isinstance(type, StructOrUnion):\n                    yield type\n\n    def enumfields(self, expand_anonymous_struct_union=True):\n        fldquals = self.fldquals\n        if fldquals is None:\n            fldquals = (0,) * len(self.fldnames)\n        for name, type, bitsize, quals in zip(self.fldnames, self.fldtypes,\n                                              self.fldbitsize, fldquals):\n            if (name == '' and isinstance(type, StructOrUnion)\n                    and expand_anonymous_struct_union):\n                # nested anonymous struct/union\n                for result in type.enumfields():\n                    yield result\n            else:\n                yield (name, type, bitsize, quals)\n\n    def force_flatten(self):\n        # force the struct or union to have a declaration that lists\n        # directly all fields returned by enumfields(), flattening\n        # nested anonymous structs/unions.\n        names = []\n        types = []\n        bitsizes = []\n        fldquals = []\n        for name, type, bitsize, quals in self.enumfields():\n            names.append(name)\n            types.append(type)\n            bitsizes.append(bitsize)\n            fldquals.append(quals)\n        self.fldnames = tuple(names)\n        self.fldtypes = tuple(types)\n        self.fldbitsize = tuple(bitsizes)\n        self.fldquals = tuple(fldquals)\n\n    def get_cached_btype(self, ffi, finishlist, can_delay=False):\n        BType = StructOrUnionOrEnum.get_cached_btype(self, ffi, finishlist,\n                                                     can_delay)\n        if not can_delay:\n            self.finish_backend_type(ffi, finishlist)\n        return BType\n\n    def finish_backend_type(self, ffi, finishlist):\n        if self.completed:\n            if self.completed != 2:\n                raise NotImplementedError(\"recursive structure declaration \"\n                                          \"for '%s'\" % (self.name,))\n            return\n        BType = ffi._cached_btypes[self]\n        #\n        self.completed = 1\n        #\n        if self.fldtypes is None:\n            pass    # not completing it: it's an opaque struct\n            #\n        elif self.fixedlayout is None:\n            fldtypes = [tp.get_cached_btype(ffi, finishlist)\n                        for tp in self.fldtypes]\n            lst = list(zip(self.fldnames, fldtypes, self.fldbitsize))\n            extra_flags = ()\n            if self.packed:\n                if self.packed == 1:\n                    extra_flags = (8,)    # SF_PACKED\n                else:\n                    extra_flags = (0, self.packed)\n            ffi._backend.complete_struct_or_union(BType, lst, self,\n                                                  -1, -1, *extra_flags)\n            #\n        else:\n            fldtypes = []\n            fieldofs, fieldsize, totalsize, totalalignment = self.fixedlayout\n            for i in range(len(self.fldnames)):\n                fsize = fieldsize[i]\n                ftype = self.fldtypes[i]\n                #\n                if isinstance(ftype, ArrayType) and ftype.length_is_unknown():\n                    # fix the length to match the total size\n                    BItemType = ftype.item.get_cached_btype(ffi, finishlist)\n                    nlen, nrest = divmod(fsize, ffi.sizeof(BItemType))\n                    if nrest != 0:\n                        self._verification_error(\n                            \"field '%s.%s' has a bogus size?\" % (\n                            self.name, self.fldnames[i] or '{}'))\n                    ftype = ftype.resolve_length(nlen)\n                    self.fldtypes = (self.fldtypes[:i] + (ftype,) +\n                                     self.fldtypes[i+1:])\n                #\n                BFieldType = ftype.get_cached_btype(ffi, finishlist)\n                if isinstance(ftype, ArrayType) and ftype.length is None:\n                    assert fsize == 0\n                else:\n                    bitemsize = ffi.sizeof(BFieldType)\n                    if bitemsize != fsize:\n                        self._verification_error(\n                            \"field '%s.%s' is declared as %d bytes, but is \"\n                            \"really %d bytes\" % (self.name,\n                                                 self.fldnames[i] or '{}',\n                                                 bitemsize, fsize))\n                fldtypes.append(BFieldType)\n            #\n            lst = list(zip(self.fldnames, fldtypes, self.fldbitsize, fieldofs))\n            ffi._backend.complete_struct_or_union(BType, lst, self,\n                                                  totalsize, totalalignment)\n        self.completed = 2\n\n    def _verification_error(self, msg):\n        raise VerificationError(msg)\n\n    def check_not_partial(self):\n        if self.partial and self.fixedlayout is None:\n            raise VerificationMissing(self._get_c_name())\n\n    def build_backend_type(self, ffi, finishlist):\n        self.check_not_partial()\n        finishlist.append(self)\n        #\n        return global_cache(self, ffi, 'new_%s_type' % self.kind,\n                            self.get_official_name(), key=self)\n\n\nclass StructType(StructOrUnion):\n    kind = 'struct'\n\n\nclass UnionType(StructOrUnion):\n    kind = 'union'\n\n\nclass EnumType(StructOrUnionOrEnum):\n    kind = 'enum'\n    partial = False\n    partial_resolved = False\n\n    def __init__(self, name, enumerators, enumvalues, baseinttype=None):\n        self.name = name\n        self.enumerators = enumerators\n        self.enumvalues = enumvalues\n        self.baseinttype = baseinttype\n        self.build_c_name_with_marker()\n\n    def force_the_name(self, forcename):\n        StructOrUnionOrEnum.force_the_name(self, forcename)\n        if self.forcename is None:\n            name = self.get_official_name()\n            self.forcename = '$' + name.replace(' ', '_')\n\n    def check_not_partial(self):\n        if self.partial and not self.partial_resolved:\n            raise VerificationMissing(self._get_c_name())\n\n    def build_backend_type(self, ffi, finishlist):\n        self.check_not_partial()\n        base_btype = self.build_baseinttype(ffi, finishlist)\n        return global_cache(self, ffi, 'new_enum_type',\n                            self.get_official_name(),\n                            self.enumerators, self.enumvalues,\n                            base_btype, key=self)\n\n    def build_baseinttype(self, ffi, finishlist):\n        if self.baseinttype is not None:\n            return self.baseinttype.get_cached_btype(ffi, finishlist)\n        #\n        if self.enumvalues:\n            smallest_value = min(self.enumvalues)\n            largest_value = max(self.enumvalues)\n        else:\n            import warnings\n            try:\n                # XXX!  The goal is to ensure that the warnings.warn()\n                # will not suppress the warning.  We want to get it\n                # several times if we reach this point several times.\n                __warningregistry__.clear()\n            except NameError:\n                pass\n            warnings.warn(\"%r has no values explicitly defined; \"\n                          \"guessing that it is equivalent to 'unsigned int'\"\n                          % self._get_c_name())\n            smallest_value = largest_value = 0\n        if smallest_value < 0:   # needs a signed type\n            sign = 1\n            candidate1 = PrimitiveType(\"int\")\n            candidate2 = PrimitiveType(\"long\")\n        else:\n            sign = 0\n            candidate1 = PrimitiveType(\"unsigned int\")\n            candidate2 = PrimitiveType(\"unsigned long\")\n        btype1 = candidate1.get_cached_btype(ffi, finishlist)\n        btype2 = candidate2.get_cached_btype(ffi, finishlist)\n        size1 = ffi.sizeof(btype1)\n        size2 = ffi.sizeof(btype2)\n        if (smallest_value >= ((-1) << (8*size1-1)) and\n            largest_value < (1 << (8*size1-sign))):\n            return btype1\n        if (smallest_value >= ((-1) << (8*size2-1)) and\n            largest_value < (1 << (8*size2-sign))):\n            return btype2\n        raise CDefError(\"%s values don't all fit into either 'long' \"\n                        \"or 'unsigned long'\" % self._get_c_name())\n\ndef unknown_type(name, structname=None):\n    if structname is None:\n        structname = '$%s' % name\n    tp = StructType(structname, None, None, None)\n    tp.force_the_name(name)\n    tp.origin = \"unknown_type\"\n    return tp\n\ndef unknown_ptr_type(name, structname=None):\n    if structname is None:\n        structname = '$$%s' % name\n    tp = StructType(structname, None, None, None)\n    return NamedPointerType(tp, name)\n\n\nglobal_lock = allocate_lock()\n_typecache_cffi_backend = weakref.WeakValueDictionary()\n\ndef get_typecache(backend):\n    # returns _typecache_cffi_backend if backend is the _cffi_backend\n    # module, or type(backend).__typecache if backend is an instance of\n    # CTypesBackend (or some FakeBackend class during tests)\n    if isinstance(backend, types.ModuleType):\n        return _typecache_cffi_backend\n    with global_lock:\n        if not hasattr(type(backend), '__typecache'):\n            type(backend).__typecache = weakref.WeakValueDictionary()\n        return type(backend).__typecache\n\ndef global_cache(srctype, ffi, funcname, *args, **kwds):\n    key = kwds.pop('key', (funcname, args))\n    assert not kwds\n    try:\n        return ffi._typecache[key]\n    except KeyError:\n        pass\n    try:\n        res = getattr(ffi._backend, funcname)(*args)\n    except NotImplementedError as e:\n        raise NotImplementedError(\"%s: %r: %s\" % (funcname, srctype, e))\n    # note that setdefault() on WeakValueDictionary is not atomic\n    # and contains a rare bug (http://bugs.python.org/issue19542);\n    # we have to use a lock and do it ourselves\n    cache = ffi._typecache\n    with global_lock:\n        res1 = cache.get(key)\n        if res1 is None:\n            cache[key] = res\n            return res\n        else:\n            return res1\n\ndef pointer_cache(ffi, BType):\n    return global_cache('?', ffi, 'new_pointer_type', BType)\n\ndef attach_exception_info(e, name):\n    if e.args and type(e.args[0]) is str:\n        e.args = ('%s: %s' % (name, e.args[0]),) + e.args[1:]\n", "src/cffi/setuptools_ext.py": "import os\nimport sys\n\ntry:\n    basestring\nexcept NameError:\n    # Python 3.x\n    basestring = str\n\ndef error(msg):\n    from cffi._shimmed_dist_utils import DistutilsSetupError\n    raise DistutilsSetupError(msg)\n\n\ndef execfile(filename, glob):\n    # We use execfile() (here rewritten for Python 3) instead of\n    # __import__() to load the build script.  The problem with\n    # a normal import is that in some packages, the intermediate\n    # __init__.py files may already try to import the file that\n    # we are generating.\n    with open(filename) as f:\n        src = f.read()\n    src += '\\n'      # Python 2.6 compatibility\n    code = compile(src, filename, 'exec')\n    exec(code, glob, glob)\n\n\ndef add_cffi_module(dist, mod_spec):\n    from cffi.api import FFI\n\n    if not isinstance(mod_spec, basestring):\n        error(\"argument to 'cffi_modules=...' must be a str or a list of str,\"\n              \" not %r\" % (type(mod_spec).__name__,))\n    mod_spec = str(mod_spec)\n    try:\n        build_file_name, ffi_var_name = mod_spec.split(':')\n    except ValueError:\n        error(\"%r must be of the form 'path/build.py:ffi_variable'\" %\n              (mod_spec,))\n    if not os.path.exists(build_file_name):\n        ext = ''\n        rewritten = build_file_name.replace('.', '/') + '.py'\n        if os.path.exists(rewritten):\n            ext = ' (rewrite cffi_modules to [%r])' % (\n                rewritten + ':' + ffi_var_name,)\n        error(\"%r does not name an existing file%s\" % (build_file_name, ext))\n\n    mod_vars = {'__name__': '__cffi__', '__file__': build_file_name}\n    execfile(build_file_name, mod_vars)\n\n    try:\n        ffi = mod_vars[ffi_var_name]\n    except KeyError:\n        error(\"%r: object %r not found in module\" % (mod_spec,\n                                                     ffi_var_name))\n    if not isinstance(ffi, FFI):\n        ffi = ffi()      # maybe it's a function instead of directly an ffi\n    if not isinstance(ffi, FFI):\n        error(\"%r is not an FFI instance (got %r)\" % (mod_spec,\n                                                      type(ffi).__name__))\n    if not hasattr(ffi, '_assigned_source'):\n        error(\"%r: the set_source() method was not called\" % (mod_spec,))\n    module_name, source, source_extension, kwds = ffi._assigned_source\n    if ffi._windows_unicode:\n        kwds = kwds.copy()\n        ffi._apply_windows_unicode(kwds)\n\n    if source is None:\n        _add_py_module(dist, ffi, module_name)\n    else:\n        _add_c_module(dist, ffi, module_name, source, source_extension, kwds)\n\ndef _set_py_limited_api(Extension, kwds):\n    \"\"\"\n    Add py_limited_api to kwds if setuptools >= 26 is in use.\n    Do not alter the setting if it already exists.\n    Setuptools takes care of ignoring the flag on Python 2 and PyPy.\n\n    CPython itself should ignore the flag in a debugging version\n    (by not listing .abi3.so in the extensions it supports), but\n    it doesn't so far, creating troubles.  That's why we check\n    for \"not hasattr(sys, 'gettotalrefcount')\" (the 2.7 compatible equivalent\n    of 'd' not in sys.abiflags). (http://bugs.python.org/issue28401)\n\n    On Windows, with CPython <= 3.4, it's better not to use py_limited_api\n    because virtualenv *still* doesn't copy PYTHON3.DLL on these versions.\n    Recently (2020) we started shipping only >= 3.5 wheels, though.  So\n    we'll give it another try and set py_limited_api on Windows >= 3.5.\n    \"\"\"\n    from cffi import recompiler\n\n    if ('py_limited_api' not in kwds and not hasattr(sys, 'gettotalrefcount')\n            and recompiler.USE_LIMITED_API):\n        import setuptools\n        try:\n            setuptools_major_version = int(setuptools.__version__.partition('.')[0])\n            if setuptools_major_version >= 26:\n                kwds['py_limited_api'] = True\n        except ValueError:  # certain development versions of setuptools\n            # If we don't know the version number of setuptools, we\n            # try to set 'py_limited_api' anyway.  At worst, we get a\n            # warning.\n            kwds['py_limited_api'] = True\n    return kwds\n\ndef _add_c_module(dist, ffi, module_name, source, source_extension, kwds):\n    # We are a setuptools extension. Need this build_ext for py_limited_api.\n    from setuptools.command.build_ext import build_ext\n    from cffi._shimmed_dist_utils import Extension, log, mkpath\n    from cffi import recompiler\n\n    allsources = ['$PLACEHOLDER']\n    allsources.extend(kwds.pop('sources', []))\n    kwds = _set_py_limited_api(Extension, kwds)\n    ext = Extension(name=module_name, sources=allsources, **kwds)\n\n    def make_mod(tmpdir, pre_run=None):\n        c_file = os.path.join(tmpdir, module_name + source_extension)\n        log.info(\"generating cffi module %r\" % c_file)\n        mkpath(tmpdir)\n        # a setuptools-only, API-only hook: called with the \"ext\" and \"ffi\"\n        # arguments just before we turn the ffi into C code.  To use it,\n        # subclass the 'distutils.command.build_ext.build_ext' class and\n        # add a method 'def pre_run(self, ext, ffi)'.\n        if pre_run is not None:\n            pre_run(ext, ffi)\n        updated = recompiler.make_c_source(ffi, module_name, source, c_file)\n        if not updated:\n            log.info(\"already up-to-date\")\n        return c_file\n\n    if dist.ext_modules is None:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n\n    base_class = dist.cmdclass.get('build_ext', build_ext)\n    class build_ext_make_mod(base_class):\n        def run(self):\n            if ext.sources[0] == '$PLACEHOLDER':\n                pre_run = getattr(self, 'pre_run', None)\n                ext.sources[0] = make_mod(self.build_temp, pre_run)\n            base_class.run(self)\n    dist.cmdclass['build_ext'] = build_ext_make_mod\n    # NB. multiple runs here will create multiple 'build_ext_make_mod'\n    # classes.  Even in this case the 'build_ext' command should be\n    # run once; but just in case, the logic above does nothing if\n    # called again.\n\n\ndef _add_py_module(dist, ffi, module_name):\n    from setuptools.command.build_py import build_py\n    from setuptools.command.build_ext import build_ext\n    from cffi._shimmed_dist_utils import log, mkpath\n    from cffi import recompiler\n\n    def generate_mod(py_file):\n        log.info(\"generating cffi module %r\" % py_file)\n        mkpath(os.path.dirname(py_file))\n        updated = recompiler.make_py_source(ffi, module_name, py_file)\n        if not updated:\n            log.info(\"already up-to-date\")\n\n    base_class = dist.cmdclass.get('build_py', build_py)\n    class build_py_make_mod(base_class):\n        def run(self):\n            base_class.run(self)\n            module_path = module_name.split('.')\n            module_path[-1] += '.py'\n            generate_mod(os.path.join(self.build_lib, *module_path))\n        def get_source_files(self):\n            # This is called from 'setup.py sdist' only.  Exclude\n            # the generate .py module in this case.\n            saved_py_modules = self.py_modules\n            try:\n                if saved_py_modules:\n                    self.py_modules = [m for m in saved_py_modules\n                                         if m != module_name]\n                return base_class.get_source_files(self)\n            finally:\n                self.py_modules = saved_py_modules\n    dist.cmdclass['build_py'] = build_py_make_mod\n\n    # distutils and setuptools have no notion I could find of a\n    # generated python module.  If we don't add module_name to\n    # dist.py_modules, then things mostly work but there are some\n    # combination of options (--root and --record) that will miss\n    # the module.  So we add it here, which gives a few apparently\n    # harmless warnings about not finding the file outside the\n    # build directory.\n    # Then we need to hack more in get_source_files(); see above.\n    if dist.py_modules is None:\n        dist.py_modules = []\n    dist.py_modules.append(module_name)\n\n    # the following is only for \"build_ext -i\"\n    base_class_2 = dist.cmdclass.get('build_ext', build_ext)\n    class build_ext_make_mod(base_class_2):\n        def run(self):\n            base_class_2.run(self)\n            if self.inplace:\n                # from get_ext_fullpath() in distutils/command/build_ext.py\n                module_path = module_name.split('.')\n                package = '.'.join(module_path[:-1])\n                build_py = self.get_finalized_command('build_py')\n                package_dir = build_py.get_package_dir(package)\n                file_name = module_path[-1] + '.py'\n                generate_mod(os.path.join(package_dir, file_name))\n    dist.cmdclass['build_ext'] = build_ext_make_mod\n\ndef cffi_modules(dist, attr, value):\n    assert attr == 'cffi_modules'\n    if isinstance(value, basestring):\n        value = [value]\n\n    for cffi_module in value:\n        add_cffi_module(dist, cffi_module)\n", "src/cffi/vengine_gen.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys, os\nimport types\n\nfrom . import model\nfrom .error import VerificationError\n\n\nclass VGenericEngine(object):\n    _class_key = 'g'\n    _gen_python_module = False\n\n    def __init__(self, verifier):\n        self.verifier = verifier\n        self.ffi = verifier.ffi\n        self.export_symbols = []\n        self._struct_pending_verification = {}\n\n    def patch_extension_kwds(self, kwds):\n        # add 'export_symbols' to the dictionary.  Note that we add the\n        # list before filling it.  When we fill it, it will thus also show\n        # up in kwds['export_symbols'].\n        kwds.setdefault('export_symbols', self.export_symbols)\n\n    def find_module(self, module_name, path, so_suffixes):\n        for so_suffix in so_suffixes:\n            basename = module_name + so_suffix\n            if path is None:\n                path = sys.path\n            for dirname in path:\n                filename = os.path.join(dirname, basename)\n                if os.path.isfile(filename):\n                    return filename\n\n    def collect_types(self):\n        pass      # not needed in the generic engine\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def write_source_to_f(self):\n        prnt = self._prnt\n        # first paste some standard set of lines that are mostly '#include'\n        prnt(cffimod_header)\n        # then paste the C source given by the user, verbatim.\n        prnt(self.verifier.preamble)\n        #\n        # call generate_gen_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._generate('decl')\n        #\n        # on Windows, distutils insists on putting init_cffi_xyz in\n        # 'export_symbols', so instead of fighting it, just give up and\n        # give it one\n        if sys.platform == 'win32':\n            if sys.version_info >= (3,):\n                prefix = 'PyInit_'\n            else:\n                prefix = 'init'\n            modname = self.verifier.get_module_name()\n            prnt(\"void %s%s(void) { }\\n\" % (prefix, modname))\n\n    def load_library(self, flags=0):\n        # import it with the CFFI backend\n        backend = self.ffi._backend\n        # needs to make a path that contains '/', on Posix\n        filename = os.path.join(os.curdir, self.verifier.modulefilename)\n        module = backend.load_library(filename, flags)\n        #\n        # call loading_gen_struct() to get the struct layout inferred by\n        # the C compiler\n        self._load(module, 'loading')\n\n        # build the FFILibrary class and instance, this is a module subclass\n        # because modules are expected to have usually-constant-attributes and\n        # in PyPy this means the JIT is able to treat attributes as constant,\n        # which we want.\n        class FFILibrary(types.ModuleType):\n            _cffi_generic_module = module\n            _cffi_ffi = self.ffi\n            _cffi_dir = []\n            def __dir__(self):\n                return FFILibrary._cffi_dir\n        library = FFILibrary(\"\")\n        #\n        # finally, call the loaded_gen_xxx() functions.  This will set\n        # up the 'library' object.\n        self._load(module, 'loaded', library=library)\n        return library\n\n    def _get_declarations(self):\n        lst = [(key, tp) for (key, (tp, qual)) in\n                                self.ffi._parser._declarations.items()]\n        lst.sort()\n        return lst\n\n    def _generate(self, step_name):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_gen_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise VerificationError(\n                    \"not implemented in verify(): %r\" % name)\n            try:\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _load(self, module, step_name, **kwds):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            method = getattr(self, '_%s_gen_%s' % (step_name, kind))\n            try:\n                method(tp, realname, module, **kwds)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _generate_nothing(self, tp, name):\n        pass\n\n    def _loaded_noop(self, tp, name, module, **kwds):\n        pass\n\n    # ----------\n    # typedefs: generates no code so far\n\n    _generate_gen_typedef_decl   = _generate_nothing\n    _loading_gen_typedef         = _loaded_noop\n    _loaded_gen_typedef          = _loaded_noop\n\n    # ----------\n    # function declarations\n\n    def _generate_gen_function_decl(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no _cffi_f_%s wrapper)\n            self._generate_gen_const(False, name, tp)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        argnames = []\n        for i, type in enumerate(tp.args):\n            indirection = ''\n            if isinstance(type, model.StructOrUnion):\n                indirection = '*'\n            argnames.append('%sx%d' % (indirection, i))\n        context = 'argument of %s' % name\n        arglist = [type.get_c_name(' %s' % arg, context)\n                   for type, arg in zip(tp.args, argnames)]\n        tpresult = tp.result\n        if isinstance(tpresult, model.StructOrUnion):\n            arglist.insert(0, tpresult.get_c_name(' *r', context))\n            tpresult = model.void_type\n        arglist = ', '.join(arglist) or 'void'\n        wrappername = '_cffi_f_%s' % name\n        self.export_symbols.append(wrappername)\n        if tp.abi:\n            abi = tp.abi + ' '\n        else:\n            abi = ''\n        funcdecl = ' %s%s(%s)' % (abi, wrappername, arglist)\n        context = 'result of %s' % name\n        prnt(tpresult.get_c_name(funcdecl, context))\n        prnt('{')\n        #\n        if isinstance(tp.result, model.StructOrUnion):\n            result_code = '*r = '\n        elif not isinstance(tp.result, model.VoidType):\n            result_code = 'return '\n        else:\n            result_code = ''\n        prnt('  %s%s(%s);' % (result_code, name, ', '.join(argnames)))\n        prnt('}')\n        prnt()\n\n    _loading_gen_function = _loaded_noop\n\n    def _loaded_gen_function(self, tp, name, module, library):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            newfunction = self._load_constant(False, tp, name, module)\n        else:\n            indirections = []\n            base_tp = tp\n            if (any(isinstance(typ, model.StructOrUnion) for typ in tp.args)\n                    or isinstance(tp.result, model.StructOrUnion)):\n                indirect_args = []\n                for i, typ in enumerate(tp.args):\n                    if isinstance(typ, model.StructOrUnion):\n                        typ = model.PointerType(typ)\n                        indirections.append((i, typ))\n                    indirect_args.append(typ)\n                indirect_result = tp.result\n                if isinstance(indirect_result, model.StructOrUnion):\n                    if indirect_result.fldtypes is None:\n                        raise TypeError(\"'%s' is used as result type, \"\n                                        \"but is opaque\" % (\n                                            indirect_result._get_c_name(),))\n                    indirect_result = model.PointerType(indirect_result)\n                    indirect_args.insert(0, indirect_result)\n                    indirections.insert(0, (\"result\", indirect_result))\n                    indirect_result = model.void_type\n                tp = model.FunctionPtrType(tuple(indirect_args),\n                                           indirect_result, tp.ellipsis)\n            BFunc = self.ffi._get_cached_btype(tp)\n            wrappername = '_cffi_f_%s' % name\n            newfunction = module.load_function(BFunc, wrappername)\n            for i, typ in indirections:\n                newfunction = self._make_struct_wrapper(newfunction, i, typ,\n                                                        base_tp)\n        setattr(library, name, newfunction)\n        type(library)._cffi_dir.append(name)\n\n    def _make_struct_wrapper(self, oldfunc, i, tp, base_tp):\n        backend = self.ffi._backend\n        BType = self.ffi._get_cached_btype(tp)\n        if i == \"result\":\n            ffi = self.ffi\n            def newfunc(*args):\n                res = ffi.new(BType)\n                oldfunc(res, *args)\n                return res[0]\n        else:\n            def newfunc(*args):\n                args = args[:i] + (backend.newp(BType, args[i]),) + args[i+1:]\n                return oldfunc(*args)\n        newfunc._cffi_base_type = base_tp\n        return newfunc\n\n    # ----------\n    # named structs\n\n    def _generate_gen_struct_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'struct', name)\n\n    def _loading_gen_struct(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'struct', name, module)\n\n    def _loaded_gen_struct(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_gen_union_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'union', name)\n\n    def _loading_gen_union(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'union', name, module)\n\n    def _loaded_gen_union(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_struct_or_union_decl(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        checkfuncname = '_cffi_check_%s_%s' % (prefix, name)\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        cname = ('%s %s' % (prefix, name)).strip()\n        #\n        prnt = self._prnt\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if (isinstance(ftype, model.PrimitiveType)\n                and ftype.is_integer_type()) or fbitsize >= 0:\n                # accept all integers, but complain on float or double\n                prnt('  (void)((p->%s) << 1);' % fname)\n            else:\n                # only accept exactly the type declared.\n                try:\n                    prnt('  { %s = &p->%s; (void)tmp; }' % (\n                        ftype.get_c_name('*tmp', 'field %r'%fname, quals=fqual),\n                        fname))\n                except VerificationError as e:\n                    prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        self.export_symbols.append(layoutfuncname)\n        prnt('intptr_t %s(intptr_t i)' % (layoutfuncname,))\n        prnt('{')\n        prnt('  struct _cffi_aligncheck { char x; %s y; };' % cname)\n        prnt('  static intptr_t nums[] = {')\n        prnt('    sizeof(%s),' % cname)\n        prnt('    offsetof(struct _cffi_aligncheck, y),')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if fbitsize >= 0:\n                continue      # xxx ignore fbitsize for now\n            prnt('    offsetof(%s, %s),' % (cname, fname))\n            if isinstance(ftype, model.ArrayType) and ftype.length is None:\n                prnt('    0,  /* %s */' % ftype._get_c_name())\n            else:\n                prnt('    sizeof(((%s *)0)->%s),' % (cname, fname))\n        prnt('    -1')\n        prnt('  };')\n        prnt('  return nums[i];')\n        prnt('  /* the next line is not executed, but compiled */')\n        prnt('  %s(0);' % (checkfuncname,))\n        prnt('}')\n        prnt()\n\n    def _loading_struct_or_union(self, tp, prefix, name, module):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        #\n        BFunc = self.ffi._typeof_locked(\"intptr_t(*)(intptr_t)\")[0]\n        function = module.load_function(BFunc, layoutfuncname)\n        layout = []\n        num = 0\n        while True:\n            x = function(num)\n            if x < 0: break\n            layout.append(x)\n            num += 1\n        if isinstance(tp, model.StructOrUnion) and tp.partial:\n            # use the function()'s sizes and offsets to guide the\n            # layout of the struct\n            totalsize = layout[0]\n            totalalignment = layout[1]\n            fieldofs = layout[2::2]\n            fieldsize = layout[3::2]\n            tp.force_flatten()\n            assert len(fieldofs) == len(fieldsize) == len(tp.fldnames)\n            tp.fixedlayout = fieldofs, fieldsize, totalsize, totalalignment\n        else:\n            cname = ('%s %s' % (prefix, name)).strip()\n            self._struct_pending_verification[tp] = layout, cname\n\n    def _loaded_struct_or_union(self, tp):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        self.ffi._get_cached_btype(tp)   # force 'fixedlayout' to be considered\n\n        if tp in self._struct_pending_verification:\n            # check that the layout sizes and offsets match the real ones\n            def check(realvalue, expectedvalue, msg):\n                if realvalue != expectedvalue:\n                    raise VerificationError(\n                        \"%s (we have %d, but C compiler says %d)\"\n                        % (msg, expectedvalue, realvalue))\n            ffi = self.ffi\n            BStruct = ffi._get_cached_btype(tp)\n            layout, cname = self._struct_pending_verification.pop(tp)\n            check(layout[0], ffi.sizeof(BStruct), \"wrong total size\")\n            check(layout[1], ffi.alignof(BStruct), \"wrong total alignment\")\n            i = 2\n            for fname, ftype, fbitsize, fqual in tp.enumfields():\n                if fbitsize >= 0:\n                    continue        # xxx ignore fbitsize for now\n                check(layout[i], ffi.offsetof(BStruct, fname),\n                      \"wrong offset for field %r\" % (fname,))\n                if layout[i+1] != 0:\n                    BField = ffi._get_cached_btype(ftype)\n                    check(layout[i+1], ffi.sizeof(BField),\n                          \"wrong size for field %r\" % (fname,))\n                i += 2\n            assert i == len(layout)\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    def _generate_gen_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_gen_enum_decl(tp, name, '')\n        else:\n            self._generate_struct_or_union_decl(tp, '', name)\n\n    def _loading_gen_anonymous(self, tp, name, module):\n        if isinstance(tp, model.EnumType):\n            self._loading_gen_enum(tp, name, module, '')\n        else:\n            self._loading_struct_or_union(tp, '', name, module)\n\n    def _loaded_gen_anonymous(self, tp, name, module, **kwds):\n        if isinstance(tp, model.EnumType):\n            self._loaded_gen_enum(tp, name, module, **kwds)\n        else:\n            self._loaded_struct_or_union(tp)\n\n    # ----------\n    # constants, likely declared with '#define'\n\n    def _generate_gen_const(self, is_int, name, tp=None, category='const',\n                            check_value=None):\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        self.export_symbols.append(funcname)\n        if check_value is not None:\n            assert is_int\n            assert category == 'const'\n            prnt('int %s(char *out_error)' % funcname)\n            prnt('{')\n            self._check_int_constant_value(name, check_value)\n            prnt('  return 0;')\n            prnt('}')\n        elif is_int:\n            assert category == 'const'\n            prnt('int %s(long long *out_value)' % funcname)\n            prnt('{')\n            prnt('  *out_value = (long long)(%s);' % (name,))\n            prnt('  return (%s) <= 0;' % (name,))\n            prnt('}')\n        else:\n            assert tp is not None\n            assert check_value is None\n            if category == 'var':\n                ampersand = '&'\n            else:\n                ampersand = ''\n            extra = ''\n            if category == 'const' and isinstance(tp, model.StructOrUnion):\n                extra = 'const *'\n                ampersand = '&'\n            prnt(tp.get_c_name(' %s%s(void)' % (extra, funcname), name))\n            prnt('{')\n            prnt('  return (%s%s);' % (ampersand, name))\n            prnt('}')\n        prnt()\n\n    def _generate_gen_constant_decl(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        self._generate_gen_const(is_int, name, tp)\n\n    _loading_gen_constant = _loaded_noop\n\n    def _load_constant(self, is_int, tp, name, module, check_value=None):\n        funcname = '_cffi_const_%s' % name\n        if check_value is not None:\n            assert is_int\n            self._load_known_int_constant(module, funcname)\n            value = check_value\n        elif is_int:\n            BType = self.ffi._typeof_locked(\"long long*\")[0]\n            BFunc = self.ffi._typeof_locked(\"int(*)(long long*)\")[0]\n            function = module.load_function(BFunc, funcname)\n            p = self.ffi.new(BType)\n            negative = function(p)\n            value = int(p[0])\n            if value < 0 and not negative:\n                BLongLong = self.ffi._typeof_locked(\"long long\")[0]\n                value += (1 << (8*self.ffi.sizeof(BLongLong)))\n        else:\n            assert check_value is None\n            fntypeextra = '(*)(void)'\n            if isinstance(tp, model.StructOrUnion):\n                fntypeextra = '*' + fntypeextra\n            BFunc = self.ffi._typeof_locked(tp.get_c_name(fntypeextra, name))[0]\n            function = module.load_function(BFunc, funcname)\n            value = function()\n            if isinstance(tp, model.StructOrUnion):\n                value = value[0]\n        return value\n\n    def _loaded_gen_constant(self, tp, name, module, library):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        value = self._load_constant(is_int, tp, name, module)\n        setattr(library, name, value)\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n    # enums\n\n    def _check_int_constant_value(self, name, value):\n        prnt = self._prnt\n        if value <= 0:\n            prnt('  if ((%s) > 0 || (long)(%s) != %dL) {' % (\n                name, name, value))\n        else:\n            prnt('  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {' % (\n                name, name, value))\n        prnt('    char buf[64];')\n        prnt('    if ((%s) <= 0)' % name)\n        prnt('        sprintf(buf, \"%%ld\", (long)(%s));' % name)\n        prnt('    else')\n        prnt('        sprintf(buf, \"%%lu\", (unsigned long)(%s));' %\n             name)\n        prnt('    sprintf(out_error, \"%s has the real value %s, not %s\",')\n        prnt('            \"%s\", buf, \"%d\");' % (name[:100], value))\n        prnt('    return -1;')\n        prnt('  }')\n\n    def _load_known_int_constant(self, module, funcname):\n        BType = self.ffi._typeof_locked(\"char[]\")[0]\n        BFunc = self.ffi._typeof_locked(\"int(*)(char*)\")[0]\n        function = module.load_function(BFunc, funcname)\n        p = self.ffi.new(BType, 256)\n        if function(p) < 0:\n            error = self.ffi.string(p)\n            if sys.version_info >= (3,):\n                error = str(error, 'utf-8')\n            raise VerificationError(error)\n\n    def _enum_funcname(self, prefix, name):\n        # \"$enum_$1\" => \"___D_enum____D_1\"\n        name = name.replace('$', '___D_')\n        return '_cffi_e_%s_%s' % (prefix, name)\n\n    def _generate_gen_enum_decl(self, tp, name, prefix='enum'):\n        if tp.partial:\n            for enumerator in tp.enumerators:\n                self._generate_gen_const(True, enumerator)\n            return\n        #\n        funcname = self._enum_funcname(prefix, name)\n        self.export_symbols.append(funcname)\n        prnt = self._prnt\n        prnt('int %s(char *out_error)' % funcname)\n        prnt('{')\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._check_int_constant_value(enumerator, enumvalue)\n        prnt('  return 0;')\n        prnt('}')\n        prnt()\n\n    def _loading_gen_enum(self, tp, name, module, prefix='enum'):\n        if tp.partial:\n            enumvalues = [self._load_constant(True, tp, enumerator, module)\n                          for enumerator in tp.enumerators]\n            tp.enumvalues = tuple(enumvalues)\n            tp.partial_resolved = True\n        else:\n            funcname = self._enum_funcname(prefix, name)\n            self._load_known_int_constant(module, funcname)\n\n    def _loaded_gen_enum(self, tp, name, module, library):\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            setattr(library, enumerator, enumvalue)\n            type(library)._cffi_dir.append(enumerator)\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_gen_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_gen_const(True, name, check_value=check_value)\n\n    _loading_gen_macro = _loaded_noop\n\n    def _loaded_gen_macro(self, tp, name, module, library):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        value = self._load_constant(True, tp, name, module,\n                                    check_value=check_value)\n        setattr(library, name, value)\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n    # global variables\n\n    def _generate_gen_variable_decl(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            if tp.length_is_unknown():\n                prnt = self._prnt\n                funcname = '_cffi_sizeof_%s' % (name,)\n                self.export_symbols.append(funcname)\n                prnt(\"size_t %s(void)\" % funcname)\n                prnt(\"{\")\n                prnt(\"  return sizeof(%s);\" % (name,))\n                prnt(\"}\")\n            tp_ptr = model.PointerType(tp.item)\n            self._generate_gen_const(False, name, tp_ptr)\n        else:\n            tp_ptr = model.PointerType(tp)\n            self._generate_gen_const(False, name, tp_ptr, category='var')\n\n    _loading_gen_variable = _loaded_noop\n\n    def _loaded_gen_variable(self, tp, name, module, library):\n        if isinstance(tp, model.ArrayType):   # int a[5] is \"constant\" in the\n                                              # sense that \"a=...\" is forbidden\n            if tp.length_is_unknown():\n                funcname = '_cffi_sizeof_%s' % (name,)\n                BFunc = self.ffi._typeof_locked('size_t(*)(void)')[0]\n                function = module.load_function(BFunc, funcname)\n                size = function()\n                BItemType = self.ffi._get_cached_btype(tp.item)\n                length, rest = divmod(size, self.ffi.sizeof(BItemType))\n                if rest != 0:\n                    raise VerificationError(\n                        \"bad size: %r does not seem to be an array of %s\" %\n                        (name, tp.item))\n                tp = tp.resolve_length(length)\n            tp_ptr = model.PointerType(tp.item)\n            value = self._load_constant(False, tp_ptr, name, module)\n            # 'value' is a <cdata 'type *'> which we have to replace with\n            # a <cdata 'type[N]'> if the N is actually known\n            if tp.length is not None:\n                BArray = self.ffi._get_cached_btype(tp)\n                value = self.ffi.cast(BArray, value)\n            setattr(library, name, value)\n            type(library)._cffi_dir.append(name)\n            return\n        # remove ptr=<cdata 'int *'> from the library instance, and replace\n        # it by a property on the class, which reads/writes into ptr[0].\n        funcname = '_cffi_var_%s' % name\n        BFunc = self.ffi._typeof_locked(tp.get_c_name('*(*)(void)', name))[0]\n        function = module.load_function(BFunc, funcname)\n        ptr = function()\n        def getter(library):\n            return ptr[0]\n        def setter(library, value):\n            ptr[0] = value\n        setattr(type(library), name, property(getter, setter))\n        type(library)._cffi_dir.append(name)\n\ncffimod_header = r'''\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <sys/types.h>   /* XXX for ssize_t on some platforms */\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py\n   and cffi/_cffi_include.h */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n#  ifndef __cplusplus\n    typedef unsigned char _Bool;\n#  endif\n# endif\n# define _cffi_float_complex_t   _Fcomplex    /* include <complex.h> for it */\n# define _cffi_double_complex_t  _Dcomplex    /* include <complex.h> for it */\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)\n#  include <alloca.h>\n# endif\n# define _cffi_float_complex_t   float _Complex\n# define _cffi_double_complex_t  double _Complex\n#endif\n'''\n", "src/cffi/_imp_emulation.py": "\ntry:\n    # this works on Python < 3.12\n    from imp import *\n\nexcept ImportError:\n    # this is a limited emulation for Python >= 3.12.\n    # Note that this is used only for tests or for the old ffi.verify().\n    # This is copied from the source code of Python 3.11.\n\n    from _imp import (acquire_lock, release_lock,\n                      is_builtin, is_frozen)\n\n    from importlib._bootstrap import _load\n\n    from importlib import machinery\n    import os\n    import sys\n    import tokenize\n\n    SEARCH_ERROR = 0\n    PY_SOURCE = 1\n    PY_COMPILED = 2\n    C_EXTENSION = 3\n    PY_RESOURCE = 4\n    PKG_DIRECTORY = 5\n    C_BUILTIN = 6\n    PY_FROZEN = 7\n    PY_CODERESOURCE = 8\n    IMP_HOOK = 9\n\n    def get_suffixes():\n        extensions = [(s, 'rb', C_EXTENSION)\n                      for s in machinery.EXTENSION_SUFFIXES]\n        source = [(s, 'r', PY_SOURCE) for s in machinery.SOURCE_SUFFIXES]\n        bytecode = [(s, 'rb', PY_COMPILED) for s in machinery.BYTECODE_SUFFIXES]\n        return extensions + source + bytecode\n\n    def find_module(name, path=None):\n        if not isinstance(name, str):\n            raise TypeError(\"'name' must be a str, not {}\".format(type(name)))\n        elif not isinstance(path, (type(None), list)):\n            # Backwards-compatibility\n            raise RuntimeError(\"'path' must be None or a list, \"\n                               \"not {}\".format(type(path)))\n\n        if path is None:\n            if is_builtin(name):\n                return None, None, ('', '', C_BUILTIN)\n            elif is_frozen(name):\n                return None, None, ('', '', PY_FROZEN)\n            else:\n                path = sys.path\n\n        for entry in path:\n            package_directory = os.path.join(entry, name)\n            for suffix in ['.py', machinery.BYTECODE_SUFFIXES[0]]:\n                package_file_name = '__init__' + suffix\n                file_path = os.path.join(package_directory, package_file_name)\n                if os.path.isfile(file_path):\n                    return None, package_directory, ('', '', PKG_DIRECTORY)\n            for suffix, mode, type_ in get_suffixes():\n                file_name = name + suffix\n                file_path = os.path.join(entry, file_name)\n                if os.path.isfile(file_path):\n                    break\n            else:\n                continue\n            break  # Break out of outer loop when breaking out of inner loop.\n        else:\n            raise ImportError(name, name=name)\n\n        encoding = None\n        if 'b' not in mode:\n            with open(file_path, 'rb') as file:\n                encoding = tokenize.detect_encoding(file.readline)[0]\n        file = open(file_path, mode, encoding=encoding)\n        return file, file_path, (suffix, mode, type_)\n\n    def load_dynamic(name, path, file=None):\n        loader = machinery.ExtensionFileLoader(name, path)\n        spec = machinery.ModuleSpec(name=name, loader=loader, origin=path)\n        return _load(spec)\n", "src/cffi/ffiplatform.py": "import sys, os\nfrom .error import VerificationError\n\n\nLIST_OF_FILE_NAMES = ['sources', 'include_dirs', 'library_dirs',\n                      'extra_objects', 'depends']\n\ndef get_extension(srcfilename, modname, sources=(), **kwds):\n    from cffi._shimmed_dist_utils import Extension\n    allsources = [srcfilename]\n    for src in sources:\n        allsources.append(os.path.normpath(src))\n    return Extension(name=modname, sources=allsources, **kwds)\n\ndef compile(tmpdir, ext, compiler_verbose=0, debug=None):\n    \"\"\"Compile a C extension module using distutils.\"\"\"\n\n    saved_environ = os.environ.copy()\n    try:\n        outputfilename = _build(tmpdir, ext, compiler_verbose, debug)\n        outputfilename = os.path.abspath(outputfilename)\n    finally:\n        # workaround for a distutils bugs where some env vars can\n        # become longer and longer every time it is used\n        for key, value in saved_environ.items():\n            if os.environ.get(key) != value:\n                os.environ[key] = value\n    return outputfilename\n\ndef _build(tmpdir, ext, compiler_verbose=0, debug=None):\n    # XXX compact but horrible :-(\n    from cffi._shimmed_dist_utils import Distribution, CompileError, LinkError, set_threshold, set_verbosity\n\n    dist = Distribution({'ext_modules': [ext]})\n    dist.parse_config_files()\n    options = dist.get_option_dict('build_ext')\n    if debug is None:\n        debug = sys.flags.debug\n    options['debug'] = ('ffiplatform', debug)\n    options['force'] = ('ffiplatform', True)\n    options['build_lib'] = ('ffiplatform', tmpdir)\n    options['build_temp'] = ('ffiplatform', tmpdir)\n    #\n    try:\n        old_level = set_threshold(0) or 0\n        try:\n            set_verbosity(compiler_verbose)\n            dist.run_command('build_ext')\n            cmd_obj = dist.get_command_obj('build_ext')\n            [soname] = cmd_obj.get_outputs()\n        finally:\n            set_threshold(old_level)\n    except (CompileError, LinkError) as e:\n        raise VerificationError('%s: %s' % (e.__class__.__name__, e))\n    #\n    return soname\n\ntry:\n    from os.path import samefile\nexcept ImportError:\n    def samefile(f1, f2):\n        return os.path.abspath(f1) == os.path.abspath(f2)\n\ndef maybe_relative_path(path):\n    if not os.path.isabs(path):\n        return path      # already relative\n    dir = path\n    names = []\n    while True:\n        prevdir = dir\n        dir, name = os.path.split(prevdir)\n        if dir == prevdir or not dir:\n            return path     # failed to make it relative\n        names.append(name)\n        try:\n            if samefile(dir, os.curdir):\n                names.reverse()\n                return os.path.join(*names)\n        except OSError:\n            pass\n\n# ____________________________________________________________\n\ntry:\n    int_or_long = (int, long)\n    import cStringIO\nexcept NameError:\n    int_or_long = int      # Python 3\n    import io as cStringIO\n\ndef _flatten(x, f):\n    if isinstance(x, str):\n        f.write('%ds%s' % (len(x), x))\n    elif isinstance(x, dict):\n        keys = sorted(x.keys())\n        f.write('%dd' % len(keys))\n        for key in keys:\n            _flatten(key, f)\n            _flatten(x[key], f)\n    elif isinstance(x, (list, tuple)):\n        f.write('%dl' % len(x))\n        for value in x:\n            _flatten(value, f)\n    elif isinstance(x, int_or_long):\n        f.write('%di' % (x,))\n    else:\n        raise TypeError(\n            \"the keywords to verify() contains unsupported object %r\" % (x,))\n\ndef flatten(x):\n    f = cStringIO.StringIO()\n    _flatten(x, f)\n    return f.getvalue()\n", "src/cffi/pkgconfig.py": "# pkg-config, https://www.freedesktop.org/wiki/Software/pkg-config/ integration for cffi\nimport sys, os, subprocess\n\nfrom .error import PkgConfigError\n\n\ndef merge_flags(cfg1, cfg2):\n    \"\"\"Merge values from cffi config flags cfg2 to cf1\n\n    Example:\n        merge_flags({\"libraries\": [\"one\"]}, {\"libraries\": [\"two\"]})\n        {\"libraries\": [\"one\", \"two\"]}\n    \"\"\"\n    for key, value in cfg2.items():\n        if key not in cfg1:\n            cfg1[key] = value\n        else:\n            if not isinstance(cfg1[key], list):\n                raise TypeError(\"cfg1[%r] should be a list of strings\" % (key,))\n            if not isinstance(value, list):\n                raise TypeError(\"cfg2[%r] should be a list of strings\" % (key,))\n            cfg1[key].extend(value)\n    return cfg1\n\n\ndef call(libname, flag, encoding=sys.getfilesystemencoding()):\n    \"\"\"Calls pkg-config and returns the output if found\n    \"\"\"\n    a = [\"pkg-config\", \"--print-errors\"]\n    a.append(flag)\n    a.append(libname)\n    try:\n        pc = subprocess.Popen(a, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    except EnvironmentError as e:\n        raise PkgConfigError(\"cannot run pkg-config: %s\" % (str(e).strip(),))\n\n    bout, berr = pc.communicate()\n    if pc.returncode != 0:\n        try:\n            berr = berr.decode(encoding)\n        except Exception:\n            pass\n        raise PkgConfigError(berr.strip())\n\n    if sys.version_info >= (3,) and not isinstance(bout, str):   # Python 3.x\n        try:\n            bout = bout.decode(encoding)\n        except UnicodeDecodeError:\n            raise PkgConfigError(\"pkg-config %s %s returned bytes that cannot \"\n                                 \"be decoded with encoding %r:\\n%r\" %\n                                 (flag, libname, encoding, bout))\n\n    if os.altsep != '\\\\' and '\\\\' in bout:\n        raise PkgConfigError(\"pkg-config %s %s returned an unsupported \"\n                             \"backslash-escaped output:\\n%r\" %\n                             (flag, libname, bout))\n    return bout\n\n\ndef flags_from_pkgconfig(libs):\n    r\"\"\"Return compiler line flags for FFI.set_source based on pkg-config output\n\n    Usage\n        ...\n        ffibuilder.set_source(\"_foo\", pkgconfig = [\"libfoo\", \"libbar >= 1.8.3\"])\n\n    If pkg-config is installed on build machine, then arguments include_dirs,\n    library_dirs, libraries, define_macros, extra_compile_args and\n    extra_link_args are extended with an output of pkg-config for libfoo and\n    libbar.\n\n    Raises PkgConfigError in case the pkg-config call fails.\n    \"\"\"\n\n    def get_include_dirs(string):\n        return [x[2:] for x in string.split() if x.startswith(\"-I\")]\n\n    def get_library_dirs(string):\n        return [x[2:] for x in string.split() if x.startswith(\"-L\")]\n\n    def get_libraries(string):\n        return [x[2:] for x in string.split() if x.startswith(\"-l\")]\n\n    # convert -Dfoo=bar to list of tuples [(\"foo\", \"bar\")] expected by distutils\n    def get_macros(string):\n        def _macro(x):\n            x = x[2:]    # drop \"-D\"\n            if '=' in x:\n                return tuple(x.split(\"=\", 1))  # \"-Dfoo=bar\" => (\"foo\", \"bar\")\n            else:\n                return (x, None)               # \"-Dfoo\" => (\"foo\", None)\n        return [_macro(x) for x in string.split() if x.startswith(\"-D\")]\n\n    def get_other_cflags(string):\n        return [x for x in string.split() if not x.startswith(\"-I\") and\n                                             not x.startswith(\"-D\")]\n\n    def get_other_libs(string):\n        return [x for x in string.split() if not x.startswith(\"-L\") and\n                                             not x.startswith(\"-l\")]\n\n    # return kwargs for given libname\n    def kwargs(libname):\n        fse = sys.getfilesystemencoding()\n        all_cflags = call(libname, \"--cflags\")\n        all_libs = call(libname, \"--libs\")\n        return {\n            \"include_dirs\": get_include_dirs(all_cflags),\n            \"library_dirs\": get_library_dirs(all_libs),\n            \"libraries\": get_libraries(all_libs),\n            \"define_macros\": get_macros(all_cflags),\n            \"extra_compile_args\": get_other_cflags(all_cflags),\n            \"extra_link_args\": get_other_libs(all_libs),\n            }\n\n    # merge all arguments together\n    ret = {}\n    for libname in libs:\n        lib_flags = kwargs(libname)\n        merge_flags(ret, lib_flags)\n    return ret\n", "src/cffi/api.py": "import sys, types\nfrom .lock import allocate_lock\nfrom .error import CDefError\nfrom . import model\n\ntry:\n    callable\nexcept NameError:\n    # Python 3.1\n    from collections import Callable\n    callable = lambda x: isinstance(x, Callable)\n\ntry:\n    basestring\nexcept NameError:\n    # Python 3.x\n    basestring = str\n\n_unspecified = object()\n\n\n\nclass FFI(object):\n    r'''\n    The main top-level class that you instantiate once, or once per module.\n\n    Example usage:\n\n        ffi = FFI()\n        ffi.cdef(\"\"\"\n            int printf(const char *, ...);\n        \"\"\")\n\n        C = ffi.dlopen(None)   # standard library\n        -or-\n        C = ffi.verify()  # use a C compiler: verify the decl above is right\n\n        C.printf(\"hello, %s!\\n\", ffi.new(\"char[]\", \"world\"))\n    '''\n\n    def __init__(self, backend=None):\n        \"\"\"Create an FFI instance.  The 'backend' argument is used to\n        select a non-default backend, mostly for tests.\n        \"\"\"\n        if backend is None:\n            # You need PyPy (>= 2.0 beta), or a CPython (>= 2.6) with\n            # _cffi_backend.so compiled.\n            import _cffi_backend as backend\n            from . import __version__\n            if backend.__version__ != __version__:\n                # bad version!  Try to be as explicit as possible.\n                if hasattr(backend, '__file__'):\n                    # CPython\n                    raise Exception(\"Version mismatch: this is the 'cffi' package version %s, located in %r.  When we import the top-level '_cffi_backend' extension module, we get version %s, located in %r.  The two versions should be equal; check your installation.\" % (\n                        __version__, __file__,\n                        backend.__version__, backend.__file__))\n                else:\n                    # PyPy\n                    raise Exception(\"Version mismatch: this is the 'cffi' package version %s, located in %r.  This interpreter comes with a built-in '_cffi_backend' module, which is version %s.  The two versions should be equal; check your installation.\" % (\n                        __version__, __file__, backend.__version__))\n            # (If you insist you can also try to pass the option\n            # 'backend=backend_ctypes.CTypesBackend()', but don't\n            # rely on it!  It's probably not going to work well.)\n\n        from . import cparser\n        self._backend = backend\n        self._lock = allocate_lock()\n        self._parser = cparser.Parser()\n        self._cached_btypes = {}\n        self._parsed_types = types.ModuleType('parsed_types').__dict__\n        self._new_types = types.ModuleType('new_types').__dict__\n        self._function_caches = []\n        self._libraries = []\n        self._cdefsources = []\n        self._included_ffis = []\n        self._windows_unicode = None\n        self._init_once_cache = {}\n        self._cdef_version = None\n        self._embedding = None\n        self._typecache = model.get_typecache(backend)\n        if hasattr(backend, 'set_ffi'):\n            backend.set_ffi(self)\n        for name in list(backend.__dict__):\n            if name.startswith('RTLD_'):\n                setattr(self, name, getattr(backend, name))\n        #\n        with self._lock:\n            self.BVoidP = self._get_cached_btype(model.voidp_type)\n            self.BCharA = self._get_cached_btype(model.char_array_type)\n        if isinstance(backend, types.ModuleType):\n            # _cffi_backend: attach these constants to the class\n            if not hasattr(FFI, 'NULL'):\n                FFI.NULL = self.cast(self.BVoidP, 0)\n                FFI.CData, FFI.CType = backend._get_types()\n        else:\n            # ctypes backend: attach these constants to the instance\n            self.NULL = self.cast(self.BVoidP, 0)\n            self.CData, self.CType = backend._get_types()\n        self.buffer = backend.buffer\n\n    def cdef(self, csource, override=False, packed=False, pack=None):\n        \"\"\"Parse the given C source.  This registers all declared functions,\n        types, and global variables.  The functions and global variables can\n        then be accessed via either 'ffi.dlopen()' or 'ffi.verify()'.\n        The types can be used in 'ffi.new()' and other functions.\n        If 'packed' is specified as True, all structs declared inside this\n        cdef are packed, i.e. laid out without any field alignment at all.\n        Alternatively, 'pack' can be a small integer, and requests for\n        alignment greater than that are ignored (pack=1 is equivalent to\n        packed=True).\n        \"\"\"\n        self._cdef(csource, override=override, packed=packed, pack=pack)\n\n    def embedding_api(self, csource, packed=False, pack=None):\n        self._cdef(csource, packed=packed, pack=pack, dllexport=True)\n        if self._embedding is None:\n            self._embedding = ''\n\n    def _cdef(self, csource, override=False, **options):\n        if not isinstance(csource, str):    # unicode, on Python 2\n            if not isinstance(csource, basestring):\n                raise TypeError(\"cdef() argument must be a string\")\n            csource = csource.encode('ascii')\n        with self._lock:\n            self._cdef_version = object()\n            self._parser.parse(csource, override=override, **options)\n            self._cdefsources.append(csource)\n            if override:\n                for cache in self._function_caches:\n                    cache.clear()\n            finishlist = self._parser._recomplete\n            if finishlist:\n                self._parser._recomplete = []\n                for tp in finishlist:\n                    tp.finish_backend_type(self, finishlist)\n\n    def dlopen(self, name, flags=0):\n        \"\"\"Load and return a dynamic library identified by 'name'.\n        The standard C library can be loaded by passing None.\n        Note that functions and types declared by 'ffi.cdef()' are not\n        linked to a particular library, just like C headers; in the\n        library we only look for the actual (untyped) symbols.\n        \"\"\"\n        if not (isinstance(name, basestring) or\n                name is None or\n                isinstance(name, self.CData)):\n            raise TypeError(\"dlopen(name): name must be a file name, None, \"\n                            \"or an already-opened 'void *' handle\")\n        with self._lock:\n            lib, function_cache = _make_ffi_library(self, name, flags)\n            self._function_caches.append(function_cache)\n            self._libraries.append(lib)\n        return lib\n\n    def dlclose(self, lib):\n        \"\"\"Close a library obtained with ffi.dlopen().  After this call,\n        access to functions or variables from the library will fail\n        (possibly with a segmentation fault).\n        \"\"\"\n        type(lib).__cffi_close__(lib)\n\n    def _typeof_locked(self, cdecl):\n        # call me with the lock!\n        key = cdecl\n        if key in self._parsed_types:\n            return self._parsed_types[key]\n        #\n        if not isinstance(cdecl, str):    # unicode, on Python 2\n            cdecl = cdecl.encode('ascii')\n        #\n        type = self._parser.parse_type(cdecl)\n        really_a_function_type = type.is_raw_function\n        if really_a_function_type:\n            type = type.as_function_pointer()\n        btype = self._get_cached_btype(type)\n        result = btype, really_a_function_type\n        self._parsed_types[key] = result\n        return result\n\n    def _typeof(self, cdecl, consider_function_as_funcptr=False):\n        # string -> ctype object\n        try:\n            result = self._parsed_types[cdecl]\n        except KeyError:\n            with self._lock:\n                result = self._typeof_locked(cdecl)\n        #\n        btype, really_a_function_type = result\n        if really_a_function_type and not consider_function_as_funcptr:\n            raise CDefError(\"the type %r is a function type, not a \"\n                            \"pointer-to-function type\" % (cdecl,))\n        return btype\n\n    def typeof(self, cdecl):\n        \"\"\"Parse the C type given as a string and return the\n        corresponding <ctype> object.\n        It can also be used on 'cdata' instance to get its C type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            return self._typeof(cdecl)\n        if isinstance(cdecl, self.CData):\n            return self._backend.typeof(cdecl)\n        if isinstance(cdecl, types.BuiltinFunctionType):\n            res = _builtin_function_type(cdecl)\n            if res is not None:\n                return res\n        if (isinstance(cdecl, types.FunctionType)\n                and hasattr(cdecl, '_cffi_base_type')):\n            with self._lock:\n                return self._get_cached_btype(cdecl._cffi_base_type)\n        raise TypeError(type(cdecl))\n\n    def sizeof(self, cdecl):\n        \"\"\"Return the size in bytes of the argument.  It can be a\n        string naming a C type, or a 'cdata' instance.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            BType = self._typeof(cdecl)\n            return self._backend.sizeof(BType)\n        else:\n            return self._backend.sizeof(cdecl)\n\n    def alignof(self, cdecl):\n        \"\"\"Return the natural alignment size in bytes of the C type\n        given as a string.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.alignof(cdecl)\n\n    def offsetof(self, cdecl, *fields_or_indexes):\n        \"\"\"Return the offset of the named field inside the given\n        structure or array, which must be given as a C type name.\n        You can give several field names in case of nested structures.\n        You can also give numeric values which correspond to array\n        items, in case of an array type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._typeoffsetof(cdecl, *fields_or_indexes)[1]\n\n    def new(self, cdecl, init=None):\n        \"\"\"Allocate an instance according to the specified C type and\n        return a pointer to it.  The specified C type must be either a\n        pointer or an array: ``new('X *')`` allocates an X and returns\n        a pointer to it, whereas ``new('X[n]')`` allocates an array of\n        n X'es and returns an array referencing it (which works\n        mostly like a pointer, like in C).  You can also use\n        ``new('X[]', n)`` to allocate an array of a non-constant\n        length n.\n\n        The memory is initialized following the rules of declaring a\n        global variable in C: by default it is zero-initialized, but\n        an explicit initializer can be given which can be used to\n        fill all or part of the memory.\n\n        When the returned <cdata> object goes out of scope, the memory\n        is freed.  In other words the returned <cdata> object has\n        ownership of the value of type 'cdecl' that it points to.  This\n        means that the raw data can be used as long as this object is\n        kept alive, but must not be used for a longer time.  Be careful\n        about that when copying the pointer to the memory somewhere\n        else, e.g. into another structure.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.newp(cdecl, init)\n\n    def new_allocator(self, alloc=None, free=None,\n                      should_clear_after_alloc=True):\n        \"\"\"Return a new allocator, i.e. a function that behaves like ffi.new()\n        but uses the provided low-level 'alloc' and 'free' functions.\n\n        'alloc' is called with the size as argument.  If it returns NULL, a\n        MemoryError is raised.  'free' is called with the result of 'alloc'\n        as argument.  Both can be either Python function or directly C\n        functions.  If 'free' is None, then no free function is called.\n        If both 'alloc' and 'free' are None, the default is used.\n\n        If 'should_clear_after_alloc' is set to False, then the memory\n        returned by 'alloc' is assumed to be already cleared (or you are\n        fine with garbage); otherwise CFFI will clear it.\n        \"\"\"\n        compiled_ffi = self._backend.FFI()\n        allocator = compiled_ffi.new_allocator(alloc, free,\n                                               should_clear_after_alloc)\n        def allocate(cdecl, init=None):\n            if isinstance(cdecl, basestring):\n                cdecl = self._typeof(cdecl)\n            return allocator(cdecl, init)\n        return allocate\n\n    def cast(self, cdecl, source):\n        \"\"\"Similar to a C cast: returns an instance of the named C\n        type initialized with the given 'source'.  The source is\n        casted between integers or pointers of any type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.cast(cdecl, source)\n\n    def string(self, cdata, maxlen=-1):\n        \"\"\"Return a Python string (or unicode string) from the 'cdata'.\n        If 'cdata' is a pointer or array of characters or bytes, returns\n        the null-terminated string.  The returned string extends until\n        the first null character, or at most 'maxlen' characters.  If\n        'cdata' is an array then 'maxlen' defaults to its length.\n\n        If 'cdata' is a pointer or array of wchar_t, returns a unicode\n        string following the same rules.\n\n        If 'cdata' is a single character or byte or a wchar_t, returns\n        it as a string or unicode string.\n\n        If 'cdata' is an enum, returns the value of the enumerator as a\n        string, or 'NUMBER' if the value is out of range.\n        \"\"\"\n        return self._backend.string(cdata, maxlen)\n\n    def unpack(self, cdata, length):\n        \"\"\"Unpack an array of C data of the given length,\n        returning a Python string/unicode/list.\n\n        If 'cdata' is a pointer to 'char', returns a byte string.\n        It does not stop at the first null.  This is equivalent to:\n        ffi.buffer(cdata, length)[:]\n\n        If 'cdata' is a pointer to 'wchar_t', returns a unicode string.\n        'length' is measured in wchar_t's; it is not the size in bytes.\n\n        If 'cdata' is a pointer to anything else, returns a list of\n        'length' items.  This is a faster equivalent to:\n        [cdata[i] for i in range(length)]\n        \"\"\"\n        return self._backend.unpack(cdata, length)\n\n   #def buffer(self, cdata, size=-1):\n   #    \"\"\"Return a read-write buffer object that references the raw C data\n   #    pointed to by the given 'cdata'.  The 'cdata' must be a pointer or\n   #    an array.  Can be passed to functions expecting a buffer, or directly\n   #    manipulated with:\n   #\n   #        buf[:]          get a copy of it in a regular string, or\n   #        buf[idx]        as a single character\n   #        buf[:] = ...\n   #        buf[idx] = ...  change the content\n   #    \"\"\"\n   #    note that 'buffer' is a type, set on this instance by __init__\n\n    def from_buffer(self, cdecl, python_buffer=_unspecified,\n                    require_writable=False):\n        \"\"\"Return a cdata of the given type pointing to the data of the\n        given Python object, which must support the buffer interface.\n        Note that this is not meant to be used on the built-in types\n        str or unicode (you can build 'char[]' arrays explicitly)\n        but only on objects containing large quantities of raw data\n        in some other format, like 'array.array' or numpy arrays.\n\n        The first argument is optional and default to 'char[]'.\n        \"\"\"\n        if python_buffer is _unspecified:\n            cdecl, python_buffer = self.BCharA, cdecl\n        elif isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.from_buffer(cdecl, python_buffer,\n                                         require_writable)\n\n    def memmove(self, dest, src, n):\n        \"\"\"ffi.memmove(dest, src, n) copies n bytes of memory from src to dest.\n\n        Like the C function memmove(), the memory areas may overlap;\n        apart from that it behaves like the C function memcpy().\n\n        'src' can be any cdata ptr or array, or any Python buffer object.\n        'dest' can be any cdata ptr or array, or a writable Python buffer\n        object.  The size to copy, 'n', is always measured in bytes.\n\n        Unlike other methods, this one supports all Python buffer including\n        byte strings and bytearrays---but it still does not support\n        non-contiguous buffers.\n        \"\"\"\n        return self._backend.memmove(dest, src, n)\n\n    def callback(self, cdecl, python_callable=None, error=None, onerror=None):\n        \"\"\"Return a callback object or a decorator making such a\n        callback object.  'cdecl' must name a C function pointer type.\n        The callback invokes the specified 'python_callable' (which may\n        be provided either directly or via a decorator).  Important: the\n        callback object must be manually kept alive for as long as the\n        callback may be invoked from the C level.\n        \"\"\"\n        def callback_decorator_wrap(python_callable):\n            if not callable(python_callable):\n                raise TypeError(\"the 'python_callable' argument \"\n                                \"is not callable\")\n            return self._backend.callback(cdecl, python_callable,\n                                          error, onerror)\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl, consider_function_as_funcptr=True)\n        if python_callable is None:\n            return callback_decorator_wrap                # decorator mode\n        else:\n            return callback_decorator_wrap(python_callable)  # direct mode\n\n    def getctype(self, cdecl, replace_with=''):\n        \"\"\"Return a string giving the C type 'cdecl', which may be itself\n        a string or a <ctype> object.  If 'replace_with' is given, it gives\n        extra text to append (or insert for more complicated C types), like\n        a variable name, or '*' to get actually the C type 'pointer-to-cdecl'.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        replace_with = replace_with.strip()\n        if (replace_with.startswith('*')\n                and '&[' in self._backend.getcname(cdecl, '&')):\n            replace_with = '(%s)' % replace_with\n        elif replace_with and not replace_with[0] in '[(':\n            replace_with = ' ' + replace_with\n        return self._backend.getcname(cdecl, replace_with)\n\n    def gc(self, cdata, destructor, size=0):\n        \"\"\"Return a new cdata object that points to the same\n        data.  Later, when this new cdata object is garbage-collected,\n        'destructor(old_cdata_object)' will be called.\n\n        The optional 'size' gives an estimate of the size, used to\n        trigger the garbage collection more eagerly.  So far only used\n        on PyPy.  It tells the GC that the returned object keeps alive\n        roughly 'size' bytes of external memory.\n        \"\"\"\n        return self._backend.gcp(cdata, destructor, size)\n\n    def _get_cached_btype(self, type):\n        assert self._lock.acquire(False) is False\n        # call me with the lock!\n        try:\n            BType = self._cached_btypes[type]\n        except KeyError:\n            finishlist = []\n            BType = type.get_cached_btype(self, finishlist)\n            for type in finishlist:\n                type.finish_backend_type(self, finishlist)\n        return BType\n\n    def verify(self, source='', tmpdir=None, **kwargs):\n        \"\"\"Verify that the current ffi signatures compile on this\n        machine, and return a dynamic library object.  The dynamic\n        library can be used to call functions and access global\n        variables declared in this 'ffi'.  The library is compiled\n        by the C compiler: it gives you C-level API compatibility\n        (including calling macros).  This is unlike 'ffi.dlopen()',\n        which requires binary compatibility in the signatures.\n        \"\"\"\n        from .verifier import Verifier, _caller_dir_pycache\n        #\n        # If set_unicode(True) was called, insert the UNICODE and\n        # _UNICODE macro declarations\n        if self._windows_unicode:\n            self._apply_windows_unicode(kwargs)\n        #\n        # Set the tmpdir here, and not in Verifier.__init__: it picks\n        # up the caller's directory, which we want to be the caller of\n        # ffi.verify(), as opposed to the caller of Veritier().\n        tmpdir = tmpdir or _caller_dir_pycache()\n        #\n        # Make a Verifier() and use it to load the library.\n        self.verifier = Verifier(self, source, tmpdir, **kwargs)\n        lib = self.verifier.load_library()\n        #\n        # Save the loaded library for keep-alive purposes, even\n        # if the caller doesn't keep it alive itself (it should).\n        self._libraries.append(lib)\n        return lib\n\n    def _get_errno(self):\n        return self._backend.get_errno()\n    def _set_errno(self, errno):\n        self._backend.set_errno(errno)\n    errno = property(_get_errno, _set_errno, None,\n                     \"the value of 'errno' from/to the C calls\")\n\n    def getwinerror(self, code=-1):\n        return self._backend.getwinerror(code)\n\n    def _pointer_to(self, ctype):\n        with self._lock:\n            return model.pointer_cache(self, ctype)\n\n    def addressof(self, cdata, *fields_or_indexes):\n        \"\"\"Return the address of a <cdata 'struct-or-union'>.\n        If 'fields_or_indexes' are given, returns the address of that\n        field or array item in the structure or array, recursively in\n        case of nested structures.\n        \"\"\"\n        try:\n            ctype = self._backend.typeof(cdata)\n        except TypeError:\n            if '__addressof__' in type(cdata).__dict__:\n                return type(cdata).__addressof__(cdata, *fields_or_indexes)\n            raise\n        if fields_or_indexes:\n            ctype, offset = self._typeoffsetof(ctype, *fields_or_indexes)\n        else:\n            if ctype.kind == \"pointer\":\n                raise TypeError(\"addressof(pointer)\")\n            offset = 0\n        ctypeptr = self._pointer_to(ctype)\n        return self._backend.rawaddressof(ctypeptr, cdata, offset)\n\n    def _typeoffsetof(self, ctype, field_or_index, *fields_or_indexes):\n        ctype, offset = self._backend.typeoffsetof(ctype, field_or_index)\n        for field1 in fields_or_indexes:\n            ctype, offset1 = self._backend.typeoffsetof(ctype, field1, 1)\n            offset += offset1\n        return ctype, offset\n\n    def include(self, ffi_to_include):\n        \"\"\"Includes the typedefs, structs, unions and enums defined\n        in another FFI instance.  Usage is similar to a #include in C,\n        where a part of the program might include types defined in\n        another part for its own usage.  Note that the include()\n        method has no effect on functions, constants and global\n        variables, which must anyway be accessed directly from the\n        lib object returned by the original FFI instance.\n        \"\"\"\n        if not isinstance(ffi_to_include, FFI):\n            raise TypeError(\"ffi.include() expects an argument that is also of\"\n                            \" type cffi.FFI, not %r\" % (\n                                type(ffi_to_include).__name__,))\n        if ffi_to_include is self:\n            raise ValueError(\"self.include(self)\")\n        with ffi_to_include._lock:\n            with self._lock:\n                self._parser.include(ffi_to_include._parser)\n                self._cdefsources.append('[')\n                self._cdefsources.extend(ffi_to_include._cdefsources)\n                self._cdefsources.append(']')\n                self._included_ffis.append(ffi_to_include)\n\n    def new_handle(self, x):\n        return self._backend.newp_handle(self.BVoidP, x)\n\n    def from_handle(self, x):\n        return self._backend.from_handle(x)\n\n    def release(self, x):\n        self._backend.release(x)\n\n    def set_unicode(self, enabled_flag):\n        \"\"\"Windows: if 'enabled_flag' is True, enable the UNICODE and\n        _UNICODE defines in C, and declare the types like TCHAR and LPTCSTR\n        to be (pointers to) wchar_t.  If 'enabled_flag' is False,\n        declare these types to be (pointers to) plain 8-bit characters.\n        This is mostly for backward compatibility; you usually want True.\n        \"\"\"\n        if self._windows_unicode is not None:\n            raise ValueError(\"set_unicode() can only be called once\")\n        enabled_flag = bool(enabled_flag)\n        if enabled_flag:\n            self.cdef(\"typedef wchar_t TBYTE;\"\n                      \"typedef wchar_t TCHAR;\"\n                      \"typedef const wchar_t *LPCTSTR;\"\n                      \"typedef const wchar_t *PCTSTR;\"\n                      \"typedef wchar_t *LPTSTR;\"\n                      \"typedef wchar_t *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        else:\n            self.cdef(\"typedef char TBYTE;\"\n                      \"typedef char TCHAR;\"\n                      \"typedef const char *LPCTSTR;\"\n                      \"typedef const char *PCTSTR;\"\n                      \"typedef char *LPTSTR;\"\n                      \"typedef char *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        self._windows_unicode = enabled_flag\n\n    def _apply_windows_unicode(self, kwds):\n        defmacros = kwds.get('define_macros', ())\n        if not isinstance(defmacros, (list, tuple)):\n            raise TypeError(\"'define_macros' must be a list or tuple\")\n        defmacros = list(defmacros) + [('UNICODE', '1'),\n                                       ('_UNICODE', '1')]\n        kwds['define_macros'] = defmacros\n\n    def _apply_embedding_fix(self, kwds):\n        # must include an argument like \"-lpython2.7\" for the compiler\n        def ensure(key, value):\n            lst = kwds.setdefault(key, [])\n            if value not in lst:\n                lst.append(value)\n        #\n        if '__pypy__' in sys.builtin_module_names:\n            import os\n            if sys.platform == \"win32\":\n                # we need 'libpypy-c.lib'.  Current distributions of\n                # pypy (>= 4.1) contain it as 'libs/python27.lib'.\n                pythonlib = \"python{0[0]}{0[1]}\".format(sys.version_info)\n                if hasattr(sys, 'prefix'):\n                    ensure('library_dirs', os.path.join(sys.prefix, 'libs'))\n            else:\n                # we need 'libpypy-c.{so,dylib}', which should be by\n                # default located in 'sys.prefix/bin' for installed\n                # systems.\n                if sys.version_info < (3,):\n                    pythonlib = \"pypy-c\"\n                else:\n                    pythonlib = \"pypy3-c\"\n                if hasattr(sys, 'prefix'):\n                    ensure('library_dirs', os.path.join(sys.prefix, 'bin'))\n            # On uninstalled pypy's, the libpypy-c is typically found in\n            # .../pypy/goal/.\n            if hasattr(sys, 'prefix'):\n                ensure('library_dirs', os.path.join(sys.prefix, 'pypy', 'goal'))\n        else:\n            if sys.platform == \"win32\":\n                template = \"python%d%d\"\n                if hasattr(sys, 'gettotalrefcount'):\n                    template += '_d'\n            else:\n                try:\n                    import sysconfig\n                except ImportError:    # 2.6\n                    from cffi._shimmed_dist_utils import sysconfig\n                template = \"python%d.%d\"\n                if sysconfig.get_config_var('DEBUG_EXT'):\n                    template += sysconfig.get_config_var('DEBUG_EXT')\n            pythonlib = (template %\n                    (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))\n            if hasattr(sys, 'abiflags'):\n                pythonlib += sys.abiflags\n        ensure('libraries', pythonlib)\n        if sys.platform == \"win32\":\n            ensure('extra_link_args', '/MANIFEST')\n\n    def set_source(self, module_name, source, source_extension='.c', **kwds):\n        import os\n        if hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() cannot be called several times \"\n                             \"per ffi object\")\n        if not isinstance(module_name, basestring):\n            raise TypeError(\"'module_name' must be a string\")\n        if os.sep in module_name or (os.altsep and os.altsep in module_name):\n            raise ValueError(\"'module_name' must not contain '/': use a dotted \"\n                             \"name to make a 'package.module' location\")\n        self._assigned_source = (str(module_name), source,\n                                 source_extension, kwds)\n\n    def set_source_pkgconfig(self, module_name, pkgconfig_libs, source,\n                             source_extension='.c', **kwds):\n        from . import pkgconfig\n        if not isinstance(pkgconfig_libs, list):\n            raise TypeError(\"the pkgconfig_libs argument must be a list \"\n                            \"of package names\")\n        kwds2 = pkgconfig.flags_from_pkgconfig(pkgconfig_libs)\n        pkgconfig.merge_flags(kwds, kwds2)\n        self.set_source(module_name, source, source_extension, **kwds)\n\n    def distutils_extension(self, tmpdir='build', verbose=True):\n        from cffi._shimmed_dist_utils import mkpath\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            if hasattr(self, 'verifier'):     # fallback, 'tmpdir' ignored\n                return self.verifier.get_extension()\n            raise ValueError(\"set_source() must be called before\"\n                             \" distutils_extension()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"distutils_extension() is only for C extension \"\n                            \"modules, not for dlopen()-style pure Python \"\n                            \"modules\")\n        mkpath(tmpdir)\n        ext, updated = recompile(self, module_name,\n                                 source, tmpdir=tmpdir, extradir=tmpdir,\n                                 source_extension=source_extension,\n                                 call_c_compiler=False, **kwds)\n        if verbose:\n            if updated:\n                sys.stderr.write(\"regenerated: %r\\n\" % (ext.sources[0],))\n            else:\n                sys.stderr.write(\"not modified: %r\\n\" % (ext.sources[0],))\n        return ext\n\n    def emit_c_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"emit_c_code() is only for C extension modules, \"\n                            \"not for dlopen()-style pure Python modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def emit_python_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is not None:\n            raise TypeError(\"emit_python_code() is only for dlopen()-style \"\n                            \"pure Python modules, not for C extension modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def compile(self, tmpdir='.', verbose=0, target=None, debug=None):\n        \"\"\"The 'target' argument gives the final file name of the\n        compiled DLL.  Use '*' to force distutils' choice, suitable for\n        regular CPython C API modules.  Use a file name ending in '.*'\n        to ask for the system's default extension for dynamic libraries\n        (.so/.dll/.dylib).\n\n        The default is '*' when building a non-embedded C API extension,\n        and (module_name + '.*') when building an embedded library.\n        \"\"\"\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before compile()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        return recompile(self, module_name, source, tmpdir=tmpdir,\n                         target=target, source_extension=source_extension,\n                         compiler_verbose=verbose, debug=debug, **kwds)\n\n    def init_once(self, func, tag):\n        # Read _init_once_cache[tag], which is either (False, lock) if\n        # we're calling the function now in some thread, or (True, result).\n        # Don't call setdefault() in most cases, to avoid allocating and\n        # immediately freeing a lock; but still use setdefaut() to avoid\n        # races.\n        try:\n            x = self._init_once_cache[tag]\n        except KeyError:\n            x = self._init_once_cache.setdefault(tag, (False, allocate_lock()))\n        # Common case: we got (True, result), so we return the result.\n        if x[0]:\n            return x[1]\n        # Else, it's a lock.  Acquire it to serialize the following tests.\n        with x[1]:\n            # Read again from _init_once_cache the current status.\n            x = self._init_once_cache[tag]\n            if x[0]:\n                return x[1]\n            # Call the function and store the result back.\n            result = func()\n            self._init_once_cache[tag] = (True, result)\n        return result\n\n    def embedding_init_code(self, pysource):\n        if self._embedding:\n            raise ValueError(\"embedding_init_code() can only be called once\")\n        # fix 'pysource' before it gets dumped into the C file:\n        # - remove empty lines at the beginning, so it starts at \"line 1\"\n        # - dedent, if all non-empty lines are indented\n        # - check for SyntaxErrors\n        import re\n        match = re.match(r'\\s*\\n', pysource)\n        if match:\n            pysource = pysource[match.end():]\n        lines = pysource.splitlines() or ['']\n        prefix = re.match(r'\\s*', lines[0]).group()\n        for i in range(1, len(lines)):\n            line = lines[i]\n            if line.rstrip():\n                while not line.startswith(prefix):\n                    prefix = prefix[:-1]\n        i = len(prefix)\n        lines = [line[i:]+'\\n' for line in lines]\n        pysource = ''.join(lines)\n        #\n        compile(pysource, \"cffi_init\", \"exec\")\n        #\n        self._embedding = pysource\n\n    def def_extern(self, *args, **kwds):\n        raise ValueError(\"ffi.def_extern() is only available on API-mode FFI \"\n                         \"objects\")\n\n    def list_types(self):\n        \"\"\"Returns the user type names known to this FFI instance.\n        This returns a tuple containing three lists of names:\n        (typedef_names, names_of_structs, names_of_unions)\n        \"\"\"\n        typedefs = []\n        structs = []\n        unions = []\n        for key in self._parser._declarations:\n            if key.startswith('typedef '):\n                typedefs.append(key[8:])\n            elif key.startswith('struct '):\n                structs.append(key[7:])\n            elif key.startswith('union '):\n                unions.append(key[6:])\n        typedefs.sort()\n        structs.sort()\n        unions.sort()\n        return (typedefs, structs, unions)\n\n\ndef _load_backend_lib(backend, name, flags):\n    import os\n    if not isinstance(name, basestring):\n        if sys.platform != \"win32\" or name is not None:\n            return backend.load_library(name, flags)\n        name = \"c\"    # Windows: load_library(None) fails, but this works\n                      # on Python 2 (backward compatibility hack only)\n    first_error = None\n    if '.' in name or '/' in name or os.sep in name:\n        try:\n            return backend.load_library(name, flags)\n        except OSError as e:\n            first_error = e\n    import ctypes.util\n    path = ctypes.util.find_library(name)\n    if path is None:\n        if name == \"c\" and sys.platform == \"win32\" and sys.version_info >= (3,):\n            raise OSError(\"dlopen(None) cannot work on Windows for Python 3 \"\n                          \"(see http://bugs.python.org/issue23606)\")\n        msg = (\"ctypes.util.find_library() did not manage \"\n               \"to locate a library called %r\" % (name,))\n        if first_error is not None:\n            msg = \"%s.  Additionally, %s\" % (first_error, msg)\n        raise OSError(msg)\n    return backend.load_library(path, flags)\n\ndef _make_ffi_library(ffi, libname, flags):\n    backend = ffi._backend\n    backendlib = _load_backend_lib(backend, libname, flags)\n    #\n    def accessor_function(name):\n        key = 'function ' + name\n        tp, _ = ffi._parser._declarations[key]\n        BType = ffi._get_cached_btype(tp)\n        value = backendlib.load_function(BType, name)\n        library.__dict__[name] = value\n    #\n    def accessor_variable(name):\n        key = 'variable ' + name\n        tp, _ = ffi._parser._declarations[key]\n        BType = ffi._get_cached_btype(tp)\n        read_variable = backendlib.read_variable\n        write_variable = backendlib.write_variable\n        setattr(FFILibrary, name, property(\n            lambda self: read_variable(BType, name),\n            lambda self, value: write_variable(BType, name, value)))\n    #\n    def addressof_var(name):\n        try:\n            return addr_variables[name]\n        except KeyError:\n            with ffi._lock:\n                if name not in addr_variables:\n                    key = 'variable ' + name\n                    tp, _ = ffi._parser._declarations[key]\n                    BType = ffi._get_cached_btype(tp)\n                    if BType.kind != 'array':\n                        BType = model.pointer_cache(ffi, BType)\n                    p = backendlib.load_function(BType, name)\n                    addr_variables[name] = p\n            return addr_variables[name]\n    #\n    def accessor_constant(name):\n        raise NotImplementedError(\"non-integer constant '%s' cannot be \"\n                                  \"accessed from a dlopen() library\" % (name,))\n    #\n    def accessor_int_constant(name):\n        library.__dict__[name] = ffi._parser._int_constants[name]\n    #\n    accessors = {}\n    accessors_version = [False]\n    addr_variables = {}\n    #\n    def update_accessors():\n        if accessors_version[0] is ffi._cdef_version:\n            return\n        #\n        for key, (tp, _) in ffi._parser._declarations.items():\n            if not isinstance(tp, model.EnumType):\n                tag, name = key.split(' ', 1)\n                if tag == 'function':\n                    accessors[name] = accessor_function\n                elif tag == 'variable':\n                    accessors[name] = accessor_variable\n                elif tag == 'constant':\n                    accessors[name] = accessor_constant\n            else:\n                for i, enumname in enumerate(tp.enumerators):\n                    def accessor_enum(name, tp=tp, i=i):\n                        tp.check_not_partial()\n                        library.__dict__[name] = tp.enumvalues[i]\n                    accessors[enumname] = accessor_enum\n        for name in ffi._parser._int_constants:\n            accessors.setdefault(name, accessor_int_constant)\n        accessors_version[0] = ffi._cdef_version\n    #\n    def make_accessor(name):\n        with ffi._lock:\n            if name in library.__dict__ or name in FFILibrary.__dict__:\n                return    # added by another thread while waiting for the lock\n            if name not in accessors:\n                update_accessors()\n                if name not in accessors:\n                    raise AttributeError(name)\n            accessors[name](name)\n    #\n    class FFILibrary(object):\n        def __getattr__(self, name):\n            make_accessor(name)\n            return getattr(self, name)\n        def __setattr__(self, name, value):\n            try:\n                property = getattr(self.__class__, name)\n            except AttributeError:\n                make_accessor(name)\n                setattr(self, name, value)\n            else:\n                property.__set__(self, value)\n        def __dir__(self):\n            with ffi._lock:\n                update_accessors()\n                return accessors.keys()\n        def __addressof__(self, name):\n            if name in library.__dict__:\n                return library.__dict__[name]\n            if name in FFILibrary.__dict__:\n                return addressof_var(name)\n            make_accessor(name)\n            if name in library.__dict__:\n                return library.__dict__[name]\n            if name in FFILibrary.__dict__:\n                return addressof_var(name)\n            raise AttributeError(\"cffi library has no function or \"\n                                 \"global variable named '%s'\" % (name,))\n        def __cffi_close__(self):\n            backendlib.close_lib()\n            self.__dict__.clear()\n    #\n    if isinstance(libname, basestring):\n        try:\n            if not isinstance(libname, str):    # unicode, on Python 2\n                libname = libname.encode('utf-8')\n            FFILibrary.__name__ = 'FFILibrary_%s' % libname\n        except UnicodeError:\n            pass\n    library = FFILibrary()\n    return library, library.__dict__\n\ndef _builtin_function_type(func):\n    # a hack to make at least ffi.typeof(builtin_function) work,\n    # if the builtin function was obtained by 'vengine_cpy'.\n    import sys\n    try:\n        module = sys.modules[func.__module__]\n        ffi = module._cffi_original_ffi\n        types_of_builtin_funcs = module._cffi_types_of_builtin_funcs\n        tp = types_of_builtin_funcs[func]\n    except (KeyError, AttributeError, TypeError):\n        return None\n    else:\n        with ffi._lock:\n            return ffi._get_cached_btype(tp)\n", "src/cffi/cparser.py": "from . import model\nfrom .commontypes import COMMON_TYPES, resolve_common_type\nfrom .error import FFIError, CDefError\ntry:\n    from . import _pycparser as pycparser\nexcept ImportError:\n    import pycparser\nimport weakref, re, sys\n\ntry:\n    if sys.version_info < (3,):\n        import thread as _thread\n    else:\n        import _thread\n    lock = _thread.allocate_lock()\nexcept ImportError:\n    lock = None\n\ndef _workaround_for_static_import_finders():\n    # Issue #392: packaging tools like cx_Freeze can not find these\n    # because pycparser uses exec dynamic import.  This is an obscure\n    # workaround.  This function is never called.\n    import pycparser.yacctab\n    import pycparser.lextab\n\nCDEF_SOURCE_STRING = \"<cdef source string>\"\n_r_comment = re.compile(r\"/\\*.*?\\*/|//([^\\n\\\\]|\\\\.)*?$\",\n                        re.DOTALL | re.MULTILINE)\n_r_define  = re.compile(r\"^\\s*#\\s*define\\s+([A-Za-z_][A-Za-z_0-9]*)\"\n                        r\"\\b((?:[^\\n\\\\]|\\\\.)*?)$\",\n                        re.DOTALL | re.MULTILINE)\n_r_line_directive = re.compile(r\"^[ \\t]*#[ \\t]*(?:line|\\d+)\\b.*$\", re.MULTILINE)\n_r_partial_enum = re.compile(r\"=\\s*\\.\\.\\.\\s*[,}]|\\.\\.\\.\\s*\\}\")\n_r_enum_dotdotdot = re.compile(r\"__dotdotdot\\d+__$\")\n_r_partial_array = re.compile(r\"\\[\\s*\\.\\.\\.\\s*\\]\")\n_r_words = re.compile(r\"\\w+|\\S\")\n_parser_cache = None\n_r_int_literal = re.compile(r\"-?0?x?[0-9a-f]+[lu]*$\", re.IGNORECASE)\n_r_stdcall1 = re.compile(r\"\\b(__stdcall|WINAPI)\\b\")\n_r_stdcall2 = re.compile(r\"[(]\\s*(__stdcall|WINAPI)\\b\")\n_r_cdecl = re.compile(r\"\\b__cdecl\\b\")\n_r_extern_python = re.compile(r'\\bextern\\s*\"'\n                              r'(Python|Python\\s*\\+\\s*C|C\\s*\\+\\s*Python)\"\\s*.')\n_r_star_const_space = re.compile(       # matches \"* const \"\n    r\"[*]\\s*((const|volatile|restrict)\\b\\s*)+\")\n_r_int_dotdotdot = re.compile(r\"(\\b(int|long|short|signed|unsigned|char)\\s*)+\"\n                              r\"\\.\\.\\.\")\n_r_float_dotdotdot = re.compile(r\"\\b(double|float)\\s*\\.\\.\\.\")\n\ndef _get_parser():\n    global _parser_cache\n    if _parser_cache is None:\n        _parser_cache = pycparser.CParser()\n    return _parser_cache\n\ndef _workaround_for_old_pycparser(csource):\n    # Workaround for a pycparser issue (fixed between pycparser 2.10 and\n    # 2.14): \"char*const***\" gives us a wrong syntax tree, the same as\n    # for \"char***(*const)\".  This means we can't tell the difference\n    # afterwards.  But \"char(*const(***))\" gives us the right syntax\n    # tree.  The issue only occurs if there are several stars in\n    # sequence with no parenthesis inbetween, just possibly qualifiers.\n    # Attempt to fix it by adding some parentheses in the source: each\n    # time we see \"* const\" or \"* const *\", we add an opening\n    # parenthesis before each star---the hard part is figuring out where\n    # to close them.\n    parts = []\n    while True:\n        match = _r_star_const_space.search(csource)\n        if not match:\n            break\n        #print repr(''.join(parts)+csource), '=>',\n        parts.append(csource[:match.start()])\n        parts.append('('); closing = ')'\n        parts.append(match.group())   # e.g. \"* const \"\n        endpos = match.end()\n        if csource.startswith('*', endpos):\n            parts.append('('); closing += ')'\n        level = 0\n        i = endpos\n        while i < len(csource):\n            c = csource[i]\n            if c == '(':\n                level += 1\n            elif c == ')':\n                if level == 0:\n                    break\n                level -= 1\n            elif c in ',;=':\n                if level == 0:\n                    break\n            i += 1\n        csource = csource[endpos:i] + closing + csource[i:]\n        #print repr(''.join(parts)+csource)\n    parts.append(csource)\n    return ''.join(parts)\n\ndef _preprocess_extern_python(csource):\n    # input: `extern \"Python\" int foo(int);` or\n    #        `extern \"Python\" { int foo(int); }`\n    # output:\n    #     void __cffi_extern_python_start;\n    #     int foo(int);\n    #     void __cffi_extern_python_stop;\n    #\n    # input: `extern \"Python+C\" int foo(int);`\n    # output:\n    #     void __cffi_extern_python_plus_c_start;\n    #     int foo(int);\n    #     void __cffi_extern_python_stop;\n    parts = []\n    while True:\n        match = _r_extern_python.search(csource)\n        if not match:\n            break\n        endpos = match.end() - 1\n        #print\n        #print ''.join(parts)+csource\n        #print '=>'\n        parts.append(csource[:match.start()])\n        if 'C' in match.group(1):\n            parts.append('void __cffi_extern_python_plus_c_start; ')\n        else:\n            parts.append('void __cffi_extern_python_start; ')\n        if csource[endpos] == '{':\n            # grouping variant\n            closing = csource.find('}', endpos)\n            if closing < 0:\n                raise CDefError(\"'extern \\\"Python\\\" {': no '}' found\")\n            if csource.find('{', endpos + 1, closing) >= 0:\n                raise NotImplementedError(\"cannot use { } inside a block \"\n                                          \"'extern \\\"Python\\\" { ... }'\")\n            parts.append(csource[endpos+1:closing])\n            csource = csource[closing+1:]\n        else:\n            # non-grouping variant\n            semicolon = csource.find(';', endpos)\n            if semicolon < 0:\n                raise CDefError(\"'extern \\\"Python\\\": no ';' found\")\n            parts.append(csource[endpos:semicolon+1])\n            csource = csource[semicolon+1:]\n        parts.append(' void __cffi_extern_python_stop;')\n        #print ''.join(parts)+csource\n        #print\n    parts.append(csource)\n    return ''.join(parts)\n\ndef _warn_for_string_literal(csource):\n    if '\"' not in csource:\n        return\n    for line in csource.splitlines():\n        if '\"' in line and not line.lstrip().startswith('#'):\n            import warnings\n            warnings.warn(\"String literal found in cdef() or type source. \"\n                          \"String literals are ignored here, but you should \"\n                          \"remove them anyway because some character sequences \"\n                          \"confuse pre-parsing.\")\n            break\n\ndef _warn_for_non_extern_non_static_global_variable(decl):\n    if not decl.storage:\n        import warnings\n        warnings.warn(\"Global variable '%s' in cdef(): for consistency \"\n                      \"with C it should have a storage class specifier \"\n                      \"(usually 'extern')\" % (decl.name,))\n\ndef _remove_line_directives(csource):\n    # _r_line_directive matches whole lines, without the final \\n, if they\n    # start with '#line' with some spacing allowed, or '#NUMBER'.  This\n    # function stores them away and replaces them with exactly the string\n    # '#line@N', where N is the index in the list 'line_directives'.\n    line_directives = []\n    def replace(m):\n        i = len(line_directives)\n        line_directives.append(m.group())\n        return '#line@%d' % i\n    csource = _r_line_directive.sub(replace, csource)\n    return csource, line_directives\n\ndef _put_back_line_directives(csource, line_directives):\n    def replace(m):\n        s = m.group()\n        if not s.startswith('#line@'):\n            raise AssertionError(\"unexpected #line directive \"\n                                 \"(should have been processed and removed\")\n        return line_directives[int(s[6:])]\n    return _r_line_directive.sub(replace, csource)\n\ndef _preprocess(csource):\n    # First, remove the lines of the form '#line N \"filename\"' because\n    # the \"filename\" part could confuse the rest\n    csource, line_directives = _remove_line_directives(csource)\n    # Remove comments.  NOTE: this only work because the cdef() section\n    # should not contain any string literals (except in line directives)!\n    def replace_keeping_newlines(m):\n        return ' ' + m.group().count('\\n') * '\\n'\n    csource = _r_comment.sub(replace_keeping_newlines, csource)\n    # Remove the \"#define FOO x\" lines\n    macros = {}\n    for match in _r_define.finditer(csource):\n        macroname, macrovalue = match.groups()\n        macrovalue = macrovalue.replace('\\\\\\n', '').strip()\n        macros[macroname] = macrovalue\n    csource = _r_define.sub('', csource)\n    #\n    if pycparser.__version__ < '2.14':\n        csource = _workaround_for_old_pycparser(csource)\n    #\n    # BIG HACK: replace WINAPI or __stdcall with \"volatile const\".\n    # It doesn't make sense for the return type of a function to be\n    # \"volatile volatile const\", so we abuse it to detect __stdcall...\n    # Hack number 2 is that \"int(volatile *fptr)();\" is not valid C\n    # syntax, so we place the \"volatile\" before the opening parenthesis.\n    csource = _r_stdcall2.sub(' volatile volatile const(', csource)\n    csource = _r_stdcall1.sub(' volatile volatile const ', csource)\n    csource = _r_cdecl.sub(' ', csource)\n    #\n    # Replace `extern \"Python\"` with start/end markers\n    csource = _preprocess_extern_python(csource)\n    #\n    # Now there should not be any string literal left; warn if we get one\n    _warn_for_string_literal(csource)\n    #\n    # Replace \"[...]\" with \"[__dotdotdotarray__]\"\n    csource = _r_partial_array.sub('[__dotdotdotarray__]', csource)\n    #\n    # Replace \"...}\" with \"__dotdotdotNUM__}\".  This construction should\n    # occur only at the end of enums; at the end of structs we have \"...;}\"\n    # and at the end of vararg functions \"...);\".  Also replace \"=...[,}]\"\n    # with \",__dotdotdotNUM__[,}]\": this occurs in the enums too, when\n    # giving an unknown value.\n    matches = list(_r_partial_enum.finditer(csource))\n    for number, match in enumerate(reversed(matches)):\n        p = match.start()\n        if csource[p] == '=':\n            p2 = csource.find('...', p, match.end())\n            assert p2 > p\n            csource = '%s,__dotdotdot%d__ %s' % (csource[:p], number,\n                                                 csource[p2+3:])\n        else:\n            assert csource[p:p+3] == '...'\n            csource = '%s __dotdotdot%d__ %s' % (csource[:p], number,\n                                                 csource[p+3:])\n    # Replace \"int ...\" or \"unsigned long int...\" with \"__dotdotdotint__\"\n    csource = _r_int_dotdotdot.sub(' __dotdotdotint__ ', csource)\n    # Replace \"float ...\" or \"double...\" with \"__dotdotdotfloat__\"\n    csource = _r_float_dotdotdot.sub(' __dotdotdotfloat__ ', csource)\n    # Replace all remaining \"...\" with the same name, \"__dotdotdot__\",\n    # which is declared with a typedef for the purpose of C parsing.\n    csource = csource.replace('...', ' __dotdotdot__ ')\n    # Finally, put back the line directives\n    csource = _put_back_line_directives(csource, line_directives)\n    return csource, macros\n\ndef _common_type_names(csource):\n    # Look in the source for what looks like usages of types from the\n    # list of common types.  A \"usage\" is approximated here as the\n    # appearance of the word, minus a \"definition\" of the type, which\n    # is the last word in a \"typedef\" statement.  Approximative only\n    # but should be fine for all the common types.\n    look_for_words = set(COMMON_TYPES)\n    look_for_words.add(';')\n    look_for_words.add(',')\n    look_for_words.add('(')\n    look_for_words.add(')')\n    look_for_words.add('typedef')\n    words_used = set()\n    is_typedef = False\n    paren = 0\n    previous_word = ''\n    for word in _r_words.findall(csource):\n        if word in look_for_words:\n            if word == ';':\n                if is_typedef:\n                    words_used.discard(previous_word)\n                    look_for_words.discard(previous_word)\n                    is_typedef = False\n            elif word == 'typedef':\n                is_typedef = True\n                paren = 0\n            elif word == '(':\n                paren += 1\n            elif word == ')':\n                paren -= 1\n            elif word == ',':\n                if is_typedef and paren == 0:\n                    words_used.discard(previous_word)\n                    look_for_words.discard(previous_word)\n            else:   # word in COMMON_TYPES\n                words_used.add(word)\n        previous_word = word\n    return words_used\n\n\nclass Parser(object):\n\n    def __init__(self):\n        self._declarations = {}\n        self._included_declarations = set()\n        self._anonymous_counter = 0\n        self._structnode2type = weakref.WeakKeyDictionary()\n        self._options = {}\n        self._int_constants = {}\n        self._recomplete = []\n        self._uses_new_feature = None\n\n    def _parse(self, csource):\n        csource, macros = _preprocess(csource)\n        # XXX: for more efficiency we would need to poke into the\n        # internals of CParser...  the following registers the\n        # typedefs, because their presence or absence influences the\n        # parsing itself (but what they are typedef'ed to plays no role)\n        ctn = _common_type_names(csource)\n        typenames = []\n        for name in sorted(self._declarations):\n            if name.startswith('typedef '):\n                name = name[8:]\n                typenames.append(name)\n                ctn.discard(name)\n        typenames += sorted(ctn)\n        #\n        csourcelines = []\n        csourcelines.append('# 1 \"<cdef automatic initialization code>\"')\n        for typename in typenames:\n            csourcelines.append('typedef int %s;' % typename)\n        csourcelines.append('typedef int __dotdotdotint__, __dotdotdotfloat__,'\n                            ' __dotdotdot__;')\n        # this forces pycparser to consider the following in the file\n        # called <cdef source string> from line 1\n        csourcelines.append('# 1 \"%s\"' % (CDEF_SOURCE_STRING,))\n        csourcelines.append(csource)\n        csourcelines.append('')   # see test_missing_newline_bug\n        fullcsource = '\\n'.join(csourcelines)\n        if lock is not None:\n            lock.acquire()     # pycparser is not thread-safe...\n        try:\n            ast = _get_parser().parse(fullcsource)\n        except pycparser.c_parser.ParseError as e:\n            self.convert_pycparser_error(e, csource)\n        finally:\n            if lock is not None:\n                lock.release()\n        # csource will be used to find buggy source text\n        return ast, macros, csource\n\n    def _convert_pycparser_error(self, e, csource):\n        # xxx look for \"<cdef source string>:NUM:\" at the start of str(e)\n        # and interpret that as a line number.  This will not work if\n        # the user gives explicit ``# NUM \"FILE\"`` directives.\n        line = None\n        msg = str(e)\n        match = re.match(r\"%s:(\\d+):\" % (CDEF_SOURCE_STRING,), msg)\n        if match:\n            linenum = int(match.group(1), 10)\n            csourcelines = csource.splitlines()\n            if 1 <= linenum <= len(csourcelines):\n                line = csourcelines[linenum-1]\n        return line\n\n    def convert_pycparser_error(self, e, csource):\n        line = self._convert_pycparser_error(e, csource)\n\n        msg = str(e)\n        if line:\n            msg = 'cannot parse \"%s\"\\n%s' % (line.strip(), msg)\n        else:\n            msg = 'parse error\\n%s' % (msg,)\n        raise CDefError(msg)\n\n    def parse(self, csource, override=False, packed=False, pack=None,\n                    dllexport=False):\n        if packed:\n            if packed != True:\n                raise ValueError(\"'packed' should be False or True; use \"\n                                 \"'pack' to give another value\")\n            if pack:\n                raise ValueError(\"cannot give both 'pack' and 'packed'\")\n            pack = 1\n        elif pack:\n            if pack & (pack - 1):\n                raise ValueError(\"'pack' must be a power of two, not %r\" %\n                    (pack,))\n        else:\n            pack = 0\n        prev_options = self._options\n        try:\n            self._options = {'override': override,\n                             'packed': pack,\n                             'dllexport': dllexport}\n            self._internal_parse(csource)\n        finally:\n            self._options = prev_options\n\n    def _internal_parse(self, csource):\n        ast, macros, csource = self._parse(csource)\n        # add the macros\n        self._process_macros(macros)\n        # find the first \"__dotdotdot__\" and use that as a separator\n        # between the repeated typedefs and the real csource\n        iterator = iter(ast.ext)\n        for decl in iterator:\n            if decl.name == '__dotdotdot__':\n                break\n        else:\n            assert 0\n        current_decl = None\n        #\n        try:\n            self._inside_extern_python = '__cffi_extern_python_stop'\n            for decl in iterator:\n                current_decl = decl\n                if isinstance(decl, pycparser.c_ast.Decl):\n                    self._parse_decl(decl)\n                elif isinstance(decl, pycparser.c_ast.Typedef):\n                    if not decl.name:\n                        raise CDefError(\"typedef does not declare any name\",\n                                        decl)\n                    quals = 0\n                    if (isinstance(decl.type.type, pycparser.c_ast.IdentifierType) and\n                            decl.type.type.names[-1].startswith('__dotdotdot')):\n                        realtype = self._get_unknown_type(decl)\n                    elif (isinstance(decl.type, pycparser.c_ast.PtrDecl) and\n                          isinstance(decl.type.type, pycparser.c_ast.TypeDecl) and\n                          isinstance(decl.type.type.type,\n                                     pycparser.c_ast.IdentifierType) and\n                          decl.type.type.type.names[-1].startswith('__dotdotdot')):\n                        realtype = self._get_unknown_ptr_type(decl)\n                    else:\n                        realtype, quals = self._get_type_and_quals(\n                            decl.type, name=decl.name, partial_length_ok=True,\n                            typedef_example=\"*(%s *)0\" % (decl.name,))\n                    self._declare('typedef ' + decl.name, realtype, quals=quals)\n                elif decl.__class__.__name__ == 'Pragma':\n                    # skip pragma, only in pycparser 2.15\n                    import warnings\n                    warnings.warn(\n                        \"#pragma in cdef() are entirely ignored. \"\n                        \"They should be removed for now, otherwise your \"\n                        \"code might behave differently in a future version \"\n                        \"of CFFI if #pragma support gets added. Note that \"\n                        \"'#pragma pack' needs to be replaced with the \"\n                        \"'packed' keyword argument to cdef().\")\n                else:\n                    raise CDefError(\"unexpected <%s>: this construct is valid \"\n                                    \"C but not valid in cdef()\" %\n                                    decl.__class__.__name__, decl)\n        except CDefError as e:\n            if len(e.args) == 1:\n                e.args = e.args + (current_decl,)\n            raise\n        except FFIError as e:\n            msg = self._convert_pycparser_error(e, csource)\n            if msg:\n                e.args = (e.args[0] + \"\\n    *** Err: %s\" % msg,)\n            raise\n\n    def _add_constants(self, key, val):\n        if key in self._int_constants:\n            if self._int_constants[key] == val:\n                return     # ignore identical double declarations\n            raise FFIError(\n                \"multiple declarations of constant: %s\" % (key,))\n        self._int_constants[key] = val\n\n    def _add_integer_constant(self, name, int_str):\n        int_str = int_str.lower().rstrip(\"ul\")\n        neg = int_str.startswith('-')\n        if neg:\n            int_str = int_str[1:]\n        # \"010\" is not valid oct in py3\n        if (int_str.startswith(\"0\") and int_str != '0'\n                and not int_str.startswith(\"0x\")):\n            int_str = \"0o\" + int_str[1:]\n        pyvalue = int(int_str, 0)\n        if neg:\n            pyvalue = -pyvalue\n        self._add_constants(name, pyvalue)\n        self._declare('macro ' + name, pyvalue)\n\n    def _process_macros(self, macros):\n        for key, value in macros.items():\n            value = value.strip()\n            if _r_int_literal.match(value):\n                self._add_integer_constant(key, value)\n            elif value == '...':\n                self._declare('macro ' + key, value)\n            else:\n                raise CDefError(\n                    'only supports one of the following syntax:\\n'\n                    '  #define %s ...     (literally dot-dot-dot)\\n'\n                    '  #define %s NUMBER  (with NUMBER an integer'\n                                    ' constant, decimal/hex/octal)\\n'\n                    'got:\\n'\n                    '  #define %s %s'\n                    % (key, key, key, value))\n\n    def _declare_function(self, tp, quals, decl):\n        tp = self._get_type_pointer(tp, quals)\n        if self._options.get('dllexport'):\n            tag = 'dllexport_python '\n        elif self._inside_extern_python == '__cffi_extern_python_start':\n            tag = 'extern_python '\n        elif self._inside_extern_python == '__cffi_extern_python_plus_c_start':\n            tag = 'extern_python_plus_c '\n        else:\n            tag = 'function '\n        self._declare(tag + decl.name, tp)\n\n    def _parse_decl(self, decl):\n        node = decl.type\n        if isinstance(node, pycparser.c_ast.FuncDecl):\n            tp, quals = self._get_type_and_quals(node, name=decl.name)\n            assert isinstance(tp, model.RawFunctionType)\n            self._declare_function(tp, quals, decl)\n        else:\n            if isinstance(node, pycparser.c_ast.Struct):\n                self._get_struct_union_enum_type('struct', node)\n            elif isinstance(node, pycparser.c_ast.Union):\n                self._get_struct_union_enum_type('union', node)\n            elif isinstance(node, pycparser.c_ast.Enum):\n                self._get_struct_union_enum_type('enum', node)\n            elif not decl.name:\n                raise CDefError(\"construct does not declare any variable\",\n                                decl)\n            #\n            if decl.name:\n                tp, quals = self._get_type_and_quals(node,\n                                                     partial_length_ok=True)\n                if tp.is_raw_function:\n                    self._declare_function(tp, quals, decl)\n                elif (tp.is_integer_type() and\n                        hasattr(decl, 'init') and\n                        hasattr(decl.init, 'value') and\n                        _r_int_literal.match(decl.init.value)):\n                    self._add_integer_constant(decl.name, decl.init.value)\n                elif (tp.is_integer_type() and\n                        isinstance(decl.init, pycparser.c_ast.UnaryOp) and\n                        decl.init.op == '-' and\n                        hasattr(decl.init.expr, 'value') and\n                        _r_int_literal.match(decl.init.expr.value)):\n                    self._add_integer_constant(decl.name,\n                                               '-' + decl.init.expr.value)\n                elif (tp is model.void_type and\n                      decl.name.startswith('__cffi_extern_python_')):\n                    # hack: `extern \"Python\"` in the C source is replaced\n                    # with \"void __cffi_extern_python_start;\" and\n                    # \"void __cffi_extern_python_stop;\"\n                    self._inside_extern_python = decl.name\n                else:\n                    if self._inside_extern_python !='__cffi_extern_python_stop':\n                        raise CDefError(\n                            \"cannot declare constants or \"\n                            \"variables with 'extern \\\"Python\\\"'\")\n                    if (quals & model.Q_CONST) and not tp.is_array_type:\n                        self._declare('constant ' + decl.name, tp, quals=quals)\n                    else:\n                        _warn_for_non_extern_non_static_global_variable(decl)\n                        self._declare('variable ' + decl.name, tp, quals=quals)\n\n    def parse_type(self, cdecl):\n        return self.parse_type_and_quals(cdecl)[0]\n\n    def parse_type_and_quals(self, cdecl):\n        ast, macros = self._parse('void __dummy(\\n%s\\n);' % cdecl)[:2]\n        assert not macros\n        exprnode = ast.ext[-1].type.args.params[0]\n        if isinstance(exprnode, pycparser.c_ast.ID):\n            raise CDefError(\"unknown identifier '%s'\" % (exprnode.name,))\n        return self._get_type_and_quals(exprnode.type)\n\n    def _declare(self, name, obj, included=False, quals=0):\n        if name in self._declarations:\n            prevobj, prevquals = self._declarations[name]\n            if prevobj is obj and prevquals == quals:\n                return\n            if not self._options.get('override'):\n                raise FFIError(\n                    \"multiple declarations of %s (for interactive usage, \"\n                    \"try cdef(xx, override=True))\" % (name,))\n        assert '__dotdotdot__' not in name.split()\n        self._declarations[name] = (obj, quals)\n        if included:\n            self._included_declarations.add(obj)\n\n    def _extract_quals(self, type):\n        quals = 0\n        if isinstance(type, (pycparser.c_ast.TypeDecl,\n                             pycparser.c_ast.PtrDecl)):\n            if 'const' in type.quals:\n                quals |= model.Q_CONST\n            if 'volatile' in type.quals:\n                quals |= model.Q_VOLATILE\n            if 'restrict' in type.quals:\n                quals |= model.Q_RESTRICT\n        return quals\n\n    def _get_type_pointer(self, type, quals, declname=None):\n        if isinstance(type, model.RawFunctionType):\n            return type.as_function_pointer()\n        if (isinstance(type, model.StructOrUnionOrEnum) and\n                type.name.startswith('$') and type.name[1:].isdigit() and\n                type.forcename is None and declname is not None):\n            return model.NamedPointerType(type, declname, quals)\n        return model.PointerType(type, quals)\n\n    def _get_type_and_quals(self, typenode, name=None, partial_length_ok=False,\n                            typedef_example=None):\n        # first, dereference typedefs, if we have it already parsed, we're good\n        if (isinstance(typenode, pycparser.c_ast.TypeDecl) and\n            isinstance(typenode.type, pycparser.c_ast.IdentifierType) and\n            len(typenode.type.names) == 1 and\n            ('typedef ' + typenode.type.names[0]) in self._declarations):\n            tp, quals = self._declarations['typedef ' + typenode.type.names[0]]\n            quals |= self._extract_quals(typenode)\n            return tp, quals\n        #\n        if isinstance(typenode, pycparser.c_ast.ArrayDecl):\n            # array type\n            if typenode.dim is None:\n                length = None\n            else:\n                length = self._parse_constant(\n                    typenode.dim, partial_length_ok=partial_length_ok)\n            # a hack: in 'typedef int foo_t[...][...];', don't use '...' as\n            # the length but use directly the C expression that would be\n            # generated by recompiler.py.  This lets the typedef be used in\n            # many more places within recompiler.py\n            if typedef_example is not None:\n                if length == '...':\n                    length = '_cffi_array_len(%s)' % (typedef_example,)\n                typedef_example = \"*\" + typedef_example\n            #\n            tp, quals = self._get_type_and_quals(typenode.type,\n                                partial_length_ok=partial_length_ok,\n                                typedef_example=typedef_example)\n            return model.ArrayType(tp, length), quals\n        #\n        if isinstance(typenode, pycparser.c_ast.PtrDecl):\n            # pointer type\n            itemtype, itemquals = self._get_type_and_quals(typenode.type)\n            tp = self._get_type_pointer(itemtype, itemquals, declname=name)\n            quals = self._extract_quals(typenode)\n            return tp, quals\n        #\n        if isinstance(typenode, pycparser.c_ast.TypeDecl):\n            quals = self._extract_quals(typenode)\n            type = typenode.type\n            if isinstance(type, pycparser.c_ast.IdentifierType):\n                # assume a primitive type.  get it from .names, but reduce\n                # synonyms to a single chosen combination\n                names = list(type.names)\n                if names != ['signed', 'char']:    # keep this unmodified\n                    prefixes = {}\n                    while names:\n                        name = names[0]\n                        if name in ('short', 'long', 'signed', 'unsigned'):\n                            prefixes[name] = prefixes.get(name, 0) + 1\n                            del names[0]\n                        else:\n                            break\n                    # ignore the 'signed' prefix below, and reorder the others\n                    newnames = []\n                    for prefix in ('unsigned', 'short', 'long'):\n                        for i in range(prefixes.get(prefix, 0)):\n                            newnames.append(prefix)\n                    if not names:\n                        names = ['int']    # implicitly\n                    if names == ['int']:   # but kill it if 'short' or 'long'\n                        if 'short' in prefixes or 'long' in prefixes:\n                            names = []\n                    names = newnames + names\n                ident = ' '.join(names)\n                if ident == 'void':\n                    return model.void_type, quals\n                if ident == '__dotdotdot__':\n                    raise FFIError(':%d: bad usage of \"...\"' %\n                            typenode.coord.line)\n                tp0, quals0 = resolve_common_type(self, ident)\n                return tp0, (quals | quals0)\n            #\n            if isinstance(type, pycparser.c_ast.Struct):\n                # 'struct foobar'\n                tp = self._get_struct_union_enum_type('struct', type, name)\n                return tp, quals\n            #\n            if isinstance(type, pycparser.c_ast.Union):\n                # 'union foobar'\n                tp = self._get_struct_union_enum_type('union', type, name)\n                return tp, quals\n            #\n            if isinstance(type, pycparser.c_ast.Enum):\n                # 'enum foobar'\n                tp = self._get_struct_union_enum_type('enum', type, name)\n                return tp, quals\n        #\n        if isinstance(typenode, pycparser.c_ast.FuncDecl):\n            # a function type\n            return self._parse_function_type(typenode, name), 0\n        #\n        # nested anonymous structs or unions end up here\n        if isinstance(typenode, pycparser.c_ast.Struct):\n            return self._get_struct_union_enum_type('struct', typenode, name,\n                                                    nested=True), 0\n        if isinstance(typenode, pycparser.c_ast.Union):\n            return self._get_struct_union_enum_type('union', typenode, name,\n                                                    nested=True), 0\n        #\n        raise FFIError(\":%d: bad or unsupported type declaration\" %\n                typenode.coord.line)\n\n    def _parse_function_type(self, typenode, funcname=None):\n        params = list(getattr(typenode.args, 'params', []))\n        for i, arg in enumerate(params):\n            if not hasattr(arg, 'type'):\n                raise CDefError(\"%s arg %d: unknown type '%s'\"\n                    \" (if you meant to use the old C syntax of giving\"\n                    \" untyped arguments, it is not supported)\"\n                    % (funcname or 'in expression', i + 1,\n                       getattr(arg, 'name', '?')))\n        ellipsis = (\n            len(params) > 0 and\n            isinstance(params[-1].type, pycparser.c_ast.TypeDecl) and\n            isinstance(params[-1].type.type,\n                       pycparser.c_ast.IdentifierType) and\n            params[-1].type.type.names == ['__dotdotdot__'])\n        if ellipsis:\n            params.pop()\n            if not params:\n                raise CDefError(\n                    \"%s: a function with only '(...)' as argument\"\n                    \" is not correct C\" % (funcname or 'in expression'))\n        args = [self._as_func_arg(*self._get_type_and_quals(argdeclnode.type))\n                for argdeclnode in params]\n        if not ellipsis and args == [model.void_type]:\n            args = []\n        result, quals = self._get_type_and_quals(typenode.type)\n        # the 'quals' on the result type are ignored.  HACK: we absure them\n        # to detect __stdcall functions: we textually replace \"__stdcall\"\n        # with \"volatile volatile const\" above.\n        abi = None\n        if hasattr(typenode.type, 'quals'): # else, probable syntax error anyway\n            if typenode.type.quals[-3:] == ['volatile', 'volatile', 'const']:\n                abi = '__stdcall'\n        return model.RawFunctionType(tuple(args), result, ellipsis, abi)\n\n    def _as_func_arg(self, type, quals):\n        if isinstance(type, model.ArrayType):\n            return model.PointerType(type.item, quals)\n        elif isinstance(type, model.RawFunctionType):\n            return type.as_function_pointer()\n        else:\n            return type\n\n    def _get_struct_union_enum_type(self, kind, type, name=None, nested=False):\n        # First, a level of caching on the exact 'type' node of the AST.\n        # This is obscure, but needed because pycparser \"unrolls\" declarations\n        # such as \"typedef struct { } foo_t, *foo_p\" and we end up with\n        # an AST that is not a tree, but a DAG, with the \"type\" node of the\n        # two branches foo_t and foo_p of the trees being the same node.\n        # It's a bit silly but detecting \"DAG-ness\" in the AST tree seems\n        # to be the only way to distinguish this case from two independent\n        # structs.  See test_struct_with_two_usages.\n        try:\n            return self._structnode2type[type]\n        except KeyError:\n            pass\n        #\n        # Note that this must handle parsing \"struct foo\" any number of\n        # times and always return the same StructType object.  Additionally,\n        # one of these times (not necessarily the first), the fields of\n        # the struct can be specified with \"struct foo { ...fields... }\".\n        # If no name is given, then we have to create a new anonymous struct\n        # with no caching; in this case, the fields are either specified\n        # right now or never.\n        #\n        force_name = name\n        name = type.name\n        #\n        # get the type or create it if needed\n        if name is None:\n            # 'force_name' is used to guess a more readable name for\n            # anonymous structs, for the common case \"typedef struct { } foo\".\n            if force_name is not None:\n                explicit_name = '$%s' % force_name\n            else:\n                self._anonymous_counter += 1\n                explicit_name = '$%d' % self._anonymous_counter\n            tp = None\n        else:\n            explicit_name = name\n            key = '%s %s' % (kind, name)\n            tp, _ = self._declarations.get(key, (None, None))\n        #\n        if tp is None:\n            if kind == 'struct':\n                tp = model.StructType(explicit_name, None, None, None)\n            elif kind == 'union':\n                tp = model.UnionType(explicit_name, None, None, None)\n            elif kind == 'enum':\n                if explicit_name == '__dotdotdot__':\n                    raise CDefError(\"Enums cannot be declared with ...\")\n                tp = self._build_enum_type(explicit_name, type.values)\n            else:\n                raise AssertionError(\"kind = %r\" % (kind,))\n            if name is not None:\n                self._declare(key, tp)\n        else:\n            if kind == 'enum' and type.values is not None:\n                raise NotImplementedError(\n                    \"enum %s: the '{}' declaration should appear on the first \"\n                    \"time the enum is mentioned, not later\" % explicit_name)\n        if not tp.forcename:\n            tp.force_the_name(force_name)\n        if tp.forcename and '$' in tp.name:\n            self._declare('anonymous %s' % tp.forcename, tp)\n        #\n        self._structnode2type[type] = tp\n        #\n        # enums: done here\n        if kind == 'enum':\n            return tp\n        #\n        # is there a 'type.decls'?  If yes, then this is the place in the\n        # C sources that declare the fields.  If no, then just return the\n        # existing type, possibly still incomplete.\n        if type.decls is None:\n            return tp\n        #\n        if tp.fldnames is not None:\n            raise CDefError(\"duplicate declaration of struct %s\" % name)\n        fldnames = []\n        fldtypes = []\n        fldbitsize = []\n        fldquals = []\n        for decl in type.decls:\n            if (isinstance(decl.type, pycparser.c_ast.IdentifierType) and\n                    ''.join(decl.type.names) == '__dotdotdot__'):\n                # XXX pycparser is inconsistent: 'names' should be a list\n                # of strings, but is sometimes just one string.  Use\n                # str.join() as a way to cope with both.\n                self._make_partial(tp, nested)\n                continue\n            if decl.bitsize is None:\n                bitsize = -1\n            else:\n                bitsize = self._parse_constant(decl.bitsize)\n            self._partial_length = False\n            type, fqual = self._get_type_and_quals(decl.type,\n                                                   partial_length_ok=True)\n            if self._partial_length:\n                self._make_partial(tp, nested)\n            if isinstance(type, model.StructType) and type.partial:\n                self._make_partial(tp, nested)\n            fldnames.append(decl.name or '')\n            fldtypes.append(type)\n            fldbitsize.append(bitsize)\n            fldquals.append(fqual)\n        tp.fldnames = tuple(fldnames)\n        tp.fldtypes = tuple(fldtypes)\n        tp.fldbitsize = tuple(fldbitsize)\n        tp.fldquals = tuple(fldquals)\n        if fldbitsize != [-1] * len(fldbitsize):\n            if isinstance(tp, model.StructType) and tp.partial:\n                raise NotImplementedError(\"%s: using both bitfields and '...;'\"\n                                          % (tp,))\n        tp.packed = self._options.get('packed')\n        if tp.completed:    # must be re-completed: it is not opaque any more\n            tp.completed = 0\n            self._recomplete.append(tp)\n        return tp\n\n    def _make_partial(self, tp, nested):\n        if not isinstance(tp, model.StructOrUnion):\n            raise CDefError(\"%s cannot be partial\" % (tp,))\n        if not tp.has_c_name() and not nested:\n            raise NotImplementedError(\"%s is partial but has no C name\" %(tp,))\n        tp.partial = True\n\n    def _parse_constant(self, exprnode, partial_length_ok=False):\n        # for now, limited to expressions that are an immediate number\n        # or positive/negative number\n        if isinstance(exprnode, pycparser.c_ast.Constant):\n            s = exprnode.value\n            if '0' <= s[0] <= '9':\n                s = s.rstrip('uUlL')\n                try:\n                    if s.startswith('0'):\n                        return int(s, 8)\n                    else:\n                        return int(s, 10)\n                except ValueError:\n                    if len(s) > 1:\n                        if s.lower()[0:2] == '0x':\n                            return int(s, 16)\n                        elif s.lower()[0:2] == '0b':\n                            return int(s, 2)\n                raise CDefError(\"invalid constant %r\" % (s,))\n            elif s[0] == \"'\" and s[-1] == \"'\" and (\n                    len(s) == 3 or (len(s) == 4 and s[1] == \"\\\\\")):\n                return ord(s[-2])\n            else:\n                raise CDefError(\"invalid constant %r\" % (s,))\n        #\n        if (isinstance(exprnode, pycparser.c_ast.UnaryOp) and\n                exprnode.op == '+'):\n            return self._parse_constant(exprnode.expr)\n        #\n        if (isinstance(exprnode, pycparser.c_ast.UnaryOp) and\n                exprnode.op == '-'):\n            return -self._parse_constant(exprnode.expr)\n        # load previously defined int constant\n        if (isinstance(exprnode, pycparser.c_ast.ID) and\n                exprnode.name in self._int_constants):\n            return self._int_constants[exprnode.name]\n        #\n        if (isinstance(exprnode, pycparser.c_ast.ID) and\n                    exprnode.name == '__dotdotdotarray__'):\n            if partial_length_ok:\n                self._partial_length = True\n                return '...'\n            raise FFIError(\":%d: unsupported '[...]' here, cannot derive \"\n                           \"the actual array length in this context\"\n                           % exprnode.coord.line)\n        #\n        if isinstance(exprnode, pycparser.c_ast.BinaryOp):\n            left = self._parse_constant(exprnode.left)\n            right = self._parse_constant(exprnode.right)\n            if exprnode.op == '+':\n                return left + right\n            elif exprnode.op == '-':\n                return left - right\n            elif exprnode.op == '*':\n                return left * right\n            elif exprnode.op == '/':\n                return self._c_div(left, right)\n            elif exprnode.op == '%':\n                return left - self._c_div(left, right) * right\n            elif exprnode.op == '<<':\n                return left << right\n            elif exprnode.op == '>>':\n                return left >> right\n            elif exprnode.op == '&':\n                return left & right\n            elif exprnode.op == '|':\n                return left | right\n            elif exprnode.op == '^':\n                return left ^ right\n        #\n        raise FFIError(\":%d: unsupported expression: expected a \"\n                       \"simple numeric constant\" % exprnode.coord.line)\n\n    def _c_div(self, a, b):\n        result = a // b\n        if ((a < 0) ^ (b < 0)) and (a % b) != 0:\n            result += 1\n        return result\n\n    def _build_enum_type(self, explicit_name, decls):\n        if decls is not None:\n            partial = False\n            enumerators = []\n            enumvalues = []\n            nextenumvalue = 0\n            for enum in decls.enumerators:\n                if _r_enum_dotdotdot.match(enum.name):\n                    partial = True\n                    continue\n                if enum.value is not None:\n                    nextenumvalue = self._parse_constant(enum.value)\n                enumerators.append(enum.name)\n                enumvalues.append(nextenumvalue)\n                self._add_constants(enum.name, nextenumvalue)\n                nextenumvalue += 1\n            enumerators = tuple(enumerators)\n            enumvalues = tuple(enumvalues)\n            tp = model.EnumType(explicit_name, enumerators, enumvalues)\n            tp.partial = partial\n        else:   # opaque enum\n            tp = model.EnumType(explicit_name, (), ())\n        return tp\n\n    def include(self, other):\n        for name, (tp, quals) in other._declarations.items():\n            if name.startswith('anonymous $enum_$'):\n                continue   # fix for test_anonymous_enum_include\n            kind = name.split(' ', 1)[0]\n            if kind in ('struct', 'union', 'enum', 'anonymous', 'typedef'):\n                self._declare(name, tp, included=True, quals=quals)\n        for k, v in other._int_constants.items():\n            self._add_constants(k, v)\n\n    def _get_unknown_type(self, decl):\n        typenames = decl.type.type.names\n        if typenames == ['__dotdotdot__']:\n            return model.unknown_type(decl.name)\n\n        if typenames == ['__dotdotdotint__']:\n            if self._uses_new_feature is None:\n                self._uses_new_feature = \"'typedef int... %s'\" % decl.name\n            return model.UnknownIntegerType(decl.name)\n\n        if typenames == ['__dotdotdotfloat__']:\n            # note: not for 'long double' so far\n            if self._uses_new_feature is None:\n                self._uses_new_feature = \"'typedef float... %s'\" % decl.name\n            return model.UnknownFloatType(decl.name)\n\n        raise FFIError(':%d: unsupported usage of \"...\" in typedef'\n                       % decl.coord.line)\n\n    def _get_unknown_ptr_type(self, decl):\n        if decl.type.type.type.names == ['__dotdotdot__']:\n            return model.unknown_ptr_type(decl.name)\n        raise FFIError(':%d: unsupported usage of \"...\" in typedef'\n                       % decl.coord.line)\n", "src/cffi/backend_ctypes.py": "import ctypes, ctypes.util, operator, sys\nfrom . import model\n\nif sys.version_info < (3,):\n    bytechr = chr\nelse:\n    unicode = str\n    long = int\n    xrange = range\n    bytechr = lambda num: bytes([num])\n\nclass CTypesType(type):\n    pass\n\nclass CTypesData(object):\n    __metaclass__ = CTypesType\n    __slots__ = ['__weakref__']\n    __name__ = '<cdata>'\n\n    def __init__(self, *args):\n        raise TypeError(\"cannot instantiate %r\" % (self.__class__,))\n\n    @classmethod\n    def _newp(cls, init):\n        raise TypeError(\"expected a pointer or array ctype, got '%s'\"\n                        % (cls._get_c_name(),))\n\n    @staticmethod\n    def _to_ctypes(value):\n        raise TypeError\n\n    @classmethod\n    def _arg_to_ctypes(cls, *value):\n        try:\n            ctype = cls._ctype\n        except AttributeError:\n            raise TypeError(\"cannot create an instance of %r\" % (cls,))\n        if value:\n            res = cls._to_ctypes(*value)\n            if not isinstance(res, ctype):\n                res = cls._ctype(res)\n        else:\n            res = cls._ctype()\n        return res\n\n    @classmethod\n    def _create_ctype_obj(cls, init):\n        if init is None:\n            return cls._arg_to_ctypes()\n        else:\n            return cls._arg_to_ctypes(init)\n\n    @staticmethod\n    def _from_ctypes(ctypes_value):\n        raise TypeError\n\n    @classmethod\n    def _get_c_name(cls, replace_with=''):\n        return cls._reftypename.replace(' &', replace_with)\n\n    @classmethod\n    def _fix_class(cls):\n        cls.__name__ = 'CData<%s>' % (cls._get_c_name(),)\n        cls.__qualname__ = 'CData<%s>' % (cls._get_c_name(),)\n        cls.__module__ = 'ffi'\n\n    def _get_own_repr(self):\n        raise NotImplementedError\n\n    def _addr_repr(self, address):\n        if address == 0:\n            return 'NULL'\n        else:\n            if address < 0:\n                address += 1 << (8*ctypes.sizeof(ctypes.c_void_p))\n            return '0x%x' % address\n\n    def __repr__(self, c_name=None):\n        own = self._get_own_repr()\n        return '<cdata %r %s>' % (c_name or self._get_c_name(), own)\n\n    def _convert_to_address(self, BClass):\n        if BClass is None:\n            raise TypeError(\"cannot convert %r to an address\" % (\n                self._get_c_name(),))\n        else:\n            raise TypeError(\"cannot convert %r to %r\" % (\n                self._get_c_name(), BClass._get_c_name()))\n\n    @classmethod\n    def _get_size(cls):\n        return ctypes.sizeof(cls._ctype)\n\n    def _get_size_of_instance(self):\n        return ctypes.sizeof(self._ctype)\n\n    @classmethod\n    def _cast_from(cls, source):\n        raise TypeError(\"cannot cast to %r\" % (cls._get_c_name(),))\n\n    def _cast_to_integer(self):\n        return self._convert_to_address(None)\n\n    @classmethod\n    def _alignment(cls):\n        return ctypes.alignment(cls._ctype)\n\n    def __iter__(self):\n        raise TypeError(\"cdata %r does not support iteration\" % (\n            self._get_c_name()),)\n\n    def _make_cmp(name):\n        cmpfunc = getattr(operator, name)\n        def cmp(self, other):\n            v_is_ptr = not isinstance(self, CTypesGenericPrimitive)\n            w_is_ptr = (isinstance(other, CTypesData) and\n                           not isinstance(other, CTypesGenericPrimitive))\n            if v_is_ptr and w_is_ptr:\n                return cmpfunc(self._convert_to_address(None),\n                               other._convert_to_address(None))\n            elif v_is_ptr or w_is_ptr:\n                return NotImplemented\n            else:\n                if isinstance(self, CTypesGenericPrimitive):\n                    self = self._value\n                if isinstance(other, CTypesGenericPrimitive):\n                    other = other._value\n                return cmpfunc(self, other)\n        cmp.func_name = name\n        return cmp\n\n    __eq__ = _make_cmp('__eq__')\n    __ne__ = _make_cmp('__ne__')\n    __lt__ = _make_cmp('__lt__')\n    __le__ = _make_cmp('__le__')\n    __gt__ = _make_cmp('__gt__')\n    __ge__ = _make_cmp('__ge__')\n\n    def __hash__(self):\n        return hash(self._convert_to_address(None))\n\n    def _to_string(self, maxlen):\n        raise TypeError(\"string(): %r\" % (self,))\n\n\nclass CTypesGenericPrimitive(CTypesData):\n    __slots__ = []\n\n    def __hash__(self):\n        return hash(self._value)\n\n    def _get_own_repr(self):\n        return repr(self._from_ctypes(self._value))\n\n\nclass CTypesGenericArray(CTypesData):\n    __slots__ = []\n\n    @classmethod\n    def _newp(cls, init):\n        return cls(init)\n\n    def __iter__(self):\n        for i in xrange(len(self)):\n            yield self[i]\n\n    def _get_own_repr(self):\n        return self._addr_repr(ctypes.addressof(self._blob))\n\n\nclass CTypesGenericPtr(CTypesData):\n    __slots__ = ['_address', '_as_ctype_ptr']\n    _automatic_casts = False\n    kind = \"pointer\"\n\n    @classmethod\n    def _newp(cls, init):\n        return cls(init)\n\n    @classmethod\n    def _cast_from(cls, source):\n        if source is None:\n            address = 0\n        elif isinstance(source, CTypesData):\n            address = source._cast_to_integer()\n        elif isinstance(source, (int, long)):\n            address = source\n        else:\n            raise TypeError(\"bad type for cast to %r: %r\" %\n                            (cls, type(source).__name__))\n        return cls._new_pointer_at(address)\n\n    @classmethod\n    def _new_pointer_at(cls, address):\n        self = cls.__new__(cls)\n        self._address = address\n        self._as_ctype_ptr = ctypes.cast(address, cls._ctype)\n        return self\n\n    def _get_own_repr(self):\n        try:\n            return self._addr_repr(self._address)\n        except AttributeError:\n            return '???'\n\n    def _cast_to_integer(self):\n        return self._address\n\n    def __nonzero__(self):\n        return bool(self._address)\n    __bool__ = __nonzero__\n\n    @classmethod\n    def _to_ctypes(cls, value):\n        if not isinstance(value, CTypesData):\n            raise TypeError(\"unexpected %s object\" % type(value).__name__)\n        address = value._convert_to_address(cls)\n        return ctypes.cast(address, cls._ctype)\n\n    @classmethod\n    def _from_ctypes(cls, ctypes_ptr):\n        address = ctypes.cast(ctypes_ptr, ctypes.c_void_p).value or 0\n        return cls._new_pointer_at(address)\n\n    @classmethod\n    def _initialize(cls, ctypes_ptr, value):\n        if value:\n            ctypes_ptr.contents = cls._to_ctypes(value).contents\n\n    def _convert_to_address(self, BClass):\n        if (BClass in (self.__class__, None) or BClass._automatic_casts\n            or self._automatic_casts):\n            return self._address\n        else:\n            return CTypesData._convert_to_address(self, BClass)\n\n\nclass CTypesBaseStructOrUnion(CTypesData):\n    __slots__ = ['_blob']\n\n    @classmethod\n    def _create_ctype_obj(cls, init):\n        # may be overridden\n        raise TypeError(\"cannot instantiate opaque type %s\" % (cls,))\n\n    def _get_own_repr(self):\n        return self._addr_repr(ctypes.addressof(self._blob))\n\n    @classmethod\n    def _offsetof(cls, fieldname):\n        return getattr(cls._ctype, fieldname).offset\n\n    def _convert_to_address(self, BClass):\n        if getattr(BClass, '_BItem', None) is self.__class__:\n            return ctypes.addressof(self._blob)\n        else:\n            return CTypesData._convert_to_address(self, BClass)\n\n    @classmethod\n    def _from_ctypes(cls, ctypes_struct_or_union):\n        self = cls.__new__(cls)\n        self._blob = ctypes_struct_or_union\n        return self\n\n    @classmethod\n    def _to_ctypes(cls, value):\n        return value._blob\n\n    def __repr__(self, c_name=None):\n        return CTypesData.__repr__(self, c_name or self._get_c_name(' &'))\n\n\nclass CTypesBackend(object):\n\n    PRIMITIVE_TYPES = {\n        'char': ctypes.c_char,\n        'short': ctypes.c_short,\n        'int': ctypes.c_int,\n        'long': ctypes.c_long,\n        'long long': ctypes.c_longlong,\n        'signed char': ctypes.c_byte,\n        'unsigned char': ctypes.c_ubyte,\n        'unsigned short': ctypes.c_ushort,\n        'unsigned int': ctypes.c_uint,\n        'unsigned long': ctypes.c_ulong,\n        'unsigned long long': ctypes.c_ulonglong,\n        'float': ctypes.c_float,\n        'double': ctypes.c_double,\n        '_Bool': ctypes.c_bool,\n        }\n\n    for _name in ['unsigned long long', 'unsigned long',\n                  'unsigned int', 'unsigned short', 'unsigned char']:\n        _size = ctypes.sizeof(PRIMITIVE_TYPES[_name])\n        PRIMITIVE_TYPES['uint%d_t' % (8*_size)] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_void_p):\n            PRIMITIVE_TYPES['uintptr_t'] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_size_t):\n            PRIMITIVE_TYPES['size_t'] = PRIMITIVE_TYPES[_name]\n\n    for _name in ['long long', 'long', 'int', 'short', 'signed char']:\n        _size = ctypes.sizeof(PRIMITIVE_TYPES[_name])\n        PRIMITIVE_TYPES['int%d_t' % (8*_size)] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_void_p):\n            PRIMITIVE_TYPES['intptr_t'] = PRIMITIVE_TYPES[_name]\n            PRIMITIVE_TYPES['ptrdiff_t'] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_size_t):\n            PRIMITIVE_TYPES['ssize_t'] = PRIMITIVE_TYPES[_name]\n\n\n    def __init__(self):\n        self.RTLD_LAZY = 0   # not supported anyway by ctypes\n        self.RTLD_NOW  = 0\n        self.RTLD_GLOBAL = ctypes.RTLD_GLOBAL\n        self.RTLD_LOCAL = ctypes.RTLD_LOCAL\n\n    def set_ffi(self, ffi):\n        self.ffi = ffi\n\n    def _get_types(self):\n        return CTypesData, CTypesType\n\n    def load_library(self, path, flags=0):\n        cdll = ctypes.CDLL(path, flags)\n        return CTypesLibrary(self, cdll)\n\n    def new_void_type(self):\n        class CTypesVoid(CTypesData):\n            __slots__ = []\n            _reftypename = 'void &'\n            @staticmethod\n            def _from_ctypes(novalue):\n                return None\n            @staticmethod\n            def _to_ctypes(novalue):\n                if novalue is not None:\n                    raise TypeError(\"None expected, got %s object\" %\n                                    (type(novalue).__name__,))\n                return None\n        CTypesVoid._fix_class()\n        return CTypesVoid\n\n    def new_primitive_type(self, name):\n        if name == 'wchar_t':\n            raise NotImplementedError(name)\n        ctype = self.PRIMITIVE_TYPES[name]\n        if name == 'char':\n            kind = 'char'\n        elif name in ('float', 'double'):\n            kind = 'float'\n        else:\n            if name in ('signed char', 'unsigned char'):\n                kind = 'byte'\n            elif name == '_Bool':\n                kind = 'bool'\n            else:\n                kind = 'int'\n            is_signed = (ctype(-1).value == -1)\n        #\n        def _cast_source_to_int(source):\n            if isinstance(source, (int, long, float)):\n                source = int(source)\n            elif isinstance(source, CTypesData):\n                source = source._cast_to_integer()\n            elif isinstance(source, bytes):\n                source = ord(source)\n            elif source is None:\n                source = 0\n            else:\n                raise TypeError(\"bad type for cast to %r: %r\" %\n                                (CTypesPrimitive, type(source).__name__))\n            return source\n        #\n        kind1 = kind\n        class CTypesPrimitive(CTypesGenericPrimitive):\n            __slots__ = ['_value']\n            _ctype = ctype\n            _reftypename = '%s &' % name\n            kind = kind1\n\n            def __init__(self, value):\n                self._value = value\n\n            @staticmethod\n            def _create_ctype_obj(init):\n                if init is None:\n                    return ctype()\n                return ctype(CTypesPrimitive._to_ctypes(init))\n\n            if kind == 'int' or kind == 'byte':\n                @classmethod\n                def _cast_from(cls, source):\n                    source = _cast_source_to_int(source)\n                    source = ctype(source).value     # cast within range\n                    return cls(source)\n                def __int__(self):\n                    return self._value\n\n            if kind == 'bool':\n                @classmethod\n                def _cast_from(cls, source):\n                    if not isinstance(source, (int, long, float)):\n                        source = _cast_source_to_int(source)\n                    return cls(bool(source))\n                def __int__(self):\n                    return int(self._value)\n\n            if kind == 'char':\n                @classmethod\n                def _cast_from(cls, source):\n                    source = _cast_source_to_int(source)\n                    source = bytechr(source & 0xFF)\n                    return cls(source)\n                def __int__(self):\n                    return ord(self._value)\n\n            if kind == 'float':\n                @classmethod\n                def _cast_from(cls, source):\n                    if isinstance(source, float):\n                        pass\n                    elif isinstance(source, CTypesGenericPrimitive):\n                        if hasattr(source, '__float__'):\n                            source = float(source)\n                        else:\n                            source = int(source)\n                    else:\n                        source = _cast_source_to_int(source)\n                    source = ctype(source).value     # fix precision\n                    return cls(source)\n                def __int__(self):\n                    return int(self._value)\n                def __float__(self):\n                    return self._value\n\n            _cast_to_integer = __int__\n\n            if kind == 'int' or kind == 'byte' or kind == 'bool':\n                @staticmethod\n                def _to_ctypes(x):\n                    if not isinstance(x, (int, long)):\n                        if isinstance(x, CTypesData):\n                            x = int(x)\n                        else:\n                            raise TypeError(\"integer expected, got %s\" %\n                                            type(x).__name__)\n                    if ctype(x).value != x:\n                        if not is_signed and x < 0:\n                            raise OverflowError(\"%s: negative integer\" % name)\n                        else:\n                            raise OverflowError(\"%s: integer out of bounds\"\n                                                % name)\n                    return x\n\n            if kind == 'char':\n                @staticmethod\n                def _to_ctypes(x):\n                    if isinstance(x, bytes) and len(x) == 1:\n                        return x\n                    if isinstance(x, CTypesPrimitive):    # <CData <char>>\n                        return x._value\n                    raise TypeError(\"character expected, got %s\" %\n                                    type(x).__name__)\n                def __nonzero__(self):\n                    return ord(self._value) != 0\n            else:\n                def __nonzero__(self):\n                    return self._value != 0\n            __bool__ = __nonzero__\n\n            if kind == 'float':\n                @staticmethod\n                def _to_ctypes(x):\n                    if not isinstance(x, (int, long, float, CTypesData)):\n                        raise TypeError(\"float expected, got %s\" %\n                                        type(x).__name__)\n                    return ctype(x).value\n\n            @staticmethod\n            def _from_ctypes(value):\n                return getattr(value, 'value', value)\n\n            @staticmethod\n            def _initialize(blob, init):\n                blob.value = CTypesPrimitive._to_ctypes(init)\n\n            if kind == 'char':\n                def _to_string(self, maxlen):\n                    return self._value\n            if kind == 'byte':\n                def _to_string(self, maxlen):\n                    return chr(self._value & 0xff)\n        #\n        CTypesPrimitive._fix_class()\n        return CTypesPrimitive\n\n    def new_pointer_type(self, BItem):\n        getbtype = self.ffi._get_cached_btype\n        if BItem is getbtype(model.PrimitiveType('char')):\n            kind = 'charp'\n        elif BItem in (getbtype(model.PrimitiveType('signed char')),\n                       getbtype(model.PrimitiveType('unsigned char'))):\n            kind = 'bytep'\n        elif BItem is getbtype(model.void_type):\n            kind = 'voidp'\n        else:\n            kind = 'generic'\n        #\n        class CTypesPtr(CTypesGenericPtr):\n            __slots__ = ['_own']\n            if kind == 'charp':\n                __slots__ += ['__as_strbuf']\n            _BItem = BItem\n            if hasattr(BItem, '_ctype'):\n                _ctype = ctypes.POINTER(BItem._ctype)\n                _bitem_size = ctypes.sizeof(BItem._ctype)\n            else:\n                _ctype = ctypes.c_void_p\n            if issubclass(BItem, CTypesGenericArray):\n                _reftypename = BItem._get_c_name('(* &)')\n            else:\n                _reftypename = BItem._get_c_name(' * &')\n\n            def __init__(self, init):\n                ctypeobj = BItem._create_ctype_obj(init)\n                if kind == 'charp':\n                    self.__as_strbuf = ctypes.create_string_buffer(\n                        ctypeobj.value + b'\\x00')\n                    self._as_ctype_ptr = ctypes.cast(\n                        self.__as_strbuf, self._ctype)\n                else:\n                    self._as_ctype_ptr = ctypes.pointer(ctypeobj)\n                self._address = ctypes.cast(self._as_ctype_ptr,\n                                            ctypes.c_void_p).value\n                self._own = True\n\n            def __add__(self, other):\n                if isinstance(other, (int, long)):\n                    return self._new_pointer_at(self._address +\n                                                other * self._bitem_size)\n                else:\n                    return NotImplemented\n\n            def __sub__(self, other):\n                if isinstance(other, (int, long)):\n                    return self._new_pointer_at(self._address -\n                                                other * self._bitem_size)\n                elif type(self) is type(other):\n                    return (self._address - other._address) // self._bitem_size\n                else:\n                    return NotImplemented\n\n            def __getitem__(self, index):\n                if getattr(self, '_own', False) and index != 0:\n                    raise IndexError\n                return BItem._from_ctypes(self._as_ctype_ptr[index])\n\n            def __setitem__(self, index, value):\n                self._as_ctype_ptr[index] = BItem._to_ctypes(value)\n\n            if kind == 'charp' or kind == 'voidp':\n                @classmethod\n                def _arg_to_ctypes(cls, *value):\n                    if value and isinstance(value[0], bytes):\n                        return ctypes.c_char_p(value[0])\n                    else:\n                        return super(CTypesPtr, cls)._arg_to_ctypes(*value)\n\n            if kind == 'charp' or kind == 'bytep':\n                def _to_string(self, maxlen):\n                    if maxlen < 0:\n                        maxlen = sys.maxsize\n                    p = ctypes.cast(self._as_ctype_ptr,\n                                    ctypes.POINTER(ctypes.c_char))\n                    n = 0\n                    while n < maxlen and p[n] != b'\\x00':\n                        n += 1\n                    return b''.join([p[i] for i in range(n)])\n\n            def _get_own_repr(self):\n                if getattr(self, '_own', False):\n                    return 'owning %d bytes' % (\n                        ctypes.sizeof(self._as_ctype_ptr.contents),)\n                return super(CTypesPtr, self)._get_own_repr()\n        #\n        if (BItem is self.ffi._get_cached_btype(model.void_type) or\n            BItem is self.ffi._get_cached_btype(model.PrimitiveType('char'))):\n            CTypesPtr._automatic_casts = True\n        #\n        CTypesPtr._fix_class()\n        return CTypesPtr\n\n    def new_array_type(self, CTypesPtr, length):\n        if length is None:\n            brackets = ' &[]'\n        else:\n            brackets = ' &[%d]' % length\n        BItem = CTypesPtr._BItem\n        getbtype = self.ffi._get_cached_btype\n        if BItem is getbtype(model.PrimitiveType('char')):\n            kind = 'char'\n        elif BItem in (getbtype(model.PrimitiveType('signed char')),\n                       getbtype(model.PrimitiveType('unsigned char'))):\n            kind = 'byte'\n        else:\n            kind = 'generic'\n        #\n        class CTypesArray(CTypesGenericArray):\n            __slots__ = ['_blob', '_own']\n            if length is not None:\n                _ctype = BItem._ctype * length\n            else:\n                __slots__.append('_ctype')\n            _reftypename = BItem._get_c_name(brackets)\n            _declared_length = length\n            _CTPtr = CTypesPtr\n\n            def __init__(self, init):\n                if length is None:\n                    if isinstance(init, (int, long)):\n                        len1 = init\n                        init = None\n                    elif kind == 'char' and isinstance(init, bytes):\n                        len1 = len(init) + 1    # extra null\n                    else:\n                        init = tuple(init)\n                        len1 = len(init)\n                    self._ctype = BItem._ctype * len1\n                self._blob = self._ctype()\n                self._own = True\n                if init is not None:\n                    self._initialize(self._blob, init)\n\n            @staticmethod\n            def _initialize(blob, init):\n                if isinstance(init, bytes):\n                    init = [init[i:i+1] for i in range(len(init))]\n                else:\n                    if isinstance(init, CTypesGenericArray):\n                        if (len(init) != len(blob) or\n                            not isinstance(init, CTypesArray)):\n                            raise TypeError(\"length/type mismatch: %s\" % (init,))\n                    init = tuple(init)\n                if len(init) > len(blob):\n                    raise IndexError(\"too many initializers\")\n                addr = ctypes.cast(blob, ctypes.c_void_p).value\n                PTR = ctypes.POINTER(BItem._ctype)\n                itemsize = ctypes.sizeof(BItem._ctype)\n                for i, value in enumerate(init):\n                    p = ctypes.cast(addr + i * itemsize, PTR)\n                    BItem._initialize(p.contents, value)\n\n            def __len__(self):\n                return len(self._blob)\n\n            def __getitem__(self, index):\n                if not (0 <= index < len(self._blob)):\n                    raise IndexError\n                return BItem._from_ctypes(self._blob[index])\n\n            def __setitem__(self, index, value):\n                if not (0 <= index < len(self._blob)):\n                    raise IndexError\n                self._blob[index] = BItem._to_ctypes(value)\n\n            if kind == 'char' or kind == 'byte':\n                def _to_string(self, maxlen):\n                    if maxlen < 0:\n                        maxlen = len(self._blob)\n                    p = ctypes.cast(self._blob,\n                                    ctypes.POINTER(ctypes.c_char))\n                    n = 0\n                    while n < maxlen and p[n] != b'\\x00':\n                        n += 1\n                    return b''.join([p[i] for i in range(n)])\n\n            def _get_own_repr(self):\n                if getattr(self, '_own', False):\n                    return 'owning %d bytes' % (ctypes.sizeof(self._blob),)\n                return super(CTypesArray, self)._get_own_repr()\n\n            def _convert_to_address(self, BClass):\n                if BClass in (CTypesPtr, None) or BClass._automatic_casts:\n                    return ctypes.addressof(self._blob)\n                else:\n                    return CTypesData._convert_to_address(self, BClass)\n\n            @staticmethod\n            def _from_ctypes(ctypes_array):\n                self = CTypesArray.__new__(CTypesArray)\n                self._blob = ctypes_array\n                return self\n\n            @staticmethod\n            def _arg_to_ctypes(value):\n                return CTypesPtr._arg_to_ctypes(value)\n\n            def __add__(self, other):\n                if isinstance(other, (int, long)):\n                    return CTypesPtr._new_pointer_at(\n                        ctypes.addressof(self._blob) +\n                        other * ctypes.sizeof(BItem._ctype))\n                else:\n                    return NotImplemented\n\n            @classmethod\n            def _cast_from(cls, source):\n                raise NotImplementedError(\"casting to %r\" % (\n                    cls._get_c_name(),))\n        #\n        CTypesArray._fix_class()\n        return CTypesArray\n\n    def _new_struct_or_union(self, kind, name, base_ctypes_class):\n        #\n        class struct_or_union(base_ctypes_class):\n            pass\n        struct_or_union.__name__ = '%s_%s' % (kind, name)\n        kind1 = kind\n        #\n        class CTypesStructOrUnion(CTypesBaseStructOrUnion):\n            __slots__ = ['_blob']\n            _ctype = struct_or_union\n            _reftypename = '%s &' % (name,)\n            _kind = kind = kind1\n        #\n        CTypesStructOrUnion._fix_class()\n        return CTypesStructOrUnion\n\n    def new_struct_type(self, name):\n        return self._new_struct_or_union('struct', name, ctypes.Structure)\n\n    def new_union_type(self, name):\n        return self._new_struct_or_union('union', name, ctypes.Union)\n\n    def complete_struct_or_union(self, CTypesStructOrUnion, fields, tp,\n                                 totalsize=-1, totalalignment=-1, sflags=0,\n                                 pack=0):\n        if totalsize >= 0 or totalalignment >= 0:\n            raise NotImplementedError(\"the ctypes backend of CFFI does not support \"\n                                      \"structures completed by verify(); please \"\n                                      \"compile and install the _cffi_backend module.\")\n        struct_or_union = CTypesStructOrUnion._ctype\n        fnames = [fname for (fname, BField, bitsize) in fields]\n        btypes = [BField for (fname, BField, bitsize) in fields]\n        bitfields = [bitsize for (fname, BField, bitsize) in fields]\n        #\n        bfield_types = {}\n        cfields = []\n        for (fname, BField, bitsize) in fields:\n            if bitsize < 0:\n                cfields.append((fname, BField._ctype))\n                bfield_types[fname] = BField\n            else:\n                cfields.append((fname, BField._ctype, bitsize))\n                bfield_types[fname] = Ellipsis\n        if sflags & 8:\n            struct_or_union._pack_ = 1\n        elif pack:\n            struct_or_union._pack_ = pack\n        struct_or_union._fields_ = cfields\n        CTypesStructOrUnion._bfield_types = bfield_types\n        #\n        @staticmethod\n        def _create_ctype_obj(init):\n            result = struct_or_union()\n            if init is not None:\n                initialize(result, init)\n            return result\n        CTypesStructOrUnion._create_ctype_obj = _create_ctype_obj\n        #\n        def initialize(blob, init):\n            if is_union:\n                if len(init) > 1:\n                    raise ValueError(\"union initializer: %d items given, but \"\n                                    \"only one supported (use a dict if needed)\"\n                                     % (len(init),))\n            if not isinstance(init, dict):\n                if isinstance(init, (bytes, unicode)):\n                    raise TypeError(\"union initializer: got a str\")\n                init = tuple(init)\n                if len(init) > len(fnames):\n                    raise ValueError(\"too many values for %s initializer\" %\n                                     CTypesStructOrUnion._get_c_name())\n                init = dict(zip(fnames, init))\n            addr = ctypes.addressof(blob)\n            for fname, value in init.items():\n                BField, bitsize = name2fieldtype[fname]\n                assert bitsize < 0, \\\n                       \"not implemented: initializer with bit fields\"\n                offset = CTypesStructOrUnion._offsetof(fname)\n                PTR = ctypes.POINTER(BField._ctype)\n                p = ctypes.cast(addr + offset, PTR)\n                BField._initialize(p.contents, value)\n        is_union = CTypesStructOrUnion._kind == 'union'\n        name2fieldtype = dict(zip(fnames, zip(btypes, bitfields)))\n        #\n        for fname, BField, bitsize in fields:\n            if fname == '':\n                raise NotImplementedError(\"nested anonymous structs/unions\")\n            if hasattr(CTypesStructOrUnion, fname):\n                raise ValueError(\"the field name %r conflicts in \"\n                                 \"the ctypes backend\" % fname)\n            if bitsize < 0:\n                def getter(self, fname=fname, BField=BField,\n                           offset=CTypesStructOrUnion._offsetof(fname),\n                           PTR=ctypes.POINTER(BField._ctype)):\n                    addr = ctypes.addressof(self._blob)\n                    p = ctypes.cast(addr + offset, PTR)\n                    return BField._from_ctypes(p.contents)\n                def setter(self, value, fname=fname, BField=BField):\n                    setattr(self._blob, fname, BField._to_ctypes(value))\n                #\n                if issubclass(BField, CTypesGenericArray):\n                    setter = None\n                    if BField._declared_length == 0:\n                        def getter(self, fname=fname, BFieldPtr=BField._CTPtr,\n                                   offset=CTypesStructOrUnion._offsetof(fname),\n                                   PTR=ctypes.POINTER(BField._ctype)):\n                            addr = ctypes.addressof(self._blob)\n                            p = ctypes.cast(addr + offset, PTR)\n                            return BFieldPtr._from_ctypes(p)\n                #\n            else:\n                def getter(self, fname=fname, BField=BField):\n                    return BField._from_ctypes(getattr(self._blob, fname))\n                def setter(self, value, fname=fname, BField=BField):\n                    # xxx obscure workaround\n                    value = BField._to_ctypes(value)\n                    oldvalue = getattr(self._blob, fname)\n                    setattr(self._blob, fname, value)\n                    if value != getattr(self._blob, fname):\n                        setattr(self._blob, fname, oldvalue)\n                        raise OverflowError(\"value too large for bitfield\")\n            setattr(CTypesStructOrUnion, fname, property(getter, setter))\n        #\n        CTypesPtr = self.ffi._get_cached_btype(model.PointerType(tp))\n        for fname in fnames:\n            if hasattr(CTypesPtr, fname):\n                raise ValueError(\"the field name %r conflicts in \"\n                                 \"the ctypes backend\" % fname)\n            def getter(self, fname=fname):\n                return getattr(self[0], fname)\n            def setter(self, value, fname=fname):\n                setattr(self[0], fname, value)\n            setattr(CTypesPtr, fname, property(getter, setter))\n\n    def new_function_type(self, BArgs, BResult, has_varargs):\n        nameargs = [BArg._get_c_name() for BArg in BArgs]\n        if has_varargs:\n            nameargs.append('...')\n        nameargs = ', '.join(nameargs)\n        #\n        class CTypesFunctionPtr(CTypesGenericPtr):\n            __slots__ = ['_own_callback', '_name']\n            _ctype = ctypes.CFUNCTYPE(getattr(BResult, '_ctype', None),\n                                      *[BArg._ctype for BArg in BArgs],\n                                      use_errno=True)\n            _reftypename = BResult._get_c_name('(* &)(%s)' % (nameargs,))\n\n            def __init__(self, init, error=None):\n                # create a callback to the Python callable init()\n                import traceback\n                assert not has_varargs, \"varargs not supported for callbacks\"\n                if getattr(BResult, '_ctype', None) is not None:\n                    error = BResult._from_ctypes(\n                        BResult._create_ctype_obj(error))\n                else:\n                    error = None\n                def callback(*args):\n                    args2 = []\n                    for arg, BArg in zip(args, BArgs):\n                        args2.append(BArg._from_ctypes(arg))\n                    try:\n                        res2 = init(*args2)\n                        res2 = BResult._to_ctypes(res2)\n                    except:\n                        traceback.print_exc()\n                        res2 = error\n                    if issubclass(BResult, CTypesGenericPtr):\n                        if res2:\n                            res2 = ctypes.cast(res2, ctypes.c_void_p).value\n                                # .value: http://bugs.python.org/issue1574593\n                        else:\n                            res2 = None\n                    #print repr(res2)\n                    return res2\n                if issubclass(BResult, CTypesGenericPtr):\n                    # The only pointers callbacks can return are void*s:\n                    # http://bugs.python.org/issue5710\n                    callback_ctype = ctypes.CFUNCTYPE(\n                        ctypes.c_void_p,\n                        *[BArg._ctype for BArg in BArgs],\n                        use_errno=True)\n                else:\n                    callback_ctype = CTypesFunctionPtr._ctype\n                self._as_ctype_ptr = callback_ctype(callback)\n                self._address = ctypes.cast(self._as_ctype_ptr,\n                                            ctypes.c_void_p).value\n                self._own_callback = init\n\n            @staticmethod\n            def _initialize(ctypes_ptr, value):\n                if value:\n                    raise NotImplementedError(\"ctypes backend: not supported: \"\n                                          \"initializers for function pointers\")\n\n            def __repr__(self):\n                c_name = getattr(self, '_name', None)\n                if c_name:\n                    i = self._reftypename.index('(* &)')\n                    if self._reftypename[i-1] not in ' )*':\n                        c_name = ' ' + c_name\n                    c_name = self._reftypename.replace('(* &)', c_name)\n                return CTypesData.__repr__(self, c_name)\n\n            def _get_own_repr(self):\n                if getattr(self, '_own_callback', None) is not None:\n                    return 'calling %r' % (self._own_callback,)\n                return super(CTypesFunctionPtr, self)._get_own_repr()\n\n            def __call__(self, *args):\n                if has_varargs:\n                    assert len(args) >= len(BArgs)\n                    extraargs = args[len(BArgs):]\n                    args = args[:len(BArgs)]\n                else:\n                    assert len(args) == len(BArgs)\n                ctypes_args = []\n                for arg, BArg in zip(args, BArgs):\n                    ctypes_args.append(BArg._arg_to_ctypes(arg))\n                if has_varargs:\n                    for i, arg in enumerate(extraargs):\n                        if arg is None:\n                            ctypes_args.append(ctypes.c_void_p(0))  # NULL\n                            continue\n                        if not isinstance(arg, CTypesData):\n                            raise TypeError(\n                                \"argument %d passed in the variadic part \"\n                                \"needs to be a cdata object (got %s)\" %\n                                (1 + len(BArgs) + i, type(arg).__name__))\n                        ctypes_args.append(arg._arg_to_ctypes(arg))\n                result = self._as_ctype_ptr(*ctypes_args)\n                return BResult._from_ctypes(result)\n        #\n        CTypesFunctionPtr._fix_class()\n        return CTypesFunctionPtr\n\n    def new_enum_type(self, name, enumerators, enumvalues, CTypesInt):\n        assert isinstance(name, str)\n        reverse_mapping = dict(zip(reversed(enumvalues),\n                                   reversed(enumerators)))\n        #\n        class CTypesEnum(CTypesInt):\n            __slots__ = []\n            _reftypename = '%s &' % name\n\n            def _get_own_repr(self):\n                value = self._value\n                try:\n                    return '%d: %s' % (value, reverse_mapping[value])\n                except KeyError:\n                    return str(value)\n\n            def _to_string(self, maxlen):\n                value = self._value\n                try:\n                    return reverse_mapping[value]\n                except KeyError:\n                    return str(value)\n        #\n        CTypesEnum._fix_class()\n        return CTypesEnum\n\n    def get_errno(self):\n        return ctypes.get_errno()\n\n    def set_errno(self, value):\n        ctypes.set_errno(value)\n\n    def string(self, b, maxlen=-1):\n        return b._to_string(maxlen)\n\n    def buffer(self, bptr, size=-1):\n        raise NotImplementedError(\"buffer() with ctypes backend\")\n\n    def sizeof(self, cdata_or_BType):\n        if isinstance(cdata_or_BType, CTypesData):\n            return cdata_or_BType._get_size_of_instance()\n        else:\n            assert issubclass(cdata_or_BType, CTypesData)\n            return cdata_or_BType._get_size()\n\n    def alignof(self, BType):\n        assert issubclass(BType, CTypesData)\n        return BType._alignment()\n\n    def newp(self, BType, source):\n        if not issubclass(BType, CTypesData):\n            raise TypeError\n        return BType._newp(source)\n\n    def cast(self, BType, source):\n        return BType._cast_from(source)\n\n    def callback(self, BType, source, error, onerror):\n        assert onerror is None   # XXX not implemented\n        return BType(source, error)\n\n    _weakref_cache_ref = None\n\n    def gcp(self, cdata, destructor, size=0):\n        if self._weakref_cache_ref is None:\n            import weakref\n            class MyRef(weakref.ref):\n                def __eq__(self, other):\n                    myref = self()\n                    return self is other or (\n                        myref is not None and myref is other())\n                def __ne__(self, other):\n                    return not (self == other)\n                def __hash__(self):\n                    try:\n                        return self._hash\n                    except AttributeError:\n                        self._hash = hash(self())\n                        return self._hash\n            self._weakref_cache_ref = {}, MyRef\n        weak_cache, MyRef = self._weakref_cache_ref\n\n        if destructor is None:\n            try:\n                del weak_cache[MyRef(cdata)]\n            except KeyError:\n                raise TypeError(\"Can remove destructor only on a object \"\n                                \"previously returned by ffi.gc()\")\n            return None\n\n        def remove(k):\n            cdata, destructor = weak_cache.pop(k, (None, None))\n            if destructor is not None:\n                destructor(cdata)\n\n        new_cdata = self.cast(self.typeof(cdata), cdata)\n        assert new_cdata is not cdata\n        weak_cache[MyRef(new_cdata, remove)] = (cdata, destructor)\n        return new_cdata\n\n    typeof = type\n\n    def getcname(self, BType, replace_with):\n        return BType._get_c_name(replace_with)\n\n    def typeoffsetof(self, BType, fieldname, num=0):\n        if isinstance(fieldname, str):\n            if num == 0 and issubclass(BType, CTypesGenericPtr):\n                BType = BType._BItem\n            if not issubclass(BType, CTypesBaseStructOrUnion):\n                raise TypeError(\"expected a struct or union ctype\")\n            BField = BType._bfield_types[fieldname]\n            if BField is Ellipsis:\n                raise TypeError(\"not supported for bitfields\")\n            return (BField, BType._offsetof(fieldname))\n        elif isinstance(fieldname, (int, long)):\n            if issubclass(BType, CTypesGenericArray):\n                BType = BType._CTPtr\n            if not issubclass(BType, CTypesGenericPtr):\n                raise TypeError(\"expected an array or ptr ctype\")\n            BItem = BType._BItem\n            offset = BItem._get_size() * fieldname\n            if offset > sys.maxsize:\n                raise OverflowError\n            return (BItem, offset)\n        else:\n            raise TypeError(type(fieldname))\n\n    def rawaddressof(self, BTypePtr, cdata, offset=None):\n        if isinstance(cdata, CTypesBaseStructOrUnion):\n            ptr = ctypes.pointer(type(cdata)._to_ctypes(cdata))\n        elif isinstance(cdata, CTypesGenericPtr):\n            if offset is None or not issubclass(type(cdata)._BItem,\n                                                CTypesBaseStructOrUnion):\n                raise TypeError(\"unexpected cdata type\")\n            ptr = type(cdata)._to_ctypes(cdata)\n        elif isinstance(cdata, CTypesGenericArray):\n            ptr = type(cdata)._to_ctypes(cdata)\n        else:\n            raise TypeError(\"expected a <cdata 'struct-or-union'>\")\n        if offset:\n            ptr = ctypes.cast(\n                ctypes.c_void_p(\n                    ctypes.cast(ptr, ctypes.c_void_p).value + offset),\n                type(ptr))\n        return BTypePtr._from_ctypes(ptr)\n\n\nclass CTypesLibrary(object):\n\n    def __init__(self, backend, cdll):\n        self.backend = backend\n        self.cdll = cdll\n\n    def load_function(self, BType, name):\n        c_func = getattr(self.cdll, name)\n        funcobj = BType._from_ctypes(c_func)\n        funcobj._name = name\n        return funcobj\n\n    def read_variable(self, BType, name):\n        try:\n            ctypes_obj = BType._ctype.in_dll(self.cdll, name)\n        except AttributeError as e:\n            raise NotImplementedError(e)\n        return BType._from_ctypes(ctypes_obj)\n\n    def write_variable(self, BType, name, value):\n        new_ctypes_obj = BType._to_ctypes(value)\n        ctypes_obj = BType._ctype.in_dll(self.cdll, name)\n        ctypes.memmove(ctypes.addressof(ctypes_obj),\n                       ctypes.addressof(new_ctypes_obj),\n                       ctypes.sizeof(BType._ctype))\n", "src/cffi/lock.py": "import sys\n\nif sys.version_info < (3,):\n    try:\n        from thread import allocate_lock\n    except ImportError:\n        from dummy_thread import allocate_lock\nelse:\n    try:\n        from _thread import allocate_lock\n    except ImportError:\n        from _dummy_thread import allocate_lock\n\n\n##import sys\n##l1 = allocate_lock\n\n##class allocate_lock(object):\n##    def __init__(self):\n##        self._real = l1()\n##    def __enter__(self):\n##        for i in range(4, 0, -1):\n##            print sys._getframe(i).f_code\n##        print\n##        return self._real.__enter__()\n##    def __exit__(self, *args):\n##        return self._real.__exit__(*args)\n##    def acquire(self, f):\n##        assert f is False\n##        return self._real.acquire(f)\n", "src/cffi/commontypes.py": "import sys\nfrom . import model\nfrom .error import FFIError\n\n\nCOMMON_TYPES = {}\n\ntry:\n    # fetch \"bool\" and all simple Windows types\n    from _cffi_backend import _get_common_types\n    _get_common_types(COMMON_TYPES)\nexcept ImportError:\n    pass\n\nCOMMON_TYPES['FILE'] = model.unknown_type('FILE', '_IO_FILE')\nCOMMON_TYPES['bool'] = '_Bool'    # in case we got ImportError above\nCOMMON_TYPES['float _Complex'] = '_cffi_float_complex_t'\nCOMMON_TYPES['double _Complex'] = '_cffi_double_complex_t'\n\nfor _type in model.PrimitiveType.ALL_PRIMITIVE_TYPES:\n    if _type.endswith('_t'):\n        COMMON_TYPES[_type] = _type\ndel _type\n\n_CACHE = {}\n\ndef resolve_common_type(parser, commontype):\n    try:\n        return _CACHE[commontype]\n    except KeyError:\n        cdecl = COMMON_TYPES.get(commontype, commontype)\n        if not isinstance(cdecl, str):\n            result, quals = cdecl, 0    # cdecl is already a BaseType\n        elif cdecl in model.PrimitiveType.ALL_PRIMITIVE_TYPES:\n            result, quals = model.PrimitiveType(cdecl), 0\n        elif cdecl == 'set-unicode-needed':\n            raise FFIError(\"The Windows type %r is only available after \"\n                           \"you call ffi.set_unicode()\" % (commontype,))\n        else:\n            if commontype == cdecl:\n                raise FFIError(\n                    \"Unsupported type: %r.  Please look at \"\n        \"http://cffi.readthedocs.io/en/latest/cdef.html#ffi-cdef-limitations \"\n                    \"and file an issue if you think this type should really \"\n                    \"be supported.\" % (commontype,))\n            result, quals = parser.parse_type_and_quals(cdecl)   # recursive\n\n        assert isinstance(result, model.BaseTypeByIdentity)\n        _CACHE[commontype] = result, quals\n        return result, quals\n\n\n# ____________________________________________________________\n# extra types for Windows (most of them are in commontypes.c)\n\n\ndef win_common_types():\n    return {\n        \"UNICODE_STRING\": model.StructType(\n            \"_UNICODE_STRING\",\n            [\"Length\",\n             \"MaximumLength\",\n             \"Buffer\"],\n            [model.PrimitiveType(\"unsigned short\"),\n             model.PrimitiveType(\"unsigned short\"),\n             model.PointerType(model.PrimitiveType(\"wchar_t\"))],\n            [-1, -1, -1]),\n        \"PUNICODE_STRING\": \"UNICODE_STRING *\",\n        \"PCUNICODE_STRING\": \"const UNICODE_STRING *\",\n\n        \"TBYTE\": \"set-unicode-needed\",\n        \"TCHAR\": \"set-unicode-needed\",\n        \"LPCTSTR\": \"set-unicode-needed\",\n        \"PCTSTR\": \"set-unicode-needed\",\n        \"LPTSTR\": \"set-unicode-needed\",\n        \"PTSTR\": \"set-unicode-needed\",\n        \"PTBYTE\": \"set-unicode-needed\",\n        \"PTCHAR\": \"set-unicode-needed\",\n        }\n\nif sys.platform == 'win32':\n    COMMON_TYPES.update(win_common_types())\n", "src/cffi/_shimmed_dist_utils.py": "\"\"\"\nTemporary shim module to indirect the bits of distutils we need from setuptools/distutils while providing useful\nerror messages beyond `No module named 'distutils' on Python >= 3.12, or when setuptools' vendored distutils is broken.\n\nThis is a compromise to avoid a hard-dep on setuptools for Python >= 3.12, since many users don't need runtime compilation support from CFFI.\n\"\"\"\nimport sys\n\ntry:\n    # import setuptools first; this is the most robust way to ensure its embedded distutils is available\n    # (the .pth shim should usually work, but this is even more robust)\n    import setuptools\nexcept Exception as ex:\n    if sys.version_info >= (3, 12):\n        # Python 3.12 has no built-in distutils to fall back on, so any import problem is fatal\n        raise Exception(\"This CFFI feature requires setuptools on Python >= 3.12. The setuptools module is missing or non-functional.\") from ex\n\n    # silently ignore on older Pythons (support fallback to stdlib distutils where available)\nelse:\n    del setuptools\n\ntry:\n    # bring in just the bits of distutils we need, whether they really came from setuptools or stdlib-embedded distutils\n    from distutils import log, sysconfig\n    from distutils.ccompiler import CCompiler\n    from distutils.command.build_ext import build_ext\n    from distutils.core import Distribution, Extension\n    from distutils.dir_util import mkpath\n    from distutils.errors import DistutilsSetupError, CompileError, LinkError\n    from distutils.log import set_threshold, set_verbosity\n\n    if sys.platform == 'win32':\n        from distutils.msvc9compiler import MSVCCompiler\nexcept Exception as ex:\n    if sys.version_info >= (3, 12):\n        raise Exception(\"This CFFI feature requires setuptools on Python >= 3.12. Please install the setuptools package.\") from ex\n\n    # anything older, just let the underlying distutils import error fly\n    raise Exception(\"This CFFI feature requires distutils. Please install the distutils or setuptools package.\") from ex\n\ndel sys\n", "src/cffi/error.py": "\nclass FFIError(Exception):\n    __module__ = 'cffi'\n\nclass CDefError(Exception):\n    __module__ = 'cffi'\n    def __str__(self):\n        try:\n            current_decl = self.args[1]\n            filename = current_decl.coord.file\n            linenum = current_decl.coord.line\n            prefix = '%s:%d: ' % (filename, linenum)\n        except (AttributeError, TypeError, IndexError):\n            prefix = ''\n        return '%s%s' % (prefix, self.args[0])\n\nclass VerificationError(Exception):\n    \"\"\" An error raised when verification fails\n    \"\"\"\n    __module__ = 'cffi'\n\nclass VerificationMissing(Exception):\n    \"\"\" An error raised when incomplete structures are passed into\n    cdef, but no verification has been done\n    \"\"\"\n    __module__ = 'cffi'\n\nclass PkgConfigError(Exception):\n    \"\"\" An error raised for missing modules in pkg-config\n    \"\"\"\n    __module__ = 'cffi'\n", "src/cffi/__init__.py": "__all__ = ['FFI', 'VerificationError', 'VerificationMissing', 'CDefError',\n           'FFIError']\n\nfrom .api import FFI\nfrom .error import CDefError, FFIError, VerificationError, VerificationMissing\nfrom .error import PkgConfigError\n\n__version__ = \"1.17.0.dev0\"\n__version_info__ = (1, 17, 0, 'dev0')\n\n# The verifier module file names are based on the CRC32 of a string that\n# contains the following version number.  It may be older than __version__\n# if nothing is clearly incompatible.\n__version_verifier_modules__ = \"0.8.6\"\n", "src/cffi/vengine_cpy.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys\nfrom . import model\nfrom .error import VerificationError\nfrom . import _imp_emulation as imp\n\n\nclass VCPythonEngine(object):\n    _class_key = 'x'\n    _gen_python_module = True\n\n    def __init__(self, verifier):\n        self.verifier = verifier\n        self.ffi = verifier.ffi\n        self._struct_pending_verification = {}\n        self._types_of_builtin_functions = {}\n\n    def patch_extension_kwds(self, kwds):\n        pass\n\n    def find_module(self, module_name, path, so_suffixes):\n        try:\n            f, filename, descr = imp.find_module(module_name, path)\n        except ImportError:\n            return None\n        if f is not None:\n            f.close()\n        # Note that after a setuptools installation, there are both .py\n        # and .so files with the same basename.  The code here relies on\n        # imp.find_module() locating the .so in priority.\n        if descr[0] not in so_suffixes:\n            return None\n        return filename\n\n    def collect_types(self):\n        self._typesdict = {}\n        self._generate(\"collecttype\")\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def _gettypenum(self, type):\n        # a KeyError here is a bug.  please report it! :-)\n        return self._typesdict[type]\n\n    def _do_collect_type(self, tp):\n        if ((not isinstance(tp, model.PrimitiveType)\n             or tp.name == 'long double')\n                and tp not in self._typesdict):\n            num = len(self._typesdict)\n            self._typesdict[tp] = num\n\n    def write_source_to_f(self):\n        self.collect_types()\n        #\n        # The new module will have a _cffi_setup() function that receives\n        # objects from the ffi world, and that calls some setup code in\n        # the module.  This setup code is split in several independent\n        # functions, e.g. one per constant.  The functions are \"chained\"\n        # by ending in a tail call to each other.\n        #\n        # This is further split in two chained lists, depending on if we\n        # can do it at import-time or if we must wait for _cffi_setup() to\n        # provide us with the <ctype> objects.  This is needed because we\n        # need the values of the enum constants in order to build the\n        # <ctype 'enum'> that we may have to pass to _cffi_setup().\n        #\n        # The following two 'chained_list_constants' items contains\n        # the head of these two chained lists, as a string that gives the\n        # call to do, if any.\n        self._chained_list_constants = ['((void)lib,0)', '((void)lib,0)']\n        #\n        prnt = self._prnt\n        # first paste some standard set of lines that are mostly '#define'\n        prnt(cffimod_header)\n        prnt()\n        # then paste the C source given by the user, verbatim.\n        prnt(self.verifier.preamble)\n        prnt()\n        #\n        # call generate_cpy_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._generate(\"decl\")\n        #\n        # implement the function _cffi_setup_custom() as calling the\n        # head of the chained list.\n        self._generate_setup_custom()\n        prnt()\n        #\n        # produce the method table, including the entries for the\n        # generated Python->C function wrappers, which are done\n        # by generate_cpy_function_method().\n        prnt('static PyMethodDef _cffi_methods[] = {')\n        self._generate(\"method\")\n        prnt('  {\"_cffi_setup\", _cffi_setup, METH_VARARGS, NULL},')\n        prnt('  {NULL, NULL, 0, NULL}    /* Sentinel */')\n        prnt('};')\n        prnt()\n        #\n        # standard init.\n        modname = self.verifier.get_module_name()\n        constants = self._chained_list_constants[False]\n        prnt('#if PY_MAJOR_VERSION >= 3')\n        prnt()\n        prnt('static struct PyModuleDef _cffi_module_def = {')\n        prnt('  PyModuleDef_HEAD_INIT,')\n        prnt('  \"%s\",' % modname)\n        prnt('  NULL,')\n        prnt('  -1,')\n        prnt('  _cffi_methods,')\n        prnt('  NULL, NULL, NULL, NULL')\n        prnt('};')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('PyInit_%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = PyModule_Create(&_cffi_module_def);')\n        prnt('  if (lib == NULL)')\n        prnt('    return NULL;')\n        prnt('  if (%s < 0 || _cffi_init() < 0) {' % (constants,))\n        prnt('    Py_DECREF(lib);')\n        prnt('    return NULL;')\n        prnt('  }')\n        prnt('  return lib;')\n        prnt('}')\n        prnt()\n        prnt('#else')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('init%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = Py_InitModule(\"%s\", _cffi_methods);' % modname)\n        prnt('  if (lib == NULL)')\n        prnt('    return;')\n        prnt('  if (%s < 0 || _cffi_init() < 0)' % (constants,))\n        prnt('    return;')\n        prnt('  return;')\n        prnt('}')\n        prnt()\n        prnt('#endif')\n\n    def load_library(self, flags=None):\n        # XXX review all usages of 'self' here!\n        # import it as a new extension module\n        imp.acquire_lock()\n        try:\n            if hasattr(sys, \"getdlopenflags\"):\n                previous_flags = sys.getdlopenflags()\n            try:\n                if hasattr(sys, \"setdlopenflags\") and flags is not None:\n                    sys.setdlopenflags(flags)\n                module = imp.load_dynamic(self.verifier.get_module_name(),\n                                          self.verifier.modulefilename)\n            except ImportError as e:\n                error = \"importing %r: %s\" % (self.verifier.modulefilename, e)\n                raise VerificationError(error)\n            finally:\n                if hasattr(sys, \"setdlopenflags\"):\n                    sys.setdlopenflags(previous_flags)\n        finally:\n            imp.release_lock()\n        #\n        # call loading_cpy_struct() to get the struct layout inferred by\n        # the C compiler\n        self._load(module, 'loading')\n        #\n        # the C code will need the <ctype> objects.  Collect them in\n        # order in a list.\n        revmapping = dict([(value, key)\n                           for (key, value) in self._typesdict.items()])\n        lst = [revmapping[i] for i in range(len(revmapping))]\n        lst = list(map(self.ffi._get_cached_btype, lst))\n        #\n        # build the FFILibrary class and instance and call _cffi_setup().\n        # this will set up some fields like '_cffi_types', and only then\n        # it will invoke the chained list of functions that will really\n        # build (notably) the constant objects, as <cdata> if they are\n        # pointers, and store them as attributes on the 'library' object.\n        class FFILibrary(object):\n            _cffi_python_module = module\n            _cffi_ffi = self.ffi\n            _cffi_dir = []\n            def __dir__(self):\n                return FFILibrary._cffi_dir + list(self.__dict__)\n        library = FFILibrary()\n        if module._cffi_setup(lst, VerificationError, library):\n            import warnings\n            warnings.warn(\"reimporting %r might overwrite older definitions\"\n                          % (self.verifier.get_module_name()))\n        #\n        # finally, call the loaded_cpy_xxx() functions.  This will perform\n        # the final adjustments, like copying the Python->C wrapper\n        # functions from the module to the 'library' object, and setting\n        # up the FFILibrary class with properties for the global C variables.\n        self._load(module, 'loaded', library=library)\n        module._cffi_original_ffi = self.ffi\n        module._cffi_types_of_builtin_funcs = self._types_of_builtin_functions\n        return library\n\n    def _get_declarations(self):\n        lst = [(key, tp) for (key, (tp, qual)) in\n                                self.ffi._parser._declarations.items()]\n        lst.sort()\n        return lst\n\n    def _generate(self, step_name):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_cpy_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise VerificationError(\n                    \"not implemented in verify(): %r\" % name)\n            try:\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _load(self, module, step_name, **kwds):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            method = getattr(self, '_%s_cpy_%s' % (step_name, kind))\n            try:\n                method(tp, realname, module, **kwds)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _generate_nothing(self, tp, name):\n        pass\n\n    def _loaded_noop(self, tp, name, module, **kwds):\n        pass\n\n    # ----------\n\n    def _convert_funcarg_to_c(self, tp, fromvar, tovar, errcode):\n        extraarg = ''\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                converter = '_cffi_to_c_int'\n                extraarg = ', %s' % tp.name\n            elif tp.is_complex_type():\n                raise VerificationError(\n                    \"not implemented in verify(): complex types\")\n            else:\n                converter = '(%s)_cffi_to_c_%s' % (tp.get_c_name(''),\n                                                   tp.name.replace(' ', '_'))\n            errvalue = '-1'\n        #\n        elif isinstance(tp, model.PointerType):\n            self._convert_funcarg_to_c_ptr_or_array(tp, fromvar,\n                                                    tovar, errcode)\n            return\n        #\n        elif isinstance(tp, (model.StructOrUnion, model.EnumType)):\n            # a struct (not a struct pointer) as a function argument\n            self._prnt('  if (_cffi_to_c((char *)&%s, _cffi_type(%d), %s) < 0)'\n                      % (tovar, self._gettypenum(tp), fromvar))\n            self._prnt('    %s;' % errcode)\n            return\n        #\n        elif isinstance(tp, model.FunctionPtrType):\n            converter = '(%s)_cffi_to_c_pointer' % tp.get_c_name('')\n            extraarg = ', _cffi_type(%d)' % self._gettypenum(tp)\n            errvalue = 'NULL'\n        #\n        else:\n            raise NotImplementedError(tp)\n        #\n        self._prnt('  %s = %s(%s%s);' % (tovar, converter, fromvar, extraarg))\n        self._prnt('  if (%s == (%s)%s && PyErr_Occurred())' % (\n            tovar, tp.get_c_name(''), errvalue))\n        self._prnt('    %s;' % errcode)\n\n    def _extra_local_variables(self, tp, localvars, freelines):\n        if isinstance(tp, model.PointerType):\n            localvars.add('Py_ssize_t datasize')\n            localvars.add('struct _cffi_freeme_s *large_args_free = NULL')\n            freelines.add('if (large_args_free != NULL)'\n                          ' _cffi_free_array_arguments(large_args_free);')\n\n    def _convert_funcarg_to_c_ptr_or_array(self, tp, fromvar, tovar, errcode):\n        self._prnt('  datasize = _cffi_prepare_pointer_call_argument(')\n        self._prnt('      _cffi_type(%d), %s, (char **)&%s);' % (\n            self._gettypenum(tp), fromvar, tovar))\n        self._prnt('  if (datasize != 0) {')\n        self._prnt('    %s = ((size_t)datasize) <= 640 ? '\n                   'alloca((size_t)datasize) : NULL;' % (tovar,))\n        self._prnt('    if (_cffi_convert_array_argument(_cffi_type(%d), %s, '\n                   '(char **)&%s,' % (self._gettypenum(tp), fromvar, tovar))\n        self._prnt('            datasize, &large_args_free) < 0)')\n        self._prnt('      %s;' % errcode)\n        self._prnt('  }')\n\n    def _convert_expr_from_c(self, tp, var, context):\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                return '_cffi_from_c_int(%s, %s)' % (var, tp.name)\n            elif tp.name != 'long double':\n                return '_cffi_from_c_%s(%s)' % (tp.name.replace(' ', '_'), var)\n            else:\n                return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                    var, self._gettypenum(tp))\n        elif isinstance(tp, (model.PointerType, model.FunctionPtrType)):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.ArrayType):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(model.PointerType(tp.item)))\n        elif isinstance(tp, model.StructOrUnion):\n            if tp.fldnames is None:\n                raise TypeError(\"'%s' is used as %s, but is opaque\" % (\n                    tp._get_c_name(), context))\n            return '_cffi_from_c_struct((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.EnumType):\n            return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        else:\n            raise NotImplementedError(tp)\n\n    # ----------\n    # typedefs: generates no code so far\n\n    _generate_cpy_typedef_collecttype = _generate_nothing\n    _generate_cpy_typedef_decl   = _generate_nothing\n    _generate_cpy_typedef_method = _generate_nothing\n    _loading_cpy_typedef         = _loaded_noop\n    _loaded_cpy_typedef          = _loaded_noop\n\n    # ----------\n    # function declarations\n\n    def _generate_cpy_function_collecttype(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            self._do_collect_type(tp)\n        else:\n            # don't call _do_collect_type(tp) in this common case,\n            # otherwise test_autofilled_struct_as_argument fails\n            for type in tp.args:\n                self._do_collect_type(type)\n            self._do_collect_type(tp.result)\n\n    def _generate_cpy_function_decl(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no CPython wrapper)\n            self._generate_cpy_const(False, name, tp)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        if numargs == 0:\n            argname = 'noarg'\n        elif numargs == 1:\n            argname = 'arg0'\n        else:\n            argname = 'args'\n        prnt('static PyObject *')\n        prnt('_cffi_f_%s(PyObject *self, PyObject *%s)' % (name, argname))\n        prnt('{')\n        #\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            prnt('  %s;' % type.get_c_name(' x%d' % i, context))\n        #\n        localvars = set()\n        freelines = set()\n        for type in tp.args:\n            self._extra_local_variables(type, localvars, freelines)\n        for decl in sorted(localvars):\n            prnt('  %s;' % (decl,))\n        #\n        if not isinstance(tp.result, model.VoidType):\n            result_code = 'result = '\n            context = 'result of %s' % name\n            prnt('  %s;' % tp.result.get_c_name(' result', context))\n            prnt('  PyObject *pyresult;')\n        else:\n            result_code = ''\n        #\n        if len(tp.args) > 1:\n            rng = range(len(tp.args))\n            for i in rng:\n                prnt('  PyObject *arg%d;' % i)\n            prnt()\n            prnt('  if (!PyArg_ParseTuple(args, \"%s:%s\", %s))' % (\n                'O' * numargs, name, ', '.join(['&arg%d' % i for i in rng])))\n            prnt('    return NULL;')\n        prnt()\n        #\n        for i, type in enumerate(tp.args):\n            self._convert_funcarg_to_c(type, 'arg%d' % i, 'x%d' % i,\n                                       'return NULL')\n            prnt()\n        #\n        prnt('  Py_BEGIN_ALLOW_THREADS')\n        prnt('  _cffi_restore_errno();')\n        prnt('  { %s%s(%s); }' % (\n            result_code, name,\n            ', '.join(['x%d' % i for i in range(len(tp.args))])))\n        prnt('  _cffi_save_errno();')\n        prnt('  Py_END_ALLOW_THREADS')\n        prnt()\n        #\n        prnt('  (void)self; /* unused */')\n        if numargs == 0:\n            prnt('  (void)noarg; /* unused */')\n        if result_code:\n            prnt('  pyresult = %s;' %\n                 self._convert_expr_from_c(tp.result, 'result', 'result type'))\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  return pyresult;')\n        else:\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  Py_INCREF(Py_None);')\n            prnt('  return Py_None;')\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_function_method(self, tp, name):\n        if tp.ellipsis:\n            return\n        numargs = len(tp.args)\n        if numargs == 0:\n            meth = 'METH_NOARGS'\n        elif numargs == 1:\n            meth = 'METH_O'\n        else:\n            meth = 'METH_VARARGS'\n        self._prnt('  {\"%s\", _cffi_f_%s, %s, NULL},' % (name, name, meth))\n\n    _loading_cpy_function = _loaded_noop\n\n    def _loaded_cpy_function(self, tp, name, module, library):\n        if tp.ellipsis:\n            return\n        func = getattr(module, name)\n        setattr(library, name, func)\n        self._types_of_builtin_functions[func] = tp\n\n    # ----------\n    # named structs\n\n    _generate_cpy_struct_collecttype = _generate_nothing\n    def _generate_cpy_struct_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'struct', name)\n    def _generate_cpy_struct_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'struct', name)\n    def _loading_cpy_struct(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'struct', name, module)\n    def _loaded_cpy_struct(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    _generate_cpy_union_collecttype = _generate_nothing\n    def _generate_cpy_union_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'union', name)\n    def _generate_cpy_union_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'union', name)\n    def _loading_cpy_union(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'union', name, module)\n    def _loaded_cpy_union(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_struct_or_union_decl(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        checkfuncname = '_cffi_check_%s_%s' % (prefix, name)\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        cname = ('%s %s' % (prefix, name)).strip()\n        #\n        prnt = self._prnt\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if (isinstance(ftype, model.PrimitiveType)\n                and ftype.is_integer_type()) or fbitsize >= 0:\n                # accept all integers, but complain on float or double\n                prnt('  (void)((p->%s) << 1);' % fname)\n            else:\n                # only accept exactly the type declared.\n                try:\n                    prnt('  { %s = &p->%s; (void)tmp; }' % (\n                        ftype.get_c_name('*tmp', 'field %r'%fname, quals=fqual),\n                        fname))\n                except VerificationError as e:\n                    prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        prnt('static PyObject *')\n        prnt('%s(PyObject *self, PyObject *noarg)' % (layoutfuncname,))\n        prnt('{')\n        prnt('  struct _cffi_aligncheck { char x; %s y; };' % cname)\n        prnt('  static Py_ssize_t nums[] = {')\n        prnt('    sizeof(%s),' % cname)\n        prnt('    offsetof(struct _cffi_aligncheck, y),')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if fbitsize >= 0:\n                continue      # xxx ignore fbitsize for now\n            prnt('    offsetof(%s, %s),' % (cname, fname))\n            if isinstance(ftype, model.ArrayType) and ftype.length is None:\n                prnt('    0,  /* %s */' % ftype._get_c_name())\n            else:\n                prnt('    sizeof(((%s *)0)->%s),' % (cname, fname))\n        prnt('    -1')\n        prnt('  };')\n        prnt('  (void)self; /* unused */')\n        prnt('  (void)noarg; /* unused */')\n        prnt('  return _cffi_get_struct_layout(nums);')\n        prnt('  /* the next line is not executed, but compiled */')\n        prnt('  %s(0);' % (checkfuncname,))\n        prnt('}')\n        prnt()\n\n    def _generate_struct_or_union_method(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        self._prnt('  {\"%s\", %s, METH_NOARGS, NULL},' % (layoutfuncname,\n                                                         layoutfuncname))\n\n    def _loading_struct_or_union(self, tp, prefix, name, module):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        #\n        function = getattr(module, layoutfuncname)\n        layout = function()\n        if isinstance(tp, model.StructOrUnion) and tp.partial:\n            # use the function()'s sizes and offsets to guide the\n            # layout of the struct\n            totalsize = layout[0]\n            totalalignment = layout[1]\n            fieldofs = layout[2::2]\n            fieldsize = layout[3::2]\n            tp.force_flatten()\n            assert len(fieldofs) == len(fieldsize) == len(tp.fldnames)\n            tp.fixedlayout = fieldofs, fieldsize, totalsize, totalalignment\n        else:\n            cname = ('%s %s' % (prefix, name)).strip()\n            self._struct_pending_verification[tp] = layout, cname\n\n    def _loaded_struct_or_union(self, tp):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        self.ffi._get_cached_btype(tp)   # force 'fixedlayout' to be considered\n\n        if tp in self._struct_pending_verification:\n            # check that the layout sizes and offsets match the real ones\n            def check(realvalue, expectedvalue, msg):\n                if realvalue != expectedvalue:\n                    raise VerificationError(\n                        \"%s (we have %d, but C compiler says %d)\"\n                        % (msg, expectedvalue, realvalue))\n            ffi = self.ffi\n            BStruct = ffi._get_cached_btype(tp)\n            layout, cname = self._struct_pending_verification.pop(tp)\n            check(layout[0], ffi.sizeof(BStruct), \"wrong total size\")\n            check(layout[1], ffi.alignof(BStruct), \"wrong total alignment\")\n            i = 2\n            for fname, ftype, fbitsize, fqual in tp.enumfields():\n                if fbitsize >= 0:\n                    continue        # xxx ignore fbitsize for now\n                check(layout[i], ffi.offsetof(BStruct, fname),\n                      \"wrong offset for field %r\" % (fname,))\n                if layout[i+1] != 0:\n                    BField = ffi._get_cached_btype(ftype)\n                    check(layout[i+1], ffi.sizeof(BField),\n                          \"wrong size for field %r\" % (fname,))\n                i += 2\n            assert i == len(layout)\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    _generate_cpy_anonymous_collecttype = _generate_nothing\n\n    def _generate_cpy_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_decl(tp, name, '')\n        else:\n            self._generate_struct_or_union_decl(tp, '', name)\n\n    def _generate_cpy_anonymous_method(self, tp, name):\n        if not isinstance(tp, model.EnumType):\n            self._generate_struct_or_union_method(tp, '', name)\n\n    def _loading_cpy_anonymous(self, tp, name, module):\n        if isinstance(tp, model.EnumType):\n            self._loading_cpy_enum(tp, name, module)\n        else:\n            self._loading_struct_or_union(tp, '', name, module)\n\n    def _loaded_cpy_anonymous(self, tp, name, module, **kwds):\n        if isinstance(tp, model.EnumType):\n            self._loaded_cpy_enum(tp, name, module, **kwds)\n        else:\n            self._loaded_struct_or_union(tp)\n\n    # ----------\n    # constants, likely declared with '#define'\n\n    def _generate_cpy_const(self, is_int, name, tp=None, category='const',\n                            vartp=None, delayed=True, size_too=False,\n                            check_value=None):\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        prnt('  PyObject *o;')\n        prnt('  int res;')\n        if not is_int:\n            prnt('  %s;' % (vartp or tp).get_c_name(' i', name))\n        else:\n            assert category == 'const'\n        #\n        if check_value is not None:\n            self._check_int_constant_value(name, check_value)\n        #\n        if not is_int:\n            if category == 'var':\n                realexpr = '&' + name\n            else:\n                realexpr = name\n            prnt('  i = (%s);' % (realexpr,))\n            prnt('  o = %s;' % (self._convert_expr_from_c(tp, 'i',\n                                                          'variable type'),))\n            assert delayed\n        else:\n            prnt('  o = _cffi_from_c_int_const(%s);' % name)\n        prnt('  if (o == NULL)')\n        prnt('    return -1;')\n        if size_too:\n            prnt('  {')\n            prnt('    PyObject *o1 = o;')\n            prnt('    o = Py_BuildValue(\"On\", o1, (Py_ssize_t)sizeof(%s));'\n                 % (name,))\n            prnt('    Py_DECREF(o1);')\n            prnt('    if (o == NULL)')\n            prnt('      return -1;')\n            prnt('  }')\n        prnt('  res = PyObject_SetAttrString(lib, \"%s\", o);' % name)\n        prnt('  Py_DECREF(o);')\n        prnt('  if (res < 0)')\n        prnt('    return -1;')\n        prnt('  return %s;' % self._chained_list_constants[delayed])\n        self._chained_list_constants[delayed] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_constant_collecttype(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        if not is_int:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_constant_decl(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        self._generate_cpy_const(is_int, name, tp)\n\n    _generate_cpy_constant_method = _generate_nothing\n    _loading_cpy_constant = _loaded_noop\n    _loaded_cpy_constant  = _loaded_noop\n\n    # ----------\n    # enums\n\n    def _check_int_constant_value(self, name, value, err_prefix=''):\n        prnt = self._prnt\n        if value <= 0:\n            prnt('  if ((%s) > 0 || (long)(%s) != %dL) {' % (\n                name, name, value))\n        else:\n            prnt('  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {' % (\n                name, name, value))\n        prnt('    char buf[64];')\n        prnt('    if ((%s) <= 0)' % name)\n        prnt('        snprintf(buf, 63, \"%%ld\", (long)(%s));' % name)\n        prnt('    else')\n        prnt('        snprintf(buf, 63, \"%%lu\", (unsigned long)(%s));' %\n             name)\n        prnt('    PyErr_Format(_cffi_VerificationError,')\n        prnt('                 \"%s%s has the real value %s, not %s\",')\n        prnt('                 \"%s\", \"%s\", buf, \"%d\");' % (\n            err_prefix, name, value))\n        prnt('    return -1;')\n        prnt('  }')\n\n    def _enum_funcname(self, prefix, name):\n        # \"$enum_$1\" => \"___D_enum____D_1\"\n        name = name.replace('$', '___D_')\n        return '_cffi_e_%s_%s' % (prefix, name)\n\n    def _generate_cpy_enum_decl(self, tp, name, prefix='enum'):\n        if tp.partial:\n            for enumerator in tp.enumerators:\n                self._generate_cpy_const(True, enumerator, delayed=False)\n            return\n        #\n        funcname = self._enum_funcname(prefix, name)\n        prnt = self._prnt\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._check_int_constant_value(enumerator, enumvalue,\n                                           \"enum %s: \" % name)\n        prnt('  return %s;' % self._chained_list_constants[True])\n        self._chained_list_constants[True] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    _generate_cpy_enum_collecttype = _generate_nothing\n    _generate_cpy_enum_method = _generate_nothing\n\n    def _loading_cpy_enum(self, tp, name, module):\n        if tp.partial:\n            enumvalues = [getattr(module, enumerator)\n                          for enumerator in tp.enumerators]\n            tp.enumvalues = tuple(enumvalues)\n            tp.partial_resolved = True\n\n    def _loaded_cpy_enum(self, tp, name, module, library):\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            setattr(library, enumerator, enumvalue)\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_cpy_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_cpy_const(True, name, check_value=check_value)\n\n    _generate_cpy_macro_collecttype = _generate_nothing\n    _generate_cpy_macro_method = _generate_nothing\n    _loading_cpy_macro = _loaded_noop\n    _loaded_cpy_macro  = _loaded_noop\n\n    # ----------\n    # global variables\n\n    def _generate_cpy_variable_collecttype(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n        else:\n            tp_ptr = model.PointerType(tp)\n        self._do_collect_type(tp_ptr)\n\n    def _generate_cpy_variable_decl(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n            self._generate_cpy_const(False, name, tp, vartp=tp_ptr,\n                                     size_too = tp.length_is_unknown())\n        else:\n            tp_ptr = model.PointerType(tp)\n            self._generate_cpy_const(False, name, tp_ptr, category='var')\n\n    _generate_cpy_variable_method = _generate_nothing\n    _loading_cpy_variable = _loaded_noop\n\n    def _loaded_cpy_variable(self, tp, name, module, library):\n        value = getattr(library, name)\n        if isinstance(tp, model.ArrayType):   # int a[5] is \"constant\" in the\n                                              # sense that \"a=...\" is forbidden\n            if tp.length_is_unknown():\n                assert isinstance(value, tuple)\n                (value, size) = value\n                BItemType = self.ffi._get_cached_btype(tp.item)\n                length, rest = divmod(size, self.ffi.sizeof(BItemType))\n                if rest != 0:\n                    raise VerificationError(\n                        \"bad size: %r does not seem to be an array of %s\" %\n                        (name, tp.item))\n                tp = tp.resolve_length(length)\n            # 'value' is a <cdata 'type *'> which we have to replace with\n            # a <cdata 'type[N]'> if the N is actually known\n            if tp.length is not None:\n                BArray = self.ffi._get_cached_btype(tp)\n                value = self.ffi.cast(BArray, value)\n                setattr(library, name, value)\n            return\n        # remove ptr=<cdata 'int *'> from the library instance, and replace\n        # it by a property on the class, which reads/writes into ptr[0].\n        ptr = value\n        delattr(library, name)\n        def getter(library):\n            return ptr[0]\n        def setter(library, value):\n            ptr[0] = value\n        setattr(type(library), name, property(getter, setter))\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n\n    def _generate_setup_custom(self):\n        prnt = self._prnt\n        prnt('static int _cffi_setup_custom(PyObject *lib)')\n        prnt('{')\n        prnt('  return %s;' % self._chained_list_constants[True])\n        prnt('}')\n\ncffimod_header = r'''\n#include <Python.h>\n#include <stddef.h>\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py\n   and cffi/_cffi_include.h */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n#  ifndef __cplusplus\n    typedef unsigned char _Bool;\n#  endif\n# endif\n# define _cffi_float_complex_t   _Fcomplex    /* include <complex.h> for it */\n# define _cffi_double_complex_t  _Dcomplex    /* include <complex.h> for it */\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)\n#  include <alloca.h>\n# endif\n# define _cffi_float_complex_t   float _Complex\n# define _cffi_double_complex_t  double _Complex\n#endif\n\n#if PY_MAJOR_VERSION < 3\n# undef PyCapsule_CheckExact\n# undef PyCapsule_GetPointer\n# define PyCapsule_CheckExact(capsule) (PyCObject_Check(capsule))\n# define PyCapsule_GetPointer(capsule, name) \\\n    (PyCObject_AsVoidPtr(capsule))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n#endif\n\n#define _cffi_from_c_double PyFloat_FromDouble\n#define _cffi_from_c_float PyFloat_FromDouble\n#define _cffi_from_c_long PyInt_FromLong\n#define _cffi_from_c_ulong PyLong_FromUnsignedLong\n#define _cffi_from_c_longlong PyLong_FromLongLong\n#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong\n#define _cffi_from_c__Bool PyBool_FromLong\n\n#define _cffi_to_c_double PyFloat_AsDouble\n#define _cffi_to_c_float PyFloat_AsDouble\n\n#define _cffi_from_c_int_const(x)                                        \\\n    (((x) > 0) ?                                                         \\\n        ((unsigned long long)(x) <= (unsigned long long)LONG_MAX) ?      \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)(x)) :       \\\n        ((long long)(x) >= (long long)LONG_MIN) ?                        \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromLongLong((long long)(x)))\n\n#define _cffi_from_c_int(x, type)                                        \\\n    (((type)-1) > 0 ? /* unsigned */                                     \\\n        (sizeof(type) < sizeof(long) ?                                   \\\n            PyInt_FromLong((long)x) :                                    \\\n         sizeof(type) == sizeof(long) ?                                  \\\n            PyLong_FromUnsignedLong((unsigned long)x) :                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \\\n        (sizeof(type) <= sizeof(long) ?                                  \\\n            PyInt_FromLong((long)x) :                                    \\\n            PyLong_FromLongLong((long long)x)))\n\n#define _cffi_to_c_int(o, type)                                          \\\n    ((type)(                                                             \\\n     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \\\n                                         : (type)_cffi_to_c_i8(o)) :     \\\n     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \\\n                                         : (type)_cffi_to_c_i16(o)) :    \\\n     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \\\n                                         : (type)_cffi_to_c_i32(o)) :    \\\n     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \\\n                                         : (type)_cffi_to_c_i64(o)) :    \\\n     (Py_FatalError(\"unsupported size for type \" #type), (type)0)))\n\n#define _cffi_to_c_i8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[1])\n#define _cffi_to_c_u8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[2])\n#define _cffi_to_c_i16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[3])\n#define _cffi_to_c_u16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[4])\n#define _cffi_to_c_i32                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[5])\n#define _cffi_to_c_u32                                                   \\\n                 ((unsigned int(*)(PyObject *))_cffi_exports[6])\n#define _cffi_to_c_i64                                                   \\\n                 ((long long(*)(PyObject *))_cffi_exports[7])\n#define _cffi_to_c_u64                                                   \\\n                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])\n#define _cffi_to_c_char                                                  \\\n                 ((int(*)(PyObject *))_cffi_exports[9])\n#define _cffi_from_c_pointer                                             \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10])\n#define _cffi_to_c_pointer                                               \\\n    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11])\n#define _cffi_get_struct_layout                                          \\\n    ((PyObject *(*)(Py_ssize_t[]))_cffi_exports[12])\n#define _cffi_restore_errno                                              \\\n    ((void(*)(void))_cffi_exports[13])\n#define _cffi_save_errno                                                 \\\n    ((void(*)(void))_cffi_exports[14])\n#define _cffi_from_c_char                                                \\\n    ((PyObject *(*)(char))_cffi_exports[15])\n#define _cffi_from_c_deref                                               \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16])\n#define _cffi_to_c                                                       \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17])\n#define _cffi_from_c_struct                                              \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18])\n#define _cffi_to_c_wchar_t                                               \\\n    ((wchar_t(*)(PyObject *))_cffi_exports[19])\n#define _cffi_from_c_wchar_t                                             \\\n    ((PyObject *(*)(wchar_t))_cffi_exports[20])\n#define _cffi_to_c_long_double                                           \\\n    ((long double(*)(PyObject *))_cffi_exports[21])\n#define _cffi_to_c__Bool                                                 \\\n    ((_Bool(*)(PyObject *))_cffi_exports[22])\n#define _cffi_prepare_pointer_call_argument                              \\\n    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23])\n#define _cffi_convert_array_from_object                                  \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24])\n#define _CFFI_NUM_EXPORTS 25\n\ntypedef struct _ctypedescr CTypeDescrObject;\n\nstatic void *_cffi_exports[_CFFI_NUM_EXPORTS];\nstatic PyObject *_cffi_types, *_cffi_VerificationError;\n\nstatic int _cffi_setup_custom(PyObject *lib);   /* forward */\n\nstatic PyObject *_cffi_setup(PyObject *self, PyObject *args)\n{\n    PyObject *library;\n    int was_alive = (_cffi_types != NULL);\n    (void)self; /* unused */\n    if (!PyArg_ParseTuple(args, \"OOO\", &_cffi_types, &_cffi_VerificationError,\n                                       &library))\n        return NULL;\n    Py_INCREF(_cffi_types);\n    Py_INCREF(_cffi_VerificationError);\n    if (_cffi_setup_custom(library) < 0)\n        return NULL;\n    return PyBool_FromLong(was_alive);\n}\n\nunion _cffi_union_alignment_u {\n    unsigned char m_char;\n    unsigned short m_short;\n    unsigned int m_int;\n    unsigned long m_long;\n    unsigned long long m_longlong;\n    float m_float;\n    double m_double;\n    long double m_longdouble;\n};\n\nstruct _cffi_freeme_s {\n    struct _cffi_freeme_s *next;\n    union _cffi_union_alignment_u alignment;\n};\n\n#ifdef __GNUC__\n  __attribute__((unused))\n#endif\nstatic int _cffi_convert_array_argument(CTypeDescrObject *ctptr, PyObject *arg,\n                                        char **output_data, Py_ssize_t datasize,\n                                        struct _cffi_freeme_s **freeme)\n{\n    char *p;\n    if (datasize < 0)\n        return -1;\n\n    p = *output_data;\n    if (p == NULL) {\n        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(\n            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);\n        if (fp == NULL)\n            return -1;\n        fp->next = *freeme;\n        *freeme = fp;\n        p = *output_data = (char *)&fp->alignment;\n    }\n    memset((void *)p, 0, (size_t)datasize);\n    return _cffi_convert_array_from_object(p, ctptr, arg);\n}\n\n#ifdef __GNUC__\n  __attribute__((unused))\n#endif\nstatic void _cffi_free_array_arguments(struct _cffi_freeme_s *freeme)\n{\n    do {\n        void *p = (void *)freeme;\n        freeme = freeme->next;\n        PyObject_Free(p);\n    } while (freeme != NULL);\n}\n\nstatic int _cffi_init(void)\n{\n    PyObject *module, *c_api_object = NULL;\n\n    module = PyImport_ImportModule(\"_cffi_backend\");\n    if (module == NULL)\n        goto failure;\n\n    c_api_object = PyObject_GetAttrString(module, \"_C_API\");\n    if (c_api_object == NULL)\n        goto failure;\n    if (!PyCapsule_CheckExact(c_api_object)) {\n        PyErr_SetNone(PyExc_ImportError);\n        goto failure;\n    }\n    memcpy(_cffi_exports, PyCapsule_GetPointer(c_api_object, \"cffi\"),\n           _CFFI_NUM_EXPORTS * sizeof(void *));\n\n    Py_DECREF(module);\n    Py_DECREF(c_api_object);\n    return 0;\n\n  failure:\n    Py_XDECREF(module);\n    Py_XDECREF(c_api_object);\n    return -1;\n}\n\n#define _cffi_type(num) ((CTypeDescrObject *)PyList_GET_ITEM(_cffi_types, num))\n\n/**********/\n'''\n", "src/cffi/recompiler.py": "import os, sys, io\nfrom . import ffiplatform, model\nfrom .error import VerificationError\nfrom .cffi_opcode import *\n\nVERSION_BASE = 0x2601\nVERSION_EMBEDDED = 0x2701\nVERSION_CHAR16CHAR32 = 0x2801\n\nUSE_LIMITED_API = (sys.platform != 'win32' or sys.version_info < (3, 0) or\n                   sys.version_info >= (3, 5))\n\n\nclass GlobalExpr:\n    def __init__(self, name, address, type_op, size=0, check_value=0):\n        self.name = name\n        self.address = address\n        self.type_op = type_op\n        self.size = size\n        self.check_value = check_value\n\n    def as_c_expr(self):\n        return '  { \"%s\", (void *)%s, %s, (void *)%s },' % (\n            self.name, self.address, self.type_op.as_c_expr(), self.size)\n\n    def as_python_expr(self):\n        return \"b'%s%s',%d\" % (self.type_op.as_python_bytes(), self.name,\n                               self.check_value)\n\nclass FieldExpr:\n    def __init__(self, name, field_offset, field_size, fbitsize, field_type_op):\n        self.name = name\n        self.field_offset = field_offset\n        self.field_size = field_size\n        self.fbitsize = fbitsize\n        self.field_type_op = field_type_op\n\n    def as_c_expr(self):\n        spaces = \" \" * len(self.name)\n        return ('  { \"%s\", %s,\\n' % (self.name, self.field_offset) +\n                '     %s   %s,\\n' % (spaces, self.field_size) +\n                '     %s   %s },' % (spaces, self.field_type_op.as_c_expr()))\n\n    def as_python_expr(self):\n        raise NotImplementedError\n\n    def as_field_python_expr(self):\n        if self.field_type_op.op == OP_NOOP:\n            size_expr = ''\n        elif self.field_type_op.op == OP_BITFIELD:\n            size_expr = format_four_bytes(self.fbitsize)\n        else:\n            raise NotImplementedError\n        return \"b'%s%s%s'\" % (self.field_type_op.as_python_bytes(),\n                              size_expr,\n                              self.name)\n\nclass StructUnionExpr:\n    def __init__(self, name, type_index, flags, size, alignment, comment,\n                 first_field_index, c_fields):\n        self.name = name\n        self.type_index = type_index\n        self.flags = flags\n        self.size = size\n        self.alignment = alignment\n        self.comment = comment\n        self.first_field_index = first_field_index\n        self.c_fields = c_fields\n\n    def as_c_expr(self):\n        return ('  { \"%s\", %d, %s,' % (self.name, self.type_index, self.flags)\n                + '\\n    %s, %s, ' % (self.size, self.alignment)\n                + '%d, %d ' % (self.first_field_index, len(self.c_fields))\n                + ('/* %s */ ' % self.comment if self.comment else '')\n                + '},')\n\n    def as_python_expr(self):\n        flags = eval(self.flags, G_FLAGS)\n        fields_expr = [c_field.as_field_python_expr()\n                       for c_field in self.c_fields]\n        return \"(b'%s%s%s',%s)\" % (\n            format_four_bytes(self.type_index),\n            format_four_bytes(flags),\n            self.name,\n            ','.join(fields_expr))\n\nclass EnumExpr:\n    def __init__(self, name, type_index, size, signed, allenums):\n        self.name = name\n        self.type_index = type_index\n        self.size = size\n        self.signed = signed\n        self.allenums = allenums\n\n    def as_c_expr(self):\n        return ('  { \"%s\", %d, _cffi_prim_int(%s, %s),\\n'\n                '    \"%s\" },' % (self.name, self.type_index,\n                                 self.size, self.signed, self.allenums))\n\n    def as_python_expr(self):\n        prim_index = {\n            (1, 0): PRIM_UINT8,  (1, 1):  PRIM_INT8,\n            (2, 0): PRIM_UINT16, (2, 1):  PRIM_INT16,\n            (4, 0): PRIM_UINT32, (4, 1):  PRIM_INT32,\n            (8, 0): PRIM_UINT64, (8, 1):  PRIM_INT64,\n            }[self.size, self.signed]\n        return \"b'%s%s%s\\\\x00%s'\" % (format_four_bytes(self.type_index),\n                                     format_four_bytes(prim_index),\n                                     self.name, self.allenums)\n\nclass TypenameExpr:\n    def __init__(self, name, type_index):\n        self.name = name\n        self.type_index = type_index\n\n    def as_c_expr(self):\n        return '  { \"%s\", %d },' % (self.name, self.type_index)\n\n    def as_python_expr(self):\n        return \"b'%s%s'\" % (format_four_bytes(self.type_index), self.name)\n\n\n# ____________________________________________________________\n\n\nclass Recompiler:\n    _num_externpy = 0\n\n    def __init__(self, ffi, module_name, target_is_python=False):\n        self.ffi = ffi\n        self.module_name = module_name\n        self.target_is_python = target_is_python\n        self._version = VERSION_BASE\n\n    def needs_version(self, ver):\n        self._version = max(self._version, ver)\n\n    def collect_type_table(self):\n        self._typesdict = {}\n        self._generate(\"collecttype\")\n        #\n        all_decls = sorted(self._typesdict, key=str)\n        #\n        # prepare all FUNCTION bytecode sequences first\n        self.cffi_types = []\n        for tp in all_decls:\n            if tp.is_raw_function:\n                assert self._typesdict[tp] is None\n                self._typesdict[tp] = len(self.cffi_types)\n                self.cffi_types.append(tp)     # placeholder\n                for tp1 in tp.args:\n                    assert isinstance(tp1, (model.VoidType,\n                                            model.BasePrimitiveType,\n                                            model.PointerType,\n                                            model.StructOrUnionOrEnum,\n                                            model.FunctionPtrType))\n                    if self._typesdict[tp1] is None:\n                        self._typesdict[tp1] = len(self.cffi_types)\n                    self.cffi_types.append(tp1)   # placeholder\n                self.cffi_types.append('END')     # placeholder\n        #\n        # prepare all OTHER bytecode sequences\n        for tp in all_decls:\n            if not tp.is_raw_function and self._typesdict[tp] is None:\n                self._typesdict[tp] = len(self.cffi_types)\n                self.cffi_types.append(tp)        # placeholder\n                if tp.is_array_type and tp.length is not None:\n                    self.cffi_types.append('LEN') # placeholder\n        assert None not in self._typesdict.values()\n        #\n        # collect all structs and unions and enums\n        self._struct_unions = {}\n        self._enums = {}\n        for tp in all_decls:\n            if isinstance(tp, model.StructOrUnion):\n                self._struct_unions[tp] = None\n            elif isinstance(tp, model.EnumType):\n                self._enums[tp] = None\n        for i, tp in enumerate(sorted(self._struct_unions,\n                                      key=lambda tp: tp.name)):\n            self._struct_unions[tp] = i\n        for i, tp in enumerate(sorted(self._enums,\n                                      key=lambda tp: tp.name)):\n            self._enums[tp] = i\n        #\n        # emit all bytecode sequences now\n        for tp in all_decls:\n            method = getattr(self, '_emit_bytecode_' + tp.__class__.__name__)\n            method(tp, self._typesdict[tp])\n        #\n        # consistency check\n        for op in self.cffi_types:\n            assert isinstance(op, CffiOp)\n        self.cffi_types = tuple(self.cffi_types)    # don't change any more\n\n    def _enum_fields(self, tp):\n        # When producing C, expand all anonymous struct/union fields.\n        # That's necessary to have C code checking the offsets of the\n        # individual fields contained in them.  When producing Python,\n        # don't do it and instead write it like it is, with the\n        # corresponding fields having an empty name.  Empty names are\n        # recognized at runtime when we import the generated Python\n        # file.\n        expand_anonymous_struct_union = not self.target_is_python\n        return tp.enumfields(expand_anonymous_struct_union)\n\n    def _do_collect_type(self, tp):\n        if not isinstance(tp, model.BaseTypeByIdentity):\n            if isinstance(tp, tuple):\n                for x in tp:\n                    self._do_collect_type(x)\n            return\n        if tp not in self._typesdict:\n            self._typesdict[tp] = None\n            if isinstance(tp, model.FunctionPtrType):\n                self._do_collect_type(tp.as_raw_function())\n            elif isinstance(tp, model.StructOrUnion):\n                if tp.fldtypes is not None and (\n                        tp not in self.ffi._parser._included_declarations):\n                    for name1, tp1, _, _ in self._enum_fields(tp):\n                        self._do_collect_type(self._field_type(tp, name1, tp1))\n            else:\n                for _, x in tp._get_items():\n                    self._do_collect_type(x)\n\n    def _generate(self, step_name):\n        lst = self.ffi._parser._declarations.items()\n        for name, (tp, quals) in sorted(lst):\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_cpy_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise VerificationError(\n                    \"not implemented in recompile(): %r\" % name)\n            try:\n                self._current_quals = quals\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    # ----------\n\n    ALL_STEPS = [\"global\", \"field\", \"struct_union\", \"enum\", \"typename\"]\n\n    def collect_step_tables(self):\n        # collect the declarations for '_cffi_globals', '_cffi_typenames', etc.\n        self._lsts = {}\n        for step_name in self.ALL_STEPS:\n            self._lsts[step_name] = []\n        self._seen_struct_unions = set()\n        self._generate(\"ctx\")\n        self._add_missing_struct_unions()\n        #\n        for step_name in self.ALL_STEPS:\n            lst = self._lsts[step_name]\n            if step_name != \"field\":\n                lst.sort(key=lambda entry: entry.name)\n            self._lsts[step_name] = tuple(lst)    # don't change any more\n        #\n        # check for a possible internal inconsistency: _cffi_struct_unions\n        # should have been generated with exactly self._struct_unions\n        lst = self._lsts[\"struct_union\"]\n        for tp, i in self._struct_unions.items():\n            assert i < len(lst)\n            assert lst[i].name == tp.name\n        assert len(lst) == len(self._struct_unions)\n        # same with enums\n        lst = self._lsts[\"enum\"]\n        for tp, i in self._enums.items():\n            assert i < len(lst)\n            assert lst[i].name == tp.name\n        assert len(lst) == len(self._enums)\n\n    # ----------\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def write_source_to_f(self, f, preamble):\n        if self.target_is_python:\n            assert preamble is None\n            self.write_py_source_to_f(f)\n        else:\n            assert preamble is not None\n            self.write_c_source_to_f(f, preamble)\n\n    def _rel_readlines(self, filename):\n        g = open(os.path.join(os.path.dirname(__file__), filename), 'r')\n        lines = g.readlines()\n        g.close()\n        return lines\n\n    def write_c_source_to_f(self, f, preamble):\n        self._f = f\n        prnt = self._prnt\n        if self.ffi._embedding is not None:\n            prnt('#define _CFFI_USE_EMBEDDING')\n        if not USE_LIMITED_API:\n            prnt('#define _CFFI_NO_LIMITED_API')\n        #\n        # first the '#include' (actually done by inlining the file's content)\n        lines = self._rel_readlines('_cffi_include.h')\n        i = lines.index('#include \"parse_c_type.h\"\\n')\n        lines[i:i+1] = self._rel_readlines('parse_c_type.h')\n        prnt(''.join(lines))\n        #\n        # if we have ffi._embedding != None, we give it here as a macro\n        # and include an extra file\n        base_module_name = self.module_name.split('.')[-1]\n        if self.ffi._embedding is not None:\n            prnt('#define _CFFI_MODULE_NAME  \"%s\"' % (self.module_name,))\n            prnt('static const char _CFFI_PYTHON_STARTUP_CODE[] = {')\n            self._print_string_literal_in_array(self.ffi._embedding)\n            prnt('0 };')\n            prnt('#ifdef PYPY_VERSION')\n            prnt('# define _CFFI_PYTHON_STARTUP_FUNC  _cffi_pypyinit_%s' % (\n                base_module_name,))\n            prnt('#elif PY_MAJOR_VERSION >= 3')\n            prnt('# define _CFFI_PYTHON_STARTUP_FUNC  PyInit_%s' % (\n                base_module_name,))\n            prnt('#else')\n            prnt('# define _CFFI_PYTHON_STARTUP_FUNC  init%s' % (\n                base_module_name,))\n            prnt('#endif')\n            lines = self._rel_readlines('_embedding.h')\n            i = lines.index('#include \"_cffi_errors.h\"\\n')\n            lines[i:i+1] = self._rel_readlines('_cffi_errors.h')\n            prnt(''.join(lines))\n            self.needs_version(VERSION_EMBEDDED)\n        #\n        # then paste the C source given by the user, verbatim.\n        prnt('/************************************************************/')\n        prnt()\n        prnt(preamble)\n        prnt()\n        prnt('/************************************************************/')\n        prnt()\n        #\n        # the declaration of '_cffi_types'\n        prnt('static void *_cffi_types[] = {')\n        typeindex2type = dict([(i, tp) for (tp, i) in self._typesdict.items()])\n        for i, op in enumerate(self.cffi_types):\n            comment = ''\n            if i in typeindex2type:\n                comment = ' // ' + typeindex2type[i]._get_c_name()\n            prnt('/* %2d */ %s,%s' % (i, op.as_c_expr(), comment))\n        if not self.cffi_types:\n            prnt('  0')\n        prnt('};')\n        prnt()\n        #\n        # call generate_cpy_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._seen_constants = set()\n        self._generate(\"decl\")\n        #\n        # the declaration of '_cffi_globals' and '_cffi_typenames'\n        nums = {}\n        for step_name in self.ALL_STEPS:\n            lst = self._lsts[step_name]\n            nums[step_name] = len(lst)\n            if nums[step_name] > 0:\n                prnt('static const struct _cffi_%s_s _cffi_%ss[] = {' % (\n                    step_name, step_name))\n                for entry in lst:\n                    prnt(entry.as_c_expr())\n                prnt('};')\n                prnt()\n        #\n        # the declaration of '_cffi_includes'\n        if self.ffi._included_ffis:\n            prnt('static const char * const _cffi_includes[] = {')\n            for ffi_to_include in self.ffi._included_ffis:\n                try:\n                    included_module_name, included_source = (\n                        ffi_to_include._assigned_source[:2])\n                except AttributeError:\n                    raise VerificationError(\n                        \"ffi object %r includes %r, but the latter has not \"\n                        \"been prepared with set_source()\" % (\n                            self.ffi, ffi_to_include,))\n                if included_source is None:\n                    raise VerificationError(\n                        \"not implemented yet: ffi.include() of a Python-based \"\n                        \"ffi inside a C-based ffi\")\n                prnt('  \"%s\",' % (included_module_name,))\n            prnt('  NULL')\n            prnt('};')\n            prnt()\n        #\n        # the declaration of '_cffi_type_context'\n        prnt('static const struct _cffi_type_context_s _cffi_type_context = {')\n        prnt('  _cffi_types,')\n        for step_name in self.ALL_STEPS:\n            if nums[step_name] > 0:\n                prnt('  _cffi_%ss,' % step_name)\n            else:\n                prnt('  NULL,  /* no %ss */' % step_name)\n        for step_name in self.ALL_STEPS:\n            if step_name != \"field\":\n                prnt('  %d,  /* num_%ss */' % (nums[step_name], step_name))\n        if self.ffi._included_ffis:\n            prnt('  _cffi_includes,')\n        else:\n            prnt('  NULL,  /* no includes */')\n        prnt('  %d,  /* num_types */' % (len(self.cffi_types),))\n        flags = 0\n        if self._num_externpy > 0 or self.ffi._embedding is not None:\n            flags |= 1     # set to mean that we use extern \"Python\"\n        prnt('  %d,  /* flags */' % flags)\n        prnt('};')\n        prnt()\n        #\n        # the init function\n        prnt('#ifdef __GNUC__')\n        prnt('#  pragma GCC visibility push(default)  /* for -fvisibility= */')\n        prnt('#endif')\n        prnt()\n        prnt('#ifdef PYPY_VERSION')\n        prnt('PyMODINIT_FUNC')\n        prnt('_cffi_pypyinit_%s(const void *p[])' % (base_module_name,))\n        prnt('{')\n        if flags & 1:\n            prnt('    if (((intptr_t)p[0]) >= 0x0A03) {')\n            prnt('        _cffi_call_python_org = '\n                 '(void(*)(struct _cffi_externpy_s *, char *))p[1];')\n            prnt('    }')\n        prnt('    p[0] = (const void *)0x%x;' % self._version)\n        prnt('    p[1] = &_cffi_type_context;')\n        prnt('#if PY_MAJOR_VERSION >= 3')\n        prnt('    return NULL;')\n        prnt('#endif')\n        prnt('}')\n        # on Windows, distutils insists on putting init_cffi_xyz in\n        # 'export_symbols', so instead of fighting it, just give up and\n        # give it one\n        prnt('#  ifdef _MSC_VER')\n        prnt('     PyMODINIT_FUNC')\n        prnt('#  if PY_MAJOR_VERSION >= 3')\n        prnt('     PyInit_%s(void) { return NULL; }' % (base_module_name,))\n        prnt('#  else')\n        prnt('     init%s(void) { }' % (base_module_name,))\n        prnt('#  endif')\n        prnt('#  endif')\n        prnt('#elif PY_MAJOR_VERSION >= 3')\n        prnt('PyMODINIT_FUNC')\n        prnt('PyInit_%s(void)' % (base_module_name,))\n        prnt('{')\n        prnt('  return _cffi_init(\"%s\", 0x%x, &_cffi_type_context);' % (\n            self.module_name, self._version))\n        prnt('}')\n        prnt('#else')\n        prnt('PyMODINIT_FUNC')\n        prnt('init%s(void)' % (base_module_name,))\n        prnt('{')\n        prnt('  _cffi_init(\"%s\", 0x%x, &_cffi_type_context);' % (\n            self.module_name, self._version))\n        prnt('}')\n        prnt('#endif')\n        prnt()\n        prnt('#ifdef __GNUC__')\n        prnt('#  pragma GCC visibility pop')\n        prnt('#endif')\n        self._version = None\n\n    def _to_py(self, x):\n        if isinstance(x, str):\n            return \"b'%s'\" % (x,)\n        if isinstance(x, (list, tuple)):\n            rep = [self._to_py(item) for item in x]\n            if len(rep) == 1:\n                rep.append('')\n            return \"(%s)\" % (','.join(rep),)\n        return x.as_python_expr()  # Py2: unicode unexpected; Py3: bytes unexp.\n\n    def write_py_source_to_f(self, f):\n        self._f = f\n        prnt = self._prnt\n        #\n        # header\n        prnt(\"# auto-generated file\")\n        prnt(\"import _cffi_backend\")\n        #\n        # the 'import' of the included ffis\n        num_includes = len(self.ffi._included_ffis or ())\n        for i in range(num_includes):\n            ffi_to_include = self.ffi._included_ffis[i]\n            try:\n                included_module_name, included_source = (\n                    ffi_to_include._assigned_source[:2])\n            except AttributeError:\n                raise VerificationError(\n                    \"ffi object %r includes %r, but the latter has not \"\n                    \"been prepared with set_source()\" % (\n                        self.ffi, ffi_to_include,))\n            if included_source is not None:\n                raise VerificationError(\n                    \"not implemented yet: ffi.include() of a C-based \"\n                    \"ffi inside a Python-based ffi\")\n            prnt('from %s import ffi as _ffi%d' % (included_module_name, i))\n        prnt()\n        prnt(\"ffi = _cffi_backend.FFI('%s',\" % (self.module_name,))\n        prnt(\"    _version = 0x%x,\" % (self._version,))\n        self._version = None\n        #\n        # the '_types' keyword argument\n        self.cffi_types = tuple(self.cffi_types)    # don't change any more\n        types_lst = [op.as_python_bytes() for op in self.cffi_types]\n        prnt('    _types = %s,' % (self._to_py(''.join(types_lst)),))\n        typeindex2type = dict([(i, tp) for (tp, i) in self._typesdict.items()])\n        #\n        # the keyword arguments from ALL_STEPS\n        for step_name in self.ALL_STEPS:\n            lst = self._lsts[step_name]\n            if len(lst) > 0 and step_name != \"field\":\n                prnt('    _%ss = %s,' % (step_name, self._to_py(lst)))\n        #\n        # the '_includes' keyword argument\n        if num_includes > 0:\n            prnt('    _includes = (%s,),' % (\n                ', '.join(['_ffi%d' % i for i in range(num_includes)]),))\n        #\n        # the footer\n        prnt(')')\n\n    # ----------\n\n    def _gettypenum(self, type):\n        # a KeyError here is a bug.  please report it! :-)\n        return self._typesdict[type]\n\n    def _convert_funcarg_to_c(self, tp, fromvar, tovar, errcode):\n        extraarg = ''\n        if isinstance(tp, model.BasePrimitiveType) and not tp.is_complex_type():\n            if tp.is_integer_type() and tp.name != '_Bool':\n                converter = '_cffi_to_c_int'\n                extraarg = ', %s' % tp.name\n            elif isinstance(tp, model.UnknownFloatType):\n                # don't check with is_float_type(): it may be a 'long\n                # double' here, and _cffi_to_c_double would loose precision\n                converter = '(%s)_cffi_to_c_double' % (tp.get_c_name(''),)\n            else:\n                cname = tp.get_c_name('')\n                converter = '(%s)_cffi_to_c_%s' % (cname,\n                                                   tp.name.replace(' ', '_'))\n                if cname in ('char16_t', 'char32_t'):\n                    self.needs_version(VERSION_CHAR16CHAR32)\n            errvalue = '-1'\n        #\n        elif isinstance(tp, model.PointerType):\n            self._convert_funcarg_to_c_ptr_or_array(tp, fromvar,\n                                                    tovar, errcode)\n            return\n        #\n        elif (isinstance(tp, model.StructOrUnionOrEnum) or\n              isinstance(tp, model.BasePrimitiveType)):\n            # a struct (not a struct pointer) as a function argument;\n            # or, a complex (the same code works)\n            self._prnt('  if (_cffi_to_c((char *)&%s, _cffi_type(%d), %s) < 0)'\n                      % (tovar, self._gettypenum(tp), fromvar))\n            self._prnt('    %s;' % errcode)\n            return\n        #\n        elif isinstance(tp, model.FunctionPtrType):\n            converter = '(%s)_cffi_to_c_pointer' % tp.get_c_name('')\n            extraarg = ', _cffi_type(%d)' % self._gettypenum(tp)\n            errvalue = 'NULL'\n        #\n        else:\n            raise NotImplementedError(tp)\n        #\n        self._prnt('  %s = %s(%s%s);' % (tovar, converter, fromvar, extraarg))\n        self._prnt('  if (%s == (%s)%s && PyErr_Occurred())' % (\n            tovar, tp.get_c_name(''), errvalue))\n        self._prnt('    %s;' % errcode)\n\n    def _extra_local_variables(self, tp, localvars, freelines):\n        if isinstance(tp, model.PointerType):\n            localvars.add('Py_ssize_t datasize')\n            localvars.add('struct _cffi_freeme_s *large_args_free = NULL')\n            freelines.add('if (large_args_free != NULL)'\n                          ' _cffi_free_array_arguments(large_args_free);')\n\n    def _convert_funcarg_to_c_ptr_or_array(self, tp, fromvar, tovar, errcode):\n        self._prnt('  datasize = _cffi_prepare_pointer_call_argument(')\n        self._prnt('      _cffi_type(%d), %s, (char **)&%s);' % (\n            self._gettypenum(tp), fromvar, tovar))\n        self._prnt('  if (datasize != 0) {')\n        self._prnt('    %s = ((size_t)datasize) <= 640 ? '\n                   '(%s)alloca((size_t)datasize) : NULL;' % (\n            tovar, tp.get_c_name('')))\n        self._prnt('    if (_cffi_convert_array_argument(_cffi_type(%d), %s, '\n                   '(char **)&%s,' % (self._gettypenum(tp), fromvar, tovar))\n        self._prnt('            datasize, &large_args_free) < 0)')\n        self._prnt('      %s;' % errcode)\n        self._prnt('  }')\n\n    def _convert_expr_from_c(self, tp, var, context):\n        if isinstance(tp, model.BasePrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                return '_cffi_from_c_int(%s, %s)' % (var, tp.name)\n            elif isinstance(tp, model.UnknownFloatType):\n                return '_cffi_from_c_double(%s)' % (var,)\n            elif tp.name != 'long double' and not tp.is_complex_type():\n                cname = tp.name.replace(' ', '_')\n                if cname in ('char16_t', 'char32_t'):\n                    self.needs_version(VERSION_CHAR16CHAR32)\n                return '_cffi_from_c_%s(%s)' % (cname, var)\n            else:\n                return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                    var, self._gettypenum(tp))\n        elif isinstance(tp, (model.PointerType, model.FunctionPtrType)):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.ArrayType):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(model.PointerType(tp.item)))\n        elif isinstance(tp, model.StructOrUnion):\n            if tp.fldnames is None:\n                raise TypeError(\"'%s' is used as %s, but is opaque\" % (\n                    tp._get_c_name(), context))\n            return '_cffi_from_c_struct((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.EnumType):\n            return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        else:\n            raise NotImplementedError(tp)\n\n    # ----------\n    # typedefs\n\n    def _typedef_type(self, tp, name):\n        return self._global_type(tp, \"(*(%s *)0)\" % (name,))\n\n    def _generate_cpy_typedef_collecttype(self, tp, name):\n        self._do_collect_type(self._typedef_type(tp, name))\n\n    def _generate_cpy_typedef_decl(self, tp, name):\n        pass\n\n    def _typedef_ctx(self, tp, name):\n        type_index = self._typesdict[tp]\n        self._lsts[\"typename\"].append(TypenameExpr(name, type_index))\n\n    def _generate_cpy_typedef_ctx(self, tp, name):\n        tp = self._typedef_type(tp, name)\n        self._typedef_ctx(tp, name)\n        if getattr(tp, \"origin\", None) == \"unknown_type\":\n            self._struct_ctx(tp, tp.name, approxname=None)\n        elif isinstance(tp, model.NamedPointerType):\n            self._struct_ctx(tp.totype, tp.totype.name, approxname=tp.name,\n                             named_ptr=tp)\n\n    # ----------\n    # function declarations\n\n    def _generate_cpy_function_collecttype(self, tp, name):\n        self._do_collect_type(tp.as_raw_function())\n        if tp.ellipsis and not self.target_is_python:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_function_decl(self, tp, name):\n        assert not self.target_is_python\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no CPython wrapper)\n            self._generate_cpy_constant_decl(tp, name)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        if numargs == 0:\n            argname = 'noarg'\n        elif numargs == 1:\n            argname = 'arg0'\n        else:\n            argname = 'args'\n        #\n        # ------------------------------\n        # the 'd' version of the function, only for addressof(lib, 'func')\n        arguments = []\n        call_arguments = []\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            arguments.append(type.get_c_name(' x%d' % i, context))\n            call_arguments.append('x%d' % i)\n        repr_arguments = ', '.join(arguments)\n        repr_arguments = repr_arguments or 'void'\n        if tp.abi:\n            abi = tp.abi + ' '\n        else:\n            abi = ''\n        name_and_arguments = '%s_cffi_d_%s(%s)' % (abi, name, repr_arguments)\n        prnt('static %s' % (tp.result.get_c_name(name_and_arguments),))\n        prnt('{')\n        call_arguments = ', '.join(call_arguments)\n        result_code = 'return '\n        if isinstance(tp.result, model.VoidType):\n            result_code = ''\n        prnt('  %s%s(%s);' % (result_code, name, call_arguments))\n        prnt('}')\n        #\n        prnt('#ifndef PYPY_VERSION')        # ------------------------------\n        #\n        prnt('static PyObject *')\n        prnt('_cffi_f_%s(PyObject *self, PyObject *%s)' % (name, argname))\n        prnt('{')\n        #\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            arg = type.get_c_name(' x%d' % i, context)\n            prnt('  %s;' % arg)\n        #\n        localvars = set()\n        freelines = set()\n        for type in tp.args:\n            self._extra_local_variables(type, localvars, freelines)\n        for decl in sorted(localvars):\n            prnt('  %s;' % (decl,))\n        #\n        if not isinstance(tp.result, model.VoidType):\n            result_code = 'result = '\n            context = 'result of %s' % name\n            result_decl = '  %s;' % tp.result.get_c_name(' result', context)\n            prnt(result_decl)\n            prnt('  PyObject *pyresult;')\n        else:\n            result_decl = None\n            result_code = ''\n        #\n        if len(tp.args) > 1:\n            rng = range(len(tp.args))\n            for i in rng:\n                prnt('  PyObject *arg%d;' % i)\n            prnt()\n            prnt('  if (!PyArg_UnpackTuple(args, \"%s\", %d, %d, %s))' % (\n                name, len(rng), len(rng),\n                ', '.join(['&arg%d' % i for i in rng])))\n            prnt('    return NULL;')\n        prnt()\n        #\n        for i, type in enumerate(tp.args):\n            self._convert_funcarg_to_c(type, 'arg%d' % i, 'x%d' % i,\n                                       'return NULL')\n            prnt()\n        #\n        prnt('  Py_BEGIN_ALLOW_THREADS')\n        prnt('  _cffi_restore_errno();')\n        call_arguments = ['x%d' % i for i in range(len(tp.args))]\n        call_arguments = ', '.join(call_arguments)\n        prnt('  { %s%s(%s); }' % (result_code, name, call_arguments))\n        prnt('  _cffi_save_errno();')\n        prnt('  Py_END_ALLOW_THREADS')\n        prnt()\n        #\n        prnt('  (void)self; /* unused */')\n        if numargs == 0:\n            prnt('  (void)noarg; /* unused */')\n        if result_code:\n            prnt('  pyresult = %s;' %\n                 self._convert_expr_from_c(tp.result, 'result', 'result type'))\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  return pyresult;')\n        else:\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  Py_INCREF(Py_None);')\n            prnt('  return Py_None;')\n        prnt('}')\n        #\n        prnt('#else')        # ------------------------------\n        #\n        # the PyPy version: need to replace struct/union arguments with\n        # pointers, and if the result is a struct/union, insert a first\n        # arg that is a pointer to the result.  We also do that for\n        # complex args and return type.\n        def need_indirection(type):\n            return (isinstance(type, model.StructOrUnion) or\n                    (isinstance(type, model.PrimitiveType) and\n                     type.is_complex_type()))\n        difference = False\n        arguments = []\n        call_arguments = []\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            indirection = ''\n            if need_indirection(type):\n                indirection = '*'\n                difference = True\n            arg = type.get_c_name(' %sx%d' % (indirection, i), context)\n            arguments.append(arg)\n            call_arguments.append('%sx%d' % (indirection, i))\n        tp_result = tp.result\n        if need_indirection(tp_result):\n            context = 'result of %s' % name\n            arg = tp_result.get_c_name(' *result', context)\n            arguments.insert(0, arg)\n            tp_result = model.void_type\n            result_decl = None\n            result_code = '*result = '\n            difference = True\n        if difference:\n            repr_arguments = ', '.join(arguments)\n            repr_arguments = repr_arguments or 'void'\n            name_and_arguments = '%s_cffi_f_%s(%s)' % (abi, name,\n                                                       repr_arguments)\n            prnt('static %s' % (tp_result.get_c_name(name_and_arguments),))\n            prnt('{')\n            if result_decl:\n                prnt(result_decl)\n            call_arguments = ', '.join(call_arguments)\n            prnt('  { %s%s(%s); }' % (result_code, name, call_arguments))\n            if result_decl:\n                prnt('  return result;')\n            prnt('}')\n        else:\n            prnt('#  define _cffi_f_%s _cffi_d_%s' % (name, name))\n        #\n        prnt('#endif')        # ------------------------------\n        prnt()\n\n    def _generate_cpy_function_ctx(self, tp, name):\n        if tp.ellipsis and not self.target_is_python:\n            self._generate_cpy_constant_ctx(tp, name)\n            return\n        type_index = self._typesdict[tp.as_raw_function()]\n        numargs = len(tp.args)\n        if self.target_is_python:\n            meth_kind = OP_DLOPEN_FUNC\n        elif numargs == 0:\n            meth_kind = OP_CPYTHON_BLTN_N   # 'METH_NOARGS'\n        elif numargs == 1:\n            meth_kind = OP_CPYTHON_BLTN_O   # 'METH_O'\n        else:\n            meth_kind = OP_CPYTHON_BLTN_V   # 'METH_VARARGS'\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_f_%s' % name,\n                       CffiOp(meth_kind, type_index),\n                       size='_cffi_d_%s' % name))\n\n    # ----------\n    # named structs or unions\n\n    def _field_type(self, tp_struct, field_name, tp_field):\n        if isinstance(tp_field, model.ArrayType):\n            actual_length = tp_field.length\n            if actual_length == '...':\n                ptr_struct_name = tp_struct.get_c_name('*')\n                actual_length = '_cffi_array_len(((%s)0)->%s)' % (\n                    ptr_struct_name, field_name)\n            tp_item = self._field_type(tp_struct, '%s[0]' % field_name,\n                                       tp_field.item)\n            tp_field = model.ArrayType(tp_item, actual_length)\n        return tp_field\n\n    def _struct_collecttype(self, tp):\n        self._do_collect_type(tp)\n        if self.target_is_python:\n            # also requires nested anon struct/unions in ABI mode, recursively\n            for fldtype in tp.anonymous_struct_fields():\n                self._struct_collecttype(fldtype)\n\n    def _struct_decl(self, tp, cname, approxname):\n        if tp.fldtypes is None:\n            return\n        prnt = self._prnt\n        checkfuncname = '_cffi_checkfld_%s' % (approxname,)\n        prnt('_CFFI_UNUSED_FN')\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize, fqual in self._enum_fields(tp):\n            try:\n                if ftype.is_integer_type() or fbitsize >= 0:\n                    # accept all integers, but complain on float or double\n                    if fname != '':\n                        prnt(\"  (void)((p->%s) | 0);  /* check that '%s.%s' is \"\n                             \"an integer */\" % (fname, cname, fname))\n                    continue\n                # only accept exactly the type declared, except that '[]'\n                # is interpreted as a '*' and so will match any array length.\n                # (It would also match '*', but that's harder to detect...)\n                while (isinstance(ftype, model.ArrayType)\n                       and (ftype.length is None or ftype.length == '...')):\n                    ftype = ftype.item\n                    fname = fname + '[0]'\n                prnt('  { %s = &p->%s; (void)tmp; }' % (\n                    ftype.get_c_name('*tmp', 'field %r'%fname, quals=fqual),\n                    fname))\n            except VerificationError as e:\n                prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        prnt('struct _cffi_align_%s { char x; %s y; };' % (approxname, cname))\n        prnt()\n\n    def _struct_ctx(self, tp, cname, approxname, named_ptr=None):\n        type_index = self._typesdict[tp]\n        reason_for_not_expanding = None\n        flags = []\n        if isinstance(tp, model.UnionType):\n            flags.append(\"_CFFI_F_UNION\")\n        if tp.fldtypes is None:\n            flags.append(\"_CFFI_F_OPAQUE\")\n            reason_for_not_expanding = \"opaque\"\n        if (tp not in self.ffi._parser._included_declarations and\n                (named_ptr is None or\n                 named_ptr not in self.ffi._parser._included_declarations)):\n            if tp.fldtypes is None:\n                pass    # opaque\n            elif tp.partial or any(tp.anonymous_struct_fields()):\n                pass    # field layout obtained silently from the C compiler\n            else:\n                flags.append(\"_CFFI_F_CHECK_FIELDS\")\n            if tp.packed:\n                if tp.packed > 1:\n                    raise NotImplementedError(\n                        \"%r is declared with 'pack=%r'; only 0 or 1 are \"\n                        \"supported in API mode (try to use \\\"...;\\\", which \"\n                        \"does not require a 'pack' declaration)\" %\n                        (tp, tp.packed))\n                flags.append(\"_CFFI_F_PACKED\")\n        else:\n            flags.append(\"_CFFI_F_EXTERNAL\")\n            reason_for_not_expanding = \"external\"\n        flags = '|'.join(flags) or '0'\n        c_fields = []\n        if reason_for_not_expanding is None:\n            enumfields = list(self._enum_fields(tp))\n            for fldname, fldtype, fbitsize, fqual in enumfields:\n                fldtype = self._field_type(tp, fldname, fldtype)\n                self._check_not_opaque(fldtype,\n                                       \"field '%s.%s'\" % (tp.name, fldname))\n                # cname is None for _add_missing_struct_unions() only\n                op = OP_NOOP\n                if fbitsize >= 0:\n                    op = OP_BITFIELD\n                    size = '%d /* bits */' % fbitsize\n                elif cname is None or (\n                        isinstance(fldtype, model.ArrayType) and\n                        fldtype.length is None):\n                    size = '(size_t)-1'\n                else:\n                    size = 'sizeof(((%s)0)->%s)' % (\n                        tp.get_c_name('*') if named_ptr is None\n                                           else named_ptr.name,\n                        fldname)\n                if cname is None or fbitsize >= 0:\n                    offset = '(size_t)-1'\n                elif named_ptr is not None:\n                    offset = '((char *)&((%s)4096)->%s) - (char *)4096' % (\n                        named_ptr.name, fldname)\n                else:\n                    offset = 'offsetof(%s, %s)' % (tp.get_c_name(''), fldname)\n                c_fields.append(\n                    FieldExpr(fldname, offset, size, fbitsize,\n                              CffiOp(op, self._typesdict[fldtype])))\n            first_field_index = len(self._lsts[\"field\"])\n            self._lsts[\"field\"].extend(c_fields)\n            #\n            if cname is None:  # unknown name, for _add_missing_struct_unions\n                size = '(size_t)-2'\n                align = -2\n                comment = \"unnamed\"\n            else:\n                if named_ptr is not None:\n                    size = 'sizeof(*(%s)0)' % (named_ptr.name,)\n                    align = '-1 /* unknown alignment */'\n                else:\n                    size = 'sizeof(%s)' % (cname,)\n                    align = 'offsetof(struct _cffi_align_%s, y)' % (approxname,)\n                comment = None\n        else:\n            size = '(size_t)-1'\n            align = -1\n            first_field_index = -1\n            comment = reason_for_not_expanding\n        self._lsts[\"struct_union\"].append(\n            StructUnionExpr(tp.name, type_index, flags, size, align, comment,\n                            first_field_index, c_fields))\n        self._seen_struct_unions.add(tp)\n\n    def _check_not_opaque(self, tp, location):\n        while isinstance(tp, model.ArrayType):\n            tp = tp.item\n        if isinstance(tp, model.StructOrUnion) and tp.fldtypes is None:\n            raise TypeError(\n                \"%s is of an opaque type (not declared in cdef())\" % location)\n\n    def _add_missing_struct_unions(self):\n        # not very nice, but some struct declarations might be missing\n        # because they don't have any known C name.  Check that they are\n        # not partial (we can't complete or verify them!) and emit them\n        # anonymously.\n        lst = list(self._struct_unions.items())\n        lst.sort(key=lambda tp_order: tp_order[1])\n        for tp, order in lst:\n            if tp not in self._seen_struct_unions:\n                if tp.partial:\n                    raise NotImplementedError(\"internal inconsistency: %r is \"\n                                              \"partial but was not seen at \"\n                                              \"this point\" % (tp,))\n                if tp.name.startswith('$') and tp.name[1:].isdigit():\n                    approxname = tp.name[1:]\n                elif tp.name == '_IO_FILE' and tp.forcename == 'FILE':\n                    approxname = 'FILE'\n                    self._typedef_ctx(tp, 'FILE')\n                else:\n                    raise NotImplementedError(\"internal inconsistency: %r\" %\n                                              (tp,))\n                self._struct_ctx(tp, None, approxname)\n\n    def _generate_cpy_struct_collecttype(self, tp, name):\n        self._struct_collecttype(tp)\n    _generate_cpy_union_collecttype = _generate_cpy_struct_collecttype\n\n    def _struct_names(self, tp):\n        cname = tp.get_c_name('')\n        if ' ' in cname:\n            return cname, cname.replace(' ', '_')\n        else:\n            return cname, '_' + cname\n\n    def _generate_cpy_struct_decl(self, tp, name):\n        self._struct_decl(tp, *self._struct_names(tp))\n    _generate_cpy_union_decl = _generate_cpy_struct_decl\n\n    def _generate_cpy_struct_ctx(self, tp, name):\n        self._struct_ctx(tp, *self._struct_names(tp))\n    _generate_cpy_union_ctx = _generate_cpy_struct_ctx\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    def _generate_cpy_anonymous_collecttype(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_collecttype(tp, name)\n        else:\n            self._struct_collecttype(tp)\n\n    def _generate_cpy_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_decl(tp)\n        else:\n            self._struct_decl(tp, name, 'typedef_' + name)\n\n    def _generate_cpy_anonymous_ctx(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._enum_ctx(tp, name)\n        else:\n            self._struct_ctx(tp, name, 'typedef_' + name)\n\n    # ----------\n    # constants, declared with \"static const ...\"\n\n    def _generate_cpy_const(self, is_int, name, tp=None, category='const',\n                            check_value=None):\n        if (category, name) in self._seen_constants:\n            raise VerificationError(\n                \"duplicate declaration of %s '%s'\" % (category, name))\n        self._seen_constants.add((category, name))\n        #\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        if is_int:\n            prnt('static int %s(unsigned long long *o)' % funcname)\n            prnt('{')\n            prnt('  int n = (%s) <= 0;' % (name,))\n            prnt('  *o = (unsigned long long)((%s) | 0);'\n                 '  /* check that %s is an integer */' % (name, name))\n            if check_value is not None:\n                if check_value > 0:\n                    check_value = '%dU' % (check_value,)\n                prnt('  if (!_cffi_check_int(*o, n, %s))' % (check_value,))\n                prnt('    n |= 2;')\n            prnt('  return n;')\n            prnt('}')\n        else:\n            assert check_value is None\n            prnt('static void %s(char *o)' % funcname)\n            prnt('{')\n            prnt('  *(%s)o = %s;' % (tp.get_c_name('*'), name))\n            prnt('}')\n        prnt()\n\n    def _generate_cpy_constant_collecttype(self, tp, name):\n        is_int = tp.is_integer_type()\n        if not is_int or self.target_is_python:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_constant_decl(self, tp, name):\n        is_int = tp.is_integer_type()\n        self._generate_cpy_const(is_int, name, tp)\n\n    def _generate_cpy_constant_ctx(self, tp, name):\n        if not self.target_is_python and tp.is_integer_type():\n            type_op = CffiOp(OP_CONSTANT_INT, -1)\n        else:\n            if self.target_is_python:\n                const_kind = OP_DLOPEN_CONST\n            else:\n                const_kind = OP_CONSTANT\n            type_index = self._typesdict[tp]\n            type_op = CffiOp(const_kind, type_index)\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_const_%s' % name, type_op))\n\n    # ----------\n    # enums\n\n    def _generate_cpy_enum_collecttype(self, tp, name):\n        self._do_collect_type(tp)\n\n    def _generate_cpy_enum_decl(self, tp, name=None):\n        for enumerator in tp.enumerators:\n            self._generate_cpy_const(True, enumerator)\n\n    def _enum_ctx(self, tp, cname):\n        type_index = self._typesdict[tp]\n        type_op = CffiOp(OP_ENUM, -1)\n        if self.target_is_python:\n            tp.check_not_partial()\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._lsts[\"global\"].append(\n                GlobalExpr(enumerator, '_cffi_const_%s' % enumerator, type_op,\n                           check_value=enumvalue))\n        #\n        if cname is not None and '$' not in cname and not self.target_is_python:\n            size = \"sizeof(%s)\" % cname\n            signed = \"((%s)-1) <= 0\" % cname\n        else:\n            basetp = tp.build_baseinttype(self.ffi, [])\n            size = self.ffi.sizeof(basetp)\n            signed = int(int(self.ffi.cast(basetp, -1)) < 0)\n        allenums = \",\".join(tp.enumerators)\n        self._lsts[\"enum\"].append(\n            EnumExpr(tp.name, type_index, size, signed, allenums))\n\n    def _generate_cpy_enum_ctx(self, tp, name):\n        self._enum_ctx(tp, tp._get_c_name())\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_cpy_macro_collecttype(self, tp, name):\n        pass\n\n    def _generate_cpy_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_cpy_const(True, name, check_value=check_value)\n\n    def _generate_cpy_macro_ctx(self, tp, name):\n        if tp == '...':\n            if self.target_is_python:\n                raise VerificationError(\n                    \"cannot use the syntax '...' in '#define %s ...' when \"\n                    \"using the ABI mode\" % (name,))\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        type_op = CffiOp(OP_CONSTANT_INT, -1)\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_const_%s' % name, type_op,\n                       check_value=check_value))\n\n    # ----------\n    # global variables\n\n    def _global_type(self, tp, global_name):\n        if isinstance(tp, model.ArrayType):\n            actual_length = tp.length\n            if actual_length == '...':\n                actual_length = '_cffi_array_len(%s)' % (global_name,)\n            tp_item = self._global_type(tp.item, '%s[0]' % global_name)\n            tp = model.ArrayType(tp_item, actual_length)\n        return tp\n\n    def _generate_cpy_variable_collecttype(self, tp, name):\n        self._do_collect_type(self._global_type(tp, name))\n\n    def _generate_cpy_variable_decl(self, tp, name):\n        prnt = self._prnt\n        tp = self._global_type(tp, name)\n        if isinstance(tp, model.ArrayType) and tp.length is None:\n            tp = tp.item\n            ampersand = ''\n        else:\n            ampersand = '&'\n        # This code assumes that casts from \"tp *\" to \"void *\" is a\n        # no-op, i.e. a function that returns a \"tp *\" can be called\n        # as if it returned a \"void *\".  This should be generally true\n        # on any modern machine.  The only exception to that rule (on\n        # uncommon architectures, and as far as I can tell) might be\n        # if 'tp' were a function type, but that is not possible here.\n        # (If 'tp' is a function _pointer_ type, then casts from \"fn_t\n        # **\" to \"void *\" are again no-ops, as far as I can tell.)\n        decl = '*_cffi_var_%s(void)' % (name,)\n        prnt('static ' + tp.get_c_name(decl, quals=self._current_quals))\n        prnt('{')\n        prnt('  return %s(%s);' % (ampersand, name))\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_variable_ctx(self, tp, name):\n        tp = self._global_type(tp, name)\n        type_index = self._typesdict[tp]\n        if self.target_is_python:\n            op = OP_GLOBAL_VAR\n        else:\n            op = OP_GLOBAL_VAR_F\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_var_%s' % name, CffiOp(op, type_index)))\n\n    # ----------\n    # extern \"Python\"\n\n    def _generate_cpy_extern_python_collecttype(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        self._do_collect_type(tp)\n    _generate_cpy_dllexport_python_collecttype = \\\n      _generate_cpy_extern_python_plus_c_collecttype = \\\n      _generate_cpy_extern_python_collecttype\n\n    def _extern_python_decl(self, tp, name, tag_and_space):\n        prnt = self._prnt\n        if isinstance(tp.result, model.VoidType):\n            size_of_result = '0'\n        else:\n            context = 'result of %s' % name\n            size_of_result = '(int)sizeof(%s)' % (\n                tp.result.get_c_name('', context),)\n        prnt('static struct _cffi_externpy_s _cffi_externpy__%s =' % name)\n        prnt('  { \"%s.%s\", %s, 0, 0 };' % (\n            self.module_name, name, size_of_result))\n        prnt()\n        #\n        arguments = []\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            arg = type.get_c_name(' a%d' % i, context)\n            arguments.append(arg)\n        #\n        repr_arguments = ', '.join(arguments)\n        repr_arguments = repr_arguments or 'void'\n        name_and_arguments = '%s(%s)' % (name, repr_arguments)\n        if tp.abi == \"__stdcall\":\n            name_and_arguments = '_cffi_stdcall ' + name_and_arguments\n        #\n        def may_need_128_bits(tp):\n            return (isinstance(tp, model.PrimitiveType) and\n                    tp.name == 'long double')\n        #\n        size_of_a = max(len(tp.args)*8, 8)\n        if may_need_128_bits(tp.result):\n            size_of_a = max(size_of_a, 16)\n        if isinstance(tp.result, model.StructOrUnion):\n            size_of_a = 'sizeof(%s) > %d ? sizeof(%s) : %d' % (\n                tp.result.get_c_name(''), size_of_a,\n                tp.result.get_c_name(''), size_of_a)\n        prnt('%s%s' % (tag_and_space, tp.result.get_c_name(name_and_arguments)))\n        prnt('{')\n        prnt('  char a[%s];' % size_of_a)\n        prnt('  char *p = a;')\n        for i, type in enumerate(tp.args):\n            arg = 'a%d' % i\n            if (isinstance(type, model.StructOrUnion) or\n                    may_need_128_bits(type)):\n                arg = '&' + arg\n                type = model.PointerType(type)\n            prnt('  *(%s)(p + %d) = %s;' % (type.get_c_name('*'), i*8, arg))\n        prnt('  _cffi_call_python(&_cffi_externpy__%s, p);' % name)\n        if not isinstance(tp.result, model.VoidType):\n            prnt('  return *(%s)p;' % (tp.result.get_c_name('*'),))\n        prnt('}')\n        prnt()\n        self._num_externpy += 1\n\n    def _generate_cpy_extern_python_decl(self, tp, name):\n        self._extern_python_decl(tp, name, 'static ')\n\n    def _generate_cpy_dllexport_python_decl(self, tp, name):\n        self._extern_python_decl(tp, name, 'CFFI_DLLEXPORT ')\n\n    def _generate_cpy_extern_python_plus_c_decl(self, tp, name):\n        self._extern_python_decl(tp, name, '')\n\n    def _generate_cpy_extern_python_ctx(self, tp, name):\n        if self.target_is_python:\n            raise VerificationError(\n                \"cannot use 'extern \\\"Python\\\"' in the ABI mode\")\n        if tp.ellipsis:\n            raise NotImplementedError(\"a vararg function is extern \\\"Python\\\"\")\n        type_index = self._typesdict[tp]\n        type_op = CffiOp(OP_EXTERN_PYTHON, type_index)\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '&_cffi_externpy__%s' % name, type_op, name))\n\n    _generate_cpy_dllexport_python_ctx = \\\n      _generate_cpy_extern_python_plus_c_ctx = \\\n      _generate_cpy_extern_python_ctx\n\n    def _print_string_literal_in_array(self, s):\n        prnt = self._prnt\n        prnt('// # NB. this is not a string because of a size limit in MSVC')\n        if not isinstance(s, bytes):    # unicode\n            s = s.encode('utf-8')       # -> bytes\n        else:\n            s.decode('utf-8')           # got bytes, check for valid utf-8\n        try:\n            s.decode('ascii')\n        except UnicodeDecodeError:\n            s = b'# -*- encoding: utf8 -*-\\n' + s\n        for line in s.splitlines(True):\n            comment = line\n            if type('//') is bytes:     # python2\n                line = map(ord, line)   #     make a list of integers\n            else:                       # python3\n                # type(line) is bytes, which enumerates like a list of integers\n                comment = ascii(comment)[1:-1]\n            prnt(('// ' + comment).rstrip())\n            printed_line = ''\n            for c in line:\n                if len(printed_line) >= 76:\n                    prnt(printed_line)\n                    printed_line = ''\n                printed_line += '%d,' % (c,)\n            prnt(printed_line)\n\n    # ----------\n    # emitting the opcodes for individual types\n\n    def _emit_bytecode_VoidType(self, tp, index):\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, PRIM_VOID)\n\n    def _emit_bytecode_PrimitiveType(self, tp, index):\n        prim_index = PRIMITIVE_TO_INDEX[tp.name]\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, prim_index)\n\n    def _emit_bytecode_UnknownIntegerType(self, tp, index):\n        s = ('_cffi_prim_int(sizeof(%s), (\\n'\n             '           ((%s)-1) | 0 /* check that %s is an integer type */\\n'\n             '         ) <= 0)' % (tp.name, tp.name, tp.name))\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, s)\n\n    def _emit_bytecode_UnknownFloatType(self, tp, index):\n        s = ('_cffi_prim_float(sizeof(%s) *\\n'\n             '           (((%s)1) / 2) * 2 /* integer => 0, float => 1 */\\n'\n             '         )' % (tp.name, tp.name))\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, s)\n\n    def _emit_bytecode_RawFunctionType(self, tp, index):\n        self.cffi_types[index] = CffiOp(OP_FUNCTION, self._typesdict[tp.result])\n        index += 1\n        for tp1 in tp.args:\n            realindex = self._typesdict[tp1]\n            if index != realindex:\n                if isinstance(tp1, model.PrimitiveType):\n                    self._emit_bytecode_PrimitiveType(tp1, index)\n                else:\n                    self.cffi_types[index] = CffiOp(OP_NOOP, realindex)\n            index += 1\n        flags = int(tp.ellipsis)\n        if tp.abi is not None:\n            if tp.abi == '__stdcall':\n                flags |= 2\n            else:\n                raise NotImplementedError(\"abi=%r\" % (tp.abi,))\n        self.cffi_types[index] = CffiOp(OP_FUNCTION_END, flags)\n\n    def _emit_bytecode_PointerType(self, tp, index):\n        self.cffi_types[index] = CffiOp(OP_POINTER, self._typesdict[tp.totype])\n\n    _emit_bytecode_ConstPointerType = _emit_bytecode_PointerType\n    _emit_bytecode_NamedPointerType = _emit_bytecode_PointerType\n\n    def _emit_bytecode_FunctionPtrType(self, tp, index):\n        raw = tp.as_raw_function()\n        self.cffi_types[index] = CffiOp(OP_POINTER, self._typesdict[raw])\n\n    def _emit_bytecode_ArrayType(self, tp, index):\n        item_index = self._typesdict[tp.item]\n        if tp.length is None:\n            self.cffi_types[index] = CffiOp(OP_OPEN_ARRAY, item_index)\n        elif tp.length == '...':\n            raise VerificationError(\n                \"type %s badly placed: the '...' array length can only be \"\n                \"used on global arrays or on fields of structures\" % (\n                    str(tp).replace('/*...*/', '...'),))\n        else:\n            assert self.cffi_types[index + 1] == 'LEN'\n            self.cffi_types[index] = CffiOp(OP_ARRAY, item_index)\n            self.cffi_types[index + 1] = CffiOp(None, str(tp.length))\n\n    def _emit_bytecode_StructType(self, tp, index):\n        struct_index = self._struct_unions[tp]\n        self.cffi_types[index] = CffiOp(OP_STRUCT_UNION, struct_index)\n    _emit_bytecode_UnionType = _emit_bytecode_StructType\n\n    def _emit_bytecode_EnumType(self, tp, index):\n        enum_index = self._enums[tp]\n        self.cffi_types[index] = CffiOp(OP_ENUM, enum_index)\n\n\nif sys.version_info >= (3,):\n    NativeIO = io.StringIO\nelse:\n    class NativeIO(io.BytesIO):\n        def write(self, s):\n            if isinstance(s, unicode):\n                s = s.encode('ascii')\n            super(NativeIO, self).write(s)\n\ndef _make_c_or_py_source(ffi, module_name, preamble, target_file, verbose):\n    if verbose:\n        print(\"generating %s\" % (target_file,))\n    recompiler = Recompiler(ffi, module_name,\n                            target_is_python=(preamble is None))\n    recompiler.collect_type_table()\n    recompiler.collect_step_tables()\n    f = NativeIO()\n    recompiler.write_source_to_f(f, preamble)\n    output = f.getvalue()\n    try:\n        with open(target_file, 'r') as f1:\n            if f1.read(len(output) + 1) != output:\n                raise IOError\n        if verbose:\n            print(\"(already up-to-date)\")\n        return False     # already up-to-date\n    except IOError:\n        tmp_file = '%s.~%d' % (target_file, os.getpid())\n        with open(tmp_file, 'w') as f1:\n            f1.write(output)\n        try:\n            os.rename(tmp_file, target_file)\n        except OSError:\n            os.unlink(target_file)\n            os.rename(tmp_file, target_file)\n        return True\n\ndef make_c_source(ffi, module_name, preamble, target_c_file, verbose=False):\n    assert preamble is not None\n    return _make_c_or_py_source(ffi, module_name, preamble, target_c_file,\n                                verbose)\n\ndef make_py_source(ffi, module_name, target_py_file, verbose=False):\n    return _make_c_or_py_source(ffi, module_name, None, target_py_file,\n                                verbose)\n\ndef _modname_to_file(outputdir, modname, extension):\n    parts = modname.split('.')\n    try:\n        os.makedirs(os.path.join(outputdir, *parts[:-1]))\n    except OSError:\n        pass\n    parts[-1] += extension\n    return os.path.join(outputdir, *parts), parts\n\n\n# Aaargh.  Distutils is not tested at all for the purpose of compiling\n# DLLs that are not extension modules.  Here are some hacks to work\n# around that, in the _patch_for_*() functions...\n\ndef _patch_meth(patchlist, cls, name, new_meth):\n    old = getattr(cls, name)\n    patchlist.append((cls, name, old))\n    setattr(cls, name, new_meth)\n    return old\n\ndef _unpatch_meths(patchlist):\n    for cls, name, old_meth in reversed(patchlist):\n        setattr(cls, name, old_meth)\n\ndef _patch_for_embedding(patchlist):\n    if sys.platform == 'win32':\n        # we must not remove the manifest when building for embedding!\n        from cffi._shimmed_dist_utils import MSVCCompiler\n        _patch_meth(patchlist, MSVCCompiler, '_remove_visual_c_ref',\n                    lambda self, manifest_file: manifest_file)\n\n    if sys.platform == 'darwin':\n        # we must not make a '-bundle', but a '-dynamiclib' instead\n        from cffi._shimmed_dist_utils import CCompiler\n        def my_link_shared_object(self, *args, **kwds):\n            if '-bundle' in self.linker_so:\n                self.linker_so = list(self.linker_so)\n                i = self.linker_so.index('-bundle')\n                self.linker_so[i] = '-dynamiclib'\n            return old_link_shared_object(self, *args, **kwds)\n        old_link_shared_object = _patch_meth(patchlist, CCompiler,\n                                             'link_shared_object',\n                                             my_link_shared_object)\n\ndef _patch_for_target(patchlist, target):\n    from cffi._shimmed_dist_utils import build_ext\n    # if 'target' is different from '*', we need to patch some internal\n    # method to just return this 'target' value, instead of having it\n    # built from module_name\n    if target.endswith('.*'):\n        target = target[:-2]\n        if sys.platform == 'win32':\n            target += '.dll'\n        elif sys.platform == 'darwin':\n            target += '.dylib'\n        else:\n            target += '.so'\n    _patch_meth(patchlist, build_ext, 'get_ext_filename',\n                lambda self, ext_name: target)\n\n\ndef recompile(ffi, module_name, preamble, tmpdir='.', call_c_compiler=True,\n              c_file=None, source_extension='.c', extradir=None,\n              compiler_verbose=1, target=None, debug=None, **kwds):\n    if not isinstance(module_name, str):\n        module_name = module_name.encode('ascii')\n    if ffi._windows_unicode:\n        ffi._apply_windows_unicode(kwds)\n    if preamble is not None:\n        embedding = (ffi._embedding is not None)\n        if embedding:\n            ffi._apply_embedding_fix(kwds)\n        if c_file is None:\n            c_file, parts = _modname_to_file(tmpdir, module_name,\n                                             source_extension)\n            if extradir:\n                parts = [extradir] + parts\n            ext_c_file = os.path.join(*parts)\n        else:\n            ext_c_file = c_file\n        #\n        if target is None:\n            if embedding:\n                target = '%s.*' % module_name\n            else:\n                target = '*'\n        #\n        ext = ffiplatform.get_extension(ext_c_file, module_name, **kwds)\n        updated = make_c_source(ffi, module_name, preamble, c_file,\n                                verbose=compiler_verbose)\n        if call_c_compiler:\n            patchlist = []\n            cwd = os.getcwd()\n            try:\n                if embedding:\n                    _patch_for_embedding(patchlist)\n                if target != '*':\n                    _patch_for_target(patchlist, target)\n                if compiler_verbose:\n                    if tmpdir == '.':\n                        msg = 'the current directory is'\n                    else:\n                        msg = 'setting the current directory to'\n                    print('%s %r' % (msg, os.path.abspath(tmpdir)))\n                os.chdir(tmpdir)\n                outputfilename = ffiplatform.compile('.', ext,\n                                                     compiler_verbose, debug)\n            finally:\n                os.chdir(cwd)\n                _unpatch_meths(patchlist)\n            return outputfilename\n        else:\n            return ext, updated\n    else:\n        if c_file is None:\n            c_file, _ = _modname_to_file(tmpdir, module_name, '.py')\n        updated = make_py_source(ffi, module_name, c_file,\n                                 verbose=compiler_verbose)\n        if call_c_compiler:\n            return c_file\n        else:\n            return None, updated\n\n"}