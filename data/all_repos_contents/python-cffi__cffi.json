{"setup.py": "import sys, os, platform\nimport subprocess\nimport errno\n\n# the setuptools distutils shim should make distutils available, but this will definitely do\n# it, since setuptools is now required at build-time\nimport setuptools\n\n\nsources = ['src/c/_cffi_backend.c']\nlibraries = ['ffi']\ninclude_dirs = ['/usr/include/ffi',\n                '/usr/include/libffi']    # may be changed by pkg-config\ndefine_macros = [('FFI_BUILDING', '1')]   # for linking with libffi static library\nlibrary_dirs = []\nextra_compile_args = []\nextra_link_args = []\n\n\ndef _ask_pkg_config(resultlist, option, result_prefix='', sysroot=False):\n    pkg_config = os.environ.get('PKG_CONFIG','pkg-config')\n    try:\n        p = subprocess.Popen([pkg_config, option, 'libffi'],\n                             stdout=subprocess.PIPE)\n    except OSError as e:\n        if e.errno not in [errno.ENOENT, errno.EACCES]:\n            raise\n    else:\n        t = p.stdout.read().decode().strip()\n        p.stdout.close()\n        if p.wait() == 0:\n            res = t.split()\n            # '-I/usr/...' -> '/usr/...'\n            for x in res:\n                assert x.startswith(result_prefix)\n            res = [x[len(result_prefix):] for x in res]\n            #print 'PKG_CONFIG:', option, res\n            #\n            sysroot = sysroot and os.environ.get('PKG_CONFIG_SYSROOT_DIR', '')\n            if sysroot:\n                # old versions of pkg-config don't support this env var,\n                # so here we emulate its effect if needed\n                res = [path if path.startswith(sysroot)\n                            else sysroot + path\n                         for path in res]\n            #\n            resultlist[:] = res\n\nno_compiler_found = False\ndef no_working_compiler_found():\n    sys.stderr.write(\"\"\"\n    No working compiler found, or bogus compiler options passed to\n    the compiler from Python's standard \"distutils\" module.  See\n    the error messages above.  Likely, the problem is not related\n    to CFFI but generic to the setup.py of any Python package that\n    tries to compile C code.  (Hints: on OS/X 10.8, for errors about\n    -mno-fused-madd see http://stackoverflow.com/questions/22313407/\n    Otherwise, see https://wiki.python.org/moin/CompLangPython or\n    the IRC channel #python on irc.libera.chat.)\n\n    Trying to continue anyway.  If you are trying to install CFFI from\n    a build done in a different context, you can ignore this warning.\n    \\n\"\"\")\n    global no_compiler_found\n    no_compiler_found = True\n\ndef get_config():\n    from distutils.core import Distribution\n    from distutils.sysconfig import get_config_vars\n    get_config_vars()      # workaround for a bug of distutils, e.g. on OS/X\n    config = Distribution().get_command_obj('config')\n    return config\n\ndef ask_supports_thread():\n    config = get_config()\n    ok = (sys.platform != 'win32' and\n          config.try_compile('__thread int some_threadlocal_variable_42;'))\n    if ok:\n        define_macros.append(('USE__THREAD', None))\n    else:\n        ok1 = config.try_compile('int some_regular_variable_42;')\n        if not ok1:\n            no_working_compiler_found()\n        else:\n            sys.stderr.write(\"Note: will not use '__thread' in the C code\\n\")\n            _safe_to_ignore()\n\ndef ask_supports_sync_synchronize():\n    if sys.platform == 'win32' or no_compiler_found:\n        return\n    config = get_config()\n    ok = config.try_link('int main(void) { __sync_synchronize(); return 0; }')\n    if ok:\n        define_macros.append(('HAVE_SYNC_SYNCHRONIZE', None))\n    else:\n        sys.stderr.write(\"Note: will not use '__sync_synchronize()'\"\n                         \" in the C code\\n\")\n        _safe_to_ignore()\n\ndef _safe_to_ignore():\n    sys.stderr.write(\"***** The above error message can be safely ignored.\\n\\n\")\n\ndef uses_msvc():\n    config = get_config()\n    return config.try_compile('#ifndef _MSC_VER\\n#error \"not MSVC\"\\n#endif')\n\ndef use_pkg_config():\n    if sys.platform == 'darwin' and os.path.exists('/usr/local/bin/brew'):\n        use_homebrew_for_libffi()\n\n    _ask_pkg_config(include_dirs,       '--cflags-only-I', '-I', sysroot=True)\n    _ask_pkg_config(extra_compile_args, '--cflags-only-other')\n    _ask_pkg_config(library_dirs,       '--libs-only-L', '-L', sysroot=True)\n    _ask_pkg_config(extra_link_args,    '--libs-only-other')\n    _ask_pkg_config(libraries,          '--libs-only-l', '-l')\n\ndef use_homebrew_for_libffi():\n    # We can build by setting:\n    # PKG_CONFIG_PATH = $(brew --prefix libffi)/lib/pkgconfig\n    with os.popen('brew --prefix libffi') as brew_prefix_cmd:\n        prefix = brew_prefix_cmd.read().strip()\n    pkgconfig = os.path.join(prefix, 'lib', 'pkgconfig')\n    os.environ['PKG_CONFIG_PATH'] = (\n        os.environ.get('PKG_CONFIG_PATH', '') + ':' + pkgconfig)\n\nif sys.platform == \"win32\" and uses_msvc():\n    if platform.machine() == \"ARM64\":\n        include_dirs.append(os.path.join(\"src/c/libffi_arm64/include\"))\n        library_dirs.append(os.path.join(\"src/c/libffi_arm64\"))\n    else:\n        COMPILE_LIBFFI = 'src/c/libffi_x86_x64'    # from the CPython distribution\n        assert os.path.isdir(COMPILE_LIBFFI), \"directory not found!\"\n        include_dirs[:] = [COMPILE_LIBFFI]\n        libraries[:] = []\n        _filenames = [filename.lower() for filename in os.listdir(COMPILE_LIBFFI)]\n        _filenames = [filename for filename in _filenames\n                            if filename.endswith('.c')]\n        if sys.maxsize > 2**32:\n            # 64-bit: unlist win32.c, and add instead win64.obj.  If the obj\n            # happens to get outdated at some point in the future, you need to\n            # rebuild it manually from win64.asm.\n            _filenames.remove('win32.c')\n            extra_link_args.append(os.path.join(COMPILE_LIBFFI, 'win64.obj'))\n        sources.extend(os.path.join(COMPILE_LIBFFI, filename)\n                    for filename in _filenames)\nelse:\n    use_pkg_config()\n    ask_supports_thread()\n    ask_supports_sync_synchronize()\n\nif 'darwin' in sys.platform:\n    # priority is given to `pkg_config`, but always fall back on SDK's libffi.\n    extra_compile_args += ['-iwithsysroot/usr/include/ffi']\n\nif 'freebsd' in sys.platform:\n    include_dirs.append('/usr/local/include')\n    library_dirs.append('/usr/local/lib')\n\nforced_extra_objs = os.environ.get('CFFI_FORCE_STATIC', [])\nif forced_extra_objs:\n    forced_extra_objs = forced_extra_objs.split(';')\n\n\nif __name__ == '__main__':\n    from setuptools import setup, Distribution, Extension\n\n    class CFFIDistribution(Distribution):\n        def has_ext_modules(self):\n            # Event if we don't have extension modules (e.g. on PyPy) we want to\n            # claim that we do so that wheels get properly tagged as Python\n            # specific.  (thanks dstufft!)\n            return True\n\n    # On PyPy, cffi is preinstalled and it is not possible, at least for now,\n    # to install a different version.  We work around it by making the setup()\n    # arguments mostly empty in this case.\n    cpython = ('_cffi_backend' not in sys.builtin_module_names)\n\n    install_requires = []\n    if cpython:\n        install_requires.append('pycparser')\n\n    setup(\n        name='cffi',\n        description='Foreign Function Interface for Python calling C code.',\n        long_description=\"\"\"\nCFFI\n====\n\nForeign Function Interface for Python calling C code.\nPlease see the `Documentation <http://cffi.readthedocs.org/>`_.\n\nContact\n-------\n\n`Mailing list <https://groups.google.com/forum/#!forum/python-cffi>`_\n\"\"\",\n        version='1.17.0.dev0',\n        python_requires='>=3.8',\n        packages=['cffi'] if cpython else [],\n        package_dir={\"\": \"src\"},\n        package_data={'cffi': ['_cffi_include.h', 'parse_c_type.h', \n                               '_embedding.h', '_cffi_errors.h']}\n                     if cpython else {},\n        zip_safe=False,\n\n        url='http://cffi.readthedocs.org',\n        author='Armin Rigo, Maciej Fijalkowski',\n        author_email='python-cffi@googlegroups.com',\n\n        license='MIT',\n\n        distclass=CFFIDistribution,\n        ext_modules=[Extension(\n            name='_cffi_backend',\n            include_dirs=include_dirs,\n            sources=sources,\n            libraries=libraries,\n            define_macros=define_macros,\n            library_dirs=library_dirs,\n            extra_compile_args=extra_compile_args,\n            extra_link_args=extra_link_args,\n            extra_objects=forced_extra_objs,\n        )] if cpython else [],\n\n        install_requires=install_requires,\n\n        entry_points = {\n            \"distutils.setup_keywords\": [\n                \"cffi_modules = cffi.setuptools_ext:cffi_modules\",\n            ],\n        },\n\n        classifiers=[\n            'Programming Language :: Python',\n            'Programming Language :: Python :: 3',\n            'Programming Language :: Python :: 3.8',\n            'Programming Language :: Python :: 3.9',\n            'Programming Language :: Python :: 3.10',\n            'Programming Language :: Python :: 3.11',\n            'Programming Language :: Python :: 3.12',\n            'Programming Language :: Python :: 3.13',\n            'Programming Language :: Python :: Implementation :: CPython',\n            'Programming Language :: Python :: Implementation :: PyPy',\n            'License :: OSI Approved :: MIT License',\n        ],\n    )\n", "setup_base.py": "import sys, os\n\n\nfrom setup import include_dirs, sources, libraries, define_macros\nfrom setup import library_dirs, extra_compile_args, extra_link_args\n\n\nif __name__ == '__main__':\n    from distutils.core import setup\n    from distutils.extension import Extension\n\n    standard = '__pypy__' not in sys.builtin_module_names\n    setup(packages=['cffi'],\n          requires=['pycparser'],\n          ext_modules=[Extension(name = '_cffi_backend',\n                                 include_dirs=include_dirs,\n                                 sources=sources,\n                                 libraries=libraries,\n                                 define_macros=define_macros,\n                                 library_dirs=library_dirs,\n                                 extra_compile_args=extra_compile_args,\n                                 extra_link_args=extra_link_args,\n                                 )] * standard)\n", "tools/version.py": "#!/usr/bin/env python\n\"\"\"A simple script to update the version embedded in the source.\"\"\"\n\nimport argparse\nimport pathlib\nimport re\n\nfrom packaging.version import Version\n\n\ndef main() -> None:\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument('version', type=Version, help='version number to embed in source files')\n    args = parser.parse_args()\n    version: Version = args.version\n\n    major_minor_version = f'{version.major}.{version.minor}'\n    version_info = ', '.join(map(repr, get_version_info(version)))\n\n    updates: list[tuple[str, re.Pattern, str | Version]] = [\n        ('doc/source/conf.py', re.compile(r\"^(version = ')[^']*(')$\", flags=re.MULTILINE), major_minor_version),\n        ('doc/source/conf.py', re.compile(r\"^(release = ')[^']*(')$\", flags=re.MULTILINE), version),\n        ('setup.py', re.compile(r\"^( +version=')[^']*(',)$\", flags=re.MULTILINE), version),\n        ('src/c/_cffi_backend.c', re.compile(r'^(#define CFFI_VERSION +\")[^\"]*(\")$', flags=re.MULTILINE), version),\n        ('src/c/test_c.py', re.compile(r'^(assert __version__ == \")[^\"]*(\", .*)$', flags=re.MULTILINE), version),\n        ('src/cffi/__init__.py', re.compile(r'^(__version__ = \")[^\"]*(\")$', flags=re.MULTILINE), version),\n        ('src/cffi/__init__.py', re.compile(r'^(__version_info__ = \\()[^)]*(\\))$', flags=re.MULTILINE), version_info),\n        ('src/cffi/_embedding.h', re.compile(r'^( +\"\\\\ncompiled with cffi version: )[^\"]*(\")$', flags=re.MULTILINE), version),\n    ]\n\n    repo_root = pathlib.Path(__file__).parent.parent\n\n    for relative_path, pattern, replacement in updates:\n        path = repo_root / relative_path\n        original_content = path.read_text()\n\n        if not pattern.search(original_content):\n            raise RuntimeError(f'{relative_path}: no match found for pattern: {pattern.pattern}')\n\n        updated_content = pattern.sub(rf'\\g<1>{replacement}\\g<2>', original_content)\n\n        if updated_content == original_content:\n            print(f'{relative_path}: unchanged')\n        else:\n            path.write_text(updated_content)\n            print(f'{relative_path}: updated')\n\n\ndef get_version_info(version: Version) -> tuple:\n    \"\"\"Return a tuple representing the given version.\"\"\"\n    version_info = list(version.release)\n\n    if version.pre is not None:\n        version_info.append(''.join(map(str, version.pre)))\n\n    if version.post is not None:\n        version_info.append(f'post{version.post}')\n\n    if version.dev is not None:\n        version_info.append(f'dev{version.dev}')\n\n    if version.local is not None:\n        version_info.append(f'+{version.local}')\n\n    return tuple(version_info)\n\n\nif __name__ == '__main__':\n    main()\n", "demo/_curses_build.py": "import sys\nif sys.platform == 'win32':\n    #This module does not exist in windows\n    raise ImportError('No module named _curses')\n\nfrom cffi import FFI\n\nffi = FFI()\n\nffi.cdef(\"\"\"\ntypedef ... WINDOW;\ntypedef ... SCREEN;\ntypedef unsigned long... mmask_t;\ntypedef unsigned char bool;\ntypedef unsigned long... chtype;\ntypedef chtype attr_t;\n\ntypedef struct\n{\n    short id;           /* ID to distinguish multiple devices */\n    int x, y, z;        /* event coordinates (character-cell) */\n    mmask_t bstate;     /* button state bits */\n}\nMEVENT;\n\nstatic const int ERR, OK;\nstatic const int TRUE, FALSE;\nstatic const int KEY_MIN, KEY_MAX;\n\nstatic const int COLOR_BLACK;\nstatic const int COLOR_RED;\nstatic const int COLOR_GREEN;\nstatic const int COLOR_YELLOW;\nstatic const int COLOR_BLUE;\nstatic const int COLOR_MAGENTA;\nstatic const int COLOR_CYAN;\nstatic const int COLOR_WHITE;\n\nstatic const chtype A_ATTRIBUTES;\nstatic const chtype A_NORMAL;\nstatic const chtype A_STANDOUT;\nstatic const chtype A_UNDERLINE;\nstatic const chtype A_REVERSE;\nstatic const chtype A_BLINK;\nstatic const chtype A_DIM;\nstatic const chtype A_BOLD;\nstatic const chtype A_ALTCHARSET;\nstatic const chtype A_INVIS;\nstatic const chtype A_PROTECT;\nstatic const chtype A_CHARTEXT;\nstatic const chtype A_COLOR;\n\nstatic const int BUTTON1_RELEASED;\nstatic const int BUTTON1_PRESSED;\nstatic const int BUTTON1_CLICKED;\nstatic const int BUTTON1_DOUBLE_CLICKED;\nstatic const int BUTTON1_TRIPLE_CLICKED;\nstatic const int BUTTON2_RELEASED;\nstatic const int BUTTON2_PRESSED;\nstatic const int BUTTON2_CLICKED;\nstatic const int BUTTON2_DOUBLE_CLICKED;\nstatic const int BUTTON2_TRIPLE_CLICKED;\nstatic const int BUTTON3_RELEASED;\nstatic const int BUTTON3_PRESSED;\nstatic const int BUTTON3_CLICKED;\nstatic const int BUTTON3_DOUBLE_CLICKED;\nstatic const int BUTTON3_TRIPLE_CLICKED;\nstatic const int BUTTON4_RELEASED;\nstatic const int BUTTON4_PRESSED;\nstatic const int BUTTON4_CLICKED;\nstatic const int BUTTON4_DOUBLE_CLICKED;\nstatic const int BUTTON4_TRIPLE_CLICKED;\nstatic const int BUTTON_SHIFT;\nstatic const int BUTTON_CTRL;\nstatic const int BUTTON_ALT;\nstatic const int ALL_MOUSE_EVENTS;\nstatic const int REPORT_MOUSE_POSITION;\n\nint setupterm(char *, int, int *);\n\nWINDOW *stdscr;\nint COLORS;\nint COLOR_PAIRS;\nint COLS;\nint LINES;\n\nint baudrate(void);\nint beep(void);\nint box(WINDOW *, chtype, chtype);\nbool can_change_color(void);\nint cbreak(void);\nint clearok(WINDOW *, bool);\nint color_content(short, short*, short*, short*);\nint copywin(const WINDOW*, WINDOW*, int, int, int, int, int, int, int);\nint curs_set(int);\nint def_prog_mode(void);\nint def_shell_mode(void);\nint delay_output(int);\nint delwin(WINDOW *);\nWINDOW * derwin(WINDOW *, int, int, int, int);\nint doupdate(void);\nint echo(void);\nint endwin(void);\nchar erasechar(void);\nvoid filter(void);\nint flash(void);\nint flushinp(void);\nchtype getbkgd(WINDOW *);\nWINDOW * getwin(FILE *);\nint halfdelay(int);\nbool has_colors(void);\nbool has_ic(void);\nbool has_il(void);\nvoid idcok(WINDOW *, bool);\nint idlok(WINDOW *, bool);\nvoid immedok(WINDOW *, bool);\nWINDOW * initscr(void);\nint init_color(short, short, short, short);\nint init_pair(short, short, short);\nint intrflush(WINDOW *, bool);\nbool isendwin(void);\nbool is_linetouched(WINDOW *, int);\nbool is_wintouched(WINDOW *);\nconst char * keyname(int);\nint keypad(WINDOW *, bool);\nchar killchar(void);\nint leaveok(WINDOW *, bool);\nchar * longname(void);\nint meta(WINDOW *, bool);\nint mvderwin(WINDOW *, int, int);\nint mvwaddch(WINDOW *, int, int, const chtype);\nint mvwaddnstr(WINDOW *, int, int, const char *, int);\nint mvwaddstr(WINDOW *, int, int, const char *);\nint mvwchgat(WINDOW *, int, int, int, attr_t, short, const void *);\nint mvwdelch(WINDOW *, int, int);\nint mvwgetch(WINDOW *, int, int);\nint mvwgetnstr(WINDOW *, int, int, char *, int);\nint mvwin(WINDOW *, int, int);\nchtype mvwinch(WINDOW *, int, int);\nint mvwinnstr(WINDOW *, int, int, char *, int);\nint mvwinsch(WINDOW *, int, int, chtype);\nint mvwinsnstr(WINDOW *, int, int, const char *, int);\nint mvwinsstr(WINDOW *, int, int, const char *);\nint napms(int);\nWINDOW * newpad(int, int);\nWINDOW * newwin(int, int, int, int);\nint nl(void);\nint nocbreak(void);\nint nodelay(WINDOW *, bool);\nint noecho(void);\nint nonl(void);\nvoid noqiflush(void);\nint noraw(void);\nint notimeout(WINDOW *, bool);\nint overlay(const WINDOW*, WINDOW *);\nint overwrite(const WINDOW*, WINDOW *);\nint pair_content(short, short*, short*);\nint pechochar(WINDOW *, const chtype);\nint pnoutrefresh(WINDOW*, int, int, int, int, int, int);\nint prefresh(WINDOW *, int, int, int, int, int, int);\nint putwin(WINDOW *, FILE *);\nvoid qiflush(void);\nint raw(void);\nint redrawwin(WINDOW *);\nint resetty(void);\nint reset_prog_mode(void);\nint reset_shell_mode(void);\nint savetty(void);\nint scroll(WINDOW *);\nint scrollok(WINDOW *, bool);\nint start_color(void);\nWINDOW * subpad(WINDOW *, int, int, int, int);\nWINDOW * subwin(WINDOW *, int, int, int, int);\nint syncok(WINDOW *, bool);\nchtype termattrs(void);\nchar * termname(void);\nint touchline(WINDOW *, int, int);\nint touchwin(WINDOW *);\nint typeahead(int);\nint ungetch(int);\nint untouchwin(WINDOW *);\nvoid use_env(bool);\nint waddch(WINDOW *, const chtype);\nint waddnstr(WINDOW *, const char *, int);\nint waddstr(WINDOW *, const char *);\nint wattron(WINDOW *, int);\nint wattroff(WINDOW *, int);\nint wattrset(WINDOW *, int);\nint wbkgd(WINDOW *, chtype);\nvoid wbkgdset(WINDOW *, chtype);\nint wborder(WINDOW *, chtype, chtype, chtype, chtype,\n            chtype, chtype, chtype, chtype);\nint wchgat(WINDOW *, int, attr_t, short, const void *);\nint wclear(WINDOW *);\nint wclrtobot(WINDOW *);\nint wclrtoeol(WINDOW *);\nvoid wcursyncup(WINDOW *);\nint wdelch(WINDOW *);\nint wdeleteln(WINDOW *);\nint wechochar(WINDOW *, const chtype);\nint werase(WINDOW *);\nint wgetch(WINDOW *);\nint wgetnstr(WINDOW *, char *, int);\nint whline(WINDOW *, chtype, int);\nchtype winch(WINDOW *);\nint winnstr(WINDOW *, char *, int);\nint winsch(WINDOW *, chtype);\nint winsdelln(WINDOW *, int);\nint winsertln(WINDOW *);\nint winsnstr(WINDOW *, const char *, int);\nint winsstr(WINDOW *, const char *);\nint wmove(WINDOW *, int, int);\nint wresize(WINDOW *, int, int);\nint wnoutrefresh(WINDOW *);\nint wredrawln(WINDOW *, int, int);\nint wrefresh(WINDOW *);\nint wscrl(WINDOW *, int);\nint wsetscrreg(WINDOW *, int, int);\nint wstandout(WINDOW *);\nint wstandend(WINDOW *);\nvoid wsyncdown(WINDOW *);\nvoid wsyncup(WINDOW *);\nvoid wtimeout(WINDOW *, int);\nint wtouchln(WINDOW *, int, int, int);\nint wvline(WINDOW *, chtype, int);\nint tigetflag(char *);\nint tigetnum(char *);\nchar * tigetstr(char *);\nint putp(const char *);\nchar * tparm(const char *, ...);\nint getattrs(const WINDOW *);\nint getcurx(const WINDOW *);\nint getcury(const WINDOW *);\nint getbegx(const WINDOW *);\nint getbegy(const WINDOW *);\nint getmaxx(const WINDOW *);\nint getmaxy(const WINDOW *);\nint getparx(const WINDOW *);\nint getpary(const WINDOW *);\n\nint getmouse(MEVENT *);\nint ungetmouse(MEVENT *);\nmmask_t mousemask(mmask_t, mmask_t *);\nbool wenclose(const WINDOW *, int, int);\nint mouseinterval(int);\n\nvoid setsyx(int y, int x);\nconst char *unctrl(chtype);\nint use_default_colors(void);\n\nint has_key(int);\nbool is_term_resized(int, int);\n\n#define _m_STRICT_SYSV_CURSES ...\n#define _m_NCURSES_MOUSE_VERSION ...\n#define _m_NetBSD ...\nint _m_ispad(WINDOW *);\n\nchtype acs_map[];\n\n// For _curses_panel:\n\ntypedef ... PANEL;\n\nWINDOW *panel_window(const PANEL *);\nvoid update_panels(void);\nint hide_panel(PANEL *);\nint show_panel(PANEL *);\nint del_panel(PANEL *);\nint top_panel(PANEL *);\nint bottom_panel(PANEL *);\nPANEL *new_panel(WINDOW *);\nPANEL *panel_above(const PANEL *);\nPANEL *panel_below(const PANEL *);\nint set_panel_userptr(PANEL *, void *);\nconst void *panel_userptr(const PANEL *);\nint move_panel(PANEL *, int, int);\nint replace_panel(PANEL *,WINDOW *);\nint panel_hidden(const PANEL *);\n\nvoid _m_getsyx(int *yx);\n\"\"\")\n\n\nffi.set_source(\"_curses_cffi\", \"\"\"\n#ifdef __APPLE__\n/* the following define is necessary for OS X 10.6+; without it, the\n   Apple-supplied ncurses.h sets NCURSES_OPAQUE to 1, and then Python\n   can't get at the WINDOW flags field. */\n#define NCURSES_OPAQUE 0\n#endif\n\n#include <ncurses.h>\n#include <panel.h>\n#include <term.h>\n\n#if defined STRICT_SYSV_CURSES\n#define _m_STRICT_SYSV_CURSES TRUE\n#else\n#define _m_STRICT_SYSV_CURSES FALSE\n#endif\n\n#if defined NCURSES_MOUSE_VERSION\n#define _m_NCURSES_MOUSE_VERSION TRUE\n#else\n#define _m_NCURSES_MOUSE_VERSION FALSE\n#endif\n\n#if defined __NetBSD__\n#define _m_NetBSD TRUE\n#else\n#define _m_NetBSD FALSE\n#endif\n\nint _m_ispad(WINDOW *win) {\n    // <curses.h> may not have _flags (and possibly _ISPAD),\n    // but for now let's assume that <ncurses.h> always has it\n    return (win->_flags & _ISPAD);\n}\n\nvoid _m_getsyx(int *yx) {\n    getsyx(yx[0], yx[1]);\n}\n\"\"\", libraries=['ncurses', 'panel'])\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/setup_manual.py": "from distutils.core import setup\nfrom distutils.extension import Extension\nsetup(name='manual',\n      ext_modules=[Extension(name='manual',\n                             sources=['manual.c'])])\n", "demo/pwuid_build.py": "from cffi import FFI\nffi = FFI()\nffi.cdef(\"\"\"     // some declarations from the man page\n    struct passwd {\n        char *pw_name;\n        ...; \n    };\n    struct passwd *getpwuid(int uid);\n\"\"\")\n\nffi.set_source('_pwuid_cffi', \"\"\"   // passed to the real C compiler\n#include <sys/types.h>\n#include <pwd.h>\n\"\"\")\n\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/xclient.py": "import sys, os\n\n# run xclient_build first, then make sure the shared object is on sys.path\nfrom _xclient_cffi import ffi, lib\n\n\n# ffi \"knows\" about the declared variables and functions from the\n#     cdef parts of the module xclient_build created,\n# lib \"knows\" how to call the functions from the set_source parts\n#     of the module.\n\n\nclass XError(Exception):\n    pass\n\ndef main():\n    display = lib.XOpenDisplay(ffi.NULL)\n    if display == ffi.NULL:\n        raise XError(\"cannot open display\")\n    w = lib.XCreateSimpleWindow(display, lib.DefaultRootWindow(display),\n                            10, 10, 500, 350, 0, 0, 0)\n    lib.XMapRaised(display, w)\n    event = ffi.new(\"XEvent *\")\n    lib.XNextEvent(display, event)\n\nif __name__ == '__main__':\n    main()\n", "demo/bsdopendirtype_build.py": "from cffi import FFI\n\nffibuilder = FFI()\nffibuilder.cdef(\"\"\"\n    typedef ... DIR;\n    struct dirent {\n        unsigned char d_type;   /* type of file */\n        char d_name[];          /* filename */\n        ...;\n    };\n    DIR *opendir(const char *name);\n    int closedir(DIR *dirp);\n    struct dirent *readdir(DIR *dirp);\n    static const int DT_BLK, DT_CHR, DT_DIR, DT_FIFO, DT_LNK, DT_REG, DT_SOCK;\n\"\"\")\n\nffibuilder.set_source(\"_bsdopendirtype\", \"\"\"\n    #include <sys/types.h>\n    #include <dirent.h>\n\"\"\")\n\nif __name__ == '__main__':\n    ffibuilder.compile(verbose=True)\n", "demo/readdir2_build.py": "from cffi import FFI\n\nffi = FFI()\nffi.cdef(\"\"\"\n\n    typedef ... DIR;\n\n    struct dirent {\n        unsigned char  d_type;      /* type of file; not supported\n                                       by all file system types */\n        char           d_name[...]; /* filename */\n        ...;\n    };\n\n    int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);\n    int openat(int dirfd, const char *pathname, int flags);\n    DIR *fdopendir(int fd);\n    int closedir(DIR *dirp);\n\n    static const int DT_DIR;\n\n\"\"\")\nffi.set_source(\"_readdir2_cffi\", \"\"\"\n#ifndef _ATFILE_SOURCE\n#  define _ATFILE_SOURCE\n#endif\n#ifndef _BSD_SOURCE\n#  define _BSD_SOURCE\n#endif\n#include <fcntl.h>\n#include <sys/types.h>\n#include <dirent.h>\n\"\"\")\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/recopendirtype.py": "from _recopendirtype import ffi, lib\n\n\ndef _posix_error():\n    raise OSError(ffi.errno, os.strerror(ffi.errno))\n\n_dtype_to_smode = {\n    lib.DT_BLK:  0o060000,\n    lib.DT_CHR:  0o020000,\n    lib.DT_DIR:  0o040000,\n    lib.DT_FIFO: 0o010000,\n    lib.DT_LNK:  0o120000,\n    lib.DT_REG:  0o100000,\n    lib.DT_SOCK: 0o140000,\n}\n\ndef opendir(dir):\n    if len(dir) == 0:\n        dir = b'.'\n    dirname = dir\n    if not dirname.endswith(b'/'):\n        dirname += b'/'\n    dirp = lib.opendir(dir)\n    if dirp == ffi.NULL:\n        raise _posix_error()\n    dirent = ffi.new(\"struct dirent *\")\n    result = ffi.new(\"struct dirent **\")\n    try:\n        while True:\n            ffi.errno = 0\n            err = lib.readdir_r(dirp, dirent, result)\n            if err:       # really got an error\n                raise OSError(err, os.strerror(err))\n            if result[0] == ffi.NULL:\n                return    # \n            name = ffi.string(dirent.d_name)\n            if name == b'.' or name == b'..':\n                continue\n            name = dirname + name\n            try:\n                smode = _dtype_to_smode[dirent.d_type]\n            except KeyError:\n                smode = os.lstat(name).st_mode\n            yield name, smode\n    finally:\n        lib.closedir(dirp)\n\nif __name__ == '__main__':\n    for name, smode in opendir(b'/tmp'):\n        print(hex(smode), name)\n", "demo/cffi-cocoa.py": "# Based on http://cocoawithlove.com/2010/09/minimalist-cocoa-programming.html\n# by Juraj Sukop.  This demo was eventually expanded into a more complete\n# Cocoa library available at https://bitbucket.org/sukop/nspython .\n\nfrom cffi import FFI\n\nffi = FFI()\nffi.cdef('''\n    \n    typedef signed char BOOL;\n    \n    typedef long NSInteger;\n    typedef unsigned long NSUInteger;\n    typedef NSInteger NSApplicationActivationPolicy;\n    typedef NSUInteger NSBackingStoreType;\n    typedef NSUInteger NSStringEncoding;\n    \n    typedef double CGFloat;\n    struct CGPoint {\n        CGFloat x;\n        CGFloat y;\n    };\n    typedef struct CGPoint CGPoint;\n    struct CGSize {\n        CGFloat width;\n        CGFloat height;\n    };\n    typedef struct CGSize CGSize;\n    struct CGRect {\n        CGPoint origin;\n        CGSize size;\n    };\n    typedef struct CGRect CGRect;\n    \n    typedef CGPoint NSPoint;\n    typedef CGSize NSSize;\n    typedef CGRect NSRect;\n    \n    typedef struct objc_class *Class;\n    typedef struct objc_object {\n        Class isa;\n    } *id;\n    typedef struct objc_selector *SEL;\n\n    SEL sel_registerName(const char *str);\n    id objc_getClass(const char *name);\n    id objc_msgSend(id theReceiver, SEL theSelector, ...);\n    \n''')\n\nobjc = ffi.dlopen('objc')\nappkit = ffi.dlopen('AppKit')\n\nnil = ffi.NULL\nYES = ffi.cast('BOOL', 1)\nNO = ffi.cast('BOOL', 0)\n\nNSASCIIStringEncoding = ffi.cast('NSStringEncoding', 1)\nNSApplicationActivationPolicyRegular = ffi.cast('NSApplicationActivationPolicy', 0)\nNSTitledWindowMask = ffi.cast('NSUInteger', 1)\nNSBackingStoreBuffered = ffi.cast('NSBackingStoreType', 2)\n\nNSMakePoint = lambda x, y: ffi.new('NSPoint *', (x, y))[0]\nNSMakeRect = lambda x, y, w, h: ffi.new('NSRect *', ((x, y), (w, h)))[0]\n\nget, send, sel = objc.objc_getClass, objc.objc_msgSend, objc.sel_registerName\nat = lambda s: send(\n    get('NSString'),\n    sel('stringWithCString:encoding:'),\n    ffi.new('char[]', s), NSASCIIStringEncoding)\n\nsend(get('NSAutoreleasePool'), sel('new'))\napp = send(get('NSApplication'), sel('sharedApplication'))\nsend(app, sel('setActivationPolicy:'), NSApplicationActivationPolicyRegular)\n\nmenubar = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappMenuItem = send(send(get('NSMenuItem'), sel('new')), sel('autorelease'))\nsend(menubar, sel('addItem:'), appMenuItem)\nsend(app, sel('setMainMenu:'), menubar)\n\nappMenu = send(send(get('NSMenu'), sel('new')), sel('autorelease'))\nappName = send(send(get('NSProcessInfo'), sel('processInfo')), sel('processName'))\nquitTitle = send(at('Quit '), sel('stringByAppendingString:'), appName)\nquitMenuItem = send(send(send(\n            get('NSMenuItem'), sel('alloc')),\n        sel('initWithTitle:action:keyEquivalent:'),\n        quitTitle, sel('terminate:'), at('q')),\n    sel('autorelease'))\nsend(appMenu, sel('addItem:'), quitMenuItem)\nsend(appMenuItem, sel('setSubmenu:'), appMenu)\n\nwindow = send(send(send(\n            get('NSWindow'), sel('alloc')),\n        sel('initWithContentRect:styleMask:backing:defer:'),\n        NSMakeRect(0, 0, 200, 200), NSTitledWindowMask, NSBackingStoreBuffered, NO),\n    sel('autorelease'))\nsend(window, sel('cascadeTopLeftFromPoint:'), NSMakePoint(20, 20))\nsend(window, sel('setTitle:'), appName)\nsend(window, sel('makeKeyAndOrderFront:'), nil)\n\nsend(app, sel('activateIgnoringOtherApps:'), YES)\nsend(app, sel('run'))\n", "demo/recopendirtype_build.py": "from cffi import FFI\nimport bsdopendirtype_build\n\nffi = FFI()\n\n# ========== This is a demo of ffi.include() ==========\nffi.include(bsdopendirtype_build.ffi)\n\nffi.cdef(\"\"\"\n    int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);\n\"\"\")\n\nffi.set_source(\"_recopendirtype\", \"\"\"\n    #include <sys/types.h>\n    #include <dirent.h>\n\"\"\")\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/readdir_build.py": "import sys\nfrom cffi import FFI\n\nif not sys.platform.startswith('linux'):\n    raise Exception(\"Linux-only demo\")\n\n\nffi = FFI()\nffi.cdef(\"\"\"\n\n    typedef void DIR;\n    typedef long ino_t;\n    typedef long off_t;\n\n    struct dirent {\n        ino_t          d_ino;       /* inode number */\n        off_t          d_off;       /* offset to the next dirent */\n        unsigned short d_reclen;    /* length of this record */\n        unsigned char  d_type;      /* type of file; not supported\n                                       by all file system types */\n        char           d_name[256]; /* filename */\n    };\n\n    int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result);\n    int openat(int dirfd, const char *pathname, int flags);\n    DIR *fdopendir(int fd);\n    int closedir(DIR *dirp);\n\n\"\"\")\nffi.set_source(\"_readdir\", None)\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/bsdopendirtype.py": "from _bsdopendirtype import ffi, lib\n\n\ndef _posix_error():\n    raise OSError(ffi.errno, os.strerror(ffi.errno))\n\n_dtype_to_smode = {\n    lib.DT_BLK:  0o060000,\n    lib.DT_CHR:  0o020000,\n    lib.DT_DIR:  0o040000,\n    lib.DT_FIFO: 0o010000,\n    lib.DT_LNK:  0o120000,\n    lib.DT_REG:  0o100000,\n    lib.DT_SOCK: 0o140000,\n}\n\ndef opendir(dir):\n    if len(dir) == 0:\n        dir = b'.'\n    dirname = dir\n    if not dirname.endswith(b'/'):\n        dirname += b'/'\n    dirp = lib.opendir(dir)\n    if dirp == ffi.NULL:\n        raise _posix_error()\n    try:\n        while True:\n            ffi.errno = 0\n            dirent = lib.readdir(dirp)\n            if dirent == ffi.NULL:\n                if ffi.errno != 0:\n                    raise _posix_error()\n                return\n            name = ffi.string(dirent.d_name)\n            if name == b'.' or name == b'..':\n                continue\n            name = dirname + name\n            try:\n                smode = _dtype_to_smode[dirent.d_type]\n            except KeyError:\n                smode = os.lstat(name).st_mode\n            yield name, smode\n    finally:\n        lib.closedir(dirp)\n\nif __name__ == '__main__':\n    for name, smode in opendir(b'/tmp'):\n        print(hex(smode), name)\n", "demo/_curses_setup.py": "from setuptools import setup\n\nsetup(\n    name=\"_curses\",\n    version=\"0.1\",\n    py_modules=[\"_curses\"],\n    setup_requires=[\"cffi>=1.0.dev0\"],\n    cffi_modules=[\n        \"_curses_build.py:ffi\",\n    ],\n    install_requires=[\"cffi>=1.0.dev0\"],   # should maybe be \"cffi-backend\" only?\n    zip_safe=False,\n)\n", "demo/xclient_build.py": "from cffi import FFI\nffi = FFI()\nffi.cdef(\"\"\"\n\ntypedef ... Display;\ntypedef struct { ...; } Window;\n\ntypedef struct { int type; ...; } XEvent;\n\nDisplay *XOpenDisplay(char *display_name);\nWindow DefaultRootWindow(Display *display);\nint XMapRaised(Display *display, Window w);\nWindow XCreateSimpleWindow(Display *display, Window parent, int x, int y,\n                           unsigned int width, unsigned int height,\n                           unsigned int border_width, unsigned long border,\n                           unsigned long background);\nint XNextEvent(Display *display, XEvent *event_return);\n\"\"\")\n\nffi.set_source('_xclient_cffi', \"\"\"\n            #include <X11/Xlib.h>\n\"\"\", libraries=['X11'])\n\nif __name__ == '__main__':\n    ffi.compile(verbose=True)\n", "demo/gmp_build.py": "import cffi\n\n#\n# This is only a demo based on the GMP library.\n# There is a rather more complete (but perhaps outdated) version available at:\n# http://bazaar.launchpad.net/~tolot-solar-empire/+junk/gmpy_cffi/files\n#\n\nffibuilder = cffi.FFI()\n\nffibuilder.cdef(\"\"\"\n\n    typedef struct { ...; } MP_INT;\n    typedef MP_INT mpz_t[1];\n\n    int mpz_init_set_str (MP_INT *dest_integer, char *src_cstring, int base);\n    void mpz_add (MP_INT *sum, MP_INT *addend1, MP_INT *addend2);\n    char * mpz_get_str (char *string, int base, MP_INT *integer);\n\n\"\"\")\n\nffibuilder.set_source('_gmp_cffi', \"#include <gmp.h>\",\n                 libraries=['gmp', 'm'])\n\nif __name__ == '__main__':\n    ffibuilder.compile(verbose=True)\n", "demo/bsdopendirtype_setup.py": "from setuptools import setup\n\nsetup(\n    name=\"example\",\n    version=\"0.1\",\n    py_modules=[\"bsdopendirtype\"],\n    setup_requires=[\"cffi>=1.0.dev0\"],\n    cffi_modules=[\n        \"bsdopendirtype_build.py:ffibuilder\",\n    ],\n    install_requires=[\"cffi>=1.0.dev0\"],   # should maybe be \"cffi-backend\" only?\n    zip_safe=False,\n)\n", "demo/extern_python.py": "import cffi\n\nffi = cffi.FFI()\n\nffi.cdef(\"\"\"int my_algo(int); extern \"Python\" int f(int);\"\"\")\n\nffi.set_source(\"_extern_python_cffi\", \"\"\"\n    static int f(int);\n    static int my_algo(int n) {\n        int i, sum = 0;\n        for (i = 0; i < n; i++)\n            sum += f(i);\n        return sum;\n    }\n\"\"\")\n\nffi.compile()\n\n\nfrom _extern_python_cffi import ffi, lib\n\n@ffi.def_extern()\ndef f(n):\n    return n * n\n\nassert lib.my_algo(10) == 0+1+4+9+16+25+36+49+64+81\n", "demo/winclipboard_build.py": "from cffi import FFI\n\nffi = FFI()\nffi.cdef('''\n    typedef void * HANDLE;\n    typedef HANDLE HWND;\n    typedef int BOOL;\n    typedef unsigned int UINT;\n    typedef int SIZE_T;\n    typedef char * LPTSTR;\n    typedef HANDLE HGLOBAL;\n    typedef HANDLE LPVOID;\n\n    HWND GetConsoleWindow(void);\n\n    LPVOID GlobalLock( HGLOBAL hMem );\n    BOOL GlobalUnlock( HGLOBAL hMem );\n    HGLOBAL GlobalAlloc(UINT uFlags, SIZE_T dwBytes);\n\n    BOOL  OpenClipboard(HWND hWndNewOwner);\n    BOOL  CloseClipboard(void);\n    BOOL  EmptyClipboard(void);\n    HANDLE  SetClipboardData(UINT uFormat, HANDLE hMem);\n\n    #define CF_TEXT ...\n    #define GMEM_MOVEABLE ...\n\n    void * memcpy(void * s1, void * s2, int n);\n    ''')\n\nffi.set_source('_winclipboard_cffi', '''\n    #include <windows.h>\n''', libraries=[\"user32\"])\n\nif __name__ == '__main__':\n    ffi.compile()\n", "demo/embedding.py": "import cffi\n\nffibuilder = cffi.FFI()\n\nffibuilder.embedding_api(\"\"\"\n    int add(int, int);\n\"\"\")\n\nffibuilder.embedding_init_code(\"\"\"\n    from _embedding_cffi import ffi\n    print(\"preparing\")   # printed once\n\n    @ffi.def_extern()\n    def add(x, y):\n        print(\"adding %d and %d\" % (x, y))\n        return x + y\n\"\"\")\n\nffibuilder.set_source(\"_embedding_cffi\", \"\")\n\nffibuilder.compile(verbose=True)\n", "demo/readdir2_setup.py": "from distutils.core import setup\nimport readdir2_build\n\nsetup(\n    name=\"readdir2\",\n    version=\"0.1\",\n    py_modules=[\"readdir2\"],\n    ext_modules=[readdir2_build.ffi.distutils_extension('build')],\n)\n", "demo/_curses.py": "\"\"\"Reimplementation of the standard extension module '_curses' using cffi.\"\"\"\n\nimport sys\nfrom functools import wraps\n\nfrom _curses_cffi import ffi, lib\n\n\ndef _copy_to_globals(name):\n    globals()[name] = getattr(lib, name)\n\n\ndef _setup():\n    for name in ['ERR', 'OK', 'KEY_MIN', 'KEY_MAX',\n                 'A_ATTRIBUTES', 'A_NORMAL', 'A_STANDOUT', 'A_UNDERLINE',\n                 'A_REVERSE', 'A_BLINK', 'A_DIM', 'A_BOLD', 'A_ALTCHARSET',\n                 'A_PROTECT', 'A_CHARTEXT', 'A_COLOR',\n                 'COLOR_BLACK', 'COLOR_RED', 'COLOR_GREEN', 'COLOR_YELLOW',\n                 'COLOR_BLUE', 'COLOR_MAGENTA', 'COLOR_CYAN', 'COLOR_WHITE',\n                 ]:\n        _copy_to_globals(name)\n\n    if not lib._m_NetBSD:\n        _copy_to_globals('A_INVIS')\n\n    for name in ['A_HORIZONTAL', 'A_LEFT', 'A_LOW', 'A_RIGHT', 'A_TOP',\n                 'A_VERTICAL',\n                 ]:\n        if hasattr(lib, name):\n            _copy_to_globals(name)\n\n    if lib._m_NCURSES_MOUSE_VERSION:\n        for name in [\"BUTTON1_PRESSED\", \"BUTTON1_RELEASED\", \"BUTTON1_CLICKED\",\n                     \"BUTTON1_DOUBLE_CLICKED\", \"BUTTON1_TRIPLE_CLICKED\",\n                     \"BUTTON2_PRESSED\", \"BUTTON2_RELEASED\", \"BUTTON2_CLICKED\",\n                     \"BUTTON2_DOUBLE_CLICKED\", \"BUTTON2_TRIPLE_CLICKED\",\n                     \"BUTTON3_PRESSED\", \"BUTTON3_RELEASED\", \"BUTTON3_CLICKED\",\n                     \"BUTTON3_DOUBLE_CLICKED\", \"BUTTON3_TRIPLE_CLICKED\",\n                     \"BUTTON4_PRESSED\", \"BUTTON4_RELEASED\", \"BUTTON4_CLICKED\",\n                     \"BUTTON4_DOUBLE_CLICKED\", \"BUTTON4_TRIPLE_CLICKED\",\n                     \"BUTTON_SHIFT\", \"BUTTON_CTRL\", \"BUTTON_ALT\",\n                     \"ALL_MOUSE_EVENTS\", \"REPORT_MOUSE_POSITION\",\n                     ]:\n            _copy_to_globals(name)\n\n    if not lib._m_NetBSD:\n        for key in range(lib.KEY_MIN, lib.KEY_MAX):\n            key_n = lib.keyname(key)\n            if key_n == ffi.NULL:\n                continue\n            key_n = ffi.string(key_n)\n            if key_n == b\"UNKNOWN KEY\":\n                continue\n            if not isinstance(key_n, str):   # python 3\n                key_n = key_n.decode()\n            key_n = key_n.replace('(', '').replace(')', '')\n            globals()[key_n] = key\n\n_setup()\n\n# Do we want this?\n# version = \"2.2\"\n# __version__ = \"2.2\"\n\n\n# ____________________________________________________________\n\n\n_initialised_setupterm = False\n_initialised = False\n_initialised_color = False\n\n\ndef _ensure_initialised_setupterm():\n    if not _initialised_setupterm:\n        raise error(\"must call (at least) setupterm() first\")\n\n\ndef _ensure_initialised():\n    if not _initialised:\n        raise error(\"must call initscr() first\")\n\n\ndef _ensure_initialised_color():\n    if not _initialised and _initialised_color:\n        raise error(\"must call start_color() first\")\n\n\ndef _check_ERR(code, fname):\n    if code != lib.ERR:\n        return None\n    elif fname is None:\n        raise error(\"curses function returned ERR\")\n    else:\n        raise error(\"%s() returned ERR\" % (fname,))\n\n\ndef _check_NULL(rval):\n    if rval == ffi.NULL:\n        raise error(\"curses function returned NULL\")\n    return rval\n\n\ndef _call_lib(method_name, *args):\n    return getattr(lib, method_name)(*args)\n\n\ndef _call_lib_check_ERR(method_name, *args):\n    return _check_ERR(_call_lib(method_name, *args), method_name)\n\n\ndef _mk_no_return(method_name):\n    def _execute():\n        _ensure_initialised()\n        return _call_lib_check_ERR(method_name)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_flag_func(method_name):\n    # This is in the CPython implementation, but not documented anywhere.\n    # We have to support it, though, even if it make me sad.\n    def _execute(flag=True):\n        _ensure_initialised()\n        if flag:\n            return _call_lib_check_ERR(method_name)\n        else:\n            return _call_lib_check_ERR('no' + method_name)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_return_val(method_name):\n    def _execute():\n        return _call_lib(method_name)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_w_getyx(method_name):\n    def _execute(self):\n        y = _call_lib(method_name + 'y', self._win)\n        x = _call_lib(method_name + 'x', self._win)\n        return (y, x)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_w_no_return(method_name):\n    def _execute(self, *args):\n        return _call_lib_check_ERR(method_name, self._win, *args)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _mk_w_return_val(method_name):\n    def _execute(self, *args):\n        return _call_lib(method_name, self._win, *args)\n    _execute.__name__ = method_name\n    return _execute\n\n\ndef _chtype(ch):\n    return int(ffi.cast(\"chtype\", ch))\n\ndef _texttype(text):\n    if isinstance(text, str):\n        return text\n    elif isinstance(text, unicode):\n        return str(text)   # default encoding\n    else:\n        raise TypeError(\"str or unicode expected, got a '%s' object\"\n                        % (type(text).__name__,))\n\n\ndef _extract_yx(args):\n    if len(args) >= 2:\n        return (args[0], args[1], args[2:])\n    return (None, None, args)\n\n\ndef _process_args(funcname, args, count, optcount, frontopt=0):\n    outargs = []\n    if frontopt:\n        if len(args) > count + optcount:\n            # We have the front optional args here.\n            outargs.extend(args[:frontopt])\n            args = args[frontopt:]\n        else:\n            # No front optional args, so make them None.\n            outargs.extend([None] * frontopt)\n    if (len(args) < count) or (len(args) > count + optcount):\n        raise error(\"%s requires %s to %s arguments\" % (\n                funcname, count, count + optcount + frontopt))\n    outargs.extend(args)\n    return outargs\n\n\ndef _argspec(count, optcount=0, frontopt=0):\n    def _argspec_deco(func):\n        @wraps(func)\n        def _wrapped(self, *args):\n            outargs = _process_args(\n                func.__name__, args, count, optcount, frontopt)\n            return func(self, *outargs)\n        return _wrapped\n    return _argspec_deco\n\n\n# ____________________________________________________________\n\n\nclass error(Exception):\n    pass\n\n\nclass Window(object):\n    def __init__(self, window):\n        self._win = window\n\n    def __del__(self):\n        if self._win != lib.stdscr:\n            lib.delwin(self._win)\n\n    untouchwin = _mk_w_no_return(\"untouchwin\")\n    touchwin = _mk_w_no_return(\"touchwin\")\n    redrawwin = _mk_w_no_return(\"redrawwin\")\n    insertln = _mk_w_no_return(\"winsertln\")\n    erase = _mk_w_no_return(\"werase\")\n    deleteln = _mk_w_no_return(\"wdeleteln\")\n\n    is_wintouched = _mk_w_return_val(\"is_wintouched\")\n\n    syncdown = _mk_w_return_val(\"wsyncdown\")\n    syncup = _mk_w_return_val(\"wsyncup\")\n    standend = _mk_w_return_val(\"wstandend\")\n    standout = _mk_w_return_val(\"wstandout\")\n    cursyncup = _mk_w_return_val(\"wcursyncup\")\n    clrtoeol = _mk_w_return_val(\"wclrtoeol\")\n    clrtobot = _mk_w_return_val(\"wclrtobot\")\n    clear = _mk_w_return_val(\"wclear\")\n\n    idcok = _mk_w_no_return(\"idcok\")\n    immedok = _mk_w_no_return(\"immedok\")\n    timeout = _mk_w_no_return(\"wtimeout\")\n\n    getyx = _mk_w_getyx(\"getcur\")\n    getbegyx = _mk_w_getyx(\"getbeg\")\n    getmaxyx = _mk_w_getyx(\"getmax\")\n    getparyx = _mk_w_getyx(\"getpar\")\n\n    clearok = _mk_w_no_return(\"clearok\")\n    idlok = _mk_w_no_return(\"idlok\")\n    leaveok = _mk_w_no_return(\"leaveok\")\n    notimeout = _mk_w_no_return(\"notimeout\")\n    scrollok = _mk_w_no_return(\"scrollok\")\n    insdelln = _mk_w_no_return(\"winsdelln\")\n    syncok = _mk_w_no_return(\"syncok\")\n\n    mvwin = _mk_w_no_return(\"mvwin\")\n    mvderwin = _mk_w_no_return(\"mvderwin\")\n    move = _mk_w_no_return(\"wmove\")\n\n    if not lib._m_STRICT_SYSV_CURSES:\n        resize = _mk_w_no_return(\"wresize\")\n\n    if lib._m_NetBSD:\n        keypad = _mk_w_return_val(\"keypad\")\n        nodelay = _mk_w_return_val(\"nodelay\")\n    else:\n        keypad = _mk_w_no_return(\"keypad\")\n        nodelay = _mk_w_no_return(\"nodelay\")\n\n    @_argspec(1, 1, 2)\n    def addch(self, y, x, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        ch = _chtype(ch)\n\n        if y is not None:\n            code = lib.mvwaddch(self._win, y, x, ch | attr)\n        else:\n            code = lib.waddch(self._win, ch | attr)\n        return _check_ERR(code, \"addch\")\n\n    @_argspec(1, 1, 2)\n    def addstr(self, y, x, text, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwaddstr(self._win, y, x, text)\n        else:\n            code = lib.waddstr(self._win, text)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"addstr\")\n\n    @_argspec(2, 1, 2)\n    def addnstr(self, y, x, text, n, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwaddnstr(self._win, y, x, text, n)\n        else:\n            code = lib.waddnstr(self._win, text, n)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"addnstr\")\n\n    def bkgd(self, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        return _check_ERR(lib.wbkgd(self._win, _chtype(ch) | attr), \"bkgd\")\n\n    attroff = _mk_w_no_return(\"wattroff\")\n    attron = _mk_w_no_return(\"wattron\")\n    attrset = _mk_w_no_return(\"wattrset\")\n\n    def bkgdset(self, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        lib.wbkgdset(self._win, _chtype(ch) | attr)\n        return None\n\n    def border(self, ls=0, rs=0, ts=0, bs=0, tl=0, tr=0, bl=0, br=0):\n        lib.wborder(self._win,\n                    _chtype(ls), _chtype(rs), _chtype(ts), _chtype(bs),\n                    _chtype(tl), _chtype(tr), _chtype(bl), _chtype(br))\n        return None\n\n    def box(self, vertint=0, horint=0):\n        lib.box(self._win, vertint, horint)\n        return None\n\n    @_argspec(1, 1, 2)\n    def chgat(self, y, x, num, attr=None):\n        # These optional args are in a weird order.\n        if attr is None:\n            attr = num\n            num = -1\n\n        color = ((attr >> 8) & 0xff)\n        attr = attr - (color << 8)\n\n        if y is not None:\n            code = lib.mvwchgat(self._win, y, x, num, attr, color, ffi.NULL)\n            lib.touchline(self._win, y, 1)\n        else:\n            yy, _ = self.getyx()\n            code = lib.wchgat(self._win, num, attr, color, ffi.NULL)\n            lib.touchline(self._win, yy, 1)\n        return _check_ERR(code, \"chgat\")\n\n    def delch(self, *args):\n        if len(args) == 0:\n            code = lib.wdelch(self._win)\n        elif len(args) == 2:\n            code = lib.mvwdelch(self._win, *args)\n        else:\n            raise error(\"delch requires 0 or 2 arguments\")\n        return _check_ERR(code, \"[mv]wdelch\")\n\n    def derwin(self, *args):\n        nlines = 0\n        ncols = 0\n        if len(args) == 2:\n            begin_y, begin_x = args\n        elif len(args) == 4:\n            nlines, ncols, begin_y, begin_x = args\n        else:\n            raise error(\"derwin requires 2 or 4 arguments\")\n\n        win = lib.derwin(self._win, nlines, ncols, begin_y, begin_x)\n        return Window(_check_NULL(win))\n\n    def echochar(self, ch, attr=None):\n        if attr is None:\n            attr = lib.A_NORMAL\n        ch = _chtype(ch)\n\n        if lib._m_ispad(self._win):\n            code = lib.pechochar(self._win, ch | attr)\n        else:\n            code = lib.wechochar(self._win, ch | attr)\n        return _check_ERR(code, \"echochar\")\n\n    if lib._m_NCURSES_MOUSE_VERSION:\n        enclose = _mk_w_return_val(\"wenclose\")\n\n    getbkgd = _mk_w_return_val(\"getbkgd\")\n\n    def getch(self, *args):\n        if len(args) == 0:\n            val = lib.wgetch(self._win)\n        elif len(args) == 2:\n            val = lib.mvwgetch(self._win, *args)\n        else:\n            raise error(\"getch requires 0 or 2 arguments\")\n        return val\n\n    def getkey(self, *args):\n        if len(args) == 0:\n            val = lib.wgetch(self._win)\n        elif len(args) == 2:\n            val = lib.mvwgetch(self._win, *args)\n        else:\n            raise error(\"getkey requires 0 or 2 arguments\")\n\n        if val == lib.ERR:\n            raise error(\"no input\")\n        elif val <= 255:\n            return chr(val)\n        else:\n            # XXX: The following line is different if `__NetBSD__` is defined.\n            val = lib.keyname(val)\n            if val == ffi.NULL:\n                return \"\"\n            return ffi.string(val)\n\n    @_argspec(0, 1, 2)\n    def getstr(self, y, x, n=1023):\n        n = min(n, 1023)\n        buf = ffi.new(\"char[1024]\")  # /* This should be big enough.. I hope */\n\n        if y is None:\n            val = lib.wgetnstr(self._win, buf, n)\n        else:\n            val = lib.mvwgetnstr(self._win, y, x, buf, n)\n\n        if val == lib.ERR:\n            return \"\"\n        return ffi.string(buf)\n\n    @_argspec(2, 1, 2)\n    def hline(self, y, x, ch, n, attr=None):\n        ch = _chtype(ch)\n        if attr is None:\n            attr = lib.A_NORMAL\n        if y is not None:\n            _check_ERR(lib.wmove(self._win, y, x), \"wmove\")\n        return _check_ERR(lib.whline(self._win, ch | attr, n), \"hline\")\n\n    @_argspec(1, 1, 2)\n    def insch(self, y, x, ch, attr=None):\n        ch = _chtype(ch)\n        if attr is None:\n            attr = lib.A_NORMAL\n        if y is not None:\n            code = lib.mvwinsch(self._win, y, x, ch | attr)\n        else:\n            code = lib.winsch(self._win, ch | attr)\n        return _check_ERR(code, \"insch\")\n\n    def inch(self, *args):\n        if len(args) == 0:\n            return lib.winch(self._win)\n        elif len(args) == 2:\n            return lib.mvwinch(self._win, *args)\n        else:\n            raise error(\"inch requires 0 or 2 arguments\")\n\n    @_argspec(0, 1, 2)\n    def instr(self, y, x, n=1023):\n        n = min(n, 1023)\n        buf = ffi.new(\"char[1024]\")  # /* This should be big enough.. I hope */\n        if y is None:\n            code = lib.winnstr(self._win, buf, n)\n        else:\n            code = lib.mvwinnstr(self._win, y, x, buf, n)\n\n        if code == lib.ERR:\n            return \"\"\n        return ffi.string(buf)\n\n    @_argspec(1, 1, 2)\n    def insstr(self, y, x, text, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwinsstr(self._win, y, x, text)\n        else:\n            code = lib.winsstr(self._win, text)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"insstr\")\n\n    @_argspec(2, 1, 2)\n    def insnstr(self, y, x, text, n, attr=None):\n        text = _texttype(text)\n        if attr is not None:\n            attr_old = lib.getattrs(self._win)\n            lib.wattrset(self._win, attr)\n        if y is not None:\n            code = lib.mvwinsnstr(self._win, y, x, text, n)\n        else:\n            code = lib.winsnstr(self._win, text, n)\n        if attr is not None:\n            lib.wattrset(self._win, attr_old)\n        return _check_ERR(code, \"insnstr\")\n\n    def is_linetouched(self, line):\n        code = lib.is_linetouched(self._win, line)\n        if code == lib.ERR:\n            raise error(\"is_linetouched: line number outside of boundaries\")\n        if code == lib.FALSE:\n            return False\n        return True\n\n    def noutrefresh(self, *args):\n        if lib._m_ispad(self._win):\n            if len(args) != 6:\n                raise error(\n                    \"noutrefresh() called for a pad requires 6 arguments\")\n            return _check_ERR(lib.pnoutrefresh(self._win, *args),\n                              \"pnoutrefresh\")\n        else:\n            # XXX: Better args check here? We need zero args.\n            return _check_ERR(lib.wnoutrefresh(self._win, *args),\n                              \"wnoutrefresh\")\n\n    nooutrefresh = noutrefresh  # \"to be removed in 2.3\", but in 2.7, 3.x.\n\n    def _copywin(self, dstwin, overlay,\n                 sminr, sminc, dminr, dminc, dmaxr, dmaxc):\n        return _check_ERR(lib.copywin(self._win, dstwin._win,\n                                      sminr, sminc, dminr, dminc, dmaxr, dmaxc,\n                                      overlay), \"copywin\")\n\n    def overlay(self, dstwin, *args):\n        if len(args) == 6:\n            return self._copywin(dstwin, True, *args)\n        elif len(args) == 0:\n            return _check_ERR(lib.overlay(self._win, dstwin._win), \"overlay\")\n        else:\n            raise error(\"overlay requires one or seven arguments\")\n\n    def overwrite(self, dstwin, *args):\n        if len(args) == 6:\n            return self._copywin(dstwin, False, *args)\n        elif len(args) == 0:\n            return _check_ERR(lib.overwrite(self._win, dstwin._win),\n                              \"overwrite\")\n        else:\n            raise error(\"overwrite requires one or seven arguments\")\n\n    def putwin(self, filep):\n        # filestar = ffi.new(\"FILE *\", filep)\n        return _check_ERR(lib.putwin(self._win, filep), \"putwin\")\n\n    def redrawln(self, beg, num):\n        return _check_ERR(lib.wredrawln(self._win, beg, num), \"redrawln\")\n\n    def refresh(self, *args):\n        if lib._m_ispad(self._win):\n            if len(args) != 6:\n                raise error(\n                    \"noutrefresh() called for a pad requires 6 arguments\")\n            return _check_ERR(lib.prefresh(self._win, *args), \"prefresh\")\n        else:\n            # XXX: Better args check here? We need zero args.\n            return _check_ERR(lib.wrefresh(self._win, *args), \"wrefresh\")\n\n    def setscrreg(self, y, x):\n        return _check_ERR(lib.wsetscrreg(self._win, y, x), \"wsetscrreg\")\n\n    def subwin(self, *args):\n        nlines = 0\n        ncols = 0\n        if len(args) == 2:\n            begin_y, begin_x = args\n        elif len(args) == 4:\n            nlines, ncols, begin_y, begin_x = args\n        else:\n            raise error(\"subwin requires 2 or 4 arguments\")\n\n        if lib._m_ispad(self._win):\n            win = lib.subpad(self._win, nlines, ncols, begin_y, begin_x)\n        else:\n            win = lib.subwin(self._win, nlines, ncols, begin_y, begin_x)\n        return Window(_check_NULL(win))\n\n    def scroll(self, nlines=None):\n        if nlines is None:\n            return _check_ERR(lib.scroll(self._win), \"scroll\")\n        else:\n            return _check_ERR(lib.wscrl(self._win, nlines), \"scroll\")\n\n    def touchline(self, st, cnt, val=None):\n        if val is None:\n            return _check_ERR(lib.touchline(self._win, st, cnt), \"touchline\")\n        else:\n            return _check_ERR(lib.wtouchln(self._win, st, cnt, val),\n                              \"touchline\")\n\n    @_argspec(2, 1, 2)\n    def vline(self, y, x, ch, n, attr=None):\n        ch = _chtype(ch)\n        if attr is None:\n            attr = lib.A_NORMAL\n        if y is not None:\n            _check_ERR(lib.wmove(self._win, y, x), \"wmove\")\n        return _check_ERR(lib.wvline(self._win, ch | attr, n), \"vline\")\n\n\nbeep = _mk_no_return(\"beep\")\ndef_prog_mode = _mk_no_return(\"def_prog_mode\")\ndef_shell_mode = _mk_no_return(\"def_shell_mode\")\ndoupdate = _mk_no_return(\"doupdate\")\nendwin = _mk_no_return(\"endwin\")\nflash = _mk_no_return(\"flash\")\nnocbreak = _mk_no_return(\"nocbreak\")\nnoecho = _mk_no_return(\"noecho\")\nnonl = _mk_no_return(\"nonl\")\nnoraw = _mk_no_return(\"noraw\")\nreset_prog_mode = _mk_no_return(\"reset_prog_mode\")\nreset_shell_mode = _mk_no_return(\"reset_shell_mode\")\nresetty = _mk_no_return(\"resetty\")\nsavetty = _mk_no_return(\"savetty\")\n\ncbreak = _mk_flag_func(\"cbreak\")\necho = _mk_flag_func(\"echo\")\nnl = _mk_flag_func(\"nl\")\nraw = _mk_flag_func(\"raw\")\n\nbaudrate = _mk_return_val(\"baudrate\")\ntermattrs = _mk_return_val(\"termattrs\")\n\ntermname = _mk_return_val(\"termname\")\nlongname = _mk_return_val(\"longname\")\n\ncan_change_color = _mk_return_val(\"can_change_color\")\nhas_colors = _mk_return_val(\"has_colors\")\nhas_ic = _mk_return_val(\"has_ic\")\nhas_il = _mk_return_val(\"has_il\")\nisendwin = _mk_return_val(\"isendwin\")\nflushinp = _mk_return_val(\"flushinp\")\nnoqiflush = _mk_return_val(\"noqiflush\")\n\n\ndef filter():\n    lib.filter()\n    return None\n\n\ndef color_content(color):\n    _ensure_initialised_color()\n    r, g, b = ffi.new(\"short *\"), ffi.new(\"short *\"), ffi.new(\"short *\")\n    if lib.color_content(color, r, g, b) == lib.ERR:\n        raise error(\"Argument 1 was out of range. Check value of COLORS.\")\n    return (r[0], g[0], b[0])\n\n\ndef color_pair(n):\n    _ensure_initialised_color()\n    return (n << 8)\n\n\ndef curs_set(vis):\n    _ensure_initialised()\n    val = lib.curs_set(vis)\n    _check_ERR(val, \"curs_set\")\n    return val\n\n\ndef delay_output(ms):\n    _ensure_initialised()\n    return _check_ERR(lib.delay_output(ms), \"delay_output\")\n\n\ndef erasechar():\n    _ensure_initialised()\n    return lib.erasechar()\n\n\ndef getsyx():\n    _ensure_initialised()\n    yx = ffi.new(\"int[2]\")\n    lib._m_getsyx(yx)\n    return (yx[0], yx[1])\n\n\nif lib._m_NCURSES_MOUSE_VERSION:\n\n    def getmouse():\n        _ensure_initialised()\n        mevent = ffi.new(\"MEVENT *\")\n        _check_ERR(lib.getmouse(mevent), \"getmouse\")\n        return (mevent.id, mevent.x, mevent.y, mevent.z, mevent.bstate)\n\n    def ungetmouse(id, x, y, z, bstate):\n        _ensure_initialised()\n        mevent = ffi.new(\"MEVENT *\")\n        mevent.id, mevent.x, mevent.y, mevent.z, mevent.bstate = (\n            id, x, y, z, bstate)\n        return _check_ERR(lib.ungetmouse(mevent), \"ungetmouse\")\n\n\ndef getwin(filep):\n    return Window(_check_NULL(lib.getwin(filep)))\n\n\ndef halfdelay(tenths):\n    _ensure_initialised()\n    return _check_ERR(lib.halfdelay(tenths), \"halfdelay\")\n\n\nif not lib._m_STRICT_SYSV_CURSES:\n    def has_key(ch):\n        _ensure_initialised()\n        return lib.has_key(ch)\n\n\ndef init_color(color, r, g, b):\n    _ensure_initialised_color()\n    return _check_ERR(lib.init_color(color, r, g, b), \"init_color\")\n\n\ndef init_pair(pair, f, b):\n    _ensure_initialised_color()\n    return _check_ERR(lib.init_pair(pair, f, b), \"init_pair\")\n\n\ndef _mk_acs(name, ichar):\n    if len(ichar) == 1:\n        globals()[name] = lib.acs_map[ord(ichar)]\n    else:\n        globals()[name] = globals()[ichar]\n\n\ndef _map_acs():\n    _mk_acs(\"ACS_ULCORNER\", 'l')\n    _mk_acs(\"ACS_LLCORNER\", 'm')\n    _mk_acs(\"ACS_URCORNER\", 'k')\n    _mk_acs(\"ACS_LRCORNER\", 'j')\n    _mk_acs(\"ACS_LTEE\", 't')\n    _mk_acs(\"ACS_RTEE\", 'u')\n    _mk_acs(\"ACS_BTEE\", 'v')\n    _mk_acs(\"ACS_TTEE\", 'w')\n    _mk_acs(\"ACS_HLINE\", 'q')\n    _mk_acs(\"ACS_VLINE\", 'x')\n    _mk_acs(\"ACS_PLUS\", 'n')\n    _mk_acs(\"ACS_S1\", 'o')\n    _mk_acs(\"ACS_S9\", 's')\n    _mk_acs(\"ACS_DIAMOND\", '`')\n    _mk_acs(\"ACS_CKBOARD\", 'a')\n    _mk_acs(\"ACS_DEGREE\", 'f')\n    _mk_acs(\"ACS_PLMINUS\", 'g')\n    _mk_acs(\"ACS_BULLET\", '~')\n    _mk_acs(\"ACS_LARROW\", ',')\n    _mk_acs(\"ACS_RARROW\", '+')\n    _mk_acs(\"ACS_DARROW\", '.')\n    _mk_acs(\"ACS_UARROW\", '-')\n    _mk_acs(\"ACS_BOARD\", 'h')\n    _mk_acs(\"ACS_LANTERN\", 'i')\n    _mk_acs(\"ACS_BLOCK\", '0')\n    _mk_acs(\"ACS_S3\", 'p')\n    _mk_acs(\"ACS_S7\", 'r')\n    _mk_acs(\"ACS_LEQUAL\", 'y')\n    _mk_acs(\"ACS_GEQUAL\", 'z')\n    _mk_acs(\"ACS_PI\", '{')\n    _mk_acs(\"ACS_NEQUAL\", '|')\n    _mk_acs(\"ACS_STERLING\", '}')\n    _mk_acs(\"ACS_BSSB\", \"ACS_ULCORNER\")\n    _mk_acs(\"ACS_SSBB\", \"ACS_LLCORNER\")\n    _mk_acs(\"ACS_BBSS\", \"ACS_URCORNER\")\n    _mk_acs(\"ACS_SBBS\", \"ACS_LRCORNER\")\n    _mk_acs(\"ACS_SBSS\", \"ACS_RTEE\")\n    _mk_acs(\"ACS_SSSB\", \"ACS_LTEE\")\n    _mk_acs(\"ACS_SSBS\", \"ACS_BTEE\")\n    _mk_acs(\"ACS_BSSS\", \"ACS_TTEE\")\n    _mk_acs(\"ACS_BSBS\", \"ACS_HLINE\")\n    _mk_acs(\"ACS_SBSB\", \"ACS_VLINE\")\n    _mk_acs(\"ACS_SSSS\", \"ACS_PLUS\")\n\n\ndef initscr():\n    if _initialised:\n        lib.wrefresh(lib.stdscr)\n        return Window(lib.stdscr)\n\n    win = _check_NULL(lib.initscr())\n    globals()['_initialised_setupterm'] = True\n    globals()['_initialised'] = True\n\n    _map_acs()\n\n    globals()[\"LINES\"] = lib.LINES\n    globals()[\"COLS\"] = lib.COLS\n\n    return Window(win)\n\n\ndef setupterm(term=None, fd=-1):\n    if fd == -1:\n        # XXX: Check for missing stdout here?\n        fd = sys.stdout.fileno()\n\n    if _initialised_setupterm:\n        return None\n\n    if term is None:\n        term = ffi.NULL\n    err = ffi.new(\"int *\")\n    if lib.setupterm(term, fd, err) == lib.ERR:\n        err = err[0]\n        if err == 0:\n            raise error(\"setupterm: could not find terminal\")\n        elif err == -1:\n            raise error(\"setupterm: could not find terminfo database\")\n        else:\n            raise error(\"setupterm: unknown error\")\n\n    globals()[\"_initialised_setupterm\"] = True\n    return None\n\n\ndef intrflush(ch):\n    _ensure_initialised()\n    return _check_ERR(lib.intrflush(ffi.NULL, ch), \"intrflush\")\n\n\n# XXX: #ifdef HAVE_CURSES_IS_TERM_RESIZED\ndef is_term_resized(lines, columns):\n    _ensure_initialised()\n    return lib.is_term_resized(lines, columns)\n\n\nif not lib._m_NetBSD:\n    def keyname(ch):\n        _ensure_initialised()\n        if ch < 0:\n            raise error(\"invalid key number\")\n        knp = lib.keyname(ch)\n        if knp == ffi.NULL:\n            return \"\"\n        return ffi.string(knp)\n\n\ndef killchar():\n    return lib.killchar()\n\n\ndef meta(ch):\n    return _check_ERR(lib.meta(lib.stdscr, ch), \"meta\")\n\n\nif lib._m_NCURSES_MOUSE_VERSION:\n\n    def mouseinterval(interval):\n        _ensure_initialised()\n        return _check_ERR(lib.mouseinterval(interval), \"mouseinterval\")\n\n    def mousemask(newmask):\n        _ensure_initialised()\n        oldmask = ffi.new(\"mmask_t *\")\n        availmask = lib.mousemask(newmask, oldmask)\n        return (availmask, oldmask)\n\n\ndef napms(ms):\n    _ensure_initialised()\n    return lib.napms(ms)\n\n\ndef newpad(nlines, ncols):\n    _ensure_initialised()\n    return Window(_check_NULL(lib.newpad(nlines, ncols)))\n\n\ndef newwin(nlines, ncols, begin_y=None, begin_x=None):\n    _ensure_initialised()\n    if begin_x is None:\n        if begin_y is not None:\n            raise error(\"newwin requires 2 or 4 arguments\")\n        begin_y = begin_x = 0\n\n    return Window(_check_NULL(lib.newwin(nlines, ncols, begin_y, begin_x)))\n\n\ndef pair_content(pair):\n    _ensure_initialised_color()\n    f = ffi.new(\"short *\")\n    b = ffi.new(\"short *\")\n    if lib.pair_content(pair, f, b) == lib.ERR:\n        raise error(\"Argument 1 was out of range. (1..COLOR_PAIRS-1)\")\n    return (f, b)\n\n\ndef pair_number(pairvalue):\n    _ensure_initialised_color()\n    return (pairvalue & lib.A_COLOR) >> 8\n\n\ndef putp(text):\n    text = _texttype(text)\n    return _check_ERR(lib.putp(text), \"putp\")\n\n\ndef qiflush(flag=True):\n    _ensure_initialised()\n    if flag:\n        lib.qiflush()\n    else:\n        lib.noqiflush()\n    return None\n\n\n# XXX: Do something about the following?\n# /* Internal helper used for updating curses.LINES, curses.COLS, _curses.LINES\n#  * and _curses.COLS */\n# #if defined(HAVE_CURSES_RESIZETERM) || defined(HAVE_CURSES_RESIZE_TERM)\n# static int\n# update_lines_cols(void)\n# {\n#     PyObject *o;\n#     PyObject *m = PyImport_ImportModuleNoBlock(\"curses\");\n\n#     if (!m)\n#         return 0;\n\n#     o = PyInt_FromLong(LINES);\n#     if (!o) {\n#         Py_DECREF(m);\n#         return 0;\n#     }\n#     if (PyObject_SetAttrString(m, \"LINES\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     if (PyDict_SetItemString(ModDict, \"LINES\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     Py_DECREF(o);\n#     o = PyInt_FromLong(COLS);\n#     if (!o) {\n#         Py_DECREF(m);\n#         return 0;\n#     }\n#     if (PyObject_SetAttrString(m, \"COLS\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     if (PyDict_SetItemString(ModDict, \"COLS\", o)) {\n#         Py_DECREF(m);\n#         Py_DECREF(o);\n#         return 0;\n#     }\n#     Py_DECREF(o);\n#     Py_DECREF(m);\n#     return 1;\n# }\n# #endif\n\n# #ifdef HAVE_CURSES_RESIZETERM\n# static PyObject *\n# PyCurses_ResizeTerm(PyObject *self, PyObject *args)\n# {\n#     int lines;\n#     int columns;\n#     PyObject *result;\n\n#     PyCursesInitialised;\n\n#     if (!PyArg_ParseTuple(args,\"ii:resizeterm\", &lines, &columns))\n#         return NULL;\n\n#     result = PyCursesCheckERR(resizeterm(lines, columns), \"resizeterm\");\n#     if (!result)\n#         return NULL;\n#     if (!update_lines_cols())\n#         return NULL;\n#     return result;\n# }\n\n# #endif\n\n# #ifdef HAVE_CURSES_RESIZE_TERM\n# static PyObject *\n# PyCurses_Resize_Term(PyObject *self, PyObject *args)\n# {\n#     int lines;\n#     int columns;\n\n#     PyObject *result;\n\n#     PyCursesInitialised;\n\n#     if (!PyArg_ParseTuple(args,\"ii:resize_term\", &lines, &columns))\n#         return NULL;\n\n#     result = PyCursesCheckERR(resize_term(lines, columns), \"resize_term\");\n#     if (!result)\n#         return NULL;\n#     if (!update_lines_cols())\n#         return NULL;\n#     return result;\n# }\n# #endif /* HAVE_CURSES_RESIZE_TERM */\n\n\ndef setsyx(y, x):\n    _ensure_initialised()\n    lib.setsyx(y, x)\n    return None\n\n\ndef start_color():\n    _check_ERR(lib.start_color(), \"start_color\")\n    globals()[\"COLORS\"] = lib.COLORS\n    globals()[\"COLOR_PAIRS\"] = lib.COLOR_PAIRS\n    globals()[\"_initialised_color\"] = True\n    return None\n\n\ndef tigetflag(capname):\n    _ensure_initialised_setupterm()\n    return lib.tigetflag(capname)\n\n\ndef tigetnum(capname):\n    _ensure_initialised_setupterm()\n    return lib.tigetnum(capname)\n\n\ndef tigetstr(capname):\n    _ensure_initialised_setupterm()\n    val = lib.tigetstr(capname)\n    if int(ffi.cast(\"intptr_t\", val)) in (0, -1):\n        return None\n    return ffi.string(val)\n\n\ndef tparm(fmt, i1=0, i2=0, i3=0, i4=0, i5=0, i6=0, i7=0, i8=0, i9=0):\n    args = [ffi.cast(\"int\", i) for i in (i1, i2, i3, i4, i5, i6, i7, i8, i9)]\n    result = lib.tparm(fmt, *args)\n    if result == ffi.NULL:\n        raise error(\"tparm() returned NULL\")\n    return ffi.string(result)\n\n\ndef typeahead(fd):\n    _ensure_initialised()\n    return _check_ERR(lib.typeahead(fd), \"typeahead\")\n\n\ndef unctrl(ch):\n    _ensure_initialised()\n    return lib.unctrl(_chtype(ch))\n\n\ndef ungetch(ch):\n    _ensure_initialised()\n    return _check_ERR(lib.ungetch(_chtype(ch)), \"ungetch\")\n\n\ndef use_env(flag):\n    lib.use_env(flag)\n    return None\n\n\nif not lib._m_STRICT_SYSV_CURSES:\n\n    def use_default_colors():\n        _ensure_initialised_color()\n        return _check_ERR(lib.use_default_colors(), \"use_default_colors\")\n", "demo/readdir_setup.py": "from setuptools import setup\n\nsetup(\n    name=\"example\",\n    version=\"0.1\",\n    py_modules=[\"readdir\"],\n    setup_requires=[\"cffi>=1.0.dev0\"],\n    cffi_modules=[\"readdir_build.py:ffi\"],\n    install_requires=[\"cffi>=1.0.dev0\"],\n    zip_safe=False,\n)\n", ".github/actions/dynamatrix/matrix_yaml_to_json.py": "from __future__ import annotations\n\nimport argparse\nimport json\nimport os\nimport pathlib\nimport sys\nimport typing as t\nimport yaml\n\nfrom collections.abc import MutableMapping, Sequence\n\nskipped_entries = []\n\ndef _filter_omit_entries(value):\n    if isinstance(value, MutableMapping):\n        if (omit_value := value.pop('omit', ...)) is not ...:\n            if omit_value is True or str(omit_value).lower().strip() == 'true':\n                print(f'omitting {value} from matrix')\n                skipped_entries.append(value)\n                return ...\n\n        return {k: v for k, v in ((k, _filter_omit_entries(v)) for k, v in value.items()) if v is not ...}\n\n    if isinstance(value, str):\n        return value\n\n    if isinstance(value, Sequence):\n        return [v for v in (_filter_omit_entries(v) for v in value) if v is not ...]\n\n    return value\n\ndef main():\n    p = argparse.ArgumentParser(description='GHA YAML matrix filter')\n    required_grp = p.add_mutually_exclusive_group(required=True)\n    required_grp.add_argument('--from-stdin', action='store_true', help='read input YAML from stdin')\n    required_grp.add_argument('--from-file', type=pathlib.Path, help='read input YAML from file path')\n\n    args = p.parse_args()\n\n    path: pathlib.Path | None\n\n    matrix_yaml: str\n\n    if path := args.from_file:\n        matrix_yaml = path.read_text()\n    elif args.from_stdin:\n        matrix_yaml = sys.stdin.read()\n    else:\n        raise Exception('no source provided for matrix yaml')\n\n    raw_matrix = yaml.safe_load(matrix_yaml)\n    filtered_matrix = _filter_omit_entries(raw_matrix)\n\n    output_matrix_json = json.dumps(filtered_matrix)\n    output_skipped_matrix_json = json.dumps(skipped_entries)\n\n    print(f'filtered matrix: {output_matrix_json}')\n    print(f'skipped entries: {output_skipped_matrix_json}')\n\n    if (gh_output := os.environ.get('GITHUB_OUTPUT')):\n        print('setting step output var matrix_json; skipped_matrix_json...')\n        with pathlib.Path(gh_output).open('a') as env_fd:\n            env_fd.write(f'matrix_json<<__MATRIX_EOF\\n{output_matrix_json}\\n__MATRIX_EOF\\n')\n            env_fd.write(f'skipped_matrix_json<<__MATRIX_EOF\\n{output_skipped_matrix_json}\\n__MATRIX_EOF\\n')\n    else:\n        print(\"GITHUB_OUTPUT not set; skipping variable output\")\n\n\nif __name__ == '__main__':\n    main()\n", "src/cffi/cffi_opcode.py": "from .error import VerificationError\n\nclass CffiOp(object):\n    def __init__(self, op, arg):\n        self.op = op\n        self.arg = arg\n\n    def as_c_expr(self):\n        if self.op is None:\n            assert isinstance(self.arg, str)\n            return '(_cffi_opcode_t)(%s)' % (self.arg,)\n        classname = CLASS_NAME[self.op]\n        return '_CFFI_OP(_CFFI_OP_%s, %s)' % (classname, self.arg)\n\n    def as_python_bytes(self):\n        if self.op is None and self.arg.isdigit():\n            value = int(self.arg)     # non-negative: '-' not in self.arg\n            if value >= 2**31:\n                raise OverflowError(\"cannot emit %r: limited to 2**31-1\"\n                                    % (self.arg,))\n            return format_four_bytes(value)\n        if isinstance(self.arg, str):\n            raise VerificationError(\"cannot emit to Python: %r\" % (self.arg,))\n        return format_four_bytes((self.arg << 8) | self.op)\n\n    def __str__(self):\n        classname = CLASS_NAME.get(self.op, self.op)\n        return '(%s %s)' % (classname, self.arg)\n\ndef format_four_bytes(num):\n    return '\\\\x%02X\\\\x%02X\\\\x%02X\\\\x%02X' % (\n        (num >> 24) & 0xFF,\n        (num >> 16) & 0xFF,\n        (num >>  8) & 0xFF,\n        (num      ) & 0xFF)\n\nOP_PRIMITIVE       = 1\nOP_POINTER         = 3\nOP_ARRAY           = 5\nOP_OPEN_ARRAY      = 7\nOP_STRUCT_UNION    = 9\nOP_ENUM            = 11\nOP_FUNCTION        = 13\nOP_FUNCTION_END    = 15\nOP_NOOP            = 17\nOP_BITFIELD        = 19\nOP_TYPENAME        = 21\nOP_CPYTHON_BLTN_V  = 23   # varargs\nOP_CPYTHON_BLTN_N  = 25   # noargs\nOP_CPYTHON_BLTN_O  = 27   # O  (i.e. a single arg)\nOP_CONSTANT        = 29\nOP_CONSTANT_INT    = 31\nOP_GLOBAL_VAR      = 33\nOP_DLOPEN_FUNC     = 35\nOP_DLOPEN_CONST    = 37\nOP_GLOBAL_VAR_F    = 39\nOP_EXTERN_PYTHON   = 41\n\nPRIM_VOID          = 0\nPRIM_BOOL          = 1\nPRIM_CHAR          = 2\nPRIM_SCHAR         = 3\nPRIM_UCHAR         = 4\nPRIM_SHORT         = 5\nPRIM_USHORT        = 6\nPRIM_INT           = 7\nPRIM_UINT          = 8\nPRIM_LONG          = 9\nPRIM_ULONG         = 10\nPRIM_LONGLONG      = 11\nPRIM_ULONGLONG     = 12\nPRIM_FLOAT         = 13\nPRIM_DOUBLE        = 14\nPRIM_LONGDOUBLE    = 15\n\nPRIM_WCHAR         = 16\nPRIM_INT8          = 17\nPRIM_UINT8         = 18\nPRIM_INT16         = 19\nPRIM_UINT16        = 20\nPRIM_INT32         = 21\nPRIM_UINT32        = 22\nPRIM_INT64         = 23\nPRIM_UINT64        = 24\nPRIM_INTPTR        = 25\nPRIM_UINTPTR       = 26\nPRIM_PTRDIFF       = 27\nPRIM_SIZE          = 28\nPRIM_SSIZE         = 29\nPRIM_INT_LEAST8    = 30\nPRIM_UINT_LEAST8   = 31\nPRIM_INT_LEAST16   = 32\nPRIM_UINT_LEAST16  = 33\nPRIM_INT_LEAST32   = 34\nPRIM_UINT_LEAST32  = 35\nPRIM_INT_LEAST64   = 36\nPRIM_UINT_LEAST64  = 37\nPRIM_INT_FAST8     = 38\nPRIM_UINT_FAST8    = 39\nPRIM_INT_FAST16    = 40\nPRIM_UINT_FAST16   = 41\nPRIM_INT_FAST32    = 42\nPRIM_UINT_FAST32   = 43\nPRIM_INT_FAST64    = 44\nPRIM_UINT_FAST64   = 45\nPRIM_INTMAX        = 46\nPRIM_UINTMAX       = 47\nPRIM_FLOATCOMPLEX  = 48\nPRIM_DOUBLECOMPLEX = 49\nPRIM_CHAR16        = 50\nPRIM_CHAR32        = 51\n\n_NUM_PRIM          = 52\n_UNKNOWN_PRIM          = -1\n_UNKNOWN_FLOAT_PRIM    = -2\n_UNKNOWN_LONG_DOUBLE   = -3\n\n_IO_FILE_STRUCT        = -1\n\nPRIMITIVE_TO_INDEX = {\n    'char':               PRIM_CHAR,\n    'short':              PRIM_SHORT,\n    'int':                PRIM_INT,\n    'long':               PRIM_LONG,\n    'long long':          PRIM_LONGLONG,\n    'signed char':        PRIM_SCHAR,\n    'unsigned char':      PRIM_UCHAR,\n    'unsigned short':     PRIM_USHORT,\n    'unsigned int':       PRIM_UINT,\n    'unsigned long':      PRIM_ULONG,\n    'unsigned long long': PRIM_ULONGLONG,\n    'float':              PRIM_FLOAT,\n    'double':             PRIM_DOUBLE,\n    'long double':        PRIM_LONGDOUBLE,\n    '_cffi_float_complex_t': PRIM_FLOATCOMPLEX,\n    '_cffi_double_complex_t': PRIM_DOUBLECOMPLEX,\n    '_Bool':              PRIM_BOOL,\n    'wchar_t':            PRIM_WCHAR,\n    'char16_t':           PRIM_CHAR16,\n    'char32_t':           PRIM_CHAR32,\n    'int8_t':             PRIM_INT8,\n    'uint8_t':            PRIM_UINT8,\n    'int16_t':            PRIM_INT16,\n    'uint16_t':           PRIM_UINT16,\n    'int32_t':            PRIM_INT32,\n    'uint32_t':           PRIM_UINT32,\n    'int64_t':            PRIM_INT64,\n    'uint64_t':           PRIM_UINT64,\n    'intptr_t':           PRIM_INTPTR,\n    'uintptr_t':          PRIM_UINTPTR,\n    'ptrdiff_t':          PRIM_PTRDIFF,\n    'size_t':             PRIM_SIZE,\n    'ssize_t':            PRIM_SSIZE,\n    'int_least8_t':       PRIM_INT_LEAST8,\n    'uint_least8_t':      PRIM_UINT_LEAST8,\n    'int_least16_t':      PRIM_INT_LEAST16,\n    'uint_least16_t':     PRIM_UINT_LEAST16,\n    'int_least32_t':      PRIM_INT_LEAST32,\n    'uint_least32_t':     PRIM_UINT_LEAST32,\n    'int_least64_t':      PRIM_INT_LEAST64,\n    'uint_least64_t':     PRIM_UINT_LEAST64,\n    'int_fast8_t':        PRIM_INT_FAST8,\n    'uint_fast8_t':       PRIM_UINT_FAST8,\n    'int_fast16_t':       PRIM_INT_FAST16,\n    'uint_fast16_t':      PRIM_UINT_FAST16,\n    'int_fast32_t':       PRIM_INT_FAST32,\n    'uint_fast32_t':      PRIM_UINT_FAST32,\n    'int_fast64_t':       PRIM_INT_FAST64,\n    'uint_fast64_t':      PRIM_UINT_FAST64,\n    'intmax_t':           PRIM_INTMAX,\n    'uintmax_t':          PRIM_UINTMAX,\n    }\n\nF_UNION         = 0x01\nF_CHECK_FIELDS  = 0x02\nF_PACKED        = 0x04\nF_EXTERNAL      = 0x08\nF_OPAQUE        = 0x10\n\nG_FLAGS = dict([('_CFFI_' + _key, globals()[_key])\n                for _key in ['F_UNION', 'F_CHECK_FIELDS', 'F_PACKED',\n                             'F_EXTERNAL', 'F_OPAQUE']])\n\nCLASS_NAME = {}\nfor _name, _value in list(globals().items()):\n    if _name.startswith('OP_') and isinstance(_value, int):\n        CLASS_NAME[_value] = _name[3:]\n", "src/cffi/verifier.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys, os, binascii, shutil, io\nfrom . import __version_verifier_modules__\nfrom . import ffiplatform\nfrom .error import VerificationError\n\nif sys.version_info >= (3, 3):\n    import importlib.machinery\n    def _extension_suffixes():\n        return importlib.machinery.EXTENSION_SUFFIXES[:]\nelse:\n    import imp\n    def _extension_suffixes():\n        return [suffix for suffix, _, type in imp.get_suffixes()\n                if type == imp.C_EXTENSION]\n\n\nif sys.version_info >= (3,):\n    NativeIO = io.StringIO\nelse:\n    class NativeIO(io.BytesIO):\n        def write(self, s):\n            if isinstance(s, unicode):\n                s = s.encode('ascii')\n            super(NativeIO, self).write(s)\n\n\nclass Verifier(object):\n\n    def __init__(self, ffi, preamble, tmpdir=None, modulename=None,\n                 ext_package=None, tag='', force_generic_engine=False,\n                 source_extension='.c', flags=None, relative_to=None, **kwds):\n        if ffi._parser._uses_new_feature:\n            raise VerificationError(\n                \"feature not supported with ffi.verify(), but only \"\n                \"with ffi.set_source(): %s\" % (ffi._parser._uses_new_feature,))\n        self.ffi = ffi\n        self.preamble = preamble\n        if not modulename:\n            flattened_kwds = ffiplatform.flatten(kwds)\n        vengine_class = _locate_engine_class(ffi, force_generic_engine)\n        self._vengine = vengine_class(self)\n        self._vengine.patch_extension_kwds(kwds)\n        self.flags = flags\n        self.kwds = self.make_relative_to(kwds, relative_to)\n        #\n        if modulename:\n            if tag:\n                raise TypeError(\"can't specify both 'modulename' and 'tag'\")\n        else:\n            key = '\\x00'.join(['%d.%d' % sys.version_info[:2],\n                               __version_verifier_modules__,\n                               preamble, flattened_kwds] +\n                              ffi._cdefsources)\n            if sys.version_info >= (3,):\n                key = key.encode('utf-8')\n            k1 = hex(binascii.crc32(key[0::2]) & 0xffffffff)\n            k1 = k1.lstrip('0x').rstrip('L')\n            k2 = hex(binascii.crc32(key[1::2]) & 0xffffffff)\n            k2 = k2.lstrip('0').rstrip('L')\n            modulename = '_cffi_%s_%s%s%s' % (tag, self._vengine._class_key,\n                                              k1, k2)\n        suffix = _get_so_suffixes()[0]\n        self.tmpdir = tmpdir or _caller_dir_pycache()\n        self.sourcefilename = os.path.join(self.tmpdir, modulename + source_extension)\n        self.modulefilename = os.path.join(self.tmpdir, modulename + suffix)\n        self.ext_package = ext_package\n        self._has_source = False\n        self._has_module = False\n\n    def write_source(self, file=None):\n        \"\"\"Write the C source code.  It is produced in 'self.sourcefilename',\n        which can be tweaked beforehand.\"\"\"\n        with self.ffi._lock:\n            if self._has_source and file is None:\n                raise VerificationError(\n                    \"source code already written\")\n            self._write_source(file)\n\n    def compile_module(self):\n        \"\"\"Write the C source code (if not done already) and compile it.\n        This produces a dynamic link library in 'self.modulefilename'.\"\"\"\n        with self.ffi._lock:\n            if self._has_module:\n                raise VerificationError(\"module already compiled\")\n            if not self._has_source:\n                self._write_source()\n            self._compile_module()\n\n    def load_library(self):\n        \"\"\"Get a C module from this Verifier instance.\n        Returns an instance of a FFILibrary class that behaves like the\n        objects returned by ffi.dlopen(), but that delegates all\n        operations to the C module.  If necessary, the C code is written\n        and compiled first.\n        \"\"\"\n        with self.ffi._lock:\n            if not self._has_module:\n                self._locate_module()\n                if not self._has_module:\n                    if not self._has_source:\n                        self._write_source()\n                    self._compile_module()\n            return self._load_library()\n\n    def get_module_name(self):\n        basename = os.path.basename(self.modulefilename)\n        # kill both the .so extension and the other .'s, as introduced\n        # by Python 3: 'basename.cpython-33m.so'\n        basename = basename.split('.', 1)[0]\n        # and the _d added in Python 2 debug builds --- but try to be\n        # conservative and not kill a legitimate _d\n        if basename.endswith('_d') and hasattr(sys, 'gettotalrefcount'):\n            basename = basename[:-2]\n        return basename\n\n    def get_extension(self):\n        if not self._has_source:\n            with self.ffi._lock:\n                if not self._has_source:\n                    self._write_source()\n        sourcename = ffiplatform.maybe_relative_path(self.sourcefilename)\n        modname = self.get_module_name()\n        return ffiplatform.get_extension(sourcename, modname, **self.kwds)\n\n    def generates_python_module(self):\n        return self._vengine._gen_python_module\n\n    def make_relative_to(self, kwds, relative_to):\n        if relative_to and os.path.dirname(relative_to):\n            dirname = os.path.dirname(relative_to)\n            kwds = kwds.copy()\n            for key in ffiplatform.LIST_OF_FILE_NAMES:\n                if key in kwds:\n                    lst = kwds[key]\n                    if not isinstance(lst, (list, tuple)):\n                        raise TypeError(\"keyword '%s' should be a list or tuple\"\n                                        % (key,))\n                    lst = [os.path.join(dirname, fn) for fn in lst]\n                    kwds[key] = lst\n        return kwds\n\n    # ----------\n\n    def _locate_module(self):\n        if not os.path.isfile(self.modulefilename):\n            if self.ext_package:\n                try:\n                    pkg = __import__(self.ext_package, None, None, ['__doc__'])\n                except ImportError:\n                    return      # cannot import the package itself, give up\n                    # (e.g. it might be called differently before installation)\n                path = pkg.__path__\n            else:\n                path = None\n            filename = self._vengine.find_module(self.get_module_name(), path,\n                                                 _get_so_suffixes())\n            if filename is None:\n                return\n            self.modulefilename = filename\n        self._vengine.collect_types()\n        self._has_module = True\n\n    def _write_source_to(self, file):\n        self._vengine._f = file\n        try:\n            self._vengine.write_source_to_f()\n        finally:\n            del self._vengine._f\n\n    def _write_source(self, file=None):\n        if file is not None:\n            self._write_source_to(file)\n        else:\n            # Write our source file to an in memory file.\n            f = NativeIO()\n            self._write_source_to(f)\n            source_data = f.getvalue()\n\n            # Determine if this matches the current file\n            if os.path.exists(self.sourcefilename):\n                with open(self.sourcefilename, \"r\") as fp:\n                    needs_written = not (fp.read() == source_data)\n            else:\n                needs_written = True\n\n            # Actually write the file out if it doesn't match\n            if needs_written:\n                _ensure_dir(self.sourcefilename)\n                with open(self.sourcefilename, \"w\") as fp:\n                    fp.write(source_data)\n\n            # Set this flag\n            self._has_source = True\n\n    def _compile_module(self):\n        # compile this C source\n        tmpdir = os.path.dirname(self.sourcefilename)\n        outputfilename = ffiplatform.compile(tmpdir, self.get_extension())\n        try:\n            same = ffiplatform.samefile(outputfilename, self.modulefilename)\n        except OSError:\n            same = False\n        if not same:\n            _ensure_dir(self.modulefilename)\n            shutil.move(outputfilename, self.modulefilename)\n        self._has_module = True\n\n    def _load_library(self):\n        assert self._has_module\n        if self.flags is not None:\n            return self._vengine.load_library(self.flags)\n        else:\n            return self._vengine.load_library()\n\n# ____________________________________________________________\n\n_FORCE_GENERIC_ENGINE = False      # for tests\n\ndef _locate_engine_class(ffi, force_generic_engine):\n    if _FORCE_GENERIC_ENGINE:\n        force_generic_engine = True\n    if not force_generic_engine:\n        if '__pypy__' in sys.builtin_module_names:\n            force_generic_engine = True\n        else:\n            try:\n                import _cffi_backend\n            except ImportError:\n                _cffi_backend = '?'\n            if ffi._backend is not _cffi_backend:\n                force_generic_engine = True\n    if force_generic_engine:\n        from . import vengine_gen\n        return vengine_gen.VGenericEngine\n    else:\n        from . import vengine_cpy\n        return vengine_cpy.VCPythonEngine\n\n# ____________________________________________________________\n\n_TMPDIR = None\n\ndef _caller_dir_pycache():\n    if _TMPDIR:\n        return _TMPDIR\n    result = os.environ.get('CFFI_TMPDIR')\n    if result:\n        return result\n    filename = sys._getframe(2).f_code.co_filename\n    return os.path.abspath(os.path.join(os.path.dirname(filename),\n                           '__pycache__'))\n\ndef set_tmpdir(dirname):\n    \"\"\"Set the temporary directory to use instead of __pycache__.\"\"\"\n    global _TMPDIR\n    _TMPDIR = dirname\n\ndef cleanup_tmpdir(tmpdir=None, keep_so=False):\n    \"\"\"Clean up the temporary directory by removing all files in it\n    called `_cffi_*.{c,so}` as well as the `build` subdirectory.\"\"\"\n    tmpdir = tmpdir or _caller_dir_pycache()\n    try:\n        filelist = os.listdir(tmpdir)\n    except OSError:\n        return\n    if keep_so:\n        suffix = '.c'   # only remove .c files\n    else:\n        suffix = _get_so_suffixes()[0].lower()\n    for fn in filelist:\n        if fn.lower().startswith('_cffi_') and (\n                fn.lower().endswith(suffix) or fn.lower().endswith('.c')):\n            try:\n                os.unlink(os.path.join(tmpdir, fn))\n            except OSError:\n                pass\n    clean_dir = [os.path.join(tmpdir, 'build')]\n    for dir in clean_dir:\n        try:\n            for fn in os.listdir(dir):\n                fn = os.path.join(dir, fn)\n                if os.path.isdir(fn):\n                    clean_dir.append(fn)\n                else:\n                    os.unlink(fn)\n        except OSError:\n            pass\n\ndef _get_so_suffixes():\n    suffixes = _extension_suffixes()\n    if not suffixes:\n        # bah, no C_EXTENSION available.  Occurs on pypy without cpyext\n        if sys.platform == 'win32':\n            suffixes = [\".pyd\"]\n        else:\n            suffixes = [\".so\"]\n\n    return suffixes\n\ndef _ensure_dir(filename):\n    dirname = os.path.dirname(filename)\n    if dirname and not os.path.isdir(dirname):\n        os.makedirs(dirname)\n", "src/cffi/model.py": "import types\nimport weakref\n\nfrom .lock import allocate_lock\nfrom .error import CDefError, VerificationError, VerificationMissing\n\n# type qualifiers\nQ_CONST    = 0x01\nQ_RESTRICT = 0x02\nQ_VOLATILE = 0x04\n\ndef qualify(quals, replace_with):\n    if quals & Q_CONST:\n        replace_with = ' const ' + replace_with.lstrip()\n    if quals & Q_VOLATILE:\n        replace_with = ' volatile ' + replace_with.lstrip()\n    if quals & Q_RESTRICT:\n        # It seems that __restrict is supported by gcc and msvc.\n        # If you hit some different compiler, add a #define in\n        # _cffi_include.h for it (and in its copies, documented there)\n        replace_with = ' __restrict ' + replace_with.lstrip()\n    return replace_with\n\n\nclass BaseTypeByIdentity(object):\n    is_array_type = False\n    is_raw_function = False\n\n    def get_c_name(self, replace_with='', context='a C file', quals=0):\n        result = self.c_name_with_marker\n        assert result.count('&') == 1\n        # some logic duplication with ffi.getctype()... :-(\n        replace_with = replace_with.strip()\n        if replace_with:\n            if replace_with.startswith('*') and '&[' in result:\n                replace_with = '(%s)' % replace_with\n            elif not replace_with[0] in '[(':\n                replace_with = ' ' + replace_with\n        replace_with = qualify(quals, replace_with)\n        result = result.replace('&', replace_with)\n        if '$' in result:\n            raise VerificationError(\n                \"cannot generate '%s' in %s: unknown type name\"\n                % (self._get_c_name(), context))\n        return result\n\n    def _get_c_name(self):\n        return self.c_name_with_marker.replace('&', '')\n\n    def has_c_name(self):\n        return '$' not in self._get_c_name()\n\n    def is_integer_type(self):\n        return False\n\n    def get_cached_btype(self, ffi, finishlist, can_delay=False):\n        try:\n            BType = ffi._cached_btypes[self]\n        except KeyError:\n            BType = self.build_backend_type(ffi, finishlist)\n            BType2 = ffi._cached_btypes.setdefault(self, BType)\n            assert BType2 is BType\n        return BType\n\n    def __repr__(self):\n        return '<%s>' % (self._get_c_name(),)\n\n    def _get_items(self):\n        return [(name, getattr(self, name)) for name in self._attrs_]\n\n\nclass BaseType(BaseTypeByIdentity):\n\n    def __eq__(self, other):\n        return (self.__class__ == other.__class__ and\n                self._get_items() == other._get_items())\n\n    def __ne__(self, other):\n        return not self == other\n\n    def __hash__(self):\n        return hash((self.__class__, tuple(self._get_items())))\n\n\nclass VoidType(BaseType):\n    _attrs_ = ()\n\n    def __init__(self):\n        self.c_name_with_marker = 'void&'\n\n    def build_backend_type(self, ffi, finishlist):\n        return global_cache(self, ffi, 'new_void_type')\n\nvoid_type = VoidType()\n\n\nclass BasePrimitiveType(BaseType):\n    def is_complex_type(self):\n        return False\n\n\nclass PrimitiveType(BasePrimitiveType):\n    _attrs_ = ('name',)\n\n    ALL_PRIMITIVE_TYPES = {\n        'char':               'c',\n        'short':              'i',\n        'int':                'i',\n        'long':               'i',\n        'long long':          'i',\n        'signed char':        'i',\n        'unsigned char':      'i',\n        'unsigned short':     'i',\n        'unsigned int':       'i',\n        'unsigned long':      'i',\n        'unsigned long long': 'i',\n        'float':              'f',\n        'double':             'f',\n        'long double':        'f',\n        '_cffi_float_complex_t': 'j',\n        '_cffi_double_complex_t': 'j',\n        '_Bool':              'i',\n        # the following types are not primitive in the C sense\n        'wchar_t':            'c',\n        'char16_t':           'c',\n        'char32_t':           'c',\n        'int8_t':             'i',\n        'uint8_t':            'i',\n        'int16_t':            'i',\n        'uint16_t':           'i',\n        'int32_t':            'i',\n        'uint32_t':           'i',\n        'int64_t':            'i',\n        'uint64_t':           'i',\n        'int_least8_t':       'i',\n        'uint_least8_t':      'i',\n        'int_least16_t':      'i',\n        'uint_least16_t':     'i',\n        'int_least32_t':      'i',\n        'uint_least32_t':     'i',\n        'int_least64_t':      'i',\n        'uint_least64_t':     'i',\n        'int_fast8_t':        'i',\n        'uint_fast8_t':       'i',\n        'int_fast16_t':       'i',\n        'uint_fast16_t':      'i',\n        'int_fast32_t':       'i',\n        'uint_fast32_t':      'i',\n        'int_fast64_t':       'i',\n        'uint_fast64_t':      'i',\n        'intptr_t':           'i',\n        'uintptr_t':          'i',\n        'intmax_t':           'i',\n        'uintmax_t':          'i',\n        'ptrdiff_t':          'i',\n        'size_t':             'i',\n        'ssize_t':            'i',\n        }\n\n    def __init__(self, name):\n        assert name in self.ALL_PRIMITIVE_TYPES\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n    def is_char_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'c'\n    def is_integer_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'i'\n    def is_float_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'f'\n    def is_complex_type(self):\n        return self.ALL_PRIMITIVE_TYPES[self.name] == 'j'\n\n    def build_backend_type(self, ffi, finishlist):\n        return global_cache(self, ffi, 'new_primitive_type', self.name)\n\n\nclass UnknownIntegerType(BasePrimitiveType):\n    _attrs_ = ('name',)\n\n    def __init__(self, name):\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n    def is_integer_type(self):\n        return True\n\n    def build_backend_type(self, ffi, finishlist):\n        raise NotImplementedError(\"integer type '%s' can only be used after \"\n                                  \"compilation\" % self.name)\n\nclass UnknownFloatType(BasePrimitiveType):\n    _attrs_ = ('name', )\n\n    def __init__(self, name):\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n    def build_backend_type(self, ffi, finishlist):\n        raise NotImplementedError(\"float type '%s' can only be used after \"\n                                  \"compilation\" % self.name)\n\n\nclass BaseFunctionType(BaseType):\n    _attrs_ = ('args', 'result', 'ellipsis', 'abi')\n\n    def __init__(self, args, result, ellipsis, abi=None):\n        self.args = args\n        self.result = result\n        self.ellipsis = ellipsis\n        self.abi = abi\n        #\n        reprargs = [arg._get_c_name() for arg in self.args]\n        if self.ellipsis:\n            reprargs.append('...')\n        reprargs = reprargs or ['void']\n        replace_with = self._base_pattern % (', '.join(reprargs),)\n        if abi is not None:\n            replace_with = replace_with[:1] + abi + ' ' + replace_with[1:]\n        self.c_name_with_marker = (\n            self.result.c_name_with_marker.replace('&', replace_with))\n\n\nclass RawFunctionType(BaseFunctionType):\n    # Corresponds to a C type like 'int(int)', which is the C type of\n    # a function, but not a pointer-to-function.  The backend has no\n    # notion of such a type; it's used temporarily by parsing.\n    _base_pattern = '(&)(%s)'\n    is_raw_function = True\n\n    def build_backend_type(self, ffi, finishlist):\n        raise CDefError(\"cannot render the type %r: it is a function \"\n                        \"type, not a pointer-to-function type\" % (self,))\n\n    def as_function_pointer(self):\n        return FunctionPtrType(self.args, self.result, self.ellipsis, self.abi)\n\n\nclass FunctionPtrType(BaseFunctionType):\n    _base_pattern = '(*&)(%s)'\n\n    def build_backend_type(self, ffi, finishlist):\n        result = self.result.get_cached_btype(ffi, finishlist)\n        args = []\n        for tp in self.args:\n            args.append(tp.get_cached_btype(ffi, finishlist))\n        abi_args = ()\n        if self.abi == \"__stdcall\":\n            if not self.ellipsis:    # __stdcall ignored for variadic funcs\n                try:\n                    abi_args = (ffi._backend.FFI_STDCALL,)\n                except AttributeError:\n                    pass\n        return global_cache(self, ffi, 'new_function_type',\n                            tuple(args), result, self.ellipsis, *abi_args)\n\n    def as_raw_function(self):\n        return RawFunctionType(self.args, self.result, self.ellipsis, self.abi)\n\n\nclass PointerType(BaseType):\n    _attrs_ = ('totype', 'quals')\n\n    def __init__(self, totype, quals=0):\n        self.totype = totype\n        self.quals = quals\n        extra = \" *&\"\n        if totype.is_array_type:\n            extra = \"(%s)\" % (extra.lstrip(),)\n        extra = qualify(quals, extra)\n        self.c_name_with_marker = totype.c_name_with_marker.replace('&', extra)\n\n    def build_backend_type(self, ffi, finishlist):\n        BItem = self.totype.get_cached_btype(ffi, finishlist, can_delay=True)\n        return global_cache(self, ffi, 'new_pointer_type', BItem)\n\nvoidp_type = PointerType(void_type)\n\ndef ConstPointerType(totype):\n    return PointerType(totype, Q_CONST)\n\nconst_voidp_type = ConstPointerType(void_type)\n\n\nclass NamedPointerType(PointerType):\n    _attrs_ = ('totype', 'name')\n\n    def __init__(self, totype, name, quals=0):\n        PointerType.__init__(self, totype, quals)\n        self.name = name\n        self.c_name_with_marker = name + '&'\n\n\nclass ArrayType(BaseType):\n    _attrs_ = ('item', 'length')\n    is_array_type = True\n\n    def __init__(self, item, length):\n        self.item = item\n        self.length = length\n        #\n        if length is None:\n            brackets = '&[]'\n        elif length == '...':\n            brackets = '&[/*...*/]'\n        else:\n            brackets = '&[%s]' % length\n        self.c_name_with_marker = (\n            self.item.c_name_with_marker.replace('&', brackets))\n\n    def length_is_unknown(self):\n        return isinstance(self.length, str)\n\n    def resolve_length(self, newlength):\n        return ArrayType(self.item, newlength)\n\n    def build_backend_type(self, ffi, finishlist):\n        if self.length_is_unknown():\n            raise CDefError(\"cannot render the type %r: unknown length\" %\n                            (self,))\n        self.item.get_cached_btype(ffi, finishlist)   # force the item BType\n        BPtrItem = PointerType(self.item).get_cached_btype(ffi, finishlist)\n        return global_cache(self, ffi, 'new_array_type', BPtrItem, self.length)\n\nchar_array_type = ArrayType(PrimitiveType('char'), None)\n\n\nclass StructOrUnionOrEnum(BaseTypeByIdentity):\n    _attrs_ = ('name',)\n    forcename = None\n\n    def build_c_name_with_marker(self):\n        name = self.forcename or '%s %s' % (self.kind, self.name)\n        self.c_name_with_marker = name + '&'\n\n    def force_the_name(self, forcename):\n        self.forcename = forcename\n        self.build_c_name_with_marker()\n\n    def get_official_name(self):\n        assert self.c_name_with_marker.endswith('&')\n        return self.c_name_with_marker[:-1]\n\n\nclass StructOrUnion(StructOrUnionOrEnum):\n    fixedlayout = None\n    completed = 0\n    partial = False\n    packed = 0\n\n    def __init__(self, name, fldnames, fldtypes, fldbitsize, fldquals=None):\n        self.name = name\n        self.fldnames = fldnames\n        self.fldtypes = fldtypes\n        self.fldbitsize = fldbitsize\n        self.fldquals = fldquals\n        self.build_c_name_with_marker()\n\n    def anonymous_struct_fields(self):\n        if self.fldtypes is not None:\n            for name, type in zip(self.fldnames, self.fldtypes):\n                if name == '' and isinstance(type, StructOrUnion):\n                    yield type\n\n    def enumfields(self, expand_anonymous_struct_union=True):\n        fldquals = self.fldquals\n        if fldquals is None:\n            fldquals = (0,) * len(self.fldnames)\n        for name, type, bitsize, quals in zip(self.fldnames, self.fldtypes,\n                                              self.fldbitsize, fldquals):\n            if (name == '' and isinstance(type, StructOrUnion)\n                    and expand_anonymous_struct_union):\n                # nested anonymous struct/union\n                for result in type.enumfields():\n                    yield result\n            else:\n                yield (name, type, bitsize, quals)\n\n    def force_flatten(self):\n        # force the struct or union to have a declaration that lists\n        # directly all fields returned by enumfields(), flattening\n        # nested anonymous structs/unions.\n        names = []\n        types = []\n        bitsizes = []\n        fldquals = []\n        for name, type, bitsize, quals in self.enumfields():\n            names.append(name)\n            types.append(type)\n            bitsizes.append(bitsize)\n            fldquals.append(quals)\n        self.fldnames = tuple(names)\n        self.fldtypes = tuple(types)\n        self.fldbitsize = tuple(bitsizes)\n        self.fldquals = tuple(fldquals)\n\n    def get_cached_btype(self, ffi, finishlist, can_delay=False):\n        BType = StructOrUnionOrEnum.get_cached_btype(self, ffi, finishlist,\n                                                     can_delay)\n        if not can_delay:\n            self.finish_backend_type(ffi, finishlist)\n        return BType\n\n    def finish_backend_type(self, ffi, finishlist):\n        if self.completed:\n            if self.completed != 2:\n                raise NotImplementedError(\"recursive structure declaration \"\n                                          \"for '%s'\" % (self.name,))\n            return\n        BType = ffi._cached_btypes[self]\n        #\n        self.completed = 1\n        #\n        if self.fldtypes is None:\n            pass    # not completing it: it's an opaque struct\n            #\n        elif self.fixedlayout is None:\n            fldtypes = [tp.get_cached_btype(ffi, finishlist)\n                        for tp in self.fldtypes]\n            lst = list(zip(self.fldnames, fldtypes, self.fldbitsize))\n            extra_flags = ()\n            if self.packed:\n                if self.packed == 1:\n                    extra_flags = (8,)    # SF_PACKED\n                else:\n                    extra_flags = (0, self.packed)\n            ffi._backend.complete_struct_or_union(BType, lst, self,\n                                                  -1, -1, *extra_flags)\n            #\n        else:\n            fldtypes = []\n            fieldofs, fieldsize, totalsize, totalalignment = self.fixedlayout\n            for i in range(len(self.fldnames)):\n                fsize = fieldsize[i]\n                ftype = self.fldtypes[i]\n                #\n                if isinstance(ftype, ArrayType) and ftype.length_is_unknown():\n                    # fix the length to match the total size\n                    BItemType = ftype.item.get_cached_btype(ffi, finishlist)\n                    nlen, nrest = divmod(fsize, ffi.sizeof(BItemType))\n                    if nrest != 0:\n                        self._verification_error(\n                            \"field '%s.%s' has a bogus size?\" % (\n                            self.name, self.fldnames[i] or '{}'))\n                    ftype = ftype.resolve_length(nlen)\n                    self.fldtypes = (self.fldtypes[:i] + (ftype,) +\n                                     self.fldtypes[i+1:])\n                #\n                BFieldType = ftype.get_cached_btype(ffi, finishlist)\n                if isinstance(ftype, ArrayType) and ftype.length is None:\n                    assert fsize == 0\n                else:\n                    bitemsize = ffi.sizeof(BFieldType)\n                    if bitemsize != fsize:\n                        self._verification_error(\n                            \"field '%s.%s' is declared as %d bytes, but is \"\n                            \"really %d bytes\" % (self.name,\n                                                 self.fldnames[i] or '{}',\n                                                 bitemsize, fsize))\n                fldtypes.append(BFieldType)\n            #\n            lst = list(zip(self.fldnames, fldtypes, self.fldbitsize, fieldofs))\n            ffi._backend.complete_struct_or_union(BType, lst, self,\n                                                  totalsize, totalalignment)\n        self.completed = 2\n\n    def _verification_error(self, msg):\n        raise VerificationError(msg)\n\n    def check_not_partial(self):\n        if self.partial and self.fixedlayout is None:\n            raise VerificationMissing(self._get_c_name())\n\n    def build_backend_type(self, ffi, finishlist):\n        self.check_not_partial()\n        finishlist.append(self)\n        #\n        return global_cache(self, ffi, 'new_%s_type' % self.kind,\n                            self.get_official_name(), key=self)\n\n\nclass StructType(StructOrUnion):\n    kind = 'struct'\n\n\nclass UnionType(StructOrUnion):\n    kind = 'union'\n\n\nclass EnumType(StructOrUnionOrEnum):\n    kind = 'enum'\n    partial = False\n    partial_resolved = False\n\n    def __init__(self, name, enumerators, enumvalues, baseinttype=None):\n        self.name = name\n        self.enumerators = enumerators\n        self.enumvalues = enumvalues\n        self.baseinttype = baseinttype\n        self.build_c_name_with_marker()\n\n    def force_the_name(self, forcename):\n        StructOrUnionOrEnum.force_the_name(self, forcename)\n        if self.forcename is None:\n            name = self.get_official_name()\n            self.forcename = '$' + name.replace(' ', '_')\n\n    def check_not_partial(self):\n        if self.partial and not self.partial_resolved:\n            raise VerificationMissing(self._get_c_name())\n\n    def build_backend_type(self, ffi, finishlist):\n        self.check_not_partial()\n        base_btype = self.build_baseinttype(ffi, finishlist)\n        return global_cache(self, ffi, 'new_enum_type',\n                            self.get_official_name(),\n                            self.enumerators, self.enumvalues,\n                            base_btype, key=self)\n\n    def build_baseinttype(self, ffi, finishlist):\n        if self.baseinttype is not None:\n            return self.baseinttype.get_cached_btype(ffi, finishlist)\n        #\n        if self.enumvalues:\n            smallest_value = min(self.enumvalues)\n            largest_value = max(self.enumvalues)\n        else:\n            import warnings\n            try:\n                # XXX!  The goal is to ensure that the warnings.warn()\n                # will not suppress the warning.  We want to get it\n                # several times if we reach this point several times.\n                __warningregistry__.clear()\n            except NameError:\n                pass\n            warnings.warn(\"%r has no values explicitly defined; \"\n                          \"guessing that it is equivalent to 'unsigned int'\"\n                          % self._get_c_name())\n            smallest_value = largest_value = 0\n        if smallest_value < 0:   # needs a signed type\n            sign = 1\n            candidate1 = PrimitiveType(\"int\")\n            candidate2 = PrimitiveType(\"long\")\n        else:\n            sign = 0\n            candidate1 = PrimitiveType(\"unsigned int\")\n            candidate2 = PrimitiveType(\"unsigned long\")\n        btype1 = candidate1.get_cached_btype(ffi, finishlist)\n        btype2 = candidate2.get_cached_btype(ffi, finishlist)\n        size1 = ffi.sizeof(btype1)\n        size2 = ffi.sizeof(btype2)\n        if (smallest_value >= ((-1) << (8*size1-1)) and\n            largest_value < (1 << (8*size1-sign))):\n            return btype1\n        if (smallest_value >= ((-1) << (8*size2-1)) and\n            largest_value < (1 << (8*size2-sign))):\n            return btype2\n        raise CDefError(\"%s values don't all fit into either 'long' \"\n                        \"or 'unsigned long'\" % self._get_c_name())\n\ndef unknown_type(name, structname=None):\n    if structname is None:\n        structname = '$%s' % name\n    tp = StructType(structname, None, None, None)\n    tp.force_the_name(name)\n    tp.origin = \"unknown_type\"\n    return tp\n\ndef unknown_ptr_type(name, structname=None):\n    if structname is None:\n        structname = '$$%s' % name\n    tp = StructType(structname, None, None, None)\n    return NamedPointerType(tp, name)\n\n\nglobal_lock = allocate_lock()\n_typecache_cffi_backend = weakref.WeakValueDictionary()\n\ndef get_typecache(backend):\n    # returns _typecache_cffi_backend if backend is the _cffi_backend\n    # module, or type(backend).__typecache if backend is an instance of\n    # CTypesBackend (or some FakeBackend class during tests)\n    if isinstance(backend, types.ModuleType):\n        return _typecache_cffi_backend\n    with global_lock:\n        if not hasattr(type(backend), '__typecache'):\n            type(backend).__typecache = weakref.WeakValueDictionary()\n        return type(backend).__typecache\n\ndef global_cache(srctype, ffi, funcname, *args, **kwds):\n    key = kwds.pop('key', (funcname, args))\n    assert not kwds\n    try:\n        return ffi._typecache[key]\n    except KeyError:\n        pass\n    try:\n        res = getattr(ffi._backend, funcname)(*args)\n    except NotImplementedError as e:\n        raise NotImplementedError(\"%s: %r: %s\" % (funcname, srctype, e))\n    # note that setdefault() on WeakValueDictionary is not atomic\n    # and contains a rare bug (http://bugs.python.org/issue19542);\n    # we have to use a lock and do it ourselves\n    cache = ffi._typecache\n    with global_lock:\n        res1 = cache.get(key)\n        if res1 is None:\n            cache[key] = res\n            return res\n        else:\n            return res1\n\ndef pointer_cache(ffi, BType):\n    return global_cache('?', ffi, 'new_pointer_type', BType)\n\ndef attach_exception_info(e, name):\n    if e.args and type(e.args[0]) is str:\n        e.args = ('%s: %s' % (name, e.args[0]),) + e.args[1:]\n", "src/cffi/setuptools_ext.py": "import os\nimport sys\n\ntry:\n    basestring\nexcept NameError:\n    # Python 3.x\n    basestring = str\n\ndef error(msg):\n    from cffi._shimmed_dist_utils import DistutilsSetupError\n    raise DistutilsSetupError(msg)\n\n\ndef execfile(filename, glob):\n    # We use execfile() (here rewritten for Python 3) instead of\n    # __import__() to load the build script.  The problem with\n    # a normal import is that in some packages, the intermediate\n    # __init__.py files may already try to import the file that\n    # we are generating.\n    with open(filename) as f:\n        src = f.read()\n    src += '\\n'      # Python 2.6 compatibility\n    code = compile(src, filename, 'exec')\n    exec(code, glob, glob)\n\n\ndef add_cffi_module(dist, mod_spec):\n    from cffi.api import FFI\n\n    if not isinstance(mod_spec, basestring):\n        error(\"argument to 'cffi_modules=...' must be a str or a list of str,\"\n              \" not %r\" % (type(mod_spec).__name__,))\n    mod_spec = str(mod_spec)\n    try:\n        build_file_name, ffi_var_name = mod_spec.split(':')\n    except ValueError:\n        error(\"%r must be of the form 'path/build.py:ffi_variable'\" %\n              (mod_spec,))\n    if not os.path.exists(build_file_name):\n        ext = ''\n        rewritten = build_file_name.replace('.', '/') + '.py'\n        if os.path.exists(rewritten):\n            ext = ' (rewrite cffi_modules to [%r])' % (\n                rewritten + ':' + ffi_var_name,)\n        error(\"%r does not name an existing file%s\" % (build_file_name, ext))\n\n    mod_vars = {'__name__': '__cffi__', '__file__': build_file_name}\n    execfile(build_file_name, mod_vars)\n\n    try:\n        ffi = mod_vars[ffi_var_name]\n    except KeyError:\n        error(\"%r: object %r not found in module\" % (mod_spec,\n                                                     ffi_var_name))\n    if not isinstance(ffi, FFI):\n        ffi = ffi()      # maybe it's a function instead of directly an ffi\n    if not isinstance(ffi, FFI):\n        error(\"%r is not an FFI instance (got %r)\" % (mod_spec,\n                                                      type(ffi).__name__))\n    if not hasattr(ffi, '_assigned_source'):\n        error(\"%r: the set_source() method was not called\" % (mod_spec,))\n    module_name, source, source_extension, kwds = ffi._assigned_source\n    if ffi._windows_unicode:\n        kwds = kwds.copy()\n        ffi._apply_windows_unicode(kwds)\n\n    if source is None:\n        _add_py_module(dist, ffi, module_name)\n    else:\n        _add_c_module(dist, ffi, module_name, source, source_extension, kwds)\n\ndef _set_py_limited_api(Extension, kwds):\n    \"\"\"\n    Add py_limited_api to kwds if setuptools >= 26 is in use.\n    Do not alter the setting if it already exists.\n    Setuptools takes care of ignoring the flag on Python 2 and PyPy.\n\n    CPython itself should ignore the flag in a debugging version\n    (by not listing .abi3.so in the extensions it supports), but\n    it doesn't so far, creating troubles.  That's why we check\n    for \"not hasattr(sys, 'gettotalrefcount')\" (the 2.7 compatible equivalent\n    of 'd' not in sys.abiflags). (http://bugs.python.org/issue28401)\n\n    On Windows, with CPython <= 3.4, it's better not to use py_limited_api\n    because virtualenv *still* doesn't copy PYTHON3.DLL on these versions.\n    Recently (2020) we started shipping only >= 3.5 wheels, though.  So\n    we'll give it another try and set py_limited_api on Windows >= 3.5.\n    \"\"\"\n    from cffi import recompiler\n\n    if ('py_limited_api' not in kwds and not hasattr(sys, 'gettotalrefcount')\n            and recompiler.USE_LIMITED_API):\n        import setuptools\n        try:\n            setuptools_major_version = int(setuptools.__version__.partition('.')[0])\n            if setuptools_major_version >= 26:\n                kwds['py_limited_api'] = True\n        except ValueError:  # certain development versions of setuptools\n            # If we don't know the version number of setuptools, we\n            # try to set 'py_limited_api' anyway.  At worst, we get a\n            # warning.\n            kwds['py_limited_api'] = True\n    return kwds\n\ndef _add_c_module(dist, ffi, module_name, source, source_extension, kwds):\n    # We are a setuptools extension. Need this build_ext for py_limited_api.\n    from setuptools.command.build_ext import build_ext\n    from cffi._shimmed_dist_utils import Extension, log, mkpath\n    from cffi import recompiler\n\n    allsources = ['$PLACEHOLDER']\n    allsources.extend(kwds.pop('sources', []))\n    kwds = _set_py_limited_api(Extension, kwds)\n    ext = Extension(name=module_name, sources=allsources, **kwds)\n\n    def make_mod(tmpdir, pre_run=None):\n        c_file = os.path.join(tmpdir, module_name + source_extension)\n        log.info(\"generating cffi module %r\" % c_file)\n        mkpath(tmpdir)\n        # a setuptools-only, API-only hook: called with the \"ext\" and \"ffi\"\n        # arguments just before we turn the ffi into C code.  To use it,\n        # subclass the 'distutils.command.build_ext.build_ext' class and\n        # add a method 'def pre_run(self, ext, ffi)'.\n        if pre_run is not None:\n            pre_run(ext, ffi)\n        updated = recompiler.make_c_source(ffi, module_name, source, c_file)\n        if not updated:\n            log.info(\"already up-to-date\")\n        return c_file\n\n    if dist.ext_modules is None:\n        dist.ext_modules = []\n    dist.ext_modules.append(ext)\n\n    base_class = dist.cmdclass.get('build_ext', build_ext)\n    class build_ext_make_mod(base_class):\n        def run(self):\n            if ext.sources[0] == '$PLACEHOLDER':\n                pre_run = getattr(self, 'pre_run', None)\n                ext.sources[0] = make_mod(self.build_temp, pre_run)\n            base_class.run(self)\n    dist.cmdclass['build_ext'] = build_ext_make_mod\n    # NB. multiple runs here will create multiple 'build_ext_make_mod'\n    # classes.  Even in this case the 'build_ext' command should be\n    # run once; but just in case, the logic above does nothing if\n    # called again.\n\n\ndef _add_py_module(dist, ffi, module_name):\n    from setuptools.command.build_py import build_py\n    from setuptools.command.build_ext import build_ext\n    from cffi._shimmed_dist_utils import log, mkpath\n    from cffi import recompiler\n\n    def generate_mod(py_file):\n        log.info(\"generating cffi module %r\" % py_file)\n        mkpath(os.path.dirname(py_file))\n        updated = recompiler.make_py_source(ffi, module_name, py_file)\n        if not updated:\n            log.info(\"already up-to-date\")\n\n    base_class = dist.cmdclass.get('build_py', build_py)\n    class build_py_make_mod(base_class):\n        def run(self):\n            base_class.run(self)\n            module_path = module_name.split('.')\n            module_path[-1] += '.py'\n            generate_mod(os.path.join(self.build_lib, *module_path))\n        def get_source_files(self):\n            # This is called from 'setup.py sdist' only.  Exclude\n            # the generate .py module in this case.\n            saved_py_modules = self.py_modules\n            try:\n                if saved_py_modules:\n                    self.py_modules = [m for m in saved_py_modules\n                                         if m != module_name]\n                return base_class.get_source_files(self)\n            finally:\n                self.py_modules = saved_py_modules\n    dist.cmdclass['build_py'] = build_py_make_mod\n\n    # distutils and setuptools have no notion I could find of a\n    # generated python module.  If we don't add module_name to\n    # dist.py_modules, then things mostly work but there are some\n    # combination of options (--root and --record) that will miss\n    # the module.  So we add it here, which gives a few apparently\n    # harmless warnings about not finding the file outside the\n    # build directory.\n    # Then we need to hack more in get_source_files(); see above.\n    if dist.py_modules is None:\n        dist.py_modules = []\n    dist.py_modules.append(module_name)\n\n    # the following is only for \"build_ext -i\"\n    base_class_2 = dist.cmdclass.get('build_ext', build_ext)\n    class build_ext_make_mod(base_class_2):\n        def run(self):\n            base_class_2.run(self)\n            if self.inplace:\n                # from get_ext_fullpath() in distutils/command/build_ext.py\n                module_path = module_name.split('.')\n                package = '.'.join(module_path[:-1])\n                build_py = self.get_finalized_command('build_py')\n                package_dir = build_py.get_package_dir(package)\n                file_name = module_path[-1] + '.py'\n                generate_mod(os.path.join(package_dir, file_name))\n    dist.cmdclass['build_ext'] = build_ext_make_mod\n\ndef cffi_modules(dist, attr, value):\n    assert attr == 'cffi_modules'\n    if isinstance(value, basestring):\n        value = [value]\n\n    for cffi_module in value:\n        add_cffi_module(dist, cffi_module)\n", "src/cffi/vengine_gen.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys, os\nimport types\n\nfrom . import model\nfrom .error import VerificationError\n\n\nclass VGenericEngine(object):\n    _class_key = 'g'\n    _gen_python_module = False\n\n    def __init__(self, verifier):\n        self.verifier = verifier\n        self.ffi = verifier.ffi\n        self.export_symbols = []\n        self._struct_pending_verification = {}\n\n    def patch_extension_kwds(self, kwds):\n        # add 'export_symbols' to the dictionary.  Note that we add the\n        # list before filling it.  When we fill it, it will thus also show\n        # up in kwds['export_symbols'].\n        kwds.setdefault('export_symbols', self.export_symbols)\n\n    def find_module(self, module_name, path, so_suffixes):\n        for so_suffix in so_suffixes:\n            basename = module_name + so_suffix\n            if path is None:\n                path = sys.path\n            for dirname in path:\n                filename = os.path.join(dirname, basename)\n                if os.path.isfile(filename):\n                    return filename\n\n    def collect_types(self):\n        pass      # not needed in the generic engine\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def write_source_to_f(self):\n        prnt = self._prnt\n        # first paste some standard set of lines that are mostly '#include'\n        prnt(cffimod_header)\n        # then paste the C source given by the user, verbatim.\n        prnt(self.verifier.preamble)\n        #\n        # call generate_gen_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._generate('decl')\n        #\n        # on Windows, distutils insists on putting init_cffi_xyz in\n        # 'export_symbols', so instead of fighting it, just give up and\n        # give it one\n        if sys.platform == 'win32':\n            if sys.version_info >= (3,):\n                prefix = 'PyInit_'\n            else:\n                prefix = 'init'\n            modname = self.verifier.get_module_name()\n            prnt(\"void %s%s(void) { }\\n\" % (prefix, modname))\n\n    def load_library(self, flags=0):\n        # import it with the CFFI backend\n        backend = self.ffi._backend\n        # needs to make a path that contains '/', on Posix\n        filename = os.path.join(os.curdir, self.verifier.modulefilename)\n        module = backend.load_library(filename, flags)\n        #\n        # call loading_gen_struct() to get the struct layout inferred by\n        # the C compiler\n        self._load(module, 'loading')\n\n        # build the FFILibrary class and instance, this is a module subclass\n        # because modules are expected to have usually-constant-attributes and\n        # in PyPy this means the JIT is able to treat attributes as constant,\n        # which we want.\n        class FFILibrary(types.ModuleType):\n            _cffi_generic_module = module\n            _cffi_ffi = self.ffi\n            _cffi_dir = []\n            def __dir__(self):\n                return FFILibrary._cffi_dir\n        library = FFILibrary(\"\")\n        #\n        # finally, call the loaded_gen_xxx() functions.  This will set\n        # up the 'library' object.\n        self._load(module, 'loaded', library=library)\n        return library\n\n    def _get_declarations(self):\n        lst = [(key, tp) for (key, (tp, qual)) in\n                                self.ffi._parser._declarations.items()]\n        lst.sort()\n        return lst\n\n    def _generate(self, step_name):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_gen_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise VerificationError(\n                    \"not implemented in verify(): %r\" % name)\n            try:\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _load(self, module, step_name, **kwds):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            method = getattr(self, '_%s_gen_%s' % (step_name, kind))\n            try:\n                method(tp, realname, module, **kwds)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _generate_nothing(self, tp, name):\n        pass\n\n    def _loaded_noop(self, tp, name, module, **kwds):\n        pass\n\n    # ----------\n    # typedefs: generates no code so far\n\n    _generate_gen_typedef_decl   = _generate_nothing\n    _loading_gen_typedef         = _loaded_noop\n    _loaded_gen_typedef          = _loaded_noop\n\n    # ----------\n    # function declarations\n\n    def _generate_gen_function_decl(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no _cffi_f_%s wrapper)\n            self._generate_gen_const(False, name, tp)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        argnames = []\n        for i, type in enumerate(tp.args):\n            indirection = ''\n            if isinstance(type, model.StructOrUnion):\n                indirection = '*'\n            argnames.append('%sx%d' % (indirection, i))\n        context = 'argument of %s' % name\n        arglist = [type.get_c_name(' %s' % arg, context)\n                   for type, arg in zip(tp.args, argnames)]\n        tpresult = tp.result\n        if isinstance(tpresult, model.StructOrUnion):\n            arglist.insert(0, tpresult.get_c_name(' *r', context))\n            tpresult = model.void_type\n        arglist = ', '.join(arglist) or 'void'\n        wrappername = '_cffi_f_%s' % name\n        self.export_symbols.append(wrappername)\n        if tp.abi:\n            abi = tp.abi + ' '\n        else:\n            abi = ''\n        funcdecl = ' %s%s(%s)' % (abi, wrappername, arglist)\n        context = 'result of %s' % name\n        prnt(tpresult.get_c_name(funcdecl, context))\n        prnt('{')\n        #\n        if isinstance(tp.result, model.StructOrUnion):\n            result_code = '*r = '\n        elif not isinstance(tp.result, model.VoidType):\n            result_code = 'return '\n        else:\n            result_code = ''\n        prnt('  %s%s(%s);' % (result_code, name, ', '.join(argnames)))\n        prnt('}')\n        prnt()\n\n    _loading_gen_function = _loaded_noop\n\n    def _loaded_gen_function(self, tp, name, module, library):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            newfunction = self._load_constant(False, tp, name, module)\n        else:\n            indirections = []\n            base_tp = tp\n            if (any(isinstance(typ, model.StructOrUnion) for typ in tp.args)\n                    or isinstance(tp.result, model.StructOrUnion)):\n                indirect_args = []\n                for i, typ in enumerate(tp.args):\n                    if isinstance(typ, model.StructOrUnion):\n                        typ = model.PointerType(typ)\n                        indirections.append((i, typ))\n                    indirect_args.append(typ)\n                indirect_result = tp.result\n                if isinstance(indirect_result, model.StructOrUnion):\n                    if indirect_result.fldtypes is None:\n                        raise TypeError(\"'%s' is used as result type, \"\n                                        \"but is opaque\" % (\n                                            indirect_result._get_c_name(),))\n                    indirect_result = model.PointerType(indirect_result)\n                    indirect_args.insert(0, indirect_result)\n                    indirections.insert(0, (\"result\", indirect_result))\n                    indirect_result = model.void_type\n                tp = model.FunctionPtrType(tuple(indirect_args),\n                                           indirect_result, tp.ellipsis)\n            BFunc = self.ffi._get_cached_btype(tp)\n            wrappername = '_cffi_f_%s' % name\n            newfunction = module.load_function(BFunc, wrappername)\n            for i, typ in indirections:\n                newfunction = self._make_struct_wrapper(newfunction, i, typ,\n                                                        base_tp)\n        setattr(library, name, newfunction)\n        type(library)._cffi_dir.append(name)\n\n    def _make_struct_wrapper(self, oldfunc, i, tp, base_tp):\n        backend = self.ffi._backend\n        BType = self.ffi._get_cached_btype(tp)\n        if i == \"result\":\n            ffi = self.ffi\n            def newfunc(*args):\n                res = ffi.new(BType)\n                oldfunc(res, *args)\n                return res[0]\n        else:\n            def newfunc(*args):\n                args = args[:i] + (backend.newp(BType, args[i]),) + args[i+1:]\n                return oldfunc(*args)\n        newfunc._cffi_base_type = base_tp\n        return newfunc\n\n    # ----------\n    # named structs\n\n    def _generate_gen_struct_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'struct', name)\n\n    def _loading_gen_struct(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'struct', name, module)\n\n    def _loaded_gen_struct(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_gen_union_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'union', name)\n\n    def _loading_gen_union(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'union', name, module)\n\n    def _loaded_gen_union(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_struct_or_union_decl(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        checkfuncname = '_cffi_check_%s_%s' % (prefix, name)\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        cname = ('%s %s' % (prefix, name)).strip()\n        #\n        prnt = self._prnt\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if (isinstance(ftype, model.PrimitiveType)\n                and ftype.is_integer_type()) or fbitsize >= 0:\n                # accept all integers, but complain on float or double\n                prnt('  (void)((p->%s) << 1);' % fname)\n            else:\n                # only accept exactly the type declared.\n                try:\n                    prnt('  { %s = &p->%s; (void)tmp; }' % (\n                        ftype.get_c_name('*tmp', 'field %r'%fname, quals=fqual),\n                        fname))\n                except VerificationError as e:\n                    prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        self.export_symbols.append(layoutfuncname)\n        prnt('intptr_t %s(intptr_t i)' % (layoutfuncname,))\n        prnt('{')\n        prnt('  struct _cffi_aligncheck { char x; %s y; };' % cname)\n        prnt('  static intptr_t nums[] = {')\n        prnt('    sizeof(%s),' % cname)\n        prnt('    offsetof(struct _cffi_aligncheck, y),')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if fbitsize >= 0:\n                continue      # xxx ignore fbitsize for now\n            prnt('    offsetof(%s, %s),' % (cname, fname))\n            if isinstance(ftype, model.ArrayType) and ftype.length is None:\n                prnt('    0,  /* %s */' % ftype._get_c_name())\n            else:\n                prnt('    sizeof(((%s *)0)->%s),' % (cname, fname))\n        prnt('    -1')\n        prnt('  };')\n        prnt('  return nums[i];')\n        prnt('  /* the next line is not executed, but compiled */')\n        prnt('  %s(0);' % (checkfuncname,))\n        prnt('}')\n        prnt()\n\n    def _loading_struct_or_union(self, tp, prefix, name, module):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        #\n        BFunc = self.ffi._typeof_locked(\"intptr_t(*)(intptr_t)\")[0]\n        function = module.load_function(BFunc, layoutfuncname)\n        layout = []\n        num = 0\n        while True:\n            x = function(num)\n            if x < 0: break\n            layout.append(x)\n            num += 1\n        if isinstance(tp, model.StructOrUnion) and tp.partial:\n            # use the function()'s sizes and offsets to guide the\n            # layout of the struct\n            totalsize = layout[0]\n            totalalignment = layout[1]\n            fieldofs = layout[2::2]\n            fieldsize = layout[3::2]\n            tp.force_flatten()\n            assert len(fieldofs) == len(fieldsize) == len(tp.fldnames)\n            tp.fixedlayout = fieldofs, fieldsize, totalsize, totalalignment\n        else:\n            cname = ('%s %s' % (prefix, name)).strip()\n            self._struct_pending_verification[tp] = layout, cname\n\n    def _loaded_struct_or_union(self, tp):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        self.ffi._get_cached_btype(tp)   # force 'fixedlayout' to be considered\n\n        if tp in self._struct_pending_verification:\n            # check that the layout sizes and offsets match the real ones\n            def check(realvalue, expectedvalue, msg):\n                if realvalue != expectedvalue:\n                    raise VerificationError(\n                        \"%s (we have %d, but C compiler says %d)\"\n                        % (msg, expectedvalue, realvalue))\n            ffi = self.ffi\n            BStruct = ffi._get_cached_btype(tp)\n            layout, cname = self._struct_pending_verification.pop(tp)\n            check(layout[0], ffi.sizeof(BStruct), \"wrong total size\")\n            check(layout[1], ffi.alignof(BStruct), \"wrong total alignment\")\n            i = 2\n            for fname, ftype, fbitsize, fqual in tp.enumfields():\n                if fbitsize >= 0:\n                    continue        # xxx ignore fbitsize for now\n                check(layout[i], ffi.offsetof(BStruct, fname),\n                      \"wrong offset for field %r\" % (fname,))\n                if layout[i+1] != 0:\n                    BField = ffi._get_cached_btype(ftype)\n                    check(layout[i+1], ffi.sizeof(BField),\n                          \"wrong size for field %r\" % (fname,))\n                i += 2\n            assert i == len(layout)\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    def _generate_gen_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_gen_enum_decl(tp, name, '')\n        else:\n            self._generate_struct_or_union_decl(tp, '', name)\n\n    def _loading_gen_anonymous(self, tp, name, module):\n        if isinstance(tp, model.EnumType):\n            self._loading_gen_enum(tp, name, module, '')\n        else:\n            self._loading_struct_or_union(tp, '', name, module)\n\n    def _loaded_gen_anonymous(self, tp, name, module, **kwds):\n        if isinstance(tp, model.EnumType):\n            self._loaded_gen_enum(tp, name, module, **kwds)\n        else:\n            self._loaded_struct_or_union(tp)\n\n    # ----------\n    # constants, likely declared with '#define'\n\n    def _generate_gen_const(self, is_int, name, tp=None, category='const',\n                            check_value=None):\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        self.export_symbols.append(funcname)\n        if check_value is not None:\n            assert is_int\n            assert category == 'const'\n            prnt('int %s(char *out_error)' % funcname)\n            prnt('{')\n            self._check_int_constant_value(name, check_value)\n            prnt('  return 0;')\n            prnt('}')\n        elif is_int:\n            assert category == 'const'\n            prnt('int %s(long long *out_value)' % funcname)\n            prnt('{')\n            prnt('  *out_value = (long long)(%s);' % (name,))\n            prnt('  return (%s) <= 0;' % (name,))\n            prnt('}')\n        else:\n            assert tp is not None\n            assert check_value is None\n            if category == 'var':\n                ampersand = '&'\n            else:\n                ampersand = ''\n            extra = ''\n            if category == 'const' and isinstance(tp, model.StructOrUnion):\n                extra = 'const *'\n                ampersand = '&'\n            prnt(tp.get_c_name(' %s%s(void)' % (extra, funcname), name))\n            prnt('{')\n            prnt('  return (%s%s);' % (ampersand, name))\n            prnt('}')\n        prnt()\n\n    def _generate_gen_constant_decl(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        self._generate_gen_const(is_int, name, tp)\n\n    _loading_gen_constant = _loaded_noop\n\n    def _load_constant(self, is_int, tp, name, module, check_value=None):\n        funcname = '_cffi_const_%s' % name\n        if check_value is not None:\n            assert is_int\n            self._load_known_int_constant(module, funcname)\n            value = check_value\n        elif is_int:\n            BType = self.ffi._typeof_locked(\"long long*\")[0]\n            BFunc = self.ffi._typeof_locked(\"int(*)(long long*)\")[0]\n            function = module.load_function(BFunc, funcname)\n            p = self.ffi.new(BType)\n            negative = function(p)\n            value = int(p[0])\n            if value < 0 and not negative:\n                BLongLong = self.ffi._typeof_locked(\"long long\")[0]\n                value += (1 << (8*self.ffi.sizeof(BLongLong)))\n        else:\n            assert check_value is None\n            fntypeextra = '(*)(void)'\n            if isinstance(tp, model.StructOrUnion):\n                fntypeextra = '*' + fntypeextra\n            BFunc = self.ffi._typeof_locked(tp.get_c_name(fntypeextra, name))[0]\n            function = module.load_function(BFunc, funcname)\n            value = function()\n            if isinstance(tp, model.StructOrUnion):\n                value = value[0]\n        return value\n\n    def _loaded_gen_constant(self, tp, name, module, library):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        value = self._load_constant(is_int, tp, name, module)\n        setattr(library, name, value)\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n    # enums\n\n    def _check_int_constant_value(self, name, value):\n        prnt = self._prnt\n        if value <= 0:\n            prnt('  if ((%s) > 0 || (long)(%s) != %dL) {' % (\n                name, name, value))\n        else:\n            prnt('  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {' % (\n                name, name, value))\n        prnt('    char buf[64];')\n        prnt('    if ((%s) <= 0)' % name)\n        prnt('        sprintf(buf, \"%%ld\", (long)(%s));' % name)\n        prnt('    else')\n        prnt('        sprintf(buf, \"%%lu\", (unsigned long)(%s));' %\n             name)\n        prnt('    sprintf(out_error, \"%s has the real value %s, not %s\",')\n        prnt('            \"%s\", buf, \"%d\");' % (name[:100], value))\n        prnt('    return -1;')\n        prnt('  }')\n\n    def _load_known_int_constant(self, module, funcname):\n        BType = self.ffi._typeof_locked(\"char[]\")[0]\n        BFunc = self.ffi._typeof_locked(\"int(*)(char*)\")[0]\n        function = module.load_function(BFunc, funcname)\n        p = self.ffi.new(BType, 256)\n        if function(p) < 0:\n            error = self.ffi.string(p)\n            if sys.version_info >= (3,):\n                error = str(error, 'utf-8')\n            raise VerificationError(error)\n\n    def _enum_funcname(self, prefix, name):\n        # \"$enum_$1\" => \"___D_enum____D_1\"\n        name = name.replace('$', '___D_')\n        return '_cffi_e_%s_%s' % (prefix, name)\n\n    def _generate_gen_enum_decl(self, tp, name, prefix='enum'):\n        if tp.partial:\n            for enumerator in tp.enumerators:\n                self._generate_gen_const(True, enumerator)\n            return\n        #\n        funcname = self._enum_funcname(prefix, name)\n        self.export_symbols.append(funcname)\n        prnt = self._prnt\n        prnt('int %s(char *out_error)' % funcname)\n        prnt('{')\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._check_int_constant_value(enumerator, enumvalue)\n        prnt('  return 0;')\n        prnt('}')\n        prnt()\n\n    def _loading_gen_enum(self, tp, name, module, prefix='enum'):\n        if tp.partial:\n            enumvalues = [self._load_constant(True, tp, enumerator, module)\n                          for enumerator in tp.enumerators]\n            tp.enumvalues = tuple(enumvalues)\n            tp.partial_resolved = True\n        else:\n            funcname = self._enum_funcname(prefix, name)\n            self._load_known_int_constant(module, funcname)\n\n    def _loaded_gen_enum(self, tp, name, module, library):\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            setattr(library, enumerator, enumvalue)\n            type(library)._cffi_dir.append(enumerator)\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_gen_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_gen_const(True, name, check_value=check_value)\n\n    _loading_gen_macro = _loaded_noop\n\n    def _loaded_gen_macro(self, tp, name, module, library):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        value = self._load_constant(True, tp, name, module,\n                                    check_value=check_value)\n        setattr(library, name, value)\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n    # global variables\n\n    def _generate_gen_variable_decl(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            if tp.length_is_unknown():\n                prnt = self._prnt\n                funcname = '_cffi_sizeof_%s' % (name,)\n                self.export_symbols.append(funcname)\n                prnt(\"size_t %s(void)\" % funcname)\n                prnt(\"{\")\n                prnt(\"  return sizeof(%s);\" % (name,))\n                prnt(\"}\")\n            tp_ptr = model.PointerType(tp.item)\n            self._generate_gen_const(False, name, tp_ptr)\n        else:\n            tp_ptr = model.PointerType(tp)\n            self._generate_gen_const(False, name, tp_ptr, category='var')\n\n    _loading_gen_variable = _loaded_noop\n\n    def _loaded_gen_variable(self, tp, name, module, library):\n        if isinstance(tp, model.ArrayType):   # int a[5] is \"constant\" in the\n                                              # sense that \"a=...\" is forbidden\n            if tp.length_is_unknown():\n                funcname = '_cffi_sizeof_%s' % (name,)\n                BFunc = self.ffi._typeof_locked('size_t(*)(void)')[0]\n                function = module.load_function(BFunc, funcname)\n                size = function()\n                BItemType = self.ffi._get_cached_btype(tp.item)\n                length, rest = divmod(size, self.ffi.sizeof(BItemType))\n                if rest != 0:\n                    raise VerificationError(\n                        \"bad size: %r does not seem to be an array of %s\" %\n                        (name, tp.item))\n                tp = tp.resolve_length(length)\n            tp_ptr = model.PointerType(tp.item)\n            value = self._load_constant(False, tp_ptr, name, module)\n            # 'value' is a <cdata 'type *'> which we have to replace with\n            # a <cdata 'type[N]'> if the N is actually known\n            if tp.length is not None:\n                BArray = self.ffi._get_cached_btype(tp)\n                value = self.ffi.cast(BArray, value)\n            setattr(library, name, value)\n            type(library)._cffi_dir.append(name)\n            return\n        # remove ptr=<cdata 'int *'> from the library instance, and replace\n        # it by a property on the class, which reads/writes into ptr[0].\n        funcname = '_cffi_var_%s' % name\n        BFunc = self.ffi._typeof_locked(tp.get_c_name('*(*)(void)', name))[0]\n        function = module.load_function(BFunc, funcname)\n        ptr = function()\n        def getter(library):\n            return ptr[0]\n        def setter(library, value):\n            ptr[0] = value\n        setattr(type(library), name, property(getter, setter))\n        type(library)._cffi_dir.append(name)\n\ncffimod_header = r'''\n#include <stdio.h>\n#include <stddef.h>\n#include <stdarg.h>\n#include <errno.h>\n#include <sys/types.h>   /* XXX for ssize_t on some platforms */\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py\n   and cffi/_cffi_include.h */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n#  ifndef __cplusplus\n    typedef unsigned char _Bool;\n#  endif\n# endif\n# define _cffi_float_complex_t   _Fcomplex    /* include <complex.h> for it */\n# define _cffi_double_complex_t  _Dcomplex    /* include <complex.h> for it */\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)\n#  include <alloca.h>\n# endif\n# define _cffi_float_complex_t   float _Complex\n# define _cffi_double_complex_t  double _Complex\n#endif\n'''\n", "src/cffi/_imp_emulation.py": "\ntry:\n    # this works on Python < 3.12\n    from imp import *\n\nexcept ImportError:\n    # this is a limited emulation for Python >= 3.12.\n    # Note that this is used only for tests or for the old ffi.verify().\n    # This is copied from the source code of Python 3.11.\n\n    from _imp import (acquire_lock, release_lock,\n                      is_builtin, is_frozen)\n\n    from importlib._bootstrap import _load\n\n    from importlib import machinery\n    import os\n    import sys\n    import tokenize\n\n    SEARCH_ERROR = 0\n    PY_SOURCE = 1\n    PY_COMPILED = 2\n    C_EXTENSION = 3\n    PY_RESOURCE = 4\n    PKG_DIRECTORY = 5\n    C_BUILTIN = 6\n    PY_FROZEN = 7\n    PY_CODERESOURCE = 8\n    IMP_HOOK = 9\n\n    def get_suffixes():\n        extensions = [(s, 'rb', C_EXTENSION)\n                      for s in machinery.EXTENSION_SUFFIXES]\n        source = [(s, 'r', PY_SOURCE) for s in machinery.SOURCE_SUFFIXES]\n        bytecode = [(s, 'rb', PY_COMPILED) for s in machinery.BYTECODE_SUFFIXES]\n        return extensions + source + bytecode\n\n    def find_module(name, path=None):\n        if not isinstance(name, str):\n            raise TypeError(\"'name' must be a str, not {}\".format(type(name)))\n        elif not isinstance(path, (type(None), list)):\n            # Backwards-compatibility\n            raise RuntimeError(\"'path' must be None or a list, \"\n                               \"not {}\".format(type(path)))\n\n        if path is None:\n            if is_builtin(name):\n                return None, None, ('', '', C_BUILTIN)\n            elif is_frozen(name):\n                return None, None, ('', '', PY_FROZEN)\n            else:\n                path = sys.path\n\n        for entry in path:\n            package_directory = os.path.join(entry, name)\n            for suffix in ['.py', machinery.BYTECODE_SUFFIXES[0]]:\n                package_file_name = '__init__' + suffix\n                file_path = os.path.join(package_directory, package_file_name)\n                if os.path.isfile(file_path):\n                    return None, package_directory, ('', '', PKG_DIRECTORY)\n            for suffix, mode, type_ in get_suffixes():\n                file_name = name + suffix\n                file_path = os.path.join(entry, file_name)\n                if os.path.isfile(file_path):\n                    break\n            else:\n                continue\n            break  # Break out of outer loop when breaking out of inner loop.\n        else:\n            raise ImportError(name, name=name)\n\n        encoding = None\n        if 'b' not in mode:\n            with open(file_path, 'rb') as file:\n                encoding = tokenize.detect_encoding(file.readline)[0]\n        file = open(file_path, mode, encoding=encoding)\n        return file, file_path, (suffix, mode, type_)\n\n    def load_dynamic(name, path, file=None):\n        loader = machinery.ExtensionFileLoader(name, path)\n        spec = machinery.ModuleSpec(name=name, loader=loader, origin=path)\n        return _load(spec)\n", "src/cffi/ffiplatform.py": "import sys, os\nfrom .error import VerificationError\n\n\nLIST_OF_FILE_NAMES = ['sources', 'include_dirs', 'library_dirs',\n                      'extra_objects', 'depends']\n\ndef get_extension(srcfilename, modname, sources=(), **kwds):\n    from cffi._shimmed_dist_utils import Extension\n    allsources = [srcfilename]\n    for src in sources:\n        allsources.append(os.path.normpath(src))\n    return Extension(name=modname, sources=allsources, **kwds)\n\ndef compile(tmpdir, ext, compiler_verbose=0, debug=None):\n    \"\"\"Compile a C extension module using distutils.\"\"\"\n\n    saved_environ = os.environ.copy()\n    try:\n        outputfilename = _build(tmpdir, ext, compiler_verbose, debug)\n        outputfilename = os.path.abspath(outputfilename)\n    finally:\n        # workaround for a distutils bugs where some env vars can\n        # become longer and longer every time it is used\n        for key, value in saved_environ.items():\n            if os.environ.get(key) != value:\n                os.environ[key] = value\n    return outputfilename\n\ndef _build(tmpdir, ext, compiler_verbose=0, debug=None):\n    # XXX compact but horrible :-(\n    from cffi._shimmed_dist_utils import Distribution, CompileError, LinkError, set_threshold, set_verbosity\n\n    dist = Distribution({'ext_modules': [ext]})\n    dist.parse_config_files()\n    options = dist.get_option_dict('build_ext')\n    if debug is None:\n        debug = sys.flags.debug\n    options['debug'] = ('ffiplatform', debug)\n    options['force'] = ('ffiplatform', True)\n    options['build_lib'] = ('ffiplatform', tmpdir)\n    options['build_temp'] = ('ffiplatform', tmpdir)\n    #\n    try:\n        old_level = set_threshold(0) or 0\n        try:\n            set_verbosity(compiler_verbose)\n            dist.run_command('build_ext')\n            cmd_obj = dist.get_command_obj('build_ext')\n            [soname] = cmd_obj.get_outputs()\n        finally:\n            set_threshold(old_level)\n    except (CompileError, LinkError) as e:\n        raise VerificationError('%s: %s' % (e.__class__.__name__, e))\n    #\n    return soname\n\ntry:\n    from os.path import samefile\nexcept ImportError:\n    def samefile(f1, f2):\n        return os.path.abspath(f1) == os.path.abspath(f2)\n\ndef maybe_relative_path(path):\n    if not os.path.isabs(path):\n        return path      # already relative\n    dir = path\n    names = []\n    while True:\n        prevdir = dir\n        dir, name = os.path.split(prevdir)\n        if dir == prevdir or not dir:\n            return path     # failed to make it relative\n        names.append(name)\n        try:\n            if samefile(dir, os.curdir):\n                names.reverse()\n                return os.path.join(*names)\n        except OSError:\n            pass\n\n# ____________________________________________________________\n\ntry:\n    int_or_long = (int, long)\n    import cStringIO\nexcept NameError:\n    int_or_long = int      # Python 3\n    import io as cStringIO\n\ndef _flatten(x, f):\n    if isinstance(x, str):\n        f.write('%ds%s' % (len(x), x))\n    elif isinstance(x, dict):\n        keys = sorted(x.keys())\n        f.write('%dd' % len(keys))\n        for key in keys:\n            _flatten(key, f)\n            _flatten(x[key], f)\n    elif isinstance(x, (list, tuple)):\n        f.write('%dl' % len(x))\n        for value in x:\n            _flatten(value, f)\n    elif isinstance(x, int_or_long):\n        f.write('%di' % (x,))\n    else:\n        raise TypeError(\n            \"the keywords to verify() contains unsupported object %r\" % (x,))\n\ndef flatten(x):\n    f = cStringIO.StringIO()\n    _flatten(x, f)\n    return f.getvalue()\n", "src/cffi/pkgconfig.py": "# pkg-config, https://www.freedesktop.org/wiki/Software/pkg-config/ integration for cffi\nimport sys, os, subprocess\n\nfrom .error import PkgConfigError\n\n\ndef merge_flags(cfg1, cfg2):\n    \"\"\"Merge values from cffi config flags cfg2 to cf1\n\n    Example:\n        merge_flags({\"libraries\": [\"one\"]}, {\"libraries\": [\"two\"]})\n        {\"libraries\": [\"one\", \"two\"]}\n    \"\"\"\n    for key, value in cfg2.items():\n        if key not in cfg1:\n            cfg1[key] = value\n        else:\n            if not isinstance(cfg1[key], list):\n                raise TypeError(\"cfg1[%r] should be a list of strings\" % (key,))\n            if not isinstance(value, list):\n                raise TypeError(\"cfg2[%r] should be a list of strings\" % (key,))\n            cfg1[key].extend(value)\n    return cfg1\n\n\ndef call(libname, flag, encoding=sys.getfilesystemencoding()):\n    \"\"\"Calls pkg-config and returns the output if found\n    \"\"\"\n    a = [\"pkg-config\", \"--print-errors\"]\n    a.append(flag)\n    a.append(libname)\n    try:\n        pc = subprocess.Popen(a, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n    except EnvironmentError as e:\n        raise PkgConfigError(\"cannot run pkg-config: %s\" % (str(e).strip(),))\n\n    bout, berr = pc.communicate()\n    if pc.returncode != 0:\n        try:\n            berr = berr.decode(encoding)\n        except Exception:\n            pass\n        raise PkgConfigError(berr.strip())\n\n    if sys.version_info >= (3,) and not isinstance(bout, str):   # Python 3.x\n        try:\n            bout = bout.decode(encoding)\n        except UnicodeDecodeError:\n            raise PkgConfigError(\"pkg-config %s %s returned bytes that cannot \"\n                                 \"be decoded with encoding %r:\\n%r\" %\n                                 (flag, libname, encoding, bout))\n\n    if os.altsep != '\\\\' and '\\\\' in bout:\n        raise PkgConfigError(\"pkg-config %s %s returned an unsupported \"\n                             \"backslash-escaped output:\\n%r\" %\n                             (flag, libname, bout))\n    return bout\n\n\ndef flags_from_pkgconfig(libs):\n    r\"\"\"Return compiler line flags for FFI.set_source based on pkg-config output\n\n    Usage\n        ...\n        ffibuilder.set_source(\"_foo\", pkgconfig = [\"libfoo\", \"libbar >= 1.8.3\"])\n\n    If pkg-config is installed on build machine, then arguments include_dirs,\n    library_dirs, libraries, define_macros, extra_compile_args and\n    extra_link_args are extended with an output of pkg-config for libfoo and\n    libbar.\n\n    Raises PkgConfigError in case the pkg-config call fails.\n    \"\"\"\n\n    def get_include_dirs(string):\n        return [x[2:] for x in string.split() if x.startswith(\"-I\")]\n\n    def get_library_dirs(string):\n        return [x[2:] for x in string.split() if x.startswith(\"-L\")]\n\n    def get_libraries(string):\n        return [x[2:] for x in string.split() if x.startswith(\"-l\")]\n\n    # convert -Dfoo=bar to list of tuples [(\"foo\", \"bar\")] expected by distutils\n    def get_macros(string):\n        def _macro(x):\n            x = x[2:]    # drop \"-D\"\n            if '=' in x:\n                return tuple(x.split(\"=\", 1))  # \"-Dfoo=bar\" => (\"foo\", \"bar\")\n            else:\n                return (x, None)               # \"-Dfoo\" => (\"foo\", None)\n        return [_macro(x) for x in string.split() if x.startswith(\"-D\")]\n\n    def get_other_cflags(string):\n        return [x for x in string.split() if not x.startswith(\"-I\") and\n                                             not x.startswith(\"-D\")]\n\n    def get_other_libs(string):\n        return [x for x in string.split() if not x.startswith(\"-L\") and\n                                             not x.startswith(\"-l\")]\n\n    # return kwargs for given libname\n    def kwargs(libname):\n        fse = sys.getfilesystemencoding()\n        all_cflags = call(libname, \"--cflags\")\n        all_libs = call(libname, \"--libs\")\n        return {\n            \"include_dirs\": get_include_dirs(all_cflags),\n            \"library_dirs\": get_library_dirs(all_libs),\n            \"libraries\": get_libraries(all_libs),\n            \"define_macros\": get_macros(all_cflags),\n            \"extra_compile_args\": get_other_cflags(all_cflags),\n            \"extra_link_args\": get_other_libs(all_libs),\n            }\n\n    # merge all arguments together\n    ret = {}\n    for libname in libs:\n        lib_flags = kwargs(libname)\n        merge_flags(ret, lib_flags)\n    return ret\n", "src/cffi/api.py": "import sys, types\nfrom .lock import allocate_lock\nfrom .error import CDefError\nfrom . import model\n\ntry:\n    callable\nexcept NameError:\n    # Python 3.1\n    from collections import Callable\n    callable = lambda x: isinstance(x, Callable)\n\ntry:\n    basestring\nexcept NameError:\n    # Python 3.x\n    basestring = str\n\n_unspecified = object()\n\n\n\nclass FFI(object):\n    r'''\n    The main top-level class that you instantiate once, or once per module.\n\n    Example usage:\n\n        ffi = FFI()\n        ffi.cdef(\"\"\"\n            int printf(const char *, ...);\n        \"\"\")\n\n        C = ffi.dlopen(None)   # standard library\n        -or-\n        C = ffi.verify()  # use a C compiler: verify the decl above is right\n\n        C.printf(\"hello, %s!\\n\", ffi.new(\"char[]\", \"world\"))\n    '''\n\n    def __init__(self, backend=None):\n        \"\"\"Create an FFI instance.  The 'backend' argument is used to\n        select a non-default backend, mostly for tests.\n        \"\"\"\n        if backend is None:\n            # You need PyPy (>= 2.0 beta), or a CPython (>= 2.6) with\n            # _cffi_backend.so compiled.\n            import _cffi_backend as backend\n            from . import __version__\n            if backend.__version__ != __version__:\n                # bad version!  Try to be as explicit as possible.\n                if hasattr(backend, '__file__'):\n                    # CPython\n                    raise Exception(\"Version mismatch: this is the 'cffi' package version %s, located in %r.  When we import the top-level '_cffi_backend' extension module, we get version %s, located in %r.  The two versions should be equal; check your installation.\" % (\n                        __version__, __file__,\n                        backend.__version__, backend.__file__))\n                else:\n                    # PyPy\n                    raise Exception(\"Version mismatch: this is the 'cffi' package version %s, located in %r.  This interpreter comes with a built-in '_cffi_backend' module, which is version %s.  The two versions should be equal; check your installation.\" % (\n                        __version__, __file__, backend.__version__))\n            # (If you insist you can also try to pass the option\n            # 'backend=backend_ctypes.CTypesBackend()', but don't\n            # rely on it!  It's probably not going to work well.)\n\n        from . import cparser\n        self._backend = backend\n        self._lock = allocate_lock()\n        self._parser = cparser.Parser()\n        self._cached_btypes = {}\n        self._parsed_types = types.ModuleType('parsed_types').__dict__\n        self._new_types = types.ModuleType('new_types').__dict__\n        self._function_caches = []\n        self._libraries = []\n        self._cdefsources = []\n        self._included_ffis = []\n        self._windows_unicode = None\n        self._init_once_cache = {}\n        self._cdef_version = None\n        self._embedding = None\n        self._typecache = model.get_typecache(backend)\n        if hasattr(backend, 'set_ffi'):\n            backend.set_ffi(self)\n        for name in list(backend.__dict__):\n            if name.startswith('RTLD_'):\n                setattr(self, name, getattr(backend, name))\n        #\n        with self._lock:\n            self.BVoidP = self._get_cached_btype(model.voidp_type)\n            self.BCharA = self._get_cached_btype(model.char_array_type)\n        if isinstance(backend, types.ModuleType):\n            # _cffi_backend: attach these constants to the class\n            if not hasattr(FFI, 'NULL'):\n                FFI.NULL = self.cast(self.BVoidP, 0)\n                FFI.CData, FFI.CType = backend._get_types()\n        else:\n            # ctypes backend: attach these constants to the instance\n            self.NULL = self.cast(self.BVoidP, 0)\n            self.CData, self.CType = backend._get_types()\n        self.buffer = backend.buffer\n\n    def cdef(self, csource, override=False, packed=False, pack=None):\n        \"\"\"Parse the given C source.  This registers all declared functions,\n        types, and global variables.  The functions and global variables can\n        then be accessed via either 'ffi.dlopen()' or 'ffi.verify()'.\n        The types can be used in 'ffi.new()' and other functions.\n        If 'packed' is specified as True, all structs declared inside this\n        cdef are packed, i.e. laid out without any field alignment at all.\n        Alternatively, 'pack' can be a small integer, and requests for\n        alignment greater than that are ignored (pack=1 is equivalent to\n        packed=True).\n        \"\"\"\n        self._cdef(csource, override=override, packed=packed, pack=pack)\n\n    def embedding_api(self, csource, packed=False, pack=None):\n        self._cdef(csource, packed=packed, pack=pack, dllexport=True)\n        if self._embedding is None:\n            self._embedding = ''\n\n    def _cdef(self, csource, override=False, **options):\n        if not isinstance(csource, str):    # unicode, on Python 2\n            if not isinstance(csource, basestring):\n                raise TypeError(\"cdef() argument must be a string\")\n            csource = csource.encode('ascii')\n        with self._lock:\n            self._cdef_version = object()\n            self._parser.parse(csource, override=override, **options)\n            self._cdefsources.append(csource)\n            if override:\n                for cache in self._function_caches:\n                    cache.clear()\n            finishlist = self._parser._recomplete\n            if finishlist:\n                self._parser._recomplete = []\n                for tp in finishlist:\n                    tp.finish_backend_type(self, finishlist)\n\n    def dlopen(self, name, flags=0):\n        \"\"\"Load and return a dynamic library identified by 'name'.\n        The standard C library can be loaded by passing None.\n        Note that functions and types declared by 'ffi.cdef()' are not\n        linked to a particular library, just like C headers; in the\n        library we only look for the actual (untyped) symbols.\n        \"\"\"\n        if not (isinstance(name, basestring) or\n                name is None or\n                isinstance(name, self.CData)):\n            raise TypeError(\"dlopen(name): name must be a file name, None, \"\n                            \"or an already-opened 'void *' handle\")\n        with self._lock:\n            lib, function_cache = _make_ffi_library(self, name, flags)\n            self._function_caches.append(function_cache)\n            self._libraries.append(lib)\n        return lib\n\n    def dlclose(self, lib):\n        \"\"\"Close a library obtained with ffi.dlopen().  After this call,\n        access to functions or variables from the library will fail\n        (possibly with a segmentation fault).\n        \"\"\"\n        type(lib).__cffi_close__(lib)\n\n    def _typeof_locked(self, cdecl):\n        # call me with the lock!\n        key = cdecl\n        if key in self._parsed_types:\n            return self._parsed_types[key]\n        #\n        if not isinstance(cdecl, str):    # unicode, on Python 2\n            cdecl = cdecl.encode('ascii')\n        #\n        type = self._parser.parse_type(cdecl)\n        really_a_function_type = type.is_raw_function\n        if really_a_function_type:\n            type = type.as_function_pointer()\n        btype = self._get_cached_btype(type)\n        result = btype, really_a_function_type\n        self._parsed_types[key] = result\n        return result\n\n    def _typeof(self, cdecl, consider_function_as_funcptr=False):\n        # string -> ctype object\n        try:\n            result = self._parsed_types[cdecl]\n        except KeyError:\n            with self._lock:\n                result = self._typeof_locked(cdecl)\n        #\n        btype, really_a_function_type = result\n        if really_a_function_type and not consider_function_as_funcptr:\n            raise CDefError(\"the type %r is a function type, not a \"\n                            \"pointer-to-function type\" % (cdecl,))\n        return btype\n\n    def typeof(self, cdecl):\n        \"\"\"Parse the C type given as a string and return the\n        corresponding <ctype> object.\n        It can also be used on 'cdata' instance to get its C type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            return self._typeof(cdecl)\n        if isinstance(cdecl, self.CData):\n            return self._backend.typeof(cdecl)\n        if isinstance(cdecl, types.BuiltinFunctionType):\n            res = _builtin_function_type(cdecl)\n            if res is not None:\n                return res\n        if (isinstance(cdecl, types.FunctionType)\n                and hasattr(cdecl, '_cffi_base_type')):\n            with self._lock:\n                return self._get_cached_btype(cdecl._cffi_base_type)\n        raise TypeError(type(cdecl))\n\n    def sizeof(self, cdecl):\n        \"\"\"Return the size in bytes of the argument.  It can be a\n        string naming a C type, or a 'cdata' instance.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            BType = self._typeof(cdecl)\n            return self._backend.sizeof(BType)\n        else:\n            return self._backend.sizeof(cdecl)\n\n    def alignof(self, cdecl):\n        \"\"\"Return the natural alignment size in bytes of the C type\n        given as a string.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.alignof(cdecl)\n\n    def offsetof(self, cdecl, *fields_or_indexes):\n        \"\"\"Return the offset of the named field inside the given\n        structure or array, which must be given as a C type name.\n        You can give several field names in case of nested structures.\n        You can also give numeric values which correspond to array\n        items, in case of an array type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._typeoffsetof(cdecl, *fields_or_indexes)[1]\n\n    def new(self, cdecl, init=None):\n        \"\"\"Allocate an instance according to the specified C type and\n        return a pointer to it.  The specified C type must be either a\n        pointer or an array: ``new('X *')`` allocates an X and returns\n        a pointer to it, whereas ``new('X[n]')`` allocates an array of\n        n X'es and returns an array referencing it (which works\n        mostly like a pointer, like in C).  You can also use\n        ``new('X[]', n)`` to allocate an array of a non-constant\n        length n.\n\n        The memory is initialized following the rules of declaring a\n        global variable in C: by default it is zero-initialized, but\n        an explicit initializer can be given which can be used to\n        fill all or part of the memory.\n\n        When the returned <cdata> object goes out of scope, the memory\n        is freed.  In other words the returned <cdata> object has\n        ownership of the value of type 'cdecl' that it points to.  This\n        means that the raw data can be used as long as this object is\n        kept alive, but must not be used for a longer time.  Be careful\n        about that when copying the pointer to the memory somewhere\n        else, e.g. into another structure.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.newp(cdecl, init)\n\n    def new_allocator(self, alloc=None, free=None,\n                      should_clear_after_alloc=True):\n        \"\"\"Return a new allocator, i.e. a function that behaves like ffi.new()\n        but uses the provided low-level 'alloc' and 'free' functions.\n\n        'alloc' is called with the size as argument.  If it returns NULL, a\n        MemoryError is raised.  'free' is called with the result of 'alloc'\n        as argument.  Both can be either Python function or directly C\n        functions.  If 'free' is None, then no free function is called.\n        If both 'alloc' and 'free' are None, the default is used.\n\n        If 'should_clear_after_alloc' is set to False, then the memory\n        returned by 'alloc' is assumed to be already cleared (or you are\n        fine with garbage); otherwise CFFI will clear it.\n        \"\"\"\n        compiled_ffi = self._backend.FFI()\n        allocator = compiled_ffi.new_allocator(alloc, free,\n                                               should_clear_after_alloc)\n        def allocate(cdecl, init=None):\n            if isinstance(cdecl, basestring):\n                cdecl = self._typeof(cdecl)\n            return allocator(cdecl, init)\n        return allocate\n\n    def cast(self, cdecl, source):\n        \"\"\"Similar to a C cast: returns an instance of the named C\n        type initialized with the given 'source'.  The source is\n        casted between integers or pointers of any type.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.cast(cdecl, source)\n\n    def string(self, cdata, maxlen=-1):\n        \"\"\"Return a Python string (or unicode string) from the 'cdata'.\n        If 'cdata' is a pointer or array of characters or bytes, returns\n        the null-terminated string.  The returned string extends until\n        the first null character, or at most 'maxlen' characters.  If\n        'cdata' is an array then 'maxlen' defaults to its length.\n\n        If 'cdata' is a pointer or array of wchar_t, returns a unicode\n        string following the same rules.\n\n        If 'cdata' is a single character or byte or a wchar_t, returns\n        it as a string or unicode string.\n\n        If 'cdata' is an enum, returns the value of the enumerator as a\n        string, or 'NUMBER' if the value is out of range.\n        \"\"\"\n        return self._backend.string(cdata, maxlen)\n\n    def unpack(self, cdata, length):\n        \"\"\"Unpack an array of C data of the given length,\n        returning a Python string/unicode/list.\n\n        If 'cdata' is a pointer to 'char', returns a byte string.\n        It does not stop at the first null.  This is equivalent to:\n        ffi.buffer(cdata, length)[:]\n\n        If 'cdata' is a pointer to 'wchar_t', returns a unicode string.\n        'length' is measured in wchar_t's; it is not the size in bytes.\n\n        If 'cdata' is a pointer to anything else, returns a list of\n        'length' items.  This is a faster equivalent to:\n        [cdata[i] for i in range(length)]\n        \"\"\"\n        return self._backend.unpack(cdata, length)\n\n   #def buffer(self, cdata, size=-1):\n   #    \"\"\"Return a read-write buffer object that references the raw C data\n   #    pointed to by the given 'cdata'.  The 'cdata' must be a pointer or\n   #    an array.  Can be passed to functions expecting a buffer, or directly\n   #    manipulated with:\n   #\n   #        buf[:]          get a copy of it in a regular string, or\n   #        buf[idx]        as a single character\n   #        buf[:] = ...\n   #        buf[idx] = ...  change the content\n   #    \"\"\"\n   #    note that 'buffer' is a type, set on this instance by __init__\n\n    def from_buffer(self, cdecl, python_buffer=_unspecified,\n                    require_writable=False):\n        \"\"\"Return a cdata of the given type pointing to the data of the\n        given Python object, which must support the buffer interface.\n        Note that this is not meant to be used on the built-in types\n        str or unicode (you can build 'char[]' arrays explicitly)\n        but only on objects containing large quantities of raw data\n        in some other format, like 'array.array' or numpy arrays.\n\n        The first argument is optional and default to 'char[]'.\n        \"\"\"\n        if python_buffer is _unspecified:\n            cdecl, python_buffer = self.BCharA, cdecl\n        elif isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        return self._backend.from_buffer(cdecl, python_buffer,\n                                         require_writable)\n\n    def memmove(self, dest, src, n):\n        \"\"\"ffi.memmove(dest, src, n) copies n bytes of memory from src to dest.\n\n        Like the C function memmove(), the memory areas may overlap;\n        apart from that it behaves like the C function memcpy().\n\n        'src' can be any cdata ptr or array, or any Python buffer object.\n        'dest' can be any cdata ptr or array, or a writable Python buffer\n        object.  The size to copy, 'n', is always measured in bytes.\n\n        Unlike other methods, this one supports all Python buffer including\n        byte strings and bytearrays---but it still does not support\n        non-contiguous buffers.\n        \"\"\"\n        return self._backend.memmove(dest, src, n)\n\n    def callback(self, cdecl, python_callable=None, error=None, onerror=None):\n        \"\"\"Return a callback object or a decorator making such a\n        callback object.  'cdecl' must name a C function pointer type.\n        The callback invokes the specified 'python_callable' (which may\n        be provided either directly or via a decorator).  Important: the\n        callback object must be manually kept alive for as long as the\n        callback may be invoked from the C level.\n        \"\"\"\n        def callback_decorator_wrap(python_callable):\n            if not callable(python_callable):\n                raise TypeError(\"the 'python_callable' argument \"\n                                \"is not callable\")\n            return self._backend.callback(cdecl, python_callable,\n                                          error, onerror)\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl, consider_function_as_funcptr=True)\n        if python_callable is None:\n            return callback_decorator_wrap                # decorator mode\n        else:\n            return callback_decorator_wrap(python_callable)  # direct mode\n\n    def getctype(self, cdecl, replace_with=''):\n        \"\"\"Return a string giving the C type 'cdecl', which may be itself\n        a string or a <ctype> object.  If 'replace_with' is given, it gives\n        extra text to append (or insert for more complicated C types), like\n        a variable name, or '*' to get actually the C type 'pointer-to-cdecl'.\n        \"\"\"\n        if isinstance(cdecl, basestring):\n            cdecl = self._typeof(cdecl)\n        replace_with = replace_with.strip()\n        if (replace_with.startswith('*')\n                and '&[' in self._backend.getcname(cdecl, '&')):\n            replace_with = '(%s)' % replace_with\n        elif replace_with and not replace_with[0] in '[(':\n            replace_with = ' ' + replace_with\n        return self._backend.getcname(cdecl, replace_with)\n\n    def gc(self, cdata, destructor, size=0):\n        \"\"\"Return a new cdata object that points to the same\n        data.  Later, when this new cdata object is garbage-collected,\n        'destructor(old_cdata_object)' will be called.\n\n        The optional 'size' gives an estimate of the size, used to\n        trigger the garbage collection more eagerly.  So far only used\n        on PyPy.  It tells the GC that the returned object keeps alive\n        roughly 'size' bytes of external memory.\n        \"\"\"\n        return self._backend.gcp(cdata, destructor, size)\n\n    def _get_cached_btype(self, type):\n        assert self._lock.acquire(False) is False\n        # call me with the lock!\n        try:\n            BType = self._cached_btypes[type]\n        except KeyError:\n            finishlist = []\n            BType = type.get_cached_btype(self, finishlist)\n            for type in finishlist:\n                type.finish_backend_type(self, finishlist)\n        return BType\n\n    def verify(self, source='', tmpdir=None, **kwargs):\n        \"\"\"Verify that the current ffi signatures compile on this\n        machine, and return a dynamic library object.  The dynamic\n        library can be used to call functions and access global\n        variables declared in this 'ffi'.  The library is compiled\n        by the C compiler: it gives you C-level API compatibility\n        (including calling macros).  This is unlike 'ffi.dlopen()',\n        which requires binary compatibility in the signatures.\n        \"\"\"\n        from .verifier import Verifier, _caller_dir_pycache\n        #\n        # If set_unicode(True) was called, insert the UNICODE and\n        # _UNICODE macro declarations\n        if self._windows_unicode:\n            self._apply_windows_unicode(kwargs)\n        #\n        # Set the tmpdir here, and not in Verifier.__init__: it picks\n        # up the caller's directory, which we want to be the caller of\n        # ffi.verify(), as opposed to the caller of Veritier().\n        tmpdir = tmpdir or _caller_dir_pycache()\n        #\n        # Make a Verifier() and use it to load the library.\n        self.verifier = Verifier(self, source, tmpdir, **kwargs)\n        lib = self.verifier.load_library()\n        #\n        # Save the loaded library for keep-alive purposes, even\n        # if the caller doesn't keep it alive itself (it should).\n        self._libraries.append(lib)\n        return lib\n\n    def _get_errno(self):\n        return self._backend.get_errno()\n    def _set_errno(self, errno):\n        self._backend.set_errno(errno)\n    errno = property(_get_errno, _set_errno, None,\n                     \"the value of 'errno' from/to the C calls\")\n\n    def getwinerror(self, code=-1):\n        return self._backend.getwinerror(code)\n\n    def _pointer_to(self, ctype):\n        with self._lock:\n            return model.pointer_cache(self, ctype)\n\n    def addressof(self, cdata, *fields_or_indexes):\n        \"\"\"Return the address of a <cdata 'struct-or-union'>.\n        If 'fields_or_indexes' are given, returns the address of that\n        field or array item in the structure or array, recursively in\n        case of nested structures.\n        \"\"\"\n        try:\n            ctype = self._backend.typeof(cdata)\n        except TypeError:\n            if '__addressof__' in type(cdata).__dict__:\n                return type(cdata).__addressof__(cdata, *fields_or_indexes)\n            raise\n        if fields_or_indexes:\n            ctype, offset = self._typeoffsetof(ctype, *fields_or_indexes)\n        else:\n            if ctype.kind == \"pointer\":\n                raise TypeError(\"addressof(pointer)\")\n            offset = 0\n        ctypeptr = self._pointer_to(ctype)\n        return self._backend.rawaddressof(ctypeptr, cdata, offset)\n\n    def _typeoffsetof(self, ctype, field_or_index, *fields_or_indexes):\n        ctype, offset = self._backend.typeoffsetof(ctype, field_or_index)\n        for field1 in fields_or_indexes:\n            ctype, offset1 = self._backend.typeoffsetof(ctype, field1, 1)\n            offset += offset1\n        return ctype, offset\n\n    def include(self, ffi_to_include):\n        \"\"\"Includes the typedefs, structs, unions and enums defined\n        in another FFI instance.  Usage is similar to a #include in C,\n        where a part of the program might include types defined in\n        another part for its own usage.  Note that the include()\n        method has no effect on functions, constants and global\n        variables, which must anyway be accessed directly from the\n        lib object returned by the original FFI instance.\n        \"\"\"\n        if not isinstance(ffi_to_include, FFI):\n            raise TypeError(\"ffi.include() expects an argument that is also of\"\n                            \" type cffi.FFI, not %r\" % (\n                                type(ffi_to_include).__name__,))\n        if ffi_to_include is self:\n            raise ValueError(\"self.include(self)\")\n        with ffi_to_include._lock:\n            with self._lock:\n                self._parser.include(ffi_to_include._parser)\n                self._cdefsources.append('[')\n                self._cdefsources.extend(ffi_to_include._cdefsources)\n                self._cdefsources.append(']')\n                self._included_ffis.append(ffi_to_include)\n\n    def new_handle(self, x):\n        return self._backend.newp_handle(self.BVoidP, x)\n\n    def from_handle(self, x):\n        return self._backend.from_handle(x)\n\n    def release(self, x):\n        self._backend.release(x)\n\n    def set_unicode(self, enabled_flag):\n        \"\"\"Windows: if 'enabled_flag' is True, enable the UNICODE and\n        _UNICODE defines in C, and declare the types like TCHAR and LPTCSTR\n        to be (pointers to) wchar_t.  If 'enabled_flag' is False,\n        declare these types to be (pointers to) plain 8-bit characters.\n        This is mostly for backward compatibility; you usually want True.\n        \"\"\"\n        if self._windows_unicode is not None:\n            raise ValueError(\"set_unicode() can only be called once\")\n        enabled_flag = bool(enabled_flag)\n        if enabled_flag:\n            self.cdef(\"typedef wchar_t TBYTE;\"\n                      \"typedef wchar_t TCHAR;\"\n                      \"typedef const wchar_t *LPCTSTR;\"\n                      \"typedef const wchar_t *PCTSTR;\"\n                      \"typedef wchar_t *LPTSTR;\"\n                      \"typedef wchar_t *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        else:\n            self.cdef(\"typedef char TBYTE;\"\n                      \"typedef char TCHAR;\"\n                      \"typedef const char *LPCTSTR;\"\n                      \"typedef const char *PCTSTR;\"\n                      \"typedef char *LPTSTR;\"\n                      \"typedef char *PTSTR;\"\n                      \"typedef TBYTE *PTBYTE;\"\n                      \"typedef TCHAR *PTCHAR;\")\n        self._windows_unicode = enabled_flag\n\n    def _apply_windows_unicode(self, kwds):\n        defmacros = kwds.get('define_macros', ())\n        if not isinstance(defmacros, (list, tuple)):\n            raise TypeError(\"'define_macros' must be a list or tuple\")\n        defmacros = list(defmacros) + [('UNICODE', '1'),\n                                       ('_UNICODE', '1')]\n        kwds['define_macros'] = defmacros\n\n    def _apply_embedding_fix(self, kwds):\n        # must include an argument like \"-lpython2.7\" for the compiler\n        def ensure(key, value):\n            lst = kwds.setdefault(key, [])\n            if value not in lst:\n                lst.append(value)\n        #\n        if '__pypy__' in sys.builtin_module_names:\n            import os\n            if sys.platform == \"win32\":\n                # we need 'libpypy-c.lib'.  Current distributions of\n                # pypy (>= 4.1) contain it as 'libs/python27.lib'.\n                pythonlib = \"python{0[0]}{0[1]}\".format(sys.version_info)\n                if hasattr(sys, 'prefix'):\n                    ensure('library_dirs', os.path.join(sys.prefix, 'libs'))\n            else:\n                # we need 'libpypy-c.{so,dylib}', which should be by\n                # default located in 'sys.prefix/bin' for installed\n                # systems.\n                if sys.version_info < (3,):\n                    pythonlib = \"pypy-c\"\n                else:\n                    pythonlib = \"pypy3-c\"\n                if hasattr(sys, 'prefix'):\n                    ensure('library_dirs', os.path.join(sys.prefix, 'bin'))\n            # On uninstalled pypy's, the libpypy-c is typically found in\n            # .../pypy/goal/.\n            if hasattr(sys, 'prefix'):\n                ensure('library_dirs', os.path.join(sys.prefix, 'pypy', 'goal'))\n        else:\n            if sys.platform == \"win32\":\n                template = \"python%d%d\"\n                if hasattr(sys, 'gettotalrefcount'):\n                    template += '_d'\n            else:\n                try:\n                    import sysconfig\n                except ImportError:    # 2.6\n                    from cffi._shimmed_dist_utils import sysconfig\n                template = \"python%d.%d\"\n                if sysconfig.get_config_var('DEBUG_EXT'):\n                    template += sysconfig.get_config_var('DEBUG_EXT')\n            pythonlib = (template %\n                    (sys.hexversion >> 24, (sys.hexversion >> 16) & 0xff))\n            if hasattr(sys, 'abiflags'):\n                pythonlib += sys.abiflags\n        ensure('libraries', pythonlib)\n        if sys.platform == \"win32\":\n            ensure('extra_link_args', '/MANIFEST')\n\n    def set_source(self, module_name, source, source_extension='.c', **kwds):\n        import os\n        if hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() cannot be called several times \"\n                             \"per ffi object\")\n        if not isinstance(module_name, basestring):\n            raise TypeError(\"'module_name' must be a string\")\n        if os.sep in module_name or (os.altsep and os.altsep in module_name):\n            raise ValueError(\"'module_name' must not contain '/': use a dotted \"\n                             \"name to make a 'package.module' location\")\n        self._assigned_source = (str(module_name), source,\n                                 source_extension, kwds)\n\n    def set_source_pkgconfig(self, module_name, pkgconfig_libs, source,\n                             source_extension='.c', **kwds):\n        from . import pkgconfig\n        if not isinstance(pkgconfig_libs, list):\n            raise TypeError(\"the pkgconfig_libs argument must be a list \"\n                            \"of package names\")\n        kwds2 = pkgconfig.flags_from_pkgconfig(pkgconfig_libs)\n        pkgconfig.merge_flags(kwds, kwds2)\n        self.set_source(module_name, source, source_extension, **kwds)\n\n    def distutils_extension(self, tmpdir='build', verbose=True):\n        from cffi._shimmed_dist_utils import mkpath\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            if hasattr(self, 'verifier'):     # fallback, 'tmpdir' ignored\n                return self.verifier.get_extension()\n            raise ValueError(\"set_source() must be called before\"\n                             \" distutils_extension()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"distutils_extension() is only for C extension \"\n                            \"modules, not for dlopen()-style pure Python \"\n                            \"modules\")\n        mkpath(tmpdir)\n        ext, updated = recompile(self, module_name,\n                                 source, tmpdir=tmpdir, extradir=tmpdir,\n                                 source_extension=source_extension,\n                                 call_c_compiler=False, **kwds)\n        if verbose:\n            if updated:\n                sys.stderr.write(\"regenerated: %r\\n\" % (ext.sources[0],))\n            else:\n                sys.stderr.write(\"not modified: %r\\n\" % (ext.sources[0],))\n        return ext\n\n    def emit_c_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is None:\n            raise TypeError(\"emit_c_code() is only for C extension modules, \"\n                            \"not for dlopen()-style pure Python modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def emit_python_code(self, filename):\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before emit_c_code()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        if source is not None:\n            raise TypeError(\"emit_python_code() is only for dlopen()-style \"\n                            \"pure Python modules, not for C extension modules\")\n        recompile(self, module_name, source,\n                  c_file=filename, call_c_compiler=False, **kwds)\n\n    def compile(self, tmpdir='.', verbose=0, target=None, debug=None):\n        \"\"\"The 'target' argument gives the final file name of the\n        compiled DLL.  Use '*' to force distutils' choice, suitable for\n        regular CPython C API modules.  Use a file name ending in '.*'\n        to ask for the system's default extension for dynamic libraries\n        (.so/.dll/.dylib).\n\n        The default is '*' when building a non-embedded C API extension,\n        and (module_name + '.*') when building an embedded library.\n        \"\"\"\n        from .recompiler import recompile\n        #\n        if not hasattr(self, '_assigned_source'):\n            raise ValueError(\"set_source() must be called before compile()\")\n        module_name, source, source_extension, kwds = self._assigned_source\n        return recompile(self, module_name, source, tmpdir=tmpdir,\n                         target=target, source_extension=source_extension,\n                         compiler_verbose=verbose, debug=debug, **kwds)\n\n    def init_once(self, func, tag):\n        # Read _init_once_cache[tag], which is either (False, lock) if\n        # we're calling the function now in some thread, or (True, result).\n        # Don't call setdefault() in most cases, to avoid allocating and\n        # immediately freeing a lock; but still use setdefaut() to avoid\n        # races.\n        try:\n            x = self._init_once_cache[tag]\n        except KeyError:\n            x = self._init_once_cache.setdefault(tag, (False, allocate_lock()))\n        # Common case: we got (True, result), so we return the result.\n        if x[0]:\n            return x[1]\n        # Else, it's a lock.  Acquire it to serialize the following tests.\n        with x[1]:\n            # Read again from _init_once_cache the current status.\n            x = self._init_once_cache[tag]\n            if x[0]:\n                return x[1]\n            # Call the function and store the result back.\n            result = func()\n            self._init_once_cache[tag] = (True, result)\n        return result\n\n    def embedding_init_code(self, pysource):\n        if self._embedding:\n            raise ValueError(\"embedding_init_code() can only be called once\")\n        # fix 'pysource' before it gets dumped into the C file:\n        # - remove empty lines at the beginning, so it starts at \"line 1\"\n        # - dedent, if all non-empty lines are indented\n        # - check for SyntaxErrors\n        import re\n        match = re.match(r'\\s*\\n', pysource)\n        if match:\n            pysource = pysource[match.end():]\n        lines = pysource.splitlines() or ['']\n        prefix = re.match(r'\\s*', lines[0]).group()\n        for i in range(1, len(lines)):\n            line = lines[i]\n            if line.rstrip():\n                while not line.startswith(prefix):\n                    prefix = prefix[:-1]\n        i = len(prefix)\n        lines = [line[i:]+'\\n' for line in lines]\n        pysource = ''.join(lines)\n        #\n        compile(pysource, \"cffi_init\", \"exec\")\n        #\n        self._embedding = pysource\n\n    def def_extern(self, *args, **kwds):\n        raise ValueError(\"ffi.def_extern() is only available on API-mode FFI \"\n                         \"objects\")\n\n    def list_types(self):\n        \"\"\"Returns the user type names known to this FFI instance.\n        This returns a tuple containing three lists of names:\n        (typedef_names, names_of_structs, names_of_unions)\n        \"\"\"\n        typedefs = []\n        structs = []\n        unions = []\n        for key in self._parser._declarations:\n            if key.startswith('typedef '):\n                typedefs.append(key[8:])\n            elif key.startswith('struct '):\n                structs.append(key[7:])\n            elif key.startswith('union '):\n                unions.append(key[6:])\n        typedefs.sort()\n        structs.sort()\n        unions.sort()\n        return (typedefs, structs, unions)\n\n\ndef _load_backend_lib(backend, name, flags):\n    import os\n    if not isinstance(name, basestring):\n        if sys.platform != \"win32\" or name is not None:\n            return backend.load_library(name, flags)\n        name = \"c\"    # Windows: load_library(None) fails, but this works\n                      # on Python 2 (backward compatibility hack only)\n    first_error = None\n    if '.' in name or '/' in name or os.sep in name:\n        try:\n            return backend.load_library(name, flags)\n        except OSError as e:\n            first_error = e\n    import ctypes.util\n    path = ctypes.util.find_library(name)\n    if path is None:\n        if name == \"c\" and sys.platform == \"win32\" and sys.version_info >= (3,):\n            raise OSError(\"dlopen(None) cannot work on Windows for Python 3 \"\n                          \"(see http://bugs.python.org/issue23606)\")\n        msg = (\"ctypes.util.find_library() did not manage \"\n               \"to locate a library called %r\" % (name,))\n        if first_error is not None:\n            msg = \"%s.  Additionally, %s\" % (first_error, msg)\n        raise OSError(msg)\n    return backend.load_library(path, flags)\n\ndef _make_ffi_library(ffi, libname, flags):\n    backend = ffi._backend\n    backendlib = _load_backend_lib(backend, libname, flags)\n    #\n    def accessor_function(name):\n        key = 'function ' + name\n        tp, _ = ffi._parser._declarations[key]\n        BType = ffi._get_cached_btype(tp)\n        value = backendlib.load_function(BType, name)\n        library.__dict__[name] = value\n    #\n    def accessor_variable(name):\n        key = 'variable ' + name\n        tp, _ = ffi._parser._declarations[key]\n        BType = ffi._get_cached_btype(tp)\n        read_variable = backendlib.read_variable\n        write_variable = backendlib.write_variable\n        setattr(FFILibrary, name, property(\n            lambda self: read_variable(BType, name),\n            lambda self, value: write_variable(BType, name, value)))\n    #\n    def addressof_var(name):\n        try:\n            return addr_variables[name]\n        except KeyError:\n            with ffi._lock:\n                if name not in addr_variables:\n                    key = 'variable ' + name\n                    tp, _ = ffi._parser._declarations[key]\n                    BType = ffi._get_cached_btype(tp)\n                    if BType.kind != 'array':\n                        BType = model.pointer_cache(ffi, BType)\n                    p = backendlib.load_function(BType, name)\n                    addr_variables[name] = p\n            return addr_variables[name]\n    #\n    def accessor_constant(name):\n        raise NotImplementedError(\"non-integer constant '%s' cannot be \"\n                                  \"accessed from a dlopen() library\" % (name,))\n    #\n    def accessor_int_constant(name):\n        library.__dict__[name] = ffi._parser._int_constants[name]\n    #\n    accessors = {}\n    accessors_version = [False]\n    addr_variables = {}\n    #\n    def update_accessors():\n        if accessors_version[0] is ffi._cdef_version:\n            return\n        #\n        for key, (tp, _) in ffi._parser._declarations.items():\n            if not isinstance(tp, model.EnumType):\n                tag, name = key.split(' ', 1)\n                if tag == 'function':\n                    accessors[name] = accessor_function\n                elif tag == 'variable':\n                    accessors[name] = accessor_variable\n                elif tag == 'constant':\n                    accessors[name] = accessor_constant\n            else:\n                for i, enumname in enumerate(tp.enumerators):\n                    def accessor_enum(name, tp=tp, i=i):\n                        tp.check_not_partial()\n                        library.__dict__[name] = tp.enumvalues[i]\n                    accessors[enumname] = accessor_enum\n        for name in ffi._parser._int_constants:\n            accessors.setdefault(name, accessor_int_constant)\n        accessors_version[0] = ffi._cdef_version\n    #\n    def make_accessor(name):\n        with ffi._lock:\n            if name in library.__dict__ or name in FFILibrary.__dict__:\n                return    # added by another thread while waiting for the lock\n            if name not in accessors:\n                update_accessors()\n                if name not in accessors:\n                    raise AttributeError(name)\n            accessors[name](name)\n    #\n    class FFILibrary(object):\n        def __getattr__(self, name):\n            make_accessor(name)\n            return getattr(self, name)\n        def __setattr__(self, name, value):\n            try:\n                property = getattr(self.__class__, name)\n            except AttributeError:\n                make_accessor(name)\n                setattr(self, name, value)\n            else:\n                property.__set__(self, value)\n        def __dir__(self):\n            with ffi._lock:\n                update_accessors()\n                return accessors.keys()\n        def __addressof__(self, name):\n            if name in library.__dict__:\n                return library.__dict__[name]\n            if name in FFILibrary.__dict__:\n                return addressof_var(name)\n            make_accessor(name)\n            if name in library.__dict__:\n                return library.__dict__[name]\n            if name in FFILibrary.__dict__:\n                return addressof_var(name)\n            raise AttributeError(\"cffi library has no function or \"\n                                 \"global variable named '%s'\" % (name,))\n        def __cffi_close__(self):\n            backendlib.close_lib()\n            self.__dict__.clear()\n    #\n    if isinstance(libname, basestring):\n        try:\n            if not isinstance(libname, str):    # unicode, on Python 2\n                libname = libname.encode('utf-8')\n            FFILibrary.__name__ = 'FFILibrary_%s' % libname\n        except UnicodeError:\n            pass\n    library = FFILibrary()\n    return library, library.__dict__\n\ndef _builtin_function_type(func):\n    # a hack to make at least ffi.typeof(builtin_function) work,\n    # if the builtin function was obtained by 'vengine_cpy'.\n    import sys\n    try:\n        module = sys.modules[func.__module__]\n        ffi = module._cffi_original_ffi\n        types_of_builtin_funcs = module._cffi_types_of_builtin_funcs\n        tp = types_of_builtin_funcs[func]\n    except (KeyError, AttributeError, TypeError):\n        return None\n    else:\n        with ffi._lock:\n            return ffi._get_cached_btype(tp)\n", "src/cffi/cparser.py": "from . import model\nfrom .commontypes import COMMON_TYPES, resolve_common_type\nfrom .error import FFIError, CDefError\ntry:\n    from . import _pycparser as pycparser\nexcept ImportError:\n    import pycparser\nimport weakref, re, sys\n\ntry:\n    if sys.version_info < (3,):\n        import thread as _thread\n    else:\n        import _thread\n    lock = _thread.allocate_lock()\nexcept ImportError:\n    lock = None\n\ndef _workaround_for_static_import_finders():\n    # Issue #392: packaging tools like cx_Freeze can not find these\n    # because pycparser uses exec dynamic import.  This is an obscure\n    # workaround.  This function is never called.\n    import pycparser.yacctab\n    import pycparser.lextab\n\nCDEF_SOURCE_STRING = \"<cdef source string>\"\n_r_comment = re.compile(r\"/\\*.*?\\*/|//([^\\n\\\\]|\\\\.)*?$\",\n                        re.DOTALL | re.MULTILINE)\n_r_define  = re.compile(r\"^\\s*#\\s*define\\s+([A-Za-z_][A-Za-z_0-9]*)\"\n                        r\"\\b((?:[^\\n\\\\]|\\\\.)*?)$\",\n                        re.DOTALL | re.MULTILINE)\n_r_line_directive = re.compile(r\"^[ \\t]*#[ \\t]*(?:line|\\d+)\\b.*$\", re.MULTILINE)\n_r_partial_enum = re.compile(r\"=\\s*\\.\\.\\.\\s*[,}]|\\.\\.\\.\\s*\\}\")\n_r_enum_dotdotdot = re.compile(r\"__dotdotdot\\d+__$\")\n_r_partial_array = re.compile(r\"\\[\\s*\\.\\.\\.\\s*\\]\")\n_r_words = re.compile(r\"\\w+|\\S\")\n_parser_cache = None\n_r_int_literal = re.compile(r\"-?0?x?[0-9a-f]+[lu]*$\", re.IGNORECASE)\n_r_stdcall1 = re.compile(r\"\\b(__stdcall|WINAPI)\\b\")\n_r_stdcall2 = re.compile(r\"[(]\\s*(__stdcall|WINAPI)\\b\")\n_r_cdecl = re.compile(r\"\\b__cdecl\\b\")\n_r_extern_python = re.compile(r'\\bextern\\s*\"'\n                              r'(Python|Python\\s*\\+\\s*C|C\\s*\\+\\s*Python)\"\\s*.')\n_r_star_const_space = re.compile(       # matches \"* const \"\n    r\"[*]\\s*((const|volatile|restrict)\\b\\s*)+\")\n_r_int_dotdotdot = re.compile(r\"(\\b(int|long|short|signed|unsigned|char)\\s*)+\"\n                              r\"\\.\\.\\.\")\n_r_float_dotdotdot = re.compile(r\"\\b(double|float)\\s*\\.\\.\\.\")\n\ndef _get_parser():\n    global _parser_cache\n    if _parser_cache is None:\n        _parser_cache = pycparser.CParser()\n    return _parser_cache\n\ndef _workaround_for_old_pycparser(csource):\n    # Workaround for a pycparser issue (fixed between pycparser 2.10 and\n    # 2.14): \"char*const***\" gives us a wrong syntax tree, the same as\n    # for \"char***(*const)\".  This means we can't tell the difference\n    # afterwards.  But \"char(*const(***))\" gives us the right syntax\n    # tree.  The issue only occurs if there are several stars in\n    # sequence with no parenthesis inbetween, just possibly qualifiers.\n    # Attempt to fix it by adding some parentheses in the source: each\n    # time we see \"* const\" or \"* const *\", we add an opening\n    # parenthesis before each star---the hard part is figuring out where\n    # to close them.\n    parts = []\n    while True:\n        match = _r_star_const_space.search(csource)\n        if not match:\n            break\n        #print repr(''.join(parts)+csource), '=>',\n        parts.append(csource[:match.start()])\n        parts.append('('); closing = ')'\n        parts.append(match.group())   # e.g. \"* const \"\n        endpos = match.end()\n        if csource.startswith('*', endpos):\n            parts.append('('); closing += ')'\n        level = 0\n        i = endpos\n        while i < len(csource):\n            c = csource[i]\n            if c == '(':\n                level += 1\n            elif c == ')':\n                if level == 0:\n                    break\n                level -= 1\n            elif c in ',;=':\n                if level == 0:\n                    break\n            i += 1\n        csource = csource[endpos:i] + closing + csource[i:]\n        #print repr(''.join(parts)+csource)\n    parts.append(csource)\n    return ''.join(parts)\n\ndef _preprocess_extern_python(csource):\n    # input: `extern \"Python\" int foo(int);` or\n    #        `extern \"Python\" { int foo(int); }`\n    # output:\n    #     void __cffi_extern_python_start;\n    #     int foo(int);\n    #     void __cffi_extern_python_stop;\n    #\n    # input: `extern \"Python+C\" int foo(int);`\n    # output:\n    #     void __cffi_extern_python_plus_c_start;\n    #     int foo(int);\n    #     void __cffi_extern_python_stop;\n    parts = []\n    while True:\n        match = _r_extern_python.search(csource)\n        if not match:\n            break\n        endpos = match.end() - 1\n        #print\n        #print ''.join(parts)+csource\n        #print '=>'\n        parts.append(csource[:match.start()])\n        if 'C' in match.group(1):\n            parts.append('void __cffi_extern_python_plus_c_start; ')\n        else:\n            parts.append('void __cffi_extern_python_start; ')\n        if csource[endpos] == '{':\n            # grouping variant\n            closing = csource.find('}', endpos)\n            if closing < 0:\n                raise CDefError(\"'extern \\\"Python\\\" {': no '}' found\")\n            if csource.find('{', endpos + 1, closing) >= 0:\n                raise NotImplementedError(\"cannot use { } inside a block \"\n                                          \"'extern \\\"Python\\\" { ... }'\")\n            parts.append(csource[endpos+1:closing])\n            csource = csource[closing+1:]\n        else:\n            # non-grouping variant\n            semicolon = csource.find(';', endpos)\n            if semicolon < 0:\n                raise CDefError(\"'extern \\\"Python\\\": no ';' found\")\n            parts.append(csource[endpos:semicolon+1])\n            csource = csource[semicolon+1:]\n        parts.append(' void __cffi_extern_python_stop;')\n        #print ''.join(parts)+csource\n        #print\n    parts.append(csource)\n    return ''.join(parts)\n\ndef _warn_for_string_literal(csource):\n    if '\"' not in csource:\n        return\n    for line in csource.splitlines():\n        if '\"' in line and not line.lstrip().startswith('#'):\n            import warnings\n            warnings.warn(\"String literal found in cdef() or type source. \"\n                          \"String literals are ignored here, but you should \"\n                          \"remove them anyway because some character sequences \"\n                          \"confuse pre-parsing.\")\n            break\n\ndef _warn_for_non_extern_non_static_global_variable(decl):\n    if not decl.storage:\n        import warnings\n        warnings.warn(\"Global variable '%s' in cdef(): for consistency \"\n                      \"with C it should have a storage class specifier \"\n                      \"(usually 'extern')\" % (decl.name,))\n\ndef _remove_line_directives(csource):\n    # _r_line_directive matches whole lines, without the final \\n, if they\n    # start with '#line' with some spacing allowed, or '#NUMBER'.  This\n    # function stores them away and replaces them with exactly the string\n    # '#line@N', where N is the index in the list 'line_directives'.\n    line_directives = []\n    def replace(m):\n        i = len(line_directives)\n        line_directives.append(m.group())\n        return '#line@%d' % i\n    csource = _r_line_directive.sub(replace, csource)\n    return csource, line_directives\n\ndef _put_back_line_directives(csource, line_directives):\n    def replace(m):\n        s = m.group()\n        if not s.startswith('#line@'):\n            raise AssertionError(\"unexpected #line directive \"\n                                 \"(should have been processed and removed\")\n        return line_directives[int(s[6:])]\n    return _r_line_directive.sub(replace, csource)\n\ndef _preprocess(csource):\n    # First, remove the lines of the form '#line N \"filename\"' because\n    # the \"filename\" part could confuse the rest\n    csource, line_directives = _remove_line_directives(csource)\n    # Remove comments.  NOTE: this only work because the cdef() section\n    # should not contain any string literals (except in line directives)!\n    def replace_keeping_newlines(m):\n        return ' ' + m.group().count('\\n') * '\\n'\n    csource = _r_comment.sub(replace_keeping_newlines, csource)\n    # Remove the \"#define FOO x\" lines\n    macros = {}\n    for match in _r_define.finditer(csource):\n        macroname, macrovalue = match.groups()\n        macrovalue = macrovalue.replace('\\\\\\n', '').strip()\n        macros[macroname] = macrovalue\n    csource = _r_define.sub('', csource)\n    #\n    if pycparser.__version__ < '2.14':\n        csource = _workaround_for_old_pycparser(csource)\n    #\n    # BIG HACK: replace WINAPI or __stdcall with \"volatile const\".\n    # It doesn't make sense for the return type of a function to be\n    # \"volatile volatile const\", so we abuse it to detect __stdcall...\n    # Hack number 2 is that \"int(volatile *fptr)();\" is not valid C\n    # syntax, so we place the \"volatile\" before the opening parenthesis.\n    csource = _r_stdcall2.sub(' volatile volatile const(', csource)\n    csource = _r_stdcall1.sub(' volatile volatile const ', csource)\n    csource = _r_cdecl.sub(' ', csource)\n    #\n    # Replace `extern \"Python\"` with start/end markers\n    csource = _preprocess_extern_python(csource)\n    #\n    # Now there should not be any string literal left; warn if we get one\n    _warn_for_string_literal(csource)\n    #\n    # Replace \"[...]\" with \"[__dotdotdotarray__]\"\n    csource = _r_partial_array.sub('[__dotdotdotarray__]', csource)\n    #\n    # Replace \"...}\" with \"__dotdotdotNUM__}\".  This construction should\n    # occur only at the end of enums; at the end of structs we have \"...;}\"\n    # and at the end of vararg functions \"...);\".  Also replace \"=...[,}]\"\n    # with \",__dotdotdotNUM__[,}]\": this occurs in the enums too, when\n    # giving an unknown value.\n    matches = list(_r_partial_enum.finditer(csource))\n    for number, match in enumerate(reversed(matches)):\n        p = match.start()\n        if csource[p] == '=':\n            p2 = csource.find('...', p, match.end())\n            assert p2 > p\n            csource = '%s,__dotdotdot%d__ %s' % (csource[:p], number,\n                                                 csource[p2+3:])\n        else:\n            assert csource[p:p+3] == '...'\n            csource = '%s __dotdotdot%d__ %s' % (csource[:p], number,\n                                                 csource[p+3:])\n    # Replace \"int ...\" or \"unsigned long int...\" with \"__dotdotdotint__\"\n    csource = _r_int_dotdotdot.sub(' __dotdotdotint__ ', csource)\n    # Replace \"float ...\" or \"double...\" with \"__dotdotdotfloat__\"\n    csource = _r_float_dotdotdot.sub(' __dotdotdotfloat__ ', csource)\n    # Replace all remaining \"...\" with the same name, \"__dotdotdot__\",\n    # which is declared with a typedef for the purpose of C parsing.\n    csource = csource.replace('...', ' __dotdotdot__ ')\n    # Finally, put back the line directives\n    csource = _put_back_line_directives(csource, line_directives)\n    return csource, macros\n\ndef _common_type_names(csource):\n    # Look in the source for what looks like usages of types from the\n    # list of common types.  A \"usage\" is approximated here as the\n    # appearance of the word, minus a \"definition\" of the type, which\n    # is the last word in a \"typedef\" statement.  Approximative only\n    # but should be fine for all the common types.\n    look_for_words = set(COMMON_TYPES)\n    look_for_words.add(';')\n    look_for_words.add(',')\n    look_for_words.add('(')\n    look_for_words.add(')')\n    look_for_words.add('typedef')\n    words_used = set()\n    is_typedef = False\n    paren = 0\n    previous_word = ''\n    for word in _r_words.findall(csource):\n        if word in look_for_words:\n            if word == ';':\n                if is_typedef:\n                    words_used.discard(previous_word)\n                    look_for_words.discard(previous_word)\n                    is_typedef = False\n            elif word == 'typedef':\n                is_typedef = True\n                paren = 0\n            elif word == '(':\n                paren += 1\n            elif word == ')':\n                paren -= 1\n            elif word == ',':\n                if is_typedef and paren == 0:\n                    words_used.discard(previous_word)\n                    look_for_words.discard(previous_word)\n            else:   # word in COMMON_TYPES\n                words_used.add(word)\n        previous_word = word\n    return words_used\n\n\nclass Parser(object):\n\n    def __init__(self):\n        self._declarations = {}\n        self._included_declarations = set()\n        self._anonymous_counter = 0\n        self._structnode2type = weakref.WeakKeyDictionary()\n        self._options = {}\n        self._int_constants = {}\n        self._recomplete = []\n        self._uses_new_feature = None\n\n    def _parse(self, csource):\n        csource, macros = _preprocess(csource)\n        # XXX: for more efficiency we would need to poke into the\n        # internals of CParser...  the following registers the\n        # typedefs, because their presence or absence influences the\n        # parsing itself (but what they are typedef'ed to plays no role)\n        ctn = _common_type_names(csource)\n        typenames = []\n        for name in sorted(self._declarations):\n            if name.startswith('typedef '):\n                name = name[8:]\n                typenames.append(name)\n                ctn.discard(name)\n        typenames += sorted(ctn)\n        #\n        csourcelines = []\n        csourcelines.append('# 1 \"<cdef automatic initialization code>\"')\n        for typename in typenames:\n            csourcelines.append('typedef int %s;' % typename)\n        csourcelines.append('typedef int __dotdotdotint__, __dotdotdotfloat__,'\n                            ' __dotdotdot__;')\n        # this forces pycparser to consider the following in the file\n        # called <cdef source string> from line 1\n        csourcelines.append('# 1 \"%s\"' % (CDEF_SOURCE_STRING,))\n        csourcelines.append(csource)\n        csourcelines.append('')   # see test_missing_newline_bug\n        fullcsource = '\\n'.join(csourcelines)\n        if lock is not None:\n            lock.acquire()     # pycparser is not thread-safe...\n        try:\n            ast = _get_parser().parse(fullcsource)\n        except pycparser.c_parser.ParseError as e:\n            self.convert_pycparser_error(e, csource)\n        finally:\n            if lock is not None:\n                lock.release()\n        # csource will be used to find buggy source text\n        return ast, macros, csource\n\n    def _convert_pycparser_error(self, e, csource):\n        # xxx look for \"<cdef source string>:NUM:\" at the start of str(e)\n        # and interpret that as a line number.  This will not work if\n        # the user gives explicit ``# NUM \"FILE\"`` directives.\n        line = None\n        msg = str(e)\n        match = re.match(r\"%s:(\\d+):\" % (CDEF_SOURCE_STRING,), msg)\n        if match:\n            linenum = int(match.group(1), 10)\n            csourcelines = csource.splitlines()\n            if 1 <= linenum <= len(csourcelines):\n                line = csourcelines[linenum-1]\n        return line\n\n    def convert_pycparser_error(self, e, csource):\n        line = self._convert_pycparser_error(e, csource)\n\n        msg = str(e)\n        if line:\n            msg = 'cannot parse \"%s\"\\n%s' % (line.strip(), msg)\n        else:\n            msg = 'parse error\\n%s' % (msg,)\n        raise CDefError(msg)\n\n    def parse(self, csource, override=False, packed=False, pack=None,\n                    dllexport=False):\n        if packed:\n            if packed != True:\n                raise ValueError(\"'packed' should be False or True; use \"\n                                 \"'pack' to give another value\")\n            if pack:\n                raise ValueError(\"cannot give both 'pack' and 'packed'\")\n            pack = 1\n        elif pack:\n            if pack & (pack - 1):\n                raise ValueError(\"'pack' must be a power of two, not %r\" %\n                    (pack,))\n        else:\n            pack = 0\n        prev_options = self._options\n        try:\n            self._options = {'override': override,\n                             'packed': pack,\n                             'dllexport': dllexport}\n            self._internal_parse(csource)\n        finally:\n            self._options = prev_options\n\n    def _internal_parse(self, csource):\n        ast, macros, csource = self._parse(csource)\n        # add the macros\n        self._process_macros(macros)\n        # find the first \"__dotdotdot__\" and use that as a separator\n        # between the repeated typedefs and the real csource\n        iterator = iter(ast.ext)\n        for decl in iterator:\n            if decl.name == '__dotdotdot__':\n                break\n        else:\n            assert 0\n        current_decl = None\n        #\n        try:\n            self._inside_extern_python = '__cffi_extern_python_stop'\n            for decl in iterator:\n                current_decl = decl\n                if isinstance(decl, pycparser.c_ast.Decl):\n                    self._parse_decl(decl)\n                elif isinstance(decl, pycparser.c_ast.Typedef):\n                    if not decl.name:\n                        raise CDefError(\"typedef does not declare any name\",\n                                        decl)\n                    quals = 0\n                    if (isinstance(decl.type.type, pycparser.c_ast.IdentifierType) and\n                            decl.type.type.names[-1].startswith('__dotdotdot')):\n                        realtype = self._get_unknown_type(decl)\n                    elif (isinstance(decl.type, pycparser.c_ast.PtrDecl) and\n                          isinstance(decl.type.type, pycparser.c_ast.TypeDecl) and\n                          isinstance(decl.type.type.type,\n                                     pycparser.c_ast.IdentifierType) and\n                          decl.type.type.type.names[-1].startswith('__dotdotdot')):\n                        realtype = self._get_unknown_ptr_type(decl)\n                    else:\n                        realtype, quals = self._get_type_and_quals(\n                            decl.type, name=decl.name, partial_length_ok=True,\n                            typedef_example=\"*(%s *)0\" % (decl.name,))\n                    self._declare('typedef ' + decl.name, realtype, quals=quals)\n                elif decl.__class__.__name__ == 'Pragma':\n                    # skip pragma, only in pycparser 2.15\n                    import warnings\n                    warnings.warn(\n                        \"#pragma in cdef() are entirely ignored. \"\n                        \"They should be removed for now, otherwise your \"\n                        \"code might behave differently in a future version \"\n                        \"of CFFI if #pragma support gets added. Note that \"\n                        \"'#pragma pack' needs to be replaced with the \"\n                        \"'packed' keyword argument to cdef().\")\n                else:\n                    raise CDefError(\"unexpected <%s>: this construct is valid \"\n                                    \"C but not valid in cdef()\" %\n                                    decl.__class__.__name__, decl)\n        except CDefError as e:\n            if len(e.args) == 1:\n                e.args = e.args + (current_decl,)\n            raise\n        except FFIError as e:\n            msg = self._convert_pycparser_error(e, csource)\n            if msg:\n                e.args = (e.args[0] + \"\\n    *** Err: %s\" % msg,)\n            raise\n\n    def _add_constants(self, key, val):\n        if key in self._int_constants:\n            if self._int_constants[key] == val:\n                return     # ignore identical double declarations\n            raise FFIError(\n                \"multiple declarations of constant: %s\" % (key,))\n        self._int_constants[key] = val\n\n    def _add_integer_constant(self, name, int_str):\n        int_str = int_str.lower().rstrip(\"ul\")\n        neg = int_str.startswith('-')\n        if neg:\n            int_str = int_str[1:]\n        # \"010\" is not valid oct in py3\n        if (int_str.startswith(\"0\") and int_str != '0'\n                and not int_str.startswith(\"0x\")):\n            int_str = \"0o\" + int_str[1:]\n        pyvalue = int(int_str, 0)\n        if neg:\n            pyvalue = -pyvalue\n        self._add_constants(name, pyvalue)\n        self._declare('macro ' + name, pyvalue)\n\n    def _process_macros(self, macros):\n        for key, value in macros.items():\n            value = value.strip()\n            if _r_int_literal.match(value):\n                self._add_integer_constant(key, value)\n            elif value == '...':\n                self._declare('macro ' + key, value)\n            else:\n                raise CDefError(\n                    'only supports one of the following syntax:\\n'\n                    '  #define %s ...     (literally dot-dot-dot)\\n'\n                    '  #define %s NUMBER  (with NUMBER an integer'\n                                    ' constant, decimal/hex/octal)\\n'\n                    'got:\\n'\n                    '  #define %s %s'\n                    % (key, key, key, value))\n\n    def _declare_function(self, tp, quals, decl):\n        tp = self._get_type_pointer(tp, quals)\n        if self._options.get('dllexport'):\n            tag = 'dllexport_python '\n        elif self._inside_extern_python == '__cffi_extern_python_start':\n            tag = 'extern_python '\n        elif self._inside_extern_python == '__cffi_extern_python_plus_c_start':\n            tag = 'extern_python_plus_c '\n        else:\n            tag = 'function '\n        self._declare(tag + decl.name, tp)\n\n    def _parse_decl(self, decl):\n        node = decl.type\n        if isinstance(node, pycparser.c_ast.FuncDecl):\n            tp, quals = self._get_type_and_quals(node, name=decl.name)\n            assert isinstance(tp, model.RawFunctionType)\n            self._declare_function(tp, quals, decl)\n        else:\n            if isinstance(node, pycparser.c_ast.Struct):\n                self._get_struct_union_enum_type('struct', node)\n            elif isinstance(node, pycparser.c_ast.Union):\n                self._get_struct_union_enum_type('union', node)\n            elif isinstance(node, pycparser.c_ast.Enum):\n                self._get_struct_union_enum_type('enum', node)\n            elif not decl.name:\n                raise CDefError(\"construct does not declare any variable\",\n                                decl)\n            #\n            if decl.name:\n                tp, quals = self._get_type_and_quals(node,\n                                                     partial_length_ok=True)\n                if tp.is_raw_function:\n                    self._declare_function(tp, quals, decl)\n                elif (tp.is_integer_type() and\n                        hasattr(decl, 'init') and\n                        hasattr(decl.init, 'value') and\n                        _r_int_literal.match(decl.init.value)):\n                    self._add_integer_constant(decl.name, decl.init.value)\n                elif (tp.is_integer_type() and\n                        isinstance(decl.init, pycparser.c_ast.UnaryOp) and\n                        decl.init.op == '-' and\n                        hasattr(decl.init.expr, 'value') and\n                        _r_int_literal.match(decl.init.expr.value)):\n                    self._add_integer_constant(decl.name,\n                                               '-' + decl.init.expr.value)\n                elif (tp is model.void_type and\n                      decl.name.startswith('__cffi_extern_python_')):\n                    # hack: `extern \"Python\"` in the C source is replaced\n                    # with \"void __cffi_extern_python_start;\" and\n                    # \"void __cffi_extern_python_stop;\"\n                    self._inside_extern_python = decl.name\n                else:\n                    if self._inside_extern_python !='__cffi_extern_python_stop':\n                        raise CDefError(\n                            \"cannot declare constants or \"\n                            \"variables with 'extern \\\"Python\\\"'\")\n                    if (quals & model.Q_CONST) and not tp.is_array_type:\n                        self._declare('constant ' + decl.name, tp, quals=quals)\n                    else:\n                        _warn_for_non_extern_non_static_global_variable(decl)\n                        self._declare('variable ' + decl.name, tp, quals=quals)\n\n    def parse_type(self, cdecl):\n        return self.parse_type_and_quals(cdecl)[0]\n\n    def parse_type_and_quals(self, cdecl):\n        ast, macros = self._parse('void __dummy(\\n%s\\n);' % cdecl)[:2]\n        assert not macros\n        exprnode = ast.ext[-1].type.args.params[0]\n        if isinstance(exprnode, pycparser.c_ast.ID):\n            raise CDefError(\"unknown identifier '%s'\" % (exprnode.name,))\n        return self._get_type_and_quals(exprnode.type)\n\n    def _declare(self, name, obj, included=False, quals=0):\n        if name in self._declarations:\n            prevobj, prevquals = self._declarations[name]\n            if prevobj is obj and prevquals == quals:\n                return\n            if not self._options.get('override'):\n                raise FFIError(\n                    \"multiple declarations of %s (for interactive usage, \"\n                    \"try cdef(xx, override=True))\" % (name,))\n        assert '__dotdotdot__' not in name.split()\n        self._declarations[name] = (obj, quals)\n        if included:\n            self._included_declarations.add(obj)\n\n    def _extract_quals(self, type):\n        quals = 0\n        if isinstance(type, (pycparser.c_ast.TypeDecl,\n                             pycparser.c_ast.PtrDecl)):\n            if 'const' in type.quals:\n                quals |= model.Q_CONST\n            if 'volatile' in type.quals:\n                quals |= model.Q_VOLATILE\n            if 'restrict' in type.quals:\n                quals |= model.Q_RESTRICT\n        return quals\n\n    def _get_type_pointer(self, type, quals, declname=None):\n        if isinstance(type, model.RawFunctionType):\n            return type.as_function_pointer()\n        if (isinstance(type, model.StructOrUnionOrEnum) and\n                type.name.startswith('$') and type.name[1:].isdigit() and\n                type.forcename is None and declname is not None):\n            return model.NamedPointerType(type, declname, quals)\n        return model.PointerType(type, quals)\n\n    def _get_type_and_quals(self, typenode, name=None, partial_length_ok=False,\n                            typedef_example=None):\n        # first, dereference typedefs, if we have it already parsed, we're good\n        if (isinstance(typenode, pycparser.c_ast.TypeDecl) and\n            isinstance(typenode.type, pycparser.c_ast.IdentifierType) and\n            len(typenode.type.names) == 1 and\n            ('typedef ' + typenode.type.names[0]) in self._declarations):\n            tp, quals = self._declarations['typedef ' + typenode.type.names[0]]\n            quals |= self._extract_quals(typenode)\n            return tp, quals\n        #\n        if isinstance(typenode, pycparser.c_ast.ArrayDecl):\n            # array type\n            if typenode.dim is None:\n                length = None\n            else:\n                length = self._parse_constant(\n                    typenode.dim, partial_length_ok=partial_length_ok)\n            # a hack: in 'typedef int foo_t[...][...];', don't use '...' as\n            # the length but use directly the C expression that would be\n            # generated by recompiler.py.  This lets the typedef be used in\n            # many more places within recompiler.py\n            if typedef_example is not None:\n                if length == '...':\n                    length = '_cffi_array_len(%s)' % (typedef_example,)\n                typedef_example = \"*\" + typedef_example\n            #\n            tp, quals = self._get_type_and_quals(typenode.type,\n                                partial_length_ok=partial_length_ok,\n                                typedef_example=typedef_example)\n            return model.ArrayType(tp, length), quals\n        #\n        if isinstance(typenode, pycparser.c_ast.PtrDecl):\n            # pointer type\n            itemtype, itemquals = self._get_type_and_quals(typenode.type)\n            tp = self._get_type_pointer(itemtype, itemquals, declname=name)\n            quals = self._extract_quals(typenode)\n            return tp, quals\n        #\n        if isinstance(typenode, pycparser.c_ast.TypeDecl):\n            quals = self._extract_quals(typenode)\n            type = typenode.type\n            if isinstance(type, pycparser.c_ast.IdentifierType):\n                # assume a primitive type.  get it from .names, but reduce\n                # synonyms to a single chosen combination\n                names = list(type.names)\n                if names != ['signed', 'char']:    # keep this unmodified\n                    prefixes = {}\n                    while names:\n                        name = names[0]\n                        if name in ('short', 'long', 'signed', 'unsigned'):\n                            prefixes[name] = prefixes.get(name, 0) + 1\n                            del names[0]\n                        else:\n                            break\n                    # ignore the 'signed' prefix below, and reorder the others\n                    newnames = []\n                    for prefix in ('unsigned', 'short', 'long'):\n                        for i in range(prefixes.get(prefix, 0)):\n                            newnames.append(prefix)\n                    if not names:\n                        names = ['int']    # implicitly\n                    if names == ['int']:   # but kill it if 'short' or 'long'\n                        if 'short' in prefixes or 'long' in prefixes:\n                            names = []\n                    names = newnames + names\n                ident = ' '.join(names)\n                if ident == 'void':\n                    return model.void_type, quals\n                if ident == '__dotdotdot__':\n                    raise FFIError(':%d: bad usage of \"...\"' %\n                            typenode.coord.line)\n                tp0, quals0 = resolve_common_type(self, ident)\n                return tp0, (quals | quals0)\n            #\n            if isinstance(type, pycparser.c_ast.Struct):\n                # 'struct foobar'\n                tp = self._get_struct_union_enum_type('struct', type, name)\n                return tp, quals\n            #\n            if isinstance(type, pycparser.c_ast.Union):\n                # 'union foobar'\n                tp = self._get_struct_union_enum_type('union', type, name)\n                return tp, quals\n            #\n            if isinstance(type, pycparser.c_ast.Enum):\n                # 'enum foobar'\n                tp = self._get_struct_union_enum_type('enum', type, name)\n                return tp, quals\n        #\n        if isinstance(typenode, pycparser.c_ast.FuncDecl):\n            # a function type\n            return self._parse_function_type(typenode, name), 0\n        #\n        # nested anonymous structs or unions end up here\n        if isinstance(typenode, pycparser.c_ast.Struct):\n            return self._get_struct_union_enum_type('struct', typenode, name,\n                                                    nested=True), 0\n        if isinstance(typenode, pycparser.c_ast.Union):\n            return self._get_struct_union_enum_type('union', typenode, name,\n                                                    nested=True), 0\n        #\n        raise FFIError(\":%d: bad or unsupported type declaration\" %\n                typenode.coord.line)\n\n    def _parse_function_type(self, typenode, funcname=None):\n        params = list(getattr(typenode.args, 'params', []))\n        for i, arg in enumerate(params):\n            if not hasattr(arg, 'type'):\n                raise CDefError(\"%s arg %d: unknown type '%s'\"\n                    \" (if you meant to use the old C syntax of giving\"\n                    \" untyped arguments, it is not supported)\"\n                    % (funcname or 'in expression', i + 1,\n                       getattr(arg, 'name', '?')))\n        ellipsis = (\n            len(params) > 0 and\n            isinstance(params[-1].type, pycparser.c_ast.TypeDecl) and\n            isinstance(params[-1].type.type,\n                       pycparser.c_ast.IdentifierType) and\n            params[-1].type.type.names == ['__dotdotdot__'])\n        if ellipsis:\n            params.pop()\n            if not params:\n                raise CDefError(\n                    \"%s: a function with only '(...)' as argument\"\n                    \" is not correct C\" % (funcname or 'in expression'))\n        args = [self._as_func_arg(*self._get_type_and_quals(argdeclnode.type))\n                for argdeclnode in params]\n        if not ellipsis and args == [model.void_type]:\n            args = []\n        result, quals = self._get_type_and_quals(typenode.type)\n        # the 'quals' on the result type are ignored.  HACK: we absure them\n        # to detect __stdcall functions: we textually replace \"__stdcall\"\n        # with \"volatile volatile const\" above.\n        abi = None\n        if hasattr(typenode.type, 'quals'): # else, probable syntax error anyway\n            if typenode.type.quals[-3:] == ['volatile', 'volatile', 'const']:\n                abi = '__stdcall'\n        return model.RawFunctionType(tuple(args), result, ellipsis, abi)\n\n    def _as_func_arg(self, type, quals):\n        if isinstance(type, model.ArrayType):\n            return model.PointerType(type.item, quals)\n        elif isinstance(type, model.RawFunctionType):\n            return type.as_function_pointer()\n        else:\n            return type\n\n    def _get_struct_union_enum_type(self, kind, type, name=None, nested=False):\n        # First, a level of caching on the exact 'type' node of the AST.\n        # This is obscure, but needed because pycparser \"unrolls\" declarations\n        # such as \"typedef struct { } foo_t, *foo_p\" and we end up with\n        # an AST that is not a tree, but a DAG, with the \"type\" node of the\n        # two branches foo_t and foo_p of the trees being the same node.\n        # It's a bit silly but detecting \"DAG-ness\" in the AST tree seems\n        # to be the only way to distinguish this case from two independent\n        # structs.  See test_struct_with_two_usages.\n        try:\n            return self._structnode2type[type]\n        except KeyError:\n            pass\n        #\n        # Note that this must handle parsing \"struct foo\" any number of\n        # times and always return the same StructType object.  Additionally,\n        # one of these times (not necessarily the first), the fields of\n        # the struct can be specified with \"struct foo { ...fields... }\".\n        # If no name is given, then we have to create a new anonymous struct\n        # with no caching; in this case, the fields are either specified\n        # right now or never.\n        #\n        force_name = name\n        name = type.name\n        #\n        # get the type or create it if needed\n        if name is None:\n            # 'force_name' is used to guess a more readable name for\n            # anonymous structs, for the common case \"typedef struct { } foo\".\n            if force_name is not None:\n                explicit_name = '$%s' % force_name\n            else:\n                self._anonymous_counter += 1\n                explicit_name = '$%d' % self._anonymous_counter\n            tp = None\n        else:\n            explicit_name = name\n            key = '%s %s' % (kind, name)\n            tp, _ = self._declarations.get(key, (None, None))\n        #\n        if tp is None:\n            if kind == 'struct':\n                tp = model.StructType(explicit_name, None, None, None)\n            elif kind == 'union':\n                tp = model.UnionType(explicit_name, None, None, None)\n            elif kind == 'enum':\n                if explicit_name == '__dotdotdot__':\n                    raise CDefError(\"Enums cannot be declared with ...\")\n                tp = self._build_enum_type(explicit_name, type.values)\n            else:\n                raise AssertionError(\"kind = %r\" % (kind,))\n            if name is not None:\n                self._declare(key, tp)\n        else:\n            if kind == 'enum' and type.values is not None:\n                raise NotImplementedError(\n                    \"enum %s: the '{}' declaration should appear on the first \"\n                    \"time the enum is mentioned, not later\" % explicit_name)\n        if not tp.forcename:\n            tp.force_the_name(force_name)\n        if tp.forcename and '$' in tp.name:\n            self._declare('anonymous %s' % tp.forcename, tp)\n        #\n        self._structnode2type[type] = tp\n        #\n        # enums: done here\n        if kind == 'enum':\n            return tp\n        #\n        # is there a 'type.decls'?  If yes, then this is the place in the\n        # C sources that declare the fields.  If no, then just return the\n        # existing type, possibly still incomplete.\n        if type.decls is None:\n            return tp\n        #\n        if tp.fldnames is not None:\n            raise CDefError(\"duplicate declaration of struct %s\" % name)\n        fldnames = []\n        fldtypes = []\n        fldbitsize = []\n        fldquals = []\n        for decl in type.decls:\n            if (isinstance(decl.type, pycparser.c_ast.IdentifierType) and\n                    ''.join(decl.type.names) == '__dotdotdot__'):\n                # XXX pycparser is inconsistent: 'names' should be a list\n                # of strings, but is sometimes just one string.  Use\n                # str.join() as a way to cope with both.\n                self._make_partial(tp, nested)\n                continue\n            if decl.bitsize is None:\n                bitsize = -1\n            else:\n                bitsize = self._parse_constant(decl.bitsize)\n            self._partial_length = False\n            type, fqual = self._get_type_and_quals(decl.type,\n                                                   partial_length_ok=True)\n            if self._partial_length:\n                self._make_partial(tp, nested)\n            if isinstance(type, model.StructType) and type.partial:\n                self._make_partial(tp, nested)\n            fldnames.append(decl.name or '')\n            fldtypes.append(type)\n            fldbitsize.append(bitsize)\n            fldquals.append(fqual)\n        tp.fldnames = tuple(fldnames)\n        tp.fldtypes = tuple(fldtypes)\n        tp.fldbitsize = tuple(fldbitsize)\n        tp.fldquals = tuple(fldquals)\n        if fldbitsize != [-1] * len(fldbitsize):\n            if isinstance(tp, model.StructType) and tp.partial:\n                raise NotImplementedError(\"%s: using both bitfields and '...;'\"\n                                          % (tp,))\n        tp.packed = self._options.get('packed')\n        if tp.completed:    # must be re-completed: it is not opaque any more\n            tp.completed = 0\n            self._recomplete.append(tp)\n        return tp\n\n    def _make_partial(self, tp, nested):\n        if not isinstance(tp, model.StructOrUnion):\n            raise CDefError(\"%s cannot be partial\" % (tp,))\n        if not tp.has_c_name() and not nested:\n            raise NotImplementedError(\"%s is partial but has no C name\" %(tp,))\n        tp.partial = True\n\n    def _parse_constant(self, exprnode, partial_length_ok=False):\n        # for now, limited to expressions that are an immediate number\n        # or positive/negative number\n        if isinstance(exprnode, pycparser.c_ast.Constant):\n            s = exprnode.value\n            if '0' <= s[0] <= '9':\n                s = s.rstrip('uUlL')\n                try:\n                    if s.startswith('0'):\n                        return int(s, 8)\n                    else:\n                        return int(s, 10)\n                except ValueError:\n                    if len(s) > 1:\n                        if s.lower()[0:2] == '0x':\n                            return int(s, 16)\n                        elif s.lower()[0:2] == '0b':\n                            return int(s, 2)\n                raise CDefError(\"invalid constant %r\" % (s,))\n            elif s[0] == \"'\" and s[-1] == \"'\" and (\n                    len(s) == 3 or (len(s) == 4 and s[1] == \"\\\\\")):\n                return ord(s[-2])\n            else:\n                raise CDefError(\"invalid constant %r\" % (s,))\n        #\n        if (isinstance(exprnode, pycparser.c_ast.UnaryOp) and\n                exprnode.op == '+'):\n            return self._parse_constant(exprnode.expr)\n        #\n        if (isinstance(exprnode, pycparser.c_ast.UnaryOp) and\n                exprnode.op == '-'):\n            return -self._parse_constant(exprnode.expr)\n        # load previously defined int constant\n        if (isinstance(exprnode, pycparser.c_ast.ID) and\n                exprnode.name in self._int_constants):\n            return self._int_constants[exprnode.name]\n        #\n        if (isinstance(exprnode, pycparser.c_ast.ID) and\n                    exprnode.name == '__dotdotdotarray__'):\n            if partial_length_ok:\n                self._partial_length = True\n                return '...'\n            raise FFIError(\":%d: unsupported '[...]' here, cannot derive \"\n                           \"the actual array length in this context\"\n                           % exprnode.coord.line)\n        #\n        if isinstance(exprnode, pycparser.c_ast.BinaryOp):\n            left = self._parse_constant(exprnode.left)\n            right = self._parse_constant(exprnode.right)\n            if exprnode.op == '+':\n                return left + right\n            elif exprnode.op == '-':\n                return left - right\n            elif exprnode.op == '*':\n                return left * right\n            elif exprnode.op == '/':\n                return self._c_div(left, right)\n            elif exprnode.op == '%':\n                return left - self._c_div(left, right) * right\n            elif exprnode.op == '<<':\n                return left << right\n            elif exprnode.op == '>>':\n                return left >> right\n            elif exprnode.op == '&':\n                return left & right\n            elif exprnode.op == '|':\n                return left | right\n            elif exprnode.op == '^':\n                return left ^ right\n        #\n        raise FFIError(\":%d: unsupported expression: expected a \"\n                       \"simple numeric constant\" % exprnode.coord.line)\n\n    def _c_div(self, a, b):\n        result = a // b\n        if ((a < 0) ^ (b < 0)) and (a % b) != 0:\n            result += 1\n        return result\n\n    def _build_enum_type(self, explicit_name, decls):\n        if decls is not None:\n            partial = False\n            enumerators = []\n            enumvalues = []\n            nextenumvalue = 0\n            for enum in decls.enumerators:\n                if _r_enum_dotdotdot.match(enum.name):\n                    partial = True\n                    continue\n                if enum.value is not None:\n                    nextenumvalue = self._parse_constant(enum.value)\n                enumerators.append(enum.name)\n                enumvalues.append(nextenumvalue)\n                self._add_constants(enum.name, nextenumvalue)\n                nextenumvalue += 1\n            enumerators = tuple(enumerators)\n            enumvalues = tuple(enumvalues)\n            tp = model.EnumType(explicit_name, enumerators, enumvalues)\n            tp.partial = partial\n        else:   # opaque enum\n            tp = model.EnumType(explicit_name, (), ())\n        return tp\n\n    def include(self, other):\n        for name, (tp, quals) in other._declarations.items():\n            if name.startswith('anonymous $enum_$'):\n                continue   # fix for test_anonymous_enum_include\n            kind = name.split(' ', 1)[0]\n            if kind in ('struct', 'union', 'enum', 'anonymous', 'typedef'):\n                self._declare(name, tp, included=True, quals=quals)\n        for k, v in other._int_constants.items():\n            self._add_constants(k, v)\n\n    def _get_unknown_type(self, decl):\n        typenames = decl.type.type.names\n        if typenames == ['__dotdotdot__']:\n            return model.unknown_type(decl.name)\n\n        if typenames == ['__dotdotdotint__']:\n            if self._uses_new_feature is None:\n                self._uses_new_feature = \"'typedef int... %s'\" % decl.name\n            return model.UnknownIntegerType(decl.name)\n\n        if typenames == ['__dotdotdotfloat__']:\n            # note: not for 'long double' so far\n            if self._uses_new_feature is None:\n                self._uses_new_feature = \"'typedef float... %s'\" % decl.name\n            return model.UnknownFloatType(decl.name)\n\n        raise FFIError(':%d: unsupported usage of \"...\" in typedef'\n                       % decl.coord.line)\n\n    def _get_unknown_ptr_type(self, decl):\n        if decl.type.type.type.names == ['__dotdotdot__']:\n            return model.unknown_ptr_type(decl.name)\n        raise FFIError(':%d: unsupported usage of \"...\" in typedef'\n                       % decl.coord.line)\n", "src/cffi/backend_ctypes.py": "import ctypes, ctypes.util, operator, sys\nfrom . import model\n\nif sys.version_info < (3,):\n    bytechr = chr\nelse:\n    unicode = str\n    long = int\n    xrange = range\n    bytechr = lambda num: bytes([num])\n\nclass CTypesType(type):\n    pass\n\nclass CTypesData(object):\n    __metaclass__ = CTypesType\n    __slots__ = ['__weakref__']\n    __name__ = '<cdata>'\n\n    def __init__(self, *args):\n        raise TypeError(\"cannot instantiate %r\" % (self.__class__,))\n\n    @classmethod\n    def _newp(cls, init):\n        raise TypeError(\"expected a pointer or array ctype, got '%s'\"\n                        % (cls._get_c_name(),))\n\n    @staticmethod\n    def _to_ctypes(value):\n        raise TypeError\n\n    @classmethod\n    def _arg_to_ctypes(cls, *value):\n        try:\n            ctype = cls._ctype\n        except AttributeError:\n            raise TypeError(\"cannot create an instance of %r\" % (cls,))\n        if value:\n            res = cls._to_ctypes(*value)\n            if not isinstance(res, ctype):\n                res = cls._ctype(res)\n        else:\n            res = cls._ctype()\n        return res\n\n    @classmethod\n    def _create_ctype_obj(cls, init):\n        if init is None:\n            return cls._arg_to_ctypes()\n        else:\n            return cls._arg_to_ctypes(init)\n\n    @staticmethod\n    def _from_ctypes(ctypes_value):\n        raise TypeError\n\n    @classmethod\n    def _get_c_name(cls, replace_with=''):\n        return cls._reftypename.replace(' &', replace_with)\n\n    @classmethod\n    def _fix_class(cls):\n        cls.__name__ = 'CData<%s>' % (cls._get_c_name(),)\n        cls.__qualname__ = 'CData<%s>' % (cls._get_c_name(),)\n        cls.__module__ = 'ffi'\n\n    def _get_own_repr(self):\n        raise NotImplementedError\n\n    def _addr_repr(self, address):\n        if address == 0:\n            return 'NULL'\n        else:\n            if address < 0:\n                address += 1 << (8*ctypes.sizeof(ctypes.c_void_p))\n            return '0x%x' % address\n\n    def __repr__(self, c_name=None):\n        own = self._get_own_repr()\n        return '<cdata %r %s>' % (c_name or self._get_c_name(), own)\n\n    def _convert_to_address(self, BClass):\n        if BClass is None:\n            raise TypeError(\"cannot convert %r to an address\" % (\n                self._get_c_name(),))\n        else:\n            raise TypeError(\"cannot convert %r to %r\" % (\n                self._get_c_name(), BClass._get_c_name()))\n\n    @classmethod\n    def _get_size(cls):\n        return ctypes.sizeof(cls._ctype)\n\n    def _get_size_of_instance(self):\n        return ctypes.sizeof(self._ctype)\n\n    @classmethod\n    def _cast_from(cls, source):\n        raise TypeError(\"cannot cast to %r\" % (cls._get_c_name(),))\n\n    def _cast_to_integer(self):\n        return self._convert_to_address(None)\n\n    @classmethod\n    def _alignment(cls):\n        return ctypes.alignment(cls._ctype)\n\n    def __iter__(self):\n        raise TypeError(\"cdata %r does not support iteration\" % (\n            self._get_c_name()),)\n\n    def _make_cmp(name):\n        cmpfunc = getattr(operator, name)\n        def cmp(self, other):\n            v_is_ptr = not isinstance(self, CTypesGenericPrimitive)\n            w_is_ptr = (isinstance(other, CTypesData) and\n                           not isinstance(other, CTypesGenericPrimitive))\n            if v_is_ptr and w_is_ptr:\n                return cmpfunc(self._convert_to_address(None),\n                               other._convert_to_address(None))\n            elif v_is_ptr or w_is_ptr:\n                return NotImplemented\n            else:\n                if isinstance(self, CTypesGenericPrimitive):\n                    self = self._value\n                if isinstance(other, CTypesGenericPrimitive):\n                    other = other._value\n                return cmpfunc(self, other)\n        cmp.func_name = name\n        return cmp\n\n    __eq__ = _make_cmp('__eq__')\n    __ne__ = _make_cmp('__ne__')\n    __lt__ = _make_cmp('__lt__')\n    __le__ = _make_cmp('__le__')\n    __gt__ = _make_cmp('__gt__')\n    __ge__ = _make_cmp('__ge__')\n\n    def __hash__(self):\n        return hash(self._convert_to_address(None))\n\n    def _to_string(self, maxlen):\n        raise TypeError(\"string(): %r\" % (self,))\n\n\nclass CTypesGenericPrimitive(CTypesData):\n    __slots__ = []\n\n    def __hash__(self):\n        return hash(self._value)\n\n    def _get_own_repr(self):\n        return repr(self._from_ctypes(self._value))\n\n\nclass CTypesGenericArray(CTypesData):\n    __slots__ = []\n\n    @classmethod\n    def _newp(cls, init):\n        return cls(init)\n\n    def __iter__(self):\n        for i in xrange(len(self)):\n            yield self[i]\n\n    def _get_own_repr(self):\n        return self._addr_repr(ctypes.addressof(self._blob))\n\n\nclass CTypesGenericPtr(CTypesData):\n    __slots__ = ['_address', '_as_ctype_ptr']\n    _automatic_casts = False\n    kind = \"pointer\"\n\n    @classmethod\n    def _newp(cls, init):\n        return cls(init)\n\n    @classmethod\n    def _cast_from(cls, source):\n        if source is None:\n            address = 0\n        elif isinstance(source, CTypesData):\n            address = source._cast_to_integer()\n        elif isinstance(source, (int, long)):\n            address = source\n        else:\n            raise TypeError(\"bad type for cast to %r: %r\" %\n                            (cls, type(source).__name__))\n        return cls._new_pointer_at(address)\n\n    @classmethod\n    def _new_pointer_at(cls, address):\n        self = cls.__new__(cls)\n        self._address = address\n        self._as_ctype_ptr = ctypes.cast(address, cls._ctype)\n        return self\n\n    def _get_own_repr(self):\n        try:\n            return self._addr_repr(self._address)\n        except AttributeError:\n            return '???'\n\n    def _cast_to_integer(self):\n        return self._address\n\n    def __nonzero__(self):\n        return bool(self._address)\n    __bool__ = __nonzero__\n\n    @classmethod\n    def _to_ctypes(cls, value):\n        if not isinstance(value, CTypesData):\n            raise TypeError(\"unexpected %s object\" % type(value).__name__)\n        address = value._convert_to_address(cls)\n        return ctypes.cast(address, cls._ctype)\n\n    @classmethod\n    def _from_ctypes(cls, ctypes_ptr):\n        address = ctypes.cast(ctypes_ptr, ctypes.c_void_p).value or 0\n        return cls._new_pointer_at(address)\n\n    @classmethod\n    def _initialize(cls, ctypes_ptr, value):\n        if value:\n            ctypes_ptr.contents = cls._to_ctypes(value).contents\n\n    def _convert_to_address(self, BClass):\n        if (BClass in (self.__class__, None) or BClass._automatic_casts\n            or self._automatic_casts):\n            return self._address\n        else:\n            return CTypesData._convert_to_address(self, BClass)\n\n\nclass CTypesBaseStructOrUnion(CTypesData):\n    __slots__ = ['_blob']\n\n    @classmethod\n    def _create_ctype_obj(cls, init):\n        # may be overridden\n        raise TypeError(\"cannot instantiate opaque type %s\" % (cls,))\n\n    def _get_own_repr(self):\n        return self._addr_repr(ctypes.addressof(self._blob))\n\n    @classmethod\n    def _offsetof(cls, fieldname):\n        return getattr(cls._ctype, fieldname).offset\n\n    def _convert_to_address(self, BClass):\n        if getattr(BClass, '_BItem', None) is self.__class__:\n            return ctypes.addressof(self._blob)\n        else:\n            return CTypesData._convert_to_address(self, BClass)\n\n    @classmethod\n    def _from_ctypes(cls, ctypes_struct_or_union):\n        self = cls.__new__(cls)\n        self._blob = ctypes_struct_or_union\n        return self\n\n    @classmethod\n    def _to_ctypes(cls, value):\n        return value._blob\n\n    def __repr__(self, c_name=None):\n        return CTypesData.__repr__(self, c_name or self._get_c_name(' &'))\n\n\nclass CTypesBackend(object):\n\n    PRIMITIVE_TYPES = {\n        'char': ctypes.c_char,\n        'short': ctypes.c_short,\n        'int': ctypes.c_int,\n        'long': ctypes.c_long,\n        'long long': ctypes.c_longlong,\n        'signed char': ctypes.c_byte,\n        'unsigned char': ctypes.c_ubyte,\n        'unsigned short': ctypes.c_ushort,\n        'unsigned int': ctypes.c_uint,\n        'unsigned long': ctypes.c_ulong,\n        'unsigned long long': ctypes.c_ulonglong,\n        'float': ctypes.c_float,\n        'double': ctypes.c_double,\n        '_Bool': ctypes.c_bool,\n        }\n\n    for _name in ['unsigned long long', 'unsigned long',\n                  'unsigned int', 'unsigned short', 'unsigned char']:\n        _size = ctypes.sizeof(PRIMITIVE_TYPES[_name])\n        PRIMITIVE_TYPES['uint%d_t' % (8*_size)] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_void_p):\n            PRIMITIVE_TYPES['uintptr_t'] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_size_t):\n            PRIMITIVE_TYPES['size_t'] = PRIMITIVE_TYPES[_name]\n\n    for _name in ['long long', 'long', 'int', 'short', 'signed char']:\n        _size = ctypes.sizeof(PRIMITIVE_TYPES[_name])\n        PRIMITIVE_TYPES['int%d_t' % (8*_size)] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_void_p):\n            PRIMITIVE_TYPES['intptr_t'] = PRIMITIVE_TYPES[_name]\n            PRIMITIVE_TYPES['ptrdiff_t'] = PRIMITIVE_TYPES[_name]\n        if _size == ctypes.sizeof(ctypes.c_size_t):\n            PRIMITIVE_TYPES['ssize_t'] = PRIMITIVE_TYPES[_name]\n\n\n    def __init__(self):\n        self.RTLD_LAZY = 0   # not supported anyway by ctypes\n        self.RTLD_NOW  = 0\n        self.RTLD_GLOBAL = ctypes.RTLD_GLOBAL\n        self.RTLD_LOCAL = ctypes.RTLD_LOCAL\n\n    def set_ffi(self, ffi):\n        self.ffi = ffi\n\n    def _get_types(self):\n        return CTypesData, CTypesType\n\n    def load_library(self, path, flags=0):\n        cdll = ctypes.CDLL(path, flags)\n        return CTypesLibrary(self, cdll)\n\n    def new_void_type(self):\n        class CTypesVoid(CTypesData):\n            __slots__ = []\n            _reftypename = 'void &'\n            @staticmethod\n            def _from_ctypes(novalue):\n                return None\n            @staticmethod\n            def _to_ctypes(novalue):\n                if novalue is not None:\n                    raise TypeError(\"None expected, got %s object\" %\n                                    (type(novalue).__name__,))\n                return None\n        CTypesVoid._fix_class()\n        return CTypesVoid\n\n    def new_primitive_type(self, name):\n        if name == 'wchar_t':\n            raise NotImplementedError(name)\n        ctype = self.PRIMITIVE_TYPES[name]\n        if name == 'char':\n            kind = 'char'\n        elif name in ('float', 'double'):\n            kind = 'float'\n        else:\n            if name in ('signed char', 'unsigned char'):\n                kind = 'byte'\n            elif name == '_Bool':\n                kind = 'bool'\n            else:\n                kind = 'int'\n            is_signed = (ctype(-1).value == -1)\n        #\n        def _cast_source_to_int(source):\n            if isinstance(source, (int, long, float)):\n                source = int(source)\n            elif isinstance(source, CTypesData):\n                source = source._cast_to_integer()\n            elif isinstance(source, bytes):\n                source = ord(source)\n            elif source is None:\n                source = 0\n            else:\n                raise TypeError(\"bad type for cast to %r: %r\" %\n                                (CTypesPrimitive, type(source).__name__))\n            return source\n        #\n        kind1 = kind\n        class CTypesPrimitive(CTypesGenericPrimitive):\n            __slots__ = ['_value']\n            _ctype = ctype\n            _reftypename = '%s &' % name\n            kind = kind1\n\n            def __init__(self, value):\n                self._value = value\n\n            @staticmethod\n            def _create_ctype_obj(init):\n                if init is None:\n                    return ctype()\n                return ctype(CTypesPrimitive._to_ctypes(init))\n\n            if kind == 'int' or kind == 'byte':\n                @classmethod\n                def _cast_from(cls, source):\n                    source = _cast_source_to_int(source)\n                    source = ctype(source).value     # cast within range\n                    return cls(source)\n                def __int__(self):\n                    return self._value\n\n            if kind == 'bool':\n                @classmethod\n                def _cast_from(cls, source):\n                    if not isinstance(source, (int, long, float)):\n                        source = _cast_source_to_int(source)\n                    return cls(bool(source))\n                def __int__(self):\n                    return int(self._value)\n\n            if kind == 'char':\n                @classmethod\n                def _cast_from(cls, source):\n                    source = _cast_source_to_int(source)\n                    source = bytechr(source & 0xFF)\n                    return cls(source)\n                def __int__(self):\n                    return ord(self._value)\n\n            if kind == 'float':\n                @classmethod\n                def _cast_from(cls, source):\n                    if isinstance(source, float):\n                        pass\n                    elif isinstance(source, CTypesGenericPrimitive):\n                        if hasattr(source, '__float__'):\n                            source = float(source)\n                        else:\n                            source = int(source)\n                    else:\n                        source = _cast_source_to_int(source)\n                    source = ctype(source).value     # fix precision\n                    return cls(source)\n                def __int__(self):\n                    return int(self._value)\n                def __float__(self):\n                    return self._value\n\n            _cast_to_integer = __int__\n\n            if kind == 'int' or kind == 'byte' or kind == 'bool':\n                @staticmethod\n                def _to_ctypes(x):\n                    if not isinstance(x, (int, long)):\n                        if isinstance(x, CTypesData):\n                            x = int(x)\n                        else:\n                            raise TypeError(\"integer expected, got %s\" %\n                                            type(x).__name__)\n                    if ctype(x).value != x:\n                        if not is_signed and x < 0:\n                            raise OverflowError(\"%s: negative integer\" % name)\n                        else:\n                            raise OverflowError(\"%s: integer out of bounds\"\n                                                % name)\n                    return x\n\n            if kind == 'char':\n                @staticmethod\n                def _to_ctypes(x):\n                    if isinstance(x, bytes) and len(x) == 1:\n                        return x\n                    if isinstance(x, CTypesPrimitive):    # <CData <char>>\n                        return x._value\n                    raise TypeError(\"character expected, got %s\" %\n                                    type(x).__name__)\n                def __nonzero__(self):\n                    return ord(self._value) != 0\n            else:\n                def __nonzero__(self):\n                    return self._value != 0\n            __bool__ = __nonzero__\n\n            if kind == 'float':\n                @staticmethod\n                def _to_ctypes(x):\n                    if not isinstance(x, (int, long, float, CTypesData)):\n                        raise TypeError(\"float expected, got %s\" %\n                                        type(x).__name__)\n                    return ctype(x).value\n\n            @staticmethod\n            def _from_ctypes(value):\n                return getattr(value, 'value', value)\n\n            @staticmethod\n            def _initialize(blob, init):\n                blob.value = CTypesPrimitive._to_ctypes(init)\n\n            if kind == 'char':\n                def _to_string(self, maxlen):\n                    return self._value\n            if kind == 'byte':\n                def _to_string(self, maxlen):\n                    return chr(self._value & 0xff)\n        #\n        CTypesPrimitive._fix_class()\n        return CTypesPrimitive\n\n    def new_pointer_type(self, BItem):\n        getbtype = self.ffi._get_cached_btype\n        if BItem is getbtype(model.PrimitiveType('char')):\n            kind = 'charp'\n        elif BItem in (getbtype(model.PrimitiveType('signed char')),\n                       getbtype(model.PrimitiveType('unsigned char'))):\n            kind = 'bytep'\n        elif BItem is getbtype(model.void_type):\n            kind = 'voidp'\n        else:\n            kind = 'generic'\n        #\n        class CTypesPtr(CTypesGenericPtr):\n            __slots__ = ['_own']\n            if kind == 'charp':\n                __slots__ += ['__as_strbuf']\n            _BItem = BItem\n            if hasattr(BItem, '_ctype'):\n                _ctype = ctypes.POINTER(BItem._ctype)\n                _bitem_size = ctypes.sizeof(BItem._ctype)\n            else:\n                _ctype = ctypes.c_void_p\n            if issubclass(BItem, CTypesGenericArray):\n                _reftypename = BItem._get_c_name('(* &)')\n            else:\n                _reftypename = BItem._get_c_name(' * &')\n\n            def __init__(self, init):\n                ctypeobj = BItem._create_ctype_obj(init)\n                if kind == 'charp':\n                    self.__as_strbuf = ctypes.create_string_buffer(\n                        ctypeobj.value + b'\\x00')\n                    self._as_ctype_ptr = ctypes.cast(\n                        self.__as_strbuf, self._ctype)\n                else:\n                    self._as_ctype_ptr = ctypes.pointer(ctypeobj)\n                self._address = ctypes.cast(self._as_ctype_ptr,\n                                            ctypes.c_void_p).value\n                self._own = True\n\n            def __add__(self, other):\n                if isinstance(other, (int, long)):\n                    return self._new_pointer_at(self._address +\n                                                other * self._bitem_size)\n                else:\n                    return NotImplemented\n\n            def __sub__(self, other):\n                if isinstance(other, (int, long)):\n                    return self._new_pointer_at(self._address -\n                                                other * self._bitem_size)\n                elif type(self) is type(other):\n                    return (self._address - other._address) // self._bitem_size\n                else:\n                    return NotImplemented\n\n            def __getitem__(self, index):\n                if getattr(self, '_own', False) and index != 0:\n                    raise IndexError\n                return BItem._from_ctypes(self._as_ctype_ptr[index])\n\n            def __setitem__(self, index, value):\n                self._as_ctype_ptr[index] = BItem._to_ctypes(value)\n\n            if kind == 'charp' or kind == 'voidp':\n                @classmethod\n                def _arg_to_ctypes(cls, *value):\n                    if value and isinstance(value[0], bytes):\n                        return ctypes.c_char_p(value[0])\n                    else:\n                        return super(CTypesPtr, cls)._arg_to_ctypes(*value)\n\n            if kind == 'charp' or kind == 'bytep':\n                def _to_string(self, maxlen):\n                    if maxlen < 0:\n                        maxlen = sys.maxsize\n                    p = ctypes.cast(self._as_ctype_ptr,\n                                    ctypes.POINTER(ctypes.c_char))\n                    n = 0\n                    while n < maxlen and p[n] != b'\\x00':\n                        n += 1\n                    return b''.join([p[i] for i in range(n)])\n\n            def _get_own_repr(self):\n                if getattr(self, '_own', False):\n                    return 'owning %d bytes' % (\n                        ctypes.sizeof(self._as_ctype_ptr.contents),)\n                return super(CTypesPtr, self)._get_own_repr()\n        #\n        if (BItem is self.ffi._get_cached_btype(model.void_type) or\n            BItem is self.ffi._get_cached_btype(model.PrimitiveType('char'))):\n            CTypesPtr._automatic_casts = True\n        #\n        CTypesPtr._fix_class()\n        return CTypesPtr\n\n    def new_array_type(self, CTypesPtr, length):\n        if length is None:\n            brackets = ' &[]'\n        else:\n            brackets = ' &[%d]' % length\n        BItem = CTypesPtr._BItem\n        getbtype = self.ffi._get_cached_btype\n        if BItem is getbtype(model.PrimitiveType('char')):\n            kind = 'char'\n        elif BItem in (getbtype(model.PrimitiveType('signed char')),\n                       getbtype(model.PrimitiveType('unsigned char'))):\n            kind = 'byte'\n        else:\n            kind = 'generic'\n        #\n        class CTypesArray(CTypesGenericArray):\n            __slots__ = ['_blob', '_own']\n            if length is not None:\n                _ctype = BItem._ctype * length\n            else:\n                __slots__.append('_ctype')\n            _reftypename = BItem._get_c_name(brackets)\n            _declared_length = length\n            _CTPtr = CTypesPtr\n\n            def __init__(self, init):\n                if length is None:\n                    if isinstance(init, (int, long)):\n                        len1 = init\n                        init = None\n                    elif kind == 'char' and isinstance(init, bytes):\n                        len1 = len(init) + 1    # extra null\n                    else:\n                        init = tuple(init)\n                        len1 = len(init)\n                    self._ctype = BItem._ctype * len1\n                self._blob = self._ctype()\n                self._own = True\n                if init is not None:\n                    self._initialize(self._blob, init)\n\n            @staticmethod\n            def _initialize(blob, init):\n                if isinstance(init, bytes):\n                    init = [init[i:i+1] for i in range(len(init))]\n                else:\n                    if isinstance(init, CTypesGenericArray):\n                        if (len(init) != len(blob) or\n                            not isinstance(init, CTypesArray)):\n                            raise TypeError(\"length/type mismatch: %s\" % (init,))\n                    init = tuple(init)\n                if len(init) > len(blob):\n                    raise IndexError(\"too many initializers\")\n                addr = ctypes.cast(blob, ctypes.c_void_p).value\n                PTR = ctypes.POINTER(BItem._ctype)\n                itemsize = ctypes.sizeof(BItem._ctype)\n                for i, value in enumerate(init):\n                    p = ctypes.cast(addr + i * itemsize, PTR)\n                    BItem._initialize(p.contents, value)\n\n            def __len__(self):\n                return len(self._blob)\n\n            def __getitem__(self, index):\n                if not (0 <= index < len(self._blob)):\n                    raise IndexError\n                return BItem._from_ctypes(self._blob[index])\n\n            def __setitem__(self, index, value):\n                if not (0 <= index < len(self._blob)):\n                    raise IndexError\n                self._blob[index] = BItem._to_ctypes(value)\n\n            if kind == 'char' or kind == 'byte':\n                def _to_string(self, maxlen):\n                    if maxlen < 0:\n                        maxlen = len(self._blob)\n                    p = ctypes.cast(self._blob,\n                                    ctypes.POINTER(ctypes.c_char))\n                    n = 0\n                    while n < maxlen and p[n] != b'\\x00':\n                        n += 1\n                    return b''.join([p[i] for i in range(n)])\n\n            def _get_own_repr(self):\n                if getattr(self, '_own', False):\n                    return 'owning %d bytes' % (ctypes.sizeof(self._blob),)\n                return super(CTypesArray, self)._get_own_repr()\n\n            def _convert_to_address(self, BClass):\n                if BClass in (CTypesPtr, None) or BClass._automatic_casts:\n                    return ctypes.addressof(self._blob)\n                else:\n                    return CTypesData._convert_to_address(self, BClass)\n\n            @staticmethod\n            def _from_ctypes(ctypes_array):\n                self = CTypesArray.__new__(CTypesArray)\n                self._blob = ctypes_array\n                return self\n\n            @staticmethod\n            def _arg_to_ctypes(value):\n                return CTypesPtr._arg_to_ctypes(value)\n\n            def __add__(self, other):\n                if isinstance(other, (int, long)):\n                    return CTypesPtr._new_pointer_at(\n                        ctypes.addressof(self._blob) +\n                        other * ctypes.sizeof(BItem._ctype))\n                else:\n                    return NotImplemented\n\n            @classmethod\n            def _cast_from(cls, source):\n                raise NotImplementedError(\"casting to %r\" % (\n                    cls._get_c_name(),))\n        #\n        CTypesArray._fix_class()\n        return CTypesArray\n\n    def _new_struct_or_union(self, kind, name, base_ctypes_class):\n        #\n        class struct_or_union(base_ctypes_class):\n            pass\n        struct_or_union.__name__ = '%s_%s' % (kind, name)\n        kind1 = kind\n        #\n        class CTypesStructOrUnion(CTypesBaseStructOrUnion):\n            __slots__ = ['_blob']\n            _ctype = struct_or_union\n            _reftypename = '%s &' % (name,)\n            _kind = kind = kind1\n        #\n        CTypesStructOrUnion._fix_class()\n        return CTypesStructOrUnion\n\n    def new_struct_type(self, name):\n        return self._new_struct_or_union('struct', name, ctypes.Structure)\n\n    def new_union_type(self, name):\n        return self._new_struct_or_union('union', name, ctypes.Union)\n\n    def complete_struct_or_union(self, CTypesStructOrUnion, fields, tp,\n                                 totalsize=-1, totalalignment=-1, sflags=0,\n                                 pack=0):\n        if totalsize >= 0 or totalalignment >= 0:\n            raise NotImplementedError(\"the ctypes backend of CFFI does not support \"\n                                      \"structures completed by verify(); please \"\n                                      \"compile and install the _cffi_backend module.\")\n        struct_or_union = CTypesStructOrUnion._ctype\n        fnames = [fname for (fname, BField, bitsize) in fields]\n        btypes = [BField for (fname, BField, bitsize) in fields]\n        bitfields = [bitsize for (fname, BField, bitsize) in fields]\n        #\n        bfield_types = {}\n        cfields = []\n        for (fname, BField, bitsize) in fields:\n            if bitsize < 0:\n                cfields.append((fname, BField._ctype))\n                bfield_types[fname] = BField\n            else:\n                cfields.append((fname, BField._ctype, bitsize))\n                bfield_types[fname] = Ellipsis\n        if sflags & 8:\n            struct_or_union._pack_ = 1\n        elif pack:\n            struct_or_union._pack_ = pack\n        struct_or_union._fields_ = cfields\n        CTypesStructOrUnion._bfield_types = bfield_types\n        #\n        @staticmethod\n        def _create_ctype_obj(init):\n            result = struct_or_union()\n            if init is not None:\n                initialize(result, init)\n            return result\n        CTypesStructOrUnion._create_ctype_obj = _create_ctype_obj\n        #\n        def initialize(blob, init):\n            if is_union:\n                if len(init) > 1:\n                    raise ValueError(\"union initializer: %d items given, but \"\n                                    \"only one supported (use a dict if needed)\"\n                                     % (len(init),))\n            if not isinstance(init, dict):\n                if isinstance(init, (bytes, unicode)):\n                    raise TypeError(\"union initializer: got a str\")\n                init = tuple(init)\n                if len(init) > len(fnames):\n                    raise ValueError(\"too many values for %s initializer\" %\n                                     CTypesStructOrUnion._get_c_name())\n                init = dict(zip(fnames, init))\n            addr = ctypes.addressof(blob)\n            for fname, value in init.items():\n                BField, bitsize = name2fieldtype[fname]\n                assert bitsize < 0, \\\n                       \"not implemented: initializer with bit fields\"\n                offset = CTypesStructOrUnion._offsetof(fname)\n                PTR = ctypes.POINTER(BField._ctype)\n                p = ctypes.cast(addr + offset, PTR)\n                BField._initialize(p.contents, value)\n        is_union = CTypesStructOrUnion._kind == 'union'\n        name2fieldtype = dict(zip(fnames, zip(btypes, bitfields)))\n        #\n        for fname, BField, bitsize in fields:\n            if fname == '':\n                raise NotImplementedError(\"nested anonymous structs/unions\")\n            if hasattr(CTypesStructOrUnion, fname):\n                raise ValueError(\"the field name %r conflicts in \"\n                                 \"the ctypes backend\" % fname)\n            if bitsize < 0:\n                def getter(self, fname=fname, BField=BField,\n                           offset=CTypesStructOrUnion._offsetof(fname),\n                           PTR=ctypes.POINTER(BField._ctype)):\n                    addr = ctypes.addressof(self._blob)\n                    p = ctypes.cast(addr + offset, PTR)\n                    return BField._from_ctypes(p.contents)\n                def setter(self, value, fname=fname, BField=BField):\n                    setattr(self._blob, fname, BField._to_ctypes(value))\n                #\n                if issubclass(BField, CTypesGenericArray):\n                    setter = None\n                    if BField._declared_length == 0:\n                        def getter(self, fname=fname, BFieldPtr=BField._CTPtr,\n                                   offset=CTypesStructOrUnion._offsetof(fname),\n                                   PTR=ctypes.POINTER(BField._ctype)):\n                            addr = ctypes.addressof(self._blob)\n                            p = ctypes.cast(addr + offset, PTR)\n                            return BFieldPtr._from_ctypes(p)\n                #\n            else:\n                def getter(self, fname=fname, BField=BField):\n                    return BField._from_ctypes(getattr(self._blob, fname))\n                def setter(self, value, fname=fname, BField=BField):\n                    # xxx obscure workaround\n                    value = BField._to_ctypes(value)\n                    oldvalue = getattr(self._blob, fname)\n                    setattr(self._blob, fname, value)\n                    if value != getattr(self._blob, fname):\n                        setattr(self._blob, fname, oldvalue)\n                        raise OverflowError(\"value too large for bitfield\")\n            setattr(CTypesStructOrUnion, fname, property(getter, setter))\n        #\n        CTypesPtr = self.ffi._get_cached_btype(model.PointerType(tp))\n        for fname in fnames:\n            if hasattr(CTypesPtr, fname):\n                raise ValueError(\"the field name %r conflicts in \"\n                                 \"the ctypes backend\" % fname)\n            def getter(self, fname=fname):\n                return getattr(self[0], fname)\n            def setter(self, value, fname=fname):\n                setattr(self[0], fname, value)\n            setattr(CTypesPtr, fname, property(getter, setter))\n\n    def new_function_type(self, BArgs, BResult, has_varargs):\n        nameargs = [BArg._get_c_name() for BArg in BArgs]\n        if has_varargs:\n            nameargs.append('...')\n        nameargs = ', '.join(nameargs)\n        #\n        class CTypesFunctionPtr(CTypesGenericPtr):\n            __slots__ = ['_own_callback', '_name']\n            _ctype = ctypes.CFUNCTYPE(getattr(BResult, '_ctype', None),\n                                      *[BArg._ctype for BArg in BArgs],\n                                      use_errno=True)\n            _reftypename = BResult._get_c_name('(* &)(%s)' % (nameargs,))\n\n            def __init__(self, init, error=None):\n                # create a callback to the Python callable init()\n                import traceback\n                assert not has_varargs, \"varargs not supported for callbacks\"\n                if getattr(BResult, '_ctype', None) is not None:\n                    error = BResult._from_ctypes(\n                        BResult._create_ctype_obj(error))\n                else:\n                    error = None\n                def callback(*args):\n                    args2 = []\n                    for arg, BArg in zip(args, BArgs):\n                        args2.append(BArg._from_ctypes(arg))\n                    try:\n                        res2 = init(*args2)\n                        res2 = BResult._to_ctypes(res2)\n                    except:\n                        traceback.print_exc()\n                        res2 = error\n                    if issubclass(BResult, CTypesGenericPtr):\n                        if res2:\n                            res2 = ctypes.cast(res2, ctypes.c_void_p).value\n                                # .value: http://bugs.python.org/issue1574593\n                        else:\n                            res2 = None\n                    #print repr(res2)\n                    return res2\n                if issubclass(BResult, CTypesGenericPtr):\n                    # The only pointers callbacks can return are void*s:\n                    # http://bugs.python.org/issue5710\n                    callback_ctype = ctypes.CFUNCTYPE(\n                        ctypes.c_void_p,\n                        *[BArg._ctype for BArg in BArgs],\n                        use_errno=True)\n                else:\n                    callback_ctype = CTypesFunctionPtr._ctype\n                self._as_ctype_ptr = callback_ctype(callback)\n                self._address = ctypes.cast(self._as_ctype_ptr,\n                                            ctypes.c_void_p).value\n                self._own_callback = init\n\n            @staticmethod\n            def _initialize(ctypes_ptr, value):\n                if value:\n                    raise NotImplementedError(\"ctypes backend: not supported: \"\n                                          \"initializers for function pointers\")\n\n            def __repr__(self):\n                c_name = getattr(self, '_name', None)\n                if c_name:\n                    i = self._reftypename.index('(* &)')\n                    if self._reftypename[i-1] not in ' )*':\n                        c_name = ' ' + c_name\n                    c_name = self._reftypename.replace('(* &)', c_name)\n                return CTypesData.__repr__(self, c_name)\n\n            def _get_own_repr(self):\n                if getattr(self, '_own_callback', None) is not None:\n                    return 'calling %r' % (self._own_callback,)\n                return super(CTypesFunctionPtr, self)._get_own_repr()\n\n            def __call__(self, *args):\n                if has_varargs:\n                    assert len(args) >= len(BArgs)\n                    extraargs = args[len(BArgs):]\n                    args = args[:len(BArgs)]\n                else:\n                    assert len(args) == len(BArgs)\n                ctypes_args = []\n                for arg, BArg in zip(args, BArgs):\n                    ctypes_args.append(BArg._arg_to_ctypes(arg))\n                if has_varargs:\n                    for i, arg in enumerate(extraargs):\n                        if arg is None:\n                            ctypes_args.append(ctypes.c_void_p(0))  # NULL\n                            continue\n                        if not isinstance(arg, CTypesData):\n                            raise TypeError(\n                                \"argument %d passed in the variadic part \"\n                                \"needs to be a cdata object (got %s)\" %\n                                (1 + len(BArgs) + i, type(arg).__name__))\n                        ctypes_args.append(arg._arg_to_ctypes(arg))\n                result = self._as_ctype_ptr(*ctypes_args)\n                return BResult._from_ctypes(result)\n        #\n        CTypesFunctionPtr._fix_class()\n        return CTypesFunctionPtr\n\n    def new_enum_type(self, name, enumerators, enumvalues, CTypesInt):\n        assert isinstance(name, str)\n        reverse_mapping = dict(zip(reversed(enumvalues),\n                                   reversed(enumerators)))\n        #\n        class CTypesEnum(CTypesInt):\n            __slots__ = []\n            _reftypename = '%s &' % name\n\n            def _get_own_repr(self):\n                value = self._value\n                try:\n                    return '%d: %s' % (value, reverse_mapping[value])\n                except KeyError:\n                    return str(value)\n\n            def _to_string(self, maxlen):\n                value = self._value\n                try:\n                    return reverse_mapping[value]\n                except KeyError:\n                    return str(value)\n        #\n        CTypesEnum._fix_class()\n        return CTypesEnum\n\n    def get_errno(self):\n        return ctypes.get_errno()\n\n    def set_errno(self, value):\n        ctypes.set_errno(value)\n\n    def string(self, b, maxlen=-1):\n        return b._to_string(maxlen)\n\n    def buffer(self, bptr, size=-1):\n        raise NotImplementedError(\"buffer() with ctypes backend\")\n\n    def sizeof(self, cdata_or_BType):\n        if isinstance(cdata_or_BType, CTypesData):\n            return cdata_or_BType._get_size_of_instance()\n        else:\n            assert issubclass(cdata_or_BType, CTypesData)\n            return cdata_or_BType._get_size()\n\n    def alignof(self, BType):\n        assert issubclass(BType, CTypesData)\n        return BType._alignment()\n\n    def newp(self, BType, source):\n        if not issubclass(BType, CTypesData):\n            raise TypeError\n        return BType._newp(source)\n\n    def cast(self, BType, source):\n        return BType._cast_from(source)\n\n    def callback(self, BType, source, error, onerror):\n        assert onerror is None   # XXX not implemented\n        return BType(source, error)\n\n    _weakref_cache_ref = None\n\n    def gcp(self, cdata, destructor, size=0):\n        if self._weakref_cache_ref is None:\n            import weakref\n            class MyRef(weakref.ref):\n                def __eq__(self, other):\n                    myref = self()\n                    return self is other or (\n                        myref is not None and myref is other())\n                def __ne__(self, other):\n                    return not (self == other)\n                def __hash__(self):\n                    try:\n                        return self._hash\n                    except AttributeError:\n                        self._hash = hash(self())\n                        return self._hash\n            self._weakref_cache_ref = {}, MyRef\n        weak_cache, MyRef = self._weakref_cache_ref\n\n        if destructor is None:\n            try:\n                del weak_cache[MyRef(cdata)]\n            except KeyError:\n                raise TypeError(\"Can remove destructor only on a object \"\n                                \"previously returned by ffi.gc()\")\n            return None\n\n        def remove(k):\n            cdata, destructor = weak_cache.pop(k, (None, None))\n            if destructor is not None:\n                destructor(cdata)\n\n        new_cdata = self.cast(self.typeof(cdata), cdata)\n        assert new_cdata is not cdata\n        weak_cache[MyRef(new_cdata, remove)] = (cdata, destructor)\n        return new_cdata\n\n    typeof = type\n\n    def getcname(self, BType, replace_with):\n        return BType._get_c_name(replace_with)\n\n    def typeoffsetof(self, BType, fieldname, num=0):\n        if isinstance(fieldname, str):\n            if num == 0 and issubclass(BType, CTypesGenericPtr):\n                BType = BType._BItem\n            if not issubclass(BType, CTypesBaseStructOrUnion):\n                raise TypeError(\"expected a struct or union ctype\")\n            BField = BType._bfield_types[fieldname]\n            if BField is Ellipsis:\n                raise TypeError(\"not supported for bitfields\")\n            return (BField, BType._offsetof(fieldname))\n        elif isinstance(fieldname, (int, long)):\n            if issubclass(BType, CTypesGenericArray):\n                BType = BType._CTPtr\n            if not issubclass(BType, CTypesGenericPtr):\n                raise TypeError(\"expected an array or ptr ctype\")\n            BItem = BType._BItem\n            offset = BItem._get_size() * fieldname\n            if offset > sys.maxsize:\n                raise OverflowError\n            return (BItem, offset)\n        else:\n            raise TypeError(type(fieldname))\n\n    def rawaddressof(self, BTypePtr, cdata, offset=None):\n        if isinstance(cdata, CTypesBaseStructOrUnion):\n            ptr = ctypes.pointer(type(cdata)._to_ctypes(cdata))\n        elif isinstance(cdata, CTypesGenericPtr):\n            if offset is None or not issubclass(type(cdata)._BItem,\n                                                CTypesBaseStructOrUnion):\n                raise TypeError(\"unexpected cdata type\")\n            ptr = type(cdata)._to_ctypes(cdata)\n        elif isinstance(cdata, CTypesGenericArray):\n            ptr = type(cdata)._to_ctypes(cdata)\n        else:\n            raise TypeError(\"expected a <cdata 'struct-or-union'>\")\n        if offset:\n            ptr = ctypes.cast(\n                ctypes.c_void_p(\n                    ctypes.cast(ptr, ctypes.c_void_p).value + offset),\n                type(ptr))\n        return BTypePtr._from_ctypes(ptr)\n\n\nclass CTypesLibrary(object):\n\n    def __init__(self, backend, cdll):\n        self.backend = backend\n        self.cdll = cdll\n\n    def load_function(self, BType, name):\n        c_func = getattr(self.cdll, name)\n        funcobj = BType._from_ctypes(c_func)\n        funcobj._name = name\n        return funcobj\n\n    def read_variable(self, BType, name):\n        try:\n            ctypes_obj = BType._ctype.in_dll(self.cdll, name)\n        except AttributeError as e:\n            raise NotImplementedError(e)\n        return BType._from_ctypes(ctypes_obj)\n\n    def write_variable(self, BType, name, value):\n        new_ctypes_obj = BType._to_ctypes(value)\n        ctypes_obj = BType._ctype.in_dll(self.cdll, name)\n        ctypes.memmove(ctypes.addressof(ctypes_obj),\n                       ctypes.addressof(new_ctypes_obj),\n                       ctypes.sizeof(BType._ctype))\n", "src/cffi/lock.py": "import sys\n\nif sys.version_info < (3,):\n    try:\n        from thread import allocate_lock\n    except ImportError:\n        from dummy_thread import allocate_lock\nelse:\n    try:\n        from _thread import allocate_lock\n    except ImportError:\n        from _dummy_thread import allocate_lock\n\n\n##import sys\n##l1 = allocate_lock\n\n##class allocate_lock(object):\n##    def __init__(self):\n##        self._real = l1()\n##    def __enter__(self):\n##        for i in range(4, 0, -1):\n##            print sys._getframe(i).f_code\n##        print\n##        return self._real.__enter__()\n##    def __exit__(self, *args):\n##        return self._real.__exit__(*args)\n##    def acquire(self, f):\n##        assert f is False\n##        return self._real.acquire(f)\n", "src/cffi/commontypes.py": "import sys\nfrom . import model\nfrom .error import FFIError\n\n\nCOMMON_TYPES = {}\n\ntry:\n    # fetch \"bool\" and all simple Windows types\n    from _cffi_backend import _get_common_types\n    _get_common_types(COMMON_TYPES)\nexcept ImportError:\n    pass\n\nCOMMON_TYPES['FILE'] = model.unknown_type('FILE', '_IO_FILE')\nCOMMON_TYPES['bool'] = '_Bool'    # in case we got ImportError above\nCOMMON_TYPES['float _Complex'] = '_cffi_float_complex_t'\nCOMMON_TYPES['double _Complex'] = '_cffi_double_complex_t'\n\nfor _type in model.PrimitiveType.ALL_PRIMITIVE_TYPES:\n    if _type.endswith('_t'):\n        COMMON_TYPES[_type] = _type\ndel _type\n\n_CACHE = {}\n\ndef resolve_common_type(parser, commontype):\n    try:\n        return _CACHE[commontype]\n    except KeyError:\n        cdecl = COMMON_TYPES.get(commontype, commontype)\n        if not isinstance(cdecl, str):\n            result, quals = cdecl, 0    # cdecl is already a BaseType\n        elif cdecl in model.PrimitiveType.ALL_PRIMITIVE_TYPES:\n            result, quals = model.PrimitiveType(cdecl), 0\n        elif cdecl == 'set-unicode-needed':\n            raise FFIError(\"The Windows type %r is only available after \"\n                           \"you call ffi.set_unicode()\" % (commontype,))\n        else:\n            if commontype == cdecl:\n                raise FFIError(\n                    \"Unsupported type: %r.  Please look at \"\n        \"http://cffi.readthedocs.io/en/latest/cdef.html#ffi-cdef-limitations \"\n                    \"and file an issue if you think this type should really \"\n                    \"be supported.\" % (commontype,))\n            result, quals = parser.parse_type_and_quals(cdecl)   # recursive\n\n        assert isinstance(result, model.BaseTypeByIdentity)\n        _CACHE[commontype] = result, quals\n        return result, quals\n\n\n# ____________________________________________________________\n# extra types for Windows (most of them are in commontypes.c)\n\n\ndef win_common_types():\n    return {\n        \"UNICODE_STRING\": model.StructType(\n            \"_UNICODE_STRING\",\n            [\"Length\",\n             \"MaximumLength\",\n             \"Buffer\"],\n            [model.PrimitiveType(\"unsigned short\"),\n             model.PrimitiveType(\"unsigned short\"),\n             model.PointerType(model.PrimitiveType(\"wchar_t\"))],\n            [-1, -1, -1]),\n        \"PUNICODE_STRING\": \"UNICODE_STRING *\",\n        \"PCUNICODE_STRING\": \"const UNICODE_STRING *\",\n\n        \"TBYTE\": \"set-unicode-needed\",\n        \"TCHAR\": \"set-unicode-needed\",\n        \"LPCTSTR\": \"set-unicode-needed\",\n        \"PCTSTR\": \"set-unicode-needed\",\n        \"LPTSTR\": \"set-unicode-needed\",\n        \"PTSTR\": \"set-unicode-needed\",\n        \"PTBYTE\": \"set-unicode-needed\",\n        \"PTCHAR\": \"set-unicode-needed\",\n        }\n\nif sys.platform == 'win32':\n    COMMON_TYPES.update(win_common_types())\n", "src/cffi/_shimmed_dist_utils.py": "\"\"\"\nTemporary shim module to indirect the bits of distutils we need from setuptools/distutils while providing useful\nerror messages beyond `No module named 'distutils' on Python >= 3.12, or when setuptools' vendored distutils is broken.\n\nThis is a compromise to avoid a hard-dep on setuptools for Python >= 3.12, since many users don't need runtime compilation support from CFFI.\n\"\"\"\nimport sys\n\ntry:\n    # import setuptools first; this is the most robust way to ensure its embedded distutils is available\n    # (the .pth shim should usually work, but this is even more robust)\n    import setuptools\nexcept Exception as ex:\n    if sys.version_info >= (3, 12):\n        # Python 3.12 has no built-in distutils to fall back on, so any import problem is fatal\n        raise Exception(\"This CFFI feature requires setuptools on Python >= 3.12. The setuptools module is missing or non-functional.\") from ex\n\n    # silently ignore on older Pythons (support fallback to stdlib distutils where available)\nelse:\n    del setuptools\n\ntry:\n    # bring in just the bits of distutils we need, whether they really came from setuptools or stdlib-embedded distutils\n    from distutils import log, sysconfig\n    from distutils.ccompiler import CCompiler\n    from distutils.command.build_ext import build_ext\n    from distutils.core import Distribution, Extension\n    from distutils.dir_util import mkpath\n    from distutils.errors import DistutilsSetupError, CompileError, LinkError\n    from distutils.log import set_threshold, set_verbosity\n\n    if sys.platform == 'win32':\n        from distutils.msvc9compiler import MSVCCompiler\nexcept Exception as ex:\n    if sys.version_info >= (3, 12):\n        raise Exception(\"This CFFI feature requires setuptools on Python >= 3.12. Please install the setuptools package.\") from ex\n\n    # anything older, just let the underlying distutils import error fly\n    raise Exception(\"This CFFI feature requires distutils. Please install the distutils or setuptools package.\") from ex\n\ndel sys\n", "src/cffi/error.py": "\nclass FFIError(Exception):\n    __module__ = 'cffi'\n\nclass CDefError(Exception):\n    __module__ = 'cffi'\n    def __str__(self):\n        try:\n            current_decl = self.args[1]\n            filename = current_decl.coord.file\n            linenum = current_decl.coord.line\n            prefix = '%s:%d: ' % (filename, linenum)\n        except (AttributeError, TypeError, IndexError):\n            prefix = ''\n        return '%s%s' % (prefix, self.args[0])\n\nclass VerificationError(Exception):\n    \"\"\" An error raised when verification fails\n    \"\"\"\n    __module__ = 'cffi'\n\nclass VerificationMissing(Exception):\n    \"\"\" An error raised when incomplete structures are passed into\n    cdef, but no verification has been done\n    \"\"\"\n    __module__ = 'cffi'\n\nclass PkgConfigError(Exception):\n    \"\"\" An error raised for missing modules in pkg-config\n    \"\"\"\n    __module__ = 'cffi'\n", "src/cffi/__init__.py": "__all__ = ['FFI', 'VerificationError', 'VerificationMissing', 'CDefError',\n           'FFIError']\n\nfrom .api import FFI\nfrom .error import CDefError, FFIError, VerificationError, VerificationMissing\nfrom .error import PkgConfigError\n\n__version__ = \"1.17.0.dev0\"\n__version_info__ = (1, 17, 0, 'dev0')\n\n# The verifier module file names are based on the CRC32 of a string that\n# contains the following version number.  It may be older than __version__\n# if nothing is clearly incompatible.\n__version_verifier_modules__ = \"0.8.6\"\n", "src/cffi/vengine_cpy.py": "#\n# DEPRECATED: implementation for ffi.verify()\n#\nimport sys\nfrom . import model\nfrom .error import VerificationError\nfrom . import _imp_emulation as imp\n\n\nclass VCPythonEngine(object):\n    _class_key = 'x'\n    _gen_python_module = True\n\n    def __init__(self, verifier):\n        self.verifier = verifier\n        self.ffi = verifier.ffi\n        self._struct_pending_verification = {}\n        self._types_of_builtin_functions = {}\n\n    def patch_extension_kwds(self, kwds):\n        pass\n\n    def find_module(self, module_name, path, so_suffixes):\n        try:\n            f, filename, descr = imp.find_module(module_name, path)\n        except ImportError:\n            return None\n        if f is not None:\n            f.close()\n        # Note that after a setuptools installation, there are both .py\n        # and .so files with the same basename.  The code here relies on\n        # imp.find_module() locating the .so in priority.\n        if descr[0] not in so_suffixes:\n            return None\n        return filename\n\n    def collect_types(self):\n        self._typesdict = {}\n        self._generate(\"collecttype\")\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def _gettypenum(self, type):\n        # a KeyError here is a bug.  please report it! :-)\n        return self._typesdict[type]\n\n    def _do_collect_type(self, tp):\n        if ((not isinstance(tp, model.PrimitiveType)\n             or tp.name == 'long double')\n                and tp not in self._typesdict):\n            num = len(self._typesdict)\n            self._typesdict[tp] = num\n\n    def write_source_to_f(self):\n        self.collect_types()\n        #\n        # The new module will have a _cffi_setup() function that receives\n        # objects from the ffi world, and that calls some setup code in\n        # the module.  This setup code is split in several independent\n        # functions, e.g. one per constant.  The functions are \"chained\"\n        # by ending in a tail call to each other.\n        #\n        # This is further split in two chained lists, depending on if we\n        # can do it at import-time or if we must wait for _cffi_setup() to\n        # provide us with the <ctype> objects.  This is needed because we\n        # need the values of the enum constants in order to build the\n        # <ctype 'enum'> that we may have to pass to _cffi_setup().\n        #\n        # The following two 'chained_list_constants' items contains\n        # the head of these two chained lists, as a string that gives the\n        # call to do, if any.\n        self._chained_list_constants = ['((void)lib,0)', '((void)lib,0)']\n        #\n        prnt = self._prnt\n        # first paste some standard set of lines that are mostly '#define'\n        prnt(cffimod_header)\n        prnt()\n        # then paste the C source given by the user, verbatim.\n        prnt(self.verifier.preamble)\n        prnt()\n        #\n        # call generate_cpy_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._generate(\"decl\")\n        #\n        # implement the function _cffi_setup_custom() as calling the\n        # head of the chained list.\n        self._generate_setup_custom()\n        prnt()\n        #\n        # produce the method table, including the entries for the\n        # generated Python->C function wrappers, which are done\n        # by generate_cpy_function_method().\n        prnt('static PyMethodDef _cffi_methods[] = {')\n        self._generate(\"method\")\n        prnt('  {\"_cffi_setup\", _cffi_setup, METH_VARARGS, NULL},')\n        prnt('  {NULL, NULL, 0, NULL}    /* Sentinel */')\n        prnt('};')\n        prnt()\n        #\n        # standard init.\n        modname = self.verifier.get_module_name()\n        constants = self._chained_list_constants[False]\n        prnt('#if PY_MAJOR_VERSION >= 3')\n        prnt()\n        prnt('static struct PyModuleDef _cffi_module_def = {')\n        prnt('  PyModuleDef_HEAD_INIT,')\n        prnt('  \"%s\",' % modname)\n        prnt('  NULL,')\n        prnt('  -1,')\n        prnt('  _cffi_methods,')\n        prnt('  NULL, NULL, NULL, NULL')\n        prnt('};')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('PyInit_%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = PyModule_Create(&_cffi_module_def);')\n        prnt('  if (lib == NULL)')\n        prnt('    return NULL;')\n        prnt('  if (%s < 0 || _cffi_init() < 0) {' % (constants,))\n        prnt('    Py_DECREF(lib);')\n        prnt('    return NULL;')\n        prnt('  }')\n        prnt('  return lib;')\n        prnt('}')\n        prnt()\n        prnt('#else')\n        prnt()\n        prnt('PyMODINIT_FUNC')\n        prnt('init%s(void)' % modname)\n        prnt('{')\n        prnt('  PyObject *lib;')\n        prnt('  lib = Py_InitModule(\"%s\", _cffi_methods);' % modname)\n        prnt('  if (lib == NULL)')\n        prnt('    return;')\n        prnt('  if (%s < 0 || _cffi_init() < 0)' % (constants,))\n        prnt('    return;')\n        prnt('  return;')\n        prnt('}')\n        prnt()\n        prnt('#endif')\n\n    def load_library(self, flags=None):\n        # XXX review all usages of 'self' here!\n        # import it as a new extension module\n        imp.acquire_lock()\n        try:\n            if hasattr(sys, \"getdlopenflags\"):\n                previous_flags = sys.getdlopenflags()\n            try:\n                if hasattr(sys, \"setdlopenflags\") and flags is not None:\n                    sys.setdlopenflags(flags)\n                module = imp.load_dynamic(self.verifier.get_module_name(),\n                                          self.verifier.modulefilename)\n            except ImportError as e:\n                error = \"importing %r: %s\" % (self.verifier.modulefilename, e)\n                raise VerificationError(error)\n            finally:\n                if hasattr(sys, \"setdlopenflags\"):\n                    sys.setdlopenflags(previous_flags)\n        finally:\n            imp.release_lock()\n        #\n        # call loading_cpy_struct() to get the struct layout inferred by\n        # the C compiler\n        self._load(module, 'loading')\n        #\n        # the C code will need the <ctype> objects.  Collect them in\n        # order in a list.\n        revmapping = dict([(value, key)\n                           for (key, value) in self._typesdict.items()])\n        lst = [revmapping[i] for i in range(len(revmapping))]\n        lst = list(map(self.ffi._get_cached_btype, lst))\n        #\n        # build the FFILibrary class and instance and call _cffi_setup().\n        # this will set up some fields like '_cffi_types', and only then\n        # it will invoke the chained list of functions that will really\n        # build (notably) the constant objects, as <cdata> if they are\n        # pointers, and store them as attributes on the 'library' object.\n        class FFILibrary(object):\n            _cffi_python_module = module\n            _cffi_ffi = self.ffi\n            _cffi_dir = []\n            def __dir__(self):\n                return FFILibrary._cffi_dir + list(self.__dict__)\n        library = FFILibrary()\n        if module._cffi_setup(lst, VerificationError, library):\n            import warnings\n            warnings.warn(\"reimporting %r might overwrite older definitions\"\n                          % (self.verifier.get_module_name()))\n        #\n        # finally, call the loaded_cpy_xxx() functions.  This will perform\n        # the final adjustments, like copying the Python->C wrapper\n        # functions from the module to the 'library' object, and setting\n        # up the FFILibrary class with properties for the global C variables.\n        self._load(module, 'loaded', library=library)\n        module._cffi_original_ffi = self.ffi\n        module._cffi_types_of_builtin_funcs = self._types_of_builtin_functions\n        return library\n\n    def _get_declarations(self):\n        lst = [(key, tp) for (key, (tp, qual)) in\n                                self.ffi._parser._declarations.items()]\n        lst.sort()\n        return lst\n\n    def _generate(self, step_name):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_cpy_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise VerificationError(\n                    \"not implemented in verify(): %r\" % name)\n            try:\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _load(self, module, step_name, **kwds):\n        for name, tp in self._get_declarations():\n            kind, realname = name.split(' ', 1)\n            method = getattr(self, '_%s_cpy_%s' % (step_name, kind))\n            try:\n                method(tp, realname, module, **kwds)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    def _generate_nothing(self, tp, name):\n        pass\n\n    def _loaded_noop(self, tp, name, module, **kwds):\n        pass\n\n    # ----------\n\n    def _convert_funcarg_to_c(self, tp, fromvar, tovar, errcode):\n        extraarg = ''\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                converter = '_cffi_to_c_int'\n                extraarg = ', %s' % tp.name\n            elif tp.is_complex_type():\n                raise VerificationError(\n                    \"not implemented in verify(): complex types\")\n            else:\n                converter = '(%s)_cffi_to_c_%s' % (tp.get_c_name(''),\n                                                   tp.name.replace(' ', '_'))\n            errvalue = '-1'\n        #\n        elif isinstance(tp, model.PointerType):\n            self._convert_funcarg_to_c_ptr_or_array(tp, fromvar,\n                                                    tovar, errcode)\n            return\n        #\n        elif isinstance(tp, (model.StructOrUnion, model.EnumType)):\n            # a struct (not a struct pointer) as a function argument\n            self._prnt('  if (_cffi_to_c((char *)&%s, _cffi_type(%d), %s) < 0)'\n                      % (tovar, self._gettypenum(tp), fromvar))\n            self._prnt('    %s;' % errcode)\n            return\n        #\n        elif isinstance(tp, model.FunctionPtrType):\n            converter = '(%s)_cffi_to_c_pointer' % tp.get_c_name('')\n            extraarg = ', _cffi_type(%d)' % self._gettypenum(tp)\n            errvalue = 'NULL'\n        #\n        else:\n            raise NotImplementedError(tp)\n        #\n        self._prnt('  %s = %s(%s%s);' % (tovar, converter, fromvar, extraarg))\n        self._prnt('  if (%s == (%s)%s && PyErr_Occurred())' % (\n            tovar, tp.get_c_name(''), errvalue))\n        self._prnt('    %s;' % errcode)\n\n    def _extra_local_variables(self, tp, localvars, freelines):\n        if isinstance(tp, model.PointerType):\n            localvars.add('Py_ssize_t datasize')\n            localvars.add('struct _cffi_freeme_s *large_args_free = NULL')\n            freelines.add('if (large_args_free != NULL)'\n                          ' _cffi_free_array_arguments(large_args_free);')\n\n    def _convert_funcarg_to_c_ptr_or_array(self, tp, fromvar, tovar, errcode):\n        self._prnt('  datasize = _cffi_prepare_pointer_call_argument(')\n        self._prnt('      _cffi_type(%d), %s, (char **)&%s);' % (\n            self._gettypenum(tp), fromvar, tovar))\n        self._prnt('  if (datasize != 0) {')\n        self._prnt('    %s = ((size_t)datasize) <= 640 ? '\n                   'alloca((size_t)datasize) : NULL;' % (tovar,))\n        self._prnt('    if (_cffi_convert_array_argument(_cffi_type(%d), %s, '\n                   '(char **)&%s,' % (self._gettypenum(tp), fromvar, tovar))\n        self._prnt('            datasize, &large_args_free) < 0)')\n        self._prnt('      %s;' % errcode)\n        self._prnt('  }')\n\n    def _convert_expr_from_c(self, tp, var, context):\n        if isinstance(tp, model.PrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                return '_cffi_from_c_int(%s, %s)' % (var, tp.name)\n            elif tp.name != 'long double':\n                return '_cffi_from_c_%s(%s)' % (tp.name.replace(' ', '_'), var)\n            else:\n                return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                    var, self._gettypenum(tp))\n        elif isinstance(tp, (model.PointerType, model.FunctionPtrType)):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.ArrayType):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(model.PointerType(tp.item)))\n        elif isinstance(tp, model.StructOrUnion):\n            if tp.fldnames is None:\n                raise TypeError(\"'%s' is used as %s, but is opaque\" % (\n                    tp._get_c_name(), context))\n            return '_cffi_from_c_struct((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.EnumType):\n            return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        else:\n            raise NotImplementedError(tp)\n\n    # ----------\n    # typedefs: generates no code so far\n\n    _generate_cpy_typedef_collecttype = _generate_nothing\n    _generate_cpy_typedef_decl   = _generate_nothing\n    _generate_cpy_typedef_method = _generate_nothing\n    _loading_cpy_typedef         = _loaded_noop\n    _loaded_cpy_typedef          = _loaded_noop\n\n    # ----------\n    # function declarations\n\n    def _generate_cpy_function_collecttype(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            self._do_collect_type(tp)\n        else:\n            # don't call _do_collect_type(tp) in this common case,\n            # otherwise test_autofilled_struct_as_argument fails\n            for type in tp.args:\n                self._do_collect_type(type)\n            self._do_collect_type(tp.result)\n\n    def _generate_cpy_function_decl(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no CPython wrapper)\n            self._generate_cpy_const(False, name, tp)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        if numargs == 0:\n            argname = 'noarg'\n        elif numargs == 1:\n            argname = 'arg0'\n        else:\n            argname = 'args'\n        prnt('static PyObject *')\n        prnt('_cffi_f_%s(PyObject *self, PyObject *%s)' % (name, argname))\n        prnt('{')\n        #\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            prnt('  %s;' % type.get_c_name(' x%d' % i, context))\n        #\n        localvars = set()\n        freelines = set()\n        for type in tp.args:\n            self._extra_local_variables(type, localvars, freelines)\n        for decl in sorted(localvars):\n            prnt('  %s;' % (decl,))\n        #\n        if not isinstance(tp.result, model.VoidType):\n            result_code = 'result = '\n            context = 'result of %s' % name\n            prnt('  %s;' % tp.result.get_c_name(' result', context))\n            prnt('  PyObject *pyresult;')\n        else:\n            result_code = ''\n        #\n        if len(tp.args) > 1:\n            rng = range(len(tp.args))\n            for i in rng:\n                prnt('  PyObject *arg%d;' % i)\n            prnt()\n            prnt('  if (!PyArg_ParseTuple(args, \"%s:%s\", %s))' % (\n                'O' * numargs, name, ', '.join(['&arg%d' % i for i in rng])))\n            prnt('    return NULL;')\n        prnt()\n        #\n        for i, type in enumerate(tp.args):\n            self._convert_funcarg_to_c(type, 'arg%d' % i, 'x%d' % i,\n                                       'return NULL')\n            prnt()\n        #\n        prnt('  Py_BEGIN_ALLOW_THREADS')\n        prnt('  _cffi_restore_errno();')\n        prnt('  { %s%s(%s); }' % (\n            result_code, name,\n            ', '.join(['x%d' % i for i in range(len(tp.args))])))\n        prnt('  _cffi_save_errno();')\n        prnt('  Py_END_ALLOW_THREADS')\n        prnt()\n        #\n        prnt('  (void)self; /* unused */')\n        if numargs == 0:\n            prnt('  (void)noarg; /* unused */')\n        if result_code:\n            prnt('  pyresult = %s;' %\n                 self._convert_expr_from_c(tp.result, 'result', 'result type'))\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  return pyresult;')\n        else:\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  Py_INCREF(Py_None);')\n            prnt('  return Py_None;')\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_function_method(self, tp, name):\n        if tp.ellipsis:\n            return\n        numargs = len(tp.args)\n        if numargs == 0:\n            meth = 'METH_NOARGS'\n        elif numargs == 1:\n            meth = 'METH_O'\n        else:\n            meth = 'METH_VARARGS'\n        self._prnt('  {\"%s\", _cffi_f_%s, %s, NULL},' % (name, name, meth))\n\n    _loading_cpy_function = _loaded_noop\n\n    def _loaded_cpy_function(self, tp, name, module, library):\n        if tp.ellipsis:\n            return\n        func = getattr(module, name)\n        setattr(library, name, func)\n        self._types_of_builtin_functions[func] = tp\n\n    # ----------\n    # named structs\n\n    _generate_cpy_struct_collecttype = _generate_nothing\n    def _generate_cpy_struct_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'struct', name)\n    def _generate_cpy_struct_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'struct', name)\n    def _loading_cpy_struct(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'struct', name, module)\n    def _loaded_cpy_struct(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    _generate_cpy_union_collecttype = _generate_nothing\n    def _generate_cpy_union_decl(self, tp, name):\n        assert name == tp.name\n        self._generate_struct_or_union_decl(tp, 'union', name)\n    def _generate_cpy_union_method(self, tp, name):\n        self._generate_struct_or_union_method(tp, 'union', name)\n    def _loading_cpy_union(self, tp, name, module):\n        self._loading_struct_or_union(tp, 'union', name, module)\n    def _loaded_cpy_union(self, tp, name, module, **kwds):\n        self._loaded_struct_or_union(tp)\n\n    def _generate_struct_or_union_decl(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        checkfuncname = '_cffi_check_%s_%s' % (prefix, name)\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        cname = ('%s %s' % (prefix, name)).strip()\n        #\n        prnt = self._prnt\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if (isinstance(ftype, model.PrimitiveType)\n                and ftype.is_integer_type()) or fbitsize >= 0:\n                # accept all integers, but complain on float or double\n                prnt('  (void)((p->%s) << 1);' % fname)\n            else:\n                # only accept exactly the type declared.\n                try:\n                    prnt('  { %s = &p->%s; (void)tmp; }' % (\n                        ftype.get_c_name('*tmp', 'field %r'%fname, quals=fqual),\n                        fname))\n                except VerificationError as e:\n                    prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        prnt('static PyObject *')\n        prnt('%s(PyObject *self, PyObject *noarg)' % (layoutfuncname,))\n        prnt('{')\n        prnt('  struct _cffi_aligncheck { char x; %s y; };' % cname)\n        prnt('  static Py_ssize_t nums[] = {')\n        prnt('    sizeof(%s),' % cname)\n        prnt('    offsetof(struct _cffi_aligncheck, y),')\n        for fname, ftype, fbitsize, fqual in tp.enumfields():\n            if fbitsize >= 0:\n                continue      # xxx ignore fbitsize for now\n            prnt('    offsetof(%s, %s),' % (cname, fname))\n            if isinstance(ftype, model.ArrayType) and ftype.length is None:\n                prnt('    0,  /* %s */' % ftype._get_c_name())\n            else:\n                prnt('    sizeof(((%s *)0)->%s),' % (cname, fname))\n        prnt('    -1')\n        prnt('  };')\n        prnt('  (void)self; /* unused */')\n        prnt('  (void)noarg; /* unused */')\n        prnt('  return _cffi_get_struct_layout(nums);')\n        prnt('  /* the next line is not executed, but compiled */')\n        prnt('  %s(0);' % (checkfuncname,))\n        prnt('}')\n        prnt()\n\n    def _generate_struct_or_union_method(self, tp, prefix, name):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        self._prnt('  {\"%s\", %s, METH_NOARGS, NULL},' % (layoutfuncname,\n                                                         layoutfuncname))\n\n    def _loading_struct_or_union(self, tp, prefix, name, module):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        layoutfuncname = '_cffi_layout_%s_%s' % (prefix, name)\n        #\n        function = getattr(module, layoutfuncname)\n        layout = function()\n        if isinstance(tp, model.StructOrUnion) and tp.partial:\n            # use the function()'s sizes and offsets to guide the\n            # layout of the struct\n            totalsize = layout[0]\n            totalalignment = layout[1]\n            fieldofs = layout[2::2]\n            fieldsize = layout[3::2]\n            tp.force_flatten()\n            assert len(fieldofs) == len(fieldsize) == len(tp.fldnames)\n            tp.fixedlayout = fieldofs, fieldsize, totalsize, totalalignment\n        else:\n            cname = ('%s %s' % (prefix, name)).strip()\n            self._struct_pending_verification[tp] = layout, cname\n\n    def _loaded_struct_or_union(self, tp):\n        if tp.fldnames is None:\n            return     # nothing to do with opaque structs\n        self.ffi._get_cached_btype(tp)   # force 'fixedlayout' to be considered\n\n        if tp in self._struct_pending_verification:\n            # check that the layout sizes and offsets match the real ones\n            def check(realvalue, expectedvalue, msg):\n                if realvalue != expectedvalue:\n                    raise VerificationError(\n                        \"%s (we have %d, but C compiler says %d)\"\n                        % (msg, expectedvalue, realvalue))\n            ffi = self.ffi\n            BStruct = ffi._get_cached_btype(tp)\n            layout, cname = self._struct_pending_verification.pop(tp)\n            check(layout[0], ffi.sizeof(BStruct), \"wrong total size\")\n            check(layout[1], ffi.alignof(BStruct), \"wrong total alignment\")\n            i = 2\n            for fname, ftype, fbitsize, fqual in tp.enumfields():\n                if fbitsize >= 0:\n                    continue        # xxx ignore fbitsize for now\n                check(layout[i], ffi.offsetof(BStruct, fname),\n                      \"wrong offset for field %r\" % (fname,))\n                if layout[i+1] != 0:\n                    BField = ffi._get_cached_btype(ftype)\n                    check(layout[i+1], ffi.sizeof(BField),\n                          \"wrong size for field %r\" % (fname,))\n                i += 2\n            assert i == len(layout)\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    _generate_cpy_anonymous_collecttype = _generate_nothing\n\n    def _generate_cpy_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_decl(tp, name, '')\n        else:\n            self._generate_struct_or_union_decl(tp, '', name)\n\n    def _generate_cpy_anonymous_method(self, tp, name):\n        if not isinstance(tp, model.EnumType):\n            self._generate_struct_or_union_method(tp, '', name)\n\n    def _loading_cpy_anonymous(self, tp, name, module):\n        if isinstance(tp, model.EnumType):\n            self._loading_cpy_enum(tp, name, module)\n        else:\n            self._loading_struct_or_union(tp, '', name, module)\n\n    def _loaded_cpy_anonymous(self, tp, name, module, **kwds):\n        if isinstance(tp, model.EnumType):\n            self._loaded_cpy_enum(tp, name, module, **kwds)\n        else:\n            self._loaded_struct_or_union(tp)\n\n    # ----------\n    # constants, likely declared with '#define'\n\n    def _generate_cpy_const(self, is_int, name, tp=None, category='const',\n                            vartp=None, delayed=True, size_too=False,\n                            check_value=None):\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        prnt('  PyObject *o;')\n        prnt('  int res;')\n        if not is_int:\n            prnt('  %s;' % (vartp or tp).get_c_name(' i', name))\n        else:\n            assert category == 'const'\n        #\n        if check_value is not None:\n            self._check_int_constant_value(name, check_value)\n        #\n        if not is_int:\n            if category == 'var':\n                realexpr = '&' + name\n            else:\n                realexpr = name\n            prnt('  i = (%s);' % (realexpr,))\n            prnt('  o = %s;' % (self._convert_expr_from_c(tp, 'i',\n                                                          'variable type'),))\n            assert delayed\n        else:\n            prnt('  o = _cffi_from_c_int_const(%s);' % name)\n        prnt('  if (o == NULL)')\n        prnt('    return -1;')\n        if size_too:\n            prnt('  {')\n            prnt('    PyObject *o1 = o;')\n            prnt('    o = Py_BuildValue(\"On\", o1, (Py_ssize_t)sizeof(%s));'\n                 % (name,))\n            prnt('    Py_DECREF(o1);')\n            prnt('    if (o == NULL)')\n            prnt('      return -1;')\n            prnt('  }')\n        prnt('  res = PyObject_SetAttrString(lib, \"%s\", o);' % name)\n        prnt('  Py_DECREF(o);')\n        prnt('  if (res < 0)')\n        prnt('    return -1;')\n        prnt('  return %s;' % self._chained_list_constants[delayed])\n        self._chained_list_constants[delayed] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_constant_collecttype(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        if not is_int:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_constant_decl(self, tp, name):\n        is_int = isinstance(tp, model.PrimitiveType) and tp.is_integer_type()\n        self._generate_cpy_const(is_int, name, tp)\n\n    _generate_cpy_constant_method = _generate_nothing\n    _loading_cpy_constant = _loaded_noop\n    _loaded_cpy_constant  = _loaded_noop\n\n    # ----------\n    # enums\n\n    def _check_int_constant_value(self, name, value, err_prefix=''):\n        prnt = self._prnt\n        if value <= 0:\n            prnt('  if ((%s) > 0 || (long)(%s) != %dL) {' % (\n                name, name, value))\n        else:\n            prnt('  if ((%s) <= 0 || (unsigned long)(%s) != %dUL) {' % (\n                name, name, value))\n        prnt('    char buf[64];')\n        prnt('    if ((%s) <= 0)' % name)\n        prnt('        snprintf(buf, 63, \"%%ld\", (long)(%s));' % name)\n        prnt('    else')\n        prnt('        snprintf(buf, 63, \"%%lu\", (unsigned long)(%s));' %\n             name)\n        prnt('    PyErr_Format(_cffi_VerificationError,')\n        prnt('                 \"%s%s has the real value %s, not %s\",')\n        prnt('                 \"%s\", \"%s\", buf, \"%d\");' % (\n            err_prefix, name, value))\n        prnt('    return -1;')\n        prnt('  }')\n\n    def _enum_funcname(self, prefix, name):\n        # \"$enum_$1\" => \"___D_enum____D_1\"\n        name = name.replace('$', '___D_')\n        return '_cffi_e_%s_%s' % (prefix, name)\n\n    def _generate_cpy_enum_decl(self, tp, name, prefix='enum'):\n        if tp.partial:\n            for enumerator in tp.enumerators:\n                self._generate_cpy_const(True, enumerator, delayed=False)\n            return\n        #\n        funcname = self._enum_funcname(prefix, name)\n        prnt = self._prnt\n        prnt('static int %s(PyObject *lib)' % funcname)\n        prnt('{')\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._check_int_constant_value(enumerator, enumvalue,\n                                           \"enum %s: \" % name)\n        prnt('  return %s;' % self._chained_list_constants[True])\n        self._chained_list_constants[True] = funcname + '(lib)'\n        prnt('}')\n        prnt()\n\n    _generate_cpy_enum_collecttype = _generate_nothing\n    _generate_cpy_enum_method = _generate_nothing\n\n    def _loading_cpy_enum(self, tp, name, module):\n        if tp.partial:\n            enumvalues = [getattr(module, enumerator)\n                          for enumerator in tp.enumerators]\n            tp.enumvalues = tuple(enumvalues)\n            tp.partial_resolved = True\n\n    def _loaded_cpy_enum(self, tp, name, module, library):\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            setattr(library, enumerator, enumvalue)\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_cpy_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_cpy_const(True, name, check_value=check_value)\n\n    _generate_cpy_macro_collecttype = _generate_nothing\n    _generate_cpy_macro_method = _generate_nothing\n    _loading_cpy_macro = _loaded_noop\n    _loaded_cpy_macro  = _loaded_noop\n\n    # ----------\n    # global variables\n\n    def _generate_cpy_variable_collecttype(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n        else:\n            tp_ptr = model.PointerType(tp)\n        self._do_collect_type(tp_ptr)\n\n    def _generate_cpy_variable_decl(self, tp, name):\n        if isinstance(tp, model.ArrayType):\n            tp_ptr = model.PointerType(tp.item)\n            self._generate_cpy_const(False, name, tp, vartp=tp_ptr,\n                                     size_too = tp.length_is_unknown())\n        else:\n            tp_ptr = model.PointerType(tp)\n            self._generate_cpy_const(False, name, tp_ptr, category='var')\n\n    _generate_cpy_variable_method = _generate_nothing\n    _loading_cpy_variable = _loaded_noop\n\n    def _loaded_cpy_variable(self, tp, name, module, library):\n        value = getattr(library, name)\n        if isinstance(tp, model.ArrayType):   # int a[5] is \"constant\" in the\n                                              # sense that \"a=...\" is forbidden\n            if tp.length_is_unknown():\n                assert isinstance(value, tuple)\n                (value, size) = value\n                BItemType = self.ffi._get_cached_btype(tp.item)\n                length, rest = divmod(size, self.ffi.sizeof(BItemType))\n                if rest != 0:\n                    raise VerificationError(\n                        \"bad size: %r does not seem to be an array of %s\" %\n                        (name, tp.item))\n                tp = tp.resolve_length(length)\n            # 'value' is a <cdata 'type *'> which we have to replace with\n            # a <cdata 'type[N]'> if the N is actually known\n            if tp.length is not None:\n                BArray = self.ffi._get_cached_btype(tp)\n                value = self.ffi.cast(BArray, value)\n                setattr(library, name, value)\n            return\n        # remove ptr=<cdata 'int *'> from the library instance, and replace\n        # it by a property on the class, which reads/writes into ptr[0].\n        ptr = value\n        delattr(library, name)\n        def getter(library):\n            return ptr[0]\n        def setter(library, value):\n            ptr[0] = value\n        setattr(type(library), name, property(getter, setter))\n        type(library)._cffi_dir.append(name)\n\n    # ----------\n\n    def _generate_setup_custom(self):\n        prnt = self._prnt\n        prnt('static int _cffi_setup_custom(PyObject *lib)')\n        prnt('{')\n        prnt('  return %s;' % self._chained_list_constants[True])\n        prnt('}')\n\ncffimod_header = r'''\n#include <Python.h>\n#include <stddef.h>\n\n/* this block of #ifs should be kept exactly identical between\n   c/_cffi_backend.c, cffi/vengine_cpy.py, cffi/vengine_gen.py\n   and cffi/_cffi_include.h */\n#if defined(_MSC_VER)\n# include <malloc.h>   /* for alloca() */\n# if _MSC_VER < 1600   /* MSVC < 2010 */\n   typedef __int8 int8_t;\n   typedef __int16 int16_t;\n   typedef __int32 int32_t;\n   typedef __int64 int64_t;\n   typedef unsigned __int8 uint8_t;\n   typedef unsigned __int16 uint16_t;\n   typedef unsigned __int32 uint32_t;\n   typedef unsigned __int64 uint64_t;\n   typedef __int8 int_least8_t;\n   typedef __int16 int_least16_t;\n   typedef __int32 int_least32_t;\n   typedef __int64 int_least64_t;\n   typedef unsigned __int8 uint_least8_t;\n   typedef unsigned __int16 uint_least16_t;\n   typedef unsigned __int32 uint_least32_t;\n   typedef unsigned __int64 uint_least64_t;\n   typedef __int8 int_fast8_t;\n   typedef __int16 int_fast16_t;\n   typedef __int32 int_fast32_t;\n   typedef __int64 int_fast64_t;\n   typedef unsigned __int8 uint_fast8_t;\n   typedef unsigned __int16 uint_fast16_t;\n   typedef unsigned __int32 uint_fast32_t;\n   typedef unsigned __int64 uint_fast64_t;\n   typedef __int64 intmax_t;\n   typedef unsigned __int64 uintmax_t;\n# else\n#  include <stdint.h>\n# endif\n# if _MSC_VER < 1800   /* MSVC < 2013 */\n#  ifndef __cplusplus\n    typedef unsigned char _Bool;\n#  endif\n# endif\n# define _cffi_float_complex_t   _Fcomplex    /* include <complex.h> for it */\n# define _cffi_double_complex_t  _Dcomplex    /* include <complex.h> for it */\n#else\n# include <stdint.h>\n# if (defined (__SVR4) && defined (__sun)) || defined(_AIX) || defined(__hpux)\n#  include <alloca.h>\n# endif\n# define _cffi_float_complex_t   float _Complex\n# define _cffi_double_complex_t  double _Complex\n#endif\n\n#if PY_MAJOR_VERSION < 3\n# undef PyCapsule_CheckExact\n# undef PyCapsule_GetPointer\n# define PyCapsule_CheckExact(capsule) (PyCObject_Check(capsule))\n# define PyCapsule_GetPointer(capsule, name) \\\n    (PyCObject_AsVoidPtr(capsule))\n#endif\n\n#if PY_MAJOR_VERSION >= 3\n# define PyInt_FromLong PyLong_FromLong\n#endif\n\n#define _cffi_from_c_double PyFloat_FromDouble\n#define _cffi_from_c_float PyFloat_FromDouble\n#define _cffi_from_c_long PyInt_FromLong\n#define _cffi_from_c_ulong PyLong_FromUnsignedLong\n#define _cffi_from_c_longlong PyLong_FromLongLong\n#define _cffi_from_c_ulonglong PyLong_FromUnsignedLongLong\n#define _cffi_from_c__Bool PyBool_FromLong\n\n#define _cffi_to_c_double PyFloat_AsDouble\n#define _cffi_to_c_float PyFloat_AsDouble\n\n#define _cffi_from_c_int_const(x)                                        \\\n    (((x) > 0) ?                                                         \\\n        ((unsigned long long)(x) <= (unsigned long long)LONG_MAX) ?      \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)(x)) :       \\\n        ((long long)(x) >= (long long)LONG_MIN) ?                        \\\n            PyInt_FromLong((long)(x)) :                                  \\\n            PyLong_FromLongLong((long long)(x)))\n\n#define _cffi_from_c_int(x, type)                                        \\\n    (((type)-1) > 0 ? /* unsigned */                                     \\\n        (sizeof(type) < sizeof(long) ?                                   \\\n            PyInt_FromLong((long)x) :                                    \\\n         sizeof(type) == sizeof(long) ?                                  \\\n            PyLong_FromUnsignedLong((unsigned long)x) :                  \\\n            PyLong_FromUnsignedLongLong((unsigned long long)x)) :        \\\n        (sizeof(type) <= sizeof(long) ?                                  \\\n            PyInt_FromLong((long)x) :                                    \\\n            PyLong_FromLongLong((long long)x)))\n\n#define _cffi_to_c_int(o, type)                                          \\\n    ((type)(                                                             \\\n     sizeof(type) == 1 ? (((type)-1) > 0 ? (type)_cffi_to_c_u8(o)        \\\n                                         : (type)_cffi_to_c_i8(o)) :     \\\n     sizeof(type) == 2 ? (((type)-1) > 0 ? (type)_cffi_to_c_u16(o)       \\\n                                         : (type)_cffi_to_c_i16(o)) :    \\\n     sizeof(type) == 4 ? (((type)-1) > 0 ? (type)_cffi_to_c_u32(o)       \\\n                                         : (type)_cffi_to_c_i32(o)) :    \\\n     sizeof(type) == 8 ? (((type)-1) > 0 ? (type)_cffi_to_c_u64(o)       \\\n                                         : (type)_cffi_to_c_i64(o)) :    \\\n     (Py_FatalError(\"unsupported size for type \" #type), (type)0)))\n\n#define _cffi_to_c_i8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[1])\n#define _cffi_to_c_u8                                                    \\\n                 ((int(*)(PyObject *))_cffi_exports[2])\n#define _cffi_to_c_i16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[3])\n#define _cffi_to_c_u16                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[4])\n#define _cffi_to_c_i32                                                   \\\n                 ((int(*)(PyObject *))_cffi_exports[5])\n#define _cffi_to_c_u32                                                   \\\n                 ((unsigned int(*)(PyObject *))_cffi_exports[6])\n#define _cffi_to_c_i64                                                   \\\n                 ((long long(*)(PyObject *))_cffi_exports[7])\n#define _cffi_to_c_u64                                                   \\\n                 ((unsigned long long(*)(PyObject *))_cffi_exports[8])\n#define _cffi_to_c_char                                                  \\\n                 ((int(*)(PyObject *))_cffi_exports[9])\n#define _cffi_from_c_pointer                                             \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[10])\n#define _cffi_to_c_pointer                                               \\\n    ((char *(*)(PyObject *, CTypeDescrObject *))_cffi_exports[11])\n#define _cffi_get_struct_layout                                          \\\n    ((PyObject *(*)(Py_ssize_t[]))_cffi_exports[12])\n#define _cffi_restore_errno                                              \\\n    ((void(*)(void))_cffi_exports[13])\n#define _cffi_save_errno                                                 \\\n    ((void(*)(void))_cffi_exports[14])\n#define _cffi_from_c_char                                                \\\n    ((PyObject *(*)(char))_cffi_exports[15])\n#define _cffi_from_c_deref                                               \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[16])\n#define _cffi_to_c                                                       \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[17])\n#define _cffi_from_c_struct                                              \\\n    ((PyObject *(*)(char *, CTypeDescrObject *))_cffi_exports[18])\n#define _cffi_to_c_wchar_t                                               \\\n    ((wchar_t(*)(PyObject *))_cffi_exports[19])\n#define _cffi_from_c_wchar_t                                             \\\n    ((PyObject *(*)(wchar_t))_cffi_exports[20])\n#define _cffi_to_c_long_double                                           \\\n    ((long double(*)(PyObject *))_cffi_exports[21])\n#define _cffi_to_c__Bool                                                 \\\n    ((_Bool(*)(PyObject *))_cffi_exports[22])\n#define _cffi_prepare_pointer_call_argument                              \\\n    ((Py_ssize_t(*)(CTypeDescrObject *, PyObject *, char **))_cffi_exports[23])\n#define _cffi_convert_array_from_object                                  \\\n    ((int(*)(char *, CTypeDescrObject *, PyObject *))_cffi_exports[24])\n#define _CFFI_NUM_EXPORTS 25\n\ntypedef struct _ctypedescr CTypeDescrObject;\n\nstatic void *_cffi_exports[_CFFI_NUM_EXPORTS];\nstatic PyObject *_cffi_types, *_cffi_VerificationError;\n\nstatic int _cffi_setup_custom(PyObject *lib);   /* forward */\n\nstatic PyObject *_cffi_setup(PyObject *self, PyObject *args)\n{\n    PyObject *library;\n    int was_alive = (_cffi_types != NULL);\n    (void)self; /* unused */\n    if (!PyArg_ParseTuple(args, \"OOO\", &_cffi_types, &_cffi_VerificationError,\n                                       &library))\n        return NULL;\n    Py_INCREF(_cffi_types);\n    Py_INCREF(_cffi_VerificationError);\n    if (_cffi_setup_custom(library) < 0)\n        return NULL;\n    return PyBool_FromLong(was_alive);\n}\n\nunion _cffi_union_alignment_u {\n    unsigned char m_char;\n    unsigned short m_short;\n    unsigned int m_int;\n    unsigned long m_long;\n    unsigned long long m_longlong;\n    float m_float;\n    double m_double;\n    long double m_longdouble;\n};\n\nstruct _cffi_freeme_s {\n    struct _cffi_freeme_s *next;\n    union _cffi_union_alignment_u alignment;\n};\n\n#ifdef __GNUC__\n  __attribute__((unused))\n#endif\nstatic int _cffi_convert_array_argument(CTypeDescrObject *ctptr, PyObject *arg,\n                                        char **output_data, Py_ssize_t datasize,\n                                        struct _cffi_freeme_s **freeme)\n{\n    char *p;\n    if (datasize < 0)\n        return -1;\n\n    p = *output_data;\n    if (p == NULL) {\n        struct _cffi_freeme_s *fp = (struct _cffi_freeme_s *)PyObject_Malloc(\n            offsetof(struct _cffi_freeme_s, alignment) + (size_t)datasize);\n        if (fp == NULL)\n            return -1;\n        fp->next = *freeme;\n        *freeme = fp;\n        p = *output_data = (char *)&fp->alignment;\n    }\n    memset((void *)p, 0, (size_t)datasize);\n    return _cffi_convert_array_from_object(p, ctptr, arg);\n}\n\n#ifdef __GNUC__\n  __attribute__((unused))\n#endif\nstatic void _cffi_free_array_arguments(struct _cffi_freeme_s *freeme)\n{\n    do {\n        void *p = (void *)freeme;\n        freeme = freeme->next;\n        PyObject_Free(p);\n    } while (freeme != NULL);\n}\n\nstatic int _cffi_init(void)\n{\n    PyObject *module, *c_api_object = NULL;\n\n    module = PyImport_ImportModule(\"_cffi_backend\");\n    if (module == NULL)\n        goto failure;\n\n    c_api_object = PyObject_GetAttrString(module, \"_C_API\");\n    if (c_api_object == NULL)\n        goto failure;\n    if (!PyCapsule_CheckExact(c_api_object)) {\n        PyErr_SetNone(PyExc_ImportError);\n        goto failure;\n    }\n    memcpy(_cffi_exports, PyCapsule_GetPointer(c_api_object, \"cffi\"),\n           _CFFI_NUM_EXPORTS * sizeof(void *));\n\n    Py_DECREF(module);\n    Py_DECREF(c_api_object);\n    return 0;\n\n  failure:\n    Py_XDECREF(module);\n    Py_XDECREF(c_api_object);\n    return -1;\n}\n\n#define _cffi_type(num) ((CTypeDescrObject *)PyList_GET_ITEM(_cffi_types, num))\n\n/**********/\n'''\n", "src/cffi/recompiler.py": "import os, sys, io\nfrom . import ffiplatform, model\nfrom .error import VerificationError\nfrom .cffi_opcode import *\n\nVERSION_BASE = 0x2601\nVERSION_EMBEDDED = 0x2701\nVERSION_CHAR16CHAR32 = 0x2801\n\nUSE_LIMITED_API = (sys.platform != 'win32' or sys.version_info < (3, 0) or\n                   sys.version_info >= (3, 5))\n\n\nclass GlobalExpr:\n    def __init__(self, name, address, type_op, size=0, check_value=0):\n        self.name = name\n        self.address = address\n        self.type_op = type_op\n        self.size = size\n        self.check_value = check_value\n\n    def as_c_expr(self):\n        return '  { \"%s\", (void *)%s, %s, (void *)%s },' % (\n            self.name, self.address, self.type_op.as_c_expr(), self.size)\n\n    def as_python_expr(self):\n        return \"b'%s%s',%d\" % (self.type_op.as_python_bytes(), self.name,\n                               self.check_value)\n\nclass FieldExpr:\n    def __init__(self, name, field_offset, field_size, fbitsize, field_type_op):\n        self.name = name\n        self.field_offset = field_offset\n        self.field_size = field_size\n        self.fbitsize = fbitsize\n        self.field_type_op = field_type_op\n\n    def as_c_expr(self):\n        spaces = \" \" * len(self.name)\n        return ('  { \"%s\", %s,\\n' % (self.name, self.field_offset) +\n                '     %s   %s,\\n' % (spaces, self.field_size) +\n                '     %s   %s },' % (spaces, self.field_type_op.as_c_expr()))\n\n    def as_python_expr(self):\n        raise NotImplementedError\n\n    def as_field_python_expr(self):\n        if self.field_type_op.op == OP_NOOP:\n            size_expr = ''\n        elif self.field_type_op.op == OP_BITFIELD:\n            size_expr = format_four_bytes(self.fbitsize)\n        else:\n            raise NotImplementedError\n        return \"b'%s%s%s'\" % (self.field_type_op.as_python_bytes(),\n                              size_expr,\n                              self.name)\n\nclass StructUnionExpr:\n    def __init__(self, name, type_index, flags, size, alignment, comment,\n                 first_field_index, c_fields):\n        self.name = name\n        self.type_index = type_index\n        self.flags = flags\n        self.size = size\n        self.alignment = alignment\n        self.comment = comment\n        self.first_field_index = first_field_index\n        self.c_fields = c_fields\n\n    def as_c_expr(self):\n        return ('  { \"%s\", %d, %s,' % (self.name, self.type_index, self.flags)\n                + '\\n    %s, %s, ' % (self.size, self.alignment)\n                + '%d, %d ' % (self.first_field_index, len(self.c_fields))\n                + ('/* %s */ ' % self.comment if self.comment else '')\n                + '},')\n\n    def as_python_expr(self):\n        flags = eval(self.flags, G_FLAGS)\n        fields_expr = [c_field.as_field_python_expr()\n                       for c_field in self.c_fields]\n        return \"(b'%s%s%s',%s)\" % (\n            format_four_bytes(self.type_index),\n            format_four_bytes(flags),\n            self.name,\n            ','.join(fields_expr))\n\nclass EnumExpr:\n    def __init__(self, name, type_index, size, signed, allenums):\n        self.name = name\n        self.type_index = type_index\n        self.size = size\n        self.signed = signed\n        self.allenums = allenums\n\n    def as_c_expr(self):\n        return ('  { \"%s\", %d, _cffi_prim_int(%s, %s),\\n'\n                '    \"%s\" },' % (self.name, self.type_index,\n                                 self.size, self.signed, self.allenums))\n\n    def as_python_expr(self):\n        prim_index = {\n            (1, 0): PRIM_UINT8,  (1, 1):  PRIM_INT8,\n            (2, 0): PRIM_UINT16, (2, 1):  PRIM_INT16,\n            (4, 0): PRIM_UINT32, (4, 1):  PRIM_INT32,\n            (8, 0): PRIM_UINT64, (8, 1):  PRIM_INT64,\n            }[self.size, self.signed]\n        return \"b'%s%s%s\\\\x00%s'\" % (format_four_bytes(self.type_index),\n                                     format_four_bytes(prim_index),\n                                     self.name, self.allenums)\n\nclass TypenameExpr:\n    def __init__(self, name, type_index):\n        self.name = name\n        self.type_index = type_index\n\n    def as_c_expr(self):\n        return '  { \"%s\", %d },' % (self.name, self.type_index)\n\n    def as_python_expr(self):\n        return \"b'%s%s'\" % (format_four_bytes(self.type_index), self.name)\n\n\n# ____________________________________________________________\n\n\nclass Recompiler:\n    _num_externpy = 0\n\n    def __init__(self, ffi, module_name, target_is_python=False):\n        self.ffi = ffi\n        self.module_name = module_name\n        self.target_is_python = target_is_python\n        self._version = VERSION_BASE\n\n    def needs_version(self, ver):\n        self._version = max(self._version, ver)\n\n    def collect_type_table(self):\n        self._typesdict = {}\n        self._generate(\"collecttype\")\n        #\n        all_decls = sorted(self._typesdict, key=str)\n        #\n        # prepare all FUNCTION bytecode sequences first\n        self.cffi_types = []\n        for tp in all_decls:\n            if tp.is_raw_function:\n                assert self._typesdict[tp] is None\n                self._typesdict[tp] = len(self.cffi_types)\n                self.cffi_types.append(tp)     # placeholder\n                for tp1 in tp.args:\n                    assert isinstance(tp1, (model.VoidType,\n                                            model.BasePrimitiveType,\n                                            model.PointerType,\n                                            model.StructOrUnionOrEnum,\n                                            model.FunctionPtrType))\n                    if self._typesdict[tp1] is None:\n                        self._typesdict[tp1] = len(self.cffi_types)\n                    self.cffi_types.append(tp1)   # placeholder\n                self.cffi_types.append('END')     # placeholder\n        #\n        # prepare all OTHER bytecode sequences\n        for tp in all_decls:\n            if not tp.is_raw_function and self._typesdict[tp] is None:\n                self._typesdict[tp] = len(self.cffi_types)\n                self.cffi_types.append(tp)        # placeholder\n                if tp.is_array_type and tp.length is not None:\n                    self.cffi_types.append('LEN') # placeholder\n        assert None not in self._typesdict.values()\n        #\n        # collect all structs and unions and enums\n        self._struct_unions = {}\n        self._enums = {}\n        for tp in all_decls:\n            if isinstance(tp, model.StructOrUnion):\n                self._struct_unions[tp] = None\n            elif isinstance(tp, model.EnumType):\n                self._enums[tp] = None\n        for i, tp in enumerate(sorted(self._struct_unions,\n                                      key=lambda tp: tp.name)):\n            self._struct_unions[tp] = i\n        for i, tp in enumerate(sorted(self._enums,\n                                      key=lambda tp: tp.name)):\n            self._enums[tp] = i\n        #\n        # emit all bytecode sequences now\n        for tp in all_decls:\n            method = getattr(self, '_emit_bytecode_' + tp.__class__.__name__)\n            method(tp, self._typesdict[tp])\n        #\n        # consistency check\n        for op in self.cffi_types:\n            assert isinstance(op, CffiOp)\n        self.cffi_types = tuple(self.cffi_types)    # don't change any more\n\n    def _enum_fields(self, tp):\n        # When producing C, expand all anonymous struct/union fields.\n        # That's necessary to have C code checking the offsets of the\n        # individual fields contained in them.  When producing Python,\n        # don't do it and instead write it like it is, with the\n        # corresponding fields having an empty name.  Empty names are\n        # recognized at runtime when we import the generated Python\n        # file.\n        expand_anonymous_struct_union = not self.target_is_python\n        return tp.enumfields(expand_anonymous_struct_union)\n\n    def _do_collect_type(self, tp):\n        if not isinstance(tp, model.BaseTypeByIdentity):\n            if isinstance(tp, tuple):\n                for x in tp:\n                    self._do_collect_type(x)\n            return\n        if tp not in self._typesdict:\n            self._typesdict[tp] = None\n            if isinstance(tp, model.FunctionPtrType):\n                self._do_collect_type(tp.as_raw_function())\n            elif isinstance(tp, model.StructOrUnion):\n                if tp.fldtypes is not None and (\n                        tp not in self.ffi._parser._included_declarations):\n                    for name1, tp1, _, _ in self._enum_fields(tp):\n                        self._do_collect_type(self._field_type(tp, name1, tp1))\n            else:\n                for _, x in tp._get_items():\n                    self._do_collect_type(x)\n\n    def _generate(self, step_name):\n        lst = self.ffi._parser._declarations.items()\n        for name, (tp, quals) in sorted(lst):\n            kind, realname = name.split(' ', 1)\n            try:\n                method = getattr(self, '_generate_cpy_%s_%s' % (kind,\n                                                                step_name))\n            except AttributeError:\n                raise VerificationError(\n                    \"not implemented in recompile(): %r\" % name)\n            try:\n                self._current_quals = quals\n                method(tp, realname)\n            except Exception as e:\n                model.attach_exception_info(e, name)\n                raise\n\n    # ----------\n\n    ALL_STEPS = [\"global\", \"field\", \"struct_union\", \"enum\", \"typename\"]\n\n    def collect_step_tables(self):\n        # collect the declarations for '_cffi_globals', '_cffi_typenames', etc.\n        self._lsts = {}\n        for step_name in self.ALL_STEPS:\n            self._lsts[step_name] = []\n        self._seen_struct_unions = set()\n        self._generate(\"ctx\")\n        self._add_missing_struct_unions()\n        #\n        for step_name in self.ALL_STEPS:\n            lst = self._lsts[step_name]\n            if step_name != \"field\":\n                lst.sort(key=lambda entry: entry.name)\n            self._lsts[step_name] = tuple(lst)    # don't change any more\n        #\n        # check for a possible internal inconsistency: _cffi_struct_unions\n        # should have been generated with exactly self._struct_unions\n        lst = self._lsts[\"struct_union\"]\n        for tp, i in self._struct_unions.items():\n            assert i < len(lst)\n            assert lst[i].name == tp.name\n        assert len(lst) == len(self._struct_unions)\n        # same with enums\n        lst = self._lsts[\"enum\"]\n        for tp, i in self._enums.items():\n            assert i < len(lst)\n            assert lst[i].name == tp.name\n        assert len(lst) == len(self._enums)\n\n    # ----------\n\n    def _prnt(self, what=''):\n        self._f.write(what + '\\n')\n\n    def write_source_to_f(self, f, preamble):\n        if self.target_is_python:\n            assert preamble is None\n            self.write_py_source_to_f(f)\n        else:\n            assert preamble is not None\n            self.write_c_source_to_f(f, preamble)\n\n    def _rel_readlines(self, filename):\n        g = open(os.path.join(os.path.dirname(__file__), filename), 'r')\n        lines = g.readlines()\n        g.close()\n        return lines\n\n    def write_c_source_to_f(self, f, preamble):\n        self._f = f\n        prnt = self._prnt\n        if self.ffi._embedding is not None:\n            prnt('#define _CFFI_USE_EMBEDDING')\n        if not USE_LIMITED_API:\n            prnt('#define _CFFI_NO_LIMITED_API')\n        #\n        # first the '#include' (actually done by inlining the file's content)\n        lines = self._rel_readlines('_cffi_include.h')\n        i = lines.index('#include \"parse_c_type.h\"\\n')\n        lines[i:i+1] = self._rel_readlines('parse_c_type.h')\n        prnt(''.join(lines))\n        #\n        # if we have ffi._embedding != None, we give it here as a macro\n        # and include an extra file\n        base_module_name = self.module_name.split('.')[-1]\n        if self.ffi._embedding is not None:\n            prnt('#define _CFFI_MODULE_NAME  \"%s\"' % (self.module_name,))\n            prnt('static const char _CFFI_PYTHON_STARTUP_CODE[] = {')\n            self._print_string_literal_in_array(self.ffi._embedding)\n            prnt('0 };')\n            prnt('#ifdef PYPY_VERSION')\n            prnt('# define _CFFI_PYTHON_STARTUP_FUNC  _cffi_pypyinit_%s' % (\n                base_module_name,))\n            prnt('#elif PY_MAJOR_VERSION >= 3')\n            prnt('# define _CFFI_PYTHON_STARTUP_FUNC  PyInit_%s' % (\n                base_module_name,))\n            prnt('#else')\n            prnt('# define _CFFI_PYTHON_STARTUP_FUNC  init%s' % (\n                base_module_name,))\n            prnt('#endif')\n            lines = self._rel_readlines('_embedding.h')\n            i = lines.index('#include \"_cffi_errors.h\"\\n')\n            lines[i:i+1] = self._rel_readlines('_cffi_errors.h')\n            prnt(''.join(lines))\n            self.needs_version(VERSION_EMBEDDED)\n        #\n        # then paste the C source given by the user, verbatim.\n        prnt('/************************************************************/')\n        prnt()\n        prnt(preamble)\n        prnt()\n        prnt('/************************************************************/')\n        prnt()\n        #\n        # the declaration of '_cffi_types'\n        prnt('static void *_cffi_types[] = {')\n        typeindex2type = dict([(i, tp) for (tp, i) in self._typesdict.items()])\n        for i, op in enumerate(self.cffi_types):\n            comment = ''\n            if i in typeindex2type:\n                comment = ' // ' + typeindex2type[i]._get_c_name()\n            prnt('/* %2d */ %s,%s' % (i, op.as_c_expr(), comment))\n        if not self.cffi_types:\n            prnt('  0')\n        prnt('};')\n        prnt()\n        #\n        # call generate_cpy_xxx_decl(), for every xxx found from\n        # ffi._parser._declarations.  This generates all the functions.\n        self._seen_constants = set()\n        self._generate(\"decl\")\n        #\n        # the declaration of '_cffi_globals' and '_cffi_typenames'\n        nums = {}\n        for step_name in self.ALL_STEPS:\n            lst = self._lsts[step_name]\n            nums[step_name] = len(lst)\n            if nums[step_name] > 0:\n                prnt('static const struct _cffi_%s_s _cffi_%ss[] = {' % (\n                    step_name, step_name))\n                for entry in lst:\n                    prnt(entry.as_c_expr())\n                prnt('};')\n                prnt()\n        #\n        # the declaration of '_cffi_includes'\n        if self.ffi._included_ffis:\n            prnt('static const char * const _cffi_includes[] = {')\n            for ffi_to_include in self.ffi._included_ffis:\n                try:\n                    included_module_name, included_source = (\n                        ffi_to_include._assigned_source[:2])\n                except AttributeError:\n                    raise VerificationError(\n                        \"ffi object %r includes %r, but the latter has not \"\n                        \"been prepared with set_source()\" % (\n                            self.ffi, ffi_to_include,))\n                if included_source is None:\n                    raise VerificationError(\n                        \"not implemented yet: ffi.include() of a Python-based \"\n                        \"ffi inside a C-based ffi\")\n                prnt('  \"%s\",' % (included_module_name,))\n            prnt('  NULL')\n            prnt('};')\n            prnt()\n        #\n        # the declaration of '_cffi_type_context'\n        prnt('static const struct _cffi_type_context_s _cffi_type_context = {')\n        prnt('  _cffi_types,')\n        for step_name in self.ALL_STEPS:\n            if nums[step_name] > 0:\n                prnt('  _cffi_%ss,' % step_name)\n            else:\n                prnt('  NULL,  /* no %ss */' % step_name)\n        for step_name in self.ALL_STEPS:\n            if step_name != \"field\":\n                prnt('  %d,  /* num_%ss */' % (nums[step_name], step_name))\n        if self.ffi._included_ffis:\n            prnt('  _cffi_includes,')\n        else:\n            prnt('  NULL,  /* no includes */')\n        prnt('  %d,  /* num_types */' % (len(self.cffi_types),))\n        flags = 0\n        if self._num_externpy > 0 or self.ffi._embedding is not None:\n            flags |= 1     # set to mean that we use extern \"Python\"\n        prnt('  %d,  /* flags */' % flags)\n        prnt('};')\n        prnt()\n        #\n        # the init function\n        prnt('#ifdef __GNUC__')\n        prnt('#  pragma GCC visibility push(default)  /* for -fvisibility= */')\n        prnt('#endif')\n        prnt()\n        prnt('#ifdef PYPY_VERSION')\n        prnt('PyMODINIT_FUNC')\n        prnt('_cffi_pypyinit_%s(const void *p[])' % (base_module_name,))\n        prnt('{')\n        if flags & 1:\n            prnt('    if (((intptr_t)p[0]) >= 0x0A03) {')\n            prnt('        _cffi_call_python_org = '\n                 '(void(*)(struct _cffi_externpy_s *, char *))p[1];')\n            prnt('    }')\n        prnt('    p[0] = (const void *)0x%x;' % self._version)\n        prnt('    p[1] = &_cffi_type_context;')\n        prnt('#if PY_MAJOR_VERSION >= 3')\n        prnt('    return NULL;')\n        prnt('#endif')\n        prnt('}')\n        # on Windows, distutils insists on putting init_cffi_xyz in\n        # 'export_symbols', so instead of fighting it, just give up and\n        # give it one\n        prnt('#  ifdef _MSC_VER')\n        prnt('     PyMODINIT_FUNC')\n        prnt('#  if PY_MAJOR_VERSION >= 3')\n        prnt('     PyInit_%s(void) { return NULL; }' % (base_module_name,))\n        prnt('#  else')\n        prnt('     init%s(void) { }' % (base_module_name,))\n        prnt('#  endif')\n        prnt('#  endif')\n        prnt('#elif PY_MAJOR_VERSION >= 3')\n        prnt('PyMODINIT_FUNC')\n        prnt('PyInit_%s(void)' % (base_module_name,))\n        prnt('{')\n        prnt('  return _cffi_init(\"%s\", 0x%x, &_cffi_type_context);' % (\n            self.module_name, self._version))\n        prnt('}')\n        prnt('#else')\n        prnt('PyMODINIT_FUNC')\n        prnt('init%s(void)' % (base_module_name,))\n        prnt('{')\n        prnt('  _cffi_init(\"%s\", 0x%x, &_cffi_type_context);' % (\n            self.module_name, self._version))\n        prnt('}')\n        prnt('#endif')\n        prnt()\n        prnt('#ifdef __GNUC__')\n        prnt('#  pragma GCC visibility pop')\n        prnt('#endif')\n        self._version = None\n\n    def _to_py(self, x):\n        if isinstance(x, str):\n            return \"b'%s'\" % (x,)\n        if isinstance(x, (list, tuple)):\n            rep = [self._to_py(item) for item in x]\n            if len(rep) == 1:\n                rep.append('')\n            return \"(%s)\" % (','.join(rep),)\n        return x.as_python_expr()  # Py2: unicode unexpected; Py3: bytes unexp.\n\n    def write_py_source_to_f(self, f):\n        self._f = f\n        prnt = self._prnt\n        #\n        # header\n        prnt(\"# auto-generated file\")\n        prnt(\"import _cffi_backend\")\n        #\n        # the 'import' of the included ffis\n        num_includes = len(self.ffi._included_ffis or ())\n        for i in range(num_includes):\n            ffi_to_include = self.ffi._included_ffis[i]\n            try:\n                included_module_name, included_source = (\n                    ffi_to_include._assigned_source[:2])\n            except AttributeError:\n                raise VerificationError(\n                    \"ffi object %r includes %r, but the latter has not \"\n                    \"been prepared with set_source()\" % (\n                        self.ffi, ffi_to_include,))\n            if included_source is not None:\n                raise VerificationError(\n                    \"not implemented yet: ffi.include() of a C-based \"\n                    \"ffi inside a Python-based ffi\")\n            prnt('from %s import ffi as _ffi%d' % (included_module_name, i))\n        prnt()\n        prnt(\"ffi = _cffi_backend.FFI('%s',\" % (self.module_name,))\n        prnt(\"    _version = 0x%x,\" % (self._version,))\n        self._version = None\n        #\n        # the '_types' keyword argument\n        self.cffi_types = tuple(self.cffi_types)    # don't change any more\n        types_lst = [op.as_python_bytes() for op in self.cffi_types]\n        prnt('    _types = %s,' % (self._to_py(''.join(types_lst)),))\n        typeindex2type = dict([(i, tp) for (tp, i) in self._typesdict.items()])\n        #\n        # the keyword arguments from ALL_STEPS\n        for step_name in self.ALL_STEPS:\n            lst = self._lsts[step_name]\n            if len(lst) > 0 and step_name != \"field\":\n                prnt('    _%ss = %s,' % (step_name, self._to_py(lst)))\n        #\n        # the '_includes' keyword argument\n        if num_includes > 0:\n            prnt('    _includes = (%s,),' % (\n                ', '.join(['_ffi%d' % i for i in range(num_includes)]),))\n        #\n        # the footer\n        prnt(')')\n\n    # ----------\n\n    def _gettypenum(self, type):\n        # a KeyError here is a bug.  please report it! :-)\n        return self._typesdict[type]\n\n    def _convert_funcarg_to_c(self, tp, fromvar, tovar, errcode):\n        extraarg = ''\n        if isinstance(tp, model.BasePrimitiveType) and not tp.is_complex_type():\n            if tp.is_integer_type() and tp.name != '_Bool':\n                converter = '_cffi_to_c_int'\n                extraarg = ', %s' % tp.name\n            elif isinstance(tp, model.UnknownFloatType):\n                # don't check with is_float_type(): it may be a 'long\n                # double' here, and _cffi_to_c_double would loose precision\n                converter = '(%s)_cffi_to_c_double' % (tp.get_c_name(''),)\n            else:\n                cname = tp.get_c_name('')\n                converter = '(%s)_cffi_to_c_%s' % (cname,\n                                                   tp.name.replace(' ', '_'))\n                if cname in ('char16_t', 'char32_t'):\n                    self.needs_version(VERSION_CHAR16CHAR32)\n            errvalue = '-1'\n        #\n        elif isinstance(tp, model.PointerType):\n            self._convert_funcarg_to_c_ptr_or_array(tp, fromvar,\n                                                    tovar, errcode)\n            return\n        #\n        elif (isinstance(tp, model.StructOrUnionOrEnum) or\n              isinstance(tp, model.BasePrimitiveType)):\n            # a struct (not a struct pointer) as a function argument;\n            # or, a complex (the same code works)\n            self._prnt('  if (_cffi_to_c((char *)&%s, _cffi_type(%d), %s) < 0)'\n                      % (tovar, self._gettypenum(tp), fromvar))\n            self._prnt('    %s;' % errcode)\n            return\n        #\n        elif isinstance(tp, model.FunctionPtrType):\n            converter = '(%s)_cffi_to_c_pointer' % tp.get_c_name('')\n            extraarg = ', _cffi_type(%d)' % self._gettypenum(tp)\n            errvalue = 'NULL'\n        #\n        else:\n            raise NotImplementedError(tp)\n        #\n        self._prnt('  %s = %s(%s%s);' % (tovar, converter, fromvar, extraarg))\n        self._prnt('  if (%s == (%s)%s && PyErr_Occurred())' % (\n            tovar, tp.get_c_name(''), errvalue))\n        self._prnt('    %s;' % errcode)\n\n    def _extra_local_variables(self, tp, localvars, freelines):\n        if isinstance(tp, model.PointerType):\n            localvars.add('Py_ssize_t datasize')\n            localvars.add('struct _cffi_freeme_s *large_args_free = NULL')\n            freelines.add('if (large_args_free != NULL)'\n                          ' _cffi_free_array_arguments(large_args_free);')\n\n    def _convert_funcarg_to_c_ptr_or_array(self, tp, fromvar, tovar, errcode):\n        self._prnt('  datasize = _cffi_prepare_pointer_call_argument(')\n        self._prnt('      _cffi_type(%d), %s, (char **)&%s);' % (\n            self._gettypenum(tp), fromvar, tovar))\n        self._prnt('  if (datasize != 0) {')\n        self._prnt('    %s = ((size_t)datasize) <= 640 ? '\n                   '(%s)alloca((size_t)datasize) : NULL;' % (\n            tovar, tp.get_c_name('')))\n        self._prnt('    if (_cffi_convert_array_argument(_cffi_type(%d), %s, '\n                   '(char **)&%s,' % (self._gettypenum(tp), fromvar, tovar))\n        self._prnt('            datasize, &large_args_free) < 0)')\n        self._prnt('      %s;' % errcode)\n        self._prnt('  }')\n\n    def _convert_expr_from_c(self, tp, var, context):\n        if isinstance(tp, model.BasePrimitiveType):\n            if tp.is_integer_type() and tp.name != '_Bool':\n                return '_cffi_from_c_int(%s, %s)' % (var, tp.name)\n            elif isinstance(tp, model.UnknownFloatType):\n                return '_cffi_from_c_double(%s)' % (var,)\n            elif tp.name != 'long double' and not tp.is_complex_type():\n                cname = tp.name.replace(' ', '_')\n                if cname in ('char16_t', 'char32_t'):\n                    self.needs_version(VERSION_CHAR16CHAR32)\n                return '_cffi_from_c_%s(%s)' % (cname, var)\n            else:\n                return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                    var, self._gettypenum(tp))\n        elif isinstance(tp, (model.PointerType, model.FunctionPtrType)):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.ArrayType):\n            return '_cffi_from_c_pointer((char *)%s, _cffi_type(%d))' % (\n                var, self._gettypenum(model.PointerType(tp.item)))\n        elif isinstance(tp, model.StructOrUnion):\n            if tp.fldnames is None:\n                raise TypeError(\"'%s' is used as %s, but is opaque\" % (\n                    tp._get_c_name(), context))\n            return '_cffi_from_c_struct((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        elif isinstance(tp, model.EnumType):\n            return '_cffi_from_c_deref((char *)&%s, _cffi_type(%d))' % (\n                var, self._gettypenum(tp))\n        else:\n            raise NotImplementedError(tp)\n\n    # ----------\n    # typedefs\n\n    def _typedef_type(self, tp, name):\n        return self._global_type(tp, \"(*(%s *)0)\" % (name,))\n\n    def _generate_cpy_typedef_collecttype(self, tp, name):\n        self._do_collect_type(self._typedef_type(tp, name))\n\n    def _generate_cpy_typedef_decl(self, tp, name):\n        pass\n\n    def _typedef_ctx(self, tp, name):\n        type_index = self._typesdict[tp]\n        self._lsts[\"typename\"].append(TypenameExpr(name, type_index))\n\n    def _generate_cpy_typedef_ctx(self, tp, name):\n        tp = self._typedef_type(tp, name)\n        self._typedef_ctx(tp, name)\n        if getattr(tp, \"origin\", None) == \"unknown_type\":\n            self._struct_ctx(tp, tp.name, approxname=None)\n        elif isinstance(tp, model.NamedPointerType):\n            self._struct_ctx(tp.totype, tp.totype.name, approxname=tp.name,\n                             named_ptr=tp)\n\n    # ----------\n    # function declarations\n\n    def _generate_cpy_function_collecttype(self, tp, name):\n        self._do_collect_type(tp.as_raw_function())\n        if tp.ellipsis and not self.target_is_python:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_function_decl(self, tp, name):\n        assert not self.target_is_python\n        assert isinstance(tp, model.FunctionPtrType)\n        if tp.ellipsis:\n            # cannot support vararg functions better than this: check for its\n            # exact type (including the fixed arguments), and build it as a\n            # constant function pointer (no CPython wrapper)\n            self._generate_cpy_constant_decl(tp, name)\n            return\n        prnt = self._prnt\n        numargs = len(tp.args)\n        if numargs == 0:\n            argname = 'noarg'\n        elif numargs == 1:\n            argname = 'arg0'\n        else:\n            argname = 'args'\n        #\n        # ------------------------------\n        # the 'd' version of the function, only for addressof(lib, 'func')\n        arguments = []\n        call_arguments = []\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            arguments.append(type.get_c_name(' x%d' % i, context))\n            call_arguments.append('x%d' % i)\n        repr_arguments = ', '.join(arguments)\n        repr_arguments = repr_arguments or 'void'\n        if tp.abi:\n            abi = tp.abi + ' '\n        else:\n            abi = ''\n        name_and_arguments = '%s_cffi_d_%s(%s)' % (abi, name, repr_arguments)\n        prnt('static %s' % (tp.result.get_c_name(name_and_arguments),))\n        prnt('{')\n        call_arguments = ', '.join(call_arguments)\n        result_code = 'return '\n        if isinstance(tp.result, model.VoidType):\n            result_code = ''\n        prnt('  %s%s(%s);' % (result_code, name, call_arguments))\n        prnt('}')\n        #\n        prnt('#ifndef PYPY_VERSION')        # ------------------------------\n        #\n        prnt('static PyObject *')\n        prnt('_cffi_f_%s(PyObject *self, PyObject *%s)' % (name, argname))\n        prnt('{')\n        #\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            arg = type.get_c_name(' x%d' % i, context)\n            prnt('  %s;' % arg)\n        #\n        localvars = set()\n        freelines = set()\n        for type in tp.args:\n            self._extra_local_variables(type, localvars, freelines)\n        for decl in sorted(localvars):\n            prnt('  %s;' % (decl,))\n        #\n        if not isinstance(tp.result, model.VoidType):\n            result_code = 'result = '\n            context = 'result of %s' % name\n            result_decl = '  %s;' % tp.result.get_c_name(' result', context)\n            prnt(result_decl)\n            prnt('  PyObject *pyresult;')\n        else:\n            result_decl = None\n            result_code = ''\n        #\n        if len(tp.args) > 1:\n            rng = range(len(tp.args))\n            for i in rng:\n                prnt('  PyObject *arg%d;' % i)\n            prnt()\n            prnt('  if (!PyArg_UnpackTuple(args, \"%s\", %d, %d, %s))' % (\n                name, len(rng), len(rng),\n                ', '.join(['&arg%d' % i for i in rng])))\n            prnt('    return NULL;')\n        prnt()\n        #\n        for i, type in enumerate(tp.args):\n            self._convert_funcarg_to_c(type, 'arg%d' % i, 'x%d' % i,\n                                       'return NULL')\n            prnt()\n        #\n        prnt('  Py_BEGIN_ALLOW_THREADS')\n        prnt('  _cffi_restore_errno();')\n        call_arguments = ['x%d' % i for i in range(len(tp.args))]\n        call_arguments = ', '.join(call_arguments)\n        prnt('  { %s%s(%s); }' % (result_code, name, call_arguments))\n        prnt('  _cffi_save_errno();')\n        prnt('  Py_END_ALLOW_THREADS')\n        prnt()\n        #\n        prnt('  (void)self; /* unused */')\n        if numargs == 0:\n            prnt('  (void)noarg; /* unused */')\n        if result_code:\n            prnt('  pyresult = %s;' %\n                 self._convert_expr_from_c(tp.result, 'result', 'result type'))\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  return pyresult;')\n        else:\n            for freeline in freelines:\n                prnt('  ' + freeline)\n            prnt('  Py_INCREF(Py_None);')\n            prnt('  return Py_None;')\n        prnt('}')\n        #\n        prnt('#else')        # ------------------------------\n        #\n        # the PyPy version: need to replace struct/union arguments with\n        # pointers, and if the result is a struct/union, insert a first\n        # arg that is a pointer to the result.  We also do that for\n        # complex args and return type.\n        def need_indirection(type):\n            return (isinstance(type, model.StructOrUnion) or\n                    (isinstance(type, model.PrimitiveType) and\n                     type.is_complex_type()))\n        difference = False\n        arguments = []\n        call_arguments = []\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            indirection = ''\n            if need_indirection(type):\n                indirection = '*'\n                difference = True\n            arg = type.get_c_name(' %sx%d' % (indirection, i), context)\n            arguments.append(arg)\n            call_arguments.append('%sx%d' % (indirection, i))\n        tp_result = tp.result\n        if need_indirection(tp_result):\n            context = 'result of %s' % name\n            arg = tp_result.get_c_name(' *result', context)\n            arguments.insert(0, arg)\n            tp_result = model.void_type\n            result_decl = None\n            result_code = '*result = '\n            difference = True\n        if difference:\n            repr_arguments = ', '.join(arguments)\n            repr_arguments = repr_arguments or 'void'\n            name_and_arguments = '%s_cffi_f_%s(%s)' % (abi, name,\n                                                       repr_arguments)\n            prnt('static %s' % (tp_result.get_c_name(name_and_arguments),))\n            prnt('{')\n            if result_decl:\n                prnt(result_decl)\n            call_arguments = ', '.join(call_arguments)\n            prnt('  { %s%s(%s); }' % (result_code, name, call_arguments))\n            if result_decl:\n                prnt('  return result;')\n            prnt('}')\n        else:\n            prnt('#  define _cffi_f_%s _cffi_d_%s' % (name, name))\n        #\n        prnt('#endif')        # ------------------------------\n        prnt()\n\n    def _generate_cpy_function_ctx(self, tp, name):\n        if tp.ellipsis and not self.target_is_python:\n            self._generate_cpy_constant_ctx(tp, name)\n            return\n        type_index = self._typesdict[tp.as_raw_function()]\n        numargs = len(tp.args)\n        if self.target_is_python:\n            meth_kind = OP_DLOPEN_FUNC\n        elif numargs == 0:\n            meth_kind = OP_CPYTHON_BLTN_N   # 'METH_NOARGS'\n        elif numargs == 1:\n            meth_kind = OP_CPYTHON_BLTN_O   # 'METH_O'\n        else:\n            meth_kind = OP_CPYTHON_BLTN_V   # 'METH_VARARGS'\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_f_%s' % name,\n                       CffiOp(meth_kind, type_index),\n                       size='_cffi_d_%s' % name))\n\n    # ----------\n    # named structs or unions\n\n    def _field_type(self, tp_struct, field_name, tp_field):\n        if isinstance(tp_field, model.ArrayType):\n            actual_length = tp_field.length\n            if actual_length == '...':\n                ptr_struct_name = tp_struct.get_c_name('*')\n                actual_length = '_cffi_array_len(((%s)0)->%s)' % (\n                    ptr_struct_name, field_name)\n            tp_item = self._field_type(tp_struct, '%s[0]' % field_name,\n                                       tp_field.item)\n            tp_field = model.ArrayType(tp_item, actual_length)\n        return tp_field\n\n    def _struct_collecttype(self, tp):\n        self._do_collect_type(tp)\n        if self.target_is_python:\n            # also requires nested anon struct/unions in ABI mode, recursively\n            for fldtype in tp.anonymous_struct_fields():\n                self._struct_collecttype(fldtype)\n\n    def _struct_decl(self, tp, cname, approxname):\n        if tp.fldtypes is None:\n            return\n        prnt = self._prnt\n        checkfuncname = '_cffi_checkfld_%s' % (approxname,)\n        prnt('_CFFI_UNUSED_FN')\n        prnt('static void %s(%s *p)' % (checkfuncname, cname))\n        prnt('{')\n        prnt('  /* only to generate compile-time warnings or errors */')\n        prnt('  (void)p;')\n        for fname, ftype, fbitsize, fqual in self._enum_fields(tp):\n            try:\n                if ftype.is_integer_type() or fbitsize >= 0:\n                    # accept all integers, but complain on float or double\n                    if fname != '':\n                        prnt(\"  (void)((p->%s) | 0);  /* check that '%s.%s' is \"\n                             \"an integer */\" % (fname, cname, fname))\n                    continue\n                # only accept exactly the type declared, except that '[]'\n                # is interpreted as a '*' and so will match any array length.\n                # (It would also match '*', but that's harder to detect...)\n                while (isinstance(ftype, model.ArrayType)\n                       and (ftype.length is None or ftype.length == '...')):\n                    ftype = ftype.item\n                    fname = fname + '[0]'\n                prnt('  { %s = &p->%s; (void)tmp; }' % (\n                    ftype.get_c_name('*tmp', 'field %r'%fname, quals=fqual),\n                    fname))\n            except VerificationError as e:\n                prnt('  /* %s */' % str(e))   # cannot verify it, ignore\n        prnt('}')\n        prnt('struct _cffi_align_%s { char x; %s y; };' % (approxname, cname))\n        prnt()\n\n    def _struct_ctx(self, tp, cname, approxname, named_ptr=None):\n        type_index = self._typesdict[tp]\n        reason_for_not_expanding = None\n        flags = []\n        if isinstance(tp, model.UnionType):\n            flags.append(\"_CFFI_F_UNION\")\n        if tp.fldtypes is None:\n            flags.append(\"_CFFI_F_OPAQUE\")\n            reason_for_not_expanding = \"opaque\"\n        if (tp not in self.ffi._parser._included_declarations and\n                (named_ptr is None or\n                 named_ptr not in self.ffi._parser._included_declarations)):\n            if tp.fldtypes is None:\n                pass    # opaque\n            elif tp.partial or any(tp.anonymous_struct_fields()):\n                pass    # field layout obtained silently from the C compiler\n            else:\n                flags.append(\"_CFFI_F_CHECK_FIELDS\")\n            if tp.packed:\n                if tp.packed > 1:\n                    raise NotImplementedError(\n                        \"%r is declared with 'pack=%r'; only 0 or 1 are \"\n                        \"supported in API mode (try to use \\\"...;\\\", which \"\n                        \"does not require a 'pack' declaration)\" %\n                        (tp, tp.packed))\n                flags.append(\"_CFFI_F_PACKED\")\n        else:\n            flags.append(\"_CFFI_F_EXTERNAL\")\n            reason_for_not_expanding = \"external\"\n        flags = '|'.join(flags) or '0'\n        c_fields = []\n        if reason_for_not_expanding is None:\n            enumfields = list(self._enum_fields(tp))\n            for fldname, fldtype, fbitsize, fqual in enumfields:\n                fldtype = self._field_type(tp, fldname, fldtype)\n                self._check_not_opaque(fldtype,\n                                       \"field '%s.%s'\" % (tp.name, fldname))\n                # cname is None for _add_missing_struct_unions() only\n                op = OP_NOOP\n                if fbitsize >= 0:\n                    op = OP_BITFIELD\n                    size = '%d /* bits */' % fbitsize\n                elif cname is None or (\n                        isinstance(fldtype, model.ArrayType) and\n                        fldtype.length is None):\n                    size = '(size_t)-1'\n                else:\n                    size = 'sizeof(((%s)0)->%s)' % (\n                        tp.get_c_name('*') if named_ptr is None\n                                           else named_ptr.name,\n                        fldname)\n                if cname is None or fbitsize >= 0:\n                    offset = '(size_t)-1'\n                elif named_ptr is not None:\n                    offset = '((char *)&((%s)4096)->%s) - (char *)4096' % (\n                        named_ptr.name, fldname)\n                else:\n                    offset = 'offsetof(%s, %s)' % (tp.get_c_name(''), fldname)\n                c_fields.append(\n                    FieldExpr(fldname, offset, size, fbitsize,\n                              CffiOp(op, self._typesdict[fldtype])))\n            first_field_index = len(self._lsts[\"field\"])\n            self._lsts[\"field\"].extend(c_fields)\n            #\n            if cname is None:  # unknown name, for _add_missing_struct_unions\n                size = '(size_t)-2'\n                align = -2\n                comment = \"unnamed\"\n            else:\n                if named_ptr is not None:\n                    size = 'sizeof(*(%s)0)' % (named_ptr.name,)\n                    align = '-1 /* unknown alignment */'\n                else:\n                    size = 'sizeof(%s)' % (cname,)\n                    align = 'offsetof(struct _cffi_align_%s, y)' % (approxname,)\n                comment = None\n        else:\n            size = '(size_t)-1'\n            align = -1\n            first_field_index = -1\n            comment = reason_for_not_expanding\n        self._lsts[\"struct_union\"].append(\n            StructUnionExpr(tp.name, type_index, flags, size, align, comment,\n                            first_field_index, c_fields))\n        self._seen_struct_unions.add(tp)\n\n    def _check_not_opaque(self, tp, location):\n        while isinstance(tp, model.ArrayType):\n            tp = tp.item\n        if isinstance(tp, model.StructOrUnion) and tp.fldtypes is None:\n            raise TypeError(\n                \"%s is of an opaque type (not declared in cdef())\" % location)\n\n    def _add_missing_struct_unions(self):\n        # not very nice, but some struct declarations might be missing\n        # because they don't have any known C name.  Check that they are\n        # not partial (we can't complete or verify them!) and emit them\n        # anonymously.\n        lst = list(self._struct_unions.items())\n        lst.sort(key=lambda tp_order: tp_order[1])\n        for tp, order in lst:\n            if tp not in self._seen_struct_unions:\n                if tp.partial:\n                    raise NotImplementedError(\"internal inconsistency: %r is \"\n                                              \"partial but was not seen at \"\n                                              \"this point\" % (tp,))\n                if tp.name.startswith('$') and tp.name[1:].isdigit():\n                    approxname = tp.name[1:]\n                elif tp.name == '_IO_FILE' and tp.forcename == 'FILE':\n                    approxname = 'FILE'\n                    self._typedef_ctx(tp, 'FILE')\n                else:\n                    raise NotImplementedError(\"internal inconsistency: %r\" %\n                                              (tp,))\n                self._struct_ctx(tp, None, approxname)\n\n    def _generate_cpy_struct_collecttype(self, tp, name):\n        self._struct_collecttype(tp)\n    _generate_cpy_union_collecttype = _generate_cpy_struct_collecttype\n\n    def _struct_names(self, tp):\n        cname = tp.get_c_name('')\n        if ' ' in cname:\n            return cname, cname.replace(' ', '_')\n        else:\n            return cname, '_' + cname\n\n    def _generate_cpy_struct_decl(self, tp, name):\n        self._struct_decl(tp, *self._struct_names(tp))\n    _generate_cpy_union_decl = _generate_cpy_struct_decl\n\n    def _generate_cpy_struct_ctx(self, tp, name):\n        self._struct_ctx(tp, *self._struct_names(tp))\n    _generate_cpy_union_ctx = _generate_cpy_struct_ctx\n\n    # ----------\n    # 'anonymous' declarations.  These are produced for anonymous structs\n    # or unions; the 'name' is obtained by a typedef.\n\n    def _generate_cpy_anonymous_collecttype(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_collecttype(tp, name)\n        else:\n            self._struct_collecttype(tp)\n\n    def _generate_cpy_anonymous_decl(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._generate_cpy_enum_decl(tp)\n        else:\n            self._struct_decl(tp, name, 'typedef_' + name)\n\n    def _generate_cpy_anonymous_ctx(self, tp, name):\n        if isinstance(tp, model.EnumType):\n            self._enum_ctx(tp, name)\n        else:\n            self._struct_ctx(tp, name, 'typedef_' + name)\n\n    # ----------\n    # constants, declared with \"static const ...\"\n\n    def _generate_cpy_const(self, is_int, name, tp=None, category='const',\n                            check_value=None):\n        if (category, name) in self._seen_constants:\n            raise VerificationError(\n                \"duplicate declaration of %s '%s'\" % (category, name))\n        self._seen_constants.add((category, name))\n        #\n        prnt = self._prnt\n        funcname = '_cffi_%s_%s' % (category, name)\n        if is_int:\n            prnt('static int %s(unsigned long long *o)' % funcname)\n            prnt('{')\n            prnt('  int n = (%s) <= 0;' % (name,))\n            prnt('  *o = (unsigned long long)((%s) | 0);'\n                 '  /* check that %s is an integer */' % (name, name))\n            if check_value is not None:\n                if check_value > 0:\n                    check_value = '%dU' % (check_value,)\n                prnt('  if (!_cffi_check_int(*o, n, %s))' % (check_value,))\n                prnt('    n |= 2;')\n            prnt('  return n;')\n            prnt('}')\n        else:\n            assert check_value is None\n            prnt('static void %s(char *o)' % funcname)\n            prnt('{')\n            prnt('  *(%s)o = %s;' % (tp.get_c_name('*'), name))\n            prnt('}')\n        prnt()\n\n    def _generate_cpy_constant_collecttype(self, tp, name):\n        is_int = tp.is_integer_type()\n        if not is_int or self.target_is_python:\n            self._do_collect_type(tp)\n\n    def _generate_cpy_constant_decl(self, tp, name):\n        is_int = tp.is_integer_type()\n        self._generate_cpy_const(is_int, name, tp)\n\n    def _generate_cpy_constant_ctx(self, tp, name):\n        if not self.target_is_python and tp.is_integer_type():\n            type_op = CffiOp(OP_CONSTANT_INT, -1)\n        else:\n            if self.target_is_python:\n                const_kind = OP_DLOPEN_CONST\n            else:\n                const_kind = OP_CONSTANT\n            type_index = self._typesdict[tp]\n            type_op = CffiOp(const_kind, type_index)\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_const_%s' % name, type_op))\n\n    # ----------\n    # enums\n\n    def _generate_cpy_enum_collecttype(self, tp, name):\n        self._do_collect_type(tp)\n\n    def _generate_cpy_enum_decl(self, tp, name=None):\n        for enumerator in tp.enumerators:\n            self._generate_cpy_const(True, enumerator)\n\n    def _enum_ctx(self, tp, cname):\n        type_index = self._typesdict[tp]\n        type_op = CffiOp(OP_ENUM, -1)\n        if self.target_is_python:\n            tp.check_not_partial()\n        for enumerator, enumvalue in zip(tp.enumerators, tp.enumvalues):\n            self._lsts[\"global\"].append(\n                GlobalExpr(enumerator, '_cffi_const_%s' % enumerator, type_op,\n                           check_value=enumvalue))\n        #\n        if cname is not None and '$' not in cname and not self.target_is_python:\n            size = \"sizeof(%s)\" % cname\n            signed = \"((%s)-1) <= 0\" % cname\n        else:\n            basetp = tp.build_baseinttype(self.ffi, [])\n            size = self.ffi.sizeof(basetp)\n            signed = int(int(self.ffi.cast(basetp, -1)) < 0)\n        allenums = \",\".join(tp.enumerators)\n        self._lsts[\"enum\"].append(\n            EnumExpr(tp.name, type_index, size, signed, allenums))\n\n    def _generate_cpy_enum_ctx(self, tp, name):\n        self._enum_ctx(tp, tp._get_c_name())\n\n    # ----------\n    # macros: for now only for integers\n\n    def _generate_cpy_macro_collecttype(self, tp, name):\n        pass\n\n    def _generate_cpy_macro_decl(self, tp, name):\n        if tp == '...':\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        self._generate_cpy_const(True, name, check_value=check_value)\n\n    def _generate_cpy_macro_ctx(self, tp, name):\n        if tp == '...':\n            if self.target_is_python:\n                raise VerificationError(\n                    \"cannot use the syntax '...' in '#define %s ...' when \"\n                    \"using the ABI mode\" % (name,))\n            check_value = None\n        else:\n            check_value = tp     # an integer\n        type_op = CffiOp(OP_CONSTANT_INT, -1)\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_const_%s' % name, type_op,\n                       check_value=check_value))\n\n    # ----------\n    # global variables\n\n    def _global_type(self, tp, global_name):\n        if isinstance(tp, model.ArrayType):\n            actual_length = tp.length\n            if actual_length == '...':\n                actual_length = '_cffi_array_len(%s)' % (global_name,)\n            tp_item = self._global_type(tp.item, '%s[0]' % global_name)\n            tp = model.ArrayType(tp_item, actual_length)\n        return tp\n\n    def _generate_cpy_variable_collecttype(self, tp, name):\n        self._do_collect_type(self._global_type(tp, name))\n\n    def _generate_cpy_variable_decl(self, tp, name):\n        prnt = self._prnt\n        tp = self._global_type(tp, name)\n        if isinstance(tp, model.ArrayType) and tp.length is None:\n            tp = tp.item\n            ampersand = ''\n        else:\n            ampersand = '&'\n        # This code assumes that casts from \"tp *\" to \"void *\" is a\n        # no-op, i.e. a function that returns a \"tp *\" can be called\n        # as if it returned a \"void *\".  This should be generally true\n        # on any modern machine.  The only exception to that rule (on\n        # uncommon architectures, and as far as I can tell) might be\n        # if 'tp' were a function type, but that is not possible here.\n        # (If 'tp' is a function _pointer_ type, then casts from \"fn_t\n        # **\" to \"void *\" are again no-ops, as far as I can tell.)\n        decl = '*_cffi_var_%s(void)' % (name,)\n        prnt('static ' + tp.get_c_name(decl, quals=self._current_quals))\n        prnt('{')\n        prnt('  return %s(%s);' % (ampersand, name))\n        prnt('}')\n        prnt()\n\n    def _generate_cpy_variable_ctx(self, tp, name):\n        tp = self._global_type(tp, name)\n        type_index = self._typesdict[tp]\n        if self.target_is_python:\n            op = OP_GLOBAL_VAR\n        else:\n            op = OP_GLOBAL_VAR_F\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '_cffi_var_%s' % name, CffiOp(op, type_index)))\n\n    # ----------\n    # extern \"Python\"\n\n    def _generate_cpy_extern_python_collecttype(self, tp, name):\n        assert isinstance(tp, model.FunctionPtrType)\n        self._do_collect_type(tp)\n    _generate_cpy_dllexport_python_collecttype = \\\n      _generate_cpy_extern_python_plus_c_collecttype = \\\n      _generate_cpy_extern_python_collecttype\n\n    def _extern_python_decl(self, tp, name, tag_and_space):\n        prnt = self._prnt\n        if isinstance(tp.result, model.VoidType):\n            size_of_result = '0'\n        else:\n            context = 'result of %s' % name\n            size_of_result = '(int)sizeof(%s)' % (\n                tp.result.get_c_name('', context),)\n        prnt('static struct _cffi_externpy_s _cffi_externpy__%s =' % name)\n        prnt('  { \"%s.%s\", %s, 0, 0 };' % (\n            self.module_name, name, size_of_result))\n        prnt()\n        #\n        arguments = []\n        context = 'argument of %s' % name\n        for i, type in enumerate(tp.args):\n            arg = type.get_c_name(' a%d' % i, context)\n            arguments.append(arg)\n        #\n        repr_arguments = ', '.join(arguments)\n        repr_arguments = repr_arguments or 'void'\n        name_and_arguments = '%s(%s)' % (name, repr_arguments)\n        if tp.abi == \"__stdcall\":\n            name_and_arguments = '_cffi_stdcall ' + name_and_arguments\n        #\n        def may_need_128_bits(tp):\n            return (isinstance(tp, model.PrimitiveType) and\n                    tp.name == 'long double')\n        #\n        size_of_a = max(len(tp.args)*8, 8)\n        if may_need_128_bits(tp.result):\n            size_of_a = max(size_of_a, 16)\n        if isinstance(tp.result, model.StructOrUnion):\n            size_of_a = 'sizeof(%s) > %d ? sizeof(%s) : %d' % (\n                tp.result.get_c_name(''), size_of_a,\n                tp.result.get_c_name(''), size_of_a)\n        prnt('%s%s' % (tag_and_space, tp.result.get_c_name(name_and_arguments)))\n        prnt('{')\n        prnt('  char a[%s];' % size_of_a)\n        prnt('  char *p = a;')\n        for i, type in enumerate(tp.args):\n            arg = 'a%d' % i\n            if (isinstance(type, model.StructOrUnion) or\n                    may_need_128_bits(type)):\n                arg = '&' + arg\n                type = model.PointerType(type)\n            prnt('  *(%s)(p + %d) = %s;' % (type.get_c_name('*'), i*8, arg))\n        prnt('  _cffi_call_python(&_cffi_externpy__%s, p);' % name)\n        if not isinstance(tp.result, model.VoidType):\n            prnt('  return *(%s)p;' % (tp.result.get_c_name('*'),))\n        prnt('}')\n        prnt()\n        self._num_externpy += 1\n\n    def _generate_cpy_extern_python_decl(self, tp, name):\n        self._extern_python_decl(tp, name, 'static ')\n\n    def _generate_cpy_dllexport_python_decl(self, tp, name):\n        self._extern_python_decl(tp, name, 'CFFI_DLLEXPORT ')\n\n    def _generate_cpy_extern_python_plus_c_decl(self, tp, name):\n        self._extern_python_decl(tp, name, '')\n\n    def _generate_cpy_extern_python_ctx(self, tp, name):\n        if self.target_is_python:\n            raise VerificationError(\n                \"cannot use 'extern \\\"Python\\\"' in the ABI mode\")\n        if tp.ellipsis:\n            raise NotImplementedError(\"a vararg function is extern \\\"Python\\\"\")\n        type_index = self._typesdict[tp]\n        type_op = CffiOp(OP_EXTERN_PYTHON, type_index)\n        self._lsts[\"global\"].append(\n            GlobalExpr(name, '&_cffi_externpy__%s' % name, type_op, name))\n\n    _generate_cpy_dllexport_python_ctx = \\\n      _generate_cpy_extern_python_plus_c_ctx = \\\n      _generate_cpy_extern_python_ctx\n\n    def _print_string_literal_in_array(self, s):\n        prnt = self._prnt\n        prnt('// # NB. this is not a string because of a size limit in MSVC')\n        if not isinstance(s, bytes):    # unicode\n            s = s.encode('utf-8')       # -> bytes\n        else:\n            s.decode('utf-8')           # got bytes, check for valid utf-8\n        try:\n            s.decode('ascii')\n        except UnicodeDecodeError:\n            s = b'# -*- encoding: utf8 -*-\\n' + s\n        for line in s.splitlines(True):\n            comment = line\n            if type('//') is bytes:     # python2\n                line = map(ord, line)   #     make a list of integers\n            else:                       # python3\n                # type(line) is bytes, which enumerates like a list of integers\n                comment = ascii(comment)[1:-1]\n            prnt(('// ' + comment).rstrip())\n            printed_line = ''\n            for c in line:\n                if len(printed_line) >= 76:\n                    prnt(printed_line)\n                    printed_line = ''\n                printed_line += '%d,' % (c,)\n            prnt(printed_line)\n\n    # ----------\n    # emitting the opcodes for individual types\n\n    def _emit_bytecode_VoidType(self, tp, index):\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, PRIM_VOID)\n\n    def _emit_bytecode_PrimitiveType(self, tp, index):\n        prim_index = PRIMITIVE_TO_INDEX[tp.name]\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, prim_index)\n\n    def _emit_bytecode_UnknownIntegerType(self, tp, index):\n        s = ('_cffi_prim_int(sizeof(%s), (\\n'\n             '           ((%s)-1) | 0 /* check that %s is an integer type */\\n'\n             '         ) <= 0)' % (tp.name, tp.name, tp.name))\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, s)\n\n    def _emit_bytecode_UnknownFloatType(self, tp, index):\n        s = ('_cffi_prim_float(sizeof(%s) *\\n'\n             '           (((%s)1) / 2) * 2 /* integer => 0, float => 1 */\\n'\n             '         )' % (tp.name, tp.name))\n        self.cffi_types[index] = CffiOp(OP_PRIMITIVE, s)\n\n    def _emit_bytecode_RawFunctionType(self, tp, index):\n        self.cffi_types[index] = CffiOp(OP_FUNCTION, self._typesdict[tp.result])\n        index += 1\n        for tp1 in tp.args:\n            realindex = self._typesdict[tp1]\n            if index != realindex:\n                if isinstance(tp1, model.PrimitiveType):\n                    self._emit_bytecode_PrimitiveType(tp1, index)\n                else:\n                    self.cffi_types[index] = CffiOp(OP_NOOP, realindex)\n            index += 1\n        flags = int(tp.ellipsis)\n        if tp.abi is not None:\n            if tp.abi == '__stdcall':\n                flags |= 2\n            else:\n                raise NotImplementedError(\"abi=%r\" % (tp.abi,))\n        self.cffi_types[index] = CffiOp(OP_FUNCTION_END, flags)\n\n    def _emit_bytecode_PointerType(self, tp, index):\n        self.cffi_types[index] = CffiOp(OP_POINTER, self._typesdict[tp.totype])\n\n    _emit_bytecode_ConstPointerType = _emit_bytecode_PointerType\n    _emit_bytecode_NamedPointerType = _emit_bytecode_PointerType\n\n    def _emit_bytecode_FunctionPtrType(self, tp, index):\n        raw = tp.as_raw_function()\n        self.cffi_types[index] = CffiOp(OP_POINTER, self._typesdict[raw])\n\n    def _emit_bytecode_ArrayType(self, tp, index):\n        item_index = self._typesdict[tp.item]\n        if tp.length is None:\n            self.cffi_types[index] = CffiOp(OP_OPEN_ARRAY, item_index)\n        elif tp.length == '...':\n            raise VerificationError(\n                \"type %s badly placed: the '...' array length can only be \"\n                \"used on global arrays or on fields of structures\" % (\n                    str(tp).replace('/*...*/', '...'),))\n        else:\n            assert self.cffi_types[index + 1] == 'LEN'\n            self.cffi_types[index] = CffiOp(OP_ARRAY, item_index)\n            self.cffi_types[index + 1] = CffiOp(None, str(tp.length))\n\n    def _emit_bytecode_StructType(self, tp, index):\n        struct_index = self._struct_unions[tp]\n        self.cffi_types[index] = CffiOp(OP_STRUCT_UNION, struct_index)\n    _emit_bytecode_UnionType = _emit_bytecode_StructType\n\n    def _emit_bytecode_EnumType(self, tp, index):\n        enum_index = self._enums[tp]\n        self.cffi_types[index] = CffiOp(OP_ENUM, enum_index)\n\n\nif sys.version_info >= (3,):\n    NativeIO = io.StringIO\nelse:\n    class NativeIO(io.BytesIO):\n        def write(self, s):\n            if isinstance(s, unicode):\n                s = s.encode('ascii')\n            super(NativeIO, self).write(s)\n\ndef _make_c_or_py_source(ffi, module_name, preamble, target_file, verbose):\n    if verbose:\n        print(\"generating %s\" % (target_file,))\n    recompiler = Recompiler(ffi, module_name,\n                            target_is_python=(preamble is None))\n    recompiler.collect_type_table()\n    recompiler.collect_step_tables()\n    f = NativeIO()\n    recompiler.write_source_to_f(f, preamble)\n    output = f.getvalue()\n    try:\n        with open(target_file, 'r') as f1:\n            if f1.read(len(output) + 1) != output:\n                raise IOError\n        if verbose:\n            print(\"(already up-to-date)\")\n        return False     # already up-to-date\n    except IOError:\n        tmp_file = '%s.~%d' % (target_file, os.getpid())\n        with open(tmp_file, 'w') as f1:\n            f1.write(output)\n        try:\n            os.rename(tmp_file, target_file)\n        except OSError:\n            os.unlink(target_file)\n            os.rename(tmp_file, target_file)\n        return True\n\ndef make_c_source(ffi, module_name, preamble, target_c_file, verbose=False):\n    assert preamble is not None\n    return _make_c_or_py_source(ffi, module_name, preamble, target_c_file,\n                                verbose)\n\ndef make_py_source(ffi, module_name, target_py_file, verbose=False):\n    return _make_c_or_py_source(ffi, module_name, None, target_py_file,\n                                verbose)\n\ndef _modname_to_file(outputdir, modname, extension):\n    parts = modname.split('.')\n    try:\n        os.makedirs(os.path.join(outputdir, *parts[:-1]))\n    except OSError:\n        pass\n    parts[-1] += extension\n    return os.path.join(outputdir, *parts), parts\n\n\n# Aaargh.  Distutils is not tested at all for the purpose of compiling\n# DLLs that are not extension modules.  Here are some hacks to work\n# around that, in the _patch_for_*() functions...\n\ndef _patch_meth(patchlist, cls, name, new_meth):\n    old = getattr(cls, name)\n    patchlist.append((cls, name, old))\n    setattr(cls, name, new_meth)\n    return old\n\ndef _unpatch_meths(patchlist):\n    for cls, name, old_meth in reversed(patchlist):\n        setattr(cls, name, old_meth)\n\ndef _patch_for_embedding(patchlist):\n    if sys.platform == 'win32':\n        # we must not remove the manifest when building for embedding!\n        from cffi._shimmed_dist_utils import MSVCCompiler\n        _patch_meth(patchlist, MSVCCompiler, '_remove_visual_c_ref',\n                    lambda self, manifest_file: manifest_file)\n\n    if sys.platform == 'darwin':\n        # we must not make a '-bundle', but a '-dynamiclib' instead\n        from cffi._shimmed_dist_utils import CCompiler\n        def my_link_shared_object(self, *args, **kwds):\n            if '-bundle' in self.linker_so:\n                self.linker_so = list(self.linker_so)\n                i = self.linker_so.index('-bundle')\n                self.linker_so[i] = '-dynamiclib'\n            return old_link_shared_object(self, *args, **kwds)\n        old_link_shared_object = _patch_meth(patchlist, CCompiler,\n                                             'link_shared_object',\n                                             my_link_shared_object)\n\ndef _patch_for_target(patchlist, target):\n    from cffi._shimmed_dist_utils import build_ext\n    # if 'target' is different from '*', we need to patch some internal\n    # method to just return this 'target' value, instead of having it\n    # built from module_name\n    if target.endswith('.*'):\n        target = target[:-2]\n        if sys.platform == 'win32':\n            target += '.dll'\n        elif sys.platform == 'darwin':\n            target += '.dylib'\n        else:\n            target += '.so'\n    _patch_meth(patchlist, build_ext, 'get_ext_filename',\n                lambda self, ext_name: target)\n\n\ndef recompile(ffi, module_name, preamble, tmpdir='.', call_c_compiler=True,\n              c_file=None, source_extension='.c', extradir=None,\n              compiler_verbose=1, target=None, debug=None, **kwds):\n    if not isinstance(module_name, str):\n        module_name = module_name.encode('ascii')\n    if ffi._windows_unicode:\n        ffi._apply_windows_unicode(kwds)\n    if preamble is not None:\n        embedding = (ffi._embedding is not None)\n        if embedding:\n            ffi._apply_embedding_fix(kwds)\n        if c_file is None:\n            c_file, parts = _modname_to_file(tmpdir, module_name,\n                                             source_extension)\n            if extradir:\n                parts = [extradir] + parts\n            ext_c_file = os.path.join(*parts)\n        else:\n            ext_c_file = c_file\n        #\n        if target is None:\n            if embedding:\n                target = '%s.*' % module_name\n            else:\n                target = '*'\n        #\n        ext = ffiplatform.get_extension(ext_c_file, module_name, **kwds)\n        updated = make_c_source(ffi, module_name, preamble, c_file,\n                                verbose=compiler_verbose)\n        if call_c_compiler:\n            patchlist = []\n            cwd = os.getcwd()\n            try:\n                if embedding:\n                    _patch_for_embedding(patchlist)\n                if target != '*':\n                    _patch_for_target(patchlist, target)\n                if compiler_verbose:\n                    if tmpdir == '.':\n                        msg = 'the current directory is'\n                    else:\n                        msg = 'setting the current directory to'\n                    print('%s %r' % (msg, os.path.abspath(tmpdir)))\n                os.chdir(tmpdir)\n                outputfilename = ffiplatform.compile('.', ext,\n                                                     compiler_verbose, debug)\n            finally:\n                os.chdir(cwd)\n                _unpatch_meths(patchlist)\n            return outputfilename\n        else:\n            return ext, updated\n    else:\n        if c_file is None:\n            c_file, _ = _modname_to_file(tmpdir, module_name, '.py')\n        updated = make_py_source(ffi, module_name, c_file,\n                                 verbose=compiler_verbose)\n        if call_c_compiler:\n            return c_file\n        else:\n            return None, updated\n\n"}