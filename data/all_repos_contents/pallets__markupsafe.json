{"setup.py": "import os\nimport platform\nimport sys\n\nfrom setuptools import Extension\nfrom setuptools import setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.errors import CCompilerError\nfrom setuptools.errors import ExecError\nfrom setuptools.errors import PlatformError\n\next_modules = [Extension(\"markupsafe._speedups\", [\"src/markupsafe/_speedups.c\"])]\n\n\nclass BuildFailed(Exception):\n    pass\n\n\nclass ve_build_ext(build_ext):\n    \"\"\"This class allows C extension building to fail.\"\"\"\n\n    def run(self):\n        try:\n            super().run()\n        except PlatformError as e:\n            raise BuildFailed() from e\n\n    def build_extension(self, ext):\n        try:\n            super().build_extension(ext)\n        except (CCompilerError, ExecError, PlatformError) as e:\n            raise BuildFailed() from e\n        except ValueError as e:\n            # this can happen on Windows 64 bit, see Python issue 7511\n            if \"'path'\" in str(sys.exc_info()[1]):  # works with Python 2 and 3\n                raise BuildFailed() from e\n            raise\n\n\ndef run_setup(with_binary):\n    setup(\n        cmdclass={\"build_ext\": ve_build_ext},\n        ext_modules=ext_modules if with_binary else [],\n    )\n\n\ndef show_message(*lines):\n    print(\"=\" * 74)\n    for line in lines:\n        print(line)\n    print(\"=\" * 74)\n\n\nsupports_speedups = platform.python_implementation() not in {\n    \"PyPy\",\n    \"Jython\",\n    \"GraalVM\",\n}\n\nif os.environ.get(\"CIBUILDWHEEL\", \"0\") == \"1\" and supports_speedups:\n    run_setup(True)\nelif supports_speedups:\n    try:\n        run_setup(True)\n    except BuildFailed:\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Failure information, if any, is above.\",\n            \"Retrying the build without the C extension now.\",\n        )\n        run_setup(False)\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Plain-Python build succeeded.\",\n        )\nelse:\n    run_setup(False)\n    show_message(\n        \"WARNING: C extensions are not supported on this Python\"\n        \" platform, speedups are not enabled.\",\n        \"Plain-Python build succeeded.\",\n    )\n", "bench.py": "import subprocess\nimport sys\n\nfor name, s in (\n    (\"short escape\", '\"<strong>Hello, World!</strong>\"'),\n    (\"long escape\", '\"Hello, World!\" * 1000'),\n    (\"short plain\", '\"Hello, World!\"'),\n    (\"long plain\", '\"Hello, World!\" * 1000'),\n    (\"long suffix\", '\"<strong>Hello, World!</strong>\" + \"x\" * 100_000'),\n):\n    for mod in \"native\", \"speedups\":\n        subprocess.run(\n            [\n                sys.executable,\n                \"-m\",\n                \"pyperf\",\n                \"timeit\",\n                \"--name\",\n                f\"{name} {mod}\",\n                \"-s\",\n                (\n                    \"import markupsafe\\n\"\n                    f\"from markupsafe._{mod} import _escape_inner\\n\"\n                    \"markupsafe._escape_inner = _escape_inner\\n\"\n                    \"from markupsafe import escape\\n\"\n                    f\"s = {s}\"\n                ),\n                \"escape(s)\",\n            ]\n        )\n", "src/markupsafe/_native.py": "def _escape_inner(s: str, /) -> str:\n    return (\n        s.replace(\"&\", \"&amp;\")\n        .replace(\">\", \"&gt;\")\n        .replace(\"<\", \"&lt;\")\n        .replace(\"'\", \"&#39;\")\n        .replace('\"', \"&#34;\")\n    )\n", "src/markupsafe/__init__.py": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport string\nimport sys\nimport typing as t\n\ntry:\n    from ._speedups import _escape_inner\nexcept ImportError:\n    from ._native import _escape_inner\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    class HasHTML(te.Protocol):\n        def __html__(self, /) -> str: ...\n\n    class TPEscape(te.Protocol):\n        def __call__(self, s: t.Any, /) -> Markup: ...\n\n\ndef escape(s: t.Any, /) -> Markup:\n    \"\"\"Replace the characters ``&``, ``<``, ``>``, ``'``, and ``\"`` in\n    the string with HTML-safe sequences. Use this if you need to display\n    text that might contain such characters in HTML.\n\n    If the object has an ``__html__`` method, it is called and the\n    return value is assumed to already be safe for HTML.\n\n    :param s: An object to be converted to a string and escaped.\n    :return: A :class:`Markup` string with the escaped text.\n    \"\"\"\n    # If the object is already a plain string, skip __html__ check and string\n    # conversion. This is the most common use case.\n    if s.__class__ is str:\n        return Markup(_escape_inner(s))\n\n    if hasattr(s, \"__html__\"):\n        return Markup(s.__html__())\n\n    return Markup(_escape_inner(str(s)))\n\n\ndef escape_silent(s: t.Any | None, /) -> Markup:\n    \"\"\"Like :func:`escape` but treats ``None`` as the empty string.\n    Useful with optional values, as otherwise you get the string\n    ``'None'`` when the value is ``None``.\n\n    >>> escape(None)\n    Markup('None')\n    >>> escape_silent(None)\n    Markup('')\n    \"\"\"\n    if s is None:\n        return Markup()\n\n    return escape(s)\n\n\ndef soft_str(s: t.Any, /) -> str:\n    \"\"\"Convert an object to a string if it isn't already. This preserves\n    a :class:`Markup` string rather than converting it back to a basic\n    string, so it will still be marked as safe and won't be escaped\n    again.\n\n    >>> value = escape(\"<User 1>\")\n    >>> value\n    Markup('&lt;User 1&gt;')\n    >>> escape(str(value))\n    Markup('&amp;lt;User 1&amp;gt;')\n    >>> escape(soft_str(value))\n    Markup('&lt;User 1&gt;')\n    \"\"\"\n    if not isinstance(s, str):\n        return str(s)\n\n    return s\n\n\nclass Markup(str):\n    \"\"\"A string that is ready to be safely inserted into an HTML or XML\n    document, either because it was escaped or because it was marked\n    safe.\n\n    Passing an object to the constructor converts it to text and wraps\n    it to mark it safe without escaping. To escape the text, use the\n    :meth:`escape` class method instead.\n\n    >>> Markup(\"Hello, <em>World</em>!\")\n    Markup('Hello, <em>World</em>!')\n    >>> Markup(42)\n    Markup('42')\n    >>> Markup.escape(\"Hello, <em>World</em>!\")\n    Markup('Hello &lt;em&gt;World&lt;/em&gt;!')\n\n    This implements the ``__html__()`` interface that some frameworks\n    use. Passing an object that implements ``__html__()`` will wrap the\n    output of that method, marking it safe.\n\n    >>> class Foo:\n    ...     def __html__(self):\n    ...         return '<a href=\"/foo\">foo</a>'\n    ...\n    >>> Markup(Foo())\n    Markup('<a href=\"/foo\">foo</a>')\n\n    This is a subclass of :class:`str`. It has the same methods, but\n    escapes their arguments and returns a ``Markup`` instance.\n\n    >>> Markup(\"<em>%s</em>\") % (\"foo & bar\",)\n    Markup('<em>foo &amp; bar</em>')\n    >>> Markup(\"<em>Hello</em> \") + \"<foo>\"\n    Markup('<em>Hello</em> &lt;foo&gt;')\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(\n        cls, object: t.Any = \"\", encoding: str | None = None, errors: str = \"strict\"\n    ) -> te.Self:\n        if hasattr(object, \"__html__\"):\n            object = object.__html__()\n\n        if encoding is None:\n            return super().__new__(cls, object)\n\n        return super().__new__(cls, object, encoding, errors)\n\n    def __html__(self, /) -> te.Self:\n        return self\n\n    def __add__(self, value: str | HasHTML, /) -> te.Self:\n        if isinstance(value, str) or hasattr(value, \"__html__\"):\n            return self.__class__(super().__add__(self.escape(value)))\n\n        return NotImplemented\n\n    def __radd__(self, value: str | HasHTML, /) -> te.Self:\n        if isinstance(value, str) or hasattr(value, \"__html__\"):\n            return self.escape(value).__add__(self)\n\n        return NotImplemented\n\n    def __mul__(self, value: t.SupportsIndex, /) -> te.Self:\n        return self.__class__(super().__mul__(value))\n\n    def __rmul__(self, value: t.SupportsIndex, /) -> te.Self:\n        return self.__class__(super().__mul__(value))\n\n    def __mod__(self, value: t.Any, /) -> te.Self:\n        if isinstance(value, tuple):\n            # a tuple of arguments, each wrapped\n            value = tuple(_MarkupEscapeHelper(x, self.escape) for x in value)\n        elif hasattr(type(value), \"__getitem__\") and not isinstance(value, str):\n            # a mapping of arguments, wrapped\n            value = _MarkupEscapeHelper(value, self.escape)\n        else:\n            # a single argument, wrapped with the helper and a tuple\n            value = (_MarkupEscapeHelper(value, self.escape),)\n\n        return self.__class__(super().__mod__(value))\n\n    def __repr__(self, /) -> str:\n        return f\"{self.__class__.__name__}({super().__repr__()})\"\n\n    def join(self, iterable: cabc.Iterable[str | HasHTML], /) -> te.Self:\n        return self.__class__(super().join(map(self.escape, iterable)))\n\n    def split(  # type: ignore[override]\n        self, /, sep: str | None = None, maxsplit: t.SupportsIndex = -1\n    ) -> list[te.Self]:\n        return [self.__class__(v) for v in super().split(sep, maxsplit)]\n\n    def rsplit(  # type: ignore[override]\n        self, /, sep: str | None = None, maxsplit: t.SupportsIndex = -1\n    ) -> list[te.Self]:\n        return [self.__class__(v) for v in super().rsplit(sep, maxsplit)]\n\n    def splitlines(  # type: ignore[override]\n        self, /, keepends: bool = False\n    ) -> list[te.Self]:\n        return [self.__class__(v) for v in super().splitlines(keepends)]\n\n    def unescape(self, /) -> str:\n        \"\"\"Convert escaped markup back into a text string. This replaces\n        HTML entities with the characters they represent.\n\n        >>> Markup(\"Main &raquo; <em>About</em>\").unescape()\n        'Main \u00bb <em>About</em>'\n        \"\"\"\n        from html import unescape\n\n        return unescape(str(self))\n\n    def striptags(self, /) -> str:\n        \"\"\":meth:`unescape` the markup, remove tags, and normalize\n        whitespace to single spaces.\n\n        >>> Markup(\"Main &raquo;\\t<em>About</em>\").striptags()\n        'Main \u00bb About'\n        \"\"\"\n        value = str(self)\n\n        # Look for comments then tags separately. Otherwise, a comment that\n        # contains a tag would end early, leaving some of the comment behind.\n\n        # keep finding comment start marks\n        while (start := value.find(\"<!--\")) != -1:\n            # find a comment end mark beyond the start, otherwise stop\n            if (end := value.find(\"-->\", start)) == -1:\n                break\n\n            value = f\"{value[:start]}{value[end + 3:]}\"\n\n        # remove tags using the same method\n        while (start := value.find(\"<\")) != -1:\n            if (end := value.find(\">\", start)) == -1:\n                break\n\n            value = f\"{value[:start]}{value[end + 1:]}\"\n\n        # collapse spaces\n        value = \" \".join(value.split())\n        return self.__class__(value).unescape()\n\n    @classmethod\n    def escape(cls, s: t.Any, /) -> te.Self:\n        \"\"\"Escape a string. Calls :func:`escape` and ensures that for\n        subclasses the correct type is returned.\n        \"\"\"\n        rv = escape(s)\n\n        if rv.__class__ is not cls:\n            return cls(rv)\n\n        return rv  # type: ignore[return-value]\n\n    def __getitem__(self, key: t.SupportsIndex | slice, /) -> te.Self:\n        return self.__class__(super().__getitem__(key))\n\n    def capitalize(self, /) -> te.Self:\n        return self.__class__(super().capitalize())\n\n    def title(self, /) -> te.Self:\n        return self.__class__(super().title())\n\n    def lower(self, /) -> te.Self:\n        return self.__class__(super().lower())\n\n    def upper(self, /) -> te.Self:\n        return self.__class__(super().upper())\n\n    def replace(self, old: str, new: str, count: t.SupportsIndex = -1, /) -> te.Self:\n        return self.__class__(super().replace(old, self.escape(new), count))\n\n    def ljust(self, width: t.SupportsIndex, fillchar: str = \" \", /) -> te.Self:\n        return self.__class__(super().ljust(width, self.escape(fillchar)))\n\n    def rjust(self, width: t.SupportsIndex, fillchar: str = \" \", /) -> te.Self:\n        return self.__class__(super().rjust(width, self.escape(fillchar)))\n\n    def lstrip(self, chars: str | None = None, /) -> te.Self:\n        return self.__class__(super().lstrip(chars))\n\n    def rstrip(self, chars: str | None = None, /) -> te.Self:\n        return self.__class__(super().rstrip(chars))\n\n    def center(self, width: t.SupportsIndex, fillchar: str = \" \", /) -> te.Self:\n        return self.__class__(super().center(width, self.escape(fillchar)))\n\n    def strip(self, chars: str | None = None, /) -> te.Self:\n        return self.__class__(super().strip(chars))\n\n    def translate(\n        self,\n        table: cabc.Mapping[int, str | int | None],  # type: ignore[override]\n        /,\n    ) -> str:\n        return self.__class__(super().translate(table))\n\n    def expandtabs(self, /, tabsize: t.SupportsIndex = 8) -> te.Self:\n        return self.__class__(super().expandtabs(tabsize))\n\n    def swapcase(self, /) -> te.Self:\n        return self.__class__(super().swapcase())\n\n    def zfill(self, width: t.SupportsIndex, /) -> te.Self:\n        return self.__class__(super().zfill(width))\n\n    def casefold(self, /) -> te.Self:\n        return self.__class__(super().casefold())\n\n    if sys.version_info >= (3, 9):\n\n        def removeprefix(self, prefix: str, /) -> te.Self:\n            return self.__class__(super().removeprefix(prefix))\n\n        def removesuffix(self, suffix: str) -> te.Self:\n            return self.__class__(super().removesuffix(suffix))\n\n    def partition(self, sep: str, /) -> tuple[te.Self, te.Self, te.Self]:\n        left, sep, right = super().partition(sep)\n        cls = self.__class__\n        return cls(left), cls(sep), cls(right)\n\n    def rpartition(self, sep: str, /) -> tuple[te.Self, te.Self, te.Self]:\n        left, sep, right = super().rpartition(sep)\n        cls = self.__class__\n        return cls(left), cls(sep), cls(right)\n\n    def format(self, *args: t.Any, **kwargs: t.Any) -> te.Self:\n        formatter = EscapeFormatter(self.escape)\n        return self.__class__(formatter.vformat(self, args, kwargs))\n\n    def format_map(\n        self,\n        mapping: cabc.Mapping[str, t.Any],  # type: ignore[override]\n        /,\n    ) -> te.Self:\n        formatter = EscapeFormatter(self.escape)\n        return self.__class__(formatter.vformat(self, (), mapping))\n\n    def __html_format__(self, format_spec: str, /) -> te.Self:\n        if format_spec:\n            raise ValueError(\"Unsupported format specification for Markup.\")\n\n        return self\n\n\nclass EscapeFormatter(string.Formatter):\n    __slots__ = (\"escape\",)\n\n    def __init__(self, escape: TPEscape) -> None:\n        self.escape: TPEscape = escape\n        super().__init__()\n\n    def format_field(self, value: t.Any, format_spec: str) -> str:\n        if hasattr(value, \"__html_format__\"):\n            rv = value.__html_format__(format_spec)\n        elif hasattr(value, \"__html__\"):\n            if format_spec:\n                raise ValueError(\n                    f\"Format specifier {format_spec} given, but {type(value)} does not\"\n                    \" define __html_format__. A class that defines __html__ must define\"\n                    \" __html_format__ to work with format specifiers.\"\n                )\n            rv = value.__html__()\n        else:\n            # We need to make sure the format spec is str here as\n            # otherwise the wrong callback methods are invoked.\n            rv = super().format_field(value, str(format_spec))\n        return str(self.escape(rv))\n\n\nclass _MarkupEscapeHelper:\n    \"\"\"Helper for :meth:`Markup.__mod__`.\"\"\"\n\n    __slots__ = (\"obj\", \"escape\")\n\n    def __init__(self, obj: t.Any, escape: TPEscape) -> None:\n        self.obj: t.Any = obj\n        self.escape: TPEscape = escape\n\n    def __getitem__(self, key: t.Any, /) -> te.Self:\n        return self.__class__(self.obj[key], self.escape)\n\n    def __str__(self, /) -> str:\n        return str(self.escape(self.obj))\n\n    def __repr__(self, /) -> str:\n        return str(self.escape(repr(self.obj)))\n\n    def __int__(self, /) -> int:\n        return int(self.obj)\n\n    def __float__(self, /) -> float:\n        return float(self.obj)\n\n\ndef __getattr__(name: str) -> t.Any:\n    if name == \"__version__\":\n        import importlib.metadata\n        import warnings\n\n        warnings.warn(\n            \"The '__version__' attribute is deprecated and will be removed in\"\n            \" MarkupSafe 3.1. Use feature detection, or\"\n            ' `importlib.metadata.version(\"markupsafe\")`, instead.',\n            stacklevel=2,\n        )\n        return importlib.metadata.version(\"markupsafe\")\n\n    raise AttributeError(name)\n"}