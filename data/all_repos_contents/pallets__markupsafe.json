{"setup.py": "import os\nimport platform\nimport sys\n\nfrom setuptools import Extension\nfrom setuptools import setup\nfrom setuptools.command.build_ext import build_ext\nfrom setuptools.errors import CCompilerError\nfrom setuptools.errors import ExecError\nfrom setuptools.errors import PlatformError\n\next_modules = [Extension(\"markupsafe._speedups\", [\"src/markupsafe/_speedups.c\"])]\n\n\nclass BuildFailed(Exception):\n    pass\n\n\nclass ve_build_ext(build_ext):\n    \"\"\"This class allows C extension building to fail.\"\"\"\n\n    def run(self):\n        try:\n            super().run()\n        except PlatformError as e:\n            raise BuildFailed() from e\n\n    def build_extension(self, ext):\n        try:\n            super().build_extension(ext)\n        except (CCompilerError, ExecError, PlatformError) as e:\n            raise BuildFailed() from e\n        except ValueError as e:\n            # this can happen on Windows 64 bit, see Python issue 7511\n            if \"'path'\" in str(sys.exc_info()[1]):  # works with Python 2 and 3\n                raise BuildFailed() from e\n            raise\n\n\ndef run_setup(with_binary):\n    setup(\n        cmdclass={\"build_ext\": ve_build_ext},\n        ext_modules=ext_modules if with_binary else [],\n    )\n\n\ndef show_message(*lines):\n    print(\"=\" * 74)\n    for line in lines:\n        print(line)\n    print(\"=\" * 74)\n\n\nsupports_speedups = platform.python_implementation() not in {\n    \"PyPy\",\n    \"Jython\",\n    \"GraalVM\",\n}\n\nif os.environ.get(\"CIBUILDWHEEL\", \"0\") == \"1\" and supports_speedups:\n    run_setup(True)\nelif supports_speedups:\n    try:\n        run_setup(True)\n    except BuildFailed:\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Failure information, if any, is above.\",\n            \"Retrying the build without the C extension now.\",\n        )\n        run_setup(False)\n        show_message(\n            \"WARNING: The C extension could not be compiled, speedups\"\n            \" are not enabled.\",\n            \"Plain-Python build succeeded.\",\n        )\nelse:\n    run_setup(False)\n    show_message(\n        \"WARNING: C extensions are not supported on this Python\"\n        \" platform, speedups are not enabled.\",\n        \"Plain-Python build succeeded.\",\n    )\n", "bench.py": "import subprocess\nimport sys\n\nfor name, s in (\n    (\"short escape\", '\"<strong>Hello, World!</strong>\"'),\n    (\"long escape\", '\"Hello, World!\" * 1000'),\n    (\"short plain\", '\"Hello, World!\"'),\n    (\"long plain\", '\"Hello, World!\" * 1000'),\n    (\"long suffix\", '\"<strong>Hello, World!</strong>\" + \"x\" * 100_000'),\n):\n    for mod in \"native\", \"speedups\":\n        subprocess.run(\n            [\n                sys.executable,\n                \"-m\",\n                \"pyperf\",\n                \"timeit\",\n                \"--name\",\n                f\"{name} {mod}\",\n                \"-s\",\n                (\n                    \"import markupsafe\\n\"\n                    f\"from markupsafe._{mod} import _escape_inner\\n\"\n                    \"markupsafe._escape_inner = _escape_inner\\n\"\n                    \"from markupsafe import escape\\n\"\n                    f\"s = {s}\"\n                ),\n                \"escape(s)\",\n            ]\n        )\n", "docs/conf.py": "from pallets_sphinx_themes import get_version\nfrom pallets_sphinx_themes import ProjectLink\n\n# Project --------------------------------------------------------------\n\nproject = \"MarkupSafe\"\ncopyright = \"2010 Pallets\"\nauthor = \"Pallets\"\nrelease, version = get_version(\"MarkupSafe\")\n\n# General --------------------------------------------------------------\n\ndefault_role = \"code\"\nextensions = [\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinxcontrib.log_cabinet\",\n    \"pallets_sphinx_themes\",\n]\nautodoc_member_order = \"bysource\"\nautodoc_typehints = \"description\"\nautodoc_preserve_defaults = True\nextlinks = {\n    \"issue\": (\"https://github.com/pallets/markupsafe/issues/%s\", \"#%s\"),\n    \"pr\": (\"https://github.com/pallets/markupsafe/pull/%s\", \"#%s\"),\n}\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3/\", None),\n}\n\n# HTML -----------------------------------------------------------------\n\nhtml_theme = \"jinja\"\nhtml_theme_options = {\"index_sidebar_logo\": False}\nhtml_context = {\n    \"project_links\": [\n        ProjectLink(\"Donate\", \"https://palletsprojects.com/donate\"),\n        ProjectLink(\"PyPI Releases\", \"https://pypi.org/project/MarkupSafe/\"),\n        ProjectLink(\"Source Code\", \"https://github.com/pallets/markupsafe/\"),\n        ProjectLink(\"Issue Tracker\", \"https://github.com/pallets/markupsafe/issues/\"),\n        ProjectLink(\"Chat\", \"https://discord.gg/pallets\"),\n    ]\n}\nhtml_sidebars = {\n    \"index\": [\"project.html\", \"localtoc.html\", \"searchbox.html\", \"ethicalads.html\"],\n    \"**\": [\"localtoc.html\", \"relations.html\", \"searchbox.html\", \"ethicalads.html\"],\n}\nsinglehtml_sidebars = {\"index\": [\"project.html\", \"localtoc.html\", \"ethicalads.html\"]}\nhtml_title = f\"MarkupSafe Documentation ({version})\"\nhtml_show_sourcelink = False\n", "tests/test_exception_custom_html.py": "from __future__ import annotations\n\nimport pytest\n\nfrom markupsafe import escape\n\n\nclass CustomHtmlThatRaises:\n    def __html__(self) -> str:\n        raise ValueError(123)\n\n\ndef test_exception_custom_html() -> None:\n    \"\"\"Checks whether exceptions in custom __html__ implementations are\n    propagated correctly.\n\n    There was a bug in the native implementation at some point:\n    https://github.com/pallets/markupsafe/issues/108\n    \"\"\"\n    obj = CustomHtmlThatRaises()\n\n    with pytest.raises(ValueError):\n        escape(obj)\n", "tests/test_markupsafe.py": "from __future__ import annotations\n\nimport typing as t\n\nimport pytest\n\nfrom markupsafe import escape\nfrom markupsafe import escape_silent\nfrom markupsafe import Markup\nfrom markupsafe import soft_str\n\n\ndef test_adding() -> None:\n    unsafe = '<script type=\"application/x-some-script\">alert(\"foo\");</script>'\n    safe = Markup(\"<em>username</em>\")\n    assert unsafe + safe == str(escape(unsafe)) + str(safe)\n\n\n@pytest.mark.parametrize(\n    (\"template\", \"data\", \"expect\"),\n    (\n        (\"<em>%s</em>\", \"<bad user>\", \"<em>&lt;bad user&gt;</em>\"),\n        (\n            \"<em>%(username)s</em>\",\n            {\"username\": \"<bad user>\"},\n            \"<em>&lt;bad user&gt;</em>\",\n        ),\n        (\"%i\", 3.14, \"3\"),\n        (\"%.2f\", 3.14, \"3.14\"),\n    ),\n)\ndef test_string_interpolation(template: str, data: t.Any, expect: str) -> None:\n    assert Markup(template) % data == expect\n\n\ndef test_type_behavior() -> None:\n    assert type(Markup(\"foo\") + \"bar\") is Markup\n    x = Markup(\"foo\")\n    assert x.__html__() is x\n\n\ndef test_html_interop() -> None:\n    class Foo:\n        def __html__(self) -> str:\n            return \"<em>awesome</em>\"\n\n        def __str__(self) -> str:\n            return \"awesome\"\n\n    assert Markup(Foo()) == \"<em>awesome</em>\"\n    result = Markup(\"<strong>%s</strong>\") % Foo()\n    assert result == \"<strong><em>awesome</em></strong>\"\n\n\n@pytest.mark.parametrize(\"args\", [\"foo\", 42, (\"foo\", 42)])\ndef test_missing_interpol(args: t.Any) -> None:\n    with pytest.raises(TypeError):\n        assert Markup(\"<em></em>\") % args\n\n\ndef test_tuple_interpol() -> None:\n    result = Markup(\"<em>%s:%s</em>\") % (\"<foo>\", \"<bar>\")\n    expect = Markup(\"<em>&lt;foo&gt;:&lt;bar&gt;</em>\")\n    assert result == expect\n\n\ndef test_dict_interpol() -> None:\n    result = Markup(\"<em>%(foo)s</em>\") % {\"foo\": \"<foo>\"}\n    expect = Markup(\"<em>&lt;foo&gt;</em>\")\n    assert result == expect\n\n    result = Markup(\"<em>%(foo)s:%(bar)s</em>\") % {\"foo\": \"<foo>\", \"bar\": \"<bar>\"}\n    expect = Markup(\"<em>&lt;foo&gt;:&lt;bar&gt;</em>\")\n    assert result == expect\n\n\ndef test_escaping() -> None:\n    assert escape(\"\\\"<>&'\") == \"&#34;&lt;&gt;&amp;&#39;\"\n    assert (\n        Markup(\n            \"<!-- outer comment -->\"\n            \"<em>Foo &amp; Bar\"\n            \" <!-- inner comment about <em> -->\\n \"\n            \"</em>\"\n            \"<!-- comment\\nwith\\nnewlines\\n-->\"\n            \"<meta content='tag\\nwith\\nnewlines'>\"\n        ).striptags()\n        == \"Foo & Bar\"\n    )\n\n\ndef test_unescape() -> None:\n    assert Markup(\"&lt;test&gt;\").unescape() == \"<test>\"\n\n    result = Markup(\"jack & tavi are cooler than mike &amp; russ\").unescape()\n    expect = \"jack & tavi are cooler than mike & russ\"\n    assert result == expect\n\n    original = \"&foo&#x3b;\"\n    once = Markup(original).unescape()\n    twice = Markup(once).unescape()\n    expect = \"&foo;\"\n    assert once == expect\n    assert twice == expect\n\n\ndef test_format() -> None:\n    result = Markup(\"<em>{awesome}</em>\").format(awesome=\"<awesome>\")\n    assert result == \"<em>&lt;awesome&gt;</em>\"\n\n    result = Markup(\"{0[1][bar]}\").format([0, {\"bar\": \"<bar/>\"}])\n    assert result == \"&lt;bar/&gt;\"\n\n    result = Markup(\"{0[1][bar]}\").format([0, {\"bar\": Markup(\"<bar/>\")}])\n    assert result == \"<bar/>\"\n\n\ndef test_format_map() -> None:\n    result = Markup(\"<em>{value}</em>\").format_map({\"value\": \"<value>\"})\n    assert result == \"<em>&lt;value&gt;</em>\"\n\n\ndef test_formatting_empty() -> None:\n    formatted = Markup(\"{}\").format(0)\n    assert formatted == Markup(\"0\")\n\n\ndef test_custom_formatting() -> None:\n    class HasHTMLOnly:\n        def __html__(self) -> Markup:\n            return Markup(\"<foo>\")\n\n    class HasHTMLAndFormat:\n        def __html__(self) -> Markup:\n            return Markup(\"<foo>\")\n\n        def __html_format__(self, spec: str) -> Markup:\n            return Markup(\"<FORMAT>\")\n\n    assert Markup(\"{0}\").format(HasHTMLOnly()) == Markup(\"<foo>\")\n    assert Markup(\"{0}\").format(HasHTMLAndFormat()) == Markup(\"<FORMAT>\")\n\n\ndef test_complex_custom_formatting() -> None:\n    class User:\n        def __init__(self, id: int, username: str) -> None:\n            self.id = id\n            self.username = username\n\n        def __html_format__(self, format_spec: str) -> Markup:\n            if format_spec == \"link\":\n                return Markup('<a href=\"/user/{0}\">{1}</a>').format(\n                    self.id, self.__html__()\n                )\n            elif format_spec:\n                raise ValueError(\"Invalid format spec\")\n\n            return self.__html__()\n\n        def __html__(self) -> Markup:\n            return Markup(\"<span class=user>{0}</span>\").format(self.username)\n\n    user = User(1, \"foo\")\n    result = Markup(\"<p>User: {0:link}\").format(user)\n    expect = Markup('<p>User: <a href=\"/user/1\"><span class=user>foo</span></a>')\n    assert result == expect\n\n\ndef test_formatting_with_objects() -> None:\n    class Stringable:\n        def __str__(self) -> str:\n            return \"\u0441\u0442\u0440\u043e\u043a\u0430\"\n\n    assert Markup(\"{s}\").format(s=Stringable()) == Markup(\"\u0441\u0442\u0440\u043e\u043a\u0430\")\n\n\ndef test_escape_silent() -> None:\n    assert escape_silent(None) == Markup()\n    assert escape(None) == Markup(None)\n    assert escape_silent(\"<foo>\") == Markup(\"&lt;foo&gt;\")\n\n\ndef test_splitting() -> None:\n    expect = [Markup(\"a\"), Markup(\"b\")]\n    assert Markup(\"a b\").split() == expect\n    assert Markup(\"a b\").rsplit() == expect\n    assert Markup(\"a\\nb\").splitlines() == expect\n\n\ndef test_mul() -> None:\n    assert Markup(\"a\") * 3 == Markup(\"aaa\")\n\n\ndef test_escape_return_type() -> None:\n    assert isinstance(escape(\"a\"), Markup)\n    assert isinstance(escape(Markup(\"a\")), Markup)\n\n    class Foo:\n        def __html__(self) -> str:\n            return \"<strong>Foo</strong>\"\n\n    assert isinstance(escape(Foo()), Markup)\n\n\ndef test_soft_str() -> None:\n    assert type(soft_str(\"\")) is str  # noqa: E721\n    assert type(soft_str(Markup())) is Markup  # noqa: E721\n    assert type(soft_str(15)) is str  # noqa: E721\n", "tests/test_escape.py": "from __future__ import annotations\n\nimport pytest\n\nfrom markupsafe import escape\nfrom markupsafe import Markup\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expect\"),\n    (\n        # empty\n        (\"\", \"\"),\n        # ascii\n        (\"abcd&><'\\\"efgh\", \"abcd&amp;&gt;&lt;&#39;&#34;efgh\"),\n        (\"&><'\\\"efgh\", \"&amp;&gt;&lt;&#39;&#34;efgh\"),\n        (\"abcd&><'\\\"\", \"abcd&amp;&gt;&lt;&#39;&#34;\"),\n        # 2 byte\n        (\"\u3053\u3093\u306b\u3061\u306f&><'\\\"\u3053\u3093\u3070\u3093\u306f\", \"\u3053\u3093\u306b\u3061\u306f&amp;&gt;&lt;&#39;&#34;\u3053\u3093\u3070\u3093\u306f\"),\n        (\"&><'\\\"\u3053\u3093\u3070\u3093\u306f\", \"&amp;&gt;&lt;&#39;&#34;\u3053\u3093\u3070\u3093\u306f\"),\n        (\"\u3053\u3093\u306b\u3061\u306f&><'\\\"\", \"\u3053\u3093\u306b\u3061\u306f&amp;&gt;&lt;&#39;&#34;\"),\n        # 4 byte\n        (\n            \"\\U0001f363\\U0001f362&><'\\\"\\U0001f37a xyz\",\n            \"\\U0001f363\\U0001f362&amp;&gt;&lt;&#39;&#34;\\U0001f37a xyz\",\n        ),\n        (\"&><'\\\"\\U0001f37a xyz\", \"&amp;&gt;&lt;&#39;&#34;\\U0001f37a xyz\"),\n        (\"\\U0001f363\\U0001f362&><'\\\"\", \"\\U0001f363\\U0001f362&amp;&gt;&lt;&#39;&#34;\"),\n    ),\n)\ndef test_escape(value: str, expect: str) -> None:\n    assert escape(value) == Markup(expect)\n", "tests/conftest.py": "from __future__ import annotations\n\nimport typing as t\nfrom types import ModuleType\n\nimport pytest\n\nimport markupsafe\nfrom markupsafe import _native\n\ntry:\n    from markupsafe import _speedups\nexcept ImportError:\n    _speedups = None  # type: ignore\n\n\n@pytest.fixture(\n    scope=\"session\",\n    autouse=True,\n    params=(\n        _native,\n        pytest.param(\n            _speedups,\n            marks=pytest.mark.skipif(_speedups is None, reason=\"speedups unavailable\"),\n        ),\n    ),\n)\ndef _mod(request: pytest.FixtureRequest) -> None:\n    mod = t.cast(ModuleType, request.param)\n    markupsafe._escape_inner = mod._escape_inner  # type: ignore[attr-defined]\n", "tests/__init__.py": "", "tests/test_leak.py": "from __future__ import annotations\n\nimport gc\n\nfrom markupsafe import escape\n\n\ndef test_markup_leaks() -> None:\n    counts = set()\n    # Try to start with a \"clean\" count. Works for PyPy but not 3.13 JIT.\n    gc.collect()\n\n    for _ in range(20):\n        for _ in range(1000):\n            escape(\"foo\")\n            escape(\"<foo>\")\n            escape(\"foo\")\n            escape(\"<foo>\")\n\n        counts.add(len(gc.get_objects()))\n\n    # Some implementations, such as PyPy and Python 3.13 JIT, end up with 2\n    # counts rather than one. Presumably this is internals stabilizing. A leak\n    # would presumably have a different count every loop.\n    assert len(counts) < 3\n", "src/markupsafe/_native.py": "def _escape_inner(s: str, /) -> str:\n    return (\n        s.replace(\"&\", \"&amp;\")\n        .replace(\">\", \"&gt;\")\n        .replace(\"<\", \"&lt;\")\n        .replace(\"'\", \"&#39;\")\n        .replace('\"', \"&#34;\")\n    )\n", "src/markupsafe/__init__.py": "from __future__ import annotations\n\nimport collections.abc as cabc\nimport string\nimport sys\nimport typing as t\n\ntry:\n    from ._speedups import _escape_inner\nexcept ImportError:\n    from ._native import _escape_inner\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    class HasHTML(te.Protocol):\n        def __html__(self, /) -> str: ...\n\n    class TPEscape(te.Protocol):\n        def __call__(self, s: t.Any, /) -> Markup: ...\n\n\ndef escape(s: t.Any, /) -> Markup:\n    \"\"\"Replace the characters ``&``, ``<``, ``>``, ``'``, and ``\"`` in\n    the string with HTML-safe sequences. Use this if you need to display\n    text that might contain such characters in HTML.\n\n    If the object has an ``__html__`` method, it is called and the\n    return value is assumed to already be safe for HTML.\n\n    :param s: An object to be converted to a string and escaped.\n    :return: A :class:`Markup` string with the escaped text.\n    \"\"\"\n    # If the object is already a plain string, skip __html__ check and string\n    # conversion. This is the most common use case.\n    if s.__class__ is str:\n        return Markup(_escape_inner(s))\n\n    if hasattr(s, \"__html__\"):\n        return Markup(s.__html__())\n\n    return Markup(_escape_inner(str(s)))\n\n\ndef escape_silent(s: t.Any | None, /) -> Markup:\n    \"\"\"Like :func:`escape` but treats ``None`` as the empty string.\n    Useful with optional values, as otherwise you get the string\n    ``'None'`` when the value is ``None``.\n\n    >>> escape(None)\n    Markup('None')\n    >>> escape_silent(None)\n    Markup('')\n    \"\"\"\n    if s is None:\n        return Markup()\n\n    return escape(s)\n\n\ndef soft_str(s: t.Any, /) -> str:\n    \"\"\"Convert an object to a string if it isn't already. This preserves\n    a :class:`Markup` string rather than converting it back to a basic\n    string, so it will still be marked as safe and won't be escaped\n    again.\n\n    >>> value = escape(\"<User 1>\")\n    >>> value\n    Markup('&lt;User 1&gt;')\n    >>> escape(str(value))\n    Markup('&amp;lt;User 1&amp;gt;')\n    >>> escape(soft_str(value))\n    Markup('&lt;User 1&gt;')\n    \"\"\"\n    if not isinstance(s, str):\n        return str(s)\n\n    return s\n\n\nclass Markup(str):\n    \"\"\"A string that is ready to be safely inserted into an HTML or XML\n    document, either because it was escaped or because it was marked\n    safe.\n\n    Passing an object to the constructor converts it to text and wraps\n    it to mark it safe without escaping. To escape the text, use the\n    :meth:`escape` class method instead.\n\n    >>> Markup(\"Hello, <em>World</em>!\")\n    Markup('Hello, <em>World</em>!')\n    >>> Markup(42)\n    Markup('42')\n    >>> Markup.escape(\"Hello, <em>World</em>!\")\n    Markup('Hello &lt;em&gt;World&lt;/em&gt;!')\n\n    This implements the ``__html__()`` interface that some frameworks\n    use. Passing an object that implements ``__html__()`` will wrap the\n    output of that method, marking it safe.\n\n    >>> class Foo:\n    ...     def __html__(self):\n    ...         return '<a href=\"/foo\">foo</a>'\n    ...\n    >>> Markup(Foo())\n    Markup('<a href=\"/foo\">foo</a>')\n\n    This is a subclass of :class:`str`. It has the same methods, but\n    escapes their arguments and returns a ``Markup`` instance.\n\n    >>> Markup(\"<em>%s</em>\") % (\"foo & bar\",)\n    Markup('<em>foo &amp; bar</em>')\n    >>> Markup(\"<em>Hello</em> \") + \"<foo>\"\n    Markup('<em>Hello</em> &lt;foo&gt;')\n    \"\"\"\n\n    __slots__ = ()\n\n    def __new__(\n        cls, object: t.Any = \"\", encoding: str | None = None, errors: str = \"strict\"\n    ) -> te.Self:\n        if hasattr(object, \"__html__\"):\n            object = object.__html__()\n\n        if encoding is None:\n            return super().__new__(cls, object)\n\n        return super().__new__(cls, object, encoding, errors)\n\n    def __html__(self, /) -> te.Self:\n        return self\n\n    def __add__(self, value: str | HasHTML, /) -> te.Self:\n        if isinstance(value, str) or hasattr(value, \"__html__\"):\n            return self.__class__(super().__add__(self.escape(value)))\n\n        return NotImplemented\n\n    def __radd__(self, value: str | HasHTML, /) -> te.Self:\n        if isinstance(value, str) or hasattr(value, \"__html__\"):\n            return self.escape(value).__add__(self)\n\n        return NotImplemented\n\n    def __mul__(self, value: t.SupportsIndex, /) -> te.Self:\n        return self.__class__(super().__mul__(value))\n\n    def __rmul__(self, value: t.SupportsIndex, /) -> te.Self:\n        return self.__class__(super().__mul__(value))\n\n    def __mod__(self, value: t.Any, /) -> te.Self:\n        if isinstance(value, tuple):\n            # a tuple of arguments, each wrapped\n            value = tuple(_MarkupEscapeHelper(x, self.escape) for x in value)\n        elif hasattr(type(value), \"__getitem__\") and not isinstance(value, str):\n            # a mapping of arguments, wrapped\n            value = _MarkupEscapeHelper(value, self.escape)\n        else:\n            # a single argument, wrapped with the helper and a tuple\n            value = (_MarkupEscapeHelper(value, self.escape),)\n\n        return self.__class__(super().__mod__(value))\n\n    def __repr__(self, /) -> str:\n        return f\"{self.__class__.__name__}({super().__repr__()})\"\n\n    def join(self, iterable: cabc.Iterable[str | HasHTML], /) -> te.Self:\n        return self.__class__(super().join(map(self.escape, iterable)))\n\n    def split(  # type: ignore[override]\n        self, /, sep: str | None = None, maxsplit: t.SupportsIndex = -1\n    ) -> list[te.Self]:\n        return [self.__class__(v) for v in super().split(sep, maxsplit)]\n\n    def rsplit(  # type: ignore[override]\n        self, /, sep: str | None = None, maxsplit: t.SupportsIndex = -1\n    ) -> list[te.Self]:\n        return [self.__class__(v) for v in super().rsplit(sep, maxsplit)]\n\n    def splitlines(  # type: ignore[override]\n        self, /, keepends: bool = False\n    ) -> list[te.Self]:\n        return [self.__class__(v) for v in super().splitlines(keepends)]\n\n    def unescape(self, /) -> str:\n        \"\"\"Convert escaped markup back into a text string. This replaces\n        HTML entities with the characters they represent.\n\n        >>> Markup(\"Main &raquo; <em>About</em>\").unescape()\n        'Main \u00bb <em>About</em>'\n        \"\"\"\n        from html import unescape\n\n        return unescape(str(self))\n\n    def striptags(self, /) -> str:\n        \"\"\":meth:`unescape` the markup, remove tags, and normalize\n        whitespace to single spaces.\n\n        >>> Markup(\"Main &raquo;\\t<em>About</em>\").striptags()\n        'Main \u00bb About'\n        \"\"\"\n        value = str(self)\n\n        # Look for comments then tags separately. Otherwise, a comment that\n        # contains a tag would end early, leaving some of the comment behind.\n\n        # keep finding comment start marks\n        while (start := value.find(\"<!--\")) != -1:\n            # find a comment end mark beyond the start, otherwise stop\n            if (end := value.find(\"-->\", start)) == -1:\n                break\n\n            value = f\"{value[:start]}{value[end + 3:]}\"\n\n        # remove tags using the same method\n        while (start := value.find(\"<\")) != -1:\n            if (end := value.find(\">\", start)) == -1:\n                break\n\n            value = f\"{value[:start]}{value[end + 1:]}\"\n\n        # collapse spaces\n        value = \" \".join(value.split())\n        return self.__class__(value).unescape()\n\n    @classmethod\n    def escape(cls, s: t.Any, /) -> te.Self:\n        \"\"\"Escape a string. Calls :func:`escape` and ensures that for\n        subclasses the correct type is returned.\n        \"\"\"\n        rv = escape(s)\n\n        if rv.__class__ is not cls:\n            return cls(rv)\n\n        return rv  # type: ignore[return-value]\n\n    def __getitem__(self, key: t.SupportsIndex | slice, /) -> te.Self:\n        return self.__class__(super().__getitem__(key))\n\n    def capitalize(self, /) -> te.Self:\n        return self.__class__(super().capitalize())\n\n    def title(self, /) -> te.Self:\n        return self.__class__(super().title())\n\n    def lower(self, /) -> te.Self:\n        return self.__class__(super().lower())\n\n    def upper(self, /) -> te.Self:\n        return self.__class__(super().upper())\n\n    def replace(self, old: str, new: str, count: t.SupportsIndex = -1, /) -> te.Self:\n        return self.__class__(super().replace(old, self.escape(new), count))\n\n    def ljust(self, width: t.SupportsIndex, fillchar: str = \" \", /) -> te.Self:\n        return self.__class__(super().ljust(width, self.escape(fillchar)))\n\n    def rjust(self, width: t.SupportsIndex, fillchar: str = \" \", /) -> te.Self:\n        return self.__class__(super().rjust(width, self.escape(fillchar)))\n\n    def lstrip(self, chars: str | None = None, /) -> te.Self:\n        return self.__class__(super().lstrip(chars))\n\n    def rstrip(self, chars: str | None = None, /) -> te.Self:\n        return self.__class__(super().rstrip(chars))\n\n    def center(self, width: t.SupportsIndex, fillchar: str = \" \", /) -> te.Self:\n        return self.__class__(super().center(width, self.escape(fillchar)))\n\n    def strip(self, chars: str | None = None, /) -> te.Self:\n        return self.__class__(super().strip(chars))\n\n    def translate(\n        self,\n        table: cabc.Mapping[int, str | int | None],  # type: ignore[override]\n        /,\n    ) -> str:\n        return self.__class__(super().translate(table))\n\n    def expandtabs(self, /, tabsize: t.SupportsIndex = 8) -> te.Self:\n        return self.__class__(super().expandtabs(tabsize))\n\n    def swapcase(self, /) -> te.Self:\n        return self.__class__(super().swapcase())\n\n    def zfill(self, width: t.SupportsIndex, /) -> te.Self:\n        return self.__class__(super().zfill(width))\n\n    def casefold(self, /) -> te.Self:\n        return self.__class__(super().casefold())\n\n    if sys.version_info >= (3, 9):\n\n        def removeprefix(self, prefix: str, /) -> te.Self:\n            return self.__class__(super().removeprefix(prefix))\n\n        def removesuffix(self, suffix: str) -> te.Self:\n            return self.__class__(super().removesuffix(suffix))\n\n    def partition(self, sep: str, /) -> tuple[te.Self, te.Self, te.Self]:\n        left, sep, right = super().partition(sep)\n        cls = self.__class__\n        return cls(left), cls(sep), cls(right)\n\n    def rpartition(self, sep: str, /) -> tuple[te.Self, te.Self, te.Self]:\n        left, sep, right = super().rpartition(sep)\n        cls = self.__class__\n        return cls(left), cls(sep), cls(right)\n\n    def format(self, *args: t.Any, **kwargs: t.Any) -> te.Self:\n        formatter = EscapeFormatter(self.escape)\n        return self.__class__(formatter.vformat(self, args, kwargs))\n\n    def format_map(\n        self,\n        mapping: cabc.Mapping[str, t.Any],  # type: ignore[override]\n        /,\n    ) -> te.Self:\n        formatter = EscapeFormatter(self.escape)\n        return self.__class__(formatter.vformat(self, (), mapping))\n\n    def __html_format__(self, format_spec: str, /) -> te.Self:\n        if format_spec:\n            raise ValueError(\"Unsupported format specification for Markup.\")\n\n        return self\n\n\nclass EscapeFormatter(string.Formatter):\n    __slots__ = (\"escape\",)\n\n    def __init__(self, escape: TPEscape) -> None:\n        self.escape: TPEscape = escape\n        super().__init__()\n\n    def format_field(self, value: t.Any, format_spec: str) -> str:\n        if hasattr(value, \"__html_format__\"):\n            rv = value.__html_format__(format_spec)\n        elif hasattr(value, \"__html__\"):\n            if format_spec:\n                raise ValueError(\n                    f\"Format specifier {format_spec} given, but {type(value)} does not\"\n                    \" define __html_format__. A class that defines __html__ must define\"\n                    \" __html_format__ to work with format specifiers.\"\n                )\n            rv = value.__html__()\n        else:\n            # We need to make sure the format spec is str here as\n            # otherwise the wrong callback methods are invoked.\n            rv = super().format_field(value, str(format_spec))\n        return str(self.escape(rv))\n\n\nclass _MarkupEscapeHelper:\n    \"\"\"Helper for :meth:`Markup.__mod__`.\"\"\"\n\n    __slots__ = (\"obj\", \"escape\")\n\n    def __init__(self, obj: t.Any, escape: TPEscape) -> None:\n        self.obj: t.Any = obj\n        self.escape: TPEscape = escape\n\n    def __getitem__(self, key: t.Any, /) -> te.Self:\n        return self.__class__(self.obj[key], self.escape)\n\n    def __str__(self, /) -> str:\n        return str(self.escape(self.obj))\n\n    def __repr__(self, /) -> str:\n        return str(self.escape(repr(self.obj)))\n\n    def __int__(self, /) -> int:\n        return int(self.obj)\n\n    def __float__(self, /) -> float:\n        return float(self.obj)\n\n\ndef __getattr__(name: str) -> t.Any:\n    if name == \"__version__\":\n        import importlib.metadata\n        import warnings\n\n        warnings.warn(\n            \"The '__version__' attribute is deprecated and will be removed in\"\n            \" MarkupSafe 3.1. Use feature detection, or\"\n            ' `importlib.metadata.version(\"markupsafe\")`, instead.',\n            stacklevel=2,\n        )\n        return importlib.metadata.version(\"markupsafe\")\n\n    raise AttributeError(name)\n"}