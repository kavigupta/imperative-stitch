{"ptyprocess/ptyprocess.py": "import codecs\nimport errno\nimport fcntl\nimport io\nimport os\nimport pty\nimport resource\nimport signal\nimport struct\nimport sys\nimport termios\nimport time\n\ntry:\n    import builtins  # Python 3\nexcept ImportError:\n    import __builtin__ as builtins  # Python 2\n\n# Constants\nfrom pty import (STDIN_FILENO, CHILD)\n\nfrom .util import which, PtyProcessError\n\n_platform = sys.platform.lower()\n\n# Solaris uses internal __fork_pty(). All others use pty.fork().\n_is_solaris = (\n    _platform.startswith('solaris') or\n    _platform.startswith('sunos'))\n\nif _is_solaris:\n    use_native_pty_fork = False\n    from . import _fork_pty\nelse:\n    use_native_pty_fork = True\n\nPY3 = sys.version_info[0] >= 3\n\nif PY3:\n    def _byte(i):\n        return bytes([i])\nelse:\n    def _byte(i):\n        return chr(i)\n    \n    class FileNotFoundError(OSError): pass\n    class TimeoutError(OSError): pass\n\n_EOF, _INTR = None, None\n\ndef _make_eof_intr():\n    \"\"\"Set constants _EOF and _INTR.\n    \n    This avoids doing potentially costly operations on module load.\n    \"\"\"\n    global _EOF, _INTR\n    if (_EOF is not None) and (_INTR is not None):\n        return\n\n    # inherit EOF and INTR definitions from controlling process.\n    try:\n        from termios import VEOF, VINTR\n        fd = None\n        for name in 'stdin', 'stdout':\n            stream = getattr(sys, '__%s__' % name, None)\n            if stream is None or not hasattr(stream, 'fileno'):\n                continue\n            try:\n                fd = stream.fileno()\n            except ValueError:\n                continue\n        if fd is None:\n            # no fd, raise ValueError to fallback on CEOF, CINTR\n            raise ValueError(\"No stream has a fileno\")\n        intr = ord(termios.tcgetattr(fd)[6][VINTR])\n        eof = ord(termios.tcgetattr(fd)[6][VEOF])\n    except (ImportError, OSError, IOError, ValueError, termios.error):\n        # unless the controlling process is also not a terminal,\n        # such as cron(1), or when stdin and stdout are both closed.\n        # Fall-back to using CEOF and CINTR. There\n        try:\n            from termios import CEOF, CINTR\n            (intr, eof) = (CINTR, CEOF)\n        except ImportError:\n            #                         ^C, ^D\n            (intr, eof) = (3, 4)\n    \n    _INTR = _byte(intr)\n    _EOF = _byte(eof)\n\n# setecho and setwinsize are pulled out here because on some platforms, we need\n# to do this from the child before we exec()\n    \ndef _setecho(fd, state):\n    errmsg = 'setecho() may not be called on this platform (it may still be possible to enable/disable echo when spawning the child process)'\n\n    try:\n        attr = termios.tcgetattr(fd)\n    except termios.error as err:\n        if err.args[0] == errno.EINVAL:\n            raise IOError(err.args[0], '%s: %s.' % (err.args[1], errmsg))\n        raise\n\n    if state:\n        attr[3] = attr[3] | termios.ECHO\n    else:\n        attr[3] = attr[3] & ~termios.ECHO\n\n    try:\n        # I tried TCSADRAIN and TCSAFLUSH, but these were inconsistent and\n        # blocked on some platforms. TCSADRAIN would probably be ideal.\n        termios.tcsetattr(fd, termios.TCSANOW, attr)\n    except IOError as err:\n        if err.args[0] == errno.EINVAL:\n            raise IOError(err.args[0], '%s: %s.' % (err.args[1], errmsg))\n        raise\n\ndef _setwinsize(fd, rows, cols):\n    # Some very old platforms have a bug that causes the value for\n    # termios.TIOCSWINSZ to be truncated. There was a hack here to work\n    # around this, but it caused problems with newer platforms so has been\n    # removed. For details see https://github.com/pexpect/pexpect/issues/39\n    TIOCSWINSZ = getattr(termios, 'TIOCSWINSZ', -2146929561)\n    # Note, assume ws_xpixel and ws_ypixel are zero.\n    s = struct.pack('HHHH', rows, cols, 0, 0)\n    fcntl.ioctl(fd, TIOCSWINSZ, s)\n\nclass PtyProcess(object):\n    '''This class represents a process running in a pseudoterminal.\n    \n    The main constructor is the :meth:`spawn` classmethod.\n    '''\n    string_type = bytes\n    if PY3:\n        linesep = os.linesep.encode('ascii')\n        crlf = '\\r\\n'.encode('ascii')\n\n        @staticmethod\n        def write_to_stdout(b):\n            try:\n                return sys.stdout.buffer.write(b)\n            except AttributeError:\n                # If stdout has been replaced, it may not have .buffer\n                return sys.stdout.write(b.decode('ascii', 'replace'))\n    else:\n        linesep = os.linesep\n        crlf = '\\r\\n'\n        write_to_stdout = sys.stdout.write\n\n    encoding = None\n    \n    argv = None\n    env = None\n    launch_dir = None\n\n    def __init__(self, pid, fd):\n        _make_eof_intr()  # Ensure _EOF and _INTR are calculated\n        self.pid = pid\n        self.fd = fd\n        readf = io.open(fd, 'rb', buffering=0)\n        writef = io.open(fd, 'wb', buffering=0, closefd=False)\n        self.fileobj = io.BufferedRWPair(readf, writef)\n\n        self.terminated = False\n        self.closed = False\n        self.exitstatus = None\n        self.signalstatus = None\n        # status returned by os.waitpid\n        self.status = None\n        self.flag_eof = False\n        # Used by close() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterclose = 0.1\n        # Used by terminate() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterterminate = 0.1\n\n    @classmethod\n    def spawn(\n            cls, argv, cwd=None, env=None, echo=True, preexec_fn=None,\n            dimensions=(24, 80), pass_fds=()):\n        '''Start the given command in a child process in a pseudo terminal.\n\n        This does all the fork/exec type of stuff for a pty, and returns an\n        instance of PtyProcess.\n\n        If preexec_fn is supplied, it will be called with no arguments in the\n        child process before exec-ing the specified command.\n        It may, for instance, set signal handlers to SIG_DFL or SIG_IGN.\n\n        Dimensions of the psuedoterminal used for the subprocess can be\n        specified as a tuple (rows, cols), or the default (24, 80) will be used.\n\n        By default, all file descriptors except 0, 1 and 2 are closed. This\n        behavior can be overridden with pass_fds, a list of file descriptors to\n        keep open between the parent and the child.\n        '''\n        # Note that it is difficult for this method to fail.\n        # You cannot detect if the child process cannot start.\n        # So the only way you can tell if the child process started\n        # or not is to try to read from the file descriptor. If you get\n        # EOF immediately then it means that the child is already dead.\n        # That may not necessarily be bad because you may have spawned a child\n        # that performs some task; creates no stdout output; and then dies.\n\n        if not isinstance(argv, (list, tuple)):\n            raise TypeError(\"Expected a list or tuple for argv, got %r\" % argv)\n\n        # Shallow copy of argv so we can modify it\n        argv = argv[:]\n        command = argv[0]\n\n        command_with_path = which(command)\n        if command_with_path is None:\n            raise FileNotFoundError('The command was not found or was not ' +\n                                    'executable: %s.' % command)\n        command = command_with_path\n        argv[0] = command\n\n        # [issue #119] To prevent the case where exec fails and the user is\n        # stuck interacting with a python child process instead of whatever\n        # was expected, we implement the solution from\n        # http://stackoverflow.com/a/3703179 to pass the exception to the\n        # parent process\n\n        # [issue #119] 1. Before forking, open a pipe in the parent process.\n        exec_err_pipe_read, exec_err_pipe_write = os.pipe()\n\n        if use_native_pty_fork:\n            pid, fd = pty.fork()\n        else:\n            # Use internal fork_pty, for Solaris\n            pid, fd = _fork_pty.fork_pty()\n\n        # Some platforms must call setwinsize() and setecho() from the\n        # child process, and others from the master process. We do both,\n        # allowing IOError for either.\n\n        if pid == CHILD:\n            # set window size\n            try:\n                _setwinsize(STDIN_FILENO, *dimensions)\n            except IOError as err:\n                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                    raise\n\n            # disable echo if spawn argument echo was unset\n            if not echo:\n                try:\n                    _setecho(STDIN_FILENO, False)\n                except (IOError, termios.error) as err:\n                    if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                        raise\n\n            # [issue #119] 3. The child closes the reading end and sets the\n            # close-on-exec flag for the writing end.\n            os.close(exec_err_pipe_read)\n            fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)\n\n            # Do not allow child to inherit open file descriptors from parent,\n            # with the exception of the exec_err_pipe_write of the pipe\n            # and pass_fds.\n            # Impose ceiling on max_fd: AIX bugfix for users with unlimited\n            # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()\n            # occasionally raises out of range error\n            max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])\n            spass_fds = sorted(set(pass_fds) | {exec_err_pipe_write})\n            for pair in zip([2] + spass_fds, spass_fds + [max_fd]):\n                os.closerange(pair[0]+1, pair[1])\n\n            if cwd is not None:\n                os.chdir(cwd)\n\n            if preexec_fn is not None:\n                try:\n                    preexec_fn()\n                except Exception as e:\n                    ename = type(e).__name__\n                    tosend = '{}:0:{}'.format(ename, str(e))\n                    if PY3:\n                        tosend = tosend.encode('utf-8')\n\n                    os.write(exec_err_pipe_write, tosend)\n                    os.close(exec_err_pipe_write)\n                    os._exit(1)\n\n            try:\n                if env is None:\n                    os.execv(command, argv)\n                else:\n                    os.execvpe(command, argv, env)\n            except OSError as err:\n                # [issue #119] 5. If exec fails, the child writes the error\n                # code back to the parent using the pipe, then exits.\n                tosend = 'OSError:{}:{}'.format(err.errno, str(err))\n                if PY3:\n                    tosend = tosend.encode('utf-8')\n                os.write(exec_err_pipe_write, tosend)\n                os.close(exec_err_pipe_write)\n                os._exit(os.EX_OSERR)\n\n        # Parent\n        inst = cls(pid, fd)\n        \n        # Set some informational attributes\n        inst.argv = argv\n        if env is not None:\n            inst.env = env\n        if cwd is not None:\n            inst.launch_dir = cwd\n\n        # [issue #119] 2. After forking, the parent closes the writing end\n        # of the pipe and reads from the reading end.\n        os.close(exec_err_pipe_write)\n        exec_err_data = os.read(exec_err_pipe_read, 4096)\n        os.close(exec_err_pipe_read)\n\n        # [issue #119] 6. The parent reads eof (a zero-length read) if the\n        # child successfully performed exec, since close-on-exec made\n        # successful exec close the writing end of the pipe. Or, if exec\n        # failed, the parent reads the error code and can proceed\n        # accordingly. Either way, the parent blocks until the child calls\n        # exec.\n        if len(exec_err_data) != 0:\n            try:\n                errclass, errno_s, errmsg = exec_err_data.split(b':', 2)\n                exctype = getattr(builtins, errclass.decode('ascii'), Exception)\n\n                exception = exctype(errmsg.decode('utf-8', 'replace'))\n                if exctype is OSError:\n                    exception.errno = int(errno_s)\n            except:\n                raise Exception('Subprocess failed, got bad error data: %r'\n                                    % exec_err_data)\n            else:\n                raise exception\n\n        try:\n            inst.setwinsize(*dimensions)\n        except IOError as err:\n            if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):\n                raise\n\n        return inst\n\n    def __repr__(self):\n        clsname = type(self).__name__\n        if self.argv is not None:\n            args = [repr(self.argv)]\n            if self.env is not None:\n                args.append(\"env=%r\" % self.env)\n            if self.launch_dir is not None:\n                args.append(\"cwd=%r\" % self.launch_dir)\n            \n            return \"{}.spawn({})\".format(clsname, \", \".join(args))\n        \n        else:\n            return \"{}(pid={}, fd={})\".format(clsname, self.pid, self.fd)\n\n    @staticmethod\n    def _coerce_send_string(s):\n        if not isinstance(s, bytes):\n            return s.encode('utf-8')\n        return s\n\n    @staticmethod\n    def _coerce_read_string(s):\n        return s\n\n    def __del__(self):\n        '''This makes sure that no system resources are left open. Python only\n        garbage collects Python objects. OS file descriptors are not Python\n        objects, so they must be handled explicitly. If the child file\n        descriptor was opened outside of this class (passed to the constructor)\n        then this does not close it. '''\n\n        if not self.closed:\n            # It is possible for __del__ methods to execute during the\n            # teardown of the Python VM itself. Thus self.close() may\n            # trigger an exception because os.close may be None.\n            try:\n                self.close()\n            # which exception, shouldn't we catch explicitly .. ?\n            except:\n                pass\n\n\n    def fileno(self):\n        '''This returns the file descriptor of the pty for the child.\n        '''\n        return self.fd\n\n    def close(self, force=True):\n        '''This closes the connection with the child application. Note that\n        calling close() more than once is valid. This emulates standard Python\n        behavior with files. Set force to True if you want to make sure that\n        the child is terminated (SIGKILL is sent if the child ignores SIGHUP\n        and SIGINT). '''\n        if not self.closed:\n            self.flush()\n            self.fileobj.close() # Closes the file descriptor\n            # Give kernel time to update process status.\n            time.sleep(self.delayafterclose)\n            if self.isalive():\n                if not self.terminate(force):\n                    raise PtyProcessError('Could not terminate the child.')\n            self.fd = -1\n            self.closed = True\n            #self.pid = None\n\n    def flush(self):\n        '''This does nothing. It is here to support the interface for a\n        File-like object. '''\n\n        pass\n\n    def isatty(self):\n        '''This returns True if the file descriptor is open and connected to a\n        tty(-like) device, else False.\n\n        On SVR4-style platforms implementing streams, such as SunOS and HP-UX,\n        the child pty may not appear as a terminal device.  This means\n        methods such as setecho(), setwinsize(), getwinsize() may raise an\n        IOError. '''\n\n        return os.isatty(self.fd)\n\n    def waitnoecho(self, timeout=None):\n        '''Wait until the terminal ECHO flag is set False.\n\n        This returns True if the echo mode is off, or False if echo was not\n        disabled before the timeout. This can be used to detect when the\n        child is waiting for a password. Usually a child application will turn\n        off echo mode when it is waiting for the user to enter a password. For\n        example, instead of expecting the \"password:\" prompt you can wait for\n        the child to turn echo off::\n\n            p = pexpect.spawn('ssh user@example.com')\n            p.waitnoecho()\n            p.sendline(mypassword)\n\n        If ``timeout=None`` then this method to block until ECHO flag is False.\n        '''\n\n        if timeout is not None:\n            end_time = time.time() + timeout\n        while True:\n            if not self.getecho():\n                return True\n            if timeout < 0 and timeout is not None:\n                return False\n            if timeout is not None:\n                timeout = end_time - time.time()\n            time.sleep(0.1)\n\n    def getecho(self):\n        '''Returns True if terminal echo is on, or False if echo is off.\n\n        Child applications that are expecting you to enter a password often\n        disable echo. See also :meth:`waitnoecho`.\n\n        Not supported on platforms where ``isatty()`` returns False.\n        '''\n\n        try:\n            attr = termios.tcgetattr(self.fd)\n        except termios.error as err:\n            errmsg = 'getecho() may not be called on this platform'\n            if err.args[0] == errno.EINVAL:\n                raise IOError(err.args[0], '%s: %s.' % (err.args[1], errmsg))\n            raise\n\n        self.echo = bool(attr[3] & termios.ECHO)\n        return self.echo\n\n    def setecho(self, state):\n        '''Enable or disable terminal echo.\n\n        Anything the child sent before the echo will be lost, so you should be\n        sure that your input buffer is empty before you call setecho().\n        For example, the following will work as expected::\n\n            p = pexpect.spawn('cat') # Echo is on by default.\n            p.sendline('1234') # We expect see this twice from the child...\n            p.expect(['1234']) # ... once from the tty echo...\n            p.expect(['1234']) # ... and again from cat itself.\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n\n        The following WILL NOT WORK because the lines sent before the setecho\n        will be lost::\n\n            p = pexpect.spawn('cat')\n            p.sendline('1234')\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['1234'])\n            p.expect(['1234'])\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n\n\n        Not supported on platforms where ``isatty()`` returns False.\n        '''\n        _setecho(self.fd, state)\n\n        self.echo = state\n\n    def read(self, size=1024):\n        \"\"\"Read and return at most ``size`` bytes from the pty.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n        \n        Unlike Pexpect's ``read_nonblocking`` method, this doesn't try to deal\n        with the vagaries of EOF on platforms that do strange things, like IRIX\n        or older Solaris systems. It handles the errno=EIO pattern used on\n        Linux, and the empty-string return used on BSD platforms and (seemingly)\n        on recent Solaris.\n        \"\"\"\n        try:\n            s = self.fileobj.read1(size)\n        except (OSError, IOError) as err:\n            if err.args[0] == errno.EIO:\n                # Linux-style EOF\n                self.flag_eof = True\n                raise EOFError('End Of File (EOF). Exception style platform.')\n            raise\n        if s == b'':\n            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))\n            self.flag_eof = True\n            raise EOFError('End Of File (EOF). Empty string style platform.')\n\n        return s\n\n    def readline(self):\n        \"\"\"Read one line from the pseudoterminal, and return it as unicode.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n        \"\"\"\n        try:\n            s = self.fileobj.readline()\n        except (OSError, IOError) as err:\n            if err.args[0] == errno.EIO:\n                # Linux-style EOF\n                self.flag_eof = True\n                raise EOFError('End Of File (EOF). Exception style platform.')\n            raise\n        if s == b'':\n            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))\n            self.flag_eof = True\n            raise EOFError('End Of File (EOF). Empty string style platform.')\n\n        return s\n\n    def _writeb(self, b, flush=True):\n        n = self.fileobj.write(b)\n        if flush:\n            self.fileobj.flush()\n        return n\n\n    def write(self, s, flush=True):\n        \"\"\"Write bytes to the pseudoterminal.\n        \n        Returns the number of bytes written.\n        \"\"\"\n        return self._writeb(s, flush=flush)\n\n    def sendcontrol(self, char):\n        '''Helper method for sending control characters to the terminal.\n\n        For example, to send Ctrl-G (ASCII 7, bell, ``'\\\\a'``)::\n\n            child.sendcontrol('g')\n\n        See also, :meth:`sendintr` and :meth:`sendeof`.\n        '''\n        char = char.lower()\n        a = ord(char)\n        if 97 <= a <= 122:\n            a = a - ord('a') + 1\n            byte = _byte(a)\n            return self._writeb(byte), byte\n        d = {'@': 0, '`': 0,\n            '[': 27, '{': 27,\n            '\\\\': 28, '|': 28,\n            ']': 29, '}': 29,\n            '^': 30, '~': 30,\n            '_': 31,\n            '?': 127}\n        if char not in d:\n            return 0, b''\n\n        byte = _byte(d[char])\n        return self._writeb(byte), byte\n\n    def sendeof(self):\n        '''Sends an EOF (typically Ctrl-D) through the terminal.\n\n        This sends a character which causes\n        the pending parent output buffer to be sent to the waiting child\n        program without waiting for end-of-line. If it is the first character\n        of the line, the read() in the user program returns 0, which signifies\n        end-of-file. This means to work as expected a sendeof() has to be\n        called at the beginning of a line. This method does not send a newline.\n        It is the responsibility of the caller to ensure the eof is sent at the\n        beginning of a line.\n        '''\n        return self._writeb(_EOF), _EOF\n\n    def sendintr(self):\n        '''Send an interrupt character (typically Ctrl-C) through the terminal.\n\n        This will normally trigger the kernel to send SIGINT to the current\n        foreground process group. Processes can turn off this translation, in\n        which case they can read the raw data sent, e.g. ``b'\\\\x03'`` for Ctrl-C.\n\n        See also the :meth:`kill` method, which sends a signal directly to the\n        immediate child process in the terminal (which is not necessarily the\n        foreground process).\n        '''\n        return self._writeb(_INTR), _INTR\n\n    def eof(self):\n        '''This returns True if the EOF exception was ever raised.\n        '''\n\n        return self.flag_eof\n\n    def terminate(self, force=False):\n        '''This forces a child process to terminate. It starts nicely with\n        SIGHUP and SIGINT. If \"force\" is True then moves onto SIGKILL. This\n        returns True if the child was terminated. This returns False if the\n        child could not be terminated. '''\n\n        if not self.isalive():\n            return True\n        try:\n            self.kill(signal.SIGHUP)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGCONT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGINT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            if force:\n                self.kill(signal.SIGKILL)\n                time.sleep(self.delayafterterminate)\n                if not self.isalive():\n                    return True\n                else:\n                    return False\n            return False\n        except OSError:\n            # I think there are kernel timing issues that sometimes cause\n            # this to happen. I think isalive() reports True, but the\n            # process is dead to the kernel.\n            # Make one last attempt to see if the kernel is up to date.\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            else:\n                return False\n\n    def wait(self):\n        '''This waits until the child exits. This is a blocking call. This will\n        not read any data from the child, so this will block forever if the\n        child has unread output and has terminated. In other words, the child\n        may have printed output then called exit(), but, the child is\n        technically still alive until its output is read by the parent. '''\n\n        if self.isalive():\n            pid, status = os.waitpid(self.pid, 0)\n        else:\n            return self.exitstatus\n        self.exitstatus = os.WEXITSTATUS(status)\n        if os.WIFEXITED(status):\n            self.status = status\n            self.exitstatus = os.WEXITSTATUS(status)\n            self.signalstatus = None\n            self.terminated = True\n        elif os.WIFSIGNALED(status):\n            self.status = status\n            self.exitstatus = None\n            self.signalstatus = os.WTERMSIG(status)\n            self.terminated = True\n        elif os.WIFSTOPPED(status):  # pragma: no cover\n            # You can't call wait() on a child process in the stopped state.\n            raise PtyProcessError('Called wait() on a stopped child ' +\n                    'process. This is not supported. Is some other ' +\n                    'process attempting job control with our child pid?')\n        return self.exitstatus\n\n    def isalive(self):\n        '''This tests if the child process is running or not. This is\n        non-blocking. If the child was terminated then this will read the\n        exitstatus or signalstatus of the child. This returns True if the child\n        process appears to be running or False if not. It can take literally\n        SECONDS for Solaris to return the right status. '''\n\n        if self.terminated:\n            return False\n\n        if self.flag_eof:\n            # This is for Linux, which requires the blocking form\n            # of waitpid to get the status of a defunct process.\n            # This is super-lame. The flag_eof would have been set\n            # in read_nonblocking(), so this should be safe.\n            waitpid_options = 0\n        else:\n            waitpid_options = os.WNOHANG\n\n        try:\n            pid, status = os.waitpid(self.pid, waitpid_options)\n        except OSError as e:\n            # No child processes\n            if e.errno == errno.ECHILD:\n                raise PtyProcessError('isalive() encountered condition ' +\n                        'where \"terminated\" is 0, but there was no child ' +\n                        'process. Did someone else call waitpid() ' +\n                        'on our process?')\n            else:\n                raise\n\n        # I have to do this twice for Solaris.\n        # I can't even believe that I figured this out...\n        # If waitpid() returns 0 it means that no child process\n        # wishes to report, and the value of status is undefined.\n        if pid == 0:\n            try:\n                ### os.WNOHANG) # Solaris!\n                pid, status = os.waitpid(self.pid, waitpid_options)\n            except OSError as e:  # pragma: no cover\n                # This should never happen...\n                if e.errno == errno.ECHILD:\n                    raise PtyProcessError('isalive() encountered condition ' +\n                            'that should never happen. There was no child ' +\n                            'process. Did someone else call waitpid() ' +\n                            'on our process?')\n                else:\n                    raise\n\n            # If pid is still 0 after two calls to waitpid() then the process\n            # really is alive. This seems to work on all platforms, except for\n            # Irix which seems to require a blocking call on waitpid or select,\n            # so I let read_nonblocking take care of this situation\n            # (unfortunately, this requires waiting through the timeout).\n            if pid == 0:\n                return True\n\n        if pid == 0:\n            return True\n\n        if os.WIFEXITED(status):\n            self.status = status\n            self.exitstatus = os.WEXITSTATUS(status)\n            self.signalstatus = None\n            self.terminated = True\n        elif os.WIFSIGNALED(status):\n            self.status = status\n            self.exitstatus = None\n            self.signalstatus = os.WTERMSIG(status)\n            self.terminated = True\n        elif os.WIFSTOPPED(status):\n            raise PtyProcessError('isalive() encountered condition ' +\n                    'where child process is stopped. This is not ' +\n                    'supported. Is some other process attempting ' +\n                    'job control with our child pid?')\n        return False\n\n    def kill(self, sig):\n        \"\"\"Send the given signal to the child application.\n\n        In keeping with UNIX tradition it has a misleading name. It does not\n        necessarily kill the child unless you send the right signal. See the\n        :mod:`signal` module for constants representing signal numbers.\n        \"\"\"\n\n        # Same as os.kill, but the pid is given for you.\n        if self.isalive():\n            os.kill(self.pid, sig)\n\n    def getwinsize(self):\n        \"\"\"Return the window size of the pseudoterminal as a tuple (rows, cols).\n        \"\"\"\n        TIOCGWINSZ = getattr(termios, 'TIOCGWINSZ', 1074295912)\n        s = struct.pack('HHHH', 0, 0, 0, 0)\n        x = fcntl.ioctl(self.fd, TIOCGWINSZ, s)\n        return struct.unpack('HHHH', x)[0:2]\n\n    def setwinsize(self, rows, cols):\n        \"\"\"Set the terminal window size of the child tty.\n\n        This will cause a SIGWINCH signal to be sent to the child. This does not\n        change the physical window size. It changes the size reported to\n        TTY-aware applications like vi or curses -- applications that respond to\n        the SIGWINCH signal.\n        \"\"\"\n        return _setwinsize(self.fd, rows, cols)\n\n\nclass PtyProcessUnicode(PtyProcess):\n    \"\"\"Unicode wrapper around a process running in a pseudoterminal.\n\n    This class exposes a similar interface to :class:`PtyProcess`, but its read\n    methods return unicode, and its :meth:`write` accepts unicode.\n    \"\"\"\n    if PY3:\n        string_type = str\n    else:\n        string_type = unicode   # analysis:ignore\n\n    def __init__(self, pid, fd, encoding='utf-8', codec_errors='strict'):\n        super(PtyProcessUnicode, self).__init__(pid, fd)\n        self.encoding = encoding\n        self.codec_errors = codec_errors\n        self.decoder = codecs.getincrementaldecoder(encoding)(errors=codec_errors)\n\n    def read(self, size=1024):\n        \"\"\"Read at most ``size`` bytes from the pty, return them as unicode.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n\n        The size argument still refers to bytes, not unicode code points.\n        \"\"\"\n        b = super(PtyProcessUnicode, self).read(size)\n        return self.decoder.decode(b, final=False)\n\n    def readline(self):\n        \"\"\"Read one line from the pseudoterminal, and return it as unicode.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n        \"\"\"\n        b = super(PtyProcessUnicode, self).readline()\n        return self.decoder.decode(b, final=False)\n\n    def write(self, s):\n        \"\"\"Write the unicode string ``s`` to the pseudoterminal.\n\n        Returns the number of bytes written.\n        \"\"\"\n        b = s.encode(self.encoding)\n        return super(PtyProcessUnicode, self).write(b)\n", "ptyprocess/util.py": "try:\n    from shutil import which  # Python >= 3.3\nexcept ImportError:\n    import os, sys\n    \n    # This is copied from Python 3.4.1\n    def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n        \"\"\"Given a command, mode, and a PATH string, return the path which\n        conforms to the given mode on the PATH, or None if there is no such\n        file.\n    \n        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n        of os.environ.get(\"PATH\"), or can be overridden with a custom search\n        path.\n    \n        \"\"\"\n        # Check that a given file can be accessed with the correct mode.\n        # Additionally check that `file` is not a directory, as on Windows\n        # directories pass the os.access check.\n        def _access_check(fn, mode):\n            return (os.path.exists(fn) and os.access(fn, mode)\n                    and not os.path.isdir(fn))\n    \n        # If we're given a path with a directory part, look it up directly rather\n        # than referring to PATH directories. This includes checking relative to the\n        # current directory, e.g. ./script\n        if os.path.dirname(cmd):\n            if _access_check(cmd, mode):\n                return cmd\n            return None\n    \n        if path is None:\n            path = os.environ.get(\"PATH\", os.defpath)\n        if not path:\n            return None\n        path = path.split(os.pathsep)\n    \n        if sys.platform == \"win32\":\n            # The current directory takes precedence on Windows.\n            if not os.curdir in path:\n                path.insert(0, os.curdir)\n    \n            # PATHEXT is necessary to check on Windows.\n            pathext = os.environ.get(\"PATHEXT\", \"\").split(os.pathsep)\n            # See if the given file matches any of the expected path extensions.\n            # This will allow us to short circuit when given \"python.exe\".\n            # If it does match, only test that one, otherwise we have to try\n            # others.\n            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n                files = [cmd]\n            else:\n                files = [cmd + ext for ext in pathext]\n        else:\n            # On other platforms you don't have things like PATHEXT to tell you\n            # what file suffixes are executable, so just pass on cmd as-is.\n            files = [cmd]\n    \n        seen = set()\n        for dir in path:\n            normdir = os.path.normcase(dir)\n            if not normdir in seen:\n                seen.add(normdir)\n                for thefile in files:\n                    name = os.path.join(dir, thefile)\n                    if _access_check(name, mode):\n                        return name\n        return None\n\n\nclass PtyProcessError(Exception):\n    \"\"\"Generic error class for this package.\"\"\"\n", "ptyprocess/__init__.py": "\"\"\"Run a subprocess in a pseudo terminal\"\"\"\nfrom .ptyprocess import PtyProcess, PtyProcessUnicode, PtyProcessError\n\n__version__ = '0.7.0'\n", "ptyprocess/_fork_pty.py": "\"\"\"Substitute for the forkpty system call, to support Solaris.\n\"\"\"\nimport os\nimport errno\n\nfrom pty import (STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO, CHILD)\nfrom .util import PtyProcessError\n\ndef fork_pty():\n    '''This implements a substitute for the forkpty system call. This\n    should be more portable than the pty.fork() function. Specifically,\n    this should work on Solaris.\n\n    Modified 10.06.05 by Geoff Marshall: Implemented __fork_pty() method to\n    resolve the issue with Python's pty.fork() not supporting Solaris,\n    particularly ssh. Based on patch to posixmodule.c authored by Noah\n    Spurrier::\n\n        http://mail.python.org/pipermail/python-dev/2003-May/035281.html\n\n    '''\n\n    parent_fd, child_fd = os.openpty()\n    if parent_fd < 0 or child_fd < 0:\n        raise OSError(\"os.openpty() failed\")\n\n    pid = os.fork()\n    if pid == CHILD:\n        # Child.\n        os.close(parent_fd)\n        pty_make_controlling_tty(child_fd)\n\n        os.dup2(child_fd, STDIN_FILENO)\n        os.dup2(child_fd, STDOUT_FILENO)\n        os.dup2(child_fd, STDERR_FILENO)\n\n    else:\n        # Parent.\n        os.close(child_fd)\n\n    return pid, parent_fd\n\ndef pty_make_controlling_tty(tty_fd):\n    '''This makes the pseudo-terminal the controlling tty. This should be\n    more portable than the pty.fork() function. Specifically, this should\n    work on Solaris. '''\n\n    child_name = os.ttyname(tty_fd)\n\n    # Disconnect from controlling tty, if any.  Raises OSError of ENXIO\n    # if there was no controlling tty to begin with, such as when\n    # executed by a cron(1) job.\n    try:\n        fd = os.open(\"/dev/tty\", os.O_RDWR | os.O_NOCTTY)\n        os.close(fd)\n    except OSError as err:\n        if err.errno != errno.ENXIO:\n            raise\n\n    os.setsid()\n\n    # Verify we are disconnected from controlling tty by attempting to open\n    # it again.  We expect that OSError of ENXIO should always be raised.\n    try:\n        fd = os.open(\"/dev/tty\", os.O_RDWR | os.O_NOCTTY)\n        os.close(fd)\n        raise PtyProcessError(\"OSError of errno.ENXIO should be raised.\")\n    except OSError as err:\n        if err.errno != errno.ENXIO:\n            raise\n\n    # Verify we can open child pty.\n    fd = os.open(child_name, os.O_RDWR)\n    os.close(fd)\n\n    # Verify we now have a controlling tty.\n    fd = os.open(\"/dev/tty\", os.O_WRONLY)\n    os.close(fd)\n"}