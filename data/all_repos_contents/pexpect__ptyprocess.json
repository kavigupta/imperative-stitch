{"ptyprocess/ptyprocess.py": "import codecs\nimport errno\nimport fcntl\nimport io\nimport os\nimport pty\nimport resource\nimport signal\nimport struct\nimport sys\nimport termios\nimport time\n\ntry:\n    import builtins  # Python 3\nexcept ImportError:\n    import __builtin__ as builtins  # Python 2\n\n# Constants\nfrom pty import (STDIN_FILENO, CHILD)\n\nfrom .util import which, PtyProcessError\n\n_platform = sys.platform.lower()\n\n# Solaris uses internal __fork_pty(). All others use pty.fork().\n_is_solaris = (\n    _platform.startswith('solaris') or\n    _platform.startswith('sunos'))\n\nif _is_solaris:\n    use_native_pty_fork = False\n    from . import _fork_pty\nelse:\n    use_native_pty_fork = True\n\nPY3 = sys.version_info[0] >= 3\n\nif PY3:\n    def _byte(i):\n        return bytes([i])\nelse:\n    def _byte(i):\n        return chr(i)\n    \n    class FileNotFoundError(OSError): pass\n    class TimeoutError(OSError): pass\n\n_EOF, _INTR = None, None\n\ndef _make_eof_intr():\n    \"\"\"Set constants _EOF and _INTR.\n    \n    This avoids doing potentially costly operations on module load.\n    \"\"\"\n    global _EOF, _INTR\n    if (_EOF is not None) and (_INTR is not None):\n        return\n\n    # inherit EOF and INTR definitions from controlling process.\n    try:\n        from termios import VEOF, VINTR\n        fd = None\n        for name in 'stdin', 'stdout':\n            stream = getattr(sys, '__%s__' % name, None)\n            if stream is None or not hasattr(stream, 'fileno'):\n                continue\n            try:\n                fd = stream.fileno()\n            except ValueError:\n                continue\n        if fd is None:\n            # no fd, raise ValueError to fallback on CEOF, CINTR\n            raise ValueError(\"No stream has a fileno\")\n        intr = ord(termios.tcgetattr(fd)[6][VINTR])\n        eof = ord(termios.tcgetattr(fd)[6][VEOF])\n    except (ImportError, OSError, IOError, ValueError, termios.error):\n        # unless the controlling process is also not a terminal,\n        # such as cron(1), or when stdin and stdout are both closed.\n        # Fall-back to using CEOF and CINTR. There\n        try:\n            from termios import CEOF, CINTR\n            (intr, eof) = (CINTR, CEOF)\n        except ImportError:\n            #                         ^C, ^D\n            (intr, eof) = (3, 4)\n    \n    _INTR = _byte(intr)\n    _EOF = _byte(eof)\n\n# setecho and setwinsize are pulled out here because on some platforms, we need\n# to do this from the child before we exec()\n    \ndef _setecho(fd, state):\n    errmsg = 'setecho() may not be called on this platform (it may still be possible to enable/disable echo when spawning the child process)'\n\n    try:\n        attr = termios.tcgetattr(fd)\n    except termios.error as err:\n        if err.args[0] == errno.EINVAL:\n            raise IOError(err.args[0], '%s: %s.' % (err.args[1], errmsg))\n        raise\n\n    if state:\n        attr[3] = attr[3] | termios.ECHO\n    else:\n        attr[3] = attr[3] & ~termios.ECHO\n\n    try:\n        # I tried TCSADRAIN and TCSAFLUSH, but these were inconsistent and\n        # blocked on some platforms. TCSADRAIN would probably be ideal.\n        termios.tcsetattr(fd, termios.TCSANOW, attr)\n    except IOError as err:\n        if err.args[0] == errno.EINVAL:\n            raise IOError(err.args[0], '%s: %s.' % (err.args[1], errmsg))\n        raise\n\ndef _setwinsize(fd, rows, cols):\n    # Some very old platforms have a bug that causes the value for\n    # termios.TIOCSWINSZ to be truncated. There was a hack here to work\n    # around this, but it caused problems with newer platforms so has been\n    # removed. For details see https://github.com/pexpect/pexpect/issues/39\n    TIOCSWINSZ = getattr(termios, 'TIOCSWINSZ', -2146929561)\n    # Note, assume ws_xpixel and ws_ypixel are zero.\n    s = struct.pack('HHHH', rows, cols, 0, 0)\n    fcntl.ioctl(fd, TIOCSWINSZ, s)\n\nclass PtyProcess(object):\n    '''This class represents a process running in a pseudoterminal.\n    \n    The main constructor is the :meth:`spawn` classmethod.\n    '''\n    string_type = bytes\n    if PY3:\n        linesep = os.linesep.encode('ascii')\n        crlf = '\\r\\n'.encode('ascii')\n\n        @staticmethod\n        def write_to_stdout(b):\n            try:\n                return sys.stdout.buffer.write(b)\n            except AttributeError:\n                # If stdout has been replaced, it may not have .buffer\n                return sys.stdout.write(b.decode('ascii', 'replace'))\n    else:\n        linesep = os.linesep\n        crlf = '\\r\\n'\n        write_to_stdout = sys.stdout.write\n\n    encoding = None\n    \n    argv = None\n    env = None\n    launch_dir = None\n\n    def __init__(self, pid, fd):\n        _make_eof_intr()  # Ensure _EOF and _INTR are calculated\n        self.pid = pid\n        self.fd = fd\n        readf = io.open(fd, 'rb', buffering=0)\n        writef = io.open(fd, 'wb', buffering=0, closefd=False)\n        self.fileobj = io.BufferedRWPair(readf, writef)\n\n        self.terminated = False\n        self.closed = False\n        self.exitstatus = None\n        self.signalstatus = None\n        # status returned by os.waitpid\n        self.status = None\n        self.flag_eof = False\n        # Used by close() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterclose = 0.1\n        # Used by terminate() to give kernel time to update process status.\n        # Time in seconds.\n        self.delayafterterminate = 0.1\n\n    @classmethod\n    def spawn(\n            cls, argv, cwd=None, env=None, echo=True, preexec_fn=None,\n            dimensions=(24, 80), pass_fds=()):\n        '''Start the given command in a child process in a pseudo terminal.\n\n        This does all the fork/exec type of stuff for a pty, and returns an\n        instance of PtyProcess.\n\n        If preexec_fn is supplied, it will be called with no arguments in the\n        child process before exec-ing the specified command.\n        It may, for instance, set signal handlers to SIG_DFL or SIG_IGN.\n\n        Dimensions of the psuedoterminal used for the subprocess can be\n        specified as a tuple (rows, cols), or the default (24, 80) will be used.\n\n        By default, all file descriptors except 0, 1 and 2 are closed. This\n        behavior can be overridden with pass_fds, a list of file descriptors to\n        keep open between the parent and the child.\n        '''\n        # Note that it is difficult for this method to fail.\n        # You cannot detect if the child process cannot start.\n        # So the only way you can tell if the child process started\n        # or not is to try to read from the file descriptor. If you get\n        # EOF immediately then it means that the child is already dead.\n        # That may not necessarily be bad because you may have spawned a child\n        # that performs some task; creates no stdout output; and then dies.\n\n        if not isinstance(argv, (list, tuple)):\n            raise TypeError(\"Expected a list or tuple for argv, got %r\" % argv)\n\n        # Shallow copy of argv so we can modify it\n        argv = argv[:]\n        command = argv[0]\n\n        command_with_path = which(command)\n        if command_with_path is None:\n            raise FileNotFoundError('The command was not found or was not ' +\n                                    'executable: %s.' % command)\n        command = command_with_path\n        argv[0] = command\n\n        # [issue #119] To prevent the case where exec fails and the user is\n        # stuck interacting with a python child process instead of whatever\n        # was expected, we implement the solution from\n        # http://stackoverflow.com/a/3703179 to pass the exception to the\n        # parent process\n\n        # [issue #119] 1. Before forking, open a pipe in the parent process.\n        exec_err_pipe_read, exec_err_pipe_write = os.pipe()\n\n        if use_native_pty_fork:\n            pid, fd = pty.fork()\n        else:\n            # Use internal fork_pty, for Solaris\n            pid, fd = _fork_pty.fork_pty()\n\n        # Some platforms must call setwinsize() and setecho() from the\n        # child process, and others from the master process. We do both,\n        # allowing IOError for either.\n\n        if pid == CHILD:\n            # set window size\n            try:\n                _setwinsize(STDIN_FILENO, *dimensions)\n            except IOError as err:\n                if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                    raise\n\n            # disable echo if spawn argument echo was unset\n            if not echo:\n                try:\n                    _setecho(STDIN_FILENO, False)\n                except (IOError, termios.error) as err:\n                    if err.args[0] not in (errno.EINVAL, errno.ENOTTY):\n                        raise\n\n            # [issue #119] 3. The child closes the reading end and sets the\n            # close-on-exec flag for the writing end.\n            os.close(exec_err_pipe_read)\n            fcntl.fcntl(exec_err_pipe_write, fcntl.F_SETFD, fcntl.FD_CLOEXEC)\n\n            # Do not allow child to inherit open file descriptors from parent,\n            # with the exception of the exec_err_pipe_write of the pipe\n            # and pass_fds.\n            # Impose ceiling on max_fd: AIX bugfix for users with unlimited\n            # nofiles where resource.RLIMIT_NOFILE is 2^63-1 and os.closerange()\n            # occasionally raises out of range error\n            max_fd = min(1048576, resource.getrlimit(resource.RLIMIT_NOFILE)[0])\n            spass_fds = sorted(set(pass_fds) | {exec_err_pipe_write})\n            for pair in zip([2] + spass_fds, spass_fds + [max_fd]):\n                os.closerange(pair[0]+1, pair[1])\n\n            if cwd is not None:\n                os.chdir(cwd)\n\n            if preexec_fn is not None:\n                try:\n                    preexec_fn()\n                except Exception as e:\n                    ename = type(e).__name__\n                    tosend = '{}:0:{}'.format(ename, str(e))\n                    if PY3:\n                        tosend = tosend.encode('utf-8')\n\n                    os.write(exec_err_pipe_write, tosend)\n                    os.close(exec_err_pipe_write)\n                    os._exit(1)\n\n            try:\n                if env is None:\n                    os.execv(command, argv)\n                else:\n                    os.execvpe(command, argv, env)\n            except OSError as err:\n                # [issue #119] 5. If exec fails, the child writes the error\n                # code back to the parent using the pipe, then exits.\n                tosend = 'OSError:{}:{}'.format(err.errno, str(err))\n                if PY3:\n                    tosend = tosend.encode('utf-8')\n                os.write(exec_err_pipe_write, tosend)\n                os.close(exec_err_pipe_write)\n                os._exit(os.EX_OSERR)\n\n        # Parent\n        inst = cls(pid, fd)\n        \n        # Set some informational attributes\n        inst.argv = argv\n        if env is not None:\n            inst.env = env\n        if cwd is not None:\n            inst.launch_dir = cwd\n\n        # [issue #119] 2. After forking, the parent closes the writing end\n        # of the pipe and reads from the reading end.\n        os.close(exec_err_pipe_write)\n        exec_err_data = os.read(exec_err_pipe_read, 4096)\n        os.close(exec_err_pipe_read)\n\n        # [issue #119] 6. The parent reads eof (a zero-length read) if the\n        # child successfully performed exec, since close-on-exec made\n        # successful exec close the writing end of the pipe. Or, if exec\n        # failed, the parent reads the error code and can proceed\n        # accordingly. Either way, the parent blocks until the child calls\n        # exec.\n        if len(exec_err_data) != 0:\n            try:\n                errclass, errno_s, errmsg = exec_err_data.split(b':', 2)\n                exctype = getattr(builtins, errclass.decode('ascii'), Exception)\n\n                exception = exctype(errmsg.decode('utf-8', 'replace'))\n                if exctype is OSError:\n                    exception.errno = int(errno_s)\n            except:\n                raise Exception('Subprocess failed, got bad error data: %r'\n                                    % exec_err_data)\n            else:\n                raise exception\n\n        try:\n            inst.setwinsize(*dimensions)\n        except IOError as err:\n            if err.args[0] not in (errno.EINVAL, errno.ENOTTY, errno.ENXIO):\n                raise\n\n        return inst\n\n    def __repr__(self):\n        clsname = type(self).__name__\n        if self.argv is not None:\n            args = [repr(self.argv)]\n            if self.env is not None:\n                args.append(\"env=%r\" % self.env)\n            if self.launch_dir is not None:\n                args.append(\"cwd=%r\" % self.launch_dir)\n            \n            return \"{}.spawn({})\".format(clsname, \", \".join(args))\n        \n        else:\n            return \"{}(pid={}, fd={})\".format(clsname, self.pid, self.fd)\n\n    @staticmethod\n    def _coerce_send_string(s):\n        if not isinstance(s, bytes):\n            return s.encode('utf-8')\n        return s\n\n    @staticmethod\n    def _coerce_read_string(s):\n        return s\n\n    def __del__(self):\n        '''This makes sure that no system resources are left open. Python only\n        garbage collects Python objects. OS file descriptors are not Python\n        objects, so they must be handled explicitly. If the child file\n        descriptor was opened outside of this class (passed to the constructor)\n        then this does not close it. '''\n\n        if not self.closed:\n            # It is possible for __del__ methods to execute during the\n            # teardown of the Python VM itself. Thus self.close() may\n            # trigger an exception because os.close may be None.\n            try:\n                self.close()\n            # which exception, shouldn't we catch explicitly .. ?\n            except:\n                pass\n\n\n    def fileno(self):\n        '''This returns the file descriptor of the pty for the child.\n        '''\n        return self.fd\n\n    def close(self, force=True):\n        '''This closes the connection with the child application. Note that\n        calling close() more than once is valid. This emulates standard Python\n        behavior with files. Set force to True if you want to make sure that\n        the child is terminated (SIGKILL is sent if the child ignores SIGHUP\n        and SIGINT). '''\n        if not self.closed:\n            self.flush()\n            self.fileobj.close() # Closes the file descriptor\n            # Give kernel time to update process status.\n            time.sleep(self.delayafterclose)\n            if self.isalive():\n                if not self.terminate(force):\n                    raise PtyProcessError('Could not terminate the child.')\n            self.fd = -1\n            self.closed = True\n            #self.pid = None\n\n    def flush(self):\n        '''This does nothing. It is here to support the interface for a\n        File-like object. '''\n\n        pass\n\n    def isatty(self):\n        '''This returns True if the file descriptor is open and connected to a\n        tty(-like) device, else False.\n\n        On SVR4-style platforms implementing streams, such as SunOS and HP-UX,\n        the child pty may not appear as a terminal device.  This means\n        methods such as setecho(), setwinsize(), getwinsize() may raise an\n        IOError. '''\n\n        return os.isatty(self.fd)\n\n    def waitnoecho(self, timeout=None):\n        '''Wait until the terminal ECHO flag is set False.\n\n        This returns True if the echo mode is off, or False if echo was not\n        disabled before the timeout. This can be used to detect when the\n        child is waiting for a password. Usually a child application will turn\n        off echo mode when it is waiting for the user to enter a password. For\n        example, instead of expecting the \"password:\" prompt you can wait for\n        the child to turn echo off::\n\n            p = pexpect.spawn('ssh user@example.com')\n            p.waitnoecho()\n            p.sendline(mypassword)\n\n        If ``timeout=None`` then this method to block until ECHO flag is False.\n        '''\n\n        if timeout is not None:\n            end_time = time.time() + timeout\n        while True:\n            if not self.getecho():\n                return True\n            if timeout < 0 and timeout is not None:\n                return False\n            if timeout is not None:\n                timeout = end_time - time.time()\n            time.sleep(0.1)\n\n    def getecho(self):\n        '''Returns True if terminal echo is on, or False if echo is off.\n\n        Child applications that are expecting you to enter a password often\n        disable echo. See also :meth:`waitnoecho`.\n\n        Not supported on platforms where ``isatty()`` returns False.\n        '''\n\n        try:\n            attr = termios.tcgetattr(self.fd)\n        except termios.error as err:\n            errmsg = 'getecho() may not be called on this platform'\n            if err.args[0] == errno.EINVAL:\n                raise IOError(err.args[0], '%s: %s.' % (err.args[1], errmsg))\n            raise\n\n        self.echo = bool(attr[3] & termios.ECHO)\n        return self.echo\n\n    def setecho(self, state):\n        '''Enable or disable terminal echo.\n\n        Anything the child sent before the echo will be lost, so you should be\n        sure that your input buffer is empty before you call setecho().\n        For example, the following will work as expected::\n\n            p = pexpect.spawn('cat') # Echo is on by default.\n            p.sendline('1234') # We expect see this twice from the child...\n            p.expect(['1234']) # ... once from the tty echo...\n            p.expect(['1234']) # ... and again from cat itself.\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n\n        The following WILL NOT WORK because the lines sent before the setecho\n        will be lost::\n\n            p = pexpect.spawn('cat')\n            p.sendline('1234')\n            p.setecho(False) # Turn off tty echo\n            p.sendline('abcd') # We will set this only once (echoed by cat).\n            p.sendline('wxyz') # We will set this only once (echoed by cat)\n            p.expect(['1234'])\n            p.expect(['1234'])\n            p.expect(['abcd'])\n            p.expect(['wxyz'])\n\n\n        Not supported on platforms where ``isatty()`` returns False.\n        '''\n        _setecho(self.fd, state)\n\n        self.echo = state\n\n    def read(self, size=1024):\n        \"\"\"Read and return at most ``size`` bytes from the pty.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n        \n        Unlike Pexpect's ``read_nonblocking`` method, this doesn't try to deal\n        with the vagaries of EOF on platforms that do strange things, like IRIX\n        or older Solaris systems. It handles the errno=EIO pattern used on\n        Linux, and the empty-string return used on BSD platforms and (seemingly)\n        on recent Solaris.\n        \"\"\"\n        try:\n            s = self.fileobj.read1(size)\n        except (OSError, IOError) as err:\n            if err.args[0] == errno.EIO:\n                # Linux-style EOF\n                self.flag_eof = True\n                raise EOFError('End Of File (EOF). Exception style platform.')\n            raise\n        if s == b'':\n            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))\n            self.flag_eof = True\n            raise EOFError('End Of File (EOF). Empty string style platform.')\n\n        return s\n\n    def readline(self):\n        \"\"\"Read one line from the pseudoterminal, and return it as unicode.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n        \"\"\"\n        try:\n            s = self.fileobj.readline()\n        except (OSError, IOError) as err:\n            if err.args[0] == errno.EIO:\n                # Linux-style EOF\n                self.flag_eof = True\n                raise EOFError('End Of File (EOF). Exception style platform.')\n            raise\n        if s == b'':\n            # BSD-style EOF (also appears to work on recent Solaris (OpenIndiana))\n            self.flag_eof = True\n            raise EOFError('End Of File (EOF). Empty string style platform.')\n\n        return s\n\n    def _writeb(self, b, flush=True):\n        n = self.fileobj.write(b)\n        if flush:\n            self.fileobj.flush()\n        return n\n\n    def write(self, s, flush=True):\n        \"\"\"Write bytes to the pseudoterminal.\n        \n        Returns the number of bytes written.\n        \"\"\"\n        return self._writeb(s, flush=flush)\n\n    def sendcontrol(self, char):\n        '''Helper method for sending control characters to the terminal.\n\n        For example, to send Ctrl-G (ASCII 7, bell, ``'\\\\a'``)::\n\n            child.sendcontrol('g')\n\n        See also, :meth:`sendintr` and :meth:`sendeof`.\n        '''\n        char = char.lower()\n        a = ord(char)\n        if 97 <= a <= 122:\n            a = a - ord('a') + 1\n            byte = _byte(a)\n            return self._writeb(byte), byte\n        d = {'@': 0, '`': 0,\n            '[': 27, '{': 27,\n            '\\\\': 28, '|': 28,\n            ']': 29, '}': 29,\n            '^': 30, '~': 30,\n            '_': 31,\n            '?': 127}\n        if char not in d:\n            return 0, b''\n\n        byte = _byte(d[char])\n        return self._writeb(byte), byte\n\n    def sendeof(self):\n        '''Sends an EOF (typically Ctrl-D) through the terminal.\n\n        This sends a character which causes\n        the pending parent output buffer to be sent to the waiting child\n        program without waiting for end-of-line. If it is the first character\n        of the line, the read() in the user program returns 0, which signifies\n        end-of-file. This means to work as expected a sendeof() has to be\n        called at the beginning of a line. This method does not send a newline.\n        It is the responsibility of the caller to ensure the eof is sent at the\n        beginning of a line.\n        '''\n        return self._writeb(_EOF), _EOF\n\n    def sendintr(self):\n        '''Send an interrupt character (typically Ctrl-C) through the terminal.\n\n        This will normally trigger the kernel to send SIGINT to the current\n        foreground process group. Processes can turn off this translation, in\n        which case they can read the raw data sent, e.g. ``b'\\\\x03'`` for Ctrl-C.\n\n        See also the :meth:`kill` method, which sends a signal directly to the\n        immediate child process in the terminal (which is not necessarily the\n        foreground process).\n        '''\n        return self._writeb(_INTR), _INTR\n\n    def eof(self):\n        '''This returns True if the EOF exception was ever raised.\n        '''\n\n        return self.flag_eof\n\n    def terminate(self, force=False):\n        '''This forces a child process to terminate. It starts nicely with\n        SIGHUP and SIGINT. If \"force\" is True then moves onto SIGKILL. This\n        returns True if the child was terminated. This returns False if the\n        child could not be terminated. '''\n\n        if not self.isalive():\n            return True\n        try:\n            self.kill(signal.SIGHUP)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGCONT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            self.kill(signal.SIGINT)\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            if force:\n                self.kill(signal.SIGKILL)\n                time.sleep(self.delayafterterminate)\n                if not self.isalive():\n                    return True\n                else:\n                    return False\n            return False\n        except OSError:\n            # I think there are kernel timing issues that sometimes cause\n            # this to happen. I think isalive() reports True, but the\n            # process is dead to the kernel.\n            # Make one last attempt to see if the kernel is up to date.\n            time.sleep(self.delayafterterminate)\n            if not self.isalive():\n                return True\n            else:\n                return False\n\n    def wait(self):\n        '''This waits until the child exits. This is a blocking call. This will\n        not read any data from the child, so this will block forever if the\n        child has unread output and has terminated. In other words, the child\n        may have printed output then called exit(), but, the child is\n        technically still alive until its output is read by the parent. '''\n\n        if self.isalive():\n            pid, status = os.waitpid(self.pid, 0)\n        else:\n            return self.exitstatus\n        self.exitstatus = os.WEXITSTATUS(status)\n        if os.WIFEXITED(status):\n            self.status = status\n            self.exitstatus = os.WEXITSTATUS(status)\n            self.signalstatus = None\n            self.terminated = True\n        elif os.WIFSIGNALED(status):\n            self.status = status\n            self.exitstatus = None\n            self.signalstatus = os.WTERMSIG(status)\n            self.terminated = True\n        elif os.WIFSTOPPED(status):  # pragma: no cover\n            # You can't call wait() on a child process in the stopped state.\n            raise PtyProcessError('Called wait() on a stopped child ' +\n                    'process. This is not supported. Is some other ' +\n                    'process attempting job control with our child pid?')\n        return self.exitstatus\n\n    def isalive(self):\n        '''This tests if the child process is running or not. This is\n        non-blocking. If the child was terminated then this will read the\n        exitstatus or signalstatus of the child. This returns True if the child\n        process appears to be running or False if not. It can take literally\n        SECONDS for Solaris to return the right status. '''\n\n        if self.terminated:\n            return False\n\n        if self.flag_eof:\n            # This is for Linux, which requires the blocking form\n            # of waitpid to get the status of a defunct process.\n            # This is super-lame. The flag_eof would have been set\n            # in read_nonblocking(), so this should be safe.\n            waitpid_options = 0\n        else:\n            waitpid_options = os.WNOHANG\n\n        try:\n            pid, status = os.waitpid(self.pid, waitpid_options)\n        except OSError as e:\n            # No child processes\n            if e.errno == errno.ECHILD:\n                raise PtyProcessError('isalive() encountered condition ' +\n                        'where \"terminated\" is 0, but there was no child ' +\n                        'process. Did someone else call waitpid() ' +\n                        'on our process?')\n            else:\n                raise\n\n        # I have to do this twice for Solaris.\n        # I can't even believe that I figured this out...\n        # If waitpid() returns 0 it means that no child process\n        # wishes to report, and the value of status is undefined.\n        if pid == 0:\n            try:\n                ### os.WNOHANG) # Solaris!\n                pid, status = os.waitpid(self.pid, waitpid_options)\n            except OSError as e:  # pragma: no cover\n                # This should never happen...\n                if e.errno == errno.ECHILD:\n                    raise PtyProcessError('isalive() encountered condition ' +\n                            'that should never happen. There was no child ' +\n                            'process. Did someone else call waitpid() ' +\n                            'on our process?')\n                else:\n                    raise\n\n            # If pid is still 0 after two calls to waitpid() then the process\n            # really is alive. This seems to work on all platforms, except for\n            # Irix which seems to require a blocking call on waitpid or select,\n            # so I let read_nonblocking take care of this situation\n            # (unfortunately, this requires waiting through the timeout).\n            if pid == 0:\n                return True\n\n        if pid == 0:\n            return True\n\n        if os.WIFEXITED(status):\n            self.status = status\n            self.exitstatus = os.WEXITSTATUS(status)\n            self.signalstatus = None\n            self.terminated = True\n        elif os.WIFSIGNALED(status):\n            self.status = status\n            self.exitstatus = None\n            self.signalstatus = os.WTERMSIG(status)\n            self.terminated = True\n        elif os.WIFSTOPPED(status):\n            raise PtyProcessError('isalive() encountered condition ' +\n                    'where child process is stopped. This is not ' +\n                    'supported. Is some other process attempting ' +\n                    'job control with our child pid?')\n        return False\n\n    def kill(self, sig):\n        \"\"\"Send the given signal to the child application.\n\n        In keeping with UNIX tradition it has a misleading name. It does not\n        necessarily kill the child unless you send the right signal. See the\n        :mod:`signal` module for constants representing signal numbers.\n        \"\"\"\n\n        # Same as os.kill, but the pid is given for you.\n        if self.isalive():\n            os.kill(self.pid, sig)\n\n    def getwinsize(self):\n        \"\"\"Return the window size of the pseudoterminal as a tuple (rows, cols).\n        \"\"\"\n        TIOCGWINSZ = getattr(termios, 'TIOCGWINSZ', 1074295912)\n        s = struct.pack('HHHH', 0, 0, 0, 0)\n        x = fcntl.ioctl(self.fd, TIOCGWINSZ, s)\n        return struct.unpack('HHHH', x)[0:2]\n\n    def setwinsize(self, rows, cols):\n        \"\"\"Set the terminal window size of the child tty.\n\n        This will cause a SIGWINCH signal to be sent to the child. This does not\n        change the physical window size. It changes the size reported to\n        TTY-aware applications like vi or curses -- applications that respond to\n        the SIGWINCH signal.\n        \"\"\"\n        return _setwinsize(self.fd, rows, cols)\n\n\nclass PtyProcessUnicode(PtyProcess):\n    \"\"\"Unicode wrapper around a process running in a pseudoterminal.\n\n    This class exposes a similar interface to :class:`PtyProcess`, but its read\n    methods return unicode, and its :meth:`write` accepts unicode.\n    \"\"\"\n    if PY3:\n        string_type = str\n    else:\n        string_type = unicode   # analysis:ignore\n\n    def __init__(self, pid, fd, encoding='utf-8', codec_errors='strict'):\n        super(PtyProcessUnicode, self).__init__(pid, fd)\n        self.encoding = encoding\n        self.codec_errors = codec_errors\n        self.decoder = codecs.getincrementaldecoder(encoding)(errors=codec_errors)\n\n    def read(self, size=1024):\n        \"\"\"Read at most ``size`` bytes from the pty, return them as unicode.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n\n        The size argument still refers to bytes, not unicode code points.\n        \"\"\"\n        b = super(PtyProcessUnicode, self).read(size)\n        return self.decoder.decode(b, final=False)\n\n    def readline(self):\n        \"\"\"Read one line from the pseudoterminal, and return it as unicode.\n\n        Can block if there is nothing to read. Raises :exc:`EOFError` if the\n        terminal was closed.\n        \"\"\"\n        b = super(PtyProcessUnicode, self).readline()\n        return self.decoder.decode(b, final=False)\n\n    def write(self, s):\n        \"\"\"Write the unicode string ``s`` to the pseudoterminal.\n\n        Returns the number of bytes written.\n        \"\"\"\n        b = s.encode(self.encoding)\n        return super(PtyProcessUnicode, self).write(b)\n", "ptyprocess/util.py": "try:\n    from shutil import which  # Python >= 3.3\nexcept ImportError:\n    import os, sys\n    \n    # This is copied from Python 3.4.1\n    def which(cmd, mode=os.F_OK | os.X_OK, path=None):\n        \"\"\"Given a command, mode, and a PATH string, return the path which\n        conforms to the given mode on the PATH, or None if there is no such\n        file.\n    \n        `mode` defaults to os.F_OK | os.X_OK. `path` defaults to the result\n        of os.environ.get(\"PATH\"), or can be overridden with a custom search\n        path.\n    \n        \"\"\"\n        # Check that a given file can be accessed with the correct mode.\n        # Additionally check that `file` is not a directory, as on Windows\n        # directories pass the os.access check.\n        def _access_check(fn, mode):\n            return (os.path.exists(fn) and os.access(fn, mode)\n                    and not os.path.isdir(fn))\n    \n        # If we're given a path with a directory part, look it up directly rather\n        # than referring to PATH directories. This includes checking relative to the\n        # current directory, e.g. ./script\n        if os.path.dirname(cmd):\n            if _access_check(cmd, mode):\n                return cmd\n            return None\n    \n        if path is None:\n            path = os.environ.get(\"PATH\", os.defpath)\n        if not path:\n            return None\n        path = path.split(os.pathsep)\n    \n        if sys.platform == \"win32\":\n            # The current directory takes precedence on Windows.\n            if not os.curdir in path:\n                path.insert(0, os.curdir)\n    \n            # PATHEXT is necessary to check on Windows.\n            pathext = os.environ.get(\"PATHEXT\", \"\").split(os.pathsep)\n            # See if the given file matches any of the expected path extensions.\n            # This will allow us to short circuit when given \"python.exe\".\n            # If it does match, only test that one, otherwise we have to try\n            # others.\n            if any(cmd.lower().endswith(ext.lower()) for ext in pathext):\n                files = [cmd]\n            else:\n                files = [cmd + ext for ext in pathext]\n        else:\n            # On other platforms you don't have things like PATHEXT to tell you\n            # what file suffixes are executable, so just pass on cmd as-is.\n            files = [cmd]\n    \n        seen = set()\n        for dir in path:\n            normdir = os.path.normcase(dir)\n            if not normdir in seen:\n                seen.add(normdir)\n                for thefile in files:\n                    name = os.path.join(dir, thefile)\n                    if _access_check(name, mode):\n                        return name\n        return None\n\n\nclass PtyProcessError(Exception):\n    \"\"\"Generic error class for this package.\"\"\"\n", "ptyprocess/__init__.py": "\"\"\"Run a subprocess in a pseudo terminal\"\"\"\nfrom .ptyprocess import PtyProcess, PtyProcessUnicode, PtyProcessError\n\n__version__ = '0.7.0'\n", "ptyprocess/_fork_pty.py": "\"\"\"Substitute for the forkpty system call, to support Solaris.\n\"\"\"\nimport os\nimport errno\n\nfrom pty import (STDIN_FILENO, STDOUT_FILENO, STDERR_FILENO, CHILD)\nfrom .util import PtyProcessError\n\ndef fork_pty():\n    '''This implements a substitute for the forkpty system call. This\n    should be more portable than the pty.fork() function. Specifically,\n    this should work on Solaris.\n\n    Modified 10.06.05 by Geoff Marshall: Implemented __fork_pty() method to\n    resolve the issue with Python's pty.fork() not supporting Solaris,\n    particularly ssh. Based on patch to posixmodule.c authored by Noah\n    Spurrier::\n\n        http://mail.python.org/pipermail/python-dev/2003-May/035281.html\n\n    '''\n\n    parent_fd, child_fd = os.openpty()\n    if parent_fd < 0 or child_fd < 0:\n        raise OSError(\"os.openpty() failed\")\n\n    pid = os.fork()\n    if pid == CHILD:\n        # Child.\n        os.close(parent_fd)\n        pty_make_controlling_tty(child_fd)\n\n        os.dup2(child_fd, STDIN_FILENO)\n        os.dup2(child_fd, STDOUT_FILENO)\n        os.dup2(child_fd, STDERR_FILENO)\n\n    else:\n        # Parent.\n        os.close(child_fd)\n\n    return pid, parent_fd\n\ndef pty_make_controlling_tty(tty_fd):\n    '''This makes the pseudo-terminal the controlling tty. This should be\n    more portable than the pty.fork() function. Specifically, this should\n    work on Solaris. '''\n\n    child_name = os.ttyname(tty_fd)\n\n    # Disconnect from controlling tty, if any.  Raises OSError of ENXIO\n    # if there was no controlling tty to begin with, such as when\n    # executed by a cron(1) job.\n    try:\n        fd = os.open(\"/dev/tty\", os.O_RDWR | os.O_NOCTTY)\n        os.close(fd)\n    except OSError as err:\n        if err.errno != errno.ENXIO:\n            raise\n\n    os.setsid()\n\n    # Verify we are disconnected from controlling tty by attempting to open\n    # it again.  We expect that OSError of ENXIO should always be raised.\n    try:\n        fd = os.open(\"/dev/tty\", os.O_RDWR | os.O_NOCTTY)\n        os.close(fd)\n        raise PtyProcessError(\"OSError of errno.ENXIO should be raised.\")\n    except OSError as err:\n        if err.errno != errno.ENXIO:\n            raise\n\n    # Verify we can open child pty.\n    fd = os.open(child_name, os.O_RDWR)\n    os.close(fd)\n\n    # Verify we now have a controlling tty.\n    fd = os.open(\"/dev/tty\", os.O_WRONLY)\n    os.close(fd)\n", "docs/conf.py": "# -*- coding: utf-8 -*-\n#\n# Ptyprocess documentation build configuration file, created by\n# sphinx-quickstart on Mon Oct 13 11:03:02 2014.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\nimport sys\nimport os\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\nsys.path.insert(0, os.path.abspath('..'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#needs_sphinx = '1.0'\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    'sphinx.ext.autodoc',\n    'sphinx.ext.intersphinx',\n    'sphinx.ext.viewcode',\n]\n\n# Add any paths that contain templates here, relative to this directory.\ntemplates_path = ['_templates']\n\n# The suffix of source filenames.\nsource_suffix = '.rst'\n\n# The encoding of source files.\n#source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = 'index'\n\n# General information about the project.\nproject = u'Ptyprocess'\ncopyright = u'2014, Thomas Kluyver'\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = '0.7'\n# The full version, including alpha/beta/rc tags.\nrelease = version #+ '.2'\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#language = None\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#today = ''\n# Else, today_fmt is used as the format for a strftime call.\n#today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = ['_build']\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = 'sphinx'\n\n# A list of ignored prefixes for module index sorting.\n#modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n#keep_warnings = False\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\nhtml_theme = 'default'\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n#html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n#html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#html_logo = None\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = ['_static']\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#html_extra_path = []\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n#html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#html_additional_pages = {}\n\n# If false, no module index is generated.\n#html_domain_indices = True\n\n# If false, no index is generated.\n#html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n#html_file_suffix = None\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = 'Ptyprocessdoc'\n\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n# The paper size ('letterpaper' or 'a4paper').\n#'papersize': 'letterpaper',\n\n# The font size ('10pt', '11pt' or '12pt').\n#'pointsize': '10pt',\n\n# Additional stuff for the LaTeX preamble.\n#'preamble': '',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n  ('index', 'Ptyprocess.tex', u'Ptyprocess Documentation',\n   u'Thomas Kluyver', 'manual'),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#latex_use_parts = False\n\n# If true, show page references after internal links.\n#latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#latex_appendices = []\n\n# If false, no module index is generated.\n#latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    ('index', 'ptyprocess', u'Ptyprocess Documentation',\n     [u'Thomas Kluyver'], 1)\n]\n\n# If true, show URL addresses after external links.\n#man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n  ('index', 'Ptyprocess', u'Ptyprocess Documentation',\n   u'Thomas Kluyver', 'Ptyprocess', 'One line description of project.',\n   'Miscellaneous'),\n]\n\n# Documents to append as an appendix to all manuals.\n#texinfo_appendices = []\n\n# If false, no module index is generated.\n#texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#texinfo_no_detailmenu = False\n\n\n# Example configuration for intersphinx: refer to the Python standard library.\nintersphinx_mapping = {'http://docs.python.org/': None}\n", "tests/test_preexec_fn.py": "#!/usr/bin/env python\n'''\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\nimport unittest\nimport shutil\nfrom ptyprocess import PtyProcess\nimport os\nimport tempfile\n\nclass PreexecFns(unittest.TestCase):\n    def test_preexec(self):\n        td = tempfile.mkdtemp()\n        filepath = os.path.join(td, 'foo')\n        def pef():\n            with open(filepath, 'w') as f:\n                f.write('bar')\n\n        try:\n            child = PtyProcess.spawn(['ls'], preexec_fn=pef)\n            child.close()\n            with open(filepath, 'r') as f:\n                assert f.read() == 'bar'\n\n        finally:\n            shutil.rmtree(td)\n\n    def test_preexec_error(self):\n        def func():\n            raise ValueError(\"Test error condition\")\n\n        try:\n            child = PtyProcess.spawn(['ls'], preexec_fn=func)\n            # If we get here then an error was not raised\n            child.close()\n            raise AssertionError(\"ValueError was not raised\")\n        except ValueError as err:\n            if str(err) != \"Test error condition\":\n                # Re-raise the original error to fail the test\n                raise\n\n\n", "tests/test_invalid_binary.py": "#!/usr/bin/env python\n'''\nPEXPECT LICENSE\n\n    This license is approved by the OSI and FSF as GPL-compatible.\n        http://opensource.org/licenses/isc-license.txt\n\n    Copyright (c) 2012, Noah Spurrier <noah@noah.org>\n    PERMISSION TO USE, COPY, MODIFY, AND/OR DISTRIBUTE THIS SOFTWARE FOR ANY\n    PURPOSE WITH OR WITHOUT FEE IS HEREBY GRANTED, PROVIDED THAT THE ABOVE\n    COPYRIGHT NOTICE AND THIS PERMISSION NOTICE APPEAR IN ALL COPIES.\n    THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n    WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n    MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n    ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n    WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n    ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n    OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\n'''\nimport time\nimport unittest\nfrom ptyprocess import PtyProcess, PtyProcessUnicode\nimport errno\nimport os\nimport stat\nimport tempfile\n\nclass InvalidBinaryChars(unittest.TestCase):\n\n    def test_invalid_binary(self):\n        '''This tests that we correctly handle the case where we attempt to\n           spawn a child process but the exec call fails'''\n\n        # Create a file that should fail the exec call\n        dirpath = tempfile.mkdtemp()\n        fullpath = os.path.join(dirpath, \"test\")\n\n        with open(fullpath, 'wb') as f:\n            # Add some constant so it will never be executable\n            #  - Not 0x54AD (Windows PE)\n            #  - Not 0x7FEF (ELF)\n            #  - Not 0410 or 0413 (a.out)\n            #  - Not 0x2321 (script)\n            file_start = b'\\x00\\x00'\n            file_data = file_start + os.urandom(1022)\n            f.write(file_data)\n\n        # Make it executable\n        st = os.stat(fullpath)\n        os.chmod(fullpath, st.st_mode | stat.S_IEXEC)\n\n        # TODO Verify this does what is intended on Windows\n        try:\n            child = PtyProcess.spawn([fullpath])\n            # If we get here then an OSError was not raised\n            child.close()\n            raise AssertionError(\"OSError was not raised\")\n        except OSError as err:\n            if errno.ENOEXEC == err.errno:\n                # This is what should happen\n                pass\n            else:\n                # Re-raise the original error to fail the test\n                raise\n        finally:\n            os.unlink(fullpath)\n            os.rmdir(dirpath)\n\nif __name__ == '__main__':\n    unittest.main()\n", "tests/test_spawn.py": "import fcntl\nimport os\nimport time\nimport select\nimport tempfile\nimport unittest\nfrom ptyprocess.ptyprocess import which\nfrom ptyprocess import PtyProcess, PtyProcessUnicode\n\nclass PtyTestCase(unittest.TestCase):\n    def setUp(self):\n        self.cmd = u'echo $ENV_KEY; exit 0\\n'\n        self.env = os.environ.copy()\n        self.env_key = u'ENV_KEY'\n        self.env_value = u'env_value'\n        self.env[self.env_key] = self.env_value\n\n    def _canread(self, fd, timeout=1):\n        return fd in select.select([fd], [], [], timeout)[0]\n\n    def _spawn_sh(self, ptyp, cmd, outp, env_value):\n        # given,\n        p = ptyp.spawn(['sh'], env=self.env)\n        p.write(cmd)\n\n        # exercise,\n        while True:\n            try:\n                outp += p.read()\n            except EOFError:\n                break\n\n        # verify, input is echo to output\n        assert cmd.strip() in outp\n\n        # result of echo $ENV_KEY in output\n        assert env_value in outp\n\n        # exit successfully (exit 0)\n        assert p.wait() == 0\n\n\n    def test_spawn_sh(self):\n        outp = b''\n        self._spawn_sh(PtyProcess, self.cmd.encode('ascii'),\n                       outp, self.env_value.encode('ascii'))\n\n    def test_spawn_sh_unicode(self):\n        outp = u''\n        self._spawn_sh(PtyProcessUnicode, self.cmd,\n                       outp, self.env_value)\n\n    def test_quick_spawn(self):\n        \"\"\"Spawn a very short-lived process.\"\"\"\n        # so far only reproducible on Solaris 11, spawning a process\n        # that exits very quickly raised an exception at 'inst.setwinsize',\n        # because the pty file descriptor was quickly lost after exec().\n        PtyProcess.spawn(['true'])\n\n    def _interactive_repl_unicode(self, echo):\n        \"\"\"Test Call and response with echo ON/OFF.\"\"\"\n        # given,\n        bc = PtyProcessUnicode.spawn(['bc'], echo=echo)\n        given_input = u'2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2\\n'\n        expected_output = u'40'\n\n        # gnu-bc will display a long FSF banner on startup,\n        # whereas bsd-bc (on FreeBSD, Solaris) display no\n        # banner at all.  To ensure we've read up to our\n        # current prompt, read until the response of '2^16' is found.\n        time.sleep(1)\n\n        bc.write(u'2^16\\n')\n        outp = u''\n        while self._canread(bc.fd):\n            outp += bc.read()\n        assert u'65536' in outp\n\n        # exercise,\n        bc.write(given_input)\n\n        while self._canread(bc.fd, timeout=2):\n            outp += bc.read()\n\n        # with echo ON, we should see our input.\n        #\n        # note: we cannot assert the reverse: on Solaris, FreeBSD,\n        # and OSX, our input is echoed to output even with echo=False,\n        # something to do with the non-gnu version of bc(1), perhaps.\n        if echo:\n            assert given_input.strip() in outp\n\n        # we should most certainly see the result output.\n        assert expected_output in outp\n\n        # exercise sending EOF\n        bc.sendeof()\n\n        # validate EOF on read\n        while True:\n            try:\n                bc.read()\n            except EOFError:\n                break\n\n        # validate exit status,\n        assert bc.wait() == 0\n\n    @unittest.skipIf(which('bc') is None, \"bc(1) not found on this server.\")\n    def test_interactive_repl_unicode_noecho(self):\n        self._interactive_repl_unicode(echo=False)\n\n    @unittest.skipIf(which('bc') is None, \"bc(1) not found on this server.\")\n    def test_interactive_repl_unicode_echo(self):\n        self._interactive_repl_unicode(echo=True)\n\n    def test_pass_fds(self):\n        with tempfile.NamedTemporaryFile() as temp_file:\n            temp_file_fd = temp_file.fileno()\n            temp_file_name = temp_file.name\n\n            # Temporary files are CLOEXEC by default\n            fcntl.fcntl(temp_file_fd,\n                        fcntl.F_SETFD,\n                        fcntl.fcntl(temp_file_fd, fcntl.F_GETFD) &\n                        ~fcntl.FD_CLOEXEC)\n\n            # You can write with pass_fds\n            p = PtyProcess.spawn(['bash',\n                                  '-c',\n                                  'printf hello >&{}'.format(temp_file_fd)],\n                                 echo=True,\n                                 pass_fds=(temp_file_fd,))\n            p.wait()\n            assert p.status == 0\n\n            with open(temp_file_name, 'r') as temp_file_r:\n                assert temp_file_r.read() == 'hello'\n\n            # You can't write without pass_fds\n            p = PtyProcess.spawn(['bash',\n                                  '-c',\n                                  'printf bye >&{}'.format(temp_file_fd)],\n                                 echo=True)\n            p.read() # Read error off child to allow it to terminate nicely\n            p.wait()\n            assert p.status != 0\n\n            with open(temp_file_name, 'r') as temp_file_r:\n                assert temp_file_r.read() == 'hello'\n", "tests/__init__.py": "", "tests/test_echo.py": "import time\nimport unittest\nfrom ptyprocess.ptyprocess import _is_solaris\nfrom ptyprocess import PtyProcess\n\nclass PtyEchoTestCase(unittest.TestCase):\n\n    def _read_until_eof(self, proc):\n        \"\"\"Read away all output on ``proc`` until EOF.\"\"\"\n        while True:\n            try:\n                proc.read()\n            except EOFError:\n                return\n\n    @unittest.skipIf(_is_solaris, \"waitnoecho cannot be called on this platform.\")\n    def test_waitnoecho_forever(self):\n        \"\"\"Ensure waitnoecho() with no timeout will return when echo=False.\"\"\"\n        cat = PtyProcess.spawn(['cat'], echo=False)\n        assert cat.waitnoecho() == True\n        assert cat.echo == False\n        assert cat.getecho() == False\n        cat.sendeof()\n        self._read_until_eof(cat)\n        assert cat.wait() == 0\n\n    @unittest.skipIf(_is_solaris, \"waitnoecho cannot be called on this platform.\")\n    def test_waitnoecho_timeout(self):\n        \"\"\"Ensure waitnoecho() with timeout will return when using stty to unset echo.\"\"\"\n        cat = PtyProcess.spawn(['cat'], echo=True)\n        assert cat.waitnoecho(timeout=1) == False\n        assert cat.echo == True\n        assert cat.getecho() == True\n        cat.sendeof()\n        self._read_until_eof(cat)\n        assert cat.wait() == 0\n", "tests/test_wait.py": "\"\"\" Test cases for PtyProcess.wait method. \"\"\"\nimport time\nimport unittest\nfrom ptyprocess import PtyProcess\n\n\nclass TestWaitAfterTermination(unittest.TestCase):\n    \"\"\"Various test cases for PtyProcess.wait()\"\"\"\n\n    def test_wait_true_shortproc(self):\n        \"\"\"Ensure correct (True) wait status for short-lived processes.\"\"\"\n        child = PtyProcess.spawn(['true'])\n        # Wait so we're reasonable sure /bin/true has terminated\n        time.sleep(0.2)\n        self.assertEqual(child.wait(), 0)\n\n    def test_wait_false_shortproc(self):\n        \"\"\"Ensure correct (False) wait status for short-lived processes.\"\"\"\n        child = PtyProcess.spawn(['false'])\n        # Wait so we're reasonable sure /bin/false has terminated\n        time.sleep(0.2)\n        self.assertNotEqual(child.wait(), 0)\n\n    def test_wait_twice_longproc(self):\n        \"\"\"Ensure correct wait status when called twice.\"\"\"\n        # previous versions of ptyprocess raises PtyProcessError when\n        # wait was called more than once with \"Cannot wait for dead child\n        # process.\".  No longer true since v0.5.\n        child = PtyProcess.spawn(['sleep', '1'])\n        # this call to wait() will block for 1s\n        for count in range(2):\n            self.assertEqual(child.wait(), 0, count)\n"}