{"setup.py": "#!/usr/bin/env python\nimport os\nfrom setuptools import setup\n\n\ndef read(*rnames):\n    with open(os.path.join(os.path.dirname(__file__), *rnames)) as read_file:\n        return read_file.read()\n\n\nsetup(\n    name=\"isodate\",\n    version=\"0.7.0.dev0\",\n    packages=[\"isodate\", \"isodate.tests\"],\n    package_dir={\"\": \"src\"},\n    # PyPI metadata\n    author=\"Gerhard Weis\",\n    author_email=\"gerhard.weis@proclos.com\",\n    description=\"An ISO 8601 date/time/duration parser and formatter\",\n    license=\"BSD-3-Clause\",\n    license_files=(\"LICENSE\",),\n    # keywords = '',\n    url=\"https://github.com/gweis/isodate/\",\n    long_description=(read(\"README.rst\") + read(\"CHANGES.txt\") + read(\"TODO.txt\")),\n    python_requires=\">=3.7\",\n    classifiers=[\n        \"Development Status :: 4 - Beta\",\n        # 'Environment :: Web Environment',\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: BSD License\",\n        \"Operating System :: OS Independent\",\n        \"Programming Language :: Python\",\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: Implementation :: PyPy\",\n        \"Topic :: Internet\",\n        \"Topic :: Software Development :: Libraries :: Python Modules\",\n    ],\n    test_suite=\"isodate.tests.test_suite\",\n)\n", "src/isodate/isodatetime.py": "\"\"\"\nThis module defines a method to parse an ISO 8601:2004 date time string.\n\nFor this job it uses the parse_date and parse_time methods defined in date\nand time module.\n\"\"\"\nfrom datetime import datetime\n\nfrom isodate.isostrf import strftime\nfrom isodate.isostrf import DATE_EXT_COMPLETE, TIME_EXT_COMPLETE, TZ_EXT\nfrom isodate.isodates import parse_date\nfrom isodate.isoerror import ISO8601Error\nfrom isodate.isotime import parse_time\n\n\ndef parse_datetime(datetimestring):\n    \"\"\"\n    Parses ISO 8601 date-times into datetime.datetime objects.\n\n    This function uses parse_date and parse_time to do the job, so it allows\n    more combinations of date and time representations, than the actual\n    ISO 8601:2004 standard allows.\n    \"\"\"\n    try:\n        datestring, timestring = datetimestring.split(\"T\")\n    except ValueError:\n        raise ISO8601Error(\n            \"ISO 8601 time designator 'T' missing. Unable to\"\n            \" parse datetime string %r\" % datetimestring\n        )\n    tmpdate = parse_date(datestring)\n    tmptime = parse_time(timestring)\n    return datetime.combine(tmpdate, tmptime)\n\n\ndef datetime_isoformat(\n    tdt, format=DATE_EXT_COMPLETE + \"T\" + TIME_EXT_COMPLETE + TZ_EXT\n):\n    \"\"\"\n    Format datetime strings.\n\n    This method is just a wrapper around isodate.isostrf.strftime and uses\n    Extended-Complete as default format.\n    \"\"\"\n    return strftime(tdt, format)\n", "src/isodate/isoerror.py": "\"\"\"\nThis module defines all exception classes in the whole package.\n\"\"\"\n\n\nclass ISO8601Error(ValueError):\n    \"\"\"Raised when the given ISO string can not be parsed.\"\"\"\n", "src/isodate/isostrf.py": "\"\"\"\nThis module provides an alternative strftime method.\n\nThe strftime method in this module allows only a subset of Python's strftime\nformat codes, plus a few additional. It supports the full range of date values\npossible with standard Python date/time objects. Furthermore there are several\npr-defined format strings in this module to make ease producing of ISO 8601\nconforming strings.\n\"\"\"\nimport re\nfrom datetime import date, timedelta\n\nfrom isodate.duration import Duration\nfrom isodate.isotzinfo import tz_isoformat\n\n# Date specific format strings\nDATE_BAS_COMPLETE = \"%Y%m%d\"\nDATE_EXT_COMPLETE = \"%Y-%m-%d\"\nDATE_BAS_WEEK_COMPLETE = \"%YW%W%w\"\nDATE_EXT_WEEK_COMPLETE = \"%Y-W%W-%w\"\nDATE_BAS_ORD_COMPLETE = \"%Y%j\"\nDATE_EXT_ORD_COMPLETE = \"%Y-%j\"\nDATE_BAS_WEEK = \"%YW%W\"\nDATE_EXT_WEEK = \"%Y-W%W\"\nDATE_BAS_MONTH = \"%Y%m\"\nDATE_EXT_MONTH = \"%Y-%m\"\nDATE_YEAR = \"%Y\"\nDATE_CENTURY = \"%C\"\n\n# Time specific format strings\nTIME_BAS_COMPLETE = \"%H%M%S\"\nTIME_EXT_COMPLETE = \"%H:%M:%S\"\nTIME_BAS_MINUTE = \"%H%M\"\nTIME_EXT_MINUTE = \"%H:%M\"\nTIME_HOUR = \"%H\"\n\n# Time zone formats\nTZ_BAS = \"%z\"\nTZ_EXT = \"%Z\"\nTZ_HOUR = \"%h\"\n\n# DateTime formats\nDT_EXT_COMPLETE = DATE_EXT_COMPLETE + \"T\" + TIME_EXT_COMPLETE + TZ_EXT\nDT_BAS_COMPLETE = DATE_BAS_COMPLETE + \"T\" + TIME_BAS_COMPLETE + TZ_BAS\nDT_EXT_ORD_COMPLETE = DATE_EXT_ORD_COMPLETE + \"T\" + TIME_EXT_COMPLETE + TZ_EXT\nDT_BAS_ORD_COMPLETE = DATE_BAS_ORD_COMPLETE + \"T\" + TIME_BAS_COMPLETE + TZ_BAS\nDT_EXT_WEEK_COMPLETE = DATE_EXT_WEEK_COMPLETE + \"T\" + TIME_EXT_COMPLETE + TZ_EXT\nDT_BAS_WEEK_COMPLETE = DATE_BAS_WEEK_COMPLETE + \"T\" + TIME_BAS_COMPLETE + TZ_BAS\n\n# Duration formts\nD_DEFAULT = \"P%P\"\nD_WEEK = \"P%p\"\nD_ALT_EXT = \"P\" + DATE_EXT_COMPLETE + \"T\" + TIME_EXT_COMPLETE\nD_ALT_BAS = \"P\" + DATE_BAS_COMPLETE + \"T\" + TIME_BAS_COMPLETE\nD_ALT_EXT_ORD = \"P\" + DATE_EXT_ORD_COMPLETE + \"T\" + TIME_EXT_COMPLETE\nD_ALT_BAS_ORD = \"P\" + DATE_BAS_ORD_COMPLETE + \"T\" + TIME_BAS_COMPLETE\n\nSTRF_DT_MAP = {\n    \"%d\": lambda tdt, yds: \"%02d\" % tdt.day,\n    \"%f\": lambda tdt, yds: \"%06d\" % tdt.microsecond,\n    \"%H\": lambda tdt, yds: \"%02d\" % tdt.hour,\n    \"%j\": lambda tdt, yds: \"%03d\"\n    % (tdt.toordinal() - date(tdt.year, 1, 1).toordinal() + 1),\n    \"%m\": lambda tdt, yds: \"%02d\" % tdt.month,\n    \"%M\": lambda tdt, yds: \"%02d\" % tdt.minute,\n    \"%S\": lambda tdt, yds: \"%02d\" % tdt.second,\n    \"%w\": lambda tdt, yds: \"%1d\" % tdt.isoweekday(),\n    \"%W\": lambda tdt, yds: \"%02d\" % tdt.isocalendar()[1],\n    \"%Y\": lambda tdt, yds: (((yds != 4) and \"+\") or \"\") + ((\"%%0%dd\" % yds) % tdt.year),\n    \"%C\": lambda tdt, yds: (((yds != 4) and \"+\") or \"\")\n    + ((\"%%0%dd\" % (yds - 2)) % (tdt.year / 100)),\n    \"%h\": lambda tdt, yds: tz_isoformat(tdt, \"%h\"),\n    \"%Z\": lambda tdt, yds: tz_isoformat(tdt, \"%Z\"),\n    \"%z\": lambda tdt, yds: tz_isoformat(tdt, \"%z\"),\n    \"%%\": lambda tdt, yds: \"%\",\n}\n\nSTRF_D_MAP = {\n    \"%d\": lambda tdt, yds: \"%02d\" % tdt.days,\n    \"%f\": lambda tdt, yds: \"%06d\" % tdt.microseconds,\n    \"%H\": lambda tdt, yds: \"%02d\" % (tdt.seconds / 60 / 60),\n    \"%m\": lambda tdt, yds: \"%02d\" % tdt.months,\n    \"%M\": lambda tdt, yds: \"%02d\" % ((tdt.seconds / 60) % 60),\n    \"%S\": lambda tdt, yds: \"%02d\" % (tdt.seconds % 60),\n    \"%W\": lambda tdt, yds: \"%02d\" % (abs(tdt.days / 7)),\n    \"%Y\": lambda tdt, yds: (((yds != 4) and \"+\") or \"\")\n    + ((\"%%0%dd\" % yds) % tdt.years),\n    \"%C\": lambda tdt, yds: (((yds != 4) and \"+\") or \"\")\n    + ((\"%%0%dd\" % (yds - 2)) % (tdt.years / 100)),\n    \"%%\": lambda tdt, yds: \"%\",\n}\n\n\ndef _strfduration(tdt, format, yeardigits=4):\n    \"\"\"\n    this is the work method for timedelta and Duration instances.\n\n    see strftime for more details.\n    \"\"\"\n\n    def repl(match):\n        \"\"\"\n        lookup format command and return corresponding replacement.\n        \"\"\"\n        if match.group(0) in STRF_D_MAP:\n            return STRF_D_MAP[match.group(0)](tdt, yeardigits)\n        elif match.group(0) == \"%P\":\n            ret = []\n            if isinstance(tdt, Duration):\n                if tdt.years:\n                    ret.append(\"%sY\" % abs(tdt.years))\n                if tdt.months:\n                    ret.append(\"%sM\" % abs(tdt.months))\n            usecs = abs(\n                (tdt.days * 24 * 60 * 60 + tdt.seconds) * 1000000 + tdt.microseconds\n            )\n            seconds, usecs = divmod(usecs, 1000000)\n            minutes, seconds = divmod(seconds, 60)\n            hours, minutes = divmod(minutes, 60)\n            days, hours = divmod(hours, 24)\n            if days:\n                ret.append(\"%sD\" % days)\n            if hours or minutes or seconds or usecs:\n                ret.append(\"T\")\n                if hours:\n                    ret.append(\"%sH\" % hours)\n                if minutes:\n                    ret.append(\"%sM\" % minutes)\n                if seconds or usecs:\n                    if usecs:\n                        ret.append((\"%d.%06d\" % (seconds, usecs)).rstrip(\"0\"))\n                    else:\n                        ret.append(\"%d\" % seconds)\n                    ret.append(\"S\")\n            # at least one component has to be there.\n            return ret and \"\".join(ret) or \"0D\"\n        elif match.group(0) == \"%p\":\n            return str(abs(tdt.days // 7)) + \"W\"\n        return match.group(0)\n\n    return re.sub(\"%d|%f|%H|%m|%M|%S|%W|%Y|%C|%%|%P|%p\", repl, format)\n\n\ndef _strfdt(tdt, format, yeardigits=4):\n    \"\"\"\n    this is the work method for time and date instances.\n\n    see strftime for more details.\n    \"\"\"\n\n    def repl(match):\n        \"\"\"\n        lookup format command and return corresponding replacement.\n        \"\"\"\n        if match.group(0) in STRF_DT_MAP:\n            return STRF_DT_MAP[match.group(0)](tdt, yeardigits)\n        return match.group(0)\n\n    return re.sub(\"%d|%f|%H|%j|%m|%M|%S|%w|%W|%Y|%C|%z|%Z|%h|%%\", repl, format)\n\n\ndef strftime(tdt, format, yeardigits=4):\n    \"\"\"Directive    Meaning    Notes\n    %d    Day of the month as a decimal number [01,31].\n    %f    Microsecond as a decimal number [0,999999], zero-padded\n          on the left (1)\n    %H    Hour (24-hour clock) as a decimal number [00,23].\n    %j    Day of the year as a decimal number [001,366].\n    %m    Month as a decimal number [01,12].\n    %M    Minute as a decimal number [00,59].\n    %S    Second as a decimal number [00,61].    (3)\n    %w    Weekday as a decimal number [0(Monday),6].\n    %W    Week number of the year (Monday as the first day of the week)\n          as a decimal number [00,53]. All days in a new year preceding the\n          first Monday are considered to be in week 0.  (4)\n    %Y    Year with century as a decimal number. [0000,9999]\n    %C    Century as a decimal number. [00,99]\n    %z    UTC offset in the form +HHMM or -HHMM (empty string if the\n          object is naive).    (5)\n    %Z    Time zone name (empty string if the object is naive).\n    %P    ISO8601 duration format.\n    %p    ISO8601 duration format in weeks.\n    %%    A literal '%' character.\n\n    \"\"\"\n    if isinstance(tdt, (timedelta, Duration)):\n        return _strfduration(tdt, format, yeardigits)\n    return _strfdt(tdt, format, yeardigits)\n", "src/isodate/isoduration.py": "\"\"\"\nThis module provides an ISO 8601:2004 duration parser.\n\nIt also provides a wrapper to strftime. This wrapper makes it easier to\nformat timedelta or Duration instances as ISO conforming strings.\n\"\"\"\nfrom datetime import timedelta\nfrom decimal import Decimal\nimport re\n\nfrom isodate.duration import Duration\nfrom isodate.isoerror import ISO8601Error\nfrom isodate.isodatetime import parse_datetime\nfrom isodate.isostrf import strftime, D_DEFAULT\n\nISO8601_PERIOD_REGEX = re.compile(\n    r\"^(?P<sign>[+-])?\"\n    r\"P(?!\\b)\"\n    r\"(?P<years>[0-9]+([,.][0-9]+)?Y)?\"\n    r\"(?P<months>[0-9]+([,.][0-9]+)?M)?\"\n    r\"(?P<weeks>[0-9]+([,.][0-9]+)?W)?\"\n    r\"(?P<days>[0-9]+([,.][0-9]+)?D)?\"\n    r\"((?P<separator>T)(?P<hours>[0-9]+([,.][0-9]+)?H)?\"\n    r\"(?P<minutes>[0-9]+([,.][0-9]+)?M)?\"\n    r\"(?P<seconds>[0-9]+([,.][0-9]+)?S)?)?$\"\n)\n# regular expression to parse ISO duration strings.\n\n\ndef parse_duration(datestring, as_timedelta_if_possible=True):\n    \"\"\"\n    Parses an ISO 8601 durations into datetime.timedelta or Duration objects.\n\n    If the ISO date string does not contain years or months, a timedelta\n    instance is returned, else a Duration instance is returned.\n\n    The following duration formats are supported:\n      -PnnW                  duration in weeks\n      -PnnYnnMnnDTnnHnnMnnS  complete duration specification\n      -PYYYYMMDDThhmmss      basic alternative complete date format\n      -PYYYY-MM-DDThh:mm:ss  extended alternative complete date format\n      -PYYYYDDDThhmmss       basic alternative ordinal date format\n      -PYYYY-DDDThh:mm:ss    extended alternative ordinal date format\n\n    The '-' is optional.\n\n    Limitations:  ISO standard defines some restrictions about where to use\n      fractional numbers and which component and format combinations are\n      allowed. This parser implementation ignores all those restrictions and\n      returns something when it is able to find all necessary components.\n      In detail:\n        it does not check, whether only the last component has fractions.\n        it allows weeks specified with all other combinations\n\n      The alternative format does not support durations with years, months or\n      days set to 0.\n    \"\"\"\n    if not isinstance(datestring, str):\n        raise TypeError(\"Expecting a string %r\" % datestring)\n    match = ISO8601_PERIOD_REGEX.match(datestring)\n    if not match:\n        # try alternative format:\n        if datestring.startswith(\"P\"):\n            durdt = parse_datetime(datestring[1:])\n            if as_timedelta_if_possible and durdt.year == 0 and durdt.month == 0:\n                # FIXME: currently not possible in alternative format\n                # create timedelta\n                ret = timedelta(\n                    days=durdt.day,\n                    seconds=durdt.second,\n                    microseconds=durdt.microsecond,\n                    minutes=durdt.minute,\n                    hours=durdt.hour,\n                )\n            else:\n                # create Duration\n                ret = Duration(\n                    days=durdt.day,\n                    seconds=durdt.second,\n                    microseconds=durdt.microsecond,\n                    minutes=durdt.minute,\n                    hours=durdt.hour,\n                    months=durdt.month,\n                    years=durdt.year,\n                )\n            return ret\n        raise ISO8601Error(\"Unable to parse duration string %r\" % datestring)\n    groups = match.groupdict()\n    for key, val in groups.items():\n        if key not in (\"separator\", \"sign\"):\n            if val is None:\n                groups[key] = \"0n\"\n            # print groups[key]\n            if key in (\"years\", \"months\"):\n                groups[key] = Decimal(groups[key][:-1].replace(\",\", \".\"))\n            else:\n                # these values are passed into a timedelta object,\n                # which works with floats.\n                groups[key] = float(groups[key][:-1].replace(\",\", \".\"))\n    if as_timedelta_if_possible and groups[\"years\"] == 0 and groups[\"months\"] == 0:\n        ret = timedelta(\n            days=groups[\"days\"],\n            hours=groups[\"hours\"],\n            minutes=groups[\"minutes\"],\n            seconds=groups[\"seconds\"],\n            weeks=groups[\"weeks\"],\n        )\n        if groups[\"sign\"] == \"-\":\n            ret = timedelta(0) - ret\n    else:\n        ret = Duration(\n            years=groups[\"years\"],\n            months=groups[\"months\"],\n            days=groups[\"days\"],\n            hours=groups[\"hours\"],\n            minutes=groups[\"minutes\"],\n            seconds=groups[\"seconds\"],\n            weeks=groups[\"weeks\"],\n        )\n        if groups[\"sign\"] == \"-\":\n            ret = Duration(0) - ret\n    return ret\n\n\ndef duration_isoformat(tduration, format=D_DEFAULT):\n    \"\"\"\n    Format duration strings.\n\n    This method is just a wrapper around isodate.isostrf.strftime and uses\n    P%P (D_DEFAULT) as default format.\n    \"\"\"\n    # TODO: implement better decision for negative Durations.\n    #       should be done in Duration class in consistent way with timedelta.\n    if (\n        isinstance(tduration, Duration)\n        and (\n            tduration.years < 0\n            or tduration.months < 0\n            or tduration.tdelta < timedelta(0)\n        )\n    ) or (isinstance(tduration, timedelta) and (tduration < timedelta(0))):\n        ret = \"-\"\n    else:\n        ret = \"\"\n    ret += strftime(tduration, format)\n    return ret\n", "src/isodate/isodates.py": "\"\"\"\nThis modules provides a method to parse an ISO 8601:2004 date string to a\npython datetime.date instance.\n\nIt supports all basic, extended and expanded formats as described in the ISO\nstandard. The only limitations it has, are given by the Python datetime.date\nimplementation, which does not support dates before 0001-01-01.\n\"\"\"\nimport re\nfrom datetime import date, timedelta\n\nfrom isodate.isostrf import strftime, DATE_EXT_COMPLETE\nfrom isodate.isoerror import ISO8601Error\n\nDATE_REGEX_CACHE = {}\n# A dictionary to cache pre-compiled regular expressions.\n# A set of regular expressions is identified, by number of year digits allowed\n# and whether a plus/minus sign is required or not. (This option is changeable\n# only for 4 digit years).\n\n\ndef build_date_regexps(yeardigits=4, expanded=False):\n    \"\"\"\n    Compile set of regular expressions to parse ISO dates. The expressions will\n    be created only if they are not already in REGEX_CACHE.\n\n    It is necessary to fix the number of year digits, else it is not possible\n    to automatically distinguish between various ISO date formats.\n\n    ISO 8601 allows more than 4 digit years, on prior agreement, but then a +/-\n    sign is required (expanded format). To support +/- sign for 4 digit years,\n    the expanded parameter needs to be set to True.\n    \"\"\"\n    if yeardigits != 4:\n        expanded = True\n    if (yeardigits, expanded) not in DATE_REGEX_CACHE:\n        cache_entry = []\n        # ISO 8601 expanded DATE formats allow an arbitrary number of year\n        # digits with a leading +/- sign.\n        if expanded:\n            sign = 1\n        else:\n            sign = 0\n\n        def add_re(regex_text):\n            cache_entry.append(re.compile(r\"\\A\" + regex_text + r\"\\Z\"))\n\n        # 1. complete dates:\n        #    YYYY-MM-DD or +- YYYYYY-MM-DD... extended date format\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"-(?P<month>[0-9]{2})-(?P<day>[0-9]{2})\" % (sign, yeardigits)\n        )\n        #    YYYYMMDD or +- YYYYYYMMDD... basic date format\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"(?P<month>[0-9]{2})(?P<day>[0-9]{2})\" % (sign, yeardigits)\n        )\n        # 2. complete week dates:\n        #    YYYY-Www-D or +-YYYYYY-Www-D ... extended week date\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"-W(?P<week>[0-9]{2})-(?P<day>[0-9]{1})\" % (sign, yeardigits)\n        )\n        #    YYYYWwwD or +-YYYYYYWwwD ... basic week date\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})W\"\n            r\"(?P<week>[0-9]{2})(?P<day>[0-9]{1})\" % (sign, yeardigits)\n        )\n        # 3. ordinal dates:\n        #    YYYY-DDD or +-YYYYYY-DDD ... extended format\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"-(?P<day>[0-9]{3})\" % (sign, yeardigits)\n        )\n        #    YYYYDDD or +-YYYYYYDDD ... basic format\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"(?P<day>[0-9]{3})\" % (sign, yeardigits)\n        )\n        # 4. week dates:\n        #    YYYY-Www or +-YYYYYY-Www ... extended reduced accuracy week date\n        # 4. week dates:\n        #    YYYY-Www or +-YYYYYY-Www ... extended reduced accuracy week date\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"-W(?P<week>[0-9]{2})\" % (sign, yeardigits)\n        )\n        #    YYYYWww or +-YYYYYYWww ... basic reduced accuracy week date\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})W\"\n            r\"(?P<week>[0-9]{2})\" % (sign, yeardigits)\n        )\n        # 5. month dates:\n        #    YYY-MM or +-YYYYYY-MM ... reduced accuracy specific month\n        # 5. month dates:\n        #    YYY-MM or +-YYYYYY-MM ... reduced accuracy specific month\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"-(?P<month>[0-9]{2})\" % (sign, yeardigits)\n        )\n        #    YYYMM or +-YYYYYYMM ... basic incomplete month date format\n        add_re(\n            r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\"\n            r\"(?P<month>[0-9]{2})\" % (sign, yeardigits)\n        )\n        # 6. year dates:\n        #    YYYY or +-YYYYYY ... reduced accuracy specific year\n        add_re(r\"(?P<sign>[+-]){%d}(?P<year>[0-9]{%d})\" % (sign, yeardigits))\n        # 7. century dates:\n        #    YY or +-YYYY ... reduced accuracy specific century\n        add_re(r\"(?P<sign>[+-]){%d}\" r\"(?P<century>[0-9]{%d})\" % (sign, yeardigits - 2))\n\n        DATE_REGEX_CACHE[(yeardigits, expanded)] = cache_entry\n    return DATE_REGEX_CACHE[(yeardigits, expanded)]\n\n\ndef parse_date(datestring, yeardigits=4, expanded=False, defaultmonth=1, defaultday=1):\n    \"\"\"\n    Parse an ISO 8601 date string into a datetime.date object.\n\n    As the datetime.date implementation is limited to dates starting from\n    0001-01-01, negative dates (BC) and year 0 can not be parsed by this\n    method.\n\n    For incomplete dates, this method chooses the first day for it. For\n    instance if only a century is given, this method returns the 1st of\n    January in year 1 of this century.\n\n    supported formats: (expanded formats are shown with 6 digits for year)\n      YYYYMMDD    +-YYYYYYMMDD      basic complete date\n      YYYY-MM-DD  +-YYYYYY-MM-DD    extended complete date\n      YYYYWwwD    +-YYYYYYWwwD      basic complete week date\n      YYYY-Www-D  +-YYYYYY-Www-D    extended complete week date\n      YYYYDDD     +-YYYYYYDDD       basic ordinal date\n      YYYY-DDD    +-YYYYYY-DDD      extended ordinal date\n      YYYYWww     +-YYYYYYWww       basic incomplete week date\n      YYYY-Www    +-YYYYYY-Www      extended incomplete week date\n      YYYMM       +-YYYYYYMM        basic incomplete month date\n      YYY-MM      +-YYYYYY-MM       incomplete month date\n      YYYY        +-YYYYYY          incomplete year date\n      YY          +-YYYY            incomplete century date\n\n    @param datestring: the ISO date string to parse\n    @param yeardigits: how many digits are used to represent a year\n    @param expanded: if True then +/- signs are allowed. This parameter\n                     is forced to True, if yeardigits != 4\n\n    @return: a datetime.date instance represented by datestring\n    @raise ISO8601Error: if this function can not parse the datestring\n    @raise ValueError: if datestring can not be represented by datetime.date\n    \"\"\"\n    if yeardigits != 4:\n        expanded = True\n    isodates = build_date_regexps(yeardigits, expanded)\n    for pattern in isodates:\n        match = pattern.match(datestring)\n        if match:\n            groups = match.groupdict()\n            # sign, century, year, month, week, day,\n            # FIXME: negative dates not possible with python standard types\n            sign = (groups[\"sign\"] == \"-\" and -1) or 1\n            if \"century\" in groups:\n                return date(\n                    sign * (int(groups[\"century\"]) * 100 + 1), defaultmonth, defaultday\n                )\n            if \"month\" not in groups:  # weekdate or ordinal date\n                ret = date(sign * int(groups[\"year\"]), 1, 1)\n                if \"week\" in groups:\n                    isotuple = ret.isocalendar()\n                    if \"day\" in groups:\n                        days = int(groups[\"day\"] or 1)\n                    else:\n                        days = 1\n                    # if first week in year, do weeks-1\n                    return ret + timedelta(\n                        weeks=int(groups[\"week\"]) - (((isotuple[1] == 1) and 1) or 0),\n                        days=-isotuple[2] + days,\n                    )\n                elif \"day\" in groups:  # ordinal date\n                    return ret + timedelta(days=int(groups[\"day\"]) - 1)\n                else:  # year date\n                    return ret.replace(month=defaultmonth, day=defaultday)\n            # year-, month-, or complete date\n            if \"day\" not in groups or groups[\"day\"] is None:\n                day = defaultday\n            else:\n                day = int(groups[\"day\"])\n            return date(\n                sign * int(groups[\"year\"]), int(groups[\"month\"]) or defaultmonth, day\n            )\n    raise ISO8601Error(\"Unrecognised ISO 8601 date format: %r\" % datestring)\n\n\ndef date_isoformat(tdate, format=DATE_EXT_COMPLETE, yeardigits=4):\n    \"\"\"\n    Format date strings.\n\n    This method is just a wrapper around isodate.isostrf.strftime and uses\n    Date-Extended-Complete as default format.\n    \"\"\"\n    return strftime(tdate, format, yeardigits)\n", "src/isodate/__init__.py": "\"\"\"\nImport all essential functions and constants to re-export them here for easy\naccess.\n\nThis module contains also various pre-defined ISO 8601 format strings.\n\"\"\"\nfrom isodate.isodates import parse_date, date_isoformat\nfrom isodate.isotime import parse_time, time_isoformat\nfrom isodate.isodatetime import parse_datetime, datetime_isoformat\nfrom isodate.isoduration import parse_duration, duration_isoformat\nfrom isodate.isoerror import ISO8601Error\nfrom isodate.isotzinfo import parse_tzinfo, tz_isoformat\nfrom isodate.tzinfo import UTC, FixedOffset, LOCAL\nfrom isodate.duration import Duration\nfrom isodate.isostrf import strftime\nfrom isodate.isostrf import DATE_BAS_COMPLETE, DATE_BAS_ORD_COMPLETE\nfrom isodate.isostrf import DATE_BAS_WEEK, DATE_BAS_WEEK_COMPLETE\nfrom isodate.isostrf import DATE_CENTURY, DATE_EXT_COMPLETE\nfrom isodate.isostrf import DATE_EXT_ORD_COMPLETE, DATE_EXT_WEEK\nfrom isodate.isostrf import DATE_EXT_WEEK_COMPLETE, DATE_YEAR\nfrom isodate.isostrf import DATE_BAS_MONTH, DATE_EXT_MONTH\nfrom isodate.isostrf import TIME_BAS_COMPLETE, TIME_BAS_MINUTE\nfrom isodate.isostrf import TIME_EXT_COMPLETE, TIME_EXT_MINUTE\nfrom isodate.isostrf import TIME_HOUR\nfrom isodate.isostrf import TZ_BAS, TZ_EXT, TZ_HOUR\nfrom isodate.isostrf import DT_BAS_COMPLETE, DT_EXT_COMPLETE\nfrom isodate.isostrf import DT_BAS_ORD_COMPLETE, DT_EXT_ORD_COMPLETE\nfrom isodate.isostrf import DT_BAS_WEEK_COMPLETE, DT_EXT_WEEK_COMPLETE\nfrom isodate.isostrf import D_DEFAULT, D_WEEK, D_ALT_EXT, D_ALT_BAS\nfrom isodate.isostrf import D_ALT_BAS_ORD, D_ALT_EXT_ORD\n\n__all__ = [\n    \"parse_date\",\n    \"date_isoformat\",\n    \"parse_time\",\n    \"time_isoformat\",\n    \"parse_datetime\",\n    \"datetime_isoformat\",\n    \"parse_duration\",\n    \"duration_isoformat\",\n    \"ISO8601Error\",\n    \"parse_tzinfo\",\n    \"tz_isoformat\",\n    \"UTC\",\n    \"FixedOffset\",\n    \"LOCAL\",\n    \"Duration\",\n    \"strftime\",\n    \"DATE_BAS_COMPLETE\",\n    \"DATE_BAS_ORD_COMPLETE\",\n    \"DATE_BAS_WEEK\",\n    \"DATE_BAS_WEEK_COMPLETE\",\n    \"DATE_CENTURY\",\n    \"DATE_EXT_COMPLETE\",\n    \"DATE_EXT_ORD_COMPLETE\",\n    \"DATE_EXT_WEEK\",\n    \"DATE_EXT_WEEK_COMPLETE\",\n    \"DATE_YEAR\",\n    \"DATE_BAS_MONTH\",\n    \"DATE_EXT_MONTH\",\n    \"TIME_BAS_COMPLETE\",\n    \"TIME_BAS_MINUTE\",\n    \"TIME_EXT_COMPLETE\",\n    \"TIME_EXT_MINUTE\",\n    \"TIME_HOUR\",\n    \"TZ_BAS\",\n    \"TZ_EXT\",\n    \"TZ_HOUR\",\n    \"DT_BAS_COMPLETE\",\n    \"DT_EXT_COMPLETE\",\n    \"DT_BAS_ORD_COMPLETE\",\n    \"DT_EXT_ORD_COMPLETE\",\n    \"DT_BAS_WEEK_COMPLETE\",\n    \"DT_EXT_WEEK_COMPLETE\",\n    \"D_DEFAULT\",\n    \"D_WEEK\",\n    \"D_ALT_EXT\",\n    \"D_ALT_BAS\",\n    \"D_ALT_BAS_ORD\",\n    \"D_ALT_EXT_ORD\",\n]\n", "src/isodate/isotime.py": "\"\"\"\nThis modules provides a method to parse an ISO 8601:2004 time string to a\nPython datetime.time instance.\n\nIt supports all basic and extended formats including time zone specifications\nas described in the ISO standard.\n\"\"\"\nimport re\nfrom decimal import Decimal, ROUND_FLOOR\nfrom datetime import time\n\nfrom isodate.isostrf import strftime, TIME_EXT_COMPLETE, TZ_EXT\nfrom isodate.isoerror import ISO8601Error\nfrom isodate.isotzinfo import TZ_REGEX, build_tzinfo\n\nTIME_REGEX_CACHE = []\n# used to cache regular expressions to parse ISO time strings.\n\n\ndef build_time_regexps():\n    \"\"\"\n    Build regular expressions to parse ISO time string.\n\n    The regular expressions are compiled and stored in TIME_REGEX_CACHE\n    for later reuse.\n    \"\"\"\n    if not TIME_REGEX_CACHE:\n        # ISO 8601 time representations allow decimal fractions on least\n        #    significant time component. Command and Full Stop are both valid\n        #    fraction separators.\n        #    The letter 'T' is allowed as time designator in front of a time\n        #    expression.\n        #    Immediately after a time expression, a time zone definition is\n        #      allowed.\n        #    a TZ may be missing (local time), be a 'Z' for UTC or a string of\n        #    +-hh:mm where the ':mm' part can be skipped.\n        # TZ information patterns:\n        #    ''\n        #    Z\n        #    +-hh:mm\n        #    +-hhmm\n        #    +-hh =>\n        #    isotzinfo.TZ_REGEX\n        def add_re(regex_text):\n            TIME_REGEX_CACHE.append(re.compile(r\"\\A\" + regex_text + TZ_REGEX + r\"\\Z\"))\n\n        # 1. complete time:\n        #    hh:mm:ss.ss ... extended format\n        add_re(\n            r\"T?(?P<hour>[0-9]{2}):\"\n            r\"(?P<minute>[0-9]{2}):\"\n            r\"(?P<second>[0-9]{2}\"\n            r\"([,.][0-9]+)?)\"\n        )\n        #    hhmmss.ss ... basic format\n        add_re(\n            r\"T?(?P<hour>[0-9]{2})\"\n            r\"(?P<minute>[0-9]{2})\"\n            r\"(?P<second>[0-9]{2}\"\n            r\"([,.][0-9]+)?)\"\n        )\n        # 2. reduced accuracy:\n        #    hh:mm.mm ... extended format\n        add_re(r\"T?(?P<hour>[0-9]{2}):\" r\"(?P<minute>[0-9]{2}\" r\"([,.][0-9]+)?)\")\n        #    hhmm.mm ... basic format\n        add_re(r\"T?(?P<hour>[0-9]{2})\" r\"(?P<minute>[0-9]{2}\" r\"([,.][0-9]+)?)\")\n        #    hh.hh ... basic format\n        add_re(r\"T?(?P<hour>[0-9]{2}\" r\"([,.][0-9]+)?)\")\n    return TIME_REGEX_CACHE\n\n\ndef parse_time(timestring):\n    \"\"\"\n    Parses ISO 8601 times into datetime.time objects.\n\n    Following ISO 8601 formats are supported:\n      (as decimal separator a ',' or a '.' is allowed)\n      hhmmss.ssTZD    basic complete time\n      hh:mm:ss.ssTZD  extended complete time\n      hhmm.mmTZD      basic reduced accuracy time\n      hh:mm.mmTZD     extended reduced accuracy time\n      hh.hhTZD        basic reduced accuracy time\n    TZD is the time zone designator which can be in the following format:\n              no designator indicates local time zone\n      Z       UTC\n      +-hhmm  basic hours and minutes\n      +-hh:mm extended hours and minutes\n      +-hh    hours\n    \"\"\"\n    isotimes = build_time_regexps()\n    for pattern in isotimes:\n        match = pattern.match(timestring)\n        if match:\n            groups = match.groupdict()\n            for key, value in groups.items():\n                if value is not None:\n                    groups[key] = value.replace(\",\", \".\")\n            tzinfo = build_tzinfo(\n                groups[\"tzname\"],\n                groups[\"tzsign\"],\n                int(groups[\"tzhour\"] or 0),\n                int(groups[\"tzmin\"] or 0),\n            )\n            if \"second\" in groups:\n                second = Decimal(groups[\"second\"]).quantize(\n                    Decimal(\".000001\"), rounding=ROUND_FLOOR\n                )\n                microsecond = (second - int(second)) * int(1e6)\n                # int(...) ... no rounding\n                # to_integral() ... rounding\n                return time(\n                    int(groups[\"hour\"]),\n                    int(groups[\"minute\"]),\n                    int(second),\n                    int(microsecond.to_integral()),\n                    tzinfo,\n                )\n            if \"minute\" in groups:\n                minute = Decimal(groups[\"minute\"])\n                second = Decimal((minute - int(minute)) * 60).quantize(\n                    Decimal(\".000001\"), rounding=ROUND_FLOOR\n                )\n                microsecond = (second - int(second)) * int(1e6)\n                return time(\n                    int(groups[\"hour\"]),\n                    int(minute),\n                    int(second),\n                    int(microsecond.to_integral()),\n                    tzinfo,\n                )\n            else:\n                microsecond, second, minute = 0, 0, 0\n            hour = Decimal(groups[\"hour\"])\n            minute = (hour - int(hour)) * 60\n            second = (minute - int(minute)) * 60\n            microsecond = (second - int(second)) * int(1e6)\n            return time(\n                int(hour),\n                int(minute),\n                int(second),\n                int(microsecond.to_integral()),\n                tzinfo,\n            )\n    raise ISO8601Error(\"Unrecognised ISO 8601 time format: %r\" % timestring)\n\n\ndef time_isoformat(ttime, format=TIME_EXT_COMPLETE + TZ_EXT):\n    \"\"\"\n    Format time strings.\n\n    This method is just a wrapper around isodate.isostrf.strftime and uses\n    Time-Extended-Complete with extended time zone as default format.\n    \"\"\"\n    return strftime(ttime, format)\n", "src/isodate/tzinfo.py": "\"\"\"\nThis module provides some datetime.tzinfo implementations.\n\nAll those classes are taken from the Python documentation.\n\"\"\"\nfrom datetime import timedelta, tzinfo\nimport time\n\nZERO = timedelta(0)\n# constant for zero time offset.\n\n\nclass Utc(tzinfo):\n    \"\"\"UTC\n\n    Universal time coordinated time zone.\n    \"\"\"\n\n    def utcoffset(self, dt):\n        \"\"\"\n        Return offset from UTC in minutes east of UTC, which is ZERO for UTC.\n        \"\"\"\n        return ZERO\n\n    def tzname(self, dt):\n        \"\"\"\n        Return the time zone name corresponding to the datetime object dt,\n        as a string.\n        \"\"\"\n        return \"UTC\"\n\n    def dst(self, dt):\n        \"\"\"\n        Return the daylight saving time (DST) adjustment, in minutes east\n        of UTC.\n        \"\"\"\n        return ZERO\n\n    def __reduce__(self):\n        \"\"\"\n        When unpickling a Utc object, return the default instance below, UTC.\n        \"\"\"\n        return _Utc, ()\n\n\nUTC = Utc()\n# the default instance for UTC.\n\n\ndef _Utc():\n    \"\"\"\n    Helper function for unpickling a Utc object.\n    \"\"\"\n    return UTC\n\n\nclass FixedOffset(tzinfo):\n    \"\"\"\n    A class building tzinfo objects for fixed-offset time zones.\n\n    Note that FixedOffset(0, 0, \"UTC\") or FixedOffset() is a different way to\n    build a UTC tzinfo object.\n    \"\"\"\n\n    def __init__(self, offset_hours=0, offset_minutes=0, name=\"UTC\"):\n        \"\"\"\n        Initialise an instance with time offset and name.\n        The time offset should be positive for time zones east of UTC\n        and negate for time zones west of UTC.\n        \"\"\"\n        self.__offset = timedelta(hours=offset_hours, minutes=offset_minutes)\n        self.__name = name\n\n    def utcoffset(self, dt):\n        \"\"\"\n        Return offset from UTC in minutes of UTC.\n        \"\"\"\n        return self.__offset\n\n    def tzname(self, dt):\n        \"\"\"\n        Return the time zone name corresponding to the datetime object dt, as a\n        string.\n        \"\"\"\n        return self.__name\n\n    def dst(self, dt):\n        \"\"\"\n        Return the daylight saving time (DST) adjustment, in minutes east of\n        UTC.\n        \"\"\"\n        return ZERO\n\n    def __repr__(self):\n        \"\"\"\n        Return nicely formatted repr string.\n        \"\"\"\n        return \"<FixedOffset %r>\" % self.__name\n\n\nSTDOFFSET = timedelta(seconds=-time.timezone)\n# locale time zone offset\n\n# calculate local daylight saving offset if any.\nif time.daylight:\n    DSTOFFSET = timedelta(seconds=-time.altzone)\nelse:\n    DSTOFFSET = STDOFFSET\n\nDSTDIFF = DSTOFFSET - STDOFFSET\n# difference between local time zone and local DST time zone\n\n\nclass LocalTimezone(tzinfo):\n    \"\"\"\n    A class capturing the platform's idea of local time.\n    \"\"\"\n\n    def utcoffset(self, dt):\n        \"\"\"\n        Return offset from UTC in minutes of UTC.\n        \"\"\"\n        if self._isdst(dt):\n            return DSTOFFSET\n        else:\n            return STDOFFSET\n\n    def dst(self, dt):\n        \"\"\"\n        Return daylight saving offset.\n        \"\"\"\n        if self._isdst(dt):\n            return DSTDIFF\n        else:\n            return ZERO\n\n    def tzname(self, dt):\n        \"\"\"\n        Return the time zone name corresponding to the datetime object dt, as a\n        string.\n        \"\"\"\n        return time.tzname[self._isdst(dt)]\n\n    def _isdst(self, dt):\n        \"\"\"\n        Returns true if DST is active for given datetime object dt.\n        \"\"\"\n        tt = (\n            dt.year,\n            dt.month,\n            dt.day,\n            dt.hour,\n            dt.minute,\n            dt.second,\n            dt.weekday(),\n            0,\n            -1,\n        )\n        stamp = time.mktime(tt)\n        tt = time.localtime(stamp)\n        return tt.tm_isdst > 0\n\n\n# the default instance for local time zone.\nLOCAL = LocalTimezone()\n", "src/isodate/duration.py": "\"\"\"\nThis module defines a Duration class.\n\nThe class Duration allows to define durations in years and months and can be\nused as limited replacement for timedelta objects.\n\"\"\"\nfrom datetime import timedelta\nfrom decimal import Decimal, ROUND_FLOOR\n\n\ndef fquotmod(val, low, high):\n    \"\"\"\n    A divmod function with boundaries.\n\n    \"\"\"\n    # assumes that all the maths is done with Decimals.\n    # divmod for Decimal uses truncate instead of floor as builtin\n    # divmod, so we have to do it manually here.\n    a, b = val - low, high - low\n    div = (a / b).to_integral(ROUND_FLOOR)\n    mod = a - div * b\n    # if we were not using Decimal, it would look like this.\n    # div, mod = divmod(val - low, high - low)\n    mod += low\n    return int(div), mod\n\n\ndef max_days_in_month(year, month):\n    \"\"\"\n    Determines the number of days of a specific month in a specific year.\n    \"\"\"\n    if month in (1, 3, 5, 7, 8, 10, 12):\n        return 31\n    if month in (4, 6, 9, 11):\n        return 30\n    if ((year % 400) == 0) or ((year % 100) != 0) and ((year % 4) == 0):\n        return 29\n    return 28\n\n\nclass Duration:\n    \"\"\"\n    A class which represents a duration.\n\n    The difference to datetime.timedelta is, that this class handles also\n    differences given in years and months.\n    A Duration treats differences given in year, months separately from all\n    other components.\n\n    A Duration can be used almost like any timedelta object, however there\n    are some restrictions:\n      * It is not really possible to compare Durations, because it is unclear,\n        whether a duration of 1 year is bigger than 365 days or not.\n      * Equality is only tested between the two (year, month vs. timedelta)\n        basic components.\n\n    A Duration can also be converted into a datetime object, but this requires\n    a start date or an end date.\n\n    The algorithm to add a duration to a date is defined at\n    http://www.w3.org/TR/xmlschema-2/#adding-durations-to-dateTimes\n    \"\"\"\n\n    def __init__(\n        self,\n        days=0,\n        seconds=0,\n        microseconds=0,\n        milliseconds=0,\n        minutes=0,\n        hours=0,\n        weeks=0,\n        months=0,\n        years=0,\n    ):\n        \"\"\"\n        Initialise this Duration instance with the given parameters.\n        \"\"\"\n        if not isinstance(months, Decimal):\n            months = Decimal(str(months))\n        if not isinstance(years, Decimal):\n            years = Decimal(str(years))\n        self.months = months\n        self.years = years\n        self.tdelta = timedelta(\n            days, seconds, microseconds, milliseconds, minutes, hours, weeks\n        )\n\n    def __getstate__(self):\n        return self.__dict__\n\n    def __setstate__(self, state):\n        self.__dict__.update(state)\n\n    def __getattr__(self, name):\n        \"\"\"\n        Provide direct access to attributes of included timedelta instance.\n        \"\"\"\n        return getattr(self.tdelta, name)\n\n    def __str__(self):\n        \"\"\"\n        Return a string representation of this duration similar to timedelta.\n        \"\"\"\n        params = []\n        if self.years:\n            params.append(\"%d years\" % self.years)\n        if self.months:\n            fmt = \"%d months\"\n            if self.months <= 1:\n                fmt = \"%d month\"\n            params.append(fmt % self.months)\n        params.append(str(self.tdelta))\n        return \", \".join(params)\n\n    def __repr__(self):\n        \"\"\"\n        Return a string suitable for repr(x) calls.\n        \"\"\"\n        return \"%s.%s(%d, %d, %d, years=%d, months=%d)\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self.tdelta.days,\n            self.tdelta.seconds,\n            self.tdelta.microseconds,\n            self.years,\n            self.months,\n        )\n\n    def __hash__(self):\n        \"\"\"\n        Return a hash of this instance so that it can be used in, for\n        example, dicts and sets.\n        \"\"\"\n        return hash((self.tdelta, self.months, self.years))\n\n    def __neg__(self):\n        \"\"\"\n        A simple unary minus.\n\n        Returns a new Duration instance with all it's negated.\n        \"\"\"\n        negduration = Duration(years=-self.years, months=-self.months)\n        negduration.tdelta = -self.tdelta\n        return negduration\n\n    def __add__(self, other):\n        \"\"\"\n        Durations can be added with Duration, timedelta, date and datetime\n        objects.\n        \"\"\"\n        if isinstance(other, Duration):\n            newduration = Duration(\n                years=self.years + other.years, months=self.months + other.months\n            )\n            newduration.tdelta = self.tdelta + other.tdelta\n            return newduration\n        try:\n            # try anything that looks like a date or datetime\n            # 'other' has attributes year, month, day\n            # and relies on 'timedelta + other' being implemented\n            if not (float(self.years).is_integer() and float(self.months).is_integer()):\n                raise ValueError(\n                    \"fractional years or months not supported\" \" for date calculations\"\n                )\n            newmonth = other.month + self.months\n            carry, newmonth = fquotmod(newmonth, 1, 13)\n            newyear = other.year + self.years + carry\n            maxdays = max_days_in_month(newyear, newmonth)\n            if other.day > maxdays:\n                newday = maxdays\n            else:\n                newday = other.day\n            newdt = other.replace(\n                year=int(newyear), month=int(newmonth), day=int(newday)\n            )\n            # does a timedelta + date/datetime\n            return self.tdelta + newdt\n        except AttributeError:\n            # other probably was not a date/datetime compatible object\n            pass\n        try:\n            # try if other is a timedelta\n            # relies on timedelta + timedelta supported\n            newduration = Duration(years=self.years, months=self.months)\n            newduration.tdelta = self.tdelta + other\n            return newduration\n        except AttributeError:\n            # ignore ... other probably was not a timedelta compatible object\n            pass\n        # we have tried everything .... return a NotImplemented\n        return NotImplemented\n\n    __radd__ = __add__\n\n    def __mul__(self, other):\n        if isinstance(other, int):\n            newduration = Duration(years=self.years * other, months=self.months * other)\n            newduration.tdelta = self.tdelta * other\n            return newduration\n        return NotImplemented\n\n    __rmul__ = __mul__\n\n    def __sub__(self, other):\n        \"\"\"\n        It is possible to subtract Duration and timedelta objects from Duration\n        objects.\n        \"\"\"\n        if isinstance(other, Duration):\n            newduration = Duration(\n                years=self.years - other.years, months=self.months - other.months\n            )\n            newduration.tdelta = self.tdelta - other.tdelta\n            return newduration\n        try:\n            # do maths with our timedelta object ....\n            newduration = Duration(years=self.years, months=self.months)\n            newduration.tdelta = self.tdelta - other\n            return newduration\n        except TypeError:\n            # looks like timedelta - other is not implemented\n            pass\n        return NotImplemented\n\n    def __rsub__(self, other):\n        \"\"\"\n        It is possible to subtract Duration objects from date, datetime and\n        timedelta objects.\n\n        TODO: there is some weird behaviour in date - timedelta ...\n              if timedelta has seconds or microseconds set, then\n              date - timedelta != date + (-timedelta)\n              for now we follow this behaviour to avoid surprises when mixing\n              timedeltas with Durations, but in case this ever changes in\n              the stdlib we can just do:\n                return -self + other\n              instead of all the current code\n        \"\"\"\n        if isinstance(other, timedelta):\n            tmpdur = Duration()\n            tmpdur.tdelta = other\n            return tmpdur - self\n        try:\n            # check if other behaves like a date/datetime object\n            # does it have year, month, day and replace?\n            if not (float(self.years).is_integer() and float(self.months).is_integer()):\n                raise ValueError(\n                    \"fractional years or months not supported\" \" for date calculations\"\n                )\n            newmonth = other.month - self.months\n            carry, newmonth = fquotmod(newmonth, 1, 13)\n            newyear = other.year - self.years + carry\n            maxdays = max_days_in_month(newyear, newmonth)\n            if other.day > maxdays:\n                newday = maxdays\n            else:\n                newday = other.day\n            newdt = other.replace(\n                year=int(newyear), month=int(newmonth), day=int(newday)\n            )\n            return newdt - self.tdelta\n        except AttributeError:\n            # other probably was not compatible with data/datetime\n            pass\n        return NotImplemented\n\n    def __eq__(self, other):\n        \"\"\"\n        If the years, month part and the timedelta part are both equal, then\n        the two Durations are considered equal.\n        \"\"\"\n        if isinstance(other, Duration):\n            if (self.years * 12 + self.months) == (\n                other.years * 12 + other.months\n            ) and self.tdelta == other.tdelta:\n                return True\n            return False\n        # check if other con be compared against timedelta object\n        # will raise an AssertionError when optimisation is off\n        if self.years == 0 and self.months == 0:\n            return self.tdelta == other\n        return False\n\n    def __ne__(self, other):\n        \"\"\"\n        If the years, month part or the timedelta part is not equal, then\n        the two Durations are considered not equal.\n        \"\"\"\n        if isinstance(other, Duration):\n            if (self.years * 12 + self.months) != (\n                other.years * 12 + other.months\n            ) or self.tdelta != other.tdelta:\n                return True\n            return False\n        # check if other can be compared against timedelta object\n        # will raise an AssertionError when optimisation is off\n        if self.years == 0 and self.months == 0:\n            return self.tdelta != other\n        return True\n\n    def totimedelta(self, start=None, end=None):\n        \"\"\"\n        Convert this duration into a timedelta object.\n\n        This method requires a start datetime or end datetimem, but raises\n        an exception if both are given.\n        \"\"\"\n        if start is None and end is None:\n            raise ValueError(\"start or end required\")\n        if start is not None and end is not None:\n            raise ValueError(\"only start or end allowed\")\n        if start is not None:\n            return (start + self) - start\n        return end - (end - self)\n", "src/isodate/isotzinfo.py": "\"\"\"\nThis module provides an ISO 8601:2004 time zone info parser.\n\nIt offers a function to parse the time zone offset as specified by ISO 8601.\n\"\"\"\nimport re\n\nfrom isodate.isoerror import ISO8601Error\nfrom isodate.tzinfo import UTC, FixedOffset, ZERO\n\nTZ_REGEX = (\n    r\"(?P<tzname>(Z|(?P<tzsign>[+-])\" r\"(?P<tzhour>[0-9]{2})(:?(?P<tzmin>[0-9]{2}))?)?)\"\n)\n\nTZ_RE = re.compile(TZ_REGEX)\n\n\ndef build_tzinfo(tzname, tzsign=\"+\", tzhour=0, tzmin=0):\n    \"\"\"\n    create a tzinfo instance according to given parameters.\n\n    tzname:\n      'Z'       ... return UTC\n      '' | None ... return None\n      other     ... return FixedOffset\n    \"\"\"\n    if tzname is None or tzname == \"\":\n        return None\n    if tzname == \"Z\":\n        return UTC\n    tzsign = ((tzsign == \"-\") and -1) or 1\n    return FixedOffset(tzsign * tzhour, tzsign * tzmin, tzname)\n\n\ndef parse_tzinfo(tzstring):\n    \"\"\"\n    Parses ISO 8601 time zone designators to tzinfo objects.\n\n    A time zone designator can be in the following format:\n              no designator indicates local time zone\n      Z       UTC\n      +-hhmm  basic hours and minutes\n      +-hh:mm extended hours and minutes\n      +-hh    hours\n    \"\"\"\n    match = TZ_RE.match(tzstring)\n    if match:\n        groups = match.groupdict()\n        return build_tzinfo(\n            groups[\"tzname\"],\n            groups[\"tzsign\"],\n            int(groups[\"tzhour\"] or 0),\n            int(groups[\"tzmin\"] or 0),\n        )\n    raise ISO8601Error(\"%s not a valid time zone info\" % tzstring)\n\n\ndef tz_isoformat(dt, format=\"%Z\"):\n    \"\"\"\n    return time zone offset ISO 8601 formatted.\n    The various ISO formats can be chosen with the format parameter.\n\n    if tzinfo is None returns ''\n    if tzinfo is UTC returns 'Z'\n    else the offset is rendered to the given format.\n    format:\n        %h ... +-HH\n        %z ... +-HHMM\n        %Z ... +-HH:MM\n    \"\"\"\n    tzinfo = dt.tzinfo\n    if (tzinfo is None) or (tzinfo.utcoffset(dt) is None):\n        return \"\"\n    if tzinfo.utcoffset(dt) == ZERO and tzinfo.dst(dt) == ZERO:\n        return \"Z\"\n    tdelta = tzinfo.utcoffset(dt)\n    seconds = tdelta.days * 24 * 60 * 60 + tdelta.seconds\n    sign = ((seconds < 0) and \"-\") or \"+\"\n    seconds = abs(seconds)\n    minutes, seconds = divmod(seconds, 60)\n    hours, minutes = divmod(minutes, 60)\n    if hours > 99:\n        raise OverflowError(\"can not handle differences > 99 hours\")\n    if format == \"%Z\":\n        return \"%s%02d:%02d\" % (sign, hours, minutes)\n    elif format == \"%z\":\n        return \"%s%02d%02d\" % (sign, hours, minutes)\n    elif format == \"%h\":\n        return \"%s%02d\" % (sign, hours)\n    raise ValueError('unknown format string \"%s\"' % format)\n"}