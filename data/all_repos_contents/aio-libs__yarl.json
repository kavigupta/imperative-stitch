{"benchmark.py": "import timeit\n\ncython_setup = \"\"\"\\\nfrom yarl._quoting_c import _Quoter as Quoter\nfrom yarl._quoting_c import _Unquoter as Unquoter\n\"\"\"\n\npython_setup = \"\"\"\\\nfrom yarl._quoting_py import _Quoter as Quoter\nfrom yarl._quoting_py import _Unquoter as Unquoter\n\"\"\"\n\n\nprint(\n    \"Cython quote ascii: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", cython_setup + \"s='/path/to';q=Quoter(safe='/')\")\n    )\n)\n\n\nprint(\n    \"Python quote ascii: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", python_setup + \"s='/path/to';q=Quoter(safe='/')\")\n    )\n)\n\n\nprint(\n    \"Cython quote PCT: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", cython_setup + \"s='abc%0a';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Python quote PCT: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", python_setup + \"s='abc%0a';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Cython quote: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", cython_setup + \"s='/\u0448\u043b\u044f\u0445/\u0444\u0430\u0439\u043b';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Python quote: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", python_setup + \"s='/\u0448\u043b\u044f\u0445/\u0444\u0430\u0439\u043b';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Cython unquote: {:.3f} sec\".format(\n        timeit.timeit(\"u(s)\", cython_setup + \"s='/path/to';u=Unquoter()\")\n    )\n)\n\n\nprint(\n    \"Python unquote: {:.3f} sec\".format(\n        timeit.timeit(\"u(s)\", python_setup + \"s='/path/to';u=Unquoter()\")\n    )\n)\n", "yarl/_quoting.py": "import os\nimport sys\n\n__all__ = (\"_Quoter\", \"_Unquoter\")\n\n\nNO_EXTENSIONS = bool(os.environ.get(\"YARL_NO_EXTENSIONS\"))  # type: bool\nif sys.implementation.name != \"cpython\":\n    NO_EXTENSIONS = True\n\n\nif not NO_EXTENSIONS:  # pragma: no branch\n    try:\n        from ._quoting_c import _Quoter, _Unquoter  # type: ignore[assignment]\n    except ImportError:  # pragma: no cover\n        from ._quoting_py import _Quoter, _Unquoter  # type: ignore[assignment]\nelse:\n    from ._quoting_py import _Quoter, _Unquoter  # type: ignore[assignment]\n", "yarl/_url.py": "import functools\nimport math\nimport warnings\nfrom collections.abc import Mapping, Sequence\nfrom contextlib import suppress\nfrom ipaddress import ip_address\nfrom urllib.parse import SplitResult, parse_qsl, quote, urljoin, urlsplit, urlunsplit\n\nimport idna\nfrom multidict import MultiDict, MultiDictProxy\n\nfrom ._quoting import _Quoter, _Unquoter\n\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443, \"ws\": 80, \"wss\": 443}\n\nsentinel = object()\n\n\ndef rewrite_module(obj: object) -> object:\n    obj.__module__ = \"yarl\"\n    return obj\n\n\nclass cached_property:\n    \"\"\"Use as a class method decorator.  It operates almost exactly like\n    the Python `@property` decorator, but it puts the result of the\n    method it decorates into the instance dict after the first call,\n    effectively replacing the function it decorates with an instance\n    variable.  It is, in Python parlance, a data descriptor.\n\n    \"\"\"\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        try:\n            self.__doc__ = wrapped.__doc__\n        except AttributeError:  # pragma: no cover\n            self.__doc__ = \"\"\n        self.name = wrapped.__name__\n\n    def __get__(self, inst, owner, _sentinel=sentinel):\n        if inst is None:\n            return self\n        val = inst._cache.get(self.name, _sentinel)\n        if val is not _sentinel:\n            return val\n        val = self.wrapped(inst)\n        inst._cache[self.name] = val\n        return val\n\n    def __set__(self, inst, value):\n        raise AttributeError(\"cached property is read-only\")\n\n\ndef _normalize_path_segments(segments):\n    \"\"\"Drop '.' and '..' from a sequence of str segments\"\"\"\n\n    resolved_path = []\n\n    for seg in segments:\n        if seg == \"..\":\n            # ignore any .. segments that would otherwise cause an\n            # IndexError when popped from resolved_path if\n            # resolving for rfc3986\n            with suppress(IndexError):\n                resolved_path.pop()\n        elif seg != \".\":\n            resolved_path.append(seg)\n\n    if segments and segments[-1] in (\".\", \"..\"):\n        # do some post-processing here.\n        # if the last segment was a relative dir,\n        # then we need to append the trailing '/'\n        resolved_path.append(\"\")\n\n    return resolved_path\n\n\n@rewrite_module\nclass URL:\n    # Don't derive from str\n    # follow pathlib.Path design\n    # probably URL will not suffer from pathlib problems:\n    # it's intended for libraries like aiohttp,\n    # not to be passed into standard library functions like os.open etc.\n\n    # URL grammar (RFC 3986)\n    # pct-encoded = \"%\" HEXDIG HEXDIG\n    # reserved    = gen-delims / sub-delims\n    # gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n    # sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n    #             / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n    # unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n    # URI         = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n    # hier-part   = \"//\" authority path-abempty\n    #             / path-absolute\n    #             / path-rootless\n    #             / path-empty\n    # scheme      = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    # authority   = [ userinfo \"@\" ] host [ \":\" port ]\n    # userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n    # host        = IP-literal / IPv4address / reg-name\n    # IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n    # IPvFuture  = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n    # IPv6address =                            6( h16 \":\" ) ls32\n    #             /                       \"::\" 5( h16 \":\" ) ls32\n    #             / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    #             / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    #             / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    #             / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    #             / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    #             / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n    #             / [ *6( h16 \":\" ) h16 ] \"::\"\n    # ls32        = ( h16 \":\" h16 ) / IPv4address\n    #             ; least-significant 32 bits of address\n    # h16         = 1*4HEXDIG\n    #             ; 16 bits of address represented in hexadecimal\n    # IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n    # dec-octet   = DIGIT                 ; 0-9\n    #             / %x31-39 DIGIT         ; 10-99\n    #             / \"1\" 2DIGIT            ; 100-199\n    #             / \"2\" %x30-34 DIGIT     ; 200-249\n    #             / \"25\" %x30-35          ; 250-255\n    # reg-name    = *( unreserved / pct-encoded / sub-delims )\n    # port        = *DIGIT\n    # path          = path-abempty    ; begins with \"/\" or is empty\n    #               / path-absolute   ; begins with \"/\" but not \"//\"\n    #               / path-noscheme   ; begins with a non-colon segment\n    #               / path-rootless   ; begins with a segment\n    #               / path-empty      ; zero characters\n    # path-abempty  = *( \"/\" segment )\n    # path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n    # path-noscheme = segment-nz-nc *( \"/\" segment )\n    # path-rootless = segment-nz *( \"/\" segment )\n    # path-empty    = 0<pchar>\n    # segment       = *pchar\n    # segment-nz    = 1*pchar\n    # segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n    #               ; non-zero-length segment without any colon \":\"\n    # pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n    # query       = *( pchar / \"/\" / \"?\" )\n    # fragment    = *( pchar / \"/\" / \"?\" )\n    # URI-reference = URI / relative-ref\n    # relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\n    # relative-part = \"//\" authority path-abempty\n    #               / path-absolute\n    #               / path-noscheme\n    #               / path-empty\n    # absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\n    __slots__ = (\"_cache\", \"_val\")\n\n    _QUOTER = _Quoter(requote=False)\n    _REQUOTER = _Quoter()\n    _PATH_QUOTER = _Quoter(safe=\"@:\", protected=\"/+\", requote=False)\n    _PATH_REQUOTER = _Quoter(safe=\"@:\", protected=\"/+\")\n    _QUERY_QUOTER = _Quoter(safe=\"?/:@\", protected=\"=+&;\", qs=True, requote=False)\n    _QUERY_REQUOTER = _Quoter(safe=\"?/:@\", protected=\"=+&;\", qs=True)\n    _QUERY_PART_QUOTER = _Quoter(safe=\"?/:@\", qs=True, requote=False)\n    _FRAGMENT_QUOTER = _Quoter(safe=\"?/:@\", requote=False)\n    _FRAGMENT_REQUOTER = _Quoter(safe=\"?/:@\")\n\n    _UNQUOTER = _Unquoter()\n    _PATH_UNQUOTER = _Unquoter(unsafe=\"+\")\n    _QS_UNQUOTER = _Unquoter(qs=True)\n\n    def __new__(cls, val=\"\", *, encoded=False, strict=None):\n        if strict is not None:  # pragma: no cover\n            warnings.warn(\"strict parameter is ignored\")\n        if type(val) is cls:\n            return val\n        if type(val) is str:\n            val = urlsplit(val)\n        elif type(val) is SplitResult:\n            if not encoded:\n                raise ValueError(\"Cannot apply decoding to SplitResult\")\n        elif isinstance(val, str):\n            val = urlsplit(str(val))\n        else:\n            raise TypeError(\"Constructor parameter should be str\")\n\n        if not encoded:\n            if not val[1]:  # netloc\n                netloc = \"\"\n                host = \"\"\n            else:\n                host = val.hostname\n                if host is None:\n                    raise ValueError(\"Invalid URL: host is required for absolute urls\")\n\n                try:\n                    port = val.port\n                except ValueError as e:\n                    raise ValueError(\n                        \"Invalid URL: port can't be converted to integer\"\n                    ) from e\n\n                netloc = cls._make_netloc(\n                    val.username, val.password, host, port, encode=True, requote=True\n                )\n            path = cls._PATH_REQUOTER(val[2])\n            if netloc:\n                path = cls._normalize_path(path)\n\n            cls._validate_authority_uri_abs_path(host=host, path=path)\n            query = cls._QUERY_REQUOTER(val[3])\n            fragment = cls._FRAGMENT_REQUOTER(val[4])\n            val = SplitResult(val[0], netloc, path, query, fragment)\n\n        self = object.__new__(cls)\n        self._val = val\n        self._cache = {}\n        return self\n\n    @classmethod\n    def build(\n        cls,\n        *,\n        scheme=\"\",\n        authority=\"\",\n        user=None,\n        password=None,\n        host=\"\",\n        port=None,\n        path=\"\",\n        query=None,\n        query_string=\"\",\n        fragment=\"\",\n        encoded=False,\n    ):\n        \"\"\"Creates and returns a new URL\"\"\"\n\n        if authority and (user or password or host or port):\n            raise ValueError(\n                'Can\\'t mix \"authority\" with \"user\", \"password\", \"host\" or \"port\".'\n            )\n        if not isinstance(port, (int, type(None))):\n            raise TypeError(\"The port is required to be int.\")\n        if port and not host:\n            raise ValueError('Can\\'t build URL with \"port\" but without \"host\".')\n        if query and query_string:\n            raise ValueError('Only one of \"query\" or \"query_string\" should be passed')\n        if (\n            scheme is None\n            or authority is None\n            or host is None\n            or path is None\n            or query_string is None\n            or fragment is None\n        ):\n            raise TypeError(\n                'NoneType is illegal for \"scheme\", \"authority\", \"host\", \"path\", '\n                '\"query_string\", and \"fragment\" args, use empty string instead.'\n            )\n\n        if authority:\n            if encoded:\n                netloc = authority\n            else:\n                tmp = SplitResult(\"\", authority, \"\", \"\", \"\")\n                netloc = cls._make_netloc(\n                    tmp.username, tmp.password, tmp.hostname, tmp.port, encode=True\n                )\n        elif not user and not password and not host and not port:\n            netloc = \"\"\n        else:\n            netloc = cls._make_netloc(\n                user, password, host, port, encode=not encoded, encode_host=not encoded\n            )\n        if not encoded:\n            path = cls._PATH_QUOTER(path)\n            if netloc:\n                path = cls._normalize_path(path)\n\n            cls._validate_authority_uri_abs_path(host=host, path=path)\n            query_string = cls._QUERY_QUOTER(query_string)\n            fragment = cls._FRAGMENT_QUOTER(fragment)\n\n        url = cls(\n            SplitResult(scheme, netloc, path, query_string, fragment), encoded=True\n        )\n\n        if query:\n            return url.with_query(query)\n        else:\n            return url\n\n    def __init_subclass__(cls):\n        raise TypeError(f\"Inheriting a class {cls!r} from URL is forbidden\")\n\n    def __str__(self):\n        val = self._val\n        if not val.path and self.is_absolute() and (val.query or val.fragment):\n            val = val._replace(path=\"/\")\n        return urlunsplit(val)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}('{str(self)}')\"\n\n    def __bytes__(self):\n        return str(self).encode(\"ascii\")\n\n    def __eq__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n\n        val1 = self._val\n        if not val1.path and self.is_absolute():\n            val1 = val1._replace(path=\"/\")\n\n        val2 = other._val\n        if not val2.path and other.is_absolute():\n            val2 = val2._replace(path=\"/\")\n\n        return val1 == val2\n\n    def __hash__(self):\n        ret = self._cache.get(\"hash\")\n        if ret is None:\n            val = self._val\n            if not val.path and self.is_absolute():\n                val = val._replace(path=\"/\")\n            ret = self._cache[\"hash\"] = hash(val)\n        return ret\n\n    def __le__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val <= other._val\n\n    def __lt__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val < other._val\n\n    def __ge__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val >= other._val\n\n    def __gt__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val > other._val\n\n    def __truediv__(self, name):\n        if not isinstance(name, str):\n            return NotImplemented\n        return self._make_child((str(name),))\n\n    def __mod__(self, query):\n        return self.update_query(query)\n\n    def __bool__(self) -> bool:\n        return bool(\n            self._val.netloc or self._val.path or self._val.query or self._val.fragment\n        )\n\n    def __getstate__(self):\n        return (self._val,)\n\n    def __setstate__(self, state):\n        if state[0] is None and isinstance(state[1], dict):\n            # default style pickle\n            self._val = state[1][\"_val\"]\n        else:\n            self._val, *unused = state\n        self._cache = {}\n\n    def is_absolute(self):\n        \"\"\"A check for absolute URLs.\n\n        Return True for absolute ones (having scheme or starting\n        with //), False otherwise.\n\n        \"\"\"\n        return self.raw_host is not None\n\n    def is_default_port(self):\n        \"\"\"A check for default port.\n\n        Return True if port is default for specified scheme,\n        e.g. 'http://python.org' or 'http://python.org:80', False\n        otherwise.\n\n        \"\"\"\n        if self.port is None:\n            return False\n        default = DEFAULT_PORTS.get(self.scheme)\n        if default is None:\n            return False\n        return self.port == default\n\n    def origin(self):\n        \"\"\"Return an URL with scheme, host and port parts only.\n\n        user, password, path, query and fragment are removed.\n\n        \"\"\"\n        # TODO: add a keyword-only option for keeping user/pass maybe?\n        if not self.is_absolute():\n            raise ValueError(\"URL should be absolute\")\n        if not self._val.scheme:\n            raise ValueError(\"URL should have scheme\")\n        v = self._val\n        netloc = self._make_netloc(None, None, v.hostname, v.port)\n        val = v._replace(netloc=netloc, path=\"\", query=\"\", fragment=\"\")\n        return URL(val, encoded=True)\n\n    def relative(self):\n        \"\"\"Return a relative part of the URL.\n\n        scheme, user, password, host and port are removed.\n\n        \"\"\"\n        if not self.is_absolute():\n            raise ValueError(\"URL should be absolute\")\n        val = self._val._replace(scheme=\"\", netloc=\"\")\n        return URL(val, encoded=True)\n\n    @property\n    def scheme(self):\n        \"\"\"Scheme for absolute URLs.\n\n        Empty string for relative URLs or URLs starting with //\n\n        \"\"\"\n        return self._val.scheme\n\n    @property\n    def raw_authority(self):\n        \"\"\"Encoded authority part of URL.\n\n        Empty string for relative URLs.\n\n        \"\"\"\n        return self._val.netloc\n\n    @cached_property\n    def authority(self):\n        \"\"\"Decoded authority part of URL.\n\n        Empty string for relative URLs.\n\n        \"\"\"\n        return self._make_netloc(\n            self.user, self.password, self.host, self.port, encode_host=False\n        )\n\n    @property\n    def raw_user(self):\n        \"\"\"Encoded user part of URL.\n\n        None if user is missing.\n\n        \"\"\"\n        # not .username\n        ret = self._val.username\n        if not ret:\n            return None\n        return ret\n\n    @cached_property\n    def user(self):\n        \"\"\"Decoded user part of URL.\n\n        None if user is missing.\n\n        \"\"\"\n        return self._UNQUOTER(self.raw_user)\n\n    @property\n    def raw_password(self):\n        \"\"\"Encoded password part of URL.\n\n        None if password is missing.\n\n        \"\"\"\n        return self._val.password\n\n    @cached_property\n    def password(self):\n        \"\"\"Decoded password part of URL.\n\n        None if password is missing.\n\n        \"\"\"\n        return self._UNQUOTER(self.raw_password)\n\n    @property\n    def raw_host(self):\n        \"\"\"Encoded host part of URL.\n\n        None for relative URLs.\n\n        \"\"\"\n        # Use host instead of hostname for sake of shortness\n        # May add .hostname prop later\n        return self._val.hostname\n\n    @cached_property\n    def host(self):\n        \"\"\"Decoded host part of URL.\n\n        None for relative URLs.\n\n        \"\"\"\n        raw = self.raw_host\n        if raw is None:\n            return None\n        if \"%\" in raw:\n            # Hack for scoped IPv6 addresses like\n            # fe80::2%\u041f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0430\n            # presence of '%' sign means only IPv6 address, so idna is useless.\n            return raw\n        return _idna_decode(raw)\n\n    @property\n    def port(self):\n        \"\"\"Port part of URL, with scheme-based fallback.\n\n        None for relative URLs or URLs without explicit port and\n        scheme without default port substitution.\n\n        \"\"\"\n        return self._val.port or DEFAULT_PORTS.get(self._val.scheme)\n\n    @property\n    def explicit_port(self):\n        \"\"\"Port part of URL, without scheme-based fallback.\n\n        None for relative URLs or URLs without explicit port.\n\n        \"\"\"\n        return self._val.port\n\n    @property\n    def raw_path(self):\n        \"\"\"Encoded path of URL.\n\n        / for absolute URLs without path part.\n\n        \"\"\"\n        ret = self._val.path\n        if not ret and self.is_absolute():\n            ret = \"/\"\n        return ret\n\n    @cached_property\n    def path(self):\n        \"\"\"Decoded path of URL.\n\n        / for absolute URLs without path part.\n\n        \"\"\"\n        return self._PATH_UNQUOTER(self.raw_path)\n\n    @cached_property\n    def query(self):\n        \"\"\"A MultiDictProxy representing parsed query parameters in decoded\n        representation.\n\n        Empty value if URL has no query part.\n\n        \"\"\"\n        ret = MultiDict(parse_qsl(self.raw_query_string, keep_blank_values=True))\n        return MultiDictProxy(ret)\n\n    @property\n    def raw_query_string(self):\n        \"\"\"Encoded query part of URL.\n\n        Empty string if query is missing.\n\n        \"\"\"\n        return self._val.query\n\n    @cached_property\n    def query_string(self):\n        \"\"\"Decoded query part of URL.\n\n        Empty string if query is missing.\n\n        \"\"\"\n        return self._QS_UNQUOTER(self.raw_query_string)\n\n    @cached_property\n    def path_qs(self):\n        \"\"\"Decoded path of URL with query.\"\"\"\n        if not self.query_string:\n            return self.path\n        return f\"{self.path}?{self.query_string}\"\n\n    @cached_property\n    def raw_path_qs(self):\n        \"\"\"Encoded path of URL with query.\"\"\"\n        if not self.raw_query_string:\n            return self.raw_path\n        return f\"{self.raw_path}?{self.raw_query_string}\"\n\n    @property\n    def raw_fragment(self):\n        \"\"\"Encoded fragment part of URL.\n\n        Empty string if fragment is missing.\n\n        \"\"\"\n        return self._val.fragment\n\n    @cached_property\n    def fragment(self):\n        \"\"\"Decoded fragment part of URL.\n\n        Empty string if fragment is missing.\n\n        \"\"\"\n        return self._UNQUOTER(self.raw_fragment)\n\n    @cached_property\n    def raw_parts(self):\n        \"\"\"A tuple containing encoded *path* parts.\n\n        ('/',) for absolute URLs if *path* is missing.\n\n        \"\"\"\n        path = self._val.path\n        if self.is_absolute():\n            if not path:\n                parts = [\"/\"]\n            else:\n                parts = [\"/\"] + path[1:].split(\"/\")\n        else:\n            if path.startswith(\"/\"):\n                parts = [\"/\"] + path[1:].split(\"/\")\n            else:\n                parts = path.split(\"/\")\n        return tuple(parts)\n\n    @cached_property\n    def parts(self):\n        \"\"\"A tuple containing decoded *path* parts.\n\n        ('/',) for absolute URLs if *path* is missing.\n\n        \"\"\"\n        return tuple(self._UNQUOTER(part) for part in self.raw_parts)\n\n    @cached_property\n    def parent(self):\n        \"\"\"A new URL with last part of path removed and cleaned up query and\n        fragment.\n\n        \"\"\"\n        path = self.raw_path\n        if not path or path == \"/\":\n            if self.raw_fragment or self.raw_query_string:\n                return URL(self._val._replace(query=\"\", fragment=\"\"), encoded=True)\n            return self\n        parts = path.split(\"/\")\n        val = self._val._replace(path=\"/\".join(parts[:-1]), query=\"\", fragment=\"\")\n        return URL(val, encoded=True)\n\n    @cached_property\n    def raw_name(self):\n        \"\"\"The last part of raw_parts.\"\"\"\n        parts = self.raw_parts\n        if self.is_absolute():\n            parts = parts[1:]\n            if not parts:\n                return \"\"\n            else:\n                return parts[-1]\n        else:\n            return parts[-1]\n\n    @cached_property\n    def name(self):\n        \"\"\"The last part of parts.\"\"\"\n        return self._UNQUOTER(self.raw_name)\n\n    @cached_property\n    def raw_suffix(self):\n        name = self.raw_name\n        i = name.rfind(\".\")\n        if 0 < i < len(name) - 1:\n            return name[i:]\n        else:\n            return \"\"\n\n    @cached_property\n    def suffix(self):\n        return self._UNQUOTER(self.raw_suffix)\n\n    @cached_property\n    def raw_suffixes(self):\n        name = self.raw_name\n        if name.endswith(\".\"):\n            return ()\n        name = name.lstrip(\".\")\n        return tuple(\".\" + suffix for suffix in name.split(\".\")[1:])\n\n    @cached_property\n    def suffixes(self):\n        return tuple(self._UNQUOTER(suffix) for suffix in self.raw_suffixes)\n\n    @staticmethod\n    def _validate_authority_uri_abs_path(host, path):\n        \"\"\"Ensure that path in URL with authority starts with a leading slash.\n\n        Raise ValueError if not.\n        \"\"\"\n        if len(host) > 0 and len(path) > 0 and not path.startswith(\"/\"):\n            raise ValueError(\n                \"Path in a URL with authority should start with a slash ('/') if set\"\n            )\n\n    def _make_child(self, segments, encoded=False):\n        \"\"\"add segments to self._val.path, accounting for absolute vs relative paths\"\"\"\n        # keep the trailing slash if the last segment ends with /\n        parsed = [\"\"] if segments and segments[-1][-1:] == \"/\" else []\n        for seg in reversed(segments):\n            if not seg:\n                continue\n            if seg[0] == \"/\":\n                raise ValueError(\n                    f\"Appending path {seg!r} starting from slash is forbidden\"\n                )\n            seg = seg if encoded else self._PATH_QUOTER(seg)\n            if \"/\" in seg:\n                parsed += (\n                    sub for sub in reversed(seg.split(\"/\")) if sub and sub != \".\"\n                )\n            elif seg != \".\":\n                parsed.append(seg)\n        parsed.reverse()\n        old_path = self._val.path\n        if old_path:\n            parsed = [*old_path.rstrip(\"/\").split(\"/\"), *parsed]\n        if self.is_absolute():\n            parsed = _normalize_path_segments(parsed)\n            if parsed and parsed[0] != \"\":\n                # inject a leading slash when adding a path to an absolute URL\n                # where there was none before\n                parsed = [\"\", *parsed]\n        new_path = \"/\".join(parsed)\n        return URL(\n            self._val._replace(path=new_path, query=\"\", fragment=\"\"), encoded=True\n        )\n\n    @classmethod\n    def _normalize_path(cls, path):\n        # Drop '.' and '..' from str path\n\n        prefix = \"\"\n        if path.startswith(\"/\"):\n            # preserve the \"/\" root element of absolute paths, copying it to the\n            # normalised output as per sections 5.2.4 and 6.2.2.3 of rfc3986.\n            prefix = \"/\"\n            path = path[1:]\n\n        segments = path.split(\"/\")\n        return prefix + \"/\".join(_normalize_path_segments(segments))\n\n    @classmethod\n    def _encode_host(cls, host, human=False):\n        try:\n            ip, sep, zone = host.partition(\"%\")\n            ip = ip_address(ip)\n        except ValueError:\n            host = host.lower()\n            # IDNA encoding is slow,\n            # skip it for ASCII-only strings\n            # Don't move the check into _idna_encode() helper\n            # to reduce the cache size\n            if human or host.isascii():\n                return host\n            host = _idna_encode(host)\n        else:\n            host = ip.compressed\n            if sep:\n                host += \"%\" + zone\n            if ip.version == 6:\n                host = \"[\" + host + \"]\"\n        return host\n\n    @classmethod\n    def _make_netloc(\n        cls, user, password, host, port, encode=False, encode_host=True, requote=False\n    ):\n        quoter = cls._REQUOTER if requote else cls._QUOTER\n        if encode_host:\n            ret = cls._encode_host(host)\n        else:\n            ret = host\n        if port is not None:\n            ret = ret + \":\" + str(port)\n        if password is not None:\n            if not user:\n                user = \"\"\n            else:\n                if encode:\n                    user = quoter(user)\n            if encode:\n                password = quoter(password)\n            user = user + \":\" + password\n        elif user and encode:\n            user = quoter(user)\n        if user:\n            ret = user + \"@\" + ret\n        return ret\n\n    def with_scheme(self, scheme):\n        \"\"\"Return a new URL with scheme replaced.\"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if not isinstance(scheme, str):\n            raise TypeError(\"Invalid scheme type\")\n        if not self.is_absolute():\n            raise ValueError(\"scheme replacement is not allowed for relative URLs\")\n        return URL(self._val._replace(scheme=scheme.lower()), encoded=True)\n\n    def with_user(self, user):\n        \"\"\"Return a new URL with user replaced.\n\n        Autoencode user if needed.\n\n        Clear user/password if user is None.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        val = self._val\n        if user is None:\n            password = None\n        elif isinstance(user, str):\n            user = self._QUOTER(user)\n            password = val.password\n        else:\n            raise TypeError(\"Invalid user type\")\n        if not self.is_absolute():\n            raise ValueError(\"user replacement is not allowed for relative URLs\")\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(user, password, val.hostname, val.port)\n            ),\n            encoded=True,\n        )\n\n    def with_password(self, password):\n        \"\"\"Return a new URL with password replaced.\n\n        Autoencode password if needed.\n\n        Clear password if argument is None.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if password is None:\n            pass\n        elif isinstance(password, str):\n            password = self._QUOTER(password)\n        else:\n            raise TypeError(\"Invalid password type\")\n        if not self.is_absolute():\n            raise ValueError(\"password replacement is not allowed for relative URLs\")\n        val = self._val\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(val.username, password, val.hostname, val.port)\n            ),\n            encoded=True,\n        )\n\n    def with_host(self, host):\n        \"\"\"Return a new URL with host replaced.\n\n        Autoencode host if needed.\n\n        Changing host for relative URLs is not allowed, use .join()\n        instead.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if not isinstance(host, str):\n            raise TypeError(\"Invalid host type\")\n        if not self.is_absolute():\n            raise ValueError(\"host replacement is not allowed for relative URLs\")\n        if not host:\n            raise ValueError(\"host removing is not allowed\")\n        val = self._val\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(val.username, val.password, host, val.port)\n            ),\n            encoded=True,\n        )\n\n    def with_port(self, port):\n        \"\"\"Return a new URL with port replaced.\n\n        Clear port to default if None is passed.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if port is not None:\n            if isinstance(port, bool) or not isinstance(port, int):\n                raise TypeError(f\"port should be int or None, got {type(port)}\")\n            if port < 0 or port > 65535:\n                raise ValueError(f\"port must be between 0 and 65535, got {port}\")\n        if not self.is_absolute():\n            raise ValueError(\"port replacement is not allowed for relative URLs\")\n        val = self._val\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(val.username, val.password, val.hostname, port)\n            ),\n            encoded=True,\n        )\n\n    def with_path(self, path, *, encoded=False):\n        \"\"\"Return a new URL with path replaced.\"\"\"\n        if not encoded:\n            path = self._PATH_QUOTER(path)\n            if self.is_absolute():\n                path = self._normalize_path(path)\n        if len(path) > 0 and path[0] != \"/\":\n            path = \"/\" + path\n        return URL(self._val._replace(path=path, query=\"\", fragment=\"\"), encoded=True)\n\n    @classmethod\n    def _query_seq_pairs(cls, quoter, pairs):\n        for key, val in pairs:\n            if isinstance(val, (list, tuple)):\n                for v in val:\n                    yield quoter(key) + \"=\" + quoter(cls._query_var(v))\n            else:\n                yield quoter(key) + \"=\" + quoter(cls._query_var(val))\n\n    @staticmethod\n    def _query_var(v):\n        cls = type(v)\n        if issubclass(cls, str):\n            return v\n        if issubclass(cls, float):\n            if math.isinf(v):\n                raise ValueError(\"float('inf') is not supported\")\n            if math.isnan(v):\n                raise ValueError(\"float('nan') is not supported\")\n            return str(float(v))\n        if issubclass(cls, int) and cls is not bool:\n            return str(int(v))\n        raise TypeError(\n            \"Invalid variable type: value \"\n            \"should be str, int or float, got {!r} \"\n            \"of type {}\".format(v, cls)\n        )\n\n    def _get_str_query(self, *args, **kwargs):\n        if kwargs:\n            if len(args) > 0:\n                raise ValueError(\n                    \"Either kwargs or single query parameter must be present\"\n                )\n            query = kwargs\n        elif len(args) == 1:\n            query = args[0]\n        else:\n            raise ValueError(\"Either kwargs or single query parameter must be present\")\n\n        if query is None:\n            query = None\n        elif isinstance(query, Mapping):\n            quoter = self._QUERY_PART_QUOTER\n            query = \"&\".join(self._query_seq_pairs(quoter, query.items()))\n        elif isinstance(query, str):\n            query = self._QUERY_QUOTER(query)\n        elif isinstance(query, (bytes, bytearray, memoryview)):\n            raise TypeError(\n                \"Invalid query type: bytes, bytearray and memoryview are forbidden\"\n            )\n        elif isinstance(query, Sequence):\n            quoter = self._QUERY_PART_QUOTER\n            # We don't expect sequence values if we're given a list of pairs\n            # already; only mappings like builtin `dict` which can't have the\n            # same key pointing to multiple values are allowed to use\n            # `_query_seq_pairs`.\n            query = \"&\".join(\n                quoter(k) + \"=\" + quoter(self._query_var(v)) for k, v in query\n            )\n        else:\n            raise TypeError(\n                \"Invalid query type: only str, mapping or \"\n                \"sequence of (key, value) pairs is allowed\"\n            )\n\n        return query\n\n    def with_query(self, *args, **kwargs):\n        \"\"\"Return a new URL with query part replaced.\n\n        Accepts any Mapping (e.g. dict, multidict.MultiDict instances)\n        or str, autoencode the argument if needed.\n\n        A sequence of (key, value) pairs is supported as well.\n\n        It also can take an arbitrary number of keyword arguments.\n\n        Clear query if None is passed.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n\n        new_query = self._get_str_query(*args, **kwargs) or \"\"\n        return URL(\n            self._val._replace(path=self._val.path, query=new_query), encoded=True\n        )\n\n    def update_query(self, *args, **kwargs):\n        \"\"\"Return a new URL with query part updated.\"\"\"\n        s = self._get_str_query(*args, **kwargs)\n        query = None\n        if s is not None:\n            new_query = MultiDict(parse_qsl(s, keep_blank_values=True))\n            query = MultiDict(self.query)\n            query.update(new_query)\n\n        return URL(\n            self._val._replace(query=self._get_str_query(query) or \"\"), encoded=True\n        )\n\n    def with_fragment(self, fragment):\n        \"\"\"Return a new URL with fragment replaced.\n\n        Autoencode fragment if needed.\n\n        Clear fragment to default if None is passed.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if fragment is None:\n            raw_fragment = \"\"\n        elif not isinstance(fragment, str):\n            raise TypeError(\"Invalid fragment type\")\n        else:\n            raw_fragment = self._FRAGMENT_QUOTER(fragment)\n        if self.raw_fragment == raw_fragment:\n            return self\n        return URL(self._val._replace(fragment=raw_fragment), encoded=True)\n\n    def with_name(self, name):\n        \"\"\"Return a new URL with name (last part of path) replaced.\n\n        Query and fragment parts are cleaned up.\n\n        Name is encoded if needed.\n\n        \"\"\"\n        # N.B. DOES cleanup query/fragment\n        if not isinstance(name, str):\n            raise TypeError(\"Invalid name type\")\n        if \"/\" in name:\n            raise ValueError(\"Slash in name is not allowed\")\n        name = self._PATH_QUOTER(name)\n        if name in (\".\", \"..\"):\n            raise ValueError(\". and .. values are forbidden\")\n        parts = list(self.raw_parts)\n        if self.is_absolute():\n            if len(parts) == 1:\n                parts.append(name)\n            else:\n                parts[-1] = name\n            parts[0] = \"\"  # replace leading '/'\n        else:\n            parts[-1] = name\n            if parts[0] == \"/\":\n                parts[0] = \"\"  # replace leading '/'\n        return URL(\n            self._val._replace(path=\"/\".join(parts), query=\"\", fragment=\"\"),\n            encoded=True,\n        )\n\n    def with_suffix(self, suffix):\n        \"\"\"Return a new URL with suffix (file extension of name) replaced.\n\n        Query and fragment parts are cleaned up.\n\n        suffix is encoded if needed.\n        \"\"\"\n        if not isinstance(suffix, str):\n            raise TypeError(\"Invalid suffix type\")\n        if suffix and not suffix.startswith(\".\") or suffix == \".\":\n            raise ValueError(f\"Invalid suffix {suffix!r}\")\n        name = self.raw_name\n        if not name:\n            raise ValueError(f\"{self!r} has an empty name\")\n        old_suffix = self.raw_suffix\n        if not old_suffix:\n            name = name + suffix\n        else:\n            name = name[: -len(old_suffix)] + suffix\n        return self.with_name(name)\n\n    def join(self, url):\n        \"\"\"Join URLs\n\n        Construct a full (\u201cabsolute\u201d) URL by combining a \u201cbase URL\u201d\n        (self) with another URL (url).\n\n        Informally, this uses components of the base URL, in\n        particular the addressing scheme, the network location and\n        (part of) the path, to provide missing components in the\n        relative URL.\n\n        \"\"\"\n        # See docs for urllib.parse.urljoin\n        if not isinstance(url, URL):\n            raise TypeError(\"url should be URL\")\n        return URL(urljoin(str(self), str(url)), encoded=True)\n\n    def joinpath(self, *other, encoded=False):\n        \"\"\"Return a new URL with the elements in other appended to the path.\"\"\"\n        return self._make_child(other, encoded=encoded)\n\n    def human_repr(self):\n        \"\"\"Return decoded human readable string for URL representation.\"\"\"\n        user = _human_quote(self.user, \"#/:?@[]\")\n        password = _human_quote(self.password, \"#/:?@[]\")\n        host = self.host\n        if host:\n            host = self._encode_host(self.host, human=True)\n        path = _human_quote(self.path, \"#?\")\n        query_string = \"&\".join(\n            \"{}={}\".format(_human_quote(k, \"#&+;=\"), _human_quote(v, \"#&+;=\"))\n            for k, v in self.query.items()\n        )\n        fragment = _human_quote(self.fragment, \"\")\n        return urlunsplit(\n            SplitResult(\n                self.scheme,\n                self._make_netloc(\n                    user,\n                    password,\n                    host,\n                    self._val.port,\n                    encode_host=False,\n                ),\n                path,\n                query_string,\n                fragment,\n            )\n        )\n\n\ndef _human_quote(s, unsafe):\n    if not s:\n        return s\n    for c in \"%\" + unsafe:\n        if c in s:\n            s = s.replace(c, f\"%{ord(c):02X}\")\n    if s.isprintable():\n        return s\n    return \"\".join(c if c.isprintable() else quote(c) for c in s)\n\n\n_MAXCACHE = 256\n\n\n@functools.lru_cache(_MAXCACHE)\ndef _idna_decode(raw):\n    try:\n        return idna.decode(raw.encode(\"ascii\"))\n    except UnicodeError:  # e.g. '::1'\n        return raw.encode(\"ascii\").decode(\"idna\")\n\n\n@functools.lru_cache(_MAXCACHE)\ndef _idna_encode(host):\n    try:\n        return idna.encode(host, uts46=True).decode(\"ascii\")\n    except UnicodeError:\n        return host.encode(\"idna\").decode(\"ascii\")\n\n\n@rewrite_module\ndef cache_clear():\n    _idna_decode.cache_clear()\n    _idna_encode.cache_clear()\n\n\n@rewrite_module\ndef cache_info():\n    return {\n        \"idna_encode\": _idna_encode.cache_info(),\n        \"idna_decode\": _idna_decode.cache_info(),\n    }\n\n\n@rewrite_module\ndef cache_configure(*, idna_encode_size=_MAXCACHE, idna_decode_size=_MAXCACHE):\n    global _idna_decode, _idna_encode\n\n    _idna_encode = functools.lru_cache(idna_encode_size)(_idna_encode.__wrapped__)\n    _idna_decode = functools.lru_cache(idna_decode_size)(_idna_decode.__wrapped__)\n", "yarl/_quoting_py.py": "import codecs\nimport re\nfrom string import ascii_letters, ascii_lowercase, digits\nfrom typing import Optional, cast\n\nBASCII_LOWERCASE = ascii_lowercase.encode(\"ascii\")\nBPCT_ALLOWED = {f\"%{i:02X}\".encode(\"ascii\") for i in range(256)}\nGEN_DELIMS = \":/?#[]@\"\nSUB_DELIMS_WITHOUT_QS = \"!$'()*,\"\nSUB_DELIMS = SUB_DELIMS_WITHOUT_QS + \"+&=;\"\nRESERVED = GEN_DELIMS + SUB_DELIMS\nUNRESERVED = ascii_letters + digits + \"-._~\"\nALLOWED = UNRESERVED + SUB_DELIMS_WITHOUT_QS\n\n\n_IS_HEX = re.compile(b\"[A-Z0-9][A-Z0-9]\")\n_IS_HEX_STR = re.compile(\"[A-Fa-f0-9][A-Fa-f0-9]\")\n\nutf8_decoder = codecs.getincrementaldecoder(\"utf-8\")\n\n\nclass _Quoter:\n    def __init__(\n        self,\n        *,\n        safe: str = \"\",\n        protected: str = \"\",\n        qs: bool = False,\n        requote: bool = True,\n    ) -> None:\n        self._safe = safe\n        self._protected = protected\n        self._qs = qs\n        self._requote = requote\n\n    def __call__(self, val: Optional[str]) -> Optional[str]:\n        if val is None:\n            return None\n        if not isinstance(val, str):\n            raise TypeError(\"Argument should be str\")\n        if not val:\n            return \"\"\n        bval = cast(str, val).encode(\"utf8\", errors=\"ignore\")\n        ret = bytearray()\n        pct = bytearray()\n        safe = self._safe\n        safe += ALLOWED\n        if not self._qs:\n            safe += \"+&=;\"\n        safe += self._protected\n        bsafe = safe.encode(\"ascii\")\n        idx = 0\n        while idx < len(bval):\n            ch = bval[idx]\n            idx += 1\n\n            if pct:\n                if ch in BASCII_LOWERCASE:\n                    ch = ch - 32  # convert to uppercase\n                pct.append(ch)\n                if len(pct) == 3:  # pragma: no branch   # peephole optimizer\n                    buf = pct[1:]\n                    if not _IS_HEX.match(buf):\n                        ret.extend(b\"%25\")\n                        pct.clear()\n                        idx -= 2\n                        continue\n                    try:\n                        unquoted = chr(int(pct[1:].decode(\"ascii\"), base=16))\n                    except ValueError:\n                        ret.extend(b\"%25\")\n                        pct.clear()\n                        idx -= 2\n                        continue\n\n                    if unquoted in self._protected:\n                        ret.extend(pct)\n                    elif unquoted in safe:\n                        ret.append(ord(unquoted))\n                    else:\n                        ret.extend(pct)\n                    pct.clear()\n\n                # special case, if we have only one char after \"%\"\n                elif len(pct) == 2 and idx == len(bval):\n                    ret.extend(b\"%25\")\n                    pct.clear()\n                    idx -= 1\n\n                continue\n\n            elif ch == ord(\"%\") and self._requote:\n                pct.clear()\n                pct.append(ch)\n\n                # special case if \"%\" is last char\n                if idx == len(bval):\n                    ret.extend(b\"%25\")\n\n                continue\n\n            if self._qs:\n                if ch == ord(\" \"):\n                    ret.append(ord(\"+\"))\n                    continue\n            if ch in bsafe:\n                ret.append(ch)\n                continue\n\n            ret.extend((f\"%{ch:02X}\").encode(\"ascii\"))\n\n        ret2 = ret.decode(\"ascii\")\n        if ret2 == val:\n            return val\n        return ret2\n\n\nclass _Unquoter:\n    def __init__(self, *, unsafe: str = \"\", qs: bool = False) -> None:\n        self._unsafe = unsafe\n        self._qs = qs\n        self._quoter = _Quoter()\n        self._qs_quoter = _Quoter(qs=True)\n\n    def __call__(self, val: Optional[str]) -> Optional[str]:\n        if val is None:\n            return None\n        if not isinstance(val, str):\n            raise TypeError(\"Argument should be str\")\n        if not val:\n            return \"\"\n        decoder = cast(codecs.BufferedIncrementalDecoder, utf8_decoder())\n        ret = []\n        idx = 0\n        while idx < len(val):\n            ch = val[idx]\n            idx += 1\n            if ch == \"%\" and idx <= len(val) - 2:\n                pct = val[idx : idx + 2]\n                if _IS_HEX_STR.fullmatch(pct):\n                    b = bytes([int(pct, base=16)])\n                    idx += 2\n                    try:\n                        unquoted = decoder.decode(b)\n                    except UnicodeDecodeError:\n                        start_pct = idx - 3 - len(decoder.buffer) * 3\n                        ret.append(val[start_pct : idx - 3])\n                        decoder.reset()\n                        try:\n                            unquoted = decoder.decode(b)\n                        except UnicodeDecodeError:\n                            ret.append(val[idx - 3 : idx])\n                            continue\n                    if not unquoted:\n                        continue\n                    if self._qs and unquoted in \"+=&;\":\n                        to_add = self._qs_quoter(unquoted)\n                        if to_add is None:  # pragma: no cover\n                            raise RuntimeError(\"Cannot quote None\")\n                        ret.append(to_add)\n                    elif unquoted in self._unsafe:\n                        to_add = self._quoter(unquoted)\n                        if to_add is None:  # pragma: no cover\n                            raise RuntimeError(\"Cannot quote None\")\n                        ret.append(to_add)\n                    else:\n                        ret.append(unquoted)\n                    continue\n\n            if decoder.buffer:\n                start_pct = idx - 1 - len(decoder.buffer) * 3\n                ret.append(val[start_pct : idx - 1])\n                decoder.reset()\n\n            if ch == \"+\":\n                if not self._qs or ch in self._unsafe:\n                    ret.append(\"+\")\n                else:\n                    ret.append(\" \")\n                continue\n\n            if ch in self._unsafe:\n                ret.append(\"%\")\n                h = hex(ord(ch)).upper()[2:]\n                for ch in h:\n                    ret.append(ch)\n                continue\n\n            ret.append(ch)\n\n        if decoder.buffer:\n            ret.append(val[-len(decoder.buffer) * 3 :])\n\n        ret2 = \"\".join(ret)\n        if ret2 == val:\n            return val\n        return ret2\n", "yarl/__init__.py": "from ._url import URL, cache_clear, cache_configure, cache_info\n\n__version__ = \"1.9.5.dev0\"\n\n__all__ = (\"URL\", \"cache_clear\", \"cache_configure\", \"cache_info\")\n", "docs/conf.py": "#!/usr/bin/env python3\n#\n# yarl documentation build configuration file, created by\n# sphinx-quickstart on Mon Aug 29 19:55:36 2016.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n#\n# import os\n# import sys\n# sys.path.insert(0, os.path.abspath('.'))\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\n#\n# needs_sphinx = '1.0'\n\nimport os\nimport re\nfrom pathlib import Path\n\nPROJECT_ROOT_DIR = Path(__file__).parents[1].resolve()\nIS_RELEASE_ON_RTD = (\n    os.getenv(\"READTHEDOCS\", \"False\") == \"True\"\n    and os.environ[\"READTHEDOCS_VERSION_TYPE\"] == \"tag\"\n)\nif IS_RELEASE_ON_RTD:\n    tags.add(\"is_release\")\n\n\n_docs_path = Path(__file__).parent\n_version_path = _docs_path / \"../yarl/__init__.py\"\n\n\nwith _version_path.open() as fp:\n    try:\n        _version_info = re.search(\n            r\"^__version__ = \\\"\"\n            r\"(?P<major>\\d+)\"\n            r\"\\.(?P<minor>\\d+)\"\n            r\"\\.(?P<patch>\\d+)\"\n            r\"(?P<tag>.*)?\\\"$\",\n            fp.read(),\n            re.M,\n        ).groupdict()\n    except IndexError:\n        raise RuntimeError(\"Unable to determine version.\")\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    # stdlib-party extensions:\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.coverage\",\n    \"sphinx.ext.doctest\",\n    \"sphinx.ext.viewcode\",\n    # Third-party extensions:\n    \"alabaster\",\n    \"sphinxcontrib.towncrier.ext\",  # provides `towncrier-draft-entries` directive\n    \"myst_parser\",  # extended markdown; https://pypi.org/project/myst-parser/\n]\n\n\ntry:\n    import sphinxcontrib.spelling  # noqa\n\n    extensions.append(\"sphinxcontrib.spelling\")\nexcept ImportError:\n    pass\n\nintersphinx_mapping = {\n    \"python\": (\"https://docs.python.org/3\", None),\n    \"multidict\": (\"https://multidict.aio-libs.org/en/stable\", None),\n}\n\n\n# Add any paths that contain templates here, relative to this directory.\n# templates_path = ['_templates']\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n#\n# source_suffix = ['.rst', '.md']\n\n# The encoding of source files.\n#\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# -- Project information -----------------------------------------------------\n\ngithub_url = \"https://github.com\"\ngithub_repo_org = \"aio-libs\"\ngithub_repo_name = \"yarl\"\ngithub_repo_slug = f\"{github_repo_org}/{github_repo_name}\"\ngithub_repo_url = f\"{github_url}/{github_repo_slug}\"\ngithub_sponsors_url = f\"{github_url}/sponsors\"\n\nproject = github_repo_name\ncopyright = f\"2016, Andrew Svetlov, {project} contributors and aio-libs team\"\nauthor = \"Andrew Svetlov and aio-libs team\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = \"{major}.{minor}\".format(**_version_info)\n# The full version, including alpha/beta/rc tags.\nrelease = \"{major}.{minor}.{patch}-{tag}\".format(**_version_info)\n\nrst_epilog = f\"\"\"\n.. |project| replace:: {project}\n\"\"\"  # pylint: disable=invalid-name\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = \"en\"\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n#\n# today = ''\n#\n# Else, today_fmt is used as the format for a strftime call.\n#\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\n# This patterns also effect to html_static_path and html_extra_path\nexclude_patterns = [\"_build\", \"Thumbs.db\", \".DS_Store\"]\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n#\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n#\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n#\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n#\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n# -- Extension configuration -------------------------------------------------\n\n# -- Options for extlinks extension ---------------------------------------\nextlinks = {\n    \"issue\": (f\"{github_repo_url}/issues/%s\", \"#%s\"),\n    \"pr\": (f\"{github_repo_url}/pull/%s\", \"PR #%s\"),\n    \"commit\": (f\"{github_repo_url}/commit/%s\", \"%s\"),\n    \"gh\": (f\"{github_url}/%s\", \"GitHub: %s\"),\n    \"user\": (f\"{github_sponsors_url}/%s\", \"@%s\"),\n}\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n#\nhtml_theme = \"alabaster\"\n\nhtml_theme_options = {\n    \"logo\": \"yarl-icon-128x128.png\",\n    \"description\": \"Yet another URL library\",\n    \"github_user\": \"aio-libs\",\n    \"github_repo\": \"yarl\",\n    \"github_button\": True,\n    \"github_type\": \"star\",\n    \"github_banner\": True,\n    \"codecov_button\": True,\n    \"pre_bg\": \"#FFF6E5\",\n    \"note_bg\": \"#E5ECD1\",\n    \"note_border\": \"#BFCF8C\",\n    \"body_text\": \"#482C0A\",\n    \"sidebar_text\": \"#49443E\",\n    \"sidebar_header\": \"#4B4032\",\n    \"sidebar_collapse\": False,\n}\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\n#\n# html_theme_options = {}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.\n# \"<project> v<release> documentation\" by default.\n#\n# html_title = 'yarl v0.1.0'\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n#\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n#\n# html_logo = None\n\n# The name of an image file (relative to this directory) to use as a favicon of\n# the docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\n#\n# html_favicon = None\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"_static\"]\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n#\n# html_extra_path = []\n\n# If not None, a 'Last updated on:' timestamp is inserted at every page\n# bottom, using the given strftime format.\n# The empty string is equivalent to '%b %d, %Y'.\n#\n# html_last_updated_fmt = None\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n#\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n#\n# html_sidebars = {}\n\nhtml_sidebars = {\n    \"**\": [\n        \"about.html\",\n        \"navigation.html\",\n        \"searchbox.html\",\n    ]\n}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n#\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n#\n# html_domain_indices = True\n\n# If false, no index is generated.\n#\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n#\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n#\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n#\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n#\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n#\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'h', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'r', 'sv', 'tr', 'zh'\n#\n# html_search_language = 'en'\n\n# A dictionary with options for the search language support, empty by default.\n# 'ja' uses this config value.\n# 'zh' user can custom change `jieba` dictionary path.\n#\n# html_search_options = {'type': 'default'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n#\n# html_search_scorer = 'scorer.js'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"yarldoc\"\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements = {\n    # The paper size ('letterpaper' or 'a4paper').\n    #\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    #\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    #\n    # 'preamble': '',\n    # Latex figure (float) alignment\n    #\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (master_doc, \"yarl.tex\", \"yarl Documentation\", \"Andrew Svetlov\", \"manual\"),\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n#\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n#\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n#\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n#\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n#\n# latex_appendices = []\n\n# It false, will not define \\strong, \\code, \titleref, \\crossref ... but only\n# \\sphinxstrong, ..., \\sphinxtitleref, ... To help avoid clash with user added\n# packages.\n#\n# latex_keep_old_macro_names = True\n\n# If false, no module index is generated.\n#\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [(master_doc, \"yarl\", \"yarl Documentation\", [author], 1)]\n\n# If true, show URL addresses after external links.\n#\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        \"yarl\",\n        \"yarl Documentation\",\n        author,\n        \"yarl\",\n        \"One line description of project.\",\n        \"Miscellaneous\",\n    ),\n]\n\n# Documents to append as an appendix to all manuals.\n#\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n#\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n#\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n#\n# texinfo_no_detailmenu = False\n\ndefault_role = \"any\"\nnitpicky = True\nnitpick_ignore = [\n    (\"envvar\", \"TMPDIR\"),\n]\n\n# -- Options for towncrier_draft extension -----------------------------------\n\ntowncrier_draft_autoversion_mode = \"draft\"  # or: 'sphinx-version', 'sphinx-release'\ntowncrier_draft_include_empty = True\ntowncrier_draft_working_directory = PROJECT_ROOT_DIR\n# Not yet supported: towncrier_draft_config_path = 'pyproject.toml'  # relative to cwd\n", "tests/test_cached_property.py": "import pytest\n\nfrom yarl._url import cached_property\n\n\nclass A:\n    def __init__(self):\n        self._cache = {}\n\n    @cached_property\n    def prop(self):\n        \"\"\"Docstring.\"\"\"\n        return 1\n\n\ndef test_reify():\n    a = A()\n    assert 1 == a.prop\n\n\ndef test_reify_class():\n    assert isinstance(A.prop, cached_property)\n    assert \"Docstring.\" == A.prop.__doc__\n\n\ndef test_reify_assignment():\n    a = A()\n\n    with pytest.raises(AttributeError):\n        a.prop = 123\n", "tests/test_normalize_path.py": "import pytest\n\nfrom yarl import URL\n\nPATHS = [\n    # No dots\n    (\"\", \"\"),\n    (\"/\", \"/\"),\n    (\"//\", \"//\"),\n    (\"///\", \"///\"),\n    # Single-dot\n    (\"path/to\", \"path/to\"),\n    (\"././path/to\", \"path/to\"),\n    (\"path/./to\", \"path/to\"),\n    (\"path/././to\", \"path/to\"),\n    (\"path/to/.\", \"path/to/\"),\n    (\"path/to/./.\", \"path/to/\"),\n    # Double-dots\n    (\"../path/to\", \"path/to\"),\n    (\"path/../to\", \"to\"),\n    (\"path/../../to\", \"to\"),\n    # absolute path root / is maintained; tests based on two\n    # tests from web-platform-tests project's urltestdata.json\n    (\"/foo/../../../ton\", \"/ton\"),\n    (\"/foo/../../../..bar\", \"/..bar\"),\n    # Non-ASCII characters\n    (\"\u03bc\u03bf\u03bd\u03bf\u03c0\u03ac\u03c4\u03b9/../../\u03bd\u03b1/\u1d1c\u0274\u026a/\u1d04\u1d0f\u1d05\u1d07\", \"\u03bd\u03b1/\u1d1c\u0274\u026a/\u1d04\u1d0f\u1d05\u1d07\"),\n    (\"\u03bc\u03bf\u03bd\u03bf\u03c0\u03ac\u03c4\u03b9/../../\u03bd\u03b1/\ud835\udd66\ud835\udd5f\ud835\udd5a/\ud835\udd54\ud835\udd60\ud835\udd55\ud835\udd56/.\", \"\u03bd\u03b1/\ud835\udd66\ud835\udd5f\ud835\udd5a/\ud835\udd54\ud835\udd60\ud835\udd55\ud835\udd56/\"),\n]\n\n\n@pytest.mark.parametrize(\"original,expected\", PATHS)\ndef test__normalize_path(original, expected):\n    assert URL._normalize_path(original) == expected\n", "tests/test_url_parsing.py": "import sys\n\nimport pytest\n\nfrom yarl import URL\n\n\nclass TestScheme:\n    def test_scheme_path(self):\n        u = URL(\"scheme:path\")\n        assert u.scheme == \"scheme\"\n        assert u.host is None\n        assert u.path == \"path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_scheme_path_other(self):\n        u = URL(\"scheme:path:other\")\n        assert u.scheme == \"scheme\"\n        assert u.host is None\n        assert u.path == \"path:other\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_complex_scheme(self):\n        u = URL(\"allow+chars-33.:path\")\n        assert u.scheme == \"allow+chars-33.\"\n        assert u.host is None\n        assert u.path == \"path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_scheme_only(self):\n        u = URL(\"simple:\")\n        assert u.scheme == \"simple\"\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_no_scheme1(self):\n        u = URL(\"google.com:80\")\n        # See: https://bugs.python.org/issue27657\n        if sys.version_info[:3] == (3, 8, 1) or sys.version_info >= (3, 9, 0):\n            assert u.scheme == \"google.com\"\n            assert u.host is None\n            assert u.path == \"80\"\n        else:\n            assert u.scheme == \"\"\n            assert u.host is None\n            assert u.path == \"google.com:80\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_no_scheme2(self):\n        u = URL(\"google.com:80/root\")\n        assert u.scheme == \"google.com\"\n        assert u.host is None\n        assert u.path == \"80/root\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_not_a_scheme1(self):\n        u = URL(\"not_cheme:path\")\n        assert u.scheme == \"\"\n        assert u.host is None\n        assert u.path == \"not_cheme:path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_not_a_scheme2(self):\n        u = URL(\"signals37:book\")\n        assert u.scheme == \"signals37\"\n        assert u.host is None\n        assert u.path == \"book\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_scheme_rel_path1(self):\n        u = URL(\":relative-path\")\n        assert u.scheme == \"\"\n        assert u.host is None\n        assert u.path == \":relative-path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_scheme_rel_path2(self):\n        u = URL(\":relative/path\")\n        assert u.scheme == \"\"\n        assert u.host is None\n        assert u.path == \":relative/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_scheme_weird(self):\n        u = URL(\"://and-this\")\n        assert u.scheme == \"\"\n        assert u.host is None\n        assert u.path == \"://and-this\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n\nclass TestHost:\n    def test_canonical(self):\n        u = URL(\"scheme://host/path\")\n        assert u.scheme == \"scheme\"\n        assert u.host == \"host\"\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_absolute_no_scheme(self):\n        u = URL(\"//host/path\")\n        assert u.scheme == \"\"\n        assert u.host == \"host\"\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_absolute_no_scheme_complex_host(self):\n        u = URL(\"//host+path\")\n        assert u.scheme == \"\"\n        assert u.host == \"host+path\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_absolute_no_scheme_simple_host(self):\n        u = URL(\"//host\")\n        assert u.scheme == \"\"\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_weird_host(self):\n        u = URL(\"//this+is$also&host!\")\n        assert u.scheme == \"\"\n        assert u.host == \"this+is$also&host!\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_scheme_no_host(self):\n        u = URL(\"scheme:/host/path\")\n        assert u.scheme == \"scheme\"\n        assert u.host is None\n        assert u.path == \"/host/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_scheme_no_host2(self):\n        u = URL(\"scheme:///host/path\")\n        assert u.scheme == \"scheme\"\n        assert u.host is None\n        assert u.path == \"/host/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_no_scheme_no_host(self):\n        u = URL(\"scheme//host/path\")\n        assert u.scheme == \"\"\n        assert u.host is None\n        assert u.path == \"scheme//host/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_ipv4(self):\n        u = URL(\"//127.0.0.1/\")\n        assert u.scheme == \"\"\n        assert u.host == \"127.0.0.1\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_ipv6(self):\n        u = URL(\"//[::1]/\")\n        assert u.scheme == \"\"\n        assert u.host == \"::1\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_ipvfuture_address(self):\n        u = URL(\"//[v1.-1]/\")\n        assert u.scheme == \"\"\n        assert u.host == \"v1.-1\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n\nclass TestPort:\n    def test_canonical(self):\n        u = URL(\"//host:80/path\")\n        assert u.scheme == \"\"\n        assert u.host == \"host\"\n        assert u.port == 80\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_no_path(self):\n        u = URL(\"//host:80\")\n        assert u.scheme == \"\"\n        assert u.host == \"host\"\n        assert u.port == 80\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    @pytest.mark.xfail(\n        # FIXME: remove \"no cover\" pragmas upon xfail marker deletion\n        reason=\"https://github.com/aio-libs/yarl/issues/821\",\n        raises=ValueError,\n    )\n    def test_no_host(self):\n        u = URL(\"//:80\")\n        assert u.scheme == \"\"  # pragma: no cover\n        assert u.host == \"\"  # pragma: no cover\n        assert u.port == 80  # pragma: no cover\n        assert u.path == \"/\"  # pragma: no cover\n        assert u.query_string == \"\"  # pragma: no cover\n        assert u.fragment == \"\"  # pragma: no cover\n\n    def test_double_port(self):\n        with pytest.raises(ValueError):\n            URL(\"//h:22:80/\")\n\n    def test_bad_port(self):\n        with pytest.raises(ValueError):\n            URL(\"//h:no/path\")\n\n    def test_another_bad_port(self):\n        with pytest.raises(ValueError):\n            URL(\"//h:22:no/path\")\n\n    def test_bad_port_again(self):\n        with pytest.raises(ValueError):\n            URL(\"//h:-80/path\")\n\n\nclass TestUserInfo:\n    def test_canonical(self):\n        u = URL(\"sch://user@host/\")\n        assert u.scheme == \"sch\"\n        assert u.user == \"user\"\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_user_pass(self):\n        u = URL(\"//user:pass@host\")\n        assert u.scheme == \"\"\n        assert u.user == \"user\"\n        assert u.password == \"pass\"\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_complex_userinfo(self):\n        u = URL(\"//user:pas:and:more@host\")\n        assert u.scheme == \"\"\n        assert u.user == \"user\"\n        assert u.password == \"pas:and:more\"\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_no_user(self):\n        u = URL(\"//:pas:@host\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password == \"pas:\"\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_weird_user(self):\n        u = URL(\"//!($&')*+,;=@host\")\n        assert u.scheme == \"\"\n        assert u.user == \"!($&')*+,;=\"\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_weird_user2(self):\n        u = URL(\"//user@info@ya.ru\")\n        assert u.scheme == \"\"\n        assert u.user == \"user@info\"\n        assert u.password is None\n        assert u.host == \"ya.ru\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_weird_user3(self):\n        u = URL(\"//%5Bsome%5D@host\")\n        assert u.scheme == \"\"\n        assert u.user == \"[some]\"\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n\nclass TestQuery_String:\n    def test_simple(self):\n        u = URL(\"?query\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"query\"\n        assert u.fragment == \"\"\n\n    def test_scheme_query(self):\n        u = URL(\"http:?query\")\n        assert u.scheme == \"http\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"query\"\n        assert u.fragment == \"\"\n\n    def test_abs_url_query(self):\n        u = URL(\"//host?query\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"query\"\n        assert u.fragment == \"\"\n\n    def test_abs_url_path_query(self):\n        u = URL(\"//host/path?query\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/path\"\n        assert u.query_string == \"query\"\n        assert u.fragment == \"\"\n\n    def test_double_question_mark(self):\n        u = URL(\"//ho?st/path?query\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"ho\"\n        assert u.path == \"/\"\n        assert u.query_string == \"st/path?query\"\n        assert u.fragment == \"\"\n\n    def test_complex_query(self):\n        u = URL(\"?a://b:c@d.e/f?g#h\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"a://b:c@d.e/f?g\"\n        assert u.fragment == \"h\"\n\n    def test_query_in_fragment(self):\n        u = URL(\"#?query\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"?query\"\n\n\nclass TestFragment:\n    def test_simple(self):\n        u = URL(\"#frag\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"frag\"\n\n    def test_scheme_frag(self):\n        u = URL(\"http:#frag\")\n        assert u.scheme == \"http\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"frag\"\n\n    def test_host_frag(self):\n        u = URL(\"//host#frag\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"frag\"\n\n    def test_scheme_path_frag(self):\n        u = URL(\"//host/path#frag\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"frag\"\n\n    def test_scheme_query_frag(self):\n        u = URL(\"//host?query#frag\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"query\"\n        assert u.fragment == \"frag\"\n\n    def test_host_frag_query(self):\n        u = URL(\"//ho#st/path?query\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"ho\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"st/path?query\"\n\n    def test_complex_frag(self):\n        u = URL(\"#a://b:c@d.e/f?g#h\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"a://b:c@d.e/f?g#h\"\n\n\nclass TestStripEmptyParts:\n    def test_all_empty(self):\n        with pytest.raises(ValueError):\n            URL(\"//@:?#\")\n\n    def test_path_only(self):\n        u = URL(\"///path\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_user(self):\n        u = URL(\"//@host\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_port(self):\n        u = URL(\"//host:\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_port_and_path(self):\n        u = URL(\"//host:/\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host == \"host\"\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_path_only(self):\n        u = URL(\"/\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"/\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_relative_path_only(self):\n        u = URL(\"path\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_path(self):\n        u = URL(\"/path\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_query_with_path(self):\n        u = URL(\"/path?\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_query(self):\n        u = URL(\"?\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_query_with_frag(self):\n        u = URL(\"?#frag\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"frag\"\n\n    def test_path_empty_frag(self):\n        u = URL(\"/path#\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"/path\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n\n    def test_empty_path(self):\n        u = URL(\"#\")\n        assert u.scheme == \"\"\n        assert u.user is None\n        assert u.password is None\n        assert u.host is None\n        assert u.path == \"\"\n        assert u.query_string == \"\"\n        assert u.fragment == \"\"\n", "tests/test_url_build.py": "import pytest\n\nfrom yarl import URL\n\n# build classmethod\n\n\ndef test_build_without_arguments():\n    u = URL.build()\n    assert str(u) == \"\"\n\n\ndef test_build_simple():\n    u = URL.build(scheme=\"http\", host=\"127.0.0.1\")\n    assert str(u) == \"http://127.0.0.1\"\n\n\ndef test_build_with_scheme():\n    u = URL.build(scheme=\"blob\", path=\"path\")\n    assert str(u) == \"blob:path\"\n\n\ndef test_build_with_host():\n    u = URL.build(host=\"127.0.0.1\")\n    assert str(u) == \"//127.0.0.1\"\n    assert u == URL(\"//127.0.0.1\")\n\n\ndef test_build_with_scheme_and_host():\n    u = URL.build(scheme=\"http\", host=\"127.0.0.1\")\n    assert str(u) == \"http://127.0.0.1\"\n    assert u == URL(\"http://127.0.0.1\")\n\n\n@pytest.mark.parametrize(\n    (\"port\", \"exc\", \"match\"),\n    [\n        pytest.param(\n            8000,\n            ValueError,\n            r\"\"\"(?x)\n            ^\n            Can't\\ build\\ URL\\ with\\ \"port\"\\ but\\ without\\ \"host\"\\.\n            $\n            \"\"\",\n            id=\"port-only\",\n        ),\n        pytest.param(\n            \"\", TypeError, r\"^The port is required to be int\\.$\", id=\"port-str\"\n        ),\n    ],\n)\ndef test_build_with_port(port, exc, match):\n    print(match)\n    with pytest.raises(exc, match=match):\n        URL.build(port=port)\n\n\ndef test_build_with_user():\n    u = URL.build(scheme=\"http\", host=\"127.0.0.1\", user=\"foo\")\n    assert str(u) == \"http://foo@127.0.0.1\"\n\n\ndef test_build_with_user_password():\n    u = URL.build(scheme=\"http\", host=\"127.0.0.1\", user=\"foo\", password=\"bar\")\n    assert str(u) == \"http://foo:bar@127.0.0.1\"\n\n\ndef test_build_with_query_and_query_string():\n    with pytest.raises(ValueError):\n        URL.build(\n            scheme=\"http\",\n            host=\"127.0.0.1\",\n            user=\"foo\",\n            password=\"bar\",\n            port=8000,\n            path=\"/index.html\",\n            query=dict(arg=\"value1\"),\n            query_string=\"arg=value1\",\n            fragment=\"top\",\n        )\n\n\ndef test_build_with_all():\n    u = URL.build(\n        scheme=\"http\",\n        host=\"127.0.0.1\",\n        user=\"foo\",\n        password=\"bar\",\n        port=8000,\n        path=\"/index.html\",\n        query_string=\"arg=value1\",\n        fragment=\"top\",\n    )\n    assert str(u) == \"http://foo:bar@127.0.0.1:8000/index.html?arg=value1#top\"\n\n\ndef test_build_with_authority_and_host():\n    with pytest.raises(ValueError):\n        URL.build(authority=\"host.com\", host=\"example.com\")\n\n\ndef test_build_with_authority():\n    url = URL.build(scheme=\"http\", authority=\"\u0441\u0442\u0435\u043f\u0430\u043d:bar@host.com:8000\", path=\"path\")\n    assert (\n        str(url) == \"http://%D1%81%D1%82%D0%B5%D0%BF%D0%B0%D0%BD:bar@host.com:8000/path\"\n    )\n\n\ndef test_build_with_authority_without_encoding():\n    url = URL.build(\n        scheme=\"http\", authority=\"foo:bar@host.com:8000\", path=\"path\", encoded=True\n    )\n    assert str(url) == \"http://foo:bar@host.com:8000/path\"\n\n\ndef test_query_str():\n    u = URL.build(scheme=\"http\", host=\"127.0.0.1\", path=\"/\", query_string=\"arg=value1\")\n    assert str(u) == \"http://127.0.0.1/?arg=value1\"\n\n\ndef test_query_dict():\n    u = URL.build(scheme=\"http\", host=\"127.0.0.1\", path=\"/\", query=dict(arg=\"value1\"))\n\n    assert str(u) == \"http://127.0.0.1/?arg=value1\"\n\n\ndef test_build_path_quoting():\n    u = URL.build(\n        scheme=\"http\",\n        host=\"127.0.0.1\",\n        path=\"/\u0444\u043e\u0442\u043e\u0433\u0440\u0430\u0444\u0456\u044f.jpg\",\n        query=dict(arg=\"\u041f\u0440\u0438\u0432\u0456\u0442\"),\n    )\n\n    assert u == URL(\"http://127.0.0.1/\u0444\u043e\u0442\u043e\u0433\u0440\u0430\u0444\u0456\u044f.jpg?arg=\u041f\u0440\u0438\u0432\u0456\u0442\")\n    assert str(u) == (\n        \"http://127.0.0.1/\"\n        \"%D1%84%D0%BE%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D1%96%D1%8F.jpg?\"\n        \"arg=%D0%9F%D1%80%D0%B8%D0%B2%D1%96%D1%82\"\n    )\n\n\ndef test_build_query_quoting():\n    u = URL.build(\n        scheme=\"http\",\n        host=\"127.0.0.1\",\n        path=\"/\u0444\u043e\u0442\u043e\u0433\u0440\u0430\u0444\u0456\u044f.jpg\",\n        query=\"arg=\u041f\u0440\u0438\u0432\u0456\u0442\",\n    )\n\n    assert u == URL(\"http://127.0.0.1/\u0444\u043e\u0442\u043e\u0433\u0440\u0430\u0444\u0456\u044f.jpg?arg=\u041f\u0440\u0438\u0432\u0456\u0442\")\n    assert str(u) == (\n        \"http://127.0.0.1/\"\n        \"%D1%84%D0%BE%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D1%96%D1%8F.jpg?\"\n        \"arg=%D0%9F%D1%80%D0%B8%D0%B2%D1%96%D1%82\"\n    )\n\n\ndef test_build_query_only():\n    u = URL.build(query={\"key\": \"value\"})\n\n    assert str(u) == \"?key=value\"\n\n\ndef test_build_drop_dots():\n    u = URL.build(scheme=\"http\", host=\"example.com\", path=\"/path/../to\")\n    assert str(u) == \"http://example.com/to\"\n\n\ndef test_build_encode():\n    u = URL.build(\n        scheme=\"http\",\n        host=\"\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440\",\n        path=\"/\u0448\u043b\u044f\u0445/\u043a\u0440\u0438\u0457\u0432\u043a\u0430\",\n        query_string=\"\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447\",\n        fragment=\"\u0444\u0440\u0430\u0433\",\n    )\n    expected = (\n        \"http://xn----8sb1bdhvc.xn--j1amh\"\n        \"/%D1%88%D0%BB%D1%8F%D1%85/%D0%BA%D1%80%D0%B8%D1%97%D0%B2%D0%BA%D0%B0\"\n        \"?%D0%BA%D0%BB%D1%8E%D1%87=%D0%B7%D0%BD%D0%B0%D1%87\"\n        \"#%D1%84%D1%80%D0%B0%D0%B3\"\n    )\n    assert str(u) == expected\n\n\ndef test_build_already_encoded():\n    # resulting URL is invalid but not encoded\n    u = URL.build(\n        scheme=\"http\",\n        host=\"\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440\",\n        path=\"/\u0448\u043b\u044f\u0445/\u043a\u0440\u0438\u0457\u0432\u043a\u0430\",\n        query_string=\"\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447\",\n        fragment=\"\u0444\u0440\u0430\u0433\",\n        encoded=True,\n    )\n    assert str(u) == \"http://\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440/\u0448\u043b\u044f\u0445/\u043a\u0440\u0438\u0457\u0432\u043a\u0430?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447#\u0444\u0440\u0430\u0433\"\n\n\ndef test_build_percent_encoded():\n    u = URL.build(\n        scheme=\"http\",\n        host=\"%2d.org\",\n        user=\"u%2d\",\n        password=\"p%2d\",\n        path=\"/%2d\",\n        query_string=\"k%2d=v%2d\",\n        fragment=\"f%2d\",\n    )\n    assert str(u) == \"http://u%252d:p%252d@%2d.org/%252d?k%252d=v%252d#f%252d\"\n    assert u.raw_host == \"%2d.org\"\n    assert u.host == \"%2d.org\"\n    assert u.raw_user == \"u%252d\"\n    assert u.user == \"u%2d\"\n    assert u.raw_password == \"p%252d\"\n    assert u.password == \"p%2d\"\n    assert u.raw_authority == \"u%252d:p%252d@%2d.org\"\n    assert u.authority == \"u%2d:p%2d@%2d.org:80\"\n    assert u.raw_path == \"/%252d\"\n    assert u.path == \"/%2d\"\n    assert u.query == {\"k%2d\": \"v%2d\"}\n    assert u.raw_query_string == \"k%252d=v%252d\"\n    assert u.query_string == \"k%2d=v%2d\"\n    assert u.raw_fragment == \"f%252d\"\n    assert u.fragment == \"f%2d\"\n\n\ndef test_build_with_authority_percent_encoded():\n    u = URL.build(scheme=\"http\", authority=\"u%2d:p%2d@%2d.org\")\n    assert str(u) == \"http://u%252d:p%252d@%2d.org\"\n    assert u.raw_host == \"%2d.org\"\n    assert u.host == \"%2d.org\"\n    assert u.raw_user == \"u%252d\"\n    assert u.user == \"u%2d\"\n    assert u.raw_password == \"p%252d\"\n    assert u.password == \"p%2d\"\n    assert u.raw_authority == \"u%252d:p%252d@%2d.org\"\n    assert u.authority == \"u%2d:p%2d@%2d.org:80\"\n\n\ndef test_build_with_authority_percent_encoded_already_encoded():\n    u = URL.build(scheme=\"http\", authority=\"u%2d:p%2d@%2d.org\", encoded=True)\n    assert str(u) == \"http://u%2d:p%2d@%2d.org\"\n    assert u.raw_host == \"%2d.org\"\n    assert u.host == \"%2d.org\"\n    assert u.user == \"u-\"\n    assert u.raw_user == \"u%2d\"\n    assert u.password == \"p-\"\n    assert u.raw_password == \"p%2d\"\n    assert u.authority == \"u-:p-@%2d.org:80\"\n    assert u.raw_authority == \"u%2d:p%2d@%2d.org\"\n\n\ndef test_build_with_authority_with_path_with_leading_slash():\n    u = URL.build(scheme=\"http\", host=\"example.com\", path=\"/path_with_leading_slash\")\n    assert str(u) == \"http://example.com/path_with_leading_slash\"\n\n\ndef test_build_with_authority_with_empty_path():\n    u = URL.build(scheme=\"http\", host=\"example.com\", path=\"\")\n    assert str(u) == \"http://example.com\"\n\n\ndef test_build_with_authority_with_path_without_leading_slash():\n    with pytest.raises(ValueError):\n        URL.build(scheme=\"http\", host=\"example.com\", path=\"path_without_leading_slash\")\n\n\ndef test_build_with_none_host():\n    with pytest.raises(TypeError, match=\"NoneType is illegal for.*host\"):\n        URL.build(scheme=\"http\", host=None)\n\n\ndef test_build_with_none_path():\n    with pytest.raises(TypeError):\n        URL.build(scheme=\"http\", host=\"example.com\", path=None)\n\n\ndef test_build_with_none_query_string():\n    with pytest.raises(TypeError):\n        URL.build(scheme=\"http\", host=\"example.com\", query_string=None)\n\n\ndef test_build_with_none_fragment():\n    with pytest.raises(TypeError):\n        URL.build(scheme=\"http\", host=\"example.com\", fragment=None)\n", "tests/test_url_query.py": "from typing import List, Tuple\nfrom urllib.parse import parse_qs, urlencode\n\nimport pytest\nfrom multidict import MultiDict, MultiDictProxy\n\nfrom yarl import URL\n\n# ========================================\n# Basic chars in query values\n# ========================================\n\nURLS_WITH_BASIC_QUERY_VALUES: List[Tuple[URL, MultiDict]] = [\n    # Empty strings, keys and values\n    (\n        URL(\"http://example.com\"),\n        MultiDict(),\n    ),\n    (\n        URL(\"http://example.com?a=\"),\n        MultiDict([(\"a\", \"\")]),\n    ),\n    # ASCII chars\n    (\n        URL(\"http://example.com?a+b=c+d\"),\n        MultiDict({\"a b\": \"c d\"}),\n    ),\n    (\n        URL(\"http://example.com?a=1&b=2\"),\n        MultiDict([(\"a\", \"1\"), (\"b\", \"2\")]),\n    ),\n    (\n        URL(\"http://example.com?a=1&b=2&a=3\"),\n        MultiDict([(\"a\", \"1\"), (\"b\", \"2\"), (\"a\", \"3\")]),\n    ),\n    # Non-ASCI BMP chars\n    (\n        URL(\"http://example.com?\u043a\u043b\u044e\u0447=\u0437\u043d\u0430\u0447\"),\n        MultiDict({\"\u043a\u043b\u044e\u0447\": \"\u0437\u043d\u0430\u0447\"}),\n    ),\n    (\n        URL(\"http://example.com?foo=\u1d1c\u0274\u026a\u1d04\u1d0f\u1d05\u1d07\"),\n        MultiDict({\"foo\": \"\u1d1c\u0274\u026a\u1d04\u1d0f\u1d05\u1d07\"}),\n    ),\n    # Non-BMP chars\n    (\n        URL(\"http://example.com?bar=\ud835\udd66\ud835\udd5f\ud835\udd5a\ud835\udd54\ud835\udd60\ud835\udd55\ud835\udd56\"),\n        MultiDict({\"bar\": \"\ud835\udd66\ud835\udd5f\ud835\udd5a\ud835\udd54\ud835\udd60\ud835\udd55\ud835\udd56\"}),\n    ),\n]\n\n\n@pytest.mark.parametrize(\n    \"original_url, expected_query\",\n    URLS_WITH_BASIC_QUERY_VALUES,\n)\ndef test_query_basic_parsing(original_url, expected_query):\n    assert isinstance(original_url.query, MultiDictProxy)\n    assert original_url.query == expected_query\n\n\n@pytest.mark.parametrize(\n    \"original_url, expected_query\",\n    URLS_WITH_BASIC_QUERY_VALUES,\n)\ndef test_query_basic_update_query(original_url, expected_query):\n    new_url = original_url.update_query({})\n    assert new_url == original_url\n\n\ndef test_query_dont_unqoute_twice():\n    sample_url = \"http://base.place?\" + urlencode({\"a\": \"/////\"})\n    query = urlencode({\"url\": sample_url})\n    full_url = \"http://test_url.aha?\" + query\n\n    url = URL(full_url)\n    assert url.query[\"url\"] == sample_url\n\n\n# ========================================\n# Reserved chars in query values\n# ========================================\n\n# See https://github.com/python/cpython#87133, which introduced a new\n# `separator` keyword argument to `urllib.parse.parse_qs` (among others).\n# If the name doesn't exist as a variable in the function bytecode, the\n# test is expected to fail.\n_SEMICOLON_XFAIL = pytest.mark.xfail(\n    condition=\"separator\" not in parse_qs.__code__.co_varnames,\n    reason=(\n        \"Python versions < 3.8.8 and < 3.9.2 lack a fix for \"\n        'CVE-2021-23336 dropping \";\" as a valid query parameter separator, '\n        \"making this test fail.\"\n    ),\n    strict=True,\n)\n\n\nURLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES = [\n    # Ampersand\n    (URL(\"http://127.0.0.1/?a=10&b=20\"), 2, \"10\"),\n    (URL(\"http://127.0.0.1/?a=10%26b=20\"), 1, \"10&b=20\"),\n    (URL(\"http://127.0.0.1/?a=10%3Bb=20\"), 1, \"10;b=20\"),\n    # Semicolon, which is *not* a query parameter separator as of RFC3986\n    (URL(\"http://127.0.0.1/?a=10;b=20\"), 1, \"10;b=20\"),\n    (URL(\"http://127.0.0.1/?a=10%26b=20\"), 1, \"10&b=20\"),\n    (URL(\"http://127.0.0.1/?a=10%3Bb=20\"), 1, \"10;b=20\"),\n]\nURLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES_W_XFAIL = [\n    # Ampersand\n    *URLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES[:3],\n    # Semicolon, which is *not* a query parameter separator as of RFC3986\n    # Mark the first of these as expecting to fail on old Python patch releases.\n    pytest.param(*URLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES[3], marks=_SEMICOLON_XFAIL),\n    *URLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES[4:],\n]\n\n\n@pytest.mark.parametrize(\n    \"original_url, expected_query_len, expected_value_a\",\n    URLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES_W_XFAIL,\n)\ndef test_query_separators_from_parsing(\n    original_url,\n    expected_query_len,\n    expected_value_a,\n):\n    assert len(original_url.query) == expected_query_len\n    assert original_url.query[\"a\"] == expected_value_a\n\n\n@pytest.mark.parametrize(\n    \"original_url, expected_query_len, expected_value_a\",\n    URLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES_W_XFAIL,\n)\ndef test_query_separators_from_update_query(\n    original_url,\n    expected_query_len,\n    expected_value_a,\n):\n    new_url = original_url.update_query({\"c\": expected_value_a})\n    assert new_url.query[\"a\"] == expected_value_a\n    assert new_url.query[\"c\"] == expected_value_a\n\n\n@pytest.mark.parametrize(\n    \"original_url, expected_query_len, expected_value_a\",\n    URLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES,\n)\ndef test_query_separators_from_with_query(\n    original_url,\n    expected_query_len,\n    expected_value_a,\n):\n    new_url = original_url.with_query({\"c\": expected_value_a})\n    assert new_url.query[\"c\"] == expected_value_a\n\n\n@pytest.mark.parametrize(\n    \"original_url, expected_query_len, expected_value_a\",\n    URLS_WITH_RESERVED_CHARS_IN_QUERY_VALUES,\n)\ndef test_query_from_empty_update_query(\n    original_url,\n    expected_query_len,\n    expected_value_a,\n):\n    new_url = original_url.update_query({})\n\n    assert new_url.query[\"a\"] == original_url.query[\"a\"]\n\n    if \"b\" in original_url.query:\n        assert new_url.query[\"b\"] == original_url.query[\"b\"]\n", "tests/test_pickle.py": "import pickle\n\nfrom yarl import URL\n\n# serialize\n\n\ndef test_pickle():\n    u1 = URL(\"test\")\n    hash(u1)\n    v = pickle.dumps(u1)\n    u2 = pickle.loads(v)\n    assert u1._cache\n    assert not u2._cache\n    assert hash(u1) == hash(u2)\n\n\ndef test_default_style_state():\n    u = URL(\"test\")\n    hash(u)\n    u.__setstate__((None, {\"_val\": \"test\", \"_strict\": False, \"_cache\": {\"hash\": 1}}))\n    assert not u._cache\n    assert u._val == \"test\"\n", "tests/test_url_cmp_and_hash.py": "from yarl import URL\n\n# comparison and hashing\n\n\ndef test_ne_str():\n    url = URL(\"http://example.com/\")\n    assert url != \"http://example.com/\"\n\n\ndef test_eq():\n    url = URL(\"http://example.com/\")\n    assert url == URL(\"http://example.com/\")\n\n\ndef test_hash():\n    assert hash(URL(\"http://example.com/\")) == hash(URL(\"http://example.com/\"))\n\n\ndef test_hash_double_call():\n    url = URL(\"http://example.com/\")\n    assert hash(url) == hash(url)\n\n\ndef test_le_less():\n    url1 = URL(\"http://example1.com/\")\n    url2 = URL(\"http://example2.com/\")\n\n    assert url1 <= url2\n\n\ndef test_le_eq():\n    url1 = URL(\"http://example.com/\")\n    url2 = URL(\"http://example.com/\")\n\n    assert url1 <= url2\n\n\ndef test_le_not_implemented():\n    url = URL(\"http://example1.com/\")\n\n    assert url.__le__(123) is NotImplemented\n\n\ndef test_lt():\n    url1 = URL(\"http://example1.com/\")\n    url2 = URL(\"http://example2.com/\")\n\n    assert url1 < url2\n\n\ndef test_lt_not_implemented():\n    url = URL(\"http://example1.com/\")\n\n    assert url.__lt__(123) is NotImplemented\n\n\ndef test_ge_more():\n    url1 = URL(\"http://example1.com/\")\n    url2 = URL(\"http://example2.com/\")\n\n    assert url2 >= url1\n\n\ndef test_ge_eq():\n    url1 = URL(\"http://example.com/\")\n    url2 = URL(\"http://example.com/\")\n\n    assert url2 >= url1\n\n\ndef test_ge_not_implemented():\n    url = URL(\"http://example1.com/\")\n\n    assert url.__ge__(123) is NotImplemented\n\n\ndef test_gt():\n    url1 = URL(\"http://example1.com/\")\n    url2 = URL(\"http://example2.com/\")\n\n    assert url2 > url1\n\n\ndef test_gt_not_implemented():\n    url = URL(\"http://example1.com/\")\n\n    assert url.__gt__(123) is NotImplemented\n", "tests/test_url_update_netloc.py": "import pytest\n\nfrom yarl import URL\n\n# with_*\n\n\ndef test_with_scheme():\n    url = URL(\"http://example.com\")\n    assert str(url.with_scheme(\"https\")) == \"https://example.com\"\n\n\ndef test_with_scheme_uppercased():\n    url = URL(\"http://example.com\")\n    assert str(url.with_scheme(\"HTTPS\")) == \"https://example.com\"\n\n\ndef test_with_scheme_for_relative_url():\n    with pytest.raises(ValueError):\n        URL(\"path/to\").with_scheme(\"http\")\n\n\ndef test_with_scheme_invalid_type():\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        assert str(url.with_scheme(123))\n\n\ndef test_with_user():\n    url = URL(\"http://example.com\")\n    assert str(url.with_user(\"john\")) == \"http://john@example.com\"\n\n\ndef test_with_user_non_ascii():\n    url = URL(\"http://example.com\")\n    url2 = url.with_user(\"\u0431\u0430\u0436\u0430\u043d\")\n    assert url2.raw_user == \"%D0%B1%D0%B0%D0%B6%D0%B0%D0%BD\"\n    assert url2.user == \"\u0431\u0430\u0436\u0430\u043d\"\n    assert url2.raw_authority == \"%D0%B1%D0%B0%D0%B6%D0%B0%D0%BD@example.com\"\n    assert url2.authority == \"\u0431\u0430\u0436\u0430\u043d@example.com:80\"\n\n\ndef test_with_user_percent_encoded():\n    url = URL(\"http://example.com\")\n    url2 = url.with_user(\"%cf%80\")\n    assert url2.raw_user == \"%25cf%2580\"\n    assert url2.user == \"%cf%80\"\n    assert url2.raw_authority == \"%25cf%2580@example.com\"\n    assert url2.authority == \"%cf%80@example.com:80\"\n\n\ndef test_with_user_for_relative_url():\n    with pytest.raises(ValueError):\n        URL(\"path/to\").with_user(\"user\")\n\n\ndef test_with_user_invalid_type():\n    url = URL(\"http://example.com:123\")\n    with pytest.raises(TypeError):\n        url.with_user(123)\n\n\ndef test_with_user_None():\n    url = URL(\"http://john@example.com\")\n    assert str(url.with_user(None)) == \"http://example.com\"\n\n\ndef test_with_user_ipv6():\n    url = URL(\"http://john:pass@[::1]:8080/\")\n    assert str(url.with_user(None)) == \"http://[::1]:8080/\"\n\n\ndef test_with_user_None_when_password_present():\n    url = URL(\"http://john:pass@example.com\")\n    assert str(url.with_user(None)) == \"http://example.com\"\n\n\ndef test_with_password():\n    url = URL(\"http://john@example.com\")\n    assert str(url.with_password(\"pass\")) == \"http://john:pass@example.com\"\n\n\ndef test_with_password_ipv6():\n    url = URL(\"http://john:pass@[::1]:8080/\")\n    assert str(url.with_password(None)) == \"http://john@[::1]:8080/\"\n\n\ndef test_with_password_non_ascii():\n    url = URL(\"http://john@example.com\")\n    url2 = url.with_password(\"\u043f\u0430\u0440\u043e\u043b\u044c\")\n    assert url2.raw_password == \"%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C\"\n    assert url2.password == \"\u043f\u0430\u0440\u043e\u043b\u044c\"\n    assert url2.raw_authority == \"john:%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C@example.com\"\n    assert url2.authority == \"john:\u043f\u0430\u0440\u043e\u043b\u044c@example.com:80\"\n\n\ndef test_with_password_percent_encoded():\n    url = URL(\"http://john@example.com\")\n    url2 = url.with_password(\"%cf%80\")\n    assert url2.raw_password == \"%25cf%2580\"\n    assert url2.password == \"%cf%80\"\n    assert url2.raw_authority == \"john:%25cf%2580@example.com\"\n    assert url2.authority == \"john:%cf%80@example.com:80\"\n\n\ndef test_with_password_non_ascii_with_colon():\n    url = URL(\"http://john@example.com\")\n    url2 = url.with_password(\"\u043f:\u0430\")\n    assert url2.raw_password == \"%D0%BF%3A%D0%B0\"\n    assert url2.password == \"\u043f:\u0430\"\n\n\ndef test_with_password_for_relative_url():\n    with pytest.raises(ValueError):\n        URL(\"path/to\").with_password(\"pass\")\n\n\ndef test_with_password_None():\n    url = URL(\"http://john:pass@example.com\")\n    assert str(url.with_password(None)) == \"http://john@example.com\"\n\n\ndef test_with_password_invalid_type():\n    url = URL(\"http://example.com:123\")\n    with pytest.raises(TypeError):\n        url.with_password(123)\n\n\ndef test_with_password_and_empty_user():\n    url = URL(\"http://example.com\")\n    url2 = url.with_password(\"pass\")\n    assert url2.password == \"pass\"\n    assert url2.user is None\n    assert str(url2) == \"http://:pass@example.com\"\n\n\ndef test_from_str_with_host_ipv4():\n    url = URL(\"http://host:80\")\n    url = url.with_host(\"192.168.1.1\")\n    assert url.raw_host == \"192.168.1.1\"\n\n\ndef test_from_str_with_host_ipv6():\n    url = URL(\"http://host:80\")\n    url = url.with_host(\"::1\")\n    assert url.raw_host == \"::1\"\n\n\ndef test_with_host():\n    url = URL(\"http://example.com:123\")\n    assert str(url.with_host(\"example.org\")) == \"http://example.org:123\"\n\n\ndef test_with_host_empty():\n    url = URL(\"http://example.com:123\")\n    with pytest.raises(ValueError):\n        url.with_host(\"\")\n\n\ndef test_with_host_non_ascii():\n    url = URL(\"http://example.com:123\")\n    url2 = url.with_host(\"\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440\")\n    assert url2.raw_host == \"xn----8sb1bdhvc.xn--j1amh\"\n    assert url2.host == \"\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440\"\n    assert url2.raw_authority == \"xn----8sb1bdhvc.xn--j1amh:123\"\n    assert url2.authority == \"\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440:123\"\n\n\ndef test_with_host_percent_encoded():\n    url = URL(\"http://%25cf%2580%cf%80:%25cf%2580%cf%80@example.com:123\")\n    url2 = url.with_host(\"%cf%80.org\")\n    assert url2.raw_host == \"%cf%80.org\"\n    assert url2.host == \"%cf%80.org\"\n    assert url2.raw_authority == \"%25cf%2580%CF%80:%25cf%2580%CF%80@%cf%80.org:123\"\n    assert url2.authority == \"%cf%80\u03c0:%cf%80\u03c0@%cf%80.org:123\"\n\n\ndef test_with_host_for_relative_url():\n    with pytest.raises(ValueError):\n        URL(\"path/to\").with_host(\"example.com\")\n\n\ndef test_with_host_invalid_type():\n    url = URL(\"http://example.com:123\")\n    with pytest.raises(TypeError):\n        url.with_host(None)\n\n\ndef test_with_port():\n    url = URL(\"http://example.com\")\n    assert str(url.with_port(8888)) == \"http://example.com:8888\"\n\n\ndef test_with_port_with_no_port():\n    url = URL(\"http://example.com\")\n    assert str(url.with_port(None)) == \"http://example.com\"\n\n\ndef test_with_port_ipv6():\n    url = URL(\"http://[::1]:8080/\")\n    assert str(url.with_port(80)) == \"http://[::1]:80/\"\n\n\ndef test_with_port_keeps_query_and_fragment():\n    url = URL(\"http://example.com/?a=1#frag\")\n    assert str(url.with_port(8888)) == \"http://example.com:8888/?a=1#frag\"\n\n\ndef test_with_port_percent_encoded():\n    url = URL(\"http://user%name:pass%word@example.com/\")\n    assert str(url.with_port(808)) == \"http://user%25name:pass%25word@example.com:808/\"\n\n\ndef test_with_port_for_relative_url():\n    with pytest.raises(ValueError):\n        URL(\"path/to\").with_port(1234)\n\n\ndef test_with_port_invalid_type():\n    with pytest.raises(TypeError):\n        URL(\"http://example.com\").with_port(\"123\")\n    with pytest.raises(TypeError):\n        URL(\"http://example.com\").with_port(True)\n\n\ndef test_with_port_invalid_range():\n    with pytest.raises(ValueError):\n        URL(\"http://example.com\").with_port(-1)\n", "tests/test_update_query.py": "import enum\n\nimport pytest\nfrom multidict import MultiDict\n\nfrom yarl import URL\n\n# with_query\n\n\ndef test_with_query():\n    url = URL(\"http://example.com\")\n    assert str(url.with_query({\"a\": \"1\"})) == \"http://example.com/?a=1\"\n\n\ndef test_update_query():\n    url = URL(\"http://example.com/\")\n    assert str(url.update_query({\"a\": \"1\"})) == \"http://example.com/?a=1\"\n    assert str(URL(\"test\").update_query(a=1)) == \"test?a=1\"\n\n    url = URL(\"http://example.com/?foo=bar\")\n    expected_url = URL(\"http://example.com/?foo=bar&baz=foo\")\n\n    assert url.update_query({\"baz\": \"foo\"}) == expected_url\n    assert url.update_query(baz=\"foo\") == expected_url\n    assert url.update_query(\"baz=foo\") == expected_url\n\n\ndef test_update_query_with_args_and_kwargs():\n    url = URL(\"http://example.com/\")\n\n    with pytest.raises(ValueError):\n        url.update_query(\"a\", foo=\"bar\")\n\n\ndef test_update_query_with_multiple_args():\n    url = URL(\"http://example.com/\")\n\n    with pytest.raises(ValueError):\n        url.update_query(\"a\", \"b\")\n\n\ndef test_update_query_with_none_arg():\n    url = URL(\"http://example.com/?foo=bar&baz=foo\")\n    expected_url = URL(\"http://example.com/\")\n    assert url.update_query(None) == expected_url\n\n\ndef test_update_query_with_empty_dict():\n    url = URL(\"http://example.com/?foo=bar&baz=foo\")\n    assert url.update_query({}) == url\n\n\ndef test_with_query_list_of_pairs():\n    url = URL(\"http://example.com\")\n    assert str(url.with_query([(\"a\", \"1\")])) == \"http://example.com/?a=1\"\n\n\ndef test_with_query_list_non_pairs():\n    url = URL(\"http://example.com\")\n    with pytest.raises(ValueError):\n        url.with_query([\"a=1\", \"b=2\", \"c=3\"])\n\n\ndef test_with_query_kwargs():\n    url = URL(\"http://example.com\")\n    q = url.with_query(query=\"1\", query2=\"1\").query\n    assert q == dict(query=\"1\", query2=\"1\")\n\n\ndef test_with_query_kwargs_and_args_are_mutually_exclusive():\n    url = URL(\"http://example.com\")\n    with pytest.raises(ValueError):\n        url.with_query({\"a\": \"2\", \"b\": \"4\"}, a=\"1\")\n\n\ndef test_with_query_only_single_arg_is_supported():\n    url = URL(\"http://example.com\")\n    u1 = url.with_query(b=3)\n    u2 = URL(\"http://example.com/?b=3\")\n    assert u1 == u2\n    with pytest.raises(ValueError):\n        url.with_query(\"a=1\", \"a=b\")\n\n\ndef test_with_query_empty_dict():\n    url = URL(\"http://example.com/?a=b\")\n    new_url = url.with_query({})\n    assert new_url.query_string == \"\"\n    assert str(new_url) == \"http://example.com/\"\n\n\ndef test_with_query_empty_str():\n    url = URL(\"http://example.com/?a=b\")\n    assert str(url.with_query(\"\")) == \"http://example.com/\"\n\n\ndef test_with_query_empty_value():\n    url = URL(\"http://example.com/\")\n    assert str(url.with_query({\"a\": \"\"})) == \"http://example.com/?a=\"\n\n\ndef test_with_query_str():\n    url = URL(\"http://example.com\")\n    assert str(url.with_query(\"a=1&b=2\")) == \"http://example.com/?a=1&b=2\"\n\n\ndef test_with_query_str_non_ascii_and_spaces():\n    url = URL(\"http://example.com\")\n    url2 = url.with_query(\"a=1 2&b=\u0437\u043d\u0430\u0447\")\n    assert url2.raw_query_string == \"a=1+2&b=%D0%B7%D0%BD%D0%B0%D1%87\"\n    assert url2.query_string == \"a=1 2&b=\u0437\u043d\u0430\u0447\"\n\n\ndef test_with_query_int():\n    url = URL(\"http://example.com\")\n    assert url.with_query({\"a\": 1}) == URL(\"http://example.com/?a=1\")\n\n\ndef test_with_query_kwargs_int():\n    url = URL(\"http://example.com\")\n    assert url.with_query(b=2) == URL(\"http://example.com/?b=2\")\n\n\ndef test_with_query_list_int():\n    url = URL(\"http://example.com\")\n    assert str(url.with_query([(\"a\", 1)])) == \"http://example.com/?a=1\"\n\n\n@pytest.mark.parametrize(\n    (\"query\", \"expected\"),\n    [\n        pytest.param({\"a\": []}, \"\", id=\"empty list\"),\n        pytest.param({\"a\": ()}, \"\", id=\"empty tuple\"),\n        pytest.param({\"a\": [1]}, \"/?a=1\", id=\"single list\"),\n        pytest.param({\"a\": (1,)}, \"/?a=1\", id=\"single tuple\"),\n        pytest.param({\"a\": [1, 2]}, \"/?a=1&a=2\", id=\"list\"),\n        pytest.param({\"a\": (1, 2)}, \"/?a=1&a=2\", id=\"tuple\"),\n        pytest.param({\"a[]\": [1, 2]}, \"/?a%5B%5D=1&a%5B%5D=2\", id=\"key with braces\"),\n        pytest.param({\"&\": [1, 2]}, \"/?%26=1&%26=2\", id=\"quote key\"),\n        pytest.param({\"a\": [\"1\", 2]}, \"/?a=1&a=2\", id=\"mixed types\"),\n        pytest.param({\"&\": [\"=\", 2]}, \"/?%26=%3D&%26=2\", id=\"quote key and value\"),\n        pytest.param({\"a\": 1, \"b\": [2, 3]}, \"/?a=1&b=2&b=3\", id=\"single then list\"),\n        pytest.param({\"a\": [1, 2], \"b\": 3}, \"/?a=1&a=2&b=3\", id=\"list then single\"),\n        pytest.param({\"a\": [\"1&a=2\", 3]}, \"/?a=1%26a%3D2&a=3\", id=\"ampersand then int\"),\n        pytest.param({\"a\": [1, \"2&a=3\"]}, \"/?a=1&a=2%26a%3D3\", id=\"int then ampersand\"),\n    ],\n)\ndef test_with_query_sequence(query, expected):\n    url = URL(\"http://example.com\")\n    expected = \"http://example.com{expected}\".format_map(locals())\n    assert str(url.with_query(query)) == expected\n\n\n@pytest.mark.parametrize(\n    \"query\",\n    [\n        pytest.param({\"a\": [[1]]}, id=\"nested\"),\n        pytest.param([(\"a\", [1, 2])], id=\"tuple list\"),\n    ],\n)\ndef test_with_query_sequence_invalid_use(query):\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError, match=\"Invalid variable type\"):\n        url.with_query(query)\n\n\nclass _CStr(str):\n    pass\n\n\nclass _EmptyStrEr:\n    def __str__(self):\n        return \"\"  # pragma: no cover  # <-- this should never happen\n\n\nclass _CInt(int, _EmptyStrEr):\n    pass\n\n\nclass _CFloat(float, _EmptyStrEr):\n    pass\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        pytest.param(\"1\", \"1\", id=\"str\"),\n        pytest.param(_CStr(\"1\"), \"1\", id=\"custom str\"),\n        pytest.param(1, \"1\", id=\"int\"),\n        pytest.param(_CInt(1), \"1\", id=\"custom int\"),\n        pytest.param(1.1, \"1.1\", id=\"float\"),\n        pytest.param(_CFloat(1.1), \"1.1\", id=\"custom float\"),\n    ],\n)\ndef test_with_query_valid_type(value, expected):\n    url = URL(\"http://example.com\")\n    expected = \"http://example.com/?a={expected}\".format_map(locals())\n    assert str(url.with_query({\"a\": value})) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"exc_type\"),\n    [\n        pytest.param(True, TypeError, id=\"bool\"),\n        pytest.param(None, TypeError, id=\"none\"),\n        pytest.param(float(\"inf\"), ValueError, id=\"non-finite float\"),\n        pytest.param(float(\"nan\"), ValueError, id=\"NaN float\"),\n    ],\n)\ndef test_with_query_invalid_type(value, exc_type):\n    url = URL(\"http://example.com\")\n    with pytest.raises(exc_type):\n        url.with_query({\"a\": value})\n\n\n@pytest.mark.parametrize(\n    (\"value\", \"expected\"),\n    [\n        pytest.param(\"1\", \"1\", id=\"str\"),\n        pytest.param(_CStr(\"1\"), \"1\", id=\"custom str\"),\n        pytest.param(1, \"1\", id=\"int\"),\n        pytest.param(_CInt(1), \"1\", id=\"custom int\"),\n        pytest.param(1.1, \"1.1\", id=\"float\"),\n        pytest.param(_CFloat(1.1), \"1.1\", id=\"custom float\"),\n    ],\n)\ndef test_with_query_list_valid_type(value, expected):\n    url = URL(\"http://example.com\")\n    expected = \"http://example.com/?a={expected}\".format_map(locals())\n    assert str(url.with_query([(\"a\", value)])) == expected\n\n\n@pytest.mark.parametrize(\n    (\"value\"), [pytest.param(True, id=\"bool\"), pytest.param(None, id=\"none\")]\n)\ndef test_with_query_list_invalid_type(value):\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        url.with_query([(\"a\", value)])\n\n\ndef test_with_int_enum():\n    class IntEnum(int, enum.Enum):\n        A = 1\n\n    url = URL(\"http://example.com/path\")\n    url2 = url.with_query(a=IntEnum.A)\n    assert str(url2) == \"http://example.com/path?a=1\"\n\n\ndef test_with_float_enum():\n    class FloatEnum(float, enum.Enum):\n        A = 1.1\n\n    url = URL(\"http://example.com/path\")\n    url2 = url.with_query(a=FloatEnum.A)\n    assert str(url2) == \"http://example.com/path?a=1.1\"\n\n\ndef test_with_query_multidict():\n    url = URL(\"http://example.com/path\")\n    q = MultiDict([(\"a\", \"b\"), (\"c\", \"d\")])\n    assert str(url.with_query(q)) == \"http://example.com/path?a=b&c=d\"\n\n\ndef test_with_multidict_with_spaces_and_non_ascii():\n    url = URL(\"http://example.com\")\n    url2 = url.with_query({\"a b\": \"\u044e \u0431\"})\n    assert url2.raw_query_string == \"a+b=%D1%8E+%D0%B1\"\n\n\ndef test_with_query_multidict_with_unsafe():\n    url = URL(\"http://example.com/path\")\n    url2 = url.with_query({\"a+b\": \"?=+&;\"})\n    assert url2.raw_query_string == \"a%2Bb=?%3D%2B%26%3B\"\n    assert url2.query_string == \"a%2Bb=?%3D%2B%26%3B\"\n    assert url2.query == {\"a+b\": \"?=+&;\"}\n\n\ndef test_with_query_None():\n    url = URL(\"http://example.com/path?a=b\")\n    assert url.with_query(None).query_string == \"\"\n\n\ndef test_with_query_bad_type():\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        url.with_query(123)\n\n\ndef test_with_query_bytes():\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        url.with_query(b\"123\")\n\n\ndef test_with_query_bytearray():\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        url.with_query(bytearray(b\"123\"))\n\n\ndef test_with_query_memoryview():\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        url.with_query(memoryview(b\"123\"))\n\n\n@pytest.mark.parametrize(\n    (\"query\", \"expected\"),\n    [\n        pytest.param([(\"key\", \"1;2;3\")], \"?key=1%3B2%3B3\", id=\"tuple list semicolon\"),\n        pytest.param({\"key\": \"1;2;3\"}, \"?key=1%3B2%3B3\", id=\"mapping semicolon\"),\n        pytest.param([(\"key\", \"1&a=2\")], \"?key=1%26a%3D2\", id=\"tuple list ampersand\"),\n        pytest.param({\"key\": \"1&a=2\"}, \"?key=1%26a%3D2\", id=\"mapping ampersand\"),\n        pytest.param([(\"&\", \"=\")], \"?%26=%3D\", id=\"tuple list quote key\"),\n        pytest.param({\"&\": \"=\"}, \"?%26=%3D\", id=\"mapping quote key\"),\n        pytest.param(\n            [(\"a[]\", \"3\")],\n            \"?a%5B%5D=3\",\n            id=\"quote one key braces\",\n        ),\n        pytest.param(\n            [(\"a[]\", \"3\"), (\"a[]\", \"4\")],\n            \"?a%5B%5D=3&a%5B%5D=4\",\n            id=\"quote many key braces\",\n        ),\n    ],\n)\ndef test_with_query_params(query, expected):\n    url = URL(\"http://example.com/get\")\n    url2 = url.with_query(query)\n    assert str(url2) == (\"http://example.com/get\" + expected)\n\n\ndef test_with_query_only():\n    url = URL()\n    url2 = url.with_query(key=\"value\")\n    assert str(url2) == \"?key=value\"\n\n\ndef test_with_query_complex_url():\n    target_url = \"http://example.com/?game=bulls+%26+cows\"\n    url = URL(\"/redir\").with_query({\"t\": target_url})\n    assert url.query[\"t\"] == target_url\n\n\ndef test_update_query_multiple_keys():\n    url = URL(\"http://example.com/path?a=1&a=2\")\n    u2 = url.update_query([(\"a\", \"3\"), (\"a\", \"4\")])\n\n    assert str(u2) == \"http://example.com/path?a=3&a=4\"\n\n\n# mod operator\n\n\ndef test_update_query_with_mod_operator():\n    url = URL(\"http://example.com/\")\n    assert str(url % {\"a\": \"1\"}) == \"http://example.com/?a=1\"\n    assert str(url % [(\"a\", \"1\")]) == \"http://example.com/?a=1\"\n    assert str(url % \"a=1&b=2\") == \"http://example.com/?a=1&b=2\"\n    assert str(url % {\"a\": \"1\"} % {\"b\": \"2\"}) == \"http://example.com/?a=1&b=2\"\n    assert str(url % {\"a\": \"1\"} % {\"a\": \"3\", \"b\": \"2\"}) == \"http://example.com/?a=3&b=2\"\n    assert str(url / \"foo\" % {\"a\": \"1\"}) == \"http://example.com/foo?a=1\"\n", "tests/test_url.py": "from enum import Enum\nfrom urllib.parse import SplitResult\n\nimport pytest\n\nfrom yarl import URL\n\n\ndef test_inheritance():\n    with pytest.raises(TypeError) as ctx:\n\n        class MyURL(URL):  # type: ignore[misc]\n            pass\n\n    assert (\n        \"Inheriting a class \"\n        \"<class 'test_url.test_inheritance.<locals>.MyURL'> \"\n        \"from URL is forbidden\" == str(ctx.value)\n    )\n\n\ndef test_str_subclass():\n    class S(str):\n        pass\n\n    assert str(URL(S(\"http://example.com\"))) == \"http://example.com\"\n\n\ndef test_is():\n    u1 = URL(\"http://example.com\")\n    u2 = URL(u1)\n    assert u1 is u2\n\n\ndef test_bool():\n    assert URL(\"http://example.com\")\n    assert not URL()\n    assert not URL(\"\")\n\n\ndef test_absolute_url_without_host():\n    with pytest.raises(ValueError):\n        URL(\"http://:8080/\")\n\n\ndef test_url_is_not_str():\n    url = URL(\"http://example.com\")\n    assert not isinstance(url, str)\n\n\ndef test_str():\n    url = URL(\"http://example.com:8888/path/to?a=1&b=2\")\n    assert str(url) == \"http://example.com:8888/path/to?a=1&b=2\"\n\n\ndef test_repr():\n    url = URL(\"http://example.com\")\n    assert \"URL('http://example.com')\" == repr(url)\n\n\ndef test_origin():\n    url = URL(\"http://user:password@example.com:8888/path/to?a=1&b=2\")\n    assert URL(\"http://example.com:8888\") == url.origin()\n\n\ndef test_origin_nonascii():\n    url = URL(\"http://user:password@\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440:8888/path/to?a=1&b=2\")\n    assert str(url.origin()) == \"http://xn----8sb1bdhvc.xn--j1amh:8888\"\n\n\ndef test_origin_ipv6():\n    url = URL(\"http://user:password@[::1]:8888/path/to?a=1&b=2\")\n    assert str(url.origin()) == \"http://[::1]:8888\"\n\n\ndef test_origin_not_absolute_url():\n    url = URL(\"/path/to?a=1&b=2\")\n    with pytest.raises(ValueError):\n        url.origin()\n\n\ndef test_origin_no_scheme():\n    url = URL(\"//user:password@example.com:8888/path/to?a=1&b=2\")\n    with pytest.raises(ValueError):\n        url.origin()\n\n\ndef test_drop_dots():\n    u = URL(\"http://example.com/path/../to\")\n    assert str(u) == \"http://example.com/to\"\n\n\ndef test_abs_cmp():\n    assert URL(\"http://example.com:8888\") == URL(\"http://example.com:8888\")\n    assert URL(\"http://example.com:8888/\") == URL(\"http://example.com:8888/\")\n    assert URL(\"http://example.com:8888/\") == URL(\"http://example.com:8888\")\n    assert URL(\"http://example.com:8888\") == URL(\"http://example.com:8888/\")\n\n\ndef test_abs_hash():\n    url = URL(\"http://example.com:8888\")\n    url_trailing = URL(\"http://example.com:8888/\")\n    assert hash(url) == hash(url_trailing)\n\n\n# properties\n\n\ndef test_scheme():\n    url = URL(\"http://example.com\")\n    assert \"http\" == url.scheme\n\n\ndef test_raw_user():\n    url = URL(\"http://user@example.com\")\n    assert \"user\" == url.raw_user\n\n\ndef test_raw_user_non_ascii():\n    url = URL(\"http://\u0431\u0430\u0436\u0430\u043d@example.com\")\n    assert \"%D0%B1%D0%B0%D0%B6%D0%B0%D0%BD\" == url.raw_user\n\n\ndef test_no_user():\n    url = URL(\"http://example.com\")\n    assert url.user is None\n\n\ndef test_user_non_ascii():\n    url = URL(\"http://\u0431\u0430\u0436\u0430\u043d@example.com\")\n    assert \"\u0431\u0430\u0436\u0430\u043d\" == url.user\n\n\ndef test_raw_password():\n    url = URL(\"http://user:password@example.com\")\n    assert \"password\" == url.raw_password\n\n\ndef test_raw_password_non_ascii():\n    url = URL(\"http://user:\u043f\u0430\u0440\u043e\u043b\u044c@example.com\")\n    assert \"%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C\" == url.raw_password\n\n\ndef test_password_non_ascii():\n    url = URL(\"http://user:\u043f\u0430\u0440\u043e\u043b\u044c@example.com\")\n    assert \"\u043f\u0430\u0440\u043e\u043b\u044c\" == url.password\n\n\ndef test_password_without_user():\n    url = URL(\"http://:password@example.com\")\n    assert url.user is None\n    assert \"password\" == url.password\n\n\ndef test_user_empty_password():\n    url = URL(\"http://user:@example.com\")\n    assert \"user\" == url.user\n    assert \"\" == url.password\n\n\ndef test_raw_host():\n    url = URL(\"http://example.com\")\n    assert \"example.com\" == url.raw_host\n\n\ndef test_raw_host_non_ascii():\n    url = URL(\"http://\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440\")\n    assert \"xn----8sb1bdhvc.xn--j1amh\" == url.raw_host\n\n\ndef test_host_non_ascii():\n    url = URL(\"http://\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440\")\n    assert \"\u043e\u0443\u043d-\u0443\u043f\u0430.\u0443\u043a\u0440\" == url.host\n\n\ndef test_localhost():\n    url = URL(\"http://[::1]\")\n    assert \"::1\" == url.host\n\n\ndef test_host_with_underscore():\n    url = URL(\"http://abc_def.com\")\n    assert \"abc_def.com\" == url.host\n\n\ndef test_raw_host_when_port_is_specified():\n    url = URL(\"http://example.com:8888\")\n    assert \"example.com\" == url.raw_host\n\n\ndef test_raw_host_from_str_with_ipv4():\n    url = URL(\"http://127.0.0.1:80\")\n    assert url.raw_host == \"127.0.0.1\"\n\n\ndef test_raw_host_from_str_with_ipv6():\n    url = URL(\"http://[::1]:80\")\n    assert url.raw_host == \"::1\"\n\n\ndef test_authority_full() -> None:\n    url = URL(\"http://user:passwd@host.com:8080/path\")\n    assert url.raw_authority == \"user:passwd@host.com:8080\"\n    assert url.authority == \"user:passwd@host.com:8080\"\n\n\ndef test_authority_short() -> None:\n    url = URL(\"http://host.com/path\")\n    assert url.raw_authority == \"host.com\"\n\n\ndef test_authority_full_nonasci() -> None:\n    url = URL(\"http://\u0441\u0442\u0435\u043f\u0430\u043d:\u043f\u0430\u0440\u043e\u043b\u044c@\u0441\u043b\u0430\u0432\u0430.\u0443\u043a\u0440:8080/path\")\n    assert url.raw_authority == (\n        \"%D1%81%D1%82%D0%B5%D0%BF%D0%B0%D0%BD:\"\n        \"%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C@\"\n        \"xn--80aaf8a3a.xn--j1amh:8080\"\n    )\n    assert url.authority == \"\u0441\u0442\u0435\u043f\u0430\u043d:\u043f\u0430\u0440\u043e\u043b\u044c@\u0441\u043b\u0430\u0432\u0430.\u0443\u043a\u0440:8080\"\n\n\ndef test_lowercase():\n    url = URL(\"http://gitHUB.com\")\n    assert url.raw_host == \"github.com\"\n    assert url.host == url.raw_host\n\n\ndef test_lowercase_nonascii():\n    url = URL(\"http://\u0421\u043b\u0430\u0432\u0430.\u0423\u043a\u0440\")\n    assert url.raw_host == \"xn--80aaf8a3a.xn--j1amh\"\n    assert url.host == \"\u0441\u043b\u0430\u0432\u0430.\u0443\u043a\u0440\"\n\n\ndef test_compressed_ipv6():\n    url = URL(\"http://[1DEC:0:0:0::1]\")\n    assert url.raw_host == \"1dec::1\"\n    assert url.host == url.raw_host\n\n\ndef test_ipv4_zone():\n    # I'm unsure if it is correct.\n    url = URL(\"http://1.2.3.4%\u0442\u0435\u0441\u0442%42:123\")\n    assert url.raw_host == \"1.2.3.4%\u0442\u0435\u0441\u0442%42\"\n    assert url.host == url.raw_host\n\n\ndef test_port_for_explicit_port():\n    url = URL(\"http://example.com:8888\")\n    assert 8888 == url.port\n\n\ndef test_port_for_implicit_port():\n    url = URL(\"http://example.com\")\n    assert 80 == url.port\n\n\ndef test_port_for_relative_url():\n    url = URL(\"/path/to\")\n    assert url.port is None\n\n\ndef test_port_for_unknown_scheme():\n    url = URL(\"unknown://example.com\")\n    assert url.port is None\n\n\ndef test_explicit_port_for_explicit_port():\n    url = URL(\"http://example.com:8888\")\n    assert 8888 == url.explicit_port\n\n\ndef test_explicit_port_for_implicit_port():\n    url = URL(\"http://example.com\")\n    assert url.explicit_port is None\n\n\ndef test_explicit_port_for_relative_url():\n    url = URL(\"/path/to\")\n    assert url.explicit_port is None\n\n\ndef test_explicit_port_for_unknown_scheme():\n    url = URL(\"unknown://example.com\")\n    assert url.explicit_port is None\n\n\ndef test_raw_path_string_empty():\n    url = URL(\"http://example.com\")\n    assert \"/\" == url.raw_path\n\n\ndef test_raw_path():\n    url = URL(\"http://example.com/path/to\")\n    assert \"/path/to\" == url.raw_path\n\n\ndef test_raw_path_non_ascii():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438\")\n    assert \"/%D1%88%D0%BB%D1%8F%D1%85/%D1%81%D1%8E%D0%B4%D0%B8\" == url.raw_path\n\n\ndef test_path_non_ascii():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438\")\n    assert \"/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438\" == url.path\n\n\ndef test_path_with_spaces():\n    url = URL(\"http://example.com/a b/test\")\n    assert \"/a b/test\" == url.path\n\n    url = URL(\"http://example.com/a b\")\n    assert \"/a b\" == url.path\n\n\ndef test_raw_path_for_empty_url():\n    url = URL()\n    assert \"\" == url.raw_path\n\n\ndef test_raw_path_for_colon_and_at():\n    url = URL(\"http://example.com/path:abc@123\")\n    assert url.raw_path == \"/path:abc@123\"\n\n\ndef test_raw_query_string():\n    url = URL(\"http://example.com?a=1&b=2\")\n    assert url.raw_query_string == \"a=1&b=2\"\n\n\ndef test_raw_query_string_non_ascii():\n    url = URL(\"http://example.com?\u0431=\u0432&\u044e=\u043a\")\n    assert url.raw_query_string == \"%D0%B1=%D0%B2&%D1%8E=%D0%BA\"\n\n\ndef test_query_string_non_ascii():\n    url = URL(\"http://example.com?\u0431=\u0432&\u044e=\u043a\")\n    assert url.query_string == \"\u0431=\u0432&\u044e=\u043a\"\n\n\ndef test_path_qs():\n    url = URL(\"http://example.com/\")\n    assert url.path_qs == \"/\"\n    url = URL(\"http://example.com/?\u0431=\u0432&\u044e=\u043a\")\n    assert url.path_qs == \"/?\u0431=\u0432&\u044e=\u043a\"\n    url = URL(\"http://example.com/path?\u0431=\u0432&\u044e=\u043a\")\n    assert url.path_qs == \"/path?\u0431=\u0432&\u044e=\u043a\"\n\n\ndef test_raw_path_qs():\n    url = URL(\"http://example.com/\")\n    assert url.raw_path_qs == \"/\"\n    url = URL(\"http://example.com/?\u0431=\u0432&\u044e=\u043a\")\n    assert url.raw_path_qs == \"/?%D0%B1=%D0%B2&%D1%8E=%D0%BA\"\n    url = URL(\"http://example.com/path?\u0431=\u0432&\u044e=\u043a\")\n    assert url.raw_path_qs == \"/path?%D0%B1=%D0%B2&%D1%8E=%D0%BA\"\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445?a=1&b=2\")\n    assert url.raw_path_qs == \"/%D1%88%D0%BB%D1%8F%D1%85?a=1&b=2\"\n\n\ndef test_query_string_spaces():\n    url = URL(\"http://example.com?a+b=c+d&e=f+g\")\n    assert url.query_string == \"a b=c d&e=f g\"\n\n\n# raw fragment\n\n\ndef test_raw_fragment_empty():\n    url = URL(\"http://example.com\")\n    assert \"\" == url.raw_fragment\n\n\ndef test_raw_fragment():\n    url = URL(\"http://example.com/path#anchor\")\n    assert \"anchor\" == url.raw_fragment\n\n\ndef test_raw_fragment_non_ascii():\n    url = URL(\"http://example.com/path#\u044f\u043a\u0456\u0440\")\n    assert \"%D1%8F%D0%BA%D1%96%D1%80\" == url.raw_fragment\n\n\ndef test_raw_fragment_safe():\n    url = URL(\"http://example.com/path#a?b/c:d@e\")\n    assert \"a?b/c:d@e\" == url.raw_fragment\n\n\ndef test_fragment_non_ascii():\n    url = URL(\"http://example.com/path#\u044f\u043a\u0456\u0440\")\n    assert \"\u044f\u043a\u0456\u0440\" == url.fragment\n\n\ndef test_raw_parts_empty():\n    url = URL(\"http://example.com\")\n    assert (\"/\",) == url.raw_parts\n\n\ndef test_raw_parts():\n    url = URL(\"http://example.com/path/to\")\n    assert (\"/\", \"path\", \"to\") == url.raw_parts\n\n\ndef test_raw_parts_without_path():\n    url = URL(\"http://example.com\")\n    assert (\"/\",) == url.raw_parts\n\n\ndef test_raw_path_parts_with_2F_in_path():\n    url = URL(\"http://example.com/path%2Fto/three\")\n    assert (\"/\", \"path%2Fto\", \"three\") == url.raw_parts\n\n\ndef test_raw_path_parts_with_2f_in_path():\n    url = URL(\"http://example.com/path%2fto/three\")\n    assert (\"/\", \"path%2Fto\", \"three\") == url.raw_parts\n\n\ndef test_raw_parts_for_relative_path():\n    url = URL(\"path/to\")\n    assert (\"path\", \"to\") == url.raw_parts\n\n\ndef test_raw_parts_for_relative_path_starting_from_slash():\n    url = URL(\"/path/to\")\n    assert (\"/\", \"path\", \"to\") == url.raw_parts\n\n\ndef test_raw_parts_for_relative_double_path():\n    url = URL(\"path/to\")\n    assert (\"path\", \"to\") == url.raw_parts\n\n\ndef test_parts_for_empty_url():\n    url = URL()\n    assert (\"\",) == url.raw_parts\n\n\ndef test_raw_parts_non_ascii():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438\")\n    assert (\n        \"/\",\n        \"%D1%88%D0%BB%D1%8F%D1%85\",\n        \"%D1%81%D1%8E%D0%B4%D0%B8\",\n    ) == url.raw_parts\n\n\ndef test_parts_non_ascii():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438\")\n    assert (\"/\", \"\u0448\u043b\u044f\u0445\", \"\u0441\u044e\u0434\u0438\") == url.parts\n\n\ndef test_name_for_empty_url():\n    url = URL()\n    assert \"\" == url.raw_name\n\n\ndef test_raw_name():\n    url = URL(\"http://example.com/path/to#frag\")\n    assert \"to\" == url.raw_name\n\n\ndef test_raw_name_root():\n    url = URL(\"http://example.com/#frag\")\n    assert \"\" == url.raw_name\n\n\ndef test_raw_name_root2():\n    url = URL(\"http://example.com\")\n    assert \"\" == url.raw_name\n\n\ndef test_raw_name_root3():\n    url = URL(\"http://example.com/\")\n    assert \"\" == url.raw_name\n\n\ndef test_relative_raw_name():\n    url = URL(\"path/to\")\n    assert \"to\" == url.raw_name\n\n\ndef test_relative_raw_name_starting_from_slash():\n    url = URL(\"/path/to\")\n    assert \"to\" == url.raw_name\n\n\ndef test_relative_raw_name_slash():\n    url = URL(\"/\")\n    assert \"\" == url.raw_name\n\n\ndef test_name_non_ascii():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445\")\n    assert url.name == \"\u0448\u043b\u044f\u0445\"\n\n\ndef test_suffix_for_empty_url():\n    url = URL()\n    assert \"\" == url.raw_suffix\n\n\ndef test_raw_suffix():\n    url = URL(\"http://example.com/path/to.txt#frag\")\n    assert \".txt\" == url.raw_suffix\n\n\ndef test_raw_suffix_root():\n    url = URL(\"http://example.com/#frag\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_raw_suffix_root2():\n    url = URL(\"http://example.com\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_raw_suffix_root3():\n    url = URL(\"http://example.com/\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_relative_raw_suffix():\n    url = URL(\"path/to\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_relative_raw_suffix_starting_from_slash():\n    url = URL(\"/path/to\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_relative_raw_suffix_dot():\n    url = URL(\".\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_suffix_non_ascii():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445.\u0441\u0443\u0444\u0456\u043a\u0441\")\n    assert url.suffix == \".\u0441\u0443\u0444\u0456\u043a\u0441\"\n\n\ndef test_suffix_with_empty_name():\n    url = URL(\"http://example.com/.hgrc\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_suffix_multi_dot():\n    url = URL(\"http://example.com/doc.tar.gz\")\n    assert \".gz\" == url.raw_suffix\n\n\ndef test_suffix_with_dot_name():\n    url = URL(\"http://example.com/doc.\")\n    assert \"\" == url.raw_suffix\n\n\ndef test_suffixes_for_empty_url():\n    url = URL()\n    assert () == url.raw_suffixes\n\n\ndef test_raw_suffixes():\n    url = URL(\"http://example.com/path/to.txt#frag\")\n    assert (\".txt\",) == url.raw_suffixes\n\n\ndef test_raw_suffixes_root():\n    url = URL(\"http://example.com/#frag\")\n    assert () == url.raw_suffixes\n\n\ndef test_raw_suffixes_root2():\n    url = URL(\"http://example.com\")\n    assert () == url.raw_suffixes\n\n\ndef test_raw_suffixes_root3():\n    url = URL(\"http://example.com/\")\n    assert () == url.raw_suffixes\n\n\ndef test_relative_raw_suffixes():\n    url = URL(\"path/to\")\n    assert () == url.raw_suffixes\n\n\ndef test_relative_raw_suffixes_starting_from_slash():\n    url = URL(\"/path/to\")\n    assert () == url.raw_suffixes\n\n\ndef test_relative_raw_suffixes_dot():\n    url = URL(\".\")\n    assert () == url.raw_suffixes\n\n\ndef test_suffixes_non_ascii():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445.\u0441\u0443\u0444\u0456\u043a\u0441\")\n    assert url.suffixes == (\".\u0441\u0443\u0444\u0456\u043a\u0441\",)\n\n\ndef test_suffixes_with_empty_name():\n    url = URL(\"http://example.com/.hgrc\")\n    assert () == url.raw_suffixes\n\n\ndef test_suffixes_multi_dot():\n    url = URL(\"http://example.com/doc.tar.gz\")\n    assert (\".tar\", \".gz\") == url.raw_suffixes\n\n\ndef test_suffixes_with_dot_name():\n    url = URL(\"http://example.com/doc.\")\n    assert () == url.raw_suffixes\n\n\ndef test_plus_in_path():\n    url = URL(\"http://example.com/test/x+y%2Bz/:+%2B/\")\n    assert \"/test/x+y+z/:++/\" == url.path\n\n\ndef test_nonascii_in_qs():\n    url = URL(\"http://example.com\")\n    url2 = url.with_query({\"f\\xf8\\xf8\": \"f\\xf8\\xf8\"})\n    assert \"http://example.com/?f%C3%B8%C3%B8=f%C3%B8%C3%B8\" == str(url2)\n\n\ndef test_percent_encoded_in_qs():\n    url = URL(\"http://example.com\")\n    url2 = url.with_query({\"k%cf%80\": \"v%cf%80\"})\n    assert str(url2) == \"http://example.com/?k%25cf%2580=v%25cf%2580\"\n    assert url2.raw_query_string == \"k%25cf%2580=v%25cf%2580\"\n    assert url2.query_string == \"k%cf%80=v%cf%80\"\n    assert url2.query == {\"k%cf%80\": \"v%cf%80\"}\n\n\n# modifiers\n\n\ndef test_parent_raw_path():\n    url = URL(\"http://example.com/path/to\")\n    assert url.parent.raw_path == \"/path\"\n\n\ndef test_parent_raw_parts():\n    url = URL(\"http://example.com/path/to\")\n    assert url.parent.raw_parts == (\"/\", \"path\")\n\n\ndef test_double_parent_raw_path():\n    url = URL(\"http://example.com/path/to\")\n    assert url.parent.parent.raw_path == \"/\"\n\n\ndef test_empty_parent_raw_path():\n    url = URL(\"http://example.com/\")\n    assert url.parent.parent.raw_path == \"/\"\n\n\ndef test_empty_parent_raw_path2():\n    url = URL(\"http://example.com\")\n    assert url.parent.parent.raw_path == \"/\"\n\n\ndef test_clear_fragment_on_getting_parent():\n    url = URL(\"http://example.com/path/to#frag\")\n    assert URL(\"http://example.com/path\") == url.parent\n\n\ndef test_clear_fragment_on_getting_parent_toplevel():\n    url = URL(\"http://example.com/#frag\")\n    assert URL(\"http://example.com/\") == url.parent\n\n\ndef test_clear_query_on_getting_parent():\n    url = URL(\"http://example.com/path/to?a=b\")\n    assert URL(\"http://example.com/path\") == url.parent\n\n\ndef test_clear_query_on_getting_parent_toplevel():\n    url = URL(\"http://example.com/?a=b\")\n    assert URL(\"http://example.com/\") == url.parent\n\n\n# truediv\n\n\ndef test_div_root():\n    url = URL(\"http://example.com\") / \"path\" / \"to\"\n    assert str(url) == \"http://example.com/path/to\"\n    assert url.raw_path == \"/path/to\"\n\n\ndef test_div_root_with_slash():\n    url = URL(\"http://example.com/\") / \"path\" / \"to\"\n    assert str(url) == \"http://example.com/path/to\"\n    assert url.raw_path == \"/path/to\"\n\n\ndef test_div():\n    url = URL(\"http://example.com/path\") / \"to\"\n    assert str(url) == \"http://example.com/path/to\"\n    assert url.raw_path == \"/path/to\"\n\n\ndef test_div_with_slash():\n    url = URL(\"http://example.com/path/\") / \"to\"\n    assert str(url) == \"http://example.com/path/to\"\n    assert url.raw_path == \"/path/to\"\n\n\ndef test_div_path_starting_from_slash_is_forbidden():\n    url = URL(\"http://example.com/path/\")\n    with pytest.raises(ValueError):\n        url / \"/to/others\"\n\n\nclass StrEnum(str, Enum):\n    spam = \"ham\"\n\n    def __str__(self):\n        return self.value\n\n\ndef test_div_path_srting_subclass():\n    url = URL(\"http://example.com/path/\") / StrEnum.spam\n    assert str(url) == \"http://example.com/path/ham\"\n\n\ndef test_div_bad_type():\n    url = URL(\"http://example.com/path/\")\n    with pytest.raises(TypeError):\n        url / 3\n\n\ndef test_div_cleanup_query_and_fragment():\n    url = URL(\"http://example.com/path?a=1#frag\")\n    assert str(url / \"to\") == \"http://example.com/path/to\"\n\n\ndef test_div_for_empty_url():\n    url = URL() / \"a\"\n    assert url.raw_parts == (\"a\",)\n\n\ndef test_div_for_relative_url():\n    url = URL(\"a\") / \"b\"\n    assert url.raw_parts == (\"a\", \"b\")\n\n\ndef test_div_for_relative_url_started_with_slash():\n    url = URL(\"/a\") / \"b\"\n    assert url.raw_parts == (\"/\", \"a\", \"b\")\n\n\ndef test_div_non_ascii():\n    url = URL(\"http://example.com/\u0441\u044e\u0434\u0438\")\n    url2 = url / \"\u0442\u0443\u0434\u0438\"\n    assert url2.path == \"/\u0441\u044e\u0434\u0438/\u0442\u0443\u0434\u0438\"\n    assert url2.raw_path == \"/%D1%81%D1%8E%D0%B4%D0%B8/%D1%82%D1%83%D0%B4%D0%B8\"\n    assert url2.parts == (\"/\", \"\u0441\u044e\u0434\u0438\", \"\u0442\u0443\u0434\u0438\")\n    assert url2.raw_parts == (\n        \"/\",\n        \"%D1%81%D1%8E%D0%B4%D0%B8\",\n        \"%D1%82%D1%83%D0%B4%D0%B8\",\n    )\n\n\ndef test_div_percent_encoded():\n    url = URL(\"http://example.com/path\")\n    url2 = url / \"%cf%80\"\n    assert url2.path == \"/path/%cf%80\"\n    assert url2.raw_path == \"/path/%25cf%2580\"\n    assert url2.parts == (\"/\", \"path\", \"%cf%80\")\n    assert url2.raw_parts == (\"/\", \"path\", \"%25cf%2580\")\n\n\ndef test_div_with_colon_and_at():\n    url = URL(\"http://example.com/base\") / \"path:abc@123\"\n    assert url.raw_path == \"/base/path:abc@123\"\n\n\ndef test_div_with_dots():\n    url = URL(\"http://example.com/base\") / \"../path/./to\"\n    assert url.raw_path == \"/path/to\"\n\n\n# joinpath\n\n\n@pytest.mark.parametrize(\n    \"base,to_join,expected\",\n    [\n        pytest.param(\"\", (\"path\", \"to\"), \"http://example.com/path/to\", id=\"root\"),\n        pytest.param(\n            \"/\", (\"path\", \"to\"), \"http://example.com/path/to\", id=\"root-with-slash\"\n        ),\n        pytest.param(\"/path\", (\"to\",), \"http://example.com/path/to\", id=\"path\"),\n        pytest.param(\n            \"/path/\", (\"to\",), \"http://example.com/path/to\", id=\"path-with-slash\"\n        ),\n        pytest.param(\n            \"/path?a=1#frag\",\n            (\"to\",),\n            \"http://example.com/path/to\",\n            id=\"cleanup-query-and-fragment\",\n        ),\n        pytest.param(\"\", (\"path/\",), \"http://example.com/path/\", id=\"trailing-slash\"),\n        pytest.param(\n            \"\", (\"path/\", \"to/\"), \"http://example.com/path/to/\", id=\"duplicate-slash\"\n        ),\n        pytest.param(\"\", (), \"http://example.com\", id=\"empty-segments\"),\n        pytest.param(\n            \"/\", (\"path/\",), \"http://example.com/path/\", id=\"base-slash-trailing-slash\"\n        ),\n        pytest.param(\n            \"/\",\n            (\"path/\", \"to/\"),\n            \"http://example.com/path/to/\",\n            id=\"base-slash-duplicate-slash\",\n        ),\n        pytest.param(\"/\", (), \"http://example.com\", id=\"base-slash-empty-segments\"),\n    ],\n)\ndef test_joinpath(base, to_join, expected):\n    url = URL(f\"http://example.com{base}\")\n    assert str(url.joinpath(*to_join)) == expected\n\n\n@pytest.mark.parametrize(\n    \"url,to_join,expected\",\n    [\n        pytest.param(URL(), (\"a\",), (\"a\",), id=\"empty-url\"),\n        pytest.param(URL(\"a\"), (\"b\",), (\"a\", \"b\"), id=\"relative-path\"),\n        pytest.param(URL(\"a\"), (\"b\", \"\", \"c\"), (\"a\", \"b\", \"c\"), id=\"empty-element\"),\n        pytest.param(URL(\"/a\"), (\"b\"), (\"/\", \"a\", \"b\"), id=\"absolute-path\"),\n        pytest.param(URL(), (\"a/\",), (\"a\", \"\"), id=\"trailing-slash\"),\n        pytest.param(URL(), (\"a/\", \"b/\"), (\"a\", \"b\", \"\"), id=\"duplicate-slash\"),\n        pytest.param(URL(), (), (\"\",), id=\"empty-segments\"),\n    ],\n)\ndef test_joinpath_relative(url, to_join, expected):\n    assert url.joinpath(*to_join).raw_parts == expected\n\n\n@pytest.mark.parametrize(\n    \"url,to_join,encoded,e_path,e_raw_path,e_parts,e_raw_parts\",\n    [\n        pytest.param(\n            \"http://example.com/\u0441\u044e\u0434\u0438\",\n            (\"\u0442\u0443\u0434\u0438\",),\n            False,\n            \"/\u0441\u044e\u0434\u0438/\u0442\u0443\u0434\u0438\",\n            \"/%D1%81%D1%8E%D0%B4%D0%B8/%D1%82%D1%83%D0%B4%D0%B8\",\n            (\"/\", \"\u0441\u044e\u0434\u0438\", \"\u0442\u0443\u0434\u0438\"),\n            (\"/\", \"%D1%81%D1%8E%D0%B4%D0%B8\", \"%D1%82%D1%83%D0%B4%D0%B8\"),\n            id=\"non-ascii\",\n        ),\n        pytest.param(\n            \"http://example.com/path\",\n            (\"%cf%80\",),\n            False,\n            \"/path/%cf%80\",\n            \"/path/%25cf%2580\",\n            (\"/\", \"path\", \"%cf%80\"),\n            (\"/\", \"path\", \"%25cf%2580\"),\n            id=\"percent-encoded\",\n        ),\n        pytest.param(\n            \"http://example.com/path\",\n            (\"%cf%80\",),\n            True,\n            \"/path/\u03c0\",\n            \"/path/%cf%80\",\n            (\"/\", \"path\", \"\u03c0\"),\n            (\"/\", \"path\", \"%cf%80\"),\n            id=\"encoded-percent-encoded\",\n        ),\n    ],\n)\ndef test_joinpath_encoding(\n    url, to_join, encoded, e_path, e_raw_path, e_parts, e_raw_parts\n):\n    joined = URL(url).joinpath(*to_join, encoded=encoded)\n    assert joined.path == e_path\n    assert joined.raw_path == e_raw_path\n    assert joined.parts == e_parts\n    assert joined.raw_parts == e_raw_parts\n\n\n@pytest.mark.parametrize(\n    \"to_join,expected\",\n    [\n        pytest.param((\"path:abc@123\",), \"/base/path:abc@123\", id=\"with-colon-and-at\"),\n        pytest.param((\"..\", \"path\", \".\", \"to\"), \"/path/to\", id=\"with-dots\"),\n    ],\n)\ndef test_joinpath_edgecases(to_join, expected):\n    url = URL(\"http://example.com/base\").joinpath(*to_join)\n    assert url.raw_path == expected\n\n\ndef test_joinpath_path_starting_from_slash_is_forbidden():\n    url = URL(\"http://example.com/path/\")\n    with pytest.raises(\n        ValueError, match=\"Appending path .* starting from slash is forbidden\"\n    ):\n        assert url.joinpath(\"/to/others\")\n\n\n# with_path\n\n\ndef test_with_path():\n    url = URL(\"http://example.com\")\n    url2 = url.with_path(\"/test\")\n    assert str(url2) == \"http://example.com/test\"\n    assert url2.raw_path == \"/test\"\n    assert url2.path == \"/test\"\n\n\ndef test_with_path_nonascii():\n    url = URL(\"http://example.com\")\n    url2 = url.with_path(\"/\u03c0\")\n    assert str(url2) == \"http://example.com/%CF%80\"\n    assert url2.raw_path == \"/%CF%80\"\n    assert url2.path == \"/\u03c0\"\n\n\ndef test_with_path_percent_encoded():\n    url = URL(\"http://example.com\")\n    url2 = url.with_path(\"/%cf%80\")\n    assert str(url2) == \"http://example.com/%25cf%2580\"\n    assert url2.raw_path == \"/%25cf%2580\"\n    assert url2.path == \"/%cf%80\"\n\n\ndef test_with_path_encoded():\n    url = URL(\"http://example.com\")\n    url2 = url.with_path(\"/test\", encoded=True)\n    assert str(url2) == \"http://example.com/test\"\n    assert url2.raw_path == \"/test\"\n    assert url2.path == \"/test\"\n\n\ndef test_with_path_encoded_nonascii():\n    url = URL(\"http://example.com\")\n    url2 = url.with_path(\"/\u03c0\", encoded=True)\n    assert str(url2) == \"http://example.com/\u03c0\"\n    assert url2.raw_path == \"/\u03c0\"\n    assert url2.path == \"/\u03c0\"\n\n\ndef test_with_path_encoded_percent_encoded():\n    url = URL(\"http://example.com\")\n    url2 = url.with_path(\"/%cf%80\", encoded=True)\n    assert str(url2) == \"http://example.com/%cf%80\"\n    assert url2.raw_path == \"/%cf%80\"\n    assert url2.path == \"/\u03c0\"\n\n\ndef test_with_path_dots():\n    url = URL(\"http://example.com\")\n    assert str(url.with_path(\"/test/.\")) == \"http://example.com/test/\"\n\n\ndef test_with_path_relative():\n    url = URL(\"/path\")\n    assert str(url.with_path(\"/new\")) == \"/new\"\n\n\ndef test_with_path_query():\n    url = URL(\"http://example.com?a=b\")\n    assert str(url.with_path(\"/test\")) == \"http://example.com/test\"\n\n\ndef test_with_path_fragment():\n    url = URL(\"http://example.com#frag\")\n    assert str(url.with_path(\"/test\")) == \"http://example.com/test\"\n\n\ndef test_with_path_empty():\n    url = URL(\"http://example.com/test\")\n    assert str(url.with_path(\"\")) == \"http://example.com\"\n\n\ndef test_with_path_leading_slash():\n    url = URL(\"http://example.com\")\n    assert url.with_path(\"test\").path == \"/test\"\n\n\n# with_fragment\n\n\ndef test_with_fragment():\n    url = URL(\"http://example.com\")\n    url2 = url.with_fragment(\"frag\")\n    assert str(url2) == \"http://example.com/#frag\"\n    assert url2.raw_fragment == \"frag\"\n    assert url2.fragment == \"frag\"\n\n\ndef test_with_fragment_safe():\n    url = URL(\"http://example.com\")\n    u2 = url.with_fragment(\"a:b?c@d/e\")\n    assert str(u2) == \"http://example.com/#a:b?c@d/e\"\n\n\ndef test_with_fragment_non_ascii():\n    url = URL(\"http://example.com\")\n    url2 = url.with_fragment(\"\u0444\u0440\u0430\u0433\u043c\")\n    assert url2.raw_fragment == \"%D1%84%D1%80%D0%B0%D0%B3%D0%BC\"\n    assert url2.fragment == \"\u0444\u0440\u0430\u0433\u043c\"\n\n\ndef test_with_fragment_percent_encoded():\n    url = URL(\"http://example.com\")\n    url2 = url.with_fragment(\"%cf%80\")\n    assert str(url2) == \"http://example.com/#%25cf%2580\"\n    assert url2.raw_fragment == \"%25cf%2580\"\n    assert url2.fragment == \"%cf%80\"\n\n\ndef test_with_fragment_None():\n    url = URL(\"http://example.com/path#frag\")\n    url2 = url.with_fragment(None)\n    assert str(url2) == \"http://example.com/path\"\n\n\ndef test_with_fragment_None_matching():\n    url = URL(\"http://example.com/path\")\n    url2 = url.with_fragment(None)\n    assert url is url2\n\n\ndef test_with_fragment_matching():\n    url = URL(\"http://example.com/path#frag\")\n    url2 = url.with_fragment(\"frag\")\n    assert url is url2\n\n\ndef test_with_fragment_bad_type():\n    url = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        url.with_fragment(123)\n\n\n# with_name\n\n\ndef test_with_name():\n    url = URL(\"http://example.com/a/b\")\n    assert url.raw_parts == (\"/\", \"a\", \"b\")\n    url2 = url.with_name(\"c\")\n    assert url2.raw_parts == (\"/\", \"a\", \"c\")\n    assert url2.parts == (\"/\", \"a\", \"c\")\n    assert url2.raw_path == \"/a/c\"\n    assert url2.path == \"/a/c\"\n\n\ndef test_with_name_for_naked_path():\n    url = URL(\"http://example.com\")\n    url2 = url.with_name(\"a\")\n    assert url2.raw_parts == (\"/\", \"a\")\n\n\ndef test_with_name_for_relative_path():\n    url = URL(\"a\")\n    url2 = url.with_name(\"b\")\n    assert url2.raw_parts == (\"b\",)\n\n\ndef test_with_name_for_relative_path2():\n    url = URL(\"a/b\")\n    url2 = url.with_name(\"c\")\n    assert url2.raw_parts == (\"a\", \"c\")\n\n\ndef test_with_name_for_relative_path_starting_from_slash():\n    url = URL(\"/a\")\n    url2 = url.with_name(\"b\")\n    assert url2.raw_parts == (\"/\", \"b\")\n\n\ndef test_with_name_for_relative_path_starting_from_slash2():\n    url = URL(\"/a/b\")\n    url2 = url.with_name(\"c\")\n    assert url2.raw_parts == (\"/\", \"a\", \"c\")\n\n\ndef test_with_name_empty():\n    url = URL(\"http://example.com/path/to\").with_name(\"\")\n    assert str(url) == \"http://example.com/path/\"\n\n\ndef test_with_name_non_ascii():\n    url = URL(\"http://example.com/path\").with_name(\"\u0448\u043b\u044f\u0445\")\n    assert url.path == \"/\u0448\u043b\u044f\u0445\"\n    assert url.raw_path == \"/%D1%88%D0%BB%D1%8F%D1%85\"\n    assert url.parts == (\"/\", \"\u0448\u043b\u044f\u0445\")\n    assert url.raw_parts == (\"/\", \"%D1%88%D0%BB%D1%8F%D1%85\")\n\n\ndef test_with_name_percent_encoded():\n    url = URL(\"http://example.com/path\")\n    url2 = url.with_name(\"%cf%80\")\n    assert url2.raw_parts == (\"/\", \"%25cf%2580\")\n    assert url2.parts == (\"/\", \"%cf%80\")\n    assert url2.raw_path == \"/%25cf%2580\"\n    assert url2.path == \"/%cf%80\"\n\n\ndef test_with_name_with_slash():\n    with pytest.raises(ValueError):\n        URL(\"http://example.com\").with_name(\"a/b\")\n\n\ndef test_with_name_non_str():\n    with pytest.raises(TypeError):\n        URL(\"http://example.com\").with_name(123)\n\n\ndef test_with_name_within_colon_and_at():\n    url = URL(\"http://example.com/oldpath\").with_name(\"path:abc@123\")\n    assert url.raw_path == \"/path:abc@123\"\n\n\ndef test_with_name_dot():\n    with pytest.raises(ValueError):\n        URL(\"http://example.com\").with_name(\".\")\n\n\ndef test_with_name_double_dot():\n    with pytest.raises(ValueError):\n        URL(\"http://example.com\").with_name(\"..\")\n\n\n# with_suffix\n\n\ndef test_with_suffix():\n    url = URL(\"http://example.com/a/b\")\n    assert url.raw_parts == (\"/\", \"a\", \"b\")\n    url2 = url.with_suffix(\".c\")\n    assert url2.raw_parts == (\"/\", \"a\", \"b.c\")\n    assert url2.parts == (\"/\", \"a\", \"b.c\")\n    assert url2.raw_path == \"/a/b.c\"\n    assert url2.path == \"/a/b.c\"\n\n\ndef test_with_suffix_for_naked_path():\n    url = URL(\"http://example.com\")\n    with pytest.raises(ValueError) as excinfo:\n        url.with_suffix(\".a\")\n    (msg,) = excinfo.value.args\n    assert msg == f\"{url!r} has an empty name\"\n\n\ndef test_with_suffix_for_relative_path():\n    url = URL(\"a\")\n    url2 = url.with_suffix(\".b\")\n    assert url2.raw_parts == (\"a.b\",)\n\n\ndef test_with_suffix_for_relative_path2():\n    url = URL(\"a/b\")\n    url2 = url.with_suffix(\".c\")\n    assert url2.raw_parts == (\"a\", \"b.c\")\n\n\ndef test_with_suffix_for_relative_path_starting_from_slash():\n    url = URL(\"/a\")\n    url2 = url.with_suffix(\".b\")\n    assert url2.raw_parts == (\"/\", \"a.b\")\n\n\ndef test_with_suffix_for_relative_path_starting_from_slash2():\n    url = URL(\"/a/b\")\n    url2 = url.with_suffix(\".c\")\n    assert url2.raw_parts == (\"/\", \"a\", \"b.c\")\n\n\ndef test_with_suffix_empty():\n    url = URL(\"http://example.com/path/to\").with_suffix(\"\")\n    assert str(url) == \"http://example.com/path/to\"\n\n\ndef test_with_suffix_non_ascii():\n    url = URL(\"http://example.com/path\").with_suffix(\".\u0448\u043b\u044f\u0445\")\n    assert url.path == \"/path.\u0448\u043b\u044f\u0445\"\n    assert url.raw_path == \"/path.%D1%88%D0%BB%D1%8F%D1%85\"\n    assert url.parts == (\"/\", \"path.\u0448\u043b\u044f\u0445\")\n    assert url.raw_parts == (\"/\", \"path.%D1%88%D0%BB%D1%8F%D1%85\")\n\n\ndef test_with_suffix_percent_encoded():\n    url = URL(\"http://example.com/path\")\n    url2 = url.with_suffix(\".%cf%80\")\n    assert url2.raw_parts == (\"/\", \"path.%25cf%2580\")\n    assert url2.parts == (\"/\", \"path.%cf%80\")\n    assert url2.raw_path == \"/path.%25cf%2580\"\n    assert url2.path == \"/path.%cf%80\"\n\n\ndef test_with_suffix_without_dot():\n    with pytest.raises(ValueError) as excinfo:\n        URL(\"http://example.com/a\").with_suffix(\"b\")\n    (msg,) = excinfo.value.args\n    assert msg == \"Invalid suffix 'b'\"\n\n\ndef test_with_suffix_non_str():\n    with pytest.raises(TypeError) as excinfo:\n        URL(\"http://example.com\").with_suffix(123)\n    (msg,) = excinfo.value.args\n    assert msg == \"Invalid suffix type\"\n\n\ndef test_with_suffix_dot():\n    with pytest.raises(ValueError) as excinfo:\n        URL(\"http://example.com\").with_suffix(\".\")\n    (msg,) = excinfo.value.args\n    assert msg == \"Invalid suffix '.'\"\n\n\ndef test_with_suffix_with_slash():\n    with pytest.raises(ValueError) as excinfo:\n        URL(\"http://example.com/a\").with_suffix(\"/.b\")\n    (msg,) = excinfo.value.args\n    assert msg == \"Invalid suffix '/.b'\"\n\n\ndef test_with_suffix_with_slash2():\n    with pytest.raises(ValueError) as excinfo:\n        URL(\"http://example.com/a\").with_suffix(\".b/.d\")\n    (msg,) = excinfo.value.args\n    assert msg == \"Slash in name is not allowed\"\n\n\ndef test_with_suffix_replace():\n    url = URL(\"/a.b\")\n    url2 = url.with_suffix(\".c\")\n    assert url2.raw_parts == (\"/\", \"a.c\")\n\n\n# is_absolute\n\n\ndef test_is_absolute_for_relative_url():\n    url = URL(\"/path/to\")\n    assert not url.is_absolute()\n\n\ndef test_is_absolute_for_absolute_url():\n    url = URL(\"http://example.com\")\n    assert url.is_absolute()\n\n\ndef test_is_non_absolute_for_empty_url():\n    url = URL()\n    assert not url.is_absolute()\n\n\ndef test_is_non_absolute_for_empty_url2():\n    url = URL(\"\")\n    assert not url.is_absolute()\n\n\ndef test_is_absolute_path_starting_from_double_slash():\n    url = URL(\"//www.python.org\")\n    assert url.is_absolute()\n\n\n# is_default_port\n\n\ndef test_is_default_port_for_relative_url():\n    url = URL(\"/path/to\")\n    assert not url.is_default_port()\n\n\ndef test_is_default_port_for_absolute_url_without_port():\n    url = URL(\"http://example.com\")\n    assert url.is_default_port()\n\n\ndef test_is_default_port_for_absolute_url_with_default_port():\n    url = URL(\"http://example.com:80\")\n    assert url.is_default_port()\n\n\ndef test_is_default_port_for_absolute_url_with_nondefault_port():\n    url = URL(\"http://example.com:8080\")\n    assert not url.is_default_port()\n\n\ndef test_is_default_port_for_unknown_scheme():\n    url = URL(\"unknown://example.com:8080\")\n    assert not url.is_default_port()\n\n\n#\n\n\ndef test_no_scheme():\n    url = URL(\"example.com\")\n    assert url.raw_host is None\n    assert url.raw_path == \"example.com\"\n    assert str(url) == \"example.com\"\n\n\ndef test_no_scheme2():\n    url = URL(\"example.com/a/b\")\n    assert url.raw_host is None\n    assert url.raw_path == \"example.com/a/b\"\n    assert str(url) == \"example.com/a/b\"\n\n\ndef test_from_non_allowed():\n    with pytest.raises(TypeError):\n        URL(1234)\n\n\ndef test_from_idna():\n    url = URL(\"http://xn--jxagkqfkduily1i.eu\")\n    assert \"http://xn--jxagkqfkduily1i.eu\" == str(url)\n    url = URL(\"http://xn--einla-pqa.de/\")  # needs idna 2008\n    assert \"http://xn--einla-pqa.de/\" == str(url)\n\n\ndef test_to_idna():\n    url = URL(\"http://\u03b5\u03bc\u03c0\u03bf\u03c1\u03b9\u03ba\u03cc\u03c3\u03ae\u03bc\u03b1.eu\")\n    assert \"http://xn--jxagkqfkduily1i.eu\" == str(url)\n    url = URL(\"http://einla\u00df.de/\")\n    assert \"http://xn--einla-pqa.de/\" == str(url)\n\n\ndef test_from_ascii_login():\n    url = URL(\"http://\" \"%D0%B2%D0%B0%D1%81%D1%8F\" \"@host:1234/\")\n    assert (\"http://\" \"%D0%B2%D0%B0%D1%81%D1%8F\" \"@host:1234/\") == str(url)\n\n\ndef test_from_non_ascii_login():\n    url = URL(\"http://\u0431\u0430\u0436\u0430\u043d@host:1234/\")\n    assert (\"http://%D0%B1%D0%B0%D0%B6%D0%B0%D0%BD@host:1234/\") == str(url)\n\n\ndef test_from_ascii_login_and_password():\n    url = URL(\n        \"http://\"\n        \"%D0%B2%D0%B0%D1%81%D1%8F\"\n        \":%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C\"\n        \"@host:1234/\"\n    )\n    assert (\n        \"http://\"\n        \"%D0%B2%D0%B0%D1%81%D1%8F\"\n        \":%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C\"\n        \"@host:1234/\"\n    ) == str(url)\n\n\ndef test_from_non_ascii_login_and_password():\n    url = URL(\"http://\u0431\u0430\u0436\u0430\u043d:\u043f\u0430\u0440\u043e\u043b\u044c@host:1234/\")\n    assert (\n        \"http://\"\n        \"%D0%B1%D0%B0%D0%B6%D0%B0%D0%BD\"\n        \":%D0%BF%D0%B0%D1%80%D0%BE%D0%BB%D1%8C\"\n        \"@host:1234/\"\n    ) == str(url)\n\n\ndef test_from_ascii_path():\n    url = URL(\"http://example.com/\" \"%D0%BF%D1%83%D1%82%D1%8C/%D1%82%D1%83%D0%B4%D0%B0\")\n    assert (\n        \"http://example.com/\" \"%D0%BF%D1%83%D1%82%D1%8C/%D1%82%D1%83%D0%B4%D0%B0\"\n    ) == str(url)\n\n\ndef test_from_ascii_path_lower_case():\n    url = URL(\"http://example.com/\" \"%d0%bf%d1%83%d1%82%d1%8c/%d1%82%d1%83%d0%b4%d0%b0\")\n    assert (\n        \"http://example.com/\" \"%D0%BF%D1%83%D1%82%D1%8C/%D1%82%D1%83%D0%B4%D0%B0\"\n    ) == str(url)\n\n\ndef test_from_non_ascii_path():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445/\u0442\u0443\u0434\u0438\")\n    assert (\n        \"http://example.com/%D1%88%D0%BB%D1%8F%D1%85/%D1%82%D1%83%D0%B4%D0%B8\"\n    ) == str(url)\n\n\ndef test_bytes():\n    url = URL(\"http://example.com/\u0448\u043b\u044f\u0445/\u0442\u0443\u0434\u0438\")\n    assert (\n        b\"http://example.com/%D1%88%D0%BB%D1%8F%D1%85/%D1%82%D1%83%D0%B4%D0%B8\"\n        == bytes(url)\n    )\n\n\ndef test_from_ascii_query_parts():\n    url = URL(\n        \"http://example.com/\"\n        \"?%D0%BF%D0%B0%D1%80%D0%B0%D0%BC\"\n        \"=%D0%B7%D0%BD%D0%B0%D1%87\"\n    )\n    assert (\n        \"http://example.com/\"\n        \"?%D0%BF%D0%B0%D1%80%D0%B0%D0%BC\"\n        \"=%D0%B7%D0%BD%D0%B0%D1%87\"\n    ) == str(url)\n\n\ndef test_from_non_ascii_query_parts():\n    url = URL(\"http://example.com/?\u043f\u0430\u0440\u0430\u043c=\u0437\u043d\u0430\u0447\")\n    assert (\n        \"http://example.com/\"\n        \"?%D0%BF%D0%B0%D1%80%D0%B0%D0%BC\"\n        \"=%D0%B7%D0%BD%D0%B0%D1%87\"\n    ) == str(url)\n\n\ndef test_from_non_ascii_query_parts2():\n    url = URL(\"http://example.com/?\u043f=\u0437&\u044e=\u0431\")\n    assert \"http://example.com/?%D0%BF=%D0%B7&%D1%8E=%D0%B1\" == str(url)\n\n\ndef test_from_ascii_fragment():\n    url = URL(\"http://example.com/\" \"#%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82\")\n    assert (\n        \"http://example.com/\" \"#%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82\"\n    ) == str(url)\n\n\ndef test_from_bytes_with_non_ascii_fragment():\n    url = URL(\"http://example.com/#\u0444\u0440\u0430\u0433\u043c\u0435\u043d\u0442\")\n    assert (\n        \"http://example.com/\" \"#%D1%84%D1%80%D0%B0%D0%B3%D0%BC%D0%B5%D0%BD%D1%82\"\n    ) == str(url)\n\n\ndef test_to_str():\n    url = URL(\"http://\u03b5\u03bc\u03c0\u03bf\u03c1\u03b9\u03ba\u03cc\u03c3\u03ae\u03bc\u03b1.eu/\")\n    assert \"http://xn--jxagkqfkduily1i.eu/\" == str(url)\n\n\ndef test_to_str_long():\n    url = URL(\n        \"https://host-12345678901234567890123456789012345678901234567890\" \"-name:8888/\"\n    )\n    expected = (\n        \"https://host-\"\n        \"12345678901234567890123456789012345678901234567890\"\n        \"-name:8888/\"\n    )\n    assert expected == str(url)\n\n\ndef test_decoding_with_2F_in_path():\n    url = URL(\"http://example.com/path%2Fto\")\n    assert \"http://example.com/path%2Fto\" == str(url)\n    assert url == URL(str(url))\n\n\ndef test_decoding_with_26_and_3D_in_query():\n    url = URL(\"http://example.com/?%26=%3D\")\n    assert \"http://example.com/?%26=%3D\" == str(url)\n    assert url == URL(str(url))\n\n\ndef test_fragment_only_url():\n    url = URL(\"#frag\")\n    assert str(url) == \"#frag\"\n\n\ndef test_url_from_url():\n    url = URL(\"http://example.com\")\n    assert URL(url) == url\n    assert URL(url).raw_parts == (\"/\",)\n\n\ndef test_lowercase_scheme():\n    url = URL(\"HTTP://example.com\")\n    assert str(url) == \"http://example.com\"\n\n\ndef test_str_for_empty_url():\n    url = URL()\n    assert \"\" == str(url)\n\n\ndef test_parent_for_empty_url():\n    url = URL()\n    assert url is url.parent\n\n\ndef test_empty_value_for_query():\n    url = URL(\"http://example.com/path\").with_query({\"a\": \"\"})\n    assert str(url) == \"http://example.com/path?a=\"\n\n\ndef test_none_value_for_query():\n    with pytest.raises(TypeError):\n        URL(\"http://example.com/path\").with_query({\"a\": None})\n\n\ndef test_decode_pct_in_path():\n    url = URL(\"http://www.python.org/%7Eguido\")\n    assert \"http://www.python.org/~guido\" == str(url)\n\n\ndef test_decode_pct_in_path_lower_case():\n    url = URL(\"http://www.python.org/%7eguido\")\n    assert \"http://www.python.org/~guido\" == str(url)\n\n\n# join\n\n\ndef test_join():\n    base = URL(\"http://www.cwi.nl/%7Eguido/Python.html\")\n    url = URL(\"FAQ.html\")\n    url2 = base.join(url)\n    assert str(url2) == \"http://www.cwi.nl/~guido/FAQ.html\"\n\n\ndef test_join_absolute():\n    base = URL(\"http://www.cwi.nl/%7Eguido/Python.html\")\n    url = URL(\"//www.python.org/%7Eguido\")\n    url2 = base.join(url)\n    assert str(url2) == \"http://www.python.org/~guido\"\n\n\ndef test_join_non_url():\n    base = URL(\"http://example.com\")\n    with pytest.raises(TypeError):\n        base.join(\"path/to\")\n\n\nNORMAL = [\n    (\"g:h\", \"g:h\"),\n    (\"g\", \"http://a/b/c/g\"),\n    (\"./g\", \"http://a/b/c/g\"),\n    (\"g/\", \"http://a/b/c/g/\"),\n    (\"/g\", \"http://a/g\"),\n    (\"//g\", \"http://g\"),\n    (\"?y\", \"http://a/b/c/d;p?y\"),\n    (\"g?y\", \"http://a/b/c/g?y\"),\n    (\"#s\", \"http://a/b/c/d;p?q#s\"),\n    (\"g#s\", \"http://a/b/c/g#s\"),\n    (\"g?y#s\", \"http://a/b/c/g?y#s\"),\n    (\";x\", \"http://a/b/c/;x\"),\n    (\"g;x\", \"http://a/b/c/g;x\"),\n    (\"g;x?y#s\", \"http://a/b/c/g;x?y#s\"),\n    (\"\", \"http://a/b/c/d;p?q\"),\n    (\".\", \"http://a/b/c/\"),\n    (\"./\", \"http://a/b/c/\"),\n    (\"..\", \"http://a/b/\"),\n    (\"../\", \"http://a/b/\"),\n    (\"../g\", \"http://a/b/g\"),\n    (\"../..\", \"http://a/\"),\n    (\"../../\", \"http://a/\"),\n    (\"../../g\", \"http://a/g\"),\n]\n\n\n@pytest.mark.parametrize(\"url,expected\", NORMAL)\ndef test_join_from_rfc_3986_normal(url, expected):\n    # test case from https://tools.ietf.org/html/rfc3986.html#section-5.4\n    base = URL(\"http://a/b/c/d;p?q\")\n    url = URL(url)\n    expected = URL(expected)\n    assert base.join(url) == expected\n\n\nABNORMAL = [\n    (\"../../../g\", \"http://a/g\"),\n    (\"../../../../g\", \"http://a/g\"),\n    (\"/./g\", \"http://a/g\"),\n    (\"/../g\", \"http://a/g\"),\n    (\"g.\", \"http://a/b/c/g.\"),\n    (\".g\", \"http://a/b/c/.g\"),\n    (\"g..\", \"http://a/b/c/g..\"),\n    (\"..g\", \"http://a/b/c/..g\"),\n    (\"./../g\", \"http://a/b/g\"),\n    (\"./g/.\", \"http://a/b/c/g/\"),\n    (\"g/./h\", \"http://a/b/c/g/h\"),\n    (\"g/../h\", \"http://a/b/c/h\"),\n    (\"g;x=1/./y\", \"http://a/b/c/g;x=1/y\"),\n    (\"g;x=1/../y\", \"http://a/b/c/y\"),\n    (\"g?y/./x\", \"http://a/b/c/g?y/./x\"),\n    (\"g?y/../x\", \"http://a/b/c/g?y/../x\"),\n    (\"g#s/./x\", \"http://a/b/c/g#s/./x\"),\n    (\"g#s/../x\", \"http://a/b/c/g#s/../x\"),\n]\n\n\n@pytest.mark.parametrize(\"url,expected\", ABNORMAL)\ndef test_join_from_rfc_3986_abnormal(url, expected):\n    # test case from https://tools.ietf.org/html/rfc3986.html#section-5.4.2\n    base = URL(\"http://a/b/c/d;p?q\")\n    url = URL(url)\n    expected = URL(expected)\n    assert base.join(url) == expected\n\n\ndef test_split_result_non_decoded():\n    with pytest.raises(ValueError):\n        URL(SplitResult(\"http\", \"example.com\", \"path\", \"qs\", \"frag\"))\n\n\ndef test_human_repr():\n    url = URL(\"http://\u0431\u0430\u0436\u0430\u043d:\u043f\u0430\u0440\u043e\u043b\u044c@\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d:8080/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438?\u0430\u0440\u0433=\u0432\u0430\u043b#\u0444\u0440\u0430\u0433\")\n    s = url.human_repr()\n    assert URL(s) == url\n    assert s == \"http://\u0431\u0430\u0436\u0430\u043d:\u043f\u0430\u0440\u043e\u043b\u044c@\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d:8080/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438?\u0430\u0440\u0433=\u0432\u0430\u043b#\u0444\u0440\u0430\u0433\"\n\n\ndef test_human_repr_defaults():\n    url = URL(\"\u0448\u043b\u044f\u0445\")\n    s = url.human_repr()\n    assert s == \"\u0448\u043b\u044f\u0445\"\n\n\ndef test_human_repr_default_port():\n    url = URL(\"http://\u0431\u0430\u0436\u0430\u043d:\u043f\u0430\u0440\u043e\u043b\u044c@\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438?\u0430\u0440\u0433=\u0432\u0430\u043b#\u0444\u0440\u0430\u0433\")\n    s = url.human_repr()\n    assert URL(s) == url\n    assert s == \"http://\u0431\u0430\u0436\u0430\u043d:\u043f\u0430\u0440\u043e\u043b\u044c@\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d/\u0448\u043b\u044f\u0445/\u0441\u044e\u0434\u0438?\u0430\u0440\u0433=\u0432\u0430\u043b#\u0444\u0440\u0430\u0433\"\n\n\ndef test_human_repr_ipv6():\n    url = URL(\"http://[::1]:8080/path\")\n    s = url.human_repr()\n    url2 = URL(s)\n    assert url2 == url\n    assert url2.host == \"::1\"\n    assert s == \"http://[::1]:8080/path\"\n\n\ndef test_human_repr_delimiters():\n    url = URL.build(\n        scheme=\"http\",\n        user=\" !\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        password=\" !\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        host=\"\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d\",\n        port=8080,\n        path=\"/ !\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n        query={\n            \" !\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\": \" !\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n        },\n        fragment=\" !\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\",\n    )\n    s = url.human_repr()\n    assert URL(s) == url\n    assert (\n        s == \"http:// !\\\"%23$%25&'()*+,-.%2F%3A;<=>%3F%40%5B\\\\%5D^_`{|}~\"\n        \": !\\\"%23$%25&'()*+,-.%2F%3A;<=>%3F%40%5B\\\\%5D^_`{|}~\"\n        \"@\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d:8080\"\n        \"/ !\\\"%23$%25&'()*+,-./:;<=>%3F@[\\\\]^_`{|}~\"\n        \"? !\\\"%23$%25%26'()*%2B,-./:%3B<%3D>?@[\\\\]^_`{|}~\"\n        \"= !\\\"%23$%25%26'()*%2B,-./:%3B<%3D>?@[\\\\]^_`{|}~\"\n        \"# !\\\"#$%25&'()*+,-./:;<=>?@[\\\\]^_`{|}~\"\n    )\n\n\ndef test_human_repr_non_printable():\n    url = URL.build(\n        scheme=\"http\",\n        user=\"\u0431\u0430\u0436\u0430\u043d\\n\\xad\\u200b\",\n        password=\"\u043f\u0430\u0440\u043e\u043b\u044c\\n\\xad\\u200b\",\n        host=\"\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d\",\n        port=8080,\n        path=\"/\u0448\u043b\u044f\u0445\\n\\xad\\u200b\",\n        query={\"\u0430\u0440\u0433\\n\\xad\\u200b\": \"\u0432\u0430\u043b\\n\\xad\\u200b\"},\n        fragment=\"\u0444\u0440\u0430\u0433\\n\\xad\\u200b\",\n    )\n    s = url.human_repr()\n    assert URL(s) == url\n    assert (\n        s == \"http://\u0431\u0430\u0436\u0430\u043d%0A%C2%AD%E2%80%8B:\u043f\u0430\u0440\u043e\u043b\u044c%0A%C2%AD%E2%80%8B\"\n        \"@\u0445\u043e\u0441\u0442.\u0434\u043e\u043c\u0435\u043d:8080\"\n        \"/\u0448\u043b\u044f\u0445%0A%C2%AD%E2%80%8B\"\n        \"?\u0430\u0440\u0433%0A%C2%AD%E2%80%8B=\u0432\u0430\u043b%0A%C2%AD%E2%80%8B\"\n        \"#\u0444\u0440\u0430\u0433%0A%C2%AD%E2%80%8B\"\n    )\n\n\n# relative\n\n\ndef test_relative():\n    url = URL(\"http://user:pass@example.com:8080/path?a=b#frag\")\n    rel = url.relative()\n    assert str(rel) == \"/path?a=b#frag\"\n\n\ndef test_relative_is_relative():\n    url = URL(\"http://user:pass@example.com:8080/path?a=b#frag\")\n    rel = url.relative()\n    assert not rel.is_absolute()\n\n\ndef test_relative_abs_parts_are_removed():\n    url = URL(\"http://user:pass@example.com:8080/path?a=b#frag\")\n    rel = url.relative()\n    assert not rel.scheme\n    assert not rel.user\n    assert not rel.password\n    assert not rel.host\n    assert not rel.port\n\n\ndef test_relative_fails_on_rel_url():\n    with pytest.raises(ValueError):\n        URL(\"/path?a=b#frag\").relative()\n\n\ndef test_slash_and_question_in_query():\n    u = URL(\"http://example.com/path?http://example.com/p?a#b\")\n    assert u.query_string == \"http://example.com/p?a\"\n\n\ndef test_slash_and_question_in_fragment():\n    u = URL(\"http://example.com/path#http://example.com/p?a\")\n    assert u.fragment == \"http://example.com/p?a\"\n\n\ndef test_requoting():\n    u = URL(\"http://127.0.0.1/?next=http%3A//example.com/\")\n    assert u.raw_query_string == \"next=http://example.com/\"\n    assert str(u) == \"http://127.0.0.1/?next=http://example.com/\"\n", "tests/test_cache.py": "import yarl\n\n# Don't check the actual behavior but make sure that calls are allowed\n\n\ndef teardown_module():\n    yarl.cache_configure()\n\n\ndef test_cache_clear() -> None:\n    yarl.cache_clear()\n\n\ndef test_cache_info() -> None:\n    info = yarl.cache_info()\n    assert info.keys() == {\"idna_encode\", \"idna_decode\"}\n\n\ndef test_cache_configure_default() -> None:\n    yarl.cache_configure()\n\n\ndef test_cache_configure_None() -> None:\n    yarl.cache_configure(idna_encode_size=None, idna_decode_size=None)\n\n\ndef test_cache_configure_explicit() -> None:\n    yarl.cache_configure(idna_encode_size=128, idna_decode_size=128)\n", "tests/test_quoting.py": "import pytest\n\nfrom yarl._quoting import NO_EXTENSIONS\nfrom yarl._quoting_py import _Quoter as _PyQuoter\nfrom yarl._quoting_py import _Unquoter as _PyUnquoter\n\nif not NO_EXTENSIONS:\n    from yarl._quoting_c import _Quoter as _CQuoter\n    from yarl._quoting_c import _Unquoter as _CUnquoter\n\n    @pytest.fixture(params=[_PyQuoter, _CQuoter], ids=[\"py_quoter\", \"c_quoter\"])\n    def quoter(request):\n        return request.param\n\n    @pytest.fixture(params=[_PyUnquoter, _CUnquoter], ids=[\"py_unquoter\", \"c_unquoter\"])\n    def unquoter(request):\n        return request.param\n\nelse:\n\n    @pytest.fixture(params=[_PyQuoter], ids=[\"py_quoter\"])\n    def quoter(request):\n        return request.param\n\n    @pytest.fixture(params=[_PyUnquoter], ids=[\"py_unquoter\"])\n    def unquoter(request):\n        return request.param\n\n\ndef hexescape(char):\n    \"\"\"Escape char as RFC 2396 specifies\"\"\"\n    hex_repr = hex(ord(char))[2:].upper()\n    if len(hex_repr) == 1:\n        hex_repr = \"0%s\" % hex_repr\n    return \"%\" + hex_repr\n\n\ndef test_quote_not_allowed_non_strict(quoter):\n    assert quoter()(\"%HH\") == \"%25HH\"\n\n\ndef test_quote_unfinished_tail_percent_non_strict(quoter):\n    assert quoter()(\"%\") == \"%25\"\n\n\ndef test_quote_unfinished_tail_digit_non_strict(quoter):\n    assert quoter()(\"%2\") == \"%252\"\n\n\ndef test_quote_unfinished_tail_safe_non_strict(quoter):\n    assert quoter()(\"%x\") == \"%25x\"\n\n\ndef test_quote_unfinished_tail_unsafe_non_strict(quoter):\n    assert quoter()(\"%#\") == \"%25%23\"\n\n\ndef test_quote_unfinished_tail_non_ascii_non_strict(quoter):\n    assert quoter()(\"%\u00df\") == \"%25%C3%9F\"\n\n\ndef test_quote_unfinished_tail_non_ascii2_non_strict(quoter):\n    assert quoter()(\"%\u20ac\") == \"%25%E2%82%AC\"\n\n\ndef test_quote_unfinished_tail_non_ascii3_non_strict(quoter):\n    assert quoter()(\"%\ud83d\udc0d\") == \"%25%F0%9F%90%8D\"\n\n\ndef test_quote_from_bytes(quoter):\n    assert quoter()(\"archaeological arcana\") == \"archaeological%20arcana\"\n    assert quoter()(\"\") == \"\"\n\n\ndef test_quote_ignore_broken_unicode(quoter):\n    s = quoter()(\n        \"j\\u001a\\udcf4q\\udcda/\\udc97g\\udcee\\udccb\\u000ch\\udccb\"\n        \"\\u0018\\udce4v\\u001b\\udce2\\udcce\\udccecom/y\\udccepj\\u0016\"\n    )\n\n    assert s == \"j%1Aq%2Fg%0Ch%18v%1Bcom%2Fypj%16\"\n    assert quoter()(s) == s\n\n\ndef test_unquote_to_bytes(unquoter):\n    assert unquoter()(\"abc%20def\") == \"abc def\"\n    assert unquoter()(\"\") == \"\"\n\n\ndef test_never_quote(quoter):\n    # Make sure quote() does not quote letters, digits, and \"_,.-~\"\n    do_not_quote = (\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\" \"abcdefghijklmnopqrstuvwxyz\" \"0123456789\" \"_.-~\"\n    )\n    assert quoter()(do_not_quote) == do_not_quote\n    assert quoter(qs=True)(do_not_quote) == do_not_quote\n\n\ndef test_safe(quoter):\n    # Test setting 'safe' parameter does what it should do\n    quote_by_default = \"<>\"\n    assert quoter(safe=quote_by_default)(quote_by_default) == quote_by_default\n\n    ret = quoter(safe=quote_by_default, qs=True)(quote_by_default)\n    assert ret == quote_by_default\n\n\n_SHOULD_QUOTE = [chr(num) for num in range(32)]\n_SHOULD_QUOTE.append(r'<>#\"{}|\\^[]`')\n_SHOULD_QUOTE.append(chr(127))  # For 0x7F\nSHOULD_QUOTE = \"\".join(_SHOULD_QUOTE)\n\n\n@pytest.mark.parametrize(\"char\", SHOULD_QUOTE)\ndef test_default_quoting(char, quoter):\n    # Make sure all characters that should be quoted are by default sans\n    # space (separate test for that).\n    result = quoter()(char)\n    assert hexescape(char) == result\n    result = quoter(qs=True)(char)\n    assert hexescape(char) == result\n\n\n# TODO: should it encode percent?\ndef test_default_quoting_percent(quoter):\n    result = quoter()(\"%25\")\n    assert \"%25\" == result\n    result = quoter(qs=True)(\"%25\")\n    assert \"%25\" == result\n    result = quoter(requote=False)(\"%25\")\n    assert \"%2525\" == result\n\n\ndef test_default_quoting_partial(quoter):\n    partial_quote = \"ab[]cd\"\n    expected = \"ab%5B%5Dcd\"\n    result = quoter()(partial_quote)\n    assert expected == result\n    result = quoter(qs=True)(partial_quote)\n    assert expected == result\n\n\ndef test_quoting_space(quoter):\n    # Make sure quote() and quote_plus() handle spaces as specified in\n    # their unique way\n    result = quoter()(\" \")\n    assert result == hexescape(\" \")\n    result = quoter(qs=True)(\" \")\n    assert result == \"+\"\n\n    given = \"a b cd e f\"\n    expect = given.replace(\" \", hexescape(\" \"))\n    result = quoter()(given)\n    assert expect == result\n    expect = given.replace(\" \", \"+\")\n    result = quoter(qs=True)(given)\n    assert expect == result\n\n\ndef test_quoting_plus(quoter):\n    assert quoter(qs=False)(\"alpha+beta gamma\") == \"alpha+beta%20gamma\"\n    assert quoter(qs=True)(\"alpha+beta gamma\") == \"alpha%2Bbeta+gamma\"\n    assert quoter(safe=\"+\", qs=True)(\"alpha+beta gamma\") == \"alpha+beta+gamma\"\n\n\ndef test_quote_with_unicode(quoter):\n    # Characters in Latin-1 range, encoded by default in UTF-8\n    given = \"\\u00a2\\u00d8ab\\u00ff\"\n    expect = \"%C2%A2%C3%98ab%C3%BF\"\n    result = quoter()(given)\n    assert expect == result\n    # Characters in BMP, encoded by default in UTF-8\n    given = \"\\u6f22\\u5b57\"  # \"Kanji\"\n    expect = \"%E6%BC%A2%E5%AD%97\"\n    result = quoter()(given)\n    assert expect == result\n\n\ndef test_quote_plus_with_unicode(quoter):\n    # Characters in Latin-1 range, encoded by default in UTF-8\n    given = \"\\u00a2\\u00d8ab\\u00ff\"\n    expect = \"%C2%A2%C3%98ab%C3%BF\"\n    result = quoter(qs=True)(given)\n    assert expect == result\n    # Characters in BMP, encoded by default in UTF-8\n    given = \"\\u6f22\\u5b57\"  # \"Kanji\"\n    expect = \"%E6%BC%A2%E5%AD%97\"\n    result = quoter(qs=True)(given)\n    assert expect == result\n\n\n@pytest.mark.parametrize(\"num\", list(range(128)))\ndef test_unquoting(num, unquoter):\n    # Make sure unquoting of all ASCII values works\n    given = hexescape(chr(num))\n    expect = chr(num)\n    result = unquoter()(given)\n    assert expect == result\n    if expect not in \"+=&;\":\n        result = unquoter(qs=True)(given)\n        assert expect == result\n\n\n# Expected value should be the same as given.\n# See https://url.spec.whatwg.org/#percent-encoded-bytes\n@pytest.mark.parametrize(\n    (\"input\", \"expected\"),\n    [\n        (\"%\", \"%\"),\n        (\"%2\", \"%2\"),\n        (\"%x\", \"%x\"),\n        (\"%\u20ac\", \"%\u20ac\"),\n        (\"%2x\", \"%2x\"),\n        (\"%2 \", \"%2 \"),\n        (\"% 2\", \"% 2\"),\n        (\"%xa\", \"%xa\"),\n        (\"%%\", \"%%\"),\n        (\"%%3f\", \"%?\"),\n        (\"%2%\", \"%2%\"),\n        (\"%2%3f\", \"%2?\"),\n        (\"%x%3f\", \"%x?\"),\n        (\"%\u20ac%3f\", \"%\u20ac?\"),\n    ],\n)\ndef test_unquoting_bad_percent_escapes(unquoter, input, expected):\n    assert unquoter()(input) == expected\n\n\n@pytest.mark.xfail(\n    reason=\"\"\"\n    FIXME: After conversion to bytes, should not cause UTF-8 decode fail.\n    See https://url.spec.whatwg.org/#percent-encoded-bytes\n\n    Refs:\n    * https://github.com/aio-libs/yarl/pull/216\n    * https://github.com/aio-libs/yarl/pull/214\n    * https://github.com/aio-libs/yarl/pull/7\n    \"\"\",\n)\n@pytest.mark.parametrize(\"urlencoded_string\", (\"%AB\", \"%AB%AB\"))\ndef test_unquoting_invalid_utf8_sequence(unquoter, urlencoded_string):\n    with pytest.raises(ValueError):\n        unquoter()(urlencoded_string)\n\n\ndef test_unquoting_mixed_case_percent_escapes(unquoter):\n    expected = \"\ud835\udd66\"\n    assert expected == unquoter()(\"%F0%9D%95%A6\")\n    assert expected == unquoter()(\"%F0%9d%95%a6\")\n    assert expected == unquoter()(\"%f0%9D%95%a6\")\n    assert expected == unquoter()(\"%f0%9d%95%a6\")\n\n\ndef test_unquoting_parts(unquoter):\n    # Make sure unquoting works when have non-quoted characters\n    # interspersed\n    given = \"ab\" + hexescape(\"c\") + \"d\"\n    expect = \"abcd\"\n    result = unquoter()(given)\n    assert expect == result\n    result = unquoter(qs=True)(given)\n    assert expect == result\n\n\ndef test_quote_None(quoter):\n    assert quoter()(None) is None\n\n\ndef test_unquote_None(unquoter):\n    assert unquoter()(None) is None\n\n\ndef test_quote_empty_string(quoter):\n    assert quoter()(\"\") == \"\"\n\n\ndef test_unquote_empty_string(unquoter):\n    assert unquoter()(\"\") == \"\"\n\n\ndef test_quote_bad_types(quoter):\n    with pytest.raises(TypeError):\n        quoter()(123)\n\n\ndef test_unquote_bad_types(unquoter):\n    with pytest.raises(TypeError):\n        unquoter()(123)\n\n\ndef test_quote_lowercase(quoter):\n    assert quoter()(\"%d1%84\") == \"%D1%84\"\n\n\ndef test_quote_unquoted(quoter):\n    assert quoter()(\"%41\") == \"A\"\n\n\ndef test_quote_space(quoter):\n    assert quoter()(\" \") == \"%20\"  # NULL\n\n\n# test to see if this would work to fix\n# coverage on this file.\ndef test_quote_percent_last_character(quoter):\n    # % is last character in this case.\n    assert quoter()(\"%\") == \"%25\"\n\n\ndef test_unquote_unsafe(unquoter):\n    assert unquoter(unsafe=\"@\")(\"%40\") == \"%40\"\n\n\ndef test_unquote_unsafe2(unquoter):\n    assert unquoter(unsafe=\"@\")(\"%40abc\") == \"%40abc\"\n\n\ndef test_unquote_unsafe3(unquoter):\n    assert unquoter(qs=True)(\"a%2Bb=?%3D%2B%26\") == \"a%2Bb=?%3D%2B%26\"\n\n\ndef test_unquote_unsafe4(unquoter):\n    assert unquoter(unsafe=\"@\")(\"a@b\") == \"a%40b\"\n\n\n@pytest.mark.parametrize(\n    (\"input\", \"expected\"),\n    [\n        (\"%e2%82\", \"%e2%82\"),\n        (\"%e2%82ac\", \"%e2%82ac\"),\n        (\"%e2%82%f8\", \"%e2%82%f8\"),\n        (\"%e2%82%2b\", \"%e2%82+\"),\n        (\"%e2%82%e2%82%ac\", \"%e2%82\u20ac\"),\n        (\"%e2%82%e2%82\", \"%e2%82%e2%82\"),\n    ],\n)\ndef test_unquote_non_utf8(unquoter, input, expected):\n    assert unquoter()(input) == expected\n\n\ndef test_unquote_unsafe_non_utf8(unquoter):\n    assert unquoter(unsafe=\"\\n\")(\"%e2%82%0a\") == \"%e2%82%0A\"\n\n\ndef test_unquote_plus_non_utf8(unquoter):\n    assert unquoter(qs=True)(\"%e2%82%2b\") == \"%e2%82%2B\"\n\n\ndef test_quote_non_ascii(quoter):\n    assert quoter()(\"%F8\") == \"%F8\"\n\n\ndef test_quote_non_ascii2(quoter):\n    assert quoter()(\"a%F8b\") == \"a%F8b\"\n\n\ndef test_quote_percent_percent_encoded(quoter):\n    assert quoter()(\"%%3f\") == \"%25%3F\"\n\n\ndef test_quote_percent_digit_percent_encoded(quoter):\n    assert quoter()(\"%2%3f\") == \"%252%3F\"\n\n\ndef test_quote_percent_safe_percent_encoded(quoter):\n    assert quoter()(\"%x%3f\") == \"%25x%3F\"\n\n\ndef test_quote_percent_unsafe_percent_encoded(quoter):\n    assert quoter()(\"%#%3f\") == \"%25%23%3F\"\n\n\ndef test_quote_percent_non_ascii_percent_encoded(quoter):\n    assert quoter()(\"%\u00df%3f\") == \"%25%C3%9F%3F\"\n\n\ndef test_quote_percent_non_ascii2_percent_encoded(quoter):\n    assert quoter()(\"%\u20ac%3f\") == \"%25%E2%82%AC%3F\"\n\n\ndef test_quote_percent_non_ascii3_percent_encoded(quoter):\n    assert quoter()(\"%\ud83d\udc0d%3f\") == \"%25%F0%9F%90%8D%3F\"\n\n\nclass StrLike(str):\n    pass\n\n\ndef test_quote_str_like(quoter):\n    assert quoter()(StrLike(\"abc\")) == \"abc\"\n\n\ndef test_unquote_str_like(unquoter):\n    assert unquoter()(StrLike(\"abc\")) == \"abc\"\n\n\ndef test_quote_sub_delims(quoter):\n    assert quoter()(\"!$&'()*+,;=\") == \"!$&'()*+,;=\"\n\n\ndef test_requote_sub_delims(quoter):\n    assert quoter()(\"%21%24%26%27%28%29%2A%2B%2C%3B%3D\") == \"!$&'()*+,;=\"\n\n\ndef test_unquoting_plus(unquoter):\n    assert unquoter(qs=False)(\"a+b\") == \"a+b\"\n\n\ndef test_unquote_plus_to_space(unquoter):\n    assert unquoter(qs=True)(\"a+b\") == \"a b\"\n\n\ndef test_unquote_plus_to_space_unsafe(unquoter):\n    assert unquoter(unsafe=\"+\", qs=True)(\"a+b\") == \"a+b\"\n\n\ndef test_quote_qs_with_colon(quoter):\n    s = quoter(safe=\"=+&?/:@\", qs=True)(\"next=http%3A//example.com/\")\n    assert s == \"next=http://example.com/\"\n\n\ndef test_quote_protected(quoter):\n    s = quoter(protected=\"/\")(\"/path%2fto/three\")\n    assert s == \"/path%2Fto/three\"\n\n\ndef test_quote_fastpath_safe(quoter):\n    s1 = \"/path/to\"\n    s2 = quoter(safe=\"/\")(s1)\n    assert s1 is s2\n\n\ndef test_quote_fastpath_pct(quoter):\n    s1 = \"abc%A0\"\n    s2 = quoter()(s1)\n    assert s1 is s2\n\n\ndef test_quote_very_large_string(quoter):\n    # more than 8 KiB\n    s = \"abc\u0444\u0443\u0445%30%0a\" * 1024\n    assert quoter()(s) == \"abc%D1%84%D1%83%D1%850%0A\" * 1024\n\n\ndef test_space(quoter):\n    s = \"% A\"\n    assert quoter()(s) == \"%25%20A\"\n\n\ndef test_quoter_path_with_plus(quoter):\n    s = \"/test/x+y%2Bz/:+%2B/\"\n    assert \"/test/x+y%2Bz/:+%2B/\" == quoter(safe=\"@:\", protected=\"/+\")(s)\n\n\ndef test_unquoter_path_with_plus(unquoter):\n    s = \"/test/x+y%2Bz/:+%2B/\"\n    assert \"/test/x+y+z/:++/\" == unquoter(unsafe=\"+\")(s)\n", "packaging/pep517_backend/_backend.py": "# fmt: off\n\"\"\"PEP 517 build backend wrapper for pre-building Cython for wheel.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport typing as t\nfrom contextlib import contextmanager, nullcontext, suppress\nfrom functools import partial\nfrom pathlib import Path\nfrom shutil import copytree\nfrom sys import implementation as _system_implementation\nfrom sys import stderr as _standard_error_stream\nfrom sys import version_info as _python_version_tuple\nfrom tempfile import TemporaryDirectory\nfrom warnings import warn as _warn_that\n\nfrom setuptools.build_meta import build_sdist as _setuptools_build_sdist\nfrom setuptools.build_meta import build_wheel as _setuptools_build_wheel\nfrom setuptools.build_meta import (\n    get_requires_for_build_wheel as _setuptools_get_requires_for_build_wheel,\n)\nfrom setuptools.build_meta import (\n    prepare_metadata_for_build_wheel as _setuptools_prepare_metadata_for_build_wheel,\n)\n\ntry:\n    from setuptools.build_meta import build_editable as _setuptools_build_editable\nexcept ImportError:\n    _setuptools_build_editable = None  # type: ignore[assignment]\n\n\n# isort: split\nfrom distutils.command.install import install as _distutils_install_cmd\nfrom distutils.core import Distribution as _DistutilsDistribution\nfrom distutils.dist import DistributionMetadata as _DistutilsDistributionMetadata\n\nwith suppress(ImportError):\n    # NOTE: Only available for wheel builds that bundle C-extensions. Declared\n    # NOTE: by `get_requires_for_build_wheel()` and\n    # NOTE: `get_requires_for_build_editable()`, when `pure-python`\n    # NOTE: is not passed.\n    from Cython.Build.Cythonize import main as _cythonize_cli_cmd\n\nfrom ._compat import chdir_cm\nfrom ._cython_configuration import (  # noqa: WPS436\n    get_local_cython_config as _get_local_cython_config,\n)\nfrom ._cython_configuration import (\n    make_cythonize_cli_args_from_config as _make_cythonize_cli_args_from_config,\n)\nfrom ._cython_configuration import patched_env as _patched_cython_env\nfrom ._transformers import sanitize_rst_roles  # noqa: WPS436\n\n__all__ = (  # noqa: WPS410\n    'build_sdist',\n    'build_wheel',\n    'get_requires_for_build_wheel',\n    'prepare_metadata_for_build_wheel',\n    *(\n        () if _setuptools_build_editable is None\n        else (\n            'build_editable',\n            'get_requires_for_build_editable',\n            'prepare_metadata_for_build_editable',\n        )\n    ),\n)\n\n\nCYTHON_TRACING_CONFIG_SETTING = 'with-cython-tracing'\n\"\"\"Config setting name toggle to include line tracing to C-exts.\"\"\"\n\nCYTHON_TRACING_ENV_VAR = 'YARL_CYTHON_TRACING'\n\"\"\"Environment variable name toggle used to opt out of making C-exts.\"\"\"\n\nPURE_PYTHON_CONFIG_SETTING = 'pure-python'\n\"\"\"Config setting name toggle that is used to opt out of making C-exts.\"\"\"\n\nPURE_PYTHON_ENV_VAR = 'YARL_NO_EXTENSIONS'\n\"\"\"Environment variable name toggle used to opt out of making C-exts.\"\"\"\n\nIS_PY3_12_PLUS = _python_version_tuple[:2] >= (3, 12)\n\"\"\"A flag meaning that the current runtime is Python 3.12 or higher.\"\"\"\n\nIS_CPYTHON = _system_implementation.name == \"cpython\"\n\"\"\"A flag meaning that the current interpreter implementation is CPython.\"\"\"\n\nPURE_PYTHON_MODE_CLI_FALLBACK = not IS_CPYTHON\n\"\"\"A fallback for ``pure-python`` is not set.\"\"\"\n\n\ndef _is_truthy_setting_value(setting_value) -> bool:\n    truthy_values = {'', None, 'true', '1', 'on'}\n    return setting_value.lower() in truthy_values\n\n\ndef _get_setting_value(\n        config_settings: dict[str, str] | None = None,\n        config_setting_name: str | None = None,\n        env_var_name: str | None = None,\n        *,\n        default: bool = False,\n) -> bool:\n    user_provided_setting_sources = (\n        (config_settings, config_setting_name, (KeyError, TypeError)),\n        (os.environ, env_var_name, KeyError),\n    )\n    for src_mapping, src_key, lookup_errors in user_provided_setting_sources:\n        if src_key is None:\n            continue\n\n        with suppress(lookup_errors):  # type: ignore[arg-type]\n            return _is_truthy_setting_value(src_mapping[src_key])  # type: ignore[index]\n\n    return default\n\n\ndef _make_pure_python(config_settings: dict[str, str] | None = None) -> bool:\n    return _get_setting_value(\n        config_settings,\n        PURE_PYTHON_CONFIG_SETTING,\n        PURE_PYTHON_ENV_VAR,\n        default=PURE_PYTHON_MODE_CLI_FALLBACK,\n    )\n\n\ndef _include_cython_line_tracing(\n        config_settings: dict[str, str] | None = None,\n        *,\n        default=False,\n) -> bool:\n    return _get_setting_value(\n        config_settings,\n        CYTHON_TRACING_CONFIG_SETTING,\n        CYTHON_TRACING_ENV_VAR,\n        default=default,\n    )\n\n\n@contextmanager\ndef patched_distutils_cmd_install():\n    \"\"\"Make `install_lib` of `install` cmd always use `platlib`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/purelib/` folder\n    orig_finalize = _distutils_install_cmd.finalize_options\n\n    def new_finalize_options(self):  # noqa: WPS430\n        self.install_lib = self.install_platlib\n        orig_finalize(self)\n\n    _distutils_install_cmd.finalize_options = new_finalize_options\n    try:\n        yield\n    finally:\n        _distutils_install_cmd.finalize_options = orig_finalize\n\n\n@contextmanager\ndef patched_dist_has_ext_modules():\n    \"\"\"Make `has_ext_modules` of `Distribution` always return `True`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/platlib/` folder\n    orig_func = _DistutilsDistribution.has_ext_modules\n\n    _DistutilsDistribution.has_ext_modules = lambda *args, **kwargs: True\n    try:\n        yield\n    finally:\n        _DistutilsDistribution.has_ext_modules = orig_func\n\n\n@contextmanager\ndef patched_dist_get_long_description():\n    \"\"\"Make `has_ext_modules` of `Distribution` always return `True`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/platlib/` folder\n    _orig_func = _DistutilsDistributionMetadata.get_long_description\n\n    def _get_sanitized_long_description(self):\n        return sanitize_rst_roles(self.long_description)\n\n    _DistutilsDistributionMetadata.get_long_description = (\n        _get_sanitized_long_description\n    )\n    try:\n        yield\n    finally:\n        _DistutilsDistributionMetadata.get_long_description = _orig_func\n\n\ndef _exclude_dir_path(\n    excluded_dir_path: Path,\n    visited_directory: str,\n    _visited_dir_contents: list[str],\n) -> list[str]:\n    \"\"\"Prevent recursive directory traversal.\"\"\"\n    # This stops the temporary directory from being copied\n    # into self recursively forever.\n    # Ref: https://github.com/aio-libs/yarl/issues/992\n    visited_directory_subdirs_to_ignore = [\n        subdir\n        for subdir in _visited_dir_contents\n        if excluded_dir_path == Path(visited_directory) / subdir\n    ]\n    if visited_directory_subdirs_to_ignore:\n        print(\n            f'Preventing `{excluded_dir_path !s}` from being '\n            'copied into itself recursively...',\n            file=_standard_error_stream,\n        )\n    return visited_directory_subdirs_to_ignore\n\n\n@contextmanager\ndef _in_temporary_directory(src_dir: Path) -> t.Iterator[None]:\n    with TemporaryDirectory(prefix='.tmp-yarl-pep517-') as tmp_dir:\n        tmp_dir_path = Path(tmp_dir)\n        root_tmp_dir_path = tmp_dir_path.parent\n        _exclude_tmpdir_parent = partial(_exclude_dir_path, root_tmp_dir_path)\n\n        with chdir_cm(tmp_dir):\n            tmp_src_dir = tmp_dir_path / 'src'\n            copytree(\n                src_dir,\n                tmp_src_dir,\n                ignore=_exclude_tmpdir_parent,\n                symlinks=True,\n            )\n            os.chdir(tmp_src_dir)\n            yield\n\n\n@contextmanager\ndef maybe_prebuild_c_extensions(\n        line_trace_cython_when_unset: bool = False,\n        build_inplace: bool = False,\n        config_settings: dict[str, str] | None = None,\n) -> t.Generator[None, t.Any, t.Any]:\n    \"\"\"Pre-build C-extensions in a temporary directory, when needed.\n\n    This context manager also patches metadata, setuptools and distutils.\n\n    :param build_inplace: Whether to copy and chdir to a temporary location.\n    :param config_settings: :pep:`517` config settings mapping.\n\n    \"\"\"\n    cython_line_tracing_requested = _include_cython_line_tracing(\n        config_settings,\n        default=line_trace_cython_when_unset,\n    )\n    is_pure_python_build = _make_pure_python(config_settings)\n\n    if is_pure_python_build:\n        print(\"*********************\", file=_standard_error_stream)\n        print(\"* Pure Python build *\", file=_standard_error_stream)\n        print(\"*********************\", file=_standard_error_stream)\n\n        if cython_line_tracing_requested:\n            _warn_that(\n                f'The `{CYTHON_TRACING_CONFIG_SETTING !s}` setting requesting '\n                'Cython line tracing is set, but building C-extensions is not. '\n                'This option will not have any effect for in the pure-python '\n                'build mode.',\n                RuntimeWarning,\n                stacklevel=999,\n            )\n\n        yield\n        return\n\n    print(\"**********************\", file=_standard_error_stream)\n    print(\"* Accelerated build *\", file=_standard_error_stream)\n    print(\"**********************\", file=_standard_error_stream)\n    if not IS_CPYTHON:\n        _warn_that(\n            'Building C-extensions under the runtimes other than CPython is '\n            'unsupported and will likely fail. Consider passing the '\n            f'`{PURE_PYTHON_CONFIG_SETTING !s}` PEP 517 config setting.',\n            RuntimeWarning,\n            stacklevel=999,\n        )\n\n    build_dir_ctx = (\n        nullcontext() if build_inplace\n        else _in_temporary_directory(src_dir=Path.cwd().resolve())\n    )\n    with build_dir_ctx:\n        config = _get_local_cython_config()\n\n        cythonize_args = _make_cythonize_cli_args_from_config(config)\n        with _patched_cython_env(config['env'], cython_line_tracing_requested):\n            _cythonize_cli_cmd(cythonize_args)\n        with patched_distutils_cmd_install():\n            with patched_dist_has_ext_modules():\n                yield\n\n\n@patched_dist_get_long_description()\ndef build_wheel(\n        wheel_directory: str,\n        config_settings: dict[str, str] | None = None,\n        metadata_directory: str | None = None,\n) -> str:\n    \"\"\"Produce a built wheel.\n\n    This wraps the corresponding ``setuptools``' build backend hook.\n\n    :param wheel_directory: Directory to put the resulting wheel in.\n    :param config_settings: :pep:`517` config settings mapping.\n    :param metadata_directory: :file:`.dist-info` directory path.\n\n    \"\"\"\n    with maybe_prebuild_c_extensions(\n            line_trace_cython_when_unset=False,\n            build_inplace=False,\n            config_settings=config_settings,\n    ):\n        return _setuptools_build_wheel(\n            wheel_directory=wheel_directory,\n            config_settings=config_settings,\n            metadata_directory=metadata_directory,\n        )\n\n\n@patched_dist_get_long_description()\ndef build_editable(\n        wheel_directory: str,\n        config_settings: dict[str, str] | None = None,\n        metadata_directory: str | None = None,\n) -> str:\n    \"\"\"Produce a built wheel for editable installs.\n\n    This wraps the corresponding ``setuptools``' build backend hook.\n\n    :param wheel_directory: Directory to put the resulting wheel in.\n    :param config_settings: :pep:`517` config settings mapping.\n    :param metadata_directory: :file:`.dist-info` directory path.\n\n    \"\"\"\n    with maybe_prebuild_c_extensions(\n            line_trace_cython_when_unset=True,\n            build_inplace=True,\n            config_settings=config_settings,\n    ):\n        return _setuptools_build_editable(\n            wheel_directory=wheel_directory,\n            config_settings=config_settings,\n            metadata_directory=metadata_directory,\n        )\n\n\ndef get_requires_for_build_wheel(\n        config_settings: dict[str, str] | None = None,\n) -> list[str]:\n    \"\"\"Determine additional requirements for building wheels.\n\n    :param config_settings: :pep:`517` config settings mapping.\n\n    \"\"\"\n    is_pure_python_build = _make_pure_python(config_settings)\n\n    if not is_pure_python_build and not IS_CPYTHON:\n        _warn_that(\n            'Building C-extensions under the runtimes other than CPython is '\n            'unsupported and will likely fail. Consider passing the '\n            f'`{PURE_PYTHON_CONFIG_SETTING !s}` PEP 517 config setting.',\n            RuntimeWarning,\n            stacklevel=999,\n        )\n\n    c_ext_build_deps = [] if is_pure_python_build else [\n        'Cython >= 3.0.0b3' if IS_PY3_12_PLUS  # Only Cython 3+ is compatible\n        else 'Cython',\n    ]\n\n    return _setuptools_get_requires_for_build_wheel(\n        config_settings=config_settings,\n    ) + c_ext_build_deps\n\n\nbuild_sdist = patched_dist_get_long_description()(_setuptools_build_sdist)\nget_requires_for_build_editable = get_requires_for_build_wheel\nprepare_metadata_for_build_wheel = patched_dist_get_long_description()(\n    _setuptools_prepare_metadata_for_build_wheel,\n)\nprepare_metadata_for_build_editable = prepare_metadata_for_build_wheel\n", "packaging/pep517_backend/cli.py": "# fmt: off\n\nfrom __future__ import annotations\n\nimport sys\nfrom itertools import chain\nfrom pathlib import Path\n\nfrom Cython.Compiler.Main import compile as _translate_cython_cli_cmd\nfrom Cython.Compiler.Main import parse_command_line as _split_cython_cli_args\n\nfrom ._cython_configuration import get_local_cython_config as _get_local_cython_config\nfrom ._cython_configuration import (\n    make_cythonize_cli_args_from_config as _make_cythonize_cli_args_from_config,\n)\nfrom ._cython_configuration import patched_env as _patched_cython_env\n\n_PROJECT_PATH = Path(__file__).parents[2]\n\n\ndef run_main_program(argv) -> int | str:\n    \"\"\"Invoke ``translate-cython`` or fail.\"\"\"\n    if len(argv) != 2:\n        return 'This program only accepts one argument -- \"translate-cython\"'\n\n    if argv[1] != 'translate-cython':\n        return 'This program only implements the \"translate-cython\" subcommand'\n\n    config = _get_local_cython_config()\n    config['flags'] = {'keep-going': config['flags']['keep-going']}\n    config['src'] = list(\n        map(\n            str,\n            chain.from_iterable(\n                map(_PROJECT_PATH.glob, config['src']),\n            ),\n        ),\n    )\n    translate_cython_cli_args = _make_cythonize_cli_args_from_config(config)\n\n    cython_options, cython_sources = _split_cython_cli_args(\n        translate_cython_cli_args,\n    )\n\n    with _patched_cython_env(config['env'], cython_line_tracing_requested=True):\n        return _translate_cython_cli_cmd(\n            cython_sources,\n            cython_options,\n        ).num_errors\n\n\nif __name__ == '__main__':\n    sys.exit(run_main_program(argv=sys.argv))\n", "packaging/pep517_backend/_transformers.py": "\"\"\"Data conversion helpers for the in-tree PEP 517 build backend.\"\"\"\n\nfrom itertools import chain\nfrom re import sub as _substitute_with_regexp\n\n\ndef _emit_opt_pairs(opt_pair):\n    flag, flag_value = opt_pair\n    flag_opt = f\"--{flag!s}\"\n    if isinstance(flag_value, dict):\n        sub_pairs = flag_value.items()\n    else:\n        sub_pairs = ((flag_value,),)\n\n    yield from (\"=\".join(map(str, (flag_opt,) + pair)) for pair in sub_pairs)\n\n\ndef get_cli_kwargs_from_config(kwargs_map):\n    \"\"\"Make a list of options with values from config.\"\"\"\n    return list(chain.from_iterable(map(_emit_opt_pairs, kwargs_map.items())))\n\n\ndef get_enabled_cli_flags_from_config(flags_map):\n    \"\"\"Make a list of enabled boolean flags from config.\"\"\"\n    return [f\"--{flag}\" for flag, is_enabled in flags_map.items() if is_enabled]\n\n\ndef sanitize_rst_roles(rst_source_text: str) -> str:\n    \"\"\"Replace RST roles with inline highlighting.\"\"\"\n    pep_role_regex = r\"\"\"(?x)\n        :pep:`(?P<pep_number>\\d+)`\n    \"\"\"\n    pep_substitution_pattern = (\n        r\"`PEP \\g<pep_number> <https://peps.python.org/pep-\\g<pep_number>>`__\"\n    )\n\n    user_role_regex = r\"\"\"(?x)\n        :user:`(?P<github_username>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    user_substitution_pattern = (\n        r\"`@\\g<github_username> \"\n        r\"<https://github.com/sponsors/\\g<github_username>>`__\"\n    )\n\n    issue_role_regex = r\"\"\"(?x)\n        :issue:`(?P<issue_number>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    issue_substitution_pattern = (\n        r\"`#\\g<issue_number> \"\n        r\"<https://github.com/aio-libs/yarl/issues/\\g<issue_number>>`__\"\n    )\n\n    pr_role_regex = r\"\"\"(?x)\n        :pr:`(?P<pr_number>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    pr_substitution_pattern = (\n        r\"`PR #\\g<pr_number> \"\n        r\"<https://github.com/aio-libs/yarl/pull/\\g<pr_number>>`__\"\n    )\n\n    commit_role_regex = r\"\"\"(?x)\n        :commit:`(?P<commit_sha>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    commit_substitution_pattern = (\n        r\"`\\g<commit_sha> \"\n        r\"<https://github.com/aio-libs/yarl/commit/\\g<commit_sha>>`__\"\n    )\n\n    gh_role_regex = r\"\"\"(?x)\n        :gh:`(?P<gh_slug>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    gh_substitution_pattern = (\n        r\"`GitHub: \\g<gh_slug> <https://github.com/\\g<gh_slug>>`__\"\n    )\n\n    meth_role_regex = r\"\"\"(?x)\n        (?::py)?:meth:`~?(?P<rendered_text>[^`<]+)(?:\\s+([^`]*))?`\n    \"\"\"\n    meth_substitution_pattern = r\"``\\g<rendered_text>()``\"\n\n    role_regex = r\"\"\"(?x)\n        (?::\\w+)?:\\w+:`(?P<rendered_text>[^`<]+)(?:\\s+([^`]*))?`\n    \"\"\"\n    substitution_pattern = r\"``\\g<rendered_text>``\"\n\n    substitutions = (\n        (pep_role_regex, pep_substitution_pattern),\n        (user_role_regex, user_substitution_pattern),\n        (issue_role_regex, issue_substitution_pattern),\n        (pr_role_regex, pr_substitution_pattern),\n        (commit_role_regex, commit_substitution_pattern),\n        (gh_role_regex, gh_substitution_pattern),\n        (meth_role_regex, meth_substitution_pattern),\n        (role_regex, substitution_pattern),\n    )\n\n    rst_source_normalized_text = rst_source_text\n    for regex, substitution in substitutions:\n        rst_source_normalized_text = _substitute_with_regexp(\n            regex,\n            substitution,\n            rst_source_normalized_text,\n        )\n\n    return rst_source_normalized_text\n", "packaging/pep517_backend/_cython_configuration.py": "# fmt: off\n\nfrom __future__ import annotations\n\nimport os\nfrom contextlib import contextmanager\nfrom pathlib import Path\nfrom sys import version_info as _python_version_tuple\n\nfrom expandvars import expandvars\n\nfrom ._compat import load_toml_from_string  # noqa: WPS436\nfrom ._transformers import (  # noqa: WPS436\n    get_cli_kwargs_from_config,\n    get_enabled_cli_flags_from_config,\n)\n\n\ndef get_local_cython_config() -> dict:\n    \"\"\"Grab optional build dependencies from pyproject.toml config.\n\n    :returns: config section from ``pyproject.toml``\n    :rtype: dict\n\n    This basically reads entries from::\n\n        [tool.local.cythonize]\n        # Env vars provisioned during cythonize call\n        src = [\"src/**/*.pyx\"]\n\n        [tool.local.cythonize.env]\n        # Env vars provisioned during cythonize call\n        LDFLAGS = \"-lssh\"\n\n        [tool.local.cythonize.flags]\n        # This section can contain the following booleans:\n        # * annotate \u2014 generate annotated HTML page for source files\n        # * build \u2014 build extension modules using distutils\n        # * inplace \u2014 build extension modules in place using distutils (implies -b)\n        # * force \u2014 force recompilation\n        # * quiet \u2014 be less verbose during compilation\n        # * lenient \u2014 increase Python compat by ignoring some compile time errors\n        # * keep-going \u2014 compile as much as possible, ignore compilation failures\n        annotate = false\n        build = false\n        inplace = true\n        force = true\n        quiet = false\n        lenient = false\n        keep-going = false\n\n        [tool.local.cythonize.kwargs]\n        # This section can contain args that have values:\n        # * exclude=PATTERN      exclude certain file patterns from the compilation\n        # * parallel=N    run builds in N parallel jobs (default: calculated per system)\n        exclude = \"**.py\"\n        parallel = 12\n\n        [tool.local.cythonize.kwargs.directives]\n        # This section can contain compiler directives\n        # NAME = \"VALUE\"\n\n        [tool.local.cythonize.kwargs.compile-time-env]\n        # This section can contain compile time env vars\n        # NAME = \"VALUE\"\n\n        [tool.local.cythonize.kwargs.options]\n        # This section can contain cythonize options\n        # NAME = \"VALUE\"\n    \"\"\"\n    config_toml_txt = (Path.cwd().resolve() / 'pyproject.toml').read_text()\n    config_mapping = load_toml_from_string(config_toml_txt)\n    return config_mapping['tool']['local']['cythonize']\n\n\ndef make_cythonize_cli_args_from_config(config) -> list[str]:\n    py_ver_arg = f'-{_python_version_tuple.major!s}'\n\n    cli_flags = get_enabled_cli_flags_from_config(config['flags'])\n    cli_kwargs = get_cli_kwargs_from_config(config['kwargs'])\n\n    return cli_flags + [py_ver_arg] + cli_kwargs + ['--'] + config['src']\n\n\n@contextmanager\ndef patched_env(env: dict[str, str], cython_line_tracing_requested: bool):\n    \"\"\"Temporary set given env vars.\n\n    :param env: tmp env vars to set\n    :type env: dict\n\n    :yields: None\n    \"\"\"\n    orig_env = os.environ.copy()\n    expanded_env = {name: expandvars(var_val) for name, var_val in env.items()}\n    os.environ.update(expanded_env)\n\n    if cython_line_tracing_requested:\n        os.environ['CFLAGS'] = ' '.join((\n            os.getenv('CFLAGS', ''),\n            '-DCYTHON_TRACE_NOGIL=1',  # Implies CYTHON_TRACE=1\n        )).strip()\n    try:\n        yield\n    finally:\n        os.environ.clear()\n        os.environ.update(orig_env)\n", "packaging/pep517_backend/__main__.py": "import sys\n\nfrom . import cli\n\nif __name__ == \"__main__\":\n    sys.exit(cli.run_main_program(argv=sys.argv))\n", "packaging/pep517_backend/_compat.py": "\"\"\"Cross-python stdlib shims.\"\"\"\n\nimport os\nimport typing as t\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\ntry:\n    from contextlib import chdir as chdir_cm  # type: ignore[attr-defined]\nexcept ImportError:\n\n    @contextmanager  # type: ignore[no-redef]\n    def chdir_cm(path: os.PathLike) -> t.Iterator[None]:\n        \"\"\"Temporarily change the current directory, recovering on exit.\"\"\"\n        original_wd = Path.cwd()\n        os.chdir(path)\n        try:\n            yield\n        finally:\n            os.chdir(original_wd)\n\n\ntry:\n    from tomllib import loads as load_toml_from_string\nexcept ImportError:\n    from tomli import loads as load_toml_from_string  # type: ignore[no-redef]\n\n\n__all__ = (\"chdir_cm\", \"load_toml_from_string\")  # noqa: WPS410\n", "packaging/pep517_backend/__init__.py": "\"\"\"PEP 517 build backend for optionally pre-building Cython.\"\"\"\n", "packaging/pep517_backend/hooks.py": "\"\"\"PEP 517 build backend for optionally pre-building Cython.\"\"\"\n\nfrom contextlib import suppress as _suppress\n\nfrom setuptools.build_meta import *  # Re-exporting PEP 517 hooks  # pylint: disable=unused-wildcard-import,wildcard-import  # noqa: E501, F401, F403\n\n# Re-exporting PEP 517 hooks\nfrom ._backend import (  # type: ignore[assignment]  # noqa: WPS436\n    build_sdist,\n    build_wheel,\n    get_requires_for_build_wheel,\n    prepare_metadata_for_build_wheel,\n)\n\nwith _suppress(ImportError):  # Only succeeds w/ setuptools implementing PEP 660\n    # Re-exporting PEP 660 hooks\n    from ._backend import (  # type: ignore[assignment]  # noqa: WPS436\n        build_editable,\n        get_requires_for_build_editable,\n        prepare_metadata_for_build_editable,\n    )\n"}