{"benchmark.py": "import timeit\n\ncython_setup = \"\"\"\\\nfrom yarl._quoting_c import _Quoter as Quoter\nfrom yarl._quoting_c import _Unquoter as Unquoter\n\"\"\"\n\npython_setup = \"\"\"\\\nfrom yarl._quoting_py import _Quoter as Quoter\nfrom yarl._quoting_py import _Unquoter as Unquoter\n\"\"\"\n\n\nprint(\n    \"Cython quote ascii: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", cython_setup + \"s='/path/to';q=Quoter(safe='/')\")\n    )\n)\n\n\nprint(\n    \"Python quote ascii: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", python_setup + \"s='/path/to';q=Quoter(safe='/')\")\n    )\n)\n\n\nprint(\n    \"Cython quote PCT: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", cython_setup + \"s='abc%0a';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Python quote PCT: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", python_setup + \"s='abc%0a';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Cython quote: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", cython_setup + \"s='/\u0448\u043b\u044f\u0445/\u0444\u0430\u0439\u043b';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Python quote: {:.3f} sec\".format(\n        timeit.timeit(\"q(s)\", python_setup + \"s='/\u0448\u043b\u044f\u0445/\u0444\u0430\u0439\u043b';q=Quoter()\")\n    )\n)\n\n\nprint(\n    \"Cython unquote: {:.3f} sec\".format(\n        timeit.timeit(\"u(s)\", cython_setup + \"s='/path/to';u=Unquoter()\")\n    )\n)\n\n\nprint(\n    \"Python unquote: {:.3f} sec\".format(\n        timeit.timeit(\"u(s)\", python_setup + \"s='/path/to';u=Unquoter()\")\n    )\n)\n", "yarl/_quoting.py": "import os\nimport sys\n\n__all__ = (\"_Quoter\", \"_Unquoter\")\n\n\nNO_EXTENSIONS = bool(os.environ.get(\"YARL_NO_EXTENSIONS\"))  # type: bool\nif sys.implementation.name != \"cpython\":\n    NO_EXTENSIONS = True\n\n\nif not NO_EXTENSIONS:  # pragma: no branch\n    try:\n        from ._quoting_c import _Quoter, _Unquoter  # type: ignore[assignment]\n    except ImportError:  # pragma: no cover\n        from ._quoting_py import _Quoter, _Unquoter  # type: ignore[assignment]\nelse:\n    from ._quoting_py import _Quoter, _Unquoter  # type: ignore[assignment]\n", "yarl/_url.py": "import functools\nimport math\nimport warnings\nfrom collections.abc import Mapping, Sequence\nfrom contextlib import suppress\nfrom ipaddress import ip_address\nfrom urllib.parse import SplitResult, parse_qsl, quote, urljoin, urlsplit, urlunsplit\n\nimport idna\nfrom multidict import MultiDict, MultiDictProxy\n\nfrom ._quoting import _Quoter, _Unquoter\n\nDEFAULT_PORTS = {\"http\": 80, \"https\": 443, \"ws\": 80, \"wss\": 443}\n\nsentinel = object()\n\n\ndef rewrite_module(obj: object) -> object:\n    obj.__module__ = \"yarl\"\n    return obj\n\n\nclass cached_property:\n    \"\"\"Use as a class method decorator.  It operates almost exactly like\n    the Python `@property` decorator, but it puts the result of the\n    method it decorates into the instance dict after the first call,\n    effectively replacing the function it decorates with an instance\n    variable.  It is, in Python parlance, a data descriptor.\n\n    \"\"\"\n\n    def __init__(self, wrapped):\n        self.wrapped = wrapped\n        try:\n            self.__doc__ = wrapped.__doc__\n        except AttributeError:  # pragma: no cover\n            self.__doc__ = \"\"\n        self.name = wrapped.__name__\n\n    def __get__(self, inst, owner, _sentinel=sentinel):\n        if inst is None:\n            return self\n        val = inst._cache.get(self.name, _sentinel)\n        if val is not _sentinel:\n            return val\n        val = self.wrapped(inst)\n        inst._cache[self.name] = val\n        return val\n\n    def __set__(self, inst, value):\n        raise AttributeError(\"cached property is read-only\")\n\n\ndef _normalize_path_segments(segments):\n    \"\"\"Drop '.' and '..' from a sequence of str segments\"\"\"\n\n    resolved_path = []\n\n    for seg in segments:\n        if seg == \"..\":\n            # ignore any .. segments that would otherwise cause an\n            # IndexError when popped from resolved_path if\n            # resolving for rfc3986\n            with suppress(IndexError):\n                resolved_path.pop()\n        elif seg != \".\":\n            resolved_path.append(seg)\n\n    if segments and segments[-1] in (\".\", \"..\"):\n        # do some post-processing here.\n        # if the last segment was a relative dir,\n        # then we need to append the trailing '/'\n        resolved_path.append(\"\")\n\n    return resolved_path\n\n\n@rewrite_module\nclass URL:\n    # Don't derive from str\n    # follow pathlib.Path design\n    # probably URL will not suffer from pathlib problems:\n    # it's intended for libraries like aiohttp,\n    # not to be passed into standard library functions like os.open etc.\n\n    # URL grammar (RFC 3986)\n    # pct-encoded = \"%\" HEXDIG HEXDIG\n    # reserved    = gen-delims / sub-delims\n    # gen-delims  = \":\" / \"/\" / \"?\" / \"#\" / \"[\" / \"]\" / \"@\"\n    # sub-delims  = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n    #             / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n    # unreserved  = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n    # URI         = scheme \":\" hier-part [ \"?\" query ] [ \"#\" fragment ]\n    # hier-part   = \"//\" authority path-abempty\n    #             / path-absolute\n    #             / path-rootless\n    #             / path-empty\n    # scheme      = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \".\" )\n    # authority   = [ userinfo \"@\" ] host [ \":\" port ]\n    # userinfo    = *( unreserved / pct-encoded / sub-delims / \":\" )\n    # host        = IP-literal / IPv4address / reg-name\n    # IP-literal = \"[\" ( IPv6address / IPvFuture  ) \"]\"\n    # IPvFuture  = \"v\" 1*HEXDIG \".\" 1*( unreserved / sub-delims / \":\" )\n    # IPv6address =                            6( h16 \":\" ) ls32\n    #             /                       \"::\" 5( h16 \":\" ) ls32\n    #             / [               h16 ] \"::\" 4( h16 \":\" ) ls32\n    #             / [ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    #             / [ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    #             / [ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    #             / [ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    #             / [ *5( h16 \":\" ) h16 ] \"::\"              h16\n    #             / [ *6( h16 \":\" ) h16 ] \"::\"\n    # ls32        = ( h16 \":\" h16 ) / IPv4address\n    #             ; least-significant 32 bits of address\n    # h16         = 1*4HEXDIG\n    #             ; 16 bits of address represented in hexadecimal\n    # IPv4address = dec-octet \".\" dec-octet \".\" dec-octet \".\" dec-octet\n    # dec-octet   = DIGIT                 ; 0-9\n    #             / %x31-39 DIGIT         ; 10-99\n    #             / \"1\" 2DIGIT            ; 100-199\n    #             / \"2\" %x30-34 DIGIT     ; 200-249\n    #             / \"25\" %x30-35          ; 250-255\n    # reg-name    = *( unreserved / pct-encoded / sub-delims )\n    # port        = *DIGIT\n    # path          = path-abempty    ; begins with \"/\" or is empty\n    #               / path-absolute   ; begins with \"/\" but not \"//\"\n    #               / path-noscheme   ; begins with a non-colon segment\n    #               / path-rootless   ; begins with a segment\n    #               / path-empty      ; zero characters\n    # path-abempty  = *( \"/\" segment )\n    # path-absolute = \"/\" [ segment-nz *( \"/\" segment ) ]\n    # path-noscheme = segment-nz-nc *( \"/\" segment )\n    # path-rootless = segment-nz *( \"/\" segment )\n    # path-empty    = 0<pchar>\n    # segment       = *pchar\n    # segment-nz    = 1*pchar\n    # segment-nz-nc = 1*( unreserved / pct-encoded / sub-delims / \"@\" )\n    #               ; non-zero-length segment without any colon \":\"\n    # pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n    # query       = *( pchar / \"/\" / \"?\" )\n    # fragment    = *( pchar / \"/\" / \"?\" )\n    # URI-reference = URI / relative-ref\n    # relative-ref  = relative-part [ \"?\" query ] [ \"#\" fragment ]\n    # relative-part = \"//\" authority path-abempty\n    #               / path-absolute\n    #               / path-noscheme\n    #               / path-empty\n    # absolute-URI  = scheme \":\" hier-part [ \"?\" query ]\n    __slots__ = (\"_cache\", \"_val\")\n\n    _QUOTER = _Quoter(requote=False)\n    _REQUOTER = _Quoter()\n    _PATH_QUOTER = _Quoter(safe=\"@:\", protected=\"/+\", requote=False)\n    _PATH_REQUOTER = _Quoter(safe=\"@:\", protected=\"/+\")\n    _QUERY_QUOTER = _Quoter(safe=\"?/:@\", protected=\"=+&;\", qs=True, requote=False)\n    _QUERY_REQUOTER = _Quoter(safe=\"?/:@\", protected=\"=+&;\", qs=True)\n    _QUERY_PART_QUOTER = _Quoter(safe=\"?/:@\", qs=True, requote=False)\n    _FRAGMENT_QUOTER = _Quoter(safe=\"?/:@\", requote=False)\n    _FRAGMENT_REQUOTER = _Quoter(safe=\"?/:@\")\n\n    _UNQUOTER = _Unquoter()\n    _PATH_UNQUOTER = _Unquoter(unsafe=\"+\")\n    _QS_UNQUOTER = _Unquoter(qs=True)\n\n    def __new__(cls, val=\"\", *, encoded=False, strict=None):\n        if strict is not None:  # pragma: no cover\n            warnings.warn(\"strict parameter is ignored\")\n        if type(val) is cls:\n            return val\n        if type(val) is str:\n            val = urlsplit(val)\n        elif type(val) is SplitResult:\n            if not encoded:\n                raise ValueError(\"Cannot apply decoding to SplitResult\")\n        elif isinstance(val, str):\n            val = urlsplit(str(val))\n        else:\n            raise TypeError(\"Constructor parameter should be str\")\n\n        if not encoded:\n            if not val[1]:  # netloc\n                netloc = \"\"\n                host = \"\"\n            else:\n                host = val.hostname\n                if host is None:\n                    raise ValueError(\"Invalid URL: host is required for absolute urls\")\n\n                try:\n                    port = val.port\n                except ValueError as e:\n                    raise ValueError(\n                        \"Invalid URL: port can't be converted to integer\"\n                    ) from e\n\n                netloc = cls._make_netloc(\n                    val.username, val.password, host, port, encode=True, requote=True\n                )\n            path = cls._PATH_REQUOTER(val[2])\n            if netloc:\n                path = cls._normalize_path(path)\n\n            cls._validate_authority_uri_abs_path(host=host, path=path)\n            query = cls._QUERY_REQUOTER(val[3])\n            fragment = cls._FRAGMENT_REQUOTER(val[4])\n            val = SplitResult(val[0], netloc, path, query, fragment)\n\n        self = object.__new__(cls)\n        self._val = val\n        self._cache = {}\n        return self\n\n    @classmethod\n    def build(\n        cls,\n        *,\n        scheme=\"\",\n        authority=\"\",\n        user=None,\n        password=None,\n        host=\"\",\n        port=None,\n        path=\"\",\n        query=None,\n        query_string=\"\",\n        fragment=\"\",\n        encoded=False,\n    ):\n        \"\"\"Creates and returns a new URL\"\"\"\n\n        if authority and (user or password or host or port):\n            raise ValueError(\n                'Can\\'t mix \"authority\" with \"user\", \"password\", \"host\" or \"port\".'\n            )\n        if not isinstance(port, (int, type(None))):\n            raise TypeError(\"The port is required to be int.\")\n        if port and not host:\n            raise ValueError('Can\\'t build URL with \"port\" but without \"host\".')\n        if query and query_string:\n            raise ValueError('Only one of \"query\" or \"query_string\" should be passed')\n        if (\n            scheme is None\n            or authority is None\n            or host is None\n            or path is None\n            or query_string is None\n            or fragment is None\n        ):\n            raise TypeError(\n                'NoneType is illegal for \"scheme\", \"authority\", \"host\", \"path\", '\n                '\"query_string\", and \"fragment\" args, use empty string instead.'\n            )\n\n        if authority:\n            if encoded:\n                netloc = authority\n            else:\n                tmp = SplitResult(\"\", authority, \"\", \"\", \"\")\n                netloc = cls._make_netloc(\n                    tmp.username, tmp.password, tmp.hostname, tmp.port, encode=True\n                )\n        elif not user and not password and not host and not port:\n            netloc = \"\"\n        else:\n            netloc = cls._make_netloc(\n                user, password, host, port, encode=not encoded, encode_host=not encoded\n            )\n        if not encoded:\n            path = cls._PATH_QUOTER(path)\n            if netloc:\n                path = cls._normalize_path(path)\n\n            cls._validate_authority_uri_abs_path(host=host, path=path)\n            query_string = cls._QUERY_QUOTER(query_string)\n            fragment = cls._FRAGMENT_QUOTER(fragment)\n\n        url = cls(\n            SplitResult(scheme, netloc, path, query_string, fragment), encoded=True\n        )\n\n        if query:\n            return url.with_query(query)\n        else:\n            return url\n\n    def __init_subclass__(cls):\n        raise TypeError(f\"Inheriting a class {cls!r} from URL is forbidden\")\n\n    def __str__(self):\n        val = self._val\n        if not val.path and self.is_absolute() and (val.query or val.fragment):\n            val = val._replace(path=\"/\")\n        return urlunsplit(val)\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}('{str(self)}')\"\n\n    def __bytes__(self):\n        return str(self).encode(\"ascii\")\n\n    def __eq__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n\n        val1 = self._val\n        if not val1.path and self.is_absolute():\n            val1 = val1._replace(path=\"/\")\n\n        val2 = other._val\n        if not val2.path and other.is_absolute():\n            val2 = val2._replace(path=\"/\")\n\n        return val1 == val2\n\n    def __hash__(self):\n        ret = self._cache.get(\"hash\")\n        if ret is None:\n            val = self._val\n            if not val.path and self.is_absolute():\n                val = val._replace(path=\"/\")\n            ret = self._cache[\"hash\"] = hash(val)\n        return ret\n\n    def __le__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val <= other._val\n\n    def __lt__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val < other._val\n\n    def __ge__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val >= other._val\n\n    def __gt__(self, other):\n        if not type(other) is URL:\n            return NotImplemented\n        return self._val > other._val\n\n    def __truediv__(self, name):\n        if not isinstance(name, str):\n            return NotImplemented\n        return self._make_child((str(name),))\n\n    def __mod__(self, query):\n        return self.update_query(query)\n\n    def __bool__(self) -> bool:\n        return bool(\n            self._val.netloc or self._val.path or self._val.query or self._val.fragment\n        )\n\n    def __getstate__(self):\n        return (self._val,)\n\n    def __setstate__(self, state):\n        if state[0] is None and isinstance(state[1], dict):\n            # default style pickle\n            self._val = state[1][\"_val\"]\n        else:\n            self._val, *unused = state\n        self._cache = {}\n\n    def is_absolute(self):\n        \"\"\"A check for absolute URLs.\n\n        Return True for absolute ones (having scheme or starting\n        with //), False otherwise.\n\n        \"\"\"\n        return self.raw_host is not None\n\n    def is_default_port(self):\n        \"\"\"A check for default port.\n\n        Return True if port is default for specified scheme,\n        e.g. 'http://python.org' or 'http://python.org:80', False\n        otherwise.\n\n        \"\"\"\n        if self.port is None:\n            return False\n        default = DEFAULT_PORTS.get(self.scheme)\n        if default is None:\n            return False\n        return self.port == default\n\n    def origin(self):\n        \"\"\"Return an URL with scheme, host and port parts only.\n\n        user, password, path, query and fragment are removed.\n\n        \"\"\"\n        # TODO: add a keyword-only option for keeping user/pass maybe?\n        if not self.is_absolute():\n            raise ValueError(\"URL should be absolute\")\n        if not self._val.scheme:\n            raise ValueError(\"URL should have scheme\")\n        v = self._val\n        netloc = self._make_netloc(None, None, v.hostname, v.port)\n        val = v._replace(netloc=netloc, path=\"\", query=\"\", fragment=\"\")\n        return URL(val, encoded=True)\n\n    def relative(self):\n        \"\"\"Return a relative part of the URL.\n\n        scheme, user, password, host and port are removed.\n\n        \"\"\"\n        if not self.is_absolute():\n            raise ValueError(\"URL should be absolute\")\n        val = self._val._replace(scheme=\"\", netloc=\"\")\n        return URL(val, encoded=True)\n\n    @property\n    def scheme(self):\n        \"\"\"Scheme for absolute URLs.\n\n        Empty string for relative URLs or URLs starting with //\n\n        \"\"\"\n        return self._val.scheme\n\n    @property\n    def raw_authority(self):\n        \"\"\"Encoded authority part of URL.\n\n        Empty string for relative URLs.\n\n        \"\"\"\n        return self._val.netloc\n\n    @cached_property\n    def authority(self):\n        \"\"\"Decoded authority part of URL.\n\n        Empty string for relative URLs.\n\n        \"\"\"\n        return self._make_netloc(\n            self.user, self.password, self.host, self.port, encode_host=False\n        )\n\n    @property\n    def raw_user(self):\n        \"\"\"Encoded user part of URL.\n\n        None if user is missing.\n\n        \"\"\"\n        # not .username\n        ret = self._val.username\n        if not ret:\n            return None\n        return ret\n\n    @cached_property\n    def user(self):\n        \"\"\"Decoded user part of URL.\n\n        None if user is missing.\n\n        \"\"\"\n        return self._UNQUOTER(self.raw_user)\n\n    @property\n    def raw_password(self):\n        \"\"\"Encoded password part of URL.\n\n        None if password is missing.\n\n        \"\"\"\n        return self._val.password\n\n    @cached_property\n    def password(self):\n        \"\"\"Decoded password part of URL.\n\n        None if password is missing.\n\n        \"\"\"\n        return self._UNQUOTER(self.raw_password)\n\n    @property\n    def raw_host(self):\n        \"\"\"Encoded host part of URL.\n\n        None for relative URLs.\n\n        \"\"\"\n        # Use host instead of hostname for sake of shortness\n        # May add .hostname prop later\n        return self._val.hostname\n\n    @cached_property\n    def host(self):\n        \"\"\"Decoded host part of URL.\n\n        None for relative URLs.\n\n        \"\"\"\n        raw = self.raw_host\n        if raw is None:\n            return None\n        if \"%\" in raw:\n            # Hack for scoped IPv6 addresses like\n            # fe80::2%\u041f\u0435\u0440\u0435\u0432\u0456\u0440\u043a\u0430\n            # presence of '%' sign means only IPv6 address, so idna is useless.\n            return raw\n        return _idna_decode(raw)\n\n    @property\n    def port(self):\n        \"\"\"Port part of URL, with scheme-based fallback.\n\n        None for relative URLs or URLs without explicit port and\n        scheme without default port substitution.\n\n        \"\"\"\n        return self._val.port or DEFAULT_PORTS.get(self._val.scheme)\n\n    @property\n    def explicit_port(self):\n        \"\"\"Port part of URL, without scheme-based fallback.\n\n        None for relative URLs or URLs without explicit port.\n\n        \"\"\"\n        return self._val.port\n\n    @property\n    def raw_path(self):\n        \"\"\"Encoded path of URL.\n\n        / for absolute URLs without path part.\n\n        \"\"\"\n        ret = self._val.path\n        if not ret and self.is_absolute():\n            ret = \"/\"\n        return ret\n\n    @cached_property\n    def path(self):\n        \"\"\"Decoded path of URL.\n\n        / for absolute URLs without path part.\n\n        \"\"\"\n        return self._PATH_UNQUOTER(self.raw_path)\n\n    @cached_property\n    def query(self):\n        \"\"\"A MultiDictProxy representing parsed query parameters in decoded\n        representation.\n\n        Empty value if URL has no query part.\n\n        \"\"\"\n        ret = MultiDict(parse_qsl(self.raw_query_string, keep_blank_values=True))\n        return MultiDictProxy(ret)\n\n    @property\n    def raw_query_string(self):\n        \"\"\"Encoded query part of URL.\n\n        Empty string if query is missing.\n\n        \"\"\"\n        return self._val.query\n\n    @cached_property\n    def query_string(self):\n        \"\"\"Decoded query part of URL.\n\n        Empty string if query is missing.\n\n        \"\"\"\n        return self._QS_UNQUOTER(self.raw_query_string)\n\n    @cached_property\n    def path_qs(self):\n        \"\"\"Decoded path of URL with query.\"\"\"\n        if not self.query_string:\n            return self.path\n        return f\"{self.path}?{self.query_string}\"\n\n    @cached_property\n    def raw_path_qs(self):\n        \"\"\"Encoded path of URL with query.\"\"\"\n        if not self.raw_query_string:\n            return self.raw_path\n        return f\"{self.raw_path}?{self.raw_query_string}\"\n\n    @property\n    def raw_fragment(self):\n        \"\"\"Encoded fragment part of URL.\n\n        Empty string if fragment is missing.\n\n        \"\"\"\n        return self._val.fragment\n\n    @cached_property\n    def fragment(self):\n        \"\"\"Decoded fragment part of URL.\n\n        Empty string if fragment is missing.\n\n        \"\"\"\n        return self._UNQUOTER(self.raw_fragment)\n\n    @cached_property\n    def raw_parts(self):\n        \"\"\"A tuple containing encoded *path* parts.\n\n        ('/',) for absolute URLs if *path* is missing.\n\n        \"\"\"\n        path = self._val.path\n        if self.is_absolute():\n            if not path:\n                parts = [\"/\"]\n            else:\n                parts = [\"/\"] + path[1:].split(\"/\")\n        else:\n            if path.startswith(\"/\"):\n                parts = [\"/\"] + path[1:].split(\"/\")\n            else:\n                parts = path.split(\"/\")\n        return tuple(parts)\n\n    @cached_property\n    def parts(self):\n        \"\"\"A tuple containing decoded *path* parts.\n\n        ('/',) for absolute URLs if *path* is missing.\n\n        \"\"\"\n        return tuple(self._UNQUOTER(part) for part in self.raw_parts)\n\n    @cached_property\n    def parent(self):\n        \"\"\"A new URL with last part of path removed and cleaned up query and\n        fragment.\n\n        \"\"\"\n        path = self.raw_path\n        if not path or path == \"/\":\n            if self.raw_fragment or self.raw_query_string:\n                return URL(self._val._replace(query=\"\", fragment=\"\"), encoded=True)\n            return self\n        parts = path.split(\"/\")\n        val = self._val._replace(path=\"/\".join(parts[:-1]), query=\"\", fragment=\"\")\n        return URL(val, encoded=True)\n\n    @cached_property\n    def raw_name(self):\n        \"\"\"The last part of raw_parts.\"\"\"\n        parts = self.raw_parts\n        if self.is_absolute():\n            parts = parts[1:]\n            if not parts:\n                return \"\"\n            else:\n                return parts[-1]\n        else:\n            return parts[-1]\n\n    @cached_property\n    def name(self):\n        \"\"\"The last part of parts.\"\"\"\n        return self._UNQUOTER(self.raw_name)\n\n    @cached_property\n    def raw_suffix(self):\n        name = self.raw_name\n        i = name.rfind(\".\")\n        if 0 < i < len(name) - 1:\n            return name[i:]\n        else:\n            return \"\"\n\n    @cached_property\n    def suffix(self):\n        return self._UNQUOTER(self.raw_suffix)\n\n    @cached_property\n    def raw_suffixes(self):\n        name = self.raw_name\n        if name.endswith(\".\"):\n            return ()\n        name = name.lstrip(\".\")\n        return tuple(\".\" + suffix for suffix in name.split(\".\")[1:])\n\n    @cached_property\n    def suffixes(self):\n        return tuple(self._UNQUOTER(suffix) for suffix in self.raw_suffixes)\n\n    @staticmethod\n    def _validate_authority_uri_abs_path(host, path):\n        \"\"\"Ensure that path in URL with authority starts with a leading slash.\n\n        Raise ValueError if not.\n        \"\"\"\n        if len(host) > 0 and len(path) > 0 and not path.startswith(\"/\"):\n            raise ValueError(\n                \"Path in a URL with authority should start with a slash ('/') if set\"\n            )\n\n    def _make_child(self, segments, encoded=False):\n        \"\"\"add segments to self._val.path, accounting for absolute vs relative paths\"\"\"\n        # keep the trailing slash if the last segment ends with /\n        parsed = [\"\"] if segments and segments[-1][-1:] == \"/\" else []\n        for seg in reversed(segments):\n            if not seg:\n                continue\n            if seg[0] == \"/\":\n                raise ValueError(\n                    f\"Appending path {seg!r} starting from slash is forbidden\"\n                )\n            seg = seg if encoded else self._PATH_QUOTER(seg)\n            if \"/\" in seg:\n                parsed += (\n                    sub for sub in reversed(seg.split(\"/\")) if sub and sub != \".\"\n                )\n            elif seg != \".\":\n                parsed.append(seg)\n        parsed.reverse()\n        old_path = self._val.path\n        if old_path:\n            parsed = [*old_path.rstrip(\"/\").split(\"/\"), *parsed]\n        if self.is_absolute():\n            parsed = _normalize_path_segments(parsed)\n            if parsed and parsed[0] != \"\":\n                # inject a leading slash when adding a path to an absolute URL\n                # where there was none before\n                parsed = [\"\", *parsed]\n        new_path = \"/\".join(parsed)\n        return URL(\n            self._val._replace(path=new_path, query=\"\", fragment=\"\"), encoded=True\n        )\n\n    @classmethod\n    def _normalize_path(cls, path):\n        # Drop '.' and '..' from str path\n\n        prefix = \"\"\n        if path.startswith(\"/\"):\n            # preserve the \"/\" root element of absolute paths, copying it to the\n            # normalised output as per sections 5.2.4 and 6.2.2.3 of rfc3986.\n            prefix = \"/\"\n            path = path[1:]\n\n        segments = path.split(\"/\")\n        return prefix + \"/\".join(_normalize_path_segments(segments))\n\n    @classmethod\n    def _encode_host(cls, host, human=False):\n        try:\n            ip, sep, zone = host.partition(\"%\")\n            ip = ip_address(ip)\n        except ValueError:\n            host = host.lower()\n            # IDNA encoding is slow,\n            # skip it for ASCII-only strings\n            # Don't move the check into _idna_encode() helper\n            # to reduce the cache size\n            if human or host.isascii():\n                return host\n            host = _idna_encode(host)\n        else:\n            host = ip.compressed\n            if sep:\n                host += \"%\" + zone\n            if ip.version == 6:\n                host = \"[\" + host + \"]\"\n        return host\n\n    @classmethod\n    def _make_netloc(\n        cls, user, password, host, port, encode=False, encode_host=True, requote=False\n    ):\n        quoter = cls._REQUOTER if requote else cls._QUOTER\n        if encode_host:\n            ret = cls._encode_host(host)\n        else:\n            ret = host\n        if port is not None:\n            ret = ret + \":\" + str(port)\n        if password is not None:\n            if not user:\n                user = \"\"\n            else:\n                if encode:\n                    user = quoter(user)\n            if encode:\n                password = quoter(password)\n            user = user + \":\" + password\n        elif user and encode:\n            user = quoter(user)\n        if user:\n            ret = user + \"@\" + ret\n        return ret\n\n    def with_scheme(self, scheme):\n        \"\"\"Return a new URL with scheme replaced.\"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if not isinstance(scheme, str):\n            raise TypeError(\"Invalid scheme type\")\n        if not self.is_absolute():\n            raise ValueError(\"scheme replacement is not allowed for relative URLs\")\n        return URL(self._val._replace(scheme=scheme.lower()), encoded=True)\n\n    def with_user(self, user):\n        \"\"\"Return a new URL with user replaced.\n\n        Autoencode user if needed.\n\n        Clear user/password if user is None.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        val = self._val\n        if user is None:\n            password = None\n        elif isinstance(user, str):\n            user = self._QUOTER(user)\n            password = val.password\n        else:\n            raise TypeError(\"Invalid user type\")\n        if not self.is_absolute():\n            raise ValueError(\"user replacement is not allowed for relative URLs\")\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(user, password, val.hostname, val.port)\n            ),\n            encoded=True,\n        )\n\n    def with_password(self, password):\n        \"\"\"Return a new URL with password replaced.\n\n        Autoencode password if needed.\n\n        Clear password if argument is None.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if password is None:\n            pass\n        elif isinstance(password, str):\n            password = self._QUOTER(password)\n        else:\n            raise TypeError(\"Invalid password type\")\n        if not self.is_absolute():\n            raise ValueError(\"password replacement is not allowed for relative URLs\")\n        val = self._val\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(val.username, password, val.hostname, val.port)\n            ),\n            encoded=True,\n        )\n\n    def with_host(self, host):\n        \"\"\"Return a new URL with host replaced.\n\n        Autoencode host if needed.\n\n        Changing host for relative URLs is not allowed, use .join()\n        instead.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if not isinstance(host, str):\n            raise TypeError(\"Invalid host type\")\n        if not self.is_absolute():\n            raise ValueError(\"host replacement is not allowed for relative URLs\")\n        if not host:\n            raise ValueError(\"host removing is not allowed\")\n        val = self._val\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(val.username, val.password, host, val.port)\n            ),\n            encoded=True,\n        )\n\n    def with_port(self, port):\n        \"\"\"Return a new URL with port replaced.\n\n        Clear port to default if None is passed.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if port is not None:\n            if isinstance(port, bool) or not isinstance(port, int):\n                raise TypeError(f\"port should be int or None, got {type(port)}\")\n            if port < 0 or port > 65535:\n                raise ValueError(f\"port must be between 0 and 65535, got {port}\")\n        if not self.is_absolute():\n            raise ValueError(\"port replacement is not allowed for relative URLs\")\n        val = self._val\n        return URL(\n            self._val._replace(\n                netloc=self._make_netloc(val.username, val.password, val.hostname, port)\n            ),\n            encoded=True,\n        )\n\n    def with_path(self, path, *, encoded=False):\n        \"\"\"Return a new URL with path replaced.\"\"\"\n        if not encoded:\n            path = self._PATH_QUOTER(path)\n            if self.is_absolute():\n                path = self._normalize_path(path)\n        if len(path) > 0 and path[0] != \"/\":\n            path = \"/\" + path\n        return URL(self._val._replace(path=path, query=\"\", fragment=\"\"), encoded=True)\n\n    @classmethod\n    def _query_seq_pairs(cls, quoter, pairs):\n        for key, val in pairs:\n            if isinstance(val, (list, tuple)):\n                for v in val:\n                    yield quoter(key) + \"=\" + quoter(cls._query_var(v))\n            else:\n                yield quoter(key) + \"=\" + quoter(cls._query_var(val))\n\n    @staticmethod\n    def _query_var(v):\n        cls = type(v)\n        if issubclass(cls, str):\n            return v\n        if issubclass(cls, float):\n            if math.isinf(v):\n                raise ValueError(\"float('inf') is not supported\")\n            if math.isnan(v):\n                raise ValueError(\"float('nan') is not supported\")\n            return str(float(v))\n        if issubclass(cls, int) and cls is not bool:\n            return str(int(v))\n        raise TypeError(\n            \"Invalid variable type: value \"\n            \"should be str, int or float, got {!r} \"\n            \"of type {}\".format(v, cls)\n        )\n\n    def _get_str_query(self, *args, **kwargs):\n        if kwargs:\n            if len(args) > 0:\n                raise ValueError(\n                    \"Either kwargs or single query parameter must be present\"\n                )\n            query = kwargs\n        elif len(args) == 1:\n            query = args[0]\n        else:\n            raise ValueError(\"Either kwargs or single query parameter must be present\")\n\n        if query is None:\n            query = None\n        elif isinstance(query, Mapping):\n            quoter = self._QUERY_PART_QUOTER\n            query = \"&\".join(self._query_seq_pairs(quoter, query.items()))\n        elif isinstance(query, str):\n            query = self._QUERY_QUOTER(query)\n        elif isinstance(query, (bytes, bytearray, memoryview)):\n            raise TypeError(\n                \"Invalid query type: bytes, bytearray and memoryview are forbidden\"\n            )\n        elif isinstance(query, Sequence):\n            quoter = self._QUERY_PART_QUOTER\n            # We don't expect sequence values if we're given a list of pairs\n            # already; only mappings like builtin `dict` which can't have the\n            # same key pointing to multiple values are allowed to use\n            # `_query_seq_pairs`.\n            query = \"&\".join(\n                quoter(k) + \"=\" + quoter(self._query_var(v)) for k, v in query\n            )\n        else:\n            raise TypeError(\n                \"Invalid query type: only str, mapping or \"\n                \"sequence of (key, value) pairs is allowed\"\n            )\n\n        return query\n\n    def with_query(self, *args, **kwargs):\n        \"\"\"Return a new URL with query part replaced.\n\n        Accepts any Mapping (e.g. dict, multidict.MultiDict instances)\n        or str, autoencode the argument if needed.\n\n        A sequence of (key, value) pairs is supported as well.\n\n        It also can take an arbitrary number of keyword arguments.\n\n        Clear query if None is passed.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n\n        new_query = self._get_str_query(*args, **kwargs) or \"\"\n        return URL(\n            self._val._replace(path=self._val.path, query=new_query), encoded=True\n        )\n\n    def update_query(self, *args, **kwargs):\n        \"\"\"Return a new URL with query part updated.\"\"\"\n        s = self._get_str_query(*args, **kwargs)\n        query = None\n        if s is not None:\n            new_query = MultiDict(parse_qsl(s, keep_blank_values=True))\n            query = MultiDict(self.query)\n            query.update(new_query)\n\n        return URL(\n            self._val._replace(query=self._get_str_query(query) or \"\"), encoded=True\n        )\n\n    def with_fragment(self, fragment):\n        \"\"\"Return a new URL with fragment replaced.\n\n        Autoencode fragment if needed.\n\n        Clear fragment to default if None is passed.\n\n        \"\"\"\n        # N.B. doesn't cleanup query/fragment\n        if fragment is None:\n            raw_fragment = \"\"\n        elif not isinstance(fragment, str):\n            raise TypeError(\"Invalid fragment type\")\n        else:\n            raw_fragment = self._FRAGMENT_QUOTER(fragment)\n        if self.raw_fragment == raw_fragment:\n            return self\n        return URL(self._val._replace(fragment=raw_fragment), encoded=True)\n\n    def with_name(self, name):\n        \"\"\"Return a new URL with name (last part of path) replaced.\n\n        Query and fragment parts are cleaned up.\n\n        Name is encoded if needed.\n\n        \"\"\"\n        # N.B. DOES cleanup query/fragment\n        if not isinstance(name, str):\n            raise TypeError(\"Invalid name type\")\n        if \"/\" in name:\n            raise ValueError(\"Slash in name is not allowed\")\n        name = self._PATH_QUOTER(name)\n        if name in (\".\", \"..\"):\n            raise ValueError(\". and .. values are forbidden\")\n        parts = list(self.raw_parts)\n        if self.is_absolute():\n            if len(parts) == 1:\n                parts.append(name)\n            else:\n                parts[-1] = name\n            parts[0] = \"\"  # replace leading '/'\n        else:\n            parts[-1] = name\n            if parts[0] == \"/\":\n                parts[0] = \"\"  # replace leading '/'\n        return URL(\n            self._val._replace(path=\"/\".join(parts), query=\"\", fragment=\"\"),\n            encoded=True,\n        )\n\n    def with_suffix(self, suffix):\n        \"\"\"Return a new URL with suffix (file extension of name) replaced.\n\n        Query and fragment parts are cleaned up.\n\n        suffix is encoded if needed.\n        \"\"\"\n        if not isinstance(suffix, str):\n            raise TypeError(\"Invalid suffix type\")\n        if suffix and not suffix.startswith(\".\") or suffix == \".\":\n            raise ValueError(f\"Invalid suffix {suffix!r}\")\n        name = self.raw_name\n        if not name:\n            raise ValueError(f\"{self!r} has an empty name\")\n        old_suffix = self.raw_suffix\n        if not old_suffix:\n            name = name + suffix\n        else:\n            name = name[: -len(old_suffix)] + suffix\n        return self.with_name(name)\n\n    def join(self, url):\n        \"\"\"Join URLs\n\n        Construct a full (\u201cabsolute\u201d) URL by combining a \u201cbase URL\u201d\n        (self) with another URL (url).\n\n        Informally, this uses components of the base URL, in\n        particular the addressing scheme, the network location and\n        (part of) the path, to provide missing components in the\n        relative URL.\n\n        \"\"\"\n        # See docs for urllib.parse.urljoin\n        if not isinstance(url, URL):\n            raise TypeError(\"url should be URL\")\n        return URL(urljoin(str(self), str(url)), encoded=True)\n\n    def joinpath(self, *other, encoded=False):\n        \"\"\"Return a new URL with the elements in other appended to the path.\"\"\"\n        return self._make_child(other, encoded=encoded)\n\n    def human_repr(self):\n        \"\"\"Return decoded human readable string for URL representation.\"\"\"\n        user = _human_quote(self.user, \"#/:?@[]\")\n        password = _human_quote(self.password, \"#/:?@[]\")\n        host = self.host\n        if host:\n            host = self._encode_host(self.host, human=True)\n        path = _human_quote(self.path, \"#?\")\n        query_string = \"&\".join(\n            \"{}={}\".format(_human_quote(k, \"#&+;=\"), _human_quote(v, \"#&+;=\"))\n            for k, v in self.query.items()\n        )\n        fragment = _human_quote(self.fragment, \"\")\n        return urlunsplit(\n            SplitResult(\n                self.scheme,\n                self._make_netloc(\n                    user,\n                    password,\n                    host,\n                    self._val.port,\n                    encode_host=False,\n                ),\n                path,\n                query_string,\n                fragment,\n            )\n        )\n\n\ndef _human_quote(s, unsafe):\n    if not s:\n        return s\n    for c in \"%\" + unsafe:\n        if c in s:\n            s = s.replace(c, f\"%{ord(c):02X}\")\n    if s.isprintable():\n        return s\n    return \"\".join(c if c.isprintable() else quote(c) for c in s)\n\n\n_MAXCACHE = 256\n\n\n@functools.lru_cache(_MAXCACHE)\ndef _idna_decode(raw):\n    try:\n        return idna.decode(raw.encode(\"ascii\"))\n    except UnicodeError:  # e.g. '::1'\n        return raw.encode(\"ascii\").decode(\"idna\")\n\n\n@functools.lru_cache(_MAXCACHE)\ndef _idna_encode(host):\n    try:\n        return idna.encode(host, uts46=True).decode(\"ascii\")\n    except UnicodeError:\n        return host.encode(\"idna\").decode(\"ascii\")\n\n\n@rewrite_module\ndef cache_clear():\n    _idna_decode.cache_clear()\n    _idna_encode.cache_clear()\n\n\n@rewrite_module\ndef cache_info():\n    return {\n        \"idna_encode\": _idna_encode.cache_info(),\n        \"idna_decode\": _idna_decode.cache_info(),\n    }\n\n\n@rewrite_module\ndef cache_configure(*, idna_encode_size=_MAXCACHE, idna_decode_size=_MAXCACHE):\n    global _idna_decode, _idna_encode\n\n    _idna_encode = functools.lru_cache(idna_encode_size)(_idna_encode.__wrapped__)\n    _idna_decode = functools.lru_cache(idna_decode_size)(_idna_decode.__wrapped__)\n", "yarl/_quoting_py.py": "import codecs\nimport re\nfrom string import ascii_letters, ascii_lowercase, digits\nfrom typing import Optional, cast\n\nBASCII_LOWERCASE = ascii_lowercase.encode(\"ascii\")\nBPCT_ALLOWED = {f\"%{i:02X}\".encode(\"ascii\") for i in range(256)}\nGEN_DELIMS = \":/?#[]@\"\nSUB_DELIMS_WITHOUT_QS = \"!$'()*,\"\nSUB_DELIMS = SUB_DELIMS_WITHOUT_QS + \"+&=;\"\nRESERVED = GEN_DELIMS + SUB_DELIMS\nUNRESERVED = ascii_letters + digits + \"-._~\"\nALLOWED = UNRESERVED + SUB_DELIMS_WITHOUT_QS\n\n\n_IS_HEX = re.compile(b\"[A-Z0-9][A-Z0-9]\")\n_IS_HEX_STR = re.compile(\"[A-Fa-f0-9][A-Fa-f0-9]\")\n\nutf8_decoder = codecs.getincrementaldecoder(\"utf-8\")\n\n\nclass _Quoter:\n    def __init__(\n        self,\n        *,\n        safe: str = \"\",\n        protected: str = \"\",\n        qs: bool = False,\n        requote: bool = True,\n    ) -> None:\n        self._safe = safe\n        self._protected = protected\n        self._qs = qs\n        self._requote = requote\n\n    def __call__(self, val: Optional[str]) -> Optional[str]:\n        if val is None:\n            return None\n        if not isinstance(val, str):\n            raise TypeError(\"Argument should be str\")\n        if not val:\n            return \"\"\n        bval = cast(str, val).encode(\"utf8\", errors=\"ignore\")\n        ret = bytearray()\n        pct = bytearray()\n        safe = self._safe\n        safe += ALLOWED\n        if not self._qs:\n            safe += \"+&=;\"\n        safe += self._protected\n        bsafe = safe.encode(\"ascii\")\n        idx = 0\n        while idx < len(bval):\n            ch = bval[idx]\n            idx += 1\n\n            if pct:\n                if ch in BASCII_LOWERCASE:\n                    ch = ch - 32  # convert to uppercase\n                pct.append(ch)\n                if len(pct) == 3:  # pragma: no branch   # peephole optimizer\n                    buf = pct[1:]\n                    if not _IS_HEX.match(buf):\n                        ret.extend(b\"%25\")\n                        pct.clear()\n                        idx -= 2\n                        continue\n                    try:\n                        unquoted = chr(int(pct[1:].decode(\"ascii\"), base=16))\n                    except ValueError:\n                        ret.extend(b\"%25\")\n                        pct.clear()\n                        idx -= 2\n                        continue\n\n                    if unquoted in self._protected:\n                        ret.extend(pct)\n                    elif unquoted in safe:\n                        ret.append(ord(unquoted))\n                    else:\n                        ret.extend(pct)\n                    pct.clear()\n\n                # special case, if we have only one char after \"%\"\n                elif len(pct) == 2 and idx == len(bval):\n                    ret.extend(b\"%25\")\n                    pct.clear()\n                    idx -= 1\n\n                continue\n\n            elif ch == ord(\"%\") and self._requote:\n                pct.clear()\n                pct.append(ch)\n\n                # special case if \"%\" is last char\n                if idx == len(bval):\n                    ret.extend(b\"%25\")\n\n                continue\n\n            if self._qs:\n                if ch == ord(\" \"):\n                    ret.append(ord(\"+\"))\n                    continue\n            if ch in bsafe:\n                ret.append(ch)\n                continue\n\n            ret.extend((f\"%{ch:02X}\").encode(\"ascii\"))\n\n        ret2 = ret.decode(\"ascii\")\n        if ret2 == val:\n            return val\n        return ret2\n\n\nclass _Unquoter:\n    def __init__(self, *, unsafe: str = \"\", qs: bool = False) -> None:\n        self._unsafe = unsafe\n        self._qs = qs\n        self._quoter = _Quoter()\n        self._qs_quoter = _Quoter(qs=True)\n\n    def __call__(self, val: Optional[str]) -> Optional[str]:\n        if val is None:\n            return None\n        if not isinstance(val, str):\n            raise TypeError(\"Argument should be str\")\n        if not val:\n            return \"\"\n        decoder = cast(codecs.BufferedIncrementalDecoder, utf8_decoder())\n        ret = []\n        idx = 0\n        while idx < len(val):\n            ch = val[idx]\n            idx += 1\n            if ch == \"%\" and idx <= len(val) - 2:\n                pct = val[idx : idx + 2]\n                if _IS_HEX_STR.fullmatch(pct):\n                    b = bytes([int(pct, base=16)])\n                    idx += 2\n                    try:\n                        unquoted = decoder.decode(b)\n                    except UnicodeDecodeError:\n                        start_pct = idx - 3 - len(decoder.buffer) * 3\n                        ret.append(val[start_pct : idx - 3])\n                        decoder.reset()\n                        try:\n                            unquoted = decoder.decode(b)\n                        except UnicodeDecodeError:\n                            ret.append(val[idx - 3 : idx])\n                            continue\n                    if not unquoted:\n                        continue\n                    if self._qs and unquoted in \"+=&;\":\n                        to_add = self._qs_quoter(unquoted)\n                        if to_add is None:  # pragma: no cover\n                            raise RuntimeError(\"Cannot quote None\")\n                        ret.append(to_add)\n                    elif unquoted in self._unsafe:\n                        to_add = self._quoter(unquoted)\n                        if to_add is None:  # pragma: no cover\n                            raise RuntimeError(\"Cannot quote None\")\n                        ret.append(to_add)\n                    else:\n                        ret.append(unquoted)\n                    continue\n\n            if decoder.buffer:\n                start_pct = idx - 1 - len(decoder.buffer) * 3\n                ret.append(val[start_pct : idx - 1])\n                decoder.reset()\n\n            if ch == \"+\":\n                if not self._qs or ch in self._unsafe:\n                    ret.append(\"+\")\n                else:\n                    ret.append(\" \")\n                continue\n\n            if ch in self._unsafe:\n                ret.append(\"%\")\n                h = hex(ord(ch)).upper()[2:]\n                for ch in h:\n                    ret.append(ch)\n                continue\n\n            ret.append(ch)\n\n        if decoder.buffer:\n            ret.append(val[-len(decoder.buffer) * 3 :])\n\n        ret2 = \"\".join(ret)\n        if ret2 == val:\n            return val\n        return ret2\n", "yarl/__init__.py": "from ._url import URL, cache_clear, cache_configure, cache_info\n\n__version__ = \"1.9.5.dev0\"\n\n__all__ = (\"URL\", \"cache_clear\", \"cache_configure\", \"cache_info\")\n", "packaging/pep517_backend/_backend.py": "# fmt: off\n\"\"\"PEP 517 build backend wrapper for pre-building Cython for wheel.\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport typing as t\nfrom contextlib import contextmanager, nullcontext, suppress\nfrom functools import partial\nfrom pathlib import Path\nfrom shutil import copytree\nfrom sys import implementation as _system_implementation\nfrom sys import stderr as _standard_error_stream\nfrom sys import version_info as _python_version_tuple\nfrom tempfile import TemporaryDirectory\nfrom warnings import warn as _warn_that\n\nfrom setuptools.build_meta import build_sdist as _setuptools_build_sdist\nfrom setuptools.build_meta import build_wheel as _setuptools_build_wheel\nfrom setuptools.build_meta import (\n    get_requires_for_build_wheel as _setuptools_get_requires_for_build_wheel,\n)\nfrom setuptools.build_meta import (\n    prepare_metadata_for_build_wheel as _setuptools_prepare_metadata_for_build_wheel,\n)\n\ntry:\n    from setuptools.build_meta import build_editable as _setuptools_build_editable\nexcept ImportError:\n    _setuptools_build_editable = None  # type: ignore[assignment]\n\n\n# isort: split\nfrom distutils.command.install import install as _distutils_install_cmd\nfrom distutils.core import Distribution as _DistutilsDistribution\nfrom distutils.dist import DistributionMetadata as _DistutilsDistributionMetadata\n\nwith suppress(ImportError):\n    # NOTE: Only available for wheel builds that bundle C-extensions. Declared\n    # NOTE: by `get_requires_for_build_wheel()` and\n    # NOTE: `get_requires_for_build_editable()`, when `pure-python`\n    # NOTE: is not passed.\n    from Cython.Build.Cythonize import main as _cythonize_cli_cmd\n\nfrom ._compat import chdir_cm\nfrom ._cython_configuration import (  # noqa: WPS436\n    get_local_cython_config as _get_local_cython_config,\n)\nfrom ._cython_configuration import (\n    make_cythonize_cli_args_from_config as _make_cythonize_cli_args_from_config,\n)\nfrom ._cython_configuration import patched_env as _patched_cython_env\nfrom ._transformers import sanitize_rst_roles  # noqa: WPS436\n\n__all__ = (  # noqa: WPS410\n    'build_sdist',\n    'build_wheel',\n    'get_requires_for_build_wheel',\n    'prepare_metadata_for_build_wheel',\n    *(\n        () if _setuptools_build_editable is None\n        else (\n            'build_editable',\n            'get_requires_for_build_editable',\n            'prepare_metadata_for_build_editable',\n        )\n    ),\n)\n\n\nCYTHON_TRACING_CONFIG_SETTING = 'with-cython-tracing'\n\"\"\"Config setting name toggle to include line tracing to C-exts.\"\"\"\n\nCYTHON_TRACING_ENV_VAR = 'YARL_CYTHON_TRACING'\n\"\"\"Environment variable name toggle used to opt out of making C-exts.\"\"\"\n\nPURE_PYTHON_CONFIG_SETTING = 'pure-python'\n\"\"\"Config setting name toggle that is used to opt out of making C-exts.\"\"\"\n\nPURE_PYTHON_ENV_VAR = 'YARL_NO_EXTENSIONS'\n\"\"\"Environment variable name toggle used to opt out of making C-exts.\"\"\"\n\nIS_PY3_12_PLUS = _python_version_tuple[:2] >= (3, 12)\n\"\"\"A flag meaning that the current runtime is Python 3.12 or higher.\"\"\"\n\nIS_CPYTHON = _system_implementation.name == \"cpython\"\n\"\"\"A flag meaning that the current interpreter implementation is CPython.\"\"\"\n\nPURE_PYTHON_MODE_CLI_FALLBACK = not IS_CPYTHON\n\"\"\"A fallback for ``pure-python`` is not set.\"\"\"\n\n\ndef _is_truthy_setting_value(setting_value) -> bool:\n    truthy_values = {'', None, 'true', '1', 'on'}\n    return setting_value.lower() in truthy_values\n\n\ndef _get_setting_value(\n        config_settings: dict[str, str] | None = None,\n        config_setting_name: str | None = None,\n        env_var_name: str | None = None,\n        *,\n        default: bool = False,\n) -> bool:\n    user_provided_setting_sources = (\n        (config_settings, config_setting_name, (KeyError, TypeError)),\n        (os.environ, env_var_name, KeyError),\n    )\n    for src_mapping, src_key, lookup_errors in user_provided_setting_sources:\n        if src_key is None:\n            continue\n\n        with suppress(lookup_errors):  # type: ignore[arg-type]\n            return _is_truthy_setting_value(src_mapping[src_key])  # type: ignore[index]\n\n    return default\n\n\ndef _make_pure_python(config_settings: dict[str, str] | None = None) -> bool:\n    return _get_setting_value(\n        config_settings,\n        PURE_PYTHON_CONFIG_SETTING,\n        PURE_PYTHON_ENV_VAR,\n        default=PURE_PYTHON_MODE_CLI_FALLBACK,\n    )\n\n\ndef _include_cython_line_tracing(\n        config_settings: dict[str, str] | None = None,\n        *,\n        default=False,\n) -> bool:\n    return _get_setting_value(\n        config_settings,\n        CYTHON_TRACING_CONFIG_SETTING,\n        CYTHON_TRACING_ENV_VAR,\n        default=default,\n    )\n\n\n@contextmanager\ndef patched_distutils_cmd_install():\n    \"\"\"Make `install_lib` of `install` cmd always use `platlib`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/purelib/` folder\n    orig_finalize = _distutils_install_cmd.finalize_options\n\n    def new_finalize_options(self):  # noqa: WPS430\n        self.install_lib = self.install_platlib\n        orig_finalize(self)\n\n    _distutils_install_cmd.finalize_options = new_finalize_options\n    try:\n        yield\n    finally:\n        _distutils_install_cmd.finalize_options = orig_finalize\n\n\n@contextmanager\ndef patched_dist_has_ext_modules():\n    \"\"\"Make `has_ext_modules` of `Distribution` always return `True`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/platlib/` folder\n    orig_func = _DistutilsDistribution.has_ext_modules\n\n    _DistutilsDistribution.has_ext_modules = lambda *args, **kwargs: True\n    try:\n        yield\n    finally:\n        _DistutilsDistribution.has_ext_modules = orig_func\n\n\n@contextmanager\ndef patched_dist_get_long_description():\n    \"\"\"Make `has_ext_modules` of `Distribution` always return `True`.\n\n    :yields: None\n    \"\"\"\n    # Without this, build_lib puts stuff under `*.data/platlib/` folder\n    _orig_func = _DistutilsDistributionMetadata.get_long_description\n\n    def _get_sanitized_long_description(self):\n        return sanitize_rst_roles(self.long_description)\n\n    _DistutilsDistributionMetadata.get_long_description = (\n        _get_sanitized_long_description\n    )\n    try:\n        yield\n    finally:\n        _DistutilsDistributionMetadata.get_long_description = _orig_func\n\n\ndef _exclude_dir_path(\n    excluded_dir_path: Path,\n    visited_directory: str,\n    _visited_dir_contents: list[str],\n) -> list[str]:\n    \"\"\"Prevent recursive directory traversal.\"\"\"\n    # This stops the temporary directory from being copied\n    # into self recursively forever.\n    # Ref: https://github.com/aio-libs/yarl/issues/992\n    visited_directory_subdirs_to_ignore = [\n        subdir\n        for subdir in _visited_dir_contents\n        if excluded_dir_path == Path(visited_directory) / subdir\n    ]\n    if visited_directory_subdirs_to_ignore:\n        print(\n            f'Preventing `{excluded_dir_path !s}` from being '\n            'copied into itself recursively...',\n            file=_standard_error_stream,\n        )\n    return visited_directory_subdirs_to_ignore\n\n\n@contextmanager\ndef _in_temporary_directory(src_dir: Path) -> t.Iterator[None]:\n    with TemporaryDirectory(prefix='.tmp-yarl-pep517-') as tmp_dir:\n        tmp_dir_path = Path(tmp_dir)\n        root_tmp_dir_path = tmp_dir_path.parent\n        _exclude_tmpdir_parent = partial(_exclude_dir_path, root_tmp_dir_path)\n\n        with chdir_cm(tmp_dir):\n            tmp_src_dir = tmp_dir_path / 'src'\n            copytree(\n                src_dir,\n                tmp_src_dir,\n                ignore=_exclude_tmpdir_parent,\n                symlinks=True,\n            )\n            os.chdir(tmp_src_dir)\n            yield\n\n\n@contextmanager\ndef maybe_prebuild_c_extensions(\n        line_trace_cython_when_unset: bool = False,\n        build_inplace: bool = False,\n        config_settings: dict[str, str] | None = None,\n) -> t.Generator[None, t.Any, t.Any]:\n    \"\"\"Pre-build C-extensions in a temporary directory, when needed.\n\n    This context manager also patches metadata, setuptools and distutils.\n\n    :param build_inplace: Whether to copy and chdir to a temporary location.\n    :param config_settings: :pep:`517` config settings mapping.\n\n    \"\"\"\n    cython_line_tracing_requested = _include_cython_line_tracing(\n        config_settings,\n        default=line_trace_cython_when_unset,\n    )\n    is_pure_python_build = _make_pure_python(config_settings)\n\n    if is_pure_python_build:\n        print(\"*********************\", file=_standard_error_stream)\n        print(\"* Pure Python build *\", file=_standard_error_stream)\n        print(\"*********************\", file=_standard_error_stream)\n\n        if cython_line_tracing_requested:\n            _warn_that(\n                f'The `{CYTHON_TRACING_CONFIG_SETTING !s}` setting requesting '\n                'Cython line tracing is set, but building C-extensions is not. '\n                'This option will not have any effect for in the pure-python '\n                'build mode.',\n                RuntimeWarning,\n                stacklevel=999,\n            )\n\n        yield\n        return\n\n    print(\"**********************\", file=_standard_error_stream)\n    print(\"* Accelerated build *\", file=_standard_error_stream)\n    print(\"**********************\", file=_standard_error_stream)\n    if not IS_CPYTHON:\n        _warn_that(\n            'Building C-extensions under the runtimes other than CPython is '\n            'unsupported and will likely fail. Consider passing the '\n            f'`{PURE_PYTHON_CONFIG_SETTING !s}` PEP 517 config setting.',\n            RuntimeWarning,\n            stacklevel=999,\n        )\n\n    build_dir_ctx = (\n        nullcontext() if build_inplace\n        else _in_temporary_directory(src_dir=Path.cwd().resolve())\n    )\n    with build_dir_ctx:\n        config = _get_local_cython_config()\n\n        cythonize_args = _make_cythonize_cli_args_from_config(config)\n        with _patched_cython_env(config['env'], cython_line_tracing_requested):\n            _cythonize_cli_cmd(cythonize_args)\n        with patched_distutils_cmd_install():\n            with patched_dist_has_ext_modules():\n                yield\n\n\n@patched_dist_get_long_description()\ndef build_wheel(\n        wheel_directory: str,\n        config_settings: dict[str, str] | None = None,\n        metadata_directory: str | None = None,\n) -> str:\n    \"\"\"Produce a built wheel.\n\n    This wraps the corresponding ``setuptools``' build backend hook.\n\n    :param wheel_directory: Directory to put the resulting wheel in.\n    :param config_settings: :pep:`517` config settings mapping.\n    :param metadata_directory: :file:`.dist-info` directory path.\n\n    \"\"\"\n    with maybe_prebuild_c_extensions(\n            line_trace_cython_when_unset=False,\n            build_inplace=False,\n            config_settings=config_settings,\n    ):\n        return _setuptools_build_wheel(\n            wheel_directory=wheel_directory,\n            config_settings=config_settings,\n            metadata_directory=metadata_directory,\n        )\n\n\n@patched_dist_get_long_description()\ndef build_editable(\n        wheel_directory: str,\n        config_settings: dict[str, str] | None = None,\n        metadata_directory: str | None = None,\n) -> str:\n    \"\"\"Produce a built wheel for editable installs.\n\n    This wraps the corresponding ``setuptools``' build backend hook.\n\n    :param wheel_directory: Directory to put the resulting wheel in.\n    :param config_settings: :pep:`517` config settings mapping.\n    :param metadata_directory: :file:`.dist-info` directory path.\n\n    \"\"\"\n    with maybe_prebuild_c_extensions(\n            line_trace_cython_when_unset=True,\n            build_inplace=True,\n            config_settings=config_settings,\n    ):\n        return _setuptools_build_editable(\n            wheel_directory=wheel_directory,\n            config_settings=config_settings,\n            metadata_directory=metadata_directory,\n        )\n\n\ndef get_requires_for_build_wheel(\n        config_settings: dict[str, str] | None = None,\n) -> list[str]:\n    \"\"\"Determine additional requirements for building wheels.\n\n    :param config_settings: :pep:`517` config settings mapping.\n\n    \"\"\"\n    is_pure_python_build = _make_pure_python(config_settings)\n\n    if not is_pure_python_build and not IS_CPYTHON:\n        _warn_that(\n            'Building C-extensions under the runtimes other than CPython is '\n            'unsupported and will likely fail. Consider passing the '\n            f'`{PURE_PYTHON_CONFIG_SETTING !s}` PEP 517 config setting.',\n            RuntimeWarning,\n            stacklevel=999,\n        )\n\n    c_ext_build_deps = [] if is_pure_python_build else [\n        'Cython >= 3.0.0b3' if IS_PY3_12_PLUS  # Only Cython 3+ is compatible\n        else 'Cython',\n    ]\n\n    return _setuptools_get_requires_for_build_wheel(\n        config_settings=config_settings,\n    ) + c_ext_build_deps\n\n\nbuild_sdist = patched_dist_get_long_description()(_setuptools_build_sdist)\nget_requires_for_build_editable = get_requires_for_build_wheel\nprepare_metadata_for_build_wheel = patched_dist_get_long_description()(\n    _setuptools_prepare_metadata_for_build_wheel,\n)\nprepare_metadata_for_build_editable = prepare_metadata_for_build_wheel\n", "packaging/pep517_backend/cli.py": "# fmt: off\n\nfrom __future__ import annotations\n\nimport sys\nfrom itertools import chain\nfrom pathlib import Path\n\nfrom Cython.Compiler.Main import compile as _translate_cython_cli_cmd\nfrom Cython.Compiler.Main import parse_command_line as _split_cython_cli_args\n\nfrom ._cython_configuration import get_local_cython_config as _get_local_cython_config\nfrom ._cython_configuration import (\n    make_cythonize_cli_args_from_config as _make_cythonize_cli_args_from_config,\n)\nfrom ._cython_configuration import patched_env as _patched_cython_env\n\n_PROJECT_PATH = Path(__file__).parents[2]\n\n\ndef run_main_program(argv) -> int | str:\n    \"\"\"Invoke ``translate-cython`` or fail.\"\"\"\n    if len(argv) != 2:\n        return 'This program only accepts one argument -- \"translate-cython\"'\n\n    if argv[1] != 'translate-cython':\n        return 'This program only implements the \"translate-cython\" subcommand'\n\n    config = _get_local_cython_config()\n    config['flags'] = {'keep-going': config['flags']['keep-going']}\n    config['src'] = list(\n        map(\n            str,\n            chain.from_iterable(\n                map(_PROJECT_PATH.glob, config['src']),\n            ),\n        ),\n    )\n    translate_cython_cli_args = _make_cythonize_cli_args_from_config(config)\n\n    cython_options, cython_sources = _split_cython_cli_args(\n        translate_cython_cli_args,\n    )\n\n    with _patched_cython_env(config['env'], cython_line_tracing_requested=True):\n        return _translate_cython_cli_cmd(\n            cython_sources,\n            cython_options,\n        ).num_errors\n\n\nif __name__ == '__main__':\n    sys.exit(run_main_program(argv=sys.argv))\n", "packaging/pep517_backend/_transformers.py": "\"\"\"Data conversion helpers for the in-tree PEP 517 build backend.\"\"\"\n\nfrom itertools import chain\nfrom re import sub as _substitute_with_regexp\n\n\ndef _emit_opt_pairs(opt_pair):\n    flag, flag_value = opt_pair\n    flag_opt = f\"--{flag!s}\"\n    if isinstance(flag_value, dict):\n        sub_pairs = flag_value.items()\n    else:\n        sub_pairs = ((flag_value,),)\n\n    yield from (\"=\".join(map(str, (flag_opt,) + pair)) for pair in sub_pairs)\n\n\ndef get_cli_kwargs_from_config(kwargs_map):\n    \"\"\"Make a list of options with values from config.\"\"\"\n    return list(chain.from_iterable(map(_emit_opt_pairs, kwargs_map.items())))\n\n\ndef get_enabled_cli_flags_from_config(flags_map):\n    \"\"\"Make a list of enabled boolean flags from config.\"\"\"\n    return [f\"--{flag}\" for flag, is_enabled in flags_map.items() if is_enabled]\n\n\ndef sanitize_rst_roles(rst_source_text: str) -> str:\n    \"\"\"Replace RST roles with inline highlighting.\"\"\"\n    pep_role_regex = r\"\"\"(?x)\n        :pep:`(?P<pep_number>\\d+)`\n    \"\"\"\n    pep_substitution_pattern = (\n        r\"`PEP \\g<pep_number> <https://peps.python.org/pep-\\g<pep_number>>`__\"\n    )\n\n    user_role_regex = r\"\"\"(?x)\n        :user:`(?P<github_username>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    user_substitution_pattern = (\n        r\"`@\\g<github_username> \"\n        r\"<https://github.com/sponsors/\\g<github_username>>`__\"\n    )\n\n    issue_role_regex = r\"\"\"(?x)\n        :issue:`(?P<issue_number>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    issue_substitution_pattern = (\n        r\"`#\\g<issue_number> \"\n        r\"<https://github.com/aio-libs/yarl/issues/\\g<issue_number>>`__\"\n    )\n\n    pr_role_regex = r\"\"\"(?x)\n        :pr:`(?P<pr_number>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    pr_substitution_pattern = (\n        r\"`PR #\\g<pr_number> \"\n        r\"<https://github.com/aio-libs/yarl/pull/\\g<pr_number>>`__\"\n    )\n\n    commit_role_regex = r\"\"\"(?x)\n        :commit:`(?P<commit_sha>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    commit_substitution_pattern = (\n        r\"`\\g<commit_sha> \"\n        r\"<https://github.com/aio-libs/yarl/commit/\\g<commit_sha>>`__\"\n    )\n\n    gh_role_regex = r\"\"\"(?x)\n        :gh:`(?P<gh_slug>[^`]+)(?:\\s+(.*))?`\n    \"\"\"\n    gh_substitution_pattern = (\n        r\"`GitHub: \\g<gh_slug> <https://github.com/\\g<gh_slug>>`__\"\n    )\n\n    meth_role_regex = r\"\"\"(?x)\n        (?::py)?:meth:`~?(?P<rendered_text>[^`<]+)(?:\\s+([^`]*))?`\n    \"\"\"\n    meth_substitution_pattern = r\"``\\g<rendered_text>()``\"\n\n    role_regex = r\"\"\"(?x)\n        (?::\\w+)?:\\w+:`(?P<rendered_text>[^`<]+)(?:\\s+([^`]*))?`\n    \"\"\"\n    substitution_pattern = r\"``\\g<rendered_text>``\"\n\n    substitutions = (\n        (pep_role_regex, pep_substitution_pattern),\n        (user_role_regex, user_substitution_pattern),\n        (issue_role_regex, issue_substitution_pattern),\n        (pr_role_regex, pr_substitution_pattern),\n        (commit_role_regex, commit_substitution_pattern),\n        (gh_role_regex, gh_substitution_pattern),\n        (meth_role_regex, meth_substitution_pattern),\n        (role_regex, substitution_pattern),\n    )\n\n    rst_source_normalized_text = rst_source_text\n    for regex, substitution in substitutions:\n        rst_source_normalized_text = _substitute_with_regexp(\n            regex,\n            substitution,\n            rst_source_normalized_text,\n        )\n\n    return rst_source_normalized_text\n", "packaging/pep517_backend/_cython_configuration.py": "# fmt: off\n\nfrom __future__ import annotations\n\nimport os\nfrom contextlib import contextmanager\nfrom pathlib import Path\nfrom sys import version_info as _python_version_tuple\n\nfrom expandvars import expandvars\n\nfrom ._compat import load_toml_from_string  # noqa: WPS436\nfrom ._transformers import (  # noqa: WPS436\n    get_cli_kwargs_from_config,\n    get_enabled_cli_flags_from_config,\n)\n\n\ndef get_local_cython_config() -> dict:\n    \"\"\"Grab optional build dependencies from pyproject.toml config.\n\n    :returns: config section from ``pyproject.toml``\n    :rtype: dict\n\n    This basically reads entries from::\n\n        [tool.local.cythonize]\n        # Env vars provisioned during cythonize call\n        src = [\"src/**/*.pyx\"]\n\n        [tool.local.cythonize.env]\n        # Env vars provisioned during cythonize call\n        LDFLAGS = \"-lssh\"\n\n        [tool.local.cythonize.flags]\n        # This section can contain the following booleans:\n        # * annotate \u2014 generate annotated HTML page for source files\n        # * build \u2014 build extension modules using distutils\n        # * inplace \u2014 build extension modules in place using distutils (implies -b)\n        # * force \u2014 force recompilation\n        # * quiet \u2014 be less verbose during compilation\n        # * lenient \u2014 increase Python compat by ignoring some compile time errors\n        # * keep-going \u2014 compile as much as possible, ignore compilation failures\n        annotate = false\n        build = false\n        inplace = true\n        force = true\n        quiet = false\n        lenient = false\n        keep-going = false\n\n        [tool.local.cythonize.kwargs]\n        # This section can contain args that have values:\n        # * exclude=PATTERN      exclude certain file patterns from the compilation\n        # * parallel=N    run builds in N parallel jobs (default: calculated per system)\n        exclude = \"**.py\"\n        parallel = 12\n\n        [tool.local.cythonize.kwargs.directives]\n        # This section can contain compiler directives\n        # NAME = \"VALUE\"\n\n        [tool.local.cythonize.kwargs.compile-time-env]\n        # This section can contain compile time env vars\n        # NAME = \"VALUE\"\n\n        [tool.local.cythonize.kwargs.options]\n        # This section can contain cythonize options\n        # NAME = \"VALUE\"\n    \"\"\"\n    config_toml_txt = (Path.cwd().resolve() / 'pyproject.toml').read_text()\n    config_mapping = load_toml_from_string(config_toml_txt)\n    return config_mapping['tool']['local']['cythonize']\n\n\ndef make_cythonize_cli_args_from_config(config) -> list[str]:\n    py_ver_arg = f'-{_python_version_tuple.major!s}'\n\n    cli_flags = get_enabled_cli_flags_from_config(config['flags'])\n    cli_kwargs = get_cli_kwargs_from_config(config['kwargs'])\n\n    return cli_flags + [py_ver_arg] + cli_kwargs + ['--'] + config['src']\n\n\n@contextmanager\ndef patched_env(env: dict[str, str], cython_line_tracing_requested: bool):\n    \"\"\"Temporary set given env vars.\n\n    :param env: tmp env vars to set\n    :type env: dict\n\n    :yields: None\n    \"\"\"\n    orig_env = os.environ.copy()\n    expanded_env = {name: expandvars(var_val) for name, var_val in env.items()}\n    os.environ.update(expanded_env)\n\n    if cython_line_tracing_requested:\n        os.environ['CFLAGS'] = ' '.join((\n            os.getenv('CFLAGS', ''),\n            '-DCYTHON_TRACE_NOGIL=1',  # Implies CYTHON_TRACE=1\n        )).strip()\n    try:\n        yield\n    finally:\n        os.environ.clear()\n        os.environ.update(orig_env)\n", "packaging/pep517_backend/__main__.py": "import sys\n\nfrom . import cli\n\nif __name__ == \"__main__\":\n    sys.exit(cli.run_main_program(argv=sys.argv))\n", "packaging/pep517_backend/_compat.py": "\"\"\"Cross-python stdlib shims.\"\"\"\n\nimport os\nimport typing as t\nfrom contextlib import contextmanager\nfrom pathlib import Path\n\ntry:\n    from contextlib import chdir as chdir_cm  # type: ignore[attr-defined]\nexcept ImportError:\n\n    @contextmanager  # type: ignore[no-redef]\n    def chdir_cm(path: os.PathLike) -> t.Iterator[None]:\n        \"\"\"Temporarily change the current directory, recovering on exit.\"\"\"\n        original_wd = Path.cwd()\n        os.chdir(path)\n        try:\n            yield\n        finally:\n            os.chdir(original_wd)\n\n\ntry:\n    from tomllib import loads as load_toml_from_string\nexcept ImportError:\n    from tomli import loads as load_toml_from_string  # type: ignore[no-redef]\n\n\n__all__ = (\"chdir_cm\", \"load_toml_from_string\")  # noqa: WPS410\n", "packaging/pep517_backend/__init__.py": "\"\"\"PEP 517 build backend for optionally pre-building Cython.\"\"\"\n", "packaging/pep517_backend/hooks.py": "\"\"\"PEP 517 build backend for optionally pre-building Cython.\"\"\"\n\nfrom contextlib import suppress as _suppress\n\nfrom setuptools.build_meta import *  # Re-exporting PEP 517 hooks  # pylint: disable=unused-wildcard-import,wildcard-import  # noqa: E501, F401, F403\n\n# Re-exporting PEP 517 hooks\nfrom ._backend import (  # type: ignore[assignment]  # noqa: WPS436\n    build_sdist,\n    build_wheel,\n    get_requires_for_build_wheel,\n    prepare_metadata_for_build_wheel,\n)\n\nwith _suppress(ImportError):  # Only succeeds w/ setuptools implementing PEP 660\n    # Re-exporting PEP 660 hooks\n    from ._backend import (  # type: ignore[assignment]  # noqa: WPS436\n        build_editable,\n        get_requires_for_build_editable,\n        prepare_metadata_for_build_editable,\n    )\n"}