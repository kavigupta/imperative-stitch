{"scripts/generate_identifier_pattern.py": "import itertools\nimport os\nimport re\nimport sys\n\n\ndef get_characters():\n    \"\"\"Find every Unicode character that is valid in a Python `identifier`_ but\n    is not matched by the regex ``\\\\w`` group.\n\n    ``\\\\w`` matches some characters that aren't valid in identifiers, but\n    :meth:`str.isidentifier` will catch that later in lexing.\n\n    All start characters are valid continue characters, so we only test for\n    continue characters.\n\n    _identifier: https://docs.python.org/3/reference/lexical_analysis.html#identifiers\n    \"\"\"\n    for cp in range(sys.maxunicode + 1):\n        s = chr(cp)\n\n        if (\"a\" + s).isidentifier() and not re.match(r\"\\w\", s):\n            yield s\n\n\ndef collapse_ranges(data):\n    \"\"\"Given a sorted list of unique characters, generate ranges representing\n    sequential code points.\n\n    Source: https://stackoverflow.com/a/4629241/400617\n    \"\"\"\n    for _, g in itertools.groupby(enumerate(data), lambda x: ord(x[1]) - x[0]):\n        lb = list(g)\n        yield lb[0][1], lb[-1][1]\n\n\ndef build_pattern(ranges):\n    \"\"\"Output the regex pattern for ranges of characters.\n\n    One and two character ranges output the individual characters.\n    \"\"\"\n    out = []\n\n    for a, b in ranges:\n        if a == b:  # single char\n            out.append(a)\n        elif ord(b) - ord(a) == 1:  # two chars, range is redundant\n            out.append(a)\n            out.append(b)\n        else:\n            out.append(f\"{a}-{b}\")\n\n    return \"\".join(out)\n\n\ndef main():\n    \"\"\"Build the regex pattern and write it to\n    ``jinja2/_identifier.py``.\n    \"\"\"\n    pattern = build_pattern(collapse_ranges(get_characters()))\n    filename = os.path.abspath(\n        os.path.join(os.path.dirname(__file__), \"..\", \"src\", \"jinja2\", \"_identifier.py\")\n    )\n\n    with open(filename, \"w\", encoding=\"utf8\") as f:\n        f.write(\"import re\\n\\n\")\n        f.write(\"# generated by scripts/generate_identifier_pattern.py\\n\")\n        f.write(\"pattern = re.compile(\\n\")\n        f.write(f'    r\"[\\\\w{pattern}]+\"  # noqa: B950\\n')\n        f.write(\")\\n\")\n\n\nif __name__ == \"__main__\":\n    main()\n", "src/jinja2/async_utils.py": "import inspect\nimport typing as t\nfrom functools import WRAPPER_ASSIGNMENTS\nfrom functools import wraps\n\nfrom .utils import _PassArg\nfrom .utils import pass_eval_context\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\nV = t.TypeVar(\"V\")\n\n\ndef async_variant(normal_func):  # type: ignore\n    def decorator(async_func):  # type: ignore\n        pass_arg = _PassArg.from_obj(normal_func)\n        need_eval_context = pass_arg is None\n\n        if pass_arg is _PassArg.environment:\n\n            def is_async(args: t.Any) -> bool:\n                return t.cast(bool, args[0].is_async)\n\n        else:\n\n            def is_async(args: t.Any) -> bool:\n                return t.cast(bool, args[0].environment.is_async)\n\n        # Take the doc and annotations from the sync function, but the\n        # name from the async function. Pallets-Sphinx-Themes\n        # build_function_directive expects __wrapped__ to point to the\n        # sync function.\n        async_func_attrs = (\"__module__\", \"__name__\", \"__qualname__\")\n        normal_func_attrs = tuple(set(WRAPPER_ASSIGNMENTS).difference(async_func_attrs))\n\n        @wraps(normal_func, assigned=normal_func_attrs)\n        @wraps(async_func, assigned=async_func_attrs, updated=())\n        def wrapper(*args, **kwargs):  # type: ignore\n            b = is_async(args)\n\n            if need_eval_context:\n                args = args[1:]\n\n            if b:\n                return async_func(*args, **kwargs)\n\n            return normal_func(*args, **kwargs)\n\n        if need_eval_context:\n            wrapper = pass_eval_context(wrapper)\n\n        wrapper.jinja_async_variant = True  # type: ignore[attr-defined]\n        return wrapper\n\n    return decorator\n\n\n_common_primitives = {int, float, bool, str, list, dict, tuple, type(None)}\n\n\nasync def auto_await(value: t.Union[t.Awaitable[\"V\"], \"V\"]) -> \"V\":\n    # Avoid a costly call to isawaitable\n    if type(value) in _common_primitives:\n        return t.cast(\"V\", value)\n\n    if inspect.isawaitable(value):\n        return await t.cast(\"t.Awaitable[V]\", value)\n\n    return t.cast(\"V\", value)\n\n\nclass _IteratorToAsyncIterator(t.Generic[V]):\n    def __init__(self, iterator: \"t.Iterator[V]\"):\n        self._iterator = iterator\n\n    def __aiter__(self) -> \"te.Self\":\n        return self\n\n    async def __anext__(self) -> V:\n        try:\n            return next(self._iterator)\n        except StopIteration as e:\n            raise StopAsyncIteration(e.value) from e\n\n\ndef auto_aiter(\n    iterable: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n) -> \"t.AsyncIterator[V]\":\n    if hasattr(iterable, \"__aiter__\"):\n        return iterable.__aiter__()\n    else:\n        return _IteratorToAsyncIterator(iter(iterable))\n\n\nasync def auto_to_list(\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n) -> t.List[\"V\"]:\n    return [x async for x in auto_aiter(value)]\n", "src/jinja2/idtracking.py": "import typing as t\n\nfrom . import nodes\nfrom .visitor import NodeVisitor\n\nVAR_LOAD_PARAMETER = \"param\"\nVAR_LOAD_RESOLVE = \"resolve\"\nVAR_LOAD_ALIAS = \"alias\"\nVAR_LOAD_UNDEFINED = \"undefined\"\n\n\ndef find_symbols(\n    nodes: t.Iterable[nodes.Node], parent_symbols: t.Optional[\"Symbols\"] = None\n) -> \"Symbols\":\n    sym = Symbols(parent=parent_symbols)\n    visitor = FrameSymbolVisitor(sym)\n    for node in nodes:\n        visitor.visit(node)\n    return sym\n\n\ndef symbols_for_node(\n    node: nodes.Node, parent_symbols: t.Optional[\"Symbols\"] = None\n) -> \"Symbols\":\n    sym = Symbols(parent=parent_symbols)\n    sym.analyze_node(node)\n    return sym\n\n\nclass Symbols:\n    def __init__(\n        self, parent: t.Optional[\"Symbols\"] = None, level: t.Optional[int] = None\n    ) -> None:\n        if level is None:\n            if parent is None:\n                level = 0\n            else:\n                level = parent.level + 1\n\n        self.level: int = level\n        self.parent = parent\n        self.refs: t.Dict[str, str] = {}\n        self.loads: t.Dict[str, t.Any] = {}\n        self.stores: t.Set[str] = set()\n\n    def analyze_node(self, node: nodes.Node, **kwargs: t.Any) -> None:\n        visitor = RootVisitor(self)\n        visitor.visit(node, **kwargs)\n\n    def _define_ref(\n        self, name: str, load: t.Optional[t.Tuple[str, t.Optional[str]]] = None\n    ) -> str:\n        ident = f\"l_{self.level}_{name}\"\n        self.refs[name] = ident\n        if load is not None:\n            self.loads[ident] = load\n        return ident\n\n    def find_load(self, target: str) -> t.Optional[t.Any]:\n        if target in self.loads:\n            return self.loads[target]\n\n        if self.parent is not None:\n            return self.parent.find_load(target)\n\n        return None\n\n    def find_ref(self, name: str) -> t.Optional[str]:\n        if name in self.refs:\n            return self.refs[name]\n\n        if self.parent is not None:\n            return self.parent.find_ref(name)\n\n        return None\n\n    def ref(self, name: str) -> str:\n        rv = self.find_ref(name)\n        if rv is None:\n            raise AssertionError(\n                \"Tried to resolve a name to a reference that was\"\n                f\" unknown to the frame ({name!r})\"\n            )\n        return rv\n\n    def copy(self) -> \"Symbols\":\n        rv = object.__new__(self.__class__)\n        rv.__dict__.update(self.__dict__)\n        rv.refs = self.refs.copy()\n        rv.loads = self.loads.copy()\n        rv.stores = self.stores.copy()\n        return rv\n\n    def store(self, name: str) -> None:\n        self.stores.add(name)\n\n        # If we have not see the name referenced yet, we need to figure\n        # out what to set it to.\n        if name not in self.refs:\n            # If there is a parent scope we check if the name has a\n            # reference there.  If it does it means we might have to alias\n            # to a variable there.\n            if self.parent is not None:\n                outer_ref = self.parent.find_ref(name)\n                if outer_ref is not None:\n                    self._define_ref(name, load=(VAR_LOAD_ALIAS, outer_ref))\n                    return\n\n            # Otherwise we can just set it to undefined.\n            self._define_ref(name, load=(VAR_LOAD_UNDEFINED, None))\n\n    def declare_parameter(self, name: str) -> str:\n        self.stores.add(name)\n        return self._define_ref(name, load=(VAR_LOAD_PARAMETER, None))\n\n    def load(self, name: str) -> None:\n        if self.find_ref(name) is None:\n            self._define_ref(name, load=(VAR_LOAD_RESOLVE, name))\n\n    def branch_update(self, branch_symbols: t.Sequence[\"Symbols\"]) -> None:\n        stores: t.Dict[str, int] = {}\n        for branch in branch_symbols:\n            for target in branch.stores:\n                if target in self.stores:\n                    continue\n                stores[target] = stores.get(target, 0) + 1\n\n        for sym in branch_symbols:\n            self.refs.update(sym.refs)\n            self.loads.update(sym.loads)\n            self.stores.update(sym.stores)\n\n        for name, branch_count in stores.items():\n            if branch_count == len(branch_symbols):\n                continue\n\n            target = self.find_ref(name)  # type: ignore\n            assert target is not None, \"should not happen\"\n\n            if self.parent is not None:\n                outer_target = self.parent.find_ref(name)\n                if outer_target is not None:\n                    self.loads[target] = (VAR_LOAD_ALIAS, outer_target)\n                    continue\n            self.loads[target] = (VAR_LOAD_RESOLVE, name)\n\n    def dump_stores(self) -> t.Dict[str, str]:\n        rv: t.Dict[str, str] = {}\n        node: t.Optional[Symbols] = self\n\n        while node is not None:\n            for name in sorted(node.stores):\n                if name not in rv:\n                    rv[name] = self.find_ref(name)  # type: ignore\n\n            node = node.parent\n\n        return rv\n\n    def dump_param_targets(self) -> t.Set[str]:\n        rv = set()\n        node: t.Optional[Symbols] = self\n\n        while node is not None:\n            for target, (instr, _) in self.loads.items():\n                if instr == VAR_LOAD_PARAMETER:\n                    rv.add(target)\n\n            node = node.parent\n\n        return rv\n\n\nclass RootVisitor(NodeVisitor):\n    def __init__(self, symbols: \"Symbols\") -> None:\n        self.sym_visitor = FrameSymbolVisitor(symbols)\n\n    def _simple_visit(self, node: nodes.Node, **kwargs: t.Any) -> None:\n        for child in node.iter_child_nodes():\n            self.sym_visitor.visit(child)\n\n    visit_Template = _simple_visit\n    visit_Block = _simple_visit\n    visit_Macro = _simple_visit\n    visit_FilterBlock = _simple_visit\n    visit_Scope = _simple_visit\n    visit_If = _simple_visit\n    visit_ScopedEvalContextModifier = _simple_visit\n\n    def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any) -> None:\n        for child in node.body:\n            self.sym_visitor.visit(child)\n\n    def visit_CallBlock(self, node: nodes.CallBlock, **kwargs: t.Any) -> None:\n        for child in node.iter_child_nodes(exclude=(\"call\",)):\n            self.sym_visitor.visit(child)\n\n    def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any) -> None:\n        for child in node.body:\n            self.sym_visitor.visit(child)\n\n    def visit_For(\n        self, node: nodes.For, for_branch: str = \"body\", **kwargs: t.Any\n    ) -> None:\n        if for_branch == \"body\":\n            self.sym_visitor.visit(node.target, store_as_param=True)\n            branch = node.body\n        elif for_branch == \"else\":\n            branch = node.else_\n        elif for_branch == \"test\":\n            self.sym_visitor.visit(node.target, store_as_param=True)\n            if node.test is not None:\n                self.sym_visitor.visit(node.test)\n            return\n        else:\n            raise RuntimeError(\"Unknown for branch\")\n\n        if branch:\n            for item in branch:\n                self.sym_visitor.visit(item)\n\n    def visit_With(self, node: nodes.With, **kwargs: t.Any) -> None:\n        for target in node.targets:\n            self.sym_visitor.visit(target)\n        for child in node.body:\n            self.sym_visitor.visit(child)\n\n    def generic_visit(self, node: nodes.Node, *args: t.Any, **kwargs: t.Any) -> None:\n        raise NotImplementedError(f\"Cannot find symbols for {type(node).__name__!r}\")\n\n\nclass FrameSymbolVisitor(NodeVisitor):\n    \"\"\"A visitor for `Frame.inspect`.\"\"\"\n\n    def __init__(self, symbols: \"Symbols\") -> None:\n        self.symbols = symbols\n\n    def visit_Name(\n        self, node: nodes.Name, store_as_param: bool = False, **kwargs: t.Any\n    ) -> None:\n        \"\"\"All assignments to names go through this function.\"\"\"\n        if store_as_param or node.ctx == \"param\":\n            self.symbols.declare_parameter(node.name)\n        elif node.ctx == \"store\":\n            self.symbols.store(node.name)\n        elif node.ctx == \"load\":\n            self.symbols.load(node.name)\n\n    def visit_NSRef(self, node: nodes.NSRef, **kwargs: t.Any) -> None:\n        self.symbols.load(node.name)\n\n    def visit_If(self, node: nodes.If, **kwargs: t.Any) -> None:\n        self.visit(node.test, **kwargs)\n        original_symbols = self.symbols\n\n        def inner_visit(nodes: t.Iterable[nodes.Node]) -> \"Symbols\":\n            self.symbols = rv = original_symbols.copy()\n\n            for subnode in nodes:\n                self.visit(subnode, **kwargs)\n\n            self.symbols = original_symbols\n            return rv\n\n        body_symbols = inner_visit(node.body)\n        elif_symbols = inner_visit(node.elif_)\n        else_symbols = inner_visit(node.else_ or ())\n        self.symbols.branch_update([body_symbols, elif_symbols, else_symbols])\n\n    def visit_Macro(self, node: nodes.Macro, **kwargs: t.Any) -> None:\n        self.symbols.store(node.name)\n\n    def visit_Import(self, node: nodes.Import, **kwargs: t.Any) -> None:\n        self.generic_visit(node, **kwargs)\n        self.symbols.store(node.target)\n\n    def visit_FromImport(self, node: nodes.FromImport, **kwargs: t.Any) -> None:\n        self.generic_visit(node, **kwargs)\n\n        for name in node.names:\n            if isinstance(name, tuple):\n                self.symbols.store(name[1])\n            else:\n                self.symbols.store(name)\n\n    def visit_Assign(self, node: nodes.Assign, **kwargs: t.Any) -> None:\n        \"\"\"Visit assignments in the correct order.\"\"\"\n        self.visit(node.node, **kwargs)\n        self.visit(node.target, **kwargs)\n\n    def visit_For(self, node: nodes.For, **kwargs: t.Any) -> None:\n        \"\"\"Visiting stops at for blocks.  However the block sequence\n        is visited as part of the outer scope.\n        \"\"\"\n        self.visit(node.iter, **kwargs)\n\n    def visit_CallBlock(self, node: nodes.CallBlock, **kwargs: t.Any) -> None:\n        self.visit(node.call, **kwargs)\n\n    def visit_FilterBlock(self, node: nodes.FilterBlock, **kwargs: t.Any) -> None:\n        self.visit(node.filter, **kwargs)\n\n    def visit_With(self, node: nodes.With, **kwargs: t.Any) -> None:\n        for target in node.values:\n            self.visit(target)\n\n    def visit_AssignBlock(self, node: nodes.AssignBlock, **kwargs: t.Any) -> None:\n        \"\"\"Stop visiting at block assigns.\"\"\"\n        self.visit(node.target, **kwargs)\n\n    def visit_Scope(self, node: nodes.Scope, **kwargs: t.Any) -> None:\n        \"\"\"Stop visiting at scopes.\"\"\"\n\n    def visit_Block(self, node: nodes.Block, **kwargs: t.Any) -> None:\n        \"\"\"Stop visiting at blocks.\"\"\"\n\n    def visit_OverlayScope(self, node: nodes.OverlayScope, **kwargs: t.Any) -> None:\n        \"\"\"Do not visit into overlay scopes.\"\"\"\n", "src/jinja2/environment.py": "\"\"\"Classes for managing templates and their runtime and compile time\noptions.\n\"\"\"\n\nimport os\nimport typing\nimport typing as t\nimport weakref\nfrom collections import ChainMap\nfrom functools import lru_cache\nfrom functools import partial\nfrom functools import reduce\nfrom types import CodeType\n\nfrom markupsafe import Markup\n\nfrom . import nodes\nfrom .compiler import CodeGenerator\nfrom .compiler import generate\nfrom .defaults import BLOCK_END_STRING\nfrom .defaults import BLOCK_START_STRING\nfrom .defaults import COMMENT_END_STRING\nfrom .defaults import COMMENT_START_STRING\nfrom .defaults import DEFAULT_FILTERS  # type: ignore[attr-defined]\nfrom .defaults import DEFAULT_NAMESPACE\nfrom .defaults import DEFAULT_POLICIES\nfrom .defaults import DEFAULT_TESTS  # type: ignore[attr-defined]\nfrom .defaults import KEEP_TRAILING_NEWLINE\nfrom .defaults import LINE_COMMENT_PREFIX\nfrom .defaults import LINE_STATEMENT_PREFIX\nfrom .defaults import LSTRIP_BLOCKS\nfrom .defaults import NEWLINE_SEQUENCE\nfrom .defaults import TRIM_BLOCKS\nfrom .defaults import VARIABLE_END_STRING\nfrom .defaults import VARIABLE_START_STRING\nfrom .exceptions import TemplateNotFound\nfrom .exceptions import TemplateRuntimeError\nfrom .exceptions import TemplatesNotFound\nfrom .exceptions import TemplateSyntaxError\nfrom .exceptions import UndefinedError\nfrom .lexer import get_lexer\nfrom .lexer import Lexer\nfrom .lexer import TokenStream\nfrom .nodes import EvalContext\nfrom .parser import Parser\nfrom .runtime import Context\nfrom .runtime import new_context\nfrom .runtime import Undefined\nfrom .utils import _PassArg\nfrom .utils import concat\nfrom .utils import consume\nfrom .utils import import_string\nfrom .utils import internalcode\nfrom .utils import LRUCache\nfrom .utils import missing\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .bccache import BytecodeCache\n    from .ext import Extension\n    from .loaders import BaseLoader\n\n_env_bound = t.TypeVar(\"_env_bound\", bound=\"Environment\")\n\n\n# for direct template usage we have up to ten living environments\n@lru_cache(maxsize=10)\ndef get_spontaneous_environment(cls: t.Type[_env_bound], *args: t.Any) -> _env_bound:\n    \"\"\"Return a new spontaneous environment. A spontaneous environment\n    is used for templates created directly rather than through an\n    existing environment.\n\n    :param cls: Environment class to create.\n    :param args: Positional arguments passed to environment.\n    \"\"\"\n    env = cls(*args)\n    env.shared = True\n    return env\n\n\ndef create_cache(\n    size: int,\n) -> t.Optional[t.MutableMapping[t.Tuple[\"weakref.ref[BaseLoader]\", str], \"Template\"]]:\n    \"\"\"Return the cache class for the given size.\"\"\"\n    if size == 0:\n        return None\n\n    if size < 0:\n        return {}\n\n    return LRUCache(size)  # type: ignore\n\n\ndef copy_cache(\n    cache: t.Optional[\n        t.MutableMapping[t.Tuple[\"weakref.ref[BaseLoader]\", str], \"Template\"]\n    ],\n) -> t.Optional[t.MutableMapping[t.Tuple[\"weakref.ref[BaseLoader]\", str], \"Template\"]]:\n    \"\"\"Create an empty copy of the given cache.\"\"\"\n    if cache is None:\n        return None\n\n    if type(cache) is dict:  # noqa E721\n        return {}\n\n    return LRUCache(cache.capacity)  # type: ignore\n\n\ndef load_extensions(\n    environment: \"Environment\",\n    extensions: t.Sequence[t.Union[str, t.Type[\"Extension\"]]],\n) -> t.Dict[str, \"Extension\"]:\n    \"\"\"Load the extensions from the list and bind it to the environment.\n    Returns a dict of instantiated extensions.\n    \"\"\"\n    result = {}\n\n    for extension in extensions:\n        if isinstance(extension, str):\n            extension = t.cast(t.Type[\"Extension\"], import_string(extension))\n\n        result[extension.identifier] = extension(environment)\n\n    return result\n\n\ndef _environment_config_check(environment: \"Environment\") -> \"Environment\":\n    \"\"\"Perform a sanity check on the environment.\"\"\"\n    assert issubclass(\n        environment.undefined, Undefined\n    ), \"'undefined' must be a subclass of 'jinja2.Undefined'.\"\n    assert (\n        environment.block_start_string\n        != environment.variable_start_string\n        != environment.comment_start_string\n    ), \"block, variable and comment start strings must be different.\"\n    assert environment.newline_sequence in {\n        \"\\r\",\n        \"\\r\\n\",\n        \"\\n\",\n    }, \"'newline_sequence' must be one of '\\\\n', '\\\\r\\\\n', or '\\\\r'.\"\n    return environment\n\n\nclass Environment:\n    r\"\"\"The core component of Jinja is the `Environment`.  It contains\n    important shared variables like configuration, filters, tests,\n    globals and others.  Instances of this class may be modified if\n    they are not shared and if no template was loaded so far.\n    Modifications on environments after the first template was loaded\n    will lead to surprising effects and undefined behavior.\n\n    Here are the possible initialization parameters:\n\n        `block_start_string`\n            The string marking the beginning of a block.  Defaults to ``'{%'``.\n\n        `block_end_string`\n            The string marking the end of a block.  Defaults to ``'%}'``.\n\n        `variable_start_string`\n            The string marking the beginning of a print statement.\n            Defaults to ``'{{'``.\n\n        `variable_end_string`\n            The string marking the end of a print statement.  Defaults to\n            ``'}}'``.\n\n        `comment_start_string`\n            The string marking the beginning of a comment.  Defaults to ``'{#'``.\n\n        `comment_end_string`\n            The string marking the end of a comment.  Defaults to ``'#}'``.\n\n        `line_statement_prefix`\n            If given and a string, this will be used as prefix for line based\n            statements.  See also :ref:`line-statements`.\n\n        `line_comment_prefix`\n            If given and a string, this will be used as prefix for line based\n            comments.  See also :ref:`line-statements`.\n\n            .. versionadded:: 2.2\n\n        `trim_blocks`\n            If this is set to ``True`` the first newline after a block is\n            removed (block, not variable tag!).  Defaults to `False`.\n\n        `lstrip_blocks`\n            If this is set to ``True`` leading spaces and tabs are stripped\n            from the start of a line to a block.  Defaults to `False`.\n\n        `newline_sequence`\n            The sequence that starts a newline.  Must be one of ``'\\r'``,\n            ``'\\n'`` or ``'\\r\\n'``.  The default is ``'\\n'`` which is a\n            useful default for Linux and OS X systems as well as web\n            applications.\n\n        `keep_trailing_newline`\n            Preserve the trailing newline when rendering templates.\n            The default is ``False``, which causes a single newline,\n            if present, to be stripped from the end of the template.\n\n            .. versionadded:: 2.7\n\n        `extensions`\n            List of Jinja extensions to use.  This can either be import paths\n            as strings or extension classes.  For more information have a\n            look at :ref:`the extensions documentation <jinja-extensions>`.\n\n        `optimized`\n            should the optimizer be enabled?  Default is ``True``.\n\n        `undefined`\n            :class:`Undefined` or a subclass of it that is used to represent\n            undefined values in the template.\n\n        `finalize`\n            A callable that can be used to process the result of a variable\n            expression before it is output.  For example one can convert\n            ``None`` implicitly into an empty string here.\n\n        `autoescape`\n            If set to ``True`` the XML/HTML autoescaping feature is enabled by\n            default.  For more details about autoescaping see\n            :class:`~markupsafe.Markup`.  As of Jinja 2.4 this can also\n            be a callable that is passed the template name and has to\n            return ``True`` or ``False`` depending on autoescape should be\n            enabled by default.\n\n            .. versionchanged:: 2.4\n               `autoescape` can now be a function\n\n        `loader`\n            The template loader for this environment.\n\n        `cache_size`\n            The size of the cache.  Per default this is ``400`` which means\n            that if more than 400 templates are loaded the loader will clean\n            out the least recently used template.  If the cache size is set to\n            ``0`` templates are recompiled all the time, if the cache size is\n            ``-1`` the cache will not be cleaned.\n\n            .. versionchanged:: 2.8\n               The cache size was increased to 400 from a low 50.\n\n        `auto_reload`\n            Some loaders load templates from locations where the template\n            sources may change (ie: file system or database).  If\n            ``auto_reload`` is set to ``True`` (default) every time a template is\n            requested the loader checks if the source changed and if yes, it\n            will reload the template.  For higher performance it's possible to\n            disable that.\n\n        `bytecode_cache`\n            If set to a bytecode cache object, this object will provide a\n            cache for the internal Jinja bytecode so that templates don't\n            have to be parsed if they were not changed.\n\n            See :ref:`bytecode-cache` for more information.\n\n        `enable_async`\n            If set to true this enables async template execution which\n            allows using async functions and generators.\n    \"\"\"\n\n    #: if this environment is sandboxed.  Modifying this variable won't make\n    #: the environment sandboxed though.  For a real sandboxed environment\n    #: have a look at jinja2.sandbox.  This flag alone controls the code\n    #: generation by the compiler.\n    sandboxed = False\n\n    #: True if the environment is just an overlay\n    overlayed = False\n\n    #: the environment this environment is linked to if it is an overlay\n    linked_to: t.Optional[\"Environment\"] = None\n\n    #: shared environments have this set to `True`.  A shared environment\n    #: must not be modified\n    shared = False\n\n    #: the class that is used for code generation.  See\n    #: :class:`~jinja2.compiler.CodeGenerator` for more information.\n    code_generator_class: t.Type[\"CodeGenerator\"] = CodeGenerator\n\n    concat = \"\".join\n\n    #: the context class that is used for templates.  See\n    #: :class:`~jinja2.runtime.Context` for more information.\n    context_class: t.Type[Context] = Context\n\n    template_class: t.Type[\"Template\"]\n\n    def __init__(\n        self,\n        block_start_string: str = BLOCK_START_STRING,\n        block_end_string: str = BLOCK_END_STRING,\n        variable_start_string: str = VARIABLE_START_STRING,\n        variable_end_string: str = VARIABLE_END_STRING,\n        comment_start_string: str = COMMENT_START_STRING,\n        comment_end_string: str = COMMENT_END_STRING,\n        line_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX,\n        line_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX,\n        trim_blocks: bool = TRIM_BLOCKS,\n        lstrip_blocks: bool = LSTRIP_BLOCKS,\n        newline_sequence: \"te.Literal['\\\\n', '\\\\r\\\\n', '\\\\r']\" = NEWLINE_SEQUENCE,\n        keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE,\n        extensions: t.Sequence[t.Union[str, t.Type[\"Extension\"]]] = (),\n        optimized: bool = True,\n        undefined: t.Type[Undefined] = Undefined,\n        finalize: t.Optional[t.Callable[..., t.Any]] = None,\n        autoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = False,\n        loader: t.Optional[\"BaseLoader\"] = None,\n        cache_size: int = 400,\n        auto_reload: bool = True,\n        bytecode_cache: t.Optional[\"BytecodeCache\"] = None,\n        enable_async: bool = False,\n    ):\n        # !!Important notice!!\n        #   The constructor accepts quite a few arguments that should be\n        #   passed by keyword rather than position.  However it's important to\n        #   not change the order of arguments because it's used at least\n        #   internally in those cases:\n        #       -   spontaneous environments (i18n extension and Template)\n        #       -   unittests\n        #   If parameter changes are required only add parameters at the end\n        #   and don't change the arguments (or the defaults!) of the arguments\n        #   existing already.\n\n        # lexer / parser information\n        self.block_start_string = block_start_string\n        self.block_end_string = block_end_string\n        self.variable_start_string = variable_start_string\n        self.variable_end_string = variable_end_string\n        self.comment_start_string = comment_start_string\n        self.comment_end_string = comment_end_string\n        self.line_statement_prefix = line_statement_prefix\n        self.line_comment_prefix = line_comment_prefix\n        self.trim_blocks = trim_blocks\n        self.lstrip_blocks = lstrip_blocks\n        self.newline_sequence = newline_sequence\n        self.keep_trailing_newline = keep_trailing_newline\n\n        # runtime information\n        self.undefined: t.Type[Undefined] = undefined\n        self.optimized = optimized\n        self.finalize = finalize\n        self.autoescape = autoescape\n\n        # defaults\n        self.filters = DEFAULT_FILTERS.copy()\n        self.tests = DEFAULT_TESTS.copy()\n        self.globals = DEFAULT_NAMESPACE.copy()\n\n        # set the loader provided\n        self.loader = loader\n        self.cache = create_cache(cache_size)\n        self.bytecode_cache = bytecode_cache\n        self.auto_reload = auto_reload\n\n        # configurable policies\n        self.policies = DEFAULT_POLICIES.copy()\n\n        # load extensions\n        self.extensions = load_extensions(self, extensions)\n\n        self.is_async = enable_async\n        _environment_config_check(self)\n\n    def add_extension(self, extension: t.Union[str, t.Type[\"Extension\"]]) -> None:\n        \"\"\"Adds an extension after the environment was created.\n\n        .. versionadded:: 2.5\n        \"\"\"\n        self.extensions.update(load_extensions(self, [extension]))\n\n    def extend(self, **attributes: t.Any) -> None:\n        \"\"\"Add the items to the instance of the environment if they do not exist\n        yet.  This is used by :ref:`extensions <writing-extensions>` to register\n        callbacks and configuration values without breaking inheritance.\n        \"\"\"\n        for key, value in attributes.items():\n            if not hasattr(self, key):\n                setattr(self, key, value)\n\n    def overlay(\n        self,\n        block_start_string: str = missing,\n        block_end_string: str = missing,\n        variable_start_string: str = missing,\n        variable_end_string: str = missing,\n        comment_start_string: str = missing,\n        comment_end_string: str = missing,\n        line_statement_prefix: t.Optional[str] = missing,\n        line_comment_prefix: t.Optional[str] = missing,\n        trim_blocks: bool = missing,\n        lstrip_blocks: bool = missing,\n        newline_sequence: \"te.Literal['\\\\n', '\\\\r\\\\n', '\\\\r']\" = missing,\n        keep_trailing_newline: bool = missing,\n        extensions: t.Sequence[t.Union[str, t.Type[\"Extension\"]]] = missing,\n        optimized: bool = missing,\n        undefined: t.Type[Undefined] = missing,\n        finalize: t.Optional[t.Callable[..., t.Any]] = missing,\n        autoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = missing,\n        loader: t.Optional[\"BaseLoader\"] = missing,\n        cache_size: int = missing,\n        auto_reload: bool = missing,\n        bytecode_cache: t.Optional[\"BytecodeCache\"] = missing,\n        enable_async: bool = False,\n    ) -> \"Environment\":\n        \"\"\"Create a new overlay environment that shares all the data with the\n        current environment except for cache and the overridden attributes.\n        Extensions cannot be removed for an overlayed environment.  An overlayed\n        environment automatically gets all the extensions of the environment it\n        is linked to plus optional extra extensions.\n\n        Creating overlays should happen after the initial environment was set\n        up completely.  Not all attributes are truly linked, some are just\n        copied over so modifications on the original environment may not shine\n        through.\n\n        .. versionchanged:: 3.1.2\n            Added the ``newline_sequence``,, ``keep_trailing_newline``,\n            and ``enable_async`` parameters to match ``__init__``.\n        \"\"\"\n        args = dict(locals())\n        del args[\"self\"], args[\"cache_size\"], args[\"extensions\"], args[\"enable_async\"]\n\n        rv = object.__new__(self.__class__)\n        rv.__dict__.update(self.__dict__)\n        rv.overlayed = True\n        rv.linked_to = self\n\n        for key, value in args.items():\n            if value is not missing:\n                setattr(rv, key, value)\n\n        if cache_size is not missing:\n            rv.cache = create_cache(cache_size)\n        else:\n            rv.cache = copy_cache(self.cache)\n\n        rv.extensions = {}\n        for key, value in self.extensions.items():\n            rv.extensions[key] = value.bind(rv)\n        if extensions is not missing:\n            rv.extensions.update(load_extensions(rv, extensions))\n\n        if enable_async is not missing:\n            rv.is_async = enable_async\n\n        return _environment_config_check(rv)\n\n    @property\n    def lexer(self) -> Lexer:\n        \"\"\"The lexer for this environment.\"\"\"\n        return get_lexer(self)\n\n    def iter_extensions(self) -> t.Iterator[\"Extension\"]:\n        \"\"\"Iterates over the extensions by priority.\"\"\"\n        return iter(sorted(self.extensions.values(), key=lambda x: x.priority))\n\n    def getitem(\n        self, obj: t.Any, argument: t.Union[str, t.Any]\n    ) -> t.Union[t.Any, Undefined]:\n        \"\"\"Get an item or attribute of an object but prefer the item.\"\"\"\n        try:\n            return obj[argument]\n        except (AttributeError, TypeError, LookupError):\n            if isinstance(argument, str):\n                try:\n                    attr = str(argument)\n                except Exception:\n                    pass\n                else:\n                    try:\n                        return getattr(obj, attr)\n                    except AttributeError:\n                        pass\n            return self.undefined(obj=obj, name=argument)\n\n    def getattr(self, obj: t.Any, attribute: str) -> t.Any:\n        \"\"\"Get an item or attribute of an object but prefer the attribute.\n        Unlike :meth:`getitem` the attribute *must* be a string.\n        \"\"\"\n        try:\n            return getattr(obj, attribute)\n        except AttributeError:\n            pass\n        try:\n            return obj[attribute]\n        except (TypeError, LookupError, AttributeError):\n            return self.undefined(obj=obj, name=attribute)\n\n    def _filter_test_common(\n        self,\n        name: t.Union[str, Undefined],\n        value: t.Any,\n        args: t.Optional[t.Sequence[t.Any]],\n        kwargs: t.Optional[t.Mapping[str, t.Any]],\n        context: t.Optional[Context],\n        eval_ctx: t.Optional[EvalContext],\n        is_filter: bool,\n    ) -> t.Any:\n        if is_filter:\n            env_map = self.filters\n            type_name = \"filter\"\n        else:\n            env_map = self.tests\n            type_name = \"test\"\n\n        func = env_map.get(name)  # type: ignore\n\n        if func is None:\n            msg = f\"No {type_name} named {name!r}.\"\n\n            if isinstance(name, Undefined):\n                try:\n                    name._fail_with_undefined_error()\n                except Exception as e:\n                    msg = f\"{msg} ({e}; did you forget to quote the callable name?)\"\n\n            raise TemplateRuntimeError(msg)\n\n        args = [value, *(args if args is not None else ())]\n        kwargs = kwargs if kwargs is not None else {}\n        pass_arg = _PassArg.from_obj(func)\n\n        if pass_arg is _PassArg.context:\n            if context is None:\n                raise TemplateRuntimeError(\n                    f\"Attempted to invoke a context {type_name} without context.\"\n                )\n\n            args.insert(0, context)\n        elif pass_arg is _PassArg.eval_context:\n            if eval_ctx is None:\n                if context is not None:\n                    eval_ctx = context.eval_ctx\n                else:\n                    eval_ctx = EvalContext(self)\n\n            args.insert(0, eval_ctx)\n        elif pass_arg is _PassArg.environment:\n            args.insert(0, self)\n\n        return func(*args, **kwargs)\n\n    def call_filter(\n        self,\n        name: str,\n        value: t.Any,\n        args: t.Optional[t.Sequence[t.Any]] = None,\n        kwargs: t.Optional[t.Mapping[str, t.Any]] = None,\n        context: t.Optional[Context] = None,\n        eval_ctx: t.Optional[EvalContext] = None,\n    ) -> t.Any:\n        \"\"\"Invoke a filter on a value the same way the compiler does.\n\n        This might return a coroutine if the filter is running from an\n        environment in async mode and the filter supports async\n        execution. It's your responsibility to await this if needed.\n\n        .. versionadded:: 2.7\n        \"\"\"\n        return self._filter_test_common(\n            name, value, args, kwargs, context, eval_ctx, True\n        )\n\n    def call_test(\n        self,\n        name: str,\n        value: t.Any,\n        args: t.Optional[t.Sequence[t.Any]] = None,\n        kwargs: t.Optional[t.Mapping[str, t.Any]] = None,\n        context: t.Optional[Context] = None,\n        eval_ctx: t.Optional[EvalContext] = None,\n    ) -> t.Any:\n        \"\"\"Invoke a test on a value the same way the compiler does.\n\n        This might return a coroutine if the test is running from an\n        environment in async mode and the test supports async execution.\n        It's your responsibility to await this if needed.\n\n        .. versionchanged:: 3.0\n            Tests support ``@pass_context``, etc. decorators. Added\n            the ``context`` and ``eval_ctx`` parameters.\n\n        .. versionadded:: 2.7\n        \"\"\"\n        return self._filter_test_common(\n            name, value, args, kwargs, context, eval_ctx, False\n        )\n\n    @internalcode\n    def parse(\n        self,\n        source: str,\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n    ) -> nodes.Template:\n        \"\"\"Parse the sourcecode and return the abstract syntax tree.  This\n        tree of nodes is used by the compiler to convert the template into\n        executable source- or bytecode.  This is useful for debugging or to\n        extract information from templates.\n\n        If you are :ref:`developing Jinja extensions <writing-extensions>`\n        this gives you a good overview of the node tree generated.\n        \"\"\"\n        try:\n            return self._parse(source, name, filename)\n        except TemplateSyntaxError:\n            self.handle_exception(source=source)\n\n    def _parse(\n        self, source: str, name: t.Optional[str], filename: t.Optional[str]\n    ) -> nodes.Template:\n        \"\"\"Internal parsing function used by `parse` and `compile`.\"\"\"\n        return Parser(self, source, name, filename).parse()\n\n    def lex(\n        self,\n        source: str,\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n    ) -> t.Iterator[t.Tuple[int, str, str]]:\n        \"\"\"Lex the given sourcecode and return a generator that yields\n        tokens as tuples in the form ``(lineno, token_type, value)``.\n        This can be useful for :ref:`extension development <writing-extensions>`\n        and debugging templates.\n\n        This does not perform preprocessing.  If you want the preprocessing\n        of the extensions to be applied you have to filter source through\n        the :meth:`preprocess` method.\n        \"\"\"\n        source = str(source)\n        try:\n            return self.lexer.tokeniter(source, name, filename)\n        except TemplateSyntaxError:\n            self.handle_exception(source=source)\n\n    def preprocess(\n        self,\n        source: str,\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n    ) -> str:\n        \"\"\"Preprocesses the source with all extensions.  This is automatically\n        called for all parsing and compiling methods but *not* for :meth:`lex`\n        because there you usually only want the actual source tokenized.\n        \"\"\"\n        return reduce(\n            lambda s, e: e.preprocess(s, name, filename),\n            self.iter_extensions(),\n            str(source),\n        )\n\n    def _tokenize(\n        self,\n        source: str,\n        name: t.Optional[str],\n        filename: t.Optional[str] = None,\n        state: t.Optional[str] = None,\n    ) -> TokenStream:\n        \"\"\"Called by the parser to do the preprocessing and filtering\n        for all the extensions.  Returns a :class:`~jinja2.lexer.TokenStream`.\n        \"\"\"\n        source = self.preprocess(source, name, filename)\n        stream = self.lexer.tokenize(source, name, filename, state)\n\n        for ext in self.iter_extensions():\n            stream = ext.filter_stream(stream)  # type: ignore\n\n            if not isinstance(stream, TokenStream):\n                stream = TokenStream(stream, name, filename)  # type: ignore[unreachable]\n\n        return stream\n\n    def _generate(\n        self,\n        source: nodes.Template,\n        name: t.Optional[str],\n        filename: t.Optional[str],\n        defer_init: bool = False,\n    ) -> str:\n        \"\"\"Internal hook that can be overridden to hook a different generate\n        method in.\n\n        .. versionadded:: 2.5\n        \"\"\"\n        return generate(  # type: ignore\n            source,\n            self,\n            name,\n            filename,\n            defer_init=defer_init,\n            optimized=self.optimized,\n        )\n\n    def _compile(self, source: str, filename: str) -> CodeType:\n        \"\"\"Internal hook that can be overridden to hook a different compile\n        method in.\n\n        .. versionadded:: 2.5\n        \"\"\"\n        return compile(source, filename, \"exec\")\n\n    @typing.overload\n    def compile(  # type: ignore\n        self,\n        source: t.Union[str, nodes.Template],\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n        raw: \"te.Literal[False]\" = False,\n        defer_init: bool = False,\n    ) -> CodeType: ...\n\n    @typing.overload\n    def compile(\n        self,\n        source: t.Union[str, nodes.Template],\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n        raw: \"te.Literal[True]\" = ...,\n        defer_init: bool = False,\n    ) -> str: ...\n\n    @internalcode\n    def compile(\n        self,\n        source: t.Union[str, nodes.Template],\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n        raw: bool = False,\n        defer_init: bool = False,\n    ) -> t.Union[str, CodeType]:\n        \"\"\"Compile a node or template source code.  The `name` parameter is\n        the load name of the template after it was joined using\n        :meth:`join_path` if necessary, not the filename on the file system.\n        the `filename` parameter is the estimated filename of the template on\n        the file system.  If the template came from a database or memory this\n        can be omitted.\n\n        The return value of this method is a python code object.  If the `raw`\n        parameter is `True` the return value will be a string with python\n        code equivalent to the bytecode returned otherwise.  This method is\n        mainly used internally.\n\n        `defer_init` is use internally to aid the module code generator.  This\n        causes the generated code to be able to import without the global\n        environment variable to be set.\n\n        .. versionadded:: 2.4\n           `defer_init` parameter added.\n        \"\"\"\n        source_hint = None\n        try:\n            if isinstance(source, str):\n                source_hint = source\n                source = self._parse(source, name, filename)\n            source = self._generate(source, name, filename, defer_init=defer_init)\n            if raw:\n                return source\n            if filename is None:\n                filename = \"<template>\"\n            return self._compile(source, filename)\n        except TemplateSyntaxError:\n            self.handle_exception(source=source_hint)\n\n    def compile_expression(\n        self, source: str, undefined_to_none: bool = True\n    ) -> \"TemplateExpression\":\n        \"\"\"A handy helper method that returns a callable that accepts keyword\n        arguments that appear as variables in the expression.  If called it\n        returns the result of the expression.\n\n        This is useful if applications want to use the same rules as Jinja\n        in template \"configuration files\" or similar situations.\n\n        Example usage:\n\n        >>> env = Environment()\n        >>> expr = env.compile_expression('foo == 42')\n        >>> expr(foo=23)\n        False\n        >>> expr(foo=42)\n        True\n\n        Per default the return value is converted to `None` if the\n        expression returns an undefined value.  This can be changed\n        by setting `undefined_to_none` to `False`.\n\n        >>> env.compile_expression('var')() is None\n        True\n        >>> env.compile_expression('var', undefined_to_none=False)()\n        Undefined\n\n        .. versionadded:: 2.1\n        \"\"\"\n        parser = Parser(self, source, state=\"variable\")\n        try:\n            expr = parser.parse_expression()\n            if not parser.stream.eos:\n                raise TemplateSyntaxError(\n                    \"chunk after expression\", parser.stream.current.lineno, None, None\n                )\n            expr.set_environment(self)\n        except TemplateSyntaxError:\n            self.handle_exception(source=source)\n\n        body = [nodes.Assign(nodes.Name(\"result\", \"store\"), expr, lineno=1)]\n        template = self.from_string(nodes.Template(body, lineno=1))\n        return TemplateExpression(template, undefined_to_none)\n\n    def compile_templates(\n        self,\n        target: t.Union[str, \"os.PathLike[str]\"],\n        extensions: t.Optional[t.Collection[str]] = None,\n        filter_func: t.Optional[t.Callable[[str], bool]] = None,\n        zip: t.Optional[str] = \"deflated\",\n        log_function: t.Optional[t.Callable[[str], None]] = None,\n        ignore_errors: bool = True,\n    ) -> None:\n        \"\"\"Finds all the templates the loader can find, compiles them\n        and stores them in `target`.  If `zip` is `None`, instead of in a\n        zipfile, the templates will be stored in a directory.\n        By default a deflate zip algorithm is used. To switch to\n        the stored algorithm, `zip` can be set to ``'stored'``.\n\n        `extensions` and `filter_func` are passed to :meth:`list_templates`.\n        Each template returned will be compiled to the target folder or\n        zipfile.\n\n        By default template compilation errors are ignored.  In case a\n        log function is provided, errors are logged.  If you want template\n        syntax errors to abort the compilation you can set `ignore_errors`\n        to `False` and you will get an exception on syntax errors.\n\n        .. versionadded:: 2.4\n        \"\"\"\n        from .loaders import ModuleLoader\n\n        if log_function is None:\n\n            def log_function(x: str) -> None:\n                pass\n\n        assert log_function is not None\n        assert self.loader is not None, \"No loader configured.\"\n\n        def write_file(filename: str, data: str) -> None:\n            if zip:\n                info = ZipInfo(filename)\n                info.external_attr = 0o755 << 16\n                zip_file.writestr(info, data)\n            else:\n                with open(os.path.join(target, filename), \"wb\") as f:\n                    f.write(data.encode(\"utf8\"))\n\n        if zip is not None:\n            from zipfile import ZIP_DEFLATED\n            from zipfile import ZIP_STORED\n            from zipfile import ZipFile\n            from zipfile import ZipInfo\n\n            zip_file = ZipFile(\n                target, \"w\", dict(deflated=ZIP_DEFLATED, stored=ZIP_STORED)[zip]\n            )\n            log_function(f\"Compiling into Zip archive {target!r}\")\n        else:\n            if not os.path.isdir(target):\n                os.makedirs(target)\n            log_function(f\"Compiling into folder {target!r}\")\n\n        try:\n            for name in self.list_templates(extensions, filter_func):\n                source, filename, _ = self.loader.get_source(self, name)\n                try:\n                    code = self.compile(source, name, filename, True, True)\n                except TemplateSyntaxError as e:\n                    if not ignore_errors:\n                        raise\n                    log_function(f'Could not compile \"{name}\": {e}')\n                    continue\n\n                filename = ModuleLoader.get_module_filename(name)\n\n                write_file(filename, code)\n                log_function(f'Compiled \"{name}\" as {filename}')\n        finally:\n            if zip:\n                zip_file.close()\n\n        log_function(\"Finished compiling templates\")\n\n    def list_templates(\n        self,\n        extensions: t.Optional[t.Collection[str]] = None,\n        filter_func: t.Optional[t.Callable[[str], bool]] = None,\n    ) -> t.List[str]:\n        \"\"\"Returns a list of templates for this environment.  This requires\n        that the loader supports the loader's\n        :meth:`~BaseLoader.list_templates` method.\n\n        If there are other files in the template folder besides the\n        actual templates, the returned list can be filtered.  There are two\n        ways: either `extensions` is set to a list of file extensions for\n        templates, or a `filter_func` can be provided which is a callable that\n        is passed a template name and should return `True` if it should end up\n        in the result list.\n\n        If the loader does not support that, a :exc:`TypeError` is raised.\n\n        .. versionadded:: 2.4\n        \"\"\"\n        assert self.loader is not None, \"No loader configured.\"\n        names = self.loader.list_templates()\n\n        if extensions is not None:\n            if filter_func is not None:\n                raise TypeError(\n                    \"either extensions or filter_func can be passed, but not both\"\n                )\n\n            def filter_func(x: str) -> bool:\n                return \".\" in x and x.rsplit(\".\", 1)[1] in extensions\n\n        if filter_func is not None:\n            names = [name for name in names if filter_func(name)]\n\n        return names\n\n    def handle_exception(self, source: t.Optional[str] = None) -> \"te.NoReturn\":\n        \"\"\"Exception handling helper.  This is used internally to either raise\n        rewritten exceptions or return a rendered traceback for the template.\n        \"\"\"\n        from .debug import rewrite_traceback_stack\n\n        raise rewrite_traceback_stack(source=source)\n\n    def join_path(self, template: str, parent: str) -> str:\n        \"\"\"Join a template with the parent.  By default all the lookups are\n        relative to the loader root so this method returns the `template`\n        parameter unchanged, but if the paths should be relative to the\n        parent template, this function can be used to calculate the real\n        template name.\n\n        Subclasses may override this method and implement template path\n        joining here.\n        \"\"\"\n        return template\n\n    @internalcode\n    def _load_template(\n        self, name: str, globals: t.Optional[t.MutableMapping[str, t.Any]]\n    ) -> \"Template\":\n        if self.loader is None:\n            raise TypeError(\"no loader for this environment specified\")\n        cache_key = (weakref.ref(self.loader), name)\n        if self.cache is not None:\n            template = self.cache.get(cache_key)\n            if template is not None and (\n                not self.auto_reload or template.is_up_to_date\n            ):\n                # template.globals is a ChainMap, modifying it will only\n                # affect the template, not the environment globals.\n                if globals:\n                    template.globals.update(globals)\n\n                return template\n\n        template = self.loader.load(self, name, self.make_globals(globals))\n\n        if self.cache is not None:\n            self.cache[cache_key] = template\n        return template\n\n    @internalcode\n    def get_template(\n        self,\n        name: t.Union[str, \"Template\"],\n        parent: t.Optional[str] = None,\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ) -> \"Template\":\n        \"\"\"Load a template by name with :attr:`loader` and return a\n        :class:`Template`. If the template does not exist a\n        :exc:`TemplateNotFound` exception is raised.\n\n        :param name: Name of the template to load. When loading\n            templates from the filesystem, \"/\" is used as the path\n            separator, even on Windows.\n        :param parent: The name of the parent template importing this\n            template. :meth:`join_path` can be used to implement name\n            transformations with this.\n        :param globals: Extend the environment :attr:`globals` with\n            these extra variables available for all renders of this\n            template. If the template has already been loaded and\n            cached, its globals are updated with any new items.\n\n        .. versionchanged:: 3.0\n            If a template is loaded from cache, ``globals`` will update\n            the template's globals instead of ignoring the new values.\n\n        .. versionchanged:: 2.4\n            If ``name`` is a :class:`Template` object it is returned\n            unchanged.\n        \"\"\"\n        if isinstance(name, Template):\n            return name\n        if parent is not None:\n            name = self.join_path(name, parent)\n\n        return self._load_template(name, globals)\n\n    @internalcode\n    def select_template(\n        self,\n        names: t.Iterable[t.Union[str, \"Template\"]],\n        parent: t.Optional[str] = None,\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ) -> \"Template\":\n        \"\"\"Like :meth:`get_template`, but tries loading multiple names.\n        If none of the names can be loaded a :exc:`TemplatesNotFound`\n        exception is raised.\n\n        :param names: List of template names to try loading in order.\n        :param parent: The name of the parent template importing this\n            template. :meth:`join_path` can be used to implement name\n            transformations with this.\n        :param globals: Extend the environment :attr:`globals` with\n            these extra variables available for all renders of this\n            template. If the template has already been loaded and\n            cached, its globals are updated with any new items.\n\n        .. versionchanged:: 3.0\n            If a template is loaded from cache, ``globals`` will update\n            the template's globals instead of ignoring the new values.\n\n        .. versionchanged:: 2.11\n            If ``names`` is :class:`Undefined`, an :exc:`UndefinedError`\n            is raised instead. If no templates were found and ``names``\n            contains :class:`Undefined`, the message is more helpful.\n\n        .. versionchanged:: 2.4\n            If ``names`` contains a :class:`Template` object it is\n            returned unchanged.\n\n        .. versionadded:: 2.3\n        \"\"\"\n        if isinstance(names, Undefined):\n            names._fail_with_undefined_error()\n\n        if not names:\n            raise TemplatesNotFound(\n                message=\"Tried to select from an empty list of templates.\"\n            )\n\n        for name in names:\n            if isinstance(name, Template):\n                return name\n            if parent is not None:\n                name = self.join_path(name, parent)\n            try:\n                return self._load_template(name, globals)\n            except (TemplateNotFound, UndefinedError):\n                pass\n        raise TemplatesNotFound(names)  # type: ignore\n\n    @internalcode\n    def get_or_select_template(\n        self,\n        template_name_or_list: t.Union[\n            str, \"Template\", t.List[t.Union[str, \"Template\"]]\n        ],\n        parent: t.Optional[str] = None,\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ) -> \"Template\":\n        \"\"\"Use :meth:`select_template` if an iterable of template names\n        is given, or :meth:`get_template` if one name is given.\n\n        .. versionadded:: 2.3\n        \"\"\"\n        if isinstance(template_name_or_list, (str, Undefined)):\n            return self.get_template(template_name_or_list, parent, globals)\n        elif isinstance(template_name_or_list, Template):\n            return template_name_or_list\n        return self.select_template(template_name_or_list, parent, globals)\n\n    def from_string(\n        self,\n        source: t.Union[str, nodes.Template],\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n        template_class: t.Optional[t.Type[\"Template\"]] = None,\n    ) -> \"Template\":\n        \"\"\"Load a template from a source string without using\n        :attr:`loader`.\n\n        :param source: Jinja source to compile into a template.\n        :param globals: Extend the environment :attr:`globals` with\n            these extra variables available for all renders of this\n            template. If the template has already been loaded and\n            cached, its globals are updated with any new items.\n        :param template_class: Return an instance of this\n            :class:`Template` class.\n        \"\"\"\n        gs = self.make_globals(globals)\n        cls = template_class or self.template_class\n        return cls.from_code(self, self.compile(source), gs, None)\n\n    def make_globals(\n        self, d: t.Optional[t.MutableMapping[str, t.Any]]\n    ) -> t.MutableMapping[str, t.Any]:\n        \"\"\"Make the globals map for a template. Any given template\n        globals overlay the environment :attr:`globals`.\n\n        Returns a :class:`collections.ChainMap`. This allows any changes\n        to a template's globals to only affect that template, while\n        changes to the environment's globals are still reflected.\n        However, avoid modifying any globals after a template is loaded.\n\n        :param d: Dict of template-specific globals.\n\n        .. versionchanged:: 3.0\n            Use :class:`collections.ChainMap` to always prevent mutating\n            environment globals.\n        \"\"\"\n        if d is None:\n            d = {}\n\n        return ChainMap(d, self.globals)\n\n\nclass Template:\n    \"\"\"A compiled template that can be rendered.\n\n    Use the methods on :class:`Environment` to create or load templates.\n    The environment is used to configure how templates are compiled and\n    behave.\n\n    It is also possible to create a template object directly. This is\n    not usually recommended. The constructor takes most of the same\n    arguments as :class:`Environment`. All templates created with the\n    same environment arguments share the same ephemeral ``Environment``\n    instance behind the scenes.\n\n    A template object should be considered immutable. Modifications on\n    the object are not supported.\n    \"\"\"\n\n    #: Type of environment to create when creating a template directly\n    #: rather than through an existing environment.\n    environment_class: t.Type[Environment] = Environment\n\n    environment: Environment\n    globals: t.MutableMapping[str, t.Any]\n    name: t.Optional[str]\n    filename: t.Optional[str]\n    blocks: t.Dict[str, t.Callable[[Context], t.Iterator[str]]]\n    root_render_func: t.Callable[[Context], t.Iterator[str]]\n    _module: t.Optional[\"TemplateModule\"]\n    _debug_info: str\n    _uptodate: t.Optional[t.Callable[[], bool]]\n\n    def __new__(\n        cls,\n        source: t.Union[str, nodes.Template],\n        block_start_string: str = BLOCK_START_STRING,\n        block_end_string: str = BLOCK_END_STRING,\n        variable_start_string: str = VARIABLE_START_STRING,\n        variable_end_string: str = VARIABLE_END_STRING,\n        comment_start_string: str = COMMENT_START_STRING,\n        comment_end_string: str = COMMENT_END_STRING,\n        line_statement_prefix: t.Optional[str] = LINE_STATEMENT_PREFIX,\n        line_comment_prefix: t.Optional[str] = LINE_COMMENT_PREFIX,\n        trim_blocks: bool = TRIM_BLOCKS,\n        lstrip_blocks: bool = LSTRIP_BLOCKS,\n        newline_sequence: \"te.Literal['\\\\n', '\\\\r\\\\n', '\\\\r']\" = NEWLINE_SEQUENCE,\n        keep_trailing_newline: bool = KEEP_TRAILING_NEWLINE,\n        extensions: t.Sequence[t.Union[str, t.Type[\"Extension\"]]] = (),\n        optimized: bool = True,\n        undefined: t.Type[Undefined] = Undefined,\n        finalize: t.Optional[t.Callable[..., t.Any]] = None,\n        autoescape: t.Union[bool, t.Callable[[t.Optional[str]], bool]] = False,\n        enable_async: bool = False,\n    ) -> t.Any:  # it returns a `Template`, but this breaks the sphinx build...\n        env = get_spontaneous_environment(\n            cls.environment_class,  # type: ignore\n            block_start_string,\n            block_end_string,\n            variable_start_string,\n            variable_end_string,\n            comment_start_string,\n            comment_end_string,\n            line_statement_prefix,\n            line_comment_prefix,\n            trim_blocks,\n            lstrip_blocks,\n            newline_sequence,\n            keep_trailing_newline,\n            frozenset(extensions),\n            optimized,\n            undefined,  # type: ignore\n            finalize,\n            autoescape,\n            None,\n            0,\n            False,\n            None,\n            enable_async,\n        )\n        return env.from_string(source, template_class=cls)\n\n    @classmethod\n    def from_code(\n        cls,\n        environment: Environment,\n        code: CodeType,\n        globals: t.MutableMapping[str, t.Any],\n        uptodate: t.Optional[t.Callable[[], bool]] = None,\n    ) -> \"Template\":\n        \"\"\"Creates a template object from compiled code and the globals.  This\n        is used by the loaders and environment to create a template object.\n        \"\"\"\n        namespace = {\"environment\": environment, \"__file__\": code.co_filename}\n        exec(code, namespace)\n        rv = cls._from_namespace(environment, namespace, globals)\n        rv._uptodate = uptodate\n        return rv\n\n    @classmethod\n    def from_module_dict(\n        cls,\n        environment: Environment,\n        module_dict: t.MutableMapping[str, t.Any],\n        globals: t.MutableMapping[str, t.Any],\n    ) -> \"Template\":\n        \"\"\"Creates a template object from a module.  This is used by the\n        module loader to create a template object.\n\n        .. versionadded:: 2.4\n        \"\"\"\n        return cls._from_namespace(environment, module_dict, globals)\n\n    @classmethod\n    def _from_namespace(\n        cls,\n        environment: Environment,\n        namespace: t.MutableMapping[str, t.Any],\n        globals: t.MutableMapping[str, t.Any],\n    ) -> \"Template\":\n        t: Template = object.__new__(cls)\n        t.environment = environment\n        t.globals = globals\n        t.name = namespace[\"name\"]\n        t.filename = namespace[\"__file__\"]\n        t.blocks = namespace[\"blocks\"]\n\n        # render function and module\n        t.root_render_func = namespace[\"root\"]\n        t._module = None\n\n        # debug and loader helpers\n        t._debug_info = namespace[\"debug_info\"]\n        t._uptodate = None\n\n        # store the reference\n        namespace[\"environment\"] = environment\n        namespace[\"__jinja_template__\"] = t\n\n        return t\n\n    def render(self, *args: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"This method accepts the same arguments as the `dict` constructor:\n        A dict, a dict subclass or some keyword arguments.  If no arguments\n        are given the context will be empty.  These two calls do the same::\n\n            template.render(knights='that say nih')\n            template.render({'knights': 'that say nih'})\n\n        This will return the rendered template as a string.\n        \"\"\"\n        if self.environment.is_async:\n            import asyncio\n\n            return asyncio.run(self.render_async(*args, **kwargs))\n\n        ctx = self.new_context(dict(*args, **kwargs))\n\n        try:\n            return self.environment.concat(self.root_render_func(ctx))  # type: ignore\n        except Exception:\n            self.environment.handle_exception()\n\n    async def render_async(self, *args: t.Any, **kwargs: t.Any) -> str:\n        \"\"\"This works similar to :meth:`render` but returns a coroutine\n        that when awaited returns the entire rendered template string.  This\n        requires the async feature to be enabled.\n\n        Example usage::\n\n            await template.render_async(knights='that say nih; asynchronously')\n        \"\"\"\n        if not self.environment.is_async:\n            raise RuntimeError(\n                \"The environment was not created with async mode enabled.\"\n            )\n\n        ctx = self.new_context(dict(*args, **kwargs))\n\n        try:\n            return self.environment.concat(  # type: ignore\n                [n async for n in self.root_render_func(ctx)]  # type: ignore\n            )\n        except Exception:\n            return self.environment.handle_exception()\n\n    def stream(self, *args: t.Any, **kwargs: t.Any) -> \"TemplateStream\":\n        \"\"\"Works exactly like :meth:`generate` but returns a\n        :class:`TemplateStream`.\n        \"\"\"\n        return TemplateStream(self.generate(*args, **kwargs))\n\n    def generate(self, *args: t.Any, **kwargs: t.Any) -> t.Iterator[str]:\n        \"\"\"For very large templates it can be useful to not render the whole\n        template at once but evaluate each statement after another and yield\n        piece for piece.  This method basically does exactly that and returns\n        a generator that yields one item after another as strings.\n\n        It accepts the same arguments as :meth:`render`.\n        \"\"\"\n        if self.environment.is_async:\n            import asyncio\n\n            async def to_list() -> t.List[str]:\n                return [x async for x in self.generate_async(*args, **kwargs)]\n\n            yield from asyncio.run(to_list())\n            return\n\n        ctx = self.new_context(dict(*args, **kwargs))\n\n        try:\n            yield from self.root_render_func(ctx)\n        except Exception:\n            yield self.environment.handle_exception()\n\n    async def generate_async(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> t.AsyncGenerator[str, object]:\n        \"\"\"An async version of :meth:`generate`.  Works very similarly but\n        returns an async iterator instead.\n        \"\"\"\n        if not self.environment.is_async:\n            raise RuntimeError(\n                \"The environment was not created with async mode enabled.\"\n            )\n\n        ctx = self.new_context(dict(*args, **kwargs))\n\n        try:\n            agen = self.root_render_func(ctx)\n            try:\n                async for event in agen:  # type: ignore\n                    yield event\n            finally:\n                # we can't use async with aclosing(...) because that's only\n                # in 3.10+\n                await agen.aclose()  # type: ignore\n        except Exception:\n            yield self.environment.handle_exception()\n\n    def new_context(\n        self,\n        vars: t.Optional[t.Dict[str, t.Any]] = None,\n        shared: bool = False,\n        locals: t.Optional[t.Mapping[str, t.Any]] = None,\n    ) -> Context:\n        \"\"\"Create a new :class:`Context` for this template.  The vars\n        provided will be passed to the template.  Per default the globals\n        are added to the context.  If shared is set to `True` the data\n        is passed as is to the context without adding the globals.\n\n        `locals` can be a dict of local variables for internal usage.\n        \"\"\"\n        return new_context(\n            self.environment, self.name, self.blocks, vars, shared, self.globals, locals\n        )\n\n    def make_module(\n        self,\n        vars: t.Optional[t.Dict[str, t.Any]] = None,\n        shared: bool = False,\n        locals: t.Optional[t.Mapping[str, t.Any]] = None,\n    ) -> \"TemplateModule\":\n        \"\"\"This method works like the :attr:`module` attribute when called\n        without arguments but it will evaluate the template on every call\n        rather than caching it.  It's also possible to provide\n        a dict which is then used as context.  The arguments are the same\n        as for the :meth:`new_context` method.\n        \"\"\"\n        ctx = self.new_context(vars, shared, locals)\n        return TemplateModule(self, ctx)\n\n    async def make_module_async(\n        self,\n        vars: t.Optional[t.Dict[str, t.Any]] = None,\n        shared: bool = False,\n        locals: t.Optional[t.Mapping[str, t.Any]] = None,\n    ) -> \"TemplateModule\":\n        \"\"\"As template module creation can invoke template code for\n        asynchronous executions this method must be used instead of the\n        normal :meth:`make_module` one.  Likewise the module attribute\n        becomes unavailable in async mode.\n        \"\"\"\n        ctx = self.new_context(vars, shared, locals)\n        return TemplateModule(\n            self,\n            ctx,\n            [x async for x in self.root_render_func(ctx)],  # type: ignore\n        )\n\n    @internalcode\n    def _get_default_module(self, ctx: t.Optional[Context] = None) -> \"TemplateModule\":\n        \"\"\"If a context is passed in, this means that the template was\n        imported. Imported templates have access to the current\n        template's globals by default, but they can only be accessed via\n        the context during runtime.\n\n        If there are new globals, we need to create a new module because\n        the cached module is already rendered and will not have access\n        to globals from the current context. This new module is not\n        cached because the template can be imported elsewhere, and it\n        should have access to only the current template's globals.\n        \"\"\"\n        if self.environment.is_async:\n            raise RuntimeError(\"Module is not available in async mode.\")\n\n        if ctx is not None:\n            keys = ctx.globals_keys - self.globals.keys()\n\n            if keys:\n                return self.make_module({k: ctx.parent[k] for k in keys})\n\n        if self._module is None:\n            self._module = self.make_module()\n\n        return self._module\n\n    async def _get_default_module_async(\n        self, ctx: t.Optional[Context] = None\n    ) -> \"TemplateModule\":\n        if ctx is not None:\n            keys = ctx.globals_keys - self.globals.keys()\n\n            if keys:\n                return await self.make_module_async({k: ctx.parent[k] for k in keys})\n\n        if self._module is None:\n            self._module = await self.make_module_async()\n\n        return self._module\n\n    @property\n    def module(self) -> \"TemplateModule\":\n        \"\"\"The template as module.  This is used for imports in the\n        template runtime but is also useful if one wants to access\n        exported template variables from the Python layer:\n\n        >>> t = Template('{% macro foo() %}42{% endmacro %}23')\n        >>> str(t.module)\n        '23'\n        >>> t.module.foo() == u'42'\n        True\n\n        This attribute is not available if async mode is enabled.\n        \"\"\"\n        return self._get_default_module()\n\n    def get_corresponding_lineno(self, lineno: int) -> int:\n        \"\"\"Return the source line number of a line number in the\n        generated bytecode as they are not in sync.\n        \"\"\"\n        for template_line, code_line in reversed(self.debug_info):\n            if code_line <= lineno:\n                return template_line\n        return 1\n\n    @property\n    def is_up_to_date(self) -> bool:\n        \"\"\"If this variable is `False` there is a newer version available.\"\"\"\n        if self._uptodate is None:\n            return True\n        return self._uptodate()\n\n    @property\n    def debug_info(self) -> t.List[t.Tuple[int, int]]:\n        \"\"\"The debug info mapping.\"\"\"\n        if self._debug_info:\n            return [\n                tuple(map(int, x.split(\"=\")))  # type: ignore\n                for x in self._debug_info.split(\"&\")\n            ]\n\n        return []\n\n    def __repr__(self) -> str:\n        if self.name is None:\n            name = f\"memory:{id(self):x}\"\n        else:\n            name = repr(self.name)\n        return f\"<{type(self).__name__} {name}>\"\n\n\nclass TemplateModule:\n    \"\"\"Represents an imported template.  All the exported names of the\n    template are available as attributes on this object.  Additionally\n    converting it into a string renders the contents.\n    \"\"\"\n\n    def __init__(\n        self,\n        template: Template,\n        context: Context,\n        body_stream: t.Optional[t.Iterable[str]] = None,\n    ) -> None:\n        if body_stream is None:\n            if context.environment.is_async:\n                raise RuntimeError(\n                    \"Async mode requires a body stream to be passed to\"\n                    \" a template module. Use the async methods of the\"\n                    \" API you are using.\"\n                )\n\n            body_stream = list(template.root_render_func(context))\n\n        self._body_stream = body_stream\n        self.__dict__.update(context.get_exported())\n        self.__name__ = template.name\n\n    def __html__(self) -> Markup:\n        return Markup(concat(self._body_stream))\n\n    def __str__(self) -> str:\n        return concat(self._body_stream)\n\n    def __repr__(self) -> str:\n        if self.__name__ is None:\n            name = f\"memory:{id(self):x}\"\n        else:\n            name = repr(self.__name__)\n        return f\"<{type(self).__name__} {name}>\"\n\n\nclass TemplateExpression:\n    \"\"\"The :meth:`jinja2.Environment.compile_expression` method returns an\n    instance of this object.  It encapsulates the expression-like access\n    to the template with an expression it wraps.\n    \"\"\"\n\n    def __init__(self, template: Template, undefined_to_none: bool) -> None:\n        self._template = template\n        self._undefined_to_none = undefined_to_none\n\n    def __call__(self, *args: t.Any, **kwargs: t.Any) -> t.Optional[t.Any]:\n        context = self._template.new_context(dict(*args, **kwargs))\n        consume(self._template.root_render_func(context))\n        rv = context.vars[\"result\"]\n        if self._undefined_to_none and isinstance(rv, Undefined):\n            rv = None\n        return rv\n\n\nclass TemplateStream:\n    \"\"\"A template stream works pretty much like an ordinary python generator\n    but it can buffer multiple items to reduce the number of total iterations.\n    Per default the output is unbuffered which means that for every unbuffered\n    instruction in the template one string is yielded.\n\n    If buffering is enabled with a buffer size of 5, five items are combined\n    into a new string.  This is mainly useful if you are streaming\n    big templates to a client via WSGI which flushes after each iteration.\n    \"\"\"\n\n    def __init__(self, gen: t.Iterator[str]) -> None:\n        self._gen = gen\n        self.disable_buffering()\n\n    def dump(\n        self,\n        fp: t.Union[str, t.IO[bytes]],\n        encoding: t.Optional[str] = None,\n        errors: t.Optional[str] = \"strict\",\n    ) -> None:\n        \"\"\"Dump the complete stream into a file or file-like object.\n        Per default strings are written, if you want to encode\n        before writing specify an `encoding`.\n\n        Example usage::\n\n            Template('Hello {{ name }}!').stream(name='foo').dump('hello.html')\n        \"\"\"\n        close = False\n\n        if isinstance(fp, str):\n            if encoding is None:\n                encoding = \"utf-8\"\n\n            real_fp: t.IO[bytes] = open(fp, \"wb\")\n            close = True\n        else:\n            real_fp = fp\n\n        try:\n            if encoding is not None:\n                iterable = (x.encode(encoding, errors) for x in self)  # type: ignore\n            else:\n                iterable = self  # type: ignore\n\n            if hasattr(real_fp, \"writelines\"):\n                real_fp.writelines(iterable)\n            else:\n                for item in iterable:\n                    real_fp.write(item)\n        finally:\n            if close:\n                real_fp.close()\n\n    def disable_buffering(self) -> None:\n        \"\"\"Disable the output buffering.\"\"\"\n        self._next = partial(next, self._gen)\n        self.buffered = False\n\n    def _buffered_generator(self, size: int) -> t.Iterator[str]:\n        buf: t.List[str] = []\n        c_size = 0\n        push = buf.append\n\n        while True:\n            try:\n                while c_size < size:\n                    c = next(self._gen)\n                    push(c)\n                    if c:\n                        c_size += 1\n            except StopIteration:\n                if not c_size:\n                    return\n            yield concat(buf)\n            del buf[:]\n            c_size = 0\n\n    def enable_buffering(self, size: int = 5) -> None:\n        \"\"\"Enable buffering.  Buffer `size` items before yielding them.\"\"\"\n        if size <= 1:\n            raise ValueError(\"buffer size too small\")\n\n        self.buffered = True\n        self._next = partial(next, self._buffered_generator(size))\n\n    def __iter__(self) -> \"TemplateStream\":\n        return self\n\n    def __next__(self) -> str:\n        return self._next()  # type: ignore\n\n\n# hook in default template class.  if anyone reads this comment: ignore that\n# it's possible to use custom templates ;-)\nEnvironment.template_class = Template\n", "src/jinja2/debug.py": "import sys\nimport typing as t\nfrom types import CodeType\nfrom types import TracebackType\n\nfrom .exceptions import TemplateSyntaxError\nfrom .utils import internal_code\nfrom .utils import missing\n\nif t.TYPE_CHECKING:\n    from .runtime import Context\n\n\ndef rewrite_traceback_stack(source: t.Optional[str] = None) -> BaseException:\n    \"\"\"Rewrite the current exception to replace any tracebacks from\n    within compiled template code with tracebacks that look like they\n    came from the template source.\n\n    This must be called within an ``except`` block.\n\n    :param source: For ``TemplateSyntaxError``, the original source if\n        known.\n    :return: The original exception with the rewritten traceback.\n    \"\"\"\n    _, exc_value, tb = sys.exc_info()\n    exc_value = t.cast(BaseException, exc_value)\n    tb = t.cast(TracebackType, tb)\n\n    if isinstance(exc_value, TemplateSyntaxError) and not exc_value.translated:\n        exc_value.translated = True\n        exc_value.source = source\n        # Remove the old traceback, otherwise the frames from the\n        # compiler still show up.\n        exc_value.with_traceback(None)\n        # Outside of runtime, so the frame isn't executing template\n        # code, but it still needs to point at the template.\n        tb = fake_traceback(\n            exc_value, None, exc_value.filename or \"<unknown>\", exc_value.lineno\n        )\n    else:\n        # Skip the frame for the render function.\n        tb = tb.tb_next\n\n    stack = []\n\n    # Build the stack of traceback object, replacing any in template\n    # code with the source file and line information.\n    while tb is not None:\n        # Skip frames decorated with @internalcode. These are internal\n        # calls that aren't useful in template debugging output.\n        if tb.tb_frame.f_code in internal_code:\n            tb = tb.tb_next\n            continue\n\n        template = tb.tb_frame.f_globals.get(\"__jinja_template__\")\n\n        if template is not None:\n            lineno = template.get_corresponding_lineno(tb.tb_lineno)\n            fake_tb = fake_traceback(exc_value, tb, template.filename, lineno)\n            stack.append(fake_tb)\n        else:\n            stack.append(tb)\n\n        tb = tb.tb_next\n\n    tb_next = None\n\n    # Assign tb_next in reverse to avoid circular references.\n    for tb in reversed(stack):\n        tb.tb_next = tb_next\n        tb_next = tb\n\n    return exc_value.with_traceback(tb_next)\n\n\ndef fake_traceback(  # type: ignore\n    exc_value: BaseException, tb: t.Optional[TracebackType], filename: str, lineno: int\n) -> TracebackType:\n    \"\"\"Produce a new traceback object that looks like it came from the\n    template source instead of the compiled code. The filename, line\n    number, and location name will point to the template, and the local\n    variables will be the current template context.\n\n    :param exc_value: The original exception to be re-raised to create\n        the new traceback.\n    :param tb: The original traceback to get the local variables and\n        code info from.\n    :param filename: The template filename.\n    :param lineno: The line number in the template source.\n    \"\"\"\n    if tb is not None:\n        # Replace the real locals with the context that would be\n        # available at that point in the template.\n        locals = get_template_locals(tb.tb_frame.f_locals)\n        locals.pop(\"__jinja_exception__\", None)\n    else:\n        locals = {}\n\n    globals = {\n        \"__name__\": filename,\n        \"__file__\": filename,\n        \"__jinja_exception__\": exc_value,\n    }\n    # Raise an exception at the correct line number.\n    code: CodeType = compile(\n        \"\\n\" * (lineno - 1) + \"raise __jinja_exception__\", filename, \"exec\"\n    )\n\n    # Build a new code object that points to the template file and\n    # replaces the location with a block name.\n    location = \"template\"\n\n    if tb is not None:\n        function = tb.tb_frame.f_code.co_name\n\n        if function == \"root\":\n            location = \"top-level template code\"\n        elif function.startswith(\"block_\"):\n            location = f\"block {function[6:]!r}\"\n\n    code = code.replace(co_name=location)\n\n    # Execute the new code, which is guaranteed to raise, and return\n    # the new traceback without this frame.\n    try:\n        exec(code, globals, locals)\n    except BaseException:\n        return sys.exc_info()[2].tb_next  # type: ignore\n\n\ndef get_template_locals(real_locals: t.Mapping[str, t.Any]) -> t.Dict[str, t.Any]:\n    \"\"\"Based on the runtime locals, get the context that would be\n    available at that point in the template.\n    \"\"\"\n    # Start with the current template context.\n    ctx: t.Optional[Context] = real_locals.get(\"context\")\n\n    if ctx is not None:\n        data: t.Dict[str, t.Any] = ctx.get_all().copy()\n    else:\n        data = {}\n\n    # Might be in a derived context that only sets local variables\n    # rather than pushing a context. Local variables follow the scheme\n    # l_depth_name. Find the highest-depth local that has a value for\n    # each name.\n    local_overrides: t.Dict[str, t.Tuple[int, t.Any]] = {}\n\n    for name, value in real_locals.items():\n        if not name.startswith(\"l_\") or value is missing:\n            # Not a template variable, or no longer relevant.\n            continue\n\n        try:\n            _, depth_str, name = name.split(\"_\", 2)\n            depth = int(depth_str)\n        except ValueError:\n            continue\n\n        cur_depth = local_overrides.get(name, (-1,))[0]\n\n        if cur_depth < depth:\n            local_overrides[name] = (depth, value)\n\n    # Modify the context with any derived context.\n    for name, (_, value) in local_overrides.items():\n        if value is missing:\n            data.pop(name, None)\n        else:\n            data[name] = value\n\n    return data\n", "src/jinja2/optimizer.py": "\"\"\"The optimizer tries to constant fold expressions and modify the AST\nin place so that it should be faster to evaluate.\n\nBecause the AST does not contain all the scoping information and the\ncompiler has to find that out, we cannot do all the optimizations we\nwant. For example, loop unrolling doesn't work because unrolled loops\nwould have a different scope. The solution would be a second syntax tree\nthat stored the scoping rules.\n\"\"\"\n\nimport typing as t\n\nfrom . import nodes\nfrom .visitor import NodeTransformer\n\nif t.TYPE_CHECKING:\n    from .environment import Environment\n\n\ndef optimize(node: nodes.Node, environment: \"Environment\") -> nodes.Node:\n    \"\"\"The context hint can be used to perform an static optimization\n    based on the context given.\"\"\"\n    optimizer = Optimizer(environment)\n    return t.cast(nodes.Node, optimizer.visit(node))\n\n\nclass Optimizer(NodeTransformer):\n    def __init__(self, environment: \"t.Optional[Environment]\") -> None:\n        self.environment = environment\n\n    def generic_visit(\n        self, node: nodes.Node, *args: t.Any, **kwargs: t.Any\n    ) -> nodes.Node:\n        node = super().generic_visit(node, *args, **kwargs)\n\n        # Do constant folding. Some other nodes besides Expr have\n        # as_const, but folding them causes errors later on.\n        if isinstance(node, nodes.Expr):\n            try:\n                return nodes.Const.from_untrusted(\n                    node.as_const(args[0] if args else None),\n                    lineno=node.lineno,\n                    environment=self.environment,\n                )\n            except nodes.Impossible:\n                pass\n\n        return node\n", "src/jinja2/compiler.py": "\"\"\"Compiles nodes from the parser into Python code.\"\"\"\n\nimport typing as t\nfrom contextlib import contextmanager\nfrom functools import update_wrapper\nfrom io import StringIO\nfrom itertools import chain\nfrom keyword import iskeyword as is_python_keyword\n\nfrom markupsafe import escape\nfrom markupsafe import Markup\n\nfrom . import nodes\nfrom .exceptions import TemplateAssertionError\nfrom .idtracking import Symbols\nfrom .idtracking import VAR_LOAD_ALIAS\nfrom .idtracking import VAR_LOAD_PARAMETER\nfrom .idtracking import VAR_LOAD_RESOLVE\nfrom .idtracking import VAR_LOAD_UNDEFINED\nfrom .nodes import EvalContext\nfrom .optimizer import Optimizer\nfrom .utils import _PassArg\nfrom .utils import concat\nfrom .visitor import NodeVisitor\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .environment import Environment\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\noperators = {\n    \"eq\": \"==\",\n    \"ne\": \"!=\",\n    \"gt\": \">\",\n    \"gteq\": \">=\",\n    \"lt\": \"<\",\n    \"lteq\": \"<=\",\n    \"in\": \"in\",\n    \"notin\": \"not in\",\n}\n\n\ndef optimizeconst(f: F) -> F:\n    def new_func(\n        self: \"CodeGenerator\", node: nodes.Expr, frame: \"Frame\", **kwargs: t.Any\n    ) -> t.Any:\n        # Only optimize if the frame is not volatile\n        if self.optimizer is not None and not frame.eval_ctx.volatile:\n            new_node = self.optimizer.visit(node, frame.eval_ctx)\n\n            if new_node != node:\n                return self.visit(new_node, frame)\n\n        return f(self, node, frame, **kwargs)\n\n    return update_wrapper(new_func, f)  # type: ignore[return-value]\n\n\ndef _make_binop(op: str) -> t.Callable[[\"CodeGenerator\", nodes.BinExpr, \"Frame\"], None]:\n    @optimizeconst\n    def visitor(self: \"CodeGenerator\", node: nodes.BinExpr, frame: Frame) -> None:\n        if (\n            self.environment.sandboxed and op in self.environment.intercepted_binops  # type: ignore\n        ):\n            self.write(f\"environment.call_binop(context, {op!r}, \")\n            self.visit(node.left, frame)\n            self.write(\", \")\n            self.visit(node.right, frame)\n        else:\n            self.write(\"(\")\n            self.visit(node.left, frame)\n            self.write(f\" {op} \")\n            self.visit(node.right, frame)\n\n        self.write(\")\")\n\n    return visitor\n\n\ndef _make_unop(\n    op: str,\n) -> t.Callable[[\"CodeGenerator\", nodes.UnaryExpr, \"Frame\"], None]:\n    @optimizeconst\n    def visitor(self: \"CodeGenerator\", node: nodes.UnaryExpr, frame: Frame) -> None:\n        if (\n            self.environment.sandboxed and op in self.environment.intercepted_unops  # type: ignore\n        ):\n            self.write(f\"environment.call_unop(context, {op!r}, \")\n            self.visit(node.node, frame)\n        else:\n            self.write(\"(\" + op)\n            self.visit(node.node, frame)\n\n        self.write(\")\")\n\n    return visitor\n\n\ndef generate(\n    node: nodes.Template,\n    environment: \"Environment\",\n    name: t.Optional[str],\n    filename: t.Optional[str],\n    stream: t.Optional[t.TextIO] = None,\n    defer_init: bool = False,\n    optimized: bool = True,\n) -> t.Optional[str]:\n    \"\"\"Generate the python source for a node tree.\"\"\"\n    if not isinstance(node, nodes.Template):\n        raise TypeError(\"Can't compile non template nodes\")\n\n    generator = environment.code_generator_class(\n        environment, name, filename, stream, defer_init, optimized\n    )\n    generator.visit(node)\n\n    if stream is None:\n        return generator.stream.getvalue()  # type: ignore\n\n    return None\n\n\ndef has_safe_repr(value: t.Any) -> bool:\n    \"\"\"Does the node have a safe representation?\"\"\"\n    if value is None or value is NotImplemented or value is Ellipsis:\n        return True\n\n    if type(value) in {bool, int, float, complex, range, str, Markup}:\n        return True\n\n    if type(value) in {tuple, list, set, frozenset}:\n        return all(has_safe_repr(v) for v in value)\n\n    if type(value) is dict:  # noqa E721\n        return all(has_safe_repr(k) and has_safe_repr(v) for k, v in value.items())\n\n    return False\n\n\ndef find_undeclared(\n    nodes: t.Iterable[nodes.Node], names: t.Iterable[str]\n) -> t.Set[str]:\n    \"\"\"Check if the names passed are accessed undeclared.  The return value\n    is a set of all the undeclared names from the sequence of names found.\n    \"\"\"\n    visitor = UndeclaredNameVisitor(names)\n    try:\n        for node in nodes:\n            visitor.visit(node)\n    except VisitorExit:\n        pass\n    return visitor.undeclared\n\n\nclass MacroRef:\n    def __init__(self, node: t.Union[nodes.Macro, nodes.CallBlock]) -> None:\n        self.node = node\n        self.accesses_caller = False\n        self.accesses_kwargs = False\n        self.accesses_varargs = False\n\n\nclass Frame:\n    \"\"\"Holds compile time information for us.\"\"\"\n\n    def __init__(\n        self,\n        eval_ctx: EvalContext,\n        parent: t.Optional[\"Frame\"] = None,\n        level: t.Optional[int] = None,\n    ) -> None:\n        self.eval_ctx = eval_ctx\n\n        # the parent of this frame\n        self.parent = parent\n\n        if parent is None:\n            self.symbols = Symbols(level=level)\n\n            # in some dynamic inheritance situations the compiler needs to add\n            # write tests around output statements.\n            self.require_output_check = False\n\n            # inside some tags we are using a buffer rather than yield statements.\n            # this for example affects {% filter %} or {% macro %}.  If a frame\n            # is buffered this variable points to the name of the list used as\n            # buffer.\n            self.buffer: t.Optional[str] = None\n\n            # the name of the block we're in, otherwise None.\n            self.block: t.Optional[str] = None\n\n        else:\n            self.symbols = Symbols(parent.symbols, level=level)\n            self.require_output_check = parent.require_output_check\n            self.buffer = parent.buffer\n            self.block = parent.block\n\n        # a toplevel frame is the root + soft frames such as if conditions.\n        self.toplevel = False\n\n        # the root frame is basically just the outermost frame, so no if\n        # conditions.  This information is used to optimize inheritance\n        # situations.\n        self.rootlevel = False\n\n        # variables set inside of loops and blocks should not affect outer frames,\n        # but they still needs to be kept track of as part of the active context.\n        self.loop_frame = False\n        self.block_frame = False\n\n        # track whether the frame is being used in an if-statement or conditional\n        # expression as it determines which errors should be raised during runtime\n        # or compile time.\n        self.soft_frame = False\n\n    def copy(self) -> \"Frame\":\n        \"\"\"Create a copy of the current one.\"\"\"\n        rv = object.__new__(self.__class__)\n        rv.__dict__.update(self.__dict__)\n        rv.symbols = self.symbols.copy()\n        return rv\n\n    def inner(self, isolated: bool = False) -> \"Frame\":\n        \"\"\"Return an inner frame.\"\"\"\n        if isolated:\n            return Frame(self.eval_ctx, level=self.symbols.level + 1)\n        return Frame(self.eval_ctx, self)\n\n    def soft(self) -> \"Frame\":\n        \"\"\"Return a soft frame.  A soft frame may not be modified as\n        standalone thing as it shares the resources with the frame it\n        was created of, but it's not a rootlevel frame any longer.\n\n        This is only used to implement if-statements and conditional\n        expressions.\n        \"\"\"\n        rv = self.copy()\n        rv.rootlevel = False\n        rv.soft_frame = True\n        return rv\n\n    __copy__ = copy\n\n\nclass VisitorExit(RuntimeError):\n    \"\"\"Exception used by the `UndeclaredNameVisitor` to signal a stop.\"\"\"\n\n\nclass DependencyFinderVisitor(NodeVisitor):\n    \"\"\"A visitor that collects filter and test calls.\"\"\"\n\n    def __init__(self) -> None:\n        self.filters: t.Set[str] = set()\n        self.tests: t.Set[str] = set()\n\n    def visit_Filter(self, node: nodes.Filter) -> None:\n        self.generic_visit(node)\n        self.filters.add(node.name)\n\n    def visit_Test(self, node: nodes.Test) -> None:\n        self.generic_visit(node)\n        self.tests.add(node.name)\n\n    def visit_Block(self, node: nodes.Block) -> None:\n        \"\"\"Stop visiting at blocks.\"\"\"\n\n\nclass UndeclaredNameVisitor(NodeVisitor):\n    \"\"\"A visitor that checks if a name is accessed without being\n    declared.  This is different from the frame visitor as it will\n    not stop at closure frames.\n    \"\"\"\n\n    def __init__(self, names: t.Iterable[str]) -> None:\n        self.names = set(names)\n        self.undeclared: t.Set[str] = set()\n\n    def visit_Name(self, node: nodes.Name) -> None:\n        if node.ctx == \"load\" and node.name in self.names:\n            self.undeclared.add(node.name)\n            if self.undeclared == self.names:\n                raise VisitorExit()\n        else:\n            self.names.discard(node.name)\n\n    def visit_Block(self, node: nodes.Block) -> None:\n        \"\"\"Stop visiting a blocks.\"\"\"\n\n\nclass CompilerExit(Exception):\n    \"\"\"Raised if the compiler encountered a situation where it just\n    doesn't make sense to further process the code.  Any block that\n    raises such an exception is not further processed.\n    \"\"\"\n\n\nclass CodeGenerator(NodeVisitor):\n    def __init__(\n        self,\n        environment: \"Environment\",\n        name: t.Optional[str],\n        filename: t.Optional[str],\n        stream: t.Optional[t.TextIO] = None,\n        defer_init: bool = False,\n        optimized: bool = True,\n    ) -> None:\n        if stream is None:\n            stream = StringIO()\n        self.environment = environment\n        self.name = name\n        self.filename = filename\n        self.stream = stream\n        self.created_block_context = False\n        self.defer_init = defer_init\n        self.optimizer: t.Optional[Optimizer] = None\n\n        if optimized:\n            self.optimizer = Optimizer(environment)\n\n        # aliases for imports\n        self.import_aliases: t.Dict[str, str] = {}\n\n        # a registry for all blocks.  Because blocks are moved out\n        # into the global python scope they are registered here\n        self.blocks: t.Dict[str, nodes.Block] = {}\n\n        # the number of extends statements so far\n        self.extends_so_far = 0\n\n        # some templates have a rootlevel extends.  In this case we\n        # can safely assume that we're a child template and do some\n        # more optimizations.\n        self.has_known_extends = False\n\n        # the current line number\n        self.code_lineno = 1\n\n        # registry of all filters and tests (global, not block local)\n        self.tests: t.Dict[str, str] = {}\n        self.filters: t.Dict[str, str] = {}\n\n        # the debug information\n        self.debug_info: t.List[t.Tuple[int, int]] = []\n        self._write_debug_info: t.Optional[int] = None\n\n        # the number of new lines before the next write()\n        self._new_lines = 0\n\n        # the line number of the last written statement\n        self._last_line = 0\n\n        # true if nothing was written so far.\n        self._first_write = True\n\n        # used by the `temporary_identifier` method to get new\n        # unique, temporary identifier\n        self._last_identifier = 0\n\n        # the current indentation\n        self._indentation = 0\n\n        # Tracks toplevel assignments\n        self._assign_stack: t.List[t.Set[str]] = []\n\n        # Tracks parameter definition blocks\n        self._param_def_block: t.List[t.Set[str]] = []\n\n        # Tracks the current context.\n        self._context_reference_stack = [\"context\"]\n\n    @property\n    def optimized(self) -> bool:\n        return self.optimizer is not None\n\n    # -- Various compilation helpers\n\n    def fail(self, msg: str, lineno: int) -> \"te.NoReturn\":\n        \"\"\"Fail with a :exc:`TemplateAssertionError`.\"\"\"\n        raise TemplateAssertionError(msg, lineno, self.name, self.filename)\n\n    def temporary_identifier(self) -> str:\n        \"\"\"Get a new unique identifier.\"\"\"\n        self._last_identifier += 1\n        return f\"t_{self._last_identifier}\"\n\n    def buffer(self, frame: Frame) -> None:\n        \"\"\"Enable buffering for the frame from that point onwards.\"\"\"\n        frame.buffer = self.temporary_identifier()\n        self.writeline(f\"{frame.buffer} = []\")\n\n    def return_buffer_contents(\n        self, frame: Frame, force_unescaped: bool = False\n    ) -> None:\n        \"\"\"Return the buffer contents of the frame.\"\"\"\n        if not force_unescaped:\n            if frame.eval_ctx.volatile:\n                self.writeline(\"if context.eval_ctx.autoescape:\")\n                self.indent()\n                self.writeline(f\"return Markup(concat({frame.buffer}))\")\n                self.outdent()\n                self.writeline(\"else:\")\n                self.indent()\n                self.writeline(f\"return concat({frame.buffer})\")\n                self.outdent()\n                return\n            elif frame.eval_ctx.autoescape:\n                self.writeline(f\"return Markup(concat({frame.buffer}))\")\n                return\n        self.writeline(f\"return concat({frame.buffer})\")\n\n    def indent(self) -> None:\n        \"\"\"Indent by one.\"\"\"\n        self._indentation += 1\n\n    def outdent(self, step: int = 1) -> None:\n        \"\"\"Outdent by step.\"\"\"\n        self._indentation -= step\n\n    def start_write(self, frame: Frame, node: t.Optional[nodes.Node] = None) -> None:\n        \"\"\"Yield or write into the frame buffer.\"\"\"\n        if frame.buffer is None:\n            self.writeline(\"yield \", node)\n        else:\n            self.writeline(f\"{frame.buffer}.append(\", node)\n\n    def end_write(self, frame: Frame) -> None:\n        \"\"\"End the writing process started by `start_write`.\"\"\"\n        if frame.buffer is not None:\n            self.write(\")\")\n\n    def simple_write(\n        self, s: str, frame: Frame, node: t.Optional[nodes.Node] = None\n    ) -> None:\n        \"\"\"Simple shortcut for start_write + write + end_write.\"\"\"\n        self.start_write(frame, node)\n        self.write(s)\n        self.end_write(frame)\n\n    def blockvisit(self, nodes: t.Iterable[nodes.Node], frame: Frame) -> None:\n        \"\"\"Visit a list of nodes as block in a frame.  If the current frame\n        is no buffer a dummy ``if 0: yield None`` is written automatically.\n        \"\"\"\n        try:\n            self.writeline(\"pass\")\n            for node in nodes:\n                self.visit(node, frame)\n        except CompilerExit:\n            pass\n\n    def write(self, x: str) -> None:\n        \"\"\"Write a string into the output stream.\"\"\"\n        if self._new_lines:\n            if not self._first_write:\n                self.stream.write(\"\\n\" * self._new_lines)\n                self.code_lineno += self._new_lines\n                if self._write_debug_info is not None:\n                    self.debug_info.append((self._write_debug_info, self.code_lineno))\n                    self._write_debug_info = None\n            self._first_write = False\n            self.stream.write(\"    \" * self._indentation)\n            self._new_lines = 0\n        self.stream.write(x)\n\n    def writeline(\n        self, x: str, node: t.Optional[nodes.Node] = None, extra: int = 0\n    ) -> None:\n        \"\"\"Combination of newline and write.\"\"\"\n        self.newline(node, extra)\n        self.write(x)\n\n    def newline(self, node: t.Optional[nodes.Node] = None, extra: int = 0) -> None:\n        \"\"\"Add one or more newlines before the next write.\"\"\"\n        self._new_lines = max(self._new_lines, 1 + extra)\n        if node is not None and node.lineno != self._last_line:\n            self._write_debug_info = node.lineno\n            self._last_line = node.lineno\n\n    def signature(\n        self,\n        node: t.Union[nodes.Call, nodes.Filter, nodes.Test],\n        frame: Frame,\n        extra_kwargs: t.Optional[t.Mapping[str, t.Any]] = None,\n    ) -> None:\n        \"\"\"Writes a function call to the stream for the current node.\n        A leading comma is added automatically.  The extra keyword\n        arguments may not include python keywords otherwise a syntax\n        error could occur.  The extra keyword arguments should be given\n        as python dict.\n        \"\"\"\n        # if any of the given keyword arguments is a python keyword\n        # we have to make sure that no invalid call is created.\n        kwarg_workaround = any(\n            is_python_keyword(t.cast(str, k))\n            for k in chain((x.key for x in node.kwargs), extra_kwargs or ())\n        )\n\n        for arg in node.args:\n            self.write(\", \")\n            self.visit(arg, frame)\n\n        if not kwarg_workaround:\n            for kwarg in node.kwargs:\n                self.write(\", \")\n                self.visit(kwarg, frame)\n            if extra_kwargs is not None:\n                for key, value in extra_kwargs.items():\n                    self.write(f\", {key}={value}\")\n        if node.dyn_args:\n            self.write(\", *\")\n            self.visit(node.dyn_args, frame)\n\n        if kwarg_workaround:\n            if node.dyn_kwargs is not None:\n                self.write(\", **dict({\")\n            else:\n                self.write(\", **{\")\n            for kwarg in node.kwargs:\n                self.write(f\"{kwarg.key!r}: \")\n                self.visit(kwarg.value, frame)\n                self.write(\", \")\n            if extra_kwargs is not None:\n                for key, value in extra_kwargs.items():\n                    self.write(f\"{key!r}: {value}, \")\n            if node.dyn_kwargs is not None:\n                self.write(\"}, **\")\n                self.visit(node.dyn_kwargs, frame)\n                self.write(\")\")\n            else:\n                self.write(\"}\")\n\n        elif node.dyn_kwargs is not None:\n            self.write(\", **\")\n            self.visit(node.dyn_kwargs, frame)\n\n    def pull_dependencies(self, nodes: t.Iterable[nodes.Node]) -> None:\n        \"\"\"Find all filter and test names used in the template and\n        assign them to variables in the compiled namespace. Checking\n        that the names are registered with the environment is done when\n        compiling the Filter and Test nodes. If the node is in an If or\n        CondExpr node, the check is done at runtime instead.\n\n        .. versionchanged:: 3.0\n            Filters and tests in If and CondExpr nodes are checked at\n            runtime instead of compile time.\n        \"\"\"\n        visitor = DependencyFinderVisitor()\n\n        for node in nodes:\n            visitor.visit(node)\n\n        for id_map, names, dependency in (\n            (self.filters, visitor.filters, \"filters\"),\n            (\n                self.tests,\n                visitor.tests,\n                \"tests\",\n            ),\n        ):\n            for name in sorted(names):\n                if name not in id_map:\n                    id_map[name] = self.temporary_identifier()\n\n                # add check during runtime that dependencies used inside of executed\n                # blocks are defined, as this step may be skipped during compile time\n                self.writeline(\"try:\")\n                self.indent()\n                self.writeline(f\"{id_map[name]} = environment.{dependency}[{name!r}]\")\n                self.outdent()\n                self.writeline(\"except KeyError:\")\n                self.indent()\n                self.writeline(\"@internalcode\")\n                self.writeline(f\"def {id_map[name]}(*unused):\")\n                self.indent()\n                self.writeline(\n                    f'raise TemplateRuntimeError(\"No {dependency[:-1]}'\n                    f' named {name!r} found.\")'\n                )\n                self.outdent()\n                self.outdent()\n\n    def enter_frame(self, frame: Frame) -> None:\n        undefs = []\n        for target, (action, param) in frame.symbols.loads.items():\n            if action == VAR_LOAD_PARAMETER:\n                pass\n            elif action == VAR_LOAD_RESOLVE:\n                self.writeline(f\"{target} = {self.get_resolve_func()}({param!r})\")\n            elif action == VAR_LOAD_ALIAS:\n                self.writeline(f\"{target} = {param}\")\n            elif action == VAR_LOAD_UNDEFINED:\n                undefs.append(target)\n            else:\n                raise NotImplementedError(\"unknown load instruction\")\n        if undefs:\n            self.writeline(f\"{' = '.join(undefs)} = missing\")\n\n    def leave_frame(self, frame: Frame, with_python_scope: bool = False) -> None:\n        if not with_python_scope:\n            undefs = []\n            for target in frame.symbols.loads:\n                undefs.append(target)\n            if undefs:\n                self.writeline(f\"{' = '.join(undefs)} = missing\")\n\n    def choose_async(self, async_value: str = \"async \", sync_value: str = \"\") -> str:\n        return async_value if self.environment.is_async else sync_value\n\n    def func(self, name: str) -> str:\n        return f\"{self.choose_async()}def {name}\"\n\n    def macro_body(\n        self, node: t.Union[nodes.Macro, nodes.CallBlock], frame: Frame\n    ) -> t.Tuple[Frame, MacroRef]:\n        \"\"\"Dump the function def of a macro or call block.\"\"\"\n        frame = frame.inner()\n        frame.symbols.analyze_node(node)\n        macro_ref = MacroRef(node)\n\n        explicit_caller = None\n        skip_special_params = set()\n        args = []\n\n        for idx, arg in enumerate(node.args):\n            if arg.name == \"caller\":\n                explicit_caller = idx\n            if arg.name in (\"kwargs\", \"varargs\"):\n                skip_special_params.add(arg.name)\n            args.append(frame.symbols.ref(arg.name))\n\n        undeclared = find_undeclared(node.body, (\"caller\", \"kwargs\", \"varargs\"))\n\n        if \"caller\" in undeclared:\n            # In older Jinja versions there was a bug that allowed caller\n            # to retain the special behavior even if it was mentioned in\n            # the argument list.  However thankfully this was only really\n            # working if it was the last argument.  So we are explicitly\n            # checking this now and error out if it is anywhere else in\n            # the argument list.\n            if explicit_caller is not None:\n                try:\n                    node.defaults[explicit_caller - len(node.args)]\n                except IndexError:\n                    self.fail(\n                        \"When defining macros or call blocks the \"\n                        'special \"caller\" argument must be omitted '\n                        \"or be given a default.\",\n                        node.lineno,\n                    )\n            else:\n                args.append(frame.symbols.declare_parameter(\"caller\"))\n            macro_ref.accesses_caller = True\n        if \"kwargs\" in undeclared and \"kwargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"kwargs\"))\n            macro_ref.accesses_kwargs = True\n        if \"varargs\" in undeclared and \"varargs\" not in skip_special_params:\n            args.append(frame.symbols.declare_parameter(\"varargs\"))\n            macro_ref.accesses_varargs = True\n\n        # macros are delayed, they never require output checks\n        frame.require_output_check = False\n        frame.symbols.analyze_node(node)\n        self.writeline(f\"{self.func('macro')}({', '.join(args)}):\", node)\n        self.indent()\n\n        self.buffer(frame)\n        self.enter_frame(frame)\n\n        self.push_parameter_definitions(frame)\n        for idx, arg in enumerate(node.args):\n            ref = frame.symbols.ref(arg.name)\n            self.writeline(f\"if {ref} is missing:\")\n            self.indent()\n            try:\n                default = node.defaults[idx - len(node.args)]\n            except IndexError:\n                self.writeline(\n                    f'{ref} = undefined(\"parameter {arg.name!r} was not provided\",'\n                    f\" name={arg.name!r})\"\n                )\n            else:\n                self.writeline(f\"{ref} = \")\n                self.visit(default, frame)\n            self.mark_parameter_stored(ref)\n            self.outdent()\n        self.pop_parameter_definitions()\n\n        self.blockvisit(node.body, frame)\n        self.return_buffer_contents(frame, force_unescaped=True)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        return frame, macro_ref\n\n    def macro_def(self, macro_ref: MacroRef, frame: Frame) -> None:\n        \"\"\"Dump the macro definition for the def created by macro_body.\"\"\"\n        arg_tuple = \", \".join(repr(x.name) for x in macro_ref.node.args)\n        name = getattr(macro_ref.node, \"name\", None)\n        if len(macro_ref.node.args) == 1:\n            arg_tuple += \",\"\n        self.write(\n            f\"Macro(environment, macro, {name!r}, ({arg_tuple}),\"\n            f\" {macro_ref.accesses_kwargs!r}, {macro_ref.accesses_varargs!r},\"\n            f\" {macro_ref.accesses_caller!r}, context.eval_ctx.autoescape)\"\n        )\n\n    def position(self, node: nodes.Node) -> str:\n        \"\"\"Return a human readable position for the node.\"\"\"\n        rv = f\"line {node.lineno}\"\n        if self.name is not None:\n            rv = f\"{rv} in {self.name!r}\"\n        return rv\n\n    def dump_local_context(self, frame: Frame) -> str:\n        items_kv = \", \".join(\n            f\"{name!r}: {target}\"\n            for name, target in frame.symbols.dump_stores().items()\n        )\n        return f\"{{{items_kv}}}\"\n\n    def write_commons(self) -> None:\n        \"\"\"Writes a common preamble that is used by root and block functions.\n        Primarily this sets up common local helpers and enforces a generator\n        through a dead branch.\n        \"\"\"\n        self.writeline(\"resolve = context.resolve_or_missing\")\n        self.writeline(\"undefined = environment.undefined\")\n        self.writeline(\"concat = environment.concat\")\n        # always use the standard Undefined class for the implicit else of\n        # conditional expressions\n        self.writeline(\"cond_expr_undefined = Undefined\")\n        self.writeline(\"if 0: yield None\")\n\n    def push_parameter_definitions(self, frame: Frame) -> None:\n        \"\"\"Pushes all parameter targets from the given frame into a local\n        stack that permits tracking of yet to be assigned parameters.  In\n        particular this enables the optimization from `visit_Name` to skip\n        undefined expressions for parameters in macros as macros can reference\n        otherwise unbound parameters.\n        \"\"\"\n        self._param_def_block.append(frame.symbols.dump_param_targets())\n\n    def pop_parameter_definitions(self) -> None:\n        \"\"\"Pops the current parameter definitions set.\"\"\"\n        self._param_def_block.pop()\n\n    def mark_parameter_stored(self, target: str) -> None:\n        \"\"\"Marks a parameter in the current parameter definitions as stored.\n        This will skip the enforced undefined checks.\n        \"\"\"\n        if self._param_def_block:\n            self._param_def_block[-1].discard(target)\n\n    def push_context_reference(self, target: str) -> None:\n        self._context_reference_stack.append(target)\n\n    def pop_context_reference(self) -> None:\n        self._context_reference_stack.pop()\n\n    def get_context_ref(self) -> str:\n        return self._context_reference_stack[-1]\n\n    def get_resolve_func(self) -> str:\n        target = self._context_reference_stack[-1]\n        if target == \"context\":\n            return \"resolve\"\n        return f\"{target}.resolve\"\n\n    def derive_context(self, frame: Frame) -> str:\n        return f\"{self.get_context_ref()}.derived({self.dump_local_context(frame)})\"\n\n    def parameter_is_undeclared(self, target: str) -> bool:\n        \"\"\"Checks if a given target is an undeclared parameter.\"\"\"\n        if not self._param_def_block:\n            return False\n        return target in self._param_def_block[-1]\n\n    def push_assign_tracking(self) -> None:\n        \"\"\"Pushes a new layer for assignment tracking.\"\"\"\n        self._assign_stack.append(set())\n\n    def pop_assign_tracking(self, frame: Frame) -> None:\n        \"\"\"Pops the topmost level for assignment tracking and updates the\n        context variables if necessary.\n        \"\"\"\n        vars = self._assign_stack.pop()\n        if (\n            not frame.block_frame\n            and not frame.loop_frame\n            and not frame.toplevel\n            or not vars\n        ):\n            return\n        public_names = [x for x in vars if x[:1] != \"_\"]\n        if len(vars) == 1:\n            name = next(iter(vars))\n            ref = frame.symbols.ref(name)\n            if frame.loop_frame:\n                self.writeline(f\"_loop_vars[{name!r}] = {ref}\")\n                return\n            if frame.block_frame:\n                self.writeline(f\"_block_vars[{name!r}] = {ref}\")\n                return\n            self.writeline(f\"context.vars[{name!r}] = {ref}\")\n        else:\n            if frame.loop_frame:\n                self.writeline(\"_loop_vars.update({\")\n            elif frame.block_frame:\n                self.writeline(\"_block_vars.update({\")\n            else:\n                self.writeline(\"context.vars.update({\")\n            for idx, name in enumerate(vars):\n                if idx:\n                    self.write(\", \")\n                ref = frame.symbols.ref(name)\n                self.write(f\"{name!r}: {ref}\")\n            self.write(\"})\")\n        if not frame.block_frame and not frame.loop_frame and public_names:\n            if len(public_names) == 1:\n                self.writeline(f\"context.exported_vars.add({public_names[0]!r})\")\n            else:\n                names_str = \", \".join(map(repr, public_names))\n                self.writeline(f\"context.exported_vars.update(({names_str}))\")\n\n    # -- Statement Visitors\n\n    def visit_Template(\n        self, node: nodes.Template, frame: t.Optional[Frame] = None\n    ) -> None:\n        assert frame is None, \"no root frame allowed\"\n        eval_ctx = EvalContext(self.environment, self.name)\n\n        from .runtime import async_exported\n        from .runtime import exported\n\n        if self.environment.is_async:\n            exported_names = sorted(exported + async_exported)\n        else:\n            exported_names = sorted(exported)\n\n        self.writeline(\"from jinja2.runtime import \" + \", \".join(exported_names))\n\n        # if we want a deferred initialization we cannot move the\n        # environment into a local name\n        envenv = \"\" if self.defer_init else \", environment=environment\"\n\n        # do we have an extends tag at all?  If not, we can save some\n        # overhead by just not processing any inheritance code.\n        have_extends = node.find(nodes.Extends) is not None\n\n        # find all blocks\n        for block in node.find_all(nodes.Block):\n            if block.name in self.blocks:\n                self.fail(f\"block {block.name!r} defined twice\", block.lineno)\n            self.blocks[block.name] = block\n\n        # find all imports and import them\n        for import_ in node.find_all(nodes.ImportedName):\n            if import_.importname not in self.import_aliases:\n                imp = import_.importname\n                self.import_aliases[imp] = alias = self.temporary_identifier()\n                if \".\" in imp:\n                    module, obj = imp.rsplit(\".\", 1)\n                    self.writeline(f\"from {module} import {obj} as {alias}\")\n                else:\n                    self.writeline(f\"import {imp} as {alias}\")\n\n        # add the load name\n        self.writeline(f\"name = {self.name!r}\")\n\n        # generate the root render function.\n        self.writeline(\n            f\"{self.func('root')}(context, missing=missing{envenv}):\", extra=1\n        )\n        self.indent()\n        self.write_commons()\n\n        # process the root\n        frame = Frame(eval_ctx)\n        if \"self\" in find_undeclared(node.body, (\"self\",)):\n            ref = frame.symbols.declare_parameter(\"self\")\n            self.writeline(f\"{ref} = TemplateReference(context)\")\n        frame.symbols.analyze_node(node)\n        frame.toplevel = frame.rootlevel = True\n        frame.require_output_check = have_extends and not self.has_known_extends\n        if have_extends:\n            self.writeline(\"parent_template = None\")\n        self.enter_frame(frame)\n        self.pull_dependencies(node.body)\n        self.blockvisit(node.body, frame)\n        self.leave_frame(frame, with_python_scope=True)\n        self.outdent()\n\n        # make sure that the parent root is called.\n        if have_extends:\n            if not self.has_known_extends:\n                self.indent()\n                self.writeline(\"if parent_template is not None:\")\n            self.indent()\n            if not self.environment.is_async:\n                self.writeline(\"yield from parent_template.root_render_func(context)\")\n            else:\n                self.writeline(\"agen = parent_template.root_render_func(context)\")\n                self.writeline(\"try:\")\n                self.indent()\n                self.writeline(\"async for event in agen:\")\n                self.indent()\n                self.writeline(\"yield event\")\n                self.outdent()\n                self.outdent()\n                self.writeline(\"finally: await agen.aclose()\")\n            self.outdent(1 + (not self.has_known_extends))\n\n        # at this point we now have the blocks collected and can visit them too.\n        for name, block in self.blocks.items():\n            self.writeline(\n                f\"{self.func('block_' + name)}(context, missing=missing{envenv}):\",\n                block,\n                1,\n            )\n            self.indent()\n            self.write_commons()\n            # It's important that we do not make this frame a child of the\n            # toplevel template.  This would cause a variety of\n            # interesting issues with identifier tracking.\n            block_frame = Frame(eval_ctx)\n            block_frame.block_frame = True\n            undeclared = find_undeclared(block.body, (\"self\", \"super\"))\n            if \"self\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"self\")\n                self.writeline(f\"{ref} = TemplateReference(context)\")\n            if \"super\" in undeclared:\n                ref = block_frame.symbols.declare_parameter(\"super\")\n                self.writeline(f\"{ref} = context.super({name!r}, block_{name})\")\n            block_frame.symbols.analyze_node(block)\n            block_frame.block = name\n            self.writeline(\"_block_vars = {}\")\n            self.enter_frame(block_frame)\n            self.pull_dependencies(block.body)\n            self.blockvisit(block.body, block_frame)\n            self.leave_frame(block_frame, with_python_scope=True)\n            self.outdent()\n\n        blocks_kv_str = \", \".join(f\"{x!r}: block_{x}\" for x in self.blocks)\n        self.writeline(f\"blocks = {{{blocks_kv_str}}}\", extra=1)\n        debug_kv_str = \"&\".join(f\"{k}={v}\" for k, v in self.debug_info)\n        self.writeline(f\"debug_info = {debug_kv_str!r}\")\n\n    def visit_Block(self, node: nodes.Block, frame: Frame) -> None:\n        \"\"\"Call a block and register it for the template.\"\"\"\n        level = 0\n        if frame.toplevel:\n            # if we know that we are a child template, there is no need to\n            # check if we are one\n            if self.has_known_extends:\n                return\n            if self.extends_so_far > 0:\n                self.writeline(\"if parent_template is None:\")\n                self.indent()\n                level += 1\n\n        if node.scoped:\n            context = self.derive_context(frame)\n        else:\n            context = self.get_context_ref()\n\n        if node.required:\n            self.writeline(f\"if len(context.blocks[{node.name!r}]) <= 1:\", node)\n            self.indent()\n            self.writeline(\n                f'raise TemplateRuntimeError(\"Required block {node.name!r} not found\")',\n                node,\n            )\n            self.outdent()\n\n        if not self.environment.is_async and frame.buffer is None:\n            self.writeline(\n                f\"yield from context.blocks[{node.name!r}][0]({context})\", node\n            )\n        else:\n            self.writeline(f\"gen = context.blocks[{node.name!r}][0]({context})\")\n            self.writeline(\"try:\")\n            self.indent()\n            self.writeline(\n                f\"{self.choose_async()}for event in gen:\",\n                node,\n            )\n            self.indent()\n            self.simple_write(\"event\", frame)\n            self.outdent()\n            self.outdent()\n            self.writeline(\n                f\"finally: {self.choose_async('await gen.aclose()', 'gen.close()')}\"\n            )\n\n        self.outdent(level)\n\n    def visit_Extends(self, node: nodes.Extends, frame: Frame) -> None:\n        \"\"\"Calls the extender.\"\"\"\n        if not frame.toplevel:\n            self.fail(\"cannot use extend from a non top-level scope\", node.lineno)\n\n        # if the number of extends statements in general is zero so\n        # far, we don't have to add a check if something extended\n        # the template before this one.\n        if self.extends_so_far > 0:\n            # if we have a known extends we just add a template runtime\n            # error into the generated code.  We could catch that at compile\n            # time too, but i welcome it not to confuse users by throwing the\n            # same error at different times just \"because we can\".\n            if not self.has_known_extends:\n                self.writeline(\"if parent_template is not None:\")\n                self.indent()\n            self.writeline('raise TemplateRuntimeError(\"extended multiple times\")')\n\n            # if we have a known extends already we don't need that code here\n            # as we know that the template execution will end here.\n            if self.has_known_extends:\n                raise CompilerExit()\n            else:\n                self.outdent()\n\n        self.writeline(\"parent_template = environment.get_template(\", node)\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r})\")\n        self.writeline(\"for name, parent_block in parent_template.blocks.items():\")\n        self.indent()\n        self.writeline(\"context.blocks.setdefault(name, []).append(parent_block)\")\n        self.outdent()\n\n        # if this extends statement was in the root level we can take\n        # advantage of that information and simplify the generated code\n        # in the top level from this point onwards\n        if frame.rootlevel:\n            self.has_known_extends = True\n\n        # and now we have one more\n        self.extends_so_far += 1\n\n    def visit_Include(self, node: nodes.Include, frame: Frame) -> None:\n        \"\"\"Handles includes.\"\"\"\n        if node.ignore_missing:\n            self.writeline(\"try:\")\n            self.indent()\n\n        func_name = \"get_or_select_template\"\n        if isinstance(node.template, nodes.Const):\n            if isinstance(node.template.value, str):\n                func_name = \"get_template\"\n            elif isinstance(node.template.value, (tuple, list)):\n                func_name = \"select_template\"\n        elif isinstance(node.template, (nodes.Tuple, nodes.List)):\n            func_name = \"select_template\"\n\n        self.writeline(f\"template = environment.{func_name}(\", node)\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r})\")\n        if node.ignore_missing:\n            self.outdent()\n            self.writeline(\"except TemplateNotFound:\")\n            self.indent()\n            self.writeline(\"pass\")\n            self.outdent()\n            self.writeline(\"else:\")\n            self.indent()\n\n        def loop_body() -> None:\n            self.indent()\n            self.simple_write(\"event\", frame)\n            self.outdent()\n\n        if node.with_context:\n            self.writeline(\n                f\"gen = template.root_render_func(\"\n                \"template.new_context(context.get_all(), True,\"\n                f\" {self.dump_local_context(frame)}))\"\n            )\n            self.writeline(\"try:\")\n            self.indent()\n            self.writeline(f\"{self.choose_async()}for event in gen:\")\n            loop_body()\n            self.outdent()\n            self.writeline(\n                f\"finally: {self.choose_async('await gen.aclose()', 'gen.close()')}\"\n            )\n        elif self.environment.is_async:\n            self.writeline(\n                \"for event in (await template._get_default_module_async())\"\n                \"._body_stream:\"\n            )\n            loop_body()\n        else:\n            self.writeline(\"yield from template._get_default_module()._body_stream\")\n\n        if node.ignore_missing:\n            self.outdent()\n\n    def _import_common(\n        self, node: t.Union[nodes.Import, nodes.FromImport], frame: Frame\n    ) -> None:\n        self.write(f\"{self.choose_async('await ')}environment.get_template(\")\n        self.visit(node.template, frame)\n        self.write(f\", {self.name!r}).\")\n\n        if node.with_context:\n            f_name = f\"make_module{self.choose_async('_async')}\"\n            self.write(\n                f\"{f_name}(context.get_all(), True, {self.dump_local_context(frame)})\"\n            )\n        else:\n            self.write(f\"_get_default_module{self.choose_async('_async')}(context)\")\n\n    def visit_Import(self, node: nodes.Import, frame: Frame) -> None:\n        \"\"\"Visit regular imports.\"\"\"\n        self.writeline(f\"{frame.symbols.ref(node.target)} = \", node)\n        if frame.toplevel:\n            self.write(f\"context.vars[{node.target!r}] = \")\n\n        self._import_common(node, frame)\n\n        if frame.toplevel and not node.target.startswith(\"_\"):\n            self.writeline(f\"context.exported_vars.discard({node.target!r})\")\n\n    def visit_FromImport(self, node: nodes.FromImport, frame: Frame) -> None:\n        \"\"\"Visit named imports.\"\"\"\n        self.newline(node)\n        self.write(\"included_template = \")\n        self._import_common(node, frame)\n        var_names = []\n        discarded_names = []\n        for name in node.names:\n            if isinstance(name, tuple):\n                name, alias = name\n            else:\n                alias = name\n            self.writeline(\n                f\"{frame.symbols.ref(alias)} =\"\n                f\" getattr(included_template, {name!r}, missing)\"\n            )\n            self.writeline(f\"if {frame.symbols.ref(alias)} is missing:\")\n            self.indent()\n            message = (\n                \"the template {included_template.__name__!r}\"\n                f\" (imported on {self.position(node)})\"\n                f\" does not export the requested name {name!r}\"\n            )\n            self.writeline(\n                f\"{frame.symbols.ref(alias)} = undefined(f{message!r}, name={name!r})\"\n            )\n            self.outdent()\n            if frame.toplevel:\n                var_names.append(alias)\n                if not alias.startswith(\"_\"):\n                    discarded_names.append(alias)\n\n        if var_names:\n            if len(var_names) == 1:\n                name = var_names[0]\n                self.writeline(f\"context.vars[{name!r}] = {frame.symbols.ref(name)}\")\n            else:\n                names_kv = \", \".join(\n                    f\"{name!r}: {frame.symbols.ref(name)}\" for name in var_names\n                )\n                self.writeline(f\"context.vars.update({{{names_kv}}})\")\n        if discarded_names:\n            if len(discarded_names) == 1:\n                self.writeline(f\"context.exported_vars.discard({discarded_names[0]!r})\")\n            else:\n                names_str = \", \".join(map(repr, discarded_names))\n                self.writeline(\n                    f\"context.exported_vars.difference_update(({names_str}))\"\n                )\n\n    def visit_For(self, node: nodes.For, frame: Frame) -> None:\n        loop_frame = frame.inner()\n        loop_frame.loop_frame = True\n        test_frame = frame.inner()\n        else_frame = frame.inner()\n\n        # try to figure out if we have an extended loop.  An extended loop\n        # is necessary if the loop is in recursive mode if the special loop\n        # variable is accessed in the body if the body is a scoped block.\n        extended_loop = (\n            node.recursive\n            or \"loop\"\n            in find_undeclared(node.iter_child_nodes(only=(\"body\",)), (\"loop\",))\n            or any(block.scoped for block in node.find_all(nodes.Block))\n        )\n\n        loop_ref = None\n        if extended_loop:\n            loop_ref = loop_frame.symbols.declare_parameter(\"loop\")\n\n        loop_frame.symbols.analyze_node(node, for_branch=\"body\")\n        if node.else_:\n            else_frame.symbols.analyze_node(node, for_branch=\"else\")\n\n        if node.test:\n            loop_filter_func = self.temporary_identifier()\n            test_frame.symbols.analyze_node(node, for_branch=\"test\")\n            self.writeline(f\"{self.func(loop_filter_func)}(fiter):\", node.test)\n            self.indent()\n            self.enter_frame(test_frame)\n            self.writeline(self.choose_async(\"async for \", \"for \"))\n            self.visit(node.target, loop_frame)\n            self.write(\" in \")\n            self.write(self.choose_async(\"auto_aiter(fiter)\", \"fiter\"))\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"if \", node.test)\n            self.visit(node.test, test_frame)\n            self.write(\":\")\n            self.indent()\n            self.writeline(\"yield \")\n            self.visit(node.target, loop_frame)\n            self.outdent(3)\n            self.leave_frame(test_frame, with_python_scope=True)\n\n        # if we don't have an recursive loop we have to find the shadowed\n        # variables at that point.  Because loops can be nested but the loop\n        # variable is a special one we have to enforce aliasing for it.\n        if node.recursive:\n            self.writeline(\n                f\"{self.func('loop')}(reciter, loop_render_func, depth=0):\", node\n            )\n            self.indent()\n            self.buffer(loop_frame)\n\n            # Use the same buffer for the else frame\n            else_frame.buffer = loop_frame.buffer\n\n        # make sure the loop variable is a special one and raise a template\n        # assertion error if a loop tries to write to loop\n        if extended_loop:\n            self.writeline(f\"{loop_ref} = missing\")\n\n        for name in node.find_all(nodes.Name):\n            if name.ctx == \"store\" and name.name == \"loop\":\n                self.fail(\n                    \"Can't assign to special loop variable in for-loop target\",\n                    name.lineno,\n                )\n\n        if node.else_:\n            iteration_indicator = self.temporary_identifier()\n            self.writeline(f\"{iteration_indicator} = 1\")\n\n        self.writeline(self.choose_async(\"async for \", \"for \"), node)\n        self.visit(node.target, loop_frame)\n        if extended_loop:\n            self.write(f\", {loop_ref} in {self.choose_async('Async')}LoopContext(\")\n        else:\n            self.write(\" in \")\n\n        if node.test:\n            self.write(f\"{loop_filter_func}(\")\n        if node.recursive:\n            self.write(\"reciter\")\n        else:\n            if self.environment.is_async and not extended_loop:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async and not extended_loop:\n                self.write(\")\")\n        if node.test:\n            self.write(\")\")\n\n        if node.recursive:\n            self.write(\", undefined, loop_render_func, depth):\")\n        else:\n            self.write(\", undefined):\" if extended_loop else \":\")\n\n        self.indent()\n        self.enter_frame(loop_frame)\n\n        self.writeline(\"_loop_vars = {}\")\n        self.blockvisit(node.body, loop_frame)\n        if node.else_:\n            self.writeline(f\"{iteration_indicator} = 0\")\n        self.outdent()\n        self.leave_frame(\n            loop_frame, with_python_scope=node.recursive and not node.else_\n        )\n\n        if node.else_:\n            self.writeline(f\"if {iteration_indicator}:\")\n            self.indent()\n            self.enter_frame(else_frame)\n            self.blockvisit(node.else_, else_frame)\n            self.leave_frame(else_frame)\n            self.outdent()\n\n        # if the node was recursive we have to return the buffer contents\n        # and start the iteration code\n        if node.recursive:\n            self.return_buffer_contents(loop_frame)\n            self.outdent()\n            self.start_write(frame, node)\n            self.write(f\"{self.choose_async('await ')}loop(\")\n            if self.environment.is_async:\n                self.write(\"auto_aiter(\")\n            self.visit(node.iter, frame)\n            if self.environment.is_async:\n                self.write(\")\")\n            self.write(\", loop)\")\n            self.end_write(frame)\n\n        # at the end of the iteration, clear any assignments made in the\n        # loop from the top level\n        if self._assign_stack:\n            self._assign_stack[-1].difference_update(loop_frame.symbols.stores)\n\n    def visit_If(self, node: nodes.If, frame: Frame) -> None:\n        if_frame = frame.soft()\n        self.writeline(\"if \", node)\n        self.visit(node.test, if_frame)\n        self.write(\":\")\n        self.indent()\n        self.blockvisit(node.body, if_frame)\n        self.outdent()\n        for elif_ in node.elif_:\n            self.writeline(\"elif \", elif_)\n            self.visit(elif_.test, if_frame)\n            self.write(\":\")\n            self.indent()\n            self.blockvisit(elif_.body, if_frame)\n            self.outdent()\n        if node.else_:\n            self.writeline(\"else:\")\n            self.indent()\n            self.blockvisit(node.else_, if_frame)\n            self.outdent()\n\n    def visit_Macro(self, node: nodes.Macro, frame: Frame) -> None:\n        macro_frame, macro_ref = self.macro_body(node, frame)\n        self.newline()\n        if frame.toplevel:\n            if not node.name.startswith(\"_\"):\n                self.write(f\"context.exported_vars.add({node.name!r})\")\n            self.writeline(f\"context.vars[{node.name!r}] = \")\n        self.write(f\"{frame.symbols.ref(node.name)} = \")\n        self.macro_def(macro_ref, macro_frame)\n\n    def visit_CallBlock(self, node: nodes.CallBlock, frame: Frame) -> None:\n        call_frame, macro_ref = self.macro_body(node, frame)\n        self.writeline(\"caller = \")\n        self.macro_def(macro_ref, call_frame)\n        self.start_write(frame, node)\n        self.visit_Call(node.call, frame, forward_caller=True)\n        self.end_write(frame)\n\n    def visit_FilterBlock(self, node: nodes.FilterBlock, frame: Frame) -> None:\n        filter_frame = frame.inner()\n        filter_frame.symbols.analyze_node(node)\n        self.enter_frame(filter_frame)\n        self.buffer(filter_frame)\n        self.blockvisit(node.body, filter_frame)\n        self.start_write(frame, node)\n        self.visit_Filter(node.filter, filter_frame)\n        self.end_write(frame)\n        self.leave_frame(filter_frame)\n\n    def visit_With(self, node: nodes.With, frame: Frame) -> None:\n        with_frame = frame.inner()\n        with_frame.symbols.analyze_node(node)\n        self.enter_frame(with_frame)\n        for target, expr in zip(node.targets, node.values):\n            self.newline()\n            self.visit(target, with_frame)\n            self.write(\" = \")\n            self.visit(expr, frame)\n        self.blockvisit(node.body, with_frame)\n        self.leave_frame(with_frame)\n\n    def visit_ExprStmt(self, node: nodes.ExprStmt, frame: Frame) -> None:\n        self.newline(node)\n        self.visit(node.node, frame)\n\n    class _FinalizeInfo(t.NamedTuple):\n        const: t.Optional[t.Callable[..., str]]\n        src: t.Optional[str]\n\n    @staticmethod\n    def _default_finalize(value: t.Any) -> t.Any:\n        \"\"\"The default finalize function if the environment isn't\n        configured with one. Or, if the environment has one, this is\n        called on that function's output for constants.\n        \"\"\"\n        return str(value)\n\n    _finalize: t.Optional[_FinalizeInfo] = None\n\n    def _make_finalize(self) -> _FinalizeInfo:\n        \"\"\"Build the finalize function to be used on constants and at\n        runtime. Cached so it's only created once for all output nodes.\n\n        Returns a ``namedtuple`` with the following attributes:\n\n        ``const``\n            A function to finalize constant data at compile time.\n\n        ``src``\n            Source code to output around nodes to be evaluated at\n            runtime.\n        \"\"\"\n        if self._finalize is not None:\n            return self._finalize\n\n        finalize: t.Optional[t.Callable[..., t.Any]]\n        finalize = default = self._default_finalize\n        src = None\n\n        if self.environment.finalize:\n            src = \"environment.finalize(\"\n            env_finalize = self.environment.finalize\n            pass_arg = {\n                _PassArg.context: \"context\",\n                _PassArg.eval_context: \"context.eval_ctx\",\n                _PassArg.environment: \"environment\",\n            }.get(\n                _PassArg.from_obj(env_finalize)  # type: ignore\n            )\n            finalize = None\n\n            if pass_arg is None:\n\n                def finalize(value: t.Any) -> t.Any:  # noqa: F811\n                    return default(env_finalize(value))\n\n            else:\n                src = f\"{src}{pass_arg}, \"\n\n                if pass_arg == \"environment\":\n\n                    def finalize(value: t.Any) -> t.Any:  # noqa: F811\n                        return default(env_finalize(self.environment, value))\n\n        self._finalize = self._FinalizeInfo(finalize, src)\n        return self._finalize\n\n    def _output_const_repr(self, group: t.Iterable[t.Any]) -> str:\n        \"\"\"Given a group of constant values converted from ``Output``\n        child nodes, produce a string to write to the template module\n        source.\n        \"\"\"\n        return repr(concat(group))\n\n    def _output_child_to_const(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> str:\n        \"\"\"Try to optimize a child of an ``Output`` node by trying to\n        convert it to constant, finalized data at compile time.\n\n        If :exc:`Impossible` is raised, the node is not constant and\n        will be evaluated at runtime. Any other exception will also be\n        evaluated at runtime for easier debugging.\n        \"\"\"\n        const = node.as_const(frame.eval_ctx)\n\n        if frame.eval_ctx.autoescape:\n            const = escape(const)\n\n        # Template data doesn't go through finalize.\n        if isinstance(node, nodes.TemplateData):\n            return str(const)\n\n        return finalize.const(const)  # type: ignore\n\n    def _output_child_pre(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> None:\n        \"\"\"Output extra source code before visiting a child of an\n        ``Output`` node.\n        \"\"\"\n        if frame.eval_ctx.volatile:\n            self.write(\"(escape if context.eval_ctx.autoescape else str)(\")\n        elif frame.eval_ctx.autoescape:\n            self.write(\"escape(\")\n        else:\n            self.write(\"str(\")\n\n        if finalize.src is not None:\n            self.write(finalize.src)\n\n    def _output_child_post(\n        self, node: nodes.Expr, frame: Frame, finalize: _FinalizeInfo\n    ) -> None:\n        \"\"\"Output extra source code after visiting a child of an\n        ``Output`` node.\n        \"\"\"\n        self.write(\")\")\n\n        if finalize.src is not None:\n            self.write(\")\")\n\n    def visit_Output(self, node: nodes.Output, frame: Frame) -> None:\n        # If an extends is active, don't render outside a block.\n        if frame.require_output_check:\n            # A top-level extends is known to exist at compile time.\n            if self.has_known_extends:\n                return\n\n            self.writeline(\"if parent_template is None:\")\n            self.indent()\n\n        finalize = self._make_finalize()\n        body: t.List[t.Union[t.List[t.Any], nodes.Expr]] = []\n\n        # Evaluate constants at compile time if possible. Each item in\n        # body will be either a list of static data or a node to be\n        # evaluated at runtime.\n        for child in node.nodes:\n            try:\n                if not (\n                    # If the finalize function requires runtime context,\n                    # constants can't be evaluated at compile time.\n                    finalize.const\n                    # Unless it's basic template data that won't be\n                    # finalized anyway.\n                    or isinstance(child, nodes.TemplateData)\n                ):\n                    raise nodes.Impossible()\n\n                const = self._output_child_to_const(child, frame, finalize)\n            except (nodes.Impossible, Exception):\n                # The node was not constant and needs to be evaluated at\n                # runtime. Or another error was raised, which is easier\n                # to debug at runtime.\n                body.append(child)\n                continue\n\n            if body and isinstance(body[-1], list):\n                body[-1].append(const)\n            else:\n                body.append([const])\n\n        if frame.buffer is not None:\n            if len(body) == 1:\n                self.writeline(f\"{frame.buffer}.append(\")\n            else:\n                self.writeline(f\"{frame.buffer}.extend((\")\n\n            self.indent()\n\n        for item in body:\n            if isinstance(item, list):\n                # A group of constant data to join and output.\n                val = self._output_const_repr(item)\n\n                if frame.buffer is None:\n                    self.writeline(\"yield \" + val)\n                else:\n                    self.writeline(val + \",\")\n            else:\n                if frame.buffer is None:\n                    self.writeline(\"yield \", item)\n                else:\n                    self.newline(item)\n\n                # A node to be evaluated at runtime.\n                self._output_child_pre(item, frame, finalize)\n                self.visit(item, frame)\n                self._output_child_post(item, frame, finalize)\n\n                if frame.buffer is not None:\n                    self.write(\",\")\n\n        if frame.buffer is not None:\n            self.outdent()\n            self.writeline(\")\" if len(body) == 1 else \"))\")\n\n        if frame.require_output_check:\n            self.outdent()\n\n    def visit_Assign(self, node: nodes.Assign, frame: Frame) -> None:\n        self.push_assign_tracking()\n        self.newline(node)\n        self.visit(node.target, frame)\n        self.write(\" = \")\n        self.visit(node.node, frame)\n        self.pop_assign_tracking(frame)\n\n    def visit_AssignBlock(self, node: nodes.AssignBlock, frame: Frame) -> None:\n        self.push_assign_tracking()\n        block_frame = frame.inner()\n        # This is a special case.  Since a set block always captures we\n        # will disable output checks.  This way one can use set blocks\n        # toplevel even in extended templates.\n        block_frame.require_output_check = False\n        block_frame.symbols.analyze_node(node)\n        self.enter_frame(block_frame)\n        self.buffer(block_frame)\n        self.blockvisit(node.body, block_frame)\n        self.newline(node)\n        self.visit(node.target, frame)\n        self.write(\" = (Markup if context.eval_ctx.autoescape else identity)(\")\n        if node.filter is not None:\n            self.visit_Filter(node.filter, block_frame)\n        else:\n            self.write(f\"concat({block_frame.buffer})\")\n        self.write(\")\")\n        self.pop_assign_tracking(frame)\n        self.leave_frame(block_frame)\n\n    # -- Expression Visitors\n\n    def visit_Name(self, node: nodes.Name, frame: Frame) -> None:\n        if node.ctx == \"store\" and (\n            frame.toplevel or frame.loop_frame or frame.block_frame\n        ):\n            if self._assign_stack:\n                self._assign_stack[-1].add(node.name)\n        ref = frame.symbols.ref(node.name)\n\n        # If we are looking up a variable we might have to deal with the\n        # case where it's undefined.  We can skip that case if the load\n        # instruction indicates a parameter which are always defined.\n        if node.ctx == \"load\":\n            load = frame.symbols.find_load(ref)\n            if not (\n                load is not None\n                and load[0] == VAR_LOAD_PARAMETER\n                and not self.parameter_is_undeclared(ref)\n            ):\n                self.write(\n                    f\"(undefined(name={node.name!r}) if {ref} is missing else {ref})\"\n                )\n                return\n\n        self.write(ref)\n\n    def visit_NSRef(self, node: nodes.NSRef, frame: Frame) -> None:\n        # NSRefs can only be used to store values; since they use the normal\n        # `foo.bar` notation they will be parsed as a normal attribute access\n        # when used anywhere but in a `set` context\n        ref = frame.symbols.ref(node.name)\n        self.writeline(f\"if not isinstance({ref}, Namespace):\")\n        self.indent()\n        self.writeline(\n            \"raise TemplateRuntimeError\"\n            '(\"cannot assign attribute on non-namespace object\")'\n        )\n        self.outdent()\n        self.writeline(f\"{ref}[{node.attr!r}]\")\n\n    def visit_Const(self, node: nodes.Const, frame: Frame) -> None:\n        val = node.as_const(frame.eval_ctx)\n        if isinstance(val, float):\n            self.write(str(val))\n        else:\n            self.write(repr(val))\n\n    def visit_TemplateData(self, node: nodes.TemplateData, frame: Frame) -> None:\n        try:\n            self.write(repr(node.as_const(frame.eval_ctx)))\n        except nodes.Impossible:\n            self.write(\n                f\"(Markup if context.eval_ctx.autoescape else identity)({node.data!r})\"\n            )\n\n    def visit_Tuple(self, node: nodes.Tuple, frame: Frame) -> None:\n        self.write(\"(\")\n        idx = -1\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item, frame)\n        self.write(\",)\" if idx == 0 else \")\")\n\n    def visit_List(self, node: nodes.List, frame: Frame) -> None:\n        self.write(\"[\")\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item, frame)\n        self.write(\"]\")\n\n    def visit_Dict(self, node: nodes.Dict, frame: Frame) -> None:\n        self.write(\"{\")\n        for idx, item in enumerate(node.items):\n            if idx:\n                self.write(\", \")\n            self.visit(item.key, frame)\n            self.write(\": \")\n            self.visit(item.value, frame)\n        self.write(\"}\")\n\n    visit_Add = _make_binop(\"+\")\n    visit_Sub = _make_binop(\"-\")\n    visit_Mul = _make_binop(\"*\")\n    visit_Div = _make_binop(\"/\")\n    visit_FloorDiv = _make_binop(\"//\")\n    visit_Pow = _make_binop(\"**\")\n    visit_Mod = _make_binop(\"%\")\n    visit_And = _make_binop(\"and\")\n    visit_Or = _make_binop(\"or\")\n    visit_Pos = _make_unop(\"+\")\n    visit_Neg = _make_unop(\"-\")\n    visit_Not = _make_unop(\"not \")\n\n    @optimizeconst\n    def visit_Concat(self, node: nodes.Concat, frame: Frame) -> None:\n        if frame.eval_ctx.volatile:\n            func_name = \"(markup_join if context.eval_ctx.volatile else str_join)\"\n        elif frame.eval_ctx.autoescape:\n            func_name = \"markup_join\"\n        else:\n            func_name = \"str_join\"\n        self.write(f\"{func_name}((\")\n        for arg in node.nodes:\n            self.visit(arg, frame)\n            self.write(\", \")\n        self.write(\"))\")\n\n    @optimizeconst\n    def visit_Compare(self, node: nodes.Compare, frame: Frame) -> None:\n        self.write(\"(\")\n        self.visit(node.expr, frame)\n        for op in node.ops:\n            self.visit(op, frame)\n        self.write(\")\")\n\n    def visit_Operand(self, node: nodes.Operand, frame: Frame) -> None:\n        self.write(f\" {operators[node.op]} \")\n        self.visit(node.expr, frame)\n\n    @optimizeconst\n    def visit_Getattr(self, node: nodes.Getattr, frame: Frame) -> None:\n        if self.environment.is_async:\n            self.write(\"(await auto_await(\")\n\n        self.write(\"environment.getattr(\")\n        self.visit(node.node, frame)\n        self.write(f\", {node.attr!r})\")\n\n        if self.environment.is_async:\n            self.write(\"))\")\n\n    @optimizeconst\n    def visit_Getitem(self, node: nodes.Getitem, frame: Frame) -> None:\n        # slices bypass the environment getitem method.\n        if isinstance(node.arg, nodes.Slice):\n            self.visit(node.node, frame)\n            self.write(\"[\")\n            self.visit(node.arg, frame)\n            self.write(\"]\")\n        else:\n            if self.environment.is_async:\n                self.write(\"(await auto_await(\")\n\n            self.write(\"environment.getitem(\")\n            self.visit(node.node, frame)\n            self.write(\", \")\n            self.visit(node.arg, frame)\n            self.write(\")\")\n\n            if self.environment.is_async:\n                self.write(\"))\")\n\n    def visit_Slice(self, node: nodes.Slice, frame: Frame) -> None:\n        if node.start is not None:\n            self.visit(node.start, frame)\n        self.write(\":\")\n        if node.stop is not None:\n            self.visit(node.stop, frame)\n        if node.step is not None:\n            self.write(\":\")\n            self.visit(node.step, frame)\n\n    @contextmanager\n    def _filter_test_common(\n        self, node: t.Union[nodes.Filter, nodes.Test], frame: Frame, is_filter: bool\n    ) -> t.Iterator[None]:\n        if self.environment.is_async:\n            self.write(\"(await auto_await(\")\n\n        if is_filter:\n            self.write(f\"{self.filters[node.name]}(\")\n            func = self.environment.filters.get(node.name)\n        else:\n            self.write(f\"{self.tests[node.name]}(\")\n            func = self.environment.tests.get(node.name)\n\n        # When inside an If or CondExpr frame, allow the filter to be\n        # undefined at compile time and only raise an error if it's\n        # actually called at runtime. See pull_dependencies.\n        if func is None and not frame.soft_frame:\n            type_name = \"filter\" if is_filter else \"test\"\n            self.fail(f\"No {type_name} named {node.name!r}.\", node.lineno)\n\n        pass_arg = {\n            _PassArg.context: \"context\",\n            _PassArg.eval_context: \"context.eval_ctx\",\n            _PassArg.environment: \"environment\",\n        }.get(\n            _PassArg.from_obj(func)  # type: ignore\n        )\n\n        if pass_arg is not None:\n            self.write(f\"{pass_arg}, \")\n\n        # Back to the visitor function to handle visiting the target of\n        # the filter or test.\n        yield\n\n        self.signature(node, frame)\n        self.write(\")\")\n\n        if self.environment.is_async:\n            self.write(\"))\")\n\n    @optimizeconst\n    def visit_Filter(self, node: nodes.Filter, frame: Frame) -> None:\n        with self._filter_test_common(node, frame, True):\n            # if the filter node is None we are inside a filter block\n            # and want to write to the current buffer\n            if node.node is not None:\n                self.visit(node.node, frame)\n            elif frame.eval_ctx.volatile:\n                self.write(\n                    f\"(Markup(concat({frame.buffer}))\"\n                    f\" if context.eval_ctx.autoescape else concat({frame.buffer}))\"\n                )\n            elif frame.eval_ctx.autoescape:\n                self.write(f\"Markup(concat({frame.buffer}))\")\n            else:\n                self.write(f\"concat({frame.buffer})\")\n\n    @optimizeconst\n    def visit_Test(self, node: nodes.Test, frame: Frame) -> None:\n        with self._filter_test_common(node, frame, False):\n            self.visit(node.node, frame)\n\n    @optimizeconst\n    def visit_CondExpr(self, node: nodes.CondExpr, frame: Frame) -> None:\n        frame = frame.soft()\n\n        def write_expr2() -> None:\n            if node.expr2 is not None:\n                self.visit(node.expr2, frame)\n                return\n\n            self.write(\n                f'cond_expr_undefined(\"the inline if-expression on'\n                f\" {self.position(node)} evaluated to false and no else\"\n                f' section was defined.\")'\n            )\n\n        self.write(\"(\")\n        self.visit(node.expr1, frame)\n        self.write(\" if \")\n        self.visit(node.test, frame)\n        self.write(\" else \")\n        write_expr2()\n        self.write(\")\")\n\n    @optimizeconst\n    def visit_Call(\n        self, node: nodes.Call, frame: Frame, forward_caller: bool = False\n    ) -> None:\n        if self.environment.is_async:\n            self.write(\"(await auto_await(\")\n        if self.environment.sandboxed:\n            self.write(\"environment.call(context, \")\n        else:\n            self.write(\"context.call(\")\n        self.visit(node.node, frame)\n        extra_kwargs = {\"caller\": \"caller\"} if forward_caller else None\n        loop_kwargs = {\"_loop_vars\": \"_loop_vars\"} if frame.loop_frame else {}\n        block_kwargs = {\"_block_vars\": \"_block_vars\"} if frame.block_frame else {}\n        if extra_kwargs:\n            extra_kwargs.update(loop_kwargs, **block_kwargs)\n        elif loop_kwargs or block_kwargs:\n            extra_kwargs = dict(loop_kwargs, **block_kwargs)\n        self.signature(node, frame, extra_kwargs)\n        self.write(\")\")\n        if self.environment.is_async:\n            self.write(\"))\")\n\n    def visit_Keyword(self, node: nodes.Keyword, frame: Frame) -> None:\n        self.write(node.key + \"=\")\n        self.visit(node.value, frame)\n\n    # -- Unused nodes for extensions\n\n    def visit_MarkSafe(self, node: nodes.MarkSafe, frame: Frame) -> None:\n        self.write(\"Markup(\")\n        self.visit(node.expr, frame)\n        self.write(\")\")\n\n    def visit_MarkSafeIfAutoescape(\n        self, node: nodes.MarkSafeIfAutoescape, frame: Frame\n    ) -> None:\n        self.write(\"(Markup if context.eval_ctx.autoescape else identity)(\")\n        self.visit(node.expr, frame)\n        self.write(\")\")\n\n    def visit_EnvironmentAttribute(\n        self, node: nodes.EnvironmentAttribute, frame: Frame\n    ) -> None:\n        self.write(\"environment.\" + node.name)\n\n    def visit_ExtensionAttribute(\n        self, node: nodes.ExtensionAttribute, frame: Frame\n    ) -> None:\n        self.write(f\"environment.extensions[{node.identifier!r}].{node.name}\")\n\n    def visit_ImportedName(self, node: nodes.ImportedName, frame: Frame) -> None:\n        self.write(self.import_aliases[node.importname])\n\n    def visit_InternalName(self, node: nodes.InternalName, frame: Frame) -> None:\n        self.write(node.name)\n\n    def visit_ContextReference(\n        self, node: nodes.ContextReference, frame: Frame\n    ) -> None:\n        self.write(\"context\")\n\n    def visit_DerivedContextReference(\n        self, node: nodes.DerivedContextReference, frame: Frame\n    ) -> None:\n        self.write(self.derive_context(frame))\n\n    def visit_Continue(self, node: nodes.Continue, frame: Frame) -> None:\n        self.writeline(\"continue\", node)\n\n    def visit_Break(self, node: nodes.Break, frame: Frame) -> None:\n        self.writeline(\"break\", node)\n\n    def visit_Scope(self, node: nodes.Scope, frame: Frame) -> None:\n        scope_frame = frame.inner()\n        scope_frame.symbols.analyze_node(node)\n        self.enter_frame(scope_frame)\n        self.blockvisit(node.body, scope_frame)\n        self.leave_frame(scope_frame)\n\n    def visit_OverlayScope(self, node: nodes.OverlayScope, frame: Frame) -> None:\n        ctx = self.temporary_identifier()\n        self.writeline(f\"{ctx} = {self.derive_context(frame)}\")\n        self.writeline(f\"{ctx}.vars = \")\n        self.visit(node.context, frame)\n        self.push_context_reference(ctx)\n\n        scope_frame = frame.inner(isolated=True)\n        scope_frame.symbols.analyze_node(node)\n        self.enter_frame(scope_frame)\n        self.blockvisit(node.body, scope_frame)\n        self.leave_frame(scope_frame)\n        self.pop_context_reference()\n\n    def visit_EvalContextModifier(\n        self, node: nodes.EvalContextModifier, frame: Frame\n    ) -> None:\n        for keyword in node.options:\n            self.writeline(f\"context.eval_ctx.{keyword.key} = \")\n            self.visit(keyword.value, frame)\n            try:\n                val = keyword.value.as_const(frame.eval_ctx)\n            except nodes.Impossible:\n                frame.eval_ctx.volatile = True\n            else:\n                setattr(frame.eval_ctx, keyword.key, val)\n\n    def visit_ScopedEvalContextModifier(\n        self, node: nodes.ScopedEvalContextModifier, frame: Frame\n    ) -> None:\n        old_ctx_name = self.temporary_identifier()\n        saved_ctx = frame.eval_ctx.save()\n        self.writeline(f\"{old_ctx_name} = context.eval_ctx.save()\")\n        self.visit_EvalContextModifier(node, frame)\n        for child in node.body:\n            self.visit(child, frame)\n        frame.eval_ctx.revert(saved_ctx)\n        self.writeline(f\"context.eval_ctx.revert({old_ctx_name})\")\n", "src/jinja2/lexer.py": "\"\"\"Implements a Jinja / Python combination lexer. The ``Lexer`` class\nis used to do some preprocessing. It filters out invalid operators like\nthe bitshift operators we don't allow in templates. It separates\ntemplate code and python code in expressions.\n\"\"\"\n\nimport re\nimport typing as t\nfrom ast import literal_eval\nfrom collections import deque\nfrom sys import intern\n\nfrom ._identifier import pattern as name_re\nfrom .exceptions import TemplateSyntaxError\nfrom .utils import LRUCache\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .environment import Environment\n\n# cache for the lexers. Exists in order to be able to have multiple\n# environments with the same lexer\n_lexer_cache: t.MutableMapping[t.Tuple, \"Lexer\"] = LRUCache(50)  # type: ignore\n\n# static regular expressions\nwhitespace_re = re.compile(r\"\\s+\")\nnewline_re = re.compile(r\"(\\r\\n|\\r|\\n)\")\nstring_re = re.compile(\n    r\"('([^'\\\\]*(?:\\\\.[^'\\\\]*)*)'\" r'|\"([^\"\\\\]*(?:\\\\.[^\"\\\\]*)*)\")', re.S\n)\ninteger_re = re.compile(\n    r\"\"\"\n    (\n        0b(_?[0-1])+ # binary\n    |\n        0o(_?[0-7])+ # octal\n    |\n        0x(_?[\\da-f])+ # hex\n    |\n        [1-9](_?\\d)* # decimal\n    |\n        0(_?0)* # decimal zero\n    )\n    \"\"\",\n    re.IGNORECASE | re.VERBOSE,\n)\nfloat_re = re.compile(\n    r\"\"\"\n    (?<!\\.)  # doesn't start with a .\n    (\\d+_)*\\d+  # digits, possibly _ separated\n    (\n        (\\.(\\d+_)*\\d+)?  # optional fractional part\n        e[+\\-]?(\\d+_)*\\d+  # exponent part\n    |\n        \\.(\\d+_)*\\d+  # required fractional part\n    )\n    \"\"\",\n    re.IGNORECASE | re.VERBOSE,\n)\n\n# internal the tokens and keep references to them\nTOKEN_ADD = intern(\"add\")\nTOKEN_ASSIGN = intern(\"assign\")\nTOKEN_COLON = intern(\"colon\")\nTOKEN_COMMA = intern(\"comma\")\nTOKEN_DIV = intern(\"div\")\nTOKEN_DOT = intern(\"dot\")\nTOKEN_EQ = intern(\"eq\")\nTOKEN_FLOORDIV = intern(\"floordiv\")\nTOKEN_GT = intern(\"gt\")\nTOKEN_GTEQ = intern(\"gteq\")\nTOKEN_LBRACE = intern(\"lbrace\")\nTOKEN_LBRACKET = intern(\"lbracket\")\nTOKEN_LPAREN = intern(\"lparen\")\nTOKEN_LT = intern(\"lt\")\nTOKEN_LTEQ = intern(\"lteq\")\nTOKEN_MOD = intern(\"mod\")\nTOKEN_MUL = intern(\"mul\")\nTOKEN_NE = intern(\"ne\")\nTOKEN_PIPE = intern(\"pipe\")\nTOKEN_POW = intern(\"pow\")\nTOKEN_RBRACE = intern(\"rbrace\")\nTOKEN_RBRACKET = intern(\"rbracket\")\nTOKEN_RPAREN = intern(\"rparen\")\nTOKEN_SEMICOLON = intern(\"semicolon\")\nTOKEN_SUB = intern(\"sub\")\nTOKEN_TILDE = intern(\"tilde\")\nTOKEN_WHITESPACE = intern(\"whitespace\")\nTOKEN_FLOAT = intern(\"float\")\nTOKEN_INTEGER = intern(\"integer\")\nTOKEN_NAME = intern(\"name\")\nTOKEN_STRING = intern(\"string\")\nTOKEN_OPERATOR = intern(\"operator\")\nTOKEN_BLOCK_BEGIN = intern(\"block_begin\")\nTOKEN_BLOCK_END = intern(\"block_end\")\nTOKEN_VARIABLE_BEGIN = intern(\"variable_begin\")\nTOKEN_VARIABLE_END = intern(\"variable_end\")\nTOKEN_RAW_BEGIN = intern(\"raw_begin\")\nTOKEN_RAW_END = intern(\"raw_end\")\nTOKEN_COMMENT_BEGIN = intern(\"comment_begin\")\nTOKEN_COMMENT_END = intern(\"comment_end\")\nTOKEN_COMMENT = intern(\"comment\")\nTOKEN_LINESTATEMENT_BEGIN = intern(\"linestatement_begin\")\nTOKEN_LINESTATEMENT_END = intern(\"linestatement_end\")\nTOKEN_LINECOMMENT_BEGIN = intern(\"linecomment_begin\")\nTOKEN_LINECOMMENT_END = intern(\"linecomment_end\")\nTOKEN_LINECOMMENT = intern(\"linecomment\")\nTOKEN_DATA = intern(\"data\")\nTOKEN_INITIAL = intern(\"initial\")\nTOKEN_EOF = intern(\"eof\")\n\n# bind operators to token types\noperators = {\n    \"+\": TOKEN_ADD,\n    \"-\": TOKEN_SUB,\n    \"/\": TOKEN_DIV,\n    \"//\": TOKEN_FLOORDIV,\n    \"*\": TOKEN_MUL,\n    \"%\": TOKEN_MOD,\n    \"**\": TOKEN_POW,\n    \"~\": TOKEN_TILDE,\n    \"[\": TOKEN_LBRACKET,\n    \"]\": TOKEN_RBRACKET,\n    \"(\": TOKEN_LPAREN,\n    \")\": TOKEN_RPAREN,\n    \"{\": TOKEN_LBRACE,\n    \"}\": TOKEN_RBRACE,\n    \"==\": TOKEN_EQ,\n    \"!=\": TOKEN_NE,\n    \">\": TOKEN_GT,\n    \">=\": TOKEN_GTEQ,\n    \"<\": TOKEN_LT,\n    \"<=\": TOKEN_LTEQ,\n    \"=\": TOKEN_ASSIGN,\n    \".\": TOKEN_DOT,\n    \":\": TOKEN_COLON,\n    \"|\": TOKEN_PIPE,\n    \",\": TOKEN_COMMA,\n    \";\": TOKEN_SEMICOLON,\n}\n\nreverse_operators = {v: k for k, v in operators.items()}\nassert len(operators) == len(reverse_operators), \"operators dropped\"\noperator_re = re.compile(\n    f\"({'|'.join(re.escape(x) for x in sorted(operators, key=lambda x: -len(x)))})\"\n)\n\nignored_tokens = frozenset(\n    [\n        TOKEN_COMMENT_BEGIN,\n        TOKEN_COMMENT,\n        TOKEN_COMMENT_END,\n        TOKEN_WHITESPACE,\n        TOKEN_LINECOMMENT_BEGIN,\n        TOKEN_LINECOMMENT_END,\n        TOKEN_LINECOMMENT,\n    ]\n)\nignore_if_empty = frozenset(\n    [TOKEN_WHITESPACE, TOKEN_DATA, TOKEN_COMMENT, TOKEN_LINECOMMENT]\n)\n\n\ndef _describe_token_type(token_type: str) -> str:\n    if token_type in reverse_operators:\n        return reverse_operators[token_type]\n\n    return {\n        TOKEN_COMMENT_BEGIN: \"begin of comment\",\n        TOKEN_COMMENT_END: \"end of comment\",\n        TOKEN_COMMENT: \"comment\",\n        TOKEN_LINECOMMENT: \"comment\",\n        TOKEN_BLOCK_BEGIN: \"begin of statement block\",\n        TOKEN_BLOCK_END: \"end of statement block\",\n        TOKEN_VARIABLE_BEGIN: \"begin of print statement\",\n        TOKEN_VARIABLE_END: \"end of print statement\",\n        TOKEN_LINESTATEMENT_BEGIN: \"begin of line statement\",\n        TOKEN_LINESTATEMENT_END: \"end of line statement\",\n        TOKEN_DATA: \"template data / text\",\n        TOKEN_EOF: \"end of template\",\n    }.get(token_type, token_type)\n\n\ndef describe_token(token: \"Token\") -> str:\n    \"\"\"Returns a description of the token.\"\"\"\n    if token.type == TOKEN_NAME:\n        return token.value\n\n    return _describe_token_type(token.type)\n\n\ndef describe_token_expr(expr: str) -> str:\n    \"\"\"Like `describe_token` but for token expressions.\"\"\"\n    if \":\" in expr:\n        type, value = expr.split(\":\", 1)\n\n        if type == TOKEN_NAME:\n            return value\n    else:\n        type = expr\n\n    return _describe_token_type(type)\n\n\ndef count_newlines(value: str) -> int:\n    \"\"\"Count the number of newline characters in the string.  This is\n    useful for extensions that filter a stream.\n    \"\"\"\n    return len(newline_re.findall(value))\n\n\ndef compile_rules(environment: \"Environment\") -> t.List[t.Tuple[str, str]]:\n    \"\"\"Compiles all the rules from the environment into a list of rules.\"\"\"\n    e = re.escape\n    rules = [\n        (\n            len(environment.comment_start_string),\n            TOKEN_COMMENT_BEGIN,\n            e(environment.comment_start_string),\n        ),\n        (\n            len(environment.block_start_string),\n            TOKEN_BLOCK_BEGIN,\n            e(environment.block_start_string),\n        ),\n        (\n            len(environment.variable_start_string),\n            TOKEN_VARIABLE_BEGIN,\n            e(environment.variable_start_string),\n        ),\n    ]\n\n    if environment.line_statement_prefix is not None:\n        rules.append(\n            (\n                len(environment.line_statement_prefix),\n                TOKEN_LINESTATEMENT_BEGIN,\n                r\"^[ \\t\\v]*\" + e(environment.line_statement_prefix),\n            )\n        )\n    if environment.line_comment_prefix is not None:\n        rules.append(\n            (\n                len(environment.line_comment_prefix),\n                TOKEN_LINECOMMENT_BEGIN,\n                r\"(?:^|(?<=\\S))[^\\S\\r\\n]*\" + e(environment.line_comment_prefix),\n            )\n        )\n\n    return [x[1:] for x in sorted(rules, reverse=True)]\n\n\nclass Failure:\n    \"\"\"Class that raises a `TemplateSyntaxError` if called.\n    Used by the `Lexer` to specify known errors.\n    \"\"\"\n\n    def __init__(\n        self, message: str, cls: t.Type[TemplateSyntaxError] = TemplateSyntaxError\n    ) -> None:\n        self.message = message\n        self.error_class = cls\n\n    def __call__(self, lineno: int, filename: str) -> \"te.NoReturn\":\n        raise self.error_class(self.message, lineno, filename)\n\n\nclass Token(t.NamedTuple):\n    lineno: int\n    type: str\n    value: str\n\n    def __str__(self) -> str:\n        return describe_token(self)\n\n    def test(self, expr: str) -> bool:\n        \"\"\"Test a token against a token expression.  This can either be a\n        token type or ``'token_type:token_value'``.  This can only test\n        against string values and types.\n        \"\"\"\n        # here we do a regular string equality check as test_any is usually\n        # passed an iterable of not interned strings.\n        if self.type == expr:\n            return True\n\n        if \":\" in expr:\n            return expr.split(\":\", 1) == [self.type, self.value]\n\n        return False\n\n    def test_any(self, *iterable: str) -> bool:\n        \"\"\"Test against multiple token expressions.\"\"\"\n        return any(self.test(expr) for expr in iterable)\n\n\nclass TokenStreamIterator:\n    \"\"\"The iterator for tokenstreams.  Iterate over the stream\n    until the eof token is reached.\n    \"\"\"\n\n    def __init__(self, stream: \"TokenStream\") -> None:\n        self.stream = stream\n\n    def __iter__(self) -> \"TokenStreamIterator\":\n        return self\n\n    def __next__(self) -> Token:\n        token = self.stream.current\n\n        if token.type is TOKEN_EOF:\n            self.stream.close()\n            raise StopIteration\n\n        next(self.stream)\n        return token\n\n\nclass TokenStream:\n    \"\"\"A token stream is an iterable that yields :class:`Token`\\\\s.  The\n    parser however does not iterate over it but calls :meth:`next` to go\n    one token ahead.  The current active token is stored as :attr:`current`.\n    \"\"\"\n\n    def __init__(\n        self,\n        generator: t.Iterable[Token],\n        name: t.Optional[str],\n        filename: t.Optional[str],\n    ):\n        self._iter = iter(generator)\n        self._pushed: te.Deque[Token] = deque()\n        self.name = name\n        self.filename = filename\n        self.closed = False\n        self.current = Token(1, TOKEN_INITIAL, \"\")\n        next(self)\n\n    def __iter__(self) -> TokenStreamIterator:\n        return TokenStreamIterator(self)\n\n    def __bool__(self) -> bool:\n        return bool(self._pushed) or self.current.type is not TOKEN_EOF\n\n    @property\n    def eos(self) -> bool:\n        \"\"\"Are we at the end of the stream?\"\"\"\n        return not self\n\n    def push(self, token: Token) -> None:\n        \"\"\"Push a token back to the stream.\"\"\"\n        self._pushed.append(token)\n\n    def look(self) -> Token:\n        \"\"\"Look at the next token.\"\"\"\n        old_token = next(self)\n        result = self.current\n        self.push(result)\n        self.current = old_token\n        return result\n\n    def skip(self, n: int = 1) -> None:\n        \"\"\"Got n tokens ahead.\"\"\"\n        for _ in range(n):\n            next(self)\n\n    def next_if(self, expr: str) -> t.Optional[Token]:\n        \"\"\"Perform the token test and return the token if it matched.\n        Otherwise the return value is `None`.\n        \"\"\"\n        if self.current.test(expr):\n            return next(self)\n\n        return None\n\n    def skip_if(self, expr: str) -> bool:\n        \"\"\"Like :meth:`next_if` but only returns `True` or `False`.\"\"\"\n        return self.next_if(expr) is not None\n\n    def __next__(self) -> Token:\n        \"\"\"Go one token ahead and return the old one.\n\n        Use the built-in :func:`next` instead of calling this directly.\n        \"\"\"\n        rv = self.current\n\n        if self._pushed:\n            self.current = self._pushed.popleft()\n        elif self.current.type is not TOKEN_EOF:\n            try:\n                self.current = next(self._iter)\n            except StopIteration:\n                self.close()\n\n        return rv\n\n    def close(self) -> None:\n        \"\"\"Close the stream.\"\"\"\n        self.current = Token(self.current.lineno, TOKEN_EOF, \"\")\n        self._iter = iter(())\n        self.closed = True\n\n    def expect(self, expr: str) -> Token:\n        \"\"\"Expect a given token type and return it.  This accepts the same\n        argument as :meth:`jinja2.lexer.Token.test`.\n        \"\"\"\n        if not self.current.test(expr):\n            expr = describe_token_expr(expr)\n\n            if self.current.type is TOKEN_EOF:\n                raise TemplateSyntaxError(\n                    f\"unexpected end of template, expected {expr!r}.\",\n                    self.current.lineno,\n                    self.name,\n                    self.filename,\n                )\n\n            raise TemplateSyntaxError(\n                f\"expected token {expr!r}, got {describe_token(self.current)!r}\",\n                self.current.lineno,\n                self.name,\n                self.filename,\n            )\n\n        return next(self)\n\n\ndef get_lexer(environment: \"Environment\") -> \"Lexer\":\n    \"\"\"Return a lexer which is probably cached.\"\"\"\n    key = (\n        environment.block_start_string,\n        environment.block_end_string,\n        environment.variable_start_string,\n        environment.variable_end_string,\n        environment.comment_start_string,\n        environment.comment_end_string,\n        environment.line_statement_prefix,\n        environment.line_comment_prefix,\n        environment.trim_blocks,\n        environment.lstrip_blocks,\n        environment.newline_sequence,\n        environment.keep_trailing_newline,\n    )\n    lexer = _lexer_cache.get(key)\n\n    if lexer is None:\n        _lexer_cache[key] = lexer = Lexer(environment)\n\n    return lexer\n\n\nclass OptionalLStrip(tuple):  # type: ignore[type-arg]\n    \"\"\"A special tuple for marking a point in the state that can have\n    lstrip applied.\n    \"\"\"\n\n    __slots__ = ()\n\n    # Even though it looks like a no-op, creating instances fails\n    # without this.\n    def __new__(cls, *members, **kwargs):  # type: ignore\n        return super().__new__(cls, members)\n\n\nclass _Rule(t.NamedTuple):\n    pattern: t.Pattern[str]\n    tokens: t.Union[str, t.Tuple[str, ...], t.Tuple[Failure]]\n    command: t.Optional[str]\n\n\nclass Lexer:\n    \"\"\"Class that implements a lexer for a given environment. Automatically\n    created by the environment class, usually you don't have to do that.\n\n    Note that the lexer is not automatically bound to an environment.\n    Multiple environments can share the same lexer.\n    \"\"\"\n\n    def __init__(self, environment: \"Environment\") -> None:\n        # shortcuts\n        e = re.escape\n\n        def c(x: str) -> t.Pattern[str]:\n            return re.compile(x, re.M | re.S)\n\n        # lexing rules for tags\n        tag_rules: t.List[_Rule] = [\n            _Rule(whitespace_re, TOKEN_WHITESPACE, None),\n            _Rule(float_re, TOKEN_FLOAT, None),\n            _Rule(integer_re, TOKEN_INTEGER, None),\n            _Rule(name_re, TOKEN_NAME, None),\n            _Rule(string_re, TOKEN_STRING, None),\n            _Rule(operator_re, TOKEN_OPERATOR, None),\n        ]\n\n        # assemble the root lexing rule. because \"|\" is ungreedy\n        # we have to sort by length so that the lexer continues working\n        # as expected when we have parsing rules like <% for block and\n        # <%= for variables. (if someone wants asp like syntax)\n        # variables are just part of the rules if variable processing\n        # is required.\n        root_tag_rules = compile_rules(environment)\n\n        block_start_re = e(environment.block_start_string)\n        block_end_re = e(environment.block_end_string)\n        comment_end_re = e(environment.comment_end_string)\n        variable_end_re = e(environment.variable_end_string)\n\n        # block suffix if trimming is enabled\n        block_suffix_re = \"\\\\n?\" if environment.trim_blocks else \"\"\n\n        self.lstrip_blocks = environment.lstrip_blocks\n\n        self.newline_sequence = environment.newline_sequence\n        self.keep_trailing_newline = environment.keep_trailing_newline\n\n        root_raw_re = (\n            rf\"(?P<raw_begin>{block_start_re}(\\-|\\+|)\\s*raw\\s*\"\n            rf\"(?:\\-{block_end_re}\\s*|{block_end_re}))\"\n        )\n        root_parts_re = \"|\".join(\n            [root_raw_re] + [rf\"(?P<{n}>{r}(\\-|\\+|))\" for n, r in root_tag_rules]\n        )\n\n        # global lexing rules\n        self.rules: t.Dict[str, t.List[_Rule]] = {\n            \"root\": [\n                # directives\n                _Rule(\n                    c(rf\"(.*?)(?:{root_parts_re})\"),\n                    OptionalLStrip(TOKEN_DATA, \"#bygroup\"),  # type: ignore\n                    \"#bygroup\",\n                ),\n                # data\n                _Rule(c(\".+\"), TOKEN_DATA, None),\n            ],\n            # comments\n            TOKEN_COMMENT_BEGIN: [\n                _Rule(\n                    c(\n                        rf\"(.*?)((?:\\+{comment_end_re}|\\-{comment_end_re}\\s*\"\n                        rf\"|{comment_end_re}{block_suffix_re}))\"\n                    ),\n                    (TOKEN_COMMENT, TOKEN_COMMENT_END),\n                    \"#pop\",\n                ),\n                _Rule(c(r\"(.)\"), (Failure(\"Missing end of comment tag\"),), None),\n            ],\n            # blocks\n            TOKEN_BLOCK_BEGIN: [\n                _Rule(\n                    c(\n                        rf\"(?:\\+{block_end_re}|\\-{block_end_re}\\s*\"\n                        rf\"|{block_end_re}{block_suffix_re})\"\n                    ),\n                    TOKEN_BLOCK_END,\n                    \"#pop\",\n                ),\n            ]\n            + tag_rules,\n            # variables\n            TOKEN_VARIABLE_BEGIN: [\n                _Rule(\n                    c(rf\"\\-{variable_end_re}\\s*|{variable_end_re}\"),\n                    TOKEN_VARIABLE_END,\n                    \"#pop\",\n                )\n            ]\n            + tag_rules,\n            # raw block\n            TOKEN_RAW_BEGIN: [\n                _Rule(\n                    c(\n                        rf\"(.*?)((?:{block_start_re}(\\-|\\+|))\\s*endraw\\s*\"\n                        rf\"(?:\\+{block_end_re}|\\-{block_end_re}\\s*\"\n                        rf\"|{block_end_re}{block_suffix_re}))\"\n                    ),\n                    OptionalLStrip(TOKEN_DATA, TOKEN_RAW_END),  # type: ignore\n                    \"#pop\",\n                ),\n                _Rule(c(r\"(.)\"), (Failure(\"Missing end of raw directive\"),), None),\n            ],\n            # line statements\n            TOKEN_LINESTATEMENT_BEGIN: [\n                _Rule(c(r\"\\s*(\\n|$)\"), TOKEN_LINESTATEMENT_END, \"#pop\")\n            ]\n            + tag_rules,\n            # line comments\n            TOKEN_LINECOMMENT_BEGIN: [\n                _Rule(\n                    c(r\"(.*?)()(?=\\n|$)\"),\n                    (TOKEN_LINECOMMENT, TOKEN_LINECOMMENT_END),\n                    \"#pop\",\n                )\n            ],\n        }\n\n    def _normalize_newlines(self, value: str) -> str:\n        \"\"\"Replace all newlines with the configured sequence in strings\n        and template data.\n        \"\"\"\n        return newline_re.sub(self.newline_sequence, value)\n\n    def tokenize(\n        self,\n        source: str,\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n        state: t.Optional[str] = None,\n    ) -> TokenStream:\n        \"\"\"Calls tokeniter + tokenize and wraps it in a token stream.\"\"\"\n        stream = self.tokeniter(source, name, filename, state)\n        return TokenStream(self.wrap(stream, name, filename), name, filename)\n\n    def wrap(\n        self,\n        stream: t.Iterable[t.Tuple[int, str, str]],\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n    ) -> t.Iterator[Token]:\n        \"\"\"This is called with the stream as returned by `tokenize` and wraps\n        every token in a :class:`Token` and converts the value.\n        \"\"\"\n        for lineno, token, value_str in stream:\n            if token in ignored_tokens:\n                continue\n\n            value: t.Any = value_str\n\n            if token == TOKEN_LINESTATEMENT_BEGIN:\n                token = TOKEN_BLOCK_BEGIN\n            elif token == TOKEN_LINESTATEMENT_END:\n                token = TOKEN_BLOCK_END\n            # we are not interested in those tokens in the parser\n            elif token in (TOKEN_RAW_BEGIN, TOKEN_RAW_END):\n                continue\n            elif token == TOKEN_DATA:\n                value = self._normalize_newlines(value_str)\n            elif token == \"keyword\":\n                token = value_str\n            elif token == TOKEN_NAME:\n                value = value_str\n\n                if not value.isidentifier():\n                    raise TemplateSyntaxError(\n                        \"Invalid character in identifier\", lineno, name, filename\n                    )\n            elif token == TOKEN_STRING:\n                # try to unescape string\n                try:\n                    value = (\n                        self._normalize_newlines(value_str[1:-1])\n                        .encode(\"ascii\", \"backslashreplace\")\n                        .decode(\"unicode-escape\")\n                    )\n                except Exception as e:\n                    msg = str(e).split(\":\")[-1].strip()\n                    raise TemplateSyntaxError(msg, lineno, name, filename) from e\n            elif token == TOKEN_INTEGER:\n                value = int(value_str.replace(\"_\", \"\"), 0)\n            elif token == TOKEN_FLOAT:\n                # remove all \"_\" first to support more Python versions\n                value = literal_eval(value_str.replace(\"_\", \"\"))\n            elif token == TOKEN_OPERATOR:\n                token = operators[value_str]\n\n            yield Token(lineno, token, value)\n\n    def tokeniter(\n        self,\n        source: str,\n        name: t.Optional[str],\n        filename: t.Optional[str] = None,\n        state: t.Optional[str] = None,\n    ) -> t.Iterator[t.Tuple[int, str, str]]:\n        \"\"\"This method tokenizes the text and returns the tokens in a\n        generator. Use this method if you just want to tokenize a template.\n\n        .. versionchanged:: 3.0\n            Only ``\\\\n``, ``\\\\r\\\\n`` and ``\\\\r`` are treated as line\n            breaks.\n        \"\"\"\n        lines = newline_re.split(source)[::2]\n\n        if not self.keep_trailing_newline and lines[-1] == \"\":\n            del lines[-1]\n\n        source = \"\\n\".join(lines)\n        pos = 0\n        lineno = 1\n        stack = [\"root\"]\n\n        if state is not None and state != \"root\":\n            assert state in (\"variable\", \"block\"), \"invalid state\"\n            stack.append(state + \"_begin\")\n\n        statetokens = self.rules[stack[-1]]\n        source_length = len(source)\n        balancing_stack: t.List[str] = []\n        newlines_stripped = 0\n        line_starting = True\n\n        while True:\n            # tokenizer loop\n            for regex, tokens, new_state in statetokens:\n                m = regex.match(source, pos)\n\n                # if no match we try again with the next rule\n                if m is None:\n                    continue\n\n                # we only match blocks and variables if braces / parentheses\n                # are balanced. continue parsing with the lower rule which\n                # is the operator rule. do this only if the end tags look\n                # like operators\n                if balancing_stack and tokens in (\n                    TOKEN_VARIABLE_END,\n                    TOKEN_BLOCK_END,\n                    TOKEN_LINESTATEMENT_END,\n                ):\n                    continue\n\n                # tuples support more options\n                if isinstance(tokens, tuple):\n                    groups: t.Sequence[str] = m.groups()\n\n                    if isinstance(tokens, OptionalLStrip):\n                        # Rule supports lstrip. Match will look like\n                        # text, block type, whitespace control, type, control, ...\n                        text = groups[0]\n                        # Skipping the text and first type, every other group is the\n                        # whitespace control for each type. One of the groups will be\n                        # -, +, or empty string instead of None.\n                        strip_sign = next(g for g in groups[2::2] if g is not None)\n\n                        if strip_sign == \"-\":\n                            # Strip all whitespace between the text and the tag.\n                            stripped = text.rstrip()\n                            newlines_stripped = text[len(stripped) :].count(\"\\n\")\n                            groups = [stripped, *groups[1:]]\n                        elif (\n                            # Not marked for preserving whitespace.\n                            strip_sign != \"+\"\n                            # lstrip is enabled.\n                            and self.lstrip_blocks\n                            # Not a variable expression.\n                            and not m.groupdict().get(TOKEN_VARIABLE_BEGIN)\n                        ):\n                            # The start of text between the last newline and the tag.\n                            l_pos = text.rfind(\"\\n\") + 1\n\n                            if l_pos > 0 or line_starting:\n                                # If there's only whitespace between the newline and the\n                                # tag, strip it.\n                                if whitespace_re.fullmatch(text, l_pos):\n                                    groups = [text[:l_pos], *groups[1:]]\n\n                    for idx, token in enumerate(tokens):\n                        # failure group\n                        if token.__class__ is Failure:\n                            raise token(lineno, filename)\n                        # bygroup is a bit more complex, in that case we\n                        # yield for the current token the first named\n                        # group that matched\n                        elif token == \"#bygroup\":\n                            for key, value in m.groupdict().items():\n                                if value is not None:\n                                    yield lineno, key, value\n                                    lineno += value.count(\"\\n\")\n                                    break\n                            else:\n                                raise RuntimeError(\n                                    f\"{regex!r} wanted to resolve the token dynamically\"\n                                    \" but no group matched\"\n                                )\n                        # normal group\n                        else:\n                            data = groups[idx]\n\n                            if data or token not in ignore_if_empty:\n                                yield lineno, token, data\n\n                            lineno += data.count(\"\\n\") + newlines_stripped\n                            newlines_stripped = 0\n\n                # strings as token just are yielded as it.\n                else:\n                    data = m.group()\n\n                    # update brace/parentheses balance\n                    if tokens == TOKEN_OPERATOR:\n                        if data == \"{\":\n                            balancing_stack.append(\"}\")\n                        elif data == \"(\":\n                            balancing_stack.append(\")\")\n                        elif data == \"[\":\n                            balancing_stack.append(\"]\")\n                        elif data in (\"}\", \")\", \"]\"):\n                            if not balancing_stack:\n                                raise TemplateSyntaxError(\n                                    f\"unexpected '{data}'\", lineno, name, filename\n                                )\n\n                            expected_op = balancing_stack.pop()\n\n                            if expected_op != data:\n                                raise TemplateSyntaxError(\n                                    f\"unexpected '{data}', expected '{expected_op}'\",\n                                    lineno,\n                                    name,\n                                    filename,\n                                )\n\n                    # yield items\n                    if data or tokens not in ignore_if_empty:\n                        yield lineno, tokens, data\n\n                    lineno += data.count(\"\\n\")\n\n                line_starting = m.group()[-1:] == \"\\n\"\n                # fetch new position into new variable so that we can check\n                # if there is a internal parsing error which would result\n                # in an infinite loop\n                pos2 = m.end()\n\n                # handle state changes\n                if new_state is not None:\n                    # remove the uppermost state\n                    if new_state == \"#pop\":\n                        stack.pop()\n                    # resolve the new state by group checking\n                    elif new_state == \"#bygroup\":\n                        for key, value in m.groupdict().items():\n                            if value is not None:\n                                stack.append(key)\n                                break\n                        else:\n                            raise RuntimeError(\n                                f\"{regex!r} wanted to resolve the new state dynamically\"\n                                f\" but no group matched\"\n                            )\n                    # direct state name given\n                    else:\n                        stack.append(new_state)\n\n                    statetokens = self.rules[stack[-1]]\n                # we are still at the same position and no stack change.\n                # this means a loop without break condition, avoid that and\n                # raise error\n                elif pos2 == pos:\n                    raise RuntimeError(\n                        f\"{regex!r} yielded empty string without stack change\"\n                    )\n\n                # publish new function and start again\n                pos = pos2\n                break\n            # if loop terminated without break we haven't found a single match\n            # either we are at the end of the file or we have a problem\n            else:\n                # end of text\n                if pos >= source_length:\n                    return\n\n                # something went wrong\n                raise TemplateSyntaxError(\n                    f\"unexpected char {source[pos]!r} at {pos}\", lineno, name, filename\n                )\n", "src/jinja2/meta.py": "\"\"\"Functions that expose information about templates that might be\ninteresting for introspection.\n\"\"\"\n\nimport typing as t\n\nfrom . import nodes\nfrom .compiler import CodeGenerator\nfrom .compiler import Frame\n\nif t.TYPE_CHECKING:\n    from .environment import Environment\n\n\nclass TrackingCodeGenerator(CodeGenerator):\n    \"\"\"We abuse the code generator for introspection.\"\"\"\n\n    def __init__(self, environment: \"Environment\") -> None:\n        super().__init__(environment, \"<introspection>\", \"<introspection>\")\n        self.undeclared_identifiers: t.Set[str] = set()\n\n    def write(self, x: str) -> None:\n        \"\"\"Don't write.\"\"\"\n\n    def enter_frame(self, frame: Frame) -> None:\n        \"\"\"Remember all undeclared identifiers.\"\"\"\n        super().enter_frame(frame)\n\n        for _, (action, param) in frame.symbols.loads.items():\n            if action == \"resolve\" and param not in self.environment.globals:\n                self.undeclared_identifiers.add(param)\n\n\ndef find_undeclared_variables(ast: nodes.Template) -> t.Set[str]:\n    \"\"\"Returns a set of all variables in the AST that will be looked up from\n    the context at runtime.  Because at compile time it's not known which\n    variables will be used depending on the path the execution takes at\n    runtime, all variables are returned.\n\n    >>> from jinja2 import Environment, meta\n    >>> env = Environment()\n    >>> ast = env.parse('{% set foo = 42 %}{{ bar + foo }}')\n    >>> meta.find_undeclared_variables(ast) == {'bar'}\n    True\n\n    .. admonition:: Implementation\n\n       Internally the code generator is used for finding undeclared variables.\n       This is good to know because the code generator might raise a\n       :exc:`TemplateAssertionError` during compilation and as a matter of\n       fact this function can currently raise that exception as well.\n    \"\"\"\n    codegen = TrackingCodeGenerator(ast.environment)  # type: ignore\n    codegen.visit(ast)\n    return codegen.undeclared_identifiers\n\n\n_ref_types = (nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include)\n_RefType = t.Union[nodes.Extends, nodes.FromImport, nodes.Import, nodes.Include]\n\n\ndef find_referenced_templates(ast: nodes.Template) -> t.Iterator[t.Optional[str]]:\n    \"\"\"Finds all the referenced templates from the AST.  This will return an\n    iterator over all the hardcoded template extensions, inclusions and\n    imports.  If dynamic inheritance or inclusion is used, `None` will be\n    yielded.\n\n    >>> from jinja2 import Environment, meta\n    >>> env = Environment()\n    >>> ast = env.parse('{% extends \"layout.html\" %}{% include helper %}')\n    >>> list(meta.find_referenced_templates(ast))\n    ['layout.html', None]\n\n    This function is useful for dependency tracking.  For example if you want\n    to rebuild parts of the website after a layout template has changed.\n    \"\"\"\n    template_name: t.Any\n\n    for node in ast.find_all(_ref_types):\n        template: nodes.Expr = node.template  # type: ignore\n\n        if not isinstance(template, nodes.Const):\n            # a tuple with some non consts in there\n            if isinstance(template, (nodes.Tuple, nodes.List)):\n                for template_name in template.items:\n                    # something const, only yield the strings and ignore\n                    # non-string consts that really just make no sense\n                    if isinstance(template_name, nodes.Const):\n                        if isinstance(template_name.value, str):\n                            yield template_name.value\n                    # something dynamic in there\n                    else:\n                        yield None\n            # something dynamic we don't know about here\n            else:\n                yield None\n            continue\n        # constant is a basestring, direct template name\n        if isinstance(template.value, str):\n            yield template.value\n        # a tuple or list (latter *should* not happen) made of consts,\n        # yield the consts that are strings.  We could warn here for\n        # non string values\n        elif isinstance(node, nodes.Include) and isinstance(\n            template.value, (tuple, list)\n        ):\n            for template_name in template.value:\n                if isinstance(template_name, str):\n                    yield template_name\n        # something else we don't care about, we could warn here\n        else:\n            yield None\n", "src/jinja2/filters.py": "\"\"\"Built-in template filters used with the ``|`` operator.\"\"\"\n\nimport math\nimport random\nimport re\nimport typing\nimport typing as t\nfrom collections import abc\nfrom itertools import chain\nfrom itertools import groupby\n\nfrom markupsafe import escape\nfrom markupsafe import Markup\nfrom markupsafe import soft_str\n\nfrom .async_utils import async_variant\nfrom .async_utils import auto_aiter\nfrom .async_utils import auto_await\nfrom .async_utils import auto_to_list\nfrom .exceptions import FilterArgumentError\nfrom .runtime import Undefined\nfrom .utils import htmlsafe_json_dumps\nfrom .utils import pass_context\nfrom .utils import pass_environment\nfrom .utils import pass_eval_context\nfrom .utils import pformat\nfrom .utils import url_quote\nfrom .utils import urlize\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .environment import Environment\n    from .nodes import EvalContext\n    from .runtime import Context\n    from .sandbox import SandboxedEnvironment  # noqa: F401\n\n    class HasHTML(te.Protocol):\n        def __html__(self) -> str:\n            pass\n\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\nK = t.TypeVar(\"K\")\nV = t.TypeVar(\"V\")\n\n\ndef ignore_case(value: V) -> V:\n    \"\"\"For use as a postprocessor for :func:`make_attrgetter`. Converts strings\n    to lowercase and returns other types as-is.\"\"\"\n    if isinstance(value, str):\n        return t.cast(V, value.lower())\n\n    return value\n\n\ndef make_attrgetter(\n    environment: \"Environment\",\n    attribute: t.Optional[t.Union[str, int]],\n    postprocess: t.Optional[t.Callable[[t.Any], t.Any]] = None,\n    default: t.Optional[t.Any] = None,\n) -> t.Callable[[t.Any], t.Any]:\n    \"\"\"Returns a callable that looks up the given attribute from a\n    passed object with the rules of the environment.  Dots are allowed\n    to access attributes of attributes.  Integer parts in paths are\n    looked up as integers.\n    \"\"\"\n    parts = _prepare_attribute_parts(attribute)\n\n    def attrgetter(item: t.Any) -> t.Any:\n        for part in parts:\n            item = environment.getitem(item, part)\n\n            if default is not None and isinstance(item, Undefined):\n                item = default\n\n        if postprocess is not None:\n            item = postprocess(item)\n\n        return item\n\n    return attrgetter\n\n\ndef make_multi_attrgetter(\n    environment: \"Environment\",\n    attribute: t.Optional[t.Union[str, int]],\n    postprocess: t.Optional[t.Callable[[t.Any], t.Any]] = None,\n) -> t.Callable[[t.Any], t.List[t.Any]]:\n    \"\"\"Returns a callable that looks up the given comma separated\n    attributes from a passed object with the rules of the environment.\n    Dots are allowed to access attributes of each attribute.  Integer\n    parts in paths are looked up as integers.\n\n    The value returned by the returned callable is a list of extracted\n    attribute values.\n\n    Examples of attribute: \"attr1,attr2\", \"attr1.inner1.0,attr2.inner2.0\", etc.\n    \"\"\"\n    if isinstance(attribute, str):\n        split: t.Sequence[t.Union[str, int, None]] = attribute.split(\",\")\n    else:\n        split = [attribute]\n\n    parts = [_prepare_attribute_parts(item) for item in split]\n\n    def attrgetter(item: t.Any) -> t.List[t.Any]:\n        items = [None] * len(parts)\n\n        for i, attribute_part in enumerate(parts):\n            item_i = item\n\n            for part in attribute_part:\n                item_i = environment.getitem(item_i, part)\n\n            if postprocess is not None:\n                item_i = postprocess(item_i)\n\n            items[i] = item_i\n\n        return items\n\n    return attrgetter\n\n\ndef _prepare_attribute_parts(\n    attr: t.Optional[t.Union[str, int]],\n) -> t.List[t.Union[str, int]]:\n    if attr is None:\n        return []\n\n    if isinstance(attr, str):\n        return [int(x) if x.isdigit() else x for x in attr.split(\".\")]\n\n    return [attr]\n\n\ndef do_forceescape(value: \"t.Union[str, HasHTML]\") -> Markup:\n    \"\"\"Enforce HTML escaping.  This will probably double escape variables.\"\"\"\n    if hasattr(value, \"__html__\"):\n        value = t.cast(\"HasHTML\", value).__html__()\n\n    return escape(str(value))\n\n\ndef do_urlencode(\n    value: t.Union[str, t.Mapping[str, t.Any], t.Iterable[t.Tuple[str, t.Any]]],\n) -> str:\n    \"\"\"Quote data for use in a URL path or query using UTF-8.\n\n    Basic wrapper around :func:`urllib.parse.quote` when given a\n    string, or :func:`urllib.parse.urlencode` for a dict or iterable.\n\n    :param value: Data to quote. A string will be quoted directly. A\n        dict or iterable of ``(key, value)`` pairs will be joined as a\n        query string.\n\n    When given a string, \"/\" is not quoted. HTTP servers treat \"/\" and\n    \"%2F\" equivalently in paths. If you need quoted slashes, use the\n    ``|replace(\"/\", \"%2F\")`` filter.\n\n    .. versionadded:: 2.7\n    \"\"\"\n    if isinstance(value, str) or not isinstance(value, abc.Iterable):\n        return url_quote(value)\n\n    if isinstance(value, dict):\n        items: t.Iterable[t.Tuple[str, t.Any]] = value.items()\n    else:\n        items = value  # type: ignore\n\n    return \"&\".join(\n        f\"{url_quote(k, for_qs=True)}={url_quote(v, for_qs=True)}\" for k, v in items\n    )\n\n\n@pass_eval_context\ndef do_replace(\n    eval_ctx: \"EvalContext\", s: str, old: str, new: str, count: t.Optional[int] = None\n) -> str:\n    \"\"\"Return a copy of the value with all occurrences of a substring\n    replaced with a new one. The first argument is the substring\n    that should be replaced, the second is the replacement string.\n    If the optional third argument ``count`` is given, only the first\n    ``count`` occurrences are replaced:\n\n    .. sourcecode:: jinja\n\n        {{ \"Hello World\"|replace(\"Hello\", \"Goodbye\") }}\n            -> Goodbye World\n\n        {{ \"aaaaargh\"|replace(\"a\", \"d'oh, \", 2) }}\n            -> d'oh, d'oh, aaargh\n    \"\"\"\n    if count is None:\n        count = -1\n\n    if not eval_ctx.autoescape:\n        return str(s).replace(str(old), str(new), count)\n\n    if (\n        hasattr(old, \"__html__\")\n        or hasattr(new, \"__html__\")\n        and not hasattr(s, \"__html__\")\n    ):\n        s = escape(s)\n    else:\n        s = soft_str(s)\n\n    return s.replace(soft_str(old), soft_str(new), count)\n\n\ndef do_upper(s: str) -> str:\n    \"\"\"Convert a value to uppercase.\"\"\"\n    return soft_str(s).upper()\n\n\ndef do_lower(s: str) -> str:\n    \"\"\"Convert a value to lowercase.\"\"\"\n    return soft_str(s).lower()\n\n\ndef do_items(value: t.Union[t.Mapping[K, V], Undefined]) -> t.Iterator[t.Tuple[K, V]]:\n    \"\"\"Return an iterator over the ``(key, value)`` items of a mapping.\n\n    ``x|items`` is the same as ``x.items()``, except if ``x`` is\n    undefined an empty iterator is returned.\n\n    This filter is useful if you expect the template to be rendered with\n    an implementation of Jinja in another programming language that does\n    not have a ``.items()`` method on its mapping type.\n\n    .. code-block:: html+jinja\n\n        <dl>\n        {% for key, value in my_dict|items %}\n            <dt>{{ key }}\n            <dd>{{ value }}\n        {% endfor %}\n        </dl>\n\n    .. versionadded:: 3.1\n    \"\"\"\n    if isinstance(value, Undefined):\n        return\n\n    if not isinstance(value, abc.Mapping):\n        raise TypeError(\"Can only get item pairs from a mapping.\")\n\n    yield from value.items()\n\n\n# Check for characters that would move the parser state from key to value.\n# https://html.spec.whatwg.org/#attribute-name-state\n_attr_key_re = re.compile(r\"[\\s/>=]\", flags=re.ASCII)\n\n\n@pass_eval_context\ndef do_xmlattr(\n    eval_ctx: \"EvalContext\", d: t.Mapping[str, t.Any], autospace: bool = True\n) -> str:\n    \"\"\"Create an SGML/XML attribute string based on the items in a dict.\n\n    **Values** that are neither ``none`` nor ``undefined`` are automatically\n    escaped, safely allowing untrusted user input.\n\n    User input should not be used as **keys** to this filter. If any key\n    contains a space, ``/`` solidus, ``>`` greater-than sign, or ``=`` equals\n    sign, this fails with a ``ValueError``. Regardless of this, user input\n    should never be used as keys to this filter, or must be separately validated\n    first.\n\n    .. sourcecode:: html+jinja\n\n        <ul{{ {'class': 'my_list', 'missing': none,\n                'id': 'list-%d'|format(variable)}|xmlattr }}>\n        ...\n        </ul>\n\n    Results in something like this:\n\n    .. sourcecode:: html\n\n        <ul class=\"my_list\" id=\"list-42\">\n        ...\n        </ul>\n\n    As you can see it automatically prepends a space in front of the item\n    if the filter returned something unless the second parameter is false.\n\n    .. versionchanged:: 3.1.4\n        Keys with ``/`` solidus, ``>`` greater-than sign, or ``=`` equals sign\n        are not allowed.\n\n    .. versionchanged:: 3.1.3\n        Keys with spaces are not allowed.\n    \"\"\"\n    items = []\n\n    for key, value in d.items():\n        if value is None or isinstance(value, Undefined):\n            continue\n\n        if _attr_key_re.search(key) is not None:\n            raise ValueError(f\"Invalid character in attribute name: {key!r}\")\n\n        items.append(f'{escape(key)}=\"{escape(value)}\"')\n\n    rv = \" \".join(items)\n\n    if autospace and rv:\n        rv = \" \" + rv\n\n    if eval_ctx.autoescape:\n        rv = Markup(rv)\n\n    return rv\n\n\ndef do_capitalize(s: str) -> str:\n    \"\"\"Capitalize a value. The first character will be uppercase, all others\n    lowercase.\n    \"\"\"\n    return soft_str(s).capitalize()\n\n\n_word_beginning_split_re = re.compile(r\"([-\\s({\\[<]+)\")\n\n\ndef do_title(s: str) -> str:\n    \"\"\"Return a titlecased version of the value. I.e. words will start with\n    uppercase letters, all remaining characters are lowercase.\n    \"\"\"\n    return \"\".join(\n        [\n            item[0].upper() + item[1:].lower()\n            for item in _word_beginning_split_re.split(soft_str(s))\n            if item\n        ]\n    )\n\n\ndef do_dictsort(\n    value: t.Mapping[K, V],\n    case_sensitive: bool = False,\n    by: 'te.Literal[\"key\", \"value\"]' = \"key\",\n    reverse: bool = False,\n) -> t.List[t.Tuple[K, V]]:\n    \"\"\"Sort a dict and yield (key, value) pairs. Python dicts may not\n    be in the order you want to display them in, so sort them first.\n\n    .. sourcecode:: jinja\n\n        {% for key, value in mydict|dictsort %}\n            sort the dict by key, case insensitive\n\n        {% for key, value in mydict|dictsort(reverse=true) %}\n            sort the dict by key, case insensitive, reverse order\n\n        {% for key, value in mydict|dictsort(true) %}\n            sort the dict by key, case sensitive\n\n        {% for key, value in mydict|dictsort(false, 'value') %}\n            sort the dict by value, case insensitive\n    \"\"\"\n    if by == \"key\":\n        pos = 0\n    elif by == \"value\":\n        pos = 1\n    else:\n        raise FilterArgumentError('You can only sort by either \"key\" or \"value\"')\n\n    def sort_func(item: t.Tuple[t.Any, t.Any]) -> t.Any:\n        value = item[pos]\n\n        if not case_sensitive:\n            value = ignore_case(value)\n\n        return value\n\n    return sorted(value.items(), key=sort_func, reverse=reverse)\n\n\n@pass_environment\ndef do_sort(\n    environment: \"Environment\",\n    value: \"t.Iterable[V]\",\n    reverse: bool = False,\n    case_sensitive: bool = False,\n    attribute: t.Optional[t.Union[str, int]] = None,\n) -> \"t.List[V]\":\n    \"\"\"Sort an iterable using Python's :func:`sorted`.\n\n    .. sourcecode:: jinja\n\n        {% for city in cities|sort %}\n            ...\n        {% endfor %}\n\n    :param reverse: Sort descending instead of ascending.\n    :param case_sensitive: When sorting strings, sort upper and lower\n        case separately.\n    :param attribute: When sorting objects or dicts, an attribute or\n        key to sort by. Can use dot notation like ``\"address.city\"``.\n        Can be a list of attributes like ``\"age,name\"``.\n\n    The sort is stable, it does not change the relative order of\n    elements that compare equal. This makes it is possible to chain\n    sorts on different attributes and ordering.\n\n    .. sourcecode:: jinja\n\n        {% for user in users|sort(attribute=\"name\")\n            |sort(reverse=true, attribute=\"age\") %}\n            ...\n        {% endfor %}\n\n    As a shortcut to chaining when the direction is the same for all\n    attributes, pass a comma separate list of attributes.\n\n    .. sourcecode:: jinja\n\n        {% for user in users|sort(attribute=\"age,name\") %}\n            ...\n        {% endfor %}\n\n    .. versionchanged:: 2.11.0\n        The ``attribute`` parameter can be a comma separated list of\n        attributes, e.g. ``\"age,name\"``.\n\n    .. versionchanged:: 2.6\n       The ``attribute`` parameter was added.\n    \"\"\"\n    key_func = make_multi_attrgetter(\n        environment, attribute, postprocess=ignore_case if not case_sensitive else None\n    )\n    return sorted(value, key=key_func, reverse=reverse)\n\n\n@pass_environment\ndef do_unique(\n    environment: \"Environment\",\n    value: \"t.Iterable[V]\",\n    case_sensitive: bool = False,\n    attribute: t.Optional[t.Union[str, int]] = None,\n) -> \"t.Iterator[V]\":\n    \"\"\"Returns a list of unique items from the given iterable.\n\n    .. sourcecode:: jinja\n\n        {{ ['foo', 'bar', 'foobar', 'FooBar']|unique|list }}\n            -> ['foo', 'bar', 'foobar']\n\n    The unique items are yielded in the same order as their first occurrence in\n    the iterable passed to the filter.\n\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Filter objects with unique values for this attribute.\n    \"\"\"\n    getter = make_attrgetter(\n        environment, attribute, postprocess=ignore_case if not case_sensitive else None\n    )\n    seen = set()\n\n    for item in value:\n        key = getter(item)\n\n        if key not in seen:\n            seen.add(key)\n            yield item\n\n\ndef _min_or_max(\n    environment: \"Environment\",\n    value: \"t.Iterable[V]\",\n    func: \"t.Callable[..., V]\",\n    case_sensitive: bool,\n    attribute: t.Optional[t.Union[str, int]],\n) -> \"t.Union[V, Undefined]\":\n    it = iter(value)\n\n    try:\n        first = next(it)\n    except StopIteration:\n        return environment.undefined(\"No aggregated item, sequence was empty.\")\n\n    key_func = make_attrgetter(\n        environment, attribute, postprocess=ignore_case if not case_sensitive else None\n    )\n    return func(chain([first], it), key=key_func)\n\n\n@pass_environment\ndef do_min(\n    environment: \"Environment\",\n    value: \"t.Iterable[V]\",\n    case_sensitive: bool = False,\n    attribute: t.Optional[t.Union[str, int]] = None,\n) -> \"t.Union[V, Undefined]\":\n    \"\"\"Return the smallest item from the sequence.\n\n    .. sourcecode:: jinja\n\n        {{ [1, 2, 3]|min }}\n            -> 1\n\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Get the object with the min value of this attribute.\n    \"\"\"\n    return _min_or_max(environment, value, min, case_sensitive, attribute)\n\n\n@pass_environment\ndef do_max(\n    environment: \"Environment\",\n    value: \"t.Iterable[V]\",\n    case_sensitive: bool = False,\n    attribute: t.Optional[t.Union[str, int]] = None,\n) -> \"t.Union[V, Undefined]\":\n    \"\"\"Return the largest item from the sequence.\n\n    .. sourcecode:: jinja\n\n        {{ [1, 2, 3]|max }}\n            -> 3\n\n    :param case_sensitive: Treat upper and lower case strings as distinct.\n    :param attribute: Get the object with the max value of this attribute.\n    \"\"\"\n    return _min_or_max(environment, value, max, case_sensitive, attribute)\n\n\ndef do_default(\n    value: V,\n    default_value: V = \"\",  # type: ignore\n    boolean: bool = False,\n) -> V:\n    \"\"\"If the value is undefined it will return the passed default value,\n    otherwise the value of the variable:\n\n    .. sourcecode:: jinja\n\n        {{ my_variable|default('my_variable is not defined') }}\n\n    This will output the value of ``my_variable`` if the variable was\n    defined, otherwise ``'my_variable is not defined'``. If you want\n    to use default with variables that evaluate to false you have to\n    set the second parameter to `true`:\n\n    .. sourcecode:: jinja\n\n        {{ ''|default('the string was empty', true) }}\n\n    .. versionchanged:: 2.11\n       It's now possible to configure the :class:`~jinja2.Environment` with\n       :class:`~jinja2.ChainableUndefined` to make the `default` filter work\n       on nested elements and attributes that may contain undefined values\n       in the chain without getting an :exc:`~jinja2.UndefinedError`.\n    \"\"\"\n    if isinstance(value, Undefined) or (boolean and not value):\n        return default_value\n\n    return value\n\n\n@pass_eval_context\ndef sync_do_join(\n    eval_ctx: \"EvalContext\",\n    value: t.Iterable[t.Any],\n    d: str = \"\",\n    attribute: t.Optional[t.Union[str, int]] = None,\n) -> str:\n    \"\"\"Return a string which is the concatenation of the strings in the\n    sequence. The separator between elements is an empty string per\n    default, you can define it with the optional parameter:\n\n    .. sourcecode:: jinja\n\n        {{ [1, 2, 3]|join('|') }}\n            -> 1|2|3\n\n        {{ [1, 2, 3]|join }}\n            -> 123\n\n    It is also possible to join certain attributes of an object:\n\n    .. sourcecode:: jinja\n\n        {{ users|join(', ', attribute='username') }}\n\n    .. versionadded:: 2.6\n       The `attribute` parameter was added.\n    \"\"\"\n    if attribute is not None:\n        value = map(make_attrgetter(eval_ctx.environment, attribute), value)\n\n    # no automatic escaping?  joining is a lot easier then\n    if not eval_ctx.autoescape:\n        return str(d).join(map(str, value))\n\n    # if the delimiter doesn't have an html representation we check\n    # if any of the items has.  If yes we do a coercion to Markup\n    if not hasattr(d, \"__html__\"):\n        value = list(value)\n        do_escape = False\n\n        for idx, item in enumerate(value):\n            if hasattr(item, \"__html__\"):\n                do_escape = True\n            else:\n                value[idx] = str(item)\n\n        if do_escape:\n            d = escape(d)\n        else:\n            d = str(d)\n\n        return d.join(value)\n\n    # no html involved, to normal joining\n    return soft_str(d).join(map(soft_str, value))\n\n\n@async_variant(sync_do_join)  # type: ignore\nasync def do_join(\n    eval_ctx: \"EvalContext\",\n    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],\n    d: str = \"\",\n    attribute: t.Optional[t.Union[str, int]] = None,\n) -> str:\n    return sync_do_join(eval_ctx, await auto_to_list(value), d, attribute)\n\n\ndef do_center(value: str, width: int = 80) -> str:\n    \"\"\"Centers the value in a field of a given width.\"\"\"\n    return soft_str(value).center(width)\n\n\n@pass_environment\ndef sync_do_first(\n    environment: \"Environment\", seq: \"t.Iterable[V]\"\n) -> \"t.Union[V, Undefined]\":\n    \"\"\"Return the first item of a sequence.\"\"\"\n    try:\n        return next(iter(seq))\n    except StopIteration:\n        return environment.undefined(\"No first item, sequence was empty.\")\n\n\n@async_variant(sync_do_first)  # type: ignore\nasync def do_first(\n    environment: \"Environment\", seq: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\"\n) -> \"t.Union[V, Undefined]\":\n    try:\n        return await auto_aiter(seq).__anext__()\n    except StopAsyncIteration:\n        return environment.undefined(\"No first item, sequence was empty.\")\n\n\n@pass_environment\ndef do_last(\n    environment: \"Environment\", seq: \"t.Reversible[V]\"\n) -> \"t.Union[V, Undefined]\":\n    \"\"\"Return the last item of a sequence.\n\n    Note: Does not work with generators. You may want to explicitly\n    convert it to a list:\n\n    .. sourcecode:: jinja\n\n        {{ data | selectattr('name', '==', 'Jinja') | list | last }}\n    \"\"\"\n    try:\n        return next(iter(reversed(seq)))\n    except StopIteration:\n        return environment.undefined(\"No last item, sequence was empty.\")\n\n\n# No async do_last, it may not be safe in async mode.\n\n\n@pass_context\ndef do_random(context: \"Context\", seq: \"t.Sequence[V]\") -> \"t.Union[V, Undefined]\":\n    \"\"\"Return a random item from the sequence.\"\"\"\n    try:\n        return random.choice(seq)\n    except IndexError:\n        return context.environment.undefined(\"No random item, sequence was empty.\")\n\n\ndef do_filesizeformat(value: t.Union[str, float, int], binary: bool = False) -> str:\n    \"\"\"Format the value like a 'human-readable' file size (i.e. 13 kB,\n    4.1 MB, 102 Bytes, etc).  Per default decimal prefixes are used (Mega,\n    Giga, etc.), if the second parameter is set to `True` the binary\n    prefixes are used (Mebi, Gibi).\n    \"\"\"\n    bytes = float(value)\n    base = 1024 if binary else 1000\n    prefixes = [\n        (\"KiB\" if binary else \"kB\"),\n        (\"MiB\" if binary else \"MB\"),\n        (\"GiB\" if binary else \"GB\"),\n        (\"TiB\" if binary else \"TB\"),\n        (\"PiB\" if binary else \"PB\"),\n        (\"EiB\" if binary else \"EB\"),\n        (\"ZiB\" if binary else \"ZB\"),\n        (\"YiB\" if binary else \"YB\"),\n    ]\n\n    if bytes == 1:\n        return \"1 Byte\"\n    elif bytes < base:\n        return f\"{int(bytes)} Bytes\"\n    else:\n        for i, prefix in enumerate(prefixes):\n            unit = base ** (i + 2)\n\n            if bytes < unit:\n                return f\"{base * bytes / unit:.1f} {prefix}\"\n\n        return f\"{base * bytes / unit:.1f} {prefix}\"\n\n\ndef do_pprint(value: t.Any) -> str:\n    \"\"\"Pretty print a variable. Useful for debugging.\"\"\"\n    return pformat(value)\n\n\n_uri_scheme_re = re.compile(r\"^([\\w.+-]{2,}:(/){0,2})$\")\n\n\n@pass_eval_context\ndef do_urlize(\n    eval_ctx: \"EvalContext\",\n    value: str,\n    trim_url_limit: t.Optional[int] = None,\n    nofollow: bool = False,\n    target: t.Optional[str] = None,\n    rel: t.Optional[str] = None,\n    extra_schemes: t.Optional[t.Iterable[str]] = None,\n) -> str:\n    \"\"\"Convert URLs in text into clickable links.\n\n    This may not recognize links in some situations. Usually, a more\n    comprehensive formatter, such as a Markdown library, is a better\n    choice.\n\n    Works on ``http://``, ``https://``, ``www.``, ``mailto:``, and email\n    addresses. Links with trailing punctuation (periods, commas, closing\n    parentheses) and leading punctuation (opening parentheses) are\n    recognized excluding the punctuation. Email addresses that include\n    header fields are not recognized (for example,\n    ``mailto:address@example.com?cc=copy@example.com``).\n\n    :param value: Original text containing URLs to link.\n    :param trim_url_limit: Shorten displayed URL values to this length.\n    :param nofollow: Add the ``rel=nofollow`` attribute to links.\n    :param target: Add the ``target`` attribute to links.\n    :param rel: Add the ``rel`` attribute to links.\n    :param extra_schemes: Recognize URLs that start with these schemes\n        in addition to the default behavior. Defaults to\n        ``env.policies[\"urlize.extra_schemes\"]``, which defaults to no\n        extra schemes.\n\n    .. versionchanged:: 3.0\n        The ``extra_schemes`` parameter was added.\n\n    .. versionchanged:: 3.0\n        Generate ``https://`` links for URLs without a scheme.\n\n    .. versionchanged:: 3.0\n        The parsing rules were updated. Recognize email addresses with\n        or without the ``mailto:`` scheme. Validate IP addresses. Ignore\n        parentheses and brackets in more cases.\n\n    .. versionchanged:: 2.8\n       The ``target`` parameter was added.\n    \"\"\"\n    policies = eval_ctx.environment.policies\n    rel_parts = set((rel or \"\").split())\n\n    if nofollow:\n        rel_parts.add(\"nofollow\")\n\n    rel_parts.update((policies[\"urlize.rel\"] or \"\").split())\n    rel = \" \".join(sorted(rel_parts)) or None\n\n    if target is None:\n        target = policies[\"urlize.target\"]\n\n    if extra_schemes is None:\n        extra_schemes = policies[\"urlize.extra_schemes\"] or ()\n\n    for scheme in extra_schemes:\n        if _uri_scheme_re.fullmatch(scheme) is None:\n            raise FilterArgumentError(f\"{scheme!r} is not a valid URI scheme prefix.\")\n\n    rv = urlize(\n        value,\n        trim_url_limit=trim_url_limit,\n        rel=rel,\n        target=target,\n        extra_schemes=extra_schemes,\n    )\n\n    if eval_ctx.autoescape:\n        rv = Markup(rv)\n\n    return rv\n\n\ndef do_indent(\n    s: str, width: t.Union[int, str] = 4, first: bool = False, blank: bool = False\n) -> str:\n    \"\"\"Return a copy of the string with each line indented by 4 spaces. The\n    first line and blank lines are not indented by default.\n\n    :param width: Number of spaces, or a string, to indent by.\n    :param first: Don't skip indenting the first line.\n    :param blank: Don't skip indenting empty lines.\n\n    .. versionchanged:: 3.0\n        ``width`` can be a string.\n\n    .. versionchanged:: 2.10\n        Blank lines are not indented by default.\n\n        Rename the ``indentfirst`` argument to ``first``.\n    \"\"\"\n    if isinstance(width, str):\n        indention = width\n    else:\n        indention = \" \" * width\n\n    newline = \"\\n\"\n\n    if isinstance(s, Markup):\n        indention = Markup(indention)\n        newline = Markup(newline)\n\n    s += newline  # this quirk is necessary for splitlines method\n\n    if blank:\n        rv = (newline + indention).join(s.splitlines())\n    else:\n        lines = s.splitlines()\n        rv = lines.pop(0)\n\n        if lines:\n            rv += newline + newline.join(\n                indention + line if line else line for line in lines\n            )\n\n    if first:\n        rv = indention + rv\n\n    return rv\n\n\n@pass_environment\ndef do_truncate(\n    env: \"Environment\",\n    s: str,\n    length: int = 255,\n    killwords: bool = False,\n    end: str = \"...\",\n    leeway: t.Optional[int] = None,\n) -> str:\n    \"\"\"Return a truncated copy of the string. The length is specified\n    with the first parameter which defaults to ``255``. If the second\n    parameter is ``true`` the filter will cut the text at length. Otherwise\n    it will discard the last word. If the text was in fact\n    truncated it will append an ellipsis sign (``\"...\"``). If you want a\n    different ellipsis sign than ``\"...\"`` you can specify it using the\n    third parameter. Strings that only exceed the length by the tolerance\n    margin given in the fourth parameter will not be truncated.\n\n    .. sourcecode:: jinja\n\n        {{ \"foo bar baz qux\"|truncate(9) }}\n            -> \"foo...\"\n        {{ \"foo bar baz qux\"|truncate(9, True) }}\n            -> \"foo ba...\"\n        {{ \"foo bar baz qux\"|truncate(11) }}\n            -> \"foo bar baz qux\"\n        {{ \"foo bar baz qux\"|truncate(11, False, '...', 0) }}\n            -> \"foo bar...\"\n\n    The default leeway on newer Jinja versions is 5 and was 0 before but\n    can be reconfigured globally.\n    \"\"\"\n    if leeway is None:\n        leeway = env.policies[\"truncate.leeway\"]\n\n    assert length >= len(end), f\"expected length >= {len(end)}, got {length}\"\n    assert leeway >= 0, f\"expected leeway >= 0, got {leeway}\"\n\n    if len(s) <= length + leeway:\n        return s\n\n    if killwords:\n        return s[: length - len(end)] + end\n\n    result = s[: length - len(end)].rsplit(\" \", 1)[0]\n    return result + end\n\n\n@pass_environment\ndef do_wordwrap(\n    environment: \"Environment\",\n    s: str,\n    width: int = 79,\n    break_long_words: bool = True,\n    wrapstring: t.Optional[str] = None,\n    break_on_hyphens: bool = True,\n) -> str:\n    \"\"\"Wrap a string to the given width. Existing newlines are treated\n    as paragraphs to be wrapped separately.\n\n    :param s: Original text to wrap.\n    :param width: Maximum length of wrapped lines.\n    :param break_long_words: If a word is longer than ``width``, break\n        it across lines.\n    :param break_on_hyphens: If a word contains hyphens, it may be split\n        across lines.\n    :param wrapstring: String to join each wrapped line. Defaults to\n        :attr:`Environment.newline_sequence`.\n\n    .. versionchanged:: 2.11\n        Existing newlines are treated as paragraphs wrapped separately.\n\n    .. versionchanged:: 2.11\n        Added the ``break_on_hyphens`` parameter.\n\n    .. versionchanged:: 2.7\n        Added the ``wrapstring`` parameter.\n    \"\"\"\n    import textwrap\n\n    if wrapstring is None:\n        wrapstring = environment.newline_sequence\n\n    # textwrap.wrap doesn't consider existing newlines when wrapping.\n    # If the string has a newline before width, wrap will still insert\n    # a newline at width, resulting in a short line. Instead, split and\n    # wrap each paragraph individually.\n    return wrapstring.join(\n        [\n            wrapstring.join(\n                textwrap.wrap(\n                    line,\n                    width=width,\n                    expand_tabs=False,\n                    replace_whitespace=False,\n                    break_long_words=break_long_words,\n                    break_on_hyphens=break_on_hyphens,\n                )\n            )\n            for line in s.splitlines()\n        ]\n    )\n\n\n_word_re = re.compile(r\"\\w+\")\n\n\ndef do_wordcount(s: str) -> int:\n    \"\"\"Count the words in that string.\"\"\"\n    return len(_word_re.findall(soft_str(s)))\n\n\ndef do_int(value: t.Any, default: int = 0, base: int = 10) -> int:\n    \"\"\"Convert the value into an integer. If the\n    conversion doesn't work it will return ``0``. You can\n    override this default using the first parameter. You\n    can also override the default base (10) in the second\n    parameter, which handles input with prefixes such as\n    0b, 0o and 0x for bases 2, 8 and 16 respectively.\n    The base is ignored for decimal numbers and non-string values.\n    \"\"\"\n    try:\n        if isinstance(value, str):\n            return int(value, base)\n\n        return int(value)\n    except (TypeError, ValueError):\n        # this quirk is necessary so that \"42.23\"|int gives 42.\n        try:\n            return int(float(value))\n        except (TypeError, ValueError):\n            return default\n\n\ndef do_float(value: t.Any, default: float = 0.0) -> float:\n    \"\"\"Convert the value into a floating point number. If the\n    conversion doesn't work it will return ``0.0``. You can\n    override this default using the first parameter.\n    \"\"\"\n    try:\n        return float(value)\n    except (TypeError, ValueError):\n        return default\n\n\ndef do_format(value: str, *args: t.Any, **kwargs: t.Any) -> str:\n    \"\"\"Apply the given values to a `printf-style`_ format string, like\n    ``string % values``.\n\n    .. sourcecode:: jinja\n\n        {{ \"%s, %s!\"|format(greeting, name) }}\n        Hello, World!\n\n    In most cases it should be more convenient and efficient to use the\n    ``%`` operator or :meth:`str.format`.\n\n    .. code-block:: text\n\n        {{ \"%s, %s!\" % (greeting, name) }}\n        {{ \"{}, {}!\".format(greeting, name) }}\n\n    .. _printf-style: https://docs.python.org/library/stdtypes.html\n        #printf-style-string-formatting\n    \"\"\"\n    if args and kwargs:\n        raise FilterArgumentError(\n            \"can't handle positional and keyword arguments at the same time\"\n        )\n\n    return soft_str(value) % (kwargs or args)\n\n\ndef do_trim(value: str, chars: t.Optional[str] = None) -> str:\n    \"\"\"Strip leading and trailing characters, by default whitespace.\"\"\"\n    return soft_str(value).strip(chars)\n\n\ndef do_striptags(value: \"t.Union[str, HasHTML]\") -> str:\n    \"\"\"Strip SGML/XML tags and replace adjacent whitespace by one space.\"\"\"\n    if hasattr(value, \"__html__\"):\n        value = t.cast(\"HasHTML\", value).__html__()\n\n    return Markup(str(value)).striptags()\n\n\ndef sync_do_slice(\n    value: \"t.Collection[V]\", slices: int, fill_with: \"t.Optional[V]\" = None\n) -> \"t.Iterator[t.List[V]]\":\n    \"\"\"Slice an iterator and return a list of lists containing\n    those items. Useful if you want to create a div containing\n    three ul tags that represent columns:\n\n    .. sourcecode:: html+jinja\n\n        <div class=\"columnwrapper\">\n          {%- for column in items|slice(3) %}\n            <ul class=\"column-{{ loop.index }}\">\n            {%- for item in column %}\n              <li>{{ item }}</li>\n            {%- endfor %}\n            </ul>\n          {%- endfor %}\n        </div>\n\n    If you pass it a second argument it's used to fill missing\n    values on the last iteration.\n    \"\"\"\n    seq = list(value)\n    length = len(seq)\n    items_per_slice = length // slices\n    slices_with_extra = length % slices\n    offset = 0\n\n    for slice_number in range(slices):\n        start = offset + slice_number * items_per_slice\n\n        if slice_number < slices_with_extra:\n            offset += 1\n\n        end = offset + (slice_number + 1) * items_per_slice\n        tmp = seq[start:end]\n\n        if fill_with is not None and slice_number >= slices_with_extra:\n            tmp.append(fill_with)\n\n        yield tmp\n\n\n@async_variant(sync_do_slice)  # type: ignore\nasync def do_slice(\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    slices: int,\n    fill_with: t.Optional[t.Any] = None,\n) -> \"t.Iterator[t.List[V]]\":\n    return sync_do_slice(await auto_to_list(value), slices, fill_with)\n\n\ndef do_batch(\n    value: \"t.Iterable[V]\", linecount: int, fill_with: \"t.Optional[V]\" = None\n) -> \"t.Iterator[t.List[V]]\":\n    \"\"\"\n    A filter that batches items. It works pretty much like `slice`\n    just the other way round. It returns a list of lists with the\n    given number of items. If you provide a second parameter this\n    is used to fill up missing items. See this example:\n\n    .. sourcecode:: html+jinja\n\n        <table>\n        {%- for row in items|batch(3, '&nbsp;') %}\n          <tr>\n          {%- for column in row %}\n            <td>{{ column }}</td>\n          {%- endfor %}\n          </tr>\n        {%- endfor %}\n        </table>\n    \"\"\"\n    tmp: t.List[V] = []\n\n    for item in value:\n        if len(tmp) == linecount:\n            yield tmp\n            tmp = []\n\n        tmp.append(item)\n\n    if tmp:\n        if fill_with is not None and len(tmp) < linecount:\n            tmp += [fill_with] * (linecount - len(tmp))\n\n        yield tmp\n\n\ndef do_round(\n    value: float,\n    precision: int = 0,\n    method: 'te.Literal[\"common\", \"ceil\", \"floor\"]' = \"common\",\n) -> float:\n    \"\"\"Round the number to a given precision. The first\n    parameter specifies the precision (default is ``0``), the\n    second the rounding method:\n\n    - ``'common'`` rounds either up or down\n    - ``'ceil'`` always rounds up\n    - ``'floor'`` always rounds down\n\n    If you don't specify a method ``'common'`` is used.\n\n    .. sourcecode:: jinja\n\n        {{ 42.55|round }}\n            -> 43.0\n        {{ 42.55|round(1, 'floor') }}\n            -> 42.5\n\n    Note that even if rounded to 0 precision, a float is returned.  If\n    you need a real integer, pipe it through `int`:\n\n    .. sourcecode:: jinja\n\n        {{ 42.55|round|int }}\n            -> 43\n    \"\"\"\n    if method not in {\"common\", \"ceil\", \"floor\"}:\n        raise FilterArgumentError(\"method must be common, ceil or floor\")\n\n    if method == \"common\":\n        return round(value, precision)\n\n    func = getattr(math, method)\n    return t.cast(float, func(value * (10**precision)) / (10**precision))\n\n\nclass _GroupTuple(t.NamedTuple):\n    grouper: t.Any\n    list: t.List[t.Any]\n\n    # Use the regular tuple repr to hide this subclass if users print\n    # out the value during debugging.\n    def __repr__(self) -> str:\n        return tuple.__repr__(self)\n\n    def __str__(self) -> str:\n        return tuple.__str__(self)\n\n\n@pass_environment\ndef sync_do_groupby(\n    environment: \"Environment\",\n    value: \"t.Iterable[V]\",\n    attribute: t.Union[str, int],\n    default: t.Optional[t.Any] = None,\n    case_sensitive: bool = False,\n) -> \"t.List[_GroupTuple]\":\n    \"\"\"Group a sequence of objects by an attribute using Python's\n    :func:`itertools.groupby`. The attribute can use dot notation for\n    nested access, like ``\"address.city\"``. Unlike Python's ``groupby``,\n    the values are sorted first so only one group is returned for each\n    unique value.\n\n    For example, a list of ``User`` objects with a ``city`` attribute\n    can be rendered in groups. In this example, ``grouper`` refers to\n    the ``city`` value of the group.\n\n    .. sourcecode:: html+jinja\n\n        <ul>{% for city, items in users|groupby(\"city\") %}\n          <li>{{ city }}\n            <ul>{% for user in items %}\n              <li>{{ user.name }}\n            {% endfor %}</ul>\n          </li>\n        {% endfor %}</ul>\n\n    ``groupby`` yields namedtuples of ``(grouper, list)``, which\n    can be used instead of the tuple unpacking above. ``grouper`` is the\n    value of the attribute, and ``list`` is the items with that value.\n\n    .. sourcecode:: html+jinja\n\n        <ul>{% for group in users|groupby(\"city\") %}\n          <li>{{ group.grouper }}: {{ group.list|join(\", \") }}\n        {% endfor %}</ul>\n\n    You can specify a ``default`` value to use if an object in the list\n    does not have the given attribute.\n\n    .. sourcecode:: jinja\n\n        <ul>{% for city, items in users|groupby(\"city\", default=\"NY\") %}\n          <li>{{ city }}: {{ items|map(attribute=\"name\")|join(\", \") }}</li>\n        {% endfor %}</ul>\n\n    Like the :func:`~jinja-filters.sort` filter, sorting and grouping is\n    case-insensitive by default. The ``key`` for each group will have\n    the case of the first item in that group of values. For example, if\n    a list of users has cities ``[\"CA\", \"NY\", \"ca\"]``, the \"CA\" group\n    will have two values. This can be disabled by passing\n    ``case_sensitive=True``.\n\n    .. versionchanged:: 3.1\n        Added the ``case_sensitive`` parameter. Sorting and grouping is\n        case-insensitive by default, matching other filters that do\n        comparisons.\n\n    .. versionchanged:: 3.0\n        Added the ``default`` parameter.\n\n    .. versionchanged:: 2.6\n        The attribute supports dot notation for nested access.\n    \"\"\"\n    expr = make_attrgetter(\n        environment,\n        attribute,\n        postprocess=ignore_case if not case_sensitive else None,\n        default=default,\n    )\n    out = [\n        _GroupTuple(key, list(values))\n        for key, values in groupby(sorted(value, key=expr), expr)\n    ]\n\n    if not case_sensitive:\n        # Return the real key from the first value instead of the lowercase key.\n        output_expr = make_attrgetter(environment, attribute, default=default)\n        out = [_GroupTuple(output_expr(values[0]), values) for _, values in out]\n\n    return out\n\n\n@async_variant(sync_do_groupby)  # type: ignore\nasync def do_groupby(\n    environment: \"Environment\",\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    attribute: t.Union[str, int],\n    default: t.Optional[t.Any] = None,\n    case_sensitive: bool = False,\n) -> \"t.List[_GroupTuple]\":\n    expr = make_attrgetter(\n        environment,\n        attribute,\n        postprocess=ignore_case if not case_sensitive else None,\n        default=default,\n    )\n    out = [\n        _GroupTuple(key, await auto_to_list(values))\n        for key, values in groupby(sorted(await auto_to_list(value), key=expr), expr)\n    ]\n\n    if not case_sensitive:\n        # Return the real key from the first value instead of the lowercase key.\n        output_expr = make_attrgetter(environment, attribute, default=default)\n        out = [_GroupTuple(output_expr(values[0]), values) for _, values in out]\n\n    return out\n\n\n@pass_environment\ndef sync_do_sum(\n    environment: \"Environment\",\n    iterable: \"t.Iterable[V]\",\n    attribute: t.Optional[t.Union[str, int]] = None,\n    start: V = 0,  # type: ignore\n) -> V:\n    \"\"\"Returns the sum of a sequence of numbers plus the value of parameter\n    'start' (which defaults to 0).  When the sequence is empty it returns\n    start.\n\n    It is also possible to sum up only certain attributes:\n\n    .. sourcecode:: jinja\n\n        Total: {{ items|sum(attribute='price') }}\n\n    .. versionchanged:: 2.6\n       The ``attribute`` parameter was added to allow summing up over\n       attributes.  Also the ``start`` parameter was moved on to the right.\n    \"\"\"\n    if attribute is not None:\n        iterable = map(make_attrgetter(environment, attribute), iterable)\n\n    return sum(iterable, start)  # type: ignore[no-any-return, call-overload]\n\n\n@async_variant(sync_do_sum)  # type: ignore\nasync def do_sum(\n    environment: \"Environment\",\n    iterable: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    attribute: t.Optional[t.Union[str, int]] = None,\n    start: V = 0,  # type: ignore\n) -> V:\n    rv = start\n\n    if attribute is not None:\n        func = make_attrgetter(environment, attribute)\n    else:\n\n        def func(x: V) -> V:\n            return x\n\n    async for item in auto_aiter(iterable):\n        rv += func(item)\n\n    return rv\n\n\ndef sync_do_list(value: \"t.Iterable[V]\") -> \"t.List[V]\":\n    \"\"\"Convert the value into a list.  If it was a string the returned list\n    will be a list of characters.\n    \"\"\"\n    return list(value)\n\n\n@async_variant(sync_do_list)  # type: ignore\nasync def do_list(value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\") -> \"t.List[V]\":\n    return await auto_to_list(value)\n\n\ndef do_mark_safe(value: str) -> Markup:\n    \"\"\"Mark the value as safe which means that in an environment with automatic\n    escaping enabled this variable will not be escaped.\n    \"\"\"\n    return Markup(value)\n\n\ndef do_mark_unsafe(value: str) -> str:\n    \"\"\"Mark a value as unsafe.  This is the reverse operation for :func:`safe`.\"\"\"\n    return str(value)\n\n\n@typing.overload\ndef do_reverse(value: str) -> str: ...\n\n\n@typing.overload\ndef do_reverse(value: \"t.Iterable[V]\") -> \"t.Iterable[V]\": ...\n\n\ndef do_reverse(value: t.Union[str, t.Iterable[V]]) -> t.Union[str, t.Iterable[V]]:\n    \"\"\"Reverse the object or return an iterator that iterates over it the other\n    way round.\n    \"\"\"\n    if isinstance(value, str):\n        return value[::-1]\n\n    try:\n        return reversed(value)  # type: ignore\n    except TypeError:\n        try:\n            rv = list(value)\n            rv.reverse()\n            return rv\n        except TypeError as e:\n            raise FilterArgumentError(\"argument must be iterable\") from e\n\n\n@pass_environment\ndef do_attr(\n    environment: \"Environment\", obj: t.Any, name: str\n) -> t.Union[Undefined, t.Any]:\n    \"\"\"Get an attribute of an object.  ``foo|attr(\"bar\")`` works like\n    ``foo.bar`` just that always an attribute is returned and items are not\n    looked up.\n\n    See :ref:`Notes on subscriptions <notes-on-subscriptions>` for more details.\n    \"\"\"\n    try:\n        name = str(name)\n    except UnicodeError:\n        pass\n    else:\n        try:\n            value = getattr(obj, name)\n        except AttributeError:\n            pass\n        else:\n            if environment.sandboxed:\n                environment = t.cast(\"SandboxedEnvironment\", environment)\n\n                if not environment.is_safe_attribute(obj, name, value):\n                    return environment.unsafe_undefined(obj, name)\n\n            return value\n\n    return environment.undefined(obj=obj, name=name)\n\n\n@typing.overload\ndef sync_do_map(\n    context: \"Context\",\n    value: t.Iterable[t.Any],\n    name: str,\n    *args: t.Any,\n    **kwargs: t.Any,\n) -> t.Iterable[t.Any]: ...\n\n\n@typing.overload\ndef sync_do_map(\n    context: \"Context\",\n    value: t.Iterable[t.Any],\n    *,\n    attribute: str = ...,\n    default: t.Optional[t.Any] = None,\n) -> t.Iterable[t.Any]: ...\n\n\n@pass_context\ndef sync_do_map(\n    context: \"Context\", value: t.Iterable[t.Any], *args: t.Any, **kwargs: t.Any\n) -> t.Iterable[t.Any]:\n    \"\"\"Applies a filter on a sequence of objects or looks up an attribute.\n    This is useful when dealing with lists of objects but you are really\n    only interested in a certain value of it.\n\n    The basic usage is mapping on an attribute.  Imagine you have a list\n    of users but you are only interested in a list of usernames:\n\n    .. sourcecode:: jinja\n\n        Users on this page: {{ users|map(attribute='username')|join(', ') }}\n\n    You can specify a ``default`` value to use if an object in the list\n    does not have the given attribute.\n\n    .. sourcecode:: jinja\n\n        {{ users|map(attribute=\"username\", default=\"Anonymous\")|join(\", \") }}\n\n    Alternatively you can let it invoke a filter by passing the name of the\n    filter and the arguments afterwards.  A good example would be applying a\n    text conversion filter on a sequence:\n\n    .. sourcecode:: jinja\n\n        Users on this page: {{ titles|map('lower')|join(', ') }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (u.username for u in users)\n        (getattr(u, \"username\", \"Anonymous\") for u in users)\n        (do_lower(x) for x in titles)\n\n    .. versionchanged:: 2.11.0\n        Added the ``default`` parameter.\n\n    .. versionadded:: 2.7\n    \"\"\"\n    if value:\n        func = prepare_map(context, args, kwargs)\n\n        for item in value:\n            yield func(item)\n\n\n@typing.overload\ndef do_map(\n    context: \"Context\",\n    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],\n    name: str,\n    *args: t.Any,\n    **kwargs: t.Any,\n) -> t.Iterable[t.Any]: ...\n\n\n@typing.overload\ndef do_map(\n    context: \"Context\",\n    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],\n    *,\n    attribute: str = ...,\n    default: t.Optional[t.Any] = None,\n) -> t.Iterable[t.Any]: ...\n\n\n@async_variant(sync_do_map)  # type: ignore\nasync def do_map(\n    context: \"Context\",\n    value: t.Union[t.AsyncIterable[t.Any], t.Iterable[t.Any]],\n    *args: t.Any,\n    **kwargs: t.Any,\n) -> t.AsyncIterable[t.Any]:\n    if value:\n        func = prepare_map(context, args, kwargs)\n\n        async for item in auto_aiter(value):\n            yield await auto_await(func(item))\n\n\n@pass_context\ndef sync_do_select(\n    context: \"Context\", value: \"t.Iterable[V]\", *args: t.Any, **kwargs: t.Any\n) -> \"t.Iterator[V]\":\n    \"\"\"Filters a sequence of objects by applying a test to each object,\n    and only selecting the objects with the test succeeding.\n\n    If no test is specified, each object will be evaluated as a boolean.\n\n    Example usage:\n\n    .. sourcecode:: jinja\n\n        {{ numbers|select(\"odd\") }}\n        {{ numbers|select(\"odd\") }}\n        {{ numbers|select(\"divisibleby\", 3) }}\n        {{ numbers|select(\"lessthan\", 42) }}\n        {{ strings|select(\"equalto\", \"mystring\") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (n for n in numbers if test_odd(n))\n        (n for n in numbers if test_divisibleby(n, 3))\n\n    .. versionadded:: 2.7\n    \"\"\"\n    return select_or_reject(context, value, args, kwargs, lambda x: x, False)\n\n\n@async_variant(sync_do_select)  # type: ignore\nasync def do_select(\n    context: \"Context\",\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    *args: t.Any,\n    **kwargs: t.Any,\n) -> \"t.AsyncIterator[V]\":\n    return async_select_or_reject(context, value, args, kwargs, lambda x: x, False)\n\n\n@pass_context\ndef sync_do_reject(\n    context: \"Context\", value: \"t.Iterable[V]\", *args: t.Any, **kwargs: t.Any\n) -> \"t.Iterator[V]\":\n    \"\"\"Filters a sequence of objects by applying a test to each object,\n    and rejecting the objects with the test succeeding.\n\n    If no test is specified, each object will be evaluated as a boolean.\n\n    Example usage:\n\n    .. sourcecode:: jinja\n\n        {{ numbers|reject(\"odd\") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (n for n in numbers if not test_odd(n))\n\n    .. versionadded:: 2.7\n    \"\"\"\n    return select_or_reject(context, value, args, kwargs, lambda x: not x, False)\n\n\n@async_variant(sync_do_reject)  # type: ignore\nasync def do_reject(\n    context: \"Context\",\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    *args: t.Any,\n    **kwargs: t.Any,\n) -> \"t.AsyncIterator[V]\":\n    return async_select_or_reject(context, value, args, kwargs, lambda x: not x, False)\n\n\n@pass_context\ndef sync_do_selectattr(\n    context: \"Context\", value: \"t.Iterable[V]\", *args: t.Any, **kwargs: t.Any\n) -> \"t.Iterator[V]\":\n    \"\"\"Filters a sequence of objects by applying a test to the specified\n    attribute of each object, and only selecting the objects with the\n    test succeeding.\n\n    If no test is specified, the attribute's value will be evaluated as\n    a boolean.\n\n    Example usage:\n\n    .. sourcecode:: jinja\n\n        {{ users|selectattr(\"is_active\") }}\n        {{ users|selectattr(\"email\", \"none\") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (u for user in users if user.is_active)\n        (u for user in users if test_none(user.email))\n\n    .. versionadded:: 2.7\n    \"\"\"\n    return select_or_reject(context, value, args, kwargs, lambda x: x, True)\n\n\n@async_variant(sync_do_selectattr)  # type: ignore\nasync def do_selectattr(\n    context: \"Context\",\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    *args: t.Any,\n    **kwargs: t.Any,\n) -> \"t.AsyncIterator[V]\":\n    return async_select_or_reject(context, value, args, kwargs, lambda x: x, True)\n\n\n@pass_context\ndef sync_do_rejectattr(\n    context: \"Context\", value: \"t.Iterable[V]\", *args: t.Any, **kwargs: t.Any\n) -> \"t.Iterator[V]\":\n    \"\"\"Filters a sequence of objects by applying a test to the specified\n    attribute of each object, and rejecting the objects with the test\n    succeeding.\n\n    If no test is specified, the attribute's value will be evaluated as\n    a boolean.\n\n    .. sourcecode:: jinja\n\n        {{ users|rejectattr(\"is_active\") }}\n        {{ users|rejectattr(\"email\", \"none\") }}\n\n    Similar to a generator comprehension such as:\n\n    .. code-block:: python\n\n        (u for user in users if not user.is_active)\n        (u for user in users if not test_none(user.email))\n\n    .. versionadded:: 2.7\n    \"\"\"\n    return select_or_reject(context, value, args, kwargs, lambda x: not x, True)\n\n\n@async_variant(sync_do_rejectattr)  # type: ignore\nasync def do_rejectattr(\n    context: \"Context\",\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    *args: t.Any,\n    **kwargs: t.Any,\n) -> \"t.AsyncIterator[V]\":\n    return async_select_or_reject(context, value, args, kwargs, lambda x: not x, True)\n\n\n@pass_eval_context\ndef do_tojson(\n    eval_ctx: \"EvalContext\", value: t.Any, indent: t.Optional[int] = None\n) -> Markup:\n    \"\"\"Serialize an object to a string of JSON, and mark it safe to\n    render in HTML. This filter is only for use in HTML documents.\n\n    The returned string is safe to render in HTML documents and\n    ``<script>`` tags. The exception is in HTML attributes that are\n    double quoted; either use single quotes or the ``|forceescape``\n    filter.\n\n    :param value: The object to serialize to JSON.\n    :param indent: The ``indent`` parameter passed to ``dumps``, for\n        pretty-printing the value.\n\n    .. versionadded:: 2.9\n    \"\"\"\n    policies = eval_ctx.environment.policies\n    dumps = policies[\"json.dumps_function\"]\n    kwargs = policies[\"json.dumps_kwargs\"]\n\n    if indent is not None:\n        kwargs = kwargs.copy()\n        kwargs[\"indent\"] = indent\n\n    return htmlsafe_json_dumps(value, dumps=dumps, **kwargs)\n\n\ndef prepare_map(\n    context: \"Context\", args: t.Tuple[t.Any, ...], kwargs: t.Dict[str, t.Any]\n) -> t.Callable[[t.Any], t.Any]:\n    if not args and \"attribute\" in kwargs:\n        attribute = kwargs.pop(\"attribute\")\n        default = kwargs.pop(\"default\", None)\n\n        if kwargs:\n            raise FilterArgumentError(\n                f\"Unexpected keyword argument {next(iter(kwargs))!r}\"\n            )\n\n        func = make_attrgetter(context.environment, attribute, default=default)\n    else:\n        try:\n            name = args[0]\n            args = args[1:]\n        except LookupError:\n            raise FilterArgumentError(\"map requires a filter argument\") from None\n\n        def func(item: t.Any) -> t.Any:\n            return context.environment.call_filter(\n                name, item, args, kwargs, context=context\n            )\n\n    return func\n\n\ndef prepare_select_or_reject(\n    context: \"Context\",\n    args: t.Tuple[t.Any, ...],\n    kwargs: t.Dict[str, t.Any],\n    modfunc: t.Callable[[t.Any], t.Any],\n    lookup_attr: bool,\n) -> t.Callable[[t.Any], t.Any]:\n    if lookup_attr:\n        try:\n            attr = args[0]\n        except LookupError:\n            raise FilterArgumentError(\"Missing parameter for attribute name\") from None\n\n        transfunc = make_attrgetter(context.environment, attr)\n        off = 1\n    else:\n        off = 0\n\n        def transfunc(x: V) -> V:\n            return x\n\n    try:\n        name = args[off]\n        args = args[1 + off :]\n\n        def func(item: t.Any) -> t.Any:\n            return context.environment.call_test(name, item, args, kwargs)\n\n    except LookupError:\n        func = bool  # type: ignore\n\n    return lambda item: modfunc(func(transfunc(item)))\n\n\ndef select_or_reject(\n    context: \"Context\",\n    value: \"t.Iterable[V]\",\n    args: t.Tuple[t.Any, ...],\n    kwargs: t.Dict[str, t.Any],\n    modfunc: t.Callable[[t.Any], t.Any],\n    lookup_attr: bool,\n) -> \"t.Iterator[V]\":\n    if value:\n        func = prepare_select_or_reject(context, args, kwargs, modfunc, lookup_attr)\n\n        for item in value:\n            if func(item):\n                yield item\n\n\nasync def async_select_or_reject(\n    context: \"Context\",\n    value: \"t.Union[t.AsyncIterable[V], t.Iterable[V]]\",\n    args: t.Tuple[t.Any, ...],\n    kwargs: t.Dict[str, t.Any],\n    modfunc: t.Callable[[t.Any], t.Any],\n    lookup_attr: bool,\n) -> \"t.AsyncIterator[V]\":\n    if value:\n        func = prepare_select_or_reject(context, args, kwargs, modfunc, lookup_attr)\n\n        async for item in auto_aiter(value):\n            if func(item):\n                yield item\n\n\nFILTERS = {\n    \"abs\": abs,\n    \"attr\": do_attr,\n    \"batch\": do_batch,\n    \"capitalize\": do_capitalize,\n    \"center\": do_center,\n    \"count\": len,\n    \"d\": do_default,\n    \"default\": do_default,\n    \"dictsort\": do_dictsort,\n    \"e\": escape,\n    \"escape\": escape,\n    \"filesizeformat\": do_filesizeformat,\n    \"first\": do_first,\n    \"float\": do_float,\n    \"forceescape\": do_forceescape,\n    \"format\": do_format,\n    \"groupby\": do_groupby,\n    \"indent\": do_indent,\n    \"int\": do_int,\n    \"join\": do_join,\n    \"last\": do_last,\n    \"length\": len,\n    \"list\": do_list,\n    \"lower\": do_lower,\n    \"items\": do_items,\n    \"map\": do_map,\n    \"min\": do_min,\n    \"max\": do_max,\n    \"pprint\": do_pprint,\n    \"random\": do_random,\n    \"reject\": do_reject,\n    \"rejectattr\": do_rejectattr,\n    \"replace\": do_replace,\n    \"reverse\": do_reverse,\n    \"round\": do_round,\n    \"safe\": do_mark_safe,\n    \"select\": do_select,\n    \"selectattr\": do_selectattr,\n    \"slice\": do_slice,\n    \"sort\": do_sort,\n    \"string\": soft_str,\n    \"striptags\": do_striptags,\n    \"sum\": do_sum,\n    \"title\": do_title,\n    \"trim\": do_trim,\n    \"truncate\": do_truncate,\n    \"unique\": do_unique,\n    \"upper\": do_upper,\n    \"urlencode\": do_urlencode,\n    \"urlize\": do_urlize,\n    \"wordcount\": do_wordcount,\n    \"wordwrap\": do_wordwrap,\n    \"xmlattr\": do_xmlattr,\n    \"tojson\": do_tojson,\n}\n", "src/jinja2/runtime.py": "\"\"\"The runtime functions and state used by compiled templates.\"\"\"\n\nimport functools\nimport sys\nimport typing as t\nfrom collections import abc\nfrom itertools import chain\n\nfrom markupsafe import escape  # noqa: F401\nfrom markupsafe import Markup\nfrom markupsafe import soft_str\n\nfrom .async_utils import auto_aiter\nfrom .async_utils import auto_await  # noqa: F401\nfrom .exceptions import TemplateNotFound  # noqa: F401\nfrom .exceptions import TemplateRuntimeError  # noqa: F401\nfrom .exceptions import UndefinedError\nfrom .nodes import EvalContext\nfrom .utils import _PassArg\nfrom .utils import concat\nfrom .utils import internalcode\nfrom .utils import missing\nfrom .utils import Namespace  # noqa: F401\nfrom .utils import object_type_repr\nfrom .utils import pass_eval_context\n\nV = t.TypeVar(\"V\")\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\nif t.TYPE_CHECKING:\n    import logging\n\n    import typing_extensions as te\n\n    from .environment import Environment\n\n    class LoopRenderFunc(te.Protocol):\n        def __call__(\n            self,\n            reciter: t.Iterable[V],\n            loop_render_func: \"LoopRenderFunc\",\n            depth: int = 0,\n        ) -> str: ...\n\n\n# these variables are exported to the template runtime\nexported = [\n    \"LoopContext\",\n    \"TemplateReference\",\n    \"Macro\",\n    \"Markup\",\n    \"TemplateRuntimeError\",\n    \"missing\",\n    \"escape\",\n    \"markup_join\",\n    \"str_join\",\n    \"identity\",\n    \"TemplateNotFound\",\n    \"Namespace\",\n    \"Undefined\",\n    \"internalcode\",\n]\nasync_exported = [\n    \"AsyncLoopContext\",\n    \"auto_aiter\",\n    \"auto_await\",\n]\n\n\ndef identity(x: V) -> V:\n    \"\"\"Returns its argument. Useful for certain things in the\n    environment.\n    \"\"\"\n    return x\n\n\ndef markup_join(seq: t.Iterable[t.Any]) -> str:\n    \"\"\"Concatenation that escapes if necessary and converts to string.\"\"\"\n    buf = []\n    iterator = map(soft_str, seq)\n    for arg in iterator:\n        buf.append(arg)\n        if hasattr(arg, \"__html__\"):\n            return Markup(\"\").join(chain(buf, iterator))\n    return concat(buf)\n\n\ndef str_join(seq: t.Iterable[t.Any]) -> str:\n    \"\"\"Simple args to string conversion and concatenation.\"\"\"\n    return concat(map(str, seq))\n\n\ndef new_context(\n    environment: \"Environment\",\n    template_name: t.Optional[str],\n    blocks: t.Dict[str, t.Callable[[\"Context\"], t.Iterator[str]]],\n    vars: t.Optional[t.Dict[str, t.Any]] = None,\n    shared: bool = False,\n    globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    locals: t.Optional[t.Mapping[str, t.Any]] = None,\n) -> \"Context\":\n    \"\"\"Internal helper for context creation.\"\"\"\n    if vars is None:\n        vars = {}\n    if shared:\n        parent = vars\n    else:\n        parent = dict(globals or (), **vars)\n    if locals:\n        # if the parent is shared a copy should be created because\n        # we don't want to modify the dict passed\n        if shared:\n            parent = dict(parent)\n        for key, value in locals.items():\n            if value is not missing:\n                parent[key] = value\n    return environment.context_class(\n        environment, parent, template_name, blocks, globals=globals\n    )\n\n\nclass TemplateReference:\n    \"\"\"The `self` in templates.\"\"\"\n\n    def __init__(self, context: \"Context\") -> None:\n        self.__context = context\n\n    def __getitem__(self, name: str) -> t.Any:\n        blocks = self.__context.blocks[name]\n        return BlockReference(name, self.__context, blocks, 0)\n\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.__context.name!r}>\"\n\n\ndef _dict_method_all(dict_method: F) -> F:\n    @functools.wraps(dict_method)\n    def f_all(self: \"Context\") -> t.Any:\n        return dict_method(self.get_all())\n\n    return t.cast(F, f_all)\n\n\n@abc.Mapping.register\nclass Context:\n    \"\"\"The template context holds the variables of a template.  It stores the\n    values passed to the template and also the names the template exports.\n    Creating instances is neither supported nor useful as it's created\n    automatically at various stages of the template evaluation and should not\n    be created by hand.\n\n    The context is immutable.  Modifications on :attr:`parent` **must not**\n    happen and modifications on :attr:`vars` are allowed from generated\n    template code only.  Template filters and global functions marked as\n    :func:`pass_context` get the active context passed as first argument\n    and are allowed to access the context read-only.\n\n    The template context supports read only dict operations (`get`,\n    `keys`, `values`, `items`, `iterkeys`, `itervalues`, `iteritems`,\n    `__getitem__`, `__contains__`).  Additionally there is a :meth:`resolve`\n    method that doesn't fail with a `KeyError` but returns an\n    :class:`Undefined` object for missing variables.\n    \"\"\"\n\n    def __init__(\n        self,\n        environment: \"Environment\",\n        parent: t.Dict[str, t.Any],\n        name: t.Optional[str],\n        blocks: t.Dict[str, t.Callable[[\"Context\"], t.Iterator[str]]],\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ):\n        self.parent = parent\n        self.vars: t.Dict[str, t.Any] = {}\n        self.environment: Environment = environment\n        self.eval_ctx = EvalContext(self.environment, name)\n        self.exported_vars: t.Set[str] = set()\n        self.name = name\n        self.globals_keys = set() if globals is None else set(globals)\n\n        # create the initial mapping of blocks.  Whenever template inheritance\n        # takes place the runtime will update this mapping with the new blocks\n        # from the template.\n        self.blocks = {k: [v] for k, v in blocks.items()}\n\n    def super(\n        self, name: str, current: t.Callable[[\"Context\"], t.Iterator[str]]\n    ) -> t.Union[\"BlockReference\", \"Undefined\"]:\n        \"\"\"Render a parent block.\"\"\"\n        try:\n            blocks = self.blocks[name]\n            index = blocks.index(current) + 1\n            blocks[index]\n        except LookupError:\n            return self.environment.undefined(\n                f\"there is no parent block called {name!r}.\", name=\"super\"\n            )\n        return BlockReference(name, self, blocks, index)\n\n    def get(self, key: str, default: t.Any = None) -> t.Any:\n        \"\"\"Look up a variable by name, or return a default if the key is\n        not found.\n\n        :param key: The variable name to look up.\n        :param default: The value to return if the key is not found.\n        \"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def resolve(self, key: str) -> t.Union[t.Any, \"Undefined\"]:\n        \"\"\"Look up a variable by name, or return an :class:`Undefined`\n        object if the key is not found.\n\n        If you need to add custom behavior, override\n        :meth:`resolve_or_missing`, not this method. The various lookup\n        functions use that method, not this one.\n\n        :param key: The variable name to look up.\n        \"\"\"\n        rv = self.resolve_or_missing(key)\n\n        if rv is missing:\n            return self.environment.undefined(name=key)\n\n        return rv\n\n    def resolve_or_missing(self, key: str) -> t.Any:\n        \"\"\"Look up a variable by name, or return a ``missing`` sentinel\n        if the key is not found.\n\n        Override this method to add custom lookup behavior.\n        :meth:`resolve`, :meth:`get`, and :meth:`__getitem__` use this\n        method. Don't call this method directly.\n\n        :param key: The variable name to look up.\n        \"\"\"\n        if key in self.vars:\n            return self.vars[key]\n\n        if key in self.parent:\n            return self.parent[key]\n\n        return missing\n\n    def get_exported(self) -> t.Dict[str, t.Any]:\n        \"\"\"Get a new dict with the exported variables.\"\"\"\n        return {k: self.vars[k] for k in self.exported_vars}\n\n    def get_all(self) -> t.Dict[str, t.Any]:\n        \"\"\"Return the complete context as dict including the exported\n        variables.  For optimizations reasons this might not return an\n        actual copy so be careful with using it.\n        \"\"\"\n        if not self.vars:\n            return self.parent\n        if not self.parent:\n            return self.vars\n        return dict(self.parent, **self.vars)\n\n    @internalcode\n    def call(\n        __self,  # noqa: B902\n        __obj: t.Callable[..., t.Any],\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> t.Union[t.Any, \"Undefined\"]:\n        \"\"\"Call the callable with the arguments and keyword arguments\n        provided but inject the active context or environment as first\n        argument if the callable has :func:`pass_context` or\n        :func:`pass_environment`.\n        \"\"\"\n        if __debug__:\n            __traceback_hide__ = True  # noqa\n\n        # Allow callable classes to take a context\n        if (\n            hasattr(__obj, \"__call__\")  # noqa: B004\n            and _PassArg.from_obj(__obj.__call__) is not None\n        ):\n            __obj = __obj.__call__\n\n        pass_arg = _PassArg.from_obj(__obj)\n\n        if pass_arg is _PassArg.context:\n            # the active context should have access to variables set in\n            # loops and blocks without mutating the context itself\n            if kwargs.get(\"_loop_vars\"):\n                __self = __self.derived(kwargs[\"_loop_vars\"])\n            if kwargs.get(\"_block_vars\"):\n                __self = __self.derived(kwargs[\"_block_vars\"])\n            args = (__self,) + args\n        elif pass_arg is _PassArg.eval_context:\n            args = (__self.eval_ctx,) + args\n        elif pass_arg is _PassArg.environment:\n            args = (__self.environment,) + args\n\n        kwargs.pop(\"_block_vars\", None)\n        kwargs.pop(\"_loop_vars\", None)\n\n        try:\n            return __obj(*args, **kwargs)\n        except StopIteration:\n            return __self.environment.undefined(\n                \"value was undefined because a callable raised a\"\n                \" StopIteration exception\"\n            )\n\n    def derived(self, locals: t.Optional[t.Dict[str, t.Any]] = None) -> \"Context\":\n        \"\"\"Internal helper function to create a derived context.  This is\n        used in situations where the system needs a new context in the same\n        template that is independent.\n        \"\"\"\n        context = new_context(\n            self.environment, self.name, {}, self.get_all(), True, None, locals\n        )\n        context.eval_ctx = self.eval_ctx\n        context.blocks.update((k, list(v)) for k, v in self.blocks.items())\n        return context\n\n    keys = _dict_method_all(dict.keys)\n    values = _dict_method_all(dict.values)\n    items = _dict_method_all(dict.items)\n\n    def __contains__(self, name: str) -> bool:\n        return name in self.vars or name in self.parent\n\n    def __getitem__(self, key: str) -> t.Any:\n        \"\"\"Look up a variable by name with ``[]`` syntax, or raise a\n        ``KeyError`` if the key is not found.\n        \"\"\"\n        item = self.resolve_or_missing(key)\n\n        if item is missing:\n            raise KeyError(key)\n\n        return item\n\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.get_all()!r} of {self.name!r}>\"\n\n\nclass BlockReference:\n    \"\"\"One block on a template reference.\"\"\"\n\n    def __init__(\n        self,\n        name: str,\n        context: \"Context\",\n        stack: t.List[t.Callable[[\"Context\"], t.Iterator[str]]],\n        depth: int,\n    ) -> None:\n        self.name = name\n        self._context = context\n        self._stack = stack\n        self._depth = depth\n\n    @property\n    def super(self) -> t.Union[\"BlockReference\", \"Undefined\"]:\n        \"\"\"Super the block.\"\"\"\n        if self._depth + 1 >= len(self._stack):\n            return self._context.environment.undefined(\n                f\"there is no parent block called {self.name!r}.\", name=\"super\"\n            )\n        return BlockReference(self.name, self._context, self._stack, self._depth + 1)\n\n    @internalcode\n    async def _async_call(self) -> str:\n        rv = concat(\n            [x async for x in self._stack[self._depth](self._context)]  # type: ignore\n        )\n\n        if self._context.eval_ctx.autoescape:\n            return Markup(rv)\n\n        return rv\n\n    @internalcode\n    def __call__(self) -> str:\n        if self._context.environment.is_async:\n            return self._async_call()  # type: ignore\n\n        rv = concat(self._stack[self._depth](self._context))\n\n        if self._context.eval_ctx.autoescape:\n            return Markup(rv)\n\n        return rv\n\n\nclass LoopContext:\n    \"\"\"A wrapper iterable for dynamic ``for`` loops, with information\n    about the loop and iteration.\n    \"\"\"\n\n    #: Current iteration of the loop, starting at 0.\n    index0 = -1\n\n    _length: t.Optional[int] = None\n    _after: t.Any = missing\n    _current: t.Any = missing\n    _before: t.Any = missing\n    _last_changed_value: t.Any = missing\n\n    def __init__(\n        self,\n        iterable: t.Iterable[V],\n        undefined: t.Type[\"Undefined\"],\n        recurse: t.Optional[\"LoopRenderFunc\"] = None,\n        depth0: int = 0,\n    ) -> None:\n        \"\"\"\n        :param iterable: Iterable to wrap.\n        :param undefined: :class:`Undefined` class to use for next and\n            previous items.\n        :param recurse: The function to render the loop body when the\n            loop is marked recursive.\n        :param depth0: Incremented when looping recursively.\n        \"\"\"\n        self._iterable = iterable\n        self._iterator = self._to_iterator(iterable)\n        self._undefined = undefined\n        self._recurse = recurse\n        #: How many levels deep a recursive loop currently is, starting at 0.\n        self.depth0 = depth0\n\n    @staticmethod\n    def _to_iterator(iterable: t.Iterable[V]) -> t.Iterator[V]:\n        return iter(iterable)\n\n    @property\n    def length(self) -> int:\n        \"\"\"Length of the iterable.\n\n        If the iterable is a generator or otherwise does not have a\n        size, it is eagerly evaluated to get a size.\n        \"\"\"\n        if self._length is not None:\n            return self._length\n\n        try:\n            self._length = len(self._iterable)  # type: ignore\n        except TypeError:\n            iterable = list(self._iterator)\n            self._iterator = self._to_iterator(iterable)\n            self._length = len(iterable) + self.index + (self._after is not missing)\n\n        return self._length\n\n    def __len__(self) -> int:\n        return self.length\n\n    @property\n    def depth(self) -> int:\n        \"\"\"How many levels deep a recursive loop currently is, starting at 1.\"\"\"\n        return self.depth0 + 1\n\n    @property\n    def index(self) -> int:\n        \"\"\"Current iteration of the loop, starting at 1.\"\"\"\n        return self.index0 + 1\n\n    @property\n    def revindex0(self) -> int:\n        \"\"\"Number of iterations from the end of the loop, ending at 0.\n\n        Requires calculating :attr:`length`.\n        \"\"\"\n        return self.length - self.index\n\n    @property\n    def revindex(self) -> int:\n        \"\"\"Number of iterations from the end of the loop, ending at 1.\n\n        Requires calculating :attr:`length`.\n        \"\"\"\n        return self.length - self.index0\n\n    @property\n    def first(self) -> bool:\n        \"\"\"Whether this is the first iteration of the loop.\"\"\"\n        return self.index0 == 0\n\n    def _peek_next(self) -> t.Any:\n        \"\"\"Return the next element in the iterable, or :data:`missing`\n        if the iterable is exhausted. Only peeks one item ahead, caching\n        the result in :attr:`_last` for use in subsequent checks. The\n        cache is reset when :meth:`__next__` is called.\n        \"\"\"\n        if self._after is not missing:\n            return self._after\n\n        self._after = next(self._iterator, missing)\n        return self._after\n\n    @property\n    def last(self) -> bool:\n        \"\"\"Whether this is the last iteration of the loop.\n\n        Causes the iterable to advance early. See\n        :func:`itertools.groupby` for issues this can cause.\n        The :func:`groupby` filter avoids that issue.\n        \"\"\"\n        return self._peek_next() is missing\n\n    @property\n    def previtem(self) -> t.Union[t.Any, \"Undefined\"]:\n        \"\"\"The item in the previous iteration. Undefined during the\n        first iteration.\n        \"\"\"\n        if self.first:\n            return self._undefined(\"there is no previous item\")\n\n        return self._before\n\n    @property\n    def nextitem(self) -> t.Union[t.Any, \"Undefined\"]:\n        \"\"\"The item in the next iteration. Undefined during the last\n        iteration.\n\n        Causes the iterable to advance early. See\n        :func:`itertools.groupby` for issues this can cause.\n        The :func:`jinja-filters.groupby` filter avoids that issue.\n        \"\"\"\n        rv = self._peek_next()\n\n        if rv is missing:\n            return self._undefined(\"there is no next item\")\n\n        return rv\n\n    def cycle(self, *args: V) -> V:\n        \"\"\"Return a value from the given args, cycling through based on\n        the current :attr:`index0`.\n\n        :param args: One or more values to cycle through.\n        \"\"\"\n        if not args:\n            raise TypeError(\"no items for cycling given\")\n\n        return args[self.index0 % len(args)]\n\n    def changed(self, *value: t.Any) -> bool:\n        \"\"\"Return ``True`` if previously called with a different value\n        (including when called for the first time).\n\n        :param value: One or more values to compare to the last call.\n        \"\"\"\n        if self._last_changed_value != value:\n            self._last_changed_value = value\n            return True\n\n        return False\n\n    def __iter__(self) -> \"LoopContext\":\n        return self\n\n    def __next__(self) -> t.Tuple[t.Any, \"LoopContext\"]:\n        if self._after is not missing:\n            rv = self._after\n            self._after = missing\n        else:\n            rv = next(self._iterator)\n\n        self.index0 += 1\n        self._before = self._current\n        self._current = rv\n        return rv, self\n\n    @internalcode\n    def __call__(self, iterable: t.Iterable[V]) -> str:\n        \"\"\"When iterating over nested data, render the body of the loop\n        recursively with the given inner iterable data.\n\n        The loop must have the ``recursive`` marker for this to work.\n        \"\"\"\n        if self._recurse is None:\n            raise TypeError(\n                \"The loop must have the 'recursive' marker to be called recursively.\"\n            )\n\n        return self._recurse(iterable, self._recurse, depth=self.depth)\n\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self.index}/{self.length}>\"\n\n\nclass AsyncLoopContext(LoopContext):\n    _iterator: t.AsyncIterator[t.Any]  # type: ignore\n\n    @staticmethod\n    def _to_iterator(  # type: ignore\n        iterable: t.Union[t.Iterable[V], t.AsyncIterable[V]],\n    ) -> t.AsyncIterator[V]:\n        return auto_aiter(iterable)\n\n    @property\n    async def length(self) -> int:  # type: ignore\n        if self._length is not None:\n            return self._length\n\n        try:\n            self._length = len(self._iterable)  # type: ignore\n        except TypeError:\n            iterable = [x async for x in self._iterator]\n            self._iterator = self._to_iterator(iterable)\n            self._length = len(iterable) + self.index + (self._after is not missing)\n\n        return self._length\n\n    @property\n    async def revindex0(self) -> int:  # type: ignore\n        return await self.length - self.index\n\n    @property\n    async def revindex(self) -> int:  # type: ignore\n        return await self.length - self.index0\n\n    async def _peek_next(self) -> t.Any:\n        if self._after is not missing:\n            return self._after\n\n        try:\n            self._after = await self._iterator.__anext__()\n        except StopAsyncIteration:\n            self._after = missing\n\n        return self._after\n\n    @property\n    async def last(self) -> bool:  # type: ignore\n        return await self._peek_next() is missing\n\n    @property\n    async def nextitem(self) -> t.Union[t.Any, \"Undefined\"]:\n        rv = await self._peek_next()\n\n        if rv is missing:\n            return self._undefined(\"there is no next item\")\n\n        return rv\n\n    def __aiter__(self) -> \"AsyncLoopContext\":\n        return self\n\n    async def __anext__(self) -> t.Tuple[t.Any, \"AsyncLoopContext\"]:\n        if self._after is not missing:\n            rv = self._after\n            self._after = missing\n        else:\n            rv = await self._iterator.__anext__()\n\n        self.index0 += 1\n        self._before = self._current\n        self._current = rv\n        return rv, self\n\n\nclass Macro:\n    \"\"\"Wraps a macro function.\"\"\"\n\n    def __init__(\n        self,\n        environment: \"Environment\",\n        func: t.Callable[..., str],\n        name: str,\n        arguments: t.List[str],\n        catch_kwargs: bool,\n        catch_varargs: bool,\n        caller: bool,\n        default_autoescape: t.Optional[bool] = None,\n    ):\n        self._environment = environment\n        self._func = func\n        self._argument_count = len(arguments)\n        self.name = name\n        self.arguments = arguments\n        self.catch_kwargs = catch_kwargs\n        self.catch_varargs = catch_varargs\n        self.caller = caller\n        self.explicit_caller = \"caller\" in arguments\n\n        if default_autoescape is None:\n            if callable(environment.autoescape):\n                default_autoescape = environment.autoescape(None)\n            else:\n                default_autoescape = environment.autoescape\n\n        self._default_autoescape = default_autoescape\n\n    @internalcode\n    @pass_eval_context\n    def __call__(self, *args: t.Any, **kwargs: t.Any) -> str:\n        # This requires a bit of explanation,  In the past we used to\n        # decide largely based on compile-time information if a macro is\n        # safe or unsafe.  While there was a volatile mode it was largely\n        # unused for deciding on escaping.  This turns out to be\n        # problematic for macros because whether a macro is safe depends not\n        # on the escape mode when it was defined, but rather when it was used.\n        #\n        # Because however we export macros from the module system and\n        # there are historic callers that do not pass an eval context (and\n        # will continue to not pass one), we need to perform an instance\n        # check here.\n        #\n        # This is considered safe because an eval context is not a valid\n        # argument to callables otherwise anyway.  Worst case here is\n        # that if no eval context is passed we fall back to the compile\n        # time autoescape flag.\n        if args and isinstance(args[0], EvalContext):\n            autoescape = args[0].autoescape\n            args = args[1:]\n        else:\n            autoescape = self._default_autoescape\n\n        # try to consume the positional arguments\n        arguments = list(args[: self._argument_count])\n        off = len(arguments)\n\n        # For information why this is necessary refer to the handling\n        # of caller in the `macro_body` handler in the compiler.\n        found_caller = False\n\n        # if the number of arguments consumed is not the number of\n        # arguments expected we start filling in keyword arguments\n        # and defaults.\n        if off != self._argument_count:\n            for name in self.arguments[len(arguments) :]:\n                try:\n                    value = kwargs.pop(name)\n                except KeyError:\n                    value = missing\n                if name == \"caller\":\n                    found_caller = True\n                arguments.append(value)\n        else:\n            found_caller = self.explicit_caller\n\n        # it's important that the order of these arguments does not change\n        # if not also changed in the compiler's `function_scoping` method.\n        # the order is caller, keyword arguments, positional arguments!\n        if self.caller and not found_caller:\n            caller = kwargs.pop(\"caller\", None)\n            if caller is None:\n                caller = self._environment.undefined(\"No caller defined\", name=\"caller\")\n            arguments.append(caller)\n\n        if self.catch_kwargs:\n            arguments.append(kwargs)\n        elif kwargs:\n            if \"caller\" in kwargs:\n                raise TypeError(\n                    f\"macro {self.name!r} was invoked with two values for the special\"\n                    \" caller argument. This is most likely a bug.\"\n                )\n            raise TypeError(\n                f\"macro {self.name!r} takes no keyword argument {next(iter(kwargs))!r}\"\n            )\n        if self.catch_varargs:\n            arguments.append(args[self._argument_count :])\n        elif len(args) > self._argument_count:\n            raise TypeError(\n                f\"macro {self.name!r} takes not more than\"\n                f\" {len(self.arguments)} argument(s)\"\n            )\n\n        return self._invoke(arguments, autoescape)\n\n    async def _async_invoke(self, arguments: t.List[t.Any], autoescape: bool) -> str:\n        rv = await self._func(*arguments)  # type: ignore\n\n        if autoescape:\n            return Markup(rv)\n\n        return rv  # type: ignore\n\n    def _invoke(self, arguments: t.List[t.Any], autoescape: bool) -> str:\n        if self._environment.is_async:\n            return self._async_invoke(arguments, autoescape)  # type: ignore\n\n        rv = self._func(*arguments)\n\n        if autoescape:\n            rv = Markup(rv)\n\n        return rv\n\n    def __repr__(self) -> str:\n        name = \"anonymous\" if self.name is None else repr(self.name)\n        return f\"<{type(self).__name__} {name}>\"\n\n\nclass Undefined:\n    \"\"\"The default undefined type.  This undefined type can be printed and\n    iterated over, but every other access will raise an :exc:`UndefinedError`:\n\n    >>> foo = Undefined(name='foo')\n    >>> str(foo)\n    ''\n    >>> not foo\n    True\n    >>> foo + 42\n    Traceback (most recent call last):\n      ...\n    jinja2.exceptions.UndefinedError: 'foo' is undefined\n    \"\"\"\n\n    __slots__ = (\n        \"_undefined_hint\",\n        \"_undefined_obj\",\n        \"_undefined_name\",\n        \"_undefined_exception\",\n    )\n\n    def __init__(\n        self,\n        hint: t.Optional[str] = None,\n        obj: t.Any = missing,\n        name: t.Optional[str] = None,\n        exc: t.Type[TemplateRuntimeError] = UndefinedError,\n    ) -> None:\n        self._undefined_hint = hint\n        self._undefined_obj = obj\n        self._undefined_name = name\n        self._undefined_exception = exc\n\n    @property\n    def _undefined_message(self) -> str:\n        \"\"\"Build a message about the undefined value based on how it was\n        accessed.\n        \"\"\"\n        if self._undefined_hint:\n            return self._undefined_hint\n\n        if self._undefined_obj is missing:\n            return f\"{self._undefined_name!r} is undefined\"\n\n        if not isinstance(self._undefined_name, str):\n            return (\n                f\"{object_type_repr(self._undefined_obj)} has no\"\n                f\" element {self._undefined_name!r}\"\n            )\n\n        return (\n            f\"{object_type_repr(self._undefined_obj)!r} has no\"\n            f\" attribute {self._undefined_name!r}\"\n        )\n\n    @internalcode\n    def _fail_with_undefined_error(\n        self, *args: t.Any, **kwargs: t.Any\n    ) -> \"te.NoReturn\":\n        \"\"\"Raise an :exc:`UndefinedError` when operations are performed\n        on the undefined value.\n        \"\"\"\n        raise self._undefined_exception(self._undefined_message)\n\n    @internalcode\n    def __getattr__(self, name: str) -> t.Any:\n        if name[:2] == \"__\":\n            raise AttributeError(name)\n\n        return self._fail_with_undefined_error()\n\n    __add__ = __radd__ = __sub__ = __rsub__ = _fail_with_undefined_error\n    __mul__ = __rmul__ = __div__ = __rdiv__ = _fail_with_undefined_error\n    __truediv__ = __rtruediv__ = _fail_with_undefined_error\n    __floordiv__ = __rfloordiv__ = _fail_with_undefined_error\n    __mod__ = __rmod__ = _fail_with_undefined_error\n    __pos__ = __neg__ = _fail_with_undefined_error\n    __call__ = __getitem__ = _fail_with_undefined_error\n    __lt__ = __le__ = __gt__ = __ge__ = _fail_with_undefined_error\n    __int__ = __float__ = __complex__ = _fail_with_undefined_error\n    __pow__ = __rpow__ = _fail_with_undefined_error\n\n    def __eq__(self, other: t.Any) -> bool:\n        return type(self) is type(other)\n\n    def __ne__(self, other: t.Any) -> bool:\n        return not self.__eq__(other)\n\n    def __hash__(self) -> int:\n        return id(type(self))\n\n    def __str__(self) -> str:\n        return \"\"\n\n    def __len__(self) -> int:\n        return 0\n\n    def __iter__(self) -> t.Iterator[t.Any]:\n        yield from ()\n\n    async def __aiter__(self) -> t.AsyncIterator[t.Any]:\n        for _ in ():\n            yield\n\n    def __bool__(self) -> bool:\n        return False\n\n    def __repr__(self) -> str:\n        return \"Undefined\"\n\n\ndef make_logging_undefined(\n    logger: t.Optional[\"logging.Logger\"] = None, base: t.Type[Undefined] = Undefined\n) -> t.Type[Undefined]:\n    \"\"\"Given a logger object this returns a new undefined class that will\n    log certain failures.  It will log iterations and printing.  If no\n    logger is given a default logger is created.\n\n    Example::\n\n        logger = logging.getLogger(__name__)\n        LoggingUndefined = make_logging_undefined(\n            logger=logger,\n            base=Undefined\n        )\n\n    .. versionadded:: 2.8\n\n    :param logger: the logger to use.  If not provided, a default logger\n                   is created.\n    :param base: the base class to add logging functionality to.  This\n                 defaults to :class:`Undefined`.\n    \"\"\"\n    if logger is None:\n        import logging\n\n        logger = logging.getLogger(__name__)\n        logger.addHandler(logging.StreamHandler(sys.stderr))\n\n    def _log_message(undef: Undefined) -> None:\n        logger.warning(\"Template variable warning: %s\", undef._undefined_message)\n\n    class LoggingUndefined(base):  # type: ignore\n        __slots__ = ()\n\n        def _fail_with_undefined_error(  # type: ignore\n            self, *args: t.Any, **kwargs: t.Any\n        ) -> \"te.NoReturn\":\n            try:\n                super()._fail_with_undefined_error(*args, **kwargs)\n            except self._undefined_exception as e:\n                logger.error(\"Template variable error: %s\", e)  # type: ignore\n                raise e\n\n        def __str__(self) -> str:\n            _log_message(self)\n            return super().__str__()  # type: ignore\n\n        def __iter__(self) -> t.Iterator[t.Any]:\n            _log_message(self)\n            return super().__iter__()  # type: ignore\n\n        def __bool__(self) -> bool:\n            _log_message(self)\n            return super().__bool__()  # type: ignore\n\n    return LoggingUndefined\n\n\nclass ChainableUndefined(Undefined):\n    \"\"\"An undefined that is chainable, where both ``__getattr__`` and\n    ``__getitem__`` return itself rather than raising an\n    :exc:`UndefinedError`.\n\n    >>> foo = ChainableUndefined(name='foo')\n    >>> str(foo.bar['baz'])\n    ''\n    >>> foo.bar['baz'] + 42\n    Traceback (most recent call last):\n      ...\n    jinja2.exceptions.UndefinedError: 'foo' is undefined\n\n    .. versionadded:: 2.11.0\n    \"\"\"\n\n    __slots__ = ()\n\n    def __html__(self) -> str:\n        return str(self)\n\n    def __getattr__(self, _: str) -> \"ChainableUndefined\":\n        return self\n\n    __getitem__ = __getattr__  # type: ignore\n\n\nclass DebugUndefined(Undefined):\n    \"\"\"An undefined that returns the debug info when printed.\n\n    >>> foo = DebugUndefined(name='foo')\n    >>> str(foo)\n    '{{ foo }}'\n    >>> not foo\n    True\n    >>> foo + 42\n    Traceback (most recent call last):\n      ...\n    jinja2.exceptions.UndefinedError: 'foo' is undefined\n    \"\"\"\n\n    __slots__ = ()\n\n    def __str__(self) -> str:\n        if self._undefined_hint:\n            message = f\"undefined value printed: {self._undefined_hint}\"\n\n        elif self._undefined_obj is missing:\n            message = self._undefined_name  # type: ignore\n\n        else:\n            message = (\n                f\"no such element: {object_type_repr(self._undefined_obj)}\"\n                f\"[{self._undefined_name!r}]\"\n            )\n\n        return f\"{{{{ {message} }}}}\"\n\n\nclass StrictUndefined(Undefined):\n    \"\"\"An undefined that barks on print and iteration as well as boolean\n    tests and all kinds of comparisons.  In other words: you can do nothing\n    with it except checking if it's defined using the `defined` test.\n\n    >>> foo = StrictUndefined(name='foo')\n    >>> str(foo)\n    Traceback (most recent call last):\n      ...\n    jinja2.exceptions.UndefinedError: 'foo' is undefined\n    >>> not foo\n    Traceback (most recent call last):\n      ...\n    jinja2.exceptions.UndefinedError: 'foo' is undefined\n    >>> foo + 42\n    Traceback (most recent call last):\n      ...\n    jinja2.exceptions.UndefinedError: 'foo' is undefined\n    \"\"\"\n\n    __slots__ = ()\n    __iter__ = __str__ = __len__ = Undefined._fail_with_undefined_error\n    __eq__ = __ne__ = __bool__ = __hash__ = Undefined._fail_with_undefined_error\n    __contains__ = Undefined._fail_with_undefined_error\n\n\n# Remove slots attributes, after the metaclass is applied they are\n# unneeded and contain wrong data for subclasses.\ndel (\n    Undefined.__slots__,\n    ChainableUndefined.__slots__,\n    DebugUndefined.__slots__,\n    StrictUndefined.__slots__,\n)\n", "src/jinja2/sandbox.py": "\"\"\"A sandbox layer that ensures unsafe operations cannot be performed.\nUseful when the template itself comes from an untrusted source.\n\"\"\"\n\nimport operator\nimport types\nimport typing as t\nfrom _string import formatter_field_name_split  # type: ignore\nfrom collections import abc\nfrom collections import deque\nfrom string import Formatter\n\nfrom markupsafe import EscapeFormatter\nfrom markupsafe import Markup\n\nfrom .environment import Environment\nfrom .exceptions import SecurityError\nfrom .runtime import Context\nfrom .runtime import Undefined\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\n#: maximum number of items a range may produce\nMAX_RANGE = 100000\n\n#: Unsafe function attributes.\nUNSAFE_FUNCTION_ATTRIBUTES: t.Set[str] = set()\n\n#: Unsafe method attributes. Function attributes are unsafe for methods too.\nUNSAFE_METHOD_ATTRIBUTES: t.Set[str] = set()\n\n#: unsafe generator attributes.\nUNSAFE_GENERATOR_ATTRIBUTES = {\"gi_frame\", \"gi_code\"}\n\n#: unsafe attributes on coroutines\nUNSAFE_COROUTINE_ATTRIBUTES = {\"cr_frame\", \"cr_code\"}\n\n#: unsafe attributes on async generators\nUNSAFE_ASYNC_GENERATOR_ATTRIBUTES = {\"ag_code\", \"ag_frame\"}\n\n_mutable_spec: t.Tuple[t.Tuple[t.Type[t.Any], t.FrozenSet[str]], ...] = (\n    (\n        abc.MutableSet,\n        frozenset(\n            [\n                \"add\",\n                \"clear\",\n                \"difference_update\",\n                \"discard\",\n                \"pop\",\n                \"remove\",\n                \"symmetric_difference_update\",\n                \"update\",\n            ]\n        ),\n    ),\n    (\n        abc.MutableMapping,\n        frozenset([\"clear\", \"pop\", \"popitem\", \"setdefault\", \"update\"]),\n    ),\n    (\n        abc.MutableSequence,\n        frozenset([\"append\", \"reverse\", \"insert\", \"sort\", \"extend\", \"remove\"]),\n    ),\n    (\n        deque,\n        frozenset(\n            [\n                \"append\",\n                \"appendleft\",\n                \"clear\",\n                \"extend\",\n                \"extendleft\",\n                \"pop\",\n                \"popleft\",\n                \"remove\",\n                \"rotate\",\n            ]\n        ),\n    ),\n)\n\n\ndef inspect_format_method(callable: t.Callable[..., t.Any]) -> t.Optional[str]:\n    if not isinstance(\n        callable, (types.MethodType, types.BuiltinMethodType)\n    ) or callable.__name__ not in (\"format\", \"format_map\"):\n        return None\n\n    obj = callable.__self__\n\n    if isinstance(obj, str):\n        return obj\n\n    return None\n\n\ndef safe_range(*args: int) -> range:\n    \"\"\"A range that can't generate ranges with a length of more than\n    MAX_RANGE items.\n    \"\"\"\n    rng = range(*args)\n\n    if len(rng) > MAX_RANGE:\n        raise OverflowError(\n            \"Range too big. The sandbox blocks ranges larger than\"\n            f\" MAX_RANGE ({MAX_RANGE}).\"\n        )\n\n    return rng\n\n\ndef unsafe(f: F) -> F:\n    \"\"\"Marks a function or method as unsafe.\n\n    .. code-block: python\n\n        @unsafe\n        def delete(self):\n            pass\n    \"\"\"\n    f.unsafe_callable = True  # type: ignore\n    return f\n\n\ndef is_internal_attribute(obj: t.Any, attr: str) -> bool:\n    \"\"\"Test if the attribute given is an internal python attribute.  For\n    example this function returns `True` for the `func_code` attribute of\n    python objects.  This is useful if the environment method\n    :meth:`~SandboxedEnvironment.is_safe_attribute` is overridden.\n\n    >>> from jinja2.sandbox import is_internal_attribute\n    >>> is_internal_attribute(str, \"mro\")\n    True\n    >>> is_internal_attribute(str, \"upper\")\n    False\n    \"\"\"\n    if isinstance(obj, types.FunctionType):\n        if attr in UNSAFE_FUNCTION_ATTRIBUTES:\n            return True\n    elif isinstance(obj, types.MethodType):\n        if attr in UNSAFE_FUNCTION_ATTRIBUTES or attr in UNSAFE_METHOD_ATTRIBUTES:\n            return True\n    elif isinstance(obj, type):\n        if attr == \"mro\":\n            return True\n    elif isinstance(obj, (types.CodeType, types.TracebackType, types.FrameType)):\n        return True\n    elif isinstance(obj, types.GeneratorType):\n        if attr in UNSAFE_GENERATOR_ATTRIBUTES:\n            return True\n    elif hasattr(types, \"CoroutineType\") and isinstance(obj, types.CoroutineType):\n        if attr in UNSAFE_COROUTINE_ATTRIBUTES:\n            return True\n    elif hasattr(types, \"AsyncGeneratorType\") and isinstance(\n        obj, types.AsyncGeneratorType\n    ):\n        if attr in UNSAFE_ASYNC_GENERATOR_ATTRIBUTES:\n            return True\n    return attr.startswith(\"__\")\n\n\ndef modifies_known_mutable(obj: t.Any, attr: str) -> bool:\n    \"\"\"This function checks if an attribute on a builtin mutable object\n    (list, dict, set or deque) or the corresponding ABCs would modify it\n    if called.\n\n    >>> modifies_known_mutable({}, \"clear\")\n    True\n    >>> modifies_known_mutable({}, \"keys\")\n    False\n    >>> modifies_known_mutable([], \"append\")\n    True\n    >>> modifies_known_mutable([], \"index\")\n    False\n\n    If called with an unsupported object, ``False`` is returned.\n\n    >>> modifies_known_mutable(\"foo\", \"upper\")\n    False\n    \"\"\"\n    for typespec, unsafe in _mutable_spec:\n        if isinstance(obj, typespec):\n            return attr in unsafe\n    return False\n\n\nclass SandboxedEnvironment(Environment):\n    \"\"\"The sandboxed environment.  It works like the regular environment but\n    tells the compiler to generate sandboxed code.  Additionally subclasses of\n    this environment may override the methods that tell the runtime what\n    attributes or functions are safe to access.\n\n    If the template tries to access insecure code a :exc:`SecurityError` is\n    raised.  However also other exceptions may occur during the rendering so\n    the caller has to ensure that all exceptions are caught.\n    \"\"\"\n\n    sandboxed = True\n\n    #: default callback table for the binary operators.  A copy of this is\n    #: available on each instance of a sandboxed environment as\n    #: :attr:`binop_table`\n    default_binop_table: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {\n        \"+\": operator.add,\n        \"-\": operator.sub,\n        \"*\": operator.mul,\n        \"/\": operator.truediv,\n        \"//\": operator.floordiv,\n        \"**\": operator.pow,\n        \"%\": operator.mod,\n    }\n\n    #: default callback table for the unary operators.  A copy of this is\n    #: available on each instance of a sandboxed environment as\n    #: :attr:`unop_table`\n    default_unop_table: t.Dict[str, t.Callable[[t.Any], t.Any]] = {\n        \"+\": operator.pos,\n        \"-\": operator.neg,\n    }\n\n    #: a set of binary operators that should be intercepted.  Each operator\n    #: that is added to this set (empty by default) is delegated to the\n    #: :meth:`call_binop` method that will perform the operator.  The default\n    #: operator callback is specified by :attr:`binop_table`.\n    #:\n    #: The following binary operators are interceptable:\n    #: ``//``, ``%``, ``+``, ``*``, ``-``, ``/``, and ``**``\n    #:\n    #: The default operation form the operator table corresponds to the\n    #: builtin function.  Intercepted calls are always slower than the native\n    #: operator call, so make sure only to intercept the ones you are\n    #: interested in.\n    #:\n    #: .. versionadded:: 2.6\n    intercepted_binops: t.FrozenSet[str] = frozenset()\n\n    #: a set of unary operators that should be intercepted.  Each operator\n    #: that is added to this set (empty by default) is delegated to the\n    #: :meth:`call_unop` method that will perform the operator.  The default\n    #: operator callback is specified by :attr:`unop_table`.\n    #:\n    #: The following unary operators are interceptable: ``+``, ``-``\n    #:\n    #: The default operation form the operator table corresponds to the\n    #: builtin function.  Intercepted calls are always slower than the native\n    #: operator call, so make sure only to intercept the ones you are\n    #: interested in.\n    #:\n    #: .. versionadded:: 2.6\n    intercepted_unops: t.FrozenSet[str] = frozenset()\n\n    def __init__(self, *args: t.Any, **kwargs: t.Any) -> None:\n        super().__init__(*args, **kwargs)\n        self.globals[\"range\"] = safe_range\n        self.binop_table = self.default_binop_table.copy()\n        self.unop_table = self.default_unop_table.copy()\n\n    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:\n        \"\"\"The sandboxed environment will call this method to check if the\n        attribute of an object is safe to access.  Per default all attributes\n        starting with an underscore are considered private as well as the\n        special attributes of internal python objects as returned by the\n        :func:`is_internal_attribute` function.\n        \"\"\"\n        return not (attr.startswith(\"_\") or is_internal_attribute(obj, attr))\n\n    def is_safe_callable(self, obj: t.Any) -> bool:\n        \"\"\"Check if an object is safely callable. By default callables\n        are considered safe unless decorated with :func:`unsafe`.\n\n        This also recognizes the Django convention of setting\n        ``func.alters_data = True``.\n        \"\"\"\n        return not (\n            getattr(obj, \"unsafe_callable\", False) or getattr(obj, \"alters_data\", False)\n        )\n\n    def call_binop(\n        self, context: Context, operator: str, left: t.Any, right: t.Any\n    ) -> t.Any:\n        \"\"\"For intercepted binary operator calls (:meth:`intercepted_binops`)\n        this function is executed instead of the builtin operator.  This can\n        be used to fine tune the behavior of certain operators.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return self.binop_table[operator](left, right)\n\n    def call_unop(self, context: Context, operator: str, arg: t.Any) -> t.Any:\n        \"\"\"For intercepted unary operator calls (:meth:`intercepted_unops`)\n        this function is executed instead of the builtin operator.  This can\n        be used to fine tune the behavior of certain operators.\n\n        .. versionadded:: 2.6\n        \"\"\"\n        return self.unop_table[operator](arg)\n\n    def getitem(\n        self, obj: t.Any, argument: t.Union[str, t.Any]\n    ) -> t.Union[t.Any, Undefined]:\n        \"\"\"Subscribe an object from sandboxed code.\"\"\"\n        try:\n            return obj[argument]\n        except (TypeError, LookupError):\n            if isinstance(argument, str):\n                try:\n                    attr = str(argument)\n                except Exception:\n                    pass\n                else:\n                    try:\n                        value = getattr(obj, attr)\n                    except AttributeError:\n                        pass\n                    else:\n                        if self.is_safe_attribute(obj, argument, value):\n                            return value\n                        return self.unsafe_undefined(obj, argument)\n        return self.undefined(obj=obj, name=argument)\n\n    def getattr(self, obj: t.Any, attribute: str) -> t.Union[t.Any, Undefined]:\n        \"\"\"Subscribe an object from sandboxed code and prefer the\n        attribute.  The attribute passed *must* be a bytestring.\n        \"\"\"\n        try:\n            value = getattr(obj, attribute)\n        except AttributeError:\n            try:\n                return obj[attribute]\n            except (TypeError, LookupError):\n                pass\n        else:\n            if self.is_safe_attribute(obj, attribute, value):\n                return value\n            return self.unsafe_undefined(obj, attribute)\n        return self.undefined(obj=obj, name=attribute)\n\n    def unsafe_undefined(self, obj: t.Any, attribute: str) -> Undefined:\n        \"\"\"Return an undefined object for unsafe attributes.\"\"\"\n        return self.undefined(\n            f\"access to attribute {attribute!r} of\"\n            f\" {type(obj).__name__!r} object is unsafe.\",\n            name=attribute,\n            obj=obj,\n            exc=SecurityError,\n        )\n\n    def format_string(\n        self,\n        s: str,\n        args: t.Tuple[t.Any, ...],\n        kwargs: t.Dict[str, t.Any],\n        format_func: t.Optional[t.Callable[..., t.Any]] = None,\n    ) -> str:\n        \"\"\"If a format call is detected, then this is routed through this\n        method so that our safety sandbox can be used for it.\n        \"\"\"\n        formatter: SandboxedFormatter\n        if isinstance(s, Markup):\n            formatter = SandboxedEscapeFormatter(self, escape=s.escape)\n        else:\n            formatter = SandboxedFormatter(self)\n\n        if format_func is not None and format_func.__name__ == \"format_map\":\n            if len(args) != 1 or kwargs:\n                raise TypeError(\n                    \"format_map() takes exactly one argument\"\n                    f\" {len(args) + (kwargs is not None)} given\"\n                )\n\n            kwargs = args[0]\n            args = ()\n\n        rv = formatter.vformat(s, args, kwargs)\n        return type(s)(rv)\n\n    def call(\n        __self,  # noqa: B902\n        __context: Context,\n        __obj: t.Any,\n        *args: t.Any,\n        **kwargs: t.Any,\n    ) -> t.Any:\n        \"\"\"Call an object from sandboxed code.\"\"\"\n        fmt = inspect_format_method(__obj)\n        if fmt is not None:\n            return __self.format_string(fmt, args, kwargs, __obj)\n\n        # the double prefixes are to avoid double keyword argument\n        # errors when proxying the call.\n        if not __self.is_safe_callable(__obj):\n            raise SecurityError(f\"{__obj!r} is not safely callable\")\n        return __context.call(__obj, *args, **kwargs)\n\n\nclass ImmutableSandboxedEnvironment(SandboxedEnvironment):\n    \"\"\"Works exactly like the regular `SandboxedEnvironment` but does not\n    permit modifications on the builtin mutable objects `list`, `set`, and\n    `dict` by using the :func:`modifies_known_mutable` function.\n    \"\"\"\n\n    def is_safe_attribute(self, obj: t.Any, attr: str, value: t.Any) -> bool:\n        if not super().is_safe_attribute(obj, attr, value):\n            return False\n\n        return not modifies_known_mutable(obj, attr)\n\n\nclass SandboxedFormatter(Formatter):\n    def __init__(self, env: Environment, **kwargs: t.Any) -> None:\n        self._env = env\n        super().__init__(**kwargs)\n\n    def get_field(\n        self, field_name: str, args: t.Sequence[t.Any], kwargs: t.Mapping[str, t.Any]\n    ) -> t.Tuple[t.Any, str]:\n        first, rest = formatter_field_name_split(field_name)\n        obj = self.get_value(first, args, kwargs)\n        for is_attr, i in rest:\n            if is_attr:\n                obj = self._env.getattr(obj, i)\n            else:\n                obj = self._env.getitem(obj, i)\n        return obj, first\n\n\nclass SandboxedEscapeFormatter(SandboxedFormatter, EscapeFormatter):\n    pass\n", "src/jinja2/exceptions.py": "import typing as t\n\nif t.TYPE_CHECKING:\n    from .runtime import Undefined\n\n\nclass TemplateError(Exception):\n    \"\"\"Baseclass for all template errors.\"\"\"\n\n    def __init__(self, message: t.Optional[str] = None) -> None:\n        super().__init__(message)\n\n    @property\n    def message(self) -> t.Optional[str]:\n        return self.args[0] if self.args else None\n\n\nclass TemplateNotFound(IOError, LookupError, TemplateError):\n    \"\"\"Raised if a template does not exist.\n\n    .. versionchanged:: 2.11\n        If the given name is :class:`Undefined` and no message was\n        provided, an :exc:`UndefinedError` is raised.\n    \"\"\"\n\n    # Silence the Python warning about message being deprecated since\n    # it's not valid here.\n    message: t.Optional[str] = None\n\n    def __init__(\n        self,\n        name: t.Optional[t.Union[str, \"Undefined\"]],\n        message: t.Optional[str] = None,\n    ) -> None:\n        IOError.__init__(self, name)\n\n        if message is None:\n            from .runtime import Undefined\n\n            if isinstance(name, Undefined):\n                name._fail_with_undefined_error()\n\n            message = name\n\n        self.message = message\n        self.name = name\n        self.templates = [name]\n\n    def __str__(self) -> str:\n        return str(self.message)\n\n\nclass TemplatesNotFound(TemplateNotFound):\n    \"\"\"Like :class:`TemplateNotFound` but raised if multiple templates\n    are selected.  This is a subclass of :class:`TemplateNotFound`\n    exception, so just catching the base exception will catch both.\n\n    .. versionchanged:: 2.11\n        If a name in the list of names is :class:`Undefined`, a message\n        about it being undefined is shown rather than the empty string.\n\n    .. versionadded:: 2.2\n    \"\"\"\n\n    def __init__(\n        self,\n        names: t.Sequence[t.Union[str, \"Undefined\"]] = (),\n        message: t.Optional[str] = None,\n    ) -> None:\n        if message is None:\n            from .runtime import Undefined\n\n            parts = []\n\n            for name in names:\n                if isinstance(name, Undefined):\n                    parts.append(name._undefined_message)\n                else:\n                    parts.append(name)\n\n            parts_str = \", \".join(map(str, parts))\n            message = f\"none of the templates given were found: {parts_str}\"\n\n        super().__init__(names[-1] if names else None, message)\n        self.templates = list(names)\n\n\nclass TemplateSyntaxError(TemplateError):\n    \"\"\"Raised to tell the user that there is a problem with the template.\"\"\"\n\n    def __init__(\n        self,\n        message: str,\n        lineno: int,\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n    ) -> None:\n        super().__init__(message)\n        self.lineno = lineno\n        self.name = name\n        self.filename = filename\n        self.source: t.Optional[str] = None\n\n        # this is set to True if the debug.translate_syntax_error\n        # function translated the syntax error into a new traceback\n        self.translated = False\n\n    def __str__(self) -> str:\n        # for translated errors we only return the message\n        if self.translated:\n            return t.cast(str, self.message)\n\n        # otherwise attach some stuff\n        location = f\"line {self.lineno}\"\n        name = self.filename or self.name\n        if name:\n            location = f'File \"{name}\", {location}'\n        lines = [t.cast(str, self.message), \"  \" + location]\n\n        # if the source is set, add the line to the output\n        if self.source is not None:\n            try:\n                line = self.source.splitlines()[self.lineno - 1]\n            except IndexError:\n                pass\n            else:\n                lines.append(\"    \" + line.strip())\n\n        return \"\\n\".join(lines)\n\n    def __reduce__(self):  # type: ignore\n        # https://bugs.python.org/issue1692335 Exceptions that take\n        # multiple required arguments have problems with pickling.\n        # Without this, raises TypeError: __init__() missing 1 required\n        # positional argument: 'lineno'\n        return self.__class__, (self.message, self.lineno, self.name, self.filename)\n\n\nclass TemplateAssertionError(TemplateSyntaxError):\n    \"\"\"Like a template syntax error, but covers cases where something in the\n    template caused an error at compile time that wasn't necessarily caused\n    by a syntax error.  However it's a direct subclass of\n    :exc:`TemplateSyntaxError` and has the same attributes.\n    \"\"\"\n\n\nclass TemplateRuntimeError(TemplateError):\n    \"\"\"A generic runtime error in the template engine.  Under some situations\n    Jinja may raise this exception.\n    \"\"\"\n\n\nclass UndefinedError(TemplateRuntimeError):\n    \"\"\"Raised if a template tries to operate on :class:`Undefined`.\"\"\"\n\n\nclass SecurityError(TemplateRuntimeError):\n    \"\"\"Raised if a template tries to do something insecure if the\n    sandbox is enabled.\n    \"\"\"\n\n\nclass FilterArgumentError(TemplateRuntimeError):\n    \"\"\"This error is raised if a filter was called with inappropriate\n    arguments\n    \"\"\"\n", "src/jinja2/nativetypes.py": "import typing as t\nfrom ast import literal_eval\nfrom ast import parse\nfrom itertools import chain\nfrom itertools import islice\nfrom types import GeneratorType\n\nfrom . import nodes\nfrom .compiler import CodeGenerator\nfrom .compiler import Frame\nfrom .compiler import has_safe_repr\nfrom .environment import Environment\nfrom .environment import Template\n\n\ndef native_concat(values: t.Iterable[t.Any]) -> t.Optional[t.Any]:\n    \"\"\"Return a native Python type from the list of compiled nodes. If\n    the result is a single node, its value is returned. Otherwise, the\n    nodes are concatenated as strings. If the result can be parsed with\n    :func:`ast.literal_eval`, the parsed value is returned. Otherwise,\n    the string is returned.\n\n    :param values: Iterable of outputs to concatenate.\n    \"\"\"\n    head = list(islice(values, 2))\n\n    if not head:\n        return None\n\n    if len(head) == 1:\n        raw = head[0]\n        if not isinstance(raw, str):\n            return raw\n    else:\n        if isinstance(values, GeneratorType):\n            values = chain(head, values)\n        raw = \"\".join([str(v) for v in values])\n\n    try:\n        return literal_eval(\n            # In Python 3.10+ ast.literal_eval removes leading spaces/tabs\n            # from the given string. For backwards compatibility we need to\n            # parse the string ourselves without removing leading spaces/tabs.\n            parse(raw, mode=\"eval\")\n        )\n    except (ValueError, SyntaxError, MemoryError):\n        return raw\n\n\nclass NativeCodeGenerator(CodeGenerator):\n    \"\"\"A code generator which renders Python types by not adding\n    ``str()`` around output nodes.\n    \"\"\"\n\n    @staticmethod\n    def _default_finalize(value: t.Any) -> t.Any:\n        return value\n\n    def _output_const_repr(self, group: t.Iterable[t.Any]) -> str:\n        return repr(\"\".join([str(v) for v in group]))\n\n    def _output_child_to_const(\n        self, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo\n    ) -> t.Any:\n        const = node.as_const(frame.eval_ctx)\n\n        if not has_safe_repr(const):\n            raise nodes.Impossible()\n\n        if isinstance(node, nodes.TemplateData):\n            return const\n\n        return finalize.const(const)  # type: ignore\n\n    def _output_child_pre(\n        self, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo\n    ) -> None:\n        if finalize.src is not None:\n            self.write(finalize.src)\n\n    def _output_child_post(\n        self, node: nodes.Expr, frame: Frame, finalize: CodeGenerator._FinalizeInfo\n    ) -> None:\n        if finalize.src is not None:\n            self.write(\")\")\n\n\nclass NativeEnvironment(Environment):\n    \"\"\"An environment that renders templates to native Python types.\"\"\"\n\n    code_generator_class = NativeCodeGenerator\n    concat = staticmethod(native_concat)  # type: ignore\n\n\nclass NativeTemplate(Template):\n    environment_class = NativeEnvironment\n\n    def render(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Render the template to produce a native Python type. If the\n        result is a single node, its value is returned. Otherwise, the\n        nodes are concatenated as strings. If the result can be parsed\n        with :func:`ast.literal_eval`, the parsed value is returned.\n        Otherwise, the string is returned.\n        \"\"\"\n        ctx = self.new_context(dict(*args, **kwargs))\n\n        try:\n            return self.environment_class.concat(  # type: ignore\n                self.root_render_func(ctx)\n            )\n        except Exception:\n            return self.environment.handle_exception()\n\n    async def render_async(self, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        if not self.environment.is_async:\n            raise RuntimeError(\n                \"The environment was not created with async mode enabled.\"\n            )\n\n        ctx = self.new_context(dict(*args, **kwargs))\n\n        try:\n            return self.environment_class.concat(  # type: ignore\n                [n async for n in self.root_render_func(ctx)]  # type: ignore\n            )\n        except Exception:\n            return self.environment.handle_exception()\n\n\nNativeEnvironment.template_class = NativeTemplate\n", "src/jinja2/_identifier.py": "import re\n\n# generated by scripts/generate_identifier_pattern.py\npattern = re.compile(\n    r\"[\\w\u00b7\u0300-\u036f\u0387\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u064b-\u065f\u0670\u06d6-\u06dc\u06df-\u06e4\u06e7\u06e8\u06ea-\u06ed\u0711\u0730-\u074a\u07a6-\u07b0\u07eb-\u07f3\u07fd\u0816-\u0819\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0859-\u085b\u08d3-\u08e1\u08e3-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962\u0963\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09cb-\u09cd\u09d7\u09e2\u09e3\u09fe\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a70\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2\u0ae3\u0afa-\u0aff\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b62\u0b63\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0c00-\u0c04\u0c3e-\u0c44\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62\u0c63\u0c81-\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2\u0ce3\u0d00-\u0d03\u0d3b\u0d3c\u0d3e-\u0d44\u0d46-\u0d48\u0d4a-\u0d4d\u0d57\u0d62\u0d63\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e31\u0e34-\u0e3a\u0e47-\u0e4e\u0eb1\u0eb4-\u0eb9\u0ebb\u0ebc\u0ec8-\u0ecd\u0f18\u0f19\u0f35\u0f37\u0f39\u0f3e\u0f3f\u0f71-\u0f84\u0f86\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u102b-\u103e\u1056-\u1059\u105e-\u1060\u1062-\u1064\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f\u109a-\u109d\u135d-\u135f\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17b4-\u17d3\u17dd\u180b-\u180d\u1885\u1886\u18a9\u1920-\u192b\u1930-\u193b\u1a17-\u1a1b\u1a55-\u1a5e\u1a60-\u1a7c\u1a7f\u1ab0-\u1abd\u1b00-\u1b04\u1b34-\u1b44\u1b6b-\u1b73\u1b80-\u1b82\u1ba1-\u1bad\u1be6-\u1bf3\u1c24-\u1c37\u1cd0-\u1cd2\u1cd4-\u1ce8\u1ced\u1cf2-\u1cf4\u1cf7-\u1cf9\u1dc0-\u1df9\u1dfb-\u1dff\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2118\u212e\u2cef-\u2cf1\u2d7f\u2de0-\u2dff\u302a-\u302f\u3099\u309a\ua66f\ua674-\ua67d\ua69e\ua69f\ua6f0\ua6f1\ua802\ua806\ua80b\ua823-\ua827\ua880\ua881\ua8b4-\ua8c5\ua8e0-\ua8f1\ua8ff\ua926-\ua92d\ua947-\ua953\ua980-\ua983\ua9b3-\ua9c0\ua9e5\uaa29-\uaa36\uaa43\uaa4c\uaa4d\uaa7b-\uaa7d\uaab0\uaab2-\uaab4\uaab7\uaab8\uaabe\uaabf\uaac1\uaaeb-\uaaef\uaaf5\uaaf6\uabe3-\uabea\uabec\uabed\ufb1e\ufe00-\ufe0f\ufe20-\ufe2f\ufe33\ufe34\ufe4d-\ufe4f\uff3f\ud800\uddfd\ud800\udee0\ud800\udf76-\ud800\udf7a\ud802\ude01-\ud802\ude03\ud802\ude05\ud802\ude06\ud802\ude0c-\ud802\ude0f\ud802\ude38-\ud802\ude3a\ud802\ude3f\ud802\udee5\ud802\udee6\ud803\udd24-\ud803\udd27\ud803\udf46-\ud803\udf50\ud804\udc00-\ud804\udc02\ud804\udc38-\ud804\udc46\ud804\udc7f-\ud804\udc82\ud804\udcb0-\ud804\udcba\ud804\udd00-\ud804\udd02\ud804\udd27-\ud804\udd34\ud804\udd45\ud804\udd46\ud804\udd73\ud804\udd80-\ud804\udd82\ud804\uddb3-\ud804\uddc0\ud804\uddc9-\ud804\uddcc\ud804\ude2c-\ud804\ude37\ud804\ude3e\ud804\udedf-\ud804\udeea\ud804\udf00-\ud804\udf03\ud804\udf3b\ud804\udf3c\ud804\udf3e-\ud804\udf44\ud804\udf47\ud804\udf48\ud804\udf4b-\ud804\udf4d\ud804\udf57\ud804\udf62\ud804\udf63\ud804\udf66-\ud804\udf6c\ud804\udf70-\ud804\udf74\ud805\udc35-\ud805\udc46\ud805\udc5e\ud805\udcb0-\ud805\udcc3\ud805\uddaf-\ud805\uddb5\ud805\uddb8-\ud805\uddc0\ud805\udddc\ud805\udddd\ud805\ude30-\ud805\ude40\ud805\udeab-\ud805\udeb7\ud805\udf1d-\ud805\udf2b\ud806\udc2c-\ud806\udc3a\ud806\ude01-\ud806\ude0a\ud806\ude33-\ud806\ude39\ud806\ude3b-\ud806\ude3e\ud806\ude47\ud806\ude51-\ud806\ude5b\ud806\ude8a-\ud806\ude99\ud807\udc2f-\ud807\udc36\ud807\udc38-\ud807\udc3f\ud807\udc92-\ud807\udca7\ud807\udca9-\ud807\udcb6\ud807\udd31-\ud807\udd36\ud807\udd3a\ud807\udd3c\ud807\udd3d\ud807\udd3f-\ud807\udd45\ud807\udd47\ud807\udd8a-\ud807\udd8e\ud807\udd90\ud807\udd91\ud807\udd93-\ud807\udd97\ud807\udef3-\ud807\udef6\ud81a\udef0-\ud81a\udef4\ud81a\udf30-\ud81a\udf36\ud81b\udf51-\ud81b\udf7e\ud81b\udf8f-\ud81b\udf92\ud82f\udc9d\ud82f\udc9e\ud834\udd65-\ud834\udd69\ud834\udd6d-\ud834\udd72\ud834\udd7b-\ud834\udd82\ud834\udd85-\ud834\udd8b\ud834\uddaa-\ud834\uddad\ud834\ude42-\ud834\ude44\ud836\ude00-\ud836\ude36\ud836\ude3b-\ud836\ude6c\ud836\ude75\ud836\ude84\ud836\ude9b-\ud836\ude9f\ud836\udea1-\ud836\udeaf\ud838\udc00-\ud838\udc06\ud838\udc08-\ud838\udc18\ud838\udc1b-\ud838\udc21\ud838\udc23\ud838\udc24\ud838\udc26-\ud838\udc2a\ud83a\udcd0-\ud83a\udcd6\ud83a\udd44-\ud83a\udd4a\udb40\udd00-\udb40\uddef]+\"  # noqa: B950\n)\n", "src/jinja2/utils.py": "import enum\nimport json\nimport os\nimport re\nimport typing as t\nfrom collections import abc\nfrom collections import deque\nfrom random import choice\nfrom random import randrange\nfrom threading import Lock\nfrom types import CodeType\nfrom urllib.parse import quote_from_bytes\n\nimport markupsafe\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\nF = t.TypeVar(\"F\", bound=t.Callable[..., t.Any])\n\n# special singleton representing missing values for the runtime\nmissing: t.Any = type(\"MissingType\", (), {\"__repr__\": lambda x: \"missing\"})()\n\ninternal_code: t.MutableSet[CodeType] = set()\n\nconcat = \"\".join\n\n\ndef pass_context(f: F) -> F:\n    \"\"\"Pass the :class:`~jinja2.runtime.Context` as the first argument\n    to the decorated function when called while rendering a template.\n\n    Can be used on functions, filters, and tests.\n\n    If only ``Context.eval_context`` is needed, use\n    :func:`pass_eval_context`. If only ``Context.environment`` is\n    needed, use :func:`pass_environment`.\n\n    .. versionadded:: 3.0.0\n        Replaces ``contextfunction`` and ``contextfilter``.\n    \"\"\"\n    f.jinja_pass_arg = _PassArg.context  # type: ignore\n    return f\n\n\ndef pass_eval_context(f: F) -> F:\n    \"\"\"Pass the :class:`~jinja2.nodes.EvalContext` as the first argument\n    to the decorated function when called while rendering a template.\n    See :ref:`eval-context`.\n\n    Can be used on functions, filters, and tests.\n\n    If only ``EvalContext.environment`` is needed, use\n    :func:`pass_environment`.\n\n    .. versionadded:: 3.0.0\n        Replaces ``evalcontextfunction`` and ``evalcontextfilter``.\n    \"\"\"\n    f.jinja_pass_arg = _PassArg.eval_context  # type: ignore\n    return f\n\n\ndef pass_environment(f: F) -> F:\n    \"\"\"Pass the :class:`~jinja2.Environment` as the first argument to\n    the decorated function when called while rendering a template.\n\n    Can be used on functions, filters, and tests.\n\n    .. versionadded:: 3.0.0\n        Replaces ``environmentfunction`` and ``environmentfilter``.\n    \"\"\"\n    f.jinja_pass_arg = _PassArg.environment  # type: ignore\n    return f\n\n\nclass _PassArg(enum.Enum):\n    context = enum.auto()\n    eval_context = enum.auto()\n    environment = enum.auto()\n\n    @classmethod\n    def from_obj(cls, obj: F) -> t.Optional[\"_PassArg\"]:\n        if hasattr(obj, \"jinja_pass_arg\"):\n            return obj.jinja_pass_arg  # type: ignore\n\n        return None\n\n\ndef internalcode(f: F) -> F:\n    \"\"\"Marks the function as internally used\"\"\"\n    internal_code.add(f.__code__)\n    return f\n\n\ndef is_undefined(obj: t.Any) -> bool:\n    \"\"\"Check if the object passed is undefined.  This does nothing more than\n    performing an instance check against :class:`Undefined` but looks nicer.\n    This can be used for custom filters or tests that want to react to\n    undefined variables.  For example a custom default filter can look like\n    this::\n\n        def default(var, default=''):\n            if is_undefined(var):\n                return default\n            return var\n    \"\"\"\n    from .runtime import Undefined\n\n    return isinstance(obj, Undefined)\n\n\ndef consume(iterable: t.Iterable[t.Any]) -> None:\n    \"\"\"Consumes an iterable without doing anything with it.\"\"\"\n    for _ in iterable:\n        pass\n\n\ndef clear_caches() -> None:\n    \"\"\"Jinja keeps internal caches for environments and lexers.  These are\n    used so that Jinja doesn't have to recreate environments and lexers all\n    the time.  Normally you don't have to care about that but if you are\n    measuring memory consumption you may want to clean the caches.\n    \"\"\"\n    from .environment import get_spontaneous_environment\n    from .lexer import _lexer_cache\n\n    get_spontaneous_environment.cache_clear()\n    _lexer_cache.clear()\n\n\ndef import_string(import_name: str, silent: bool = False) -> t.Any:\n    \"\"\"Imports an object based on a string.  This is useful if you want to\n    use import paths as endpoints or something similar.  An import path can\n    be specified either in dotted notation (``xml.sax.saxutils.escape``)\n    or with a colon as object delimiter (``xml.sax.saxutils:escape``).\n\n    If the `silent` is True the return value will be `None` if the import\n    fails.\n\n    :return: imported object\n    \"\"\"\n    try:\n        if \":\" in import_name:\n            module, obj = import_name.split(\":\", 1)\n        elif \".\" in import_name:\n            module, _, obj = import_name.rpartition(\".\")\n        else:\n            return __import__(import_name)\n        return getattr(__import__(module, None, None, [obj]), obj)\n    except (ImportError, AttributeError):\n        if not silent:\n            raise\n\n\ndef open_if_exists(filename: str, mode: str = \"rb\") -> t.Optional[t.IO[t.Any]]:\n    \"\"\"Returns a file descriptor for the filename if that file exists,\n    otherwise ``None``.\n    \"\"\"\n    if not os.path.isfile(filename):\n        return None\n\n    return open(filename, mode)\n\n\ndef object_type_repr(obj: t.Any) -> str:\n    \"\"\"Returns the name of the object's type.  For some recognized\n    singletons the name of the object is returned instead. (For\n    example for `None` and `Ellipsis`).\n    \"\"\"\n    if obj is None:\n        return \"None\"\n    elif obj is Ellipsis:\n        return \"Ellipsis\"\n\n    cls = type(obj)\n\n    if cls.__module__ == \"builtins\":\n        return f\"{cls.__name__} object\"\n\n    return f\"{cls.__module__}.{cls.__name__} object\"\n\n\ndef pformat(obj: t.Any) -> str:\n    \"\"\"Format an object using :func:`pprint.pformat`.\"\"\"\n    from pprint import pformat\n\n    return pformat(obj)\n\n\n_http_re = re.compile(\n    r\"\"\"\n    ^\n    (\n        (https?://|www\\.)  # scheme or www\n        (([\\w%-]+\\.)+)?  # subdomain\n        (\n            [a-z]{2,63}  # basic tld\n        |\n            xn--[\\w%]{2,59}  # idna tld\n        )\n    |\n        ([\\w%-]{2,63}\\.)+  # basic domain\n        (com|net|int|edu|gov|org|info|mil)  # basic tld\n    |\n        (https?://)  # scheme\n        (\n            (([\\d]{1,3})(\\.[\\d]{1,3}){3})  # IPv4\n        |\n            (\\[([\\da-f]{0,4}:){2}([\\da-f]{0,4}:?){1,6}])  # IPv6\n        )\n    )\n    (?::[\\d]{1,5})?  # port\n    (?:[/?#]\\S*)?  # path, query, and fragment\n    $\n    \"\"\",\n    re.IGNORECASE | re.VERBOSE,\n)\n_email_re = re.compile(r\"^\\S+@\\w[\\w.-]*\\.\\w+$\")\n\n\ndef urlize(\n    text: str,\n    trim_url_limit: t.Optional[int] = None,\n    rel: t.Optional[str] = None,\n    target: t.Optional[str] = None,\n    extra_schemes: t.Optional[t.Iterable[str]] = None,\n) -> str:\n    \"\"\"Convert URLs in text into clickable links.\n\n    This may not recognize links in some situations. Usually, a more\n    comprehensive formatter, such as a Markdown library, is a better\n    choice.\n\n    Works on ``http://``, ``https://``, ``www.``, ``mailto:``, and email\n    addresses. Links with trailing punctuation (periods, commas, closing\n    parentheses) and leading punctuation (opening parentheses) are\n    recognized excluding the punctuation. Email addresses that include\n    header fields are not recognized (for example,\n    ``mailto:address@example.com?cc=copy@example.com``).\n\n    :param text: Original text containing URLs to link.\n    :param trim_url_limit: Shorten displayed URL values to this length.\n    :param target: Add the ``target`` attribute to links.\n    :param rel: Add the ``rel`` attribute to links.\n    :param extra_schemes: Recognize URLs that start with these schemes\n        in addition to the default behavior.\n\n    .. versionchanged:: 3.0\n        The ``extra_schemes`` parameter was added.\n\n    .. versionchanged:: 3.0\n        Generate ``https://`` links for URLs without a scheme.\n\n    .. versionchanged:: 3.0\n        The parsing rules were updated. Recognize email addresses with\n        or without the ``mailto:`` scheme. Validate IP addresses. Ignore\n        parentheses and brackets in more cases.\n    \"\"\"\n    if trim_url_limit is not None:\n\n        def trim_url(x: str) -> str:\n            if len(x) > trim_url_limit:\n                return f\"{x[:trim_url_limit]}...\"\n\n            return x\n\n    else:\n\n        def trim_url(x: str) -> str:\n            return x\n\n    words = re.split(r\"(\\s+)\", str(markupsafe.escape(text)))\n    rel_attr = f' rel=\"{markupsafe.escape(rel)}\"' if rel else \"\"\n    target_attr = f' target=\"{markupsafe.escape(target)}\"' if target else \"\"\n\n    for i, word in enumerate(words):\n        head, middle, tail = \"\", word, \"\"\n        match = re.match(r\"^([(<]|&lt;)+\", middle)\n\n        if match:\n            head = match.group()\n            middle = middle[match.end() :]\n\n        # Unlike lead, which is anchored to the start of the string,\n        # need to check that the string ends with any of the characters\n        # before trying to match all of them, to avoid backtracking.\n        if middle.endswith((\")\", \">\", \".\", \",\", \"\\n\", \"&gt;\")):\n            match = re.search(r\"([)>.,\\n]|&gt;)+$\", middle)\n\n            if match:\n                tail = match.group()\n                middle = middle[: match.start()]\n\n        # Prefer balancing parentheses in URLs instead of ignoring a\n        # trailing character.\n        for start_char, end_char in (\"(\", \")\"), (\"<\", \">\"), (\"&lt;\", \"&gt;\"):\n            start_count = middle.count(start_char)\n\n            if start_count <= middle.count(end_char):\n                # Balanced, or lighter on the left\n                continue\n\n            # Move as many as possible from the tail to balance\n            for _ in range(min(start_count, tail.count(end_char))):\n                end_index = tail.index(end_char) + len(end_char)\n                # Move anything in the tail before the end char too\n                middle += tail[:end_index]\n                tail = tail[end_index:]\n\n        if _http_re.match(middle):\n            if middle.startswith(\"https://\") or middle.startswith(\"http://\"):\n                middle = (\n                    f'<a href=\"{middle}\"{rel_attr}{target_attr}>{trim_url(middle)}</a>'\n                )\n            else:\n                middle = (\n                    f'<a href=\"https://{middle}\"{rel_attr}{target_attr}>'\n                    f\"{trim_url(middle)}</a>\"\n                )\n\n        elif middle.startswith(\"mailto:\") and _email_re.match(middle[7:]):\n            middle = f'<a href=\"{middle}\">{middle[7:]}</a>'\n\n        elif (\n            \"@\" in middle\n            and not middle.startswith(\"www.\")\n            and \":\" not in middle\n            and _email_re.match(middle)\n        ):\n            middle = f'<a href=\"mailto:{middle}\">{middle}</a>'\n\n        elif extra_schemes is not None:\n            for scheme in extra_schemes:\n                if middle != scheme and middle.startswith(scheme):\n                    middle = f'<a href=\"{middle}\"{rel_attr}{target_attr}>{middle}</a>'\n\n        words[i] = f\"{head}{middle}{tail}\"\n\n    return \"\".join(words)\n\n\ndef generate_lorem_ipsum(\n    n: int = 5, html: bool = True, min: int = 20, max: int = 100\n) -> str:\n    \"\"\"Generate some lorem ipsum for the template.\"\"\"\n    from .constants import LOREM_IPSUM_WORDS\n\n    words = LOREM_IPSUM_WORDS.split()\n    result = []\n\n    for _ in range(n):\n        next_capitalized = True\n        last_comma = last_fullstop = 0\n        word = None\n        last = None\n        p = []\n\n        # each paragraph contains out of 20 to 100 words.\n        for idx, _ in enumerate(range(randrange(min, max))):\n            while True:\n                word = choice(words)\n                if word != last:\n                    last = word\n                    break\n            if next_capitalized:\n                word = word.capitalize()\n                next_capitalized = False\n            # add commas\n            if idx - randrange(3, 8) > last_comma:\n                last_comma = idx\n                last_fullstop += 2\n                word += \",\"\n            # add end of sentences\n            if idx - randrange(10, 20) > last_fullstop:\n                last_comma = last_fullstop = idx\n                word += \".\"\n                next_capitalized = True\n            p.append(word)\n\n        # ensure that the paragraph ends with a dot.\n        p_str = \" \".join(p)\n\n        if p_str.endswith(\",\"):\n            p_str = p_str[:-1] + \".\"\n        elif not p_str.endswith(\".\"):\n            p_str += \".\"\n\n        result.append(p_str)\n\n    if not html:\n        return \"\\n\\n\".join(result)\n    return markupsafe.Markup(\n        \"\\n\".join(f\"<p>{markupsafe.escape(x)}</p>\" for x in result)\n    )\n\n\ndef url_quote(obj: t.Any, charset: str = \"utf-8\", for_qs: bool = False) -> str:\n    \"\"\"Quote a string for use in a URL using the given charset.\n\n    :param obj: String or bytes to quote. Other types are converted to\n        string then encoded to bytes using the given charset.\n    :param charset: Encode text to bytes using this charset.\n    :param for_qs: Quote \"/\" and use \"+\" for spaces.\n    \"\"\"\n    if not isinstance(obj, bytes):\n        if not isinstance(obj, str):\n            obj = str(obj)\n\n        obj = obj.encode(charset)\n\n    safe = b\"\" if for_qs else b\"/\"\n    rv = quote_from_bytes(obj, safe)\n\n    if for_qs:\n        rv = rv.replace(\"%20\", \"+\")\n\n    return rv\n\n\n@abc.MutableMapping.register\nclass LRUCache:\n    \"\"\"A simple LRU Cache implementation.\"\"\"\n\n    # this is fast for small capacities (something below 1000) but doesn't\n    # scale.  But as long as it's only used as storage for templates this\n    # won't do any harm.\n\n    def __init__(self, capacity: int) -> None:\n        self.capacity = capacity\n        self._mapping: t.Dict[t.Any, t.Any] = {}\n        self._queue: te.Deque[t.Any] = deque()\n        self._postinit()\n\n    def _postinit(self) -> None:\n        # alias all queue methods for faster lookup\n        self._popleft = self._queue.popleft\n        self._pop = self._queue.pop\n        self._remove = self._queue.remove\n        self._wlock = Lock()\n        self._append = self._queue.append\n\n    def __getstate__(self) -> t.Mapping[str, t.Any]:\n        return {\n            \"capacity\": self.capacity,\n            \"_mapping\": self._mapping,\n            \"_queue\": self._queue,\n        }\n\n    def __setstate__(self, d: t.Mapping[str, t.Any]) -> None:\n        self.__dict__.update(d)\n        self._postinit()\n\n    def __getnewargs__(self) -> t.Tuple[t.Any, ...]:\n        return (self.capacity,)\n\n    def copy(self) -> \"LRUCache\":\n        \"\"\"Return a shallow copy of the instance.\"\"\"\n        rv = self.__class__(self.capacity)\n        rv._mapping.update(self._mapping)\n        rv._queue.extend(self._queue)\n        return rv\n\n    def get(self, key: t.Any, default: t.Any = None) -> t.Any:\n        \"\"\"Return an item from the cache dict or `default`\"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            return default\n\n    def setdefault(self, key: t.Any, default: t.Any = None) -> t.Any:\n        \"\"\"Set `default` if the key is not in the cache otherwise\n        leave unchanged. Return the value of this key.\n        \"\"\"\n        try:\n            return self[key]\n        except KeyError:\n            self[key] = default\n            return default\n\n    def clear(self) -> None:\n        \"\"\"Clear the cache.\"\"\"\n        with self._wlock:\n            self._mapping.clear()\n            self._queue.clear()\n\n    def __contains__(self, key: t.Any) -> bool:\n        \"\"\"Check if a key exists in this cache.\"\"\"\n        return key in self._mapping\n\n    def __len__(self) -> int:\n        \"\"\"Return the current size of the cache.\"\"\"\n        return len(self._mapping)\n\n    def __repr__(self) -> str:\n        return f\"<{type(self).__name__} {self._mapping!r}>\"\n\n    def __getitem__(self, key: t.Any) -> t.Any:\n        \"\"\"Get an item from the cache. Moves the item up so that it has the\n        highest priority then.\n\n        Raise a `KeyError` if it does not exist.\n        \"\"\"\n        with self._wlock:\n            rv = self._mapping[key]\n\n            if self._queue[-1] != key:\n                try:\n                    self._remove(key)\n                except ValueError:\n                    # if something removed the key from the container\n                    # when we read, ignore the ValueError that we would\n                    # get otherwise.\n                    pass\n\n                self._append(key)\n\n            return rv\n\n    def __setitem__(self, key: t.Any, value: t.Any) -> None:\n        \"\"\"Sets the value for an item. Moves the item up so that it\n        has the highest priority then.\n        \"\"\"\n        with self._wlock:\n            if key in self._mapping:\n                self._remove(key)\n            elif len(self._mapping) == self.capacity:\n                del self._mapping[self._popleft()]\n\n            self._append(key)\n            self._mapping[key] = value\n\n    def __delitem__(self, key: t.Any) -> None:\n        \"\"\"Remove an item from the cache dict.\n        Raise a `KeyError` if it does not exist.\n        \"\"\"\n        with self._wlock:\n            del self._mapping[key]\n\n            try:\n                self._remove(key)\n            except ValueError:\n                pass\n\n    def items(self) -> t.Iterable[t.Tuple[t.Any, t.Any]]:\n        \"\"\"Return a list of items.\"\"\"\n        result = [(key, self._mapping[key]) for key in list(self._queue)]\n        result.reverse()\n        return result\n\n    def values(self) -> t.Iterable[t.Any]:\n        \"\"\"Return a list of all values.\"\"\"\n        return [x[1] for x in self.items()]\n\n    def keys(self) -> t.Iterable[t.Any]:\n        \"\"\"Return a list of all keys ordered by most recent usage.\"\"\"\n        return list(self)\n\n    def __iter__(self) -> t.Iterator[t.Any]:\n        return reversed(tuple(self._queue))\n\n    def __reversed__(self) -> t.Iterator[t.Any]:\n        \"\"\"Iterate over the keys in the cache dict, oldest items\n        coming first.\n        \"\"\"\n        return iter(tuple(self._queue))\n\n    __copy__ = copy\n\n\ndef select_autoescape(\n    enabled_extensions: t.Collection[str] = (\"html\", \"htm\", \"xml\"),\n    disabled_extensions: t.Collection[str] = (),\n    default_for_string: bool = True,\n    default: bool = False,\n) -> t.Callable[[t.Optional[str]], bool]:\n    \"\"\"Intelligently sets the initial value of autoescaping based on the\n    filename of the template.  This is the recommended way to configure\n    autoescaping if you do not want to write a custom function yourself.\n\n    If you want to enable it for all templates created from strings or\n    for all templates with `.html` and `.xml` extensions::\n\n        from jinja2 import Environment, select_autoescape\n        env = Environment(autoescape=select_autoescape(\n            enabled_extensions=('html', 'xml'),\n            default_for_string=True,\n        ))\n\n    Example configuration to turn it on at all times except if the template\n    ends with `.txt`::\n\n        from jinja2 import Environment, select_autoescape\n        env = Environment(autoescape=select_autoescape(\n            disabled_extensions=('txt',),\n            default_for_string=True,\n            default=True,\n        ))\n\n    The `enabled_extensions` is an iterable of all the extensions that\n    autoescaping should be enabled for.  Likewise `disabled_extensions` is\n    a list of all templates it should be disabled for.  If a template is\n    loaded from a string then the default from `default_for_string` is used.\n    If nothing matches then the initial value of autoescaping is set to the\n    value of `default`.\n\n    For security reasons this function operates case insensitive.\n\n    .. versionadded:: 2.9\n    \"\"\"\n    enabled_patterns = tuple(f\".{x.lstrip('.').lower()}\" for x in enabled_extensions)\n    disabled_patterns = tuple(f\".{x.lstrip('.').lower()}\" for x in disabled_extensions)\n\n    def autoescape(template_name: t.Optional[str]) -> bool:\n        if template_name is None:\n            return default_for_string\n        template_name = template_name.lower()\n        if template_name.endswith(enabled_patterns):\n            return True\n        if template_name.endswith(disabled_patterns):\n            return False\n        return default\n\n    return autoescape\n\n\ndef htmlsafe_json_dumps(\n    obj: t.Any, dumps: t.Optional[t.Callable[..., str]] = None, **kwargs: t.Any\n) -> markupsafe.Markup:\n    \"\"\"Serialize an object to a string of JSON with :func:`json.dumps`,\n    then replace HTML-unsafe characters with Unicode escapes and mark\n    the result safe with :class:`~markupsafe.Markup`.\n\n    This is available in templates as the ``|tojson`` filter.\n\n    The following characters are escaped: ``<``, ``>``, ``&``, ``'``.\n\n    The returned string is safe to render in HTML documents and\n    ``<script>`` tags. The exception is in HTML attributes that are\n    double quoted; either use single quotes or the ``|forceescape``\n    filter.\n\n    :param obj: The object to serialize to JSON.\n    :param dumps: The ``dumps`` function to use. Defaults to\n        ``env.policies[\"json.dumps_function\"]``, which defaults to\n        :func:`json.dumps`.\n    :param kwargs: Extra arguments to pass to ``dumps``. Merged onto\n        ``env.policies[\"json.dumps_kwargs\"]``.\n\n    .. versionchanged:: 3.0\n        The ``dumper`` parameter is renamed to ``dumps``.\n\n    .. versionadded:: 2.9\n    \"\"\"\n    if dumps is None:\n        dumps = json.dumps\n\n    return markupsafe.Markup(\n        dumps(obj, **kwargs)\n        .replace(\"<\", \"\\\\u003c\")\n        .replace(\">\", \"\\\\u003e\")\n        .replace(\"&\", \"\\\\u0026\")\n        .replace(\"'\", \"\\\\u0027\")\n    )\n\n\nclass Cycler:\n    \"\"\"Cycle through values by yield them one at a time, then restarting\n    once the end is reached. Available as ``cycler`` in templates.\n\n    Similar to ``loop.cycle``, but can be used outside loops or across\n    multiple loops. For example, render a list of folders and files in a\n    list, alternating giving them \"odd\" and \"even\" classes.\n\n    .. code-block:: html+jinja\n\n        {% set row_class = cycler(\"odd\", \"even\") %}\n        <ul class=\"browser\">\n        {% for folder in folders %}\n          <li class=\"folder {{ row_class.next() }}\">{{ folder }}\n        {% endfor %}\n        {% for file in files %}\n          <li class=\"file {{ row_class.next() }}\">{{ file }}\n        {% endfor %}\n        </ul>\n\n    :param items: Each positional argument will be yielded in the order\n        given for each cycle.\n\n    .. versionadded:: 2.1\n    \"\"\"\n\n    def __init__(self, *items: t.Any) -> None:\n        if not items:\n            raise RuntimeError(\"at least one item has to be provided\")\n        self.items = items\n        self.pos = 0\n\n    def reset(self) -> None:\n        \"\"\"Resets the current item to the first item.\"\"\"\n        self.pos = 0\n\n    @property\n    def current(self) -> t.Any:\n        \"\"\"Return the current item. Equivalent to the item that will be\n        returned next time :meth:`next` is called.\n        \"\"\"\n        return self.items[self.pos]\n\n    def next(self) -> t.Any:\n        \"\"\"Return the current item, then advance :attr:`current` to the\n        next item.\n        \"\"\"\n        rv = self.current\n        self.pos = (self.pos + 1) % len(self.items)\n        return rv\n\n    __next__ = next\n\n\nclass Joiner:\n    \"\"\"A joining helper for templates.\"\"\"\n\n    def __init__(self, sep: str = \", \") -> None:\n        self.sep = sep\n        self.used = False\n\n    def __call__(self) -> str:\n        if not self.used:\n            self.used = True\n            return \"\"\n        return self.sep\n\n\nclass Namespace:\n    \"\"\"A namespace object that can hold arbitrary attributes.  It may be\n    initialized from a dictionary or with keyword arguments.\"\"\"\n\n    def __init__(*args: t.Any, **kwargs: t.Any) -> None:  # noqa: B902\n        self, args = args[0], args[1:]\n        self.__attrs = dict(*args, **kwargs)\n\n    def __getattribute__(self, name: str) -> t.Any:\n        # __class__ is needed for the awaitable check in async mode\n        if name in {\"_Namespace__attrs\", \"__class__\"}:\n            return object.__getattribute__(self, name)\n        try:\n            return self.__attrs[name]\n        except KeyError:\n            raise AttributeError(name) from None\n\n    def __setitem__(self, name: str, value: t.Any) -> None:\n        self.__attrs[name] = value\n\n    def __repr__(self) -> str:\n        return f\"<Namespace {self.__attrs!r}>\"\n", "src/jinja2/ext.py": "\"\"\"Extension API for adding custom tags and behavior.\"\"\"\n\nimport pprint\nimport re\nimport typing as t\n\nfrom markupsafe import Markup\n\nfrom . import defaults\nfrom . import nodes\nfrom .environment import Environment\nfrom .exceptions import TemplateAssertionError\nfrom .exceptions import TemplateSyntaxError\nfrom .runtime import concat  # type: ignore\nfrom .runtime import Context\nfrom .runtime import Undefined\nfrom .utils import import_string\nfrom .utils import pass_context\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .lexer import Token\n    from .lexer import TokenStream\n    from .parser import Parser\n\n    class _TranslationsBasic(te.Protocol):\n        def gettext(self, message: str) -> str: ...\n\n        def ngettext(self, singular: str, plural: str, n: int) -> str:\n            pass\n\n    class _TranslationsContext(_TranslationsBasic):\n        def pgettext(self, context: str, message: str) -> str: ...\n\n        def npgettext(\n            self, context: str, singular: str, plural: str, n: int\n        ) -> str: ...\n\n    _SupportedTranslations = t.Union[_TranslationsBasic, _TranslationsContext]\n\n\n# I18N functions available in Jinja templates. If the I18N library\n# provides ugettext, it will be assigned to gettext.\nGETTEXT_FUNCTIONS: t.Tuple[str, ...] = (\n    \"_\",\n    \"gettext\",\n    \"ngettext\",\n    \"pgettext\",\n    \"npgettext\",\n)\n_ws_re = re.compile(r\"\\s*\\n\\s*\")\n\n\nclass Extension:\n    \"\"\"Extensions can be used to add extra functionality to the Jinja template\n    system at the parser level.  Custom extensions are bound to an environment\n    but may not store environment specific data on `self`.  The reason for\n    this is that an extension can be bound to another environment (for\n    overlays) by creating a copy and reassigning the `environment` attribute.\n\n    As extensions are created by the environment they cannot accept any\n    arguments for configuration.  One may want to work around that by using\n    a factory function, but that is not possible as extensions are identified\n    by their import name.  The correct way to configure the extension is\n    storing the configuration values on the environment.  Because this way the\n    environment ends up acting as central configuration storage the\n    attributes may clash which is why extensions have to ensure that the names\n    they choose for configuration are not too generic.  ``prefix`` for example\n    is a terrible name, ``fragment_cache_prefix`` on the other hand is a good\n    name as includes the name of the extension (fragment cache).\n    \"\"\"\n\n    identifier: t.ClassVar[str]\n\n    def __init_subclass__(cls) -> None:\n        cls.identifier = f\"{cls.__module__}.{cls.__name__}\"\n\n    #: if this extension parses this is the list of tags it's listening to.\n    tags: t.Set[str] = set()\n\n    #: the priority of that extension.  This is especially useful for\n    #: extensions that preprocess values.  A lower value means higher\n    #: priority.\n    #:\n    #: .. versionadded:: 2.4\n    priority = 100\n\n    def __init__(self, environment: Environment) -> None:\n        self.environment = environment\n\n    def bind(self, environment: Environment) -> \"Extension\":\n        \"\"\"Create a copy of this extension bound to another environment.\"\"\"\n        rv = object.__new__(self.__class__)\n        rv.__dict__.update(self.__dict__)\n        rv.environment = environment\n        return rv\n\n    def preprocess(\n        self, source: str, name: t.Optional[str], filename: t.Optional[str] = None\n    ) -> str:\n        \"\"\"This method is called before the actual lexing and can be used to\n        preprocess the source.  The `filename` is optional.  The return value\n        must be the preprocessed source.\n        \"\"\"\n        return source\n\n    def filter_stream(\n        self, stream: \"TokenStream\"\n    ) -> t.Union[\"TokenStream\", t.Iterable[\"Token\"]]:\n        \"\"\"It's passed a :class:`~jinja2.lexer.TokenStream` that can be used\n        to filter tokens returned.  This method has to return an iterable of\n        :class:`~jinja2.lexer.Token`\\\\s, but it doesn't have to return a\n        :class:`~jinja2.lexer.TokenStream`.\n        \"\"\"\n        return stream\n\n    def parse(self, parser: \"Parser\") -> t.Union[nodes.Node, t.List[nodes.Node]]:\n        \"\"\"If any of the :attr:`tags` matched this method is called with the\n        parser as first argument.  The token the parser stream is pointing at\n        is the name token that matched.  This method has to return one or a\n        list of multiple nodes.\n        \"\"\"\n        raise NotImplementedError()\n\n    def attr(\n        self, name: str, lineno: t.Optional[int] = None\n    ) -> nodes.ExtensionAttribute:\n        \"\"\"Return an attribute node for the current extension.  This is useful\n        to pass constants on extensions to generated template code.\n\n        ::\n\n            self.attr('_my_attribute', lineno=lineno)\n        \"\"\"\n        return nodes.ExtensionAttribute(self.identifier, name, lineno=lineno)\n\n    def call_method(\n        self,\n        name: str,\n        args: t.Optional[t.List[nodes.Expr]] = None,\n        kwargs: t.Optional[t.List[nodes.Keyword]] = None,\n        dyn_args: t.Optional[nodes.Expr] = None,\n        dyn_kwargs: t.Optional[nodes.Expr] = None,\n        lineno: t.Optional[int] = None,\n    ) -> nodes.Call:\n        \"\"\"Call a method of the extension.  This is a shortcut for\n        :meth:`attr` + :class:`jinja2.nodes.Call`.\n        \"\"\"\n        if args is None:\n            args = []\n        if kwargs is None:\n            kwargs = []\n        return nodes.Call(\n            self.attr(name, lineno=lineno),\n            args,\n            kwargs,\n            dyn_args,\n            dyn_kwargs,\n            lineno=lineno,\n        )\n\n\n@pass_context\ndef _gettext_alias(\n    __context: Context, *args: t.Any, **kwargs: t.Any\n) -> t.Union[t.Any, Undefined]:\n    return __context.call(__context.resolve(\"gettext\"), *args, **kwargs)\n\n\ndef _make_new_gettext(func: t.Callable[[str], str]) -> t.Callable[..., str]:\n    @pass_context\n    def gettext(__context: Context, __string: str, **variables: t.Any) -> str:\n        rv = __context.call(func, __string)\n        if __context.eval_ctx.autoescape:\n            rv = Markup(rv)\n        # Always treat as a format string, even if there are no\n        # variables. This makes translation strings more consistent\n        # and predictable. This requires escaping\n        return rv % variables  # type: ignore\n\n    return gettext\n\n\ndef _make_new_ngettext(func: t.Callable[[str, str, int], str]) -> t.Callable[..., str]:\n    @pass_context\n    def ngettext(\n        __context: Context,\n        __singular: str,\n        __plural: str,\n        __num: int,\n        **variables: t.Any,\n    ) -> str:\n        variables.setdefault(\"num\", __num)\n        rv = __context.call(func, __singular, __plural, __num)\n        if __context.eval_ctx.autoescape:\n            rv = Markup(rv)\n        # Always treat as a format string, see gettext comment above.\n        return rv % variables  # type: ignore\n\n    return ngettext\n\n\ndef _make_new_pgettext(func: t.Callable[[str, str], str]) -> t.Callable[..., str]:\n    @pass_context\n    def pgettext(\n        __context: Context, __string_ctx: str, __string: str, **variables: t.Any\n    ) -> str:\n        variables.setdefault(\"context\", __string_ctx)\n        rv = __context.call(func, __string_ctx, __string)\n\n        if __context.eval_ctx.autoescape:\n            rv = Markup(rv)\n\n        # Always treat as a format string, see gettext comment above.\n        return rv % variables  # type: ignore\n\n    return pgettext\n\n\ndef _make_new_npgettext(\n    func: t.Callable[[str, str, str, int], str],\n) -> t.Callable[..., str]:\n    @pass_context\n    def npgettext(\n        __context: Context,\n        __string_ctx: str,\n        __singular: str,\n        __plural: str,\n        __num: int,\n        **variables: t.Any,\n    ) -> str:\n        variables.setdefault(\"context\", __string_ctx)\n        variables.setdefault(\"num\", __num)\n        rv = __context.call(func, __string_ctx, __singular, __plural, __num)\n\n        if __context.eval_ctx.autoescape:\n            rv = Markup(rv)\n\n        # Always treat as a format string, see gettext comment above.\n        return rv % variables  # type: ignore\n\n    return npgettext\n\n\nclass InternationalizationExtension(Extension):\n    \"\"\"This extension adds gettext support to Jinja.\"\"\"\n\n    tags = {\"trans\"}\n\n    # TODO: the i18n extension is currently reevaluating values in a few\n    # situations.  Take this example:\n    #   {% trans count=something() %}{{ count }} foo{% pluralize\n    #     %}{{ count }} fooss{% endtrans %}\n    # something is called twice here.  One time for the gettext value and\n    # the other time for the n-parameter of the ngettext function.\n\n    def __init__(self, environment: Environment) -> None:\n        super().__init__(environment)\n        environment.globals[\"_\"] = _gettext_alias\n        environment.extend(\n            install_gettext_translations=self._install,\n            install_null_translations=self._install_null,\n            install_gettext_callables=self._install_callables,\n            uninstall_gettext_translations=self._uninstall,\n            extract_translations=self._extract,\n            newstyle_gettext=False,\n        )\n\n    def _install(\n        self, translations: \"_SupportedTranslations\", newstyle: t.Optional[bool] = None\n    ) -> None:\n        # ugettext and ungettext are preferred in case the I18N library\n        # is providing compatibility with older Python versions.\n        gettext = getattr(translations, \"ugettext\", None)\n        if gettext is None:\n            gettext = translations.gettext\n        ngettext = getattr(translations, \"ungettext\", None)\n        if ngettext is None:\n            ngettext = translations.ngettext\n\n        pgettext = getattr(translations, \"pgettext\", None)\n        npgettext = getattr(translations, \"npgettext\", None)\n        self._install_callables(\n            gettext, ngettext, newstyle=newstyle, pgettext=pgettext, npgettext=npgettext\n        )\n\n    def _install_null(self, newstyle: t.Optional[bool] = None) -> None:\n        import gettext\n\n        translations = gettext.NullTranslations()\n        self._install_callables(\n            gettext=translations.gettext,\n            ngettext=translations.ngettext,\n            newstyle=newstyle,\n            pgettext=translations.pgettext,\n            npgettext=translations.npgettext,\n        )\n\n    def _install_callables(\n        self,\n        gettext: t.Callable[[str], str],\n        ngettext: t.Callable[[str, str, int], str],\n        newstyle: t.Optional[bool] = None,\n        pgettext: t.Optional[t.Callable[[str, str], str]] = None,\n        npgettext: t.Optional[t.Callable[[str, str, str, int], str]] = None,\n    ) -> None:\n        if newstyle is not None:\n            self.environment.newstyle_gettext = newstyle  # type: ignore\n        if self.environment.newstyle_gettext:  # type: ignore\n            gettext = _make_new_gettext(gettext)\n            ngettext = _make_new_ngettext(ngettext)\n\n            if pgettext is not None:\n                pgettext = _make_new_pgettext(pgettext)\n\n            if npgettext is not None:\n                npgettext = _make_new_npgettext(npgettext)\n\n        self.environment.globals.update(\n            gettext=gettext, ngettext=ngettext, pgettext=pgettext, npgettext=npgettext\n        )\n\n    def _uninstall(self, translations: \"_SupportedTranslations\") -> None:\n        for key in (\"gettext\", \"ngettext\", \"pgettext\", \"npgettext\"):\n            self.environment.globals.pop(key, None)\n\n    def _extract(\n        self,\n        source: t.Union[str, nodes.Template],\n        gettext_functions: t.Sequence[str] = GETTEXT_FUNCTIONS,\n    ) -> t.Iterator[\n        t.Tuple[int, str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]]]\n    ]:\n        if isinstance(source, str):\n            source = self.environment.parse(source)\n        return extract_from_ast(source, gettext_functions)\n\n    def parse(self, parser: \"Parser\") -> t.Union[nodes.Node, t.List[nodes.Node]]:\n        \"\"\"Parse a translatable tag.\"\"\"\n        lineno = next(parser.stream).lineno\n\n        context = None\n        context_token = parser.stream.next_if(\"string\")\n\n        if context_token is not None:\n            context = context_token.value\n\n        # find all the variables referenced.  Additionally a variable can be\n        # defined in the body of the trans block too, but this is checked at\n        # a later state.\n        plural_expr: t.Optional[nodes.Expr] = None\n        plural_expr_assignment: t.Optional[nodes.Assign] = None\n        num_called_num = False\n        variables: t.Dict[str, nodes.Expr] = {}\n        trimmed = None\n        while parser.stream.current.type != \"block_end\":\n            if variables:\n                parser.stream.expect(\"comma\")\n\n            # skip colon for python compatibility\n            if parser.stream.skip_if(\"colon\"):\n                break\n\n            token = parser.stream.expect(\"name\")\n            if token.value in variables:\n                parser.fail(\n                    f\"translatable variable {token.value!r} defined twice.\",\n                    token.lineno,\n                    exc=TemplateAssertionError,\n                )\n\n            # expressions\n            if parser.stream.current.type == \"assign\":\n                next(parser.stream)\n                variables[token.value] = var = parser.parse_expression()\n            elif trimmed is None and token.value in (\"trimmed\", \"notrimmed\"):\n                trimmed = token.value == \"trimmed\"\n                continue\n            else:\n                variables[token.value] = var = nodes.Name(token.value, \"load\")\n\n            if plural_expr is None:\n                if isinstance(var, nodes.Call):\n                    plural_expr = nodes.Name(\"_trans\", \"load\")\n                    variables[token.value] = plural_expr\n                    plural_expr_assignment = nodes.Assign(\n                        nodes.Name(\"_trans\", \"store\"), var\n                    )\n                else:\n                    plural_expr = var\n                num_called_num = token.value == \"num\"\n\n        parser.stream.expect(\"block_end\")\n\n        plural = None\n        have_plural = False\n        referenced = set()\n\n        # now parse until endtrans or pluralize\n        singular_names, singular = self._parse_block(parser, True)\n        if singular_names:\n            referenced.update(singular_names)\n            if plural_expr is None:\n                plural_expr = nodes.Name(singular_names[0], \"load\")\n                num_called_num = singular_names[0] == \"num\"\n\n        # if we have a pluralize block, we parse that too\n        if parser.stream.current.test(\"name:pluralize\"):\n            have_plural = True\n            next(parser.stream)\n            if parser.stream.current.type != \"block_end\":\n                token = parser.stream.expect(\"name\")\n                if token.value not in variables:\n                    parser.fail(\n                        f\"unknown variable {token.value!r} for pluralization\",\n                        token.lineno,\n                        exc=TemplateAssertionError,\n                    )\n                plural_expr = variables[token.value]\n                num_called_num = token.value == \"num\"\n            parser.stream.expect(\"block_end\")\n            plural_names, plural = self._parse_block(parser, False)\n            next(parser.stream)\n            referenced.update(plural_names)\n        else:\n            next(parser.stream)\n\n        # register free names as simple name expressions\n        for name in referenced:\n            if name not in variables:\n                variables[name] = nodes.Name(name, \"load\")\n\n        if not have_plural:\n            plural_expr = None\n        elif plural_expr is None:\n            parser.fail(\"pluralize without variables\", lineno)\n\n        if trimmed is None:\n            trimmed = self.environment.policies[\"ext.i18n.trimmed\"]\n        if trimmed:\n            singular = self._trim_whitespace(singular)\n            if plural:\n                plural = self._trim_whitespace(plural)\n\n        node = self._make_node(\n            singular,\n            plural,\n            context,\n            variables,\n            plural_expr,\n            bool(referenced),\n            num_called_num and have_plural,\n        )\n        node.set_lineno(lineno)\n        if plural_expr_assignment is not None:\n            return [plural_expr_assignment, node]\n        else:\n            return node\n\n    def _trim_whitespace(self, string: str, _ws_re: t.Pattern[str] = _ws_re) -> str:\n        return _ws_re.sub(\" \", string.strip())\n\n    def _parse_block(\n        self, parser: \"Parser\", allow_pluralize: bool\n    ) -> t.Tuple[t.List[str], str]:\n        \"\"\"Parse until the next block tag with a given name.\"\"\"\n        referenced = []\n        buf = []\n\n        while True:\n            if parser.stream.current.type == \"data\":\n                buf.append(parser.stream.current.value.replace(\"%\", \"%%\"))\n                next(parser.stream)\n            elif parser.stream.current.type == \"variable_begin\":\n                next(parser.stream)\n                name = parser.stream.expect(\"name\").value\n                referenced.append(name)\n                buf.append(f\"%({name})s\")\n                parser.stream.expect(\"variable_end\")\n            elif parser.stream.current.type == \"block_begin\":\n                next(parser.stream)\n                block_name = (\n                    parser.stream.current.value\n                    if parser.stream.current.type == \"name\"\n                    else None\n                )\n                if block_name == \"endtrans\":\n                    break\n                elif block_name == \"pluralize\":\n                    if allow_pluralize:\n                        break\n                    parser.fail(\n                        \"a translatable section can have only one pluralize section\"\n                    )\n                elif block_name == \"trans\":\n                    parser.fail(\n                        \"trans blocks can't be nested; did you mean `endtrans`?\"\n                    )\n                parser.fail(\n                    f\"control structures in translatable sections are not allowed; \"\n                    f\"saw `{block_name}`\"\n                )\n            elif parser.stream.eos:\n                parser.fail(\"unclosed translation block\")\n            else:\n                raise RuntimeError(\"internal parser error\")\n\n        return referenced, concat(buf)\n\n    def _make_node(\n        self,\n        singular: str,\n        plural: t.Optional[str],\n        context: t.Optional[str],\n        variables: t.Dict[str, nodes.Expr],\n        plural_expr: t.Optional[nodes.Expr],\n        vars_referenced: bool,\n        num_called_num: bool,\n    ) -> nodes.Output:\n        \"\"\"Generates a useful node from the data provided.\"\"\"\n        newstyle = self.environment.newstyle_gettext  # type: ignore\n        node: nodes.Expr\n\n        # no variables referenced?  no need to escape for old style\n        # gettext invocations only if there are vars.\n        if not vars_referenced and not newstyle:\n            singular = singular.replace(\"%%\", \"%\")\n            if plural:\n                plural = plural.replace(\"%%\", \"%\")\n\n        func_name = \"gettext\"\n        func_args: t.List[nodes.Expr] = [nodes.Const(singular)]\n\n        if context is not None:\n            func_args.insert(0, nodes.Const(context))\n            func_name = f\"p{func_name}\"\n\n        if plural_expr is not None:\n            func_name = f\"n{func_name}\"\n            func_args.extend((nodes.Const(plural), plural_expr))\n\n        node = nodes.Call(nodes.Name(func_name, \"load\"), func_args, [], None, None)\n\n        # in case newstyle gettext is used, the method is powerful\n        # enough to handle the variable expansion and autoescape\n        # handling itself\n        if newstyle:\n            for key, value in variables.items():\n                # the function adds that later anyways in case num was\n                # called num, so just skip it.\n                if num_called_num and key == \"num\":\n                    continue\n                node.kwargs.append(nodes.Keyword(key, value))\n\n        # otherwise do that here\n        else:\n            # mark the return value as safe if we are in an\n            # environment with autoescaping turned on\n            node = nodes.MarkSafeIfAutoescape(node)\n            if variables:\n                node = nodes.Mod(\n                    node,\n                    nodes.Dict(\n                        [\n                            nodes.Pair(nodes.Const(key), value)\n                            for key, value in variables.items()\n                        ]\n                    ),\n                )\n        return nodes.Output([node])\n\n\nclass ExprStmtExtension(Extension):\n    \"\"\"Adds a `do` tag to Jinja that works like the print statement just\n    that it doesn't print the return value.\n    \"\"\"\n\n    tags = {\"do\"}\n\n    def parse(self, parser: \"Parser\") -> nodes.ExprStmt:\n        node = nodes.ExprStmt(lineno=next(parser.stream).lineno)\n        node.node = parser.parse_tuple()\n        return node\n\n\nclass LoopControlExtension(Extension):\n    \"\"\"Adds break and continue to the template engine.\"\"\"\n\n    tags = {\"break\", \"continue\"}\n\n    def parse(self, parser: \"Parser\") -> t.Union[nodes.Break, nodes.Continue]:\n        token = next(parser.stream)\n        if token.value == \"break\":\n            return nodes.Break(lineno=token.lineno)\n        return nodes.Continue(lineno=token.lineno)\n\n\nclass DebugExtension(Extension):\n    \"\"\"A ``{% debug %}`` tag that dumps the available variables,\n    filters, and tests.\n\n    .. code-block:: html+jinja\n\n        <pre>{% debug %}</pre>\n\n    .. code-block:: text\n\n        {'context': {'cycler': <class 'jinja2.utils.Cycler'>,\n                     ...,\n                     'namespace': <class 'jinja2.utils.Namespace'>},\n         'filters': ['abs', 'attr', 'batch', 'capitalize', 'center', 'count', 'd',\n                     ..., 'urlencode', 'urlize', 'wordcount', 'wordwrap', 'xmlattr'],\n         'tests': ['!=', '<', '<=', '==', '>', '>=', 'callable', 'defined',\n                   ..., 'odd', 'sameas', 'sequence', 'string', 'undefined', 'upper']}\n\n    .. versionadded:: 2.11.0\n    \"\"\"\n\n    tags = {\"debug\"}\n\n    def parse(self, parser: \"Parser\") -> nodes.Output:\n        lineno = parser.stream.expect(\"name:debug\").lineno\n        context = nodes.ContextReference()\n        result = self.call_method(\"_render\", [context], lineno=lineno)\n        return nodes.Output([result], lineno=lineno)\n\n    def _render(self, context: Context) -> str:\n        result = {\n            \"context\": context.get_all(),\n            \"filters\": sorted(self.environment.filters.keys()),\n            \"tests\": sorted(self.environment.tests.keys()),\n        }\n\n        # Set the depth since the intent is to show the top few names.\n        return pprint.pformat(result, depth=3, compact=True)\n\n\ndef extract_from_ast(\n    ast: nodes.Template,\n    gettext_functions: t.Sequence[str] = GETTEXT_FUNCTIONS,\n    babel_style: bool = True,\n) -> t.Iterator[\n    t.Tuple[int, str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]]]\n]:\n    \"\"\"Extract localizable strings from the given template node.  Per\n    default this function returns matches in babel style that means non string\n    parameters as well as keyword arguments are returned as `None`.  This\n    allows Babel to figure out what you really meant if you are using\n    gettext functions that allow keyword arguments for placeholder expansion.\n    If you don't want that behavior set the `babel_style` parameter to `False`\n    which causes only strings to be returned and parameters are always stored\n    in tuples.  As a consequence invalid gettext calls (calls without a single\n    string parameter or string parameters after non-string parameters) are\n    skipped.\n\n    This example explains the behavior:\n\n    >>> from jinja2 import Environment\n    >>> env = Environment()\n    >>> node = env.parse('{{ (_(\"foo\"), _(), ngettext(\"foo\", \"bar\", 42)) }}')\n    >>> list(extract_from_ast(node))\n    [(1, '_', 'foo'), (1, '_', ()), (1, 'ngettext', ('foo', 'bar', None))]\n    >>> list(extract_from_ast(node, babel_style=False))\n    [(1, '_', ('foo',)), (1, 'ngettext', ('foo', 'bar'))]\n\n    For every string found this function yields a ``(lineno, function,\n    message)`` tuple, where:\n\n    * ``lineno`` is the number of the line on which the string was found,\n    * ``function`` is the name of the ``gettext`` function used (if the\n      string was extracted from embedded Python code), and\n    *   ``message`` is the string, or a tuple of strings for functions\n         with multiple string arguments.\n\n    This extraction function operates on the AST and is because of that unable\n    to extract any comments.  For comment support you have to use the babel\n    extraction interface or extract comments yourself.\n    \"\"\"\n    out: t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]]\n\n    for node in ast.find_all(nodes.Call):\n        if (\n            not isinstance(node.node, nodes.Name)\n            or node.node.name not in gettext_functions\n        ):\n            continue\n\n        strings: t.List[t.Optional[str]] = []\n\n        for arg in node.args:\n            if isinstance(arg, nodes.Const) and isinstance(arg.value, str):\n                strings.append(arg.value)\n            else:\n                strings.append(None)\n\n        for _ in node.kwargs:\n            strings.append(None)\n        if node.dyn_args is not None:\n            strings.append(None)\n        if node.dyn_kwargs is not None:\n            strings.append(None)\n\n        if not babel_style:\n            out = tuple(x for x in strings if x is not None)\n\n            if not out:\n                continue\n        else:\n            if len(strings) == 1:\n                out = strings[0]\n            else:\n                out = tuple(strings)\n\n        yield node.lineno, node.node.name, out\n\n\nclass _CommentFinder:\n    \"\"\"Helper class to find comments in a token stream.  Can only\n    find comments for gettext calls forwards.  Once the comment\n    from line 4 is found, a comment for line 1 will not return a\n    usable value.\n    \"\"\"\n\n    def __init__(\n        self, tokens: t.Sequence[t.Tuple[int, str, str]], comment_tags: t.Sequence[str]\n    ) -> None:\n        self.tokens = tokens\n        self.comment_tags = comment_tags\n        self.offset = 0\n        self.last_lineno = 0\n\n    def find_backwards(self, offset: int) -> t.List[str]:\n        try:\n            for _, token_type, token_value in reversed(\n                self.tokens[self.offset : offset]\n            ):\n                if token_type in (\"comment\", \"linecomment\"):\n                    try:\n                        prefix, comment = token_value.split(None, 1)\n                    except ValueError:\n                        continue\n                    if prefix in self.comment_tags:\n                        return [comment.rstrip()]\n            return []\n        finally:\n            self.offset = offset\n\n    def find_comments(self, lineno: int) -> t.List[str]:\n        if not self.comment_tags or self.last_lineno > lineno:\n            return []\n        for idx, (token_lineno, _, _) in enumerate(self.tokens[self.offset :]):\n            if token_lineno > lineno:\n                return self.find_backwards(self.offset + idx)\n        return self.find_backwards(len(self.tokens))\n\n\ndef babel_extract(\n    fileobj: t.BinaryIO,\n    keywords: t.Sequence[str],\n    comment_tags: t.Sequence[str],\n    options: t.Dict[str, t.Any],\n) -> t.Iterator[\n    t.Tuple[\n        int, str, t.Union[t.Optional[str], t.Tuple[t.Optional[str], ...]], t.List[str]\n    ]\n]:\n    \"\"\"Babel extraction method for Jinja templates.\n\n    .. versionchanged:: 2.3\n       Basic support for translation comments was added.  If `comment_tags`\n       is now set to a list of keywords for extraction, the extractor will\n       try to find the best preceding comment that begins with one of the\n       keywords.  For best results, make sure to not have more than one\n       gettext call in one line of code and the matching comment in the\n       same line or the line before.\n\n    .. versionchanged:: 2.5.1\n       The `newstyle_gettext` flag can be set to `True` to enable newstyle\n       gettext calls.\n\n    .. versionchanged:: 2.7\n       A `silent` option can now be provided.  If set to `False` template\n       syntax errors are propagated instead of being ignored.\n\n    :param fileobj: the file-like object the messages should be extracted from\n    :param keywords: a list of keywords (i.e. function names) that should be\n                     recognized as translation functions\n    :param comment_tags: a list of translator tags to search for and include\n                         in the results.\n    :param options: a dictionary of additional options (optional)\n    :return: an iterator over ``(lineno, funcname, message, comments)`` tuples.\n             (comments will be empty currently)\n    \"\"\"\n    extensions: t.Dict[t.Type[Extension], None] = {}\n\n    for extension_name in options.get(\"extensions\", \"\").split(\",\"):\n        extension_name = extension_name.strip()\n\n        if not extension_name:\n            continue\n\n        extensions[import_string(extension_name)] = None\n\n    if InternationalizationExtension not in extensions:\n        extensions[InternationalizationExtension] = None\n\n    def getbool(options: t.Mapping[str, str], key: str, default: bool = False) -> bool:\n        return options.get(key, str(default)).lower() in {\"1\", \"on\", \"yes\", \"true\"}\n\n    silent = getbool(options, \"silent\", True)\n    environment = Environment(\n        options.get(\"block_start_string\", defaults.BLOCK_START_STRING),\n        options.get(\"block_end_string\", defaults.BLOCK_END_STRING),\n        options.get(\"variable_start_string\", defaults.VARIABLE_START_STRING),\n        options.get(\"variable_end_string\", defaults.VARIABLE_END_STRING),\n        options.get(\"comment_start_string\", defaults.COMMENT_START_STRING),\n        options.get(\"comment_end_string\", defaults.COMMENT_END_STRING),\n        options.get(\"line_statement_prefix\") or defaults.LINE_STATEMENT_PREFIX,\n        options.get(\"line_comment_prefix\") or defaults.LINE_COMMENT_PREFIX,\n        getbool(options, \"trim_blocks\", defaults.TRIM_BLOCKS),\n        getbool(options, \"lstrip_blocks\", defaults.LSTRIP_BLOCKS),\n        defaults.NEWLINE_SEQUENCE,\n        getbool(options, \"keep_trailing_newline\", defaults.KEEP_TRAILING_NEWLINE),\n        tuple(extensions),\n        cache_size=0,\n        auto_reload=False,\n    )\n\n    if getbool(options, \"trimmed\"):\n        environment.policies[\"ext.i18n.trimmed\"] = True\n    if getbool(options, \"newstyle_gettext\"):\n        environment.newstyle_gettext = True  # type: ignore\n\n    source = fileobj.read().decode(options.get(\"encoding\", \"utf-8\"))\n    try:\n        node = environment.parse(source)\n        tokens = list(environment.lex(environment.preprocess(source)))\n    except TemplateSyntaxError:\n        if not silent:\n            raise\n        # skip templates with syntax errors\n        return\n\n    finder = _CommentFinder(tokens, comment_tags)\n    for lineno, func, message in extract_from_ast(node, keywords):\n        yield lineno, func, message, finder.find_comments(lineno)\n\n\n#: nicer import names\ni18n = InternationalizationExtension\ndo = ExprStmtExtension\nloopcontrols = LoopControlExtension\ndebug = DebugExtension\n", "src/jinja2/nodes.py": "\"\"\"AST nodes generated by the parser for the compiler. Also provides\nsome node tree helper functions used by the parser and compiler in order\nto normalize nodes.\n\"\"\"\n\nimport inspect\nimport operator\nimport typing as t\nfrom collections import deque\n\nfrom markupsafe import Markup\n\nfrom .utils import _PassArg\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .environment import Environment\n\n_NodeBound = t.TypeVar(\"_NodeBound\", bound=\"Node\")\n\n_binop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {\n    \"*\": operator.mul,\n    \"/\": operator.truediv,\n    \"//\": operator.floordiv,\n    \"**\": operator.pow,\n    \"%\": operator.mod,\n    \"+\": operator.add,\n    \"-\": operator.sub,\n}\n\n_uaop_to_func: t.Dict[str, t.Callable[[t.Any], t.Any]] = {\n    \"not\": operator.not_,\n    \"+\": operator.pos,\n    \"-\": operator.neg,\n}\n\n_cmpop_to_func: t.Dict[str, t.Callable[[t.Any, t.Any], t.Any]] = {\n    \"eq\": operator.eq,\n    \"ne\": operator.ne,\n    \"gt\": operator.gt,\n    \"gteq\": operator.ge,\n    \"lt\": operator.lt,\n    \"lteq\": operator.le,\n    \"in\": lambda a, b: a in b,\n    \"notin\": lambda a, b: a not in b,\n}\n\n\nclass Impossible(Exception):\n    \"\"\"Raised if the node could not perform a requested action.\"\"\"\n\n\nclass NodeType(type):\n    \"\"\"A metaclass for nodes that handles the field and attribute\n    inheritance.  fields and attributes from the parent class are\n    automatically forwarded to the child.\"\"\"\n\n    def __new__(mcs, name, bases, d):  # type: ignore\n        for attr in \"fields\", \"attributes\":\n            storage: t.List[t.Tuple[str, ...]] = []\n            storage.extend(getattr(bases[0] if bases else object, attr, ()))\n            storage.extend(d.get(attr, ()))\n            assert len(bases) <= 1, \"multiple inheritance not allowed\"\n            assert len(storage) == len(set(storage)), \"layout conflict\"\n            d[attr] = tuple(storage)\n        d.setdefault(\"abstract\", False)\n        return type.__new__(mcs, name, bases, d)\n\n\nclass EvalContext:\n    \"\"\"Holds evaluation time information.  Custom attributes can be attached\n    to it in extensions.\n    \"\"\"\n\n    def __init__(\n        self, environment: \"Environment\", template_name: t.Optional[str] = None\n    ) -> None:\n        self.environment = environment\n        if callable(environment.autoescape):\n            self.autoescape = environment.autoescape(template_name)\n        else:\n            self.autoescape = environment.autoescape\n        self.volatile = False\n\n    def save(self) -> t.Mapping[str, t.Any]:\n        return self.__dict__.copy()\n\n    def revert(self, old: t.Mapping[str, t.Any]) -> None:\n        self.__dict__.clear()\n        self.__dict__.update(old)\n\n\ndef get_eval_context(node: \"Node\", ctx: t.Optional[EvalContext]) -> EvalContext:\n    if ctx is None:\n        if node.environment is None:\n            raise RuntimeError(\n                \"if no eval context is passed, the node must have an\"\n                \" attached environment.\"\n            )\n        return EvalContext(node.environment)\n    return ctx\n\n\nclass Node(metaclass=NodeType):\n    \"\"\"Baseclass for all Jinja nodes.  There are a number of nodes available\n    of different types.  There are four major types:\n\n    -   :class:`Stmt`: statements\n    -   :class:`Expr`: expressions\n    -   :class:`Helper`: helper nodes\n    -   :class:`Template`: the outermost wrapper node\n\n    All nodes have fields and attributes.  Fields may be other nodes, lists,\n    or arbitrary values.  Fields are passed to the constructor as regular\n    positional arguments, attributes as keyword arguments.  Each node has\n    two attributes: `lineno` (the line number of the node) and `environment`.\n    The `environment` attribute is set at the end of the parsing process for\n    all nodes automatically.\n    \"\"\"\n\n    fields: t.Tuple[str, ...] = ()\n    attributes: t.Tuple[str, ...] = (\"lineno\", \"environment\")\n    abstract = True\n\n    lineno: int\n    environment: t.Optional[\"Environment\"]\n\n    def __init__(self, *fields: t.Any, **attributes: t.Any) -> None:\n        if self.abstract:\n            raise TypeError(\"abstract nodes are not instantiable\")\n        if fields:\n            if len(fields) != len(self.fields):\n                if not self.fields:\n                    raise TypeError(f\"{type(self).__name__!r} takes 0 arguments\")\n                raise TypeError(\n                    f\"{type(self).__name__!r} takes 0 or {len(self.fields)}\"\n                    f\" argument{'s' if len(self.fields) != 1 else ''}\"\n                )\n            for name, arg in zip(self.fields, fields):\n                setattr(self, name, arg)\n        for attr in self.attributes:\n            setattr(self, attr, attributes.pop(attr, None))\n        if attributes:\n            raise TypeError(f\"unknown attribute {next(iter(attributes))!r}\")\n\n    def iter_fields(\n        self,\n        exclude: t.Optional[t.Container[str]] = None,\n        only: t.Optional[t.Container[str]] = None,\n    ) -> t.Iterator[t.Tuple[str, t.Any]]:\n        \"\"\"This method iterates over all fields that are defined and yields\n        ``(key, value)`` tuples.  Per default all fields are returned, but\n        it's possible to limit that to some fields by providing the `only`\n        parameter or to exclude some using the `exclude` parameter.  Both\n        should be sets or tuples of field names.\n        \"\"\"\n        for name in self.fields:\n            if (\n                (exclude is None and only is None)\n                or (exclude is not None and name not in exclude)\n                or (only is not None and name in only)\n            ):\n                try:\n                    yield name, getattr(self, name)\n                except AttributeError:\n                    pass\n\n    def iter_child_nodes(\n        self,\n        exclude: t.Optional[t.Container[str]] = None,\n        only: t.Optional[t.Container[str]] = None,\n    ) -> t.Iterator[\"Node\"]:\n        \"\"\"Iterates over all direct child nodes of the node.  This iterates\n        over all fields and yields the values of they are nodes.  If the value\n        of a field is a list all the nodes in that list are returned.\n        \"\"\"\n        for _, item in self.iter_fields(exclude, only):\n            if isinstance(item, list):\n                for n in item:\n                    if isinstance(n, Node):\n                        yield n\n            elif isinstance(item, Node):\n                yield item\n\n    def find(self, node_type: t.Type[_NodeBound]) -> t.Optional[_NodeBound]:\n        \"\"\"Find the first node of a given type.  If no such node exists the\n        return value is `None`.\n        \"\"\"\n        for result in self.find_all(node_type):\n            return result\n\n        return None\n\n    def find_all(\n        self, node_type: t.Union[t.Type[_NodeBound], t.Tuple[t.Type[_NodeBound], ...]]\n    ) -> t.Iterator[_NodeBound]:\n        \"\"\"Find all the nodes of a given type.  If the type is a tuple,\n        the check is performed for any of the tuple items.\n        \"\"\"\n        for child in self.iter_child_nodes():\n            if isinstance(child, node_type):\n                yield child  # type: ignore\n            yield from child.find_all(node_type)\n\n    def set_ctx(self, ctx: str) -> \"Node\":\n        \"\"\"Reset the context of a node and all child nodes.  Per default the\n        parser will all generate nodes that have a 'load' context as it's the\n        most common one.  This method is used in the parser to set assignment\n        targets and other nodes to a store context.\n        \"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            if \"ctx\" in node.fields:\n                node.ctx = ctx  # type: ignore\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def set_lineno(self, lineno: int, override: bool = False) -> \"Node\":\n        \"\"\"Set the line numbers of the node and children.\"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            if \"lineno\" in node.attributes:\n                if node.lineno is None or override:\n                    node.lineno = lineno\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def set_environment(self, environment: \"Environment\") -> \"Node\":\n        \"\"\"Set the environment for all nodes.\"\"\"\n        todo = deque([self])\n        while todo:\n            node = todo.popleft()\n            node.environment = environment\n            todo.extend(node.iter_child_nodes())\n        return self\n\n    def __eq__(self, other: t.Any) -> bool:\n        if type(self) is not type(other):\n            return NotImplemented\n\n        return tuple(self.iter_fields()) == tuple(other.iter_fields())\n\n    __hash__ = object.__hash__\n\n    def __repr__(self) -> str:\n        args_str = \", \".join(f\"{a}={getattr(self, a, None)!r}\" for a in self.fields)\n        return f\"{type(self).__name__}({args_str})\"\n\n    def dump(self) -> str:\n        def _dump(node: t.Union[Node, t.Any]) -> None:\n            if not isinstance(node, Node):\n                buf.append(repr(node))\n                return\n\n            buf.append(f\"nodes.{type(node).__name__}(\")\n            if not node.fields:\n                buf.append(\")\")\n                return\n            for idx, field in enumerate(node.fields):\n                if idx:\n                    buf.append(\", \")\n                value = getattr(node, field)\n                if isinstance(value, list):\n                    buf.append(\"[\")\n                    for idx, item in enumerate(value):\n                        if idx:\n                            buf.append(\", \")\n                        _dump(item)\n                    buf.append(\"]\")\n                else:\n                    _dump(value)\n            buf.append(\")\")\n\n        buf: t.List[str] = []\n        _dump(self)\n        return \"\".join(buf)\n\n\nclass Stmt(Node):\n    \"\"\"Base node for all statements.\"\"\"\n\n    abstract = True\n\n\nclass Helper(Node):\n    \"\"\"Nodes that exist in a specific context only.\"\"\"\n\n    abstract = True\n\n\nclass Template(Node):\n    \"\"\"Node that represents a template.  This must be the outermost node that\n    is passed to the compiler.\n    \"\"\"\n\n    fields = (\"body\",)\n    body: t.List[Node]\n\n\nclass Output(Stmt):\n    \"\"\"A node that holds multiple expressions which are then printed out.\n    This is used both for the `print` statement and the regular template data.\n    \"\"\"\n\n    fields = (\"nodes\",)\n    nodes: t.List[\"Expr\"]\n\n\nclass Extends(Stmt):\n    \"\"\"Represents an extends statement.\"\"\"\n\n    fields = (\"template\",)\n    template: \"Expr\"\n\n\nclass For(Stmt):\n    \"\"\"The for loop.  `target` is the target for the iteration (usually a\n    :class:`Name` or :class:`Tuple`), `iter` the iterable.  `body` is a list\n    of nodes that are used as loop-body, and `else_` a list of nodes for the\n    `else` block.  If no else node exists it has to be an empty list.\n\n    For filtered nodes an expression can be stored as `test`, otherwise `None`.\n    \"\"\"\n\n    fields = (\"target\", \"iter\", \"body\", \"else_\", \"test\", \"recursive\")\n    target: Node\n    iter: Node\n    body: t.List[Node]\n    else_: t.List[Node]\n    test: t.Optional[Node]\n    recursive: bool\n\n\nclass If(Stmt):\n    \"\"\"If `test` is true, `body` is rendered, else `else_`.\"\"\"\n\n    fields = (\"test\", \"body\", \"elif_\", \"else_\")\n    test: Node\n    body: t.List[Node]\n    elif_: t.List[\"If\"]\n    else_: t.List[Node]\n\n\nclass Macro(Stmt):\n    \"\"\"A macro definition.  `name` is the name of the macro, `args` a list of\n    arguments and `defaults` a list of defaults if there are any.  `body` is\n    a list of nodes for the macro body.\n    \"\"\"\n\n    fields = (\"name\", \"args\", \"defaults\", \"body\")\n    name: str\n    args: t.List[\"Name\"]\n    defaults: t.List[\"Expr\"]\n    body: t.List[Node]\n\n\nclass CallBlock(Stmt):\n    \"\"\"Like a macro without a name but a call instead.  `call` is called with\n    the unnamed macro as `caller` argument this node holds.\n    \"\"\"\n\n    fields = (\"call\", \"args\", \"defaults\", \"body\")\n    call: \"Call\"\n    args: t.List[\"Name\"]\n    defaults: t.List[\"Expr\"]\n    body: t.List[Node]\n\n\nclass FilterBlock(Stmt):\n    \"\"\"Node for filter sections.\"\"\"\n\n    fields = (\"body\", \"filter\")\n    body: t.List[Node]\n    filter: \"Filter\"\n\n\nclass With(Stmt):\n    \"\"\"Specific node for with statements.  In older versions of Jinja the\n    with statement was implemented on the base of the `Scope` node instead.\n\n    .. versionadded:: 2.9.3\n    \"\"\"\n\n    fields = (\"targets\", \"values\", \"body\")\n    targets: t.List[\"Expr\"]\n    values: t.List[\"Expr\"]\n    body: t.List[Node]\n\n\nclass Block(Stmt):\n    \"\"\"A node that represents a block.\n\n    .. versionchanged:: 3.0.0\n        the `required` field was added.\n    \"\"\"\n\n    fields = (\"name\", \"body\", \"scoped\", \"required\")\n    name: str\n    body: t.List[Node]\n    scoped: bool\n    required: bool\n\n\nclass Include(Stmt):\n    \"\"\"A node that represents the include tag.\"\"\"\n\n    fields = (\"template\", \"with_context\", \"ignore_missing\")\n    template: \"Expr\"\n    with_context: bool\n    ignore_missing: bool\n\n\nclass Import(Stmt):\n    \"\"\"A node that represents the import tag.\"\"\"\n\n    fields = (\"template\", \"target\", \"with_context\")\n    template: \"Expr\"\n    target: str\n    with_context: bool\n\n\nclass FromImport(Stmt):\n    \"\"\"A node that represents the from import tag.  It's important to not\n    pass unsafe names to the name attribute.  The compiler translates the\n    attribute lookups directly into getattr calls and does *not* use the\n    subscript callback of the interface.  As exported variables may not\n    start with double underscores (which the parser asserts) this is not a\n    problem for regular Jinja code, but if this node is used in an extension\n    extra care must be taken.\n\n    The list of names may contain tuples if aliases are wanted.\n    \"\"\"\n\n    fields = (\"template\", \"names\", \"with_context\")\n    template: \"Expr\"\n    names: t.List[t.Union[str, t.Tuple[str, str]]]\n    with_context: bool\n\n\nclass ExprStmt(Stmt):\n    \"\"\"A statement that evaluates an expression and discards the result.\"\"\"\n\n    fields = (\"node\",)\n    node: Node\n\n\nclass Assign(Stmt):\n    \"\"\"Assigns an expression to a target.\"\"\"\n\n    fields = (\"target\", \"node\")\n    target: \"Expr\"\n    node: Node\n\n\nclass AssignBlock(Stmt):\n    \"\"\"Assigns a block to a target.\"\"\"\n\n    fields = (\"target\", \"filter\", \"body\")\n    target: \"Expr\"\n    filter: t.Optional[\"Filter\"]\n    body: t.List[Node]\n\n\nclass Expr(Node):\n    \"\"\"Baseclass for all expressions.\"\"\"\n\n    abstract = True\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        \"\"\"Return the value of the expression as constant or raise\n        :exc:`Impossible` if this was not possible.\n\n        An :class:`EvalContext` can be provided, if none is given\n        a default context is created which requires the nodes to have\n        an attached environment.\n\n        .. versionchanged:: 2.4\n           the `eval_ctx` parameter was added.\n        \"\"\"\n        raise Impossible()\n\n    def can_assign(self) -> bool:\n        \"\"\"Check if it's possible to assign something to this node.\"\"\"\n        return False\n\n\nclass BinExpr(Expr):\n    \"\"\"Baseclass for all binary expressions.\"\"\"\n\n    fields = (\"left\", \"right\")\n    left: Expr\n    right: Expr\n    operator: str\n    abstract = True\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        eval_ctx = get_eval_context(self, eval_ctx)\n\n        # intercepted operators cannot be folded at compile time\n        if (\n            eval_ctx.environment.sandboxed\n            and self.operator in eval_ctx.environment.intercepted_binops  # type: ignore\n        ):\n            raise Impossible()\n        f = _binop_to_func[self.operator]\n        try:\n            return f(self.left.as_const(eval_ctx), self.right.as_const(eval_ctx))\n        except Exception as e:\n            raise Impossible() from e\n\n\nclass UnaryExpr(Expr):\n    \"\"\"Baseclass for all unary expressions.\"\"\"\n\n    fields = (\"node\",)\n    node: Expr\n    operator: str\n    abstract = True\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        eval_ctx = get_eval_context(self, eval_ctx)\n\n        # intercepted operators cannot be folded at compile time\n        if (\n            eval_ctx.environment.sandboxed\n            and self.operator in eval_ctx.environment.intercepted_unops  # type: ignore\n        ):\n            raise Impossible()\n        f = _uaop_to_func[self.operator]\n        try:\n            return f(self.node.as_const(eval_ctx))\n        except Exception as e:\n            raise Impossible() from e\n\n\nclass Name(Expr):\n    \"\"\"Looks up a name or stores a value in a name.\n    The `ctx` of the node can be one of the following values:\n\n    -   `store`: store a value in the name\n    -   `load`: load that name\n    -   `param`: like `store` but if the name was defined as function parameter.\n    \"\"\"\n\n    fields = (\"name\", \"ctx\")\n    name: str\n    ctx: str\n\n    def can_assign(self) -> bool:\n        return self.name not in {\"true\", \"false\", \"none\", \"True\", \"False\", \"None\"}\n\n\nclass NSRef(Expr):\n    \"\"\"Reference to a namespace value assignment\"\"\"\n\n    fields = (\"name\", \"attr\")\n    name: str\n    attr: str\n\n    def can_assign(self) -> bool:\n        # We don't need any special checks here; NSRef assignments have a\n        # runtime check to ensure the target is a namespace object which will\n        # have been checked already as it is created using a normal assignment\n        # which goes through a `Name` node.\n        return True\n\n\nclass Literal(Expr):\n    \"\"\"Baseclass for literals.\"\"\"\n\n    abstract = True\n\n\nclass Const(Literal):\n    \"\"\"All constant values.  The parser will return this node for simple\n    constants such as ``42`` or ``\"foo\"`` but it can be used to store more\n    complex values such as lists too.  Only constants with a safe\n    representation (objects where ``eval(repr(x)) == x`` is true).\n    \"\"\"\n\n    fields = (\"value\",)\n    value: t.Any\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        return self.value\n\n    @classmethod\n    def from_untrusted(\n        cls,\n        value: t.Any,\n        lineno: t.Optional[int] = None,\n        environment: \"t.Optional[Environment]\" = None,\n    ) -> \"Const\":\n        \"\"\"Return a const object if the value is representable as\n        constant value in the generated code, otherwise it will raise\n        an `Impossible` exception.\n        \"\"\"\n        from .compiler import has_safe_repr\n\n        if not has_safe_repr(value):\n            raise Impossible()\n        return cls(value, lineno=lineno, environment=environment)\n\n\nclass TemplateData(Literal):\n    \"\"\"A constant template string.\"\"\"\n\n    fields = (\"data\",)\n    data: str\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> str:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        if eval_ctx.autoescape:\n            return Markup(self.data)\n        return self.data\n\n\nclass Tuple(Literal):\n    \"\"\"For loop unpacking and some other things like multiple arguments\n    for subscripts.  Like for :class:`Name` `ctx` specifies if the tuple\n    is used for loading the names or storing.\n    \"\"\"\n\n    fields = (\"items\", \"ctx\")\n    items: t.List[Expr]\n    ctx: str\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Tuple[t.Any, ...]:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return tuple(x.as_const(eval_ctx) for x in self.items)\n\n    def can_assign(self) -> bool:\n        for item in self.items:\n            if not item.can_assign():\n                return False\n        return True\n\n\nclass List(Literal):\n    \"\"\"Any list literal such as ``[1, 2, 3]``\"\"\"\n\n    fields = (\"items\",)\n    items: t.List[Expr]\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.List[t.Any]:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return [x.as_const(eval_ctx) for x in self.items]\n\n\nclass Dict(Literal):\n    \"\"\"Any dict literal such as ``{1: 2, 3: 4}``.  The items must be a list of\n    :class:`Pair` nodes.\n    \"\"\"\n\n    fields = (\"items\",)\n    items: t.List[\"Pair\"]\n\n    def as_const(\n        self, eval_ctx: t.Optional[EvalContext] = None\n    ) -> t.Dict[t.Any, t.Any]:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return dict(x.as_const(eval_ctx) for x in self.items)\n\n\nclass Pair(Helper):\n    \"\"\"A key, value pair for dicts.\"\"\"\n\n    fields = (\"key\", \"value\")\n    key: Expr\n    value: Expr\n\n    def as_const(\n        self, eval_ctx: t.Optional[EvalContext] = None\n    ) -> t.Tuple[t.Any, t.Any]:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key.as_const(eval_ctx), self.value.as_const(eval_ctx)\n\n\nclass Keyword(Helper):\n    \"\"\"A key, value pair for keyword arguments where key is a string.\"\"\"\n\n    fields = (\"key\", \"value\")\n    key: str\n    value: Expr\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Tuple[str, t.Any]:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.key, self.value.as_const(eval_ctx)\n\n\nclass CondExpr(Expr):\n    \"\"\"A conditional expression (inline if expression).  (``{{\n    foo if bar else baz }}``)\n    \"\"\"\n\n    fields = (\"test\", \"expr1\", \"expr2\")\n    test: Expr\n    expr1: Expr\n    expr2: t.Optional[Expr]\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if self.test.as_const(eval_ctx):\n            return self.expr1.as_const(eval_ctx)\n\n        # if we evaluate to an undefined object, we better do that at runtime\n        if self.expr2 is None:\n            raise Impossible()\n\n        return self.expr2.as_const(eval_ctx)\n\n\ndef args_as_const(\n    node: t.Union[\"_FilterTestCommon\", \"Call\"], eval_ctx: t.Optional[EvalContext]\n) -> t.Tuple[t.List[t.Any], t.Dict[t.Any, t.Any]]:\n    args = [x.as_const(eval_ctx) for x in node.args]\n    kwargs = dict(x.as_const(eval_ctx) for x in node.kwargs)\n\n    if node.dyn_args is not None:\n        try:\n            args.extend(node.dyn_args.as_const(eval_ctx))\n        except Exception as e:\n            raise Impossible() from e\n\n    if node.dyn_kwargs is not None:\n        try:\n            kwargs.update(node.dyn_kwargs.as_const(eval_ctx))\n        except Exception as e:\n            raise Impossible() from e\n\n    return args, kwargs\n\n\nclass _FilterTestCommon(Expr):\n    fields = (\"node\", \"name\", \"args\", \"kwargs\", \"dyn_args\", \"dyn_kwargs\")\n    node: Expr\n    name: str\n    args: t.List[Expr]\n    kwargs: t.List[Pair]\n    dyn_args: t.Optional[Expr]\n    dyn_kwargs: t.Optional[Expr]\n    abstract = True\n    _is_filter = True\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        eval_ctx = get_eval_context(self, eval_ctx)\n\n        if eval_ctx.volatile:\n            raise Impossible()\n\n        if self._is_filter:\n            env_map = eval_ctx.environment.filters\n        else:\n            env_map = eval_ctx.environment.tests\n\n        func = env_map.get(self.name)\n        pass_arg = _PassArg.from_obj(func)  # type: ignore\n\n        if func is None or pass_arg is _PassArg.context:\n            raise Impossible()\n\n        if eval_ctx.environment.is_async and (\n            getattr(func, \"jinja_async_variant\", False) is True\n            or inspect.iscoroutinefunction(func)\n        ):\n            raise Impossible()\n\n        args, kwargs = args_as_const(self, eval_ctx)\n        args.insert(0, self.node.as_const(eval_ctx))\n\n        if pass_arg is _PassArg.eval_context:\n            args.insert(0, eval_ctx)\n        elif pass_arg is _PassArg.environment:\n            args.insert(0, eval_ctx.environment)\n\n        try:\n            return func(*args, **kwargs)\n        except Exception as e:\n            raise Impossible() from e\n\n\nclass Filter(_FilterTestCommon):\n    \"\"\"Apply a filter to an expression. ``name`` is the name of the\n    filter, the other fields are the same as :class:`Call`.\n\n    If ``node`` is ``None``, the filter is being used in a filter block\n    and is applied to the content of the block.\n    \"\"\"\n\n    node: t.Optional[Expr]  # type: ignore\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        if self.node is None:\n            raise Impossible()\n\n        return super().as_const(eval_ctx=eval_ctx)\n\n\nclass Test(_FilterTestCommon):\n    \"\"\"Apply a test to an expression. ``name`` is the name of the test,\n    the other field are the same as :class:`Call`.\n\n    .. versionchanged:: 3.0\n        ``as_const`` shares the same logic for filters and tests. Tests\n        check for volatile, async, and ``@pass_context`` etc.\n        decorators.\n    \"\"\"\n\n    _is_filter = False\n\n\nclass Call(Expr):\n    \"\"\"Calls an expression.  `args` is a list of arguments, `kwargs` a list\n    of keyword arguments (list of :class:`Keyword` nodes), and `dyn_args`\n    and `dyn_kwargs` has to be either `None` or a node that is used as\n    node for dynamic positional (``*args``) or keyword (``**kwargs``)\n    arguments.\n    \"\"\"\n\n    fields = (\"node\", \"args\", \"kwargs\", \"dyn_args\", \"dyn_kwargs\")\n    node: Expr\n    args: t.List[Expr]\n    kwargs: t.List[Keyword]\n    dyn_args: t.Optional[Expr]\n    dyn_kwargs: t.Optional[Expr]\n\n\nclass Getitem(Expr):\n    \"\"\"Get an attribute or item from an expression and prefer the item.\"\"\"\n\n    fields = (\"node\", \"arg\", \"ctx\")\n    node: Expr\n    arg: Expr\n    ctx: str\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        if self.ctx != \"load\":\n            raise Impossible()\n\n        eval_ctx = get_eval_context(self, eval_ctx)\n\n        try:\n            return eval_ctx.environment.getitem(\n                self.node.as_const(eval_ctx), self.arg.as_const(eval_ctx)\n            )\n        except Exception as e:\n            raise Impossible() from e\n\n\nclass Getattr(Expr):\n    \"\"\"Get an attribute or item from an expression that is a ascii-only\n    bytestring and prefer the attribute.\n    \"\"\"\n\n    fields = (\"node\", \"attr\", \"ctx\")\n    node: Expr\n    attr: str\n    ctx: str\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        if self.ctx != \"load\":\n            raise Impossible()\n\n        eval_ctx = get_eval_context(self, eval_ctx)\n\n        try:\n            return eval_ctx.environment.getattr(self.node.as_const(eval_ctx), self.attr)\n        except Exception as e:\n            raise Impossible() from e\n\n\nclass Slice(Expr):\n    \"\"\"Represents a slice object.  This must only be used as argument for\n    :class:`Subscript`.\n    \"\"\"\n\n    fields = (\"start\", \"stop\", \"step\")\n    start: t.Optional[Expr]\n    stop: t.Optional[Expr]\n    step: t.Optional[Expr]\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> slice:\n        eval_ctx = get_eval_context(self, eval_ctx)\n\n        def const(obj: t.Optional[Expr]) -> t.Optional[t.Any]:\n            if obj is None:\n                return None\n            return obj.as_const(eval_ctx)\n\n        return slice(const(self.start), const(self.stop), const(self.step))\n\n\nclass Concat(Expr):\n    \"\"\"Concatenates the list of expressions provided after converting\n    them to strings.\n    \"\"\"\n\n    fields = (\"nodes\",)\n    nodes: t.List[Expr]\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> str:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return \"\".join(str(x.as_const(eval_ctx)) for x in self.nodes)\n\n\nclass Compare(Expr):\n    \"\"\"Compares an expression with some other expressions.  `ops` must be a\n    list of :class:`Operand`\\\\s.\n    \"\"\"\n\n    fields = (\"expr\", \"ops\")\n    expr: Expr\n    ops: t.List[\"Operand\"]\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        result = value = self.expr.as_const(eval_ctx)\n\n        try:\n            for op in self.ops:\n                new_value = op.expr.as_const(eval_ctx)\n                result = _cmpop_to_func[op.op](value, new_value)\n\n                if not result:\n                    return False\n\n                value = new_value\n        except Exception as e:\n            raise Impossible() from e\n\n        return result\n\n\nclass Operand(Helper):\n    \"\"\"Holds an operator and an expression.\"\"\"\n\n    fields = (\"op\", \"expr\")\n    op: str\n    expr: Expr\n\n\nclass Mul(BinExpr):\n    \"\"\"Multiplies the left with the right node.\"\"\"\n\n    operator = \"*\"\n\n\nclass Div(BinExpr):\n    \"\"\"Divides the left by the right node.\"\"\"\n\n    operator = \"/\"\n\n\nclass FloorDiv(BinExpr):\n    \"\"\"Divides the left by the right node and converts the\n    result into an integer by truncating.\n    \"\"\"\n\n    operator = \"//\"\n\n\nclass Add(BinExpr):\n    \"\"\"Add the left to the right node.\"\"\"\n\n    operator = \"+\"\n\n\nclass Sub(BinExpr):\n    \"\"\"Subtract the right from the left node.\"\"\"\n\n    operator = \"-\"\n\n\nclass Mod(BinExpr):\n    \"\"\"Left modulo right.\"\"\"\n\n    operator = \"%\"\n\n\nclass Pow(BinExpr):\n    \"\"\"Left to the power of right.\"\"\"\n\n    operator = \"**\"\n\n\nclass And(BinExpr):\n    \"\"\"Short circuited AND.\"\"\"\n\n    operator = \"and\"\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) and self.right.as_const(eval_ctx)\n\n\nclass Or(BinExpr):\n    \"\"\"Short circuited OR.\"\"\"\n\n    operator = \"or\"\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> t.Any:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return self.left.as_const(eval_ctx) or self.right.as_const(eval_ctx)\n\n\nclass Not(UnaryExpr):\n    \"\"\"Negate the expression.\"\"\"\n\n    operator = \"not\"\n\n\nclass Neg(UnaryExpr):\n    \"\"\"Make the expression negative.\"\"\"\n\n    operator = \"-\"\n\n\nclass Pos(UnaryExpr):\n    \"\"\"Make the expression positive (noop for most expressions)\"\"\"\n\n    operator = \"+\"\n\n\n# Helpers for extensions\n\n\nclass EnvironmentAttribute(Expr):\n    \"\"\"Loads an attribute from the environment object.  This is useful for\n    extensions that want to call a callback stored on the environment.\n    \"\"\"\n\n    fields = (\"name\",)\n    name: str\n\n\nclass ExtensionAttribute(Expr):\n    \"\"\"Returns the attribute of an extension bound to the environment.\n    The identifier is the identifier of the :class:`Extension`.\n\n    This node is usually constructed by calling the\n    :meth:`~jinja2.ext.Extension.attr` method on an extension.\n    \"\"\"\n\n    fields = (\"identifier\", \"name\")\n    identifier: str\n    name: str\n\n\nclass ImportedName(Expr):\n    \"\"\"If created with an import name the import name is returned on node\n    access.  For example ``ImportedName('cgi.escape')`` returns the `escape`\n    function from the cgi module on evaluation.  Imports are optimized by the\n    compiler so there is no need to assign them to local variables.\n    \"\"\"\n\n    fields = (\"importname\",)\n    importname: str\n\n\nclass InternalName(Expr):\n    \"\"\"An internal name in the compiler.  You cannot create these nodes\n    yourself but the parser provides a\n    :meth:`~jinja2.parser.Parser.free_identifier` method that creates\n    a new identifier for you.  This identifier is not available from the\n    template and is not treated specially by the compiler.\n    \"\"\"\n\n    fields = (\"name\",)\n    name: str\n\n    def __init__(self) -> None:\n        raise TypeError(\n            \"Can't create internal names.  Use the \"\n            \"`free_identifier` method on a parser.\"\n        )\n\n\nclass MarkSafe(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`).\"\"\"\n\n    fields = (\"expr\",)\n    expr: Expr\n\n    def as_const(self, eval_ctx: t.Optional[EvalContext] = None) -> Markup:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        return Markup(self.expr.as_const(eval_ctx))\n\n\nclass MarkSafeIfAutoescape(Expr):\n    \"\"\"Mark the wrapped expression as safe (wrap it as `Markup`) but\n    only if autoescaping is active.\n\n    .. versionadded:: 2.5\n    \"\"\"\n\n    fields = (\"expr\",)\n    expr: Expr\n\n    def as_const(\n        self, eval_ctx: t.Optional[EvalContext] = None\n    ) -> t.Union[Markup, t.Any]:\n        eval_ctx = get_eval_context(self, eval_ctx)\n        if eval_ctx.volatile:\n            raise Impossible()\n        expr = self.expr.as_const(eval_ctx)\n        if eval_ctx.autoescape:\n            return Markup(expr)\n        return expr\n\n\nclass ContextReference(Expr):\n    \"\"\"Returns the current template context.  It can be used like a\n    :class:`Name` node, with a ``'load'`` ctx and will return the\n    current :class:`~jinja2.runtime.Context` object.\n\n    Here an example that assigns the current template name to a\n    variable named `foo`::\n\n        Assign(Name('foo', ctx='store'),\n               Getattr(ContextReference(), 'name'))\n\n    This is basically equivalent to using the\n    :func:`~jinja2.pass_context` decorator when using the high-level\n    API, which causes a reference to the context to be passed as the\n    first argument to a function.\n    \"\"\"\n\n\nclass DerivedContextReference(Expr):\n    \"\"\"Return the current template context including locals. Behaves\n    exactly like :class:`ContextReference`, but includes local\n    variables, such as from a ``for`` loop.\n\n    .. versionadded:: 2.11\n    \"\"\"\n\n\nclass Continue(Stmt):\n    \"\"\"Continue a loop.\"\"\"\n\n\nclass Break(Stmt):\n    \"\"\"Break a loop.\"\"\"\n\n\nclass Scope(Stmt):\n    \"\"\"An artificial scope.\"\"\"\n\n    fields = (\"body\",)\n    body: t.List[Node]\n\n\nclass OverlayScope(Stmt):\n    \"\"\"An overlay scope for extensions.  This is a largely unoptimized scope\n    that however can be used to introduce completely arbitrary variables into\n    a sub scope from a dictionary or dictionary like object.  The `context`\n    field has to evaluate to a dictionary object.\n\n    Example usage::\n\n        OverlayScope(context=self.call_method('get_context'),\n                     body=[...])\n\n    .. versionadded:: 2.10\n    \"\"\"\n\n    fields = (\"context\", \"body\")\n    context: Expr\n    body: t.List[Node]\n\n\nclass EvalContextModifier(Stmt):\n    \"\"\"Modifies the eval context.  For each option that should be modified,\n    a :class:`Keyword` has to be added to the :attr:`options` list.\n\n    Example to change the `autoescape` setting::\n\n        EvalContextModifier(options=[Keyword('autoescape', Const(True))])\n    \"\"\"\n\n    fields = (\"options\",)\n    options: t.List[Keyword]\n\n\nclass ScopedEvalContextModifier(EvalContextModifier):\n    \"\"\"Modifies the eval context and reverts it later.  Works exactly like\n    :class:`EvalContextModifier` but will only modify the\n    :class:`~jinja2.nodes.EvalContext` for nodes in the :attr:`body`.\n    \"\"\"\n\n    fields = (\"body\",)\n    body: t.List[Node]\n\n\n# make sure nobody creates custom nodes\ndef _failing_new(*args: t.Any, **kwargs: t.Any) -> \"te.NoReturn\":\n    raise TypeError(\"can't create custom node types\")\n\n\nNodeType.__new__ = staticmethod(_failing_new)  # type: ignore\ndel _failing_new\n", "src/jinja2/constants.py": "#: list of lorem ipsum words used by the lipsum() helper function\nLOREM_IPSUM_WORDS = \"\"\"\\\na ac accumsan ad adipiscing aenean aliquam aliquet amet ante aptent arcu at\nauctor augue bibendum blandit class commodo condimentum congue consectetuer\nconsequat conubia convallis cras cubilia cum curabitur curae cursus dapibus\ndiam dictum dictumst dignissim dis dolor donec dui duis egestas eget eleifend\nelementum elit enim erat eros est et etiam eu euismod facilisi facilisis fames\nfaucibus felis fermentum feugiat fringilla fusce gravida habitant habitasse hac\nhendrerit hymenaeos iaculis id imperdiet in inceptos integer interdum ipsum\njusto lacinia lacus laoreet lectus leo libero ligula litora lobortis lorem\nluctus maecenas magna magnis malesuada massa mattis mauris metus mi molestie\nmollis montes morbi mus nam nascetur natoque nec neque netus nibh nisi nisl non\nnonummy nostra nulla nullam nunc odio orci ornare parturient pede pellentesque\npenatibus per pharetra phasellus placerat platea porta porttitor posuere\npotenti praesent pretium primis proin pulvinar purus quam quis quisque rhoncus\nridiculus risus rutrum sagittis sapien scelerisque sed sem semper senectus sit\nsociis sociosqu sodales sollicitudin suscipit suspendisse taciti tellus tempor\ntempus tincidunt torquent tortor tristique turpis ullamcorper ultrices\nultricies urna ut varius vehicula vel velit venenatis vestibulum vitae vivamus\nviverra volutpat vulputate\"\"\"\n", "src/jinja2/bccache.py": "\"\"\"The optional bytecode cache system. This is useful if you have very\ncomplex template situations and the compilation of all those templates\nslows down your application too much.\n\nSituations where this is useful are often forking web applications that\nare initialized on the first request.\n\"\"\"\n\nimport errno\nimport fnmatch\nimport marshal\nimport os\nimport pickle\nimport stat\nimport sys\nimport tempfile\nimport typing as t\nfrom hashlib import sha1\nfrom io import BytesIO\nfrom types import CodeType\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .environment import Environment\n\n    class _MemcachedClient(te.Protocol):\n        def get(self, key: str) -> bytes: ...\n\n        def set(\n            self, key: str, value: bytes, timeout: t.Optional[int] = None\n        ) -> None: ...\n\n\nbc_version = 5\n# Magic bytes to identify Jinja bytecode cache files. Contains the\n# Python major and minor version to avoid loading incompatible bytecode\n# if a project upgrades its Python version.\nbc_magic = (\n    b\"j2\"\n    + pickle.dumps(bc_version, 2)\n    + pickle.dumps((sys.version_info[0] << 24) | sys.version_info[1], 2)\n)\n\n\nclass Bucket:\n    \"\"\"Buckets are used to store the bytecode for one template.  It's created\n    and initialized by the bytecode cache and passed to the loading functions.\n\n    The buckets get an internal checksum from the cache assigned and use this\n    to automatically reject outdated cache material.  Individual bytecode\n    cache subclasses don't have to care about cache invalidation.\n    \"\"\"\n\n    def __init__(self, environment: \"Environment\", key: str, checksum: str) -> None:\n        self.environment = environment\n        self.key = key\n        self.checksum = checksum\n        self.reset()\n\n    def reset(self) -> None:\n        \"\"\"Resets the bucket (unloads the bytecode).\"\"\"\n        self.code: t.Optional[CodeType] = None\n\n    def load_bytecode(self, f: t.BinaryIO) -> None:\n        \"\"\"Loads bytecode from a file or file like object.\"\"\"\n        # make sure the magic header is correct\n        magic = f.read(len(bc_magic))\n        if magic != bc_magic:\n            self.reset()\n            return\n        # the source code of the file changed, we need to reload\n        checksum = pickle.load(f)\n        if self.checksum != checksum:\n            self.reset()\n            return\n        # if marshal_load fails then we need to reload\n        try:\n            self.code = marshal.load(f)\n        except (EOFError, ValueError, TypeError):\n            self.reset()\n            return\n\n    def write_bytecode(self, f: t.IO[bytes]) -> None:\n        \"\"\"Dump the bytecode into the file or file like object passed.\"\"\"\n        if self.code is None:\n            raise TypeError(\"can't write empty bucket\")\n        f.write(bc_magic)\n        pickle.dump(self.checksum, f, 2)\n        marshal.dump(self.code, f)\n\n    def bytecode_from_string(self, string: bytes) -> None:\n        \"\"\"Load bytecode from bytes.\"\"\"\n        self.load_bytecode(BytesIO(string))\n\n    def bytecode_to_string(self) -> bytes:\n        \"\"\"Return the bytecode as bytes.\"\"\"\n        out = BytesIO()\n        self.write_bytecode(out)\n        return out.getvalue()\n\n\nclass BytecodeCache:\n    \"\"\"To implement your own bytecode cache you have to subclass this class\n    and override :meth:`load_bytecode` and :meth:`dump_bytecode`.  Both of\n    these methods are passed a :class:`~jinja2.bccache.Bucket`.\n\n    A very basic bytecode cache that saves the bytecode on the file system::\n\n        from os import path\n\n        class MyCache(BytecodeCache):\n\n            def __init__(self, directory):\n                self.directory = directory\n\n            def load_bytecode(self, bucket):\n                filename = path.join(self.directory, bucket.key)\n                if path.exists(filename):\n                    with open(filename, 'rb') as f:\n                        bucket.load_bytecode(f)\n\n            def dump_bytecode(self, bucket):\n                filename = path.join(self.directory, bucket.key)\n                with open(filename, 'wb') as f:\n                    bucket.write_bytecode(f)\n\n    A more advanced version of a filesystem based bytecode cache is part of\n    Jinja.\n    \"\"\"\n\n    def load_bytecode(self, bucket: Bucket) -> None:\n        \"\"\"Subclasses have to override this method to load bytecode into a\n        bucket.  If they are not able to find code in the cache for the\n        bucket, it must not do anything.\n        \"\"\"\n        raise NotImplementedError()\n\n    def dump_bytecode(self, bucket: Bucket) -> None:\n        \"\"\"Subclasses have to override this method to write the bytecode\n        from a bucket back to the cache.  If it unable to do so it must not\n        fail silently but raise an exception.\n        \"\"\"\n        raise NotImplementedError()\n\n    def clear(self) -> None:\n        \"\"\"Clears the cache.  This method is not used by Jinja but should be\n        implemented to allow applications to clear the bytecode cache used\n        by a particular environment.\n        \"\"\"\n\n    def get_cache_key(\n        self, name: str, filename: t.Optional[t.Union[str]] = None\n    ) -> str:\n        \"\"\"Returns the unique hash key for this template name.\"\"\"\n        hash = sha1(name.encode(\"utf-8\"))\n\n        if filename is not None:\n            hash.update(f\"|{filename}\".encode())\n\n        return hash.hexdigest()\n\n    def get_source_checksum(self, source: str) -> str:\n        \"\"\"Returns a checksum for the source.\"\"\"\n        return sha1(source.encode(\"utf-8\")).hexdigest()\n\n    def get_bucket(\n        self,\n        environment: \"Environment\",\n        name: str,\n        filename: t.Optional[str],\n        source: str,\n    ) -> Bucket:\n        \"\"\"Return a cache bucket for the given template.  All arguments are\n        mandatory but filename may be `None`.\n        \"\"\"\n        key = self.get_cache_key(name, filename)\n        checksum = self.get_source_checksum(source)\n        bucket = Bucket(environment, key, checksum)\n        self.load_bytecode(bucket)\n        return bucket\n\n    def set_bucket(self, bucket: Bucket) -> None:\n        \"\"\"Put the bucket into the cache.\"\"\"\n        self.dump_bytecode(bucket)\n\n\nclass FileSystemBytecodeCache(BytecodeCache):\n    \"\"\"A bytecode cache that stores bytecode on the filesystem.  It accepts\n    two arguments: The directory where the cache items are stored and a\n    pattern string that is used to build the filename.\n\n    If no directory is specified a default cache directory is selected.  On\n    Windows the user's temp directory is used, on UNIX systems a directory\n    is created for the user in the system temp directory.\n\n    The pattern can be used to have multiple separate caches operate on the\n    same directory.  The default pattern is ``'__jinja2_%s.cache'``.  ``%s``\n    is replaced with the cache key.\n\n    >>> bcc = FileSystemBytecodeCache('/tmp/jinja_cache', '%s.cache')\n\n    This bytecode cache supports clearing of the cache using the clear method.\n    \"\"\"\n\n    def __init__(\n        self, directory: t.Optional[str] = None, pattern: str = \"__jinja2_%s.cache\"\n    ) -> None:\n        if directory is None:\n            directory = self._get_default_cache_dir()\n        self.directory = directory\n        self.pattern = pattern\n\n    def _get_default_cache_dir(self) -> str:\n        def _unsafe_dir() -> \"te.NoReturn\":\n            raise RuntimeError(\n                \"Cannot determine safe temp directory.  You \"\n                \"need to explicitly provide one.\"\n            )\n\n        tmpdir = tempfile.gettempdir()\n\n        # On windows the temporary directory is used specific unless\n        # explicitly forced otherwise.  We can just use that.\n        if os.name == \"nt\":\n            return tmpdir\n        if not hasattr(os, \"getuid\"):\n            _unsafe_dir()\n\n        dirname = f\"_jinja2-cache-{os.getuid()}\"\n        actual_dir = os.path.join(tmpdir, dirname)\n\n        try:\n            os.mkdir(actual_dir, stat.S_IRWXU)\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n        try:\n            os.chmod(actual_dir, stat.S_IRWXU)\n            actual_dir_stat = os.lstat(actual_dir)\n            if (\n                actual_dir_stat.st_uid != os.getuid()\n                or not stat.S_ISDIR(actual_dir_stat.st_mode)\n                or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU\n            ):\n                _unsafe_dir()\n        except OSError as e:\n            if e.errno != errno.EEXIST:\n                raise\n\n        actual_dir_stat = os.lstat(actual_dir)\n        if (\n            actual_dir_stat.st_uid != os.getuid()\n            or not stat.S_ISDIR(actual_dir_stat.st_mode)\n            or stat.S_IMODE(actual_dir_stat.st_mode) != stat.S_IRWXU\n        ):\n            _unsafe_dir()\n\n        return actual_dir\n\n    def _get_cache_filename(self, bucket: Bucket) -> str:\n        return os.path.join(self.directory, self.pattern % (bucket.key,))\n\n    def load_bytecode(self, bucket: Bucket) -> None:\n        filename = self._get_cache_filename(bucket)\n\n        # Don't test for existence before opening the file, since the\n        # file could disappear after the test before the open.\n        try:\n            f = open(filename, \"rb\")\n        except (FileNotFoundError, IsADirectoryError, PermissionError):\n            # PermissionError can occur on Windows when an operation is\n            # in progress, such as calling clear().\n            return\n\n        with f:\n            bucket.load_bytecode(f)\n\n    def dump_bytecode(self, bucket: Bucket) -> None:\n        # Write to a temporary file, then rename to the real name after\n        # writing. This avoids another process reading the file before\n        # it is fully written.\n        name = self._get_cache_filename(bucket)\n        f = tempfile.NamedTemporaryFile(\n            mode=\"wb\",\n            dir=os.path.dirname(name),\n            prefix=os.path.basename(name),\n            suffix=\".tmp\",\n            delete=False,\n        )\n\n        def remove_silent() -> None:\n            try:\n                os.remove(f.name)\n            except OSError:\n                # Another process may have called clear(). On Windows,\n                # another program may be holding the file open.\n                pass\n\n        try:\n            with f:\n                bucket.write_bytecode(f)\n        except BaseException:\n            remove_silent()\n            raise\n\n        try:\n            os.replace(f.name, name)\n        except OSError:\n            # Another process may have called clear(). On Windows,\n            # another program may be holding the file open.\n            remove_silent()\n        except BaseException:\n            remove_silent()\n            raise\n\n    def clear(self) -> None:\n        # imported lazily here because google app-engine doesn't support\n        # write access on the file system and the function does not exist\n        # normally.\n        from os import remove\n\n        files = fnmatch.filter(os.listdir(self.directory), self.pattern % (\"*\",))\n        for filename in files:\n            try:\n                remove(os.path.join(self.directory, filename))\n            except OSError:\n                pass\n\n\nclass MemcachedBytecodeCache(BytecodeCache):\n    \"\"\"This class implements a bytecode cache that uses a memcache cache for\n    storing the information.  It does not enforce a specific memcache library\n    (tummy's memcache or cmemcache) but will accept any class that provides\n    the minimal interface required.\n\n    Libraries compatible with this class:\n\n    -   `cachelib <https://github.com/pallets/cachelib>`_\n    -   `python-memcached <https://pypi.org/project/python-memcached/>`_\n\n    (Unfortunately the django cache interface is not compatible because it\n    does not support storing binary data, only text. You can however pass\n    the underlying cache client to the bytecode cache which is available\n    as `django.core.cache.cache._client`.)\n\n    The minimal interface for the client passed to the constructor is this:\n\n    .. class:: MinimalClientInterface\n\n        .. method:: set(key, value[, timeout])\n\n            Stores the bytecode in the cache.  `value` is a string and\n            `timeout` the timeout of the key.  If timeout is not provided\n            a default timeout or no timeout should be assumed, if it's\n            provided it's an integer with the number of seconds the cache\n            item should exist.\n\n        .. method:: get(key)\n\n            Returns the value for the cache key.  If the item does not\n            exist in the cache the return value must be `None`.\n\n    The other arguments to the constructor are the prefix for all keys that\n    is added before the actual cache key and the timeout for the bytecode in\n    the cache system.  We recommend a high (or no) timeout.\n\n    This bytecode cache does not support clearing of used items in the cache.\n    The clear method is a no-operation function.\n\n    .. versionadded:: 2.7\n       Added support for ignoring memcache errors through the\n       `ignore_memcache_errors` parameter.\n    \"\"\"\n\n    def __init__(\n        self,\n        client: \"_MemcachedClient\",\n        prefix: str = \"jinja2/bytecode/\",\n        timeout: t.Optional[int] = None,\n        ignore_memcache_errors: bool = True,\n    ):\n        self.client = client\n        self.prefix = prefix\n        self.timeout = timeout\n        self.ignore_memcache_errors = ignore_memcache_errors\n\n    def load_bytecode(self, bucket: Bucket) -> None:\n        try:\n            code = self.client.get(self.prefix + bucket.key)\n        except Exception:\n            if not self.ignore_memcache_errors:\n                raise\n        else:\n            bucket.bytecode_from_string(code)\n\n    def dump_bytecode(self, bucket: Bucket) -> None:\n        key = self.prefix + bucket.key\n        value = bucket.bytecode_to_string()\n\n        try:\n            if self.timeout is not None:\n                self.client.set(key, value, self.timeout)\n            else:\n                self.client.set(key, value)\n        except Exception:\n            if not self.ignore_memcache_errors:\n                raise\n", "src/jinja2/__init__.py": "\"\"\"Jinja is a template engine written in pure Python. It provides a\nnon-XML syntax that supports inline expressions and an optional\nsandboxed environment.\n\"\"\"\n\nfrom .bccache import BytecodeCache as BytecodeCache\nfrom .bccache import FileSystemBytecodeCache as FileSystemBytecodeCache\nfrom .bccache import MemcachedBytecodeCache as MemcachedBytecodeCache\nfrom .environment import Environment as Environment\nfrom .environment import Template as Template\nfrom .exceptions import TemplateAssertionError as TemplateAssertionError\nfrom .exceptions import TemplateError as TemplateError\nfrom .exceptions import TemplateNotFound as TemplateNotFound\nfrom .exceptions import TemplateRuntimeError as TemplateRuntimeError\nfrom .exceptions import TemplatesNotFound as TemplatesNotFound\nfrom .exceptions import TemplateSyntaxError as TemplateSyntaxError\nfrom .exceptions import UndefinedError as UndefinedError\nfrom .loaders import BaseLoader as BaseLoader\nfrom .loaders import ChoiceLoader as ChoiceLoader\nfrom .loaders import DictLoader as DictLoader\nfrom .loaders import FileSystemLoader as FileSystemLoader\nfrom .loaders import FunctionLoader as FunctionLoader\nfrom .loaders import ModuleLoader as ModuleLoader\nfrom .loaders import PackageLoader as PackageLoader\nfrom .loaders import PrefixLoader as PrefixLoader\nfrom .runtime import ChainableUndefined as ChainableUndefined\nfrom .runtime import DebugUndefined as DebugUndefined\nfrom .runtime import make_logging_undefined as make_logging_undefined\nfrom .runtime import StrictUndefined as StrictUndefined\nfrom .runtime import Undefined as Undefined\nfrom .utils import clear_caches as clear_caches\nfrom .utils import is_undefined as is_undefined\nfrom .utils import pass_context as pass_context\nfrom .utils import pass_environment as pass_environment\nfrom .utils import pass_eval_context as pass_eval_context\nfrom .utils import select_autoescape as select_autoescape\n\n__version__ = \"3.2.0.dev0\"\n", "src/jinja2/parser.py": "\"\"\"Parse tokens from the lexer into nodes for the compiler.\"\"\"\n\nimport typing\nimport typing as t\n\nfrom . import nodes\nfrom .exceptions import TemplateAssertionError\nfrom .exceptions import TemplateSyntaxError\nfrom .lexer import describe_token\nfrom .lexer import describe_token_expr\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    from .environment import Environment\n\n_ImportInclude = t.TypeVar(\"_ImportInclude\", nodes.Import, nodes.Include)\n_MacroCall = t.TypeVar(\"_MacroCall\", nodes.Macro, nodes.CallBlock)\n\n_statement_keywords = frozenset(\n    [\n        \"for\",\n        \"if\",\n        \"block\",\n        \"extends\",\n        \"print\",\n        \"macro\",\n        \"include\",\n        \"from\",\n        \"import\",\n        \"set\",\n        \"with\",\n        \"autoescape\",\n    ]\n)\n_compare_operators = frozenset([\"eq\", \"ne\", \"lt\", \"lteq\", \"gt\", \"gteq\"])\n\n_math_nodes: t.Dict[str, t.Type[nodes.Expr]] = {\n    \"add\": nodes.Add,\n    \"sub\": nodes.Sub,\n    \"mul\": nodes.Mul,\n    \"div\": nodes.Div,\n    \"floordiv\": nodes.FloorDiv,\n    \"mod\": nodes.Mod,\n}\n\n\nclass Parser:\n    \"\"\"This is the central parsing class Jinja uses.  It's passed to\n    extensions and can be used to parse expressions or statements.\n    \"\"\"\n\n    def __init__(\n        self,\n        environment: \"Environment\",\n        source: str,\n        name: t.Optional[str] = None,\n        filename: t.Optional[str] = None,\n        state: t.Optional[str] = None,\n    ) -> None:\n        self.environment = environment\n        self.stream = environment._tokenize(source, name, filename, state)\n        self.name = name\n        self.filename = filename\n        self.closed = False\n        self.extensions: t.Dict[\n            str, t.Callable[[Parser], t.Union[nodes.Node, t.List[nodes.Node]]]\n        ] = {}\n        for extension in environment.iter_extensions():\n            for tag in extension.tags:\n                self.extensions[tag] = extension.parse\n        self._last_identifier = 0\n        self._tag_stack: t.List[str] = []\n        self._end_token_stack: t.List[t.Tuple[str, ...]] = []\n\n    def fail(\n        self,\n        msg: str,\n        lineno: t.Optional[int] = None,\n        exc: t.Type[TemplateSyntaxError] = TemplateSyntaxError,\n    ) -> \"te.NoReturn\":\n        \"\"\"Convenience method that raises `exc` with the message, passed\n        line number or last line number as well as the current name and\n        filename.\n        \"\"\"\n        if lineno is None:\n            lineno = self.stream.current.lineno\n        raise exc(msg, lineno, self.name, self.filename)\n\n    def _fail_ut_eof(\n        self,\n        name: t.Optional[str],\n        end_token_stack: t.List[t.Tuple[str, ...]],\n        lineno: t.Optional[int],\n    ) -> \"te.NoReturn\":\n        expected: t.Set[str] = set()\n        for exprs in end_token_stack:\n            expected.update(map(describe_token_expr, exprs))\n        if end_token_stack:\n            currently_looking: t.Optional[str] = \" or \".join(\n                map(repr, map(describe_token_expr, end_token_stack[-1]))\n            )\n        else:\n            currently_looking = None\n\n        if name is None:\n            message = [\"Unexpected end of template.\"]\n        else:\n            message = [f\"Encountered unknown tag {name!r}.\"]\n\n        if currently_looking:\n            if name is not None and name in expected:\n                message.append(\n                    \"You probably made a nesting mistake. Jinja is expecting this tag,\"\n                    f\" but currently looking for {currently_looking}.\"\n                )\n            else:\n                message.append(\n                    f\"Jinja was looking for the following tags: {currently_looking}.\"\n                )\n\n        if self._tag_stack:\n            message.append(\n                \"The innermost block that needs to be closed is\"\n                f\" {self._tag_stack[-1]!r}.\"\n            )\n\n        self.fail(\" \".join(message), lineno)\n\n    def fail_unknown_tag(\n        self, name: str, lineno: t.Optional[int] = None\n    ) -> \"te.NoReturn\":\n        \"\"\"Called if the parser encounters an unknown tag.  Tries to fail\n        with a human readable error message that could help to identify\n        the problem.\n        \"\"\"\n        self._fail_ut_eof(name, self._end_token_stack, lineno)\n\n    def fail_eof(\n        self,\n        end_tokens: t.Optional[t.Tuple[str, ...]] = None,\n        lineno: t.Optional[int] = None,\n    ) -> \"te.NoReturn\":\n        \"\"\"Like fail_unknown_tag but for end of template situations.\"\"\"\n        stack = list(self._end_token_stack)\n        if end_tokens is not None:\n            stack.append(end_tokens)\n        self._fail_ut_eof(None, stack, lineno)\n\n    def is_tuple_end(\n        self, extra_end_rules: t.Optional[t.Tuple[str, ...]] = None\n    ) -> bool:\n        \"\"\"Are we at the end of a tuple?\"\"\"\n        if self.stream.current.type in (\"variable_end\", \"block_end\", \"rparen\"):\n            return True\n        elif extra_end_rules is not None:\n            return self.stream.current.test_any(extra_end_rules)  # type: ignore\n        return False\n\n    def free_identifier(self, lineno: t.Optional[int] = None) -> nodes.InternalName:\n        \"\"\"Return a new free identifier as :class:`~jinja2.nodes.InternalName`.\"\"\"\n        self._last_identifier += 1\n        rv = object.__new__(nodes.InternalName)\n        nodes.Node.__init__(rv, f\"fi{self._last_identifier}\", lineno=lineno)\n        return rv\n\n    def parse_statement(self) -> t.Union[nodes.Node, t.List[nodes.Node]]:\n        \"\"\"Parse a single statement.\"\"\"\n        token = self.stream.current\n        if token.type != \"name\":\n            self.fail(\"tag name expected\", token.lineno)\n        self._tag_stack.append(token.value)\n        pop_tag = True\n        try:\n            if token.value in _statement_keywords:\n                f = getattr(self, f\"parse_{self.stream.current.value}\")\n                return f()  # type: ignore\n            if token.value == \"call\":\n                return self.parse_call_block()\n            if token.value == \"filter\":\n                return self.parse_filter_block()\n            ext = self.extensions.get(token.value)\n            if ext is not None:\n                return ext(self)\n\n            # did not work out, remove the token we pushed by accident\n            # from the stack so that the unknown tag fail function can\n            # produce a proper error message.\n            self._tag_stack.pop()\n            pop_tag = False\n            self.fail_unknown_tag(token.value, token.lineno)\n        finally:\n            if pop_tag:\n                self._tag_stack.pop()\n\n    def parse_statements(\n        self, end_tokens: t.Tuple[str, ...], drop_needle: bool = False\n    ) -> t.List[nodes.Node]:\n        \"\"\"Parse multiple statements into a list until one of the end tokens\n        is reached.  This is used to parse the body of statements as it also\n        parses template data if appropriate.  The parser checks first if the\n        current token is a colon and skips it if there is one.  Then it checks\n        for the block end and parses until if one of the `end_tokens` is\n        reached.  Per default the active token in the stream at the end of\n        the call is the matched end token.  If this is not wanted `drop_needle`\n        can be set to `True` and the end token is removed.\n        \"\"\"\n        # the first token may be a colon for python compatibility\n        self.stream.skip_if(\"colon\")\n\n        # in the future it would be possible to add whole code sections\n        # by adding some sort of end of statement token and parsing those here.\n        self.stream.expect(\"block_end\")\n        result = self.subparse(end_tokens)\n\n        # we reached the end of the template too early, the subparser\n        # does not check for this, so we do that now\n        if self.stream.current.type == \"eof\":\n            self.fail_eof(end_tokens)\n\n        if drop_needle:\n            next(self.stream)\n        return result\n\n    def parse_set(self) -> t.Union[nodes.Assign, nodes.AssignBlock]:\n        \"\"\"Parse an assign statement.\"\"\"\n        lineno = next(self.stream).lineno\n        target = self.parse_assign_target(with_namespace=True)\n        if self.stream.skip_if(\"assign\"):\n            expr = self.parse_tuple()\n            return nodes.Assign(target, expr, lineno=lineno)\n        filter_node = self.parse_filter(None)\n        body = self.parse_statements((\"name:endset\",), drop_needle=True)\n        return nodes.AssignBlock(target, filter_node, body, lineno=lineno)\n\n    def parse_for(self) -> nodes.For:\n        \"\"\"Parse a for loop.\"\"\"\n        lineno = self.stream.expect(\"name:for\").lineno\n        target = self.parse_assign_target(extra_end_rules=(\"name:in\",))\n        self.stream.expect(\"name:in\")\n        iter = self.parse_tuple(\n            with_condexpr=False, extra_end_rules=(\"name:recursive\",)\n        )\n        test = None\n        if self.stream.skip_if(\"name:if\"):\n            test = self.parse_expression()\n        recursive = self.stream.skip_if(\"name:recursive\")\n        body = self.parse_statements((\"name:endfor\", \"name:else\"))\n        if next(self.stream).value == \"endfor\":\n            else_ = []\n        else:\n            else_ = self.parse_statements((\"name:endfor\",), drop_needle=True)\n        return nodes.For(target, iter, body, else_, test, recursive, lineno=lineno)\n\n    def parse_if(self) -> nodes.If:\n        \"\"\"Parse an if construct.\"\"\"\n        node = result = nodes.If(lineno=self.stream.expect(\"name:if\").lineno)\n        while True:\n            node.test = self.parse_tuple(with_condexpr=False)\n            node.body = self.parse_statements((\"name:elif\", \"name:else\", \"name:endif\"))\n            node.elif_ = []\n            node.else_ = []\n            token = next(self.stream)\n            if token.test(\"name:elif\"):\n                node = nodes.If(lineno=self.stream.current.lineno)\n                result.elif_.append(node)\n                continue\n            elif token.test(\"name:else\"):\n                result.else_ = self.parse_statements((\"name:endif\",), drop_needle=True)\n            break\n        return result\n\n    def parse_with(self) -> nodes.With:\n        node = nodes.With(lineno=next(self.stream).lineno)\n        targets: t.List[nodes.Expr] = []\n        values: t.List[nodes.Expr] = []\n        while self.stream.current.type != \"block_end\":\n            if targets:\n                self.stream.expect(\"comma\")\n            target = self.parse_assign_target()\n            target.set_ctx(\"param\")\n            targets.append(target)\n            self.stream.expect(\"assign\")\n            values.append(self.parse_expression())\n        node.targets = targets\n        node.values = values\n        node.body = self.parse_statements((\"name:endwith\",), drop_needle=True)\n        return node\n\n    def parse_autoescape(self) -> nodes.Scope:\n        node = nodes.ScopedEvalContextModifier(lineno=next(self.stream).lineno)\n        node.options = [nodes.Keyword(\"autoescape\", self.parse_expression())]\n        node.body = self.parse_statements((\"name:endautoescape\",), drop_needle=True)\n        return nodes.Scope([node])\n\n    def parse_block(self) -> nodes.Block:\n        node = nodes.Block(lineno=next(self.stream).lineno)\n        node.name = self.stream.expect(\"name\").value\n        node.scoped = self.stream.skip_if(\"name:scoped\")\n        node.required = self.stream.skip_if(\"name:required\")\n\n        # common problem people encounter when switching from django\n        # to jinja.  we do not support hyphens in block names, so let's\n        # raise a nicer error message in that case.\n        if self.stream.current.type == \"sub\":\n            self.fail(\n                \"Block names in Jinja have to be valid Python identifiers and may not\"\n                \" contain hyphens, use an underscore instead.\"\n            )\n\n        node.body = self.parse_statements((\"name:endblock\",), drop_needle=True)\n\n        # enforce that required blocks only contain whitespace or comments\n        # by asserting that the body, if not empty, is just TemplateData nodes\n        # with whitespace data\n        if node.required:\n            for body_node in node.body:\n                if not isinstance(body_node, nodes.Output) or any(\n                    not isinstance(output_node, nodes.TemplateData)\n                    or not output_node.data.isspace()\n                    for output_node in body_node.nodes\n                ):\n                    self.fail(\"Required blocks can only contain comments or whitespace\")\n\n        self.stream.skip_if(\"name:\" + node.name)\n        return node\n\n    def parse_extends(self) -> nodes.Extends:\n        node = nodes.Extends(lineno=next(self.stream).lineno)\n        node.template = self.parse_expression()\n        return node\n\n    def parse_import_context(\n        self, node: _ImportInclude, default: bool\n    ) -> _ImportInclude:\n        if self.stream.current.test_any(\n            \"name:with\", \"name:without\"\n        ) and self.stream.look().test(\"name:context\"):\n            node.with_context = next(self.stream).value == \"with\"\n            self.stream.skip()\n        else:\n            node.with_context = default\n        return node\n\n    def parse_include(self) -> nodes.Include:\n        node = nodes.Include(lineno=next(self.stream).lineno)\n        node.template = self.parse_expression()\n        if self.stream.current.test(\"name:ignore\") and self.stream.look().test(\n            \"name:missing\"\n        ):\n            node.ignore_missing = True\n            self.stream.skip(2)\n        else:\n            node.ignore_missing = False\n        return self.parse_import_context(node, True)\n\n    def parse_import(self) -> nodes.Import:\n        node = nodes.Import(lineno=next(self.stream).lineno)\n        node.template = self.parse_expression()\n        self.stream.expect(\"name:as\")\n        node.target = self.parse_assign_target(name_only=True).name\n        return self.parse_import_context(node, False)\n\n    def parse_from(self) -> nodes.FromImport:\n        node = nodes.FromImport(lineno=next(self.stream).lineno)\n        node.template = self.parse_expression()\n        self.stream.expect(\"name:import\")\n        node.names = []\n\n        def parse_context() -> bool:\n            if self.stream.current.value in {\n                \"with\",\n                \"without\",\n            } and self.stream.look().test(\"name:context\"):\n                node.with_context = next(self.stream).value == \"with\"\n                self.stream.skip()\n                return True\n            return False\n\n        while True:\n            if node.names:\n                self.stream.expect(\"comma\")\n            if self.stream.current.type == \"name\":\n                if parse_context():\n                    break\n                target = self.parse_assign_target(name_only=True)\n                if target.name.startswith(\"_\"):\n                    self.fail(\n                        \"names starting with an underline can not be imported\",\n                        target.lineno,\n                        exc=TemplateAssertionError,\n                    )\n                if self.stream.skip_if(\"name:as\"):\n                    alias = self.parse_assign_target(name_only=True)\n                    node.names.append((target.name, alias.name))\n                else:\n                    node.names.append(target.name)\n                if parse_context() or self.stream.current.type != \"comma\":\n                    break\n            else:\n                self.stream.expect(\"name\")\n        if not hasattr(node, \"with_context\"):\n            node.with_context = False\n        return node\n\n    def parse_signature(self, node: _MacroCall) -> None:\n        args = node.args = []\n        defaults = node.defaults = []\n        self.stream.expect(\"lparen\")\n        while self.stream.current.type != \"rparen\":\n            if args:\n                self.stream.expect(\"comma\")\n            arg = self.parse_assign_target(name_only=True)\n            arg.set_ctx(\"param\")\n            if self.stream.skip_if(\"assign\"):\n                defaults.append(self.parse_expression())\n            elif defaults:\n                self.fail(\"non-default argument follows default argument\")\n            args.append(arg)\n        self.stream.expect(\"rparen\")\n\n    def parse_call_block(self) -> nodes.CallBlock:\n        node = nodes.CallBlock(lineno=next(self.stream).lineno)\n        if self.stream.current.type == \"lparen\":\n            self.parse_signature(node)\n        else:\n            node.args = []\n            node.defaults = []\n\n        call_node = self.parse_expression()\n        if not isinstance(call_node, nodes.Call):\n            self.fail(\"expected call\", node.lineno)\n        node.call = call_node\n        node.body = self.parse_statements((\"name:endcall\",), drop_needle=True)\n        return node\n\n    def parse_filter_block(self) -> nodes.FilterBlock:\n        node = nodes.FilterBlock(lineno=next(self.stream).lineno)\n        node.filter = self.parse_filter(None, start_inline=True)  # type: ignore\n        node.body = self.parse_statements((\"name:endfilter\",), drop_needle=True)\n        return node\n\n    def parse_macro(self) -> nodes.Macro:\n        node = nodes.Macro(lineno=next(self.stream).lineno)\n        node.name = self.parse_assign_target(name_only=True).name\n        self.parse_signature(node)\n        node.body = self.parse_statements((\"name:endmacro\",), drop_needle=True)\n        return node\n\n    def parse_print(self) -> nodes.Output:\n        node = nodes.Output(lineno=next(self.stream).lineno)\n        node.nodes = []\n        while self.stream.current.type != \"block_end\":\n            if node.nodes:\n                self.stream.expect(\"comma\")\n            node.nodes.append(self.parse_expression())\n        return node\n\n    @typing.overload\n    def parse_assign_target(\n        self, with_tuple: bool = ..., name_only: \"te.Literal[True]\" = ...\n    ) -> nodes.Name: ...\n\n    @typing.overload\n    def parse_assign_target(\n        self,\n        with_tuple: bool = True,\n        name_only: bool = False,\n        extra_end_rules: t.Optional[t.Tuple[str, ...]] = None,\n        with_namespace: bool = False,\n    ) -> t.Union[nodes.NSRef, nodes.Name, nodes.Tuple]: ...\n\n    def parse_assign_target(\n        self,\n        with_tuple: bool = True,\n        name_only: bool = False,\n        extra_end_rules: t.Optional[t.Tuple[str, ...]] = None,\n        with_namespace: bool = False,\n    ) -> t.Union[nodes.NSRef, nodes.Name, nodes.Tuple]:\n        \"\"\"Parse an assignment target.  As Jinja allows assignments to\n        tuples, this function can parse all allowed assignment targets.  Per\n        default assignments to tuples are parsed, that can be disable however\n        by setting `with_tuple` to `False`.  If only assignments to names are\n        wanted `name_only` can be set to `True`.  The `extra_end_rules`\n        parameter is forwarded to the tuple parsing function.  If\n        `with_namespace` is enabled, a namespace assignment may be parsed.\n        \"\"\"\n        target: nodes.Expr\n\n        if with_namespace and self.stream.look().type == \"dot\":\n            token = self.stream.expect(\"name\")\n            next(self.stream)  # dot\n            attr = self.stream.expect(\"name\")\n            target = nodes.NSRef(token.value, attr.value, lineno=token.lineno)\n        elif name_only:\n            token = self.stream.expect(\"name\")\n            target = nodes.Name(token.value, \"store\", lineno=token.lineno)\n        else:\n            if with_tuple:\n                target = self.parse_tuple(\n                    simplified=True, extra_end_rules=extra_end_rules\n                )\n            else:\n                target = self.parse_primary()\n\n            target.set_ctx(\"store\")\n\n        if not target.can_assign():\n            self.fail(\n                f\"can't assign to {type(target).__name__.lower()!r}\", target.lineno\n            )\n\n        return target  # type: ignore\n\n    def parse_expression(self, with_condexpr: bool = True) -> nodes.Expr:\n        \"\"\"Parse an expression.  Per default all expressions are parsed, if\n        the optional `with_condexpr` parameter is set to `False` conditional\n        expressions are not parsed.\n        \"\"\"\n        if with_condexpr:\n            return self.parse_condexpr()\n        return self.parse_or()\n\n    def parse_condexpr(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        expr1 = self.parse_or()\n        expr3: t.Optional[nodes.Expr]\n\n        while self.stream.skip_if(\"name:if\"):\n            expr2 = self.parse_or()\n            if self.stream.skip_if(\"name:else\"):\n                expr3 = self.parse_condexpr()\n            else:\n                expr3 = None\n            expr1 = nodes.CondExpr(expr2, expr1, expr3, lineno=lineno)\n            lineno = self.stream.current.lineno\n        return expr1\n\n    def parse_or(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        left = self.parse_and()\n        while self.stream.skip_if(\"name:or\"):\n            right = self.parse_and()\n            left = nodes.Or(left, right, lineno=lineno)\n            lineno = self.stream.current.lineno\n        return left\n\n    def parse_and(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        left = self.parse_not()\n        while self.stream.skip_if(\"name:and\"):\n            right = self.parse_not()\n            left = nodes.And(left, right, lineno=lineno)\n            lineno = self.stream.current.lineno\n        return left\n\n    def parse_not(self) -> nodes.Expr:\n        if self.stream.current.test(\"name:not\"):\n            lineno = next(self.stream).lineno\n            return nodes.Not(self.parse_not(), lineno=lineno)\n        return self.parse_compare()\n\n    def parse_compare(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        expr = self.parse_math1()\n        ops = []\n        while True:\n            token_type = self.stream.current.type\n            if token_type in _compare_operators:\n                next(self.stream)\n                ops.append(nodes.Operand(token_type, self.parse_math1()))\n            elif self.stream.skip_if(\"name:in\"):\n                ops.append(nodes.Operand(\"in\", self.parse_math1()))\n            elif self.stream.current.test(\"name:not\") and self.stream.look().test(\n                \"name:in\"\n            ):\n                self.stream.skip(2)\n                ops.append(nodes.Operand(\"notin\", self.parse_math1()))\n            else:\n                break\n            lineno = self.stream.current.lineno\n        if not ops:\n            return expr\n        return nodes.Compare(expr, ops, lineno=lineno)\n\n    def parse_math1(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        left = self.parse_concat()\n        while self.stream.current.type in (\"add\", \"sub\"):\n            cls = _math_nodes[self.stream.current.type]\n            next(self.stream)\n            right = self.parse_concat()\n            left = cls(left, right, lineno=lineno)\n            lineno = self.stream.current.lineno\n        return left\n\n    def parse_concat(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        args = [self.parse_math2()]\n        while self.stream.current.type == \"tilde\":\n            next(self.stream)\n            args.append(self.parse_math2())\n        if len(args) == 1:\n            return args[0]\n        return nodes.Concat(args, lineno=lineno)\n\n    def parse_math2(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        left = self.parse_pow()\n        while self.stream.current.type in (\"mul\", \"div\", \"floordiv\", \"mod\"):\n            cls = _math_nodes[self.stream.current.type]\n            next(self.stream)\n            right = self.parse_pow()\n            left = cls(left, right, lineno=lineno)\n            lineno = self.stream.current.lineno\n        return left\n\n    def parse_pow(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        left = self.parse_unary()\n        while self.stream.current.type == \"pow\":\n            next(self.stream)\n            right = self.parse_unary()\n            left = nodes.Pow(left, right, lineno=lineno)\n            lineno = self.stream.current.lineno\n        return left\n\n    def parse_unary(self, with_filter: bool = True) -> nodes.Expr:\n        token_type = self.stream.current.type\n        lineno = self.stream.current.lineno\n        node: nodes.Expr\n\n        if token_type == \"sub\":\n            next(self.stream)\n            node = nodes.Neg(self.parse_unary(False), lineno=lineno)\n        elif token_type == \"add\":\n            next(self.stream)\n            node = nodes.Pos(self.parse_unary(False), lineno=lineno)\n        else:\n            node = self.parse_primary()\n        node = self.parse_postfix(node)\n        if with_filter:\n            node = self.parse_filter_expr(node)\n        return node\n\n    def parse_primary(self) -> nodes.Expr:\n        token = self.stream.current\n        node: nodes.Expr\n        if token.type == \"name\":\n            if token.value in (\"true\", \"false\", \"True\", \"False\"):\n                node = nodes.Const(token.value in (\"true\", \"True\"), lineno=token.lineno)\n            elif token.value in (\"none\", \"None\"):\n                node = nodes.Const(None, lineno=token.lineno)\n            else:\n                node = nodes.Name(token.value, \"load\", lineno=token.lineno)\n            next(self.stream)\n        elif token.type == \"string\":\n            next(self.stream)\n            buf = [token.value]\n            lineno = token.lineno\n            while self.stream.current.type == \"string\":\n                buf.append(self.stream.current.value)\n                next(self.stream)\n            node = nodes.Const(\"\".join(buf), lineno=lineno)\n        elif token.type in (\"integer\", \"float\"):\n            next(self.stream)\n            node = nodes.Const(token.value, lineno=token.lineno)\n        elif token.type == \"lparen\":\n            next(self.stream)\n            node = self.parse_tuple(explicit_parentheses=True)\n            self.stream.expect(\"rparen\")\n        elif token.type == \"lbracket\":\n            node = self.parse_list()\n        elif token.type == \"lbrace\":\n            node = self.parse_dict()\n        else:\n            self.fail(f\"unexpected {describe_token(token)!r}\", token.lineno)\n        return node\n\n    def parse_tuple(\n        self,\n        simplified: bool = False,\n        with_condexpr: bool = True,\n        extra_end_rules: t.Optional[t.Tuple[str, ...]] = None,\n        explicit_parentheses: bool = False,\n    ) -> t.Union[nodes.Tuple, nodes.Expr]:\n        \"\"\"Works like `parse_expression` but if multiple expressions are\n        delimited by a comma a :class:`~jinja2.nodes.Tuple` node is created.\n        This method could also return a regular expression instead of a tuple\n        if no commas where found.\n\n        The default parsing mode is a full tuple.  If `simplified` is `True`\n        only names and literals are parsed.  The `no_condexpr` parameter is\n        forwarded to :meth:`parse_expression`.\n\n        Because tuples do not require delimiters and may end in a bogus comma\n        an extra hint is needed that marks the end of a tuple.  For example\n        for loops support tuples between `for` and `in`.  In that case the\n        `extra_end_rules` is set to ``['name:in']``.\n\n        `explicit_parentheses` is true if the parsing was triggered by an\n        expression in parentheses.  This is used to figure out if an empty\n        tuple is a valid expression or not.\n        \"\"\"\n        lineno = self.stream.current.lineno\n        if simplified:\n            parse = self.parse_primary\n        elif with_condexpr:\n            parse = self.parse_expression\n        else:\n\n            def parse() -> nodes.Expr:\n                return self.parse_expression(with_condexpr=False)\n\n        args: t.List[nodes.Expr] = []\n        is_tuple = False\n\n        while True:\n            if args:\n                self.stream.expect(\"comma\")\n            if self.is_tuple_end(extra_end_rules):\n                break\n            args.append(parse())\n            if self.stream.current.type == \"comma\":\n                is_tuple = True\n            else:\n                break\n            lineno = self.stream.current.lineno\n\n        if not is_tuple:\n            if args:\n                return args[0]\n\n            # if we don't have explicit parentheses, an empty tuple is\n            # not a valid expression.  This would mean nothing (literally\n            # nothing) in the spot of an expression would be an empty\n            # tuple.\n            if not explicit_parentheses:\n                self.fail(\n                    \"Expected an expression,\"\n                    f\" got {describe_token(self.stream.current)!r}\"\n                )\n\n        return nodes.Tuple(args, \"load\", lineno=lineno)\n\n    def parse_list(self) -> nodes.List:\n        token = self.stream.expect(\"lbracket\")\n        items: t.List[nodes.Expr] = []\n        while self.stream.current.type != \"rbracket\":\n            if items:\n                self.stream.expect(\"comma\")\n            if self.stream.current.type == \"rbracket\":\n                break\n            items.append(self.parse_expression())\n        self.stream.expect(\"rbracket\")\n        return nodes.List(items, lineno=token.lineno)\n\n    def parse_dict(self) -> nodes.Dict:\n        token = self.stream.expect(\"lbrace\")\n        items: t.List[nodes.Pair] = []\n        while self.stream.current.type != \"rbrace\":\n            if items:\n                self.stream.expect(\"comma\")\n            if self.stream.current.type == \"rbrace\":\n                break\n            key = self.parse_expression()\n            self.stream.expect(\"colon\")\n            value = self.parse_expression()\n            items.append(nodes.Pair(key, value, lineno=key.lineno))\n        self.stream.expect(\"rbrace\")\n        return nodes.Dict(items, lineno=token.lineno)\n\n    def parse_postfix(self, node: nodes.Expr) -> nodes.Expr:\n        while True:\n            token_type = self.stream.current.type\n            if token_type == \"dot\" or token_type == \"lbracket\":\n                node = self.parse_subscript(node)\n            # calls are valid both after postfix expressions (getattr\n            # and getitem) as well as filters and tests\n            elif token_type == \"lparen\":\n                node = self.parse_call(node)\n            else:\n                break\n        return node\n\n    def parse_filter_expr(self, node: nodes.Expr) -> nodes.Expr:\n        while True:\n            token_type = self.stream.current.type\n            if token_type == \"pipe\":\n                node = self.parse_filter(node)  # type: ignore\n            elif token_type == \"name\" and self.stream.current.value == \"is\":\n                node = self.parse_test(node)\n            # calls are valid both after postfix expressions (getattr\n            # and getitem) as well as filters and tests\n            elif token_type == \"lparen\":\n                node = self.parse_call(node)\n            else:\n                break\n        return node\n\n    def parse_subscript(\n        self, node: nodes.Expr\n    ) -> t.Union[nodes.Getattr, nodes.Getitem]:\n        token = next(self.stream)\n        arg: nodes.Expr\n\n        if token.type == \"dot\":\n            attr_token = self.stream.current\n            next(self.stream)\n            if attr_token.type == \"name\":\n                return nodes.Getattr(\n                    node, attr_token.value, \"load\", lineno=token.lineno\n                )\n            elif attr_token.type != \"integer\":\n                self.fail(\"expected name or number\", attr_token.lineno)\n            arg = nodes.Const(attr_token.value, lineno=attr_token.lineno)\n            return nodes.Getitem(node, arg, \"load\", lineno=token.lineno)\n        if token.type == \"lbracket\":\n            args: t.List[nodes.Expr] = []\n            while self.stream.current.type != \"rbracket\":\n                if args:\n                    self.stream.expect(\"comma\")\n                args.append(self.parse_subscribed())\n            self.stream.expect(\"rbracket\")\n            if len(args) == 1:\n                arg = args[0]\n            else:\n                arg = nodes.Tuple(args, \"load\", lineno=token.lineno)\n            return nodes.Getitem(node, arg, \"load\", lineno=token.lineno)\n        self.fail(\"expected subscript expression\", token.lineno)\n\n    def parse_subscribed(self) -> nodes.Expr:\n        lineno = self.stream.current.lineno\n        args: t.List[t.Optional[nodes.Expr]]\n\n        if self.stream.current.type == \"colon\":\n            next(self.stream)\n            args = [None]\n        else:\n            node = self.parse_expression()\n            if self.stream.current.type != \"colon\":\n                return node\n            next(self.stream)\n            args = [node]\n\n        if self.stream.current.type == \"colon\":\n            args.append(None)\n        elif self.stream.current.type not in (\"rbracket\", \"comma\"):\n            args.append(self.parse_expression())\n        else:\n            args.append(None)\n\n        if self.stream.current.type == \"colon\":\n            next(self.stream)\n            if self.stream.current.type not in (\"rbracket\", \"comma\"):\n                args.append(self.parse_expression())\n            else:\n                args.append(None)\n        else:\n            args.append(None)\n\n        return nodes.Slice(lineno=lineno, *args)  # noqa: B026\n\n    def parse_call_args(\n        self,\n    ) -> t.Tuple[\n        t.List[nodes.Expr],\n        t.List[nodes.Keyword],\n        t.Union[nodes.Expr, None],\n        t.Union[nodes.Expr, None],\n    ]:\n        token = self.stream.expect(\"lparen\")\n        args = []\n        kwargs = []\n        dyn_args = None\n        dyn_kwargs = None\n        require_comma = False\n\n        def ensure(expr: bool) -> None:\n            if not expr:\n                self.fail(\"invalid syntax for function call expression\", token.lineno)\n\n        while self.stream.current.type != \"rparen\":\n            if require_comma:\n                self.stream.expect(\"comma\")\n\n                # support for trailing comma\n                if self.stream.current.type == \"rparen\":\n                    break\n\n            if self.stream.current.type == \"mul\":\n                ensure(dyn_args is None and dyn_kwargs is None)\n                next(self.stream)\n                dyn_args = self.parse_expression()\n            elif self.stream.current.type == \"pow\":\n                ensure(dyn_kwargs is None)\n                next(self.stream)\n                dyn_kwargs = self.parse_expression()\n            else:\n                if (\n                    self.stream.current.type == \"name\"\n                    and self.stream.look().type == \"assign\"\n                ):\n                    # Parsing a kwarg\n                    ensure(dyn_kwargs is None)\n                    key = self.stream.current.value\n                    self.stream.skip(2)\n                    value = self.parse_expression()\n                    kwargs.append(nodes.Keyword(key, value, lineno=value.lineno))\n                else:\n                    # Parsing an arg\n                    ensure(dyn_args is None and dyn_kwargs is None and not kwargs)\n                    args.append(self.parse_expression())\n\n            require_comma = True\n\n        self.stream.expect(\"rparen\")\n        return args, kwargs, dyn_args, dyn_kwargs\n\n    def parse_call(self, node: nodes.Expr) -> nodes.Call:\n        # The lparen will be expected in parse_call_args, but the lineno\n        # needs to be recorded before the stream is advanced.\n        token = self.stream.current\n        args, kwargs, dyn_args, dyn_kwargs = self.parse_call_args()\n        return nodes.Call(node, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno)\n\n    def parse_filter(\n        self, node: t.Optional[nodes.Expr], start_inline: bool = False\n    ) -> t.Optional[nodes.Expr]:\n        while self.stream.current.type == \"pipe\" or start_inline:\n            if not start_inline:\n                next(self.stream)\n            token = self.stream.expect(\"name\")\n            name = token.value\n            while self.stream.current.type == \"dot\":\n                next(self.stream)\n                name += \".\" + self.stream.expect(\"name\").value\n            if self.stream.current.type == \"lparen\":\n                args, kwargs, dyn_args, dyn_kwargs = self.parse_call_args()\n            else:\n                args = []\n                kwargs = []\n                dyn_args = dyn_kwargs = None\n            node = nodes.Filter(\n                node, name, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno\n            )\n            start_inline = False\n        return node\n\n    def parse_test(self, node: nodes.Expr) -> nodes.Expr:\n        token = next(self.stream)\n        if self.stream.current.test(\"name:not\"):\n            next(self.stream)\n            negated = True\n        else:\n            negated = False\n        name = self.stream.expect(\"name\").value\n        while self.stream.current.type == \"dot\":\n            next(self.stream)\n            name += \".\" + self.stream.expect(\"name\").value\n        dyn_args = dyn_kwargs = None\n        kwargs: t.List[nodes.Keyword] = []\n        if self.stream.current.type == \"lparen\":\n            args, kwargs, dyn_args, dyn_kwargs = self.parse_call_args()\n        elif self.stream.current.type in {\n            \"name\",\n            \"string\",\n            \"integer\",\n            \"float\",\n            \"lparen\",\n            \"lbracket\",\n            \"lbrace\",\n        } and not self.stream.current.test_any(\"name:else\", \"name:or\", \"name:and\"):\n            if self.stream.current.test(\"name:is\"):\n                self.fail(\"You cannot chain multiple tests with is\")\n            arg_node = self.parse_primary()\n            arg_node = self.parse_postfix(arg_node)\n            args = [arg_node]\n        else:\n            args = []\n        node = nodes.Test(\n            node, name, args, kwargs, dyn_args, dyn_kwargs, lineno=token.lineno\n        )\n        if negated:\n            node = nodes.Not(node, lineno=token.lineno)\n        return node\n\n    def subparse(\n        self, end_tokens: t.Optional[t.Tuple[str, ...]] = None\n    ) -> t.List[nodes.Node]:\n        body: t.List[nodes.Node] = []\n        data_buffer: t.List[nodes.Node] = []\n        add_data = data_buffer.append\n\n        if end_tokens is not None:\n            self._end_token_stack.append(end_tokens)\n\n        def flush_data() -> None:\n            if data_buffer:\n                lineno = data_buffer[0].lineno\n                body.append(nodes.Output(data_buffer[:], lineno=lineno))\n                del data_buffer[:]\n\n        try:\n            while self.stream:\n                token = self.stream.current\n                if token.type == \"data\":\n                    if token.value:\n                        add_data(nodes.TemplateData(token.value, lineno=token.lineno))\n                    next(self.stream)\n                elif token.type == \"variable_begin\":\n                    next(self.stream)\n                    add_data(self.parse_tuple(with_condexpr=True))\n                    self.stream.expect(\"variable_end\")\n                elif token.type == \"block_begin\":\n                    flush_data()\n                    next(self.stream)\n                    if end_tokens is not None and self.stream.current.test_any(\n                        *end_tokens\n                    ):\n                        return body\n                    rv = self.parse_statement()\n                    if isinstance(rv, list):\n                        body.extend(rv)\n                    else:\n                        body.append(rv)\n                    self.stream.expect(\"block_end\")\n                else:\n                    raise AssertionError(\"internal parsing error\")\n\n            flush_data()\n        finally:\n            if end_tokens is not None:\n                self._end_token_stack.pop()\n        return body\n\n    def parse(self) -> nodes.Template:\n        \"\"\"Parse the whole template into a `Template` node.\"\"\"\n        result = nodes.Template(self.subparse(), lineno=1)\n        result.set_environment(self.environment)\n        return result\n", "src/jinja2/visitor.py": "\"\"\"API for traversing the AST nodes. Implemented by the compiler and\nmeta introspection.\n\"\"\"\n\nimport typing as t\n\nfrom .nodes import Node\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n    class VisitCallable(te.Protocol):\n        def __call__(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any: ...\n\n\nclass NodeVisitor:\n    \"\"\"Walks the abstract syntax tree and call visitor functions for every\n    node found.  The visitor functions may return values which will be\n    forwarded by the `visit` method.\n\n    Per default the visitor functions for the nodes are ``'visit_'`` +\n    class name of the node.  So a `TryFinally` node visit function would\n    be `visit_TryFinally`.  This behavior can be changed by overriding\n    the `get_visitor` function.  If no visitor function exists for a node\n    (return value `None`) the `generic_visit` visitor is used instead.\n    \"\"\"\n\n    def get_visitor(self, node: Node) -> \"t.Optional[VisitCallable]\":\n        \"\"\"Return the visitor function for this node or `None` if no visitor\n        exists for this node.  In that case the generic visit function is\n        used instead.\n        \"\"\"\n        return getattr(self, f\"visit_{type(node).__name__}\", None)\n\n    def visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Visit a node.\"\"\"\n        f = self.get_visitor(node)\n\n        if f is not None:\n            return f(node, *args, **kwargs)\n\n        return self.generic_visit(node, *args, **kwargs)\n\n    def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.Any:\n        \"\"\"Called if no explicit visitor function exists for a node.\"\"\"\n        for child_node in node.iter_child_nodes():\n            self.visit(child_node, *args, **kwargs)\n\n\nclass NodeTransformer(NodeVisitor):\n    \"\"\"Walks the abstract syntax tree and allows modifications of nodes.\n\n    The `NodeTransformer` will walk the AST and use the return value of the\n    visitor functions to replace or remove the old node.  If the return\n    value of the visitor function is `None` the node will be removed\n    from the previous location otherwise it's replaced with the return\n    value.  The return value may be the original node in which case no\n    replacement takes place.\n    \"\"\"\n\n    def generic_visit(self, node: Node, *args: t.Any, **kwargs: t.Any) -> Node:\n        for field, old_value in node.iter_fields():\n            if isinstance(old_value, list):\n                new_values = []\n                for value in old_value:\n                    if isinstance(value, Node):\n                        value = self.visit(value, *args, **kwargs)\n                        if value is None:\n                            continue\n                        elif not isinstance(value, Node):\n                            new_values.extend(value)\n                            continue\n                    new_values.append(value)\n                old_value[:] = new_values\n            elif isinstance(old_value, Node):\n                new_node = self.visit(old_value, *args, **kwargs)\n                if new_node is None:\n                    delattr(node, field)\n                else:\n                    setattr(node, field, new_node)\n        return node\n\n    def visit_list(self, node: Node, *args: t.Any, **kwargs: t.Any) -> t.List[Node]:\n        \"\"\"As transformers may return lists in some places this method\n        can be used to enforce a list as return value.\n        \"\"\"\n        rv = self.visit(node, *args, **kwargs)\n\n        if not isinstance(rv, list):\n            return [rv]\n\n        return rv\n", "src/jinja2/defaults.py": "import typing as t\n\nfrom .filters import FILTERS as DEFAULT_FILTERS  # noqa: F401\nfrom .tests import TESTS as DEFAULT_TESTS  # noqa: F401\nfrom .utils import Cycler\nfrom .utils import generate_lorem_ipsum\nfrom .utils import Joiner\nfrom .utils import Namespace\n\nif t.TYPE_CHECKING:\n    import typing_extensions as te\n\n# defaults for the parser / lexer\nBLOCK_START_STRING = \"{%\"\nBLOCK_END_STRING = \"%}\"\nVARIABLE_START_STRING = \"{{\"\nVARIABLE_END_STRING = \"}}\"\nCOMMENT_START_STRING = \"{#\"\nCOMMENT_END_STRING = \"#}\"\nLINE_STATEMENT_PREFIX: t.Optional[str] = None\nLINE_COMMENT_PREFIX: t.Optional[str] = None\nTRIM_BLOCKS = False\nLSTRIP_BLOCKS = False\nNEWLINE_SEQUENCE: \"te.Literal['\\\\n', '\\\\r\\\\n', '\\\\r']\" = \"\\n\"\nKEEP_TRAILING_NEWLINE = False\n\n# default filters, tests and namespace\n\nDEFAULT_NAMESPACE = {\n    \"range\": range,\n    \"dict\": dict,\n    \"lipsum\": generate_lorem_ipsum,\n    \"cycler\": Cycler,\n    \"joiner\": Joiner,\n    \"namespace\": Namespace,\n}\n\n# default policies\nDEFAULT_POLICIES: t.Dict[str, t.Any] = {\n    \"compiler.ascii_str\": True,\n    \"urlize.rel\": \"noopener\",\n    \"urlize.target\": None,\n    \"urlize.extra_schemes\": None,\n    \"truncate.leeway\": 5,\n    \"json.dumps_function\": None,\n    \"json.dumps_kwargs\": {\"sort_keys\": True},\n    \"ext.i18n.trimmed\": False,\n}\n", "src/jinja2/loaders.py": "\"\"\"API and implementations for loading templates from different data\nsources.\n\"\"\"\n\nimport importlib.util\nimport os\nimport posixpath\nimport sys\nimport typing as t\nimport weakref\nimport zipimport\nfrom collections import abc\nfrom hashlib import sha1\nfrom importlib import import_module\nfrom types import ModuleType\n\nfrom .exceptions import TemplateNotFound\nfrom .utils import internalcode\n\nif t.TYPE_CHECKING:\n    from .environment import Environment\n    from .environment import Template\n\n\ndef split_template_path(template: str) -> t.List[str]:\n    \"\"\"Split a path into segments and perform a sanity check.  If it detects\n    '..' in the path it will raise a `TemplateNotFound` error.\n    \"\"\"\n    pieces = []\n    for piece in template.split(\"/\"):\n        if (\n            os.sep in piece\n            or (os.path.altsep and os.path.altsep in piece)\n            or piece == os.path.pardir\n        ):\n            raise TemplateNotFound(template)\n        elif piece and piece != \".\":\n            pieces.append(piece)\n    return pieces\n\n\nclass BaseLoader:\n    \"\"\"Baseclass for all loaders.  Subclass this and override `get_source` to\n    implement a custom loading mechanism.  The environment provides a\n    `get_template` method that calls the loader's `load` method to get the\n    :class:`Template` object.\n\n    A very basic example for a loader that looks up templates on the file\n    system could look like this::\n\n        from jinja2 import BaseLoader, TemplateNotFound\n        from os.path import join, exists, getmtime\n\n        class MyLoader(BaseLoader):\n\n            def __init__(self, path):\n                self.path = path\n\n            def get_source(self, environment, template):\n                path = join(self.path, template)\n                if not exists(path):\n                    raise TemplateNotFound(template)\n                mtime = getmtime(path)\n                with open(path) as f:\n                    source = f.read()\n                return source, path, lambda: mtime == getmtime(path)\n    \"\"\"\n\n    #: if set to `False` it indicates that the loader cannot provide access\n    #: to the source of templates.\n    #:\n    #: .. versionadded:: 2.4\n    has_source_access = True\n\n    def get_source(\n        self, environment: \"Environment\", template: str\n    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:\n        \"\"\"Get the template source, filename and reload helper for a template.\n        It's passed the environment and template name and has to return a\n        tuple in the form ``(source, filename, uptodate)`` or raise a\n        `TemplateNotFound` error if it can't locate the template.\n\n        The source part of the returned tuple must be the source of the\n        template as a string. The filename should be the name of the\n        file on the filesystem if it was loaded from there, otherwise\n        ``None``. The filename is used by Python for the tracebacks\n        if no loader extension is used.\n\n        The last item in the tuple is the `uptodate` function.  If auto\n        reloading is enabled it's always called to check if the template\n        changed.  No arguments are passed so the function must store the\n        old state somewhere (for example in a closure).  If it returns `False`\n        the template will be reloaded.\n        \"\"\"\n        if not self.has_source_access:\n            raise RuntimeError(\n                f\"{type(self).__name__} cannot provide access to the source\"\n            )\n        raise TemplateNotFound(template)\n\n    def list_templates(self) -> t.List[str]:\n        \"\"\"Iterates over all templates.  If the loader does not support that\n        it should raise a :exc:`TypeError` which is the default behavior.\n        \"\"\"\n        raise TypeError(\"this loader cannot iterate over all templates\")\n\n    @internalcode\n    def load(\n        self,\n        environment: \"Environment\",\n        name: str,\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ) -> \"Template\":\n        \"\"\"Loads a template.  This method looks up the template in the cache\n        or loads one by calling :meth:`get_source`.  Subclasses should not\n        override this method as loaders working on collections of other\n        loaders (such as :class:`PrefixLoader` or :class:`ChoiceLoader`)\n        will not call this method but `get_source` directly.\n        \"\"\"\n        code = None\n        if globals is None:\n            globals = {}\n\n        # first we try to get the source for this template together\n        # with the filename and the uptodate function.\n        source, filename, uptodate = self.get_source(environment, name)\n\n        # try to load the code from the bytecode cache if there is a\n        # bytecode cache configured.\n        bcc = environment.bytecode_cache\n        if bcc is not None:\n            bucket = bcc.get_bucket(environment, name, filename, source)\n            code = bucket.code\n\n        # if we don't have code so far (not cached, no longer up to\n        # date) etc. we compile the template\n        if code is None:\n            code = environment.compile(source, name, filename)\n\n        # if the bytecode cache is available and the bucket doesn't\n        # have a code so far, we give the bucket the new code and put\n        # it back to the bytecode cache.\n        if bcc is not None and bucket.code is None:\n            bucket.code = code\n            bcc.set_bucket(bucket)\n\n        return environment.template_class.from_code(\n            environment, code, globals, uptodate\n        )\n\n\nclass FileSystemLoader(BaseLoader):\n    \"\"\"Load templates from a directory in the file system.\n\n    The path can be relative or absolute. Relative paths are relative to\n    the current working directory.\n\n    .. code-block:: python\n\n        loader = FileSystemLoader(\"templates\")\n\n    A list of paths can be given. The directories will be searched in\n    order, stopping at the first matching template.\n\n    .. code-block:: python\n\n        loader = FileSystemLoader([\"/override/templates\", \"/default/templates\"])\n\n    :param searchpath: A path, or list of paths, to the directory that\n        contains the templates.\n    :param encoding: Use this encoding to read the text from template\n        files.\n    :param followlinks: Follow symbolic links in the path.\n\n    .. versionchanged:: 2.8\n        Added the ``followlinks`` parameter.\n    \"\"\"\n\n    def __init__(\n        self,\n        searchpath: t.Union[\n            str, \"os.PathLike[str]\", t.Sequence[t.Union[str, \"os.PathLike[str]\"]]\n        ],\n        encoding: str = \"utf-8\",\n        followlinks: bool = False,\n    ) -> None:\n        if not isinstance(searchpath, abc.Iterable) or isinstance(searchpath, str):\n            searchpath = [searchpath]\n\n        self.searchpath = [os.fspath(p) for p in searchpath]\n        self.encoding = encoding\n        self.followlinks = followlinks\n\n    def get_source(\n        self, environment: \"Environment\", template: str\n    ) -> t.Tuple[str, str, t.Callable[[], bool]]:\n        pieces = split_template_path(template)\n\n        for searchpath in self.searchpath:\n            # Use posixpath even on Windows to avoid \"drive:\" or UNC\n            # segments breaking out of the search directory.\n            filename = posixpath.join(searchpath, *pieces)\n\n            if os.path.isfile(filename):\n                break\n        else:\n            raise TemplateNotFound(template)\n\n        with open(filename, encoding=self.encoding) as f:\n            contents = f.read()\n\n        mtime = os.path.getmtime(filename)\n\n        def uptodate() -> bool:\n            try:\n                return os.path.getmtime(filename) == mtime\n            except OSError:\n                return False\n\n        # Use normpath to convert Windows altsep to sep.\n        return contents, os.path.normpath(filename), uptodate\n\n    def list_templates(self) -> t.List[str]:\n        found = set()\n        for searchpath in self.searchpath:\n            walk_dir = os.walk(searchpath, followlinks=self.followlinks)\n            for dirpath, _, filenames in walk_dir:\n                for filename in filenames:\n                    template = (\n                        os.path.join(dirpath, filename)[len(searchpath) :]\n                        .strip(os.sep)\n                        .replace(os.sep, \"/\")\n                    )\n                    if template[:2] == \"./\":\n                        template = template[2:]\n                    if template not in found:\n                        found.add(template)\n        return sorted(found)\n\n\nclass PackageLoader(BaseLoader):\n    \"\"\"Load templates from a directory in a Python package.\n\n    :param package_name: Import name of the package that contains the\n        template directory.\n    :param package_path: Directory within the imported package that\n        contains the templates.\n    :param encoding: Encoding of template files.\n\n    The following example looks up templates in the ``pages`` directory\n    within the ``project.ui`` package.\n\n    .. code-block:: python\n\n        loader = PackageLoader(\"project.ui\", \"pages\")\n\n    Only packages installed as directories (standard pip behavior) or\n    zip/egg files (less common) are supported. The Python API for\n    introspecting data in packages is too limited to support other\n    installation methods the way this loader requires.\n\n    There is limited support for :pep:`420` namespace packages. The\n    template directory is assumed to only be in one namespace\n    contributor. Zip files contributing to a namespace are not\n    supported.\n\n    .. versionchanged:: 3.0\n        No longer uses ``setuptools`` as a dependency.\n\n    .. versionchanged:: 3.0\n        Limited PEP 420 namespace package support.\n    \"\"\"\n\n    def __init__(\n        self,\n        package_name: str,\n        package_path: \"str\" = \"templates\",\n        encoding: str = \"utf-8\",\n    ) -> None:\n        package_path = os.path.normpath(package_path).rstrip(os.sep)\n\n        # normpath preserves \".\", which isn't valid in zip paths.\n        if package_path == os.path.curdir:\n            package_path = \"\"\n        elif package_path[:2] == os.path.curdir + os.sep:\n            package_path = package_path[2:]\n\n        self.package_path = package_path\n        self.package_name = package_name\n        self.encoding = encoding\n\n        # Make sure the package exists. This also makes namespace\n        # packages work, otherwise get_loader returns None.\n        import_module(package_name)\n        spec = importlib.util.find_spec(package_name)\n        assert spec is not None, \"An import spec was not found for the package.\"\n        loader = spec.loader\n        assert loader is not None, \"A loader was not found for the package.\"\n        self._loader = loader\n        self._archive = None\n        template_root = None\n\n        if isinstance(loader, zipimport.zipimporter):\n            self._archive = loader.archive\n            pkgdir = next(iter(spec.submodule_search_locations))  # type: ignore\n            template_root = os.path.join(pkgdir, package_path).rstrip(os.sep)\n        else:\n            roots: t.List[str] = []\n\n            # One element for regular packages, multiple for namespace\n            # packages, or None for single module file.\n            if spec.submodule_search_locations:\n                roots.extend(spec.submodule_search_locations)\n            # A single module file, use the parent directory instead.\n            elif spec.origin is not None:\n                roots.append(os.path.dirname(spec.origin))\n\n            for root in roots:\n                root = os.path.join(root, package_path)\n\n                if os.path.isdir(root):\n                    template_root = root\n                    break\n\n        if template_root is None:\n            raise ValueError(\n                f\"The {package_name!r} package was not installed in a\"\n                \" way that PackageLoader understands.\"\n            )\n\n        self._template_root = template_root\n\n    def get_source(\n        self, environment: \"Environment\", template: str\n    ) -> t.Tuple[str, str, t.Optional[t.Callable[[], bool]]]:\n        # Use posixpath even on Windows to avoid \"drive:\" or UNC\n        # segments breaking out of the search directory. Use normpath to\n        # convert Windows altsep to sep.\n        p = os.path.normpath(\n            posixpath.join(self._template_root, *split_template_path(template))\n        )\n        up_to_date: t.Optional[t.Callable[[], bool]]\n\n        if self._archive is None:\n            # Package is a directory.\n            if not os.path.isfile(p):\n                raise TemplateNotFound(template)\n\n            with open(p, \"rb\") as f:\n                source = f.read()\n\n            mtime = os.path.getmtime(p)\n\n            def up_to_date() -> bool:\n                return os.path.isfile(p) and os.path.getmtime(p) == mtime\n\n        else:\n            # Package is a zip file.\n            try:\n                source = self._loader.get_data(p)  # type: ignore\n            except OSError as e:\n                raise TemplateNotFound(template) from e\n\n            # Could use the zip's mtime for all template mtimes, but\n            # would need to safely reload the module if it's out of\n            # date, so just report it as always current.\n            up_to_date = None\n\n        return source.decode(self.encoding), p, up_to_date\n\n    def list_templates(self) -> t.List[str]:\n        results: t.List[str] = []\n\n        if self._archive is None:\n            # Package is a directory.\n            offset = len(self._template_root)\n\n            for dirpath, _, filenames in os.walk(self._template_root):\n                dirpath = dirpath[offset:].lstrip(os.sep)\n                results.extend(\n                    os.path.join(dirpath, name).replace(os.sep, \"/\")\n                    for name in filenames\n                )\n        else:\n            if not hasattr(self._loader, \"_files\"):\n                raise TypeError(\n                    \"This zip import does not have the required\"\n                    \" metadata to list templates.\"\n                )\n\n            # Package is a zip file.\n            prefix = self._template_root[len(self._archive) :].lstrip(os.sep) + os.sep\n            offset = len(prefix)\n\n            for name in self._loader._files.keys():\n                # Find names under the templates directory that aren't directories.\n                if name.startswith(prefix) and name[-1] != os.sep:\n                    results.append(name[offset:].replace(os.sep, \"/\"))\n\n        results.sort()\n        return results\n\n\nclass DictLoader(BaseLoader):\n    \"\"\"Loads a template from a Python dict mapping template names to\n    template source.  This loader is useful for unittesting:\n\n    >>> loader = DictLoader({'index.html': 'source here'})\n\n    Because auto reloading is rarely useful this is disabled per default.\n    \"\"\"\n\n    def __init__(self, mapping: t.Mapping[str, str]) -> None:\n        self.mapping = mapping\n\n    def get_source(\n        self, environment: \"Environment\", template: str\n    ) -> t.Tuple[str, None, t.Callable[[], bool]]:\n        if template in self.mapping:\n            source = self.mapping[template]\n            return source, None, lambda: source == self.mapping.get(template)\n        raise TemplateNotFound(template)\n\n    def list_templates(self) -> t.List[str]:\n        return sorted(self.mapping)\n\n\nclass FunctionLoader(BaseLoader):\n    \"\"\"A loader that is passed a function which does the loading.  The\n    function receives the name of the template and has to return either\n    a string with the template source, a tuple in the form ``(source,\n    filename, uptodatefunc)`` or `None` if the template does not exist.\n\n    >>> def load_template(name):\n    ...     if name == 'index.html':\n    ...         return '...'\n    ...\n    >>> loader = FunctionLoader(load_template)\n\n    The `uptodatefunc` is a function that is called if autoreload is enabled\n    and has to return `True` if the template is still up to date.  For more\n    details have a look at :meth:`BaseLoader.get_source` which has the same\n    return value.\n    \"\"\"\n\n    def __init__(\n        self,\n        load_func: t.Callable[\n            [str],\n            t.Optional[\n                t.Union[\n                    str, t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]\n                ]\n            ],\n        ],\n    ) -> None:\n        self.load_func = load_func\n\n    def get_source(\n        self, environment: \"Environment\", template: str\n    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:\n        rv = self.load_func(template)\n\n        if rv is None:\n            raise TemplateNotFound(template)\n\n        if isinstance(rv, str):\n            return rv, None, None\n\n        return rv\n\n\nclass PrefixLoader(BaseLoader):\n    \"\"\"A loader that is passed a dict of loaders where each loader is bound\n    to a prefix.  The prefix is delimited from the template by a slash per\n    default, which can be changed by setting the `delimiter` argument to\n    something else::\n\n        loader = PrefixLoader({\n            'app1':     PackageLoader('mypackage.app1'),\n            'app2':     PackageLoader('mypackage.app2')\n        })\n\n    By loading ``'app1/index.html'`` the file from the app1 package is loaded,\n    by loading ``'app2/index.html'`` the file from the second.\n    \"\"\"\n\n    def __init__(\n        self, mapping: t.Mapping[str, BaseLoader], delimiter: str = \"/\"\n    ) -> None:\n        self.mapping = mapping\n        self.delimiter = delimiter\n\n    def get_loader(self, template: str) -> t.Tuple[BaseLoader, str]:\n        try:\n            prefix, name = template.split(self.delimiter, 1)\n            loader = self.mapping[prefix]\n        except (ValueError, KeyError) as e:\n            raise TemplateNotFound(template) from e\n        return loader, name\n\n    def get_source(\n        self, environment: \"Environment\", template: str\n    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:\n        loader, name = self.get_loader(template)\n        try:\n            return loader.get_source(environment, name)\n        except TemplateNotFound as e:\n            # re-raise the exception with the correct filename here.\n            # (the one that includes the prefix)\n            raise TemplateNotFound(template) from e\n\n    @internalcode\n    def load(\n        self,\n        environment: \"Environment\",\n        name: str,\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ) -> \"Template\":\n        loader, local_name = self.get_loader(name)\n        try:\n            return loader.load(environment, local_name, globals)\n        except TemplateNotFound as e:\n            # re-raise the exception with the correct filename here.\n            # (the one that includes the prefix)\n            raise TemplateNotFound(name) from e\n\n    def list_templates(self) -> t.List[str]:\n        result = []\n        for prefix, loader in self.mapping.items():\n            for template in loader.list_templates():\n                result.append(prefix + self.delimiter + template)\n        return result\n\n\nclass ChoiceLoader(BaseLoader):\n    \"\"\"This loader works like the `PrefixLoader` just that no prefix is\n    specified.  If a template could not be found by one loader the next one\n    is tried.\n\n    >>> loader = ChoiceLoader([\n    ...     FileSystemLoader('/path/to/user/templates'),\n    ...     FileSystemLoader('/path/to/system/templates')\n    ... ])\n\n    This is useful if you want to allow users to override builtin templates\n    from a different location.\n    \"\"\"\n\n    def __init__(self, loaders: t.Sequence[BaseLoader]) -> None:\n        self.loaders = loaders\n\n    def get_source(\n        self, environment: \"Environment\", template: str\n    ) -> t.Tuple[str, t.Optional[str], t.Optional[t.Callable[[], bool]]]:\n        for loader in self.loaders:\n            try:\n                return loader.get_source(environment, template)\n            except TemplateNotFound:\n                pass\n        raise TemplateNotFound(template)\n\n    @internalcode\n    def load(\n        self,\n        environment: \"Environment\",\n        name: str,\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ) -> \"Template\":\n        for loader in self.loaders:\n            try:\n                return loader.load(environment, name, globals)\n            except TemplateNotFound:\n                pass\n        raise TemplateNotFound(name)\n\n    def list_templates(self) -> t.List[str]:\n        found = set()\n        for loader in self.loaders:\n            found.update(loader.list_templates())\n        return sorted(found)\n\n\nclass _TemplateModule(ModuleType):\n    \"\"\"Like a normal module but with support for weak references\"\"\"\n\n\nclass ModuleLoader(BaseLoader):\n    \"\"\"This loader loads templates from precompiled templates.\n\n    Example usage:\n\n    >>> loader = ChoiceLoader([\n    ...     ModuleLoader('/path/to/compiled/templates'),\n    ...     FileSystemLoader('/path/to/templates')\n    ... ])\n\n    Templates can be precompiled with :meth:`Environment.compile_templates`.\n    \"\"\"\n\n    has_source_access = False\n\n    def __init__(\n        self,\n        path: t.Union[\n            str, \"os.PathLike[str]\", t.Sequence[t.Union[str, \"os.PathLike[str]\"]]\n        ],\n    ) -> None:\n        package_name = f\"_jinja2_module_templates_{id(self):x}\"\n\n        # create a fake module that looks for the templates in the\n        # path given.\n        mod = _TemplateModule(package_name)\n\n        if not isinstance(path, abc.Iterable) or isinstance(path, str):\n            path = [path]\n\n        mod.__path__ = [os.fspath(p) for p in path]\n\n        sys.modules[package_name] = weakref.proxy(\n            mod, lambda x: sys.modules.pop(package_name, None)\n        )\n\n        # the only strong reference, the sys.modules entry is weak\n        # so that the garbage collector can remove it once the\n        # loader that created it goes out of business.\n        self.module = mod\n        self.package_name = package_name\n\n    @staticmethod\n    def get_template_key(name: str) -> str:\n        return \"tmpl_\" + sha1(name.encode(\"utf-8\")).hexdigest()\n\n    @staticmethod\n    def get_module_filename(name: str) -> str:\n        return ModuleLoader.get_template_key(name) + \".py\"\n\n    @internalcode\n    def load(\n        self,\n        environment: \"Environment\",\n        name: str,\n        globals: t.Optional[t.MutableMapping[str, t.Any]] = None,\n    ) -> \"Template\":\n        key = self.get_template_key(name)\n        module = f\"{self.package_name}.{key}\"\n        mod = getattr(self.module, module, None)\n\n        if mod is None:\n            try:\n                mod = __import__(module, None, None, [\"root\"])\n            except ImportError as e:\n                raise TemplateNotFound(name) from e\n\n            # remove the entry from sys.modules, we only want the attribute\n            # on the module object we have stored on the loader.\n            sys.modules.pop(module, None)\n\n        if globals is None:\n            globals = {}\n\n        return environment.template_class.from_module_dict(\n            environment, mod.__dict__, globals\n        )\n", "examples/basic/translate.py": "from jinja2 import Environment\n\nenv = Environment(extensions=[\"jinja2.ext.i18n\"])\nenv.globals[\"gettext\"] = {\"Hello %(user)s!\": \"Hallo %(user)s!\"}.__getitem__\nenv.globals[\"ngettext\"] = lambda s, p, n: {\n    \"%(count)s user\": \"%(count)d Benutzer\",\n    \"%(count)s users\": \"%(count)d Benutzer\",\n}[s if n == 1 else p]\nprint(\n    env.from_string(\n        \"\"\"\\\n{% trans %}Hello {{ user }}!{% endtrans %}\n{% trans count=users|count -%}\n{{ count }} user{% pluralize %}{{ count }} users\n{% endtrans %}\n\"\"\"\n    ).render(user=\"someone\", users=[1, 2, 3])\n)\n", "examples/basic/inheritance.py": "from jinja2 import Environment\nfrom jinja2.loaders import DictLoader\n\nenv = Environment(\n    loader=DictLoader(\n        {\n            \"a\": \"[A[{% block body %}{% endblock %}]]\",\n            \"b\": \"{% extends 'a' %}{% block body %}[B]{% endblock %}\",\n            \"c\": \"{% extends 'b' %}{% block body %}###{{ super() }}###{% endblock %}\",\n        }\n    )\n)\nprint(env.get_template(\"c\").render())\n", "examples/basic/debugger.py": "from jinja2 import Environment\nfrom jinja2.loaders import FileSystemLoader\n\nenv = Environment(loader=FileSystemLoader(\"templates\"))\ntmpl = env.get_template(\"broken.html\")\nprint(tmpl.render(seq=[3, 2, 4, 5, 3, 2, 0, 2, 1]))\n", "examples/basic/cycle.py": "from jinja2 import Environment\n\nenv = Environment(\n    line_statement_prefix=\"#\", variable_start_string=\"${\", variable_end_string=\"}\"\n)\nprint(\n    env.from_string(\n        \"\"\"\\\n<ul>\n# for item in range(10)\n    <li class=\"${loop.cycle('odd', 'even')}\">${item}</li>\n# endfor\n</ul>\\\n\"\"\"\n    ).render()\n)\n"}