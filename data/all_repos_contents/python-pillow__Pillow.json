{"setup.py": "# > pyroma .\n# ------------------------------\n# Checking .\n# Found Pillow\n# ------------------------------\n# Final rating: 10/10\n# Your cheese is so fresh most people think it's a cream: Mascarpone\n# ------------------------------\nfrom __future__ import annotations\n\nimport os\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport warnings\n\nfrom setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\n\n\ndef get_version():\n    version_file = \"src/PIL/_version.py\"\n    with open(version_file, encoding=\"utf-8\") as f:\n        return f.read().split('\"')[1]\n\n\nconfiguration = {}\n\n\nPILLOW_VERSION = get_version()\nFREETYPE_ROOT = None\nHARFBUZZ_ROOT = None\nFRIBIDI_ROOT = None\nIMAGEQUANT_ROOT = None\nJPEG2K_ROOT = None\nJPEG_ROOT = None\nLCMS_ROOT = None\nRAQM_ROOT = None\nTIFF_ROOT = None\nWEBP_ROOT = None\nZLIB_ROOT = None\nFUZZING_BUILD = \"LIB_FUZZING_ENGINE\" in os.environ\n\nif sys.platform == \"win32\" and sys.version_info >= (3, 13):\n    import atexit\n\n    atexit.register(\n        lambda: warnings.warn(\n            f\"Pillow {PILLOW_VERSION} does not support Python \"\n            f\"{sys.version_info.major}.{sys.version_info.minor} and does not provide \"\n            \"prebuilt Windows binaries. We do not recommend building from source on \"\n            \"Windows.\",\n            RuntimeWarning,\n        )\n    )\n\n\n_IMAGING = (\"decode\", \"encode\", \"map\", \"display\", \"outline\", \"path\")\n\n_LIB_IMAGING = (\n    \"Access\",\n    \"AlphaComposite\",\n    \"Resample\",\n    \"Reduce\",\n    \"Bands\",\n    \"BcnDecode\",\n    \"BitDecode\",\n    \"Blend\",\n    \"Chops\",\n    \"ColorLUT\",\n    \"Convert\",\n    \"ConvertYCbCr\",\n    \"Copy\",\n    \"Crop\",\n    \"Dib\",\n    \"Draw\",\n    \"Effects\",\n    \"EpsEncode\",\n    \"File\",\n    \"Fill\",\n    \"Filter\",\n    \"FliDecode\",\n    \"Geometry\",\n    \"GetBBox\",\n    \"GifDecode\",\n    \"GifEncode\",\n    \"HexDecode\",\n    \"Histo\",\n    \"JpegDecode\",\n    \"JpegEncode\",\n    \"Matrix\",\n    \"ModeFilter\",\n    \"Negative\",\n    \"Offset\",\n    \"Pack\",\n    \"PackDecode\",\n    \"Palette\",\n    \"Paste\",\n    \"Quant\",\n    \"QuantOctree\",\n    \"QuantHash\",\n    \"QuantHeap\",\n    \"PcdDecode\",\n    \"PcxDecode\",\n    \"PcxEncode\",\n    \"Point\",\n    \"RankFilter\",\n    \"RawDecode\",\n    \"RawEncode\",\n    \"Storage\",\n    \"SgiRleDecode\",\n    \"SunRleDecode\",\n    \"TgaRleDecode\",\n    \"TgaRleEncode\",\n    \"Unpack\",\n    \"UnpackYCC\",\n    \"UnsharpMask\",\n    \"XbmDecode\",\n    \"XbmEncode\",\n    \"ZipDecode\",\n    \"ZipEncode\",\n    \"TiffDecode\",\n    \"Jpeg2KDecode\",\n    \"Jpeg2KEncode\",\n    \"BoxBlur\",\n    \"QuantPngQuant\",\n    \"codec_fd\",\n)\n\nDEBUG = False\n\n\nclass DependencyException(Exception):\n    pass\n\n\nclass RequiredDependencyException(Exception):\n    pass\n\n\nPLATFORM_MINGW = os.name == \"nt\" and \"GCC\" in sys.version\n\n\ndef _dbg(s, tp=None):\n    if DEBUG:\n        if tp:\n            print(s % tp)\n            return\n        print(s)\n\n\ndef _find_library_dirs_ldconfig():\n    # Based on ctypes.util from Python 2\n\n    ldconfig = \"ldconfig\" if shutil.which(\"ldconfig\") else \"/sbin/ldconfig\"\n    if sys.platform.startswith(\"linux\") or sys.platform.startswith(\"gnu\"):\n        if struct.calcsize(\"l\") == 4:\n            machine = os.uname()[4] + \"-32\"\n        else:\n            machine = os.uname()[4] + \"-64\"\n        mach_map = {\n            \"x86_64-64\": \"libc6,x86-64\",\n            \"ppc64-64\": \"libc6,64bit\",\n            \"sparc64-64\": \"libc6,64bit\",\n            \"s390x-64\": \"libc6,64bit\",\n            \"ia64-64\": \"libc6,IA-64\",\n        }\n        abi_type = mach_map.get(machine, \"libc6\")\n\n        # Assuming GLIBC's ldconfig (with option -p)\n        # Alpine Linux uses musl that can't print cache\n        args = [ldconfig, \"-p\"]\n        expr = rf\".*\\({abi_type}.*\\) => (.*)\"\n        env = dict(os.environ)\n        env[\"LC_ALL\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n\n    elif sys.platform.startswith(\"freebsd\"):\n        args = [ldconfig, \"-r\"]\n        expr = r\".* => (.*)\"\n        env = {}\n\n    try:\n        p = subprocess.Popen(\n            args, stderr=subprocess.DEVNULL, stdout=subprocess.PIPE, env=env\n        )\n    except OSError:  # E.g. command not found\n        return []\n    [data, _] = p.communicate()\n    if isinstance(data, bytes):\n        data = data.decode(\"latin1\")\n\n    dirs = []\n    for dll in re.findall(expr, data):\n        dir = os.path.dirname(dll)\n        if dir not in dirs:\n            dirs.append(dir)\n    return dirs\n\n\ndef _add_directory(path, subdir, where=None):\n    if subdir is None:\n        return\n    subdir = os.path.realpath(subdir)\n    if os.path.isdir(subdir) and subdir not in path:\n        if where is None:\n            _dbg(\"Appending path %s\", subdir)\n            path.append(subdir)\n        else:\n            _dbg(\"Inserting path %s\", subdir)\n            path.insert(where, subdir)\n    elif subdir in path and where is not None:\n        path.remove(subdir)\n        path.insert(where, subdir)\n\n\ndef _find_include_file(self, include):\n    for directory in self.compiler.include_dirs:\n        _dbg(\"Checking for include file %s in %s\", (include, directory))\n        if os.path.isfile(os.path.join(directory, include)):\n            _dbg(\"Found %s\", include)\n            return 1\n    return 0\n\n\ndef _find_library_file(self, library):\n    ret = self.compiler.find_library_file(self.compiler.library_dirs, library)\n    if ret:\n        _dbg(\"Found library %s at %s\", (library, ret))\n    else:\n        _dbg(\"Couldn't find library %s in %s\", (library, self.compiler.library_dirs))\n    return ret\n\n\ndef _find_include_dir(self, dirname, include):\n    for directory in self.compiler.include_dirs:\n        _dbg(\"Checking for include file %s in %s\", (include, directory))\n        if os.path.isfile(os.path.join(directory, include)):\n            _dbg(\"Found %s in %s\", (include, directory))\n            return True\n        subdir = os.path.join(directory, dirname)\n        _dbg(\"Checking for include file %s in %s\", (include, subdir))\n        if os.path.isfile(os.path.join(subdir, include)):\n            _dbg(\"Found %s in %s\", (include, subdir))\n            return subdir\n\n\ndef _cmd_exists(cmd: str) -> bool:\n    if \"PATH\" not in os.environ:\n        return False\n    return any(\n        os.access(os.path.join(path, cmd), os.X_OK)\n        for path in os.environ[\"PATH\"].split(os.pathsep)\n    )\n\n\ndef _pkg_config(name):\n    command = os.environ.get(\"PKG_CONFIG\", \"pkg-config\")\n    for keep_system in (True, False):\n        try:\n            command_libs = [command, \"--libs-only-L\", name]\n            command_cflags = [command, \"--cflags-only-I\", name]\n            stderr = None\n            if keep_system:\n                command_libs.append(\"--keep-system-libs\")\n                command_cflags.append(\"--keep-system-cflags\")\n                stderr = subprocess.DEVNULL\n            if not DEBUG:\n                command_libs.append(\"--silence-errors\")\n                command_cflags.append(\"--silence-errors\")\n            libs = re.split(\n                r\"(^|\\s+)-L\",\n                subprocess.check_output(command_libs, stderr=stderr)\n                .decode(\"utf8\")\n                .strip(),\n            )[::2][1:]\n            cflags = re.split(\n                r\"(^|\\s+)-I\",\n                subprocess.check_output(command_cflags).decode(\"utf8\").strip(),\n            )[::2][1:]\n            return libs, cflags\n        except Exception:\n            pass\n\n\nclass pil_build_ext(build_ext):\n    class feature:\n        features = [\n            \"zlib\",\n            \"jpeg\",\n            \"tiff\",\n            \"freetype\",\n            \"raqm\",\n            \"lcms\",\n            \"webp\",\n            \"webpmux\",\n            \"jpeg2000\",\n            \"imagequant\",\n            \"xcb\",\n        ]\n\n        required = {\"jpeg\", \"zlib\"}\n        vendor = set()\n\n        def __init__(self):\n            for f in self.features:\n                setattr(self, f, None)\n\n        def require(self, feat):\n            return feat in self.required\n\n        def want(self, feat):\n            return getattr(self, feat) is None\n\n        def want_vendor(self, feat):\n            return feat in self.vendor\n\n        def __iter__(self):\n            yield from self.features\n\n    feature = feature()\n\n    user_options = (\n        build_ext.user_options\n        + [(f\"disable-{x}\", None, f\"Disable support for {x}\") for x in feature]\n        + [(f\"enable-{x}\", None, f\"Enable support for {x}\") for x in feature]\n        + [\n            (f\"vendor-{x}\", None, f\"Use vendored version of {x}\")\n            for x in (\"raqm\", \"fribidi\")\n        ]\n        + [\n            (\"disable-platform-guessing\", None, \"Disable platform guessing on Linux\"),\n            (\"debug\", None, \"Debug logging\"),\n        ]\n        + [(\"add-imaging-libs=\", None, \"Add libs to _imaging build\")]\n    )\n\n    @staticmethod\n    def check_configuration(option, value):\n        return True if value in configuration.get(option, []) else None\n\n    def initialize_options(self):\n        self.disable_platform_guessing = self.check_configuration(\n            \"platform-guessing\", \"disable\"\n        )\n        self.add_imaging_libs = \"\"\n        build_ext.initialize_options(self)\n        for x in self.feature:\n            setattr(self, f\"disable_{x}\", self.check_configuration(x, \"disable\"))\n            setattr(self, f\"enable_{x}\", self.check_configuration(x, \"enable\"))\n        for x in (\"raqm\", \"fribidi\"):\n            setattr(self, f\"vendor_{x}\", self.check_configuration(x, \"vendor\"))\n        if self.check_configuration(\"debug\", \"true\"):\n            self.debug = True\n        self.parallel = configuration.get(\"parallel\", [None])[-1]\n\n    def finalize_options(self):\n        build_ext.finalize_options(self)\n        if self.debug:\n            global DEBUG\n            DEBUG = True\n        if not self.parallel:\n            # If --parallel (or -j) wasn't specified, we want to reproduce the same\n            # behavior as before, that is, auto-detect the number of jobs.\n            try:\n                self.parallel = int(\n                    os.environ.get(\"MAX_CONCURRENCY\", min(4, os.cpu_count()))\n                )\n            except TypeError:\n                self.parallel = None\n        for x in self.feature:\n            if getattr(self, f\"disable_{x}\"):\n                setattr(self.feature, x, False)\n                self.feature.required.discard(x)\n                _dbg(\"Disabling %s\", x)\n                if getattr(self, f\"enable_{x}\"):\n                    msg = f\"Conflicting options: --enable-{x} and --disable-{x}\"\n                    raise ValueError(msg)\n                if x == \"freetype\":\n                    _dbg(\"--disable-freetype implies --disable-raqm\")\n                    if getattr(self, \"enable_raqm\"):\n                        msg = (\n                            \"Conflicting options: --enable-raqm and --disable-freetype\"\n                        )\n                        raise ValueError(msg)\n                    setattr(self, \"disable_raqm\", True)\n            if getattr(self, f\"enable_{x}\"):\n                _dbg(\"Requiring %s\", x)\n                self.feature.required.add(x)\n                if x == \"raqm\":\n                    _dbg(\"--enable-raqm implies --enable-freetype\")\n                    self.feature.required.add(\"freetype\")\n        for x in (\"raqm\", \"fribidi\"):\n            if getattr(self, f\"vendor_{x}\"):\n                if getattr(self, \"disable_raqm\"):\n                    msg = f\"Conflicting options: --vendor-{x} and --disable-raqm\"\n                    raise ValueError(msg)\n                if x == \"fribidi\" and not getattr(self, \"vendor_raqm\"):\n                    msg = f\"Conflicting options: --vendor-{x} and not --vendor-raqm\"\n                    raise ValueError(msg)\n                _dbg(\"Using vendored version of %s\", x)\n                self.feature.vendor.add(x)\n\n    def _update_extension(self, name, libraries, define_macros=None, sources=None):\n        for extension in self.extensions:\n            if extension.name == name:\n                extension.libraries += libraries\n                if define_macros is not None:\n                    extension.define_macros += define_macros\n                if sources is not None:\n                    extension.sources += sources\n                if FUZZING_BUILD:\n                    extension.language = \"c++\"\n                    extension.extra_link_args = [\"--stdlib=libc++\"]\n                break\n\n    def _remove_extension(self, name):\n        for extension in self.extensions:\n            if extension.name == name:\n                self.extensions.remove(extension)\n                break\n\n    def get_macos_sdk_path(self):\n        try:\n            sdk_path = (\n                subprocess.check_output([\"xcrun\", \"--show-sdk-path\"])\n                .strip()\n                .decode(\"latin1\")\n            )\n        except Exception:\n            sdk_path = None\n        if (\n            not sdk_path\n            or sdk_path == \"/Applications/Xcode.app/Contents/Developer\"\n            \"/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk\"\n        ):\n            commandlinetools_sdk_path = (\n                \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk\"\n            )\n            if os.path.exists(commandlinetools_sdk_path):\n                sdk_path = commandlinetools_sdk_path\n        return sdk_path\n\n    def build_extensions(self):\n        library_dirs = []\n        include_dirs = []\n\n        pkg_config = None\n        if _cmd_exists(os.environ.get(\"PKG_CONFIG\", \"pkg-config\")):\n            pkg_config = _pkg_config\n\n        #\n        # add configured kits\n        for root_name, lib_name in {\n            \"JPEG_ROOT\": \"libjpeg\",\n            \"JPEG2K_ROOT\": \"libopenjp2\",\n            \"TIFF_ROOT\": (\"libtiff-5\", \"libtiff-4\"),\n            \"ZLIB_ROOT\": \"zlib\",\n            \"FREETYPE_ROOT\": \"freetype2\",\n            \"HARFBUZZ_ROOT\": \"harfbuzz\",\n            \"FRIBIDI_ROOT\": \"fribidi\",\n            \"RAQM_ROOT\": \"raqm\",\n            \"WEBP_ROOT\": \"libwebp\",\n            \"LCMS_ROOT\": \"lcms2\",\n            \"IMAGEQUANT_ROOT\": \"libimagequant\",\n        }.items():\n            root = globals()[root_name]\n\n            if root is None and root_name in os.environ:\n                prefix = os.environ[root_name]\n                root = (os.path.join(prefix, \"lib\"), os.path.join(prefix, \"include\"))\n\n            if root is None and pkg_config:\n                if isinstance(lib_name, tuple):\n                    for lib_name2 in lib_name:\n                        _dbg(f\"Looking for `{lib_name2}` using pkg-config.\")\n                        root = pkg_config(lib_name2)\n                        if root:\n                            break\n                else:\n                    _dbg(f\"Looking for `{lib_name}` using pkg-config.\")\n                    root = pkg_config(lib_name)\n\n            if isinstance(root, tuple):\n                lib_root, include_root = root\n            else:\n                lib_root = include_root = root\n\n            if lib_root is not None:\n                if not isinstance(lib_root, (tuple, list)):\n                    lib_root = (lib_root,)\n                for lib_dir in lib_root:\n                    _add_directory(library_dirs, lib_dir)\n            if include_root is not None:\n                if not isinstance(include_root, (tuple, list)):\n                    include_root = (include_root,)\n                for include_dir in include_root:\n                    _add_directory(include_dirs, include_dir)\n\n        # respect CFLAGS/CPPFLAGS/LDFLAGS\n        for k in (\"CFLAGS\", \"CPPFLAGS\", \"LDFLAGS\"):\n            if k in os.environ:\n                for match in re.finditer(r\"-I([^\\s]+)\", os.environ[k]):\n                    _add_directory(include_dirs, match.group(1))\n                for match in re.finditer(r\"-L([^\\s]+)\", os.environ[k]):\n                    _add_directory(library_dirs, match.group(1))\n\n        # include, rpath, if set as environment variables:\n        for k in (\"C_INCLUDE_PATH\", \"CPATH\", \"INCLUDE\"):\n            if k in os.environ:\n                for d in os.environ[k].split(os.path.pathsep):\n                    _add_directory(include_dirs, d)\n\n        for k in (\"LD_RUN_PATH\", \"LIBRARY_PATH\", \"LIB\"):\n            if k in os.environ:\n                for d in os.environ[k].split(os.path.pathsep):\n                    _add_directory(library_dirs, d)\n\n        _add_directory(library_dirs, os.path.join(sys.prefix, \"lib\"))\n        _add_directory(include_dirs, os.path.join(sys.prefix, \"include\"))\n\n        #\n        # add platform directories\n\n        if self.disable_platform_guessing:\n            pass\n\n        elif sys.platform == \"cygwin\":\n            # pythonX.Y.dll.a is in the /usr/lib/pythonX.Y/config directory\n            self.compiler.shared_lib_extension = \".dll.a\"\n            _add_directory(\n                library_dirs,\n                os.path.join(\n                    \"/usr/lib\", \"python{}.{}\".format(*sys.version_info), \"config\"\n                ),\n            )\n\n        elif sys.platform == \"darwin\":\n            # attempt to make sure we pick freetype2 over other versions\n            _add_directory(include_dirs, \"/sw/include/freetype2\")\n            _add_directory(include_dirs, \"/sw/lib/freetype2/include\")\n            # fink installation directories\n            _add_directory(library_dirs, \"/sw/lib\")\n            _add_directory(include_dirs, \"/sw/include\")\n            # darwin ports installation directories\n            _add_directory(library_dirs, \"/opt/local/lib\")\n            _add_directory(include_dirs, \"/opt/local/include\")\n\n            # if Homebrew is installed, use its lib and include directories\n            try:\n                prefix = (\n                    subprocess.check_output([\"brew\", \"--prefix\"])\n                    .strip()\n                    .decode(\"latin1\")\n                )\n            except Exception:\n                # Homebrew not installed\n                prefix = None\n\n            ft_prefix = None\n\n            if prefix:\n                # add Homebrew's include and lib directories\n                _add_directory(library_dirs, os.path.join(prefix, \"lib\"))\n                _add_directory(include_dirs, os.path.join(prefix, \"include\"))\n                _add_directory(\n                    include_dirs, os.path.join(prefix, \"opt\", \"zlib\", \"include\")\n                )\n                ft_prefix = os.path.join(prefix, \"opt\", \"freetype\")\n\n            if ft_prefix and os.path.isdir(ft_prefix):\n                # freetype might not be linked into Homebrew's prefix\n                _add_directory(library_dirs, os.path.join(ft_prefix, \"lib\"))\n                _add_directory(include_dirs, os.path.join(ft_prefix, \"include\"))\n            else:\n                # fall back to freetype from XQuartz if\n                # Homebrew's freetype is missing\n                _add_directory(library_dirs, \"/usr/X11/lib\")\n                _add_directory(include_dirs, \"/usr/X11/include\")\n\n            sdk_path = self.get_macos_sdk_path()\n            if sdk_path:\n                _add_directory(library_dirs, os.path.join(sdk_path, \"usr\", \"lib\"))\n                _add_directory(include_dirs, os.path.join(sdk_path, \"usr\", \"include\"))\n\n                for extension in self.extensions:\n                    extension.extra_compile_args = [\"-Wno-nullability-completeness\"]\n        elif (\n            sys.platform.startswith(\"linux\")\n            or sys.platform.startswith(\"gnu\")\n            or sys.platform.startswith(\"freebsd\")\n        ):\n            for dirname in _find_library_dirs_ldconfig():\n                _add_directory(library_dirs, dirname)\n            if sys.platform.startswith(\"linux\") and os.environ.get(\"ANDROID_ROOT\"):\n                # termux support for android.\n                # system libraries (zlib) are installed in /system/lib\n                # headers are at $PREFIX/include\n                # user libs are at $PREFIX/lib\n                _add_directory(\n                    library_dirs,\n                    os.path.join(\n                        os.environ[\"ANDROID_ROOT\"],\n                        \"lib\" if struct.calcsize(\"l\") == 4 else \"lib64\",\n                    ),\n                )\n\n        elif sys.platform.startswith(\"netbsd\"):\n            _add_directory(library_dirs, \"/usr/pkg/lib\")\n            _add_directory(include_dirs, \"/usr/pkg/include\")\n\n        elif sys.platform.startswith(\"sunos5\"):\n            _add_directory(library_dirs, \"/opt/local/lib\")\n            _add_directory(include_dirs, \"/opt/local/include\")\n\n        # FIXME: check /opt/stuff directories here?\n\n        # standard locations\n        if not self.disable_platform_guessing:\n            _add_directory(library_dirs, \"/usr/local/lib\")\n            _add_directory(include_dirs, \"/usr/local/include\")\n\n            _add_directory(library_dirs, \"/usr/lib\")\n            _add_directory(include_dirs, \"/usr/include\")\n            # alpine, at least\n            _add_directory(library_dirs, \"/lib\")\n\n        if sys.platform == \"win32\":\n            # on Windows, look for the OpenJPEG libraries in the location that\n            # the official installer puts them\n            program_files = os.environ.get(\"ProgramFiles\", \"\")\n            best_version = (0, 0)\n            best_path = None\n            for name in os.listdir(program_files):\n                if name.startswith(\"OpenJPEG \"):\n                    version = tuple(int(x) for x in name[9:].strip().split(\".\"))\n                    if version > best_version:\n                        best_version = version\n                        best_path = os.path.join(program_files, name)\n\n            if best_path:\n                _dbg(\"Adding %s to search list\", best_path)\n                _add_directory(library_dirs, os.path.join(best_path, \"lib\"))\n                _add_directory(include_dirs, os.path.join(best_path, \"include\"))\n\n        #\n        # insert new dirs *before* default libs, to avoid conflicts\n        # between Python PYD stub libs and real libraries\n\n        self.compiler.library_dirs = library_dirs + self.compiler.library_dirs\n        self.compiler.include_dirs = include_dirs + self.compiler.include_dirs\n\n        #\n        # look for available libraries\n\n        feature = self.feature\n\n        if feature.want(\"zlib\"):\n            _dbg(\"Looking for zlib\")\n            if _find_include_file(self, \"zlib.h\"):\n                if _find_library_file(self, \"z\"):\n                    feature.zlib = \"z\"\n                elif sys.platform == \"win32\" and _find_library_file(self, \"zlib\"):\n                    feature.zlib = \"zlib\"  # alternative name\n\n        if feature.want(\"jpeg\"):\n            _dbg(\"Looking for jpeg\")\n            if _find_include_file(self, \"jpeglib.h\"):\n                if _find_library_file(self, \"jpeg\"):\n                    feature.jpeg = \"jpeg\"\n                elif sys.platform == \"win32\" and _find_library_file(self, \"libjpeg\"):\n                    feature.jpeg = \"libjpeg\"  # alternative name\n\n        feature.openjpeg_version = None\n        if feature.want(\"jpeg2000\"):\n            _dbg(\"Looking for jpeg2000\")\n            best_version = None\n            best_path = None\n\n            # Find the best version\n            for directory in self.compiler.include_dirs:\n                _dbg(\"Checking for openjpeg-#.# in %s\", directory)\n                try:\n                    listdir = os.listdir(directory)\n                except Exception:\n                    # OSError, FileNotFoundError\n                    continue\n                for name in listdir:\n                    if name.startswith(\"openjpeg-\") and os.path.isfile(\n                        os.path.join(directory, name, \"openjpeg.h\")\n                    ):\n                        _dbg(\"Found openjpeg.h in %s/%s\", (directory, name))\n                        version = tuple(int(x) for x in name[9:].split(\".\"))\n                        if best_version is None or version > best_version:\n                            best_version = version\n                            best_path = os.path.join(directory, name)\n                            _dbg(\n                                \"Best openjpeg version %s so far in %s\",\n                                (best_version, best_path),\n                            )\n\n            if best_version and _find_library_file(self, \"openjp2\"):\n                # Add the directory to the include path so we can include\n                # <openjpeg.h> rather than having to cope with the versioned\n                # include path\n                _add_directory(self.compiler.include_dirs, best_path, 0)\n                feature.jpeg2000 = \"openjp2\"\n                feature.openjpeg_version = \".\".join(str(x) for x in best_version)\n\n        if feature.want(\"imagequant\"):\n            _dbg(\"Looking for imagequant\")\n            if _find_include_file(self, \"libimagequant.h\"):\n                if _find_library_file(self, \"imagequant\"):\n                    feature.imagequant = \"imagequant\"\n                elif _find_library_file(self, \"libimagequant\"):\n                    feature.imagequant = \"libimagequant\"\n\n        if feature.want(\"tiff\"):\n            _dbg(\"Looking for tiff\")\n            if _find_include_file(self, \"tiff.h\"):\n                if _find_library_file(self, \"tiff\"):\n                    feature.tiff = \"tiff\"\n                if sys.platform in [\"win32\", \"darwin\"] and _find_library_file(\n                    self, \"libtiff\"\n                ):\n                    feature.tiff = \"libtiff\"\n\n        if feature.want(\"freetype\"):\n            _dbg(\"Looking for freetype\")\n            if _find_library_file(self, \"freetype\"):\n                # look for freetype2 include files\n                freetype_version = 0\n                for subdir in self.compiler.include_dirs:\n                    _dbg(\"Checking for include file %s in %s\", (\"ft2build.h\", subdir))\n                    if os.path.isfile(os.path.join(subdir, \"ft2build.h\")):\n                        _dbg(\"Found %s in %s\", (\"ft2build.h\", subdir))\n                        freetype_version = 21\n                        subdir = os.path.join(subdir, \"freetype2\")\n                        break\n                    subdir = os.path.join(subdir, \"freetype2\")\n                    _dbg(\"Checking for include file %s in %s\", (\"ft2build.h\", subdir))\n                    if os.path.isfile(os.path.join(subdir, \"ft2build.h\")):\n                        _dbg(\"Found %s in %s\", (\"ft2build.h\", subdir))\n                        freetype_version = 21\n                        break\n                if freetype_version:\n                    feature.freetype = \"freetype\"\n                    if subdir:\n                        _add_directory(self.compiler.include_dirs, subdir, 0)\n\n        if feature.freetype and feature.want(\"raqm\"):\n            if not feature.want_vendor(\"raqm\"):  # want system Raqm\n                _dbg(\"Looking for Raqm\")\n                if _find_include_file(self, \"raqm.h\"):\n                    if _find_library_file(self, \"raqm\"):\n                        feature.raqm = \"raqm\"\n                    elif _find_library_file(self, \"libraqm\"):\n                        feature.raqm = \"libraqm\"\n            else:  # want to build Raqm from src/thirdparty\n                _dbg(\"Looking for HarfBuzz\")\n                feature.harfbuzz = None\n                hb_dir = _find_include_dir(self, \"harfbuzz\", \"hb.h\")\n                if hb_dir:\n                    if isinstance(hb_dir, str):\n                        _add_directory(self.compiler.include_dirs, hb_dir, 0)\n                    if _find_library_file(self, \"harfbuzz\"):\n                        feature.harfbuzz = \"harfbuzz\"\n                if feature.harfbuzz:\n                    if not feature.want_vendor(\"fribidi\"):  # want system FriBiDi\n                        _dbg(\"Looking for FriBiDi\")\n                        feature.fribidi = None\n                        fribidi_dir = _find_include_dir(self, \"fribidi\", \"fribidi.h\")\n                        if fribidi_dir:\n                            if isinstance(fribidi_dir, str):\n                                _add_directory(\n                                    self.compiler.include_dirs, fribidi_dir, 0\n                                )\n                            if _find_library_file(self, \"fribidi\"):\n                                feature.fribidi = \"fribidi\"\n                                feature.raqm = True\n                    else:  # want to build FriBiDi shim from src/thirdparty\n                        feature.raqm = True\n\n        if feature.want(\"lcms\"):\n            _dbg(\"Looking for lcms\")\n            if _find_include_file(self, \"lcms2.h\"):\n                if _find_library_file(self, \"lcms2\"):\n                    feature.lcms = \"lcms2\"\n                elif _find_library_file(self, \"lcms2_static\"):\n                    # alternate Windows name.\n                    feature.lcms = \"lcms2_static\"\n\n        if feature.want(\"webp\"):\n            _dbg(\"Looking for webp\")\n            if _find_include_file(self, \"webp/encode.h\") and _find_include_file(\n                self, \"webp/decode.h\"\n            ):\n                # In Google's precompiled zip it is call \"libwebp\":\n                if _find_library_file(self, \"webp\"):\n                    feature.webp = \"webp\"\n                elif _find_library_file(self, \"libwebp\"):\n                    feature.webp = \"libwebp\"\n\n        if feature.want(\"webpmux\"):\n            _dbg(\"Looking for webpmux\")\n            if _find_include_file(self, \"webp/mux.h\") and _find_include_file(\n                self, \"webp/demux.h\"\n            ):\n                if _find_library_file(self, \"webpmux\") and _find_library_file(\n                    self, \"webpdemux\"\n                ):\n                    feature.webpmux = \"webpmux\"\n                if _find_library_file(self, \"libwebpmux\") and _find_library_file(\n                    self, \"libwebpdemux\"\n                ):\n                    feature.webpmux = \"libwebpmux\"\n\n        if feature.want(\"xcb\"):\n            _dbg(\"Looking for xcb\")\n            if _find_include_file(self, \"xcb/xcb.h\"):\n                if _find_library_file(self, \"xcb\"):\n                    feature.xcb = \"xcb\"\n\n        for f in feature:\n            if not getattr(feature, f) and feature.require(f):\n                if f in (\"jpeg\", \"zlib\"):\n                    raise RequiredDependencyException(f)\n                raise DependencyException(f)\n\n        #\n        # core library\n\n        libs = self.add_imaging_libs.split()\n        defs = []\n        if feature.tiff:\n            libs.append(feature.tiff)\n            defs.append((\"HAVE_LIBTIFF\", None))\n            if sys.platform == \"win32\":\n                # This define needs to be defined if-and-only-if it was defined\n                # when compiling LibTIFF. LibTIFF doesn't expose it in `tiffconf.h`,\n                # so we have to guess; by default it is defined in all Windows builds.\n                # See #4237, #5243, #5359 for more information.\n                defs.append((\"USE_WIN32_FILEIO\", None))\n        if feature.jpeg:\n            libs.append(feature.jpeg)\n            defs.append((\"HAVE_LIBJPEG\", None))\n        if feature.jpeg2000:\n            libs.append(feature.jpeg2000)\n            defs.append((\"HAVE_OPENJPEG\", None))\n            if sys.platform == \"win32\" and not PLATFORM_MINGW:\n                defs.append((\"OPJ_STATIC\", None))\n        if feature.zlib:\n            libs.append(feature.zlib)\n            defs.append((\"HAVE_LIBZ\", None))\n        if feature.imagequant:\n            libs.append(feature.imagequant)\n            defs.append((\"HAVE_LIBIMAGEQUANT\", None))\n        if feature.xcb:\n            libs.append(feature.xcb)\n            defs.append((\"HAVE_XCB\", None))\n        if sys.platform == \"win32\":\n            libs.extend([\"kernel32\", \"user32\", \"gdi32\"])\n        if struct.unpack(\"h\", b\"\\0\\1\")[0] == 1:\n            defs.append((\"WORDS_BIGENDIAN\", None))\n\n        defs.append((\"PILLOW_VERSION\", f'\"{PILLOW_VERSION}\"'))\n\n        self._update_extension(\"PIL._imaging\", libs, defs)\n\n        #\n        # additional libraries\n\n        if feature.freetype:\n            srcs = []\n            libs = [\"freetype\"]\n            defs = []\n            if feature.raqm:\n                if not feature.want_vendor(\"raqm\"):  # using system Raqm\n                    defs.append((\"HAVE_RAQM\", None))\n                    defs.append((\"HAVE_RAQM_SYSTEM\", None))\n                    libs.append(feature.raqm)\n                else:  # building Raqm from src/thirdparty\n                    defs.append((\"HAVE_RAQM\", None))\n                    srcs.append(\"src/thirdparty/raqm/raqm.c\")\n                    libs.append(feature.harfbuzz)\n                    if not feature.want_vendor(\"fribidi\"):  # using system FriBiDi\n                        defs.append((\"HAVE_FRIBIDI_SYSTEM\", None))\n                        libs.append(feature.fribidi)\n                    else:  # building FriBiDi shim from src/thirdparty\n                        srcs.append(\"src/thirdparty/fribidi-shim/fribidi.c\")\n            self._update_extension(\"PIL._imagingft\", libs, defs, srcs)\n\n        else:\n            self._remove_extension(\"PIL._imagingft\")\n\n        if feature.lcms:\n            extra = []\n            if sys.platform == \"win32\":\n                extra.extend([\"user32\", \"gdi32\"])\n            self._update_extension(\"PIL._imagingcms\", [feature.lcms] + extra)\n        else:\n            self._remove_extension(\"PIL._imagingcms\")\n\n        if feature.webp:\n            libs = [feature.webp]\n            defs = []\n\n            if feature.webpmux:\n                defs.append((\"HAVE_WEBPMUX\", None))\n                libs.append(feature.webpmux)\n                libs.append(feature.webpmux.replace(\"pmux\", \"pdemux\"))\n\n            self._update_extension(\"PIL._webp\", libs, defs)\n        else:\n            self._remove_extension(\"PIL._webp\")\n\n        tk_libs = [\"psapi\"] if sys.platform in (\"win32\", \"cygwin\") else []\n        self._update_extension(\"PIL._imagingtk\", tk_libs)\n\n        build_ext.build_extensions(self)\n\n        #\n        # sanity checks\n\n        self.summary_report(feature)\n\n    def summary_report(self, feature):\n        print(\"-\" * 68)\n        print(\"PIL SETUP SUMMARY\")\n        print(\"-\" * 68)\n        print(f\"version      Pillow {PILLOW_VERSION}\")\n        v = sys.version.split(\"[\")\n        print(f\"platform     {sys.platform} {v[0].strip()}\")\n        for v in v[1:]:\n            print(f\"             [{v.strip()}\")\n        print(\"-\" * 68)\n\n        raqm_extra_info = \"\"\n        if feature.want_vendor(\"raqm\"):\n            raqm_extra_info += \"bundled\"\n            if feature.want_vendor(\"fribidi\"):\n                raqm_extra_info += \", FriBiDi shim\"\n\n        options = [\n            (feature.jpeg, \"JPEG\"),\n            (feature.jpeg2000, \"OPENJPEG (JPEG2000)\", feature.openjpeg_version),\n            (feature.zlib, \"ZLIB (PNG/ZIP)\"),\n            (feature.imagequant, \"LIBIMAGEQUANT\"),\n            (feature.tiff, \"LIBTIFF\"),\n            (feature.freetype, \"FREETYPE2\"),\n            (feature.raqm, \"RAQM (Text shaping)\", raqm_extra_info),\n            (feature.lcms, \"LITTLECMS2\"),\n            (feature.webp, \"WEBP\"),\n            (feature.webpmux, \"WEBPMUX\"),\n            (feature.xcb, \"XCB (X protocol)\"),\n        ]\n\n        all = 1\n        for option in options:\n            if option[0]:\n                extra_info = \"\"\n                if len(option) >= 3 and option[2]:\n                    extra_info = f\" ({option[2]})\"\n                print(f\"--- {option[1]} support available{extra_info}\")\n            else:\n                print(f\"*** {option[1]} support not available\")\n                all = 0\n\n        print(\"-\" * 68)\n\n        if not all:\n            print(\"To add a missing option, make sure you have the required\")\n            print(\"library and headers.\")\n            print(\n                \"See https://pillow.readthedocs.io/en/latest/installation.\"\n                \"html#building-from-source\"\n            )\n            print(\"\")\n\n        print(\"To check the build, run the selftest.py script.\")\n        print(\"\")\n\n\ndef debug_build():\n    return hasattr(sys, \"gettotalrefcount\") or FUZZING_BUILD\n\n\nfiles = [\"src/_imaging.c\"]\nfor src_file in _IMAGING:\n    files.append(\"src/\" + src_file + \".c\")\nfor src_file in _LIB_IMAGING:\n    files.append(os.path.join(\"src/libImaging\", src_file + \".c\"))\next_modules = [\n    Extension(\"PIL._imaging\", files),\n    Extension(\"PIL._imagingft\", [\"src/_imagingft.c\"]),\n    Extension(\"PIL._imagingcms\", [\"src/_imagingcms.c\"]),\n    Extension(\"PIL._webp\", [\"src/_webp.c\"]),\n    Extension(\"PIL._imagingtk\", [\"src/_imagingtk.c\", \"src/Tk/tkImaging.c\"]),\n    Extension(\"PIL._imagingmath\", [\"src/_imagingmath.c\"]),\n    Extension(\"PIL._imagingmorph\", [\"src/_imagingmorph.c\"]),\n]\n\n\n# parse configuration from _custom_build/backend.py\nwhile sys.argv[-1].startswith(\"--pillow-configuration=\"):\n    _, key, value = sys.argv.pop().split(\"=\", 2)\n    configuration.setdefault(key, []).append(value)\n\ntry:\n    setup(\n        cmdclass={\"build_ext\": pil_build_ext},\n        ext_modules=ext_modules,\n        zip_safe=not (debug_build() or PLATFORM_MINGW),\n    )\nexcept RequiredDependencyException as err:\n    msg = f\"\"\"\n\nThe headers or library files could not be found for {str(err)},\na required dependency when compiling Pillow from source.\n\nPlease see the install instructions at:\n   https://pillow.readthedocs.io/en/latest/installation/basic-installation.html\n\n\"\"\"\n    sys.stderr.write(msg)\n    raise RequiredDependencyException(msg)\nexcept DependencyException as err:\n    msg = f\"\"\"\n\nThe headers or library files could not be found for {str(err)},\nwhich was requested by the option flag --enable-{str(err)}\n\n\"\"\"\n    sys.stderr.write(msg)\n    raise DependencyException(msg)\n", "_custom_build/backend.py": "from __future__ import annotations\n\nimport sys\n\nfrom setuptools.build_meta import *  # noqa: F403\nfrom setuptools.build_meta import build_wheel\n\nbackend_class = build_wheel.__self__.__class__\n\n\nclass _CustomBuildMetaBackend(backend_class):\n    def run_setup(self, setup_script=\"setup.py\"):\n        if self.config_settings:\n            for key, values in self.config_settings.items():\n                if not isinstance(values, list):\n                    values = [values]\n                for value in values:\n                    sys.argv.append(f\"--pillow-configuration={key}={value}\")\n\n        return super().run_setup(setup_script)\n\n    def build_wheel(\n        self, wheel_directory, config_settings=None, metadata_directory=None\n    ):\n        self.config_settings = config_settings\n        return super().build_wheel(wheel_directory, config_settings, metadata_directory)\n\n    def build_editable(\n        self, wheel_directory, config_settings=None, metadata_directory=None\n    ):\n        self.config_settings = config_settings\n        return super().build_editable(\n            wheel_directory, config_settings, metadata_directory\n        )\n\n\n_backend = _CustomBuildMetaBackend()\nbuild_wheel = _backend.build_wheel\nbuild_editable = _backend.build_editable\n", ".github/workflows/system-info.py": "\"\"\"\nPrint out some handy system info like Travis CI does.\n\nThis sort of info is missing from GitHub Actions.\n\nRequested here:\nhttps://github.com/actions/virtual-environments/issues/79\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nprint(\"Build system information\")\nprint()\n\nprint(\"sys.version\\t\\t\", sys.version.split(\"\\n\"))\nprint(\"os.name\\t\\t\\t\", os.name)\nprint(\"sys.platform\\t\\t\", sys.platform)\nprint(\"platform.system()\\t\", platform.system())\nprint(\"platform.machine()\\t\", platform.machine())\nprint(\"platform.platform()\\t\", platform.platform())\nprint(\"platform.version()\\t\", platform.version())\nprint(\"platform.uname()\\t\", platform.uname())\nif sys.platform == \"darwin\":\n    print(\"platform.mac_ver()\\t\", platform.mac_ver())\n", "src/PIL/ImageMorph.py": "# A binary morphology add-on for the Python Imaging Library\n#\n# History:\n#   2014-06-04 Initial version.\n#\n# Copyright (c) 2014 Dov Grobgeld <dov.grobgeld@gmail.com>\nfrom __future__ import annotations\n\nimport re\n\nfrom . import Image, _imagingmorph\n\nLUT_SIZE = 1 << 9\n\n# fmt: off\nROTATION_MATRIX = [\n    6, 3, 0,\n    7, 4, 1,\n    8, 5, 2,\n]\nMIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,\n    8, 7, 6,\n]\n# fmt: on\n\n\nclass LutBuilder:\n    \"\"\"A class for building a MorphLut from a descriptive language\n\n    The input patterns is a list of a strings sequences like these::\n\n        4:(...\n           .1.\n           111)->1\n\n    (whitespaces including linebreaks are ignored). The option 4\n    describes a series of symmetry operations (in this case a\n    4-rotation), the pattern is described by:\n\n    - . or X - Ignore\n    - 1 - Pixel is on\n    - 0 - Pixel is off\n\n    The result of the operation is described after \"->\" string.\n\n    The default is to return the current pixel value, which is\n    returned if no other match is found.\n\n    Operations:\n\n    - 4 - 4 way rotation\n    - N - Negate\n    - 1 - Dummy op for no other operation (an op must always be given)\n    - M - Mirroring\n\n    Example::\n\n        lb = LutBuilder(patterns = [\"4:(... .1. 111)->1\"])\n        lut = lb.build_lut()\n\n    \"\"\"\n\n    def __init__(\n        self, patterns: list[str] | None = None, op_name: str | None = None\n    ) -> None:\n        if patterns is not None:\n            self.patterns = patterns\n        else:\n            self.patterns = []\n        self.lut: bytearray | None = None\n        if op_name is not None:\n            known_patterns = {\n                \"corner\": [\"1:(... ... ...)->0\", \"4:(00. 01. ...)->1\"],\n                \"dilation4\": [\"4:(... .0. .1.)->1\"],\n                \"dilation8\": [\"4:(... .0. .1.)->1\", \"4:(... .0. ..1)->1\"],\n                \"erosion4\": [\"4:(... .1. .0.)->0\"],\n                \"erosion8\": [\"4:(... .1. .0.)->0\", \"4:(... .1. ..0)->0\"],\n                \"edge\": [\n                    \"1:(... ... ...)->0\",\n                    \"4:(.0. .1. ...)->1\",\n                    \"4:(01. .1. ...)->1\",\n                ],\n            }\n            if op_name not in known_patterns:\n                msg = f\"Unknown pattern {op_name}!\"\n                raise Exception(msg)\n\n            self.patterns = known_patterns[op_name]\n\n    def add_patterns(self, patterns: list[str]) -> None:\n        self.patterns += patterns\n\n    def build_default_lut(self) -> None:\n        symbols = [0, 1]\n        m = 1 << 4  # pos of current pixel\n        self.lut = bytearray(symbols[(i & m) > 0] for i in range(LUT_SIZE))\n\n    def get_lut(self) -> bytearray | None:\n        return self.lut\n\n    def _string_permute(self, pattern: str, permutation: list[int]) -> str:\n        \"\"\"string_permute takes a pattern and a permutation and returns the\n        string permuted according to the permutation list.\n        \"\"\"\n        assert len(permutation) == 9\n        return \"\".join(pattern[p] for p in permutation)\n\n    def _pattern_permute(\n        self, basic_pattern: str, options: str, basic_result: int\n    ) -> list[tuple[str, int]]:\n        \"\"\"pattern_permute takes a basic pattern and its result and clones\n        the pattern according to the modifications described in the $options\n        parameter. It returns a list of all cloned patterns.\"\"\"\n        patterns = [(basic_pattern, basic_result)]\n\n        # rotations\n        if \"4\" in options:\n            res = patterns[-1][1]\n            for i in range(4):\n                patterns.append(\n                    (self._string_permute(patterns[-1][0], ROTATION_MATRIX), res)\n                )\n        # mirror\n        if \"M\" in options:\n            n = len(patterns)\n            for pattern, res in patterns[:n]:\n                patterns.append((self._string_permute(pattern, MIRROR_MATRIX), res))\n\n        # negate\n        if \"N\" in options:\n            n = len(patterns)\n            for pattern, res in patterns[:n]:\n                # Swap 0 and 1\n                pattern = pattern.replace(\"0\", \"Z\").replace(\"1\", \"0\").replace(\"Z\", \"1\")\n                res = 1 - int(res)\n                patterns.append((pattern, res))\n\n        return patterns\n\n    def build_lut(self) -> bytearray:\n        \"\"\"Compile all patterns into a morphology lut.\n\n        TBD :Build based on (file) morphlut:modify_lut\n        \"\"\"\n        self.build_default_lut()\n        assert self.lut is not None\n        patterns = []\n\n        # Parse and create symmetries of the patterns strings\n        for p in self.patterns:\n            m = re.search(r\"(\\w*):?\\s*\\((.+?)\\)\\s*->\\s*(\\d)\", p.replace(\"\\n\", \"\"))\n            if not m:\n                msg = 'Syntax error in pattern \"' + p + '\"'\n                raise Exception(msg)\n            options = m.group(1)\n            pattern = m.group(2)\n            result = int(m.group(3))\n\n            # Get rid of spaces\n            pattern = pattern.replace(\" \", \"\").replace(\"\\n\", \"\")\n\n            patterns += self._pattern_permute(pattern, options, result)\n\n        # compile the patterns into regular expressions for speed\n        compiled_patterns = []\n        for pattern in patterns:\n            p = pattern[0].replace(\".\", \"X\").replace(\"X\", \"[01]\")\n            compiled_patterns.append((re.compile(p), pattern[1]))\n\n        # Step through table and find patterns that match.\n        # Note that all the patterns are searched. The last one\n        # caught overrides\n        for i in range(LUT_SIZE):\n            # Build the bit pattern\n            bitpattern = bin(i)[2:]\n            bitpattern = (\"0\" * (9 - len(bitpattern)) + bitpattern)[::-1]\n\n            for pattern, r in compiled_patterns:\n                if pattern.match(bitpattern):\n                    self.lut[i] = [0, 1][r]\n\n        return self.lut\n\n\nclass MorphOp:\n    \"\"\"A class for binary morphological operators\"\"\"\n\n    def __init__(\n        self,\n        lut: bytearray | None = None,\n        op_name: str | None = None,\n        patterns: list[str] | None = None,\n    ) -> None:\n        \"\"\"Create a binary morphological operator\"\"\"\n        self.lut = lut\n        if op_name is not None:\n            self.lut = LutBuilder(op_name=op_name).build_lut()\n        elif patterns is not None:\n            self.lut = LutBuilder(patterns=patterns).build_lut()\n\n    def apply(self, image: Image.Image) -> tuple[int, Image.Image]:\n        \"\"\"Run a single morphological operation on an image\n\n        Returns a tuple of the number of changed pixels and the\n        morphed image\"\"\"\n        if self.lut is None:\n            msg = \"No operator loaded\"\n            raise Exception(msg)\n\n        if image.mode != \"L\":\n            msg = \"Image mode must be L\"\n            raise ValueError(msg)\n        outimage = Image.new(image.mode, image.size, None)\n        count = _imagingmorph.apply(bytes(self.lut), image.im.id, outimage.im.id)\n        return count, outimage\n\n    def match(self, image: Image.Image) -> list[tuple[int, int]]:\n        \"\"\"Get a list of coordinates matching the morphological operation on\n        an image.\n\n        Returns a list of tuples of (x,y) coordinates\n        of all matching pixels. See :ref:`coordinate-system`.\"\"\"\n        if self.lut is None:\n            msg = \"No operator loaded\"\n            raise Exception(msg)\n\n        if image.mode != \"L\":\n            msg = \"Image mode must be L\"\n            raise ValueError(msg)\n        return _imagingmorph.match(bytes(self.lut), image.im.id)\n\n    def get_on_pixels(self, image: Image.Image) -> list[tuple[int, int]]:\n        \"\"\"Get a list of all turned on pixels in a binary image\n\n        Returns a list of tuples of (x,y) coordinates\n        of all matching pixels. See :ref:`coordinate-system`.\"\"\"\n\n        if image.mode != \"L\":\n            msg = \"Image mode must be L\"\n            raise ValueError(msg)\n        return _imagingmorph.get_on_pixels(image.im.id)\n\n    def load_lut(self, filename: str) -> None:\n        \"\"\"Load an operator from an mrl file\"\"\"\n        with open(filename, \"rb\") as f:\n            self.lut = bytearray(f.read())\n\n        if len(self.lut) != LUT_SIZE:\n            self.lut = None\n            msg = \"Wrong size operator file!\"\n            raise Exception(msg)\n\n    def save_lut(self, filename: str) -> None:\n        \"\"\"Save an operator to an mrl file\"\"\"\n        if self.lut is None:\n            msg = \"No operator loaded\"\n            raise Exception(msg)\n        with open(filename, \"wb\") as f:\n            f.write(self.lut)\n\n    def set_lut(self, lut: bytearray | None) -> None:\n        \"\"\"Set the lut from an external source\"\"\"\n        self.lut = lut\n", "src/PIL/MspImagePlugin.py": "#\n# The Python Imaging Library.\n#\n# MSP file handling\n#\n# This is the format used by the Paint program in Windows 1 and 2.\n#\n# History:\n#       95-09-05 fl     Created\n#       97-01-03 fl     Read/write MSP images\n#       17-02-21 es     Fixed RLE interpretation\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1995-97.\n# Copyright (c) Eric Soroos 2017.\n#\n# See the README file for information on usage and redistribution.\n#\n# More info on this format: https://archive.org/details/gg243631\n# Page 313:\n# Figure 205. Windows Paint Version 1: \"DanM\" Format\n# Figure 206. Windows Paint Version 2: \"LinS\" Format. Used in Windows V2.03\n#\n# See also: https://www.fileformat.info/format/mspaint/egff.htm\nfrom __future__ import annotations\n\nimport io\nimport struct\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16le as i16\nfrom ._binary import o16le as o16\n\n#\n# read MSP files\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] in [b\"DanM\", b\"LinS\"]\n\n\n##\n# Image plugin for Windows MSP images.  This plugin supports both\n# uncompressed (Windows 1.0).\n\n\nclass MspImageFile(ImageFile.ImageFile):\n    format = \"MSP\"\n    format_description = \"Windows Paint\"\n\n    def _open(self) -> None:\n        # Header\n        assert self.fp is not None\n\n        s = self.fp.read(32)\n        if not _accept(s):\n            msg = \"not an MSP file\"\n            raise SyntaxError(msg)\n\n        # Header checksum\n        checksum = 0\n        for i in range(0, 32, 2):\n            checksum = checksum ^ i16(s, i)\n        if checksum != 0:\n            msg = \"bad MSP checksum\"\n            raise SyntaxError(msg)\n\n        self._mode = \"1\"\n        self._size = i16(s, 4), i16(s, 6)\n\n        if s[:4] == b\"DanM\":\n            self.tile = [(\"raw\", (0, 0) + self.size, 32, (\"1\", 0, 1))]\n        else:\n            self.tile = [(\"MSP\", (0, 0) + self.size, 32, None)]\n\n\nclass MspDecoder(ImageFile.PyDecoder):\n    # The algo for the MSP decoder is from\n    # https://www.fileformat.info/format/mspaint/egff.htm\n    # cc-by-attribution -- That page references is taken from the\n    # Encyclopedia of Graphics File Formats and is licensed by\n    # O'Reilly under the Creative Common/Attribution license\n    #\n    # For RLE encoded files, the 32byte header is followed by a scan\n    # line map, encoded as one 16bit word of encoded byte length per\n    # line.\n    #\n    # NOTE: the encoded length of the line can be 0. This was not\n    # handled in the previous version of this encoder, and there's no\n    # mention of how to handle it in the documentation. From the few\n    # examples I've seen, I've assumed that it is a fill of the\n    # background color, in this case, white.\n    #\n    #\n    # Pseudocode of the decoder:\n    # Read a BYTE value as the RunType\n    #  If the RunType value is zero\n    #   Read next byte as the RunCount\n    #   Read the next byte as the RunValue\n    #   Write the RunValue byte RunCount times\n    #  If the RunType value is non-zero\n    #   Use this value as the RunCount\n    #   Read and write the next RunCount bytes literally\n    #\n    #  e.g.:\n    #  0x00 03 ff 05 00 01 02 03 04\n    #  would yield the bytes:\n    #  0xff ff ff 00 01 02 03 04\n    #\n    # which are then interpreted as a bit packed mode '1' image\n\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n\n        img = io.BytesIO()\n        blank_line = bytearray((0xFF,) * ((self.state.xsize + 7) // 8))\n        try:\n            self.fd.seek(32)\n            rowmap = struct.unpack_from(\n                f\"<{self.state.ysize}H\", self.fd.read(self.state.ysize * 2)\n            )\n        except struct.error as e:\n            msg = \"Truncated MSP file in row map\"\n            raise OSError(msg) from e\n\n        for x, rowlen in enumerate(rowmap):\n            try:\n                if rowlen == 0:\n                    img.write(blank_line)\n                    continue\n                row = self.fd.read(rowlen)\n                if len(row) != rowlen:\n                    msg = f\"Truncated MSP file, expected {rowlen} bytes on row {x}\"\n                    raise OSError(msg)\n                idx = 0\n                while idx < rowlen:\n                    runtype = row[idx]\n                    idx += 1\n                    if runtype == 0:\n                        (runcount, runval) = struct.unpack_from(\"Bc\", row, idx)\n                        img.write(runval * runcount)\n                        idx += 2\n                    else:\n                        runcount = runtype\n                        img.write(row[idx : idx + runcount])\n                        idx += runcount\n\n            except struct.error as e:\n                msg = f\"Corrupted MSP file in row {x}\"\n                raise OSError(msg) from e\n\n        self.set_as_raw(img.getvalue(), (\"1\", 0, 1))\n\n        return -1, 0\n\n\nImage.register_decoder(\"MSP\", MspDecoder)\n\n\n#\n# write MSP files (uncompressed only)\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode != \"1\":\n        msg = f\"cannot write mode {im.mode} as MSP\"\n        raise OSError(msg)\n\n    # create MSP header\n    header = [0] * 16\n\n    header[0], header[1] = i16(b\"Da\"), i16(b\"nM\")  # version 1\n    header[2], header[3] = im.size\n    header[4], header[5] = 1, 1\n    header[6], header[7] = 1, 1\n    header[8], header[9] = im.size\n\n    checksum = 0\n    for h in header:\n        checksum = checksum ^ h\n    header[12] = checksum  # FIXME: is this the right field?\n\n    # header\n    for h in header:\n        fp.write(o16(h))\n\n    # image body\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 32, (\"1\", 0, 1))])\n\n\n#\n# registry\n\nImage.register_open(MspImageFile.format, MspImageFile, _accept)\nImage.register_save(MspImageFile.format, _save)\n\nImage.register_extension(MspImageFile.format, \".msp\")\n", "src/PIL/WalImageFile.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# WAL file handling\n#\n# History:\n# 2003-04-23 fl   created\n#\n# Copyright (c) 2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nThis reader is based on the specification available from:\nhttps://www.flipcode.com/archives/Quake_2_BSP_File_Format.shtml\nand has been tested with a few sample files found using google.\n\n.. note::\n    This format cannot be automatically recognized, so the reader\n    is not registered for use with :py:func:`PIL.Image.open()`.\n    To open a WAL file, use the :py:func:`PIL.WalImageFile.open()` function instead.\n\"\"\"\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i32le as i32\n\n\nclass WalImageFile(ImageFile.ImageFile):\n    format = \"WAL\"\n    format_description = \"Quake2 Texture\"\n\n    def _open(self) -> None:\n        self._mode = \"P\"\n\n        # read header fields\n        header = self.fp.read(32 + 24 + 32 + 12)\n        self._size = i32(header, 32), i32(header, 36)\n        Image._decompression_bomb_check(self.size)\n\n        # load pixel data\n        offset = i32(header, 40)\n        self.fp.seek(offset)\n\n        # strings are null-terminated\n        self.info[\"name\"] = header[:32].split(b\"\\0\", 1)[0]\n        next_name = header[56 : 56 + 32].split(b\"\\0\", 1)[0]\n        if next_name:\n            self.info[\"next_name\"] = next_name\n\n    def load(self):\n        if not self.im:\n            self.im = Image.core.new(self.mode, self.size)\n            self.frombytes(self.fp.read(self.size[0] * self.size[1]))\n            self.putpalette(quake2palette)\n        return Image.Image.load(self)\n\n\ndef open(filename):\n    \"\"\"\n    Load texture from a Quake2 WAL texture file.\n\n    By default, a Quake2 standard palette is attached to the texture.\n    To override the palette, use the :py:func:`PIL.Image.Image.putpalette()` method.\n\n    :param filename: WAL file name, or an opened file handle.\n    :returns: An image instance.\n    \"\"\"\n    return WalImageFile(filename)\n\n\nquake2palette = (\n    # default palette taken from piffo 0.93 by Hans H\u00e4ggstr\u00f6m\n    b\"\\x01\\x01\\x01\\x0b\\x0b\\x0b\\x12\\x12\\x12\\x17\\x17\\x17\\x1b\\x1b\\x1b\\x1e\"\n    b\"\\x1e\\x1e\\x22\\x22\\x22\\x26\\x26\\x26\\x29\\x29\\x29\\x2c\\x2c\\x2c\\x2f\\x2f\"\n    b\"\\x2f\\x32\\x32\\x32\\x35\\x35\\x35\\x37\\x37\\x37\\x3a\\x3a\\x3a\\x3c\\x3c\\x3c\"\n    b\"\\x24\\x1e\\x13\\x22\\x1c\\x12\\x20\\x1b\\x12\\x1f\\x1a\\x10\\x1d\\x19\\x10\\x1b\"\n    b\"\\x17\\x0f\\x1a\\x16\\x0f\\x18\\x14\\x0d\\x17\\x13\\x0d\\x16\\x12\\x0d\\x14\\x10\"\n    b\"\\x0b\\x13\\x0f\\x0b\\x10\\x0d\\x0a\\x0f\\x0b\\x0a\\x0d\\x0b\\x07\\x0b\\x0a\\x07\"\n    b\"\\x23\\x23\\x26\\x22\\x22\\x25\\x22\\x20\\x23\\x21\\x1f\\x22\\x20\\x1e\\x20\\x1f\"\n    b\"\\x1d\\x1e\\x1d\\x1b\\x1c\\x1b\\x1a\\x1a\\x1a\\x19\\x19\\x18\\x17\\x17\\x17\\x16\"\n    b\"\\x16\\x14\\x14\\x14\\x13\\x13\\x13\\x10\\x10\\x10\\x0f\\x0f\\x0f\\x0d\\x0d\\x0d\"\n    b\"\\x2d\\x28\\x20\\x29\\x24\\x1c\\x27\\x22\\x1a\\x25\\x1f\\x17\\x38\\x2e\\x1e\\x31\"\n    b\"\\x29\\x1a\\x2c\\x25\\x17\\x26\\x20\\x14\\x3c\\x30\\x14\\x37\\x2c\\x13\\x33\\x28\"\n    b\"\\x12\\x2d\\x24\\x10\\x28\\x1f\\x0f\\x22\\x1a\\x0b\\x1b\\x14\\x0a\\x13\\x0f\\x07\"\n    b\"\\x31\\x1a\\x16\\x30\\x17\\x13\\x2e\\x16\\x10\\x2c\\x14\\x0d\\x2a\\x12\\x0b\\x27\"\n    b\"\\x0f\\x0a\\x25\\x0f\\x07\\x21\\x0d\\x01\\x1e\\x0b\\x01\\x1c\\x0b\\x01\\x1a\\x0b\"\n    b\"\\x01\\x18\\x0a\\x01\\x16\\x0a\\x01\\x13\\x0a\\x01\\x10\\x07\\x01\\x0d\\x07\\x01\"\n    b\"\\x29\\x23\\x1e\\x27\\x21\\x1c\\x26\\x20\\x1b\\x25\\x1f\\x1a\\x23\\x1d\\x19\\x21\"\n    b\"\\x1c\\x18\\x20\\x1b\\x17\\x1e\\x19\\x16\\x1c\\x18\\x14\\x1b\\x17\\x13\\x19\\x14\"\n    b\"\\x10\\x17\\x13\\x0f\\x14\\x10\\x0d\\x12\\x0f\\x0b\\x0f\\x0b\\x0a\\x0b\\x0a\\x07\"\n    b\"\\x26\\x1a\\x0f\\x23\\x19\\x0f\\x20\\x17\\x0f\\x1c\\x16\\x0f\\x19\\x13\\x0d\\x14\"\n    b\"\\x10\\x0b\\x10\\x0d\\x0a\\x0b\\x0a\\x07\\x33\\x22\\x1f\\x35\\x29\\x26\\x37\\x2f\"\n    b\"\\x2d\\x39\\x35\\x34\\x37\\x39\\x3a\\x33\\x37\\x39\\x30\\x34\\x36\\x2b\\x31\\x34\"\n    b\"\\x27\\x2e\\x31\\x22\\x2b\\x2f\\x1d\\x28\\x2c\\x17\\x25\\x2a\\x0f\\x20\\x26\\x0d\"\n    b\"\\x1e\\x25\\x0b\\x1c\\x22\\x0a\\x1b\\x20\\x07\\x19\\x1e\\x07\\x17\\x1b\\x07\\x14\"\n    b\"\\x18\\x01\\x12\\x16\\x01\\x0f\\x12\\x01\\x0b\\x0d\\x01\\x07\\x0a\\x01\\x01\\x01\"\n    b\"\\x2c\\x21\\x21\\x2a\\x1f\\x1f\\x29\\x1d\\x1d\\x27\\x1c\\x1c\\x26\\x1a\\x1a\\x24\"\n    b\"\\x18\\x18\\x22\\x17\\x17\\x21\\x16\\x16\\x1e\\x13\\x13\\x1b\\x12\\x12\\x18\\x10\"\n    b\"\\x10\\x16\\x0d\\x0d\\x12\\x0b\\x0b\\x0d\\x0a\\x0a\\x0a\\x07\\x07\\x01\\x01\\x01\"\n    b\"\\x2e\\x30\\x29\\x2d\\x2e\\x27\\x2b\\x2c\\x26\\x2a\\x2a\\x24\\x28\\x29\\x23\\x27\"\n    b\"\\x27\\x21\\x26\\x26\\x1f\\x24\\x24\\x1d\\x22\\x22\\x1c\\x1f\\x1f\\x1a\\x1c\\x1c\"\n    b\"\\x18\\x19\\x19\\x16\\x17\\x17\\x13\\x13\\x13\\x10\\x0f\\x0f\\x0d\\x0b\\x0b\\x0a\"\n    b\"\\x30\\x1e\\x1b\\x2d\\x1c\\x19\\x2c\\x1a\\x17\\x2a\\x19\\x14\\x28\\x17\\x13\\x26\"\n    b\"\\x16\\x10\\x24\\x13\\x0f\\x21\\x12\\x0d\\x1f\\x10\\x0b\\x1c\\x0f\\x0a\\x19\\x0d\"\n    b\"\\x0a\\x16\\x0b\\x07\\x12\\x0a\\x07\\x0f\\x07\\x01\\x0a\\x01\\x01\\x01\\x01\\x01\"\n    b\"\\x28\\x29\\x38\\x26\\x27\\x36\\x25\\x26\\x34\\x24\\x24\\x31\\x22\\x22\\x2f\\x20\"\n    b\"\\x21\\x2d\\x1e\\x1f\\x2a\\x1d\\x1d\\x27\\x1b\\x1b\\x25\\x19\\x19\\x21\\x17\\x17\"\n    b\"\\x1e\\x14\\x14\\x1b\\x13\\x12\\x17\\x10\\x0f\\x13\\x0d\\x0b\\x0f\\x0a\\x07\\x07\"\n    b\"\\x2f\\x32\\x29\\x2d\\x30\\x26\\x2b\\x2e\\x24\\x29\\x2c\\x21\\x27\\x2a\\x1e\\x25\"\n    b\"\\x28\\x1c\\x23\\x26\\x1a\\x21\\x25\\x18\\x1e\\x22\\x14\\x1b\\x1f\\x10\\x19\\x1c\"\n    b\"\\x0d\\x17\\x1a\\x0a\\x13\\x17\\x07\\x10\\x13\\x01\\x0d\\x0f\\x01\\x0a\\x0b\\x01\"\n    b\"\\x01\\x3f\\x01\\x13\\x3c\\x0b\\x1b\\x39\\x10\\x20\\x35\\x14\\x23\\x31\\x17\\x23\"\n    b\"\\x2d\\x18\\x23\\x29\\x18\\x3f\\x3f\\x3f\\x3f\\x3f\\x39\\x3f\\x3f\\x31\\x3f\\x3f\"\n    b\"\\x2a\\x3f\\x3f\\x20\\x3f\\x3f\\x14\\x3f\\x3c\\x12\\x3f\\x39\\x0f\\x3f\\x35\\x0b\"\n    b\"\\x3f\\x32\\x07\\x3f\\x2d\\x01\\x3d\\x2a\\x01\\x3b\\x26\\x01\\x39\\x21\\x01\\x37\"\n    b\"\\x1d\\x01\\x34\\x1a\\x01\\x32\\x16\\x01\\x2f\\x12\\x01\\x2d\\x0f\\x01\\x2a\\x0b\"\n    b\"\\x01\\x27\\x07\\x01\\x23\\x01\\x01\\x1d\\x01\\x01\\x17\\x01\\x01\\x10\\x01\\x01\"\n    b\"\\x3d\\x01\\x01\\x19\\x19\\x3f\\x3f\\x01\\x01\\x01\\x01\\x3f\\x16\\x16\\x13\\x10\"\n    b\"\\x10\\x0f\\x0d\\x0d\\x0b\\x3c\\x2e\\x2a\\x36\\x27\\x20\\x30\\x21\\x18\\x29\\x1b\"\n    b\"\\x10\\x3c\\x39\\x37\\x37\\x32\\x2f\\x31\\x2c\\x28\\x2b\\x26\\x21\\x30\\x22\\x20\"\n)\n", "src/PIL/DcxImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# DCX file handling\n#\n# DCX is a container file format defined by Intel, commonly used\n# for fax applications.  Each DCX file consists of a directory\n# (a list of file offsets) followed by a set of (usually 1-bit)\n# PCX files.\n#\n# History:\n# 1995-09-09 fl   Created\n# 1996-03-20 fl   Properly derived from PcxImageFile.\n# 1998-07-15 fl   Renamed offset attribute to avoid name clash\n# 2002-07-30 fl   Fixed file handling\n#\n# Copyright (c) 1997-98 by Secret Labs AB.\n# Copyright (c) 1995-96 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image\nfrom ._binary import i32le as i32\nfrom .PcxImagePlugin import PcxImageFile\n\nMAGIC = 0x3ADE68B1  # QUIZ: what's this value, then?\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 4 and i32(prefix) == MAGIC\n\n\n##\n# Image plugin for the Intel DCX format.\n\n\nclass DcxImageFile(PcxImageFile):\n    format = \"DCX\"\n    format_description = \"Intel DCX\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # Header\n        s = self.fp.read(4)\n        if not _accept(s):\n            msg = \"not a DCX file\"\n            raise SyntaxError(msg)\n\n        # Component directory\n        self._offset = []\n        for i in range(1024):\n            offset = i32(self.fp.read(4))\n            if not offset:\n                break\n            self._offset.append(offset)\n\n        self._fp = self.fp\n        self.frame = -1\n        self.n_frames = len(self._offset)\n        self.is_animated = self.n_frames > 1\n        self.seek(0)\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        self.frame = frame\n        self.fp = self._fp\n        self.fp.seek(self._offset[frame])\n        PcxImageFile._open(self)\n\n    def tell(self) -> int:\n        return self.frame\n\n\nImage.register_open(DcxImageFile.format, DcxImageFile, _accept)\n\nImage.register_extension(DcxImageFile.format, \".dcx\")\n", "src/PIL/XpmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# XPM File handling\n#\n# History:\n# 1996-12-29 fl   Created\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.7)\n#\n# Copyright (c) Secret Labs AB 1997-2001.\n# Copyright (c) Fredrik Lundh 1996-2001.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import o8\n\n# XPM header\nxpm_head = re.compile(b'\"([0-9]*) ([0-9]*) ([0-9]*) ([0-9]*)')\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:9] == b\"/* XPM */\"\n\n\n##\n# Image plugin for X11 pixel maps.\n\n\nclass XpmImageFile(ImageFile.ImageFile):\n    format = \"XPM\"\n    format_description = \"X11 Pixel Map\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(9)):\n            msg = \"not an XPM file\"\n            raise SyntaxError(msg)\n\n        # skip forward to next string\n        while True:\n            s = self.fp.readline()\n            if not s:\n                msg = \"broken XPM file\"\n                raise SyntaxError(msg)\n            m = xpm_head.match(s)\n            if m:\n                break\n\n        self._size = int(m.group(1)), int(m.group(2))\n\n        pal = int(m.group(3))\n        bpp = int(m.group(4))\n\n        if pal > 256 or bpp != 1:\n            msg = \"cannot read this XPM file\"\n            raise ValueError(msg)\n\n        #\n        # load palette description\n\n        palette = [b\"\\0\\0\\0\"] * 256\n\n        for _ in range(pal):\n            s = self.fp.readline()\n            if s[-2:] == b\"\\r\\n\":\n                s = s[:-2]\n            elif s[-1:] in b\"\\r\\n\":\n                s = s[:-1]\n\n            c = s[1]\n            s = s[2:-2].split()\n\n            for i in range(0, len(s), 2):\n                if s[i] == b\"c\":\n                    # process colour key\n                    rgb = s[i + 1]\n                    if rgb == b\"None\":\n                        self.info[\"transparency\"] = c\n                    elif rgb[:1] == b\"#\":\n                        # FIXME: handle colour names (see ImagePalette.py)\n                        rgb = int(rgb[1:], 16)\n                        palette[c] = (\n                            o8((rgb >> 16) & 255) + o8((rgb >> 8) & 255) + o8(rgb & 255)\n                        )\n                    else:\n                        # unknown colour\n                        msg = \"cannot read this XPM file\"\n                        raise ValueError(msg)\n                    break\n\n            else:\n                # missing colour key\n                msg = \"cannot read this XPM file\"\n                raise ValueError(msg)\n\n        self._mode = \"P\"\n        self.palette = ImagePalette.raw(\"RGB\", b\"\".join(palette))\n\n        self.tile = [(\"raw\", (0, 0) + self.size, self.fp.tell(), (\"P\", 0, 1))]\n\n    def load_read(self, read_bytes: int) -> bytes:\n        #\n        # load all image data in one chunk\n\n        xsize, ysize = self.size\n\n        s = [self.fp.readline()[1 : xsize + 1].ljust(xsize) for i in range(ysize)]\n\n        return b\"\".join(s)\n\n\n#\n# Registry\n\n\nImage.register_open(XpmImageFile.format, XpmImageFile, _accept)\n\nImage.register_extension(XpmImageFile.format, \".xpm\")\n\nImage.register_mime(XpmImageFile.format, \"image/xpm\")\n", "src/PIL/McIdasImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Basic McIdas support for PIL\n#\n# History:\n# 1997-05-05 fl  Created (8-bit images only)\n# 2009-03-08 fl  Added 16/32-bit support.\n#\n# Thanks to Richard Jones and Craig Swank for specs and samples.\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport struct\n\nfrom . import Image, ImageFile\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\"\n\n\n##\n# Image plugin for McIdas area images.\n\n\nclass McIdasImageFile(ImageFile.ImageFile):\n    format = \"MCIDAS\"\n    format_description = \"McIdas area file\"\n\n    def _open(self) -> None:\n        # parse area file directory\n        assert self.fp is not None\n\n        s = self.fp.read(256)\n        if not _accept(s) or len(s) != 256:\n            msg = \"not an McIdas area file\"\n            raise SyntaxError(msg)\n\n        self.area_descriptor_raw = s\n        self.area_descriptor = w = [0] + list(struct.unpack(\"!64i\", s))\n\n        # get mode\n        if w[11] == 1:\n            mode = rawmode = \"L\"\n        elif w[11] == 2:\n            # FIXME: add memory map support\n            mode = \"I\"\n            rawmode = \"I;16B\"\n        elif w[11] == 4:\n            # FIXME: add memory map support\n            mode = \"I\"\n            rawmode = \"I;32B\"\n        else:\n            msg = \"unsupported McIdas format\"\n            raise SyntaxError(msg)\n\n        self._mode = mode\n        self._size = w[10], w[9]\n\n        offset = w[34] + w[15]\n        stride = w[15] + w[10] * w[11] * w[14]\n\n        self.tile = [(\"raw\", (0, 0) + self.size, offset, (rawmode, stride, 1))]\n\n\n# --------------------------------------------------------------------\n# registry\n\nImage.register_open(McIdasImageFile.format, McIdasImageFile, _accept)\n\n# no default extension\n", "src/PIL/GribStubImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# GRIB stub adapter\n#\n# Copyright (c) 1996-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific GRIB image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\n# --------------------------------------------------------------------\n# Image adapter\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"GRIB\" and prefix[7] == 1\n\n\nclass GribStubImageFile(ImageFile.StubImageFile):\n    format = \"GRIB\"\n    format_description = \"GRIB\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        if not _accept(self.fp.read(8)):\n            msg = \"Not a GRIB file\"\n            raise SyntaxError(msg)\n\n        self.fp.seek(offset)\n\n        # make something up\n        self._mode = \"F\"\n        self._size = 1, 1\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"GRIB save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(GribStubImageFile.format, GribStubImageFile, _accept)\nImage.register_save(GribStubImageFile.format, _save)\n\nImage.register_extension(GribStubImageFile.format, \".grib\")\n", "src/PIL/ImageFile.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# base class for image file handlers\n#\n# history:\n# 1995-09-09 fl   Created\n# 1996-03-11 fl   Fixed load mechanism.\n# 1996-04-15 fl   Added pcx/xbm decoders.\n# 1996-04-30 fl   Added encoders.\n# 1996-12-14 fl   Added load helpers\n# 1997-01-11 fl   Use encode_to_file where possible\n# 1997-08-27 fl   Flush output in _save\n# 1998-03-05 fl   Use memory mapping for some modes\n# 1999-02-04 fl   Use memory mapping also for \"I;16\" and \"I;16B\"\n# 1999-05-31 fl   Added image parser\n# 2000-10-12 fl   Set readonly flag on memory-mapped images\n# 2002-03-20 fl   Use better messages for common decoder errors\n# 2003-04-21 fl   Fall back on mmap/map_buffer if map is not available\n# 2003-10-30 fl   Added StubImageFile class\n# 2004-02-25 fl   Made incremental parser more robust\n#\n# Copyright (c) 1997-2004 by Secret Labs AB\n# Copyright (c) 1995-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport abc\nimport io\nimport itertools\nimport struct\nimport sys\nfrom typing import IO, Any, NamedTuple\n\nfrom . import Image\nfrom ._deprecate import deprecate\nfrom ._util import is_path\n\nMAXBLOCK = 65536\n\nSAFEBLOCK = 1024 * 1024\n\nLOAD_TRUNCATED_IMAGES = False\n\"\"\"Whether or not to load truncated image files. User code may change this.\"\"\"\n\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}\n\"\"\"\nDict of known error codes returned from :meth:`.PyDecoder.decode`,\n:meth:`.PyEncoder.encode` :meth:`.PyEncoder.encode_to_pyfd` and\n:meth:`.PyEncoder.encode_to_file`.\n\"\"\"\n\n\n#\n# --------------------------------------------------------------------\n# Helpers\n\n\ndef _get_oserror(error, *, encoder):\n    try:\n        msg = Image.core.getcodecstatus(error)\n    except AttributeError:\n        msg = ERRORS.get(error)\n    if not msg:\n        msg = f\"{'encoder' if encoder else 'decoder'} error {error}\"\n    msg += f\" when {'writing' if encoder else 'reading'} image file\"\n    return OSError(msg)\n\n\ndef raise_oserror(error):\n    deprecate(\n        \"raise_oserror\",\n        12,\n        action=\"It is only useful for translating error codes returned by a codec's \"\n        \"decode() method, which ImageFile already does automatically.\",\n    )\n    raise _get_oserror(error, encoder=False)\n\n\ndef _tilesort(t):\n    # sort on offset\n    return t[2]\n\n\nclass _Tile(NamedTuple):\n    codec_name: str\n    extents: tuple[int, int, int, int]\n    offset: int\n    args: tuple[Any, ...] | str | None\n\n\n#\n# --------------------------------------------------------------------\n# ImageFile base class\n\n\nclass ImageFile(Image.Image):\n    \"\"\"Base class for image file format handlers.\"\"\"\n\n    def __init__(self, fp=None, filename=None):\n        super().__init__()\n\n        self._min_frame = 0\n\n        self.custom_mimetype = None\n\n        self.tile = None\n        \"\"\" A list of tile descriptors, or ``None`` \"\"\"\n\n        self.readonly = 1  # until we know better\n\n        self.decoderconfig = ()\n        self.decodermaxblock = MAXBLOCK\n\n        if is_path(fp):\n            # filename\n            self.fp = open(fp, \"rb\")\n            self.filename = fp\n            self._exclusive_fp = True\n        else:\n            # stream\n            self.fp = fp\n            self.filename = filename\n            # can be overridden\n            self._exclusive_fp = None\n\n        try:\n            try:\n                self._open()\n            except (\n                IndexError,  # end of data\n                TypeError,  # end of data (ord)\n                KeyError,  # unsupported mode\n                EOFError,  # got header but not the first frame\n                struct.error,\n            ) as v:\n                raise SyntaxError(v) from v\n\n            if not self.mode or self.size[0] <= 0 or self.size[1] <= 0:\n                msg = \"not identified by this driver\"\n                raise SyntaxError(msg)\n        except BaseException:\n            # close the file only if we have opened it this constructor\n            if self._exclusive_fp:\n                self.fp.close()\n            raise\n\n    def get_format_mimetype(self):\n        if self.custom_mimetype:\n            return self.custom_mimetype\n        if self.format is not None:\n            return Image.MIME.get(self.format.upper())\n\n    def __setstate__(self, state):\n        self.tile = []\n        super().__setstate__(state)\n\n    def verify(self) -> None:\n        \"\"\"Check file integrity\"\"\"\n\n        # raise exception if something's wrong.  must be called\n        # directly after open, and closes file when finished.\n        if self._exclusive_fp:\n            self.fp.close()\n        self.fp = None\n\n    def load(self):\n        \"\"\"Load image data based on tile list\"\"\"\n\n        if self.tile is None:\n            msg = \"cannot load this image\"\n            raise OSError(msg)\n\n        pixel = Image.Image.load(self)\n        if not self.tile:\n            return pixel\n\n        self.map = None\n        use_mmap = self.filename and len(self.tile) == 1\n        # As of pypy 2.1.0, memory mapping was failing here.\n        use_mmap = use_mmap and not hasattr(sys, \"pypy_version_info\")\n\n        readonly = 0\n\n        # look for read/seek overrides\n        try:\n            read = self.load_read\n            # don't use mmap if there are custom read/seek functions\n            use_mmap = False\n        except AttributeError:\n            read = self.fp.read\n\n        try:\n            seek = self.load_seek\n            use_mmap = False\n        except AttributeError:\n            seek = self.fp.seek\n\n        if use_mmap:\n            # try memory mapping\n            decoder_name, extents, offset, args = self.tile[0]\n            if isinstance(args, str):\n                args = (args, 0, 1)\n            if (\n                decoder_name == \"raw\"\n                and len(args) >= 3\n                and args[0] == self.mode\n                and args[0] in Image._MAPMODES\n            ):\n                try:\n                    # use mmap, if possible\n                    import mmap\n\n                    with open(self.filename) as fp:\n                        self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)\n                    if offset + self.size[1] * args[1] > self.map.size():\n                        msg = \"buffer is not large enough\"\n                        raise OSError(msg)\n                    self.im = Image.core.map_buffer(\n                        self.map, self.size, decoder_name, offset, args\n                    )\n                    readonly = 1\n                    # After trashing self.im,\n                    # we might need to reload the palette data.\n                    if self.palette:\n                        self.palette.dirty = 1\n                except (AttributeError, OSError, ImportError):\n                    self.map = None\n\n        self.load_prepare()\n        err_code = -3  # initialize to unknown error\n        if not self.map:\n            # sort tiles in file order\n            self.tile.sort(key=_tilesort)\n\n            try:\n                # FIXME: This is a hack to handle TIFF's JpegTables tag.\n                prefix = self.tile_prefix\n            except AttributeError:\n                prefix = b\"\"\n\n            # Remove consecutive duplicates that only differ by their offset\n            self.tile = [\n                list(tiles)[-1]\n                for _, tiles in itertools.groupby(\n                    self.tile, lambda tile: (tile[0], tile[1], tile[3])\n                )\n            ]\n            for decoder_name, extents, offset, args in self.tile:\n                seek(offset)\n                decoder = Image._getdecoder(\n                    self.mode, decoder_name, args, self.decoderconfig\n                )\n                try:\n                    decoder.setimage(self.im, extents)\n                    if decoder.pulls_fd:\n                        decoder.setfd(self.fp)\n                        err_code = decoder.decode(b\"\")[1]\n                    else:\n                        b = prefix\n                        while True:\n                            try:\n                                s = read(self.decodermaxblock)\n                            except (IndexError, struct.error) as e:\n                                # truncated png/gif\n                                if LOAD_TRUNCATED_IMAGES:\n                                    break\n                                else:\n                                    msg = \"image file is truncated\"\n                                    raise OSError(msg) from e\n\n                            if not s:  # truncated jpeg\n                                if LOAD_TRUNCATED_IMAGES:\n                                    break\n                                else:\n                                    msg = (\n                                        \"image file is truncated \"\n                                        f\"({len(b)} bytes not processed)\"\n                                    )\n                                    raise OSError(msg)\n\n                            b = b + s\n                            n, err_code = decoder.decode(b)\n                            if n < 0:\n                                break\n                            b = b[n:]\n                finally:\n                    # Need to cleanup here to prevent leaks\n                    decoder.cleanup()\n\n        self.tile = []\n        self.readonly = readonly\n\n        self.load_end()\n\n        if self._exclusive_fp and self._close_exclusive_fp_after_loading:\n            self.fp.close()\n        self.fp = None\n\n        if not self.map and not LOAD_TRUNCATED_IMAGES and err_code < 0:\n            # still raised if decoder fails to return anything\n            raise _get_oserror(err_code, encoder=False)\n\n        return Image.Image.load(self)\n\n    def load_prepare(self) -> None:\n        # create image memory if necessary\n        if not self.im or self.im.mode != self.mode or self.im.size != self.size:\n            self.im = Image.core.new(self.mode, self.size)\n        # create palette (optional)\n        if self.mode == \"P\":\n            Image.Image.load(self)\n\n    def load_end(self) -> None:\n        # may be overridden\n        pass\n\n    # may be defined for contained formats\n    # def load_seek(self, pos: int) -> None:\n    #     pass\n\n    # may be defined for blocked formats (e.g. PNG)\n    # def load_read(self, read_bytes: int) -> bytes:\n    #     pass\n\n    def _seek_check(self, frame):\n        if (\n            frame < self._min_frame\n            # Only check upper limit on frames if additional seek operations\n            # are not required to do so\n            or (\n                not (hasattr(self, \"_n_frames\") and self._n_frames is None)\n                and frame >= self.n_frames + self._min_frame\n            )\n        ):\n            msg = \"attempt to seek outside sequence\"\n            raise EOFError(msg)\n\n        return self.tell() != frame\n\n\nclass StubHandler:\n    def open(self, im: StubImageFile) -> None:\n        pass\n\n    @abc.abstractmethod\n    def load(self, im: StubImageFile) -> Image.Image:\n        pass\n\n\nclass StubImageFile(ImageFile):\n    \"\"\"\n    Base class for stub image loaders.\n\n    A stub loader is an image loader that can identify files of a\n    certain format, but relies on external code to load the file.\n    \"\"\"\n\n    def _open(self):\n        msg = \"StubImageFile subclass must implement _open\"\n        raise NotImplementedError(msg)\n\n    def load(self):\n        loader = self._load()\n        if loader is None:\n            msg = f\"cannot find loader for this {self.format} file\"\n            raise OSError(msg)\n        image = loader.load(self)\n        assert image is not None\n        # become the other object (!)\n        self.__class__ = image.__class__\n        self.__dict__ = image.__dict__\n        return image.load()\n\n    def _load(self):\n        \"\"\"(Hook) Find actual image loader.\"\"\"\n        msg = \"StubImageFile subclass must implement _load\"\n        raise NotImplementedError(msg)\n\n\nclass Parser:\n    \"\"\"\n    Incremental image parser.  This class implements the standard\n    feed/close consumer interface.\n    \"\"\"\n\n    incremental = None\n    image: Image.Image | None = None\n    data = None\n    decoder = None\n    offset = 0\n    finished = 0\n\n    def reset(self) -> None:\n        \"\"\"\n        (Consumer) Reset the parser.  Note that you can only call this\n        method immediately after you've created a parser; parser\n        instances cannot be reused.\n        \"\"\"\n        assert self.data is None, \"cannot reuse parsers\"\n\n    def feed(self, data):\n        \"\"\"\n        (Consumer) Feed data to the parser.\n\n        :param data: A string buffer.\n        :exception OSError: If the parser failed to parse the image file.\n        \"\"\"\n        # collect data\n\n        if self.finished:\n            return\n\n        if self.data is None:\n            self.data = data\n        else:\n            self.data = self.data + data\n\n        # parse what we have\n        if self.decoder:\n            if self.offset > 0:\n                # skip header\n                skip = min(len(self.data), self.offset)\n                self.data = self.data[skip:]\n                self.offset = self.offset - skip\n                if self.offset > 0 or not self.data:\n                    return\n\n            n, e = self.decoder.decode(self.data)\n\n            if n < 0:\n                # end of stream\n                self.data = None\n                self.finished = 1\n                if e < 0:\n                    # decoding error\n                    self.image = None\n                    raise _get_oserror(e, encoder=False)\n                else:\n                    # end of image\n                    return\n            self.data = self.data[n:]\n\n        elif self.image:\n            # if we end up here with no decoder, this file cannot\n            # be incrementally parsed.  wait until we've gotten all\n            # available data\n            pass\n\n        else:\n            # attempt to open this file\n            try:\n                with io.BytesIO(self.data) as fp:\n                    im = Image.open(fp)\n            except OSError:\n                pass  # not enough data\n            else:\n                flag = hasattr(im, \"load_seek\") or hasattr(im, \"load_read\")\n                if flag or len(im.tile) != 1:\n                    # custom load code, or multiple tiles\n                    self.decode = None\n                else:\n                    # initialize decoder\n                    im.load_prepare()\n                    d, e, o, a = im.tile[0]\n                    im.tile = []\n                    self.decoder = Image._getdecoder(im.mode, d, a, im.decoderconfig)\n                    self.decoder.setimage(im.im, e)\n\n                    # calculate decoder offset\n                    self.offset = o\n                    if self.offset <= len(self.data):\n                        self.data = self.data[self.offset :]\n                        self.offset = 0\n\n                self.image = im\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def close(self):\n        \"\"\"\n        (Consumer) Close the stream.\n\n        :returns: An image object.\n        :exception OSError: If the parser failed to parse the image file either\n                            because it cannot be identified or cannot be\n                            decoded.\n        \"\"\"\n        # finish decoding\n        if self.decoder:\n            # get rid of what's left in the buffers\n            self.feed(b\"\")\n            self.data = self.decoder = None\n            if not self.finished:\n                msg = \"image was incomplete\"\n                raise OSError(msg)\n        if not self.image:\n            msg = \"cannot parse this image\"\n            raise OSError(msg)\n        if self.data:\n            # incremental parsing not possible; reopen the file\n            # not that we have all data\n            with io.BytesIO(self.data) as fp:\n                try:\n                    self.image = Image.open(fp)\n                finally:\n                    self.image.load()\n        return self.image\n\n\n# --------------------------------------------------------------------\n\n\ndef _save(im, fp, tile, bufsize=0) -> None:\n    \"\"\"Helper to save image based on tile list\n\n    :param im: Image object.\n    :param fp: File object.\n    :param tile: Tile list.\n    :param bufsize: Optional buffer size\n    \"\"\"\n\n    im.load()\n    if not hasattr(im, \"encoderconfig\"):\n        im.encoderconfig = ()\n    tile.sort(key=_tilesort)\n    # FIXME: make MAXBLOCK a configuration parameter\n    # It would be great if we could have the encoder specify what it needs\n    # But, it would need at least the image size in most cases. RawEncode is\n    # a tricky case.\n    bufsize = max(MAXBLOCK, bufsize, im.size[0] * 4)  # see RawEncode.c\n    try:\n        fh = fp.fileno()\n        fp.flush()\n        _encode_tile(im, fp, tile, bufsize, fh)\n    except (AttributeError, io.UnsupportedOperation) as exc:\n        _encode_tile(im, fp, tile, bufsize, None, exc)\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\ndef _encode_tile(im, fp, tile: list[_Tile], bufsize, fh, exc=None):\n    for encoder_name, extents, offset, args in tile:\n        if offset > 0:\n            fp.seek(offset)\n        encoder = Image._getencoder(im.mode, encoder_name, args, im.encoderconfig)\n        try:\n            encoder.setimage(im.im, extents)\n            if encoder.pushes_fd:\n                encoder.setfd(fp)\n                errcode = encoder.encode_to_pyfd()[1]\n            else:\n                if exc:\n                    # compress to Python file-compatible object\n                    while True:\n                        errcode, data = encoder.encode(bufsize)[1:]\n                        fp.write(data)\n                        if errcode:\n                            break\n                else:\n                    # slight speedup: compress to real file object\n                    errcode = encoder.encode_to_file(fh, bufsize)\n            if errcode < 0:\n                raise _get_oserror(errcode, encoder=True) from exc\n        finally:\n            encoder.cleanup()\n\n\ndef _safe_read(fp, size):\n    \"\"\"\n    Reads large blocks in a safe way.  Unlike fp.read(n), this function\n    doesn't trust the user.  If the requested size is larger than\n    SAFEBLOCK, the file is read block by block.\n\n    :param fp: File handle.  Must implement a <b>read</b> method.\n    :param size: Number of bytes to read.\n    :returns: A string containing <i>size</i> bytes of data.\n\n    Raises an OSError if the file is truncated and the read cannot be completed\n\n    \"\"\"\n    if size <= 0:\n        return b\"\"\n    if size <= SAFEBLOCK:\n        data = fp.read(size)\n        if len(data) < size:\n            msg = \"Truncated File Read\"\n            raise OSError(msg)\n        return data\n    data = []\n    remaining_size = size\n    while remaining_size > 0:\n        block = fp.read(min(remaining_size, SAFEBLOCK))\n        if not block:\n            break\n        data.append(block)\n        remaining_size -= len(block)\n    if sum(len(d) for d in data) < size:\n        msg = \"Truncated File Read\"\n        raise OSError(msg)\n    return b\"\".join(data)\n\n\nclass PyCodecState:\n    def __init__(self) -> None:\n        self.xsize = 0\n        self.ysize = 0\n        self.xoff = 0\n        self.yoff = 0\n\n    def extents(self):\n        return self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize\n\n\nclass PyCodec:\n    fd: IO[bytes] | None\n\n    def __init__(self, mode, *args):\n        self.im = None\n        self.state = PyCodecState()\n        self.fd = None\n        self.mode = mode\n        self.init(args)\n\n    def init(self, args):\n        \"\"\"\n        Override to perform codec specific initialization\n\n        :param args: Array of args items from the tile entry\n        :returns: None\n        \"\"\"\n        self.args = args\n\n    def cleanup(self) -> None:\n        \"\"\"\n        Override to perform codec specific cleanup\n\n        :returns: None\n        \"\"\"\n        pass\n\n    def setfd(self, fd):\n        \"\"\"\n        Called from ImageFile to set the Python file-like object\n\n        :param fd: A Python file-like object\n        :returns: None\n        \"\"\"\n        self.fd = fd\n\n    def setimage(self, im, extents=None):\n        \"\"\"\n        Called from ImageFile to set the core output image for the codec\n\n        :param im: A core image object\n        :param extents: a 4 tuple of (x0, y0, x1, y1) defining the rectangle\n            for this tile\n        :returns: None\n        \"\"\"\n\n        # following c code\n        self.im = im\n\n        if extents:\n            (x0, y0, x1, y1) = extents\n        else:\n            (x0, y0, x1, y1) = (0, 0, 0, 0)\n\n        if x0 == 0 and x1 == 0:\n            self.state.xsize, self.state.ysize = self.im.size\n        else:\n            self.state.xoff = x0\n            self.state.yoff = y0\n            self.state.xsize = x1 - x0\n            self.state.ysize = y1 - y0\n\n        if self.state.xsize <= 0 or self.state.ysize <= 0:\n            msg = \"Size cannot be negative\"\n            raise ValueError(msg)\n\n        if (\n            self.state.xsize + self.state.xoff > self.im.size[0]\n            or self.state.ysize + self.state.yoff > self.im.size[1]\n        ):\n            msg = \"Tile cannot extend outside image\"\n            raise ValueError(msg)\n\n\nclass PyDecoder(PyCodec):\n    \"\"\"\n    Python implementation of a format decoder. Override this class and\n    add the decoding logic in the :meth:`decode` method.\n\n    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`\n    \"\"\"\n\n    _pulls_fd = False\n\n    @property\n    def pulls_fd(self):\n        return self._pulls_fd\n\n    def decode(self, buffer):\n        \"\"\"\n        Override to perform the decoding process.\n\n        :param buffer: A bytes object with the data to be decoded.\n        :returns: A tuple of ``(bytes consumed, errcode)``.\n            If finished with decoding return -1 for the bytes consumed.\n            Err codes are from :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        msg = \"unavailable in base decoder\"\n        raise NotImplementedError(msg)\n\n    def set_as_raw(self, data: bytes, rawmode=None) -> None:\n        \"\"\"\n        Convenience method to set the internal image from a stream of raw data\n\n        :param data: Bytes to be set\n        :param rawmode: The rawmode to be used for the decoder.\n            If not specified, it will default to the mode of the image\n        :returns: None\n        \"\"\"\n\n        if not rawmode:\n            rawmode = self.mode\n        d = Image._getdecoder(self.mode, \"raw\", rawmode)\n        d.setimage(self.im, self.state.extents())\n        s = d.decode(data)\n\n        if s[0] >= 0:\n            msg = \"not enough image data\"\n            raise ValueError(msg)\n        if s[1] != 0:\n            msg = \"cannot decode image data\"\n            raise ValueError(msg)\n\n\nclass PyEncoder(PyCodec):\n    \"\"\"\n    Python implementation of a format encoder. Override this class and\n    add the decoding logic in the :meth:`encode` method.\n\n    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`\n    \"\"\"\n\n    _pushes_fd = False\n\n    @property\n    def pushes_fd(self):\n        return self._pushes_fd\n\n    def encode(self, bufsize: int) -> tuple[int, int, bytes]:\n        \"\"\"\n        Override to perform the encoding process.\n\n        :param bufsize: Buffer size.\n        :returns: A tuple of ``(bytes encoded, errcode, bytes)``.\n            If finished with encoding return 1 for the error code.\n            Err codes are from :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        msg = \"unavailable in base encoder\"\n        raise NotImplementedError(msg)\n\n    def encode_to_pyfd(self):\n        \"\"\"\n        If ``pushes_fd`` is ``True``, then this method will be used,\n        and ``encode()`` will only be called once.\n\n        :returns: A tuple of ``(bytes consumed, errcode)``.\n            Err codes are from :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        if not self.pushes_fd:\n            return 0, -8  # bad configuration\n        bytes_consumed, errcode, data = self.encode(0)\n        if data:\n            self.fd.write(data)\n        return bytes_consumed, errcode\n\n    def encode_to_file(self, fh, bufsize):\n        \"\"\"\n        :param fh: File handle.\n        :param bufsize: Buffer size.\n\n        :returns: If finished successfully, return 0.\n            Otherwise, return an error code. Err codes are from\n            :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        errcode = 0\n        while errcode == 0:\n            status, errcode, buf = self.encode(bufsize)\n            if status > 0:\n                fh.write(buf[status:])\n        return errcode\n", "src/PIL/GimpGradientFile.py": "#\n# Python Imaging Library\n# $Id$\n#\n# stuff to read (and render) GIMP gradient files\n#\n# History:\n#       97-08-23 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nStuff to translate curve segments to palette values (derived from\nthe corresponding code in GIMP, written by Federico Mena Quintero.\nSee the GIMP distribution for more information.)\n\"\"\"\nfrom __future__ import annotations\n\nfrom math import log, pi, sin, sqrt\nfrom typing import IO, Callable\n\nfrom ._binary import o8\n\nEPSILON = 1e-10\n\"\"\"\"\"\"  # Enable auto-doc for data member\n\n\ndef linear(middle: float, pos: float) -> float:\n    if pos <= middle:\n        if middle < EPSILON:\n            return 0.0\n        else:\n            return 0.5 * pos / middle\n    else:\n        pos = pos - middle\n        middle = 1.0 - middle\n        if middle < EPSILON:\n            return 1.0\n        else:\n            return 0.5 + 0.5 * pos / middle\n\n\ndef curved(middle: float, pos: float) -> float:\n    return pos ** (log(0.5) / log(max(middle, EPSILON)))\n\n\ndef sine(middle: float, pos: float) -> float:\n    return (sin((-pi / 2.0) + pi * linear(middle, pos)) + 1.0) / 2.0\n\n\ndef sphere_increasing(middle: float, pos: float) -> float:\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\n\n\ndef sphere_decreasing(middle: float, pos: float) -> float:\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\n\n\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\n\"\"\"\"\"\"  # Enable auto-doc for data member\n\n\nclass GradientFile:\n    gradient: (\n        list[\n            tuple[\n                float,\n                float,\n                float,\n                list[float],\n                list[float],\n                Callable[[float, float], float],\n            ]\n        ]\n        | None\n    ) = None\n\n    def getpalette(self, entries: int = 256) -> tuple[bytes, str]:\n        assert self.gradient is not None\n        palette = []\n\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n\n        for i in range(entries):\n            x = i / (entries - 1)\n\n            while x1 < x:\n                ix += 1\n                x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n\n            w = x1 - x0\n\n            if w < EPSILON:\n                scale = segment(0.5, 0.5)\n            else:\n                scale = segment((xm - x0) / w, (x - x0) / w)\n\n            # expand to RGBA\n            r = o8(int(255 * ((rgb1[0] - rgb0[0]) * scale + rgb0[0]) + 0.5))\n            g = o8(int(255 * ((rgb1[1] - rgb0[1]) * scale + rgb0[1]) + 0.5))\n            b = o8(int(255 * ((rgb1[2] - rgb0[2]) * scale + rgb0[2]) + 0.5))\n            a = o8(int(255 * ((rgb1[3] - rgb0[3]) * scale + rgb0[3]) + 0.5))\n\n            # add to palette\n            palette.append(r + g + b + a)\n\n        return b\"\".join(palette), \"RGBA\"\n\n\nclass GimpGradientFile(GradientFile):\n    \"\"\"File handler for GIMP's gradient format.\"\"\"\n\n    def __init__(self, fp: IO[bytes]) -> None:\n        if fp.readline()[:13] != b\"GIMP Gradient\":\n            msg = \"not a GIMP gradient file\"\n            raise SyntaxError(msg)\n\n        line = fp.readline()\n\n        # GIMP 1.2 gradient files don't contain a name, but GIMP 1.3 files do\n        if line.startswith(b\"Name: \"):\n            line = fp.readline().strip()\n\n        count = int(line)\n\n        self.gradient = []\n\n        for i in range(count):\n            s = fp.readline().split()\n            w = [float(x) for x in s[:11]]\n\n            x0, x1 = w[0], w[2]\n            xm = w[1]\n            rgb0 = w[3:7]\n            rgb1 = w[7:11]\n\n            segment = SEGMENTS[int(s[11])]\n            cspace = int(s[12])\n\n            if cspace != 0:\n                msg = \"cannot handle HSV colour space\"\n                raise OSError(msg)\n\n            self.gradient.append((x0, x1, xm, rgb0, rgb1, segment))\n", "src/PIL/DdsImagePlugin.py": "\"\"\"\nA Pillow loader for .dds files (S3TC-compressed aka DXTC)\nJerome Leclanche <jerome@leclan.ch>\n\nDocumentation:\nhttps://web.archive.org/web/20170802060935/http://oss.sgi.com/projects/ogl-sample/registry/EXT/texture_compression_s3tc.txt\n\nThe contents of this file are hereby released in the public domain (CC0)\nFull text of the CC0 license:\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport struct\nimport sys\nfrom enum import IntEnum, IntFlag\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i32le as i32\nfrom ._binary import o8\nfrom ._binary import o32le as o32\n\n# Magic (\"DDS \")\nDDS_MAGIC = 0x20534444\n\n\n# DDS flags\nclass DDSD(IntFlag):\n    CAPS = 0x1\n    HEIGHT = 0x2\n    WIDTH = 0x4\n    PITCH = 0x8\n    PIXELFORMAT = 0x1000\n    MIPMAPCOUNT = 0x20000\n    LINEARSIZE = 0x80000\n    DEPTH = 0x800000\n\n\n# DDS caps\nclass DDSCAPS(IntFlag):\n    COMPLEX = 0x8\n    TEXTURE = 0x1000\n    MIPMAP = 0x400000\n\n\nclass DDSCAPS2(IntFlag):\n    CUBEMAP = 0x200\n    CUBEMAP_POSITIVEX = 0x400\n    CUBEMAP_NEGATIVEX = 0x800\n    CUBEMAP_POSITIVEY = 0x1000\n    CUBEMAP_NEGATIVEY = 0x2000\n    CUBEMAP_POSITIVEZ = 0x4000\n    CUBEMAP_NEGATIVEZ = 0x8000\n    VOLUME = 0x200000\n\n\n# Pixel Format\nclass DDPF(IntFlag):\n    ALPHAPIXELS = 0x1\n    ALPHA = 0x2\n    FOURCC = 0x4\n    PALETTEINDEXED8 = 0x20\n    RGB = 0x40\n    LUMINANCE = 0x20000\n\n\n# dxgiformat.h\nclass DXGI_FORMAT(IntEnum):\n    UNKNOWN = 0\n    R32G32B32A32_TYPELESS = 1\n    R32G32B32A32_FLOAT = 2\n    R32G32B32A32_UINT = 3\n    R32G32B32A32_SINT = 4\n    R32G32B32_TYPELESS = 5\n    R32G32B32_FLOAT = 6\n    R32G32B32_UINT = 7\n    R32G32B32_SINT = 8\n    R16G16B16A16_TYPELESS = 9\n    R16G16B16A16_FLOAT = 10\n    R16G16B16A16_UNORM = 11\n    R16G16B16A16_UINT = 12\n    R16G16B16A16_SNORM = 13\n    R16G16B16A16_SINT = 14\n    R32G32_TYPELESS = 15\n    R32G32_FLOAT = 16\n    R32G32_UINT = 17\n    R32G32_SINT = 18\n    R32G8X24_TYPELESS = 19\n    D32_FLOAT_S8X24_UINT = 20\n    R32_FLOAT_X8X24_TYPELESS = 21\n    X32_TYPELESS_G8X24_UINT = 22\n    R10G10B10A2_TYPELESS = 23\n    R10G10B10A2_UNORM = 24\n    R10G10B10A2_UINT = 25\n    R11G11B10_FLOAT = 26\n    R8G8B8A8_TYPELESS = 27\n    R8G8B8A8_UNORM = 28\n    R8G8B8A8_UNORM_SRGB = 29\n    R8G8B8A8_UINT = 30\n    R8G8B8A8_SNORM = 31\n    R8G8B8A8_SINT = 32\n    R16G16_TYPELESS = 33\n    R16G16_FLOAT = 34\n    R16G16_UNORM = 35\n    R16G16_UINT = 36\n    R16G16_SNORM = 37\n    R16G16_SINT = 38\n    R32_TYPELESS = 39\n    D32_FLOAT = 40\n    R32_FLOAT = 41\n    R32_UINT = 42\n    R32_SINT = 43\n    R24G8_TYPELESS = 44\n    D24_UNORM_S8_UINT = 45\n    R24_UNORM_X8_TYPELESS = 46\n    X24_TYPELESS_G8_UINT = 47\n    R8G8_TYPELESS = 48\n    R8G8_UNORM = 49\n    R8G8_UINT = 50\n    R8G8_SNORM = 51\n    R8G8_SINT = 52\n    R16_TYPELESS = 53\n    R16_FLOAT = 54\n    D16_UNORM = 55\n    R16_UNORM = 56\n    R16_UINT = 57\n    R16_SNORM = 58\n    R16_SINT = 59\n    R8_TYPELESS = 60\n    R8_UNORM = 61\n    R8_UINT = 62\n    R8_SNORM = 63\n    R8_SINT = 64\n    A8_UNORM = 65\n    R1_UNORM = 66\n    R9G9B9E5_SHAREDEXP = 67\n    R8G8_B8G8_UNORM = 68\n    G8R8_G8B8_UNORM = 69\n    BC1_TYPELESS = 70\n    BC1_UNORM = 71\n    BC1_UNORM_SRGB = 72\n    BC2_TYPELESS = 73\n    BC2_UNORM = 74\n    BC2_UNORM_SRGB = 75\n    BC3_TYPELESS = 76\n    BC3_UNORM = 77\n    BC3_UNORM_SRGB = 78\n    BC4_TYPELESS = 79\n    BC4_UNORM = 80\n    BC4_SNORM = 81\n    BC5_TYPELESS = 82\n    BC5_UNORM = 83\n    BC5_SNORM = 84\n    B5G6R5_UNORM = 85\n    B5G5R5A1_UNORM = 86\n    B8G8R8A8_UNORM = 87\n    B8G8R8X8_UNORM = 88\n    R10G10B10_XR_BIAS_A2_UNORM = 89\n    B8G8R8A8_TYPELESS = 90\n    B8G8R8A8_UNORM_SRGB = 91\n    B8G8R8X8_TYPELESS = 92\n    B8G8R8X8_UNORM_SRGB = 93\n    BC6H_TYPELESS = 94\n    BC6H_UF16 = 95\n    BC6H_SF16 = 96\n    BC7_TYPELESS = 97\n    BC7_UNORM = 98\n    BC7_UNORM_SRGB = 99\n    AYUV = 100\n    Y410 = 101\n    Y416 = 102\n    NV12 = 103\n    P010 = 104\n    P016 = 105\n    OPAQUE_420 = 106\n    YUY2 = 107\n    Y210 = 108\n    Y216 = 109\n    NV11 = 110\n    AI44 = 111\n    IA44 = 112\n    P8 = 113\n    A8P8 = 114\n    B4G4R4A4_UNORM = 115\n    P208 = 130\n    V208 = 131\n    V408 = 132\n    SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 189\n    SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 190\n\n\nclass D3DFMT(IntEnum):\n    UNKNOWN = 0\n    R8G8B8 = 20\n    A8R8G8B8 = 21\n    X8R8G8B8 = 22\n    R5G6B5 = 23\n    X1R5G5B5 = 24\n    A1R5G5B5 = 25\n    A4R4G4B4 = 26\n    R3G3B2 = 27\n    A8 = 28\n    A8R3G3B2 = 29\n    X4R4G4B4 = 30\n    A2B10G10R10 = 31\n    A8B8G8R8 = 32\n    X8B8G8R8 = 33\n    G16R16 = 34\n    A2R10G10B10 = 35\n    A16B16G16R16 = 36\n    A8P8 = 40\n    P8 = 41\n    L8 = 50\n    A8L8 = 51\n    A4L4 = 52\n    V8U8 = 60\n    L6V5U5 = 61\n    X8L8V8U8 = 62\n    Q8W8V8U8 = 63\n    V16U16 = 64\n    A2W10V10U10 = 67\n    D16_LOCKABLE = 70\n    D32 = 71\n    D15S1 = 73\n    D24S8 = 75\n    D24X8 = 77\n    D24X4S4 = 79\n    D16 = 80\n    D32F_LOCKABLE = 82\n    D24FS8 = 83\n    D32_LOCKABLE = 84\n    S8_LOCKABLE = 85\n    L16 = 81\n    VERTEXDATA = 100\n    INDEX16 = 101\n    INDEX32 = 102\n    Q16W16V16U16 = 110\n    R16F = 111\n    G16R16F = 112\n    A16B16G16R16F = 113\n    R32F = 114\n    G32R32F = 115\n    A32B32G32R32F = 116\n    CxV8U8 = 117\n    A1 = 118\n    A2B10G10R10_XR_BIAS = 119\n    BINARYBUFFER = 199\n\n    UYVY = i32(b\"UYVY\")\n    R8G8_B8G8 = i32(b\"RGBG\")\n    YUY2 = i32(b\"YUY2\")\n    G8R8_G8B8 = i32(b\"GRGB\")\n    DXT1 = i32(b\"DXT1\")\n    DXT2 = i32(b\"DXT2\")\n    DXT3 = i32(b\"DXT3\")\n    DXT4 = i32(b\"DXT4\")\n    DXT5 = i32(b\"DXT5\")\n    DX10 = i32(b\"DX10\")\n    BC4S = i32(b\"BC4S\")\n    BC4U = i32(b\"BC4U\")\n    BC5S = i32(b\"BC5S\")\n    BC5U = i32(b\"BC5U\")\n    ATI1 = i32(b\"ATI1\")\n    ATI2 = i32(b\"ATI2\")\n    MULTI2_ARGB8 = i32(b\"MET1\")\n\n\n# Backward compatibility layer\nmodule = sys.modules[__name__]\nfor item in DDSD:\n    assert item.name is not None\n    setattr(module, f\"DDSD_{item.name}\", item.value)\nfor item1 in DDSCAPS:\n    assert item1.name is not None\n    setattr(module, f\"DDSCAPS_{item1.name}\", item1.value)\nfor item2 in DDSCAPS2:\n    assert item2.name is not None\n    setattr(module, f\"DDSCAPS2_{item2.name}\", item2.value)\nfor item3 in DDPF:\n    assert item3.name is not None\n    setattr(module, f\"DDPF_{item3.name}\", item3.value)\n\nDDS_FOURCC = DDPF.FOURCC\nDDS_RGB = DDPF.RGB\nDDS_RGBA = DDPF.RGB | DDPF.ALPHAPIXELS\nDDS_LUMINANCE = DDPF.LUMINANCE\nDDS_LUMINANCEA = DDPF.LUMINANCE | DDPF.ALPHAPIXELS\nDDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\n\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\n\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\n\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\n\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\n\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\n\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\n\n\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"\n            raise SyntaxError(msg)\n        (header_size,) = struct.unpack(\"<I\", self.fp.read(4))\n        if header_size != 124:\n            msg = f\"Unsupported header size {repr(header_size)}\"\n            raise OSError(msg)\n        header_bytes = self.fp.read(header_size - 4)\n        if len(header_bytes) != 120:\n            msg = f\"Incomplete header: {len(header_bytes)} bytes\"\n            raise OSError(msg)\n        header = io.BytesIO(header_bytes)\n\n        flags, height, width = struct.unpack(\"<3I\", header.read(12))\n        self._size = (width, height)\n        extents = (0, 0) + self.size\n\n        pitch, depth, mipmaps = struct.unpack(\"<3I\", header.read(12))\n        struct.unpack(\"<11I\", header.read(44))  # reserved\n\n        # pixel format\n        pfsize, pfflags, fourcc, bitcount = struct.unpack(\"<4I\", header.read(16))\n        n = 0\n        rawmode = None\n        if pfflags & DDPF.RGB:\n            # Texture contains uncompressed RGB data\n            if pfflags & DDPF.ALPHAPIXELS:\n                self._mode = \"RGBA\"\n                mask_count = 4\n            else:\n                self._mode = \"RGB\"\n                mask_count = 3\n\n            masks = struct.unpack(f\"<{mask_count}I\", header.read(mask_count * 4))\n            self.tile = [(\"dds_rgb\", extents, 0, (bitcount, masks))]\n            return\n        elif pfflags & DDPF.LUMINANCE:\n            if bitcount == 8:\n                self._mode = \"L\"\n            elif bitcount == 16 and pfflags & DDPF.ALPHAPIXELS:\n                self._mode = \"LA\"\n            else:\n                msg = f\"Unsupported bitcount {bitcount} for {pfflags}\"\n                raise OSError(msg)\n        elif pfflags & DDPF.PALETTEINDEXED8:\n            self._mode = \"P\"\n            self.palette = ImagePalette.raw(\"RGBA\", self.fp.read(1024))\n            self.palette.mode = \"RGBA\"\n        elif pfflags & DDPF.FOURCC:\n            offset = header_size + 4\n            if fourcc == D3DFMT.DXT1:\n                self._mode = \"RGBA\"\n                self.pixel_format = \"DXT1\"\n                n = 1\n            elif fourcc == D3DFMT.DXT3:\n                self._mode = \"RGBA\"\n                self.pixel_format = \"DXT3\"\n                n = 2\n            elif fourcc == D3DFMT.DXT5:\n                self._mode = \"RGBA\"\n                self.pixel_format = \"DXT5\"\n                n = 3\n            elif fourcc in (D3DFMT.BC4U, D3DFMT.ATI1):\n                self._mode = \"L\"\n                self.pixel_format = \"BC4\"\n                n = 4\n            elif fourcc == D3DFMT.BC5S:\n                self._mode = \"RGB\"\n                self.pixel_format = \"BC5S\"\n                n = 5\n            elif fourcc in (D3DFMT.BC5U, D3DFMT.ATI2):\n                self._mode = \"RGB\"\n                self.pixel_format = \"BC5\"\n                n = 5\n            elif fourcc == D3DFMT.DX10:\n                offset += 20\n                # ignoring flags which pertain to volume textures and cubemaps\n                (dxgi_format,) = struct.unpack(\"<I\", self.fp.read(4))\n                self.fp.read(16)\n                if dxgi_format in (\n                    DXGI_FORMAT.BC1_UNORM,\n                    DXGI_FORMAT.BC1_TYPELESS,\n                ):\n                    self._mode = \"RGBA\"\n                    self.pixel_format = \"BC1\"\n                    n = 1\n                elif dxgi_format in (DXGI_FORMAT.BC4_TYPELESS, DXGI_FORMAT.BC4_UNORM):\n                    self._mode = \"L\"\n                    self.pixel_format = \"BC4\"\n                    n = 4\n                elif dxgi_format in (DXGI_FORMAT.BC5_TYPELESS, DXGI_FORMAT.BC5_UNORM):\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC5\"\n                    n = 5\n                elif dxgi_format == DXGI_FORMAT.BC5_SNORM:\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC5S\"\n                    n = 5\n                elif dxgi_format == DXGI_FORMAT.BC6H_UF16:\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC6H\"\n                    n = 6\n                elif dxgi_format == DXGI_FORMAT.BC6H_SF16:\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC6HS\"\n                    n = 6\n                elif dxgi_format in (\n                    DXGI_FORMAT.BC7_TYPELESS,\n                    DXGI_FORMAT.BC7_UNORM,\n                    DXGI_FORMAT.BC7_UNORM_SRGB,\n                ):\n                    self._mode = \"RGBA\"\n                    self.pixel_format = \"BC7\"\n                    n = 7\n                    if dxgi_format == DXGI_FORMAT.BC7_UNORM_SRGB:\n                        self.info[\"gamma\"] = 1 / 2.2\n                elif dxgi_format in (\n                    DXGI_FORMAT.R8G8B8A8_TYPELESS,\n                    DXGI_FORMAT.R8G8B8A8_UNORM,\n                    DXGI_FORMAT.R8G8B8A8_UNORM_SRGB,\n                ):\n                    self._mode = \"RGBA\"\n                    if dxgi_format == DXGI_FORMAT.R8G8B8A8_UNORM_SRGB:\n                        self.info[\"gamma\"] = 1 / 2.2\n                else:\n                    msg = f\"Unimplemented DXGI format {dxgi_format}\"\n                    raise NotImplementedError(msg)\n            else:\n                msg = f\"Unimplemented pixel format {repr(fourcc)}\"\n                raise NotImplementedError(msg)\n        else:\n            msg = f\"Unknown pixel format flags {pfflags}\"\n            raise NotImplementedError(msg)\n\n        if n:\n            self.tile = [\n                ImageFile._Tile(\"bcn\", extents, offset, (n, self.pixel_format))\n            ]\n        else:\n            self.tile = [ImageFile._Tile(\"raw\", extents, 0, rawmode or self.mode)]\n\n    def load_seek(self, pos: int) -> None:\n        pass\n\n\nclass DdsRgbDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        bitcount, masks = self.args\n\n        # Some masks will be padded with zeros, e.g. R 0b11 G 0b1100\n        # Calculate how many zeros each mask is padded with\n        mask_offsets = []\n        # And the maximum value of each channel without the padding\n        mask_totals = []\n        for mask in masks:\n            offset = 0\n            if mask != 0:\n                while mask >> (offset + 1) << (offset + 1) == mask:\n                    offset += 1\n            mask_offsets.append(offset)\n            mask_totals.append(mask >> offset)\n\n        data = bytearray()\n        bytecount = bitcount // 8\n        dest_length = self.state.xsize * self.state.ysize * len(masks)\n        while len(data) < dest_length:\n            value = int.from_bytes(self.fd.read(bytecount), \"little\")\n            for i, mask in enumerate(masks):\n                masked_value = value & mask\n                # Remove the zero padding, and scale it to 8 bits\n                data += o8(\n                    int(((masked_value >> mask_offsets[i]) / mask_totals[i]) * 255)\n                )\n        self.set_as_raw(data)\n        return -1, 0\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode not in (\"RGB\", \"RGBA\", \"L\", \"LA\"):\n        msg = f\"cannot write mode {im.mode} as DDS\"\n        raise OSError(msg)\n\n    alpha = im.mode[-1] == \"A\"\n    if im.mode[0] == \"L\":\n        pixel_flags = DDPF.LUMINANCE\n        rawmode = im.mode\n        if alpha:\n            rgba_mask = [0x000000FF, 0x000000FF, 0x000000FF]\n        else:\n            rgba_mask = [0xFF000000, 0xFF000000, 0xFF000000]\n    else:\n        pixel_flags = DDPF.RGB\n        rawmode = im.mode[::-1]\n        rgba_mask = [0x00FF0000, 0x0000FF00, 0x000000FF]\n\n        if alpha:\n            r, g, b, a = im.split()\n            im = Image.merge(\"RGBA\", (a, r, g, b))\n    if alpha:\n        pixel_flags |= DDPF.ALPHAPIXELS\n    rgba_mask.append(0xFF000000 if alpha else 0)\n\n    flags = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PITCH | DDSD.PIXELFORMAT\n    bitcount = len(im.getbands()) * 8\n    pitch = (im.width * bitcount + 7) // 8\n\n    fp.write(\n        o32(DDS_MAGIC)\n        + struct.pack(\n            \"<7I\",\n            124,  # header size\n            flags,  # flags\n            im.height,\n            im.width,\n            pitch,\n            0,  # depth\n            0,  # mipmaps\n        )\n        + struct.pack(\"11I\", *((0,) * 11))  # reserved\n        # pfsize, pfflags, fourcc, bitcount\n        + struct.pack(\"<4I\", 32, pixel_flags, 0, bitcount)\n        + struct.pack(\"<4I\", *rgba_mask)  # dwRGBABitMask\n        + struct.pack(\"<5I\", DDSCAPS.TEXTURE, 0, 0, 0, 0)\n    )\n    ImageFile._save(\n        im, fp, [ImageFile._Tile(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, 1))]\n    )\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"DDS \"\n\n\nImage.register_open(DdsImageFile.format, DdsImageFile, _accept)\nImage.register_decoder(\"dds_rgb\", DdsRgbDecoder)\nImage.register_save(DdsImageFile.format, _save)\nImage.register_extension(DdsImageFile.format, \".dds\")\n", "src/PIL/CurImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Windows Cursor support for PIL\n#\n# notes:\n#       uses BmpImagePlugin.py to read the bitmap data.\n#\n# history:\n#       96-05-27 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import BmpImagePlugin, Image\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\n\n#\n# --------------------------------------------------------------------\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"\\0\\0\\2\\0\"\n\n\n##\n# Image plugin for Windows Cursor files.\n\n\nclass CurImageFile(BmpImagePlugin.BmpImageFile):\n    format = \"CUR\"\n    format_description = \"Windows Cursor\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        # check magic\n        s = self.fp.read(6)\n        if not _accept(s):\n            msg = \"not a CUR file\"\n            raise SyntaxError(msg)\n\n        # pick the largest cursor in the file\n        m = b\"\"\n        for i in range(i16(s, 4)):\n            s = self.fp.read(16)\n            if not m:\n                m = s\n            elif s[0] > m[0] and s[1] > m[1]:\n                m = s\n        if not m:\n            msg = \"No cursors were found\"\n            raise TypeError(msg)\n\n        # load as bitmap\n        self._bitmap(i32(m, 12) + offset)\n\n        # patch up the bitmap height\n        self._size = self.size[0], self.size[1] // 2\n        d, e, o, a = self.tile[0]\n        self.tile[0] = d, (0, 0) + self.size, o, a\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(CurImageFile.format, CurImageFile, _accept)\n\nImage.register_extension(CurImageFile.format, \".cur\")\n", "src/PIL/ExifTags.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# EXIF tags\n#\n# Copyright (c) 2003 by Secret Labs AB\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nThis module provides constants and clear-text names for various\nwell-known EXIF tags.\n\"\"\"\nfrom __future__ import annotations\n\nfrom enum import IntEnum\n\n\nclass Base(IntEnum):\n    # possibly incomplete\n    InteropIndex = 0x0001\n    ProcessingSoftware = 0x000B\n    NewSubfileType = 0x00FE\n    SubfileType = 0x00FF\n    ImageWidth = 0x0100\n    ImageLength = 0x0101\n    BitsPerSample = 0x0102\n    Compression = 0x0103\n    PhotometricInterpretation = 0x0106\n    Thresholding = 0x0107\n    CellWidth = 0x0108\n    CellLength = 0x0109\n    FillOrder = 0x010A\n    DocumentName = 0x010D\n    ImageDescription = 0x010E\n    Make = 0x010F\n    Model = 0x0110\n    StripOffsets = 0x0111\n    Orientation = 0x0112\n    SamplesPerPixel = 0x0115\n    RowsPerStrip = 0x0116\n    StripByteCounts = 0x0117\n    MinSampleValue = 0x0118\n    MaxSampleValue = 0x0119\n    XResolution = 0x011A\n    YResolution = 0x011B\n    PlanarConfiguration = 0x011C\n    PageName = 0x011D\n    FreeOffsets = 0x0120\n    FreeByteCounts = 0x0121\n    GrayResponseUnit = 0x0122\n    GrayResponseCurve = 0x0123\n    T4Options = 0x0124\n    T6Options = 0x0125\n    ResolutionUnit = 0x0128\n    PageNumber = 0x0129\n    TransferFunction = 0x012D\n    Software = 0x0131\n    DateTime = 0x0132\n    Artist = 0x013B\n    HostComputer = 0x013C\n    Predictor = 0x013D\n    WhitePoint = 0x013E\n    PrimaryChromaticities = 0x013F\n    ColorMap = 0x0140\n    HalftoneHints = 0x0141\n    TileWidth = 0x0142\n    TileLength = 0x0143\n    TileOffsets = 0x0144\n    TileByteCounts = 0x0145\n    SubIFDs = 0x014A\n    InkSet = 0x014C\n    InkNames = 0x014D\n    NumberOfInks = 0x014E\n    DotRange = 0x0150\n    TargetPrinter = 0x0151\n    ExtraSamples = 0x0152\n    SampleFormat = 0x0153\n    SMinSampleValue = 0x0154\n    SMaxSampleValue = 0x0155\n    TransferRange = 0x0156\n    ClipPath = 0x0157\n    XClipPathUnits = 0x0158\n    YClipPathUnits = 0x0159\n    Indexed = 0x015A\n    JPEGTables = 0x015B\n    OPIProxy = 0x015F\n    JPEGProc = 0x0200\n    JpegIFOffset = 0x0201\n    JpegIFByteCount = 0x0202\n    JpegRestartInterval = 0x0203\n    JpegLosslessPredictors = 0x0205\n    JpegPointTransforms = 0x0206\n    JpegQTables = 0x0207\n    JpegDCTables = 0x0208\n    JpegACTables = 0x0209\n    YCbCrCoefficients = 0x0211\n    YCbCrSubSampling = 0x0212\n    YCbCrPositioning = 0x0213\n    ReferenceBlackWhite = 0x0214\n    XMLPacket = 0x02BC\n    RelatedImageFileFormat = 0x1000\n    RelatedImageWidth = 0x1001\n    RelatedImageLength = 0x1002\n    Rating = 0x4746\n    RatingPercent = 0x4749\n    ImageID = 0x800D\n    CFARepeatPatternDim = 0x828D\n    BatteryLevel = 0x828F\n    Copyright = 0x8298\n    ExposureTime = 0x829A\n    FNumber = 0x829D\n    IPTCNAA = 0x83BB\n    ImageResources = 0x8649\n    ExifOffset = 0x8769\n    InterColorProfile = 0x8773\n    ExposureProgram = 0x8822\n    SpectralSensitivity = 0x8824\n    GPSInfo = 0x8825\n    ISOSpeedRatings = 0x8827\n    OECF = 0x8828\n    Interlace = 0x8829\n    TimeZoneOffset = 0x882A\n    SelfTimerMode = 0x882B\n    SensitivityType = 0x8830\n    StandardOutputSensitivity = 0x8831\n    RecommendedExposureIndex = 0x8832\n    ISOSpeed = 0x8833\n    ISOSpeedLatitudeyyy = 0x8834\n    ISOSpeedLatitudezzz = 0x8835\n    ExifVersion = 0x9000\n    DateTimeOriginal = 0x9003\n    DateTimeDigitized = 0x9004\n    OffsetTime = 0x9010\n    OffsetTimeOriginal = 0x9011\n    OffsetTimeDigitized = 0x9012\n    ComponentsConfiguration = 0x9101\n    CompressedBitsPerPixel = 0x9102\n    ShutterSpeedValue = 0x9201\n    ApertureValue = 0x9202\n    BrightnessValue = 0x9203\n    ExposureBiasValue = 0x9204\n    MaxApertureValue = 0x9205\n    SubjectDistance = 0x9206\n    MeteringMode = 0x9207\n    LightSource = 0x9208\n    Flash = 0x9209\n    FocalLength = 0x920A\n    Noise = 0x920D\n    ImageNumber = 0x9211\n    SecurityClassification = 0x9212\n    ImageHistory = 0x9213\n    TIFFEPStandardID = 0x9216\n    MakerNote = 0x927C\n    UserComment = 0x9286\n    SubsecTime = 0x9290\n    SubsecTimeOriginal = 0x9291\n    SubsecTimeDigitized = 0x9292\n    AmbientTemperature = 0x9400\n    Humidity = 0x9401\n    Pressure = 0x9402\n    WaterDepth = 0x9403\n    Acceleration = 0x9404\n    CameraElevationAngle = 0x9405\n    XPTitle = 0x9C9B\n    XPComment = 0x9C9C\n    XPAuthor = 0x9C9D\n    XPKeywords = 0x9C9E\n    XPSubject = 0x9C9F\n    FlashPixVersion = 0xA000\n    ColorSpace = 0xA001\n    ExifImageWidth = 0xA002\n    ExifImageHeight = 0xA003\n    RelatedSoundFile = 0xA004\n    ExifInteroperabilityOffset = 0xA005\n    FlashEnergy = 0xA20B\n    SpatialFrequencyResponse = 0xA20C\n    FocalPlaneXResolution = 0xA20E\n    FocalPlaneYResolution = 0xA20F\n    FocalPlaneResolutionUnit = 0xA210\n    SubjectLocation = 0xA214\n    ExposureIndex = 0xA215\n    SensingMethod = 0xA217\n    FileSource = 0xA300\n    SceneType = 0xA301\n    CFAPattern = 0xA302\n    CustomRendered = 0xA401\n    ExposureMode = 0xA402\n    WhiteBalance = 0xA403\n    DigitalZoomRatio = 0xA404\n    FocalLengthIn35mmFilm = 0xA405\n    SceneCaptureType = 0xA406\n    GainControl = 0xA407\n    Contrast = 0xA408\n    Saturation = 0xA409\n    Sharpness = 0xA40A\n    DeviceSettingDescription = 0xA40B\n    SubjectDistanceRange = 0xA40C\n    ImageUniqueID = 0xA420\n    CameraOwnerName = 0xA430\n    BodySerialNumber = 0xA431\n    LensSpecification = 0xA432\n    LensMake = 0xA433\n    LensModel = 0xA434\n    LensSerialNumber = 0xA435\n    CompositeImage = 0xA460\n    CompositeImageCount = 0xA461\n    CompositeImageExposureTimes = 0xA462\n    Gamma = 0xA500\n    PrintImageMatching = 0xC4A5\n    DNGVersion = 0xC612\n    DNGBackwardVersion = 0xC613\n    UniqueCameraModel = 0xC614\n    LocalizedCameraModel = 0xC615\n    CFAPlaneColor = 0xC616\n    CFALayout = 0xC617\n    LinearizationTable = 0xC618\n    BlackLevelRepeatDim = 0xC619\n    BlackLevel = 0xC61A\n    BlackLevelDeltaH = 0xC61B\n    BlackLevelDeltaV = 0xC61C\n    WhiteLevel = 0xC61D\n    DefaultScale = 0xC61E\n    DefaultCropOrigin = 0xC61F\n    DefaultCropSize = 0xC620\n    ColorMatrix1 = 0xC621\n    ColorMatrix2 = 0xC622\n    CameraCalibration1 = 0xC623\n    CameraCalibration2 = 0xC624\n    ReductionMatrix1 = 0xC625\n    ReductionMatrix2 = 0xC626\n    AnalogBalance = 0xC627\n    AsShotNeutral = 0xC628\n    AsShotWhiteXY = 0xC629\n    BaselineExposure = 0xC62A\n    BaselineNoise = 0xC62B\n    BaselineSharpness = 0xC62C\n    BayerGreenSplit = 0xC62D\n    LinearResponseLimit = 0xC62E\n    CameraSerialNumber = 0xC62F\n    LensInfo = 0xC630\n    ChromaBlurRadius = 0xC631\n    AntiAliasStrength = 0xC632\n    ShadowScale = 0xC633\n    DNGPrivateData = 0xC634\n    MakerNoteSafety = 0xC635\n    CalibrationIlluminant1 = 0xC65A\n    CalibrationIlluminant2 = 0xC65B\n    BestQualityScale = 0xC65C\n    RawDataUniqueID = 0xC65D\n    OriginalRawFileName = 0xC68B\n    OriginalRawFileData = 0xC68C\n    ActiveArea = 0xC68D\n    MaskedAreas = 0xC68E\n    AsShotICCProfile = 0xC68F\n    AsShotPreProfileMatrix = 0xC690\n    CurrentICCProfile = 0xC691\n    CurrentPreProfileMatrix = 0xC692\n    ColorimetricReference = 0xC6BF\n    CameraCalibrationSignature = 0xC6F3\n    ProfileCalibrationSignature = 0xC6F4\n    AsShotProfileName = 0xC6F6\n    NoiseReductionApplied = 0xC6F7\n    ProfileName = 0xC6F8\n    ProfileHueSatMapDims = 0xC6F9\n    ProfileHueSatMapData1 = 0xC6FA\n    ProfileHueSatMapData2 = 0xC6FB\n    ProfileToneCurve = 0xC6FC\n    ProfileEmbedPolicy = 0xC6FD\n    ProfileCopyright = 0xC6FE\n    ForwardMatrix1 = 0xC714\n    ForwardMatrix2 = 0xC715\n    PreviewApplicationName = 0xC716\n    PreviewApplicationVersion = 0xC717\n    PreviewSettingsName = 0xC718\n    PreviewSettingsDigest = 0xC719\n    PreviewColorSpace = 0xC71A\n    PreviewDateTime = 0xC71B\n    RawImageDigest = 0xC71C\n    OriginalRawFileDigest = 0xC71D\n    SubTileBlockSize = 0xC71E\n    RowInterleaveFactor = 0xC71F\n    ProfileLookTableDims = 0xC725\n    ProfileLookTableData = 0xC726\n    OpcodeList1 = 0xC740\n    OpcodeList2 = 0xC741\n    OpcodeList3 = 0xC74E\n    NoiseProfile = 0xC761\n\n\n\"\"\"Maps EXIF tags to tag names.\"\"\"\nTAGS = {\n    **{i.value: i.name for i in Base},\n    0x920C: \"SpatialFrequencyResponse\",\n    0x9214: \"SubjectLocation\",\n    0x9215: \"ExposureIndex\",\n    0x828E: \"CFAPattern\",\n    0x920B: \"FlashEnergy\",\n    0x9216: \"TIFF/EPStandardID\",\n}\n\n\nclass GPS(IntEnum):\n    GPSVersionID = 0\n    GPSLatitudeRef = 1\n    GPSLatitude = 2\n    GPSLongitudeRef = 3\n    GPSLongitude = 4\n    GPSAltitudeRef = 5\n    GPSAltitude = 6\n    GPSTimeStamp = 7\n    GPSSatellites = 8\n    GPSStatus = 9\n    GPSMeasureMode = 10\n    GPSDOP = 11\n    GPSSpeedRef = 12\n    GPSSpeed = 13\n    GPSTrackRef = 14\n    GPSTrack = 15\n    GPSImgDirectionRef = 16\n    GPSImgDirection = 17\n    GPSMapDatum = 18\n    GPSDestLatitudeRef = 19\n    GPSDestLatitude = 20\n    GPSDestLongitudeRef = 21\n    GPSDestLongitude = 22\n    GPSDestBearingRef = 23\n    GPSDestBearing = 24\n    GPSDestDistanceRef = 25\n    GPSDestDistance = 26\n    GPSProcessingMethod = 27\n    GPSAreaInformation = 28\n    GPSDateStamp = 29\n    GPSDifferential = 30\n    GPSHPositioningError = 31\n\n\n\"\"\"Maps EXIF GPS tags to tag names.\"\"\"\nGPSTAGS = {i.value: i.name for i in GPS}\n\n\nclass Interop(IntEnum):\n    InteropIndex = 1\n    InteropVersion = 2\n    RelatedImageFileFormat = 4096\n    RelatedImageWidth = 4097\n    RelatedImageHeight = 4098\n\n\nclass IFD(IntEnum):\n    Exif = 34665\n    GPSInfo = 34853\n    Makernote = 37500\n    Interop = 40965\n    IFD1 = -1\n\n\nclass LightSource(IntEnum):\n    Unknown = 0\n    Daylight = 1\n    Fluorescent = 2\n    Tungsten = 3\n    Flash = 4\n    Fine = 9\n    Cloudy = 10\n    Shade = 11\n    DaylightFluorescent = 12\n    DayWhiteFluorescent = 13\n    CoolWhiteFluorescent = 14\n    WhiteFluorescent = 15\n    StandardLightA = 17\n    StandardLightB = 18\n    StandardLightC = 19\n    D55 = 20\n    D65 = 21\n    D75 = 22\n    D50 = 23\n    ISO = 24\n    Other = 255\n", "src/PIL/FpxImagePlugin.py": "#\n# THIS IS WORK IN PROGRESS\n#\n# The Python Imaging Library.\n# $Id$\n#\n# FlashPix support for PIL\n#\n# History:\n# 97-01-25 fl   Created (reads uncompressed RGB images only)\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport olefile\n\nfrom . import Image, ImageFile\nfrom ._binary import i32le as i32\n\n# we map from colour field tuples to (mode, rawmode) descriptors\nMODES = {\n    # opacity\n    (0x00007FFE,): (\"A\", \"L\"),\n    # monochrome\n    (0x00010000,): (\"L\", \"L\"),\n    (0x00018000, 0x00017FFE): (\"RGBA\", \"LA\"),\n    # photo YCC\n    (0x00020000, 0x00020001, 0x00020002): (\"RGB\", \"YCC;P\"),\n    (0x00028000, 0x00028001, 0x00028002, 0x00027FFE): (\"RGBA\", \"YCCA;P\"),\n    # standard RGB (NIFRGB)\n    (0x00030000, 0x00030001, 0x00030002): (\"RGB\", \"RGB\"),\n    (0x00038000, 0x00038001, 0x00038002, 0x00037FFE): (\"RGBA\", \"RGBA\"),\n}\n\n\n#\n# --------------------------------------------------------------------\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == olefile.MAGIC\n\n\n##\n# Image plugin for the FlashPix images.\n\n\nclass FpxImageFile(ImageFile.ImageFile):\n    format = \"FPX\"\n    format_description = \"FlashPix\"\n\n    def _open(self):\n        #\n        # read the OLE directory and see if this is a likely\n        # to be a FlashPix file\n\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except OSError as e:\n            msg = \"not an FPX file; invalid OLE file\"\n            raise SyntaxError(msg) from e\n\n        if self.ole.root.clsid != \"56616700-C154-11CE-8553-00AA00A1F95B\":\n            msg = \"not an FPX file; bad root CLSID\"\n            raise SyntaxError(msg)\n\n        self._open_index(1)\n\n    def _open_index(self, index: int = 1) -> None:\n        #\n        # get the Image Contents Property Set\n\n        prop = self.ole.getproperties(\n            [f\"Data Object Store {index:06d}\", \"\\005Image Contents\"]\n        )\n\n        # size (highest resolution)\n\n        self._size = prop[0x1000002], prop[0x1000003]\n\n        size = max(self.size)\n        i = 1\n        while size > 64:\n            size = size // 2\n            i += 1\n        self.maxid = i - 1\n\n        # mode.  instead of using a single field for this, flashpix\n        # requires you to specify the mode for each channel in each\n        # resolution subimage, and leaves it to the decoder to make\n        # sure that they all match.  for now, we'll cheat and assume\n        # that this is always the case.\n\n        id = self.maxid << 16\n\n        s = prop[0x2000002 | id]\n\n        bands = i32(s, 4)\n        if bands > 4:\n            msg = \"Invalid number of bands\"\n            raise OSError(msg)\n\n        # note: for now, we ignore the \"uncalibrated\" flag\n        colors = tuple(i32(s, 8 + i * 4) & 0x7FFFFFFF for i in range(bands))\n\n        self._mode, self.rawmode = MODES[colors]\n\n        # load JPEG tables, if any\n        self.jpeg = {}\n        for i in range(256):\n            id = 0x3000001 | (i << 16)\n            if id in prop:\n                self.jpeg[i] = prop[id]\n\n        self._open_subimage(1, self.maxid)\n\n    def _open_subimage(self, index: int = 1, subimage: int = 0) -> None:\n        #\n        # setup tile descriptors for a given subimage\n\n        stream = [\n            f\"Data Object Store {index:06d}\",\n            f\"Resolution {subimage:04d}\",\n            \"Subimage 0000 Header\",\n        ]\n\n        fp = self.ole.openstream(stream)\n\n        # skip prefix\n        fp.read(28)\n\n        # header stream\n        s = fp.read(36)\n\n        size = i32(s, 4), i32(s, 8)\n        # tilecount = i32(s, 12)\n        tilesize = i32(s, 16), i32(s, 20)\n        # channels = i32(s, 24)\n        offset = i32(s, 28)\n        length = i32(s, 32)\n\n        if size != self.size:\n            msg = \"subimage mismatch\"\n            raise OSError(msg)\n\n        # get tile descriptors\n        fp.seek(28 + offset)\n        s = fp.read(i32(s, 12) * length)\n\n        x = y = 0\n        xsize, ysize = size\n        xtile, ytile = tilesize\n        self.tile = []\n\n        for i in range(0, len(s), length):\n            x1 = min(xsize, x + xtile)\n            y1 = min(ysize, y + ytile)\n\n            compression = i32(s, i + 8)\n\n            if compression == 0:\n                self.tile.append(\n                    (\n                        \"raw\",\n                        (x, y, x1, y1),\n                        i32(s, i) + 28,\n                        (self.rawmode,),\n                    )\n                )\n\n            elif compression == 1:\n                # FIXME: the fill decoder is not implemented\n                self.tile.append(\n                    (\n                        \"fill\",\n                        (x, y, x1, y1),\n                        i32(s, i) + 28,\n                        (self.rawmode, s[12:16]),\n                    )\n                )\n\n            elif compression == 2:\n                internal_color_conversion = s[14]\n                jpeg_tables = s[15]\n                rawmode = self.rawmode\n\n                if internal_color_conversion:\n                    # The image is stored as usual (usually YCbCr).\n                    if rawmode == \"RGBA\":\n                        # For \"RGBA\", data is stored as YCbCrA based on\n                        # negative RGB. The following trick works around\n                        # this problem :\n                        jpegmode, rawmode = \"YCbCrK\", \"CMYK\"\n                    else:\n                        jpegmode = None  # let the decoder decide\n\n                else:\n                    # The image is stored as defined by rawmode\n                    jpegmode = rawmode\n\n                self.tile.append(\n                    (\n                        \"jpeg\",\n                        (x, y, x1, y1),\n                        i32(s, i) + 28,\n                        (rawmode, jpegmode),\n                    )\n                )\n\n                # FIXME: jpeg tables are tile dependent; the prefix\n                # data must be placed in the tile descriptor itself!\n\n                if jpeg_tables:\n                    self.tile_prefix = self.jpeg[jpeg_tables]\n\n            else:\n                msg = \"unknown/invalid compression\"\n                raise OSError(msg)\n\n            x = x + xtile\n            if x >= xsize:\n                x, y = 0, y + ytile\n                if y >= ysize:\n                    break  # isn't really required\n\n        self.stream = stream\n        self._fp = self.fp\n        self.fp = None\n\n    def load(self):\n        if not self.fp:\n            self.fp = self.ole.openstream(self.stream[:2] + [\"Subimage 0000 Data\"])\n\n        return ImageFile.ImageFile.load(self)\n\n    def close(self) -> None:\n        self.ole.close()\n        super().close()\n\n    def __exit__(self, *args: object) -> None:\n        self.ole.close()\n        super().__exit__()\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_open(FpxImageFile.format, FpxImageFile, _accept)\n\nImage.register_extension(FpxImageFile.format, \".fpx\")\n", "src/PIL/FontFile.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# base class for raster font file parsers\n#\n# history:\n# 1997-06-05 fl   created\n# 1997-08-19 fl   restrict image width\n#\n# Copyright (c) 1997-1998 by Secret Labs AB\n# Copyright (c) 1997-1998 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nfrom typing import BinaryIO\n\nfrom . import Image, _binary\n\nWIDTH = 800\n\n\ndef puti16(\n    fp: BinaryIO, values: tuple[int, int, int, int, int, int, int, int, int, int]\n) -> None:\n    \"\"\"Write network order (big-endian) 16-bit sequence\"\"\"\n    for v in values:\n        if v < 0:\n            v += 65536\n        fp.write(_binary.o16be(v))\n\n\nclass FontFile:\n    \"\"\"Base class for raster font file handlers.\"\"\"\n\n    bitmap: Image.Image | None = None\n\n    def __init__(self) -> None:\n        self.info: dict[bytes, bytes | int] = {}\n        self.glyph: list[\n            tuple[\n                tuple[int, int],\n                tuple[int, int, int, int],\n                tuple[int, int, int, int],\n                Image.Image,\n            ]\n            | None\n        ] = [None] * 256\n\n    def __getitem__(self, ix: int) -> (\n        tuple[\n            tuple[int, int],\n            tuple[int, int, int, int],\n            tuple[int, int, int, int],\n            Image.Image,\n        ]\n        | None\n    ):\n        return self.glyph[ix]\n\n    def compile(self) -> None:\n        \"\"\"Create metrics and bitmap\"\"\"\n\n        if self.bitmap:\n            return\n\n        # create bitmap large enough to hold all data\n        h = w = maxwidth = 0\n        lines = 1\n        for glyph in self.glyph:\n            if glyph:\n                d, dst, src, im = glyph\n                h = max(h, src[3] - src[1])\n                w = w + (src[2] - src[0])\n                if w > WIDTH:\n                    lines += 1\n                    w = src[2] - src[0]\n                maxwidth = max(maxwidth, w)\n\n        xsize = maxwidth\n        ysize = lines * h\n\n        if xsize == 0 and ysize == 0:\n            return\n\n        self.ysize = h\n\n        # paste glyphs into bitmap\n        self.bitmap = Image.new(\"1\", (xsize, ysize))\n        self.metrics: list[\n            tuple[tuple[int, int], tuple[int, int, int, int], tuple[int, int, int, int]]\n            | None\n        ] = [None] * 256\n        x = y = 0\n        for i in range(256):\n            glyph = self[i]\n            if glyph:\n                d, dst, src, im = glyph\n                xx = src[2] - src[0]\n                x0, y0 = x, y\n                x = x + xx\n                if x > WIDTH:\n                    x, y = 0, y + h\n                    x0, y0 = x, y\n                    x = xx\n                s = src[0] + x0, src[1] + y0, src[2] + x0, src[3] + y0\n                self.bitmap.paste(im.crop(src), s)\n                self.metrics[i] = d, dst, s\n\n    def save(self, filename: str) -> None:\n        \"\"\"Save font\"\"\"\n\n        self.compile()\n\n        # font data\n        if not self.bitmap:\n            msg = \"No bitmap created\"\n            raise ValueError(msg)\n        self.bitmap.save(os.path.splitext(filename)[0] + \".pbm\", \"PNG\")\n\n        # font metrics\n        with open(os.path.splitext(filename)[0] + \".pil\", \"wb\") as fp:\n            fp.write(b\"PILfont\\n\")\n            fp.write(f\";;;;;;{self.ysize};\\n\".encode(\"ascii\"))  # HACK!!!\n            fp.write(b\"DATA\\n\")\n            for id in range(256):\n                m = self.metrics[id]\n                if not m:\n                    puti16(fp, (0,) * 10)\n                else:\n                    puti16(fp, m[0] + m[1] + m[2])\n", "src/PIL/ImageDraw2.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# WCK-style drawing interface operations\n#\n# History:\n# 2003-12-07 fl   created\n# 2005-05-15 fl   updated; added to PIL as ImageDraw2\n# 2005-05-15 fl   added text support\n# 2005-05-20 fl   added arc/chord/pieslice support\n#\n# Copyright (c) 2003-2005 by Secret Labs AB\n# Copyright (c) 2003-2005 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\n\n\"\"\"\n(Experimental) WCK-style drawing interface operations\n\n.. seealso:: :py:mod:`PIL.ImageDraw`\n\"\"\"\nfrom __future__ import annotations\n\nfrom . import Image, ImageColor, ImageDraw, ImageFont, ImagePath\n\n\nclass Pen:\n    \"\"\"Stores an outline color and width.\"\"\"\n\n    def __init__(self, color: str, width: int = 1, opacity: int = 255) -> None:\n        self.color = ImageColor.getrgb(color)\n        self.width = width\n\n\nclass Brush:\n    \"\"\"Stores a fill color\"\"\"\n\n    def __init__(self, color: str, opacity: int = 255) -> None:\n        self.color = ImageColor.getrgb(color)\n\n\nclass Font:\n    \"\"\"Stores a TrueType font and color\"\"\"\n\n    def __init__(self, color, file, size=12):\n        # FIXME: add support for bitmap fonts\n        self.color = ImageColor.getrgb(color)\n        self.font = ImageFont.truetype(file, size)\n\n\nclass Draw:\n    \"\"\"\n    (Experimental) WCK-style drawing interface\n    \"\"\"\n\n    def __init__(\n        self,\n        image: Image.Image | str,\n        size: tuple[int, int] | list[int] | None = None,\n        color: float | tuple[float, ...] | str | None = None,\n    ) -> None:\n        if isinstance(image, str):\n            if size is None:\n                msg = \"If image argument is mode string, size must be a list or tuple\"\n                raise ValueError(msg)\n            image = Image.new(image, size, color)\n        self.draw = ImageDraw.Draw(image)\n        self.image = image\n        self.transform = None\n\n    def flush(self) -> Image.Image:\n        return self.image\n\n    def render(self, op, xy, pen, brush=None):\n        # handle color arguments\n        outline = fill = None\n        width = 1\n        if isinstance(pen, Pen):\n            outline = pen.color\n            width = pen.width\n        elif isinstance(brush, Pen):\n            outline = brush.color\n            width = brush.width\n        if isinstance(brush, Brush):\n            fill = brush.color\n        elif isinstance(pen, Brush):\n            fill = pen.color\n        # handle transformation\n        if self.transform:\n            xy = ImagePath.Path(xy)\n            xy.transform(self.transform)\n        # render the item\n        if op == \"line\":\n            self.draw.line(xy, fill=outline, width=width)\n        else:\n            getattr(self.draw, op)(xy, fill=fill, outline=outline)\n\n    def settransform(self, offset):\n        \"\"\"Sets a transformation offset.\"\"\"\n        (xoffset, yoffset) = offset\n        self.transform = (1, 0, xoffset, 0, 1, yoffset)\n\n    def arc(self, xy, start, end, *options):\n        \"\"\"\n        Draws an arc (a portion of a circle outline) between the start and end\n        angles, inside the given bounding box.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.arc`\n        \"\"\"\n        self.render(\"arc\", xy, start, end, *options)\n\n    def chord(self, xy, start, end, *options):\n        \"\"\"\n        Same as :py:meth:`~PIL.ImageDraw2.Draw.arc`, but connects the end points\n        with a straight line.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.chord`\n        \"\"\"\n        self.render(\"chord\", xy, start, end, *options)\n\n    def ellipse(self, xy, *options):\n        \"\"\"\n        Draws an ellipse inside the given bounding box.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.ellipse`\n        \"\"\"\n        self.render(\"ellipse\", xy, *options)\n\n    def line(self, xy, *options):\n        \"\"\"\n        Draws a line between the coordinates in the ``xy`` list.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.line`\n        \"\"\"\n        self.render(\"line\", xy, *options)\n\n    def pieslice(self, xy, start, end, *options):\n        \"\"\"\n        Same as arc, but also draws straight lines between the end points and the\n        center of the bounding box.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.pieslice`\n        \"\"\"\n        self.render(\"pieslice\", xy, start, end, *options)\n\n    def polygon(self, xy, *options):\n        \"\"\"\n        Draws a polygon.\n\n        The polygon outline consists of straight lines between the given\n        coordinates, plus a straight line between the last and the first\n        coordinate.\n\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.polygon`\n        \"\"\"\n        self.render(\"polygon\", xy, *options)\n\n    def rectangle(self, xy, *options):\n        \"\"\"\n        Draws a rectangle.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.rectangle`\n        \"\"\"\n        self.render(\"rectangle\", xy, *options)\n\n    def text(self, xy, text, font):\n        \"\"\"\n        Draws the string at the given position.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.text`\n        \"\"\"\n        if self.transform:\n            xy = ImagePath.Path(xy)\n            xy.transform(self.transform)\n        self.draw.text(xy, text, font=font.font, fill=font.color)\n\n    def textbbox(self, xy, text, font):\n        \"\"\"\n        Returns bounding box (in pixels) of given text.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.textbbox`\n        \"\"\"\n        if self.transform:\n            xy = ImagePath.Path(xy)\n            xy.transform(self.transform)\n        return self.draw.textbbox(xy, text, font=font.font)\n\n    def textlength(self, text, font):\n        \"\"\"\n        Returns length (in pixels) of given text.\n        This is the amount by which following text should be offset.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.textlength`\n        \"\"\"\n        return self.draw.textlength(text, font=font.font)\n", "src/PIL/GbrImagePlugin.py": "#\n# The Python Imaging Library\n#\n# load a GIMP brush file\n#\n# History:\n#       96-03-14 fl     Created\n#       16-01-08 es     Version 2\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n# Copyright (c) Eric Soroos 2016.\n#\n# See the README file for information on usage and redistribution.\n#\n#\n# See https://github.com/GNOME/gimp/blob/mainline/devel-docs/gbr.txt for\n# format documentation.\n#\n# This code Interprets version 1 and 2 .gbr files.\n# Version 1 files are obsolete, and should not be used for new\n#   brushes.\n# Version 2 files are saved by GIMP v2.8 (at least)\n# Version 3 files have a format specifier of 18 for 16bit floats in\n#   the color depth field. This is currently unsupported by Pillow.\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i32be as i32\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 8 and i32(prefix, 0) >= 20 and i32(prefix, 4) in (1, 2)\n\n\n##\n# Image plugin for the GIMP brush format.\n\n\nclass GbrImageFile(ImageFile.ImageFile):\n    format = \"GBR\"\n    format_description = \"GIMP brush file\"\n\n    def _open(self) -> None:\n        header_size = i32(self.fp.read(4))\n        if header_size < 20:\n            msg = \"not a GIMP brush\"\n            raise SyntaxError(msg)\n        version = i32(self.fp.read(4))\n        if version not in (1, 2):\n            msg = f\"Unsupported GIMP brush version: {version}\"\n            raise SyntaxError(msg)\n\n        width = i32(self.fp.read(4))\n        height = i32(self.fp.read(4))\n        color_depth = i32(self.fp.read(4))\n        if width <= 0 or height <= 0:\n            msg = \"not a GIMP brush\"\n            raise SyntaxError(msg)\n        if color_depth not in (1, 4):\n            msg = f\"Unsupported GIMP brush color depth: {color_depth}\"\n            raise SyntaxError(msg)\n\n        if version == 1:\n            comment_length = header_size - 20\n        else:\n            comment_length = header_size - 28\n            magic_number = self.fp.read(4)\n            if magic_number != b\"GIMP\":\n                msg = \"not a GIMP brush, bad magic number\"\n                raise SyntaxError(msg)\n            self.info[\"spacing\"] = i32(self.fp.read(4))\n\n        comment = self.fp.read(comment_length)[:-1]\n\n        if color_depth == 1:\n            self._mode = \"L\"\n        else:\n            self._mode = \"RGBA\"\n\n        self._size = width, height\n\n        self.info[\"comment\"] = comment\n\n        # Image might not be small\n        Image._decompression_bomb_check(self.size)\n\n        # Data is an uncompressed block of w * h * bytes/pixel\n        self._data_size = width * height * color_depth\n\n    def load(self):\n        if not self.im:\n            self.im = Image.core.new(self.mode, self.size)\n            self.frombytes(self.fp.read(self._data_size))\n        return Image.Image.load(self)\n\n\n#\n# registry\n\n\nImage.register_open(GbrImageFile.format, GbrImageFile, _accept)\nImage.register_extension(GbrImageFile.format, \".gbr\")\n", "src/PIL/IptcImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# IPTC/NAA file handling\n#\n# history:\n# 1995-10-01 fl   Created\n# 1998-03-09 fl   Cleaned up and added to PIL\n# 2002-06-18 fl   Added getiptcinfo helper\n#\n# Copyright (c) Secret Labs AB 1997-2002.\n# Copyright (c) Fredrik Lundh 1995.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom io import BytesIO\nfrom typing import Sequence\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._deprecate import deprecate\n\nCOMPRESSION = {1: \"raw\", 5: \"jpeg\"}\n\n\ndef __getattr__(name: str) -> bytes:\n    if name == \"PAD\":\n        deprecate(\"IptcImagePlugin.PAD\", 12)\n        return b\"\\0\\0\\0\\0\"\n    msg = f\"module '{__name__}' has no attribute '{name}'\"\n    raise AttributeError(msg)\n\n\n#\n# Helpers\n\n\ndef _i(c: bytes) -> int:\n    return i32((b\"\\0\\0\\0\\0\" + c)[-4:])\n\n\ndef _i8(c: int | bytes) -> int:\n    return c if isinstance(c, int) else c[0]\n\n\ndef i(c: bytes) -> int:\n    \"\"\".. deprecated:: 10.2.0\"\"\"\n    deprecate(\"IptcImagePlugin.i\", 12)\n    return _i(c)\n\n\ndef dump(c: Sequence[int | bytes]) -> None:\n    \"\"\".. deprecated:: 10.2.0\"\"\"\n    deprecate(\"IptcImagePlugin.dump\", 12)\n    for i in c:\n        print(f\"{_i8(i):02x}\", end=\" \")\n    print()\n\n\n##\n# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields\n# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.\n\n\nclass IptcImageFile(ImageFile.ImageFile):\n    format = \"IPTC\"\n    format_description = \"IPTC/NAA\"\n\n    def getint(self, key: tuple[int, int]) -> int:\n        return _i(self.info[key])\n\n    def field(self) -> tuple[tuple[int, int] | None, int]:\n        #\n        # get a IPTC field header\n        s = self.fp.read(5)\n        if not s.strip(b\"\\x00\"):\n            return None, 0\n\n        tag = s[1], s[2]\n\n        # syntax\n        if s[0] != 0x1C or tag[0] not in [1, 2, 3, 4, 5, 6, 7, 8, 9, 240]:\n            msg = \"invalid IPTC/NAA file\"\n            raise SyntaxError(msg)\n\n        # field size\n        size = s[3]\n        if size > 132:\n            msg = \"illegal field length in IPTC/NAA file\"\n            raise OSError(msg)\n        elif size == 128:\n            size = 0\n        elif size > 128:\n            size = _i(self.fp.read(size - 128))\n        else:\n            size = i16(s, 3)\n\n        return tag, size\n\n    def _open(self) -> None:\n        # load descriptive fields\n        while True:\n            offset = self.fp.tell()\n            tag, size = self.field()\n            if not tag or tag == (8, 10):\n                break\n            if size:\n                tagdata = self.fp.read(size)\n            else:\n                tagdata = None\n            if tag in self.info:\n                if isinstance(self.info[tag], list):\n                    self.info[tag].append(tagdata)\n                else:\n                    self.info[tag] = [self.info[tag], tagdata]\n            else:\n                self.info[tag] = tagdata\n\n        # mode\n        layers = self.info[(3, 60)][0]\n        component = self.info[(3, 60)][1]\n        if (3, 65) in self.info:\n            id = self.info[(3, 65)][0] - 1\n        else:\n            id = 0\n        if layers == 1 and not component:\n            self._mode = \"L\"\n        elif layers == 3 and component:\n            self._mode = \"RGB\"[id]\n        elif layers == 4 and component:\n            self._mode = \"CMYK\"[id]\n\n        # size\n        self._size = self.getint((3, 20)), self.getint((3, 30))\n\n        # compression\n        try:\n            compression = COMPRESSION[self.getint((3, 120))]\n        except KeyError as e:\n            msg = \"Unknown IPTC image compression\"\n            raise OSError(msg) from e\n\n        # tile\n        if tag == (8, 10):\n            self.tile = [(\"iptc\", (0, 0) + self.size, offset, compression)]\n\n    def load(self):\n        if len(self.tile) != 1 or self.tile[0][0] != \"iptc\":\n            return ImageFile.ImageFile.load(self)\n\n        offset, compression = self.tile[0][2:]\n\n        self.fp.seek(offset)\n\n        # Copy image data to temporary file\n        o = BytesIO()\n        if compression == \"raw\":\n            # To simplify access to the extracted file,\n            # prepend a PPM header\n            o.write(b\"P5\\n%d %d\\n255\\n\" % self.size)\n        while True:\n            type, size = self.field()\n            if type != (8, 10):\n                break\n            while size > 0:\n                s = self.fp.read(min(size, 8192))\n                if not s:\n                    break\n                o.write(s)\n                size -= len(s)\n\n        with Image.open(o) as _im:\n            _im.load()\n            self.im = _im.im\n\n\nImage.register_open(IptcImageFile.format, IptcImageFile)\n\nImage.register_extension(IptcImageFile.format, \".iim\")\n\n\ndef getiptcinfo(im):\n    \"\"\"\n    Get IPTC information from TIFF, JPEG, or IPTC file.\n\n    :param im: An image containing IPTC data.\n    :returns: A dictionary containing IPTC information, or None if\n        no IPTC information block was found.\n    \"\"\"\n    from . import JpegImagePlugin, TiffImagePlugin\n\n    data = None\n\n    if isinstance(im, IptcImageFile):\n        # return info dictionary right away\n        return im.info\n\n    elif isinstance(im, JpegImagePlugin.JpegImageFile):\n        # extract the IPTC/NAA resource\n        photoshop = im.info.get(\"photoshop\")\n        if photoshop:\n            data = photoshop.get(0x0404)\n\n    elif isinstance(im, TiffImagePlugin.TiffImageFile):\n        # get raw data from the IPTC/NAA tag (PhotoShop tags the data\n        # as 4-byte integers, so we cannot use the get method...)\n        try:\n            data = im.tag.tagdata[TiffImagePlugin.IPTC_NAA_CHUNK]\n        except (AttributeError, KeyError):\n            pass\n\n    if data is None:\n        return None  # no properties\n\n    # create an IptcImagePlugin object without initializing it\n    class FakeImage:\n        pass\n\n    im = FakeImage()\n    im.__class__ = IptcImageFile\n\n    # parse the IPTC information chunk\n    im.info = {}\n    im.fp = BytesIO(data)\n\n    try:\n        im._open()\n    except (IndexError, KeyError):\n        pass  # expected failure\n\n    return im.info\n", "src/PIL/ImageShow.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# im.show() drivers\n#\n# History:\n# 2008-04-06 fl   Created\n#\n# Copyright (c) Secret Labs AB 2008.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport abc\nimport os\nimport shutil\nimport subprocess\nimport sys\nfrom shlex import quote\nfrom typing import Any\n\nfrom . import Image\n\n_viewers = []\n\n\ndef register(viewer, order: int = 1) -> None:\n    \"\"\"\n    The :py:func:`register` function is used to register additional viewers::\n\n        from PIL import ImageShow\n        ImageShow.register(MyViewer())  # MyViewer will be used as a last resort\n        ImageShow.register(MySecondViewer(), 0)  # MySecondViewer will be prioritised\n        ImageShow.register(ImageShow.XVViewer(), 0)  # XVViewer will be prioritised\n\n    :param viewer: The viewer to be registered.\n    :param order:\n        Zero or a negative integer to prepend this viewer to the list,\n        a positive integer to append it.\n    \"\"\"\n    try:\n        if issubclass(viewer, Viewer):\n            viewer = viewer()\n    except TypeError:\n        pass  # raised if viewer wasn't a class\n    if order > 0:\n        _viewers.append(viewer)\n    else:\n        _viewers.insert(0, viewer)\n\n\ndef show(image: Image.Image, title: str | None = None, **options: Any) -> bool:\n    r\"\"\"\n    Display a given image.\n\n    :param image: An image object.\n    :param title: Optional title. Not all viewers can display the title.\n    :param \\**options: Additional viewer options.\n    :returns: ``True`` if a suitable viewer was found, ``False`` otherwise.\n    \"\"\"\n    for viewer in _viewers:\n        if viewer.show(image, title=title, **options):\n            return True\n    return False\n\n\nclass Viewer:\n    \"\"\"Base class for viewers.\"\"\"\n\n    # main api\n\n    def show(self, image: Image.Image, **options: Any) -> int:\n        \"\"\"\n        The main function for displaying an image.\n        Converts the given image to the target format and displays it.\n        \"\"\"\n\n        if not (\n            image.mode in (\"1\", \"RGBA\")\n            or (self.format == \"PNG\" and image.mode in (\"I;16\", \"LA\"))\n        ):\n            base = Image.getmodebase(image.mode)\n            if image.mode != base:\n                image = image.convert(base)\n\n        return self.show_image(image, **options)\n\n    # hook methods\n\n    format: str | None = None\n    \"\"\"The format to convert the image into.\"\"\"\n    options: dict[str, Any] = {}\n    \"\"\"Additional options used to convert the image.\"\"\"\n\n    def get_format(self, image: Image.Image) -> str | None:\n        \"\"\"Return format name, or ``None`` to save as PGM/PPM.\"\"\"\n        return self.format\n\n    def get_command(self, file: str, **options: Any) -> str:\n        \"\"\"\n        Returns the command used to display the file.\n        Not implemented in the base class.\n        \"\"\"\n        msg = \"unavailable in base viewer\"\n        raise NotImplementedError(msg)\n\n    def save_image(self, image: Image.Image) -> str:\n        \"\"\"Save to temporary file and return filename.\"\"\"\n        return image._dump(format=self.get_format(image), **self.options)\n\n    def show_image(self, image: Image.Image, **options: Any) -> int:\n        \"\"\"Display the given image.\"\"\"\n        return self.show_file(self.save_image(image), **options)\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        os.system(self.get_command(path, **options))  # nosec\n        return 1\n\n\n# --------------------------------------------------------------------\n\n\nclass WindowsViewer(Viewer):\n    \"\"\"The default viewer on Windows is the default system application for PNG files.\"\"\"\n\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n\n    def get_command(self, file: str, **options: Any) -> str:\n        return (\n            f'start \"Pillow\" /WAIT \"{file}\" '\n            \"&& ping -n 4 127.0.0.1 >NUL \"\n            f'&& del /f \"{file}\"'\n        )\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen(\n            self.get_command(path, **options),\n            shell=True,\n            creationflags=getattr(subprocess, \"CREATE_NO_WINDOW\"),\n        )  # nosec\n        return 1\n\n\nif sys.platform == \"win32\":\n    register(WindowsViewer)\n\n\nclass MacViewer(Viewer):\n    \"\"\"The default viewer on macOS using ``Preview.app``.\"\"\"\n\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n\n    def get_command(self, file: str, **options: Any) -> str:\n        # on darwin open returns immediately resulting in the temp\n        # file removal while app is opening\n        command = \"open -a Preview.app\"\n        command = f\"({command} {quote(file)}; sleep 20; rm -f {quote(file)})&\"\n        return command\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.call([\"open\", \"-a\", \"Preview.app\", path])\n        executable = sys.executable or shutil.which(\"python3\")\n        if executable:\n            subprocess.Popen(\n                [\n                    executable,\n                    \"-c\",\n                    \"import os, sys, time; time.sleep(20); os.remove(sys.argv[1])\",\n                    path,\n                ]\n            )\n        return 1\n\n\nif sys.platform == \"darwin\":\n    register(MacViewer)\n\n\nclass UnixViewer(Viewer):\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n\n    @abc.abstractmethod\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        pass\n\n    def get_command(self, file: str, **options: Any) -> str:\n        command = self.get_command_ex(file, **options)[0]\n        return f\"{command} {quote(file)}\"\n\n\nclass XDGViewer(UnixViewer):\n    \"\"\"\n    The freedesktop.org ``xdg-open`` command.\n    \"\"\"\n\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        command = executable = \"xdg-open\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen([\"xdg-open\", path])\n        return 1\n\n\nclass DisplayViewer(UnixViewer):\n    \"\"\"\n    The ImageMagick ``display`` command.\n    This viewer supports the ``title`` parameter.\n    \"\"\"\n\n    def get_command_ex(\n        self, file: str, title: str | None = None, **options: Any\n    ) -> tuple[str, str]:\n        command = executable = \"display\"\n        if title:\n            command += f\" -title {quote(title)}\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        args = [\"display\"]\n        title = options.get(\"title\")\n        if title:\n            args += [\"-title\", title]\n        args.append(path)\n\n        subprocess.Popen(args)\n        return 1\n\n\nclass GmDisplayViewer(UnixViewer):\n    \"\"\"The GraphicsMagick ``gm display`` command.\"\"\"\n\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        executable = \"gm\"\n        command = \"gm display\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen([\"gm\", \"display\", path])\n        return 1\n\n\nclass EogViewer(UnixViewer):\n    \"\"\"The GNOME Image Viewer ``eog`` command.\"\"\"\n\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        executable = \"eog\"\n        command = \"eog -n\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen([\"eog\", \"-n\", path])\n        return 1\n\n\nclass XVViewer(UnixViewer):\n    \"\"\"\n    The X Viewer ``xv`` command.\n    This viewer supports the ``title`` parameter.\n    \"\"\"\n\n    def get_command_ex(\n        self, file: str, title: str | None = None, **options: Any\n    ) -> tuple[str, str]:\n        # note: xv is pretty outdated.  most modern systems have\n        # imagemagick's display command instead.\n        command = executable = \"xv\"\n        if title:\n            command += f\" -name {quote(title)}\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        args = [\"xv\"]\n        title = options.get(\"title\")\n        if title:\n            args += [\"-name\", title]\n        args.append(path)\n\n        subprocess.Popen(args)\n        return 1\n\n\nif sys.platform not in (\"win32\", \"darwin\"):  # unixoids\n    if shutil.which(\"xdg-open\"):\n        register(XDGViewer)\n    if shutil.which(\"display\"):\n        register(DisplayViewer)\n    if shutil.which(\"gm\"):\n        register(GmDisplayViewer)\n    if shutil.which(\"eog\"):\n        register(EogViewer)\n    if shutil.which(\"xv\"):\n        register(XVViewer)\n\n\nclass IPythonViewer(Viewer):\n    \"\"\"The viewer for IPython frontends.\"\"\"\n\n    def show_image(self, image: Image.Image, **options: Any) -> int:\n        ipython_display(image)\n        return 1\n\n\ntry:\n    from IPython.display import display as ipython_display\nexcept ImportError:\n    pass\nelse:\n    register(IPythonViewer)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Syntax: python3 ImageShow.py imagefile [title]\")\n        sys.exit()\n\n    with Image.open(sys.argv[1]) as im:\n        print(show(im, *sys.argv[2:]))\n", "src/PIL/ImageSequence.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# sequence support classes\n#\n# history:\n# 1997-02-20 fl     Created\n#\n# Copyright (c) 1997 by Secret Labs AB.\n# Copyright (c) 1997 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n##\nfrom __future__ import annotations\n\nfrom typing import Callable\n\nfrom . import Image\n\n\nclass Iterator:\n    \"\"\"\n    This class implements an iterator object that can be used to loop\n    over an image sequence.\n\n    You can use the ``[]`` operator to access elements by index. This operator\n    will raise an :py:exc:`IndexError` if you try to access a nonexistent\n    frame.\n\n    :param im: An image object.\n    \"\"\"\n\n    def __init__(self, im: Image.Image):\n        if not hasattr(im, \"seek\"):\n            msg = \"im must have seek method\"\n            raise AttributeError(msg)\n        self.im = im\n        self.position = getattr(self.im, \"_min_frame\", 0)\n\n    def __getitem__(self, ix: int) -> Image.Image:\n        try:\n            self.im.seek(ix)\n            return self.im\n        except EOFError as e:\n            msg = \"end of sequence\"\n            raise IndexError(msg) from e\n\n    def __iter__(self) -> Iterator:\n        return self\n\n    def __next__(self) -> Image.Image:\n        try:\n            self.im.seek(self.position)\n            self.position += 1\n            return self.im\n        except EOFError as e:\n            msg = \"end of sequence\"\n            raise StopIteration(msg) from e\n\n\ndef all_frames(\n    im: Image.Image | list[Image.Image],\n    func: Callable[[Image.Image], Image.Image] | None = None,\n) -> list[Image.Image]:\n    \"\"\"\n    Applies a given function to all frames in an image or a list of images.\n    The frames are returned as a list of separate images.\n\n    :param im: An image, or a list of images.\n    :param func: The function to apply to all of the image frames.\n    :returns: A list of images.\n    \"\"\"\n    if not isinstance(im, list):\n        im = [im]\n\n    ims = []\n    for imSequence in im:\n        current = imSequence.tell()\n\n        ims += [im_frame.copy() for im_frame in Iterator(imSequence)]\n\n        imSequence.seek(current)\n    return [func(im) for im in ims] if func else ims\n", "src/PIL/_deprecate.py": "from __future__ import annotations\n\nimport warnings\n\nfrom . import __version__\n\n\ndef deprecate(\n    deprecated: str,\n    when: int | None,\n    replacement: str | None = None,\n    *,\n    action: str | None = None,\n    plural: bool = False,\n) -> None:\n    \"\"\"\n    Deprecations helper.\n\n    :param deprecated: Name of thing to be deprecated.\n    :param when: Pillow major version to be removed in.\n    :param replacement: Name of replacement.\n    :param action: Instead of \"replacement\", give a custom call to action\n        e.g. \"Upgrade to new thing\".\n    :param plural: if the deprecated thing is plural, needing \"are\" instead of \"is\".\n\n    Usually of the form:\n\n        \"[deprecated] is deprecated and will be removed in Pillow [when] (yyyy-mm-dd).\n        Use [replacement] instead.\"\n\n    You can leave out the replacement sentence:\n\n        \"[deprecated] is deprecated and will be removed in Pillow [when] (yyyy-mm-dd)\"\n\n    Or with another call to action:\n\n        \"[deprecated] is deprecated and will be removed in Pillow [when] (yyyy-mm-dd).\n        [action].\"\n    \"\"\"\n\n    is_ = \"are\" if plural else \"is\"\n\n    if when is None:\n        removed = \"a future version\"\n    elif when <= int(__version__.split(\".\")[0]):\n        msg = f\"{deprecated} {is_} deprecated and should be removed.\"\n        raise RuntimeError(msg)\n    elif when == 11:\n        removed = \"Pillow 11 (2024-10-15)\"\n    elif when == 12:\n        removed = \"Pillow 12 (2025-10-15)\"\n    else:\n        msg = f\"Unknown removal version: {when}. Update {__name__}?\"\n        raise ValueError(msg)\n\n    if replacement and action:\n        msg = \"Use only one of 'replacement' and 'action'\"\n        raise ValueError(msg)\n\n    if replacement:\n        action = f\". Use {replacement} instead.\"\n    elif action:\n        action = f\". {action.rstrip('.')}.\"\n    else:\n        action = \"\"\n\n    warnings.warn(\n        f\"{deprecated} {is_} deprecated and will be removed in {removed}{action}\",\n        DeprecationWarning,\n        stacklevel=3,\n    )\n", "src/PIL/PSDraw.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# Simple PostScript graphics interface\n#\n# History:\n# 1996-04-20 fl   Created\n# 1999-01-10 fl   Added gsave/grestore to image method\n# 2005-05-04 fl   Fixed floating point issue in image (from Eric Etheridge)\n#\n# Copyright (c) 1997-2005 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom . import EpsImagePlugin\n\n##\n# Simple PostScript graphics interface.\n\n\nclass PSDraw:\n    \"\"\"\n    Sets up printing to the given file. If ``fp`` is omitted,\n    ``sys.stdout.buffer`` or ``sys.stdout`` is assumed.\n    \"\"\"\n\n    def __init__(self, fp=None):\n        if not fp:\n            try:\n                fp = sys.stdout.buffer\n            except AttributeError:\n                fp = sys.stdout\n        self.fp = fp\n\n    def begin_document(self, id: str | None = None) -> None:\n        \"\"\"Set up printing of a document. (Write PostScript DSC header.)\"\"\"\n        # FIXME: incomplete\n        self.fp.write(\n            b\"%!PS-Adobe-3.0\\n\"\n            b\"save\\n\"\n            b\"/showpage { } def\\n\"\n            b\"%%EndComments\\n\"\n            b\"%%BeginDocument\\n\"\n        )\n        # self.fp.write(ERROR_PS)  # debugging!\n        self.fp.write(EDROFF_PS)\n        self.fp.write(VDI_PS)\n        self.fp.write(b\"%%EndProlog\\n\")\n        self.isofont: dict[bytes, int] = {}\n\n    def end_document(self) -> None:\n        \"\"\"Ends printing. (Write PostScript DSC footer.)\"\"\"\n        self.fp.write(b\"%%EndDocument\\nrestore showpage\\n%%End\\n\")\n        if hasattr(self.fp, \"flush\"):\n            self.fp.flush()\n\n    def setfont(self, font: str, size: int) -> None:\n        \"\"\"\n        Selects which font to use.\n\n        :param font: A PostScript font name\n        :param size: Size in points.\n        \"\"\"\n        font_bytes = bytes(font, \"UTF-8\")\n        if font_bytes not in self.isofont:\n            # reencode font\n            self.fp.write(\n                b\"/PSDraw-%s ISOLatin1Encoding /%s E\\n\" % (font_bytes, font_bytes)\n            )\n            self.isofont[font_bytes] = 1\n        # rough\n        self.fp.write(b\"/F0 %d /PSDraw-%s F\\n\" % (size, font_bytes))\n\n    def line(self, xy0: tuple[int, int], xy1: tuple[int, int]) -> None:\n        \"\"\"\n        Draws a line between the two points. Coordinates are given in\n        PostScript point coordinates (72 points per inch, (0, 0) is the lower\n        left corner of the page).\n        \"\"\"\n        self.fp.write(b\"%d %d %d %d Vl\\n\" % (*xy0, *xy1))\n\n    def rectangle(self, box: tuple[int, int, int, int]) -> None:\n        \"\"\"\n        Draws a rectangle.\n\n        :param box: A tuple of four integers, specifying left, bottom, width and\n           height.\n        \"\"\"\n        self.fp.write(b\"%d %d M 0 %d %d Vr\\n\" % box)\n\n    def text(self, xy: tuple[int, int], text: str) -> None:\n        \"\"\"\n        Draws text at the given position. You must use\n        :py:meth:`~PIL.PSDraw.PSDraw.setfont` before calling this method.\n        \"\"\"\n        text_bytes = bytes(text, \"UTF-8\")\n        text_bytes = b\"\\\\(\".join(text_bytes.split(b\"(\"))\n        text_bytes = b\"\\\\)\".join(text_bytes.split(b\")\"))\n        self.fp.write(b\"%d %d M (%s) S\\n\" % (xy + (text_bytes,)))\n\n    if TYPE_CHECKING:\n        from . import Image\n\n    def image(\n        self, box: tuple[int, int, int, int], im: Image.Image, dpi: int | None = None\n    ) -> None:\n        \"\"\"Draw a PIL image, centered in the given box.\"\"\"\n        # default resolution depends on mode\n        if not dpi:\n            if im.mode == \"1\":\n                dpi = 200  # fax\n            else:\n                dpi = 100  # grayscale\n        # image size (on paper)\n        x = im.size[0] * 72 / dpi\n        y = im.size[1] * 72 / dpi\n        # max allowed size\n        xmax = float(box[2] - box[0])\n        ymax = float(box[3] - box[1])\n        if x > xmax:\n            y = y * xmax / x\n            x = xmax\n        if y > ymax:\n            x = x * ymax / y\n            y = ymax\n        dx = (xmax - x) / 2 + box[0]\n        dy = (ymax - y) / 2 + box[1]\n        self.fp.write(b\"gsave\\n%f %f translate\\n\" % (dx, dy))\n        if (x, y) != im.size:\n            # EpsImagePlugin._save prints the image at (0,0,xsize,ysize)\n            sx = x / im.size[0]\n            sy = y / im.size[1]\n            self.fp.write(b\"%f %f scale\\n\" % (sx, sy))\n        EpsImagePlugin._save(im, self.fp, \"\", 0)\n        self.fp.write(b\"\\ngrestore\\n\")\n\n\n# --------------------------------------------------------------------\n# PostScript driver\n\n#\n# EDROFF.PS -- PostScript driver for Edroff 2\n#\n# History:\n# 94-01-25 fl: created (edroff 2.04)\n#\n# Copyright (c) Fredrik Lundh 1994.\n#\n\n\nEDROFF_PS = b\"\"\"\\\n/S { show } bind def\n/P { moveto show } bind def\n/M { moveto } bind def\n/X { 0 rmoveto } bind def\n/Y { 0 exch rmoveto } bind def\n/E {    findfont\n        dup maxlength dict begin\n        {\n                1 index /FID ne { def } { pop pop } ifelse\n        } forall\n        /Encoding exch def\n        dup /FontName exch def\n        currentdict end definefont pop\n} bind def\n/F {    findfont exch scalefont dup setfont\n        [ exch /setfont cvx ] cvx bind def\n} bind def\n\"\"\"\n\n#\n# VDI.PS -- PostScript driver for VDI meta commands\n#\n# History:\n# 94-01-25 fl: created (edroff 2.04)\n#\n# Copyright (c) Fredrik Lundh 1994.\n#\n\nVDI_PS = b\"\"\"\\\n/Vm { moveto } bind def\n/Va { newpath arcn stroke } bind def\n/Vl { moveto lineto stroke } bind def\n/Vc { newpath 0 360 arc closepath } bind def\n/Vr {   exch dup 0 rlineto\n        exch dup 0 exch rlineto\n        exch neg 0 rlineto\n        0 exch neg rlineto\n        setgray fill } bind def\n/Tm matrix def\n/Ve {   Tm currentmatrix pop\n        translate scale newpath 0 0 .5 0 360 arc closepath\n        Tm setmatrix\n} bind def\n/Vf { currentgray exch setgray fill setgray } bind def\n\"\"\"\n\n#\n# ERROR.PS -- Error handler\n#\n# History:\n# 89-11-21 fl: created (pslist 1.10)\n#\n\nERROR_PS = b\"\"\"\\\n/landscape false def\n/errorBUF 200 string def\n/errorNL { currentpoint 10 sub exch pop 72 exch moveto } def\nerrordict begin /handleerror {\n    initmatrix /Courier findfont 10 scalefont setfont\n    newpath 72 720 moveto $error begin /newerror false def\n    (PostScript Error) show errorNL errorNL\n    (Error: ) show\n        /errorname load errorBUF cvs show errorNL errorNL\n    (Command: ) show\n        /command load dup type /stringtype ne { errorBUF cvs } if show\n        errorNL errorNL\n    (VMstatus: ) show\n        vmstatus errorBUF cvs show ( bytes available, ) show\n        errorBUF cvs show ( bytes used at level ) show\n        errorBUF cvs show errorNL errorNL\n    (Operand stargck: ) show errorNL /ostargck load {\n        dup type /stringtype ne { errorBUF cvs } if 72 0 rmoveto show errorNL\n    } forall errorNL\n    (Execution stargck: ) show errorNL /estargck load {\n        dup type /stringtype ne { errorBUF cvs } if 72 0 rmoveto show errorNL\n    } forall\n    end showpage\n} def end\n\"\"\"\n", "src/PIL/ImageWin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a Windows DIB display interface\n#\n# History:\n# 1996-05-20 fl   Created\n# 1996-09-20 fl   Fixed subregion exposure\n# 1997-09-21 fl   Added draw primitive (for tzPrint)\n# 2003-05-21 fl   Added experimental Window/ImageWindow classes\n# 2003-09-05 fl   Added fromstring/tostring methods\n#\n# Copyright (c) Secret Labs AB 1997-2003.\n# Copyright (c) Fredrik Lundh 1996-2003.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image\n\n\nclass HDC:\n    \"\"\"\n    Wraps an HDC integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods.\n    \"\"\"\n\n    def __init__(self, dc: int) -> None:\n        self.dc = dc\n\n    def __int__(self) -> int:\n        return self.dc\n\n\nclass HWND:\n    \"\"\"\n    Wraps an HWND integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods, instead of a DC.\n    \"\"\"\n\n    def __init__(self, wnd: int) -> None:\n        self.wnd = wnd\n\n    def __int__(self) -> int:\n        return self.wnd\n\n\nclass Dib:\n    \"\"\"\n    A Windows bitmap with the given mode and size.  The mode can be one of \"1\",\n    \"L\", \"P\", or \"RGB\".\n\n    If the display requires a palette, this constructor creates a suitable\n    palette and associates it with the image. For an \"L\" image, 128 graylevels\n    are allocated. For an \"RGB\" image, a 6x6x6 colour cube is used, together\n    with 20 graylevels.\n\n    To make sure that palettes work properly under Windows, you must call the\n    ``palette`` method upon certain events from Windows.\n\n    :param image: Either a PIL image, or a mode string. If a mode string is\n                  used, a size must also be given.  The mode can be one of \"1\",\n                  \"L\", \"P\", or \"RGB\".\n    :param size: If the first argument is a mode string, this\n                 defines the size of the image.\n    \"\"\"\n\n    def __init__(self, image, size=None):\n        if hasattr(image, \"mode\") and hasattr(image, \"size\"):\n            mode = image.mode\n            size = image.size\n        else:\n            mode = image\n            image = None\n        if mode not in [\"1\", \"L\", \"P\", \"RGB\"]:\n            mode = Image.getmodebase(mode)\n        self.image = Image.core.display(mode, size)\n        self.mode = mode\n        self.size = size\n        if image:\n            self.paste(image)\n\n    def expose(self, handle):\n        \"\"\"\n        Copy the bitmap contents to a device context.\n\n        :param handle: Device context (HDC), cast to a Python integer, or an\n                       HDC or HWND instance.  In PythonWin, you can use\n                       ``CDC.GetHandleAttrib()`` to get a suitable handle.\n        \"\"\"\n        if isinstance(handle, HWND):\n            dc = self.image.getdc(handle)\n            try:\n                result = self.image.expose(dc)\n            finally:\n                self.image.releasedc(handle, dc)\n        else:\n            result = self.image.expose(handle)\n        return result\n\n    def draw(self, handle, dst, src=None):\n        \"\"\"\n        Same as expose, but allows you to specify where to draw the image, and\n        what part of it to draw.\n\n        The destination and source areas are given as 4-tuple rectangles. If\n        the source is omitted, the entire image is copied. If the source and\n        the destination have different sizes, the image is resized as\n        necessary.\n        \"\"\"\n        if not src:\n            src = (0, 0) + self.size\n        if isinstance(handle, HWND):\n            dc = self.image.getdc(handle)\n            try:\n                result = self.image.draw(dc, dst, src)\n            finally:\n                self.image.releasedc(handle, dc)\n        else:\n            result = self.image.draw(handle, dst, src)\n        return result\n\n    def query_palette(self, handle):\n        \"\"\"\n        Installs the palette associated with the image in the given device\n        context.\n\n        This method should be called upon **QUERYNEWPALETTE** and\n        **PALETTECHANGED** events from Windows. If this method returns a\n        non-zero value, one or more display palette entries were changed, and\n        the image should be redrawn.\n\n        :param handle: Device context (HDC), cast to a Python integer, or an\n                       HDC or HWND instance.\n        :return: A true value if one or more entries were changed (this\n                 indicates that the image should be redrawn).\n        \"\"\"\n        if isinstance(handle, HWND):\n            handle = self.image.getdc(handle)\n            try:\n                result = self.image.query_palette(handle)\n            finally:\n                self.image.releasedc(handle, handle)\n        else:\n            result = self.image.query_palette(handle)\n        return result\n\n    def paste(\n        self, im: Image.Image, box: tuple[int, int, int, int] | None = None\n    ) -> None:\n        \"\"\"\n        Paste a PIL image into the bitmap image.\n\n        :param im: A PIL image.  The size must match the target region.\n                   If the mode does not match, the image is converted to the\n                   mode of the bitmap image.\n        :param box: A 4-tuple defining the left, upper, right, and\n                    lower pixel coordinate.  See :ref:`coordinate-system`. If\n                    None is given instead of a tuple, all of the image is\n                    assumed.\n        \"\"\"\n        im.load()\n        if self.mode != im.mode:\n            im = im.convert(self.mode)\n        if box:\n            self.image.paste(im.im, box)\n        else:\n            self.image.paste(im.im)\n\n    def frombytes(self, buffer: bytes) -> None:\n        \"\"\"\n        Load display memory contents from byte data.\n\n        :param buffer: A buffer containing display data (usually\n                       data returned from :py:func:`~PIL.ImageWin.Dib.tobytes`)\n        \"\"\"\n        self.image.frombytes(buffer)\n\n    def tobytes(self) -> bytes:\n        \"\"\"\n        Copy display memory contents to bytes object.\n\n        :return: A bytes object containing display data.\n        \"\"\"\n        return self.image.tobytes()\n\n\nclass Window:\n    \"\"\"Create a Window with the given title size.\"\"\"\n\n    def __init__(\n        self, title: str = \"PIL\", width: int | None = None, height: int | None = None\n    ) -> None:\n        self.hwnd = Image.core.createwindow(\n            title, self.__dispatcher, width or 0, height or 0\n        )\n\n    def __dispatcher(self, action, *args):\n        return getattr(self, f\"ui_handle_{action}\")(*args)\n\n    def ui_handle_clear(self, dc, x0, y0, x1, y1):\n        pass\n\n    def ui_handle_damage(self, x0, y0, x1, y1):\n        pass\n\n    def ui_handle_destroy(self) -> None:\n        pass\n\n    def ui_handle_repair(self, dc, x0, y0, x1, y1):\n        pass\n\n    def ui_handle_resize(self, width, height):\n        pass\n\n    def mainloop(self) -> None:\n        Image.core.eventloop()\n\n\nclass ImageWindow(Window):\n    \"\"\"Create an image window which displays the given image.\"\"\"\n\n    def __init__(self, image, title=\"PIL\"):\n        if not isinstance(image, Dib):\n            image = Dib(image)\n        self.image = image\n        width, height = image.size\n        super().__init__(title, width=width, height=height)\n\n    def ui_handle_repair(self, dc, x0, y0, x1, y1):\n        self.image.draw(dc, (x0, y0, x1, y1))\n", "src/PIL/ImagePalette.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# image palette object\n#\n# History:\n# 1996-03-11 fl   Rewritten.\n# 1997-01-03 fl   Up and running.\n# 1997-08-23 fl   Added load hack\n# 2001-04-16 fl   Fixed randint shadow bug in random()\n#\n# Copyright (c) 1997-2001 by Secret Labs AB\n# Copyright (c) 1996-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport array\nfrom typing import IO, TYPE_CHECKING, Sequence\n\nfrom . import GimpGradientFile, GimpPaletteFile, ImageColor, PaletteFile\n\nif TYPE_CHECKING:\n    from . import Image\n\n\nclass ImagePalette:\n    \"\"\"\n    Color palette for palette mapped images\n\n    :param mode: The mode to use for the palette. See:\n        :ref:`concept-modes`. Defaults to \"RGB\"\n    :param palette: An optional palette. If given, it must be a bytearray,\n        an array or a list of ints between 0-255. The list must consist of\n        all channels for one color followed by the next color (e.g. RGBRGBRGB).\n        Defaults to an empty palette.\n    \"\"\"\n\n    def __init__(self, mode: str = \"RGB\", palette: Sequence[int] | None = None) -> None:\n        self.mode = mode\n        self.rawmode = None  # if set, palette contains raw data\n        self.palette = palette or bytearray()\n        self.dirty: int | None = None\n\n    @property\n    def palette(self):\n        return self._palette\n\n    @palette.setter\n    def palette(self, palette):\n        self._colors = None\n        self._palette = palette\n\n    @property\n    def colors(self) -> dict[tuple[int, int, int] | tuple[int, int, int, int], int]:\n        if self._colors is None:\n            mode_len = len(self.mode)\n            self._colors = {}\n            for i in range(0, len(self.palette), mode_len):\n                color = tuple(self.palette[i : i + mode_len])\n                if color in self._colors:\n                    continue\n                self._colors[color] = i // mode_len\n        return self._colors\n\n    @colors.setter\n    def colors(\n        self, colors: dict[tuple[int, int, int] | tuple[int, int, int, int], int]\n    ) -> None:\n        self._colors = colors\n\n    def copy(self) -> ImagePalette:\n        new = ImagePalette()\n\n        new.mode = self.mode\n        new.rawmode = self.rawmode\n        if self.palette is not None:\n            new.palette = self.palette[:]\n        new.dirty = self.dirty\n\n        return new\n\n    def getdata(self) -> tuple[str, bytes]:\n        \"\"\"\n        Get palette contents in format suitable for the low-level\n        ``im.putpalette`` primitive.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            return self.rawmode, self.palette\n        return self.mode, self.tobytes()\n\n    def tobytes(self) -> bytes:\n        \"\"\"Convert palette to bytes.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            msg = \"palette contains raw palette data\"\n            raise ValueError(msg)\n        if isinstance(self.palette, bytes):\n            return self.palette\n        arr = array.array(\"B\", self.palette)\n        return arr.tobytes()\n\n    # Declare tostring as an alias for tobytes\n    tostring = tobytes\n\n    def _new_color_index(\n        self, image: Image.Image | None = None, e: Exception | None = None\n    ) -> int:\n        if not isinstance(self.palette, bytearray):\n            self._palette = bytearray(self.palette)\n        index = len(self.palette) // 3\n        special_colors: tuple[int | tuple[int, ...] | None, ...] = ()\n        if image:\n            special_colors = (\n                image.info.get(\"background\"),\n                image.info.get(\"transparency\"),\n            )\n            while index in special_colors:\n                index += 1\n        if index >= 256:\n            if image:\n                # Search for an unused index\n                for i, count in reversed(list(enumerate(image.histogram()))):\n                    if count == 0 and i not in special_colors:\n                        index = i\n                        break\n            if index >= 256:\n                msg = \"cannot allocate more than 256 colors\"\n                raise ValueError(msg) from e\n        return index\n\n    def getcolor(\n        self,\n        color: tuple[int, int, int] | tuple[int, int, int, int],\n        image: Image.Image | None = None,\n    ) -> int:\n        \"\"\"Given an rgb tuple, allocate palette entry.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            msg = \"palette contains raw palette data\"\n            raise ValueError(msg)\n        if isinstance(color, tuple):\n            if self.mode == \"RGB\":\n                if len(color) == 4:\n                    if color[3] != 255:\n                        msg = \"cannot add non-opaque RGBA color to RGB palette\"\n                        raise ValueError(msg)\n                    color = color[:3]\n            elif self.mode == \"RGBA\":\n                if len(color) == 3:\n                    color += (255,)\n            try:\n                return self.colors[color]\n            except KeyError as e:\n                # allocate new color slot\n                index = self._new_color_index(image, e)\n                self.colors[color] = index\n                if index * 3 < len(self.palette):\n                    self._palette = (\n                        self.palette[: index * 3]\n                        + bytes(color)\n                        + self.palette[index * 3 + 3 :]\n                    )\n                else:\n                    self._palette += bytes(color)\n                self.dirty = 1\n                return index\n        else:\n            msg = f\"unknown color specifier: {repr(color)}\"  # type: ignore[unreachable]\n            raise ValueError(msg)\n\n    def save(self, fp: str | IO[str]) -> None:\n        \"\"\"Save palette to text file.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            msg = \"palette contains raw palette data\"\n            raise ValueError(msg)\n        if isinstance(fp, str):\n            fp = open(fp, \"w\")\n        fp.write(\"# Palette\\n\")\n        fp.write(f\"# Mode: {self.mode}\\n\")\n        for i in range(256):\n            fp.write(f\"{i}\")\n            for j in range(i * len(self.mode), (i + 1) * len(self.mode)):\n                try:\n                    fp.write(f\" {self.palette[j]}\")\n                except IndexError:\n                    fp.write(\" 0\")\n            fp.write(\"\\n\")\n        fp.close()\n\n\n# --------------------------------------------------------------------\n# Internal\n\n\ndef raw(rawmode, data) -> ImagePalette:\n    palette = ImagePalette()\n    palette.rawmode = rawmode\n    palette.palette = data\n    palette.dirty = 1\n    return palette\n\n\n# --------------------------------------------------------------------\n# Factories\n\n\ndef make_linear_lut(black, white):\n    if black == 0:\n        return [white * i // 255 for i in range(256)]\n\n    msg = \"unavailable when black is non-zero\"\n    raise NotImplementedError(msg)  # FIXME\n\n\ndef make_gamma_lut(exp: float) -> list[int]:\n    return [int(((i / 255.0) ** exp) * 255.0 + 0.5) for i in range(256)]\n\n\ndef negative(mode: str = \"RGB\") -> ImagePalette:\n    palette = list(range(256 * len(mode)))\n    palette.reverse()\n    return ImagePalette(mode, [i // len(mode) for i in palette])\n\n\ndef random(mode: str = \"RGB\") -> ImagePalette:\n    from random import randint\n\n    palette = [randint(0, 255) for _ in range(256 * len(mode))]\n    return ImagePalette(mode, palette)\n\n\ndef sepia(white: str = \"#fff0c0\") -> ImagePalette:\n    bands = [make_linear_lut(0, band) for band in ImageColor.getrgb(white)]\n    return ImagePalette(\"RGB\", [bands[i % 3][i // 3] for i in range(256 * 3)])\n\n\ndef wedge(mode: str = \"RGB\") -> ImagePalette:\n    palette = list(range(256 * len(mode)))\n    return ImagePalette(mode, [i // len(mode) for i in palette])\n\n\ndef load(filename):\n    # FIXME: supports GIMP gradients only\n\n    with open(filename, \"rb\") as fp:\n        for paletteHandler in [\n            GimpPaletteFile.GimpPaletteFile,\n            GimpGradientFile.GimpGradientFile,\n            PaletteFile.PaletteFile,\n        ]:\n            try:\n                fp.seek(0)\n                lut = paletteHandler(fp).getpalette()\n                if lut:\n                    break\n            except (SyntaxError, ValueError):\n                pass\n        else:\n            msg = \"cannot load palette\"\n            raise OSError(msg)\n\n    return lut  # data, rawmode\n", "src/PIL/ImageTransform.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# transform wrappers\n#\n# History:\n# 2002-04-08 fl   Created\n#\n# Copyright (c) 2002 by Secret Labs AB\n# Copyright (c) 2002 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import Any, Sequence\n\nfrom . import Image\n\n\nclass Transform(Image.ImageTransformHandler):\n    \"\"\"Base class for other transforms defined in :py:mod:`~PIL.ImageTransform`.\"\"\"\n\n    method: Image.Transform\n\n    def __init__(self, data: Sequence[Any]) -> None:\n        self.data = data\n\n    def getdata(self) -> tuple[Image.Transform, Sequence[int]]:\n        return self.method, self.data\n\n    def transform(\n        self,\n        size: tuple[int, int],\n        image: Image.Image,\n        **options: Any,\n    ) -> Image.Image:\n        \"\"\"Perform the transform. Called from :py:meth:`.Image.transform`.\"\"\"\n        # can be overridden\n        method, data = self.getdata()\n        return image.transform(size, method, data, **options)\n\n\nclass AffineTransform(Transform):\n    \"\"\"\n    Define an affine image transform.\n\n    This function takes a 6-tuple (a, b, c, d, e, f) which contain the first\n    two rows from an affine transform matrix. For each pixel (x, y) in the\n    output image, the new value is taken from a position (a x + b y + c,\n    d x + e y + f) in the input image, rounded to nearest pixel.\n\n    This function can be used to scale, translate, rotate, and shear the\n    original image.\n\n    See :py:meth:`.Image.transform`\n\n    :param matrix: A 6-tuple (a, b, c, d, e, f) containing the first two rows\n        from an affine transform matrix.\n    \"\"\"\n\n    method = Image.Transform.AFFINE\n\n\nclass PerspectiveTransform(Transform):\n    \"\"\"\n    Define a perspective image transform.\n\n    This function takes an 8-tuple (a, b, c, d, e, f, g, h). For each pixel\n    (x, y) in the output image, the new value is taken from a position\n    ((a x + b y + c) / (g x + h y + 1), (d x + e y + f) / (g x + h y + 1)) in\n    the input image, rounded to nearest pixel.\n\n    This function can be used to scale, translate, rotate, and shear the\n    original image.\n\n    See :py:meth:`.Image.transform`\n\n    :param matrix: An 8-tuple (a, b, c, d, e, f, g, h).\n    \"\"\"\n\n    method = Image.Transform.PERSPECTIVE\n\n\nclass ExtentTransform(Transform):\n    \"\"\"\n    Define a transform to extract a subregion from an image.\n\n    Maps a rectangle (defined by two corners) from the image to a rectangle of\n    the given size. The resulting image will contain data sampled from between\n    the corners, such that (x0, y0) in the input image will end up at (0,0) in\n    the output image, and (x1, y1) at size.\n\n    This method can be used to crop, stretch, shrink, or mirror an arbitrary\n    rectangle in the current image. It is slightly slower than crop, but about\n    as fast as a corresponding resize operation.\n\n    See :py:meth:`.Image.transform`\n\n    :param bbox: A 4-tuple (x0, y0, x1, y1) which specifies two points in the\n        input image's coordinate system. See :ref:`coordinate-system`.\n    \"\"\"\n\n    method = Image.Transform.EXTENT\n\n\nclass QuadTransform(Transform):\n    \"\"\"\n    Define a quad image transform.\n\n    Maps a quadrilateral (a region defined by four corners) from the image to a\n    rectangle of the given size.\n\n    See :py:meth:`.Image.transform`\n\n    :param xy: An 8-tuple (x0, y0, x1, y1, x2, y2, x3, y3) which contain the\n        upper left, lower left, lower right, and upper right corner of the\n        source quadrilateral.\n    \"\"\"\n\n    method = Image.Transform.QUAD\n\n\nclass MeshTransform(Transform):\n    \"\"\"\n    Define a mesh image transform.  A mesh transform consists of one or more\n    individual quad transforms.\n\n    See :py:meth:`.Image.transform`\n\n    :param data: A list of (bbox, quad) tuples.\n    \"\"\"\n\n    method = Image.Transform.MESH\n", "src/PIL/MpoImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# MPO file handling\n#\n# See \"Multi-Picture Format\" (CIPA DC-007-Translation 2009, Standard of the\n# Camera & Imaging Products Association)\n#\n# The multi-picture object combines multiple JPEG images (with a modified EXIF\n# data format) into a single file. While it can theoretically be used much like\n# a GIF animation, it is commonly used to represent 3D photographs and is (as\n# of this writing) the most commonly used format by 3D cameras.\n#\n# History:\n# 2014-03-13 Feneric   Created\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport itertools\nimport os\nimport struct\nfrom typing import IO\n\nfrom . import (\n    Image,\n    ImageSequence,\n    JpegImagePlugin,\n    TiffImagePlugin,\n)\nfrom ._binary import o32le\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    JpegImagePlugin._save(im, fp, filename)\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    append_images = im.encoderinfo.get(\"append_images\", [])\n    if not append_images and not getattr(im, \"is_animated\", False):\n        _save(im, fp, filename)\n        return\n\n    mpf_offset = 28\n    offsets: list[int] = []\n    for imSequence in itertools.chain([im], append_images):\n        for im_frame in ImageSequence.Iterator(imSequence):\n            if not offsets:\n                # APP2 marker\n                im_frame.encoderinfo[\"extra\"] = (\n                    b\"\\xFF\\xE2\" + struct.pack(\">H\", 6 + 82) + b\"MPF\\0\" + b\" \" * 82\n                )\n                exif = im_frame.encoderinfo.get(\"exif\")\n                if isinstance(exif, Image.Exif):\n                    exif = exif.tobytes()\n                    im_frame.encoderinfo[\"exif\"] = exif\n                if exif:\n                    mpf_offset += 4 + len(exif)\n\n                JpegImagePlugin._save(im_frame, fp, filename)\n                offsets.append(fp.tell())\n            else:\n                im_frame.save(fp, \"JPEG\")\n                offsets.append(fp.tell() - offsets[-1])\n\n    ifd = TiffImagePlugin.ImageFileDirectory_v2()\n    ifd[0xB000] = b\"0100\"\n    ifd[0xB001] = len(offsets)\n\n    mpentries = b\"\"\n    data_offset = 0\n    for i, size in enumerate(offsets):\n        if i == 0:\n            mptype = 0x030000  # Baseline MP Primary Image\n        else:\n            mptype = 0x000000  # Undefined\n        mpentries += struct.pack(\"<LLLHH\", mptype, size, data_offset, 0, 0)\n        if i == 0:\n            data_offset -= mpf_offset\n        data_offset += size\n    ifd[0xB002] = mpentries\n\n    fp.seek(mpf_offset)\n    fp.write(b\"II\\x2A\\x00\" + o32le(8) + ifd.tobytes(8))\n    fp.seek(0, os.SEEK_END)\n\n\n##\n# Image plugin for MPO images.\n\n\nclass MpoImageFile(JpegImagePlugin.JpegImageFile):\n    format = \"MPO\"\n    format_description = \"MPO (CIPA DC-007)\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        self.fp.seek(0)  # prep the fp in order to pass the JPEG test\n        JpegImagePlugin.JpegImageFile._open(self)\n        self._after_jpeg_open()\n\n    def _after_jpeg_open(self, mpheader=None):\n        self.mpinfo = mpheader if mpheader is not None else self._getmp()\n        self.n_frames = self.mpinfo[0xB001]\n        self.__mpoffsets = [\n            mpent[\"DataOffset\"] + self.info[\"mpoffset\"] for mpent in self.mpinfo[0xB002]\n        ]\n        self.__mpoffsets[0] = 0\n        # Note that the following assertion will only be invalid if something\n        # gets broken within JpegImagePlugin.\n        assert self.n_frames == len(self.__mpoffsets)\n        del self.info[\"mpoffset\"]  # no longer needed\n        self.is_animated = self.n_frames > 1\n        self._fp = self.fp  # FIXME: hack\n        self._fp.seek(self.__mpoffsets[0])  # get ready to read first frame\n        self.__frame = 0\n        self.offset = 0\n        # for now we can only handle reading and individual frame extraction\n        self.readonly = 1\n\n    def load_seek(self, pos: int) -> None:\n        self._fp.seek(pos)\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        self.fp = self._fp\n        self.offset = self.__mpoffsets[frame]\n\n        original_exif = self.info.get(\"exif\")\n        if \"exif\" in self.info:\n            del self.info[\"exif\"]\n\n        self.fp.seek(self.offset + 2)  # skip SOI marker\n        if not self.fp.read(2):\n            msg = \"No data found for frame\"\n            raise ValueError(msg)\n        self.fp.seek(self.offset)\n        JpegImagePlugin.JpegImageFile._open(self)\n        if self.info.get(\"exif\") != original_exif:\n            self._reload_exif()\n\n        self.tile = [(\"jpeg\", (0, 0) + self.size, self.offset, self.tile[0][-1])]\n        self.__frame = frame\n\n    def tell(self) -> int:\n        return self.__frame\n\n    @staticmethod\n    def adopt(jpeg_instance, mpheader=None):\n        \"\"\"\n        Transform the instance of JpegImageFile into\n        an instance of MpoImageFile.\n        After the call, the JpegImageFile is extended\n        to be an MpoImageFile.\n\n        This is essentially useful when opening a JPEG\n        file that reveals itself as an MPO, to avoid\n        double call to _open.\n        \"\"\"\n        jpeg_instance.__class__ = MpoImageFile\n        jpeg_instance._after_jpeg_open(mpheader)\n        return jpeg_instance\n\n\n# ---------------------------------------------------------------------\n# Registry stuff\n\n# Note that since MPO shares a factory with JPEG, we do not need to do a\n# separate registration for it here.\n# Image.register_open(MpoImageFile.format,\n#                     JpegImagePlugin.jpeg_factory, _accept)\nImage.register_save(MpoImageFile.format, _save)\nImage.register_save_all(MpoImageFile.format, _save_all)\n\nImage.register_extension(MpoImageFile.format, \".mpo\")\n\nImage.register_mime(MpoImageFile.format, \"image/mpo\")\n", "src/PIL/BlpImagePlugin.py": "\"\"\"\nBlizzard Mipmap Format (.blp)\nJerome Leclanche <jerome@leclan.ch>\n\nThe contents of this file are hereby released in the public domain (CC0)\nFull text of the CC0 license:\n  https://creativecommons.org/publicdomain/zero/1.0/\n\nBLP1 files, used mostly in Warcraft III, are not fully supported.\nAll types of BLP2 files used in World of Warcraft are supported.\n\nThe BLP file structure consists of a header, up to 16 mipmaps of the\ntexture\n\nTexture sizes must be powers of two, though the two dimensions do\nnot have to be equal; 512x256 is valid, but 512x200 is not.\nThe first mipmap (mipmap #0) is the full size image; each subsequent\nmipmap halves both dimensions. The final mipmap should be 1x1.\n\nBLP files come in many different flavours:\n* JPEG-compressed (type == 0) - only supported for BLP1.\n* RAW images (type == 1, encoding == 1). Each mipmap is stored as an\n  array of 8-bit values, one per pixel, left to right, top to bottom.\n  Each value is an index to the palette.\n* DXT-compressed (type == 1, encoding == 2):\n- DXT1 compression is used if alpha_encoding == 0.\n  - An additional alpha bit is used if alpha_depth == 1.\n  - DXT3 compression is used if alpha_encoding == 1.\n  - DXT5 compression is used if alpha_encoding == 7.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport os\nimport struct\nfrom enum import IntEnum\nfrom io import BytesIO\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n\nclass Format(IntEnum):\n    JPEG = 0\n\n\nclass Encoding(IntEnum):\n    UNCOMPRESSED = 1\n    DXT = 2\n    UNCOMPRESSED_RAW_BGRA = 3\n\n\nclass AlphaEncoding(IntEnum):\n    DXT1 = 0\n    DXT3 = 1\n    DXT5 = 7\n\n\ndef unpack_565(i: int) -> tuple[int, int, int]:\n    return ((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3\n\n\ndef decode_dxt1(\n    data: bytes, alpha: bool = False\n) -> tuple[bytearray, bytearray, bytearray, bytearray]:\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n\n    for block_index in range(blocks):\n        # Decode next 8-byte block.\n        idx = block_index * 8\n        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)\n\n        r0, g0, b0 = unpack_565(color0)\n        r1, g1, b1 = unpack_565(color1)\n\n        # Decode this block into 4x4 pixels\n        # Accumulate the results onto our 4 row accumulators\n        for j in range(4):\n            for i in range(4):\n                # get next control op and generate a pixel\n\n                control = bits & 3\n                bits = bits >> 2\n\n                a = 0xFF\n                if control == 0:\n                    r, g, b = r0, g0, b0\n                elif control == 1:\n                    r, g, b = r1, g1, b1\n                elif control == 2:\n                    if color0 > color1:\n                        r = (2 * r0 + r1) // 3\n                        g = (2 * g0 + g1) // 3\n                        b = (2 * b0 + b1) // 3\n                    else:\n                        r = (r0 + r1) // 2\n                        g = (g0 + g1) // 2\n                        b = (b0 + b1) // 2\n                elif control == 3:\n                    if color0 > color1:\n                        r = (2 * r1 + r0) // 3\n                        g = (2 * g1 + g0) // 3\n                        b = (2 * b1 + b0) // 3\n                    else:\n                        r, g, b, a = 0, 0, 0, 0\n\n                if alpha:\n                    ret[j].extend([r, g, b, a])\n                else:\n                    ret[j].extend([r, g, b])\n\n    return ret\n\n\ndef decode_dxt3(data: bytes) -> tuple[bytearray, bytearray, bytearray, bytearray]:\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n\n    for block_index in range(blocks):\n        idx = block_index * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.\n        bits = struct.unpack_from(\"<8B\", block)\n        color0, color1 = struct.unpack_from(\"<HH\", block, 8)\n\n        (code,) = struct.unpack_from(\"<I\", block, 12)\n\n        r0, g0, b0 = unpack_565(color0)\n        r1, g1, b1 = unpack_565(color1)\n\n        for j in range(4):\n            high = False  # Do we want the higher bits?\n            for i in range(4):\n                alphacode_index = (4 * j + i) // 2\n                a = bits[alphacode_index]\n                if high:\n                    high = False\n                    a >>= 4\n                else:\n                    high = True\n                    a &= 0xF\n                a *= 17  # We get a value between 0 and 15\n\n                color_code = (code >> 2 * (4 * j + i)) & 0x03\n\n                if color_code == 0:\n                    r, g, b = r0, g0, b0\n                elif color_code == 1:\n                    r, g, b = r1, g1, b1\n                elif color_code == 2:\n                    r = (2 * r0 + r1) // 3\n                    g = (2 * g0 + g1) // 3\n                    b = (2 * b0 + b1) // 3\n                elif color_code == 3:\n                    r = (2 * r1 + r0) // 3\n                    g = (2 * g1 + g0) // 3\n                    b = (2 * b1 + b0) // 3\n\n                ret[j].extend([r, g, b, a])\n\n    return ret\n\n\ndef decode_dxt5(data: bytes) -> tuple[bytearray, bytearray, bytearray, bytearray]:\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4 * width pixels)\n    \"\"\"\n\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n\n    for block_index in range(blocks):\n        idx = block_index * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.\n        a0, a1 = struct.unpack_from(\"<BB\", block)\n\n        bits = struct.unpack_from(\"<6B\", block, 2)\n        alphacode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24)\n        alphacode2 = bits[0] | (bits[1] << 8)\n\n        color0, color1 = struct.unpack_from(\"<HH\", block, 8)\n\n        (code,) = struct.unpack_from(\"<I\", block, 12)\n\n        r0, g0, b0 = unpack_565(color0)\n        r1, g1, b1 = unpack_565(color1)\n\n        for j in range(4):\n            for i in range(4):\n                # get next control op and generate a pixel\n                alphacode_index = 3 * (4 * j + i)\n\n                if alphacode_index <= 12:\n                    alphacode = (alphacode2 >> alphacode_index) & 0x07\n                elif alphacode_index == 15:\n                    alphacode = (alphacode2 >> 15) | ((alphacode1 << 1) & 0x06)\n                else:  # alphacode_index >= 18 and alphacode_index <= 45\n                    alphacode = (alphacode1 >> (alphacode_index - 16)) & 0x07\n\n                if alphacode == 0:\n                    a = a0\n                elif alphacode == 1:\n                    a = a1\n                elif a0 > a1:\n                    a = ((8 - alphacode) * a0 + (alphacode - 1) * a1) // 7\n                elif alphacode == 6:\n                    a = 0\n                elif alphacode == 7:\n                    a = 255\n                else:\n                    a = ((6 - alphacode) * a0 + (alphacode - 1) * a1) // 5\n\n                color_code = (code >> 2 * (4 * j + i)) & 0x03\n\n                if color_code == 0:\n                    r, g, b = r0, g0, b0\n                elif color_code == 1:\n                    r, g, b = r1, g1, b1\n                elif color_code == 2:\n                    r = (2 * r0 + r1) // 3\n                    g = (2 * g0 + g1) // 3\n                    b = (2 * b0 + b1) // 3\n                elif color_code == 3:\n                    r = (2 * r1 + r0) // 3\n                    g = (2 * g1 + g0) // 3\n                    b = (2 * b1 + b0) // 3\n\n                ret[j].extend([r, g, b, a])\n\n    return ret\n\n\nclass BLPFormatError(NotImplementedError):\n    pass\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] in (b\"BLP1\", b\"BLP2\")\n\n\nclass BlpImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Blizzard Mipmap Format\n    \"\"\"\n\n    format = \"BLP\"\n    format_description = \"Blizzard Mipmap Format\"\n\n    def _open(self) -> None:\n        self.magic = self.fp.read(4)\n\n        self.fp.seek(5, os.SEEK_CUR)\n        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fp.read(1))\n\n        self.fp.seek(2, os.SEEK_CUR)\n        self._size = struct.unpack(\"<II\", self.fp.read(8))\n\n        if self.magic in (b\"BLP1\", b\"BLP2\"):\n            decoder = self.magic.decode()\n        else:\n            msg = f\"Bad BLP magic {repr(self.magic)}\"\n            raise BLPFormatError(msg)\n\n        self._mode = \"RGBA\" if self._blp_alpha_depth else \"RGB\"\n        self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]\n\n\nclass _BLPBaseDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        try:\n            self._read_blp_header()\n            self._load()\n        except struct.error as e:\n            msg = \"Truncated BLP file\"\n            raise OSError(msg) from e\n        return -1, 0\n\n    @abc.abstractmethod\n    def _load(self) -> None:\n        pass\n\n    def _read_blp_header(self) -> None:\n        assert self.fd is not None\n        self.fd.seek(4)\n        (self._blp_compression,) = struct.unpack(\"<i\", self._safe_read(4))\n\n        (self._blp_encoding,) = struct.unpack(\"<b\", self._safe_read(1))\n        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self._safe_read(1))\n        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self._safe_read(1))\n        self.fd.seek(1, os.SEEK_CUR)  # mips\n\n        self.size = struct.unpack(\"<II\", self._safe_read(8))\n\n        if isinstance(self, BLP1Decoder):\n            # Only present for BLP1\n            (self._blp_encoding,) = struct.unpack(\"<i\", self._safe_read(4))\n            self.fd.seek(4, os.SEEK_CUR)  # subtype\n\n        self._blp_offsets = struct.unpack(\"<16I\", self._safe_read(16 * 4))\n        self._blp_lengths = struct.unpack(\"<16I\", self._safe_read(16 * 4))\n\n    def _safe_read(self, length: int) -> bytes:\n        return ImageFile._safe_read(self.fd, length)\n\n    def _read_palette(self) -> list[tuple[int, int, int, int]]:\n        ret = []\n        for i in range(256):\n            try:\n                b, g, r, a = struct.unpack(\"<4B\", self._safe_read(4))\n            except struct.error:\n                break\n            ret.append((b, g, r, a))\n        return ret\n\n    def _read_bgra(self, palette: list[tuple[int, int, int, int]]) -> bytearray:\n        data = bytearray()\n        _data = BytesIO(self._safe_read(self._blp_lengths[0]))\n        while True:\n            try:\n                (offset,) = struct.unpack(\"<B\", _data.read(1))\n            except struct.error:\n                break\n            b, g, r, a = palette[offset]\n            d: tuple[int, ...] = (r, g, b)\n            if self._blp_alpha_depth:\n                d += (a,)\n            data.extend(d)\n        return data\n\n\nclass BLP1Decoder(_BLPBaseDecoder):\n    def _load(self) -> None:\n        if self._blp_compression == Format.JPEG:\n            self._decode_jpeg_stream()\n\n        elif self._blp_compression == 1:\n            if self._blp_encoding in (4, 5):\n                palette = self._read_palette()\n                data = self._read_bgra(palette)\n                self.set_as_raw(data)\n            else:\n                msg = f\"Unsupported BLP encoding {repr(self._blp_encoding)}\"\n                raise BLPFormatError(msg)\n        else:\n            msg = f\"Unsupported BLP compression {repr(self._blp_encoding)}\"\n            raise BLPFormatError(msg)\n\n    def _decode_jpeg_stream(self) -> None:\n        from .JpegImagePlugin import JpegImageFile\n\n        (jpeg_header_size,) = struct.unpack(\"<I\", self._safe_read(4))\n        jpeg_header = self._safe_read(jpeg_header_size)\n        assert self.fd is not None\n        self._safe_read(self._blp_offsets[0] - self.fd.tell())  # What IS this?\n        data = self._safe_read(self._blp_lengths[0])\n        data = jpeg_header + data\n        image = JpegImageFile(BytesIO(data))\n        Image._decompression_bomb_check(image.size)\n        if image.mode == \"CMYK\":\n            decoder_name, extents, offset, args = image.tile[0]\n            image.tile = [(decoder_name, extents, offset, (args[0], \"CMYK\"))]\n        r, g, b = image.convert(\"RGB\").split()\n        reversed_image = Image.merge(\"RGB\", (b, g, r))\n        self.set_as_raw(reversed_image.tobytes())\n\n\nclass BLP2Decoder(_BLPBaseDecoder):\n    def _load(self) -> None:\n        palette = self._read_palette()\n\n        assert self.fd is not None\n        self.fd.seek(self._blp_offsets[0])\n\n        if self._blp_compression == 1:\n            # Uncompressed or DirectX compression\n\n            if self._blp_encoding == Encoding.UNCOMPRESSED:\n                data = self._read_bgra(palette)\n\n            elif self._blp_encoding == Encoding.DXT:\n                data = bytearray()\n                if self._blp_alpha_encoding == AlphaEncoding.DXT1:\n                    linesize = (self.size[0] + 3) // 4 * 8\n                    for yb in range((self.size[1] + 3) // 4):\n                        for d in decode_dxt1(\n                            self._safe_read(linesize), alpha=bool(self._blp_alpha_depth)\n                        ):\n                            data += d\n\n                elif self._blp_alpha_encoding == AlphaEncoding.DXT3:\n                    linesize = (self.size[0] + 3) // 4 * 16\n                    for yb in range((self.size[1] + 3) // 4):\n                        for d in decode_dxt3(self._safe_read(linesize)):\n                            data += d\n\n                elif self._blp_alpha_encoding == AlphaEncoding.DXT5:\n                    linesize = (self.size[0] + 3) // 4 * 16\n                    for yb in range((self.size[1] + 3) // 4):\n                        for d in decode_dxt5(self._safe_read(linesize)):\n                            data += d\n                else:\n                    msg = f\"Unsupported alpha encoding {repr(self._blp_alpha_encoding)}\"\n                    raise BLPFormatError(msg)\n            else:\n                msg = f\"Unknown BLP encoding {repr(self._blp_encoding)}\"\n                raise BLPFormatError(msg)\n\n        else:\n            msg = f\"Unknown BLP compression {repr(self._blp_compression)}\"\n            raise BLPFormatError(msg)\n\n        self.set_as_raw(data)\n\n\nclass BLPEncoder(ImageFile.PyEncoder):\n    _pushes_fd = True\n\n    def _write_palette(self) -> bytes:\n        data = b\"\"\n        palette = self.im.getpalette(\"RGBA\", \"RGBA\")\n        for i in range(len(palette) // 4):\n            r, g, b, a = palette[i * 4 : (i + 1) * 4]\n            data += struct.pack(\"<4B\", b, g, r, a)\n        while len(data) < 256 * 4:\n            data += b\"\\x00\" * 4\n        return data\n\n    def encode(self, bufsize: int) -> tuple[int, int, bytes]:\n        palette_data = self._write_palette()\n\n        offset = 20 + 16 * 4 * 2 + len(palette_data)\n        data = struct.pack(\"<16I\", offset, *((0,) * 15))\n\n        w, h = self.im.size\n        data += struct.pack(\"<16I\", w * h, *((0,) * 15))\n\n        data += palette_data\n\n        for y in range(h):\n            for x in range(w):\n                data += struct.pack(\"<B\", self.im.getpixel((x, y)))\n\n        return len(data), 0, data\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode != \"P\":\n        msg = \"Unsupported BLP image mode\"\n        raise ValueError(msg)\n\n    magic = b\"BLP1\" if im.encoderinfo.get(\"blp_version\") == \"BLP1\" else b\"BLP2\"\n    fp.write(magic)\n\n    fp.write(struct.pack(\"<i\", 1))  # Uncompressed or DirectX compression\n    fp.write(struct.pack(\"<b\", Encoding.UNCOMPRESSED))\n    fp.write(struct.pack(\"<b\", 1 if im.palette.mode == \"RGBA\" else 0))\n    fp.write(struct.pack(\"<b\", 0))  # alpha encoding\n    fp.write(struct.pack(\"<b\", 0))  # mips\n    fp.write(struct.pack(\"<II\", *im.size))\n    if magic == b\"BLP1\":\n        fp.write(struct.pack(\"<i\", 5))\n        fp.write(struct.pack(\"<i\", 0))\n\n    ImageFile._save(im, fp, [(\"BLP\", (0, 0) + im.size, 0, im.mode)])\n\n\nImage.register_open(BlpImageFile.format, BlpImageFile, _accept)\nImage.register_extension(BlpImageFile.format, \".blp\")\nImage.register_decoder(\"BLP1\", BLP1Decoder)\nImage.register_decoder(\"BLP2\", BLP2Decoder)\n\nImage.register_save(BlpImageFile.format, _save)\nImage.register_encoder(\"BLP\", BLPEncoder)\n", "src/PIL/BufrStubImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# BUFR stub adapter\n#\n# Copyright (c) 1996-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific BUFR image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\n# --------------------------------------------------------------------\n# Image adapter\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"BUFR\" or prefix[:4] == b\"ZCZC\"\n\n\nclass BufrStubImageFile(ImageFile.StubImageFile):\n    format = \"BUFR\"\n    format_description = \"BUFR\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        if not _accept(self.fp.read(4)):\n            msg = \"Not a BUFR file\"\n            raise SyntaxError(msg)\n\n        self.fp.seek(offset)\n\n        # make something up\n        self._mode = \"F\"\n        self._size = 1, 1\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"BUFR save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(BufrStubImageFile.format, BufrStubImageFile, _accept)\nImage.register_save(BufrStubImageFile.format, _save)\n\nImage.register_extension(BufrStubImageFile.format, \".bufr\")\n", "src/PIL/PcfFontFile.py": "#\n# THIS IS WORK IN PROGRESS\n#\n# The Python Imaging Library\n# $Id$\n#\n# portable compiled font file parser\n#\n# history:\n# 1997-08-19 fl   created\n# 2003-09-13 fl   fixed loading of unicode fonts\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1997-2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nfrom typing import BinaryIO, Callable\n\nfrom . import FontFile, Image\nfrom ._binary import i8\nfrom ._binary import i16be as b16\nfrom ._binary import i16le as l16\nfrom ._binary import i32be as b32\nfrom ._binary import i32le as l32\n\n# --------------------------------------------------------------------\n# declarations\n\nPCF_MAGIC = 0x70636601  # \"\\x01fcp\"\n\nPCF_PROPERTIES = 1 << 0\nPCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\n\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\n\n\ndef sz(s: bytes, o: int) -> bytes:\n    return s[o : s.index(b\"\\0\", o)]\n\n\nclass PcfFontFile(FontFile.FontFile):\n    \"\"\"Font file plugin for the X11 PCF format.\"\"\"\n\n    name = \"name\"\n\n    def __init__(self, fp: BinaryIO, charset_encoding: str = \"iso8859-1\"):\n        self.charset_encoding = charset_encoding\n\n        magic = l32(fp.read(4))\n        if magic != PCF_MAGIC:\n            msg = \"not a PCF file\"\n            raise SyntaxError(msg)\n\n        super().__init__()\n\n        count = l32(fp.read(4))\n        self.toc = {}\n        for i in range(count):\n            type = l32(fp.read(4))\n            self.toc[type] = l32(fp.read(4)), l32(fp.read(4)), l32(fp.read(4))\n\n        self.fp = fp\n\n        self.info = self._load_properties()\n\n        metrics = self._load_metrics()\n        bitmaps = self._load_bitmaps(metrics)\n        encoding = self._load_encoding()\n\n        #\n        # create glyph structure\n\n        for ch, ix in enumerate(encoding):\n            if ix is not None:\n                (\n                    xsize,\n                    ysize,\n                    left,\n                    right,\n                    width,\n                    ascent,\n                    descent,\n                    attributes,\n                ) = metrics[ix]\n                self.glyph[ch] = (\n                    (width, 0),\n                    (left, descent - ysize, xsize + left, descent),\n                    (0, 0, xsize, ysize),\n                    bitmaps[ix],\n                )\n\n    def _getformat(\n        self, tag: int\n    ) -> tuple[BinaryIO, int, Callable[[bytes], int], Callable[[bytes], int]]:\n        format, size, offset = self.toc[tag]\n\n        fp = self.fp\n        fp.seek(offset)\n\n        format = l32(fp.read(4))\n\n        if format & 4:\n            i16, i32 = b16, b32\n        else:\n            i16, i32 = l16, l32\n\n        return fp, format, i16, i32\n\n    def _load_properties(self) -> dict[bytes, bytes | int]:\n        #\n        # font properties\n\n        properties = {}\n\n        fp, format, i16, i32 = self._getformat(PCF_PROPERTIES)\n\n        nprops = i32(fp.read(4))\n\n        # read property description\n        p = [(i32(fp.read(4)), i8(fp.read(1)), i32(fp.read(4))) for _ in range(nprops)]\n\n        if nprops & 3:\n            fp.seek(4 - (nprops & 3), io.SEEK_CUR)  # pad\n\n        data = fp.read(i32(fp.read(4)))\n\n        for k, s, v in p:\n            property_value: bytes | int = sz(data, v) if s else v\n            properties[sz(data, k)] = property_value\n\n        return properties\n\n    def _load_metrics(self) -> list[tuple[int, int, int, int, int, int, int, int]]:\n        #\n        # font metrics\n\n        metrics: list[tuple[int, int, int, int, int, int, int, int]] = []\n\n        fp, format, i16, i32 = self._getformat(PCF_METRICS)\n\n        append = metrics.append\n\n        if (format & 0xFF00) == 0x100:\n            # \"compressed\" metrics\n            for i in range(i16(fp.read(2))):\n                left = i8(fp.read(1)) - 128\n                right = i8(fp.read(1)) - 128\n                width = i8(fp.read(1)) - 128\n                ascent = i8(fp.read(1)) - 128\n                descent = i8(fp.read(1)) - 128\n                xsize = right - left\n                ysize = ascent + descent\n                append((xsize, ysize, left, right, width, ascent, descent, 0))\n\n        else:\n            # \"jumbo\" metrics\n            for i in range(i32(fp.read(4))):\n                left = i16(fp.read(2))\n                right = i16(fp.read(2))\n                width = i16(fp.read(2))\n                ascent = i16(fp.read(2))\n                descent = i16(fp.read(2))\n                attributes = i16(fp.read(2))\n                xsize = right - left\n                ysize = ascent + descent\n                append((xsize, ysize, left, right, width, ascent, descent, attributes))\n\n        return metrics\n\n    def _load_bitmaps(\n        self, metrics: list[tuple[int, int, int, int, int, int, int, int]]\n    ) -> list[Image.Image]:\n        #\n        # bitmap data\n\n        fp, format, i16, i32 = self._getformat(PCF_BITMAPS)\n\n        nbitmaps = i32(fp.read(4))\n\n        if nbitmaps != len(metrics):\n            msg = \"Wrong number of bitmaps\"\n            raise OSError(msg)\n\n        offsets = [i32(fp.read(4)) for _ in range(nbitmaps)]\n\n        bitmap_sizes = [i32(fp.read(4)) for _ in range(4)]\n\n        # byteorder = format & 4  # non-zero => MSB\n        bitorder = format & 8  # non-zero => MSB\n        padindex = format & 3\n\n        bitmapsize = bitmap_sizes[padindex]\n        offsets.append(bitmapsize)\n\n        data = fp.read(bitmapsize)\n\n        pad = BYTES_PER_ROW[padindex]\n        mode = \"1;R\"\n        if bitorder:\n            mode = \"1\"\n\n        bitmaps = []\n        for i in range(nbitmaps):\n            xsize, ysize = metrics[i][:2]\n            b, e = offsets[i : i + 2]\n            bitmaps.append(\n                Image.frombytes(\"1\", (xsize, ysize), data[b:e], \"raw\", mode, pad(xsize))\n            )\n\n        return bitmaps\n\n    def _load_encoding(self) -> list[int | None]:\n        fp, format, i16, i32 = self._getformat(PCF_BDF_ENCODINGS)\n\n        first_col, last_col = i16(fp.read(2)), i16(fp.read(2))\n        first_row, last_row = i16(fp.read(2)), i16(fp.read(2))\n\n        i16(fp.read(2))  # default\n\n        nencoding = (last_col - first_col + 1) * (last_row - first_row + 1)\n\n        # map character code to bitmap index\n        encoding: list[int | None] = [None] * min(256, nencoding)\n\n        encoding_offsets = [i16(fp.read(2)) for _ in range(nencoding)]\n\n        for i in range(first_col, len(encoding)):\n            try:\n                encoding_offset = encoding_offsets[\n                    ord(bytearray([i]).decode(self.charset_encoding))\n                ]\n                if encoding_offset != 0xFFFF:\n                    encoding[i] = encoding_offset\n            except UnicodeDecodeError:\n                # character is not supported in selected encoding\n                pass\n\n        return encoding\n", "src/PIL/TgaImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# TGA file handling\n#\n# History:\n# 95-09-01 fl   created (reads 24-bit files only)\n# 97-01-04 fl   support more TGA versions, including compressed images\n# 98-07-04 fl   fixed orientation and alpha layer bugs\n# 98-09-11 fl   fixed orientation for runlength decoder\n#\n# Copyright (c) Secret Labs AB 1997-98.\n# Copyright (c) Fredrik Lundh 1995-97.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport warnings\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import o8\nfrom ._binary import o16le as o16\n\n#\n# --------------------------------------------------------------------\n# Read RGA file\n\n\nMODES = {\n    # map imagetype/depth to rawmode\n    (1, 8): \"P\",\n    (3, 1): \"1\",\n    (3, 8): \"L\",\n    (3, 16): \"LA\",\n    (2, 16): \"BGR;5\",\n    (2, 24): \"BGR\",\n    (2, 32): \"BGRA\",\n}\n\n\n##\n# Image plugin for Targa files.\n\n\nclass TgaImageFile(ImageFile.ImageFile):\n    format = \"TGA\"\n    format_description = \"Targa\"\n\n    def _open(self) -> None:\n        # process header\n        assert self.fp is not None\n\n        s = self.fp.read(18)\n\n        id_len = s[0]\n\n        colormaptype = s[1]\n        imagetype = s[2]\n\n        depth = s[16]\n\n        flags = s[17]\n\n        self._size = i16(s, 12), i16(s, 14)\n\n        # validate header fields\n        if (\n            colormaptype not in (0, 1)\n            or self.size[0] <= 0\n            or self.size[1] <= 0\n            or depth not in (1, 8, 16, 24, 32)\n        ):\n            msg = \"not a TGA file\"\n            raise SyntaxError(msg)\n\n        # image mode\n        if imagetype in (3, 11):\n            self._mode = \"L\"\n            if depth == 1:\n                self._mode = \"1\"  # ???\n            elif depth == 16:\n                self._mode = \"LA\"\n        elif imagetype in (1, 9):\n            self._mode = \"P\" if colormaptype else \"L\"\n        elif imagetype in (2, 10):\n            self._mode = \"RGB\"\n            if depth == 32:\n                self._mode = \"RGBA\"\n        else:\n            msg = \"unknown TGA mode\"\n            raise SyntaxError(msg)\n\n        # orientation\n        orientation = flags & 0x30\n        self._flip_horizontally = orientation in [0x10, 0x30]\n        if orientation in [0x20, 0x30]:\n            orientation = 1\n        elif orientation in [0, 0x10]:\n            orientation = -1\n        else:\n            msg = \"unknown TGA orientation\"\n            raise SyntaxError(msg)\n\n        self.info[\"orientation\"] = orientation\n\n        if imagetype & 8:\n            self.info[\"compression\"] = \"tga_rle\"\n\n        if id_len:\n            self.info[\"id_section\"] = self.fp.read(id_len)\n\n        if colormaptype:\n            # read palette\n            start, size, mapdepth = i16(s, 3), i16(s, 5), s[7]\n            if mapdepth == 16:\n                self.palette = ImagePalette.raw(\n                    \"BGR;15\", b\"\\0\" * 2 * start + self.fp.read(2 * size)\n                )\n            elif mapdepth == 24:\n                self.palette = ImagePalette.raw(\n                    \"BGR\", b\"\\0\" * 3 * start + self.fp.read(3 * size)\n                )\n            elif mapdepth == 32:\n                self.palette = ImagePalette.raw(\n                    \"BGRA\", b\"\\0\" * 4 * start + self.fp.read(4 * size)\n                )\n            else:\n                msg = \"unknown TGA map depth\"\n                raise SyntaxError(msg)\n\n        # setup tile descriptor\n        try:\n            rawmode = MODES[(imagetype & 7, depth)]\n            if imagetype & 8:\n                # compressed\n                self.tile = [\n                    (\n                        \"tga_rle\",\n                        (0, 0) + self.size,\n                        self.fp.tell(),\n                        (rawmode, orientation, depth),\n                    )\n                ]\n            else:\n                self.tile = [\n                    (\n                        \"raw\",\n                        (0, 0) + self.size,\n                        self.fp.tell(),\n                        (rawmode, 0, orientation),\n                    )\n                ]\n        except KeyError:\n            pass  # cannot decode\n\n    def load_end(self) -> None:\n        if self._flip_horizontally:\n            assert self.im is not None\n            self.im = self.im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)\n\n\n#\n# --------------------------------------------------------------------\n# Write TGA file\n\n\nSAVE = {\n    \"1\": (\"1\", 1, 0, 3),\n    \"L\": (\"L\", 8, 0, 3),\n    \"LA\": (\"LA\", 16, 0, 3),\n    \"P\": (\"P\", 8, 1, 1),\n    \"RGB\": (\"BGR\", 24, 0, 2),\n    \"RGBA\": (\"BGRA\", 32, 0, 2),\n}\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    try:\n        rawmode, bits, colormaptype, imagetype = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as TGA\"\n        raise OSError(msg) from e\n\n    if \"rle\" in im.encoderinfo:\n        rle = im.encoderinfo[\"rle\"]\n    else:\n        compression = im.encoderinfo.get(\"compression\", im.info.get(\"compression\"))\n        rle = compression == \"tga_rle\"\n    if rle:\n        imagetype += 8\n\n    id_section = im.encoderinfo.get(\"id_section\", im.info.get(\"id_section\", \"\"))\n    id_len = len(id_section)\n    if id_len > 255:\n        id_len = 255\n        id_section = id_section[:255]\n        warnings.warn(\"id_section has been trimmed to 255 characters\")\n\n    if colormaptype:\n        assert im.im is not None\n        palette = im.im.getpalette(\"RGB\", \"BGR\")\n        colormaplength, colormapentry = len(palette) // 3, 24\n    else:\n        colormaplength, colormapentry = 0, 0\n\n    if im.mode in (\"LA\", \"RGBA\"):\n        flags = 8\n    else:\n        flags = 0\n\n    orientation = im.encoderinfo.get(\"orientation\", im.info.get(\"orientation\", -1))\n    if orientation > 0:\n        flags = flags | 0x20\n\n    fp.write(\n        o8(id_len)\n        + o8(colormaptype)\n        + o8(imagetype)\n        + o16(0)  # colormapfirst\n        + o16(colormaplength)\n        + o8(colormapentry)\n        + o16(0)\n        + o16(0)\n        + o16(im.size[0])\n        + o16(im.size[1])\n        + o8(bits)\n        + o8(flags)\n    )\n\n    if id_section:\n        fp.write(id_section)\n\n    if colormaptype:\n        fp.write(palette)\n\n    if rle:\n        ImageFile._save(\n            im, fp, [(\"tga_rle\", (0, 0) + im.size, 0, (rawmode, orientation))]\n        )\n    else:\n        ImageFile._save(\n            im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, orientation))]\n        )\n\n    # write targa version 2 footer\n    fp.write(b\"\\000\" * 8 + b\"TRUEVISION-XFILE.\" + b\"\\000\")\n\n\n#\n# --------------------------------------------------------------------\n# Registry\n\n\nImage.register_open(TgaImageFile.format, TgaImageFile)\nImage.register_save(TgaImageFile.format, _save)\n\nImage.register_extensions(TgaImageFile.format, [\".tga\", \".icb\", \".vda\", \".vst\"])\n\nImage.register_mime(TgaImageFile.format, \"image/x-tga\")\n", "src/PIL/MicImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Microsoft Image Composer support for PIL\n#\n# Notes:\n#       uses TiffImagePlugin.py to read the actual image streams\n#\n# History:\n#       97-01-20 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport olefile\n\nfrom . import Image, TiffImagePlugin\n\n#\n# --------------------------------------------------------------------\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == olefile.MAGIC\n\n\n##\n# Image plugin for Microsoft's Image Composer file format.\n\n\nclass MicImageFile(TiffImagePlugin.TiffImageFile):\n    format = \"MIC\"\n    format_description = \"Microsoft Image Composer\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # read the OLE directory and see if this is a likely\n        # to be a Microsoft Image Composer file\n\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except OSError as e:\n            msg = \"not an MIC file; invalid OLE file\"\n            raise SyntaxError(msg) from e\n\n        # find ACI subfiles with Image members (maybe not the\n        # best way to identify MIC files, but what the... ;-)\n\n        self.images = [\n            path\n            for path in self.ole.listdir()\n            if path[1:] and path[0][-4:] == \".ACI\" and path[1] == \"Image\"\n        ]\n\n        # if we didn't find any images, this is probably not\n        # an MIC file.\n        if not self.images:\n            msg = \"not an MIC file; no image entries\"\n            raise SyntaxError(msg)\n\n        self.frame = -1\n        self._n_frames = len(self.images)\n        self.is_animated = self._n_frames > 1\n\n        self.__fp = self.fp\n        self.seek(0)\n\n    def seek(self, frame):\n        if not self._seek_check(frame):\n            return\n        try:\n            filename = self.images[frame]\n        except IndexError as e:\n            msg = \"no such frame\"\n            raise EOFError(msg) from e\n\n        self.fp = self.ole.openstream(filename)\n\n        TiffImagePlugin.TiffImageFile._open(self)\n\n        self.frame = frame\n\n    def tell(self) -> int:\n        return self.frame\n\n    def close(self) -> None:\n        self.__fp.close()\n        self.ole.close()\n        super().close()\n\n    def __exit__(self, *args: object) -> None:\n        self.__fp.close()\n        self.ole.close()\n        super().__exit__()\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(MicImageFile.format, MicImageFile, _accept)\n\nImage.register_extension(MicImageFile.format, \".mic\")\n", "src/PIL/PcxImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PCX file handling\n#\n# This format was originally used by ZSoft's popular PaintBrush\n# program for the IBM PC.  It is also supported by many MS-DOS and\n# Windows applications, including the Windows PaintBrush program in\n# Windows 3.\n#\n# history:\n# 1995-09-01 fl   Created\n# 1996-05-20 fl   Fixed RGB support\n# 1997-01-03 fl   Fixed 2-bit and 4-bit support\n# 1999-02-03 fl   Fixed 8-bit support (broken in 1.0b1)\n# 1999-02-07 fl   Added write support\n# 2002-06-09 fl   Made 2-bit and 4-bit support a bit more robust\n# 2002-07-30 fl   Seek from to current position, not beginning of file\n# 2003-06-03 fl   Extract DPI settings (info[\"dpi\"])\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport logging\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import o8\nfrom ._binary import o16le as o16\n\nlogger = logging.getLogger(__name__)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[0] == 10 and prefix[1] in [0, 2, 3, 5]\n\n\n##\n# Image plugin for Paintbrush images.\n\n\nclass PcxImageFile(ImageFile.ImageFile):\n    format = \"PCX\"\n    format_description = \"Paintbrush\"\n\n    def _open(self) -> None:\n        # header\n        assert self.fp is not None\n\n        s = self.fp.read(128)\n        if not _accept(s):\n            msg = \"not a PCX file\"\n            raise SyntaxError(msg)\n\n        # image\n        bbox = i16(s, 4), i16(s, 6), i16(s, 8) + 1, i16(s, 10) + 1\n        if bbox[2] <= bbox[0] or bbox[3] <= bbox[1]:\n            msg = \"bad PCX image size\"\n            raise SyntaxError(msg)\n        logger.debug(\"BBox: %s %s %s %s\", *bbox)\n\n        # format\n        version = s[1]\n        bits = s[3]\n        planes = s[65]\n        provided_stride = i16(s, 66)\n        logger.debug(\n            \"PCX version %s, bits %s, planes %s, stride %s\",\n            version,\n            bits,\n            planes,\n            provided_stride,\n        )\n\n        self.info[\"dpi\"] = i16(s, 12), i16(s, 14)\n\n        if bits == 1 and planes == 1:\n            mode = rawmode = \"1\"\n\n        elif bits == 1 and planes in (2, 4):\n            mode = \"P\"\n            rawmode = \"P;%dL\" % planes\n            self.palette = ImagePalette.raw(\"RGB\", s[16:64])\n\n        elif version == 5 and bits == 8 and planes == 1:\n            mode = rawmode = \"L\"\n            # FIXME: hey, this doesn't work with the incremental loader !!!\n            self.fp.seek(-769, io.SEEK_END)\n            s = self.fp.read(769)\n            if len(s) == 769 and s[0] == 12:\n                # check if the palette is linear grayscale\n                for i in range(256):\n                    if s[i * 3 + 1 : i * 3 + 4] != o8(i) * 3:\n                        mode = rawmode = \"P\"\n                        break\n                if mode == \"P\":\n                    self.palette = ImagePalette.raw(\"RGB\", s[1:])\n            self.fp.seek(128)\n\n        elif version == 5 and bits == 8 and planes == 3:\n            mode = \"RGB\"\n            rawmode = \"RGB;L\"\n\n        else:\n            msg = \"unknown PCX mode\"\n            raise OSError(msg)\n\n        self._mode = mode\n        self._size = bbox[2] - bbox[0], bbox[3] - bbox[1]\n\n        # Don't trust the passed in stride.\n        # Calculate the approximate position for ourselves.\n        # CVE-2020-35653\n        stride = (self._size[0] * bits + 7) // 8\n\n        # While the specification states that this must be even,\n        # not all images follow this\n        if provided_stride != stride:\n            stride += stride % 2\n\n        bbox = (0, 0) + self.size\n        logger.debug(\"size: %sx%s\", *self.size)\n\n        self.tile = [(\"pcx\", bbox, self.fp.tell(), (rawmode, planes * stride))]\n\n\n# --------------------------------------------------------------------\n# save PCX files\n\n\nSAVE = {\n    # mode: (version, bits, planes, raw mode)\n    \"1\": (2, 1, 1, \"1\"),\n    \"L\": (5, 8, 1, \"L\"),\n    \"P\": (5, 8, 1, \"P\"),\n    \"RGB\": (5, 8, 3, \"RGB;L\"),\n}\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    try:\n        version, bits, planes, rawmode = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"Cannot save {im.mode} images as PCX\"\n        raise ValueError(msg) from e\n\n    # bytes per plane\n    stride = (im.size[0] * bits + 7) // 8\n    # stride should be even\n    stride += stride % 2\n    # Stride needs to be kept in sync with the PcxEncode.c version.\n    # Ideally it should be passed in in the state, but the bytes value\n    # gets overwritten.\n\n    logger.debug(\n        \"PcxImagePlugin._save: xwidth: %d, bits: %d, stride: %d\",\n        im.size[0],\n        bits,\n        stride,\n    )\n\n    # under windows, we could determine the current screen size with\n    # \"Image.core.display_mode()[1]\", but I think that's overkill...\n\n    screen = im.size\n\n    dpi = 100, 100\n\n    # PCX header\n    fp.write(\n        o8(10)\n        + o8(version)\n        + o8(1)\n        + o8(bits)\n        + o16(0)\n        + o16(0)\n        + o16(im.size[0] - 1)\n        + o16(im.size[1] - 1)\n        + o16(dpi[0])\n        + o16(dpi[1])\n        + b\"\\0\" * 24\n        + b\"\\xFF\" * 24\n        + b\"\\0\"\n        + o8(planes)\n        + o16(stride)\n        + o16(1)\n        + o16(screen[0])\n        + o16(screen[1])\n        + b\"\\0\" * 54\n    )\n\n    assert fp.tell() == 128\n\n    ImageFile._save(im, fp, [(\"pcx\", (0, 0) + im.size, 0, (rawmode, bits * planes))])\n\n    if im.mode == \"P\":\n        # colour palette\n        assert im.im is not None\n\n        fp.write(o8(12))\n        palette = im.im.getpalette(\"RGB\", \"RGB\")\n        palette += b\"\\x00\" * (768 - len(palette))\n        fp.write(palette)  # 768 bytes\n    elif im.mode == \"L\":\n        # grayscale palette\n        fp.write(o8(12))\n        for i in range(256):\n            fp.write(o8(i) * 3)\n\n\n# --------------------------------------------------------------------\n# registry\n\n\nImage.register_open(PcxImageFile.format, PcxImageFile, _accept)\nImage.register_save(PcxImageFile.format, _save)\n\nImage.register_extension(PcxImageFile.format, \".pcx\")\n\nImage.register_mime(PcxImageFile.format, \"image/x-pcx\")\n", "src/PIL/PsdImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# Adobe PSD 2.5/3.0 file handling\n#\n# History:\n# 1995-09-01 fl   Created\n# 1997-01-03 fl   Read most PSD images\n# 1997-01-18 fl   Fixed P and CMYK support\n# 2001-10-21 fl   Added seek/tell support (for layers)\n#\n# Copyright (c) 1997-2001 by Secret Labs AB.\n# Copyright (c) 1995-2001 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i8\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import si16be as si16\nfrom ._binary import si32be as si32\n\nMODES = {\n    # (photoshop mode, bits) -> (pil mode, required channels)\n    (0, 1): (\"1\", 1),\n    (0, 8): (\"L\", 1),\n    (1, 8): (\"L\", 1),\n    (2, 8): (\"P\", 1),\n    (3, 8): (\"RGB\", 3),\n    (4, 8): (\"CMYK\", 4),\n    (7, 8): (\"L\", 1),  # FIXME: multilayer\n    (8, 8): (\"L\", 1),  # duotone\n    (9, 8): (\"LAB\", 3),\n}\n\n\n# --------------------------------------------------------------------.\n# read PSD images\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"8BPS\"\n\n\n##\n# Image plugin for Photoshop images.\n\n\nclass PsdImageFile(ImageFile.ImageFile):\n    format = \"PSD\"\n    format_description = \"Adobe Photoshop\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        read = self.fp.read\n\n        #\n        # header\n\n        s = read(26)\n        if not _accept(s) or i16(s, 4) != 1:\n            msg = \"not a PSD file\"\n            raise SyntaxError(msg)\n\n        psd_bits = i16(s, 22)\n        psd_channels = i16(s, 12)\n        psd_mode = i16(s, 24)\n\n        mode, channels = MODES[(psd_mode, psd_bits)]\n\n        if channels > psd_channels:\n            msg = \"not enough channels\"\n            raise OSError(msg)\n        if mode == \"RGB\" and psd_channels == 4:\n            mode = \"RGBA\"\n            channels = 4\n\n        self._mode = mode\n        self._size = i32(s, 18), i32(s, 14)\n\n        #\n        # color mode data\n\n        size = i32(read(4))\n        if size:\n            data = read(size)\n            if mode == \"P\" and size == 768:\n                self.palette = ImagePalette.raw(\"RGB;L\", data)\n\n        #\n        # image resources\n\n        self.resources = []\n\n        size = i32(read(4))\n        if size:\n            # load resources\n            end = self.fp.tell() + size\n            while self.fp.tell() < end:\n                read(4)  # signature\n                id = i16(read(2))\n                name = read(i8(read(1)))\n                if not (len(name) & 1):\n                    read(1)  # padding\n                data = read(i32(read(4)))\n                if len(data) & 1:\n                    read(1)  # padding\n                self.resources.append((id, name, data))\n                if id == 1039:  # ICC profile\n                    self.info[\"icc_profile\"] = data\n\n        #\n        # layer and mask information\n\n        self.layers = []\n\n        size = i32(read(4))\n        if size:\n            end = self.fp.tell() + size\n            size = i32(read(4))\n            if size:\n                _layer_data = io.BytesIO(ImageFile._safe_read(self.fp, size))\n                self.layers = _layerinfo(_layer_data, size)\n            self.fp.seek(end)\n        self.n_frames = len(self.layers)\n        self.is_animated = self.n_frames > 1\n\n        #\n        # image descriptor\n\n        self.tile = _maketile(self.fp, mode, (0, 0) + self.size, channels)\n\n        # keep the file open\n        self._fp = self.fp\n        self.frame = 1\n        self._min_frame = 1\n\n    def seek(self, layer: int) -> None:\n        if not self._seek_check(layer):\n            return\n\n        # seek to given layer (1..max)\n        try:\n            _, mode, _, tile = self.layers[layer - 1]\n            self._mode = mode\n            self.tile = tile\n            self.frame = layer\n            self.fp = self._fp\n        except IndexError as e:\n            msg = \"no such layer\"\n            raise EOFError(msg) from e\n\n    def tell(self) -> int:\n        # return layer number (0=image, 1..max=layers)\n        return self.frame\n\n\ndef _layerinfo(fp, ct_bytes):\n    # read layerinfo block\n    layers = []\n\n    def read(size):\n        return ImageFile._safe_read(fp, size)\n\n    ct = si16(read(2))\n\n    # sanity check\n    if ct_bytes < (abs(ct) * 20):\n        msg = \"Layer block too short for number of layers requested\"\n        raise SyntaxError(msg)\n\n    for _ in range(abs(ct)):\n        # bounding box\n        y0 = si32(read(4))\n        x0 = si32(read(4))\n        y1 = si32(read(4))\n        x1 = si32(read(4))\n\n        # image info\n        mode = []\n        ct_types = i16(read(2))\n        if ct_types > 4:\n            fp.seek(ct_types * 6 + 12, io.SEEK_CUR)\n            size = i32(read(4))\n            fp.seek(size, io.SEEK_CUR)\n            continue\n\n        for _ in range(ct_types):\n            type = i16(read(2))\n\n            if type == 65535:\n                m = \"A\"\n            else:\n                m = \"RGBA\"[type]\n\n            mode.append(m)\n            read(4)  # size\n\n        # figure out the image mode\n        mode.sort()\n        if mode == [\"R\"]:\n            mode = \"L\"\n        elif mode == [\"B\", \"G\", \"R\"]:\n            mode = \"RGB\"\n        elif mode == [\"A\", \"B\", \"G\", \"R\"]:\n            mode = \"RGBA\"\n        else:\n            mode = None  # unknown\n\n        # skip over blend flags and extra information\n        read(12)  # filler\n        name = \"\"\n        size = i32(read(4))  # length of the extra data field\n        if size:\n            data_end = fp.tell() + size\n\n            length = i32(read(4))\n            if length:\n                fp.seek(length - 16, io.SEEK_CUR)\n\n            length = i32(read(4))\n            if length:\n                fp.seek(length, io.SEEK_CUR)\n\n            length = i8(read(1))\n            if length:\n                # Don't know the proper encoding,\n                # Latin-1 should be a good guess\n                name = read(length).decode(\"latin-1\", \"replace\")\n\n            fp.seek(data_end)\n        layers.append((name, mode, (x0, y0, x1, y1)))\n\n    # get tiles\n    for i, (name, mode, bbox) in enumerate(layers):\n        tile = []\n        for m in mode:\n            t = _maketile(fp, m, bbox, 1)\n            if t:\n                tile.extend(t)\n        layers[i] = name, mode, bbox, tile\n\n    return layers\n\n\ndef _maketile(file, mode, bbox, channels):\n    tile = None\n    read = file.read\n\n    compression = i16(read(2))\n\n    xsize = bbox[2] - bbox[0]\n    ysize = bbox[3] - bbox[1]\n\n    offset = file.tell()\n\n    if compression == 0:\n        #\n        # raw compression\n        tile = []\n        for channel in range(channels):\n            layer = mode[channel]\n            if mode == \"CMYK\":\n                layer += \";I\"\n            tile.append((\"raw\", bbox, offset, layer))\n            offset = offset + xsize * ysize\n\n    elif compression == 1:\n        #\n        # packbits compression\n        i = 0\n        tile = []\n        bytecount = read(channels * ysize * 2)\n        offset = file.tell()\n        for channel in range(channels):\n            layer = mode[channel]\n            if mode == \"CMYK\":\n                layer += \";I\"\n            tile.append((\"packbits\", bbox, offset, layer))\n            for y in range(ysize):\n                offset = offset + i16(bytecount, i)\n                i += 2\n\n    file.seek(offset)\n\n    if offset & 1:\n        read(1)  # padding\n\n    return tile\n\n\n# --------------------------------------------------------------------\n# registry\n\n\nImage.register_open(PsdImageFile.format, PsdImageFile, _accept)\n\nImage.register_extension(PsdImageFile.format, \".psd\")\n\nImage.register_mime(PsdImageFile.format, \"image/vnd.adobe.photoshop\")\n", "src/PIL/_tkinter_finder.py": "\"\"\" Find compiled module linking to Tcl / Tk libraries\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport tkinter\n\ntk = getattr(tkinter, \"_tkinter\")\n\ntry:\n    if hasattr(sys, \"pypy_find_executable\"):\n        TKINTER_LIB = tk.tklib_cffi.__file__\n    else:\n        TKINTER_LIB = tk.__file__\nexcept AttributeError:\n    # _tkinter may be compiled directly into Python, in which case __file__ is\n    # not available. load_tkinter_funcs will check the binary first in any case.\n    TKINTER_LIB = None\n\ntk_version = str(tkinter.TkVersion)\n", "src/PIL/QoiImagePlugin.py": "#\n# The Python Imaging Library.\n#\n# QOI support for PIL\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\n\nfrom . import Image, ImageFile\nfrom ._binary import i32be as i32\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"qoif\"\n\n\nclass QoiImageFile(ImageFile.ImageFile):\n    format = \"QOI\"\n    format_description = \"Quite OK Image\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(4)):\n            msg = \"not a QOI file\"\n            raise SyntaxError(msg)\n\n        self._size = tuple(i32(self.fp.read(4)) for i in range(2))\n\n        channels = self.fp.read(1)[0]\n        self._mode = \"RGB\" if channels == 3 else \"RGBA\"\n\n        self.fp.seek(1, os.SEEK_CUR)  # colorspace\n        self.tile = [(\"qoi\", (0, 0) + self._size, self.fp.tell(), None)]\n\n\nclass QoiDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    _previous_pixel: bytes | bytearray | None = None\n    _previously_seen_pixels: dict[int, bytes | bytearray] = {}\n\n    def _add_to_previous_pixels(self, value: bytes | bytearray) -> None:\n        self._previous_pixel = value\n\n        r, g, b, a = value\n        hash_value = (r * 3 + g * 5 + b * 7 + a * 11) % 64\n        self._previously_seen_pixels[hash_value] = value\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n\n        self._previously_seen_pixels = {}\n        self._add_to_previous_pixels(bytearray((0, 0, 0, 255)))\n\n        data = bytearray()\n        bands = Image.getmodebands(self.mode)\n        dest_length = self.state.xsize * self.state.ysize * bands\n        while len(data) < dest_length:\n            byte = self.fd.read(1)[0]\n            value: bytes | bytearray\n            if byte == 0b11111110 and self._previous_pixel:  # QOI_OP_RGB\n                value = bytearray(self.fd.read(3)) + self._previous_pixel[3:]\n            elif byte == 0b11111111:  # QOI_OP_RGBA\n                value = self.fd.read(4)\n            else:\n                op = byte >> 6\n                if op == 0:  # QOI_OP_INDEX\n                    op_index = byte & 0b00111111\n                    value = self._previously_seen_pixels.get(\n                        op_index, bytearray((0, 0, 0, 0))\n                    )\n                elif op == 1 and self._previous_pixel:  # QOI_OP_DIFF\n                    value = bytearray(\n                        (\n                            (self._previous_pixel[0] + ((byte & 0b00110000) >> 4) - 2)\n                            % 256,\n                            (self._previous_pixel[1] + ((byte & 0b00001100) >> 2) - 2)\n                            % 256,\n                            (self._previous_pixel[2] + (byte & 0b00000011) - 2) % 256,\n                            self._previous_pixel[3],\n                        )\n                    )\n                elif op == 2 and self._previous_pixel:  # QOI_OP_LUMA\n                    second_byte = self.fd.read(1)[0]\n                    diff_green = (byte & 0b00111111) - 32\n                    diff_red = ((second_byte & 0b11110000) >> 4) - 8\n                    diff_blue = (second_byte & 0b00001111) - 8\n\n                    value = bytearray(\n                        tuple(\n                            (self._previous_pixel[i] + diff_green + diff) % 256\n                            for i, diff in enumerate((diff_red, 0, diff_blue))\n                        )\n                    )\n                    value += self._previous_pixel[3:]\n                elif op == 3 and self._previous_pixel:  # QOI_OP_RUN\n                    run_length = (byte & 0b00111111) + 1\n                    value = self._previous_pixel\n                    if bands == 3:\n                        value = value[:3]\n                    data += value * run_length\n                    continue\n            self._add_to_previous_pixels(value)\n\n            if bands == 3:\n                value = value[:3]\n            data += value\n        self.set_as_raw(data)\n        return -1, 0\n\n\nImage.register_open(QoiImageFile.format, QoiImageFile, _accept)\nImage.register_decoder(\"qoi\", QoiDecoder)\nImage.register_extension(QoiImageFile.format, \".qoi\")\n", "src/PIL/WebPImagePlugin.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom typing import IO, Any\n\nfrom . import Image, ImageFile\n\ntry:\n    from . import _webp\n\n    SUPPORTED = True\nexcept ImportError:\n    SUPPORTED = False\n\n\n_VALID_WEBP_MODES = {\"RGBX\": True, \"RGBA\": True, \"RGB\": True}\n\n_VALID_WEBP_LEGACY_MODES = {\"RGB\": True, \"RGBA\": True}\n\n_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\n\n\ndef _accept(prefix: bytes) -> bool | str:\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"\n    is_valid_vp8_mode = prefix[12:16] in _VP8_MODES_BY_IDENTIFIER\n\n    if is_riff_file_format and is_webp_file and is_valid_vp8_mode:\n        if not SUPPORTED:\n            return (\n                \"image file could not be identified because WEBP support not installed\"\n            )\n        return True\n    return False\n\n\nclass WebPImageFile(ImageFile.ImageFile):\n    format = \"WEBP\"\n    format_description = \"WebP image\"\n    __loaded = 0\n    __logical_frame = 0\n\n    def _open(self) -> None:\n        if not _webp.HAVE_WEBPANIM:\n            # Legacy mode\n            data, width, height, self._mode, icc_profile, exif = _webp.WebPDecode(\n                self.fp.read()\n            )\n            if icc_profile:\n                self.info[\"icc_profile\"] = icc_profile\n            if exif:\n                self.info[\"exif\"] = exif\n            self._size = width, height\n            self.fp = BytesIO(data)\n            self.tile = [(\"raw\", (0, 0) + self.size, 0, self.mode)]\n            self.n_frames = 1\n            self.is_animated = False\n            return\n\n        # Use the newer AnimDecoder API to parse the (possibly) animated file,\n        # and access muxed chunks like ICC/EXIF/XMP.\n        self._decoder = _webp.WebPAnimDecoder(self.fp.read())\n\n        # Get info from decoder\n        width, height, loop_count, bgcolor, frame_count, mode = self._decoder.get_info()\n        self._size = width, height\n        self.info[\"loop\"] = loop_count\n        bg_a, bg_r, bg_g, bg_b = (\n            (bgcolor >> 24) & 0xFF,\n            (bgcolor >> 16) & 0xFF,\n            (bgcolor >> 8) & 0xFF,\n            bgcolor & 0xFF,\n        )\n        self.info[\"background\"] = (bg_r, bg_g, bg_b, bg_a)\n        self.n_frames = frame_count\n        self.is_animated = self.n_frames > 1\n        self._mode = \"RGB\" if mode == \"RGBX\" else mode\n        self.rawmode = mode\n        self.tile = []\n\n        # Attempt to read ICC / EXIF / XMP chunks from file\n        icc_profile = self._decoder.get_chunk(\"ICCP\")\n        exif = self._decoder.get_chunk(\"EXIF\")\n        xmp = self._decoder.get_chunk(\"XMP \")\n        if icc_profile:\n            self.info[\"icc_profile\"] = icc_profile\n        if exif:\n            self.info[\"exif\"] = exif\n        if xmp:\n            self.info[\"xmp\"] = xmp\n\n        # Initialize seek state\n        self._reset(reset=False)\n\n    def _getexif(self) -> dict[str, Any] | None:\n        if \"exif\" not in self.info:\n            return None\n        return self.getexif()._get_merged_dict()\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n\n        # Set logical frame to requested position\n        self.__logical_frame = frame\n\n    def _reset(self, reset: bool = True) -> None:\n        if reset:\n            self._decoder.reset()\n        self.__physical_frame = 0\n        self.__loaded = -1\n        self.__timestamp = 0\n\n    def _get_next(self):\n        # Get next frame\n        ret = self._decoder.get_next()\n        self.__physical_frame += 1\n\n        # Check if an error occurred\n        if ret is None:\n            self._reset()  # Reset just to be safe\n            self.seek(0)\n            msg = \"failed to decode next frame in WebP file\"\n            raise EOFError(msg)\n\n        # Compute duration\n        data, timestamp = ret\n        duration = timestamp - self.__timestamp\n        self.__timestamp = timestamp\n\n        # libwebp gives frame end, adjust to start of frame\n        timestamp -= duration\n        return data, timestamp, duration\n\n    def _seek(self, frame: int) -> None:\n        if self.__physical_frame == frame:\n            return  # Nothing to do\n        if frame < self.__physical_frame:\n            self._reset()  # Rewind to beginning\n        while self.__physical_frame < frame:\n            self._get_next()  # Advance to the requested frame\n\n    def load(self):\n        if _webp.HAVE_WEBPANIM:\n            if self.__loaded != self.__logical_frame:\n                self._seek(self.__logical_frame)\n\n                # We need to load the image data for this frame\n                data, timestamp, duration = self._get_next()\n                self.info[\"timestamp\"] = timestamp\n                self.info[\"duration\"] = duration\n                self.__loaded = self.__logical_frame\n\n                # Set tile\n                if self.fp and self._exclusive_fp:\n                    self.fp.close()\n                self.fp = BytesIO(data)\n                self.tile = [(\"raw\", (0, 0) + self.size, 0, self.rawmode)]\n\n        return super().load()\n\n    def load_seek(self, pos: int) -> None:\n        pass\n\n    def tell(self) -> int:\n        if not _webp.HAVE_WEBPANIM:\n            return super().tell()\n\n        return self.__logical_frame\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    encoderinfo = im.encoderinfo.copy()\n    append_images = list(encoderinfo.get(\"append_images\", []))\n\n    # If total frame count is 1, then save using the legacy API, which\n    # will preserve non-alpha modes\n    total = 0\n    for ims in [im] + append_images:\n        total += getattr(ims, \"n_frames\", 1)\n    if total == 1:\n        _save(im, fp, filename)\n        return\n\n    background: int | tuple[int, ...] = (0, 0, 0, 0)\n    if \"background\" in encoderinfo:\n        background = encoderinfo[\"background\"]\n    elif \"background\" in im.info:\n        background = im.info[\"background\"]\n        if isinstance(background, int):\n            # GifImagePlugin stores a global color table index in\n            # info[\"background\"]. So it must be converted to an RGBA value\n            palette = im.getpalette()\n            if palette:\n                r, g, b = palette[background * 3 : (background + 1) * 3]\n                background = (r, g, b, 255)\n            else:\n                background = (background, background, background, 255)\n\n    duration = im.encoderinfo.get(\"duration\", im.info.get(\"duration\", 0))\n    loop = im.encoderinfo.get(\"loop\", 0)\n    minimize_size = im.encoderinfo.get(\"minimize_size\", False)\n    kmin = im.encoderinfo.get(\"kmin\", None)\n    kmax = im.encoderinfo.get(\"kmax\", None)\n    allow_mixed = im.encoderinfo.get(\"allow_mixed\", False)\n    verbose = False\n    lossless = im.encoderinfo.get(\"lossless\", False)\n    quality = im.encoderinfo.get(\"quality\", 80)\n    alpha_quality = im.encoderinfo.get(\"alpha_quality\", 100)\n    method = im.encoderinfo.get(\"method\", 0)\n    icc_profile = im.encoderinfo.get(\"icc_profile\") or \"\"\n    exif = im.encoderinfo.get(\"exif\", \"\")\n    if isinstance(exif, Image.Exif):\n        exif = exif.tobytes()\n    xmp = im.encoderinfo.get(\"xmp\", \"\")\n    if allow_mixed:\n        lossless = False\n\n    # Sensible keyframe defaults are from gif2webp.c script\n    if kmin is None:\n        kmin = 9 if lossless else 3\n    if kmax is None:\n        kmax = 17 if lossless else 5\n\n    # Validate background color\n    if (\n        not isinstance(background, (list, tuple))\n        or len(background) != 4\n        or not all(0 <= v < 256 for v in background)\n    ):\n        msg = f\"Background color is not an RGBA tuple clamped to (0-255): {background}\"\n        raise OSError(msg)\n\n    # Convert to packed uint\n    bg_r, bg_g, bg_b, bg_a = background\n    background = (bg_a << 24) | (bg_r << 16) | (bg_g << 8) | (bg_b << 0)\n\n    # Setup the WebP animation encoder\n    enc = _webp.WebPAnimEncoder(\n        im.size[0],\n        im.size[1],\n        background,\n        loop,\n        minimize_size,\n        kmin,\n        kmax,\n        allow_mixed,\n        verbose,\n    )\n\n    # Add each frame\n    frame_idx = 0\n    timestamp = 0\n    cur_idx = im.tell()\n    try:\n        for ims in [im] + append_images:\n            # Get # of frames in this image\n            nfr = getattr(ims, \"n_frames\", 1)\n\n            for idx in range(nfr):\n                ims.seek(idx)\n                ims.load()\n\n                # Make sure image mode is supported\n                frame = ims\n                rawmode = ims.mode\n                if ims.mode not in _VALID_WEBP_MODES:\n                    alpha = (\n                        \"A\" in ims.mode\n                        or \"a\" in ims.mode\n                        or (ims.mode == \"P\" and \"A\" in ims.im.getpalettemode())\n                    )\n                    rawmode = \"RGBA\" if alpha else \"RGB\"\n                    frame = ims.convert(rawmode)\n\n                if rawmode == \"RGB\":\n                    # For faster conversion, use RGBX\n                    rawmode = \"RGBX\"\n\n                # Append the frame to the animation encoder\n                enc.add(\n                    frame.tobytes(\"raw\", rawmode),\n                    round(timestamp),\n                    frame.size[0],\n                    frame.size[1],\n                    rawmode,\n                    lossless,\n                    quality,\n                    alpha_quality,\n                    method,\n                )\n\n                # Update timestamp and frame index\n                if isinstance(duration, (list, tuple)):\n                    timestamp += duration[frame_idx]\n                else:\n                    timestamp += duration\n                frame_idx += 1\n\n    finally:\n        im.seek(cur_idx)\n\n    # Force encoder to flush frames\n    enc.add(None, round(timestamp), 0, 0, \"\", lossless, quality, alpha_quality, 0)\n\n    # Get the final output from the encoder\n    data = enc.assemble(icc_profile, exif, xmp)\n    if data is None:\n        msg = \"cannot write file as WebP (encoder returned None)\"\n        raise OSError(msg)\n\n    fp.write(data)\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    lossless = im.encoderinfo.get(\"lossless\", False)\n    quality = im.encoderinfo.get(\"quality\", 80)\n    alpha_quality = im.encoderinfo.get(\"alpha_quality\", 100)\n    icc_profile = im.encoderinfo.get(\"icc_profile\") or \"\"\n    exif = im.encoderinfo.get(\"exif\", b\"\")\n    if isinstance(exif, Image.Exif):\n        exif = exif.tobytes()\n    if exif.startswith(b\"Exif\\x00\\x00\"):\n        exif = exif[6:]\n    xmp = im.encoderinfo.get(\"xmp\", \"\")\n    method = im.encoderinfo.get(\"method\", 4)\n    exact = 1 if im.encoderinfo.get(\"exact\") else 0\n\n    if im.mode not in _VALID_WEBP_LEGACY_MODES:\n        im = im.convert(\"RGBA\" if im.has_transparency_data else \"RGB\")\n\n    data = _webp.WebPEncode(\n        im.tobytes(),\n        im.size[0],\n        im.size[1],\n        lossless,\n        float(quality),\n        float(alpha_quality),\n        im.mode,\n        icc_profile,\n        method,\n        exact,\n        exif,\n        xmp,\n    )\n    if data is None:\n        msg = \"cannot write file as WebP (encoder returned None)\"\n        raise OSError(msg)\n\n    fp.write(data)\n\n\nImage.register_open(WebPImageFile.format, WebPImageFile, _accept)\nif SUPPORTED:\n    Image.register_save(WebPImageFile.format, _save)\n    if _webp.HAVE_WEBPANIM:\n        Image.register_save_all(WebPImageFile.format, _save_all)\n    Image.register_extension(WebPImageFile.format, \".webp\")\n    Image.register_mime(WebPImageFile.format, \"image/webp\")\n", "src/PIL/report.py": "from __future__ import annotations\n\nfrom .features import pilinfo\n\npilinfo(supported_formats=False)\n", "src/PIL/GimpPaletteFile.py": "#\n# Python Imaging Library\n# $Id$\n#\n# stuff to read GIMP palette files\n#\n# History:\n# 1997-08-23 fl     Created\n# 2004-09-07 fl     Support GIMP 2.0 palette files.\n#\n# Copyright (c) Secret Labs AB 1997-2004.  All rights reserved.\n# Copyright (c) Fredrik Lundh 1997-2004.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\nfrom typing import IO\n\nfrom ._binary import o8\n\n\nclass GimpPaletteFile:\n    \"\"\"File handler for GIMP's palette format.\"\"\"\n\n    rawmode = \"RGB\"\n\n    def __init__(self, fp: IO[bytes]) -> None:\n        palette = [o8(i) * 3 for i in range(256)]\n\n        if fp.readline()[:12] != b\"GIMP Palette\":\n            msg = \"not a GIMP palette file\"\n            raise SyntaxError(msg)\n\n        for i in range(256):\n            s = fp.readline()\n            if not s:\n                break\n\n            # skip fields and comment lines\n            if re.match(rb\"\\w+:|#\", s):\n                continue\n            if len(s) > 100:\n                msg = \"bad palette file\"\n                raise SyntaxError(msg)\n\n            v = tuple(map(int, s.split()[:3]))\n            if len(v) != 3:\n                msg = \"bad palette entry\"\n                raise ValueError(msg)\n\n            palette[i] = o8(v[0]) + o8(v[1]) + o8(v[2])\n\n        self.palette = b\"\".join(palette)\n\n    def getpalette(self) -> tuple[bytes, str]:\n        return self.palette, self.rawmode\n", "src/PIL/PixarImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PIXAR raster support for PIL\n#\n# history:\n#       97-01-29 fl     Created\n#\n# notes:\n#       This is incomplete; it is based on a few samples created with\n#       Photoshop 2.5 and 3.0, and a summary description provided by\n#       Greg Coats <gcoats@labiris.er.usgs.gov>.  Hopefully, \"L\" and\n#       \"RGBA\" support will be added in future versions.\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i16le as i16\n\n#\n# helpers\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"\\200\\350\\000\\000\"\n\n\n##\n# Image plugin for PIXAR raster images.\n\n\nclass PixarImageFile(ImageFile.ImageFile):\n    format = \"PIXAR\"\n    format_description = \"PIXAR raster image\"\n\n    def _open(self) -> None:\n        # assuming a 4-byte magic label\n        assert self.fp is not None\n\n        s = self.fp.read(4)\n        if not _accept(s):\n            msg = \"not a PIXAR file\"\n            raise SyntaxError(msg)\n\n        # read rest of header\n        s = s + self.fp.read(508)\n\n        self._size = i16(s, 418), i16(s, 416)\n\n        # get channel/depth descriptions\n        mode = i16(s, 424), i16(s, 426)\n\n        if mode == (14, 2):\n            self._mode = \"RGB\"\n        # FIXME: to be continued...\n\n        # create tile descriptor (assuming \"dumped\")\n        self.tile = [(\"raw\", (0, 0) + self.size, 1024, (self.mode, 0, 1))]\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(PixarImageFile.format, PixarImageFile, _accept)\n\nImage.register_extension(PixarImageFile.format, \".pxr\")\n", "src/PIL/IcnsImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# macOS icns file decoder, based on icns.py by Bob Ippolito.\n#\n# history:\n# 2004-10-09 fl   Turned into a PIL plugin; removed 2.3 dependencies.\n# 2020-04-04      Allow saving on all operating systems.\n#\n# Copyright (c) 2004 by Bob Ippolito.\n# Copyright (c) 2004 by Secret Labs.\n# Copyright (c) 2004 by Fredrik Lundh.\n# Copyright (c) 2014 by Alastair Houghton.\n# Copyright (c) 2020 by Pan Jing.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport struct\nimport sys\nfrom typing import IO\n\nfrom . import Image, ImageFile, PngImagePlugin, features\n\nenable_jpeg2k = features.check_codec(\"jpg_2000\")\nif enable_jpeg2k:\n    from . import Jpeg2KImagePlugin\n\nMAGIC = b\"icns\"\nHEADERSIZE = 8\n\n\ndef nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\n\n\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        msg = \"Unknown signature, expecting 0x00000000\"\n        raise SyntaxError(msg)\n    return read_32(fobj, (start + 4, length - 4), size)\n\n\ndef read_32(fobj, start_length, size):\n    \"\"\"\n    Read a 32bit RGB icon resource.  Seems to be either uncompressed or\n    an RLE packbits-like scheme.\n    \"\"\"\n    (start, length) = start_length\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    if length == sizesq * 3:\n        # uncompressed (\"RGBRGBGB\")\n        indata = fobj.read(length)\n        im = Image.frombuffer(\"RGB\", pixel_size, indata, \"raw\", \"RGB\", 0, 1)\n    else:\n        # decode image\n        im = Image.new(\"RGB\", pixel_size, None)\n        for band_ix in range(3):\n            data = []\n            bytesleft = sizesq\n            while bytesleft > 0:\n                byte = fobj.read(1)\n                if not byte:\n                    break\n                byte = byte[0]\n                if byte & 0x80:\n                    blocksize = byte - 125\n                    byte = fobj.read(1)\n                    for i in range(blocksize):\n                        data.append(byte)\n                else:\n                    blocksize = byte + 1\n                    data.append(fobj.read(blocksize))\n                bytesleft -= blocksize\n                if bytesleft <= 0:\n                    break\n            if bytesleft != 0:\n                msg = f\"Error reading channel [{repr(bytesleft)} left]\"\n                raise SyntaxError(msg)\n            band = Image.frombuffer(\"L\", pixel_size, b\"\".join(data), \"raw\", \"L\", 0, 1)\n            im.im.putband(band.im, band_ix)\n    return {\"RGB\": im}\n\n\ndef read_mk(fobj, start_length, size):\n    # Alpha masks seem to be uncompressed\n    start = start_length[0]\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    band = Image.frombuffer(\"L\", pixel_size, fobj.read(sizesq), \"raw\", \"L\", 0, 1)\n    return {\"A\": band}\n\n\ndef read_png_or_jpeg2000(fobj, start_length, size):\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(12)\n    if sig[:8] == b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\":\n        fobj.seek(start)\n        im = PngImagePlugin.PngImageFile(fobj)\n        Image._decompression_bomb_check(im.size)\n        return {\"RGBA\": im}\n    elif (\n        sig[:4] == b\"\\xff\\x4f\\xff\\x51\"\n        or sig[:4] == b\"\\x0d\\x0a\\x87\\x0a\"\n        or sig == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\"\n    ):\n        if not enable_jpeg2k:\n            msg = (\n                \"Unsupported icon subimage format (rebuild PIL \"\n                \"with JPEG 2000 support to fix this)\"\n            )\n            raise ValueError(msg)\n        # j2k, jpc or j2c\n        fobj.seek(start)\n        jp2kstream = fobj.read(length)\n        f = io.BytesIO(jp2kstream)\n        im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)\n        Image._decompression_bomb_check(im.size)\n        if im.mode != \"RGBA\":\n            im = im.convert(\"RGBA\")\n        return {\"RGBA\": im}\n    else:\n        msg = \"Unsupported icon subimage format\"\n        raise ValueError(msg)\n\n\nclass IcnsFile:\n    SIZES = {\n        (512, 512, 2): [(b\"ic10\", read_png_or_jpeg2000)],\n        (512, 512, 1): [(b\"ic09\", read_png_or_jpeg2000)],\n        (256, 256, 2): [(b\"ic14\", read_png_or_jpeg2000)],\n        (256, 256, 1): [(b\"ic08\", read_png_or_jpeg2000)],\n        (128, 128, 2): [(b\"ic13\", read_png_or_jpeg2000)],\n        (128, 128, 1): [\n            (b\"ic07\", read_png_or_jpeg2000),\n            (b\"it32\", read_32t),\n            (b\"t8mk\", read_mk),\n        ],\n        (64, 64, 1): [(b\"icp6\", read_png_or_jpeg2000)],\n        (32, 32, 2): [(b\"ic12\", read_png_or_jpeg2000)],\n        (48, 48, 1): [(b\"ih32\", read_32), (b\"h8mk\", read_mk)],\n        (32, 32, 1): [\n            (b\"icp5\", read_png_or_jpeg2000),\n            (b\"il32\", read_32),\n            (b\"l8mk\", read_mk),\n        ],\n        (16, 16, 2): [(b\"ic11\", read_png_or_jpeg2000)],\n        (16, 16, 1): [\n            (b\"icp4\", read_png_or_jpeg2000),\n            (b\"is32\", read_32),\n            (b\"s8mk\", read_mk),\n        ],\n    }\n\n    def __init__(self, fobj):\n        \"\"\"\n        fobj is a file-like object as an icns resource\n        \"\"\"\n        # signature : (start, length)\n        self.dct = dct = {}\n        self.fobj = fobj\n        sig, filesize = nextheader(fobj)\n        if not _accept(sig):\n            msg = \"not an icns file\"\n            raise SyntaxError(msg)\n        i = HEADERSIZE\n        while i < filesize:\n            sig, blocksize = nextheader(fobj)\n            if blocksize <= 0:\n                msg = \"invalid block header\"\n                raise SyntaxError(msg)\n            i += HEADERSIZE\n            blocksize -= HEADERSIZE\n            dct[sig] = (i, blocksize)\n            fobj.seek(blocksize, io.SEEK_CUR)\n            i += blocksize\n\n    def itersizes(self):\n        sizes = []\n        for size, fmts in self.SIZES.items():\n            for fmt, reader in fmts:\n                if fmt in self.dct:\n                    sizes.append(size)\n                    break\n        return sizes\n\n    def bestsize(self):\n        sizes = self.itersizes()\n        if not sizes:\n            msg = \"No 32bit icon resources found\"\n            raise SyntaxError(msg)\n        return max(sizes)\n\n    def dataforsize(self, size):\n        \"\"\"\n        Get an icon resource as {channel: array}.  Note that\n        the arrays are bottom-up like windows bitmaps and will likely\n        need to be flipped or transposed in some way.\n        \"\"\"\n        dct = {}\n        for code, reader in self.SIZES[size]:\n            desc = self.dct.get(code)\n            if desc is not None:\n                dct.update(reader(self.fobj, desc, size))\n        return dct\n\n    def getimage(self, size=None):\n        if size is None:\n            size = self.bestsize()\n        if len(size) == 2:\n            size = (size[0], size[1], 1)\n        channels = self.dataforsize(size)\n\n        im = channels.get(\"RGBA\", None)\n        if im:\n            return im\n\n        im = channels.get(\"RGB\").copy()\n        try:\n            im.putalpha(channels[\"A\"])\n        except KeyError:\n            pass\n        return im\n\n\n##\n# Image plugin for Mac OS icons.\n\n\nclass IcnsImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL image support for Mac OS .icns files.\n    Chooses the best resolution, but will possibly load\n    a different size image if you mutate the size attribute\n    before calling 'load'.\n\n    The info dictionary has a key 'sizes' that is a list\n    of sizes that the icns file has.\n    \"\"\"\n\n    format = \"ICNS\"\n    format_description = \"Mac OS icns resource\"\n\n    def _open(self) -> None:\n        self.icns = IcnsFile(self.fp)\n        self._mode = \"RGBA\"\n        self.info[\"sizes\"] = self.icns.itersizes()\n        self.best_size = self.icns.bestsize()\n        self.size = (\n            self.best_size[0] * self.best_size[2],\n            self.best_size[1] * self.best_size[2],\n        )\n\n    @property\n    def size(self):\n        return self._size\n\n    @size.setter\n    def size(self, value):\n        info_size = value\n        if info_size not in self.info[\"sizes\"] and len(info_size) == 2:\n            info_size = (info_size[0], info_size[1], 1)\n        if (\n            info_size not in self.info[\"sizes\"]\n            and len(info_size) == 3\n            and info_size[2] == 1\n        ):\n            simple_sizes = [\n                (size[0] * size[2], size[1] * size[2]) for size in self.info[\"sizes\"]\n            ]\n            if value in simple_sizes:\n                info_size = self.info[\"sizes\"][simple_sizes.index(value)]\n        if info_size not in self.info[\"sizes\"]:\n            msg = \"This is not one of the allowed sizes of this image\"\n            raise ValueError(msg)\n        self._size = value\n\n    def load(self):\n        if len(self.size) == 3:\n            self.best_size = self.size\n            self.size = (\n                self.best_size[0] * self.best_size[2],\n                self.best_size[1] * self.best_size[2],\n            )\n\n        px = Image.Image.load(self)\n        if self.im is not None and self.im.size == self.size:\n            # Already loaded\n            return px\n        self.load_prepare()\n        # This is likely NOT the best way to do it, but whatever.\n        im = self.icns.getimage(self.best_size)\n\n        # If this is a PNG or JPEG 2000, it won't be loaded yet\n        px = im.load()\n\n        self.im = im.im\n        self._mode = im.mode\n        self.size = im.size\n\n        return px\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    \"\"\"\n    Saves the image as a series of PNG files,\n    that are then combined into a .icns file.\n    \"\"\"\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n    sizes = {\n        b\"ic07\": 128,\n        b\"ic08\": 256,\n        b\"ic09\": 512,\n        b\"ic10\": 1024,\n        b\"ic11\": 32,\n        b\"ic12\": 64,\n        b\"ic13\": 256,\n        b\"ic14\": 512,\n    }\n    provided_images = {im.width: im for im in im.encoderinfo.get(\"append_images\", [])}\n    size_streams = {}\n    for size in set(sizes.values()):\n        image = (\n            provided_images[size]\n            if size in provided_images\n            else im.resize((size, size))\n        )\n\n        temp = io.BytesIO()\n        image.save(temp, \"png\")\n        size_streams[size] = temp.getvalue()\n\n    entries = []\n    for type, size in sizes.items():\n        stream = size_streams[size]\n        entries.append((type, HEADERSIZE + len(stream), stream))\n\n    # Header\n    fp.write(MAGIC)\n    file_length = HEADERSIZE  # Header\n    file_length += HEADERSIZE + 8 * len(entries)  # TOC\n    file_length += sum(entry[1] for entry in entries)\n    fp.write(struct.pack(\">i\", file_length))\n\n    # TOC\n    fp.write(b\"TOC \")\n    fp.write(struct.pack(\">i\", HEADERSIZE + len(entries) * HEADERSIZE))\n    for entry in entries:\n        fp.write(entry[0])\n        fp.write(struct.pack(\">i\", entry[1]))\n\n    # Data\n    for entry in entries:\n        fp.write(entry[0])\n        fp.write(struct.pack(\">i\", entry[1]))\n        fp.write(entry[2])\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == MAGIC\n\n\nImage.register_open(IcnsImageFile.format, IcnsImageFile, _accept)\nImage.register_extension(IcnsImageFile.format, \".icns\")\n\nImage.register_save(IcnsImageFile.format, _save)\nImage.register_mime(IcnsImageFile.format, \"image/icns\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Syntax: python3 IcnsImagePlugin.py [file]\")\n        sys.exit()\n\n    with open(sys.argv[1], \"rb\") as fp:\n        imf = IcnsImageFile(fp)\n        for size in imf.info[\"sizes\"]:\n            width, height, scale = imf.size = size\n            imf.save(f\"out-{width}-{height}-{scale}.png\")\n        with Image.open(sys.argv[1]) as im:\n            im.save(\"out.png\")\n        if sys.platform == \"windows\":\n            os.startfile(\"out.png\")\n", "src/PIL/ImageChops.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard channel operations\n#\n# History:\n# 1996-03-24 fl   Created\n# 1996-08-13 fl   Added logical operations (for \"1\" images)\n# 2000-10-12 fl   Added offset method (from Image.py)\n#\n# Copyright (c) 1997-2000 by Secret Labs AB\n# Copyright (c) 1996-2000 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import annotations\n\nfrom . import Image\n\n\ndef constant(image: Image.Image, value: int) -> Image.Image:\n    \"\"\"Fill a channel with a given gray level.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return Image.new(\"L\", image.size, value)\n\n\ndef duplicate(image: Image.Image) -> Image.Image:\n    \"\"\"Copy a channel. Alias for :py:meth:`PIL.Image.Image.copy`.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return image.copy()\n\n\ndef invert(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Invert an image (channel). ::\n\n        out = MAX - image\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image.load()\n    return image._new(image.im.chop_invert())\n\n\ndef lighter(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the lighter values. ::\n\n        out = max(image1, image2)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_lighter(image2.im))\n\n\ndef darker(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the darker values. ::\n\n        out = min(image1, image2)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_darker(image2.im))\n\n\ndef difference(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Returns the absolute value of the pixel-by-pixel difference between the two\n    images. ::\n\n        out = abs(image1 - image2)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_difference(image2.im))\n\n\ndef multiply(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other.\n\n    If you multiply an image with a solid black image, the result is black. If\n    you multiply with a solid white image, the image is unaffected. ::\n\n        out = image1 * image2 / MAX\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_multiply(image2.im))\n\n\ndef screen(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two inverted images on top of each other. ::\n\n        out = MAX - ((MAX - image1) * (MAX - image2) / MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_screen(image2.im))\n\n\ndef soft_light(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Soft Light algorithm\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_soft_light(image2.im))\n\n\ndef hard_light(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Hard Light algorithm\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_hard_light(image2.im))\n\n\ndef overlay(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Overlay algorithm\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_overlay(image2.im))\n\n\ndef add(\n    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0\n) -> Image.Image:\n    \"\"\"\n    Adds two images, dividing the result by scale and adding the\n    offset. If omitted, scale defaults to 1.0, and offset to 0.0. ::\n\n        out = ((image1 + image2) / scale + offset)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_add(image2.im, scale, offset))\n\n\ndef subtract(\n    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0\n) -> Image.Image:\n    \"\"\"\n    Subtracts two images, dividing the result by scale and adding the offset.\n    If omitted, scale defaults to 1.0, and offset to 0.0. ::\n\n        out = ((image1 - image2) / scale + offset)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_subtract(image2.im, scale, offset))\n\n\ndef add_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Add two images, without clipping the result. ::\n\n        out = ((image1 + image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_add_modulo(image2.im))\n\n\ndef subtract_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Subtract two images, without clipping the result. ::\n\n        out = ((image1 - image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_subtract_modulo(image2.im))\n\n\ndef logical_and(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical AND between two images.\n\n    Both of the images must have mode \"1\". If you would like to perform a\n    logical AND on an image with a mode other than \"1\", try\n    :py:meth:`~PIL.ImageChops.multiply` instead, using a black-and-white mask\n    as the second image. ::\n\n        out = ((image1 and image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_and(image2.im))\n\n\ndef logical_or(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical OR between two images.\n\n    Both of the images must have mode \"1\". ::\n\n        out = ((image1 or image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_or(image2.im))\n\n\ndef logical_xor(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical XOR between two images.\n\n    Both of the images must have mode \"1\". ::\n\n        out = ((bool(image1) != bool(image2)) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_xor(image2.im))\n\n\ndef blend(image1: Image.Image, image2: Image.Image, alpha: float) -> Image.Image:\n    \"\"\"Blend images using constant transparency weight. Alias for\n    :py:func:`PIL.Image.blend`.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return Image.blend(image1, image2, alpha)\n\n\ndef composite(\n    image1: Image.Image, image2: Image.Image, mask: Image.Image\n) -> Image.Image:\n    \"\"\"Create composite using transparency mask. Alias for\n    :py:func:`PIL.Image.composite`.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return Image.composite(image1, image2, mask)\n\n\ndef offset(image: Image.Image, xoffset: int, yoffset: int | None = None) -> Image.Image:\n    \"\"\"Returns a copy of the image where data has been offset by the given\n    distances. Data wraps around the edges. If ``yoffset`` is omitted, it\n    is assumed to be equal to ``xoffset``.\n\n    :param image: Input image.\n    :param xoffset: The horizontal distance.\n    :param yoffset: The vertical distance.  If omitted, both\n        distances are set to the same value.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    if yoffset is None:\n        yoffset = xoffset\n    image.load()\n    return image._new(image.im.offset(xoffset, yoffset))\n", "src/PIL/PalmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n\n##\n# Image plugin for Palm pixmap images (output only).\n##\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import o8\nfrom ._binary import o16be as o16b\n\n# fmt: off\n_Palm8BitColormapValues = (\n    (255, 255, 255), (255, 204, 255), (255, 153, 255), (255, 102, 255),\n    (255,  51, 255), (255,   0, 255), (255, 255, 204), (255, 204, 204),\n    (255, 153, 204), (255, 102, 204), (255,  51, 204), (255,   0, 204),\n    (255, 255, 153), (255, 204, 153), (255, 153, 153), (255, 102, 153),\n    (255,  51, 153), (255,   0, 153), (204, 255, 255), (204, 204, 255),\n    (204, 153, 255), (204, 102, 255), (204,  51, 255), (204,   0, 255),\n    (204, 255, 204), (204, 204, 204), (204, 153, 204), (204, 102, 204),\n    (204,  51, 204), (204,   0, 204), (204, 255, 153), (204, 204, 153),\n    (204, 153, 153), (204, 102, 153), (204,  51, 153), (204,   0, 153),\n    (153, 255, 255), (153, 204, 255), (153, 153, 255), (153, 102, 255),\n    (153,  51, 255), (153,   0, 255), (153, 255, 204), (153, 204, 204),\n    (153, 153, 204), (153, 102, 204), (153,  51, 204), (153,   0, 204),\n    (153, 255, 153), (153, 204, 153), (153, 153, 153), (153, 102, 153),\n    (153,  51, 153), (153,   0, 153), (102, 255, 255), (102, 204, 255),\n    (102, 153, 255), (102, 102, 255), (102,  51, 255), (102,   0, 255),\n    (102, 255, 204), (102, 204, 204), (102, 153, 204), (102, 102, 204),\n    (102,  51, 204), (102,   0, 204), (102, 255, 153), (102, 204, 153),\n    (102, 153, 153), (102, 102, 153), (102,  51, 153), (102,   0, 153),\n    (51,  255, 255), (51,  204, 255), (51,  153, 255), (51,  102, 255),\n    (51,   51, 255), (51,    0, 255), (51,  255, 204), (51,  204, 204),\n    (51,  153, 204), (51,  102, 204), (51,   51, 204), (51,    0, 204),\n    (51,  255, 153), (51,  204, 153), (51,  153, 153), (51,  102, 153),\n    (51,   51, 153), (51,    0, 153), (0,   255, 255), (0,   204, 255),\n    (0,   153, 255), (0,   102, 255), (0,    51, 255), (0,     0, 255),\n    (0,   255, 204), (0,   204, 204), (0,   153, 204), (0,   102, 204),\n    (0,    51, 204), (0,     0, 204), (0,   255, 153), (0,   204, 153),\n    (0,   153, 153), (0,   102, 153), (0,    51, 153), (0,     0, 153),\n    (255, 255, 102), (255, 204, 102), (255, 153, 102), (255, 102, 102),\n    (255,  51, 102), (255,   0, 102), (255, 255,  51), (255, 204,  51),\n    (255, 153,  51), (255, 102,  51), (255,  51,  51), (255,   0,  51),\n    (255, 255,   0), (255, 204,   0), (255, 153,   0), (255, 102,   0),\n    (255,  51,   0), (255,   0,   0), (204, 255, 102), (204, 204, 102),\n    (204, 153, 102), (204, 102, 102), (204,  51, 102), (204,   0, 102),\n    (204, 255,  51), (204, 204,  51), (204, 153,  51), (204, 102,  51),\n    (204,  51,  51), (204,   0,  51), (204, 255,   0), (204, 204,   0),\n    (204, 153,   0), (204, 102,   0), (204,  51,   0), (204,   0,   0),\n    (153, 255, 102), (153, 204, 102), (153, 153, 102), (153, 102, 102),\n    (153,  51, 102), (153,   0, 102), (153, 255,  51), (153, 204,  51),\n    (153, 153,  51), (153, 102,  51), (153,  51,  51), (153,   0,  51),\n    (153, 255,   0), (153, 204,   0), (153, 153,   0), (153, 102,   0),\n    (153,  51,   0), (153,   0,   0), (102, 255, 102), (102, 204, 102),\n    (102, 153, 102), (102, 102, 102), (102,  51, 102), (102,   0, 102),\n    (102, 255,  51), (102, 204,  51), (102, 153,  51), (102, 102,  51),\n    (102,  51,  51), (102,   0,  51), (102, 255,   0), (102, 204,   0),\n    (102, 153,   0), (102, 102,   0), (102,  51,   0), (102,   0,   0),\n    (51,  255, 102), (51,  204, 102), (51,  153, 102), (51,  102, 102),\n    (51,   51, 102), (51,    0, 102), (51,  255,  51), (51,  204,  51),\n    (51,  153,  51), (51,  102,  51), (51,   51,  51), (51,    0,  51),\n    (51,  255,   0), (51,  204,   0), (51,  153,   0), (51,  102,   0),\n    (51,   51,   0), (51,    0,   0), (0,   255, 102), (0,   204, 102),\n    (0,   153, 102), (0,   102, 102), (0,    51, 102), (0,     0, 102),\n    (0,   255,  51), (0,   204,  51), (0,   153,  51), (0,   102,  51),\n    (0,    51,  51), (0,     0,  51), (0,   255,   0), (0,   204,   0),\n    (0,   153,   0), (0,   102,   0), (0,    51,   0), (17,   17,  17),\n    (34,   34,  34), (68,   68,  68), (85,   85,  85), (119, 119, 119),\n    (136, 136, 136), (170, 170, 170), (187, 187, 187), (221, 221, 221),\n    (238, 238, 238), (192, 192, 192), (128,   0,   0), (128,   0, 128),\n    (0,   128,   0), (0,   128, 128), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0))\n# fmt: on\n\n\n# so build a prototype image to be used for palette resampling\ndef build_prototype_image() -> Image.Image:\n    image = Image.new(\"L\", (1, len(_Palm8BitColormapValues)))\n    image.putdata(list(range(len(_Palm8BitColormapValues))))\n    palettedata: tuple[int, ...] = ()\n    for colormapValue in _Palm8BitColormapValues:\n        palettedata += colormapValue\n    palettedata += (0, 0, 0) * (256 - len(_Palm8BitColormapValues))\n    image.putpalette(palettedata)\n    return image\n\n\nPalm8BitColormapImage = build_prototype_image()\n\n# OK, we now have in Palm8BitColormapImage,\n# a \"P\"-mode image with the right palette\n#\n# --------------------------------------------------------------------\n\n_FLAGS = {\"custom-colormap\": 0x4000, \"is-compressed\": 0x8000, \"has-transparent\": 0x2000}\n\n_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n\n\n#\n# --------------------------------------------------------------------\n\n##\n# (Internal) Image save plugin for the Palm format.\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode == \"P\":\n        # we assume this is a color Palm image with the standard colormap,\n        # unless the \"info\" dict has a \"custom-colormap\" field\n\n        rawmode = \"P\"\n        bpp = 8\n        version = 1\n\n    elif im.mode == \"L\":\n        if im.encoderinfo.get(\"bpp\") in (1, 2, 4):\n            # this is 8-bit grayscale, so we shift it to get the high-order bits,\n            # and invert it because\n            # Palm does grayscale from white (0) to black (1)\n            bpp = im.encoderinfo[\"bpp\"]\n            maxval = (1 << bpp) - 1\n            shift = 8 - bpp\n            im = im.point(lambda x: maxval - (x >> shift))\n        elif im.info.get(\"bpp\") in (1, 2, 4):\n            # here we assume that even though the inherent mode is 8-bit grayscale,\n            # only the lower bpp bits are significant.\n            # We invert them to match the Palm.\n            bpp = im.info[\"bpp\"]\n            maxval = (1 << bpp) - 1\n            im = im.point(lambda x: maxval - (x & maxval))\n        else:\n            msg = f\"cannot write mode {im.mode} as Palm\"\n            raise OSError(msg)\n\n        # we ignore the palette here\n        im._mode = \"P\"\n        rawmode = f\"P;{bpp}\"\n        version = 1\n\n    elif im.mode == \"1\":\n        # monochrome -- write it inverted, as is the Palm standard\n        rawmode = \"1;I\"\n        bpp = 1\n        version = 0\n\n    else:\n        msg = f\"cannot write mode {im.mode} as Palm\"\n        raise OSError(msg)\n\n    #\n    # make sure image data is available\n    im.load()\n\n    # write header\n\n    cols = im.size[0]\n    rows = im.size[1]\n\n    rowbytes = int((cols + (16 // bpp - 1)) / (16 // bpp)) * 2\n    transparent_index = 0\n    compression_type = _COMPRESSION_TYPES[\"none\"]\n\n    flags = 0\n    if im.mode == \"P\" and \"custom-colormap\" in im.info:\n        flags = flags & _FLAGS[\"custom-colormap\"]\n        colormapsize = 4 * 256 + 2\n        colormapmode = im.palette.mode\n        colormap = im.getdata().getpalette()\n    else:\n        colormapsize = 0\n\n    if \"offset\" in im.info:\n        offset = (rowbytes * rows + 16 + 3 + colormapsize) // 4\n    else:\n        offset = 0\n\n    fp.write(o16b(cols) + o16b(rows) + o16b(rowbytes) + o16b(flags))\n    fp.write(o8(bpp))\n    fp.write(o8(version))\n    fp.write(o16b(offset))\n    fp.write(o8(transparent_index))\n    fp.write(o8(compression_type))\n    fp.write(o16b(0))  # reserved by Palm\n\n    # now write colormap if necessary\n\n    if colormapsize > 0:\n        fp.write(o16b(256))\n        for i in range(256):\n            fp.write(o8(i))\n            if colormapmode == \"RGB\":\n                fp.write(\n                    o8(colormap[3 * i])\n                    + o8(colormap[3 * i + 1])\n                    + o8(colormap[3 * i + 2])\n                )\n            elif colormapmode == \"RGBA\":\n                fp.write(\n                    o8(colormap[4 * i])\n                    + o8(colormap[4 * i + 1])\n                    + o8(colormap[4 * i + 2])\n                )\n\n    # now convert data to raw form\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, rowbytes, 1))])\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_save(\"Palm\", _save)\n\nImage.register_extension(\"Palm\", \".palm\")\n\nImage.register_mime(\"Palm\", \"image/palm\")\n", "src/PIL/BdfFontFile.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# bitmap distribution font (bdf) file parser\n#\n# history:\n# 1996-05-16 fl   created (as bdf2pil)\n# 1997-08-25 fl   converted to FontFile driver\n# 2001-05-25 fl   removed bogus __init__ call\n# 2002-11-20 fl   robustification (from Kevin Cazabon, Dmitry Vasiliev)\n# 2003-04-22 fl   more robustification (from Graham Dumpleton)\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1997-2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nParse X Bitmap Distribution Format (BDF)\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import BinaryIO\n\nfrom . import FontFile, Image\n\nbdf_slant = {\n    \"R\": \"Roman\",\n    \"I\": \"Italic\",\n    \"O\": \"Oblique\",\n    \"RI\": \"Reverse Italic\",\n    \"RO\": \"Reverse Oblique\",\n    \"OT\": \"Other\",\n}\n\nbdf_spacing = {\"P\": \"Proportional\", \"M\": \"Monospaced\", \"C\": \"Cell\"}\n\n\ndef bdf_char(\n    f: BinaryIO,\n) -> (\n    tuple[\n        str,\n        int,\n        tuple[tuple[int, int], tuple[int, int, int, int], tuple[int, int, int, int]],\n        Image.Image,\n    ]\n    | None\n):\n    # skip to STARTCHAR\n    while True:\n        s = f.readline()\n        if not s:\n            return None\n        if s[:9] == b\"STARTCHAR\":\n            break\n    id = s[9:].strip().decode(\"ascii\")\n\n    # load symbol properties\n    props = {}\n    while True:\n        s = f.readline()\n        if not s or s[:6] == b\"BITMAP\":\n            break\n        i = s.find(b\" \")\n        props[s[:i].decode(\"ascii\")] = s[i + 1 : -1].decode(\"ascii\")\n\n    # load bitmap\n    bitmap = bytearray()\n    while True:\n        s = f.readline()\n        if not s or s[:7] == b\"ENDCHAR\":\n            break\n        bitmap += s[:-1]\n\n    # The word BBX\n    # followed by the width in x (BBw), height in y (BBh),\n    # and x and y displacement (BBxoff0, BByoff0)\n    # of the lower left corner from the origin of the character.\n    width, height, x_disp, y_disp = (int(p) for p in props[\"BBX\"].split())\n\n    # The word DWIDTH\n    # followed by the width in x and y of the character in device pixels.\n    dwx, dwy = (int(p) for p in props[\"DWIDTH\"].split())\n\n    bbox = (\n        (dwx, dwy),\n        (x_disp, -y_disp - height, width + x_disp, -y_disp),\n        (0, 0, width, height),\n    )\n\n    try:\n        im = Image.frombytes(\"1\", (width, height), bitmap, \"hex\", \"1\")\n    except ValueError:\n        # deal with zero-width characters\n        im = Image.new(\"1\", (width, height))\n\n    return id, int(props[\"ENCODING\"]), bbox, im\n\n\nclass BdfFontFile(FontFile.FontFile):\n    \"\"\"Font file plugin for the X11 BDF format.\"\"\"\n\n    def __init__(self, fp: BinaryIO) -> None:\n        super().__init__()\n\n        s = fp.readline()\n        if s[:13] != b\"STARTFONT 2.1\":\n            msg = \"not a valid BDF file\"\n            raise SyntaxError(msg)\n\n        props = {}\n        comments = []\n\n        while True:\n            s = fp.readline()\n            if not s or s[:13] == b\"ENDPROPERTIES\":\n                break\n            i = s.find(b\" \")\n            props[s[:i].decode(\"ascii\")] = s[i + 1 : -1].decode(\"ascii\")\n            if s[:i] in [b\"COMMENT\", b\"COPYRIGHT\"]:\n                if s.find(b\"LogicalFontDescription\") < 0:\n                    comments.append(s[i + 1 : -1].decode(\"ascii\"))\n\n        while True:\n            c = bdf_char(fp)\n            if not c:\n                break\n            id, ch, (xy, dst, src), im = c\n            if 0 <= ch < len(self.glyph):\n                self.glyph[ch] = xy, dst, src, im\n", "src/PIL/SpiderImagePlugin.py": "#\n# The Python Imaging Library.\n#\n# SPIDER image file handling\n#\n# History:\n# 2004-08-02    Created BB\n# 2006-03-02    added save method\n# 2006-03-13    added support for stack images\n#\n# Copyright (c) 2004 by Health Research Inc. (HRI) RENSSELAER, NY 12144.\n# Copyright (c) 2004 by William Baxter.\n# Copyright (c) 2004 by Secret Labs AB.\n# Copyright (c) 2004 by Fredrik Lundh.\n#\n\n##\n# Image plugin for the Spider image format. This format is used\n# by the SPIDER software, in processing image data from electron\n# microscopy and tomography.\n##\n\n#\n# SpiderImagePlugin.py\n#\n# The Spider image format is used by SPIDER software, in processing\n# image data from electron microscopy and tomography.\n#\n# Spider home page:\n# https://spider.wadsworth.org/spider_doc/spider/docs/spider.html\n#\n# Details about the Spider image format:\n# https://spider.wadsworth.org/spider_doc/spider/docs/image_doc.html\n#\nfrom __future__ import annotations\n\nimport os\nimport struct\nimport sys\nfrom typing import IO, TYPE_CHECKING\n\nfrom . import Image, ImageFile\n\n\ndef isInt(f):\n    try:\n        i = int(f)\n        if f - i == 0:\n            return 1\n        else:\n            return 0\n    except (ValueError, OverflowError):\n        return 0\n\n\niforms = [1, 3, -11, -12, -21, -22]\n\n\n# There is no magic number to identify Spider files, so just check a\n# series of header locations to see if they have reasonable values.\n# Returns no. of bytes in the header, if it is a valid Spider header,\n# otherwise returns 0\n\n\ndef isSpiderHeader(t):\n    h = (99,) + t  # add 1 value so can use spider header index start=1\n    # header values 1,2,5,12,13,22,23 should be integers\n    for i in [1, 2, 5, 12, 13, 22, 23]:\n        if not isInt(h[i]):\n            return 0\n    # check iform\n    iform = int(h[5])\n    if iform not in iforms:\n        return 0\n    # check other header values\n    labrec = int(h[13])  # no. records in file header\n    labbyt = int(h[22])  # total no. of bytes in header\n    lenbyt = int(h[23])  # record length in bytes\n    if labbyt != (labrec * lenbyt):\n        return 0\n    # looks like a valid header\n    return labbyt\n\n\ndef isSpiderImage(filename):\n    with open(filename, \"rb\") as fp:\n        f = fp.read(92)  # read 23 * 4 bytes\n    t = struct.unpack(\">23f\", f)  # try big-endian first\n    hdrlen = isSpiderHeader(t)\n    if hdrlen == 0:\n        t = struct.unpack(\"<23f\", f)  # little-endian\n        hdrlen = isSpiderHeader(t)\n    return hdrlen\n\n\nclass SpiderImageFile(ImageFile.ImageFile):\n    format = \"SPIDER\"\n    format_description = \"Spider 2D image\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # check header\n        n = 27 * 4  # read 27 float values\n        f = self.fp.read(n)\n\n        try:\n            self.bigendian = 1\n            t = struct.unpack(\">27f\", f)  # try big-endian first\n            hdrlen = isSpiderHeader(t)\n            if hdrlen == 0:\n                self.bigendian = 0\n                t = struct.unpack(\"<27f\", f)  # little-endian\n                hdrlen = isSpiderHeader(t)\n            if hdrlen == 0:\n                msg = \"not a valid Spider file\"\n                raise SyntaxError(msg)\n        except struct.error as e:\n            msg = \"not a valid Spider file\"\n            raise SyntaxError(msg) from e\n\n        h = (99,) + t  # add 1 value : spider header index starts at 1\n        iform = int(h[5])\n        if iform != 1:\n            msg = \"not a Spider 2D image\"\n            raise SyntaxError(msg)\n\n        self._size = int(h[12]), int(h[2])  # size in pixels (width, height)\n        self.istack = int(h[24])\n        self.imgnumber = int(h[27])\n\n        if self.istack == 0 and self.imgnumber == 0:\n            # stk=0, img=0: a regular 2D image\n            offset = hdrlen\n            self._nimages = 1\n        elif self.istack > 0 and self.imgnumber == 0:\n            # stk>0, img=0: Opening the stack for the first time\n            self.imgbytes = int(h[12]) * int(h[2]) * 4\n            self.hdrlen = hdrlen\n            self._nimages = int(h[26])\n            # Point to the first image in the stack\n            offset = hdrlen * 2\n            self.imgnumber = 1\n        elif self.istack == 0 and self.imgnumber > 0:\n            # stk=0, img>0: an image within the stack\n            offset = hdrlen + self.stkoffset\n            self.istack = 2  # So Image knows it's still a stack\n        else:\n            msg = \"inconsistent stack header values\"\n            raise SyntaxError(msg)\n\n        if self.bigendian:\n            self.rawmode = \"F;32BF\"\n        else:\n            self.rawmode = \"F;32F\"\n        self._mode = \"F\"\n\n        self.tile = [(\"raw\", (0, 0) + self.size, offset, (self.rawmode, 0, 1))]\n        self._fp = self.fp  # FIXME: hack\n\n    @property\n    def n_frames(self) -> int:\n        return self._nimages\n\n    @property\n    def is_animated(self) -> bool:\n        return self._nimages > 1\n\n    # 1st image index is zero (although SPIDER imgnumber starts at 1)\n    def tell(self) -> int:\n        if self.imgnumber < 1:\n            return 0\n        else:\n            return self.imgnumber - 1\n\n    def seek(self, frame: int) -> None:\n        if self.istack == 0:\n            msg = \"attempt to seek in a non-stack file\"\n            raise EOFError(msg)\n        if not self._seek_check(frame):\n            return\n        self.stkoffset = self.hdrlen + frame * (self.hdrlen + self.imgbytes)\n        self.fp = self._fp\n        self.fp.seek(self.stkoffset)\n        self._open()\n\n    # returns a byte image after rescaling to 0..255\n    def convert2byte(self, depth=255):\n        (minimum, maximum) = self.getextrema()\n        m = 1\n        if maximum != minimum:\n            m = depth / (maximum - minimum)\n        b = -m * minimum\n        return self.point(lambda i, m=m, b=b: i * m + b).convert(\"L\")\n\n    if TYPE_CHECKING:\n        from . import ImageTk\n\n    # returns a ImageTk.PhotoImage object, after rescaling to 0..255\n    def tkPhotoImage(self) -> ImageTk.PhotoImage:\n        from . import ImageTk\n\n        return ImageTk.PhotoImage(self.convert2byte(), palette=256)\n\n\n# --------------------------------------------------------------------\n# Image series\n\n\n# given a list of filenames, return a list of images\ndef loadImageSeries(filelist=None):\n    \"\"\"create a list of :py:class:`~PIL.Image.Image` objects for use in a montage\"\"\"\n    if filelist is None or len(filelist) < 1:\n        return\n\n    imglist = []\n    for img in filelist:\n        if not os.path.exists(img):\n            print(f\"unable to find {img}\")\n            continue\n        try:\n            with Image.open(img) as im:\n                im = im.convert2byte()\n        except Exception:\n            if not isSpiderImage(img):\n                print(f\"{img} is not a Spider image file\")\n            continue\n        im.info[\"filename\"] = img\n        imglist.append(im)\n    return imglist\n\n\n# --------------------------------------------------------------------\n# For saving images in Spider format\n\n\ndef makeSpiderHeader(im: Image.Image) -> list[bytes]:\n    nsam, nrow = im.size\n    lenbyt = nsam * 4  # There are labrec records in the header\n    labrec = int(1024 / lenbyt)\n    if 1024 % lenbyt != 0:\n        labrec += 1\n    labbyt = labrec * lenbyt\n    nvalues = int(labbyt / 4)\n    if nvalues < 23:\n        return []\n\n    hdr = [0.0] * nvalues\n\n    # NB these are Fortran indices\n    hdr[1] = 1.0  # nslice (=1 for an image)\n    hdr[2] = float(nrow)  # number of rows per slice\n    hdr[3] = float(nrow)  # number of records in the image\n    hdr[5] = 1.0  # iform for 2D image\n    hdr[12] = float(nsam)  # number of pixels per line\n    hdr[13] = float(labrec)  # number of records in file header\n    hdr[22] = float(labbyt)  # total number of bytes in header\n    hdr[23] = float(lenbyt)  # record length in bytes\n\n    # adjust for Fortran indexing\n    hdr = hdr[1:]\n    hdr.append(0.0)\n    # pack binary data into a string\n    return [struct.pack(\"f\", v) for v in hdr]\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode[0] != \"F\":\n        im = im.convert(\"F\")\n\n    hdr = makeSpiderHeader(im)\n    if len(hdr) < 256:\n        msg = \"Error creating Spider header\"\n        raise OSError(msg)\n\n    # write the SPIDER header\n    fp.writelines(hdr)\n\n    rawmode = \"F;32NF\"  # 32-bit native floating point\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, 1))])\n\n\ndef _save_spider(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # get the filename extension and register it with Image\n    filename_ext = os.path.splitext(filename)[1]\n    ext = filename_ext.decode() if isinstance(filename_ext, bytes) else filename_ext\n    Image.register_extension(SpiderImageFile.format, ext)\n    _save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n\n\nImage.register_open(SpiderImageFile.format, SpiderImageFile)\nImage.register_save(SpiderImageFile.format, _save_spider)\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Syntax: python3 SpiderImagePlugin.py [infile] [outfile]\")\n        sys.exit()\n\n    filename = sys.argv[1]\n    if not isSpiderImage(filename):\n        print(\"input image must be in Spider format\")\n        sys.exit()\n\n    with Image.open(filename) as im:\n        print(f\"image: {im}\")\n        print(f\"format: {im.format}\")\n        print(f\"size: {im.size}\")\n        print(f\"mode: {im.mode}\")\n        print(\"max, min: \", end=\" \")\n        print(im.getextrema())\n\n        if len(sys.argv) > 2:\n            outfile = sys.argv[2]\n\n            # perform some image operation\n            im = im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)\n            print(\n                f\"saving a flipped version of {os.path.basename(filename)} \"\n                f\"as {outfile} \"\n            )\n            im.save(outfile, SpiderImageFile.format)\n", "src/PIL/ContainerIO.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a class to read from a container file\n#\n# History:\n# 1995-06-18 fl     Created\n# 1995-09-07 fl     Added readline(), readlines()\n#\n# Copyright (c) 1997-2001 by Secret Labs AB\n# Copyright (c) 1995 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nfrom typing import IO, AnyStr, Generic, Literal\n\n\nclass ContainerIO(Generic[AnyStr]):\n    \"\"\"\n    A file object that provides read access to a part of an existing\n    file (for example a TAR file).\n    \"\"\"\n\n    def __init__(self, file: IO[AnyStr], offset: int, length: int) -> None:\n        \"\"\"\n        Create file object.\n\n        :param file: Existing file.\n        :param offset: Start of region, in bytes.\n        :param length: Size of region, in bytes.\n        \"\"\"\n        self.fh: IO[AnyStr] = file\n        self.pos = 0\n        self.offset = offset\n        self.length = length\n        self.fh.seek(offset)\n\n    ##\n    # Always false.\n\n    def isatty(self) -> bool:\n        return False\n\n    def seek(self, offset: int, mode: Literal[0, 1, 2] = io.SEEK_SET) -> None:\n        \"\"\"\n        Move file pointer.\n\n        :param offset: Offset in bytes.\n        :param mode: Starting position. Use 0 for beginning of region, 1\n           for current offset, and 2 for end of region.  You cannot move\n           the pointer outside the defined region.\n        \"\"\"\n        if mode == 1:\n            self.pos = self.pos + offset\n        elif mode == 2:\n            self.pos = self.length + offset\n        else:\n            self.pos = offset\n        # clamp\n        self.pos = max(0, min(self.pos, self.length))\n        self.fh.seek(self.offset + self.pos)\n\n    def tell(self) -> int:\n        \"\"\"\n        Get current file pointer.\n\n        :returns: Offset from start of region, in bytes.\n        \"\"\"\n        return self.pos\n\n    def read(self, n: int = 0) -> AnyStr:\n        \"\"\"\n        Read data.\n\n        :param n: Number of bytes to read. If omitted or zero,\n            read until end of region.\n        :returns: An 8-bit string.\n        \"\"\"\n        if n:\n            n = min(n, self.length - self.pos)\n        else:\n            n = self.length - self.pos\n        if not n:  # EOF\n            return b\"\" if \"b\" in self.fh.mode else \"\"  # type: ignore[return-value]\n        self.pos = self.pos + n\n        return self.fh.read(n)\n\n    def readline(self) -> AnyStr:\n        \"\"\"\n        Read a line of text.\n\n        :returns: An 8-bit string.\n        \"\"\"\n        s: AnyStr = b\"\" if \"b\" in self.fh.mode else \"\"  # type: ignore[assignment]\n        newline_character = b\"\\n\" if \"b\" in self.fh.mode else \"\\n\"\n        while True:\n            c = self.read(1)\n            if not c:\n                break\n            s = s + c\n            if c == newline_character:\n                break\n        return s\n\n    def readlines(self) -> list[AnyStr]:\n        \"\"\"\n        Read multiple lines of text.\n\n        :returns: A list of 8-bit strings.\n        \"\"\"\n        lines = []\n        while True:\n            s = self.readline()\n            if not s:\n                break\n            lines.append(s)\n        return lines\n", "src/PIL/PdfParser.py": "from __future__ import annotations\n\nimport calendar\nimport codecs\nimport collections\nimport mmap\nimport os\nimport re\nimport time\nimport zlib\nfrom typing import TYPE_CHECKING, Any, List, NamedTuple, Union\n\n\n# see 7.9.2.2 Text String Type on page 86 and D.3 PDFDocEncoding Character Set\n# on page 656\ndef encode_text(s: str) -> bytes:\n    return codecs.BOM_UTF16_BE + s.encode(\"utf_16_be\")\n\n\nPDFDocEncoding = {\n    0x16: \"\\u0017\",\n    0x18: \"\\u02D8\",\n    0x19: \"\\u02C7\",\n    0x1A: \"\\u02C6\",\n    0x1B: \"\\u02D9\",\n    0x1C: \"\\u02DD\",\n    0x1D: \"\\u02DB\",\n    0x1E: \"\\u02DA\",\n    0x1F: \"\\u02DC\",\n    0x80: \"\\u2022\",\n    0x81: \"\\u2020\",\n    0x82: \"\\u2021\",\n    0x83: \"\\u2026\",\n    0x84: \"\\u2014\",\n    0x85: \"\\u2013\",\n    0x86: \"\\u0192\",\n    0x87: \"\\u2044\",\n    0x88: \"\\u2039\",\n    0x89: \"\\u203A\",\n    0x8A: \"\\u2212\",\n    0x8B: \"\\u2030\",\n    0x8C: \"\\u201E\",\n    0x8D: \"\\u201C\",\n    0x8E: \"\\u201D\",\n    0x8F: \"\\u2018\",\n    0x90: \"\\u2019\",\n    0x91: \"\\u201A\",\n    0x92: \"\\u2122\",\n    0x93: \"\\uFB01\",\n    0x94: \"\\uFB02\",\n    0x95: \"\\u0141\",\n    0x96: \"\\u0152\",\n    0x97: \"\\u0160\",\n    0x98: \"\\u0178\",\n    0x99: \"\\u017D\",\n    0x9A: \"\\u0131\",\n    0x9B: \"\\u0142\",\n    0x9C: \"\\u0153\",\n    0x9D: \"\\u0161\",\n    0x9E: \"\\u017E\",\n    0xA0: \"\\u20AC\",\n}\n\n\ndef decode_text(b):\n    if b[: len(codecs.BOM_UTF16_BE)] == codecs.BOM_UTF16_BE:\n        return b[len(codecs.BOM_UTF16_BE) :].decode(\"utf_16_be\")\n    else:\n        return \"\".join(PDFDocEncoding.get(byte, chr(byte)) for byte in b)\n\n\nclass PdfFormatError(RuntimeError):\n    \"\"\"An error that probably indicates a syntactic or semantic error in the\n    PDF file structure\"\"\"\n\n    pass\n\n\ndef check_format_condition(condition: bool, error_message: str) -> None:\n    if not condition:\n        raise PdfFormatError(error_message)\n\n\nclass IndirectReferenceTuple(NamedTuple):\n    object_id: int\n    generation: int\n\n\nclass IndirectReference(IndirectReferenceTuple):\n    def __str__(self) -> str:\n        return f\"{self.object_id} {self.generation} R\"\n\n    def __bytes__(self) -> bytes:\n        return self.__str__().encode(\"us-ascii\")\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return False\n        assert isinstance(other, IndirectReference)\n        return other.object_id == self.object_id and other.generation == self.generation\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self) -> int:\n        return hash((self.object_id, self.generation))\n\n\nclass IndirectObjectDef(IndirectReference):\n    def __str__(self) -> str:\n        return f\"{self.object_id} {self.generation} obj\"\n\n\nclass XrefTable:\n    def __init__(self):\n        self.existing_entries = {}  # object ID => (offset, generation)\n        self.new_entries = {}  # object ID => (offset, generation)\n        self.deleted_entries = {0: 65536}  # object ID => generation\n        self.reading_finished = False\n\n    def __setitem__(self, key, value):\n        if self.reading_finished:\n            self.new_entries[key] = value\n        else:\n            self.existing_entries[key] = value\n        if key in self.deleted_entries:\n            del self.deleted_entries[key]\n\n    def __getitem__(self, key):\n        try:\n            return self.new_entries[key]\n        except KeyError:\n            return self.existing_entries[key]\n\n    def __delitem__(self, key):\n        if key in self.new_entries:\n            generation = self.new_entries[key][1] + 1\n            del self.new_entries[key]\n            self.deleted_entries[key] = generation\n        elif key in self.existing_entries:\n            generation = self.existing_entries[key][1] + 1\n            self.deleted_entries[key] = generation\n        elif key in self.deleted_entries:\n            generation = self.deleted_entries[key]\n        else:\n            msg = f\"object ID {key} cannot be deleted because it doesn't exist\"\n            raise IndexError(msg)\n\n    def __contains__(self, key):\n        return key in self.existing_entries or key in self.new_entries\n\n    def __len__(self) -> int:\n        return len(\n            set(self.existing_entries.keys())\n            | set(self.new_entries.keys())\n            | set(self.deleted_entries.keys())\n        )\n\n    def keys(self):\n        return (\n            set(self.existing_entries.keys()) - set(self.deleted_entries.keys())\n        ) | set(self.new_entries.keys())\n\n    def write(self, f):\n        keys = sorted(set(self.new_entries.keys()) | set(self.deleted_entries.keys()))\n        deleted_keys = sorted(set(self.deleted_entries.keys()))\n        startxref = f.tell()\n        f.write(b\"xref\\n\")\n        while keys:\n            # find a contiguous sequence of object IDs\n            prev = None\n            for index, key in enumerate(keys):\n                if prev is None or prev + 1 == key:\n                    prev = key\n                else:\n                    contiguous_keys = keys[:index]\n                    keys = keys[index:]\n                    break\n            else:\n                contiguous_keys = keys\n                keys = None\n            f.write(b\"%d %d\\n\" % (contiguous_keys[0], len(contiguous_keys)))\n            for object_id in contiguous_keys:\n                if object_id in self.new_entries:\n                    f.write(b\"%010d %05d n \\n\" % self.new_entries[object_id])\n                else:\n                    this_deleted_object_id = deleted_keys.pop(0)\n                    check_format_condition(\n                        object_id == this_deleted_object_id,\n                        f\"expected the next deleted object ID to be {object_id}, \"\n                        f\"instead found {this_deleted_object_id}\",\n                    )\n                    try:\n                        next_in_linked_list = deleted_keys[0]\n                    except IndexError:\n                        next_in_linked_list = 0\n                    f.write(\n                        b\"%010d %05d f \\n\"\n                        % (next_in_linked_list, self.deleted_entries[object_id])\n                    )\n        return startxref\n\n\nclass PdfName:\n    def __init__(self, name):\n        if isinstance(name, PdfName):\n            self.name = name.name\n        elif isinstance(name, bytes):\n            self.name = name\n        else:\n            self.name = name.encode(\"us-ascii\")\n\n    def name_as_str(self) -> str:\n        return self.name.decode(\"us-ascii\")\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, PdfName) and other.name == self.name\n        ) or other == self.name\n\n    def __hash__(self) -> int:\n        return hash(self.name)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({repr(self.name)})\"\n\n    @classmethod\n    def from_pdf_stream(cls, data):\n        return cls(PdfParser.interpret_name(data))\n\n    allowed_chars = set(range(33, 127)) - {ord(c) for c in \"#%/()<>[]{}\"}\n\n    def __bytes__(self) -> bytes:\n        result = bytearray(b\"/\")\n        for b in self.name:\n            if b in self.allowed_chars:\n                result.append(b)\n            else:\n                result.extend(b\"#%02X\" % b)\n        return bytes(result)\n\n\nclass PdfArray(List[Any]):\n    def __bytes__(self) -> bytes:\n        return b\"[ \" + b\" \".join(pdf_repr(x) for x in self) + b\" ]\"\n\n\nif TYPE_CHECKING:\n    _DictBase = collections.UserDict[Union[str, bytes], Any]\nelse:\n    _DictBase = collections.UserDict\n\n\nclass PdfDict(_DictBase):\n    def __setattr__(self, key, value):\n        if key == \"data\":\n            collections.UserDict.__setattr__(self, key, value)\n        else:\n            self[key.encode(\"us-ascii\")] = value\n\n    def __getattr__(self, key):\n        try:\n            value = self[key.encode(\"us-ascii\")]\n        except KeyError as e:\n            raise AttributeError(key) from e\n        if isinstance(value, bytes):\n            value = decode_text(value)\n        if key.endswith(\"Date\"):\n            if value.startswith(\"D:\"):\n                value = value[2:]\n\n            relationship = \"Z\"\n            if len(value) > 17:\n                relationship = value[14]\n                offset = int(value[15:17]) * 60\n                if len(value) > 20:\n                    offset += int(value[18:20])\n\n            format = \"%Y%m%d%H%M%S\"[: len(value) - 2]\n            value = time.strptime(value[: len(format) + 2], format)\n            if relationship in [\"+\", \"-\"]:\n                offset *= 60\n                if relationship == \"+\":\n                    offset *= -1\n                value = time.gmtime(calendar.timegm(value) + offset)\n        return value\n\n    def __bytes__(self) -> bytes:\n        out = bytearray(b\"<<\")\n        for key, value in self.items():\n            if value is None:\n                continue\n            value = pdf_repr(value)\n            out.extend(b\"\\n\")\n            out.extend(bytes(PdfName(key)))\n            out.extend(b\" \")\n            out.extend(value)\n        out.extend(b\"\\n>>\")\n        return bytes(out)\n\n\nclass PdfBinary:\n    def __init__(self, data):\n        self.data = data\n\n    def __bytes__(self) -> bytes:\n        return b\"<%s>\" % b\"\".join(b\"%02X\" % b for b in self.data)\n\n\nclass PdfStream:\n    def __init__(self, dictionary, buf):\n        self.dictionary = dictionary\n        self.buf = buf\n\n    def decode(self):\n        try:\n            filter = self.dictionary.Filter\n        except AttributeError:\n            return self.buf\n        if filter == b\"FlateDecode\":\n            try:\n                expected_length = self.dictionary.DL\n            except AttributeError:\n                expected_length = self.dictionary.Length\n            return zlib.decompress(self.buf, bufsize=int(expected_length))\n        else:\n            msg = f\"stream filter {repr(self.dictionary.Filter)} unknown/unsupported\"\n            raise NotImplementedError(msg)\n\n\ndef pdf_repr(x):\n    if x is True:\n        return b\"true\"\n    elif x is False:\n        return b\"false\"\n    elif x is None:\n        return b\"null\"\n    elif isinstance(x, (PdfName, PdfDict, PdfArray, PdfBinary)):\n        return bytes(x)\n    elif isinstance(x, (int, float)):\n        return str(x).encode(\"us-ascii\")\n    elif isinstance(x, time.struct_time):\n        return b\"(D:\" + time.strftime(\"%Y%m%d%H%M%SZ\", x).encode(\"us-ascii\") + b\")\"\n    elif isinstance(x, dict):\n        return bytes(PdfDict(x))\n    elif isinstance(x, list):\n        return bytes(PdfArray(x))\n    elif isinstance(x, str):\n        return pdf_repr(encode_text(x))\n    elif isinstance(x, bytes):\n        # XXX escape more chars? handle binary garbage\n        x = x.replace(b\"\\\\\", b\"\\\\\\\\\")\n        x = x.replace(b\"(\", b\"\\\\(\")\n        x = x.replace(b\")\", b\"\\\\)\")\n        return b\"(\" + x + b\")\"\n    else:\n        return bytes(x)\n\n\nclass PdfParser:\n    \"\"\"Based on\n    https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf\n    Supports PDF up to 1.4\n    \"\"\"\n\n    def __init__(self, filename=None, f=None, buf=None, start_offset=0, mode=\"rb\"):\n        if buf and f:\n            msg = \"specify buf or f or filename, but not both buf and f\"\n            raise RuntimeError(msg)\n        self.filename = filename\n        self.buf = buf\n        self.f = f\n        self.start_offset = start_offset\n        self.should_close_buf = False\n        self.should_close_file = False\n        if filename is not None and f is None:\n            self.f = f = open(filename, mode)\n            self.should_close_file = True\n        if f is not None:\n            self.buf = buf = self.get_buf_from_file(f)\n            self.should_close_buf = True\n            if not filename and hasattr(f, \"name\"):\n                self.filename = f.name\n        self.cached_objects = {}\n        if buf:\n            self.read_pdf_info()\n        else:\n            self.file_size_total = self.file_size_this = 0\n            self.root = PdfDict()\n            self.root_ref = None\n            self.info = PdfDict()\n            self.info_ref = None\n            self.page_tree_root = {}\n            self.pages = []\n            self.orig_pages = []\n            self.pages_ref = None\n            self.last_xref_section_offset = None\n            self.trailer_dict = {}\n            self.xref_table = XrefTable()\n        self.xref_table.reading_finished = True\n        if f:\n            self.seek_end()\n\n    def __enter__(self) -> PdfParser:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def start_writing(self) -> None:\n        self.close_buf()\n        self.seek_end()\n\n    def close_buf(self) -> None:\n        try:\n            self.buf.close()\n        except AttributeError:\n            pass\n        self.buf = None\n\n    def close(self) -> None:\n        if self.should_close_buf:\n            self.close_buf()\n        if self.f is not None and self.should_close_file:\n            self.f.close()\n            self.f = None\n\n    def seek_end(self) -> None:\n        self.f.seek(0, os.SEEK_END)\n\n    def write_header(self) -> None:\n        self.f.write(b\"%PDF-1.4\\n\")\n\n    def write_comment(self, s):\n        self.f.write(f\"% {s}\\n\".encode())\n\n    def write_catalog(self) -> IndirectReference:\n        self.del_root()\n        self.root_ref = self.next_object_id(self.f.tell())\n        self.pages_ref = self.next_object_id(0)\n        self.rewrite_pages()\n        self.write_obj(self.root_ref, Type=PdfName(b\"Catalog\"), Pages=self.pages_ref)\n        self.write_obj(\n            self.pages_ref,\n            Type=PdfName(b\"Pages\"),\n            Count=len(self.pages),\n            Kids=self.pages,\n        )\n        return self.root_ref\n\n    def rewrite_pages(self) -> None:\n        pages_tree_nodes_to_delete = []\n        for i, page_ref in enumerate(self.orig_pages):\n            page_info = self.cached_objects[page_ref]\n            del self.xref_table[page_ref.object_id]\n            pages_tree_nodes_to_delete.append(page_info[PdfName(b\"Parent\")])\n            if page_ref not in self.pages:\n                # the page has been deleted\n                continue\n            # make dict keys into strings for passing to write_page\n            stringified_page_info = {}\n            for key, value in page_info.items():\n                # key should be a PdfName\n                stringified_page_info[key.name_as_str()] = value\n            stringified_page_info[\"Parent\"] = self.pages_ref\n            new_page_ref = self.write_page(None, **stringified_page_info)\n            for j, cur_page_ref in enumerate(self.pages):\n                if cur_page_ref == page_ref:\n                    # replace the page reference with the new one\n                    self.pages[j] = new_page_ref\n        # delete redundant Pages tree nodes from xref table\n        for pages_tree_node_ref in pages_tree_nodes_to_delete:\n            while pages_tree_node_ref:\n                pages_tree_node = self.cached_objects[pages_tree_node_ref]\n                if pages_tree_node_ref.object_id in self.xref_table:\n                    del self.xref_table[pages_tree_node_ref.object_id]\n                pages_tree_node_ref = pages_tree_node.get(b\"Parent\", None)\n        self.orig_pages = []\n\n    def write_xref_and_trailer(self, new_root_ref=None):\n        if new_root_ref:\n            self.del_root()\n            self.root_ref = new_root_ref\n        if self.info:\n            self.info_ref = self.write_obj(None, self.info)\n        start_xref = self.xref_table.write(self.f)\n        num_entries = len(self.xref_table)\n        trailer_dict = {b\"Root\": self.root_ref, b\"Size\": num_entries}\n        if self.last_xref_section_offset is not None:\n            trailer_dict[b\"Prev\"] = self.last_xref_section_offset\n        if self.info:\n            trailer_dict[b\"Info\"] = self.info_ref\n        self.last_xref_section_offset = start_xref\n        self.f.write(\n            b\"trailer\\n\"\n            + bytes(PdfDict(trailer_dict))\n            + b\"\\nstartxref\\n%d\\n%%%%EOF\" % start_xref\n        )\n\n    def write_page(self, ref, *objs, **dict_obj):\n        if isinstance(ref, int):\n            ref = self.pages[ref]\n        if \"Type\" not in dict_obj:\n            dict_obj[\"Type\"] = PdfName(b\"Page\")\n        if \"Parent\" not in dict_obj:\n            dict_obj[\"Parent\"] = self.pages_ref\n        return self.write_obj(ref, *objs, **dict_obj)\n\n    def write_obj(self, ref, *objs, **dict_obj):\n        f = self.f\n        if ref is None:\n            ref = self.next_object_id(f.tell())\n        else:\n            self.xref_table[ref.object_id] = (f.tell(), ref.generation)\n        f.write(bytes(IndirectObjectDef(*ref)))\n        stream = dict_obj.pop(\"stream\", None)\n        if stream is not None:\n            dict_obj[\"Length\"] = len(stream)\n        if dict_obj:\n            f.write(pdf_repr(dict_obj))\n        for obj in objs:\n            f.write(pdf_repr(obj))\n        if stream is not None:\n            f.write(b\"stream\\n\")\n            f.write(stream)\n            f.write(b\"\\nendstream\\n\")\n        f.write(b\"endobj\\n\")\n        return ref\n\n    def del_root(self) -> None:\n        if self.root_ref is None:\n            return\n        del self.xref_table[self.root_ref.object_id]\n        del self.xref_table[self.root[b\"Pages\"].object_id]\n\n    @staticmethod\n    def get_buf_from_file(f):\n        if hasattr(f, \"getbuffer\"):\n            return f.getbuffer()\n        elif hasattr(f, \"getvalue\"):\n            return f.getvalue()\n        else:\n            try:\n                return mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\n            except ValueError:  # cannot mmap an empty file\n                return b\"\"\n\n    def read_pdf_info(self) -> None:\n        self.file_size_total = len(self.buf)\n        self.file_size_this = self.file_size_total - self.start_offset\n        self.read_trailer()\n        self.root_ref = self.trailer_dict[b\"Root\"]\n        self.info_ref = self.trailer_dict.get(b\"Info\", None)\n        self.root = PdfDict(self.read_indirect(self.root_ref))\n        if self.info_ref is None:\n            self.info = PdfDict()\n        else:\n            self.info = PdfDict(self.read_indirect(self.info_ref))\n        check_format_condition(b\"Type\" in self.root, \"/Type missing in Root\")\n        check_format_condition(\n            self.root[b\"Type\"] == b\"Catalog\", \"/Type in Root is not /Catalog\"\n        )\n        check_format_condition(b\"Pages\" in self.root, \"/Pages missing in Root\")\n        check_format_condition(\n            isinstance(self.root[b\"Pages\"], IndirectReference),\n            \"/Pages in Root is not an indirect reference\",\n        )\n        self.pages_ref = self.root[b\"Pages\"]\n        self.page_tree_root = self.read_indirect(self.pages_ref)\n        self.pages = self.linearize_page_tree(self.page_tree_root)\n        # save the original list of page references\n        # in case the user modifies, adds or deletes some pages\n        # and we need to rewrite the pages and their list\n        self.orig_pages = self.pages[:]\n\n    def next_object_id(self, offset=None):\n        try:\n            # TODO: support reuse of deleted objects\n            reference = IndirectReference(max(self.xref_table.keys()) + 1, 0)\n        except ValueError:\n            reference = IndirectReference(1, 0)\n        if offset is not None:\n            self.xref_table[reference.object_id] = (offset, 0)\n        return reference\n\n    delimiter = rb\"[][()<>{}/%]\"\n    delimiter_or_ws = rb\"[][()<>{}/%\\000\\011\\012\\014\\015\\040]\"\n    whitespace = rb\"[\\000\\011\\012\\014\\015\\040]\"\n    whitespace_or_hex = rb\"[\\000\\011\\012\\014\\015\\0400-9a-fA-F]\"\n    whitespace_optional = whitespace + b\"*\"\n    whitespace_mandatory = whitespace + b\"+\"\n    # No \"\\012\" aka \"\\n\" or \"\\015\" aka \"\\r\":\n    whitespace_optional_no_nl = rb\"[\\000\\011\\014\\040]*\"\n    newline_only = rb\"[\\r\\n]+\"\n    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl\n    re_trailer_end = re.compile(\n        whitespace_mandatory\n        + rb\"trailer\"\n        + whitespace_optional\n        + rb\"<<(.*>>)\"\n        + newline\n        + rb\"startxref\"\n        + newline\n        + rb\"([0-9]+)\"\n        + newline\n        + rb\"%%EOF\"\n        + whitespace_optional\n        + rb\"$\",\n        re.DOTALL,\n    )\n    re_trailer_prev = re.compile(\n        whitespace_optional\n        + rb\"trailer\"\n        + whitespace_optional\n        + rb\"<<(.*?>>)\"\n        + newline\n        + rb\"startxref\"\n        + newline\n        + rb\"([0-9]+)\"\n        + newline\n        + rb\"%%EOF\"\n        + whitespace_optional,\n        re.DOTALL,\n    )\n\n    def read_trailer(self):\n        search_start_offset = len(self.buf) - 16384\n        if search_start_offset < self.start_offset:\n            search_start_offset = self.start_offset\n        m = self.re_trailer_end.search(self.buf, search_start_offset)\n        check_format_condition(m, \"trailer end not found\")\n        # make sure we found the LAST trailer\n        last_match = m\n        while m:\n            last_match = m\n            m = self.re_trailer_end.search(self.buf, m.start() + 16)\n        if not m:\n            m = last_match\n        trailer_data = m.group(1)\n        self.last_xref_section_offset = int(m.group(2))\n        self.trailer_dict = self.interpret_trailer(trailer_data)\n        self.xref_table = XrefTable()\n        self.read_xref_table(xref_section_offset=self.last_xref_section_offset)\n        if b\"Prev\" in self.trailer_dict:\n            self.read_prev_trailer(self.trailer_dict[b\"Prev\"])\n\n    def read_prev_trailer(self, xref_section_offset):\n        trailer_offset = self.read_xref_table(xref_section_offset=xref_section_offset)\n        m = self.re_trailer_prev.search(\n            self.buf[trailer_offset : trailer_offset + 16384]\n        )\n        check_format_condition(m, \"previous trailer not found\")\n        trailer_data = m.group(1)\n        check_format_condition(\n            int(m.group(2)) == xref_section_offset,\n            \"xref section offset in previous trailer doesn't match what was expected\",\n        )\n        trailer_dict = self.interpret_trailer(trailer_data)\n        if b\"Prev\" in trailer_dict:\n            self.read_prev_trailer(trailer_dict[b\"Prev\"])\n\n    re_whitespace_optional = re.compile(whitespace_optional)\n    re_name = re.compile(\n        whitespace_optional\n        + rb\"/([!-$&'*-.0-;=?-Z\\\\^-z|~]+)(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_dict_start = re.compile(whitespace_optional + rb\"<<\")\n    re_dict_end = re.compile(whitespace_optional + rb\">>\" + whitespace_optional)\n\n    @classmethod\n    def interpret_trailer(cls, trailer_data):\n        trailer = {}\n        offset = 0\n        while True:\n            m = cls.re_name.match(trailer_data, offset)\n            if not m:\n                m = cls.re_dict_end.match(trailer_data, offset)\n                check_format_condition(\n                    m and m.end() == len(trailer_data),\n                    \"name not found in trailer, remaining data: \"\n                    + repr(trailer_data[offset:]),\n                )\n                break\n            key = cls.interpret_name(m.group(1))\n            value, offset = cls.get_value(trailer_data, m.end())\n            trailer[key] = value\n        check_format_condition(\n            b\"Size\" in trailer and isinstance(trailer[b\"Size\"], int),\n            \"/Size not in trailer or not an integer\",\n        )\n        check_format_condition(\n            b\"Root\" in trailer and isinstance(trailer[b\"Root\"], IndirectReference),\n            \"/Root not in trailer or not an indirect reference\",\n        )\n        return trailer\n\n    re_hashes_in_name = re.compile(rb\"([^#]*)(#([0-9a-fA-F]{2}))?\")\n\n    @classmethod\n    def interpret_name(cls, raw, as_text=False):\n        name = b\"\"\n        for m in cls.re_hashes_in_name.finditer(raw):\n            if m.group(3):\n                name += m.group(1) + bytearray.fromhex(m.group(3).decode(\"us-ascii\"))\n            else:\n                name += m.group(1)\n        if as_text:\n            return name.decode(\"utf-8\")\n        else:\n            return bytes(name)\n\n    re_null = re.compile(whitespace_optional + rb\"null(?=\" + delimiter_or_ws + rb\")\")\n    re_true = re.compile(whitespace_optional + rb\"true(?=\" + delimiter_or_ws + rb\")\")\n    re_false = re.compile(whitespace_optional + rb\"false(?=\" + delimiter_or_ws + rb\")\")\n    re_int = re.compile(\n        whitespace_optional + rb\"([-+]?[0-9]+)(?=\" + delimiter_or_ws + rb\")\"\n    )\n    re_real = re.compile(\n        whitespace_optional\n        + rb\"([-+]?([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+))(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_array_start = re.compile(whitespace_optional + rb\"\\[\")\n    re_array_end = re.compile(whitespace_optional + rb\"]\")\n    re_string_hex = re.compile(\n        whitespace_optional + rb\"<(\" + whitespace_or_hex + rb\"*)>\"\n    )\n    re_string_lit = re.compile(whitespace_optional + rb\"\\(\")\n    re_indirect_reference = re.compile(\n        whitespace_optional\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"R(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_indirect_def_start = re.compile(\n        whitespace_optional\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"obj(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_indirect_def_end = re.compile(\n        whitespace_optional + rb\"endobj(?=\" + delimiter_or_ws + rb\")\"\n    )\n    re_comment = re.compile(\n        rb\"(\" + whitespace_optional + rb\"%[^\\r\\n]*\" + newline + rb\")*\"\n    )\n    re_stream_start = re.compile(whitespace_optional + rb\"stream\\r?\\n\")\n    re_stream_end = re.compile(\n        whitespace_optional + rb\"endstream(?=\" + delimiter_or_ws + rb\")\"\n    )\n\n    @classmethod\n    def get_value(cls, data, offset, expect_indirect=None, max_nesting=-1):\n        if max_nesting == 0:\n            return None, None\n        m = cls.re_comment.match(data, offset)\n        if m:\n            offset = m.end()\n        m = cls.re_indirect_def_start.match(data, offset)\n        if m:\n            check_format_condition(\n                int(m.group(1)) > 0,\n                \"indirect object definition: object ID must be greater than 0\",\n            )\n            check_format_condition(\n                int(m.group(2)) >= 0,\n                \"indirect object definition: generation must be non-negative\",\n            )\n            check_format_condition(\n                expect_indirect is None\n                or expect_indirect\n                == IndirectReference(int(m.group(1)), int(m.group(2))),\n                \"indirect object definition different than expected\",\n            )\n            object, offset = cls.get_value(data, m.end(), max_nesting=max_nesting - 1)\n            if offset is None:\n                return object, None\n            m = cls.re_indirect_def_end.match(data, offset)\n            check_format_condition(m, \"indirect object definition end not found\")\n            return object, m.end()\n        check_format_condition(\n            not expect_indirect, \"indirect object definition not found\"\n        )\n        m = cls.re_indirect_reference.match(data, offset)\n        if m:\n            check_format_condition(\n                int(m.group(1)) > 0,\n                \"indirect object reference: object ID must be greater than 0\",\n            )\n            check_format_condition(\n                int(m.group(2)) >= 0,\n                \"indirect object reference: generation must be non-negative\",\n            )\n            return IndirectReference(int(m.group(1)), int(m.group(2))), m.end()\n        m = cls.re_dict_start.match(data, offset)\n        if m:\n            offset = m.end()\n            result = {}\n            m = cls.re_dict_end.match(data, offset)\n            while not m:\n                key, offset = cls.get_value(data, offset, max_nesting=max_nesting - 1)\n                if offset is None:\n                    return result, None\n                value, offset = cls.get_value(data, offset, max_nesting=max_nesting - 1)\n                result[key] = value\n                if offset is None:\n                    return result, None\n                m = cls.re_dict_end.match(data, offset)\n            offset = m.end()\n            m = cls.re_stream_start.match(data, offset)\n            if m:\n                try:\n                    stream_len_str = result.get(b\"Length\")\n                    stream_len = int(stream_len_str)\n                except (TypeError, ValueError) as e:\n                    msg = f\"bad or missing Length in stream dict ({stream_len_str})\"\n                    raise PdfFormatError(msg) from e\n                stream_data = data[m.end() : m.end() + stream_len]\n                m = cls.re_stream_end.match(data, m.end() + stream_len)\n                check_format_condition(m, \"stream end not found\")\n                offset = m.end()\n                result = PdfStream(PdfDict(result), stream_data)\n            else:\n                result = PdfDict(result)\n            return result, offset\n        m = cls.re_array_start.match(data, offset)\n        if m:\n            offset = m.end()\n            result = []\n            m = cls.re_array_end.match(data, offset)\n            while not m:\n                value, offset = cls.get_value(data, offset, max_nesting=max_nesting - 1)\n                result.append(value)\n                if offset is None:\n                    return result, None\n                m = cls.re_array_end.match(data, offset)\n            return result, m.end()\n        m = cls.re_null.match(data, offset)\n        if m:\n            return None, m.end()\n        m = cls.re_true.match(data, offset)\n        if m:\n            return True, m.end()\n        m = cls.re_false.match(data, offset)\n        if m:\n            return False, m.end()\n        m = cls.re_name.match(data, offset)\n        if m:\n            return PdfName(cls.interpret_name(m.group(1))), m.end()\n        m = cls.re_int.match(data, offset)\n        if m:\n            return int(m.group(1)), m.end()\n        m = cls.re_real.match(data, offset)\n        if m:\n            # XXX Decimal instead of float???\n            return float(m.group(1)), m.end()\n        m = cls.re_string_hex.match(data, offset)\n        if m:\n            # filter out whitespace\n            hex_string = bytearray(\n                b for b in m.group(1) if b in b\"0123456789abcdefABCDEF\"\n            )\n            if len(hex_string) % 2 == 1:\n                # append a 0 if the length is not even - yes, at the end\n                hex_string.append(ord(b\"0\"))\n            return bytearray.fromhex(hex_string.decode(\"us-ascii\")), m.end()\n        m = cls.re_string_lit.match(data, offset)\n        if m:\n            return cls.get_literal_string(data, m.end())\n        # return None, offset  # fallback (only for debugging)\n        msg = f\"unrecognized object: {repr(data[offset : offset + 32])}\"\n        raise PdfFormatError(msg)\n\n    re_lit_str_token = re.compile(\n        rb\"(\\\\[nrtbf()\\\\])|(\\\\[0-9]{1,3})|(\\\\(\\r\\n|\\r|\\n))|(\\r\\n|\\r|\\n)|(\\()|(\\))\"\n    )\n    escaped_chars = {\n        b\"n\": b\"\\n\",\n        b\"r\": b\"\\r\",\n        b\"t\": b\"\\t\",\n        b\"b\": b\"\\b\",\n        b\"f\": b\"\\f\",\n        b\"(\": b\"(\",\n        b\")\": b\")\",\n        b\"\\\\\": b\"\\\\\",\n        ord(b\"n\"): b\"\\n\",\n        ord(b\"r\"): b\"\\r\",\n        ord(b\"t\"): b\"\\t\",\n        ord(b\"b\"): b\"\\b\",\n        ord(b\"f\"): b\"\\f\",\n        ord(b\"(\"): b\"(\",\n        ord(b\")\"): b\")\",\n        ord(b\"\\\\\"): b\"\\\\\",\n    }\n\n    @classmethod\n    def get_literal_string(cls, data, offset):\n        nesting_depth = 0\n        result = bytearray()\n        for m in cls.re_lit_str_token.finditer(data, offset):\n            result.extend(data[offset : m.start()])\n            if m.group(1):\n                result.extend(cls.escaped_chars[m.group(1)[1]])\n            elif m.group(2):\n                result.append(int(m.group(2)[1:], 8))\n            elif m.group(3):\n                pass\n            elif m.group(5):\n                result.extend(b\"\\n\")\n            elif m.group(6):\n                result.extend(b\"(\")\n                nesting_depth += 1\n            elif m.group(7):\n                if nesting_depth == 0:\n                    return bytes(result), m.end()\n                result.extend(b\")\")\n                nesting_depth -= 1\n            offset = m.end()\n        msg = \"unfinished literal string\"\n        raise PdfFormatError(msg)\n\n    re_xref_section_start = re.compile(whitespace_optional + rb\"xref\" + newline)\n    re_xref_subsection_start = re.compile(\n        whitespace_optional\n        + rb\"([0-9]+)\"\n        + whitespace_mandatory\n        + rb\"([0-9]+)\"\n        + whitespace_optional\n        + newline_only\n    )\n    re_xref_entry = re.compile(rb\"([0-9]{10}) ([0-9]{5}) ([fn])( \\r| \\n|\\r\\n)\")\n\n    def read_xref_table(self, xref_section_offset):\n        subsection_found = False\n        m = self.re_xref_section_start.match(\n            self.buf, xref_section_offset + self.start_offset\n        )\n        check_format_condition(m, \"xref section start not found\")\n        offset = m.end()\n        while True:\n            m = self.re_xref_subsection_start.match(self.buf, offset)\n            if not m:\n                check_format_condition(\n                    subsection_found, \"xref subsection start not found\"\n                )\n                break\n            subsection_found = True\n            offset = m.end()\n            first_object = int(m.group(1))\n            num_objects = int(m.group(2))\n            for i in range(first_object, first_object + num_objects):\n                m = self.re_xref_entry.match(self.buf, offset)\n                check_format_condition(m, \"xref entry not found\")\n                offset = m.end()\n                is_free = m.group(3) == b\"f\"\n                if not is_free:\n                    generation = int(m.group(2))\n                    new_entry = (int(m.group(1)), generation)\n                    if i not in self.xref_table:\n                        self.xref_table[i] = new_entry\n        return offset\n\n    def read_indirect(self, ref, max_nesting=-1):\n        offset, generation = self.xref_table[ref[0]]\n        check_format_condition(\n            generation == ref[1],\n            f\"expected to find generation {ref[1]} for object ID {ref[0]} in xref \"\n            f\"table, instead found generation {generation} at offset {offset}\",\n        )\n        value = self.get_value(\n            self.buf,\n            offset + self.start_offset,\n            expect_indirect=IndirectReference(*ref),\n            max_nesting=max_nesting,\n        )[0]\n        self.cached_objects[ref] = value\n        return value\n\n    def linearize_page_tree(self, node=None):\n        if node is None:\n            node = self.page_tree_root\n        check_format_condition(\n            node[b\"Type\"] == b\"Pages\", \"/Type of page tree node is not /Pages\"\n        )\n        pages = []\n        for kid in node[b\"Kids\"]:\n            kid_object = self.read_indirect(kid)\n            if kid_object[b\"Type\"] == b\"Page\":\n                pages.append(kid)\n            else:\n                pages.extend(self.linearize_page_tree(node=kid_object))\n        return pages\n", "src/PIL/PcdImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PCD file handling\n#\n# History:\n#       96-05-10 fl     Created\n#       96-05-27 fl     Added draft mode (128x192, 256x384)\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\n\n##\n# Image plugin for PhotoCD images.  This plugin only reads the 768x512\n# image from the file; higher resolutions are encoded in a proprietary\n# encoding.\n\n\nclass PcdImageFile(ImageFile.ImageFile):\n    format = \"PCD\"\n    format_description = \"Kodak PhotoCD\"\n\n    def _open(self) -> None:\n        # rough\n        assert self.fp is not None\n\n        self.fp.seek(2048)\n        s = self.fp.read(2048)\n\n        if s[:4] != b\"PCD_\":\n            msg = \"not a PCD file\"\n            raise SyntaxError(msg)\n\n        orientation = s[1538] & 3\n        self.tile_post_rotate = None\n        if orientation == 1:\n            self.tile_post_rotate = 90\n        elif orientation == 3:\n            self.tile_post_rotate = -90\n\n        self._mode = \"RGB\"\n        self._size = 768, 512  # FIXME: not correct for rotated images!\n        self.tile = [(\"pcd\", (0, 0) + self.size, 96 * 2048, None)]\n\n    def load_end(self) -> None:\n        if self.tile_post_rotate:\n            # Handle rotated PCDs\n            assert self.im is not None\n\n            self.im = self.im.rotate(self.tile_post_rotate)\n            self._size = self.im.size\n\n\n#\n# registry\n\nImage.register_open(PcdImageFile.format, PcdImageFile)\n\nImage.register_extension(PcdImageFile.format, \".pcd\")\n", "src/PIL/EpsImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# EPS file handling\n#\n# History:\n# 1995-09-01 fl   Created (0.1)\n# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)\n# 1996-08-22 fl   Don't choke on floating point BoundingBox values\n# 1996-08-23 fl   Handle files from Macintosh (0.3)\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)\n# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)\n# 2014-05-07 e    Handling of EPS with binary preview and fixed resolution\n#                 resizing\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport re\nimport subprocess\nimport sys\nimport tempfile\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i32le as i32\nfrom ._deprecate import deprecate\n\n# --------------------------------------------------------------------\n\n\nsplit = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")\nfield = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\n\ngs_binary: str | bool | None = None\ngs_windows_binary = None\n\n\ndef has_ghostscript() -> bool:\n    global gs_binary, gs_windows_binary\n    if gs_binary is None:\n        if sys.platform.startswith(\"win\"):\n            if gs_windows_binary is None:\n                import shutil\n\n                for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):\n                    if shutil.which(binary) is not None:\n                        gs_windows_binary = binary\n                        break\n                else:\n                    gs_windows_binary = False\n            gs_binary = gs_windows_binary\n        else:\n            try:\n                subprocess.check_call([\"gs\", \"--version\"], stdout=subprocess.DEVNULL)\n                gs_binary = \"gs\"\n            except OSError:\n                gs_binary = False\n    return gs_binary is not False\n\n\ndef Ghostscript(tile, size, fp, scale=1, transparency=False):\n    \"\"\"Render an image using Ghostscript\"\"\"\n    global gs_binary\n    if not has_ghostscript():\n        msg = \"Unable to locate Ghostscript on paths\"\n        raise OSError(msg)\n\n    # Unpack decoder tile\n    decoder, tile, offset, data = tile[0]\n    length, bbox = data\n\n    # Hack to support hi-res rendering\n    scale = int(scale) or 1\n    width = size[0] * scale\n    height = size[1] * scale\n    # resolution is dependent on bbox and size\n    res_x = 72.0 * width / (bbox[2] - bbox[0])\n    res_y = 72.0 * height / (bbox[3] - bbox[1])\n\n    out_fd, outfile = tempfile.mkstemp()\n    os.close(out_fd)\n\n    infile_temp = None\n    if hasattr(fp, \"name\") and os.path.exists(fp.name):\n        infile = fp.name\n    else:\n        in_fd, infile_temp = tempfile.mkstemp()\n        os.close(in_fd)\n        infile = infile_temp\n\n        # Ignore length and offset!\n        # Ghostscript can read it\n        # Copy whole file to read in Ghostscript\n        with open(infile_temp, \"wb\") as f:\n            # fetch length of fp\n            fp.seek(0, io.SEEK_END)\n            fsize = fp.tell()\n            # ensure start position\n            # go back\n            fp.seek(0)\n            lengthfile = fsize\n            while lengthfile > 0:\n                s = fp.read(min(lengthfile, 100 * 1024))\n                if not s:\n                    break\n                lengthfile -= len(s)\n                f.write(s)\n\n    device = \"pngalpha\" if transparency else \"ppmraw\"\n\n    # Build Ghostscript command\n    command = [\n        gs_binary,\n        \"-q\",  # quiet mode\n        f\"-g{width:d}x{height:d}\",  # set output geometry (pixels)\n        f\"-r{res_x:f}x{res_y:f}\",  # set input DPI (dots per inch)\n        \"-dBATCH\",  # exit after processing\n        \"-dNOPAUSE\",  # don't pause between pages\n        \"-dSAFER\",  # safe mode\n        f\"-sDEVICE={device}\",\n        f\"-sOutputFile={outfile}\",  # output file\n        # adjust for image origin\n        \"-c\",\n        f\"{-bbox[0]} {-bbox[1]} translate\",\n        \"-f\",\n        infile,  # input file\n        # showpage (see https://bugs.ghostscript.com/show_bug.cgi?id=698272)\n        \"-c\",\n        \"showpage\",\n    ]\n\n    # push data through Ghostscript\n    try:\n        startupinfo = None\n        if sys.platform.startswith(\"win\"):\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        subprocess.check_call(command, startupinfo=startupinfo)\n        out_im = Image.open(outfile)\n        out_im.load()\n    finally:\n        try:\n            os.unlink(outfile)\n            if infile_temp:\n                os.unlink(infile_temp)\n        except OSError:\n            pass\n\n    im = out_im.im.copy()\n    out_im.close()\n    return im\n\n\nclass PSFile:\n    \"\"\"\n    Wrapper for bytesio object that treats either CR or LF as end of line.\n    This class is no longer used internally, but kept for backwards compatibility.\n    \"\"\"\n\n    def __init__(self, fp):\n        deprecate(\n            \"PSFile\",\n            11,\n            action=\"If you need the functionality of this class \"\n            \"you will need to implement it yourself.\",\n        )\n        self.fp = fp\n        self.char = None\n\n    def seek(self, offset, whence=io.SEEK_SET):\n        self.char = None\n        self.fp.seek(offset, whence)\n\n    def readline(self) -> str:\n        s = [self.char or b\"\"]\n        self.char = None\n\n        c = self.fp.read(1)\n        while (c not in b\"\\r\\n\") and len(c):\n            s.append(c)\n            c = self.fp.read(1)\n\n        self.char = self.fp.read(1)\n        # line endings can be 1 or 2 of \\r \\n, in either order\n        if self.char in b\"\\r\\n\":\n            self.char = None\n\n        return b\"\".join(s).decode(\"latin-1\")\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"%!PS\" or (len(prefix) >= 4 and i32(prefix) == 0xC6D3D0C5)\n\n\n##\n# Image plugin for Encapsulated PostScript. This plugin supports only\n# a few variants of this format.\n\n\nclass EpsImageFile(ImageFile.ImageFile):\n    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"\n\n    format = \"EPS\"\n    format_description = \"Encapsulated Postscript\"\n\n    mode_map = {1: \"L\", 2: \"LAB\", 3: \"RGB\", 4: \"CMYK\"}\n\n    def _open(self) -> None:\n        (length, offset) = self._find_offset(self.fp)\n\n        # go to offset - start of \"%!PS\"\n        self.fp.seek(offset)\n\n        self._mode = \"RGB\"\n        self._size = None\n\n        byte_arr = bytearray(255)\n        bytes_mv = memoryview(byte_arr)\n        bytes_read = 0\n        reading_header_comments = True\n        reading_trailer_comments = False\n        trailer_reached = False\n\n        def check_required_header_comments() -> None:\n            if \"PS-Adobe\" not in self.info:\n                msg = 'EPS header missing \"%!PS-Adobe\" comment'\n                raise SyntaxError(msg)\n            if \"BoundingBox\" not in self.info:\n                msg = 'EPS header missing \"%%BoundingBox\" comment'\n                raise SyntaxError(msg)\n\n        def _read_comment(s: str) -> bool:\n            nonlocal reading_trailer_comments\n            try:\n                m = split.match(s)\n            except re.error as e:\n                msg = \"not an EPS file\"\n                raise SyntaxError(msg) from e\n\n            if not m:\n                return False\n\n            k, v = m.group(1, 2)\n            self.info[k] = v\n            if k == \"BoundingBox\":\n                if v == \"(atend)\":\n                    reading_trailer_comments = True\n                elif not self._size or (trailer_reached and reading_trailer_comments):\n                    try:\n                        # Note: The DSC spec says that BoundingBox\n                        # fields should be integers, but some drivers\n                        # put floating point values there anyway.\n                        box = [int(float(i)) for i in v.split()]\n                        self._size = box[2] - box[0], box[3] - box[1]\n                        self.tile = [(\"eps\", (0, 0) + self.size, offset, (length, box))]\n                    except Exception:\n                        pass\n            return True\n\n        while True:\n            byte = self.fp.read(1)\n            if byte == b\"\":\n                # if we didn't read a byte we must be at the end of the file\n                if bytes_read == 0:\n                    break\n            elif byte in b\"\\r\\n\":\n                # if we read a line ending character, ignore it and parse what\n                # we have already read. if we haven't read any other characters,\n                # continue reading\n                if bytes_read == 0:\n                    continue\n            else:\n                # ASCII/hexadecimal lines in an EPS file must not exceed\n                # 255 characters, not including line ending characters\n                if bytes_read >= 255:\n                    # only enforce this for lines starting with a \"%\",\n                    # otherwise assume it's binary data\n                    if byte_arr[0] == ord(\"%\"):\n                        msg = \"not an EPS file\"\n                        raise SyntaxError(msg)\n                    else:\n                        if reading_header_comments:\n                            check_required_header_comments()\n                            reading_header_comments = False\n                        # reset bytes_read so we can keep reading\n                        # data until the end of the line\n                        bytes_read = 0\n                byte_arr[bytes_read] = byte[0]\n                bytes_read += 1\n                continue\n\n            if reading_header_comments:\n                # Load EPS header\n\n                # if this line doesn't start with a \"%\",\n                # or does start with \"%%EndComments\",\n                # then we've reached the end of the header/comments\n                if byte_arr[0] != ord(\"%\") or bytes_mv[:13] == b\"%%EndComments\":\n                    check_required_header_comments()\n                    reading_header_comments = False\n                    continue\n\n                s = str(bytes_mv[:bytes_read], \"latin-1\")\n                if not _read_comment(s):\n                    m = field.match(s)\n                    if m:\n                        k = m.group(1)\n                        if k[:8] == \"PS-Adobe\":\n                            self.info[\"PS-Adobe\"] = k[9:]\n                        else:\n                            self.info[k] = \"\"\n                    elif s[0] == \"%\":\n                        # handle non-DSC PostScript comments that some\n                        # tools mistakenly put in the Comments section\n                        pass\n                    else:\n                        msg = \"bad EPS header\"\n                        raise OSError(msg)\n            elif bytes_mv[:11] == b\"%ImageData:\":\n                # Check for an \"ImageData\" descriptor\n                # https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577413_pgfId-1035096\n\n                # Values:\n                # columns\n                # rows\n                # bit depth (1 or 8)\n                # mode (1: L, 2: LAB, 3: RGB, 4: CMYK)\n                # number of padding channels\n                # block size (number of bytes per row per channel)\n                # binary/ascii (1: binary, 2: ascii)\n                # data start identifier (the image data follows after a single line\n                #   consisting only of this quoted value)\n                image_data_values = byte_arr[11:bytes_read].split(None, 7)\n                columns, rows, bit_depth, mode_id = (\n                    int(value) for value in image_data_values[:4]\n                )\n\n                if bit_depth == 1:\n                    self._mode = \"1\"\n                elif bit_depth == 8:\n                    try:\n                        self._mode = self.mode_map[mode_id]\n                    except ValueError:\n                        break\n                else:\n                    break\n\n                self._size = columns, rows\n                return\n            elif bytes_mv[:5] == b\"%%EOF\":\n                break\n            elif trailer_reached and reading_trailer_comments:\n                # Load EPS trailer\n                s = str(bytes_mv[:bytes_read], \"latin-1\")\n                _read_comment(s)\n            elif bytes_mv[:9] == b\"%%Trailer\":\n                trailer_reached = True\n            bytes_read = 0\n\n        check_required_header_comments()\n\n        if not self._size:\n            msg = \"cannot determine EPS bounding box\"\n            raise OSError(msg)\n\n    def _find_offset(self, fp):\n        s = fp.read(4)\n\n        if s == b\"%!PS\":\n            # for HEAD without binary preview\n            fp.seek(0, io.SEEK_END)\n            length = fp.tell()\n            offset = 0\n        elif i32(s) == 0xC6D3D0C5:\n            # FIX for: Some EPS file not handled correctly / issue #302\n            # EPS can contain binary data\n            # or start directly with latin coding\n            # more info see:\n            # https://web.archive.org/web/20160528181353/http://partners.adobe.com/public/developer/en/ps/5002.EPSF_Spec.pdf\n            s = fp.read(8)\n            offset = i32(s)\n            length = i32(s, 4)\n        else:\n            msg = \"not an EPS file\"\n            raise SyntaxError(msg)\n\n        return length, offset\n\n    def load(self, scale=1, transparency=False):\n        # Load EPS via Ghostscript\n        if self.tile:\n            self.im = Ghostscript(self.tile, self.size, self.fp, scale, transparency)\n            self._mode = self.im.mode\n            self._size = self.im.size\n            self.tile = []\n        return Image.Image.load(self)\n\n    def load_seek(self, pos: int) -> None:\n        # we can't incrementally load, so force ImageFile.parser to\n        # use our custom load method by defining this method.\n        pass\n\n\n# --------------------------------------------------------------------\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes, eps: int = 1) -> None:\n    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"\n\n    # make sure image data is available\n    im.load()\n\n    # determine PostScript image mode\n    if im.mode == \"L\":\n        operator = (8, 1, b\"image\")\n    elif im.mode == \"RGB\":\n        operator = (8, 3, b\"false 3 colorimage\")\n    elif im.mode == \"CMYK\":\n        operator = (8, 4, b\"false 4 colorimage\")\n    else:\n        msg = \"image mode is not supported\"\n        raise ValueError(msg)\n\n    if eps:\n        # write EPS header\n        fp.write(b\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n        fp.write(b\"%%Creator: PIL 0.1 EpsEncode\\n\")\n        # fp.write(\"%%CreationDate: %s\"...)\n        fp.write(b\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)\n        fp.write(b\"%%Pages: 1\\n\")\n        fp.write(b\"%%EndComments\\n\")\n        fp.write(b\"%%Page: 1 1\\n\")\n        fp.write(b\"%%ImageData: %d %d \" % im.size)\n        fp.write(b'%d %d 0 1 1 \"%s\"\\n' % operator)\n\n    # image header\n    fp.write(b\"gsave\\n\")\n    fp.write(b\"10 dict begin\\n\")\n    fp.write(b\"/buf %d string def\\n\" % (im.size[0] * operator[1]))\n    fp.write(b\"%d %d scale\\n\" % im.size)\n    fp.write(b\"%d %d 8\\n\" % im.size)  # <= bits\n    fp.write(b\"[%d 0 0 -%d 0 %d]\\n\" % (im.size[0], im.size[1], im.size[1]))\n    fp.write(b\"{ currentfile buf readhexstring pop } bind\\n\")\n    fp.write(operator[2] + b\"\\n\")\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n    ImageFile._save(im, fp, [(\"eps\", (0, 0) + im.size, 0, None)])\n\n    fp.write(b\"\\n%%%%EndBinary\\n\")\n    fp.write(b\"grestore end\\n\")\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\n# --------------------------------------------------------------------\n\n\nImage.register_open(EpsImageFile.format, EpsImageFile, _accept)\n\nImage.register_save(EpsImageFile.format, _save)\n\nImage.register_extensions(EpsImageFile.format, [\".ps\", \".eps\"])\n\nImage.register_mime(EpsImageFile.format, \"application/postscript\")\n", "src/PIL/ImageCms.py": "# The Python Imaging Library.\n# $Id$\n\n# Optional color management support, based on Kevin Cazabon's PyCMS\n# library.\n\n# Originally released under LGPL.  Graciously donated to PIL in\n# March 2009, for distribution under the standard PIL license\n\n# History:\n\n# 2009-03-08 fl   Added to PIL.\n\n# Copyright (C) 2002-2003 Kevin Cazabon\n# Copyright (c) 2009 by Fredrik Lundh\n# Copyright (c) 2013 by Eric Soroos\n\n# See the README file for information on usage and redistribution.  See\n# below for the original description.\nfrom __future__ import annotations\n\nimport operator\nimport sys\nfrom enum import IntEnum, IntFlag\nfrom functools import reduce\nfrom typing import Any, Literal, SupportsFloat, SupportsInt, Union\n\nfrom . import Image, __version__\nfrom ._deprecate import deprecate\nfrom ._typing import SupportsRead\n\ntry:\n    from . import _imagingcms as core\nexcept ImportError as ex:\n    # Allow error import for doc purposes, but error out when accessing\n    # anything in core.\n    from ._util import DeferredError\n\n    core = DeferredError.new(ex)\n\n_DESCRIPTION = \"\"\"\npyCMS\n\n    a Python / PIL interface to the littleCMS ICC Color Management System\n    Copyright (C) 2002-2003 Kevin Cazabon\n    kevin@cazabon.com\n    https://www.cazabon.com\n\n    pyCMS home page:  https://www.cazabon.com/pyCMS\n    littleCMS home page:  https://www.littlecms.com\n    (littleCMS is Copyright (C) 1998-2001 Marti Maria)\n\n    Originally released under LGPL.  Graciously donated to PIL in\n    March 2009, for distribution under the standard PIL license\n\n    The pyCMS.py module provides a \"clean\" interface between Python/PIL and\n    pyCMSdll, taking care of some of the more complex handling of the direct\n    pyCMSdll functions, as well as error-checking and making sure that all\n    relevant data is kept together.\n\n    While it is possible to call pyCMSdll functions directly, it's not highly\n    recommended.\n\n    Version History:\n\n        1.0.0 pil       Oct 2013 Port to LCMS 2.\n\n        0.1.0 pil mod   March 10, 2009\n\n                        Renamed display profile to proof profile. The proof\n                        profile is the profile of the device that is being\n                        simulated, not the profile of the device which is\n                        actually used to display/print the final simulation\n                        (that'd be the output profile) - also see LCMSAPI.txt\n                        input colorspace -> using 'renderingIntent' -> proof\n                        colorspace -> using 'proofRenderingIntent' -> output\n                        colorspace\n\n                        Added LCMS FLAGS support.\n                        Added FLAGS[\"SOFTPROOFING\"] as default flag for\n                        buildProofTransform (otherwise the proof profile/intent\n                        would be ignored).\n\n        0.1.0 pil       March 2009 - added to PIL, as PIL.ImageCms\n\n        0.0.2 alpha     Jan 6, 2002\n\n                        Added try/except statements around type() checks of\n                        potential CObjects... Python won't let you use type()\n                        on them, and raises a TypeError (stupid, if you ask\n                        me!)\n\n                        Added buildProofTransformFromOpenProfiles() function.\n                        Additional fixes in DLL, see DLL code for details.\n\n        0.0.1 alpha     first public release, Dec. 26, 2002\n\n    Known to-do list with current version (of Python interface, not pyCMSdll):\n\n        none\n\n\"\"\"\n\n_VERSION = \"1.0.0 pil\"\n\n\ndef __getattr__(name: str) -> Any:\n    if name == \"DESCRIPTION\":\n        deprecate(\"PIL.ImageCms.DESCRIPTION\", 12)\n        return _DESCRIPTION\n    elif name == \"VERSION\":\n        deprecate(\"PIL.ImageCms.VERSION\", 12)\n        return _VERSION\n    elif name == \"FLAGS\":\n        deprecate(\"PIL.ImageCms.FLAGS\", 12, \"PIL.ImageCms.Flags\")\n        return _FLAGS\n    msg = f\"module '{__name__}' has no attribute '{name}'\"\n    raise AttributeError(msg)\n\n\n# --------------------------------------------------------------------.\n\n\n#\n# intent/direction values\n\n\nclass Intent(IntEnum):\n    PERCEPTUAL = 0\n    RELATIVE_COLORIMETRIC = 1\n    SATURATION = 2\n    ABSOLUTE_COLORIMETRIC = 3\n\n\nclass Direction(IntEnum):\n    INPUT = 0\n    OUTPUT = 1\n    PROOF = 2\n\n\n#\n# flags\n\n\nclass Flags(IntFlag):\n    \"\"\"Flags and documentation are taken from ``lcms2.h``.\"\"\"\n\n    NONE = 0\n    NOCACHE = 0x0040\n    \"\"\"Inhibit 1-pixel cache\"\"\"\n    NOOPTIMIZE = 0x0100\n    \"\"\"Inhibit optimizations\"\"\"\n    NULLTRANSFORM = 0x0200\n    \"\"\"Don't transform anyway\"\"\"\n    GAMUTCHECK = 0x1000\n    \"\"\"Out of Gamut alarm\"\"\"\n    SOFTPROOFING = 0x4000\n    \"\"\"Do softproofing\"\"\"\n    BLACKPOINTCOMPENSATION = 0x2000\n    NOWHITEONWHITEFIXUP = 0x0004\n    \"\"\"Don't fix scum dot\"\"\"\n    HIGHRESPRECALC = 0x0400\n    \"\"\"Use more memory to give better accuracy\"\"\"\n    LOWRESPRECALC = 0x0800\n    \"\"\"Use less memory to minimize resources\"\"\"\n    # this should be 8BITS_DEVICELINK, but that is not a valid name in Python:\n    USE_8BITS_DEVICELINK = 0x0008\n    \"\"\"Create 8 bits devicelinks\"\"\"\n    GUESSDEVICECLASS = 0x0020\n    \"\"\"Guess device class (for ``transform2devicelink``)\"\"\"\n    KEEP_SEQUENCE = 0x0080\n    \"\"\"Keep profile sequence for devicelink creation\"\"\"\n    FORCE_CLUT = 0x0002\n    \"\"\"Force CLUT optimization\"\"\"\n    CLUT_POST_LINEARIZATION = 0x0001\n    \"\"\"create postlinearization tables if possible\"\"\"\n    CLUT_PRE_LINEARIZATION = 0x0010\n    \"\"\"create prelinearization tables if possible\"\"\"\n    NONEGATIVES = 0x8000\n    \"\"\"Prevent negative numbers in floating point transforms\"\"\"\n    COPY_ALPHA = 0x04000000\n    \"\"\"Alpha channels are copied on ``cmsDoTransform()``\"\"\"\n    NODEFAULTRESOURCEDEF = 0x01000000\n\n    _GRIDPOINTS_1 = 1 << 16\n    _GRIDPOINTS_2 = 2 << 16\n    _GRIDPOINTS_4 = 4 << 16\n    _GRIDPOINTS_8 = 8 << 16\n    _GRIDPOINTS_16 = 16 << 16\n    _GRIDPOINTS_32 = 32 << 16\n    _GRIDPOINTS_64 = 64 << 16\n    _GRIDPOINTS_128 = 128 << 16\n\n    @staticmethod\n    def GRIDPOINTS(n: int) -> Flags:\n        \"\"\"\n        Fine-tune control over number of gridpoints\n\n        :param n: :py:class:`int` in range ``0 <= n <= 255``\n        \"\"\"\n        return Flags.NONE | ((n & 0xFF) << 16)\n\n\n_MAX_FLAG = reduce(operator.or_, Flags)\n\n\n_FLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),\n    \"NOWHITEONWHITEFIXUP\": 4,  # Don't hot fix scum dot\n    # Don't create prelinearization tables on precalculated transforms\n    # (internal use):\n    \"NOPRELINEARIZATION\": 16,\n    \"GUESSDEVICECLASS\": 32,  # Guess device class (for transform2devicelink)\n    \"NOTCACHE\": 64,  # Inhibit 1-pixel cache\n    \"NOTPRECALC\": 256,\n    \"NULLTRANSFORM\": 512,  # Don't transform anyway\n    \"HIGHRESPRECALC\": 1024,  # Use more memory to give better accuracy\n    \"LOWRESPRECALC\": 2048,  # Use less memory to minimize resources\n    \"WHITEBLACKCOMPENSATION\": 8192,\n    \"BLACKPOINTCOMPENSATION\": 8192,\n    \"GAMUTCHECK\": 4096,  # Out of Gamut alarm\n    \"SOFTPROOFING\": 16384,  # Do softproofing\n    \"PRESERVEBLACK\": 32768,  # Black preservation\n    \"NODEFAULTRESOURCEDEF\": 16777216,  # CRD special\n    \"GRIDPOINTS\": lambda n: (n & 0xFF) << 16,  # Gridpoints\n}\n\n\n# --------------------------------------------------------------------.\n# Experimental PIL-level API\n# --------------------------------------------------------------------.\n\n##\n# Profile.\n\n\nclass ImageCmsProfile:\n    def __init__(self, profile: str | SupportsRead[bytes] | core.CmsProfile) -> None:\n        \"\"\"\n        :param profile: Either a string representing a filename,\n            a file like object containing a profile or a\n            low-level profile object\n\n        \"\"\"\n\n        if isinstance(profile, str):\n            if sys.platform == \"win32\":\n                profile_bytes_path = profile.encode()\n                try:\n                    profile_bytes_path.decode(\"ascii\")\n                except UnicodeDecodeError:\n                    with open(profile, \"rb\") as f:\n                        self._set(core.profile_frombytes(f.read()))\n                    return\n            self._set(core.profile_open(profile), profile)\n        elif hasattr(profile, \"read\"):\n            self._set(core.profile_frombytes(profile.read()))\n        elif isinstance(profile, core.CmsProfile):\n            self._set(profile)\n        else:\n            msg = \"Invalid type for Profile\"  # type: ignore[unreachable]\n            raise TypeError(msg)\n\n    def _set(self, profile: core.CmsProfile, filename: str | None = None) -> None:\n        self.profile = profile\n        self.filename = filename\n        self.product_name = None  # profile.product_name\n        self.product_info = None  # profile.product_info\n\n    def tobytes(self) -> bytes:\n        \"\"\"\n        Returns the profile in a format suitable for embedding in\n        saved images.\n\n        :returns: a bytes object containing the ICC profile.\n        \"\"\"\n\n        return core.profile_tobytes(self.profile)\n\n\nclass ImageCmsTransform(Image.ImagePointHandler):\n    \"\"\"\n    Transform.  This can be used with the procedural API, or with the standard\n    :py:func:`~PIL.Image.Image.point` method.\n\n    Will return the output profile in the ``output.info['icc_profile']``.\n    \"\"\"\n\n    def __init__(\n        self,\n        input: ImageCmsProfile,\n        output: ImageCmsProfile,\n        input_mode: str,\n        output_mode: str,\n        intent: Intent = Intent.PERCEPTUAL,\n        proof: ImageCmsProfile | None = None,\n        proof_intent: Intent = Intent.ABSOLUTE_COLORIMETRIC,\n        flags: Flags = Flags.NONE,\n    ):\n        if proof is None:\n            self.transform = core.buildTransform(\n                input.profile, output.profile, input_mode, output_mode, intent, flags\n            )\n        else:\n            self.transform = core.buildProofTransform(\n                input.profile,\n                output.profile,\n                proof.profile,\n                input_mode,\n                output_mode,\n                intent,\n                proof_intent,\n                flags,\n            )\n        # Note: inputMode and outputMode are for pyCMS compatibility only\n        self.input_mode = self.inputMode = input_mode\n        self.output_mode = self.outputMode = output_mode\n\n        self.output_profile = output\n\n    def point(self, im: Image.Image) -> Image.Image:\n        return self.apply(im)\n\n    def apply(self, im: Image.Image, imOut: Image.Image | None = None) -> Image.Image:\n        im.load()\n        if imOut is None:\n            imOut = Image.new(self.output_mode, im.size, None)\n        self.transform.apply(im.im.id, imOut.im.id)\n        imOut.info[\"icc_profile\"] = self.output_profile.tobytes()\n        return imOut\n\n    def apply_in_place(self, im: Image.Image) -> Image.Image:\n        im.load()\n        if im.mode != self.output_mode:\n            msg = \"mode mismatch\"\n            raise ValueError(msg)  # wrong output mode\n        self.transform.apply(im.im.id, im.im.id)\n        im.info[\"icc_profile\"] = self.output_profile.tobytes()\n        return im\n\n\ndef get_display_profile(handle: SupportsInt | None = None) -> ImageCmsProfile | None:\n    \"\"\"\n    (experimental) Fetches the profile for the current display device.\n\n    :returns: ``None`` if the profile is not known.\n    \"\"\"\n\n    if sys.platform != \"win32\":\n        return None\n\n    from . import ImageWin  # type: ignore[unused-ignore, unreachable]\n\n    if isinstance(handle, ImageWin.HDC):\n        profile = core.get_display_profile_win32(int(handle), 1)\n    else:\n        profile = core.get_display_profile_win32(int(handle or 0))\n    if profile is None:\n        return None\n    return ImageCmsProfile(profile)\n\n\n# --------------------------------------------------------------------.\n# pyCMS compatible layer\n# --------------------------------------------------------------------.\n\n_CmsProfileCompatible = Union[\n    str, SupportsRead[bytes], core.CmsProfile, ImageCmsProfile\n]\n\n\nclass PyCMSError(Exception):\n    \"\"\"(pyCMS) Exception class.\n    This is used for all errors in the pyCMS API.\"\"\"\n\n    pass\n\n\ndef profileToProfile(\n    im: Image.Image,\n    inputProfile: _CmsProfileCompatible,\n    outputProfile: _CmsProfileCompatible,\n    renderingIntent: Intent = Intent.PERCEPTUAL,\n    outputMode: str | None = None,\n    inPlace: bool = False,\n    flags: Flags = Flags.NONE,\n) -> Image.Image | None:\n    \"\"\"\n    (pyCMS) Applies an ICC transformation to a given image, mapping from\n    ``inputProfile`` to ``outputProfile``.\n\n    If the input or output profiles specified are not valid filenames, a\n    :exc:`PyCMSError` will be raised.  If ``inPlace`` is ``True`` and\n    ``outputMode != im.mode``, a :exc:`PyCMSError` will be raised.\n    If an error occurs during application of the profiles,\n    a :exc:`PyCMSError` will be raised.\n    If ``outputMode`` is not a mode supported by the ``outputProfile`` (or by pyCMS),\n    a :exc:`PyCMSError` will be raised.\n\n    This function applies an ICC transformation to im from ``inputProfile``'s\n    color space to ``outputProfile``'s color space using the specified rendering\n    intent to decide how to handle out-of-gamut colors.\n\n    ``outputMode`` can be used to specify that a color mode conversion is to\n    be done using these profiles, but the specified profiles must be able\n    to handle that mode.  I.e., if converting im from RGB to CMYK using\n    profiles, the input profile must handle RGB data, and the output\n    profile must handle CMYK data.\n\n    :param im: An open :py:class:`~PIL.Image.Image` object (i.e. Image.new(...)\n        or Image.open(...), etc.)\n    :param inputProfile: String, as a valid filename path to the ICC input\n        profile you wish to use for this image, or a profile object\n    :param outputProfile: String, as a valid filename path to the ICC output\n        profile you wish to use for this image, or a profile object\n    :param renderingIntent: Integer (0-3) specifying the rendering intent you\n        wish to use for the transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param outputMode: A valid PIL mode for the output image (i.e. \"RGB\",\n        \"CMYK\", etc.).  Note: if rendering the image \"inPlace\", outputMode\n        MUST be the same mode as the input, or omitted completely.  If\n        omitted, the outputMode will be the same as the mode of the input\n        image (im.mode)\n    :param inPlace: Boolean.  If ``True``, the original image is modified in-place,\n        and ``None`` is returned.  If ``False`` (default), a new\n        :py:class:`~PIL.Image.Image` object is returned with the transform applied.\n    :param flags: Integer (0-...) specifying additional flags\n    :returns: Either None or a new :py:class:`~PIL.Image.Image` object, depending on\n        the value of ``inPlace``\n    :exception PyCMSError:\n    \"\"\"\n\n    if outputMode is None:\n        outputMode = im.mode\n\n    if not isinstance(renderingIntent, int) or not (0 <= renderingIntent <= 3):\n        msg = \"renderingIntent must be an integer between 0 and 3\"\n        raise PyCMSError(msg)\n\n    if not isinstance(flags, int) or not (0 <= flags <= _MAX_FLAG):\n        msg = f\"flags must be an integer between 0 and {_MAX_FLAG}\"\n        raise PyCMSError(msg)\n\n    try:\n        if not isinstance(inputProfile, ImageCmsProfile):\n            inputProfile = ImageCmsProfile(inputProfile)\n        if not isinstance(outputProfile, ImageCmsProfile):\n            outputProfile = ImageCmsProfile(outputProfile)\n        transform = ImageCmsTransform(\n            inputProfile,\n            outputProfile,\n            im.mode,\n            outputMode,\n            renderingIntent,\n            flags=flags,\n        )\n        if inPlace:\n            transform.apply_in_place(im)\n            imOut = None\n        else:\n            imOut = transform.apply(im)\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n    return imOut\n\n\ndef getOpenProfile(\n    profileFilename: str | SupportsRead[bytes] | core.CmsProfile,\n) -> ImageCmsProfile:\n    \"\"\"\n    (pyCMS) Opens an ICC profile file.\n\n    The PyCMSProfile object can be passed back into pyCMS for use in creating\n    transforms and such (as in ImageCms.buildTransformFromOpenProfiles()).\n\n    If ``profileFilename`` is not a valid filename for an ICC profile,\n    a :exc:`PyCMSError` will be raised.\n\n    :param profileFilename: String, as a valid filename path to the ICC profile\n        you wish to open, or a file-like object.\n    :returns: A CmsProfile class object.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        return ImageCmsProfile(profileFilename)\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef buildTransform(\n    inputProfile: _CmsProfileCompatible,\n    outputProfile: _CmsProfileCompatible,\n    inMode: str,\n    outMode: str,\n    renderingIntent: Intent = Intent.PERCEPTUAL,\n    flags: Flags = Flags.NONE,\n) -> ImageCmsTransform:\n    \"\"\"\n    (pyCMS) Builds an ICC transform mapping from the ``inputProfile`` to the\n    ``outputProfile``. Use applyTransform to apply the transform to a given\n    image.\n\n    If the input or output profiles specified are not valid filenames, a\n    :exc:`PyCMSError` will be raised. If an error occurs during creation\n    of the transform, a :exc:`PyCMSError` will be raised.\n\n    If ``inMode`` or ``outMode`` are not a mode supported by the ``outputProfile``\n    (or by pyCMS), a :exc:`PyCMSError` will be raised.\n\n    This function builds and returns an ICC transform from the ``inputProfile``\n    to the ``outputProfile`` using the ``renderingIntent`` to determine what to do\n    with out-of-gamut colors.  It will ONLY work for converting images that\n    are in ``inMode`` to images that are in ``outMode`` color format (PIL mode,\n    i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.).\n\n    Building the transform is a fair part of the overhead in\n    ImageCms.profileToProfile(), so if you're planning on converting multiple\n    images using the same input/output settings, this can save you time.\n    Once you have a transform object, it can be used with\n    ImageCms.applyProfile() to convert images without the need to re-compute\n    the lookup table for the transform.\n\n    The reason pyCMS returns a class object rather than a handle directly\n    to the transform is that it needs to keep track of the PIL input/output\n    modes that the transform is meant for.  These attributes are stored in\n    the ``inMode`` and ``outMode`` attributes of the object (which can be\n    manually overridden if you really want to, but I don't know of any\n    time that would be of use, or would even work).\n\n    :param inputProfile: String, as a valid filename path to the ICC input\n        profile you wish to use for this transform, or a profile object\n    :param outputProfile: String, as a valid filename path to the ICC output\n        profile you wish to use for this transform, or a profile object\n    :param inMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param outMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param renderingIntent: Integer (0-3) specifying the rendering intent you\n        wish to use for the transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param flags: Integer (0-...) specifying additional flags\n    :returns: A CmsTransform class object.\n    :exception PyCMSError:\n    \"\"\"\n\n    if not isinstance(renderingIntent, int) or not (0 <= renderingIntent <= 3):\n        msg = \"renderingIntent must be an integer between 0 and 3\"\n        raise PyCMSError(msg)\n\n    if not isinstance(flags, int) or not (0 <= flags <= _MAX_FLAG):\n        msg = f\"flags must be an integer between 0 and {_MAX_FLAG}\"\n        raise PyCMSError(msg)\n\n    try:\n        if not isinstance(inputProfile, ImageCmsProfile):\n            inputProfile = ImageCmsProfile(inputProfile)\n        if not isinstance(outputProfile, ImageCmsProfile):\n            outputProfile = ImageCmsProfile(outputProfile)\n        return ImageCmsTransform(\n            inputProfile, outputProfile, inMode, outMode, renderingIntent, flags=flags\n        )\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef buildProofTransform(\n    inputProfile: _CmsProfileCompatible,\n    outputProfile: _CmsProfileCompatible,\n    proofProfile: _CmsProfileCompatible,\n    inMode: str,\n    outMode: str,\n    renderingIntent: Intent = Intent.PERCEPTUAL,\n    proofRenderingIntent: Intent = Intent.ABSOLUTE_COLORIMETRIC,\n    flags: Flags = Flags.SOFTPROOFING,\n) -> ImageCmsTransform:\n    \"\"\"\n    (pyCMS) Builds an ICC transform mapping from the ``inputProfile`` to the\n    ``outputProfile``, but tries to simulate the result that would be\n    obtained on the ``proofProfile`` device.\n\n    If the input, output, or proof profiles specified are not valid\n    filenames, a :exc:`PyCMSError` will be raised.\n\n    If an error occurs during creation of the transform,\n    a :exc:`PyCMSError` will be raised.\n\n    If ``inMode`` or ``outMode`` are not a mode supported by the ``outputProfile``\n    (or by pyCMS), a :exc:`PyCMSError` will be raised.\n\n    This function builds and returns an ICC transform from the ``inputProfile``\n    to the ``outputProfile``, but tries to simulate the result that would be\n    obtained on the ``proofProfile`` device using ``renderingIntent`` and\n    ``proofRenderingIntent`` to determine what to do with out-of-gamut\n    colors.  This is known as \"soft-proofing\".  It will ONLY work for\n    converting images that are in ``inMode`` to images that are in outMode\n    color format (PIL mode, i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.).\n\n    Usage of the resulting transform object is exactly the same as with\n    ImageCms.buildTransform().\n\n    Proof profiling is generally used when using an output device to get a\n    good idea of what the final printed/displayed image would look like on\n    the ``proofProfile`` device when it's quicker and easier to use the\n    output device for judging color.  Generally, this means that the\n    output device is a monitor, or a dye-sub printer (etc.), and the simulated\n    device is something more expensive, complicated, or time consuming\n    (making it difficult to make a real print for color judgement purposes).\n\n    Soft-proofing basically functions by adjusting the colors on the\n    output device to match the colors of the device being simulated. However,\n    when the simulated device has a much wider gamut than the output\n    device, you may obtain marginal results.\n\n    :param inputProfile: String, as a valid filename path to the ICC input\n        profile you wish to use for this transform, or a profile object\n    :param outputProfile: String, as a valid filename path to the ICC output\n        (monitor, usually) profile you wish to use for this transform, or a\n        profile object\n    :param proofProfile: String, as a valid filename path to the ICC proof\n        profile you wish to use for this transform, or a profile object\n    :param inMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param outMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param renderingIntent: Integer (0-3) specifying the rendering intent you\n        wish to use for the input->proof (simulated) transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param proofRenderingIntent: Integer (0-3) specifying the rendering intent\n        you wish to use for proof->output transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param flags: Integer (0-...) specifying additional flags\n    :returns: A CmsTransform class object.\n    :exception PyCMSError:\n    \"\"\"\n\n    if not isinstance(renderingIntent, int) or not (0 <= renderingIntent <= 3):\n        msg = \"renderingIntent must be an integer between 0 and 3\"\n        raise PyCMSError(msg)\n\n    if not isinstance(flags, int) or not (0 <= flags <= _MAX_FLAG):\n        msg = f\"flags must be an integer between 0 and {_MAX_FLAG}\"\n        raise PyCMSError(msg)\n\n    try:\n        if not isinstance(inputProfile, ImageCmsProfile):\n            inputProfile = ImageCmsProfile(inputProfile)\n        if not isinstance(outputProfile, ImageCmsProfile):\n            outputProfile = ImageCmsProfile(outputProfile)\n        if not isinstance(proofProfile, ImageCmsProfile):\n            proofProfile = ImageCmsProfile(proofProfile)\n        return ImageCmsTransform(\n            inputProfile,\n            outputProfile,\n            inMode,\n            outMode,\n            renderingIntent,\n            proofProfile,\n            proofRenderingIntent,\n            flags,\n        )\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\nbuildTransformFromOpenProfiles = buildTransform\nbuildProofTransformFromOpenProfiles = buildProofTransform\n\n\ndef applyTransform(\n    im: Image.Image, transform: ImageCmsTransform, inPlace: bool = False\n) -> Image.Image | None:\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n\n    If ``im.mode != transform.input_mode``, a :exc:`PyCMSError` is raised.\n\n    If ``inPlace`` is ``True`` and ``transform.input_mode != transform.output_mode``, a\n    :exc:`PyCMSError` is raised.\n\n    If ``im.mode``, ``transform.input_mode`` or ``transform.output_mode`` is not\n    supported by pyCMSdll or the profiles you used for the transform, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while the transform is being applied,\n    a :exc:`PyCMSError` is raised.\n\n    This function applies a pre-calculated transform (from\n    ImageCms.buildTransform() or ImageCms.buildTransformFromOpenProfiles())\n    to an image. The transform can be used for multiple images, saving\n    considerable calculation time if doing the same conversion multiple times.\n\n    If you want to modify im in-place instead of receiving a new image as\n    the return value, set ``inPlace`` to ``True``.  This can only be done if\n    ``transform.input_mode`` and ``transform.output_mode`` are the same, because we\n    can't change the mode in-place (the buffer sizes for some modes are\n    different).  The default behavior is to return a new :py:class:`~PIL.Image.Image`\n    object of the same dimensions in mode ``transform.output_mode``.\n\n    :param im: An :py:class:`~PIL.Image.Image` object, and ``im.mode`` must be the same\n        as the ``input_mode`` supported by the transform.\n    :param transform: A valid CmsTransform class object\n    :param inPlace: Bool.  If ``True``, ``im`` is modified in place and ``None`` is\n        returned, if ``False``, a new :py:class:`~PIL.Image.Image` object with the\n        transform applied is returned (and ``im`` is not changed). The default is\n        ``False``.\n    :returns: Either ``None``, or a new :py:class:`~PIL.Image.Image` object,\n        depending on the value of ``inPlace``. The profile will be returned in\n        the image's ``info['icc_profile']``.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if inPlace:\n            transform.apply_in_place(im)\n            imOut = None\n        else:\n            imOut = transform.apply(im)\n    except (TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n    return imOut\n\n\ndef createProfile(\n    colorSpace: Literal[\"LAB\", \"XYZ\", \"sRGB\"], colorTemp: SupportsFloat = 0\n) -> core.CmsProfile:\n    \"\"\"\n    (pyCMS) Creates a profile.\n\n    If colorSpace not in ``[\"LAB\", \"XYZ\", \"sRGB\"]``,\n    a :exc:`PyCMSError` is raised.\n\n    If using LAB and ``colorTemp`` is not a positive integer,\n    a :exc:`PyCMSError` is raised.\n\n    If an error occurs while creating the profile,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to create common profiles on-the-fly instead of\n    having to supply a profile on disk and knowing the path to it.  It\n    returns a normal CmsProfile object that can be passed to\n    ImageCms.buildTransformFromOpenProfiles() to create a transform to apply\n    to images.\n\n    :param colorSpace: String, the color space of the profile you wish to\n        create.\n        Currently only \"LAB\", \"XYZ\", and \"sRGB\" are supported.\n    :param colorTemp: Positive number for the white point for the profile, in\n        degrees Kelvin (i.e. 5000, 6500, 9600, etc.).  The default is for D50\n        illuminant if omitted (5000k).  colorTemp is ONLY applied to LAB\n        profiles, and is ignored for XYZ and sRGB.\n    :returns: A CmsProfile class object\n    :exception PyCMSError:\n    \"\"\"\n\n    if colorSpace not in [\"LAB\", \"XYZ\", \"sRGB\"]:\n        msg = (\n            f\"Color space not supported for on-the-fly profile creation ({colorSpace})\"\n        )\n        raise PyCMSError(msg)\n\n    if colorSpace == \"LAB\":\n        try:\n            colorTemp = float(colorTemp)\n        except (TypeError, ValueError) as e:\n            msg = f'Color temperature must be numeric, \"{colorTemp}\" not valid'\n            raise PyCMSError(msg) from e\n\n    try:\n        return core.createProfile(colorSpace, colorTemp)\n    except (TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileName(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n\n    (pyCMS) Gets the internal product name for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile,\n    a :exc:`PyCMSError` is raised If an error occurs while trying\n    to obtain the name tag, a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the INTERNAL name of the profile (stored\n    in an ICC tag in the profile itself), usually the one used when the\n    profile was originally created.  Sometimes this tag also contains\n    additional information supplied by the creator.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal name of the profile as stored\n        in an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        # do it in python, not c.\n        #    // name was \"%s - %s\" (model, manufacturer) || Description ,\n        #    // but if the Model and Manufacturer were the same or the model\n        #    // was long, Just the model,  in 1.x\n        model = profile.profile.model\n        manufacturer = profile.profile.manufacturer\n\n        if not (model or manufacturer):\n            return (profile.profile.profile_description or \"\") + \"\\n\"\n        if not manufacturer or (model and len(model) > 30):\n            return f\"{model}\\n\"\n        return f\"{model} - {manufacturer}\\n\"\n\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileInfo(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the internal product information for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile,\n    a :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the info tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    info tag.  This often contains details about the profile, and how it\n    was created, as supplied by the creator.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        # add an extra newline to preserve pyCMS compatibility\n        # Python, not C. the white point bits weren't working well,\n        # so skipping.\n        # info was description \\r\\n\\r\\n copyright \\r\\n\\r\\n K007 tag \\r\\n\\r\\n whitepoint\n        description = profile.profile.profile_description\n        cpright = profile.profile.copyright\n        elements = [element for element in (description, cpright) if element]\n        return \"\\r\\n\\r\\n\".join(elements) + \"\\r\\n\\r\\n\"\n\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileCopyright(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the copyright for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the copyright tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    copyright tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.copyright or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileManufacturer(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the manufacturer for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the manufacturer tag, a\n    :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    manufacturer tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.manufacturer or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileModel(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the model for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the model tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    model tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.model or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileDescription(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the description for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the description tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    description tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in an\n        ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.profile_description or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getDefaultIntent(profile: _CmsProfileCompatible) -> int:\n    \"\"\"\n    (pyCMS) Gets the default intent name for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the default intent, a\n    :exc:`PyCMSError` is raised.\n\n    Use this function to determine the default (and usually best optimized)\n    rendering intent for this profile.  Most profiles support multiple\n    rendering intents, but are intended mostly for one type of conversion.\n    If you wish to use a different intent than returned, use\n    ImageCms.isIntentSupported() to verify it will work first.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: Integer 0-3 specifying the default rendering intent for this\n        profile.\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n            they do.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return profile.profile.rendering_intent\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef isIntentSupported(\n    profile: _CmsProfileCompatible, intent: Intent, direction: Direction\n) -> Literal[-1, 1]:\n    \"\"\"\n    (pyCMS) Checks if a given intent is supported.\n\n    Use this function to verify that you can use your desired\n    ``intent`` with ``profile``, and that ``profile`` can be used for the\n    input/output/proof profile as you desire.\n\n    Some profiles are created specifically for one \"direction\", can cannot\n    be used for others. Some profiles can only be used for certain\n    rendering intents, so it's best to either verify this before trying\n    to create a transform with them (using this function), or catch the\n    potential :exc:`PyCMSError` that will occur if they don't\n    support the modes you select.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :param intent: Integer (0-3) specifying the rendering intent you wish to\n        use with this profile\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n            they do.\n    :param direction: Integer specifying if the profile is to be used for\n        input, output, or proof\n\n            INPUT  = 0 (or use ImageCms.Direction.INPUT)\n            OUTPUT = 1 (or use ImageCms.Direction.OUTPUT)\n            PROOF  = 2 (or use ImageCms.Direction.PROOF)\n\n    :returns: 1 if the intent/direction are supported, -1 if they are not.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        # FIXME: I get different results for the same data w. different\n        # compilers.  Bug in LittleCMS or in the binding?\n        if profile.profile.is_intent_supported(intent, direction):\n            return 1\n        else:\n            return -1\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef versions() -> tuple[str, str | None, str, str]:\n    \"\"\"\n    (pyCMS) Fetches versions.\n    \"\"\"\n\n    deprecate(\n        \"PIL.ImageCms.versions()\",\n        12,\n        '(PIL.features.version(\"littlecms2\"), sys.version, PIL.__version__)',\n    )\n    return _VERSION, core.littlecms_version, sys.version.split()[0], __version__\n", "src/PIL/SgiImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# SGI image file handling\n#\n# See \"The SGI Image File Format (Draft version 0.97)\", Paul Haeberli.\n# <ftp://ftp.sgi.com/graphics/SGIIMAGESPEC>\n#\n#\n# History:\n# 2017-22-07 mb   Add RLE decompression\n# 2016-16-10 mb   Add save method without compression\n# 1995-09-10 fl   Created\n#\n# Copyright (c) 2016 by Mickael Bonfill.\n# Copyright (c) 2008 by Karsten Hiddemann.\n# Copyright (c) 1997 by Secret Labs AB.\n# Copyright (c) 1995 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nimport struct\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import o8\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 2 and i16(prefix) == 474\n\n\nMODES = {\n    (1, 1, 1): \"L\",\n    (1, 2, 1): \"L\",\n    (2, 1, 1): \"L;16B\",\n    (2, 2, 1): \"L;16B\",\n    (1, 3, 3): \"RGB\",\n    (2, 3, 3): \"RGB;16B\",\n    (1, 3, 4): \"RGBA\",\n    (2, 3, 4): \"RGBA;16B\",\n}\n\n\n##\n# Image plugin for SGI images.\nclass SgiImageFile(ImageFile.ImageFile):\n    format = \"SGI\"\n    format_description = \"SGI Image File Format\"\n\n    def _open(self) -> None:\n        # HEAD\n        assert self.fp is not None\n\n        headlen = 512\n        s = self.fp.read(headlen)\n\n        if not _accept(s):\n            msg = \"Not an SGI image file\"\n            raise ValueError(msg)\n\n        # compression : verbatim or RLE\n        compression = s[2]\n\n        # bpc : 1 or 2 bytes (8bits or 16bits)\n        bpc = s[3]\n\n        # dimension : 1, 2 or 3 (depending on xsize, ysize and zsize)\n        dimension = i16(s, 4)\n\n        # xsize : width\n        xsize = i16(s, 6)\n\n        # ysize : height\n        ysize = i16(s, 8)\n\n        # zsize : channels count\n        zsize = i16(s, 10)\n\n        # layout\n        layout = bpc, dimension, zsize\n\n        # determine mode from bits/zsize\n        rawmode = \"\"\n        try:\n            rawmode = MODES[layout]\n        except KeyError:\n            pass\n\n        if rawmode == \"\":\n            msg = \"Unsupported SGI image mode\"\n            raise ValueError(msg)\n\n        self._size = xsize, ysize\n        self._mode = rawmode.split(\";\")[0]\n        if self.mode == \"RGB\":\n            self.custom_mimetype = \"image/rgb\"\n\n        # orientation -1 : scanlines begins at the bottom-left corner\n        orientation = -1\n\n        # decoder info\n        if compression == 0:\n            pagesize = xsize * ysize * bpc\n            if bpc == 2:\n                self.tile = [\n                    (\"SGI16\", (0, 0) + self.size, headlen, (self.mode, 0, orientation))\n                ]\n            else:\n                self.tile = []\n                offset = headlen\n                for layer in self.mode:\n                    self.tile.append(\n                        (\"raw\", (0, 0) + self.size, offset, (layer, 0, orientation))\n                    )\n                    offset += pagesize\n        elif compression == 1:\n            self.tile = [\n                (\"sgi_rle\", (0, 0) + self.size, headlen, (rawmode, orientation, bpc))\n            ]\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode not in {\"RGB\", \"RGBA\", \"L\"}:\n        msg = \"Unsupported SGI image mode\"\n        raise ValueError(msg)\n\n    # Get the keyword arguments\n    info = im.encoderinfo\n\n    # Byte-per-pixel precision, 1 = 8bits per pixel\n    bpc = info.get(\"bpc\", 1)\n\n    if bpc not in (1, 2):\n        msg = \"Unsupported number of bytes per pixel\"\n        raise ValueError(msg)\n\n    # Flip the image, since the origin of SGI file is the bottom-left corner\n    orientation = -1\n    # Define the file as SGI File Format\n    magic_number = 474\n    # Run-Length Encoding Compression - Unsupported at this time\n    rle = 0\n\n    # Number of dimensions (x,y,z)\n    dim = 3\n    # X Dimension = width / Y Dimension = height\n    x, y = im.size\n    if im.mode == \"L\" and y == 1:\n        dim = 1\n    elif im.mode == \"L\":\n        dim = 2\n    # Z Dimension: Number of channels\n    z = len(im.mode)\n\n    if dim in {1, 2}:\n        z = 1\n\n    # assert we've got the right number of bands.\n    if len(im.getbands()) != z:\n        msg = f\"incorrect number of bands in SGI write: {z} vs {len(im.getbands())}\"\n        raise ValueError(msg)\n\n    # Minimum Byte value\n    pinmin = 0\n    # Maximum Byte value (255 = 8bits per pixel)\n    pinmax = 255\n    # Image name (79 characters max, truncated below in write)\n    img_name = os.path.splitext(os.path.basename(filename))[0]\n    if isinstance(img_name, str):\n        img_name = img_name.encode(\"ascii\", \"ignore\")\n    # Standard representation of pixel in the file\n    colormap = 0\n    fp.write(struct.pack(\">h\", magic_number))\n    fp.write(o8(rle))\n    fp.write(o8(bpc))\n    fp.write(struct.pack(\">H\", dim))\n    fp.write(struct.pack(\">H\", x))\n    fp.write(struct.pack(\">H\", y))\n    fp.write(struct.pack(\">H\", z))\n    fp.write(struct.pack(\">l\", pinmin))\n    fp.write(struct.pack(\">l\", pinmax))\n    fp.write(struct.pack(\"4s\", b\"\"))  # dummy\n    fp.write(struct.pack(\"79s\", img_name))  # truncates to 79 chars\n    fp.write(struct.pack(\"s\", b\"\"))  # force null byte after img_name\n    fp.write(struct.pack(\">l\", colormap))\n    fp.write(struct.pack(\"404s\", b\"\"))  # dummy\n\n    rawmode = \"L\"\n    if bpc == 2:\n        rawmode = \"L;16B\"\n\n    for channel in im.split():\n        fp.write(channel.tobytes(\"raw\", rawmode, 0, orientation))\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\nclass SGI16Decoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        assert self.im is not None\n\n        rawmode, stride, orientation = self.args\n        pagesize = self.state.xsize * self.state.ysize\n        zsize = len(self.mode)\n        self.fd.seek(512)\n\n        for band in range(zsize):\n            channel = Image.new(\"L\", (self.state.xsize, self.state.ysize))\n            channel.frombytes(\n                self.fd.read(2 * pagesize), \"raw\", \"L;16B\", stride, orientation\n            )\n            self.im.putband(channel.im, band)\n\n        return -1, 0\n\n\n#\n# registry\n\n\nImage.register_decoder(\"SGI16\", SGI16Decoder)\nImage.register_open(SgiImageFile.format, SgiImageFile, _accept)\nImage.register_save(SgiImageFile.format, _save)\nImage.register_mime(SgiImageFile.format, \"image/sgi\")\n\nImage.register_extensions(SgiImageFile.format, [\".bw\", \".rgb\", \".rgba\", \".sgi\"])\n\n# End of file\n", "src/PIL/TarIO.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# read files from within a tar file\n#\n# History:\n# 95-06-18 fl   Created\n# 96-05-28 fl   Open files in binary mode\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1995-96.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\n\nfrom . import ContainerIO\n\n\nclass TarIO(ContainerIO.ContainerIO[bytes]):\n    \"\"\"A file object that provides read access to a given member of a TAR file.\"\"\"\n\n    def __init__(self, tarfile: str, file: str) -> None:\n        \"\"\"\n        Create file object.\n\n        :param tarfile: Name of TAR file.\n        :param file: Name of member file.\n        \"\"\"\n        self.fh = open(tarfile, \"rb\")\n\n        while True:\n            s = self.fh.read(512)\n            if len(s) != 512:\n                msg = \"unexpected end of tar file\"\n                raise OSError(msg)\n\n            name = s[:100].decode(\"utf-8\")\n            i = name.find(\"\\0\")\n            if i == 0:\n                msg = \"cannot find subfile\"\n                raise OSError(msg)\n            if i > 0:\n                name = name[:i]\n\n            size = int(s[124:135], 8)\n\n            if file == name:\n                break\n\n            self.fh.seek((size + 511) & (~511), io.SEEK_CUR)\n\n        # Open region\n        super().__init__(self.fh, self.fh.tell(), size)\n\n    # Context manager support\n    def __enter__(self) -> TarIO:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def close(self) -> None:\n        self.fh.close()\n", "src/PIL/FitsImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# FITS file handling\n#\n# Copyright (c) 1998-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport gzip\nimport math\n\nfrom . import Image, ImageFile\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:6] == b\"SIMPLE\"\n\n\nclass FitsImageFile(ImageFile.ImageFile):\n    format = \"FITS\"\n    format_description = \"FITS\"\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        headers: dict[bytes, bytes] = {}\n        header_in_progress = False\n        decoder_name = \"\"\n        while True:\n            header = self.fp.read(80)\n            if not header:\n                msg = \"Truncated FITS file\"\n                raise OSError(msg)\n            keyword = header[:8].strip()\n            if keyword in (b\"SIMPLE\", b\"XTENSION\"):\n                header_in_progress = True\n            elif headers and not header_in_progress:\n                # This is now a data unit\n                break\n            elif keyword == b\"END\":\n                # Seek to the end of the header unit\n                self.fp.seek(math.ceil(self.fp.tell() / 2880) * 2880)\n                if not decoder_name:\n                    decoder_name, offset, args = self._parse_headers(headers)\n\n                header_in_progress = False\n                continue\n\n            if decoder_name:\n                # Keep going to read past the headers\n                continue\n\n            value = header[8:].split(b\"/\")[0].strip()\n            if value.startswith(b\"=\"):\n                value = value[1:].strip()\n            if not headers and (not _accept(keyword) or value != b\"T\"):\n                msg = \"Not a FITS file\"\n                raise SyntaxError(msg)\n            headers[keyword] = value\n\n        if not decoder_name:\n            msg = \"No image data\"\n            raise ValueError(msg)\n\n        offset += self.fp.tell() - 80\n        self.tile = [(decoder_name, (0, 0) + self.size, offset, args)]\n\n    def _get_size(\n        self, headers: dict[bytes, bytes], prefix: bytes\n    ) -> tuple[int, int] | None:\n        naxis = int(headers[prefix + b\"NAXIS\"])\n        if naxis == 0:\n            return None\n\n        if naxis == 1:\n            return 1, int(headers[prefix + b\"NAXIS1\"])\n        else:\n            return int(headers[prefix + b\"NAXIS1\"]), int(headers[prefix + b\"NAXIS2\"])\n\n    def _parse_headers(\n        self, headers: dict[bytes, bytes]\n    ) -> tuple[str, int, tuple[str | int, ...]]:\n        prefix = b\"\"\n        decoder_name = \"raw\"\n        offset = 0\n        if (\n            headers.get(b\"XTENSION\") == b\"'BINTABLE'\"\n            and headers.get(b\"ZIMAGE\") == b\"T\"\n            and headers[b\"ZCMPTYPE\"] == b\"'GZIP_1  '\"\n        ):\n            no_prefix_size = self._get_size(headers, prefix) or (0, 0)\n            number_of_bits = int(headers[b\"BITPIX\"])\n            offset = no_prefix_size[0] * no_prefix_size[1] * (number_of_bits // 8)\n\n            prefix = b\"Z\"\n            decoder_name = \"fits_gzip\"\n\n        size = self._get_size(headers, prefix)\n        if not size:\n            return \"\", 0, ()\n\n        self._size = size\n\n        number_of_bits = int(headers[prefix + b\"BITPIX\"])\n        if number_of_bits == 8:\n            self._mode = \"L\"\n        elif number_of_bits == 16:\n            self._mode = \"I;16\"\n        elif number_of_bits == 32:\n            self._mode = \"I\"\n        elif number_of_bits in (-32, -64):\n            self._mode = \"F\"\n\n        args: tuple[str | int, ...]\n        if decoder_name == \"raw\":\n            args = (self.mode, 0, -1)\n        else:\n            args = (number_of_bits,)\n        return decoder_name, offset, args\n\n\nclass FitsGzipDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        value = gzip.decompress(self.fd.read())\n\n        rows = []\n        offset = 0\n        number_of_bits = min(self.args[0] // 8, 4)\n        for y in range(self.state.ysize):\n            row = bytearray()\n            for x in range(self.state.xsize):\n                row += value[offset + (4 - number_of_bits) : offset + 4]\n                offset += 4\n            rows.append(row)\n        self.set_as_raw(bytes([pixel for row in rows[::-1] for pixel in row]))\n        return -1, 0\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(FitsImageFile.format, FitsImageFile, _accept)\nImage.register_decoder(\"fits_gzip\", FitsGzipDecoder)\n\nImage.register_extensions(FitsImageFile.format, [\".fit\", \".fits\"])\n", "src/PIL/JpegImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# JPEG (JFIF) file handling\n#\n# See \"Digital Compression and Coding of Continuous-Tone Still Images,\n# Part 1, Requirements and Guidelines\" (CCITT T.81 / ISO 10918-1)\n#\n# History:\n# 1995-09-09 fl   Created\n# 1995-09-13 fl   Added full parser\n# 1996-03-25 fl   Added hack to use the IJG command line utilities\n# 1996-05-05 fl   Workaround Photoshop 2.5 CMYK polarity bug\n# 1996-05-28 fl   Added draft support, JFIF version (0.1)\n# 1996-12-30 fl   Added encoder options, added progression property (0.2)\n# 1997-08-27 fl   Save mode 1 images as BW (0.3)\n# 1998-07-12 fl   Added YCbCr to draft and save methods (0.4)\n# 1998-10-19 fl   Don't hang on files using 16-bit DQT's (0.4.1)\n# 2001-04-16 fl   Extract DPI settings from JFIF files (0.4.2)\n# 2002-07-01 fl   Skip pad bytes before markers; identify Exif files (0.4.3)\n# 2003-04-25 fl   Added experimental EXIF decoder (0.5)\n# 2003-06-06 fl   Added experimental EXIF GPSinfo decoder\n# 2003-09-13 fl   Extract COM markers\n# 2009-09-06 fl   Added icc_profile support (from Florian Hoech)\n# 2009-03-06 fl   Changed CMYK handling; always use Adobe polarity (0.6)\n# 2009-03-08 fl   Added subsampling support (from Justin Huff).\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport array\nimport io\nimport math\nimport os\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport warnings\nfrom typing import IO, Any\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import o8\nfrom ._binary import o16be as o16\nfrom .JpegPresets import presets\n\n#\n# Parser\n\n\ndef Skip(self: JpegImageFile, marker: int) -> None:\n    n = i16(self.fp.read(2)) - 2\n    ImageFile._safe_read(self.fp, n)\n\n\ndef APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n\n    app = \"APP%d\" % (marker & 15)\n\n    self.app[app] = s  # compatibility\n    self.applist.append((app, s))\n\n    if marker == 0xFFE0 and s[:4] == b\"JFIF\":\n        # extract JFIF information\n        self.info[\"jfif\"] = version = i16(s, 5)  # version\n        self.info[\"jfif_version\"] = divmod(version, 256)\n        # extract JFIF properties\n        try:\n            jfif_unit = s[7]\n            jfif_density = i16(s, 8), i16(s, 10)\n        except Exception:\n            pass\n        else:\n            if jfif_unit == 1:\n                self.info[\"dpi\"] = jfif_density\n            self.info[\"jfif_unit\"] = jfif_unit\n            self.info[\"jfif_density\"] = jfif_density\n    elif marker == 0xFFE1 and s[:6] == b\"Exif\\0\\0\":\n        # extract EXIF information\n        if \"exif\" in self.info:\n            self.info[\"exif\"] += s[6:]\n        else:\n            self.info[\"exif\"] = s\n            self._exif_offset = self.fp.tell() - n + 6\n    elif marker == 0xFFE1 and s[:29] == b\"http://ns.adobe.com/xap/1.0/\\x00\":\n        self.info[\"xmp\"] = s.split(b\"\\x00\")[1]\n    elif marker == 0xFFE2 and s[:5] == b\"FPXR\\0\":\n        # extract FlashPix information (incomplete)\n        self.info[\"flashpix\"] = s  # FIXME: value will change\n    elif marker == 0xFFE2 and s[:12] == b\"ICC_PROFILE\\0\":\n        # Since an ICC profile can be larger than the maximum size of\n        # a JPEG marker (64K), we need provisions to split it into\n        # multiple markers. The format defined by the ICC specifies\n        # one or more APP2 markers containing the following data:\n        #   Identifying string      ASCII \"ICC_PROFILE\\0\"  (12 bytes)\n        #   Marker sequence number  1, 2, etc (1 byte)\n        #   Number of markers       Total of APP2's used (1 byte)\n        #   Profile data            (remainder of APP2 data)\n        # Decoders should use the marker sequence numbers to\n        # reassemble the profile, rather than assuming that the APP2\n        # markers appear in the correct sequence.\n        self.icclist.append(s)\n    elif marker == 0xFFED and s[:14] == b\"Photoshop 3.0\\x00\":\n        # parse the image resource block\n        offset = 14\n        photoshop = self.info.setdefault(\"photoshop\", {})\n        while s[offset : offset + 4] == b\"8BIM\":\n            try:\n                offset += 4\n                # resource code\n                code = i16(s, offset)\n                offset += 2\n                # resource name (usually empty)\n                name_len = s[offset]\n                # name = s[offset+1:offset+1+name_len]\n                offset += 1 + name_len\n                offset += offset & 1  # align\n                # resource data block\n                size = i32(s, offset)\n                offset += 4\n                data = s[offset : offset + size]\n                if code == 0x03ED:  # ResolutionInfo\n                    data = {\n                        \"XResolution\": i32(data, 0) / 65536,\n                        \"DisplayedUnitsX\": i16(data, 4),\n                        \"YResolution\": i32(data, 8) / 65536,\n                        \"DisplayedUnitsY\": i16(data, 12),\n                    }\n                photoshop[code] = data\n                offset += size\n                offset += offset & 1  # align\n            except struct.error:\n                break  # insufficient data\n\n    elif marker == 0xFFEE and s[:5] == b\"Adobe\":\n        self.info[\"adobe\"] = i16(s, 5)\n        # extract Adobe custom properties\n        try:\n            adobe_transform = s[11]\n        except IndexError:\n            pass\n        else:\n            self.info[\"adobe_transform\"] = adobe_transform\n    elif marker == 0xFFE2 and s[:4] == b\"MPF\\0\":\n        # extract MPO information\n        self.info[\"mp\"] = s[4:]\n        # offset is current location minus buffer size\n        # plus constant header size\n        self.info[\"mpoffset\"] = self.fp.tell() - n + 4\n\n    # If DPI isn't in JPEG header, fetch from EXIF\n    if \"dpi\" not in self.info and \"exif\" in self.info:\n        try:\n            exif = self.getexif()\n            resolution_unit = exif[0x0128]\n            x_resolution = exif[0x011A]\n            try:\n                dpi = float(x_resolution[0]) / x_resolution[1]\n            except TypeError:\n                dpi = x_resolution\n            if math.isnan(dpi):\n                msg = \"DPI is not a number\"\n                raise ValueError(msg)\n            if resolution_unit == 3:  # cm\n                # 1 dpcm = 2.54 dpi\n                dpi *= 2.54\n            self.info[\"dpi\"] = dpi, dpi\n        except (\n            struct.error,\n            KeyError,\n            SyntaxError,\n            TypeError,\n            ValueError,\n            ZeroDivisionError,\n        ):\n            # struct.error for truncated EXIF\n            # KeyError for dpi not included\n            # SyntaxError for invalid/unreadable EXIF\n            # ValueError or TypeError for dpi being an invalid float\n            # ZeroDivisionError for invalid dpi rational value\n            self.info[\"dpi\"] = 72, 72\n\n\ndef COM(self: JpegImageFile, marker: int) -> None:\n    #\n    # Comment marker.  Store these in the APP dictionary.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n\n    self.info[\"comment\"] = s\n    self.app[\"COM\"] = s  # compatibility\n    self.applist.append((\"COM\", s))\n\n\ndef SOF(self: JpegImageFile, marker: int) -> None:\n    #\n    # Start of frame marker.  Defines the size and mode of the\n    # image.  JPEG is colour blind, so we use some simple\n    # heuristics to map the number of layers to an appropriate\n    # mode.  Note that this could be made a bit brighter, by\n    # looking for JFIF and Adobe APP markers.\n\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    self._size = i16(s, 3), i16(s, 1)\n\n    self.bits = s[0]\n    if self.bits != 8:\n        msg = f\"cannot handle {self.bits}-bit layers\"\n        raise SyntaxError(msg)\n\n    self.layers = s[5]\n    if self.layers == 1:\n        self._mode = \"L\"\n    elif self.layers == 3:\n        self._mode = \"RGB\"\n    elif self.layers == 4:\n        self._mode = \"CMYK\"\n    else:\n        msg = f\"cannot handle {self.layers}-layer images\"\n        raise SyntaxError(msg)\n\n    if marker in [0xFFC2, 0xFFC6, 0xFFCA, 0xFFCE]:\n        self.info[\"progressive\"] = self.info[\"progression\"] = 1\n\n    if self.icclist:\n        # fixup icc profile\n        self.icclist.sort()  # sort by sequence number\n        if self.icclist[0][13] == len(self.icclist):\n            profile = [p[14:] for p in self.icclist]\n            icc_profile = b\"\".join(profile)\n        else:\n            icc_profile = None  # wrong number of fragments\n        self.info[\"icc_profile\"] = icc_profile\n        self.icclist = []\n\n    for i in range(6, len(s), 3):\n        t = s[i : i + 3]\n        # 4-tuples: id, vsamp, hsamp, qtable\n        self.layer.append((t[0], t[1] // 16, t[1] & 15, t[2]))\n\n\ndef DQT(self: JpegImageFile, marker: int) -> None:\n    #\n    # Define quantization table.  Note that there might be more\n    # than one table in each marker.\n\n    # FIXME: The quantization tables can be used to estimate the\n    # compression quality.\n\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    while len(s):\n        v = s[0]\n        precision = 1 if (v // 16 == 0) else 2  # in bytes\n        qt_length = 1 + precision * 64\n        if len(s) < qt_length:\n            msg = \"bad quantization table marker\"\n            raise SyntaxError(msg)\n        data = array.array(\"B\" if precision == 1 else \"H\", s[1:qt_length])\n        if sys.byteorder == \"little\" and precision > 1:\n            data.byteswap()  # the values are always big-endian\n        self.quantization[v & 15] = [data[i] for i in zigzag_index]\n        s = s[qt_length:]\n\n\n#\n# JPEG marker table\n\nMARKER = {\n    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),\n    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),\n    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),\n    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),\n    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),\n    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),\n    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),\n    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),\n    0xFFC8: (\"JPG\", \"Extension\", None),\n    0xFFC9: (\"SOF9\", \"Extended sequential DCT (AC)\", SOF),\n    0xFFCA: (\"SOF10\", \"Progressive DCT (AC)\", SOF),\n    0xFFCB: (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF),\n    0xFFCC: (\"DAC\", \"Define arithmetic coding conditioning\", Skip),\n    0xFFCD: (\"SOF13\", \"Differential sequential DCT (AC)\", SOF),\n    0xFFCE: (\"SOF14\", \"Differential progressive DCT (AC)\", SOF),\n    0xFFCF: (\"SOF15\", \"Differential spatial (AC)\", SOF),\n    0xFFD0: (\"RST0\", \"Restart 0\", None),\n    0xFFD1: (\"RST1\", \"Restart 1\", None),\n    0xFFD2: (\"RST2\", \"Restart 2\", None),\n    0xFFD3: (\"RST3\", \"Restart 3\", None),\n    0xFFD4: (\"RST4\", \"Restart 4\", None),\n    0xFFD5: (\"RST5\", \"Restart 5\", None),\n    0xFFD6: (\"RST6\", \"Restart 6\", None),\n    0xFFD7: (\"RST7\", \"Restart 7\", None),\n    0xFFD8: (\"SOI\", \"Start of image\", None),\n    0xFFD9: (\"EOI\", \"End of image\", None),\n    0xFFDA: (\"SOS\", \"Start of scan\", Skip),\n    0xFFDB: (\"DQT\", \"Define quantization table\", DQT),\n    0xFFDC: (\"DNL\", \"Define number of lines\", Skip),\n    0xFFDD: (\"DRI\", \"Define restart interval\", Skip),\n    0xFFDE: (\"DHP\", \"Define hierarchical progression\", SOF),\n    0xFFDF: (\"EXP\", \"Expand reference component\", Skip),\n    0xFFE0: (\"APP0\", \"Application segment 0\", APP),\n    0xFFE1: (\"APP1\", \"Application segment 1\", APP),\n    0xFFE2: (\"APP2\", \"Application segment 2\", APP),\n    0xFFE3: (\"APP3\", \"Application segment 3\", APP),\n    0xFFE4: (\"APP4\", \"Application segment 4\", APP),\n    0xFFE5: (\"APP5\", \"Application segment 5\", APP),\n    0xFFE6: (\"APP6\", \"Application segment 6\", APP),\n    0xFFE7: (\"APP7\", \"Application segment 7\", APP),\n    0xFFE8: (\"APP8\", \"Application segment 8\", APP),\n    0xFFE9: (\"APP9\", \"Application segment 9\", APP),\n    0xFFEA: (\"APP10\", \"Application segment 10\", APP),\n    0xFFEB: (\"APP11\", \"Application segment 11\", APP),\n    0xFFEC: (\"APP12\", \"Application segment 12\", APP),\n    0xFFED: (\"APP13\", \"Application segment 13\", APP),\n    0xFFEE: (\"APP14\", \"Application segment 14\", APP),\n    0xFFEF: (\"APP15\", \"Application segment 15\", APP),\n    0xFFF0: (\"JPG0\", \"Extension 0\", None),\n    0xFFF1: (\"JPG1\", \"Extension 1\", None),\n    0xFFF2: (\"JPG2\", \"Extension 2\", None),\n    0xFFF3: (\"JPG3\", \"Extension 3\", None),\n    0xFFF4: (\"JPG4\", \"Extension 4\", None),\n    0xFFF5: (\"JPG5\", \"Extension 5\", None),\n    0xFFF6: (\"JPG6\", \"Extension 6\", None),\n    0xFFF7: (\"JPG7\", \"Extension 7\", None),\n    0xFFF8: (\"JPG8\", \"Extension 8\", None),\n    0xFFF9: (\"JPG9\", \"Extension 9\", None),\n    0xFFFA: (\"JPG10\", \"Extension 10\", None),\n    0xFFFB: (\"JPG11\", \"Extension 11\", None),\n    0xFFFC: (\"JPG12\", \"Extension 12\", None),\n    0xFFFD: (\"JPG13\", \"Extension 13\", None),\n    0xFFFE: (\"COM\", \"Comment\", COM),\n}\n\n\ndef _accept(prefix: bytes) -> bool:\n    # Magic number was taken from https://en.wikipedia.org/wiki/JPEG\n    return prefix[:3] == b\"\\xFF\\xD8\\xFF\"\n\n\n##\n# Image plugin for JPEG and JFIF images.\n\n\nclass JpegImageFile(ImageFile.ImageFile):\n    format = \"JPEG\"\n    format_description = \"JPEG (ISO 10918)\"\n\n    def _open(self):\n        s = self.fp.read(3)\n\n        if not _accept(s):\n            msg = \"not a JPEG file\"\n            raise SyntaxError(msg)\n        s = b\"\\xFF\"\n\n        # Create attributes\n        self.bits = self.layers = 0\n\n        # JPEG specifics (internal)\n        self.layer = []\n        self.huffman_dc = {}\n        self.huffman_ac = {}\n        self.quantization = {}\n        self.app = {}  # compatibility\n        self.applist = []\n        self.icclist = []\n\n        while True:\n            i = s[0]\n            if i == 0xFF:\n                s = s + self.fp.read(1)\n                i = i16(s)\n            else:\n                # Skip non-0xFF junk\n                s = self.fp.read(1)\n                continue\n\n            if i in MARKER:\n                name, description, handler = MARKER[i]\n                if handler is not None:\n                    handler(self, i)\n                if i == 0xFFDA:  # start of scan\n                    rawmode = self.mode\n                    if self.mode == \"CMYK\":\n                        rawmode = \"CMYK;I\"  # assume adobe conventions\n                    self.tile = [(\"jpeg\", (0, 0) + self.size, 0, (rawmode, \"\"))]\n                    # self.__offset = self.fp.tell()\n                    break\n                s = self.fp.read(1)\n            elif i in {0, 0xFFFF}:\n                # padded marker or junk; move on\n                s = b\"\\xff\"\n            elif i == 0xFF00:  # Skip extraneous data (escaped 0xFF)\n                s = self.fp.read(1)\n            else:\n                msg = \"no marker found\"\n                raise SyntaxError(msg)\n\n    def load_read(self, read_bytes: int) -> bytes:\n        \"\"\"\n        internal: read more image data\n        For premature EOF and LOAD_TRUNCATED_IMAGES adds EOI marker\n        so libjpeg can finish decoding\n        \"\"\"\n        s = self.fp.read(read_bytes)\n\n        if not s and ImageFile.LOAD_TRUNCATED_IMAGES and not hasattr(self, \"_ended\"):\n            # Premature EOF.\n            # Pretend file is finished adding EOI marker\n            self._ended = True\n            return b\"\\xFF\\xD9\"\n\n        return s\n\n    def draft(\n        self, mode: str | None, size: tuple[int, int] | None\n    ) -> tuple[str, tuple[int, int, float, float]] | None:\n        if len(self.tile) != 1:\n            return None\n\n        # Protect from second call\n        if self.decoderconfig:\n            return None\n\n        d, e, o, a = self.tile[0]\n        scale = 1\n        original_size = self.size\n\n        if a[0] == \"RGB\" and mode in [\"L\", \"YCbCr\"]:\n            self._mode = mode\n            a = mode, \"\"\n\n        if size:\n            scale = min(self.size[0] // size[0], self.size[1] // size[1])\n            for s in [8, 4, 2, 1]:\n                if scale >= s:\n                    break\n            e = (\n                e[0],\n                e[1],\n                (e[2] - e[0] + s - 1) // s + e[0],\n                (e[3] - e[1] + s - 1) // s + e[1],\n            )\n            self._size = ((self.size[0] + s - 1) // s, (self.size[1] + s - 1) // s)\n            scale = s\n\n        self.tile = [(d, e, o, a)]\n        self.decoderconfig = (scale, 0)\n\n        box = (0, 0, original_size[0] / scale, original_size[1] / scale)\n        return self.mode, box\n\n    def load_djpeg(self) -> None:\n        # ALTERNATIVE: handle JPEGs via the IJG command line utilities\n\n        f, path = tempfile.mkstemp()\n        os.close(f)\n        if os.path.exists(self.filename):\n            subprocess.check_call([\"djpeg\", \"-outfile\", path, self.filename])\n        else:\n            try:\n                os.unlink(path)\n            except OSError:\n                pass\n\n            msg = \"Invalid Filename\"\n            raise ValueError(msg)\n\n        try:\n            with Image.open(path) as _im:\n                _im.load()\n                self.im = _im.im\n        finally:\n            try:\n                os.unlink(path)\n            except OSError:\n                pass\n\n        self._mode = self.im.mode\n        self._size = self.im.size\n\n        self.tile = []\n\n    def _getexif(self) -> dict[str, Any] | None:\n        return _getexif(self)\n\n    def _getmp(self):\n        return _getmp(self)\n\n\ndef _getexif(self) -> dict[str, Any] | None:\n    if \"exif\" not in self.info:\n        return None\n    return self.getexif()._get_merged_dict()\n\n\ndef _getmp(self):\n    # Extract MP information.  This method was inspired by the \"highly\n    # experimental\" _getexif version that's been in use for years now,\n    # itself based on the ImageFileDirectory class in the TIFF plugin.\n\n    # The MP record essentially consists of a TIFF file embedded in a JPEG\n    # application marker.\n    try:\n        data = self.info[\"mp\"]\n    except KeyError:\n        return None\n    file_contents = io.BytesIO(data)\n    head = file_contents.read(8)\n    endianness = \">\" if head[:4] == b\"\\x4d\\x4d\\x00\\x2a\" else \"<\"\n    # process dictionary\n    from . import TiffImagePlugin\n\n    try:\n        info = TiffImagePlugin.ImageFileDirectory_v2(head)\n        file_contents.seek(info.next)\n        info.load(file_contents)\n        mp = dict(info)\n    except Exception as e:\n        msg = \"malformed MP Index (unreadable directory)\"\n        raise SyntaxError(msg) from e\n    # it's an error not to have a number of images\n    try:\n        quant = mp[0xB001]\n    except KeyError as e:\n        msg = \"malformed MP Index (no number of images)\"\n        raise SyntaxError(msg) from e\n    # get MP entries\n    mpentries = []\n    try:\n        rawmpentries = mp[0xB002]\n        for entrynum in range(0, quant):\n            unpackedentry = struct.unpack_from(\n                f\"{endianness}LLLHH\", rawmpentries, entrynum * 16\n            )\n            labels = (\"Attribute\", \"Size\", \"DataOffset\", \"EntryNo1\", \"EntryNo2\")\n            mpentry = dict(zip(labels, unpackedentry))\n            mpentryattr = {\n                \"DependentParentImageFlag\": bool(mpentry[\"Attribute\"] & (1 << 31)),\n                \"DependentChildImageFlag\": bool(mpentry[\"Attribute\"] & (1 << 30)),\n                \"RepresentativeImageFlag\": bool(mpentry[\"Attribute\"] & (1 << 29)),\n                \"Reserved\": (mpentry[\"Attribute\"] & (3 << 27)) >> 27,\n                \"ImageDataFormat\": (mpentry[\"Attribute\"] & (7 << 24)) >> 24,\n                \"MPType\": mpentry[\"Attribute\"] & 0x00FFFFFF,\n            }\n            if mpentryattr[\"ImageDataFormat\"] == 0:\n                mpentryattr[\"ImageDataFormat\"] = \"JPEG\"\n            else:\n                msg = \"unsupported picture format in MPO\"\n                raise SyntaxError(msg)\n            mptypemap = {\n                0x000000: \"Undefined\",\n                0x010001: \"Large Thumbnail (VGA Equivalent)\",\n                0x010002: \"Large Thumbnail (Full HD Equivalent)\",\n                0x020001: \"Multi-Frame Image (Panorama)\",\n                0x020002: \"Multi-Frame Image: (Disparity)\",\n                0x020003: \"Multi-Frame Image: (Multi-Angle)\",\n                0x030000: \"Baseline MP Primary Image\",\n            }\n            mpentryattr[\"MPType\"] = mptypemap.get(mpentryattr[\"MPType\"], \"Unknown\")\n            mpentry[\"Attribute\"] = mpentryattr\n            mpentries.append(mpentry)\n        mp[0xB002] = mpentries\n    except KeyError as e:\n        msg = \"malformed MP Index (bad MP Entry)\"\n        raise SyntaxError(msg) from e\n    # Next we should try and parse the individual image unique ID list;\n    # we don't because I've never seen this actually used in a real MPO\n    # file and so can't test it.\n    return mp\n\n\n# --------------------------------------------------------------------\n# stuff to save JPEG files\n\nRAWMODE = {\n    \"1\": \"L\",\n    \"L\": \"L\",\n    \"RGB\": \"RGB\",\n    \"RGBX\": \"RGB\",\n    \"CMYK\": \"CMYK;I\",  # assume adobe conventions\n    \"YCbCr\": \"YCbCr\",\n}\n\n# fmt: off\nzigzag_index = (\n    0,  1,  5,  6, 14, 15, 27, 28,\n    2,  4,  7, 13, 16, 26, 29, 42,\n    3,  8, 12, 17, 25, 30, 41, 43,\n    9, 11, 18, 24, 31, 40, 44, 53,\n    10, 19, 23, 32, 39, 45, 52, 54,\n    20, 22, 33, 38, 46, 51, 55, 60,\n    21, 34, 37, 47, 50, 56, 59, 61,\n    35, 36, 48, 49, 57, 58, 62, 63,\n)\n\nsamplings = {\n    (1, 1, 1, 1, 1, 1): 0,\n    (2, 1, 1, 1, 1, 1): 1,\n    (2, 2, 1, 1, 1, 1): 2,\n}\n# fmt: on\n\n\ndef get_sampling(im):\n    # There's no subsampling when images have only 1 layer\n    # (grayscale images) or when they are CMYK (4 layers),\n    # so set subsampling to the default value.\n    #\n    # NOTE: currently Pillow can't encode JPEG to YCCK format.\n    # If YCCK support is added in the future, subsampling code will have\n    # to be updated (here and in JpegEncode.c) to deal with 4 layers.\n    if not hasattr(im, \"layers\") or im.layers in (1, 4):\n        return -1\n    sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]\n    return samplings.get(sampling, -1)\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.width == 0 or im.height == 0:\n        msg = \"cannot write empty image as JPEG\"\n        raise ValueError(msg)\n\n    try:\n        rawmode = RAWMODE[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as JPEG\"\n        raise OSError(msg) from e\n\n    info = im.encoderinfo\n\n    dpi = [round(x) for x in info.get(\"dpi\", (0, 0))]\n\n    quality = info.get(\"quality\", -1)\n    subsampling = info.get(\"subsampling\", -1)\n    qtables = info.get(\"qtables\")\n\n    if quality == \"keep\":\n        quality = -1\n        subsampling = \"keep\"\n        qtables = \"keep\"\n    elif quality in presets:\n        preset = presets[quality]\n        quality = -1\n        subsampling = preset.get(\"subsampling\", -1)\n        qtables = preset.get(\"quantization\")\n    elif not isinstance(quality, int):\n        msg = \"Invalid quality setting\"\n        raise ValueError(msg)\n    else:\n        if subsampling in presets:\n            subsampling = presets[subsampling].get(\"subsampling\", -1)\n        if isinstance(qtables, str) and qtables in presets:\n            qtables = presets[qtables].get(\"quantization\")\n\n    if subsampling == \"4:4:4\":\n        subsampling = 0\n    elif subsampling == \"4:2:2\":\n        subsampling = 1\n    elif subsampling == \"4:2:0\":\n        subsampling = 2\n    elif subsampling == \"4:1:1\":\n        # For compatibility. Before Pillow 4.3, 4:1:1 actually meant 4:2:0.\n        # Set 4:2:0 if someone is still using that value.\n        subsampling = 2\n    elif subsampling == \"keep\":\n        if im.format != \"JPEG\":\n            msg = \"Cannot use 'keep' when original image is not a JPEG\"\n            raise ValueError(msg)\n        subsampling = get_sampling(im)\n\n    def validate_qtables(qtables):\n        if qtables is None:\n            return qtables\n        if isinstance(qtables, str):\n            try:\n                lines = [\n                    int(num)\n                    for line in qtables.splitlines()\n                    for num in line.split(\"#\", 1)[0].split()\n                ]\n            except ValueError as e:\n                msg = \"Invalid quantization table\"\n                raise ValueError(msg) from e\n            else:\n                qtables = [lines[s : s + 64] for s in range(0, len(lines), 64)]\n        if isinstance(qtables, (tuple, list, dict)):\n            if isinstance(qtables, dict):\n                qtables = [\n                    qtables[key] for key in range(len(qtables)) if key in qtables\n                ]\n            elif isinstance(qtables, tuple):\n                qtables = list(qtables)\n            if not (0 < len(qtables) < 5):\n                msg = \"None or too many quantization tables\"\n                raise ValueError(msg)\n            for idx, table in enumerate(qtables):\n                try:\n                    if len(table) != 64:\n                        msg = \"Invalid quantization table\"\n                        raise TypeError(msg)\n                    table = array.array(\"H\", table)\n                except TypeError as e:\n                    msg = \"Invalid quantization table\"\n                    raise ValueError(msg) from e\n                else:\n                    qtables[idx] = list(table)\n            return qtables\n\n    if qtables == \"keep\":\n        if im.format != \"JPEG\":\n            msg = \"Cannot use 'keep' when original image is not a JPEG\"\n            raise ValueError(msg)\n        qtables = getattr(im, \"quantization\", None)\n    qtables = validate_qtables(qtables)\n\n    extra = info.get(\"extra\", b\"\")\n\n    MAX_BYTES_IN_MARKER = 65533\n    icc_profile = info.get(\"icc_profile\")\n    if icc_profile:\n        ICC_OVERHEAD_LEN = 14\n        MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN\n        markers = []\n        while icc_profile:\n            markers.append(icc_profile[:MAX_DATA_BYTES_IN_MARKER])\n            icc_profile = icc_profile[MAX_DATA_BYTES_IN_MARKER:]\n        i = 1\n        for marker in markers:\n            size = o16(2 + ICC_OVERHEAD_LEN + len(marker))\n            extra += (\n                b\"\\xFF\\xE2\"\n                + size\n                + b\"ICC_PROFILE\\0\"\n                + o8(i)\n                + o8(len(markers))\n                + marker\n            )\n            i += 1\n\n    comment = info.get(\"comment\", im.info.get(\"comment\"))\n\n    # \"progressive\" is the official name, but older documentation\n    # says \"progression\"\n    # FIXME: issue a warning if the wrong form is used (post-1.1.7)\n    progressive = info.get(\"progressive\", False) or info.get(\"progression\", False)\n\n    optimize = info.get(\"optimize\", False)\n\n    exif = info.get(\"exif\", b\"\")\n    if isinstance(exif, Image.Exif):\n        exif = exif.tobytes()\n    if len(exif) > MAX_BYTES_IN_MARKER:\n        msg = \"EXIF data is too long\"\n        raise ValueError(msg)\n\n    # get keyword arguments\n    im.encoderconfig = (\n        quality,\n        progressive,\n        info.get(\"smooth\", 0),\n        optimize,\n        info.get(\"keep_rgb\", False),\n        info.get(\"streamtype\", 0),\n        dpi[0],\n        dpi[1],\n        subsampling,\n        info.get(\"restart_marker_blocks\", 0),\n        info.get(\"restart_marker_rows\", 0),\n        qtables,\n        comment,\n        extra,\n        exif,\n    )\n\n    # if we optimize, libjpeg needs a buffer big enough to hold the whole image\n    # in a shot. Guessing on the size, at im.size bytes. (raw pixel size is\n    # channels*size, this is a value that's been used in a django patch.\n    # https://github.com/matthewwithanm/django-imagekit/issues/50\n    bufsize = 0\n    if optimize or progressive:\n        # CMYK can be bigger\n        if im.mode == \"CMYK\":\n            bufsize = 4 * im.size[0] * im.size[1]\n        # keep sets quality to -1, but the actual value may be high.\n        elif quality >= 95 or quality == -1:\n            bufsize = 2 * im.size[0] * im.size[1]\n        else:\n            bufsize = im.size[0] * im.size[1]\n        if exif:\n            bufsize += len(exif) + 5\n        if extra:\n            bufsize += len(extra) + 1\n    else:\n        # The EXIF info needs to be written as one block, + APP1, + one spare byte.\n        # Ensure that our buffer is big enough. Same with the icc_profile block.\n        bufsize = max(bufsize, len(exif) + 5, len(extra) + 1)\n\n    ImageFile._save(im, fp, [(\"jpeg\", (0, 0) + im.size, 0, rawmode)], bufsize)\n\n\ndef _save_cjpeg(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # ALTERNATIVE: handle JPEGs via the IJG command line utilities.\n    tempfile = im._dump()\n    subprocess.check_call([\"cjpeg\", \"-outfile\", filename, tempfile])\n    try:\n        os.unlink(tempfile)\n    except OSError:\n        pass\n\n\n##\n# Factory for making JPEG and MPO instances\ndef jpeg_factory(fp=None, filename=None):\n    im = JpegImageFile(fp, filename)\n    try:\n        mpheader = im._getmp()\n        if mpheader[45057] > 1:\n            # It's actually an MPO\n            from .MpoImagePlugin import MpoImageFile\n\n            # Don't reload everything, just convert it.\n            im = MpoImageFile.adopt(im, mpheader)\n    except (TypeError, IndexError):\n        # It is really a JPEG\n        pass\n    except SyntaxError:\n        warnings.warn(\n            \"Image appears to be a malformed MPO file, it will be \"\n            \"interpreted as a base JPEG file\"\n        )\n    return im\n\n\n# ---------------------------------------------------------------------\n# Registry stuff\n\nImage.register_open(JpegImageFile.format, jpeg_factory, _accept)\nImage.register_save(JpegImageFile.format, _save)\n\nImage.register_extensions(JpegImageFile.format, [\".jfif\", \".jpe\", \".jpg\", \".jpeg\"])\n\nImage.register_mime(JpegImageFile.format, \"image/jpeg\")\n", "src/PIL/XbmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# XBM File handling\n#\n# History:\n# 1995-09-08 fl   Created\n# 1996-11-01 fl   Added save support\n# 1997-07-07 fl   Made header parser more tolerant\n# 1997-07-22 fl   Fixed yet another parser bug\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)\n# 2001-05-13 fl   Added hotspot handling (based on code from Bernhard Herzog)\n# 2004-02-24 fl   Allow some whitespace before first #define\n#\n# Copyright (c) 1997-2004 by Secret Labs AB\n# Copyright (c) 1996-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n# XBM header\nxbm_head = re.compile(\n    rb\"\\s*#define[ \\t]+.*_width[ \\t]+(?P<width>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+.*_height[ \\t]+(?P<height>[0-9]+)[\\r\\n]+\"\n    b\"(?P<hotspot>\"\n    b\"#define[ \\t]+[^_]*_x_hot[ \\t]+(?P<xhot>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+[^_]*_y_hot[ \\t]+(?P<yhot>[0-9]+)[\\r\\n]+\"\n    b\")?\"\n    rb\"[\\000-\\377]*_bits\\[]\"\n)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix.lstrip()[:7] == b\"#define\"\n\n\n##\n# Image plugin for X11 bitmaps.\n\n\nclass XbmImageFile(ImageFile.ImageFile):\n    format = \"XBM\"\n    format_description = \"X11 Bitmap\"\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        m = xbm_head.match(self.fp.read(512))\n\n        if not m:\n            msg = \"not a XBM file\"\n            raise SyntaxError(msg)\n\n        xsize = int(m.group(\"width\"))\n        ysize = int(m.group(\"height\"))\n\n        if m.group(\"hotspot\"):\n            self.info[\"hotspot\"] = (int(m.group(\"xhot\")), int(m.group(\"yhot\")))\n\n        self._mode = \"1\"\n        self._size = xsize, ysize\n\n        self.tile = [(\"xbm\", (0, 0) + self.size, m.end(), None)]\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode != \"1\":\n        msg = f\"cannot write mode {im.mode} as XBM\"\n        raise OSError(msg)\n\n    fp.write(f\"#define im_width {im.size[0]}\\n\".encode(\"ascii\"))\n    fp.write(f\"#define im_height {im.size[1]}\\n\".encode(\"ascii\"))\n\n    hotspot = im.encoderinfo.get(\"hotspot\")\n    if hotspot:\n        fp.write(f\"#define im_x_hot {hotspot[0]}\\n\".encode(\"ascii\"))\n        fp.write(f\"#define im_y_hot {hotspot[1]}\\n\".encode(\"ascii\"))\n\n    fp.write(b\"static char im_bits[] = {\\n\")\n\n    ImageFile._save(im, fp, [(\"xbm\", (0, 0) + im.size, 0, None)])\n\n    fp.write(b\"};\\n\")\n\n\nImage.register_open(XbmImageFile.format, XbmImageFile, _accept)\nImage.register_save(XbmImageFile.format, _save)\n\nImage.register_extension(XbmImageFile.format, \".xbm\")\n\nImage.register_mime(XbmImageFile.format, \"image/xbm\")\n", "src/PIL/ImageGrab.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# screen grabber\n#\n# History:\n# 2001-04-26 fl  created\n# 2001-09-17 fl  use builtin driver, if present\n# 2002-11-19 fl  added grabclipboard support\n#\n# Copyright (c) 2001-2002 by Secret Labs AB\n# Copyright (c) 2001-2002 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\nfrom . import Image\n\n\ndef grab(bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None):\n    if xdisplay is None:\n        if sys.platform == \"darwin\":\n            fh, filepath = tempfile.mkstemp(\".png\")\n            os.close(fh)\n            args = [\"screencapture\"]\n            if bbox:\n                left, top, right, bottom = bbox\n                args += [\"-R\", f\"{left},{top},{right-left},{bottom-top}\"]\n            subprocess.call(args + [\"-x\", filepath])\n            im = Image.open(filepath)\n            im.load()\n            os.unlink(filepath)\n            if bbox:\n                im_resized = im.resize((right - left, bottom - top))\n                im.close()\n                return im_resized\n            return im\n        elif sys.platform == \"win32\":\n            offset, size, data = Image.core.grabscreen_win32(\n                include_layered_windows, all_screens\n            )\n            im = Image.frombytes(\n                \"RGB\",\n                size,\n                data,\n                # RGB, 32-bit line padding, origin lower left corner\n                \"raw\",\n                \"BGR\",\n                (size[0] * 3 + 3) & -4,\n                -1,\n            )\n            if bbox:\n                x0, y0 = offset\n                left, top, right, bottom = bbox\n                im = im.crop((left - x0, top - y0, right - x0, bottom - y0))\n            return im\n    try:\n        if not Image.core.HAVE_XCB:\n            msg = \"Pillow was built without XCB support\"\n            raise OSError(msg)\n        size, data = Image.core.grabscreen_x11(xdisplay)\n    except OSError:\n        if (\n            xdisplay is None\n            and sys.platform not in (\"darwin\", \"win32\")\n            and shutil.which(\"gnome-screenshot\")\n        ):\n            fh, filepath = tempfile.mkstemp(\".png\")\n            os.close(fh)\n            subprocess.call([\"gnome-screenshot\", \"-f\", filepath])\n            im = Image.open(filepath)\n            im.load()\n            os.unlink(filepath)\n            if bbox:\n                im_cropped = im.crop(bbox)\n                im.close()\n                return im_cropped\n            return im\n        else:\n            raise\n    else:\n        im = Image.frombytes(\"RGB\", size, data, \"raw\", \"BGRX\", size[0] * 4, 1)\n        if bbox:\n            im = im.crop(bbox)\n        return im\n\n\ndef grabclipboard():\n    if sys.platform == \"darwin\":\n        fh, filepath = tempfile.mkstemp(\".png\")\n        os.close(fh)\n        commands = [\n            'set theFile to (open for access POSIX file \"'\n            + filepath\n            + '\" with write permission)',\n            \"try\",\n            \"    write (the clipboard as \u00abclass PNGf\u00bb) to theFile\",\n            \"end try\",\n            \"close access theFile\",\n        ]\n        script = [\"osascript\"]\n        for command in commands:\n            script += [\"-e\", command]\n        subprocess.call(script)\n\n        im = None\n        if os.stat(filepath).st_size != 0:\n            im = Image.open(filepath)\n            im.load()\n        os.unlink(filepath)\n        return im\n    elif sys.platform == \"win32\":\n        fmt, data = Image.core.grabclipboard_win32()\n        if fmt == \"file\":  # CF_HDROP\n            import struct\n\n            o = struct.unpack_from(\"I\", data)[0]\n            if data[16] != 0:\n                files = data[o:].decode(\"utf-16le\").split(\"\\0\")\n            else:\n                files = data[o:].decode(\"mbcs\").split(\"\\0\")\n            return files[: files.index(\"\")]\n        if isinstance(data, bytes):\n            data = io.BytesIO(data)\n            if fmt == \"png\":\n                from . import PngImagePlugin\n\n                return PngImagePlugin.PngImageFile(data)\n            elif fmt == \"DIB\":\n                from . import BmpImagePlugin\n\n                return BmpImagePlugin.DibImageFile(data)\n        return None\n    else:\n        if os.getenv(\"WAYLAND_DISPLAY\"):\n            session_type = \"wayland\"\n        elif os.getenv(\"DISPLAY\"):\n            session_type = \"x11\"\n        else:  # Session type check failed\n            session_type = None\n\n        if shutil.which(\"wl-paste\") and session_type in (\"wayland\", None):\n            args = [\"wl-paste\", \"-t\", \"image\"]\n        elif shutil.which(\"xclip\") and session_type in (\"x11\", None):\n            args = [\"xclip\", \"-selection\", \"clipboard\", \"-t\", \"image/png\", \"-o\"]\n        else:\n            msg = \"wl-paste or xclip is required for ImageGrab.grabclipboard() on Linux\"\n            raise NotImplementedError(msg)\n\n        p = subprocess.run(args, capture_output=True)\n        if p.returncode != 0:\n            err = p.stderr\n            for silent_error in [\n                # wl-paste, when the clipboard is empty\n                b\"Nothing is copied\",\n                # Ubuntu/Debian wl-paste, when the clipboard is empty\n                b\"No selection\",\n                # Ubuntu/Debian wl-paste, when an image isn't available\n                b\"No suitable type of content copied\",\n                # wl-paste or Ubuntu/Debian xclip, when an image isn't available\n                b\" not available\",\n                # xclip, when an image isn't available\n                b\"cannot convert \",\n                # xclip, when the clipboard isn't initialized\n                b\"xclip: Error: There is no owner for the \",\n            ]:\n                if silent_error in err:\n                    return None\n            msg = f\"{args[0]} error\"\n            if err:\n                msg += f\": {err.strip().decode()}\"\n            raise ChildProcessError(msg)\n\n        data = io.BytesIO(p.stdout)\n        im = Image.open(data)\n        im.load()\n        return im\n", "src/PIL/MpegImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# MPEG file handling\n#\n# History:\n#       95-09-09 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1995.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i8\nfrom ._typing import SupportsRead\n\n#\n# Bitstream parser\n\n\nclass BitStream:\n    def __init__(self, fp: SupportsRead[bytes]) -> None:\n        self.fp = fp\n        self.bits = 0\n        self.bitbuffer = 0\n\n    def next(self) -> int:\n        return i8(self.fp.read(1))\n\n    def peek(self, bits: int) -> int:\n        while self.bits < bits:\n            c = self.next()\n            if c < 0:\n                self.bits = 0\n                continue\n            self.bitbuffer = (self.bitbuffer << 8) + c\n            self.bits += 8\n        return self.bitbuffer >> (self.bits - bits) & (1 << bits) - 1\n\n    def skip(self, bits: int) -> None:\n        while self.bits < bits:\n            self.bitbuffer = (self.bitbuffer << 8) + i8(self.fp.read(1))\n            self.bits += 8\n        self.bits = self.bits - bits\n\n    def read(self, bits: int) -> int:\n        v = self.peek(bits)\n        self.bits = self.bits - bits\n        return v\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"\\x00\\x00\\x01\\xb3\"\n\n\n##\n# Image plugin for MPEG streams.  This plugin can identify a stream,\n# but it cannot read it.\n\n\nclass MpegImageFile(ImageFile.ImageFile):\n    format = \"MPEG\"\n    format_description = \"MPEG\"\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        s = BitStream(self.fp)\n        if s.read(32) != 0x1B3:\n            msg = \"not an MPEG file\"\n            raise SyntaxError(msg)\n\n        self._mode = \"RGB\"\n        self._size = s.read(12), s.read(12)\n\n\n# --------------------------------------------------------------------\n# Registry stuff\n\nImage.register_open(MpegImageFile.format, MpegImageFile, _accept)\n\nImage.register_extensions(MpegImageFile.format, [\".mpg\", \".mpeg\"])\n\nImage.register_mime(MpegImageFile.format, \"video/mpeg\")\n", "src/PIL/XVThumbImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# XV Thumbnail file handler by Charles E. \"Gene\" Cash\n# (gcash@magicnet.net)\n#\n# see xvcolor.c and xvbrowse.c in the sources to John Bradley's XV,\n# available from ftp://ftp.cis.upenn.edu/pub/xv/\n#\n# history:\n# 98-08-15 cec  created (b/w only)\n# 98-12-09 cec  added color palette\n# 98-12-28 fl   added to PIL (with only a few very minor modifications)\n#\n# To do:\n# FIXME: make save work (this requires quantization support)\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import o8\n\n_MAGIC = b\"P7 332\"\n\n# standard color palette for thumbnails (RGB332)\nPALETTE = b\"\"\nfor r in range(8):\n    for g in range(8):\n        for b in range(4):\n            PALETTE = PALETTE + (\n                o8((r * 255) // 7) + o8((g * 255) // 7) + o8((b * 255) // 3)\n            )\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:6] == _MAGIC\n\n\n##\n# Image plugin for XV thumbnail images.\n\n\nclass XVThumbImageFile(ImageFile.ImageFile):\n    format = \"XVThumb\"\n    format_description = \"XV thumbnail image\"\n\n    def _open(self) -> None:\n        # check magic\n        assert self.fp is not None\n\n        if not _accept(self.fp.read(6)):\n            msg = \"not an XV thumbnail file\"\n            raise SyntaxError(msg)\n\n        # Skip to beginning of next line\n        self.fp.readline()\n\n        # skip info comments\n        while True:\n            s = self.fp.readline()\n            if not s:\n                msg = \"Unexpected EOF reading XV thumbnail file\"\n                raise SyntaxError(msg)\n            if s[0] != 35:  # ie. when not a comment: '#'\n                break\n\n        # parse header line (already read)\n        s = s.strip().split()\n\n        self._mode = \"P\"\n        self._size = int(s[0]), int(s[1])\n\n        self.palette = ImagePalette.raw(\"RGB\", PALETTE)\n\n        self.tile = [(\"raw\", (0, 0) + self.size, self.fp.tell(), (self.mode, 0, 1))]\n\n\n# --------------------------------------------------------------------\n\nImage.register_open(XVThumbImageFile.format, XVThumbImageFile, _accept)\n", "src/PIL/ImageFilter.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard filters\n#\n# History:\n# 1995-11-27 fl   Created\n# 2002-06-08 fl   Added rank and mode filters\n# 2003-09-15 fl   Fixed rank calculation in rank filter; added expand call\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2002 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING, Any, Callable, Sequence, cast\n\nif TYPE_CHECKING:\n    from . import _imaging\n    from ._typing import NumpyArray\n\n\nclass Filter:\n    @abc.abstractmethod\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        pass\n\n\nclass MultibandFilter(Filter):\n    pass\n\n\nclass BuiltinFilter(MultibandFilter):\n    filterargs: tuple[Any, ...]\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        if image.mode == \"P\":\n            msg = \"cannot filter palette images\"\n            raise ValueError(msg)\n        return image.filter(*self.filterargs)\n\n\nclass Kernel(BuiltinFilter):\n    \"\"\"\n    Create a convolution kernel. This only supports 3x3 and 5x5 integer and floating\n    point kernels.\n\n    Kernels can only be applied to \"L\" and \"RGB\" images.\n\n    :param size: Kernel size, given as (width, height). This must be (3,3) or (5,5).\n    :param kernel: A sequence containing kernel weights. The kernel will be flipped\n                   vertically before being applied to the image.\n    :param scale: Scale factor. If given, the result for each pixel is divided by this\n                  value. The default is the sum of the kernel weights.\n    :param offset: Offset. If given, this value is added to the result, after it has\n                   been divided by the scale factor.\n    \"\"\"\n\n    name = \"Kernel\"\n\n    def __init__(\n        self,\n        size: tuple[int, int],\n        kernel: Sequence[float],\n        scale: float | None = None,\n        offset: float = 0,\n    ) -> None:\n        if scale is None:\n            # default scale is sum of kernel\n            scale = functools.reduce(lambda a, b: a + b, kernel)\n        if size[0] * size[1] != len(kernel):\n            msg = \"not enough coefficients in kernel\"\n            raise ValueError(msg)\n        self.filterargs = size, scale, offset, kernel\n\n\nclass RankFilter(Filter):\n    \"\"\"\n    Create a rank filter.  The rank filter sorts all pixels in\n    a window of the given size, and returns the ``rank``'th value.\n\n    :param size: The kernel size, in pixels.\n    :param rank: What pixel value to pick.  Use 0 for a min filter,\n                 ``size * size / 2`` for a median filter, ``size * size - 1``\n                 for a max filter, etc.\n    \"\"\"\n\n    name = \"Rank\"\n\n    def __init__(self, size: int, rank: int) -> None:\n        self.size = size\n        self.rank = rank\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        if image.mode == \"P\":\n            msg = \"cannot filter palette images\"\n            raise ValueError(msg)\n        image = image.expand(self.size // 2, self.size // 2)\n        return image.rankfilter(self.size, self.rank)\n\n\nclass MedianFilter(RankFilter):\n    \"\"\"\n    Create a median filter. Picks the median pixel value in a window with the\n    given size.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Median\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n        self.rank = size * size // 2\n\n\nclass MinFilter(RankFilter):\n    \"\"\"\n    Create a min filter.  Picks the lowest pixel value in a window with the\n    given size.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Min\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n        self.rank = 0\n\n\nclass MaxFilter(RankFilter):\n    \"\"\"\n    Create a max filter.  Picks the largest pixel value in a window with the\n    given size.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Max\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n        self.rank = size * size - 1\n\n\nclass ModeFilter(Filter):\n    \"\"\"\n    Create a mode filter. Picks the most frequent pixel value in a box with the\n    given size.  Pixel values that occur only once or twice are ignored; if no\n    pixel value occurs more than twice, the original pixel value is preserved.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Mode\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        return image.modefilter(self.size)\n\n\nclass GaussianBlur(MultibandFilter):\n    \"\"\"Blurs the image with a sequence of extended box filters, which\n    approximates a Gaussian kernel. For details on accuracy see\n    <https://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf>\n\n    :param radius: Standard deviation of the Gaussian kernel. Either a sequence of two\n                   numbers for x and y, or a single number for both.\n    \"\"\"\n\n    name = \"GaussianBlur\"\n\n    def __init__(self, radius: float | Sequence[float] = 2) -> None:\n        self.radius = radius\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        xy = self.radius\n        if isinstance(xy, (int, float)):\n            xy = (xy, xy)\n        if xy == (0, 0):\n            return image.copy()\n        return image.gaussian_blur(xy)\n\n\nclass BoxBlur(MultibandFilter):\n    \"\"\"Blurs the image by setting each pixel to the average value of the pixels\n    in a square box extending radius pixels in each direction.\n    Supports float radius of arbitrary size. Uses an optimized implementation\n    which runs in linear time relative to the size of the image\n    for any radius value.\n\n    :param radius: Size of the box in a direction. Either a sequence of two numbers for\n                   x and y, or a single number for both.\n\n                   Radius 0 does not blur, returns an identical image.\n                   Radius 1 takes 1 pixel in each direction, i.e. 9 pixels in total.\n    \"\"\"\n\n    name = \"BoxBlur\"\n\n    def __init__(self, radius: float | Sequence[float]) -> None:\n        xy = radius if isinstance(radius, (tuple, list)) else (radius, radius)\n        if xy[0] < 0 or xy[1] < 0:\n            msg = \"radius must be >= 0\"\n            raise ValueError(msg)\n        self.radius = radius\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        xy = self.radius\n        if isinstance(xy, (int, float)):\n            xy = (xy, xy)\n        if xy == (0, 0):\n            return image.copy()\n        return image.box_blur(xy)\n\n\nclass UnsharpMask(MultibandFilter):\n    \"\"\"Unsharp mask filter.\n\n    See Wikipedia's entry on `digital unsharp masking`_ for an explanation of\n    the parameters.\n\n    :param radius: Blur Radius\n    :param percent: Unsharp strength, in percent\n    :param threshold: Threshold controls the minimum brightness change that\n      will be sharpened\n\n    .. _digital unsharp masking: https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking\n\n    \"\"\"\n\n    name = \"UnsharpMask\"\n\n    def __init__(\n        self, radius: float = 2, percent: int = 150, threshold: int = 3\n    ) -> None:\n        self.radius = radius\n        self.percent = percent\n        self.threshold = threshold\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        return image.unsharp_mask(self.radius, self.percent, self.threshold)\n\n\nclass BLUR(BuiltinFilter):\n    name = \"Blur\"\n    # fmt: off\n    filterargs = (5, 5), 16, 0, (\n        1, 1, 1, 1, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 1, 1, 1, 1,\n    )\n    # fmt: on\n\n\nclass CONTOUR(BuiltinFilter):\n    name = \"Contour\"\n    # fmt: off\n    filterargs = (3, 3), 1, 255, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass DETAIL(BuiltinFilter):\n    name = \"Detail\"\n    # fmt: off\n    filterargs = (3, 3), 6, 0, (\n        0,  -1,  0,\n        -1, 10, -1,\n        0,  -1,  0,\n    )\n    # fmt: on\n\n\nclass EDGE_ENHANCE(BuiltinFilter):\n    name = \"Edge-enhance\"\n    # fmt: off\n    filterargs = (3, 3), 2, 0, (\n        -1, -1, -1,\n        -1, 10, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass EDGE_ENHANCE_MORE(BuiltinFilter):\n    name = \"Edge-enhance More\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  9, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass EMBOSS(BuiltinFilter):\n    name = \"Emboss\"\n    # fmt: off\n    filterargs = (3, 3), 1, 128, (\n        -1, 0, 0,\n        0,  1, 0,\n        0,  0, 0,\n    )\n    # fmt: on\n\n\nclass FIND_EDGES(BuiltinFilter):\n    name = \"Find Edges\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass SHARPEN(BuiltinFilter):\n    name = \"Sharpen\"\n    # fmt: off\n    filterargs = (3, 3), 16, 0, (\n        -2, -2, -2,\n        -2, 32, -2,\n        -2, -2, -2,\n    )\n    # fmt: on\n\n\nclass SMOOTH(BuiltinFilter):\n    name = \"Smooth\"\n    # fmt: off\n    filterargs = (3, 3), 13, 0, (\n        1, 1, 1,\n        1, 5, 1,\n        1, 1, 1,\n    )\n    # fmt: on\n\n\nclass SMOOTH_MORE(BuiltinFilter):\n    name = \"Smooth More\"\n    # fmt: off\n    filterargs = (5, 5), 100, 0, (\n        1, 1,  1, 1, 1,\n        1, 5,  5, 5, 1,\n        1, 5, 44, 5, 1,\n        1, 5,  5, 5, 1,\n        1, 1,  1, 1, 1,\n    )\n    # fmt: on\n\n\nclass Color3DLUT(MultibandFilter):\n    \"\"\"Three-dimensional color lookup table.\n\n    Transforms 3-channel pixels using the values of the channels as coordinates\n    in the 3D lookup table and interpolating the nearest elements.\n\n    This method allows you to apply almost any color transformation\n    in constant time by using pre-calculated decimated tables.\n\n    .. versionadded:: 5.2.0\n\n    :param size: Size of the table. One int or tuple of (int, int, int).\n                 Minimal size in any dimension is 2, maximum is 65.\n    :param table: Flat lookup table. A list of ``channels * size**3``\n                  float elements or a list of ``size**3`` channels-sized\n                  tuples with floats. Channels are changed first,\n                  then first dimension, then second, then third.\n                  Value 0.0 corresponds lowest value of output, 1.0 highest.\n    :param channels: Number of channels in the table. Could be 3 or 4.\n                     Default is 3.\n    :param target_mode: A mode for the result image. Should have not less\n                        than ``channels`` channels. Default is ``None``,\n                        which means that mode wouldn't be changed.\n    \"\"\"\n\n    name = \"Color 3D LUT\"\n\n    def __init__(\n        self,\n        size: int | tuple[int, int, int],\n        table: Sequence[float] | Sequence[Sequence[int]] | NumpyArray,\n        channels: int = 3,\n        target_mode: str | None = None,\n        **kwargs: bool,\n    ) -> None:\n        if channels not in (3, 4):\n            msg = \"Only 3 or 4 output channels are supported\"\n            raise ValueError(msg)\n        self.size = size = self._check_size(size)\n        self.channels = channels\n        self.mode = target_mode\n\n        # Hidden flag `_copy_table=False` could be used to avoid extra copying\n        # of the table if the table is specially made for the constructor.\n        copy_table = kwargs.get(\"_copy_table\", True)\n        items = size[0] * size[1] * size[2]\n        wrong_size = False\n\n        numpy: ModuleType | None = None\n        if hasattr(table, \"shape\"):\n            try:\n                import numpy\n            except ImportError:\n                pass\n\n        if numpy and isinstance(table, numpy.ndarray):\n            numpy_table: NumpyArray = table\n            if copy_table:\n                numpy_table = numpy_table.copy()\n\n            if numpy_table.shape in [\n                (items * channels,),\n                (items, channels),\n                (size[2], size[1], size[0], channels),\n            ]:\n                table = numpy_table.reshape(items * channels)\n            else:\n                wrong_size = True\n\n        else:\n            if copy_table:\n                table = list(table)\n\n            # Convert to a flat list\n            if table and isinstance(table[0], (list, tuple)):\n                raw_table = cast(Sequence[Sequence[int]], table)\n                flat_table: list[int] = []\n                for pixel in raw_table:\n                    if len(pixel) != channels:\n                        msg = (\n                            \"The elements of the table should \"\n                            f\"have a length of {channels}.\"\n                        )\n                        raise ValueError(msg)\n                    flat_table.extend(pixel)\n                table = flat_table\n\n        if wrong_size or len(table) != items * channels:\n            msg = (\n                \"The table should have either channels * size**3 float items \"\n                \"or size**3 items of channels-sized tuples with floats. \"\n                f\"Table should be: {channels}x{size[0]}x{size[1]}x{size[2]}. \"\n                f\"Actual length: {len(table)}\"\n            )\n            raise ValueError(msg)\n        self.table = table\n\n    @staticmethod\n    def _check_size(size: Any) -> tuple[int, int, int]:\n        try:\n            _, _, _ = size\n        except ValueError as e:\n            msg = \"Size should be either an integer or a tuple of three integers.\"\n            raise ValueError(msg) from e\n        except TypeError:\n            size = (size, size, size)\n        size = tuple(int(x) for x in size)\n        for size_1d in size:\n            if not 2 <= size_1d <= 65:\n                msg = \"Size should be in [2, 65] range.\"\n                raise ValueError(msg)\n        return size\n\n    @classmethod\n    def generate(\n        cls,\n        size: int | tuple[int, int, int],\n        callback: Callable[[float, float, float], tuple[float, ...]],\n        channels: int = 3,\n        target_mode: str | None = None,\n    ) -> Color3DLUT:\n        \"\"\"Generates new LUT using provided callback.\n\n        :param size: Size of the table. Passed to the constructor.\n        :param callback: Function with three parameters which correspond\n                         three color channels. Will be called ``size**3``\n                         times with values from 0.0 to 1.0 and should return\n                         a tuple with ``channels`` elements.\n        :param channels: The number of channels which should return callback.\n        :param target_mode: Passed to the constructor of the resulting\n                            lookup table.\n        \"\"\"\n        size_1d, size_2d, size_3d = cls._check_size(size)\n        if channels not in (3, 4):\n            msg = \"Only 3 or 4 output channels are supported\"\n            raise ValueError(msg)\n\n        table: list[float] = [0] * (size_1d * size_2d * size_3d * channels)\n        idx_out = 0\n        for b in range(size_3d):\n            for g in range(size_2d):\n                for r in range(size_1d):\n                    table[idx_out : idx_out + channels] = callback(\n                        r / (size_1d - 1), g / (size_2d - 1), b / (size_3d - 1)\n                    )\n                    idx_out += channels\n\n        return cls(\n            (size_1d, size_2d, size_3d),\n            table,\n            channels=channels,\n            target_mode=target_mode,\n            _copy_table=False,\n        )\n\n    def transform(\n        self,\n        callback: Callable[..., tuple[float, ...]],\n        with_normals: bool = False,\n        channels: int | None = None,\n        target_mode: str | None = None,\n    ) -> Color3DLUT:\n        \"\"\"Transforms the table values using provided callback and returns\n        a new LUT with altered values.\n\n        :param callback: A function which takes old lookup table values\n                         and returns a new set of values. The number\n                         of arguments which function should take is\n                         ``self.channels`` or ``3 + self.channels``\n                         if ``with_normals`` flag is set.\n                         Should return a tuple of ``self.channels`` or\n                         ``channels`` elements if it is set.\n        :param with_normals: If true, ``callback`` will be called with\n                             coordinates in the color cube as the first\n                             three arguments. Otherwise, ``callback``\n                             will be called only with actual color values.\n        :param channels: The number of channels in the resulting lookup table.\n        :param target_mode: Passed to the constructor of the resulting\n                            lookup table.\n        \"\"\"\n        if channels not in (None, 3, 4):\n            msg = \"Only 3 or 4 output channels are supported\"\n            raise ValueError(msg)\n        ch_in = self.channels\n        ch_out = channels or ch_in\n        size_1d, size_2d, size_3d = self.size\n\n        table = [0] * (size_1d * size_2d * size_3d * ch_out)\n        idx_in = 0\n        idx_out = 0\n        for b in range(size_3d):\n            for g in range(size_2d):\n                for r in range(size_1d):\n                    values = self.table[idx_in : idx_in + ch_in]\n                    if with_normals:\n                        values = callback(\n                            r / (size_1d - 1),\n                            g / (size_2d - 1),\n                            b / (size_3d - 1),\n                            *values,\n                        )\n                    else:\n                        values = callback(*values)\n                    table[idx_out : idx_out + ch_out] = values\n                    idx_in += ch_in\n                    idx_out += ch_out\n\n        return type(self)(\n            self.size,\n            table,\n            channels=ch_out,\n            target_mode=target_mode or self.mode,\n            _copy_table=False,\n        )\n\n    def __repr__(self) -> str:\n        r = [\n            f\"{self.__class__.__name__} from {self.table.__class__.__name__}\",\n            \"size={:d}x{:d}x{:d}\".format(*self.size),\n            f\"channels={self.channels:d}\",\n        ]\n        if self.mode:\n            r.append(f\"target_mode={self.mode}\")\n        return \"<{}>\".format(\" \".join(r))\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        from . import Image\n\n        return image.color_lut_3d(\n            self.mode or image.mode,\n            Image.Resampling.BILINEAR,\n            self.channels,\n            self.size[0],\n            self.size[1],\n            self.size[2],\n            self.table,\n        )\n", "src/PIL/PdfImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PDF (Acrobat) file handling\n#\n# History:\n# 1996-07-16 fl   Created\n# 1997-01-18 fl   Fixed header\n# 2004-02-21 fl   Fixes for 1/L/CMYK images, etc.\n# 2004-02-24 fl   Fixes for 1 and P images.\n#\n# Copyright (c) 1997-2004 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1996-1997 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n##\n# Image plugin for PDF images (output only).\n##\nfrom __future__ import annotations\n\nimport io\nimport math\nimport os\nimport time\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImageSequence, PdfParser, __version__, features\n\n#\n# --------------------------------------------------------------------\n\n# object ids:\n#  1. catalogue\n#  2. pages\n#  3. image\n#  4. page\n#  5. page contents\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, save_all=True)\n\n\n##\n# (Internal) Image save plugin for the PDF format.\n\n\ndef _write_image(im, filename, existing_pdf, image_refs):\n    # FIXME: Should replace ASCIIHexDecode with RunLengthDecode\n    # (packbits) or LZWDecode (tiff/lzw compression).  Note that\n    # PDF 1.2 also supports Flatedecode (zip compression).\n\n    params = None\n    decode = None\n\n    #\n    # Get image characteristics\n\n    width, height = im.size\n\n    dict_obj = {\"BitsPerComponent\": 8}\n    if im.mode == \"1\":\n        if features.check(\"libtiff\"):\n            filter = \"CCITTFaxDecode\"\n            dict_obj[\"BitsPerComponent\"] = 1\n            params = PdfParser.PdfArray(\n                [\n                    PdfParser.PdfDict(\n                        {\n                            \"K\": -1,\n                            \"BlackIs1\": True,\n                            \"Columns\": width,\n                            \"Rows\": height,\n                        }\n                    )\n                ]\n            )\n        else:\n            filter = \"DCTDecode\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceGray\")\n        procset = \"ImageB\"  # grayscale\n    elif im.mode == \"L\":\n        filter = \"DCTDecode\"\n        # params = f\"<< /Predictor 15 /Columns {width-2} >>\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceGray\")\n        procset = \"ImageB\"  # grayscale\n    elif im.mode == \"LA\":\n        filter = \"JPXDecode\"\n        # params = f\"<< /Predictor 15 /Columns {width-2} >>\"\n        procset = \"ImageB\"  # grayscale\n        dict_obj[\"SMaskInData\"] = 1\n    elif im.mode == \"P\":\n        filter = \"ASCIIHexDecode\"\n        palette = im.getpalette()\n        dict_obj[\"ColorSpace\"] = [\n            PdfParser.PdfName(\"Indexed\"),\n            PdfParser.PdfName(\"DeviceRGB\"),\n            len(palette) // 3 - 1,\n            PdfParser.PdfBinary(palette),\n        ]\n        procset = \"ImageI\"  # indexed color\n\n        if \"transparency\" in im.info:\n            smask = im.convert(\"LA\").getchannel(\"A\")\n            smask.encoderinfo = {}\n\n            image_ref = _write_image(smask, filename, existing_pdf, image_refs)[0]\n            dict_obj[\"SMask\"] = image_ref\n    elif im.mode == \"RGB\":\n        filter = \"DCTDecode\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceRGB\")\n        procset = \"ImageC\"  # color images\n    elif im.mode == \"RGBA\":\n        filter = \"JPXDecode\"\n        procset = \"ImageC\"  # color images\n        dict_obj[\"SMaskInData\"] = 1\n    elif im.mode == \"CMYK\":\n        filter = \"DCTDecode\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceCMYK\")\n        procset = \"ImageC\"  # color images\n        decode = [1, 0, 1, 0, 1, 0, 1, 0]\n    else:\n        msg = f\"cannot save mode {im.mode}\"\n        raise ValueError(msg)\n\n    #\n    # image\n\n    op = io.BytesIO()\n\n    if filter == \"ASCIIHexDecode\":\n        ImageFile._save(im, op, [(\"hex\", (0, 0) + im.size, 0, im.mode)])\n    elif filter == \"CCITTFaxDecode\":\n        im.save(\n            op,\n            \"TIFF\",\n            compression=\"group4\",\n            # use a single strip\n            strip_size=math.ceil(width / 8) * height,\n        )\n    elif filter == \"DCTDecode\":\n        Image.SAVE[\"JPEG\"](im, op, filename)\n    elif filter == \"JPXDecode\":\n        del dict_obj[\"BitsPerComponent\"]\n        Image.SAVE[\"JPEG2000\"](im, op, filename)\n    else:\n        msg = f\"unsupported PDF filter ({filter})\"\n        raise ValueError(msg)\n\n    stream = op.getvalue()\n    if filter == \"CCITTFaxDecode\":\n        stream = stream[8:]\n        filter = PdfParser.PdfArray([PdfParser.PdfName(filter)])\n    else:\n        filter = PdfParser.PdfName(filter)\n\n    image_ref = image_refs.pop(0)\n    existing_pdf.write_obj(\n        image_ref,\n        stream=stream,\n        Type=PdfParser.PdfName(\"XObject\"),\n        Subtype=PdfParser.PdfName(\"Image\"),\n        Width=width,  # * 72.0 / x_resolution,\n        Height=height,  # * 72.0 / y_resolution,\n        Filter=filter,\n        Decode=decode,\n        DecodeParms=params,\n        **dict_obj,\n    )\n\n    return image_ref, procset\n\n\ndef _save(im, fp, filename, save_all=False):\n    is_appending = im.encoderinfo.get(\"append\", False)\n    if is_appending:\n        existing_pdf = PdfParser.PdfParser(f=fp, filename=filename, mode=\"r+b\")\n    else:\n        existing_pdf = PdfParser.PdfParser(f=fp, filename=filename, mode=\"w+b\")\n\n    dpi = im.encoderinfo.get(\"dpi\")\n    if dpi:\n        x_resolution = dpi[0]\n        y_resolution = dpi[1]\n    else:\n        x_resolution = y_resolution = im.encoderinfo.get(\"resolution\", 72.0)\n\n    info = {\n        \"title\": (\n            None if is_appending else os.path.splitext(os.path.basename(filename))[0]\n        ),\n        \"author\": None,\n        \"subject\": None,\n        \"keywords\": None,\n        \"creator\": None,\n        \"producer\": None,\n        \"creationDate\": None if is_appending else time.gmtime(),\n        \"modDate\": None if is_appending else time.gmtime(),\n    }\n    for k, default in info.items():\n        v = im.encoderinfo.get(k) if k in im.encoderinfo else default\n        if v:\n            existing_pdf.info[k[0].upper() + k[1:]] = v\n\n    #\n    # make sure image data is available\n    im.load()\n\n    existing_pdf.start_writing()\n    existing_pdf.write_header()\n    existing_pdf.write_comment(f\"created by Pillow {__version__} PDF driver\")\n\n    #\n    # pages\n    ims = [im]\n    if save_all:\n        append_images = im.encoderinfo.get(\"append_images\", [])\n        for append_im in append_images:\n            append_im.encoderinfo = im.encoderinfo.copy()\n            ims.append(append_im)\n    number_of_pages = 0\n    image_refs = []\n    page_refs = []\n    contents_refs = []\n    for im in ims:\n        im_number_of_pages = 1\n        if save_all:\n            try:\n                im_number_of_pages = im.n_frames\n            except AttributeError:\n                # Image format does not have n_frames.\n                # It is a single frame image\n                pass\n        number_of_pages += im_number_of_pages\n        for i in range(im_number_of_pages):\n            image_refs.append(existing_pdf.next_object_id(0))\n            if im.mode == \"P\" and \"transparency\" in im.info:\n                image_refs.append(existing_pdf.next_object_id(0))\n\n            page_refs.append(existing_pdf.next_object_id(0))\n            contents_refs.append(existing_pdf.next_object_id(0))\n            existing_pdf.pages.append(page_refs[-1])\n\n    #\n    # catalog and list of pages\n    existing_pdf.write_catalog()\n\n    page_number = 0\n    for im_sequence in ims:\n        im_pages = ImageSequence.Iterator(im_sequence) if save_all else [im_sequence]\n        for im in im_pages:\n            image_ref, procset = _write_image(im, filename, existing_pdf, image_refs)\n\n            #\n            # page\n\n            existing_pdf.write_page(\n                page_refs[page_number],\n                Resources=PdfParser.PdfDict(\n                    ProcSet=[PdfParser.PdfName(\"PDF\"), PdfParser.PdfName(procset)],\n                    XObject=PdfParser.PdfDict(image=image_ref),\n                ),\n                MediaBox=[\n                    0,\n                    0,\n                    im.width * 72.0 / x_resolution,\n                    im.height * 72.0 / y_resolution,\n                ],\n                Contents=contents_refs[page_number],\n            )\n\n            #\n            # page contents\n\n            page_contents = b\"q %f 0 0 %f 0 0 cm /image Do Q\\n\" % (\n                im.width * 72.0 / x_resolution,\n                im.height * 72.0 / y_resolution,\n            )\n\n            existing_pdf.write_obj(contents_refs[page_number], stream=page_contents)\n\n            page_number += 1\n\n    #\n    # trailer\n    existing_pdf.write_xref_and_trailer()\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n    existing_pdf.close()\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_save(\"PDF\", _save)\nImage.register_save_all(\"PDF\", _save_all)\n\nImage.register_extension(\"PDF\", \".pdf\")\n\nImage.register_mime(\"PDF\", \"application/pdf\")\n", "src/PIL/ImagePath.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# path interface\n#\n# History:\n# 1996-11-04 fl   Created\n# 2002-04-14 fl   Added documentation stub class\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image\n\nPath = Image.core.path\n", "src/PIL/ImageTk.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a Tk display interface\n#\n# History:\n# 96-04-08 fl   Created\n# 96-09-06 fl   Added getimage method\n# 96-11-01 fl   Rewritten, removed image attribute and crop method\n# 97-05-09 fl   Use PyImagingPaste method instead of image type\n# 97-05-12 fl   Minor tweaks to match the IFUNC95 interface\n# 97-05-17 fl   Support the \"pilbitmap\" booster patch\n# 97-06-05 fl   Added file= and data= argument to image constructors\n# 98-03-09 fl   Added width and height methods to Image classes\n# 98-07-02 fl   Use default mode for \"P\" images without palette attribute\n# 98-07-02 fl   Explicitly destroy Tkinter image objects\n# 99-07-24 fl   Support multiple Tk interpreters (from Greg Couch)\n# 99-07-26 fl   Automatically hook into Tkinter (if possible)\n# 99-08-15 fl   Hook uses _imagingtk instead of _imaging\n#\n# Copyright (c) 1997-1999 by Secret Labs AB\n# Copyright (c) 1996-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport tkinter\nfrom io import BytesIO\n\nfrom . import Image\n\n# --------------------------------------------------------------------\n# Check for Tkinter interface hooks\n\n_pilbitmap_ok = None\n\n\ndef _pilbitmap_check() -> int:\n    global _pilbitmap_ok\n    if _pilbitmap_ok is None:\n        try:\n            im = Image.new(\"1\", (1, 1))\n            tkinter.BitmapImage(data=f\"PIL:{im.im.id}\")\n            _pilbitmap_ok = 1\n        except tkinter.TclError:\n            _pilbitmap_ok = 0\n    return _pilbitmap_ok\n\n\ndef _get_image_from_kw(kw):\n    source = None\n    if \"file\" in kw:\n        source = kw.pop(\"file\")\n    elif \"data\" in kw:\n        source = BytesIO(kw.pop(\"data\"))\n    if source:\n        return Image.open(source)\n\n\ndef _pyimagingtkcall(command, photo, id):\n    tk = photo.tk\n    try:\n        tk.call(command, photo, id)\n    except tkinter.TclError:\n        # activate Tkinter hook\n        # may raise an error if it cannot attach to Tkinter\n        from . import _imagingtk\n\n        _imagingtk.tkinit(tk.interpaddr())\n        tk.call(command, photo, id)\n\n\n# --------------------------------------------------------------------\n# PhotoImage\n\n\nclass PhotoImage:\n    \"\"\"\n    A Tkinter-compatible photo image.  This can be used\n    everywhere Tkinter expects an image object.  If the image is an RGBA\n    image, pixels having alpha 0 are treated as transparent.\n\n    The constructor takes either a PIL image, or a mode and a size.\n    Alternatively, you can use the ``file`` or ``data`` options to initialize\n    the photo image object.\n\n    :param image: Either a PIL image, or a mode string.  If a mode string is\n                  used, a size must also be given.\n    :param size: If the first argument is a mode string, this defines the size\n                 of the image.\n    :keyword file: A filename to load the image from (using\n                   ``Image.open(file)``).\n    :keyword data: An 8-bit string containing image data (as loaded from an\n                   image file).\n    \"\"\"\n\n    def __init__(self, image=None, size=None, **kw):\n        # Tk compatibility: file or data\n        if image is None:\n            image = _get_image_from_kw(kw)\n\n        if hasattr(image, \"mode\") and hasattr(image, \"size\"):\n            # got an image instead of a mode\n            mode = image.mode\n            if mode == \"P\":\n                # palette mapped data\n                image.apply_transparency()\n                image.load()\n                try:\n                    mode = image.palette.mode\n                except AttributeError:\n                    mode = \"RGB\"  # default\n            size = image.size\n            kw[\"width\"], kw[\"height\"] = size\n        else:\n            mode = image\n            image = None\n\n        if mode not in [\"1\", \"L\", \"RGB\", \"RGBA\"]:\n            mode = Image.getmodebase(mode)\n\n        self.__mode = mode\n        self.__size = size\n        self.__photo = tkinter.PhotoImage(**kw)\n        self.tk = self.__photo.tk\n        if image:\n            self.paste(image)\n\n    def __del__(self) -> None:\n        name = self.__photo.name\n        self.__photo.name = None\n        try:\n            self.__photo.tk.call(\"image\", \"delete\", name)\n        except Exception:\n            pass  # ignore internal errors\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get the Tkinter photo image identifier.  This method is automatically\n        called by Tkinter whenever a PhotoImage object is passed to a Tkinter\n        method.\n\n        :return: A Tkinter photo image identifier (a string).\n        \"\"\"\n        return str(self.__photo)\n\n    def width(self) -> int:\n        \"\"\"\n        Get the width of the image.\n\n        :return: The width, in pixels.\n        \"\"\"\n        return self.__size[0]\n\n    def height(self) -> int:\n        \"\"\"\n        Get the height of the image.\n\n        :return: The height, in pixels.\n        \"\"\"\n        return self.__size[1]\n\n    def paste(self, im: Image.Image) -> None:\n        \"\"\"\n        Paste a PIL image into the photo image.  Note that this can\n        be very slow if the photo image is displayed.\n\n        :param im: A PIL image. The size must match the target region.  If the\n                   mode does not match, the image is converted to the mode of\n                   the bitmap image.\n        \"\"\"\n        # convert to blittable\n        im.load()\n        image = im.im\n        if image.isblock() and im.mode == self.__mode:\n            block = image\n        else:\n            block = image.new_block(self.__mode, im.size)\n            image.convert2(block, image)  # convert directly between buffers\n\n        _pyimagingtkcall(\"PyImagingPhoto\", self.__photo, block.id)\n\n\n# --------------------------------------------------------------------\n# BitmapImage\n\n\nclass BitmapImage:\n    \"\"\"\n    A Tkinter-compatible bitmap image.  This can be used everywhere Tkinter\n    expects an image object.\n\n    The given image must have mode \"1\".  Pixels having value 0 are treated as\n    transparent.  Options, if any, are passed on to Tkinter.  The most commonly\n    used option is ``foreground``, which is used to specify the color for the\n    non-transparent parts.  See the Tkinter documentation for information on\n    how to specify colours.\n\n    :param image: A PIL image.\n    \"\"\"\n\n    def __init__(self, image=None, **kw):\n        # Tk compatibility: file or data\n        if image is None:\n            image = _get_image_from_kw(kw)\n\n        self.__mode = image.mode\n        self.__size = image.size\n\n        if _pilbitmap_check():\n            # fast way (requires the pilbitmap booster patch)\n            image.load()\n            kw[\"data\"] = f\"PIL:{image.im.id}\"\n            self.__im = image  # must keep a reference\n        else:\n            # slow but safe way\n            kw[\"data\"] = image.tobitmap()\n        self.__photo = tkinter.BitmapImage(**kw)\n\n    def __del__(self) -> None:\n        name = self.__photo.name\n        self.__photo.name = None\n        try:\n            self.__photo.tk.call(\"image\", \"delete\", name)\n        except Exception:\n            pass  # ignore internal errors\n\n    def width(self) -> int:\n        \"\"\"\n        Get the width of the image.\n\n        :return: The width, in pixels.\n        \"\"\"\n        return self.__size[0]\n\n    def height(self) -> int:\n        \"\"\"\n        Get the height of the image.\n\n        :return: The height, in pixels.\n        \"\"\"\n        return self.__size[1]\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get the Tkinter bitmap image identifier.  This method is automatically\n        called by Tkinter whenever a BitmapImage object is passed to a Tkinter\n        method.\n\n        :return: A Tkinter bitmap image identifier (a string).\n        \"\"\"\n        return str(self.__photo)\n\n\ndef getimage(photo: PhotoImage) -> Image.Image:\n    \"\"\"Copies the contents of a PhotoImage to a PIL image memory.\"\"\"\n    im = Image.new(\"RGBA\", (photo.width(), photo.height()))\n    block = im.im\n\n    _pyimagingtkcall(\"PyImagingPhotoGet\", photo, block.id)\n\n    return im\n\n\ndef _show(image, title):\n    \"\"\"Helper for the Image.show method.\"\"\"\n\n    class UI(tkinter.Label):\n        def __init__(self, master, im):\n            if im.mode == \"1\":\n                self.image = BitmapImage(im, foreground=\"white\", master=master)\n            else:\n                self.image = PhotoImage(im, master=master)\n            super().__init__(master, image=self.image, bg=\"black\", bd=0)\n\n    if not tkinter._default_root:\n        msg = \"tkinter not initialized\"\n        raise OSError(msg)\n    top = tkinter.Toplevel()\n    if title:\n        top.title(title)\n    UI(top, image).pack()\n", "src/PIL/ImtImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# IM Tools support for PIL\n#\n# history:\n# 1996-05-27 fl   Created (read 8-bit images only)\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.2)\n#\n# Copyright (c) Secret Labs AB 1997-2001.\n# Copyright (c) Fredrik Lundh 1996-2001.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\n\nfrom . import Image, ImageFile\n\n#\n# --------------------------------------------------------------------\n\nfield = re.compile(rb\"([a-z]*) ([^ \\r\\n]*)\")\n\n\n##\n# Image plugin for IM Tools images.\n\n\nclass ImtImageFile(ImageFile.ImageFile):\n    format = \"IMT\"\n    format_description = \"IM Tools\"\n\n    def _open(self) -> None:\n        # Quick rejection: if there's not a LF among the first\n        # 100 bytes, this is (probably) not a text header.\n\n        assert self.fp is not None\n\n        buffer = self.fp.read(100)\n        if b\"\\n\" not in buffer:\n            msg = \"not an IM file\"\n            raise SyntaxError(msg)\n\n        xsize = ysize = 0\n\n        while True:\n            if buffer:\n                s = buffer[:1]\n                buffer = buffer[1:]\n            else:\n                s = self.fp.read(1)\n            if not s:\n                break\n\n            if s == b\"\\x0C\":\n                # image data begins\n                self.tile = [\n                    (\n                        \"raw\",\n                        (0, 0) + self.size,\n                        self.fp.tell() - len(buffer),\n                        (self.mode, 0, 1),\n                    )\n                ]\n\n                break\n\n            else:\n                # read key/value pair\n                if b\"\\n\" not in buffer:\n                    buffer += self.fp.read(100)\n                lines = buffer.split(b\"\\n\")\n                s += lines.pop(0)\n                buffer = b\"\\n\".join(lines)\n                if len(s) == 1 or len(s) > 100:\n                    break\n                if s[0] == ord(b\"*\"):\n                    continue  # comment\n\n                m = field.match(s)\n                if not m:\n                    break\n                k, v = m.group(1, 2)\n                if k == b\"width\":\n                    xsize = int(v)\n                    self._size = xsize, ysize\n                elif k == b\"height\":\n                    ysize = int(v)\n                    self._size = xsize, ysize\n                elif k == b\"pixel\" and v == b\"n8\":\n                    self._mode = \"L\"\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(ImtImageFile.format, ImtImageFile)\n\n#\n# no extension registered (\".im\" is simply too common)\n", "src/PIL/GdImageFile.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# GD file handling\n#\n# History:\n# 1996-04-12 fl   Created\n#\n# Copyright (c) 1997 by Secret Labs AB.\n# Copyright (c) 1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\n\"\"\"\n.. note::\n    This format cannot be automatically recognized, so the\n    class is not registered for use with :py:func:`PIL.Image.open()`.  To open a\n    gd file, use the :py:func:`PIL.GdImageFile.open()` function instead.\n\n.. warning::\n    THE GD FORMAT IS NOT DESIGNED FOR DATA INTERCHANGE.  This\n    implementation is provided for convenience and demonstrational\n    purposes only.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import ImageFile, ImagePalette, UnidentifiedImageError\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._typing import StrOrBytesPath\n\n\nclass GdImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Image plugin for the GD uncompressed format.  Note that this format\n    is not supported by the standard :py:func:`PIL.Image.open()` function.  To use\n    this plugin, you have to import the :py:mod:`PIL.GdImageFile` module and\n    use the :py:func:`PIL.GdImageFile.open()` function.\n    \"\"\"\n\n    format = \"GD\"\n    format_description = \"GD uncompressed images\"\n\n    def _open(self) -> None:\n        # Header\n        assert self.fp is not None\n\n        s = self.fp.read(1037)\n\n        if i16(s) not in [65534, 65535]:\n            msg = \"Not a valid GD 2.x .gd file\"\n            raise SyntaxError(msg)\n\n        self._mode = \"L\"  # FIXME: \"P\"\n        self._size = i16(s, 2), i16(s, 4)\n\n        true_color = s[6]\n        true_color_offset = 2 if true_color else 0\n\n        # transparency index\n        tindex = i32(s, 7 + true_color_offset)\n        if tindex < 256:\n            self.info[\"transparency\"] = tindex\n\n        self.palette = ImagePalette.raw(\n            \"XBGR\", s[7 + true_color_offset + 4 : 7 + true_color_offset + 4 + 256 * 4]\n        )\n\n        self.tile = [\n            (\n                \"raw\",\n                (0, 0) + self.size,\n                7 + true_color_offset + 4 + 256 * 4,\n                (\"L\", 0, 1),\n            )\n        ]\n\n\ndef open(fp: StrOrBytesPath | IO[bytes], mode: str = \"r\") -> GdImageFile:\n    \"\"\"\n    Load texture from a GD image file.\n\n    :param fp: GD file name, or an opened file handle.\n    :param mode: Optional mode.  In this version, if the mode argument\n        is given, it must be \"r\".\n    :returns: An image instance.\n    :raises OSError: If the image could not be read.\n    \"\"\"\n    if mode != \"r\":\n        msg = \"bad mode\"\n        raise ValueError(msg)\n\n    try:\n        return GdImageFile(fp)\n    except SyntaxError as e:\n        msg = \"cannot identify this image file\"\n        raise UnidentifiedImageError(msg) from e\n", "src/PIL/IcoImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Windows Icon support for PIL\n#\n# History:\n#       96-05-27 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\n\n# This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis\n# <casadebender@gmail.com>.\n# https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki\n#\n# Icon format references:\n#   * https://en.wikipedia.org/wiki/ICO_(file_format)\n#   * https://msdn.microsoft.com/en-us/library/ms997538.aspx\nfrom __future__ import annotations\n\nimport warnings\nfrom io import BytesIO\nfrom math import ceil, log\nfrom typing import IO\n\nfrom . import BmpImagePlugin, Image, ImageFile, PngImagePlugin\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\nfrom ._binary import o8\nfrom ._binary import o16le as o16\nfrom ._binary import o32le as o32\n\n#\n# --------------------------------------------------------------------\n\n_MAGIC = b\"\\0\\0\\1\\0\"\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    fp.write(_MAGIC)  # (2+2)\n    bmp = im.encoderinfo.get(\"bitmap_format\") == \"bmp\"\n    sizes = im.encoderinfo.get(\n        \"sizes\",\n        [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],\n    )\n    frames = []\n    provided_ims = [im] + im.encoderinfo.get(\"append_images\", [])\n    width, height = im.size\n    for size in sorted(set(sizes)):\n        if size[0] > width or size[1] > height or size[0] > 256 or size[1] > 256:\n            continue\n\n        for provided_im in provided_ims:\n            if provided_im.size != size:\n                continue\n            frames.append(provided_im)\n            if bmp:\n                bits = BmpImagePlugin.SAVE[provided_im.mode][1]\n                bits_used = [bits]\n                for other_im in provided_ims:\n                    if other_im.size != size:\n                        continue\n                    bits = BmpImagePlugin.SAVE[other_im.mode][1]\n                    if bits not in bits_used:\n                        # Another image has been supplied for this size\n                        # with a different bit depth\n                        frames.append(other_im)\n                        bits_used.append(bits)\n            break\n        else:\n            # TODO: invent a more convenient method for proportional scalings\n            frame = provided_im.copy()\n            frame.thumbnail(size, Image.Resampling.LANCZOS, reducing_gap=None)\n            frames.append(frame)\n    fp.write(o16(len(frames)))  # idCount(2)\n    offset = fp.tell() + len(frames) * 16\n    for frame in frames:\n        width, height = frame.size\n        # 0 means 256\n        fp.write(o8(width if width < 256 else 0))  # bWidth(1)\n        fp.write(o8(height if height < 256 else 0))  # bHeight(1)\n\n        bits, colors = BmpImagePlugin.SAVE[frame.mode][1:] if bmp else (32, 0)\n        fp.write(o8(colors))  # bColorCount(1)\n        fp.write(b\"\\0\")  # bReserved(1)\n        fp.write(b\"\\0\\0\")  # wPlanes(2)\n        fp.write(o16(bits))  # wBitCount(2)\n\n        image_io = BytesIO()\n        if bmp:\n            frame.save(image_io, \"dib\")\n\n            if bits != 32:\n                and_mask = Image.new(\"1\", size)\n                ImageFile._save(\n                    and_mask, image_io, [(\"raw\", (0, 0) + size, 0, (\"1\", 0, -1))]\n                )\n        else:\n            frame.save(image_io, \"png\")\n        image_io.seek(0)\n        image_bytes = image_io.read()\n        if bmp:\n            image_bytes = image_bytes[:8] + o32(height * 2) + image_bytes[12:]\n        bytes_len = len(image_bytes)\n        fp.write(o32(bytes_len))  # dwBytesInRes(4)\n        fp.write(o32(offset))  # dwImageOffset(4)\n        current = fp.tell()\n        fp.seek(offset)\n        fp.write(image_bytes)\n        offset = offset + bytes_len\n        fp.seek(current)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == _MAGIC\n\n\nclass IcoFile:\n    def __init__(self, buf):\n        \"\"\"\n        Parse image from file-like object containing ico file data\n        \"\"\"\n\n        # check magic\n        s = buf.read(6)\n        if not _accept(s):\n            msg = \"not an ICO file\"\n            raise SyntaxError(msg)\n\n        self.buf = buf\n        self.entry = []\n\n        # Number of items in file\n        self.nb_items = i16(s, 4)\n\n        # Get headers for each item\n        for i in range(self.nb_items):\n            s = buf.read(16)\n\n            icon_header = {\n                \"width\": s[0],\n                \"height\": s[1],\n                \"nb_color\": s[2],  # No. of colors in image (0 if >=8bpp)\n                \"reserved\": s[3],\n                \"planes\": i16(s, 4),\n                \"bpp\": i16(s, 6),\n                \"size\": i32(s, 8),\n                \"offset\": i32(s, 12),\n            }\n\n            # See Wikipedia\n            for j in (\"width\", \"height\"):\n                if not icon_header[j]:\n                    icon_header[j] = 256\n\n            # See Wikipedia notes about color depth.\n            # We need this just to differ images with equal sizes\n            icon_header[\"color_depth\"] = (\n                icon_header[\"bpp\"]\n                or (\n                    icon_header[\"nb_color\"] != 0\n                    and ceil(log(icon_header[\"nb_color\"], 2))\n                )\n                or 256\n            )\n\n            icon_header[\"dim\"] = (icon_header[\"width\"], icon_header[\"height\"])\n            icon_header[\"square\"] = icon_header[\"width\"] * icon_header[\"height\"]\n\n            self.entry.append(icon_header)\n\n        self.entry = sorted(self.entry, key=lambda x: x[\"color_depth\"])\n        # ICO images are usually squares\n        self.entry = sorted(self.entry, key=lambda x: x[\"square\"], reverse=True)\n\n    def sizes(self):\n        \"\"\"\n        Get a list of all available icon sizes and color depths.\n        \"\"\"\n        return {(h[\"width\"], h[\"height\"]) for h in self.entry}\n\n    def getentryindex(self, size, bpp=False):\n        for i, h in enumerate(self.entry):\n            if size == h[\"dim\"] and (bpp is False or bpp == h[\"color_depth\"]):\n                return i\n        return 0\n\n    def getimage(self, size, bpp=False):\n        \"\"\"\n        Get an image from the icon\n        \"\"\"\n        return self.frame(self.getentryindex(size, bpp))\n\n    def frame(self, idx: int) -> Image.Image:\n        \"\"\"\n        Get an image from frame idx\n        \"\"\"\n\n        header = self.entry[idx]\n\n        self.buf.seek(header[\"offset\"])\n        data = self.buf.read(8)\n        self.buf.seek(header[\"offset\"])\n\n        im: Image.Image\n        if data[:8] == PngImagePlugin._MAGIC:\n            # png frame\n            im = PngImagePlugin.PngImageFile(self.buf)\n            Image._decompression_bomb_check(im.size)\n        else:\n            # XOR + AND mask bmp frame\n            im = BmpImagePlugin.DibImageFile(self.buf)\n            Image._decompression_bomb_check(im.size)\n\n            # change tile dimension to only encompass XOR image\n            im._size = (im.size[0], int(im.size[1] / 2))\n            d, e, o, a = im.tile[0]\n            im.tile[0] = d, (0, 0) + im.size, o, a\n\n            # figure out where AND mask image starts\n            bpp = header[\"bpp\"]\n            if 32 == bpp:\n                # 32-bit color depth icon image allows semitransparent areas\n                # PIL's DIB format ignores transparency bits, recover them.\n                # The DIB is packed in BGRX byte order where X is the alpha\n                # channel.\n\n                # Back up to start of bmp data\n                self.buf.seek(o)\n                # extract every 4th byte (eg. 3,7,11,15,...)\n                alpha_bytes = self.buf.read(im.size[0] * im.size[1] * 4)[3::4]\n\n                # convert to an 8bpp grayscale image\n                mask = Image.frombuffer(\n                    \"L\",  # 8bpp\n                    im.size,  # (w, h)\n                    alpha_bytes,  # source chars\n                    \"raw\",  # raw decoder\n                    (\"L\", 0, -1),  # 8bpp inverted, unpadded, reversed\n                )\n            else:\n                # get AND image from end of bitmap\n                w = im.size[0]\n                if (w % 32) > 0:\n                    # bitmap row data is aligned to word boundaries\n                    w += 32 - (im.size[0] % 32)\n\n                # the total mask data is\n                # padded row size * height / bits per char\n\n                total_bytes = int((w * im.size[1]) / 8)\n                and_mask_offset = header[\"offset\"] + header[\"size\"] - total_bytes\n\n                self.buf.seek(and_mask_offset)\n                mask_data = self.buf.read(total_bytes)\n\n                # convert raw data to image\n                mask = Image.frombuffer(\n                    \"1\",  # 1 bpp\n                    im.size,  # (w, h)\n                    mask_data,  # source chars\n                    \"raw\",  # raw decoder\n                    (\"1;I\", int(w / 8), -1),  # 1bpp inverted, padded, reversed\n                )\n\n                # now we have two images, im is XOR image and mask is AND image\n\n            # apply mask image as alpha channel\n            im = im.convert(\"RGBA\")\n            im.putalpha(mask)\n\n        return im\n\n\n##\n# Image plugin for Windows Icon files.\n\n\nclass IcoImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL read-only image support for Microsoft Windows .ico files.\n\n    By default the largest resolution image in the file will be loaded. This\n    can be changed by altering the 'size' attribute before calling 'load'.\n\n    The info dictionary has a key 'sizes' that is a list of the sizes available\n    in the icon file.\n\n    Handles classic, XP and Vista icon formats.\n\n    When saving, PNG compression is used. Support for this was only added in\n    Windows Vista. If you are unable to view the icon in Windows, convert the\n    image to \"RGBA\" mode before saving.\n\n    This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis\n    <casadebender@gmail.com>.\n    https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki\n    \"\"\"\n\n    format = \"ICO\"\n    format_description = \"Windows Icon\"\n\n    def _open(self) -> None:\n        self.ico = IcoFile(self.fp)\n        self.info[\"sizes\"] = self.ico.sizes()\n        self.size = self.ico.entry[0][\"dim\"]\n        self.load()\n\n    @property\n    def size(self):\n        return self._size\n\n    @size.setter\n    def size(self, value):\n        if value not in self.info[\"sizes\"]:\n            msg = \"This is not one of the allowed sizes of this image\"\n            raise ValueError(msg)\n        self._size = value\n\n    def load(self):\n        if self.im is not None and self.im.size == self.size:\n            # Already loaded\n            return Image.Image.load(self)\n        im = self.ico.getimage(self.size)\n        # if tile is PNG, it won't really be loaded yet\n        im.load()\n        self.im = im.im\n        self.pyaccess = None\n        self._mode = im.mode\n        if im.palette:\n            self.palette = im.palette\n        if im.size != self.size:\n            warnings.warn(\"Image was not the expected size\")\n\n            index = self.ico.getentryindex(self.size)\n            sizes = list(self.info[\"sizes\"])\n            sizes[index] = im.size\n            self.info[\"sizes\"] = set(sizes)\n\n            self.size = im.size\n\n    def load_seek(self, pos: int) -> None:\n        # Flag the ImageFile.Parser so that it\n        # just does all the decode at the end.\n        pass\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_open(IcoImageFile.format, IcoImageFile, _accept)\nImage.register_save(IcoImageFile.format, _save)\nImage.register_extension(IcoImageFile.format, \".ico\")\n\nImage.register_mime(IcoImageFile.format, \"image/x-icon\")\n", "src/PIL/SunImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Sun image file handling\n#\n# History:\n# 1995-09-10 fl   Created\n# 1996-05-28 fl   Fixed 32-bit alignment\n# 1998-12-29 fl   Import ImagePalette module\n# 2001-12-18 fl   Fixed palette loading (from Jean-Claude Rimbault)\n#\n# Copyright (c) 1997-2001 by Secret Labs AB\n# Copyright (c) 1995-1996 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i32be as i32\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 4 and i32(prefix) == 0x59A66A95\n\n\n##\n# Image plugin for Sun raster files.\n\n\nclass SunImageFile(ImageFile.ImageFile):\n    format = \"SUN\"\n    format_description = \"Sun Raster File\"\n\n    def _open(self) -> None:\n        # The Sun Raster file header is 32 bytes in length\n        # and has the following format:\n\n        #     typedef struct _SunRaster\n        #     {\n        #         DWORD MagicNumber;      /* Magic (identification) number */\n        #         DWORD Width;            /* Width of image in pixels */\n        #         DWORD Height;           /* Height of image in pixels */\n        #         DWORD Depth;            /* Number of bits per pixel */\n        #         DWORD Length;           /* Size of image data in bytes */\n        #         DWORD Type;             /* Type of raster file */\n        #         DWORD ColorMapType;     /* Type of color map */\n        #         DWORD ColorMapLength;   /* Size of the color map in bytes */\n        #     } SUNRASTER;\n\n        assert self.fp is not None\n\n        # HEAD\n        s = self.fp.read(32)\n        if not _accept(s):\n            msg = \"not an SUN raster file\"\n            raise SyntaxError(msg)\n\n        offset = 32\n\n        self._size = i32(s, 4), i32(s, 8)\n\n        depth = i32(s, 12)\n        # data_length = i32(s, 16)   # unreliable, ignore.\n        file_type = i32(s, 20)\n        palette_type = i32(s, 24)  # 0: None, 1: RGB, 2: Raw/arbitrary\n        palette_length = i32(s, 28)\n\n        if depth == 1:\n            self._mode, rawmode = \"1\", \"1;I\"\n        elif depth == 4:\n            self._mode, rawmode = \"L\", \"L;4\"\n        elif depth == 8:\n            self._mode = rawmode = \"L\"\n        elif depth == 24:\n            if file_type == 3:\n                self._mode, rawmode = \"RGB\", \"RGB\"\n            else:\n                self._mode, rawmode = \"RGB\", \"BGR\"\n        elif depth == 32:\n            if file_type == 3:\n                self._mode, rawmode = \"RGB\", \"RGBX\"\n            else:\n                self._mode, rawmode = \"RGB\", \"BGRX\"\n        else:\n            msg = \"Unsupported Mode/Bit Depth\"\n            raise SyntaxError(msg)\n\n        if palette_length:\n            if palette_length > 1024:\n                msg = \"Unsupported Color Palette Length\"\n                raise SyntaxError(msg)\n\n            if palette_type != 1:\n                msg = \"Unsupported Palette Type\"\n                raise SyntaxError(msg)\n\n            offset = offset + palette_length\n            self.palette = ImagePalette.raw(\"RGB;L\", self.fp.read(palette_length))\n            if self.mode == \"L\":\n                self._mode = \"P\"\n                rawmode = rawmode.replace(\"L\", \"P\")\n\n        # 16 bit boundaries on stride\n        stride = ((self.size[0] * depth + 15) // 16) * 2\n\n        # file type: Type is the version (or flavor) of the bitmap\n        # file. The following values are typically found in the Type\n        # field:\n        # 0000h Old\n        # 0001h Standard\n        # 0002h Byte-encoded\n        # 0003h RGB format\n        # 0004h TIFF format\n        # 0005h IFF format\n        # FFFFh Experimental\n\n        # Old and standard are the same, except for the length tag.\n        # byte-encoded is run-length-encoded\n        # RGB looks similar to standard, but RGB byte order\n        # TIFF and IFF mean that they were converted from T/IFF\n        # Experimental means that it's something else.\n        # (https://www.fileformat.info/format/sunraster/egff.htm)\n\n        if file_type in (0, 1, 3, 4, 5):\n            self.tile = [(\"raw\", (0, 0) + self.size, offset, (rawmode, stride))]\n        elif file_type == 2:\n            self.tile = [(\"sun_rle\", (0, 0) + self.size, offset, rawmode)]\n        else:\n            msg = \"Unsupported Sun Raster file type\"\n            raise SyntaxError(msg)\n\n\n#\n# registry\n\n\nImage.register_open(SunImageFile.format, SunImageFile, _accept)\n\nImage.register_extension(SunImageFile.format, \".ras\")\n", "src/PIL/TiffImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# TIFF file handling\n#\n# TIFF is a flexible, if somewhat aged, image file format originally\n# defined by Aldus.  Although TIFF supports a wide variety of pixel\n# layouts and compression methods, the name doesn't really stand for\n# \"thousands of incompatible file formats,\" it just feels that way.\n#\n# To read TIFF data from a stream, the stream must be seekable.  For\n# progressive decoding, make sure to use TIFF files where the tag\n# directory is placed first in the file.\n#\n# History:\n# 1995-09-01 fl   Created\n# 1996-05-04 fl   Handle JPEGTABLES tag\n# 1996-05-18 fl   Fixed COLORMAP support\n# 1997-01-05 fl   Fixed PREDICTOR support\n# 1997-08-27 fl   Added support for rational tags (from Perry Stoll)\n# 1998-01-10 fl   Fixed seek/tell (from Jan Blom)\n# 1998-07-15 fl   Use private names for internal variables\n# 1999-06-13 fl   Rewritten for PIL 1.0 (1.0)\n# 2000-10-11 fl   Additional fixes for Python 2.0 (1.1)\n# 2001-04-17 fl   Fixed rewind support (seek to frame 0) (1.2)\n# 2001-05-12 fl   Added write support for more tags (from Greg Couch) (1.3)\n# 2001-12-18 fl   Added workaround for broken Matrox library\n# 2002-01-18 fl   Don't mess up if photometric tag is missing (D. Alan Stewart)\n# 2003-05-19 fl   Check FILLORDER tag\n# 2003-09-26 fl   Added RGBa support\n# 2004-02-24 fl   Added DPI support; fixed rational write support\n# 2005-02-07 fl   Added workaround for broken Corel Draw 10 files\n# 2006-01-09 fl   Added support for float/double tags (from Russell Nelson)\n#\n# Copyright (c) 1997-2006 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport itertools\nimport logging\nimport math\nimport os\nimport struct\nimport warnings\nfrom collections.abc import MutableMapping\nfrom fractions import Fraction\nfrom numbers import Number, Rational\nfrom typing import IO, TYPE_CHECKING, Any, Callable, NoReturn\n\nfrom . import ExifTags, Image, ImageFile, ImageOps, ImagePalette, TiffTags\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import o8\nfrom ._deprecate import deprecate\nfrom .TiffTags import TYPES\n\nlogger = logging.getLogger(__name__)\n\n# Set these to true to force use of libtiff for reading or writing.\nREAD_LIBTIFF = False\nWRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nSTRIP_SIZE = 65536\n\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n\n# a few tag names, just to make the code below a bit more readable\nOSUBFILETYPE = 255\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\n\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete\n    7: \"jpeg\",\n    8: \"tiff_adobe_deflate\",\n    32771: \"tiff_raw_16\",  # 16-bit padding\n    32773: \"packbits\",\n    32809: \"tiff_thunderscan\",\n    32946: \"tiff_deflate\",\n    34676: \"tiff_sgilog\",\n    34677: \"tiff_sgilog24\",\n    34925: \"lzma\",\n    50000: \"zstd\",\n    50001: \"webp\",\n}\n\nCOMPRESSION_INFO_REV = {v: k for k, v in COMPRESSION_INFO.items()}\n\nOPEN_INFO = {\n    # (ByteOrder, PhotoInterpretation, SampleFormat, FillOrder, BitsPerSample,\n    #  ExtraSamples) => mode, rawmode\n    (II, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (MM, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (II, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (MM, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (II, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (MM, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (II, 1, (1,), 2, (1,), ()): (\"1\", \"1;R\"),\n    (MM, 1, (1,), 2, (1,), ()): (\"1\", \"1;R\"),\n    (II, 0, (1,), 1, (2,), ()): (\"L\", \"L;2I\"),\n    (MM, 0, (1,), 1, (2,), ()): (\"L\", \"L;2I\"),\n    (II, 0, (1,), 2, (2,), ()): (\"L\", \"L;2IR\"),\n    (MM, 0, (1,), 2, (2,), ()): (\"L\", \"L;2IR\"),\n    (II, 1, (1,), 1, (2,), ()): (\"L\", \"L;2\"),\n    (MM, 1, (1,), 1, (2,), ()): (\"L\", \"L;2\"),\n    (II, 1, (1,), 2, (2,), ()): (\"L\", \"L;2R\"),\n    (MM, 1, (1,), 2, (2,), ()): (\"L\", \"L;2R\"),\n    (II, 0, (1,), 1, (4,), ()): (\"L\", \"L;4I\"),\n    (MM, 0, (1,), 1, (4,), ()): (\"L\", \"L;4I\"),\n    (II, 0, (1,), 2, (4,), ()): (\"L\", \"L;4IR\"),\n    (MM, 0, (1,), 2, (4,), ()): (\"L\", \"L;4IR\"),\n    (II, 1, (1,), 1, (4,), ()): (\"L\", \"L;4\"),\n    (MM, 1, (1,), 1, (4,), ()): (\"L\", \"L;4\"),\n    (II, 1, (1,), 2, (4,), ()): (\"L\", \"L;4R\"),\n    (MM, 1, (1,), 2, (4,), ()): (\"L\", \"L;4R\"),\n    (II, 0, (1,), 1, (8,), ()): (\"L\", \"L;I\"),\n    (MM, 0, (1,), 1, (8,), ()): (\"L\", \"L;I\"),\n    (II, 0, (1,), 2, (8,), ()): (\"L\", \"L;IR\"),\n    (MM, 0, (1,), 2, (8,), ()): (\"L\", \"L;IR\"),\n    (II, 1, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    (MM, 1, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    (II, 1, (2,), 1, (8,), ()): (\"L\", \"L\"),\n    (MM, 1, (2,), 1, (8,), ()): (\"L\", \"L\"),\n    (II, 1, (1,), 2, (8,), ()): (\"L\", \"L;R\"),\n    (MM, 1, (1,), 2, (8,), ()): (\"L\", \"L;R\"),\n    (II, 1, (1,), 1, (12,), ()): (\"I;16\", \"I;12\"),\n    (II, 0, (1,), 1, (16,), ()): (\"I;16\", \"I;16\"),\n    (II, 1, (1,), 1, (16,), ()): (\"I;16\", \"I;16\"),\n    (MM, 1, (1,), 1, (16,), ()): (\"I;16B\", \"I;16B\"),\n    (II, 1, (1,), 2, (16,), ()): (\"I;16\", \"I;16R\"),\n    (II, 1, (2,), 1, (16,), ()): (\"I\", \"I;16S\"),\n    (MM, 1, (2,), 1, (16,), ()): (\"I\", \"I;16BS\"),\n    (II, 0, (3,), 1, (32,), ()): (\"F\", \"F;32F\"),\n    (MM, 0, (3,), 1, (32,), ()): (\"F\", \"F;32BF\"),\n    (II, 1, (1,), 1, (32,), ()): (\"I\", \"I;32N\"),\n    (II, 1, (2,), 1, (32,), ()): (\"I\", \"I;32S\"),\n    (MM, 1, (2,), 1, (32,), ()): (\"I\", \"I;32BS\"),\n    (II, 1, (3,), 1, (32,), ()): (\"F\", \"F;32F\"),\n    (MM, 1, (3,), 1, (32,), ()): (\"F\", \"F;32BF\"),\n    (II, 1, (1,), 1, (8, 8), (2,)): (\"LA\", \"LA\"),\n    (MM, 1, (1,), 1, (8, 8), (2,)): (\"LA\", \"LA\"),\n    (II, 2, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGB\"),\n    (MM, 2, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGB\"),\n    (II, 2, (1,), 2, (8, 8, 8), ()): (\"RGB\", \"RGB;R\"),\n    (MM, 2, (1,), 2, (8, 8, 8), ()): (\"RGB\", \"RGB;R\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), ()): (\"RGBA\", \"RGBA\"),  # missing ExtraSamples\n    (MM, 2, (1,), 1, (8, 8, 8, 8), ()): (\"RGBA\", \"RGBA\"),  # missing ExtraSamples\n    (II, 2, (1,), 1, (8, 8, 8, 8), (0,)): (\"RGBX\", \"RGBX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (0,)): (\"RGBX\", \"RGBX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8), (0, 0)): (\"RGBX\", \"RGBXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8), (0, 0)): (\"RGBX\", \"RGBXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0, 0)): (\"RGBX\", \"RGBXXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0, 0)): (\"RGBX\", \"RGBXXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), (1,)): (\"RGBA\", \"RGBa\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (1,)): (\"RGBA\", \"RGBa\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8), (1, 0)): (\"RGBA\", \"RGBaX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8), (1, 0)): (\"RGBA\", \"RGBaX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (1, 0, 0)): (\"RGBA\", \"RGBaXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (1, 0, 0)): (\"RGBA\", \"RGBaXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), (2,)): (\"RGBA\", \"RGBA\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (2,)): (\"RGBA\", \"RGBA\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8), (2, 0)): (\"RGBA\", \"RGBAX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8), (2, 0)): (\"RGBA\", \"RGBAX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (2, 0, 0)): (\"RGBA\", \"RGBAXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (2, 0, 0)): (\"RGBA\", \"RGBAXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), (999,)): (\"RGBA\", \"RGBA\"),  # Corel Draw 10\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (999,)): (\"RGBA\", \"RGBA\"),  # Corel Draw 10\n    (II, 2, (1,), 1, (16, 16, 16), ()): (\"RGB\", \"RGB;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16), ()): (\"RGB\", \"RGB;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), ()): (\"RGBA\", \"RGBA;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), ()): (\"RGBA\", \"RGBA;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), (0,)): (\"RGBX\", \"RGBX;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), (0,)): (\"RGBX\", \"RGBX;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), (1,)): (\"RGBA\", \"RGBa;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), (1,)): (\"RGBA\", \"RGBa;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), (2,)): (\"RGBA\", \"RGBA;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), (2,)): (\"RGBA\", \"RGBA;16B\"),\n    (II, 3, (1,), 1, (1,), ()): (\"P\", \"P;1\"),\n    (MM, 3, (1,), 1, (1,), ()): (\"P\", \"P;1\"),\n    (II, 3, (1,), 2, (1,), ()): (\"P\", \"P;1R\"),\n    (MM, 3, (1,), 2, (1,), ()): (\"P\", \"P;1R\"),\n    (II, 3, (1,), 1, (2,), ()): (\"P\", \"P;2\"),\n    (MM, 3, (1,), 1, (2,), ()): (\"P\", \"P;2\"),\n    (II, 3, (1,), 2, (2,), ()): (\"P\", \"P;2R\"),\n    (MM, 3, (1,), 2, (2,), ()): (\"P\", \"P;2R\"),\n    (II, 3, (1,), 1, (4,), ()): (\"P\", \"P;4\"),\n    (MM, 3, (1,), 1, (4,), ()): (\"P\", \"P;4\"),\n    (II, 3, (1,), 2, (4,), ()): (\"P\", \"P;4R\"),\n    (MM, 3, (1,), 2, (4,), ()): (\"P\", \"P;4R\"),\n    (II, 3, (1,), 1, (8,), ()): (\"P\", \"P\"),\n    (MM, 3, (1,), 1, (8,), ()): (\"P\", \"P\"),\n    (II, 3, (1,), 1, (8, 8), (0,)): (\"P\", \"PX\"),\n    (II, 3, (1,), 1, (8, 8), (2,)): (\"PA\", \"PA\"),\n    (MM, 3, (1,), 1, (8, 8), (2,)): (\"PA\", \"PA\"),\n    (II, 3, (1,), 2, (8,), ()): (\"P\", \"P;R\"),\n    (MM, 3, (1,), 2, (8,), ()): (\"P\", \"P;R\"),\n    (II, 5, (1,), 1, (8, 8, 8, 8), ()): (\"CMYK\", \"CMYK\"),\n    (MM, 5, (1,), 1, (8, 8, 8, 8), ()): (\"CMYK\", \"CMYK\"),\n    (II, 5, (1,), 1, (8, 8, 8, 8, 8), (0,)): (\"CMYK\", \"CMYKX\"),\n    (MM, 5, (1,), 1, (8, 8, 8, 8, 8), (0,)): (\"CMYK\", \"CMYKX\"),\n    (II, 5, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0)): (\"CMYK\", \"CMYKXX\"),\n    (MM, 5, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0)): (\"CMYK\", \"CMYKXX\"),\n    (II, 5, (1,), 1, (16, 16, 16, 16), ()): (\"CMYK\", \"CMYK;16L\"),\n    (II, 6, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    (MM, 6, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    # JPEG compressed images handled by LibTiff and auto-converted to RGBX\n    # Minimal Baseline TIFF requires YCbCr images to have 3 SamplesPerPixel\n    (II, 6, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGBX\"),\n    (MM, 6, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGBX\"),\n    (II, 8, (1,), 1, (8, 8, 8), ()): (\"LAB\", \"LAB\"),\n    (MM, 8, (1,), 1, (8, 8, 8), ()): (\"LAB\", \"LAB\"),\n}\n\nMAX_SAMPLESPERPIXEL = max(len(key_tp[4]) for key_tp in OPEN_INFO)\n\nPREFIXES = [\n    b\"MM\\x00\\x2A\",  # Valid TIFF header with big-endian byte order\n    b\"II\\x2A\\x00\",  # Valid TIFF header with little-endian byte order\n    b\"MM\\x2A\\x00\",  # Invalid TIFF header, assume big-endian\n    b\"II\\x00\\x2A\",  # Invalid TIFF header, assume little-endian\n    b\"MM\\x00\\x2B\",  # BigTIFF with big-endian byte order\n    b\"II\\x2B\\x00\",  # BigTIFF with little-endian byte order\n]\n\nif not getattr(Image.core, \"libtiff_support_custom_tags\", True):\n    deprecate(\"Support for LibTIFF earlier than version 4\", 12)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] in PREFIXES\n\n\ndef _limit_rational(val, max_val):\n    inv = abs(val) > 1\n    n_d = IFDRational(1 / val if inv else val).limit_rational(max_val)\n    return n_d[::-1] if inv else n_d\n\n\ndef _limit_signed_rational(val, max_val, min_val):\n    frac = Fraction(val)\n    n_d = frac.numerator, frac.denominator\n\n    if min(n_d) < min_val:\n        n_d = _limit_rational(val, abs(min_val))\n\n    if max(n_d) > max_val:\n        val = Fraction(*n_d)\n        n_d = _limit_rational(val, max_val)\n\n    return n_d\n\n\n##\n# Wrapper for TIFF IFDs.\n\n_load_dispatch = {}\n_write_dispatch = {}\n\n\ndef _delegate(op):\n    def delegate(self, *args):\n        return getattr(self._val, op)(*args)\n\n    return delegate\n\n\nclass IFDRational(Rational):\n    \"\"\"Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n\n    \"\"\"\n\n    __slots__ = (\"_numerator\", \"_denominator\", \"_val\")\n\n    def __init__(self, value, denominator=1):\n        \"\"\"\n        :param value: either an integer numerator, a\n        float/rational/other number, or an IFDRational\n        :param denominator: Optional integer denominator\n        \"\"\"\n        if isinstance(value, IFDRational):\n            self._numerator = value.numerator\n            self._denominator = value.denominator\n            self._val = value._val\n            return\n\n        if isinstance(value, Fraction):\n            self._numerator = value.numerator\n            self._denominator = value.denominator\n        else:\n            self._numerator = value\n            self._denominator = denominator\n\n        if denominator == 0:\n            self._val = float(\"nan\")\n        elif denominator == 1:\n            self._val = Fraction(value)\n        else:\n            self._val = Fraction(value, denominator)\n\n    @property\n    def numerator(self):\n        return self._numerator\n\n    @property\n    def denominator(self):\n        return self._denominator\n\n    def limit_rational(self, max_denominator):\n        \"\"\"\n\n        :param max_denominator: Integer, the maximum denominator value\n        :returns: Tuple of (numerator, denominator)\n        \"\"\"\n\n        if self.denominator == 0:\n            return self.numerator, self.denominator\n\n        f = self._val.limit_denominator(max_denominator)\n        return f.numerator, f.denominator\n\n    def __repr__(self) -> str:\n        return str(float(self._val))\n\n    def __hash__(self) -> int:\n        return self._val.__hash__()\n\n    def __eq__(self, other: object) -> bool:\n        val = self._val\n        if isinstance(other, IFDRational):\n            other = other._val\n        if isinstance(other, float):\n            val = float(val)\n        return val == other\n\n    def __getstate__(self):\n        return [self._val, self._numerator, self._denominator]\n\n    def __setstate__(self, state):\n        IFDRational.__init__(self, 0)\n        _val, _numerator, _denominator = state\n        self._val = _val\n        self._numerator = _numerator\n        self._denominator = _denominator\n\n    \"\"\" a = ['add','radd', 'sub', 'rsub', 'mul', 'rmul',\n             'truediv', 'rtruediv', 'floordiv', 'rfloordiv',\n             'mod','rmod', 'pow','rpow', 'pos', 'neg',\n             'abs', 'trunc', 'lt', 'gt', 'le', 'ge', 'bool',\n             'ceil', 'floor', 'round']\n        print(\"\\n\".join(\"__%s__ = _delegate('__%s__')\" % (s,s) for s in a))\n        \"\"\"\n\n    __add__ = _delegate(\"__add__\")\n    __radd__ = _delegate(\"__radd__\")\n    __sub__ = _delegate(\"__sub__\")\n    __rsub__ = _delegate(\"__rsub__\")\n    __mul__ = _delegate(\"__mul__\")\n    __rmul__ = _delegate(\"__rmul__\")\n    __truediv__ = _delegate(\"__truediv__\")\n    __rtruediv__ = _delegate(\"__rtruediv__\")\n    __floordiv__ = _delegate(\"__floordiv__\")\n    __rfloordiv__ = _delegate(\"__rfloordiv__\")\n    __mod__ = _delegate(\"__mod__\")\n    __rmod__ = _delegate(\"__rmod__\")\n    __pow__ = _delegate(\"__pow__\")\n    __rpow__ = _delegate(\"__rpow__\")\n    __pos__ = _delegate(\"__pos__\")\n    __neg__ = _delegate(\"__neg__\")\n    __abs__ = _delegate(\"__abs__\")\n    __trunc__ = _delegate(\"__trunc__\")\n    __lt__ = _delegate(\"__lt__\")\n    __gt__ = _delegate(\"__gt__\")\n    __le__ = _delegate(\"__le__\")\n    __ge__ = _delegate(\"__ge__\")\n    __bool__ = _delegate(\"__bool__\")\n    __ceil__ = _delegate(\"__ceil__\")\n    __floor__ = _delegate(\"__floor__\")\n    __round__ = _delegate(\"__round__\")\n    # Python >= 3.11\n    if hasattr(Fraction, \"__int__\"):\n        __int__ = _delegate(\"__int__\")\n\n\ndef _register_loader(idx, size):\n    def decorator(func):\n        from .TiffTags import TYPES\n\n        if func.__name__.startswith(\"load_\"):\n            TYPES[idx] = func.__name__[5:].replace(\"_\", \" \")\n        _load_dispatch[idx] = size, func  # noqa: F821\n        return func\n\n    return decorator\n\n\ndef _register_writer(idx):\n    def decorator(func):\n        _write_dispatch[idx] = func  # noqa: F821\n        return func\n\n    return decorator\n\n\ndef _register_basic(idx_fmt_name):\n    from .TiffTags import TYPES\n\n    idx, fmt, name = idx_fmt_name\n    TYPES[idx] = name\n    size = struct.calcsize(f\"={fmt}\")\n    _load_dispatch[idx] = (  # noqa: F821\n        size,\n        lambda self, data, legacy_api=True: (\n            self._unpack(f\"{len(data) // size}{fmt}\", data)\n        ),\n    )\n    _write_dispatch[idx] = lambda self, *values: (  # noqa: F821\n        b\"\".join(self._pack(fmt, value) for value in values)\n    )\n\n\nif TYPE_CHECKING:\n    _IFDv2Base = MutableMapping[int, Any]\nelse:\n    _IFDv2Base = MutableMapping\n\n\nclass ImageFileDirectory_v2(_IFDv2Base):\n    \"\"\"This class represents a TIFF tag directory.  To speed things up, we\n    don't decode tags unless they're asked for.\n\n    Exposes a dictionary interface of the tags in the directory::\n\n        ifd = ImageFileDirectory_v2()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        'Some Data'\n\n    Individual values are returned as the strings or numbers, sequences are\n    returned as tuples of the values.\n\n    The tiff metadata type of each item is stored in a dictionary of\n    tag types in\n    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v2.tagtype`. The types\n    are read from a tiff file, guessed from the type added, or added\n    manually.\n\n    Data Structures:\n\n        * ``self.tagtype = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: integer corresponding to the data type from\n            :py:data:`.TiffTags.TYPES`\n\n          .. versionadded:: 3.0.0\n\n    'Internal' data structures:\n\n        * ``self._tags_v2 = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: decoded data, as tuple for multiple values\n\n        * ``self._tagdata = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: undecoded byte string from file\n\n        * ``self._tags_v1 = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: decoded data in the v1 format\n\n    Tags will be found in the private attributes ``self._tagdata``, and in\n    ``self._tags_v2`` once decoded.\n\n    ``self.legacy_api`` is a value for internal use, and shouldn't be changed\n    from outside code. In cooperation with\n    :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`, if ``legacy_api``\n    is true, then decoded tags will be populated into both ``_tags_v1`` and\n    ``_tags_v2``. ``_tags_v2`` will be used if this IFD is used in the TIFF\n    save routine. Tags should be read from ``_tags_v1`` if\n    ``legacy_api == true``.\n\n    \"\"\"\n\n    _load_dispatch: dict[int, Callable[[ImageFileDirectory_v2, bytes, bool], Any]] = {}\n    _write_dispatch: dict[int, Callable[..., Any]] = {}\n\n    def __init__(\n        self,\n        ifh: bytes = b\"II\\052\\0\\0\\0\\0\\0\",\n        prefix: bytes | None = None,\n        group: int | None = None,\n    ) -> None:\n        \"\"\"Initialize an ImageFileDirectory.\n\n        To construct an ImageFileDirectory from a real file, pass the 8-byte\n        magic header to the constructor.  To only set the endianness, pass it\n        as the 'prefix' keyword argument.\n\n        :param ifh: One of the accepted magic headers (cf. PREFIXES); also sets\n              endianness.\n        :param prefix: Override the endianness of the file.\n        \"\"\"\n        if not _accept(ifh):\n            msg = f\"not a TIFF file (header {repr(ifh)} not valid)\"\n            raise SyntaxError(msg)\n        self._prefix = prefix if prefix is not None else ifh[:2]\n        if self._prefix == MM:\n            self._endian = \">\"\n        elif self._prefix == II:\n            self._endian = \"<\"\n        else:\n            msg = \"not a TIFF IFD\"\n            raise SyntaxError(msg)\n        self._bigtiff = ifh[2] == 43\n        self.group = group\n        self.tagtype: dict[int, int] = {}\n        \"\"\" Dictionary of tag types \"\"\"\n        self.reset()\n        (self.next,) = (\n            self._unpack(\"Q\", ifh[8:]) if self._bigtiff else self._unpack(\"L\", ifh[4:])\n        )\n        self._legacy_api = False\n\n    prefix = property(lambda self: self._prefix)\n    offset = property(lambda self: self._offset)\n\n    @property\n    def legacy_api(self) -> bool:\n        return self._legacy_api\n\n    @legacy_api.setter\n    def legacy_api(self, value: bool) -> NoReturn:\n        msg = \"Not allowing setting of legacy api\"\n        raise Exception(msg)\n\n    def reset(self) -> None:\n        self._tags_v1: dict[int, Any] = {}  # will remain empty if legacy_api is false\n        self._tags_v2: dict[int, Any] = {}  # main tag storage\n        self._tagdata: dict[int, bytes] = {}\n        self.tagtype = {}  # added 2008-06-05 by Florian Hoech\n        self._next = None\n        self._offset = None\n\n    def __str__(self) -> str:\n        return str(dict(self))\n\n    def named(self):\n        \"\"\"\n        :returns: dict of name|key: value\n\n        Returns the complete tag dictionary, with named tags where possible.\n        \"\"\"\n        return {\n            TiffTags.lookup(code, self.group).name: value\n            for code, value in self.items()\n        }\n\n    def __len__(self) -> int:\n        return len(set(self._tagdata) | set(self._tags_v2))\n\n    def __getitem__(self, tag):\n        if tag not in self._tags_v2:  # unpack on the fly\n            data = self._tagdata[tag]\n            typ = self.tagtype[tag]\n            size, handler = self._load_dispatch[typ]\n            self[tag] = handler(self, data, self.legacy_api)  # check type\n        val = self._tags_v2[tag]\n        if self.legacy_api and not isinstance(val, (tuple, bytes)):\n            val = (val,)\n        return val\n\n    def __contains__(self, tag):\n        return tag in self._tags_v2 or tag in self._tagdata\n\n    def __setitem__(self, tag, value):\n        self._setitem(tag, value, self.legacy_api)\n\n    def _setitem(self, tag, value, legacy_api):\n        basetypes = (Number, bytes, str)\n\n        info = TiffTags.lookup(tag, self.group)\n        values = [value] if isinstance(value, basetypes) else value\n\n        if tag not in self.tagtype:\n            if info.type:\n                self.tagtype[tag] = info.type\n            else:\n                self.tagtype[tag] = TiffTags.UNDEFINED\n                if all(isinstance(v, IFDRational) for v in values):\n                    self.tagtype[tag] = (\n                        TiffTags.RATIONAL\n                        if all(v >= 0 for v in values)\n                        else TiffTags.SIGNED_RATIONAL\n                    )\n                elif all(isinstance(v, int) for v in values):\n                    if all(0 <= v < 2**16 for v in values):\n                        self.tagtype[tag] = TiffTags.SHORT\n                    elif all(-(2**15) < v < 2**15 for v in values):\n                        self.tagtype[tag] = TiffTags.SIGNED_SHORT\n                    else:\n                        self.tagtype[tag] = (\n                            TiffTags.LONG\n                            if all(v >= 0 for v in values)\n                            else TiffTags.SIGNED_LONG\n                        )\n                elif all(isinstance(v, float) for v in values):\n                    self.tagtype[tag] = TiffTags.DOUBLE\n                elif all(isinstance(v, str) for v in values):\n                    self.tagtype[tag] = TiffTags.ASCII\n                elif all(isinstance(v, bytes) for v in values):\n                    self.tagtype[tag] = TiffTags.BYTE\n\n        if self.tagtype[tag] == TiffTags.UNDEFINED:\n            values = [\n                v.encode(\"ascii\", \"replace\") if isinstance(v, str) else v\n                for v in values\n            ]\n        elif self.tagtype[tag] == TiffTags.RATIONAL:\n            values = [float(v) if isinstance(v, int) else v for v in values]\n\n        is_ifd = self.tagtype[tag] == TiffTags.LONG and isinstance(values, dict)\n        if not is_ifd:\n            values = tuple(info.cvt_enum(value) for value in values)\n\n        dest = self._tags_v1 if legacy_api else self._tags_v2\n\n        # Three branches:\n        # Spec'd length == 1, Actual length 1, store as element\n        # Spec'd length == 1, Actual > 1, Warn and truncate. Formerly barfed.\n        # No Spec, Actual length 1, Formerly (<4.2) returned a 1 element tuple.\n        # Don't mess with the legacy api, since it's frozen.\n        if not is_ifd and (\n            (info.length == 1)\n            or self.tagtype[tag] == TiffTags.BYTE\n            or (info.length is None and len(values) == 1 and not legacy_api)\n        ):\n            # Don't mess with the legacy api, since it's frozen.\n            if legacy_api and self.tagtype[tag] in [\n                TiffTags.RATIONAL,\n                TiffTags.SIGNED_RATIONAL,\n            ]:  # rationals\n                values = (values,)\n            try:\n                (dest[tag],) = values\n            except ValueError:\n                # We've got a builtin tag with 1 expected entry\n                warnings.warn(\n                    f\"Metadata Warning, tag {tag} had too many entries: \"\n                    f\"{len(values)}, expected 1\"\n                )\n                dest[tag] = values[0]\n\n        else:\n            # Spec'd length > 1 or undefined\n            # Unspec'd, and length > 1\n            dest[tag] = values\n\n    def __delitem__(self, tag: int) -> None:\n        self._tags_v2.pop(tag, None)\n        self._tags_v1.pop(tag, None)\n        self._tagdata.pop(tag, None)\n\n    def __iter__(self):\n        return iter(set(self._tagdata) | set(self._tags_v2))\n\n    def _unpack(self, fmt, data):\n        return struct.unpack(self._endian + fmt, data)\n\n    def _pack(self, fmt, *values):\n        return struct.pack(self._endian + fmt, *values)\n\n    list(\n        map(\n            _register_basic,\n            [\n                (TiffTags.SHORT, \"H\", \"short\"),\n                (TiffTags.LONG, \"L\", \"long\"),\n                (TiffTags.SIGNED_BYTE, \"b\", \"signed byte\"),\n                (TiffTags.SIGNED_SHORT, \"h\", \"signed short\"),\n                (TiffTags.SIGNED_LONG, \"l\", \"signed long\"),\n                (TiffTags.FLOAT, \"f\", \"float\"),\n                (TiffTags.DOUBLE, \"d\", \"double\"),\n                (TiffTags.IFD, \"L\", \"long\"),\n                (TiffTags.LONG8, \"Q\", \"long8\"),\n            ],\n        )\n    )\n\n    @_register_loader(1, 1)  # Basic type, except for the legacy API.\n    def load_byte(self, data, legacy_api=True):\n        return data\n\n    @_register_writer(1)  # Basic type, except for the legacy API.\n    def write_byte(self, data):\n        if isinstance(data, IFDRational):\n            data = int(data)\n        if isinstance(data, int):\n            data = bytes((data,))\n        return data\n\n    @_register_loader(2, 1)\n    def load_string(self, data, legacy_api=True):\n        if data.endswith(b\"\\0\"):\n            data = data[:-1]\n        return data.decode(\"latin-1\", \"replace\")\n\n    @_register_writer(2)\n    def write_string(self, value):\n        # remerge of https://github.com/python-pillow/Pillow/pull/1416\n        if isinstance(value, int):\n            value = str(value)\n        if not isinstance(value, bytes):\n            value = value.encode(\"ascii\", \"replace\")\n        return value + b\"\\0\"\n\n    @_register_loader(5, 8)\n    def load_rational(self, data, legacy_api=True):\n        vals = self._unpack(f\"{len(data) // 4}L\", data)\n\n        def combine(a, b):\n            return (a, b) if legacy_api else IFDRational(a, b)\n\n        return tuple(combine(num, denom) for num, denom in zip(vals[::2], vals[1::2]))\n\n    @_register_writer(5)\n    def write_rational(self, *values):\n        return b\"\".join(\n            self._pack(\"2L\", *_limit_rational(frac, 2**32 - 1)) for frac in values\n        )\n\n    @_register_loader(7, 1)\n    def load_undefined(self, data, legacy_api=True):\n        return data\n\n    @_register_writer(7)\n    def write_undefined(self, value):\n        if isinstance(value, IFDRational):\n            value = int(value)\n        if isinstance(value, int):\n            value = str(value).encode(\"ascii\", \"replace\")\n        return value\n\n    @_register_loader(10, 8)\n    def load_signed_rational(self, data, legacy_api=True):\n        vals = self._unpack(f\"{len(data) // 4}l\", data)\n\n        def combine(a, b):\n            return (a, b) if legacy_api else IFDRational(a, b)\n\n        return tuple(combine(num, denom) for num, denom in zip(vals[::2], vals[1::2]))\n\n    @_register_writer(10)\n    def write_signed_rational(self, *values):\n        return b\"\".join(\n            self._pack(\"2l\", *_limit_signed_rational(frac, 2**31 - 1, -(2**31)))\n            for frac in values\n        )\n\n    def _ensure_read(self, fp, size):\n        ret = fp.read(size)\n        if len(ret) != size:\n            msg = (\n                \"Corrupt EXIF data.  \"\n                f\"Expecting to read {size} bytes but only got {len(ret)}. \"\n            )\n            raise OSError(msg)\n        return ret\n\n    def load(self, fp):\n        self.reset()\n        self._offset = fp.tell()\n\n        try:\n            tag_count = (\n                self._unpack(\"Q\", self._ensure_read(fp, 8))\n                if self._bigtiff\n                else self._unpack(\"H\", self._ensure_read(fp, 2))\n            )[0]\n            for i in range(tag_count):\n                tag, typ, count, data = (\n                    self._unpack(\"HHQ8s\", self._ensure_read(fp, 20))\n                    if self._bigtiff\n                    else self._unpack(\"HHL4s\", self._ensure_read(fp, 12))\n                )\n\n                tagname = TiffTags.lookup(tag, self.group).name\n                typname = TYPES.get(typ, \"unknown\")\n                msg = f\"tag: {tagname} ({tag}) - type: {typname} ({typ})\"\n\n                try:\n                    unit_size, handler = self._load_dispatch[typ]\n                except KeyError:\n                    logger.debug(\"%s - unsupported type %s\", msg, typ)\n                    continue  # ignore unsupported type\n                size = count * unit_size\n                if size > (8 if self._bigtiff else 4):\n                    here = fp.tell()\n                    (offset,) = self._unpack(\"Q\" if self._bigtiff else \"L\", data)\n                    msg += f\" Tag Location: {here} - Data Location: {offset}\"\n                    fp.seek(offset)\n                    data = ImageFile._safe_read(fp, size)\n                    fp.seek(here)\n                else:\n                    data = data[:size]\n\n                if len(data) != size:\n                    warnings.warn(\n                        \"Possibly corrupt EXIF data.  \"\n                        f\"Expecting to read {size} bytes but only got {len(data)}.\"\n                        f\" Skipping tag {tag}\"\n                    )\n                    logger.debug(msg)\n                    continue\n\n                if not data:\n                    logger.debug(msg)\n                    continue\n\n                self._tagdata[tag] = data\n                self.tagtype[tag] = typ\n\n                msg += \" - value: \" + (\n                    \"<table: %d bytes>\" % size if size > 32 else repr(data)\n                )\n                logger.debug(msg)\n\n            (self.next,) = (\n                self._unpack(\"Q\", self._ensure_read(fp, 8))\n                if self._bigtiff\n                else self._unpack(\"L\", self._ensure_read(fp, 4))\n            )\n        except OSError as msg:\n            warnings.warn(str(msg))\n            return\n\n    def tobytes(self, offset=0):\n        # FIXME What about tagdata?\n        result = self._pack(\"H\", len(self._tags_v2))\n\n        entries = []\n        offset = offset + len(result) + len(self._tags_v2) * 12 + 4\n        stripoffsets = None\n\n        # pass 1: convert tags to binary format\n        # always write tags in ascending order\n        for tag, value in sorted(self._tags_v2.items()):\n            if tag == STRIPOFFSETS:\n                stripoffsets = len(entries)\n            typ = self.tagtype.get(tag)\n            logger.debug(\"Tag %s, Type: %s, Value: %s\", tag, typ, repr(value))\n            is_ifd = typ == TiffTags.LONG and isinstance(value, dict)\n            if is_ifd:\n                if self._endian == \"<\":\n                    ifh = b\"II\\x2A\\x00\\x08\\x00\\x00\\x00\"\n                else:\n                    ifh = b\"MM\\x00\\x2A\\x00\\x00\\x00\\x08\"\n                ifd = ImageFileDirectory_v2(ifh, group=tag)\n                values = self._tags_v2[tag]\n                for ifd_tag, ifd_value in values.items():\n                    ifd[ifd_tag] = ifd_value\n                data = ifd.tobytes(offset)\n            else:\n                values = value if isinstance(value, tuple) else (value,)\n                data = self._write_dispatch[typ](self, *values)\n\n            tagname = TiffTags.lookup(tag, self.group).name\n            typname = \"ifd\" if is_ifd else TYPES.get(typ, \"unknown\")\n            msg = f\"save: {tagname} ({tag}) - type: {typname} ({typ})\"\n            msg += \" - value: \" + (\n                \"<table: %d bytes>\" % len(data) if len(data) >= 16 else str(values)\n            )\n            logger.debug(msg)\n\n            # count is sum of lengths for string and arbitrary data\n            if is_ifd:\n                count = 1\n            elif typ in [TiffTags.BYTE, TiffTags.ASCII, TiffTags.UNDEFINED]:\n                count = len(data)\n            else:\n                count = len(values)\n            # figure out if data fits into the entry\n            if len(data) <= 4:\n                entries.append((tag, typ, count, data.ljust(4, b\"\\0\"), b\"\"))\n            else:\n                entries.append((tag, typ, count, self._pack(\"L\", offset), data))\n                offset += (len(data) + 1) // 2 * 2  # pad to word\n\n        # update strip offset data to point beyond auxiliary data\n        if stripoffsets is not None:\n            tag, typ, count, value, data = entries[stripoffsets]\n            if data:\n                msg = \"multistrip support not yet implemented\"\n                raise NotImplementedError(msg)\n            value = self._pack(\"L\", self._unpack(\"L\", value)[0] + offset)\n            entries[stripoffsets] = tag, typ, count, value, data\n\n        # pass 2: write entries to file\n        for tag, typ, count, value, data in entries:\n            logger.debug(\"%s %s %s %s %s\", tag, typ, count, repr(value), repr(data))\n            result += self._pack(\"HHL4s\", tag, typ, count, value)\n\n        # -- overwrite here for multi-page --\n        result += b\"\\0\\0\\0\\0\"  # end of entries\n\n        # pass 3: write auxiliary data to file\n        for tag, typ, count, value, data in entries:\n            result += data\n            if len(data) & 1:\n                result += b\"\\0\"\n\n        return result\n\n    def save(self, fp):\n        if fp.tell() == 0:  # skip TIFF header on subsequent pages\n            # tiff header -- PIL always starts the first IFD at offset 8\n            fp.write(self._prefix + self._pack(\"HL\", 42, 8))\n\n        offset = fp.tell()\n        result = self.tobytes(offset)\n        fp.write(result)\n        return offset + len(result)\n\n\nImageFileDirectory_v2._load_dispatch = _load_dispatch\nImageFileDirectory_v2._write_dispatch = _write_dispatch\nfor idx, name in TYPES.items():\n    name = name.replace(\" \", \"_\")\n    setattr(ImageFileDirectory_v2, f\"load_{name}\", _load_dispatch[idx][1])\n    setattr(ImageFileDirectory_v2, f\"write_{name}\", _write_dispatch[idx])\ndel _load_dispatch, _write_dispatch, idx, name\n\n\n# Legacy ImageFileDirectory support.\nclass ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.\n\n    Exposes a dictionary interface of the tags in the directory::\n\n        ifd = ImageFileDirectory_v1()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        ('Some Data',)\n\n    Also contains a dictionary of tag types as read from the tiff image file,\n    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v1.tagtype`.\n\n    Values are returned as a tuple.\n\n    ..  deprecated:: 3.0.0\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._legacy_api = True\n\n    tags = property(lambda self: self._tags_v1)\n    tagdata = property(lambda self: self._tagdata)\n\n    # defined in ImageFileDirectory_v2\n    tagtype: dict[int, int]\n    \"\"\"Dictionary of tag types\"\"\"\n\n    @classmethod\n    def from_v2(cls, original):\n        \"\"\"Returns an\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`\n        instance with the same data as is contained in the original\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`\n        instance.\n\n        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`\n\n        \"\"\"\n\n        ifd = cls(prefix=original.prefix)\n        ifd._tagdata = original._tagdata\n        ifd.tagtype = original.tagtype\n        ifd.next = original.next  # an indicator for multipage tiffs\n        return ifd\n\n    def to_v2(self) -> ImageFileDirectory_v2:\n        \"\"\"Returns an\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`\n        instance with the same data as is contained in the original\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`\n        instance.\n\n        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`\n\n        \"\"\"\n\n        ifd = ImageFileDirectory_v2(prefix=self.prefix)\n        ifd._tagdata = dict(self._tagdata)\n        ifd.tagtype = dict(self.tagtype)\n        ifd._tags_v2 = dict(self._tags_v2)\n        return ifd\n\n    def __contains__(self, tag):\n        return tag in self._tags_v1 or tag in self._tagdata\n\n    def __len__(self) -> int:\n        return len(set(self._tagdata) | set(self._tags_v1))\n\n    def __iter__(self):\n        return iter(set(self._tagdata) | set(self._tags_v1))\n\n    def __setitem__(self, tag, value):\n        for legacy_api in (False, True):\n            self._setitem(tag, value, legacy_api)\n\n    def __getitem__(self, tag):\n        if tag not in self._tags_v1:  # unpack on the fly\n            data = self._tagdata[tag]\n            typ = self.tagtype[tag]\n            size, handler = self._load_dispatch[typ]\n            for legacy in (False, True):\n                self._setitem(tag, handler(self, data, legacy), legacy)\n        val = self._tags_v1[tag]\n        if not isinstance(val, (tuple, bytes)):\n            val = (val,)\n        return val\n\n\n# undone -- switch this pointer when IFD_LEGACY_API == False\nImageFileDirectory = ImageFileDirectory_v1\n\n\n##\n# Image plugin for TIFF files.\n\n\nclass TiffImageFile(ImageFile.ImageFile):\n    format = \"TIFF\"\n    format_description = \"Adobe TIFF\"\n    _close_exclusive_fp_after_loading = False\n\n    def __init__(self, fp=None, filename=None):\n        self.tag_v2 = None\n        \"\"\" Image file directory (tag dictionary) \"\"\"\n\n        self.tag = None\n        \"\"\" Legacy tag entries \"\"\"\n\n        super().__init__(fp, filename)\n\n    def _open(self) -> None:\n        \"\"\"Open the first image in a TIFF file\"\"\"\n\n        # Header\n        ifh = self.fp.read(8)\n        if ifh[2] == 43:\n            ifh += self.fp.read(8)\n\n        self.tag_v2 = ImageFileDirectory_v2(ifh)\n\n        # legacy IFD entries will be filled in later\n        self.ifd = None\n\n        # setup frame pointers\n        self.__first = self.__next = self.tag_v2.next\n        self.__frame = -1\n        self._fp = self.fp\n        self._frame_pos: list[int] = []\n        self._n_frames: int | None = None\n\n        logger.debug(\"*** TiffImageFile._open ***\")\n        logger.debug(\"- __first: %s\", self.__first)\n        logger.debug(\"- ifh: %s\", repr(ifh))  # Use repr to avoid str(bytes)\n\n        # and load the first frame\n        self._seek(0)\n\n    @property\n    def n_frames(self):\n        if self._n_frames is None:\n            current = self.tell()\n            self._seek(len(self._frame_pos))\n            while self._n_frames is None:\n                self._seek(self.tell() + 1)\n            self.seek(current)\n        return self._n_frames\n\n    def seek(self, frame: int) -> None:\n        \"\"\"Select a given frame as current image\"\"\"\n        if not self._seek_check(frame):\n            return\n        self._seek(frame)\n        # Create a new core image object on second and\n        # subsequent frames in the image. Image may be\n        # different size/mode.\n        Image._decompression_bomb_check(self.size)\n        self.im = Image.core.new(self.mode, self.size)\n\n    def _seek(self, frame: int) -> None:\n        self.fp = self._fp\n\n        # reset buffered io handle in case fp\n        # was passed to libtiff, invalidating the buffer\n        self.fp.tell()\n\n        while len(self._frame_pos) <= frame:\n            if not self.__next:\n                msg = \"no more images in TIFF file\"\n                raise EOFError(msg)\n            logger.debug(\n                \"Seeking to frame %s, on frame %s, __next %s, location: %s\",\n                frame,\n                self.__frame,\n                self.__next,\n                self.fp.tell(),\n            )\n            if self.__next >= 2**63:\n                msg = \"Unable to seek to frame\"\n                raise ValueError(msg)\n            self.fp.seek(self.__next)\n            self._frame_pos.append(self.__next)\n            logger.debug(\"Loading tags, location: %s\", self.fp.tell())\n            self.tag_v2.load(self.fp)\n            if self.tag_v2.next in self._frame_pos:\n                # This IFD has already been processed\n                # Declare this to be the end of the image\n                self.__next = 0\n            else:\n                self.__next = self.tag_v2.next\n            if self.__next == 0:\n                self._n_frames = frame + 1\n            if len(self._frame_pos) == 1:\n                self.is_animated = self.__next != 0\n            self.__frame += 1\n        self.fp.seek(self._frame_pos[frame])\n        self.tag_v2.load(self.fp)\n        if XMP in self.tag_v2:\n            self.info[\"xmp\"] = self.tag_v2[XMP]\n        elif \"xmp\" in self.info:\n            del self.info[\"xmp\"]\n        self._reload_exif()\n        # fill the legacy tag/ifd entries\n        self.tag = self.ifd = ImageFileDirectory_v1.from_v2(self.tag_v2)\n        self.__frame = frame\n        self._setup()\n\n    def tell(self) -> int:\n        \"\"\"Return the current frame number\"\"\"\n        return self.__frame\n\n    def get_photoshop_blocks(self):\n        \"\"\"\n        Returns a dictionary of Photoshop \"Image Resource Blocks\".\n        The keys are the image resource ID. For more information, see\n        https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_pgfId-1037727\n\n        :returns: Photoshop \"Image Resource Blocks\" in a dictionary.\n        \"\"\"\n        blocks = {}\n        val = self.tag_v2.get(ExifTags.Base.ImageResources)\n        if val:\n            while val[:4] == b\"8BIM\":\n                id = i16(val[4:6])\n                n = math.ceil((val[6] + 1) / 2) * 2\n                size = i32(val[6 + n : 10 + n])\n                data = val[10 + n : 10 + n + size]\n                blocks[id] = {\"data\": data}\n\n                val = val[math.ceil((10 + n + size) / 2) * 2 :]\n        return blocks\n\n    def load(self):\n        if self.tile and self.use_load_libtiff:\n            return self._load_libtiff()\n        return super().load()\n\n    def load_end(self) -> None:\n        # allow closing if we're on the first frame, there's no next\n        # This is the ImageFile.load path only, libtiff specific below.\n        if not self.is_animated:\n            self._close_exclusive_fp_after_loading = True\n\n            # reset buffered io handle in case fp\n            # was passed to libtiff, invalidating the buffer\n            self.fp.tell()\n\n            # load IFD data from fp before it is closed\n            exif = self.getexif()\n            for key in TiffTags.TAGS_V2_GROUPS:\n                if key not in exif:\n                    continue\n                exif.get_ifd(key)\n\n        ImageOps.exif_transpose(self, in_place=True)\n        if ExifTags.Base.Orientation in self.tag_v2:\n            del self.tag_v2[ExifTags.Base.Orientation]\n\n    def _load_libtiff(self):\n        \"\"\"Overload method triggered when we detect a compressed tiff\n        Calls out to libtiff\"\"\"\n\n        Image.Image.load(self)\n\n        self.load_prepare()\n\n        if not len(self.tile) == 1:\n            msg = \"Not exactly one tile\"\n            raise OSError(msg)\n\n        # (self._compression, (extents tuple),\n        #   0, (rawmode, self._compression, fp))\n        extents = self.tile[0][1]\n        args = list(self.tile[0][3])\n\n        # To be nice on memory footprint, if there's a\n        # file descriptor, use that instead of reading\n        # into a string in python.\n        try:\n            fp = hasattr(self.fp, \"fileno\") and self.fp.fileno()\n            # flush the file descriptor, prevents error on pypy 2.4+\n            # should also eliminate the need for fp.tell\n            # in _seek\n            if hasattr(self.fp, \"flush\"):\n                self.fp.flush()\n        except OSError:\n            # io.BytesIO have a fileno, but returns an OSError if\n            # it doesn't use a file descriptor.\n            fp = False\n\n        if fp:\n            args[2] = fp\n\n        decoder = Image._getdecoder(\n            self.mode, \"libtiff\", tuple(args), self.decoderconfig\n        )\n        try:\n            decoder.setimage(self.im, extents)\n        except ValueError as e:\n            msg = \"Couldn't set the image\"\n            raise OSError(msg) from e\n\n        close_self_fp = self._exclusive_fp and not self.is_animated\n        if hasattr(self.fp, \"getvalue\"):\n            # We've got a stringio like thing passed in. Yay for all in memory.\n            # The decoder needs the entire file in one shot, so there's not\n            # a lot we can do here other than give it the entire file.\n            # unless we could do something like get the address of the\n            # underlying string for stringio.\n            #\n            # Rearranging for supporting byteio items, since they have a fileno\n            # that returns an OSError if there's no underlying fp. Easier to\n            # deal with here by reordering.\n            logger.debug(\"have getvalue. just sending in a string from getvalue\")\n            n, err = decoder.decode(self.fp.getvalue())\n        elif fp:\n            # we've got a actual file on disk, pass in the fp.\n            logger.debug(\"have fileno, calling fileno version of the decoder.\")\n            if not close_self_fp:\n                self.fp.seek(0)\n            # 4 bytes, otherwise the trace might error out\n            n, err = decoder.decode(b\"fpfp\")\n        else:\n            # we have something else.\n            logger.debug(\"don't have fileno or getvalue. just reading\")\n            self.fp.seek(0)\n            # UNDONE -- so much for that buffer size thing.\n            n, err = decoder.decode(self.fp.read())\n\n        self.tile = []\n        self.readonly = 0\n\n        self.load_end()\n\n        if close_self_fp:\n            self.fp.close()\n            self.fp = None  # might be shared\n\n        if err < 0:\n            raise OSError(err)\n\n        return Image.Image.load(self)\n\n    def _setup(self):\n        \"\"\"Setup this image object based on current tags\"\"\"\n\n        if 0xBC01 in self.tag_v2:\n            msg = \"Windows Media Photo files not yet supported\"\n            raise OSError(msg)\n\n        # extract relevant tags\n        self._compression = COMPRESSION_INFO[self.tag_v2.get(COMPRESSION, 1)]\n        self._planar_configuration = self.tag_v2.get(PLANAR_CONFIGURATION, 1)\n\n        # photometric is a required tag, but not everyone is reading\n        # the specification\n        photo = self.tag_v2.get(PHOTOMETRIC_INTERPRETATION, 0)\n\n        # old style jpeg compression images most certainly are YCbCr\n        if self._compression == \"tiff_jpeg\":\n            photo = 6\n\n        fillorder = self.tag_v2.get(FILLORDER, 1)\n\n        logger.debug(\"*** Summary ***\")\n        logger.debug(\"- compression: %s\", self._compression)\n        logger.debug(\"- photometric_interpretation: %s\", photo)\n        logger.debug(\"- planar_configuration: %s\", self._planar_configuration)\n        logger.debug(\"- fill_order: %s\", fillorder)\n        logger.debug(\"- YCbCr subsampling: %s\", self.tag.get(YCBCRSUBSAMPLING))\n\n        # size\n        xsize = int(self.tag_v2.get(IMAGEWIDTH))\n        ysize = int(self.tag_v2.get(IMAGELENGTH))\n        self._size = xsize, ysize\n\n        logger.debug(\"- size: %s\", self.size)\n\n        sample_format = self.tag_v2.get(SAMPLEFORMAT, (1,))\n        if len(sample_format) > 1 and max(sample_format) == min(sample_format) == 1:\n            # SAMPLEFORMAT is properly per band, so an RGB image will\n            # be (1,1,1).  But, we don't support per band pixel types,\n            # and anything more than one band is a uint8. So, just\n            # take the first element. Revisit this if adding support\n            # for more exotic images.\n            sample_format = (1,)\n\n        bps_tuple = self.tag_v2.get(BITSPERSAMPLE, (1,))\n        extra_tuple = self.tag_v2.get(EXTRASAMPLES, ())\n        if photo in (2, 6, 8):  # RGB, YCbCr, LAB\n            bps_count = 3\n        elif photo == 5:  # CMYK\n            bps_count = 4\n        else:\n            bps_count = 1\n        bps_count += len(extra_tuple)\n        bps_actual_count = len(bps_tuple)\n        samples_per_pixel = self.tag_v2.get(\n            SAMPLESPERPIXEL,\n            3 if self._compression == \"tiff_jpeg\" and photo in (2, 6) else 1,\n        )\n\n        if samples_per_pixel > MAX_SAMPLESPERPIXEL:\n            # DOS check, samples_per_pixel can be a Long, and we extend the tuple below\n            logger.error(\n                \"More samples per pixel than can be decoded: %s\", samples_per_pixel\n            )\n            msg = \"Invalid value for samples per pixel\"\n            raise SyntaxError(msg)\n\n        if samples_per_pixel < bps_actual_count:\n            # If a file has more values in bps_tuple than expected,\n            # remove the excess.\n            bps_tuple = bps_tuple[:samples_per_pixel]\n        elif samples_per_pixel > bps_actual_count and bps_actual_count == 1:\n            # If a file has only one value in bps_tuple, when it should have more,\n            # presume it is the same number of bits for all of the samples.\n            bps_tuple = bps_tuple * samples_per_pixel\n\n        if len(bps_tuple) != samples_per_pixel:\n            msg = \"unknown data organization\"\n            raise SyntaxError(msg)\n\n        # mode: check photometric interpretation and bits per pixel\n        key = (\n            self.tag_v2.prefix,\n            photo,\n            sample_format,\n            fillorder,\n            bps_tuple,\n            extra_tuple,\n        )\n        logger.debug(\"format key: %s\", key)\n        try:\n            self._mode, rawmode = OPEN_INFO[key]\n        except KeyError as e:\n            logger.debug(\"- unsupported format\")\n            msg = \"unknown pixel mode\"\n            raise SyntaxError(msg) from e\n\n        logger.debug(\"- raw mode: %s\", rawmode)\n        logger.debug(\"- pil mode: %s\", self.mode)\n\n        self.info[\"compression\"] = self._compression\n\n        xres = self.tag_v2.get(X_RESOLUTION, 1)\n        yres = self.tag_v2.get(Y_RESOLUTION, 1)\n\n        if xres and yres:\n            resunit = self.tag_v2.get(RESOLUTION_UNIT)\n            if resunit == 2:  # dots per inch\n                self.info[\"dpi\"] = (xres, yres)\n            elif resunit == 3:  # dots per centimeter. convert to dpi\n                self.info[\"dpi\"] = (xres * 2.54, yres * 2.54)\n            elif resunit is None:  # used to default to 1, but now 2)\n                self.info[\"dpi\"] = (xres, yres)\n                # For backward compatibility,\n                # we also preserve the old behavior\n                self.info[\"resolution\"] = xres, yres\n            else:  # No absolute unit of measurement\n                self.info[\"resolution\"] = xres, yres\n\n        # build tile descriptors\n        x = y = layer = 0\n        self.tile = []\n        self.use_load_libtiff = READ_LIBTIFF or self._compression != \"raw\"\n        if self.use_load_libtiff:\n            # Decoder expects entire file as one tile.\n            # There's a buffer size limit in load (64k)\n            # so large g4 images will fail if we use that\n            # function.\n            #\n            # Setup the one tile for the whole image, then\n            # use the _load_libtiff function.\n\n            # libtiff handles the fillmode for us, so 1;IR should\n            # actually be 1;I. Including the R double reverses the\n            # bits, so stripes of the image are reversed.  See\n            # https://github.com/python-pillow/Pillow/issues/279\n            if fillorder == 2:\n                # Replace fillorder with fillorder=1\n                key = key[:3] + (1,) + key[4:]\n                logger.debug(\"format key: %s\", key)\n                # this should always work, since all the\n                # fillorder==2 modes have a corresponding\n                # fillorder=1 mode\n                self._mode, rawmode = OPEN_INFO[key]\n            # libtiff always returns the bytes in native order.\n            # we're expecting image byte order. So, if the rawmode\n            # contains I;16, we need to convert from native to image\n            # byte order.\n            if rawmode == \"I;16\":\n                rawmode = \"I;16N\"\n            if \";16B\" in rawmode:\n                rawmode = rawmode.replace(\";16B\", \";16N\")\n            if \";16L\" in rawmode:\n                rawmode = rawmode.replace(\";16L\", \";16N\")\n\n            # YCbCr images with new jpeg compression with pixels in one plane\n            # unpacked straight into RGB values\n            if (\n                photo == 6\n                and self._compression == \"jpeg\"\n                and self._planar_configuration == 1\n            ):\n                rawmode = \"RGB\"\n\n            # Offset in the tile tuple is 0, we go from 0,0 to\n            # w,h, and we only do this once -- eds\n            a = (rawmode, self._compression, False, self.tag_v2.offset)\n            self.tile.append((\"libtiff\", (0, 0, xsize, ysize), 0, a))\n\n        elif STRIPOFFSETS in self.tag_v2 or TILEOFFSETS in self.tag_v2:\n            # striped image\n            if STRIPOFFSETS in self.tag_v2:\n                offsets = self.tag_v2[STRIPOFFSETS]\n                h = self.tag_v2.get(ROWSPERSTRIP, ysize)\n                w = self.size[0]\n            else:\n                # tiled image\n                offsets = self.tag_v2[TILEOFFSETS]\n                w = self.tag_v2.get(TILEWIDTH)\n                h = self.tag_v2.get(TILELENGTH)\n\n            for offset in offsets:\n                if x + w > xsize:\n                    stride = w * sum(bps_tuple) / 8  # bytes per line\n                else:\n                    stride = 0\n\n                tile_rawmode = rawmode\n                if self._planar_configuration == 2:\n                    # each band on it's own layer\n                    tile_rawmode = rawmode[layer]\n                    # adjust stride width accordingly\n                    stride /= bps_count\n\n                a = (tile_rawmode, int(stride), 1)\n                self.tile.append(\n                    (\n                        self._compression,\n                        (x, y, min(x + w, xsize), min(y + h, ysize)),\n                        offset,\n                        a,\n                    )\n                )\n                x = x + w\n                if x >= self.size[0]:\n                    x, y = 0, y + h\n                    if y >= self.size[1]:\n                        x = y = 0\n                        layer += 1\n        else:\n            logger.debug(\"- unsupported data organization\")\n            msg = \"unknown data organization\"\n            raise SyntaxError(msg)\n\n        # Fix up info.\n        if ICCPROFILE in self.tag_v2:\n            self.info[\"icc_profile\"] = self.tag_v2[ICCPROFILE]\n\n        # fixup palette descriptor\n\n        if self.mode in [\"P\", \"PA\"]:\n            palette = [o8(b // 256) for b in self.tag_v2[COLORMAP]]\n            self.palette = ImagePalette.raw(\"RGB;L\", b\"\".join(palette))\n\n\n#\n# --------------------------------------------------------------------\n# Write TIFF files\n\n# little endian is default except for image modes with\n# explicit big endian byte-order\n\nSAVE_INFO = {\n    # mode => rawmode, byteorder, photometrics,\n    #           sampleformat, bitspersample, extra\n    \"1\": (\"1\", II, 1, 1, (1,), None),\n    \"L\": (\"L\", II, 1, 1, (8,), None),\n    \"LA\": (\"LA\", II, 1, 1, (8, 8), 2),\n    \"P\": (\"P\", II, 3, 1, (8,), None),\n    \"PA\": (\"PA\", II, 3, 1, (8, 8), 2),\n    \"I\": (\"I;32S\", II, 1, 2, (32,), None),\n    \"I;16\": (\"I;16\", II, 1, 1, (16,), None),\n    \"I;16S\": (\"I;16S\", II, 1, 2, (16,), None),\n    \"F\": (\"F;32F\", II, 1, 3, (32,), None),\n    \"RGB\": (\"RGB\", II, 2, 1, (8, 8, 8), None),\n    \"RGBX\": (\"RGBX\", II, 2, 1, (8, 8, 8, 8), 0),\n    \"RGBA\": (\"RGBA\", II, 2, 1, (8, 8, 8, 8), 2),\n    \"CMYK\": (\"CMYK\", II, 5, 1, (8, 8, 8, 8), None),\n    \"YCbCr\": (\"YCbCr\", II, 6, 1, (8, 8, 8), None),\n    \"LAB\": (\"LAB\", II, 8, 1, (8, 8, 8), None),\n    \"I;32BS\": (\"I;32BS\", MM, 1, 2, (32,), None),\n    \"I;16B\": (\"I;16B\", MM, 1, 1, (16,), None),\n    \"I;16BS\": (\"I;16BS\", MM, 1, 2, (16,), None),\n    \"F;32BF\": (\"F;32BF\", MM, 1, 3, (32,), None),\n}\n\n\ndef _save(im, fp, filename):\n    try:\n        rawmode, prefix, photo, format, bits, extra = SAVE_INFO[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as TIFF\"\n        raise OSError(msg) from e\n\n    ifd = ImageFileDirectory_v2(prefix=prefix)\n\n    encoderinfo = im.encoderinfo\n    encoderconfig = im.encoderconfig\n    try:\n        compression = encoderinfo[\"compression\"]\n    except KeyError:\n        compression = im.info.get(\"compression\")\n        if isinstance(compression, int):\n            # compression value may be from BMP. Ignore it\n            compression = None\n    if compression is None:\n        compression = \"raw\"\n    elif compression == \"tiff_jpeg\":\n        # OJPEG is obsolete, so use new-style JPEG compression instead\n        compression = \"jpeg\"\n    elif compression == \"tiff_deflate\":\n        compression = \"tiff_adobe_deflate\"\n\n    libtiff = WRITE_LIBTIFF or compression != \"raw\"\n\n    # required for color libtiff images\n    ifd[PLANAR_CONFIGURATION] = 1\n\n    ifd[IMAGEWIDTH] = im.size[0]\n    ifd[IMAGELENGTH] = im.size[1]\n\n    # write any arbitrary tags passed in as an ImageFileDirectory\n    if \"tiffinfo\" in encoderinfo:\n        info = encoderinfo[\"tiffinfo\"]\n    elif \"exif\" in encoderinfo:\n        info = encoderinfo[\"exif\"]\n        if isinstance(info, bytes):\n            exif = Image.Exif()\n            exif.load(info)\n            info = exif\n    else:\n        info = {}\n    logger.debug(\"Tiffinfo Keys: %s\", list(info))\n    if isinstance(info, ImageFileDirectory_v1):\n        info = info.to_v2()\n    for key in info:\n        if isinstance(info, Image.Exif) and key in TiffTags.TAGS_V2_GROUPS:\n            ifd[key] = info.get_ifd(key)\n        else:\n            ifd[key] = info.get(key)\n        try:\n            ifd.tagtype[key] = info.tagtype[key]\n        except Exception:\n            pass  # might not be an IFD. Might not have populated type\n\n    # additions written by Greg Couch, gregc@cgl.ucsf.edu\n    # inspired by image-sig posting from Kevin Cazabon, kcazabon@home.com\n    if hasattr(im, \"tag_v2\"):\n        # preserve tags from original TIFF image file\n        for key in (\n            RESOLUTION_UNIT,\n            X_RESOLUTION,\n            Y_RESOLUTION,\n            IPTC_NAA_CHUNK,\n            PHOTOSHOP_CHUNK,\n            XMP,\n        ):\n            if key in im.tag_v2:\n                ifd[key] = im.tag_v2[key]\n                ifd.tagtype[key] = im.tag_v2.tagtype[key]\n\n    # preserve ICC profile (should also work when saving other formats\n    # which support profiles as TIFF) -- 2008-06-06 Florian Hoech\n    icc = encoderinfo.get(\"icc_profile\", im.info.get(\"icc_profile\"))\n    if icc:\n        ifd[ICCPROFILE] = icc\n\n    for key, name in [\n        (IMAGEDESCRIPTION, \"description\"),\n        (X_RESOLUTION, \"resolution\"),\n        (Y_RESOLUTION, \"resolution\"),\n        (X_RESOLUTION, \"x_resolution\"),\n        (Y_RESOLUTION, \"y_resolution\"),\n        (RESOLUTION_UNIT, \"resolution_unit\"),\n        (SOFTWARE, \"software\"),\n        (DATE_TIME, \"date_time\"),\n        (ARTIST, \"artist\"),\n        (COPYRIGHT, \"copyright\"),\n    ]:\n        if name in encoderinfo:\n            ifd[key] = encoderinfo[name]\n\n    dpi = encoderinfo.get(\"dpi\")\n    if dpi:\n        ifd[RESOLUTION_UNIT] = 2\n        ifd[X_RESOLUTION] = dpi[0]\n        ifd[Y_RESOLUTION] = dpi[1]\n\n    if bits != (1,):\n        ifd[BITSPERSAMPLE] = bits\n        if len(bits) != 1:\n            ifd[SAMPLESPERPIXEL] = len(bits)\n    if extra is not None:\n        ifd[EXTRASAMPLES] = extra\n    if format != 1:\n        ifd[SAMPLEFORMAT] = format\n\n    if PHOTOMETRIC_INTERPRETATION not in ifd:\n        ifd[PHOTOMETRIC_INTERPRETATION] = photo\n    elif im.mode in (\"1\", \"L\") and ifd[PHOTOMETRIC_INTERPRETATION] == 0:\n        if im.mode == \"1\":\n            inverted_im = im.copy()\n            px = inverted_im.load()\n            for y in range(inverted_im.height):\n                for x in range(inverted_im.width):\n                    px[x, y] = 0 if px[x, y] == 255 else 255\n            im = inverted_im\n        else:\n            im = ImageOps.invert(im)\n\n    if im.mode in [\"P\", \"PA\"]:\n        lut = im.im.getpalette(\"RGB\", \"RGB;L\")\n        colormap = []\n        colors = len(lut) // 3\n        for i in range(3):\n            colormap += [v * 256 for v in lut[colors * i : colors * (i + 1)]]\n            colormap += [0] * (256 - colors)\n        ifd[COLORMAP] = colormap\n    # data orientation\n    w, h = ifd[IMAGEWIDTH], ifd[IMAGELENGTH]\n    stride = len(bits) * ((w * bits[0] + 7) // 8)\n    if ROWSPERSTRIP not in ifd:\n        # aim for given strip size (64 KB by default) when using libtiff writer\n        if libtiff:\n            im_strip_size = encoderinfo.get(\"strip_size\", STRIP_SIZE)\n            rows_per_strip = 1 if stride == 0 else min(im_strip_size // stride, h)\n            # JPEG encoder expects multiple of 8 rows\n            if compression == \"jpeg\":\n                rows_per_strip = min(((rows_per_strip + 7) // 8) * 8, h)\n        else:\n            rows_per_strip = h\n        if rows_per_strip == 0:\n            rows_per_strip = 1\n        ifd[ROWSPERSTRIP] = rows_per_strip\n    strip_byte_counts = 1 if stride == 0 else stride * ifd[ROWSPERSTRIP]\n    strips_per_image = (h + ifd[ROWSPERSTRIP] - 1) // ifd[ROWSPERSTRIP]\n    if strip_byte_counts >= 2**16:\n        ifd.tagtype[STRIPBYTECOUNTS] = TiffTags.LONG\n    ifd[STRIPBYTECOUNTS] = (strip_byte_counts,) * (strips_per_image - 1) + (\n        stride * h - strip_byte_counts * (strips_per_image - 1),\n    )\n    ifd[STRIPOFFSETS] = tuple(\n        range(0, strip_byte_counts * strips_per_image, strip_byte_counts)\n    )  # this is adjusted by IFD writer\n    # no compression by default:\n    ifd[COMPRESSION] = COMPRESSION_INFO_REV.get(compression, 1)\n\n    if im.mode == \"YCbCr\":\n        for tag, value in {\n            YCBCRSUBSAMPLING: (1, 1),\n            REFERENCEBLACKWHITE: (0, 255, 128, 255, 128, 255),\n        }.items():\n            ifd.setdefault(tag, value)\n\n    blocklist = [TILEWIDTH, TILELENGTH, TILEOFFSETS, TILEBYTECOUNTS]\n    if libtiff:\n        if \"quality\" in encoderinfo:\n            quality = encoderinfo[\"quality\"]\n            if not isinstance(quality, int) or quality < 0 or quality > 100:\n                msg = \"Invalid quality setting\"\n                raise ValueError(msg)\n            if compression != \"jpeg\":\n                msg = \"quality setting only supported for 'jpeg' compression\"\n                raise ValueError(msg)\n            ifd[JPEGQUALITY] = quality\n\n        logger.debug(\"Saving using libtiff encoder\")\n        logger.debug(\"Items: %s\", sorted(ifd.items()))\n        _fp = 0\n        if hasattr(fp, \"fileno\"):\n            try:\n                fp.seek(0)\n                _fp = os.dup(fp.fileno())\n            except io.UnsupportedOperation:\n                pass\n\n        # optional types for non core tags\n        types = {}\n        # STRIPOFFSETS and STRIPBYTECOUNTS are added by the library\n        # based on the data in the strip.\n        # OSUBFILETYPE is deprecated.\n        # The other tags expect arrays with a certain length (fixed or depending on\n        # BITSPERSAMPLE, etc), passing arrays with a different length will result in\n        # segfaults. Block these tags until we add extra validation.\n        # SUBIFD may also cause a segfault.\n        blocklist += [\n            OSUBFILETYPE,\n            REFERENCEBLACKWHITE,\n            STRIPBYTECOUNTS,\n            STRIPOFFSETS,\n            TRANSFERFUNCTION,\n            SUBIFD,\n        ]\n\n        # bits per sample is a single short in the tiff directory, not a list.\n        atts = {BITSPERSAMPLE: bits[0]}\n        # Merge the ones that we have with (optional) more bits from\n        # the original file, e.g x,y resolution so that we can\n        # save(load('')) == original file.\n        legacy_ifd = {}\n        if hasattr(im, \"tag\"):\n            legacy_ifd = im.tag.to_v2()\n\n        # SAMPLEFORMAT is determined by the image format and should not be copied\n        # from legacy_ifd.\n        supplied_tags = {**getattr(im, \"tag_v2\", {}), **legacy_ifd}\n        if SAMPLEFORMAT in supplied_tags:\n            del supplied_tags[SAMPLEFORMAT]\n\n        for tag, value in itertools.chain(ifd.items(), supplied_tags.items()):\n            # Libtiff can only process certain core items without adding\n            # them to the custom dictionary.\n            # Custom items are supported for int, float, unicode, string and byte\n            # values. Other types and tuples require a tagtype.\n            if tag not in TiffTags.LIBTIFF_CORE:\n                if not getattr(Image.core, \"libtiff_support_custom_tags\", False):\n                    continue\n\n                if tag in ifd.tagtype:\n                    types[tag] = ifd.tagtype[tag]\n                elif not (isinstance(value, (int, float, str, bytes))):\n                    continue\n                else:\n                    type = TiffTags.lookup(tag).type\n                    if type:\n                        types[tag] = type\n            if tag not in atts and tag not in blocklist:\n                if isinstance(value, str):\n                    atts[tag] = value.encode(\"ascii\", \"replace\") + b\"\\0\"\n                elif isinstance(value, IFDRational):\n                    atts[tag] = float(value)\n                else:\n                    atts[tag] = value\n\n        if SAMPLEFORMAT in atts and len(atts[SAMPLEFORMAT]) == 1:\n            atts[SAMPLEFORMAT] = atts[SAMPLEFORMAT][0]\n\n        logger.debug(\"Converted items: %s\", sorted(atts.items()))\n\n        # libtiff always expects the bytes in native order.\n        # we're storing image byte order. So, if the rawmode\n        # contains I;16, we need to convert from native to image\n        # byte order.\n        if im.mode in (\"I;16B\", \"I;16\"):\n            rawmode = \"I;16N\"\n\n        # Pass tags as sorted list so that the tags are set in a fixed order.\n        # This is required by libtiff for some tags. For example, the JPEGQUALITY\n        # pseudo tag requires that the COMPRESS tag was already set.\n        tags = list(atts.items())\n        tags.sort()\n        a = (rawmode, compression, _fp, filename, tags, types)\n        encoder = Image._getencoder(im.mode, \"libtiff\", a, encoderconfig)\n        encoder.setimage(im.im, (0, 0) + im.size)\n        while True:\n            # undone, change to self.decodermaxblock:\n            errcode, data = encoder.encode(16 * 1024)[1:]\n            if not _fp:\n                fp.write(data)\n            if errcode:\n                break\n        if _fp:\n            try:\n                os.close(_fp)\n            except OSError:\n                pass\n        if errcode < 0:\n            msg = f\"encoder error {errcode} when writing image file\"\n            raise OSError(msg)\n\n    else:\n        for tag in blocklist:\n            del ifd[tag]\n        offset = ifd.save(fp)\n\n        ImageFile._save(\n            im, fp, [(\"raw\", (0, 0) + im.size, offset, (rawmode, stride, 1))]\n        )\n\n    # -- helper for multi-page save --\n    if \"_debug_multipage\" in encoderinfo:\n        # just to access o32 and o16 (using correct byte order)\n        im._debug_multipage = ifd\n\n\nclass AppendingTiffWriter:\n    fieldSizes = [\n        0,  # None\n        1,  # byte\n        1,  # ascii\n        2,  # short\n        4,  # long\n        8,  # rational\n        1,  # sbyte\n        1,  # undefined\n        2,  # sshort\n        4,  # slong\n        8,  # srational\n        4,  # float\n        8,  # double\n        4,  # ifd\n        2,  # unicode\n        4,  # complex\n        8,  # long8\n    ]\n\n    Tags = {\n        273,  # StripOffsets\n        288,  # FreeOffsets\n        324,  # TileOffsets\n        519,  # JPEGQTables\n        520,  # JPEGDCTables\n        521,  # JPEGACTables\n    }\n\n    def __init__(self, fn, new=False):\n        if hasattr(fn, \"read\"):\n            self.f = fn\n            self.close_fp = False\n        else:\n            self.name = fn\n            self.close_fp = True\n            try:\n                self.f = open(fn, \"w+b\" if new else \"r+b\")\n            except OSError:\n                self.f = open(fn, \"w+b\")\n        self.beginning = self.f.tell()\n        self.setup()\n\n    def setup(self) -> None:\n        # Reset everything.\n        self.f.seek(self.beginning, os.SEEK_SET)\n\n        self.whereToWriteNewIFDOffset = None\n        self.offsetOfNewPage = 0\n\n        self.IIMM = iimm = self.f.read(4)\n        if not iimm:\n            # empty file - first page\n            self.isFirst = True\n            return\n\n        self.isFirst = False\n        if iimm == b\"II\\x2a\\x00\":\n            self.setEndian(\"<\")\n        elif iimm == b\"MM\\x00\\x2a\":\n            self.setEndian(\">\")\n        else:\n            msg = \"Invalid TIFF file header\"\n            raise RuntimeError(msg)\n\n        self.skipIFDs()\n        self.goToEnd()\n\n    def finalize(self) -> None:\n        if self.isFirst:\n            return\n\n        # fix offsets\n        self.f.seek(self.offsetOfNewPage)\n\n        iimm = self.f.read(4)\n        if not iimm:\n            # Make it easy to finish a frame without committing to a new one.\n            return\n\n        if iimm != self.IIMM:\n            msg = \"IIMM of new page doesn't match IIMM of first page\"\n            raise RuntimeError(msg)\n\n        ifd_offset = self.readLong()\n        ifd_offset += self.offsetOfNewPage\n        self.f.seek(self.whereToWriteNewIFDOffset)\n        self.writeLong(ifd_offset)\n        self.f.seek(ifd_offset)\n        self.fixIFD()\n\n    def newFrame(self) -> None:\n        # Call this to finish a frame.\n        self.finalize()\n        self.setup()\n\n    def __enter__(self) -> AppendingTiffWriter:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        if self.close_fp:\n            self.close()\n\n    def tell(self) -> int:\n        return self.f.tell() - self.offsetOfNewPage\n\n    def seek(self, offset, whence=io.SEEK_SET):\n        if whence == os.SEEK_SET:\n            offset += self.offsetOfNewPage\n\n        self.f.seek(offset, whence)\n        return self.tell()\n\n    def goToEnd(self) -> None:\n        self.f.seek(0, os.SEEK_END)\n        pos = self.f.tell()\n\n        # pad to 16 byte boundary\n        pad_bytes = 16 - pos % 16\n        if 0 < pad_bytes < 16:\n            self.f.write(bytes(pad_bytes))\n        self.offsetOfNewPage = self.f.tell()\n\n    def setEndian(self, endian: str) -> None:\n        self.endian = endian\n        self.longFmt = f\"{self.endian}L\"\n        self.shortFmt = f\"{self.endian}H\"\n        self.tagFormat = f\"{self.endian}HHL\"\n\n    def skipIFDs(self) -> None:\n        while True:\n            ifd_offset = self.readLong()\n            if ifd_offset == 0:\n                self.whereToWriteNewIFDOffset = self.f.tell() - 4\n                break\n\n            self.f.seek(ifd_offset)\n            num_tags = self.readShort()\n            self.f.seek(num_tags * 12, os.SEEK_CUR)\n\n    def write(self, data: bytes) -> int | None:\n        return self.f.write(data)\n\n    def readShort(self) -> int:\n        (value,) = struct.unpack(self.shortFmt, self.f.read(2))\n        return value\n\n    def readLong(self) -> int:\n        (value,) = struct.unpack(self.longFmt, self.f.read(4))\n        return value\n\n    def rewriteLastShortToLong(self, value: int) -> None:\n        self.f.seek(-2, os.SEEK_CUR)\n        bytes_written = self.f.write(struct.pack(self.longFmt, value))\n        if bytes_written is not None and bytes_written != 4:\n            msg = f\"wrote only {bytes_written} bytes but wanted 4\"\n            raise RuntimeError(msg)\n\n    def rewriteLastShort(self, value: int) -> None:\n        self.f.seek(-2, os.SEEK_CUR)\n        bytes_written = self.f.write(struct.pack(self.shortFmt, value))\n        if bytes_written is not None and bytes_written != 2:\n            msg = f\"wrote only {bytes_written} bytes but wanted 2\"\n            raise RuntimeError(msg)\n\n    def rewriteLastLong(self, value: int) -> None:\n        self.f.seek(-4, os.SEEK_CUR)\n        bytes_written = self.f.write(struct.pack(self.longFmt, value))\n        if bytes_written is not None and bytes_written != 4:\n            msg = f\"wrote only {bytes_written} bytes but wanted 4\"\n            raise RuntimeError(msg)\n\n    def writeShort(self, value: int) -> None:\n        bytes_written = self.f.write(struct.pack(self.shortFmt, value))\n        if bytes_written is not None and bytes_written != 2:\n            msg = f\"wrote only {bytes_written} bytes but wanted 2\"\n            raise RuntimeError(msg)\n\n    def writeLong(self, value: int) -> None:\n        bytes_written = self.f.write(struct.pack(self.longFmt, value))\n        if bytes_written is not None and bytes_written != 4:\n            msg = f\"wrote only {bytes_written} bytes but wanted 4\"\n            raise RuntimeError(msg)\n\n    def close(self) -> None:\n        self.finalize()\n        self.f.close()\n\n    def fixIFD(self) -> None:\n        num_tags = self.readShort()\n\n        for i in range(num_tags):\n            tag, field_type, count = struct.unpack(self.tagFormat, self.f.read(8))\n\n            field_size = self.fieldSizes[field_type]\n            total_size = field_size * count\n            is_local = total_size <= 4\n            offset: int | None\n            if not is_local:\n                offset = self.readLong() + self.offsetOfNewPage\n                self.rewriteLastLong(offset)\n\n            if tag in self.Tags:\n                cur_pos = self.f.tell()\n\n                if is_local:\n                    self.fixOffsets(\n                        count, isShort=(field_size == 2), isLong=(field_size == 4)\n                    )\n                    self.f.seek(cur_pos + 4)\n                else:\n                    self.f.seek(offset)\n                    self.fixOffsets(\n                        count, isShort=(field_size == 2), isLong=(field_size == 4)\n                    )\n                    self.f.seek(cur_pos)\n\n                offset = cur_pos = None\n\n            elif is_local:\n                # skip the locally stored value that is not an offset\n                self.f.seek(4, os.SEEK_CUR)\n\n    def fixOffsets(\n        self, count: int, isShort: bool = False, isLong: bool = False\n    ) -> None:\n        if not isShort and not isLong:\n            msg = \"offset is neither short nor long\"\n            raise RuntimeError(msg)\n\n        for i in range(count):\n            offset = self.readShort() if isShort else self.readLong()\n            offset += self.offsetOfNewPage\n            if isShort and offset >= 65536:\n                # offset is now too large - we must convert shorts to longs\n                if count != 1:\n                    msg = \"not implemented\"\n                    raise RuntimeError(msg)  # XXX TODO\n\n                # simple case - the offset is just one and therefore it is\n                # local (not referenced with another offset)\n                self.rewriteLastShortToLong(offset)\n                self.f.seek(-10, os.SEEK_CUR)\n                self.writeShort(TiffTags.LONG)  # rewrite the type to LONG\n                self.f.seek(8, os.SEEK_CUR)\n            elif isShort:\n                self.rewriteLastShort(offset)\n            else:\n                self.rewriteLastLong(offset)\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    encoderinfo = im.encoderinfo.copy()\n    encoderconfig = im.encoderconfig\n    append_images = list(encoderinfo.get(\"append_images\", []))\n    if not hasattr(im, \"n_frames\") and not append_images:\n        return _save(im, fp, filename)\n\n    cur_idx = im.tell()\n    try:\n        with AppendingTiffWriter(fp) as tf:\n            for ims in [im] + append_images:\n                ims.encoderinfo = encoderinfo\n                ims.encoderconfig = encoderconfig\n                if not hasattr(ims, \"n_frames\"):\n                    nfr = 1\n                else:\n                    nfr = ims.n_frames\n\n                for idx in range(nfr):\n                    ims.seek(idx)\n                    ims.load()\n                    _save(ims, tf, filename)\n                    tf.newFrame()\n    finally:\n        im.seek(cur_idx)\n\n\n#\n# --------------------------------------------------------------------\n# Register\n\nImage.register_open(TiffImageFile.format, TiffImageFile, _accept)\nImage.register_save(TiffImageFile.format, _save)\nImage.register_save_all(TiffImageFile.format, _save_all)\n\nImage.register_extensions(TiffImageFile.format, [\".tif\", \".tiff\"])\n\nImage.register_mime(TiffImageFile.format, \"image/tiff\")\n", "src/PIL/Image.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# the Image class wrapper\n#\n# partial release history:\n# 1995-09-09 fl   Created\n# 1996-03-11 fl   PIL release 0.0 (proof of concept)\n# 1996-04-30 fl   PIL release 0.1b1\n# 1999-07-28 fl   PIL release 1.0 final\n# 2000-06-07 fl   PIL release 1.1\n# 2000-10-20 fl   PIL release 1.1.1\n# 2001-05-07 fl   PIL release 1.1.2\n# 2002-03-15 fl   PIL release 1.1.3\n# 2003-05-10 fl   PIL release 1.1.4\n# 2005-03-28 fl   PIL release 1.1.5\n# 2006-12-02 fl   PIL release 1.1.6\n# 2009-11-15 fl   PIL release 1.1.7\n#\n# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-2009 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import annotations\n\nimport abc\nimport atexit\nimport builtins\nimport io\nimport logging\nimport math\nimport os\nimport re\nimport struct\nimport sys\nimport tempfile\nimport warnings\nfrom collections.abc import Callable, MutableMapping\nfrom enum import IntEnum\nfrom types import ModuleType\nfrom typing import IO, TYPE_CHECKING, Any, Literal, Protocol, Sequence, Tuple, cast\n\n# VERSION was removed in Pillow 6.0.0.\n# PILLOW_VERSION was removed in Pillow 9.0.0.\n# Use __version__ instead.\nfrom . import (\n    ExifTags,\n    ImageMode,\n    TiffTags,\n    UnidentifiedImageError,\n    __version__,\n    _plugins,\n)\nfrom ._binary import i32le, o32be, o32le\nfrom ._deprecate import deprecate\nfrom ._typing import StrOrBytesPath, TypeGuard\nfrom ._util import DeferredError, is_path\n\nElementTree: ModuleType | None\ntry:\n    from defusedxml import ElementTree\nexcept ImportError:\n    ElementTree = None\n\nlogger = logging.getLogger(__name__)\n\n\nclass DecompressionBombWarning(RuntimeWarning):\n    pass\n\n\nclass DecompressionBombError(Exception):\n    pass\n\n\n# Limit to around a quarter gigabyte for a 24-bit (3 bpp) image\nMAX_IMAGE_PIXELS: int | None = int(1024 * 1024 * 1024 // 4 // 3)\n\n\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;\n    # import Image and use the Image.core variable instead.\n    # Also note that Image.core is not a publicly documented interface,\n    # and should be considered private and subject to change.\n    from . import _imaging as core\n\n    if __version__ != getattr(core, \"PILLOW_VERSION\", None):\n        msg = (\n            \"The _imaging extension was built for another version of Pillow or PIL:\\n\"\n            f\"Core version: {getattr(core, 'PILLOW_VERSION', None)}\\n\"\n            f\"Pillow version: {__version__}\"\n        )\n        raise ImportError(msg)\n\nexcept ImportError as v:\n    core = DeferredError.new(ImportError(\"The _imaging C module is not installed.\"))\n    # Explanations for ways that we know we might have an import error\n    if str(v).startswith(\"Module use of python\"):\n        # The _imaging C module is present, but not compiled for\n        # the right version (windows only).  Print a warning, if\n        # possible.\n        warnings.warn(\n            \"The _imaging extension was built for another version of Python.\",\n            RuntimeWarning,\n        )\n    elif str(v).startswith(\"The _imaging extension\"):\n        warnings.warn(str(v), RuntimeWarning)\n    # Fail here anyway. Don't let people run with a mostly broken Pillow.\n    # see docs/porting.rst\n    raise\n\n\nUSE_CFFI_ACCESS = False\ncffi: ModuleType | None\ntry:\n    import cffi\nexcept ImportError:\n    cffi = None\n\n\ndef isImageType(t: Any) -> TypeGuard[Image]:\n    \"\"\"\n    Checks if an object is an image object.\n\n    .. warning::\n\n       This function is for internal use only.\n\n    :param t: object to check if it's an image\n    :returns: True if the object is an image\n    \"\"\"\n    return hasattr(t, \"im\")\n\n\n#\n# Constants\n\n\n# transpose\nclass Transpose(IntEnum):\n    FLIP_LEFT_RIGHT = 0\n    FLIP_TOP_BOTTOM = 1\n    ROTATE_90 = 2\n    ROTATE_180 = 3\n    ROTATE_270 = 4\n    TRANSPOSE = 5\n    TRANSVERSE = 6\n\n\n# transforms (also defined in Imaging.h)\nclass Transform(IntEnum):\n    AFFINE = 0\n    EXTENT = 1\n    PERSPECTIVE = 2\n    QUAD = 3\n    MESH = 4\n\n\n# resampling filters (also defined in Imaging.h)\nclass Resampling(IntEnum):\n    NEAREST = 0\n    BOX = 4\n    BILINEAR = 2\n    HAMMING = 5\n    BICUBIC = 3\n    LANCZOS = 1\n\n\n_filters_support = {\n    Resampling.BOX: 0.5,\n    Resampling.BILINEAR: 1.0,\n    Resampling.HAMMING: 1.0,\n    Resampling.BICUBIC: 2.0,\n    Resampling.LANCZOS: 3.0,\n}\n\n\n# dithers\nclass Dither(IntEnum):\n    NONE = 0\n    ORDERED = 1  # Not yet implemented\n    RASTERIZE = 2  # Not yet implemented\n    FLOYDSTEINBERG = 3  # default\n\n\n# palettes/quantizers\nclass Palette(IntEnum):\n    WEB = 0\n    ADAPTIVE = 1\n\n\nclass Quantize(IntEnum):\n    MEDIANCUT = 0\n    MAXCOVERAGE = 1\n    FASTOCTREE = 2\n    LIBIMAGEQUANT = 3\n\n\nmodule = sys.modules[__name__]\nfor enum in (Transpose, Transform, Resampling, Dither, Palette, Quantize):\n    for item in enum:\n        setattr(module, item.name, item.value)\n\n\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED\n\n\n# --------------------------------------------------------------------\n# Registries\n\nif TYPE_CHECKING:\n    from . import ImageFile\nID: list[str] = []\nOPEN: dict[\n    str,\n    tuple[\n        Callable[[IO[bytes], str | bytes], ImageFile.ImageFile],\n        Callable[[bytes], bool | str] | None,\n    ],\n] = {}\nMIME: dict[str, str] = {}\nSAVE: dict[str, Callable[[Image, IO[bytes], str | bytes], None]] = {}\nSAVE_ALL: dict[str, Callable[[Image, IO[bytes], str | bytes], None]] = {}\nEXTENSION: dict[str, str] = {}\nDECODERS: dict[str, type[ImageFile.PyDecoder]] = {}\nENCODERS: dict[str, type[ImageFile.PyEncoder]] = {}\n\n# --------------------------------------------------------------------\n# Modes\n\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\n\n\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)\n    shape = (im.height, im.width)\n    extra = len(m.bands)\n    if extra != 1:\n        shape += (extra,)\n    return shape, m.typestr\n\n\nMODES = [\n    \"1\",\n    \"CMYK\",\n    \"F\",\n    \"HSV\",\n    \"I\",\n    \"I;16\",\n    \"I;16B\",\n    \"I;16L\",\n    \"I;16N\",\n    \"L\",\n    \"LA\",\n    \"La\",\n    \"LAB\",\n    \"P\",\n    \"PA\",\n    \"RGB\",\n    \"RGBA\",\n    \"RGBa\",\n    \"RGBX\",\n    \"YCbCr\",\n]\n\n# raw modes that may be memory mapped.  NOTE: if you change this, you\n# may have to modify the stride calculation in map.c too!\n_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\n\n\ndef getmodebase(mode: str) -> str:\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basemode\n\n\ndef getmodetype(mode: str) -> str:\n    \"\"\"\n    Gets the storage type mode.  Given a mode, this function returns a\n    single-layer mode suitable for storing individual bands.\n\n    :param mode: Input mode.\n    :returns: \"L\", \"I\", or \"F\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basetype\n\n\ndef getmodebandnames(mode: str) -> tuple[str, ...]:\n    \"\"\"\n    Gets a list of individual band names.  Given a mode, this function returns\n    a tuple containing the names of individual bands (use\n    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each\n    individual band.\n\n    :param mode: Input mode.\n    :returns: A tuple containing band names.  The length of the tuple\n        gives the number of bands in an image of the given mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).bands\n\n\ndef getmodebands(mode: str) -> int:\n    \"\"\"\n    Gets the number of individual bands for this mode.\n\n    :param mode: Input mode.\n    :returns: The number of bands in this mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return len(ImageMode.getmode(mode).bands)\n\n\n# --------------------------------------------------------------------\n# Helpers\n\n_initialized = 0\n\n\ndef preinit() -> None:\n    \"\"\"\n    Explicitly loads BMP, GIF, JPEG, PPM and PPM file format drivers.\n\n    It is called when opening or saving images.\n    \"\"\"\n\n    global _initialized\n    if _initialized >= 1:\n        return\n\n    try:\n        from . import BmpImagePlugin\n\n        assert BmpImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import GifImagePlugin\n\n        assert GifImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import JpegImagePlugin\n\n        assert JpegImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import PpmImagePlugin\n\n        assert PpmImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import PngImagePlugin\n\n        assert PngImagePlugin\n    except ImportError:\n        pass\n\n    _initialized = 1\n\n\ndef init() -> bool:\n    \"\"\"\n    Explicitly initializes the Python Imaging Library. This function\n    loads all available file format drivers.\n\n    It is called when opening or saving images if :py:meth:`~preinit()` is\n    insufficient, and by :py:meth:`~PIL.features.pilinfo`.\n    \"\"\"\n\n    global _initialized\n    if _initialized >= 2:\n        return False\n\n    parent_name = __name__.rpartition(\".\")[0]\n    for plugin in _plugins:\n        try:\n            logger.debug(\"Importing %s\", plugin)\n            __import__(f\"{parent_name}.{plugin}\", globals(), locals(), [])\n        except ImportError as e:\n            logger.debug(\"Image: failed to import %s: %s\", plugin, e)\n\n    if OPEN or SAVE:\n        _initialized = 2\n        return True\n    return False\n\n\n# --------------------------------------------------------------------\n# Codec factories (used by tobytes/frombytes and ImageFile.load)\n\n\ndef _getdecoder(\n    mode: str, decoder_name: str, args: Any, extra: tuple[Any, ...] = ()\n) -> core.ImagingDecoder | ImageFile.PyDecoder:\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        decoder = DECODERS[decoder_name]\n    except KeyError:\n        pass\n    else:\n        return decoder(mode, *args + extra)\n\n    try:\n        # get decoder\n        decoder = getattr(core, f\"{decoder_name}_decoder\")\n    except AttributeError as e:\n        msg = f\"decoder {decoder_name} not available\"\n        raise OSError(msg) from e\n    return decoder(mode, *args + extra)\n\n\ndef _getencoder(\n    mode: str, encoder_name: str, args: Any, extra: tuple[Any, ...] = ()\n) -> core.ImagingEncoder | ImageFile.PyEncoder:\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        encoder = ENCODERS[encoder_name]\n    except KeyError:\n        pass\n    else:\n        return encoder(mode, *args + extra)\n\n    try:\n        # get encoder\n        encoder = getattr(core, f\"{encoder_name}_encoder\")\n    except AttributeError as e:\n        msg = f\"encoder {encoder_name} not available\"\n        raise OSError(msg) from e\n    return encoder(mode, *args + extra)\n\n\n# --------------------------------------------------------------------\n# Simple expression analyzer\n\n\nclass _E:\n    def __init__(self, scale, offset) -> None:\n        self.scale = scale\n        self.offset = offset\n\n    def __neg__(self):\n        return _E(-self.scale, -self.offset)\n\n    def __add__(self, other):\n        if isinstance(other, _E):\n            return _E(self.scale + other.scale, self.offset + other.offset)\n        return _E(self.scale, self.offset + other)\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        return self + -other\n\n    def __rsub__(self, other):\n        return other + -self\n\n    def __mul__(self, other):\n        if isinstance(other, _E):\n            return NotImplemented\n        return _E(self.scale * other, self.offset * other)\n\n    __rmul__ = __mul__\n\n    def __truediv__(self, other):\n        if isinstance(other, _E):\n            return NotImplemented\n        return _E(self.scale / other, self.offset / other)\n\n\ndef _getscaleoffset(expr):\n    a = expr(_E(1, 0))\n    return (a.scale, a.offset) if isinstance(a, _E) else (0, a)\n\n\n# --------------------------------------------------------------------\n# Implementation wrapper\n\n\nclass SupportsGetData(Protocol):\n    def getdata(\n        self,\n    ) -> tuple[Transform, Sequence[int]]: ...\n\n\nclass Image:\n    \"\"\"\n    This class represents an image object.  To create\n    :py:class:`~PIL.Image.Image` objects, use the appropriate factory\n    functions.  There's hardly ever any reason to call the Image constructor\n    directly.\n\n    * :py:func:`~PIL.Image.open`\n    * :py:func:`~PIL.Image.new`\n    * :py:func:`~PIL.Image.frombytes`\n    \"\"\"\n\n    format: str | None = None\n    format_description: str | None = None\n    _close_exclusive_fp_after_loading = True\n\n    def __init__(self):\n        # FIXME: take \"new\" parameters / other image?\n        # FIXME: turn mode and size into delegating properties?\n        self.im = None\n        self._mode = \"\"\n        self._size = (0, 0)\n        self.palette = None\n        self.info = {}\n        self.readonly = 0\n        self.pyaccess = None\n        self._exif = None\n\n    @property\n    def width(self) -> int:\n        return self.size[0]\n\n    @property\n    def height(self) -> int:\n        return self.size[1]\n\n    @property\n    def size(self) -> tuple[int, int]:\n        return self._size\n\n    @property\n    def mode(self) -> str:\n        return self._mode\n\n    def _new(self, im: core.ImagingCore) -> Image:\n        new = Image()\n        new.im = im\n        new._mode = im.mode\n        new._size = im.size\n        if im.mode in (\"P\", \"PA\"):\n            if self.palette:\n                new.palette = self.palette.copy()\n            else:\n                from . import ImagePalette\n\n                new.palette = ImagePalette.ImagePalette()\n        new.info = self.info.copy()\n        return new\n\n    # Context manager support\n    def __enter__(self):\n        return self\n\n    def _close_fp(self):\n        if getattr(self, \"_fp\", False):\n            if self._fp != self.fp:\n                self._fp.close()\n            self._fp = DeferredError(ValueError(\"Operation on closed image\"))\n        if self.fp:\n            self.fp.close()\n\n    def __exit__(self, *args):\n        if hasattr(self, \"fp\"):\n            if getattr(self, \"_exclusive_fp\", False):\n                self._close_fp()\n            self.fp = None\n\n    def close(self) -> None:\n        \"\"\"\n        Closes the file pointer, if possible.\n\n        This operation will destroy the image core and release its memory.\n        The image data will be unusable afterward.\n\n        This function is required to close images that have multiple frames or\n        have not had their file read and closed by the\n        :py:meth:`~PIL.Image.Image.load` method. See :ref:`file-handling` for\n        more information.\n        \"\"\"\n        if hasattr(self, \"fp\"):\n            try:\n                self._close_fp()\n                self.fp = None\n            except Exception as msg:\n                logger.debug(\"Error closing: %s\", msg)\n\n        if getattr(self, \"map\", None):\n            self.map = None\n\n        # Instead of simply setting to None, we're setting up a\n        # deferred error that will better explain that the core image\n        # object is gone.\n        self.im = DeferredError(ValueError(\"Operation on closed image\"))\n\n    def _copy(self) -> None:\n        self.load()\n        self.im = self.im.copy()\n        self.pyaccess = None\n        self.readonly = 0\n\n    def _ensure_mutable(self) -> None:\n        if self.readonly:\n            self._copy()\n        else:\n            self.load()\n\n    def _dump(\n        self, file: str | None = None, format: str | None = None, **options: Any\n    ) -> str:\n        suffix = \"\"\n        if format:\n            suffix = f\".{format}\"\n\n        if not file:\n            f, filename = tempfile.mkstemp(suffix)\n            os.close(f)\n        else:\n            filename = file\n            if not filename.endswith(suffix):\n                filename = filename + suffix\n\n        self.load()\n\n        if not format or format == \"PPM\":\n            self.im.save_ppm(filename)\n        else:\n            self.save(filename, format, **options)\n\n        return filename\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return False\n        assert isinstance(other, Image)\n        return (\n            self.mode == other.mode\n            and self.size == other.size\n            and self.info == other.info\n            and self.getpalette() == other.getpalette()\n            and self.tobytes() == other.tobytes()\n        )\n\n    def __repr__(self) -> str:\n        return \"<%s.%s image mode=%s size=%dx%d at 0x%X>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self.mode,\n            self.size[0],\n            self.size[1],\n            id(self),\n        )\n\n    def _repr_pretty_(self, p, cycle) -> None:\n        \"\"\"IPython plain text display support\"\"\"\n\n        # Same as __repr__ but without unpredictable id(self),\n        # to keep Jupyter notebook `text/plain` output stable.\n        p.text(\n            \"<%s.%s image mode=%s size=%dx%d>\"\n            % (\n                self.__class__.__module__,\n                self.__class__.__name__,\n                self.mode,\n                self.size[0],\n                self.size[1],\n            )\n        )\n\n    def _repr_image(self, image_format: str, **kwargs: Any) -> bytes | None:\n        \"\"\"Helper function for iPython display hook.\n\n        :param image_format: Image format.\n        :returns: image as bytes, saved into the given format.\n        \"\"\"\n        b = io.BytesIO()\n        try:\n            self.save(b, image_format, **kwargs)\n        except Exception:\n            return None\n        return b.getvalue()\n\n    def _repr_png_(self) -> bytes | None:\n        \"\"\"iPython display hook support for PNG format.\n\n        :returns: PNG version of the image as bytes\n        \"\"\"\n        return self._repr_image(\"PNG\", compress_level=1)\n\n    def _repr_jpeg_(self) -> bytes | None:\n        \"\"\"iPython display hook support for JPEG format.\n\n        :returns: JPEG version of the image as bytes\n        \"\"\"\n        return self._repr_image(\"JPEG\")\n\n    @property\n    def __array_interface__(self):\n        # numpy array interface support\n        new = {\"version\": 3}\n        try:\n            if self.mode == \"1\":\n                # Binary images need to be extended from bits to bytes\n                # See: https://github.com/python-pillow/Pillow/issues/350\n                new[\"data\"] = self.tobytes(\"raw\", \"L\")\n            else:\n                new[\"data\"] = self.tobytes()\n        except Exception as e:\n            if not isinstance(e, (MemoryError, RecursionError)):\n                try:\n                    import numpy\n                    from packaging.version import parse as parse_version\n                except ImportError:\n                    pass\n                else:\n                    if parse_version(numpy.__version__) < parse_version(\"1.23\"):\n                        warnings.warn(str(e))\n            raise\n        new[\"shape\"], new[\"typestr\"] = _conv_type_shape(self)\n        return new\n\n    def __getstate__(self):\n        im_data = self.tobytes()  # load image first\n        return [self.info, self.mode, self.size, self.getpalette(), im_data]\n\n    def __setstate__(self, state) -> None:\n        Image.__init__(self)\n        info, mode, size, palette, data = state\n        self.info = info\n        self._mode = mode\n        self._size = size\n        self.im = core.new(mode, size)\n        if mode in (\"L\", \"LA\", \"P\", \"PA\") and palette:\n            self.putpalette(palette)\n        self.frombytes(data)\n\n    def tobytes(self, encoder_name: str = \"raw\", *args: Any) -> bytes:\n        \"\"\"\n        Return image as a bytes object.\n\n        .. warning::\n\n            This method returns the raw image data from the internal\n            storage.  For compressed image data (e.g. PNG, JPEG) use\n            :meth:`~.save`, with a BytesIO parameter for in-memory\n            data.\n\n        :param encoder_name: What encoder to use.  The default is to\n                             use the standard \"raw\" encoder.\n\n                             A list of C encoders can be seen under\n                             codecs section of the function array in\n                             :file:`_imaging.c`. Python encoders are\n                             registered within the relevant plugins.\n        :param args: Extra arguments to the encoder.\n        :returns: A :py:class:`bytes` object.\n        \"\"\"\n\n        encoder_args: Any = args\n        if len(encoder_args) == 1 and isinstance(encoder_args[0], tuple):\n            # may pass tuple instead of argument list\n            encoder_args = encoder_args[0]\n\n        if encoder_name == \"raw\" and encoder_args == ():\n            encoder_args = self.mode\n\n        self.load()\n\n        if self.width == 0 or self.height == 0:\n            return b\"\"\n\n        # unpack data\n        e = _getencoder(self.mode, encoder_name, encoder_args)\n        e.setimage(self.im)\n\n        bufsize = max(65536, self.size[0] * 4)  # see RawEncode.c\n\n        output = []\n        while True:\n            bytes_consumed, errcode, data = e.encode(bufsize)\n            output.append(data)\n            if errcode:\n                break\n        if errcode < 0:\n            msg = f\"encoder error {errcode} in tobytes\"\n            raise RuntimeError(msg)\n\n        return b\"\".join(output)\n\n    def tobitmap(self, name: str = \"image\") -> bytes:\n        \"\"\"\n        Returns the image converted to an X11 bitmap.\n\n        .. note:: This method only works for mode \"1\" images.\n\n        :param name: The name prefix to use for the bitmap variables.\n        :returns: A string containing an X11 bitmap.\n        :raises ValueError: If the mode is not \"1\"\n        \"\"\"\n\n        self.load()\n        if self.mode != \"1\":\n            msg = \"not a bitmap\"\n            raise ValueError(msg)\n        data = self.tobytes(\"xbm\")\n        return b\"\".join(\n            [\n                f\"#define {name}_width {self.size[0]}\\n\".encode(\"ascii\"),\n                f\"#define {name}_height {self.size[1]}\\n\".encode(\"ascii\"),\n                f\"static char {name}_bits[] = {{\\n\".encode(\"ascii\"),\n                data,\n                b\"};\",\n            ]\n        )\n\n    def frombytes(\n        self, data: bytes | bytearray, decoder_name: str = \"raw\", *args: Any\n    ) -> None:\n        \"\"\"\n        Loads this image with pixel data from a bytes object.\n\n        This method is similar to the :py:func:`~PIL.Image.frombytes` function,\n        but loads data into this image instead of creating a new image object.\n        \"\"\"\n\n        if self.width == 0 or self.height == 0:\n            return\n\n        decoder_args: Any = args\n        if len(decoder_args) == 1 and isinstance(decoder_args[0], tuple):\n            # may pass tuple instead of argument list\n            decoder_args = decoder_args[0]\n\n        # default format\n        if decoder_name == \"raw\" and decoder_args == ():\n            decoder_args = self.mode\n\n        # unpack data\n        d = _getdecoder(self.mode, decoder_name, decoder_args)\n        d.setimage(self.im)\n        s = d.decode(data)\n\n        if s[0] >= 0:\n            msg = \"not enough image data\"\n            raise ValueError(msg)\n        if s[1] != 0:\n            msg = \"cannot decode image data\"\n            raise ValueError(msg)\n\n    def load(self):\n        \"\"\"\n        Allocates storage for the image and loads the pixel data.  In\n        normal cases, you don't need to call this method, since the\n        Image class automatically loads an opened image when it is\n        accessed for the first time.\n\n        If the file associated with the image was opened by Pillow, then this\n        method will close it. The exception to this is if the image has\n        multiple frames, in which case the file will be left open for seek\n        operations. See :ref:`file-handling` for more information.\n\n        :returns: An image access object.\n        :rtype: :ref:`PixelAccess` or :py:class:`PIL.PyAccess`\n        \"\"\"\n        if self.im is not None and self.palette and self.palette.dirty:\n            # realize palette\n            mode, arr = self.palette.getdata()\n            self.im.putpalette(self.palette.mode, mode, arr)\n            self.palette.dirty = 0\n            self.palette.rawmode = None\n            if \"transparency\" in self.info and mode in (\"LA\", \"PA\"):\n                if isinstance(self.info[\"transparency\"], int):\n                    self.im.putpalettealpha(self.info[\"transparency\"], 0)\n                else:\n                    self.im.putpalettealphas(self.info[\"transparency\"])\n                self.palette.mode = \"RGBA\"\n            else:\n                self.palette.palette = self.im.getpalette(\n                    self.palette.mode, self.palette.mode\n                )\n\n        if self.im is not None:\n            if cffi and USE_CFFI_ACCESS:\n                if self.pyaccess:\n                    return self.pyaccess\n                from . import PyAccess\n\n                self.pyaccess = PyAccess.new(self, self.readonly)\n                if self.pyaccess:\n                    return self.pyaccess\n            return self.im.pixel_access(self.readonly)\n\n    def verify(self) -> None:\n        \"\"\"\n        Verifies the contents of a file. For data read from a file, this\n        method attempts to determine if the file is broken, without\n        actually decoding the image data.  If this method finds any\n        problems, it raises suitable exceptions.  If you need to load\n        the image after using this method, you must reopen the image\n        file.\n        \"\"\"\n        pass\n\n    def convert(\n        self,\n        mode: str | None = None,\n        matrix: tuple[float, ...] | None = None,\n        dither: Dither | None = None,\n        palette: Palette = Palette.WEB,\n        colors: int = 256,\n    ) -> Image:\n        \"\"\"\n        Returns a converted copy of this image. For the \"P\" mode, this\n        method translates pixels through the palette.  If mode is\n        omitted, a mode is chosen so that all information in the image\n        and the palette can be represented without a palette.\n\n        This supports all possible conversions between \"L\", \"RGB\" and \"CMYK\". The\n        ``matrix`` argument only supports \"L\" and \"RGB\".\n\n        When translating a color image to grayscale (mode \"L\"),\n        the library uses the ITU-R 601-2 luma transform::\n\n            L = R * 299/1000 + G * 587/1000 + B * 114/1000\n\n        The default method of converting a grayscale (\"L\") or \"RGB\"\n        image into a bilevel (mode \"1\") image uses Floyd-Steinberg\n        dither to approximate the original image luminosity levels. If\n        dither is ``None``, all values larger than 127 are set to 255 (white),\n        all other values to 0 (black). To use other thresholds, use the\n        :py:meth:`~PIL.Image.Image.point` method.\n\n        When converting from \"RGBA\" to \"P\" without a ``matrix`` argument,\n        this passes the operation to :py:meth:`~PIL.Image.Image.quantize`,\n        and ``dither`` and ``palette`` are ignored.\n\n        When converting from \"PA\", if an \"RGBA\" palette is present, the alpha\n        channel from the image will be used instead of the values from the palette.\n\n        :param mode: The requested mode. See: :ref:`concept-modes`.\n        :param matrix: An optional conversion matrix.  If given, this\n           should be 4- or 12-tuple containing floating point values.\n        :param dither: Dithering method, used when converting from\n           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n           (default). Note that this is not used when ``matrix`` is supplied.\n        :param palette: Palette to use when converting from mode \"RGB\"\n           to \"P\".  Available palettes are :data:`Palette.WEB` or\n           :data:`Palette.ADAPTIVE`.\n        :param colors: Number of colors to use for the :data:`Palette.ADAPTIVE`\n           palette. Defaults to 256.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if mode in (\"BGR;15\", \"BGR;16\", \"BGR;24\"):\n            deprecate(mode, 12)\n\n        self.load()\n\n        has_transparency = \"transparency\" in self.info\n        if not mode and self.mode == \"P\":\n            # determine default mode\n            if self.palette:\n                mode = self.palette.mode\n            else:\n                mode = \"RGB\"\n            if mode == \"RGB\" and has_transparency:\n                mode = \"RGBA\"\n        if not mode or (mode == self.mode and not matrix):\n            return self.copy()\n\n        if matrix:\n            # matrix conversion\n            if mode not in (\"L\", \"RGB\"):\n                msg = \"illegal conversion\"\n                raise ValueError(msg)\n            im = self.im.convert_matrix(mode, matrix)\n            new_im = self._new(im)\n            if has_transparency and self.im.bands == 3:\n                transparency = new_im.info[\"transparency\"]\n\n                def convert_transparency(\n                    m: tuple[float, ...], v: tuple[int, int, int]\n                ) -> int:\n                    value = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * 0.5\n                    return max(0, min(255, int(value)))\n\n                if mode == \"L\":\n                    transparency = convert_transparency(matrix, transparency)\n                elif len(mode) == 3:\n                    transparency = tuple(\n                        convert_transparency(matrix[i * 4 : i * 4 + 4], transparency)\n                        for i in range(0, len(transparency))\n                    )\n                new_im.info[\"transparency\"] = transparency\n            return new_im\n\n        if mode == \"P\" and self.mode == \"RGBA\":\n            return self.quantize(colors)\n\n        trns = None\n        delete_trns = False\n        # transparency handling\n        if has_transparency:\n            if (self.mode in (\"1\", \"L\", \"I\", \"I;16\") and mode in (\"LA\", \"RGBA\")) or (\n                self.mode == \"RGB\" and mode in (\"La\", \"LA\", \"RGBa\", \"RGBA\")\n            ):\n                # Use transparent conversion to promote from transparent\n                # color to an alpha channel.\n                new_im = self._new(\n                    self.im.convert_transparent(mode, self.info[\"transparency\"])\n                )\n                del new_im.info[\"transparency\"]\n                return new_im\n            elif self.mode in (\"L\", \"RGB\", \"P\") and mode in (\"L\", \"RGB\", \"P\"):\n                t = self.info[\"transparency\"]\n                if isinstance(t, bytes):\n                    # Dragons. This can't be represented by a single color\n                    warnings.warn(\n                        \"Palette images with Transparency expressed in bytes should be \"\n                        \"converted to RGBA images\"\n                    )\n                    delete_trns = True\n                else:\n                    # get the new transparency color.\n                    # use existing conversions\n                    trns_im = new(self.mode, (1, 1))\n                    if self.mode == \"P\":\n                        trns_im.putpalette(self.palette)\n                        if isinstance(t, tuple):\n                            err = \"Couldn't allocate a palette color for transparency\"\n                            try:\n                                t = trns_im.palette.getcolor(t, self)\n                            except ValueError as e:\n                                if str(e) == \"cannot allocate more than 256 colors\":\n                                    # If all 256 colors are in use,\n                                    # then there is no need for transparency\n                                    t = None\n                                else:\n                                    raise ValueError(err) from e\n                    if t is None:\n                        trns = None\n                    else:\n                        trns_im.putpixel((0, 0), t)\n\n                        if mode in (\"L\", \"RGB\"):\n                            trns_im = trns_im.convert(mode)\n                        else:\n                            # can't just retrieve the palette number, got to do it\n                            # after quantization.\n                            trns_im = trns_im.convert(\"RGB\")\n                        trns = trns_im.getpixel((0, 0))\n\n            elif self.mode == \"P\" and mode in (\"LA\", \"PA\", \"RGBA\"):\n                t = self.info[\"transparency\"]\n                delete_trns = True\n\n                if isinstance(t, bytes):\n                    self.im.putpalettealphas(t)\n                elif isinstance(t, int):\n                    self.im.putpalettealpha(t, 0)\n                else:\n                    msg = \"Transparency for P mode should be bytes or int\"\n                    raise ValueError(msg)\n\n        if mode == \"P\" and palette == Palette.ADAPTIVE:\n            im = self.im.quantize(colors)\n            new_im = self._new(im)\n            from . import ImagePalette\n\n            new_im.palette = ImagePalette.ImagePalette(\n                \"RGB\", new_im.im.getpalette(\"RGB\")\n            )\n            if delete_trns:\n                # This could possibly happen if we requantize to fewer colors.\n                # The transparency would be totally off in that case.\n                del new_im.info[\"transparency\"]\n            if trns is not None:\n                try:\n                    new_im.info[\"transparency\"] = new_im.palette.getcolor(trns, new_im)\n                except Exception:\n                    # if we can't make a transparent color, don't leave the old\n                    # transparency hanging around to mess us up.\n                    del new_im.info[\"transparency\"]\n                    warnings.warn(\"Couldn't allocate palette entry for transparency\")\n            return new_im\n\n        if \"LAB\" in (self.mode, mode):\n            other_mode = mode if self.mode == \"LAB\" else self.mode\n            if other_mode in (\"RGB\", \"RGBA\", \"RGBX\"):\n                from . import ImageCms\n\n                srgb = ImageCms.createProfile(\"sRGB\")\n                lab = ImageCms.createProfile(\"LAB\")\n                profiles = [lab, srgb] if self.mode == \"LAB\" else [srgb, lab]\n                transform = ImageCms.buildTransform(\n                    profiles[0], profiles[1], self.mode, mode\n                )\n                return transform.apply(self)\n\n        # colorspace conversion\n        if dither is None:\n            dither = Dither.FLOYDSTEINBERG\n\n        try:\n            im = self.im.convert(mode, dither)\n        except ValueError:\n            try:\n                # normalize source image and try again\n                modebase = getmodebase(self.mode)\n                if modebase == self.mode:\n                    raise\n                im = self.im.convert(modebase)\n                im = im.convert(mode, dither)\n            except KeyError as e:\n                msg = \"illegal conversion\"\n                raise ValueError(msg) from e\n\n        new_im = self._new(im)\n        if mode == \"P\" and palette != Palette.ADAPTIVE:\n            from . import ImagePalette\n\n            new_im.palette = ImagePalette.ImagePalette(\"RGB\", im.getpalette(\"RGB\"))\n        if delete_trns:\n            # crash fail if we leave a bytes transparency in an rgb/l mode.\n            del new_im.info[\"transparency\"]\n        if trns is not None:\n            if new_im.mode == \"P\":\n                try:\n                    new_im.info[\"transparency\"] = new_im.palette.getcolor(trns, new_im)\n                except ValueError as e:\n                    del new_im.info[\"transparency\"]\n                    if str(e) != \"cannot allocate more than 256 colors\":\n                        # If all 256 colors are in use,\n                        # then there is no need for transparency\n                        warnings.warn(\n                            \"Couldn't allocate palette entry for transparency\"\n                        )\n            else:\n                new_im.info[\"transparency\"] = trns\n        return new_im\n\n    def quantize(\n        self,\n        colors: int = 256,\n        method: int | None = None,\n        kmeans: int = 0,\n        palette=None,\n        dither: Dither = Dither.FLOYDSTEINBERG,\n    ) -> Image:\n        \"\"\"\n        Convert the image to 'P' mode with the specified number\n        of colors.\n\n        :param colors: The desired number of colors, <= 256\n        :param method: :data:`Quantize.MEDIANCUT` (median cut),\n                       :data:`Quantize.MAXCOVERAGE` (maximum coverage),\n                       :data:`Quantize.FASTOCTREE` (fast octree),\n                       :data:`Quantize.LIBIMAGEQUANT` (libimagequant; check support\n                       using :py:func:`PIL.features.check_feature` with\n                       ``feature=\"libimagequant\"``).\n\n                       By default, :data:`Quantize.MEDIANCUT` will be used.\n\n                       The exception to this is RGBA images. :data:`Quantize.MEDIANCUT`\n                       and :data:`Quantize.MAXCOVERAGE` do not support RGBA images, so\n                       :data:`Quantize.FASTOCTREE` is used by default instead.\n        :param kmeans: Integer greater than or equal to zero.\n        :param palette: Quantize to the palette of given\n                        :py:class:`PIL.Image.Image`.\n        :param dither: Dithering method, used when converting from\n           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n           (default).\n        :returns: A new image\n        \"\"\"\n\n        self.load()\n\n        if method is None:\n            # defaults:\n            method = Quantize.MEDIANCUT\n            if self.mode == \"RGBA\":\n                method = Quantize.FASTOCTREE\n\n        if self.mode == \"RGBA\" and method not in (\n            Quantize.FASTOCTREE,\n            Quantize.LIBIMAGEQUANT,\n        ):\n            # Caller specified an invalid mode.\n            msg = (\n                \"Fast Octree (method == 2) and libimagequant (method == 3) \"\n                \"are the only valid methods for quantizing RGBA images\"\n            )\n            raise ValueError(msg)\n\n        if palette:\n            # use palette from reference image\n            palette.load()\n            if palette.mode != \"P\":\n                msg = \"bad mode for palette image\"\n                raise ValueError(msg)\n            if self.mode not in {\"RGB\", \"L\"}:\n                msg = \"only RGB or L mode images can be quantized to a palette\"\n                raise ValueError(msg)\n            im = self.im.convert(\"P\", dither, palette.im)\n            new_im = self._new(im)\n            new_im.palette = palette.palette.copy()\n            return new_im\n\n        if kmeans < 0:\n            msg = \"kmeans must not be negative\"\n            raise ValueError(msg)\n\n        im = self._new(self.im.quantize(colors, method, kmeans))\n\n        from . import ImagePalette\n\n        mode = im.im.getpalettemode()\n        palette = im.im.getpalette(mode, mode)[: colors * len(mode)]\n        im.palette = ImagePalette.ImagePalette(mode, palette)\n\n        return im\n\n    def copy(self) -> Image:\n        \"\"\"\n        Copies this image. Use this method if you wish to paste things\n        into an image, but still retain the original.\n\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n        self.load()\n        return self._new(self.im.copy())\n\n    __copy__ = copy\n\n    def crop(self, box: tuple[float, float, float, float] | None = None) -> Image:\n        \"\"\"\n        Returns a rectangular region from this image. The box is a\n        4-tuple defining the left, upper, right, and lower pixel\n        coordinate. See :ref:`coordinate-system`.\n\n        Note: Prior to Pillow 3.4.0, this was a lazy operation.\n\n        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if box is None:\n            return self.copy()\n\n        if box[2] < box[0]:\n            msg = \"Coordinate 'right' is less than 'left'\"\n            raise ValueError(msg)\n        elif box[3] < box[1]:\n            msg = \"Coordinate 'lower' is less than 'upper'\"\n            raise ValueError(msg)\n\n        self.load()\n        return self._new(self._crop(self.im, box))\n\n    def _crop(\n        self, im: core.ImagingCore, box: tuple[float, float, float, float]\n    ) -> core.ImagingCore:\n        \"\"\"\n        Returns a rectangular region from the core image object im.\n\n        This is equivalent to calling im.crop((x0, y0, x1, y1)), but\n        includes additional sanity checks.\n\n        :param im: a core image object\n        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n        :returns: A core image object.\n        \"\"\"\n\n        x0, y0, x1, y1 = map(int, map(round, box))\n\n        absolute_values = (abs(x1 - x0), abs(y1 - y0))\n\n        _decompression_bomb_check(absolute_values)\n\n        return im.crop((x0, y0, x1, y1))\n\n    def draft(\n        self, mode: str | None, size: tuple[int, int] | None\n    ) -> tuple[str, tuple[int, int, float, float]] | None:\n        \"\"\"\n        Configures the image file loader so it returns a version of the\n        image that as closely as possible matches the given mode and\n        size. For example, you can use this method to convert a color\n        JPEG to grayscale while loading it.\n\n        If any changes are made, returns a tuple with the chosen ``mode`` and\n        ``box`` with coordinates of the original image within the altered one.\n\n        Note that this method modifies the :py:class:`~PIL.Image.Image` object\n        in place. If the image has already been loaded, this method has no\n        effect.\n\n        Note: This method is not implemented for most images. It is\n        currently implemented only for JPEG and MPO images.\n\n        :param mode: The requested mode.\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        \"\"\"\n        pass\n\n    def _expand(self, xmargin: int, ymargin: int | None = None) -> Image:\n        if ymargin is None:\n            ymargin = xmargin\n        self.load()\n        return self._new(self.im.expand(xmargin, ymargin))\n\n    if TYPE_CHECKING:\n        from . import ImageFilter\n\n    def filter(self, filter: ImageFilter.Filter | type[ImageFilter.Filter]) -> Image:\n        \"\"\"\n        Filters this image using the given filter.  For a list of\n        available filters, see the :py:mod:`~PIL.ImageFilter` module.\n\n        :param filter: Filter kernel.\n        :returns: An :py:class:`~PIL.Image.Image` object.\"\"\"\n\n        from . import ImageFilter\n\n        self.load()\n\n        if callable(filter):\n            filter = filter()\n        if not hasattr(filter, \"filter\"):\n            msg = \"filter argument should be ImageFilter.Filter instance or class\"\n            raise TypeError(msg)\n\n        multiband = isinstance(filter, ImageFilter.MultibandFilter)\n        if self.im.bands == 1 or multiband:\n            return self._new(filter.filter(self.im))\n\n        ims = [\n            self._new(filter.filter(self.im.getband(c))) for c in range(self.im.bands)\n        ]\n        return merge(self.mode, ims)\n\n    def getbands(self) -> tuple[str, ...]:\n        \"\"\"\n        Returns a tuple containing the name of each band in this image.\n        For example, ``getbands`` on an RGB image returns (\"R\", \"G\", \"B\").\n\n        :returns: A tuple containing band names.\n        :rtype: tuple\n        \"\"\"\n        return ImageMode.getmode(self.mode).bands\n\n    def getbbox(self, *, alpha_only: bool = True) -> tuple[int, int, int, int] | None:\n        \"\"\"\n        Calculates the bounding box of the non-zero regions in the\n        image.\n\n        :param alpha_only: Optional flag, defaulting to ``True``.\n           If ``True`` and the image has an alpha channel, trim transparent pixels.\n           Otherwise, trim pixels when all channels are zero.\n           Keyword-only argument.\n        :returns: The bounding box is returned as a 4-tuple defining the\n           left, upper, right, and lower pixel coordinate. See\n           :ref:`coordinate-system`. If the image is completely empty, this\n           method returns None.\n\n        \"\"\"\n\n        self.load()\n        return self.im.getbbox(alpha_only)\n\n    def getcolors(self, maxcolors: int = 256):\n        \"\"\"\n        Returns a list of colors used in this image.\n\n        The colors will be in the image's mode. For example, an RGB image will\n        return a tuple of (red, green, blue) color values, and a P image will\n        return the index of the color in the palette.\n\n        :param maxcolors: Maximum number of colors.  If this number is\n           exceeded, this method returns None.  The default limit is\n           256 colors.\n        :returns: An unsorted list of (count, pixel) values.\n        \"\"\"\n\n        self.load()\n        if self.mode in (\"1\", \"L\", \"P\"):\n            h = self.im.histogram()\n            out = [(h[i], i) for i in range(256) if h[i]]\n            if len(out) > maxcolors:\n                return None\n            return out\n        return self.im.getcolors(maxcolors)\n\n    def getdata(self, band: int | None = None):\n        \"\"\"\n        Returns the contents of this image as a sequence object\n        containing pixel values.  The sequence object is flattened, so\n        that values for line one follow directly after the values of\n        line zero, and so on.\n\n        Note that the sequence object returned by this method is an\n        internal PIL data type, which only supports certain sequence\n        operations.  To convert it to an ordinary sequence (e.g. for\n        printing), use ``list(im.getdata())``.\n\n        :param band: What band to return.  The default is to return\n           all bands.  To return a single band, pass in the index\n           value (e.g. 0 to get the \"R\" band from an \"RGB\" image).\n        :returns: A sequence-like object.\n        \"\"\"\n\n        self.load()\n        if band is not None:\n            return self.im.getband(band)\n        return self.im  # could be abused\n\n    def getextrema(self) -> tuple[float, float] | tuple[tuple[int, int], ...]:\n        \"\"\"\n        Gets the minimum and maximum pixel values for each band in\n        the image.\n\n        :returns: For a single-band image, a 2-tuple containing the\n           minimum and maximum pixel value.  For a multi-band image,\n           a tuple containing one 2-tuple for each band.\n        \"\"\"\n\n        self.load()\n        if self.im.bands > 1:\n            return tuple(self.im.getband(i).getextrema() for i in range(self.im.bands))\n        return self.im.getextrema()\n\n    def getxmp(self):\n        \"\"\"\n        Returns a dictionary containing the XMP tags.\n        Requires defusedxml to be installed.\n\n        :returns: XMP tags in a dictionary.\n        \"\"\"\n\n        def get_name(tag: str) -> str:\n            return re.sub(\"^{[^}]+}\", \"\", tag)\n\n        def get_value(element):\n            value = {get_name(k): v for k, v in element.attrib.items()}\n            children = list(element)\n            if children:\n                for child in children:\n                    name = get_name(child.tag)\n                    child_value = get_value(child)\n                    if name in value:\n                        if not isinstance(value[name], list):\n                            value[name] = [value[name]]\n                        value[name].append(child_value)\n                    else:\n                        value[name] = child_value\n            elif value:\n                if element.text:\n                    value[\"text\"] = element.text\n            else:\n                return element.text\n            return value\n\n        if ElementTree is None:\n            warnings.warn(\"XMP data cannot be read without defusedxml dependency\")\n            return {}\n        if \"xmp\" not in self.info:\n            return {}\n        root = ElementTree.fromstring(self.info[\"xmp\"])\n        return {get_name(root.tag): get_value(root)}\n\n    def getexif(self) -> Exif:\n        \"\"\"\n        Gets EXIF data from the image.\n\n        :returns: an :py:class:`~PIL.Image.Exif` object.\n        \"\"\"\n        if self._exif is None:\n            self._exif = Exif()\n        elif self._exif._loaded:\n            return self._exif\n        self._exif._loaded = True\n\n        exif_info = self.info.get(\"exif\")\n        if exif_info is None:\n            if \"Raw profile type exif\" in self.info:\n                exif_info = bytes.fromhex(\n                    \"\".join(self.info[\"Raw profile type exif\"].split(\"\\n\")[3:])\n                )\n            elif hasattr(self, \"tag_v2\"):\n                self._exif.bigtiff = self.tag_v2._bigtiff\n                self._exif.endian = self.tag_v2._endian\n                self._exif.load_from_fp(self.fp, self.tag_v2._offset)\n        if exif_info is not None:\n            self._exif.load(exif_info)\n\n        # XMP tags\n        if ExifTags.Base.Orientation not in self._exif:\n            xmp_tags = self.info.get(\"XML:com.adobe.xmp\")\n            if xmp_tags:\n                match = re.search(r'tiff:Orientation(=\"|>)([0-9])', xmp_tags)\n                if match:\n                    self._exif[ExifTags.Base.Orientation] = int(match[2])\n\n        return self._exif\n\n    def _reload_exif(self) -> None:\n        if self._exif is None or not self._exif._loaded:\n            return\n        self._exif._loaded = False\n        self.getexif()\n\n    def get_child_images(self) -> list[ImageFile.ImageFile]:\n        child_images = []\n        exif = self.getexif()\n        ifds = []\n        if ExifTags.Base.SubIFDs in exif:\n            subifd_offsets = exif[ExifTags.Base.SubIFDs]\n            if subifd_offsets:\n                if not isinstance(subifd_offsets, tuple):\n                    subifd_offsets = (subifd_offsets,)\n                for subifd_offset in subifd_offsets:\n                    ifds.append((exif._get_ifd_dict(subifd_offset), subifd_offset))\n        ifd1 = exif.get_ifd(ExifTags.IFD.IFD1)\n        if ifd1 and ifd1.get(513):\n            ifds.append((ifd1, exif._info.next))\n\n        offset = None\n        for ifd, ifd_offset in ifds:\n            current_offset = self.fp.tell()\n            if offset is None:\n                offset = current_offset\n\n            fp = self.fp\n            thumbnail_offset = ifd.get(513)\n            if thumbnail_offset is not None:\n                thumbnail_offset += getattr(self, \"_exif_offset\", 0)\n                self.fp.seek(thumbnail_offset)\n                data = self.fp.read(ifd.get(514))\n                fp = io.BytesIO(data)\n\n            with open(fp) as im:\n                from . import TiffImagePlugin\n\n                if thumbnail_offset is None and isinstance(\n                    im, TiffImagePlugin.TiffImageFile\n                ):\n                    im._frame_pos = [ifd_offset]\n                    im._seek(0)\n                im.load()\n                child_images.append(im)\n\n        if offset is not None:\n            self.fp.seek(offset)\n        return child_images\n\n    def getim(self):\n        \"\"\"\n        Returns a capsule that points to the internal image memory.\n\n        :returns: A capsule object.\n        \"\"\"\n\n        self.load()\n        return self.im.ptr\n\n    def getpalette(self, rawmode: str | None = \"RGB\") -> list[int] | None:\n        \"\"\"\n        Returns the image palette as a list.\n\n        :param rawmode: The mode in which to return the palette. ``None`` will\n           return the palette in its current mode.\n\n           .. versionadded:: 9.1.0\n\n        :returns: A list of color values [r, g, b, ...], or None if the\n           image has no palette.\n        \"\"\"\n\n        self.load()\n        try:\n            mode = self.im.getpalettemode()\n        except ValueError:\n            return None  # no palette\n        if rawmode is None:\n            rawmode = mode\n        return list(self.im.getpalette(mode, rawmode))\n\n    @property\n    def has_transparency_data(self) -> bool:\n        \"\"\"\n        Determine if an image has transparency data, whether in the form of an\n        alpha channel, a palette with an alpha channel, or a \"transparency\" key\n        in the info dictionary.\n\n        Note the image might still appear solid, if all of the values shown\n        within are opaque.\n\n        :returns: A boolean.\n        \"\"\"\n        return (\n            self.mode in (\"LA\", \"La\", \"PA\", \"RGBA\", \"RGBa\")\n            or (self.mode == \"P\" and self.palette.mode.endswith(\"A\"))\n            or \"transparency\" in self.info\n        )\n\n    def apply_transparency(self) -> None:\n        \"\"\"\n        If a P mode image has a \"transparency\" key in the info dictionary,\n        remove the key and instead apply the transparency to the palette.\n        Otherwise, the image is unchanged.\n        \"\"\"\n        if self.mode != \"P\" or \"transparency\" not in self.info:\n            return\n\n        from . import ImagePalette\n\n        palette = self.getpalette(\"RGBA\")\n        assert palette is not None\n        transparency = self.info[\"transparency\"]\n        if isinstance(transparency, bytes):\n            for i, alpha in enumerate(transparency):\n                palette[i * 4 + 3] = alpha\n        else:\n            palette[transparency * 4 + 3] = 0\n        self.palette = ImagePalette.ImagePalette(\"RGBA\", bytes(palette))\n        self.palette.dirty = 1\n\n        del self.info[\"transparency\"]\n\n    def getpixel(self, xy):\n        \"\"\"\n        Returns the pixel value at a given position.\n\n        :param xy: The coordinate, given as (x, y). See\n           :ref:`coordinate-system`.\n        :returns: The pixel value.  If the image is a multi-layer image,\n           this method returns a tuple.\n        \"\"\"\n\n        self.load()\n        if self.pyaccess:\n            return self.pyaccess.getpixel(xy)\n        return self.im.getpixel(tuple(xy))\n\n    def getprojection(self) -> tuple[list[int], list[int]]:\n        \"\"\"\n        Get projection to x and y axes\n\n        :returns: Two sequences, indicating where there are non-zero\n            pixels along the X-axis and the Y-axis, respectively.\n        \"\"\"\n\n        self.load()\n        x, y = self.im.getprojection()\n        return list(x), list(y)\n\n    def histogram(self, mask: Image | None = None, extrema=None) -> list[int]:\n        \"\"\"\n        Returns a histogram for the image. The histogram is returned as a\n        list of pixel counts, one for each pixel value in the source\n        image. Counts are grouped into 256 bins for each band, even if\n        the image has more than 8 bits per band. If the image has more\n        than one band, the histograms for all bands are concatenated (for\n        example, the histogram for an \"RGB\" image contains 768 values).\n\n        A bilevel image (mode \"1\") is treated as a grayscale (\"L\") image\n        by this method.\n\n        If a mask is provided, the method returns a histogram for those\n        parts of the image where the mask image is non-zero. The mask\n        image must have the same size as the image, and be either a\n        bi-level image (mode \"1\") or a grayscale image (\"L\").\n\n        :param mask: An optional mask.\n        :param extrema: An optional tuple of manually-specified extrema.\n        :returns: A list containing pixel counts.\n        \"\"\"\n        self.load()\n        if mask:\n            mask.load()\n            return self.im.histogram((0, 0), mask.im)\n        if self.mode in (\"I\", \"F\"):\n            if extrema is None:\n                extrema = self.getextrema()\n            return self.im.histogram(extrema)\n        return self.im.histogram()\n\n    def entropy(self, mask=None, extrema=None):\n        \"\"\"\n        Calculates and returns the entropy for the image.\n\n        A bilevel image (mode \"1\") is treated as a grayscale (\"L\")\n        image by this method.\n\n        If a mask is provided, the method employs the histogram for\n        those parts of the image where the mask image is non-zero.\n        The mask image must have the same size as the image, and be\n        either a bi-level image (mode \"1\") or a grayscale image (\"L\").\n\n        :param mask: An optional mask.\n        :param extrema: An optional tuple of manually-specified extrema.\n        :returns: A float value representing the image entropy\n        \"\"\"\n        self.load()\n        if mask:\n            mask.load()\n            return self.im.entropy((0, 0), mask.im)\n        if self.mode in (\"I\", \"F\"):\n            if extrema is None:\n                extrema = self.getextrema()\n            return self.im.entropy(extrema)\n        return self.im.entropy()\n\n    def paste(\n        self,\n        im: Image | str | float | tuple[float, ...],\n        box: Image | tuple[int, int, int, int] | tuple[int, int] | None = None,\n        mask: Image | None = None,\n    ) -> None:\n        \"\"\"\n        Pastes another image into this image. The box argument is either\n        a 2-tuple giving the upper left corner, a 4-tuple defining the\n        left, upper, right, and lower pixel coordinate, or None (same as\n        (0, 0)). See :ref:`coordinate-system`. If a 4-tuple is given, the size\n        of the pasted image must match the size of the region.\n\n        If the modes don't match, the pasted image is converted to the mode of\n        this image (see the :py:meth:`~PIL.Image.Image.convert` method for\n        details).\n\n        Instead of an image, the source can be a integer or tuple\n        containing pixel values.  The method then fills the region\n        with the given color.  When creating RGB images, you can\n        also use color strings as supported by the ImageColor module.\n\n        If a mask is given, this method updates only the regions\n        indicated by the mask. You can use either \"1\", \"L\", \"LA\", \"RGBA\"\n        or \"RGBa\" images (if present, the alpha band is used as mask).\n        Where the mask is 255, the given image is copied as is.  Where\n        the mask is 0, the current value is preserved.  Intermediate\n        values will mix the two images together, including their alpha\n        channels if they have them.\n\n        See :py:meth:`~PIL.Image.Image.alpha_composite` if you want to\n        combine images with respect to their alpha channels.\n\n        :param im: Source image or pixel value (integer, float or tuple).\n        :param box: An optional 4-tuple giving the region to paste into.\n           If a 2-tuple is used instead, it's treated as the upper left\n           corner.  If omitted or None, the source is pasted into the\n           upper left corner.\n\n           If an image is given as the second argument and there is no\n           third, the box defaults to (0, 0), and the second argument\n           is interpreted as a mask image.\n        :param mask: An optional mask image.\n        \"\"\"\n\n        if isImageType(box):\n            if mask is not None:\n                msg = \"If using second argument as mask, third argument must be None\"\n                raise ValueError(msg)\n            # abbreviated paste(im, mask) syntax\n            mask = box\n            box = None\n        assert not isinstance(box, Image)\n\n        if box is None:\n            box = (0, 0)\n\n        if len(box) == 2:\n            # upper left corner given; get size from image or mask\n            if isImageType(im):\n                size = im.size\n            elif isImageType(mask):\n                size = mask.size\n            else:\n                # FIXME: use self.size here?\n                msg = \"cannot determine region size; use 4-item box\"\n                raise ValueError(msg)\n            box += (box[0] + size[0], box[1] + size[1])\n\n        if isinstance(im, str):\n            from . import ImageColor\n\n            im = ImageColor.getcolor(im, self.mode)\n\n        elif isImageType(im):\n            im.load()\n            if self.mode != im.mode:\n                if self.mode != \"RGB\" or im.mode not in (\"LA\", \"RGBA\", \"RGBa\"):\n                    # should use an adapter for this!\n                    im = im.convert(self.mode)\n            im = im.im\n\n        self._ensure_mutable()\n\n        if mask:\n            mask.load()\n            self.im.paste(im, box, mask.im)\n        else:\n            self.im.paste(im, box)\n\n    def alpha_composite(\n        self, im: Image, dest: Sequence[int] = (0, 0), source: Sequence[int] = (0, 0)\n    ) -> None:\n        \"\"\"'In-place' analog of Image.alpha_composite. Composites an image\n        onto this image.\n\n        :param im: image to composite over this one\n        :param dest: Optional 2 tuple (left, top) specifying the upper\n          left corner in this (destination) image.\n        :param source: Optional 2 (left, top) tuple for the upper left\n          corner in the overlay source image, or 4 tuple (left, top, right,\n          bottom) for the bounds of the source rectangle\n\n        Performance Note: Not currently implemented in-place in the core layer.\n        \"\"\"\n\n        if not isinstance(source, (list, tuple)):\n            msg = \"Source must be a list or tuple\"\n            raise ValueError(msg)\n        if not isinstance(dest, (list, tuple)):\n            msg = \"Destination must be a list or tuple\"\n            raise ValueError(msg)\n\n        if len(source) == 4:\n            overlay_crop_box = tuple(source)\n        elif len(source) == 2:\n            overlay_crop_box = tuple(source) + im.size\n        else:\n            msg = \"Source must be a sequence of length 2 or 4\"\n            raise ValueError(msg)\n\n        if not len(dest) == 2:\n            msg = \"Destination must be a sequence of length 2\"\n            raise ValueError(msg)\n        if min(source) < 0:\n            msg = \"Source must be non-negative\"\n            raise ValueError(msg)\n\n        # over image, crop if it's not the whole image.\n        if overlay_crop_box == (0, 0) + im.size:\n            overlay = im\n        else:\n            overlay = im.crop(overlay_crop_box)\n\n        # target for the paste\n        box = tuple(dest) + (dest[0] + overlay.width, dest[1] + overlay.height)\n\n        # destination image. don't copy if we're using the whole image.\n        if box == (0, 0) + self.size:\n            background = self\n        else:\n            background = self.crop(box)\n\n        result = alpha_composite(background, overlay)\n        self.paste(result, box)\n\n    def point(\n        self,\n        lut: Sequence[float] | Callable[[int], float] | ImagePointHandler,\n        mode: str | None = None,\n    ) -> Image:\n        \"\"\"\n        Maps this image through a lookup table or function.\n\n        :param lut: A lookup table, containing 256 (or 65536 if\n           self.mode==\"I\" and mode == \"L\") values per band in the\n           image.  A function can be used instead, it should take a\n           single argument. The function is called once for each\n           possible pixel value, and the resulting table is applied to\n           all bands of the image.\n\n           It may also be an :py:class:`~PIL.Image.ImagePointHandler`\n           object::\n\n               class Example(Image.ImagePointHandler):\n                 def point(self, data):\n                   # Return result\n        :param mode: Output mode (default is same as input). This can only be used if\n           the source image has mode \"L\" or \"P\", and the output has mode \"1\" or the\n           source image mode is \"I\" and the output mode is \"L\".\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        self.load()\n\n        if isinstance(lut, ImagePointHandler):\n            return lut.point(self)\n\n        if callable(lut):\n            # if it isn't a list, it should be a function\n            if self.mode in (\"I\", \"I;16\", \"F\"):\n                # check if the function can be used with point_transform\n                # UNDONE wiredfool -- I think this prevents us from ever doing\n                # a gamma function point transform on > 8bit images.\n                scale, offset = _getscaleoffset(lut)\n                return self._new(self.im.point_transform(scale, offset))\n            # for other modes, convert the function to a table\n            flatLut = [lut(i) for i in range(256)] * self.im.bands\n        else:\n            flatLut = lut\n\n        if self.mode == \"F\":\n            # FIXME: _imaging returns a confusing error message for this case\n            msg = \"point operation not supported for this mode\"\n            raise ValueError(msg)\n\n        if mode != \"F\":\n            flatLut = [round(i) for i in flatLut]\n        return self._new(self.im.point(flatLut, mode))\n\n    def putalpha(self, alpha):\n        \"\"\"\n        Adds or replaces the alpha layer in this image.  If the image\n        does not have an alpha layer, it's converted to \"LA\" or \"RGBA\".\n        The new layer must be either \"L\" or \"1\".\n\n        :param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"\n           image having the same size as this image, or an integer or\n           other color value.\n        \"\"\"\n\n        self._ensure_mutable()\n\n        if self.mode not in (\"LA\", \"PA\", \"RGBA\"):\n            # attempt to promote self to a matching alpha mode\n            try:\n                mode = getmodebase(self.mode) + \"A\"\n                try:\n                    self.im.setmode(mode)\n                except (AttributeError, ValueError) as e:\n                    # do things the hard way\n                    im = self.im.convert(mode)\n                    if im.mode not in (\"LA\", \"PA\", \"RGBA\"):\n                        msg = \"alpha channel could not be added\"\n                        raise ValueError(msg) from e  # sanity check\n                    self.im = im\n                self.pyaccess = None\n                self._mode = self.im.mode\n            except KeyError as e:\n                msg = \"illegal image mode\"\n                raise ValueError(msg) from e\n\n        if self.mode in (\"LA\", \"PA\"):\n            band = 1\n        else:\n            band = 3\n\n        if isImageType(alpha):\n            # alpha layer\n            if alpha.mode not in (\"1\", \"L\"):\n                msg = \"illegal image mode\"\n                raise ValueError(msg)\n            alpha.load()\n            if alpha.mode == \"1\":\n                alpha = alpha.convert(\"L\")\n        else:\n            # constant alpha\n            try:\n                self.im.fillband(band, alpha)\n            except (AttributeError, ValueError):\n                # do things the hard way\n                alpha = new(\"L\", self.size, alpha)\n            else:\n                return\n\n        self.im.putband(alpha.im, band)\n\n    def putdata(\n        self,\n        data: Sequence[float] | Sequence[Sequence[int]],\n        scale: float = 1.0,\n        offset: float = 0.0,\n    ) -> None:\n        \"\"\"\n        Copies pixel data from a flattened sequence object into the image. The\n        values should start at the upper left corner (0, 0), continue to the\n        end of the line, followed directly by the first value of the second\n        line, and so on. Data will be read until either the image or the\n        sequence ends. The scale and offset values are used to adjust the\n        sequence values: **pixel = value*scale + offset**.\n\n        :param data: A flattened sequence object.\n        :param scale: An optional scale value.  The default is 1.0.\n        :param offset: An optional offset value.  The default is 0.0.\n        \"\"\"\n\n        self._ensure_mutable()\n\n        self.im.putdata(data, scale, offset)\n\n    def putpalette(self, data, rawmode=\"RGB\") -> None:\n        \"\"\"\n        Attaches a palette to this image.  The image must be a \"P\", \"PA\", \"L\"\n        or \"LA\" image.\n\n        The palette sequence must contain at most 256 colors, made up of one\n        integer value for each channel in the raw mode.\n        For example, if the raw mode is \"RGB\", then it can contain at most 768\n        values, made up of red, green and blue values for the corresponding pixel\n        index in the 256 colors.\n        If the raw mode is \"RGBA\", then it can contain at most 1024 values,\n        containing red, green, blue and alpha values.\n\n        Alternatively, an 8-bit string may be used instead of an integer sequence.\n\n        :param data: A palette sequence (either a list or a string).\n        :param rawmode: The raw mode of the palette. Either \"RGB\", \"RGBA\", or a mode\n           that can be transformed to \"RGB\" or \"RGBA\" (e.g. \"R\", \"BGR;15\", \"RGBA;L\").\n        \"\"\"\n        from . import ImagePalette\n\n        if self.mode not in (\"L\", \"LA\", \"P\", \"PA\"):\n            msg = \"illegal image mode\"\n            raise ValueError(msg)\n        if isinstance(data, ImagePalette.ImagePalette):\n            palette = ImagePalette.raw(data.rawmode, data.palette)\n        else:\n            if not isinstance(data, bytes):\n                data = bytes(data)\n            palette = ImagePalette.raw(rawmode, data)\n        self._mode = \"PA\" if \"A\" in self.mode else \"P\"\n        self.palette = palette\n        self.palette.mode = \"RGBA\" if \"A\" in rawmode else \"RGB\"\n        self.load()  # install new palette\n\n    def putpixel(self, xy, value):\n        \"\"\"\n        Modifies the pixel at the given position. The color is given as\n        a single numerical value for single-band images, and a tuple for\n        multi-band images. In addition to this, RGB and RGBA tuples are\n        accepted for P and PA images.\n\n        Note that this method is relatively slow.  For more extensive changes,\n        use :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`\n        module instead.\n\n        See:\n\n        * :py:meth:`~PIL.Image.Image.paste`\n        * :py:meth:`~PIL.Image.Image.putdata`\n        * :py:mod:`~PIL.ImageDraw`\n\n        :param xy: The pixel coordinate, given as (x, y). See\n           :ref:`coordinate-system`.\n        :param value: The pixel value.\n        \"\"\"\n\n        if self.readonly:\n            self._copy()\n        self.load()\n\n        if self.pyaccess:\n            return self.pyaccess.putpixel(xy, value)\n\n        if (\n            self.mode in (\"P\", \"PA\")\n            and isinstance(value, (list, tuple))\n            and len(value) in [3, 4]\n        ):\n            # RGB or RGBA value for a P or PA image\n            if self.mode == \"PA\":\n                alpha = value[3] if len(value) == 4 else 255\n                value = value[:3]\n            value = self.palette.getcolor(value, self)\n            if self.mode == \"PA\":\n                value = (value, alpha)\n        return self.im.putpixel(xy, value)\n\n    def remap_palette(self, dest_map, source_palette=None):\n        \"\"\"\n        Rewrites the image to reorder the palette.\n\n        :param dest_map: A list of indexes into the original palette.\n           e.g. ``[1,0]`` would swap a two item palette, and ``list(range(256))``\n           is the identity transform.\n        :param source_palette: Bytes or None.\n        :returns:  An :py:class:`~PIL.Image.Image` object.\n\n        \"\"\"\n        from . import ImagePalette\n\n        if self.mode not in (\"L\", \"P\"):\n            msg = \"illegal image mode\"\n            raise ValueError(msg)\n\n        bands = 3\n        palette_mode = \"RGB\"\n        if source_palette is None:\n            if self.mode == \"P\":\n                self.load()\n                palette_mode = self.im.getpalettemode()\n                if palette_mode == \"RGBA\":\n                    bands = 4\n                source_palette = self.im.getpalette(palette_mode, palette_mode)\n            else:  # L-mode\n                source_palette = bytearray(i // 3 for i in range(768))\n\n        palette_bytes = b\"\"\n        new_positions = [0] * 256\n\n        # pick only the used colors from the palette\n        for i, oldPosition in enumerate(dest_map):\n            palette_bytes += source_palette[\n                oldPosition * bands : oldPosition * bands + bands\n            ]\n            new_positions[oldPosition] = i\n\n        # replace the palette color id of all pixel with the new id\n\n        # Palette images are [0..255], mapped through a 1 or 3\n        # byte/color map.  We need to remap the whole image\n        # from palette 1 to palette 2. New_positions is\n        # an array of indexes into palette 1.  Palette 2 is\n        # palette 1 with any holes removed.\n\n        # We're going to leverage the convert mechanism to use the\n        # C code to remap the image from palette 1 to palette 2,\n        # by forcing the source image into 'L' mode and adding a\n        # mapping 'L' mode palette, then converting back to 'L'\n        # sans palette thus converting the image bytes, then\n        # assigning the optimized RGB palette.\n\n        # perf reference, 9500x4000 gif, w/~135 colors\n        # 14 sec prepatch, 1 sec postpatch with optimization forced.\n\n        mapping_palette = bytearray(new_positions)\n\n        m_im = self.copy()\n        m_im._mode = \"P\"\n\n        m_im.palette = ImagePalette.ImagePalette(\n            palette_mode, palette=mapping_palette * bands\n        )\n        # possibly set palette dirty, then\n        # m_im.putpalette(mapping_palette, 'L')  # converts to 'P'\n        # or just force it.\n        # UNDONE -- this is part of the general issue with palettes\n        m_im.im.putpalette(palette_mode, palette_mode + \";L\", m_im.palette.tobytes())\n\n        m_im = m_im.convert(\"L\")\n\n        m_im.putpalette(palette_bytes, palette_mode)\n        m_im.palette = ImagePalette.ImagePalette(palette_mode, palette=palette_bytes)\n\n        if \"transparency\" in self.info:\n            try:\n                m_im.info[\"transparency\"] = dest_map.index(self.info[\"transparency\"])\n            except ValueError:\n                if \"transparency\" in m_im.info:\n                    del m_im.info[\"transparency\"]\n\n        return m_im\n\n    def _get_safe_box(self, size, resample, box):\n        \"\"\"Expands the box so it includes adjacent pixels\n        that may be used by resampling with the given resampling filter.\n        \"\"\"\n        filter_support = _filters_support[resample] - 0.5\n        scale_x = (box[2] - box[0]) / size[0]\n        scale_y = (box[3] - box[1]) / size[1]\n        support_x = filter_support * scale_x\n        support_y = filter_support * scale_y\n\n        return (\n            max(0, int(box[0] - support_x)),\n            max(0, int(box[1] - support_y)),\n            min(self.size[0], math.ceil(box[2] + support_x)),\n            min(self.size[1], math.ceil(box[3] + support_y)),\n        )\n\n    def resize(\n        self,\n        size: tuple[int, int],\n        resample: int | None = None,\n        box: tuple[float, float, float, float] | None = None,\n        reducing_gap: float | None = None,\n    ) -> Image:\n        \"\"\"\n        Returns a resized copy of this image.\n\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        :param resample: An optional resampling filter.  This can be\n           one of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n           :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n           :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n           If the image has mode \"1\" or \"P\", it is always set to\n           :py:data:`Resampling.NEAREST`. If the image mode specifies a number\n           of bits, such as \"I;16\", then the default filter is\n           :py:data:`Resampling.NEAREST`. Otherwise, the default filter is\n           :py:data:`Resampling.BICUBIC`. See: :ref:`concept-filters`.\n        :param box: An optional 4-tuple of floats providing\n           the source image region to be scaled.\n           The values must be within (0, 0, width, height) rectangle.\n           If omitted or None, the entire source is used.\n        :param reducing_gap: Apply optimization by resizing the image\n           in two steps. First, reducing the image by integer times\n           using :py:meth:`~PIL.Image.Image.reduce`.\n           Second, resizing using regular resampling. The last step\n           changes size no less than by ``reducing_gap`` times.\n           ``reducing_gap`` may be None (no first step is performed)\n           or should be greater than 1.0. The bigger ``reducing_gap``,\n           the closer the result to the fair resampling.\n           The smaller ``reducing_gap``, the faster resizing.\n           With ``reducing_gap`` greater or equal to 3.0, the result is\n           indistinguishable from fair resampling in most cases.\n           The default value is None (no optimization).\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if resample is None:\n            type_special = \";\" in self.mode\n            resample = Resampling.NEAREST if type_special else Resampling.BICUBIC\n        elif resample not in (\n            Resampling.NEAREST,\n            Resampling.BILINEAR,\n            Resampling.BICUBIC,\n            Resampling.LANCZOS,\n            Resampling.BOX,\n            Resampling.HAMMING,\n        ):\n            msg = f\"Unknown resampling filter ({resample}).\"\n\n            filters = [\n                f\"{filter[1]} ({filter[0]})\"\n                for filter in (\n                    (Resampling.NEAREST, \"Image.Resampling.NEAREST\"),\n                    (Resampling.LANCZOS, \"Image.Resampling.LANCZOS\"),\n                    (Resampling.BILINEAR, \"Image.Resampling.BILINEAR\"),\n                    (Resampling.BICUBIC, \"Image.Resampling.BICUBIC\"),\n                    (Resampling.BOX, \"Image.Resampling.BOX\"),\n                    (Resampling.HAMMING, \"Image.Resampling.HAMMING\"),\n                )\n            ]\n            msg += f\" Use {', '.join(filters[:-1])} or {filters[-1]}\"\n            raise ValueError(msg)\n\n        if reducing_gap is not None and reducing_gap < 1.0:\n            msg = \"reducing_gap must be 1.0 or greater\"\n            raise ValueError(msg)\n\n        self.load()\n        if box is None:\n            box = (0, 0) + self.size\n\n        if self.size == size and box == (0, 0) + self.size:\n            return self.copy()\n\n        if self.mode in (\"1\", \"P\"):\n            resample = Resampling.NEAREST\n\n        if self.mode in [\"LA\", \"RGBA\"] and resample != Resampling.NEAREST:\n            im = self.convert({\"LA\": \"La\", \"RGBA\": \"RGBa\"}[self.mode])\n            im = im.resize(size, resample, box)\n            return im.convert(self.mode)\n\n        self.load()\n\n        if reducing_gap is not None and resample != Resampling.NEAREST:\n            factor_x = int((box[2] - box[0]) / size[0] / reducing_gap) or 1\n            factor_y = int((box[3] - box[1]) / size[1] / reducing_gap) or 1\n            if factor_x > 1 or factor_y > 1:\n                reduce_box = self._get_safe_box(size, resample, box)\n                factor = (factor_x, factor_y)\n                self = (\n                    self.reduce(factor, box=reduce_box)\n                    if callable(self.reduce)\n                    else Image.reduce(self, factor, box=reduce_box)\n                )\n                box = (\n                    (box[0] - reduce_box[0]) / factor_x,\n                    (box[1] - reduce_box[1]) / factor_y,\n                    (box[2] - reduce_box[0]) / factor_x,\n                    (box[3] - reduce_box[1]) / factor_y,\n                )\n\n        return self._new(self.im.resize(size, resample, box))\n\n    def reduce(\n        self,\n        factor: int | tuple[int, int],\n        box: tuple[int, int, int, int] | None = None,\n    ) -> Image:\n        \"\"\"\n        Returns a copy of the image reduced ``factor`` times.\n        If the size of the image is not dividable by ``factor``,\n        the resulting size will be rounded up.\n\n        :param factor: A greater than 0 integer or tuple of two integers\n           for width and height separately.\n        :param box: An optional 4-tuple of ints providing\n           the source image region to be reduced.\n           The values must be within ``(0, 0, width, height)`` rectangle.\n           If omitted or ``None``, the entire source is used.\n        \"\"\"\n        if not isinstance(factor, (list, tuple)):\n            factor = (factor, factor)\n\n        if box is None:\n            box = (0, 0) + self.size\n\n        if factor == (1, 1) and box == (0, 0) + self.size:\n            return self.copy()\n\n        if self.mode in [\"LA\", \"RGBA\"]:\n            im = self.convert({\"LA\": \"La\", \"RGBA\": \"RGBa\"}[self.mode])\n            im = im.reduce(factor, box)\n            return im.convert(self.mode)\n\n        self.load()\n\n        return self._new(self.im.reduce(factor, box))\n\n    def rotate(\n        self,\n        angle: float,\n        resample: Resampling = Resampling.NEAREST,\n        expand: int | bool = False,\n        center: tuple[int, int] | None = None,\n        translate: tuple[int, int] | None = None,\n        fillcolor: float | tuple[float, ...] | str | None = None,\n    ) -> Image:\n        \"\"\"\n        Returns a rotated copy of this image.  This method returns a\n        copy of this image, rotated the given number of degrees counter\n        clockwise around its centre.\n\n        :param angle: In degrees counter clockwise.\n        :param resample: An optional resampling filter.  This can be\n           one of :py:data:`Resampling.NEAREST` (use nearest neighbour),\n           :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment). If omitted, or if the image has\n           mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n           See :ref:`concept-filters`.\n        :param expand: Optional expansion flag.  If true, expands the output\n           image to make it large enough to hold the entire rotated image.\n           If false or omitted, make the output image the same size as the\n           input image.  Note that the expand flag assumes rotation around\n           the center and no translation.\n        :param center: Optional center of rotation (a 2-tuple).  Origin is\n           the upper left corner.  Default is the center of the image.\n        :param translate: An optional post-rotate translation (a 2-tuple).\n        :param fillcolor: An optional color for area outside the rotated image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        angle = angle % 360.0\n\n        # Fast paths regardless of filter, as long as we're not\n        # translating or changing the center.\n        if not (center or translate):\n            if angle == 0:\n                return self.copy()\n            if angle == 180:\n                return self.transpose(Transpose.ROTATE_180)\n            if angle in (90, 270) and (expand or self.width == self.height):\n                return self.transpose(\n                    Transpose.ROTATE_90 if angle == 90 else Transpose.ROTATE_270\n                )\n\n        # Calculate the affine matrix.  Note that this is the reverse\n        # transformation (from destination image to source) because we\n        # want to interpolate the (discrete) destination pixel from\n        # the local area around the (floating) source pixel.\n\n        # The matrix we actually want (note that it operates from the right):\n        # (1, 0, tx)   (1, 0, cx)   ( cos a, sin a, 0)   (1, 0, -cx)\n        # (0, 1, ty) * (0, 1, cy) * (-sin a, cos a, 0) * (0, 1, -cy)\n        # (0, 0,  1)   (0, 0,  1)   (     0,     0, 1)   (0, 0,   1)\n\n        # The reverse matrix is thus:\n        # (1, 0, cx)   ( cos -a, sin -a, 0)   (1, 0, -cx)   (1, 0, -tx)\n        # (0, 1, cy) * (-sin -a, cos -a, 0) * (0, 1, -cy) * (0, 1, -ty)\n        # (0, 0,  1)   (      0,      0, 1)   (0, 0,   1)   (0, 0,   1)\n\n        # In any case, the final translation may be updated at the end to\n        # compensate for the expand flag.\n\n        w, h = self.size\n\n        if translate is None:\n            post_trans = (0, 0)\n        else:\n            post_trans = translate\n        if center is None:\n            # FIXME These should be rounded to ints?\n            rotn_center = (w / 2.0, h / 2.0)\n        else:\n            rotn_center = center\n\n        angle = -math.radians(angle)\n        matrix = [\n            round(math.cos(angle), 15),\n            round(math.sin(angle), 15),\n            0.0,\n            round(-math.sin(angle), 15),\n            round(math.cos(angle), 15),\n            0.0,\n        ]\n\n        def transform(x, y, matrix):\n            (a, b, c, d, e, f) = matrix\n            return a * x + b * y + c, d * x + e * y + f\n\n        matrix[2], matrix[5] = transform(\n            -rotn_center[0] - post_trans[0], -rotn_center[1] - post_trans[1], matrix\n        )\n        matrix[2] += rotn_center[0]\n        matrix[5] += rotn_center[1]\n\n        if expand:\n            # calculate output size\n            xx = []\n            yy = []\n            for x, y in ((0, 0), (w, 0), (w, h), (0, h)):\n                x, y = transform(x, y, matrix)\n                xx.append(x)\n                yy.append(y)\n            nw = math.ceil(max(xx)) - math.floor(min(xx))\n            nh = math.ceil(max(yy)) - math.floor(min(yy))\n\n            # We multiply a translation matrix from the right.  Because of its\n            # special form, this is the same as taking the image of the\n            # translation vector as new translation vector.\n            matrix[2], matrix[5] = transform(-(nw - w) / 2.0, -(nh - h) / 2.0, matrix)\n            w, h = nw, nh\n\n        return self.transform(\n            (w, h), Transform.AFFINE, matrix, resample, fillcolor=fillcolor\n        )\n\n    def save(\n        self, fp: StrOrBytesPath | IO[bytes], format: str | None = None, **params: Any\n    ) -> None:\n        \"\"\"\n        Saves this image under the given filename.  If no format is\n        specified, the format to use is determined from the filename\n        extension, if possible.\n\n        Keyword options can be used to provide additional instructions\n        to the writer. If a writer doesn't recognise an option, it is\n        silently ignored. The available options are described in the\n        :doc:`image format documentation\n        <../handbook/image-file-formats>` for each writer.\n\n        You can use a file object instead of a filename. In this case,\n        you must always specify the format. The file object must\n        implement the ``seek``, ``tell``, and ``write``\n        methods, and be opened in binary mode.\n\n        :param fp: A filename (string), os.PathLike object or file object.\n        :param format: Optional format override.  If omitted, the\n           format to use is determined from the filename extension.\n           If a file object was used instead of a filename, this\n           parameter should always be used.\n        :param params: Extra parameters to the image writer.\n        :returns: None\n        :exception ValueError: If the output format could not be determined\n           from the file name.  Use the format option to solve this.\n        :exception OSError: If the file could not be written.  The file\n           may have been created, and may contain partial data.\n        \"\"\"\n\n        filename: str | bytes = \"\"\n        open_fp = False\n        if is_path(fp):\n            filename = os.path.realpath(os.fspath(fp))\n            open_fp = True\n        elif fp == sys.stdout:\n            try:\n                fp = sys.stdout.buffer\n            except AttributeError:\n                pass\n        if not filename and hasattr(fp, \"name\") and is_path(fp.name):\n            # only set the name for metadata purposes\n            filename = os.path.realpath(os.fspath(fp.name))\n\n        # may mutate self!\n        self._ensure_mutable()\n\n        save_all = params.pop(\"save_all\", False)\n        self.encoderinfo = params\n        self.encoderconfig: tuple[Any, ...] = ()\n\n        preinit()\n\n        filename_ext = os.path.splitext(filename)[1].lower()\n        ext = filename_ext.decode() if isinstance(filename_ext, bytes) else filename_ext\n\n        if not format:\n            if ext not in EXTENSION:\n                init()\n            try:\n                format = EXTENSION[ext]\n            except KeyError as e:\n                msg = f\"unknown file extension: {ext}\"\n                raise ValueError(msg) from e\n\n        if format.upper() not in SAVE:\n            init()\n        if save_all:\n            save_handler = SAVE_ALL[format.upper()]\n        else:\n            save_handler = SAVE[format.upper()]\n\n        created = False\n        if open_fp:\n            created = not os.path.exists(filename)\n            if params.get(\"append\", False):\n                # Open also for reading (\"+\"), because TIFF save_all\n                # writer needs to go back and edit the written data.\n                fp = builtins.open(filename, \"r+b\")\n            else:\n                fp = builtins.open(filename, \"w+b\")\n        else:\n            fp = cast(IO[bytes], fp)\n\n        try:\n            save_handler(self, fp, filename)\n        except Exception:\n            if open_fp:\n                fp.close()\n            if created:\n                try:\n                    os.remove(filename)\n                except PermissionError:\n                    pass\n            raise\n        if open_fp:\n            fp.close()\n\n    def seek(self, frame: int) -> None:\n        \"\"\"\n        Seeks to the given frame in this sequence file. If you seek\n        beyond the end of the sequence, the method raises an\n        ``EOFError`` exception. When a sequence file is opened, the\n        library automatically seeks to frame 0.\n\n        See :py:meth:`~PIL.Image.Image.tell`.\n\n        If defined, :attr:`~PIL.Image.Image.n_frames` refers to the\n        number of available frames.\n\n        :param frame: Frame number, starting at 0.\n        :exception EOFError: If the call attempts to seek beyond the end\n            of the sequence.\n        \"\"\"\n\n        # overridden by file handlers\n        if frame != 0:\n            msg = \"no more images in file\"\n            raise EOFError(msg)\n\n    def show(self, title: str | None = None) -> None:\n        \"\"\"\n        Displays this image. This method is mainly intended for debugging purposes.\n\n        This method calls :py:func:`PIL.ImageShow.show` internally. You can use\n        :py:func:`PIL.ImageShow.register` to override its default behaviour.\n\n        The image is first saved to a temporary file. By default, it will be in\n        PNG format.\n\n        On Unix, the image is then opened using the **xdg-open**, **display**,\n        **gm**, **eog** or **xv** utility, depending on which one can be found.\n\n        On macOS, the image is opened with the native Preview application.\n\n        On Windows, the image is opened with the standard PNG display utility.\n\n        :param title: Optional title to use for the image window, where possible.\n        \"\"\"\n\n        _show(self, title=title)\n\n    def split(self) -> tuple[Image, ...]:\n        \"\"\"\n        Split this image into individual bands. This method returns a\n        tuple of individual image bands from an image. For example,\n        splitting an \"RGB\" image creates three new images each\n        containing a copy of one of the original bands (red, green,\n        blue).\n\n        If you need only one band, :py:meth:`~PIL.Image.Image.getchannel`\n        method can be more convenient and faster.\n\n        :returns: A tuple containing bands.\n        \"\"\"\n\n        self.load()\n        if self.im.bands == 1:\n            return (self.copy(),)\n        return tuple(map(self._new, self.im.split()))\n\n    def getchannel(self, channel: int | str) -> Image:\n        \"\"\"\n        Returns an image containing a single channel of the source image.\n\n        :param channel: What channel to return. Could be index\n          (0 for \"R\" channel of \"RGB\") or channel name\n          (\"A\" for alpha channel of \"RGBA\").\n        :returns: An image in \"L\" mode.\n\n        .. versionadded:: 4.3.0\n        \"\"\"\n        self.load()\n\n        if isinstance(channel, str):\n            try:\n                channel = self.getbands().index(channel)\n            except ValueError as e:\n                msg = f'The image has no channel \"{channel}\"'\n                raise ValueError(msg) from e\n\n        return self._new(self.im.getband(channel))\n\n    def tell(self) -> int:\n        \"\"\"\n        Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.\n\n        If defined, :attr:`~PIL.Image.Image.n_frames` refers to the\n        number of available frames.\n\n        :returns: Frame number, starting with 0.\n        \"\"\"\n        return 0\n\n    def thumbnail(\n        self,\n        size: tuple[float, float],\n        resample: Resampling = Resampling.BICUBIC,\n        reducing_gap: float | None = 2.0,\n    ) -> None:\n        \"\"\"\n        Make this image into a thumbnail.  This method modifies the\n        image to contain a thumbnail version of itself, no larger than\n        the given size.  This method calculates an appropriate thumbnail\n        size to preserve the aspect of the image, calls the\n        :py:meth:`~PIL.Image.Image.draft` method to configure the file reader\n        (where applicable), and finally resizes the image.\n\n        Note that this function modifies the :py:class:`~PIL.Image.Image`\n        object in place.  If you need to use the full resolution image as well,\n        apply this method to a :py:meth:`~PIL.Image.Image.copy` of the original\n        image.\n\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        :param resample: Optional resampling filter.  This can be one\n           of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n           :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n           :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n           If omitted, it defaults to :py:data:`Resampling.BICUBIC`.\n           (was :py:data:`Resampling.NEAREST` prior to version 2.5.0).\n           See: :ref:`concept-filters`.\n        :param reducing_gap: Apply optimization by resizing the image\n           in two steps. First, reducing the image by integer times\n           using :py:meth:`~PIL.Image.Image.reduce` or\n           :py:meth:`~PIL.Image.Image.draft` for JPEG images.\n           Second, resizing using regular resampling. The last step\n           changes size no less than by ``reducing_gap`` times.\n           ``reducing_gap`` may be None (no first step is performed)\n           or should be greater than 1.0. The bigger ``reducing_gap``,\n           the closer the result to the fair resampling.\n           The smaller ``reducing_gap``, the faster resizing.\n           With ``reducing_gap`` greater or equal to 3.0, the result is\n           indistinguishable from fair resampling in most cases.\n           The default value is 2.0 (very close to fair resampling\n           while still being faster in many cases).\n        :returns: None\n        \"\"\"\n\n        provided_size = tuple(map(math.floor, size))\n\n        def preserve_aspect_ratio() -> tuple[int, int] | None:\n            def round_aspect(number, key):\n                return max(min(math.floor(number), math.ceil(number), key=key), 1)\n\n            x, y = provided_size\n            if x >= self.width and y >= self.height:\n                return None\n\n            aspect = self.width / self.height\n            if x / y >= aspect:\n                x = round_aspect(y * aspect, key=lambda n: abs(aspect - n / y))\n            else:\n                y = round_aspect(\n                    x / aspect, key=lambda n: 0 if n == 0 else abs(aspect - x / n)\n                )\n            return x, y\n\n        box = None\n        final_size: tuple[int, int]\n        if reducing_gap is not None:\n            preserved_size = preserve_aspect_ratio()\n            if preserved_size is None:\n                return\n            final_size = preserved_size\n\n            res = self.draft(\n                None, (int(size[0] * reducing_gap), int(size[1] * reducing_gap))\n            )\n            if res is not None:\n                box = res[1]\n        if box is None:\n            self.load()\n\n            # load() may have changed the size of the image\n            preserved_size = preserve_aspect_ratio()\n            if preserved_size is None:\n                return\n            final_size = preserved_size\n\n        if self.size != final_size:\n            im = self.resize(final_size, resample, box=box, reducing_gap=reducing_gap)\n\n            self.im = im.im\n            self._size = final_size\n            self._mode = self.im.mode\n\n        self.readonly = 0\n        self.pyaccess = None\n\n    # FIXME: the different transform methods need further explanation\n    # instead of bloating the method docs, add a separate chapter.\n    def transform(\n        self,\n        size: tuple[int, int],\n        method: Transform | ImageTransformHandler | SupportsGetData,\n        data: Sequence[Any] | None = None,\n        resample: int = Resampling.NEAREST,\n        fill: int = 1,\n        fillcolor: float | tuple[float, ...] | str | None = None,\n    ) -> Image:\n        \"\"\"\n        Transforms this image.  This method creates a new image with the\n        given size, and the same mode as the original, and copies data\n        to the new image using the given transform.\n\n        :param size: The output size in pixels, as a 2-tuple:\n           (width, height).\n        :param method: The transformation method.  This is one of\n          :py:data:`Transform.EXTENT` (cut out a rectangular subregion),\n          :py:data:`Transform.AFFINE` (affine transform),\n          :py:data:`Transform.PERSPECTIVE` (perspective transform),\n          :py:data:`Transform.QUAD` (map a quadrilateral to a rectangle), or\n          :py:data:`Transform.MESH` (map a number of source quadrilaterals\n          in one operation).\n\n          It may also be an :py:class:`~PIL.Image.ImageTransformHandler`\n          object::\n\n            class Example(Image.ImageTransformHandler):\n                def transform(self, size, data, resample, fill=1):\n                    # Return result\n\n          Implementations of :py:class:`~PIL.Image.ImageTransformHandler`\n          for some of the :py:class:`Transform` methods are provided\n          in :py:mod:`~PIL.ImageTransform`.\n\n          It may also be an object with a ``method.getdata`` method\n          that returns a tuple supplying new ``method`` and ``data`` values::\n\n            class Example:\n                def getdata(self):\n                    method = Image.Transform.EXTENT\n                    data = (0, 0, 100, 100)\n                    return method, data\n        :param data: Extra data to the transformation method.\n        :param resample: Optional resampling filter.  It can be one of\n           :py:data:`Resampling.NEAREST` (use nearest neighbour),\n           :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment). If omitted, or if the image\n           has mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n           See: :ref:`concept-filters`.\n        :param fill: If ``method`` is an\n          :py:class:`~PIL.Image.ImageTransformHandler` object, this is one of\n          the arguments passed to it. Otherwise, it is unused.\n        :param fillcolor: Optional fill color for the area outside the\n           transform in the output image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if self.mode in (\"LA\", \"RGBA\") and resample != Resampling.NEAREST:\n            return (\n                self.convert({\"LA\": \"La\", \"RGBA\": \"RGBa\"}[self.mode])\n                .transform(size, method, data, resample, fill, fillcolor)\n                .convert(self.mode)\n            )\n\n        if isinstance(method, ImageTransformHandler):\n            return method.transform(size, self, resample=resample, fill=fill)\n\n        if hasattr(method, \"getdata\"):\n            # compatibility w. old-style transform objects\n            method, data = method.getdata()\n\n        if data is None:\n            msg = \"missing method data\"\n            raise ValueError(msg)\n\n        im = new(self.mode, size, fillcolor)\n        if self.mode == \"P\" and self.palette:\n            im.palette = self.palette.copy()\n        im.info = self.info.copy()\n        if method == Transform.MESH:\n            # list of quads\n            for box, quad in data:\n                im.__transformer(\n                    box, self, Transform.QUAD, quad, resample, fillcolor is None\n                )\n        else:\n            im.__transformer(\n                (0, 0) + size, self, method, data, resample, fillcolor is None\n            )\n\n        return im\n\n    def __transformer(\n        self, box, image, method, data, resample=Resampling.NEAREST, fill=1\n    ):\n        w = box[2] - box[0]\n        h = box[3] - box[1]\n\n        if method == Transform.AFFINE:\n            data = data[:6]\n\n        elif method == Transform.EXTENT:\n            # convert extent to an affine transform\n            x0, y0, x1, y1 = data\n            xs = (x1 - x0) / w\n            ys = (y1 - y0) / h\n            method = Transform.AFFINE\n            data = (xs, 0, x0, 0, ys, y0)\n\n        elif method == Transform.PERSPECTIVE:\n            data = data[:8]\n\n        elif method == Transform.QUAD:\n            # quadrilateral warp.  data specifies the four corners\n            # given as NW, SW, SE, and NE.\n            nw = data[:2]\n            sw = data[2:4]\n            se = data[4:6]\n            ne = data[6:8]\n            x0, y0 = nw\n            As = 1.0 / w\n            At = 1.0 / h\n            data = (\n                x0,\n                (ne[0] - x0) * As,\n                (sw[0] - x0) * At,\n                (se[0] - sw[0] - ne[0] + x0) * As * At,\n                y0,\n                (ne[1] - y0) * As,\n                (sw[1] - y0) * At,\n                (se[1] - sw[1] - ne[1] + y0) * As * At,\n            )\n\n        else:\n            msg = \"unknown transformation method\"\n            raise ValueError(msg)\n\n        if resample not in (\n            Resampling.NEAREST,\n            Resampling.BILINEAR,\n            Resampling.BICUBIC,\n        ):\n            if resample in (Resampling.BOX, Resampling.HAMMING, Resampling.LANCZOS):\n                msg = {\n                    Resampling.BOX: \"Image.Resampling.BOX\",\n                    Resampling.HAMMING: \"Image.Resampling.HAMMING\",\n                    Resampling.LANCZOS: \"Image.Resampling.LANCZOS\",\n                }[resample] + f\" ({resample}) cannot be used.\"\n            else:\n                msg = f\"Unknown resampling filter ({resample}).\"\n\n            filters = [\n                f\"{filter[1]} ({filter[0]})\"\n                for filter in (\n                    (Resampling.NEAREST, \"Image.Resampling.NEAREST\"),\n                    (Resampling.BILINEAR, \"Image.Resampling.BILINEAR\"),\n                    (Resampling.BICUBIC, \"Image.Resampling.BICUBIC\"),\n                )\n            ]\n            msg += f\" Use {', '.join(filters[:-1])} or {filters[-1]}\"\n            raise ValueError(msg)\n\n        image.load()\n\n        self.load()\n\n        if image.mode in (\"1\", \"P\"):\n            resample = Resampling.NEAREST\n\n        self.im.transform(box, image.im, method, data, resample, fill)\n\n    def transpose(self, method: Transpose) -> Image:\n        \"\"\"\n        Transpose image (flip or rotate in 90 degree steps)\n\n        :param method: One of :py:data:`Transpose.FLIP_LEFT_RIGHT`,\n          :py:data:`Transpose.FLIP_TOP_BOTTOM`, :py:data:`Transpose.ROTATE_90`,\n          :py:data:`Transpose.ROTATE_180`, :py:data:`Transpose.ROTATE_270`,\n          :py:data:`Transpose.TRANSPOSE` or :py:data:`Transpose.TRANSVERSE`.\n        :returns: Returns a flipped or rotated copy of this image.\n        \"\"\"\n\n        self.load()\n        return self._new(self.im.transpose(method))\n\n    def effect_spread(self, distance: int) -> Image:\n        \"\"\"\n        Randomly spread pixels in an image.\n\n        :param distance: Distance to spread pixels.\n        \"\"\"\n        self.load()\n        return self._new(self.im.effect_spread(distance))\n\n    def toqimage(self):\n        \"\"\"Returns a QImage copy of this image\"\"\"\n        from . import ImageQt\n\n        if not ImageQt.qt_is_installed:\n            msg = \"Qt bindings are not installed\"\n            raise ImportError(msg)\n        return ImageQt.toqimage(self)\n\n    def toqpixmap(self):\n        \"\"\"Returns a QPixmap copy of this image\"\"\"\n        from . import ImageQt\n\n        if not ImageQt.qt_is_installed:\n            msg = \"Qt bindings are not installed\"\n            raise ImportError(msg)\n        return ImageQt.toqpixmap(self)\n\n\n# --------------------------------------------------------------------\n# Abstract handlers.\n\n\nclass ImagePointHandler:\n    \"\"\"\n    Used as a mixin by point transforms\n    (for use with :py:meth:`~PIL.Image.Image.point`)\n    \"\"\"\n\n    @abc.abstractmethod\n    def point(self, im: Image) -> Image:\n        pass\n\n\nclass ImageTransformHandler:\n    \"\"\"\n    Used as a mixin by geometry transforms\n    (for use with :py:meth:`~PIL.Image.Image.transform`)\n    \"\"\"\n\n    @abc.abstractmethod\n    def transform(\n        self,\n        size: tuple[int, int],\n        image: Image,\n        **options: Any,\n    ) -> Image:\n        pass\n\n\n# --------------------------------------------------------------------\n# Factories\n\n#\n# Debugging\n\n\ndef _wedge() -> Image:\n    \"\"\"Create grayscale wedge (for debugging only)\"\"\"\n\n    return Image()._new(core.wedge(\"L\"))\n\n\ndef _check_size(size: Any) -> None:\n    \"\"\"\n    Common check to enforce type and sanity check on size tuples\n\n    :param size: Should be a 2 tuple of (width, height)\n    :returns: None, or raises a ValueError\n    \"\"\"\n\n    if not isinstance(size, (list, tuple)):\n        msg = \"Size must be a list or tuple\"\n        raise ValueError(msg)\n    if len(size) != 2:\n        msg = \"Size must be a sequence of length 2\"\n        raise ValueError(msg)\n    if size[0] < 0 or size[1] < 0:\n        msg = \"Width and height must be >= 0\"\n        raise ValueError(msg)\n\n\ndef new(\n    mode: str,\n    size: tuple[int, int] | list[int],\n    color: float | tuple[float, ...] | str | None = 0,\n) -> Image:\n    \"\"\"\n    Creates a new image with the given mode and size.\n\n    :param mode: The mode to use for the new image. See:\n       :ref:`concept-modes`.\n    :param size: A 2-tuple, containing (width, height) in pixels.\n    :param color: What color to use for the image.  Default is black.\n       If given, this should be a single integer or floating point value\n       for single-band modes, and a tuple for multi-band modes (one value\n       per band).  When creating RGB or HSV images, you can also use color\n       strings as supported by the ImageColor module.  If the color is\n       None, the image is not initialised.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if mode in (\"BGR;15\", \"BGR;16\", \"BGR;24\"):\n        deprecate(mode, 12)\n\n    _check_size(size)\n\n    if color is None:\n        # don't initialize\n        return Image()._new(core.new(mode, size))\n\n    if isinstance(color, str):\n        # css3-style specifier\n\n        from . import ImageColor\n\n        color = ImageColor.getcolor(color, mode)\n\n    im = Image()\n    if (\n        mode == \"P\"\n        and isinstance(color, (list, tuple))\n        and all(isinstance(i, int) for i in color)\n    ):\n        color_ints: tuple[int, ...] = cast(Tuple[int, ...], tuple(color))\n        if len(color_ints) == 3 or len(color_ints) == 4:\n            # RGB or RGBA value for a P image\n            from . import ImagePalette\n\n            im.palette = ImagePalette.ImagePalette()\n            color = im.palette.getcolor(color_ints)\n    return im._new(core.fill(mode, size, color))\n\n\ndef frombytes(\n    mode: str,\n    size: tuple[int, int],\n    data: bytes | bytearray,\n    decoder_name: str = \"raw\",\n    *args: Any,\n) -> Image:\n    \"\"\"\n    Creates a copy of an image memory from pixel data in a buffer.\n\n    In its simplest form, this function takes three arguments\n    (mode, size, and unpacked pixel data).\n\n    You can also use any pixel decoder supported by PIL. For more\n    information on available decoders, see the section\n    :ref:`Writing Your Own File Codec <file-codecs>`.\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image in a string, wrap it in a\n    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load\n    it.\n\n    :param mode: The image mode. See: :ref:`concept-modes`.\n    :param size: The image size.\n    :param data: A byte buffer containing raw data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    _check_size(size)\n\n    im = new(mode, size)\n    if im.width != 0 and im.height != 0:\n        decoder_args: Any = args\n        if len(decoder_args) == 1 and isinstance(decoder_args[0], tuple):\n            # may pass tuple instead of argument list\n            decoder_args = decoder_args[0]\n\n        if decoder_name == \"raw\" and decoder_args == ():\n            decoder_args = mode\n\n        im.frombytes(data, decoder_name, decoder_args)\n    return im\n\n\ndef frombuffer(\n    mode: str, size: tuple[int, int], data, decoder_name: str = \"raw\", *args: Any\n) -> Image:\n    \"\"\"\n    Creates an image memory referencing pixel data in a byte buffer.\n\n    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\n    in the byte buffer, where possible.  This means that changes to the\n    original buffer object are reflected in this image).  Not all modes can\n    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image file in a string, wrap it in a\n    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load it.\n\n    The default parameters used for the \"raw\" decoder differs from that used for\n    :py:func:`~PIL.Image.frombytes`. This is a bug, and will probably be fixed in a\n    future release. The current release issues a warning if you do this; to disable\n    the warning, you should provide the full set of parameters. See below for details.\n\n    :param mode: The image mode. See: :ref:`concept-modes`.\n    :param size: The image size.\n    :param data: A bytes or other buffer object containing raw\n        data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.  For the\n        default encoder (\"raw\"), it's recommended that you provide the\n        full set of parameters::\n\n            frombuffer(mode, size, data, \"raw\", mode, 0, 1)\n\n    :returns: An :py:class:`~PIL.Image.Image` object.\n\n    .. versionadded:: 1.1.4\n    \"\"\"\n\n    _check_size(size)\n\n    # may pass tuple instead of argument list\n    if len(args) == 1 and isinstance(args[0], tuple):\n        args = args[0]\n\n    if decoder_name == \"raw\":\n        if args == ():\n            args = mode, 0, 1\n        if args[0] in _MAPMODES:\n            im = new(mode, (0, 0))\n            im = im._new(core.map_buffer(data, size, decoder_name, 0, args))\n            if mode == \"P\":\n                from . import ImagePalette\n\n                im.palette = ImagePalette.ImagePalette(\"RGB\", im.im.getpalette(\"RGB\"))\n            im.readonly = 1\n            return im\n\n    return frombytes(mode, size, data, decoder_name, args)\n\n\nclass SupportsArrayInterface(Protocol):\n    \"\"\"\n    An object that has an ``__array_interface__`` dictionary.\n    \"\"\"\n\n    @property\n    def __array_interface__(self) -> dict[str, Any]:\n        raise NotImplementedError()\n\n\ndef fromarray(obj: SupportsArrayInterface, mode: str | None = None) -> Image:\n    \"\"\"\n    Creates an image memory from an object exporting the array interface\n    (using the buffer protocol)::\n\n      from PIL import Image\n      import numpy as np\n      a = np.zeros((5, 5))\n      im = Image.fromarray(a)\n\n    If ``obj`` is not contiguous, then the ``tobytes`` method is called\n    and :py:func:`~PIL.Image.frombuffer` is used.\n\n    In the case of NumPy, be aware that Pillow modes do not always correspond\n    to NumPy dtypes. Pillow modes only offer 1-bit pixels, 8-bit pixels,\n    32-bit signed integer pixels, and 32-bit floating point pixels.\n\n    Pillow images can also be converted to arrays::\n\n      from PIL import Image\n      import numpy as np\n      im = Image.open(\"hopper.jpg\")\n      a = np.asarray(im)\n\n    When converting Pillow images to arrays however, only pixel values are\n    transferred. This means that P and PA mode images will lose their palette.\n\n    :param obj: Object with array interface\n    :param mode: Optional mode to use when reading ``obj``. Will be determined from\n      type if ``None``.\n\n      This will not be used to convert the data after reading, but will be used to\n      change how the data is read::\n\n        from PIL import Image\n        import numpy as np\n        a = np.full((1, 1), 300)\n        im = Image.fromarray(a, mode=\"L\")\n        im.getpixel((0, 0))  # 44\n        im = Image.fromarray(a, mode=\"RGB\")\n        im.getpixel((0, 0))  # (44, 1, 0)\n\n      See: :ref:`concept-modes` for general information about modes.\n    :returns: An image object.\n\n    .. versionadded:: 1.1.6\n    \"\"\"\n    arr = obj.__array_interface__\n    shape = arr[\"shape\"]\n    ndim = len(shape)\n    strides = arr.get(\"strides\", None)\n    if mode is None:\n        try:\n            typekey = (1, 1) + shape[2:], arr[\"typestr\"]\n        except KeyError as e:\n            msg = \"Cannot handle this data type\"\n            raise TypeError(msg) from e\n        try:\n            mode, rawmode = _fromarray_typemap[typekey]\n        except KeyError as e:\n            typekey_shape, typestr = typekey\n            msg = f\"Cannot handle this data type: {typekey_shape}, {typestr}\"\n            raise TypeError(msg) from e\n    else:\n        rawmode = mode\n    if mode in [\"1\", \"L\", \"I\", \"P\", \"F\"]:\n        ndmax = 2\n    elif mode == \"RGB\":\n        ndmax = 3\n    else:\n        ndmax = 4\n    if ndim > ndmax:\n        msg = f\"Too many dimensions: {ndim} > {ndmax}.\"\n        raise ValueError(msg)\n\n    size = 1 if ndim == 1 else shape[1], shape[0]\n    if strides is not None:\n        if hasattr(obj, \"tobytes\"):\n            obj = obj.tobytes()\n        elif hasattr(obj, \"tostring\"):\n            obj = obj.tostring()\n        else:\n            msg = \"'strides' requires either tobytes() or tostring()\"\n            raise ValueError(msg)\n\n    return frombuffer(mode, size, obj, \"raw\", rawmode, 0, 1)\n\n\ndef fromqimage(im):\n    \"\"\"Creates an image instance from a QImage image\"\"\"\n    from . import ImageQt\n\n    if not ImageQt.qt_is_installed:\n        msg = \"Qt bindings are not installed\"\n        raise ImportError(msg)\n    return ImageQt.fromqimage(im)\n\n\ndef fromqpixmap(im):\n    \"\"\"Creates an image instance from a QPixmap image\"\"\"\n    from . import ImageQt\n\n    if not ImageQt.qt_is_installed:\n        msg = \"Qt bindings are not installed\"\n        raise ImportError(msg)\n    return ImageQt.fromqpixmap(im)\n\n\n_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one\n    ((1, 1), \"|b1\"): (\"1\", \"1;8\"),\n    ((1, 1), \"|u1\"): (\"L\", \"L\"),\n    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),\n    ((1, 1), \"<u2\"): (\"I\", \"I;16\"),\n    ((1, 1), \">u2\"): (\"I\", \"I;16B\"),\n    ((1, 1), \"<i2\"): (\"I\", \"I;16S\"),\n    ((1, 1), \">i2\"): (\"I\", \"I;16BS\"),\n    ((1, 1), \"<u4\"): (\"I\", \"I;32\"),\n    ((1, 1), \">u4\"): (\"I\", \"I;32B\"),\n    ((1, 1), \"<i4\"): (\"I\", \"I;32S\"),\n    ((1, 1), \">i4\"): (\"I\", \"I;32BS\"),\n    ((1, 1), \"<f4\"): (\"F\", \"F;32F\"),\n    ((1, 1), \">f4\"): (\"F\", \"F;32BF\"),\n    ((1, 1), \"<f8\"): (\"F\", \"F;64F\"),\n    ((1, 1), \">f8\"): (\"F\", \"F;64BF\"),\n    ((1, 1, 2), \"|u1\"): (\"LA\", \"LA\"),\n    ((1, 1, 3), \"|u1\"): (\"RGB\", \"RGB\"),\n    ((1, 1, 4), \"|u1\"): (\"RGBA\", \"RGBA\"),\n    # shortcuts:\n    ((1, 1), f\"{_ENDIAN}i4\"): (\"I\", \"I\"),\n    ((1, 1), f\"{_ENDIAN}f4\"): (\"F\", \"F\"),\n}\n\n\ndef _decompression_bomb_check(size: tuple[int, int]) -> None:\n    if MAX_IMAGE_PIXELS is None:\n        return\n\n    pixels = max(1, size[0]) * max(1, size[1])\n\n    if pixels > 2 * MAX_IMAGE_PIXELS:\n        msg = (\n            f\"Image size ({pixels} pixels) exceeds limit of {2 * MAX_IMAGE_PIXELS} \"\n            \"pixels, could be decompression bomb DOS attack.\"\n        )\n        raise DecompressionBombError(msg)\n\n    if pixels > MAX_IMAGE_PIXELS:\n        warnings.warn(\n            f\"Image size ({pixels} pixels) exceeds limit of {MAX_IMAGE_PIXELS} pixels, \"\n            \"could be decompression bomb DOS attack.\",\n            DecompressionBombWarning,\n        )\n\n\ndef open(\n    fp: StrOrBytesPath | IO[bytes],\n    mode: Literal[\"r\"] = \"r\",\n    formats: list[str] | tuple[str, ...] | None = None,\n) -> ImageFile.ImageFile:\n    \"\"\"\n    Opens and identifies the given image file.\n\n    This is a lazy operation; this function identifies the file, but\n    the file remains open and the actual image data is not read from\n    the file until you try to process the data (or call the\n    :py:meth:`~PIL.Image.Image.load` method).  See\n    :py:func:`~PIL.Image.new`. See :ref:`file-handling`.\n\n    :param fp: A filename (string), os.PathLike object or a file object.\n       The file object must implement ``file.read``,\n       ``file.seek``, and ``file.tell`` methods,\n       and be opened in binary mode. The file object will also seek to zero\n       before reading.\n    :param mode: The mode.  If given, this argument must be \"r\".\n    :param formats: A list or tuple of formats to attempt to load the file in.\n       This can be used to restrict the set of formats checked.\n       Pass ``None`` to try all supported formats. You can print the set of\n       available formats by running ``python3 -m PIL`` or using\n       the :py:func:`PIL.features.pilinfo` function.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    :exception FileNotFoundError: If the file cannot be found.\n    :exception PIL.UnidentifiedImageError: If the image cannot be opened and\n       identified.\n    :exception ValueError: If the ``mode`` is not \"r\", or if a ``StringIO``\n       instance is used for ``fp``.\n    :exception TypeError: If ``formats`` is not ``None``, a list or a tuple.\n    \"\"\"\n\n    if mode != \"r\":\n        msg = f\"bad mode {repr(mode)}\"  # type: ignore[unreachable]\n        raise ValueError(msg)\n    elif isinstance(fp, io.StringIO):\n        msg = (  # type: ignore[unreachable]\n            \"StringIO cannot be used to open an image. \"\n            \"Binary data must be used instead.\"\n        )\n        raise ValueError(msg)\n\n    if formats is None:\n        formats = ID\n    elif not isinstance(formats, (list, tuple)):\n        msg = \"formats must be a list or tuple\"  # type: ignore[unreachable]\n        raise TypeError(msg)\n\n    exclusive_fp = False\n    filename: str | bytes = \"\"\n    if is_path(fp):\n        filename = os.path.realpath(os.fspath(fp))\n\n    if filename:\n        fp = builtins.open(filename, \"rb\")\n        exclusive_fp = True\n    else:\n        fp = cast(IO[bytes], fp)\n\n    try:\n        fp.seek(0)\n    except (AttributeError, io.UnsupportedOperation):\n        fp = io.BytesIO(fp.read())\n        exclusive_fp = True\n\n    prefix = fp.read(16)\n\n    preinit()\n\n    accept_warnings: list[str] = []\n\n    def _open_core(\n        fp: IO[bytes],\n        filename: str | bytes,\n        prefix: bytes,\n        formats: list[str] | tuple[str, ...],\n    ) -> ImageFile.ImageFile | None:\n        for i in formats:\n            i = i.upper()\n            if i not in OPEN:\n                init()\n            try:\n                factory, accept = OPEN[i]\n                result = not accept or accept(prefix)\n                if isinstance(result, str):\n                    accept_warnings.append(result)\n                elif result:\n                    fp.seek(0)\n                    im = factory(fp, filename)\n                    _decompression_bomb_check(im.size)\n                    return im\n            except (SyntaxError, IndexError, TypeError, struct.error):\n                # Leave disabled by default, spams the logs with image\n                # opening failures that are entirely expected.\n                # logger.debug(\"\", exc_info=True)\n                continue\n            except BaseException:\n                if exclusive_fp:\n                    fp.close()\n                raise\n        return None\n\n    im = _open_core(fp, filename, prefix, formats)\n\n    if im is None and formats is ID:\n        checked_formats = ID.copy()\n        if init():\n            im = _open_core(\n                fp,\n                filename,\n                prefix,\n                tuple(format for format in formats if format not in checked_formats),\n            )\n\n    if im:\n        im._exclusive_fp = exclusive_fp\n        return im\n\n    if exclusive_fp:\n        fp.close()\n    for message in accept_warnings:\n        warnings.warn(message)\n    msg = \"cannot identify image file %r\" % (filename if filename else fp)\n    raise UnidentifiedImageError(msg)\n\n\n#\n# Image processing.\n\n\ndef alpha_composite(im1: Image, im2: Image) -> Image:\n    \"\"\"\n    Alpha composite im2 over im1.\n\n    :param im1: The first image. Must have mode RGBA.\n    :param im2: The second image.  Must have mode RGBA, and the same size as\n       the first image.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.alpha_composite(im1.im, im2.im))\n\n\ndef blend(im1: Image, im2: Image, alpha: float) -> Image:\n    \"\"\"\n    Creates a new image by interpolating between two input images, using\n    a constant alpha::\n\n        out = image1 * (1.0 - alpha) + image2 * alpha\n\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a\n       copy of the first image is returned. If alpha is 1.0, a copy of\n       the second image is returned. There are no restrictions on the\n       alpha value. If necessary, the result is clipped to fit into\n       the allowed output range.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.blend(im1.im, im2.im, alpha))\n\n\ndef composite(image1: Image, image2: Image, mask: Image) -> Image:\n    \"\"\"\n    Create composite image by blending images using a transparency mask.\n\n    :param image1: The first image.\n    :param image2: The second image.  Must have the same mode and\n       size as the first image.\n    :param mask: A mask image.  This image can have mode\n       \"1\", \"L\", or \"RGBA\", and must have the same size as the\n       other two images.\n    \"\"\"\n\n    image = image2.copy()\n    image.paste(image1, None, mask)\n    return image\n\n\ndef eval(image, *args):\n    \"\"\"\n    Applies the function (which should take one argument) to each pixel\n    in the given image. If the image has more than one band, the same\n    function is applied to each band. Note that the function is\n    evaluated once for each possible pixel value, so you cannot use\n    random components or other generators.\n\n    :param image: The input image.\n    :param function: A function object, taking one integer argument.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    return image.point(args[0])\n\n\ndef merge(mode: str, bands: Sequence[Image]) -> Image:\n    \"\"\"\n    Merge a set of single band images into a new multiband image.\n\n    :param mode: The mode to use for the output image. See:\n        :ref:`concept-modes`.\n    :param bands: A sequence containing one single-band image for\n        each band in the output image.  All bands must have the\n        same size.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if getmodebands(mode) != len(bands) or \"*\" in mode:\n        msg = \"wrong number of bands\"\n        raise ValueError(msg)\n    for band in bands[1:]:\n        if band.mode != getmodetype(mode):\n            msg = \"mode mismatch\"\n            raise ValueError(msg)\n        if band.size != bands[0].size:\n            msg = \"size mismatch\"\n            raise ValueError(msg)\n    for band in bands:\n        band.load()\n    return bands[0]._new(core.merge(mode, *[b.im for b in bands]))\n\n\n# --------------------------------------------------------------------\n# Plugin registry\n\n\ndef register_open(\n    id: str,\n    factory: Callable[[IO[bytes], str | bytes], ImageFile.ImageFile],\n    accept: Callable[[bytes], bool | str] | None = None,\n) -> None:\n    \"\"\"\n    Register an image file plugin.  This function should not be used\n    in application code.\n\n    :param id: An image format identifier.\n    :param factory: An image file factory method.\n    :param accept: An optional function that can be used to quickly\n       reject images having another format.\n    \"\"\"\n    id = id.upper()\n    if id not in ID:\n        ID.append(id)\n    OPEN[id] = factory, accept\n\n\ndef register_mime(id: str, mimetype: str) -> None:\n    \"\"\"\n    Registers an image MIME type by populating ``Image.MIME``. This function\n    should not be used in application code.\n\n    ``Image.MIME`` provides a mapping from image format identifiers to mime\n    formats, but :py:meth:`~PIL.ImageFile.ImageFile.get_format_mimetype` can\n    provide a different result for specific images.\n\n    :param id: An image format identifier.\n    :param mimetype: The image MIME type for this format.\n    \"\"\"\n    MIME[id.upper()] = mimetype\n\n\ndef register_save(\n    id: str, driver: Callable[[Image, IO[bytes], str | bytes], None]\n) -> None:\n    \"\"\"\n    Registers an image save function.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE[id.upper()] = driver\n\n\ndef register_save_all(\n    id: str, driver: Callable[[Image, IO[bytes], str | bytes], None]\n) -> None:\n    \"\"\"\n    Registers an image function to save all the frames\n    of a multiframe format.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE_ALL[id.upper()] = driver\n\n\ndef register_extension(id: str, extension: str) -> None:\n    \"\"\"\n    Registers an image extension.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param extension: An extension used for this format.\n    \"\"\"\n    EXTENSION[extension.lower()] = id.upper()\n\n\ndef register_extensions(id: str, extensions: list[str]) -> None:\n    \"\"\"\n    Registers image extensions.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param extensions: A list of extensions used for this format.\n    \"\"\"\n    for extension in extensions:\n        register_extension(id, extension)\n\n\ndef registered_extensions() -> dict[str, str]:\n    \"\"\"\n    Returns a dictionary containing all file extensions belonging\n    to registered plugins\n    \"\"\"\n    init()\n    return EXTENSION\n\n\ndef register_decoder(name: str, decoder: type[ImageFile.PyDecoder]) -> None:\n    \"\"\"\n    Registers an image decoder.  This function should not be\n    used in application code.\n\n    :param name: The name of the decoder\n    :param decoder: An ImageFile.PyDecoder object\n\n    .. versionadded:: 4.1.0\n    \"\"\"\n    DECODERS[name] = decoder\n\n\ndef register_encoder(name: str, encoder: type[ImageFile.PyEncoder]) -> None:\n    \"\"\"\n    Registers an image encoder.  This function should not be\n    used in application code.\n\n    :param name: The name of the encoder\n    :param encoder: An ImageFile.PyEncoder object\n\n    .. versionadded:: 4.1.0\n    \"\"\"\n    ENCODERS[name] = encoder\n\n\n# --------------------------------------------------------------------\n# Simple display support.\n\n\ndef _show(image: Image, **options: Any) -> None:\n    from . import ImageShow\n\n    ImageShow.show(image, **options)\n\n\n# --------------------------------------------------------------------\n# Effects\n\n\ndef effect_mandelbrot(\n    size: tuple[int, int], extent: tuple[float, float, float, float], quality: int\n) -> Image:\n    \"\"\"\n    Generate a Mandelbrot set covering the given extent.\n\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param extent: The extent to cover, as a 4-tuple:\n       (x0, y0, x1, y1).\n    :param quality: Quality.\n    \"\"\"\n    return Image()._new(core.effect_mandelbrot(size, extent, quality))\n\n\ndef effect_noise(size: tuple[int, int], sigma: float) -> Image:\n    \"\"\"\n    Generate Gaussian noise centered around 128.\n\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param sigma: Standard deviation of noise.\n    \"\"\"\n    return Image()._new(core.effect_noise(size, sigma))\n\n\ndef linear_gradient(mode: str) -> Image:\n    \"\"\"\n    Generate 256x256 linear gradient from black to white, top to bottom.\n\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.linear_gradient(mode))\n\n\ndef radial_gradient(mode: str) -> Image:\n    \"\"\"\n    Generate 256x256 radial gradient from black to white, centre to edge.\n\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.radial_gradient(mode))\n\n\n# --------------------------------------------------------------------\n# Resources\n\n\ndef _apply_env_variables(env: dict[str, str] | None = None) -> None:\n    env_dict = env if env is not None else os.environ\n\n    for var_name, setter in [\n        (\"PILLOW_ALIGNMENT\", core.set_alignment),\n        (\"PILLOW_BLOCK_SIZE\", core.set_block_size),\n        (\"PILLOW_BLOCKS_MAX\", core.set_blocks_max),\n    ]:\n        if var_name not in env_dict:\n            continue\n\n        var = env_dict[var_name].lower()\n\n        units = 1\n        for postfix, mul in [(\"k\", 1024), (\"m\", 1024 * 1024)]:\n            if var.endswith(postfix):\n                units = mul\n                var = var[: -len(postfix)]\n\n        try:\n            var_int = int(var) * units\n        except ValueError:\n            warnings.warn(f\"{var_name} is not int\")\n            continue\n\n        try:\n            setter(var_int)\n        except ValueError as e:\n            warnings.warn(f\"{var_name}: {e}\")\n\n\n_apply_env_variables()\natexit.register(core.clear_cache)\n\n\nif TYPE_CHECKING:\n    _ExifBase = MutableMapping[int, Any]\nelse:\n    _ExifBase = MutableMapping\n\n\nclass Exif(_ExifBase):\n    \"\"\"\n    This class provides read and write access to EXIF image data::\n\n      from PIL import Image\n      im = Image.open(\"exif.png\")\n      exif = im.getexif()  # Returns an instance of this class\n\n    Information can be read and written, iterated over or deleted::\n\n      print(exif[274])  # 1\n      exif[274] = 2\n      for k, v in exif.items():\n        print(\"Tag\", k, \"Value\", v)  # Tag 274 Value 2\n      del exif[274]\n\n    To access information beyond IFD0, :py:meth:`~PIL.Image.Exif.get_ifd`\n    returns a dictionary::\n\n      from PIL import ExifTags\n      im = Image.open(\"exif_gps.jpg\")\n      exif = im.getexif()\n      gps_ifd = exif.get_ifd(ExifTags.IFD.GPSInfo)\n      print(gps_ifd)\n\n    Other IFDs include ``ExifTags.IFD.Exif``, ``ExifTags.IFD.Makernote``,\n    ``ExifTags.IFD.Interop`` and ``ExifTags.IFD.IFD1``.\n\n    :py:mod:`~PIL.ExifTags` also has enum classes to provide names for data::\n\n      print(exif[ExifTags.Base.Software])  # PIL\n      print(gps_ifd[ExifTags.GPS.GPSDateStamp])  # 1999:99:99 99:99:99\n    \"\"\"\n\n    endian = None\n    bigtiff = False\n    _loaded = False\n\n    def __init__(self):\n        self._data = {}\n        self._hidden_data = {}\n        self._ifds = {}\n        self._info = None\n        self._loaded_exif = None\n\n    def _fixup(self, value):\n        try:\n            if len(value) == 1 and isinstance(value, tuple):\n                return value[0]\n        except Exception:\n            pass\n        return value\n\n    def _fixup_dict(self, src_dict):\n        # Helper function\n        # returns a dict with any single item tuples/lists as individual values\n        return {k: self._fixup(v) for k, v in src_dict.items()}\n\n    def _get_ifd_dict(self, offset, group=None):\n        try:\n            # an offset pointer to the location of the nested embedded IFD.\n            # It should be a long, but may be corrupted.\n            self.fp.seek(offset)\n        except (KeyError, TypeError):\n            pass\n        else:\n            from . import TiffImagePlugin\n\n            info = TiffImagePlugin.ImageFileDirectory_v2(self.head, group=group)\n            info.load(self.fp)\n            return self._fixup_dict(info)\n\n    def _get_head(self):\n        version = b\"\\x2B\" if self.bigtiff else b\"\\x2A\"\n        if self.endian == \"<\":\n            head = b\"II\" + version + b\"\\x00\" + o32le(8)\n        else:\n            head = b\"MM\\x00\" + version + o32be(8)\n        if self.bigtiff:\n            head += o32le(8) if self.endian == \"<\" else o32be(8)\n            head += b\"\\x00\\x00\\x00\\x00\"\n        return head\n\n    def load(self, data):\n        # Extract EXIF information.  This is highly experimental,\n        # and is likely to be replaced with something better in a future\n        # version.\n\n        # The EXIF record consists of a TIFF file embedded in a JPEG\n        # application marker (!).\n        if data == self._loaded_exif:\n            return\n        self._loaded_exif = data\n        self._data.clear()\n        self._hidden_data.clear()\n        self._ifds.clear()\n        if data and data.startswith(b\"Exif\\x00\\x00\"):\n            data = data[6:]\n        if not data:\n            self._info = None\n            return\n\n        self.fp = io.BytesIO(data)\n        self.head = self.fp.read(8)\n        # process dictionary\n        from . import TiffImagePlugin\n\n        self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)\n        self.endian = self._info._endian\n        self.fp.seek(self._info.next)\n        self._info.load(self.fp)\n\n    def load_from_fp(self, fp, offset=None):\n        self._loaded_exif = None\n        self._data.clear()\n        self._hidden_data.clear()\n        self._ifds.clear()\n\n        # process dictionary\n        from . import TiffImagePlugin\n\n        self.fp = fp\n        if offset is not None:\n            self.head = self._get_head()\n        else:\n            self.head = self.fp.read(8)\n        self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)\n        if self.endian is None:\n            self.endian = self._info._endian\n        if offset is None:\n            offset = self._info.next\n        self.fp.tell()\n        self.fp.seek(offset)\n        self._info.load(self.fp)\n\n    def _get_merged_dict(self):\n        merged_dict = dict(self)\n\n        # get EXIF extension\n        if ExifTags.IFD.Exif in self:\n            ifd = self._get_ifd_dict(self[ExifTags.IFD.Exif], ExifTags.IFD.Exif)\n            if ifd:\n                merged_dict.update(ifd)\n\n        # GPS\n        if ExifTags.IFD.GPSInfo in self:\n            merged_dict[ExifTags.IFD.GPSInfo] = self._get_ifd_dict(\n                self[ExifTags.IFD.GPSInfo], ExifTags.IFD.GPSInfo\n            )\n\n        return merged_dict\n\n    def tobytes(self, offset: int = 8) -> bytes:\n        from . import TiffImagePlugin\n\n        head = self._get_head()\n        ifd = TiffImagePlugin.ImageFileDirectory_v2(ifh=head)\n        for tag, value in self.items():\n            if tag in [\n                ExifTags.IFD.Exif,\n                ExifTags.IFD.GPSInfo,\n            ] and not isinstance(value, dict):\n                value = self.get_ifd(tag)\n                if (\n                    tag == ExifTags.IFD.Exif\n                    and ExifTags.IFD.Interop in value\n                    and not isinstance(value[ExifTags.IFD.Interop], dict)\n                ):\n                    value = value.copy()\n                    value[ExifTags.IFD.Interop] = self.get_ifd(ExifTags.IFD.Interop)\n            ifd[tag] = value\n        return b\"Exif\\x00\\x00\" + head + ifd.tobytes(offset)\n\n    def get_ifd(self, tag):\n        if tag not in self._ifds:\n            if tag == ExifTags.IFD.IFD1:\n                if self._info is not None and self._info.next != 0:\n                    self._ifds[tag] = self._get_ifd_dict(self._info.next)\n            elif tag in [ExifTags.IFD.Exif, ExifTags.IFD.GPSInfo]:\n                offset = self._hidden_data.get(tag, self.get(tag))\n                if offset is not None:\n                    self._ifds[tag] = self._get_ifd_dict(offset, tag)\n            elif tag in [ExifTags.IFD.Interop, ExifTags.IFD.Makernote]:\n                if ExifTags.IFD.Exif not in self._ifds:\n                    self.get_ifd(ExifTags.IFD.Exif)\n                tag_data = self._ifds[ExifTags.IFD.Exif][tag]\n                if tag == ExifTags.IFD.Makernote:\n                    from .TiffImagePlugin import ImageFileDirectory_v2\n\n                    if tag_data[:8] == b\"FUJIFILM\":\n                        ifd_offset = i32le(tag_data, 8)\n                        ifd_data = tag_data[ifd_offset:]\n\n                        makernote = {}\n                        for i in range(0, struct.unpack(\"<H\", ifd_data[:2])[0]):\n                            ifd_tag, typ, count, data = struct.unpack(\n                                \"<HHL4s\", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]\n                            )\n                            try:\n                                (\n                                    unit_size,\n                                    handler,\n                                ) = ImageFileDirectory_v2._load_dispatch[typ]\n                            except KeyError:\n                                continue\n                            size = count * unit_size\n                            if size > 4:\n                                (offset,) = struct.unpack(\"<L\", data)\n                                data = ifd_data[offset - 12 : offset + size - 12]\n                            else:\n                                data = data[:size]\n\n                            if len(data) != size:\n                                warnings.warn(\n                                    \"Possibly corrupt EXIF MakerNote data.  \"\n                                    f\"Expecting to read {size} bytes but only got \"\n                                    f\"{len(data)}. Skipping tag {ifd_tag}\"\n                                )\n                                continue\n\n                            if not data:\n                                continue\n\n                            makernote[ifd_tag] = handler(\n                                ImageFileDirectory_v2(), data, False\n                            )\n                        self._ifds[tag] = dict(self._fixup_dict(makernote))\n                    elif self.get(0x010F) == \"Nintendo\":\n                        makernote = {}\n                        for i in range(0, struct.unpack(\">H\", tag_data[:2])[0]):\n                            ifd_tag, typ, count, data = struct.unpack(\n                                \">HHL4s\", tag_data[i * 12 + 2 : (i + 1) * 12 + 2]\n                            )\n                            if ifd_tag == 0x1101:\n                                # CameraInfo\n                                (offset,) = struct.unpack(\">L\", data)\n                                self.fp.seek(offset)\n\n                                camerainfo = {\"ModelID\": self.fp.read(4)}\n\n                                self.fp.read(4)\n                                # Seconds since 2000\n                                camerainfo[\"TimeStamp\"] = i32le(self.fp.read(12))\n\n                                self.fp.read(4)\n                                camerainfo[\"InternalSerialNumber\"] = self.fp.read(4)\n\n                                self.fp.read(12)\n                                parallax = self.fp.read(4)\n                                handler = ImageFileDirectory_v2._load_dispatch[\n                                    TiffTags.FLOAT\n                                ][1]\n                                camerainfo[\"Parallax\"] = handler(\n                                    ImageFileDirectory_v2(), parallax, False\n                                )\n\n                                self.fp.read(4)\n                                camerainfo[\"Category\"] = self.fp.read(2)\n\n                                makernote = {0x1101: dict(self._fixup_dict(camerainfo))}\n                        self._ifds[tag] = makernote\n                else:\n                    # Interop\n                    self._ifds[tag] = self._get_ifd_dict(tag_data, tag)\n        ifd = self._ifds.get(tag, {})\n        if tag == ExifTags.IFD.Exif and self._hidden_data:\n            ifd = {\n                k: v\n                for (k, v) in ifd.items()\n                if k not in (ExifTags.IFD.Interop, ExifTags.IFD.Makernote)\n            }\n        return ifd\n\n    def hide_offsets(self) -> None:\n        for tag in (ExifTags.IFD.Exif, ExifTags.IFD.GPSInfo):\n            if tag in self:\n                self._hidden_data[tag] = self[tag]\n                del self[tag]\n\n    def __str__(self) -> str:\n        if self._info is not None:\n            # Load all keys into self._data\n            for tag in self._info:\n                self[tag]\n\n        return str(self._data)\n\n    def __len__(self) -> int:\n        keys = set(self._data)\n        if self._info is not None:\n            keys.update(self._info)\n        return len(keys)\n\n    def __getitem__(self, tag):\n        if self._info is not None and tag not in self._data and tag in self._info:\n            self._data[tag] = self._fixup(self._info[tag])\n            del self._info[tag]\n        return self._data[tag]\n\n    def __contains__(self, tag) -> bool:\n        return tag in self._data or (self._info is not None and tag in self._info)\n\n    def __setitem__(self, tag, value) -> None:\n        if self._info is not None and tag in self._info:\n            del self._info[tag]\n        self._data[tag] = value\n\n    def __delitem__(self, tag: int) -> None:\n        if self._info is not None and tag in self._info:\n            del self._info[tag]\n        else:\n            del self._data[tag]\n\n    def __iter__(self):\n        keys = set(self._data)\n        if self._info is not None:\n            keys.update(self._info)\n        return iter(keys)\n", "src/PIL/FliImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# FLI/FLC file handling.\n#\n# History:\n#       95-09-01 fl     Created\n#       97-01-03 fl     Fixed parser, setup decoder tile\n#       98-07-15 fl     Renamed offset attribute to avoid name clash\n#\n# Copyright (c) Secret Labs AB 1997-98.\n# Copyright (c) Fredrik Lundh 1995-97.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\nfrom ._binary import o8\n\n#\n# decoder\n\n\ndef _accept(prefix: bytes) -> bool:\n    return (\n        len(prefix) >= 6\n        and i16(prefix, 4) in [0xAF11, 0xAF12]\n        and i16(prefix, 14) in [0, 3]  # flags\n    )\n\n\n##\n# Image plugin for the FLI/FLC animation format.  Use the <b>seek</b>\n# method to load individual frames.\n\n\nclass FliImageFile(ImageFile.ImageFile):\n    format = \"FLI\"\n    format_description = \"Autodesk FLI/FLC Animation\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self):\n        # HEAD\n        s = self.fp.read(128)\n        if not (_accept(s) and s[20:22] == b\"\\x00\\x00\"):\n            msg = \"not an FLI/FLC file\"\n            raise SyntaxError(msg)\n\n        # frames\n        self.n_frames = i16(s, 6)\n        self.is_animated = self.n_frames > 1\n\n        # image characteristics\n        self._mode = \"P\"\n        self._size = i16(s, 8), i16(s, 10)\n\n        # animation speed\n        duration = i32(s, 16)\n        magic = i16(s, 4)\n        if magic == 0xAF11:\n            duration = (duration * 1000) // 70\n        self.info[\"duration\"] = duration\n\n        # look for palette\n        palette = [(a, a, a) for a in range(256)]\n\n        s = self.fp.read(16)\n\n        self.__offset = 128\n\n        if i16(s, 4) == 0xF100:\n            # prefix chunk; ignore it\n            self.__offset = self.__offset + i32(s)\n            self.fp.seek(self.__offset)\n            s = self.fp.read(16)\n\n        if i16(s, 4) == 0xF1FA:\n            # look for palette chunk\n            number_of_subchunks = i16(s, 6)\n            chunk_size = None\n            for _ in range(number_of_subchunks):\n                if chunk_size is not None:\n                    self.fp.seek(chunk_size - 6, os.SEEK_CUR)\n                s = self.fp.read(6)\n                chunk_type = i16(s, 4)\n                if chunk_type in (4, 11):\n                    self._palette(palette, 2 if chunk_type == 11 else 0)\n                    break\n                chunk_size = i32(s)\n                if not chunk_size:\n                    break\n\n        palette = [o8(r) + o8(g) + o8(b) for (r, g, b) in palette]\n        self.palette = ImagePalette.raw(\"RGB\", b\"\".join(palette))\n\n        # set things up to decode first frame\n        self.__frame = -1\n        self._fp = self.fp\n        self.__rewind = self.fp.tell()\n        self.seek(0)\n\n    def _palette(self, palette, shift):\n        # load palette\n\n        i = 0\n        for e in range(i16(self.fp.read(2))):\n            s = self.fp.read(2)\n            i = i + s[0]\n            n = s[1]\n            if n == 0:\n                n = 256\n            s = self.fp.read(n * 3)\n            for n in range(0, len(s), 3):\n                r = s[n] << shift\n                g = s[n + 1] << shift\n                b = s[n + 2] << shift\n                palette[i] = (r, g, b)\n                i += 1\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        if frame < self.__frame:\n            self._seek(0)\n\n        for f in range(self.__frame + 1, frame + 1):\n            self._seek(f)\n\n    def _seek(self, frame: int) -> None:\n        if frame == 0:\n            self.__frame = -1\n            self._fp.seek(self.__rewind)\n            self.__offset = 128\n        else:\n            # ensure that the previous frame was loaded\n            self.load()\n\n        if frame != self.__frame + 1:\n            msg = f\"cannot seek to frame {frame}\"\n            raise ValueError(msg)\n        self.__frame = frame\n\n        # move to next frame\n        self.fp = self._fp\n        self.fp.seek(self.__offset)\n\n        s = self.fp.read(4)\n        if not s:\n            msg = \"missing frame size\"\n            raise EOFError(msg)\n\n        framesize = i32(s)\n\n        self.decodermaxblock = framesize\n        self.tile = [(\"fli\", (0, 0) + self.size, self.__offset, None)]\n\n        self.__offset += framesize\n\n    def tell(self) -> int:\n        return self.__frame\n\n\n#\n# registry\n\nImage.register_open(FliImageFile.format, FliImageFile, _accept)\n\nImage.register_extensions(FliImageFile.format, [\".fli\", \".flc\"])\n", "src/PIL/ImageMath.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# a simple math add-on for the Python Imaging Library\n#\n# History:\n# 1999-02-15 fl   Original PIL Plus release\n# 2005-05-05 fl   Simplified and cleaned up for PIL 1.1.6\n# 2005-09-12 fl   Fixed int() and float() for Python 2.4.1\n#\n# Copyright (c) 1999-2005 by Secret Labs AB\n# Copyright (c) 2005 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport builtins\nfrom types import CodeType\nfrom typing import Any, Callable\n\nfrom . import Image, _imagingmath\nfrom ._deprecate import deprecate\n\n\nclass _Operand:\n    \"\"\"Wraps an image operand, providing standard operators\"\"\"\n\n    def __init__(self, im: Image.Image):\n        self.im = im\n\n    def __fixup(self, im1: _Operand | float) -> Image.Image:\n        # convert image to suitable mode\n        if isinstance(im1, _Operand):\n            # argument was an image.\n            if im1.im.mode in (\"1\", \"L\"):\n                return im1.im.convert(\"I\")\n            elif im1.im.mode in (\"I\", \"F\"):\n                return im1.im\n            else:\n                msg = f\"unsupported mode: {im1.im.mode}\"\n                raise ValueError(msg)\n        else:\n            # argument was a constant\n            if isinstance(im1, (int, float)) and self.im.mode in (\"1\", \"L\", \"I\"):\n                return Image.new(\"I\", self.im.size, im1)\n            else:\n                return Image.new(\"F\", self.im.size, im1)\n\n    def apply(\n        self,\n        op: str,\n        im1: _Operand | float,\n        im2: _Operand | float | None = None,\n        mode: str | None = None,\n    ) -> _Operand:\n        im_1 = self.__fixup(im1)\n        if im2 is None:\n            # unary operation\n            out = Image.new(mode or im_1.mode, im_1.size, None)\n            im_1.load()\n            try:\n                op = getattr(_imagingmath, f\"{op}_{im_1.mode}\")\n            except AttributeError as e:\n                msg = f\"bad operand type for '{op}'\"\n                raise TypeError(msg) from e\n            _imagingmath.unop(op, out.im.id, im_1.im.id)\n        else:\n            # binary operation\n            im_2 = self.__fixup(im2)\n            if im_1.mode != im_2.mode:\n                # convert both arguments to floating point\n                if im_1.mode != \"F\":\n                    im_1 = im_1.convert(\"F\")\n                if im_2.mode != \"F\":\n                    im_2 = im_2.convert(\"F\")\n            if im_1.size != im_2.size:\n                # crop both arguments to a common size\n                size = (\n                    min(im_1.size[0], im_2.size[0]),\n                    min(im_1.size[1], im_2.size[1]),\n                )\n                if im_1.size != size:\n                    im_1 = im_1.crop((0, 0) + size)\n                if im_2.size != size:\n                    im_2 = im_2.crop((0, 0) + size)\n            out = Image.new(mode or im_1.mode, im_1.size, None)\n            im_1.load()\n            im_2.load()\n            try:\n                op = getattr(_imagingmath, f\"{op}_{im_1.mode}\")\n            except AttributeError as e:\n                msg = f\"bad operand type for '{op}'\"\n                raise TypeError(msg) from e\n            _imagingmath.binop(op, out.im.id, im_1.im.id, im_2.im.id)\n        return _Operand(out)\n\n    # unary operators\n    def __bool__(self) -> bool:\n        # an image is \"true\" if it contains at least one non-zero pixel\n        return self.im.getbbox() is not None\n\n    def __abs__(self) -> _Operand:\n        return self.apply(\"abs\", self)\n\n    def __pos__(self) -> _Operand:\n        return self\n\n    def __neg__(self) -> _Operand:\n        return self.apply(\"neg\", self)\n\n    # binary operators\n    def __add__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"add\", self, other)\n\n    def __radd__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"add\", other, self)\n\n    def __sub__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"sub\", self, other)\n\n    def __rsub__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"sub\", other, self)\n\n    def __mul__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mul\", self, other)\n\n    def __rmul__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mul\", other, self)\n\n    def __truediv__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"div\", self, other)\n\n    def __rtruediv__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"div\", other, self)\n\n    def __mod__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mod\", self, other)\n\n    def __rmod__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mod\", other, self)\n\n    def __pow__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"pow\", self, other)\n\n    def __rpow__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"pow\", other, self)\n\n    # bitwise\n    def __invert__(self) -> _Operand:\n        return self.apply(\"invert\", self)\n\n    def __and__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"and\", self, other)\n\n    def __rand__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"and\", other, self)\n\n    def __or__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"or\", self, other)\n\n    def __ror__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"or\", other, self)\n\n    def __xor__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"xor\", self, other)\n\n    def __rxor__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"xor\", other, self)\n\n    def __lshift__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"lshift\", self, other)\n\n    def __rshift__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"rshift\", self, other)\n\n    # logical\n    def __eq__(self, other):\n        return self.apply(\"eq\", self, other)\n\n    def __ne__(self, other):\n        return self.apply(\"ne\", self, other)\n\n    def __lt__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"lt\", self, other)\n\n    def __le__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"le\", self, other)\n\n    def __gt__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"gt\", self, other)\n\n    def __ge__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"ge\", self, other)\n\n\n# conversions\ndef imagemath_int(self: _Operand) -> _Operand:\n    return _Operand(self.im.convert(\"I\"))\n\n\ndef imagemath_float(self: _Operand) -> _Operand:\n    return _Operand(self.im.convert(\"F\"))\n\n\n# logical\ndef imagemath_equal(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"eq\", self, other, mode=\"I\")\n\n\ndef imagemath_notequal(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"ne\", self, other, mode=\"I\")\n\n\ndef imagemath_min(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"min\", self, other)\n\n\ndef imagemath_max(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"max\", self, other)\n\n\ndef imagemath_convert(self: _Operand, mode: str) -> _Operand:\n    return _Operand(self.im.convert(mode))\n\n\nops = {\n    \"int\": imagemath_int,\n    \"float\": imagemath_float,\n    \"equal\": imagemath_equal,\n    \"notequal\": imagemath_notequal,\n    \"min\": imagemath_min,\n    \"max\": imagemath_max,\n    \"convert\": imagemath_convert,\n}\n\n\ndef lambda_eval(\n    expression: Callable[[dict[str, Any]], Any],\n    options: dict[str, Any] = {},\n    **kw: Any,\n) -> Any:\n    \"\"\"\n    Returns the result of an image function.\n\n    :py:mod:`~PIL.ImageMath` only supports single-layer images. To process multi-band\n    images, use the :py:meth:`~PIL.Image.Image.split` method or\n    :py:func:`~PIL.Image.merge` function.\n\n    :param expression: A function that receives a dictionary.\n    :param options: Values to add to the function's dictionary. You\n                    can either use a dictionary, or one or more keyword\n                    arguments.\n    :return: The expression result. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.\n    \"\"\"\n\n    args: dict[str, Any] = ops.copy()\n    args.update(options)\n    args.update(kw)\n    for k, v in args.items():\n        if hasattr(v, \"im\"):\n            args[k] = _Operand(v)\n\n    out = expression(args)\n    try:\n        return out.im\n    except AttributeError:\n        return out\n\n\ndef unsafe_eval(\n    expression: str,\n    options: dict[str, Any] = {},\n    **kw: Any,\n) -> Any:\n    \"\"\"\n    Evaluates an image expression. This uses Python's ``eval()`` function to process\n    the expression string, and carries the security risks of doing so. It is not\n    recommended to process expressions without considering this.\n    :py:meth:`~lambda_eval` is a more secure alternative.\n\n    :py:mod:`~PIL.ImageMath` only supports single-layer images. To process multi-band\n    images, use the :py:meth:`~PIL.Image.Image.split` method or\n    :py:func:`~PIL.Image.merge` function.\n\n    :param expression: A string containing a Python-style expression.\n    :param options: Values to add to the evaluation context.  You\n                    can either use a dictionary, or one or more keyword\n                    arguments.\n    :return: The evaluated expression. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.\n    \"\"\"\n\n    # build execution namespace\n    args: dict[str, Any] = ops.copy()\n    for k in list(options.keys()) + list(kw.keys()):\n        if \"__\" in k or hasattr(builtins, k):\n            msg = f\"'{k}' not allowed\"\n            raise ValueError(msg)\n\n    args.update(options)\n    args.update(kw)\n    for k, v in args.items():\n        if hasattr(v, \"im\"):\n            args[k] = _Operand(v)\n\n    compiled_code = compile(expression, \"<string>\", \"eval\")\n\n    def scan(code: CodeType) -> None:\n        for const in code.co_consts:\n            if type(const) is type(compiled_code):\n                scan(const)\n\n        for name in code.co_names:\n            if name not in args and name != \"abs\":\n                msg = f\"'{name}' not allowed\"\n                raise ValueError(msg)\n\n    scan(compiled_code)\n    out = builtins.eval(expression, {\"__builtins\": {\"abs\": abs}}, args)\n    try:\n        return out.im\n    except AttributeError:\n        return out\n\n\ndef eval(\n    expression: str,\n    _dict: dict[str, Any] = {},\n    **kw: Any,\n) -> Any:\n    \"\"\"\n    Evaluates an image expression.\n\n    Deprecated. Use lambda_eval() or unsafe_eval() instead.\n\n    :param expression: A string containing a Python-style expression.\n    :param _dict: Values to add to the evaluation context.  You\n                  can either use a dictionary, or one or more keyword\n                  arguments.\n    :return: The evaluated expression. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.\n\n    ..  deprecated:: 10.3.0\n    \"\"\"\n\n    deprecate(\n        \"ImageMath.eval\",\n        12,\n        \"ImageMath.lambda_eval or ImageMath.unsafe_eval\",\n    )\n    return unsafe_eval(expression, _dict, **kw)\n", "src/PIL/JpegPresets.py": "\"\"\"\nJPEG quality settings equivalent to the Photoshop settings.\nCan be used when saving JPEG files.\n\nThe following presets are available by default:\n``web_low``, ``web_medium``, ``web_high``, ``web_very_high``, ``web_maximum``,\n``low``, ``medium``, ``high``, ``maximum``.\nMore presets can be added to the :py:data:`presets` dict if needed.\n\nTo apply the preset, specify::\n\n  quality=\"preset_name\"\n\nTo apply only the quantization table::\n\n  qtables=\"preset_name\"\n\nTo apply only the subsampling setting::\n\n  subsampling=\"preset_name\"\n\nExample::\n\n  im.save(\"image_name.jpg\", quality=\"web_high\")\n\nSubsampling\n-----------\n\nSubsampling is the practice of encoding images by implementing less resolution\nfor chroma information than for luma information.\n(ref.: https://en.wikipedia.org/wiki/Chroma_subsampling)\n\nPossible subsampling values are 0, 1 and 2 that correspond to 4:4:4, 4:2:2 and\n4:2:0.\n\nYou can get the subsampling of a JPEG with the\n:func:`.JpegImagePlugin.get_sampling` function.\n\nIn JPEG compressed data a JPEG marker is used instead of an EXIF\u00a0tag.\n(ref.: https://web.archive.org/web/20240227115053/https://exiv2.org/tags.html)\n\n\nQuantization tables\n-------------------\n\nThey are values use by the DCT (Discrete cosine transform) to remove\n*unnecessary* information from the image (the lossy part of the compression).\n(ref.: https://en.wikipedia.org/wiki/Quantization_matrix#Quantization_matrices,\nhttps://en.wikipedia.org/wiki/JPEG#Quantization)\n\nYou can get the quantization tables of a JPEG with::\n\n  im.quantization\n\nThis will return a dict with a number of lists. You can pass this dict\ndirectly as the qtables argument when saving a JPEG.\n\nThe quantization table format in presets is a list with sublists. These formats\nare interchangeable.\n\nLibjpeg ref.:\nhttps://web.archive.org/web/20120328125543/http://www.jpegcameras.com/libjpeg/libjpeg-3.html\n\n\"\"\"\n\nfrom __future__ import annotations\n\n# fmt: off\npresets = {\n            'web_low':      {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [20, 16, 25, 39, 50, 46, 62, 68,\n                                16, 18, 23, 38, 38, 53, 65, 68,\n                                25, 23, 31, 38, 53, 65, 68, 68,\n                                39, 38, 38, 53, 65, 68, 68, 68,\n                                50, 38, 53, 65, 68, 68, 68, 68,\n                                46, 53, 65, 68, 68, 68, 68, 68,\n                                62, 65, 68, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68],\n                               [21, 25, 32, 38, 54, 68, 68, 68,\n                                25, 28, 24, 38, 54, 68, 68, 68,\n                                32, 24, 32, 43, 66, 68, 68, 68,\n                                38, 38, 43, 53, 68, 68, 68, 68,\n                                54, 54, 66, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68]\n                              ]},\n            'web_medium':   {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [16, 11, 11, 16, 23, 27, 31, 30,\n                                11, 12, 12, 15, 20, 23, 23, 30,\n                                11, 12, 13, 16, 23, 26, 35, 47,\n                                16, 15, 16, 23, 26, 37, 47, 64,\n                                23, 20, 23, 26, 39, 51, 64, 64,\n                                27, 23, 26, 37, 51, 64, 64, 64,\n                                31, 23, 35, 47, 64, 64, 64, 64,\n                                30, 30, 47, 64, 64, 64, 64, 64],\n                               [17, 15, 17, 21, 20, 26, 38, 48,\n                                15, 19, 18, 17, 20, 26, 35, 43,\n                                17, 18, 20, 22, 26, 30, 46, 53,\n                                21, 17, 22, 28, 30, 39, 53, 64,\n                                20, 20, 26, 30, 39, 48, 64, 64,\n                                26, 26, 30, 39, 48, 63, 64, 64,\n                                38, 35, 46, 53, 64, 64, 64, 64,\n                                48, 43, 53, 64, 64, 64, 64, 64]\n                             ]},\n            'web_high':     {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                               [6,   4,  4,  6,  9, 11, 12, 16,\n                                4,   5,  5,  6,  8, 10, 12, 12,\n                                4,   5,  5,  6, 10, 12, 14, 19,\n                                6,   6,  6, 11, 12, 15, 19, 28,\n                                9,   8, 10, 12, 16, 20, 27, 31,\n                                11, 10, 12, 15, 20, 27, 31, 31,\n                                12, 12, 14, 19, 27, 31, 31, 31,\n                                16, 12, 19, 28, 31, 31, 31, 31],\n                               [7,   7, 13, 24, 26, 31, 31, 31,\n                                7,  12, 16, 21, 31, 31, 31, 31,\n                                13, 16, 17, 31, 31, 31, 31, 31,\n                                24, 21, 31, 31, 31, 31, 31, 31,\n                                26, 31, 31, 31, 31, 31, 31, 31,\n                                31, 31, 31, 31, 31, 31, 31, 31,\n                                31, 31, 31, 31, 31, 31, 31, 31,\n                                31, 31, 31, 31, 31, 31, 31, 31]\n                             ]},\n            'web_very_high': {'subsampling':  0,  # \"4:4:4\"\n                              'quantization': [\n                               [2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  4,  5,  7,  9,\n                                2,   2,  2,  4,  5,  7,  9, 12,\n                                3,   3,  4,  5,  8, 10, 12, 12,\n                                4,   4,  5,  7, 10, 12, 12, 12,\n                                5,   5,  7,  9, 12, 12, 12, 12,\n                                6,   6,  9, 12, 12, 12, 12, 12],\n                               [3,   3,  5,  9, 13, 15, 15, 15,\n                                3,   4,  6, 11, 14, 12, 12, 12,\n                                5,   6,  9, 14, 12, 12, 12, 12,\n                                9,  11, 14, 12, 12, 12, 12, 12,\n                                13, 14, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12]\n                              ]},\n            'web_maximum':  {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                                [1,  1,  1,  1,  1,  1,  1,  1,\n                                 1,  1,  1,  1,  1,  1,  1,  1,\n                                 1,  1,  1,  1,  1,  1,  1,  2,\n                                 1,  1,  1,  1,  1,  1,  2,  2,\n                                 1,  1,  1,  1,  1,  2,  2,  3,\n                                 1,  1,  1,  1,  2,  2,  3,  3,\n                                 1,  1,  1,  2,  2,  3,  3,  3,\n                                 1,  1,  2,  2,  3,  3,  3,  3],\n                                [1,  1,  1,  2,  2,  3,  3,  3,\n                                 1,  1,  1,  2,  3,  3,  3,  3,\n                                 1,  1,  1,  3,  3,  3,  3,  3,\n                                 2,  2,  3,  3,  3,  3,  3,  3,\n                                 2,  3,  3,  3,  3,  3,  3,  3,\n                                 3,  3,  3,  3,  3,  3,  3,  3,\n                                 3,  3,  3,  3,  3,  3,  3,  3,\n                                 3,  3,  3,  3,  3,  3,  3,  3]\n                             ]},\n            'low':          {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [18, 14, 14, 21, 30, 35, 34, 17,\n                                14, 16, 16, 19, 26, 23, 12, 12,\n                                14, 16, 17, 21, 23, 12, 12, 12,\n                                21, 19, 21, 23, 12, 12, 12, 12,\n                                30, 26, 23, 12, 12, 12, 12, 12,\n                                35, 23, 12, 12, 12, 12, 12, 12,\n                                34, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12],\n                               [20, 19, 22, 27, 20, 20, 17, 17,\n                                19, 25, 23, 14, 14, 12, 12, 12,\n                                22, 23, 14, 14, 12, 12, 12, 12,\n                                27, 14, 14, 12, 12, 12, 12, 12,\n                                20, 14, 12, 12, 12, 12, 12, 12,\n                                20, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n            'medium':       {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [12,  8,  8, 12, 17, 21, 24, 17,\n                                8,   9,  9, 11, 15, 19, 12, 12,\n                                8,   9, 10, 12, 19, 12, 12, 12,\n                                12, 11, 12, 21, 12, 12, 12, 12,\n                                17, 15, 19, 12, 12, 12, 12, 12,\n                                21, 19, 12, 12, 12, 12, 12, 12,\n                                24, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12],\n                               [13, 11, 13, 16, 20, 20, 17, 17,\n                                11, 14, 14, 14, 14, 12, 12, 12,\n                                13, 14, 14, 14, 12, 12, 12, 12,\n                                16, 14, 14, 12, 12, 12, 12, 12,\n                                20, 14, 12, 12, 12, 12, 12, 12,\n                                20, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n            'high':         {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                               [6,   4,  4,  6,  9, 11, 12, 16,\n                                4,   5,  5,  6,  8, 10, 12, 12,\n                                4,   5,  5,  6, 10, 12, 12, 12,\n                                6,   6,  6, 11, 12, 12, 12, 12,\n                                9,   8, 10, 12, 12, 12, 12, 12,\n                                11, 10, 12, 12, 12, 12, 12, 12,\n                                12, 12, 12, 12, 12, 12, 12, 12,\n                                16, 12, 12, 12, 12, 12, 12, 12],\n                               [7,   7, 13, 24, 20, 20, 17, 17,\n                                7,  12, 16, 14, 14, 12, 12, 12,\n                                13, 16, 14, 14, 12, 12, 12, 12,\n                                24, 14, 14, 12, 12, 12, 12, 12,\n                                20, 14, 12, 12, 12, 12, 12, 12,\n                                20, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n            'maximum':      {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                               [2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  4,  5,  7,  9,\n                                2,   2,  2,  4,  5,  7,  9, 12,\n                                3,   3,  4,  5,  8, 10, 12, 12,\n                                4,   4,  5,  7, 10, 12, 12, 12,\n                                5,   5,  7,  9, 12, 12, 12, 12,\n                                6,   6,  9, 12, 12, 12, 12, 12],\n                               [3,   3,  5,  9, 13, 15, 15, 15,\n                                3,   4,  6, 10, 14, 12, 12, 12,\n                                5,   6,  9, 14, 12, 12, 12, 12,\n                                9,  10, 14, 12, 12, 12, 12, 12,\n                                13, 14, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n}\n# fmt: on\n", "src/PIL/TiffTags.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# TIFF tags\n#\n# This module provides clear-text names for various well-known\n# TIFF tags.  the TIFF codec works just fine without it.\n#\n# Copyright (c) Secret Labs AB 1999.\n#\n# See the README file for information on usage and redistribution.\n#\n\n##\n# This module provides constants and clear-text names for various\n# well-known TIFF tags.\n##\nfrom __future__ import annotations\n\nfrom typing import NamedTuple\n\n\nclass _TagInfo(NamedTuple):\n    value: int | None\n    name: str\n    type: int | None\n    length: int | None\n    enum: dict[str, int]\n\n\nclass TagInfo(_TagInfo):\n    __slots__: list[str] = []\n\n    def __new__(cls, value=None, name=\"unknown\", type=None, length=None, enum=None):\n        return super().__new__(cls, value, name, type, length, enum or {})\n\n    def cvt_enum(self, value):\n        # Using get will call hash(value), which can be expensive\n        # for some types (e.g. Fraction). Since self.enum is rarely\n        # used, it's usually better to test it first.\n        return self.enum.get(value, value) if self.enum else value\n\n\ndef lookup(tag, group=None):\n    \"\"\"\n    :param tag: Integer tag number\n    :param group: Which :py:data:`~PIL.TiffTags.TAGS_V2_GROUPS` to look in\n\n    .. versionadded:: 8.3.0\n\n    :returns: Taginfo namedtuple, From the ``TAGS_V2`` info if possible,\n        otherwise just populating the value and name from ``TAGS``.\n        If the tag is not recognized, \"unknown\" is returned for the name\n\n    \"\"\"\n\n    if group is not None:\n        info = TAGS_V2_GROUPS[group].get(tag) if group in TAGS_V2_GROUPS else None\n    else:\n        info = TAGS_V2.get(tag)\n    return info or TagInfo(tag, TAGS.get(tag, \"unknown\"))\n\n\n##\n# Map tag numbers to tag info.\n#\n#  id: (Name, Type, Length[, enum_values])\n#\n# The length here differs from the length in the tiff spec.  For\n# numbers, the tiff spec is for the number of fields returned. We\n# agree here.  For string-like types, the tiff spec uses the length of\n# field in bytes.  In Pillow, we are using the number of expected\n# fields, in general 1 for string-like types.\n\n\nBYTE = 1\nASCII = 2\nSHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\n\n_tags_v2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",\n        SHORT,\n        1,\n        {\n            \"Uncompressed\": 1,\n            \"CCITT 1d\": 2,\n            \"Group 3 Fax\": 3,\n            \"Group 4 Fax\": 4,\n            \"LZW\": 5,\n            \"JPEG\": 6,\n            \"PackBits\": 32773,\n        },\n    ),\n    262: (\n        \"PhotometricInterpretation\",\n        SHORT,\n        1,\n        {\n            \"WhiteIsZero\": 0,\n            \"BlackIsZero\": 1,\n            \"RGB\": 2,\n            \"RGB Palette\": 3,\n            \"Transparency Mask\": 4,\n            \"CMYK\": 5,\n            \"YCbCr\": 6,\n            \"CieLAB\": 8,\n            \"CFA\": 32803,  # TIFF/EP, Adobe DNG\n            \"LinearRaw\": 32892,  # Adobe DNG\n        },\n    ),\n    263: (\"Threshholding\", SHORT, 1),\n    264: (\"CellWidth\", SHORT, 1),\n    265: (\"CellLength\", SHORT, 1),\n    266: (\"FillOrder\", SHORT, 1),\n    269: (\"DocumentName\", ASCII, 1),\n    270: (\"ImageDescription\", ASCII, 1),\n    271: (\"Make\", ASCII, 1),\n    272: (\"Model\", ASCII, 1),\n    273: (\"StripOffsets\", LONG, 0),\n    274: (\"Orientation\", SHORT, 1),\n    277: (\"SamplesPerPixel\", SHORT, 1),\n    278: (\"RowsPerStrip\", LONG, 1),\n    279: (\"StripByteCounts\", LONG, 0),\n    280: (\"MinSampleValue\", SHORT, 0),\n    281: (\"MaxSampleValue\", SHORT, 0),\n    282: (\"XResolution\", RATIONAL, 1),\n    283: (\"YResolution\", RATIONAL, 1),\n    284: (\"PlanarConfiguration\", SHORT, 1, {\"Contiguous\": 1, \"Separate\": 2}),\n    285: (\"PageName\", ASCII, 1),\n    286: (\"XPosition\", RATIONAL, 1),\n    287: (\"YPosition\", RATIONAL, 1),\n    288: (\"FreeOffsets\", LONG, 1),\n    289: (\"FreeByteCounts\", LONG, 1),\n    290: (\"GrayResponseUnit\", SHORT, 1),\n    291: (\"GrayResponseCurve\", SHORT, 0),\n    292: (\"T4Options\", LONG, 1),\n    293: (\"T6Options\", LONG, 1),\n    296: (\"ResolutionUnit\", SHORT, 1, {\"none\": 1, \"inch\": 2, \"cm\": 3}),\n    297: (\"PageNumber\", SHORT, 2),\n    301: (\"TransferFunction\", SHORT, 0),\n    305: (\"Software\", ASCII, 1),\n    306: (\"DateTime\", ASCII, 1),\n    315: (\"Artist\", ASCII, 1),\n    316: (\"HostComputer\", ASCII, 1),\n    317: (\"Predictor\", SHORT, 1, {\"none\": 1, \"Horizontal Differencing\": 2}),\n    318: (\"WhitePoint\", RATIONAL, 2),\n    319: (\"PrimaryChromaticities\", RATIONAL, 6),\n    320: (\"ColorMap\", SHORT, 0),\n    321: (\"HalftoneHints\", SHORT, 2),\n    322: (\"TileWidth\", LONG, 1),\n    323: (\"TileLength\", LONG, 1),\n    324: (\"TileOffsets\", LONG, 0),\n    325: (\"TileByteCounts\", LONG, 0),\n    330: (\"SubIFDs\", LONG, 0),\n    332: (\"InkSet\", SHORT, 1),\n    333: (\"InkNames\", ASCII, 1),\n    334: (\"NumberOfInks\", SHORT, 1),\n    336: (\"DotRange\", SHORT, 0),\n    337: (\"TargetPrinter\", ASCII, 1),\n    338: (\"ExtraSamples\", SHORT, 0),\n    339: (\"SampleFormat\", SHORT, 0),\n    340: (\"SMinSampleValue\", DOUBLE, 0),\n    341: (\"SMaxSampleValue\", DOUBLE, 0),\n    342: (\"TransferRange\", SHORT, 6),\n    347: (\"JPEGTables\", UNDEFINED, 1),\n    # obsolete JPEG tags\n    512: (\"JPEGProc\", SHORT, 1),\n    513: (\"JPEGInterchangeFormat\", LONG, 1),\n    514: (\"JPEGInterchangeFormatLength\", LONG, 1),\n    515: (\"JPEGRestartInterval\", SHORT, 1),\n    517: (\"JPEGLosslessPredictors\", SHORT, 0),\n    518: (\"JPEGPointTransforms\", SHORT, 0),\n    519: (\"JPEGQTables\", LONG, 0),\n    520: (\"JPEGDCTables\", LONG, 0),\n    521: (\"JPEGACTables\", LONG, 0),\n    529: (\"YCbCrCoefficients\", RATIONAL, 3),\n    530: (\"YCbCrSubSampling\", SHORT, 2),\n    531: (\"YCbCrPositioning\", SHORT, 1),\n    532: (\"ReferenceBlackWhite\", RATIONAL, 6),\n    700: (\"XMP\", BYTE, 0),\n    33432: (\"Copyright\", ASCII, 1),\n    33723: (\"IptcNaaInfo\", UNDEFINED, 1),\n    34377: (\"PhotoshopInfo\", BYTE, 0),\n    # FIXME add more tags here\n    34665: (\"ExifIFD\", LONG, 1),\n    34675: (\"ICCProfile\", UNDEFINED, 1),\n    34853: (\"GPSInfoIFD\", LONG, 1),\n    36864: (\"ExifVersion\", UNDEFINED, 1),\n    37724: (\"ImageSourceData\", UNDEFINED, 1),\n    40965: (\"InteroperabilityIFD\", LONG, 1),\n    41730: (\"CFAPattern\", UNDEFINED, 1),\n    # MPInfo\n    45056: (\"MPFVersion\", UNDEFINED, 1),\n    45057: (\"NumberOfImages\", LONG, 1),\n    45058: (\"MPEntry\", UNDEFINED, 1),\n    45059: (\"ImageUIDList\", UNDEFINED, 0),  # UNDONE, check\n    45060: (\"TotalFrames\", LONG, 1),\n    45313: (\"MPIndividualNum\", LONG, 1),\n    45569: (\"PanOrientation\", LONG, 1),\n    45570: (\"PanOverlap_H\", RATIONAL, 1),\n    45571: (\"PanOverlap_V\", RATIONAL, 1),\n    45572: (\"BaseViewpointNum\", LONG, 1),\n    45573: (\"ConvergenceAngle\", SIGNED_RATIONAL, 1),\n    45574: (\"BaselineLength\", RATIONAL, 1),\n    45575: (\"VerticalDivergence\", SIGNED_RATIONAL, 1),\n    45576: (\"AxisDistance_X\", SIGNED_RATIONAL, 1),\n    45577: (\"AxisDistance_Y\", SIGNED_RATIONAL, 1),\n    45578: (\"AxisDistance_Z\", SIGNED_RATIONAL, 1),\n    45579: (\"YawAngle\", SIGNED_RATIONAL, 1),\n    45580: (\"PitchAngle\", SIGNED_RATIONAL, 1),\n    45581: (\"RollAngle\", SIGNED_RATIONAL, 1),\n    40960: (\"FlashPixVersion\", UNDEFINED, 1),\n    50741: (\"MakerNoteSafety\", SHORT, 1, {\"Unsafe\": 0, \"Safe\": 1}),\n    50780: (\"BestQualityScale\", RATIONAL, 1),\n    50838: (\"ImageJMetaDataByteCounts\", LONG, 0),  # Can be more than one\n    50839: (\"ImageJMetaData\", UNDEFINED, 1),  # see Issue #2006\n}\nTAGS_V2_GROUPS = {\n    # ExifIFD\n    34665: {\n        36864: (\"ExifVersion\", UNDEFINED, 1),\n        40960: (\"FlashPixVersion\", UNDEFINED, 1),\n        40965: (\"InteroperabilityIFD\", LONG, 1),\n        41730: (\"CFAPattern\", UNDEFINED, 1),\n    },\n    # GPSInfoIFD\n    34853: {\n        0: (\"GPSVersionID\", BYTE, 4),\n        1: (\"GPSLatitudeRef\", ASCII, 2),\n        2: (\"GPSLatitude\", RATIONAL, 3),\n        3: (\"GPSLongitudeRef\", ASCII, 2),\n        4: (\"GPSLongitude\", RATIONAL, 3),\n        5: (\"GPSAltitudeRef\", BYTE, 1),\n        6: (\"GPSAltitude\", RATIONAL, 1),\n        7: (\"GPSTimeStamp\", RATIONAL, 3),\n        8: (\"GPSSatellites\", ASCII, 0),\n        9: (\"GPSStatus\", ASCII, 2),\n        10: (\"GPSMeasureMode\", ASCII, 2),\n        11: (\"GPSDOP\", RATIONAL, 1),\n        12: (\"GPSSpeedRef\", ASCII, 2),\n        13: (\"GPSSpeed\", RATIONAL, 1),\n        14: (\"GPSTrackRef\", ASCII, 2),\n        15: (\"GPSTrack\", RATIONAL, 1),\n        16: (\"GPSImgDirectionRef\", ASCII, 2),\n        17: (\"GPSImgDirection\", RATIONAL, 1),\n        18: (\"GPSMapDatum\", ASCII, 0),\n        19: (\"GPSDestLatitudeRef\", ASCII, 2),\n        20: (\"GPSDestLatitude\", RATIONAL, 3),\n        21: (\"GPSDestLongitudeRef\", ASCII, 2),\n        22: (\"GPSDestLongitude\", RATIONAL, 3),\n        23: (\"GPSDestBearingRef\", ASCII, 2),\n        24: (\"GPSDestBearing\", RATIONAL, 1),\n        25: (\"GPSDestDistanceRef\", ASCII, 2),\n        26: (\"GPSDestDistance\", RATIONAL, 1),\n        27: (\"GPSProcessingMethod\", UNDEFINED, 0),\n        28: (\"GPSAreaInformation\", UNDEFINED, 0),\n        29: (\"GPSDateStamp\", ASCII, 11),\n        30: (\"GPSDifferential\", SHORT, 1),\n    },\n    # InteroperabilityIFD\n    40965: {1: (\"InteropIndex\", ASCII, 1), 2: (\"InteropVersion\", UNDEFINED, 1)},\n}\n\n# Legacy Tags structure\n# these tags aren't included above, but were in the previous versions\nTAGS = {\n    347: \"JPEGTables\",\n    700: \"XMP\",\n    # Additional Exif Info\n    32932: \"Wang Annotation\",\n    33434: \"ExposureTime\",\n    33437: \"FNumber\",\n    33445: \"MD FileTag\",\n    33446: \"MD ScalePixel\",\n    33447: \"MD ColorTable\",\n    33448: \"MD LabName\",\n    33449: \"MD SampleInfo\",\n    33450: \"MD PrepDate\",\n    33451: \"MD PrepTime\",\n    33452: \"MD FileUnits\",\n    33550: \"ModelPixelScaleTag\",\n    33723: \"IptcNaaInfo\",\n    33918: \"INGR Packet Data Tag\",\n    33919: \"INGR Flag Registers\",\n    33920: \"IrasB Transformation Matrix\",\n    33922: \"ModelTiepointTag\",\n    34264: \"ModelTransformationTag\",\n    34377: \"PhotoshopInfo\",\n    34735: \"GeoKeyDirectoryTag\",\n    34736: \"GeoDoubleParamsTag\",\n    34737: \"GeoAsciiParamsTag\",\n    34850: \"ExposureProgram\",\n    34852: \"SpectralSensitivity\",\n    34855: \"ISOSpeedRatings\",\n    34856: \"OECF\",\n    34864: \"SensitivityType\",\n    34865: \"StandardOutputSensitivity\",\n    34866: \"RecommendedExposureIndex\",\n    34867: \"ISOSpeed\",\n    34868: \"ISOSpeedLatitudeyyy\",\n    34869: \"ISOSpeedLatitudezzz\",\n    34908: \"HylaFAX FaxRecvParams\",\n    34909: \"HylaFAX FaxSubAddress\",\n    34910: \"HylaFAX FaxRecvTime\",\n    36864: \"ExifVersion\",\n    36867: \"DateTimeOriginal\",\n    36868: \"DateTimeDigitized\",\n    37121: \"ComponentsConfiguration\",\n    37122: \"CompressedBitsPerPixel\",\n    37724: \"ImageSourceData\",\n    37377: \"ShutterSpeedValue\",\n    37378: \"ApertureValue\",\n    37379: \"BrightnessValue\",\n    37380: \"ExposureBiasValue\",\n    37381: \"MaxApertureValue\",\n    37382: \"SubjectDistance\",\n    37383: \"MeteringMode\",\n    37384: \"LightSource\",\n    37385: \"Flash\",\n    37386: \"FocalLength\",\n    37396: \"SubjectArea\",\n    37500: \"MakerNote\",\n    37510: \"UserComment\",\n    37520: \"SubSec\",\n    37521: \"SubSecTimeOriginal\",\n    37522: \"SubsecTimeDigitized\",\n    40960: \"FlashPixVersion\",\n    40961: \"ColorSpace\",\n    40962: \"PixelXDimension\",\n    40963: \"PixelYDimension\",\n    40964: \"RelatedSoundFile\",\n    40965: \"InteroperabilityIFD\",\n    41483: \"FlashEnergy\",\n    41484: \"SpatialFrequencyResponse\",\n    41486: \"FocalPlaneXResolution\",\n    41487: \"FocalPlaneYResolution\",\n    41488: \"FocalPlaneResolutionUnit\",\n    41492: \"SubjectLocation\",\n    41493: \"ExposureIndex\",\n    41495: \"SensingMethod\",\n    41728: \"FileSource\",\n    41729: \"SceneType\",\n    41730: \"CFAPattern\",\n    41985: \"CustomRendered\",\n    41986: \"ExposureMode\",\n    41987: \"WhiteBalance\",\n    41988: \"DigitalZoomRatio\",\n    41989: \"FocalLengthIn35mmFilm\",\n    41990: \"SceneCaptureType\",\n    41991: \"GainControl\",\n    41992: \"Contrast\",\n    41993: \"Saturation\",\n    41994: \"Sharpness\",\n    41995: \"DeviceSettingDescription\",\n    41996: \"SubjectDistanceRange\",\n    42016: \"ImageUniqueID\",\n    42032: \"CameraOwnerName\",\n    42033: \"BodySerialNumber\",\n    42034: \"LensSpecification\",\n    42035: \"LensMake\",\n    42036: \"LensModel\",\n    42037: \"LensSerialNumber\",\n    42112: \"GDAL_METADATA\",\n    42113: \"GDAL_NODATA\",\n    42240: \"Gamma\",\n    50215: \"Oce Scanjob Description\",\n    50216: \"Oce Application Selector\",\n    50217: \"Oce Identification Number\",\n    50218: \"Oce ImageLogic Characteristics\",\n    # Adobe DNG\n    50706: \"DNGVersion\",\n    50707: \"DNGBackwardVersion\",\n    50708: \"UniqueCameraModel\",\n    50709: \"LocalizedCameraModel\",\n    50710: \"CFAPlaneColor\",\n    50711: \"CFALayout\",\n    50712: \"LinearizationTable\",\n    50713: \"BlackLevelRepeatDim\",\n    50714: \"BlackLevel\",\n    50715: \"BlackLevelDeltaH\",\n    50716: \"BlackLevelDeltaV\",\n    50717: \"WhiteLevel\",\n    50718: \"DefaultScale\",\n    50719: \"DefaultCropOrigin\",\n    50720: \"DefaultCropSize\",\n    50721: \"ColorMatrix1\",\n    50722: \"ColorMatrix2\",\n    50723: \"CameraCalibration1\",\n    50724: \"CameraCalibration2\",\n    50725: \"ReductionMatrix1\",\n    50726: \"ReductionMatrix2\",\n    50727: \"AnalogBalance\",\n    50728: \"AsShotNeutral\",\n    50729: \"AsShotWhiteXY\",\n    50730: \"BaselineExposure\",\n    50731: \"BaselineNoise\",\n    50732: \"BaselineSharpness\",\n    50733: \"BayerGreenSplit\",\n    50734: \"LinearResponseLimit\",\n    50735: \"CameraSerialNumber\",\n    50736: \"LensInfo\",\n    50737: \"ChromaBlurRadius\",\n    50738: \"AntiAliasStrength\",\n    50740: \"DNGPrivateData\",\n    50778: \"CalibrationIlluminant1\",\n    50779: \"CalibrationIlluminant2\",\n    50784: \"Alias Layer Metadata\",\n}\n\nTAGS_V2: dict[int, TagInfo] = {}\n\n\ndef _populate():\n    for k, v in _tags_v2.items():\n        # Populate legacy structure.\n        TAGS[k] = v[0]\n        if len(v) == 4:\n            for sk, sv in v[3].items():\n                TAGS[(k, sv)] = sk\n\n        TAGS_V2[k] = TagInfo(k, *v)\n\n    for tags in TAGS_V2_GROUPS.values():\n        for k, v in tags.items():\n            tags[k] = TagInfo(k, *v)\n\n\n_populate()\n##\n# Map type numbers to type names -- defined in ImageFileDirectory.\n\nTYPES: dict[int, str] = {}\n\n#\n# These tags are handled by default in libtiff, without\n# adding to the custom dictionary. From tif_dir.c, searching for\n# case TIFFTAG in the _TIFFVSetField function:\n# Line: item.\n# 148: case TIFFTAG_SUBFILETYPE:\n# 151: case TIFFTAG_IMAGEWIDTH:\n# 154: case TIFFTAG_IMAGELENGTH:\n# 157: case TIFFTAG_BITSPERSAMPLE:\n# 181: case TIFFTAG_COMPRESSION:\n# 202: case TIFFTAG_PHOTOMETRIC:\n# 205: case TIFFTAG_THRESHHOLDING:\n# 208: case TIFFTAG_FILLORDER:\n# 214: case TIFFTAG_ORIENTATION:\n# 221: case TIFFTAG_SAMPLESPERPIXEL:\n# 228: case TIFFTAG_ROWSPERSTRIP:\n# 238: case TIFFTAG_MINSAMPLEVALUE:\n# 241: case TIFFTAG_MAXSAMPLEVALUE:\n# 244: case TIFFTAG_SMINSAMPLEVALUE:\n# 247: case TIFFTAG_SMAXSAMPLEVALUE:\n# 250: case TIFFTAG_XRESOLUTION:\n# 256: case TIFFTAG_YRESOLUTION:\n# 262: case TIFFTAG_PLANARCONFIG:\n# 268: case TIFFTAG_XPOSITION:\n# 271: case TIFFTAG_YPOSITION:\n# 274: case TIFFTAG_RESOLUTIONUNIT:\n# 280: case TIFFTAG_PAGENUMBER:\n# 284: case TIFFTAG_HALFTONEHINTS:\n# 288: case TIFFTAG_COLORMAP:\n# 294: case TIFFTAG_EXTRASAMPLES:\n# 298: case TIFFTAG_MATTEING:\n# 305: case TIFFTAG_TILEWIDTH:\n# 316: case TIFFTAG_TILELENGTH:\n# 327: case TIFFTAG_TILEDEPTH:\n# 333: case TIFFTAG_DATATYPE:\n# 344: case TIFFTAG_SAMPLEFORMAT:\n# 361: case TIFFTAG_IMAGEDEPTH:\n# 364: case TIFFTAG_SUBIFD:\n# 376: case TIFFTAG_YCBCRPOSITIONING:\n# 379: case TIFFTAG_YCBCRSUBSAMPLING:\n# 383: case TIFFTAG_TRANSFERFUNCTION:\n# 389: case TIFFTAG_REFERENCEBLACKWHITE:\n# 393: case TIFFTAG_INKNAMES:\n\n# Following pseudo-tags are also handled by default in libtiff:\n# TIFFTAG_JPEGQUALITY 65537\n\n# some of these are not in our TAGS_V2 dict and were included from tiff.h\n\n# This list also exists in encode.c\nLIBTIFF_CORE = {\n    255,\n    256,\n    257,\n    258,\n    259,\n    262,\n    263,\n    266,\n    274,\n    277,\n    278,\n    280,\n    281,\n    340,\n    341,\n    282,\n    283,\n    284,\n    286,\n    287,\n    296,\n    297,\n    321,\n    320,\n    338,\n    32995,\n    322,\n    323,\n    32998,\n    32996,\n    339,\n    32997,\n    330,\n    531,\n    530,\n    301,\n    532,\n    333,\n    # as above\n    269,  # this has been in our tests forever, and works\n    65537,\n}\n\nLIBTIFF_CORE.remove(255)  # We don't have support for subfiletypes\nLIBTIFF_CORE.remove(322)  # We don't have support for writing tiled images with libtiff\nLIBTIFF_CORE.remove(323)  # Tiled images\nLIBTIFF_CORE.remove(333)  # Ink Names either\n\n# Note to advanced users: There may be combinations of these\n# parameters and values that when added properly, will work and\n# produce valid tiff images that may work in your application.\n# It is safe to add and remove tags from this set from Pillow's point\n# of view so long as you test against libtiff.\n", "src/PIL/ImageOps.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard image operations\n#\n# History:\n# 2001-10-20 fl   Created\n# 2001-10-23 fl   Added autocontrast operator\n# 2001-12-18 fl   Added Kevin's fit operator\n# 2004-03-14 fl   Fixed potential division by zero in equalize\n# 2005-05-05 fl   Fixed equalize for low number of values\n#\n# Copyright (c) 2001-2004 by Secret Labs AB\n# Copyright (c) 2001-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport functools\nimport operator\nimport re\nfrom typing import Protocol, Sequence, cast\n\nfrom . import ExifTags, Image, ImagePalette\n\n#\n# helpers\n\n\ndef _border(border: int | tuple[int, ...]) -> tuple[int, int, int, int]:\n    if isinstance(border, tuple):\n        if len(border) == 2:\n            left, top = right, bottom = border\n        elif len(border) == 4:\n            left, top, right, bottom = border\n    else:\n        left = top = right = bottom = border\n    return left, top, right, bottom\n\n\ndef _color(color: str | int | tuple[int, ...], mode: str) -> int | tuple[int, ...]:\n    if isinstance(color, str):\n        from . import ImageColor\n\n        color = ImageColor.getcolor(color, mode)\n    return color\n\n\ndef _lut(image: Image.Image, lut: list[int]) -> Image.Image:\n    if image.mode == \"P\":\n        # FIXME: apply to lookup table, not image data\n        msg = \"mode P support coming soon\"\n        raise NotImplementedError(msg)\n    elif image.mode in (\"L\", \"RGB\"):\n        if image.mode == \"RGB\" and len(lut) == 256:\n            lut = lut + lut + lut\n        return image.point(lut)\n    else:\n        msg = f\"not supported for mode {image.mode}\"\n        raise OSError(msg)\n\n\n#\n# actions\n\n\ndef autocontrast(\n    image: Image.Image,\n    cutoff: float | tuple[float, float] = 0,\n    ignore: int | Sequence[int] | None = None,\n    mask: Image.Image | None = None,\n    preserve_tone: bool = False,\n) -> Image.Image:\n    \"\"\"\n    Maximize (normalize) image contrast. This function calculates a\n    histogram of the input image (or mask region), removes ``cutoff`` percent of the\n    lightest and darkest pixels from the histogram, and remaps the image\n    so that the darkest pixel becomes black (0), and the lightest\n    becomes white (255).\n\n    :param image: The image to process.\n    :param cutoff: The percent to cut off from the histogram on the low and\n                   high ends. Either a tuple of (low, high), or a single\n                   number for both.\n    :param ignore: The background pixel value (use None for no background).\n    :param mask: Histogram used in contrast operation is computed using pixels\n                 within the mask. If no mask is given the entire image is used\n                 for histogram computation.\n    :param preserve_tone: Preserve image tone in Photoshop-like style autocontrast.\n\n                          .. versionadded:: 8.2.0\n\n    :return: An image.\n    \"\"\"\n    if preserve_tone:\n        histogram = image.convert(\"L\").histogram(mask)\n    else:\n        histogram = image.histogram(mask)\n\n    lut = []\n    for layer in range(0, len(histogram), 256):\n        h = histogram[layer : layer + 256]\n        if ignore is not None:\n            # get rid of outliers\n            if isinstance(ignore, int):\n                h[ignore] = 0\n            else:\n                for ix in ignore:\n                    h[ix] = 0\n        if cutoff:\n            # cut off pixels from both ends of the histogram\n            if not isinstance(cutoff, tuple):\n                cutoff = (cutoff, cutoff)\n            # get number of pixels\n            n = 0\n            for ix in range(256):\n                n = n + h[ix]\n            # remove cutoff% pixels from the low end\n            cut = int(n * cutoff[0] // 100)\n            for lo in range(256):\n                if cut > h[lo]:\n                    cut = cut - h[lo]\n                    h[lo] = 0\n                else:\n                    h[lo] -= cut\n                    cut = 0\n                if cut <= 0:\n                    break\n            # remove cutoff% samples from the high end\n            cut = int(n * cutoff[1] // 100)\n            for hi in range(255, -1, -1):\n                if cut > h[hi]:\n                    cut = cut - h[hi]\n                    h[hi] = 0\n                else:\n                    h[hi] -= cut\n                    cut = 0\n                if cut <= 0:\n                    break\n        # find lowest/highest samples after preprocessing\n        for lo in range(256):\n            if h[lo]:\n                break\n        for hi in range(255, -1, -1):\n            if h[hi]:\n                break\n        if hi <= lo:\n            # don't bother\n            lut.extend(list(range(256)))\n        else:\n            scale = 255.0 / (hi - lo)\n            offset = -lo * scale\n            for ix in range(256):\n                ix = int(ix * scale + offset)\n                if ix < 0:\n                    ix = 0\n                elif ix > 255:\n                    ix = 255\n                lut.append(ix)\n    return _lut(image, lut)\n\n\ndef colorize(\n    image: Image.Image,\n    black: str | tuple[int, ...],\n    white: str | tuple[int, ...],\n    mid: str | int | tuple[int, ...] | None = None,\n    blackpoint: int = 0,\n    whitepoint: int = 255,\n    midpoint: int = 127,\n) -> Image.Image:\n    \"\"\"\n    Colorize grayscale image.\n    This function calculates a color wedge which maps all black pixels in\n    the source image to the first color and all white pixels to the\n    second color. If ``mid`` is specified, it uses three-color mapping.\n    The ``black`` and ``white`` arguments should be RGB tuples or color names;\n    optionally you can use three-color mapping by also specifying ``mid``.\n    Mapping positions for any of the colors can be specified\n    (e.g. ``blackpoint``), where these parameters are the integer\n    value corresponding to where the corresponding color should be mapped.\n    These parameters must have logical order, such that\n    ``blackpoint <= midpoint <= whitepoint`` (if ``mid`` is specified).\n\n    :param image: The image to colorize.\n    :param black: The color to use for black input pixels.\n    :param white: The color to use for white input pixels.\n    :param mid: The color to use for midtone input pixels.\n    :param blackpoint: an int value [0, 255] for the black mapping.\n    :param whitepoint: an int value [0, 255] for the white mapping.\n    :param midpoint: an int value [0, 255] for the midtone mapping.\n    :return: An image.\n    \"\"\"\n\n    # Initial asserts\n    assert image.mode == \"L\"\n    if mid is None:\n        assert 0 <= blackpoint <= whitepoint <= 255\n    else:\n        assert 0 <= blackpoint <= midpoint <= whitepoint <= 255\n\n    # Define colors from arguments\n    rgb_black = cast(Sequence[int], _color(black, \"RGB\"))\n    rgb_white = cast(Sequence[int], _color(white, \"RGB\"))\n    rgb_mid = cast(Sequence[int], _color(mid, \"RGB\")) if mid is not None else None\n\n    # Empty lists for the mapping\n    red = []\n    green = []\n    blue = []\n\n    # Create the low-end values\n    for i in range(0, blackpoint):\n        red.append(rgb_black[0])\n        green.append(rgb_black[1])\n        blue.append(rgb_black[2])\n\n    # Create the mapping (2-color)\n    if rgb_mid is None:\n        range_map = range(0, whitepoint - blackpoint)\n\n        for i in range_map:\n            red.append(\n                rgb_black[0] + i * (rgb_white[0] - rgb_black[0]) // len(range_map)\n            )\n            green.append(\n                rgb_black[1] + i * (rgb_white[1] - rgb_black[1]) // len(range_map)\n            )\n            blue.append(\n                rgb_black[2] + i * (rgb_white[2] - rgb_black[2]) // len(range_map)\n            )\n\n    # Create the mapping (3-color)\n    else:\n        range_map1 = range(0, midpoint - blackpoint)\n        range_map2 = range(0, whitepoint - midpoint)\n\n        for i in range_map1:\n            red.append(\n                rgb_black[0] + i * (rgb_mid[0] - rgb_black[0]) // len(range_map1)\n            )\n            green.append(\n                rgb_black[1] + i * (rgb_mid[1] - rgb_black[1]) // len(range_map1)\n            )\n            blue.append(\n                rgb_black[2] + i * (rgb_mid[2] - rgb_black[2]) // len(range_map1)\n            )\n        for i in range_map2:\n            red.append(rgb_mid[0] + i * (rgb_white[0] - rgb_mid[0]) // len(range_map2))\n            green.append(\n                rgb_mid[1] + i * (rgb_white[1] - rgb_mid[1]) // len(range_map2)\n            )\n            blue.append(rgb_mid[2] + i * (rgb_white[2] - rgb_mid[2]) // len(range_map2))\n\n    # Create the high-end values\n    for i in range(0, 256 - whitepoint):\n        red.append(rgb_white[0])\n        green.append(rgb_white[1])\n        blue.append(rgb_white[2])\n\n    # Return converted image\n    image = image.convert(\"RGB\")\n    return _lut(image, red + green + blue)\n\n\ndef contain(\n    image: Image.Image, size: tuple[int, int], method: int = Image.Resampling.BICUBIC\n) -> Image.Image:\n    \"\"\"\n    Returns a resized version of the image, set to the maximum width and height\n    within the requested size, while maintaining the original aspect ratio.\n\n    :param image: The image to resize.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :return: An image.\n    \"\"\"\n\n    im_ratio = image.width / image.height\n    dest_ratio = size[0] / size[1]\n\n    if im_ratio != dest_ratio:\n        if im_ratio > dest_ratio:\n            new_height = round(image.height / image.width * size[0])\n            if new_height != size[1]:\n                size = (size[0], new_height)\n        else:\n            new_width = round(image.width / image.height * size[1])\n            if new_width != size[0]:\n                size = (new_width, size[1])\n    return image.resize(size, resample=method)\n\n\ndef cover(\n    image: Image.Image, size: tuple[int, int], method: int = Image.Resampling.BICUBIC\n) -> Image.Image:\n    \"\"\"\n    Returns a resized version of the image, so that the requested size is\n    covered, while maintaining the original aspect ratio.\n\n    :param image: The image to resize.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :return: An image.\n    \"\"\"\n\n    im_ratio = image.width / image.height\n    dest_ratio = size[0] / size[1]\n\n    if im_ratio != dest_ratio:\n        if im_ratio < dest_ratio:\n            new_height = round(image.height / image.width * size[0])\n            if new_height != size[1]:\n                size = (size[0], new_height)\n        else:\n            new_width = round(image.width / image.height * size[1])\n            if new_width != size[0]:\n                size = (new_width, size[1])\n    return image.resize(size, resample=method)\n\n\ndef pad(\n    image: Image.Image,\n    size: tuple[int, int],\n    method: int = Image.Resampling.BICUBIC,\n    color: str | int | tuple[int, ...] | None = None,\n    centering: tuple[float, float] = (0.5, 0.5),\n) -> Image.Image:\n    \"\"\"\n    Returns a resized and padded version of the image, expanded to fill the\n    requested aspect ratio and size.\n\n    :param image: The image to resize and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :param color: The background color of the padded image.\n    :param centering: Control the position of the original image within the\n                      padded version.\n\n                          (0.5, 0.5) will keep the image centered\n                          (0, 0) will keep the image aligned to the top left\n                          (1, 1) will keep the image aligned to the bottom\n                          right\n    :return: An image.\n    \"\"\"\n\n    resized = contain(image, size, method)\n    if resized.size == size:\n        out = resized\n    else:\n        out = Image.new(image.mode, size, color)\n        if resized.palette:\n            out.putpalette(resized.getpalette())\n        if resized.width != size[0]:\n            x = round((size[0] - resized.width) * max(0, min(centering[0], 1)))\n            out.paste(resized, (x, 0))\n        else:\n            y = round((size[1] - resized.height) * max(0, min(centering[1], 1)))\n            out.paste(resized, (0, y))\n    return out\n\n\ndef crop(image: Image.Image, border: int = 0) -> Image.Image:\n    \"\"\"\n    Remove border from image.  The same amount of pixels are removed\n    from all four sides.  This function works on all image modes.\n\n    .. seealso:: :py:meth:`~PIL.Image.Image.crop`\n\n    :param image: The image to crop.\n    :param border: The number of pixels to remove.\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)\n    return image.crop((left, top, image.size[0] - right, image.size[1] - bottom))\n\n\ndef scale(\n    image: Image.Image, factor: float, resample: int = Image.Resampling.BICUBIC\n) -> Image.Image:\n    \"\"\"\n    Returns a rescaled image by a specific factor given in parameter.\n    A factor greater than 1 expands the image, between 0 and 1 contracts the\n    image.\n\n    :param image: The image to rescale.\n    :param factor: The expansion factor, as a float.\n    :param resample: Resampling method to use. Default is\n                     :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                     See :ref:`concept-filters`.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n    if factor == 1:\n        return image.copy()\n    elif factor <= 0:\n        msg = \"the factor must be greater than 0\"\n        raise ValueError(msg)\n    else:\n        size = (round(factor * image.width), round(factor * image.height))\n        return image.resize(size, resample)\n\n\nclass SupportsGetMesh(Protocol):\n    \"\"\"\n    An object that supports the ``getmesh`` method, taking an image as an\n    argument, and returning a list of tuples. Each tuple contains two tuples,\n    the source box as a tuple of 4 integers, and a tuple of 8 integers for the\n    final quadrilateral, in order of top left, bottom left, bottom right, top\n    right.\n    \"\"\"\n\n    def getmesh(\n        self, image: Image.Image\n    ) -> list[\n        tuple[tuple[int, int, int, int], tuple[int, int, int, int, int, int, int, int]]\n    ]: ...\n\n\ndef deform(\n    image: Image.Image,\n    deformer: SupportsGetMesh,\n    resample: int = Image.Resampling.BILINEAR,\n) -> Image.Image:\n    \"\"\"\n    Deform the image.\n\n    :param image: The image to deform.\n    :param deformer: A deformer object.  Any object that implements a\n                    ``getmesh`` method can be used.\n    :param resample: An optional resampling filter. Same values possible as\n       in the PIL.Image.transform function.\n    :return: An image.\n    \"\"\"\n    return image.transform(\n        image.size, Image.Transform.MESH, deformer.getmesh(image), resample\n    )\n\n\ndef equalize(image: Image.Image, mask: Image.Image | None = None) -> Image.Image:\n    \"\"\"\n    Equalize the image histogram. This function applies a non-linear\n    mapping to the input image, in order to create a uniform\n    distribution of grayscale values in the output image.\n\n    :param image: The image to equalize.\n    :param mask: An optional mask.  If given, only the pixels selected by\n                 the mask are included in the analysis.\n    :return: An image.\n    \"\"\"\n    if image.mode == \"P\":\n        image = image.convert(\"RGB\")\n    h = image.histogram(mask)\n    lut = []\n    for b in range(0, len(h), 256):\n        histo = [_f for _f in h[b : b + 256] if _f]\n        if len(histo) <= 1:\n            lut.extend(list(range(256)))\n        else:\n            step = (functools.reduce(operator.add, histo) - histo[-1]) // 255\n            if not step:\n                lut.extend(list(range(256)))\n            else:\n                n = step // 2\n                for i in range(256):\n                    lut.append(n // step)\n                    n = n + h[i + b]\n    return _lut(image, lut)\n\n\ndef expand(\n    image: Image.Image,\n    border: int | tuple[int, ...] = 0,\n    fill: str | int | tuple[int, ...] = 0,\n) -> Image.Image:\n    \"\"\"\n    Add border to the image\n\n    :param image: The image to expand.\n    :param border: Border width, in pixels.\n    :param fill: Pixel fill value (a color value).  Default is 0 (black).\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)\n    width = left + image.size[0] + right\n    height = top + image.size[1] + bottom\n    color = _color(fill, image.mode)\n    if image.palette:\n        palette = ImagePalette.ImagePalette(palette=image.getpalette())\n        if isinstance(color, tuple) and (len(color) == 3 or len(color) == 4):\n            color = palette.getcolor(color)\n    else:\n        palette = None\n    out = Image.new(image.mode, (width, height), color)\n    if palette:\n        out.putpalette(palette.palette)\n    out.paste(image, (left, top))\n    return out\n\n\ndef fit(\n    image: Image.Image,\n    size: tuple[int, int],\n    method: int = Image.Resampling.BICUBIC,\n    bleed: float = 0.0,\n    centering: tuple[float, float] = (0.5, 0.5),\n) -> Image.Image:\n    \"\"\"\n    Returns a resized and cropped version of the image, cropped to the\n    requested aspect ratio and size.\n\n    This function was contributed by Kevin Cazabon.\n\n    :param image: The image to resize and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :param bleed: Remove a border around the outside of the image from all\n                  four edges. The value is a decimal percentage (use 0.01 for\n                  one percent). The default value is 0 (no border).\n                  Cannot be greater than or equal to 0.5.\n    :param centering: Control the cropping position.  Use (0.5, 0.5) for\n                      center cropping (e.g. if cropping the width, take 50% off\n                      of the left side, and therefore 50% off the right side).\n                      (0.0, 0.0) will crop from the top left corner (i.e. if\n                      cropping the width, take all of the crop off of the right\n                      side, and if cropping the height, take all of it off the\n                      bottom).  (1.0, 0.0) will crop from the bottom left\n                      corner, etc. (i.e. if cropping the width, take all of the\n                      crop off the left side, and if cropping the height take\n                      none from the top, and therefore all off the bottom).\n    :return: An image.\n    \"\"\"\n\n    # by Kevin Cazabon, Feb 17/2000\n    # kevin@cazabon.com\n    # https://www.cazabon.com\n\n    centering_x, centering_y = centering\n\n    if not 0.0 <= centering_x <= 1.0:\n        centering_x = 0.5\n    if not 0.0 <= centering_y <= 1.0:\n        centering_y = 0.5\n\n    if not 0.0 <= bleed < 0.5:\n        bleed = 0.0\n\n    # calculate the area to use for resizing and cropping, subtracting\n    # the 'bleed' around the edges\n\n    # number of pixels to trim off on Top and Bottom, Left and Right\n    bleed_pixels = (bleed * image.size[0], bleed * image.size[1])\n\n    live_size = (\n        image.size[0] - bleed_pixels[0] * 2,\n        image.size[1] - bleed_pixels[1] * 2,\n    )\n\n    # calculate the aspect ratio of the live_size\n    live_size_ratio = live_size[0] / live_size[1]\n\n    # calculate the aspect ratio of the output image\n    output_ratio = size[0] / size[1]\n\n    # figure out if the sides or top/bottom will be cropped off\n    if live_size_ratio == output_ratio:\n        # live_size is already the needed ratio\n        crop_width = live_size[0]\n        crop_height = live_size[1]\n    elif live_size_ratio >= output_ratio:\n        # live_size is wider than what's needed, crop the sides\n        crop_width = output_ratio * live_size[1]\n        crop_height = live_size[1]\n    else:\n        # live_size is taller than what's needed, crop the top and bottom\n        crop_width = live_size[0]\n        crop_height = live_size[0] / output_ratio\n\n    # make the crop\n    crop_left = bleed_pixels[0] + (live_size[0] - crop_width) * centering_x\n    crop_top = bleed_pixels[1] + (live_size[1] - crop_height) * centering_y\n\n    crop = (crop_left, crop_top, crop_left + crop_width, crop_top + crop_height)\n\n    # resize the image and return it\n    return image.resize(size, method, box=crop)\n\n\ndef flip(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Flip the image vertically (top to bottom).\n\n    :param image: The image to flip.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.Transpose.FLIP_TOP_BOTTOM)\n\n\ndef grayscale(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Convert the image to grayscale.\n\n    :param image: The image to convert.\n    :return: An image.\n    \"\"\"\n    return image.convert(\"L\")\n\n\ndef invert(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Invert (negate) the image.\n\n    :param image: The image to invert.\n    :return: An image.\n    \"\"\"\n    lut = list(range(255, -1, -1))\n    return image.point(lut) if image.mode == \"1\" else _lut(image, lut)\n\n\ndef mirror(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Flip image horizontally (left to right).\n\n    :param image: The image to mirror.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.Transpose.FLIP_LEFT_RIGHT)\n\n\ndef posterize(image: Image.Image, bits: int) -> Image.Image:\n    \"\"\"\n    Reduce the number of bits for each color channel.\n\n    :param image: The image to posterize.\n    :param bits: The number of bits to keep for each channel (1-8).\n    :return: An image.\n    \"\"\"\n    mask = ~(2 ** (8 - bits) - 1)\n    lut = [i & mask for i in range(256)]\n    return _lut(image, lut)\n\n\ndef solarize(image: Image.Image, threshold: int = 128) -> Image.Image:\n    \"\"\"\n    Invert all pixel values above a threshold.\n\n    :param image: The image to solarize.\n    :param threshold: All pixels above this grayscale level are inverted.\n    :return: An image.\n    \"\"\"\n    lut = []\n    for i in range(256):\n        if i < threshold:\n            lut.append(i)\n        else:\n            lut.append(255 - i)\n    return _lut(image, lut)\n\n\ndef exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image | None:\n    \"\"\"\n    If an image has an EXIF Orientation tag, other than 1, transpose the image\n    accordingly, and remove the orientation data.\n\n    :param image: The image to transpose.\n    :param in_place: Boolean. Keyword-only argument.\n        If ``True``, the original image is modified in-place, and ``None`` is returned.\n        If ``False`` (default), a new :py:class:`~PIL.Image.Image` object is returned\n        with the transposition applied. If there is no transposition, a copy of the\n        image will be returned.\n    \"\"\"\n    image.load()\n    image_exif = image.getexif()\n    orientation = image_exif.get(ExifTags.Base.Orientation, 1)\n    method = {\n        2: Image.Transpose.FLIP_LEFT_RIGHT,\n        3: Image.Transpose.ROTATE_180,\n        4: Image.Transpose.FLIP_TOP_BOTTOM,\n        5: Image.Transpose.TRANSPOSE,\n        6: Image.Transpose.ROTATE_270,\n        7: Image.Transpose.TRANSVERSE,\n        8: Image.Transpose.ROTATE_90,\n    }.get(orientation)\n    if method is not None:\n        transposed_image = image.transpose(method)\n        if in_place:\n            image.im = transposed_image.im\n            image.pyaccess = None\n            image._size = transposed_image._size\n        exif_image = image if in_place else transposed_image\n\n        exif = exif_image.getexif()\n        if ExifTags.Base.Orientation in exif:\n            del exif[ExifTags.Base.Orientation]\n            if \"exif\" in exif_image.info:\n                exif_image.info[\"exif\"] = exif.tobytes()\n            elif \"Raw profile type exif\" in exif_image.info:\n                exif_image.info[\"Raw profile type exif\"] = exif.tobytes().hex()\n            elif \"XML:com.adobe.xmp\" in exif_image.info:\n                for pattern in (\n                    r'tiff:Orientation=\"([0-9])\"',\n                    r\"<tiff:Orientation>([0-9])</tiff:Orientation>\",\n                ):\n                    exif_image.info[\"XML:com.adobe.xmp\"] = re.sub(\n                        pattern, \"\", exif_image.info[\"XML:com.adobe.xmp\"]\n                    )\n                    exif_image.info[\"xmp\"] = re.sub(\n                        pattern.encode(), b\"\", exif_image.info[\"xmp\"]\n                    )\n        if not in_place:\n            return transposed_image\n    elif not in_place:\n        return image.copy()\n    return None\n", "src/PIL/__main__.py": "from __future__ import annotations\n\nimport sys\n\nfrom .features import pilinfo\n\npilinfo(supported_formats=\"--report\" not in sys.argv)\n", "src/PIL/_util.py": "from __future__ import annotations\n\nimport os\nfrom typing import Any, NoReturn\n\nfrom ._typing import StrOrBytesPath, TypeGuard\n\n\ndef is_path(f: Any) -> TypeGuard[StrOrBytesPath]:\n    return isinstance(f, (bytes, str, os.PathLike))\n\n\ndef is_directory(f: Any) -> TypeGuard[StrOrBytesPath]:\n    \"\"\"Checks if an object is a string, and that it points to a directory.\"\"\"\n    return is_path(f) and os.path.isdir(f)\n\n\nclass DeferredError:\n    def __init__(self, ex: BaseException):\n        self.ex = ex\n\n    def __getattr__(self, elt: str) -> NoReturn:\n        raise self.ex\n\n    @staticmethod\n    def new(ex: BaseException) -> Any:\n        \"\"\"\n        Creates an object that raises the wrapped exception ``ex`` when used,\n        and casts it to :py:obj:`~typing.Any` type.\n        \"\"\"\n        return DeferredError(ex)\n", "src/PIL/ImageColor.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# map CSS3-style colour description strings to RGB\n#\n# History:\n# 2002-10-24 fl   Added support for CSS-style color strings\n# 2002-12-15 fl   Added RGBA support\n# 2004-03-27 fl   Fixed remaining int() problems for Python 1.5.2\n# 2004-07-19 fl   Fixed gray/grey spelling issues\n# 2009-03-05 fl   Fixed rounding error in grayscale calculation\n#\n# Copyright (c) 2002-2004 by Secret Labs AB\n# Copyright (c) 2002-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\nfrom functools import lru_cache\n\nfrom . import Image\n\n\n@lru_cache\ndef getrgb(color: str) -> tuple[int, int, int] | tuple[int, int, int, int]:\n    \"\"\"\n     Convert a color string to an RGB or RGBA tuple. If the string cannot be\n     parsed, this function raises a :py:exc:`ValueError` exception.\n\n    .. versionadded:: 1.1.4\n\n    :param color: A color string\n    :return: ``(red, green, blue[, alpha])``\n    \"\"\"\n    if len(color) > 100:\n        msg = \"color specifier is too long\"\n        raise ValueError(msg)\n    color = color.lower()\n\n    rgb = colormap.get(color, None)\n    if rgb:\n        if isinstance(rgb, tuple):\n            return rgb\n        rgb_tuple = getrgb(rgb)\n        assert len(rgb_tuple) == 3\n        colormap[color] = rgb_tuple\n        return rgb_tuple\n\n    # check for known string formats\n    if re.match(\"#[a-f0-9]{3}$\", color):\n        return int(color[1] * 2, 16), int(color[2] * 2, 16), int(color[3] * 2, 16)\n\n    if re.match(\"#[a-f0-9]{4}$\", color):\n        return (\n            int(color[1] * 2, 16),\n            int(color[2] * 2, 16),\n            int(color[3] * 2, 16),\n            int(color[4] * 2, 16),\n        )\n\n    if re.match(\"#[a-f0-9]{6}$\", color):\n        return int(color[1:3], 16), int(color[3:5], 16), int(color[5:7], 16)\n\n    if re.match(\"#[a-f0-9]{8}$\", color):\n        return (\n            int(color[1:3], 16),\n            int(color[3:5], 16),\n            int(color[5:7], 16),\n            int(color[7:9], 16),\n        )\n\n    m = re.match(r\"rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$\", color)\n    if m:\n        return int(m.group(1)), int(m.group(2)), int(m.group(3))\n\n    m = re.match(r\"rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)$\", color)\n    if m:\n        return (\n            int((int(m.group(1)) * 255) / 100.0 + 0.5),\n            int((int(m.group(2)) * 255) / 100.0 + 0.5),\n            int((int(m.group(3)) * 255) / 100.0 + 0.5),\n        )\n\n    m = re.match(\n        r\"hsl\\(\\s*(\\d+\\.?\\d*)\\s*,\\s*(\\d+\\.?\\d*)%\\s*,\\s*(\\d+\\.?\\d*)%\\s*\\)$\", color\n    )\n    if m:\n        from colorsys import hls_to_rgb\n\n        rgb_floats = hls_to_rgb(\n            float(m.group(1)) / 360.0,\n            float(m.group(3)) / 100.0,\n            float(m.group(2)) / 100.0,\n        )\n        return (\n            int(rgb_floats[0] * 255 + 0.5),\n            int(rgb_floats[1] * 255 + 0.5),\n            int(rgb_floats[2] * 255 + 0.5),\n        )\n\n    m = re.match(\n        r\"hs[bv]\\(\\s*(\\d+\\.?\\d*)\\s*,\\s*(\\d+\\.?\\d*)%\\s*,\\s*(\\d+\\.?\\d*)%\\s*\\)$\", color\n    )\n    if m:\n        from colorsys import hsv_to_rgb\n\n        rgb_floats = hsv_to_rgb(\n            float(m.group(1)) / 360.0,\n            float(m.group(2)) / 100.0,\n            float(m.group(3)) / 100.0,\n        )\n        return (\n            int(rgb_floats[0] * 255 + 0.5),\n            int(rgb_floats[1] * 255 + 0.5),\n            int(rgb_floats[2] * 255 + 0.5),\n        )\n\n    m = re.match(r\"rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$\", color)\n    if m:\n        return int(m.group(1)), int(m.group(2)), int(m.group(3)), int(m.group(4))\n    msg = f\"unknown color specifier: {repr(color)}\"\n    raise ValueError(msg)\n\n\n@lru_cache\ndef getcolor(color: str, mode: str) -> int | tuple[int, ...]:\n    \"\"\"\n    Same as :py:func:`~PIL.ImageColor.getrgb` for most modes. However, if\n    ``mode`` is HSV, converts the RGB value to a HSV value, or if ``mode`` is\n    not color or a palette image, converts the RGB value to a grayscale value.\n    If the string cannot be parsed, this function raises a :py:exc:`ValueError`\n    exception.\n\n    .. versionadded:: 1.1.4\n\n    :param color: A color string\n    :param mode: Convert result to this mode\n    :return: ``graylevel, (graylevel, alpha) or (red, green, blue[, alpha])``\n    \"\"\"\n    # same as getrgb, but converts the result to the given mode\n    rgb, alpha = getrgb(color), 255\n    if len(rgb) == 4:\n        alpha = rgb[3]\n        rgb = rgb[:3]\n\n    if mode == \"HSV\":\n        from colorsys import rgb_to_hsv\n\n        r, g, b = rgb\n        h, s, v = rgb_to_hsv(r / 255, g / 255, b / 255)\n        return int(h * 255), int(s * 255), int(v * 255)\n    elif Image.getmodebase(mode) == \"L\":\n        r, g, b = rgb\n        # ITU-R Recommendation 601-2 for nonlinear RGB\n        # scaled to 24 bits to match the convert's implementation.\n        graylevel = (r * 19595 + g * 38470 + b * 7471 + 0x8000) >> 16\n        if mode[-1] == \"A\":\n            return graylevel, alpha\n        return graylevel\n    elif mode[-1] == \"A\":\n        return rgb + (alpha,)\n    return rgb\n\n\ncolormap: dict[str, str | tuple[int, int, int]] = {\n    # X11 colour table from https://drafts.csswg.org/css-color-4/, with\n    # gray/grey spelling issues fixed.  This is a superset of HTML 4.0\n    # colour names used in CSS 1.\n    \"aliceblue\": \"#f0f8ff\",\n    \"antiquewhite\": \"#faebd7\",\n    \"aqua\": \"#00ffff\",\n    \"aquamarine\": \"#7fffd4\",\n    \"azure\": \"#f0ffff\",\n    \"beige\": \"#f5f5dc\",\n    \"bisque\": \"#ffe4c4\",\n    \"black\": \"#000000\",\n    \"blanchedalmond\": \"#ffebcd\",\n    \"blue\": \"#0000ff\",\n    \"blueviolet\": \"#8a2be2\",\n    \"brown\": \"#a52a2a\",\n    \"burlywood\": \"#deb887\",\n    \"cadetblue\": \"#5f9ea0\",\n    \"chartreuse\": \"#7fff00\",\n    \"chocolate\": \"#d2691e\",\n    \"coral\": \"#ff7f50\",\n    \"cornflowerblue\": \"#6495ed\",\n    \"cornsilk\": \"#fff8dc\",\n    \"crimson\": \"#dc143c\",\n    \"cyan\": \"#00ffff\",\n    \"darkblue\": \"#00008b\",\n    \"darkcyan\": \"#008b8b\",\n    \"darkgoldenrod\": \"#b8860b\",\n    \"darkgray\": \"#a9a9a9\",\n    \"darkgrey\": \"#a9a9a9\",\n    \"darkgreen\": \"#006400\",\n    \"darkkhaki\": \"#bdb76b\",\n    \"darkmagenta\": \"#8b008b\",\n    \"darkolivegreen\": \"#556b2f\",\n    \"darkorange\": \"#ff8c00\",\n    \"darkorchid\": \"#9932cc\",\n    \"darkred\": \"#8b0000\",\n    \"darksalmon\": \"#e9967a\",\n    \"darkseagreen\": \"#8fbc8f\",\n    \"darkslateblue\": \"#483d8b\",\n    \"darkslategray\": \"#2f4f4f\",\n    \"darkslategrey\": \"#2f4f4f\",\n    \"darkturquoise\": \"#00ced1\",\n    \"darkviolet\": \"#9400d3\",\n    \"deeppink\": \"#ff1493\",\n    \"deepskyblue\": \"#00bfff\",\n    \"dimgray\": \"#696969\",\n    \"dimgrey\": \"#696969\",\n    \"dodgerblue\": \"#1e90ff\",\n    \"firebrick\": \"#b22222\",\n    \"floralwhite\": \"#fffaf0\",\n    \"forestgreen\": \"#228b22\",\n    \"fuchsia\": \"#ff00ff\",\n    \"gainsboro\": \"#dcdcdc\",\n    \"ghostwhite\": \"#f8f8ff\",\n    \"gold\": \"#ffd700\",\n    \"goldenrod\": \"#daa520\",\n    \"gray\": \"#808080\",\n    \"grey\": \"#808080\",\n    \"green\": \"#008000\",\n    \"greenyellow\": \"#adff2f\",\n    \"honeydew\": \"#f0fff0\",\n    \"hotpink\": \"#ff69b4\",\n    \"indianred\": \"#cd5c5c\",\n    \"indigo\": \"#4b0082\",\n    \"ivory\": \"#fffff0\",\n    \"khaki\": \"#f0e68c\",\n    \"lavender\": \"#e6e6fa\",\n    \"lavenderblush\": \"#fff0f5\",\n    \"lawngreen\": \"#7cfc00\",\n    \"lemonchiffon\": \"#fffacd\",\n    \"lightblue\": \"#add8e6\",\n    \"lightcoral\": \"#f08080\",\n    \"lightcyan\": \"#e0ffff\",\n    \"lightgoldenrodyellow\": \"#fafad2\",\n    \"lightgreen\": \"#90ee90\",\n    \"lightgray\": \"#d3d3d3\",\n    \"lightgrey\": \"#d3d3d3\",\n    \"lightpink\": \"#ffb6c1\",\n    \"lightsalmon\": \"#ffa07a\",\n    \"lightseagreen\": \"#20b2aa\",\n    \"lightskyblue\": \"#87cefa\",\n    \"lightslategray\": \"#778899\",\n    \"lightslategrey\": \"#778899\",\n    \"lightsteelblue\": \"#b0c4de\",\n    \"lightyellow\": \"#ffffe0\",\n    \"lime\": \"#00ff00\",\n    \"limegreen\": \"#32cd32\",\n    \"linen\": \"#faf0e6\",\n    \"magenta\": \"#ff00ff\",\n    \"maroon\": \"#800000\",\n    \"mediumaquamarine\": \"#66cdaa\",\n    \"mediumblue\": \"#0000cd\",\n    \"mediumorchid\": \"#ba55d3\",\n    \"mediumpurple\": \"#9370db\",\n    \"mediumseagreen\": \"#3cb371\",\n    \"mediumslateblue\": \"#7b68ee\",\n    \"mediumspringgreen\": \"#00fa9a\",\n    \"mediumturquoise\": \"#48d1cc\",\n    \"mediumvioletred\": \"#c71585\",\n    \"midnightblue\": \"#191970\",\n    \"mintcream\": \"#f5fffa\",\n    \"mistyrose\": \"#ffe4e1\",\n    \"moccasin\": \"#ffe4b5\",\n    \"navajowhite\": \"#ffdead\",\n    \"navy\": \"#000080\",\n    \"oldlace\": \"#fdf5e6\",\n    \"olive\": \"#808000\",\n    \"olivedrab\": \"#6b8e23\",\n    \"orange\": \"#ffa500\",\n    \"orangered\": \"#ff4500\",\n    \"orchid\": \"#da70d6\",\n    \"palegoldenrod\": \"#eee8aa\",\n    \"palegreen\": \"#98fb98\",\n    \"paleturquoise\": \"#afeeee\",\n    \"palevioletred\": \"#db7093\",\n    \"papayawhip\": \"#ffefd5\",\n    \"peachpuff\": \"#ffdab9\",\n    \"peru\": \"#cd853f\",\n    \"pink\": \"#ffc0cb\",\n    \"plum\": \"#dda0dd\",\n    \"powderblue\": \"#b0e0e6\",\n    \"purple\": \"#800080\",\n    \"rebeccapurple\": \"#663399\",\n    \"red\": \"#ff0000\",\n    \"rosybrown\": \"#bc8f8f\",\n    \"royalblue\": \"#4169e1\",\n    \"saddlebrown\": \"#8b4513\",\n    \"salmon\": \"#fa8072\",\n    \"sandybrown\": \"#f4a460\",\n    \"seagreen\": \"#2e8b57\",\n    \"seashell\": \"#fff5ee\",\n    \"sienna\": \"#a0522d\",\n    \"silver\": \"#c0c0c0\",\n    \"skyblue\": \"#87ceeb\",\n    \"slateblue\": \"#6a5acd\",\n    \"slategray\": \"#708090\",\n    \"slategrey\": \"#708090\",\n    \"snow\": \"#fffafa\",\n    \"springgreen\": \"#00ff7f\",\n    \"steelblue\": \"#4682b4\",\n    \"tan\": \"#d2b48c\",\n    \"teal\": \"#008080\",\n    \"thistle\": \"#d8bfd8\",\n    \"tomato\": \"#ff6347\",\n    \"turquoise\": \"#40e0d0\",\n    \"violet\": \"#ee82ee\",\n    \"wheat\": \"#f5deb3\",\n    \"white\": \"#ffffff\",\n    \"whitesmoke\": \"#f5f5f5\",\n    \"yellow\": \"#ffff00\",\n    \"yellowgreen\": \"#9acd32\",\n}\n", "src/PIL/ImageEnhance.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# image enhancement classes\n#\n# For a background, see \"Image Processing By Interpolation and\n# Extrapolation\", Paul Haeberli and Douglas Voorhies.  Available\n# at http://www.graficaobscura.com/interp/index.html\n#\n# History:\n# 1996-03-23 fl  Created\n# 2009-06-16 fl  Fixed mean calculation\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFilter, ImageStat\n\n\nclass _Enhance:\n    image: Image.Image\n    degenerate: Image.Image\n\n    def enhance(self, factor: float) -> Image.Image:\n        \"\"\"\n        Returns an enhanced image.\n\n        :param factor: A floating point value controlling the enhancement.\n                       Factor 1.0 always returns a copy of the original image,\n                       lower factors mean less color (brightness, contrast,\n                       etc), and higher values more. There are no restrictions\n                       on this value.\n        :rtype: :py:class:`~PIL.Image.Image`\n        \"\"\"\n        return Image.blend(self.degenerate, self.image, factor)\n\n\nclass Color(_Enhance):\n    \"\"\"Adjust image color balance.\n\n    This class can be used to adjust the colour balance of an image, in\n    a manner similar to the controls on a colour TV set. An enhancement\n    factor of 0.0 gives a black and white image. A factor of 1.0 gives\n    the original image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        self.intermediate_mode = \"L\"\n        if \"A\" in image.getbands():\n            self.intermediate_mode = \"LA\"\n\n        self.degenerate = image.convert(self.intermediate_mode).convert(image.mode)\n\n\nclass Contrast(_Enhance):\n    \"\"\"Adjust image contrast.\n\n    This class can be used to control the contrast of an image, similar\n    to the contrast control on a TV set. An enhancement factor of 0.0\n    gives a solid gray image. A factor of 1.0 gives the original image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        mean = int(ImageStat.Stat(image.convert(\"L\")).mean[0] + 0.5)\n        self.degenerate = Image.new(\"L\", image.size, mean).convert(image.mode)\n\n        if \"A\" in image.getbands():\n            self.degenerate.putalpha(image.getchannel(\"A\"))\n\n\nclass Brightness(_Enhance):\n    \"\"\"Adjust image brightness.\n\n    This class can be used to control the brightness of an image.  An\n    enhancement factor of 0.0 gives a black image. A factor of 1.0 gives the\n    original image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        self.degenerate = Image.new(image.mode, image.size, 0)\n\n        if \"A\" in image.getbands():\n            self.degenerate.putalpha(image.getchannel(\"A\"))\n\n\nclass Sharpness(_Enhance):\n    \"\"\"Adjust image sharpness.\n\n    This class can be used to adjust the sharpness of an image. An\n    enhancement factor of 0.0 gives a blurred image, a factor of 1.0 gives the\n    original image, and a factor of 2.0 gives a sharpened image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        self.degenerate = image.filter(ImageFilter.SMOOTH)\n\n        if \"A\" in image.getbands():\n            self.degenerate.putalpha(image.getchannel(\"A\"))\n", "src/PIL/PaletteFile.py": "#\n# Python Imaging Library\n# $Id$\n#\n# stuff to read simple, teragon-style palette files\n#\n# History:\n#       97-08-23 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom ._binary import o8\n\n\nclass PaletteFile:\n    \"\"\"File handler for Teragon-style palette files.\"\"\"\n\n    rawmode = \"RGB\"\n\n    def __init__(self, fp: IO[bytes]) -> None:\n        palette = [o8(i) * 3 for i in range(256)]\n\n        while True:\n            s = fp.readline()\n\n            if not s:\n                break\n            if s[:1] == b\"#\":\n                continue\n            if len(s) > 100:\n                msg = \"bad palette file\"\n                raise SyntaxError(msg)\n\n            v = [int(x) for x in s.split()]\n            try:\n                [i, r, g, b] = v\n            except ValueError:\n                [i, r] = v\n                g = b = r\n\n            if 0 <= i <= 255:\n                palette[i] = o8(r) + o8(g) + o8(b)\n\n        self.palette = b\"\".join(palette)\n\n    def getpalette(self) -> tuple[bytes, str]:\n        return self.palette, self.rawmode\n", "src/PIL/Jpeg2KImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# JPEG2000 file handling\n#\n# History:\n# 2014-03-12 ajh  Created\n# 2021-06-30 rogermb  Extract dpi information from the 'resc' header box\n#\n# Copyright (c) 2014 Coriolis Systems Limited\n# Copyright (c) 2014 Alastair Houghton\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport struct\nfrom typing import IO, Tuple, cast\n\nfrom . import Image, ImageFile, ImagePalette, _binary\n\n\nclass BoxReader:\n    \"\"\"\n    A small helper class to read fields stored in JPEG2000 header boxes\n    and to easily step into and read sub-boxes.\n    \"\"\"\n\n    def __init__(self, fp, length=-1):\n        self.fp = fp\n        self.has_length = length >= 0\n        self.length = length\n        self.remaining_in_box = -1\n\n    def _can_read(self, num_bytes: int) -> bool:\n        if self.has_length and self.fp.tell() + num_bytes > self.length:\n            # Outside box: ensure we don't read past the known file length\n            return False\n        if self.remaining_in_box >= 0:\n            # Inside box contents: ensure read does not go past box boundaries\n            return num_bytes <= self.remaining_in_box\n        else:\n            return True  # No length known, just read\n\n    def _read_bytes(self, num_bytes: int) -> bytes:\n        if not self._can_read(num_bytes):\n            msg = \"Not enough data in header\"\n            raise SyntaxError(msg)\n\n        data = self.fp.read(num_bytes)\n        if len(data) < num_bytes:\n            msg = f\"Expected to read {num_bytes} bytes but only got {len(data)}.\"\n            raise OSError(msg)\n\n        if self.remaining_in_box > 0:\n            self.remaining_in_box -= num_bytes\n        return data\n\n    def read_fields(self, field_format: str) -> tuple[int | bytes, ...]:\n        size = struct.calcsize(field_format)\n        data = self._read_bytes(size)\n        return struct.unpack(field_format, data)\n\n    def read_boxes(self) -> BoxReader:\n        size = self.remaining_in_box\n        data = self._read_bytes(size)\n        return BoxReader(io.BytesIO(data), size)\n\n    def has_next_box(self) -> bool:\n        if self.has_length:\n            return self.fp.tell() + self.remaining_in_box < self.length\n        else:\n            return True\n\n    def next_box_type(self) -> bytes:\n        # Skip the rest of the box if it has not been read\n        if self.remaining_in_box > 0:\n            self.fp.seek(self.remaining_in_box, os.SEEK_CUR)\n        self.remaining_in_box = -1\n\n        # Read the length and type of the next box\n        lbox, tbox = cast(Tuple[int, bytes], self.read_fields(\">I4s\"))\n        if lbox == 1:\n            lbox = cast(int, self.read_fields(\">Q\")[0])\n            hlen = 16\n        else:\n            hlen = 8\n\n        if lbox < hlen or not self._can_read(lbox - hlen):\n            msg = \"Invalid header length\"\n            raise SyntaxError(msg)\n\n        self.remaining_in_box = lbox - hlen\n        return tbox\n\n\ndef _parse_codestream(fp):\n    \"\"\"Parse the JPEG 2000 codestream to extract the size and component\n    count from the SIZ marker segment, returning a PIL (size, mode) tuple.\"\"\"\n\n    hdr = fp.read(2)\n    lsiz = _binary.i16be(hdr)\n    siz = hdr + fp.read(lsiz - 2)\n    lsiz, rsiz, xsiz, ysiz, xosiz, yosiz, _, _, _, _, csiz = struct.unpack_from(\n        \">HHIIIIIIIIH\", siz\n    )\n\n    size = (xsiz - xosiz, ysiz - yosiz)\n    if csiz == 1:\n        ssiz = struct.unpack_from(\">B\", siz, 38)\n        if (ssiz[0] & 0x7F) + 1 > 8:\n            mode = \"I;16\"\n        else:\n            mode = \"L\"\n    elif csiz == 2:\n        mode = \"LA\"\n    elif csiz == 3:\n        mode = \"RGB\"\n    elif csiz == 4:\n        mode = \"RGBA\"\n    else:\n        mode = \"\"\n\n    return size, mode\n\n\ndef _res_to_dpi(num: int, denom: int, exp: int) -> float | None:\n    \"\"\"Convert JPEG2000's (numerator, denominator, exponent-base-10) resolution,\n    calculated as (num / denom) * 10^exp and stored in dots per meter,\n    to floating-point dots per inch.\"\"\"\n    if denom == 0:\n        return None\n    return (254 * num * (10**exp)) / (10000 * denom)\n\n\ndef _parse_jp2_header(fp):\n    \"\"\"Parse the JP2 header box to extract size, component count,\n    color space information, and optionally DPI information,\n    returning a (size, mode, mimetype, dpi) tuple.\"\"\"\n\n    # Find the JP2 header box\n    reader = BoxReader(fp)\n    header = None\n    mimetype = None\n    while reader.has_next_box():\n        tbox = reader.next_box_type()\n\n        if tbox == b\"jp2h\":\n            header = reader.read_boxes()\n            break\n        elif tbox == b\"ftyp\":\n            if reader.read_fields(\">4s\")[0] == b\"jpx \":\n                mimetype = \"image/jpx\"\n\n    size = None\n    mode = None\n    bpc = None\n    nc = None\n    dpi = None  # 2-tuple of DPI info, or None\n    palette = None\n\n    while header.has_next_box():\n        tbox = header.next_box_type()\n\n        if tbox == b\"ihdr\":\n            height, width, nc, bpc = header.read_fields(\">IIHB\")\n            size = (width, height)\n            if nc == 1 and (bpc & 0x7F) > 8:\n                mode = \"I;16\"\n            elif nc == 1:\n                mode = \"L\"\n            elif nc == 2:\n                mode = \"LA\"\n            elif nc == 3:\n                mode = \"RGB\"\n            elif nc == 4:\n                mode = \"RGBA\"\n        elif tbox == b\"colr\" and nc == 4:\n            meth, _, _, enumcs = header.read_fields(\">BBBI\")\n            if meth == 1 and enumcs == 12:\n                mode = \"CMYK\"\n        elif tbox == b\"pclr\" and mode in (\"L\", \"LA\"):\n            ne, npc = header.read_fields(\">HB\")\n            bitdepths = header.read_fields(\">\" + (\"B\" * npc))\n            if max(bitdepths) <= 8:\n                palette = ImagePalette.ImagePalette()\n                for i in range(ne):\n                    palette.getcolor(header.read_fields(\">\" + (\"B\" * npc)))\n                mode = \"P\" if mode == \"L\" else \"PA\"\n        elif tbox == b\"res \":\n            res = header.read_boxes()\n            while res.has_next_box():\n                tres = res.next_box_type()\n                if tres == b\"resc\":\n                    vrcn, vrcd, hrcn, hrcd, vrce, hrce = res.read_fields(\">HHHHBB\")\n                    hres = _res_to_dpi(hrcn, hrcd, hrce)\n                    vres = _res_to_dpi(vrcn, vrcd, vrce)\n                    if hres is not None and vres is not None:\n                        dpi = (hres, vres)\n                    break\n\n    if size is None or mode is None:\n        msg = \"Malformed JP2 header\"\n        raise SyntaxError(msg)\n\n    return size, mode, mimetype, dpi, palette\n\n\n##\n# Image plugin for JPEG2000 images.\n\n\nclass Jpeg2KImageFile(ImageFile.ImageFile):\n    format = \"JPEG2000\"\n    format_description = \"JPEG 2000 (ISO 15444)\"\n\n    def _open(self) -> None:\n        sig = self.fp.read(4)\n        if sig == b\"\\xff\\x4f\\xff\\x51\":\n            self.codec = \"j2k\"\n            self._size, self._mode = _parse_codestream(self.fp)\n        else:\n            sig = sig + self.fp.read(8)\n\n            if sig == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\":\n                self.codec = \"jp2\"\n                header = _parse_jp2_header(self.fp)\n                self._size, self._mode, self.custom_mimetype, dpi, self.palette = header\n                if dpi is not None:\n                    self.info[\"dpi\"] = dpi\n                if self.fp.read(12).endswith(b\"jp2c\\xff\\x4f\\xff\\x51\"):\n                    self._parse_comment()\n            else:\n                msg = \"not a JPEG 2000 file\"\n                raise SyntaxError(msg)\n\n        if self.size is None or not self.mode:\n            msg = \"unable to determine size/mode\"\n            raise SyntaxError(msg)\n\n        self._reduce = 0\n        self.layers = 0\n\n        fd = -1\n        length = -1\n\n        try:\n            fd = self.fp.fileno()\n            length = os.fstat(fd).st_size\n        except Exception:\n            fd = -1\n            try:\n                pos = self.fp.tell()\n                self.fp.seek(0, io.SEEK_END)\n                length = self.fp.tell()\n                self.fp.seek(pos)\n            except Exception:\n                length = -1\n\n        self.tile = [\n            (\n                \"jpeg2k\",\n                (0, 0) + self.size,\n                0,\n                (self.codec, self._reduce, self.layers, fd, length),\n            )\n        ]\n\n    def _parse_comment(self) -> None:\n        hdr = self.fp.read(2)\n        length = _binary.i16be(hdr)\n        self.fp.seek(length - 2, os.SEEK_CUR)\n\n        while True:\n            marker = self.fp.read(2)\n            if not marker:\n                break\n            typ = marker[1]\n            if typ in (0x90, 0xD9):\n                # Start of tile or end of codestream\n                break\n            hdr = self.fp.read(2)\n            length = _binary.i16be(hdr)\n            if typ == 0x64:\n                # Comment\n                self.info[\"comment\"] = self.fp.read(length - 2)[2:]\n                break\n            else:\n                self.fp.seek(length - 2, os.SEEK_CUR)\n\n    @property\n    def reduce(self):\n        # https://github.com/python-pillow/Pillow/issues/4343 found that the\n        # new Image 'reduce' method was shadowed by this plugin's 'reduce'\n        # property. This attempts to allow for both scenarios\n        return self._reduce or super().reduce\n\n    @reduce.setter\n    def reduce(self, value):\n        self._reduce = value\n\n    def load(self):\n        if self.tile and self._reduce:\n            power = 1 << self._reduce\n            adjust = power >> 1\n            self._size = (\n                int((self.size[0] + adjust) / power),\n                int((self.size[1] + adjust) / power),\n            )\n\n            # Update the reduce and layers settings\n            t = self.tile[0]\n            t3 = (t[3][0], self._reduce, self.layers, t[3][3], t[3][4])\n            self.tile = [(t[0], (0, 0) + self.size, t[2], t3)]\n\n        return ImageFile.ImageFile.load(self)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return (\n        prefix[:4] == b\"\\xff\\x4f\\xff\\x51\"\n        or prefix[:12] == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\"\n    )\n\n\n# ------------------------------------------------------------\n# Save support\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # Get the keyword arguments\n    info = im.encoderinfo\n\n    if isinstance(filename, str):\n        filename = filename.encode()\n    if filename.endswith(b\".j2k\") or info.get(\"no_jp2\", False):\n        kind = \"j2k\"\n    else:\n        kind = \"jp2\"\n\n    offset = info.get(\"offset\", None)\n    tile_offset = info.get(\"tile_offset\", None)\n    tile_size = info.get(\"tile_size\", None)\n    quality_mode = info.get(\"quality_mode\", \"rates\")\n    quality_layers = info.get(\"quality_layers\", None)\n    if quality_layers is not None and not (\n        isinstance(quality_layers, (list, tuple))\n        and all(\n            isinstance(quality_layer, (int, float)) for quality_layer in quality_layers\n        )\n    ):\n        msg = \"quality_layers must be a sequence of numbers\"\n        raise ValueError(msg)\n\n    num_resolutions = info.get(\"num_resolutions\", 0)\n    cblk_size = info.get(\"codeblock_size\", None)\n    precinct_size = info.get(\"precinct_size\", None)\n    irreversible = info.get(\"irreversible\", False)\n    progression = info.get(\"progression\", \"LRCP\")\n    cinema_mode = info.get(\"cinema_mode\", \"no\")\n    mct = info.get(\"mct\", 0)\n    signed = info.get(\"signed\", False)\n    comment = info.get(\"comment\")\n    if isinstance(comment, str):\n        comment = comment.encode()\n    plt = info.get(\"plt\", False)\n\n    fd = -1\n    if hasattr(fp, \"fileno\"):\n        try:\n            fd = fp.fileno()\n        except Exception:\n            fd = -1\n\n    im.encoderconfig = (\n        offset,\n        tile_offset,\n        tile_size,\n        quality_mode,\n        quality_layers,\n        num_resolutions,\n        cblk_size,\n        precinct_size,\n        irreversible,\n        progression,\n        cinema_mode,\n        mct,\n        signed,\n        fd,\n        comment,\n        plt,\n    )\n\n    ImageFile._save(im, fp, [(\"jpeg2k\", (0, 0) + im.size, 0, kind)])\n\n\n# ------------------------------------------------------------\n# Registry stuff\n\n\nImage.register_open(Jpeg2KImageFile.format, Jpeg2KImageFile, _accept)\nImage.register_save(Jpeg2KImageFile.format, _save)\n\nImage.register_extensions(\n    Jpeg2KImageFile.format, [\".jp2\", \".j2k\", \".jpc\", \".jpf\", \".jpx\", \".j2c\"]\n)\n\nImage.register_mime(Jpeg2KImageFile.format, \"image/jp2\")\n", "src/PIL/_typing.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom typing import Any, Protocol, Sequence, TypeVar, Union\n\ntry:\n    import numpy.typing as npt\n\n    NumpyArray = npt.NDArray[Any]\nexcept ImportError:\n    pass\n\nif sys.version_info >= (3, 10):\n    from typing import TypeGuard\nelse:\n    try:\n        from typing_extensions import TypeGuard\n    except ImportError:\n\n        class TypeGuard:  # type: ignore[no-redef]\n            def __class_getitem__(cls, item: Any) -> type[bool]:\n                return bool\n\n\nCoords = Union[Sequence[float], Sequence[Sequence[float]]]\n\n\n_T_co = TypeVar(\"_T_co\", covariant=True)\n\n\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n\nStrOrBytesPath = Union[str, bytes, \"os.PathLike[str]\", \"os.PathLike[bytes]\"]\n\n\n__all__ = [\"TypeGuard\", \"StrOrBytesPath\", \"SupportsRead\"]\n", "src/PIL/ImageMode.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard mode descriptors\n#\n# History:\n# 2006-03-20 fl   Added\n#\n# Copyright (c) 2006 by Secret Labs AB.\n# Copyright (c) 2006 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport sys\nfrom functools import lru_cache\nfrom typing import NamedTuple\n\nfrom ._deprecate import deprecate\n\n\nclass ModeDescriptor(NamedTuple):\n    \"\"\"Wrapper for mode strings.\"\"\"\n\n    mode: str\n    bands: tuple[str, ...]\n    basemode: str\n    basetype: str\n    typestr: str\n\n    def __str__(self) -> str:\n        return self.mode\n\n\n@lru_cache\ndef getmode(mode: str) -> ModeDescriptor:\n    \"\"\"Gets a mode descriptor for the given mode.\"\"\"\n    endian = \"<\" if sys.byteorder == \"little\" else \">\"\n\n    modes = {\n        # core modes\n        # Bits need to be extended to bytes\n        \"1\": (\"L\", \"L\", (\"1\",), \"|b1\"),\n        \"L\": (\"L\", \"L\", (\"L\",), \"|u1\"),\n        \"I\": (\"L\", \"I\", (\"I\",), f\"{endian}i4\"),\n        \"F\": (\"L\", \"F\", (\"F\",), f\"{endian}f4\"),\n        \"P\": (\"P\", \"L\", (\"P\",), \"|u1\"),\n        \"RGB\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\"), \"|u1\"),\n        \"RGBX\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"X\"), \"|u1\"),\n        \"RGBA\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"A\"), \"|u1\"),\n        \"CMYK\": (\"RGB\", \"L\", (\"C\", \"M\", \"Y\", \"K\"), \"|u1\"),\n        \"YCbCr\": (\"RGB\", \"L\", (\"Y\", \"Cb\", \"Cr\"), \"|u1\"),\n        # UNDONE - unsigned |u1i1i1\n        \"LAB\": (\"RGB\", \"L\", (\"L\", \"A\", \"B\"), \"|u1\"),\n        \"HSV\": (\"RGB\", \"L\", (\"H\", \"S\", \"V\"), \"|u1\"),\n        # extra experimental modes\n        \"RGBa\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"a\"), \"|u1\"),\n        \"BGR;15\": (\"RGB\", \"L\", (\"B\", \"G\", \"R\"), \"|u1\"),\n        \"BGR;16\": (\"RGB\", \"L\", (\"B\", \"G\", \"R\"), \"|u1\"),\n        \"BGR;24\": (\"RGB\", \"L\", (\"B\", \"G\", \"R\"), \"|u1\"),\n        \"LA\": (\"L\", \"L\", (\"L\", \"A\"), \"|u1\"),\n        \"La\": (\"L\", \"L\", (\"L\", \"a\"), \"|u1\"),\n        \"PA\": (\"RGB\", \"L\", (\"P\", \"A\"), \"|u1\"),\n    }\n    if mode in modes:\n        if mode in (\"BGR;15\", \"BGR;16\", \"BGR;24\"):\n            deprecate(mode, 12)\n        base_mode, base_type, bands, type_str = modes[mode]\n        return ModeDescriptor(mode, bands, base_mode, base_type, type_str)\n\n    mapping_modes = {\n        # I;16 == I;16L, and I;32 == I;32L\n        \"I;16\": \"<u2\",\n        \"I;16S\": \"<i2\",\n        \"I;16L\": \"<u2\",\n        \"I;16LS\": \"<i2\",\n        \"I;16B\": \">u2\",\n        \"I;16BS\": \">i2\",\n        \"I;16N\": f\"{endian}u2\",\n        \"I;16NS\": f\"{endian}i2\",\n        \"I;32\": \"<u4\",\n        \"I;32B\": \">u4\",\n        \"I;32L\": \"<u4\",\n        \"I;32S\": \"<i4\",\n        \"I;32BS\": \">i4\",\n        \"I;32LS\": \"<i4\",\n    }\n\n    type_str = mapping_modes[mode]\n    return ModeDescriptor(mode, (\"I\",), \"L\", \"L\", type_str)\n", "src/PIL/Hdf5StubImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# HDF5 stub adapter\n#\n# Copyright (c) 2000-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific HDF5 image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\n# --------------------------------------------------------------------\n# Image adapter\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == b\"\\x89HDF\\r\\n\\x1a\\n\"\n\n\nclass HDF5StubImageFile(ImageFile.StubImageFile):\n    format = \"HDF5\"\n    format_description = \"HDF5\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        if not _accept(self.fp.read(8)):\n            msg = \"Not an HDF file\"\n            raise SyntaxError(msg)\n\n        self.fp.seek(offset)\n\n        # make something up\n        self._mode = \"F\"\n        self._size = 1, 1\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"HDF5 save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(HDF5StubImageFile.format, HDF5StubImageFile, _accept)\nImage.register_save(HDF5StubImageFile.format, _save)\n\nImage.register_extensions(HDF5StubImageFile.format, [\".h5\", \".hdf\"])\n", "src/PIL/__init__.py": "\"\"\"Pillow (Fork of the Python Imaging Library)\n\nPillow is the friendly PIL fork by Jeffrey A. Clark and contributors.\n    https://github.com/python-pillow/Pillow/\n\nPillow is forked from PIL 1.1.7.\n\nPIL is the Python Imaging Library by Fredrik Lundh and contributors.\nCopyright (c) 1999 by Secret Labs AB.\n\nUse PIL.__version__ for this Pillow version.\n\n;-)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import _version\n\n# VERSION was removed in Pillow 6.0.0.\n# PILLOW_VERSION was removed in Pillow 9.0.0.\n# Use __version__ instead.\n__version__ = _version.__version__\ndel _version\n\n\n_plugins = [\n    \"BlpImagePlugin\",\n    \"BmpImagePlugin\",\n    \"BufrStubImagePlugin\",\n    \"CurImagePlugin\",\n    \"DcxImagePlugin\",\n    \"DdsImagePlugin\",\n    \"EpsImagePlugin\",\n    \"FitsImagePlugin\",\n    \"FliImagePlugin\",\n    \"FpxImagePlugin\",\n    \"FtexImagePlugin\",\n    \"GbrImagePlugin\",\n    \"GifImagePlugin\",\n    \"GribStubImagePlugin\",\n    \"Hdf5StubImagePlugin\",\n    \"IcnsImagePlugin\",\n    \"IcoImagePlugin\",\n    \"ImImagePlugin\",\n    \"ImtImagePlugin\",\n    \"IptcImagePlugin\",\n    \"JpegImagePlugin\",\n    \"Jpeg2KImagePlugin\",\n    \"McIdasImagePlugin\",\n    \"MicImagePlugin\",\n    \"MpegImagePlugin\",\n    \"MpoImagePlugin\",\n    \"MspImagePlugin\",\n    \"PalmImagePlugin\",\n    \"PcdImagePlugin\",\n    \"PcxImagePlugin\",\n    \"PdfImagePlugin\",\n    \"PixarImagePlugin\",\n    \"PngImagePlugin\",\n    \"PpmImagePlugin\",\n    \"PsdImagePlugin\",\n    \"QoiImagePlugin\",\n    \"SgiImagePlugin\",\n    \"SpiderImagePlugin\",\n    \"SunImagePlugin\",\n    \"TgaImagePlugin\",\n    \"TiffImagePlugin\",\n    \"WebPImagePlugin\",\n    \"WmfImagePlugin\",\n    \"XbmImagePlugin\",\n    \"XpmImagePlugin\",\n    \"XVThumbImagePlugin\",\n]\n\n\nclass UnidentifiedImageError(OSError):\n    \"\"\"\n    Raised in :py:meth:`PIL.Image.open` if an image cannot be opened and identified.\n\n    If a PNG image raises this error, setting :data:`.ImageFile.LOAD_TRUNCATED_IMAGES`\n    to true may allow the image to be opened after all. The setting will ignore missing\n    data and checksum failures.\n    \"\"\"\n\n    pass\n", "src/PIL/ImImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# IFUNC IM file handling for PIL\n#\n# history:\n# 1995-09-01 fl   Created.\n# 1997-01-03 fl   Save palette images\n# 1997-01-08 fl   Added sequence support\n# 1997-01-23 fl   Added P and RGB save support\n# 1997-05-31 fl   Read floating point images\n# 1997-06-22 fl   Save floating point images\n# 1997-08-27 fl   Read and save 1-bit images\n# 1998-06-25 fl   Added support for RGB+LUT images\n# 1998-07-02 fl   Added support for YCC images\n# 1998-07-15 fl   Renamed offset attribute to avoid name clash\n# 1998-12-29 fl   Added I;16 support\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.7)\n# 2003-09-26 fl   Added LA/PA support\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2001 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nimport re\nfrom typing import IO, Any\n\nfrom . import Image, ImageFile, ImagePalette\n\n# --------------------------------------------------------------------\n# Standard tags\n\nCOMMENT = \"Comment\"\nDATE = \"Date\"\nEQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\n\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,\n    SIZE: 0,\n    MODE: 0,\n}\n\nOPEN = {\n    # ifunc93/p3cfunc formats\n    \"0 1 image\": (\"1\", \"1\"),\n    \"L 1 image\": (\"1\", \"1\"),\n    \"Greyscale image\": (\"L\", \"L\"),\n    \"Grayscale image\": (\"L\", \"L\"),\n    \"RGB image\": (\"RGB\", \"RGB;L\"),\n    \"RLB image\": (\"RGB\", \"RLB\"),\n    \"RYB image\": (\"RGB\", \"RLB\"),\n    \"B1 image\": (\"1\", \"1\"),\n    \"B2 image\": (\"P\", \"P;2\"),\n    \"B4 image\": (\"P\", \"P;4\"),\n    \"X 24 image\": (\"RGB\", \"RGB\"),\n    \"L 32 S image\": (\"I\", \"I;32\"),\n    \"L 32 F image\": (\"F\", \"F;32\"),\n    # old p3cfunc formats\n    \"RGB3 image\": (\"RGB\", \"RGB;T\"),\n    \"RYB3 image\": (\"RGB\", \"RYB;T\"),\n    # extensions\n    \"LA image\": (\"LA\", \"LA;L\"),\n    \"PA image\": (\"LA\", \"PA;L\"),\n    \"RGBA image\": (\"RGBA\", \"RGBA;L\"),\n    \"RGBX image\": (\"RGBX\", \"RGBX;L\"),\n    \"CMYK image\": (\"CMYK\", \"CMYK;L\"),\n    \"YCC image\": (\"YCbCr\", \"YCbCr;L\"),\n}\n\n# ifunc95 extensions\nfor i in [\"8\", \"8S\", \"16\", \"16S\", \"32\", \"32F\"]:\n    OPEN[f\"L {i} image\"] = (\"F\", f\"F;{i}\")\n    OPEN[f\"L*{i} image\"] = (\"F\", f\"F;{i}\")\nfor i in [\"16\", \"16L\", \"16B\"]:\n    OPEN[f\"L {i} image\"] = (f\"I;{i}\", f\"I;{i}\")\n    OPEN[f\"L*{i} image\"] = (f\"I;{i}\", f\"I;{i}\")\nfor i in [\"32S\"]:\n    OPEN[f\"L {i} image\"] = (\"I\", f\"I;{i}\")\n    OPEN[f\"L*{i} image\"] = (\"I\", f\"I;{i}\")\nfor j in range(2, 33):\n    OPEN[f\"L*{j} image\"] = (\"F\", f\"F;{j}\")\n\n\n# --------------------------------------------------------------------\n# Read IM directory\n\nsplit = re.compile(rb\"^([A-Za-z][^:]*):[ \\t]*(.*)[ \\t]*$\")\n\n\ndef number(s: Any) -> float:\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n\n\n##\n# Image plugin for the IFUNC IM file format.\n\n\nclass ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"\n    format_description = \"IFUNC Image Memory\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # Quick rejection: if there's not an LF among the first\n        # 100 bytes, this is (probably) not a text header.\n\n        if b\"\\n\" not in self.fp.read(100):\n            msg = \"not an IM file\"\n            raise SyntaxError(msg)\n        self.fp.seek(0)\n\n        n = 0\n\n        # Default values\n        self.info[MODE] = \"L\"\n        self.info[SIZE] = (512, 512)\n        self.info[FRAMES] = 1\n\n        self.rawmode = \"L\"\n\n        while True:\n            s = self.fp.read(1)\n\n            # Some versions of IFUNC uses \\n\\r instead of \\r\\n...\n            if s == b\"\\r\":\n                continue\n\n            if not s or s == b\"\\0\" or s == b\"\\x1A\":\n                break\n\n            # FIXME: this may read whole file if not a text file\n            s = s + self.fp.readline()\n\n            if len(s) > 100:\n                msg = \"not an IM file\"\n                raise SyntaxError(msg)\n\n            if s[-2:] == b\"\\r\\n\":\n                s = s[:-2]\n            elif s[-1:] == b\"\\n\":\n                s = s[:-1]\n\n            try:\n                m = split.match(s)\n            except re.error as e:\n                msg = \"not an IM file\"\n                raise SyntaxError(msg) from e\n\n            if m:\n                k, v = m.group(1, 2)\n\n                # Don't know if this is the correct encoding,\n                # but a decent guess (I guess)\n                k = k.decode(\"latin-1\", \"replace\")\n                v = v.decode(\"latin-1\", \"replace\")\n\n                # Convert value as appropriate\n                if k in [FRAMES, SCALE, SIZE]:\n                    v = v.replace(\"*\", \",\")\n                    v = tuple(map(number, v.split(\",\")))\n                    if len(v) == 1:\n                        v = v[0]\n                elif k == MODE and v in OPEN:\n                    v, self.rawmode = OPEN[v]\n\n                # Add to dictionary. Note that COMMENT tags are\n                # combined into a list of strings.\n                if k == COMMENT:\n                    if k in self.info:\n                        self.info[k].append(v)\n                    else:\n                        self.info[k] = [v]\n                else:\n                    self.info[k] = v\n\n                if k in TAGS:\n                    n += 1\n\n            else:\n                msg = f\"Syntax error in IM header: {s.decode('ascii', 'replace')}\"\n                raise SyntaxError(msg)\n\n        if not n:\n            msg = \"Not an IM file\"\n            raise SyntaxError(msg)\n\n        # Basic attributes\n        self._size = self.info[SIZE]\n        self._mode = self.info[MODE]\n\n        # Skip forward to start of image data\n        while s and s[:1] != b\"\\x1A\":\n            s = self.fp.read(1)\n        if not s:\n            msg = \"File truncated\"\n            raise SyntaxError(msg)\n\n        if LUT in self.info:\n            # convert lookup table to palette or lut attribute\n            palette = self.fp.read(768)\n            greyscale = 1  # greyscale palette\n            linear = 1  # linear greyscale palette\n            for i in range(256):\n                if palette[i] == palette[i + 256] == palette[i + 512]:\n                    if palette[i] != i:\n                        linear = 0\n                else:\n                    greyscale = 0\n            if self.mode in [\"L\", \"LA\", \"P\", \"PA\"]:\n                if greyscale:\n                    if not linear:\n                        self.lut = list(palette[:256])\n                else:\n                    if self.mode in [\"L\", \"P\"]:\n                        self._mode = self.rawmode = \"P\"\n                    elif self.mode in [\"LA\", \"PA\"]:\n                        self._mode = \"PA\"\n                        self.rawmode = \"PA;L\"\n                    self.palette = ImagePalette.raw(\"RGB;L\", palette)\n            elif self.mode == \"RGB\":\n                if not greyscale or not linear:\n                    self.lut = list(palette)\n\n        self.frame = 0\n\n        self.__offset = offs = self.fp.tell()\n\n        self._fp = self.fp  # FIXME: hack\n\n        if self.rawmode[:2] == \"F;\":\n            # ifunc95 formats\n            try:\n                # use bit decoder (if necessary)\n                bits = int(self.rawmode[2:])\n                if bits not in [8, 16, 32]:\n                    self.tile = [(\"bit\", (0, 0) + self.size, offs, (bits, 8, 3, 0, -1))]\n                    return\n            except ValueError:\n                pass\n\n        if self.rawmode in [\"RGB;T\", \"RYB;T\"]:\n            # Old LabEye/3PC files.  Would be very surprised if anyone\n            # ever stumbled upon such a file ;-)\n            size = self.size[0] * self.size[1]\n            self.tile = [\n                (\"raw\", (0, 0) + self.size, offs, (\"G\", 0, -1)),\n                (\"raw\", (0, 0) + self.size, offs + size, (\"R\", 0, -1)),\n                (\"raw\", (0, 0) + self.size, offs + 2 * size, (\"B\", 0, -1)),\n            ]\n        else:\n            # LabEye/IFUNC files\n            self.tile = [(\"raw\", (0, 0) + self.size, offs, (self.rawmode, 0, -1))]\n\n    @property\n    def n_frames(self) -> int:\n        return self.info[FRAMES]\n\n    @property\n    def is_animated(self) -> bool:\n        return self.info[FRAMES] > 1\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n\n        self.frame = frame\n\n        if self.mode == \"1\":\n            bits = 1\n        else:\n            bits = 8 * len(self.mode)\n\n        size = ((self.size[0] * bits + 7) // 8) * self.size[1]\n        offs = self.__offset + frame * size\n\n        self.fp = self._fp\n\n        self.tile = [(\"raw\", (0, 0) + self.size, offs, (self.rawmode, 0, -1))]\n\n    def tell(self) -> int:\n        return self.frame\n\n\n#\n# --------------------------------------------------------------------\n# Save IM files\n\n\nSAVE = {\n    # mode: (im type, raw mode)\n    \"1\": (\"0 1\", \"1\"),\n    \"L\": (\"Greyscale\", \"L\"),\n    \"LA\": (\"LA\", \"LA;L\"),\n    \"P\": (\"Greyscale\", \"P\"),\n    \"PA\": (\"LA\", \"PA;L\"),\n    \"I\": (\"L 32S\", \"I;32S\"),\n    \"I;16\": (\"L 16\", \"I;16\"),\n    \"I;16L\": (\"L 16L\", \"I;16L\"),\n    \"I;16B\": (\"L 16B\", \"I;16B\"),\n    \"F\": (\"L 32F\", \"F;32F\"),\n    \"RGB\": (\"RGB\", \"RGB;L\"),\n    \"RGBA\": (\"RGBA\", \"RGBA;L\"),\n    \"RGBX\": (\"RGBX\", \"RGBX;L\"),\n    \"CMYK\": (\"CMYK\", \"CMYK;L\"),\n    \"YCbCr\": (\"YCC\", \"YCbCr;L\"),\n}\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    try:\n        image_type, rawmode = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"Cannot save {im.mode} images as IM\"\n        raise ValueError(msg) from e\n\n    frames = im.encoderinfo.get(\"frames\", 1)\n\n    fp.write(f\"Image type: {image_type} image\\r\\n\".encode(\"ascii\"))\n    if filename:\n        # Each line must be 100 characters or less,\n        # or: SyntaxError(\"not an IM file\")\n        # 8 characters are used for \"Name: \" and \"\\r\\n\"\n        # Keep just the filename, ditch the potentially overlong path\n        if isinstance(filename, bytes):\n            filename = filename.decode(\"ascii\")\n        name, ext = os.path.splitext(os.path.basename(filename))\n        name = \"\".join([name[: 92 - len(ext)], ext])\n\n        fp.write(f\"Name: {name}\\r\\n\".encode(\"ascii\"))\n    fp.write((\"Image size (x*y): %d*%d\\r\\n\" % im.size).encode(\"ascii\"))\n    fp.write(f\"File size (no of images): {frames}\\r\\n\".encode(\"ascii\"))\n    if im.mode in [\"P\", \"PA\"]:\n        fp.write(b\"Lut: 1\\r\\n\")\n    fp.write(b\"\\000\" * (511 - fp.tell()) + b\"\\032\")\n    if im.mode in [\"P\", \"PA\"]:\n        im_palette = im.im.getpalette(\"RGB\", \"RGB;L\")\n        colors = len(im_palette) // 3\n        palette = b\"\"\n        for i in range(3):\n            palette += im_palette[colors * i : colors * (i + 1)]\n            palette += b\"\\x00\" * (256 - colors)\n        fp.write(palette)  # 768 bytes\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, -1))])\n\n\n#\n# --------------------------------------------------------------------\n# Registry\n\n\nImage.register_open(ImImageFile.format, ImImageFile)\nImage.register_save(ImImageFile.format, _save)\n\nImage.register_extension(ImImageFile.format, \".im\")\n", "src/PIL/features.py": "from __future__ import annotations\n\nimport collections\nimport os\nimport sys\nimport warnings\nfrom typing import IO\n\nimport PIL\n\nfrom . import Image\n\nmodules = {\n    \"pil\": (\"PIL._imaging\", \"PILLOW_VERSION\"),\n    \"tkinter\": (\"PIL._tkinter_finder\", \"tk_version\"),\n    \"freetype2\": (\"PIL._imagingft\", \"freetype2_version\"),\n    \"littlecms2\": (\"PIL._imagingcms\", \"littlecms_version\"),\n    \"webp\": (\"PIL._webp\", \"webpdecoder_version\"),\n}\n\n\ndef check_module(feature: str) -> bool:\n    \"\"\"\n    Checks if a module is available.\n\n    :param feature: The module to check for.\n    :returns: ``True`` if available, ``False`` otherwise.\n    :raises ValueError: If the module is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in modules:\n        msg = f\"Unknown module {feature}\"\n        raise ValueError(msg)\n\n    module, ver = modules[feature]\n\n    try:\n        __import__(module)\n        return True\n    except ModuleNotFoundError:\n        return False\n    except ImportError as ex:\n        warnings.warn(str(ex))\n        return False\n\n\ndef version_module(feature: str) -> str | None:\n    \"\"\"\n    :param feature: The module to check for.\n    :returns:\n        The loaded version number as a string, or ``None`` if unknown or not available.\n    :raises ValueError: If the module is not defined in this version of Pillow.\n    \"\"\"\n    if not check_module(feature):\n        return None\n\n    module, ver = modules[feature]\n\n    return getattr(__import__(module, fromlist=[ver]), ver)\n\n\ndef get_supported_modules() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported modules.\n    \"\"\"\n    return [f for f in modules if check_module(f)]\n\n\ncodecs = {\n    \"jpg\": (\"jpeg\", \"jpeglib\"),\n    \"jpg_2000\": (\"jpeg2k\", \"jp2klib\"),\n    \"zlib\": (\"zip\", \"zlib\"),\n    \"libtiff\": (\"libtiff\", \"libtiff\"),\n}\n\n\ndef check_codec(feature: str) -> bool:\n    \"\"\"\n    Checks if a codec is available.\n\n    :param feature: The codec to check for.\n    :returns: ``True`` if available, ``False`` otherwise.\n    :raises ValueError: If the codec is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in codecs:\n        msg = f\"Unknown codec {feature}\"\n        raise ValueError(msg)\n\n    codec, lib = codecs[feature]\n\n    return f\"{codec}_encoder\" in dir(Image.core)\n\n\ndef version_codec(feature: str) -> str | None:\n    \"\"\"\n    :param feature: The codec to check for.\n    :returns:\n        The version number as a string, or ``None`` if not available.\n        Checked at compile time for ``jpg``, run-time otherwise.\n    :raises ValueError: If the codec is not defined in this version of Pillow.\n    \"\"\"\n    if not check_codec(feature):\n        return None\n\n    codec, lib = codecs[feature]\n\n    version = getattr(Image.core, f\"{lib}_version\")\n\n    if feature == \"libtiff\":\n        return version.split(\"\\n\")[0].split(\"Version \")[1]\n\n    return version\n\n\ndef get_supported_codecs() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported codecs.\n    \"\"\"\n    return [f for f in codecs if check_codec(f)]\n\n\nfeatures = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\", None),\n    \"webp_mux\": (\"PIL._webp\", \"HAVE_WEBPMUX\", None),\n    \"transp_webp\": (\"PIL._webp\", \"HAVE_TRANSPARENCY\", None),\n    \"raqm\": (\"PIL._imagingft\", \"HAVE_RAQM\", \"raqm_version\"),\n    \"fribidi\": (\"PIL._imagingft\", \"HAVE_FRIBIDI\", \"fribidi_version\"),\n    \"harfbuzz\": (\"PIL._imagingft\", \"HAVE_HARFBUZZ\", \"harfbuzz_version\"),\n    \"libjpeg_turbo\": (\"PIL._imaging\", \"HAVE_LIBJPEGTURBO\", \"libjpeg_turbo_version\"),\n    \"libimagequant\": (\"PIL._imaging\", \"HAVE_LIBIMAGEQUANT\", \"imagequant_version\"),\n    \"xcb\": (\"PIL._imaging\", \"HAVE_XCB\", None),\n}\n\n\ndef check_feature(feature: str) -> bool | None:\n    \"\"\"\n    Checks if a feature is available.\n\n    :param feature: The feature to check for.\n    :returns: ``True`` if available, ``False`` if unavailable, ``None`` if unknown.\n    :raises ValueError: If the feature is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in features:\n        msg = f\"Unknown feature {feature}\"\n        raise ValueError(msg)\n\n    module, flag, ver = features[feature]\n\n    try:\n        imported_module = __import__(module, fromlist=[\"PIL\"])\n        return getattr(imported_module, flag)\n    except ModuleNotFoundError:\n        return None\n    except ImportError as ex:\n        warnings.warn(str(ex))\n        return None\n\n\ndef version_feature(feature: str) -> str | None:\n    \"\"\"\n    :param feature: The feature to check for.\n    :returns: The version number as a string, or ``None`` if not available.\n    :raises ValueError: If the feature is not defined in this version of Pillow.\n    \"\"\"\n    if not check_feature(feature):\n        return None\n\n    module, flag, ver = features[feature]\n\n    if ver is None:\n        return None\n\n    return getattr(__import__(module, fromlist=[ver]), ver)\n\n\ndef get_supported_features() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported features.\n    \"\"\"\n    return [f for f in features if check_feature(f)]\n\n\ndef check(feature: str) -> bool | None:\n    \"\"\"\n    :param feature: A module, codec, or feature name.\n    :returns:\n        ``True`` if the module, codec, or feature is available,\n        ``False`` or ``None`` otherwise.\n    \"\"\"\n\n    if feature in modules:\n        return check_module(feature)\n    if feature in codecs:\n        return check_codec(feature)\n    if feature in features:\n        return check_feature(feature)\n    warnings.warn(f\"Unknown feature '{feature}'.\", stacklevel=2)\n    return False\n\n\ndef version(feature: str) -> str | None:\n    \"\"\"\n    :param feature:\n        The module, codec, or feature to check for.\n    :returns:\n        The version number as a string, or ``None`` if unknown or not available.\n    \"\"\"\n    if feature in modules:\n        return version_module(feature)\n    if feature in codecs:\n        return version_codec(feature)\n    if feature in features:\n        return version_feature(feature)\n    return None\n\n\ndef get_supported() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported modules, features, and codecs.\n    \"\"\"\n\n    ret = get_supported_modules()\n    ret.extend(get_supported_features())\n    ret.extend(get_supported_codecs())\n    return ret\n\n\ndef pilinfo(out: IO[str] | None = None, supported_formats: bool = True) -> None:\n    \"\"\"\n    Prints information about this installation of Pillow.\n    This function can be called with ``python3 -m PIL``.\n    It can also be called with ``python3 -m PIL.report`` or ``python3 -m PIL --report``\n    to have \"supported_formats\" set to ``False``, omitting the list of all supported\n    image file formats.\n\n    :param out:\n        The output stream to print to. Defaults to ``sys.stdout`` if ``None``.\n    :param supported_formats:\n        If ``True``, a list of all supported image file formats will be printed.\n    \"\"\"\n\n    if out is None:\n        out = sys.stdout\n\n    Image.init()\n\n    print(\"-\" * 68, file=out)\n    print(f\"Pillow {PIL.__version__}\", file=out)\n    py_version_lines = sys.version.splitlines()\n    print(f\"Python {py_version_lines[0].strip()}\", file=out)\n    for py_version in py_version_lines[1:]:\n        print(f\"       {py_version.strip()}\", file=out)\n    print(\"-\" * 68, file=out)\n    print(f\"Python executable is {sys.executable or 'unknown'}\", file=out)\n    if sys.prefix != sys.base_prefix:\n        print(f\"Environment Python files loaded from {sys.prefix}\", file=out)\n    print(f\"System Python files loaded from {sys.base_prefix}\", file=out)\n    print(\"-\" * 68, file=out)\n    print(\n        f\"Python Pillow modules loaded from {os.path.dirname(Image.__file__)}\",\n        file=out,\n    )\n    print(\n        f\"Binary Pillow modules loaded from {os.path.dirname(Image.core.__file__)}\",\n        file=out,\n    )\n    print(\"-\" * 68, file=out)\n\n    for name, feature in [\n        (\"pil\", \"PIL CORE\"),\n        (\"tkinter\", \"TKINTER\"),\n        (\"freetype2\", \"FREETYPE2\"),\n        (\"littlecms2\", \"LITTLECMS2\"),\n        (\"webp\", \"WEBP\"),\n        (\"transp_webp\", \"WEBP Transparency\"),\n        (\"webp_mux\", \"WEBPMUX\"),\n        (\"webp_anim\", \"WEBP Animation\"),\n        (\"jpg\", \"JPEG\"),\n        (\"jpg_2000\", \"OPENJPEG (JPEG2000)\"),\n        (\"zlib\", \"ZLIB (PNG/ZIP)\"),\n        (\"libtiff\", \"LIBTIFF\"),\n        (\"raqm\", \"RAQM (Bidirectional Text)\"),\n        (\"libimagequant\", \"LIBIMAGEQUANT (Quantization method)\"),\n        (\"xcb\", \"XCB (X protocol)\"),\n    ]:\n        if check(name):\n            v: str | None = None\n            if name == \"jpg\":\n                libjpeg_turbo_version = version_feature(\"libjpeg_turbo\")\n                if libjpeg_turbo_version is not None:\n                    v = \"libjpeg-turbo \" + libjpeg_turbo_version\n            if v is None:\n                v = version(name)\n            if v is not None:\n                version_static = name in (\"pil\", \"jpg\")\n                if name == \"littlecms2\":\n                    # this check is also in src/_imagingcms.c:setup_module()\n                    version_static = tuple(int(x) for x in v.split(\".\")) < (2, 7)\n                t = \"compiled for\" if version_static else \"loaded\"\n                if name == \"raqm\":\n                    for f in (\"fribidi\", \"harfbuzz\"):\n                        v2 = version_feature(f)\n                        if v2 is not None:\n                            v += f\", {f} {v2}\"\n                print(\"---\", feature, \"support ok,\", t, v, file=out)\n            else:\n                print(\"---\", feature, \"support ok\", file=out)\n        else:\n            print(\"***\", feature, \"support not installed\", file=out)\n    print(\"-\" * 68, file=out)\n\n    if supported_formats:\n        extensions = collections.defaultdict(list)\n        for ext, i in Image.EXTENSION.items():\n            extensions[i].append(ext)\n\n        for i in sorted(Image.ID):\n            line = f\"{i}\"\n            if i in Image.MIME:\n                line = f\"{line} {Image.MIME[i]}\"\n            print(line, file=out)\n\n            if i in extensions:\n                print(\n                    \"Extensions: {}\".format(\", \".join(sorted(extensions[i]))), file=out\n                )\n\n            features = []\n            if i in Image.OPEN:\n                features.append(\"open\")\n            if i in Image.SAVE:\n                features.append(\"save\")\n            if i in Image.SAVE_ALL:\n                features.append(\"save_all\")\n            if i in Image.DECODERS:\n                features.append(\"decode\")\n            if i in Image.ENCODERS:\n                features.append(\"encode\")\n\n            print(\"Features: {}\".format(\", \".join(features)), file=out)\n            print(\"-\" * 68, file=out)\n", "src/PIL/GifImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# GIF file handling\n#\n# History:\n# 1995-09-01 fl   Created\n# 1996-12-14 fl   Added interlace support\n# 1996-12-30 fl   Added animation support\n# 1997-01-05 fl   Added write support, fixed local colour map bug\n# 1997-02-23 fl   Make sure to load raster data in getdata()\n# 1997-07-05 fl   Support external decoder (0.4)\n# 1998-07-09 fl   Handle all modes when saving (0.5)\n# 1998-07-15 fl   Renamed offset attribute to avoid name clash\n# 2001-04-16 fl   Added rewind support (seek to frame 0) (0.6)\n# 2001-04-17 fl   Added palette optimization (0.7)\n# 2002-06-06 fl   Added transparency support for save (0.8)\n# 2004-02-24 fl   Disable interlacing for small images\n#\n# Copyright (c) 1997-2004 by Secret Labs AB\n# Copyright (c) 1995-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport itertools\nimport math\nimport os\nimport subprocess\nimport sys\nfrom enum import IntEnum\nfrom functools import cached_property\nfrom typing import IO, TYPE_CHECKING, Any, List, Literal, NamedTuple, Union\n\nfrom . import (\n    Image,\n    ImageChops,\n    ImageFile,\n    ImageMath,\n    ImageOps,\n    ImagePalette,\n    ImageSequence,\n)\nfrom ._binary import i16le as i16\nfrom ._binary import o8\nfrom ._binary import o16le as o16\n\nif TYPE_CHECKING:\n    from . import _imaging\n\n\nclass LoadingStrategy(IntEnum):\n    \"\"\".. versionadded:: 9.1.0\"\"\"\n\n    RGB_AFTER_FIRST = 0\n    RGB_AFTER_DIFFERENT_PALETTE_ONLY = 1\n    RGB_ALWAYS = 2\n\n\n#: .. versionadded:: 9.1.0\nLOADING_STRATEGY = LoadingStrategy.RGB_AFTER_FIRST\n\n# --------------------------------------------------------------------\n# Identify/read GIF files\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:6] in [b\"GIF87a\", b\"GIF89a\"]\n\n\n##\n# Image plugin for GIF images.  This plugin supports both GIF87 and\n# GIF89 images.\n\n\nclass GifImageFile(ImageFile.ImageFile):\n    format = \"GIF\"\n    format_description = \"Compuserve GIF\"\n    _close_exclusive_fp_after_loading = False\n\n    global_palette = None\n\n    def data(self) -> bytes | None:\n        s = self.fp.read(1)\n        if s and s[0]:\n            return self.fp.read(s[0])\n        return None\n\n    def _is_palette_needed(self, p: bytes) -> bool:\n        for i in range(0, len(p), 3):\n            if not (i // 3 == p[i] == p[i + 1] == p[i + 2]):\n                return True\n        return False\n\n    def _open(self) -> None:\n        # Screen\n        s = self.fp.read(13)\n        if not _accept(s):\n            msg = \"not a GIF file\"\n            raise SyntaxError(msg)\n\n        self.info[\"version\"] = s[:6]\n        self._size = i16(s, 6), i16(s, 8)\n        self.tile = []\n        flags = s[10]\n        bits = (flags & 7) + 1\n\n        if flags & 128:\n            # get global palette\n            self.info[\"background\"] = s[11]\n            # check if palette contains colour indices\n            p = self.fp.read(3 << bits)\n            if self._is_palette_needed(p):\n                p = ImagePalette.raw(\"RGB\", p)\n                self.global_palette = self.palette = p\n\n        self._fp = self.fp  # FIXME: hack\n        self.__rewind = self.fp.tell()\n        self._n_frames: int | None = None\n        self._seek(0)  # get ready to read first frame\n\n    @property\n    def n_frames(self) -> int:\n        if self._n_frames is None:\n            current = self.tell()\n            try:\n                while True:\n                    self._seek(self.tell() + 1, False)\n            except EOFError:\n                self._n_frames = self.tell() + 1\n            self.seek(current)\n        return self._n_frames\n\n    @cached_property\n    def is_animated(self) -> bool:\n        if self._n_frames is not None:\n            return self._n_frames != 1\n\n        current = self.tell()\n        if current:\n            return True\n\n        try:\n            self._seek(1, False)\n            is_animated = True\n        except EOFError:\n            is_animated = False\n\n        self.seek(current)\n        return is_animated\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        if frame < self.__frame:\n            self.im = None\n            self._seek(0)\n\n        last_frame = self.__frame\n        for f in range(self.__frame + 1, frame + 1):\n            try:\n                self._seek(f)\n            except EOFError as e:\n                self.seek(last_frame)\n                msg = \"no more images in GIF file\"\n                raise EOFError(msg) from e\n\n    def _seek(self, frame: int, update_image: bool = True) -> None:\n        if frame == 0:\n            # rewind\n            self.__offset = 0\n            self.dispose: _imaging.ImagingCore | None = None\n            self.__frame = -1\n            self._fp.seek(self.__rewind)\n            self.disposal_method = 0\n            if \"comment\" in self.info:\n                del self.info[\"comment\"]\n        else:\n            # ensure that the previous frame was loaded\n            if self.tile and update_image:\n                self.load()\n\n        if frame != self.__frame + 1:\n            msg = f\"cannot seek to frame {frame}\"\n            raise ValueError(msg)\n\n        self.fp = self._fp\n        if self.__offset:\n            # backup to last frame\n            self.fp.seek(self.__offset)\n            while self.data():\n                pass\n            self.__offset = 0\n\n        s = self.fp.read(1)\n        if not s or s == b\";\":\n            msg = \"no more images in GIF file\"\n            raise EOFError(msg)\n\n        palette: ImagePalette.ImagePalette | Literal[False] | None = None\n\n        info: dict[str, Any] = {}\n        frame_transparency = None\n        interlace = None\n        frame_dispose_extent = None\n        while True:\n            if not s:\n                s = self.fp.read(1)\n            if not s or s == b\";\":\n                break\n\n            elif s == b\"!\":\n                #\n                # extensions\n                #\n                s = self.fp.read(1)\n                block = self.data()\n                if s[0] == 249 and block is not None:\n                    #\n                    # graphic control extension\n                    #\n                    flags = block[0]\n                    if flags & 1:\n                        frame_transparency = block[3]\n                    info[\"duration\"] = i16(block, 1) * 10\n\n                    # disposal method - find the value of bits 4 - 6\n                    dispose_bits = 0b00011100 & flags\n                    dispose_bits = dispose_bits >> 2\n                    if dispose_bits:\n                        # only set the dispose if it is not\n                        # unspecified. I'm not sure if this is\n                        # correct, but it seems to prevent the last\n                        # frame from looking odd for some animations\n                        self.disposal_method = dispose_bits\n                elif s[0] == 254:\n                    #\n                    # comment extension\n                    #\n                    comment = b\"\"\n\n                    # Read this comment block\n                    while block:\n                        comment += block\n                        block = self.data()\n\n                    if \"comment\" in info:\n                        # If multiple comment blocks in frame, separate with \\n\n                        info[\"comment\"] += b\"\\n\" + comment\n                    else:\n                        info[\"comment\"] = comment\n                    s = None\n                    continue\n                elif s[0] == 255 and frame == 0 and block is not None:\n                    #\n                    # application extension\n                    #\n                    info[\"extension\"] = block, self.fp.tell()\n                    if block[:11] == b\"NETSCAPE2.0\":\n                        block = self.data()\n                        if block and len(block) >= 3 and block[0] == 1:\n                            self.info[\"loop\"] = i16(block, 1)\n                while self.data():\n                    pass\n\n            elif s == b\",\":\n                #\n                # local image\n                #\n                s = self.fp.read(9)\n\n                # extent\n                x0, y0 = i16(s, 0), i16(s, 2)\n                x1, y1 = x0 + i16(s, 4), y0 + i16(s, 6)\n                if (x1 > self.size[0] or y1 > self.size[1]) and update_image:\n                    self._size = max(x1, self.size[0]), max(y1, self.size[1])\n                    Image._decompression_bomb_check(self._size)\n                frame_dispose_extent = x0, y0, x1, y1\n                flags = s[8]\n\n                interlace = (flags & 64) != 0\n\n                if flags & 128:\n                    bits = (flags & 7) + 1\n                    p = self.fp.read(3 << bits)\n                    if self._is_palette_needed(p):\n                        palette = ImagePalette.raw(\"RGB\", p)\n                    else:\n                        palette = False\n\n                # image data\n                bits = self.fp.read(1)[0]\n                self.__offset = self.fp.tell()\n                break\n            s = None\n\n        if interlace is None:\n            msg = \"image not found in GIF frame\"\n            raise EOFError(msg)\n\n        self.__frame = frame\n        if not update_image:\n            return\n\n        self.tile = []\n\n        if self.dispose:\n            self.im.paste(self.dispose, self.dispose_extent)\n\n        self._frame_palette = palette if palette is not None else self.global_palette\n        self._frame_transparency = frame_transparency\n        if frame == 0:\n            if self._frame_palette:\n                if LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS:\n                    self._mode = \"RGBA\" if frame_transparency is not None else \"RGB\"\n                else:\n                    self._mode = \"P\"\n            else:\n                self._mode = \"L\"\n\n            if not palette and self.global_palette:\n                from copy import copy\n\n                palette = copy(self.global_palette)\n            self.palette = palette\n        else:\n            if self.mode == \"P\":\n                if (\n                    LOADING_STRATEGY != LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY\n                    or palette\n                ):\n                    self.pyaccess = None\n                    if \"transparency\" in self.info:\n                        self.im.putpalettealpha(self.info[\"transparency\"], 0)\n                        self.im = self.im.convert(\"RGBA\", Image.Dither.FLOYDSTEINBERG)\n                        self._mode = \"RGBA\"\n                        del self.info[\"transparency\"]\n                    else:\n                        self._mode = \"RGB\"\n                        self.im = self.im.convert(\"RGB\", Image.Dither.FLOYDSTEINBERG)\n\n        def _rgb(color: int) -> tuple[int, int, int]:\n            if self._frame_palette:\n                if color * 3 + 3 > len(self._frame_palette.palette):\n                    color = 0\n                return tuple(self._frame_palette.palette[color * 3 : color * 3 + 3])\n            else:\n                return (color, color, color)\n\n        self.dispose = None\n        self.dispose_extent = frame_dispose_extent\n        if self.dispose_extent and self.disposal_method >= 2:\n            try:\n                if self.disposal_method == 2:\n                    # replace with background colour\n\n                    # only dispose the extent in this frame\n                    x0, y0, x1, y1 = self.dispose_extent\n                    dispose_size = (x1 - x0, y1 - y0)\n\n                    Image._decompression_bomb_check(dispose_size)\n\n                    # by convention, attempt to use transparency first\n                    dispose_mode = \"P\"\n                    color = self.info.get(\"transparency\", frame_transparency)\n                    if color is not None:\n                        if self.mode in (\"RGB\", \"RGBA\"):\n                            dispose_mode = \"RGBA\"\n                            color = _rgb(color) + (0,)\n                    else:\n                        color = self.info.get(\"background\", 0)\n                        if self.mode in (\"RGB\", \"RGBA\"):\n                            dispose_mode = \"RGB\"\n                            color = _rgb(color)\n                    self.dispose = Image.core.fill(dispose_mode, dispose_size, color)\n                else:\n                    # replace with previous contents\n                    if self.im is not None:\n                        # only dispose the extent in this frame\n                        self.dispose = self._crop(self.im, self.dispose_extent)\n                    elif frame_transparency is not None:\n                        x0, y0, x1, y1 = self.dispose_extent\n                        dispose_size = (x1 - x0, y1 - y0)\n\n                        Image._decompression_bomb_check(dispose_size)\n                        dispose_mode = \"P\"\n                        color = frame_transparency\n                        if self.mode in (\"RGB\", \"RGBA\"):\n                            dispose_mode = \"RGBA\"\n                            color = _rgb(frame_transparency) + (0,)\n                        self.dispose = Image.core.fill(\n                            dispose_mode, dispose_size, color\n                        )\n            except AttributeError:\n                pass\n\n        if interlace is not None:\n            transparency = -1\n            if frame_transparency is not None:\n                if frame == 0:\n                    if LOADING_STRATEGY != LoadingStrategy.RGB_ALWAYS:\n                        self.info[\"transparency\"] = frame_transparency\n                elif self.mode not in (\"RGB\", \"RGBA\"):\n                    transparency = frame_transparency\n            self.tile = [\n                (\n                    \"gif\",\n                    (x0, y0, x1, y1),\n                    self.__offset,\n                    (bits, interlace, transparency),\n                )\n            ]\n\n        if info.get(\"comment\"):\n            self.info[\"comment\"] = info[\"comment\"]\n        for k in [\"duration\", \"extension\"]:\n            if k in info:\n                self.info[k] = info[k]\n            elif k in self.info:\n                del self.info[k]\n\n    def load_prepare(self) -> None:\n        temp_mode = \"P\" if self._frame_palette else \"L\"\n        self._prev_im = None\n        if self.__frame == 0:\n            if self._frame_transparency is not None:\n                self.im = Image.core.fill(\n                    temp_mode, self.size, self._frame_transparency\n                )\n        elif self.mode in (\"RGB\", \"RGBA\"):\n            self._prev_im = self.im\n            if self._frame_palette:\n                self.im = Image.core.fill(\"P\", self.size, self._frame_transparency or 0)\n                self.im.putpalette(\"RGB\", *self._frame_palette.getdata())\n            else:\n                self.im = None\n        self._mode = temp_mode\n        self._frame_palette = None\n\n        super().load_prepare()\n\n    def load_end(self) -> None:\n        if self.__frame == 0:\n            if self.mode == \"P\" and LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS:\n                if self._frame_transparency is not None:\n                    self.im.putpalettealpha(self._frame_transparency, 0)\n                    self._mode = \"RGBA\"\n                else:\n                    self._mode = \"RGB\"\n                self.im = self.im.convert(self.mode, Image.Dither.FLOYDSTEINBERG)\n            return\n        if not self._prev_im:\n            return\n        if self._frame_transparency is not None:\n            self.im.putpalettealpha(self._frame_transparency, 0)\n            frame_im = self.im.convert(\"RGBA\")\n        else:\n            frame_im = self.im.convert(\"RGB\")\n\n        assert self.dispose_extent is not None\n        frame_im = self._crop(frame_im, self.dispose_extent)\n\n        self.im = self._prev_im\n        self._mode = self.im.mode\n        if frame_im.mode == \"RGBA\":\n            self.im.paste(frame_im, self.dispose_extent, frame_im)\n        else:\n            self.im.paste(frame_im, self.dispose_extent)\n\n    def tell(self) -> int:\n        return self.__frame\n\n\n# --------------------------------------------------------------------\n# Write GIF files\n\n\nRAWMODE = {\"1\": \"L\", \"L\": \"L\", \"P\": \"P\"}\n\n\ndef _normalize_mode(im: Image.Image) -> Image.Image:\n    \"\"\"\n    Takes an image (or frame), returns an image in a mode that is appropriate\n    for saving in a Gif.\n\n    It may return the original image, or it may return an image converted to\n    palette or 'L' mode.\n\n    :param im: Image object\n    :returns: Image object\n    \"\"\"\n    if im.mode in RAWMODE:\n        im.load()\n        return im\n    if Image.getmodebase(im.mode) == \"RGB\":\n        im = im.convert(\"P\", palette=Image.Palette.ADAPTIVE)\n        if im.palette.mode == \"RGBA\":\n            for rgba in im.palette.colors:\n                if rgba[3] == 0:\n                    im.info[\"transparency\"] = im.palette.colors[rgba]\n                    break\n        return im\n    return im.convert(\"L\")\n\n\n_Palette = Union[bytes, bytearray, List[int], ImagePalette.ImagePalette]\n\n\ndef _normalize_palette(\n    im: Image.Image, palette: _Palette | None, info: dict[str, Any]\n) -> Image.Image:\n    \"\"\"\n    Normalizes the palette for image.\n      - Sets the palette to the incoming palette, if provided.\n      - Ensures that there's a palette for L mode images\n      - Optimizes the palette if necessary/desired.\n\n    :param im: Image object\n    :param palette: bytes object containing the source palette, or ....\n    :param info: encoderinfo\n    :returns: Image object\n    \"\"\"\n    source_palette = None\n    if palette:\n        # a bytes palette\n        if isinstance(palette, (bytes, bytearray, list)):\n            source_palette = bytearray(palette[:768])\n        if isinstance(palette, ImagePalette.ImagePalette):\n            source_palette = bytearray(palette.palette)\n\n    if im.mode == \"P\":\n        if not source_palette:\n            source_palette = im.im.getpalette(\"RGB\")[:768]\n    else:  # L-mode\n        if not source_palette:\n            source_palette = bytearray(i // 3 for i in range(768))\n        im.palette = ImagePalette.ImagePalette(\"RGB\", palette=source_palette)\n\n    used_palette_colors: list[int] | None\n    if palette:\n        used_palette_colors = []\n        assert source_palette is not None\n        for i in range(0, len(source_palette), 3):\n            source_color = tuple(source_palette[i : i + 3])\n            index = im.palette.colors.get(source_color)\n            if index in used_palette_colors:\n                index = None\n            used_palette_colors.append(index)\n        for i, index in enumerate(used_palette_colors):\n            if index is None:\n                for j in range(len(used_palette_colors)):\n                    if j not in used_palette_colors:\n                        used_palette_colors[i] = j\n                        break\n        im = im.remap_palette(used_palette_colors)\n    else:\n        used_palette_colors = _get_optimize(im, info)\n        if used_palette_colors is not None:\n            im = im.remap_palette(used_palette_colors, source_palette)\n            if \"transparency\" in info:\n                try:\n                    info[\"transparency\"] = used_palette_colors.index(\n                        info[\"transparency\"]\n                    )\n                except ValueError:\n                    del info[\"transparency\"]\n            return im\n\n    im.palette.palette = source_palette\n    return im\n\n\ndef _write_single_frame(\n    im: Image.Image,\n    fp: IO[bytes],\n    palette: _Palette | None,\n) -> None:\n    im_out = _normalize_mode(im)\n    for k, v in im_out.info.items():\n        im.encoderinfo.setdefault(k, v)\n    im_out = _normalize_palette(im_out, palette, im.encoderinfo)\n\n    for s in _get_global_header(im_out, im.encoderinfo):\n        fp.write(s)\n\n    # local image header\n    flags = 0\n    if get_interlace(im):\n        flags = flags | 64\n    _write_local_header(fp, im, (0, 0), flags)\n\n    im_out.encoderconfig = (8, get_interlace(im))\n    ImageFile._save(im_out, fp, [(\"gif\", (0, 0) + im.size, 0, RAWMODE[im_out.mode])])\n\n    fp.write(b\"\\0\")  # end of image data\n\n\ndef _getbbox(\n    base_im: Image.Image, im_frame: Image.Image\n) -> tuple[Image.Image, tuple[int, int, int, int] | None]:\n    if _get_palette_bytes(im_frame) != _get_palette_bytes(base_im):\n        im_frame = im_frame.convert(\"RGBA\")\n        base_im = base_im.convert(\"RGBA\")\n    delta = ImageChops.subtract_modulo(im_frame, base_im)\n    return delta, delta.getbbox(alpha_only=False)\n\n\nclass _Frame(NamedTuple):\n    im: Image.Image\n    bbox: tuple[int, int, int, int] | None\n    encoderinfo: dict[str, Any]\n\n\ndef _write_multiple_frames(\n    im: Image.Image, fp: IO[bytes], palette: _Palette | None\n) -> bool:\n    duration = im.encoderinfo.get(\"duration\")\n    disposal = im.encoderinfo.get(\"disposal\", im.info.get(\"disposal\"))\n\n    im_frames: list[_Frame] = []\n    previous_im: Image.Image | None = None\n    frame_count = 0\n    background_im = None\n    for imSequence in itertools.chain([im], im.encoderinfo.get(\"append_images\", [])):\n        for im_frame in ImageSequence.Iterator(imSequence):\n            # a copy is required here since seek can still mutate the image\n            im_frame = _normalize_mode(im_frame.copy())\n            if frame_count == 0:\n                for k, v in im_frame.info.items():\n                    if k == \"transparency\":\n                        continue\n                    im.encoderinfo.setdefault(k, v)\n\n            encoderinfo = im.encoderinfo.copy()\n            if \"transparency\" in im_frame.info:\n                encoderinfo.setdefault(\"transparency\", im_frame.info[\"transparency\"])\n            im_frame = _normalize_palette(im_frame, palette, encoderinfo)\n            if isinstance(duration, (list, tuple)):\n                encoderinfo[\"duration\"] = duration[frame_count]\n            elif duration is None and \"duration\" in im_frame.info:\n                encoderinfo[\"duration\"] = im_frame.info[\"duration\"]\n            if isinstance(disposal, (list, tuple)):\n                encoderinfo[\"disposal\"] = disposal[frame_count]\n            frame_count += 1\n\n            diff_frame = None\n            if im_frames and previous_im:\n                # delta frame\n                delta, bbox = _getbbox(previous_im, im_frame)\n                if not bbox:\n                    # This frame is identical to the previous frame\n                    if encoderinfo.get(\"duration\"):\n                        im_frames[-1].encoderinfo[\"duration\"] += encoderinfo[\"duration\"]\n                    continue\n                if im_frames[-1].encoderinfo.get(\"disposal\") == 2:\n                    if background_im is None:\n                        color = im.encoderinfo.get(\n                            \"transparency\", im.info.get(\"transparency\", (0, 0, 0))\n                        )\n                        background = _get_background(im_frame, color)\n                        background_im = Image.new(\"P\", im_frame.size, background)\n                        background_im.putpalette(im_frames[0].im.palette)\n                    bbox = _getbbox(background_im, im_frame)[1]\n                elif encoderinfo.get(\"optimize\") and im_frame.mode != \"1\":\n                    if \"transparency\" not in encoderinfo:\n                        try:\n                            encoderinfo[\"transparency\"] = (\n                                im_frame.palette._new_color_index(im_frame)\n                            )\n                        except ValueError:\n                            pass\n                    if \"transparency\" in encoderinfo:\n                        # When the delta is zero, fill the image with transparency\n                        diff_frame = im_frame.copy()\n                        fill = Image.new(\"P\", delta.size, encoderinfo[\"transparency\"])\n                        if delta.mode == \"RGBA\":\n                            r, g, b, a = delta.split()\n                            mask = ImageMath.lambda_eval(\n                                lambda args: args[\"convert\"](\n                                    args[\"max\"](\n                                        args[\"max\"](\n                                            args[\"max\"](args[\"r\"], args[\"g\"]), args[\"b\"]\n                                        ),\n                                        args[\"a\"],\n                                    )\n                                    * 255,\n                                    \"1\",\n                                ),\n                                r=r,\n                                g=g,\n                                b=b,\n                                a=a,\n                            )\n                        else:\n                            if delta.mode == \"P\":\n                                # Convert to L without considering palette\n                                delta_l = Image.new(\"L\", delta.size)\n                                delta_l.putdata(delta.getdata())\n                                delta = delta_l\n                            mask = ImageMath.lambda_eval(\n                                lambda args: args[\"convert\"](args[\"im\"] * 255, \"1\"),\n                                im=delta,\n                            )\n                        diff_frame.paste(fill, mask=ImageOps.invert(mask))\n            else:\n                bbox = None\n            previous_im = im_frame\n            im_frames.append(_Frame(diff_frame or im_frame, bbox, encoderinfo))\n\n    if len(im_frames) == 1:\n        if \"duration\" in im.encoderinfo:\n            # Since multiple frames will not be written, use the combined duration\n            im.encoderinfo[\"duration\"] = im_frames[0].encoderinfo[\"duration\"]\n        return False\n\n    for frame_data in im_frames:\n        im_frame = frame_data.im\n        if not frame_data.bbox:\n            # global header\n            for s in _get_global_header(im_frame, frame_data.encoderinfo):\n                fp.write(s)\n            offset = (0, 0)\n        else:\n            # compress difference\n            if not palette:\n                frame_data.encoderinfo[\"include_color_table\"] = True\n\n            im_frame = im_frame.crop(frame_data.bbox)\n            offset = frame_data.bbox[:2]\n        _write_frame_data(fp, im_frame, offset, frame_data.encoderinfo)\n    return True\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, save_all=True)\n\n\ndef _save(\n    im: Image.Image, fp: IO[bytes], filename: str | bytes, save_all: bool = False\n) -> None:\n    # header\n    if \"palette\" in im.encoderinfo or \"palette\" in im.info:\n        palette = im.encoderinfo.get(\"palette\", im.info.get(\"palette\"))\n    else:\n        palette = None\n        im.encoderinfo.setdefault(\"optimize\", True)\n\n    if not save_all or not _write_multiple_frames(im, fp, palette):\n        _write_single_frame(im, fp, palette)\n\n    fp.write(b\";\")  # end of file\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\ndef get_interlace(im: Image.Image) -> int:\n    interlace = im.encoderinfo.get(\"interlace\", 1)\n\n    # workaround for @PIL153\n    if min(im.size) < 16:\n        interlace = 0\n\n    return interlace\n\n\ndef _write_local_header(\n    fp: IO[bytes], im: Image.Image, offset: tuple[int, int], flags: int\n) -> None:\n    try:\n        transparency = im.encoderinfo[\"transparency\"]\n    except KeyError:\n        transparency = None\n\n    if \"duration\" in im.encoderinfo:\n        duration = int(im.encoderinfo[\"duration\"] / 10)\n    else:\n        duration = 0\n\n    disposal = int(im.encoderinfo.get(\"disposal\", 0))\n\n    if transparency is not None or duration != 0 or disposal:\n        packed_flag = 1 if transparency is not None else 0\n        packed_flag |= disposal << 2\n\n        fp.write(\n            b\"!\"\n            + o8(249)  # extension intro\n            + o8(4)  # length\n            + o8(packed_flag)  # packed fields\n            + o16(duration)  # duration\n            + o8(transparency or 0)  # transparency index\n            + o8(0)\n        )\n\n    include_color_table = im.encoderinfo.get(\"include_color_table\")\n    if include_color_table:\n        palette_bytes = _get_palette_bytes(im)\n        color_table_size = _get_color_table_size(palette_bytes)\n        if color_table_size:\n            flags = flags | 128  # local color table flag\n            flags = flags | color_table_size\n\n    fp.write(\n        b\",\"\n        + o16(offset[0])  # offset\n        + o16(offset[1])\n        + o16(im.size[0])  # size\n        + o16(im.size[1])\n        + o8(flags)  # flags\n    )\n    if include_color_table and color_table_size:\n        fp.write(_get_header_palette(palette_bytes))\n    fp.write(o8(8))  # bits\n\n\ndef _save_netpbm(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # Unused by default.\n    # To use, uncomment the register_save call at the end of the file.\n    #\n    # If you need real GIF compression and/or RGB quantization, you\n    # can use the external NETPBM/PBMPLUS utilities.  See comments\n    # below for information on how to enable this.\n    tempfile = im._dump()\n\n    try:\n        with open(filename, \"wb\") as f:\n            if im.mode != \"RGB\":\n                subprocess.check_call(\n                    [\"ppmtogif\", tempfile], stdout=f, stderr=subprocess.DEVNULL\n                )\n            else:\n                # Pipe ppmquant output into ppmtogif\n                # \"ppmquant 256 %s | ppmtogif > %s\" % (tempfile, filename)\n                quant_cmd = [\"ppmquant\", \"256\", tempfile]\n                togif_cmd = [\"ppmtogif\"]\n                quant_proc = subprocess.Popen(\n                    quant_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL\n                )\n                togif_proc = subprocess.Popen(\n                    togif_cmd,\n                    stdin=quant_proc.stdout,\n                    stdout=f,\n                    stderr=subprocess.DEVNULL,\n                )\n\n                # Allow ppmquant to receive SIGPIPE if ppmtogif exits\n                assert quant_proc.stdout is not None\n                quant_proc.stdout.close()\n\n                retcode = quant_proc.wait()\n                if retcode:\n                    raise subprocess.CalledProcessError(retcode, quant_cmd)\n\n                retcode = togif_proc.wait()\n                if retcode:\n                    raise subprocess.CalledProcessError(retcode, togif_cmd)\n    finally:\n        try:\n            os.unlink(tempfile)\n        except OSError:\n            pass\n\n\n# Force optimization so that we can test performance against\n# cases where it took lots of memory and time previously.\n_FORCE_OPTIMIZE = False\n\n\ndef _get_optimize(im: Image.Image, info: dict[str, Any]) -> list[int] | None:\n    \"\"\"\n    Palette optimization is a potentially expensive operation.\n\n    This function determines if the palette should be optimized using\n    some heuristics, then returns the list of palette entries in use.\n\n    :param im: Image object\n    :param info: encoderinfo\n    :returns: list of indexes of palette entries in use, or None\n    \"\"\"\n    if im.mode in (\"P\", \"L\") and info and info.get(\"optimize\"):\n        # Potentially expensive operation.\n\n        # The palette saves 3 bytes per color not used, but palette\n        # lengths are restricted to 3*(2**N) bytes. Max saving would\n        # be 768 -> 6 bytes if we went all the way down to 2 colors.\n        # * If we're over 128 colors, we can't save any space.\n        # * If there aren't any holes, it's not worth collapsing.\n        # * If we have a 'large' image, the palette is in the noise.\n\n        # create the new palette if not every color is used\n        optimise = _FORCE_OPTIMIZE or im.mode == \"L\"\n        if optimise or im.width * im.height < 512 * 512:\n            # check which colors are used\n            used_palette_colors = []\n            for i, count in enumerate(im.histogram()):\n                if count:\n                    used_palette_colors.append(i)\n\n            if optimise or max(used_palette_colors) >= len(used_palette_colors):\n                return used_palette_colors\n\n            num_palette_colors = len(im.palette.palette) // Image.getmodebands(\n                im.palette.mode\n            )\n            current_palette_size = 1 << (num_palette_colors - 1).bit_length()\n            if (\n                # check that the palette would become smaller when saved\n                len(used_palette_colors) <= current_palette_size // 2\n                # check that the palette is not already the smallest possible size\n                and current_palette_size > 2\n            ):\n                return used_palette_colors\n    return None\n\n\ndef _get_color_table_size(palette_bytes: bytes) -> int:\n    # calculate the palette size for the header\n    if not palette_bytes:\n        return 0\n    elif len(palette_bytes) < 9:\n        return 1\n    else:\n        return math.ceil(math.log(len(palette_bytes) // 3, 2)) - 1\n\n\ndef _get_header_palette(palette_bytes: bytes) -> bytes:\n    \"\"\"\n    Returns the palette, null padded to the next power of 2 (*3) bytes\n    suitable for direct inclusion in the GIF header\n\n    :param palette_bytes: Unpadded palette bytes, in RGBRGB form\n    :returns: Null padded palette\n    \"\"\"\n    color_table_size = _get_color_table_size(palette_bytes)\n\n    # add the missing amount of bytes\n    # the palette has to be 2<<n in size\n    actual_target_size_diff = (2 << color_table_size) - len(palette_bytes) // 3\n    if actual_target_size_diff > 0:\n        palette_bytes += o8(0) * 3 * actual_target_size_diff\n    return palette_bytes\n\n\ndef _get_palette_bytes(im: Image.Image) -> bytes:\n    \"\"\"\n    Gets the palette for inclusion in the gif header\n\n    :param im: Image object\n    :returns: Bytes, len<=768 suitable for inclusion in gif header\n    \"\"\"\n    return im.palette.palette if im.palette else b\"\"\n\n\ndef _get_background(\n    im: Image.Image,\n    info_background: int | tuple[int, int, int] | tuple[int, int, int, int] | None,\n) -> int:\n    background = 0\n    if info_background:\n        if isinstance(info_background, tuple):\n            # WebPImagePlugin stores an RGBA value in info[\"background\"]\n            # So it must be converted to the same format as GifImagePlugin's\n            # info[\"background\"] - a global color table index\n            try:\n                background = im.palette.getcolor(info_background, im)\n            except ValueError as e:\n                if str(e) not in (\n                    # If all 256 colors are in use,\n                    # then there is no need for the background color\n                    \"cannot allocate more than 256 colors\",\n                    # Ignore non-opaque WebP background\n                    \"cannot add non-opaque RGBA color to RGB palette\",\n                ):\n                    raise\n        else:\n            background = info_background\n    return background\n\n\ndef _get_global_header(im: Image.Image, info: dict[str, Any]) -> list[bytes]:\n    \"\"\"Return a list of strings representing a GIF header\"\"\"\n\n    # Header Block\n    # https://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp\n\n    version = b\"87a\"\n    if im.info.get(\"version\") == b\"89a\" or (\n        info\n        and (\n            \"transparency\" in info\n            or info.get(\"loop\") is not None\n            or info.get(\"duration\")\n            or info.get(\"comment\")\n        )\n    ):\n        version = b\"89a\"\n\n    background = _get_background(im, info.get(\"background\"))\n\n    palette_bytes = _get_palette_bytes(im)\n    color_table_size = _get_color_table_size(palette_bytes)\n\n    header = [\n        b\"GIF\"  # signature\n        + version  # version\n        + o16(im.size[0])  # canvas width\n        + o16(im.size[1]),  # canvas height\n        # Logical Screen Descriptor\n        # size of global color table + global color table flag\n        o8(color_table_size + 128),  # packed fields\n        # background + reserved/aspect\n        o8(background) + o8(0),\n        # Global Color Table\n        _get_header_palette(palette_bytes),\n    ]\n    if info.get(\"loop\") is not None:\n        header.append(\n            b\"!\"\n            + o8(255)  # extension intro\n            + o8(11)\n            + b\"NETSCAPE2.0\"\n            + o8(3)\n            + o8(1)\n            + o16(info[\"loop\"])  # number of loops\n            + o8(0)\n        )\n    if info.get(\"comment\"):\n        comment_block = b\"!\" + o8(254)  # extension intro\n\n        comment = info[\"comment\"]\n        if isinstance(comment, str):\n            comment = comment.encode()\n        for i in range(0, len(comment), 255):\n            subblock = comment[i : i + 255]\n            comment_block += o8(len(subblock)) + subblock\n\n        comment_block += o8(0)\n        header.append(comment_block)\n    return header\n\n\ndef _write_frame_data(\n    fp: IO[bytes],\n    im_frame: Image.Image,\n    offset: tuple[int, int],\n    params: dict[str, Any],\n) -> None:\n    try:\n        im_frame.encoderinfo = params\n\n        # local image header\n        _write_local_header(fp, im_frame, offset, 0)\n\n        ImageFile._save(\n            im_frame, fp, [(\"gif\", (0, 0) + im_frame.size, 0, RAWMODE[im_frame.mode])]\n        )\n\n        fp.write(b\"\\0\")  # end of image data\n    finally:\n        del im_frame.encoderinfo\n\n\n# --------------------------------------------------------------------\n# Legacy GIF utilities\n\n\ndef getheader(\n    im: Image.Image, palette: _Palette | None = None, info: dict[str, Any] | None = None\n) -> tuple[list[bytes], list[int] | None]:\n    \"\"\"\n    Legacy Method to get Gif data from image.\n\n    Warning:: May modify image data.\n\n    :param im: Image object\n    :param palette: bytes object containing the source palette, or ....\n    :param info: encoderinfo\n    :returns: tuple of(list of header items, optimized palette)\n\n    \"\"\"\n    if info is None:\n        info = {}\n\n    used_palette_colors = _get_optimize(im, info)\n\n    if \"background\" not in info and \"background\" in im.info:\n        info[\"background\"] = im.info[\"background\"]\n\n    im_mod = _normalize_palette(im, palette, info)\n    im.palette = im_mod.palette\n    im.im = im_mod.im\n    header = _get_global_header(im, info)\n\n    return header, used_palette_colors\n\n\ndef getdata(\n    im: Image.Image, offset: tuple[int, int] = (0, 0), **params: Any\n) -> list[bytes]:\n    \"\"\"\n    Legacy Method\n\n    Return a list of strings representing this image.\n    The first string is a local image header, the rest contains\n    encoded image data.\n\n    To specify duration, add the time in milliseconds,\n    e.g. ``getdata(im_frame, duration=1000)``\n\n    :param im: Image object\n    :param offset: Tuple of (x, y) pixels. Defaults to (0, 0)\n    :param \\\\**params: e.g. duration or other encoder info parameters\n    :returns: List of bytes containing GIF encoded frame data\n\n    \"\"\"\n    from io import BytesIO\n\n    class Collector(BytesIO):\n        data = []\n\n        if sys.version_info >= (3, 12):\n            from collections.abc import Buffer\n\n            def write(self, data: Buffer) -> int:\n                self.data.append(data)\n                return len(data)\n\n        else:\n\n            def write(self, data: Any) -> int:\n                self.data.append(data)\n                return len(data)\n\n    im.load()  # make sure raster data is available\n\n    fp = Collector()\n\n    _write_frame_data(fp, im, offset, params)\n\n    return fp.data\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(GifImageFile.format, GifImageFile, _accept)\nImage.register_save(GifImageFile.format, _save)\nImage.register_save_all(GifImageFile.format, _save_all)\nImage.register_extension(GifImageFile.format, \".gif\")\nImage.register_mime(GifImageFile.format, \"image/gif\")\n\n#\n# Uncomment the following line if you wish to use NETPBM/PBMPLUS\n# instead of the built-in \"uncompressed\" GIF encoder\n\n# Image.register_save(GifImageFile.format, _save_netpbm)\n", "src/PIL/FtexImagePlugin.py": "\"\"\"\nA Pillow loader for .ftc and .ftu files (FTEX)\nJerome Leclanche <jerome@leclan.ch>\n\nThe contents of this file are hereby released in the public domain (CC0)\nFull text of the CC0 license:\n  https://creativecommons.org/publicdomain/zero/1.0/\n\nIndependence War 2: Edge Of Chaos - Texture File Format - 16 October 2001\n\nThe textures used for 3D objects in Independence War 2: Edge Of Chaos are in a\npacked custom format called FTEX. This file format uses file extensions FTC\nand FTU.\n* FTC files are compressed textures (using standard texture compression).\n* FTU files are not compressed.\nTexture File Format\nThe FTC and FTU texture files both use the same format. This\nhas the following structure:\n{header}\n{format_directory}\n{data}\nWhere:\n{header} = {\n    u32:magic,\n    u32:version,\n    u32:width,\n    u32:height,\n    u32:mipmap_count,\n    u32:format_count\n}\n\n* The \"magic\" number is \"FTEX\".\n* \"width\" and \"height\" are the dimensions of the texture.\n* \"mipmap_count\" is the number of mipmaps in the texture.\n* \"format_count\" is the number of texture formats (different versions of the\nsame texture) in this file.\n\n{format_directory} = format_count * { u32:format, u32:where }\n\nThe format value is 0 for DXT1 compressed textures and 1 for 24-bit RGB\nuncompressed textures.\nThe texture data for a format starts at the position \"where\" in the file.\n\nEach set of texture data in the file has the following structure:\n{data} = format_count * { u32:mipmap_size, mipmap_size * { u8 } }\n* \"mipmap_size\" is the number of bytes in that mip level. For compressed\ntextures this is the size of the texture data compressed with DXT1. For 24 bit\nuncompressed textures, this is 3 * width * height. Following this are the image\nbytes for that mipmap level.\n\nNote: All data is stored in little-Endian (Intel) byte order.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport struct\nfrom enum import IntEnum\nfrom io import BytesIO\n\nfrom . import Image, ImageFile\n\nMAGIC = b\"FTEX\"\n\n\nclass Format(IntEnum):\n    DXT1 = 0\n    UNCOMPRESSED = 1\n\n\nclass FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(4)):\n            msg = \"not an FTEX file\"\n            raise SyntaxError(msg)\n        struct.unpack(\"<i\", self.fp.read(4))  # version\n        self._size = struct.unpack(\"<2i\", self.fp.read(8))\n        mipmap_count, format_count = struct.unpack(\"<2i\", self.fp.read(8))\n\n        self._mode = \"RGB\"\n\n        # Only support single-format files.\n        # I don't know of any multi-format file.\n        assert format_count == 1\n\n        format, where = struct.unpack(\"<2i\", self.fp.read(8))\n        self.fp.seek(where)\n        (mipmap_size,) = struct.unpack(\"<i\", self.fp.read(4))\n\n        data = self.fp.read(mipmap_size)\n\n        if format == Format.DXT1:\n            self._mode = \"RGBA\"\n            self.tile = [(\"bcn\", (0, 0) + self.size, 0, 1)]\n        elif format == Format.UNCOMPRESSED:\n            self.tile = [(\"raw\", (0, 0) + self.size, 0, (\"RGB\", 0, 1))]\n        else:\n            msg = f\"Invalid texture compression format: {repr(format)}\"\n            raise ValueError(msg)\n\n        self.fp.close()\n        self.fp = BytesIO(data)\n\n    def load_seek(self, pos: int) -> None:\n        pass\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == MAGIC\n\n\nImage.register_open(FtexImageFile.format, FtexImageFile, _accept)\nImage.register_extensions(FtexImageFile.format, [\".ftc\", \".ftu\"])\n", "src/PIL/BmpImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# BMP file handler\n#\n# Windows (and OS/2) native bitmap storage format.\n#\n# history:\n# 1995-09-01 fl   Created\n# 1996-04-30 fl   Added save\n# 1997-08-27 fl   Fixed save of 1-bit images\n# 1998-03-06 fl   Load P images as L where possible\n# 1998-07-03 fl   Load P images as 1 where possible\n# 1998-12-29 fl   Handle small palettes\n# 2002-12-30 fl   Fixed load of 1-bit palette images\n# 2003-04-21 fl   Fixed load of 1-bit monochrome images\n# 2003-04-23 fl   Added limited support for BI_BITFIELDS compression\n#\n# Copyright (c) 1997-2003 by Secret Labs AB\n# Copyright (c) 1995-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\nfrom ._binary import o8\nfrom ._binary import o16le as o16\nfrom ._binary import o32le as o32\n\n#\n# --------------------------------------------------------------------\n# Read BMP file\n\nBIT2MODE = {\n    # bits => mode, rawmode\n    1: (\"P\", \"P;1\"),\n    4: (\"P\", \"P;4\"),\n    8: (\"P\", \"P\"),\n    16: (\"RGB\", \"BGR;15\"),\n    24: (\"RGB\", \"BGR\"),\n    32: (\"RGB\", \"BGRX\"),\n}\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:2] == b\"BM\"\n\n\ndef _dib_accept(prefix: bytes) -> bool:\n    return i32(prefix) in [12, 40, 52, 56, 64, 108, 124]\n\n\n# =============================================================================\n# Image plugin for the Windows BMP format.\n# =============================================================================\nclass BmpImageFile(ImageFile.ImageFile):\n    \"\"\"Image plugin for the Windows Bitmap format (BMP)\"\"\"\n\n    # ------------------------------------------------------------- Description\n    format_description = \"Windows Bitmap\"\n    format = \"BMP\"\n\n    # -------------------------------------------------- BMP Compression values\n    COMPRESSIONS = {\"RAW\": 0, \"RLE8\": 1, \"RLE4\": 2, \"BITFIELDS\": 3, \"JPEG\": 4, \"PNG\": 5}\n    for k, v in COMPRESSIONS.items():\n        vars()[k] = v\n\n    def _bitmap(self, header=0, offset=0):\n        \"\"\"Read relevant info about the BMP\"\"\"\n        read, seek = self.fp.read, self.fp.seek\n        if header:\n            seek(header)\n        # read bmp header size @offset 14 (this is part of the header size)\n        file_info = {\"header_size\": i32(read(4)), \"direction\": -1}\n\n        # -------------------- If requested, read header at a specific position\n        # read the rest of the bmp header, without its size\n        header_data = ImageFile._safe_read(self.fp, file_info[\"header_size\"] - 4)\n\n        # ------------------------------- Windows Bitmap v2, IBM OS/2 Bitmap v1\n        # ----- This format has different offsets because of width/height types\n        # 12: BITMAPCOREHEADER/OS21XBITMAPHEADER\n        if file_info[\"header_size\"] == 12:\n            file_info[\"width\"] = i16(header_data, 0)\n            file_info[\"height\"] = i16(header_data, 2)\n            file_info[\"planes\"] = i16(header_data, 4)\n            file_info[\"bits\"] = i16(header_data, 6)\n            file_info[\"compression\"] = self.RAW\n            file_info[\"palette_padding\"] = 3\n\n        # --------------------------------------------- Windows Bitmap v3 to v5\n        #  40: BITMAPINFOHEADER\n        #  52: BITMAPV2HEADER\n        #  56: BITMAPV3HEADER\n        #  64: BITMAPCOREHEADER2/OS22XBITMAPHEADER\n        # 108: BITMAPV4HEADER\n        # 124: BITMAPV5HEADER\n        elif file_info[\"header_size\"] in (40, 52, 56, 64, 108, 124):\n            file_info[\"y_flip\"] = header_data[7] == 0xFF\n            file_info[\"direction\"] = 1 if file_info[\"y_flip\"] else -1\n            file_info[\"width\"] = i32(header_data, 0)\n            file_info[\"height\"] = (\n                i32(header_data, 4)\n                if not file_info[\"y_flip\"]\n                else 2**32 - i32(header_data, 4)\n            )\n            file_info[\"planes\"] = i16(header_data, 8)\n            file_info[\"bits\"] = i16(header_data, 10)\n            file_info[\"compression\"] = i32(header_data, 12)\n            # byte size of pixel data\n            file_info[\"data_size\"] = i32(header_data, 16)\n            file_info[\"pixels_per_meter\"] = (\n                i32(header_data, 20),\n                i32(header_data, 24),\n            )\n            file_info[\"colors\"] = i32(header_data, 28)\n            file_info[\"palette_padding\"] = 4\n            self.info[\"dpi\"] = tuple(x / 39.3701 for x in file_info[\"pixels_per_meter\"])\n            if file_info[\"compression\"] == self.BITFIELDS:\n                masks = [\"r_mask\", \"g_mask\", \"b_mask\"]\n                if len(header_data) >= 48:\n                    if len(header_data) >= 52:\n                        masks.append(\"a_mask\")\n                    else:\n                        file_info[\"a_mask\"] = 0x0\n                    for idx, mask in enumerate(masks):\n                        file_info[mask] = i32(header_data, 36 + idx * 4)\n                else:\n                    # 40 byte headers only have the three components in the\n                    # bitfields masks, ref:\n                    # https://msdn.microsoft.com/en-us/library/windows/desktop/dd183376(v=vs.85).aspx\n                    # See also\n                    # https://github.com/python-pillow/Pillow/issues/1293\n                    # There is a 4th component in the RGBQuad, in the alpha\n                    # location, but it is listed as a reserved component,\n                    # and it is not generally an alpha channel\n                    file_info[\"a_mask\"] = 0x0\n                    for mask in masks:\n                        file_info[mask] = i32(read(4))\n                file_info[\"rgb_mask\"] = (\n                    file_info[\"r_mask\"],\n                    file_info[\"g_mask\"],\n                    file_info[\"b_mask\"],\n                )\n                file_info[\"rgba_mask\"] = (\n                    file_info[\"r_mask\"],\n                    file_info[\"g_mask\"],\n                    file_info[\"b_mask\"],\n                    file_info[\"a_mask\"],\n                )\n        else:\n            msg = f\"Unsupported BMP header type ({file_info['header_size']})\"\n            raise OSError(msg)\n\n        # ------------------ Special case : header is reported 40, which\n        # ---------------------- is shorter than real size for bpp >= 16\n        self._size = file_info[\"width\"], file_info[\"height\"]\n\n        # ------- If color count was not found in the header, compute from bits\n        file_info[\"colors\"] = (\n            file_info[\"colors\"]\n            if file_info.get(\"colors\", 0)\n            else (1 << file_info[\"bits\"])\n        )\n        if offset == 14 + file_info[\"header_size\"] and file_info[\"bits\"] <= 8:\n            offset += 4 * file_info[\"colors\"]\n\n        # ---------------------- Check bit depth for unusual unsupported values\n        self._mode, raw_mode = BIT2MODE.get(file_info[\"bits\"], (None, None))\n        if self.mode is None:\n            msg = f\"Unsupported BMP pixel depth ({file_info['bits']})\"\n            raise OSError(msg)\n\n        # ---------------- Process BMP with Bitfields compression (not palette)\n        decoder_name = \"raw\"\n        if file_info[\"compression\"] == self.BITFIELDS:\n            SUPPORTED = {\n                32: [\n                    (0xFF0000, 0xFF00, 0xFF, 0x0),\n                    (0xFF000000, 0xFF0000, 0xFF00, 0x0),\n                    (0xFF000000, 0xFF00, 0xFF, 0x0),\n                    (0xFF000000, 0xFF0000, 0xFF00, 0xFF),\n                    (0xFF, 0xFF00, 0xFF0000, 0xFF000000),\n                    (0xFF0000, 0xFF00, 0xFF, 0xFF000000),\n                    (0xFF000000, 0xFF00, 0xFF, 0xFF0000),\n                    (0x0, 0x0, 0x0, 0x0),\n                ],\n                24: [(0xFF0000, 0xFF00, 0xFF)],\n                16: [(0xF800, 0x7E0, 0x1F), (0x7C00, 0x3E0, 0x1F)],\n            }\n            MASK_MODES = {\n                (32, (0xFF0000, 0xFF00, 0xFF, 0x0)): \"BGRX\",\n                (32, (0xFF000000, 0xFF0000, 0xFF00, 0x0)): \"XBGR\",\n                (32, (0xFF000000, 0xFF00, 0xFF, 0x0)): \"BGXR\",\n                (32, (0xFF000000, 0xFF0000, 0xFF00, 0xFF)): \"ABGR\",\n                (32, (0xFF, 0xFF00, 0xFF0000, 0xFF000000)): \"RGBA\",\n                (32, (0xFF0000, 0xFF00, 0xFF, 0xFF000000)): \"BGRA\",\n                (32, (0xFF000000, 0xFF00, 0xFF, 0xFF0000)): \"BGAR\",\n                (32, (0x0, 0x0, 0x0, 0x0)): \"BGRA\",\n                (24, (0xFF0000, 0xFF00, 0xFF)): \"BGR\",\n                (16, (0xF800, 0x7E0, 0x1F)): \"BGR;16\",\n                (16, (0x7C00, 0x3E0, 0x1F)): \"BGR;15\",\n            }\n            if file_info[\"bits\"] in SUPPORTED:\n                if (\n                    file_info[\"bits\"] == 32\n                    and file_info[\"rgba_mask\"] in SUPPORTED[file_info[\"bits\"]]\n                ):\n                    raw_mode = MASK_MODES[(file_info[\"bits\"], file_info[\"rgba_mask\"])]\n                    self._mode = \"RGBA\" if \"A\" in raw_mode else self.mode\n                elif (\n                    file_info[\"bits\"] in (24, 16)\n                    and file_info[\"rgb_mask\"] in SUPPORTED[file_info[\"bits\"]]\n                ):\n                    raw_mode = MASK_MODES[(file_info[\"bits\"], file_info[\"rgb_mask\"])]\n                else:\n                    msg = \"Unsupported BMP bitfields layout\"\n                    raise OSError(msg)\n            else:\n                msg = \"Unsupported BMP bitfields layout\"\n                raise OSError(msg)\n        elif file_info[\"compression\"] == self.RAW:\n            if file_info[\"bits\"] == 32 and header == 22:  # 32-bit .cur offset\n                raw_mode, self._mode = \"BGRA\", \"RGBA\"\n        elif file_info[\"compression\"] in (self.RLE8, self.RLE4):\n            decoder_name = \"bmp_rle\"\n        else:\n            msg = f\"Unsupported BMP compression ({file_info['compression']})\"\n            raise OSError(msg)\n\n        # --------------- Once the header is processed, process the palette/LUT\n        if self.mode == \"P\":  # Paletted for 1, 4 and 8 bit images\n            # ---------------------------------------------------- 1-bit images\n            if not (0 < file_info[\"colors\"] <= 65536):\n                msg = f\"Unsupported BMP Palette size ({file_info['colors']})\"\n                raise OSError(msg)\n            else:\n                padding = file_info[\"palette_padding\"]\n                palette = read(padding * file_info[\"colors\"])\n                grayscale = True\n                indices = (\n                    (0, 255)\n                    if file_info[\"colors\"] == 2\n                    else list(range(file_info[\"colors\"]))\n                )\n\n                # ----------------- Check if grayscale and ignore palette if so\n                for ind, val in enumerate(indices):\n                    rgb = palette[ind * padding : ind * padding + 3]\n                    if rgb != o8(val) * 3:\n                        grayscale = False\n\n                # ------- If all colors are gray, white or black, ditch palette\n                if grayscale:\n                    self._mode = \"1\" if file_info[\"colors\"] == 2 else \"L\"\n                    raw_mode = self.mode\n                else:\n                    self._mode = \"P\"\n                    self.palette = ImagePalette.raw(\n                        \"BGRX\" if padding == 4 else \"BGR\", palette\n                    )\n\n        # ---------------------------- Finally set the tile data for the plugin\n        self.info[\"compression\"] = file_info[\"compression\"]\n        args = [raw_mode]\n        if decoder_name == \"bmp_rle\":\n            args.append(file_info[\"compression\"] == self.RLE4)\n        else:\n            args.append(((file_info[\"width\"] * file_info[\"bits\"] + 31) >> 3) & (~3))\n        args.append(file_info[\"direction\"])\n        self.tile = [\n            (\n                decoder_name,\n                (0, 0, file_info[\"width\"], file_info[\"height\"]),\n                offset or self.fp.tell(),\n                tuple(args),\n            )\n        ]\n\n    def _open(self) -> None:\n        \"\"\"Open file, check magic number and read header\"\"\"\n        # read 14 bytes: magic number, filesize, reserved, header final offset\n        head_data = self.fp.read(14)\n        # choke if the file does not have the required magic bytes\n        if not _accept(head_data):\n            msg = \"Not a BMP file\"\n            raise SyntaxError(msg)\n        # read the start position of the BMP image data (u32)\n        offset = i32(head_data, 10)\n        # load bitmap information (offset=raster info)\n        self._bitmap(offset=offset)\n\n\nclass BmpRleDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        rle4 = self.args[1]\n        data = bytearray()\n        x = 0\n        dest_length = self.state.xsize * self.state.ysize\n        while len(data) < dest_length:\n            pixels = self.fd.read(1)\n            byte = self.fd.read(1)\n            if not pixels or not byte:\n                break\n            num_pixels = pixels[0]\n            if num_pixels:\n                # encoded mode\n                if x + num_pixels > self.state.xsize:\n                    # Too much data for row\n                    num_pixels = max(0, self.state.xsize - x)\n                if rle4:\n                    first_pixel = o8(byte[0] >> 4)\n                    second_pixel = o8(byte[0] & 0x0F)\n                    for index in range(num_pixels):\n                        if index % 2 == 0:\n                            data += first_pixel\n                        else:\n                            data += second_pixel\n                else:\n                    data += byte * num_pixels\n                x += num_pixels\n            else:\n                if byte[0] == 0:\n                    # end of line\n                    while len(data) % self.state.xsize != 0:\n                        data += b\"\\x00\"\n                    x = 0\n                elif byte[0] == 1:\n                    # end of bitmap\n                    break\n                elif byte[0] == 2:\n                    # delta\n                    bytes_read = self.fd.read(2)\n                    if len(bytes_read) < 2:\n                        break\n                    right, up = self.fd.read(2)\n                    data += b\"\\x00\" * (right + up * self.state.xsize)\n                    x = len(data) % self.state.xsize\n                else:\n                    # absolute mode\n                    if rle4:\n                        # 2 pixels per byte\n                        byte_count = byte[0] // 2\n                        bytes_read = self.fd.read(byte_count)\n                        for byte_read in bytes_read:\n                            data += o8(byte_read >> 4)\n                            data += o8(byte_read & 0x0F)\n                    else:\n                        byte_count = byte[0]\n                        bytes_read = self.fd.read(byte_count)\n                        data += bytes_read\n                    if len(bytes_read) < byte_count:\n                        break\n                    x += byte[0]\n\n                    # align to 16-bit word boundary\n                    if self.fd.tell() % 2 != 0:\n                        self.fd.seek(1, os.SEEK_CUR)\n        rawmode = \"L\" if self.mode == \"L\" else \"P\"\n        self.set_as_raw(bytes(data), (rawmode, 0, self.args[-1]))\n        return -1, 0\n\n\n# =============================================================================\n# Image plugin for the DIB format (BMP alias)\n# =============================================================================\nclass DibImageFile(BmpImageFile):\n    format = \"DIB\"\n    format_description = \"Windows Bitmap\"\n\n    def _open(self) -> None:\n        self._bitmap()\n\n\n#\n# --------------------------------------------------------------------\n# Write BMP file\n\n\nSAVE = {\n    \"1\": (\"1\", 1, 2),\n    \"L\": (\"L\", 8, 256),\n    \"P\": (\"P\", 8, 256),\n    \"RGB\": (\"BGR\", 24, 0),\n    \"RGBA\": (\"BGRA\", 32, 0),\n}\n\n\ndef _dib_save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, False)\n\n\ndef _save(\n    im: Image.Image, fp: IO[bytes], filename: str | bytes, bitmap_header: bool = True\n) -> None:\n    try:\n        rawmode, bits, colors = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as BMP\"\n        raise OSError(msg) from e\n\n    info = im.encoderinfo\n\n    dpi = info.get(\"dpi\", (96, 96))\n\n    # 1 meter == 39.3701 inches\n    ppm = tuple(int(x * 39.3701 + 0.5) for x in dpi)\n\n    stride = ((im.size[0] * bits + 7) // 8 + 3) & (~3)\n    header = 40  # or 64 for OS/2 version 2\n    image = stride * im.size[1]\n\n    if im.mode == \"1\":\n        palette = b\"\".join(o8(i) * 4 for i in (0, 255))\n    elif im.mode == \"L\":\n        palette = b\"\".join(o8(i) * 4 for i in range(256))\n    elif im.mode == \"P\":\n        palette = im.im.getpalette(\"RGB\", \"BGRX\")\n        colors = len(palette) // 4\n    else:\n        palette = None\n\n    # bitmap header\n    if bitmap_header:\n        offset = 14 + header + colors * 4\n        file_size = offset + image\n        if file_size > 2**32 - 1:\n            msg = \"File size is too large for the BMP format\"\n            raise ValueError(msg)\n        fp.write(\n            b\"BM\"  # file type (magic)\n            + o32(file_size)  # file size\n            + o32(0)  # reserved\n            + o32(offset)  # image data offset\n        )\n\n    # bitmap info header\n    fp.write(\n        o32(header)  # info header size\n        + o32(im.size[0])  # width\n        + o32(im.size[1])  # height\n        + o16(1)  # planes\n        + o16(bits)  # depth\n        + o32(0)  # compression (0=uncompressed)\n        + o32(image)  # size of bitmap\n        + o32(ppm[0])  # resolution\n        + o32(ppm[1])  # resolution\n        + o32(colors)  # colors used\n        + o32(colors)  # colors important\n    )\n\n    fp.write(b\"\\0\" * (header - 40))  # padding (for OS/2 format)\n\n    if palette:\n        fp.write(palette)\n\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, stride, -1))])\n\n\n#\n# --------------------------------------------------------------------\n# Registry\n\n\nImage.register_open(BmpImageFile.format, BmpImageFile, _accept)\nImage.register_save(BmpImageFile.format, _save)\n\nImage.register_extension(BmpImageFile.format, \".bmp\")\n\nImage.register_mime(BmpImageFile.format, \"image/bmp\")\n\nImage.register_decoder(\"bmp_rle\", BmpRleDecoder)\n\nImage.register_open(DibImageFile.format, DibImageFile, _dib_accept)\nImage.register_save(DibImageFile.format, _dib_save)\n\nImage.register_extension(DibImageFile.format, \".dib\")\n\nImage.register_mime(DibImageFile.format, \"image/bmp\")\n", "src/PIL/_version.py": "# Master version for Pillow\nfrom __future__ import annotations\n\n__version__ = \"10.4.0.dev0\"\n", "src/PIL/PyAccess.py": "#\n# The Python Imaging Library\n# Pillow fork\n#\n# Python implementation of the PixelAccess Object\n#\n# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-2009 by Fredrik Lundh.\n# Copyright (c) 2013 Eric Soroos\n#\n# See the README file for information on usage and redistribution\n#\n\n# Notes:\n#\n#  * Implements the pixel access object following Access.c\n#  * Taking only the tuple form, which is used from python.\n#    * Fill.c uses the integer form, but it's still going to use the old\n#      Access.c implementation.\n#\nfrom __future__ import annotations\n\nimport logging\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom ._deprecate import deprecate\n\nFFI: type\ntry:\n    from cffi import FFI\n\n    defs = \"\"\"\n    struct Pixel_RGBA {\n        unsigned char r,g,b,a;\n    };\n    struct Pixel_I16 {\n        unsigned char l,r;\n    };\n    \"\"\"\n    ffi = FFI()\n    ffi.cdef(defs)\nexcept ImportError as ex:\n    # Allow error import for doc purposes, but error out when accessing\n    # anything in core.\n    from ._util import DeferredError\n\n    FFI = ffi = DeferredError.new(ex)\n\nlogger = logging.getLogger(__name__)\n\nif TYPE_CHECKING:\n    from . import Image\n\n\nclass PyAccess:\n    def __init__(self, img: Image.Image, readonly: bool = False) -> None:\n        deprecate(\"PyAccess\", 11)\n        vals = dict(img.im.unsafe_ptrs)\n        self.readonly = readonly\n        self.image8 = ffi.cast(\"unsigned char **\", vals[\"image8\"])\n        self.image32 = ffi.cast(\"int **\", vals[\"image32\"])\n        self.image = ffi.cast(\"unsigned char **\", vals[\"image\"])\n        self.xsize, self.ysize = img.im.size\n        self._img = img\n\n        # Keep pointer to im object to prevent dereferencing.\n        self._im = img.im\n        if self._im.mode in (\"P\", \"PA\"):\n            self._palette = img.palette\n\n        # Debugging is polluting test traces, only useful here\n        # when hacking on PyAccess\n        # logger.debug(\"%s\", vals)\n        self._post_init()\n\n    def _post_init(self) -> None:\n        pass\n\n    def __setitem__(self, xy, color):\n        \"\"\"\n        Modifies the pixel at x,y. The color is given as a single\n        numerical value for single band images, and a tuple for\n        multi-band images. In addition to this, RGB and RGBA tuples\n        are accepted for P and PA images.\n\n        :param xy: The pixel coordinate, given as (x, y). See\n           :ref:`coordinate-system`.\n        :param color: The pixel value.\n        \"\"\"\n        if self.readonly:\n            msg = \"Attempt to putpixel a read only image\"\n            raise ValueError(msg)\n        (x, y) = xy\n        if x < 0:\n            x = self.xsize + x\n        if y < 0:\n            y = self.ysize + y\n        (x, y) = self.check_xy((x, y))\n\n        if (\n            self._im.mode in (\"P\", \"PA\")\n            and isinstance(color, (list, tuple))\n            and len(color) in [3, 4]\n        ):\n            # RGB or RGBA value for a P or PA image\n            if self._im.mode == \"PA\":\n                alpha = color[3] if len(color) == 4 else 255\n                color = color[:3]\n            color = self._palette.getcolor(color, self._img)\n            if self._im.mode == \"PA\":\n                color = (color, alpha)\n\n        return self.set_pixel(x, y, color)\n\n    def __getitem__(self, xy: tuple[int, int]) -> float | tuple[int, ...]:\n        \"\"\"\n        Returns the pixel at x,y. The pixel is returned as a single\n        value for single band images or a tuple for multiple band\n        images\n\n        :param xy: The pixel coordinate, given as (x, y). See\n          :ref:`coordinate-system`.\n        :returns: a pixel value for single band images, a tuple of\n          pixel values for multiband images.\n        \"\"\"\n        (x, y) = xy\n        if x < 0:\n            x = self.xsize + x\n        if y < 0:\n            y = self.ysize + y\n        (x, y) = self.check_xy((x, y))\n        return self.get_pixel(x, y)\n\n    putpixel = __setitem__\n    getpixel = __getitem__\n\n    def check_xy(self, xy: tuple[int, int]) -> tuple[int, int]:\n        (x, y) = xy\n        if not (0 <= x < self.xsize and 0 <= y < self.ysize):\n            msg = \"pixel location out of range\"\n            raise ValueError(msg)\n        return xy\n\n    def get_pixel(self, x: int, y: int) -> float | tuple[int, ...]:\n        raise NotImplementedError()\n\n    def set_pixel(self, x: int, y: int, color: float | tuple[int, ...]) -> None:\n        raise NotImplementedError()\n\n\nclass _PyAccess32_2(PyAccess):\n    \"\"\"PA, LA, stored in first and last bytes of a 32 bit word\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> tuple[int, int]:\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.a\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple\n        pixel.r = min(color[0], 255)\n        pixel.a = min(color[1], 255)\n\n\nclass _PyAccess32_3(PyAccess):\n    \"\"\"RGB and friends, stored in the first three bytes of a 32 bit word\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> tuple[int, int, int]:\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.g, pixel.b\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple\n        pixel.r = min(color[0], 255)\n        pixel.g = min(color[1], 255)\n        pixel.b = min(color[2], 255)\n        pixel.a = 255\n\n\nclass _PyAccess32_4(PyAccess):\n    \"\"\"RGBA etc, all 4 bytes of a 32 bit word\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> tuple[int, int, int, int]:\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.g, pixel.b, pixel.a\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple\n        pixel.r = min(color[0], 255)\n        pixel.g = min(color[1], 255)\n        pixel.b = min(color[2], 255)\n        pixel.a = min(color[3], 255)\n\n\nclass _PyAccess8(PyAccess):\n    \"\"\"1, L, P, 8 bit images stored as uint8\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image8\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 255)\n        except TypeError:\n            # tuple\n            self.pixels[y][x] = min(color[0], 255)\n\n\nclass _PyAccessI16_N(PyAccess):\n    \"\"\"I;16 access, native bitendian without conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"unsigned short **\", self.image)\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 65535)\n        except TypeError:\n            # tuple\n            self.pixels[y][x] = min(color[0], 65535)\n\n\nclass _PyAccessI16_L(PyAccess):\n    \"\"\"I;16L access, with conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n\n    def get_pixel(self, x: int, y: int) -> int:\n        pixel = self.pixels[y][x]\n        return pixel.l + pixel.r * 256\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:\n            color = min(color, 65535)\n        except TypeError:\n            color = min(color[0], 65535)\n\n        pixel.l = color & 0xFF\n        pixel.r = color >> 8\n\n\nclass _PyAccessI16_B(PyAccess):\n    \"\"\"I;16B access, with conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n\n    def get_pixel(self, x: int, y: int) -> int:\n        pixel = self.pixels[y][x]\n        return pixel.l * 256 + pixel.r\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:\n            color = min(color, 65535)\n        except Exception:\n            color = min(color[0], 65535)\n\n        pixel.l = color >> 8\n        pixel.r = color & 0xFF\n\n\nclass _PyAccessI32_N(PyAccess):\n    \"\"\"Signed Int32 access, native endian\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        self.pixels[y][x] = color\n\n\nclass _PyAccessI32_Swap(PyAccess):\n    \"\"\"I;32L/B access, with byteswapping conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n\n    def reverse(self, i):\n        orig = ffi.new(\"int *\", i)\n        chars = ffi.cast(\"unsigned char *\", orig)\n        chars[0], chars[1], chars[2], chars[3] = chars[3], chars[2], chars[1], chars[0]\n        return ffi.cast(\"int *\", chars)[0]\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.reverse(self.pixels[y][x])\n\n    def set_pixel(self, x, y, color):\n        self.pixels[y][x] = self.reverse(color)\n\n\nclass _PyAccessF(PyAccess):\n    \"\"\"32 bit float access\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"float **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> float:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        try:\n            # not a tuple\n            self.pixels[y][x] = color\n        except TypeError:\n            # tuple\n            self.pixels[y][x] = color[0]\n\n\nmode_map = {\n    \"1\": _PyAccess8,\n    \"L\": _PyAccess8,\n    \"P\": _PyAccess8,\n    \"I;16N\": _PyAccessI16_N,\n    \"LA\": _PyAccess32_2,\n    \"La\": _PyAccess32_2,\n    \"PA\": _PyAccess32_2,\n    \"RGB\": _PyAccess32_3,\n    \"LAB\": _PyAccess32_3,\n    \"HSV\": _PyAccess32_3,\n    \"YCbCr\": _PyAccess32_3,\n    \"RGBA\": _PyAccess32_4,\n    \"RGBa\": _PyAccess32_4,\n    \"RGBX\": _PyAccess32_4,\n    \"CMYK\": _PyAccess32_4,\n    \"F\": _PyAccessF,\n    \"I\": _PyAccessI32_N,\n}\n\nif sys.byteorder == \"little\":\n    mode_map[\"I;16\"] = _PyAccessI16_N\n    mode_map[\"I;16L\"] = _PyAccessI16_N\n    mode_map[\"I;16B\"] = _PyAccessI16_B\n\n    mode_map[\"I;32L\"] = _PyAccessI32_N\n    mode_map[\"I;32B\"] = _PyAccessI32_Swap\nelse:\n    mode_map[\"I;16\"] = _PyAccessI16_L\n    mode_map[\"I;16L\"] = _PyAccessI16_L\n    mode_map[\"I;16B\"] = _PyAccessI16_N\n\n    mode_map[\"I;32L\"] = _PyAccessI32_Swap\n    mode_map[\"I;32B\"] = _PyAccessI32_N\n\n\ndef new(img: Image.Image, readonly: bool = False) -> PyAccess | None:\n    access_type = mode_map.get(img.mode, None)\n    if not access_type:\n        logger.debug(\"PyAccess Not Implemented: %s\", img.mode)\n        return None\n    return access_type(img, readonly)\n", "src/PIL/PpmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PPM support for PIL\n#\n# History:\n#       96-03-24 fl     Created\n#       98-03-06 fl     Write RGBA images (as RGB, that is)\n#\n# Copyright (c) Secret Labs AB 1997-98.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport math\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import o8\nfrom ._binary import o32le as o32\n\n#\n# --------------------------------------------------------------------\n\nb_whitespace = b\"\\x20\\x09\\x0a\\x0b\\x0c\\x0d\"\n\nMODES = {\n    # standard\n    b\"P1\": \"1\",\n    b\"P2\": \"L\",\n    b\"P3\": \"RGB\",\n    b\"P4\": \"1\",\n    b\"P5\": \"L\",\n    b\"P6\": \"RGB\",\n    # extensions\n    b\"P0CMYK\": \"CMYK\",\n    b\"Pf\": \"F\",\n    # PIL extensions (for test purposes only)\n    b\"PyP\": \"P\",\n    b\"PyRGBA\": \"RGBA\",\n    b\"PyCMYK\": \"CMYK\",\n}\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[0:1] == b\"P\" and prefix[1] in b\"0123456fy\"\n\n\n##\n# Image plugin for PBM, PGM, and PPM images.\n\n\nclass PpmImageFile(ImageFile.ImageFile):\n    format = \"PPM\"\n    format_description = \"Pbmplus image\"\n\n    def _read_magic(self) -> bytes:\n        assert self.fp is not None\n\n        magic = b\"\"\n        # read until whitespace or longest available magic number\n        for _ in range(6):\n            c = self.fp.read(1)\n            if not c or c in b_whitespace:\n                break\n            magic += c\n        return magic\n\n    def _read_token(self) -> bytes:\n        assert self.fp is not None\n\n        token = b\"\"\n        while len(token) <= 10:  # read until next whitespace or limit of 10 characters\n            c = self.fp.read(1)\n            if not c:\n                break\n            elif c in b_whitespace:  # token ended\n                if not token:\n                    # skip whitespace at start\n                    continue\n                break\n            elif c == b\"#\":\n                # ignores rest of the line; stops at CR, LF or EOF\n                while self.fp.read(1) not in b\"\\r\\n\":\n                    pass\n                continue\n            token += c\n        if not token:\n            # Token was not even 1 byte\n            msg = \"Reached EOF while reading header\"\n            raise ValueError(msg)\n        elif len(token) > 10:\n            msg = f\"Token too long in file header: {token.decode()}\"\n            raise ValueError(msg)\n        return token\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        magic_number = self._read_magic()\n        try:\n            mode = MODES[magic_number]\n        except KeyError:\n            msg = \"not a PPM file\"\n            raise SyntaxError(msg)\n        self._mode = mode\n\n        if magic_number in (b\"P1\", b\"P4\"):\n            self.custom_mimetype = \"image/x-portable-bitmap\"\n        elif magic_number in (b\"P2\", b\"P5\"):\n            self.custom_mimetype = \"image/x-portable-graymap\"\n        elif magic_number in (b\"P3\", b\"P6\"):\n            self.custom_mimetype = \"image/x-portable-pixmap\"\n\n        self._size = int(self._read_token()), int(self._read_token())\n\n        decoder_name = \"raw\"\n        if magic_number in (b\"P1\", b\"P2\", b\"P3\"):\n            decoder_name = \"ppm_plain\"\n\n        args: str | tuple[str | int, ...]\n        if mode == \"1\":\n            args = \"1;I\"\n        elif mode == \"F\":\n            scale = float(self._read_token())\n            if scale == 0.0 or not math.isfinite(scale):\n                msg = \"scale must be finite and non-zero\"\n                raise ValueError(msg)\n            self.info[\"scale\"] = abs(scale)\n\n            rawmode = \"F;32F\" if scale < 0 else \"F;32BF\"\n            args = (rawmode, 0, -1)\n        else:\n            maxval = int(self._read_token())\n            if not 0 < maxval < 65536:\n                msg = \"maxval must be greater than 0 and less than 65536\"\n                raise ValueError(msg)\n            if maxval > 255 and mode == \"L\":\n                self._mode = \"I\"\n\n            rawmode = mode\n            if decoder_name != \"ppm_plain\":\n                # If maxval matches a bit depth, use the raw decoder directly\n                if maxval == 65535 and mode == \"L\":\n                    rawmode = \"I;16B\"\n                elif maxval != 255:\n                    decoder_name = \"ppm\"\n\n            args = rawmode if decoder_name == \"raw\" else (rawmode, maxval)\n        self.tile = [(decoder_name, (0, 0) + self.size, self.fp.tell(), args)]\n\n\n#\n# --------------------------------------------------------------------\n\n\nclass PpmPlainDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    _comment_spans: bool\n\n    def _read_block(self) -> bytes:\n        assert self.fd is not None\n\n        return self.fd.read(ImageFile.SAFEBLOCK)\n\n    def _find_comment_end(self, block: bytes, start: int = 0) -> int:\n        a = block.find(b\"\\n\", start)\n        b = block.find(b\"\\r\", start)\n        return min(a, b) if a * b > 0 else max(a, b)  # lowest nonnegative index (or -1)\n\n    def _ignore_comments(self, block: bytes) -> bytes:\n        if self._comment_spans:\n            # Finish current comment\n            while block:\n                comment_end = self._find_comment_end(block)\n                if comment_end != -1:\n                    # Comment ends in this block\n                    # Delete tail of comment\n                    block = block[comment_end + 1 :]\n                    break\n                else:\n                    # Comment spans whole block\n                    # So read the next block, looking for the end\n                    block = self._read_block()\n\n        # Search for any further comments\n        self._comment_spans = False\n        while True:\n            comment_start = block.find(b\"#\")\n            if comment_start == -1:\n                # No comment found\n                break\n            comment_end = self._find_comment_end(block, comment_start)\n            if comment_end != -1:\n                # Comment ends in this block\n                # Delete comment\n                block = block[:comment_start] + block[comment_end + 1 :]\n            else:\n                # Comment continues to next block(s)\n                block = block[:comment_start]\n                self._comment_spans = True\n                break\n        return block\n\n    def _decode_bitonal(self) -> bytearray:\n        \"\"\"\n        This is a separate method because in the plain PBM format, all data tokens are\n        exactly one byte, so the inter-token whitespace is optional.\n        \"\"\"\n        data = bytearray()\n        total_bytes = self.state.xsize * self.state.ysize\n\n        while len(data) != total_bytes:\n            block = self._read_block()  # read next block\n            if not block:\n                # eof\n                break\n\n            block = self._ignore_comments(block)\n\n            tokens = b\"\".join(block.split())\n            for token in tokens:\n                if token not in (48, 49):\n                    msg = b\"Invalid token for this mode: %s\" % bytes([token])\n                    raise ValueError(msg)\n            data = (data + tokens)[:total_bytes]\n        invert = bytes.maketrans(b\"01\", b\"\\xFF\\x00\")\n        return data.translate(invert)\n\n    def _decode_blocks(self, maxval: int) -> bytearray:\n        data = bytearray()\n        max_len = 10\n        out_byte_count = 4 if self.mode == \"I\" else 1\n        out_max = 65535 if self.mode == \"I\" else 255\n        bands = Image.getmodebands(self.mode)\n        total_bytes = self.state.xsize * self.state.ysize * bands * out_byte_count\n\n        half_token = b\"\"\n        while len(data) != total_bytes:\n            block = self._read_block()  # read next block\n            if not block:\n                if half_token:\n                    block = bytearray(b\" \")  # flush half_token\n                else:\n                    # eof\n                    break\n\n            block = self._ignore_comments(block)\n\n            if half_token:\n                block = half_token + block  # stitch half_token to new block\n                half_token = b\"\"\n\n            tokens = block.split()\n\n            if block and not block[-1:].isspace():  # block might split token\n                half_token = tokens.pop()  # save half token for later\n                if len(half_token) > max_len:  # prevent buildup of half_token\n                    msg = (\n                        b\"Token too long found in data: %s\" % half_token[: max_len + 1]\n                    )\n                    raise ValueError(msg)\n\n            for token in tokens:\n                if len(token) > max_len:\n                    msg = b\"Token too long found in data: %s\" % token[: max_len + 1]\n                    raise ValueError(msg)\n                value = int(token)\n                if value < 0:\n                    msg_str = f\"Channel value is negative: {value}\"\n                    raise ValueError(msg_str)\n                if value > maxval:\n                    msg_str = f\"Channel value too large for this mode: {value}\"\n                    raise ValueError(msg_str)\n                value = round(value / maxval * out_max)\n                data += o32(value) if self.mode == \"I\" else o8(value)\n                if len(data) == total_bytes:  # finished!\n                    break\n        return data\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        self._comment_spans = False\n        if self.mode == \"1\":\n            data = self._decode_bitonal()\n            rawmode = \"1;8\"\n        else:\n            maxval = self.args[-1]\n            data = self._decode_blocks(maxval)\n            rawmode = \"I;32\" if self.mode == \"I\" else self.mode\n        self.set_as_raw(bytes(data), rawmode)\n        return -1, 0\n\n\nclass PpmDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n\n        data = bytearray()\n        maxval = self.args[-1]\n        in_byte_count = 1 if maxval < 256 else 2\n        out_byte_count = 4 if self.mode == \"I\" else 1\n        out_max = 65535 if self.mode == \"I\" else 255\n        bands = Image.getmodebands(self.mode)\n        dest_length = self.state.xsize * self.state.ysize * bands * out_byte_count\n        while len(data) < dest_length:\n            pixels = self.fd.read(in_byte_count * bands)\n            if len(pixels) < in_byte_count * bands:\n                # eof\n                break\n            for b in range(bands):\n                value = (\n                    pixels[b] if in_byte_count == 1 else i16(pixels, b * in_byte_count)\n                )\n                value = min(out_max, round(value / maxval * out_max))\n                data += o32(value) if self.mode == \"I\" else o8(value)\n        rawmode = \"I;32\" if self.mode == \"I\" else self.mode\n        self.set_as_raw(bytes(data), rawmode)\n        return -1, 0\n\n\n#\n# --------------------------------------------------------------------\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode == \"1\":\n        rawmode, head = \"1;I\", b\"P4\"\n    elif im.mode == \"L\":\n        rawmode, head = \"L\", b\"P5\"\n    elif im.mode == \"I\":\n        rawmode, head = \"I;16B\", b\"P5\"\n    elif im.mode in (\"RGB\", \"RGBA\"):\n        rawmode, head = \"RGB\", b\"P6\"\n    elif im.mode == \"F\":\n        rawmode, head = \"F;32F\", b\"Pf\"\n    else:\n        msg = f\"cannot write mode {im.mode} as PPM\"\n        raise OSError(msg)\n    fp.write(head + b\"\\n%d %d\\n\" % im.size)\n    if head == b\"P6\":\n        fp.write(b\"255\\n\")\n    elif head == b\"P5\":\n        if rawmode == \"L\":\n            fp.write(b\"255\\n\")\n        else:\n            fp.write(b\"65535\\n\")\n    elif head == b\"Pf\":\n        fp.write(b\"-1.0\\n\")\n    row_order = -1 if im.mode == \"F\" else 1\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, row_order))])\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_open(PpmImageFile.format, PpmImageFile, _accept)\nImage.register_save(PpmImageFile.format, _save)\n\nImage.register_decoder(\"ppm\", PpmDecoder)\nImage.register_decoder(\"ppm_plain\", PpmPlainDecoder)\n\nImage.register_extensions(PpmImageFile.format, [\".pbm\", \".pgm\", \".ppm\", \".pnm\", \".pfm\"])\n\nImage.register_mime(PpmImageFile.format, \"image/x-portable-anymap\")\n", "src/PIL/PngImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PNG support code\n#\n# See \"PNG (Portable Network Graphics) Specification, version 1.0;\n# W3C Recommendation\", 1996-10-01, Thomas Boutell (ed.).\n#\n# history:\n# 1996-05-06 fl   Created (couldn't resist it)\n# 1996-12-14 fl   Upgraded, added read and verify support (0.2)\n# 1996-12-15 fl   Separate PNG stream parser\n# 1996-12-29 fl   Added write support, added getchunks\n# 1996-12-30 fl   Eliminated circular references in decoder (0.3)\n# 1998-07-12 fl   Read/write 16-bit images as mode I (0.4)\n# 2001-02-08 fl   Added transparency support (from Zircon) (0.5)\n# 2001-04-16 fl   Don't close data source in \"open\" method (0.6)\n# 2004-02-24 fl   Don't even pretend to support interlaced files (0.7)\n# 2004-08-31 fl   Do basic sanity check on chunk identifiers (0.8)\n# 2004-09-20 fl   Added PngInfo chunk container\n# 2004-12-18 fl   Added DPI read support (based on code by Niki Spahiev)\n# 2008-08-13 fl   Added tRNS support for RGB images\n# 2009-03-06 fl   Support for preserving ICC profiles (by Florian Hoech)\n# 2009-03-08 fl   Added zTXT support (from Lowell Alleman)\n# 2009-03-29 fl   Read interlaced PNG files (from Conrado Porto Lopes Gouvua)\n#\n# Copyright (c) 1997-2009 by Secret Labs AB\n# Copyright (c) 1996 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport itertools\nimport logging\nimport re\nimport struct\nimport warnings\nimport zlib\nfrom enum import IntEnum\nfrom typing import IO, TYPE_CHECKING, Any, NoReturn\n\nfrom . import Image, ImageChops, ImageFile, ImagePalette, ImageSequence\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import o8\nfrom ._binary import o16be as o16\nfrom ._binary import o32be as o32\n\nif TYPE_CHECKING:\n    from . import _imaging\n\nlogger = logging.getLogger(__name__)\n\nis_cid = re.compile(rb\"\\w\\w\\w\\w\").match\n\n\n_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n\n\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Grayscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I;16\", \"I;16B\"),\n    # Truecolour\n    (8, 2): (\"RGB\", \"RGB\"),\n    (16, 2): (\"RGB\", \"RGB;16B\"),\n    # Indexed-colour\n    (1, 3): (\"P\", \"P;1\"),\n    (2, 3): (\"P\", \"P;2\"),\n    (4, 3): (\"P\", \"P;4\"),\n    (8, 3): (\"P\", \"P\"),\n    # Grayscale with alpha\n    (8, 4): (\"LA\", \"LA\"),\n    (16, 4): (\"RGBA\", \"LA;16B\"),  # LA;16B->LA not yet available\n    # Truecolour with alpha\n    (8, 6): (\"RGBA\", \"RGBA\"),\n    (16, 6): (\"RGBA\", \"RGBA;16B\"),\n}\n\n\n_simple_palette = re.compile(b\"^\\xff*\\x00\\xff*$\")\n\nMAX_TEXT_CHUNK = ImageFile.SAFEBLOCK\n\"\"\"\nMaximum decompressed size for a iTXt or zTXt chunk.\nEliminates decompression bombs where compressed chunks can expand 1000x.\nSee :ref:`Text in PNG File Format<png-text>`.\n\"\"\"\nMAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\n\"\"\"\nSet the maximum total text chunk size.\nSee :ref:`Text in PNG File Format<png-text>`.\n\"\"\"\n\n\n# APNG frame disposal modes\nclass Disposal(IntEnum):\n    OP_NONE = 0\n    \"\"\"\n    No disposal is done on this frame before rendering the next frame.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_BACKGROUND = 1\n    \"\"\"\n    This frame\u2019s modified region is cleared to fully transparent black before rendering\n    the next frame.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_PREVIOUS = 2\n    \"\"\"\n    This frame\u2019s modified region is reverted to the previous frame\u2019s contents before\n    rendering the next frame.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n\n\n# APNG frame blend modes\nclass Blend(IntEnum):\n    OP_SOURCE = 0\n    \"\"\"\n    All color components of this frame, including alpha, overwrite the previous output\n    image contents.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_OVER = 1\n    \"\"\"\n    This frame should be alpha composited with the previous output image contents.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n\n\ndef _safe_zlib_decompress(s):\n    dobj = zlib.decompressobj()\n    plaintext = dobj.decompress(s, MAX_TEXT_CHUNK)\n    if dobj.unconsumed_tail:\n        msg = \"Decompressed Data Too Large\"\n        raise ValueError(msg)\n    return plaintext\n\n\ndef _crc32(data, seed=0):\n    return zlib.crc32(data, seed) & 0xFFFFFFFF\n\n\n# --------------------------------------------------------------------\n# Support classes.  Suitable for PNG and related formats like MNG etc.\n\n\nclass ChunkStream:\n    def __init__(self, fp: IO[bytes]) -> None:\n        self.fp: IO[bytes] | None = fp\n        self.queue: list[tuple[bytes, int, int]] | None = []\n\n    def read(self) -> tuple[bytes, int, int]:\n        \"\"\"Fetch a new chunk. Returns header information.\"\"\"\n        cid = None\n\n        assert self.fp is not None\n        if self.queue:\n            cid, pos, length = self.queue.pop()\n            self.fp.seek(pos)\n        else:\n            s = self.fp.read(8)\n            cid = s[4:]\n            pos = self.fp.tell()\n            length = i32(s)\n\n        if not is_cid(cid):\n            if not ImageFile.LOAD_TRUNCATED_IMAGES:\n                msg = f\"broken PNG file (chunk {repr(cid)})\"\n                raise SyntaxError(msg)\n\n        return cid, pos, length\n\n    def __enter__(self) -> ChunkStream:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def close(self) -> None:\n        self.queue = self.fp = None\n\n    def push(self, cid: bytes, pos: int, length: int) -> None:\n        assert self.queue is not None\n        self.queue.append((cid, pos, length))\n\n    def call(self, cid, pos, length):\n        \"\"\"Call the appropriate chunk handler\"\"\"\n\n        logger.debug(\"STREAM %r %s %s\", cid, pos, length)\n        return getattr(self, f\"chunk_{cid.decode('ascii')}\")(pos, length)\n\n    def crc(self, cid: bytes, data: bytes) -> None:\n        \"\"\"Read and verify checksum\"\"\"\n\n        # Skip CRC checks for ancillary chunks if allowed to load truncated\n        # images\n        # 5th byte of first char is 1 [specs, section 5.4]\n        if ImageFile.LOAD_TRUNCATED_IMAGES and (cid[0] >> 5 & 1):\n            self.crc_skip(cid, data)\n            return\n\n        assert self.fp is not None\n        try:\n            crc1 = _crc32(data, _crc32(cid))\n            crc2 = i32(self.fp.read(4))\n            if crc1 != crc2:\n                msg = f\"broken PNG file (bad header checksum in {repr(cid)})\"\n                raise SyntaxError(msg)\n        except struct.error as e:\n            msg = f\"broken PNG file (incomplete checksum in {repr(cid)})\"\n            raise SyntaxError(msg) from e\n\n    def crc_skip(self, cid: bytes, data: bytes) -> None:\n        \"\"\"Read checksum\"\"\"\n\n        assert self.fp is not None\n        self.fp.read(4)\n\n    def verify(self, endchunk: bytes = b\"IEND\") -> list[bytes]:\n        # Simple approach; just calculate checksum for all remaining\n        # blocks.  Must be called directly after open.\n\n        cids = []\n\n        while True:\n            try:\n                cid, pos, length = self.read()\n            except struct.error as e:\n                msg = \"truncated PNG file\"\n                raise OSError(msg) from e\n\n            if cid == endchunk:\n                break\n            self.crc(cid, ImageFile._safe_read(self.fp, length))\n            cids.append(cid)\n\n        return cids\n\n\nclass iTXt(str):\n    \"\"\"\n    Subclass of string to allow iTXt chunks to look like strings while\n    keeping their extra information\n\n    \"\"\"\n\n    lang: str | bytes | None\n    tkey: str | bytes | None\n\n    @staticmethod\n    def __new__(cls, text, lang=None, tkey=None):\n        \"\"\"\n        :param cls: the class to use when creating the instance\n        :param text: value for this key\n        :param lang: language code\n        :param tkey: UTF-8 version of the key name\n        \"\"\"\n\n        self = str.__new__(cls, text)\n        self.lang = lang\n        self.tkey = tkey\n        return self\n\n\nclass PngInfo:\n    \"\"\"\n    PNG chunk container (for use with save(pnginfo=))\n\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.chunks: list[tuple[bytes, bytes, bool]] = []\n\n    def add(self, cid: bytes, data: bytes, after_idat: bool = False) -> None:\n        \"\"\"Appends an arbitrary chunk. Use with caution.\n\n        :param cid: a byte string, 4 bytes long.\n        :param data: a byte string of the encoded data\n        :param after_idat: for use with private chunks. Whether the chunk\n                           should be written after IDAT\n\n        \"\"\"\n\n        self.chunks.append((cid, data, after_idat))\n\n    def add_itxt(\n        self,\n        key: str | bytes,\n        value: str | bytes,\n        lang: str | bytes = \"\",\n        tkey: str | bytes = \"\",\n        zip: bool = False,\n    ) -> None:\n        \"\"\"Appends an iTXt chunk.\n\n        :param key: latin-1 encodable text key name\n        :param value: value for this key\n        :param lang: language code\n        :param tkey: UTF-8 version of the key name\n        :param zip: compression flag\n\n        \"\"\"\n\n        if not isinstance(key, bytes):\n            key = key.encode(\"latin-1\", \"strict\")\n        if not isinstance(value, bytes):\n            value = value.encode(\"utf-8\", \"strict\")\n        if not isinstance(lang, bytes):\n            lang = lang.encode(\"utf-8\", \"strict\")\n        if not isinstance(tkey, bytes):\n            tkey = tkey.encode(\"utf-8\", \"strict\")\n\n        if zip:\n            self.add(\n                b\"iTXt\",\n                key + b\"\\0\\x01\\0\" + lang + b\"\\0\" + tkey + b\"\\0\" + zlib.compress(value),\n            )\n        else:\n            self.add(b\"iTXt\", key + b\"\\0\\0\\0\" + lang + b\"\\0\" + tkey + b\"\\0\" + value)\n\n    def add_text(\n        self, key: str | bytes, value: str | bytes | iTXt, zip: bool = False\n    ) -> None:\n        \"\"\"Appends a text chunk.\n\n        :param key: latin-1 encodable text key name\n        :param value: value for this key, text or an\n           :py:class:`PIL.PngImagePlugin.iTXt` instance\n        :param zip: compression flag\n\n        \"\"\"\n        if isinstance(value, iTXt):\n            return self.add_itxt(\n                key,\n                value,\n                value.lang if value.lang is not None else b\"\",\n                value.tkey if value.tkey is not None else b\"\",\n                zip=zip,\n            )\n\n        # The tEXt chunk stores latin-1 text\n        if not isinstance(value, bytes):\n            try:\n                value = value.encode(\"latin-1\", \"strict\")\n            except UnicodeError:\n                return self.add_itxt(key, value, zip=zip)\n\n        if not isinstance(key, bytes):\n            key = key.encode(\"latin-1\", \"strict\")\n\n        if zip:\n            self.add(b\"zTXt\", key + b\"\\0\\0\" + zlib.compress(value))\n        else:\n            self.add(b\"tEXt\", key + b\"\\0\" + value)\n\n\n# --------------------------------------------------------------------\n# PNG image stream (IHDR/IEND)\n\n\nclass PngStream(ChunkStream):\n    def __init__(self, fp):\n        super().__init__(fp)\n\n        # local copies of Image attributes\n        self.im_info = {}\n        self.im_text = {}\n        self.im_size = (0, 0)\n        self.im_mode = None\n        self.im_tile = None\n        self.im_palette = None\n        self.im_custom_mimetype = None\n        self.im_n_frames = None\n        self._seq_num = None\n        self.rewind_state = None\n\n        self.text_memory = 0\n\n    def check_text_memory(self, chunklen: int) -> None:\n        self.text_memory += chunklen\n        if self.text_memory > MAX_TEXT_MEMORY:\n            msg = (\n                \"Too much memory used in text chunks: \"\n                f\"{self.text_memory}>MAX_TEXT_MEMORY\"\n            )\n            raise ValueError(msg)\n\n    def save_rewind(self) -> None:\n        self.rewind_state = {\n            \"info\": self.im_info.copy(),\n            \"tile\": self.im_tile,\n            \"seq_num\": self._seq_num,\n        }\n\n    def rewind(self) -> None:\n        self.im_info = self.rewind_state[\"info\"].copy()\n        self.im_tile = self.rewind_state[\"tile\"]\n        self._seq_num = self.rewind_state[\"seq_num\"]\n\n    def chunk_iCCP(self, pos: int, length: int) -> bytes:\n        # ICC profile\n        s = ImageFile._safe_read(self.fp, length)\n        # according to PNG spec, the iCCP chunk contains:\n        # Profile name  1-79 bytes (character string)\n        # Null separator        1 byte (null character)\n        # Compression method    1 byte (0)\n        # Compressed profile    n bytes (zlib with deflate compression)\n        i = s.find(b\"\\0\")\n        logger.debug(\"iCCP profile name %r\", s[:i])\n        comp_method = s[i + 1]\n        logger.debug(\"Compression method %s\", comp_method)\n        if comp_method != 0:\n            msg = f\"Unknown compression method {comp_method} in iCCP chunk\"\n            raise SyntaxError(msg)\n        try:\n            icc_profile = _safe_zlib_decompress(s[i + 2 :])\n        except ValueError:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                icc_profile = None\n            else:\n                raise\n        except zlib.error:\n            icc_profile = None  # FIXME\n        self.im_info[\"icc_profile\"] = icc_profile\n        return s\n\n    def chunk_IHDR(self, pos: int, length: int) -> bytes:\n        # image header\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 13:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"Truncated IHDR chunk\"\n            raise ValueError(msg)\n        self.im_size = i32(s, 0), i32(s, 4)\n        try:\n            self.im_mode, self.im_rawmode = _MODES[(s[8], s[9])]\n        except Exception:\n            pass\n        if s[12]:\n            self.im_info[\"interlace\"] = 1\n        if s[11]:\n            msg = \"unknown filter category\"\n            raise SyntaxError(msg)\n        return s\n\n    def chunk_IDAT(self, pos: int, length: int) -> NoReturn:\n        # image data\n        if \"bbox\" in self.im_info:\n            tile = [(\"zip\", self.im_info[\"bbox\"], pos, self.im_rawmode)]\n        else:\n            if self.im_n_frames is not None:\n                self.im_info[\"default_image\"] = True\n            tile = [(\"zip\", (0, 0) + self.im_size, pos, self.im_rawmode)]\n        self.im_tile = tile\n        self.im_idat = length\n        msg = \"image data found\"\n        raise EOFError(msg)\n\n    def chunk_IEND(self, pos: int, length: int) -> NoReturn:\n        msg = \"end of PNG image\"\n        raise EOFError(msg)\n\n    def chunk_PLTE(self, pos: int, length: int) -> bytes:\n        # palette\n        s = ImageFile._safe_read(self.fp, length)\n        if self.im_mode == \"P\":\n            self.im_palette = \"RGB\", s\n        return s\n\n    def chunk_tRNS(self, pos: int, length: int) -> bytes:\n        # transparency\n        s = ImageFile._safe_read(self.fp, length)\n        if self.im_mode == \"P\":\n            if _simple_palette.match(s):\n                # tRNS contains only one full-transparent entry,\n                # other entries are full opaque\n                i = s.find(b\"\\0\")\n                if i >= 0:\n                    self.im_info[\"transparency\"] = i\n            else:\n                # otherwise, we have a byte string with one alpha value\n                # for each palette entry\n                self.im_info[\"transparency\"] = s\n        elif self.im_mode in (\"1\", \"L\", \"I;16\"):\n            self.im_info[\"transparency\"] = i16(s)\n        elif self.im_mode == \"RGB\":\n            self.im_info[\"transparency\"] = i16(s), i16(s, 2), i16(s, 4)\n        return s\n\n    def chunk_gAMA(self, pos: int, length: int) -> bytes:\n        # gamma setting\n        s = ImageFile._safe_read(self.fp, length)\n        self.im_info[\"gamma\"] = i32(s) / 100000.0\n        return s\n\n    def chunk_cHRM(self, pos: int, length: int) -> bytes:\n        # chromaticity, 8 unsigned ints, actual value is scaled by 100,000\n        # WP x,y, Red x,y, Green x,y Blue x,y\n\n        s = ImageFile._safe_read(self.fp, length)\n        raw_vals = struct.unpack(\">%dI\" % (len(s) // 4), s)\n        self.im_info[\"chromaticity\"] = tuple(elt / 100000.0 for elt in raw_vals)\n        return s\n\n    def chunk_sRGB(self, pos: int, length: int) -> bytes:\n        # srgb rendering intent, 1 byte\n        # 0 perceptual\n        # 1 relative colorimetric\n        # 2 saturation\n        # 3 absolute colorimetric\n\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 1:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"Truncated sRGB chunk\"\n            raise ValueError(msg)\n        self.im_info[\"srgb\"] = s[0]\n        return s\n\n    def chunk_pHYs(self, pos: int, length: int) -> bytes:\n        # pixels per unit\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 9:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"Truncated pHYs chunk\"\n            raise ValueError(msg)\n        px, py = i32(s, 0), i32(s, 4)\n        unit = s[8]\n        if unit == 1:  # meter\n            dpi = px * 0.0254, py * 0.0254\n            self.im_info[\"dpi\"] = dpi\n        elif unit == 0:\n            self.im_info[\"aspect\"] = px, py\n        return s\n\n    def chunk_tEXt(self, pos: int, length: int) -> bytes:\n        # text\n        s = ImageFile._safe_read(self.fp, length)\n        try:\n            k, v = s.split(b\"\\0\", 1)\n        except ValueError:\n            # fallback for broken tEXt tags\n            k = s\n            v = b\"\"\n        if k:\n            k = k.decode(\"latin-1\", \"strict\")\n            v_str = v.decode(\"latin-1\", \"replace\")\n\n            self.im_info[k] = v if k == \"exif\" else v_str\n            self.im_text[k] = v_str\n            self.check_text_memory(len(v_str))\n\n        return s\n\n    def chunk_zTXt(self, pos: int, length: int) -> bytes:\n        # compressed text\n        s = ImageFile._safe_read(self.fp, length)\n        try:\n            k, v = s.split(b\"\\0\", 1)\n        except ValueError:\n            k = s\n            v = b\"\"\n        if v:\n            comp_method = v[0]\n        else:\n            comp_method = 0\n        if comp_method != 0:\n            msg = f\"Unknown compression method {comp_method} in zTXt chunk\"\n            raise SyntaxError(msg)\n        try:\n            v = _safe_zlib_decompress(v[1:])\n        except ValueError:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                v = b\"\"\n            else:\n                raise\n        except zlib.error:\n            v = b\"\"\n\n        if k:\n            k = k.decode(\"latin-1\", \"strict\")\n            v = v.decode(\"latin-1\", \"replace\")\n\n            self.im_info[k] = self.im_text[k] = v\n            self.check_text_memory(len(v))\n\n        return s\n\n    def chunk_iTXt(self, pos: int, length: int) -> bytes:\n        # international text\n        r = s = ImageFile._safe_read(self.fp, length)\n        try:\n            k, r = r.split(b\"\\0\", 1)\n        except ValueError:\n            return s\n        if len(r) < 2:\n            return s\n        cf, cm, r = r[0], r[1], r[2:]\n        try:\n            lang, tk, v = r.split(b\"\\0\", 2)\n        except ValueError:\n            return s\n        if cf != 0:\n            if cm == 0:\n                try:\n                    v = _safe_zlib_decompress(v)\n                except ValueError:\n                    if ImageFile.LOAD_TRUNCATED_IMAGES:\n                        return s\n                    else:\n                        raise\n                except zlib.error:\n                    return s\n            else:\n                return s\n        if k == b\"XML:com.adobe.xmp\":\n            self.im_info[\"xmp\"] = v\n        try:\n            k = k.decode(\"latin-1\", \"strict\")\n            lang = lang.decode(\"utf-8\", \"strict\")\n            tk = tk.decode(\"utf-8\", \"strict\")\n            v = v.decode(\"utf-8\", \"strict\")\n        except UnicodeError:\n            return s\n\n        self.im_info[k] = self.im_text[k] = iTXt(v, lang, tk)\n        self.check_text_memory(len(v))\n\n        return s\n\n    def chunk_eXIf(self, pos: int, length: int) -> bytes:\n        s = ImageFile._safe_read(self.fp, length)\n        self.im_info[\"exif\"] = b\"Exif\\x00\\x00\" + s\n        return s\n\n    # APNG chunks\n    def chunk_acTL(self, pos: int, length: int) -> bytes:\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 8:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"APNG contains truncated acTL chunk\"\n            raise ValueError(msg)\n        if self.im_n_frames is not None:\n            self.im_n_frames = None\n            warnings.warn(\"Invalid APNG, will use default PNG image if possible\")\n            return s\n        n_frames = i32(s)\n        if n_frames == 0 or n_frames > 0x80000000:\n            warnings.warn(\"Invalid APNG, will use default PNG image if possible\")\n            return s\n        self.im_n_frames = n_frames\n        self.im_info[\"loop\"] = i32(s, 4)\n        self.im_custom_mimetype = \"image/apng\"\n        return s\n\n    def chunk_fcTL(self, pos: int, length: int) -> bytes:\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 26:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"APNG contains truncated fcTL chunk\"\n            raise ValueError(msg)\n        seq = i32(s)\n        if (self._seq_num is None and seq != 0) or (\n            self._seq_num is not None and self._seq_num != seq - 1\n        ):\n            msg = \"APNG contains frame sequence errors\"\n            raise SyntaxError(msg)\n        self._seq_num = seq\n        width, height = i32(s, 4), i32(s, 8)\n        px, py = i32(s, 12), i32(s, 16)\n        im_w, im_h = self.im_size\n        if px + width > im_w or py + height > im_h:\n            msg = \"APNG contains invalid frames\"\n            raise SyntaxError(msg)\n        self.im_info[\"bbox\"] = (px, py, px + width, py + height)\n        delay_num, delay_den = i16(s, 20), i16(s, 22)\n        if delay_den == 0:\n            delay_den = 100\n        self.im_info[\"duration\"] = float(delay_num) / float(delay_den) * 1000\n        self.im_info[\"disposal\"] = s[24]\n        self.im_info[\"blend\"] = s[25]\n        return s\n\n    def chunk_fdAT(self, pos: int, length: int) -> bytes:\n        if length < 4:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                s = ImageFile._safe_read(self.fp, length)\n                return s\n            msg = \"APNG contains truncated fDAT chunk\"\n            raise ValueError(msg)\n        s = ImageFile._safe_read(self.fp, 4)\n        seq = i32(s)\n        if self._seq_num != seq - 1:\n            msg = \"APNG contains frame sequence errors\"\n            raise SyntaxError(msg)\n        self._seq_num = seq\n        return self.chunk_IDAT(pos + 4, length - 4)\n\n\n# --------------------------------------------------------------------\n# PNG reader\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == _MAGIC\n\n\n##\n# Image plugin for PNG images.\n\n\nclass PngImageFile(ImageFile.ImageFile):\n    format = \"PNG\"\n    format_description = \"Portable network graphics\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(8)):\n            msg = \"not a PNG file\"\n            raise SyntaxError(msg)\n        self._fp = self.fp\n        self.__frame = 0\n\n        #\n        # Parse headers up to the first IDAT or fDAT chunk\n\n        self.private_chunks: list[tuple[bytes, bytes] | tuple[bytes, bytes, bool]] = []\n        self.png: PngStream | None = PngStream(self.fp)\n\n        while True:\n            #\n            # get next chunk\n\n            cid, pos, length = self.png.read()\n\n            try:\n                s = self.png.call(cid, pos, length)\n            except EOFError:\n                break\n            except AttributeError:\n                logger.debug(\"%r %s %s (unknown)\", cid, pos, length)\n                s = ImageFile._safe_read(self.fp, length)\n                if cid[1:2].islower():\n                    self.private_chunks.append((cid, s))\n\n            self.png.crc(cid, s)\n\n        #\n        # Copy relevant attributes from the PngStream.  An alternative\n        # would be to let the PngStream class modify these attributes\n        # directly, but that introduces circular references which are\n        # difficult to break if things go wrong in the decoder...\n        # (believe me, I've tried ;-)\n\n        self._mode = self.png.im_mode\n        self._size = self.png.im_size\n        self.info = self.png.im_info\n        self._text = None\n        self.tile = self.png.im_tile\n        self.custom_mimetype = self.png.im_custom_mimetype\n        self.n_frames = self.png.im_n_frames or 1\n        self.default_image = self.info.get(\"default_image\", False)\n\n        if self.png.im_palette:\n            rawmode, data = self.png.im_palette\n            self.palette = ImagePalette.raw(rawmode, data)\n\n        if cid == b\"fdAT\":\n            self.__prepare_idat = length - 4\n        else:\n            self.__prepare_idat = length  # used by load_prepare()\n\n        if self.png.im_n_frames is not None:\n            self._close_exclusive_fp_after_loading = False\n            self.png.save_rewind()\n            self.__rewind_idat = self.__prepare_idat\n            self.__rewind = self._fp.tell()\n            if self.default_image:\n                # IDAT chunk contains default image and not first animation frame\n                self.n_frames += 1\n            self._seek(0)\n        self.is_animated = self.n_frames > 1\n\n    @property\n    def text(self):\n        # experimental\n        if self._text is None:\n            # iTxt, tEXt and zTXt chunks may appear at the end of the file\n            # So load the file to ensure that they are read\n            if self.is_animated:\n                frame = self.__frame\n                # for APNG, seek to the final frame before loading\n                self.seek(self.n_frames - 1)\n            self.load()\n            if self.is_animated:\n                self.seek(frame)\n        return self._text\n\n    def verify(self) -> None:\n        \"\"\"Verify PNG file\"\"\"\n\n        if self.fp is None:\n            msg = \"verify must be called directly after open\"\n            raise RuntimeError(msg)\n\n        # back up to beginning of IDAT block\n        self.fp.seek(self.tile[0][2] - 8)\n\n        assert self.png is not None\n        self.png.verify()\n        self.png.close()\n\n        if self._exclusive_fp:\n            self.fp.close()\n        self.fp = None\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        if frame < self.__frame:\n            self._seek(0, True)\n\n        last_frame = self.__frame\n        for f in range(self.__frame + 1, frame + 1):\n            try:\n                self._seek(f)\n            except EOFError as e:\n                self.seek(last_frame)\n                msg = \"no more images in APNG file\"\n                raise EOFError(msg) from e\n\n    def _seek(self, frame: int, rewind: bool = False) -> None:\n        assert self.png is not None\n\n        self.dispose: _imaging.ImagingCore | None\n        if frame == 0:\n            if rewind:\n                self._fp.seek(self.__rewind)\n                self.png.rewind()\n                self.__prepare_idat = self.__rewind_idat\n                self.im = None\n                if self.pyaccess:\n                    self.pyaccess = None\n                self.info = self.png.im_info\n                self.tile = self.png.im_tile\n                self.fp = self._fp\n            self._prev_im = None\n            self.dispose = None\n            self.default_image = self.info.get(\"default_image\", False)\n            self.dispose_op = self.info.get(\"disposal\")\n            self.blend_op = self.info.get(\"blend\")\n            self.dispose_extent = self.info.get(\"bbox\")\n            self.__frame = 0\n        else:\n            if frame != self.__frame + 1:\n                msg = f\"cannot seek to frame {frame}\"\n                raise ValueError(msg)\n\n            # ensure previous frame was loaded\n            self.load()\n\n            if self.dispose:\n                self.im.paste(self.dispose, self.dispose_extent)\n            self._prev_im = self.im.copy()\n\n            self.fp = self._fp\n\n            # advance to the next frame\n            if self.__prepare_idat:\n                ImageFile._safe_read(self.fp, self.__prepare_idat)\n                self.__prepare_idat = 0\n            frame_start = False\n            while True:\n                self.fp.read(4)  # CRC\n\n                try:\n                    cid, pos, length = self.png.read()\n                except (struct.error, SyntaxError):\n                    break\n\n                if cid == b\"IEND\":\n                    msg = \"No more images in APNG file\"\n                    raise EOFError(msg)\n                if cid == b\"fcTL\":\n                    if frame_start:\n                        # there must be at least one fdAT chunk between fcTL chunks\n                        msg = \"APNG missing frame data\"\n                        raise SyntaxError(msg)\n                    frame_start = True\n\n                try:\n                    self.png.call(cid, pos, length)\n                except UnicodeDecodeError:\n                    break\n                except EOFError:\n                    if cid == b\"fdAT\":\n                        length -= 4\n                        if frame_start:\n                            self.__prepare_idat = length\n                            break\n                    ImageFile._safe_read(self.fp, length)\n                except AttributeError:\n                    logger.debug(\"%r %s %s (unknown)\", cid, pos, length)\n                    ImageFile._safe_read(self.fp, length)\n\n            self.__frame = frame\n            self.tile = self.png.im_tile\n            self.dispose_op = self.info.get(\"disposal\")\n            self.blend_op = self.info.get(\"blend\")\n            self.dispose_extent = self.info.get(\"bbox\")\n\n            if not self.tile:\n                msg = \"image not found in APNG frame\"\n                raise EOFError(msg)\n\n        # setup frame disposal (actual disposal done when needed in the next _seek())\n        if self._prev_im is None and self.dispose_op == Disposal.OP_PREVIOUS:\n            self.dispose_op = Disposal.OP_BACKGROUND\n\n        self.dispose = None\n        if self.dispose_op == Disposal.OP_PREVIOUS:\n            if self._prev_im:\n                self.dispose = self._prev_im.copy()\n                self.dispose = self._crop(self.dispose, self.dispose_extent)\n        elif self.dispose_op == Disposal.OP_BACKGROUND:\n            self.dispose = Image.core.fill(self.mode, self.size)\n            self.dispose = self._crop(self.dispose, self.dispose_extent)\n\n    def tell(self) -> int:\n        return self.__frame\n\n    def load_prepare(self) -> None:\n        \"\"\"internal: prepare to read PNG file\"\"\"\n\n        if self.info.get(\"interlace\"):\n            self.decoderconfig = self.decoderconfig + (1,)\n\n        self.__idat = self.__prepare_idat  # used by load_read()\n        ImageFile.ImageFile.load_prepare(self)\n\n    def load_read(self, read_bytes: int) -> bytes:\n        \"\"\"internal: read more image data\"\"\"\n\n        assert self.png is not None\n        while self.__idat == 0:\n            # end of chunk, skip forward to next one\n\n            self.fp.read(4)  # CRC\n\n            cid, pos, length = self.png.read()\n\n            if cid not in [b\"IDAT\", b\"DDAT\", b\"fdAT\"]:\n                self.png.push(cid, pos, length)\n                return b\"\"\n\n            if cid == b\"fdAT\":\n                try:\n                    self.png.call(cid, pos, length)\n                except EOFError:\n                    pass\n                self.__idat = length - 4  # sequence_num has already been read\n            else:\n                self.__idat = length  # empty chunks are allowed\n\n        # read more data from this chunk\n        if read_bytes <= 0:\n            read_bytes = self.__idat\n        else:\n            read_bytes = min(read_bytes, self.__idat)\n\n        self.__idat = self.__idat - read_bytes\n\n        return self.fp.read(read_bytes)\n\n    def load_end(self) -> None:\n        \"\"\"internal: finished reading image data\"\"\"\n        assert self.png is not None\n        if self.__idat != 0:\n            self.fp.read(self.__idat)\n        while True:\n            self.fp.read(4)  # CRC\n\n            try:\n                cid, pos, length = self.png.read()\n            except (struct.error, SyntaxError):\n                break\n\n            if cid == b\"IEND\":\n                break\n            elif cid == b\"fcTL\" and self.is_animated:\n                # start of the next frame, stop reading\n                self.__prepare_idat = 0\n                self.png.push(cid, pos, length)\n                break\n\n            try:\n                self.png.call(cid, pos, length)\n            except UnicodeDecodeError:\n                break\n            except EOFError:\n                if cid == b\"fdAT\":\n                    length -= 4\n                try:\n                    ImageFile._safe_read(self.fp, length)\n                except OSError as e:\n                    if ImageFile.LOAD_TRUNCATED_IMAGES:\n                        break\n                    else:\n                        raise e\n            except AttributeError:\n                logger.debug(\"%r %s %s (unknown)\", cid, pos, length)\n                s = ImageFile._safe_read(self.fp, length)\n                if cid[1:2].islower():\n                    self.private_chunks.append((cid, s, True))\n        self._text = self.png.im_text\n        if not self.is_animated:\n            self.png.close()\n            self.png = None\n        else:\n            if self._prev_im and self.blend_op == Blend.OP_OVER:\n                updated = self._crop(self.im, self.dispose_extent)\n                if self.im.mode == \"RGB\" and \"transparency\" in self.info:\n                    mask = updated.convert_transparent(\n                        \"RGBA\", self.info[\"transparency\"]\n                    )\n                else:\n                    mask = updated.convert(\"RGBA\")\n                self._prev_im.paste(updated, self.dispose_extent, mask)\n                self.im = self._prev_im\n                if self.pyaccess:\n                    self.pyaccess = None\n\n    def _getexif(self) -> dict[str, Any] | None:\n        if \"exif\" not in self.info:\n            self.load()\n        if \"exif\" not in self.info and \"Raw profile type exif\" not in self.info:\n            return None\n        return self.getexif()._get_merged_dict()\n\n    def getexif(self) -> Image.Exif:\n        if \"exif\" not in self.info:\n            self.load()\n\n        return super().getexif()\n\n\n# --------------------------------------------------------------------\n# PNG writer\n\n_OUTMODES = {\n    # supported PIL modes, and corresponding rawmode, bit depth and color type\n    \"1\": (\"1\", b\"\\x01\", b\"\\x00\"),\n    \"L;1\": (\"L;1\", b\"\\x01\", b\"\\x00\"),\n    \"L;2\": (\"L;2\", b\"\\x02\", b\"\\x00\"),\n    \"L;4\": (\"L;4\", b\"\\x04\", b\"\\x00\"),\n    \"L\": (\"L\", b\"\\x08\", b\"\\x00\"),\n    \"LA\": (\"LA\", b\"\\x08\", b\"\\x04\"),\n    \"I\": (\"I;16B\", b\"\\x10\", b\"\\x00\"),\n    \"I;16\": (\"I;16B\", b\"\\x10\", b\"\\x00\"),\n    \"I;16B\": (\"I;16B\", b\"\\x10\", b\"\\x00\"),\n    \"P;1\": (\"P;1\", b\"\\x01\", b\"\\x03\"),\n    \"P;2\": (\"P;2\", b\"\\x02\", b\"\\x03\"),\n    \"P;4\": (\"P;4\", b\"\\x04\", b\"\\x03\"),\n    \"P\": (\"P\", b\"\\x08\", b\"\\x03\"),\n    \"RGB\": (\"RGB\", b\"\\x08\", b\"\\x02\"),\n    \"RGBA\": (\"RGBA\", b\"\\x08\", b\"\\x06\"),\n}\n\n\ndef putchunk(fp, cid, *data):\n    \"\"\"Write a PNG chunk (including CRC field)\"\"\"\n\n    data = b\"\".join(data)\n\n    fp.write(o32(len(data)) + cid)\n    fp.write(data)\n    crc = _crc32(data, _crc32(cid))\n    fp.write(o32(crc))\n\n\nclass _idat:\n    # wrap output from the encoder in IDAT chunks\n\n    def __init__(self, fp, chunk):\n        self.fp = fp\n        self.chunk = chunk\n\n    def write(self, data: bytes) -> None:\n        self.chunk(self.fp, b\"IDAT\", data)\n\n\nclass _fdat:\n    # wrap encoder output in fdAT chunks\n\n    def __init__(self, fp, chunk, seq_num):\n        self.fp = fp\n        self.chunk = chunk\n        self.seq_num = seq_num\n\n    def write(self, data: bytes) -> None:\n        self.chunk(self.fp, b\"fdAT\", o32(self.seq_num), data)\n        self.seq_num += 1\n\n\ndef _write_multiple_frames(im, fp, chunk, rawmode, default_image, append_images):\n    duration = im.encoderinfo.get(\"duration\", im.info.get(\"duration\", 0))\n    loop = im.encoderinfo.get(\"loop\", im.info.get(\"loop\", 0))\n    disposal = im.encoderinfo.get(\"disposal\", im.info.get(\"disposal\", Disposal.OP_NONE))\n    blend = im.encoderinfo.get(\"blend\", im.info.get(\"blend\", Blend.OP_SOURCE))\n\n    if default_image:\n        chain = itertools.chain(append_images)\n    else:\n        chain = itertools.chain([im], append_images)\n\n    im_frames = []\n    frame_count = 0\n    for im_seq in chain:\n        for im_frame in ImageSequence.Iterator(im_seq):\n            if im_frame.mode == rawmode:\n                im_frame = im_frame.copy()\n            else:\n                im_frame = im_frame.convert(rawmode)\n            encoderinfo = im.encoderinfo.copy()\n            if isinstance(duration, (list, tuple)):\n                encoderinfo[\"duration\"] = duration[frame_count]\n            if isinstance(disposal, (list, tuple)):\n                encoderinfo[\"disposal\"] = disposal[frame_count]\n            if isinstance(blend, (list, tuple)):\n                encoderinfo[\"blend\"] = blend[frame_count]\n            frame_count += 1\n\n            if im_frames:\n                previous = im_frames[-1]\n                prev_disposal = previous[\"encoderinfo\"].get(\"disposal\")\n                prev_blend = previous[\"encoderinfo\"].get(\"blend\")\n                if prev_disposal == Disposal.OP_PREVIOUS and len(im_frames) < 2:\n                    prev_disposal = Disposal.OP_BACKGROUND\n\n                if prev_disposal == Disposal.OP_BACKGROUND:\n                    base_im = previous[\"im\"].copy()\n                    dispose = Image.core.fill(\"RGBA\", im.size, (0, 0, 0, 0))\n                    bbox = previous[\"bbox\"]\n                    if bbox:\n                        dispose = dispose.crop(bbox)\n                    else:\n                        bbox = (0, 0) + im.size\n                    base_im.paste(dispose, bbox)\n                elif prev_disposal == Disposal.OP_PREVIOUS:\n                    base_im = im_frames[-2][\"im\"]\n                else:\n                    base_im = previous[\"im\"]\n                delta = ImageChops.subtract_modulo(\n                    im_frame.convert(\"RGBA\"), base_im.convert(\"RGBA\")\n                )\n                bbox = delta.getbbox(alpha_only=False)\n                if (\n                    not bbox\n                    and prev_disposal == encoderinfo.get(\"disposal\")\n                    and prev_blend == encoderinfo.get(\"blend\")\n                ):\n                    previous[\"encoderinfo\"][\"duration\"] += encoderinfo.get(\n                        \"duration\", duration\n                    )\n                    continue\n            else:\n                bbox = None\n            if \"duration\" not in encoderinfo:\n                encoderinfo[\"duration\"] = duration\n            im_frames.append({\"im\": im_frame, \"bbox\": bbox, \"encoderinfo\": encoderinfo})\n\n    if len(im_frames) == 1 and not default_image:\n        return im_frames[0][\"im\"]\n\n    # animation control\n    chunk(\n        fp,\n        b\"acTL\",\n        o32(len(im_frames)),  # 0: num_frames\n        o32(loop),  # 4: num_plays\n    )\n\n    # default image IDAT (if it exists)\n    if default_image:\n        if im.mode != rawmode:\n            im = im.convert(rawmode)\n        ImageFile._save(im, _idat(fp, chunk), [(\"zip\", (0, 0) + im.size, 0, rawmode)])\n\n    seq_num = 0\n    for frame, frame_data in enumerate(im_frames):\n        im_frame = frame_data[\"im\"]\n        if not frame_data[\"bbox\"]:\n            bbox = (0, 0) + im_frame.size\n        else:\n            bbox = frame_data[\"bbox\"]\n            im_frame = im_frame.crop(bbox)\n        size = im_frame.size\n        encoderinfo = frame_data[\"encoderinfo\"]\n        frame_duration = int(round(encoderinfo[\"duration\"]))\n        frame_disposal = encoderinfo.get(\"disposal\", disposal)\n        frame_blend = encoderinfo.get(\"blend\", blend)\n        # frame control\n        chunk(\n            fp,\n            b\"fcTL\",\n            o32(seq_num),  # sequence_number\n            o32(size[0]),  # width\n            o32(size[1]),  # height\n            o32(bbox[0]),  # x_offset\n            o32(bbox[1]),  # y_offset\n            o16(frame_duration),  # delay_numerator\n            o16(1000),  # delay_denominator\n            o8(frame_disposal),  # dispose_op\n            o8(frame_blend),  # blend_op\n        )\n        seq_num += 1\n        # frame data\n        if frame == 0 and not default_image:\n            # first frame must be in IDAT chunks for backwards compatibility\n            ImageFile._save(\n                im_frame,\n                _idat(fp, chunk),\n                [(\"zip\", (0, 0) + im_frame.size, 0, rawmode)],\n            )\n        else:\n            fdat_chunks = _fdat(fp, chunk, seq_num)\n            ImageFile._save(\n                im_frame,\n                fdat_chunks,\n                [(\"zip\", (0, 0) + im_frame.size, 0, rawmode)],\n            )\n            seq_num = fdat_chunks.seq_num\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, save_all=True)\n\n\ndef _save(im, fp, filename, chunk=putchunk, save_all=False):\n    # save an image to disk (called by the save method)\n\n    if save_all:\n        default_image = im.encoderinfo.get(\n            \"default_image\", im.info.get(\"default_image\")\n        )\n        modes = set()\n        sizes = set()\n        append_images = im.encoderinfo.get(\"append_images\", [])\n        for im_seq in itertools.chain([im], append_images):\n            for im_frame in ImageSequence.Iterator(im_seq):\n                modes.add(im_frame.mode)\n                sizes.add(im_frame.size)\n        for mode in (\"RGBA\", \"RGB\", \"P\"):\n            if mode in modes:\n                break\n        else:\n            mode = modes.pop()\n        size = tuple(max(frame_size[i] for frame_size in sizes) for i in range(2))\n    else:\n        size = im.size\n        mode = im.mode\n\n    if mode == \"P\":\n        #\n        # attempt to minimize storage requirements for palette images\n        if \"bits\" in im.encoderinfo:\n            # number of bits specified by user\n            colors = min(1 << im.encoderinfo[\"bits\"], 256)\n        else:\n            # check palette contents\n            if im.palette:\n                colors = max(min(len(im.palette.getdata()[1]) // 3, 256), 1)\n            else:\n                colors = 256\n\n        if colors <= 16:\n            if colors <= 2:\n                bits = 1\n            elif colors <= 4:\n                bits = 2\n            else:\n                bits = 4\n            mode = f\"{mode};{bits}\"\n\n    # encoder options\n    im.encoderconfig = (\n        im.encoderinfo.get(\"optimize\", False),\n        im.encoderinfo.get(\"compress_level\", -1),\n        im.encoderinfo.get(\"compress_type\", -1),\n        im.encoderinfo.get(\"dictionary\", b\"\"),\n    )\n\n    # get the corresponding PNG mode\n    try:\n        rawmode, bit_depth, color_type = _OUTMODES[mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {mode} as PNG\"\n        raise OSError(msg) from e\n\n    #\n    # write minimal PNG file\n\n    fp.write(_MAGIC)\n\n    chunk(\n        fp,\n        b\"IHDR\",\n        o32(size[0]),  # 0: size\n        o32(size[1]),\n        bit_depth,\n        color_type,\n        b\"\\0\",  # 10: compression\n        b\"\\0\",  # 11: filter category\n        b\"\\0\",  # 12: interlace flag\n    )\n\n    chunks = [b\"cHRM\", b\"gAMA\", b\"sBIT\", b\"sRGB\", b\"tIME\"]\n\n    icc = im.encoderinfo.get(\"icc_profile\", im.info.get(\"icc_profile\"))\n    if icc:\n        # ICC profile\n        # according to PNG spec, the iCCP chunk contains:\n        # Profile name  1-79 bytes (character string)\n        # Null separator        1 byte (null character)\n        # Compression method    1 byte (0)\n        # Compressed profile    n bytes (zlib with deflate compression)\n        name = b\"ICC Profile\"\n        data = name + b\"\\0\\0\" + zlib.compress(icc)\n        chunk(fp, b\"iCCP\", data)\n\n        # You must either have sRGB or iCCP.\n        # Disallow sRGB chunks when an iCCP-chunk has been emitted.\n        chunks.remove(b\"sRGB\")\n\n    info = im.encoderinfo.get(\"pnginfo\")\n    if info:\n        chunks_multiple_allowed = [b\"sPLT\", b\"iTXt\", b\"tEXt\", b\"zTXt\"]\n        for info_chunk in info.chunks:\n            cid, data = info_chunk[:2]\n            if cid in chunks:\n                chunks.remove(cid)\n                chunk(fp, cid, data)\n            elif cid in chunks_multiple_allowed:\n                chunk(fp, cid, data)\n            elif cid[1:2].islower():\n                # Private chunk\n                after_idat = len(info_chunk) == 3 and info_chunk[2]\n                if not after_idat:\n                    chunk(fp, cid, data)\n\n    if im.mode == \"P\":\n        palette_byte_number = colors * 3\n        palette_bytes = im.im.getpalette(\"RGB\")[:palette_byte_number]\n        while len(palette_bytes) < palette_byte_number:\n            palette_bytes += b\"\\0\"\n        chunk(fp, b\"PLTE\", palette_bytes)\n\n    transparency = im.encoderinfo.get(\"transparency\", im.info.get(\"transparency\", None))\n\n    if transparency or transparency == 0:\n        if im.mode == \"P\":\n            # limit to actual palette size\n            alpha_bytes = colors\n            if isinstance(transparency, bytes):\n                chunk(fp, b\"tRNS\", transparency[:alpha_bytes])\n            else:\n                transparency = max(0, min(255, transparency))\n                alpha = b\"\\xFF\" * transparency + b\"\\0\"\n                chunk(fp, b\"tRNS\", alpha[:alpha_bytes])\n        elif im.mode in (\"1\", \"L\", \"I\", \"I;16\"):\n            transparency = max(0, min(65535, transparency))\n            chunk(fp, b\"tRNS\", o16(transparency))\n        elif im.mode == \"RGB\":\n            red, green, blue = transparency\n            chunk(fp, b\"tRNS\", o16(red) + o16(green) + o16(blue))\n        else:\n            if \"transparency\" in im.encoderinfo:\n                # don't bother with transparency if it's an RGBA\n                # and it's in the info dict. It's probably just stale.\n                msg = \"cannot use transparency for this mode\"\n                raise OSError(msg)\n    else:\n        if im.mode == \"P\" and im.im.getpalettemode() == \"RGBA\":\n            alpha = im.im.getpalette(\"RGBA\", \"A\")\n            alpha_bytes = colors\n            chunk(fp, b\"tRNS\", alpha[:alpha_bytes])\n\n    dpi = im.encoderinfo.get(\"dpi\")\n    if dpi:\n        chunk(\n            fp,\n            b\"pHYs\",\n            o32(int(dpi[0] / 0.0254 + 0.5)),\n            o32(int(dpi[1] / 0.0254 + 0.5)),\n            b\"\\x01\",\n        )\n\n    if info:\n        chunks = [b\"bKGD\", b\"hIST\"]\n        for info_chunk in info.chunks:\n            cid, data = info_chunk[:2]\n            if cid in chunks:\n                chunks.remove(cid)\n                chunk(fp, cid, data)\n\n    exif = im.encoderinfo.get(\"exif\")\n    if exif:\n        if isinstance(exif, Image.Exif):\n            exif = exif.tobytes(8)\n        if exif.startswith(b\"Exif\\x00\\x00\"):\n            exif = exif[6:]\n        chunk(fp, b\"eXIf\", exif)\n\n    if save_all:\n        im = _write_multiple_frames(\n            im, fp, chunk, rawmode, default_image, append_images\n        )\n    if im:\n        ImageFile._save(im, _idat(fp, chunk), [(\"zip\", (0, 0) + im.size, 0, rawmode)])\n\n    if info:\n        for info_chunk in info.chunks:\n            cid, data = info_chunk[:2]\n            if cid[1:2].islower():\n                # Private chunk\n                after_idat = len(info_chunk) == 3 and info_chunk[2]\n                if after_idat:\n                    chunk(fp, cid, data)\n\n    chunk(fp, b\"IEND\", b\"\")\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\n# --------------------------------------------------------------------\n# PNG chunk converter\n\n\ndef getchunks(im, **params):\n    \"\"\"Return a list of PNG chunks representing this image.\"\"\"\n\n    class collector:\n        data = []\n\n        def write(self, data: bytes) -> None:\n            pass\n\n        def append(self, chunk: bytes) -> None:\n            self.data.append(chunk)\n\n    def append(fp, cid, *data):\n        data = b\"\".join(data)\n        crc = o32(_crc32(data, _crc32(cid)))\n        fp.append((cid, data, crc))\n\n    fp = collector()\n\n    try:\n        im.encoderinfo = params\n        _save(im, fp, None, append)\n    finally:\n        del im.encoderinfo\n\n    return fp.data\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(PngImageFile.format, PngImageFile, _accept)\nImage.register_save(PngImageFile.format, _save)\nImage.register_save_all(PngImageFile.format, _save_all)\n\nImage.register_extensions(PngImageFile.format, [\".png\", \".apng\"])\n\nImage.register_mime(PngImageFile.format, \"image/png\")\n", "src/PIL/WmfImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# WMF stub codec\n#\n# history:\n# 1996-12-14 fl   Created\n# 2004-02-22 fl   Turned into a stub driver\n# 2004-02-23 fl   Added EMF support\n#\n# Copyright (c) Secret Labs AB 1997-2004.  All rights reserved.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\n# WMF/EMF reference documentation:\n# https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-WMF/[MS-WMF].pdf\n# http://wvware.sourceforge.net/caolan/index.html\n# http://wvware.sourceforge.net/caolan/ora-wmf.html\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16le as word\nfrom ._binary import si16le as short\nfrom ._binary import si32le as _long\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific WMF image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\nif hasattr(Image.core, \"drawwmf\"):\n    # install default handler (windows only)\n\n    class WmfHandler(ImageFile.StubHandler):\n        def open(self, im: ImageFile.StubImageFile) -> None:\n            im._mode = \"RGB\"\n            self.bbox = im.info[\"wmf_bbox\"]\n\n        def load(self, im: ImageFile.StubImageFile) -> Image.Image:\n            im.fp.seek(0)  # rewind\n            return Image.frombytes(\n                \"RGB\",\n                im.size,\n                Image.core.drawwmf(im.fp.read(), im.size, self.bbox),\n                \"raw\",\n                \"BGR\",\n                (im.size[0] * 3 + 3) & -4,\n                -1,\n            )\n\n    register_handler(WmfHandler())\n\n#\n# --------------------------------------------------------------------\n# Read WMF file\n\n\ndef _accept(prefix: bytes) -> bool:\n    return (\n        prefix[:6] == b\"\\xd7\\xcd\\xc6\\x9a\\x00\\x00\" or prefix[:4] == b\"\\x01\\x00\\x00\\x00\"\n    )\n\n\n##\n# Image plugin for Windows metafiles.\n\n\nclass WmfStubImageFile(ImageFile.StubImageFile):\n    format = \"WMF\"\n    format_description = \"Windows Metafile\"\n\n    def _open(self) -> None:\n        self._inch = None\n\n        # check placable header\n        s = self.fp.read(80)\n\n        if s[:6] == b\"\\xd7\\xcd\\xc6\\x9a\\x00\\x00\":\n            # placeable windows metafile\n\n            # get units per inch\n            self._inch = word(s, 14)\n\n            # get bounding box\n            x0 = short(s, 6)\n            y0 = short(s, 8)\n            x1 = short(s, 10)\n            y1 = short(s, 12)\n\n            # normalize size to 72 dots per inch\n            self.info[\"dpi\"] = 72\n            size = (\n                (x1 - x0) * self.info[\"dpi\"] // self._inch,\n                (y1 - y0) * self.info[\"dpi\"] // self._inch,\n            )\n\n            self.info[\"wmf_bbox\"] = x0, y0, x1, y1\n\n            # sanity check (standard metafile header)\n            if s[22:26] != b\"\\x01\\x00\\t\\x00\":\n                msg = \"Unsupported WMF file format\"\n                raise SyntaxError(msg)\n\n        elif s[:4] == b\"\\x01\\x00\\x00\\x00\" and s[40:44] == b\" EMF\":\n            # enhanced metafile\n\n            # get bounding box\n            x0 = _long(s, 8)\n            y0 = _long(s, 12)\n            x1 = _long(s, 16)\n            y1 = _long(s, 20)\n\n            # get frame (in 0.01 millimeter units)\n            frame = _long(s, 24), _long(s, 28), _long(s, 32), _long(s, 36)\n\n            size = x1 - x0, y1 - y0\n\n            # calculate dots per inch from bbox and frame\n            xdpi = 2540.0 * (x1 - y0) / (frame[2] - frame[0])\n            ydpi = 2540.0 * (y1 - y0) / (frame[3] - frame[1])\n\n            self.info[\"wmf_bbox\"] = x0, y0, x1, y1\n\n            if xdpi == ydpi:\n                self.info[\"dpi\"] = xdpi\n            else:\n                self.info[\"dpi\"] = xdpi, ydpi\n\n        else:\n            msg = \"Unsupported file format\"\n            raise SyntaxError(msg)\n\n        self._mode = \"RGB\"\n        self._size = size\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n    def load(self, dpi=None):\n        if dpi is not None and self._inch is not None:\n            self.info[\"dpi\"] = dpi\n            x0, y0, x1, y1 = self.info[\"wmf_bbox\"]\n            self._size = (\n                (x1 - x0) * self.info[\"dpi\"] // self._inch,\n                (y1 - y0) * self.info[\"dpi\"] // self._inch,\n            )\n        return super().load()\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"WMF save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n#\n# --------------------------------------------------------------------\n# Registry stuff\n\n\nImage.register_open(WmfStubImageFile.format, WmfStubImageFile, _accept)\nImage.register_save(WmfStubImageFile.format, _save)\n\nImage.register_extensions(WmfStubImageFile.format, [\".wmf\", \".emf\"])\n", "src/PIL/ImageQt.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a simple Qt image interface.\n#\n# history:\n# 2006-06-03 fl: created\n# 2006-06-04 fl: inherit from QImage instead of wrapping it\n# 2006-06-05 fl: removed toimage helper; move string support to ImageQt\n# 2013-11-13 fl: add support for Qt5 (aurelien.ballier@cyclonit.com)\n#\n# Copyright (c) 2006 by Secret Labs AB\n# Copyright (c) 2006 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport sys\nfrom io import BytesIO\nfrom typing import Callable\n\nfrom . import Image\nfrom ._util import is_path\n\nqt_version: str | None\nqt_versions = [\n    [\"6\", \"PyQt6\"],\n    [\"side6\", \"PySide6\"],\n]\n\n# If a version has already been imported, attempt it first\nqt_versions.sort(key=lambda version: version[1] in sys.modules, reverse=True)\nfor version, qt_module in qt_versions:\n    try:\n        QBuffer: type\n        QIODevice: type\n        QImage: type\n        QPixmap: type\n        qRgba: Callable[[int, int, int, int], int]\n        if qt_module == \"PyQt6\":\n            from PyQt6.QtCore import QBuffer, QIODevice\n            from PyQt6.QtGui import QImage, QPixmap, qRgba\n        elif qt_module == \"PySide6\":\n            from PySide6.QtCore import QBuffer, QIODevice\n            from PySide6.QtGui import QImage, QPixmap, qRgba\n    except (ImportError, RuntimeError):\n        continue\n    qt_is_installed = True\n    qt_version = version\n    break\nelse:\n    qt_is_installed = False\n    qt_version = None\n\n\ndef rgb(r, g, b, a=255):\n    \"\"\"(Internal) Turns an RGB color into a Qt compatible color integer.\"\"\"\n    # use qRgb to pack the colors, and then turn the resulting long\n    # into a negative integer with the same bitpattern.\n    return qRgba(r, g, b, a) & 0xFFFFFFFF\n\n\ndef fromqimage(im):\n    \"\"\"\n    :param im: QImage or PIL ImageQt object\n    \"\"\"\n    buffer = QBuffer()\n    if qt_version == \"6\":\n        try:\n            qt_openmode = QIODevice.OpenModeFlag\n        except AttributeError:\n            qt_openmode = QIODevice.OpenMode\n    else:\n        qt_openmode = QIODevice\n    buffer.open(qt_openmode.ReadWrite)\n    # preserve alpha channel with png\n    # otherwise ppm is more friendly with Image.open\n    if im.hasAlphaChannel():\n        im.save(buffer, \"png\")\n    else:\n        im.save(buffer, \"ppm\")\n\n    b = BytesIO()\n    b.write(buffer.data())\n    buffer.close()\n    b.seek(0)\n\n    return Image.open(b)\n\n\ndef fromqpixmap(im):\n    return fromqimage(im)\n\n\ndef align8to32(bytes, width, mode):\n    \"\"\"\n    converts each scanline of data from 8 bit to 32 bit aligned\n    \"\"\"\n\n    bits_per_pixel = {\"1\": 1, \"L\": 8, \"P\": 8, \"I;16\": 16}[mode]\n\n    # calculate bytes per line and the extra padding if needed\n    bits_per_line = bits_per_pixel * width\n    full_bytes_per_line, remaining_bits_per_line = divmod(bits_per_line, 8)\n    bytes_per_line = full_bytes_per_line + (1 if remaining_bits_per_line else 0)\n\n    extra_padding = -bytes_per_line % 4\n\n    # already 32 bit aligned by luck\n    if not extra_padding:\n        return bytes\n\n    new_data = [\n        bytes[i * bytes_per_line : (i + 1) * bytes_per_line] + b\"\\x00\" * extra_padding\n        for i in range(len(bytes) // bytes_per_line)\n    ]\n\n    return b\"\".join(new_data)\n\n\ndef _toqclass_helper(im):\n    data = None\n    colortable = None\n    exclusive_fp = False\n\n    # handle filename, if given instead of image name\n    if hasattr(im, \"toUtf8\"):\n        # FIXME - is this really the best way to do this?\n        im = str(im.toUtf8(), \"utf-8\")\n    if is_path(im):\n        im = Image.open(im)\n        exclusive_fp = True\n\n    qt_format = QImage.Format if qt_version == \"6\" else QImage\n    if im.mode == \"1\":\n        format = qt_format.Format_Mono\n    elif im.mode == \"L\":\n        format = qt_format.Format_Indexed8\n        colortable = [rgb(i, i, i) for i in range(256)]\n    elif im.mode == \"P\":\n        format = qt_format.Format_Indexed8\n        palette = im.getpalette()\n        colortable = [rgb(*palette[i : i + 3]) for i in range(0, len(palette), 3)]\n    elif im.mode == \"RGB\":\n        # Populate the 4th channel with 255\n        im = im.convert(\"RGBA\")\n\n        data = im.tobytes(\"raw\", \"BGRA\")\n        format = qt_format.Format_RGB32\n    elif im.mode == \"RGBA\":\n        data = im.tobytes(\"raw\", \"BGRA\")\n        format = qt_format.Format_ARGB32\n    elif im.mode == \"I;16\":\n        im = im.point(lambda i: i * 256)\n\n        format = qt_format.Format_Grayscale16\n    else:\n        if exclusive_fp:\n            im.close()\n        msg = f\"unsupported image mode {repr(im.mode)}\"\n        raise ValueError(msg)\n\n    size = im.size\n    __data = data or align8to32(im.tobytes(), size[0], im.mode)\n    if exclusive_fp:\n        im.close()\n    return {\"data\": __data, \"size\": size, \"format\": format, \"colortable\": colortable}\n\n\nif qt_is_installed:\n\n    class ImageQt(QImage):\n        def __init__(self, im):\n            \"\"\"\n            An PIL image wrapper for Qt.  This is a subclass of PyQt's QImage\n            class.\n\n            :param im: A PIL Image object, or a file name (given either as\n                Python string or a PyQt string object).\n            \"\"\"\n            im_data = _toqclass_helper(im)\n            # must keep a reference, or Qt will crash!\n            # All QImage constructors that take data operate on an existing\n            # buffer, so this buffer has to hang on for the life of the image.\n            # Fixes https://github.com/python-pillow/Pillow/issues/1370\n            self.__data = im_data[\"data\"]\n            super().__init__(\n                self.__data,\n                im_data[\"size\"][0],\n                im_data[\"size\"][1],\n                im_data[\"format\"],\n            )\n            if im_data[\"colortable\"]:\n                self.setColorTable(im_data[\"colortable\"])\n\n\ndef toqimage(im) -> ImageQt:\n    return ImageQt(im)\n\n\ndef toqpixmap(im):\n    qimage = toqimage(im)\n    return QPixmap.fromImage(qimage)\n", "src/PIL/ImageFont.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PIL raster font management\n#\n# History:\n# 1996-08-07 fl   created (experimental)\n# 1997-08-25 fl   minor adjustments to handle fonts from pilfont 0.3\n# 1999-02-06 fl   rewrote most font management stuff in C\n# 1999-03-17 fl   take pth files into account in load_path (from Richard Jones)\n# 2001-02-17 fl   added freetype support\n# 2001-05-09 fl   added TransposedFont wrapper class\n# 2002-03-04 fl   make sure we have a \"L\" or \"1\" font\n# 2002-12-04 fl   skip non-directory entries in the system path\n# 2003-04-29 fl   add embedded default font\n# 2003-09-27 fl   added support for truetype charmap encodings\n#\n# Todo:\n# Adapt to PILFONT2 format (16-bit fonts, compressed, single file)\n#\n# Copyright (c) 1997-2003 by Secret Labs AB\n# Copyright (c) 1996-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import annotations\n\nimport base64\nimport os\nimport sys\nimport warnings\nfrom enum import IntEnum\nfrom io import BytesIO\nfrom types import ModuleType\nfrom typing import IO, TYPE_CHECKING, Any, BinaryIO\n\nfrom . import Image\nfrom ._typing import StrOrBytesPath\nfrom ._util import DeferredError, is_path\n\nif TYPE_CHECKING:\n    from . import ImageFile\n    from ._imaging import ImagingFont\n    from ._imagingft import Font\n\n\nclass Layout(IntEnum):\n    BASIC = 0\n    RAQM = 1\n\n\nMAX_STRING_LENGTH = 1_000_000\n\n\ncore: ModuleType | DeferredError\ntry:\n    from . import _imagingft as core\nexcept ImportError as ex:\n    core = DeferredError.new(ex)\n\n\ndef _string_length_check(text: str | bytes | bytearray) -> None:\n    if MAX_STRING_LENGTH is not None and len(text) > MAX_STRING_LENGTH:\n        msg = \"too many characters in string\"\n        raise ValueError(msg)\n\n\n# FIXME: add support for pilfont2 format (see FontFile.py)\n\n# --------------------------------------------------------------------\n# Font metrics format:\n#       \"PILfont\" LF\n#       fontdescriptor LF\n#       (optional) key=value... LF\n#       \"DATA\" LF\n#       binary data: 256*10*2 bytes (dx, dy, dstbox, srcbox)\n#\n# To place a character, cut out srcbox and paste at dstbox,\n# relative to the character position.  Then move the character\n# position according to dx, dy.\n# --------------------------------------------------------------------\n\n\nclass ImageFont:\n    \"\"\"PIL font wrapper\"\"\"\n\n    font: ImagingFont\n\n    def _load_pilfont(self, filename: str) -> None:\n        with open(filename, \"rb\") as fp:\n            image: ImageFile.ImageFile | None = None\n            for ext in (\".png\", \".gif\", \".pbm\"):\n                if image:\n                    image.close()\n                try:\n                    fullname = os.path.splitext(filename)[0] + ext\n                    image = Image.open(fullname)\n                except Exception:\n                    pass\n                else:\n                    if image and image.mode in (\"1\", \"L\"):\n                        break\n            else:\n                if image:\n                    image.close()\n                msg = \"cannot find glyph data file\"\n                raise OSError(msg)\n\n            self.file = fullname\n\n            self._load_pilfont_data(fp, image)\n            image.close()\n\n    def _load_pilfont_data(self, file: IO[bytes], image: Image.Image) -> None:\n        # read PILfont header\n        if file.readline() != b\"PILfont\\n\":\n            msg = \"Not a PILfont file\"\n            raise SyntaxError(msg)\n        file.readline().split(b\";\")\n        self.info = []  # FIXME: should be a dictionary\n        while True:\n            s = file.readline()\n            if not s or s == b\"DATA\\n\":\n                break\n            self.info.append(s)\n\n        # read PILfont metrics\n        data = file.read(256 * 20)\n\n        # check image\n        if image.mode not in (\"1\", \"L\"):\n            msg = \"invalid font image mode\"\n            raise TypeError(msg)\n\n        image.load()\n\n        self.font = Image.core.font(image.im, data)\n\n    def getmask(self, text, mode=\"\", *args, **kwargs):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :return: An internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module.\n        \"\"\"\n        _string_length_check(text)\n        Image._decompression_bomb_check(self.font.getsize(text))\n        return self.font.getmask(text, mode)\n\n    def getbbox(\n        self, text: str | bytes | bytearray, *args: Any, **kwargs: Any\n    ) -> tuple[int, int, int, int]:\n        \"\"\"\n        Returns bounding box (in pixels) of given text.\n\n        .. versionadded:: 9.2.0\n\n        :param text: Text to render.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n        \"\"\"\n        _string_length_check(text)\n        width, height = self.font.getsize(text)\n        return 0, 0, width, height\n\n    def getlength(\n        self, text: str | bytes | bytearray, *args: Any, **kwargs: Any\n    ) -> int:\n        \"\"\"\n        Returns length (in pixels) of given text.\n        This is the amount by which following text should be offset.\n\n        .. versionadded:: 9.2.0\n        \"\"\"\n        _string_length_check(text)\n        width, height = self.font.getsize(text)\n        return width\n\n\n##\n# Wrapper for FreeType fonts.  Application code should use the\n# <b>truetype</b> factory function to create font objects.\n\n\nclass FreeTypeFont:\n    \"\"\"FreeType font wrapper (requires _imagingft service)\"\"\"\n\n    font: Font\n    font_bytes: bytes\n\n    def __init__(\n        self,\n        font: StrOrBytesPath | BinaryIO | None = None,\n        size: float = 10,\n        index: int = 0,\n        encoding: str = \"\",\n        layout_engine: Layout | None = None,\n    ) -> None:\n        # FIXME: use service provider instead\n\n        if isinstance(core, DeferredError):\n            raise core.ex\n\n        if size <= 0:\n            msg = \"font size must be greater than 0\"\n            raise ValueError(msg)\n\n        self.path = font\n        self.size = size\n        self.index = index\n        self.encoding = encoding\n\n        if layout_engine not in (Layout.BASIC, Layout.RAQM):\n            layout_engine = Layout.BASIC\n            if core.HAVE_RAQM:\n                layout_engine = Layout.RAQM\n        elif layout_engine == Layout.RAQM and not core.HAVE_RAQM:\n            warnings.warn(\n                \"Raqm layout was requested, but Raqm is not available. \"\n                \"Falling back to basic layout.\"\n            )\n            layout_engine = Layout.BASIC\n\n        self.layout_engine = layout_engine\n\n        def load_from_bytes(f):\n            self.font_bytes = f.read()\n            self.font = core.getfont(\n                \"\", size, index, encoding, self.font_bytes, layout_engine\n            )\n\n        if is_path(font):\n            font = os.path.realpath(os.fspath(font))\n            if sys.platform == \"win32\":\n                font_bytes_path = font if isinstance(font, bytes) else font.encode()\n                try:\n                    font_bytes_path.decode(\"ascii\")\n                except UnicodeDecodeError:\n                    # FreeType cannot load fonts with non-ASCII characters on Windows\n                    # So load it into memory first\n                    with open(font, \"rb\") as f:\n                        load_from_bytes(f)\n                    return\n            self.font = core.getfont(\n                font, size, index, encoding, layout_engine=layout_engine\n            )\n        else:\n            load_from_bytes(font)\n\n    def __getstate__(self):\n        return [self.path, self.size, self.index, self.encoding, self.layout_engine]\n\n    def __setstate__(self, state):\n        path, size, index, encoding, layout_engine = state\n        self.__init__(path, size, index, encoding, layout_engine)\n\n    def getname(self) -> tuple[str | None, str | None]:\n        \"\"\"\n        :return: A tuple of the font family (e.g. Helvetica) and the font style\n            (e.g. Bold)\n        \"\"\"\n        return self.font.family, self.font.style\n\n    def getmetrics(self) -> tuple[int, int]:\n        \"\"\"\n        :return: A tuple of the font ascent (the distance from the baseline to\n            the highest outline point) and descent (the distance from the\n            baseline to the lowest outline point, a negative value)\n        \"\"\"\n        return self.font.ascent, self.font.descent\n\n    def getlength(\n        self, text: str, mode=\"\", direction=None, features=None, language=None\n    ) -> float:\n        \"\"\"\n        Returns length (in pixels with 1/64 precision) of given text when rendered\n        in font with provided direction, features, and language.\n\n        This is the amount by which following text should be offset.\n        Text bounding box may extend past the length in some fonts,\n        e.g. when using italics or accents.\n\n        The result is returned as a float; it is a whole number if using basic layout.\n\n        Note that the sum of two lengths may not equal the length of a concatenated\n        string due to kerning. If you need to adjust for kerning, include the following\n        character and subtract its length.\n\n        For example, instead of ::\n\n          hello = font.getlength(\"Hello\")\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # not adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # may fail\n\n        use ::\n\n          hello = font.getlength(\"HelloW\") - font.getlength(\"W\")  # adjusted for kerning\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # True\n\n        or disable kerning with (requires libraqm) ::\n\n          hello = draw.textlength(\"Hello\", font, features=[\"-kern\"])\n          world = draw.textlength(\"World\", font, features=[\"-kern\"])\n          hello_world = hello + world  # kerning is disabled, no need to adjust\n          assert hello_world == draw.textlength(\"HelloWorld\", font, features=[\"-kern\"])\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to measure.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :return: Either width for horizontal text, or height for vertical text.\n        \"\"\"\n        _string_length_check(text)\n        return self.font.getlength(text, mode, direction, features, language) / 64\n\n    def getbbox(\n        self,\n        text: str,\n        mode: str = \"\",\n        direction: str | None = None,\n        features: list[str] | None = None,\n        language: str | None = None,\n        stroke_width: float = 0,\n        anchor: str | None = None,\n    ) -> tuple[float, float, float, float]:\n        \"\"\"\n        Returns bounding box (in pixels) of given text relative to given anchor\n        when rendered in font with provided direction, features, and language.\n\n        Use :py:meth:`getlength()` to get the offset of following text with\n        1/64 pixel precision. The bounding box includes extra margins for\n        some fonts, e.g. italics or accents.\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :param stroke_width: The width of the text stroke.\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left,\n                        specifically ``la`` for horizontal text and ``lt`` for\n                        vertical text. See :ref:`text-anchors` for details.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n        \"\"\"\n        _string_length_check(text)\n        size, offset = self.font.getsize(\n            text, mode, direction, features, language, anchor\n        )\n        left, top = offset[0] - stroke_width, offset[1] - stroke_width\n        width, height = size[0] + 2 * stroke_width, size[1] + 2 * stroke_width\n        return left, top, left + width, top + height\n\n    def getmask(\n        self,\n        text,\n        mode=\"\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        anchor=None,\n        ink=0,\n        start=None,\n    ):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. If the font has embedded color data, the bitmap\n        should have mode ``RGBA``. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n                          .. versionadded:: 4.2.0\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n                         .. versionadded:: 4.2.0\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n                         .. versionadded:: 6.0.0\n\n        :param stroke_width: The width of the text stroke.\n\n                         .. versionadded:: 6.2.0\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left,\n                        specifically ``la`` for horizontal text and ``lt`` for\n                        vertical text. See :ref:`text-anchors` for details.\n\n                         .. versionadded:: 8.0.0\n\n        :param ink: Foreground ink for rendering in RGBA mode.\n\n                         .. versionadded:: 8.0.0\n\n        :param start: Tuple of horizontal and vertical offset, as text may render\n                      differently when starting at fractional coordinates.\n\n                         .. versionadded:: 9.4.0\n\n        :return: An internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module.\n        \"\"\"\n        return self.getmask2(\n            text,\n            mode,\n            direction=direction,\n            features=features,\n            language=language,\n            stroke_width=stroke_width,\n            anchor=anchor,\n            ink=ink,\n            start=start,\n        )[0]\n\n    def getmask2(\n        self,\n        text: str,\n        mode=\"\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        anchor=None,\n        ink=0,\n        start=None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. If the font has embedded color data, the bitmap\n        should have mode ``RGBA``. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n                          .. versionadded:: 4.2.0\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n                         .. versionadded:: 4.2.0\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n                         .. versionadded:: 6.0.0\n\n        :param stroke_width: The width of the text stroke.\n\n                         .. versionadded:: 6.2.0\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left,\n                        specifically ``la`` for horizontal text and ``lt`` for\n                        vertical text. See :ref:`text-anchors` for details.\n\n                         .. versionadded:: 8.0.0\n\n        :param ink: Foreground ink for rendering in RGBA mode.\n\n                         .. versionadded:: 8.0.0\n\n        :param start: Tuple of horizontal and vertical offset, as text may render\n                      differently when starting at fractional coordinates.\n\n                         .. versionadded:: 9.4.0\n\n        :return: A tuple of an internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module, and the text offset, the\n                 gap between the starting coordinate and the first marking\n        \"\"\"\n        _string_length_check(text)\n        if start is None:\n            start = (0, 0)\n\n        def fill(width, height):\n            size = (width, height)\n            Image._decompression_bomb_check(size)\n            return Image.core.fill(\"RGBA\" if mode == \"RGBA\" else \"L\", size)\n\n        return self.font.render(\n            text,\n            fill,\n            mode,\n            direction,\n            features,\n            language,\n            stroke_width,\n            anchor,\n            ink,\n            start[0],\n            start[1],\n        )\n\n    def font_variant(\n        self, font=None, size=None, index=None, encoding=None, layout_engine=None\n    ):\n        \"\"\"\n        Create a copy of this FreeTypeFont object,\n        using any specified arguments to override the settings.\n\n        Parameters are identical to the parameters used to initialize this\n        object.\n\n        :return: A FreeTypeFont object.\n        \"\"\"\n        if font is None:\n            try:\n                font = BytesIO(self.font_bytes)\n            except AttributeError:\n                font = self.path\n        return FreeTypeFont(\n            font=font,\n            size=self.size if size is None else size,\n            index=self.index if index is None else index,\n            encoding=self.encoding if encoding is None else encoding,\n            layout_engine=layout_engine or self.layout_engine,\n        )\n\n    def get_variation_names(self) -> list[bytes]:\n        \"\"\"\n        :returns: A list of the named styles in a variation font.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        try:\n            names = self.font.getvarnames()\n        except AttributeError as e:\n            msg = \"FreeType 2.9.1 or greater is required\"\n            raise NotImplementedError(msg) from e\n        return [name.replace(b\"\\x00\", b\"\") for name in names]\n\n    def set_variation_by_name(self, name):\n        \"\"\"\n        :param name: The name of the style.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        names = self.get_variation_names()\n        if not isinstance(name, bytes):\n            name = name.encode()\n        index = names.index(name) + 1\n\n        if index == getattr(self, \"_last_variation_index\", None):\n            # When the same name is set twice in a row,\n            # there is an 'unknown freetype error'\n            # https://savannah.nongnu.org/bugs/?56186\n            return\n        self._last_variation_index = index\n\n        self.font.setvarname(index)\n\n    def get_variation_axes(self):\n        \"\"\"\n        :returns: A list of the axes in a variation font.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        try:\n            axes = self.font.getvaraxes()\n        except AttributeError as e:\n            msg = \"FreeType 2.9.1 or greater is required\"\n            raise NotImplementedError(msg) from e\n        for axis in axes:\n            if axis[\"name\"]:\n                axis[\"name\"] = axis[\"name\"].replace(b\"\\x00\", b\"\")\n        return axes\n\n    def set_variation_by_axes(self, axes: list[float]) -> None:\n        \"\"\"\n        :param axes: A list of values for each axis.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        try:\n            self.font.setvaraxes(axes)\n        except AttributeError as e:\n            msg = \"FreeType 2.9.1 or greater is required\"\n            raise NotImplementedError(msg) from e\n\n\nclass TransposedFont:\n    \"\"\"Wrapper for writing rotated or mirrored text\"\"\"\n\n    def __init__(self, font, orientation=None):\n        \"\"\"\n        Wrapper that creates a transposed font from any existing font\n        object.\n\n        :param font: A font object.\n        :param orientation: An optional orientation.  If given, this should\n            be one of Image.Transpose.FLIP_LEFT_RIGHT, Image.Transpose.FLIP_TOP_BOTTOM,\n            Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_180, or\n            Image.Transpose.ROTATE_270.\n        \"\"\"\n        self.font = font\n        self.orientation = orientation  # any 'transpose' argument, or None\n\n    def getmask(self, text, mode=\"\", *args, **kwargs):\n        im = self.font.getmask(text, mode, *args, **kwargs)\n        if self.orientation is not None:\n            return im.transpose(self.orientation)\n        return im\n\n    def getbbox(self, text, *args, **kwargs):\n        # TransposedFont doesn't support getmask2, move top-left point to (0, 0)\n        # this has no effect on ImageFont and simulates anchor=\"lt\" for FreeTypeFont\n        left, top, right, bottom = self.font.getbbox(text, *args, **kwargs)\n        width = right - left\n        height = bottom - top\n        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):\n            return 0, 0, height, width\n        return 0, 0, width, height\n\n    def getlength(self, text: str, *args, **kwargs) -> float:\n        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):\n            msg = \"text length is undefined for text rotated by 90 or 270 degrees\"\n            raise ValueError(msg)\n        return self.font.getlength(text, *args, **kwargs)\n\n\ndef load(filename: str) -> ImageFont:\n    \"\"\"\n    Load a font file.  This function loads a font object from the given\n    bitmap font file, and returns the corresponding font object.\n\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    \"\"\"\n    f = ImageFont()\n    f._load_pilfont(filename)\n    return f\n\n\ndef truetype(\n    font: StrOrBytesPath | BinaryIO | None = None,\n    size: float = 10,\n    index: int = 0,\n    encoding: str = \"\",\n    layout_engine: Layout | None = None,\n) -> FreeTypeFont:\n    \"\"\"\n    Load a TrueType or OpenType font from a file or file-like object,\n    and create a font object.\n    This function loads a font object from the given file or file-like\n    object, and creates a font object for a font of the given size.\n\n    Pillow uses FreeType to open font files. On Windows, be aware that FreeType\n    will keep the file open as long as the FreeTypeFont object exists. Windows\n    limits the number of files that can be open in C at once to 512, so if many\n    fonts are opened simultaneously and that limit is approached, an\n    ``OSError`` may be thrown, reporting that FreeType \"cannot open resource\".\n    A workaround would be to copy the file(s) into memory, and open that instead.\n\n    This function requires the _imagingft service.\n\n    :param font: A filename or file-like object containing a TrueType font.\n                 If the file is not found in this filename, the loader may also\n                 search in other directories, such as:\n\n                 * The :file:`fonts/` directory on Windows,\n                 * :file:`/Library/Fonts/`, :file:`/System/Library/Fonts/`\n                   and :file:`~/Library/Fonts/` on macOS.\n                 * :file:`~/.local/share/fonts`, :file:`/usr/local/share/fonts`,\n                   and :file:`/usr/share/fonts` on Linux; or those specified by\n                   the ``XDG_DATA_HOME`` and ``XDG_DATA_DIRS`` environment variables\n                   for user-installed and system-wide fonts, respectively.\n\n    :param size: The requested size, in pixels.\n    :param index: Which font face to load (default is first available face).\n    :param encoding: Which font encoding to use (default is Unicode). Possible\n                     encodings include (see the FreeType documentation for more\n                     information):\n\n                     * \"unic\" (Unicode)\n                     * \"symb\" (Microsoft Symbol)\n                     * \"ADOB\" (Adobe Standard)\n                     * \"ADBE\" (Adobe Expert)\n                     * \"ADBC\" (Adobe Custom)\n                     * \"armn\" (Apple Roman)\n                     * \"sjis\" (Shift JIS)\n                     * \"gb  \" (PRC)\n                     * \"big5\"\n                     * \"wans\" (Extended Wansung)\n                     * \"joha\" (Johab)\n                     * \"lat1\" (Latin-1)\n\n                     This specifies the character set to use. It does not alter the\n                     encoding of any text provided in subsequent operations.\n    :param layout_engine: Which layout engine to use, if available:\n                     :attr:`.ImageFont.Layout.BASIC` or :attr:`.ImageFont.Layout.RAQM`.\n                     If it is available, Raqm layout will be used by default.\n                     Otherwise, basic layout will be used.\n\n                     Raqm layout is recommended for all non-English text. If Raqm layout\n                     is not required, basic layout will have better performance.\n\n                     You can check support for Raqm layout using\n                     :py:func:`PIL.features.check_feature` with ``feature=\"raqm\"``.\n\n                     .. versionadded:: 4.2.0\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    :exception ValueError: If the font size is not greater than zero.\n    \"\"\"\n\n    def freetype(font: StrOrBytesPath | BinaryIO | None) -> FreeTypeFont:\n        return FreeTypeFont(font, size, index, encoding, layout_engine)\n\n    try:\n        return freetype(font)\n    except OSError:\n        if not is_path(font):\n            raise\n        ttf_filename = os.path.basename(font)\n\n        dirs = []\n        if sys.platform == \"win32\":\n            # check the windows font repository\n            # NOTE: must use uppercase WINDIR, to work around bugs in\n            # 1.5.2's os.environ.get()\n            windir = os.environ.get(\"WINDIR\")\n            if windir:\n                dirs.append(os.path.join(windir, \"fonts\"))\n        elif sys.platform in (\"linux\", \"linux2\"):\n            data_home = os.environ.get(\"XDG_DATA_HOME\")\n            if not data_home:\n                # The freedesktop spec defines the following default directory for\n                # when XDG_DATA_HOME is unset or empty. This user-level directory\n                # takes precedence over system-level directories.\n                data_home = os.path.expanduser(\"~/.local/share\")\n            xdg_dirs = [data_home]\n\n            data_dirs = os.environ.get(\"XDG_DATA_DIRS\")\n            if not data_dirs:\n                # Similarly, defaults are defined for the system-level directories\n                data_dirs = \"/usr/local/share:/usr/share\"\n            xdg_dirs += data_dirs.split(\":\")\n\n            dirs += [os.path.join(xdg_dir, \"fonts\") for xdg_dir in xdg_dirs]\n        elif sys.platform == \"darwin\":\n            dirs += [\n                \"/Library/Fonts\",\n                \"/System/Library/Fonts\",\n                os.path.expanduser(\"~/Library/Fonts\"),\n            ]\n\n        ext = os.path.splitext(ttf_filename)[1]\n        first_font_with_a_different_extension = None\n        for directory in dirs:\n            for walkroot, walkdir, walkfilenames in os.walk(directory):\n                for walkfilename in walkfilenames:\n                    if ext and walkfilename == ttf_filename:\n                        return freetype(os.path.join(walkroot, walkfilename))\n                    elif not ext and os.path.splitext(walkfilename)[0] == ttf_filename:\n                        fontpath = os.path.join(walkroot, walkfilename)\n                        if os.path.splitext(fontpath)[1] == \".ttf\":\n                            return freetype(fontpath)\n                        if not ext and first_font_with_a_different_extension is None:\n                            first_font_with_a_different_extension = fontpath\n        if first_font_with_a_different_extension:\n            return freetype(first_font_with_a_different_extension)\n        raise\n\n\ndef load_path(filename: str | bytes) -> ImageFont:\n    \"\"\"\n    Load font file. Same as :py:func:`~PIL.ImageFont.load`, but searches for a\n    bitmap font along the Python path.\n\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    \"\"\"\n    if not isinstance(filename, str):\n        filename = filename.decode(\"utf-8\")\n    for directory in sys.path:\n        try:\n            return load(os.path.join(directory, filename))\n        except OSError:\n            pass\n    msg = \"cannot find font file\"\n    raise OSError(msg)\n\n\ndef load_default(size: float | None = None) -> FreeTypeFont | ImageFont:\n    \"\"\"If FreeType support is available, load a version of Aileron Regular,\n    https://dotcolon.net/font/aileron, with a more limited character set.\n\n    Otherwise, load a \"better than nothing\" font.\n\n    .. versionadded:: 1.1.4\n\n    :param size: The font size of Aileron Regular.\n\n        .. versionadded:: 10.1.0\n\n    :return: A font object.\n    \"\"\"\n    f: FreeTypeFont | ImageFont\n    if isinstance(core, ModuleType) or size is not None:\n        f = truetype(\n            BytesIO(\n                base64.b64decode(\n                    b\"\"\"\nAAEAAAAPAIAAAwBwRkZUTYwDlUAAADFoAAAAHEdERUYAqADnAAAo8AAAACRHUE9ThhmITwAAKfgAA\nAduR1NVQnHxefoAACkUAAAA4k9TLzJovoHLAAABeAAAAGBjbWFw5lFQMQAAA6gAAAGqZ2FzcP//AA\nMAACjoAAAACGdseWYmRXoPAAAGQAAAHfhoZWFkE18ayQAAAPwAAAA2aGhlYQboArEAAAE0AAAAJGh\ntdHjjERZ8AAAB2AAAAdBsb2NhuOexrgAABVQAAADqbWF4cAC7AEYAAAFYAAAAIG5hbWUr+h5lAAAk\nOAAAA6Jwb3N0D3oPTQAAJ9wAAAEKAAEAAAABGhxJDqIhXw889QALA+gAAAAA0Bqf2QAAAADhCh2h/\n2r/LgOxAyAAAAAIAAIAAAAAAAAAAQAAA8r/GgAAA7j/av9qA7EAAQAAAAAAAAAAAAAAAAAAAHQAAQ\nAAAHQAQwAFAAAAAAACAAAAAQABAAAAQAAAAAAAAAADAfoBkAAFAAgCigJYAAAASwKKAlgAAAFeADI\nBPgAAAAAFAAAAAAAAAAAAAAcAAAAAAAAAAAAAAABVS1dOAEAAIPsCAwL/GgDIA8oA5iAAAJMAAAAA\nAhICsgAAACAAAwH0AAAAAAAAAU0AAADYAAAA8gA5AVMAVgJEAEYCRAA1AuQAKQKOAEAAsAArATsAZ\nAE7AB4CMABVAkQAUADc/+EBEgAgANwAJQEv//sCRAApAkQAggJEADwCRAAtAkQAIQJEADkCRAArAk\nQAMgJEACwCRAAxANwAJQDc/+ECRABnAkQAUAJEAEQB8wAjA1QANgJ/AB0CcwBkArsALwLFAGQCSwB\nkAjcAZALGAC8C2gBkAQgAZAIgADcCYQBkAj8AZANiAGQCzgBkAuEALwJWAGQC3QAvAmsAZAJJADQC\nZAAiAqoAXgJuACADuAAaAnEAGQJFABMCTwAuATMAYgEv//sBJwAiAkQAUAH0ADIBLAApAhMAJAJjA\nEoCEQAeAmcAHgIlAB4BIgAVAmcAHgJRAEoA7gA+AOn/8wIKAEoA9wBGA1cASgJRAEoCSgAeAmMASg\nJnAB4BSgBKAcsAGAE5ABQCUABCAgIAAQMRAAEB4v/6AgEAAQHOABQBLwBAAPoAYAEvACECRABNA0Y\nAJAItAHgBKgAcAkQAUAEsAHQAygAgAi0AOQD3ADYA9wAWAaEANgGhABYCbAAlAYMAeAGDADkA6/9q\nAhsAFAIKABUB/QAVAAAAAwAAAAMAAAAcAAEAAAAAAKQAAwABAAAAHAAEAIgAAAAeABAAAwAOAH4Aq\nQCrALEAtAC3ALsgGSAdICYgOiBEISL7Av//AAAAIACpAKsAsAC0ALcAuyAYIBwgJiA5IEQhIvsB//\n//4/+5/7j/tP+y/7D/reBR4E/gR+A14CzfTwVxAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAEGAAABAAAAAAAAAAECAAAAAgAAAAAAAAAAAAAAAAAAAAEAAAMEBQYHCAkKCwwNDg8QERIT\nFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMT\nU5PUFFSU1RVVldYWVpbXF1eX2BhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQAAA\nAAAAAAYnFmAAAAAABlAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2htAAAAAAAAAABrbGlqAAAAAHAAbm9\nycwBnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmACYAJgAmAD4AUgCCAMoBCgFO\nAVwBcgGIAaYBvAHKAdYB6AH2AgwCIAJKAogCpgLWAw4DIgNkA5wDugPUA+gD/AQQBEYEogS8BPoFJ\ngVSBWoFgAWwBcoF1gX6BhQGJAZMBmgGiga0BuIHGgdUB2YHkAeiB8AH3AfyCAoIHAgqCDoITghcCG\noIogjSCPoJKglYCXwJwgnqCgIKKApACl4Klgq8CtwLDAs8C1YLjAuyC9oL7gwMDCYMSAxgDKAMrAz\nqDQoNTA1mDYQNoA2uDcAN2g3oDfYODA4iDkoOXA5sDnoOnA7EDvwAAAAFAAAAAAH0ArwAAwAGAAkA\nDAAPAAAxESERAxMhExcRASELARETAfT6qv6syKr+jgFUqsiqArz9RAGLAP/+1P8B/v3VAP8BLP4CA\nP8AAgA5//IAuQKyAAMACwAANyMDMwIyFhQGIiY0oE4MZk84JCQ4JLQB/v3AJDgkJDgAAgBWAeUBPA\nLfAAMABwAAEyMnMxcjJzOmRgpagkYKWgHl+vr6AAAAAAIARgAAAf4CsgAbAB8AAAEHMxUjByM3Iwc\njNyM1MzcjNTM3MwczNzMHMxUrAQczAZgdZXEvOi9bLzovWmYdZXEvOi9bLzovWp9bHlsBn4w429vb\n2ziMONvb29s4jAAAAAMANf+mAg4DDAAfACYALAAAJRQGBxUjNS4BJzMeARcRLgE0Njc1MxUeARcjJ\nicVHgEBFBYXNQ4BExU+ATU0Ag5xWDpgcgRcBz41Xl9oVTpVYwpcC1ttXP6cLTQuM5szOrVRZwlOTQ\nZqVzZECAEAGlukZAlOTQdrUG8O7iNlAQgxNhDlCDj+8/YGOjReAAAAAAUAKf/yArsCvAAHAAsAFQA\ndACcAABIyFhQGIiY0EyMBMwQiBhUUFjI2NTQSMhYUBiImNDYiBhUUFjI2NTR5iFBQiFCVVwHAV/5c\nOiMjOiPmiFBQiFCxOiMjOiMCvFaSVlaS/ZoCsjIzMC80NC8w/uNWklZWkhozMC80NC8wAAAAAgBA/\n/ICbgLAACIALgAAARUjEQYjIiY1NDY3LgE1NDYzMhcVJiMiBhUUFhcWOwE1MxUFFBYzMjc1IyIHDg\nECbmBcYYOOVkg7R4hsQjY4Q0RNRD4SLDxW/pJUXzksPCkUUk0BgUb+zBVUZ0BkDw5RO1huCkULQzp\nCOAMBcHDHRz0J/AIHRQAAAAEAKwHlAIUC3wADAAATIycze0YKWgHl+gAAAAABAGT/sAEXAwwACQAA\nEzMGEBcjLgE0Nt06dXU6OUBAAwzG/jDGVePs4wAAAAEAHv+wANEDDAAJAAATMx4BFAYHIzYQHjo5Q\nEA5OnUDDFXj7ONVxgHQAAAAAQBVAFIB2wHbAA4AAAE3FwcXBycHJzcnNxcnMwEtmxOfcTJjYzJxnx\nObCj4BKD07KYolmZkliik7PbMAAQBQAFUB9AIlAAsAAAEjFSM1IzUzNTMVMwH0tTq1tTq1AR/Kyjj\nOzgAAAAAB/+H/iACMAGQABAAANwcjNzOMWlFOXVrS3AAAAQAgAP8A8gE3AAMAABMjNTPy0tIA/zgA\nAQAl//IApQByAAcAADYyFhQGIiY0STgkJDgkciQ4JCQ4AAAAAf/7/+IBNALQAAMAABcjEzM5Pvs+H\ngLuAAAAAAIAKf/yAhsCwAADAAcAABIgECA2IBAgKQHy/g5gATL+zgLA/TJEAkYAAAAAAQCCAAABlg\nKyAAgAAAERIxEHNTc2MwGWVr6SIygCsv1OAldxW1sWAAEAPAAAAg4CwAAZAAA3IRUhNRM+ATU0JiM\niDwEjNz4BMzIWFRQGB7kBUv4x+kI2QTt+EAFWAQp8aGVtSl5GRjEA/0RVLzlLmAoKa3FsUkNxXQAA\nAAEALf/yAhYCwAAqAAABHgEVFAYjIi8BMxceATMyNjU0KwE1MzI2NTQmIyIGDwEjNz4BMzIWFRQGA\nYxBSZJo2RUBVgEHV0JBUaQREUBUQzc5TQcBVgEKfGhfcEMBbxJbQl1x0AoKRkZHPn9GSD80QUVCCg\npfbGBPOlgAAAACACEAAAIkArIACgAPAAAlIxUjNSE1ATMRMyMRBg8BAiRXVv6qAVZWV60dHLCurq4\nrAdn+QgFLMibzAAABADn/8gIZArIAHQAAATIWFRQGIyIvATMXFjMyNjU0JiMiByMTIRUhBzc2ATNv\nd5Fl1RQBVgIad0VSTkVhL1IwAYj+vh8rMAHHgGdtgcUKCoFXTU5bYgGRRvAuHQAAAAACACv/8gITA\nsAAFwAjAAABMhYVFAYjIhE0NjMyFh8BIycmIyIDNzYTMjY1NCYjIgYVFBYBLmp7imr0l3RZdAgBXA\nIYZ5wKJzU6QVNJSz5SUAHSgWltiQFGxcNlVQoKdv7sPiz+ZF1LTmJbU0lhAAAAAQAyAAACGgKyAAY\nAAAEVASMBITUCGv6oXAFL/oECsij9dgJsRgAAAAMALP/xAhgCwAAWACAALAAAAR4BFRQGIyImNTQ2\nNy4BNTQ2MhYVFAYmIgYVFBYyNjU0AzI2NTQmIyIGFRQWAZQ5S5BmbIpPOjA7ecp5P2F8Q0J8RIVJS\n0pLTEtOAW0TXTxpZ2ZqPF0SE1A3VWVlVTdQ/UU0N0RENzT9/ko+Ok1NOj1LAAIAMf/yAhkCwAAXAC\nMAAAEyERQGIyImLwEzFxYzMhMHBiMiJjU0NhMyNjU0JiMiBhUUFgEl9Jd0WXQIAVwCGGecCic1SWp\n7imo+UlBAQVNJAsD+usXDZVUKCnYBFD4sgWltif5kW1NJYV1LTmIAAAACACX/8gClAiAABwAPAAAS\nMhYUBiImNBIyFhQGIiY0STgkJDgkJDgkJDgkAiAkOCQkOP52JDgkJDgAAAAC/+H/iAClAiAABwAMA\nAASMhYUBiImNBMHIzczSTgkJDgkaFpSTl4CICQ4JCQ4/mba5gAAAQBnAB4B+AH0AAYAAAENARUlNS\nUB+P6qAVb+bwGRAbCmpkbJRMkAAAIAUAC7AfQBuwADAAcAAAEhNSERITUhAfT+XAGk/lwBpAGDOP8\nAOAABAEQAHgHVAfQABgAAARUFNS0BNQHV/m8BVv6qAStEyUSmpkYAAAAAAgAj//IB1ALAABgAIAAA\nATIWFRQHDgEHIz4BNz4BNTQmIyIGByM+ARIyFhQGIiY0AQRibmktIAJWBSEqNig+NTlHBFoDezQ4J\nCQ4JALAZ1BjaS03JS1DMD5LLDQ/SUVgcv2yJDgkJDgAAAAAAgA2/5gDFgKYADYAQgAAAQMGFRQzMj\nY1NCYjIg4CFRQWMzI2NxcGIyImNTQ+AjMyFhUUBiMiJwcGIyImNTQ2MzIfATcHNzYmIyIGFRQzMjY\nCej8EJjJJlnBAfGQ+oHtAhjUYg5OPx0h2k06Os3xRWQsVLjY5VHtdPBwJETcJDyUoOkZEJz8B0f74\nEQ8kZl6EkTFZjVOLlyknMVm1pmCiaTq4lX6CSCknTVRmmR8wPdYnQzxuSWVGAAIAHQAAAncCsgAHA\nAoAACUjByMTMxMjATMDAcj+UVz4dO5d/sjPZPT0ArL9TgE6ATQAAAADAGQAAAJMArIAEAAbACcAAA\nEeARUUBgcGKwERMzIXFhUUJRUzMjc2NTQnJiMTPgE1NCcmKwEVMzIBvkdHZkwiNt7LOSGq/oeFHBt\nhahIlSTM+cB8Yj5UWAW8QT0VYYgwFArIEF5Fv1eMED2NfDAL93AU+N24PBP0AAAAAAQAv//ICjwLA\nABsAAAEyFh8BIycmIyIGFRQWMzI/ATMHDgEjIiY1NDYBdX+PCwFWAiKiaHx5ZaIiAlYBCpWBk6a0A\nsCAagoKpqN/gaOmCgplhcicn8sAAAIAZAAAAp8CsgAMABkAAAEeARUUBgcGKwERMzITPgE1NCYnJi\nsBETMyAY59lJp8IzXN0jUVWmdjWRs5d3I4Aq4QqJWUug8EArL9mQ+PeHGHDgX92gAAAAABAGQAAAI\nvArIACwAAJRUhESEVIRUhFSEVAi/+NQHB/pUBTf6zRkYCskbwRvAAAAABAGQAAAIlArIACQAAExUh\nFSERIxEhFboBQ/69VgHBAmzwRv7KArJGAAAAAAEAL//yAo8CwAAfAAABMxEjNQcGIyImNTQ2MzIWH\nwEjJyYjIgYVFBYzMjY1IwGP90wfPnWTprSSf48LAVYCIqJofHllVG+hAU3+s3hARsicn8uAagoKpq\nN/gaN1XAAAAAEAZAAAAowCsgALAAABESMRIREjETMRIRECjFb+hFZWAXwCsv1OAS7+0gKy/sQBPAA\nAAAABAGQAAAC6ArIAAwAAMyMRM7pWVgKyAAABADf/8gHoArIAEwAAAREUBw4BIyImLwEzFxYzMjc2\nNREB6AIFcGpgbQIBVgIHfXQKAQKy/lYxIltob2EpKYyEFD0BpwAAAAABAGQAAAJ0ArIACwAACQEjA\nwcVIxEzEQEzATsBJ3ntQlZWAVVlAWH+nwEnR+ACsv6RAW8AAQBkAAACLwKyAAUAACUVIREzEQIv/j\nVWRkYCsv2UAAABAGQAAAMUArIAFAAAAREjETQ3BgcDIwMmJxYVESMRMxsBAxRWAiMxemx8NxsCVo7\nMywKy/U4BY7ZLco7+nAFmoFxLtP6dArL9lwJpAAAAAAEAZAAAAoACsgANAAAhIwEWFREjETMBJjUR\nMwKAhP67A1aEAUUDVAJeeov+pwKy/aJ5jAFZAAAAAgAv//ICuwLAAAkAEwAAEiAWFRQGICY1NBIyN\njU0JiIGFRTbATSsrP7MrNrYenrYegLAxaKhxsahov47nIeIm5uIhwACAGQAAAJHArIADgAYAAABHg\nEVFAYHBisBESMRMzITNjQnJisBETMyAZRUX2VOHzuAVtY7GlxcGDWIiDUCrgtnVlVpCgT+5gKy/rU\nV1BUF/vgAAAACAC//zAK9AsAAEgAcAAAlFhcHJiMiBwYjIiY1NDYgFhUUJRQWMjY1NCYiBgI9PUMx\nUDcfKh8omqysATSs/dR62Hp62HpICTg7NgkHxqGixcWitbWHnJyHiJubAAIAZAAAAlgCsgAXACMAA\nCUWFyMmJyYnJisBESMRMzIXHgEVFAYHFiUzMjc+ATU0JyYrAQIqDCJfGQwNWhAhglbiOx9QXEY1Tv\n6bhDATMj1lGSyMtYgtOXR0BwH+1wKyBApbU0BSESRAAgVAOGoQBAABADT/8gIoAsAAJQAAATIWFyM\nuASMiBhUUFhceARUUBiMiJiczHgEzMjY1NCYnLgE1NDYBOmd2ClwGS0E6SUNRdW+HZnKKC1wPWkQ9\nUk1cZGuEAsBwXUJHNjQ3OhIbZVZZbm5kREo+NT5DFRdYUFdrAAAAAAEAIgAAAmQCsgAHAAABIxEjE\nSM1IQJk9lb2AkICbP2UAmxGAAEAXv/yAmQCsgAXAAABERQHDgEiJicmNREzERQXHgEyNjc2NRECZA\nIIgfCBCAJWAgZYmlgGAgKy/k0qFFxzc1wUKgGz/lUrEkRQUEQSKwGrAAAAAAEAIAAAAnoCsgAGAAA\nhIwMzGwEzAYJ07l3N1FwCsv2PAnEAAAEAGgAAA7ECsgAMAAABAyMLASMDMxsBMxsBA7HAcZyicrZi\nkaB0nJkCsv1OAlP9rQKy/ZsCW/2kAmYAAAEAGQAAAm8CsgALAAAhCwEjEwMzGwEzAxMCCsrEY/bkY\nre+Y/D6AST+3AFcAVb+5gEa/q3+oQAAAQATAAACUQKyAAgAAAERIxEDMxsBMwFdVvRjwLphARD+8A\nEQAaL+sQFPAAABAC4AAAI5ArIACQAAJRUhNQEhNSEVAQI5/fUBof57Aen+YUZGQgIqRkX92QAAAAA\nBAGL/sAEFAwwABwAAARUjETMVIxEBBWlpowMMOP0UOANcAAAB//v/4gE0AtAAAwAABSMDMwE0Pvs+\nHgLuAAAAAQAi/7AAxQMMAAcAABcjNTMRIzUzxaNpaaNQOALsOAABAFAA1wH0AmgABgAAJQsBIxMzE\nwGwjY1GsESw1wFZ/qcBkf5vAAAAAQAy/6oBwv/iAAMAAAUhNSEBwv5wAZBWOAAAAAEAKQJEALYCsg\nADAAATIycztjhVUAJEbgAAAAACACT/8gHQAiAAHQAlAAAhJwcGIyImNTQ2OwE1NCcmIyIHIz4BMzI\nXFh0BFBcnMjY9ASYVFAF6CR0wVUtgkJoiAgdgaQlaBm1Zrg4DCuQ9R+5MOSFQR1tbDiwUUXBUXowf\nJ8c9SjRORzYSgVwAAAAAAgBK//ICRQLfABEAHgAAATIWFRQGIyImLwEVIxEzETc2EzI2NTQmIyIGH\nQEUFgFUcYCVbiNJEyNWVigySElcU01JXmECIJd4i5QTEDRJAt/+3jkq/hRuZV55ZWsdX14AAQAe//\nIB9wIgABgAAAEyFhcjJiMiBhUUFjMyNjczDgEjIiY1NDYBF152DFocbEJXU0A1Rw1aE3pbaoKQAiB\noWH5qZm1tPDlaXYuLgZcAAAACAB7/8gIZAt8AEQAeAAABESM1BwYjIiY1NDYzMhYfAREDMjY9ATQm\nIyIGFRQWAhlWKDJacYCVbiNJEyOnSV5hQUlcUwLf/SFVOSqXeIuUExA0ARb9VWVrHV9ebmVeeQACA\nB7/8gH9AiAAFQAbAAABFAchHgEzMjY3Mw4BIyImNTQ2MzIWJyIGByEmAf0C/oAGUkA1SwlaD4FXbI\nWObmt45UBVBwEqDQEYFhNjWD84W16Oh3+akU9aU60AAAEAFQAAARoC8gAWAAATBh0BMxUjESMRIzU\nzNTQ3PgEzMhcVJqcDbW1WOTkDB0k8Hx5oAngVITRC/jQBzEIsJRs5PwVHEwAAAAIAHv8uAhkCIAAi\nAC8AAAERFAcOASMiLwEzFx4BMzI2NzY9AQcGIyImNTQ2MzIWHwE1AzI2PQE0JiMiBhUUFgIZAQSEd\nNwRAVcBBU5DTlUDASgyWnGAlW4jSRMjp0leYUFJXFMCEv5wSh1zeq8KCTI8VU0ZIQk5Kpd4i5QTED\nRJ/iJlax1fXm5lXnkAAQBKAAACCgLkABcAAAEWFREjETQnLgEHDgEdASMRMxE3NjMyFgIIAlYCBDs\n6RVRWViE5UVViAYUbQP7WASQxGzI7AQJyf+kC5P7TPSxUAAACAD4AAACsAsAABwALAAASMhYUBiIm\nNBMjETNeLiAgLiBiVlYCwCAuICAu/WACEgAC//P/LgCnAsAABwAVAAASMhYUBiImNBcRFAcGIyInN\nRY3NjURWS4gIC4gYgMLcRwNSgYCAsAgLiAgLo79wCUbZAJGBzMOHgJEAAAAAQBKAAACCALfAAsAAC\nEnBxUjETMREzMHEwGTwTJWVvdu9/rgN6kC3/4oAQv6/ugAAQBG//wA3gLfAA8AABMRFBceATcVBiM\niJicmNRGcAQIcIxkkKi4CAQLf/bkhERoSBD4EJC8SNAJKAAAAAQBKAAADEAIgACQAAAEWFREjETQn\nJiMiFREjETQnJiMiFREjETMVNzYzMhYXNzYzMhYDCwVWBAxedFYEDF50VlYiJko7ThAvJkpEVAGfI\njn+vAEcQyRZ1v76ARxDJFnW/voCEk08HzYtRB9HAAAAAAEASgAAAgoCIAAWAAABFhURIxE0JyYjIg\nYdASMRMxU3NjMyFgIIAlYCCXBEVVZWITlRVWIBhRtA/tYBJDEbbHR/6QISWz0sVAAAAAACAB7/8gI\nsAiAABwARAAASIBYUBiAmNBIyNjU0JiIGFRSlAQCHh/8Ah7ieWlqeWgIgn/Cfn/D+s3ZfYHV1YF8A\nAgBK/zwCRQIgABEAHgAAATIWFRQGIyImLwERIxEzFTc2EzI2NTQmIyIGHQEUFgFUcYCVbiNJEyNWV\nigySElcU01JXmECIJd4i5QTEDT+8wLWVTkq/hRuZV55ZWsdX14AAgAe/zwCGQIgABEAHgAAAREjEQ\ncGIyImNTQ2MzIWHwE1AzI2PQE0JiMiBhUUFgIZVigyWnGAlW4jSRMjp0leYUFJXFMCEv0qARk5Kpd\n4i5QTEDRJ/iJlax1fXm5lXnkAAQBKAAABPgIeAA0AAAEyFxUmBhURIxEzFTc2ARoWDkdXVlYwIwIe\nB0EFVlf+0gISU0cYAAEAGP/yAa0CIAAjAAATMhYXIyYjIgYVFBYXHgEVFAYjIiYnMxYzMjY1NCYnL\ngE1NDbkV2MJWhNdKy04PF1XbVhWbgxaE2ktOjlEUllkAiBaS2MrJCUoEBlPQkhOVFZoKCUmLhIWSE\nBIUwAAAAEAFP/4ARQCiQAXAAATERQXHgE3FQYjIiYnJjURIzUzNTMVMxWxAQMmMx8qMjMEAUdHVmM\nBzP7PGw4mFgY/BSwxDjQBNUJ7e0IAAAABAEL/8gICAhIAFwAAAREjNQcGIyImJyY1ETMRFBceATMy\nNj0BAgJWITlRT2EKBVYEBkA1RFECEv3uWj4qTToiOQE+/tIlJC43c4DpAAAAAAEAAQAAAfwCEgAGA\nAABAyMDMxsBAfzJaclfop8CEv3uAhL+LQHTAAABAAEAAAMLAhIADAAAAQMjCwEjAzMbATMbAQMLqW\nZ2dmapY3t0a3Z7AhL97gG+/kICEv5AAcD+QwG9AAAB//oAAAHWAhIACwAAARMjJwcjEwMzFzczARq\n8ZIuKY763ZoWFYwEO/vLV1QEMAQbNzQAAAQAB/y4B+wISABEAAAEDDgEjIic1FjMyNj8BAzMbAQH7\n2iFZQB8NDRIpNhQH02GenQIS/cFVUAJGASozEwIt/i4B0gABABQAAAGxAg4ACQAAJRUhNQEhNSEVA\nQGx/mMBNP7iAYL+zkREQgGIREX+ewAAAAABAED/sAEOAwwALAAAASMiBhUUFxYVFAYHHgEVFAcGFR\nQWOwEVIyImNTQ3NjU0JzU2NTQnJjU0NjsBAQ4MKiMLDS4pKS4NCyMqDAtERAwLUlILDERECwLUGBk\nWTlsgKzUFBTcrIFtOFhkYOC87GFVMIkUIOAhFIkxVGDsvAAAAAAEAYP84AJoDIAADAAAXIxEzmjo6\nyAPoAAEAIf+wAO8DDAAsAAATFQYVFBcWFRQGKwE1MzI2NTQnJjU0NjcuATU0NzY1NCYrATUzMhYVF\nAcGFRTvUgsMREQLDCojCw0uKSkuDQsjKgwLREQMCwF6OAhFIkxVGDsvOBgZFk5bICs1BQU3KyBbTh\nYZGDgvOxhVTCJFAAABAE0A3wH2AWQAEwAAATMUIyImJyYjIhUjNDMyFhcWMzIBvjhuGywtQR0xOG4\nbLC1BHTEBZIURGCNMhREYIwAAAwAk/94DIgLoAAcAEQApAAAAIBYQBiAmECQgBhUUFiA2NTQlMhYX\nIyYjIgYUFjMyNjczDgEjIiY1NDYBAQFE3d3+vN0CB/7wubkBELn+xVBnD1wSWDo+QTcqOQZcEmZWX\nHN2Aujg/rbg4AFKpr+Mjb6+jYxbWEldV5ZZNShLVn5na34AAgB4AFIB9AGeAAUACwAAAQcXIyc3Mw\ncXIyc3AUqJiUmJifOJiUmJiQGepqampqampqYAAAIAHAHSAQ4CwAAHAA8AABIyFhQGIiY0NiIGFBY\nyNjRgakREakSTNCEhNCECwEJqQkJqCiM4IyM4AAAAAAIAUAAAAfQCCwALAA8AAAEzFSMVIzUjNTM1\nMxMhNSEBP7W1OrW1OrX+XAGkAVs4tLQ4sP31OAAAAQB0AkQBAQKyAAMAABMjNzOsOD1QAkRuAAAAA\nAEAIADsAKoBdgAHAAASMhYUBiImNEg6KCg6KAF2KDooKDoAAAIAOQBSAbUBngAFAAsAACUHIzcnMw\nUHIzcnMwELiUmJiUkBM4lJiYlJ+KampqampqYAAAABADYB5QDhAt8ABAAAEzczByM2Xk1OXQHv8Po\nAAQAWAeUAwQLfAAQAABMHIzczwV5NTl0C1fD6AAIANgHlAYsC3wAEAAkAABM3MwcjPwEzByM2Xk1O\nXapeTU5dAe/w+grw+gAAAgAWAeUBawLfAAQACQAAEwcjNzMXByM3M8FeTU5dql5NTl0C1fD6CvD6A\nAADACX/8gI1AHIABwAPABcAADYyFhQGIiY0NjIWFAYiJjQ2MhYUBiImNEk4JCQ4JOw4JCQ4JOw4JC\nQ4JHIkOCQkOCQkOCQkOCQkOCQkOAAAAAEAeABSAUoBngAFAAABBxcjJzcBSomJSYmJAZ6mpqamAAA\nAAAEAOQBSAQsBngAFAAAlByM3JzMBC4lJiYlJ+KampgAAAf9qAAABgQKyAAMAACsBATM/VwHAVwKy\nAAAAAAIAFAHIAdwClAAHABQAABMVIxUjNSM1BRUjNwcjJxcjNTMXN9pKMkoByDICKzQqATJLKysCl\nCmjoykBy46KiY3Lm5sAAQAVAAABvALyABgAAAERIxEjESMRIzUzNTQ3NjMyFxUmBgcGHQEBvFbCVj\nk5AxHHHx5iVgcDAg798gHM/jQBzEIOJRuWBUcIJDAVIRYAAAABABX//AHkAvIAJQAAJR4BNxUGIyI\nmJyY1ESYjIgcGHQEzFSMRIxEjNTM1NDc2MzIXERQBowIcIxkkKi4CAR4nXgwDbW1WLy8DEbNdOmYa\nEQQ/BCQvEjQCFQZWFSEWQv40AcxCDiUblhP9uSEAAAAAAAAWAQ4AAQAAAAAAAAATACgAAQAAAAAAA\nQAHAEwAAQAAAAAAAgAHAGQAAQAAAAAAAwAaAKIAAQAAAAAABAAHAM0AAQAAAAAABQA8AU8AAQAAAA\nAABgAPAawAAQAAAAAACAALAdQAAQAAAAAACQALAfgAAQAAAAAACwAXAjQAAQAAAAAADAAXAnwAAwA\nBBAkAAAAmAAAAAwABBAkAAQAOADwAAwABBAkAAgAOAFQAAwABBAkAAwA0AGwAAwABBAkABAAOAL0A\nAwABBAkABQB4ANUAAwABBAkABgAeAYwAAwABBAkACAAWAbwAAwABBAkACQAWAeAAAwABBAkACwAuA\ngQAAwABBAkADAAuAkwATgBvACAAUgBpAGcAaAB0AHMAIABSAGUAcwBlAHIAdgBlAGQALgAATm8gUm\nlnaHRzIFJlc2VydmVkLgAAQQBpAGwAZQByAG8AbgAAQWlsZXJvbgAAUgBlAGcAdQBsAGEAcgAAUmV\nndWxhcgAAMQAuADEAMAAyADsAVQBLAFcATgA7AEEAaQBsAGUAcgBvAG4ALQBSAGUAZwB1AGwAYQBy\nAAAxLjEwMjtVS1dOO0FpbGVyb24tUmVndWxhcgAAQQBpAGwAZQByAG8AbgAAQWlsZXJvbgAAVgBlA\nHIAcwBpAG8AbgAgADEALgAxADAAMgA7AFAAUwAgADAAMAAxAC4AMQAwADIAOwBoAG8AdABjAG8Abg\nB2ACAAMQAuADAALgA3ADAAOwBtAGEAawBlAG8AdABmAC4AbABpAGIAMgAuADUALgA1ADgAMwAyADk\nAAFZlcnNpb24gMS4xMDI7UFMgMDAxLjEwMjtob3Rjb252IDEuMC43MDttYWtlb3RmLmxpYjIuNS41\nODMyOQAAQQBpAGwAZQByAG8AbgAtAFIAZQBnAHUAbABhAHIAAEFpbGVyb24tUmVndWxhcgAAUwBvA\nHIAYQAgAFMAYQBnAGEAbgBvAABTb3JhIFNhZ2FubwAAUwBvAHIAYQAgAFMAYQBnAGEAbgBvAABTb3\nJhIFNhZ2FubwAAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGQAbwB0AGMAbwBsAG8AbgAuAG4AZQB0AAB\nodHRwOi8vd3d3LmRvdGNvbG9uLm5ldAAAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGQAbwB0AGMAbwBs\nAG8AbgAuAG4AZQB0AABodHRwOi8vd3d3LmRvdGNvbG9uLm5ldAAAAAACAAAAAAAA/4MAMgAAAAAAA\nAAAAAAAAAAAAAAAAAAAAHQAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATAB\nQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAA\nxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0A\nTgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAIsAqQCDAJMAjQDDAKoAtgC3A\nLQAtQCrAL4AvwC8AIwAwADBAAAAAAAB//8AAgABAAAADAAAABwAAAACAAIAAwBxAAEAcgBzAAIABA\nAAAAIAAAABAAAACgBMAGYAAkRGTFQADmxhdG4AGgAEAAAAAP//AAEAAAAWAANDQVQgAB5NT0wgABZ\nST00gABYAAP//AAEAAAAA//8AAgAAAAEAAmxpZ2EADmxvY2wAFAAAAAEAAQAAAAEAAAACAAYAEAAG\nAAAAAgASADQABAAAAAEATAADAAAAAgAQABYAAQAcAAAAAQABAE8AAQABAGcAAQABAE8AAwAAAAIAE\nAAWAAEAHAAAAAEAAQAvAAEAAQBnAAEAAQAvAAEAGgABAAgAAgAGAAwAcwACAE8AcgACAEwAAQABAE\nkAAAABAAAACgBGAGAAAkRGTFQADmxhdG4AHAAEAAAAAP//AAIAAAABABYAA0NBVCAAFk1PTCAAFlJ\nPTSAAFgAA//8AAgAAAAEAAmNwc3AADmtlcm4AFAAAAAEAAAAAAAEAAQACAAYADgABAAAAAQASAAIA\nAAACAB4ANgABAAoABQAFAAoAAgABACQAPQAAAAEAEgAEAAAAAQAMAAEAOP/nAAEAAQAkAAIGigAEA\nAAFJAXKABoAGQAA//gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAD/sv+4/+z/7v/MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAD/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9T/6AAAAAD/8QAA\nABD/vQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7gAAAAAAAAAAAAAAAAAA//MAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAP/5AAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/gAAD/4AAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//L/9AAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAA/+gAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/mAAAAAAAAAAAAAAAAAAD\n/4gAA//AAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+AAAAAAAAP/OAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zv/qAAAAAP/0AAAACAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/ZAAD/egAA/1kAAAAA/5D/rgAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAD/9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAD/8AAA/7b/8P+wAAD/8P/E/98AAAAA/8P/+P/0//oAAAAAAAAAAAAA//gA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+AAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/w//C/9MAAP/SAAD/9wAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/yAAA/+kAAAAA//QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9wAAAAD//QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAP/cAAAAAAAAAAAAAAAA/7YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAP/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6AAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAkAFAAEAAAAAQACwAAABcA\nBgAAAAAAAAAIAA4AAAAAAAsAEgAAAAAAAAATABkAAwANAAAAAQAJAAAAAAAAAAAAAAAAAAAAGAAAA\nAAABwAAAAAAAAAAAAAAFQAFAAAAAAAYABgAAAAUAAAACgAAAAwAAgAPABEAFgAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAEAEQBdAAYAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAcAAAAAAAAABwAAAAAACAAAAAAAAAAAAAcAAAAHAAAAEwAJ\nABUADgAPAAAACwAQAAAAAAAAAAAAAAAAAAUAGAACAAIAAgAAAAIAGAAXAAAAGAAAABYAFgACABYAA\ngAWAAAAEQADAAoAFAAMAA0ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAEgAGAAEAHgAkAC\nYAJwApACoALQAuAC8AMgAzADcAOAA5ADoAPAA9AEUASABOAE8AUgBTAFUAVwBZAFoAWwBcAF0AcwA\nAAAAAAQAAAADa3tfFAAAAANAan9kAAAAA4QodoQ==\n\"\"\"\n                )\n            ),\n            10 if size is None else size,\n            layout_engine=Layout.BASIC,\n        )\n    else:\n        f = ImageFont()\n        f._load_pilfont_data(\n            # courB08\n            BytesIO(\n                base64.b64decode(\n                    b\"\"\"\nUElMZm9udAo7Ozs7OzsxMDsKREFUQQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAA//8AAQAAAAAAAAABAAEA\nBgAAAAH/+gADAAAAAQAAAAMABgAGAAAAAf/6AAT//QADAAAABgADAAYAAAAA//kABQABAAYAAAAL\nAAgABgAAAAD/+AAFAAEACwAAABAACQAGAAAAAP/5AAUAAAAQAAAAFQAHAAYAAP////oABQAAABUA\nAAAbAAYABgAAAAH/+QAE//wAGwAAAB4AAwAGAAAAAf/5AAQAAQAeAAAAIQAIAAYAAAAB//kABAAB\nACEAAAAkAAgABgAAAAD/+QAE//0AJAAAACgABAAGAAAAAP/6AAX//wAoAAAALQAFAAYAAAAB//8A\nBAACAC0AAAAwAAMABgAAAAD//AAF//0AMAAAADUAAQAGAAAAAf//AAMAAAA1AAAANwABAAYAAAAB\n//kABQABADcAAAA7AAgABgAAAAD/+QAFAAAAOwAAAEAABwAGAAAAAP/5AAYAAABAAAAARgAHAAYA\nAAAA//kABQAAAEYAAABLAAcABgAAAAD/+QAFAAAASwAAAFAABwAGAAAAAP/5AAYAAABQAAAAVgAH\nAAYAAAAA//kABQAAAFYAAABbAAcABgAAAAD/+QAFAAAAWwAAAGAABwAGAAAAAP/5AAUAAABgAAAA\nZQAHAAYAAAAA//kABQAAAGUAAABqAAcABgAAAAD/+QAFAAAAagAAAG8ABwAGAAAAAf/8AAMAAABv\nAAAAcQAEAAYAAAAA//wAAwACAHEAAAB0AAYABgAAAAD/+gAE//8AdAAAAHgABQAGAAAAAP/7AAT/\n/gB4AAAAfAADAAYAAAAB//oABf//AHwAAACAAAUABgAAAAD/+gAFAAAAgAAAAIUABgAGAAAAAP/5\nAAYAAQCFAAAAiwAIAAYAAP////oABgAAAIsAAACSAAYABgAA////+gAFAAAAkgAAAJgABgAGAAAA\nAP/6AAUAAACYAAAAnQAGAAYAAP////oABQAAAJ0AAACjAAYABgAA////+gAFAAAAowAAAKkABgAG\nAAD////6AAUAAACpAAAArwAGAAYAAAAA//oABQAAAK8AAAC0AAYABgAA////+gAGAAAAtAAAALsA\nBgAGAAAAAP/6AAQAAAC7AAAAvwAGAAYAAP////oABQAAAL8AAADFAAYABgAA////+gAGAAAAxQAA\nAMwABgAGAAD////6AAUAAADMAAAA0gAGAAYAAP////oABQAAANIAAADYAAYABgAA////+gAGAAAA\n2AAAAN8ABgAGAAAAAP/6AAUAAADfAAAA5AAGAAYAAP////oABQAAAOQAAADqAAYABgAAAAD/+gAF\nAAEA6gAAAO8ABwAGAAD////6AAYAAADvAAAA9gAGAAYAAAAA//oABQAAAPYAAAD7AAYABgAA////\n+gAFAAAA+wAAAQEABgAGAAD////6AAYAAAEBAAABCAAGAAYAAP////oABgAAAQgAAAEPAAYABgAA\n////+gAGAAABDwAAARYABgAGAAAAAP/6AAYAAAEWAAABHAAGAAYAAP////oABgAAARwAAAEjAAYA\nBgAAAAD/+gAFAAABIwAAASgABgAGAAAAAf/5AAQAAQEoAAABKwAIAAYAAAAA//kABAABASsAAAEv\nAAgABgAAAAH/+QAEAAEBLwAAATIACAAGAAAAAP/5AAX//AEyAAABNwADAAYAAAAAAAEABgACATcA\nAAE9AAEABgAAAAH/+QAE//wBPQAAAUAAAwAGAAAAAP/7AAYAAAFAAAABRgAFAAYAAP////kABQAA\nAUYAAAFMAAcABgAAAAD/+wAFAAABTAAAAVEABQAGAAAAAP/5AAYAAAFRAAABVwAHAAYAAAAA//sA\nBQAAAVcAAAFcAAUABgAAAAD/+QAFAAABXAAAAWEABwAGAAAAAP/7AAYAAgFhAAABZwAHAAYAAP//\n//kABQAAAWcAAAFtAAcABgAAAAD/+QAGAAABbQAAAXMABwAGAAAAAP/5AAQAAgFzAAABdwAJAAYA\nAP////kABgAAAXcAAAF+AAcABgAAAAD/+QAGAAABfgAAAYQABwAGAAD////7AAUAAAGEAAABigAF\nAAYAAP////sABQAAAYoAAAGQAAUABgAAAAD/+wAFAAABkAAAAZUABQAGAAD////7AAUAAgGVAAAB\nmwAHAAYAAAAA//sABgACAZsAAAGhAAcABgAAAAD/+wAGAAABoQAAAacABQAGAAAAAP/7AAYAAAGn\nAAABrQAFAAYAAAAA//kABgAAAa0AAAGzAAcABgAA////+wAGAAABswAAAboABQAGAAD////7AAUA\nAAG6AAABwAAFAAYAAP////sABgAAAcAAAAHHAAUABgAAAAD/+wAGAAABxwAAAc0ABQAGAAD////7\nAAYAAgHNAAAB1AAHAAYAAAAA//sABQAAAdQAAAHZAAUABgAAAAH/+QAFAAEB2QAAAd0ACAAGAAAA\nAv/6AAMAAQHdAAAB3gAHAAYAAAAA//kABAABAd4AAAHiAAgABgAAAAD/+wAF//0B4gAAAecAAgAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAB\n//sAAwACAecAAAHpAAcABgAAAAD/+QAFAAEB6QAAAe4ACAAGAAAAAP/5AAYAAAHuAAAB9AAHAAYA\nAAAA//oABf//AfQAAAH5AAUABgAAAAD/+QAGAAAB+QAAAf8ABwAGAAAAAv/5AAMAAgH/AAACAAAJ\nAAYAAAAA//kABQABAgAAAAIFAAgABgAAAAH/+gAE//sCBQAAAggAAQAGAAAAAP/5AAYAAAIIAAAC\nDgAHAAYAAAAB//kABf/+Ag4AAAISAAUABgAA////+wAGAAACEgAAAhkABQAGAAAAAP/7AAX//gIZ\nAAACHgADAAYAAAAA//wABf/9Ah4AAAIjAAEABgAAAAD/+QAHAAACIwAAAioABwAGAAAAAP/6AAT/\n+wIqAAACLgABAAYAAAAA//kABP/8Ai4AAAIyAAMABgAAAAD/+gAFAAACMgAAAjcABgAGAAAAAf/5\nAAT//QI3AAACOgAEAAYAAAAB//kABP/9AjoAAAI9AAQABgAAAAL/+QAE//sCPQAAAj8AAgAGAAD/\n///7AAYAAgI/AAACRgAHAAYAAAAA//kABgABAkYAAAJMAAgABgAAAAH//AAD//0CTAAAAk4AAQAG\nAAAAAf//AAQAAgJOAAACUQADAAYAAAAB//kABP/9AlEAAAJUAAQABgAAAAH/+QAF//4CVAAAAlgA\nBQAGAAD////7AAYAAAJYAAACXwAFAAYAAP////kABgAAAl8AAAJmAAcABgAA////+QAGAAACZgAA\nAm0ABwAGAAD////5AAYAAAJtAAACdAAHAAYAAAAA//sABQACAnQAAAJ5AAcABgAA////9wAGAAAC\neQAAAoAACQAGAAD////3AAYAAAKAAAAChwAJAAYAAP////cABgAAAocAAAKOAAkABgAA////9wAG\nAAACjgAAApUACQAGAAD////4AAYAAAKVAAACnAAIAAYAAP////cABgAAApwAAAKjAAkABgAA////\n+gAGAAACowAAAqoABgAGAAAAAP/6AAUAAgKqAAACrwAIAAYAAP////cABQAAAq8AAAK1AAkABgAA\n////9wAFAAACtQAAArsACQAGAAD////3AAUAAAK7AAACwQAJAAYAAP////gABQAAAsEAAALHAAgA\nBgAAAAD/9wAEAAACxwAAAssACQAGAAAAAP/3AAQAAALLAAACzwAJAAYAAAAA//cABAAAAs8AAALT\nAAkABgAAAAD/+AAEAAAC0wAAAtcACAAGAAD////6AAUAAALXAAAC3QAGAAYAAP////cABgAAAt0A\nAALkAAkABgAAAAD/9wAFAAAC5AAAAukACQAGAAAAAP/3AAUAAALpAAAC7gAJAAYAAAAA//cABQAA\nAu4AAALzAAkABgAAAAD/9wAFAAAC8wAAAvgACQAGAAAAAP/4AAUAAAL4AAAC/QAIAAYAAAAA//oA\nBf//Av0AAAMCAAUABgAA////+gAGAAADAgAAAwkABgAGAAD////3AAYAAAMJAAADEAAJAAYAAP//\n//cABgAAAxAAAAMXAAkABgAA////9wAGAAADFwAAAx4ACQAGAAD////4AAYAAAAAAAoABwASAAYA\nAP////cABgAAAAcACgAOABMABgAA////+gAFAAAADgAKABQAEAAGAAD////6AAYAAAAUAAoAGwAQ\nAAYAAAAA//gABgAAABsACgAhABIABgAAAAD/+AAGAAAAIQAKACcAEgAGAAAAAP/4AAYAAAAnAAoA\nLQASAAYAAAAA//gABgAAAC0ACgAzABIABgAAAAD/+QAGAAAAMwAKADkAEQAGAAAAAP/3AAYAAAA5\nAAoAPwATAAYAAP////sABQAAAD8ACgBFAA8ABgAAAAD/+wAFAAIARQAKAEoAEQAGAAAAAP/4AAUA\nAABKAAoATwASAAYAAAAA//gABQAAAE8ACgBUABIABgAAAAD/+AAFAAAAVAAKAFkAEgAGAAAAAP/5\nAAUAAABZAAoAXgARAAYAAAAA//gABgAAAF4ACgBkABIABgAAAAD/+AAGAAAAZAAKAGoAEgAGAAAA\nAP/4AAYAAABqAAoAcAASAAYAAAAA//kABgAAAHAACgB2ABEABgAAAAD/+AAFAAAAdgAKAHsAEgAG\nAAD////4AAYAAAB7AAoAggASAAYAAAAA//gABQAAAIIACgCHABIABgAAAAD/+AAFAAAAhwAKAIwA\nEgAGAAAAAP/4AAUAAACMAAoAkQASAAYAAAAA//gABQAAAJEACgCWABIABgAAAAD/+QAFAAAAlgAK\nAJsAEQAGAAAAAP/6AAX//wCbAAoAoAAPAAYAAAAA//oABQABAKAACgClABEABgAA////+AAGAAAA\npQAKAKwAEgAGAAD////4AAYAAACsAAoAswASAAYAAP////gABgAAALMACgC6ABIABgAA////+QAG\nAAAAugAKAMEAEQAGAAD////4AAYAAgDBAAoAyAAUAAYAAP////kABQACAMgACgDOABMABgAA////\n+QAGAAIAzgAKANUAEw==\n\"\"\"\n                )\n            ),\n            Image.open(\n                BytesIO(\n                    base64.b64decode(\n                        b\"\"\"\niVBORw0KGgoAAAANSUhEUgAAAx4AAAAUAQAAAAArMtZoAAAEwElEQVR4nABlAJr/AHVE4czCI/4u\nMc4b7vuds/xzjz5/3/7u/n9vMe7vnfH/9++vPn/xyf5zhxzjt8GHw8+2d83u8x27199/nxuQ6Od9\nM43/5z2I+9n9ZtmDBwMQECDRQw/eQIQohJXxpBCNVE6QCCAAAAD//wBlAJr/AgALyj1t/wINwq0g\nLeNZUworuN1cjTPIzrTX6ofHWeo3v336qPzfEwRmBnHTtf95/fglZK5N0PDgfRTslpGBvz7LFc4F\nIUXBWQGjQ5MGCx34EDFPwXiY4YbYxavpnhHFrk14CDAAAAD//wBlAJr/AgKqRooH2gAgPeggvUAA\nBu2WfgPoAwzRAABAAAAAAACQgLz/3Uv4Gv+gX7BJgDeeGP6AAAD1NMDzKHD7ANWr3loYbxsAD791\nNAADfcoIDyP44K/jv4Y63/Z+t98Ovt+ub4T48LAAAAD//wBlAJr/AuplMlADJAAAAGuAphWpqhMx\nin0A/fRvAYBABPgBwBUgABBQ/sYAyv9g0bCHgOLoGAAAAAAAREAAwI7nr0ArYpow7aX8//9LaP/9\nSjdavWA8ePHeBIKB//81/83ndznOaXx379wAAAD//wBlAJr/AqDxW+D3AABAAbUh/QMnbQag/gAY\nAYDAAACgtgD/gOqAAAB5IA/8AAAk+n9w0AAA8AAAmFRJuPo27ciC0cD5oeW4E7KA/wD3ECMAn2tt\ny8PgwH8AfAxFzC0JzeAMtratAsC/ffwAAAD//wBlAJr/BGKAyCAA4AAAAvgeYTAwHd1kmQF5chkG\nABoMIHcL5xVpTfQbUqzlAAAErwAQBgAAEOClA5D9il08AEh/tUzdCBsXkbgACED+woQg8Si9VeqY\nlODCn7lmF6NhnAEYgAAA/NMIAAAAAAD//2JgjLZgVGBg5Pv/Tvpc8hwGBjYGJADjHDrAwPzAjv/H\n/Wf3PzCwtzcwHmBgYGcwbZz8wHaCAQMDOwMDQ8MCBgYOC3W7mp+f0w+wHOYxO3OG+e376hsMZjk3\nAAAAAP//YmCMY2A4wMAIN5e5gQETPD6AZisDAwMDgzSDAAPjByiHcQMDAwMDg1nOze1lByRu5/47\nc4859311AYNZzg0AAAAA//9iYGDBYihOIIMuwIjGL39/fwffA8b//xv/P2BPtzzHwCBjUQAAAAD/\n/yLFBrIBAAAA//9i1HhcwdhizX7u8NZNzyLbvT97bfrMf/QHI8evOwcSqGUJAAAA//9iYBB81iSw\npEE170Qrg5MIYydHqwdDQRMrAwcVrQAAAAD//2J4x7j9AAMDn8Q/BgYLBoaiAwwMjPdvMDBYM1Tv\noJodAAAAAP//Yqo/83+dxePWlxl3npsel9lvLfPcqlE9725C+acfVLMEAAAA//9i+s9gwCoaaGMR\nevta/58PTEWzr21hufPjA8N+qlnBwAAAAAD//2JiWLci5v1+HmFXDqcnULE/MxgYGBj+f6CaJQAA\nAAD//2Ji2FrkY3iYpYC5qDeGgeEMAwPDvwQBBoYvcTwOVLMEAAAA//9isDBgkP///0EOg9z35v//\nGc/eeW7BwPj5+QGZhANUswMAAAD//2JgqGBgYGBgqEMXlvhMPUsAAAAA//8iYDd1AAAAAP//AwDR\nw7IkEbzhVQAAAABJRU5ErkJggg==\n\"\"\"\n                    )\n                )\n            ),\n        )\n    return f\n", "src/PIL/ImageDraw.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# drawing interface operations\n#\n# History:\n# 1996-04-13 fl   Created (experimental)\n# 1996-08-07 fl   Filled polygons, ellipses.\n# 1996-08-13 fl   Added text support\n# 1998-06-28 fl   Handle I and F images\n# 1998-12-29 fl   Added arc; use arc primitive to draw ellipses\n# 1999-01-10 fl   Added shape stuff (experimental)\n# 1999-02-06 fl   Added bitmap support\n# 1999-02-11 fl   Changed all primitives to take options\n# 1999-02-20 fl   Fixed backwards compatibility\n# 2000-10-12 fl   Copy on write, when necessary\n# 2001-02-18 fl   Use default ink for bitmap/text also in fill mode\n# 2002-10-24 fl   Added support for CSS-style color strings\n# 2002-12-10 fl   Added experimental support for RGBA-on-RGB drawing\n# 2002-12-11 fl   Refactored low-level drawing API (work in progress)\n# 2004-08-26 fl   Made Draw() a factory function, added getdraw() support\n# 2004-09-04 fl   Added width support to line primitive\n# 2004-09-10 fl   Added font mode handling\n# 2006-06-19 fl   Added font bearing support (getmask2)\n#\n# Copyright (c) 1997-2006 by Secret Labs AB\n# Copyright (c) 1996-2006 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport math\nimport numbers\nimport struct\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING, AnyStr, Callable, List, Sequence, Tuple, Union, cast\n\nfrom . import Image, ImageColor\nfrom ._deprecate import deprecate\nfrom ._typing import Coords\n\n# experimental access to the outline API\nOutline: Callable[[], Image.core._Outline] | None\ntry:\n    Outline = Image.core.outline\nexcept AttributeError:\n    Outline = None\n\nif TYPE_CHECKING:\n    from . import ImageDraw2, ImageFont\n\n_Ink = Union[float, Tuple[int, ...], str]\n\n\"\"\"\nA simple 2D drawing interface for PIL images.\n<p>\nApplication code should use the <b>Draw</b> factory, instead of\ndirectly.\n\"\"\"\n\n\nclass ImageDraw:\n    font: (\n        ImageFont.ImageFont | ImageFont.FreeTypeFont | ImageFont.TransposedFont | None\n    ) = None\n\n    def __init__(self, im: Image.Image, mode: str | None = None) -> None:\n        \"\"\"\n        Create a drawing instance.\n\n        :param im: The image to draw in.\n        :param mode: Optional mode to use for color values.  For RGB\n           images, this argument can be RGB or RGBA (to blend the\n           drawing into the image).  For all other modes, this argument\n           must be the same as the image mode.  If omitted, the mode\n           defaults to the mode of the image.\n        \"\"\"\n        im.load()\n        if im.readonly:\n            im._copy()  # make it writeable\n        blend = 0\n        if mode is None:\n            mode = im.mode\n        if mode != im.mode:\n            if mode == \"RGBA\" and im.mode == \"RGB\":\n                blend = 1\n            else:\n                msg = \"mode mismatch\"\n                raise ValueError(msg)\n        if mode == \"P\":\n            self.palette = im.palette\n        else:\n            self.palette = None\n        self._image = im\n        self.im = im.im\n        self.draw = Image.core.draw(self.im, blend)\n        self.mode = mode\n        if mode in (\"I\", \"F\"):\n            self.ink = self.draw.draw_ink(1)\n        else:\n            self.ink = self.draw.draw_ink(-1)\n        if mode in (\"1\", \"P\", \"I\", \"F\"):\n            # FIXME: fix Fill2 to properly support matte for I+F images\n            self.fontmode = \"1\"\n        else:\n            self.fontmode = \"L\"  # aliasing is okay for other modes\n        self.fill = False\n\n    def getfont(\n        self,\n    ) -> ImageFont.ImageFont | ImageFont.FreeTypeFont | ImageFont.TransposedFont:\n        \"\"\"\n        Get the current default font.\n\n        To set the default font for this ImageDraw instance::\n\n            from PIL import ImageDraw, ImageFont\n            draw.font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\")\n\n        To set the default font for all future ImageDraw instances::\n\n            from PIL import ImageDraw, ImageFont\n            ImageDraw.ImageDraw.font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\")\n\n        If the current default font is ``None``,\n        it is initialized with ``ImageFont.load_default()``.\n\n        :returns: An image font.\"\"\"\n        if not self.font:\n            # FIXME: should add a font repository\n            from . import ImageFont\n\n            self.font = ImageFont.load_default()\n        return self.font\n\n    def _getfont(\n        self, font_size: float | None\n    ) -> ImageFont.ImageFont | ImageFont.FreeTypeFont | ImageFont.TransposedFont:\n        if font_size is not None:\n            from . import ImageFont\n\n            return ImageFont.load_default(font_size)\n        else:\n            return self.getfont()\n\n    def _getink(\n        self, ink: _Ink | None, fill: _Ink | None = None\n    ) -> tuple[int | None, int | None]:\n        result_ink = None\n        result_fill = None\n        if ink is None and fill is None:\n            if self.fill:\n                result_fill = self.ink\n            else:\n                result_ink = self.ink\n        else:\n            if ink is not None:\n                if isinstance(ink, str):\n                    ink = ImageColor.getcolor(ink, self.mode)\n                if self.palette and not isinstance(ink, numbers.Number):\n                    ink = self.palette.getcolor(ink, self._image)\n                result_ink = self.draw.draw_ink(ink)\n            if fill is not None:\n                if isinstance(fill, str):\n                    fill = ImageColor.getcolor(fill, self.mode)\n                if self.palette and not isinstance(fill, numbers.Number):\n                    fill = self.palette.getcolor(fill, self._image)\n                result_fill = self.draw.draw_ink(fill)\n        return result_ink, result_fill\n\n    def arc(\n        self,\n        xy: Coords,\n        start: float,\n        end: float,\n        fill: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw an arc.\"\"\"\n        ink, fill = self._getink(fill)\n        if ink is not None:\n            self.draw.draw_arc(xy, start, end, ink, width)\n\n    def bitmap(\n        self, xy: Sequence[int], bitmap: Image.Image, fill: _Ink | None = None\n    ) -> None:\n        \"\"\"Draw a bitmap.\"\"\"\n        bitmap.load()\n        ink, fill = self._getink(fill)\n        if ink is None:\n            ink = fill\n        if ink is not None:\n            self.draw.draw_bitmap(xy, bitmap.im, ink)\n\n    def chord(\n        self,\n        xy: Coords,\n        start: float,\n        end: float,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a chord.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_chord(xy, start, end, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_chord(xy, start, end, ink, 0, width)\n\n    def ellipse(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw an ellipse.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_ellipse(xy, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_ellipse(xy, ink, 0, width)\n\n    def circle(\n        self,\n        xy: Sequence[float],\n        radius: float,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a circle given center coordinates and a radius.\"\"\"\n        ellipse_xy = (xy[0] - radius, xy[1] - radius, xy[0] + radius, xy[1] + radius)\n        self.ellipse(ellipse_xy, fill, outline, width)\n\n    def line(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        width: int = 0,\n        joint: str | None = None,\n    ) -> None:\n        \"\"\"Draw a line, or a connected sequence of line segments.\"\"\"\n        ink = self._getink(fill)[0]\n        if ink is not None:\n            self.draw.draw_lines(xy, ink, width)\n            if joint == \"curve\" and width > 4:\n                points: Sequence[Sequence[float]]\n                if isinstance(xy[0], (list, tuple)):\n                    points = cast(Sequence[Sequence[float]], xy)\n                else:\n                    points = [\n                        cast(Sequence[float], tuple(xy[i : i + 2]))\n                        for i in range(0, len(xy), 2)\n                    ]\n                for i in range(1, len(points) - 1):\n                    point = points[i]\n                    angles = [\n                        math.degrees(math.atan2(end[0] - start[0], start[1] - end[1]))\n                        % 360\n                        for start, end in (\n                            (points[i - 1], point),\n                            (point, points[i + 1]),\n                        )\n                    ]\n                    if angles[0] == angles[1]:\n                        # This is a straight line, so no joint is required\n                        continue\n\n                    def coord_at_angle(\n                        coord: Sequence[float], angle: float\n                    ) -> tuple[float, ...]:\n                        x, y = coord\n                        angle -= 90\n                        distance = width / 2 - 1\n                        return tuple(\n                            p + (math.floor(p_d) if p_d > 0 else math.ceil(p_d))\n                            for p, p_d in (\n                                (x, distance * math.cos(math.radians(angle))),\n                                (y, distance * math.sin(math.radians(angle))),\n                            )\n                        )\n\n                    flipped = (\n                        angles[1] > angles[0] and angles[1] - 180 > angles[0]\n                    ) or (angles[1] < angles[0] and angles[1] + 180 > angles[0])\n                    coords = [\n                        (point[0] - width / 2 + 1, point[1] - width / 2 + 1),\n                        (point[0] + width / 2 - 1, point[1] + width / 2 - 1),\n                    ]\n                    if flipped:\n                        start, end = (angles[1] + 90, angles[0] + 90)\n                    else:\n                        start, end = (angles[0] - 90, angles[1] - 90)\n                    self.pieslice(coords, start - 90, end - 90, fill)\n\n                    if width > 8:\n                        # Cover potential gaps between the line and the joint\n                        if flipped:\n                            gap_coords = [\n                                coord_at_angle(point, angles[0] + 90),\n                                point,\n                                coord_at_angle(point, angles[1] + 90),\n                            ]\n                        else:\n                            gap_coords = [\n                                coord_at_angle(point, angles[0] - 90),\n                                point,\n                                coord_at_angle(point, angles[1] - 90),\n                            ]\n                        self.line(gap_coords, fill, width=3)\n\n    def shape(\n        self,\n        shape: Image.core._Outline,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n    ) -> None:\n        \"\"\"(Experimental) Draw a shape.\"\"\"\n        shape.close()\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_outline(shape, fill_ink, 1)\n        if ink is not None and ink != fill_ink:\n            self.draw.draw_outline(shape, ink, 0)\n\n    def pieslice(\n        self,\n        xy: Coords,\n        start: float,\n        end: float,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a pieslice.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_pieslice(xy, start, end, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_pieslice(xy, start, end, ink, 0, width)\n\n    def point(self, xy: Coords, fill: _Ink | None = None) -> None:\n        \"\"\"Draw one or more individual pixels.\"\"\"\n        ink, fill = self._getink(fill)\n        if ink is not None:\n            self.draw.draw_points(xy, ink)\n\n    def polygon(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a polygon.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_polygon(xy, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            if width == 1:\n                self.draw.draw_polygon(xy, ink, 0, width)\n            elif self.im is not None:\n                # To avoid expanding the polygon outwards,\n                # use the fill as a mask\n                mask = Image.new(\"1\", self.im.size)\n                mask_ink = self._getink(1)[0]\n\n                fill_im = mask.copy()\n                draw = Draw(fill_im)\n                draw.draw.draw_polygon(xy, mask_ink, 1)\n\n                ink_im = mask.copy()\n                draw = Draw(ink_im)\n                width = width * 2 - 1\n                draw.draw.draw_polygon(xy, mask_ink, 0, width)\n\n                mask.paste(ink_im, mask=fill_im)\n\n                im = Image.new(self.mode, self.im.size)\n                draw = Draw(im)\n                draw.draw.draw_polygon(xy, ink, 0, width)\n                self.im.paste(im.im, (0, 0) + im.size, mask.im)\n\n    def regular_polygon(\n        self,\n        bounding_circle: Sequence[Sequence[float] | float],\n        n_sides: int,\n        rotation: float = 0,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a regular polygon.\"\"\"\n        xy = _compute_regular_polygon_vertices(bounding_circle, n_sides, rotation)\n        self.polygon(xy, fill, outline, width)\n\n    def rectangle(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a rectangle.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_rectangle(xy, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_rectangle(xy, ink, 0, width)\n\n    def rounded_rectangle(\n        self,\n        xy: Coords,\n        radius: float = 0,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n        *,\n        corners: tuple[bool, bool, bool, bool] | None = None,\n    ) -> None:\n        \"\"\"Draw a rounded rectangle.\"\"\"\n        if isinstance(xy[0], (list, tuple)):\n            (x0, y0), (x1, y1) = cast(Sequence[Sequence[float]], xy)\n        else:\n            x0, y0, x1, y1 = cast(Sequence[float], xy)\n        if x1 < x0:\n            msg = \"x1 must be greater than or equal to x0\"\n            raise ValueError(msg)\n        if y1 < y0:\n            msg = \"y1 must be greater than or equal to y0\"\n            raise ValueError(msg)\n        if corners is None:\n            corners = (True, True, True, True)\n\n        d = radius * 2\n\n        x0 = round(x0)\n        y0 = round(y0)\n        x1 = round(x1)\n        y1 = round(y1)\n        full_x, full_y = False, False\n        if all(corners):\n            full_x = d >= x1 - x0 - 1\n            if full_x:\n                # The two left and two right corners are joined\n                d = x1 - x0\n            full_y = d >= y1 - y0 - 1\n            if full_y:\n                # The two top and two bottom corners are joined\n                d = y1 - y0\n            if full_x and full_y:\n                # If all corners are joined, that is a circle\n                return self.ellipse(xy, fill, outline, width)\n\n        if d == 0 or not any(corners):\n            # If the corners have no curve,\n            # or there are no corners,\n            # that is a rectangle\n            return self.rectangle(xy, fill, outline, width)\n\n        r = int(d // 2)\n        ink, fill_ink = self._getink(outline, fill)\n\n        def draw_corners(pieslice: bool) -> None:\n            parts: tuple[tuple[tuple[float, float, float, float], int, int], ...]\n            if full_x:\n                # Draw top and bottom halves\n                parts = (\n                    ((x0, y0, x0 + d, y0 + d), 180, 360),\n                    ((x0, y1 - d, x0 + d, y1), 0, 180),\n                )\n            elif full_y:\n                # Draw left and right halves\n                parts = (\n                    ((x0, y0, x0 + d, y0 + d), 90, 270),\n                    ((x1 - d, y0, x1, y0 + d), 270, 90),\n                )\n            else:\n                # Draw four separate corners\n                parts = tuple(\n                    part\n                    for i, part in enumerate(\n                        (\n                            ((x0, y0, x0 + d, y0 + d), 180, 270),\n                            ((x1 - d, y0, x1, y0 + d), 270, 360),\n                            ((x1 - d, y1 - d, x1, y1), 0, 90),\n                            ((x0, y1 - d, x0 + d, y1), 90, 180),\n                        )\n                    )\n                    if corners[i]\n                )\n            for part in parts:\n                if pieslice:\n                    self.draw.draw_pieslice(*(part + (fill_ink, 1)))\n                else:\n                    self.draw.draw_arc(*(part + (ink, width)))\n\n        if fill_ink is not None:\n            draw_corners(True)\n\n            if full_x:\n                self.draw.draw_rectangle((x0, y0 + r + 1, x1, y1 - r - 1), fill_ink, 1)\n            else:\n                self.draw.draw_rectangle((x0 + r + 1, y0, x1 - r - 1, y1), fill_ink, 1)\n            if not full_x and not full_y:\n                left = [x0, y0, x0 + r, y1]\n                if corners[0]:\n                    left[1] += r + 1\n                if corners[3]:\n                    left[3] -= r + 1\n                self.draw.draw_rectangle(left, fill_ink, 1)\n\n                right = [x1 - r, y0, x1, y1]\n                if corners[1]:\n                    right[1] += r + 1\n                if corners[2]:\n                    right[3] -= r + 1\n                self.draw.draw_rectangle(right, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            draw_corners(False)\n\n            if not full_x:\n                top = [x0, y0, x1, y0 + width - 1]\n                if corners[0]:\n                    top[0] += r + 1\n                if corners[1]:\n                    top[2] -= r + 1\n                self.draw.draw_rectangle(top, ink, 1)\n\n                bottom = [x0, y1 - width + 1, x1, y1]\n                if corners[3]:\n                    bottom[0] += r + 1\n                if corners[2]:\n                    bottom[2] -= r + 1\n                self.draw.draw_rectangle(bottom, ink, 1)\n            if not full_y:\n                left = [x0, y0, x0 + width - 1, y1]\n                if corners[0]:\n                    left[1] += r + 1\n                if corners[3]:\n                    left[3] -= r + 1\n                self.draw.draw_rectangle(left, ink, 1)\n\n                right = [x1 - width + 1, y0, x1, y1]\n                if corners[1]:\n                    right[1] += r + 1\n                if corners[2]:\n                    right[3] -= r + 1\n                self.draw.draw_rectangle(right, ink, 1)\n\n    def _multiline_check(self, text: AnyStr) -> bool:\n        split_character = \"\\n\" if isinstance(text, str) else b\"\\n\"\n\n        return split_character in text\n\n    def _multiline_split(self, text: AnyStr) -> list[AnyStr]:\n        return text.split(\"\\n\" if isinstance(text, str) else b\"\\n\")\n\n    def _multiline_spacing(self, font, spacing, stroke_width):\n        return (\n            self.textbbox((0, 0), \"A\", font, stroke_width=stroke_width)[3]\n            + stroke_width\n            + spacing\n        )\n\n    def text(\n        self,\n        xy: tuple[float, float],\n        text: str,\n        fill=None,\n        font: (\n            ImageFont.ImageFont\n            | ImageFont.FreeTypeFont\n            | ImageFont.TransposedFont\n            | None\n        ) = None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        stroke_fill=None,\n        embedded_color=False,\n        *args,\n        **kwargs,\n    ) -> None:\n        \"\"\"Draw text.\"\"\"\n        if embedded_color and self.mode not in (\"RGB\", \"RGBA\"):\n            msg = \"Embedded color supported only in RGB and RGBA modes\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(kwargs.get(\"font_size\"))\n\n        if self._multiline_check(text):\n            return self.multiline_text(\n                xy,\n                text,\n                fill,\n                font,\n                anchor,\n                spacing,\n                align,\n                direction,\n                features,\n                language,\n                stroke_width,\n                stroke_fill,\n                embedded_color,\n            )\n\n        def getink(fill: _Ink | None) -> int:\n            ink, fill_ink = self._getink(fill)\n            if ink is None:\n                assert fill_ink is not None\n                return fill_ink\n            return ink\n\n        def draw_text(ink, stroke_width=0, stroke_offset=None) -> None:\n            mode = self.fontmode\n            if stroke_width == 0 and embedded_color:\n                mode = \"RGBA\"\n            coord = []\n            start = []\n            for i in range(2):\n                coord.append(int(xy[i]))\n                start.append(math.modf(xy[i])[0])\n            try:\n                mask, offset = font.getmask2(  # type: ignore[union-attr,misc]\n                    text,\n                    mode,\n                    direction=direction,\n                    features=features,\n                    language=language,\n                    stroke_width=stroke_width,\n                    anchor=anchor,\n                    ink=ink,\n                    start=start,\n                    *args,\n                    **kwargs,\n                )\n                coord = [coord[0] + offset[0], coord[1] + offset[1]]\n            except AttributeError:\n                try:\n                    mask = font.getmask(  # type: ignore[misc]\n                        text,\n                        mode,\n                        direction,\n                        features,\n                        language,\n                        stroke_width,\n                        anchor,\n                        ink,\n                        start=start,\n                        *args,\n                        **kwargs,\n                    )\n                except TypeError:\n                    mask = font.getmask(text)\n            if stroke_offset:\n                coord = [coord[0] + stroke_offset[0], coord[1] + stroke_offset[1]]\n            if mode == \"RGBA\":\n                # font.getmask2(mode=\"RGBA\") returns color in RGB bands and mask in A\n                # extract mask and set text alpha\n                color, mask = mask, mask.getband(3)\n                ink_alpha = struct.pack(\"i\", ink)[3]\n                color.fillband(3, ink_alpha)\n                x, y = coord\n                if self.im is not None:\n                    self.im.paste(\n                        color, (x, y, x + mask.size[0], y + mask.size[1]), mask\n                    )\n            else:\n                self.draw.draw_bitmap(coord, mask, ink)\n\n        ink = getink(fill)\n        if ink is not None:\n            stroke_ink = None\n            if stroke_width:\n                stroke_ink = getink(stroke_fill) if stroke_fill is not None else ink\n\n            if stroke_ink is not None:\n                # Draw stroked text\n                draw_text(stroke_ink, stroke_width)\n\n                # Draw normal text\n                draw_text(ink, 0)\n            else:\n                # Only draw normal text\n                draw_text(ink)\n\n    def multiline_text(\n        self,\n        xy: tuple[float, float],\n        text: str,\n        fill=None,\n        font: (\n            ImageFont.ImageFont\n            | ImageFont.FreeTypeFont\n            | ImageFont.TransposedFont\n            | None\n        ) = None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        stroke_fill=None,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> None:\n        if direction == \"ttb\":\n            msg = \"ttb direction is unsupported for multiline text\"\n            raise ValueError(msg)\n\n        if anchor is None:\n            anchor = \"la\"\n        elif len(anchor) != 2:\n            msg = \"anchor must be a 2 character string\"\n            raise ValueError(msg)\n        elif anchor[1] in \"tb\":\n            msg = \"anchor not supported for multiline text\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n\n        widths = []\n        max_width: float = 0\n        lines = self._multiline_split(text)\n        line_spacing = self._multiline_spacing(font, spacing, stroke_width)\n        for line in lines:\n            line_width = self.textlength(\n                line, font, direction=direction, features=features, language=language\n            )\n            widths.append(line_width)\n            max_width = max(max_width, line_width)\n\n        top = xy[1]\n        if anchor[1] == \"m\":\n            top -= (len(lines) - 1) * line_spacing / 2.0\n        elif anchor[1] == \"d\":\n            top -= (len(lines) - 1) * line_spacing\n\n        for idx, line in enumerate(lines):\n            left = xy[0]\n            width_difference = max_width - widths[idx]\n\n            # first align left by anchor\n            if anchor[0] == \"m\":\n                left -= width_difference / 2.0\n            elif anchor[0] == \"r\":\n                left -= width_difference\n\n            # then align by align parameter\n            if align == \"left\":\n                pass\n            elif align == \"center\":\n                left += width_difference / 2.0\n            elif align == \"right\":\n                left += width_difference\n            else:\n                msg = 'align must be \"left\", \"center\" or \"right\"'\n                raise ValueError(msg)\n\n            self.text(\n                (left, top),\n                line,\n                fill,\n                font,\n                anchor,\n                direction=direction,\n                features=features,\n                language=language,\n                stroke_width=stroke_width,\n                stroke_fill=stroke_fill,\n                embedded_color=embedded_color,\n            )\n            top += line_spacing\n\n    def textlength(\n        self,\n        text: str,\n        font: (\n            ImageFont.ImageFont\n            | ImageFont.FreeTypeFont\n            | ImageFont.TransposedFont\n            | None\n        ) = None,\n        direction=None,\n        features=None,\n        language=None,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> float:\n        \"\"\"Get the length of a given string, in pixels with 1/64 precision.\"\"\"\n        if self._multiline_check(text):\n            msg = \"can't measure length of multiline text\"\n            raise ValueError(msg)\n        if embedded_color and self.mode not in (\"RGB\", \"RGBA\"):\n            msg = \"Embedded color supported only in RGB and RGBA modes\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n        mode = \"RGBA\" if embedded_color else self.fontmode\n        return font.getlength(text, mode, direction, features, language)\n\n    def textbbox(\n        self,\n        xy,\n        text,\n        font=None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> tuple[int, int, int, int]:\n        \"\"\"Get the bounding box of a given string, in pixels.\"\"\"\n        if embedded_color and self.mode not in (\"RGB\", \"RGBA\"):\n            msg = \"Embedded color supported only in RGB and RGBA modes\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n\n        if self._multiline_check(text):\n            return self.multiline_textbbox(\n                xy,\n                text,\n                font,\n                anchor,\n                spacing,\n                align,\n                direction,\n                features,\n                language,\n                stroke_width,\n                embedded_color,\n            )\n\n        mode = \"RGBA\" if embedded_color else self.fontmode\n        bbox = font.getbbox(\n            text, mode, direction, features, language, stroke_width, anchor\n        )\n        return bbox[0] + xy[0], bbox[1] + xy[1], bbox[2] + xy[0], bbox[3] + xy[1]\n\n    def multiline_textbbox(\n        self,\n        xy,\n        text,\n        font=None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> tuple[int, int, int, int]:\n        if direction == \"ttb\":\n            msg = \"ttb direction is unsupported for multiline text\"\n            raise ValueError(msg)\n\n        if anchor is None:\n            anchor = \"la\"\n        elif len(anchor) != 2:\n            msg = \"anchor must be a 2 character string\"\n            raise ValueError(msg)\n        elif anchor[1] in \"tb\":\n            msg = \"anchor not supported for multiline text\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n\n        widths = []\n        max_width: float = 0\n        lines = self._multiline_split(text)\n        line_spacing = self._multiline_spacing(font, spacing, stroke_width)\n        for line in lines:\n            line_width = self.textlength(\n                line,\n                font,\n                direction=direction,\n                features=features,\n                language=language,\n                embedded_color=embedded_color,\n            )\n            widths.append(line_width)\n            max_width = max(max_width, line_width)\n\n        top = xy[1]\n        if anchor[1] == \"m\":\n            top -= (len(lines) - 1) * line_spacing / 2.0\n        elif anchor[1] == \"d\":\n            top -= (len(lines) - 1) * line_spacing\n\n        bbox: tuple[int, int, int, int] | None = None\n\n        for idx, line in enumerate(lines):\n            left = xy[0]\n            width_difference = max_width - widths[idx]\n\n            # first align left by anchor\n            if anchor[0] == \"m\":\n                left -= width_difference / 2.0\n            elif anchor[0] == \"r\":\n                left -= width_difference\n\n            # then align by align parameter\n            if align == \"left\":\n                pass\n            elif align == \"center\":\n                left += width_difference / 2.0\n            elif align == \"right\":\n                left += width_difference\n            else:\n                msg = 'align must be \"left\", \"center\" or \"right\"'\n                raise ValueError(msg)\n\n            bbox_line = self.textbbox(\n                (left, top),\n                line,\n                font,\n                anchor,\n                direction=direction,\n                features=features,\n                language=language,\n                stroke_width=stroke_width,\n                embedded_color=embedded_color,\n            )\n            if bbox is None:\n                bbox = bbox_line\n            else:\n                bbox = (\n                    min(bbox[0], bbox_line[0]),\n                    min(bbox[1], bbox_line[1]),\n                    max(bbox[2], bbox_line[2]),\n                    max(bbox[3], bbox_line[3]),\n                )\n\n            top += line_spacing\n\n        if bbox is None:\n            return xy[0], xy[1], xy[0], xy[1]\n        return bbox\n\n\ndef Draw(im: Image.Image, mode: str | None = None) -> ImageDraw:\n    \"\"\"\n    A simple 2D drawing interface for PIL images.\n\n    :param im: The image to draw in.\n    :param mode: Optional mode to use for color values.  For RGB\n       images, this argument can be RGB or RGBA (to blend the\n       drawing into the image).  For all other modes, this argument\n       must be the same as the image mode.  If omitted, the mode\n       defaults to the mode of the image.\n    \"\"\"\n    try:\n        return getattr(im, \"getdraw\")(mode)\n    except AttributeError:\n        return ImageDraw(im, mode)\n\n\ndef getdraw(\n    im: Image.Image | None = None, hints: list[str] | None = None\n) -> tuple[ImageDraw2.Draw | None, ModuleType]:\n    \"\"\"\n    :param im: The image to draw in.\n    :param hints: An optional list of hints. Deprecated.\n    :returns: A (drawing context, drawing resource factory) tuple.\n    \"\"\"\n    if hints is not None:\n        deprecate(\"'hints' parameter\", 12)\n    from . import ImageDraw2\n\n    draw = ImageDraw2.Draw(im) if im is not None else None\n    return draw, ImageDraw2\n\n\ndef floodfill(\n    image: Image.Image,\n    xy: tuple[int, int],\n    value: float | tuple[int, ...],\n    border: float | tuple[int, ...] | None = None,\n    thresh: float = 0,\n) -> None:\n    \"\"\"\n    (experimental) Fills a bounded region with a given color.\n\n    :param image: Target image.\n    :param xy: Seed position (a 2-item coordinate tuple). See\n        :ref:`coordinate-system`.\n    :param value: Fill color.\n    :param border: Optional border value.  If given, the region consists of\n        pixels with a color different from the border color.  If not given,\n        the region consists of pixels having the same color as the seed\n        pixel.\n    :param thresh: Optional threshold value which specifies a maximum\n        tolerable difference of a pixel value from the 'background' in\n        order for it to be replaced. Useful for filling regions of\n        non-homogeneous, but similar, colors.\n    \"\"\"\n    # based on an implementation by Eric S. Raymond\n    # amended by yo1995 @20180806\n    pixel = image.load()\n    x, y = xy\n    try:\n        background = pixel[x, y]\n        if _color_diff(value, background) <= thresh:\n            return  # seed point already has fill color\n        pixel[x, y] = value\n    except (ValueError, IndexError):\n        return  # seed point outside image\n    edge = {(x, y)}\n    # use a set to keep record of current and previous edge pixels\n    # to reduce memory consumption\n    full_edge = set()\n    while edge:\n        new_edge = set()\n        for x, y in edge:  # 4 adjacent method\n            for s, t in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n                # If already processed, or if a coordinate is negative, skip\n                if (s, t) in full_edge or s < 0 or t < 0:\n                    continue\n                try:\n                    p = pixel[s, t]\n                except (ValueError, IndexError):\n                    pass\n                else:\n                    full_edge.add((s, t))\n                    if border is None:\n                        fill = _color_diff(p, background) <= thresh\n                    else:\n                        fill = p not in (value, border)\n                    if fill:\n                        pixel[s, t] = value\n                        new_edge.add((s, t))\n        full_edge = edge  # discard pixels processed\n        edge = new_edge\n\n\ndef _compute_regular_polygon_vertices(\n    bounding_circle: Sequence[Sequence[float] | float], n_sides: int, rotation: float\n) -> list[tuple[float, float]]:\n    \"\"\"\n    Generate a list of vertices for a 2D regular polygon.\n\n    :param bounding_circle: The bounding circle is a sequence defined\n        by a point and radius. The polygon is inscribed in this circle.\n        (e.g. ``bounding_circle=(x, y, r)`` or ``((x, y), r)``)\n    :param n_sides: Number of sides\n        (e.g. ``n_sides=3`` for a triangle, ``6`` for a hexagon)\n    :param rotation: Apply an arbitrary rotation to the polygon\n        (e.g. ``rotation=90``, applies a 90 degree rotation)\n    :return: List of regular polygon vertices\n        (e.g. ``[(25, 50), (50, 50), (50, 25), (25, 25)]``)\n\n    How are the vertices computed?\n    1. Compute the following variables\n        - theta: Angle between the apothem & the nearest polygon vertex\n        - side_length: Length of each polygon edge\n        - centroid: Center of bounding circle (1st, 2nd elements of bounding_circle)\n        - polygon_radius: Polygon radius (last element of bounding_circle)\n        - angles: Location of each polygon vertex in polar grid\n            (e.g. A square with 0 degree rotation => [225.0, 315.0, 45.0, 135.0])\n\n    2. For each angle in angles, get the polygon vertex at that angle\n        The vertex is computed using the equation below.\n            X= xcos(\u03c6) + ysin(\u03c6)\n            Y= \u2212xsin(\u03c6) + ycos(\u03c6)\n\n        Note:\n            \u03c6 = angle in degrees\n            x = 0\n            y = polygon_radius\n\n        The formula above assumes rotation around the origin.\n        In our case, we are rotating around the centroid.\n        To account for this, we use the formula below\n            X = xcos(\u03c6) + ysin(\u03c6) + centroid_x\n            Y = \u2212xsin(\u03c6) + ycos(\u03c6) + centroid_y\n    \"\"\"\n    # 1. Error Handling\n    # 1.1 Check `n_sides` has an appropriate value\n    if not isinstance(n_sides, int):\n        msg = \"n_sides should be an int\"  # type: ignore[unreachable]\n        raise TypeError(msg)\n    if n_sides < 3:\n        msg = \"n_sides should be an int > 2\"\n        raise ValueError(msg)\n\n    # 1.2 Check `bounding_circle` has an appropriate value\n    if not isinstance(bounding_circle, (list, tuple)):\n        msg = \"bounding_circle should be a sequence\"\n        raise TypeError(msg)\n\n    if len(bounding_circle) == 3:\n        if not all(isinstance(i, (int, float)) for i in bounding_circle):\n            msg = \"bounding_circle should only contain numeric data\"\n            raise ValueError(msg)\n\n        *centroid, polygon_radius = cast(List[float], list(bounding_circle))\n    elif len(bounding_circle) == 2 and isinstance(bounding_circle[0], (list, tuple)):\n        if not all(\n            isinstance(i, (int, float)) for i in bounding_circle[0]\n        ) or not isinstance(bounding_circle[1], (int, float)):\n            msg = \"bounding_circle should only contain numeric data\"\n            raise ValueError(msg)\n\n        if len(bounding_circle[0]) != 2:\n            msg = \"bounding_circle centre should contain 2D coordinates (e.g. (x, y))\"\n            raise ValueError(msg)\n\n        centroid = cast(List[float], list(bounding_circle[0]))\n        polygon_radius = cast(float, bounding_circle[1])\n    else:\n        msg = (\n            \"bounding_circle should contain 2D coordinates \"\n            \"and a radius (e.g. (x, y, r) or ((x, y), r) )\"\n        )\n        raise ValueError(msg)\n\n    if polygon_radius <= 0:\n        msg = \"bounding_circle radius should be > 0\"\n        raise ValueError(msg)\n\n    # 1.3 Check `rotation` has an appropriate value\n    if not isinstance(rotation, (int, float)):\n        msg = \"rotation should be an int or float\"  # type: ignore[unreachable]\n        raise ValueError(msg)\n\n    # 2. Define Helper Functions\n    def _apply_rotation(point: list[float], degrees: float) -> tuple[float, float]:\n        return (\n            round(\n                point[0] * math.cos(math.radians(360 - degrees))\n                - point[1] * math.sin(math.radians(360 - degrees))\n                + centroid[0],\n                2,\n            ),\n            round(\n                point[1] * math.cos(math.radians(360 - degrees))\n                + point[0] * math.sin(math.radians(360 - degrees))\n                + centroid[1],\n                2,\n            ),\n        )\n\n    def _compute_polygon_vertex(angle: float) -> tuple[float, float]:\n        start_point = [polygon_radius, 0]\n        return _apply_rotation(start_point, angle)\n\n    def _get_angles(n_sides: int, rotation: float) -> list[float]:\n        angles = []\n        degrees = 360 / n_sides\n        # Start with the bottom left polygon vertex\n        current_angle = (270 - 0.5 * degrees) + rotation\n        for _ in range(0, n_sides):\n            angles.append(current_angle)\n            current_angle += degrees\n            if current_angle > 360:\n                current_angle -= 360\n        return angles\n\n    # 3. Variable Declarations\n    angles = _get_angles(n_sides, rotation)\n\n    # 4. Compute Vertices\n    return [_compute_polygon_vertex(angle) for angle in angles]\n\n\ndef _color_diff(\n    color1: float | tuple[int, ...], color2: float | tuple[int, ...]\n) -> float:\n    \"\"\"\n    Uses 1-norm distance to calculate difference between two values.\n    \"\"\"\n    first = color1 if isinstance(color1, tuple) else (color1,)\n    second = color2 if isinstance(color2, tuple) else (color2,)\n\n    return sum(abs(first[i] - second[i]) for i in range(0, len(second)))\n", "src/PIL/ImageStat.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# global image statistics\n#\n# History:\n# 1996-04-05 fl   Created\n# 1997-05-21 fl   Added mask; added rms, var, stddev attributes\n# 1997-08-05 fl   Added median\n# 1998-07-05 hk   Fixed integer overflow error\n#\n# Notes:\n# This class shows how to implement delayed evaluation of attributes.\n# To get a certain value, simply access the corresponding attribute.\n# The __getattr__ dispatcher takes care of the rest.\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996-97.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport math\nfrom functools import cached_property\n\nfrom . import Image\n\n\nclass Stat:\n    def __init__(\n        self, image_or_list: Image.Image | list[int], mask: Image.Image | None = None\n    ) -> None:\n        \"\"\"\n        Calculate statistics for the given image. If a mask is included,\n        only the regions covered by that mask are included in the\n        statistics. You can also pass in a previously calculated histogram.\n\n        :param image: A PIL image, or a precalculated histogram.\n\n            .. note::\n\n                For a PIL image, calculations rely on the\n                :py:meth:`~PIL.Image.Image.histogram` method. The pixel counts are\n                grouped into 256 bins, even if the image has more than 8 bits per\n                channel. So ``I`` and ``F`` mode images have a maximum ``mean``,\n                ``median`` and ``rms`` of 255, and cannot have an ``extrema`` maximum\n                of more than 255.\n\n        :param mask: An optional mask.\n        \"\"\"\n        if isinstance(image_or_list, Image.Image):\n            self.h = image_or_list.histogram(mask)\n        elif isinstance(image_or_list, list):\n            self.h = image_or_list\n        else:\n            msg = \"first argument must be image or list\"  # type: ignore[unreachable]\n            raise TypeError(msg)\n        self.bands = list(range(len(self.h) // 256))\n\n    @cached_property\n    def extrema(self) -> list[tuple[int, int]]:\n        \"\"\"\n        Min/max values for each band in the image.\n\n        .. note::\n            This relies on the :py:meth:`~PIL.Image.Image.histogram` method, and\n            simply returns the low and high bins used. This is correct for\n            images with 8 bits per channel, but fails for other modes such as\n            ``I`` or ``F``. Instead, use :py:meth:`~PIL.Image.Image.getextrema` to\n            return per-band extrema for the image. This is more correct and\n            efficient because, for non-8-bit modes, the histogram method uses\n            :py:meth:`~PIL.Image.Image.getextrema` to determine the bins used.\n        \"\"\"\n\n        def minmax(histogram: list[int]) -> tuple[int, int]:\n            res_min, res_max = 255, 0\n            for i in range(256):\n                if histogram[i]:\n                    res_min = i\n                    break\n            for i in range(255, -1, -1):\n                if histogram[i]:\n                    res_max = i\n                    break\n            return res_min, res_max\n\n        return [minmax(self.h[i:]) for i in range(0, len(self.h), 256)]\n\n    @cached_property\n    def count(self) -> list[int]:\n        \"\"\"Total number of pixels for each band in the image.\"\"\"\n        return [sum(self.h[i : i + 256]) for i in range(0, len(self.h), 256)]\n\n    @cached_property\n    def sum(self) -> list[float]:\n        \"\"\"Sum of all pixels for each band in the image.\"\"\"\n\n        v = []\n        for i in range(0, len(self.h), 256):\n            layer_sum = 0.0\n            for j in range(256):\n                layer_sum += j * self.h[i + j]\n            v.append(layer_sum)\n        return v\n\n    @cached_property\n    def sum2(self) -> list[float]:\n        \"\"\"Squared sum of all pixels for each band in the image.\"\"\"\n\n        v = []\n        for i in range(0, len(self.h), 256):\n            sum2 = 0.0\n            for j in range(256):\n                sum2 += (j**2) * float(self.h[i + j])\n            v.append(sum2)\n        return v\n\n    @cached_property\n    def mean(self) -> list[float]:\n        \"\"\"Average (arithmetic mean) pixel level for each band in the image.\"\"\"\n        return [self.sum[i] / self.count[i] for i in self.bands]\n\n    @cached_property\n    def median(self) -> list[int]:\n        \"\"\"Median pixel level for each band in the image.\"\"\"\n\n        v = []\n        for i in self.bands:\n            s = 0\n            half = self.count[i] // 2\n            b = i * 256\n            for j in range(256):\n                s = s + self.h[b + j]\n                if s > half:\n                    break\n            v.append(j)\n        return v\n\n    @cached_property\n    def rms(self) -> list[float]:\n        \"\"\"RMS (root-mean-square) for each band in the image.\"\"\"\n        return [math.sqrt(self.sum2[i] / self.count[i]) for i in self.bands]\n\n    @cached_property\n    def var(self) -> list[float]:\n        \"\"\"Variance for each band in the image.\"\"\"\n        return [\n            (self.sum2[i] - (self.sum[i] ** 2.0) / self.count[i]) / self.count[i]\n            for i in self.bands\n        ]\n\n    @cached_property\n    def stddev(self) -> list[float]:\n        \"\"\"Standard deviation for each band in the image.\"\"\"\n        return [math.sqrt(self.var[i]) for i in self.bands]\n\n\nGlobal = Stat  # compatibility\n", "src/PIL/_binary.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Binary input/output support routines.\n#\n# Copyright (c) 1997-2003 by Secret Labs AB\n# Copyright (c) 1995-2003 by Fredrik Lundh\n# Copyright (c) 2012 by Brian Crowell\n#\n# See the README file for information on usage and redistribution.\n#\n\n\n\"\"\"Binary input/output support routines.\"\"\"\nfrom __future__ import annotations\n\nfrom struct import pack, unpack_from\n\n\ndef i8(c: bytes) -> int:\n    return c[0]\n\n\ndef o8(i: int) -> bytes:\n    return bytes((i & 255,))\n\n\n# Input, le = little endian, be = big endian\ndef i16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to an unsigned integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<H\", c, o)[0]\n\n\ndef si16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<h\", c, o)[0]\n\n\ndef si16be(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer, big endian.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\">h\", c, o)[0]\n\n\ndef i32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to an unsigned integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<I\", c, o)[0]\n\n\ndef si32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<i\", c, o)[0]\n\n\ndef si32be(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer, big endian.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\">i\", c, o)[0]\n\n\ndef i16be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">H\", c, o)[0]\n\n\ndef i32be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">I\", c, o)[0]\n\n\n# Output, le = little endian, be = big endian\ndef o16le(i: int) -> bytes:\n    return pack(\"<H\", i)\n\n\ndef o32le(i: int) -> bytes:\n    return pack(\"<I\", i)\n\n\ndef o16be(i: int) -> bytes:\n    return pack(\">H\", i)\n\n\ndef o32be(i: int) -> bytes:\n    return pack(\">I\", i)\n", "Tests/check_release_notes.py": "from __future__ import annotations\n\nimport sys\nfrom pathlib import Path\n\nfor rst in Path(\"docs/releasenotes\").glob(\"[1-9]*.rst\"):\n    if \"TODO\" in open(rst).read():\n        sys.exit(f\"Error: remove TODO from {rst}\")\n", "Tests/check_libtiff_segfault.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nTEST_FILE = \"Tests/images/libtiff_segfault.tif\"\n\n\ndef test_libtiff_segfault() -> None:\n    \"\"\"This test should not segfault. It will on Pillow <= 3.1.0 and\n    libtiff >= 4.0.0\n    \"\"\"\n\n    with pytest.raises(OSError):\n        with Image.open(TEST_FILE) as im:\n            im.load()\n", "Tests/bench_cffi_access.py": "from __future__ import annotations\n\nimport time\n\nfrom PIL import PyAccess\n\nfrom .helper import hopper\n\n# Not running this test by default. No DOS against CI.\n\n\ndef iterate_get(size, access) -> None:\n    (w, h) = size\n    for x in range(w):\n        for y in range(h):\n            access[(x, y)]\n\n\ndef iterate_set(size, access) -> None:\n    (w, h) = size\n    for x in range(w):\n        for y in range(h):\n            access[(x, y)] = (x % 256, y % 256, 0)\n\n\ndef timer(func, label, *args) -> None:\n    iterations = 5000\n    starttime = time.time()\n    for x in range(iterations):\n        func(*args)\n        if time.time() - starttime > 10:\n            break\n    endtime = time.time()\n    print(\n        f\"{label}: completed {x + 1} iterations in {endtime - starttime:.4f}s, \"\n        f\"{(endtime - starttime) / (x + 1.0):.6f}s per iteration\"\n    )\n\n\ndef test_direct() -> None:\n    im = hopper()\n    im.load()\n    # im = Image.new(\"RGB\", (2000, 2000), (1, 3, 2))\n    caccess = im.im.pixel_access(False)\n    access = PyAccess.new(im, False)\n\n    assert access is not None\n    assert caccess[(0, 0)] == access[(0, 0)]\n\n    print(f\"Size: {im.width}x{im.height}\")\n    timer(iterate_get, \"PyAccess - get\", im.size, access)\n    timer(iterate_set, \"PyAccess - set\", im.size, access)\n    timer(iterate_get, \"C-api - get\", im.size, caccess)\n    timer(iterate_set, \"C-api - set\", im.size, caccess)\n", "Tests/check_jpeg_leaks.py": "from __future__ import annotations\n\nfrom io import BytesIO\n\nimport pytest\n\nfrom .helper import hopper, is_win32\n\niterations = 5000\n\n\n\"\"\"\nWhen run on a system without the jpeg leak fixes,\nthe valgrind runs look like this.\n\nvalgrind --tool=massif python test-installed.py -s -v Tests/check_jpeg_leaks.py\n\n\"\"\"\n\n\npytestmark = pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\")\n\n\"\"\"\npre patch:\n\n    MB\n31.62^                                                                       :\n     |                                                              @:@:@:@#::\n     |                                                     @:@:@@:@:@:@:@:@#::\n     |                                             ::::::::@:@:@@:@:@:@:@:@#::\n     |                                   :::::@::::::: ::::@:@:@@:@:@:@:@:@#::\n     |                          @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |               ::::::@::::@:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |          ::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |         :::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |        ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |        ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |      ::::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |      : ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |     @: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |    @@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |   :@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |   :@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     | :@:@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     | :@:@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     | :@:@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n   0 +----------------------------------------------------------------------->Gi\n     0                                                                   8.535\n\n\npost-patch:\n\n    MB\n21.03^          :::@@:::@::::@@:::::::@@::::::::@::::::::::::@:::@:::::::@::::\n     |         #:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |         #:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |        :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |        :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |        :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |      :::#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |      : :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |      : :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |     @: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |    @@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |    @@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |    @@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |   :@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |   :@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n   0 +----------------------------------------------------------------------->Gi\n     0                                                                   8.421\n\n\"\"\"\n\n\nstandard_l_qtable = (\n    # fmt: off\n    16, 11, 10, 16,  24,  40,  51,  61,\n    12, 12, 14, 19,  26,  58,  60,  55,\n    14, 13, 16, 24,  40,  57,  69,  56,\n    14, 17, 22, 29,  51,  87,  80,  62,\n    18, 22, 37, 56,  68, 109, 103,  77,\n    24, 35, 55, 64,  81, 104, 113,  92,\n    49, 64, 78, 87, 103, 121, 120, 101,\n    72, 92, 95, 98, 112, 100, 103,  99,\n    # fmt: on\n)\n\nstandard_chrominance_qtable = (\n    # fmt: off\n    17, 18, 24, 47, 99, 99, 99, 99,\n    18, 21, 26, 66, 99, 99, 99, 99,\n    24, 26, 56, 99, 99, 99, 99, 99,\n    47, 66, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    # fmt: on\n)\n\n\n@pytest.mark.parametrize(\n    \"qtables\",\n    (\n        (standard_l_qtable, standard_chrominance_qtable),\n        [standard_l_qtable, standard_chrominance_qtable],\n    ),\n)\ndef test_qtables_leak(qtables: tuple[tuple[int, ...]] | list[tuple[int, ...]]) -> None:\n    im = hopper(\"RGB\")\n    for _ in range(iterations):\n        test_output = BytesIO()\n        im.save(test_output, \"JPEG\", qtables=qtables)\n\n\ndef test_exif_leak() -> None:\n    \"\"\"\n    pre patch:\n\n        MB\n    177.1^                                                                       #\n         |                                                                    @@@#\n         |                                                                :@@@@@@#\n         |                                                             ::::@@@@@@#\n         |                                                         ::::::::@@@@@@#\n         |                                                     @@::::: ::::@@@@@@#\n         |                                                  @@@@ ::::: ::::@@@@@@#\n         |                                               @@@@@@@ ::::: ::::@@@@@@#\n         |                                           @@::@@@@@@@ ::::: ::::@@@@@@#\n         |                                        @@@@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                                   @@@@@@ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                                @@@@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                            @::@@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                        ::::@: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                     :@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                ::@@::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |            @@::: @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |         @::@ : : @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |      :::@: @ : : @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |   @@@:: @: @ : : @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n       0 +----------------------------------------------------------------------->Gi\n         0                                                                   11.37\n\n\n    post patch:\n\n        MB\n    21.06^        ::::::::::::::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      ##::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      # ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      # ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      # ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |    @@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @@@@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n       0 +----------------------------------------------------------------------->Gi\n         0                                                                   11.33\n    \"\"\"\n    im = hopper(\"RGB\")\n    exif = b\"12345678\" * 4096\n\n    for _ in range(iterations):\n        test_output = BytesIO()\n        im.save(test_output, \"JPEG\", exif=exif)\n\n\ndef test_base_save() -> None:\n    \"\"\"\n    base case:\n        MB\n    20.99^           :::::         :::::::::::::::::::::::::::::::::::::::::::@:::\n         |         ##: : ::::::@::::::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |         # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |         # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |         # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |       @@# : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |       @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |       @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |     @@@ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |     @ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@@@@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n       0 +----------------------------------------------------------------------->Gi\n         0                                                                   7.882\"\"\"\n    im = hopper(\"RGB\")\n\n    for _ in range(iterations):\n        test_output = BytesIO()\n        im.save(test_output, \"JPEG\")\n", "Tests/check_fli_overflow.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nTEST_FILE = \"Tests/images/fli_overflow.fli\"\n\n\ndef test_fli_overflow() -> None:\n    # this should not crash with a malloc error or access violation\n    with Image.open(TEST_FILE) as im:\n        im.load()\n", "Tests/check_jp2_overflow.py": "# Reproductions/tests for OOB read errors in FliDecode.c\n\n# When run in python, all of these images should fail for\n# one reason or another, either as a buffer overrun,\n# unrecognized datastream, or truncated image file.\n# There shouldn't be any segfaults.\n#\n# if run like\n# `valgrind --tool=memcheck python check_jp2_overflow.py  2>&1 | grep Decode.c`\n# the output should be empty. There may be python issues\n# in the valgrind especially if run in a debug python\n# version.\nfrom __future__ import annotations\n\nfrom PIL import Image\n\nrepro = (\"00r0_gray_l.jp2\", \"00r1_graya_la.jp2\")\n\nfor path in repro:\n    with Image.open(path) as im:\n        try:\n            im.load()\n        except Exception as msg:\n            print(msg)\n", "Tests/check_imaging_leaks.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nfrom typing import Any, Callable\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import is_win32\n\nmin_iterations = 100\nmax_iterations = 10000\n\npytestmark = pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\")\n\n\ndef _get_mem_usage() -> float:\n    from resource import RUSAGE_SELF, getpagesize, getrusage\n\n    mem = getrusage(RUSAGE_SELF).ru_maxrss\n    return mem * getpagesize() / 1024 / 1024\n\n\ndef _test_leak(\n    min_iterations: int,\n    max_iterations: int,\n    fn: Callable[..., Image.Image | None],\n    *args: Any,\n) -> None:\n    mem_limit = None\n    for i in range(max_iterations):\n        fn(*args)\n        mem = _get_mem_usage()\n        if i < min_iterations:\n            mem_limit = mem + 1\n            continue\n        msg = f\"memory usage limit exceeded after {i + 1} iterations\"\n        assert mem_limit is not None\n        assert mem <= mem_limit, msg\n\n\ndef test_leak_putdata() -> None:\n    im = Image.new(\"RGB\", (25, 25))\n    _test_leak(min_iterations, max_iterations, im.putdata, im.getdata())\n\n\ndef test_leak_getlist() -> None:\n    im = Image.new(\"P\", (25, 25))\n    _test_leak(\n        min_iterations,\n        max_iterations,\n        # Pass a new list at each iteration.\n        lambda: im.point(range(256)),\n    )\n", "Tests/32bit_segfault_check.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport sys\n\nfrom PIL import Image\n\nif sys.maxsize < 2**32:\n    im = Image.new(\"L\", (999999, 999999), 0)\n", "Tests/check_j2k_overflow.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\n\ndef test_j2k_overflow(tmp_path: Path) -> None:\n    im = Image.new(\"RGBA\", (1024, 131584))\n    target = str(tmp_path / \"temp.jpc\")\n    with pytest.raises(OSError):\n        im.save(target)\n", "Tests/check_j2k_leaks.py": "from __future__ import annotations\n\nfrom io import BytesIO\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import is_win32, skip_unless_feature\n\n# Limits for testing the leak\nmem_limit = 1024 * 1048576\nstack_size = 8 * 1048576\niterations = int((mem_limit / stack_size) * 2)\ntest_file = \"Tests/images/rgb_trns_ycbc.jp2\"\n\npytestmark = [\n    pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\"),\n    skip_unless_feature(\"jpg_2000\"),\n]\n\n\ndef test_leak_load() -> None:\n    from resource import RLIMIT_AS, RLIMIT_STACK, setrlimit\n\n    setrlimit(RLIMIT_STACK, (stack_size, stack_size))\n    setrlimit(RLIMIT_AS, (mem_limit, mem_limit))\n    for _ in range(iterations):\n        with Image.open(test_file) as im:\n            im.load()\n\n\ndef test_leak_save() -> None:\n    from resource import RLIMIT_AS, RLIMIT_STACK, setrlimit\n\n    setrlimit(RLIMIT_STACK, (stack_size, stack_size))\n    setrlimit(RLIMIT_AS, (mem_limit, mem_limit))\n    for _ in range(iterations):\n        with Image.open(test_file) as im:\n            im.load()\n            test_output = BytesIO()\n            im.save(test_output, \"JPEG2000\")\n            test_output.seek(0)\n            test_output.read()\n", "Tests/check_icns_dos.py": "# Tests potential DOS of IcnsImagePlugin with 0 length block.\n# Run from anywhere that PIL is importable.\nfrom __future__ import annotations\n\nfrom io import BytesIO\n\nfrom PIL import Image\n\nwith Image.open(BytesIO(b\"icns\\x00\\x00\\x00\\x10hang\\x00\\x00\\x00\\x00\")):\n    pass\n", "Tests/check_png_dos.py": "from __future__ import annotations\n\nimport zlib\nfrom io import BytesIO\n\nfrom PIL import Image, ImageFile, PngImagePlugin\n\nTEST_FILE = \"Tests/images/png_decompression_dos.png\"\n\n\ndef test_ignore_dos_text() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = True\n\n    try:\n        im = Image.open(TEST_FILE)\n        im.load()\n    finally:\n        ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    assert isinstance(im, PngImagePlugin.PngImageFile)\n    for s in im.text.values():\n        assert len(s) < 1024 * 1024, \"Text chunk larger than 1M\"\n\n    for s in im.info.values():\n        assert len(s) < 1024 * 1024, \"Text chunk larger than 1M\"\n\n\ndef test_dos_text() -> None:\n    try:\n        im = Image.open(TEST_FILE)\n        im.load()\n    except ValueError as msg:\n        assert msg, \"Decompressed Data Too Large\"\n        return\n\n    assert isinstance(im, PngImagePlugin.PngImageFile)\n    for s in im.text.values():\n        assert len(s) < 1024 * 1024, \"Text chunk larger than 1M\"\n\n\ndef test_dos_total_memory() -> None:\n    im = Image.new(\"L\", (1, 1))\n    compressed_data = zlib.compress(b\"a\" * 1024 * 1023)\n\n    info = PngImagePlugin.PngInfo()\n\n    for x in range(64):\n        info.add_text(f\"t{x}\", compressed_data, zip=True)\n        info.add_itxt(f\"i{x}\", compressed_data, zip=True)\n\n    b = BytesIO()\n    im.save(b, \"PNG\", pnginfo=info)\n    b.seek(0)\n\n    try:\n        im2 = Image.open(b)\n    except ValueError as msg:\n        assert \"Too much memory\" in str(msg)\n        return\n\n    total_len = 0\n    assert isinstance(im2, PngImagePlugin.PngImageFile)\n    for txt in im2.text.values():\n        total_len += len(txt)\n    assert total_len < 64 * 1024 * 1024, \"Total text chunks greater than 64M\"\n", "Tests/check_j2k_dos.py": "# Tests potential DOS of Jpeg2kImagePlugin with 0 length block.\n# Run from anywhere that PIL is importable.\nfrom __future__ import annotations\n\nfrom io import BytesIO\n\nfrom PIL import Image\n\nwith Image.open(\n    BytesIO(b\"\\x00\\x00\\x00\\x0cjP\\x20\\x20\\x0d\\x0a\\x87\\x0a\\x00\\x00\\x00\\x00hang\")\n):\n    pass\n", "Tests/helper.py": "\"\"\"\nHelper functions.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport sysconfig\nimport tempfile\nfrom functools import lru_cache\nfrom io import BytesIO\nfrom typing import Any, Callable, Sequence\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nfrom PIL import Image, ImageFile, ImageMath, features\n\nlogger = logging.getLogger(__name__)\n\nuploader = None\nif os.environ.get(\"SHOW_ERRORS\"):\n    uploader = \"show\"\nelif \"GITHUB_ACTIONS\" in os.environ:\n    uploader = \"github_actions\"\n\n\ndef upload(a: Image.Image, b: Image.Image) -> str | None:\n    if uploader == \"show\":\n        # local img.show for errors.\n        a.show()\n        b.show()\n    elif uploader == \"github_actions\":\n        dir_errors = os.path.join(os.path.dirname(__file__), \"errors\")\n        os.makedirs(dir_errors, exist_ok=True)\n        tmpdir = tempfile.mkdtemp(dir=dir_errors)\n        a.save(os.path.join(tmpdir, \"a.png\"))\n        b.save(os.path.join(tmpdir, \"b.png\"))\n        return tmpdir\n    return None\n\n\ndef convert_to_comparable(\n    a: Image.Image, b: Image.Image\n) -> tuple[Image.Image, Image.Image]:\n    new_a, new_b = a, b\n    if a.mode == \"P\":\n        new_a = Image.new(\"L\", a.size)\n        new_b = Image.new(\"L\", b.size)\n        new_a.putdata(a.getdata())\n        new_b.putdata(b.getdata())\n    elif a.mode == \"I;16\":\n        new_a = a.convert(\"I\")\n        new_b = b.convert(\"I\")\n    return new_a, new_b\n\n\ndef assert_deep_equal(\n    a: Sequence[Any], b: Sequence[Any], msg: str | None = None\n) -> None:\n    try:\n        assert len(a) == len(b), msg or f\"got length {len(a)}, expected {len(b)}\"\n    except Exception:\n        assert a == b, msg\n\n\ndef assert_image(\n    im: Image.Image, mode: str, size: tuple[int, int], msg: str | None = None\n) -> None:\n    if mode is not None:\n        assert im.mode == mode, (\n            msg or f\"got mode {repr(im.mode)}, expected {repr(mode)}\"\n        )\n\n    if size is not None:\n        assert im.size == size, (\n            msg or f\"got size {repr(im.size)}, expected {repr(size)}\"\n        )\n\n\ndef assert_image_equal(a: Image.Image, b: Image.Image, msg: str | None = None) -> None:\n    assert a.mode == b.mode, msg or f\"got mode {repr(a.mode)}, expected {repr(b.mode)}\"\n    assert a.size == b.size, msg or f\"got size {repr(a.size)}, expected {repr(b.size)}\"\n    if a.tobytes() != b.tobytes():\n        try:\n            url = upload(a, b)\n            if url:\n                logger.error(\"URL for test images: %s\", url)\n        except Exception:\n            pass\n\n        pytest.fail(msg or \"got different content\")\n\n\ndef assert_image_equal_tofile(\n    a: Image.Image, filename: str, msg: str | None = None, mode: str | None = None\n) -> None:\n    with Image.open(filename) as img:\n        if mode:\n            img = img.convert(mode)\n        assert_image_equal(a, img, msg)\n\n\ndef assert_image_similar(\n    a: Image.Image, b: Image.Image, epsilon: float, msg: str | None = None\n) -> None:\n    assert a.mode == b.mode, msg or f\"got mode {repr(a.mode)}, expected {repr(b.mode)}\"\n    assert a.size == b.size, msg or f\"got size {repr(a.size)}, expected {repr(b.size)}\"\n\n    a, b = convert_to_comparable(a, b)\n\n    diff = 0\n    for ach, bch in zip(a.split(), b.split()):\n        chdiff = ImageMath.lambda_eval(\n            lambda args: abs(args[\"a\"] - args[\"b\"]), a=ach, b=bch\n        ).convert(\"L\")\n        diff += sum(i * num for i, num in enumerate(chdiff.histogram()))\n\n    ave_diff = diff / (a.size[0] * a.size[1])\n    try:\n        assert epsilon >= ave_diff, (\n            (msg or \"\")\n            + f\" average pixel value difference {ave_diff:.4f} > epsilon {epsilon:.4f}\"\n        )\n    except Exception as e:\n        try:\n            url = upload(a, b)\n            if url:\n                logger.exception(\"URL for test images: %s\", url)\n        except Exception:\n            pass\n        raise e\n\n\ndef assert_image_similar_tofile(\n    a: Image.Image,\n    filename: str,\n    epsilon: float,\n    msg: str | None = None,\n    mode: str | None = None,\n) -> None:\n    with Image.open(filename) as img:\n        if mode:\n            img = img.convert(mode)\n        assert_image_similar(a, img, epsilon, msg)\n\n\ndef assert_all_same(items: Sequence[Any], msg: str | None = None) -> None:\n    assert items.count(items[0]) == len(items), msg\n\n\ndef assert_not_all_same(items: Sequence[Any], msg: str | None = None) -> None:\n    assert items.count(items[0]) != len(items), msg\n\n\ndef assert_tuple_approx_equal(\n    actuals: Sequence[int], targets: tuple[int, ...], threshold: int, msg: str\n) -> None:\n    \"\"\"Tests if actuals has values within threshold from targets\"\"\"\n    for i, target in enumerate(targets):\n        if not (target - threshold <= actuals[i] <= target + threshold):\n            pytest.fail(msg + \": \" + repr(actuals) + \" != \" + repr(targets))\n\n\ndef skip_unless_feature(feature: str) -> pytest.MarkDecorator:\n    reason = f\"{feature} not available\"\n    return pytest.mark.skipif(not features.check(feature), reason=reason)\n\n\ndef skip_unless_feature_version(\n    feature: str, required: str, reason: str | None = None\n) -> pytest.MarkDecorator:\n    version = features.version(feature)\n    if version is None:\n        return pytest.mark.skip(f\"{feature} not available\")\n    if reason is None:\n        reason = f\"{feature} is older than {required}\"\n    version_required = parse_version(required)\n    version_available = parse_version(version)\n    return pytest.mark.skipif(version_available < version_required, reason=reason)\n\n\ndef mark_if_feature_version(\n    mark: pytest.MarkDecorator,\n    feature: str,\n    version_blacklist: str,\n    reason: str | None = None,\n) -> pytest.MarkDecorator:\n    version = features.version(feature)\n    if version is None:\n        return pytest.mark.pil_noop_mark()\n    if reason is None:\n        reason = f\"{feature} is {version_blacklist}\"\n    version_required = parse_version(version_blacklist)\n    version_available = parse_version(version)\n    if (\n        version_available.major == version_required.major\n        and version_available.minor == version_required.minor\n    ):\n        return mark(reason=reason)\n    return pytest.mark.pil_noop_mark()\n\n\n@pytest.mark.skipif(sys.platform.startswith(\"win32\"), reason=\"Requires Unix or macOS\")\nclass PillowLeakTestCase:\n    # requires unix/macOS\n    iterations = 100  # count\n    mem_limit = 512  # k\n\n    def _get_mem_usage(self) -> float:\n        \"\"\"\n        Gets the RUSAGE memory usage, returns in K. Encapsulates the difference\n        between macOS and Linux rss reporting\n\n        :returns: memory usage in kilobytes\n        \"\"\"\n\n        from resource import RUSAGE_SELF, getrusage\n\n        mem = getrusage(RUSAGE_SELF).ru_maxrss\n        # man 2 getrusage:\n        #     ru_maxrss\n        # This is the maximum resident set size utilized\n        # in bytes on macOS, in kilobytes on Linux\n        return mem / 1024 if sys.platform == \"darwin\" else mem\n\n    def _test_leak(self, core: Callable[[], None]) -> None:\n        start_mem = self._get_mem_usage()\n        for cycle in range(self.iterations):\n            core()\n            mem = self._get_mem_usage() - start_mem\n            msg = f\"memory usage limit exceeded in iteration {cycle}\"\n            assert mem < self.mem_limit, msg\n\n\n# helpers\n\n\ndef fromstring(data: bytes) -> ImageFile.ImageFile:\n    return Image.open(BytesIO(data))\n\n\ndef tostring(im: Image.Image, string_format: str, **options: Any) -> bytes:\n    out = BytesIO()\n    im.save(out, string_format, **options)\n    return out.getvalue()\n\n\ndef hopper(mode: str | None = None) -> Image.Image:\n    # Use caching to reduce reading from disk, but return a copy\n    # so that the cached image isn't modified by the tests\n    # (for fast, isolated, repeatable tests).\n\n    if mode is None:\n        # Always return fresh not-yet-loaded version of image.\n        # Operations on not-yet-loaded images are a separate class of errors\n        # that we should catch.\n        return Image.open(\"Tests/images/hopper.ppm\")\n\n    return _cached_hopper(mode).copy()\n\n\n@lru_cache\ndef _cached_hopper(mode: str) -> Image.Image:\n    if mode == \"F\":\n        im = hopper(\"L\")\n    else:\n        im = hopper()\n    if mode.startswith(\"BGR;\"):\n        with pytest.warns(DeprecationWarning):\n            im = im.convert(mode)\n    else:\n        try:\n            im = im.convert(mode)\n        except ImportError:\n            if mode == \"LAB\":\n                im = Image.open(\"Tests/images/hopper.Lab.tif\")\n            else:\n                raise\n    return im\n\n\ndef djpeg_available() -> bool:\n    if shutil.which(\"djpeg\"):\n        try:\n            subprocess.check_call([\"djpeg\", \"-version\"])\n            return True\n        except subprocess.CalledProcessError:  # pragma: no cover\n            return False\n    return False\n\n\ndef cjpeg_available() -> bool:\n    if shutil.which(\"cjpeg\"):\n        try:\n            subprocess.check_call([\"cjpeg\", \"-version\"])\n            return True\n        except subprocess.CalledProcessError:  # pragma: no cover\n            return False\n    return False\n\n\ndef netpbm_available() -> bool:\n    return bool(shutil.which(\"ppmquant\") and shutil.which(\"ppmtogif\"))\n\n\ndef magick_command() -> list[str] | None:\n    if sys.platform == \"win32\":\n        magickhome = os.environ.get(\"MAGICK_HOME\")\n        if magickhome:\n            imagemagick = [os.path.join(magickhome, \"convert.exe\")]\n            graphicsmagick = [os.path.join(magickhome, \"gm.exe\"), \"convert\"]\n        else:\n            imagemagick = None\n            graphicsmagick = None\n    else:\n        imagemagick = [\"convert\"]\n        graphicsmagick = [\"gm\", \"convert\"]\n\n    if imagemagick and shutil.which(imagemagick[0]):\n        return imagemagick\n    if graphicsmagick and shutil.which(graphicsmagick[0]):\n        return graphicsmagick\n    return None\n\n\ndef on_appveyor() -> bool:\n    return \"APPVEYOR\" in os.environ\n\n\ndef on_github_actions() -> bool:\n    return \"GITHUB_ACTIONS\" in os.environ\n\n\ndef on_ci() -> bool:\n    # GitHub Actions and AppVeyor have \"CI\"\n    return \"CI\" in os.environ\n\n\ndef is_big_endian() -> bool:\n    return sys.byteorder == \"big\"\n\n\ndef is_ppc64le() -> bool:\n    import platform\n\n    return platform.machine() == \"ppc64le\"\n\n\ndef is_win32() -> bool:\n    return sys.platform.startswith(\"win32\")\n\n\ndef is_pypy() -> bool:\n    return hasattr(sys, \"pypy_translation_info\")\n\n\ndef is_mingw() -> bool:\n    return sysconfig.get_platform() == \"mingw\"\n\n\nclass CachedProperty:\n    def __init__(self, func: Callable[[Any], Any]) -> None:\n        self.func = func\n\n    def __get__(self, instance: Any, cls: type[Any] | None = None) -> Any:\n        result = instance.__dict__[self.func.__name__] = self.func(instance)\n        return result\n", "Tests/check_large_memory_numpy.py": "from __future__ import annotations\n\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\n# This test is not run automatically.\n#\n# It requires > 2gb memory for the >2 gigapixel image generated in the\n# second test.  Running this automatically would amount to a denial of\n# service on our testing infrastructure.  I expect this test to fail\n# on any 32-bit machine, as well as any smallish things (like\n# Raspberry Pis).\n\n\nnp = pytest.importorskip(\"numpy\", reason=\"NumPy not installed\")\n\nYDIM = 32769\nXDIM = 48000\n\n\npytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason=\"requires 64-bit system\")\n\n\ndef _write_png(tmp_path: Path, xdim: int, ydim: int) -> None:\n    dtype = np.uint8\n    a = np.zeros((xdim, ydim), dtype=dtype)\n    f = str(tmp_path / \"temp.png\")\n    im = Image.fromarray(a, \"L\")\n    im.save(f)\n\n\ndef test_large(tmp_path: Path) -> None:\n    \"\"\"succeeded prepatch\"\"\"\n    _write_png(tmp_path, XDIM, YDIM)\n\n\ndef test_2gpx(tmp_path: Path) -> None:\n    \"\"\"failed prepatch\"\"\"\n    _write_png(tmp_path, XDIM, XDIM)\n", "Tests/check_fli_oob.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nrepro_ss2 = (\n    \"images/fli_oob/06r/06r00.fli\",\n    \"images/fli_oob/06r/others/06r01.fli\",\n    \"images/fli_oob/06r/others/06r02.fli\",\n    \"images/fli_oob/06r/others/06r03.fli\",\n    \"images/fli_oob/06r/others/06r04.fli\",\n)\n\nrepro_lc = (\n    \"images/fli_oob/05r/05r00.fli\",\n    \"images/fli_oob/05r/others/05r03.fli\",\n    \"images/fli_oob/05r/others/05r06.fli\",\n    \"images/fli_oob/05r/others/05r05.fli\",\n    \"images/fli_oob/05r/others/05r01.fli\",\n    \"images/fli_oob/05r/others/05r04.fli\",\n    \"images/fli_oob/05r/others/05r02.fli\",\n    \"images/fli_oob/05r/others/05r07.fli\",\n    \"images/fli_oob/patch0/000000\",\n    \"images/fli_oob/patch0/000001\",\n    \"images/fli_oob/patch0/000002\",\n    \"images/fli_oob/patch0/000003\",\n)\n\n\nrepro_advance = (\n    \"images/fli_oob/03r/03r00.fli\",\n    \"images/fli_oob/03r/others/03r01.fli\",\n    \"images/fli_oob/03r/others/03r09.fli\",\n    \"images/fli_oob/03r/others/03r11.fli\",\n    \"images/fli_oob/03r/others/03r05.fli\",\n    \"images/fli_oob/03r/others/03r10.fli\",\n    \"images/fli_oob/03r/others/03r06.fli\",\n    \"images/fli_oob/03r/others/03r08.fli\",\n    \"images/fli_oob/03r/others/03r03.fli\",\n    \"images/fli_oob/03r/others/03r07.fli\",\n    \"images/fli_oob/03r/others/03r02.fli\",\n    \"images/fli_oob/03r/others/03r04.fli\",\n)\n\nrepro_brun = (\n    \"images/fli_oob/04r/initial.fli\",\n    \"images/fli_oob/04r/others/04r02.fli\",\n    \"images/fli_oob/04r/others/04r05.fli\",\n    \"images/fli_oob/04r/others/04r04.fli\",\n    \"images/fli_oob/04r/others/04r03.fli\",\n    \"images/fli_oob/04r/others/04r01.fli\",\n    \"images/fli_oob/04r/04r00.fli\",\n)\n\nrepro_copy = (\n    \"images/fli_oob/02r/others/02r02.fli\",\n    \"images/fli_oob/02r/others/02r04.fli\",\n    \"images/fli_oob/02r/others/02r03.fli\",\n    \"images/fli_oob/02r/others/02r01.fli\",\n    \"images/fli_oob/02r/02r00.fli\",\n)\n\n\nfor path in repro_ss2 + repro_lc + repro_advance + repro_brun + repro_copy:\n    with Image.open(path) as im:\n        try:\n            im.load()\n        except Exception as msg:\n            print(msg)\n", "Tests/check_large_memory.py": "from __future__ import annotations\n\nimport sys\nfrom pathlib import Path\nfrom types import ModuleType\n\nimport pytest\n\nfrom PIL import Image\n\n# This test is not run automatically.\n#\n# It requires > 2gb memory for the >2 gigapixel image generated in the\n# second test.  Running this automatically would amount to a denial of\n# service on our testing infrastructure.  I expect this test to fail\n# on any 32-bit machine, as well as any smallish things (like\n# Raspberry Pis). It does succeed on a 3gb Ubuntu 12.04x64 VM on Python\n# 2.7 and 3.2.\n\n\nnumpy: ModuleType | None\ntry:\n    import numpy\nexcept ImportError:\n    numpy = None\n\nYDIM = 32769\nXDIM = 48000\n\n\npytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason=\"requires 64-bit system\")\n\n\ndef _write_png(tmp_path: Path, xdim: int, ydim: int) -> None:\n    f = str(tmp_path / \"temp.png\")\n    im = Image.new(\"L\", (xdim, ydim), 0)\n    im.save(f)\n\n\ndef test_large(tmp_path: Path) -> None:\n    \"\"\"succeeded prepatch\"\"\"\n    _write_png(tmp_path, XDIM, YDIM)\n\n\ndef test_2gpx(tmp_path: Path) -> None:\n    \"\"\"failed prepatch\"\"\"\n    _write_png(tmp_path, XDIM, XDIM)\n\n\n@pytest.mark.skipif(numpy is None, reason=\"Numpy is not installed\")\ndef test_size_greater_than_int() -> None:\n    assert numpy is not None\n    arr = numpy.ndarray(shape=(16394, 16394))\n    Image.fromarray(arr)\n", "Tests/__init__.py": "", "Tests/check_wheel.py": "from __future__ import annotations\n\nimport sys\n\nfrom PIL import features\n\n\ndef test_wheel_modules() -> None:\n    expected_modules = {\"pil\", \"tkinter\", \"freetype2\", \"littlecms2\", \"webp\"}\n\n    # tkinter is not available in cibuildwheel installed CPython on Windows\n    try:\n        import tkinter\n\n        assert tkinter\n    except ImportError:\n        expected_modules.remove(\"tkinter\")\n\n    assert set(features.get_supported_modules()) == expected_modules\n\n\ndef test_wheel_codecs() -> None:\n    expected_codecs = {\"jpg\", \"jpg_2000\", \"zlib\", \"libtiff\"}\n\n    assert set(features.get_supported_codecs()) == expected_codecs\n\n\ndef test_wheel_features() -> None:\n    expected_features = {\n        \"webp_anim\",\n        \"webp_mux\",\n        \"transp_webp\",\n        \"raqm\",\n        \"fribidi\",\n        \"harfbuzz\",\n        \"libjpeg_turbo\",\n        \"xcb\",\n    }\n\n    if sys.platform == \"win32\":\n        expected_features.remove(\"xcb\")\n\n    assert set(features.get_supported_features()) == expected_features\n", "Tests/oss-fuzz/fuzz_pillow.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport atheris\n\nwith atheris.instrument_imports():\n    import sys\n\n    import fuzzers\n\n\ndef TestOneInput(data: bytes) -> None:\n    try:\n        fuzzers.fuzz_image(data)\n    except Exception:\n        # We're catching all exceptions because Pillow's exceptions are\n        # directly inheriting from Exception.\n        pass\n\n\ndef main() -> None:\n    fuzzers.enable_decompressionbomb_error()\n    atheris.Setup(sys.argv, TestOneInput)\n    atheris.Fuzz()\n    fuzzers.disable_decompressionbomb_error()\n\n\nif __name__ == \"__main__\":\n    main()\n", "Tests/oss-fuzz/fuzz_font.py": "#!/usr/bin/python3\n\n# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport atheris\n\nwith atheris.instrument_imports():\n    import sys\n\n    import fuzzers\n\n\ndef TestOneInput(data: bytes) -> None:\n    try:\n        fuzzers.fuzz_font(data)\n    except Exception:\n        # We're catching all exceptions because Pillow's exceptions are\n        # directly inheriting from Exception.\n        pass\n\n\ndef main() -> None:\n    fuzzers.enable_decompressionbomb_error()\n    atheris.Setup(sys.argv, TestOneInput)\n    atheris.Fuzz()\n    fuzzers.disable_decompressionbomb_error()\n\n\nif __name__ == \"__main__\":\n    main()\n", "Tests/oss-fuzz/fuzzers.py": "from __future__ import annotations\n\nimport io\nimport warnings\n\nfrom PIL import Image, ImageDraw, ImageFile, ImageFilter, ImageFont\n\n\ndef enable_decompressionbomb_error() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = True\n    warnings.filterwarnings(\"ignore\")\n    warnings.simplefilter(\"error\", Image.DecompressionBombWarning)\n\n\ndef disable_decompressionbomb_error() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = False\n    warnings.resetwarnings()\n\n\ndef fuzz_image(data: bytes) -> None:\n    # This will fail on some images in the corpus, as we have many\n    # invalid images in the test suite.\n    with Image.open(io.BytesIO(data)) as im:\n        im.rotate(45)\n        im.filter(ImageFilter.DETAIL)\n        im.save(io.BytesIO(), \"BMP\")\n\n\ndef fuzz_font(data: bytes) -> None:\n    wrapper = io.BytesIO(data)\n    try:\n        font = ImageFont.truetype(wrapper)\n    except OSError:\n        # Catch pcf/pilfonts/random garbage here. They return\n        # different font objects.\n        return\n\n    font.getbbox(\"ABC\")\n    font.getmask(\"test text\")\n    with Image.new(mode=\"RGBA\", size=(200, 200)) as im:\n        draw = ImageDraw.Draw(im)\n        draw.multiline_textbbox((10, 10), \"ABC\\nAaaa\", font, stroke_width=2)\n        draw.text((10, 10), \"Test Text\", font=font, fill=\"#000\")\n", "winbuild/build_prepare.py": "from __future__ import annotations\n\nimport argparse\nimport os\nimport platform\nimport re\nimport shutil\nimport struct\nimport subprocess\n\n\ndef cmd_cd(path: str) -> str:\n    return f\"cd /D {path}\"\n\n\ndef cmd_set(name: str, value: str) -> str:\n    return f\"set {name}={value}\"\n\n\ndef cmd_append(name: str, value: str) -> str:\n    op = \"path \" if name == \"PATH\" else f\"set {name}=\"\n    return op + f\"%{name}%;{value}\"\n\n\ndef cmd_copy(src: str, tgt: str) -> str:\n    return f'copy /Y /B \"{src}\" \"{tgt}\"'\n\n\ndef cmd_xcopy(src: str, tgt: str) -> str:\n    return f'xcopy /Y /E \"{src}\" \"{tgt}\"'\n\n\ndef cmd_mkdir(path: str) -> str:\n    return f'mkdir \"{path}\"'\n\n\ndef cmd_rmdir(path: str) -> str:\n    return f'rmdir /S /Q \"{path}\"'\n\n\ndef cmd_nmake(\n    makefile: str | None = None,\n    target: str = \"\",\n    params: list[str] | None = None,\n) -> str:\n    params = \"\" if params is None else \" \".join(params)\n\n    return \" \".join(\n        [\n            \"{nmake}\",\n            \"-nologo\",\n            f'-f \"{makefile}\"' if makefile is not None else \"\",\n            f\"{params}\",\n            f'\"{target}\"',\n        ]\n    )\n\n\ndef cmds_cmake(\n    target: str | tuple[str, ...] | list[str], *params, build_dir: str = \".\"\n) -> list[str]:\n    if not isinstance(target, str):\n        target = \" \".join(target)\n\n    return [\n        \" \".join(\n            [\n                \"{cmake}\",\n                \"-DCMAKE_BUILD_TYPE=Release\",\n                \"-DCMAKE_VERBOSE_MAKEFILE=ON\",\n                \"-DCMAKE_RULE_MESSAGES:BOOL=OFF\",  # for NMake\n                \"-DCMAKE_C_COMPILER=cl.exe\",  # for Ninja\n                \"-DCMAKE_CXX_COMPILER=cl.exe\",  # for Ninja\n                \"-DCMAKE_C_FLAGS=-nologo\",\n                \"-DCMAKE_CXX_FLAGS=-nologo\",\n                *params,\n                '-G \"{cmake_generator}\"',\n                f'-B \"{build_dir}\"',\n                \"-S .\",\n            ]\n        ),\n        f'{{cmake}} --build \"{build_dir}\" --clean-first --parallel --target {target}',\n    ]\n\n\ndef cmd_msbuild(\n    file: str,\n    configuration: str = \"Release\",\n    target: str = \"Build\",\n    plat: str = \"{msbuild_arch}\",\n) -> str:\n    return \" \".join(\n        [\n            \"{msbuild}\",\n            f\"{file}\",\n            f'/t:\"{target}\"',\n            f'/p:Configuration=\"{configuration}\"',\n            f\"/p:Platform={plat}\",\n            \"/m\",\n        ]\n    )\n\n\nSF_PROJECTS = \"https://sourceforge.net/projects\"\n\nARCHITECTURES = {\n    \"x86\": {\"vcvars_arch\": \"x86\", \"msbuild_arch\": \"Win32\"},\n    \"AMD64\": {\"vcvars_arch\": \"x86_amd64\", \"msbuild_arch\": \"x64\"},\n    \"ARM64\": {\"vcvars_arch\": \"x86_arm64\", \"msbuild_arch\": \"ARM64\"},\n}\n\nV = {\n    \"BROTLI\": \"1.1.0\",\n    \"FREETYPE\": \"2.13.2\",\n    \"FRIBIDI\": \"1.0.15\",\n    \"HARFBUZZ\": \"8.5.0\",\n    \"JPEGTURBO\": \"3.0.3\",\n    \"LCMS2\": \"2.16\",\n    \"LIBPNG\": \"1.6.43\",\n    \"LIBWEBP\": \"1.4.0\",\n    \"OPENJPEG\": \"2.5.2\",\n    \"TIFF\": \"4.6.0\",\n    \"XZ\": \"5.4.5\",\n    \"ZLIB\": \"1.3.1\",\n}\nV[\"LIBPNG_DOTLESS\"] = V[\"LIBPNG\"].replace(\".\", \"\")\nV[\"LIBPNG_XY\"] = \"\".join(V[\"LIBPNG\"].split(\".\")[:2])\nV[\"ZLIB_DOTLESS\"] = V[\"ZLIB\"].replace(\".\", \"\")\n\n\n# dependencies, listed in order of compilation\nDEPS = {\n    \"libjpeg\": {\n        \"url\": f\"{SF_PROJECTS}/libjpeg-turbo/files/{V['JPEGTURBO']}/\"\n        f\"libjpeg-turbo-{V['JPEGTURBO']}.tar.gz/download\",\n        \"filename\": f\"libjpeg-turbo-{V['JPEGTURBO']}.tar.gz\",\n        \"dir\": f\"libjpeg-turbo-{V['JPEGTURBO']}\",\n        \"license\": [\"README.ijg\", \"LICENSE.md\"],\n        \"license_pattern\": (\n            \"(LEGAL ISSUES\\n============\\n\\n.+?)\\n\\nREFERENCES\\n==========\"\n            \".+(libjpeg-turbo Licenses\\n======================\\n\\n.+)$\"\n        ),\n        \"patch\": {\n            r\"CMakeLists.txt\": {\n                # libjpeg-turbo does not detect MSVC x86_arm64 cross-compiler correctly\n                'if(MSVC_IDE AND CMAKE_GENERATOR_PLATFORM MATCHES \"arm64\")': \"if({architecture} STREQUAL ARM64)\",  # noqa: E501\n            },\n        },\n        \"build\": [\n            *cmds_cmake(\n                (\"jpeg-static\", \"cjpeg-static\", \"djpeg-static\"),\n                \"-DENABLE_SHARED:BOOL=FALSE\",\n                \"-DWITH_JPEG8:BOOL=TRUE\",\n                \"-DWITH_CRT_DLL:BOOL=TRUE\",\n            ),\n            cmd_copy(\"jpeg-static.lib\", \"libjpeg.lib\"),\n            cmd_copy(\"cjpeg-static.exe\", \"cjpeg.exe\"),\n            cmd_copy(\"djpeg-static.exe\", \"djpeg.exe\"),\n        ],\n        \"headers\": [\"j*.h\"],\n        \"libs\": [\"libjpeg.lib\"],\n        \"bins\": [\"cjpeg.exe\", \"djpeg.exe\"],\n    },\n    \"zlib\": {\n        \"url\": f\"https://zlib.net/zlib{V['ZLIB_DOTLESS']}.zip\",\n        \"filename\": f\"zlib{V['ZLIB_DOTLESS']}.zip\",\n        \"dir\": f\"zlib-{V['ZLIB']}\",\n        \"license\": \"README\",\n        \"license_pattern\": \"Copyright notice:\\n\\n(.+)$\",\n        \"build\": [\n            cmd_nmake(r\"win32\\Makefile.msc\", \"clean\"),\n            cmd_nmake(r\"win32\\Makefile.msc\", \"zlib.lib\"),\n            cmd_copy(\"zlib.lib\", \"z.lib\"),\n        ],\n        \"headers\": [r\"z*.h\"],\n        \"libs\": [r\"*.lib\"],\n    },\n    \"xz\": {\n        \"url\": f\"{SF_PROJECTS}/lzmautils/files/xz-{V['XZ']}.tar.gz/download\",\n        \"filename\": f\"xz-{V['XZ']}.tar.gz\",\n        \"dir\": f\"xz-{V['XZ']}\",\n        \"license\": \"COPYING\",\n        \"build\": [\n            *cmds_cmake(\"liblzma\", \"-DBUILD_SHARED_LIBS:BOOL=OFF\"),\n            cmd_mkdir(r\"{inc_dir}\\lzma\"),\n            cmd_copy(r\"src\\liblzma\\api\\lzma\\*.h\", r\"{inc_dir}\\lzma\"),\n        ],\n        \"headers\": [r\"src\\liblzma\\api\\lzma.h\"],\n        \"libs\": [r\"liblzma.lib\"],\n    },\n    \"libwebp\": {\n        \"url\": f\"http://downloads.webmproject.org/releases/webp/libwebp-{V['LIBWEBP']}.tar.gz\",\n        \"filename\": f\"libwebp-{V['LIBWEBP']}.tar.gz\",\n        \"dir\": f\"libwebp-{V['LIBWEBP']}\",\n        \"license\": \"COPYING\",\n        \"patch\": {\n            r\"src\\enc\\picture_csp_enc.c\": {\n                # link against libsharpyuv.lib\n                '#include \"sharpyuv/sharpyuv.h\"': '#include \"sharpyuv/sharpyuv.h\"\\n#pragma comment(lib, \"libsharpyuv.lib\")',  # noqa: E501\n            }\n        },\n        \"build\": [\n            *cmds_cmake(\n                \"webp webpdemux webpmux\",\n                \"-DBUILD_SHARED_LIBS:BOOL=OFF\",\n                \"-DWEBP_LINK_STATIC:BOOL=OFF\",\n            ),\n            cmd_mkdir(r\"{inc_dir}\\webp\"),\n            cmd_copy(r\"src\\webp\\*.h\", r\"{inc_dir}\\webp\"),\n        ],\n        \"libs\": [r\"libsharpyuv.lib\", r\"libwebp*.lib\"],\n    },\n    \"libtiff\": {\n        \"url\": f\"https://download.osgeo.org/libtiff/tiff-{V['TIFF']}.tar.gz\",\n        \"filename\": f\"tiff-{V['TIFF']}.tar.gz\",\n        \"dir\": f\"tiff-{V['TIFF']}\",\n        \"license\": \"LICENSE.md\",\n        \"patch\": {\n            r\"libtiff\\tif_lzma.c\": {\n                # link against liblzma.lib\n                \"#ifdef LZMA_SUPPORT\": '#ifdef LZMA_SUPPORT\\n#pragma comment(lib, \"liblzma.lib\")',  # noqa: E501\n            },\n            r\"libtiff\\tif_webp.c\": {\n                # link against libwebp.lib\n                \"#ifdef WEBP_SUPPORT\": '#ifdef WEBP_SUPPORT\\n#pragma comment(lib, \"libwebp.lib\")',  # noqa: E501\n            },\n            r\"test\\CMakeLists.txt\": {\n                \"add_executable(test_write_read_tags ../placeholder.h)\": \"\",\n                \"target_sources(test_write_read_tags PRIVATE test_write_read_tags.c)\": \"\",  # noqa: E501\n                \"target_link_libraries(test_write_read_tags PRIVATE tiff)\": \"\",\n                \"list(APPEND simple_tests test_write_read_tags)\": \"\",\n            },\n        },\n        \"build\": [\n            *cmds_cmake(\n                \"tiff\",\n                \"-DBUILD_SHARED_LIBS:BOOL=OFF\",\n                \"-DWebP_LIBRARY=libwebp\",\n                '-DCMAKE_C_FLAGS=\"-nologo -DLZMA_API_STATIC\"',\n            )\n        ],\n        \"headers\": [r\"libtiff\\tiff*.h\"],\n        \"libs\": [r\"libtiff\\*.lib\"],\n    },\n    \"libpng\": {\n        \"url\": f\"{SF_PROJECTS}/libpng/files/libpng{V['LIBPNG_XY']}/{V['LIBPNG']}/\"\n        f\"lpng{V['LIBPNG_DOTLESS']}.zip/download\",\n        \"filename\": f\"lpng{V['LIBPNG_DOTLESS']}.zip\",\n        \"dir\": f\"lpng{V['LIBPNG_DOTLESS']}\",\n        \"license\": \"LICENSE\",\n        \"build\": [\n            *cmds_cmake(\"png_static\", \"-DPNG_SHARED:BOOL=OFF\", \"-DPNG_TESTS:BOOL=OFF\"),\n            cmd_copy(\n                f\"libpng{V['LIBPNG_XY']}_static.lib\", f\"libpng{V['LIBPNG_XY']}.lib\"\n            ),\n        ],\n        \"headers\": [r\"png*.h\"],\n        \"libs\": [f\"libpng{V['LIBPNG_XY']}.lib\"],\n    },\n    \"brotli\": {\n        \"url\": f\"https://github.com/google/brotli/archive/refs/tags/v{V['BROTLI']}.tar.gz\",\n        \"filename\": f\"brotli-{V['BROTLI']}.tar.gz\",\n        \"dir\": f\"brotli-{V['BROTLI']}\",\n        \"license\": \"LICENSE\",\n        \"build\": [\n            *cmds_cmake((\"brotlicommon\", \"brotlidec\"), \"-DBUILD_SHARED_LIBS:BOOL=OFF\"),\n            cmd_xcopy(r\"c\\include\", \"{inc_dir}\"),\n        ],\n        \"libs\": [\"*.lib\"],\n    },\n    \"freetype\": {\n        \"url\": f\"https://download.savannah.gnu.org/releases/freetype/freetype-{V['FREETYPE']}.tar.gz\",\n        \"filename\": f\"freetype-{V['FREETYPE']}.tar.gz\",\n        \"dir\": f\"freetype-{V['FREETYPE']}\",\n        \"license\": [\"LICENSE.TXT\", r\"docs\\FTL.TXT\", r\"docs\\GPLv2.TXT\"],\n        \"patch\": {\n            r\"builds\\windows\\vc2010\\freetype.vcxproj\": {\n                # freetype setting is /MD for .dll and /MT for .lib, we need /MD\n                \"<RuntimeLibrary>MultiThreaded</RuntimeLibrary>\": \"<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\",  # noqa: E501\n                # freetype doesn't specify SDK version, MSBuild may guess incorrectly\n                '<PropertyGroup Label=\"Globals\">': '<PropertyGroup Label=\"Globals\">\\n    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>',  # noqa: E501\n            },\n            r\"builds\\windows\\vc2010\\freetype.user.props\": {\n                \"<UserDefines></UserDefines>\": \"<UserDefines>FT_CONFIG_OPTION_SYSTEM_ZLIB;FT_CONFIG_OPTION_USE_PNG;FT_CONFIG_OPTION_USE_HARFBUZZ;FT_CONFIG_OPTION_USE_BROTLI</UserDefines>\",  # noqa: E501\n                \"<UserIncludeDirectories></UserIncludeDirectories>\": r\"<UserIncludeDirectories>{dir_harfbuzz}\\src;{inc_dir}</UserIncludeDirectories>\",  # noqa: E501\n                \"<UserLibraryDirectories></UserLibraryDirectories>\": \"<UserLibraryDirectories>{lib_dir}</UserLibraryDirectories>\",  # noqa: E501\n                \"<UserDependencies></UserDependencies>\": f\"<UserDependencies>zlib.lib;libpng{V['LIBPNG_XY']}.lib;brotlicommon.lib;brotlidec.lib</UserDependencies>\",  # noqa: E501\n            },\n            r\"src/autofit/afshaper.c\": {\n                # link against harfbuzz.lib\n                \"#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ\": '#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ\\n#pragma comment(lib, \"harfbuzz.lib\")',  # noqa: E501\n            },\n        },\n        \"build\": [\n            cmd_rmdir(\"objs\"),\n            cmd_msbuild(\n                r\"builds\\windows\\vc2010\\freetype.sln\", \"Release Static\", \"Clean\"\n            ),\n            cmd_msbuild(\n                r\"builds\\windows\\vc2010\\freetype.sln\", \"Release Static\", \"Build\"\n            ),\n            cmd_xcopy(\"include\", \"{inc_dir}\"),\n        ],\n        \"libs\": [r\"objs\\{msbuild_arch}\\Release Static\\freetype.lib\"],\n    },\n    \"lcms2\": {\n        \"url\": f\"{SF_PROJECTS}/lcms/files/lcms/{V['LCMS2']}/lcms2-{V['LCMS2']}.tar.gz/download\",  # noqa: E501\n        \"filename\": f\"lcms2-{V['LCMS2']}.tar.gz\",\n        \"dir\": f\"lcms2-{V['LCMS2']}\",\n        \"license\": \"LICENSE\",\n        \"patch\": {\n            r\"Projects\\VC2022\\lcms2_static\\lcms2_static.vcxproj\": {\n                # default is /MD for x86 and /MT for x64, we need /MD always\n                \"<RuntimeLibrary>MultiThreaded</RuntimeLibrary>\": \"<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\",  # noqa: E501\n                # retarget to default toolset (selected by vcvarsall.bat)\n                \"<PlatformToolset>v143</PlatformToolset>\": \"<PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>\",  # noqa: E501\n                # retarget to latest (selected by vcvarsall.bat)\n                \"<WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\": \"<WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>\",  # noqa: E501\n            }\n        },\n        \"build\": [\n            cmd_rmdir(\"Lib\"),\n            cmd_rmdir(r\"Projects\\VC2022\\Release\"),\n            cmd_msbuild(r\"Projects\\VC2022\\lcms2.sln\", \"Release\", \"Clean\"),\n            cmd_msbuild(\n                r\"Projects\\VC2022\\lcms2.sln\", \"Release\", \"lcms2_static:Rebuild\"\n            ),\n            cmd_xcopy(\"include\", \"{inc_dir}\"),\n        ],\n        \"libs\": [r\"Lib\\MS\\*.lib\"],\n    },\n    \"openjpeg\": {\n        \"url\": f\"https://github.com/uclouvain/openjpeg/archive/v{V['OPENJPEG']}.tar.gz\",\n        \"filename\": f\"openjpeg-{V['OPENJPEG']}.tar.gz\",\n        \"dir\": f\"openjpeg-{V['OPENJPEG']}\",\n        \"license\": \"LICENSE\",\n        \"build\": [\n            *cmds_cmake(\n                \"openjp2\", \"-DBUILD_CODEC:BOOL=OFF\", \"-DBUILD_SHARED_LIBS:BOOL=OFF\"\n            ),\n            cmd_mkdir(rf\"{{inc_dir}}\\openjpeg-{V['OPENJPEG']}\"),\n            cmd_copy(r\"src\\lib\\openjp2\\*.h\", rf\"{{inc_dir}}\\openjpeg-{V['OPENJPEG']}\"),\n        ],\n        \"libs\": [r\"bin\\*.lib\"],\n    },\n    \"libimagequant\": {\n        # commit: Merge branch 'master' into msvc (matches 2.17.0 tag)\n        \"url\": \"https://github.com/ImageOptim/libimagequant/archive/e4c1334be0eff290af5e2b4155057c2953a313ab.zip\",\n        \"filename\": \"libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab.zip\",\n        \"dir\": \"libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab\",\n        \"license\": \"COPYRIGHT\",\n        \"patch\": {\n            \"CMakeLists.txt\": {\n                \"if(OPENMP_FOUND)\": \"if(false)\",\n                \"install\": \"#install\",\n                # libimagequant does not detect MSVC x86_arm64 cross-compiler correctly\n                \"if(${{CMAKE_SYSTEM_PROCESSOR}} STREQUAL ARM64)\": \"if({architecture} STREQUAL ARM64)\",  # noqa: E501\n            }\n        },\n        \"build\": [\n            *cmds_cmake(\"imagequant_a\"),\n            cmd_copy(\"imagequant_a.lib\", \"imagequant.lib\"),\n        ],\n        \"headers\": [r\"*.h\"],\n        \"libs\": [r\"imagequant.lib\"],\n    },\n    \"harfbuzz\": {\n        \"url\": f\"https://github.com/harfbuzz/harfbuzz/archive/{V['HARFBUZZ']}.zip\",\n        \"filename\": f\"harfbuzz-{V['HARFBUZZ']}.zip\",\n        \"dir\": f\"harfbuzz-{V['HARFBUZZ']}\",\n        \"license\": \"COPYING\",\n        \"build\": [\n            *cmds_cmake(\n                \"harfbuzz\",\n                \"-DHB_HAVE_FREETYPE:BOOL=TRUE\",\n                '-DCMAKE_CXX_FLAGS=\"-nologo -d2FH4-\"',\n            ),\n        ],\n        \"headers\": [r\"src\\*.h\"],\n        \"libs\": [r\"*.lib\"],\n    },\n    \"fribidi\": {\n        \"url\": f\"https://github.com/fribidi/fribidi/archive/v{V['FRIBIDI']}.zip\",\n        \"filename\": f\"fribidi-{V['FRIBIDI']}.zip\",\n        \"dir\": f\"fribidi-{V['FRIBIDI']}\",\n        \"license\": \"COPYING\",\n        \"build\": [\n            cmd_copy(r\"COPYING\", rf\"{{bin_dir}}\\fribidi-{V['FRIBIDI']}-COPYING\"),\n            cmd_copy(r\"{winbuild_dir}\\fribidi.cmake\", r\"CMakeLists.txt\"),\n            # generated tab.i files cannot be cross-compiled\n            \" ^&^& \".join(\n                [\n                    \"if {architecture}==ARM64 cmd /c call {vcvarsall} x86\",\n                    *cmds_cmake(\"fribidi-gen\", \"-DARCH=x86\", build_dir=\"build_x86\"),\n                ]\n            ),\n            *cmds_cmake(\"fribidi\", \"-DARCH={architecture}\"),\n        ],\n        \"bins\": [r\"*.dll\"],\n    },\n}\n\n\n# based on distutils._msvccompiler from CPython 3.7.4\ndef find_msvs(architecture: str) -> dict[str, str] | None:\n    root = os.environ.get(\"ProgramFiles(x86)\") or os.environ.get(\"ProgramFiles\")\n    if not root:\n        print(\"Program Files not found\")\n        return None\n\n    requires = [\"-requires\", \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\"]\n    if architecture == \"ARM64\":\n        requires += [\"-requires\", \"Microsoft.VisualStudio.Component.VC.Tools.ARM64\"]\n\n    try:\n        vspath = (\n            subprocess.check_output(\n                [\n                    os.path.join(\n                        root, \"Microsoft Visual Studio\", \"Installer\", \"vswhere.exe\"\n                    ),\n                    \"-latest\",\n                    \"-prerelease\",\n                    *requires,\n                    \"-property\",\n                    \"installationPath\",\n                    \"-products\",\n                    \"*\",\n                ]\n            )\n            .decode(encoding=\"mbcs\")\n            .strip()\n        )\n    except (subprocess.CalledProcessError, OSError, UnicodeDecodeError):\n        print(\"vswhere not found\")\n        return None\n\n    if not os.path.isdir(os.path.join(vspath, \"VC\", \"Auxiliary\", \"Build\")):\n        print(\"Visual Studio seems to be missing C compiler\")\n        return None\n\n    # vs2017\n    msbuild = os.path.join(vspath, \"MSBuild\", \"15.0\", \"Bin\", \"MSBuild.exe\")\n    if not os.path.isfile(msbuild):\n        # vs2019\n        msbuild = os.path.join(vspath, \"MSBuild\", \"Current\", \"Bin\", \"MSBuild.exe\")\n        if not os.path.isfile(msbuild):\n            print(\"Visual Studio MSBuild not found\")\n            return None\n\n    vcvarsall = os.path.join(vspath, \"VC\", \"Auxiliary\", \"Build\", \"vcvarsall.bat\")\n    if not os.path.isfile(vcvarsall):\n        print(\"Visual Studio vcvarsall not found\")\n        return None\n\n    return {\n        \"vs_dir\": vspath,\n        \"msbuild\": f'\"{msbuild}\"',\n        \"vcvarsall\": f'\"{vcvarsall}\"',\n        \"nmake\": \"nmake.exe\",  # nmake selected by vcvarsall\n    }\n\n\ndef download_dep(url: str, file: str) -> None:\n    import urllib.error\n    import urllib.request\n\n    ex = None\n    for i in range(3):\n        try:\n            print(f\"Fetching {url} (attempt {i + 1})...\")\n            content = urllib.request.urlopen(url).read()\n            with open(file, \"wb\") as f:\n                f.write(content)\n            break\n        except urllib.error.URLError as e:\n            ex = e\n    else:\n        raise RuntimeError(ex)\n\n\ndef extract_dep(url: str, filename: str, prefs: dict[str, str]) -> None:\n    import tarfile\n    import zipfile\n\n    depends_dir = prefs[\"depends_dir\"]\n    sources_dir = prefs[\"src_dir\"]\n\n    file = os.path.join(depends_dir, filename)\n    if not os.path.exists(file):\n        # First try our mirror\n        mirror_url = (\n            f\"https://raw.githubusercontent.com/\"\n            f\"python-pillow/pillow-depends/main/{filename}\"\n        )\n        try:\n            download_dep(mirror_url, file)\n        except RuntimeError as exc:\n            # Otherwise try upstream\n            print(exc)\n            download_dep(url, file)\n\n    print(\"Extracting \" + filename)\n    sources_dir_abs = os.path.abspath(sources_dir)\n    if filename.endswith(\".zip\"):\n        with zipfile.ZipFile(file) as zf:\n            for member in zf.namelist():\n                member_abspath = os.path.abspath(os.path.join(sources_dir, member))\n                member_prefix = os.path.commonpath([sources_dir_abs, member_abspath])\n                if sources_dir_abs != member_prefix:\n                    msg = \"Attempted Path Traversal in Zip File\"\n                    raise RuntimeError(msg)\n            zf.extractall(sources_dir)\n    elif filename.endswith((\".tar.gz\", \".tgz\")):\n        with tarfile.open(file, \"r:gz\") as tgz:\n            for member in tgz.getnames():\n                member_abspath = os.path.abspath(os.path.join(sources_dir, member))\n                member_prefix = os.path.commonpath([sources_dir_abs, member_abspath])\n                if sources_dir_abs != member_prefix:\n                    msg = \"Attempted Path Traversal in Tar File\"\n                    raise RuntimeError(msg)\n            tgz.extractall(sources_dir)\n    else:\n        msg = \"Unknown archive type: \" + filename\n        raise RuntimeError(msg)\n\n\ndef write_script(\n    name: str, lines: list[str], prefs: dict[str, str], verbose: bool\n) -> None:\n    name = os.path.join(prefs[\"build_dir\"], name)\n    lines = [line.format(**prefs) for line in lines]\n    print(\"Writing \" + name)\n    with open(name, \"w\", newline=\"\") as f:\n        f.write(os.linesep.join(lines))\n    if verbose:\n        for line in lines:\n            print(\"    \" + line)\n\n\ndef get_footer(dep: dict) -> list[str]:\n    lines = []\n    for out in dep.get(\"headers\", []):\n        lines.append(cmd_copy(out, \"{inc_dir}\"))\n    for out in dep.get(\"libs\", []):\n        lines.append(cmd_copy(out, \"{lib_dir}\"))\n    for out in dep.get(\"bins\", []):\n        lines.append(cmd_copy(out, \"{bin_dir}\"))\n    return lines\n\n\ndef build_env(prefs: dict[str, str], verbose: bool) -> None:\n    lines = [\n        \"if defined DISTUTILS_USE_SDK goto end\",\n        cmd_set(\"INCLUDE\", \"{inc_dir}\"),\n        cmd_set(\"INCLIB\", \"{lib_dir}\"),\n        cmd_set(\"LIB\", \"{lib_dir}\"),\n        cmd_append(\"PATH\", \"{bin_dir}\"),\n        \"call {vcvarsall} {vcvars_arch}\",\n        cmd_set(\"DISTUTILS_USE_SDK\", \"1\"),  # use same compiler to build Pillow\n        cmd_set(\"py_vcruntime_redist\", \"true\"),  # always use /MD, never /MT\n        \":end\",\n        \"@echo on\",\n    ]\n    write_script(\"build_env.cmd\", lines, prefs, verbose)\n\n\ndef build_dep(name: str, prefs: dict[str, str], verbose: bool) -> str:\n    dep = DEPS[name]\n    directory = dep[\"dir\"]\n    file = f\"build_dep_{name}.cmd\"\n    license_dir = prefs[\"license_dir\"]\n    sources_dir = prefs[\"src_dir\"]\n\n    extract_dep(dep[\"url\"], dep[\"filename\"], prefs)\n\n    licenses = dep[\"license\"]\n    if isinstance(licenses, str):\n        licenses = [licenses]\n    license_text = \"\"\n    for license_file in licenses:\n        with open(os.path.join(sources_dir, directory, license_file)) as f:\n            license_text += f.read()\n    if \"license_pattern\" in dep:\n        match = re.search(dep[\"license_pattern\"], license_text, re.DOTALL)\n        license_text = \"\\n\".join(match.groups())\n    assert len(license_text) > 50\n    with open(os.path.join(license_dir, f\"{directory}.txt\"), \"w\") as f:\n        print(f\"Writing license {directory}.txt\")\n        f.write(license_text)\n\n    for patch_file, patch_list in dep.get(\"patch\", {}).items():\n        patch_file = os.path.join(sources_dir, directory, patch_file.format(**prefs))\n        with open(patch_file) as f:\n            text = f.read()\n        for patch_from, patch_to in patch_list.items():\n            patch_from = patch_from.format(**prefs)\n            patch_to = patch_to.format(**prefs)\n            assert patch_from in text\n            text = text.replace(patch_from, patch_to)\n        with open(patch_file, \"w\") as f:\n            print(f\"Patching {patch_file}\")\n            f.write(text)\n\n    banner = f\"Building {name} ({directory})\"\n    lines = [\n        r'call \"{build_dir}\\build_env.cmd\"',\n        \"@echo \" + (\"=\" * 70),\n        f\"@echo ==== {banner:<60} ====\",\n        \"@echo \" + (\"=\" * 70),\n        cmd_cd(os.path.join(sources_dir, directory)),\n        *dep.get(\"build\", []),\n        *get_footer(dep),\n    ]\n\n    write_script(file, lines, prefs, verbose)\n    return file\n\n\ndef build_dep_all(disabled: list[str], prefs: dict[str, str], verbose: bool) -> None:\n    lines = [r'call \"{build_dir}\\build_env.cmd\"']\n    gha_groups = \"GITHUB_ACTIONS\" in os.environ\n    for dep_name in DEPS:\n        print()\n        if dep_name in disabled:\n            print(f\"Skipping disabled dependency {dep_name}\")\n            continue\n        script = build_dep(dep_name, prefs, verbose)\n        if gha_groups:\n            lines.append(f\"@echo ::group::Running {script}\")\n        lines.append(rf'cmd.exe /c \"{{build_dir}}\\{script}\"')\n        lines.append(\"if errorlevel 1 echo Build failed! && exit /B 1\")\n        if gha_groups:\n            lines.append(\"@echo ::endgroup::\")\n    print()\n    lines.append(\"@echo All Pillow dependencies built successfully!\")\n    write_script(\"build_dep_all.cmd\", lines, prefs, verbose)\n\n\ndef main() -> None:\n    winbuild_dir = os.path.dirname(os.path.realpath(__file__))\n\n    parser = argparse.ArgumentParser(\n        prog=\"winbuild\\\\build_prepare.py\",\n        description=\"Download and generate build scripts for Pillow dependencies.\",\n        epilog=\"\"\"Arguments can also be supplied using the environment variables\n                  PILLOW_BUILD, PILLOW_DEPS, ARCHITECTURE. See winbuild\\\\build.rst\n                  for more information.\"\"\",\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\", action=\"store_true\", help=\"print generated scripts\"\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--dir\",\n        \"--build-dir\",\n        dest=\"build_dir\",\n        metavar=\"PILLOW_BUILD\",\n        default=os.environ.get(\"PILLOW_BUILD\", os.path.join(winbuild_dir, \"build\")),\n        help=\"build directory (default: 'winbuild\\\\build')\",\n    )\n    parser.add_argument(\n        \"--depends\",\n        dest=\"depends_dir\",\n        metavar=\"PILLOW_DEPS\",\n        default=os.environ.get(\"PILLOW_DEPS\", os.path.join(winbuild_dir, \"depends\")),\n        help=\"directory used to store cached dependencies \"\n        \"(default: 'winbuild\\\\depends')\",\n    )\n    parser.add_argument(\n        \"--architecture\",\n        choices=ARCHITECTURES,\n        default=os.environ.get(\n            \"ARCHITECTURE\",\n            (\n                \"ARM64\"\n                if platform.machine() == \"ARM64\"\n                else (\"x86\" if struct.calcsize(\"P\") == 4 else \"AMD64\")\n            ),\n        ),\n        help=\"build architecture (default: same as host Python)\",\n    )\n    parser.add_argument(\n        \"--nmake\",\n        dest=\"cmake_generator\",\n        action=\"store_const\",\n        const=\"NMake Makefiles\",\n        default=\"Ninja\",\n        help=\"build dependencies using NMake instead of Ninja\",\n    )\n    parser.add_argument(\n        \"--no-imagequant\",\n        action=\"store_true\",\n        help=\"skip GPL-licensed optional dependency libimagequant\",\n    )\n    parser.add_argument(\n        \"--no-fribidi\",\n        \"--no-raqm\",\n        action=\"store_true\",\n        help=\"skip LGPL-licensed optional dependency FriBiDi\",\n    )\n    args = parser.parse_args()\n\n    arch_prefs = ARCHITECTURES[args.architecture]\n    print(\"Target architecture:\", args.architecture)\n\n    msvs = find_msvs(args.architecture)\n    if msvs is None:\n        msg = \"Visual Studio not found. Please install Visual Studio 2017 or newer.\"\n        raise RuntimeError(msg)\n    print(\"Found Visual Studio at:\", msvs[\"vs_dir\"])\n\n    # dependency cache directory\n    args.depends_dir = os.path.abspath(args.depends_dir)\n    os.makedirs(args.depends_dir, exist_ok=True)\n    print(\"Caching dependencies in:\", args.depends_dir)\n\n    args.build_dir = os.path.abspath(args.build_dir)\n    print(\"Using output directory:\", args.build_dir)\n\n    # build directory for *.h files\n    inc_dir = os.path.join(args.build_dir, \"inc\")\n    # build directory for *.lib files\n    lib_dir = os.path.join(args.build_dir, \"lib\")\n    # build directory for *.bin files\n    bin_dir = os.path.join(args.build_dir, \"bin\")\n    # directory for storing project files\n    sources_dir = os.path.join(args.build_dir, \"src\")\n    # copy dependency licenses to this directory\n    license_dir = os.path.join(args.build_dir, \"license\")\n\n    shutil.rmtree(args.build_dir, ignore_errors=True)\n    os.makedirs(args.build_dir, exist_ok=False)\n    for path in [inc_dir, lib_dir, bin_dir, sources_dir, license_dir]:\n        os.makedirs(path, exist_ok=True)\n\n    disabled = []\n    if args.no_imagequant:\n        disabled += [\"libimagequant\"]\n    if args.no_fribidi:\n        disabled += [\"fribidi\"]\n\n    prefs = {\n        \"architecture\": args.architecture,\n        **arch_prefs,\n        # Pillow paths\n        \"winbuild_dir\": winbuild_dir,\n        # Build paths\n        \"bin_dir\": bin_dir,\n        \"build_dir\": args.build_dir,\n        \"depends_dir\": args.depends_dir,\n        \"inc_dir\": inc_dir,\n        \"lib_dir\": lib_dir,\n        \"license_dir\": license_dir,\n        \"src_dir\": sources_dir,\n        # Compilers / Tools\n        **msvs,\n        \"cmake\": \"cmake.exe\",  # TODO find CMAKE automatically\n        \"cmake_generator\": args.cmake_generator,\n        # TODO find NASM automatically\n    }\n\n    for k, v in DEPS.items():\n        prefs[f\"dir_{k}\"] = os.path.join(sources_dir, v[\"dir\"])\n\n    print()\n\n    write_script(\".gitignore\", [\"*\"], prefs, args.verbose)\n    build_env(prefs, args.verbose)\n    build_dep_all(disabled, prefs, args.verbose)\n\n\nif __name__ == \"__main__\":\n    main()\n"}