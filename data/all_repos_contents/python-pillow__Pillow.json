{"setup.py": "# > pyroma .\n# ------------------------------\n# Checking .\n# Found Pillow\n# ------------------------------\n# Final rating: 10/10\n# Your cheese is so fresh most people think it's a cream: Mascarpone\n# ------------------------------\nfrom __future__ import annotations\n\nimport os\nimport re\nimport shutil\nimport struct\nimport subprocess\nimport sys\nimport warnings\n\nfrom setuptools import Extension, setup\nfrom setuptools.command.build_ext import build_ext\n\n\ndef get_version():\n    version_file = \"src/PIL/_version.py\"\n    with open(version_file, encoding=\"utf-8\") as f:\n        return f.read().split('\"')[1]\n\n\nconfiguration = {}\n\n\nPILLOW_VERSION = get_version()\nFREETYPE_ROOT = None\nHARFBUZZ_ROOT = None\nFRIBIDI_ROOT = None\nIMAGEQUANT_ROOT = None\nJPEG2K_ROOT = None\nJPEG_ROOT = None\nLCMS_ROOT = None\nRAQM_ROOT = None\nTIFF_ROOT = None\nWEBP_ROOT = None\nZLIB_ROOT = None\nFUZZING_BUILD = \"LIB_FUZZING_ENGINE\" in os.environ\n\nif sys.platform == \"win32\" and sys.version_info >= (3, 13):\n    import atexit\n\n    atexit.register(\n        lambda: warnings.warn(\n            f\"Pillow {PILLOW_VERSION} does not support Python \"\n            f\"{sys.version_info.major}.{sys.version_info.minor} and does not provide \"\n            \"prebuilt Windows binaries. We do not recommend building from source on \"\n            \"Windows.\",\n            RuntimeWarning,\n        )\n    )\n\n\n_IMAGING = (\"decode\", \"encode\", \"map\", \"display\", \"outline\", \"path\")\n\n_LIB_IMAGING = (\n    \"Access\",\n    \"AlphaComposite\",\n    \"Resample\",\n    \"Reduce\",\n    \"Bands\",\n    \"BcnDecode\",\n    \"BitDecode\",\n    \"Blend\",\n    \"Chops\",\n    \"ColorLUT\",\n    \"Convert\",\n    \"ConvertYCbCr\",\n    \"Copy\",\n    \"Crop\",\n    \"Dib\",\n    \"Draw\",\n    \"Effects\",\n    \"EpsEncode\",\n    \"File\",\n    \"Fill\",\n    \"Filter\",\n    \"FliDecode\",\n    \"Geometry\",\n    \"GetBBox\",\n    \"GifDecode\",\n    \"GifEncode\",\n    \"HexDecode\",\n    \"Histo\",\n    \"JpegDecode\",\n    \"JpegEncode\",\n    \"Matrix\",\n    \"ModeFilter\",\n    \"Negative\",\n    \"Offset\",\n    \"Pack\",\n    \"PackDecode\",\n    \"Palette\",\n    \"Paste\",\n    \"Quant\",\n    \"QuantOctree\",\n    \"QuantHash\",\n    \"QuantHeap\",\n    \"PcdDecode\",\n    \"PcxDecode\",\n    \"PcxEncode\",\n    \"Point\",\n    \"RankFilter\",\n    \"RawDecode\",\n    \"RawEncode\",\n    \"Storage\",\n    \"SgiRleDecode\",\n    \"SunRleDecode\",\n    \"TgaRleDecode\",\n    \"TgaRleEncode\",\n    \"Unpack\",\n    \"UnpackYCC\",\n    \"UnsharpMask\",\n    \"XbmDecode\",\n    \"XbmEncode\",\n    \"ZipDecode\",\n    \"ZipEncode\",\n    \"TiffDecode\",\n    \"Jpeg2KDecode\",\n    \"Jpeg2KEncode\",\n    \"BoxBlur\",\n    \"QuantPngQuant\",\n    \"codec_fd\",\n)\n\nDEBUG = False\n\n\nclass DependencyException(Exception):\n    pass\n\n\nclass RequiredDependencyException(Exception):\n    pass\n\n\nPLATFORM_MINGW = os.name == \"nt\" and \"GCC\" in sys.version\n\n\ndef _dbg(s, tp=None):\n    if DEBUG:\n        if tp:\n            print(s % tp)\n            return\n        print(s)\n\n\ndef _find_library_dirs_ldconfig():\n    # Based on ctypes.util from Python 2\n\n    ldconfig = \"ldconfig\" if shutil.which(\"ldconfig\") else \"/sbin/ldconfig\"\n    if sys.platform.startswith(\"linux\") or sys.platform.startswith(\"gnu\"):\n        if struct.calcsize(\"l\") == 4:\n            machine = os.uname()[4] + \"-32\"\n        else:\n            machine = os.uname()[4] + \"-64\"\n        mach_map = {\n            \"x86_64-64\": \"libc6,x86-64\",\n            \"ppc64-64\": \"libc6,64bit\",\n            \"sparc64-64\": \"libc6,64bit\",\n            \"s390x-64\": \"libc6,64bit\",\n            \"ia64-64\": \"libc6,IA-64\",\n        }\n        abi_type = mach_map.get(machine, \"libc6\")\n\n        # Assuming GLIBC's ldconfig (with option -p)\n        # Alpine Linux uses musl that can't print cache\n        args = [ldconfig, \"-p\"]\n        expr = rf\".*\\({abi_type}.*\\) => (.*)\"\n        env = dict(os.environ)\n        env[\"LC_ALL\"] = \"C\"\n        env[\"LANG\"] = \"C\"\n\n    elif sys.platform.startswith(\"freebsd\"):\n        args = [ldconfig, \"-r\"]\n        expr = r\".* => (.*)\"\n        env = {}\n\n    try:\n        p = subprocess.Popen(\n            args, stderr=subprocess.DEVNULL, stdout=subprocess.PIPE, env=env\n        )\n    except OSError:  # E.g. command not found\n        return []\n    [data, _] = p.communicate()\n    if isinstance(data, bytes):\n        data = data.decode(\"latin1\")\n\n    dirs = []\n    for dll in re.findall(expr, data):\n        dir = os.path.dirname(dll)\n        if dir not in dirs:\n            dirs.append(dir)\n    return dirs\n\n\ndef _add_directory(path, subdir, where=None):\n    if subdir is None:\n        return\n    subdir = os.path.realpath(subdir)\n    if os.path.isdir(subdir) and subdir not in path:\n        if where is None:\n            _dbg(\"Appending path %s\", subdir)\n            path.append(subdir)\n        else:\n            _dbg(\"Inserting path %s\", subdir)\n            path.insert(where, subdir)\n    elif subdir in path and where is not None:\n        path.remove(subdir)\n        path.insert(where, subdir)\n\n\ndef _find_include_file(self, include):\n    for directory in self.compiler.include_dirs:\n        _dbg(\"Checking for include file %s in %s\", (include, directory))\n        if os.path.isfile(os.path.join(directory, include)):\n            _dbg(\"Found %s\", include)\n            return 1\n    return 0\n\n\ndef _find_library_file(self, library):\n    ret = self.compiler.find_library_file(self.compiler.library_dirs, library)\n    if ret:\n        _dbg(\"Found library %s at %s\", (library, ret))\n    else:\n        _dbg(\"Couldn't find library %s in %s\", (library, self.compiler.library_dirs))\n    return ret\n\n\ndef _find_include_dir(self, dirname, include):\n    for directory in self.compiler.include_dirs:\n        _dbg(\"Checking for include file %s in %s\", (include, directory))\n        if os.path.isfile(os.path.join(directory, include)):\n            _dbg(\"Found %s in %s\", (include, directory))\n            return True\n        subdir = os.path.join(directory, dirname)\n        _dbg(\"Checking for include file %s in %s\", (include, subdir))\n        if os.path.isfile(os.path.join(subdir, include)):\n            _dbg(\"Found %s in %s\", (include, subdir))\n            return subdir\n\n\ndef _cmd_exists(cmd: str) -> bool:\n    if \"PATH\" not in os.environ:\n        return False\n    return any(\n        os.access(os.path.join(path, cmd), os.X_OK)\n        for path in os.environ[\"PATH\"].split(os.pathsep)\n    )\n\n\ndef _pkg_config(name):\n    command = os.environ.get(\"PKG_CONFIG\", \"pkg-config\")\n    for keep_system in (True, False):\n        try:\n            command_libs = [command, \"--libs-only-L\", name]\n            command_cflags = [command, \"--cflags-only-I\", name]\n            stderr = None\n            if keep_system:\n                command_libs.append(\"--keep-system-libs\")\n                command_cflags.append(\"--keep-system-cflags\")\n                stderr = subprocess.DEVNULL\n            if not DEBUG:\n                command_libs.append(\"--silence-errors\")\n                command_cflags.append(\"--silence-errors\")\n            libs = re.split(\n                r\"(^|\\s+)-L\",\n                subprocess.check_output(command_libs, stderr=stderr)\n                .decode(\"utf8\")\n                .strip(),\n            )[::2][1:]\n            cflags = re.split(\n                r\"(^|\\s+)-I\",\n                subprocess.check_output(command_cflags).decode(\"utf8\").strip(),\n            )[::2][1:]\n            return libs, cflags\n        except Exception:\n            pass\n\n\nclass pil_build_ext(build_ext):\n    class feature:\n        features = [\n            \"zlib\",\n            \"jpeg\",\n            \"tiff\",\n            \"freetype\",\n            \"raqm\",\n            \"lcms\",\n            \"webp\",\n            \"webpmux\",\n            \"jpeg2000\",\n            \"imagequant\",\n            \"xcb\",\n        ]\n\n        required = {\"jpeg\", \"zlib\"}\n        vendor = set()\n\n        def __init__(self):\n            for f in self.features:\n                setattr(self, f, None)\n\n        def require(self, feat):\n            return feat in self.required\n\n        def want(self, feat):\n            return getattr(self, feat) is None\n\n        def want_vendor(self, feat):\n            return feat in self.vendor\n\n        def __iter__(self):\n            yield from self.features\n\n    feature = feature()\n\n    user_options = (\n        build_ext.user_options\n        + [(f\"disable-{x}\", None, f\"Disable support for {x}\") for x in feature]\n        + [(f\"enable-{x}\", None, f\"Enable support for {x}\") for x in feature]\n        + [\n            (f\"vendor-{x}\", None, f\"Use vendored version of {x}\")\n            for x in (\"raqm\", \"fribidi\")\n        ]\n        + [\n            (\"disable-platform-guessing\", None, \"Disable platform guessing on Linux\"),\n            (\"debug\", None, \"Debug logging\"),\n        ]\n        + [(\"add-imaging-libs=\", None, \"Add libs to _imaging build\")]\n    )\n\n    @staticmethod\n    def check_configuration(option, value):\n        return True if value in configuration.get(option, []) else None\n\n    def initialize_options(self):\n        self.disable_platform_guessing = self.check_configuration(\n            \"platform-guessing\", \"disable\"\n        )\n        self.add_imaging_libs = \"\"\n        build_ext.initialize_options(self)\n        for x in self.feature:\n            setattr(self, f\"disable_{x}\", self.check_configuration(x, \"disable\"))\n            setattr(self, f\"enable_{x}\", self.check_configuration(x, \"enable\"))\n        for x in (\"raqm\", \"fribidi\"):\n            setattr(self, f\"vendor_{x}\", self.check_configuration(x, \"vendor\"))\n        if self.check_configuration(\"debug\", \"true\"):\n            self.debug = True\n        self.parallel = configuration.get(\"parallel\", [None])[-1]\n\n    def finalize_options(self):\n        build_ext.finalize_options(self)\n        if self.debug:\n            global DEBUG\n            DEBUG = True\n        if not self.parallel:\n            # If --parallel (or -j) wasn't specified, we want to reproduce the same\n            # behavior as before, that is, auto-detect the number of jobs.\n            try:\n                self.parallel = int(\n                    os.environ.get(\"MAX_CONCURRENCY\", min(4, os.cpu_count()))\n                )\n            except TypeError:\n                self.parallel = None\n        for x in self.feature:\n            if getattr(self, f\"disable_{x}\"):\n                setattr(self.feature, x, False)\n                self.feature.required.discard(x)\n                _dbg(\"Disabling %s\", x)\n                if getattr(self, f\"enable_{x}\"):\n                    msg = f\"Conflicting options: --enable-{x} and --disable-{x}\"\n                    raise ValueError(msg)\n                if x == \"freetype\":\n                    _dbg(\"--disable-freetype implies --disable-raqm\")\n                    if getattr(self, \"enable_raqm\"):\n                        msg = (\n                            \"Conflicting options: --enable-raqm and --disable-freetype\"\n                        )\n                        raise ValueError(msg)\n                    setattr(self, \"disable_raqm\", True)\n            if getattr(self, f\"enable_{x}\"):\n                _dbg(\"Requiring %s\", x)\n                self.feature.required.add(x)\n                if x == \"raqm\":\n                    _dbg(\"--enable-raqm implies --enable-freetype\")\n                    self.feature.required.add(\"freetype\")\n        for x in (\"raqm\", \"fribidi\"):\n            if getattr(self, f\"vendor_{x}\"):\n                if getattr(self, \"disable_raqm\"):\n                    msg = f\"Conflicting options: --vendor-{x} and --disable-raqm\"\n                    raise ValueError(msg)\n                if x == \"fribidi\" and not getattr(self, \"vendor_raqm\"):\n                    msg = f\"Conflicting options: --vendor-{x} and not --vendor-raqm\"\n                    raise ValueError(msg)\n                _dbg(\"Using vendored version of %s\", x)\n                self.feature.vendor.add(x)\n\n    def _update_extension(self, name, libraries, define_macros=None, sources=None):\n        for extension in self.extensions:\n            if extension.name == name:\n                extension.libraries += libraries\n                if define_macros is not None:\n                    extension.define_macros += define_macros\n                if sources is not None:\n                    extension.sources += sources\n                if FUZZING_BUILD:\n                    extension.language = \"c++\"\n                    extension.extra_link_args = [\"--stdlib=libc++\"]\n                break\n\n    def _remove_extension(self, name):\n        for extension in self.extensions:\n            if extension.name == name:\n                self.extensions.remove(extension)\n                break\n\n    def get_macos_sdk_path(self):\n        try:\n            sdk_path = (\n                subprocess.check_output([\"xcrun\", \"--show-sdk-path\"])\n                .strip()\n                .decode(\"latin1\")\n            )\n        except Exception:\n            sdk_path = None\n        if (\n            not sdk_path\n            or sdk_path == \"/Applications/Xcode.app/Contents/Developer\"\n            \"/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk\"\n        ):\n            commandlinetools_sdk_path = (\n                \"/Library/Developer/CommandLineTools/SDKs/MacOSX.sdk\"\n            )\n            if os.path.exists(commandlinetools_sdk_path):\n                sdk_path = commandlinetools_sdk_path\n        return sdk_path\n\n    def build_extensions(self):\n        library_dirs = []\n        include_dirs = []\n\n        pkg_config = None\n        if _cmd_exists(os.environ.get(\"PKG_CONFIG\", \"pkg-config\")):\n            pkg_config = _pkg_config\n\n        #\n        # add configured kits\n        for root_name, lib_name in {\n            \"JPEG_ROOT\": \"libjpeg\",\n            \"JPEG2K_ROOT\": \"libopenjp2\",\n            \"TIFF_ROOT\": (\"libtiff-5\", \"libtiff-4\"),\n            \"ZLIB_ROOT\": \"zlib\",\n            \"FREETYPE_ROOT\": \"freetype2\",\n            \"HARFBUZZ_ROOT\": \"harfbuzz\",\n            \"FRIBIDI_ROOT\": \"fribidi\",\n            \"RAQM_ROOT\": \"raqm\",\n            \"WEBP_ROOT\": \"libwebp\",\n            \"LCMS_ROOT\": \"lcms2\",\n            \"IMAGEQUANT_ROOT\": \"libimagequant\",\n        }.items():\n            root = globals()[root_name]\n\n            if root is None and root_name in os.environ:\n                prefix = os.environ[root_name]\n                root = (os.path.join(prefix, \"lib\"), os.path.join(prefix, \"include\"))\n\n            if root is None and pkg_config:\n                if isinstance(lib_name, tuple):\n                    for lib_name2 in lib_name:\n                        _dbg(f\"Looking for `{lib_name2}` using pkg-config.\")\n                        root = pkg_config(lib_name2)\n                        if root:\n                            break\n                else:\n                    _dbg(f\"Looking for `{lib_name}` using pkg-config.\")\n                    root = pkg_config(lib_name)\n\n            if isinstance(root, tuple):\n                lib_root, include_root = root\n            else:\n                lib_root = include_root = root\n\n            if lib_root is not None:\n                if not isinstance(lib_root, (tuple, list)):\n                    lib_root = (lib_root,)\n                for lib_dir in lib_root:\n                    _add_directory(library_dirs, lib_dir)\n            if include_root is not None:\n                if not isinstance(include_root, (tuple, list)):\n                    include_root = (include_root,)\n                for include_dir in include_root:\n                    _add_directory(include_dirs, include_dir)\n\n        # respect CFLAGS/CPPFLAGS/LDFLAGS\n        for k in (\"CFLAGS\", \"CPPFLAGS\", \"LDFLAGS\"):\n            if k in os.environ:\n                for match in re.finditer(r\"-I([^\\s]+)\", os.environ[k]):\n                    _add_directory(include_dirs, match.group(1))\n                for match in re.finditer(r\"-L([^\\s]+)\", os.environ[k]):\n                    _add_directory(library_dirs, match.group(1))\n\n        # include, rpath, if set as environment variables:\n        for k in (\"C_INCLUDE_PATH\", \"CPATH\", \"INCLUDE\"):\n            if k in os.environ:\n                for d in os.environ[k].split(os.path.pathsep):\n                    _add_directory(include_dirs, d)\n\n        for k in (\"LD_RUN_PATH\", \"LIBRARY_PATH\", \"LIB\"):\n            if k in os.environ:\n                for d in os.environ[k].split(os.path.pathsep):\n                    _add_directory(library_dirs, d)\n\n        _add_directory(library_dirs, os.path.join(sys.prefix, \"lib\"))\n        _add_directory(include_dirs, os.path.join(sys.prefix, \"include\"))\n\n        #\n        # add platform directories\n\n        if self.disable_platform_guessing:\n            pass\n\n        elif sys.platform == \"cygwin\":\n            # pythonX.Y.dll.a is in the /usr/lib/pythonX.Y/config directory\n            self.compiler.shared_lib_extension = \".dll.a\"\n            _add_directory(\n                library_dirs,\n                os.path.join(\n                    \"/usr/lib\", \"python{}.{}\".format(*sys.version_info), \"config\"\n                ),\n            )\n\n        elif sys.platform == \"darwin\":\n            # attempt to make sure we pick freetype2 over other versions\n            _add_directory(include_dirs, \"/sw/include/freetype2\")\n            _add_directory(include_dirs, \"/sw/lib/freetype2/include\")\n            # fink installation directories\n            _add_directory(library_dirs, \"/sw/lib\")\n            _add_directory(include_dirs, \"/sw/include\")\n            # darwin ports installation directories\n            _add_directory(library_dirs, \"/opt/local/lib\")\n            _add_directory(include_dirs, \"/opt/local/include\")\n\n            # if Homebrew is installed, use its lib and include directories\n            try:\n                prefix = (\n                    subprocess.check_output([\"brew\", \"--prefix\"])\n                    .strip()\n                    .decode(\"latin1\")\n                )\n            except Exception:\n                # Homebrew not installed\n                prefix = None\n\n            ft_prefix = None\n\n            if prefix:\n                # add Homebrew's include and lib directories\n                _add_directory(library_dirs, os.path.join(prefix, \"lib\"))\n                _add_directory(include_dirs, os.path.join(prefix, \"include\"))\n                _add_directory(\n                    include_dirs, os.path.join(prefix, \"opt\", \"zlib\", \"include\")\n                )\n                ft_prefix = os.path.join(prefix, \"opt\", \"freetype\")\n\n            if ft_prefix and os.path.isdir(ft_prefix):\n                # freetype might not be linked into Homebrew's prefix\n                _add_directory(library_dirs, os.path.join(ft_prefix, \"lib\"))\n                _add_directory(include_dirs, os.path.join(ft_prefix, \"include\"))\n            else:\n                # fall back to freetype from XQuartz if\n                # Homebrew's freetype is missing\n                _add_directory(library_dirs, \"/usr/X11/lib\")\n                _add_directory(include_dirs, \"/usr/X11/include\")\n\n            sdk_path = self.get_macos_sdk_path()\n            if sdk_path:\n                _add_directory(library_dirs, os.path.join(sdk_path, \"usr\", \"lib\"))\n                _add_directory(include_dirs, os.path.join(sdk_path, \"usr\", \"include\"))\n\n                for extension in self.extensions:\n                    extension.extra_compile_args = [\"-Wno-nullability-completeness\"]\n        elif (\n            sys.platform.startswith(\"linux\")\n            or sys.platform.startswith(\"gnu\")\n            or sys.platform.startswith(\"freebsd\")\n        ):\n            for dirname in _find_library_dirs_ldconfig():\n                _add_directory(library_dirs, dirname)\n            if sys.platform.startswith(\"linux\") and os.environ.get(\"ANDROID_ROOT\"):\n                # termux support for android.\n                # system libraries (zlib) are installed in /system/lib\n                # headers are at $PREFIX/include\n                # user libs are at $PREFIX/lib\n                _add_directory(\n                    library_dirs,\n                    os.path.join(\n                        os.environ[\"ANDROID_ROOT\"],\n                        \"lib\" if struct.calcsize(\"l\") == 4 else \"lib64\",\n                    ),\n                )\n\n        elif sys.platform.startswith(\"netbsd\"):\n            _add_directory(library_dirs, \"/usr/pkg/lib\")\n            _add_directory(include_dirs, \"/usr/pkg/include\")\n\n        elif sys.platform.startswith(\"sunos5\"):\n            _add_directory(library_dirs, \"/opt/local/lib\")\n            _add_directory(include_dirs, \"/opt/local/include\")\n\n        # FIXME: check /opt/stuff directories here?\n\n        # standard locations\n        if not self.disable_platform_guessing:\n            _add_directory(library_dirs, \"/usr/local/lib\")\n            _add_directory(include_dirs, \"/usr/local/include\")\n\n            _add_directory(library_dirs, \"/usr/lib\")\n            _add_directory(include_dirs, \"/usr/include\")\n            # alpine, at least\n            _add_directory(library_dirs, \"/lib\")\n\n        if sys.platform == \"win32\":\n            # on Windows, look for the OpenJPEG libraries in the location that\n            # the official installer puts them\n            program_files = os.environ.get(\"ProgramFiles\", \"\")\n            best_version = (0, 0)\n            best_path = None\n            for name in os.listdir(program_files):\n                if name.startswith(\"OpenJPEG \"):\n                    version = tuple(int(x) for x in name[9:].strip().split(\".\"))\n                    if version > best_version:\n                        best_version = version\n                        best_path = os.path.join(program_files, name)\n\n            if best_path:\n                _dbg(\"Adding %s to search list\", best_path)\n                _add_directory(library_dirs, os.path.join(best_path, \"lib\"))\n                _add_directory(include_dirs, os.path.join(best_path, \"include\"))\n\n        #\n        # insert new dirs *before* default libs, to avoid conflicts\n        # between Python PYD stub libs and real libraries\n\n        self.compiler.library_dirs = library_dirs + self.compiler.library_dirs\n        self.compiler.include_dirs = include_dirs + self.compiler.include_dirs\n\n        #\n        # look for available libraries\n\n        feature = self.feature\n\n        if feature.want(\"zlib\"):\n            _dbg(\"Looking for zlib\")\n            if _find_include_file(self, \"zlib.h\"):\n                if _find_library_file(self, \"z\"):\n                    feature.zlib = \"z\"\n                elif sys.platform == \"win32\" and _find_library_file(self, \"zlib\"):\n                    feature.zlib = \"zlib\"  # alternative name\n\n        if feature.want(\"jpeg\"):\n            _dbg(\"Looking for jpeg\")\n            if _find_include_file(self, \"jpeglib.h\"):\n                if _find_library_file(self, \"jpeg\"):\n                    feature.jpeg = \"jpeg\"\n                elif sys.platform == \"win32\" and _find_library_file(self, \"libjpeg\"):\n                    feature.jpeg = \"libjpeg\"  # alternative name\n\n        feature.openjpeg_version = None\n        if feature.want(\"jpeg2000\"):\n            _dbg(\"Looking for jpeg2000\")\n            best_version = None\n            best_path = None\n\n            # Find the best version\n            for directory in self.compiler.include_dirs:\n                _dbg(\"Checking for openjpeg-#.# in %s\", directory)\n                try:\n                    listdir = os.listdir(directory)\n                except Exception:\n                    # OSError, FileNotFoundError\n                    continue\n                for name in listdir:\n                    if name.startswith(\"openjpeg-\") and os.path.isfile(\n                        os.path.join(directory, name, \"openjpeg.h\")\n                    ):\n                        _dbg(\"Found openjpeg.h in %s/%s\", (directory, name))\n                        version = tuple(int(x) for x in name[9:].split(\".\"))\n                        if best_version is None or version > best_version:\n                            best_version = version\n                            best_path = os.path.join(directory, name)\n                            _dbg(\n                                \"Best openjpeg version %s so far in %s\",\n                                (best_version, best_path),\n                            )\n\n            if best_version and _find_library_file(self, \"openjp2\"):\n                # Add the directory to the include path so we can include\n                # <openjpeg.h> rather than having to cope with the versioned\n                # include path\n                _add_directory(self.compiler.include_dirs, best_path, 0)\n                feature.jpeg2000 = \"openjp2\"\n                feature.openjpeg_version = \".\".join(str(x) for x in best_version)\n\n        if feature.want(\"imagequant\"):\n            _dbg(\"Looking for imagequant\")\n            if _find_include_file(self, \"libimagequant.h\"):\n                if _find_library_file(self, \"imagequant\"):\n                    feature.imagequant = \"imagequant\"\n                elif _find_library_file(self, \"libimagequant\"):\n                    feature.imagequant = \"libimagequant\"\n\n        if feature.want(\"tiff\"):\n            _dbg(\"Looking for tiff\")\n            if _find_include_file(self, \"tiff.h\"):\n                if _find_library_file(self, \"tiff\"):\n                    feature.tiff = \"tiff\"\n                if sys.platform in [\"win32\", \"darwin\"] and _find_library_file(\n                    self, \"libtiff\"\n                ):\n                    feature.tiff = \"libtiff\"\n\n        if feature.want(\"freetype\"):\n            _dbg(\"Looking for freetype\")\n            if _find_library_file(self, \"freetype\"):\n                # look for freetype2 include files\n                freetype_version = 0\n                for subdir in self.compiler.include_dirs:\n                    _dbg(\"Checking for include file %s in %s\", (\"ft2build.h\", subdir))\n                    if os.path.isfile(os.path.join(subdir, \"ft2build.h\")):\n                        _dbg(\"Found %s in %s\", (\"ft2build.h\", subdir))\n                        freetype_version = 21\n                        subdir = os.path.join(subdir, \"freetype2\")\n                        break\n                    subdir = os.path.join(subdir, \"freetype2\")\n                    _dbg(\"Checking for include file %s in %s\", (\"ft2build.h\", subdir))\n                    if os.path.isfile(os.path.join(subdir, \"ft2build.h\")):\n                        _dbg(\"Found %s in %s\", (\"ft2build.h\", subdir))\n                        freetype_version = 21\n                        break\n                if freetype_version:\n                    feature.freetype = \"freetype\"\n                    if subdir:\n                        _add_directory(self.compiler.include_dirs, subdir, 0)\n\n        if feature.freetype and feature.want(\"raqm\"):\n            if not feature.want_vendor(\"raqm\"):  # want system Raqm\n                _dbg(\"Looking for Raqm\")\n                if _find_include_file(self, \"raqm.h\"):\n                    if _find_library_file(self, \"raqm\"):\n                        feature.raqm = \"raqm\"\n                    elif _find_library_file(self, \"libraqm\"):\n                        feature.raqm = \"libraqm\"\n            else:  # want to build Raqm from src/thirdparty\n                _dbg(\"Looking for HarfBuzz\")\n                feature.harfbuzz = None\n                hb_dir = _find_include_dir(self, \"harfbuzz\", \"hb.h\")\n                if hb_dir:\n                    if isinstance(hb_dir, str):\n                        _add_directory(self.compiler.include_dirs, hb_dir, 0)\n                    if _find_library_file(self, \"harfbuzz\"):\n                        feature.harfbuzz = \"harfbuzz\"\n                if feature.harfbuzz:\n                    if not feature.want_vendor(\"fribidi\"):  # want system FriBiDi\n                        _dbg(\"Looking for FriBiDi\")\n                        feature.fribidi = None\n                        fribidi_dir = _find_include_dir(self, \"fribidi\", \"fribidi.h\")\n                        if fribidi_dir:\n                            if isinstance(fribidi_dir, str):\n                                _add_directory(\n                                    self.compiler.include_dirs, fribidi_dir, 0\n                                )\n                            if _find_library_file(self, \"fribidi\"):\n                                feature.fribidi = \"fribidi\"\n                                feature.raqm = True\n                    else:  # want to build FriBiDi shim from src/thirdparty\n                        feature.raqm = True\n\n        if feature.want(\"lcms\"):\n            _dbg(\"Looking for lcms\")\n            if _find_include_file(self, \"lcms2.h\"):\n                if _find_library_file(self, \"lcms2\"):\n                    feature.lcms = \"lcms2\"\n                elif _find_library_file(self, \"lcms2_static\"):\n                    # alternate Windows name.\n                    feature.lcms = \"lcms2_static\"\n\n        if feature.want(\"webp\"):\n            _dbg(\"Looking for webp\")\n            if _find_include_file(self, \"webp/encode.h\") and _find_include_file(\n                self, \"webp/decode.h\"\n            ):\n                # In Google's precompiled zip it is call \"libwebp\":\n                if _find_library_file(self, \"webp\"):\n                    feature.webp = \"webp\"\n                elif _find_library_file(self, \"libwebp\"):\n                    feature.webp = \"libwebp\"\n\n        if feature.want(\"webpmux\"):\n            _dbg(\"Looking for webpmux\")\n            if _find_include_file(self, \"webp/mux.h\") and _find_include_file(\n                self, \"webp/demux.h\"\n            ):\n                if _find_library_file(self, \"webpmux\") and _find_library_file(\n                    self, \"webpdemux\"\n                ):\n                    feature.webpmux = \"webpmux\"\n                if _find_library_file(self, \"libwebpmux\") and _find_library_file(\n                    self, \"libwebpdemux\"\n                ):\n                    feature.webpmux = \"libwebpmux\"\n\n        if feature.want(\"xcb\"):\n            _dbg(\"Looking for xcb\")\n            if _find_include_file(self, \"xcb/xcb.h\"):\n                if _find_library_file(self, \"xcb\"):\n                    feature.xcb = \"xcb\"\n\n        for f in feature:\n            if not getattr(feature, f) and feature.require(f):\n                if f in (\"jpeg\", \"zlib\"):\n                    raise RequiredDependencyException(f)\n                raise DependencyException(f)\n\n        #\n        # core library\n\n        libs = self.add_imaging_libs.split()\n        defs = []\n        if feature.tiff:\n            libs.append(feature.tiff)\n            defs.append((\"HAVE_LIBTIFF\", None))\n            if sys.platform == \"win32\":\n                # This define needs to be defined if-and-only-if it was defined\n                # when compiling LibTIFF. LibTIFF doesn't expose it in `tiffconf.h`,\n                # so we have to guess; by default it is defined in all Windows builds.\n                # See #4237, #5243, #5359 for more information.\n                defs.append((\"USE_WIN32_FILEIO\", None))\n        if feature.jpeg:\n            libs.append(feature.jpeg)\n            defs.append((\"HAVE_LIBJPEG\", None))\n        if feature.jpeg2000:\n            libs.append(feature.jpeg2000)\n            defs.append((\"HAVE_OPENJPEG\", None))\n            if sys.platform == \"win32\" and not PLATFORM_MINGW:\n                defs.append((\"OPJ_STATIC\", None))\n        if feature.zlib:\n            libs.append(feature.zlib)\n            defs.append((\"HAVE_LIBZ\", None))\n        if feature.imagequant:\n            libs.append(feature.imagequant)\n            defs.append((\"HAVE_LIBIMAGEQUANT\", None))\n        if feature.xcb:\n            libs.append(feature.xcb)\n            defs.append((\"HAVE_XCB\", None))\n        if sys.platform == \"win32\":\n            libs.extend([\"kernel32\", \"user32\", \"gdi32\"])\n        if struct.unpack(\"h\", b\"\\0\\1\")[0] == 1:\n            defs.append((\"WORDS_BIGENDIAN\", None))\n\n        defs.append((\"PILLOW_VERSION\", f'\"{PILLOW_VERSION}\"'))\n\n        self._update_extension(\"PIL._imaging\", libs, defs)\n\n        #\n        # additional libraries\n\n        if feature.freetype:\n            srcs = []\n            libs = [\"freetype\"]\n            defs = []\n            if feature.raqm:\n                if not feature.want_vendor(\"raqm\"):  # using system Raqm\n                    defs.append((\"HAVE_RAQM\", None))\n                    defs.append((\"HAVE_RAQM_SYSTEM\", None))\n                    libs.append(feature.raqm)\n                else:  # building Raqm from src/thirdparty\n                    defs.append((\"HAVE_RAQM\", None))\n                    srcs.append(\"src/thirdparty/raqm/raqm.c\")\n                    libs.append(feature.harfbuzz)\n                    if not feature.want_vendor(\"fribidi\"):  # using system FriBiDi\n                        defs.append((\"HAVE_FRIBIDI_SYSTEM\", None))\n                        libs.append(feature.fribidi)\n                    else:  # building FriBiDi shim from src/thirdparty\n                        srcs.append(\"src/thirdparty/fribidi-shim/fribidi.c\")\n            self._update_extension(\"PIL._imagingft\", libs, defs, srcs)\n\n        else:\n            self._remove_extension(\"PIL._imagingft\")\n\n        if feature.lcms:\n            extra = []\n            if sys.platform == \"win32\":\n                extra.extend([\"user32\", \"gdi32\"])\n            self._update_extension(\"PIL._imagingcms\", [feature.lcms] + extra)\n        else:\n            self._remove_extension(\"PIL._imagingcms\")\n\n        if feature.webp:\n            libs = [feature.webp]\n            defs = []\n\n            if feature.webpmux:\n                defs.append((\"HAVE_WEBPMUX\", None))\n                libs.append(feature.webpmux)\n                libs.append(feature.webpmux.replace(\"pmux\", \"pdemux\"))\n\n            self._update_extension(\"PIL._webp\", libs, defs)\n        else:\n            self._remove_extension(\"PIL._webp\")\n\n        tk_libs = [\"psapi\"] if sys.platform in (\"win32\", \"cygwin\") else []\n        self._update_extension(\"PIL._imagingtk\", tk_libs)\n\n        build_ext.build_extensions(self)\n\n        #\n        # sanity checks\n\n        self.summary_report(feature)\n\n    def summary_report(self, feature):\n        print(\"-\" * 68)\n        print(\"PIL SETUP SUMMARY\")\n        print(\"-\" * 68)\n        print(f\"version      Pillow {PILLOW_VERSION}\")\n        v = sys.version.split(\"[\")\n        print(f\"platform     {sys.platform} {v[0].strip()}\")\n        for v in v[1:]:\n            print(f\"             [{v.strip()}\")\n        print(\"-\" * 68)\n\n        raqm_extra_info = \"\"\n        if feature.want_vendor(\"raqm\"):\n            raqm_extra_info += \"bundled\"\n            if feature.want_vendor(\"fribidi\"):\n                raqm_extra_info += \", FriBiDi shim\"\n\n        options = [\n            (feature.jpeg, \"JPEG\"),\n            (feature.jpeg2000, \"OPENJPEG (JPEG2000)\", feature.openjpeg_version),\n            (feature.zlib, \"ZLIB (PNG/ZIP)\"),\n            (feature.imagequant, \"LIBIMAGEQUANT\"),\n            (feature.tiff, \"LIBTIFF\"),\n            (feature.freetype, \"FREETYPE2\"),\n            (feature.raqm, \"RAQM (Text shaping)\", raqm_extra_info),\n            (feature.lcms, \"LITTLECMS2\"),\n            (feature.webp, \"WEBP\"),\n            (feature.webpmux, \"WEBPMUX\"),\n            (feature.xcb, \"XCB (X protocol)\"),\n        ]\n\n        all = 1\n        for option in options:\n            if option[0]:\n                extra_info = \"\"\n                if len(option) >= 3 and option[2]:\n                    extra_info = f\" ({option[2]})\"\n                print(f\"--- {option[1]} support available{extra_info}\")\n            else:\n                print(f\"*** {option[1]} support not available\")\n                all = 0\n\n        print(\"-\" * 68)\n\n        if not all:\n            print(\"To add a missing option, make sure you have the required\")\n            print(\"library and headers.\")\n            print(\n                \"See https://pillow.readthedocs.io/en/latest/installation.\"\n                \"html#building-from-source\"\n            )\n            print(\"\")\n\n        print(\"To check the build, run the selftest.py script.\")\n        print(\"\")\n\n\ndef debug_build():\n    return hasattr(sys, \"gettotalrefcount\") or FUZZING_BUILD\n\n\nfiles = [\"src/_imaging.c\"]\nfor src_file in _IMAGING:\n    files.append(\"src/\" + src_file + \".c\")\nfor src_file in _LIB_IMAGING:\n    files.append(os.path.join(\"src/libImaging\", src_file + \".c\"))\next_modules = [\n    Extension(\"PIL._imaging\", files),\n    Extension(\"PIL._imagingft\", [\"src/_imagingft.c\"]),\n    Extension(\"PIL._imagingcms\", [\"src/_imagingcms.c\"]),\n    Extension(\"PIL._webp\", [\"src/_webp.c\"]),\n    Extension(\"PIL._imagingtk\", [\"src/_imagingtk.c\", \"src/Tk/tkImaging.c\"]),\n    Extension(\"PIL._imagingmath\", [\"src/_imagingmath.c\"]),\n    Extension(\"PIL._imagingmorph\", [\"src/_imagingmorph.c\"]),\n]\n\n\n# parse configuration from _custom_build/backend.py\nwhile sys.argv[-1].startswith(\"--pillow-configuration=\"):\n    _, key, value = sys.argv.pop().split(\"=\", 2)\n    configuration.setdefault(key, []).append(value)\n\ntry:\n    setup(\n        cmdclass={\"build_ext\": pil_build_ext},\n        ext_modules=ext_modules,\n        zip_safe=not (debug_build() or PLATFORM_MINGW),\n    )\nexcept RequiredDependencyException as err:\n    msg = f\"\"\"\n\nThe headers or library files could not be found for {str(err)},\na required dependency when compiling Pillow from source.\n\nPlease see the install instructions at:\n   https://pillow.readthedocs.io/en/latest/installation/basic-installation.html\n\n\"\"\"\n    sys.stderr.write(msg)\n    raise RequiredDependencyException(msg)\nexcept DependencyException as err:\n    msg = f\"\"\"\n\nThe headers or library files could not be found for {str(err)},\nwhich was requested by the option flag --enable-{str(err)}\n\n\"\"\"\n    sys.stderr.write(msg)\n    raise DependencyException(msg)\n", "selftest.py": "#!/usr/bin/env python3\n# minimal sanity check\nfrom __future__ import annotations\n\nimport sys\n\nfrom PIL import Image, features\n\ntry:\n    Image.core.ping\nexcept ImportError as v:\n    print(\"***\", v)\n    sys.exit()\nexcept AttributeError:\n    pass\n\n\ndef testimage() -> None:\n    \"\"\"\n    PIL lets you create in-memory images with various pixel types:\n\n    >>> from PIL import Image, ImageDraw, ImageFilter, ImageMath\n    >>> im = Image.new(\"1\", (128, 128)) # monochrome\n    >>> def _info(im): return im.format, im.mode, im.size\n    >>> _info(im)\n    (None, '1', (128, 128))\n    >>> _info(Image.new(\"L\", (128, 128))) # grayscale (luminance)\n    (None, 'L', (128, 128))\n    >>> _info(Image.new(\"P\", (128, 128))) # palette\n    (None, 'P', (128, 128))\n    >>> _info(Image.new(\"RGB\", (128, 128))) # truecolor\n    (None, 'RGB', (128, 128))\n    >>> _info(Image.new(\"I\", (128, 128))) # 32-bit integer\n    (None, 'I', (128, 128))\n    >>> _info(Image.new(\"F\", (128, 128))) # 32-bit floating point\n    (None, 'F', (128, 128))\n\n    Or open existing files:\n\n    >>> with Image.open(\"Tests/images/hopper.gif\") as im:\n    ...     _info(im)\n    ('GIF', 'P', (128, 128))\n    >>> _info(Image.open(\"Tests/images/hopper.ppm\"))\n    ('PPM', 'RGB', (128, 128))\n    >>> try:\n    ...  _info(Image.open(\"Tests/images/hopper.jpg\"))\n    ... except OSError as v:\n    ...  print(v)\n    ('JPEG', 'RGB', (128, 128))\n\n    PIL doesn't actually load the image data until it's needed,\n    or you call the \"load\" method:\n\n    >>> im = Image.open(\"Tests/images/hopper.ppm\")\n    >>> print(im.im) # internal image attribute\n    None\n    >>> a = im.load()\n    >>> type(im.im) # doctest: +ELLIPSIS\n    <... '...ImagingCore'>\n\n    You can apply many different operations on images.  Most\n    operations return a new image:\n\n    >>> im = Image.open(\"Tests/images/hopper.ppm\")\n    >>> _info(im.convert(\"L\"))\n    (None, 'L', (128, 128))\n    >>> _info(im.copy())\n    (None, 'RGB', (128, 128))\n    >>> _info(im.crop((32, 32, 96, 96)))\n    (None, 'RGB', (64, 64))\n    >>> _info(im.filter(ImageFilter.BLUR))\n    (None, 'RGB', (128, 128))\n    >>> im.getbands()\n    ('R', 'G', 'B')\n    >>> im.getbbox()\n    (0, 0, 128, 128)\n    >>> len(im.getdata())\n    16384\n    >>> im.getextrema()\n    ((0, 255), (0, 255), (0, 255))\n    >>> im.getpixel((0, 0))\n    (20, 20, 70)\n    >>> len(im.getprojection())\n    2\n    >>> len(im.histogram())\n    768\n    >>> '%.7f' % im.entropy()\n    '8.8212866'\n    >>> _info(im.point(list(range(256))*3))\n    (None, 'RGB', (128, 128))\n    >>> _info(im.resize((64, 64)))\n    (None, 'RGB', (64, 64))\n    >>> _info(im.rotate(45))\n    (None, 'RGB', (128, 128))\n    >>> [_info(ch) for ch in im.split()]\n    [(None, 'L', (128, 128)), (None, 'L', (128, 128)), (None, 'L', (128, 128))]\n    >>> len(im.convert(\"1\").tobitmap())\n    10456\n    >>> len(im.tobytes())\n    49152\n    >>> _info(im.transform((512, 512), Image.Transform.AFFINE, (1,0,0,0,1,0)))\n    (None, 'RGB', (512, 512))\n    >>> _info(im.transform((512, 512), Image.Transform.EXTENT, (32,32,96,96)))\n    (None, 'RGB', (512, 512))\n\n    The ImageDraw module lets you draw stuff in raster images:\n\n    >>> im = Image.new(\"L\", (128, 128), 64)\n    >>> d = ImageDraw.ImageDraw(im)\n    >>> d.line((0, 0, 128, 128), fill=128)\n    >>> d.line((0, 128, 128, 0), fill=128)\n    >>> im.getextrema()\n    (64, 128)\n\n    In 1.1.4, you can specify colors in a number of ways:\n\n    >>> xy = 0, 0, 128, 128\n    >>> im = Image.new(\"RGB\", (128, 128), 0)\n    >>> d = ImageDraw.ImageDraw(im)\n    >>> d.rectangle(xy, \"#f00\")\n    >>> im.getpixel((0, 0))\n    (255, 0, 0)\n    >>> d.rectangle(xy, \"#ff0000\")\n    >>> im.getpixel((0, 0))\n    (255, 0, 0)\n    >>> d.rectangle(xy, \"rgb(255,0,0)\")\n    >>> im.getpixel((0, 0))\n    (255, 0, 0)\n    >>> d.rectangle(xy, \"rgb(100%,0%,0%)\")\n    >>> im.getpixel((0, 0))\n    (255, 0, 0)\n    >>> d.rectangle(xy, \"hsl(0, 100%, 50%)\")\n    >>> im.getpixel((0, 0))\n    (255, 0, 0)\n    >>> d.rectangle(xy, \"red\")\n    >>> im.getpixel((0, 0))\n    (255, 0, 0)\n\n    In 1.1.6, you can use the ImageMath module to do image\n    calculations.\n\n    >>> im = ImageMath.lambda_eval( \\\n      lambda args: args[\"float\"](args[\"im\"] + 20), im=im.convert(\"L\") \\\n    )\n    >>> im.mode, im.size\n    ('F', (128, 128))\n\n    PIL can do many other things, but I'll leave that for another\n    day.\n\n    Cheers /F\n    \"\"\"\n\n\nif __name__ == \"__main__\":\n    # check build sanity\n\n    exit_status = 0\n\n    features.pilinfo(sys.stdout, False)\n\n    # use doctest to make sure the test program behaves as documented!\n    import doctest\n\n    print(\"Running selftest:\")\n    status = doctest.testmod(sys.modules[__name__])\n    if status[0]:\n        print(f\"*** {status[0]} tests of {status[1]} failed.\")\n        exit_status = 1\n    else:\n        print(f\"--- {status[1]} tests passed.\")\n\n    sys.exit(exit_status)\n", "conftest.py": "from __future__ import annotations\n\npytest_plugins = [\"Tests.helper\"]\n", "_custom_build/backend.py": "from __future__ import annotations\n\nimport sys\n\nfrom setuptools.build_meta import *  # noqa: F403\nfrom setuptools.build_meta import build_wheel\n\nbackend_class = build_wheel.__self__.__class__\n\n\nclass _CustomBuildMetaBackend(backend_class):\n    def run_setup(self, setup_script=\"setup.py\"):\n        if self.config_settings:\n            for key, values in self.config_settings.items():\n                if not isinstance(values, list):\n                    values = [values]\n                for value in values:\n                    sys.argv.append(f\"--pillow-configuration={key}={value}\")\n\n        return super().run_setup(setup_script)\n\n    def build_wheel(\n        self, wheel_directory, config_settings=None, metadata_directory=None\n    ):\n        self.config_settings = config_settings\n        return super().build_wheel(wheel_directory, config_settings, metadata_directory)\n\n    def build_editable(\n        self, wheel_directory, config_settings=None, metadata_directory=None\n    ):\n        self.config_settings = config_settings\n        return super().build_editable(\n            wheel_directory, config_settings, metadata_directory\n        )\n\n\n_backend = _CustomBuildMetaBackend()\nbuild_wheel = _backend.build_wheel\nbuild_editable = _backend.build_editable\n", ".github/workflows/system-info.py": "\"\"\"\nPrint out some handy system info like Travis CI does.\n\nThis sort of info is missing from GitHub Actions.\n\nRequested here:\nhttps://github.com/actions/virtual-environments/issues/79\n\"\"\"\n\nfrom __future__ import annotations\n\nimport os\nimport platform\nimport sys\n\nprint(\"Build system information\")\nprint()\n\nprint(\"sys.version\\t\\t\", sys.version.split(\"\\n\"))\nprint(\"os.name\\t\\t\\t\", os.name)\nprint(\"sys.platform\\t\\t\", sys.platform)\nprint(\"platform.system()\\t\", platform.system())\nprint(\"platform.machine()\\t\", platform.machine())\nprint(\"platform.platform()\\t\", platform.platform())\nprint(\"platform.version()\\t\", platform.version())\nprint(\"platform.uname()\\t\", platform.uname())\nif sys.platform == \"darwin\":\n    print(\"platform.mac_ver()\\t\", platform.mac_ver())\n", "docs/dater.py": "\"\"\"\nSphinx extension to add timestamps to release notes based on Git versions.\n\nBased on https://github.com/jaraco/rst.linker, with thanks to Jason R. Coombs.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport re\nimport subprocess\nfrom typing import TYPE_CHECKING\n\nif TYPE_CHECKING:\n    from sphinx.application import Sphinx\n\nDOC_NAME_REGEX = re.compile(r\"releasenotes/\\d+\\.\\d+\\.\\d+\")\nVERSION_TITLE_REGEX = re.compile(r\"^(\\d+\\.\\d+\\.\\d+)\\n-+\\n\")\n\n\ndef get_date_for(git_version: str) -> str | None:\n    cmd = [\"git\", \"log\", \"-1\", \"--format=%ai\", git_version]\n    try:\n        out = subprocess.check_output(\n            cmd, stderr=subprocess.DEVNULL, text=True, encoding=\"utf-8\"\n        )\n    except subprocess.CalledProcessError:\n        return None\n    return out.split()[0]\n\n\ndef add_date(app: Sphinx, doc_name: str, source: list[str]) -> None:\n    if DOC_NAME_REGEX.match(doc_name) and (m := VERSION_TITLE_REGEX.match(source[0])):\n        old_title = m.group(1)\n\n        if tag_date := get_date_for(old_title):\n            new_title = f\"{old_title} ({tag_date})\"\n        else:\n            new_title = f\"{old_title} (unreleased)\"\n\n        new_underline = \"-\" * len(new_title)\n\n        result = source[0].replace(m.group(0), f\"{new_title}\\n{new_underline}\\n\", 1)\n        source[0] = result\n\n\ndef setup(app: Sphinx) -> dict[str, bool]:\n    app.connect(\"source-read\", add_date)\n    return {\"parallel_read_safe\": True}\n", "docs/conf.py": "#\n# Pillow (PIL Fork) documentation build configuration file, created by\n# sphinx-quickstart on Sat Apr  4 07:54:11 2015.\n#\n# This file is execfile()d with the current directory set to its\n# containing dir.\n#\n# Note that not all possible configuration values are present in this\n# autogenerated file.\n#\n# All configuration values have a default; values that are commented out\n# serve to show the default.\n\n# If extensions (or modules to document with autodoc) are in another directory,\n# add these directories to sys.path here. If the directory is relative to the\n# documentation root, use os.path.abspath to make it absolute, like shown here.\n# sys.path.insert(0, os.path.abspath('.'))\nfrom __future__ import annotations\n\nimport PIL\n\n# -- General configuration ------------------------------------------------\n\n# If your documentation needs a minimal Sphinx version, state it here.\nneeds_sphinx = \"7.3\"\n\n# Add any Sphinx extension module names here, as strings. They can be\n# extensions coming with Sphinx (named 'sphinx.ext.*') or your custom\n# ones.\nextensions = [\n    \"dater\",\n    \"sphinx.ext.autodoc\",\n    \"sphinx.ext.extlinks\",\n    \"sphinx.ext.intersphinx\",\n    \"sphinx.ext.viewcode\",\n    \"sphinx_copybutton\",\n    \"sphinx_inline_tabs\",\n    \"sphinxext.opengraph\",\n]\n\nintersphinx_mapping = {\"python\": (\"https://docs.python.org/3\", None)}\n\n# The suffix(es) of source filenames.\n# You can specify multiple suffix as a list of string:\n# source_suffix = ['.rst', '.md']\nsource_suffix = \".rst\"\n\n# The encoding of source files.\n# source_encoding = 'utf-8-sig'\n\n# The master toctree document.\nmaster_doc = \"index\"\n\n# General information about the project.\nproject = \"Pillow (PIL Fork)\"\ncopyright = (\n    \"1995-2011 Fredrik Lundh and contributors, \"\n    \"2010-2024 Jeffrey A. Clark and contributors.\"\n)\nauthor = \"Fredrik Lundh (PIL), Jeffrey A. Clark (Pillow)\"\n\n# The version info for the project you're documenting, acts as replacement for\n# |version| and |release|, also used in various other places throughout the\n# built documents.\n#\n# The short X.Y version.\nversion = PIL.__version__\n# The full version, including alpha/beta/rc tags.\nrelease = PIL.__version__\n\n# The language for content autogenerated by Sphinx. Refer to documentation\n# for a list of supported languages.\n#\n# This is also used if you do content translation via gettext catalogs.\n# Usually you set \"language\" from the command line for these cases.\nlanguage = \"en\"\n\n# There are two options for replacing |today|: either, you set today to some\n# non-false value, then it is used:\n# today = ''\n# Else, today_fmt is used as the format for a strftime call.\n# today_fmt = '%B %d, %Y'\n\n# List of patterns, relative to source directory, that match files and\n# directories to ignore when looking for source files.\nexclude_patterns = [\"_build\", \"releasenotes/template.rst\"]\n\n# The reST default role (used for this markup: `text`) to use for all\n# documents.\n# default_role = None\n\n# If true, '()' will be appended to :func: etc. cross-reference text.\n# add_function_parentheses = True\n\n# If true, the current module name will be prepended to all description\n# unit titles (such as .. function::).\n# add_module_names = True\n\n# If true, sectionauthor and moduleauthor directives will be shown in the\n# output. They are ignored by default.\n# show_authors = False\n\n# The name of the Pygments (syntax highlighting) style to use.\npygments_style = \"sphinx\"\n\n# A list of ignored prefixes for module index sorting.\n# modindex_common_prefix = []\n\n# If true, keep warnings as \"system message\" paragraphs in the built documents.\n# keep_warnings = False\n\n# If true, `todo` and `todoList` produce output, else they produce nothing.\ntodo_include_todos = False\n\n# If true, Sphinx will warn about all references where the target cannot be found.\n# Default is False. You can activate this mode temporarily using the -n command-line\n# switch.\nnitpicky = True\n\n# A list of (type, target) tuples (by default empty) that should be ignored when\n# generating warnings in \u201cnitpicky mode\u201d. Note that type should include the domain name\n# if present. Example entries would be ('py:func', 'int') or\n# ('envvar', 'LD_LIBRARY_PATH').\n# nitpick_ignore = []\n\n\n# -- Options for HTML output ----------------------------------------------\n\n# The theme to use for HTML and HTML Help pages.  See the documentation for\n# a list of builtin themes.\n\nhtml_theme = \"furo\"\n\n# Theme options are theme-specific and customize the look and feel of a theme\n# further.  For a list of options available for each theme, see the\n# documentation.\nhtml_theme_options = {\n    \"light_logo\": \"pillow-logo-dark-text.png\",\n    \"dark_logo\": \"pillow-logo.png\",\n}\n\n# Add any paths that contain custom themes here, relative to this directory.\n# html_theme_path = []\n\n# The name for this set of Sphinx documents.  If None, it defaults to\n# \"<project> v<release> documentation\".\n# html_title = None\n\n# A shorter title for the navigation bar.  Default is the same as html_title.\n# html_short_title = None\n\n# The name of an image file (relative to this directory) to place at the top\n# of the sidebar.\n# html_logo = \"resources/pillow-logo.png\"\n\n# The name of an image file (within the static path) to use as favicon of the\n# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32\n# pixels large.\nhtml_favicon = \"resources/favicon.ico\"\n\n# Add any paths that contain custom static files (such as style sheets) here,\n# relative to this directory. They are copied after the builtin static files,\n# so a file named \"default.css\" will overwrite the builtin \"default.css\".\nhtml_static_path = [\"resources\"]\n\n# Add any extra paths that contain custom files (such as robots.txt or\n# .htaccess) here, relative to this directory. These files are copied\n# directly to the root of the documentation.\n# html_extra_path = []\n\nhtml_css_files = [\"css/dark.css\"]\n\nhtml_js_files = [\n    \"js/activate_tab.js\",\n]\n\n# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,\n# using the given strftime format.\n# html_last_updated_fmt = '%b %d, %Y'\n\n# If true, SmartyPants will be used to convert quotes and dashes to\n# typographically correct entities.\n# html_use_smartypants = True\n\n# Custom sidebar templates, maps document names to template names.\n# html_sidebars = {}\n\n# Additional templates that should be rendered to pages, maps page names to\n# template names.\n# html_additional_pages = {}\n\n# If false, no module index is generated.\n# html_domain_indices = True\n\n# If false, no index is generated.\n# html_use_index = True\n\n# If true, the index is split into individual pages for each letter.\n# html_split_index = False\n\n# If true, links to the reST sources are added to the pages.\n# html_show_sourcelink = True\n\n# If true, \"Created using Sphinx\" is shown in the HTML footer. Default is True.\n# html_show_sphinx = True\n\n# If true, \"(C) Copyright ...\" is shown in the HTML footer. Default is True.\n# html_show_copyright = True\n\n# If true, an OpenSearch description file will be output, and all pages will\n# contain a <link> tag referring to it.  The value of this option must be the\n# base URL from which the finished HTML is served.\n# html_use_opensearch = ''\n\n# This is the file name suffix for HTML files (e.g. \".xhtml\").\n# html_file_suffix = None\n\n# Language to be used for generating the HTML full-text search index.\n# Sphinx supports the following languages:\n#   'da', 'de', 'en', 'es', 'fi', 'fr', 'hu', 'it', 'ja'\n#   'nl', 'no', 'pt', 'ro', 'ru', 'sv', 'tr'\n# html_search_language = 'en'\n\n# A dictionary with options for the search language support, empty by default.\n# Now only 'ja' uses this config value\n# html_search_options = {'type': 'default'}\n\n# The name of a javascript file (relative to the configuration directory) that\n# implements a search results scorer. If empty, the default will be used.\n# html_search_scorer = 'scorer.js'\n\n# Output file base name for HTML help builder.\nhtmlhelp_basename = \"PillowPILForkdoc\"\n\n# -- Options for LaTeX output ---------------------------------------------\n\nlatex_elements: dict[str, str] = {\n    # The paper size ('letterpaper' or 'a4paper').\n    # 'papersize': 'letterpaper',\n    # The font size ('10pt', '11pt' or '12pt').\n    # 'pointsize': '10pt',\n    # Additional stuff for the LaTeX preamble.\n    # 'preamble': '',\n    # Latex figure (float) alignment\n    # 'figure_align': 'htbp',\n}\n\n# Grouping the document tree into LaTeX files. List of tuples\n# (source start file, target name, title,\n#  author, documentclass [howto, manual, or own class]).\nlatex_documents = [\n    (\n        master_doc,\n        \"PillowPILFork.tex\",\n        \"Pillow (PIL Fork) Documentation\",\n        \"Jeffrey A. Clark\",\n        \"manual\",\n    )\n]\n\n# The name of an image file (relative to this directory) to place at the top of\n# the title page.\n# latex_logo = None\n\n# For \"manual\" documents, if this is true, then toplevel headings are parts,\n# not chapters.\n# latex_use_parts = False\n\n# If true, show page references after internal links.\n# latex_show_pagerefs = False\n\n# If true, show URL addresses after external links.\n# latex_show_urls = False\n\n# Documents to append as an appendix to all manuals.\n# latex_appendices = []\n\n# If false, no module index is generated.\n# latex_domain_indices = True\n\n\n# -- Options for manual page output ---------------------------------------\n\n# One entry per manual page. List of tuples\n# (source start file, name, description, authors, manual section).\nman_pages = [\n    (master_doc, \"pillowpilfork\", \"Pillow (PIL Fork) Documentation\", [author], 1)\n]\n\n# If true, show URL addresses after external links.\n# man_show_urls = False\n\n\n# -- Options for Texinfo output -------------------------------------------\n\n# Grouping the document tree into Texinfo files. List of tuples\n# (source start file, target name, title, author,\n#  dir menu entry, description, category)\ntexinfo_documents = [\n    (\n        master_doc,\n        \"PillowPILFork\",\n        \"Pillow (PIL Fork) Documentation\",\n        author,\n        \"PillowPILFork\",\n        \"Pillow is the friendly PIL fork by Jeffrey A. Clark and contributors.\",\n        \"Miscellaneous\",\n    )\n]\n\n# Documents to append as an appendix to all manuals.\n# texinfo_appendices = []\n\n# If false, no module index is generated.\n# texinfo_domain_indices = True\n\n# How to display URL addresses: 'footnote', 'no', or 'inline'.\n# texinfo_show_urls = 'footnote'\n\n# If true, do not generate a @detailmenu in the \"Top\" node's menu.\n# texinfo_no_detailmenu = False\n\n\nlinkcheck_allowed_redirects = {\n    r\"https://www.bestpractices.dev/projects/6331\": r\"https://www.bestpractices.dev/en/.*\",\n    r\"https://badges.gitter.im/python-pillow/Pillow.svg\": r\"https://badges.gitter.im/repo.svg\",\n    r\"https://gitter.im/python-pillow/Pillow?.*\": r\"https://app.gitter.im/#/room/#python-pillow_Pillow:gitter.im?.*\",\n    r\"https://pillow.readthedocs.io/?badge=latest\": r\"https://pillow.readthedocs.io/en/stable/?badge=latest\",\n    r\"https://pillow.readthedocs.io\": r\"https://pillow.readthedocs.io/en/stable/\",\n    r\"https://tidelift.com/badges/package/pypi/pillow?.*\": r\"https://img.shields.io/badge/.*\",\n    r\"https://zenodo.org/badge/17549/python-pillow/Pillow.svg\": r\"https://zenodo.org/badge/doi/[\\.0-9]+/zenodo.[0-9]+.svg\",\n    r\"https://zenodo.org/badge/latestdoi/17549/python-pillow/Pillow\": r\"https://zenodo.org/record/[0-9]+\",\n}\n\n# sphinx.ext.extlinks\n# This config is a dictionary of external sites,\n# mapping unique short aliases to a base URL and a prefix.\n# https://www.sphinx-doc.org/en/master/usage/extensions/extlinks.html\n_repo = \"https://github.com/python-pillow/Pillow/\"\nextlinks = {\n    \"cve\": (\"https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-%s\", \"CVE-%s\"),\n    \"cwe\": (\"https://cwe.mitre.org/data/definitions/%s.html\", \"CWE-%s\"),\n    \"issue\": (_repo + \"issues/%s\", \"#%s\"),\n    \"pr\": (_repo + \"pull/%s\", \"#%s\"),\n    \"pypi\": (\"https://pypi.org/project/%s/\", \"%s\"),\n}\n\n# sphinxext.opengraph\nogp_image = (\n    \"https://raw.githubusercontent.com/python-pillow/pillow-logo/main/\"\n    \"pillow-logo-dark-text-1280x640.png\"\n)\nogp_image_alt = \"Pillow\"\n", "docs/example/DdsImagePlugin.py": "\"\"\"\nA Pillow loader for .dds files (S3TC-compressed aka DXTC)\nJerome Leclanche <jerome@leclan.ch>\n\nDocumentation:\n  https://web.archive.org/web/20170802060935/http://oss.sgi.com/projects/ogl-sample/registry/EXT/texture_compression_s3tc.txt\n\nThe contents of this file are hereby released in the public domain (CC0)\nFull text of the CC0 license:\n  https://creativecommons.org/publicdomain/zero/1.0/\n\"\"\"\n\nfrom __future__ import annotations\n\nimport struct\nfrom io import BytesIO\n\nfrom PIL import Image, ImageFile\n\n# Magic (\"DDS \")\nDDS_MAGIC = 0x20534444\n\n# DDS flags\nDDSD_CAPS = 0x1\nDDSD_HEIGHT = 0x2\nDDSD_WIDTH = 0x4\nDDSD_PITCH = 0x8\nDDSD_PIXELFORMAT = 0x1000\nDDSD_MIPMAPCOUNT = 0x20000\nDDSD_LINEARSIZE = 0x80000\nDDSD_DEPTH = 0x800000\n\n# DDS caps\nDDSCAPS_COMPLEX = 0x8\nDDSCAPS_TEXTURE = 0x1000\nDDSCAPS_MIPMAP = 0x400000\n\nDDSCAPS2_CUBEMAP = 0x200\nDDSCAPS2_CUBEMAP_POSITIVEX = 0x400\nDDSCAPS2_CUBEMAP_NEGATIVEX = 0x800\nDDSCAPS2_CUBEMAP_POSITIVEY = 0x1000\nDDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000\nDDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000\nDDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000\nDDSCAPS2_VOLUME = 0x200000\n\n# Pixel Format\nDDPF_ALPHAPIXELS = 0x1\nDDPF_ALPHA = 0x2\nDDPF_FOURCC = 0x4\nDDPF_PALETTEINDEXED8 = 0x20\nDDPF_RGB = 0x40\nDDPF_LUMINANCE = 0x20000\n\n\n# dds.h\n\nDDS_FOURCC = DDPF_FOURCC\nDDS_RGB = DDPF_RGB\nDDS_RGBA = DDPF_RGB | DDPF_ALPHAPIXELS\nDDS_LUMINANCE = DDPF_LUMINANCE\nDDS_LUMINANCEA = DDPF_LUMINANCE | DDPF_ALPHAPIXELS\nDDS_ALPHA = DDPF_ALPHA\nDDS_PAL8 = DDPF_PALETTEINDEXED8\n\nDDS_HEADER_FLAGS_TEXTURE = DDSD_CAPS | DDSD_HEIGHT | DDSD_WIDTH | DDSD_PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD_MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD_DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD_PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD_LINEARSIZE\n\nDDS_HEIGHT = DDSD_HEIGHT\nDDS_WIDTH = DDSD_WIDTH\n\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS_TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS_COMPLEX | DDSCAPS_MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS_COMPLEX\n\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2_CUBEMAP | DDSCAPS2_CUBEMAP_NEGATIVEZ\n\n\n# DXT1\nDXT1_FOURCC = 0x31545844\n\n# DXT3\nDXT3_FOURCC = 0x33545844\n\n# DXT5\nDXT5_FOURCC = 0x35545844\n\n\ndef _decode565(bits):\n    a = ((bits >> 11) & 0x1F) << 3\n    b = ((bits >> 5) & 0x3F) << 2\n    c = (bits & 0x1F) << 3\n    return a, b, c\n\n\ndef _c2a(a, b):\n    return (2 * a + b) // 3\n\n\ndef _c2b(a, b):\n    return (a + b) // 2\n\n\ndef _c3(a, b):\n    return (2 * b + a) // 3\n\n\ndef _dxt1(data, width, height):\n    # TODO implement this function as pixel format in decode.c\n    ret = bytearray(4 * width * height)\n\n    for y in range(0, height, 4):\n        for x in range(0, width, 4):\n            color0, color1, bits = struct.unpack(\"<HHI\", data.read(8))\n\n            r0, g0, b0 = _decode565(color0)\n            r1, g1, b1 = _decode565(color1)\n\n            # Decode this block into 4x4 pixels\n            for j in range(4):\n                for i in range(4):\n                    # get next control op and generate a pixel\n                    control = bits & 3\n                    bits = bits >> 2\n                    if control == 0:\n                        r, g, b = r0, g0, b0\n                    elif control == 1:\n                        r, g, b = r1, g1, b1\n                    elif control == 2:\n                        if color0 > color1:\n                            r, g, b = _c2a(r0, r1), _c2a(g0, g1), _c2a(b0, b1)\n                        else:\n                            r, g, b = _c2b(r0, r1), _c2b(g0, g1), _c2b(b0, b1)\n                    elif control == 3:\n                        if color0 > color1:\n                            r, g, b = _c3(r0, r1), _c3(g0, g1), _c3(b0, b1)\n                        else:\n                            r, g, b = 0, 0, 0\n\n                    idx = 4 * ((y + j) * width + x + i)\n                    ret[idx : idx + 4] = struct.pack(\"4B\", r, g, b, 255)\n\n    return bytes(ret)\n\n\ndef _dxtc_alpha(a0, a1, ac0, ac1, ai):\n    if ai <= 12:\n        ac = (ac0 >> ai) & 7\n    elif ai == 15:\n        ac = (ac0 >> 15) | ((ac1 << 1) & 6)\n    else:\n        ac = (ac1 >> (ai - 16)) & 7\n\n    if ac == 0:\n        alpha = a0\n    elif ac == 1:\n        alpha = a1\n    elif a0 > a1:\n        alpha = ((8 - ac) * a0 + (ac - 1) * a1) // 7\n    elif ac == 6:\n        alpha = 0\n    elif ac == 7:\n        alpha = 0xFF\n    else:\n        alpha = ((6 - ac) * a0 + (ac - 1) * a1) // 5\n\n    return alpha\n\n\ndef _dxt5(data, width, height):\n    # TODO implement this function as pixel format in decode.c\n    ret = bytearray(4 * width * height)\n\n    for y in range(0, height, 4):\n        for x in range(0, width, 4):\n            a0, a1, ac0, ac1, c0, c1, code = struct.unpack(\"<2BHI2HI\", data.read(16))\n\n            r0, g0, b0 = _decode565(c0)\n            r1, g1, b1 = _decode565(c1)\n\n            for j in range(4):\n                for i in range(4):\n                    ai = 3 * (4 * j + i)\n                    alpha = _dxtc_alpha(a0, a1, ac0, ac1, ai)\n\n                    cc = (code >> 2 * (4 * j + i)) & 3\n                    if cc == 0:\n                        r, g, b = r0, g0, b0\n                    elif cc == 1:\n                        r, g, b = r1, g1, b1\n                    elif cc == 2:\n                        r, g, b = _c2a(r0, r1), _c2a(g0, g1), _c2a(b0, b1)\n                    elif cc == 3:\n                        r, g, b = _c3(r0, r1), _c3(g0, g1), _c3(b0, b1)\n\n                    idx = 4 * ((y + j) * width + x + i)\n                    ret[idx : idx + 4] = struct.pack(\"4B\", r, g, b, alpha)\n\n    return bytes(ret)\n\n\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n\n    def _open(self):\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"\n            raise SyntaxError(msg)\n        (header_size,) = struct.unpack(\"<I\", self.fp.read(4))\n        if header_size != 124:\n            msg = f\"Unsupported header size {repr(header_size)}\"\n            raise OSError(msg)\n        header_bytes = self.fp.read(header_size - 4)\n        if len(header_bytes) != 120:\n            msg = f\"Incomplete header: {len(header_bytes)} bytes\"\n            raise OSError(msg)\n        header = BytesIO(header_bytes)\n\n        flags, height, width = struct.unpack(\"<3I\", header.read(12))\n        self._size = (width, height)\n        self._mode = \"RGBA\"\n\n        pitch, depth, mipmaps = struct.unpack(\"<3I\", header.read(12))\n        struct.unpack(\"<11I\", header.read(44))  # reserved\n\n        # pixel format\n        pfsize, pfflags = struct.unpack(\"<2I\", header.read(8))\n        fourcc = header.read(4)\n        bitcount, rmask, gmask, bmask, amask = struct.unpack(\"<5I\", header.read(20))\n\n        if fourcc == b\"DXT1\":\n            self.decoder = \"DXT1\"\n        elif fourcc == b\"DXT5\":\n            self.decoder = \"DXT5\"\n        else:\n            msg = f\"Unimplemented pixel format {fourcc}\"\n            raise NotImplementedError(msg)\n\n        self.tile = [(self.decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]\n\n    def load_seek(self, pos):\n        pass\n\n\nclass DXT1Decoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer):\n        try:\n            self.set_as_raw(_dxt1(self.fd, self.state.xsize, self.state.ysize))\n        except struct.error as e:\n            msg = \"Truncated DDS file\"\n            raise OSError(msg) from e\n        return -1, 0\n\n\nclass DXT5Decoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer):\n        try:\n            self.set_as_raw(_dxt5(self.fd, self.state.xsize, self.state.ysize))\n        except struct.error as e:\n            msg = \"Truncated DDS file\"\n            raise OSError(msg) from e\n        return -1, 0\n\n\nImage.register_decoder(\"DXT1\", DXT1Decoder)\nImage.register_decoder(\"DXT5\", DXT5Decoder)\n\n\ndef _accept(prefix):\n    return prefix[:4] == b\"DDS \"\n\n\nImage.register_open(DdsImageFile.format, DdsImageFile, _accept)\nImage.register_extension(DdsImageFile.format, \".dds\")\n", "docs/example/anchors.py": "from __future__ import annotations\n\nfrom PIL import Image, ImageDraw, ImageFont\n\nfont = ImageFont.truetype(\"Tests/fonts/NotoSans-Regular.ttf\", 16)\n\n\ndef test(anchor: str) -> Image.Image:\n    im = Image.new(\"RGBA\", (200, 100), \"white\")\n    d = ImageDraw.Draw(im)\n    d.line(((100, 0), (100, 100)), \"gray\")\n    d.line(((0, 50), (200, 50)), \"gray\")\n    d.text((100, 50), f\"{anchor} example\", \"black\", font, anchor)\n    return im\n\n\nif __name__ == \"__main__\":\n    im = Image.new(\"RGBA\", (600, 300), \"white\")\n    d = ImageDraw.Draw(im)\n    for y, row in enumerate(\n        ((\"ma\", \"mt\", \"mm\"), (\"ms\", \"mb\", \"md\"), (\"ls\", \"ms\", \"rs\"))\n    ):\n        for x, anchor in enumerate(row):\n            im.paste(test(anchor), (x * 200, y * 100))\n            if x != 0:\n                d.line(((x * 200, y * 100), (x * 200, (y + 1) * 100)), \"black\", 3)\n            if y != 0:\n                d.line(((x * 200, y * 100), ((x + 1) * 200, y * 100)), \"black\", 3)\n    im.save(\"docs/example/anchors.png\")\n    im.show()\n", "src/PIL/ImageMorph.py": "# A binary morphology add-on for the Python Imaging Library\n#\n# History:\n#   2014-06-04 Initial version.\n#\n# Copyright (c) 2014 Dov Grobgeld <dov.grobgeld@gmail.com>\nfrom __future__ import annotations\n\nimport re\n\nfrom . import Image, _imagingmorph\n\nLUT_SIZE = 1 << 9\n\n# fmt: off\nROTATION_MATRIX = [\n    6, 3, 0,\n    7, 4, 1,\n    8, 5, 2,\n]\nMIRROR_MATRIX = [\n    2, 1, 0,\n    5, 4, 3,\n    8, 7, 6,\n]\n# fmt: on\n\n\nclass LutBuilder:\n    \"\"\"A class for building a MorphLut from a descriptive language\n\n    The input patterns is a list of a strings sequences like these::\n\n        4:(...\n           .1.\n           111)->1\n\n    (whitespaces including linebreaks are ignored). The option 4\n    describes a series of symmetry operations (in this case a\n    4-rotation), the pattern is described by:\n\n    - . or X - Ignore\n    - 1 - Pixel is on\n    - 0 - Pixel is off\n\n    The result of the operation is described after \"->\" string.\n\n    The default is to return the current pixel value, which is\n    returned if no other match is found.\n\n    Operations:\n\n    - 4 - 4 way rotation\n    - N - Negate\n    - 1 - Dummy op for no other operation (an op must always be given)\n    - M - Mirroring\n\n    Example::\n\n        lb = LutBuilder(patterns = [\"4:(... .1. 111)->1\"])\n        lut = lb.build_lut()\n\n    \"\"\"\n\n    def __init__(\n        self, patterns: list[str] | None = None, op_name: str | None = None\n    ) -> None:\n        if patterns is not None:\n            self.patterns = patterns\n        else:\n            self.patterns = []\n        self.lut: bytearray | None = None\n        if op_name is not None:\n            known_patterns = {\n                \"corner\": [\"1:(... ... ...)->0\", \"4:(00. 01. ...)->1\"],\n                \"dilation4\": [\"4:(... .0. .1.)->1\"],\n                \"dilation8\": [\"4:(... .0. .1.)->1\", \"4:(... .0. ..1)->1\"],\n                \"erosion4\": [\"4:(... .1. .0.)->0\"],\n                \"erosion8\": [\"4:(... .1. .0.)->0\", \"4:(... .1. ..0)->0\"],\n                \"edge\": [\n                    \"1:(... ... ...)->0\",\n                    \"4:(.0. .1. ...)->1\",\n                    \"4:(01. .1. ...)->1\",\n                ],\n            }\n            if op_name not in known_patterns:\n                msg = f\"Unknown pattern {op_name}!\"\n                raise Exception(msg)\n\n            self.patterns = known_patterns[op_name]\n\n    def add_patterns(self, patterns: list[str]) -> None:\n        self.patterns += patterns\n\n    def build_default_lut(self) -> None:\n        symbols = [0, 1]\n        m = 1 << 4  # pos of current pixel\n        self.lut = bytearray(symbols[(i & m) > 0] for i in range(LUT_SIZE))\n\n    def get_lut(self) -> bytearray | None:\n        return self.lut\n\n    def _string_permute(self, pattern: str, permutation: list[int]) -> str:\n        \"\"\"string_permute takes a pattern and a permutation and returns the\n        string permuted according to the permutation list.\n        \"\"\"\n        assert len(permutation) == 9\n        return \"\".join(pattern[p] for p in permutation)\n\n    def _pattern_permute(\n        self, basic_pattern: str, options: str, basic_result: int\n    ) -> list[tuple[str, int]]:\n        \"\"\"pattern_permute takes a basic pattern and its result and clones\n        the pattern according to the modifications described in the $options\n        parameter. It returns a list of all cloned patterns.\"\"\"\n        patterns = [(basic_pattern, basic_result)]\n\n        # rotations\n        if \"4\" in options:\n            res = patterns[-1][1]\n            for i in range(4):\n                patterns.append(\n                    (self._string_permute(patterns[-1][0], ROTATION_MATRIX), res)\n                )\n        # mirror\n        if \"M\" in options:\n            n = len(patterns)\n            for pattern, res in patterns[:n]:\n                patterns.append((self._string_permute(pattern, MIRROR_MATRIX), res))\n\n        # negate\n        if \"N\" in options:\n            n = len(patterns)\n            for pattern, res in patterns[:n]:\n                # Swap 0 and 1\n                pattern = pattern.replace(\"0\", \"Z\").replace(\"1\", \"0\").replace(\"Z\", \"1\")\n                res = 1 - int(res)\n                patterns.append((pattern, res))\n\n        return patterns\n\n    def build_lut(self) -> bytearray:\n        \"\"\"Compile all patterns into a morphology lut.\n\n        TBD :Build based on (file) morphlut:modify_lut\n        \"\"\"\n        self.build_default_lut()\n        assert self.lut is not None\n        patterns = []\n\n        # Parse and create symmetries of the patterns strings\n        for p in self.patterns:\n            m = re.search(r\"(\\w*):?\\s*\\((.+?)\\)\\s*->\\s*(\\d)\", p.replace(\"\\n\", \"\"))\n            if not m:\n                msg = 'Syntax error in pattern \"' + p + '\"'\n                raise Exception(msg)\n            options = m.group(1)\n            pattern = m.group(2)\n            result = int(m.group(3))\n\n            # Get rid of spaces\n            pattern = pattern.replace(\" \", \"\").replace(\"\\n\", \"\")\n\n            patterns += self._pattern_permute(pattern, options, result)\n\n        # compile the patterns into regular expressions for speed\n        compiled_patterns = []\n        for pattern in patterns:\n            p = pattern[0].replace(\".\", \"X\").replace(\"X\", \"[01]\")\n            compiled_patterns.append((re.compile(p), pattern[1]))\n\n        # Step through table and find patterns that match.\n        # Note that all the patterns are searched. The last one\n        # caught overrides\n        for i in range(LUT_SIZE):\n            # Build the bit pattern\n            bitpattern = bin(i)[2:]\n            bitpattern = (\"0\" * (9 - len(bitpattern)) + bitpattern)[::-1]\n\n            for pattern, r in compiled_patterns:\n                if pattern.match(bitpattern):\n                    self.lut[i] = [0, 1][r]\n\n        return self.lut\n\n\nclass MorphOp:\n    \"\"\"A class for binary morphological operators\"\"\"\n\n    def __init__(\n        self,\n        lut: bytearray | None = None,\n        op_name: str | None = None,\n        patterns: list[str] | None = None,\n    ) -> None:\n        \"\"\"Create a binary morphological operator\"\"\"\n        self.lut = lut\n        if op_name is not None:\n            self.lut = LutBuilder(op_name=op_name).build_lut()\n        elif patterns is not None:\n            self.lut = LutBuilder(patterns=patterns).build_lut()\n\n    def apply(self, image: Image.Image) -> tuple[int, Image.Image]:\n        \"\"\"Run a single morphological operation on an image\n\n        Returns a tuple of the number of changed pixels and the\n        morphed image\"\"\"\n        if self.lut is None:\n            msg = \"No operator loaded\"\n            raise Exception(msg)\n\n        if image.mode != \"L\":\n            msg = \"Image mode must be L\"\n            raise ValueError(msg)\n        outimage = Image.new(image.mode, image.size, None)\n        count = _imagingmorph.apply(bytes(self.lut), image.im.id, outimage.im.id)\n        return count, outimage\n\n    def match(self, image: Image.Image) -> list[tuple[int, int]]:\n        \"\"\"Get a list of coordinates matching the morphological operation on\n        an image.\n\n        Returns a list of tuples of (x,y) coordinates\n        of all matching pixels. See :ref:`coordinate-system`.\"\"\"\n        if self.lut is None:\n            msg = \"No operator loaded\"\n            raise Exception(msg)\n\n        if image.mode != \"L\":\n            msg = \"Image mode must be L\"\n            raise ValueError(msg)\n        return _imagingmorph.match(bytes(self.lut), image.im.id)\n\n    def get_on_pixels(self, image: Image.Image) -> list[tuple[int, int]]:\n        \"\"\"Get a list of all turned on pixels in a binary image\n\n        Returns a list of tuples of (x,y) coordinates\n        of all matching pixels. See :ref:`coordinate-system`.\"\"\"\n\n        if image.mode != \"L\":\n            msg = \"Image mode must be L\"\n            raise ValueError(msg)\n        return _imagingmorph.get_on_pixels(image.im.id)\n\n    def load_lut(self, filename: str) -> None:\n        \"\"\"Load an operator from an mrl file\"\"\"\n        with open(filename, \"rb\") as f:\n            self.lut = bytearray(f.read())\n\n        if len(self.lut) != LUT_SIZE:\n            self.lut = None\n            msg = \"Wrong size operator file!\"\n            raise Exception(msg)\n\n    def save_lut(self, filename: str) -> None:\n        \"\"\"Save an operator to an mrl file\"\"\"\n        if self.lut is None:\n            msg = \"No operator loaded\"\n            raise Exception(msg)\n        with open(filename, \"wb\") as f:\n            f.write(self.lut)\n\n    def set_lut(self, lut: bytearray | None) -> None:\n        \"\"\"Set the lut from an external source\"\"\"\n        self.lut = lut\n", "src/PIL/MspImagePlugin.py": "#\n# The Python Imaging Library.\n#\n# MSP file handling\n#\n# This is the format used by the Paint program in Windows 1 and 2.\n#\n# History:\n#       95-09-05 fl     Created\n#       97-01-03 fl     Read/write MSP images\n#       17-02-21 es     Fixed RLE interpretation\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1995-97.\n# Copyright (c) Eric Soroos 2017.\n#\n# See the README file for information on usage and redistribution.\n#\n# More info on this format: https://archive.org/details/gg243631\n# Page 313:\n# Figure 205. Windows Paint Version 1: \"DanM\" Format\n# Figure 206. Windows Paint Version 2: \"LinS\" Format. Used in Windows V2.03\n#\n# See also: https://www.fileformat.info/format/mspaint/egff.htm\nfrom __future__ import annotations\n\nimport io\nimport struct\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16le as i16\nfrom ._binary import o16le as o16\n\n#\n# read MSP files\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] in [b\"DanM\", b\"LinS\"]\n\n\n##\n# Image plugin for Windows MSP images.  This plugin supports both\n# uncompressed (Windows 1.0).\n\n\nclass MspImageFile(ImageFile.ImageFile):\n    format = \"MSP\"\n    format_description = \"Windows Paint\"\n\n    def _open(self) -> None:\n        # Header\n        assert self.fp is not None\n\n        s = self.fp.read(32)\n        if not _accept(s):\n            msg = \"not an MSP file\"\n            raise SyntaxError(msg)\n\n        # Header checksum\n        checksum = 0\n        for i in range(0, 32, 2):\n            checksum = checksum ^ i16(s, i)\n        if checksum != 0:\n            msg = \"bad MSP checksum\"\n            raise SyntaxError(msg)\n\n        self._mode = \"1\"\n        self._size = i16(s, 4), i16(s, 6)\n\n        if s[:4] == b\"DanM\":\n            self.tile = [(\"raw\", (0, 0) + self.size, 32, (\"1\", 0, 1))]\n        else:\n            self.tile = [(\"MSP\", (0, 0) + self.size, 32, None)]\n\n\nclass MspDecoder(ImageFile.PyDecoder):\n    # The algo for the MSP decoder is from\n    # https://www.fileformat.info/format/mspaint/egff.htm\n    # cc-by-attribution -- That page references is taken from the\n    # Encyclopedia of Graphics File Formats and is licensed by\n    # O'Reilly under the Creative Common/Attribution license\n    #\n    # For RLE encoded files, the 32byte header is followed by a scan\n    # line map, encoded as one 16bit word of encoded byte length per\n    # line.\n    #\n    # NOTE: the encoded length of the line can be 0. This was not\n    # handled in the previous version of this encoder, and there's no\n    # mention of how to handle it in the documentation. From the few\n    # examples I've seen, I've assumed that it is a fill of the\n    # background color, in this case, white.\n    #\n    #\n    # Pseudocode of the decoder:\n    # Read a BYTE value as the RunType\n    #  If the RunType value is zero\n    #   Read next byte as the RunCount\n    #   Read the next byte as the RunValue\n    #   Write the RunValue byte RunCount times\n    #  If the RunType value is non-zero\n    #   Use this value as the RunCount\n    #   Read and write the next RunCount bytes literally\n    #\n    #  e.g.:\n    #  0x00 03 ff 05 00 01 02 03 04\n    #  would yield the bytes:\n    #  0xff ff ff 00 01 02 03 04\n    #\n    # which are then interpreted as a bit packed mode '1' image\n\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n\n        img = io.BytesIO()\n        blank_line = bytearray((0xFF,) * ((self.state.xsize + 7) // 8))\n        try:\n            self.fd.seek(32)\n            rowmap = struct.unpack_from(\n                f\"<{self.state.ysize}H\", self.fd.read(self.state.ysize * 2)\n            )\n        except struct.error as e:\n            msg = \"Truncated MSP file in row map\"\n            raise OSError(msg) from e\n\n        for x, rowlen in enumerate(rowmap):\n            try:\n                if rowlen == 0:\n                    img.write(blank_line)\n                    continue\n                row = self.fd.read(rowlen)\n                if len(row) != rowlen:\n                    msg = f\"Truncated MSP file, expected {rowlen} bytes on row {x}\"\n                    raise OSError(msg)\n                idx = 0\n                while idx < rowlen:\n                    runtype = row[idx]\n                    idx += 1\n                    if runtype == 0:\n                        (runcount, runval) = struct.unpack_from(\"Bc\", row, idx)\n                        img.write(runval * runcount)\n                        idx += 2\n                    else:\n                        runcount = runtype\n                        img.write(row[idx : idx + runcount])\n                        idx += runcount\n\n            except struct.error as e:\n                msg = f\"Corrupted MSP file in row {x}\"\n                raise OSError(msg) from e\n\n        self.set_as_raw(img.getvalue(), (\"1\", 0, 1))\n\n        return -1, 0\n\n\nImage.register_decoder(\"MSP\", MspDecoder)\n\n\n#\n# write MSP files (uncompressed only)\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode != \"1\":\n        msg = f\"cannot write mode {im.mode} as MSP\"\n        raise OSError(msg)\n\n    # create MSP header\n    header = [0] * 16\n\n    header[0], header[1] = i16(b\"Da\"), i16(b\"nM\")  # version 1\n    header[2], header[3] = im.size\n    header[4], header[5] = 1, 1\n    header[6], header[7] = 1, 1\n    header[8], header[9] = im.size\n\n    checksum = 0\n    for h in header:\n        checksum = checksum ^ h\n    header[12] = checksum  # FIXME: is this the right field?\n\n    # header\n    for h in header:\n        fp.write(o16(h))\n\n    # image body\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 32, (\"1\", 0, 1))])\n\n\n#\n# registry\n\nImage.register_open(MspImageFile.format, MspImageFile, _accept)\nImage.register_save(MspImageFile.format, _save)\n\nImage.register_extension(MspImageFile.format, \".msp\")\n", "src/PIL/WalImageFile.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# WAL file handling\n#\n# History:\n# 2003-04-23 fl   created\n#\n# Copyright (c) 2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nThis reader is based on the specification available from:\nhttps://www.flipcode.com/archives/Quake_2_BSP_File_Format.shtml\nand has been tested with a few sample files found using google.\n\n.. note::\n    This format cannot be automatically recognized, so the reader\n    is not registered for use with :py:func:`PIL.Image.open()`.\n    To open a WAL file, use the :py:func:`PIL.WalImageFile.open()` function instead.\n\"\"\"\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i32le as i32\n\n\nclass WalImageFile(ImageFile.ImageFile):\n    format = \"WAL\"\n    format_description = \"Quake2 Texture\"\n\n    def _open(self) -> None:\n        self._mode = \"P\"\n\n        # read header fields\n        header = self.fp.read(32 + 24 + 32 + 12)\n        self._size = i32(header, 32), i32(header, 36)\n        Image._decompression_bomb_check(self.size)\n\n        # load pixel data\n        offset = i32(header, 40)\n        self.fp.seek(offset)\n\n        # strings are null-terminated\n        self.info[\"name\"] = header[:32].split(b\"\\0\", 1)[0]\n        next_name = header[56 : 56 + 32].split(b\"\\0\", 1)[0]\n        if next_name:\n            self.info[\"next_name\"] = next_name\n\n    def load(self):\n        if not self.im:\n            self.im = Image.core.new(self.mode, self.size)\n            self.frombytes(self.fp.read(self.size[0] * self.size[1]))\n            self.putpalette(quake2palette)\n        return Image.Image.load(self)\n\n\ndef open(filename):\n    \"\"\"\n    Load texture from a Quake2 WAL texture file.\n\n    By default, a Quake2 standard palette is attached to the texture.\n    To override the palette, use the :py:func:`PIL.Image.Image.putpalette()` method.\n\n    :param filename: WAL file name, or an opened file handle.\n    :returns: An image instance.\n    \"\"\"\n    return WalImageFile(filename)\n\n\nquake2palette = (\n    # default palette taken from piffo 0.93 by Hans H\u00e4ggstr\u00f6m\n    b\"\\x01\\x01\\x01\\x0b\\x0b\\x0b\\x12\\x12\\x12\\x17\\x17\\x17\\x1b\\x1b\\x1b\\x1e\"\n    b\"\\x1e\\x1e\\x22\\x22\\x22\\x26\\x26\\x26\\x29\\x29\\x29\\x2c\\x2c\\x2c\\x2f\\x2f\"\n    b\"\\x2f\\x32\\x32\\x32\\x35\\x35\\x35\\x37\\x37\\x37\\x3a\\x3a\\x3a\\x3c\\x3c\\x3c\"\n    b\"\\x24\\x1e\\x13\\x22\\x1c\\x12\\x20\\x1b\\x12\\x1f\\x1a\\x10\\x1d\\x19\\x10\\x1b\"\n    b\"\\x17\\x0f\\x1a\\x16\\x0f\\x18\\x14\\x0d\\x17\\x13\\x0d\\x16\\x12\\x0d\\x14\\x10\"\n    b\"\\x0b\\x13\\x0f\\x0b\\x10\\x0d\\x0a\\x0f\\x0b\\x0a\\x0d\\x0b\\x07\\x0b\\x0a\\x07\"\n    b\"\\x23\\x23\\x26\\x22\\x22\\x25\\x22\\x20\\x23\\x21\\x1f\\x22\\x20\\x1e\\x20\\x1f\"\n    b\"\\x1d\\x1e\\x1d\\x1b\\x1c\\x1b\\x1a\\x1a\\x1a\\x19\\x19\\x18\\x17\\x17\\x17\\x16\"\n    b\"\\x16\\x14\\x14\\x14\\x13\\x13\\x13\\x10\\x10\\x10\\x0f\\x0f\\x0f\\x0d\\x0d\\x0d\"\n    b\"\\x2d\\x28\\x20\\x29\\x24\\x1c\\x27\\x22\\x1a\\x25\\x1f\\x17\\x38\\x2e\\x1e\\x31\"\n    b\"\\x29\\x1a\\x2c\\x25\\x17\\x26\\x20\\x14\\x3c\\x30\\x14\\x37\\x2c\\x13\\x33\\x28\"\n    b\"\\x12\\x2d\\x24\\x10\\x28\\x1f\\x0f\\x22\\x1a\\x0b\\x1b\\x14\\x0a\\x13\\x0f\\x07\"\n    b\"\\x31\\x1a\\x16\\x30\\x17\\x13\\x2e\\x16\\x10\\x2c\\x14\\x0d\\x2a\\x12\\x0b\\x27\"\n    b\"\\x0f\\x0a\\x25\\x0f\\x07\\x21\\x0d\\x01\\x1e\\x0b\\x01\\x1c\\x0b\\x01\\x1a\\x0b\"\n    b\"\\x01\\x18\\x0a\\x01\\x16\\x0a\\x01\\x13\\x0a\\x01\\x10\\x07\\x01\\x0d\\x07\\x01\"\n    b\"\\x29\\x23\\x1e\\x27\\x21\\x1c\\x26\\x20\\x1b\\x25\\x1f\\x1a\\x23\\x1d\\x19\\x21\"\n    b\"\\x1c\\x18\\x20\\x1b\\x17\\x1e\\x19\\x16\\x1c\\x18\\x14\\x1b\\x17\\x13\\x19\\x14\"\n    b\"\\x10\\x17\\x13\\x0f\\x14\\x10\\x0d\\x12\\x0f\\x0b\\x0f\\x0b\\x0a\\x0b\\x0a\\x07\"\n    b\"\\x26\\x1a\\x0f\\x23\\x19\\x0f\\x20\\x17\\x0f\\x1c\\x16\\x0f\\x19\\x13\\x0d\\x14\"\n    b\"\\x10\\x0b\\x10\\x0d\\x0a\\x0b\\x0a\\x07\\x33\\x22\\x1f\\x35\\x29\\x26\\x37\\x2f\"\n    b\"\\x2d\\x39\\x35\\x34\\x37\\x39\\x3a\\x33\\x37\\x39\\x30\\x34\\x36\\x2b\\x31\\x34\"\n    b\"\\x27\\x2e\\x31\\x22\\x2b\\x2f\\x1d\\x28\\x2c\\x17\\x25\\x2a\\x0f\\x20\\x26\\x0d\"\n    b\"\\x1e\\x25\\x0b\\x1c\\x22\\x0a\\x1b\\x20\\x07\\x19\\x1e\\x07\\x17\\x1b\\x07\\x14\"\n    b\"\\x18\\x01\\x12\\x16\\x01\\x0f\\x12\\x01\\x0b\\x0d\\x01\\x07\\x0a\\x01\\x01\\x01\"\n    b\"\\x2c\\x21\\x21\\x2a\\x1f\\x1f\\x29\\x1d\\x1d\\x27\\x1c\\x1c\\x26\\x1a\\x1a\\x24\"\n    b\"\\x18\\x18\\x22\\x17\\x17\\x21\\x16\\x16\\x1e\\x13\\x13\\x1b\\x12\\x12\\x18\\x10\"\n    b\"\\x10\\x16\\x0d\\x0d\\x12\\x0b\\x0b\\x0d\\x0a\\x0a\\x0a\\x07\\x07\\x01\\x01\\x01\"\n    b\"\\x2e\\x30\\x29\\x2d\\x2e\\x27\\x2b\\x2c\\x26\\x2a\\x2a\\x24\\x28\\x29\\x23\\x27\"\n    b\"\\x27\\x21\\x26\\x26\\x1f\\x24\\x24\\x1d\\x22\\x22\\x1c\\x1f\\x1f\\x1a\\x1c\\x1c\"\n    b\"\\x18\\x19\\x19\\x16\\x17\\x17\\x13\\x13\\x13\\x10\\x0f\\x0f\\x0d\\x0b\\x0b\\x0a\"\n    b\"\\x30\\x1e\\x1b\\x2d\\x1c\\x19\\x2c\\x1a\\x17\\x2a\\x19\\x14\\x28\\x17\\x13\\x26\"\n    b\"\\x16\\x10\\x24\\x13\\x0f\\x21\\x12\\x0d\\x1f\\x10\\x0b\\x1c\\x0f\\x0a\\x19\\x0d\"\n    b\"\\x0a\\x16\\x0b\\x07\\x12\\x0a\\x07\\x0f\\x07\\x01\\x0a\\x01\\x01\\x01\\x01\\x01\"\n    b\"\\x28\\x29\\x38\\x26\\x27\\x36\\x25\\x26\\x34\\x24\\x24\\x31\\x22\\x22\\x2f\\x20\"\n    b\"\\x21\\x2d\\x1e\\x1f\\x2a\\x1d\\x1d\\x27\\x1b\\x1b\\x25\\x19\\x19\\x21\\x17\\x17\"\n    b\"\\x1e\\x14\\x14\\x1b\\x13\\x12\\x17\\x10\\x0f\\x13\\x0d\\x0b\\x0f\\x0a\\x07\\x07\"\n    b\"\\x2f\\x32\\x29\\x2d\\x30\\x26\\x2b\\x2e\\x24\\x29\\x2c\\x21\\x27\\x2a\\x1e\\x25\"\n    b\"\\x28\\x1c\\x23\\x26\\x1a\\x21\\x25\\x18\\x1e\\x22\\x14\\x1b\\x1f\\x10\\x19\\x1c\"\n    b\"\\x0d\\x17\\x1a\\x0a\\x13\\x17\\x07\\x10\\x13\\x01\\x0d\\x0f\\x01\\x0a\\x0b\\x01\"\n    b\"\\x01\\x3f\\x01\\x13\\x3c\\x0b\\x1b\\x39\\x10\\x20\\x35\\x14\\x23\\x31\\x17\\x23\"\n    b\"\\x2d\\x18\\x23\\x29\\x18\\x3f\\x3f\\x3f\\x3f\\x3f\\x39\\x3f\\x3f\\x31\\x3f\\x3f\"\n    b\"\\x2a\\x3f\\x3f\\x20\\x3f\\x3f\\x14\\x3f\\x3c\\x12\\x3f\\x39\\x0f\\x3f\\x35\\x0b\"\n    b\"\\x3f\\x32\\x07\\x3f\\x2d\\x01\\x3d\\x2a\\x01\\x3b\\x26\\x01\\x39\\x21\\x01\\x37\"\n    b\"\\x1d\\x01\\x34\\x1a\\x01\\x32\\x16\\x01\\x2f\\x12\\x01\\x2d\\x0f\\x01\\x2a\\x0b\"\n    b\"\\x01\\x27\\x07\\x01\\x23\\x01\\x01\\x1d\\x01\\x01\\x17\\x01\\x01\\x10\\x01\\x01\"\n    b\"\\x3d\\x01\\x01\\x19\\x19\\x3f\\x3f\\x01\\x01\\x01\\x01\\x3f\\x16\\x16\\x13\\x10\"\n    b\"\\x10\\x0f\\x0d\\x0d\\x0b\\x3c\\x2e\\x2a\\x36\\x27\\x20\\x30\\x21\\x18\\x29\\x1b\"\n    b\"\\x10\\x3c\\x39\\x37\\x37\\x32\\x2f\\x31\\x2c\\x28\\x2b\\x26\\x21\\x30\\x22\\x20\"\n)\n", "src/PIL/DcxImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# DCX file handling\n#\n# DCX is a container file format defined by Intel, commonly used\n# for fax applications.  Each DCX file consists of a directory\n# (a list of file offsets) followed by a set of (usually 1-bit)\n# PCX files.\n#\n# History:\n# 1995-09-09 fl   Created\n# 1996-03-20 fl   Properly derived from PcxImageFile.\n# 1998-07-15 fl   Renamed offset attribute to avoid name clash\n# 2002-07-30 fl   Fixed file handling\n#\n# Copyright (c) 1997-98 by Secret Labs AB.\n# Copyright (c) 1995-96 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image\nfrom ._binary import i32le as i32\nfrom .PcxImagePlugin import PcxImageFile\n\nMAGIC = 0x3ADE68B1  # QUIZ: what's this value, then?\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 4 and i32(prefix) == MAGIC\n\n\n##\n# Image plugin for the Intel DCX format.\n\n\nclass DcxImageFile(PcxImageFile):\n    format = \"DCX\"\n    format_description = \"Intel DCX\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # Header\n        s = self.fp.read(4)\n        if not _accept(s):\n            msg = \"not a DCX file\"\n            raise SyntaxError(msg)\n\n        # Component directory\n        self._offset = []\n        for i in range(1024):\n            offset = i32(self.fp.read(4))\n            if not offset:\n                break\n            self._offset.append(offset)\n\n        self._fp = self.fp\n        self.frame = -1\n        self.n_frames = len(self._offset)\n        self.is_animated = self.n_frames > 1\n        self.seek(0)\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        self.frame = frame\n        self.fp = self._fp\n        self.fp.seek(self._offset[frame])\n        PcxImageFile._open(self)\n\n    def tell(self) -> int:\n        return self.frame\n\n\nImage.register_open(DcxImageFile.format, DcxImageFile, _accept)\n\nImage.register_extension(DcxImageFile.format, \".dcx\")\n", "src/PIL/XpmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# XPM File handling\n#\n# History:\n# 1996-12-29 fl   Created\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.7)\n#\n# Copyright (c) Secret Labs AB 1997-2001.\n# Copyright (c) Fredrik Lundh 1996-2001.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import o8\n\n# XPM header\nxpm_head = re.compile(b'\"([0-9]*) ([0-9]*) ([0-9]*) ([0-9]*)')\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:9] == b\"/* XPM */\"\n\n\n##\n# Image plugin for X11 pixel maps.\n\n\nclass XpmImageFile(ImageFile.ImageFile):\n    format = \"XPM\"\n    format_description = \"X11 Pixel Map\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(9)):\n            msg = \"not an XPM file\"\n            raise SyntaxError(msg)\n\n        # skip forward to next string\n        while True:\n            s = self.fp.readline()\n            if not s:\n                msg = \"broken XPM file\"\n                raise SyntaxError(msg)\n            m = xpm_head.match(s)\n            if m:\n                break\n\n        self._size = int(m.group(1)), int(m.group(2))\n\n        pal = int(m.group(3))\n        bpp = int(m.group(4))\n\n        if pal > 256 or bpp != 1:\n            msg = \"cannot read this XPM file\"\n            raise ValueError(msg)\n\n        #\n        # load palette description\n\n        palette = [b\"\\0\\0\\0\"] * 256\n\n        for _ in range(pal):\n            s = self.fp.readline()\n            if s[-2:] == b\"\\r\\n\":\n                s = s[:-2]\n            elif s[-1:] in b\"\\r\\n\":\n                s = s[:-1]\n\n            c = s[1]\n            s = s[2:-2].split()\n\n            for i in range(0, len(s), 2):\n                if s[i] == b\"c\":\n                    # process colour key\n                    rgb = s[i + 1]\n                    if rgb == b\"None\":\n                        self.info[\"transparency\"] = c\n                    elif rgb[:1] == b\"#\":\n                        # FIXME: handle colour names (see ImagePalette.py)\n                        rgb = int(rgb[1:], 16)\n                        palette[c] = (\n                            o8((rgb >> 16) & 255) + o8((rgb >> 8) & 255) + o8(rgb & 255)\n                        )\n                    else:\n                        # unknown colour\n                        msg = \"cannot read this XPM file\"\n                        raise ValueError(msg)\n                    break\n\n            else:\n                # missing colour key\n                msg = \"cannot read this XPM file\"\n                raise ValueError(msg)\n\n        self._mode = \"P\"\n        self.palette = ImagePalette.raw(\"RGB\", b\"\".join(palette))\n\n        self.tile = [(\"raw\", (0, 0) + self.size, self.fp.tell(), (\"P\", 0, 1))]\n\n    def load_read(self, read_bytes: int) -> bytes:\n        #\n        # load all image data in one chunk\n\n        xsize, ysize = self.size\n\n        s = [self.fp.readline()[1 : xsize + 1].ljust(xsize) for i in range(ysize)]\n\n        return b\"\".join(s)\n\n\n#\n# Registry\n\n\nImage.register_open(XpmImageFile.format, XpmImageFile, _accept)\n\nImage.register_extension(XpmImageFile.format, \".xpm\")\n\nImage.register_mime(XpmImageFile.format, \"image/xpm\")\n", "src/PIL/McIdasImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Basic McIdas support for PIL\n#\n# History:\n# 1997-05-05 fl  Created (8-bit images only)\n# 2009-03-08 fl  Added 16/32-bit support.\n#\n# Thanks to Richard Jones and Craig Swank for specs and samples.\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport struct\n\nfrom . import Image, ImageFile\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == b\"\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x04\"\n\n\n##\n# Image plugin for McIdas area images.\n\n\nclass McIdasImageFile(ImageFile.ImageFile):\n    format = \"MCIDAS\"\n    format_description = \"McIdas area file\"\n\n    def _open(self) -> None:\n        # parse area file directory\n        assert self.fp is not None\n\n        s = self.fp.read(256)\n        if not _accept(s) or len(s) != 256:\n            msg = \"not an McIdas area file\"\n            raise SyntaxError(msg)\n\n        self.area_descriptor_raw = s\n        self.area_descriptor = w = [0] + list(struct.unpack(\"!64i\", s))\n\n        # get mode\n        if w[11] == 1:\n            mode = rawmode = \"L\"\n        elif w[11] == 2:\n            # FIXME: add memory map support\n            mode = \"I\"\n            rawmode = \"I;16B\"\n        elif w[11] == 4:\n            # FIXME: add memory map support\n            mode = \"I\"\n            rawmode = \"I;32B\"\n        else:\n            msg = \"unsupported McIdas format\"\n            raise SyntaxError(msg)\n\n        self._mode = mode\n        self._size = w[10], w[9]\n\n        offset = w[34] + w[15]\n        stride = w[15] + w[10] * w[11] * w[14]\n\n        self.tile = [(\"raw\", (0, 0) + self.size, offset, (rawmode, stride, 1))]\n\n\n# --------------------------------------------------------------------\n# registry\n\nImage.register_open(McIdasImageFile.format, McIdasImageFile, _accept)\n\n# no default extension\n", "src/PIL/GribStubImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# GRIB stub adapter\n#\n# Copyright (c) 1996-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific GRIB image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\n# --------------------------------------------------------------------\n# Image adapter\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"GRIB\" and prefix[7] == 1\n\n\nclass GribStubImageFile(ImageFile.StubImageFile):\n    format = \"GRIB\"\n    format_description = \"GRIB\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        if not _accept(self.fp.read(8)):\n            msg = \"Not a GRIB file\"\n            raise SyntaxError(msg)\n\n        self.fp.seek(offset)\n\n        # make something up\n        self._mode = \"F\"\n        self._size = 1, 1\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"GRIB save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(GribStubImageFile.format, GribStubImageFile, _accept)\nImage.register_save(GribStubImageFile.format, _save)\n\nImage.register_extension(GribStubImageFile.format, \".grib\")\n", "src/PIL/ImageFile.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# base class for image file handlers\n#\n# history:\n# 1995-09-09 fl   Created\n# 1996-03-11 fl   Fixed load mechanism.\n# 1996-04-15 fl   Added pcx/xbm decoders.\n# 1996-04-30 fl   Added encoders.\n# 1996-12-14 fl   Added load helpers\n# 1997-01-11 fl   Use encode_to_file where possible\n# 1997-08-27 fl   Flush output in _save\n# 1998-03-05 fl   Use memory mapping for some modes\n# 1999-02-04 fl   Use memory mapping also for \"I;16\" and \"I;16B\"\n# 1999-05-31 fl   Added image parser\n# 2000-10-12 fl   Set readonly flag on memory-mapped images\n# 2002-03-20 fl   Use better messages for common decoder errors\n# 2003-04-21 fl   Fall back on mmap/map_buffer if map is not available\n# 2003-10-30 fl   Added StubImageFile class\n# 2004-02-25 fl   Made incremental parser more robust\n#\n# Copyright (c) 1997-2004 by Secret Labs AB\n# Copyright (c) 1995-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport abc\nimport io\nimport itertools\nimport struct\nimport sys\nfrom typing import IO, Any, NamedTuple\n\nfrom . import Image\nfrom ._deprecate import deprecate\nfrom ._util import is_path\n\nMAXBLOCK = 65536\n\nSAFEBLOCK = 1024 * 1024\n\nLOAD_TRUNCATED_IMAGES = False\n\"\"\"Whether or not to load truncated image files. User code may change this.\"\"\"\n\nERRORS = {\n    -1: \"image buffer overrun error\",\n    -2: \"decoding error\",\n    -3: \"unknown error\",\n    -8: \"bad configuration\",\n    -9: \"out of memory error\",\n}\n\"\"\"\nDict of known error codes returned from :meth:`.PyDecoder.decode`,\n:meth:`.PyEncoder.encode` :meth:`.PyEncoder.encode_to_pyfd` and\n:meth:`.PyEncoder.encode_to_file`.\n\"\"\"\n\n\n#\n# --------------------------------------------------------------------\n# Helpers\n\n\ndef _get_oserror(error, *, encoder):\n    try:\n        msg = Image.core.getcodecstatus(error)\n    except AttributeError:\n        msg = ERRORS.get(error)\n    if not msg:\n        msg = f\"{'encoder' if encoder else 'decoder'} error {error}\"\n    msg += f\" when {'writing' if encoder else 'reading'} image file\"\n    return OSError(msg)\n\n\ndef raise_oserror(error):\n    deprecate(\n        \"raise_oserror\",\n        12,\n        action=\"It is only useful for translating error codes returned by a codec's \"\n        \"decode() method, which ImageFile already does automatically.\",\n    )\n    raise _get_oserror(error, encoder=False)\n\n\ndef _tilesort(t):\n    # sort on offset\n    return t[2]\n\n\nclass _Tile(NamedTuple):\n    codec_name: str\n    extents: tuple[int, int, int, int]\n    offset: int\n    args: tuple[Any, ...] | str | None\n\n\n#\n# --------------------------------------------------------------------\n# ImageFile base class\n\n\nclass ImageFile(Image.Image):\n    \"\"\"Base class for image file format handlers.\"\"\"\n\n    def __init__(self, fp=None, filename=None):\n        super().__init__()\n\n        self._min_frame = 0\n\n        self.custom_mimetype = None\n\n        self.tile = None\n        \"\"\" A list of tile descriptors, or ``None`` \"\"\"\n\n        self.readonly = 1  # until we know better\n\n        self.decoderconfig = ()\n        self.decodermaxblock = MAXBLOCK\n\n        if is_path(fp):\n            # filename\n            self.fp = open(fp, \"rb\")\n            self.filename = fp\n            self._exclusive_fp = True\n        else:\n            # stream\n            self.fp = fp\n            self.filename = filename\n            # can be overridden\n            self._exclusive_fp = None\n\n        try:\n            try:\n                self._open()\n            except (\n                IndexError,  # end of data\n                TypeError,  # end of data (ord)\n                KeyError,  # unsupported mode\n                EOFError,  # got header but not the first frame\n                struct.error,\n            ) as v:\n                raise SyntaxError(v) from v\n\n            if not self.mode or self.size[0] <= 0 or self.size[1] <= 0:\n                msg = \"not identified by this driver\"\n                raise SyntaxError(msg)\n        except BaseException:\n            # close the file only if we have opened it this constructor\n            if self._exclusive_fp:\n                self.fp.close()\n            raise\n\n    def get_format_mimetype(self):\n        if self.custom_mimetype:\n            return self.custom_mimetype\n        if self.format is not None:\n            return Image.MIME.get(self.format.upper())\n\n    def __setstate__(self, state):\n        self.tile = []\n        super().__setstate__(state)\n\n    def verify(self) -> None:\n        \"\"\"Check file integrity\"\"\"\n\n        # raise exception if something's wrong.  must be called\n        # directly after open, and closes file when finished.\n        if self._exclusive_fp:\n            self.fp.close()\n        self.fp = None\n\n    def load(self):\n        \"\"\"Load image data based on tile list\"\"\"\n\n        if self.tile is None:\n            msg = \"cannot load this image\"\n            raise OSError(msg)\n\n        pixel = Image.Image.load(self)\n        if not self.tile:\n            return pixel\n\n        self.map = None\n        use_mmap = self.filename and len(self.tile) == 1\n        # As of pypy 2.1.0, memory mapping was failing here.\n        use_mmap = use_mmap and not hasattr(sys, \"pypy_version_info\")\n\n        readonly = 0\n\n        # look for read/seek overrides\n        try:\n            read = self.load_read\n            # don't use mmap if there are custom read/seek functions\n            use_mmap = False\n        except AttributeError:\n            read = self.fp.read\n\n        try:\n            seek = self.load_seek\n            use_mmap = False\n        except AttributeError:\n            seek = self.fp.seek\n\n        if use_mmap:\n            # try memory mapping\n            decoder_name, extents, offset, args = self.tile[0]\n            if isinstance(args, str):\n                args = (args, 0, 1)\n            if (\n                decoder_name == \"raw\"\n                and len(args) >= 3\n                and args[0] == self.mode\n                and args[0] in Image._MAPMODES\n            ):\n                try:\n                    # use mmap, if possible\n                    import mmap\n\n                    with open(self.filename) as fp:\n                        self.map = mmap.mmap(fp.fileno(), 0, access=mmap.ACCESS_READ)\n                    if offset + self.size[1] * args[1] > self.map.size():\n                        msg = \"buffer is not large enough\"\n                        raise OSError(msg)\n                    self.im = Image.core.map_buffer(\n                        self.map, self.size, decoder_name, offset, args\n                    )\n                    readonly = 1\n                    # After trashing self.im,\n                    # we might need to reload the palette data.\n                    if self.palette:\n                        self.palette.dirty = 1\n                except (AttributeError, OSError, ImportError):\n                    self.map = None\n\n        self.load_prepare()\n        err_code = -3  # initialize to unknown error\n        if not self.map:\n            # sort tiles in file order\n            self.tile.sort(key=_tilesort)\n\n            try:\n                # FIXME: This is a hack to handle TIFF's JpegTables tag.\n                prefix = self.tile_prefix\n            except AttributeError:\n                prefix = b\"\"\n\n            # Remove consecutive duplicates that only differ by their offset\n            self.tile = [\n                list(tiles)[-1]\n                for _, tiles in itertools.groupby(\n                    self.tile, lambda tile: (tile[0], tile[1], tile[3])\n                )\n            ]\n            for decoder_name, extents, offset, args in self.tile:\n                seek(offset)\n                decoder = Image._getdecoder(\n                    self.mode, decoder_name, args, self.decoderconfig\n                )\n                try:\n                    decoder.setimage(self.im, extents)\n                    if decoder.pulls_fd:\n                        decoder.setfd(self.fp)\n                        err_code = decoder.decode(b\"\")[1]\n                    else:\n                        b = prefix\n                        while True:\n                            try:\n                                s = read(self.decodermaxblock)\n                            except (IndexError, struct.error) as e:\n                                # truncated png/gif\n                                if LOAD_TRUNCATED_IMAGES:\n                                    break\n                                else:\n                                    msg = \"image file is truncated\"\n                                    raise OSError(msg) from e\n\n                            if not s:  # truncated jpeg\n                                if LOAD_TRUNCATED_IMAGES:\n                                    break\n                                else:\n                                    msg = (\n                                        \"image file is truncated \"\n                                        f\"({len(b)} bytes not processed)\"\n                                    )\n                                    raise OSError(msg)\n\n                            b = b + s\n                            n, err_code = decoder.decode(b)\n                            if n < 0:\n                                break\n                            b = b[n:]\n                finally:\n                    # Need to cleanup here to prevent leaks\n                    decoder.cleanup()\n\n        self.tile = []\n        self.readonly = readonly\n\n        self.load_end()\n\n        if self._exclusive_fp and self._close_exclusive_fp_after_loading:\n            self.fp.close()\n        self.fp = None\n\n        if not self.map and not LOAD_TRUNCATED_IMAGES and err_code < 0:\n            # still raised if decoder fails to return anything\n            raise _get_oserror(err_code, encoder=False)\n\n        return Image.Image.load(self)\n\n    def load_prepare(self) -> None:\n        # create image memory if necessary\n        if not self.im or self.im.mode != self.mode or self.im.size != self.size:\n            self.im = Image.core.new(self.mode, self.size)\n        # create palette (optional)\n        if self.mode == \"P\":\n            Image.Image.load(self)\n\n    def load_end(self) -> None:\n        # may be overridden\n        pass\n\n    # may be defined for contained formats\n    # def load_seek(self, pos: int) -> None:\n    #     pass\n\n    # may be defined for blocked formats (e.g. PNG)\n    # def load_read(self, read_bytes: int) -> bytes:\n    #     pass\n\n    def _seek_check(self, frame):\n        if (\n            frame < self._min_frame\n            # Only check upper limit on frames if additional seek operations\n            # are not required to do so\n            or (\n                not (hasattr(self, \"_n_frames\") and self._n_frames is None)\n                and frame >= self.n_frames + self._min_frame\n            )\n        ):\n            msg = \"attempt to seek outside sequence\"\n            raise EOFError(msg)\n\n        return self.tell() != frame\n\n\nclass StubHandler:\n    def open(self, im: StubImageFile) -> None:\n        pass\n\n    @abc.abstractmethod\n    def load(self, im: StubImageFile) -> Image.Image:\n        pass\n\n\nclass StubImageFile(ImageFile):\n    \"\"\"\n    Base class for stub image loaders.\n\n    A stub loader is an image loader that can identify files of a\n    certain format, but relies on external code to load the file.\n    \"\"\"\n\n    def _open(self):\n        msg = \"StubImageFile subclass must implement _open\"\n        raise NotImplementedError(msg)\n\n    def load(self):\n        loader = self._load()\n        if loader is None:\n            msg = f\"cannot find loader for this {self.format} file\"\n            raise OSError(msg)\n        image = loader.load(self)\n        assert image is not None\n        # become the other object (!)\n        self.__class__ = image.__class__\n        self.__dict__ = image.__dict__\n        return image.load()\n\n    def _load(self):\n        \"\"\"(Hook) Find actual image loader.\"\"\"\n        msg = \"StubImageFile subclass must implement _load\"\n        raise NotImplementedError(msg)\n\n\nclass Parser:\n    \"\"\"\n    Incremental image parser.  This class implements the standard\n    feed/close consumer interface.\n    \"\"\"\n\n    incremental = None\n    image: Image.Image | None = None\n    data = None\n    decoder = None\n    offset = 0\n    finished = 0\n\n    def reset(self) -> None:\n        \"\"\"\n        (Consumer) Reset the parser.  Note that you can only call this\n        method immediately after you've created a parser; parser\n        instances cannot be reused.\n        \"\"\"\n        assert self.data is None, \"cannot reuse parsers\"\n\n    def feed(self, data):\n        \"\"\"\n        (Consumer) Feed data to the parser.\n\n        :param data: A string buffer.\n        :exception OSError: If the parser failed to parse the image file.\n        \"\"\"\n        # collect data\n\n        if self.finished:\n            return\n\n        if self.data is None:\n            self.data = data\n        else:\n            self.data = self.data + data\n\n        # parse what we have\n        if self.decoder:\n            if self.offset > 0:\n                # skip header\n                skip = min(len(self.data), self.offset)\n                self.data = self.data[skip:]\n                self.offset = self.offset - skip\n                if self.offset > 0 or not self.data:\n                    return\n\n            n, e = self.decoder.decode(self.data)\n\n            if n < 0:\n                # end of stream\n                self.data = None\n                self.finished = 1\n                if e < 0:\n                    # decoding error\n                    self.image = None\n                    raise _get_oserror(e, encoder=False)\n                else:\n                    # end of image\n                    return\n            self.data = self.data[n:]\n\n        elif self.image:\n            # if we end up here with no decoder, this file cannot\n            # be incrementally parsed.  wait until we've gotten all\n            # available data\n            pass\n\n        else:\n            # attempt to open this file\n            try:\n                with io.BytesIO(self.data) as fp:\n                    im = Image.open(fp)\n            except OSError:\n                pass  # not enough data\n            else:\n                flag = hasattr(im, \"load_seek\") or hasattr(im, \"load_read\")\n                if flag or len(im.tile) != 1:\n                    # custom load code, or multiple tiles\n                    self.decode = None\n                else:\n                    # initialize decoder\n                    im.load_prepare()\n                    d, e, o, a = im.tile[0]\n                    im.tile = []\n                    self.decoder = Image._getdecoder(im.mode, d, a, im.decoderconfig)\n                    self.decoder.setimage(im.im, e)\n\n                    # calculate decoder offset\n                    self.offset = o\n                    if self.offset <= len(self.data):\n                        self.data = self.data[self.offset :]\n                        self.offset = 0\n\n                self.image = im\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def close(self):\n        \"\"\"\n        (Consumer) Close the stream.\n\n        :returns: An image object.\n        :exception OSError: If the parser failed to parse the image file either\n                            because it cannot be identified or cannot be\n                            decoded.\n        \"\"\"\n        # finish decoding\n        if self.decoder:\n            # get rid of what's left in the buffers\n            self.feed(b\"\")\n            self.data = self.decoder = None\n            if not self.finished:\n                msg = \"image was incomplete\"\n                raise OSError(msg)\n        if not self.image:\n            msg = \"cannot parse this image\"\n            raise OSError(msg)\n        if self.data:\n            # incremental parsing not possible; reopen the file\n            # not that we have all data\n            with io.BytesIO(self.data) as fp:\n                try:\n                    self.image = Image.open(fp)\n                finally:\n                    self.image.load()\n        return self.image\n\n\n# --------------------------------------------------------------------\n\n\ndef _save(im, fp, tile, bufsize=0) -> None:\n    \"\"\"Helper to save image based on tile list\n\n    :param im: Image object.\n    :param fp: File object.\n    :param tile: Tile list.\n    :param bufsize: Optional buffer size\n    \"\"\"\n\n    im.load()\n    if not hasattr(im, \"encoderconfig\"):\n        im.encoderconfig = ()\n    tile.sort(key=_tilesort)\n    # FIXME: make MAXBLOCK a configuration parameter\n    # It would be great if we could have the encoder specify what it needs\n    # But, it would need at least the image size in most cases. RawEncode is\n    # a tricky case.\n    bufsize = max(MAXBLOCK, bufsize, im.size[0] * 4)  # see RawEncode.c\n    try:\n        fh = fp.fileno()\n        fp.flush()\n        _encode_tile(im, fp, tile, bufsize, fh)\n    except (AttributeError, io.UnsupportedOperation) as exc:\n        _encode_tile(im, fp, tile, bufsize, None, exc)\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\ndef _encode_tile(im, fp, tile: list[_Tile], bufsize, fh, exc=None):\n    for encoder_name, extents, offset, args in tile:\n        if offset > 0:\n            fp.seek(offset)\n        encoder = Image._getencoder(im.mode, encoder_name, args, im.encoderconfig)\n        try:\n            encoder.setimage(im.im, extents)\n            if encoder.pushes_fd:\n                encoder.setfd(fp)\n                errcode = encoder.encode_to_pyfd()[1]\n            else:\n                if exc:\n                    # compress to Python file-compatible object\n                    while True:\n                        errcode, data = encoder.encode(bufsize)[1:]\n                        fp.write(data)\n                        if errcode:\n                            break\n                else:\n                    # slight speedup: compress to real file object\n                    errcode = encoder.encode_to_file(fh, bufsize)\n            if errcode < 0:\n                raise _get_oserror(errcode, encoder=True) from exc\n        finally:\n            encoder.cleanup()\n\n\ndef _safe_read(fp, size):\n    \"\"\"\n    Reads large blocks in a safe way.  Unlike fp.read(n), this function\n    doesn't trust the user.  If the requested size is larger than\n    SAFEBLOCK, the file is read block by block.\n\n    :param fp: File handle.  Must implement a <b>read</b> method.\n    :param size: Number of bytes to read.\n    :returns: A string containing <i>size</i> bytes of data.\n\n    Raises an OSError if the file is truncated and the read cannot be completed\n\n    \"\"\"\n    if size <= 0:\n        return b\"\"\n    if size <= SAFEBLOCK:\n        data = fp.read(size)\n        if len(data) < size:\n            msg = \"Truncated File Read\"\n            raise OSError(msg)\n        return data\n    data = []\n    remaining_size = size\n    while remaining_size > 0:\n        block = fp.read(min(remaining_size, SAFEBLOCK))\n        if not block:\n            break\n        data.append(block)\n        remaining_size -= len(block)\n    if sum(len(d) for d in data) < size:\n        msg = \"Truncated File Read\"\n        raise OSError(msg)\n    return b\"\".join(data)\n\n\nclass PyCodecState:\n    def __init__(self) -> None:\n        self.xsize = 0\n        self.ysize = 0\n        self.xoff = 0\n        self.yoff = 0\n\n    def extents(self):\n        return self.xoff, self.yoff, self.xoff + self.xsize, self.yoff + self.ysize\n\n\nclass PyCodec:\n    fd: IO[bytes] | None\n\n    def __init__(self, mode, *args):\n        self.im = None\n        self.state = PyCodecState()\n        self.fd = None\n        self.mode = mode\n        self.init(args)\n\n    def init(self, args):\n        \"\"\"\n        Override to perform codec specific initialization\n\n        :param args: Array of args items from the tile entry\n        :returns: None\n        \"\"\"\n        self.args = args\n\n    def cleanup(self) -> None:\n        \"\"\"\n        Override to perform codec specific cleanup\n\n        :returns: None\n        \"\"\"\n        pass\n\n    def setfd(self, fd):\n        \"\"\"\n        Called from ImageFile to set the Python file-like object\n\n        :param fd: A Python file-like object\n        :returns: None\n        \"\"\"\n        self.fd = fd\n\n    def setimage(self, im, extents=None):\n        \"\"\"\n        Called from ImageFile to set the core output image for the codec\n\n        :param im: A core image object\n        :param extents: a 4 tuple of (x0, y0, x1, y1) defining the rectangle\n            for this tile\n        :returns: None\n        \"\"\"\n\n        # following c code\n        self.im = im\n\n        if extents:\n            (x0, y0, x1, y1) = extents\n        else:\n            (x0, y0, x1, y1) = (0, 0, 0, 0)\n\n        if x0 == 0 and x1 == 0:\n            self.state.xsize, self.state.ysize = self.im.size\n        else:\n            self.state.xoff = x0\n            self.state.yoff = y0\n            self.state.xsize = x1 - x0\n            self.state.ysize = y1 - y0\n\n        if self.state.xsize <= 0 or self.state.ysize <= 0:\n            msg = \"Size cannot be negative\"\n            raise ValueError(msg)\n\n        if (\n            self.state.xsize + self.state.xoff > self.im.size[0]\n            or self.state.ysize + self.state.yoff > self.im.size[1]\n        ):\n            msg = \"Tile cannot extend outside image\"\n            raise ValueError(msg)\n\n\nclass PyDecoder(PyCodec):\n    \"\"\"\n    Python implementation of a format decoder. Override this class and\n    add the decoding logic in the :meth:`decode` method.\n\n    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`\n    \"\"\"\n\n    _pulls_fd = False\n\n    @property\n    def pulls_fd(self):\n        return self._pulls_fd\n\n    def decode(self, buffer):\n        \"\"\"\n        Override to perform the decoding process.\n\n        :param buffer: A bytes object with the data to be decoded.\n        :returns: A tuple of ``(bytes consumed, errcode)``.\n            If finished with decoding return -1 for the bytes consumed.\n            Err codes are from :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        msg = \"unavailable in base decoder\"\n        raise NotImplementedError(msg)\n\n    def set_as_raw(self, data: bytes, rawmode=None) -> None:\n        \"\"\"\n        Convenience method to set the internal image from a stream of raw data\n\n        :param data: Bytes to be set\n        :param rawmode: The rawmode to be used for the decoder.\n            If not specified, it will default to the mode of the image\n        :returns: None\n        \"\"\"\n\n        if not rawmode:\n            rawmode = self.mode\n        d = Image._getdecoder(self.mode, \"raw\", rawmode)\n        d.setimage(self.im, self.state.extents())\n        s = d.decode(data)\n\n        if s[0] >= 0:\n            msg = \"not enough image data\"\n            raise ValueError(msg)\n        if s[1] != 0:\n            msg = \"cannot decode image data\"\n            raise ValueError(msg)\n\n\nclass PyEncoder(PyCodec):\n    \"\"\"\n    Python implementation of a format encoder. Override this class and\n    add the decoding logic in the :meth:`encode` method.\n\n    See :ref:`Writing Your Own File Codec in Python<file-codecs-py>`\n    \"\"\"\n\n    _pushes_fd = False\n\n    @property\n    def pushes_fd(self):\n        return self._pushes_fd\n\n    def encode(self, bufsize: int) -> tuple[int, int, bytes]:\n        \"\"\"\n        Override to perform the encoding process.\n\n        :param bufsize: Buffer size.\n        :returns: A tuple of ``(bytes encoded, errcode, bytes)``.\n            If finished with encoding return 1 for the error code.\n            Err codes are from :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        msg = \"unavailable in base encoder\"\n        raise NotImplementedError(msg)\n\n    def encode_to_pyfd(self):\n        \"\"\"\n        If ``pushes_fd`` is ``True``, then this method will be used,\n        and ``encode()`` will only be called once.\n\n        :returns: A tuple of ``(bytes consumed, errcode)``.\n            Err codes are from :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        if not self.pushes_fd:\n            return 0, -8  # bad configuration\n        bytes_consumed, errcode, data = self.encode(0)\n        if data:\n            self.fd.write(data)\n        return bytes_consumed, errcode\n\n    def encode_to_file(self, fh, bufsize):\n        \"\"\"\n        :param fh: File handle.\n        :param bufsize: Buffer size.\n\n        :returns: If finished successfully, return 0.\n            Otherwise, return an error code. Err codes are from\n            :data:`.ImageFile.ERRORS`.\n        \"\"\"\n        errcode = 0\n        while errcode == 0:\n            status, errcode, buf = self.encode(bufsize)\n            if status > 0:\n                fh.write(buf[status:])\n        return errcode\n", "src/PIL/GimpGradientFile.py": "#\n# Python Imaging Library\n# $Id$\n#\n# stuff to read (and render) GIMP gradient files\n#\n# History:\n#       97-08-23 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nStuff to translate curve segments to palette values (derived from\nthe corresponding code in GIMP, written by Federico Mena Quintero.\nSee the GIMP distribution for more information.)\n\"\"\"\nfrom __future__ import annotations\n\nfrom math import log, pi, sin, sqrt\nfrom typing import IO, Callable\n\nfrom ._binary import o8\n\nEPSILON = 1e-10\n\"\"\"\"\"\"  # Enable auto-doc for data member\n\n\ndef linear(middle: float, pos: float) -> float:\n    if pos <= middle:\n        if middle < EPSILON:\n            return 0.0\n        else:\n            return 0.5 * pos / middle\n    else:\n        pos = pos - middle\n        middle = 1.0 - middle\n        if middle < EPSILON:\n            return 1.0\n        else:\n            return 0.5 + 0.5 * pos / middle\n\n\ndef curved(middle: float, pos: float) -> float:\n    return pos ** (log(0.5) / log(max(middle, EPSILON)))\n\n\ndef sine(middle: float, pos: float) -> float:\n    return (sin((-pi / 2.0) + pi * linear(middle, pos)) + 1.0) / 2.0\n\n\ndef sphere_increasing(middle: float, pos: float) -> float:\n    return sqrt(1.0 - (linear(middle, pos) - 1.0) ** 2)\n\n\ndef sphere_decreasing(middle: float, pos: float) -> float:\n    return 1.0 - sqrt(1.0 - linear(middle, pos) ** 2)\n\n\nSEGMENTS = [linear, curved, sine, sphere_increasing, sphere_decreasing]\n\"\"\"\"\"\"  # Enable auto-doc for data member\n\n\nclass GradientFile:\n    gradient: (\n        list[\n            tuple[\n                float,\n                float,\n                float,\n                list[float],\n                list[float],\n                Callable[[float, float], float],\n            ]\n        ]\n        | None\n    ) = None\n\n    def getpalette(self, entries: int = 256) -> tuple[bytes, str]:\n        assert self.gradient is not None\n        palette = []\n\n        ix = 0\n        x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n\n        for i in range(entries):\n            x = i / (entries - 1)\n\n            while x1 < x:\n                ix += 1\n                x0, x1, xm, rgb0, rgb1, segment = self.gradient[ix]\n\n            w = x1 - x0\n\n            if w < EPSILON:\n                scale = segment(0.5, 0.5)\n            else:\n                scale = segment((xm - x0) / w, (x - x0) / w)\n\n            # expand to RGBA\n            r = o8(int(255 * ((rgb1[0] - rgb0[0]) * scale + rgb0[0]) + 0.5))\n            g = o8(int(255 * ((rgb1[1] - rgb0[1]) * scale + rgb0[1]) + 0.5))\n            b = o8(int(255 * ((rgb1[2] - rgb0[2]) * scale + rgb0[2]) + 0.5))\n            a = o8(int(255 * ((rgb1[3] - rgb0[3]) * scale + rgb0[3]) + 0.5))\n\n            # add to palette\n            palette.append(r + g + b + a)\n\n        return b\"\".join(palette), \"RGBA\"\n\n\nclass GimpGradientFile(GradientFile):\n    \"\"\"File handler for GIMP's gradient format.\"\"\"\n\n    def __init__(self, fp: IO[bytes]) -> None:\n        if fp.readline()[:13] != b\"GIMP Gradient\":\n            msg = \"not a GIMP gradient file\"\n            raise SyntaxError(msg)\n\n        line = fp.readline()\n\n        # GIMP 1.2 gradient files don't contain a name, but GIMP 1.3 files do\n        if line.startswith(b\"Name: \"):\n            line = fp.readline().strip()\n\n        count = int(line)\n\n        self.gradient = []\n\n        for i in range(count):\n            s = fp.readline().split()\n            w = [float(x) for x in s[:11]]\n\n            x0, x1 = w[0], w[2]\n            xm = w[1]\n            rgb0 = w[3:7]\n            rgb1 = w[7:11]\n\n            segment = SEGMENTS[int(s[11])]\n            cspace = int(s[12])\n\n            if cspace != 0:\n                msg = \"cannot handle HSV colour space\"\n                raise OSError(msg)\n\n            self.gradient.append((x0, x1, xm, rgb0, rgb1, segment))\n", "src/PIL/DdsImagePlugin.py": "\"\"\"\nA Pillow loader for .dds files (S3TC-compressed aka DXTC)\nJerome Leclanche <jerome@leclan.ch>\n\nDocumentation:\nhttps://web.archive.org/web/20170802060935/http://oss.sgi.com/projects/ogl-sample/registry/EXT/texture_compression_s3tc.txt\n\nThe contents of this file are hereby released in the public domain (CC0)\nFull text of the CC0 license:\nhttps://creativecommons.org/publicdomain/zero/1.0/\n\"\"\"\n\nfrom __future__ import annotations\n\nimport io\nimport struct\nimport sys\nfrom enum import IntEnum, IntFlag\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i32le as i32\nfrom ._binary import o8\nfrom ._binary import o32le as o32\n\n# Magic (\"DDS \")\nDDS_MAGIC = 0x20534444\n\n\n# DDS flags\nclass DDSD(IntFlag):\n    CAPS = 0x1\n    HEIGHT = 0x2\n    WIDTH = 0x4\n    PITCH = 0x8\n    PIXELFORMAT = 0x1000\n    MIPMAPCOUNT = 0x20000\n    LINEARSIZE = 0x80000\n    DEPTH = 0x800000\n\n\n# DDS caps\nclass DDSCAPS(IntFlag):\n    COMPLEX = 0x8\n    TEXTURE = 0x1000\n    MIPMAP = 0x400000\n\n\nclass DDSCAPS2(IntFlag):\n    CUBEMAP = 0x200\n    CUBEMAP_POSITIVEX = 0x400\n    CUBEMAP_NEGATIVEX = 0x800\n    CUBEMAP_POSITIVEY = 0x1000\n    CUBEMAP_NEGATIVEY = 0x2000\n    CUBEMAP_POSITIVEZ = 0x4000\n    CUBEMAP_NEGATIVEZ = 0x8000\n    VOLUME = 0x200000\n\n\n# Pixel Format\nclass DDPF(IntFlag):\n    ALPHAPIXELS = 0x1\n    ALPHA = 0x2\n    FOURCC = 0x4\n    PALETTEINDEXED8 = 0x20\n    RGB = 0x40\n    LUMINANCE = 0x20000\n\n\n# dxgiformat.h\nclass DXGI_FORMAT(IntEnum):\n    UNKNOWN = 0\n    R32G32B32A32_TYPELESS = 1\n    R32G32B32A32_FLOAT = 2\n    R32G32B32A32_UINT = 3\n    R32G32B32A32_SINT = 4\n    R32G32B32_TYPELESS = 5\n    R32G32B32_FLOAT = 6\n    R32G32B32_UINT = 7\n    R32G32B32_SINT = 8\n    R16G16B16A16_TYPELESS = 9\n    R16G16B16A16_FLOAT = 10\n    R16G16B16A16_UNORM = 11\n    R16G16B16A16_UINT = 12\n    R16G16B16A16_SNORM = 13\n    R16G16B16A16_SINT = 14\n    R32G32_TYPELESS = 15\n    R32G32_FLOAT = 16\n    R32G32_UINT = 17\n    R32G32_SINT = 18\n    R32G8X24_TYPELESS = 19\n    D32_FLOAT_S8X24_UINT = 20\n    R32_FLOAT_X8X24_TYPELESS = 21\n    X32_TYPELESS_G8X24_UINT = 22\n    R10G10B10A2_TYPELESS = 23\n    R10G10B10A2_UNORM = 24\n    R10G10B10A2_UINT = 25\n    R11G11B10_FLOAT = 26\n    R8G8B8A8_TYPELESS = 27\n    R8G8B8A8_UNORM = 28\n    R8G8B8A8_UNORM_SRGB = 29\n    R8G8B8A8_UINT = 30\n    R8G8B8A8_SNORM = 31\n    R8G8B8A8_SINT = 32\n    R16G16_TYPELESS = 33\n    R16G16_FLOAT = 34\n    R16G16_UNORM = 35\n    R16G16_UINT = 36\n    R16G16_SNORM = 37\n    R16G16_SINT = 38\n    R32_TYPELESS = 39\n    D32_FLOAT = 40\n    R32_FLOAT = 41\n    R32_UINT = 42\n    R32_SINT = 43\n    R24G8_TYPELESS = 44\n    D24_UNORM_S8_UINT = 45\n    R24_UNORM_X8_TYPELESS = 46\n    X24_TYPELESS_G8_UINT = 47\n    R8G8_TYPELESS = 48\n    R8G8_UNORM = 49\n    R8G8_UINT = 50\n    R8G8_SNORM = 51\n    R8G8_SINT = 52\n    R16_TYPELESS = 53\n    R16_FLOAT = 54\n    D16_UNORM = 55\n    R16_UNORM = 56\n    R16_UINT = 57\n    R16_SNORM = 58\n    R16_SINT = 59\n    R8_TYPELESS = 60\n    R8_UNORM = 61\n    R8_UINT = 62\n    R8_SNORM = 63\n    R8_SINT = 64\n    A8_UNORM = 65\n    R1_UNORM = 66\n    R9G9B9E5_SHAREDEXP = 67\n    R8G8_B8G8_UNORM = 68\n    G8R8_G8B8_UNORM = 69\n    BC1_TYPELESS = 70\n    BC1_UNORM = 71\n    BC1_UNORM_SRGB = 72\n    BC2_TYPELESS = 73\n    BC2_UNORM = 74\n    BC2_UNORM_SRGB = 75\n    BC3_TYPELESS = 76\n    BC3_UNORM = 77\n    BC3_UNORM_SRGB = 78\n    BC4_TYPELESS = 79\n    BC4_UNORM = 80\n    BC4_SNORM = 81\n    BC5_TYPELESS = 82\n    BC5_UNORM = 83\n    BC5_SNORM = 84\n    B5G6R5_UNORM = 85\n    B5G5R5A1_UNORM = 86\n    B8G8R8A8_UNORM = 87\n    B8G8R8X8_UNORM = 88\n    R10G10B10_XR_BIAS_A2_UNORM = 89\n    B8G8R8A8_TYPELESS = 90\n    B8G8R8A8_UNORM_SRGB = 91\n    B8G8R8X8_TYPELESS = 92\n    B8G8R8X8_UNORM_SRGB = 93\n    BC6H_TYPELESS = 94\n    BC6H_UF16 = 95\n    BC6H_SF16 = 96\n    BC7_TYPELESS = 97\n    BC7_UNORM = 98\n    BC7_UNORM_SRGB = 99\n    AYUV = 100\n    Y410 = 101\n    Y416 = 102\n    NV12 = 103\n    P010 = 104\n    P016 = 105\n    OPAQUE_420 = 106\n    YUY2 = 107\n    Y210 = 108\n    Y216 = 109\n    NV11 = 110\n    AI44 = 111\n    IA44 = 112\n    P8 = 113\n    A8P8 = 114\n    B4G4R4A4_UNORM = 115\n    P208 = 130\n    V208 = 131\n    V408 = 132\n    SAMPLER_FEEDBACK_MIN_MIP_OPAQUE = 189\n    SAMPLER_FEEDBACK_MIP_REGION_USED_OPAQUE = 190\n\n\nclass D3DFMT(IntEnum):\n    UNKNOWN = 0\n    R8G8B8 = 20\n    A8R8G8B8 = 21\n    X8R8G8B8 = 22\n    R5G6B5 = 23\n    X1R5G5B5 = 24\n    A1R5G5B5 = 25\n    A4R4G4B4 = 26\n    R3G3B2 = 27\n    A8 = 28\n    A8R3G3B2 = 29\n    X4R4G4B4 = 30\n    A2B10G10R10 = 31\n    A8B8G8R8 = 32\n    X8B8G8R8 = 33\n    G16R16 = 34\n    A2R10G10B10 = 35\n    A16B16G16R16 = 36\n    A8P8 = 40\n    P8 = 41\n    L8 = 50\n    A8L8 = 51\n    A4L4 = 52\n    V8U8 = 60\n    L6V5U5 = 61\n    X8L8V8U8 = 62\n    Q8W8V8U8 = 63\n    V16U16 = 64\n    A2W10V10U10 = 67\n    D16_LOCKABLE = 70\n    D32 = 71\n    D15S1 = 73\n    D24S8 = 75\n    D24X8 = 77\n    D24X4S4 = 79\n    D16 = 80\n    D32F_LOCKABLE = 82\n    D24FS8 = 83\n    D32_LOCKABLE = 84\n    S8_LOCKABLE = 85\n    L16 = 81\n    VERTEXDATA = 100\n    INDEX16 = 101\n    INDEX32 = 102\n    Q16W16V16U16 = 110\n    R16F = 111\n    G16R16F = 112\n    A16B16G16R16F = 113\n    R32F = 114\n    G32R32F = 115\n    A32B32G32R32F = 116\n    CxV8U8 = 117\n    A1 = 118\n    A2B10G10R10_XR_BIAS = 119\n    BINARYBUFFER = 199\n\n    UYVY = i32(b\"UYVY\")\n    R8G8_B8G8 = i32(b\"RGBG\")\n    YUY2 = i32(b\"YUY2\")\n    G8R8_G8B8 = i32(b\"GRGB\")\n    DXT1 = i32(b\"DXT1\")\n    DXT2 = i32(b\"DXT2\")\n    DXT3 = i32(b\"DXT3\")\n    DXT4 = i32(b\"DXT4\")\n    DXT5 = i32(b\"DXT5\")\n    DX10 = i32(b\"DX10\")\n    BC4S = i32(b\"BC4S\")\n    BC4U = i32(b\"BC4U\")\n    BC5S = i32(b\"BC5S\")\n    BC5U = i32(b\"BC5U\")\n    ATI1 = i32(b\"ATI1\")\n    ATI2 = i32(b\"ATI2\")\n    MULTI2_ARGB8 = i32(b\"MET1\")\n\n\n# Backward compatibility layer\nmodule = sys.modules[__name__]\nfor item in DDSD:\n    assert item.name is not None\n    setattr(module, f\"DDSD_{item.name}\", item.value)\nfor item1 in DDSCAPS:\n    assert item1.name is not None\n    setattr(module, f\"DDSCAPS_{item1.name}\", item1.value)\nfor item2 in DDSCAPS2:\n    assert item2.name is not None\n    setattr(module, f\"DDSCAPS2_{item2.name}\", item2.value)\nfor item3 in DDPF:\n    assert item3.name is not None\n    setattr(module, f\"DDPF_{item3.name}\", item3.value)\n\nDDS_FOURCC = DDPF.FOURCC\nDDS_RGB = DDPF.RGB\nDDS_RGBA = DDPF.RGB | DDPF.ALPHAPIXELS\nDDS_LUMINANCE = DDPF.LUMINANCE\nDDS_LUMINANCEA = DDPF.LUMINANCE | DDPF.ALPHAPIXELS\nDDS_ALPHA = DDPF.ALPHA\nDDS_PAL8 = DDPF.PALETTEINDEXED8\n\nDDS_HEADER_FLAGS_TEXTURE = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PIXELFORMAT\nDDS_HEADER_FLAGS_MIPMAP = DDSD.MIPMAPCOUNT\nDDS_HEADER_FLAGS_VOLUME = DDSD.DEPTH\nDDS_HEADER_FLAGS_PITCH = DDSD.PITCH\nDDS_HEADER_FLAGS_LINEARSIZE = DDSD.LINEARSIZE\n\nDDS_HEIGHT = DDSD.HEIGHT\nDDS_WIDTH = DDSD.WIDTH\n\nDDS_SURFACE_FLAGS_TEXTURE = DDSCAPS.TEXTURE\nDDS_SURFACE_FLAGS_MIPMAP = DDSCAPS.COMPLEX | DDSCAPS.MIPMAP\nDDS_SURFACE_FLAGS_CUBEMAP = DDSCAPS.COMPLEX\n\nDDS_CUBEMAP_POSITIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEX\nDDS_CUBEMAP_NEGATIVEX = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEX\nDDS_CUBEMAP_POSITIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEY\nDDS_CUBEMAP_NEGATIVEY = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEY\nDDS_CUBEMAP_POSITIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_POSITIVEZ\nDDS_CUBEMAP_NEGATIVEZ = DDSCAPS2.CUBEMAP | DDSCAPS2.CUBEMAP_NEGATIVEZ\n\nDXT1_FOURCC = D3DFMT.DXT1\nDXT3_FOURCC = D3DFMT.DXT3\nDXT5_FOURCC = D3DFMT.DXT5\n\nDXGI_FORMAT_R8G8B8A8_TYPELESS = DXGI_FORMAT.R8G8B8A8_TYPELESS\nDXGI_FORMAT_R8G8B8A8_UNORM = DXGI_FORMAT.R8G8B8A8_UNORM\nDXGI_FORMAT_R8G8B8A8_UNORM_SRGB = DXGI_FORMAT.R8G8B8A8_UNORM_SRGB\nDXGI_FORMAT_BC5_TYPELESS = DXGI_FORMAT.BC5_TYPELESS\nDXGI_FORMAT_BC5_UNORM = DXGI_FORMAT.BC5_UNORM\nDXGI_FORMAT_BC5_SNORM = DXGI_FORMAT.BC5_SNORM\nDXGI_FORMAT_BC6H_UF16 = DXGI_FORMAT.BC6H_UF16\nDXGI_FORMAT_BC6H_SF16 = DXGI_FORMAT.BC6H_SF16\nDXGI_FORMAT_BC7_TYPELESS = DXGI_FORMAT.BC7_TYPELESS\nDXGI_FORMAT_BC7_UNORM = DXGI_FORMAT.BC7_UNORM\nDXGI_FORMAT_BC7_UNORM_SRGB = DXGI_FORMAT.BC7_UNORM_SRGB\n\n\nclass DdsImageFile(ImageFile.ImageFile):\n    format = \"DDS\"\n    format_description = \"DirectDraw Surface\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(4)):\n            msg = \"not a DDS file\"\n            raise SyntaxError(msg)\n        (header_size,) = struct.unpack(\"<I\", self.fp.read(4))\n        if header_size != 124:\n            msg = f\"Unsupported header size {repr(header_size)}\"\n            raise OSError(msg)\n        header_bytes = self.fp.read(header_size - 4)\n        if len(header_bytes) != 120:\n            msg = f\"Incomplete header: {len(header_bytes)} bytes\"\n            raise OSError(msg)\n        header = io.BytesIO(header_bytes)\n\n        flags, height, width = struct.unpack(\"<3I\", header.read(12))\n        self._size = (width, height)\n        extents = (0, 0) + self.size\n\n        pitch, depth, mipmaps = struct.unpack(\"<3I\", header.read(12))\n        struct.unpack(\"<11I\", header.read(44))  # reserved\n\n        # pixel format\n        pfsize, pfflags, fourcc, bitcount = struct.unpack(\"<4I\", header.read(16))\n        n = 0\n        rawmode = None\n        if pfflags & DDPF.RGB:\n            # Texture contains uncompressed RGB data\n            if pfflags & DDPF.ALPHAPIXELS:\n                self._mode = \"RGBA\"\n                mask_count = 4\n            else:\n                self._mode = \"RGB\"\n                mask_count = 3\n\n            masks = struct.unpack(f\"<{mask_count}I\", header.read(mask_count * 4))\n            self.tile = [(\"dds_rgb\", extents, 0, (bitcount, masks))]\n            return\n        elif pfflags & DDPF.LUMINANCE:\n            if bitcount == 8:\n                self._mode = \"L\"\n            elif bitcount == 16 and pfflags & DDPF.ALPHAPIXELS:\n                self._mode = \"LA\"\n            else:\n                msg = f\"Unsupported bitcount {bitcount} for {pfflags}\"\n                raise OSError(msg)\n        elif pfflags & DDPF.PALETTEINDEXED8:\n            self._mode = \"P\"\n            self.palette = ImagePalette.raw(\"RGBA\", self.fp.read(1024))\n            self.palette.mode = \"RGBA\"\n        elif pfflags & DDPF.FOURCC:\n            offset = header_size + 4\n            if fourcc == D3DFMT.DXT1:\n                self._mode = \"RGBA\"\n                self.pixel_format = \"DXT1\"\n                n = 1\n            elif fourcc == D3DFMT.DXT3:\n                self._mode = \"RGBA\"\n                self.pixel_format = \"DXT3\"\n                n = 2\n            elif fourcc == D3DFMT.DXT5:\n                self._mode = \"RGBA\"\n                self.pixel_format = \"DXT5\"\n                n = 3\n            elif fourcc in (D3DFMT.BC4U, D3DFMT.ATI1):\n                self._mode = \"L\"\n                self.pixel_format = \"BC4\"\n                n = 4\n            elif fourcc == D3DFMT.BC5S:\n                self._mode = \"RGB\"\n                self.pixel_format = \"BC5S\"\n                n = 5\n            elif fourcc in (D3DFMT.BC5U, D3DFMT.ATI2):\n                self._mode = \"RGB\"\n                self.pixel_format = \"BC5\"\n                n = 5\n            elif fourcc == D3DFMT.DX10:\n                offset += 20\n                # ignoring flags which pertain to volume textures and cubemaps\n                (dxgi_format,) = struct.unpack(\"<I\", self.fp.read(4))\n                self.fp.read(16)\n                if dxgi_format in (\n                    DXGI_FORMAT.BC1_UNORM,\n                    DXGI_FORMAT.BC1_TYPELESS,\n                ):\n                    self._mode = \"RGBA\"\n                    self.pixel_format = \"BC1\"\n                    n = 1\n                elif dxgi_format in (DXGI_FORMAT.BC4_TYPELESS, DXGI_FORMAT.BC4_UNORM):\n                    self._mode = \"L\"\n                    self.pixel_format = \"BC4\"\n                    n = 4\n                elif dxgi_format in (DXGI_FORMAT.BC5_TYPELESS, DXGI_FORMAT.BC5_UNORM):\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC5\"\n                    n = 5\n                elif dxgi_format == DXGI_FORMAT.BC5_SNORM:\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC5S\"\n                    n = 5\n                elif dxgi_format == DXGI_FORMAT.BC6H_UF16:\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC6H\"\n                    n = 6\n                elif dxgi_format == DXGI_FORMAT.BC6H_SF16:\n                    self._mode = \"RGB\"\n                    self.pixel_format = \"BC6HS\"\n                    n = 6\n                elif dxgi_format in (\n                    DXGI_FORMAT.BC7_TYPELESS,\n                    DXGI_FORMAT.BC7_UNORM,\n                    DXGI_FORMAT.BC7_UNORM_SRGB,\n                ):\n                    self._mode = \"RGBA\"\n                    self.pixel_format = \"BC7\"\n                    n = 7\n                    if dxgi_format == DXGI_FORMAT.BC7_UNORM_SRGB:\n                        self.info[\"gamma\"] = 1 / 2.2\n                elif dxgi_format in (\n                    DXGI_FORMAT.R8G8B8A8_TYPELESS,\n                    DXGI_FORMAT.R8G8B8A8_UNORM,\n                    DXGI_FORMAT.R8G8B8A8_UNORM_SRGB,\n                ):\n                    self._mode = \"RGBA\"\n                    if dxgi_format == DXGI_FORMAT.R8G8B8A8_UNORM_SRGB:\n                        self.info[\"gamma\"] = 1 / 2.2\n                else:\n                    msg = f\"Unimplemented DXGI format {dxgi_format}\"\n                    raise NotImplementedError(msg)\n            else:\n                msg = f\"Unimplemented pixel format {repr(fourcc)}\"\n                raise NotImplementedError(msg)\n        else:\n            msg = f\"Unknown pixel format flags {pfflags}\"\n            raise NotImplementedError(msg)\n\n        if n:\n            self.tile = [\n                ImageFile._Tile(\"bcn\", extents, offset, (n, self.pixel_format))\n            ]\n        else:\n            self.tile = [ImageFile._Tile(\"raw\", extents, 0, rawmode or self.mode)]\n\n    def load_seek(self, pos: int) -> None:\n        pass\n\n\nclass DdsRgbDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        bitcount, masks = self.args\n\n        # Some masks will be padded with zeros, e.g. R 0b11 G 0b1100\n        # Calculate how many zeros each mask is padded with\n        mask_offsets = []\n        # And the maximum value of each channel without the padding\n        mask_totals = []\n        for mask in masks:\n            offset = 0\n            if mask != 0:\n                while mask >> (offset + 1) << (offset + 1) == mask:\n                    offset += 1\n            mask_offsets.append(offset)\n            mask_totals.append(mask >> offset)\n\n        data = bytearray()\n        bytecount = bitcount // 8\n        dest_length = self.state.xsize * self.state.ysize * len(masks)\n        while len(data) < dest_length:\n            value = int.from_bytes(self.fd.read(bytecount), \"little\")\n            for i, mask in enumerate(masks):\n                masked_value = value & mask\n                # Remove the zero padding, and scale it to 8 bits\n                data += o8(\n                    int(((masked_value >> mask_offsets[i]) / mask_totals[i]) * 255)\n                )\n        self.set_as_raw(data)\n        return -1, 0\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode not in (\"RGB\", \"RGBA\", \"L\", \"LA\"):\n        msg = f\"cannot write mode {im.mode} as DDS\"\n        raise OSError(msg)\n\n    alpha = im.mode[-1] == \"A\"\n    if im.mode[0] == \"L\":\n        pixel_flags = DDPF.LUMINANCE\n        rawmode = im.mode\n        if alpha:\n            rgba_mask = [0x000000FF, 0x000000FF, 0x000000FF]\n        else:\n            rgba_mask = [0xFF000000, 0xFF000000, 0xFF000000]\n    else:\n        pixel_flags = DDPF.RGB\n        rawmode = im.mode[::-1]\n        rgba_mask = [0x00FF0000, 0x0000FF00, 0x000000FF]\n\n        if alpha:\n            r, g, b, a = im.split()\n            im = Image.merge(\"RGBA\", (a, r, g, b))\n    if alpha:\n        pixel_flags |= DDPF.ALPHAPIXELS\n    rgba_mask.append(0xFF000000 if alpha else 0)\n\n    flags = DDSD.CAPS | DDSD.HEIGHT | DDSD.WIDTH | DDSD.PITCH | DDSD.PIXELFORMAT\n    bitcount = len(im.getbands()) * 8\n    pitch = (im.width * bitcount + 7) // 8\n\n    fp.write(\n        o32(DDS_MAGIC)\n        + struct.pack(\n            \"<7I\",\n            124,  # header size\n            flags,  # flags\n            im.height,\n            im.width,\n            pitch,\n            0,  # depth\n            0,  # mipmaps\n        )\n        + struct.pack(\"11I\", *((0,) * 11))  # reserved\n        # pfsize, pfflags, fourcc, bitcount\n        + struct.pack(\"<4I\", 32, pixel_flags, 0, bitcount)\n        + struct.pack(\"<4I\", *rgba_mask)  # dwRGBABitMask\n        + struct.pack(\"<5I\", DDSCAPS.TEXTURE, 0, 0, 0, 0)\n    )\n    ImageFile._save(\n        im, fp, [ImageFile._Tile(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, 1))]\n    )\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"DDS \"\n\n\nImage.register_open(DdsImageFile.format, DdsImageFile, _accept)\nImage.register_decoder(\"dds_rgb\", DdsRgbDecoder)\nImage.register_save(DdsImageFile.format, _save)\nImage.register_extension(DdsImageFile.format, \".dds\")\n", "src/PIL/CurImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Windows Cursor support for PIL\n#\n# notes:\n#       uses BmpImagePlugin.py to read the bitmap data.\n#\n# history:\n#       96-05-27 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import BmpImagePlugin, Image\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\n\n#\n# --------------------------------------------------------------------\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"\\0\\0\\2\\0\"\n\n\n##\n# Image plugin for Windows Cursor files.\n\n\nclass CurImageFile(BmpImagePlugin.BmpImageFile):\n    format = \"CUR\"\n    format_description = \"Windows Cursor\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        # check magic\n        s = self.fp.read(6)\n        if not _accept(s):\n            msg = \"not a CUR file\"\n            raise SyntaxError(msg)\n\n        # pick the largest cursor in the file\n        m = b\"\"\n        for i in range(i16(s, 4)):\n            s = self.fp.read(16)\n            if not m:\n                m = s\n            elif s[0] > m[0] and s[1] > m[1]:\n                m = s\n        if not m:\n            msg = \"No cursors were found\"\n            raise TypeError(msg)\n\n        # load as bitmap\n        self._bitmap(i32(m, 12) + offset)\n\n        # patch up the bitmap height\n        self._size = self.size[0], self.size[1] // 2\n        d, e, o, a = self.tile[0]\n        self.tile[0] = d, (0, 0) + self.size, o, a\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(CurImageFile.format, CurImageFile, _accept)\n\nImage.register_extension(CurImageFile.format, \".cur\")\n", "src/PIL/ExifTags.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# EXIF tags\n#\n# Copyright (c) 2003 by Secret Labs AB\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nThis module provides constants and clear-text names for various\nwell-known EXIF tags.\n\"\"\"\nfrom __future__ import annotations\n\nfrom enum import IntEnum\n\n\nclass Base(IntEnum):\n    # possibly incomplete\n    InteropIndex = 0x0001\n    ProcessingSoftware = 0x000B\n    NewSubfileType = 0x00FE\n    SubfileType = 0x00FF\n    ImageWidth = 0x0100\n    ImageLength = 0x0101\n    BitsPerSample = 0x0102\n    Compression = 0x0103\n    PhotometricInterpretation = 0x0106\n    Thresholding = 0x0107\n    CellWidth = 0x0108\n    CellLength = 0x0109\n    FillOrder = 0x010A\n    DocumentName = 0x010D\n    ImageDescription = 0x010E\n    Make = 0x010F\n    Model = 0x0110\n    StripOffsets = 0x0111\n    Orientation = 0x0112\n    SamplesPerPixel = 0x0115\n    RowsPerStrip = 0x0116\n    StripByteCounts = 0x0117\n    MinSampleValue = 0x0118\n    MaxSampleValue = 0x0119\n    XResolution = 0x011A\n    YResolution = 0x011B\n    PlanarConfiguration = 0x011C\n    PageName = 0x011D\n    FreeOffsets = 0x0120\n    FreeByteCounts = 0x0121\n    GrayResponseUnit = 0x0122\n    GrayResponseCurve = 0x0123\n    T4Options = 0x0124\n    T6Options = 0x0125\n    ResolutionUnit = 0x0128\n    PageNumber = 0x0129\n    TransferFunction = 0x012D\n    Software = 0x0131\n    DateTime = 0x0132\n    Artist = 0x013B\n    HostComputer = 0x013C\n    Predictor = 0x013D\n    WhitePoint = 0x013E\n    PrimaryChromaticities = 0x013F\n    ColorMap = 0x0140\n    HalftoneHints = 0x0141\n    TileWidth = 0x0142\n    TileLength = 0x0143\n    TileOffsets = 0x0144\n    TileByteCounts = 0x0145\n    SubIFDs = 0x014A\n    InkSet = 0x014C\n    InkNames = 0x014D\n    NumberOfInks = 0x014E\n    DotRange = 0x0150\n    TargetPrinter = 0x0151\n    ExtraSamples = 0x0152\n    SampleFormat = 0x0153\n    SMinSampleValue = 0x0154\n    SMaxSampleValue = 0x0155\n    TransferRange = 0x0156\n    ClipPath = 0x0157\n    XClipPathUnits = 0x0158\n    YClipPathUnits = 0x0159\n    Indexed = 0x015A\n    JPEGTables = 0x015B\n    OPIProxy = 0x015F\n    JPEGProc = 0x0200\n    JpegIFOffset = 0x0201\n    JpegIFByteCount = 0x0202\n    JpegRestartInterval = 0x0203\n    JpegLosslessPredictors = 0x0205\n    JpegPointTransforms = 0x0206\n    JpegQTables = 0x0207\n    JpegDCTables = 0x0208\n    JpegACTables = 0x0209\n    YCbCrCoefficients = 0x0211\n    YCbCrSubSampling = 0x0212\n    YCbCrPositioning = 0x0213\n    ReferenceBlackWhite = 0x0214\n    XMLPacket = 0x02BC\n    RelatedImageFileFormat = 0x1000\n    RelatedImageWidth = 0x1001\n    RelatedImageLength = 0x1002\n    Rating = 0x4746\n    RatingPercent = 0x4749\n    ImageID = 0x800D\n    CFARepeatPatternDim = 0x828D\n    BatteryLevel = 0x828F\n    Copyright = 0x8298\n    ExposureTime = 0x829A\n    FNumber = 0x829D\n    IPTCNAA = 0x83BB\n    ImageResources = 0x8649\n    ExifOffset = 0x8769\n    InterColorProfile = 0x8773\n    ExposureProgram = 0x8822\n    SpectralSensitivity = 0x8824\n    GPSInfo = 0x8825\n    ISOSpeedRatings = 0x8827\n    OECF = 0x8828\n    Interlace = 0x8829\n    TimeZoneOffset = 0x882A\n    SelfTimerMode = 0x882B\n    SensitivityType = 0x8830\n    StandardOutputSensitivity = 0x8831\n    RecommendedExposureIndex = 0x8832\n    ISOSpeed = 0x8833\n    ISOSpeedLatitudeyyy = 0x8834\n    ISOSpeedLatitudezzz = 0x8835\n    ExifVersion = 0x9000\n    DateTimeOriginal = 0x9003\n    DateTimeDigitized = 0x9004\n    OffsetTime = 0x9010\n    OffsetTimeOriginal = 0x9011\n    OffsetTimeDigitized = 0x9012\n    ComponentsConfiguration = 0x9101\n    CompressedBitsPerPixel = 0x9102\n    ShutterSpeedValue = 0x9201\n    ApertureValue = 0x9202\n    BrightnessValue = 0x9203\n    ExposureBiasValue = 0x9204\n    MaxApertureValue = 0x9205\n    SubjectDistance = 0x9206\n    MeteringMode = 0x9207\n    LightSource = 0x9208\n    Flash = 0x9209\n    FocalLength = 0x920A\n    Noise = 0x920D\n    ImageNumber = 0x9211\n    SecurityClassification = 0x9212\n    ImageHistory = 0x9213\n    TIFFEPStandardID = 0x9216\n    MakerNote = 0x927C\n    UserComment = 0x9286\n    SubsecTime = 0x9290\n    SubsecTimeOriginal = 0x9291\n    SubsecTimeDigitized = 0x9292\n    AmbientTemperature = 0x9400\n    Humidity = 0x9401\n    Pressure = 0x9402\n    WaterDepth = 0x9403\n    Acceleration = 0x9404\n    CameraElevationAngle = 0x9405\n    XPTitle = 0x9C9B\n    XPComment = 0x9C9C\n    XPAuthor = 0x9C9D\n    XPKeywords = 0x9C9E\n    XPSubject = 0x9C9F\n    FlashPixVersion = 0xA000\n    ColorSpace = 0xA001\n    ExifImageWidth = 0xA002\n    ExifImageHeight = 0xA003\n    RelatedSoundFile = 0xA004\n    ExifInteroperabilityOffset = 0xA005\n    FlashEnergy = 0xA20B\n    SpatialFrequencyResponse = 0xA20C\n    FocalPlaneXResolution = 0xA20E\n    FocalPlaneYResolution = 0xA20F\n    FocalPlaneResolutionUnit = 0xA210\n    SubjectLocation = 0xA214\n    ExposureIndex = 0xA215\n    SensingMethod = 0xA217\n    FileSource = 0xA300\n    SceneType = 0xA301\n    CFAPattern = 0xA302\n    CustomRendered = 0xA401\n    ExposureMode = 0xA402\n    WhiteBalance = 0xA403\n    DigitalZoomRatio = 0xA404\n    FocalLengthIn35mmFilm = 0xA405\n    SceneCaptureType = 0xA406\n    GainControl = 0xA407\n    Contrast = 0xA408\n    Saturation = 0xA409\n    Sharpness = 0xA40A\n    DeviceSettingDescription = 0xA40B\n    SubjectDistanceRange = 0xA40C\n    ImageUniqueID = 0xA420\n    CameraOwnerName = 0xA430\n    BodySerialNumber = 0xA431\n    LensSpecification = 0xA432\n    LensMake = 0xA433\n    LensModel = 0xA434\n    LensSerialNumber = 0xA435\n    CompositeImage = 0xA460\n    CompositeImageCount = 0xA461\n    CompositeImageExposureTimes = 0xA462\n    Gamma = 0xA500\n    PrintImageMatching = 0xC4A5\n    DNGVersion = 0xC612\n    DNGBackwardVersion = 0xC613\n    UniqueCameraModel = 0xC614\n    LocalizedCameraModel = 0xC615\n    CFAPlaneColor = 0xC616\n    CFALayout = 0xC617\n    LinearizationTable = 0xC618\n    BlackLevelRepeatDim = 0xC619\n    BlackLevel = 0xC61A\n    BlackLevelDeltaH = 0xC61B\n    BlackLevelDeltaV = 0xC61C\n    WhiteLevel = 0xC61D\n    DefaultScale = 0xC61E\n    DefaultCropOrigin = 0xC61F\n    DefaultCropSize = 0xC620\n    ColorMatrix1 = 0xC621\n    ColorMatrix2 = 0xC622\n    CameraCalibration1 = 0xC623\n    CameraCalibration2 = 0xC624\n    ReductionMatrix1 = 0xC625\n    ReductionMatrix2 = 0xC626\n    AnalogBalance = 0xC627\n    AsShotNeutral = 0xC628\n    AsShotWhiteXY = 0xC629\n    BaselineExposure = 0xC62A\n    BaselineNoise = 0xC62B\n    BaselineSharpness = 0xC62C\n    BayerGreenSplit = 0xC62D\n    LinearResponseLimit = 0xC62E\n    CameraSerialNumber = 0xC62F\n    LensInfo = 0xC630\n    ChromaBlurRadius = 0xC631\n    AntiAliasStrength = 0xC632\n    ShadowScale = 0xC633\n    DNGPrivateData = 0xC634\n    MakerNoteSafety = 0xC635\n    CalibrationIlluminant1 = 0xC65A\n    CalibrationIlluminant2 = 0xC65B\n    BestQualityScale = 0xC65C\n    RawDataUniqueID = 0xC65D\n    OriginalRawFileName = 0xC68B\n    OriginalRawFileData = 0xC68C\n    ActiveArea = 0xC68D\n    MaskedAreas = 0xC68E\n    AsShotICCProfile = 0xC68F\n    AsShotPreProfileMatrix = 0xC690\n    CurrentICCProfile = 0xC691\n    CurrentPreProfileMatrix = 0xC692\n    ColorimetricReference = 0xC6BF\n    CameraCalibrationSignature = 0xC6F3\n    ProfileCalibrationSignature = 0xC6F4\n    AsShotProfileName = 0xC6F6\n    NoiseReductionApplied = 0xC6F7\n    ProfileName = 0xC6F8\n    ProfileHueSatMapDims = 0xC6F9\n    ProfileHueSatMapData1 = 0xC6FA\n    ProfileHueSatMapData2 = 0xC6FB\n    ProfileToneCurve = 0xC6FC\n    ProfileEmbedPolicy = 0xC6FD\n    ProfileCopyright = 0xC6FE\n    ForwardMatrix1 = 0xC714\n    ForwardMatrix2 = 0xC715\n    PreviewApplicationName = 0xC716\n    PreviewApplicationVersion = 0xC717\n    PreviewSettingsName = 0xC718\n    PreviewSettingsDigest = 0xC719\n    PreviewColorSpace = 0xC71A\n    PreviewDateTime = 0xC71B\n    RawImageDigest = 0xC71C\n    OriginalRawFileDigest = 0xC71D\n    SubTileBlockSize = 0xC71E\n    RowInterleaveFactor = 0xC71F\n    ProfileLookTableDims = 0xC725\n    ProfileLookTableData = 0xC726\n    OpcodeList1 = 0xC740\n    OpcodeList2 = 0xC741\n    OpcodeList3 = 0xC74E\n    NoiseProfile = 0xC761\n\n\n\"\"\"Maps EXIF tags to tag names.\"\"\"\nTAGS = {\n    **{i.value: i.name for i in Base},\n    0x920C: \"SpatialFrequencyResponse\",\n    0x9214: \"SubjectLocation\",\n    0x9215: \"ExposureIndex\",\n    0x828E: \"CFAPattern\",\n    0x920B: \"FlashEnergy\",\n    0x9216: \"TIFF/EPStandardID\",\n}\n\n\nclass GPS(IntEnum):\n    GPSVersionID = 0\n    GPSLatitudeRef = 1\n    GPSLatitude = 2\n    GPSLongitudeRef = 3\n    GPSLongitude = 4\n    GPSAltitudeRef = 5\n    GPSAltitude = 6\n    GPSTimeStamp = 7\n    GPSSatellites = 8\n    GPSStatus = 9\n    GPSMeasureMode = 10\n    GPSDOP = 11\n    GPSSpeedRef = 12\n    GPSSpeed = 13\n    GPSTrackRef = 14\n    GPSTrack = 15\n    GPSImgDirectionRef = 16\n    GPSImgDirection = 17\n    GPSMapDatum = 18\n    GPSDestLatitudeRef = 19\n    GPSDestLatitude = 20\n    GPSDestLongitudeRef = 21\n    GPSDestLongitude = 22\n    GPSDestBearingRef = 23\n    GPSDestBearing = 24\n    GPSDestDistanceRef = 25\n    GPSDestDistance = 26\n    GPSProcessingMethod = 27\n    GPSAreaInformation = 28\n    GPSDateStamp = 29\n    GPSDifferential = 30\n    GPSHPositioningError = 31\n\n\n\"\"\"Maps EXIF GPS tags to tag names.\"\"\"\nGPSTAGS = {i.value: i.name for i in GPS}\n\n\nclass Interop(IntEnum):\n    InteropIndex = 1\n    InteropVersion = 2\n    RelatedImageFileFormat = 4096\n    RelatedImageWidth = 4097\n    RelatedImageHeight = 4098\n\n\nclass IFD(IntEnum):\n    Exif = 34665\n    GPSInfo = 34853\n    Makernote = 37500\n    Interop = 40965\n    IFD1 = -1\n\n\nclass LightSource(IntEnum):\n    Unknown = 0\n    Daylight = 1\n    Fluorescent = 2\n    Tungsten = 3\n    Flash = 4\n    Fine = 9\n    Cloudy = 10\n    Shade = 11\n    DaylightFluorescent = 12\n    DayWhiteFluorescent = 13\n    CoolWhiteFluorescent = 14\n    WhiteFluorescent = 15\n    StandardLightA = 17\n    StandardLightB = 18\n    StandardLightC = 19\n    D55 = 20\n    D65 = 21\n    D75 = 22\n    D50 = 23\n    ISO = 24\n    Other = 255\n", "src/PIL/FpxImagePlugin.py": "#\n# THIS IS WORK IN PROGRESS\n#\n# The Python Imaging Library.\n# $Id$\n#\n# FlashPix support for PIL\n#\n# History:\n# 97-01-25 fl   Created (reads uncompressed RGB images only)\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport olefile\n\nfrom . import Image, ImageFile\nfrom ._binary import i32le as i32\n\n# we map from colour field tuples to (mode, rawmode) descriptors\nMODES = {\n    # opacity\n    (0x00007FFE,): (\"A\", \"L\"),\n    # monochrome\n    (0x00010000,): (\"L\", \"L\"),\n    (0x00018000, 0x00017FFE): (\"RGBA\", \"LA\"),\n    # photo YCC\n    (0x00020000, 0x00020001, 0x00020002): (\"RGB\", \"YCC;P\"),\n    (0x00028000, 0x00028001, 0x00028002, 0x00027FFE): (\"RGBA\", \"YCCA;P\"),\n    # standard RGB (NIFRGB)\n    (0x00030000, 0x00030001, 0x00030002): (\"RGB\", \"RGB\"),\n    (0x00038000, 0x00038001, 0x00038002, 0x00037FFE): (\"RGBA\", \"RGBA\"),\n}\n\n\n#\n# --------------------------------------------------------------------\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == olefile.MAGIC\n\n\n##\n# Image plugin for the FlashPix images.\n\n\nclass FpxImageFile(ImageFile.ImageFile):\n    format = \"FPX\"\n    format_description = \"FlashPix\"\n\n    def _open(self):\n        #\n        # read the OLE directory and see if this is a likely\n        # to be a FlashPix file\n\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except OSError as e:\n            msg = \"not an FPX file; invalid OLE file\"\n            raise SyntaxError(msg) from e\n\n        if self.ole.root.clsid != \"56616700-C154-11CE-8553-00AA00A1F95B\":\n            msg = \"not an FPX file; bad root CLSID\"\n            raise SyntaxError(msg)\n\n        self._open_index(1)\n\n    def _open_index(self, index: int = 1) -> None:\n        #\n        # get the Image Contents Property Set\n\n        prop = self.ole.getproperties(\n            [f\"Data Object Store {index:06d}\", \"\\005Image Contents\"]\n        )\n\n        # size (highest resolution)\n\n        self._size = prop[0x1000002], prop[0x1000003]\n\n        size = max(self.size)\n        i = 1\n        while size > 64:\n            size = size // 2\n            i += 1\n        self.maxid = i - 1\n\n        # mode.  instead of using a single field for this, flashpix\n        # requires you to specify the mode for each channel in each\n        # resolution subimage, and leaves it to the decoder to make\n        # sure that they all match.  for now, we'll cheat and assume\n        # that this is always the case.\n\n        id = self.maxid << 16\n\n        s = prop[0x2000002 | id]\n\n        bands = i32(s, 4)\n        if bands > 4:\n            msg = \"Invalid number of bands\"\n            raise OSError(msg)\n\n        # note: for now, we ignore the \"uncalibrated\" flag\n        colors = tuple(i32(s, 8 + i * 4) & 0x7FFFFFFF for i in range(bands))\n\n        self._mode, self.rawmode = MODES[colors]\n\n        # load JPEG tables, if any\n        self.jpeg = {}\n        for i in range(256):\n            id = 0x3000001 | (i << 16)\n            if id in prop:\n                self.jpeg[i] = prop[id]\n\n        self._open_subimage(1, self.maxid)\n\n    def _open_subimage(self, index: int = 1, subimage: int = 0) -> None:\n        #\n        # setup tile descriptors for a given subimage\n\n        stream = [\n            f\"Data Object Store {index:06d}\",\n            f\"Resolution {subimage:04d}\",\n            \"Subimage 0000 Header\",\n        ]\n\n        fp = self.ole.openstream(stream)\n\n        # skip prefix\n        fp.read(28)\n\n        # header stream\n        s = fp.read(36)\n\n        size = i32(s, 4), i32(s, 8)\n        # tilecount = i32(s, 12)\n        tilesize = i32(s, 16), i32(s, 20)\n        # channels = i32(s, 24)\n        offset = i32(s, 28)\n        length = i32(s, 32)\n\n        if size != self.size:\n            msg = \"subimage mismatch\"\n            raise OSError(msg)\n\n        # get tile descriptors\n        fp.seek(28 + offset)\n        s = fp.read(i32(s, 12) * length)\n\n        x = y = 0\n        xsize, ysize = size\n        xtile, ytile = tilesize\n        self.tile = []\n\n        for i in range(0, len(s), length):\n            x1 = min(xsize, x + xtile)\n            y1 = min(ysize, y + ytile)\n\n            compression = i32(s, i + 8)\n\n            if compression == 0:\n                self.tile.append(\n                    (\n                        \"raw\",\n                        (x, y, x1, y1),\n                        i32(s, i) + 28,\n                        (self.rawmode,),\n                    )\n                )\n\n            elif compression == 1:\n                # FIXME: the fill decoder is not implemented\n                self.tile.append(\n                    (\n                        \"fill\",\n                        (x, y, x1, y1),\n                        i32(s, i) + 28,\n                        (self.rawmode, s[12:16]),\n                    )\n                )\n\n            elif compression == 2:\n                internal_color_conversion = s[14]\n                jpeg_tables = s[15]\n                rawmode = self.rawmode\n\n                if internal_color_conversion:\n                    # The image is stored as usual (usually YCbCr).\n                    if rawmode == \"RGBA\":\n                        # For \"RGBA\", data is stored as YCbCrA based on\n                        # negative RGB. The following trick works around\n                        # this problem :\n                        jpegmode, rawmode = \"YCbCrK\", \"CMYK\"\n                    else:\n                        jpegmode = None  # let the decoder decide\n\n                else:\n                    # The image is stored as defined by rawmode\n                    jpegmode = rawmode\n\n                self.tile.append(\n                    (\n                        \"jpeg\",\n                        (x, y, x1, y1),\n                        i32(s, i) + 28,\n                        (rawmode, jpegmode),\n                    )\n                )\n\n                # FIXME: jpeg tables are tile dependent; the prefix\n                # data must be placed in the tile descriptor itself!\n\n                if jpeg_tables:\n                    self.tile_prefix = self.jpeg[jpeg_tables]\n\n            else:\n                msg = \"unknown/invalid compression\"\n                raise OSError(msg)\n\n            x = x + xtile\n            if x >= xsize:\n                x, y = 0, y + ytile\n                if y >= ysize:\n                    break  # isn't really required\n\n        self.stream = stream\n        self._fp = self.fp\n        self.fp = None\n\n    def load(self):\n        if not self.fp:\n            self.fp = self.ole.openstream(self.stream[:2] + [\"Subimage 0000 Data\"])\n\n        return ImageFile.ImageFile.load(self)\n\n    def close(self) -> None:\n        self.ole.close()\n        super().close()\n\n    def __exit__(self, *args: object) -> None:\n        self.ole.close()\n        super().__exit__()\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_open(FpxImageFile.format, FpxImageFile, _accept)\n\nImage.register_extension(FpxImageFile.format, \".fpx\")\n", "src/PIL/FontFile.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# base class for raster font file parsers\n#\n# history:\n# 1997-06-05 fl   created\n# 1997-08-19 fl   restrict image width\n#\n# Copyright (c) 1997-1998 by Secret Labs AB\n# Copyright (c) 1997-1998 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nfrom typing import BinaryIO\n\nfrom . import Image, _binary\n\nWIDTH = 800\n\n\ndef puti16(\n    fp: BinaryIO, values: tuple[int, int, int, int, int, int, int, int, int, int]\n) -> None:\n    \"\"\"Write network order (big-endian) 16-bit sequence\"\"\"\n    for v in values:\n        if v < 0:\n            v += 65536\n        fp.write(_binary.o16be(v))\n\n\nclass FontFile:\n    \"\"\"Base class for raster font file handlers.\"\"\"\n\n    bitmap: Image.Image | None = None\n\n    def __init__(self) -> None:\n        self.info: dict[bytes, bytes | int] = {}\n        self.glyph: list[\n            tuple[\n                tuple[int, int],\n                tuple[int, int, int, int],\n                tuple[int, int, int, int],\n                Image.Image,\n            ]\n            | None\n        ] = [None] * 256\n\n    def __getitem__(self, ix: int) -> (\n        tuple[\n            tuple[int, int],\n            tuple[int, int, int, int],\n            tuple[int, int, int, int],\n            Image.Image,\n        ]\n        | None\n    ):\n        return self.glyph[ix]\n\n    def compile(self) -> None:\n        \"\"\"Create metrics and bitmap\"\"\"\n\n        if self.bitmap:\n            return\n\n        # create bitmap large enough to hold all data\n        h = w = maxwidth = 0\n        lines = 1\n        for glyph in self.glyph:\n            if glyph:\n                d, dst, src, im = glyph\n                h = max(h, src[3] - src[1])\n                w = w + (src[2] - src[0])\n                if w > WIDTH:\n                    lines += 1\n                    w = src[2] - src[0]\n                maxwidth = max(maxwidth, w)\n\n        xsize = maxwidth\n        ysize = lines * h\n\n        if xsize == 0 and ysize == 0:\n            return\n\n        self.ysize = h\n\n        # paste glyphs into bitmap\n        self.bitmap = Image.new(\"1\", (xsize, ysize))\n        self.metrics: list[\n            tuple[tuple[int, int], tuple[int, int, int, int], tuple[int, int, int, int]]\n            | None\n        ] = [None] * 256\n        x = y = 0\n        for i in range(256):\n            glyph = self[i]\n            if glyph:\n                d, dst, src, im = glyph\n                xx = src[2] - src[0]\n                x0, y0 = x, y\n                x = x + xx\n                if x > WIDTH:\n                    x, y = 0, y + h\n                    x0, y0 = x, y\n                    x = xx\n                s = src[0] + x0, src[1] + y0, src[2] + x0, src[3] + y0\n                self.bitmap.paste(im.crop(src), s)\n                self.metrics[i] = d, dst, s\n\n    def save(self, filename: str) -> None:\n        \"\"\"Save font\"\"\"\n\n        self.compile()\n\n        # font data\n        if not self.bitmap:\n            msg = \"No bitmap created\"\n            raise ValueError(msg)\n        self.bitmap.save(os.path.splitext(filename)[0] + \".pbm\", \"PNG\")\n\n        # font metrics\n        with open(os.path.splitext(filename)[0] + \".pil\", \"wb\") as fp:\n            fp.write(b\"PILfont\\n\")\n            fp.write(f\";;;;;;{self.ysize};\\n\".encode(\"ascii\"))  # HACK!!!\n            fp.write(b\"DATA\\n\")\n            for id in range(256):\n                m = self.metrics[id]\n                if not m:\n                    puti16(fp, (0,) * 10)\n                else:\n                    puti16(fp, m[0] + m[1] + m[2])\n", "src/PIL/ImageDraw2.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# WCK-style drawing interface operations\n#\n# History:\n# 2003-12-07 fl   created\n# 2005-05-15 fl   updated; added to PIL as ImageDraw2\n# 2005-05-15 fl   added text support\n# 2005-05-20 fl   added arc/chord/pieslice support\n#\n# Copyright (c) 2003-2005 by Secret Labs AB\n# Copyright (c) 2003-2005 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\n\n\"\"\"\n(Experimental) WCK-style drawing interface operations\n\n.. seealso:: :py:mod:`PIL.ImageDraw`\n\"\"\"\nfrom __future__ import annotations\n\nfrom . import Image, ImageColor, ImageDraw, ImageFont, ImagePath\n\n\nclass Pen:\n    \"\"\"Stores an outline color and width.\"\"\"\n\n    def __init__(self, color: str, width: int = 1, opacity: int = 255) -> None:\n        self.color = ImageColor.getrgb(color)\n        self.width = width\n\n\nclass Brush:\n    \"\"\"Stores a fill color\"\"\"\n\n    def __init__(self, color: str, opacity: int = 255) -> None:\n        self.color = ImageColor.getrgb(color)\n\n\nclass Font:\n    \"\"\"Stores a TrueType font and color\"\"\"\n\n    def __init__(self, color, file, size=12):\n        # FIXME: add support for bitmap fonts\n        self.color = ImageColor.getrgb(color)\n        self.font = ImageFont.truetype(file, size)\n\n\nclass Draw:\n    \"\"\"\n    (Experimental) WCK-style drawing interface\n    \"\"\"\n\n    def __init__(\n        self,\n        image: Image.Image | str,\n        size: tuple[int, int] | list[int] | None = None,\n        color: float | tuple[float, ...] | str | None = None,\n    ) -> None:\n        if isinstance(image, str):\n            if size is None:\n                msg = \"If image argument is mode string, size must be a list or tuple\"\n                raise ValueError(msg)\n            image = Image.new(image, size, color)\n        self.draw = ImageDraw.Draw(image)\n        self.image = image\n        self.transform = None\n\n    def flush(self) -> Image.Image:\n        return self.image\n\n    def render(self, op, xy, pen, brush=None):\n        # handle color arguments\n        outline = fill = None\n        width = 1\n        if isinstance(pen, Pen):\n            outline = pen.color\n            width = pen.width\n        elif isinstance(brush, Pen):\n            outline = brush.color\n            width = brush.width\n        if isinstance(brush, Brush):\n            fill = brush.color\n        elif isinstance(pen, Brush):\n            fill = pen.color\n        # handle transformation\n        if self.transform:\n            xy = ImagePath.Path(xy)\n            xy.transform(self.transform)\n        # render the item\n        if op == \"line\":\n            self.draw.line(xy, fill=outline, width=width)\n        else:\n            getattr(self.draw, op)(xy, fill=fill, outline=outline)\n\n    def settransform(self, offset):\n        \"\"\"Sets a transformation offset.\"\"\"\n        (xoffset, yoffset) = offset\n        self.transform = (1, 0, xoffset, 0, 1, yoffset)\n\n    def arc(self, xy, start, end, *options):\n        \"\"\"\n        Draws an arc (a portion of a circle outline) between the start and end\n        angles, inside the given bounding box.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.arc`\n        \"\"\"\n        self.render(\"arc\", xy, start, end, *options)\n\n    def chord(self, xy, start, end, *options):\n        \"\"\"\n        Same as :py:meth:`~PIL.ImageDraw2.Draw.arc`, but connects the end points\n        with a straight line.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.chord`\n        \"\"\"\n        self.render(\"chord\", xy, start, end, *options)\n\n    def ellipse(self, xy, *options):\n        \"\"\"\n        Draws an ellipse inside the given bounding box.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.ellipse`\n        \"\"\"\n        self.render(\"ellipse\", xy, *options)\n\n    def line(self, xy, *options):\n        \"\"\"\n        Draws a line between the coordinates in the ``xy`` list.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.line`\n        \"\"\"\n        self.render(\"line\", xy, *options)\n\n    def pieslice(self, xy, start, end, *options):\n        \"\"\"\n        Same as arc, but also draws straight lines between the end points and the\n        center of the bounding box.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.pieslice`\n        \"\"\"\n        self.render(\"pieslice\", xy, start, end, *options)\n\n    def polygon(self, xy, *options):\n        \"\"\"\n        Draws a polygon.\n\n        The polygon outline consists of straight lines between the given\n        coordinates, plus a straight line between the last and the first\n        coordinate.\n\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.polygon`\n        \"\"\"\n        self.render(\"polygon\", xy, *options)\n\n    def rectangle(self, xy, *options):\n        \"\"\"\n        Draws a rectangle.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.rectangle`\n        \"\"\"\n        self.render(\"rectangle\", xy, *options)\n\n    def text(self, xy, text, font):\n        \"\"\"\n        Draws the string at the given position.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.text`\n        \"\"\"\n        if self.transform:\n            xy = ImagePath.Path(xy)\n            xy.transform(self.transform)\n        self.draw.text(xy, text, font=font.font, fill=font.color)\n\n    def textbbox(self, xy, text, font):\n        \"\"\"\n        Returns bounding box (in pixels) of given text.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.textbbox`\n        \"\"\"\n        if self.transform:\n            xy = ImagePath.Path(xy)\n            xy.transform(self.transform)\n        return self.draw.textbbox(xy, text, font=font.font)\n\n    def textlength(self, text, font):\n        \"\"\"\n        Returns length (in pixels) of given text.\n        This is the amount by which following text should be offset.\n\n        .. seealso:: :py:meth:`PIL.ImageDraw.ImageDraw.textlength`\n        \"\"\"\n        return self.draw.textlength(text, font=font.font)\n", "src/PIL/GbrImagePlugin.py": "#\n# The Python Imaging Library\n#\n# load a GIMP brush file\n#\n# History:\n#       96-03-14 fl     Created\n#       16-01-08 es     Version 2\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n# Copyright (c) Eric Soroos 2016.\n#\n# See the README file for information on usage and redistribution.\n#\n#\n# See https://github.com/GNOME/gimp/blob/mainline/devel-docs/gbr.txt for\n# format documentation.\n#\n# This code Interprets version 1 and 2 .gbr files.\n# Version 1 files are obsolete, and should not be used for new\n#   brushes.\n# Version 2 files are saved by GIMP v2.8 (at least)\n# Version 3 files have a format specifier of 18 for 16bit floats in\n#   the color depth field. This is currently unsupported by Pillow.\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i32be as i32\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 8 and i32(prefix, 0) >= 20 and i32(prefix, 4) in (1, 2)\n\n\n##\n# Image plugin for the GIMP brush format.\n\n\nclass GbrImageFile(ImageFile.ImageFile):\n    format = \"GBR\"\n    format_description = \"GIMP brush file\"\n\n    def _open(self) -> None:\n        header_size = i32(self.fp.read(4))\n        if header_size < 20:\n            msg = \"not a GIMP brush\"\n            raise SyntaxError(msg)\n        version = i32(self.fp.read(4))\n        if version not in (1, 2):\n            msg = f\"Unsupported GIMP brush version: {version}\"\n            raise SyntaxError(msg)\n\n        width = i32(self.fp.read(4))\n        height = i32(self.fp.read(4))\n        color_depth = i32(self.fp.read(4))\n        if width <= 0 or height <= 0:\n            msg = \"not a GIMP brush\"\n            raise SyntaxError(msg)\n        if color_depth not in (1, 4):\n            msg = f\"Unsupported GIMP brush color depth: {color_depth}\"\n            raise SyntaxError(msg)\n\n        if version == 1:\n            comment_length = header_size - 20\n        else:\n            comment_length = header_size - 28\n            magic_number = self.fp.read(4)\n            if magic_number != b\"GIMP\":\n                msg = \"not a GIMP brush, bad magic number\"\n                raise SyntaxError(msg)\n            self.info[\"spacing\"] = i32(self.fp.read(4))\n\n        comment = self.fp.read(comment_length)[:-1]\n\n        if color_depth == 1:\n            self._mode = \"L\"\n        else:\n            self._mode = \"RGBA\"\n\n        self._size = width, height\n\n        self.info[\"comment\"] = comment\n\n        # Image might not be small\n        Image._decompression_bomb_check(self.size)\n\n        # Data is an uncompressed block of w * h * bytes/pixel\n        self._data_size = width * height * color_depth\n\n    def load(self):\n        if not self.im:\n            self.im = Image.core.new(self.mode, self.size)\n            self.frombytes(self.fp.read(self._data_size))\n        return Image.Image.load(self)\n\n\n#\n# registry\n\n\nImage.register_open(GbrImageFile.format, GbrImageFile, _accept)\nImage.register_extension(GbrImageFile.format, \".gbr\")\n", "src/PIL/IptcImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# IPTC/NAA file handling\n#\n# history:\n# 1995-10-01 fl   Created\n# 1998-03-09 fl   Cleaned up and added to PIL\n# 2002-06-18 fl   Added getiptcinfo helper\n#\n# Copyright (c) Secret Labs AB 1997-2002.\n# Copyright (c) Fredrik Lundh 1995.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom io import BytesIO\nfrom typing import Sequence\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._deprecate import deprecate\n\nCOMPRESSION = {1: \"raw\", 5: \"jpeg\"}\n\n\ndef __getattr__(name: str) -> bytes:\n    if name == \"PAD\":\n        deprecate(\"IptcImagePlugin.PAD\", 12)\n        return b\"\\0\\0\\0\\0\"\n    msg = f\"module '{__name__}' has no attribute '{name}'\"\n    raise AttributeError(msg)\n\n\n#\n# Helpers\n\n\ndef _i(c: bytes) -> int:\n    return i32((b\"\\0\\0\\0\\0\" + c)[-4:])\n\n\ndef _i8(c: int | bytes) -> int:\n    return c if isinstance(c, int) else c[0]\n\n\ndef i(c: bytes) -> int:\n    \"\"\".. deprecated:: 10.2.0\"\"\"\n    deprecate(\"IptcImagePlugin.i\", 12)\n    return _i(c)\n\n\ndef dump(c: Sequence[int | bytes]) -> None:\n    \"\"\".. deprecated:: 10.2.0\"\"\"\n    deprecate(\"IptcImagePlugin.dump\", 12)\n    for i in c:\n        print(f\"{_i8(i):02x}\", end=\" \")\n    print()\n\n\n##\n# Image plugin for IPTC/NAA datastreams.  To read IPTC/NAA fields\n# from TIFF and JPEG files, use the <b>getiptcinfo</b> function.\n\n\nclass IptcImageFile(ImageFile.ImageFile):\n    format = \"IPTC\"\n    format_description = \"IPTC/NAA\"\n\n    def getint(self, key: tuple[int, int]) -> int:\n        return _i(self.info[key])\n\n    def field(self) -> tuple[tuple[int, int] | None, int]:\n        #\n        # get a IPTC field header\n        s = self.fp.read(5)\n        if not s.strip(b\"\\x00\"):\n            return None, 0\n\n        tag = s[1], s[2]\n\n        # syntax\n        if s[0] != 0x1C or tag[0] not in [1, 2, 3, 4, 5, 6, 7, 8, 9, 240]:\n            msg = \"invalid IPTC/NAA file\"\n            raise SyntaxError(msg)\n\n        # field size\n        size = s[3]\n        if size > 132:\n            msg = \"illegal field length in IPTC/NAA file\"\n            raise OSError(msg)\n        elif size == 128:\n            size = 0\n        elif size > 128:\n            size = _i(self.fp.read(size - 128))\n        else:\n            size = i16(s, 3)\n\n        return tag, size\n\n    def _open(self) -> None:\n        # load descriptive fields\n        while True:\n            offset = self.fp.tell()\n            tag, size = self.field()\n            if not tag or tag == (8, 10):\n                break\n            if size:\n                tagdata = self.fp.read(size)\n            else:\n                tagdata = None\n            if tag in self.info:\n                if isinstance(self.info[tag], list):\n                    self.info[tag].append(tagdata)\n                else:\n                    self.info[tag] = [self.info[tag], tagdata]\n            else:\n                self.info[tag] = tagdata\n\n        # mode\n        layers = self.info[(3, 60)][0]\n        component = self.info[(3, 60)][1]\n        if (3, 65) in self.info:\n            id = self.info[(3, 65)][0] - 1\n        else:\n            id = 0\n        if layers == 1 and not component:\n            self._mode = \"L\"\n        elif layers == 3 and component:\n            self._mode = \"RGB\"[id]\n        elif layers == 4 and component:\n            self._mode = \"CMYK\"[id]\n\n        # size\n        self._size = self.getint((3, 20)), self.getint((3, 30))\n\n        # compression\n        try:\n            compression = COMPRESSION[self.getint((3, 120))]\n        except KeyError as e:\n            msg = \"Unknown IPTC image compression\"\n            raise OSError(msg) from e\n\n        # tile\n        if tag == (8, 10):\n            self.tile = [(\"iptc\", (0, 0) + self.size, offset, compression)]\n\n    def load(self):\n        if len(self.tile) != 1 or self.tile[0][0] != \"iptc\":\n            return ImageFile.ImageFile.load(self)\n\n        offset, compression = self.tile[0][2:]\n\n        self.fp.seek(offset)\n\n        # Copy image data to temporary file\n        o = BytesIO()\n        if compression == \"raw\":\n            # To simplify access to the extracted file,\n            # prepend a PPM header\n            o.write(b\"P5\\n%d %d\\n255\\n\" % self.size)\n        while True:\n            type, size = self.field()\n            if type != (8, 10):\n                break\n            while size > 0:\n                s = self.fp.read(min(size, 8192))\n                if not s:\n                    break\n                o.write(s)\n                size -= len(s)\n\n        with Image.open(o) as _im:\n            _im.load()\n            self.im = _im.im\n\n\nImage.register_open(IptcImageFile.format, IptcImageFile)\n\nImage.register_extension(IptcImageFile.format, \".iim\")\n\n\ndef getiptcinfo(im):\n    \"\"\"\n    Get IPTC information from TIFF, JPEG, or IPTC file.\n\n    :param im: An image containing IPTC data.\n    :returns: A dictionary containing IPTC information, or None if\n        no IPTC information block was found.\n    \"\"\"\n    from . import JpegImagePlugin, TiffImagePlugin\n\n    data = None\n\n    if isinstance(im, IptcImageFile):\n        # return info dictionary right away\n        return im.info\n\n    elif isinstance(im, JpegImagePlugin.JpegImageFile):\n        # extract the IPTC/NAA resource\n        photoshop = im.info.get(\"photoshop\")\n        if photoshop:\n            data = photoshop.get(0x0404)\n\n    elif isinstance(im, TiffImagePlugin.TiffImageFile):\n        # get raw data from the IPTC/NAA tag (PhotoShop tags the data\n        # as 4-byte integers, so we cannot use the get method...)\n        try:\n            data = im.tag.tagdata[TiffImagePlugin.IPTC_NAA_CHUNK]\n        except (AttributeError, KeyError):\n            pass\n\n    if data is None:\n        return None  # no properties\n\n    # create an IptcImagePlugin object without initializing it\n    class FakeImage:\n        pass\n\n    im = FakeImage()\n    im.__class__ = IptcImageFile\n\n    # parse the IPTC information chunk\n    im.info = {}\n    im.fp = BytesIO(data)\n\n    try:\n        im._open()\n    except (IndexError, KeyError):\n        pass  # expected failure\n\n    return im.info\n", "src/PIL/ImageShow.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# im.show() drivers\n#\n# History:\n# 2008-04-06 fl   Created\n#\n# Copyright (c) Secret Labs AB 2008.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport abc\nimport os\nimport shutil\nimport subprocess\nimport sys\nfrom shlex import quote\nfrom typing import Any\n\nfrom . import Image\n\n_viewers = []\n\n\ndef register(viewer, order: int = 1) -> None:\n    \"\"\"\n    The :py:func:`register` function is used to register additional viewers::\n\n        from PIL import ImageShow\n        ImageShow.register(MyViewer())  # MyViewer will be used as a last resort\n        ImageShow.register(MySecondViewer(), 0)  # MySecondViewer will be prioritised\n        ImageShow.register(ImageShow.XVViewer(), 0)  # XVViewer will be prioritised\n\n    :param viewer: The viewer to be registered.\n    :param order:\n        Zero or a negative integer to prepend this viewer to the list,\n        a positive integer to append it.\n    \"\"\"\n    try:\n        if issubclass(viewer, Viewer):\n            viewer = viewer()\n    except TypeError:\n        pass  # raised if viewer wasn't a class\n    if order > 0:\n        _viewers.append(viewer)\n    else:\n        _viewers.insert(0, viewer)\n\n\ndef show(image: Image.Image, title: str | None = None, **options: Any) -> bool:\n    r\"\"\"\n    Display a given image.\n\n    :param image: An image object.\n    :param title: Optional title. Not all viewers can display the title.\n    :param \\**options: Additional viewer options.\n    :returns: ``True`` if a suitable viewer was found, ``False`` otherwise.\n    \"\"\"\n    for viewer in _viewers:\n        if viewer.show(image, title=title, **options):\n            return True\n    return False\n\n\nclass Viewer:\n    \"\"\"Base class for viewers.\"\"\"\n\n    # main api\n\n    def show(self, image: Image.Image, **options: Any) -> int:\n        \"\"\"\n        The main function for displaying an image.\n        Converts the given image to the target format and displays it.\n        \"\"\"\n\n        if not (\n            image.mode in (\"1\", \"RGBA\")\n            or (self.format == \"PNG\" and image.mode in (\"I;16\", \"LA\"))\n        ):\n            base = Image.getmodebase(image.mode)\n            if image.mode != base:\n                image = image.convert(base)\n\n        return self.show_image(image, **options)\n\n    # hook methods\n\n    format: str | None = None\n    \"\"\"The format to convert the image into.\"\"\"\n    options: dict[str, Any] = {}\n    \"\"\"Additional options used to convert the image.\"\"\"\n\n    def get_format(self, image: Image.Image) -> str | None:\n        \"\"\"Return format name, or ``None`` to save as PGM/PPM.\"\"\"\n        return self.format\n\n    def get_command(self, file: str, **options: Any) -> str:\n        \"\"\"\n        Returns the command used to display the file.\n        Not implemented in the base class.\n        \"\"\"\n        msg = \"unavailable in base viewer\"\n        raise NotImplementedError(msg)\n\n    def save_image(self, image: Image.Image) -> str:\n        \"\"\"Save to temporary file and return filename.\"\"\"\n        return image._dump(format=self.get_format(image), **self.options)\n\n    def show_image(self, image: Image.Image, **options: Any) -> int:\n        \"\"\"Display the given image.\"\"\"\n        return self.show_file(self.save_image(image), **options)\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        os.system(self.get_command(path, **options))  # nosec\n        return 1\n\n\n# --------------------------------------------------------------------\n\n\nclass WindowsViewer(Viewer):\n    \"\"\"The default viewer on Windows is the default system application for PNG files.\"\"\"\n\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n\n    def get_command(self, file: str, **options: Any) -> str:\n        return (\n            f'start \"Pillow\" /WAIT \"{file}\" '\n            \"&& ping -n 4 127.0.0.1 >NUL \"\n            f'&& del /f \"{file}\"'\n        )\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen(\n            self.get_command(path, **options),\n            shell=True,\n            creationflags=getattr(subprocess, \"CREATE_NO_WINDOW\"),\n        )  # nosec\n        return 1\n\n\nif sys.platform == \"win32\":\n    register(WindowsViewer)\n\n\nclass MacViewer(Viewer):\n    \"\"\"The default viewer on macOS using ``Preview.app``.\"\"\"\n\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n\n    def get_command(self, file: str, **options: Any) -> str:\n        # on darwin open returns immediately resulting in the temp\n        # file removal while app is opening\n        command = \"open -a Preview.app\"\n        command = f\"({command} {quote(file)}; sleep 20; rm -f {quote(file)})&\"\n        return command\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.call([\"open\", \"-a\", \"Preview.app\", path])\n        executable = sys.executable or shutil.which(\"python3\")\n        if executable:\n            subprocess.Popen(\n                [\n                    executable,\n                    \"-c\",\n                    \"import os, sys, time; time.sleep(20); os.remove(sys.argv[1])\",\n                    path,\n                ]\n            )\n        return 1\n\n\nif sys.platform == \"darwin\":\n    register(MacViewer)\n\n\nclass UnixViewer(Viewer):\n    format = \"PNG\"\n    options = {\"compress_level\": 1, \"save_all\": True}\n\n    @abc.abstractmethod\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        pass\n\n    def get_command(self, file: str, **options: Any) -> str:\n        command = self.get_command_ex(file, **options)[0]\n        return f\"{command} {quote(file)}\"\n\n\nclass XDGViewer(UnixViewer):\n    \"\"\"\n    The freedesktop.org ``xdg-open`` command.\n    \"\"\"\n\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        command = executable = \"xdg-open\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen([\"xdg-open\", path])\n        return 1\n\n\nclass DisplayViewer(UnixViewer):\n    \"\"\"\n    The ImageMagick ``display`` command.\n    This viewer supports the ``title`` parameter.\n    \"\"\"\n\n    def get_command_ex(\n        self, file: str, title: str | None = None, **options: Any\n    ) -> tuple[str, str]:\n        command = executable = \"display\"\n        if title:\n            command += f\" -title {quote(title)}\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        args = [\"display\"]\n        title = options.get(\"title\")\n        if title:\n            args += [\"-title\", title]\n        args.append(path)\n\n        subprocess.Popen(args)\n        return 1\n\n\nclass GmDisplayViewer(UnixViewer):\n    \"\"\"The GraphicsMagick ``gm display`` command.\"\"\"\n\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        executable = \"gm\"\n        command = \"gm display\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen([\"gm\", \"display\", path])\n        return 1\n\n\nclass EogViewer(UnixViewer):\n    \"\"\"The GNOME Image Viewer ``eog`` command.\"\"\"\n\n    def get_command_ex(self, file: str, **options: Any) -> tuple[str, str]:\n        executable = \"eog\"\n        command = \"eog -n\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        subprocess.Popen([\"eog\", \"-n\", path])\n        return 1\n\n\nclass XVViewer(UnixViewer):\n    \"\"\"\n    The X Viewer ``xv`` command.\n    This viewer supports the ``title`` parameter.\n    \"\"\"\n\n    def get_command_ex(\n        self, file: str, title: str | None = None, **options: Any\n    ) -> tuple[str, str]:\n        # note: xv is pretty outdated.  most modern systems have\n        # imagemagick's display command instead.\n        command = executable = \"xv\"\n        if title:\n            command += f\" -name {quote(title)}\"\n        return command, executable\n\n    def show_file(self, path: str, **options: Any) -> int:\n        \"\"\"\n        Display given file.\n        \"\"\"\n        args = [\"xv\"]\n        title = options.get(\"title\")\n        if title:\n            args += [\"-name\", title]\n        args.append(path)\n\n        subprocess.Popen(args)\n        return 1\n\n\nif sys.platform not in (\"win32\", \"darwin\"):  # unixoids\n    if shutil.which(\"xdg-open\"):\n        register(XDGViewer)\n    if shutil.which(\"display\"):\n        register(DisplayViewer)\n    if shutil.which(\"gm\"):\n        register(GmDisplayViewer)\n    if shutil.which(\"eog\"):\n        register(EogViewer)\n    if shutil.which(\"xv\"):\n        register(XVViewer)\n\n\nclass IPythonViewer(Viewer):\n    \"\"\"The viewer for IPython frontends.\"\"\"\n\n    def show_image(self, image: Image.Image, **options: Any) -> int:\n        ipython_display(image)\n        return 1\n\n\ntry:\n    from IPython.display import display as ipython_display\nexcept ImportError:\n    pass\nelse:\n    register(IPythonViewer)\n\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Syntax: python3 ImageShow.py imagefile [title]\")\n        sys.exit()\n\n    with Image.open(sys.argv[1]) as im:\n        print(show(im, *sys.argv[2:]))\n", "src/PIL/ImageSequence.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# sequence support classes\n#\n# history:\n# 1997-02-20 fl     Created\n#\n# Copyright (c) 1997 by Secret Labs AB.\n# Copyright (c) 1997 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n##\nfrom __future__ import annotations\n\nfrom typing import Callable\n\nfrom . import Image\n\n\nclass Iterator:\n    \"\"\"\n    This class implements an iterator object that can be used to loop\n    over an image sequence.\n\n    You can use the ``[]`` operator to access elements by index. This operator\n    will raise an :py:exc:`IndexError` if you try to access a nonexistent\n    frame.\n\n    :param im: An image object.\n    \"\"\"\n\n    def __init__(self, im: Image.Image):\n        if not hasattr(im, \"seek\"):\n            msg = \"im must have seek method\"\n            raise AttributeError(msg)\n        self.im = im\n        self.position = getattr(self.im, \"_min_frame\", 0)\n\n    def __getitem__(self, ix: int) -> Image.Image:\n        try:\n            self.im.seek(ix)\n            return self.im\n        except EOFError as e:\n            msg = \"end of sequence\"\n            raise IndexError(msg) from e\n\n    def __iter__(self) -> Iterator:\n        return self\n\n    def __next__(self) -> Image.Image:\n        try:\n            self.im.seek(self.position)\n            self.position += 1\n            return self.im\n        except EOFError as e:\n            msg = \"end of sequence\"\n            raise StopIteration(msg) from e\n\n\ndef all_frames(\n    im: Image.Image | list[Image.Image],\n    func: Callable[[Image.Image], Image.Image] | None = None,\n) -> list[Image.Image]:\n    \"\"\"\n    Applies a given function to all frames in an image or a list of images.\n    The frames are returned as a list of separate images.\n\n    :param im: An image, or a list of images.\n    :param func: The function to apply to all of the image frames.\n    :returns: A list of images.\n    \"\"\"\n    if not isinstance(im, list):\n        im = [im]\n\n    ims = []\n    for imSequence in im:\n        current = imSequence.tell()\n\n        ims += [im_frame.copy() for im_frame in Iterator(imSequence)]\n\n        imSequence.seek(current)\n    return [func(im) for im in ims] if func else ims\n", "src/PIL/_deprecate.py": "from __future__ import annotations\n\nimport warnings\n\nfrom . import __version__\n\n\ndef deprecate(\n    deprecated: str,\n    when: int | None,\n    replacement: str | None = None,\n    *,\n    action: str | None = None,\n    plural: bool = False,\n) -> None:\n    \"\"\"\n    Deprecations helper.\n\n    :param deprecated: Name of thing to be deprecated.\n    :param when: Pillow major version to be removed in.\n    :param replacement: Name of replacement.\n    :param action: Instead of \"replacement\", give a custom call to action\n        e.g. \"Upgrade to new thing\".\n    :param plural: if the deprecated thing is plural, needing \"are\" instead of \"is\".\n\n    Usually of the form:\n\n        \"[deprecated] is deprecated and will be removed in Pillow [when] (yyyy-mm-dd).\n        Use [replacement] instead.\"\n\n    You can leave out the replacement sentence:\n\n        \"[deprecated] is deprecated and will be removed in Pillow [when] (yyyy-mm-dd)\"\n\n    Or with another call to action:\n\n        \"[deprecated] is deprecated and will be removed in Pillow [when] (yyyy-mm-dd).\n        [action].\"\n    \"\"\"\n\n    is_ = \"are\" if plural else \"is\"\n\n    if when is None:\n        removed = \"a future version\"\n    elif when <= int(__version__.split(\".\")[0]):\n        msg = f\"{deprecated} {is_} deprecated and should be removed.\"\n        raise RuntimeError(msg)\n    elif when == 11:\n        removed = \"Pillow 11 (2024-10-15)\"\n    elif when == 12:\n        removed = \"Pillow 12 (2025-10-15)\"\n    else:\n        msg = f\"Unknown removal version: {when}. Update {__name__}?\"\n        raise ValueError(msg)\n\n    if replacement and action:\n        msg = \"Use only one of 'replacement' and 'action'\"\n        raise ValueError(msg)\n\n    if replacement:\n        action = f\". Use {replacement} instead.\"\n    elif action:\n        action = f\". {action.rstrip('.')}.\"\n    else:\n        action = \"\"\n\n    warnings.warn(\n        f\"{deprecated} {is_} deprecated and will be removed in {removed}{action}\",\n        DeprecationWarning,\n        stacklevel=3,\n    )\n", "src/PIL/PSDraw.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# Simple PostScript graphics interface\n#\n# History:\n# 1996-04-20 fl   Created\n# 1999-01-10 fl   Added gsave/grestore to image method\n# 2005-05-04 fl   Fixed floating point issue in image (from Eric Etheridge)\n#\n# Copyright (c) 1997-2005 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom . import EpsImagePlugin\n\n##\n# Simple PostScript graphics interface.\n\n\nclass PSDraw:\n    \"\"\"\n    Sets up printing to the given file. If ``fp`` is omitted,\n    ``sys.stdout.buffer`` or ``sys.stdout`` is assumed.\n    \"\"\"\n\n    def __init__(self, fp=None):\n        if not fp:\n            try:\n                fp = sys.stdout.buffer\n            except AttributeError:\n                fp = sys.stdout\n        self.fp = fp\n\n    def begin_document(self, id: str | None = None) -> None:\n        \"\"\"Set up printing of a document. (Write PostScript DSC header.)\"\"\"\n        # FIXME: incomplete\n        self.fp.write(\n            b\"%!PS-Adobe-3.0\\n\"\n            b\"save\\n\"\n            b\"/showpage { } def\\n\"\n            b\"%%EndComments\\n\"\n            b\"%%BeginDocument\\n\"\n        )\n        # self.fp.write(ERROR_PS)  # debugging!\n        self.fp.write(EDROFF_PS)\n        self.fp.write(VDI_PS)\n        self.fp.write(b\"%%EndProlog\\n\")\n        self.isofont: dict[bytes, int] = {}\n\n    def end_document(self) -> None:\n        \"\"\"Ends printing. (Write PostScript DSC footer.)\"\"\"\n        self.fp.write(b\"%%EndDocument\\nrestore showpage\\n%%End\\n\")\n        if hasattr(self.fp, \"flush\"):\n            self.fp.flush()\n\n    def setfont(self, font: str, size: int) -> None:\n        \"\"\"\n        Selects which font to use.\n\n        :param font: A PostScript font name\n        :param size: Size in points.\n        \"\"\"\n        font_bytes = bytes(font, \"UTF-8\")\n        if font_bytes not in self.isofont:\n            # reencode font\n            self.fp.write(\n                b\"/PSDraw-%s ISOLatin1Encoding /%s E\\n\" % (font_bytes, font_bytes)\n            )\n            self.isofont[font_bytes] = 1\n        # rough\n        self.fp.write(b\"/F0 %d /PSDraw-%s F\\n\" % (size, font_bytes))\n\n    def line(self, xy0: tuple[int, int], xy1: tuple[int, int]) -> None:\n        \"\"\"\n        Draws a line between the two points. Coordinates are given in\n        PostScript point coordinates (72 points per inch, (0, 0) is the lower\n        left corner of the page).\n        \"\"\"\n        self.fp.write(b\"%d %d %d %d Vl\\n\" % (*xy0, *xy1))\n\n    def rectangle(self, box: tuple[int, int, int, int]) -> None:\n        \"\"\"\n        Draws a rectangle.\n\n        :param box: A tuple of four integers, specifying left, bottom, width and\n           height.\n        \"\"\"\n        self.fp.write(b\"%d %d M 0 %d %d Vr\\n\" % box)\n\n    def text(self, xy: tuple[int, int], text: str) -> None:\n        \"\"\"\n        Draws text at the given position. You must use\n        :py:meth:`~PIL.PSDraw.PSDraw.setfont` before calling this method.\n        \"\"\"\n        text_bytes = bytes(text, \"UTF-8\")\n        text_bytes = b\"\\\\(\".join(text_bytes.split(b\"(\"))\n        text_bytes = b\"\\\\)\".join(text_bytes.split(b\")\"))\n        self.fp.write(b\"%d %d M (%s) S\\n\" % (xy + (text_bytes,)))\n\n    if TYPE_CHECKING:\n        from . import Image\n\n    def image(\n        self, box: tuple[int, int, int, int], im: Image.Image, dpi: int | None = None\n    ) -> None:\n        \"\"\"Draw a PIL image, centered in the given box.\"\"\"\n        # default resolution depends on mode\n        if not dpi:\n            if im.mode == \"1\":\n                dpi = 200  # fax\n            else:\n                dpi = 100  # grayscale\n        # image size (on paper)\n        x = im.size[0] * 72 / dpi\n        y = im.size[1] * 72 / dpi\n        # max allowed size\n        xmax = float(box[2] - box[0])\n        ymax = float(box[3] - box[1])\n        if x > xmax:\n            y = y * xmax / x\n            x = xmax\n        if y > ymax:\n            x = x * ymax / y\n            y = ymax\n        dx = (xmax - x) / 2 + box[0]\n        dy = (ymax - y) / 2 + box[1]\n        self.fp.write(b\"gsave\\n%f %f translate\\n\" % (dx, dy))\n        if (x, y) != im.size:\n            # EpsImagePlugin._save prints the image at (0,0,xsize,ysize)\n            sx = x / im.size[0]\n            sy = y / im.size[1]\n            self.fp.write(b\"%f %f scale\\n\" % (sx, sy))\n        EpsImagePlugin._save(im, self.fp, \"\", 0)\n        self.fp.write(b\"\\ngrestore\\n\")\n\n\n# --------------------------------------------------------------------\n# PostScript driver\n\n#\n# EDROFF.PS -- PostScript driver for Edroff 2\n#\n# History:\n# 94-01-25 fl: created (edroff 2.04)\n#\n# Copyright (c) Fredrik Lundh 1994.\n#\n\n\nEDROFF_PS = b\"\"\"\\\n/S { show } bind def\n/P { moveto show } bind def\n/M { moveto } bind def\n/X { 0 rmoveto } bind def\n/Y { 0 exch rmoveto } bind def\n/E {    findfont\n        dup maxlength dict begin\n        {\n                1 index /FID ne { def } { pop pop } ifelse\n        } forall\n        /Encoding exch def\n        dup /FontName exch def\n        currentdict end definefont pop\n} bind def\n/F {    findfont exch scalefont dup setfont\n        [ exch /setfont cvx ] cvx bind def\n} bind def\n\"\"\"\n\n#\n# VDI.PS -- PostScript driver for VDI meta commands\n#\n# History:\n# 94-01-25 fl: created (edroff 2.04)\n#\n# Copyright (c) Fredrik Lundh 1994.\n#\n\nVDI_PS = b\"\"\"\\\n/Vm { moveto } bind def\n/Va { newpath arcn stroke } bind def\n/Vl { moveto lineto stroke } bind def\n/Vc { newpath 0 360 arc closepath } bind def\n/Vr {   exch dup 0 rlineto\n        exch dup 0 exch rlineto\n        exch neg 0 rlineto\n        0 exch neg rlineto\n        setgray fill } bind def\n/Tm matrix def\n/Ve {   Tm currentmatrix pop\n        translate scale newpath 0 0 .5 0 360 arc closepath\n        Tm setmatrix\n} bind def\n/Vf { currentgray exch setgray fill setgray } bind def\n\"\"\"\n\n#\n# ERROR.PS -- Error handler\n#\n# History:\n# 89-11-21 fl: created (pslist 1.10)\n#\n\nERROR_PS = b\"\"\"\\\n/landscape false def\n/errorBUF 200 string def\n/errorNL { currentpoint 10 sub exch pop 72 exch moveto } def\nerrordict begin /handleerror {\n    initmatrix /Courier findfont 10 scalefont setfont\n    newpath 72 720 moveto $error begin /newerror false def\n    (PostScript Error) show errorNL errorNL\n    (Error: ) show\n        /errorname load errorBUF cvs show errorNL errorNL\n    (Command: ) show\n        /command load dup type /stringtype ne { errorBUF cvs } if show\n        errorNL errorNL\n    (VMstatus: ) show\n        vmstatus errorBUF cvs show ( bytes available, ) show\n        errorBUF cvs show ( bytes used at level ) show\n        errorBUF cvs show errorNL errorNL\n    (Operand stargck: ) show errorNL /ostargck load {\n        dup type /stringtype ne { errorBUF cvs } if 72 0 rmoveto show errorNL\n    } forall errorNL\n    (Execution stargck: ) show errorNL /estargck load {\n        dup type /stringtype ne { errorBUF cvs } if 72 0 rmoveto show errorNL\n    } forall\n    end showpage\n} def end\n\"\"\"\n", "src/PIL/ImageWin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a Windows DIB display interface\n#\n# History:\n# 1996-05-20 fl   Created\n# 1996-09-20 fl   Fixed subregion exposure\n# 1997-09-21 fl   Added draw primitive (for tzPrint)\n# 2003-05-21 fl   Added experimental Window/ImageWindow classes\n# 2003-09-05 fl   Added fromstring/tostring methods\n#\n# Copyright (c) Secret Labs AB 1997-2003.\n# Copyright (c) Fredrik Lundh 1996-2003.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image\n\n\nclass HDC:\n    \"\"\"\n    Wraps an HDC integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods.\n    \"\"\"\n\n    def __init__(self, dc: int) -> None:\n        self.dc = dc\n\n    def __int__(self) -> int:\n        return self.dc\n\n\nclass HWND:\n    \"\"\"\n    Wraps an HWND integer. The resulting object can be passed to the\n    :py:meth:`~PIL.ImageWin.Dib.draw` and :py:meth:`~PIL.ImageWin.Dib.expose`\n    methods, instead of a DC.\n    \"\"\"\n\n    def __init__(self, wnd: int) -> None:\n        self.wnd = wnd\n\n    def __int__(self) -> int:\n        return self.wnd\n\n\nclass Dib:\n    \"\"\"\n    A Windows bitmap with the given mode and size.  The mode can be one of \"1\",\n    \"L\", \"P\", or \"RGB\".\n\n    If the display requires a palette, this constructor creates a suitable\n    palette and associates it with the image. For an \"L\" image, 128 graylevels\n    are allocated. For an \"RGB\" image, a 6x6x6 colour cube is used, together\n    with 20 graylevels.\n\n    To make sure that palettes work properly under Windows, you must call the\n    ``palette`` method upon certain events from Windows.\n\n    :param image: Either a PIL image, or a mode string. If a mode string is\n                  used, a size must also be given.  The mode can be one of \"1\",\n                  \"L\", \"P\", or \"RGB\".\n    :param size: If the first argument is a mode string, this\n                 defines the size of the image.\n    \"\"\"\n\n    def __init__(self, image, size=None):\n        if hasattr(image, \"mode\") and hasattr(image, \"size\"):\n            mode = image.mode\n            size = image.size\n        else:\n            mode = image\n            image = None\n        if mode not in [\"1\", \"L\", \"P\", \"RGB\"]:\n            mode = Image.getmodebase(mode)\n        self.image = Image.core.display(mode, size)\n        self.mode = mode\n        self.size = size\n        if image:\n            self.paste(image)\n\n    def expose(self, handle):\n        \"\"\"\n        Copy the bitmap contents to a device context.\n\n        :param handle: Device context (HDC), cast to a Python integer, or an\n                       HDC or HWND instance.  In PythonWin, you can use\n                       ``CDC.GetHandleAttrib()`` to get a suitable handle.\n        \"\"\"\n        if isinstance(handle, HWND):\n            dc = self.image.getdc(handle)\n            try:\n                result = self.image.expose(dc)\n            finally:\n                self.image.releasedc(handle, dc)\n        else:\n            result = self.image.expose(handle)\n        return result\n\n    def draw(self, handle, dst, src=None):\n        \"\"\"\n        Same as expose, but allows you to specify where to draw the image, and\n        what part of it to draw.\n\n        The destination and source areas are given as 4-tuple rectangles. If\n        the source is omitted, the entire image is copied. If the source and\n        the destination have different sizes, the image is resized as\n        necessary.\n        \"\"\"\n        if not src:\n            src = (0, 0) + self.size\n        if isinstance(handle, HWND):\n            dc = self.image.getdc(handle)\n            try:\n                result = self.image.draw(dc, dst, src)\n            finally:\n                self.image.releasedc(handle, dc)\n        else:\n            result = self.image.draw(handle, dst, src)\n        return result\n\n    def query_palette(self, handle):\n        \"\"\"\n        Installs the palette associated with the image in the given device\n        context.\n\n        This method should be called upon **QUERYNEWPALETTE** and\n        **PALETTECHANGED** events from Windows. If this method returns a\n        non-zero value, one or more display palette entries were changed, and\n        the image should be redrawn.\n\n        :param handle: Device context (HDC), cast to a Python integer, or an\n                       HDC or HWND instance.\n        :return: A true value if one or more entries were changed (this\n                 indicates that the image should be redrawn).\n        \"\"\"\n        if isinstance(handle, HWND):\n            handle = self.image.getdc(handle)\n            try:\n                result = self.image.query_palette(handle)\n            finally:\n                self.image.releasedc(handle, handle)\n        else:\n            result = self.image.query_palette(handle)\n        return result\n\n    def paste(\n        self, im: Image.Image, box: tuple[int, int, int, int] | None = None\n    ) -> None:\n        \"\"\"\n        Paste a PIL image into the bitmap image.\n\n        :param im: A PIL image.  The size must match the target region.\n                   If the mode does not match, the image is converted to the\n                   mode of the bitmap image.\n        :param box: A 4-tuple defining the left, upper, right, and\n                    lower pixel coordinate.  See :ref:`coordinate-system`. If\n                    None is given instead of a tuple, all of the image is\n                    assumed.\n        \"\"\"\n        im.load()\n        if self.mode != im.mode:\n            im = im.convert(self.mode)\n        if box:\n            self.image.paste(im.im, box)\n        else:\n            self.image.paste(im.im)\n\n    def frombytes(self, buffer: bytes) -> None:\n        \"\"\"\n        Load display memory contents from byte data.\n\n        :param buffer: A buffer containing display data (usually\n                       data returned from :py:func:`~PIL.ImageWin.Dib.tobytes`)\n        \"\"\"\n        self.image.frombytes(buffer)\n\n    def tobytes(self) -> bytes:\n        \"\"\"\n        Copy display memory contents to bytes object.\n\n        :return: A bytes object containing display data.\n        \"\"\"\n        return self.image.tobytes()\n\n\nclass Window:\n    \"\"\"Create a Window with the given title size.\"\"\"\n\n    def __init__(\n        self, title: str = \"PIL\", width: int | None = None, height: int | None = None\n    ) -> None:\n        self.hwnd = Image.core.createwindow(\n            title, self.__dispatcher, width or 0, height or 0\n        )\n\n    def __dispatcher(self, action, *args):\n        return getattr(self, f\"ui_handle_{action}\")(*args)\n\n    def ui_handle_clear(self, dc, x0, y0, x1, y1):\n        pass\n\n    def ui_handle_damage(self, x0, y0, x1, y1):\n        pass\n\n    def ui_handle_destroy(self) -> None:\n        pass\n\n    def ui_handle_repair(self, dc, x0, y0, x1, y1):\n        pass\n\n    def ui_handle_resize(self, width, height):\n        pass\n\n    def mainloop(self) -> None:\n        Image.core.eventloop()\n\n\nclass ImageWindow(Window):\n    \"\"\"Create an image window which displays the given image.\"\"\"\n\n    def __init__(self, image, title=\"PIL\"):\n        if not isinstance(image, Dib):\n            image = Dib(image)\n        self.image = image\n        width, height = image.size\n        super().__init__(title, width=width, height=height)\n\n    def ui_handle_repair(self, dc, x0, y0, x1, y1):\n        self.image.draw(dc, (x0, y0, x1, y1))\n", "src/PIL/ImagePalette.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# image palette object\n#\n# History:\n# 1996-03-11 fl   Rewritten.\n# 1997-01-03 fl   Up and running.\n# 1997-08-23 fl   Added load hack\n# 2001-04-16 fl   Fixed randint shadow bug in random()\n#\n# Copyright (c) 1997-2001 by Secret Labs AB\n# Copyright (c) 1996-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport array\nfrom typing import IO, TYPE_CHECKING, Sequence\n\nfrom . import GimpGradientFile, GimpPaletteFile, ImageColor, PaletteFile\n\nif TYPE_CHECKING:\n    from . import Image\n\n\nclass ImagePalette:\n    \"\"\"\n    Color palette for palette mapped images\n\n    :param mode: The mode to use for the palette. See:\n        :ref:`concept-modes`. Defaults to \"RGB\"\n    :param palette: An optional palette. If given, it must be a bytearray,\n        an array or a list of ints between 0-255. The list must consist of\n        all channels for one color followed by the next color (e.g. RGBRGBRGB).\n        Defaults to an empty palette.\n    \"\"\"\n\n    def __init__(self, mode: str = \"RGB\", palette: Sequence[int] | None = None) -> None:\n        self.mode = mode\n        self.rawmode = None  # if set, palette contains raw data\n        self.palette = palette or bytearray()\n        self.dirty: int | None = None\n\n    @property\n    def palette(self):\n        return self._palette\n\n    @palette.setter\n    def palette(self, palette):\n        self._colors = None\n        self._palette = palette\n\n    @property\n    def colors(self) -> dict[tuple[int, int, int] | tuple[int, int, int, int], int]:\n        if self._colors is None:\n            mode_len = len(self.mode)\n            self._colors = {}\n            for i in range(0, len(self.palette), mode_len):\n                color = tuple(self.palette[i : i + mode_len])\n                if color in self._colors:\n                    continue\n                self._colors[color] = i // mode_len\n        return self._colors\n\n    @colors.setter\n    def colors(\n        self, colors: dict[tuple[int, int, int] | tuple[int, int, int, int], int]\n    ) -> None:\n        self._colors = colors\n\n    def copy(self) -> ImagePalette:\n        new = ImagePalette()\n\n        new.mode = self.mode\n        new.rawmode = self.rawmode\n        if self.palette is not None:\n            new.palette = self.palette[:]\n        new.dirty = self.dirty\n\n        return new\n\n    def getdata(self) -> tuple[str, bytes]:\n        \"\"\"\n        Get palette contents in format suitable for the low-level\n        ``im.putpalette`` primitive.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            return self.rawmode, self.palette\n        return self.mode, self.tobytes()\n\n    def tobytes(self) -> bytes:\n        \"\"\"Convert palette to bytes.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            msg = \"palette contains raw palette data\"\n            raise ValueError(msg)\n        if isinstance(self.palette, bytes):\n            return self.palette\n        arr = array.array(\"B\", self.palette)\n        return arr.tobytes()\n\n    # Declare tostring as an alias for tobytes\n    tostring = tobytes\n\n    def _new_color_index(\n        self, image: Image.Image | None = None, e: Exception | None = None\n    ) -> int:\n        if not isinstance(self.palette, bytearray):\n            self._palette = bytearray(self.palette)\n        index = len(self.palette) // 3\n        special_colors: tuple[int | tuple[int, ...] | None, ...] = ()\n        if image:\n            special_colors = (\n                image.info.get(\"background\"),\n                image.info.get(\"transparency\"),\n            )\n            while index in special_colors:\n                index += 1\n        if index >= 256:\n            if image:\n                # Search for an unused index\n                for i, count in reversed(list(enumerate(image.histogram()))):\n                    if count == 0 and i not in special_colors:\n                        index = i\n                        break\n            if index >= 256:\n                msg = \"cannot allocate more than 256 colors\"\n                raise ValueError(msg) from e\n        return index\n\n    def getcolor(\n        self,\n        color: tuple[int, int, int] | tuple[int, int, int, int],\n        image: Image.Image | None = None,\n    ) -> int:\n        \"\"\"Given an rgb tuple, allocate palette entry.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            msg = \"palette contains raw palette data\"\n            raise ValueError(msg)\n        if isinstance(color, tuple):\n            if self.mode == \"RGB\":\n                if len(color) == 4:\n                    if color[3] != 255:\n                        msg = \"cannot add non-opaque RGBA color to RGB palette\"\n                        raise ValueError(msg)\n                    color = color[:3]\n            elif self.mode == \"RGBA\":\n                if len(color) == 3:\n                    color += (255,)\n            try:\n                return self.colors[color]\n            except KeyError as e:\n                # allocate new color slot\n                index = self._new_color_index(image, e)\n                self.colors[color] = index\n                if index * 3 < len(self.palette):\n                    self._palette = (\n                        self.palette[: index * 3]\n                        + bytes(color)\n                        + self.palette[index * 3 + 3 :]\n                    )\n                else:\n                    self._palette += bytes(color)\n                self.dirty = 1\n                return index\n        else:\n            msg = f\"unknown color specifier: {repr(color)}\"  # type: ignore[unreachable]\n            raise ValueError(msg)\n\n    def save(self, fp: str | IO[str]) -> None:\n        \"\"\"Save palette to text file.\n\n        .. warning:: This method is experimental.\n        \"\"\"\n        if self.rawmode:\n            msg = \"palette contains raw palette data\"\n            raise ValueError(msg)\n        if isinstance(fp, str):\n            fp = open(fp, \"w\")\n        fp.write(\"# Palette\\n\")\n        fp.write(f\"# Mode: {self.mode}\\n\")\n        for i in range(256):\n            fp.write(f\"{i}\")\n            for j in range(i * len(self.mode), (i + 1) * len(self.mode)):\n                try:\n                    fp.write(f\" {self.palette[j]}\")\n                except IndexError:\n                    fp.write(\" 0\")\n            fp.write(\"\\n\")\n        fp.close()\n\n\n# --------------------------------------------------------------------\n# Internal\n\n\ndef raw(rawmode, data) -> ImagePalette:\n    palette = ImagePalette()\n    palette.rawmode = rawmode\n    palette.palette = data\n    palette.dirty = 1\n    return palette\n\n\n# --------------------------------------------------------------------\n# Factories\n\n\ndef make_linear_lut(black, white):\n    if black == 0:\n        return [white * i // 255 for i in range(256)]\n\n    msg = \"unavailable when black is non-zero\"\n    raise NotImplementedError(msg)  # FIXME\n\n\ndef make_gamma_lut(exp: float) -> list[int]:\n    return [int(((i / 255.0) ** exp) * 255.0 + 0.5) for i in range(256)]\n\n\ndef negative(mode: str = \"RGB\") -> ImagePalette:\n    palette = list(range(256 * len(mode)))\n    palette.reverse()\n    return ImagePalette(mode, [i // len(mode) for i in palette])\n\n\ndef random(mode: str = \"RGB\") -> ImagePalette:\n    from random import randint\n\n    palette = [randint(0, 255) for _ in range(256 * len(mode))]\n    return ImagePalette(mode, palette)\n\n\ndef sepia(white: str = \"#fff0c0\") -> ImagePalette:\n    bands = [make_linear_lut(0, band) for band in ImageColor.getrgb(white)]\n    return ImagePalette(\"RGB\", [bands[i % 3][i // 3] for i in range(256 * 3)])\n\n\ndef wedge(mode: str = \"RGB\") -> ImagePalette:\n    palette = list(range(256 * len(mode)))\n    return ImagePalette(mode, [i // len(mode) for i in palette])\n\n\ndef load(filename):\n    # FIXME: supports GIMP gradients only\n\n    with open(filename, \"rb\") as fp:\n        for paletteHandler in [\n            GimpPaletteFile.GimpPaletteFile,\n            GimpGradientFile.GimpGradientFile,\n            PaletteFile.PaletteFile,\n        ]:\n            try:\n                fp.seek(0)\n                lut = paletteHandler(fp).getpalette()\n                if lut:\n                    break\n            except (SyntaxError, ValueError):\n                pass\n        else:\n            msg = \"cannot load palette\"\n            raise OSError(msg)\n\n    return lut  # data, rawmode\n", "src/PIL/ImageTransform.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# transform wrappers\n#\n# History:\n# 2002-04-08 fl   Created\n#\n# Copyright (c) 2002 by Secret Labs AB\n# Copyright (c) 2002 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import Any, Sequence\n\nfrom . import Image\n\n\nclass Transform(Image.ImageTransformHandler):\n    \"\"\"Base class for other transforms defined in :py:mod:`~PIL.ImageTransform`.\"\"\"\n\n    method: Image.Transform\n\n    def __init__(self, data: Sequence[Any]) -> None:\n        self.data = data\n\n    def getdata(self) -> tuple[Image.Transform, Sequence[int]]:\n        return self.method, self.data\n\n    def transform(\n        self,\n        size: tuple[int, int],\n        image: Image.Image,\n        **options: Any,\n    ) -> Image.Image:\n        \"\"\"Perform the transform. Called from :py:meth:`.Image.transform`.\"\"\"\n        # can be overridden\n        method, data = self.getdata()\n        return image.transform(size, method, data, **options)\n\n\nclass AffineTransform(Transform):\n    \"\"\"\n    Define an affine image transform.\n\n    This function takes a 6-tuple (a, b, c, d, e, f) which contain the first\n    two rows from an affine transform matrix. For each pixel (x, y) in the\n    output image, the new value is taken from a position (a x + b y + c,\n    d x + e y + f) in the input image, rounded to nearest pixel.\n\n    This function can be used to scale, translate, rotate, and shear the\n    original image.\n\n    See :py:meth:`.Image.transform`\n\n    :param matrix: A 6-tuple (a, b, c, d, e, f) containing the first two rows\n        from an affine transform matrix.\n    \"\"\"\n\n    method = Image.Transform.AFFINE\n\n\nclass PerspectiveTransform(Transform):\n    \"\"\"\n    Define a perspective image transform.\n\n    This function takes an 8-tuple (a, b, c, d, e, f, g, h). For each pixel\n    (x, y) in the output image, the new value is taken from a position\n    ((a x + b y + c) / (g x + h y + 1), (d x + e y + f) / (g x + h y + 1)) in\n    the input image, rounded to nearest pixel.\n\n    This function can be used to scale, translate, rotate, and shear the\n    original image.\n\n    See :py:meth:`.Image.transform`\n\n    :param matrix: An 8-tuple (a, b, c, d, e, f, g, h).\n    \"\"\"\n\n    method = Image.Transform.PERSPECTIVE\n\n\nclass ExtentTransform(Transform):\n    \"\"\"\n    Define a transform to extract a subregion from an image.\n\n    Maps a rectangle (defined by two corners) from the image to a rectangle of\n    the given size. The resulting image will contain data sampled from between\n    the corners, such that (x0, y0) in the input image will end up at (0,0) in\n    the output image, and (x1, y1) at size.\n\n    This method can be used to crop, stretch, shrink, or mirror an arbitrary\n    rectangle in the current image. It is slightly slower than crop, but about\n    as fast as a corresponding resize operation.\n\n    See :py:meth:`.Image.transform`\n\n    :param bbox: A 4-tuple (x0, y0, x1, y1) which specifies two points in the\n        input image's coordinate system. See :ref:`coordinate-system`.\n    \"\"\"\n\n    method = Image.Transform.EXTENT\n\n\nclass QuadTransform(Transform):\n    \"\"\"\n    Define a quad image transform.\n\n    Maps a quadrilateral (a region defined by four corners) from the image to a\n    rectangle of the given size.\n\n    See :py:meth:`.Image.transform`\n\n    :param xy: An 8-tuple (x0, y0, x1, y1, x2, y2, x3, y3) which contain the\n        upper left, lower left, lower right, and upper right corner of the\n        source quadrilateral.\n    \"\"\"\n\n    method = Image.Transform.QUAD\n\n\nclass MeshTransform(Transform):\n    \"\"\"\n    Define a mesh image transform.  A mesh transform consists of one or more\n    individual quad transforms.\n\n    See :py:meth:`.Image.transform`\n\n    :param data: A list of (bbox, quad) tuples.\n    \"\"\"\n\n    method = Image.Transform.MESH\n", "src/PIL/MpoImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# MPO file handling\n#\n# See \"Multi-Picture Format\" (CIPA DC-007-Translation 2009, Standard of the\n# Camera & Imaging Products Association)\n#\n# The multi-picture object combines multiple JPEG images (with a modified EXIF\n# data format) into a single file. While it can theoretically be used much like\n# a GIF animation, it is commonly used to represent 3D photographs and is (as\n# of this writing) the most commonly used format by 3D cameras.\n#\n# History:\n# 2014-03-13 Feneric   Created\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport itertools\nimport os\nimport struct\nfrom typing import IO\n\nfrom . import (\n    Image,\n    ImageSequence,\n    JpegImagePlugin,\n    TiffImagePlugin,\n)\nfrom ._binary import o32le\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    JpegImagePlugin._save(im, fp, filename)\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    append_images = im.encoderinfo.get(\"append_images\", [])\n    if not append_images and not getattr(im, \"is_animated\", False):\n        _save(im, fp, filename)\n        return\n\n    mpf_offset = 28\n    offsets: list[int] = []\n    for imSequence in itertools.chain([im], append_images):\n        for im_frame in ImageSequence.Iterator(imSequence):\n            if not offsets:\n                # APP2 marker\n                im_frame.encoderinfo[\"extra\"] = (\n                    b\"\\xFF\\xE2\" + struct.pack(\">H\", 6 + 82) + b\"MPF\\0\" + b\" \" * 82\n                )\n                exif = im_frame.encoderinfo.get(\"exif\")\n                if isinstance(exif, Image.Exif):\n                    exif = exif.tobytes()\n                    im_frame.encoderinfo[\"exif\"] = exif\n                if exif:\n                    mpf_offset += 4 + len(exif)\n\n                JpegImagePlugin._save(im_frame, fp, filename)\n                offsets.append(fp.tell())\n            else:\n                im_frame.save(fp, \"JPEG\")\n                offsets.append(fp.tell() - offsets[-1])\n\n    ifd = TiffImagePlugin.ImageFileDirectory_v2()\n    ifd[0xB000] = b\"0100\"\n    ifd[0xB001] = len(offsets)\n\n    mpentries = b\"\"\n    data_offset = 0\n    for i, size in enumerate(offsets):\n        if i == 0:\n            mptype = 0x030000  # Baseline MP Primary Image\n        else:\n            mptype = 0x000000  # Undefined\n        mpentries += struct.pack(\"<LLLHH\", mptype, size, data_offset, 0, 0)\n        if i == 0:\n            data_offset -= mpf_offset\n        data_offset += size\n    ifd[0xB002] = mpentries\n\n    fp.seek(mpf_offset)\n    fp.write(b\"II\\x2A\\x00\" + o32le(8) + ifd.tobytes(8))\n    fp.seek(0, os.SEEK_END)\n\n\n##\n# Image plugin for MPO images.\n\n\nclass MpoImageFile(JpegImagePlugin.JpegImageFile):\n    format = \"MPO\"\n    format_description = \"MPO (CIPA DC-007)\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        self.fp.seek(0)  # prep the fp in order to pass the JPEG test\n        JpegImagePlugin.JpegImageFile._open(self)\n        self._after_jpeg_open()\n\n    def _after_jpeg_open(self, mpheader=None):\n        self.mpinfo = mpheader if mpheader is not None else self._getmp()\n        self.n_frames = self.mpinfo[0xB001]\n        self.__mpoffsets = [\n            mpent[\"DataOffset\"] + self.info[\"mpoffset\"] for mpent in self.mpinfo[0xB002]\n        ]\n        self.__mpoffsets[0] = 0\n        # Note that the following assertion will only be invalid if something\n        # gets broken within JpegImagePlugin.\n        assert self.n_frames == len(self.__mpoffsets)\n        del self.info[\"mpoffset\"]  # no longer needed\n        self.is_animated = self.n_frames > 1\n        self._fp = self.fp  # FIXME: hack\n        self._fp.seek(self.__mpoffsets[0])  # get ready to read first frame\n        self.__frame = 0\n        self.offset = 0\n        # for now we can only handle reading and individual frame extraction\n        self.readonly = 1\n\n    def load_seek(self, pos: int) -> None:\n        self._fp.seek(pos)\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        self.fp = self._fp\n        self.offset = self.__mpoffsets[frame]\n\n        original_exif = self.info.get(\"exif\")\n        if \"exif\" in self.info:\n            del self.info[\"exif\"]\n\n        self.fp.seek(self.offset + 2)  # skip SOI marker\n        if not self.fp.read(2):\n            msg = \"No data found for frame\"\n            raise ValueError(msg)\n        self.fp.seek(self.offset)\n        JpegImagePlugin.JpegImageFile._open(self)\n        if self.info.get(\"exif\") != original_exif:\n            self._reload_exif()\n\n        self.tile = [(\"jpeg\", (0, 0) + self.size, self.offset, self.tile[0][-1])]\n        self.__frame = frame\n\n    def tell(self) -> int:\n        return self.__frame\n\n    @staticmethod\n    def adopt(jpeg_instance, mpheader=None):\n        \"\"\"\n        Transform the instance of JpegImageFile into\n        an instance of MpoImageFile.\n        After the call, the JpegImageFile is extended\n        to be an MpoImageFile.\n\n        This is essentially useful when opening a JPEG\n        file that reveals itself as an MPO, to avoid\n        double call to _open.\n        \"\"\"\n        jpeg_instance.__class__ = MpoImageFile\n        jpeg_instance._after_jpeg_open(mpheader)\n        return jpeg_instance\n\n\n# ---------------------------------------------------------------------\n# Registry stuff\n\n# Note that since MPO shares a factory with JPEG, we do not need to do a\n# separate registration for it here.\n# Image.register_open(MpoImageFile.format,\n#                     JpegImagePlugin.jpeg_factory, _accept)\nImage.register_save(MpoImageFile.format, _save)\nImage.register_save_all(MpoImageFile.format, _save_all)\n\nImage.register_extension(MpoImageFile.format, \".mpo\")\n\nImage.register_mime(MpoImageFile.format, \"image/mpo\")\n", "src/PIL/BlpImagePlugin.py": "\"\"\"\nBlizzard Mipmap Format (.blp)\nJerome Leclanche <jerome@leclan.ch>\n\nThe contents of this file are hereby released in the public domain (CC0)\nFull text of the CC0 license:\n  https://creativecommons.org/publicdomain/zero/1.0/\n\nBLP1 files, used mostly in Warcraft III, are not fully supported.\nAll types of BLP2 files used in World of Warcraft are supported.\n\nThe BLP file structure consists of a header, up to 16 mipmaps of the\ntexture\n\nTexture sizes must be powers of two, though the two dimensions do\nnot have to be equal; 512x256 is valid, but 512x200 is not.\nThe first mipmap (mipmap #0) is the full size image; each subsequent\nmipmap halves both dimensions. The final mipmap should be 1x1.\n\nBLP files come in many different flavours:\n* JPEG-compressed (type == 0) - only supported for BLP1.\n* RAW images (type == 1, encoding == 1). Each mipmap is stored as an\n  array of 8-bit values, one per pixel, left to right, top to bottom.\n  Each value is an index to the palette.\n* DXT-compressed (type == 1, encoding == 2):\n- DXT1 compression is used if alpha_encoding == 0.\n  - An additional alpha bit is used if alpha_depth == 1.\n  - DXT3 compression is used if alpha_encoding == 1.\n  - DXT5 compression is used if alpha_encoding == 7.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport abc\nimport os\nimport struct\nfrom enum import IntEnum\nfrom io import BytesIO\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n\nclass Format(IntEnum):\n    JPEG = 0\n\n\nclass Encoding(IntEnum):\n    UNCOMPRESSED = 1\n    DXT = 2\n    UNCOMPRESSED_RAW_BGRA = 3\n\n\nclass AlphaEncoding(IntEnum):\n    DXT1 = 0\n    DXT3 = 1\n    DXT5 = 7\n\n\ndef unpack_565(i: int) -> tuple[int, int, int]:\n    return ((i >> 11) & 0x1F) << 3, ((i >> 5) & 0x3F) << 2, (i & 0x1F) << 3\n\n\ndef decode_dxt1(\n    data: bytes, alpha: bool = False\n) -> tuple[bytearray, bytearray, bytearray, bytearray]:\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n\n    blocks = len(data) // 8  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n\n    for block_index in range(blocks):\n        # Decode next 8-byte block.\n        idx = block_index * 8\n        color0, color1, bits = struct.unpack_from(\"<HHI\", data, idx)\n\n        r0, g0, b0 = unpack_565(color0)\n        r1, g1, b1 = unpack_565(color1)\n\n        # Decode this block into 4x4 pixels\n        # Accumulate the results onto our 4 row accumulators\n        for j in range(4):\n            for i in range(4):\n                # get next control op and generate a pixel\n\n                control = bits & 3\n                bits = bits >> 2\n\n                a = 0xFF\n                if control == 0:\n                    r, g, b = r0, g0, b0\n                elif control == 1:\n                    r, g, b = r1, g1, b1\n                elif control == 2:\n                    if color0 > color1:\n                        r = (2 * r0 + r1) // 3\n                        g = (2 * g0 + g1) // 3\n                        b = (2 * b0 + b1) // 3\n                    else:\n                        r = (r0 + r1) // 2\n                        g = (g0 + g1) // 2\n                        b = (b0 + b1) // 2\n                elif control == 3:\n                    if color0 > color1:\n                        r = (2 * r1 + r0) // 3\n                        g = (2 * g1 + g0) // 3\n                        b = (2 * b1 + b0) // 3\n                    else:\n                        r, g, b, a = 0, 0, 0, 0\n\n                if alpha:\n                    ret[j].extend([r, g, b, a])\n                else:\n                    ret[j].extend([r, g, b])\n\n    return ret\n\n\ndef decode_dxt3(data: bytes) -> tuple[bytearray, bytearray, bytearray, bytearray]:\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4*width pixels)\n    \"\"\"\n\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n\n    for block_index in range(blocks):\n        idx = block_index * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.\n        bits = struct.unpack_from(\"<8B\", block)\n        color0, color1 = struct.unpack_from(\"<HH\", block, 8)\n\n        (code,) = struct.unpack_from(\"<I\", block, 12)\n\n        r0, g0, b0 = unpack_565(color0)\n        r1, g1, b1 = unpack_565(color1)\n\n        for j in range(4):\n            high = False  # Do we want the higher bits?\n            for i in range(4):\n                alphacode_index = (4 * j + i) // 2\n                a = bits[alphacode_index]\n                if high:\n                    high = False\n                    a >>= 4\n                else:\n                    high = True\n                    a &= 0xF\n                a *= 17  # We get a value between 0 and 15\n\n                color_code = (code >> 2 * (4 * j + i)) & 0x03\n\n                if color_code == 0:\n                    r, g, b = r0, g0, b0\n                elif color_code == 1:\n                    r, g, b = r1, g1, b1\n                elif color_code == 2:\n                    r = (2 * r0 + r1) // 3\n                    g = (2 * g0 + g1) // 3\n                    b = (2 * b0 + b1) // 3\n                elif color_code == 3:\n                    r = (2 * r1 + r0) // 3\n                    g = (2 * g1 + g0) // 3\n                    b = (2 * b1 + b0) // 3\n\n                ret[j].extend([r, g, b, a])\n\n    return ret\n\n\ndef decode_dxt5(data: bytes) -> tuple[bytearray, bytearray, bytearray, bytearray]:\n    \"\"\"\n    input: one \"row\" of data (i.e. will produce 4 * width pixels)\n    \"\"\"\n\n    blocks = len(data) // 16  # number of blocks in row\n    ret = (bytearray(), bytearray(), bytearray(), bytearray())\n\n    for block_index in range(blocks):\n        idx = block_index * 16\n        block = data[idx : idx + 16]\n        # Decode next 16-byte block.\n        a0, a1 = struct.unpack_from(\"<BB\", block)\n\n        bits = struct.unpack_from(\"<6B\", block, 2)\n        alphacode1 = bits[2] | (bits[3] << 8) | (bits[4] << 16) | (bits[5] << 24)\n        alphacode2 = bits[0] | (bits[1] << 8)\n\n        color0, color1 = struct.unpack_from(\"<HH\", block, 8)\n\n        (code,) = struct.unpack_from(\"<I\", block, 12)\n\n        r0, g0, b0 = unpack_565(color0)\n        r1, g1, b1 = unpack_565(color1)\n\n        for j in range(4):\n            for i in range(4):\n                # get next control op and generate a pixel\n                alphacode_index = 3 * (4 * j + i)\n\n                if alphacode_index <= 12:\n                    alphacode = (alphacode2 >> alphacode_index) & 0x07\n                elif alphacode_index == 15:\n                    alphacode = (alphacode2 >> 15) | ((alphacode1 << 1) & 0x06)\n                else:  # alphacode_index >= 18 and alphacode_index <= 45\n                    alphacode = (alphacode1 >> (alphacode_index - 16)) & 0x07\n\n                if alphacode == 0:\n                    a = a0\n                elif alphacode == 1:\n                    a = a1\n                elif a0 > a1:\n                    a = ((8 - alphacode) * a0 + (alphacode - 1) * a1) // 7\n                elif alphacode == 6:\n                    a = 0\n                elif alphacode == 7:\n                    a = 255\n                else:\n                    a = ((6 - alphacode) * a0 + (alphacode - 1) * a1) // 5\n\n                color_code = (code >> 2 * (4 * j + i)) & 0x03\n\n                if color_code == 0:\n                    r, g, b = r0, g0, b0\n                elif color_code == 1:\n                    r, g, b = r1, g1, b1\n                elif color_code == 2:\n                    r = (2 * r0 + r1) // 3\n                    g = (2 * g0 + g1) // 3\n                    b = (2 * b0 + b1) // 3\n                elif color_code == 3:\n                    r = (2 * r1 + r0) // 3\n                    g = (2 * g1 + g0) // 3\n                    b = (2 * b1 + b0) // 3\n\n                ret[j].extend([r, g, b, a])\n\n    return ret\n\n\nclass BLPFormatError(NotImplementedError):\n    pass\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] in (b\"BLP1\", b\"BLP2\")\n\n\nclass BlpImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Blizzard Mipmap Format\n    \"\"\"\n\n    format = \"BLP\"\n    format_description = \"Blizzard Mipmap Format\"\n\n    def _open(self) -> None:\n        self.magic = self.fp.read(4)\n\n        self.fp.seek(5, os.SEEK_CUR)\n        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self.fp.read(1))\n\n        self.fp.seek(2, os.SEEK_CUR)\n        self._size = struct.unpack(\"<II\", self.fp.read(8))\n\n        if self.magic in (b\"BLP1\", b\"BLP2\"):\n            decoder = self.magic.decode()\n        else:\n            msg = f\"Bad BLP magic {repr(self.magic)}\"\n            raise BLPFormatError(msg)\n\n        self._mode = \"RGBA\" if self._blp_alpha_depth else \"RGB\"\n        self.tile = [(decoder, (0, 0) + self.size, 0, (self.mode, 0, 1))]\n\n\nclass _BLPBaseDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        try:\n            self._read_blp_header()\n            self._load()\n        except struct.error as e:\n            msg = \"Truncated BLP file\"\n            raise OSError(msg) from e\n        return -1, 0\n\n    @abc.abstractmethod\n    def _load(self) -> None:\n        pass\n\n    def _read_blp_header(self) -> None:\n        assert self.fd is not None\n        self.fd.seek(4)\n        (self._blp_compression,) = struct.unpack(\"<i\", self._safe_read(4))\n\n        (self._blp_encoding,) = struct.unpack(\"<b\", self._safe_read(1))\n        (self._blp_alpha_depth,) = struct.unpack(\"<b\", self._safe_read(1))\n        (self._blp_alpha_encoding,) = struct.unpack(\"<b\", self._safe_read(1))\n        self.fd.seek(1, os.SEEK_CUR)  # mips\n\n        self.size = struct.unpack(\"<II\", self._safe_read(8))\n\n        if isinstance(self, BLP1Decoder):\n            # Only present for BLP1\n            (self._blp_encoding,) = struct.unpack(\"<i\", self._safe_read(4))\n            self.fd.seek(4, os.SEEK_CUR)  # subtype\n\n        self._blp_offsets = struct.unpack(\"<16I\", self._safe_read(16 * 4))\n        self._blp_lengths = struct.unpack(\"<16I\", self._safe_read(16 * 4))\n\n    def _safe_read(self, length: int) -> bytes:\n        return ImageFile._safe_read(self.fd, length)\n\n    def _read_palette(self) -> list[tuple[int, int, int, int]]:\n        ret = []\n        for i in range(256):\n            try:\n                b, g, r, a = struct.unpack(\"<4B\", self._safe_read(4))\n            except struct.error:\n                break\n            ret.append((b, g, r, a))\n        return ret\n\n    def _read_bgra(self, palette: list[tuple[int, int, int, int]]) -> bytearray:\n        data = bytearray()\n        _data = BytesIO(self._safe_read(self._blp_lengths[0]))\n        while True:\n            try:\n                (offset,) = struct.unpack(\"<B\", _data.read(1))\n            except struct.error:\n                break\n            b, g, r, a = palette[offset]\n            d: tuple[int, ...] = (r, g, b)\n            if self._blp_alpha_depth:\n                d += (a,)\n            data.extend(d)\n        return data\n\n\nclass BLP1Decoder(_BLPBaseDecoder):\n    def _load(self) -> None:\n        if self._blp_compression == Format.JPEG:\n            self._decode_jpeg_stream()\n\n        elif self._blp_compression == 1:\n            if self._blp_encoding in (4, 5):\n                palette = self._read_palette()\n                data = self._read_bgra(palette)\n                self.set_as_raw(data)\n            else:\n                msg = f\"Unsupported BLP encoding {repr(self._blp_encoding)}\"\n                raise BLPFormatError(msg)\n        else:\n            msg = f\"Unsupported BLP compression {repr(self._blp_encoding)}\"\n            raise BLPFormatError(msg)\n\n    def _decode_jpeg_stream(self) -> None:\n        from .JpegImagePlugin import JpegImageFile\n\n        (jpeg_header_size,) = struct.unpack(\"<I\", self._safe_read(4))\n        jpeg_header = self._safe_read(jpeg_header_size)\n        assert self.fd is not None\n        self._safe_read(self._blp_offsets[0] - self.fd.tell())  # What IS this?\n        data = self._safe_read(self._blp_lengths[0])\n        data = jpeg_header + data\n        image = JpegImageFile(BytesIO(data))\n        Image._decompression_bomb_check(image.size)\n        if image.mode == \"CMYK\":\n            decoder_name, extents, offset, args = image.tile[0]\n            image.tile = [(decoder_name, extents, offset, (args[0], \"CMYK\"))]\n        r, g, b = image.convert(\"RGB\").split()\n        reversed_image = Image.merge(\"RGB\", (b, g, r))\n        self.set_as_raw(reversed_image.tobytes())\n\n\nclass BLP2Decoder(_BLPBaseDecoder):\n    def _load(self) -> None:\n        palette = self._read_palette()\n\n        assert self.fd is not None\n        self.fd.seek(self._blp_offsets[0])\n\n        if self._blp_compression == 1:\n            # Uncompressed or DirectX compression\n\n            if self._blp_encoding == Encoding.UNCOMPRESSED:\n                data = self._read_bgra(palette)\n\n            elif self._blp_encoding == Encoding.DXT:\n                data = bytearray()\n                if self._blp_alpha_encoding == AlphaEncoding.DXT1:\n                    linesize = (self.size[0] + 3) // 4 * 8\n                    for yb in range((self.size[1] + 3) // 4):\n                        for d in decode_dxt1(\n                            self._safe_read(linesize), alpha=bool(self._blp_alpha_depth)\n                        ):\n                            data += d\n\n                elif self._blp_alpha_encoding == AlphaEncoding.DXT3:\n                    linesize = (self.size[0] + 3) // 4 * 16\n                    for yb in range((self.size[1] + 3) // 4):\n                        for d in decode_dxt3(self._safe_read(linesize)):\n                            data += d\n\n                elif self._blp_alpha_encoding == AlphaEncoding.DXT5:\n                    linesize = (self.size[0] + 3) // 4 * 16\n                    for yb in range((self.size[1] + 3) // 4):\n                        for d in decode_dxt5(self._safe_read(linesize)):\n                            data += d\n                else:\n                    msg = f\"Unsupported alpha encoding {repr(self._blp_alpha_encoding)}\"\n                    raise BLPFormatError(msg)\n            else:\n                msg = f\"Unknown BLP encoding {repr(self._blp_encoding)}\"\n                raise BLPFormatError(msg)\n\n        else:\n            msg = f\"Unknown BLP compression {repr(self._blp_compression)}\"\n            raise BLPFormatError(msg)\n\n        self.set_as_raw(data)\n\n\nclass BLPEncoder(ImageFile.PyEncoder):\n    _pushes_fd = True\n\n    def _write_palette(self) -> bytes:\n        data = b\"\"\n        palette = self.im.getpalette(\"RGBA\", \"RGBA\")\n        for i in range(len(palette) // 4):\n            r, g, b, a = palette[i * 4 : (i + 1) * 4]\n            data += struct.pack(\"<4B\", b, g, r, a)\n        while len(data) < 256 * 4:\n            data += b\"\\x00\" * 4\n        return data\n\n    def encode(self, bufsize: int) -> tuple[int, int, bytes]:\n        palette_data = self._write_palette()\n\n        offset = 20 + 16 * 4 * 2 + len(palette_data)\n        data = struct.pack(\"<16I\", offset, *((0,) * 15))\n\n        w, h = self.im.size\n        data += struct.pack(\"<16I\", w * h, *((0,) * 15))\n\n        data += palette_data\n\n        for y in range(h):\n            for x in range(w):\n                data += struct.pack(\"<B\", self.im.getpixel((x, y)))\n\n        return len(data), 0, data\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode != \"P\":\n        msg = \"Unsupported BLP image mode\"\n        raise ValueError(msg)\n\n    magic = b\"BLP1\" if im.encoderinfo.get(\"blp_version\") == \"BLP1\" else b\"BLP2\"\n    fp.write(magic)\n\n    fp.write(struct.pack(\"<i\", 1))  # Uncompressed or DirectX compression\n    fp.write(struct.pack(\"<b\", Encoding.UNCOMPRESSED))\n    fp.write(struct.pack(\"<b\", 1 if im.palette.mode == \"RGBA\" else 0))\n    fp.write(struct.pack(\"<b\", 0))  # alpha encoding\n    fp.write(struct.pack(\"<b\", 0))  # mips\n    fp.write(struct.pack(\"<II\", *im.size))\n    if magic == b\"BLP1\":\n        fp.write(struct.pack(\"<i\", 5))\n        fp.write(struct.pack(\"<i\", 0))\n\n    ImageFile._save(im, fp, [(\"BLP\", (0, 0) + im.size, 0, im.mode)])\n\n\nImage.register_open(BlpImageFile.format, BlpImageFile, _accept)\nImage.register_extension(BlpImageFile.format, \".blp\")\nImage.register_decoder(\"BLP1\", BLP1Decoder)\nImage.register_decoder(\"BLP2\", BLP2Decoder)\n\nImage.register_save(BlpImageFile.format, _save)\nImage.register_encoder(\"BLP\", BLPEncoder)\n", "src/PIL/BufrStubImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# BUFR stub adapter\n#\n# Copyright (c) 1996-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific BUFR image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\n# --------------------------------------------------------------------\n# Image adapter\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"BUFR\" or prefix[:4] == b\"ZCZC\"\n\n\nclass BufrStubImageFile(ImageFile.StubImageFile):\n    format = \"BUFR\"\n    format_description = \"BUFR\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        if not _accept(self.fp.read(4)):\n            msg = \"Not a BUFR file\"\n            raise SyntaxError(msg)\n\n        self.fp.seek(offset)\n\n        # make something up\n        self._mode = \"F\"\n        self._size = 1, 1\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"BUFR save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(BufrStubImageFile.format, BufrStubImageFile, _accept)\nImage.register_save(BufrStubImageFile.format, _save)\n\nImage.register_extension(BufrStubImageFile.format, \".bufr\")\n", "src/PIL/PcfFontFile.py": "#\n# THIS IS WORK IN PROGRESS\n#\n# The Python Imaging Library\n# $Id$\n#\n# portable compiled font file parser\n#\n# history:\n# 1997-08-19 fl   created\n# 2003-09-13 fl   fixed loading of unicode fonts\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1997-2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nfrom typing import BinaryIO, Callable\n\nfrom . import FontFile, Image\nfrom ._binary import i8\nfrom ._binary import i16be as b16\nfrom ._binary import i16le as l16\nfrom ._binary import i32be as b32\nfrom ._binary import i32le as l32\n\n# --------------------------------------------------------------------\n# declarations\n\nPCF_MAGIC = 0x70636601  # \"\\x01fcp\"\n\nPCF_PROPERTIES = 1 << 0\nPCF_ACCELERATORS = 1 << 1\nPCF_METRICS = 1 << 2\nPCF_BITMAPS = 1 << 3\nPCF_INK_METRICS = 1 << 4\nPCF_BDF_ENCODINGS = 1 << 5\nPCF_SWIDTHS = 1 << 6\nPCF_GLYPH_NAMES = 1 << 7\nPCF_BDF_ACCELERATORS = 1 << 8\n\nBYTES_PER_ROW: list[Callable[[int], int]] = [\n    lambda bits: ((bits + 7) >> 3),\n    lambda bits: ((bits + 15) >> 3) & ~1,\n    lambda bits: ((bits + 31) >> 3) & ~3,\n    lambda bits: ((bits + 63) >> 3) & ~7,\n]\n\n\ndef sz(s: bytes, o: int) -> bytes:\n    return s[o : s.index(b\"\\0\", o)]\n\n\nclass PcfFontFile(FontFile.FontFile):\n    \"\"\"Font file plugin for the X11 PCF format.\"\"\"\n\n    name = \"name\"\n\n    def __init__(self, fp: BinaryIO, charset_encoding: str = \"iso8859-1\"):\n        self.charset_encoding = charset_encoding\n\n        magic = l32(fp.read(4))\n        if magic != PCF_MAGIC:\n            msg = \"not a PCF file\"\n            raise SyntaxError(msg)\n\n        super().__init__()\n\n        count = l32(fp.read(4))\n        self.toc = {}\n        for i in range(count):\n            type = l32(fp.read(4))\n            self.toc[type] = l32(fp.read(4)), l32(fp.read(4)), l32(fp.read(4))\n\n        self.fp = fp\n\n        self.info = self._load_properties()\n\n        metrics = self._load_metrics()\n        bitmaps = self._load_bitmaps(metrics)\n        encoding = self._load_encoding()\n\n        #\n        # create glyph structure\n\n        for ch, ix in enumerate(encoding):\n            if ix is not None:\n                (\n                    xsize,\n                    ysize,\n                    left,\n                    right,\n                    width,\n                    ascent,\n                    descent,\n                    attributes,\n                ) = metrics[ix]\n                self.glyph[ch] = (\n                    (width, 0),\n                    (left, descent - ysize, xsize + left, descent),\n                    (0, 0, xsize, ysize),\n                    bitmaps[ix],\n                )\n\n    def _getformat(\n        self, tag: int\n    ) -> tuple[BinaryIO, int, Callable[[bytes], int], Callable[[bytes], int]]:\n        format, size, offset = self.toc[tag]\n\n        fp = self.fp\n        fp.seek(offset)\n\n        format = l32(fp.read(4))\n\n        if format & 4:\n            i16, i32 = b16, b32\n        else:\n            i16, i32 = l16, l32\n\n        return fp, format, i16, i32\n\n    def _load_properties(self) -> dict[bytes, bytes | int]:\n        #\n        # font properties\n\n        properties = {}\n\n        fp, format, i16, i32 = self._getformat(PCF_PROPERTIES)\n\n        nprops = i32(fp.read(4))\n\n        # read property description\n        p = [(i32(fp.read(4)), i8(fp.read(1)), i32(fp.read(4))) for _ in range(nprops)]\n\n        if nprops & 3:\n            fp.seek(4 - (nprops & 3), io.SEEK_CUR)  # pad\n\n        data = fp.read(i32(fp.read(4)))\n\n        for k, s, v in p:\n            property_value: bytes | int = sz(data, v) if s else v\n            properties[sz(data, k)] = property_value\n\n        return properties\n\n    def _load_metrics(self) -> list[tuple[int, int, int, int, int, int, int, int]]:\n        #\n        # font metrics\n\n        metrics: list[tuple[int, int, int, int, int, int, int, int]] = []\n\n        fp, format, i16, i32 = self._getformat(PCF_METRICS)\n\n        append = metrics.append\n\n        if (format & 0xFF00) == 0x100:\n            # \"compressed\" metrics\n            for i in range(i16(fp.read(2))):\n                left = i8(fp.read(1)) - 128\n                right = i8(fp.read(1)) - 128\n                width = i8(fp.read(1)) - 128\n                ascent = i8(fp.read(1)) - 128\n                descent = i8(fp.read(1)) - 128\n                xsize = right - left\n                ysize = ascent + descent\n                append((xsize, ysize, left, right, width, ascent, descent, 0))\n\n        else:\n            # \"jumbo\" metrics\n            for i in range(i32(fp.read(4))):\n                left = i16(fp.read(2))\n                right = i16(fp.read(2))\n                width = i16(fp.read(2))\n                ascent = i16(fp.read(2))\n                descent = i16(fp.read(2))\n                attributes = i16(fp.read(2))\n                xsize = right - left\n                ysize = ascent + descent\n                append((xsize, ysize, left, right, width, ascent, descent, attributes))\n\n        return metrics\n\n    def _load_bitmaps(\n        self, metrics: list[tuple[int, int, int, int, int, int, int, int]]\n    ) -> list[Image.Image]:\n        #\n        # bitmap data\n\n        fp, format, i16, i32 = self._getformat(PCF_BITMAPS)\n\n        nbitmaps = i32(fp.read(4))\n\n        if nbitmaps != len(metrics):\n            msg = \"Wrong number of bitmaps\"\n            raise OSError(msg)\n\n        offsets = [i32(fp.read(4)) for _ in range(nbitmaps)]\n\n        bitmap_sizes = [i32(fp.read(4)) for _ in range(4)]\n\n        # byteorder = format & 4  # non-zero => MSB\n        bitorder = format & 8  # non-zero => MSB\n        padindex = format & 3\n\n        bitmapsize = bitmap_sizes[padindex]\n        offsets.append(bitmapsize)\n\n        data = fp.read(bitmapsize)\n\n        pad = BYTES_PER_ROW[padindex]\n        mode = \"1;R\"\n        if bitorder:\n            mode = \"1\"\n\n        bitmaps = []\n        for i in range(nbitmaps):\n            xsize, ysize = metrics[i][:2]\n            b, e = offsets[i : i + 2]\n            bitmaps.append(\n                Image.frombytes(\"1\", (xsize, ysize), data[b:e], \"raw\", mode, pad(xsize))\n            )\n\n        return bitmaps\n\n    def _load_encoding(self) -> list[int | None]:\n        fp, format, i16, i32 = self._getformat(PCF_BDF_ENCODINGS)\n\n        first_col, last_col = i16(fp.read(2)), i16(fp.read(2))\n        first_row, last_row = i16(fp.read(2)), i16(fp.read(2))\n\n        i16(fp.read(2))  # default\n\n        nencoding = (last_col - first_col + 1) * (last_row - first_row + 1)\n\n        # map character code to bitmap index\n        encoding: list[int | None] = [None] * min(256, nencoding)\n\n        encoding_offsets = [i16(fp.read(2)) for _ in range(nencoding)]\n\n        for i in range(first_col, len(encoding)):\n            try:\n                encoding_offset = encoding_offsets[\n                    ord(bytearray([i]).decode(self.charset_encoding))\n                ]\n                if encoding_offset != 0xFFFF:\n                    encoding[i] = encoding_offset\n            except UnicodeDecodeError:\n                # character is not supported in selected encoding\n                pass\n\n        return encoding\n", "src/PIL/TgaImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# TGA file handling\n#\n# History:\n# 95-09-01 fl   created (reads 24-bit files only)\n# 97-01-04 fl   support more TGA versions, including compressed images\n# 98-07-04 fl   fixed orientation and alpha layer bugs\n# 98-09-11 fl   fixed orientation for runlength decoder\n#\n# Copyright (c) Secret Labs AB 1997-98.\n# Copyright (c) Fredrik Lundh 1995-97.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport warnings\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import o8\nfrom ._binary import o16le as o16\n\n#\n# --------------------------------------------------------------------\n# Read RGA file\n\n\nMODES = {\n    # map imagetype/depth to rawmode\n    (1, 8): \"P\",\n    (3, 1): \"1\",\n    (3, 8): \"L\",\n    (3, 16): \"LA\",\n    (2, 16): \"BGR;5\",\n    (2, 24): \"BGR\",\n    (2, 32): \"BGRA\",\n}\n\n\n##\n# Image plugin for Targa files.\n\n\nclass TgaImageFile(ImageFile.ImageFile):\n    format = \"TGA\"\n    format_description = \"Targa\"\n\n    def _open(self) -> None:\n        # process header\n        assert self.fp is not None\n\n        s = self.fp.read(18)\n\n        id_len = s[0]\n\n        colormaptype = s[1]\n        imagetype = s[2]\n\n        depth = s[16]\n\n        flags = s[17]\n\n        self._size = i16(s, 12), i16(s, 14)\n\n        # validate header fields\n        if (\n            colormaptype not in (0, 1)\n            or self.size[0] <= 0\n            or self.size[1] <= 0\n            or depth not in (1, 8, 16, 24, 32)\n        ):\n            msg = \"not a TGA file\"\n            raise SyntaxError(msg)\n\n        # image mode\n        if imagetype in (3, 11):\n            self._mode = \"L\"\n            if depth == 1:\n                self._mode = \"1\"  # ???\n            elif depth == 16:\n                self._mode = \"LA\"\n        elif imagetype in (1, 9):\n            self._mode = \"P\" if colormaptype else \"L\"\n        elif imagetype in (2, 10):\n            self._mode = \"RGB\"\n            if depth == 32:\n                self._mode = \"RGBA\"\n        else:\n            msg = \"unknown TGA mode\"\n            raise SyntaxError(msg)\n\n        # orientation\n        orientation = flags & 0x30\n        self._flip_horizontally = orientation in [0x10, 0x30]\n        if orientation in [0x20, 0x30]:\n            orientation = 1\n        elif orientation in [0, 0x10]:\n            orientation = -1\n        else:\n            msg = \"unknown TGA orientation\"\n            raise SyntaxError(msg)\n\n        self.info[\"orientation\"] = orientation\n\n        if imagetype & 8:\n            self.info[\"compression\"] = \"tga_rle\"\n\n        if id_len:\n            self.info[\"id_section\"] = self.fp.read(id_len)\n\n        if colormaptype:\n            # read palette\n            start, size, mapdepth = i16(s, 3), i16(s, 5), s[7]\n            if mapdepth == 16:\n                self.palette = ImagePalette.raw(\n                    \"BGR;15\", b\"\\0\" * 2 * start + self.fp.read(2 * size)\n                )\n            elif mapdepth == 24:\n                self.palette = ImagePalette.raw(\n                    \"BGR\", b\"\\0\" * 3 * start + self.fp.read(3 * size)\n                )\n            elif mapdepth == 32:\n                self.palette = ImagePalette.raw(\n                    \"BGRA\", b\"\\0\" * 4 * start + self.fp.read(4 * size)\n                )\n            else:\n                msg = \"unknown TGA map depth\"\n                raise SyntaxError(msg)\n\n        # setup tile descriptor\n        try:\n            rawmode = MODES[(imagetype & 7, depth)]\n            if imagetype & 8:\n                # compressed\n                self.tile = [\n                    (\n                        \"tga_rle\",\n                        (0, 0) + self.size,\n                        self.fp.tell(),\n                        (rawmode, orientation, depth),\n                    )\n                ]\n            else:\n                self.tile = [\n                    (\n                        \"raw\",\n                        (0, 0) + self.size,\n                        self.fp.tell(),\n                        (rawmode, 0, orientation),\n                    )\n                ]\n        except KeyError:\n            pass  # cannot decode\n\n    def load_end(self) -> None:\n        if self._flip_horizontally:\n            assert self.im is not None\n            self.im = self.im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)\n\n\n#\n# --------------------------------------------------------------------\n# Write TGA file\n\n\nSAVE = {\n    \"1\": (\"1\", 1, 0, 3),\n    \"L\": (\"L\", 8, 0, 3),\n    \"LA\": (\"LA\", 16, 0, 3),\n    \"P\": (\"P\", 8, 1, 1),\n    \"RGB\": (\"BGR\", 24, 0, 2),\n    \"RGBA\": (\"BGRA\", 32, 0, 2),\n}\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    try:\n        rawmode, bits, colormaptype, imagetype = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as TGA\"\n        raise OSError(msg) from e\n\n    if \"rle\" in im.encoderinfo:\n        rle = im.encoderinfo[\"rle\"]\n    else:\n        compression = im.encoderinfo.get(\"compression\", im.info.get(\"compression\"))\n        rle = compression == \"tga_rle\"\n    if rle:\n        imagetype += 8\n\n    id_section = im.encoderinfo.get(\"id_section\", im.info.get(\"id_section\", \"\"))\n    id_len = len(id_section)\n    if id_len > 255:\n        id_len = 255\n        id_section = id_section[:255]\n        warnings.warn(\"id_section has been trimmed to 255 characters\")\n\n    if colormaptype:\n        assert im.im is not None\n        palette = im.im.getpalette(\"RGB\", \"BGR\")\n        colormaplength, colormapentry = len(palette) // 3, 24\n    else:\n        colormaplength, colormapentry = 0, 0\n\n    if im.mode in (\"LA\", \"RGBA\"):\n        flags = 8\n    else:\n        flags = 0\n\n    orientation = im.encoderinfo.get(\"orientation\", im.info.get(\"orientation\", -1))\n    if orientation > 0:\n        flags = flags | 0x20\n\n    fp.write(\n        o8(id_len)\n        + o8(colormaptype)\n        + o8(imagetype)\n        + o16(0)  # colormapfirst\n        + o16(colormaplength)\n        + o8(colormapentry)\n        + o16(0)\n        + o16(0)\n        + o16(im.size[0])\n        + o16(im.size[1])\n        + o8(bits)\n        + o8(flags)\n    )\n\n    if id_section:\n        fp.write(id_section)\n\n    if colormaptype:\n        fp.write(palette)\n\n    if rle:\n        ImageFile._save(\n            im, fp, [(\"tga_rle\", (0, 0) + im.size, 0, (rawmode, orientation))]\n        )\n    else:\n        ImageFile._save(\n            im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, orientation))]\n        )\n\n    # write targa version 2 footer\n    fp.write(b\"\\000\" * 8 + b\"TRUEVISION-XFILE.\" + b\"\\000\")\n\n\n#\n# --------------------------------------------------------------------\n# Registry\n\n\nImage.register_open(TgaImageFile.format, TgaImageFile)\nImage.register_save(TgaImageFile.format, _save)\n\nImage.register_extensions(TgaImageFile.format, [\".tga\", \".icb\", \".vda\", \".vst\"])\n\nImage.register_mime(TgaImageFile.format, \"image/x-tga\")\n", "src/PIL/MicImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Microsoft Image Composer support for PIL\n#\n# Notes:\n#       uses TiffImagePlugin.py to read the actual image streams\n#\n# History:\n#       97-01-20 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport olefile\n\nfrom . import Image, TiffImagePlugin\n\n#\n# --------------------------------------------------------------------\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == olefile.MAGIC\n\n\n##\n# Image plugin for Microsoft's Image Composer file format.\n\n\nclass MicImageFile(TiffImagePlugin.TiffImageFile):\n    format = \"MIC\"\n    format_description = \"Microsoft Image Composer\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # read the OLE directory and see if this is a likely\n        # to be a Microsoft Image Composer file\n\n        try:\n            self.ole = olefile.OleFileIO(self.fp)\n        except OSError as e:\n            msg = \"not an MIC file; invalid OLE file\"\n            raise SyntaxError(msg) from e\n\n        # find ACI subfiles with Image members (maybe not the\n        # best way to identify MIC files, but what the... ;-)\n\n        self.images = [\n            path\n            for path in self.ole.listdir()\n            if path[1:] and path[0][-4:] == \".ACI\" and path[1] == \"Image\"\n        ]\n\n        # if we didn't find any images, this is probably not\n        # an MIC file.\n        if not self.images:\n            msg = \"not an MIC file; no image entries\"\n            raise SyntaxError(msg)\n\n        self.frame = -1\n        self._n_frames = len(self.images)\n        self.is_animated = self._n_frames > 1\n\n        self.__fp = self.fp\n        self.seek(0)\n\n    def seek(self, frame):\n        if not self._seek_check(frame):\n            return\n        try:\n            filename = self.images[frame]\n        except IndexError as e:\n            msg = \"no such frame\"\n            raise EOFError(msg) from e\n\n        self.fp = self.ole.openstream(filename)\n\n        TiffImagePlugin.TiffImageFile._open(self)\n\n        self.frame = frame\n\n    def tell(self) -> int:\n        return self.frame\n\n    def close(self) -> None:\n        self.__fp.close()\n        self.ole.close()\n        super().close()\n\n    def __exit__(self, *args: object) -> None:\n        self.__fp.close()\n        self.ole.close()\n        super().__exit__()\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(MicImageFile.format, MicImageFile, _accept)\n\nImage.register_extension(MicImageFile.format, \".mic\")\n", "src/PIL/PcxImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PCX file handling\n#\n# This format was originally used by ZSoft's popular PaintBrush\n# program for the IBM PC.  It is also supported by many MS-DOS and\n# Windows applications, including the Windows PaintBrush program in\n# Windows 3.\n#\n# history:\n# 1995-09-01 fl   Created\n# 1996-05-20 fl   Fixed RGB support\n# 1997-01-03 fl   Fixed 2-bit and 4-bit support\n# 1999-02-03 fl   Fixed 8-bit support (broken in 1.0b1)\n# 1999-02-07 fl   Added write support\n# 2002-06-09 fl   Made 2-bit and 4-bit support a bit more robust\n# 2002-07-30 fl   Seek from to current position, not beginning of file\n# 2003-06-03 fl   Extract DPI settings (info[\"dpi\"])\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport logging\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import o8\nfrom ._binary import o16le as o16\n\nlogger = logging.getLogger(__name__)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[0] == 10 and prefix[1] in [0, 2, 3, 5]\n\n\n##\n# Image plugin for Paintbrush images.\n\n\nclass PcxImageFile(ImageFile.ImageFile):\n    format = \"PCX\"\n    format_description = \"Paintbrush\"\n\n    def _open(self) -> None:\n        # header\n        assert self.fp is not None\n\n        s = self.fp.read(128)\n        if not _accept(s):\n            msg = \"not a PCX file\"\n            raise SyntaxError(msg)\n\n        # image\n        bbox = i16(s, 4), i16(s, 6), i16(s, 8) + 1, i16(s, 10) + 1\n        if bbox[2] <= bbox[0] or bbox[3] <= bbox[1]:\n            msg = \"bad PCX image size\"\n            raise SyntaxError(msg)\n        logger.debug(\"BBox: %s %s %s %s\", *bbox)\n\n        # format\n        version = s[1]\n        bits = s[3]\n        planes = s[65]\n        provided_stride = i16(s, 66)\n        logger.debug(\n            \"PCX version %s, bits %s, planes %s, stride %s\",\n            version,\n            bits,\n            planes,\n            provided_stride,\n        )\n\n        self.info[\"dpi\"] = i16(s, 12), i16(s, 14)\n\n        if bits == 1 and planes == 1:\n            mode = rawmode = \"1\"\n\n        elif bits == 1 and planes in (2, 4):\n            mode = \"P\"\n            rawmode = \"P;%dL\" % planes\n            self.palette = ImagePalette.raw(\"RGB\", s[16:64])\n\n        elif version == 5 and bits == 8 and planes == 1:\n            mode = rawmode = \"L\"\n            # FIXME: hey, this doesn't work with the incremental loader !!!\n            self.fp.seek(-769, io.SEEK_END)\n            s = self.fp.read(769)\n            if len(s) == 769 and s[0] == 12:\n                # check if the palette is linear grayscale\n                for i in range(256):\n                    if s[i * 3 + 1 : i * 3 + 4] != o8(i) * 3:\n                        mode = rawmode = \"P\"\n                        break\n                if mode == \"P\":\n                    self.palette = ImagePalette.raw(\"RGB\", s[1:])\n            self.fp.seek(128)\n\n        elif version == 5 and bits == 8 and planes == 3:\n            mode = \"RGB\"\n            rawmode = \"RGB;L\"\n\n        else:\n            msg = \"unknown PCX mode\"\n            raise OSError(msg)\n\n        self._mode = mode\n        self._size = bbox[2] - bbox[0], bbox[3] - bbox[1]\n\n        # Don't trust the passed in stride.\n        # Calculate the approximate position for ourselves.\n        # CVE-2020-35653\n        stride = (self._size[0] * bits + 7) // 8\n\n        # While the specification states that this must be even,\n        # not all images follow this\n        if provided_stride != stride:\n            stride += stride % 2\n\n        bbox = (0, 0) + self.size\n        logger.debug(\"size: %sx%s\", *self.size)\n\n        self.tile = [(\"pcx\", bbox, self.fp.tell(), (rawmode, planes * stride))]\n\n\n# --------------------------------------------------------------------\n# save PCX files\n\n\nSAVE = {\n    # mode: (version, bits, planes, raw mode)\n    \"1\": (2, 1, 1, \"1\"),\n    \"L\": (5, 8, 1, \"L\"),\n    \"P\": (5, 8, 1, \"P\"),\n    \"RGB\": (5, 8, 3, \"RGB;L\"),\n}\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    try:\n        version, bits, planes, rawmode = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"Cannot save {im.mode} images as PCX\"\n        raise ValueError(msg) from e\n\n    # bytes per plane\n    stride = (im.size[0] * bits + 7) // 8\n    # stride should be even\n    stride += stride % 2\n    # Stride needs to be kept in sync with the PcxEncode.c version.\n    # Ideally it should be passed in in the state, but the bytes value\n    # gets overwritten.\n\n    logger.debug(\n        \"PcxImagePlugin._save: xwidth: %d, bits: %d, stride: %d\",\n        im.size[0],\n        bits,\n        stride,\n    )\n\n    # under windows, we could determine the current screen size with\n    # \"Image.core.display_mode()[1]\", but I think that's overkill...\n\n    screen = im.size\n\n    dpi = 100, 100\n\n    # PCX header\n    fp.write(\n        o8(10)\n        + o8(version)\n        + o8(1)\n        + o8(bits)\n        + o16(0)\n        + o16(0)\n        + o16(im.size[0] - 1)\n        + o16(im.size[1] - 1)\n        + o16(dpi[0])\n        + o16(dpi[1])\n        + b\"\\0\" * 24\n        + b\"\\xFF\" * 24\n        + b\"\\0\"\n        + o8(planes)\n        + o16(stride)\n        + o16(1)\n        + o16(screen[0])\n        + o16(screen[1])\n        + b\"\\0\" * 54\n    )\n\n    assert fp.tell() == 128\n\n    ImageFile._save(im, fp, [(\"pcx\", (0, 0) + im.size, 0, (rawmode, bits * planes))])\n\n    if im.mode == \"P\":\n        # colour palette\n        assert im.im is not None\n\n        fp.write(o8(12))\n        palette = im.im.getpalette(\"RGB\", \"RGB\")\n        palette += b\"\\x00\" * (768 - len(palette))\n        fp.write(palette)  # 768 bytes\n    elif im.mode == \"L\":\n        # grayscale palette\n        fp.write(o8(12))\n        for i in range(256):\n            fp.write(o8(i) * 3)\n\n\n# --------------------------------------------------------------------\n# registry\n\n\nImage.register_open(PcxImageFile.format, PcxImageFile, _accept)\nImage.register_save(PcxImageFile.format, _save)\n\nImage.register_extension(PcxImageFile.format, \".pcx\")\n\nImage.register_mime(PcxImageFile.format, \"image/x-pcx\")\n", "src/PIL/PsdImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# Adobe PSD 2.5/3.0 file handling\n#\n# History:\n# 1995-09-01 fl   Created\n# 1997-01-03 fl   Read most PSD images\n# 1997-01-18 fl   Fixed P and CMYK support\n# 2001-10-21 fl   Added seek/tell support (for layers)\n#\n# Copyright (c) 1997-2001 by Secret Labs AB.\n# Copyright (c) 1995-2001 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i8\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import si16be as si16\nfrom ._binary import si32be as si32\n\nMODES = {\n    # (photoshop mode, bits) -> (pil mode, required channels)\n    (0, 1): (\"1\", 1),\n    (0, 8): (\"L\", 1),\n    (1, 8): (\"L\", 1),\n    (2, 8): (\"P\", 1),\n    (3, 8): (\"RGB\", 3),\n    (4, 8): (\"CMYK\", 4),\n    (7, 8): (\"L\", 1),  # FIXME: multilayer\n    (8, 8): (\"L\", 1),  # duotone\n    (9, 8): (\"LAB\", 3),\n}\n\n\n# --------------------------------------------------------------------.\n# read PSD images\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"8BPS\"\n\n\n##\n# Image plugin for Photoshop images.\n\n\nclass PsdImageFile(ImageFile.ImageFile):\n    format = \"PSD\"\n    format_description = \"Adobe Photoshop\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        read = self.fp.read\n\n        #\n        # header\n\n        s = read(26)\n        if not _accept(s) or i16(s, 4) != 1:\n            msg = \"not a PSD file\"\n            raise SyntaxError(msg)\n\n        psd_bits = i16(s, 22)\n        psd_channels = i16(s, 12)\n        psd_mode = i16(s, 24)\n\n        mode, channels = MODES[(psd_mode, psd_bits)]\n\n        if channels > psd_channels:\n            msg = \"not enough channels\"\n            raise OSError(msg)\n        if mode == \"RGB\" and psd_channels == 4:\n            mode = \"RGBA\"\n            channels = 4\n\n        self._mode = mode\n        self._size = i32(s, 18), i32(s, 14)\n\n        #\n        # color mode data\n\n        size = i32(read(4))\n        if size:\n            data = read(size)\n            if mode == \"P\" and size == 768:\n                self.palette = ImagePalette.raw(\"RGB;L\", data)\n\n        #\n        # image resources\n\n        self.resources = []\n\n        size = i32(read(4))\n        if size:\n            # load resources\n            end = self.fp.tell() + size\n            while self.fp.tell() < end:\n                read(4)  # signature\n                id = i16(read(2))\n                name = read(i8(read(1)))\n                if not (len(name) & 1):\n                    read(1)  # padding\n                data = read(i32(read(4)))\n                if len(data) & 1:\n                    read(1)  # padding\n                self.resources.append((id, name, data))\n                if id == 1039:  # ICC profile\n                    self.info[\"icc_profile\"] = data\n\n        #\n        # layer and mask information\n\n        self.layers = []\n\n        size = i32(read(4))\n        if size:\n            end = self.fp.tell() + size\n            size = i32(read(4))\n            if size:\n                _layer_data = io.BytesIO(ImageFile._safe_read(self.fp, size))\n                self.layers = _layerinfo(_layer_data, size)\n            self.fp.seek(end)\n        self.n_frames = len(self.layers)\n        self.is_animated = self.n_frames > 1\n\n        #\n        # image descriptor\n\n        self.tile = _maketile(self.fp, mode, (0, 0) + self.size, channels)\n\n        # keep the file open\n        self._fp = self.fp\n        self.frame = 1\n        self._min_frame = 1\n\n    def seek(self, layer: int) -> None:\n        if not self._seek_check(layer):\n            return\n\n        # seek to given layer (1..max)\n        try:\n            _, mode, _, tile = self.layers[layer - 1]\n            self._mode = mode\n            self.tile = tile\n            self.frame = layer\n            self.fp = self._fp\n        except IndexError as e:\n            msg = \"no such layer\"\n            raise EOFError(msg) from e\n\n    def tell(self) -> int:\n        # return layer number (0=image, 1..max=layers)\n        return self.frame\n\n\ndef _layerinfo(fp, ct_bytes):\n    # read layerinfo block\n    layers = []\n\n    def read(size):\n        return ImageFile._safe_read(fp, size)\n\n    ct = si16(read(2))\n\n    # sanity check\n    if ct_bytes < (abs(ct) * 20):\n        msg = \"Layer block too short for number of layers requested\"\n        raise SyntaxError(msg)\n\n    for _ in range(abs(ct)):\n        # bounding box\n        y0 = si32(read(4))\n        x0 = si32(read(4))\n        y1 = si32(read(4))\n        x1 = si32(read(4))\n\n        # image info\n        mode = []\n        ct_types = i16(read(2))\n        if ct_types > 4:\n            fp.seek(ct_types * 6 + 12, io.SEEK_CUR)\n            size = i32(read(4))\n            fp.seek(size, io.SEEK_CUR)\n            continue\n\n        for _ in range(ct_types):\n            type = i16(read(2))\n\n            if type == 65535:\n                m = \"A\"\n            else:\n                m = \"RGBA\"[type]\n\n            mode.append(m)\n            read(4)  # size\n\n        # figure out the image mode\n        mode.sort()\n        if mode == [\"R\"]:\n            mode = \"L\"\n        elif mode == [\"B\", \"G\", \"R\"]:\n            mode = \"RGB\"\n        elif mode == [\"A\", \"B\", \"G\", \"R\"]:\n            mode = \"RGBA\"\n        else:\n            mode = None  # unknown\n\n        # skip over blend flags and extra information\n        read(12)  # filler\n        name = \"\"\n        size = i32(read(4))  # length of the extra data field\n        if size:\n            data_end = fp.tell() + size\n\n            length = i32(read(4))\n            if length:\n                fp.seek(length - 16, io.SEEK_CUR)\n\n            length = i32(read(4))\n            if length:\n                fp.seek(length, io.SEEK_CUR)\n\n            length = i8(read(1))\n            if length:\n                # Don't know the proper encoding,\n                # Latin-1 should be a good guess\n                name = read(length).decode(\"latin-1\", \"replace\")\n\n            fp.seek(data_end)\n        layers.append((name, mode, (x0, y0, x1, y1)))\n\n    # get tiles\n    for i, (name, mode, bbox) in enumerate(layers):\n        tile = []\n        for m in mode:\n            t = _maketile(fp, m, bbox, 1)\n            if t:\n                tile.extend(t)\n        layers[i] = name, mode, bbox, tile\n\n    return layers\n\n\ndef _maketile(file, mode, bbox, channels):\n    tile = None\n    read = file.read\n\n    compression = i16(read(2))\n\n    xsize = bbox[2] - bbox[0]\n    ysize = bbox[3] - bbox[1]\n\n    offset = file.tell()\n\n    if compression == 0:\n        #\n        # raw compression\n        tile = []\n        for channel in range(channels):\n            layer = mode[channel]\n            if mode == \"CMYK\":\n                layer += \";I\"\n            tile.append((\"raw\", bbox, offset, layer))\n            offset = offset + xsize * ysize\n\n    elif compression == 1:\n        #\n        # packbits compression\n        i = 0\n        tile = []\n        bytecount = read(channels * ysize * 2)\n        offset = file.tell()\n        for channel in range(channels):\n            layer = mode[channel]\n            if mode == \"CMYK\":\n                layer += \";I\"\n            tile.append((\"packbits\", bbox, offset, layer))\n            for y in range(ysize):\n                offset = offset + i16(bytecount, i)\n                i += 2\n\n    file.seek(offset)\n\n    if offset & 1:\n        read(1)  # padding\n\n    return tile\n\n\n# --------------------------------------------------------------------\n# registry\n\n\nImage.register_open(PsdImageFile.format, PsdImageFile, _accept)\n\nImage.register_extension(PsdImageFile.format, \".psd\")\n\nImage.register_mime(PsdImageFile.format, \"image/vnd.adobe.photoshop\")\n", "src/PIL/_tkinter_finder.py": "\"\"\" Find compiled module linking to Tcl / Tk libraries\n\"\"\"\n\nfrom __future__ import annotations\n\nimport sys\nimport tkinter\n\ntk = getattr(tkinter, \"_tkinter\")\n\ntry:\n    if hasattr(sys, \"pypy_find_executable\"):\n        TKINTER_LIB = tk.tklib_cffi.__file__\n    else:\n        TKINTER_LIB = tk.__file__\nexcept AttributeError:\n    # _tkinter may be compiled directly into Python, in which case __file__ is\n    # not available. load_tkinter_funcs will check the binary first in any case.\n    TKINTER_LIB = None\n\ntk_version = str(tkinter.TkVersion)\n", "src/PIL/QoiImagePlugin.py": "#\n# The Python Imaging Library.\n#\n# QOI support for PIL\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\n\nfrom . import Image, ImageFile\nfrom ._binary import i32be as i32\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"qoif\"\n\n\nclass QoiImageFile(ImageFile.ImageFile):\n    format = \"QOI\"\n    format_description = \"Quite OK Image\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(4)):\n            msg = \"not a QOI file\"\n            raise SyntaxError(msg)\n\n        self._size = tuple(i32(self.fp.read(4)) for i in range(2))\n\n        channels = self.fp.read(1)[0]\n        self._mode = \"RGB\" if channels == 3 else \"RGBA\"\n\n        self.fp.seek(1, os.SEEK_CUR)  # colorspace\n        self.tile = [(\"qoi\", (0, 0) + self._size, self.fp.tell(), None)]\n\n\nclass QoiDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    _previous_pixel: bytes | bytearray | None = None\n    _previously_seen_pixels: dict[int, bytes | bytearray] = {}\n\n    def _add_to_previous_pixels(self, value: bytes | bytearray) -> None:\n        self._previous_pixel = value\n\n        r, g, b, a = value\n        hash_value = (r * 3 + g * 5 + b * 7 + a * 11) % 64\n        self._previously_seen_pixels[hash_value] = value\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n\n        self._previously_seen_pixels = {}\n        self._add_to_previous_pixels(bytearray((0, 0, 0, 255)))\n\n        data = bytearray()\n        bands = Image.getmodebands(self.mode)\n        dest_length = self.state.xsize * self.state.ysize * bands\n        while len(data) < dest_length:\n            byte = self.fd.read(1)[0]\n            value: bytes | bytearray\n            if byte == 0b11111110 and self._previous_pixel:  # QOI_OP_RGB\n                value = bytearray(self.fd.read(3)) + self._previous_pixel[3:]\n            elif byte == 0b11111111:  # QOI_OP_RGBA\n                value = self.fd.read(4)\n            else:\n                op = byte >> 6\n                if op == 0:  # QOI_OP_INDEX\n                    op_index = byte & 0b00111111\n                    value = self._previously_seen_pixels.get(\n                        op_index, bytearray((0, 0, 0, 0))\n                    )\n                elif op == 1 and self._previous_pixel:  # QOI_OP_DIFF\n                    value = bytearray(\n                        (\n                            (self._previous_pixel[0] + ((byte & 0b00110000) >> 4) - 2)\n                            % 256,\n                            (self._previous_pixel[1] + ((byte & 0b00001100) >> 2) - 2)\n                            % 256,\n                            (self._previous_pixel[2] + (byte & 0b00000011) - 2) % 256,\n                            self._previous_pixel[3],\n                        )\n                    )\n                elif op == 2 and self._previous_pixel:  # QOI_OP_LUMA\n                    second_byte = self.fd.read(1)[0]\n                    diff_green = (byte & 0b00111111) - 32\n                    diff_red = ((second_byte & 0b11110000) >> 4) - 8\n                    diff_blue = (second_byte & 0b00001111) - 8\n\n                    value = bytearray(\n                        tuple(\n                            (self._previous_pixel[i] + diff_green + diff) % 256\n                            for i, diff in enumerate((diff_red, 0, diff_blue))\n                        )\n                    )\n                    value += self._previous_pixel[3:]\n                elif op == 3 and self._previous_pixel:  # QOI_OP_RUN\n                    run_length = (byte & 0b00111111) + 1\n                    value = self._previous_pixel\n                    if bands == 3:\n                        value = value[:3]\n                    data += value * run_length\n                    continue\n            self._add_to_previous_pixels(value)\n\n            if bands == 3:\n                value = value[:3]\n            data += value\n        self.set_as_raw(data)\n        return -1, 0\n\n\nImage.register_open(QoiImageFile.format, QoiImageFile, _accept)\nImage.register_decoder(\"qoi\", QoiDecoder)\nImage.register_extension(QoiImageFile.format, \".qoi\")\n", "src/PIL/WebPImagePlugin.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom typing import IO, Any\n\nfrom . import Image, ImageFile\n\ntry:\n    from . import _webp\n\n    SUPPORTED = True\nexcept ImportError:\n    SUPPORTED = False\n\n\n_VALID_WEBP_MODES = {\"RGBX\": True, \"RGBA\": True, \"RGB\": True}\n\n_VALID_WEBP_LEGACY_MODES = {\"RGB\": True, \"RGBA\": True}\n\n_VP8_MODES_BY_IDENTIFIER = {\n    b\"VP8 \": \"RGB\",\n    b\"VP8X\": \"RGBA\",\n    b\"VP8L\": \"RGBA\",  # lossless\n}\n\n\ndef _accept(prefix: bytes) -> bool | str:\n    is_riff_file_format = prefix[:4] == b\"RIFF\"\n    is_webp_file = prefix[8:12] == b\"WEBP\"\n    is_valid_vp8_mode = prefix[12:16] in _VP8_MODES_BY_IDENTIFIER\n\n    if is_riff_file_format and is_webp_file and is_valid_vp8_mode:\n        if not SUPPORTED:\n            return (\n                \"image file could not be identified because WEBP support not installed\"\n            )\n        return True\n    return False\n\n\nclass WebPImageFile(ImageFile.ImageFile):\n    format = \"WEBP\"\n    format_description = \"WebP image\"\n    __loaded = 0\n    __logical_frame = 0\n\n    def _open(self) -> None:\n        if not _webp.HAVE_WEBPANIM:\n            # Legacy mode\n            data, width, height, self._mode, icc_profile, exif = _webp.WebPDecode(\n                self.fp.read()\n            )\n            if icc_profile:\n                self.info[\"icc_profile\"] = icc_profile\n            if exif:\n                self.info[\"exif\"] = exif\n            self._size = width, height\n            self.fp = BytesIO(data)\n            self.tile = [(\"raw\", (0, 0) + self.size, 0, self.mode)]\n            self.n_frames = 1\n            self.is_animated = False\n            return\n\n        # Use the newer AnimDecoder API to parse the (possibly) animated file,\n        # and access muxed chunks like ICC/EXIF/XMP.\n        self._decoder = _webp.WebPAnimDecoder(self.fp.read())\n\n        # Get info from decoder\n        width, height, loop_count, bgcolor, frame_count, mode = self._decoder.get_info()\n        self._size = width, height\n        self.info[\"loop\"] = loop_count\n        bg_a, bg_r, bg_g, bg_b = (\n            (bgcolor >> 24) & 0xFF,\n            (bgcolor >> 16) & 0xFF,\n            (bgcolor >> 8) & 0xFF,\n            bgcolor & 0xFF,\n        )\n        self.info[\"background\"] = (bg_r, bg_g, bg_b, bg_a)\n        self.n_frames = frame_count\n        self.is_animated = self.n_frames > 1\n        self._mode = \"RGB\" if mode == \"RGBX\" else mode\n        self.rawmode = mode\n        self.tile = []\n\n        # Attempt to read ICC / EXIF / XMP chunks from file\n        icc_profile = self._decoder.get_chunk(\"ICCP\")\n        exif = self._decoder.get_chunk(\"EXIF\")\n        xmp = self._decoder.get_chunk(\"XMP \")\n        if icc_profile:\n            self.info[\"icc_profile\"] = icc_profile\n        if exif:\n            self.info[\"exif\"] = exif\n        if xmp:\n            self.info[\"xmp\"] = xmp\n\n        # Initialize seek state\n        self._reset(reset=False)\n\n    def _getexif(self) -> dict[str, Any] | None:\n        if \"exif\" not in self.info:\n            return None\n        return self.getexif()._get_merged_dict()\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n\n        # Set logical frame to requested position\n        self.__logical_frame = frame\n\n    def _reset(self, reset: bool = True) -> None:\n        if reset:\n            self._decoder.reset()\n        self.__physical_frame = 0\n        self.__loaded = -1\n        self.__timestamp = 0\n\n    def _get_next(self):\n        # Get next frame\n        ret = self._decoder.get_next()\n        self.__physical_frame += 1\n\n        # Check if an error occurred\n        if ret is None:\n            self._reset()  # Reset just to be safe\n            self.seek(0)\n            msg = \"failed to decode next frame in WebP file\"\n            raise EOFError(msg)\n\n        # Compute duration\n        data, timestamp = ret\n        duration = timestamp - self.__timestamp\n        self.__timestamp = timestamp\n\n        # libwebp gives frame end, adjust to start of frame\n        timestamp -= duration\n        return data, timestamp, duration\n\n    def _seek(self, frame: int) -> None:\n        if self.__physical_frame == frame:\n            return  # Nothing to do\n        if frame < self.__physical_frame:\n            self._reset()  # Rewind to beginning\n        while self.__physical_frame < frame:\n            self._get_next()  # Advance to the requested frame\n\n    def load(self):\n        if _webp.HAVE_WEBPANIM:\n            if self.__loaded != self.__logical_frame:\n                self._seek(self.__logical_frame)\n\n                # We need to load the image data for this frame\n                data, timestamp, duration = self._get_next()\n                self.info[\"timestamp\"] = timestamp\n                self.info[\"duration\"] = duration\n                self.__loaded = self.__logical_frame\n\n                # Set tile\n                if self.fp and self._exclusive_fp:\n                    self.fp.close()\n                self.fp = BytesIO(data)\n                self.tile = [(\"raw\", (0, 0) + self.size, 0, self.rawmode)]\n\n        return super().load()\n\n    def load_seek(self, pos: int) -> None:\n        pass\n\n    def tell(self) -> int:\n        if not _webp.HAVE_WEBPANIM:\n            return super().tell()\n\n        return self.__logical_frame\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    encoderinfo = im.encoderinfo.copy()\n    append_images = list(encoderinfo.get(\"append_images\", []))\n\n    # If total frame count is 1, then save using the legacy API, which\n    # will preserve non-alpha modes\n    total = 0\n    for ims in [im] + append_images:\n        total += getattr(ims, \"n_frames\", 1)\n    if total == 1:\n        _save(im, fp, filename)\n        return\n\n    background: int | tuple[int, ...] = (0, 0, 0, 0)\n    if \"background\" in encoderinfo:\n        background = encoderinfo[\"background\"]\n    elif \"background\" in im.info:\n        background = im.info[\"background\"]\n        if isinstance(background, int):\n            # GifImagePlugin stores a global color table index in\n            # info[\"background\"]. So it must be converted to an RGBA value\n            palette = im.getpalette()\n            if palette:\n                r, g, b = palette[background * 3 : (background + 1) * 3]\n                background = (r, g, b, 255)\n            else:\n                background = (background, background, background, 255)\n\n    duration = im.encoderinfo.get(\"duration\", im.info.get(\"duration\", 0))\n    loop = im.encoderinfo.get(\"loop\", 0)\n    minimize_size = im.encoderinfo.get(\"minimize_size\", False)\n    kmin = im.encoderinfo.get(\"kmin\", None)\n    kmax = im.encoderinfo.get(\"kmax\", None)\n    allow_mixed = im.encoderinfo.get(\"allow_mixed\", False)\n    verbose = False\n    lossless = im.encoderinfo.get(\"lossless\", False)\n    quality = im.encoderinfo.get(\"quality\", 80)\n    alpha_quality = im.encoderinfo.get(\"alpha_quality\", 100)\n    method = im.encoderinfo.get(\"method\", 0)\n    icc_profile = im.encoderinfo.get(\"icc_profile\") or \"\"\n    exif = im.encoderinfo.get(\"exif\", \"\")\n    if isinstance(exif, Image.Exif):\n        exif = exif.tobytes()\n    xmp = im.encoderinfo.get(\"xmp\", \"\")\n    if allow_mixed:\n        lossless = False\n\n    # Sensible keyframe defaults are from gif2webp.c script\n    if kmin is None:\n        kmin = 9 if lossless else 3\n    if kmax is None:\n        kmax = 17 if lossless else 5\n\n    # Validate background color\n    if (\n        not isinstance(background, (list, tuple))\n        or len(background) != 4\n        or not all(0 <= v < 256 for v in background)\n    ):\n        msg = f\"Background color is not an RGBA tuple clamped to (0-255): {background}\"\n        raise OSError(msg)\n\n    # Convert to packed uint\n    bg_r, bg_g, bg_b, bg_a = background\n    background = (bg_a << 24) | (bg_r << 16) | (bg_g << 8) | (bg_b << 0)\n\n    # Setup the WebP animation encoder\n    enc = _webp.WebPAnimEncoder(\n        im.size[0],\n        im.size[1],\n        background,\n        loop,\n        minimize_size,\n        kmin,\n        kmax,\n        allow_mixed,\n        verbose,\n    )\n\n    # Add each frame\n    frame_idx = 0\n    timestamp = 0\n    cur_idx = im.tell()\n    try:\n        for ims in [im] + append_images:\n            # Get # of frames in this image\n            nfr = getattr(ims, \"n_frames\", 1)\n\n            for idx in range(nfr):\n                ims.seek(idx)\n                ims.load()\n\n                # Make sure image mode is supported\n                frame = ims\n                rawmode = ims.mode\n                if ims.mode not in _VALID_WEBP_MODES:\n                    alpha = (\n                        \"A\" in ims.mode\n                        or \"a\" in ims.mode\n                        or (ims.mode == \"P\" and \"A\" in ims.im.getpalettemode())\n                    )\n                    rawmode = \"RGBA\" if alpha else \"RGB\"\n                    frame = ims.convert(rawmode)\n\n                if rawmode == \"RGB\":\n                    # For faster conversion, use RGBX\n                    rawmode = \"RGBX\"\n\n                # Append the frame to the animation encoder\n                enc.add(\n                    frame.tobytes(\"raw\", rawmode),\n                    round(timestamp),\n                    frame.size[0],\n                    frame.size[1],\n                    rawmode,\n                    lossless,\n                    quality,\n                    alpha_quality,\n                    method,\n                )\n\n                # Update timestamp and frame index\n                if isinstance(duration, (list, tuple)):\n                    timestamp += duration[frame_idx]\n                else:\n                    timestamp += duration\n                frame_idx += 1\n\n    finally:\n        im.seek(cur_idx)\n\n    # Force encoder to flush frames\n    enc.add(None, round(timestamp), 0, 0, \"\", lossless, quality, alpha_quality, 0)\n\n    # Get the final output from the encoder\n    data = enc.assemble(icc_profile, exif, xmp)\n    if data is None:\n        msg = \"cannot write file as WebP (encoder returned None)\"\n        raise OSError(msg)\n\n    fp.write(data)\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    lossless = im.encoderinfo.get(\"lossless\", False)\n    quality = im.encoderinfo.get(\"quality\", 80)\n    alpha_quality = im.encoderinfo.get(\"alpha_quality\", 100)\n    icc_profile = im.encoderinfo.get(\"icc_profile\") or \"\"\n    exif = im.encoderinfo.get(\"exif\", b\"\")\n    if isinstance(exif, Image.Exif):\n        exif = exif.tobytes()\n    if exif.startswith(b\"Exif\\x00\\x00\"):\n        exif = exif[6:]\n    xmp = im.encoderinfo.get(\"xmp\", \"\")\n    method = im.encoderinfo.get(\"method\", 4)\n    exact = 1 if im.encoderinfo.get(\"exact\") else 0\n\n    if im.mode not in _VALID_WEBP_LEGACY_MODES:\n        im = im.convert(\"RGBA\" if im.has_transparency_data else \"RGB\")\n\n    data = _webp.WebPEncode(\n        im.tobytes(),\n        im.size[0],\n        im.size[1],\n        lossless,\n        float(quality),\n        float(alpha_quality),\n        im.mode,\n        icc_profile,\n        method,\n        exact,\n        exif,\n        xmp,\n    )\n    if data is None:\n        msg = \"cannot write file as WebP (encoder returned None)\"\n        raise OSError(msg)\n\n    fp.write(data)\n\n\nImage.register_open(WebPImageFile.format, WebPImageFile, _accept)\nif SUPPORTED:\n    Image.register_save(WebPImageFile.format, _save)\n    if _webp.HAVE_WEBPANIM:\n        Image.register_save_all(WebPImageFile.format, _save_all)\n    Image.register_extension(WebPImageFile.format, \".webp\")\n    Image.register_mime(WebPImageFile.format, \"image/webp\")\n", "src/PIL/report.py": "from __future__ import annotations\n\nfrom .features import pilinfo\n\npilinfo(supported_formats=False)\n", "src/PIL/GimpPaletteFile.py": "#\n# Python Imaging Library\n# $Id$\n#\n# stuff to read GIMP palette files\n#\n# History:\n# 1997-08-23 fl     Created\n# 2004-09-07 fl     Support GIMP 2.0 palette files.\n#\n# Copyright (c) Secret Labs AB 1997-2004.  All rights reserved.\n# Copyright (c) Fredrik Lundh 1997-2004.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\nfrom typing import IO\n\nfrom ._binary import o8\n\n\nclass GimpPaletteFile:\n    \"\"\"File handler for GIMP's palette format.\"\"\"\n\n    rawmode = \"RGB\"\n\n    def __init__(self, fp: IO[bytes]) -> None:\n        palette = [o8(i) * 3 for i in range(256)]\n\n        if fp.readline()[:12] != b\"GIMP Palette\":\n            msg = \"not a GIMP palette file\"\n            raise SyntaxError(msg)\n\n        for i in range(256):\n            s = fp.readline()\n            if not s:\n                break\n\n            # skip fields and comment lines\n            if re.match(rb\"\\w+:|#\", s):\n                continue\n            if len(s) > 100:\n                msg = \"bad palette file\"\n                raise SyntaxError(msg)\n\n            v = tuple(map(int, s.split()[:3]))\n            if len(v) != 3:\n                msg = \"bad palette entry\"\n                raise ValueError(msg)\n\n            palette[i] = o8(v[0]) + o8(v[1]) + o8(v[2])\n\n        self.palette = b\"\".join(palette)\n\n    def getpalette(self) -> tuple[bytes, str]:\n        return self.palette, self.rawmode\n", "src/PIL/PixarImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PIXAR raster support for PIL\n#\n# history:\n#       97-01-29 fl     Created\n#\n# notes:\n#       This is incomplete; it is based on a few samples created with\n#       Photoshop 2.5 and 3.0, and a summary description provided by\n#       Greg Coats <gcoats@labiris.er.usgs.gov>.  Hopefully, \"L\" and\n#       \"RGBA\" support will be added in future versions.\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i16le as i16\n\n#\n# helpers\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"\\200\\350\\000\\000\"\n\n\n##\n# Image plugin for PIXAR raster images.\n\n\nclass PixarImageFile(ImageFile.ImageFile):\n    format = \"PIXAR\"\n    format_description = \"PIXAR raster image\"\n\n    def _open(self) -> None:\n        # assuming a 4-byte magic label\n        assert self.fp is not None\n\n        s = self.fp.read(4)\n        if not _accept(s):\n            msg = \"not a PIXAR file\"\n            raise SyntaxError(msg)\n\n        # read rest of header\n        s = s + self.fp.read(508)\n\n        self._size = i16(s, 418), i16(s, 416)\n\n        # get channel/depth descriptions\n        mode = i16(s, 424), i16(s, 426)\n\n        if mode == (14, 2):\n            self._mode = \"RGB\"\n        # FIXME: to be continued...\n\n        # create tile descriptor (assuming \"dumped\")\n        self.tile = [(\"raw\", (0, 0) + self.size, 1024, (self.mode, 0, 1))]\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(PixarImageFile.format, PixarImageFile, _accept)\n\nImage.register_extension(PixarImageFile.format, \".pxr\")\n", "src/PIL/IcnsImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# macOS icns file decoder, based on icns.py by Bob Ippolito.\n#\n# history:\n# 2004-10-09 fl   Turned into a PIL plugin; removed 2.3 dependencies.\n# 2020-04-04      Allow saving on all operating systems.\n#\n# Copyright (c) 2004 by Bob Ippolito.\n# Copyright (c) 2004 by Secret Labs.\n# Copyright (c) 2004 by Fredrik Lundh.\n# Copyright (c) 2014 by Alastair Houghton.\n# Copyright (c) 2020 by Pan Jing.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport struct\nimport sys\nfrom typing import IO\n\nfrom . import Image, ImageFile, PngImagePlugin, features\n\nenable_jpeg2k = features.check_codec(\"jpg_2000\")\nif enable_jpeg2k:\n    from . import Jpeg2KImagePlugin\n\nMAGIC = b\"icns\"\nHEADERSIZE = 8\n\n\ndef nextheader(fobj):\n    return struct.unpack(\">4sI\", fobj.read(HEADERSIZE))\n\n\ndef read_32t(fobj, start_length, size):\n    # The 128x128 icon seems to have an extra header for some reason.\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(4)\n    if sig != b\"\\x00\\x00\\x00\\x00\":\n        msg = \"Unknown signature, expecting 0x00000000\"\n        raise SyntaxError(msg)\n    return read_32(fobj, (start + 4, length - 4), size)\n\n\ndef read_32(fobj, start_length, size):\n    \"\"\"\n    Read a 32bit RGB icon resource.  Seems to be either uncompressed or\n    an RLE packbits-like scheme.\n    \"\"\"\n    (start, length) = start_length\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    if length == sizesq * 3:\n        # uncompressed (\"RGBRGBGB\")\n        indata = fobj.read(length)\n        im = Image.frombuffer(\"RGB\", pixel_size, indata, \"raw\", \"RGB\", 0, 1)\n    else:\n        # decode image\n        im = Image.new(\"RGB\", pixel_size, None)\n        for band_ix in range(3):\n            data = []\n            bytesleft = sizesq\n            while bytesleft > 0:\n                byte = fobj.read(1)\n                if not byte:\n                    break\n                byte = byte[0]\n                if byte & 0x80:\n                    blocksize = byte - 125\n                    byte = fobj.read(1)\n                    for i in range(blocksize):\n                        data.append(byte)\n                else:\n                    blocksize = byte + 1\n                    data.append(fobj.read(blocksize))\n                bytesleft -= blocksize\n                if bytesleft <= 0:\n                    break\n            if bytesleft != 0:\n                msg = f\"Error reading channel [{repr(bytesleft)} left]\"\n                raise SyntaxError(msg)\n            band = Image.frombuffer(\"L\", pixel_size, b\"\".join(data), \"raw\", \"L\", 0, 1)\n            im.im.putband(band.im, band_ix)\n    return {\"RGB\": im}\n\n\ndef read_mk(fobj, start_length, size):\n    # Alpha masks seem to be uncompressed\n    start = start_length[0]\n    fobj.seek(start)\n    pixel_size = (size[0] * size[2], size[1] * size[2])\n    sizesq = pixel_size[0] * pixel_size[1]\n    band = Image.frombuffer(\"L\", pixel_size, fobj.read(sizesq), \"raw\", \"L\", 0, 1)\n    return {\"A\": band}\n\n\ndef read_png_or_jpeg2000(fobj, start_length, size):\n    (start, length) = start_length\n    fobj.seek(start)\n    sig = fobj.read(12)\n    if sig[:8] == b\"\\x89PNG\\x0d\\x0a\\x1a\\x0a\":\n        fobj.seek(start)\n        im = PngImagePlugin.PngImageFile(fobj)\n        Image._decompression_bomb_check(im.size)\n        return {\"RGBA\": im}\n    elif (\n        sig[:4] == b\"\\xff\\x4f\\xff\\x51\"\n        or sig[:4] == b\"\\x0d\\x0a\\x87\\x0a\"\n        or sig == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\"\n    ):\n        if not enable_jpeg2k:\n            msg = (\n                \"Unsupported icon subimage format (rebuild PIL \"\n                \"with JPEG 2000 support to fix this)\"\n            )\n            raise ValueError(msg)\n        # j2k, jpc or j2c\n        fobj.seek(start)\n        jp2kstream = fobj.read(length)\n        f = io.BytesIO(jp2kstream)\n        im = Jpeg2KImagePlugin.Jpeg2KImageFile(f)\n        Image._decompression_bomb_check(im.size)\n        if im.mode != \"RGBA\":\n            im = im.convert(\"RGBA\")\n        return {\"RGBA\": im}\n    else:\n        msg = \"Unsupported icon subimage format\"\n        raise ValueError(msg)\n\n\nclass IcnsFile:\n    SIZES = {\n        (512, 512, 2): [(b\"ic10\", read_png_or_jpeg2000)],\n        (512, 512, 1): [(b\"ic09\", read_png_or_jpeg2000)],\n        (256, 256, 2): [(b\"ic14\", read_png_or_jpeg2000)],\n        (256, 256, 1): [(b\"ic08\", read_png_or_jpeg2000)],\n        (128, 128, 2): [(b\"ic13\", read_png_or_jpeg2000)],\n        (128, 128, 1): [\n            (b\"ic07\", read_png_or_jpeg2000),\n            (b\"it32\", read_32t),\n            (b\"t8mk\", read_mk),\n        ],\n        (64, 64, 1): [(b\"icp6\", read_png_or_jpeg2000)],\n        (32, 32, 2): [(b\"ic12\", read_png_or_jpeg2000)],\n        (48, 48, 1): [(b\"ih32\", read_32), (b\"h8mk\", read_mk)],\n        (32, 32, 1): [\n            (b\"icp5\", read_png_or_jpeg2000),\n            (b\"il32\", read_32),\n            (b\"l8mk\", read_mk),\n        ],\n        (16, 16, 2): [(b\"ic11\", read_png_or_jpeg2000)],\n        (16, 16, 1): [\n            (b\"icp4\", read_png_or_jpeg2000),\n            (b\"is32\", read_32),\n            (b\"s8mk\", read_mk),\n        ],\n    }\n\n    def __init__(self, fobj):\n        \"\"\"\n        fobj is a file-like object as an icns resource\n        \"\"\"\n        # signature : (start, length)\n        self.dct = dct = {}\n        self.fobj = fobj\n        sig, filesize = nextheader(fobj)\n        if not _accept(sig):\n            msg = \"not an icns file\"\n            raise SyntaxError(msg)\n        i = HEADERSIZE\n        while i < filesize:\n            sig, blocksize = nextheader(fobj)\n            if blocksize <= 0:\n                msg = \"invalid block header\"\n                raise SyntaxError(msg)\n            i += HEADERSIZE\n            blocksize -= HEADERSIZE\n            dct[sig] = (i, blocksize)\n            fobj.seek(blocksize, io.SEEK_CUR)\n            i += blocksize\n\n    def itersizes(self):\n        sizes = []\n        for size, fmts in self.SIZES.items():\n            for fmt, reader in fmts:\n                if fmt in self.dct:\n                    sizes.append(size)\n                    break\n        return sizes\n\n    def bestsize(self):\n        sizes = self.itersizes()\n        if not sizes:\n            msg = \"No 32bit icon resources found\"\n            raise SyntaxError(msg)\n        return max(sizes)\n\n    def dataforsize(self, size):\n        \"\"\"\n        Get an icon resource as {channel: array}.  Note that\n        the arrays are bottom-up like windows bitmaps and will likely\n        need to be flipped or transposed in some way.\n        \"\"\"\n        dct = {}\n        for code, reader in self.SIZES[size]:\n            desc = self.dct.get(code)\n            if desc is not None:\n                dct.update(reader(self.fobj, desc, size))\n        return dct\n\n    def getimage(self, size=None):\n        if size is None:\n            size = self.bestsize()\n        if len(size) == 2:\n            size = (size[0], size[1], 1)\n        channels = self.dataforsize(size)\n\n        im = channels.get(\"RGBA\", None)\n        if im:\n            return im\n\n        im = channels.get(\"RGB\").copy()\n        try:\n            im.putalpha(channels[\"A\"])\n        except KeyError:\n            pass\n        return im\n\n\n##\n# Image plugin for Mac OS icons.\n\n\nclass IcnsImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL image support for Mac OS .icns files.\n    Chooses the best resolution, but will possibly load\n    a different size image if you mutate the size attribute\n    before calling 'load'.\n\n    The info dictionary has a key 'sizes' that is a list\n    of sizes that the icns file has.\n    \"\"\"\n\n    format = \"ICNS\"\n    format_description = \"Mac OS icns resource\"\n\n    def _open(self) -> None:\n        self.icns = IcnsFile(self.fp)\n        self._mode = \"RGBA\"\n        self.info[\"sizes\"] = self.icns.itersizes()\n        self.best_size = self.icns.bestsize()\n        self.size = (\n            self.best_size[0] * self.best_size[2],\n            self.best_size[1] * self.best_size[2],\n        )\n\n    @property\n    def size(self):\n        return self._size\n\n    @size.setter\n    def size(self, value):\n        info_size = value\n        if info_size not in self.info[\"sizes\"] and len(info_size) == 2:\n            info_size = (info_size[0], info_size[1], 1)\n        if (\n            info_size not in self.info[\"sizes\"]\n            and len(info_size) == 3\n            and info_size[2] == 1\n        ):\n            simple_sizes = [\n                (size[0] * size[2], size[1] * size[2]) for size in self.info[\"sizes\"]\n            ]\n            if value in simple_sizes:\n                info_size = self.info[\"sizes\"][simple_sizes.index(value)]\n        if info_size not in self.info[\"sizes\"]:\n            msg = \"This is not one of the allowed sizes of this image\"\n            raise ValueError(msg)\n        self._size = value\n\n    def load(self):\n        if len(self.size) == 3:\n            self.best_size = self.size\n            self.size = (\n                self.best_size[0] * self.best_size[2],\n                self.best_size[1] * self.best_size[2],\n            )\n\n        px = Image.Image.load(self)\n        if self.im is not None and self.im.size == self.size:\n            # Already loaded\n            return px\n        self.load_prepare()\n        # This is likely NOT the best way to do it, but whatever.\n        im = self.icns.getimage(self.best_size)\n\n        # If this is a PNG or JPEG 2000, it won't be loaded yet\n        px = im.load()\n\n        self.im = im.im\n        self._mode = im.mode\n        self.size = im.size\n\n        return px\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    \"\"\"\n    Saves the image as a series of PNG files,\n    that are then combined into a .icns file.\n    \"\"\"\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n    sizes = {\n        b\"ic07\": 128,\n        b\"ic08\": 256,\n        b\"ic09\": 512,\n        b\"ic10\": 1024,\n        b\"ic11\": 32,\n        b\"ic12\": 64,\n        b\"ic13\": 256,\n        b\"ic14\": 512,\n    }\n    provided_images = {im.width: im for im in im.encoderinfo.get(\"append_images\", [])}\n    size_streams = {}\n    for size in set(sizes.values()):\n        image = (\n            provided_images[size]\n            if size in provided_images\n            else im.resize((size, size))\n        )\n\n        temp = io.BytesIO()\n        image.save(temp, \"png\")\n        size_streams[size] = temp.getvalue()\n\n    entries = []\n    for type, size in sizes.items():\n        stream = size_streams[size]\n        entries.append((type, HEADERSIZE + len(stream), stream))\n\n    # Header\n    fp.write(MAGIC)\n    file_length = HEADERSIZE  # Header\n    file_length += HEADERSIZE + 8 * len(entries)  # TOC\n    file_length += sum(entry[1] for entry in entries)\n    fp.write(struct.pack(\">i\", file_length))\n\n    # TOC\n    fp.write(b\"TOC \")\n    fp.write(struct.pack(\">i\", HEADERSIZE + len(entries) * HEADERSIZE))\n    for entry in entries:\n        fp.write(entry[0])\n        fp.write(struct.pack(\">i\", entry[1]))\n\n    # Data\n    for entry in entries:\n        fp.write(entry[0])\n        fp.write(struct.pack(\">i\", entry[1]))\n        fp.write(entry[2])\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == MAGIC\n\n\nImage.register_open(IcnsImageFile.format, IcnsImageFile, _accept)\nImage.register_extension(IcnsImageFile.format, \".icns\")\n\nImage.register_save(IcnsImageFile.format, _save)\nImage.register_mime(IcnsImageFile.format, \"image/icns\")\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Syntax: python3 IcnsImagePlugin.py [file]\")\n        sys.exit()\n\n    with open(sys.argv[1], \"rb\") as fp:\n        imf = IcnsImageFile(fp)\n        for size in imf.info[\"sizes\"]:\n            width, height, scale = imf.size = size\n            imf.save(f\"out-{width}-{height}-{scale}.png\")\n        with Image.open(sys.argv[1]) as im:\n            im.save(\"out.png\")\n        if sys.platform == \"windows\":\n            os.startfile(\"out.png\")\n", "src/PIL/ImageChops.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard channel operations\n#\n# History:\n# 1996-03-24 fl   Created\n# 1996-08-13 fl   Added logical operations (for \"1\" images)\n# 2000-10-12 fl   Added offset method (from Image.py)\n#\n# Copyright (c) 1997-2000 by Secret Labs AB\n# Copyright (c) 1996-2000 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import annotations\n\nfrom . import Image\n\n\ndef constant(image: Image.Image, value: int) -> Image.Image:\n    \"\"\"Fill a channel with a given gray level.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return Image.new(\"L\", image.size, value)\n\n\ndef duplicate(image: Image.Image) -> Image.Image:\n    \"\"\"Copy a channel. Alias for :py:meth:`PIL.Image.Image.copy`.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return image.copy()\n\n\ndef invert(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Invert an image (channel). ::\n\n        out = MAX - image\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image.load()\n    return image._new(image.im.chop_invert())\n\n\ndef lighter(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the lighter values. ::\n\n        out = max(image1, image2)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_lighter(image2.im))\n\n\ndef darker(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Compares the two images, pixel by pixel, and returns a new image containing\n    the darker values. ::\n\n        out = min(image1, image2)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_darker(image2.im))\n\n\ndef difference(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Returns the absolute value of the pixel-by-pixel difference between the two\n    images. ::\n\n        out = abs(image1 - image2)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_difference(image2.im))\n\n\ndef multiply(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other.\n\n    If you multiply an image with a solid black image, the result is black. If\n    you multiply with a solid white image, the image is unaffected. ::\n\n        out = image1 * image2 / MAX\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_multiply(image2.im))\n\n\ndef screen(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two inverted images on top of each other. ::\n\n        out = MAX - ((MAX - image1) * (MAX - image2) / MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_screen(image2.im))\n\n\ndef soft_light(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Soft Light algorithm\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_soft_light(image2.im))\n\n\ndef hard_light(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Hard Light algorithm\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_hard_light(image2.im))\n\n\ndef overlay(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"\n    Superimposes two images on top of each other using the Overlay algorithm\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_overlay(image2.im))\n\n\ndef add(\n    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0\n) -> Image.Image:\n    \"\"\"\n    Adds two images, dividing the result by scale and adding the\n    offset. If omitted, scale defaults to 1.0, and offset to 0.0. ::\n\n        out = ((image1 + image2) / scale + offset)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_add(image2.im, scale, offset))\n\n\ndef subtract(\n    image1: Image.Image, image2: Image.Image, scale: float = 1.0, offset: float = 0\n) -> Image.Image:\n    \"\"\"\n    Subtracts two images, dividing the result by scale and adding the offset.\n    If omitted, scale defaults to 1.0, and offset to 0.0. ::\n\n        out = ((image1 - image2) / scale + offset)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_subtract(image2.im, scale, offset))\n\n\ndef add_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Add two images, without clipping the result. ::\n\n        out = ((image1 + image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_add_modulo(image2.im))\n\n\ndef subtract_modulo(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Subtract two images, without clipping the result. ::\n\n        out = ((image1 - image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_subtract_modulo(image2.im))\n\n\ndef logical_and(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical AND between two images.\n\n    Both of the images must have mode \"1\". If you would like to perform a\n    logical AND on an image with a mode other than \"1\", try\n    :py:meth:`~PIL.ImageChops.multiply` instead, using a black-and-white mask\n    as the second image. ::\n\n        out = ((image1 and image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_and(image2.im))\n\n\ndef logical_or(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical OR between two images.\n\n    Both of the images must have mode \"1\". ::\n\n        out = ((image1 or image2) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_or(image2.im))\n\n\ndef logical_xor(image1: Image.Image, image2: Image.Image) -> Image.Image:\n    \"\"\"Logical XOR between two images.\n\n    Both of the images must have mode \"1\". ::\n\n        out = ((bool(image1) != bool(image2)) % MAX)\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    image1.load()\n    image2.load()\n    return image1._new(image1.im.chop_xor(image2.im))\n\n\ndef blend(image1: Image.Image, image2: Image.Image, alpha: float) -> Image.Image:\n    \"\"\"Blend images using constant transparency weight. Alias for\n    :py:func:`PIL.Image.blend`.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return Image.blend(image1, image2, alpha)\n\n\ndef composite(\n    image1: Image.Image, image2: Image.Image, mask: Image.Image\n) -> Image.Image:\n    \"\"\"Create composite using transparency mask. Alias for\n    :py:func:`PIL.Image.composite`.\n\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    return Image.composite(image1, image2, mask)\n\n\ndef offset(image: Image.Image, xoffset: int, yoffset: int | None = None) -> Image.Image:\n    \"\"\"Returns a copy of the image where data has been offset by the given\n    distances. Data wraps around the edges. If ``yoffset`` is omitted, it\n    is assumed to be equal to ``xoffset``.\n\n    :param image: Input image.\n    :param xoffset: The horizontal distance.\n    :param yoffset: The vertical distance.  If omitted, both\n        distances are set to the same value.\n    :rtype: :py:class:`~PIL.Image.Image`\n    \"\"\"\n\n    if yoffset is None:\n        yoffset = xoffset\n    image.load()\n    return image._new(image.im.offset(xoffset, yoffset))\n", "src/PIL/PalmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n\n##\n# Image plugin for Palm pixmap images (output only).\n##\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import o8\nfrom ._binary import o16be as o16b\n\n# fmt: off\n_Palm8BitColormapValues = (\n    (255, 255, 255), (255, 204, 255), (255, 153, 255), (255, 102, 255),\n    (255,  51, 255), (255,   0, 255), (255, 255, 204), (255, 204, 204),\n    (255, 153, 204), (255, 102, 204), (255,  51, 204), (255,   0, 204),\n    (255, 255, 153), (255, 204, 153), (255, 153, 153), (255, 102, 153),\n    (255,  51, 153), (255,   0, 153), (204, 255, 255), (204, 204, 255),\n    (204, 153, 255), (204, 102, 255), (204,  51, 255), (204,   0, 255),\n    (204, 255, 204), (204, 204, 204), (204, 153, 204), (204, 102, 204),\n    (204,  51, 204), (204,   0, 204), (204, 255, 153), (204, 204, 153),\n    (204, 153, 153), (204, 102, 153), (204,  51, 153), (204,   0, 153),\n    (153, 255, 255), (153, 204, 255), (153, 153, 255), (153, 102, 255),\n    (153,  51, 255), (153,   0, 255), (153, 255, 204), (153, 204, 204),\n    (153, 153, 204), (153, 102, 204), (153,  51, 204), (153,   0, 204),\n    (153, 255, 153), (153, 204, 153), (153, 153, 153), (153, 102, 153),\n    (153,  51, 153), (153,   0, 153), (102, 255, 255), (102, 204, 255),\n    (102, 153, 255), (102, 102, 255), (102,  51, 255), (102,   0, 255),\n    (102, 255, 204), (102, 204, 204), (102, 153, 204), (102, 102, 204),\n    (102,  51, 204), (102,   0, 204), (102, 255, 153), (102, 204, 153),\n    (102, 153, 153), (102, 102, 153), (102,  51, 153), (102,   0, 153),\n    (51,  255, 255), (51,  204, 255), (51,  153, 255), (51,  102, 255),\n    (51,   51, 255), (51,    0, 255), (51,  255, 204), (51,  204, 204),\n    (51,  153, 204), (51,  102, 204), (51,   51, 204), (51,    0, 204),\n    (51,  255, 153), (51,  204, 153), (51,  153, 153), (51,  102, 153),\n    (51,   51, 153), (51,    0, 153), (0,   255, 255), (0,   204, 255),\n    (0,   153, 255), (0,   102, 255), (0,    51, 255), (0,     0, 255),\n    (0,   255, 204), (0,   204, 204), (0,   153, 204), (0,   102, 204),\n    (0,    51, 204), (0,     0, 204), (0,   255, 153), (0,   204, 153),\n    (0,   153, 153), (0,   102, 153), (0,    51, 153), (0,     0, 153),\n    (255, 255, 102), (255, 204, 102), (255, 153, 102), (255, 102, 102),\n    (255,  51, 102), (255,   0, 102), (255, 255,  51), (255, 204,  51),\n    (255, 153,  51), (255, 102,  51), (255,  51,  51), (255,   0,  51),\n    (255, 255,   0), (255, 204,   0), (255, 153,   0), (255, 102,   0),\n    (255,  51,   0), (255,   0,   0), (204, 255, 102), (204, 204, 102),\n    (204, 153, 102), (204, 102, 102), (204,  51, 102), (204,   0, 102),\n    (204, 255,  51), (204, 204,  51), (204, 153,  51), (204, 102,  51),\n    (204,  51,  51), (204,   0,  51), (204, 255,   0), (204, 204,   0),\n    (204, 153,   0), (204, 102,   0), (204,  51,   0), (204,   0,   0),\n    (153, 255, 102), (153, 204, 102), (153, 153, 102), (153, 102, 102),\n    (153,  51, 102), (153,   0, 102), (153, 255,  51), (153, 204,  51),\n    (153, 153,  51), (153, 102,  51), (153,  51,  51), (153,   0,  51),\n    (153, 255,   0), (153, 204,   0), (153, 153,   0), (153, 102,   0),\n    (153,  51,   0), (153,   0,   0), (102, 255, 102), (102, 204, 102),\n    (102, 153, 102), (102, 102, 102), (102,  51, 102), (102,   0, 102),\n    (102, 255,  51), (102, 204,  51), (102, 153,  51), (102, 102,  51),\n    (102,  51,  51), (102,   0,  51), (102, 255,   0), (102, 204,   0),\n    (102, 153,   0), (102, 102,   0), (102,  51,   0), (102,   0,   0),\n    (51,  255, 102), (51,  204, 102), (51,  153, 102), (51,  102, 102),\n    (51,   51, 102), (51,    0, 102), (51,  255,  51), (51,  204,  51),\n    (51,  153,  51), (51,  102,  51), (51,   51,  51), (51,    0,  51),\n    (51,  255,   0), (51,  204,   0), (51,  153,   0), (51,  102,   0),\n    (51,   51,   0), (51,    0,   0), (0,   255, 102), (0,   204, 102),\n    (0,   153, 102), (0,   102, 102), (0,    51, 102), (0,     0, 102),\n    (0,   255,  51), (0,   204,  51), (0,   153,  51), (0,   102,  51),\n    (0,    51,  51), (0,     0,  51), (0,   255,   0), (0,   204,   0),\n    (0,   153,   0), (0,   102,   0), (0,    51,   0), (17,   17,  17),\n    (34,   34,  34), (68,   68,  68), (85,   85,  85), (119, 119, 119),\n    (136, 136, 136), (170, 170, 170), (187, 187, 187), (221, 221, 221),\n    (238, 238, 238), (192, 192, 192), (128,   0,   0), (128,   0, 128),\n    (0,   128,   0), (0,   128, 128), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0),\n    (0,     0,   0), (0,     0,   0), (0,     0,   0), (0,     0,   0))\n# fmt: on\n\n\n# so build a prototype image to be used for palette resampling\ndef build_prototype_image() -> Image.Image:\n    image = Image.new(\"L\", (1, len(_Palm8BitColormapValues)))\n    image.putdata(list(range(len(_Palm8BitColormapValues))))\n    palettedata: tuple[int, ...] = ()\n    for colormapValue in _Palm8BitColormapValues:\n        palettedata += colormapValue\n    palettedata += (0, 0, 0) * (256 - len(_Palm8BitColormapValues))\n    image.putpalette(palettedata)\n    return image\n\n\nPalm8BitColormapImage = build_prototype_image()\n\n# OK, we now have in Palm8BitColormapImage,\n# a \"P\"-mode image with the right palette\n#\n# --------------------------------------------------------------------\n\n_FLAGS = {\"custom-colormap\": 0x4000, \"is-compressed\": 0x8000, \"has-transparent\": 0x2000}\n\n_COMPRESSION_TYPES = {\"none\": 0xFF, \"rle\": 0x01, \"scanline\": 0x00}\n\n\n#\n# --------------------------------------------------------------------\n\n##\n# (Internal) Image save plugin for the Palm format.\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode == \"P\":\n        # we assume this is a color Palm image with the standard colormap,\n        # unless the \"info\" dict has a \"custom-colormap\" field\n\n        rawmode = \"P\"\n        bpp = 8\n        version = 1\n\n    elif im.mode == \"L\":\n        if im.encoderinfo.get(\"bpp\") in (1, 2, 4):\n            # this is 8-bit grayscale, so we shift it to get the high-order bits,\n            # and invert it because\n            # Palm does grayscale from white (0) to black (1)\n            bpp = im.encoderinfo[\"bpp\"]\n            maxval = (1 << bpp) - 1\n            shift = 8 - bpp\n            im = im.point(lambda x: maxval - (x >> shift))\n        elif im.info.get(\"bpp\") in (1, 2, 4):\n            # here we assume that even though the inherent mode is 8-bit grayscale,\n            # only the lower bpp bits are significant.\n            # We invert them to match the Palm.\n            bpp = im.info[\"bpp\"]\n            maxval = (1 << bpp) - 1\n            im = im.point(lambda x: maxval - (x & maxval))\n        else:\n            msg = f\"cannot write mode {im.mode} as Palm\"\n            raise OSError(msg)\n\n        # we ignore the palette here\n        im._mode = \"P\"\n        rawmode = f\"P;{bpp}\"\n        version = 1\n\n    elif im.mode == \"1\":\n        # monochrome -- write it inverted, as is the Palm standard\n        rawmode = \"1;I\"\n        bpp = 1\n        version = 0\n\n    else:\n        msg = f\"cannot write mode {im.mode} as Palm\"\n        raise OSError(msg)\n\n    #\n    # make sure image data is available\n    im.load()\n\n    # write header\n\n    cols = im.size[0]\n    rows = im.size[1]\n\n    rowbytes = int((cols + (16 // bpp - 1)) / (16 // bpp)) * 2\n    transparent_index = 0\n    compression_type = _COMPRESSION_TYPES[\"none\"]\n\n    flags = 0\n    if im.mode == \"P\" and \"custom-colormap\" in im.info:\n        flags = flags & _FLAGS[\"custom-colormap\"]\n        colormapsize = 4 * 256 + 2\n        colormapmode = im.palette.mode\n        colormap = im.getdata().getpalette()\n    else:\n        colormapsize = 0\n\n    if \"offset\" in im.info:\n        offset = (rowbytes * rows + 16 + 3 + colormapsize) // 4\n    else:\n        offset = 0\n\n    fp.write(o16b(cols) + o16b(rows) + o16b(rowbytes) + o16b(flags))\n    fp.write(o8(bpp))\n    fp.write(o8(version))\n    fp.write(o16b(offset))\n    fp.write(o8(transparent_index))\n    fp.write(o8(compression_type))\n    fp.write(o16b(0))  # reserved by Palm\n\n    # now write colormap if necessary\n\n    if colormapsize > 0:\n        fp.write(o16b(256))\n        for i in range(256):\n            fp.write(o8(i))\n            if colormapmode == \"RGB\":\n                fp.write(\n                    o8(colormap[3 * i])\n                    + o8(colormap[3 * i + 1])\n                    + o8(colormap[3 * i + 2])\n                )\n            elif colormapmode == \"RGBA\":\n                fp.write(\n                    o8(colormap[4 * i])\n                    + o8(colormap[4 * i + 1])\n                    + o8(colormap[4 * i + 2])\n                )\n\n    # now convert data to raw form\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, rowbytes, 1))])\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_save(\"Palm\", _save)\n\nImage.register_extension(\"Palm\", \".palm\")\n\nImage.register_mime(\"Palm\", \"image/palm\")\n", "src/PIL/BdfFontFile.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# bitmap distribution font (bdf) file parser\n#\n# history:\n# 1996-05-16 fl   created (as bdf2pil)\n# 1997-08-25 fl   converted to FontFile driver\n# 2001-05-25 fl   removed bogus __init__ call\n# 2002-11-20 fl   robustification (from Kevin Cazabon, Dmitry Vasiliev)\n# 2003-04-22 fl   more robustification (from Graham Dumpleton)\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1997-2003 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\"\"\"\nParse X Bitmap Distribution Format (BDF)\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import BinaryIO\n\nfrom . import FontFile, Image\n\nbdf_slant = {\n    \"R\": \"Roman\",\n    \"I\": \"Italic\",\n    \"O\": \"Oblique\",\n    \"RI\": \"Reverse Italic\",\n    \"RO\": \"Reverse Oblique\",\n    \"OT\": \"Other\",\n}\n\nbdf_spacing = {\"P\": \"Proportional\", \"M\": \"Monospaced\", \"C\": \"Cell\"}\n\n\ndef bdf_char(\n    f: BinaryIO,\n) -> (\n    tuple[\n        str,\n        int,\n        tuple[tuple[int, int], tuple[int, int, int, int], tuple[int, int, int, int]],\n        Image.Image,\n    ]\n    | None\n):\n    # skip to STARTCHAR\n    while True:\n        s = f.readline()\n        if not s:\n            return None\n        if s[:9] == b\"STARTCHAR\":\n            break\n    id = s[9:].strip().decode(\"ascii\")\n\n    # load symbol properties\n    props = {}\n    while True:\n        s = f.readline()\n        if not s or s[:6] == b\"BITMAP\":\n            break\n        i = s.find(b\" \")\n        props[s[:i].decode(\"ascii\")] = s[i + 1 : -1].decode(\"ascii\")\n\n    # load bitmap\n    bitmap = bytearray()\n    while True:\n        s = f.readline()\n        if not s or s[:7] == b\"ENDCHAR\":\n            break\n        bitmap += s[:-1]\n\n    # The word BBX\n    # followed by the width in x (BBw), height in y (BBh),\n    # and x and y displacement (BBxoff0, BByoff0)\n    # of the lower left corner from the origin of the character.\n    width, height, x_disp, y_disp = (int(p) for p in props[\"BBX\"].split())\n\n    # The word DWIDTH\n    # followed by the width in x and y of the character in device pixels.\n    dwx, dwy = (int(p) for p in props[\"DWIDTH\"].split())\n\n    bbox = (\n        (dwx, dwy),\n        (x_disp, -y_disp - height, width + x_disp, -y_disp),\n        (0, 0, width, height),\n    )\n\n    try:\n        im = Image.frombytes(\"1\", (width, height), bitmap, \"hex\", \"1\")\n    except ValueError:\n        # deal with zero-width characters\n        im = Image.new(\"1\", (width, height))\n\n    return id, int(props[\"ENCODING\"]), bbox, im\n\n\nclass BdfFontFile(FontFile.FontFile):\n    \"\"\"Font file plugin for the X11 BDF format.\"\"\"\n\n    def __init__(self, fp: BinaryIO) -> None:\n        super().__init__()\n\n        s = fp.readline()\n        if s[:13] != b\"STARTFONT 2.1\":\n            msg = \"not a valid BDF file\"\n            raise SyntaxError(msg)\n\n        props = {}\n        comments = []\n\n        while True:\n            s = fp.readline()\n            if not s or s[:13] == b\"ENDPROPERTIES\":\n                break\n            i = s.find(b\" \")\n            props[s[:i].decode(\"ascii\")] = s[i + 1 : -1].decode(\"ascii\")\n            if s[:i] in [b\"COMMENT\", b\"COPYRIGHT\"]:\n                if s.find(b\"LogicalFontDescription\") < 0:\n                    comments.append(s[i + 1 : -1].decode(\"ascii\"))\n\n        while True:\n            c = bdf_char(fp)\n            if not c:\n                break\n            id, ch, (xy, dst, src), im = c\n            if 0 <= ch < len(self.glyph):\n                self.glyph[ch] = xy, dst, src, im\n", "src/PIL/SpiderImagePlugin.py": "#\n# The Python Imaging Library.\n#\n# SPIDER image file handling\n#\n# History:\n# 2004-08-02    Created BB\n# 2006-03-02    added save method\n# 2006-03-13    added support for stack images\n#\n# Copyright (c) 2004 by Health Research Inc. (HRI) RENSSELAER, NY 12144.\n# Copyright (c) 2004 by William Baxter.\n# Copyright (c) 2004 by Secret Labs AB.\n# Copyright (c) 2004 by Fredrik Lundh.\n#\n\n##\n# Image plugin for the Spider image format. This format is used\n# by the SPIDER software, in processing image data from electron\n# microscopy and tomography.\n##\n\n#\n# SpiderImagePlugin.py\n#\n# The Spider image format is used by SPIDER software, in processing\n# image data from electron microscopy and tomography.\n#\n# Spider home page:\n# https://spider.wadsworth.org/spider_doc/spider/docs/spider.html\n#\n# Details about the Spider image format:\n# https://spider.wadsworth.org/spider_doc/spider/docs/image_doc.html\n#\nfrom __future__ import annotations\n\nimport os\nimport struct\nimport sys\nfrom typing import IO, TYPE_CHECKING\n\nfrom . import Image, ImageFile\n\n\ndef isInt(f):\n    try:\n        i = int(f)\n        if f - i == 0:\n            return 1\n        else:\n            return 0\n    except (ValueError, OverflowError):\n        return 0\n\n\niforms = [1, 3, -11, -12, -21, -22]\n\n\n# There is no magic number to identify Spider files, so just check a\n# series of header locations to see if they have reasonable values.\n# Returns no. of bytes in the header, if it is a valid Spider header,\n# otherwise returns 0\n\n\ndef isSpiderHeader(t):\n    h = (99,) + t  # add 1 value so can use spider header index start=1\n    # header values 1,2,5,12,13,22,23 should be integers\n    for i in [1, 2, 5, 12, 13, 22, 23]:\n        if not isInt(h[i]):\n            return 0\n    # check iform\n    iform = int(h[5])\n    if iform not in iforms:\n        return 0\n    # check other header values\n    labrec = int(h[13])  # no. records in file header\n    labbyt = int(h[22])  # total no. of bytes in header\n    lenbyt = int(h[23])  # record length in bytes\n    if labbyt != (labrec * lenbyt):\n        return 0\n    # looks like a valid header\n    return labbyt\n\n\ndef isSpiderImage(filename):\n    with open(filename, \"rb\") as fp:\n        f = fp.read(92)  # read 23 * 4 bytes\n    t = struct.unpack(\">23f\", f)  # try big-endian first\n    hdrlen = isSpiderHeader(t)\n    if hdrlen == 0:\n        t = struct.unpack(\"<23f\", f)  # little-endian\n        hdrlen = isSpiderHeader(t)\n    return hdrlen\n\n\nclass SpiderImageFile(ImageFile.ImageFile):\n    format = \"SPIDER\"\n    format_description = \"Spider 2D image\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # check header\n        n = 27 * 4  # read 27 float values\n        f = self.fp.read(n)\n\n        try:\n            self.bigendian = 1\n            t = struct.unpack(\">27f\", f)  # try big-endian first\n            hdrlen = isSpiderHeader(t)\n            if hdrlen == 0:\n                self.bigendian = 0\n                t = struct.unpack(\"<27f\", f)  # little-endian\n                hdrlen = isSpiderHeader(t)\n            if hdrlen == 0:\n                msg = \"not a valid Spider file\"\n                raise SyntaxError(msg)\n        except struct.error as e:\n            msg = \"not a valid Spider file\"\n            raise SyntaxError(msg) from e\n\n        h = (99,) + t  # add 1 value : spider header index starts at 1\n        iform = int(h[5])\n        if iform != 1:\n            msg = \"not a Spider 2D image\"\n            raise SyntaxError(msg)\n\n        self._size = int(h[12]), int(h[2])  # size in pixels (width, height)\n        self.istack = int(h[24])\n        self.imgnumber = int(h[27])\n\n        if self.istack == 0 and self.imgnumber == 0:\n            # stk=0, img=0: a regular 2D image\n            offset = hdrlen\n            self._nimages = 1\n        elif self.istack > 0 and self.imgnumber == 0:\n            # stk>0, img=0: Opening the stack for the first time\n            self.imgbytes = int(h[12]) * int(h[2]) * 4\n            self.hdrlen = hdrlen\n            self._nimages = int(h[26])\n            # Point to the first image in the stack\n            offset = hdrlen * 2\n            self.imgnumber = 1\n        elif self.istack == 0 and self.imgnumber > 0:\n            # stk=0, img>0: an image within the stack\n            offset = hdrlen + self.stkoffset\n            self.istack = 2  # So Image knows it's still a stack\n        else:\n            msg = \"inconsistent stack header values\"\n            raise SyntaxError(msg)\n\n        if self.bigendian:\n            self.rawmode = \"F;32BF\"\n        else:\n            self.rawmode = \"F;32F\"\n        self._mode = \"F\"\n\n        self.tile = [(\"raw\", (0, 0) + self.size, offset, (self.rawmode, 0, 1))]\n        self._fp = self.fp  # FIXME: hack\n\n    @property\n    def n_frames(self) -> int:\n        return self._nimages\n\n    @property\n    def is_animated(self) -> bool:\n        return self._nimages > 1\n\n    # 1st image index is zero (although SPIDER imgnumber starts at 1)\n    def tell(self) -> int:\n        if self.imgnumber < 1:\n            return 0\n        else:\n            return self.imgnumber - 1\n\n    def seek(self, frame: int) -> None:\n        if self.istack == 0:\n            msg = \"attempt to seek in a non-stack file\"\n            raise EOFError(msg)\n        if not self._seek_check(frame):\n            return\n        self.stkoffset = self.hdrlen + frame * (self.hdrlen + self.imgbytes)\n        self.fp = self._fp\n        self.fp.seek(self.stkoffset)\n        self._open()\n\n    # returns a byte image after rescaling to 0..255\n    def convert2byte(self, depth=255):\n        (minimum, maximum) = self.getextrema()\n        m = 1\n        if maximum != minimum:\n            m = depth / (maximum - minimum)\n        b = -m * minimum\n        return self.point(lambda i, m=m, b=b: i * m + b).convert(\"L\")\n\n    if TYPE_CHECKING:\n        from . import ImageTk\n\n    # returns a ImageTk.PhotoImage object, after rescaling to 0..255\n    def tkPhotoImage(self) -> ImageTk.PhotoImage:\n        from . import ImageTk\n\n        return ImageTk.PhotoImage(self.convert2byte(), palette=256)\n\n\n# --------------------------------------------------------------------\n# Image series\n\n\n# given a list of filenames, return a list of images\ndef loadImageSeries(filelist=None):\n    \"\"\"create a list of :py:class:`~PIL.Image.Image` objects for use in a montage\"\"\"\n    if filelist is None or len(filelist) < 1:\n        return\n\n    imglist = []\n    for img in filelist:\n        if not os.path.exists(img):\n            print(f\"unable to find {img}\")\n            continue\n        try:\n            with Image.open(img) as im:\n                im = im.convert2byte()\n        except Exception:\n            if not isSpiderImage(img):\n                print(f\"{img} is not a Spider image file\")\n            continue\n        im.info[\"filename\"] = img\n        imglist.append(im)\n    return imglist\n\n\n# --------------------------------------------------------------------\n# For saving images in Spider format\n\n\ndef makeSpiderHeader(im: Image.Image) -> list[bytes]:\n    nsam, nrow = im.size\n    lenbyt = nsam * 4  # There are labrec records in the header\n    labrec = int(1024 / lenbyt)\n    if 1024 % lenbyt != 0:\n        labrec += 1\n    labbyt = labrec * lenbyt\n    nvalues = int(labbyt / 4)\n    if nvalues < 23:\n        return []\n\n    hdr = [0.0] * nvalues\n\n    # NB these are Fortran indices\n    hdr[1] = 1.0  # nslice (=1 for an image)\n    hdr[2] = float(nrow)  # number of rows per slice\n    hdr[3] = float(nrow)  # number of records in the image\n    hdr[5] = 1.0  # iform for 2D image\n    hdr[12] = float(nsam)  # number of pixels per line\n    hdr[13] = float(labrec)  # number of records in file header\n    hdr[22] = float(labbyt)  # total number of bytes in header\n    hdr[23] = float(lenbyt)  # record length in bytes\n\n    # adjust for Fortran indexing\n    hdr = hdr[1:]\n    hdr.append(0.0)\n    # pack binary data into a string\n    return [struct.pack(\"f\", v) for v in hdr]\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode[0] != \"F\":\n        im = im.convert(\"F\")\n\n    hdr = makeSpiderHeader(im)\n    if len(hdr) < 256:\n        msg = \"Error creating Spider header\"\n        raise OSError(msg)\n\n    # write the SPIDER header\n    fp.writelines(hdr)\n\n    rawmode = \"F;32NF\"  # 32-bit native floating point\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, 1))])\n\n\ndef _save_spider(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # get the filename extension and register it with Image\n    filename_ext = os.path.splitext(filename)[1]\n    ext = filename_ext.decode() if isinstance(filename_ext, bytes) else filename_ext\n    Image.register_extension(SpiderImageFile.format, ext)\n    _save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n\n\nImage.register_open(SpiderImageFile.format, SpiderImageFile)\nImage.register_save(SpiderImageFile.format, _save_spider)\n\nif __name__ == \"__main__\":\n    if len(sys.argv) < 2:\n        print(\"Syntax: python3 SpiderImagePlugin.py [infile] [outfile]\")\n        sys.exit()\n\n    filename = sys.argv[1]\n    if not isSpiderImage(filename):\n        print(\"input image must be in Spider format\")\n        sys.exit()\n\n    with Image.open(filename) as im:\n        print(f\"image: {im}\")\n        print(f\"format: {im.format}\")\n        print(f\"size: {im.size}\")\n        print(f\"mode: {im.mode}\")\n        print(\"max, min: \", end=\" \")\n        print(im.getextrema())\n\n        if len(sys.argv) > 2:\n            outfile = sys.argv[2]\n\n            # perform some image operation\n            im = im.transpose(Image.Transpose.FLIP_LEFT_RIGHT)\n            print(\n                f\"saving a flipped version of {os.path.basename(filename)} \"\n                f\"as {outfile} \"\n            )\n            im.save(outfile, SpiderImageFile.format)\n", "src/PIL/ContainerIO.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a class to read from a container file\n#\n# History:\n# 1995-06-18 fl     Created\n# 1995-09-07 fl     Added readline(), readlines()\n#\n# Copyright (c) 1997-2001 by Secret Labs AB\n# Copyright (c) 1995 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nfrom typing import IO, AnyStr, Generic, Literal\n\n\nclass ContainerIO(Generic[AnyStr]):\n    \"\"\"\n    A file object that provides read access to a part of an existing\n    file (for example a TAR file).\n    \"\"\"\n\n    def __init__(self, file: IO[AnyStr], offset: int, length: int) -> None:\n        \"\"\"\n        Create file object.\n\n        :param file: Existing file.\n        :param offset: Start of region, in bytes.\n        :param length: Size of region, in bytes.\n        \"\"\"\n        self.fh: IO[AnyStr] = file\n        self.pos = 0\n        self.offset = offset\n        self.length = length\n        self.fh.seek(offset)\n\n    ##\n    # Always false.\n\n    def isatty(self) -> bool:\n        return False\n\n    def seek(self, offset: int, mode: Literal[0, 1, 2] = io.SEEK_SET) -> None:\n        \"\"\"\n        Move file pointer.\n\n        :param offset: Offset in bytes.\n        :param mode: Starting position. Use 0 for beginning of region, 1\n           for current offset, and 2 for end of region.  You cannot move\n           the pointer outside the defined region.\n        \"\"\"\n        if mode == 1:\n            self.pos = self.pos + offset\n        elif mode == 2:\n            self.pos = self.length + offset\n        else:\n            self.pos = offset\n        # clamp\n        self.pos = max(0, min(self.pos, self.length))\n        self.fh.seek(self.offset + self.pos)\n\n    def tell(self) -> int:\n        \"\"\"\n        Get current file pointer.\n\n        :returns: Offset from start of region, in bytes.\n        \"\"\"\n        return self.pos\n\n    def read(self, n: int = 0) -> AnyStr:\n        \"\"\"\n        Read data.\n\n        :param n: Number of bytes to read. If omitted or zero,\n            read until end of region.\n        :returns: An 8-bit string.\n        \"\"\"\n        if n:\n            n = min(n, self.length - self.pos)\n        else:\n            n = self.length - self.pos\n        if not n:  # EOF\n            return b\"\" if \"b\" in self.fh.mode else \"\"  # type: ignore[return-value]\n        self.pos = self.pos + n\n        return self.fh.read(n)\n\n    def readline(self) -> AnyStr:\n        \"\"\"\n        Read a line of text.\n\n        :returns: An 8-bit string.\n        \"\"\"\n        s: AnyStr = b\"\" if \"b\" in self.fh.mode else \"\"  # type: ignore[assignment]\n        newline_character = b\"\\n\" if \"b\" in self.fh.mode else \"\\n\"\n        while True:\n            c = self.read(1)\n            if not c:\n                break\n            s = s + c\n            if c == newline_character:\n                break\n        return s\n\n    def readlines(self) -> list[AnyStr]:\n        \"\"\"\n        Read multiple lines of text.\n\n        :returns: A list of 8-bit strings.\n        \"\"\"\n        lines = []\n        while True:\n            s = self.readline()\n            if not s:\n                break\n            lines.append(s)\n        return lines\n", "src/PIL/PdfParser.py": "from __future__ import annotations\n\nimport calendar\nimport codecs\nimport collections\nimport mmap\nimport os\nimport re\nimport time\nimport zlib\nfrom typing import TYPE_CHECKING, Any, List, NamedTuple, Union\n\n\n# see 7.9.2.2 Text String Type on page 86 and D.3 PDFDocEncoding Character Set\n# on page 656\ndef encode_text(s: str) -> bytes:\n    return codecs.BOM_UTF16_BE + s.encode(\"utf_16_be\")\n\n\nPDFDocEncoding = {\n    0x16: \"\\u0017\",\n    0x18: \"\\u02D8\",\n    0x19: \"\\u02C7\",\n    0x1A: \"\\u02C6\",\n    0x1B: \"\\u02D9\",\n    0x1C: \"\\u02DD\",\n    0x1D: \"\\u02DB\",\n    0x1E: \"\\u02DA\",\n    0x1F: \"\\u02DC\",\n    0x80: \"\\u2022\",\n    0x81: \"\\u2020\",\n    0x82: \"\\u2021\",\n    0x83: \"\\u2026\",\n    0x84: \"\\u2014\",\n    0x85: \"\\u2013\",\n    0x86: \"\\u0192\",\n    0x87: \"\\u2044\",\n    0x88: \"\\u2039\",\n    0x89: \"\\u203A\",\n    0x8A: \"\\u2212\",\n    0x8B: \"\\u2030\",\n    0x8C: \"\\u201E\",\n    0x8D: \"\\u201C\",\n    0x8E: \"\\u201D\",\n    0x8F: \"\\u2018\",\n    0x90: \"\\u2019\",\n    0x91: \"\\u201A\",\n    0x92: \"\\u2122\",\n    0x93: \"\\uFB01\",\n    0x94: \"\\uFB02\",\n    0x95: \"\\u0141\",\n    0x96: \"\\u0152\",\n    0x97: \"\\u0160\",\n    0x98: \"\\u0178\",\n    0x99: \"\\u017D\",\n    0x9A: \"\\u0131\",\n    0x9B: \"\\u0142\",\n    0x9C: \"\\u0153\",\n    0x9D: \"\\u0161\",\n    0x9E: \"\\u017E\",\n    0xA0: \"\\u20AC\",\n}\n\n\ndef decode_text(b):\n    if b[: len(codecs.BOM_UTF16_BE)] == codecs.BOM_UTF16_BE:\n        return b[len(codecs.BOM_UTF16_BE) :].decode(\"utf_16_be\")\n    else:\n        return \"\".join(PDFDocEncoding.get(byte, chr(byte)) for byte in b)\n\n\nclass PdfFormatError(RuntimeError):\n    \"\"\"An error that probably indicates a syntactic or semantic error in the\n    PDF file structure\"\"\"\n\n    pass\n\n\ndef check_format_condition(condition: bool, error_message: str) -> None:\n    if not condition:\n        raise PdfFormatError(error_message)\n\n\nclass IndirectReferenceTuple(NamedTuple):\n    object_id: int\n    generation: int\n\n\nclass IndirectReference(IndirectReferenceTuple):\n    def __str__(self) -> str:\n        return f\"{self.object_id} {self.generation} R\"\n\n    def __bytes__(self) -> bytes:\n        return self.__str__().encode(\"us-ascii\")\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return False\n        assert isinstance(other, IndirectReference)\n        return other.object_id == self.object_id and other.generation == self.generation\n\n    def __ne__(self, other):\n        return not (self == other)\n\n    def __hash__(self) -> int:\n        return hash((self.object_id, self.generation))\n\n\nclass IndirectObjectDef(IndirectReference):\n    def __str__(self) -> str:\n        return f\"{self.object_id} {self.generation} obj\"\n\n\nclass XrefTable:\n    def __init__(self):\n        self.existing_entries = {}  # object ID => (offset, generation)\n        self.new_entries = {}  # object ID => (offset, generation)\n        self.deleted_entries = {0: 65536}  # object ID => generation\n        self.reading_finished = False\n\n    def __setitem__(self, key, value):\n        if self.reading_finished:\n            self.new_entries[key] = value\n        else:\n            self.existing_entries[key] = value\n        if key in self.deleted_entries:\n            del self.deleted_entries[key]\n\n    def __getitem__(self, key):\n        try:\n            return self.new_entries[key]\n        except KeyError:\n            return self.existing_entries[key]\n\n    def __delitem__(self, key):\n        if key in self.new_entries:\n            generation = self.new_entries[key][1] + 1\n            del self.new_entries[key]\n            self.deleted_entries[key] = generation\n        elif key in self.existing_entries:\n            generation = self.existing_entries[key][1] + 1\n            self.deleted_entries[key] = generation\n        elif key in self.deleted_entries:\n            generation = self.deleted_entries[key]\n        else:\n            msg = f\"object ID {key} cannot be deleted because it doesn't exist\"\n            raise IndexError(msg)\n\n    def __contains__(self, key):\n        return key in self.existing_entries or key in self.new_entries\n\n    def __len__(self) -> int:\n        return len(\n            set(self.existing_entries.keys())\n            | set(self.new_entries.keys())\n            | set(self.deleted_entries.keys())\n        )\n\n    def keys(self):\n        return (\n            set(self.existing_entries.keys()) - set(self.deleted_entries.keys())\n        ) | set(self.new_entries.keys())\n\n    def write(self, f):\n        keys = sorted(set(self.new_entries.keys()) | set(self.deleted_entries.keys()))\n        deleted_keys = sorted(set(self.deleted_entries.keys()))\n        startxref = f.tell()\n        f.write(b\"xref\\n\")\n        while keys:\n            # find a contiguous sequence of object IDs\n            prev = None\n            for index, key in enumerate(keys):\n                if prev is None or prev + 1 == key:\n                    prev = key\n                else:\n                    contiguous_keys = keys[:index]\n                    keys = keys[index:]\n                    break\n            else:\n                contiguous_keys = keys\n                keys = None\n            f.write(b\"%d %d\\n\" % (contiguous_keys[0], len(contiguous_keys)))\n            for object_id in contiguous_keys:\n                if object_id in self.new_entries:\n                    f.write(b\"%010d %05d n \\n\" % self.new_entries[object_id])\n                else:\n                    this_deleted_object_id = deleted_keys.pop(0)\n                    check_format_condition(\n                        object_id == this_deleted_object_id,\n                        f\"expected the next deleted object ID to be {object_id}, \"\n                        f\"instead found {this_deleted_object_id}\",\n                    )\n                    try:\n                        next_in_linked_list = deleted_keys[0]\n                    except IndexError:\n                        next_in_linked_list = 0\n                    f.write(\n                        b\"%010d %05d f \\n\"\n                        % (next_in_linked_list, self.deleted_entries[object_id])\n                    )\n        return startxref\n\n\nclass PdfName:\n    def __init__(self, name):\n        if isinstance(name, PdfName):\n            self.name = name.name\n        elif isinstance(name, bytes):\n            self.name = name\n        else:\n            self.name = name.encode(\"us-ascii\")\n\n    def name_as_str(self) -> str:\n        return self.name.decode(\"us-ascii\")\n\n    def __eq__(self, other):\n        return (\n            isinstance(other, PdfName) and other.name == self.name\n        ) or other == self.name\n\n    def __hash__(self) -> int:\n        return hash(self.name)\n\n    def __repr__(self) -> str:\n        return f\"{self.__class__.__name__}({repr(self.name)})\"\n\n    @classmethod\n    def from_pdf_stream(cls, data):\n        return cls(PdfParser.interpret_name(data))\n\n    allowed_chars = set(range(33, 127)) - {ord(c) for c in \"#%/()<>[]{}\"}\n\n    def __bytes__(self) -> bytes:\n        result = bytearray(b\"/\")\n        for b in self.name:\n            if b in self.allowed_chars:\n                result.append(b)\n            else:\n                result.extend(b\"#%02X\" % b)\n        return bytes(result)\n\n\nclass PdfArray(List[Any]):\n    def __bytes__(self) -> bytes:\n        return b\"[ \" + b\" \".join(pdf_repr(x) for x in self) + b\" ]\"\n\n\nif TYPE_CHECKING:\n    _DictBase = collections.UserDict[Union[str, bytes], Any]\nelse:\n    _DictBase = collections.UserDict\n\n\nclass PdfDict(_DictBase):\n    def __setattr__(self, key, value):\n        if key == \"data\":\n            collections.UserDict.__setattr__(self, key, value)\n        else:\n            self[key.encode(\"us-ascii\")] = value\n\n    def __getattr__(self, key):\n        try:\n            value = self[key.encode(\"us-ascii\")]\n        except KeyError as e:\n            raise AttributeError(key) from e\n        if isinstance(value, bytes):\n            value = decode_text(value)\n        if key.endswith(\"Date\"):\n            if value.startswith(\"D:\"):\n                value = value[2:]\n\n            relationship = \"Z\"\n            if len(value) > 17:\n                relationship = value[14]\n                offset = int(value[15:17]) * 60\n                if len(value) > 20:\n                    offset += int(value[18:20])\n\n            format = \"%Y%m%d%H%M%S\"[: len(value) - 2]\n            value = time.strptime(value[: len(format) + 2], format)\n            if relationship in [\"+\", \"-\"]:\n                offset *= 60\n                if relationship == \"+\":\n                    offset *= -1\n                value = time.gmtime(calendar.timegm(value) + offset)\n        return value\n\n    def __bytes__(self) -> bytes:\n        out = bytearray(b\"<<\")\n        for key, value in self.items():\n            if value is None:\n                continue\n            value = pdf_repr(value)\n            out.extend(b\"\\n\")\n            out.extend(bytes(PdfName(key)))\n            out.extend(b\" \")\n            out.extend(value)\n        out.extend(b\"\\n>>\")\n        return bytes(out)\n\n\nclass PdfBinary:\n    def __init__(self, data):\n        self.data = data\n\n    def __bytes__(self) -> bytes:\n        return b\"<%s>\" % b\"\".join(b\"%02X\" % b for b in self.data)\n\n\nclass PdfStream:\n    def __init__(self, dictionary, buf):\n        self.dictionary = dictionary\n        self.buf = buf\n\n    def decode(self):\n        try:\n            filter = self.dictionary.Filter\n        except AttributeError:\n            return self.buf\n        if filter == b\"FlateDecode\":\n            try:\n                expected_length = self.dictionary.DL\n            except AttributeError:\n                expected_length = self.dictionary.Length\n            return zlib.decompress(self.buf, bufsize=int(expected_length))\n        else:\n            msg = f\"stream filter {repr(self.dictionary.Filter)} unknown/unsupported\"\n            raise NotImplementedError(msg)\n\n\ndef pdf_repr(x):\n    if x is True:\n        return b\"true\"\n    elif x is False:\n        return b\"false\"\n    elif x is None:\n        return b\"null\"\n    elif isinstance(x, (PdfName, PdfDict, PdfArray, PdfBinary)):\n        return bytes(x)\n    elif isinstance(x, (int, float)):\n        return str(x).encode(\"us-ascii\")\n    elif isinstance(x, time.struct_time):\n        return b\"(D:\" + time.strftime(\"%Y%m%d%H%M%SZ\", x).encode(\"us-ascii\") + b\")\"\n    elif isinstance(x, dict):\n        return bytes(PdfDict(x))\n    elif isinstance(x, list):\n        return bytes(PdfArray(x))\n    elif isinstance(x, str):\n        return pdf_repr(encode_text(x))\n    elif isinstance(x, bytes):\n        # XXX escape more chars? handle binary garbage\n        x = x.replace(b\"\\\\\", b\"\\\\\\\\\")\n        x = x.replace(b\"(\", b\"\\\\(\")\n        x = x.replace(b\")\", b\"\\\\)\")\n        return b\"(\" + x + b\")\"\n    else:\n        return bytes(x)\n\n\nclass PdfParser:\n    \"\"\"Based on\n    https://www.adobe.com/content/dam/acom/en/devnet/acrobat/pdfs/PDF32000_2008.pdf\n    Supports PDF up to 1.4\n    \"\"\"\n\n    def __init__(self, filename=None, f=None, buf=None, start_offset=0, mode=\"rb\"):\n        if buf and f:\n            msg = \"specify buf or f or filename, but not both buf and f\"\n            raise RuntimeError(msg)\n        self.filename = filename\n        self.buf = buf\n        self.f = f\n        self.start_offset = start_offset\n        self.should_close_buf = False\n        self.should_close_file = False\n        if filename is not None and f is None:\n            self.f = f = open(filename, mode)\n            self.should_close_file = True\n        if f is not None:\n            self.buf = buf = self.get_buf_from_file(f)\n            self.should_close_buf = True\n            if not filename and hasattr(f, \"name\"):\n                self.filename = f.name\n        self.cached_objects = {}\n        if buf:\n            self.read_pdf_info()\n        else:\n            self.file_size_total = self.file_size_this = 0\n            self.root = PdfDict()\n            self.root_ref = None\n            self.info = PdfDict()\n            self.info_ref = None\n            self.page_tree_root = {}\n            self.pages = []\n            self.orig_pages = []\n            self.pages_ref = None\n            self.last_xref_section_offset = None\n            self.trailer_dict = {}\n            self.xref_table = XrefTable()\n        self.xref_table.reading_finished = True\n        if f:\n            self.seek_end()\n\n    def __enter__(self) -> PdfParser:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def start_writing(self) -> None:\n        self.close_buf()\n        self.seek_end()\n\n    def close_buf(self) -> None:\n        try:\n            self.buf.close()\n        except AttributeError:\n            pass\n        self.buf = None\n\n    def close(self) -> None:\n        if self.should_close_buf:\n            self.close_buf()\n        if self.f is not None and self.should_close_file:\n            self.f.close()\n            self.f = None\n\n    def seek_end(self) -> None:\n        self.f.seek(0, os.SEEK_END)\n\n    def write_header(self) -> None:\n        self.f.write(b\"%PDF-1.4\\n\")\n\n    def write_comment(self, s):\n        self.f.write(f\"% {s}\\n\".encode())\n\n    def write_catalog(self) -> IndirectReference:\n        self.del_root()\n        self.root_ref = self.next_object_id(self.f.tell())\n        self.pages_ref = self.next_object_id(0)\n        self.rewrite_pages()\n        self.write_obj(self.root_ref, Type=PdfName(b\"Catalog\"), Pages=self.pages_ref)\n        self.write_obj(\n            self.pages_ref,\n            Type=PdfName(b\"Pages\"),\n            Count=len(self.pages),\n            Kids=self.pages,\n        )\n        return self.root_ref\n\n    def rewrite_pages(self) -> None:\n        pages_tree_nodes_to_delete = []\n        for i, page_ref in enumerate(self.orig_pages):\n            page_info = self.cached_objects[page_ref]\n            del self.xref_table[page_ref.object_id]\n            pages_tree_nodes_to_delete.append(page_info[PdfName(b\"Parent\")])\n            if page_ref not in self.pages:\n                # the page has been deleted\n                continue\n            # make dict keys into strings for passing to write_page\n            stringified_page_info = {}\n            for key, value in page_info.items():\n                # key should be a PdfName\n                stringified_page_info[key.name_as_str()] = value\n            stringified_page_info[\"Parent\"] = self.pages_ref\n            new_page_ref = self.write_page(None, **stringified_page_info)\n            for j, cur_page_ref in enumerate(self.pages):\n                if cur_page_ref == page_ref:\n                    # replace the page reference with the new one\n                    self.pages[j] = new_page_ref\n        # delete redundant Pages tree nodes from xref table\n        for pages_tree_node_ref in pages_tree_nodes_to_delete:\n            while pages_tree_node_ref:\n                pages_tree_node = self.cached_objects[pages_tree_node_ref]\n                if pages_tree_node_ref.object_id in self.xref_table:\n                    del self.xref_table[pages_tree_node_ref.object_id]\n                pages_tree_node_ref = pages_tree_node.get(b\"Parent\", None)\n        self.orig_pages = []\n\n    def write_xref_and_trailer(self, new_root_ref=None):\n        if new_root_ref:\n            self.del_root()\n            self.root_ref = new_root_ref\n        if self.info:\n            self.info_ref = self.write_obj(None, self.info)\n        start_xref = self.xref_table.write(self.f)\n        num_entries = len(self.xref_table)\n        trailer_dict = {b\"Root\": self.root_ref, b\"Size\": num_entries}\n        if self.last_xref_section_offset is not None:\n            trailer_dict[b\"Prev\"] = self.last_xref_section_offset\n        if self.info:\n            trailer_dict[b\"Info\"] = self.info_ref\n        self.last_xref_section_offset = start_xref\n        self.f.write(\n            b\"trailer\\n\"\n            + bytes(PdfDict(trailer_dict))\n            + b\"\\nstartxref\\n%d\\n%%%%EOF\" % start_xref\n        )\n\n    def write_page(self, ref, *objs, **dict_obj):\n        if isinstance(ref, int):\n            ref = self.pages[ref]\n        if \"Type\" not in dict_obj:\n            dict_obj[\"Type\"] = PdfName(b\"Page\")\n        if \"Parent\" not in dict_obj:\n            dict_obj[\"Parent\"] = self.pages_ref\n        return self.write_obj(ref, *objs, **dict_obj)\n\n    def write_obj(self, ref, *objs, **dict_obj):\n        f = self.f\n        if ref is None:\n            ref = self.next_object_id(f.tell())\n        else:\n            self.xref_table[ref.object_id] = (f.tell(), ref.generation)\n        f.write(bytes(IndirectObjectDef(*ref)))\n        stream = dict_obj.pop(\"stream\", None)\n        if stream is not None:\n            dict_obj[\"Length\"] = len(stream)\n        if dict_obj:\n            f.write(pdf_repr(dict_obj))\n        for obj in objs:\n            f.write(pdf_repr(obj))\n        if stream is not None:\n            f.write(b\"stream\\n\")\n            f.write(stream)\n            f.write(b\"\\nendstream\\n\")\n        f.write(b\"endobj\\n\")\n        return ref\n\n    def del_root(self) -> None:\n        if self.root_ref is None:\n            return\n        del self.xref_table[self.root_ref.object_id]\n        del self.xref_table[self.root[b\"Pages\"].object_id]\n\n    @staticmethod\n    def get_buf_from_file(f):\n        if hasattr(f, \"getbuffer\"):\n            return f.getbuffer()\n        elif hasattr(f, \"getvalue\"):\n            return f.getvalue()\n        else:\n            try:\n                return mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\n            except ValueError:  # cannot mmap an empty file\n                return b\"\"\n\n    def read_pdf_info(self) -> None:\n        self.file_size_total = len(self.buf)\n        self.file_size_this = self.file_size_total - self.start_offset\n        self.read_trailer()\n        self.root_ref = self.trailer_dict[b\"Root\"]\n        self.info_ref = self.trailer_dict.get(b\"Info\", None)\n        self.root = PdfDict(self.read_indirect(self.root_ref))\n        if self.info_ref is None:\n            self.info = PdfDict()\n        else:\n            self.info = PdfDict(self.read_indirect(self.info_ref))\n        check_format_condition(b\"Type\" in self.root, \"/Type missing in Root\")\n        check_format_condition(\n            self.root[b\"Type\"] == b\"Catalog\", \"/Type in Root is not /Catalog\"\n        )\n        check_format_condition(b\"Pages\" in self.root, \"/Pages missing in Root\")\n        check_format_condition(\n            isinstance(self.root[b\"Pages\"], IndirectReference),\n            \"/Pages in Root is not an indirect reference\",\n        )\n        self.pages_ref = self.root[b\"Pages\"]\n        self.page_tree_root = self.read_indirect(self.pages_ref)\n        self.pages = self.linearize_page_tree(self.page_tree_root)\n        # save the original list of page references\n        # in case the user modifies, adds or deletes some pages\n        # and we need to rewrite the pages and their list\n        self.orig_pages = self.pages[:]\n\n    def next_object_id(self, offset=None):\n        try:\n            # TODO: support reuse of deleted objects\n            reference = IndirectReference(max(self.xref_table.keys()) + 1, 0)\n        except ValueError:\n            reference = IndirectReference(1, 0)\n        if offset is not None:\n            self.xref_table[reference.object_id] = (offset, 0)\n        return reference\n\n    delimiter = rb\"[][()<>{}/%]\"\n    delimiter_or_ws = rb\"[][()<>{}/%\\000\\011\\012\\014\\015\\040]\"\n    whitespace = rb\"[\\000\\011\\012\\014\\015\\040]\"\n    whitespace_or_hex = rb\"[\\000\\011\\012\\014\\015\\0400-9a-fA-F]\"\n    whitespace_optional = whitespace + b\"*\"\n    whitespace_mandatory = whitespace + b\"+\"\n    # No \"\\012\" aka \"\\n\" or \"\\015\" aka \"\\r\":\n    whitespace_optional_no_nl = rb\"[\\000\\011\\014\\040]*\"\n    newline_only = rb\"[\\r\\n]+\"\n    newline = whitespace_optional_no_nl + newline_only + whitespace_optional_no_nl\n    re_trailer_end = re.compile(\n        whitespace_mandatory\n        + rb\"trailer\"\n        + whitespace_optional\n        + rb\"<<(.*>>)\"\n        + newline\n        + rb\"startxref\"\n        + newline\n        + rb\"([0-9]+)\"\n        + newline\n        + rb\"%%EOF\"\n        + whitespace_optional\n        + rb\"$\",\n        re.DOTALL,\n    )\n    re_trailer_prev = re.compile(\n        whitespace_optional\n        + rb\"trailer\"\n        + whitespace_optional\n        + rb\"<<(.*?>>)\"\n        + newline\n        + rb\"startxref\"\n        + newline\n        + rb\"([0-9]+)\"\n        + newline\n        + rb\"%%EOF\"\n        + whitespace_optional,\n        re.DOTALL,\n    )\n\n    def read_trailer(self):\n        search_start_offset = len(self.buf) - 16384\n        if search_start_offset < self.start_offset:\n            search_start_offset = self.start_offset\n        m = self.re_trailer_end.search(self.buf, search_start_offset)\n        check_format_condition(m, \"trailer end not found\")\n        # make sure we found the LAST trailer\n        last_match = m\n        while m:\n            last_match = m\n            m = self.re_trailer_end.search(self.buf, m.start() + 16)\n        if not m:\n            m = last_match\n        trailer_data = m.group(1)\n        self.last_xref_section_offset = int(m.group(2))\n        self.trailer_dict = self.interpret_trailer(trailer_data)\n        self.xref_table = XrefTable()\n        self.read_xref_table(xref_section_offset=self.last_xref_section_offset)\n        if b\"Prev\" in self.trailer_dict:\n            self.read_prev_trailer(self.trailer_dict[b\"Prev\"])\n\n    def read_prev_trailer(self, xref_section_offset):\n        trailer_offset = self.read_xref_table(xref_section_offset=xref_section_offset)\n        m = self.re_trailer_prev.search(\n            self.buf[trailer_offset : trailer_offset + 16384]\n        )\n        check_format_condition(m, \"previous trailer not found\")\n        trailer_data = m.group(1)\n        check_format_condition(\n            int(m.group(2)) == xref_section_offset,\n            \"xref section offset in previous trailer doesn't match what was expected\",\n        )\n        trailer_dict = self.interpret_trailer(trailer_data)\n        if b\"Prev\" in trailer_dict:\n            self.read_prev_trailer(trailer_dict[b\"Prev\"])\n\n    re_whitespace_optional = re.compile(whitespace_optional)\n    re_name = re.compile(\n        whitespace_optional\n        + rb\"/([!-$&'*-.0-;=?-Z\\\\^-z|~]+)(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_dict_start = re.compile(whitespace_optional + rb\"<<\")\n    re_dict_end = re.compile(whitespace_optional + rb\">>\" + whitespace_optional)\n\n    @classmethod\n    def interpret_trailer(cls, trailer_data):\n        trailer = {}\n        offset = 0\n        while True:\n            m = cls.re_name.match(trailer_data, offset)\n            if not m:\n                m = cls.re_dict_end.match(trailer_data, offset)\n                check_format_condition(\n                    m and m.end() == len(trailer_data),\n                    \"name not found in trailer, remaining data: \"\n                    + repr(trailer_data[offset:]),\n                )\n                break\n            key = cls.interpret_name(m.group(1))\n            value, offset = cls.get_value(trailer_data, m.end())\n            trailer[key] = value\n        check_format_condition(\n            b\"Size\" in trailer and isinstance(trailer[b\"Size\"], int),\n            \"/Size not in trailer or not an integer\",\n        )\n        check_format_condition(\n            b\"Root\" in trailer and isinstance(trailer[b\"Root\"], IndirectReference),\n            \"/Root not in trailer or not an indirect reference\",\n        )\n        return trailer\n\n    re_hashes_in_name = re.compile(rb\"([^#]*)(#([0-9a-fA-F]{2}))?\")\n\n    @classmethod\n    def interpret_name(cls, raw, as_text=False):\n        name = b\"\"\n        for m in cls.re_hashes_in_name.finditer(raw):\n            if m.group(3):\n                name += m.group(1) + bytearray.fromhex(m.group(3).decode(\"us-ascii\"))\n            else:\n                name += m.group(1)\n        if as_text:\n            return name.decode(\"utf-8\")\n        else:\n            return bytes(name)\n\n    re_null = re.compile(whitespace_optional + rb\"null(?=\" + delimiter_or_ws + rb\")\")\n    re_true = re.compile(whitespace_optional + rb\"true(?=\" + delimiter_or_ws + rb\")\")\n    re_false = re.compile(whitespace_optional + rb\"false(?=\" + delimiter_or_ws + rb\")\")\n    re_int = re.compile(\n        whitespace_optional + rb\"([-+]?[0-9]+)(?=\" + delimiter_or_ws + rb\")\"\n    )\n    re_real = re.compile(\n        whitespace_optional\n        + rb\"([-+]?([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+))(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_array_start = re.compile(whitespace_optional + rb\"\\[\")\n    re_array_end = re.compile(whitespace_optional + rb\"]\")\n    re_string_hex = re.compile(\n        whitespace_optional + rb\"<(\" + whitespace_or_hex + rb\"*)>\"\n    )\n    re_string_lit = re.compile(whitespace_optional + rb\"\\(\")\n    re_indirect_reference = re.compile(\n        whitespace_optional\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"R(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_indirect_def_start = re.compile(\n        whitespace_optional\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"([-+]?[0-9]+)\"\n        + whitespace_mandatory\n        + rb\"obj(?=\"\n        + delimiter_or_ws\n        + rb\")\"\n    )\n    re_indirect_def_end = re.compile(\n        whitespace_optional + rb\"endobj(?=\" + delimiter_or_ws + rb\")\"\n    )\n    re_comment = re.compile(\n        rb\"(\" + whitespace_optional + rb\"%[^\\r\\n]*\" + newline + rb\")*\"\n    )\n    re_stream_start = re.compile(whitespace_optional + rb\"stream\\r?\\n\")\n    re_stream_end = re.compile(\n        whitespace_optional + rb\"endstream(?=\" + delimiter_or_ws + rb\")\"\n    )\n\n    @classmethod\n    def get_value(cls, data, offset, expect_indirect=None, max_nesting=-1):\n        if max_nesting == 0:\n            return None, None\n        m = cls.re_comment.match(data, offset)\n        if m:\n            offset = m.end()\n        m = cls.re_indirect_def_start.match(data, offset)\n        if m:\n            check_format_condition(\n                int(m.group(1)) > 0,\n                \"indirect object definition: object ID must be greater than 0\",\n            )\n            check_format_condition(\n                int(m.group(2)) >= 0,\n                \"indirect object definition: generation must be non-negative\",\n            )\n            check_format_condition(\n                expect_indirect is None\n                or expect_indirect\n                == IndirectReference(int(m.group(1)), int(m.group(2))),\n                \"indirect object definition different than expected\",\n            )\n            object, offset = cls.get_value(data, m.end(), max_nesting=max_nesting - 1)\n            if offset is None:\n                return object, None\n            m = cls.re_indirect_def_end.match(data, offset)\n            check_format_condition(m, \"indirect object definition end not found\")\n            return object, m.end()\n        check_format_condition(\n            not expect_indirect, \"indirect object definition not found\"\n        )\n        m = cls.re_indirect_reference.match(data, offset)\n        if m:\n            check_format_condition(\n                int(m.group(1)) > 0,\n                \"indirect object reference: object ID must be greater than 0\",\n            )\n            check_format_condition(\n                int(m.group(2)) >= 0,\n                \"indirect object reference: generation must be non-negative\",\n            )\n            return IndirectReference(int(m.group(1)), int(m.group(2))), m.end()\n        m = cls.re_dict_start.match(data, offset)\n        if m:\n            offset = m.end()\n            result = {}\n            m = cls.re_dict_end.match(data, offset)\n            while not m:\n                key, offset = cls.get_value(data, offset, max_nesting=max_nesting - 1)\n                if offset is None:\n                    return result, None\n                value, offset = cls.get_value(data, offset, max_nesting=max_nesting - 1)\n                result[key] = value\n                if offset is None:\n                    return result, None\n                m = cls.re_dict_end.match(data, offset)\n            offset = m.end()\n            m = cls.re_stream_start.match(data, offset)\n            if m:\n                try:\n                    stream_len_str = result.get(b\"Length\")\n                    stream_len = int(stream_len_str)\n                except (TypeError, ValueError) as e:\n                    msg = f\"bad or missing Length in stream dict ({stream_len_str})\"\n                    raise PdfFormatError(msg) from e\n                stream_data = data[m.end() : m.end() + stream_len]\n                m = cls.re_stream_end.match(data, m.end() + stream_len)\n                check_format_condition(m, \"stream end not found\")\n                offset = m.end()\n                result = PdfStream(PdfDict(result), stream_data)\n            else:\n                result = PdfDict(result)\n            return result, offset\n        m = cls.re_array_start.match(data, offset)\n        if m:\n            offset = m.end()\n            result = []\n            m = cls.re_array_end.match(data, offset)\n            while not m:\n                value, offset = cls.get_value(data, offset, max_nesting=max_nesting - 1)\n                result.append(value)\n                if offset is None:\n                    return result, None\n                m = cls.re_array_end.match(data, offset)\n            return result, m.end()\n        m = cls.re_null.match(data, offset)\n        if m:\n            return None, m.end()\n        m = cls.re_true.match(data, offset)\n        if m:\n            return True, m.end()\n        m = cls.re_false.match(data, offset)\n        if m:\n            return False, m.end()\n        m = cls.re_name.match(data, offset)\n        if m:\n            return PdfName(cls.interpret_name(m.group(1))), m.end()\n        m = cls.re_int.match(data, offset)\n        if m:\n            return int(m.group(1)), m.end()\n        m = cls.re_real.match(data, offset)\n        if m:\n            # XXX Decimal instead of float???\n            return float(m.group(1)), m.end()\n        m = cls.re_string_hex.match(data, offset)\n        if m:\n            # filter out whitespace\n            hex_string = bytearray(\n                b for b in m.group(1) if b in b\"0123456789abcdefABCDEF\"\n            )\n            if len(hex_string) % 2 == 1:\n                # append a 0 if the length is not even - yes, at the end\n                hex_string.append(ord(b\"0\"))\n            return bytearray.fromhex(hex_string.decode(\"us-ascii\")), m.end()\n        m = cls.re_string_lit.match(data, offset)\n        if m:\n            return cls.get_literal_string(data, m.end())\n        # return None, offset  # fallback (only for debugging)\n        msg = f\"unrecognized object: {repr(data[offset : offset + 32])}\"\n        raise PdfFormatError(msg)\n\n    re_lit_str_token = re.compile(\n        rb\"(\\\\[nrtbf()\\\\])|(\\\\[0-9]{1,3})|(\\\\(\\r\\n|\\r|\\n))|(\\r\\n|\\r|\\n)|(\\()|(\\))\"\n    )\n    escaped_chars = {\n        b\"n\": b\"\\n\",\n        b\"r\": b\"\\r\",\n        b\"t\": b\"\\t\",\n        b\"b\": b\"\\b\",\n        b\"f\": b\"\\f\",\n        b\"(\": b\"(\",\n        b\")\": b\")\",\n        b\"\\\\\": b\"\\\\\",\n        ord(b\"n\"): b\"\\n\",\n        ord(b\"r\"): b\"\\r\",\n        ord(b\"t\"): b\"\\t\",\n        ord(b\"b\"): b\"\\b\",\n        ord(b\"f\"): b\"\\f\",\n        ord(b\"(\"): b\"(\",\n        ord(b\")\"): b\")\",\n        ord(b\"\\\\\"): b\"\\\\\",\n    }\n\n    @classmethod\n    def get_literal_string(cls, data, offset):\n        nesting_depth = 0\n        result = bytearray()\n        for m in cls.re_lit_str_token.finditer(data, offset):\n            result.extend(data[offset : m.start()])\n            if m.group(1):\n                result.extend(cls.escaped_chars[m.group(1)[1]])\n            elif m.group(2):\n                result.append(int(m.group(2)[1:], 8))\n            elif m.group(3):\n                pass\n            elif m.group(5):\n                result.extend(b\"\\n\")\n            elif m.group(6):\n                result.extend(b\"(\")\n                nesting_depth += 1\n            elif m.group(7):\n                if nesting_depth == 0:\n                    return bytes(result), m.end()\n                result.extend(b\")\")\n                nesting_depth -= 1\n            offset = m.end()\n        msg = \"unfinished literal string\"\n        raise PdfFormatError(msg)\n\n    re_xref_section_start = re.compile(whitespace_optional + rb\"xref\" + newline)\n    re_xref_subsection_start = re.compile(\n        whitespace_optional\n        + rb\"([0-9]+)\"\n        + whitespace_mandatory\n        + rb\"([0-9]+)\"\n        + whitespace_optional\n        + newline_only\n    )\n    re_xref_entry = re.compile(rb\"([0-9]{10}) ([0-9]{5}) ([fn])( \\r| \\n|\\r\\n)\")\n\n    def read_xref_table(self, xref_section_offset):\n        subsection_found = False\n        m = self.re_xref_section_start.match(\n            self.buf, xref_section_offset + self.start_offset\n        )\n        check_format_condition(m, \"xref section start not found\")\n        offset = m.end()\n        while True:\n            m = self.re_xref_subsection_start.match(self.buf, offset)\n            if not m:\n                check_format_condition(\n                    subsection_found, \"xref subsection start not found\"\n                )\n                break\n            subsection_found = True\n            offset = m.end()\n            first_object = int(m.group(1))\n            num_objects = int(m.group(2))\n            for i in range(first_object, first_object + num_objects):\n                m = self.re_xref_entry.match(self.buf, offset)\n                check_format_condition(m, \"xref entry not found\")\n                offset = m.end()\n                is_free = m.group(3) == b\"f\"\n                if not is_free:\n                    generation = int(m.group(2))\n                    new_entry = (int(m.group(1)), generation)\n                    if i not in self.xref_table:\n                        self.xref_table[i] = new_entry\n        return offset\n\n    def read_indirect(self, ref, max_nesting=-1):\n        offset, generation = self.xref_table[ref[0]]\n        check_format_condition(\n            generation == ref[1],\n            f\"expected to find generation {ref[1]} for object ID {ref[0]} in xref \"\n            f\"table, instead found generation {generation} at offset {offset}\",\n        )\n        value = self.get_value(\n            self.buf,\n            offset + self.start_offset,\n            expect_indirect=IndirectReference(*ref),\n            max_nesting=max_nesting,\n        )[0]\n        self.cached_objects[ref] = value\n        return value\n\n    def linearize_page_tree(self, node=None):\n        if node is None:\n            node = self.page_tree_root\n        check_format_condition(\n            node[b\"Type\"] == b\"Pages\", \"/Type of page tree node is not /Pages\"\n        )\n        pages = []\n        for kid in node[b\"Kids\"]:\n            kid_object = self.read_indirect(kid)\n            if kid_object[b\"Type\"] == b\"Page\":\n                pages.append(kid)\n            else:\n                pages.extend(self.linearize_page_tree(node=kid_object))\n        return pages\n", "src/PIL/PcdImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PCD file handling\n#\n# History:\n#       96-05-10 fl     Created\n#       96-05-27 fl     Added draft mode (128x192, 256x384)\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\n\n##\n# Image plugin for PhotoCD images.  This plugin only reads the 768x512\n# image from the file; higher resolutions are encoded in a proprietary\n# encoding.\n\n\nclass PcdImageFile(ImageFile.ImageFile):\n    format = \"PCD\"\n    format_description = \"Kodak PhotoCD\"\n\n    def _open(self) -> None:\n        # rough\n        assert self.fp is not None\n\n        self.fp.seek(2048)\n        s = self.fp.read(2048)\n\n        if s[:4] != b\"PCD_\":\n            msg = \"not a PCD file\"\n            raise SyntaxError(msg)\n\n        orientation = s[1538] & 3\n        self.tile_post_rotate = None\n        if orientation == 1:\n            self.tile_post_rotate = 90\n        elif orientation == 3:\n            self.tile_post_rotate = -90\n\n        self._mode = \"RGB\"\n        self._size = 768, 512  # FIXME: not correct for rotated images!\n        self.tile = [(\"pcd\", (0, 0) + self.size, 96 * 2048, None)]\n\n    def load_end(self) -> None:\n        if self.tile_post_rotate:\n            # Handle rotated PCDs\n            assert self.im is not None\n\n            self.im = self.im.rotate(self.tile_post_rotate)\n            self._size = self.im.size\n\n\n#\n# registry\n\nImage.register_open(PcdImageFile.format, PcdImageFile)\n\nImage.register_extension(PcdImageFile.format, \".pcd\")\n", "src/PIL/EpsImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# EPS file handling\n#\n# History:\n# 1995-09-01 fl   Created (0.1)\n# 1996-05-18 fl   Don't choke on \"atend\" fields, Ghostscript interface (0.2)\n# 1996-08-22 fl   Don't choke on floating point BoundingBox values\n# 1996-08-23 fl   Handle files from Macintosh (0.3)\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)\n# 2003-09-07 fl   Check gs.close status (from Federico Di Gregorio) (0.5)\n# 2014-05-07 e    Handling of EPS with binary preview and fixed resolution\n#                 resizing\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport re\nimport subprocess\nimport sys\nimport tempfile\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i32le as i32\nfrom ._deprecate import deprecate\n\n# --------------------------------------------------------------------\n\n\nsplit = re.compile(r\"^%%([^:]*):[ \\t]*(.*)[ \\t]*$\")\nfield = re.compile(r\"^%[%!\\w]([^:]*)[ \\t]*$\")\n\ngs_binary: str | bool | None = None\ngs_windows_binary = None\n\n\ndef has_ghostscript() -> bool:\n    global gs_binary, gs_windows_binary\n    if gs_binary is None:\n        if sys.platform.startswith(\"win\"):\n            if gs_windows_binary is None:\n                import shutil\n\n                for binary in (\"gswin32c\", \"gswin64c\", \"gs\"):\n                    if shutil.which(binary) is not None:\n                        gs_windows_binary = binary\n                        break\n                else:\n                    gs_windows_binary = False\n            gs_binary = gs_windows_binary\n        else:\n            try:\n                subprocess.check_call([\"gs\", \"--version\"], stdout=subprocess.DEVNULL)\n                gs_binary = \"gs\"\n            except OSError:\n                gs_binary = False\n    return gs_binary is not False\n\n\ndef Ghostscript(tile, size, fp, scale=1, transparency=False):\n    \"\"\"Render an image using Ghostscript\"\"\"\n    global gs_binary\n    if not has_ghostscript():\n        msg = \"Unable to locate Ghostscript on paths\"\n        raise OSError(msg)\n\n    # Unpack decoder tile\n    decoder, tile, offset, data = tile[0]\n    length, bbox = data\n\n    # Hack to support hi-res rendering\n    scale = int(scale) or 1\n    width = size[0] * scale\n    height = size[1] * scale\n    # resolution is dependent on bbox and size\n    res_x = 72.0 * width / (bbox[2] - bbox[0])\n    res_y = 72.0 * height / (bbox[3] - bbox[1])\n\n    out_fd, outfile = tempfile.mkstemp()\n    os.close(out_fd)\n\n    infile_temp = None\n    if hasattr(fp, \"name\") and os.path.exists(fp.name):\n        infile = fp.name\n    else:\n        in_fd, infile_temp = tempfile.mkstemp()\n        os.close(in_fd)\n        infile = infile_temp\n\n        # Ignore length and offset!\n        # Ghostscript can read it\n        # Copy whole file to read in Ghostscript\n        with open(infile_temp, \"wb\") as f:\n            # fetch length of fp\n            fp.seek(0, io.SEEK_END)\n            fsize = fp.tell()\n            # ensure start position\n            # go back\n            fp.seek(0)\n            lengthfile = fsize\n            while lengthfile > 0:\n                s = fp.read(min(lengthfile, 100 * 1024))\n                if not s:\n                    break\n                lengthfile -= len(s)\n                f.write(s)\n\n    device = \"pngalpha\" if transparency else \"ppmraw\"\n\n    # Build Ghostscript command\n    command = [\n        gs_binary,\n        \"-q\",  # quiet mode\n        f\"-g{width:d}x{height:d}\",  # set output geometry (pixels)\n        f\"-r{res_x:f}x{res_y:f}\",  # set input DPI (dots per inch)\n        \"-dBATCH\",  # exit after processing\n        \"-dNOPAUSE\",  # don't pause between pages\n        \"-dSAFER\",  # safe mode\n        f\"-sDEVICE={device}\",\n        f\"-sOutputFile={outfile}\",  # output file\n        # adjust for image origin\n        \"-c\",\n        f\"{-bbox[0]} {-bbox[1]} translate\",\n        \"-f\",\n        infile,  # input file\n        # showpage (see https://bugs.ghostscript.com/show_bug.cgi?id=698272)\n        \"-c\",\n        \"showpage\",\n    ]\n\n    # push data through Ghostscript\n    try:\n        startupinfo = None\n        if sys.platform.startswith(\"win\"):\n            startupinfo = subprocess.STARTUPINFO()\n            startupinfo.dwFlags |= subprocess.STARTF_USESHOWWINDOW\n        subprocess.check_call(command, startupinfo=startupinfo)\n        out_im = Image.open(outfile)\n        out_im.load()\n    finally:\n        try:\n            os.unlink(outfile)\n            if infile_temp:\n                os.unlink(infile_temp)\n        except OSError:\n            pass\n\n    im = out_im.im.copy()\n    out_im.close()\n    return im\n\n\nclass PSFile:\n    \"\"\"\n    Wrapper for bytesio object that treats either CR or LF as end of line.\n    This class is no longer used internally, but kept for backwards compatibility.\n    \"\"\"\n\n    def __init__(self, fp):\n        deprecate(\n            \"PSFile\",\n            11,\n            action=\"If you need the functionality of this class \"\n            \"you will need to implement it yourself.\",\n        )\n        self.fp = fp\n        self.char = None\n\n    def seek(self, offset, whence=io.SEEK_SET):\n        self.char = None\n        self.fp.seek(offset, whence)\n\n    def readline(self) -> str:\n        s = [self.char or b\"\"]\n        self.char = None\n\n        c = self.fp.read(1)\n        while (c not in b\"\\r\\n\") and len(c):\n            s.append(c)\n            c = self.fp.read(1)\n\n        self.char = self.fp.read(1)\n        # line endings can be 1 or 2 of \\r \\n, in either order\n        if self.char in b\"\\r\\n\":\n            self.char = None\n\n        return b\"\".join(s).decode(\"latin-1\")\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"%!PS\" or (len(prefix) >= 4 and i32(prefix) == 0xC6D3D0C5)\n\n\n##\n# Image plugin for Encapsulated PostScript. This plugin supports only\n# a few variants of this format.\n\n\nclass EpsImageFile(ImageFile.ImageFile):\n    \"\"\"EPS File Parser for the Python Imaging Library\"\"\"\n\n    format = \"EPS\"\n    format_description = \"Encapsulated Postscript\"\n\n    mode_map = {1: \"L\", 2: \"LAB\", 3: \"RGB\", 4: \"CMYK\"}\n\n    def _open(self) -> None:\n        (length, offset) = self._find_offset(self.fp)\n\n        # go to offset - start of \"%!PS\"\n        self.fp.seek(offset)\n\n        self._mode = \"RGB\"\n        self._size = None\n\n        byte_arr = bytearray(255)\n        bytes_mv = memoryview(byte_arr)\n        bytes_read = 0\n        reading_header_comments = True\n        reading_trailer_comments = False\n        trailer_reached = False\n\n        def check_required_header_comments() -> None:\n            if \"PS-Adobe\" not in self.info:\n                msg = 'EPS header missing \"%!PS-Adobe\" comment'\n                raise SyntaxError(msg)\n            if \"BoundingBox\" not in self.info:\n                msg = 'EPS header missing \"%%BoundingBox\" comment'\n                raise SyntaxError(msg)\n\n        def _read_comment(s: str) -> bool:\n            nonlocal reading_trailer_comments\n            try:\n                m = split.match(s)\n            except re.error as e:\n                msg = \"not an EPS file\"\n                raise SyntaxError(msg) from e\n\n            if not m:\n                return False\n\n            k, v = m.group(1, 2)\n            self.info[k] = v\n            if k == \"BoundingBox\":\n                if v == \"(atend)\":\n                    reading_trailer_comments = True\n                elif not self._size or (trailer_reached and reading_trailer_comments):\n                    try:\n                        # Note: The DSC spec says that BoundingBox\n                        # fields should be integers, but some drivers\n                        # put floating point values there anyway.\n                        box = [int(float(i)) for i in v.split()]\n                        self._size = box[2] - box[0], box[3] - box[1]\n                        self.tile = [(\"eps\", (0, 0) + self.size, offset, (length, box))]\n                    except Exception:\n                        pass\n            return True\n\n        while True:\n            byte = self.fp.read(1)\n            if byte == b\"\":\n                # if we didn't read a byte we must be at the end of the file\n                if bytes_read == 0:\n                    break\n            elif byte in b\"\\r\\n\":\n                # if we read a line ending character, ignore it and parse what\n                # we have already read. if we haven't read any other characters,\n                # continue reading\n                if bytes_read == 0:\n                    continue\n            else:\n                # ASCII/hexadecimal lines in an EPS file must not exceed\n                # 255 characters, not including line ending characters\n                if bytes_read >= 255:\n                    # only enforce this for lines starting with a \"%\",\n                    # otherwise assume it's binary data\n                    if byte_arr[0] == ord(\"%\"):\n                        msg = \"not an EPS file\"\n                        raise SyntaxError(msg)\n                    else:\n                        if reading_header_comments:\n                            check_required_header_comments()\n                            reading_header_comments = False\n                        # reset bytes_read so we can keep reading\n                        # data until the end of the line\n                        bytes_read = 0\n                byte_arr[bytes_read] = byte[0]\n                bytes_read += 1\n                continue\n\n            if reading_header_comments:\n                # Load EPS header\n\n                # if this line doesn't start with a \"%\",\n                # or does start with \"%%EndComments\",\n                # then we've reached the end of the header/comments\n                if byte_arr[0] != ord(\"%\") or bytes_mv[:13] == b\"%%EndComments\":\n                    check_required_header_comments()\n                    reading_header_comments = False\n                    continue\n\n                s = str(bytes_mv[:bytes_read], \"latin-1\")\n                if not _read_comment(s):\n                    m = field.match(s)\n                    if m:\n                        k = m.group(1)\n                        if k[:8] == \"PS-Adobe\":\n                            self.info[\"PS-Adobe\"] = k[9:]\n                        else:\n                            self.info[k] = \"\"\n                    elif s[0] == \"%\":\n                        # handle non-DSC PostScript comments that some\n                        # tools mistakenly put in the Comments section\n                        pass\n                    else:\n                        msg = \"bad EPS header\"\n                        raise OSError(msg)\n            elif bytes_mv[:11] == b\"%ImageData:\":\n                # Check for an \"ImageData\" descriptor\n                # https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577413_pgfId-1035096\n\n                # Values:\n                # columns\n                # rows\n                # bit depth (1 or 8)\n                # mode (1: L, 2: LAB, 3: RGB, 4: CMYK)\n                # number of padding channels\n                # block size (number of bytes per row per channel)\n                # binary/ascii (1: binary, 2: ascii)\n                # data start identifier (the image data follows after a single line\n                #   consisting only of this quoted value)\n                image_data_values = byte_arr[11:bytes_read].split(None, 7)\n                columns, rows, bit_depth, mode_id = (\n                    int(value) for value in image_data_values[:4]\n                )\n\n                if bit_depth == 1:\n                    self._mode = \"1\"\n                elif bit_depth == 8:\n                    try:\n                        self._mode = self.mode_map[mode_id]\n                    except ValueError:\n                        break\n                else:\n                    break\n\n                self._size = columns, rows\n                return\n            elif bytes_mv[:5] == b\"%%EOF\":\n                break\n            elif trailer_reached and reading_trailer_comments:\n                # Load EPS trailer\n                s = str(bytes_mv[:bytes_read], \"latin-1\")\n                _read_comment(s)\n            elif bytes_mv[:9] == b\"%%Trailer\":\n                trailer_reached = True\n            bytes_read = 0\n\n        check_required_header_comments()\n\n        if not self._size:\n            msg = \"cannot determine EPS bounding box\"\n            raise OSError(msg)\n\n    def _find_offset(self, fp):\n        s = fp.read(4)\n\n        if s == b\"%!PS\":\n            # for HEAD without binary preview\n            fp.seek(0, io.SEEK_END)\n            length = fp.tell()\n            offset = 0\n        elif i32(s) == 0xC6D3D0C5:\n            # FIX for: Some EPS file not handled correctly / issue #302\n            # EPS can contain binary data\n            # or start directly with latin coding\n            # more info see:\n            # https://web.archive.org/web/20160528181353/http://partners.adobe.com/public/developer/en/ps/5002.EPSF_Spec.pdf\n            s = fp.read(8)\n            offset = i32(s)\n            length = i32(s, 4)\n        else:\n            msg = \"not an EPS file\"\n            raise SyntaxError(msg)\n\n        return length, offset\n\n    def load(self, scale=1, transparency=False):\n        # Load EPS via Ghostscript\n        if self.tile:\n            self.im = Ghostscript(self.tile, self.size, self.fp, scale, transparency)\n            self._mode = self.im.mode\n            self._size = self.im.size\n            self.tile = []\n        return Image.Image.load(self)\n\n    def load_seek(self, pos: int) -> None:\n        # we can't incrementally load, so force ImageFile.parser to\n        # use our custom load method by defining this method.\n        pass\n\n\n# --------------------------------------------------------------------\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes, eps: int = 1) -> None:\n    \"\"\"EPS Writer for the Python Imaging Library.\"\"\"\n\n    # make sure image data is available\n    im.load()\n\n    # determine PostScript image mode\n    if im.mode == \"L\":\n        operator = (8, 1, b\"image\")\n    elif im.mode == \"RGB\":\n        operator = (8, 3, b\"false 3 colorimage\")\n    elif im.mode == \"CMYK\":\n        operator = (8, 4, b\"false 4 colorimage\")\n    else:\n        msg = \"image mode is not supported\"\n        raise ValueError(msg)\n\n    if eps:\n        # write EPS header\n        fp.write(b\"%!PS-Adobe-3.0 EPSF-3.0\\n\")\n        fp.write(b\"%%Creator: PIL 0.1 EpsEncode\\n\")\n        # fp.write(\"%%CreationDate: %s\"...)\n        fp.write(b\"%%%%BoundingBox: 0 0 %d %d\\n\" % im.size)\n        fp.write(b\"%%Pages: 1\\n\")\n        fp.write(b\"%%EndComments\\n\")\n        fp.write(b\"%%Page: 1 1\\n\")\n        fp.write(b\"%%ImageData: %d %d \" % im.size)\n        fp.write(b'%d %d 0 1 1 \"%s\"\\n' % operator)\n\n    # image header\n    fp.write(b\"gsave\\n\")\n    fp.write(b\"10 dict begin\\n\")\n    fp.write(b\"/buf %d string def\\n\" % (im.size[0] * operator[1]))\n    fp.write(b\"%d %d scale\\n\" % im.size)\n    fp.write(b\"%d %d 8\\n\" % im.size)  # <= bits\n    fp.write(b\"[%d 0 0 -%d 0 %d]\\n\" % (im.size[0], im.size[1], im.size[1]))\n    fp.write(b\"{ currentfile buf readhexstring pop } bind\\n\")\n    fp.write(operator[2] + b\"\\n\")\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n    ImageFile._save(im, fp, [(\"eps\", (0, 0) + im.size, 0, None)])\n\n    fp.write(b\"\\n%%%%EndBinary\\n\")\n    fp.write(b\"grestore end\\n\")\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\n# --------------------------------------------------------------------\n\n\nImage.register_open(EpsImageFile.format, EpsImageFile, _accept)\n\nImage.register_save(EpsImageFile.format, _save)\n\nImage.register_extensions(EpsImageFile.format, [\".ps\", \".eps\"])\n\nImage.register_mime(EpsImageFile.format, \"application/postscript\")\n", "src/PIL/ImageCms.py": "# The Python Imaging Library.\n# $Id$\n\n# Optional color management support, based on Kevin Cazabon's PyCMS\n# library.\n\n# Originally released under LGPL.  Graciously donated to PIL in\n# March 2009, for distribution under the standard PIL license\n\n# History:\n\n# 2009-03-08 fl   Added to PIL.\n\n# Copyright (C) 2002-2003 Kevin Cazabon\n# Copyright (c) 2009 by Fredrik Lundh\n# Copyright (c) 2013 by Eric Soroos\n\n# See the README file for information on usage and redistribution.  See\n# below for the original description.\nfrom __future__ import annotations\n\nimport operator\nimport sys\nfrom enum import IntEnum, IntFlag\nfrom functools import reduce\nfrom typing import Any, Literal, SupportsFloat, SupportsInt, Union\n\nfrom . import Image, __version__\nfrom ._deprecate import deprecate\nfrom ._typing import SupportsRead\n\ntry:\n    from . import _imagingcms as core\nexcept ImportError as ex:\n    # Allow error import for doc purposes, but error out when accessing\n    # anything in core.\n    from ._util import DeferredError\n\n    core = DeferredError.new(ex)\n\n_DESCRIPTION = \"\"\"\npyCMS\n\n    a Python / PIL interface to the littleCMS ICC Color Management System\n    Copyright (C) 2002-2003 Kevin Cazabon\n    kevin@cazabon.com\n    https://www.cazabon.com\n\n    pyCMS home page:  https://www.cazabon.com/pyCMS\n    littleCMS home page:  https://www.littlecms.com\n    (littleCMS is Copyright (C) 1998-2001 Marti Maria)\n\n    Originally released under LGPL.  Graciously donated to PIL in\n    March 2009, for distribution under the standard PIL license\n\n    The pyCMS.py module provides a \"clean\" interface between Python/PIL and\n    pyCMSdll, taking care of some of the more complex handling of the direct\n    pyCMSdll functions, as well as error-checking and making sure that all\n    relevant data is kept together.\n\n    While it is possible to call pyCMSdll functions directly, it's not highly\n    recommended.\n\n    Version History:\n\n        1.0.0 pil       Oct 2013 Port to LCMS 2.\n\n        0.1.0 pil mod   March 10, 2009\n\n                        Renamed display profile to proof profile. The proof\n                        profile is the profile of the device that is being\n                        simulated, not the profile of the device which is\n                        actually used to display/print the final simulation\n                        (that'd be the output profile) - also see LCMSAPI.txt\n                        input colorspace -> using 'renderingIntent' -> proof\n                        colorspace -> using 'proofRenderingIntent' -> output\n                        colorspace\n\n                        Added LCMS FLAGS support.\n                        Added FLAGS[\"SOFTPROOFING\"] as default flag for\n                        buildProofTransform (otherwise the proof profile/intent\n                        would be ignored).\n\n        0.1.0 pil       March 2009 - added to PIL, as PIL.ImageCms\n\n        0.0.2 alpha     Jan 6, 2002\n\n                        Added try/except statements around type() checks of\n                        potential CObjects... Python won't let you use type()\n                        on them, and raises a TypeError (stupid, if you ask\n                        me!)\n\n                        Added buildProofTransformFromOpenProfiles() function.\n                        Additional fixes in DLL, see DLL code for details.\n\n        0.0.1 alpha     first public release, Dec. 26, 2002\n\n    Known to-do list with current version (of Python interface, not pyCMSdll):\n\n        none\n\n\"\"\"\n\n_VERSION = \"1.0.0 pil\"\n\n\ndef __getattr__(name: str) -> Any:\n    if name == \"DESCRIPTION\":\n        deprecate(\"PIL.ImageCms.DESCRIPTION\", 12)\n        return _DESCRIPTION\n    elif name == \"VERSION\":\n        deprecate(\"PIL.ImageCms.VERSION\", 12)\n        return _VERSION\n    elif name == \"FLAGS\":\n        deprecate(\"PIL.ImageCms.FLAGS\", 12, \"PIL.ImageCms.Flags\")\n        return _FLAGS\n    msg = f\"module '{__name__}' has no attribute '{name}'\"\n    raise AttributeError(msg)\n\n\n# --------------------------------------------------------------------.\n\n\n#\n# intent/direction values\n\n\nclass Intent(IntEnum):\n    PERCEPTUAL = 0\n    RELATIVE_COLORIMETRIC = 1\n    SATURATION = 2\n    ABSOLUTE_COLORIMETRIC = 3\n\n\nclass Direction(IntEnum):\n    INPUT = 0\n    OUTPUT = 1\n    PROOF = 2\n\n\n#\n# flags\n\n\nclass Flags(IntFlag):\n    \"\"\"Flags and documentation are taken from ``lcms2.h``.\"\"\"\n\n    NONE = 0\n    NOCACHE = 0x0040\n    \"\"\"Inhibit 1-pixel cache\"\"\"\n    NOOPTIMIZE = 0x0100\n    \"\"\"Inhibit optimizations\"\"\"\n    NULLTRANSFORM = 0x0200\n    \"\"\"Don't transform anyway\"\"\"\n    GAMUTCHECK = 0x1000\n    \"\"\"Out of Gamut alarm\"\"\"\n    SOFTPROOFING = 0x4000\n    \"\"\"Do softproofing\"\"\"\n    BLACKPOINTCOMPENSATION = 0x2000\n    NOWHITEONWHITEFIXUP = 0x0004\n    \"\"\"Don't fix scum dot\"\"\"\n    HIGHRESPRECALC = 0x0400\n    \"\"\"Use more memory to give better accuracy\"\"\"\n    LOWRESPRECALC = 0x0800\n    \"\"\"Use less memory to minimize resources\"\"\"\n    # this should be 8BITS_DEVICELINK, but that is not a valid name in Python:\n    USE_8BITS_DEVICELINK = 0x0008\n    \"\"\"Create 8 bits devicelinks\"\"\"\n    GUESSDEVICECLASS = 0x0020\n    \"\"\"Guess device class (for ``transform2devicelink``)\"\"\"\n    KEEP_SEQUENCE = 0x0080\n    \"\"\"Keep profile sequence for devicelink creation\"\"\"\n    FORCE_CLUT = 0x0002\n    \"\"\"Force CLUT optimization\"\"\"\n    CLUT_POST_LINEARIZATION = 0x0001\n    \"\"\"create postlinearization tables if possible\"\"\"\n    CLUT_PRE_LINEARIZATION = 0x0010\n    \"\"\"create prelinearization tables if possible\"\"\"\n    NONEGATIVES = 0x8000\n    \"\"\"Prevent negative numbers in floating point transforms\"\"\"\n    COPY_ALPHA = 0x04000000\n    \"\"\"Alpha channels are copied on ``cmsDoTransform()``\"\"\"\n    NODEFAULTRESOURCEDEF = 0x01000000\n\n    _GRIDPOINTS_1 = 1 << 16\n    _GRIDPOINTS_2 = 2 << 16\n    _GRIDPOINTS_4 = 4 << 16\n    _GRIDPOINTS_8 = 8 << 16\n    _GRIDPOINTS_16 = 16 << 16\n    _GRIDPOINTS_32 = 32 << 16\n    _GRIDPOINTS_64 = 64 << 16\n    _GRIDPOINTS_128 = 128 << 16\n\n    @staticmethod\n    def GRIDPOINTS(n: int) -> Flags:\n        \"\"\"\n        Fine-tune control over number of gridpoints\n\n        :param n: :py:class:`int` in range ``0 <= n <= 255``\n        \"\"\"\n        return Flags.NONE | ((n & 0xFF) << 16)\n\n\n_MAX_FLAG = reduce(operator.or_, Flags)\n\n\n_FLAGS = {\n    \"MATRIXINPUT\": 1,\n    \"MATRIXOUTPUT\": 2,\n    \"MATRIXONLY\": (1 | 2),\n    \"NOWHITEONWHITEFIXUP\": 4,  # Don't hot fix scum dot\n    # Don't create prelinearization tables on precalculated transforms\n    # (internal use):\n    \"NOPRELINEARIZATION\": 16,\n    \"GUESSDEVICECLASS\": 32,  # Guess device class (for transform2devicelink)\n    \"NOTCACHE\": 64,  # Inhibit 1-pixel cache\n    \"NOTPRECALC\": 256,\n    \"NULLTRANSFORM\": 512,  # Don't transform anyway\n    \"HIGHRESPRECALC\": 1024,  # Use more memory to give better accuracy\n    \"LOWRESPRECALC\": 2048,  # Use less memory to minimize resources\n    \"WHITEBLACKCOMPENSATION\": 8192,\n    \"BLACKPOINTCOMPENSATION\": 8192,\n    \"GAMUTCHECK\": 4096,  # Out of Gamut alarm\n    \"SOFTPROOFING\": 16384,  # Do softproofing\n    \"PRESERVEBLACK\": 32768,  # Black preservation\n    \"NODEFAULTRESOURCEDEF\": 16777216,  # CRD special\n    \"GRIDPOINTS\": lambda n: (n & 0xFF) << 16,  # Gridpoints\n}\n\n\n# --------------------------------------------------------------------.\n# Experimental PIL-level API\n# --------------------------------------------------------------------.\n\n##\n# Profile.\n\n\nclass ImageCmsProfile:\n    def __init__(self, profile: str | SupportsRead[bytes] | core.CmsProfile) -> None:\n        \"\"\"\n        :param profile: Either a string representing a filename,\n            a file like object containing a profile or a\n            low-level profile object\n\n        \"\"\"\n\n        if isinstance(profile, str):\n            if sys.platform == \"win32\":\n                profile_bytes_path = profile.encode()\n                try:\n                    profile_bytes_path.decode(\"ascii\")\n                except UnicodeDecodeError:\n                    with open(profile, \"rb\") as f:\n                        self._set(core.profile_frombytes(f.read()))\n                    return\n            self._set(core.profile_open(profile), profile)\n        elif hasattr(profile, \"read\"):\n            self._set(core.profile_frombytes(profile.read()))\n        elif isinstance(profile, core.CmsProfile):\n            self._set(profile)\n        else:\n            msg = \"Invalid type for Profile\"  # type: ignore[unreachable]\n            raise TypeError(msg)\n\n    def _set(self, profile: core.CmsProfile, filename: str | None = None) -> None:\n        self.profile = profile\n        self.filename = filename\n        self.product_name = None  # profile.product_name\n        self.product_info = None  # profile.product_info\n\n    def tobytes(self) -> bytes:\n        \"\"\"\n        Returns the profile in a format suitable for embedding in\n        saved images.\n\n        :returns: a bytes object containing the ICC profile.\n        \"\"\"\n\n        return core.profile_tobytes(self.profile)\n\n\nclass ImageCmsTransform(Image.ImagePointHandler):\n    \"\"\"\n    Transform.  This can be used with the procedural API, or with the standard\n    :py:func:`~PIL.Image.Image.point` method.\n\n    Will return the output profile in the ``output.info['icc_profile']``.\n    \"\"\"\n\n    def __init__(\n        self,\n        input: ImageCmsProfile,\n        output: ImageCmsProfile,\n        input_mode: str,\n        output_mode: str,\n        intent: Intent = Intent.PERCEPTUAL,\n        proof: ImageCmsProfile | None = None,\n        proof_intent: Intent = Intent.ABSOLUTE_COLORIMETRIC,\n        flags: Flags = Flags.NONE,\n    ):\n        if proof is None:\n            self.transform = core.buildTransform(\n                input.profile, output.profile, input_mode, output_mode, intent, flags\n            )\n        else:\n            self.transform = core.buildProofTransform(\n                input.profile,\n                output.profile,\n                proof.profile,\n                input_mode,\n                output_mode,\n                intent,\n                proof_intent,\n                flags,\n            )\n        # Note: inputMode and outputMode are for pyCMS compatibility only\n        self.input_mode = self.inputMode = input_mode\n        self.output_mode = self.outputMode = output_mode\n\n        self.output_profile = output\n\n    def point(self, im: Image.Image) -> Image.Image:\n        return self.apply(im)\n\n    def apply(self, im: Image.Image, imOut: Image.Image | None = None) -> Image.Image:\n        im.load()\n        if imOut is None:\n            imOut = Image.new(self.output_mode, im.size, None)\n        self.transform.apply(im.im.id, imOut.im.id)\n        imOut.info[\"icc_profile\"] = self.output_profile.tobytes()\n        return imOut\n\n    def apply_in_place(self, im: Image.Image) -> Image.Image:\n        im.load()\n        if im.mode != self.output_mode:\n            msg = \"mode mismatch\"\n            raise ValueError(msg)  # wrong output mode\n        self.transform.apply(im.im.id, im.im.id)\n        im.info[\"icc_profile\"] = self.output_profile.tobytes()\n        return im\n\n\ndef get_display_profile(handle: SupportsInt | None = None) -> ImageCmsProfile | None:\n    \"\"\"\n    (experimental) Fetches the profile for the current display device.\n\n    :returns: ``None`` if the profile is not known.\n    \"\"\"\n\n    if sys.platform != \"win32\":\n        return None\n\n    from . import ImageWin  # type: ignore[unused-ignore, unreachable]\n\n    if isinstance(handle, ImageWin.HDC):\n        profile = core.get_display_profile_win32(int(handle), 1)\n    else:\n        profile = core.get_display_profile_win32(int(handle or 0))\n    if profile is None:\n        return None\n    return ImageCmsProfile(profile)\n\n\n# --------------------------------------------------------------------.\n# pyCMS compatible layer\n# --------------------------------------------------------------------.\n\n_CmsProfileCompatible = Union[\n    str, SupportsRead[bytes], core.CmsProfile, ImageCmsProfile\n]\n\n\nclass PyCMSError(Exception):\n    \"\"\"(pyCMS) Exception class.\n    This is used for all errors in the pyCMS API.\"\"\"\n\n    pass\n\n\ndef profileToProfile(\n    im: Image.Image,\n    inputProfile: _CmsProfileCompatible,\n    outputProfile: _CmsProfileCompatible,\n    renderingIntent: Intent = Intent.PERCEPTUAL,\n    outputMode: str | None = None,\n    inPlace: bool = False,\n    flags: Flags = Flags.NONE,\n) -> Image.Image | None:\n    \"\"\"\n    (pyCMS) Applies an ICC transformation to a given image, mapping from\n    ``inputProfile`` to ``outputProfile``.\n\n    If the input or output profiles specified are not valid filenames, a\n    :exc:`PyCMSError` will be raised.  If ``inPlace`` is ``True`` and\n    ``outputMode != im.mode``, a :exc:`PyCMSError` will be raised.\n    If an error occurs during application of the profiles,\n    a :exc:`PyCMSError` will be raised.\n    If ``outputMode`` is not a mode supported by the ``outputProfile`` (or by pyCMS),\n    a :exc:`PyCMSError` will be raised.\n\n    This function applies an ICC transformation to im from ``inputProfile``'s\n    color space to ``outputProfile``'s color space using the specified rendering\n    intent to decide how to handle out-of-gamut colors.\n\n    ``outputMode`` can be used to specify that a color mode conversion is to\n    be done using these profiles, but the specified profiles must be able\n    to handle that mode.  I.e., if converting im from RGB to CMYK using\n    profiles, the input profile must handle RGB data, and the output\n    profile must handle CMYK data.\n\n    :param im: An open :py:class:`~PIL.Image.Image` object (i.e. Image.new(...)\n        or Image.open(...), etc.)\n    :param inputProfile: String, as a valid filename path to the ICC input\n        profile you wish to use for this image, or a profile object\n    :param outputProfile: String, as a valid filename path to the ICC output\n        profile you wish to use for this image, or a profile object\n    :param renderingIntent: Integer (0-3) specifying the rendering intent you\n        wish to use for the transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param outputMode: A valid PIL mode for the output image (i.e. \"RGB\",\n        \"CMYK\", etc.).  Note: if rendering the image \"inPlace\", outputMode\n        MUST be the same mode as the input, or omitted completely.  If\n        omitted, the outputMode will be the same as the mode of the input\n        image (im.mode)\n    :param inPlace: Boolean.  If ``True``, the original image is modified in-place,\n        and ``None`` is returned.  If ``False`` (default), a new\n        :py:class:`~PIL.Image.Image` object is returned with the transform applied.\n    :param flags: Integer (0-...) specifying additional flags\n    :returns: Either None or a new :py:class:`~PIL.Image.Image` object, depending on\n        the value of ``inPlace``\n    :exception PyCMSError:\n    \"\"\"\n\n    if outputMode is None:\n        outputMode = im.mode\n\n    if not isinstance(renderingIntent, int) or not (0 <= renderingIntent <= 3):\n        msg = \"renderingIntent must be an integer between 0 and 3\"\n        raise PyCMSError(msg)\n\n    if not isinstance(flags, int) or not (0 <= flags <= _MAX_FLAG):\n        msg = f\"flags must be an integer between 0 and {_MAX_FLAG}\"\n        raise PyCMSError(msg)\n\n    try:\n        if not isinstance(inputProfile, ImageCmsProfile):\n            inputProfile = ImageCmsProfile(inputProfile)\n        if not isinstance(outputProfile, ImageCmsProfile):\n            outputProfile = ImageCmsProfile(outputProfile)\n        transform = ImageCmsTransform(\n            inputProfile,\n            outputProfile,\n            im.mode,\n            outputMode,\n            renderingIntent,\n            flags=flags,\n        )\n        if inPlace:\n            transform.apply_in_place(im)\n            imOut = None\n        else:\n            imOut = transform.apply(im)\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n    return imOut\n\n\ndef getOpenProfile(\n    profileFilename: str | SupportsRead[bytes] | core.CmsProfile,\n) -> ImageCmsProfile:\n    \"\"\"\n    (pyCMS) Opens an ICC profile file.\n\n    The PyCMSProfile object can be passed back into pyCMS for use in creating\n    transforms and such (as in ImageCms.buildTransformFromOpenProfiles()).\n\n    If ``profileFilename`` is not a valid filename for an ICC profile,\n    a :exc:`PyCMSError` will be raised.\n\n    :param profileFilename: String, as a valid filename path to the ICC profile\n        you wish to open, or a file-like object.\n    :returns: A CmsProfile class object.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        return ImageCmsProfile(profileFilename)\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef buildTransform(\n    inputProfile: _CmsProfileCompatible,\n    outputProfile: _CmsProfileCompatible,\n    inMode: str,\n    outMode: str,\n    renderingIntent: Intent = Intent.PERCEPTUAL,\n    flags: Flags = Flags.NONE,\n) -> ImageCmsTransform:\n    \"\"\"\n    (pyCMS) Builds an ICC transform mapping from the ``inputProfile`` to the\n    ``outputProfile``. Use applyTransform to apply the transform to a given\n    image.\n\n    If the input or output profiles specified are not valid filenames, a\n    :exc:`PyCMSError` will be raised. If an error occurs during creation\n    of the transform, a :exc:`PyCMSError` will be raised.\n\n    If ``inMode`` or ``outMode`` are not a mode supported by the ``outputProfile``\n    (or by pyCMS), a :exc:`PyCMSError` will be raised.\n\n    This function builds and returns an ICC transform from the ``inputProfile``\n    to the ``outputProfile`` using the ``renderingIntent`` to determine what to do\n    with out-of-gamut colors.  It will ONLY work for converting images that\n    are in ``inMode`` to images that are in ``outMode`` color format (PIL mode,\n    i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.).\n\n    Building the transform is a fair part of the overhead in\n    ImageCms.profileToProfile(), so if you're planning on converting multiple\n    images using the same input/output settings, this can save you time.\n    Once you have a transform object, it can be used with\n    ImageCms.applyProfile() to convert images without the need to re-compute\n    the lookup table for the transform.\n\n    The reason pyCMS returns a class object rather than a handle directly\n    to the transform is that it needs to keep track of the PIL input/output\n    modes that the transform is meant for.  These attributes are stored in\n    the ``inMode`` and ``outMode`` attributes of the object (which can be\n    manually overridden if you really want to, but I don't know of any\n    time that would be of use, or would even work).\n\n    :param inputProfile: String, as a valid filename path to the ICC input\n        profile you wish to use for this transform, or a profile object\n    :param outputProfile: String, as a valid filename path to the ICC output\n        profile you wish to use for this transform, or a profile object\n    :param inMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param outMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param renderingIntent: Integer (0-3) specifying the rendering intent you\n        wish to use for the transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param flags: Integer (0-...) specifying additional flags\n    :returns: A CmsTransform class object.\n    :exception PyCMSError:\n    \"\"\"\n\n    if not isinstance(renderingIntent, int) or not (0 <= renderingIntent <= 3):\n        msg = \"renderingIntent must be an integer between 0 and 3\"\n        raise PyCMSError(msg)\n\n    if not isinstance(flags, int) or not (0 <= flags <= _MAX_FLAG):\n        msg = f\"flags must be an integer between 0 and {_MAX_FLAG}\"\n        raise PyCMSError(msg)\n\n    try:\n        if not isinstance(inputProfile, ImageCmsProfile):\n            inputProfile = ImageCmsProfile(inputProfile)\n        if not isinstance(outputProfile, ImageCmsProfile):\n            outputProfile = ImageCmsProfile(outputProfile)\n        return ImageCmsTransform(\n            inputProfile, outputProfile, inMode, outMode, renderingIntent, flags=flags\n        )\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef buildProofTransform(\n    inputProfile: _CmsProfileCompatible,\n    outputProfile: _CmsProfileCompatible,\n    proofProfile: _CmsProfileCompatible,\n    inMode: str,\n    outMode: str,\n    renderingIntent: Intent = Intent.PERCEPTUAL,\n    proofRenderingIntent: Intent = Intent.ABSOLUTE_COLORIMETRIC,\n    flags: Flags = Flags.SOFTPROOFING,\n) -> ImageCmsTransform:\n    \"\"\"\n    (pyCMS) Builds an ICC transform mapping from the ``inputProfile`` to the\n    ``outputProfile``, but tries to simulate the result that would be\n    obtained on the ``proofProfile`` device.\n\n    If the input, output, or proof profiles specified are not valid\n    filenames, a :exc:`PyCMSError` will be raised.\n\n    If an error occurs during creation of the transform,\n    a :exc:`PyCMSError` will be raised.\n\n    If ``inMode`` or ``outMode`` are not a mode supported by the ``outputProfile``\n    (or by pyCMS), a :exc:`PyCMSError` will be raised.\n\n    This function builds and returns an ICC transform from the ``inputProfile``\n    to the ``outputProfile``, but tries to simulate the result that would be\n    obtained on the ``proofProfile`` device using ``renderingIntent`` and\n    ``proofRenderingIntent`` to determine what to do with out-of-gamut\n    colors.  This is known as \"soft-proofing\".  It will ONLY work for\n    converting images that are in ``inMode`` to images that are in outMode\n    color format (PIL mode, i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.).\n\n    Usage of the resulting transform object is exactly the same as with\n    ImageCms.buildTransform().\n\n    Proof profiling is generally used when using an output device to get a\n    good idea of what the final printed/displayed image would look like on\n    the ``proofProfile`` device when it's quicker and easier to use the\n    output device for judging color.  Generally, this means that the\n    output device is a monitor, or a dye-sub printer (etc.), and the simulated\n    device is something more expensive, complicated, or time consuming\n    (making it difficult to make a real print for color judgement purposes).\n\n    Soft-proofing basically functions by adjusting the colors on the\n    output device to match the colors of the device being simulated. However,\n    when the simulated device has a much wider gamut than the output\n    device, you may obtain marginal results.\n\n    :param inputProfile: String, as a valid filename path to the ICC input\n        profile you wish to use for this transform, or a profile object\n    :param outputProfile: String, as a valid filename path to the ICC output\n        (monitor, usually) profile you wish to use for this transform, or a\n        profile object\n    :param proofProfile: String, as a valid filename path to the ICC proof\n        profile you wish to use for this transform, or a profile object\n    :param inMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param outMode: String, as a valid PIL mode that the appropriate profile\n        also supports (i.e. \"RGB\", \"RGBA\", \"CMYK\", etc.)\n    :param renderingIntent: Integer (0-3) specifying the rendering intent you\n        wish to use for the input->proof (simulated) transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param proofRenderingIntent: Integer (0-3) specifying the rendering intent\n        you wish to use for proof->output transform\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n        they do.\n    :param flags: Integer (0-...) specifying additional flags\n    :returns: A CmsTransform class object.\n    :exception PyCMSError:\n    \"\"\"\n\n    if not isinstance(renderingIntent, int) or not (0 <= renderingIntent <= 3):\n        msg = \"renderingIntent must be an integer between 0 and 3\"\n        raise PyCMSError(msg)\n\n    if not isinstance(flags, int) or not (0 <= flags <= _MAX_FLAG):\n        msg = f\"flags must be an integer between 0 and {_MAX_FLAG}\"\n        raise PyCMSError(msg)\n\n    try:\n        if not isinstance(inputProfile, ImageCmsProfile):\n            inputProfile = ImageCmsProfile(inputProfile)\n        if not isinstance(outputProfile, ImageCmsProfile):\n            outputProfile = ImageCmsProfile(outputProfile)\n        if not isinstance(proofProfile, ImageCmsProfile):\n            proofProfile = ImageCmsProfile(proofProfile)\n        return ImageCmsTransform(\n            inputProfile,\n            outputProfile,\n            inMode,\n            outMode,\n            renderingIntent,\n            proofProfile,\n            proofRenderingIntent,\n            flags,\n        )\n    except (OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\nbuildTransformFromOpenProfiles = buildTransform\nbuildProofTransformFromOpenProfiles = buildProofTransform\n\n\ndef applyTransform(\n    im: Image.Image, transform: ImageCmsTransform, inPlace: bool = False\n) -> Image.Image | None:\n    \"\"\"\n    (pyCMS) Applies a transform to a given image.\n\n    If ``im.mode != transform.input_mode``, a :exc:`PyCMSError` is raised.\n\n    If ``inPlace`` is ``True`` and ``transform.input_mode != transform.output_mode``, a\n    :exc:`PyCMSError` is raised.\n\n    If ``im.mode``, ``transform.input_mode`` or ``transform.output_mode`` is not\n    supported by pyCMSdll or the profiles you used for the transform, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while the transform is being applied,\n    a :exc:`PyCMSError` is raised.\n\n    This function applies a pre-calculated transform (from\n    ImageCms.buildTransform() or ImageCms.buildTransformFromOpenProfiles())\n    to an image. The transform can be used for multiple images, saving\n    considerable calculation time if doing the same conversion multiple times.\n\n    If you want to modify im in-place instead of receiving a new image as\n    the return value, set ``inPlace`` to ``True``.  This can only be done if\n    ``transform.input_mode`` and ``transform.output_mode`` are the same, because we\n    can't change the mode in-place (the buffer sizes for some modes are\n    different).  The default behavior is to return a new :py:class:`~PIL.Image.Image`\n    object of the same dimensions in mode ``transform.output_mode``.\n\n    :param im: An :py:class:`~PIL.Image.Image` object, and ``im.mode`` must be the same\n        as the ``input_mode`` supported by the transform.\n    :param transform: A valid CmsTransform class object\n    :param inPlace: Bool.  If ``True``, ``im`` is modified in place and ``None`` is\n        returned, if ``False``, a new :py:class:`~PIL.Image.Image` object with the\n        transform applied is returned (and ``im`` is not changed). The default is\n        ``False``.\n    :returns: Either ``None``, or a new :py:class:`~PIL.Image.Image` object,\n        depending on the value of ``inPlace``. The profile will be returned in\n        the image's ``info['icc_profile']``.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if inPlace:\n            transform.apply_in_place(im)\n            imOut = None\n        else:\n            imOut = transform.apply(im)\n    except (TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n    return imOut\n\n\ndef createProfile(\n    colorSpace: Literal[\"LAB\", \"XYZ\", \"sRGB\"], colorTemp: SupportsFloat = 0\n) -> core.CmsProfile:\n    \"\"\"\n    (pyCMS) Creates a profile.\n\n    If colorSpace not in ``[\"LAB\", \"XYZ\", \"sRGB\"]``,\n    a :exc:`PyCMSError` is raised.\n\n    If using LAB and ``colorTemp`` is not a positive integer,\n    a :exc:`PyCMSError` is raised.\n\n    If an error occurs while creating the profile,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to create common profiles on-the-fly instead of\n    having to supply a profile on disk and knowing the path to it.  It\n    returns a normal CmsProfile object that can be passed to\n    ImageCms.buildTransformFromOpenProfiles() to create a transform to apply\n    to images.\n\n    :param colorSpace: String, the color space of the profile you wish to\n        create.\n        Currently only \"LAB\", \"XYZ\", and \"sRGB\" are supported.\n    :param colorTemp: Positive number for the white point for the profile, in\n        degrees Kelvin (i.e. 5000, 6500, 9600, etc.).  The default is for D50\n        illuminant if omitted (5000k).  colorTemp is ONLY applied to LAB\n        profiles, and is ignored for XYZ and sRGB.\n    :returns: A CmsProfile class object\n    :exception PyCMSError:\n    \"\"\"\n\n    if colorSpace not in [\"LAB\", \"XYZ\", \"sRGB\"]:\n        msg = (\n            f\"Color space not supported for on-the-fly profile creation ({colorSpace})\"\n        )\n        raise PyCMSError(msg)\n\n    if colorSpace == \"LAB\":\n        try:\n            colorTemp = float(colorTemp)\n        except (TypeError, ValueError) as e:\n            msg = f'Color temperature must be numeric, \"{colorTemp}\" not valid'\n            raise PyCMSError(msg) from e\n\n    try:\n        return core.createProfile(colorSpace, colorTemp)\n    except (TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileName(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n\n    (pyCMS) Gets the internal product name for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile,\n    a :exc:`PyCMSError` is raised If an error occurs while trying\n    to obtain the name tag, a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the INTERNAL name of the profile (stored\n    in an ICC tag in the profile itself), usually the one used when the\n    profile was originally created.  Sometimes this tag also contains\n    additional information supplied by the creator.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal name of the profile as stored\n        in an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        # do it in python, not c.\n        #    // name was \"%s - %s\" (model, manufacturer) || Description ,\n        #    // but if the Model and Manufacturer were the same or the model\n        #    // was long, Just the model,  in 1.x\n        model = profile.profile.model\n        manufacturer = profile.profile.manufacturer\n\n        if not (model or manufacturer):\n            return (profile.profile.profile_description or \"\") + \"\\n\"\n        if not manufacturer or (model and len(model) > 30):\n            return f\"{model}\\n\"\n        return f\"{model} - {manufacturer}\\n\"\n\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileInfo(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the internal product information for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile,\n    a :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the info tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    info tag.  This often contains details about the profile, and how it\n    was created, as supplied by the creator.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        # add an extra newline to preserve pyCMS compatibility\n        # Python, not C. the white point bits weren't working well,\n        # so skipping.\n        # info was description \\r\\n\\r\\n copyright \\r\\n\\r\\n K007 tag \\r\\n\\r\\n whitepoint\n        description = profile.profile.profile_description\n        cpright = profile.profile.copyright\n        elements = [element for element in (description, cpright) if element]\n        return \"\\r\\n\\r\\n\".join(elements) + \"\\r\\n\\r\\n\"\n\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileCopyright(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the copyright for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the copyright tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    copyright tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.copyright or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileManufacturer(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the manufacturer for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the manufacturer tag, a\n    :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    manufacturer tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.manufacturer or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileModel(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the model for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the model tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    model tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in\n        an ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.model or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getProfileDescription(profile: _CmsProfileCompatible) -> str:\n    \"\"\"\n    (pyCMS) Gets the description for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the description tag,\n    a :exc:`PyCMSError` is raised.\n\n    Use this function to obtain the information stored in the profile's\n    description tag.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: A string containing the internal profile information stored in an\n        ICC tag.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        # add an extra newline to preserve pyCMS compatibility\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return (profile.profile.profile_description or \"\") + \"\\n\"\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef getDefaultIntent(profile: _CmsProfileCompatible) -> int:\n    \"\"\"\n    (pyCMS) Gets the default intent name for the given profile.\n\n    If ``profile`` isn't a valid CmsProfile object or filename to a profile, a\n    :exc:`PyCMSError` is raised.\n\n    If an error occurs while trying to obtain the default intent, a\n    :exc:`PyCMSError` is raised.\n\n    Use this function to determine the default (and usually best optimized)\n    rendering intent for this profile.  Most profiles support multiple\n    rendering intents, but are intended mostly for one type of conversion.\n    If you wish to use a different intent than returned, use\n    ImageCms.isIntentSupported() to verify it will work first.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :returns: Integer 0-3 specifying the default rendering intent for this\n        profile.\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n            they do.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        return profile.profile.rendering_intent\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef isIntentSupported(\n    profile: _CmsProfileCompatible, intent: Intent, direction: Direction\n) -> Literal[-1, 1]:\n    \"\"\"\n    (pyCMS) Checks if a given intent is supported.\n\n    Use this function to verify that you can use your desired\n    ``intent`` with ``profile``, and that ``profile`` can be used for the\n    input/output/proof profile as you desire.\n\n    Some profiles are created specifically for one \"direction\", can cannot\n    be used for others. Some profiles can only be used for certain\n    rendering intents, so it's best to either verify this before trying\n    to create a transform with them (using this function), or catch the\n    potential :exc:`PyCMSError` that will occur if they don't\n    support the modes you select.\n\n    :param profile: EITHER a valid CmsProfile object, OR a string of the\n        filename of an ICC profile.\n    :param intent: Integer (0-3) specifying the rendering intent you wish to\n        use with this profile\n\n            ImageCms.Intent.PERCEPTUAL            = 0 (DEFAULT)\n            ImageCms.Intent.RELATIVE_COLORIMETRIC = 1\n            ImageCms.Intent.SATURATION            = 2\n            ImageCms.Intent.ABSOLUTE_COLORIMETRIC = 3\n\n        see the pyCMS documentation for details on rendering intents and what\n            they do.\n    :param direction: Integer specifying if the profile is to be used for\n        input, output, or proof\n\n            INPUT  = 0 (or use ImageCms.Direction.INPUT)\n            OUTPUT = 1 (or use ImageCms.Direction.OUTPUT)\n            PROOF  = 2 (or use ImageCms.Direction.PROOF)\n\n    :returns: 1 if the intent/direction are supported, -1 if they are not.\n    :exception PyCMSError:\n    \"\"\"\n\n    try:\n        if not isinstance(profile, ImageCmsProfile):\n            profile = ImageCmsProfile(profile)\n        # FIXME: I get different results for the same data w. different\n        # compilers.  Bug in LittleCMS or in the binding?\n        if profile.profile.is_intent_supported(intent, direction):\n            return 1\n        else:\n            return -1\n    except (AttributeError, OSError, TypeError, ValueError) as v:\n        raise PyCMSError(v) from v\n\n\ndef versions() -> tuple[str, str | None, str, str]:\n    \"\"\"\n    (pyCMS) Fetches versions.\n    \"\"\"\n\n    deprecate(\n        \"PIL.ImageCms.versions()\",\n        12,\n        '(PIL.features.version(\"littlecms2\"), sys.version, PIL.__version__)',\n    )\n    return _VERSION, core.littlecms_version, sys.version.split()[0], __version__\n", "src/PIL/SgiImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# SGI image file handling\n#\n# See \"The SGI Image File Format (Draft version 0.97)\", Paul Haeberli.\n# <ftp://ftp.sgi.com/graphics/SGIIMAGESPEC>\n#\n#\n# History:\n# 2017-22-07 mb   Add RLE decompression\n# 2016-16-10 mb   Add save method without compression\n# 1995-09-10 fl   Created\n#\n# Copyright (c) 2016 by Mickael Bonfill.\n# Copyright (c) 2008 by Karsten Hiddemann.\n# Copyright (c) 1997 by Secret Labs AB.\n# Copyright (c) 1995 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nimport struct\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import o8\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 2 and i16(prefix) == 474\n\n\nMODES = {\n    (1, 1, 1): \"L\",\n    (1, 2, 1): \"L\",\n    (2, 1, 1): \"L;16B\",\n    (2, 2, 1): \"L;16B\",\n    (1, 3, 3): \"RGB\",\n    (2, 3, 3): \"RGB;16B\",\n    (1, 3, 4): \"RGBA\",\n    (2, 3, 4): \"RGBA;16B\",\n}\n\n\n##\n# Image plugin for SGI images.\nclass SgiImageFile(ImageFile.ImageFile):\n    format = \"SGI\"\n    format_description = \"SGI Image File Format\"\n\n    def _open(self) -> None:\n        # HEAD\n        assert self.fp is not None\n\n        headlen = 512\n        s = self.fp.read(headlen)\n\n        if not _accept(s):\n            msg = \"Not an SGI image file\"\n            raise ValueError(msg)\n\n        # compression : verbatim or RLE\n        compression = s[2]\n\n        # bpc : 1 or 2 bytes (8bits or 16bits)\n        bpc = s[3]\n\n        # dimension : 1, 2 or 3 (depending on xsize, ysize and zsize)\n        dimension = i16(s, 4)\n\n        # xsize : width\n        xsize = i16(s, 6)\n\n        # ysize : height\n        ysize = i16(s, 8)\n\n        # zsize : channels count\n        zsize = i16(s, 10)\n\n        # layout\n        layout = bpc, dimension, zsize\n\n        # determine mode from bits/zsize\n        rawmode = \"\"\n        try:\n            rawmode = MODES[layout]\n        except KeyError:\n            pass\n\n        if rawmode == \"\":\n            msg = \"Unsupported SGI image mode\"\n            raise ValueError(msg)\n\n        self._size = xsize, ysize\n        self._mode = rawmode.split(\";\")[0]\n        if self.mode == \"RGB\":\n            self.custom_mimetype = \"image/rgb\"\n\n        # orientation -1 : scanlines begins at the bottom-left corner\n        orientation = -1\n\n        # decoder info\n        if compression == 0:\n            pagesize = xsize * ysize * bpc\n            if bpc == 2:\n                self.tile = [\n                    (\"SGI16\", (0, 0) + self.size, headlen, (self.mode, 0, orientation))\n                ]\n            else:\n                self.tile = []\n                offset = headlen\n                for layer in self.mode:\n                    self.tile.append(\n                        (\"raw\", (0, 0) + self.size, offset, (layer, 0, orientation))\n                    )\n                    offset += pagesize\n        elif compression == 1:\n            self.tile = [\n                (\"sgi_rle\", (0, 0) + self.size, headlen, (rawmode, orientation, bpc))\n            ]\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode not in {\"RGB\", \"RGBA\", \"L\"}:\n        msg = \"Unsupported SGI image mode\"\n        raise ValueError(msg)\n\n    # Get the keyword arguments\n    info = im.encoderinfo\n\n    # Byte-per-pixel precision, 1 = 8bits per pixel\n    bpc = info.get(\"bpc\", 1)\n\n    if bpc not in (1, 2):\n        msg = \"Unsupported number of bytes per pixel\"\n        raise ValueError(msg)\n\n    # Flip the image, since the origin of SGI file is the bottom-left corner\n    orientation = -1\n    # Define the file as SGI File Format\n    magic_number = 474\n    # Run-Length Encoding Compression - Unsupported at this time\n    rle = 0\n\n    # Number of dimensions (x,y,z)\n    dim = 3\n    # X Dimension = width / Y Dimension = height\n    x, y = im.size\n    if im.mode == \"L\" and y == 1:\n        dim = 1\n    elif im.mode == \"L\":\n        dim = 2\n    # Z Dimension: Number of channels\n    z = len(im.mode)\n\n    if dim in {1, 2}:\n        z = 1\n\n    # assert we've got the right number of bands.\n    if len(im.getbands()) != z:\n        msg = f\"incorrect number of bands in SGI write: {z} vs {len(im.getbands())}\"\n        raise ValueError(msg)\n\n    # Minimum Byte value\n    pinmin = 0\n    # Maximum Byte value (255 = 8bits per pixel)\n    pinmax = 255\n    # Image name (79 characters max, truncated below in write)\n    img_name = os.path.splitext(os.path.basename(filename))[0]\n    if isinstance(img_name, str):\n        img_name = img_name.encode(\"ascii\", \"ignore\")\n    # Standard representation of pixel in the file\n    colormap = 0\n    fp.write(struct.pack(\">h\", magic_number))\n    fp.write(o8(rle))\n    fp.write(o8(bpc))\n    fp.write(struct.pack(\">H\", dim))\n    fp.write(struct.pack(\">H\", x))\n    fp.write(struct.pack(\">H\", y))\n    fp.write(struct.pack(\">H\", z))\n    fp.write(struct.pack(\">l\", pinmin))\n    fp.write(struct.pack(\">l\", pinmax))\n    fp.write(struct.pack(\"4s\", b\"\"))  # dummy\n    fp.write(struct.pack(\"79s\", img_name))  # truncates to 79 chars\n    fp.write(struct.pack(\"s\", b\"\"))  # force null byte after img_name\n    fp.write(struct.pack(\">l\", colormap))\n    fp.write(struct.pack(\"404s\", b\"\"))  # dummy\n\n    rawmode = \"L\"\n    if bpc == 2:\n        rawmode = \"L;16B\"\n\n    for channel in im.split():\n        fp.write(channel.tobytes(\"raw\", rawmode, 0, orientation))\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\nclass SGI16Decoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        assert self.im is not None\n\n        rawmode, stride, orientation = self.args\n        pagesize = self.state.xsize * self.state.ysize\n        zsize = len(self.mode)\n        self.fd.seek(512)\n\n        for band in range(zsize):\n            channel = Image.new(\"L\", (self.state.xsize, self.state.ysize))\n            channel.frombytes(\n                self.fd.read(2 * pagesize), \"raw\", \"L;16B\", stride, orientation\n            )\n            self.im.putband(channel.im, band)\n\n        return -1, 0\n\n\n#\n# registry\n\n\nImage.register_decoder(\"SGI16\", SGI16Decoder)\nImage.register_open(SgiImageFile.format, SgiImageFile, _accept)\nImage.register_save(SgiImageFile.format, _save)\nImage.register_mime(SgiImageFile.format, \"image/sgi\")\n\nImage.register_extensions(SgiImageFile.format, [\".bw\", \".rgb\", \".rgba\", \".sgi\"])\n\n# End of file\n", "src/PIL/TarIO.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# read files from within a tar file\n#\n# History:\n# 95-06-18 fl   Created\n# 96-05-28 fl   Open files in binary mode\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1995-96.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\n\nfrom . import ContainerIO\n\n\nclass TarIO(ContainerIO.ContainerIO[bytes]):\n    \"\"\"A file object that provides read access to a given member of a TAR file.\"\"\"\n\n    def __init__(self, tarfile: str, file: str) -> None:\n        \"\"\"\n        Create file object.\n\n        :param tarfile: Name of TAR file.\n        :param file: Name of member file.\n        \"\"\"\n        self.fh = open(tarfile, \"rb\")\n\n        while True:\n            s = self.fh.read(512)\n            if len(s) != 512:\n                msg = \"unexpected end of tar file\"\n                raise OSError(msg)\n\n            name = s[:100].decode(\"utf-8\")\n            i = name.find(\"\\0\")\n            if i == 0:\n                msg = \"cannot find subfile\"\n                raise OSError(msg)\n            if i > 0:\n                name = name[:i]\n\n            size = int(s[124:135], 8)\n\n            if file == name:\n                break\n\n            self.fh.seek((size + 511) & (~511), io.SEEK_CUR)\n\n        # Open region\n        super().__init__(self.fh, self.fh.tell(), size)\n\n    # Context manager support\n    def __enter__(self) -> TarIO:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def close(self) -> None:\n        self.fh.close()\n", "src/PIL/FitsImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# FITS file handling\n#\n# Copyright (c) 1998-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport gzip\nimport math\n\nfrom . import Image, ImageFile\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:6] == b\"SIMPLE\"\n\n\nclass FitsImageFile(ImageFile.ImageFile):\n    format = \"FITS\"\n    format_description = \"FITS\"\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        headers: dict[bytes, bytes] = {}\n        header_in_progress = False\n        decoder_name = \"\"\n        while True:\n            header = self.fp.read(80)\n            if not header:\n                msg = \"Truncated FITS file\"\n                raise OSError(msg)\n            keyword = header[:8].strip()\n            if keyword in (b\"SIMPLE\", b\"XTENSION\"):\n                header_in_progress = True\n            elif headers and not header_in_progress:\n                # This is now a data unit\n                break\n            elif keyword == b\"END\":\n                # Seek to the end of the header unit\n                self.fp.seek(math.ceil(self.fp.tell() / 2880) * 2880)\n                if not decoder_name:\n                    decoder_name, offset, args = self._parse_headers(headers)\n\n                header_in_progress = False\n                continue\n\n            if decoder_name:\n                # Keep going to read past the headers\n                continue\n\n            value = header[8:].split(b\"/\")[0].strip()\n            if value.startswith(b\"=\"):\n                value = value[1:].strip()\n            if not headers and (not _accept(keyword) or value != b\"T\"):\n                msg = \"Not a FITS file\"\n                raise SyntaxError(msg)\n            headers[keyword] = value\n\n        if not decoder_name:\n            msg = \"No image data\"\n            raise ValueError(msg)\n\n        offset += self.fp.tell() - 80\n        self.tile = [(decoder_name, (0, 0) + self.size, offset, args)]\n\n    def _get_size(\n        self, headers: dict[bytes, bytes], prefix: bytes\n    ) -> tuple[int, int] | None:\n        naxis = int(headers[prefix + b\"NAXIS\"])\n        if naxis == 0:\n            return None\n\n        if naxis == 1:\n            return 1, int(headers[prefix + b\"NAXIS1\"])\n        else:\n            return int(headers[prefix + b\"NAXIS1\"]), int(headers[prefix + b\"NAXIS2\"])\n\n    def _parse_headers(\n        self, headers: dict[bytes, bytes]\n    ) -> tuple[str, int, tuple[str | int, ...]]:\n        prefix = b\"\"\n        decoder_name = \"raw\"\n        offset = 0\n        if (\n            headers.get(b\"XTENSION\") == b\"'BINTABLE'\"\n            and headers.get(b\"ZIMAGE\") == b\"T\"\n            and headers[b\"ZCMPTYPE\"] == b\"'GZIP_1  '\"\n        ):\n            no_prefix_size = self._get_size(headers, prefix) or (0, 0)\n            number_of_bits = int(headers[b\"BITPIX\"])\n            offset = no_prefix_size[0] * no_prefix_size[1] * (number_of_bits // 8)\n\n            prefix = b\"Z\"\n            decoder_name = \"fits_gzip\"\n\n        size = self._get_size(headers, prefix)\n        if not size:\n            return \"\", 0, ()\n\n        self._size = size\n\n        number_of_bits = int(headers[prefix + b\"BITPIX\"])\n        if number_of_bits == 8:\n            self._mode = \"L\"\n        elif number_of_bits == 16:\n            self._mode = \"I;16\"\n        elif number_of_bits == 32:\n            self._mode = \"I\"\n        elif number_of_bits in (-32, -64):\n            self._mode = \"F\"\n\n        args: tuple[str | int, ...]\n        if decoder_name == \"raw\":\n            args = (self.mode, 0, -1)\n        else:\n            args = (number_of_bits,)\n        return decoder_name, offset, args\n\n\nclass FitsGzipDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        value = gzip.decompress(self.fd.read())\n\n        rows = []\n        offset = 0\n        number_of_bits = min(self.args[0] // 8, 4)\n        for y in range(self.state.ysize):\n            row = bytearray()\n            for x in range(self.state.xsize):\n                row += value[offset + (4 - number_of_bits) : offset + 4]\n                offset += 4\n            rows.append(row)\n        self.set_as_raw(bytes([pixel for row in rows[::-1] for pixel in row]))\n        return -1, 0\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(FitsImageFile.format, FitsImageFile, _accept)\nImage.register_decoder(\"fits_gzip\", FitsGzipDecoder)\n\nImage.register_extensions(FitsImageFile.format, [\".fit\", \".fits\"])\n", "src/PIL/JpegImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# JPEG (JFIF) file handling\n#\n# See \"Digital Compression and Coding of Continuous-Tone Still Images,\n# Part 1, Requirements and Guidelines\" (CCITT T.81 / ISO 10918-1)\n#\n# History:\n# 1995-09-09 fl   Created\n# 1995-09-13 fl   Added full parser\n# 1996-03-25 fl   Added hack to use the IJG command line utilities\n# 1996-05-05 fl   Workaround Photoshop 2.5 CMYK polarity bug\n# 1996-05-28 fl   Added draft support, JFIF version (0.1)\n# 1996-12-30 fl   Added encoder options, added progression property (0.2)\n# 1997-08-27 fl   Save mode 1 images as BW (0.3)\n# 1998-07-12 fl   Added YCbCr to draft and save methods (0.4)\n# 1998-10-19 fl   Don't hang on files using 16-bit DQT's (0.4.1)\n# 2001-04-16 fl   Extract DPI settings from JFIF files (0.4.2)\n# 2002-07-01 fl   Skip pad bytes before markers; identify Exif files (0.4.3)\n# 2003-04-25 fl   Added experimental EXIF decoder (0.5)\n# 2003-06-06 fl   Added experimental EXIF GPSinfo decoder\n# 2003-09-13 fl   Extract COM markers\n# 2009-09-06 fl   Added icc_profile support (from Florian Hoech)\n# 2009-03-06 fl   Changed CMYK handling; always use Adobe polarity (0.6)\n# 2009-03-08 fl   Added subsampling support (from Justin Huff).\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport array\nimport io\nimport math\nimport os\nimport struct\nimport subprocess\nimport sys\nimport tempfile\nimport warnings\nfrom typing import IO, Any\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import o8\nfrom ._binary import o16be as o16\nfrom .JpegPresets import presets\n\n#\n# Parser\n\n\ndef Skip(self: JpegImageFile, marker: int) -> None:\n    n = i16(self.fp.read(2)) - 2\n    ImageFile._safe_read(self.fp, n)\n\n\ndef APP(self, marker):\n    #\n    # Application marker.  Store these in the APP dictionary.\n    # Also look for well-known application markers.\n\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n\n    app = \"APP%d\" % (marker & 15)\n\n    self.app[app] = s  # compatibility\n    self.applist.append((app, s))\n\n    if marker == 0xFFE0 and s[:4] == b\"JFIF\":\n        # extract JFIF information\n        self.info[\"jfif\"] = version = i16(s, 5)  # version\n        self.info[\"jfif_version\"] = divmod(version, 256)\n        # extract JFIF properties\n        try:\n            jfif_unit = s[7]\n            jfif_density = i16(s, 8), i16(s, 10)\n        except Exception:\n            pass\n        else:\n            if jfif_unit == 1:\n                self.info[\"dpi\"] = jfif_density\n            self.info[\"jfif_unit\"] = jfif_unit\n            self.info[\"jfif_density\"] = jfif_density\n    elif marker == 0xFFE1 and s[:6] == b\"Exif\\0\\0\":\n        # extract EXIF information\n        if \"exif\" in self.info:\n            self.info[\"exif\"] += s[6:]\n        else:\n            self.info[\"exif\"] = s\n            self._exif_offset = self.fp.tell() - n + 6\n    elif marker == 0xFFE1 and s[:29] == b\"http://ns.adobe.com/xap/1.0/\\x00\":\n        self.info[\"xmp\"] = s.split(b\"\\x00\")[1]\n    elif marker == 0xFFE2 and s[:5] == b\"FPXR\\0\":\n        # extract FlashPix information (incomplete)\n        self.info[\"flashpix\"] = s  # FIXME: value will change\n    elif marker == 0xFFE2 and s[:12] == b\"ICC_PROFILE\\0\":\n        # Since an ICC profile can be larger than the maximum size of\n        # a JPEG marker (64K), we need provisions to split it into\n        # multiple markers. The format defined by the ICC specifies\n        # one or more APP2 markers containing the following data:\n        #   Identifying string      ASCII \"ICC_PROFILE\\0\"  (12 bytes)\n        #   Marker sequence number  1, 2, etc (1 byte)\n        #   Number of markers       Total of APP2's used (1 byte)\n        #   Profile data            (remainder of APP2 data)\n        # Decoders should use the marker sequence numbers to\n        # reassemble the profile, rather than assuming that the APP2\n        # markers appear in the correct sequence.\n        self.icclist.append(s)\n    elif marker == 0xFFED and s[:14] == b\"Photoshop 3.0\\x00\":\n        # parse the image resource block\n        offset = 14\n        photoshop = self.info.setdefault(\"photoshop\", {})\n        while s[offset : offset + 4] == b\"8BIM\":\n            try:\n                offset += 4\n                # resource code\n                code = i16(s, offset)\n                offset += 2\n                # resource name (usually empty)\n                name_len = s[offset]\n                # name = s[offset+1:offset+1+name_len]\n                offset += 1 + name_len\n                offset += offset & 1  # align\n                # resource data block\n                size = i32(s, offset)\n                offset += 4\n                data = s[offset : offset + size]\n                if code == 0x03ED:  # ResolutionInfo\n                    data = {\n                        \"XResolution\": i32(data, 0) / 65536,\n                        \"DisplayedUnitsX\": i16(data, 4),\n                        \"YResolution\": i32(data, 8) / 65536,\n                        \"DisplayedUnitsY\": i16(data, 12),\n                    }\n                photoshop[code] = data\n                offset += size\n                offset += offset & 1  # align\n            except struct.error:\n                break  # insufficient data\n\n    elif marker == 0xFFEE and s[:5] == b\"Adobe\":\n        self.info[\"adobe\"] = i16(s, 5)\n        # extract Adobe custom properties\n        try:\n            adobe_transform = s[11]\n        except IndexError:\n            pass\n        else:\n            self.info[\"adobe_transform\"] = adobe_transform\n    elif marker == 0xFFE2 and s[:4] == b\"MPF\\0\":\n        # extract MPO information\n        self.info[\"mp\"] = s[4:]\n        # offset is current location minus buffer size\n        # plus constant header size\n        self.info[\"mpoffset\"] = self.fp.tell() - n + 4\n\n    # If DPI isn't in JPEG header, fetch from EXIF\n    if \"dpi\" not in self.info and \"exif\" in self.info:\n        try:\n            exif = self.getexif()\n            resolution_unit = exif[0x0128]\n            x_resolution = exif[0x011A]\n            try:\n                dpi = float(x_resolution[0]) / x_resolution[1]\n            except TypeError:\n                dpi = x_resolution\n            if math.isnan(dpi):\n                msg = \"DPI is not a number\"\n                raise ValueError(msg)\n            if resolution_unit == 3:  # cm\n                # 1 dpcm = 2.54 dpi\n                dpi *= 2.54\n            self.info[\"dpi\"] = dpi, dpi\n        except (\n            struct.error,\n            KeyError,\n            SyntaxError,\n            TypeError,\n            ValueError,\n            ZeroDivisionError,\n        ):\n            # struct.error for truncated EXIF\n            # KeyError for dpi not included\n            # SyntaxError for invalid/unreadable EXIF\n            # ValueError or TypeError for dpi being an invalid float\n            # ZeroDivisionError for invalid dpi rational value\n            self.info[\"dpi\"] = 72, 72\n\n\ndef COM(self: JpegImageFile, marker: int) -> None:\n    #\n    # Comment marker.  Store these in the APP dictionary.\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n\n    self.info[\"comment\"] = s\n    self.app[\"COM\"] = s  # compatibility\n    self.applist.append((\"COM\", s))\n\n\ndef SOF(self: JpegImageFile, marker: int) -> None:\n    #\n    # Start of frame marker.  Defines the size and mode of the\n    # image.  JPEG is colour blind, so we use some simple\n    # heuristics to map the number of layers to an appropriate\n    # mode.  Note that this could be made a bit brighter, by\n    # looking for JFIF and Adobe APP markers.\n\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    self._size = i16(s, 3), i16(s, 1)\n\n    self.bits = s[0]\n    if self.bits != 8:\n        msg = f\"cannot handle {self.bits}-bit layers\"\n        raise SyntaxError(msg)\n\n    self.layers = s[5]\n    if self.layers == 1:\n        self._mode = \"L\"\n    elif self.layers == 3:\n        self._mode = \"RGB\"\n    elif self.layers == 4:\n        self._mode = \"CMYK\"\n    else:\n        msg = f\"cannot handle {self.layers}-layer images\"\n        raise SyntaxError(msg)\n\n    if marker in [0xFFC2, 0xFFC6, 0xFFCA, 0xFFCE]:\n        self.info[\"progressive\"] = self.info[\"progression\"] = 1\n\n    if self.icclist:\n        # fixup icc profile\n        self.icclist.sort()  # sort by sequence number\n        if self.icclist[0][13] == len(self.icclist):\n            profile = [p[14:] for p in self.icclist]\n            icc_profile = b\"\".join(profile)\n        else:\n            icc_profile = None  # wrong number of fragments\n        self.info[\"icc_profile\"] = icc_profile\n        self.icclist = []\n\n    for i in range(6, len(s), 3):\n        t = s[i : i + 3]\n        # 4-tuples: id, vsamp, hsamp, qtable\n        self.layer.append((t[0], t[1] // 16, t[1] & 15, t[2]))\n\n\ndef DQT(self: JpegImageFile, marker: int) -> None:\n    #\n    # Define quantization table.  Note that there might be more\n    # than one table in each marker.\n\n    # FIXME: The quantization tables can be used to estimate the\n    # compression quality.\n\n    n = i16(self.fp.read(2)) - 2\n    s = ImageFile._safe_read(self.fp, n)\n    while len(s):\n        v = s[0]\n        precision = 1 if (v // 16 == 0) else 2  # in bytes\n        qt_length = 1 + precision * 64\n        if len(s) < qt_length:\n            msg = \"bad quantization table marker\"\n            raise SyntaxError(msg)\n        data = array.array(\"B\" if precision == 1 else \"H\", s[1:qt_length])\n        if sys.byteorder == \"little\" and precision > 1:\n            data.byteswap()  # the values are always big-endian\n        self.quantization[v & 15] = [data[i] for i in zigzag_index]\n        s = s[qt_length:]\n\n\n#\n# JPEG marker table\n\nMARKER = {\n    0xFFC0: (\"SOF0\", \"Baseline DCT\", SOF),\n    0xFFC1: (\"SOF1\", \"Extended Sequential DCT\", SOF),\n    0xFFC2: (\"SOF2\", \"Progressive DCT\", SOF),\n    0xFFC3: (\"SOF3\", \"Spatial lossless\", SOF),\n    0xFFC4: (\"DHT\", \"Define Huffman table\", Skip),\n    0xFFC5: (\"SOF5\", \"Differential sequential DCT\", SOF),\n    0xFFC6: (\"SOF6\", \"Differential progressive DCT\", SOF),\n    0xFFC7: (\"SOF7\", \"Differential spatial\", SOF),\n    0xFFC8: (\"JPG\", \"Extension\", None),\n    0xFFC9: (\"SOF9\", \"Extended sequential DCT (AC)\", SOF),\n    0xFFCA: (\"SOF10\", \"Progressive DCT (AC)\", SOF),\n    0xFFCB: (\"SOF11\", \"Spatial lossless DCT (AC)\", SOF),\n    0xFFCC: (\"DAC\", \"Define arithmetic coding conditioning\", Skip),\n    0xFFCD: (\"SOF13\", \"Differential sequential DCT (AC)\", SOF),\n    0xFFCE: (\"SOF14\", \"Differential progressive DCT (AC)\", SOF),\n    0xFFCF: (\"SOF15\", \"Differential spatial (AC)\", SOF),\n    0xFFD0: (\"RST0\", \"Restart 0\", None),\n    0xFFD1: (\"RST1\", \"Restart 1\", None),\n    0xFFD2: (\"RST2\", \"Restart 2\", None),\n    0xFFD3: (\"RST3\", \"Restart 3\", None),\n    0xFFD4: (\"RST4\", \"Restart 4\", None),\n    0xFFD5: (\"RST5\", \"Restart 5\", None),\n    0xFFD6: (\"RST6\", \"Restart 6\", None),\n    0xFFD7: (\"RST7\", \"Restart 7\", None),\n    0xFFD8: (\"SOI\", \"Start of image\", None),\n    0xFFD9: (\"EOI\", \"End of image\", None),\n    0xFFDA: (\"SOS\", \"Start of scan\", Skip),\n    0xFFDB: (\"DQT\", \"Define quantization table\", DQT),\n    0xFFDC: (\"DNL\", \"Define number of lines\", Skip),\n    0xFFDD: (\"DRI\", \"Define restart interval\", Skip),\n    0xFFDE: (\"DHP\", \"Define hierarchical progression\", SOF),\n    0xFFDF: (\"EXP\", \"Expand reference component\", Skip),\n    0xFFE0: (\"APP0\", \"Application segment 0\", APP),\n    0xFFE1: (\"APP1\", \"Application segment 1\", APP),\n    0xFFE2: (\"APP2\", \"Application segment 2\", APP),\n    0xFFE3: (\"APP3\", \"Application segment 3\", APP),\n    0xFFE4: (\"APP4\", \"Application segment 4\", APP),\n    0xFFE5: (\"APP5\", \"Application segment 5\", APP),\n    0xFFE6: (\"APP6\", \"Application segment 6\", APP),\n    0xFFE7: (\"APP7\", \"Application segment 7\", APP),\n    0xFFE8: (\"APP8\", \"Application segment 8\", APP),\n    0xFFE9: (\"APP9\", \"Application segment 9\", APP),\n    0xFFEA: (\"APP10\", \"Application segment 10\", APP),\n    0xFFEB: (\"APP11\", \"Application segment 11\", APP),\n    0xFFEC: (\"APP12\", \"Application segment 12\", APP),\n    0xFFED: (\"APP13\", \"Application segment 13\", APP),\n    0xFFEE: (\"APP14\", \"Application segment 14\", APP),\n    0xFFEF: (\"APP15\", \"Application segment 15\", APP),\n    0xFFF0: (\"JPG0\", \"Extension 0\", None),\n    0xFFF1: (\"JPG1\", \"Extension 1\", None),\n    0xFFF2: (\"JPG2\", \"Extension 2\", None),\n    0xFFF3: (\"JPG3\", \"Extension 3\", None),\n    0xFFF4: (\"JPG4\", \"Extension 4\", None),\n    0xFFF5: (\"JPG5\", \"Extension 5\", None),\n    0xFFF6: (\"JPG6\", \"Extension 6\", None),\n    0xFFF7: (\"JPG7\", \"Extension 7\", None),\n    0xFFF8: (\"JPG8\", \"Extension 8\", None),\n    0xFFF9: (\"JPG9\", \"Extension 9\", None),\n    0xFFFA: (\"JPG10\", \"Extension 10\", None),\n    0xFFFB: (\"JPG11\", \"Extension 11\", None),\n    0xFFFC: (\"JPG12\", \"Extension 12\", None),\n    0xFFFD: (\"JPG13\", \"Extension 13\", None),\n    0xFFFE: (\"COM\", \"Comment\", COM),\n}\n\n\ndef _accept(prefix: bytes) -> bool:\n    # Magic number was taken from https://en.wikipedia.org/wiki/JPEG\n    return prefix[:3] == b\"\\xFF\\xD8\\xFF\"\n\n\n##\n# Image plugin for JPEG and JFIF images.\n\n\nclass JpegImageFile(ImageFile.ImageFile):\n    format = \"JPEG\"\n    format_description = \"JPEG (ISO 10918)\"\n\n    def _open(self):\n        s = self.fp.read(3)\n\n        if not _accept(s):\n            msg = \"not a JPEG file\"\n            raise SyntaxError(msg)\n        s = b\"\\xFF\"\n\n        # Create attributes\n        self.bits = self.layers = 0\n\n        # JPEG specifics (internal)\n        self.layer = []\n        self.huffman_dc = {}\n        self.huffman_ac = {}\n        self.quantization = {}\n        self.app = {}  # compatibility\n        self.applist = []\n        self.icclist = []\n\n        while True:\n            i = s[0]\n            if i == 0xFF:\n                s = s + self.fp.read(1)\n                i = i16(s)\n            else:\n                # Skip non-0xFF junk\n                s = self.fp.read(1)\n                continue\n\n            if i in MARKER:\n                name, description, handler = MARKER[i]\n                if handler is not None:\n                    handler(self, i)\n                if i == 0xFFDA:  # start of scan\n                    rawmode = self.mode\n                    if self.mode == \"CMYK\":\n                        rawmode = \"CMYK;I\"  # assume adobe conventions\n                    self.tile = [(\"jpeg\", (0, 0) + self.size, 0, (rawmode, \"\"))]\n                    # self.__offset = self.fp.tell()\n                    break\n                s = self.fp.read(1)\n            elif i in {0, 0xFFFF}:\n                # padded marker or junk; move on\n                s = b\"\\xff\"\n            elif i == 0xFF00:  # Skip extraneous data (escaped 0xFF)\n                s = self.fp.read(1)\n            else:\n                msg = \"no marker found\"\n                raise SyntaxError(msg)\n\n    def load_read(self, read_bytes: int) -> bytes:\n        \"\"\"\n        internal: read more image data\n        For premature EOF and LOAD_TRUNCATED_IMAGES adds EOI marker\n        so libjpeg can finish decoding\n        \"\"\"\n        s = self.fp.read(read_bytes)\n\n        if not s and ImageFile.LOAD_TRUNCATED_IMAGES and not hasattr(self, \"_ended\"):\n            # Premature EOF.\n            # Pretend file is finished adding EOI marker\n            self._ended = True\n            return b\"\\xFF\\xD9\"\n\n        return s\n\n    def draft(\n        self, mode: str | None, size: tuple[int, int] | None\n    ) -> tuple[str, tuple[int, int, float, float]] | None:\n        if len(self.tile) != 1:\n            return None\n\n        # Protect from second call\n        if self.decoderconfig:\n            return None\n\n        d, e, o, a = self.tile[0]\n        scale = 1\n        original_size = self.size\n\n        if a[0] == \"RGB\" and mode in [\"L\", \"YCbCr\"]:\n            self._mode = mode\n            a = mode, \"\"\n\n        if size:\n            scale = min(self.size[0] // size[0], self.size[1] // size[1])\n            for s in [8, 4, 2, 1]:\n                if scale >= s:\n                    break\n            e = (\n                e[0],\n                e[1],\n                (e[2] - e[0] + s - 1) // s + e[0],\n                (e[3] - e[1] + s - 1) // s + e[1],\n            )\n            self._size = ((self.size[0] + s - 1) // s, (self.size[1] + s - 1) // s)\n            scale = s\n\n        self.tile = [(d, e, o, a)]\n        self.decoderconfig = (scale, 0)\n\n        box = (0, 0, original_size[0] / scale, original_size[1] / scale)\n        return self.mode, box\n\n    def load_djpeg(self) -> None:\n        # ALTERNATIVE: handle JPEGs via the IJG command line utilities\n\n        f, path = tempfile.mkstemp()\n        os.close(f)\n        if os.path.exists(self.filename):\n            subprocess.check_call([\"djpeg\", \"-outfile\", path, self.filename])\n        else:\n            try:\n                os.unlink(path)\n            except OSError:\n                pass\n\n            msg = \"Invalid Filename\"\n            raise ValueError(msg)\n\n        try:\n            with Image.open(path) as _im:\n                _im.load()\n                self.im = _im.im\n        finally:\n            try:\n                os.unlink(path)\n            except OSError:\n                pass\n\n        self._mode = self.im.mode\n        self._size = self.im.size\n\n        self.tile = []\n\n    def _getexif(self) -> dict[str, Any] | None:\n        return _getexif(self)\n\n    def _getmp(self):\n        return _getmp(self)\n\n\ndef _getexif(self) -> dict[str, Any] | None:\n    if \"exif\" not in self.info:\n        return None\n    return self.getexif()._get_merged_dict()\n\n\ndef _getmp(self):\n    # Extract MP information.  This method was inspired by the \"highly\n    # experimental\" _getexif version that's been in use for years now,\n    # itself based on the ImageFileDirectory class in the TIFF plugin.\n\n    # The MP record essentially consists of a TIFF file embedded in a JPEG\n    # application marker.\n    try:\n        data = self.info[\"mp\"]\n    except KeyError:\n        return None\n    file_contents = io.BytesIO(data)\n    head = file_contents.read(8)\n    endianness = \">\" if head[:4] == b\"\\x4d\\x4d\\x00\\x2a\" else \"<\"\n    # process dictionary\n    from . import TiffImagePlugin\n\n    try:\n        info = TiffImagePlugin.ImageFileDirectory_v2(head)\n        file_contents.seek(info.next)\n        info.load(file_contents)\n        mp = dict(info)\n    except Exception as e:\n        msg = \"malformed MP Index (unreadable directory)\"\n        raise SyntaxError(msg) from e\n    # it's an error not to have a number of images\n    try:\n        quant = mp[0xB001]\n    except KeyError as e:\n        msg = \"malformed MP Index (no number of images)\"\n        raise SyntaxError(msg) from e\n    # get MP entries\n    mpentries = []\n    try:\n        rawmpentries = mp[0xB002]\n        for entrynum in range(0, quant):\n            unpackedentry = struct.unpack_from(\n                f\"{endianness}LLLHH\", rawmpentries, entrynum * 16\n            )\n            labels = (\"Attribute\", \"Size\", \"DataOffset\", \"EntryNo1\", \"EntryNo2\")\n            mpentry = dict(zip(labels, unpackedentry))\n            mpentryattr = {\n                \"DependentParentImageFlag\": bool(mpentry[\"Attribute\"] & (1 << 31)),\n                \"DependentChildImageFlag\": bool(mpentry[\"Attribute\"] & (1 << 30)),\n                \"RepresentativeImageFlag\": bool(mpentry[\"Attribute\"] & (1 << 29)),\n                \"Reserved\": (mpentry[\"Attribute\"] & (3 << 27)) >> 27,\n                \"ImageDataFormat\": (mpentry[\"Attribute\"] & (7 << 24)) >> 24,\n                \"MPType\": mpentry[\"Attribute\"] & 0x00FFFFFF,\n            }\n            if mpentryattr[\"ImageDataFormat\"] == 0:\n                mpentryattr[\"ImageDataFormat\"] = \"JPEG\"\n            else:\n                msg = \"unsupported picture format in MPO\"\n                raise SyntaxError(msg)\n            mptypemap = {\n                0x000000: \"Undefined\",\n                0x010001: \"Large Thumbnail (VGA Equivalent)\",\n                0x010002: \"Large Thumbnail (Full HD Equivalent)\",\n                0x020001: \"Multi-Frame Image (Panorama)\",\n                0x020002: \"Multi-Frame Image: (Disparity)\",\n                0x020003: \"Multi-Frame Image: (Multi-Angle)\",\n                0x030000: \"Baseline MP Primary Image\",\n            }\n            mpentryattr[\"MPType\"] = mptypemap.get(mpentryattr[\"MPType\"], \"Unknown\")\n            mpentry[\"Attribute\"] = mpentryattr\n            mpentries.append(mpentry)\n        mp[0xB002] = mpentries\n    except KeyError as e:\n        msg = \"malformed MP Index (bad MP Entry)\"\n        raise SyntaxError(msg) from e\n    # Next we should try and parse the individual image unique ID list;\n    # we don't because I've never seen this actually used in a real MPO\n    # file and so can't test it.\n    return mp\n\n\n# --------------------------------------------------------------------\n# stuff to save JPEG files\n\nRAWMODE = {\n    \"1\": \"L\",\n    \"L\": \"L\",\n    \"RGB\": \"RGB\",\n    \"RGBX\": \"RGB\",\n    \"CMYK\": \"CMYK;I\",  # assume adobe conventions\n    \"YCbCr\": \"YCbCr\",\n}\n\n# fmt: off\nzigzag_index = (\n    0,  1,  5,  6, 14, 15, 27, 28,\n    2,  4,  7, 13, 16, 26, 29, 42,\n    3,  8, 12, 17, 25, 30, 41, 43,\n    9, 11, 18, 24, 31, 40, 44, 53,\n    10, 19, 23, 32, 39, 45, 52, 54,\n    20, 22, 33, 38, 46, 51, 55, 60,\n    21, 34, 37, 47, 50, 56, 59, 61,\n    35, 36, 48, 49, 57, 58, 62, 63,\n)\n\nsamplings = {\n    (1, 1, 1, 1, 1, 1): 0,\n    (2, 1, 1, 1, 1, 1): 1,\n    (2, 2, 1, 1, 1, 1): 2,\n}\n# fmt: on\n\n\ndef get_sampling(im):\n    # There's no subsampling when images have only 1 layer\n    # (grayscale images) or when they are CMYK (4 layers),\n    # so set subsampling to the default value.\n    #\n    # NOTE: currently Pillow can't encode JPEG to YCCK format.\n    # If YCCK support is added in the future, subsampling code will have\n    # to be updated (here and in JpegEncode.c) to deal with 4 layers.\n    if not hasattr(im, \"layers\") or im.layers in (1, 4):\n        return -1\n    sampling = im.layer[0][1:3] + im.layer[1][1:3] + im.layer[2][1:3]\n    return samplings.get(sampling, -1)\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.width == 0 or im.height == 0:\n        msg = \"cannot write empty image as JPEG\"\n        raise ValueError(msg)\n\n    try:\n        rawmode = RAWMODE[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as JPEG\"\n        raise OSError(msg) from e\n\n    info = im.encoderinfo\n\n    dpi = [round(x) for x in info.get(\"dpi\", (0, 0))]\n\n    quality = info.get(\"quality\", -1)\n    subsampling = info.get(\"subsampling\", -1)\n    qtables = info.get(\"qtables\")\n\n    if quality == \"keep\":\n        quality = -1\n        subsampling = \"keep\"\n        qtables = \"keep\"\n    elif quality in presets:\n        preset = presets[quality]\n        quality = -1\n        subsampling = preset.get(\"subsampling\", -1)\n        qtables = preset.get(\"quantization\")\n    elif not isinstance(quality, int):\n        msg = \"Invalid quality setting\"\n        raise ValueError(msg)\n    else:\n        if subsampling in presets:\n            subsampling = presets[subsampling].get(\"subsampling\", -1)\n        if isinstance(qtables, str) and qtables in presets:\n            qtables = presets[qtables].get(\"quantization\")\n\n    if subsampling == \"4:4:4\":\n        subsampling = 0\n    elif subsampling == \"4:2:2\":\n        subsampling = 1\n    elif subsampling == \"4:2:0\":\n        subsampling = 2\n    elif subsampling == \"4:1:1\":\n        # For compatibility. Before Pillow 4.3, 4:1:1 actually meant 4:2:0.\n        # Set 4:2:0 if someone is still using that value.\n        subsampling = 2\n    elif subsampling == \"keep\":\n        if im.format != \"JPEG\":\n            msg = \"Cannot use 'keep' when original image is not a JPEG\"\n            raise ValueError(msg)\n        subsampling = get_sampling(im)\n\n    def validate_qtables(qtables):\n        if qtables is None:\n            return qtables\n        if isinstance(qtables, str):\n            try:\n                lines = [\n                    int(num)\n                    for line in qtables.splitlines()\n                    for num in line.split(\"#\", 1)[0].split()\n                ]\n            except ValueError as e:\n                msg = \"Invalid quantization table\"\n                raise ValueError(msg) from e\n            else:\n                qtables = [lines[s : s + 64] for s in range(0, len(lines), 64)]\n        if isinstance(qtables, (tuple, list, dict)):\n            if isinstance(qtables, dict):\n                qtables = [\n                    qtables[key] for key in range(len(qtables)) if key in qtables\n                ]\n            elif isinstance(qtables, tuple):\n                qtables = list(qtables)\n            if not (0 < len(qtables) < 5):\n                msg = \"None or too many quantization tables\"\n                raise ValueError(msg)\n            for idx, table in enumerate(qtables):\n                try:\n                    if len(table) != 64:\n                        msg = \"Invalid quantization table\"\n                        raise TypeError(msg)\n                    table = array.array(\"H\", table)\n                except TypeError as e:\n                    msg = \"Invalid quantization table\"\n                    raise ValueError(msg) from e\n                else:\n                    qtables[idx] = list(table)\n            return qtables\n\n    if qtables == \"keep\":\n        if im.format != \"JPEG\":\n            msg = \"Cannot use 'keep' when original image is not a JPEG\"\n            raise ValueError(msg)\n        qtables = getattr(im, \"quantization\", None)\n    qtables = validate_qtables(qtables)\n\n    extra = info.get(\"extra\", b\"\")\n\n    MAX_BYTES_IN_MARKER = 65533\n    icc_profile = info.get(\"icc_profile\")\n    if icc_profile:\n        ICC_OVERHEAD_LEN = 14\n        MAX_DATA_BYTES_IN_MARKER = MAX_BYTES_IN_MARKER - ICC_OVERHEAD_LEN\n        markers = []\n        while icc_profile:\n            markers.append(icc_profile[:MAX_DATA_BYTES_IN_MARKER])\n            icc_profile = icc_profile[MAX_DATA_BYTES_IN_MARKER:]\n        i = 1\n        for marker in markers:\n            size = o16(2 + ICC_OVERHEAD_LEN + len(marker))\n            extra += (\n                b\"\\xFF\\xE2\"\n                + size\n                + b\"ICC_PROFILE\\0\"\n                + o8(i)\n                + o8(len(markers))\n                + marker\n            )\n            i += 1\n\n    comment = info.get(\"comment\", im.info.get(\"comment\"))\n\n    # \"progressive\" is the official name, but older documentation\n    # says \"progression\"\n    # FIXME: issue a warning if the wrong form is used (post-1.1.7)\n    progressive = info.get(\"progressive\", False) or info.get(\"progression\", False)\n\n    optimize = info.get(\"optimize\", False)\n\n    exif = info.get(\"exif\", b\"\")\n    if isinstance(exif, Image.Exif):\n        exif = exif.tobytes()\n    if len(exif) > MAX_BYTES_IN_MARKER:\n        msg = \"EXIF data is too long\"\n        raise ValueError(msg)\n\n    # get keyword arguments\n    im.encoderconfig = (\n        quality,\n        progressive,\n        info.get(\"smooth\", 0),\n        optimize,\n        info.get(\"keep_rgb\", False),\n        info.get(\"streamtype\", 0),\n        dpi[0],\n        dpi[1],\n        subsampling,\n        info.get(\"restart_marker_blocks\", 0),\n        info.get(\"restart_marker_rows\", 0),\n        qtables,\n        comment,\n        extra,\n        exif,\n    )\n\n    # if we optimize, libjpeg needs a buffer big enough to hold the whole image\n    # in a shot. Guessing on the size, at im.size bytes. (raw pixel size is\n    # channels*size, this is a value that's been used in a django patch.\n    # https://github.com/matthewwithanm/django-imagekit/issues/50\n    bufsize = 0\n    if optimize or progressive:\n        # CMYK can be bigger\n        if im.mode == \"CMYK\":\n            bufsize = 4 * im.size[0] * im.size[1]\n        # keep sets quality to -1, but the actual value may be high.\n        elif quality >= 95 or quality == -1:\n            bufsize = 2 * im.size[0] * im.size[1]\n        else:\n            bufsize = im.size[0] * im.size[1]\n        if exif:\n            bufsize += len(exif) + 5\n        if extra:\n            bufsize += len(extra) + 1\n    else:\n        # The EXIF info needs to be written as one block, + APP1, + one spare byte.\n        # Ensure that our buffer is big enough. Same with the icc_profile block.\n        bufsize = max(bufsize, len(exif) + 5, len(extra) + 1)\n\n    ImageFile._save(im, fp, [(\"jpeg\", (0, 0) + im.size, 0, rawmode)], bufsize)\n\n\ndef _save_cjpeg(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # ALTERNATIVE: handle JPEGs via the IJG command line utilities.\n    tempfile = im._dump()\n    subprocess.check_call([\"cjpeg\", \"-outfile\", filename, tempfile])\n    try:\n        os.unlink(tempfile)\n    except OSError:\n        pass\n\n\n##\n# Factory for making JPEG and MPO instances\ndef jpeg_factory(fp=None, filename=None):\n    im = JpegImageFile(fp, filename)\n    try:\n        mpheader = im._getmp()\n        if mpheader[45057] > 1:\n            # It's actually an MPO\n            from .MpoImagePlugin import MpoImageFile\n\n            # Don't reload everything, just convert it.\n            im = MpoImageFile.adopt(im, mpheader)\n    except (TypeError, IndexError):\n        # It is really a JPEG\n        pass\n    except SyntaxError:\n        warnings.warn(\n            \"Image appears to be a malformed MPO file, it will be \"\n            \"interpreted as a base JPEG file\"\n        )\n    return im\n\n\n# ---------------------------------------------------------------------\n# Registry stuff\n\nImage.register_open(JpegImageFile.format, jpeg_factory, _accept)\nImage.register_save(JpegImageFile.format, _save)\n\nImage.register_extensions(JpegImageFile.format, [\".jfif\", \".jpe\", \".jpg\", \".jpeg\"])\n\nImage.register_mime(JpegImageFile.format, \"image/jpeg\")\n", "src/PIL/XbmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# XBM File handling\n#\n# History:\n# 1995-09-08 fl   Created\n# 1996-11-01 fl   Added save support\n# 1997-07-07 fl   Made header parser more tolerant\n# 1997-07-22 fl   Fixed yet another parser bug\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.4)\n# 2001-05-13 fl   Added hotspot handling (based on code from Bernhard Herzog)\n# 2004-02-24 fl   Allow some whitespace before first #define\n#\n# Copyright (c) 1997-2004 by Secret Labs AB\n# Copyright (c) 1996-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n# XBM header\nxbm_head = re.compile(\n    rb\"\\s*#define[ \\t]+.*_width[ \\t]+(?P<width>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+.*_height[ \\t]+(?P<height>[0-9]+)[\\r\\n]+\"\n    b\"(?P<hotspot>\"\n    b\"#define[ \\t]+[^_]*_x_hot[ \\t]+(?P<xhot>[0-9]+)[\\r\\n]+\"\n    b\"#define[ \\t]+[^_]*_y_hot[ \\t]+(?P<yhot>[0-9]+)[\\r\\n]+\"\n    b\")?\"\n    rb\"[\\000-\\377]*_bits\\[]\"\n)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix.lstrip()[:7] == b\"#define\"\n\n\n##\n# Image plugin for X11 bitmaps.\n\n\nclass XbmImageFile(ImageFile.ImageFile):\n    format = \"XBM\"\n    format_description = \"X11 Bitmap\"\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        m = xbm_head.match(self.fp.read(512))\n\n        if not m:\n            msg = \"not a XBM file\"\n            raise SyntaxError(msg)\n\n        xsize = int(m.group(\"width\"))\n        ysize = int(m.group(\"height\"))\n\n        if m.group(\"hotspot\"):\n            self.info[\"hotspot\"] = (int(m.group(\"xhot\")), int(m.group(\"yhot\")))\n\n        self._mode = \"1\"\n        self._size = xsize, ysize\n\n        self.tile = [(\"xbm\", (0, 0) + self.size, m.end(), None)]\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode != \"1\":\n        msg = f\"cannot write mode {im.mode} as XBM\"\n        raise OSError(msg)\n\n    fp.write(f\"#define im_width {im.size[0]}\\n\".encode(\"ascii\"))\n    fp.write(f\"#define im_height {im.size[1]}\\n\".encode(\"ascii\"))\n\n    hotspot = im.encoderinfo.get(\"hotspot\")\n    if hotspot:\n        fp.write(f\"#define im_x_hot {hotspot[0]}\\n\".encode(\"ascii\"))\n        fp.write(f\"#define im_y_hot {hotspot[1]}\\n\".encode(\"ascii\"))\n\n    fp.write(b\"static char im_bits[] = {\\n\")\n\n    ImageFile._save(im, fp, [(\"xbm\", (0, 0) + im.size, 0, None)])\n\n    fp.write(b\"};\\n\")\n\n\nImage.register_open(XbmImageFile.format, XbmImageFile, _accept)\nImage.register_save(XbmImageFile.format, _save)\n\nImage.register_extension(XbmImageFile.format, \".xbm\")\n\nImage.register_mime(XbmImageFile.format, \"image/xbm\")\n", "src/PIL/ImageGrab.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# screen grabber\n#\n# History:\n# 2001-04-26 fl  created\n# 2001-09-17 fl  use builtin driver, if present\n# 2002-11-19 fl  added grabclipboard support\n#\n# Copyright (c) 2001-2002 by Secret Labs AB\n# Copyright (c) 2001-2002 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport tempfile\n\nfrom . import Image\n\n\ndef grab(bbox=None, include_layered_windows=False, all_screens=False, xdisplay=None):\n    if xdisplay is None:\n        if sys.platform == \"darwin\":\n            fh, filepath = tempfile.mkstemp(\".png\")\n            os.close(fh)\n            args = [\"screencapture\"]\n            if bbox:\n                left, top, right, bottom = bbox\n                args += [\"-R\", f\"{left},{top},{right-left},{bottom-top}\"]\n            subprocess.call(args + [\"-x\", filepath])\n            im = Image.open(filepath)\n            im.load()\n            os.unlink(filepath)\n            if bbox:\n                im_resized = im.resize((right - left, bottom - top))\n                im.close()\n                return im_resized\n            return im\n        elif sys.platform == \"win32\":\n            offset, size, data = Image.core.grabscreen_win32(\n                include_layered_windows, all_screens\n            )\n            im = Image.frombytes(\n                \"RGB\",\n                size,\n                data,\n                # RGB, 32-bit line padding, origin lower left corner\n                \"raw\",\n                \"BGR\",\n                (size[0] * 3 + 3) & -4,\n                -1,\n            )\n            if bbox:\n                x0, y0 = offset\n                left, top, right, bottom = bbox\n                im = im.crop((left - x0, top - y0, right - x0, bottom - y0))\n            return im\n    try:\n        if not Image.core.HAVE_XCB:\n            msg = \"Pillow was built without XCB support\"\n            raise OSError(msg)\n        size, data = Image.core.grabscreen_x11(xdisplay)\n    except OSError:\n        if (\n            xdisplay is None\n            and sys.platform not in (\"darwin\", \"win32\")\n            and shutil.which(\"gnome-screenshot\")\n        ):\n            fh, filepath = tempfile.mkstemp(\".png\")\n            os.close(fh)\n            subprocess.call([\"gnome-screenshot\", \"-f\", filepath])\n            im = Image.open(filepath)\n            im.load()\n            os.unlink(filepath)\n            if bbox:\n                im_cropped = im.crop(bbox)\n                im.close()\n                return im_cropped\n            return im\n        else:\n            raise\n    else:\n        im = Image.frombytes(\"RGB\", size, data, \"raw\", \"BGRX\", size[0] * 4, 1)\n        if bbox:\n            im = im.crop(bbox)\n        return im\n\n\ndef grabclipboard():\n    if sys.platform == \"darwin\":\n        fh, filepath = tempfile.mkstemp(\".png\")\n        os.close(fh)\n        commands = [\n            'set theFile to (open for access POSIX file \"'\n            + filepath\n            + '\" with write permission)',\n            \"try\",\n            \"    write (the clipboard as \u00abclass PNGf\u00bb) to theFile\",\n            \"end try\",\n            \"close access theFile\",\n        ]\n        script = [\"osascript\"]\n        for command in commands:\n            script += [\"-e\", command]\n        subprocess.call(script)\n\n        im = None\n        if os.stat(filepath).st_size != 0:\n            im = Image.open(filepath)\n            im.load()\n        os.unlink(filepath)\n        return im\n    elif sys.platform == \"win32\":\n        fmt, data = Image.core.grabclipboard_win32()\n        if fmt == \"file\":  # CF_HDROP\n            import struct\n\n            o = struct.unpack_from(\"I\", data)[0]\n            if data[16] != 0:\n                files = data[o:].decode(\"utf-16le\").split(\"\\0\")\n            else:\n                files = data[o:].decode(\"mbcs\").split(\"\\0\")\n            return files[: files.index(\"\")]\n        if isinstance(data, bytes):\n            data = io.BytesIO(data)\n            if fmt == \"png\":\n                from . import PngImagePlugin\n\n                return PngImagePlugin.PngImageFile(data)\n            elif fmt == \"DIB\":\n                from . import BmpImagePlugin\n\n                return BmpImagePlugin.DibImageFile(data)\n        return None\n    else:\n        if os.getenv(\"WAYLAND_DISPLAY\"):\n            session_type = \"wayland\"\n        elif os.getenv(\"DISPLAY\"):\n            session_type = \"x11\"\n        else:  # Session type check failed\n            session_type = None\n\n        if shutil.which(\"wl-paste\") and session_type in (\"wayland\", None):\n            args = [\"wl-paste\", \"-t\", \"image\"]\n        elif shutil.which(\"xclip\") and session_type in (\"x11\", None):\n            args = [\"xclip\", \"-selection\", \"clipboard\", \"-t\", \"image/png\", \"-o\"]\n        else:\n            msg = \"wl-paste or xclip is required for ImageGrab.grabclipboard() on Linux\"\n            raise NotImplementedError(msg)\n\n        p = subprocess.run(args, capture_output=True)\n        if p.returncode != 0:\n            err = p.stderr\n            for silent_error in [\n                # wl-paste, when the clipboard is empty\n                b\"Nothing is copied\",\n                # Ubuntu/Debian wl-paste, when the clipboard is empty\n                b\"No selection\",\n                # Ubuntu/Debian wl-paste, when an image isn't available\n                b\"No suitable type of content copied\",\n                # wl-paste or Ubuntu/Debian xclip, when an image isn't available\n                b\" not available\",\n                # xclip, when an image isn't available\n                b\"cannot convert \",\n                # xclip, when the clipboard isn't initialized\n                b\"xclip: Error: There is no owner for the \",\n            ]:\n                if silent_error in err:\n                    return None\n            msg = f\"{args[0]} error\"\n            if err:\n                msg += f\": {err.strip().decode()}\"\n            raise ChildProcessError(msg)\n\n        data = io.BytesIO(p.stdout)\n        im = Image.open(data)\n        im.load()\n        return im\n", "src/PIL/MpegImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# MPEG file handling\n#\n# History:\n#       95-09-09 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1995.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile\nfrom ._binary import i8\nfrom ._typing import SupportsRead\n\n#\n# Bitstream parser\n\n\nclass BitStream:\n    def __init__(self, fp: SupportsRead[bytes]) -> None:\n        self.fp = fp\n        self.bits = 0\n        self.bitbuffer = 0\n\n    def next(self) -> int:\n        return i8(self.fp.read(1))\n\n    def peek(self, bits: int) -> int:\n        while self.bits < bits:\n            c = self.next()\n            if c < 0:\n                self.bits = 0\n                continue\n            self.bitbuffer = (self.bitbuffer << 8) + c\n            self.bits += 8\n        return self.bitbuffer >> (self.bits - bits) & (1 << bits) - 1\n\n    def skip(self, bits: int) -> None:\n        while self.bits < bits:\n            self.bitbuffer = (self.bitbuffer << 8) + i8(self.fp.read(1))\n            self.bits += 8\n        self.bits = self.bits - bits\n\n    def read(self, bits: int) -> int:\n        v = self.peek(bits)\n        self.bits = self.bits - bits\n        return v\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == b\"\\x00\\x00\\x01\\xb3\"\n\n\n##\n# Image plugin for MPEG streams.  This plugin can identify a stream,\n# but it cannot read it.\n\n\nclass MpegImageFile(ImageFile.ImageFile):\n    format = \"MPEG\"\n    format_description = \"MPEG\"\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        s = BitStream(self.fp)\n        if s.read(32) != 0x1B3:\n            msg = \"not an MPEG file\"\n            raise SyntaxError(msg)\n\n        self._mode = \"RGB\"\n        self._size = s.read(12), s.read(12)\n\n\n# --------------------------------------------------------------------\n# Registry stuff\n\nImage.register_open(MpegImageFile.format, MpegImageFile, _accept)\n\nImage.register_extensions(MpegImageFile.format, [\".mpg\", \".mpeg\"])\n\nImage.register_mime(MpegImageFile.format, \"video/mpeg\")\n", "src/PIL/XVThumbImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# XV Thumbnail file handler by Charles E. \"Gene\" Cash\n# (gcash@magicnet.net)\n#\n# see xvcolor.c and xvbrowse.c in the sources to John Bradley's XV,\n# available from ftp://ftp.cis.upenn.edu/pub/xv/\n#\n# history:\n# 98-08-15 cec  created (b/w only)\n# 98-12-09 cec  added color palette\n# 98-12-28 fl   added to PIL (with only a few very minor modifications)\n#\n# To do:\n# FIXME: make save work (this requires quantization support)\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import o8\n\n_MAGIC = b\"P7 332\"\n\n# standard color palette for thumbnails (RGB332)\nPALETTE = b\"\"\nfor r in range(8):\n    for g in range(8):\n        for b in range(4):\n            PALETTE = PALETTE + (\n                o8((r * 255) // 7) + o8((g * 255) // 7) + o8((b * 255) // 3)\n            )\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:6] == _MAGIC\n\n\n##\n# Image plugin for XV thumbnail images.\n\n\nclass XVThumbImageFile(ImageFile.ImageFile):\n    format = \"XVThumb\"\n    format_description = \"XV thumbnail image\"\n\n    def _open(self) -> None:\n        # check magic\n        assert self.fp is not None\n\n        if not _accept(self.fp.read(6)):\n            msg = \"not an XV thumbnail file\"\n            raise SyntaxError(msg)\n\n        # Skip to beginning of next line\n        self.fp.readline()\n\n        # skip info comments\n        while True:\n            s = self.fp.readline()\n            if not s:\n                msg = \"Unexpected EOF reading XV thumbnail file\"\n                raise SyntaxError(msg)\n            if s[0] != 35:  # ie. when not a comment: '#'\n                break\n\n        # parse header line (already read)\n        s = s.strip().split()\n\n        self._mode = \"P\"\n        self._size = int(s[0]), int(s[1])\n\n        self.palette = ImagePalette.raw(\"RGB\", PALETTE)\n\n        self.tile = [(\"raw\", (0, 0) + self.size, self.fp.tell(), (self.mode, 0, 1))]\n\n\n# --------------------------------------------------------------------\n\nImage.register_open(XVThumbImageFile.format, XVThumbImageFile, _accept)\n", "src/PIL/ImageFilter.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard filters\n#\n# History:\n# 1995-11-27 fl   Created\n# 2002-06-08 fl   Added rank and mode filters\n# 2003-09-15 fl   Fixed rank calculation in rank filter; added expand call\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2002 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport abc\nimport functools\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING, Any, Callable, Sequence, cast\n\nif TYPE_CHECKING:\n    from . import _imaging\n    from ._typing import NumpyArray\n\n\nclass Filter:\n    @abc.abstractmethod\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        pass\n\n\nclass MultibandFilter(Filter):\n    pass\n\n\nclass BuiltinFilter(MultibandFilter):\n    filterargs: tuple[Any, ...]\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        if image.mode == \"P\":\n            msg = \"cannot filter palette images\"\n            raise ValueError(msg)\n        return image.filter(*self.filterargs)\n\n\nclass Kernel(BuiltinFilter):\n    \"\"\"\n    Create a convolution kernel. This only supports 3x3 and 5x5 integer and floating\n    point kernels.\n\n    Kernels can only be applied to \"L\" and \"RGB\" images.\n\n    :param size: Kernel size, given as (width, height). This must be (3,3) or (5,5).\n    :param kernel: A sequence containing kernel weights. The kernel will be flipped\n                   vertically before being applied to the image.\n    :param scale: Scale factor. If given, the result for each pixel is divided by this\n                  value. The default is the sum of the kernel weights.\n    :param offset: Offset. If given, this value is added to the result, after it has\n                   been divided by the scale factor.\n    \"\"\"\n\n    name = \"Kernel\"\n\n    def __init__(\n        self,\n        size: tuple[int, int],\n        kernel: Sequence[float],\n        scale: float | None = None,\n        offset: float = 0,\n    ) -> None:\n        if scale is None:\n            # default scale is sum of kernel\n            scale = functools.reduce(lambda a, b: a + b, kernel)\n        if size[0] * size[1] != len(kernel):\n            msg = \"not enough coefficients in kernel\"\n            raise ValueError(msg)\n        self.filterargs = size, scale, offset, kernel\n\n\nclass RankFilter(Filter):\n    \"\"\"\n    Create a rank filter.  The rank filter sorts all pixels in\n    a window of the given size, and returns the ``rank``'th value.\n\n    :param size: The kernel size, in pixels.\n    :param rank: What pixel value to pick.  Use 0 for a min filter,\n                 ``size * size / 2`` for a median filter, ``size * size - 1``\n                 for a max filter, etc.\n    \"\"\"\n\n    name = \"Rank\"\n\n    def __init__(self, size: int, rank: int) -> None:\n        self.size = size\n        self.rank = rank\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        if image.mode == \"P\":\n            msg = \"cannot filter palette images\"\n            raise ValueError(msg)\n        image = image.expand(self.size // 2, self.size // 2)\n        return image.rankfilter(self.size, self.rank)\n\n\nclass MedianFilter(RankFilter):\n    \"\"\"\n    Create a median filter. Picks the median pixel value in a window with the\n    given size.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Median\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n        self.rank = size * size // 2\n\n\nclass MinFilter(RankFilter):\n    \"\"\"\n    Create a min filter.  Picks the lowest pixel value in a window with the\n    given size.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Min\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n        self.rank = 0\n\n\nclass MaxFilter(RankFilter):\n    \"\"\"\n    Create a max filter.  Picks the largest pixel value in a window with the\n    given size.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Max\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n        self.rank = size * size - 1\n\n\nclass ModeFilter(Filter):\n    \"\"\"\n    Create a mode filter. Picks the most frequent pixel value in a box with the\n    given size.  Pixel values that occur only once or twice are ignored; if no\n    pixel value occurs more than twice, the original pixel value is preserved.\n\n    :param size: The kernel size, in pixels.\n    \"\"\"\n\n    name = \"Mode\"\n\n    def __init__(self, size: int = 3) -> None:\n        self.size = size\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        return image.modefilter(self.size)\n\n\nclass GaussianBlur(MultibandFilter):\n    \"\"\"Blurs the image with a sequence of extended box filters, which\n    approximates a Gaussian kernel. For details on accuracy see\n    <https://www.mia.uni-saarland.de/Publications/gwosdek-ssvm11.pdf>\n\n    :param radius: Standard deviation of the Gaussian kernel. Either a sequence of two\n                   numbers for x and y, or a single number for both.\n    \"\"\"\n\n    name = \"GaussianBlur\"\n\n    def __init__(self, radius: float | Sequence[float] = 2) -> None:\n        self.radius = radius\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        xy = self.radius\n        if isinstance(xy, (int, float)):\n            xy = (xy, xy)\n        if xy == (0, 0):\n            return image.copy()\n        return image.gaussian_blur(xy)\n\n\nclass BoxBlur(MultibandFilter):\n    \"\"\"Blurs the image by setting each pixel to the average value of the pixels\n    in a square box extending radius pixels in each direction.\n    Supports float radius of arbitrary size. Uses an optimized implementation\n    which runs in linear time relative to the size of the image\n    for any radius value.\n\n    :param radius: Size of the box in a direction. Either a sequence of two numbers for\n                   x and y, or a single number for both.\n\n                   Radius 0 does not blur, returns an identical image.\n                   Radius 1 takes 1 pixel in each direction, i.e. 9 pixels in total.\n    \"\"\"\n\n    name = \"BoxBlur\"\n\n    def __init__(self, radius: float | Sequence[float]) -> None:\n        xy = radius if isinstance(radius, (tuple, list)) else (radius, radius)\n        if xy[0] < 0 or xy[1] < 0:\n            msg = \"radius must be >= 0\"\n            raise ValueError(msg)\n        self.radius = radius\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        xy = self.radius\n        if isinstance(xy, (int, float)):\n            xy = (xy, xy)\n        if xy == (0, 0):\n            return image.copy()\n        return image.box_blur(xy)\n\n\nclass UnsharpMask(MultibandFilter):\n    \"\"\"Unsharp mask filter.\n\n    See Wikipedia's entry on `digital unsharp masking`_ for an explanation of\n    the parameters.\n\n    :param radius: Blur Radius\n    :param percent: Unsharp strength, in percent\n    :param threshold: Threshold controls the minimum brightness change that\n      will be sharpened\n\n    .. _digital unsharp masking: https://en.wikipedia.org/wiki/Unsharp_masking#Digital_unsharp_masking\n\n    \"\"\"\n\n    name = \"UnsharpMask\"\n\n    def __init__(\n        self, radius: float = 2, percent: int = 150, threshold: int = 3\n    ) -> None:\n        self.radius = radius\n        self.percent = percent\n        self.threshold = threshold\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        return image.unsharp_mask(self.radius, self.percent, self.threshold)\n\n\nclass BLUR(BuiltinFilter):\n    name = \"Blur\"\n    # fmt: off\n    filterargs = (5, 5), 16, 0, (\n        1, 1, 1, 1, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 0, 0, 0, 1,\n        1, 1, 1, 1, 1,\n    )\n    # fmt: on\n\n\nclass CONTOUR(BuiltinFilter):\n    name = \"Contour\"\n    # fmt: off\n    filterargs = (3, 3), 1, 255, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass DETAIL(BuiltinFilter):\n    name = \"Detail\"\n    # fmt: off\n    filterargs = (3, 3), 6, 0, (\n        0,  -1,  0,\n        -1, 10, -1,\n        0,  -1,  0,\n    )\n    # fmt: on\n\n\nclass EDGE_ENHANCE(BuiltinFilter):\n    name = \"Edge-enhance\"\n    # fmt: off\n    filterargs = (3, 3), 2, 0, (\n        -1, -1, -1,\n        -1, 10, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass EDGE_ENHANCE_MORE(BuiltinFilter):\n    name = \"Edge-enhance More\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  9, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass EMBOSS(BuiltinFilter):\n    name = \"Emboss\"\n    # fmt: off\n    filterargs = (3, 3), 1, 128, (\n        -1, 0, 0,\n        0,  1, 0,\n        0,  0, 0,\n    )\n    # fmt: on\n\n\nclass FIND_EDGES(BuiltinFilter):\n    name = \"Find Edges\"\n    # fmt: off\n    filterargs = (3, 3), 1, 0, (\n        -1, -1, -1,\n        -1,  8, -1,\n        -1, -1, -1,\n    )\n    # fmt: on\n\n\nclass SHARPEN(BuiltinFilter):\n    name = \"Sharpen\"\n    # fmt: off\n    filterargs = (3, 3), 16, 0, (\n        -2, -2, -2,\n        -2, 32, -2,\n        -2, -2, -2,\n    )\n    # fmt: on\n\n\nclass SMOOTH(BuiltinFilter):\n    name = \"Smooth\"\n    # fmt: off\n    filterargs = (3, 3), 13, 0, (\n        1, 1, 1,\n        1, 5, 1,\n        1, 1, 1,\n    )\n    # fmt: on\n\n\nclass SMOOTH_MORE(BuiltinFilter):\n    name = \"Smooth More\"\n    # fmt: off\n    filterargs = (5, 5), 100, 0, (\n        1, 1,  1, 1, 1,\n        1, 5,  5, 5, 1,\n        1, 5, 44, 5, 1,\n        1, 5,  5, 5, 1,\n        1, 1,  1, 1, 1,\n    )\n    # fmt: on\n\n\nclass Color3DLUT(MultibandFilter):\n    \"\"\"Three-dimensional color lookup table.\n\n    Transforms 3-channel pixels using the values of the channels as coordinates\n    in the 3D lookup table and interpolating the nearest elements.\n\n    This method allows you to apply almost any color transformation\n    in constant time by using pre-calculated decimated tables.\n\n    .. versionadded:: 5.2.0\n\n    :param size: Size of the table. One int or tuple of (int, int, int).\n                 Minimal size in any dimension is 2, maximum is 65.\n    :param table: Flat lookup table. A list of ``channels * size**3``\n                  float elements or a list of ``size**3`` channels-sized\n                  tuples with floats. Channels are changed first,\n                  then first dimension, then second, then third.\n                  Value 0.0 corresponds lowest value of output, 1.0 highest.\n    :param channels: Number of channels in the table. Could be 3 or 4.\n                     Default is 3.\n    :param target_mode: A mode for the result image. Should have not less\n                        than ``channels`` channels. Default is ``None``,\n                        which means that mode wouldn't be changed.\n    \"\"\"\n\n    name = \"Color 3D LUT\"\n\n    def __init__(\n        self,\n        size: int | tuple[int, int, int],\n        table: Sequence[float] | Sequence[Sequence[int]] | NumpyArray,\n        channels: int = 3,\n        target_mode: str | None = None,\n        **kwargs: bool,\n    ) -> None:\n        if channels not in (3, 4):\n            msg = \"Only 3 or 4 output channels are supported\"\n            raise ValueError(msg)\n        self.size = size = self._check_size(size)\n        self.channels = channels\n        self.mode = target_mode\n\n        # Hidden flag `_copy_table=False` could be used to avoid extra copying\n        # of the table if the table is specially made for the constructor.\n        copy_table = kwargs.get(\"_copy_table\", True)\n        items = size[0] * size[1] * size[2]\n        wrong_size = False\n\n        numpy: ModuleType | None = None\n        if hasattr(table, \"shape\"):\n            try:\n                import numpy\n            except ImportError:\n                pass\n\n        if numpy and isinstance(table, numpy.ndarray):\n            numpy_table: NumpyArray = table\n            if copy_table:\n                numpy_table = numpy_table.copy()\n\n            if numpy_table.shape in [\n                (items * channels,),\n                (items, channels),\n                (size[2], size[1], size[0], channels),\n            ]:\n                table = numpy_table.reshape(items * channels)\n            else:\n                wrong_size = True\n\n        else:\n            if copy_table:\n                table = list(table)\n\n            # Convert to a flat list\n            if table and isinstance(table[0], (list, tuple)):\n                raw_table = cast(Sequence[Sequence[int]], table)\n                flat_table: list[int] = []\n                for pixel in raw_table:\n                    if len(pixel) != channels:\n                        msg = (\n                            \"The elements of the table should \"\n                            f\"have a length of {channels}.\"\n                        )\n                        raise ValueError(msg)\n                    flat_table.extend(pixel)\n                table = flat_table\n\n        if wrong_size or len(table) != items * channels:\n            msg = (\n                \"The table should have either channels * size**3 float items \"\n                \"or size**3 items of channels-sized tuples with floats. \"\n                f\"Table should be: {channels}x{size[0]}x{size[1]}x{size[2]}. \"\n                f\"Actual length: {len(table)}\"\n            )\n            raise ValueError(msg)\n        self.table = table\n\n    @staticmethod\n    def _check_size(size: Any) -> tuple[int, int, int]:\n        try:\n            _, _, _ = size\n        except ValueError as e:\n            msg = \"Size should be either an integer or a tuple of three integers.\"\n            raise ValueError(msg) from e\n        except TypeError:\n            size = (size, size, size)\n        size = tuple(int(x) for x in size)\n        for size_1d in size:\n            if not 2 <= size_1d <= 65:\n                msg = \"Size should be in [2, 65] range.\"\n                raise ValueError(msg)\n        return size\n\n    @classmethod\n    def generate(\n        cls,\n        size: int | tuple[int, int, int],\n        callback: Callable[[float, float, float], tuple[float, ...]],\n        channels: int = 3,\n        target_mode: str | None = None,\n    ) -> Color3DLUT:\n        \"\"\"Generates new LUT using provided callback.\n\n        :param size: Size of the table. Passed to the constructor.\n        :param callback: Function with three parameters which correspond\n                         three color channels. Will be called ``size**3``\n                         times with values from 0.0 to 1.0 and should return\n                         a tuple with ``channels`` elements.\n        :param channels: The number of channels which should return callback.\n        :param target_mode: Passed to the constructor of the resulting\n                            lookup table.\n        \"\"\"\n        size_1d, size_2d, size_3d = cls._check_size(size)\n        if channels not in (3, 4):\n            msg = \"Only 3 or 4 output channels are supported\"\n            raise ValueError(msg)\n\n        table: list[float] = [0] * (size_1d * size_2d * size_3d * channels)\n        idx_out = 0\n        for b in range(size_3d):\n            for g in range(size_2d):\n                for r in range(size_1d):\n                    table[idx_out : idx_out + channels] = callback(\n                        r / (size_1d - 1), g / (size_2d - 1), b / (size_3d - 1)\n                    )\n                    idx_out += channels\n\n        return cls(\n            (size_1d, size_2d, size_3d),\n            table,\n            channels=channels,\n            target_mode=target_mode,\n            _copy_table=False,\n        )\n\n    def transform(\n        self,\n        callback: Callable[..., tuple[float, ...]],\n        with_normals: bool = False,\n        channels: int | None = None,\n        target_mode: str | None = None,\n    ) -> Color3DLUT:\n        \"\"\"Transforms the table values using provided callback and returns\n        a new LUT with altered values.\n\n        :param callback: A function which takes old lookup table values\n                         and returns a new set of values. The number\n                         of arguments which function should take is\n                         ``self.channels`` or ``3 + self.channels``\n                         if ``with_normals`` flag is set.\n                         Should return a tuple of ``self.channels`` or\n                         ``channels`` elements if it is set.\n        :param with_normals: If true, ``callback`` will be called with\n                             coordinates in the color cube as the first\n                             three arguments. Otherwise, ``callback``\n                             will be called only with actual color values.\n        :param channels: The number of channels in the resulting lookup table.\n        :param target_mode: Passed to the constructor of the resulting\n                            lookup table.\n        \"\"\"\n        if channels not in (None, 3, 4):\n            msg = \"Only 3 or 4 output channels are supported\"\n            raise ValueError(msg)\n        ch_in = self.channels\n        ch_out = channels or ch_in\n        size_1d, size_2d, size_3d = self.size\n\n        table = [0] * (size_1d * size_2d * size_3d * ch_out)\n        idx_in = 0\n        idx_out = 0\n        for b in range(size_3d):\n            for g in range(size_2d):\n                for r in range(size_1d):\n                    values = self.table[idx_in : idx_in + ch_in]\n                    if with_normals:\n                        values = callback(\n                            r / (size_1d - 1),\n                            g / (size_2d - 1),\n                            b / (size_3d - 1),\n                            *values,\n                        )\n                    else:\n                        values = callback(*values)\n                    table[idx_out : idx_out + ch_out] = values\n                    idx_in += ch_in\n                    idx_out += ch_out\n\n        return type(self)(\n            self.size,\n            table,\n            channels=ch_out,\n            target_mode=target_mode or self.mode,\n            _copy_table=False,\n        )\n\n    def __repr__(self) -> str:\n        r = [\n            f\"{self.__class__.__name__} from {self.table.__class__.__name__}\",\n            \"size={:d}x{:d}x{:d}\".format(*self.size),\n            f\"channels={self.channels:d}\",\n        ]\n        if self.mode:\n            r.append(f\"target_mode={self.mode}\")\n        return \"<{}>\".format(\" \".join(r))\n\n    def filter(self, image: _imaging.ImagingCore) -> _imaging.ImagingCore:\n        from . import Image\n\n        return image.color_lut_3d(\n            self.mode or image.mode,\n            Image.Resampling.BILINEAR,\n            self.channels,\n            self.size[0],\n            self.size[1],\n            self.size[2],\n            self.table,\n        )\n", "src/PIL/PdfImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PDF (Acrobat) file handling\n#\n# History:\n# 1996-07-16 fl   Created\n# 1997-01-18 fl   Fixed header\n# 2004-02-21 fl   Fixes for 1/L/CMYK images, etc.\n# 2004-02-24 fl   Fixes for 1 and P images.\n#\n# Copyright (c) 1997-2004 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1996-1997 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n##\n# Image plugin for PDF images (output only).\n##\nfrom __future__ import annotations\n\nimport io\nimport math\nimport os\nimport time\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImageSequence, PdfParser, __version__, features\n\n#\n# --------------------------------------------------------------------\n\n# object ids:\n#  1. catalogue\n#  2. pages\n#  3. image\n#  4. page\n#  5. page contents\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, save_all=True)\n\n\n##\n# (Internal) Image save plugin for the PDF format.\n\n\ndef _write_image(im, filename, existing_pdf, image_refs):\n    # FIXME: Should replace ASCIIHexDecode with RunLengthDecode\n    # (packbits) or LZWDecode (tiff/lzw compression).  Note that\n    # PDF 1.2 also supports Flatedecode (zip compression).\n\n    params = None\n    decode = None\n\n    #\n    # Get image characteristics\n\n    width, height = im.size\n\n    dict_obj = {\"BitsPerComponent\": 8}\n    if im.mode == \"1\":\n        if features.check(\"libtiff\"):\n            filter = \"CCITTFaxDecode\"\n            dict_obj[\"BitsPerComponent\"] = 1\n            params = PdfParser.PdfArray(\n                [\n                    PdfParser.PdfDict(\n                        {\n                            \"K\": -1,\n                            \"BlackIs1\": True,\n                            \"Columns\": width,\n                            \"Rows\": height,\n                        }\n                    )\n                ]\n            )\n        else:\n            filter = \"DCTDecode\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceGray\")\n        procset = \"ImageB\"  # grayscale\n    elif im.mode == \"L\":\n        filter = \"DCTDecode\"\n        # params = f\"<< /Predictor 15 /Columns {width-2} >>\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceGray\")\n        procset = \"ImageB\"  # grayscale\n    elif im.mode == \"LA\":\n        filter = \"JPXDecode\"\n        # params = f\"<< /Predictor 15 /Columns {width-2} >>\"\n        procset = \"ImageB\"  # grayscale\n        dict_obj[\"SMaskInData\"] = 1\n    elif im.mode == \"P\":\n        filter = \"ASCIIHexDecode\"\n        palette = im.getpalette()\n        dict_obj[\"ColorSpace\"] = [\n            PdfParser.PdfName(\"Indexed\"),\n            PdfParser.PdfName(\"DeviceRGB\"),\n            len(palette) // 3 - 1,\n            PdfParser.PdfBinary(palette),\n        ]\n        procset = \"ImageI\"  # indexed color\n\n        if \"transparency\" in im.info:\n            smask = im.convert(\"LA\").getchannel(\"A\")\n            smask.encoderinfo = {}\n\n            image_ref = _write_image(smask, filename, existing_pdf, image_refs)[0]\n            dict_obj[\"SMask\"] = image_ref\n    elif im.mode == \"RGB\":\n        filter = \"DCTDecode\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceRGB\")\n        procset = \"ImageC\"  # color images\n    elif im.mode == \"RGBA\":\n        filter = \"JPXDecode\"\n        procset = \"ImageC\"  # color images\n        dict_obj[\"SMaskInData\"] = 1\n    elif im.mode == \"CMYK\":\n        filter = \"DCTDecode\"\n        dict_obj[\"ColorSpace\"] = PdfParser.PdfName(\"DeviceCMYK\")\n        procset = \"ImageC\"  # color images\n        decode = [1, 0, 1, 0, 1, 0, 1, 0]\n    else:\n        msg = f\"cannot save mode {im.mode}\"\n        raise ValueError(msg)\n\n    #\n    # image\n\n    op = io.BytesIO()\n\n    if filter == \"ASCIIHexDecode\":\n        ImageFile._save(im, op, [(\"hex\", (0, 0) + im.size, 0, im.mode)])\n    elif filter == \"CCITTFaxDecode\":\n        im.save(\n            op,\n            \"TIFF\",\n            compression=\"group4\",\n            # use a single strip\n            strip_size=math.ceil(width / 8) * height,\n        )\n    elif filter == \"DCTDecode\":\n        Image.SAVE[\"JPEG\"](im, op, filename)\n    elif filter == \"JPXDecode\":\n        del dict_obj[\"BitsPerComponent\"]\n        Image.SAVE[\"JPEG2000\"](im, op, filename)\n    else:\n        msg = f\"unsupported PDF filter ({filter})\"\n        raise ValueError(msg)\n\n    stream = op.getvalue()\n    if filter == \"CCITTFaxDecode\":\n        stream = stream[8:]\n        filter = PdfParser.PdfArray([PdfParser.PdfName(filter)])\n    else:\n        filter = PdfParser.PdfName(filter)\n\n    image_ref = image_refs.pop(0)\n    existing_pdf.write_obj(\n        image_ref,\n        stream=stream,\n        Type=PdfParser.PdfName(\"XObject\"),\n        Subtype=PdfParser.PdfName(\"Image\"),\n        Width=width,  # * 72.0 / x_resolution,\n        Height=height,  # * 72.0 / y_resolution,\n        Filter=filter,\n        Decode=decode,\n        DecodeParms=params,\n        **dict_obj,\n    )\n\n    return image_ref, procset\n\n\ndef _save(im, fp, filename, save_all=False):\n    is_appending = im.encoderinfo.get(\"append\", False)\n    if is_appending:\n        existing_pdf = PdfParser.PdfParser(f=fp, filename=filename, mode=\"r+b\")\n    else:\n        existing_pdf = PdfParser.PdfParser(f=fp, filename=filename, mode=\"w+b\")\n\n    dpi = im.encoderinfo.get(\"dpi\")\n    if dpi:\n        x_resolution = dpi[0]\n        y_resolution = dpi[1]\n    else:\n        x_resolution = y_resolution = im.encoderinfo.get(\"resolution\", 72.0)\n\n    info = {\n        \"title\": (\n            None if is_appending else os.path.splitext(os.path.basename(filename))[0]\n        ),\n        \"author\": None,\n        \"subject\": None,\n        \"keywords\": None,\n        \"creator\": None,\n        \"producer\": None,\n        \"creationDate\": None if is_appending else time.gmtime(),\n        \"modDate\": None if is_appending else time.gmtime(),\n    }\n    for k, default in info.items():\n        v = im.encoderinfo.get(k) if k in im.encoderinfo else default\n        if v:\n            existing_pdf.info[k[0].upper() + k[1:]] = v\n\n    #\n    # make sure image data is available\n    im.load()\n\n    existing_pdf.start_writing()\n    existing_pdf.write_header()\n    existing_pdf.write_comment(f\"created by Pillow {__version__} PDF driver\")\n\n    #\n    # pages\n    ims = [im]\n    if save_all:\n        append_images = im.encoderinfo.get(\"append_images\", [])\n        for append_im in append_images:\n            append_im.encoderinfo = im.encoderinfo.copy()\n            ims.append(append_im)\n    number_of_pages = 0\n    image_refs = []\n    page_refs = []\n    contents_refs = []\n    for im in ims:\n        im_number_of_pages = 1\n        if save_all:\n            try:\n                im_number_of_pages = im.n_frames\n            except AttributeError:\n                # Image format does not have n_frames.\n                # It is a single frame image\n                pass\n        number_of_pages += im_number_of_pages\n        for i in range(im_number_of_pages):\n            image_refs.append(existing_pdf.next_object_id(0))\n            if im.mode == \"P\" and \"transparency\" in im.info:\n                image_refs.append(existing_pdf.next_object_id(0))\n\n            page_refs.append(existing_pdf.next_object_id(0))\n            contents_refs.append(existing_pdf.next_object_id(0))\n            existing_pdf.pages.append(page_refs[-1])\n\n    #\n    # catalog and list of pages\n    existing_pdf.write_catalog()\n\n    page_number = 0\n    for im_sequence in ims:\n        im_pages = ImageSequence.Iterator(im_sequence) if save_all else [im_sequence]\n        for im in im_pages:\n            image_ref, procset = _write_image(im, filename, existing_pdf, image_refs)\n\n            #\n            # page\n\n            existing_pdf.write_page(\n                page_refs[page_number],\n                Resources=PdfParser.PdfDict(\n                    ProcSet=[PdfParser.PdfName(\"PDF\"), PdfParser.PdfName(procset)],\n                    XObject=PdfParser.PdfDict(image=image_ref),\n                ),\n                MediaBox=[\n                    0,\n                    0,\n                    im.width * 72.0 / x_resolution,\n                    im.height * 72.0 / y_resolution,\n                ],\n                Contents=contents_refs[page_number],\n            )\n\n            #\n            # page contents\n\n            page_contents = b\"q %f 0 0 %f 0 0 cm /image Do Q\\n\" % (\n                im.width * 72.0 / x_resolution,\n                im.height * 72.0 / y_resolution,\n            )\n\n            existing_pdf.write_obj(contents_refs[page_number], stream=page_contents)\n\n            page_number += 1\n\n    #\n    # trailer\n    existing_pdf.write_xref_and_trailer()\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n    existing_pdf.close()\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_save(\"PDF\", _save)\nImage.register_save_all(\"PDF\", _save_all)\n\nImage.register_extension(\"PDF\", \".pdf\")\n\nImage.register_mime(\"PDF\", \"application/pdf\")\n", "src/PIL/ImagePath.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# path interface\n#\n# History:\n# 1996-11-04 fl   Created\n# 2002-04-14 fl   Added documentation stub class\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image\n\nPath = Image.core.path\n", "src/PIL/ImageTk.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a Tk display interface\n#\n# History:\n# 96-04-08 fl   Created\n# 96-09-06 fl   Added getimage method\n# 96-11-01 fl   Rewritten, removed image attribute and crop method\n# 97-05-09 fl   Use PyImagingPaste method instead of image type\n# 97-05-12 fl   Minor tweaks to match the IFUNC95 interface\n# 97-05-17 fl   Support the \"pilbitmap\" booster patch\n# 97-06-05 fl   Added file= and data= argument to image constructors\n# 98-03-09 fl   Added width and height methods to Image classes\n# 98-07-02 fl   Use default mode for \"P\" images without palette attribute\n# 98-07-02 fl   Explicitly destroy Tkinter image objects\n# 99-07-24 fl   Support multiple Tk interpreters (from Greg Couch)\n# 99-07-26 fl   Automatically hook into Tkinter (if possible)\n# 99-08-15 fl   Hook uses _imagingtk instead of _imaging\n#\n# Copyright (c) 1997-1999 by Secret Labs AB\n# Copyright (c) 1996-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport tkinter\nfrom io import BytesIO\n\nfrom . import Image\n\n# --------------------------------------------------------------------\n# Check for Tkinter interface hooks\n\n_pilbitmap_ok = None\n\n\ndef _pilbitmap_check() -> int:\n    global _pilbitmap_ok\n    if _pilbitmap_ok is None:\n        try:\n            im = Image.new(\"1\", (1, 1))\n            tkinter.BitmapImage(data=f\"PIL:{im.im.id}\")\n            _pilbitmap_ok = 1\n        except tkinter.TclError:\n            _pilbitmap_ok = 0\n    return _pilbitmap_ok\n\n\ndef _get_image_from_kw(kw):\n    source = None\n    if \"file\" in kw:\n        source = kw.pop(\"file\")\n    elif \"data\" in kw:\n        source = BytesIO(kw.pop(\"data\"))\n    if source:\n        return Image.open(source)\n\n\ndef _pyimagingtkcall(command, photo, id):\n    tk = photo.tk\n    try:\n        tk.call(command, photo, id)\n    except tkinter.TclError:\n        # activate Tkinter hook\n        # may raise an error if it cannot attach to Tkinter\n        from . import _imagingtk\n\n        _imagingtk.tkinit(tk.interpaddr())\n        tk.call(command, photo, id)\n\n\n# --------------------------------------------------------------------\n# PhotoImage\n\n\nclass PhotoImage:\n    \"\"\"\n    A Tkinter-compatible photo image.  This can be used\n    everywhere Tkinter expects an image object.  If the image is an RGBA\n    image, pixels having alpha 0 are treated as transparent.\n\n    The constructor takes either a PIL image, or a mode and a size.\n    Alternatively, you can use the ``file`` or ``data`` options to initialize\n    the photo image object.\n\n    :param image: Either a PIL image, or a mode string.  If a mode string is\n                  used, a size must also be given.\n    :param size: If the first argument is a mode string, this defines the size\n                 of the image.\n    :keyword file: A filename to load the image from (using\n                   ``Image.open(file)``).\n    :keyword data: An 8-bit string containing image data (as loaded from an\n                   image file).\n    \"\"\"\n\n    def __init__(self, image=None, size=None, **kw):\n        # Tk compatibility: file or data\n        if image is None:\n            image = _get_image_from_kw(kw)\n\n        if hasattr(image, \"mode\") and hasattr(image, \"size\"):\n            # got an image instead of a mode\n            mode = image.mode\n            if mode == \"P\":\n                # palette mapped data\n                image.apply_transparency()\n                image.load()\n                try:\n                    mode = image.palette.mode\n                except AttributeError:\n                    mode = \"RGB\"  # default\n            size = image.size\n            kw[\"width\"], kw[\"height\"] = size\n        else:\n            mode = image\n            image = None\n\n        if mode not in [\"1\", \"L\", \"RGB\", \"RGBA\"]:\n            mode = Image.getmodebase(mode)\n\n        self.__mode = mode\n        self.__size = size\n        self.__photo = tkinter.PhotoImage(**kw)\n        self.tk = self.__photo.tk\n        if image:\n            self.paste(image)\n\n    def __del__(self) -> None:\n        name = self.__photo.name\n        self.__photo.name = None\n        try:\n            self.__photo.tk.call(\"image\", \"delete\", name)\n        except Exception:\n            pass  # ignore internal errors\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get the Tkinter photo image identifier.  This method is automatically\n        called by Tkinter whenever a PhotoImage object is passed to a Tkinter\n        method.\n\n        :return: A Tkinter photo image identifier (a string).\n        \"\"\"\n        return str(self.__photo)\n\n    def width(self) -> int:\n        \"\"\"\n        Get the width of the image.\n\n        :return: The width, in pixels.\n        \"\"\"\n        return self.__size[0]\n\n    def height(self) -> int:\n        \"\"\"\n        Get the height of the image.\n\n        :return: The height, in pixels.\n        \"\"\"\n        return self.__size[1]\n\n    def paste(self, im: Image.Image) -> None:\n        \"\"\"\n        Paste a PIL image into the photo image.  Note that this can\n        be very slow if the photo image is displayed.\n\n        :param im: A PIL image. The size must match the target region.  If the\n                   mode does not match, the image is converted to the mode of\n                   the bitmap image.\n        \"\"\"\n        # convert to blittable\n        im.load()\n        image = im.im\n        if image.isblock() and im.mode == self.__mode:\n            block = image\n        else:\n            block = image.new_block(self.__mode, im.size)\n            image.convert2(block, image)  # convert directly between buffers\n\n        _pyimagingtkcall(\"PyImagingPhoto\", self.__photo, block.id)\n\n\n# --------------------------------------------------------------------\n# BitmapImage\n\n\nclass BitmapImage:\n    \"\"\"\n    A Tkinter-compatible bitmap image.  This can be used everywhere Tkinter\n    expects an image object.\n\n    The given image must have mode \"1\".  Pixels having value 0 are treated as\n    transparent.  Options, if any, are passed on to Tkinter.  The most commonly\n    used option is ``foreground``, which is used to specify the color for the\n    non-transparent parts.  See the Tkinter documentation for information on\n    how to specify colours.\n\n    :param image: A PIL image.\n    \"\"\"\n\n    def __init__(self, image=None, **kw):\n        # Tk compatibility: file or data\n        if image is None:\n            image = _get_image_from_kw(kw)\n\n        self.__mode = image.mode\n        self.__size = image.size\n\n        if _pilbitmap_check():\n            # fast way (requires the pilbitmap booster patch)\n            image.load()\n            kw[\"data\"] = f\"PIL:{image.im.id}\"\n            self.__im = image  # must keep a reference\n        else:\n            # slow but safe way\n            kw[\"data\"] = image.tobitmap()\n        self.__photo = tkinter.BitmapImage(**kw)\n\n    def __del__(self) -> None:\n        name = self.__photo.name\n        self.__photo.name = None\n        try:\n            self.__photo.tk.call(\"image\", \"delete\", name)\n        except Exception:\n            pass  # ignore internal errors\n\n    def width(self) -> int:\n        \"\"\"\n        Get the width of the image.\n\n        :return: The width, in pixels.\n        \"\"\"\n        return self.__size[0]\n\n    def height(self) -> int:\n        \"\"\"\n        Get the height of the image.\n\n        :return: The height, in pixels.\n        \"\"\"\n        return self.__size[1]\n\n    def __str__(self) -> str:\n        \"\"\"\n        Get the Tkinter bitmap image identifier.  This method is automatically\n        called by Tkinter whenever a BitmapImage object is passed to a Tkinter\n        method.\n\n        :return: A Tkinter bitmap image identifier (a string).\n        \"\"\"\n        return str(self.__photo)\n\n\ndef getimage(photo: PhotoImage) -> Image.Image:\n    \"\"\"Copies the contents of a PhotoImage to a PIL image memory.\"\"\"\n    im = Image.new(\"RGBA\", (photo.width(), photo.height()))\n    block = im.im\n\n    _pyimagingtkcall(\"PyImagingPhotoGet\", photo, block.id)\n\n    return im\n\n\ndef _show(image, title):\n    \"\"\"Helper for the Image.show method.\"\"\"\n\n    class UI(tkinter.Label):\n        def __init__(self, master, im):\n            if im.mode == \"1\":\n                self.image = BitmapImage(im, foreground=\"white\", master=master)\n            else:\n                self.image = PhotoImage(im, master=master)\n            super().__init__(master, image=self.image, bg=\"black\", bd=0)\n\n    if not tkinter._default_root:\n        msg = \"tkinter not initialized\"\n        raise OSError(msg)\n    top = tkinter.Toplevel()\n    if title:\n        top.title(title)\n    UI(top, image).pack()\n", "src/PIL/ImtImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# IM Tools support for PIL\n#\n# history:\n# 1996-05-27 fl   Created (read 8-bit images only)\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.2)\n#\n# Copyright (c) Secret Labs AB 1997-2001.\n# Copyright (c) Fredrik Lundh 1996-2001.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\n\nfrom . import Image, ImageFile\n\n#\n# --------------------------------------------------------------------\n\nfield = re.compile(rb\"([a-z]*) ([^ \\r\\n]*)\")\n\n\n##\n# Image plugin for IM Tools images.\n\n\nclass ImtImageFile(ImageFile.ImageFile):\n    format = \"IMT\"\n    format_description = \"IM Tools\"\n\n    def _open(self) -> None:\n        # Quick rejection: if there's not a LF among the first\n        # 100 bytes, this is (probably) not a text header.\n\n        assert self.fp is not None\n\n        buffer = self.fp.read(100)\n        if b\"\\n\" not in buffer:\n            msg = \"not an IM file\"\n            raise SyntaxError(msg)\n\n        xsize = ysize = 0\n\n        while True:\n            if buffer:\n                s = buffer[:1]\n                buffer = buffer[1:]\n            else:\n                s = self.fp.read(1)\n            if not s:\n                break\n\n            if s == b\"\\x0C\":\n                # image data begins\n                self.tile = [\n                    (\n                        \"raw\",\n                        (0, 0) + self.size,\n                        self.fp.tell() - len(buffer),\n                        (self.mode, 0, 1),\n                    )\n                ]\n\n                break\n\n            else:\n                # read key/value pair\n                if b\"\\n\" not in buffer:\n                    buffer += self.fp.read(100)\n                lines = buffer.split(b\"\\n\")\n                s += lines.pop(0)\n                buffer = b\"\\n\".join(lines)\n                if len(s) == 1 or len(s) > 100:\n                    break\n                if s[0] == ord(b\"*\"):\n                    continue  # comment\n\n                m = field.match(s)\n                if not m:\n                    break\n                k, v = m.group(1, 2)\n                if k == b\"width\":\n                    xsize = int(v)\n                    self._size = xsize, ysize\n                elif k == b\"height\":\n                    ysize = int(v)\n                    self._size = xsize, ysize\n                elif k == b\"pixel\" and v == b\"n8\":\n                    self._mode = \"L\"\n\n\n#\n# --------------------------------------------------------------------\n\nImage.register_open(ImtImageFile.format, ImtImageFile)\n\n#\n# no extension registered (\".im\" is simply too common)\n", "src/PIL/GdImageFile.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# GD file handling\n#\n# History:\n# 1996-04-12 fl   Created\n#\n# Copyright (c) 1997 by Secret Labs AB.\n# Copyright (c) 1996 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\n\n\"\"\"\n.. note::\n    This format cannot be automatically recognized, so the\n    class is not registered for use with :py:func:`PIL.Image.open()`.  To open a\n    gd file, use the :py:func:`PIL.GdImageFile.open()` function instead.\n\n.. warning::\n    THE GD FORMAT IS NOT DESIGNED FOR DATA INTERCHANGE.  This\n    implementation is provided for convenience and demonstrational\n    purposes only.\n\"\"\"\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import ImageFile, ImagePalette, UnidentifiedImageError\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._typing import StrOrBytesPath\n\n\nclass GdImageFile(ImageFile.ImageFile):\n    \"\"\"\n    Image plugin for the GD uncompressed format.  Note that this format\n    is not supported by the standard :py:func:`PIL.Image.open()` function.  To use\n    this plugin, you have to import the :py:mod:`PIL.GdImageFile` module and\n    use the :py:func:`PIL.GdImageFile.open()` function.\n    \"\"\"\n\n    format = \"GD\"\n    format_description = \"GD uncompressed images\"\n\n    def _open(self) -> None:\n        # Header\n        assert self.fp is not None\n\n        s = self.fp.read(1037)\n\n        if i16(s) not in [65534, 65535]:\n            msg = \"Not a valid GD 2.x .gd file\"\n            raise SyntaxError(msg)\n\n        self._mode = \"L\"  # FIXME: \"P\"\n        self._size = i16(s, 2), i16(s, 4)\n\n        true_color = s[6]\n        true_color_offset = 2 if true_color else 0\n\n        # transparency index\n        tindex = i32(s, 7 + true_color_offset)\n        if tindex < 256:\n            self.info[\"transparency\"] = tindex\n\n        self.palette = ImagePalette.raw(\n            \"XBGR\", s[7 + true_color_offset + 4 : 7 + true_color_offset + 4 + 256 * 4]\n        )\n\n        self.tile = [\n            (\n                \"raw\",\n                (0, 0) + self.size,\n                7 + true_color_offset + 4 + 256 * 4,\n                (\"L\", 0, 1),\n            )\n        ]\n\n\ndef open(fp: StrOrBytesPath | IO[bytes], mode: str = \"r\") -> GdImageFile:\n    \"\"\"\n    Load texture from a GD image file.\n\n    :param fp: GD file name, or an opened file handle.\n    :param mode: Optional mode.  In this version, if the mode argument\n        is given, it must be \"r\".\n    :returns: An image instance.\n    :raises OSError: If the image could not be read.\n    \"\"\"\n    if mode != \"r\":\n        msg = \"bad mode\"\n        raise ValueError(msg)\n\n    try:\n        return GdImageFile(fp)\n    except SyntaxError as e:\n        msg = \"cannot identify this image file\"\n        raise UnidentifiedImageError(msg) from e\n", "src/PIL/IcoImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Windows Icon support for PIL\n#\n# History:\n#       96-05-27 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\n\n# This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis\n# <casadebender@gmail.com>.\n# https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki\n#\n# Icon format references:\n#   * https://en.wikipedia.org/wiki/ICO_(file_format)\n#   * https://msdn.microsoft.com/en-us/library/ms997538.aspx\nfrom __future__ import annotations\n\nimport warnings\nfrom io import BytesIO\nfrom math import ceil, log\nfrom typing import IO\n\nfrom . import BmpImagePlugin, Image, ImageFile, PngImagePlugin\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\nfrom ._binary import o8\nfrom ._binary import o16le as o16\nfrom ._binary import o32le as o32\n\n#\n# --------------------------------------------------------------------\n\n_MAGIC = b\"\\0\\0\\1\\0\"\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    fp.write(_MAGIC)  # (2+2)\n    bmp = im.encoderinfo.get(\"bitmap_format\") == \"bmp\"\n    sizes = im.encoderinfo.get(\n        \"sizes\",\n        [(16, 16), (24, 24), (32, 32), (48, 48), (64, 64), (128, 128), (256, 256)],\n    )\n    frames = []\n    provided_ims = [im] + im.encoderinfo.get(\"append_images\", [])\n    width, height = im.size\n    for size in sorted(set(sizes)):\n        if size[0] > width or size[1] > height or size[0] > 256 or size[1] > 256:\n            continue\n\n        for provided_im in provided_ims:\n            if provided_im.size != size:\n                continue\n            frames.append(provided_im)\n            if bmp:\n                bits = BmpImagePlugin.SAVE[provided_im.mode][1]\n                bits_used = [bits]\n                for other_im in provided_ims:\n                    if other_im.size != size:\n                        continue\n                    bits = BmpImagePlugin.SAVE[other_im.mode][1]\n                    if bits not in bits_used:\n                        # Another image has been supplied for this size\n                        # with a different bit depth\n                        frames.append(other_im)\n                        bits_used.append(bits)\n            break\n        else:\n            # TODO: invent a more convenient method for proportional scalings\n            frame = provided_im.copy()\n            frame.thumbnail(size, Image.Resampling.LANCZOS, reducing_gap=None)\n            frames.append(frame)\n    fp.write(o16(len(frames)))  # idCount(2)\n    offset = fp.tell() + len(frames) * 16\n    for frame in frames:\n        width, height = frame.size\n        # 0 means 256\n        fp.write(o8(width if width < 256 else 0))  # bWidth(1)\n        fp.write(o8(height if height < 256 else 0))  # bHeight(1)\n\n        bits, colors = BmpImagePlugin.SAVE[frame.mode][1:] if bmp else (32, 0)\n        fp.write(o8(colors))  # bColorCount(1)\n        fp.write(b\"\\0\")  # bReserved(1)\n        fp.write(b\"\\0\\0\")  # wPlanes(2)\n        fp.write(o16(bits))  # wBitCount(2)\n\n        image_io = BytesIO()\n        if bmp:\n            frame.save(image_io, \"dib\")\n\n            if bits != 32:\n                and_mask = Image.new(\"1\", size)\n                ImageFile._save(\n                    and_mask, image_io, [(\"raw\", (0, 0) + size, 0, (\"1\", 0, -1))]\n                )\n        else:\n            frame.save(image_io, \"png\")\n        image_io.seek(0)\n        image_bytes = image_io.read()\n        if bmp:\n            image_bytes = image_bytes[:8] + o32(height * 2) + image_bytes[12:]\n        bytes_len = len(image_bytes)\n        fp.write(o32(bytes_len))  # dwBytesInRes(4)\n        fp.write(o32(offset))  # dwImageOffset(4)\n        current = fp.tell()\n        fp.seek(offset)\n        fp.write(image_bytes)\n        offset = offset + bytes_len\n        fp.seek(current)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == _MAGIC\n\n\nclass IcoFile:\n    def __init__(self, buf):\n        \"\"\"\n        Parse image from file-like object containing ico file data\n        \"\"\"\n\n        # check magic\n        s = buf.read(6)\n        if not _accept(s):\n            msg = \"not an ICO file\"\n            raise SyntaxError(msg)\n\n        self.buf = buf\n        self.entry = []\n\n        # Number of items in file\n        self.nb_items = i16(s, 4)\n\n        # Get headers for each item\n        for i in range(self.nb_items):\n            s = buf.read(16)\n\n            icon_header = {\n                \"width\": s[0],\n                \"height\": s[1],\n                \"nb_color\": s[2],  # No. of colors in image (0 if >=8bpp)\n                \"reserved\": s[3],\n                \"planes\": i16(s, 4),\n                \"bpp\": i16(s, 6),\n                \"size\": i32(s, 8),\n                \"offset\": i32(s, 12),\n            }\n\n            # See Wikipedia\n            for j in (\"width\", \"height\"):\n                if not icon_header[j]:\n                    icon_header[j] = 256\n\n            # See Wikipedia notes about color depth.\n            # We need this just to differ images with equal sizes\n            icon_header[\"color_depth\"] = (\n                icon_header[\"bpp\"]\n                or (\n                    icon_header[\"nb_color\"] != 0\n                    and ceil(log(icon_header[\"nb_color\"], 2))\n                )\n                or 256\n            )\n\n            icon_header[\"dim\"] = (icon_header[\"width\"], icon_header[\"height\"])\n            icon_header[\"square\"] = icon_header[\"width\"] * icon_header[\"height\"]\n\n            self.entry.append(icon_header)\n\n        self.entry = sorted(self.entry, key=lambda x: x[\"color_depth\"])\n        # ICO images are usually squares\n        self.entry = sorted(self.entry, key=lambda x: x[\"square\"], reverse=True)\n\n    def sizes(self):\n        \"\"\"\n        Get a list of all available icon sizes and color depths.\n        \"\"\"\n        return {(h[\"width\"], h[\"height\"]) for h in self.entry}\n\n    def getentryindex(self, size, bpp=False):\n        for i, h in enumerate(self.entry):\n            if size == h[\"dim\"] and (bpp is False or bpp == h[\"color_depth\"]):\n                return i\n        return 0\n\n    def getimage(self, size, bpp=False):\n        \"\"\"\n        Get an image from the icon\n        \"\"\"\n        return self.frame(self.getentryindex(size, bpp))\n\n    def frame(self, idx: int) -> Image.Image:\n        \"\"\"\n        Get an image from frame idx\n        \"\"\"\n\n        header = self.entry[idx]\n\n        self.buf.seek(header[\"offset\"])\n        data = self.buf.read(8)\n        self.buf.seek(header[\"offset\"])\n\n        im: Image.Image\n        if data[:8] == PngImagePlugin._MAGIC:\n            # png frame\n            im = PngImagePlugin.PngImageFile(self.buf)\n            Image._decompression_bomb_check(im.size)\n        else:\n            # XOR + AND mask bmp frame\n            im = BmpImagePlugin.DibImageFile(self.buf)\n            Image._decompression_bomb_check(im.size)\n\n            # change tile dimension to only encompass XOR image\n            im._size = (im.size[0], int(im.size[1] / 2))\n            d, e, o, a = im.tile[0]\n            im.tile[0] = d, (0, 0) + im.size, o, a\n\n            # figure out where AND mask image starts\n            bpp = header[\"bpp\"]\n            if 32 == bpp:\n                # 32-bit color depth icon image allows semitransparent areas\n                # PIL's DIB format ignores transparency bits, recover them.\n                # The DIB is packed in BGRX byte order where X is the alpha\n                # channel.\n\n                # Back up to start of bmp data\n                self.buf.seek(o)\n                # extract every 4th byte (eg. 3,7,11,15,...)\n                alpha_bytes = self.buf.read(im.size[0] * im.size[1] * 4)[3::4]\n\n                # convert to an 8bpp grayscale image\n                mask = Image.frombuffer(\n                    \"L\",  # 8bpp\n                    im.size,  # (w, h)\n                    alpha_bytes,  # source chars\n                    \"raw\",  # raw decoder\n                    (\"L\", 0, -1),  # 8bpp inverted, unpadded, reversed\n                )\n            else:\n                # get AND image from end of bitmap\n                w = im.size[0]\n                if (w % 32) > 0:\n                    # bitmap row data is aligned to word boundaries\n                    w += 32 - (im.size[0] % 32)\n\n                # the total mask data is\n                # padded row size * height / bits per char\n\n                total_bytes = int((w * im.size[1]) / 8)\n                and_mask_offset = header[\"offset\"] + header[\"size\"] - total_bytes\n\n                self.buf.seek(and_mask_offset)\n                mask_data = self.buf.read(total_bytes)\n\n                # convert raw data to image\n                mask = Image.frombuffer(\n                    \"1\",  # 1 bpp\n                    im.size,  # (w, h)\n                    mask_data,  # source chars\n                    \"raw\",  # raw decoder\n                    (\"1;I\", int(w / 8), -1),  # 1bpp inverted, padded, reversed\n                )\n\n                # now we have two images, im is XOR image and mask is AND image\n\n            # apply mask image as alpha channel\n            im = im.convert(\"RGBA\")\n            im.putalpha(mask)\n\n        return im\n\n\n##\n# Image plugin for Windows Icon files.\n\n\nclass IcoImageFile(ImageFile.ImageFile):\n    \"\"\"\n    PIL read-only image support for Microsoft Windows .ico files.\n\n    By default the largest resolution image in the file will be loaded. This\n    can be changed by altering the 'size' attribute before calling 'load'.\n\n    The info dictionary has a key 'sizes' that is a list of the sizes available\n    in the icon file.\n\n    Handles classic, XP and Vista icon formats.\n\n    When saving, PNG compression is used. Support for this was only added in\n    Windows Vista. If you are unable to view the icon in Windows, convert the\n    image to \"RGBA\" mode before saving.\n\n    This plugin is a refactored version of Win32IconImagePlugin by Bryan Davis\n    <casadebender@gmail.com>.\n    https://code.google.com/archive/p/casadebender/wikis/Win32IconImagePlugin.wiki\n    \"\"\"\n\n    format = \"ICO\"\n    format_description = \"Windows Icon\"\n\n    def _open(self) -> None:\n        self.ico = IcoFile(self.fp)\n        self.info[\"sizes\"] = self.ico.sizes()\n        self.size = self.ico.entry[0][\"dim\"]\n        self.load()\n\n    @property\n    def size(self):\n        return self._size\n\n    @size.setter\n    def size(self, value):\n        if value not in self.info[\"sizes\"]:\n            msg = \"This is not one of the allowed sizes of this image\"\n            raise ValueError(msg)\n        self._size = value\n\n    def load(self):\n        if self.im is not None and self.im.size == self.size:\n            # Already loaded\n            return Image.Image.load(self)\n        im = self.ico.getimage(self.size)\n        # if tile is PNG, it won't really be loaded yet\n        im.load()\n        self.im = im.im\n        self.pyaccess = None\n        self._mode = im.mode\n        if im.palette:\n            self.palette = im.palette\n        if im.size != self.size:\n            warnings.warn(\"Image was not the expected size\")\n\n            index = self.ico.getentryindex(self.size)\n            sizes = list(self.info[\"sizes\"])\n            sizes[index] = im.size\n            self.info[\"sizes\"] = set(sizes)\n\n            self.size = im.size\n\n    def load_seek(self, pos: int) -> None:\n        # Flag the ImageFile.Parser so that it\n        # just does all the decode at the end.\n        pass\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_open(IcoImageFile.format, IcoImageFile, _accept)\nImage.register_save(IcoImageFile.format, _save)\nImage.register_extension(IcoImageFile.format, \".ico\")\n\nImage.register_mime(IcoImageFile.format, \"image/x-icon\")\n", "src/PIL/SunImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Sun image file handling\n#\n# History:\n# 1995-09-10 fl   Created\n# 1996-05-28 fl   Fixed 32-bit alignment\n# 1998-12-29 fl   Import ImagePalette module\n# 2001-12-18 fl   Fixed palette loading (from Jean-Claude Rimbault)\n#\n# Copyright (c) 1997-2001 by Secret Labs AB\n# Copyright (c) 1995-1996 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i32be as i32\n\n\ndef _accept(prefix: bytes) -> bool:\n    return len(prefix) >= 4 and i32(prefix) == 0x59A66A95\n\n\n##\n# Image plugin for Sun raster files.\n\n\nclass SunImageFile(ImageFile.ImageFile):\n    format = \"SUN\"\n    format_description = \"Sun Raster File\"\n\n    def _open(self) -> None:\n        # The Sun Raster file header is 32 bytes in length\n        # and has the following format:\n\n        #     typedef struct _SunRaster\n        #     {\n        #         DWORD MagicNumber;      /* Magic (identification) number */\n        #         DWORD Width;            /* Width of image in pixels */\n        #         DWORD Height;           /* Height of image in pixels */\n        #         DWORD Depth;            /* Number of bits per pixel */\n        #         DWORD Length;           /* Size of image data in bytes */\n        #         DWORD Type;             /* Type of raster file */\n        #         DWORD ColorMapType;     /* Type of color map */\n        #         DWORD ColorMapLength;   /* Size of the color map in bytes */\n        #     } SUNRASTER;\n\n        assert self.fp is not None\n\n        # HEAD\n        s = self.fp.read(32)\n        if not _accept(s):\n            msg = \"not an SUN raster file\"\n            raise SyntaxError(msg)\n\n        offset = 32\n\n        self._size = i32(s, 4), i32(s, 8)\n\n        depth = i32(s, 12)\n        # data_length = i32(s, 16)   # unreliable, ignore.\n        file_type = i32(s, 20)\n        palette_type = i32(s, 24)  # 0: None, 1: RGB, 2: Raw/arbitrary\n        palette_length = i32(s, 28)\n\n        if depth == 1:\n            self._mode, rawmode = \"1\", \"1;I\"\n        elif depth == 4:\n            self._mode, rawmode = \"L\", \"L;4\"\n        elif depth == 8:\n            self._mode = rawmode = \"L\"\n        elif depth == 24:\n            if file_type == 3:\n                self._mode, rawmode = \"RGB\", \"RGB\"\n            else:\n                self._mode, rawmode = \"RGB\", \"BGR\"\n        elif depth == 32:\n            if file_type == 3:\n                self._mode, rawmode = \"RGB\", \"RGBX\"\n            else:\n                self._mode, rawmode = \"RGB\", \"BGRX\"\n        else:\n            msg = \"Unsupported Mode/Bit Depth\"\n            raise SyntaxError(msg)\n\n        if palette_length:\n            if palette_length > 1024:\n                msg = \"Unsupported Color Palette Length\"\n                raise SyntaxError(msg)\n\n            if palette_type != 1:\n                msg = \"Unsupported Palette Type\"\n                raise SyntaxError(msg)\n\n            offset = offset + palette_length\n            self.palette = ImagePalette.raw(\"RGB;L\", self.fp.read(palette_length))\n            if self.mode == \"L\":\n                self._mode = \"P\"\n                rawmode = rawmode.replace(\"L\", \"P\")\n\n        # 16 bit boundaries on stride\n        stride = ((self.size[0] * depth + 15) // 16) * 2\n\n        # file type: Type is the version (or flavor) of the bitmap\n        # file. The following values are typically found in the Type\n        # field:\n        # 0000h Old\n        # 0001h Standard\n        # 0002h Byte-encoded\n        # 0003h RGB format\n        # 0004h TIFF format\n        # 0005h IFF format\n        # FFFFh Experimental\n\n        # Old and standard are the same, except for the length tag.\n        # byte-encoded is run-length-encoded\n        # RGB looks similar to standard, but RGB byte order\n        # TIFF and IFF mean that they were converted from T/IFF\n        # Experimental means that it's something else.\n        # (https://www.fileformat.info/format/sunraster/egff.htm)\n\n        if file_type in (0, 1, 3, 4, 5):\n            self.tile = [(\"raw\", (0, 0) + self.size, offset, (rawmode, stride))]\n        elif file_type == 2:\n            self.tile = [(\"sun_rle\", (0, 0) + self.size, offset, rawmode)]\n        else:\n            msg = \"Unsupported Sun Raster file type\"\n            raise SyntaxError(msg)\n\n\n#\n# registry\n\n\nImage.register_open(SunImageFile.format, SunImageFile, _accept)\n\nImage.register_extension(SunImageFile.format, \".ras\")\n", "src/PIL/TiffImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# TIFF file handling\n#\n# TIFF is a flexible, if somewhat aged, image file format originally\n# defined by Aldus.  Although TIFF supports a wide variety of pixel\n# layouts and compression methods, the name doesn't really stand for\n# \"thousands of incompatible file formats,\" it just feels that way.\n#\n# To read TIFF data from a stream, the stream must be seekable.  For\n# progressive decoding, make sure to use TIFF files where the tag\n# directory is placed first in the file.\n#\n# History:\n# 1995-09-01 fl   Created\n# 1996-05-04 fl   Handle JPEGTABLES tag\n# 1996-05-18 fl   Fixed COLORMAP support\n# 1997-01-05 fl   Fixed PREDICTOR support\n# 1997-08-27 fl   Added support for rational tags (from Perry Stoll)\n# 1998-01-10 fl   Fixed seek/tell (from Jan Blom)\n# 1998-07-15 fl   Use private names for internal variables\n# 1999-06-13 fl   Rewritten for PIL 1.0 (1.0)\n# 2000-10-11 fl   Additional fixes for Python 2.0 (1.1)\n# 2001-04-17 fl   Fixed rewind support (seek to frame 0) (1.2)\n# 2001-05-12 fl   Added write support for more tags (from Greg Couch) (1.3)\n# 2001-12-18 fl   Added workaround for broken Matrox library\n# 2002-01-18 fl   Don't mess up if photometric tag is missing (D. Alan Stewart)\n# 2003-05-19 fl   Check FILLORDER tag\n# 2003-09-26 fl   Added RGBa support\n# 2004-02-24 fl   Added DPI support; fixed rational write support\n# 2005-02-07 fl   Added workaround for broken Corel Draw 10 files\n# 2006-01-09 fl   Added support for float/double tags (from Russell Nelson)\n#\n# Copyright (c) 1997-2006 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-1997 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport itertools\nimport logging\nimport math\nimport os\nimport struct\nimport warnings\nfrom collections.abc import MutableMapping\nfrom fractions import Fraction\nfrom numbers import Number, Rational\nfrom typing import IO, TYPE_CHECKING, Any, Callable, NoReturn\n\nfrom . import ExifTags, Image, ImageFile, ImageOps, ImagePalette, TiffTags\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import o8\nfrom ._deprecate import deprecate\nfrom .TiffTags import TYPES\n\nlogger = logging.getLogger(__name__)\n\n# Set these to true to force use of libtiff for reading or writing.\nREAD_LIBTIFF = False\nWRITE_LIBTIFF = False\nIFD_LEGACY_API = True\nSTRIP_SIZE = 65536\n\nII = b\"II\"  # little-endian (Intel style)\nMM = b\"MM\"  # big-endian (Motorola style)\n\n#\n# --------------------------------------------------------------------\n# Read TIFF files\n\n# a few tag names, just to make the code below a bit more readable\nOSUBFILETYPE = 255\nIMAGEWIDTH = 256\nIMAGELENGTH = 257\nBITSPERSAMPLE = 258\nCOMPRESSION = 259\nPHOTOMETRIC_INTERPRETATION = 262\nFILLORDER = 266\nIMAGEDESCRIPTION = 270\nSTRIPOFFSETS = 273\nSAMPLESPERPIXEL = 277\nROWSPERSTRIP = 278\nSTRIPBYTECOUNTS = 279\nX_RESOLUTION = 282\nY_RESOLUTION = 283\nPLANAR_CONFIGURATION = 284\nRESOLUTION_UNIT = 296\nTRANSFERFUNCTION = 301\nSOFTWARE = 305\nDATE_TIME = 306\nARTIST = 315\nPREDICTOR = 317\nCOLORMAP = 320\nTILEWIDTH = 322\nTILELENGTH = 323\nTILEOFFSETS = 324\nTILEBYTECOUNTS = 325\nSUBIFD = 330\nEXTRASAMPLES = 338\nSAMPLEFORMAT = 339\nJPEGTABLES = 347\nYCBCRSUBSAMPLING = 530\nREFERENCEBLACKWHITE = 532\nCOPYRIGHT = 33432\nIPTC_NAA_CHUNK = 33723  # newsphoto properties\nPHOTOSHOP_CHUNK = 34377  # photoshop properties\nICCPROFILE = 34675\nEXIFIFD = 34665\nXMP = 700\nJPEGQUALITY = 65537  # pseudo-tag by libtiff\n\n# https://github.com/imagej/ImageJA/blob/master/src/main/java/ij/io/TiffDecoder.java\nIMAGEJ_META_DATA_BYTE_COUNTS = 50838\nIMAGEJ_META_DATA = 50839\n\nCOMPRESSION_INFO = {\n    # Compression => pil compression name\n    1: \"raw\",\n    2: \"tiff_ccitt\",\n    3: \"group3\",\n    4: \"group4\",\n    5: \"tiff_lzw\",\n    6: \"tiff_jpeg\",  # obsolete\n    7: \"jpeg\",\n    8: \"tiff_adobe_deflate\",\n    32771: \"tiff_raw_16\",  # 16-bit padding\n    32773: \"packbits\",\n    32809: \"tiff_thunderscan\",\n    32946: \"tiff_deflate\",\n    34676: \"tiff_sgilog\",\n    34677: \"tiff_sgilog24\",\n    34925: \"lzma\",\n    50000: \"zstd\",\n    50001: \"webp\",\n}\n\nCOMPRESSION_INFO_REV = {v: k for k, v in COMPRESSION_INFO.items()}\n\nOPEN_INFO = {\n    # (ByteOrder, PhotoInterpretation, SampleFormat, FillOrder, BitsPerSample,\n    #  ExtraSamples) => mode, rawmode\n    (II, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (MM, 0, (1,), 1, (1,), ()): (\"1\", \"1;I\"),\n    (II, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (MM, 0, (1,), 2, (1,), ()): (\"1\", \"1;IR\"),\n    (II, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (MM, 1, (1,), 1, (1,), ()): (\"1\", \"1\"),\n    (II, 1, (1,), 2, (1,), ()): (\"1\", \"1;R\"),\n    (MM, 1, (1,), 2, (1,), ()): (\"1\", \"1;R\"),\n    (II, 0, (1,), 1, (2,), ()): (\"L\", \"L;2I\"),\n    (MM, 0, (1,), 1, (2,), ()): (\"L\", \"L;2I\"),\n    (II, 0, (1,), 2, (2,), ()): (\"L\", \"L;2IR\"),\n    (MM, 0, (1,), 2, (2,), ()): (\"L\", \"L;2IR\"),\n    (II, 1, (1,), 1, (2,), ()): (\"L\", \"L;2\"),\n    (MM, 1, (1,), 1, (2,), ()): (\"L\", \"L;2\"),\n    (II, 1, (1,), 2, (2,), ()): (\"L\", \"L;2R\"),\n    (MM, 1, (1,), 2, (2,), ()): (\"L\", \"L;2R\"),\n    (II, 0, (1,), 1, (4,), ()): (\"L\", \"L;4I\"),\n    (MM, 0, (1,), 1, (4,), ()): (\"L\", \"L;4I\"),\n    (II, 0, (1,), 2, (4,), ()): (\"L\", \"L;4IR\"),\n    (MM, 0, (1,), 2, (4,), ()): (\"L\", \"L;4IR\"),\n    (II, 1, (1,), 1, (4,), ()): (\"L\", \"L;4\"),\n    (MM, 1, (1,), 1, (4,), ()): (\"L\", \"L;4\"),\n    (II, 1, (1,), 2, (4,), ()): (\"L\", \"L;4R\"),\n    (MM, 1, (1,), 2, (4,), ()): (\"L\", \"L;4R\"),\n    (II, 0, (1,), 1, (8,), ()): (\"L\", \"L;I\"),\n    (MM, 0, (1,), 1, (8,), ()): (\"L\", \"L;I\"),\n    (II, 0, (1,), 2, (8,), ()): (\"L\", \"L;IR\"),\n    (MM, 0, (1,), 2, (8,), ()): (\"L\", \"L;IR\"),\n    (II, 1, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    (MM, 1, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    (II, 1, (2,), 1, (8,), ()): (\"L\", \"L\"),\n    (MM, 1, (2,), 1, (8,), ()): (\"L\", \"L\"),\n    (II, 1, (1,), 2, (8,), ()): (\"L\", \"L;R\"),\n    (MM, 1, (1,), 2, (8,), ()): (\"L\", \"L;R\"),\n    (II, 1, (1,), 1, (12,), ()): (\"I;16\", \"I;12\"),\n    (II, 0, (1,), 1, (16,), ()): (\"I;16\", \"I;16\"),\n    (II, 1, (1,), 1, (16,), ()): (\"I;16\", \"I;16\"),\n    (MM, 1, (1,), 1, (16,), ()): (\"I;16B\", \"I;16B\"),\n    (II, 1, (1,), 2, (16,), ()): (\"I;16\", \"I;16R\"),\n    (II, 1, (2,), 1, (16,), ()): (\"I\", \"I;16S\"),\n    (MM, 1, (2,), 1, (16,), ()): (\"I\", \"I;16BS\"),\n    (II, 0, (3,), 1, (32,), ()): (\"F\", \"F;32F\"),\n    (MM, 0, (3,), 1, (32,), ()): (\"F\", \"F;32BF\"),\n    (II, 1, (1,), 1, (32,), ()): (\"I\", \"I;32N\"),\n    (II, 1, (2,), 1, (32,), ()): (\"I\", \"I;32S\"),\n    (MM, 1, (2,), 1, (32,), ()): (\"I\", \"I;32BS\"),\n    (II, 1, (3,), 1, (32,), ()): (\"F\", \"F;32F\"),\n    (MM, 1, (3,), 1, (32,), ()): (\"F\", \"F;32BF\"),\n    (II, 1, (1,), 1, (8, 8), (2,)): (\"LA\", \"LA\"),\n    (MM, 1, (1,), 1, (8, 8), (2,)): (\"LA\", \"LA\"),\n    (II, 2, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGB\"),\n    (MM, 2, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGB\"),\n    (II, 2, (1,), 2, (8, 8, 8), ()): (\"RGB\", \"RGB;R\"),\n    (MM, 2, (1,), 2, (8, 8, 8), ()): (\"RGB\", \"RGB;R\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), ()): (\"RGBA\", \"RGBA\"),  # missing ExtraSamples\n    (MM, 2, (1,), 1, (8, 8, 8, 8), ()): (\"RGBA\", \"RGBA\"),  # missing ExtraSamples\n    (II, 2, (1,), 1, (8, 8, 8, 8), (0,)): (\"RGBX\", \"RGBX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (0,)): (\"RGBX\", \"RGBX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8), (0, 0)): (\"RGBX\", \"RGBXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8), (0, 0)): (\"RGBX\", \"RGBXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0, 0)): (\"RGBX\", \"RGBXXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0, 0)): (\"RGBX\", \"RGBXXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), (1,)): (\"RGBA\", \"RGBa\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (1,)): (\"RGBA\", \"RGBa\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8), (1, 0)): (\"RGBA\", \"RGBaX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8), (1, 0)): (\"RGBA\", \"RGBaX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (1, 0, 0)): (\"RGBA\", \"RGBaXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (1, 0, 0)): (\"RGBA\", \"RGBaXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), (2,)): (\"RGBA\", \"RGBA\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (2,)): (\"RGBA\", \"RGBA\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8), (2, 0)): (\"RGBA\", \"RGBAX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8), (2, 0)): (\"RGBA\", \"RGBAX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (2, 0, 0)): (\"RGBA\", \"RGBAXX\"),\n    (MM, 2, (1,), 1, (8, 8, 8, 8, 8, 8), (2, 0, 0)): (\"RGBA\", \"RGBAXX\"),\n    (II, 2, (1,), 1, (8, 8, 8, 8), (999,)): (\"RGBA\", \"RGBA\"),  # Corel Draw 10\n    (MM, 2, (1,), 1, (8, 8, 8, 8), (999,)): (\"RGBA\", \"RGBA\"),  # Corel Draw 10\n    (II, 2, (1,), 1, (16, 16, 16), ()): (\"RGB\", \"RGB;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16), ()): (\"RGB\", \"RGB;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), ()): (\"RGBA\", \"RGBA;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), ()): (\"RGBA\", \"RGBA;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), (0,)): (\"RGBX\", \"RGBX;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), (0,)): (\"RGBX\", \"RGBX;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), (1,)): (\"RGBA\", \"RGBa;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), (1,)): (\"RGBA\", \"RGBa;16B\"),\n    (II, 2, (1,), 1, (16, 16, 16, 16), (2,)): (\"RGBA\", \"RGBA;16L\"),\n    (MM, 2, (1,), 1, (16, 16, 16, 16), (2,)): (\"RGBA\", \"RGBA;16B\"),\n    (II, 3, (1,), 1, (1,), ()): (\"P\", \"P;1\"),\n    (MM, 3, (1,), 1, (1,), ()): (\"P\", \"P;1\"),\n    (II, 3, (1,), 2, (1,), ()): (\"P\", \"P;1R\"),\n    (MM, 3, (1,), 2, (1,), ()): (\"P\", \"P;1R\"),\n    (II, 3, (1,), 1, (2,), ()): (\"P\", \"P;2\"),\n    (MM, 3, (1,), 1, (2,), ()): (\"P\", \"P;2\"),\n    (II, 3, (1,), 2, (2,), ()): (\"P\", \"P;2R\"),\n    (MM, 3, (1,), 2, (2,), ()): (\"P\", \"P;2R\"),\n    (II, 3, (1,), 1, (4,), ()): (\"P\", \"P;4\"),\n    (MM, 3, (1,), 1, (4,), ()): (\"P\", \"P;4\"),\n    (II, 3, (1,), 2, (4,), ()): (\"P\", \"P;4R\"),\n    (MM, 3, (1,), 2, (4,), ()): (\"P\", \"P;4R\"),\n    (II, 3, (1,), 1, (8,), ()): (\"P\", \"P\"),\n    (MM, 3, (1,), 1, (8,), ()): (\"P\", \"P\"),\n    (II, 3, (1,), 1, (8, 8), (0,)): (\"P\", \"PX\"),\n    (II, 3, (1,), 1, (8, 8), (2,)): (\"PA\", \"PA\"),\n    (MM, 3, (1,), 1, (8, 8), (2,)): (\"PA\", \"PA\"),\n    (II, 3, (1,), 2, (8,), ()): (\"P\", \"P;R\"),\n    (MM, 3, (1,), 2, (8,), ()): (\"P\", \"P;R\"),\n    (II, 5, (1,), 1, (8, 8, 8, 8), ()): (\"CMYK\", \"CMYK\"),\n    (MM, 5, (1,), 1, (8, 8, 8, 8), ()): (\"CMYK\", \"CMYK\"),\n    (II, 5, (1,), 1, (8, 8, 8, 8, 8), (0,)): (\"CMYK\", \"CMYKX\"),\n    (MM, 5, (1,), 1, (8, 8, 8, 8, 8), (0,)): (\"CMYK\", \"CMYKX\"),\n    (II, 5, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0)): (\"CMYK\", \"CMYKXX\"),\n    (MM, 5, (1,), 1, (8, 8, 8, 8, 8, 8), (0, 0)): (\"CMYK\", \"CMYKXX\"),\n    (II, 5, (1,), 1, (16, 16, 16, 16), ()): (\"CMYK\", \"CMYK;16L\"),\n    (II, 6, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    (MM, 6, (1,), 1, (8,), ()): (\"L\", \"L\"),\n    # JPEG compressed images handled by LibTiff and auto-converted to RGBX\n    # Minimal Baseline TIFF requires YCbCr images to have 3 SamplesPerPixel\n    (II, 6, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGBX\"),\n    (MM, 6, (1,), 1, (8, 8, 8), ()): (\"RGB\", \"RGBX\"),\n    (II, 8, (1,), 1, (8, 8, 8), ()): (\"LAB\", \"LAB\"),\n    (MM, 8, (1,), 1, (8, 8, 8), ()): (\"LAB\", \"LAB\"),\n}\n\nMAX_SAMPLESPERPIXEL = max(len(key_tp[4]) for key_tp in OPEN_INFO)\n\nPREFIXES = [\n    b\"MM\\x00\\x2A\",  # Valid TIFF header with big-endian byte order\n    b\"II\\x2A\\x00\",  # Valid TIFF header with little-endian byte order\n    b\"MM\\x2A\\x00\",  # Invalid TIFF header, assume big-endian\n    b\"II\\x00\\x2A\",  # Invalid TIFF header, assume little-endian\n    b\"MM\\x00\\x2B\",  # BigTIFF with big-endian byte order\n    b\"II\\x2B\\x00\",  # BigTIFF with little-endian byte order\n]\n\nif not getattr(Image.core, \"libtiff_support_custom_tags\", True):\n    deprecate(\"Support for LibTIFF earlier than version 4\", 12)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] in PREFIXES\n\n\ndef _limit_rational(val, max_val):\n    inv = abs(val) > 1\n    n_d = IFDRational(1 / val if inv else val).limit_rational(max_val)\n    return n_d[::-1] if inv else n_d\n\n\ndef _limit_signed_rational(val, max_val, min_val):\n    frac = Fraction(val)\n    n_d = frac.numerator, frac.denominator\n\n    if min(n_d) < min_val:\n        n_d = _limit_rational(val, abs(min_val))\n\n    if max(n_d) > max_val:\n        val = Fraction(*n_d)\n        n_d = _limit_rational(val, max_val)\n\n    return n_d\n\n\n##\n# Wrapper for TIFF IFDs.\n\n_load_dispatch = {}\n_write_dispatch = {}\n\n\ndef _delegate(op):\n    def delegate(self, *args):\n        return getattr(self._val, op)(*args)\n\n    return delegate\n\n\nclass IFDRational(Rational):\n    \"\"\"Implements a rational class where 0/0 is a legal value to match\n    the in the wild use of exif rationals.\n\n    e.g., DigitalZoomRatio - 0.00/0.00  indicates that no digital zoom was used\n    \"\"\"\n\n    \"\"\" If the denominator is 0, store this as a float('nan'), otherwise store\n    as a fractions.Fraction(). Delegate as appropriate\n\n    \"\"\"\n\n    __slots__ = (\"_numerator\", \"_denominator\", \"_val\")\n\n    def __init__(self, value, denominator=1):\n        \"\"\"\n        :param value: either an integer numerator, a\n        float/rational/other number, or an IFDRational\n        :param denominator: Optional integer denominator\n        \"\"\"\n        if isinstance(value, IFDRational):\n            self._numerator = value.numerator\n            self._denominator = value.denominator\n            self._val = value._val\n            return\n\n        if isinstance(value, Fraction):\n            self._numerator = value.numerator\n            self._denominator = value.denominator\n        else:\n            self._numerator = value\n            self._denominator = denominator\n\n        if denominator == 0:\n            self._val = float(\"nan\")\n        elif denominator == 1:\n            self._val = Fraction(value)\n        else:\n            self._val = Fraction(value, denominator)\n\n    @property\n    def numerator(self):\n        return self._numerator\n\n    @property\n    def denominator(self):\n        return self._denominator\n\n    def limit_rational(self, max_denominator):\n        \"\"\"\n\n        :param max_denominator: Integer, the maximum denominator value\n        :returns: Tuple of (numerator, denominator)\n        \"\"\"\n\n        if self.denominator == 0:\n            return self.numerator, self.denominator\n\n        f = self._val.limit_denominator(max_denominator)\n        return f.numerator, f.denominator\n\n    def __repr__(self) -> str:\n        return str(float(self._val))\n\n    def __hash__(self) -> int:\n        return self._val.__hash__()\n\n    def __eq__(self, other: object) -> bool:\n        val = self._val\n        if isinstance(other, IFDRational):\n            other = other._val\n        if isinstance(other, float):\n            val = float(val)\n        return val == other\n\n    def __getstate__(self):\n        return [self._val, self._numerator, self._denominator]\n\n    def __setstate__(self, state):\n        IFDRational.__init__(self, 0)\n        _val, _numerator, _denominator = state\n        self._val = _val\n        self._numerator = _numerator\n        self._denominator = _denominator\n\n    \"\"\" a = ['add','radd', 'sub', 'rsub', 'mul', 'rmul',\n             'truediv', 'rtruediv', 'floordiv', 'rfloordiv',\n             'mod','rmod', 'pow','rpow', 'pos', 'neg',\n             'abs', 'trunc', 'lt', 'gt', 'le', 'ge', 'bool',\n             'ceil', 'floor', 'round']\n        print(\"\\n\".join(\"__%s__ = _delegate('__%s__')\" % (s,s) for s in a))\n        \"\"\"\n\n    __add__ = _delegate(\"__add__\")\n    __radd__ = _delegate(\"__radd__\")\n    __sub__ = _delegate(\"__sub__\")\n    __rsub__ = _delegate(\"__rsub__\")\n    __mul__ = _delegate(\"__mul__\")\n    __rmul__ = _delegate(\"__rmul__\")\n    __truediv__ = _delegate(\"__truediv__\")\n    __rtruediv__ = _delegate(\"__rtruediv__\")\n    __floordiv__ = _delegate(\"__floordiv__\")\n    __rfloordiv__ = _delegate(\"__rfloordiv__\")\n    __mod__ = _delegate(\"__mod__\")\n    __rmod__ = _delegate(\"__rmod__\")\n    __pow__ = _delegate(\"__pow__\")\n    __rpow__ = _delegate(\"__rpow__\")\n    __pos__ = _delegate(\"__pos__\")\n    __neg__ = _delegate(\"__neg__\")\n    __abs__ = _delegate(\"__abs__\")\n    __trunc__ = _delegate(\"__trunc__\")\n    __lt__ = _delegate(\"__lt__\")\n    __gt__ = _delegate(\"__gt__\")\n    __le__ = _delegate(\"__le__\")\n    __ge__ = _delegate(\"__ge__\")\n    __bool__ = _delegate(\"__bool__\")\n    __ceil__ = _delegate(\"__ceil__\")\n    __floor__ = _delegate(\"__floor__\")\n    __round__ = _delegate(\"__round__\")\n    # Python >= 3.11\n    if hasattr(Fraction, \"__int__\"):\n        __int__ = _delegate(\"__int__\")\n\n\ndef _register_loader(idx, size):\n    def decorator(func):\n        from .TiffTags import TYPES\n\n        if func.__name__.startswith(\"load_\"):\n            TYPES[idx] = func.__name__[5:].replace(\"_\", \" \")\n        _load_dispatch[idx] = size, func  # noqa: F821\n        return func\n\n    return decorator\n\n\ndef _register_writer(idx):\n    def decorator(func):\n        _write_dispatch[idx] = func  # noqa: F821\n        return func\n\n    return decorator\n\n\ndef _register_basic(idx_fmt_name):\n    from .TiffTags import TYPES\n\n    idx, fmt, name = idx_fmt_name\n    TYPES[idx] = name\n    size = struct.calcsize(f\"={fmt}\")\n    _load_dispatch[idx] = (  # noqa: F821\n        size,\n        lambda self, data, legacy_api=True: (\n            self._unpack(f\"{len(data) // size}{fmt}\", data)\n        ),\n    )\n    _write_dispatch[idx] = lambda self, *values: (  # noqa: F821\n        b\"\".join(self._pack(fmt, value) for value in values)\n    )\n\n\nif TYPE_CHECKING:\n    _IFDv2Base = MutableMapping[int, Any]\nelse:\n    _IFDv2Base = MutableMapping\n\n\nclass ImageFileDirectory_v2(_IFDv2Base):\n    \"\"\"This class represents a TIFF tag directory.  To speed things up, we\n    don't decode tags unless they're asked for.\n\n    Exposes a dictionary interface of the tags in the directory::\n\n        ifd = ImageFileDirectory_v2()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        'Some Data'\n\n    Individual values are returned as the strings or numbers, sequences are\n    returned as tuples of the values.\n\n    The tiff metadata type of each item is stored in a dictionary of\n    tag types in\n    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v2.tagtype`. The types\n    are read from a tiff file, guessed from the type added, or added\n    manually.\n\n    Data Structures:\n\n        * ``self.tagtype = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: integer corresponding to the data type from\n            :py:data:`.TiffTags.TYPES`\n\n          .. versionadded:: 3.0.0\n\n    'Internal' data structures:\n\n        * ``self._tags_v2 = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: decoded data, as tuple for multiple values\n\n        * ``self._tagdata = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: undecoded byte string from file\n\n        * ``self._tags_v1 = {}``\n\n          * Key: numerical TIFF tag number\n          * Value: decoded data in the v1 format\n\n    Tags will be found in the private attributes ``self._tagdata``, and in\n    ``self._tags_v2`` once decoded.\n\n    ``self.legacy_api`` is a value for internal use, and shouldn't be changed\n    from outside code. In cooperation with\n    :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`, if ``legacy_api``\n    is true, then decoded tags will be populated into both ``_tags_v1`` and\n    ``_tags_v2``. ``_tags_v2`` will be used if this IFD is used in the TIFF\n    save routine. Tags should be read from ``_tags_v1`` if\n    ``legacy_api == true``.\n\n    \"\"\"\n\n    _load_dispatch: dict[int, Callable[[ImageFileDirectory_v2, bytes, bool], Any]] = {}\n    _write_dispatch: dict[int, Callable[..., Any]] = {}\n\n    def __init__(\n        self,\n        ifh: bytes = b\"II\\052\\0\\0\\0\\0\\0\",\n        prefix: bytes | None = None,\n        group: int | None = None,\n    ) -> None:\n        \"\"\"Initialize an ImageFileDirectory.\n\n        To construct an ImageFileDirectory from a real file, pass the 8-byte\n        magic header to the constructor.  To only set the endianness, pass it\n        as the 'prefix' keyword argument.\n\n        :param ifh: One of the accepted magic headers (cf. PREFIXES); also sets\n              endianness.\n        :param prefix: Override the endianness of the file.\n        \"\"\"\n        if not _accept(ifh):\n            msg = f\"not a TIFF file (header {repr(ifh)} not valid)\"\n            raise SyntaxError(msg)\n        self._prefix = prefix if prefix is not None else ifh[:2]\n        if self._prefix == MM:\n            self._endian = \">\"\n        elif self._prefix == II:\n            self._endian = \"<\"\n        else:\n            msg = \"not a TIFF IFD\"\n            raise SyntaxError(msg)\n        self._bigtiff = ifh[2] == 43\n        self.group = group\n        self.tagtype: dict[int, int] = {}\n        \"\"\" Dictionary of tag types \"\"\"\n        self.reset()\n        (self.next,) = (\n            self._unpack(\"Q\", ifh[8:]) if self._bigtiff else self._unpack(\"L\", ifh[4:])\n        )\n        self._legacy_api = False\n\n    prefix = property(lambda self: self._prefix)\n    offset = property(lambda self: self._offset)\n\n    @property\n    def legacy_api(self) -> bool:\n        return self._legacy_api\n\n    @legacy_api.setter\n    def legacy_api(self, value: bool) -> NoReturn:\n        msg = \"Not allowing setting of legacy api\"\n        raise Exception(msg)\n\n    def reset(self) -> None:\n        self._tags_v1: dict[int, Any] = {}  # will remain empty if legacy_api is false\n        self._tags_v2: dict[int, Any] = {}  # main tag storage\n        self._tagdata: dict[int, bytes] = {}\n        self.tagtype = {}  # added 2008-06-05 by Florian Hoech\n        self._next = None\n        self._offset = None\n\n    def __str__(self) -> str:\n        return str(dict(self))\n\n    def named(self):\n        \"\"\"\n        :returns: dict of name|key: value\n\n        Returns the complete tag dictionary, with named tags where possible.\n        \"\"\"\n        return {\n            TiffTags.lookup(code, self.group).name: value\n            for code, value in self.items()\n        }\n\n    def __len__(self) -> int:\n        return len(set(self._tagdata) | set(self._tags_v2))\n\n    def __getitem__(self, tag):\n        if tag not in self._tags_v2:  # unpack on the fly\n            data = self._tagdata[tag]\n            typ = self.tagtype[tag]\n            size, handler = self._load_dispatch[typ]\n            self[tag] = handler(self, data, self.legacy_api)  # check type\n        val = self._tags_v2[tag]\n        if self.legacy_api and not isinstance(val, (tuple, bytes)):\n            val = (val,)\n        return val\n\n    def __contains__(self, tag):\n        return tag in self._tags_v2 or tag in self._tagdata\n\n    def __setitem__(self, tag, value):\n        self._setitem(tag, value, self.legacy_api)\n\n    def _setitem(self, tag, value, legacy_api):\n        basetypes = (Number, bytes, str)\n\n        info = TiffTags.lookup(tag, self.group)\n        values = [value] if isinstance(value, basetypes) else value\n\n        if tag not in self.tagtype:\n            if info.type:\n                self.tagtype[tag] = info.type\n            else:\n                self.tagtype[tag] = TiffTags.UNDEFINED\n                if all(isinstance(v, IFDRational) for v in values):\n                    self.tagtype[tag] = (\n                        TiffTags.RATIONAL\n                        if all(v >= 0 for v in values)\n                        else TiffTags.SIGNED_RATIONAL\n                    )\n                elif all(isinstance(v, int) for v in values):\n                    if all(0 <= v < 2**16 for v in values):\n                        self.tagtype[tag] = TiffTags.SHORT\n                    elif all(-(2**15) < v < 2**15 for v in values):\n                        self.tagtype[tag] = TiffTags.SIGNED_SHORT\n                    else:\n                        self.tagtype[tag] = (\n                            TiffTags.LONG\n                            if all(v >= 0 for v in values)\n                            else TiffTags.SIGNED_LONG\n                        )\n                elif all(isinstance(v, float) for v in values):\n                    self.tagtype[tag] = TiffTags.DOUBLE\n                elif all(isinstance(v, str) for v in values):\n                    self.tagtype[tag] = TiffTags.ASCII\n                elif all(isinstance(v, bytes) for v in values):\n                    self.tagtype[tag] = TiffTags.BYTE\n\n        if self.tagtype[tag] == TiffTags.UNDEFINED:\n            values = [\n                v.encode(\"ascii\", \"replace\") if isinstance(v, str) else v\n                for v in values\n            ]\n        elif self.tagtype[tag] == TiffTags.RATIONAL:\n            values = [float(v) if isinstance(v, int) else v for v in values]\n\n        is_ifd = self.tagtype[tag] == TiffTags.LONG and isinstance(values, dict)\n        if not is_ifd:\n            values = tuple(info.cvt_enum(value) for value in values)\n\n        dest = self._tags_v1 if legacy_api else self._tags_v2\n\n        # Three branches:\n        # Spec'd length == 1, Actual length 1, store as element\n        # Spec'd length == 1, Actual > 1, Warn and truncate. Formerly barfed.\n        # No Spec, Actual length 1, Formerly (<4.2) returned a 1 element tuple.\n        # Don't mess with the legacy api, since it's frozen.\n        if not is_ifd and (\n            (info.length == 1)\n            or self.tagtype[tag] == TiffTags.BYTE\n            or (info.length is None and len(values) == 1 and not legacy_api)\n        ):\n            # Don't mess with the legacy api, since it's frozen.\n            if legacy_api and self.tagtype[tag] in [\n                TiffTags.RATIONAL,\n                TiffTags.SIGNED_RATIONAL,\n            ]:  # rationals\n                values = (values,)\n            try:\n                (dest[tag],) = values\n            except ValueError:\n                # We've got a builtin tag with 1 expected entry\n                warnings.warn(\n                    f\"Metadata Warning, tag {tag} had too many entries: \"\n                    f\"{len(values)}, expected 1\"\n                )\n                dest[tag] = values[0]\n\n        else:\n            # Spec'd length > 1 or undefined\n            # Unspec'd, and length > 1\n            dest[tag] = values\n\n    def __delitem__(self, tag: int) -> None:\n        self._tags_v2.pop(tag, None)\n        self._tags_v1.pop(tag, None)\n        self._tagdata.pop(tag, None)\n\n    def __iter__(self):\n        return iter(set(self._tagdata) | set(self._tags_v2))\n\n    def _unpack(self, fmt, data):\n        return struct.unpack(self._endian + fmt, data)\n\n    def _pack(self, fmt, *values):\n        return struct.pack(self._endian + fmt, *values)\n\n    list(\n        map(\n            _register_basic,\n            [\n                (TiffTags.SHORT, \"H\", \"short\"),\n                (TiffTags.LONG, \"L\", \"long\"),\n                (TiffTags.SIGNED_BYTE, \"b\", \"signed byte\"),\n                (TiffTags.SIGNED_SHORT, \"h\", \"signed short\"),\n                (TiffTags.SIGNED_LONG, \"l\", \"signed long\"),\n                (TiffTags.FLOAT, \"f\", \"float\"),\n                (TiffTags.DOUBLE, \"d\", \"double\"),\n                (TiffTags.IFD, \"L\", \"long\"),\n                (TiffTags.LONG8, \"Q\", \"long8\"),\n            ],\n        )\n    )\n\n    @_register_loader(1, 1)  # Basic type, except for the legacy API.\n    def load_byte(self, data, legacy_api=True):\n        return data\n\n    @_register_writer(1)  # Basic type, except for the legacy API.\n    def write_byte(self, data):\n        if isinstance(data, IFDRational):\n            data = int(data)\n        if isinstance(data, int):\n            data = bytes((data,))\n        return data\n\n    @_register_loader(2, 1)\n    def load_string(self, data, legacy_api=True):\n        if data.endswith(b\"\\0\"):\n            data = data[:-1]\n        return data.decode(\"latin-1\", \"replace\")\n\n    @_register_writer(2)\n    def write_string(self, value):\n        # remerge of https://github.com/python-pillow/Pillow/pull/1416\n        if isinstance(value, int):\n            value = str(value)\n        if not isinstance(value, bytes):\n            value = value.encode(\"ascii\", \"replace\")\n        return value + b\"\\0\"\n\n    @_register_loader(5, 8)\n    def load_rational(self, data, legacy_api=True):\n        vals = self._unpack(f\"{len(data) // 4}L\", data)\n\n        def combine(a, b):\n            return (a, b) if legacy_api else IFDRational(a, b)\n\n        return tuple(combine(num, denom) for num, denom in zip(vals[::2], vals[1::2]))\n\n    @_register_writer(5)\n    def write_rational(self, *values):\n        return b\"\".join(\n            self._pack(\"2L\", *_limit_rational(frac, 2**32 - 1)) for frac in values\n        )\n\n    @_register_loader(7, 1)\n    def load_undefined(self, data, legacy_api=True):\n        return data\n\n    @_register_writer(7)\n    def write_undefined(self, value):\n        if isinstance(value, IFDRational):\n            value = int(value)\n        if isinstance(value, int):\n            value = str(value).encode(\"ascii\", \"replace\")\n        return value\n\n    @_register_loader(10, 8)\n    def load_signed_rational(self, data, legacy_api=True):\n        vals = self._unpack(f\"{len(data) // 4}l\", data)\n\n        def combine(a, b):\n            return (a, b) if legacy_api else IFDRational(a, b)\n\n        return tuple(combine(num, denom) for num, denom in zip(vals[::2], vals[1::2]))\n\n    @_register_writer(10)\n    def write_signed_rational(self, *values):\n        return b\"\".join(\n            self._pack(\"2l\", *_limit_signed_rational(frac, 2**31 - 1, -(2**31)))\n            for frac in values\n        )\n\n    def _ensure_read(self, fp, size):\n        ret = fp.read(size)\n        if len(ret) != size:\n            msg = (\n                \"Corrupt EXIF data.  \"\n                f\"Expecting to read {size} bytes but only got {len(ret)}. \"\n            )\n            raise OSError(msg)\n        return ret\n\n    def load(self, fp):\n        self.reset()\n        self._offset = fp.tell()\n\n        try:\n            tag_count = (\n                self._unpack(\"Q\", self._ensure_read(fp, 8))\n                if self._bigtiff\n                else self._unpack(\"H\", self._ensure_read(fp, 2))\n            )[0]\n            for i in range(tag_count):\n                tag, typ, count, data = (\n                    self._unpack(\"HHQ8s\", self._ensure_read(fp, 20))\n                    if self._bigtiff\n                    else self._unpack(\"HHL4s\", self._ensure_read(fp, 12))\n                )\n\n                tagname = TiffTags.lookup(tag, self.group).name\n                typname = TYPES.get(typ, \"unknown\")\n                msg = f\"tag: {tagname} ({tag}) - type: {typname} ({typ})\"\n\n                try:\n                    unit_size, handler = self._load_dispatch[typ]\n                except KeyError:\n                    logger.debug(\"%s - unsupported type %s\", msg, typ)\n                    continue  # ignore unsupported type\n                size = count * unit_size\n                if size > (8 if self._bigtiff else 4):\n                    here = fp.tell()\n                    (offset,) = self._unpack(\"Q\" if self._bigtiff else \"L\", data)\n                    msg += f\" Tag Location: {here} - Data Location: {offset}\"\n                    fp.seek(offset)\n                    data = ImageFile._safe_read(fp, size)\n                    fp.seek(here)\n                else:\n                    data = data[:size]\n\n                if len(data) != size:\n                    warnings.warn(\n                        \"Possibly corrupt EXIF data.  \"\n                        f\"Expecting to read {size} bytes but only got {len(data)}.\"\n                        f\" Skipping tag {tag}\"\n                    )\n                    logger.debug(msg)\n                    continue\n\n                if not data:\n                    logger.debug(msg)\n                    continue\n\n                self._tagdata[tag] = data\n                self.tagtype[tag] = typ\n\n                msg += \" - value: \" + (\n                    \"<table: %d bytes>\" % size if size > 32 else repr(data)\n                )\n                logger.debug(msg)\n\n            (self.next,) = (\n                self._unpack(\"Q\", self._ensure_read(fp, 8))\n                if self._bigtiff\n                else self._unpack(\"L\", self._ensure_read(fp, 4))\n            )\n        except OSError as msg:\n            warnings.warn(str(msg))\n            return\n\n    def tobytes(self, offset=0):\n        # FIXME What about tagdata?\n        result = self._pack(\"H\", len(self._tags_v2))\n\n        entries = []\n        offset = offset + len(result) + len(self._tags_v2) * 12 + 4\n        stripoffsets = None\n\n        # pass 1: convert tags to binary format\n        # always write tags in ascending order\n        for tag, value in sorted(self._tags_v2.items()):\n            if tag == STRIPOFFSETS:\n                stripoffsets = len(entries)\n            typ = self.tagtype.get(tag)\n            logger.debug(\"Tag %s, Type: %s, Value: %s\", tag, typ, repr(value))\n            is_ifd = typ == TiffTags.LONG and isinstance(value, dict)\n            if is_ifd:\n                if self._endian == \"<\":\n                    ifh = b\"II\\x2A\\x00\\x08\\x00\\x00\\x00\"\n                else:\n                    ifh = b\"MM\\x00\\x2A\\x00\\x00\\x00\\x08\"\n                ifd = ImageFileDirectory_v2(ifh, group=tag)\n                values = self._tags_v2[tag]\n                for ifd_tag, ifd_value in values.items():\n                    ifd[ifd_tag] = ifd_value\n                data = ifd.tobytes(offset)\n            else:\n                values = value if isinstance(value, tuple) else (value,)\n                data = self._write_dispatch[typ](self, *values)\n\n            tagname = TiffTags.lookup(tag, self.group).name\n            typname = \"ifd\" if is_ifd else TYPES.get(typ, \"unknown\")\n            msg = f\"save: {tagname} ({tag}) - type: {typname} ({typ})\"\n            msg += \" - value: \" + (\n                \"<table: %d bytes>\" % len(data) if len(data) >= 16 else str(values)\n            )\n            logger.debug(msg)\n\n            # count is sum of lengths for string and arbitrary data\n            if is_ifd:\n                count = 1\n            elif typ in [TiffTags.BYTE, TiffTags.ASCII, TiffTags.UNDEFINED]:\n                count = len(data)\n            else:\n                count = len(values)\n            # figure out if data fits into the entry\n            if len(data) <= 4:\n                entries.append((tag, typ, count, data.ljust(4, b\"\\0\"), b\"\"))\n            else:\n                entries.append((tag, typ, count, self._pack(\"L\", offset), data))\n                offset += (len(data) + 1) // 2 * 2  # pad to word\n\n        # update strip offset data to point beyond auxiliary data\n        if stripoffsets is not None:\n            tag, typ, count, value, data = entries[stripoffsets]\n            if data:\n                msg = \"multistrip support not yet implemented\"\n                raise NotImplementedError(msg)\n            value = self._pack(\"L\", self._unpack(\"L\", value)[0] + offset)\n            entries[stripoffsets] = tag, typ, count, value, data\n\n        # pass 2: write entries to file\n        for tag, typ, count, value, data in entries:\n            logger.debug(\"%s %s %s %s %s\", tag, typ, count, repr(value), repr(data))\n            result += self._pack(\"HHL4s\", tag, typ, count, value)\n\n        # -- overwrite here for multi-page --\n        result += b\"\\0\\0\\0\\0\"  # end of entries\n\n        # pass 3: write auxiliary data to file\n        for tag, typ, count, value, data in entries:\n            result += data\n            if len(data) & 1:\n                result += b\"\\0\"\n\n        return result\n\n    def save(self, fp):\n        if fp.tell() == 0:  # skip TIFF header on subsequent pages\n            # tiff header -- PIL always starts the first IFD at offset 8\n            fp.write(self._prefix + self._pack(\"HL\", 42, 8))\n\n        offset = fp.tell()\n        result = self.tobytes(offset)\n        fp.write(result)\n        return offset + len(result)\n\n\nImageFileDirectory_v2._load_dispatch = _load_dispatch\nImageFileDirectory_v2._write_dispatch = _write_dispatch\nfor idx, name in TYPES.items():\n    name = name.replace(\" \", \"_\")\n    setattr(ImageFileDirectory_v2, f\"load_{name}\", _load_dispatch[idx][1])\n    setattr(ImageFileDirectory_v2, f\"write_{name}\", _write_dispatch[idx])\ndel _load_dispatch, _write_dispatch, idx, name\n\n\n# Legacy ImageFileDirectory support.\nclass ImageFileDirectory_v1(ImageFileDirectory_v2):\n    \"\"\"This class represents the **legacy** interface to a TIFF tag directory.\n\n    Exposes a dictionary interface of the tags in the directory::\n\n        ifd = ImageFileDirectory_v1()\n        ifd[key] = 'Some Data'\n        ifd.tagtype[key] = TiffTags.ASCII\n        print(ifd[key])\n        ('Some Data',)\n\n    Also contains a dictionary of tag types as read from the tiff image file,\n    :attr:`~PIL.TiffImagePlugin.ImageFileDirectory_v1.tagtype`.\n\n    Values are returned as a tuple.\n\n    ..  deprecated:: 3.0.0\n    \"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self._legacy_api = True\n\n    tags = property(lambda self: self._tags_v1)\n    tagdata = property(lambda self: self._tagdata)\n\n    # defined in ImageFileDirectory_v2\n    tagtype: dict[int, int]\n    \"\"\"Dictionary of tag types\"\"\"\n\n    @classmethod\n    def from_v2(cls, original):\n        \"\"\"Returns an\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`\n        instance with the same data as is contained in the original\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`\n        instance.\n\n        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`\n\n        \"\"\"\n\n        ifd = cls(prefix=original.prefix)\n        ifd._tagdata = original._tagdata\n        ifd.tagtype = original.tagtype\n        ifd.next = original.next  # an indicator for multipage tiffs\n        return ifd\n\n    def to_v2(self) -> ImageFileDirectory_v2:\n        \"\"\"Returns an\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`\n        instance with the same data as is contained in the original\n        :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v1`\n        instance.\n\n        :returns: :py:class:`~PIL.TiffImagePlugin.ImageFileDirectory_v2`\n\n        \"\"\"\n\n        ifd = ImageFileDirectory_v2(prefix=self.prefix)\n        ifd._tagdata = dict(self._tagdata)\n        ifd.tagtype = dict(self.tagtype)\n        ifd._tags_v2 = dict(self._tags_v2)\n        return ifd\n\n    def __contains__(self, tag):\n        return tag in self._tags_v1 or tag in self._tagdata\n\n    def __len__(self) -> int:\n        return len(set(self._tagdata) | set(self._tags_v1))\n\n    def __iter__(self):\n        return iter(set(self._tagdata) | set(self._tags_v1))\n\n    def __setitem__(self, tag, value):\n        for legacy_api in (False, True):\n            self._setitem(tag, value, legacy_api)\n\n    def __getitem__(self, tag):\n        if tag not in self._tags_v1:  # unpack on the fly\n            data = self._tagdata[tag]\n            typ = self.tagtype[tag]\n            size, handler = self._load_dispatch[typ]\n            for legacy in (False, True):\n                self._setitem(tag, handler(self, data, legacy), legacy)\n        val = self._tags_v1[tag]\n        if not isinstance(val, (tuple, bytes)):\n            val = (val,)\n        return val\n\n\n# undone -- switch this pointer when IFD_LEGACY_API == False\nImageFileDirectory = ImageFileDirectory_v1\n\n\n##\n# Image plugin for TIFF files.\n\n\nclass TiffImageFile(ImageFile.ImageFile):\n    format = \"TIFF\"\n    format_description = \"Adobe TIFF\"\n    _close_exclusive_fp_after_loading = False\n\n    def __init__(self, fp=None, filename=None):\n        self.tag_v2 = None\n        \"\"\" Image file directory (tag dictionary) \"\"\"\n\n        self.tag = None\n        \"\"\" Legacy tag entries \"\"\"\n\n        super().__init__(fp, filename)\n\n    def _open(self) -> None:\n        \"\"\"Open the first image in a TIFF file\"\"\"\n\n        # Header\n        ifh = self.fp.read(8)\n        if ifh[2] == 43:\n            ifh += self.fp.read(8)\n\n        self.tag_v2 = ImageFileDirectory_v2(ifh)\n\n        # legacy IFD entries will be filled in later\n        self.ifd = None\n\n        # setup frame pointers\n        self.__first = self.__next = self.tag_v2.next\n        self.__frame = -1\n        self._fp = self.fp\n        self._frame_pos: list[int] = []\n        self._n_frames: int | None = None\n\n        logger.debug(\"*** TiffImageFile._open ***\")\n        logger.debug(\"- __first: %s\", self.__first)\n        logger.debug(\"- ifh: %s\", repr(ifh))  # Use repr to avoid str(bytes)\n\n        # and load the first frame\n        self._seek(0)\n\n    @property\n    def n_frames(self):\n        if self._n_frames is None:\n            current = self.tell()\n            self._seek(len(self._frame_pos))\n            while self._n_frames is None:\n                self._seek(self.tell() + 1)\n            self.seek(current)\n        return self._n_frames\n\n    def seek(self, frame: int) -> None:\n        \"\"\"Select a given frame as current image\"\"\"\n        if not self._seek_check(frame):\n            return\n        self._seek(frame)\n        # Create a new core image object on second and\n        # subsequent frames in the image. Image may be\n        # different size/mode.\n        Image._decompression_bomb_check(self.size)\n        self.im = Image.core.new(self.mode, self.size)\n\n    def _seek(self, frame: int) -> None:\n        self.fp = self._fp\n\n        # reset buffered io handle in case fp\n        # was passed to libtiff, invalidating the buffer\n        self.fp.tell()\n\n        while len(self._frame_pos) <= frame:\n            if not self.__next:\n                msg = \"no more images in TIFF file\"\n                raise EOFError(msg)\n            logger.debug(\n                \"Seeking to frame %s, on frame %s, __next %s, location: %s\",\n                frame,\n                self.__frame,\n                self.__next,\n                self.fp.tell(),\n            )\n            if self.__next >= 2**63:\n                msg = \"Unable to seek to frame\"\n                raise ValueError(msg)\n            self.fp.seek(self.__next)\n            self._frame_pos.append(self.__next)\n            logger.debug(\"Loading tags, location: %s\", self.fp.tell())\n            self.tag_v2.load(self.fp)\n            if self.tag_v2.next in self._frame_pos:\n                # This IFD has already been processed\n                # Declare this to be the end of the image\n                self.__next = 0\n            else:\n                self.__next = self.tag_v2.next\n            if self.__next == 0:\n                self._n_frames = frame + 1\n            if len(self._frame_pos) == 1:\n                self.is_animated = self.__next != 0\n            self.__frame += 1\n        self.fp.seek(self._frame_pos[frame])\n        self.tag_v2.load(self.fp)\n        if XMP in self.tag_v2:\n            self.info[\"xmp\"] = self.tag_v2[XMP]\n        elif \"xmp\" in self.info:\n            del self.info[\"xmp\"]\n        self._reload_exif()\n        # fill the legacy tag/ifd entries\n        self.tag = self.ifd = ImageFileDirectory_v1.from_v2(self.tag_v2)\n        self.__frame = frame\n        self._setup()\n\n    def tell(self) -> int:\n        \"\"\"Return the current frame number\"\"\"\n        return self.__frame\n\n    def get_photoshop_blocks(self):\n        \"\"\"\n        Returns a dictionary of Photoshop \"Image Resource Blocks\".\n        The keys are the image resource ID. For more information, see\n        https://www.adobe.com/devnet-apps/photoshop/fileformatashtml/#50577409_pgfId-1037727\n\n        :returns: Photoshop \"Image Resource Blocks\" in a dictionary.\n        \"\"\"\n        blocks = {}\n        val = self.tag_v2.get(ExifTags.Base.ImageResources)\n        if val:\n            while val[:4] == b\"8BIM\":\n                id = i16(val[4:6])\n                n = math.ceil((val[6] + 1) / 2) * 2\n                size = i32(val[6 + n : 10 + n])\n                data = val[10 + n : 10 + n + size]\n                blocks[id] = {\"data\": data}\n\n                val = val[math.ceil((10 + n + size) / 2) * 2 :]\n        return blocks\n\n    def load(self):\n        if self.tile and self.use_load_libtiff:\n            return self._load_libtiff()\n        return super().load()\n\n    def load_end(self) -> None:\n        # allow closing if we're on the first frame, there's no next\n        # This is the ImageFile.load path only, libtiff specific below.\n        if not self.is_animated:\n            self._close_exclusive_fp_after_loading = True\n\n            # reset buffered io handle in case fp\n            # was passed to libtiff, invalidating the buffer\n            self.fp.tell()\n\n            # load IFD data from fp before it is closed\n            exif = self.getexif()\n            for key in TiffTags.TAGS_V2_GROUPS:\n                if key not in exif:\n                    continue\n                exif.get_ifd(key)\n\n        ImageOps.exif_transpose(self, in_place=True)\n        if ExifTags.Base.Orientation in self.tag_v2:\n            del self.tag_v2[ExifTags.Base.Orientation]\n\n    def _load_libtiff(self):\n        \"\"\"Overload method triggered when we detect a compressed tiff\n        Calls out to libtiff\"\"\"\n\n        Image.Image.load(self)\n\n        self.load_prepare()\n\n        if not len(self.tile) == 1:\n            msg = \"Not exactly one tile\"\n            raise OSError(msg)\n\n        # (self._compression, (extents tuple),\n        #   0, (rawmode, self._compression, fp))\n        extents = self.tile[0][1]\n        args = list(self.tile[0][3])\n\n        # To be nice on memory footprint, if there's a\n        # file descriptor, use that instead of reading\n        # into a string in python.\n        try:\n            fp = hasattr(self.fp, \"fileno\") and self.fp.fileno()\n            # flush the file descriptor, prevents error on pypy 2.4+\n            # should also eliminate the need for fp.tell\n            # in _seek\n            if hasattr(self.fp, \"flush\"):\n                self.fp.flush()\n        except OSError:\n            # io.BytesIO have a fileno, but returns an OSError if\n            # it doesn't use a file descriptor.\n            fp = False\n\n        if fp:\n            args[2] = fp\n\n        decoder = Image._getdecoder(\n            self.mode, \"libtiff\", tuple(args), self.decoderconfig\n        )\n        try:\n            decoder.setimage(self.im, extents)\n        except ValueError as e:\n            msg = \"Couldn't set the image\"\n            raise OSError(msg) from e\n\n        close_self_fp = self._exclusive_fp and not self.is_animated\n        if hasattr(self.fp, \"getvalue\"):\n            # We've got a stringio like thing passed in. Yay for all in memory.\n            # The decoder needs the entire file in one shot, so there's not\n            # a lot we can do here other than give it the entire file.\n            # unless we could do something like get the address of the\n            # underlying string for stringio.\n            #\n            # Rearranging for supporting byteio items, since they have a fileno\n            # that returns an OSError if there's no underlying fp. Easier to\n            # deal with here by reordering.\n            logger.debug(\"have getvalue. just sending in a string from getvalue\")\n            n, err = decoder.decode(self.fp.getvalue())\n        elif fp:\n            # we've got a actual file on disk, pass in the fp.\n            logger.debug(\"have fileno, calling fileno version of the decoder.\")\n            if not close_self_fp:\n                self.fp.seek(0)\n            # 4 bytes, otherwise the trace might error out\n            n, err = decoder.decode(b\"fpfp\")\n        else:\n            # we have something else.\n            logger.debug(\"don't have fileno or getvalue. just reading\")\n            self.fp.seek(0)\n            # UNDONE -- so much for that buffer size thing.\n            n, err = decoder.decode(self.fp.read())\n\n        self.tile = []\n        self.readonly = 0\n\n        self.load_end()\n\n        if close_self_fp:\n            self.fp.close()\n            self.fp = None  # might be shared\n\n        if err < 0:\n            raise OSError(err)\n\n        return Image.Image.load(self)\n\n    def _setup(self):\n        \"\"\"Setup this image object based on current tags\"\"\"\n\n        if 0xBC01 in self.tag_v2:\n            msg = \"Windows Media Photo files not yet supported\"\n            raise OSError(msg)\n\n        # extract relevant tags\n        self._compression = COMPRESSION_INFO[self.tag_v2.get(COMPRESSION, 1)]\n        self._planar_configuration = self.tag_v2.get(PLANAR_CONFIGURATION, 1)\n\n        # photometric is a required tag, but not everyone is reading\n        # the specification\n        photo = self.tag_v2.get(PHOTOMETRIC_INTERPRETATION, 0)\n\n        # old style jpeg compression images most certainly are YCbCr\n        if self._compression == \"tiff_jpeg\":\n            photo = 6\n\n        fillorder = self.tag_v2.get(FILLORDER, 1)\n\n        logger.debug(\"*** Summary ***\")\n        logger.debug(\"- compression: %s\", self._compression)\n        logger.debug(\"- photometric_interpretation: %s\", photo)\n        logger.debug(\"- planar_configuration: %s\", self._planar_configuration)\n        logger.debug(\"- fill_order: %s\", fillorder)\n        logger.debug(\"- YCbCr subsampling: %s\", self.tag.get(YCBCRSUBSAMPLING))\n\n        # size\n        xsize = int(self.tag_v2.get(IMAGEWIDTH))\n        ysize = int(self.tag_v2.get(IMAGELENGTH))\n        self._size = xsize, ysize\n\n        logger.debug(\"- size: %s\", self.size)\n\n        sample_format = self.tag_v2.get(SAMPLEFORMAT, (1,))\n        if len(sample_format) > 1 and max(sample_format) == min(sample_format) == 1:\n            # SAMPLEFORMAT is properly per band, so an RGB image will\n            # be (1,1,1).  But, we don't support per band pixel types,\n            # and anything more than one band is a uint8. So, just\n            # take the first element. Revisit this if adding support\n            # for more exotic images.\n            sample_format = (1,)\n\n        bps_tuple = self.tag_v2.get(BITSPERSAMPLE, (1,))\n        extra_tuple = self.tag_v2.get(EXTRASAMPLES, ())\n        if photo in (2, 6, 8):  # RGB, YCbCr, LAB\n            bps_count = 3\n        elif photo == 5:  # CMYK\n            bps_count = 4\n        else:\n            bps_count = 1\n        bps_count += len(extra_tuple)\n        bps_actual_count = len(bps_tuple)\n        samples_per_pixel = self.tag_v2.get(\n            SAMPLESPERPIXEL,\n            3 if self._compression == \"tiff_jpeg\" and photo in (2, 6) else 1,\n        )\n\n        if samples_per_pixel > MAX_SAMPLESPERPIXEL:\n            # DOS check, samples_per_pixel can be a Long, and we extend the tuple below\n            logger.error(\n                \"More samples per pixel than can be decoded: %s\", samples_per_pixel\n            )\n            msg = \"Invalid value for samples per pixel\"\n            raise SyntaxError(msg)\n\n        if samples_per_pixel < bps_actual_count:\n            # If a file has more values in bps_tuple than expected,\n            # remove the excess.\n            bps_tuple = bps_tuple[:samples_per_pixel]\n        elif samples_per_pixel > bps_actual_count and bps_actual_count == 1:\n            # If a file has only one value in bps_tuple, when it should have more,\n            # presume it is the same number of bits for all of the samples.\n            bps_tuple = bps_tuple * samples_per_pixel\n\n        if len(bps_tuple) != samples_per_pixel:\n            msg = \"unknown data organization\"\n            raise SyntaxError(msg)\n\n        # mode: check photometric interpretation and bits per pixel\n        key = (\n            self.tag_v2.prefix,\n            photo,\n            sample_format,\n            fillorder,\n            bps_tuple,\n            extra_tuple,\n        )\n        logger.debug(\"format key: %s\", key)\n        try:\n            self._mode, rawmode = OPEN_INFO[key]\n        except KeyError as e:\n            logger.debug(\"- unsupported format\")\n            msg = \"unknown pixel mode\"\n            raise SyntaxError(msg) from e\n\n        logger.debug(\"- raw mode: %s\", rawmode)\n        logger.debug(\"- pil mode: %s\", self.mode)\n\n        self.info[\"compression\"] = self._compression\n\n        xres = self.tag_v2.get(X_RESOLUTION, 1)\n        yres = self.tag_v2.get(Y_RESOLUTION, 1)\n\n        if xres and yres:\n            resunit = self.tag_v2.get(RESOLUTION_UNIT)\n            if resunit == 2:  # dots per inch\n                self.info[\"dpi\"] = (xres, yres)\n            elif resunit == 3:  # dots per centimeter. convert to dpi\n                self.info[\"dpi\"] = (xres * 2.54, yres * 2.54)\n            elif resunit is None:  # used to default to 1, but now 2)\n                self.info[\"dpi\"] = (xres, yres)\n                # For backward compatibility,\n                # we also preserve the old behavior\n                self.info[\"resolution\"] = xres, yres\n            else:  # No absolute unit of measurement\n                self.info[\"resolution\"] = xres, yres\n\n        # build tile descriptors\n        x = y = layer = 0\n        self.tile = []\n        self.use_load_libtiff = READ_LIBTIFF or self._compression != \"raw\"\n        if self.use_load_libtiff:\n            # Decoder expects entire file as one tile.\n            # There's a buffer size limit in load (64k)\n            # so large g4 images will fail if we use that\n            # function.\n            #\n            # Setup the one tile for the whole image, then\n            # use the _load_libtiff function.\n\n            # libtiff handles the fillmode for us, so 1;IR should\n            # actually be 1;I. Including the R double reverses the\n            # bits, so stripes of the image are reversed.  See\n            # https://github.com/python-pillow/Pillow/issues/279\n            if fillorder == 2:\n                # Replace fillorder with fillorder=1\n                key = key[:3] + (1,) + key[4:]\n                logger.debug(\"format key: %s\", key)\n                # this should always work, since all the\n                # fillorder==2 modes have a corresponding\n                # fillorder=1 mode\n                self._mode, rawmode = OPEN_INFO[key]\n            # libtiff always returns the bytes in native order.\n            # we're expecting image byte order. So, if the rawmode\n            # contains I;16, we need to convert from native to image\n            # byte order.\n            if rawmode == \"I;16\":\n                rawmode = \"I;16N\"\n            if \";16B\" in rawmode:\n                rawmode = rawmode.replace(\";16B\", \";16N\")\n            if \";16L\" in rawmode:\n                rawmode = rawmode.replace(\";16L\", \";16N\")\n\n            # YCbCr images with new jpeg compression with pixels in one plane\n            # unpacked straight into RGB values\n            if (\n                photo == 6\n                and self._compression == \"jpeg\"\n                and self._planar_configuration == 1\n            ):\n                rawmode = \"RGB\"\n\n            # Offset in the tile tuple is 0, we go from 0,0 to\n            # w,h, and we only do this once -- eds\n            a = (rawmode, self._compression, False, self.tag_v2.offset)\n            self.tile.append((\"libtiff\", (0, 0, xsize, ysize), 0, a))\n\n        elif STRIPOFFSETS in self.tag_v2 or TILEOFFSETS in self.tag_v2:\n            # striped image\n            if STRIPOFFSETS in self.tag_v2:\n                offsets = self.tag_v2[STRIPOFFSETS]\n                h = self.tag_v2.get(ROWSPERSTRIP, ysize)\n                w = self.size[0]\n            else:\n                # tiled image\n                offsets = self.tag_v2[TILEOFFSETS]\n                w = self.tag_v2.get(TILEWIDTH)\n                h = self.tag_v2.get(TILELENGTH)\n\n            for offset in offsets:\n                if x + w > xsize:\n                    stride = w * sum(bps_tuple) / 8  # bytes per line\n                else:\n                    stride = 0\n\n                tile_rawmode = rawmode\n                if self._planar_configuration == 2:\n                    # each band on it's own layer\n                    tile_rawmode = rawmode[layer]\n                    # adjust stride width accordingly\n                    stride /= bps_count\n\n                a = (tile_rawmode, int(stride), 1)\n                self.tile.append(\n                    (\n                        self._compression,\n                        (x, y, min(x + w, xsize), min(y + h, ysize)),\n                        offset,\n                        a,\n                    )\n                )\n                x = x + w\n                if x >= self.size[0]:\n                    x, y = 0, y + h\n                    if y >= self.size[1]:\n                        x = y = 0\n                        layer += 1\n        else:\n            logger.debug(\"- unsupported data organization\")\n            msg = \"unknown data organization\"\n            raise SyntaxError(msg)\n\n        # Fix up info.\n        if ICCPROFILE in self.tag_v2:\n            self.info[\"icc_profile\"] = self.tag_v2[ICCPROFILE]\n\n        # fixup palette descriptor\n\n        if self.mode in [\"P\", \"PA\"]:\n            palette = [o8(b // 256) for b in self.tag_v2[COLORMAP]]\n            self.palette = ImagePalette.raw(\"RGB;L\", b\"\".join(palette))\n\n\n#\n# --------------------------------------------------------------------\n# Write TIFF files\n\n# little endian is default except for image modes with\n# explicit big endian byte-order\n\nSAVE_INFO = {\n    # mode => rawmode, byteorder, photometrics,\n    #           sampleformat, bitspersample, extra\n    \"1\": (\"1\", II, 1, 1, (1,), None),\n    \"L\": (\"L\", II, 1, 1, (8,), None),\n    \"LA\": (\"LA\", II, 1, 1, (8, 8), 2),\n    \"P\": (\"P\", II, 3, 1, (8,), None),\n    \"PA\": (\"PA\", II, 3, 1, (8, 8), 2),\n    \"I\": (\"I;32S\", II, 1, 2, (32,), None),\n    \"I;16\": (\"I;16\", II, 1, 1, (16,), None),\n    \"I;16S\": (\"I;16S\", II, 1, 2, (16,), None),\n    \"F\": (\"F;32F\", II, 1, 3, (32,), None),\n    \"RGB\": (\"RGB\", II, 2, 1, (8, 8, 8), None),\n    \"RGBX\": (\"RGBX\", II, 2, 1, (8, 8, 8, 8), 0),\n    \"RGBA\": (\"RGBA\", II, 2, 1, (8, 8, 8, 8), 2),\n    \"CMYK\": (\"CMYK\", II, 5, 1, (8, 8, 8, 8), None),\n    \"YCbCr\": (\"YCbCr\", II, 6, 1, (8, 8, 8), None),\n    \"LAB\": (\"LAB\", II, 8, 1, (8, 8, 8), None),\n    \"I;32BS\": (\"I;32BS\", MM, 1, 2, (32,), None),\n    \"I;16B\": (\"I;16B\", MM, 1, 1, (16,), None),\n    \"I;16BS\": (\"I;16BS\", MM, 1, 2, (16,), None),\n    \"F;32BF\": (\"F;32BF\", MM, 1, 3, (32,), None),\n}\n\n\ndef _save(im, fp, filename):\n    try:\n        rawmode, prefix, photo, format, bits, extra = SAVE_INFO[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as TIFF\"\n        raise OSError(msg) from e\n\n    ifd = ImageFileDirectory_v2(prefix=prefix)\n\n    encoderinfo = im.encoderinfo\n    encoderconfig = im.encoderconfig\n    try:\n        compression = encoderinfo[\"compression\"]\n    except KeyError:\n        compression = im.info.get(\"compression\")\n        if isinstance(compression, int):\n            # compression value may be from BMP. Ignore it\n            compression = None\n    if compression is None:\n        compression = \"raw\"\n    elif compression == \"tiff_jpeg\":\n        # OJPEG is obsolete, so use new-style JPEG compression instead\n        compression = \"jpeg\"\n    elif compression == \"tiff_deflate\":\n        compression = \"tiff_adobe_deflate\"\n\n    libtiff = WRITE_LIBTIFF or compression != \"raw\"\n\n    # required for color libtiff images\n    ifd[PLANAR_CONFIGURATION] = 1\n\n    ifd[IMAGEWIDTH] = im.size[0]\n    ifd[IMAGELENGTH] = im.size[1]\n\n    # write any arbitrary tags passed in as an ImageFileDirectory\n    if \"tiffinfo\" in encoderinfo:\n        info = encoderinfo[\"tiffinfo\"]\n    elif \"exif\" in encoderinfo:\n        info = encoderinfo[\"exif\"]\n        if isinstance(info, bytes):\n            exif = Image.Exif()\n            exif.load(info)\n            info = exif\n    else:\n        info = {}\n    logger.debug(\"Tiffinfo Keys: %s\", list(info))\n    if isinstance(info, ImageFileDirectory_v1):\n        info = info.to_v2()\n    for key in info:\n        if isinstance(info, Image.Exif) and key in TiffTags.TAGS_V2_GROUPS:\n            ifd[key] = info.get_ifd(key)\n        else:\n            ifd[key] = info.get(key)\n        try:\n            ifd.tagtype[key] = info.tagtype[key]\n        except Exception:\n            pass  # might not be an IFD. Might not have populated type\n\n    # additions written by Greg Couch, gregc@cgl.ucsf.edu\n    # inspired by image-sig posting from Kevin Cazabon, kcazabon@home.com\n    if hasattr(im, \"tag_v2\"):\n        # preserve tags from original TIFF image file\n        for key in (\n            RESOLUTION_UNIT,\n            X_RESOLUTION,\n            Y_RESOLUTION,\n            IPTC_NAA_CHUNK,\n            PHOTOSHOP_CHUNK,\n            XMP,\n        ):\n            if key in im.tag_v2:\n                ifd[key] = im.tag_v2[key]\n                ifd.tagtype[key] = im.tag_v2.tagtype[key]\n\n    # preserve ICC profile (should also work when saving other formats\n    # which support profiles as TIFF) -- 2008-06-06 Florian Hoech\n    icc = encoderinfo.get(\"icc_profile\", im.info.get(\"icc_profile\"))\n    if icc:\n        ifd[ICCPROFILE] = icc\n\n    for key, name in [\n        (IMAGEDESCRIPTION, \"description\"),\n        (X_RESOLUTION, \"resolution\"),\n        (Y_RESOLUTION, \"resolution\"),\n        (X_RESOLUTION, \"x_resolution\"),\n        (Y_RESOLUTION, \"y_resolution\"),\n        (RESOLUTION_UNIT, \"resolution_unit\"),\n        (SOFTWARE, \"software\"),\n        (DATE_TIME, \"date_time\"),\n        (ARTIST, \"artist\"),\n        (COPYRIGHT, \"copyright\"),\n    ]:\n        if name in encoderinfo:\n            ifd[key] = encoderinfo[name]\n\n    dpi = encoderinfo.get(\"dpi\")\n    if dpi:\n        ifd[RESOLUTION_UNIT] = 2\n        ifd[X_RESOLUTION] = dpi[0]\n        ifd[Y_RESOLUTION] = dpi[1]\n\n    if bits != (1,):\n        ifd[BITSPERSAMPLE] = bits\n        if len(bits) != 1:\n            ifd[SAMPLESPERPIXEL] = len(bits)\n    if extra is not None:\n        ifd[EXTRASAMPLES] = extra\n    if format != 1:\n        ifd[SAMPLEFORMAT] = format\n\n    if PHOTOMETRIC_INTERPRETATION not in ifd:\n        ifd[PHOTOMETRIC_INTERPRETATION] = photo\n    elif im.mode in (\"1\", \"L\") and ifd[PHOTOMETRIC_INTERPRETATION] == 0:\n        if im.mode == \"1\":\n            inverted_im = im.copy()\n            px = inverted_im.load()\n            for y in range(inverted_im.height):\n                for x in range(inverted_im.width):\n                    px[x, y] = 0 if px[x, y] == 255 else 255\n            im = inverted_im\n        else:\n            im = ImageOps.invert(im)\n\n    if im.mode in [\"P\", \"PA\"]:\n        lut = im.im.getpalette(\"RGB\", \"RGB;L\")\n        colormap = []\n        colors = len(lut) // 3\n        for i in range(3):\n            colormap += [v * 256 for v in lut[colors * i : colors * (i + 1)]]\n            colormap += [0] * (256 - colors)\n        ifd[COLORMAP] = colormap\n    # data orientation\n    w, h = ifd[IMAGEWIDTH], ifd[IMAGELENGTH]\n    stride = len(bits) * ((w * bits[0] + 7) // 8)\n    if ROWSPERSTRIP not in ifd:\n        # aim for given strip size (64 KB by default) when using libtiff writer\n        if libtiff:\n            im_strip_size = encoderinfo.get(\"strip_size\", STRIP_SIZE)\n            rows_per_strip = 1 if stride == 0 else min(im_strip_size // stride, h)\n            # JPEG encoder expects multiple of 8 rows\n            if compression == \"jpeg\":\n                rows_per_strip = min(((rows_per_strip + 7) // 8) * 8, h)\n        else:\n            rows_per_strip = h\n        if rows_per_strip == 0:\n            rows_per_strip = 1\n        ifd[ROWSPERSTRIP] = rows_per_strip\n    strip_byte_counts = 1 if stride == 0 else stride * ifd[ROWSPERSTRIP]\n    strips_per_image = (h + ifd[ROWSPERSTRIP] - 1) // ifd[ROWSPERSTRIP]\n    if strip_byte_counts >= 2**16:\n        ifd.tagtype[STRIPBYTECOUNTS] = TiffTags.LONG\n    ifd[STRIPBYTECOUNTS] = (strip_byte_counts,) * (strips_per_image - 1) + (\n        stride * h - strip_byte_counts * (strips_per_image - 1),\n    )\n    ifd[STRIPOFFSETS] = tuple(\n        range(0, strip_byte_counts * strips_per_image, strip_byte_counts)\n    )  # this is adjusted by IFD writer\n    # no compression by default:\n    ifd[COMPRESSION] = COMPRESSION_INFO_REV.get(compression, 1)\n\n    if im.mode == \"YCbCr\":\n        for tag, value in {\n            YCBCRSUBSAMPLING: (1, 1),\n            REFERENCEBLACKWHITE: (0, 255, 128, 255, 128, 255),\n        }.items():\n            ifd.setdefault(tag, value)\n\n    blocklist = [TILEWIDTH, TILELENGTH, TILEOFFSETS, TILEBYTECOUNTS]\n    if libtiff:\n        if \"quality\" in encoderinfo:\n            quality = encoderinfo[\"quality\"]\n            if not isinstance(quality, int) or quality < 0 or quality > 100:\n                msg = \"Invalid quality setting\"\n                raise ValueError(msg)\n            if compression != \"jpeg\":\n                msg = \"quality setting only supported for 'jpeg' compression\"\n                raise ValueError(msg)\n            ifd[JPEGQUALITY] = quality\n\n        logger.debug(\"Saving using libtiff encoder\")\n        logger.debug(\"Items: %s\", sorted(ifd.items()))\n        _fp = 0\n        if hasattr(fp, \"fileno\"):\n            try:\n                fp.seek(0)\n                _fp = os.dup(fp.fileno())\n            except io.UnsupportedOperation:\n                pass\n\n        # optional types for non core tags\n        types = {}\n        # STRIPOFFSETS and STRIPBYTECOUNTS are added by the library\n        # based on the data in the strip.\n        # OSUBFILETYPE is deprecated.\n        # The other tags expect arrays with a certain length (fixed or depending on\n        # BITSPERSAMPLE, etc), passing arrays with a different length will result in\n        # segfaults. Block these tags until we add extra validation.\n        # SUBIFD may also cause a segfault.\n        blocklist += [\n            OSUBFILETYPE,\n            REFERENCEBLACKWHITE,\n            STRIPBYTECOUNTS,\n            STRIPOFFSETS,\n            TRANSFERFUNCTION,\n            SUBIFD,\n        ]\n\n        # bits per sample is a single short in the tiff directory, not a list.\n        atts = {BITSPERSAMPLE: bits[0]}\n        # Merge the ones that we have with (optional) more bits from\n        # the original file, e.g x,y resolution so that we can\n        # save(load('')) == original file.\n        legacy_ifd = {}\n        if hasattr(im, \"tag\"):\n            legacy_ifd = im.tag.to_v2()\n\n        # SAMPLEFORMAT is determined by the image format and should not be copied\n        # from legacy_ifd.\n        supplied_tags = {**getattr(im, \"tag_v2\", {}), **legacy_ifd}\n        if SAMPLEFORMAT in supplied_tags:\n            del supplied_tags[SAMPLEFORMAT]\n\n        for tag, value in itertools.chain(ifd.items(), supplied_tags.items()):\n            # Libtiff can only process certain core items without adding\n            # them to the custom dictionary.\n            # Custom items are supported for int, float, unicode, string and byte\n            # values. Other types and tuples require a tagtype.\n            if tag not in TiffTags.LIBTIFF_CORE:\n                if not getattr(Image.core, \"libtiff_support_custom_tags\", False):\n                    continue\n\n                if tag in ifd.tagtype:\n                    types[tag] = ifd.tagtype[tag]\n                elif not (isinstance(value, (int, float, str, bytes))):\n                    continue\n                else:\n                    type = TiffTags.lookup(tag).type\n                    if type:\n                        types[tag] = type\n            if tag not in atts and tag not in blocklist:\n                if isinstance(value, str):\n                    atts[tag] = value.encode(\"ascii\", \"replace\") + b\"\\0\"\n                elif isinstance(value, IFDRational):\n                    atts[tag] = float(value)\n                else:\n                    atts[tag] = value\n\n        if SAMPLEFORMAT in atts and len(atts[SAMPLEFORMAT]) == 1:\n            atts[SAMPLEFORMAT] = atts[SAMPLEFORMAT][0]\n\n        logger.debug(\"Converted items: %s\", sorted(atts.items()))\n\n        # libtiff always expects the bytes in native order.\n        # we're storing image byte order. So, if the rawmode\n        # contains I;16, we need to convert from native to image\n        # byte order.\n        if im.mode in (\"I;16B\", \"I;16\"):\n            rawmode = \"I;16N\"\n\n        # Pass tags as sorted list so that the tags are set in a fixed order.\n        # This is required by libtiff for some tags. For example, the JPEGQUALITY\n        # pseudo tag requires that the COMPRESS tag was already set.\n        tags = list(atts.items())\n        tags.sort()\n        a = (rawmode, compression, _fp, filename, tags, types)\n        encoder = Image._getencoder(im.mode, \"libtiff\", a, encoderconfig)\n        encoder.setimage(im.im, (0, 0) + im.size)\n        while True:\n            # undone, change to self.decodermaxblock:\n            errcode, data = encoder.encode(16 * 1024)[1:]\n            if not _fp:\n                fp.write(data)\n            if errcode:\n                break\n        if _fp:\n            try:\n                os.close(_fp)\n            except OSError:\n                pass\n        if errcode < 0:\n            msg = f\"encoder error {errcode} when writing image file\"\n            raise OSError(msg)\n\n    else:\n        for tag in blocklist:\n            del ifd[tag]\n        offset = ifd.save(fp)\n\n        ImageFile._save(\n            im, fp, [(\"raw\", (0, 0) + im.size, offset, (rawmode, stride, 1))]\n        )\n\n    # -- helper for multi-page save --\n    if \"_debug_multipage\" in encoderinfo:\n        # just to access o32 and o16 (using correct byte order)\n        im._debug_multipage = ifd\n\n\nclass AppendingTiffWriter:\n    fieldSizes = [\n        0,  # None\n        1,  # byte\n        1,  # ascii\n        2,  # short\n        4,  # long\n        8,  # rational\n        1,  # sbyte\n        1,  # undefined\n        2,  # sshort\n        4,  # slong\n        8,  # srational\n        4,  # float\n        8,  # double\n        4,  # ifd\n        2,  # unicode\n        4,  # complex\n        8,  # long8\n    ]\n\n    Tags = {\n        273,  # StripOffsets\n        288,  # FreeOffsets\n        324,  # TileOffsets\n        519,  # JPEGQTables\n        520,  # JPEGDCTables\n        521,  # JPEGACTables\n    }\n\n    def __init__(self, fn, new=False):\n        if hasattr(fn, \"read\"):\n            self.f = fn\n            self.close_fp = False\n        else:\n            self.name = fn\n            self.close_fp = True\n            try:\n                self.f = open(fn, \"w+b\" if new else \"r+b\")\n            except OSError:\n                self.f = open(fn, \"w+b\")\n        self.beginning = self.f.tell()\n        self.setup()\n\n    def setup(self) -> None:\n        # Reset everything.\n        self.f.seek(self.beginning, os.SEEK_SET)\n\n        self.whereToWriteNewIFDOffset = None\n        self.offsetOfNewPage = 0\n\n        self.IIMM = iimm = self.f.read(4)\n        if not iimm:\n            # empty file - first page\n            self.isFirst = True\n            return\n\n        self.isFirst = False\n        if iimm == b\"II\\x2a\\x00\":\n            self.setEndian(\"<\")\n        elif iimm == b\"MM\\x00\\x2a\":\n            self.setEndian(\">\")\n        else:\n            msg = \"Invalid TIFF file header\"\n            raise RuntimeError(msg)\n\n        self.skipIFDs()\n        self.goToEnd()\n\n    def finalize(self) -> None:\n        if self.isFirst:\n            return\n\n        # fix offsets\n        self.f.seek(self.offsetOfNewPage)\n\n        iimm = self.f.read(4)\n        if not iimm:\n            # Make it easy to finish a frame without committing to a new one.\n            return\n\n        if iimm != self.IIMM:\n            msg = \"IIMM of new page doesn't match IIMM of first page\"\n            raise RuntimeError(msg)\n\n        ifd_offset = self.readLong()\n        ifd_offset += self.offsetOfNewPage\n        self.f.seek(self.whereToWriteNewIFDOffset)\n        self.writeLong(ifd_offset)\n        self.f.seek(ifd_offset)\n        self.fixIFD()\n\n    def newFrame(self) -> None:\n        # Call this to finish a frame.\n        self.finalize()\n        self.setup()\n\n    def __enter__(self) -> AppendingTiffWriter:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        if self.close_fp:\n            self.close()\n\n    def tell(self) -> int:\n        return self.f.tell() - self.offsetOfNewPage\n\n    def seek(self, offset, whence=io.SEEK_SET):\n        if whence == os.SEEK_SET:\n            offset += self.offsetOfNewPage\n\n        self.f.seek(offset, whence)\n        return self.tell()\n\n    def goToEnd(self) -> None:\n        self.f.seek(0, os.SEEK_END)\n        pos = self.f.tell()\n\n        # pad to 16 byte boundary\n        pad_bytes = 16 - pos % 16\n        if 0 < pad_bytes < 16:\n            self.f.write(bytes(pad_bytes))\n        self.offsetOfNewPage = self.f.tell()\n\n    def setEndian(self, endian: str) -> None:\n        self.endian = endian\n        self.longFmt = f\"{self.endian}L\"\n        self.shortFmt = f\"{self.endian}H\"\n        self.tagFormat = f\"{self.endian}HHL\"\n\n    def skipIFDs(self) -> None:\n        while True:\n            ifd_offset = self.readLong()\n            if ifd_offset == 0:\n                self.whereToWriteNewIFDOffset = self.f.tell() - 4\n                break\n\n            self.f.seek(ifd_offset)\n            num_tags = self.readShort()\n            self.f.seek(num_tags * 12, os.SEEK_CUR)\n\n    def write(self, data: bytes) -> int | None:\n        return self.f.write(data)\n\n    def readShort(self) -> int:\n        (value,) = struct.unpack(self.shortFmt, self.f.read(2))\n        return value\n\n    def readLong(self) -> int:\n        (value,) = struct.unpack(self.longFmt, self.f.read(4))\n        return value\n\n    def rewriteLastShortToLong(self, value: int) -> None:\n        self.f.seek(-2, os.SEEK_CUR)\n        bytes_written = self.f.write(struct.pack(self.longFmt, value))\n        if bytes_written is not None and bytes_written != 4:\n            msg = f\"wrote only {bytes_written} bytes but wanted 4\"\n            raise RuntimeError(msg)\n\n    def rewriteLastShort(self, value: int) -> None:\n        self.f.seek(-2, os.SEEK_CUR)\n        bytes_written = self.f.write(struct.pack(self.shortFmt, value))\n        if bytes_written is not None and bytes_written != 2:\n            msg = f\"wrote only {bytes_written} bytes but wanted 2\"\n            raise RuntimeError(msg)\n\n    def rewriteLastLong(self, value: int) -> None:\n        self.f.seek(-4, os.SEEK_CUR)\n        bytes_written = self.f.write(struct.pack(self.longFmt, value))\n        if bytes_written is not None and bytes_written != 4:\n            msg = f\"wrote only {bytes_written} bytes but wanted 4\"\n            raise RuntimeError(msg)\n\n    def writeShort(self, value: int) -> None:\n        bytes_written = self.f.write(struct.pack(self.shortFmt, value))\n        if bytes_written is not None and bytes_written != 2:\n            msg = f\"wrote only {bytes_written} bytes but wanted 2\"\n            raise RuntimeError(msg)\n\n    def writeLong(self, value: int) -> None:\n        bytes_written = self.f.write(struct.pack(self.longFmt, value))\n        if bytes_written is not None and bytes_written != 4:\n            msg = f\"wrote only {bytes_written} bytes but wanted 4\"\n            raise RuntimeError(msg)\n\n    def close(self) -> None:\n        self.finalize()\n        self.f.close()\n\n    def fixIFD(self) -> None:\n        num_tags = self.readShort()\n\n        for i in range(num_tags):\n            tag, field_type, count = struct.unpack(self.tagFormat, self.f.read(8))\n\n            field_size = self.fieldSizes[field_type]\n            total_size = field_size * count\n            is_local = total_size <= 4\n            offset: int | None\n            if not is_local:\n                offset = self.readLong() + self.offsetOfNewPage\n                self.rewriteLastLong(offset)\n\n            if tag in self.Tags:\n                cur_pos = self.f.tell()\n\n                if is_local:\n                    self.fixOffsets(\n                        count, isShort=(field_size == 2), isLong=(field_size == 4)\n                    )\n                    self.f.seek(cur_pos + 4)\n                else:\n                    self.f.seek(offset)\n                    self.fixOffsets(\n                        count, isShort=(field_size == 2), isLong=(field_size == 4)\n                    )\n                    self.f.seek(cur_pos)\n\n                offset = cur_pos = None\n\n            elif is_local:\n                # skip the locally stored value that is not an offset\n                self.f.seek(4, os.SEEK_CUR)\n\n    def fixOffsets(\n        self, count: int, isShort: bool = False, isLong: bool = False\n    ) -> None:\n        if not isShort and not isLong:\n            msg = \"offset is neither short nor long\"\n            raise RuntimeError(msg)\n\n        for i in range(count):\n            offset = self.readShort() if isShort else self.readLong()\n            offset += self.offsetOfNewPage\n            if isShort and offset >= 65536:\n                # offset is now too large - we must convert shorts to longs\n                if count != 1:\n                    msg = \"not implemented\"\n                    raise RuntimeError(msg)  # XXX TODO\n\n                # simple case - the offset is just one and therefore it is\n                # local (not referenced with another offset)\n                self.rewriteLastShortToLong(offset)\n                self.f.seek(-10, os.SEEK_CUR)\n                self.writeShort(TiffTags.LONG)  # rewrite the type to LONG\n                self.f.seek(8, os.SEEK_CUR)\n            elif isShort:\n                self.rewriteLastShort(offset)\n            else:\n                self.rewriteLastLong(offset)\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    encoderinfo = im.encoderinfo.copy()\n    encoderconfig = im.encoderconfig\n    append_images = list(encoderinfo.get(\"append_images\", []))\n    if not hasattr(im, \"n_frames\") and not append_images:\n        return _save(im, fp, filename)\n\n    cur_idx = im.tell()\n    try:\n        with AppendingTiffWriter(fp) as tf:\n            for ims in [im] + append_images:\n                ims.encoderinfo = encoderinfo\n                ims.encoderconfig = encoderconfig\n                if not hasattr(ims, \"n_frames\"):\n                    nfr = 1\n                else:\n                    nfr = ims.n_frames\n\n                for idx in range(nfr):\n                    ims.seek(idx)\n                    ims.load()\n                    _save(ims, tf, filename)\n                    tf.newFrame()\n    finally:\n        im.seek(cur_idx)\n\n\n#\n# --------------------------------------------------------------------\n# Register\n\nImage.register_open(TiffImageFile.format, TiffImageFile, _accept)\nImage.register_save(TiffImageFile.format, _save)\nImage.register_save_all(TiffImageFile.format, _save_all)\n\nImage.register_extensions(TiffImageFile.format, [\".tif\", \".tiff\"])\n\nImage.register_mime(TiffImageFile.format, \"image/tiff\")\n", "src/PIL/Image.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# the Image class wrapper\n#\n# partial release history:\n# 1995-09-09 fl   Created\n# 1996-03-11 fl   PIL release 0.0 (proof of concept)\n# 1996-04-30 fl   PIL release 0.1b1\n# 1999-07-28 fl   PIL release 1.0 final\n# 2000-06-07 fl   PIL release 1.1\n# 2000-10-20 fl   PIL release 1.1.1\n# 2001-05-07 fl   PIL release 1.1.2\n# 2002-03-15 fl   PIL release 1.1.3\n# 2003-05-10 fl   PIL release 1.1.4\n# 2005-03-28 fl   PIL release 1.1.5\n# 2006-12-02 fl   PIL release 1.1.6\n# 2009-11-15 fl   PIL release 1.1.7\n#\n# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-2009 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import annotations\n\nimport abc\nimport atexit\nimport builtins\nimport io\nimport logging\nimport math\nimport os\nimport re\nimport struct\nimport sys\nimport tempfile\nimport warnings\nfrom collections.abc import Callable, MutableMapping\nfrom enum import IntEnum\nfrom types import ModuleType\nfrom typing import IO, TYPE_CHECKING, Any, Literal, Protocol, Sequence, Tuple, cast\n\n# VERSION was removed in Pillow 6.0.0.\n# PILLOW_VERSION was removed in Pillow 9.0.0.\n# Use __version__ instead.\nfrom . import (\n    ExifTags,\n    ImageMode,\n    TiffTags,\n    UnidentifiedImageError,\n    __version__,\n    _plugins,\n)\nfrom ._binary import i32le, o32be, o32le\nfrom ._deprecate import deprecate\nfrom ._typing import StrOrBytesPath, TypeGuard\nfrom ._util import DeferredError, is_path\n\nElementTree: ModuleType | None\ntry:\n    from defusedxml import ElementTree\nexcept ImportError:\n    ElementTree = None\n\nlogger = logging.getLogger(__name__)\n\n\nclass DecompressionBombWarning(RuntimeWarning):\n    pass\n\n\nclass DecompressionBombError(Exception):\n    pass\n\n\n# Limit to around a quarter gigabyte for a 24-bit (3 bpp) image\nMAX_IMAGE_PIXELS: int | None = int(1024 * 1024 * 1024 // 4 // 3)\n\n\ntry:\n    # If the _imaging C module is not present, Pillow will not load.\n    # Note that other modules should not refer to _imaging directly;\n    # import Image and use the Image.core variable instead.\n    # Also note that Image.core is not a publicly documented interface,\n    # and should be considered private and subject to change.\n    from . import _imaging as core\n\n    if __version__ != getattr(core, \"PILLOW_VERSION\", None):\n        msg = (\n            \"The _imaging extension was built for another version of Pillow or PIL:\\n\"\n            f\"Core version: {getattr(core, 'PILLOW_VERSION', None)}\\n\"\n            f\"Pillow version: {__version__}\"\n        )\n        raise ImportError(msg)\n\nexcept ImportError as v:\n    core = DeferredError.new(ImportError(\"The _imaging C module is not installed.\"))\n    # Explanations for ways that we know we might have an import error\n    if str(v).startswith(\"Module use of python\"):\n        # The _imaging C module is present, but not compiled for\n        # the right version (windows only).  Print a warning, if\n        # possible.\n        warnings.warn(\n            \"The _imaging extension was built for another version of Python.\",\n            RuntimeWarning,\n        )\n    elif str(v).startswith(\"The _imaging extension\"):\n        warnings.warn(str(v), RuntimeWarning)\n    # Fail here anyway. Don't let people run with a mostly broken Pillow.\n    # see docs/porting.rst\n    raise\n\n\nUSE_CFFI_ACCESS = False\ncffi: ModuleType | None\ntry:\n    import cffi\nexcept ImportError:\n    cffi = None\n\n\ndef isImageType(t: Any) -> TypeGuard[Image]:\n    \"\"\"\n    Checks if an object is an image object.\n\n    .. warning::\n\n       This function is for internal use only.\n\n    :param t: object to check if it's an image\n    :returns: True if the object is an image\n    \"\"\"\n    return hasattr(t, \"im\")\n\n\n#\n# Constants\n\n\n# transpose\nclass Transpose(IntEnum):\n    FLIP_LEFT_RIGHT = 0\n    FLIP_TOP_BOTTOM = 1\n    ROTATE_90 = 2\n    ROTATE_180 = 3\n    ROTATE_270 = 4\n    TRANSPOSE = 5\n    TRANSVERSE = 6\n\n\n# transforms (also defined in Imaging.h)\nclass Transform(IntEnum):\n    AFFINE = 0\n    EXTENT = 1\n    PERSPECTIVE = 2\n    QUAD = 3\n    MESH = 4\n\n\n# resampling filters (also defined in Imaging.h)\nclass Resampling(IntEnum):\n    NEAREST = 0\n    BOX = 4\n    BILINEAR = 2\n    HAMMING = 5\n    BICUBIC = 3\n    LANCZOS = 1\n\n\n_filters_support = {\n    Resampling.BOX: 0.5,\n    Resampling.BILINEAR: 1.0,\n    Resampling.HAMMING: 1.0,\n    Resampling.BICUBIC: 2.0,\n    Resampling.LANCZOS: 3.0,\n}\n\n\n# dithers\nclass Dither(IntEnum):\n    NONE = 0\n    ORDERED = 1  # Not yet implemented\n    RASTERIZE = 2  # Not yet implemented\n    FLOYDSTEINBERG = 3  # default\n\n\n# palettes/quantizers\nclass Palette(IntEnum):\n    WEB = 0\n    ADAPTIVE = 1\n\n\nclass Quantize(IntEnum):\n    MEDIANCUT = 0\n    MAXCOVERAGE = 1\n    FASTOCTREE = 2\n    LIBIMAGEQUANT = 3\n\n\nmodule = sys.modules[__name__]\nfor enum in (Transpose, Transform, Resampling, Dither, Palette, Quantize):\n    for item in enum:\n        setattr(module, item.name, item.value)\n\n\nif hasattr(core, \"DEFAULT_STRATEGY\"):\n    DEFAULT_STRATEGY = core.DEFAULT_STRATEGY\n    FILTERED = core.FILTERED\n    HUFFMAN_ONLY = core.HUFFMAN_ONLY\n    RLE = core.RLE\n    FIXED = core.FIXED\n\n\n# --------------------------------------------------------------------\n# Registries\n\nif TYPE_CHECKING:\n    from . import ImageFile\nID: list[str] = []\nOPEN: dict[\n    str,\n    tuple[\n        Callable[[IO[bytes], str | bytes], ImageFile.ImageFile],\n        Callable[[bytes], bool | str] | None,\n    ],\n] = {}\nMIME: dict[str, str] = {}\nSAVE: dict[str, Callable[[Image, IO[bytes], str | bytes], None]] = {}\nSAVE_ALL: dict[str, Callable[[Image, IO[bytes], str | bytes], None]] = {}\nEXTENSION: dict[str, str] = {}\nDECODERS: dict[str, type[ImageFile.PyDecoder]] = {}\nENCODERS: dict[str, type[ImageFile.PyEncoder]] = {}\n\n# --------------------------------------------------------------------\n# Modes\n\n_ENDIAN = \"<\" if sys.byteorder == \"little\" else \">\"\n\n\ndef _conv_type_shape(im):\n    m = ImageMode.getmode(im.mode)\n    shape = (im.height, im.width)\n    extra = len(m.bands)\n    if extra != 1:\n        shape += (extra,)\n    return shape, m.typestr\n\n\nMODES = [\n    \"1\",\n    \"CMYK\",\n    \"F\",\n    \"HSV\",\n    \"I\",\n    \"I;16\",\n    \"I;16B\",\n    \"I;16L\",\n    \"I;16N\",\n    \"L\",\n    \"LA\",\n    \"La\",\n    \"LAB\",\n    \"P\",\n    \"PA\",\n    \"RGB\",\n    \"RGBA\",\n    \"RGBa\",\n    \"RGBX\",\n    \"YCbCr\",\n]\n\n# raw modes that may be memory mapped.  NOTE: if you change this, you\n# may have to modify the stride calculation in map.c too!\n_MAPMODES = (\"L\", \"P\", \"RGBX\", \"RGBA\", \"CMYK\", \"I;16\", \"I;16L\", \"I;16B\")\n\n\ndef getmodebase(mode: str) -> str:\n    \"\"\"\n    Gets the \"base\" mode for given mode.  This function returns \"L\" for\n    images that contain grayscale data, and \"RGB\" for images that\n    contain color data.\n\n    :param mode: Input mode.\n    :returns: \"L\" or \"RGB\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basemode\n\n\ndef getmodetype(mode: str) -> str:\n    \"\"\"\n    Gets the storage type mode.  Given a mode, this function returns a\n    single-layer mode suitable for storing individual bands.\n\n    :param mode: Input mode.\n    :returns: \"L\", \"I\", or \"F\".\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).basetype\n\n\ndef getmodebandnames(mode: str) -> tuple[str, ...]:\n    \"\"\"\n    Gets a list of individual band names.  Given a mode, this function returns\n    a tuple containing the names of individual bands (use\n    :py:method:`~PIL.Image.getmodetype` to get the mode used to store each\n    individual band.\n\n    :param mode: Input mode.\n    :returns: A tuple containing band names.  The length of the tuple\n        gives the number of bands in an image of the given mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return ImageMode.getmode(mode).bands\n\n\ndef getmodebands(mode: str) -> int:\n    \"\"\"\n    Gets the number of individual bands for this mode.\n\n    :param mode: Input mode.\n    :returns: The number of bands in this mode.\n    :exception KeyError: If the input mode was not a standard mode.\n    \"\"\"\n    return len(ImageMode.getmode(mode).bands)\n\n\n# --------------------------------------------------------------------\n# Helpers\n\n_initialized = 0\n\n\ndef preinit() -> None:\n    \"\"\"\n    Explicitly loads BMP, GIF, JPEG, PPM and PPM file format drivers.\n\n    It is called when opening or saving images.\n    \"\"\"\n\n    global _initialized\n    if _initialized >= 1:\n        return\n\n    try:\n        from . import BmpImagePlugin\n\n        assert BmpImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import GifImagePlugin\n\n        assert GifImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import JpegImagePlugin\n\n        assert JpegImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import PpmImagePlugin\n\n        assert PpmImagePlugin\n    except ImportError:\n        pass\n    try:\n        from . import PngImagePlugin\n\n        assert PngImagePlugin\n    except ImportError:\n        pass\n\n    _initialized = 1\n\n\ndef init() -> bool:\n    \"\"\"\n    Explicitly initializes the Python Imaging Library. This function\n    loads all available file format drivers.\n\n    It is called when opening or saving images if :py:meth:`~preinit()` is\n    insufficient, and by :py:meth:`~PIL.features.pilinfo`.\n    \"\"\"\n\n    global _initialized\n    if _initialized >= 2:\n        return False\n\n    parent_name = __name__.rpartition(\".\")[0]\n    for plugin in _plugins:\n        try:\n            logger.debug(\"Importing %s\", plugin)\n            __import__(f\"{parent_name}.{plugin}\", globals(), locals(), [])\n        except ImportError as e:\n            logger.debug(\"Image: failed to import %s: %s\", plugin, e)\n\n    if OPEN or SAVE:\n        _initialized = 2\n        return True\n    return False\n\n\n# --------------------------------------------------------------------\n# Codec factories (used by tobytes/frombytes and ImageFile.load)\n\n\ndef _getdecoder(\n    mode: str, decoder_name: str, args: Any, extra: tuple[Any, ...] = ()\n) -> core.ImagingDecoder | ImageFile.PyDecoder:\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        decoder = DECODERS[decoder_name]\n    except KeyError:\n        pass\n    else:\n        return decoder(mode, *args + extra)\n\n    try:\n        # get decoder\n        decoder = getattr(core, f\"{decoder_name}_decoder\")\n    except AttributeError as e:\n        msg = f\"decoder {decoder_name} not available\"\n        raise OSError(msg) from e\n    return decoder(mode, *args + extra)\n\n\ndef _getencoder(\n    mode: str, encoder_name: str, args: Any, extra: tuple[Any, ...] = ()\n) -> core.ImagingEncoder | ImageFile.PyEncoder:\n    # tweak arguments\n    if args is None:\n        args = ()\n    elif not isinstance(args, tuple):\n        args = (args,)\n\n    try:\n        encoder = ENCODERS[encoder_name]\n    except KeyError:\n        pass\n    else:\n        return encoder(mode, *args + extra)\n\n    try:\n        # get encoder\n        encoder = getattr(core, f\"{encoder_name}_encoder\")\n    except AttributeError as e:\n        msg = f\"encoder {encoder_name} not available\"\n        raise OSError(msg) from e\n    return encoder(mode, *args + extra)\n\n\n# --------------------------------------------------------------------\n# Simple expression analyzer\n\n\nclass _E:\n    def __init__(self, scale, offset) -> None:\n        self.scale = scale\n        self.offset = offset\n\n    def __neg__(self):\n        return _E(-self.scale, -self.offset)\n\n    def __add__(self, other):\n        if isinstance(other, _E):\n            return _E(self.scale + other.scale, self.offset + other.offset)\n        return _E(self.scale, self.offset + other)\n\n    __radd__ = __add__\n\n    def __sub__(self, other):\n        return self + -other\n\n    def __rsub__(self, other):\n        return other + -self\n\n    def __mul__(self, other):\n        if isinstance(other, _E):\n            return NotImplemented\n        return _E(self.scale * other, self.offset * other)\n\n    __rmul__ = __mul__\n\n    def __truediv__(self, other):\n        if isinstance(other, _E):\n            return NotImplemented\n        return _E(self.scale / other, self.offset / other)\n\n\ndef _getscaleoffset(expr):\n    a = expr(_E(1, 0))\n    return (a.scale, a.offset) if isinstance(a, _E) else (0, a)\n\n\n# --------------------------------------------------------------------\n# Implementation wrapper\n\n\nclass SupportsGetData(Protocol):\n    def getdata(\n        self,\n    ) -> tuple[Transform, Sequence[int]]: ...\n\n\nclass Image:\n    \"\"\"\n    This class represents an image object.  To create\n    :py:class:`~PIL.Image.Image` objects, use the appropriate factory\n    functions.  There's hardly ever any reason to call the Image constructor\n    directly.\n\n    * :py:func:`~PIL.Image.open`\n    * :py:func:`~PIL.Image.new`\n    * :py:func:`~PIL.Image.frombytes`\n    \"\"\"\n\n    format: str | None = None\n    format_description: str | None = None\n    _close_exclusive_fp_after_loading = True\n\n    def __init__(self):\n        # FIXME: take \"new\" parameters / other image?\n        # FIXME: turn mode and size into delegating properties?\n        self.im = None\n        self._mode = \"\"\n        self._size = (0, 0)\n        self.palette = None\n        self.info = {}\n        self.readonly = 0\n        self.pyaccess = None\n        self._exif = None\n\n    @property\n    def width(self) -> int:\n        return self.size[0]\n\n    @property\n    def height(self) -> int:\n        return self.size[1]\n\n    @property\n    def size(self) -> tuple[int, int]:\n        return self._size\n\n    @property\n    def mode(self) -> str:\n        return self._mode\n\n    def _new(self, im: core.ImagingCore) -> Image:\n        new = Image()\n        new.im = im\n        new._mode = im.mode\n        new._size = im.size\n        if im.mode in (\"P\", \"PA\"):\n            if self.palette:\n                new.palette = self.palette.copy()\n            else:\n                from . import ImagePalette\n\n                new.palette = ImagePalette.ImagePalette()\n        new.info = self.info.copy()\n        return new\n\n    # Context manager support\n    def __enter__(self):\n        return self\n\n    def _close_fp(self):\n        if getattr(self, \"_fp\", False):\n            if self._fp != self.fp:\n                self._fp.close()\n            self._fp = DeferredError(ValueError(\"Operation on closed image\"))\n        if self.fp:\n            self.fp.close()\n\n    def __exit__(self, *args):\n        if hasattr(self, \"fp\"):\n            if getattr(self, \"_exclusive_fp\", False):\n                self._close_fp()\n            self.fp = None\n\n    def close(self) -> None:\n        \"\"\"\n        Closes the file pointer, if possible.\n\n        This operation will destroy the image core and release its memory.\n        The image data will be unusable afterward.\n\n        This function is required to close images that have multiple frames or\n        have not had their file read and closed by the\n        :py:meth:`~PIL.Image.Image.load` method. See :ref:`file-handling` for\n        more information.\n        \"\"\"\n        if hasattr(self, \"fp\"):\n            try:\n                self._close_fp()\n                self.fp = None\n            except Exception as msg:\n                logger.debug(\"Error closing: %s\", msg)\n\n        if getattr(self, \"map\", None):\n            self.map = None\n\n        # Instead of simply setting to None, we're setting up a\n        # deferred error that will better explain that the core image\n        # object is gone.\n        self.im = DeferredError(ValueError(\"Operation on closed image\"))\n\n    def _copy(self) -> None:\n        self.load()\n        self.im = self.im.copy()\n        self.pyaccess = None\n        self.readonly = 0\n\n    def _ensure_mutable(self) -> None:\n        if self.readonly:\n            self._copy()\n        else:\n            self.load()\n\n    def _dump(\n        self, file: str | None = None, format: str | None = None, **options: Any\n    ) -> str:\n        suffix = \"\"\n        if format:\n            suffix = f\".{format}\"\n\n        if not file:\n            f, filename = tempfile.mkstemp(suffix)\n            os.close(f)\n        else:\n            filename = file\n            if not filename.endswith(suffix):\n                filename = filename + suffix\n\n        self.load()\n\n        if not format or format == \"PPM\":\n            self.im.save_ppm(filename)\n        else:\n            self.save(filename, format, **options)\n\n        return filename\n\n    def __eq__(self, other: object) -> bool:\n        if self.__class__ is not other.__class__:\n            return False\n        assert isinstance(other, Image)\n        return (\n            self.mode == other.mode\n            and self.size == other.size\n            and self.info == other.info\n            and self.getpalette() == other.getpalette()\n            and self.tobytes() == other.tobytes()\n        )\n\n    def __repr__(self) -> str:\n        return \"<%s.%s image mode=%s size=%dx%d at 0x%X>\" % (\n            self.__class__.__module__,\n            self.__class__.__name__,\n            self.mode,\n            self.size[0],\n            self.size[1],\n            id(self),\n        )\n\n    def _repr_pretty_(self, p, cycle) -> None:\n        \"\"\"IPython plain text display support\"\"\"\n\n        # Same as __repr__ but without unpredictable id(self),\n        # to keep Jupyter notebook `text/plain` output stable.\n        p.text(\n            \"<%s.%s image mode=%s size=%dx%d>\"\n            % (\n                self.__class__.__module__,\n                self.__class__.__name__,\n                self.mode,\n                self.size[0],\n                self.size[1],\n            )\n        )\n\n    def _repr_image(self, image_format: str, **kwargs: Any) -> bytes | None:\n        \"\"\"Helper function for iPython display hook.\n\n        :param image_format: Image format.\n        :returns: image as bytes, saved into the given format.\n        \"\"\"\n        b = io.BytesIO()\n        try:\n            self.save(b, image_format, **kwargs)\n        except Exception:\n            return None\n        return b.getvalue()\n\n    def _repr_png_(self) -> bytes | None:\n        \"\"\"iPython display hook support for PNG format.\n\n        :returns: PNG version of the image as bytes\n        \"\"\"\n        return self._repr_image(\"PNG\", compress_level=1)\n\n    def _repr_jpeg_(self) -> bytes | None:\n        \"\"\"iPython display hook support for JPEG format.\n\n        :returns: JPEG version of the image as bytes\n        \"\"\"\n        return self._repr_image(\"JPEG\")\n\n    @property\n    def __array_interface__(self):\n        # numpy array interface support\n        new = {\"version\": 3}\n        try:\n            if self.mode == \"1\":\n                # Binary images need to be extended from bits to bytes\n                # See: https://github.com/python-pillow/Pillow/issues/350\n                new[\"data\"] = self.tobytes(\"raw\", \"L\")\n            else:\n                new[\"data\"] = self.tobytes()\n        except Exception as e:\n            if not isinstance(e, (MemoryError, RecursionError)):\n                try:\n                    import numpy\n                    from packaging.version import parse as parse_version\n                except ImportError:\n                    pass\n                else:\n                    if parse_version(numpy.__version__) < parse_version(\"1.23\"):\n                        warnings.warn(str(e))\n            raise\n        new[\"shape\"], new[\"typestr\"] = _conv_type_shape(self)\n        return new\n\n    def __getstate__(self):\n        im_data = self.tobytes()  # load image first\n        return [self.info, self.mode, self.size, self.getpalette(), im_data]\n\n    def __setstate__(self, state) -> None:\n        Image.__init__(self)\n        info, mode, size, palette, data = state\n        self.info = info\n        self._mode = mode\n        self._size = size\n        self.im = core.new(mode, size)\n        if mode in (\"L\", \"LA\", \"P\", \"PA\") and palette:\n            self.putpalette(palette)\n        self.frombytes(data)\n\n    def tobytes(self, encoder_name: str = \"raw\", *args: Any) -> bytes:\n        \"\"\"\n        Return image as a bytes object.\n\n        .. warning::\n\n            This method returns the raw image data from the internal\n            storage.  For compressed image data (e.g. PNG, JPEG) use\n            :meth:`~.save`, with a BytesIO parameter for in-memory\n            data.\n\n        :param encoder_name: What encoder to use.  The default is to\n                             use the standard \"raw\" encoder.\n\n                             A list of C encoders can be seen under\n                             codecs section of the function array in\n                             :file:`_imaging.c`. Python encoders are\n                             registered within the relevant plugins.\n        :param args: Extra arguments to the encoder.\n        :returns: A :py:class:`bytes` object.\n        \"\"\"\n\n        encoder_args: Any = args\n        if len(encoder_args) == 1 and isinstance(encoder_args[0], tuple):\n            # may pass tuple instead of argument list\n            encoder_args = encoder_args[0]\n\n        if encoder_name == \"raw\" and encoder_args == ():\n            encoder_args = self.mode\n\n        self.load()\n\n        if self.width == 0 or self.height == 0:\n            return b\"\"\n\n        # unpack data\n        e = _getencoder(self.mode, encoder_name, encoder_args)\n        e.setimage(self.im)\n\n        bufsize = max(65536, self.size[0] * 4)  # see RawEncode.c\n\n        output = []\n        while True:\n            bytes_consumed, errcode, data = e.encode(bufsize)\n            output.append(data)\n            if errcode:\n                break\n        if errcode < 0:\n            msg = f\"encoder error {errcode} in tobytes\"\n            raise RuntimeError(msg)\n\n        return b\"\".join(output)\n\n    def tobitmap(self, name: str = \"image\") -> bytes:\n        \"\"\"\n        Returns the image converted to an X11 bitmap.\n\n        .. note:: This method only works for mode \"1\" images.\n\n        :param name: The name prefix to use for the bitmap variables.\n        :returns: A string containing an X11 bitmap.\n        :raises ValueError: If the mode is not \"1\"\n        \"\"\"\n\n        self.load()\n        if self.mode != \"1\":\n            msg = \"not a bitmap\"\n            raise ValueError(msg)\n        data = self.tobytes(\"xbm\")\n        return b\"\".join(\n            [\n                f\"#define {name}_width {self.size[0]}\\n\".encode(\"ascii\"),\n                f\"#define {name}_height {self.size[1]}\\n\".encode(\"ascii\"),\n                f\"static char {name}_bits[] = {{\\n\".encode(\"ascii\"),\n                data,\n                b\"};\",\n            ]\n        )\n\n    def frombytes(\n        self, data: bytes | bytearray, decoder_name: str = \"raw\", *args: Any\n    ) -> None:\n        \"\"\"\n        Loads this image with pixel data from a bytes object.\n\n        This method is similar to the :py:func:`~PIL.Image.frombytes` function,\n        but loads data into this image instead of creating a new image object.\n        \"\"\"\n\n        if self.width == 0 or self.height == 0:\n            return\n\n        decoder_args: Any = args\n        if len(decoder_args) == 1 and isinstance(decoder_args[0], tuple):\n            # may pass tuple instead of argument list\n            decoder_args = decoder_args[0]\n\n        # default format\n        if decoder_name == \"raw\" and decoder_args == ():\n            decoder_args = self.mode\n\n        # unpack data\n        d = _getdecoder(self.mode, decoder_name, decoder_args)\n        d.setimage(self.im)\n        s = d.decode(data)\n\n        if s[0] >= 0:\n            msg = \"not enough image data\"\n            raise ValueError(msg)\n        if s[1] != 0:\n            msg = \"cannot decode image data\"\n            raise ValueError(msg)\n\n    def load(self):\n        \"\"\"\n        Allocates storage for the image and loads the pixel data.  In\n        normal cases, you don't need to call this method, since the\n        Image class automatically loads an opened image when it is\n        accessed for the first time.\n\n        If the file associated with the image was opened by Pillow, then this\n        method will close it. The exception to this is if the image has\n        multiple frames, in which case the file will be left open for seek\n        operations. See :ref:`file-handling` for more information.\n\n        :returns: An image access object.\n        :rtype: :ref:`PixelAccess` or :py:class:`PIL.PyAccess`\n        \"\"\"\n        if self.im is not None and self.palette and self.palette.dirty:\n            # realize palette\n            mode, arr = self.palette.getdata()\n            self.im.putpalette(self.palette.mode, mode, arr)\n            self.palette.dirty = 0\n            self.palette.rawmode = None\n            if \"transparency\" in self.info and mode in (\"LA\", \"PA\"):\n                if isinstance(self.info[\"transparency\"], int):\n                    self.im.putpalettealpha(self.info[\"transparency\"], 0)\n                else:\n                    self.im.putpalettealphas(self.info[\"transparency\"])\n                self.palette.mode = \"RGBA\"\n            else:\n                self.palette.palette = self.im.getpalette(\n                    self.palette.mode, self.palette.mode\n                )\n\n        if self.im is not None:\n            if cffi and USE_CFFI_ACCESS:\n                if self.pyaccess:\n                    return self.pyaccess\n                from . import PyAccess\n\n                self.pyaccess = PyAccess.new(self, self.readonly)\n                if self.pyaccess:\n                    return self.pyaccess\n            return self.im.pixel_access(self.readonly)\n\n    def verify(self) -> None:\n        \"\"\"\n        Verifies the contents of a file. For data read from a file, this\n        method attempts to determine if the file is broken, without\n        actually decoding the image data.  If this method finds any\n        problems, it raises suitable exceptions.  If you need to load\n        the image after using this method, you must reopen the image\n        file.\n        \"\"\"\n        pass\n\n    def convert(\n        self,\n        mode: str | None = None,\n        matrix: tuple[float, ...] | None = None,\n        dither: Dither | None = None,\n        palette: Palette = Palette.WEB,\n        colors: int = 256,\n    ) -> Image:\n        \"\"\"\n        Returns a converted copy of this image. For the \"P\" mode, this\n        method translates pixels through the palette.  If mode is\n        omitted, a mode is chosen so that all information in the image\n        and the palette can be represented without a palette.\n\n        This supports all possible conversions between \"L\", \"RGB\" and \"CMYK\". The\n        ``matrix`` argument only supports \"L\" and \"RGB\".\n\n        When translating a color image to grayscale (mode \"L\"),\n        the library uses the ITU-R 601-2 luma transform::\n\n            L = R * 299/1000 + G * 587/1000 + B * 114/1000\n\n        The default method of converting a grayscale (\"L\") or \"RGB\"\n        image into a bilevel (mode \"1\") image uses Floyd-Steinberg\n        dither to approximate the original image luminosity levels. If\n        dither is ``None``, all values larger than 127 are set to 255 (white),\n        all other values to 0 (black). To use other thresholds, use the\n        :py:meth:`~PIL.Image.Image.point` method.\n\n        When converting from \"RGBA\" to \"P\" without a ``matrix`` argument,\n        this passes the operation to :py:meth:`~PIL.Image.Image.quantize`,\n        and ``dither`` and ``palette`` are ignored.\n\n        When converting from \"PA\", if an \"RGBA\" palette is present, the alpha\n        channel from the image will be used instead of the values from the palette.\n\n        :param mode: The requested mode. See: :ref:`concept-modes`.\n        :param matrix: An optional conversion matrix.  If given, this\n           should be 4- or 12-tuple containing floating point values.\n        :param dither: Dithering method, used when converting from\n           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n           (default). Note that this is not used when ``matrix`` is supplied.\n        :param palette: Palette to use when converting from mode \"RGB\"\n           to \"P\".  Available palettes are :data:`Palette.WEB` or\n           :data:`Palette.ADAPTIVE`.\n        :param colors: Number of colors to use for the :data:`Palette.ADAPTIVE`\n           palette. Defaults to 256.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if mode in (\"BGR;15\", \"BGR;16\", \"BGR;24\"):\n            deprecate(mode, 12)\n\n        self.load()\n\n        has_transparency = \"transparency\" in self.info\n        if not mode and self.mode == \"P\":\n            # determine default mode\n            if self.palette:\n                mode = self.palette.mode\n            else:\n                mode = \"RGB\"\n            if mode == \"RGB\" and has_transparency:\n                mode = \"RGBA\"\n        if not mode or (mode == self.mode and not matrix):\n            return self.copy()\n\n        if matrix:\n            # matrix conversion\n            if mode not in (\"L\", \"RGB\"):\n                msg = \"illegal conversion\"\n                raise ValueError(msg)\n            im = self.im.convert_matrix(mode, matrix)\n            new_im = self._new(im)\n            if has_transparency and self.im.bands == 3:\n                transparency = new_im.info[\"transparency\"]\n\n                def convert_transparency(\n                    m: tuple[float, ...], v: tuple[int, int, int]\n                ) -> int:\n                    value = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3] * 0.5\n                    return max(0, min(255, int(value)))\n\n                if mode == \"L\":\n                    transparency = convert_transparency(matrix, transparency)\n                elif len(mode) == 3:\n                    transparency = tuple(\n                        convert_transparency(matrix[i * 4 : i * 4 + 4], transparency)\n                        for i in range(0, len(transparency))\n                    )\n                new_im.info[\"transparency\"] = transparency\n            return new_im\n\n        if mode == \"P\" and self.mode == \"RGBA\":\n            return self.quantize(colors)\n\n        trns = None\n        delete_trns = False\n        # transparency handling\n        if has_transparency:\n            if (self.mode in (\"1\", \"L\", \"I\", \"I;16\") and mode in (\"LA\", \"RGBA\")) or (\n                self.mode == \"RGB\" and mode in (\"La\", \"LA\", \"RGBa\", \"RGBA\")\n            ):\n                # Use transparent conversion to promote from transparent\n                # color to an alpha channel.\n                new_im = self._new(\n                    self.im.convert_transparent(mode, self.info[\"transparency\"])\n                )\n                del new_im.info[\"transparency\"]\n                return new_im\n            elif self.mode in (\"L\", \"RGB\", \"P\") and mode in (\"L\", \"RGB\", \"P\"):\n                t = self.info[\"transparency\"]\n                if isinstance(t, bytes):\n                    # Dragons. This can't be represented by a single color\n                    warnings.warn(\n                        \"Palette images with Transparency expressed in bytes should be \"\n                        \"converted to RGBA images\"\n                    )\n                    delete_trns = True\n                else:\n                    # get the new transparency color.\n                    # use existing conversions\n                    trns_im = new(self.mode, (1, 1))\n                    if self.mode == \"P\":\n                        trns_im.putpalette(self.palette)\n                        if isinstance(t, tuple):\n                            err = \"Couldn't allocate a palette color for transparency\"\n                            try:\n                                t = trns_im.palette.getcolor(t, self)\n                            except ValueError as e:\n                                if str(e) == \"cannot allocate more than 256 colors\":\n                                    # If all 256 colors are in use,\n                                    # then there is no need for transparency\n                                    t = None\n                                else:\n                                    raise ValueError(err) from e\n                    if t is None:\n                        trns = None\n                    else:\n                        trns_im.putpixel((0, 0), t)\n\n                        if mode in (\"L\", \"RGB\"):\n                            trns_im = trns_im.convert(mode)\n                        else:\n                            # can't just retrieve the palette number, got to do it\n                            # after quantization.\n                            trns_im = trns_im.convert(\"RGB\")\n                        trns = trns_im.getpixel((0, 0))\n\n            elif self.mode == \"P\" and mode in (\"LA\", \"PA\", \"RGBA\"):\n                t = self.info[\"transparency\"]\n                delete_trns = True\n\n                if isinstance(t, bytes):\n                    self.im.putpalettealphas(t)\n                elif isinstance(t, int):\n                    self.im.putpalettealpha(t, 0)\n                else:\n                    msg = \"Transparency for P mode should be bytes or int\"\n                    raise ValueError(msg)\n\n        if mode == \"P\" and palette == Palette.ADAPTIVE:\n            im = self.im.quantize(colors)\n            new_im = self._new(im)\n            from . import ImagePalette\n\n            new_im.palette = ImagePalette.ImagePalette(\n                \"RGB\", new_im.im.getpalette(\"RGB\")\n            )\n            if delete_trns:\n                # This could possibly happen if we requantize to fewer colors.\n                # The transparency would be totally off in that case.\n                del new_im.info[\"transparency\"]\n            if trns is not None:\n                try:\n                    new_im.info[\"transparency\"] = new_im.palette.getcolor(trns, new_im)\n                except Exception:\n                    # if we can't make a transparent color, don't leave the old\n                    # transparency hanging around to mess us up.\n                    del new_im.info[\"transparency\"]\n                    warnings.warn(\"Couldn't allocate palette entry for transparency\")\n            return new_im\n\n        if \"LAB\" in (self.mode, mode):\n            other_mode = mode if self.mode == \"LAB\" else self.mode\n            if other_mode in (\"RGB\", \"RGBA\", \"RGBX\"):\n                from . import ImageCms\n\n                srgb = ImageCms.createProfile(\"sRGB\")\n                lab = ImageCms.createProfile(\"LAB\")\n                profiles = [lab, srgb] if self.mode == \"LAB\" else [srgb, lab]\n                transform = ImageCms.buildTransform(\n                    profiles[0], profiles[1], self.mode, mode\n                )\n                return transform.apply(self)\n\n        # colorspace conversion\n        if dither is None:\n            dither = Dither.FLOYDSTEINBERG\n\n        try:\n            im = self.im.convert(mode, dither)\n        except ValueError:\n            try:\n                # normalize source image and try again\n                modebase = getmodebase(self.mode)\n                if modebase == self.mode:\n                    raise\n                im = self.im.convert(modebase)\n                im = im.convert(mode, dither)\n            except KeyError as e:\n                msg = \"illegal conversion\"\n                raise ValueError(msg) from e\n\n        new_im = self._new(im)\n        if mode == \"P\" and palette != Palette.ADAPTIVE:\n            from . import ImagePalette\n\n            new_im.palette = ImagePalette.ImagePalette(\"RGB\", im.getpalette(\"RGB\"))\n        if delete_trns:\n            # crash fail if we leave a bytes transparency in an rgb/l mode.\n            del new_im.info[\"transparency\"]\n        if trns is not None:\n            if new_im.mode == \"P\":\n                try:\n                    new_im.info[\"transparency\"] = new_im.palette.getcolor(trns, new_im)\n                except ValueError as e:\n                    del new_im.info[\"transparency\"]\n                    if str(e) != \"cannot allocate more than 256 colors\":\n                        # If all 256 colors are in use,\n                        # then there is no need for transparency\n                        warnings.warn(\n                            \"Couldn't allocate palette entry for transparency\"\n                        )\n            else:\n                new_im.info[\"transparency\"] = trns\n        return new_im\n\n    def quantize(\n        self,\n        colors: int = 256,\n        method: int | None = None,\n        kmeans: int = 0,\n        palette=None,\n        dither: Dither = Dither.FLOYDSTEINBERG,\n    ) -> Image:\n        \"\"\"\n        Convert the image to 'P' mode with the specified number\n        of colors.\n\n        :param colors: The desired number of colors, <= 256\n        :param method: :data:`Quantize.MEDIANCUT` (median cut),\n                       :data:`Quantize.MAXCOVERAGE` (maximum coverage),\n                       :data:`Quantize.FASTOCTREE` (fast octree),\n                       :data:`Quantize.LIBIMAGEQUANT` (libimagequant; check support\n                       using :py:func:`PIL.features.check_feature` with\n                       ``feature=\"libimagequant\"``).\n\n                       By default, :data:`Quantize.MEDIANCUT` will be used.\n\n                       The exception to this is RGBA images. :data:`Quantize.MEDIANCUT`\n                       and :data:`Quantize.MAXCOVERAGE` do not support RGBA images, so\n                       :data:`Quantize.FASTOCTREE` is used by default instead.\n        :param kmeans: Integer greater than or equal to zero.\n        :param palette: Quantize to the palette of given\n                        :py:class:`PIL.Image.Image`.\n        :param dither: Dithering method, used when converting from\n           mode \"RGB\" to \"P\" or from \"RGB\" or \"L\" to \"1\".\n           Available methods are :data:`Dither.NONE` or :data:`Dither.FLOYDSTEINBERG`\n           (default).\n        :returns: A new image\n        \"\"\"\n\n        self.load()\n\n        if method is None:\n            # defaults:\n            method = Quantize.MEDIANCUT\n            if self.mode == \"RGBA\":\n                method = Quantize.FASTOCTREE\n\n        if self.mode == \"RGBA\" and method not in (\n            Quantize.FASTOCTREE,\n            Quantize.LIBIMAGEQUANT,\n        ):\n            # Caller specified an invalid mode.\n            msg = (\n                \"Fast Octree (method == 2) and libimagequant (method == 3) \"\n                \"are the only valid methods for quantizing RGBA images\"\n            )\n            raise ValueError(msg)\n\n        if palette:\n            # use palette from reference image\n            palette.load()\n            if palette.mode != \"P\":\n                msg = \"bad mode for palette image\"\n                raise ValueError(msg)\n            if self.mode not in {\"RGB\", \"L\"}:\n                msg = \"only RGB or L mode images can be quantized to a palette\"\n                raise ValueError(msg)\n            im = self.im.convert(\"P\", dither, palette.im)\n            new_im = self._new(im)\n            new_im.palette = palette.palette.copy()\n            return new_im\n\n        if kmeans < 0:\n            msg = \"kmeans must not be negative\"\n            raise ValueError(msg)\n\n        im = self._new(self.im.quantize(colors, method, kmeans))\n\n        from . import ImagePalette\n\n        mode = im.im.getpalettemode()\n        palette = im.im.getpalette(mode, mode)[: colors * len(mode)]\n        im.palette = ImagePalette.ImagePalette(mode, palette)\n\n        return im\n\n    def copy(self) -> Image:\n        \"\"\"\n        Copies this image. Use this method if you wish to paste things\n        into an image, but still retain the original.\n\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n        self.load()\n        return self._new(self.im.copy())\n\n    __copy__ = copy\n\n    def crop(self, box: tuple[float, float, float, float] | None = None) -> Image:\n        \"\"\"\n        Returns a rectangular region from this image. The box is a\n        4-tuple defining the left, upper, right, and lower pixel\n        coordinate. See :ref:`coordinate-system`.\n\n        Note: Prior to Pillow 3.4.0, this was a lazy operation.\n\n        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n        :rtype: :py:class:`~PIL.Image.Image`\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if box is None:\n            return self.copy()\n\n        if box[2] < box[0]:\n            msg = \"Coordinate 'right' is less than 'left'\"\n            raise ValueError(msg)\n        elif box[3] < box[1]:\n            msg = \"Coordinate 'lower' is less than 'upper'\"\n            raise ValueError(msg)\n\n        self.load()\n        return self._new(self._crop(self.im, box))\n\n    def _crop(\n        self, im: core.ImagingCore, box: tuple[float, float, float, float]\n    ) -> core.ImagingCore:\n        \"\"\"\n        Returns a rectangular region from the core image object im.\n\n        This is equivalent to calling im.crop((x0, y0, x1, y1)), but\n        includes additional sanity checks.\n\n        :param im: a core image object\n        :param box: The crop rectangle, as a (left, upper, right, lower)-tuple.\n        :returns: A core image object.\n        \"\"\"\n\n        x0, y0, x1, y1 = map(int, map(round, box))\n\n        absolute_values = (abs(x1 - x0), abs(y1 - y0))\n\n        _decompression_bomb_check(absolute_values)\n\n        return im.crop((x0, y0, x1, y1))\n\n    def draft(\n        self, mode: str | None, size: tuple[int, int] | None\n    ) -> tuple[str, tuple[int, int, float, float]] | None:\n        \"\"\"\n        Configures the image file loader so it returns a version of the\n        image that as closely as possible matches the given mode and\n        size. For example, you can use this method to convert a color\n        JPEG to grayscale while loading it.\n\n        If any changes are made, returns a tuple with the chosen ``mode`` and\n        ``box`` with coordinates of the original image within the altered one.\n\n        Note that this method modifies the :py:class:`~PIL.Image.Image` object\n        in place. If the image has already been loaded, this method has no\n        effect.\n\n        Note: This method is not implemented for most images. It is\n        currently implemented only for JPEG and MPO images.\n\n        :param mode: The requested mode.\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        \"\"\"\n        pass\n\n    def _expand(self, xmargin: int, ymargin: int | None = None) -> Image:\n        if ymargin is None:\n            ymargin = xmargin\n        self.load()\n        return self._new(self.im.expand(xmargin, ymargin))\n\n    if TYPE_CHECKING:\n        from . import ImageFilter\n\n    def filter(self, filter: ImageFilter.Filter | type[ImageFilter.Filter]) -> Image:\n        \"\"\"\n        Filters this image using the given filter.  For a list of\n        available filters, see the :py:mod:`~PIL.ImageFilter` module.\n\n        :param filter: Filter kernel.\n        :returns: An :py:class:`~PIL.Image.Image` object.\"\"\"\n\n        from . import ImageFilter\n\n        self.load()\n\n        if callable(filter):\n            filter = filter()\n        if not hasattr(filter, \"filter\"):\n            msg = \"filter argument should be ImageFilter.Filter instance or class\"\n            raise TypeError(msg)\n\n        multiband = isinstance(filter, ImageFilter.MultibandFilter)\n        if self.im.bands == 1 or multiband:\n            return self._new(filter.filter(self.im))\n\n        ims = [\n            self._new(filter.filter(self.im.getband(c))) for c in range(self.im.bands)\n        ]\n        return merge(self.mode, ims)\n\n    def getbands(self) -> tuple[str, ...]:\n        \"\"\"\n        Returns a tuple containing the name of each band in this image.\n        For example, ``getbands`` on an RGB image returns (\"R\", \"G\", \"B\").\n\n        :returns: A tuple containing band names.\n        :rtype: tuple\n        \"\"\"\n        return ImageMode.getmode(self.mode).bands\n\n    def getbbox(self, *, alpha_only: bool = True) -> tuple[int, int, int, int] | None:\n        \"\"\"\n        Calculates the bounding box of the non-zero regions in the\n        image.\n\n        :param alpha_only: Optional flag, defaulting to ``True``.\n           If ``True`` and the image has an alpha channel, trim transparent pixels.\n           Otherwise, trim pixels when all channels are zero.\n           Keyword-only argument.\n        :returns: The bounding box is returned as a 4-tuple defining the\n           left, upper, right, and lower pixel coordinate. See\n           :ref:`coordinate-system`. If the image is completely empty, this\n           method returns None.\n\n        \"\"\"\n\n        self.load()\n        return self.im.getbbox(alpha_only)\n\n    def getcolors(self, maxcolors: int = 256):\n        \"\"\"\n        Returns a list of colors used in this image.\n\n        The colors will be in the image's mode. For example, an RGB image will\n        return a tuple of (red, green, blue) color values, and a P image will\n        return the index of the color in the palette.\n\n        :param maxcolors: Maximum number of colors.  If this number is\n           exceeded, this method returns None.  The default limit is\n           256 colors.\n        :returns: An unsorted list of (count, pixel) values.\n        \"\"\"\n\n        self.load()\n        if self.mode in (\"1\", \"L\", \"P\"):\n            h = self.im.histogram()\n            out = [(h[i], i) for i in range(256) if h[i]]\n            if len(out) > maxcolors:\n                return None\n            return out\n        return self.im.getcolors(maxcolors)\n\n    def getdata(self, band: int | None = None):\n        \"\"\"\n        Returns the contents of this image as a sequence object\n        containing pixel values.  The sequence object is flattened, so\n        that values for line one follow directly after the values of\n        line zero, and so on.\n\n        Note that the sequence object returned by this method is an\n        internal PIL data type, which only supports certain sequence\n        operations.  To convert it to an ordinary sequence (e.g. for\n        printing), use ``list(im.getdata())``.\n\n        :param band: What band to return.  The default is to return\n           all bands.  To return a single band, pass in the index\n           value (e.g. 0 to get the \"R\" band from an \"RGB\" image).\n        :returns: A sequence-like object.\n        \"\"\"\n\n        self.load()\n        if band is not None:\n            return self.im.getband(band)\n        return self.im  # could be abused\n\n    def getextrema(self) -> tuple[float, float] | tuple[tuple[int, int], ...]:\n        \"\"\"\n        Gets the minimum and maximum pixel values for each band in\n        the image.\n\n        :returns: For a single-band image, a 2-tuple containing the\n           minimum and maximum pixel value.  For a multi-band image,\n           a tuple containing one 2-tuple for each band.\n        \"\"\"\n\n        self.load()\n        if self.im.bands > 1:\n            return tuple(self.im.getband(i).getextrema() for i in range(self.im.bands))\n        return self.im.getextrema()\n\n    def getxmp(self):\n        \"\"\"\n        Returns a dictionary containing the XMP tags.\n        Requires defusedxml to be installed.\n\n        :returns: XMP tags in a dictionary.\n        \"\"\"\n\n        def get_name(tag: str) -> str:\n            return re.sub(\"^{[^}]+}\", \"\", tag)\n\n        def get_value(element):\n            value = {get_name(k): v for k, v in element.attrib.items()}\n            children = list(element)\n            if children:\n                for child in children:\n                    name = get_name(child.tag)\n                    child_value = get_value(child)\n                    if name in value:\n                        if not isinstance(value[name], list):\n                            value[name] = [value[name]]\n                        value[name].append(child_value)\n                    else:\n                        value[name] = child_value\n            elif value:\n                if element.text:\n                    value[\"text\"] = element.text\n            else:\n                return element.text\n            return value\n\n        if ElementTree is None:\n            warnings.warn(\"XMP data cannot be read without defusedxml dependency\")\n            return {}\n        if \"xmp\" not in self.info:\n            return {}\n        root = ElementTree.fromstring(self.info[\"xmp\"])\n        return {get_name(root.tag): get_value(root)}\n\n    def getexif(self) -> Exif:\n        \"\"\"\n        Gets EXIF data from the image.\n\n        :returns: an :py:class:`~PIL.Image.Exif` object.\n        \"\"\"\n        if self._exif is None:\n            self._exif = Exif()\n        elif self._exif._loaded:\n            return self._exif\n        self._exif._loaded = True\n\n        exif_info = self.info.get(\"exif\")\n        if exif_info is None:\n            if \"Raw profile type exif\" in self.info:\n                exif_info = bytes.fromhex(\n                    \"\".join(self.info[\"Raw profile type exif\"].split(\"\\n\")[3:])\n                )\n            elif hasattr(self, \"tag_v2\"):\n                self._exif.bigtiff = self.tag_v2._bigtiff\n                self._exif.endian = self.tag_v2._endian\n                self._exif.load_from_fp(self.fp, self.tag_v2._offset)\n        if exif_info is not None:\n            self._exif.load(exif_info)\n\n        # XMP tags\n        if ExifTags.Base.Orientation not in self._exif:\n            xmp_tags = self.info.get(\"XML:com.adobe.xmp\")\n            if xmp_tags:\n                match = re.search(r'tiff:Orientation(=\"|>)([0-9])', xmp_tags)\n                if match:\n                    self._exif[ExifTags.Base.Orientation] = int(match[2])\n\n        return self._exif\n\n    def _reload_exif(self) -> None:\n        if self._exif is None or not self._exif._loaded:\n            return\n        self._exif._loaded = False\n        self.getexif()\n\n    def get_child_images(self) -> list[ImageFile.ImageFile]:\n        child_images = []\n        exif = self.getexif()\n        ifds = []\n        if ExifTags.Base.SubIFDs in exif:\n            subifd_offsets = exif[ExifTags.Base.SubIFDs]\n            if subifd_offsets:\n                if not isinstance(subifd_offsets, tuple):\n                    subifd_offsets = (subifd_offsets,)\n                for subifd_offset in subifd_offsets:\n                    ifds.append((exif._get_ifd_dict(subifd_offset), subifd_offset))\n        ifd1 = exif.get_ifd(ExifTags.IFD.IFD1)\n        if ifd1 and ifd1.get(513):\n            ifds.append((ifd1, exif._info.next))\n\n        offset = None\n        for ifd, ifd_offset in ifds:\n            current_offset = self.fp.tell()\n            if offset is None:\n                offset = current_offset\n\n            fp = self.fp\n            thumbnail_offset = ifd.get(513)\n            if thumbnail_offset is not None:\n                thumbnail_offset += getattr(self, \"_exif_offset\", 0)\n                self.fp.seek(thumbnail_offset)\n                data = self.fp.read(ifd.get(514))\n                fp = io.BytesIO(data)\n\n            with open(fp) as im:\n                from . import TiffImagePlugin\n\n                if thumbnail_offset is None and isinstance(\n                    im, TiffImagePlugin.TiffImageFile\n                ):\n                    im._frame_pos = [ifd_offset]\n                    im._seek(0)\n                im.load()\n                child_images.append(im)\n\n        if offset is not None:\n            self.fp.seek(offset)\n        return child_images\n\n    def getim(self):\n        \"\"\"\n        Returns a capsule that points to the internal image memory.\n\n        :returns: A capsule object.\n        \"\"\"\n\n        self.load()\n        return self.im.ptr\n\n    def getpalette(self, rawmode: str | None = \"RGB\") -> list[int] | None:\n        \"\"\"\n        Returns the image palette as a list.\n\n        :param rawmode: The mode in which to return the palette. ``None`` will\n           return the palette in its current mode.\n\n           .. versionadded:: 9.1.0\n\n        :returns: A list of color values [r, g, b, ...], or None if the\n           image has no palette.\n        \"\"\"\n\n        self.load()\n        try:\n            mode = self.im.getpalettemode()\n        except ValueError:\n            return None  # no palette\n        if rawmode is None:\n            rawmode = mode\n        return list(self.im.getpalette(mode, rawmode))\n\n    @property\n    def has_transparency_data(self) -> bool:\n        \"\"\"\n        Determine if an image has transparency data, whether in the form of an\n        alpha channel, a palette with an alpha channel, or a \"transparency\" key\n        in the info dictionary.\n\n        Note the image might still appear solid, if all of the values shown\n        within are opaque.\n\n        :returns: A boolean.\n        \"\"\"\n        return (\n            self.mode in (\"LA\", \"La\", \"PA\", \"RGBA\", \"RGBa\")\n            or (self.mode == \"P\" and self.palette.mode.endswith(\"A\"))\n            or \"transparency\" in self.info\n        )\n\n    def apply_transparency(self) -> None:\n        \"\"\"\n        If a P mode image has a \"transparency\" key in the info dictionary,\n        remove the key and instead apply the transparency to the palette.\n        Otherwise, the image is unchanged.\n        \"\"\"\n        if self.mode != \"P\" or \"transparency\" not in self.info:\n            return\n\n        from . import ImagePalette\n\n        palette = self.getpalette(\"RGBA\")\n        assert palette is not None\n        transparency = self.info[\"transparency\"]\n        if isinstance(transparency, bytes):\n            for i, alpha in enumerate(transparency):\n                palette[i * 4 + 3] = alpha\n        else:\n            palette[transparency * 4 + 3] = 0\n        self.palette = ImagePalette.ImagePalette(\"RGBA\", bytes(palette))\n        self.palette.dirty = 1\n\n        del self.info[\"transparency\"]\n\n    def getpixel(self, xy):\n        \"\"\"\n        Returns the pixel value at a given position.\n\n        :param xy: The coordinate, given as (x, y). See\n           :ref:`coordinate-system`.\n        :returns: The pixel value.  If the image is a multi-layer image,\n           this method returns a tuple.\n        \"\"\"\n\n        self.load()\n        if self.pyaccess:\n            return self.pyaccess.getpixel(xy)\n        return self.im.getpixel(tuple(xy))\n\n    def getprojection(self) -> tuple[list[int], list[int]]:\n        \"\"\"\n        Get projection to x and y axes\n\n        :returns: Two sequences, indicating where there are non-zero\n            pixels along the X-axis and the Y-axis, respectively.\n        \"\"\"\n\n        self.load()\n        x, y = self.im.getprojection()\n        return list(x), list(y)\n\n    def histogram(self, mask: Image | None = None, extrema=None) -> list[int]:\n        \"\"\"\n        Returns a histogram for the image. The histogram is returned as a\n        list of pixel counts, one for each pixel value in the source\n        image. Counts are grouped into 256 bins for each band, even if\n        the image has more than 8 bits per band. If the image has more\n        than one band, the histograms for all bands are concatenated (for\n        example, the histogram for an \"RGB\" image contains 768 values).\n\n        A bilevel image (mode \"1\") is treated as a grayscale (\"L\") image\n        by this method.\n\n        If a mask is provided, the method returns a histogram for those\n        parts of the image where the mask image is non-zero. The mask\n        image must have the same size as the image, and be either a\n        bi-level image (mode \"1\") or a grayscale image (\"L\").\n\n        :param mask: An optional mask.\n        :param extrema: An optional tuple of manually-specified extrema.\n        :returns: A list containing pixel counts.\n        \"\"\"\n        self.load()\n        if mask:\n            mask.load()\n            return self.im.histogram((0, 0), mask.im)\n        if self.mode in (\"I\", \"F\"):\n            if extrema is None:\n                extrema = self.getextrema()\n            return self.im.histogram(extrema)\n        return self.im.histogram()\n\n    def entropy(self, mask=None, extrema=None):\n        \"\"\"\n        Calculates and returns the entropy for the image.\n\n        A bilevel image (mode \"1\") is treated as a grayscale (\"L\")\n        image by this method.\n\n        If a mask is provided, the method employs the histogram for\n        those parts of the image where the mask image is non-zero.\n        The mask image must have the same size as the image, and be\n        either a bi-level image (mode \"1\") or a grayscale image (\"L\").\n\n        :param mask: An optional mask.\n        :param extrema: An optional tuple of manually-specified extrema.\n        :returns: A float value representing the image entropy\n        \"\"\"\n        self.load()\n        if mask:\n            mask.load()\n            return self.im.entropy((0, 0), mask.im)\n        if self.mode in (\"I\", \"F\"):\n            if extrema is None:\n                extrema = self.getextrema()\n            return self.im.entropy(extrema)\n        return self.im.entropy()\n\n    def paste(\n        self,\n        im: Image | str | float | tuple[float, ...],\n        box: Image | tuple[int, int, int, int] | tuple[int, int] | None = None,\n        mask: Image | None = None,\n    ) -> None:\n        \"\"\"\n        Pastes another image into this image. The box argument is either\n        a 2-tuple giving the upper left corner, a 4-tuple defining the\n        left, upper, right, and lower pixel coordinate, or None (same as\n        (0, 0)). See :ref:`coordinate-system`. If a 4-tuple is given, the size\n        of the pasted image must match the size of the region.\n\n        If the modes don't match, the pasted image is converted to the mode of\n        this image (see the :py:meth:`~PIL.Image.Image.convert` method for\n        details).\n\n        Instead of an image, the source can be a integer or tuple\n        containing pixel values.  The method then fills the region\n        with the given color.  When creating RGB images, you can\n        also use color strings as supported by the ImageColor module.\n\n        If a mask is given, this method updates only the regions\n        indicated by the mask. You can use either \"1\", \"L\", \"LA\", \"RGBA\"\n        or \"RGBa\" images (if present, the alpha band is used as mask).\n        Where the mask is 255, the given image is copied as is.  Where\n        the mask is 0, the current value is preserved.  Intermediate\n        values will mix the two images together, including their alpha\n        channels if they have them.\n\n        See :py:meth:`~PIL.Image.Image.alpha_composite` if you want to\n        combine images with respect to their alpha channels.\n\n        :param im: Source image or pixel value (integer, float or tuple).\n        :param box: An optional 4-tuple giving the region to paste into.\n           If a 2-tuple is used instead, it's treated as the upper left\n           corner.  If omitted or None, the source is pasted into the\n           upper left corner.\n\n           If an image is given as the second argument and there is no\n           third, the box defaults to (0, 0), and the second argument\n           is interpreted as a mask image.\n        :param mask: An optional mask image.\n        \"\"\"\n\n        if isImageType(box):\n            if mask is not None:\n                msg = \"If using second argument as mask, third argument must be None\"\n                raise ValueError(msg)\n            # abbreviated paste(im, mask) syntax\n            mask = box\n            box = None\n        assert not isinstance(box, Image)\n\n        if box is None:\n            box = (0, 0)\n\n        if len(box) == 2:\n            # upper left corner given; get size from image or mask\n            if isImageType(im):\n                size = im.size\n            elif isImageType(mask):\n                size = mask.size\n            else:\n                # FIXME: use self.size here?\n                msg = \"cannot determine region size; use 4-item box\"\n                raise ValueError(msg)\n            box += (box[0] + size[0], box[1] + size[1])\n\n        if isinstance(im, str):\n            from . import ImageColor\n\n            im = ImageColor.getcolor(im, self.mode)\n\n        elif isImageType(im):\n            im.load()\n            if self.mode != im.mode:\n                if self.mode != \"RGB\" or im.mode not in (\"LA\", \"RGBA\", \"RGBa\"):\n                    # should use an adapter for this!\n                    im = im.convert(self.mode)\n            im = im.im\n\n        self._ensure_mutable()\n\n        if mask:\n            mask.load()\n            self.im.paste(im, box, mask.im)\n        else:\n            self.im.paste(im, box)\n\n    def alpha_composite(\n        self, im: Image, dest: Sequence[int] = (0, 0), source: Sequence[int] = (0, 0)\n    ) -> None:\n        \"\"\"'In-place' analog of Image.alpha_composite. Composites an image\n        onto this image.\n\n        :param im: image to composite over this one\n        :param dest: Optional 2 tuple (left, top) specifying the upper\n          left corner in this (destination) image.\n        :param source: Optional 2 (left, top) tuple for the upper left\n          corner in the overlay source image, or 4 tuple (left, top, right,\n          bottom) for the bounds of the source rectangle\n\n        Performance Note: Not currently implemented in-place in the core layer.\n        \"\"\"\n\n        if not isinstance(source, (list, tuple)):\n            msg = \"Source must be a list or tuple\"\n            raise ValueError(msg)\n        if not isinstance(dest, (list, tuple)):\n            msg = \"Destination must be a list or tuple\"\n            raise ValueError(msg)\n\n        if len(source) == 4:\n            overlay_crop_box = tuple(source)\n        elif len(source) == 2:\n            overlay_crop_box = tuple(source) + im.size\n        else:\n            msg = \"Source must be a sequence of length 2 or 4\"\n            raise ValueError(msg)\n\n        if not len(dest) == 2:\n            msg = \"Destination must be a sequence of length 2\"\n            raise ValueError(msg)\n        if min(source) < 0:\n            msg = \"Source must be non-negative\"\n            raise ValueError(msg)\n\n        # over image, crop if it's not the whole image.\n        if overlay_crop_box == (0, 0) + im.size:\n            overlay = im\n        else:\n            overlay = im.crop(overlay_crop_box)\n\n        # target for the paste\n        box = tuple(dest) + (dest[0] + overlay.width, dest[1] + overlay.height)\n\n        # destination image. don't copy if we're using the whole image.\n        if box == (0, 0) + self.size:\n            background = self\n        else:\n            background = self.crop(box)\n\n        result = alpha_composite(background, overlay)\n        self.paste(result, box)\n\n    def point(\n        self,\n        lut: Sequence[float] | Callable[[int], float] | ImagePointHandler,\n        mode: str | None = None,\n    ) -> Image:\n        \"\"\"\n        Maps this image through a lookup table or function.\n\n        :param lut: A lookup table, containing 256 (or 65536 if\n           self.mode==\"I\" and mode == \"L\") values per band in the\n           image.  A function can be used instead, it should take a\n           single argument. The function is called once for each\n           possible pixel value, and the resulting table is applied to\n           all bands of the image.\n\n           It may also be an :py:class:`~PIL.Image.ImagePointHandler`\n           object::\n\n               class Example(Image.ImagePointHandler):\n                 def point(self, data):\n                   # Return result\n        :param mode: Output mode (default is same as input). This can only be used if\n           the source image has mode \"L\" or \"P\", and the output has mode \"1\" or the\n           source image mode is \"I\" and the output mode is \"L\".\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        self.load()\n\n        if isinstance(lut, ImagePointHandler):\n            return lut.point(self)\n\n        if callable(lut):\n            # if it isn't a list, it should be a function\n            if self.mode in (\"I\", \"I;16\", \"F\"):\n                # check if the function can be used with point_transform\n                # UNDONE wiredfool -- I think this prevents us from ever doing\n                # a gamma function point transform on > 8bit images.\n                scale, offset = _getscaleoffset(lut)\n                return self._new(self.im.point_transform(scale, offset))\n            # for other modes, convert the function to a table\n            flatLut = [lut(i) for i in range(256)] * self.im.bands\n        else:\n            flatLut = lut\n\n        if self.mode == \"F\":\n            # FIXME: _imaging returns a confusing error message for this case\n            msg = \"point operation not supported for this mode\"\n            raise ValueError(msg)\n\n        if mode != \"F\":\n            flatLut = [round(i) for i in flatLut]\n        return self._new(self.im.point(flatLut, mode))\n\n    def putalpha(self, alpha):\n        \"\"\"\n        Adds or replaces the alpha layer in this image.  If the image\n        does not have an alpha layer, it's converted to \"LA\" or \"RGBA\".\n        The new layer must be either \"L\" or \"1\".\n\n        :param alpha: The new alpha layer.  This can either be an \"L\" or \"1\"\n           image having the same size as this image, or an integer or\n           other color value.\n        \"\"\"\n\n        self._ensure_mutable()\n\n        if self.mode not in (\"LA\", \"PA\", \"RGBA\"):\n            # attempt to promote self to a matching alpha mode\n            try:\n                mode = getmodebase(self.mode) + \"A\"\n                try:\n                    self.im.setmode(mode)\n                except (AttributeError, ValueError) as e:\n                    # do things the hard way\n                    im = self.im.convert(mode)\n                    if im.mode not in (\"LA\", \"PA\", \"RGBA\"):\n                        msg = \"alpha channel could not be added\"\n                        raise ValueError(msg) from e  # sanity check\n                    self.im = im\n                self.pyaccess = None\n                self._mode = self.im.mode\n            except KeyError as e:\n                msg = \"illegal image mode\"\n                raise ValueError(msg) from e\n\n        if self.mode in (\"LA\", \"PA\"):\n            band = 1\n        else:\n            band = 3\n\n        if isImageType(alpha):\n            # alpha layer\n            if alpha.mode not in (\"1\", \"L\"):\n                msg = \"illegal image mode\"\n                raise ValueError(msg)\n            alpha.load()\n            if alpha.mode == \"1\":\n                alpha = alpha.convert(\"L\")\n        else:\n            # constant alpha\n            try:\n                self.im.fillband(band, alpha)\n            except (AttributeError, ValueError):\n                # do things the hard way\n                alpha = new(\"L\", self.size, alpha)\n            else:\n                return\n\n        self.im.putband(alpha.im, band)\n\n    def putdata(\n        self,\n        data: Sequence[float] | Sequence[Sequence[int]],\n        scale: float = 1.0,\n        offset: float = 0.0,\n    ) -> None:\n        \"\"\"\n        Copies pixel data from a flattened sequence object into the image. The\n        values should start at the upper left corner (0, 0), continue to the\n        end of the line, followed directly by the first value of the second\n        line, and so on. Data will be read until either the image or the\n        sequence ends. The scale and offset values are used to adjust the\n        sequence values: **pixel = value*scale + offset**.\n\n        :param data: A flattened sequence object.\n        :param scale: An optional scale value.  The default is 1.0.\n        :param offset: An optional offset value.  The default is 0.0.\n        \"\"\"\n\n        self._ensure_mutable()\n\n        self.im.putdata(data, scale, offset)\n\n    def putpalette(self, data, rawmode=\"RGB\") -> None:\n        \"\"\"\n        Attaches a palette to this image.  The image must be a \"P\", \"PA\", \"L\"\n        or \"LA\" image.\n\n        The palette sequence must contain at most 256 colors, made up of one\n        integer value for each channel in the raw mode.\n        For example, if the raw mode is \"RGB\", then it can contain at most 768\n        values, made up of red, green and blue values for the corresponding pixel\n        index in the 256 colors.\n        If the raw mode is \"RGBA\", then it can contain at most 1024 values,\n        containing red, green, blue and alpha values.\n\n        Alternatively, an 8-bit string may be used instead of an integer sequence.\n\n        :param data: A palette sequence (either a list or a string).\n        :param rawmode: The raw mode of the palette. Either \"RGB\", \"RGBA\", or a mode\n           that can be transformed to \"RGB\" or \"RGBA\" (e.g. \"R\", \"BGR;15\", \"RGBA;L\").\n        \"\"\"\n        from . import ImagePalette\n\n        if self.mode not in (\"L\", \"LA\", \"P\", \"PA\"):\n            msg = \"illegal image mode\"\n            raise ValueError(msg)\n        if isinstance(data, ImagePalette.ImagePalette):\n            palette = ImagePalette.raw(data.rawmode, data.palette)\n        else:\n            if not isinstance(data, bytes):\n                data = bytes(data)\n            palette = ImagePalette.raw(rawmode, data)\n        self._mode = \"PA\" if \"A\" in self.mode else \"P\"\n        self.palette = palette\n        self.palette.mode = \"RGBA\" if \"A\" in rawmode else \"RGB\"\n        self.load()  # install new palette\n\n    def putpixel(self, xy, value):\n        \"\"\"\n        Modifies the pixel at the given position. The color is given as\n        a single numerical value for single-band images, and a tuple for\n        multi-band images. In addition to this, RGB and RGBA tuples are\n        accepted for P and PA images.\n\n        Note that this method is relatively slow.  For more extensive changes,\n        use :py:meth:`~PIL.Image.Image.paste` or the :py:mod:`~PIL.ImageDraw`\n        module instead.\n\n        See:\n\n        * :py:meth:`~PIL.Image.Image.paste`\n        * :py:meth:`~PIL.Image.Image.putdata`\n        * :py:mod:`~PIL.ImageDraw`\n\n        :param xy: The pixel coordinate, given as (x, y). See\n           :ref:`coordinate-system`.\n        :param value: The pixel value.\n        \"\"\"\n\n        if self.readonly:\n            self._copy()\n        self.load()\n\n        if self.pyaccess:\n            return self.pyaccess.putpixel(xy, value)\n\n        if (\n            self.mode in (\"P\", \"PA\")\n            and isinstance(value, (list, tuple))\n            and len(value) in [3, 4]\n        ):\n            # RGB or RGBA value for a P or PA image\n            if self.mode == \"PA\":\n                alpha = value[3] if len(value) == 4 else 255\n                value = value[:3]\n            value = self.palette.getcolor(value, self)\n            if self.mode == \"PA\":\n                value = (value, alpha)\n        return self.im.putpixel(xy, value)\n\n    def remap_palette(self, dest_map, source_palette=None):\n        \"\"\"\n        Rewrites the image to reorder the palette.\n\n        :param dest_map: A list of indexes into the original palette.\n           e.g. ``[1,0]`` would swap a two item palette, and ``list(range(256))``\n           is the identity transform.\n        :param source_palette: Bytes or None.\n        :returns:  An :py:class:`~PIL.Image.Image` object.\n\n        \"\"\"\n        from . import ImagePalette\n\n        if self.mode not in (\"L\", \"P\"):\n            msg = \"illegal image mode\"\n            raise ValueError(msg)\n\n        bands = 3\n        palette_mode = \"RGB\"\n        if source_palette is None:\n            if self.mode == \"P\":\n                self.load()\n                palette_mode = self.im.getpalettemode()\n                if palette_mode == \"RGBA\":\n                    bands = 4\n                source_palette = self.im.getpalette(palette_mode, palette_mode)\n            else:  # L-mode\n                source_palette = bytearray(i // 3 for i in range(768))\n\n        palette_bytes = b\"\"\n        new_positions = [0] * 256\n\n        # pick only the used colors from the palette\n        for i, oldPosition in enumerate(dest_map):\n            palette_bytes += source_palette[\n                oldPosition * bands : oldPosition * bands + bands\n            ]\n            new_positions[oldPosition] = i\n\n        # replace the palette color id of all pixel with the new id\n\n        # Palette images are [0..255], mapped through a 1 or 3\n        # byte/color map.  We need to remap the whole image\n        # from palette 1 to palette 2. New_positions is\n        # an array of indexes into palette 1.  Palette 2 is\n        # palette 1 with any holes removed.\n\n        # We're going to leverage the convert mechanism to use the\n        # C code to remap the image from palette 1 to palette 2,\n        # by forcing the source image into 'L' mode and adding a\n        # mapping 'L' mode palette, then converting back to 'L'\n        # sans palette thus converting the image bytes, then\n        # assigning the optimized RGB palette.\n\n        # perf reference, 9500x4000 gif, w/~135 colors\n        # 14 sec prepatch, 1 sec postpatch with optimization forced.\n\n        mapping_palette = bytearray(new_positions)\n\n        m_im = self.copy()\n        m_im._mode = \"P\"\n\n        m_im.palette = ImagePalette.ImagePalette(\n            palette_mode, palette=mapping_palette * bands\n        )\n        # possibly set palette dirty, then\n        # m_im.putpalette(mapping_palette, 'L')  # converts to 'P'\n        # or just force it.\n        # UNDONE -- this is part of the general issue with palettes\n        m_im.im.putpalette(palette_mode, palette_mode + \";L\", m_im.palette.tobytes())\n\n        m_im = m_im.convert(\"L\")\n\n        m_im.putpalette(palette_bytes, palette_mode)\n        m_im.palette = ImagePalette.ImagePalette(palette_mode, palette=palette_bytes)\n\n        if \"transparency\" in self.info:\n            try:\n                m_im.info[\"transparency\"] = dest_map.index(self.info[\"transparency\"])\n            except ValueError:\n                if \"transparency\" in m_im.info:\n                    del m_im.info[\"transparency\"]\n\n        return m_im\n\n    def _get_safe_box(self, size, resample, box):\n        \"\"\"Expands the box so it includes adjacent pixels\n        that may be used by resampling with the given resampling filter.\n        \"\"\"\n        filter_support = _filters_support[resample] - 0.5\n        scale_x = (box[2] - box[0]) / size[0]\n        scale_y = (box[3] - box[1]) / size[1]\n        support_x = filter_support * scale_x\n        support_y = filter_support * scale_y\n\n        return (\n            max(0, int(box[0] - support_x)),\n            max(0, int(box[1] - support_y)),\n            min(self.size[0], math.ceil(box[2] + support_x)),\n            min(self.size[1], math.ceil(box[3] + support_y)),\n        )\n\n    def resize(\n        self,\n        size: tuple[int, int],\n        resample: int | None = None,\n        box: tuple[float, float, float, float] | None = None,\n        reducing_gap: float | None = None,\n    ) -> Image:\n        \"\"\"\n        Returns a resized copy of this image.\n\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        :param resample: An optional resampling filter.  This can be\n           one of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n           :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n           :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n           If the image has mode \"1\" or \"P\", it is always set to\n           :py:data:`Resampling.NEAREST`. If the image mode specifies a number\n           of bits, such as \"I;16\", then the default filter is\n           :py:data:`Resampling.NEAREST`. Otherwise, the default filter is\n           :py:data:`Resampling.BICUBIC`. See: :ref:`concept-filters`.\n        :param box: An optional 4-tuple of floats providing\n           the source image region to be scaled.\n           The values must be within (0, 0, width, height) rectangle.\n           If omitted or None, the entire source is used.\n        :param reducing_gap: Apply optimization by resizing the image\n           in two steps. First, reducing the image by integer times\n           using :py:meth:`~PIL.Image.Image.reduce`.\n           Second, resizing using regular resampling. The last step\n           changes size no less than by ``reducing_gap`` times.\n           ``reducing_gap`` may be None (no first step is performed)\n           or should be greater than 1.0. The bigger ``reducing_gap``,\n           the closer the result to the fair resampling.\n           The smaller ``reducing_gap``, the faster resizing.\n           With ``reducing_gap`` greater or equal to 3.0, the result is\n           indistinguishable from fair resampling in most cases.\n           The default value is None (no optimization).\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if resample is None:\n            type_special = \";\" in self.mode\n            resample = Resampling.NEAREST if type_special else Resampling.BICUBIC\n        elif resample not in (\n            Resampling.NEAREST,\n            Resampling.BILINEAR,\n            Resampling.BICUBIC,\n            Resampling.LANCZOS,\n            Resampling.BOX,\n            Resampling.HAMMING,\n        ):\n            msg = f\"Unknown resampling filter ({resample}).\"\n\n            filters = [\n                f\"{filter[1]} ({filter[0]})\"\n                for filter in (\n                    (Resampling.NEAREST, \"Image.Resampling.NEAREST\"),\n                    (Resampling.LANCZOS, \"Image.Resampling.LANCZOS\"),\n                    (Resampling.BILINEAR, \"Image.Resampling.BILINEAR\"),\n                    (Resampling.BICUBIC, \"Image.Resampling.BICUBIC\"),\n                    (Resampling.BOX, \"Image.Resampling.BOX\"),\n                    (Resampling.HAMMING, \"Image.Resampling.HAMMING\"),\n                )\n            ]\n            msg += f\" Use {', '.join(filters[:-1])} or {filters[-1]}\"\n            raise ValueError(msg)\n\n        if reducing_gap is not None and reducing_gap < 1.0:\n            msg = \"reducing_gap must be 1.0 or greater\"\n            raise ValueError(msg)\n\n        self.load()\n        if box is None:\n            box = (0, 0) + self.size\n\n        if self.size == size and box == (0, 0) + self.size:\n            return self.copy()\n\n        if self.mode in (\"1\", \"P\"):\n            resample = Resampling.NEAREST\n\n        if self.mode in [\"LA\", \"RGBA\"] and resample != Resampling.NEAREST:\n            im = self.convert({\"LA\": \"La\", \"RGBA\": \"RGBa\"}[self.mode])\n            im = im.resize(size, resample, box)\n            return im.convert(self.mode)\n\n        self.load()\n\n        if reducing_gap is not None and resample != Resampling.NEAREST:\n            factor_x = int((box[2] - box[0]) / size[0] / reducing_gap) or 1\n            factor_y = int((box[3] - box[1]) / size[1] / reducing_gap) or 1\n            if factor_x > 1 or factor_y > 1:\n                reduce_box = self._get_safe_box(size, resample, box)\n                factor = (factor_x, factor_y)\n                self = (\n                    self.reduce(factor, box=reduce_box)\n                    if callable(self.reduce)\n                    else Image.reduce(self, factor, box=reduce_box)\n                )\n                box = (\n                    (box[0] - reduce_box[0]) / factor_x,\n                    (box[1] - reduce_box[1]) / factor_y,\n                    (box[2] - reduce_box[0]) / factor_x,\n                    (box[3] - reduce_box[1]) / factor_y,\n                )\n\n        return self._new(self.im.resize(size, resample, box))\n\n    def reduce(\n        self,\n        factor: int | tuple[int, int],\n        box: tuple[int, int, int, int] | None = None,\n    ) -> Image:\n        \"\"\"\n        Returns a copy of the image reduced ``factor`` times.\n        If the size of the image is not dividable by ``factor``,\n        the resulting size will be rounded up.\n\n        :param factor: A greater than 0 integer or tuple of two integers\n           for width and height separately.\n        :param box: An optional 4-tuple of ints providing\n           the source image region to be reduced.\n           The values must be within ``(0, 0, width, height)`` rectangle.\n           If omitted or ``None``, the entire source is used.\n        \"\"\"\n        if not isinstance(factor, (list, tuple)):\n            factor = (factor, factor)\n\n        if box is None:\n            box = (0, 0) + self.size\n\n        if factor == (1, 1) and box == (0, 0) + self.size:\n            return self.copy()\n\n        if self.mode in [\"LA\", \"RGBA\"]:\n            im = self.convert({\"LA\": \"La\", \"RGBA\": \"RGBa\"}[self.mode])\n            im = im.reduce(factor, box)\n            return im.convert(self.mode)\n\n        self.load()\n\n        return self._new(self.im.reduce(factor, box))\n\n    def rotate(\n        self,\n        angle: float,\n        resample: Resampling = Resampling.NEAREST,\n        expand: int | bool = False,\n        center: tuple[int, int] | None = None,\n        translate: tuple[int, int] | None = None,\n        fillcolor: float | tuple[float, ...] | str | None = None,\n    ) -> Image:\n        \"\"\"\n        Returns a rotated copy of this image.  This method returns a\n        copy of this image, rotated the given number of degrees counter\n        clockwise around its centre.\n\n        :param angle: In degrees counter clockwise.\n        :param resample: An optional resampling filter.  This can be\n           one of :py:data:`Resampling.NEAREST` (use nearest neighbour),\n           :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment). If omitted, or if the image has\n           mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n           See :ref:`concept-filters`.\n        :param expand: Optional expansion flag.  If true, expands the output\n           image to make it large enough to hold the entire rotated image.\n           If false or omitted, make the output image the same size as the\n           input image.  Note that the expand flag assumes rotation around\n           the center and no translation.\n        :param center: Optional center of rotation (a 2-tuple).  Origin is\n           the upper left corner.  Default is the center of the image.\n        :param translate: An optional post-rotate translation (a 2-tuple).\n        :param fillcolor: An optional color for area outside the rotated image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        angle = angle % 360.0\n\n        # Fast paths regardless of filter, as long as we're not\n        # translating or changing the center.\n        if not (center or translate):\n            if angle == 0:\n                return self.copy()\n            if angle == 180:\n                return self.transpose(Transpose.ROTATE_180)\n            if angle in (90, 270) and (expand or self.width == self.height):\n                return self.transpose(\n                    Transpose.ROTATE_90 if angle == 90 else Transpose.ROTATE_270\n                )\n\n        # Calculate the affine matrix.  Note that this is the reverse\n        # transformation (from destination image to source) because we\n        # want to interpolate the (discrete) destination pixel from\n        # the local area around the (floating) source pixel.\n\n        # The matrix we actually want (note that it operates from the right):\n        # (1, 0, tx)   (1, 0, cx)   ( cos a, sin a, 0)   (1, 0, -cx)\n        # (0, 1, ty) * (0, 1, cy) * (-sin a, cos a, 0) * (0, 1, -cy)\n        # (0, 0,  1)   (0, 0,  1)   (     0,     0, 1)   (0, 0,   1)\n\n        # The reverse matrix is thus:\n        # (1, 0, cx)   ( cos -a, sin -a, 0)   (1, 0, -cx)   (1, 0, -tx)\n        # (0, 1, cy) * (-sin -a, cos -a, 0) * (0, 1, -cy) * (0, 1, -ty)\n        # (0, 0,  1)   (      0,      0, 1)   (0, 0,   1)   (0, 0,   1)\n\n        # In any case, the final translation may be updated at the end to\n        # compensate for the expand flag.\n\n        w, h = self.size\n\n        if translate is None:\n            post_trans = (0, 0)\n        else:\n            post_trans = translate\n        if center is None:\n            # FIXME These should be rounded to ints?\n            rotn_center = (w / 2.0, h / 2.0)\n        else:\n            rotn_center = center\n\n        angle = -math.radians(angle)\n        matrix = [\n            round(math.cos(angle), 15),\n            round(math.sin(angle), 15),\n            0.0,\n            round(-math.sin(angle), 15),\n            round(math.cos(angle), 15),\n            0.0,\n        ]\n\n        def transform(x, y, matrix):\n            (a, b, c, d, e, f) = matrix\n            return a * x + b * y + c, d * x + e * y + f\n\n        matrix[2], matrix[5] = transform(\n            -rotn_center[0] - post_trans[0], -rotn_center[1] - post_trans[1], matrix\n        )\n        matrix[2] += rotn_center[0]\n        matrix[5] += rotn_center[1]\n\n        if expand:\n            # calculate output size\n            xx = []\n            yy = []\n            for x, y in ((0, 0), (w, 0), (w, h), (0, h)):\n                x, y = transform(x, y, matrix)\n                xx.append(x)\n                yy.append(y)\n            nw = math.ceil(max(xx)) - math.floor(min(xx))\n            nh = math.ceil(max(yy)) - math.floor(min(yy))\n\n            # We multiply a translation matrix from the right.  Because of its\n            # special form, this is the same as taking the image of the\n            # translation vector as new translation vector.\n            matrix[2], matrix[5] = transform(-(nw - w) / 2.0, -(nh - h) / 2.0, matrix)\n            w, h = nw, nh\n\n        return self.transform(\n            (w, h), Transform.AFFINE, matrix, resample, fillcolor=fillcolor\n        )\n\n    def save(\n        self, fp: StrOrBytesPath | IO[bytes], format: str | None = None, **params: Any\n    ) -> None:\n        \"\"\"\n        Saves this image under the given filename.  If no format is\n        specified, the format to use is determined from the filename\n        extension, if possible.\n\n        Keyword options can be used to provide additional instructions\n        to the writer. If a writer doesn't recognise an option, it is\n        silently ignored. The available options are described in the\n        :doc:`image format documentation\n        <../handbook/image-file-formats>` for each writer.\n\n        You can use a file object instead of a filename. In this case,\n        you must always specify the format. The file object must\n        implement the ``seek``, ``tell``, and ``write``\n        methods, and be opened in binary mode.\n\n        :param fp: A filename (string), os.PathLike object or file object.\n        :param format: Optional format override.  If omitted, the\n           format to use is determined from the filename extension.\n           If a file object was used instead of a filename, this\n           parameter should always be used.\n        :param params: Extra parameters to the image writer.\n        :returns: None\n        :exception ValueError: If the output format could not be determined\n           from the file name.  Use the format option to solve this.\n        :exception OSError: If the file could not be written.  The file\n           may have been created, and may contain partial data.\n        \"\"\"\n\n        filename: str | bytes = \"\"\n        open_fp = False\n        if is_path(fp):\n            filename = os.path.realpath(os.fspath(fp))\n            open_fp = True\n        elif fp == sys.stdout:\n            try:\n                fp = sys.stdout.buffer\n            except AttributeError:\n                pass\n        if not filename and hasattr(fp, \"name\") and is_path(fp.name):\n            # only set the name for metadata purposes\n            filename = os.path.realpath(os.fspath(fp.name))\n\n        # may mutate self!\n        self._ensure_mutable()\n\n        save_all = params.pop(\"save_all\", False)\n        self.encoderinfo = params\n        self.encoderconfig: tuple[Any, ...] = ()\n\n        preinit()\n\n        filename_ext = os.path.splitext(filename)[1].lower()\n        ext = filename_ext.decode() if isinstance(filename_ext, bytes) else filename_ext\n\n        if not format:\n            if ext not in EXTENSION:\n                init()\n            try:\n                format = EXTENSION[ext]\n            except KeyError as e:\n                msg = f\"unknown file extension: {ext}\"\n                raise ValueError(msg) from e\n\n        if format.upper() not in SAVE:\n            init()\n        if save_all:\n            save_handler = SAVE_ALL[format.upper()]\n        else:\n            save_handler = SAVE[format.upper()]\n\n        created = False\n        if open_fp:\n            created = not os.path.exists(filename)\n            if params.get(\"append\", False):\n                # Open also for reading (\"+\"), because TIFF save_all\n                # writer needs to go back and edit the written data.\n                fp = builtins.open(filename, \"r+b\")\n            else:\n                fp = builtins.open(filename, \"w+b\")\n        else:\n            fp = cast(IO[bytes], fp)\n\n        try:\n            save_handler(self, fp, filename)\n        except Exception:\n            if open_fp:\n                fp.close()\n            if created:\n                try:\n                    os.remove(filename)\n                except PermissionError:\n                    pass\n            raise\n        if open_fp:\n            fp.close()\n\n    def seek(self, frame: int) -> None:\n        \"\"\"\n        Seeks to the given frame in this sequence file. If you seek\n        beyond the end of the sequence, the method raises an\n        ``EOFError`` exception. When a sequence file is opened, the\n        library automatically seeks to frame 0.\n\n        See :py:meth:`~PIL.Image.Image.tell`.\n\n        If defined, :attr:`~PIL.Image.Image.n_frames` refers to the\n        number of available frames.\n\n        :param frame: Frame number, starting at 0.\n        :exception EOFError: If the call attempts to seek beyond the end\n            of the sequence.\n        \"\"\"\n\n        # overridden by file handlers\n        if frame != 0:\n            msg = \"no more images in file\"\n            raise EOFError(msg)\n\n    def show(self, title: str | None = None) -> None:\n        \"\"\"\n        Displays this image. This method is mainly intended for debugging purposes.\n\n        This method calls :py:func:`PIL.ImageShow.show` internally. You can use\n        :py:func:`PIL.ImageShow.register` to override its default behaviour.\n\n        The image is first saved to a temporary file. By default, it will be in\n        PNG format.\n\n        On Unix, the image is then opened using the **xdg-open**, **display**,\n        **gm**, **eog** or **xv** utility, depending on which one can be found.\n\n        On macOS, the image is opened with the native Preview application.\n\n        On Windows, the image is opened with the standard PNG display utility.\n\n        :param title: Optional title to use for the image window, where possible.\n        \"\"\"\n\n        _show(self, title=title)\n\n    def split(self) -> tuple[Image, ...]:\n        \"\"\"\n        Split this image into individual bands. This method returns a\n        tuple of individual image bands from an image. For example,\n        splitting an \"RGB\" image creates three new images each\n        containing a copy of one of the original bands (red, green,\n        blue).\n\n        If you need only one band, :py:meth:`~PIL.Image.Image.getchannel`\n        method can be more convenient and faster.\n\n        :returns: A tuple containing bands.\n        \"\"\"\n\n        self.load()\n        if self.im.bands == 1:\n            return (self.copy(),)\n        return tuple(map(self._new, self.im.split()))\n\n    def getchannel(self, channel: int | str) -> Image:\n        \"\"\"\n        Returns an image containing a single channel of the source image.\n\n        :param channel: What channel to return. Could be index\n          (0 for \"R\" channel of \"RGB\") or channel name\n          (\"A\" for alpha channel of \"RGBA\").\n        :returns: An image in \"L\" mode.\n\n        .. versionadded:: 4.3.0\n        \"\"\"\n        self.load()\n\n        if isinstance(channel, str):\n            try:\n                channel = self.getbands().index(channel)\n            except ValueError as e:\n                msg = f'The image has no channel \"{channel}\"'\n                raise ValueError(msg) from e\n\n        return self._new(self.im.getband(channel))\n\n    def tell(self) -> int:\n        \"\"\"\n        Returns the current frame number. See :py:meth:`~PIL.Image.Image.seek`.\n\n        If defined, :attr:`~PIL.Image.Image.n_frames` refers to the\n        number of available frames.\n\n        :returns: Frame number, starting with 0.\n        \"\"\"\n        return 0\n\n    def thumbnail(\n        self,\n        size: tuple[float, float],\n        resample: Resampling = Resampling.BICUBIC,\n        reducing_gap: float | None = 2.0,\n    ) -> None:\n        \"\"\"\n        Make this image into a thumbnail.  This method modifies the\n        image to contain a thumbnail version of itself, no larger than\n        the given size.  This method calculates an appropriate thumbnail\n        size to preserve the aspect of the image, calls the\n        :py:meth:`~PIL.Image.Image.draft` method to configure the file reader\n        (where applicable), and finally resizes the image.\n\n        Note that this function modifies the :py:class:`~PIL.Image.Image`\n        object in place.  If you need to use the full resolution image as well,\n        apply this method to a :py:meth:`~PIL.Image.Image.copy` of the original\n        image.\n\n        :param size: The requested size in pixels, as a 2-tuple:\n           (width, height).\n        :param resample: Optional resampling filter.  This can be one\n           of :py:data:`Resampling.NEAREST`, :py:data:`Resampling.BOX`,\n           :py:data:`Resampling.BILINEAR`, :py:data:`Resampling.HAMMING`,\n           :py:data:`Resampling.BICUBIC` or :py:data:`Resampling.LANCZOS`.\n           If omitted, it defaults to :py:data:`Resampling.BICUBIC`.\n           (was :py:data:`Resampling.NEAREST` prior to version 2.5.0).\n           See: :ref:`concept-filters`.\n        :param reducing_gap: Apply optimization by resizing the image\n           in two steps. First, reducing the image by integer times\n           using :py:meth:`~PIL.Image.Image.reduce` or\n           :py:meth:`~PIL.Image.Image.draft` for JPEG images.\n           Second, resizing using regular resampling. The last step\n           changes size no less than by ``reducing_gap`` times.\n           ``reducing_gap`` may be None (no first step is performed)\n           or should be greater than 1.0. The bigger ``reducing_gap``,\n           the closer the result to the fair resampling.\n           The smaller ``reducing_gap``, the faster resizing.\n           With ``reducing_gap`` greater or equal to 3.0, the result is\n           indistinguishable from fair resampling in most cases.\n           The default value is 2.0 (very close to fair resampling\n           while still being faster in many cases).\n        :returns: None\n        \"\"\"\n\n        provided_size = tuple(map(math.floor, size))\n\n        def preserve_aspect_ratio() -> tuple[int, int] | None:\n            def round_aspect(number, key):\n                return max(min(math.floor(number), math.ceil(number), key=key), 1)\n\n            x, y = provided_size\n            if x >= self.width and y >= self.height:\n                return None\n\n            aspect = self.width / self.height\n            if x / y >= aspect:\n                x = round_aspect(y * aspect, key=lambda n: abs(aspect - n / y))\n            else:\n                y = round_aspect(\n                    x / aspect, key=lambda n: 0 if n == 0 else abs(aspect - x / n)\n                )\n            return x, y\n\n        box = None\n        final_size: tuple[int, int]\n        if reducing_gap is not None:\n            preserved_size = preserve_aspect_ratio()\n            if preserved_size is None:\n                return\n            final_size = preserved_size\n\n            res = self.draft(\n                None, (int(size[0] * reducing_gap), int(size[1] * reducing_gap))\n            )\n            if res is not None:\n                box = res[1]\n        if box is None:\n            self.load()\n\n            # load() may have changed the size of the image\n            preserved_size = preserve_aspect_ratio()\n            if preserved_size is None:\n                return\n            final_size = preserved_size\n\n        if self.size != final_size:\n            im = self.resize(final_size, resample, box=box, reducing_gap=reducing_gap)\n\n            self.im = im.im\n            self._size = final_size\n            self._mode = self.im.mode\n\n        self.readonly = 0\n        self.pyaccess = None\n\n    # FIXME: the different transform methods need further explanation\n    # instead of bloating the method docs, add a separate chapter.\n    def transform(\n        self,\n        size: tuple[int, int],\n        method: Transform | ImageTransformHandler | SupportsGetData,\n        data: Sequence[Any] | None = None,\n        resample: int = Resampling.NEAREST,\n        fill: int = 1,\n        fillcolor: float | tuple[float, ...] | str | None = None,\n    ) -> Image:\n        \"\"\"\n        Transforms this image.  This method creates a new image with the\n        given size, and the same mode as the original, and copies data\n        to the new image using the given transform.\n\n        :param size: The output size in pixels, as a 2-tuple:\n           (width, height).\n        :param method: The transformation method.  This is one of\n          :py:data:`Transform.EXTENT` (cut out a rectangular subregion),\n          :py:data:`Transform.AFFINE` (affine transform),\n          :py:data:`Transform.PERSPECTIVE` (perspective transform),\n          :py:data:`Transform.QUAD` (map a quadrilateral to a rectangle), or\n          :py:data:`Transform.MESH` (map a number of source quadrilaterals\n          in one operation).\n\n          It may also be an :py:class:`~PIL.Image.ImageTransformHandler`\n          object::\n\n            class Example(Image.ImageTransformHandler):\n                def transform(self, size, data, resample, fill=1):\n                    # Return result\n\n          Implementations of :py:class:`~PIL.Image.ImageTransformHandler`\n          for some of the :py:class:`Transform` methods are provided\n          in :py:mod:`~PIL.ImageTransform`.\n\n          It may also be an object with a ``method.getdata`` method\n          that returns a tuple supplying new ``method`` and ``data`` values::\n\n            class Example:\n                def getdata(self):\n                    method = Image.Transform.EXTENT\n                    data = (0, 0, 100, 100)\n                    return method, data\n        :param data: Extra data to the transformation method.\n        :param resample: Optional resampling filter.  It can be one of\n           :py:data:`Resampling.NEAREST` (use nearest neighbour),\n           :py:data:`Resampling.BILINEAR` (linear interpolation in a 2x2\n           environment), or :py:data:`Resampling.BICUBIC` (cubic spline\n           interpolation in a 4x4 environment). If omitted, or if the image\n           has mode \"1\" or \"P\", it is set to :py:data:`Resampling.NEAREST`.\n           See: :ref:`concept-filters`.\n        :param fill: If ``method`` is an\n          :py:class:`~PIL.Image.ImageTransformHandler` object, this is one of\n          the arguments passed to it. Otherwise, it is unused.\n        :param fillcolor: Optional fill color for the area outside the\n           transform in the output image.\n        :returns: An :py:class:`~PIL.Image.Image` object.\n        \"\"\"\n\n        if self.mode in (\"LA\", \"RGBA\") and resample != Resampling.NEAREST:\n            return (\n                self.convert({\"LA\": \"La\", \"RGBA\": \"RGBa\"}[self.mode])\n                .transform(size, method, data, resample, fill, fillcolor)\n                .convert(self.mode)\n            )\n\n        if isinstance(method, ImageTransformHandler):\n            return method.transform(size, self, resample=resample, fill=fill)\n\n        if hasattr(method, \"getdata\"):\n            # compatibility w. old-style transform objects\n            method, data = method.getdata()\n\n        if data is None:\n            msg = \"missing method data\"\n            raise ValueError(msg)\n\n        im = new(self.mode, size, fillcolor)\n        if self.mode == \"P\" and self.palette:\n            im.palette = self.palette.copy()\n        im.info = self.info.copy()\n        if method == Transform.MESH:\n            # list of quads\n            for box, quad in data:\n                im.__transformer(\n                    box, self, Transform.QUAD, quad, resample, fillcolor is None\n                )\n        else:\n            im.__transformer(\n                (0, 0) + size, self, method, data, resample, fillcolor is None\n            )\n\n        return im\n\n    def __transformer(\n        self, box, image, method, data, resample=Resampling.NEAREST, fill=1\n    ):\n        w = box[2] - box[0]\n        h = box[3] - box[1]\n\n        if method == Transform.AFFINE:\n            data = data[:6]\n\n        elif method == Transform.EXTENT:\n            # convert extent to an affine transform\n            x0, y0, x1, y1 = data\n            xs = (x1 - x0) / w\n            ys = (y1 - y0) / h\n            method = Transform.AFFINE\n            data = (xs, 0, x0, 0, ys, y0)\n\n        elif method == Transform.PERSPECTIVE:\n            data = data[:8]\n\n        elif method == Transform.QUAD:\n            # quadrilateral warp.  data specifies the four corners\n            # given as NW, SW, SE, and NE.\n            nw = data[:2]\n            sw = data[2:4]\n            se = data[4:6]\n            ne = data[6:8]\n            x0, y0 = nw\n            As = 1.0 / w\n            At = 1.0 / h\n            data = (\n                x0,\n                (ne[0] - x0) * As,\n                (sw[0] - x0) * At,\n                (se[0] - sw[0] - ne[0] + x0) * As * At,\n                y0,\n                (ne[1] - y0) * As,\n                (sw[1] - y0) * At,\n                (se[1] - sw[1] - ne[1] + y0) * As * At,\n            )\n\n        else:\n            msg = \"unknown transformation method\"\n            raise ValueError(msg)\n\n        if resample not in (\n            Resampling.NEAREST,\n            Resampling.BILINEAR,\n            Resampling.BICUBIC,\n        ):\n            if resample in (Resampling.BOX, Resampling.HAMMING, Resampling.LANCZOS):\n                msg = {\n                    Resampling.BOX: \"Image.Resampling.BOX\",\n                    Resampling.HAMMING: \"Image.Resampling.HAMMING\",\n                    Resampling.LANCZOS: \"Image.Resampling.LANCZOS\",\n                }[resample] + f\" ({resample}) cannot be used.\"\n            else:\n                msg = f\"Unknown resampling filter ({resample}).\"\n\n            filters = [\n                f\"{filter[1]} ({filter[0]})\"\n                for filter in (\n                    (Resampling.NEAREST, \"Image.Resampling.NEAREST\"),\n                    (Resampling.BILINEAR, \"Image.Resampling.BILINEAR\"),\n                    (Resampling.BICUBIC, \"Image.Resampling.BICUBIC\"),\n                )\n            ]\n            msg += f\" Use {', '.join(filters[:-1])} or {filters[-1]}\"\n            raise ValueError(msg)\n\n        image.load()\n\n        self.load()\n\n        if image.mode in (\"1\", \"P\"):\n            resample = Resampling.NEAREST\n\n        self.im.transform(box, image.im, method, data, resample, fill)\n\n    def transpose(self, method: Transpose) -> Image:\n        \"\"\"\n        Transpose image (flip or rotate in 90 degree steps)\n\n        :param method: One of :py:data:`Transpose.FLIP_LEFT_RIGHT`,\n          :py:data:`Transpose.FLIP_TOP_BOTTOM`, :py:data:`Transpose.ROTATE_90`,\n          :py:data:`Transpose.ROTATE_180`, :py:data:`Transpose.ROTATE_270`,\n          :py:data:`Transpose.TRANSPOSE` or :py:data:`Transpose.TRANSVERSE`.\n        :returns: Returns a flipped or rotated copy of this image.\n        \"\"\"\n\n        self.load()\n        return self._new(self.im.transpose(method))\n\n    def effect_spread(self, distance: int) -> Image:\n        \"\"\"\n        Randomly spread pixels in an image.\n\n        :param distance: Distance to spread pixels.\n        \"\"\"\n        self.load()\n        return self._new(self.im.effect_spread(distance))\n\n    def toqimage(self):\n        \"\"\"Returns a QImage copy of this image\"\"\"\n        from . import ImageQt\n\n        if not ImageQt.qt_is_installed:\n            msg = \"Qt bindings are not installed\"\n            raise ImportError(msg)\n        return ImageQt.toqimage(self)\n\n    def toqpixmap(self):\n        \"\"\"Returns a QPixmap copy of this image\"\"\"\n        from . import ImageQt\n\n        if not ImageQt.qt_is_installed:\n            msg = \"Qt bindings are not installed\"\n            raise ImportError(msg)\n        return ImageQt.toqpixmap(self)\n\n\n# --------------------------------------------------------------------\n# Abstract handlers.\n\n\nclass ImagePointHandler:\n    \"\"\"\n    Used as a mixin by point transforms\n    (for use with :py:meth:`~PIL.Image.Image.point`)\n    \"\"\"\n\n    @abc.abstractmethod\n    def point(self, im: Image) -> Image:\n        pass\n\n\nclass ImageTransformHandler:\n    \"\"\"\n    Used as a mixin by geometry transforms\n    (for use with :py:meth:`~PIL.Image.Image.transform`)\n    \"\"\"\n\n    @abc.abstractmethod\n    def transform(\n        self,\n        size: tuple[int, int],\n        image: Image,\n        **options: Any,\n    ) -> Image:\n        pass\n\n\n# --------------------------------------------------------------------\n# Factories\n\n#\n# Debugging\n\n\ndef _wedge() -> Image:\n    \"\"\"Create grayscale wedge (for debugging only)\"\"\"\n\n    return Image()._new(core.wedge(\"L\"))\n\n\ndef _check_size(size: Any) -> None:\n    \"\"\"\n    Common check to enforce type and sanity check on size tuples\n\n    :param size: Should be a 2 tuple of (width, height)\n    :returns: None, or raises a ValueError\n    \"\"\"\n\n    if not isinstance(size, (list, tuple)):\n        msg = \"Size must be a list or tuple\"\n        raise ValueError(msg)\n    if len(size) != 2:\n        msg = \"Size must be a sequence of length 2\"\n        raise ValueError(msg)\n    if size[0] < 0 or size[1] < 0:\n        msg = \"Width and height must be >= 0\"\n        raise ValueError(msg)\n\n\ndef new(\n    mode: str,\n    size: tuple[int, int] | list[int],\n    color: float | tuple[float, ...] | str | None = 0,\n) -> Image:\n    \"\"\"\n    Creates a new image with the given mode and size.\n\n    :param mode: The mode to use for the new image. See:\n       :ref:`concept-modes`.\n    :param size: A 2-tuple, containing (width, height) in pixels.\n    :param color: What color to use for the image.  Default is black.\n       If given, this should be a single integer or floating point value\n       for single-band modes, and a tuple for multi-band modes (one value\n       per band).  When creating RGB or HSV images, you can also use color\n       strings as supported by the ImageColor module.  If the color is\n       None, the image is not initialised.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if mode in (\"BGR;15\", \"BGR;16\", \"BGR;24\"):\n        deprecate(mode, 12)\n\n    _check_size(size)\n\n    if color is None:\n        # don't initialize\n        return Image()._new(core.new(mode, size))\n\n    if isinstance(color, str):\n        # css3-style specifier\n\n        from . import ImageColor\n\n        color = ImageColor.getcolor(color, mode)\n\n    im = Image()\n    if (\n        mode == \"P\"\n        and isinstance(color, (list, tuple))\n        and all(isinstance(i, int) for i in color)\n    ):\n        color_ints: tuple[int, ...] = cast(Tuple[int, ...], tuple(color))\n        if len(color_ints) == 3 or len(color_ints) == 4:\n            # RGB or RGBA value for a P image\n            from . import ImagePalette\n\n            im.palette = ImagePalette.ImagePalette()\n            color = im.palette.getcolor(color_ints)\n    return im._new(core.fill(mode, size, color))\n\n\ndef frombytes(\n    mode: str,\n    size: tuple[int, int],\n    data: bytes | bytearray,\n    decoder_name: str = \"raw\",\n    *args: Any,\n) -> Image:\n    \"\"\"\n    Creates a copy of an image memory from pixel data in a buffer.\n\n    In its simplest form, this function takes three arguments\n    (mode, size, and unpacked pixel data).\n\n    You can also use any pixel decoder supported by PIL. For more\n    information on available decoders, see the section\n    :ref:`Writing Your Own File Codec <file-codecs>`.\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image in a string, wrap it in a\n    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load\n    it.\n\n    :param mode: The image mode. See: :ref:`concept-modes`.\n    :param size: The image size.\n    :param data: A byte buffer containing raw data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    _check_size(size)\n\n    im = new(mode, size)\n    if im.width != 0 and im.height != 0:\n        decoder_args: Any = args\n        if len(decoder_args) == 1 and isinstance(decoder_args[0], tuple):\n            # may pass tuple instead of argument list\n            decoder_args = decoder_args[0]\n\n        if decoder_name == \"raw\" and decoder_args == ():\n            decoder_args = mode\n\n        im.frombytes(data, decoder_name, decoder_args)\n    return im\n\n\ndef frombuffer(\n    mode: str, size: tuple[int, int], data, decoder_name: str = \"raw\", *args: Any\n) -> Image:\n    \"\"\"\n    Creates an image memory referencing pixel data in a byte buffer.\n\n    This function is similar to :py:func:`~PIL.Image.frombytes`, but uses data\n    in the byte buffer, where possible.  This means that changes to the\n    original buffer object are reflected in this image).  Not all modes can\n    share memory; supported modes include \"L\", \"RGBX\", \"RGBA\", and \"CMYK\".\n\n    Note that this function decodes pixel data only, not entire images.\n    If you have an entire image file in a string, wrap it in a\n    :py:class:`~io.BytesIO` object, and use :py:func:`~PIL.Image.open` to load it.\n\n    The default parameters used for the \"raw\" decoder differs from that used for\n    :py:func:`~PIL.Image.frombytes`. This is a bug, and will probably be fixed in a\n    future release. The current release issues a warning if you do this; to disable\n    the warning, you should provide the full set of parameters. See below for details.\n\n    :param mode: The image mode. See: :ref:`concept-modes`.\n    :param size: The image size.\n    :param data: A bytes or other buffer object containing raw\n        data for the given mode.\n    :param decoder_name: What decoder to use.\n    :param args: Additional parameters for the given decoder.  For the\n        default encoder (\"raw\"), it's recommended that you provide the\n        full set of parameters::\n\n            frombuffer(mode, size, data, \"raw\", mode, 0, 1)\n\n    :returns: An :py:class:`~PIL.Image.Image` object.\n\n    .. versionadded:: 1.1.4\n    \"\"\"\n\n    _check_size(size)\n\n    # may pass tuple instead of argument list\n    if len(args) == 1 and isinstance(args[0], tuple):\n        args = args[0]\n\n    if decoder_name == \"raw\":\n        if args == ():\n            args = mode, 0, 1\n        if args[0] in _MAPMODES:\n            im = new(mode, (0, 0))\n            im = im._new(core.map_buffer(data, size, decoder_name, 0, args))\n            if mode == \"P\":\n                from . import ImagePalette\n\n                im.palette = ImagePalette.ImagePalette(\"RGB\", im.im.getpalette(\"RGB\"))\n            im.readonly = 1\n            return im\n\n    return frombytes(mode, size, data, decoder_name, args)\n\n\nclass SupportsArrayInterface(Protocol):\n    \"\"\"\n    An object that has an ``__array_interface__`` dictionary.\n    \"\"\"\n\n    @property\n    def __array_interface__(self) -> dict[str, Any]:\n        raise NotImplementedError()\n\n\ndef fromarray(obj: SupportsArrayInterface, mode: str | None = None) -> Image:\n    \"\"\"\n    Creates an image memory from an object exporting the array interface\n    (using the buffer protocol)::\n\n      from PIL import Image\n      import numpy as np\n      a = np.zeros((5, 5))\n      im = Image.fromarray(a)\n\n    If ``obj`` is not contiguous, then the ``tobytes`` method is called\n    and :py:func:`~PIL.Image.frombuffer` is used.\n\n    In the case of NumPy, be aware that Pillow modes do not always correspond\n    to NumPy dtypes. Pillow modes only offer 1-bit pixels, 8-bit pixels,\n    32-bit signed integer pixels, and 32-bit floating point pixels.\n\n    Pillow images can also be converted to arrays::\n\n      from PIL import Image\n      import numpy as np\n      im = Image.open(\"hopper.jpg\")\n      a = np.asarray(im)\n\n    When converting Pillow images to arrays however, only pixel values are\n    transferred. This means that P and PA mode images will lose their palette.\n\n    :param obj: Object with array interface\n    :param mode: Optional mode to use when reading ``obj``. Will be determined from\n      type if ``None``.\n\n      This will not be used to convert the data after reading, but will be used to\n      change how the data is read::\n\n        from PIL import Image\n        import numpy as np\n        a = np.full((1, 1), 300)\n        im = Image.fromarray(a, mode=\"L\")\n        im.getpixel((0, 0))  # 44\n        im = Image.fromarray(a, mode=\"RGB\")\n        im.getpixel((0, 0))  # (44, 1, 0)\n\n      See: :ref:`concept-modes` for general information about modes.\n    :returns: An image object.\n\n    .. versionadded:: 1.1.6\n    \"\"\"\n    arr = obj.__array_interface__\n    shape = arr[\"shape\"]\n    ndim = len(shape)\n    strides = arr.get(\"strides\", None)\n    if mode is None:\n        try:\n            typekey = (1, 1) + shape[2:], arr[\"typestr\"]\n        except KeyError as e:\n            msg = \"Cannot handle this data type\"\n            raise TypeError(msg) from e\n        try:\n            mode, rawmode = _fromarray_typemap[typekey]\n        except KeyError as e:\n            typekey_shape, typestr = typekey\n            msg = f\"Cannot handle this data type: {typekey_shape}, {typestr}\"\n            raise TypeError(msg) from e\n    else:\n        rawmode = mode\n    if mode in [\"1\", \"L\", \"I\", \"P\", \"F\"]:\n        ndmax = 2\n    elif mode == \"RGB\":\n        ndmax = 3\n    else:\n        ndmax = 4\n    if ndim > ndmax:\n        msg = f\"Too many dimensions: {ndim} > {ndmax}.\"\n        raise ValueError(msg)\n\n    size = 1 if ndim == 1 else shape[1], shape[0]\n    if strides is not None:\n        if hasattr(obj, \"tobytes\"):\n            obj = obj.tobytes()\n        elif hasattr(obj, \"tostring\"):\n            obj = obj.tostring()\n        else:\n            msg = \"'strides' requires either tobytes() or tostring()\"\n            raise ValueError(msg)\n\n    return frombuffer(mode, size, obj, \"raw\", rawmode, 0, 1)\n\n\ndef fromqimage(im):\n    \"\"\"Creates an image instance from a QImage image\"\"\"\n    from . import ImageQt\n\n    if not ImageQt.qt_is_installed:\n        msg = \"Qt bindings are not installed\"\n        raise ImportError(msg)\n    return ImageQt.fromqimage(im)\n\n\ndef fromqpixmap(im):\n    \"\"\"Creates an image instance from a QPixmap image\"\"\"\n    from . import ImageQt\n\n    if not ImageQt.qt_is_installed:\n        msg = \"Qt bindings are not installed\"\n        raise ImportError(msg)\n    return ImageQt.fromqpixmap(im)\n\n\n_fromarray_typemap = {\n    # (shape, typestr) => mode, rawmode\n    # first two members of shape are set to one\n    ((1, 1), \"|b1\"): (\"1\", \"1;8\"),\n    ((1, 1), \"|u1\"): (\"L\", \"L\"),\n    ((1, 1), \"|i1\"): (\"I\", \"I;8\"),\n    ((1, 1), \"<u2\"): (\"I\", \"I;16\"),\n    ((1, 1), \">u2\"): (\"I\", \"I;16B\"),\n    ((1, 1), \"<i2\"): (\"I\", \"I;16S\"),\n    ((1, 1), \">i2\"): (\"I\", \"I;16BS\"),\n    ((1, 1), \"<u4\"): (\"I\", \"I;32\"),\n    ((1, 1), \">u4\"): (\"I\", \"I;32B\"),\n    ((1, 1), \"<i4\"): (\"I\", \"I;32S\"),\n    ((1, 1), \">i4\"): (\"I\", \"I;32BS\"),\n    ((1, 1), \"<f4\"): (\"F\", \"F;32F\"),\n    ((1, 1), \">f4\"): (\"F\", \"F;32BF\"),\n    ((1, 1), \"<f8\"): (\"F\", \"F;64F\"),\n    ((1, 1), \">f8\"): (\"F\", \"F;64BF\"),\n    ((1, 1, 2), \"|u1\"): (\"LA\", \"LA\"),\n    ((1, 1, 3), \"|u1\"): (\"RGB\", \"RGB\"),\n    ((1, 1, 4), \"|u1\"): (\"RGBA\", \"RGBA\"),\n    # shortcuts:\n    ((1, 1), f\"{_ENDIAN}i4\"): (\"I\", \"I\"),\n    ((1, 1), f\"{_ENDIAN}f4\"): (\"F\", \"F\"),\n}\n\n\ndef _decompression_bomb_check(size: tuple[int, int]) -> None:\n    if MAX_IMAGE_PIXELS is None:\n        return\n\n    pixels = max(1, size[0]) * max(1, size[1])\n\n    if pixels > 2 * MAX_IMAGE_PIXELS:\n        msg = (\n            f\"Image size ({pixels} pixels) exceeds limit of {2 * MAX_IMAGE_PIXELS} \"\n            \"pixels, could be decompression bomb DOS attack.\"\n        )\n        raise DecompressionBombError(msg)\n\n    if pixels > MAX_IMAGE_PIXELS:\n        warnings.warn(\n            f\"Image size ({pixels} pixels) exceeds limit of {MAX_IMAGE_PIXELS} pixels, \"\n            \"could be decompression bomb DOS attack.\",\n            DecompressionBombWarning,\n        )\n\n\ndef open(\n    fp: StrOrBytesPath | IO[bytes],\n    mode: Literal[\"r\"] = \"r\",\n    formats: list[str] | tuple[str, ...] | None = None,\n) -> ImageFile.ImageFile:\n    \"\"\"\n    Opens and identifies the given image file.\n\n    This is a lazy operation; this function identifies the file, but\n    the file remains open and the actual image data is not read from\n    the file until you try to process the data (or call the\n    :py:meth:`~PIL.Image.Image.load` method).  See\n    :py:func:`~PIL.Image.new`. See :ref:`file-handling`.\n\n    :param fp: A filename (string), os.PathLike object or a file object.\n       The file object must implement ``file.read``,\n       ``file.seek``, and ``file.tell`` methods,\n       and be opened in binary mode. The file object will also seek to zero\n       before reading.\n    :param mode: The mode.  If given, this argument must be \"r\".\n    :param formats: A list or tuple of formats to attempt to load the file in.\n       This can be used to restrict the set of formats checked.\n       Pass ``None`` to try all supported formats. You can print the set of\n       available formats by running ``python3 -m PIL`` or using\n       the :py:func:`PIL.features.pilinfo` function.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    :exception FileNotFoundError: If the file cannot be found.\n    :exception PIL.UnidentifiedImageError: If the image cannot be opened and\n       identified.\n    :exception ValueError: If the ``mode`` is not \"r\", or if a ``StringIO``\n       instance is used for ``fp``.\n    :exception TypeError: If ``formats`` is not ``None``, a list or a tuple.\n    \"\"\"\n\n    if mode != \"r\":\n        msg = f\"bad mode {repr(mode)}\"  # type: ignore[unreachable]\n        raise ValueError(msg)\n    elif isinstance(fp, io.StringIO):\n        msg = (  # type: ignore[unreachable]\n            \"StringIO cannot be used to open an image. \"\n            \"Binary data must be used instead.\"\n        )\n        raise ValueError(msg)\n\n    if formats is None:\n        formats = ID\n    elif not isinstance(formats, (list, tuple)):\n        msg = \"formats must be a list or tuple\"  # type: ignore[unreachable]\n        raise TypeError(msg)\n\n    exclusive_fp = False\n    filename: str | bytes = \"\"\n    if is_path(fp):\n        filename = os.path.realpath(os.fspath(fp))\n\n    if filename:\n        fp = builtins.open(filename, \"rb\")\n        exclusive_fp = True\n    else:\n        fp = cast(IO[bytes], fp)\n\n    try:\n        fp.seek(0)\n    except (AttributeError, io.UnsupportedOperation):\n        fp = io.BytesIO(fp.read())\n        exclusive_fp = True\n\n    prefix = fp.read(16)\n\n    preinit()\n\n    accept_warnings: list[str] = []\n\n    def _open_core(\n        fp: IO[bytes],\n        filename: str | bytes,\n        prefix: bytes,\n        formats: list[str] | tuple[str, ...],\n    ) -> ImageFile.ImageFile | None:\n        for i in formats:\n            i = i.upper()\n            if i not in OPEN:\n                init()\n            try:\n                factory, accept = OPEN[i]\n                result = not accept or accept(prefix)\n                if isinstance(result, str):\n                    accept_warnings.append(result)\n                elif result:\n                    fp.seek(0)\n                    im = factory(fp, filename)\n                    _decompression_bomb_check(im.size)\n                    return im\n            except (SyntaxError, IndexError, TypeError, struct.error):\n                # Leave disabled by default, spams the logs with image\n                # opening failures that are entirely expected.\n                # logger.debug(\"\", exc_info=True)\n                continue\n            except BaseException:\n                if exclusive_fp:\n                    fp.close()\n                raise\n        return None\n\n    im = _open_core(fp, filename, prefix, formats)\n\n    if im is None and formats is ID:\n        checked_formats = ID.copy()\n        if init():\n            im = _open_core(\n                fp,\n                filename,\n                prefix,\n                tuple(format for format in formats if format not in checked_formats),\n            )\n\n    if im:\n        im._exclusive_fp = exclusive_fp\n        return im\n\n    if exclusive_fp:\n        fp.close()\n    for message in accept_warnings:\n        warnings.warn(message)\n    msg = \"cannot identify image file %r\" % (filename if filename else fp)\n    raise UnidentifiedImageError(msg)\n\n\n#\n# Image processing.\n\n\ndef alpha_composite(im1: Image, im2: Image) -> Image:\n    \"\"\"\n    Alpha composite im2 over im1.\n\n    :param im1: The first image. Must have mode RGBA.\n    :param im2: The second image.  Must have mode RGBA, and the same size as\n       the first image.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.alpha_composite(im1.im, im2.im))\n\n\ndef blend(im1: Image, im2: Image, alpha: float) -> Image:\n    \"\"\"\n    Creates a new image by interpolating between two input images, using\n    a constant alpha::\n\n        out = image1 * (1.0 - alpha) + image2 * alpha\n\n    :param im1: The first image.\n    :param im2: The second image.  Must have the same mode and size as\n       the first image.\n    :param alpha: The interpolation alpha factor.  If alpha is 0.0, a\n       copy of the first image is returned. If alpha is 1.0, a copy of\n       the second image is returned. There are no restrictions on the\n       alpha value. If necessary, the result is clipped to fit into\n       the allowed output range.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    im1.load()\n    im2.load()\n    return im1._new(core.blend(im1.im, im2.im, alpha))\n\n\ndef composite(image1: Image, image2: Image, mask: Image) -> Image:\n    \"\"\"\n    Create composite image by blending images using a transparency mask.\n\n    :param image1: The first image.\n    :param image2: The second image.  Must have the same mode and\n       size as the first image.\n    :param mask: A mask image.  This image can have mode\n       \"1\", \"L\", or \"RGBA\", and must have the same size as the\n       other two images.\n    \"\"\"\n\n    image = image2.copy()\n    image.paste(image1, None, mask)\n    return image\n\n\ndef eval(image, *args):\n    \"\"\"\n    Applies the function (which should take one argument) to each pixel\n    in the given image. If the image has more than one band, the same\n    function is applied to each band. Note that the function is\n    evaluated once for each possible pixel value, so you cannot use\n    random components or other generators.\n\n    :param image: The input image.\n    :param function: A function object, taking one integer argument.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    return image.point(args[0])\n\n\ndef merge(mode: str, bands: Sequence[Image]) -> Image:\n    \"\"\"\n    Merge a set of single band images into a new multiband image.\n\n    :param mode: The mode to use for the output image. See:\n        :ref:`concept-modes`.\n    :param bands: A sequence containing one single-band image for\n        each band in the output image.  All bands must have the\n        same size.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n\n    if getmodebands(mode) != len(bands) or \"*\" in mode:\n        msg = \"wrong number of bands\"\n        raise ValueError(msg)\n    for band in bands[1:]:\n        if band.mode != getmodetype(mode):\n            msg = \"mode mismatch\"\n            raise ValueError(msg)\n        if band.size != bands[0].size:\n            msg = \"size mismatch\"\n            raise ValueError(msg)\n    for band in bands:\n        band.load()\n    return bands[0]._new(core.merge(mode, *[b.im for b in bands]))\n\n\n# --------------------------------------------------------------------\n# Plugin registry\n\n\ndef register_open(\n    id: str,\n    factory: Callable[[IO[bytes], str | bytes], ImageFile.ImageFile],\n    accept: Callable[[bytes], bool | str] | None = None,\n) -> None:\n    \"\"\"\n    Register an image file plugin.  This function should not be used\n    in application code.\n\n    :param id: An image format identifier.\n    :param factory: An image file factory method.\n    :param accept: An optional function that can be used to quickly\n       reject images having another format.\n    \"\"\"\n    id = id.upper()\n    if id not in ID:\n        ID.append(id)\n    OPEN[id] = factory, accept\n\n\ndef register_mime(id: str, mimetype: str) -> None:\n    \"\"\"\n    Registers an image MIME type by populating ``Image.MIME``. This function\n    should not be used in application code.\n\n    ``Image.MIME`` provides a mapping from image format identifiers to mime\n    formats, but :py:meth:`~PIL.ImageFile.ImageFile.get_format_mimetype` can\n    provide a different result for specific images.\n\n    :param id: An image format identifier.\n    :param mimetype: The image MIME type for this format.\n    \"\"\"\n    MIME[id.upper()] = mimetype\n\n\ndef register_save(\n    id: str, driver: Callable[[Image, IO[bytes], str | bytes], None]\n) -> None:\n    \"\"\"\n    Registers an image save function.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE[id.upper()] = driver\n\n\ndef register_save_all(\n    id: str, driver: Callable[[Image, IO[bytes], str | bytes], None]\n) -> None:\n    \"\"\"\n    Registers an image function to save all the frames\n    of a multiframe format.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param driver: A function to save images in this format.\n    \"\"\"\n    SAVE_ALL[id.upper()] = driver\n\n\ndef register_extension(id: str, extension: str) -> None:\n    \"\"\"\n    Registers an image extension.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param extension: An extension used for this format.\n    \"\"\"\n    EXTENSION[extension.lower()] = id.upper()\n\n\ndef register_extensions(id: str, extensions: list[str]) -> None:\n    \"\"\"\n    Registers image extensions.  This function should not be\n    used in application code.\n\n    :param id: An image format identifier.\n    :param extensions: A list of extensions used for this format.\n    \"\"\"\n    for extension in extensions:\n        register_extension(id, extension)\n\n\ndef registered_extensions() -> dict[str, str]:\n    \"\"\"\n    Returns a dictionary containing all file extensions belonging\n    to registered plugins\n    \"\"\"\n    init()\n    return EXTENSION\n\n\ndef register_decoder(name: str, decoder: type[ImageFile.PyDecoder]) -> None:\n    \"\"\"\n    Registers an image decoder.  This function should not be\n    used in application code.\n\n    :param name: The name of the decoder\n    :param decoder: An ImageFile.PyDecoder object\n\n    .. versionadded:: 4.1.0\n    \"\"\"\n    DECODERS[name] = decoder\n\n\ndef register_encoder(name: str, encoder: type[ImageFile.PyEncoder]) -> None:\n    \"\"\"\n    Registers an image encoder.  This function should not be\n    used in application code.\n\n    :param name: The name of the encoder\n    :param encoder: An ImageFile.PyEncoder object\n\n    .. versionadded:: 4.1.0\n    \"\"\"\n    ENCODERS[name] = encoder\n\n\n# --------------------------------------------------------------------\n# Simple display support.\n\n\ndef _show(image: Image, **options: Any) -> None:\n    from . import ImageShow\n\n    ImageShow.show(image, **options)\n\n\n# --------------------------------------------------------------------\n# Effects\n\n\ndef effect_mandelbrot(\n    size: tuple[int, int], extent: tuple[float, float, float, float], quality: int\n) -> Image:\n    \"\"\"\n    Generate a Mandelbrot set covering the given extent.\n\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param extent: The extent to cover, as a 4-tuple:\n       (x0, y0, x1, y1).\n    :param quality: Quality.\n    \"\"\"\n    return Image()._new(core.effect_mandelbrot(size, extent, quality))\n\n\ndef effect_noise(size: tuple[int, int], sigma: float) -> Image:\n    \"\"\"\n    Generate Gaussian noise centered around 128.\n\n    :param size: The requested size in pixels, as a 2-tuple:\n       (width, height).\n    :param sigma: Standard deviation of noise.\n    \"\"\"\n    return Image()._new(core.effect_noise(size, sigma))\n\n\ndef linear_gradient(mode: str) -> Image:\n    \"\"\"\n    Generate 256x256 linear gradient from black to white, top to bottom.\n\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.linear_gradient(mode))\n\n\ndef radial_gradient(mode: str) -> Image:\n    \"\"\"\n    Generate 256x256 radial gradient from black to white, centre to edge.\n\n    :param mode: Input mode.\n    \"\"\"\n    return Image()._new(core.radial_gradient(mode))\n\n\n# --------------------------------------------------------------------\n# Resources\n\n\ndef _apply_env_variables(env: dict[str, str] | None = None) -> None:\n    env_dict = env if env is not None else os.environ\n\n    for var_name, setter in [\n        (\"PILLOW_ALIGNMENT\", core.set_alignment),\n        (\"PILLOW_BLOCK_SIZE\", core.set_block_size),\n        (\"PILLOW_BLOCKS_MAX\", core.set_blocks_max),\n    ]:\n        if var_name not in env_dict:\n            continue\n\n        var = env_dict[var_name].lower()\n\n        units = 1\n        for postfix, mul in [(\"k\", 1024), (\"m\", 1024 * 1024)]:\n            if var.endswith(postfix):\n                units = mul\n                var = var[: -len(postfix)]\n\n        try:\n            var_int = int(var) * units\n        except ValueError:\n            warnings.warn(f\"{var_name} is not int\")\n            continue\n\n        try:\n            setter(var_int)\n        except ValueError as e:\n            warnings.warn(f\"{var_name}: {e}\")\n\n\n_apply_env_variables()\natexit.register(core.clear_cache)\n\n\nif TYPE_CHECKING:\n    _ExifBase = MutableMapping[int, Any]\nelse:\n    _ExifBase = MutableMapping\n\n\nclass Exif(_ExifBase):\n    \"\"\"\n    This class provides read and write access to EXIF image data::\n\n      from PIL import Image\n      im = Image.open(\"exif.png\")\n      exif = im.getexif()  # Returns an instance of this class\n\n    Information can be read and written, iterated over or deleted::\n\n      print(exif[274])  # 1\n      exif[274] = 2\n      for k, v in exif.items():\n        print(\"Tag\", k, \"Value\", v)  # Tag 274 Value 2\n      del exif[274]\n\n    To access information beyond IFD0, :py:meth:`~PIL.Image.Exif.get_ifd`\n    returns a dictionary::\n\n      from PIL import ExifTags\n      im = Image.open(\"exif_gps.jpg\")\n      exif = im.getexif()\n      gps_ifd = exif.get_ifd(ExifTags.IFD.GPSInfo)\n      print(gps_ifd)\n\n    Other IFDs include ``ExifTags.IFD.Exif``, ``ExifTags.IFD.Makernote``,\n    ``ExifTags.IFD.Interop`` and ``ExifTags.IFD.IFD1``.\n\n    :py:mod:`~PIL.ExifTags` also has enum classes to provide names for data::\n\n      print(exif[ExifTags.Base.Software])  # PIL\n      print(gps_ifd[ExifTags.GPS.GPSDateStamp])  # 1999:99:99 99:99:99\n    \"\"\"\n\n    endian = None\n    bigtiff = False\n    _loaded = False\n\n    def __init__(self):\n        self._data = {}\n        self._hidden_data = {}\n        self._ifds = {}\n        self._info = None\n        self._loaded_exif = None\n\n    def _fixup(self, value):\n        try:\n            if len(value) == 1 and isinstance(value, tuple):\n                return value[0]\n        except Exception:\n            pass\n        return value\n\n    def _fixup_dict(self, src_dict):\n        # Helper function\n        # returns a dict with any single item tuples/lists as individual values\n        return {k: self._fixup(v) for k, v in src_dict.items()}\n\n    def _get_ifd_dict(self, offset, group=None):\n        try:\n            # an offset pointer to the location of the nested embedded IFD.\n            # It should be a long, but may be corrupted.\n            self.fp.seek(offset)\n        except (KeyError, TypeError):\n            pass\n        else:\n            from . import TiffImagePlugin\n\n            info = TiffImagePlugin.ImageFileDirectory_v2(self.head, group=group)\n            info.load(self.fp)\n            return self._fixup_dict(info)\n\n    def _get_head(self):\n        version = b\"\\x2B\" if self.bigtiff else b\"\\x2A\"\n        if self.endian == \"<\":\n            head = b\"II\" + version + b\"\\x00\" + o32le(8)\n        else:\n            head = b\"MM\\x00\" + version + o32be(8)\n        if self.bigtiff:\n            head += o32le(8) if self.endian == \"<\" else o32be(8)\n            head += b\"\\x00\\x00\\x00\\x00\"\n        return head\n\n    def load(self, data):\n        # Extract EXIF information.  This is highly experimental,\n        # and is likely to be replaced with something better in a future\n        # version.\n\n        # The EXIF record consists of a TIFF file embedded in a JPEG\n        # application marker (!).\n        if data == self._loaded_exif:\n            return\n        self._loaded_exif = data\n        self._data.clear()\n        self._hidden_data.clear()\n        self._ifds.clear()\n        if data and data.startswith(b\"Exif\\x00\\x00\"):\n            data = data[6:]\n        if not data:\n            self._info = None\n            return\n\n        self.fp = io.BytesIO(data)\n        self.head = self.fp.read(8)\n        # process dictionary\n        from . import TiffImagePlugin\n\n        self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)\n        self.endian = self._info._endian\n        self.fp.seek(self._info.next)\n        self._info.load(self.fp)\n\n    def load_from_fp(self, fp, offset=None):\n        self._loaded_exif = None\n        self._data.clear()\n        self._hidden_data.clear()\n        self._ifds.clear()\n\n        # process dictionary\n        from . import TiffImagePlugin\n\n        self.fp = fp\n        if offset is not None:\n            self.head = self._get_head()\n        else:\n            self.head = self.fp.read(8)\n        self._info = TiffImagePlugin.ImageFileDirectory_v2(self.head)\n        if self.endian is None:\n            self.endian = self._info._endian\n        if offset is None:\n            offset = self._info.next\n        self.fp.tell()\n        self.fp.seek(offset)\n        self._info.load(self.fp)\n\n    def _get_merged_dict(self):\n        merged_dict = dict(self)\n\n        # get EXIF extension\n        if ExifTags.IFD.Exif in self:\n            ifd = self._get_ifd_dict(self[ExifTags.IFD.Exif], ExifTags.IFD.Exif)\n            if ifd:\n                merged_dict.update(ifd)\n\n        # GPS\n        if ExifTags.IFD.GPSInfo in self:\n            merged_dict[ExifTags.IFD.GPSInfo] = self._get_ifd_dict(\n                self[ExifTags.IFD.GPSInfo], ExifTags.IFD.GPSInfo\n            )\n\n        return merged_dict\n\n    def tobytes(self, offset: int = 8) -> bytes:\n        from . import TiffImagePlugin\n\n        head = self._get_head()\n        ifd = TiffImagePlugin.ImageFileDirectory_v2(ifh=head)\n        for tag, value in self.items():\n            if tag in [\n                ExifTags.IFD.Exif,\n                ExifTags.IFD.GPSInfo,\n            ] and not isinstance(value, dict):\n                value = self.get_ifd(tag)\n                if (\n                    tag == ExifTags.IFD.Exif\n                    and ExifTags.IFD.Interop in value\n                    and not isinstance(value[ExifTags.IFD.Interop], dict)\n                ):\n                    value = value.copy()\n                    value[ExifTags.IFD.Interop] = self.get_ifd(ExifTags.IFD.Interop)\n            ifd[tag] = value\n        return b\"Exif\\x00\\x00\" + head + ifd.tobytes(offset)\n\n    def get_ifd(self, tag):\n        if tag not in self._ifds:\n            if tag == ExifTags.IFD.IFD1:\n                if self._info is not None and self._info.next != 0:\n                    self._ifds[tag] = self._get_ifd_dict(self._info.next)\n            elif tag in [ExifTags.IFD.Exif, ExifTags.IFD.GPSInfo]:\n                offset = self._hidden_data.get(tag, self.get(tag))\n                if offset is not None:\n                    self._ifds[tag] = self._get_ifd_dict(offset, tag)\n            elif tag in [ExifTags.IFD.Interop, ExifTags.IFD.Makernote]:\n                if ExifTags.IFD.Exif not in self._ifds:\n                    self.get_ifd(ExifTags.IFD.Exif)\n                tag_data = self._ifds[ExifTags.IFD.Exif][tag]\n                if tag == ExifTags.IFD.Makernote:\n                    from .TiffImagePlugin import ImageFileDirectory_v2\n\n                    if tag_data[:8] == b\"FUJIFILM\":\n                        ifd_offset = i32le(tag_data, 8)\n                        ifd_data = tag_data[ifd_offset:]\n\n                        makernote = {}\n                        for i in range(0, struct.unpack(\"<H\", ifd_data[:2])[0]):\n                            ifd_tag, typ, count, data = struct.unpack(\n                                \"<HHL4s\", ifd_data[i * 12 + 2 : (i + 1) * 12 + 2]\n                            )\n                            try:\n                                (\n                                    unit_size,\n                                    handler,\n                                ) = ImageFileDirectory_v2._load_dispatch[typ]\n                            except KeyError:\n                                continue\n                            size = count * unit_size\n                            if size > 4:\n                                (offset,) = struct.unpack(\"<L\", data)\n                                data = ifd_data[offset - 12 : offset + size - 12]\n                            else:\n                                data = data[:size]\n\n                            if len(data) != size:\n                                warnings.warn(\n                                    \"Possibly corrupt EXIF MakerNote data.  \"\n                                    f\"Expecting to read {size} bytes but only got \"\n                                    f\"{len(data)}. Skipping tag {ifd_tag}\"\n                                )\n                                continue\n\n                            if not data:\n                                continue\n\n                            makernote[ifd_tag] = handler(\n                                ImageFileDirectory_v2(), data, False\n                            )\n                        self._ifds[tag] = dict(self._fixup_dict(makernote))\n                    elif self.get(0x010F) == \"Nintendo\":\n                        makernote = {}\n                        for i in range(0, struct.unpack(\">H\", tag_data[:2])[0]):\n                            ifd_tag, typ, count, data = struct.unpack(\n                                \">HHL4s\", tag_data[i * 12 + 2 : (i + 1) * 12 + 2]\n                            )\n                            if ifd_tag == 0x1101:\n                                # CameraInfo\n                                (offset,) = struct.unpack(\">L\", data)\n                                self.fp.seek(offset)\n\n                                camerainfo = {\"ModelID\": self.fp.read(4)}\n\n                                self.fp.read(4)\n                                # Seconds since 2000\n                                camerainfo[\"TimeStamp\"] = i32le(self.fp.read(12))\n\n                                self.fp.read(4)\n                                camerainfo[\"InternalSerialNumber\"] = self.fp.read(4)\n\n                                self.fp.read(12)\n                                parallax = self.fp.read(4)\n                                handler = ImageFileDirectory_v2._load_dispatch[\n                                    TiffTags.FLOAT\n                                ][1]\n                                camerainfo[\"Parallax\"] = handler(\n                                    ImageFileDirectory_v2(), parallax, False\n                                )\n\n                                self.fp.read(4)\n                                camerainfo[\"Category\"] = self.fp.read(2)\n\n                                makernote = {0x1101: dict(self._fixup_dict(camerainfo))}\n                        self._ifds[tag] = makernote\n                else:\n                    # Interop\n                    self._ifds[tag] = self._get_ifd_dict(tag_data, tag)\n        ifd = self._ifds.get(tag, {})\n        if tag == ExifTags.IFD.Exif and self._hidden_data:\n            ifd = {\n                k: v\n                for (k, v) in ifd.items()\n                if k not in (ExifTags.IFD.Interop, ExifTags.IFD.Makernote)\n            }\n        return ifd\n\n    def hide_offsets(self) -> None:\n        for tag in (ExifTags.IFD.Exif, ExifTags.IFD.GPSInfo):\n            if tag in self:\n                self._hidden_data[tag] = self[tag]\n                del self[tag]\n\n    def __str__(self) -> str:\n        if self._info is not None:\n            # Load all keys into self._data\n            for tag in self._info:\n                self[tag]\n\n        return str(self._data)\n\n    def __len__(self) -> int:\n        keys = set(self._data)\n        if self._info is not None:\n            keys.update(self._info)\n        return len(keys)\n\n    def __getitem__(self, tag):\n        if self._info is not None and tag not in self._data and tag in self._info:\n            self._data[tag] = self._fixup(self._info[tag])\n            del self._info[tag]\n        return self._data[tag]\n\n    def __contains__(self, tag) -> bool:\n        return tag in self._data or (self._info is not None and tag in self._info)\n\n    def __setitem__(self, tag, value) -> None:\n        if self._info is not None and tag in self._info:\n            del self._info[tag]\n        self._data[tag] = value\n\n    def __delitem__(self, tag: int) -> None:\n        if self._info is not None and tag in self._info:\n            del self._info[tag]\n        else:\n            del self._data[tag]\n\n    def __iter__(self):\n        keys = set(self._data)\n        if self._info is not None:\n            keys.update(self._info)\n        return iter(keys)\n", "src/PIL/FliImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# FLI/FLC file handling.\n#\n# History:\n#       95-09-01 fl     Created\n#       97-01-03 fl     Fixed parser, setup decoder tile\n#       98-07-15 fl     Renamed offset attribute to avoid name clash\n#\n# Copyright (c) Secret Labs AB 1997-98.\n# Copyright (c) Fredrik Lundh 1995-97.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\nfrom ._binary import o8\n\n#\n# decoder\n\n\ndef _accept(prefix: bytes) -> bool:\n    return (\n        len(prefix) >= 6\n        and i16(prefix, 4) in [0xAF11, 0xAF12]\n        and i16(prefix, 14) in [0, 3]  # flags\n    )\n\n\n##\n# Image plugin for the FLI/FLC animation format.  Use the <b>seek</b>\n# method to load individual frames.\n\n\nclass FliImageFile(ImageFile.ImageFile):\n    format = \"FLI\"\n    format_description = \"Autodesk FLI/FLC Animation\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self):\n        # HEAD\n        s = self.fp.read(128)\n        if not (_accept(s) and s[20:22] == b\"\\x00\\x00\"):\n            msg = \"not an FLI/FLC file\"\n            raise SyntaxError(msg)\n\n        # frames\n        self.n_frames = i16(s, 6)\n        self.is_animated = self.n_frames > 1\n\n        # image characteristics\n        self._mode = \"P\"\n        self._size = i16(s, 8), i16(s, 10)\n\n        # animation speed\n        duration = i32(s, 16)\n        magic = i16(s, 4)\n        if magic == 0xAF11:\n            duration = (duration * 1000) // 70\n        self.info[\"duration\"] = duration\n\n        # look for palette\n        palette = [(a, a, a) for a in range(256)]\n\n        s = self.fp.read(16)\n\n        self.__offset = 128\n\n        if i16(s, 4) == 0xF100:\n            # prefix chunk; ignore it\n            self.__offset = self.__offset + i32(s)\n            self.fp.seek(self.__offset)\n            s = self.fp.read(16)\n\n        if i16(s, 4) == 0xF1FA:\n            # look for palette chunk\n            number_of_subchunks = i16(s, 6)\n            chunk_size = None\n            for _ in range(number_of_subchunks):\n                if chunk_size is not None:\n                    self.fp.seek(chunk_size - 6, os.SEEK_CUR)\n                s = self.fp.read(6)\n                chunk_type = i16(s, 4)\n                if chunk_type in (4, 11):\n                    self._palette(palette, 2 if chunk_type == 11 else 0)\n                    break\n                chunk_size = i32(s)\n                if not chunk_size:\n                    break\n\n        palette = [o8(r) + o8(g) + o8(b) for (r, g, b) in palette]\n        self.palette = ImagePalette.raw(\"RGB\", b\"\".join(palette))\n\n        # set things up to decode first frame\n        self.__frame = -1\n        self._fp = self.fp\n        self.__rewind = self.fp.tell()\n        self.seek(0)\n\n    def _palette(self, palette, shift):\n        # load palette\n\n        i = 0\n        for e in range(i16(self.fp.read(2))):\n            s = self.fp.read(2)\n            i = i + s[0]\n            n = s[1]\n            if n == 0:\n                n = 256\n            s = self.fp.read(n * 3)\n            for n in range(0, len(s), 3):\n                r = s[n] << shift\n                g = s[n + 1] << shift\n                b = s[n + 2] << shift\n                palette[i] = (r, g, b)\n                i += 1\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        if frame < self.__frame:\n            self._seek(0)\n\n        for f in range(self.__frame + 1, frame + 1):\n            self._seek(f)\n\n    def _seek(self, frame: int) -> None:\n        if frame == 0:\n            self.__frame = -1\n            self._fp.seek(self.__rewind)\n            self.__offset = 128\n        else:\n            # ensure that the previous frame was loaded\n            self.load()\n\n        if frame != self.__frame + 1:\n            msg = f\"cannot seek to frame {frame}\"\n            raise ValueError(msg)\n        self.__frame = frame\n\n        # move to next frame\n        self.fp = self._fp\n        self.fp.seek(self.__offset)\n\n        s = self.fp.read(4)\n        if not s:\n            msg = \"missing frame size\"\n            raise EOFError(msg)\n\n        framesize = i32(s)\n\n        self.decodermaxblock = framesize\n        self.tile = [(\"fli\", (0, 0) + self.size, self.__offset, None)]\n\n        self.__offset += framesize\n\n    def tell(self) -> int:\n        return self.__frame\n\n\n#\n# registry\n\nImage.register_open(FliImageFile.format, FliImageFile, _accept)\n\nImage.register_extensions(FliImageFile.format, [\".fli\", \".flc\"])\n", "src/PIL/ImageMath.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# a simple math add-on for the Python Imaging Library\n#\n# History:\n# 1999-02-15 fl   Original PIL Plus release\n# 2005-05-05 fl   Simplified and cleaned up for PIL 1.1.6\n# 2005-09-12 fl   Fixed int() and float() for Python 2.4.1\n#\n# Copyright (c) 1999-2005 by Secret Labs AB\n# Copyright (c) 2005 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport builtins\nfrom types import CodeType\nfrom typing import Any, Callable\n\nfrom . import Image, _imagingmath\nfrom ._deprecate import deprecate\n\n\nclass _Operand:\n    \"\"\"Wraps an image operand, providing standard operators\"\"\"\n\n    def __init__(self, im: Image.Image):\n        self.im = im\n\n    def __fixup(self, im1: _Operand | float) -> Image.Image:\n        # convert image to suitable mode\n        if isinstance(im1, _Operand):\n            # argument was an image.\n            if im1.im.mode in (\"1\", \"L\"):\n                return im1.im.convert(\"I\")\n            elif im1.im.mode in (\"I\", \"F\"):\n                return im1.im\n            else:\n                msg = f\"unsupported mode: {im1.im.mode}\"\n                raise ValueError(msg)\n        else:\n            # argument was a constant\n            if isinstance(im1, (int, float)) and self.im.mode in (\"1\", \"L\", \"I\"):\n                return Image.new(\"I\", self.im.size, im1)\n            else:\n                return Image.new(\"F\", self.im.size, im1)\n\n    def apply(\n        self,\n        op: str,\n        im1: _Operand | float,\n        im2: _Operand | float | None = None,\n        mode: str | None = None,\n    ) -> _Operand:\n        im_1 = self.__fixup(im1)\n        if im2 is None:\n            # unary operation\n            out = Image.new(mode or im_1.mode, im_1.size, None)\n            im_1.load()\n            try:\n                op = getattr(_imagingmath, f\"{op}_{im_1.mode}\")\n            except AttributeError as e:\n                msg = f\"bad operand type for '{op}'\"\n                raise TypeError(msg) from e\n            _imagingmath.unop(op, out.im.id, im_1.im.id)\n        else:\n            # binary operation\n            im_2 = self.__fixup(im2)\n            if im_1.mode != im_2.mode:\n                # convert both arguments to floating point\n                if im_1.mode != \"F\":\n                    im_1 = im_1.convert(\"F\")\n                if im_2.mode != \"F\":\n                    im_2 = im_2.convert(\"F\")\n            if im_1.size != im_2.size:\n                # crop both arguments to a common size\n                size = (\n                    min(im_1.size[0], im_2.size[0]),\n                    min(im_1.size[1], im_2.size[1]),\n                )\n                if im_1.size != size:\n                    im_1 = im_1.crop((0, 0) + size)\n                if im_2.size != size:\n                    im_2 = im_2.crop((0, 0) + size)\n            out = Image.new(mode or im_1.mode, im_1.size, None)\n            im_1.load()\n            im_2.load()\n            try:\n                op = getattr(_imagingmath, f\"{op}_{im_1.mode}\")\n            except AttributeError as e:\n                msg = f\"bad operand type for '{op}'\"\n                raise TypeError(msg) from e\n            _imagingmath.binop(op, out.im.id, im_1.im.id, im_2.im.id)\n        return _Operand(out)\n\n    # unary operators\n    def __bool__(self) -> bool:\n        # an image is \"true\" if it contains at least one non-zero pixel\n        return self.im.getbbox() is not None\n\n    def __abs__(self) -> _Operand:\n        return self.apply(\"abs\", self)\n\n    def __pos__(self) -> _Operand:\n        return self\n\n    def __neg__(self) -> _Operand:\n        return self.apply(\"neg\", self)\n\n    # binary operators\n    def __add__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"add\", self, other)\n\n    def __radd__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"add\", other, self)\n\n    def __sub__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"sub\", self, other)\n\n    def __rsub__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"sub\", other, self)\n\n    def __mul__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mul\", self, other)\n\n    def __rmul__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mul\", other, self)\n\n    def __truediv__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"div\", self, other)\n\n    def __rtruediv__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"div\", other, self)\n\n    def __mod__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mod\", self, other)\n\n    def __rmod__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"mod\", other, self)\n\n    def __pow__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"pow\", self, other)\n\n    def __rpow__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"pow\", other, self)\n\n    # bitwise\n    def __invert__(self) -> _Operand:\n        return self.apply(\"invert\", self)\n\n    def __and__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"and\", self, other)\n\n    def __rand__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"and\", other, self)\n\n    def __or__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"or\", self, other)\n\n    def __ror__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"or\", other, self)\n\n    def __xor__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"xor\", self, other)\n\n    def __rxor__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"xor\", other, self)\n\n    def __lshift__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"lshift\", self, other)\n\n    def __rshift__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"rshift\", self, other)\n\n    # logical\n    def __eq__(self, other):\n        return self.apply(\"eq\", self, other)\n\n    def __ne__(self, other):\n        return self.apply(\"ne\", self, other)\n\n    def __lt__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"lt\", self, other)\n\n    def __le__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"le\", self, other)\n\n    def __gt__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"gt\", self, other)\n\n    def __ge__(self, other: _Operand | float) -> _Operand:\n        return self.apply(\"ge\", self, other)\n\n\n# conversions\ndef imagemath_int(self: _Operand) -> _Operand:\n    return _Operand(self.im.convert(\"I\"))\n\n\ndef imagemath_float(self: _Operand) -> _Operand:\n    return _Operand(self.im.convert(\"F\"))\n\n\n# logical\ndef imagemath_equal(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"eq\", self, other, mode=\"I\")\n\n\ndef imagemath_notequal(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"ne\", self, other, mode=\"I\")\n\n\ndef imagemath_min(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"min\", self, other)\n\n\ndef imagemath_max(self: _Operand, other: _Operand | float | None) -> _Operand:\n    return self.apply(\"max\", self, other)\n\n\ndef imagemath_convert(self: _Operand, mode: str) -> _Operand:\n    return _Operand(self.im.convert(mode))\n\n\nops = {\n    \"int\": imagemath_int,\n    \"float\": imagemath_float,\n    \"equal\": imagemath_equal,\n    \"notequal\": imagemath_notequal,\n    \"min\": imagemath_min,\n    \"max\": imagemath_max,\n    \"convert\": imagemath_convert,\n}\n\n\ndef lambda_eval(\n    expression: Callable[[dict[str, Any]], Any],\n    options: dict[str, Any] = {},\n    **kw: Any,\n) -> Any:\n    \"\"\"\n    Returns the result of an image function.\n\n    :py:mod:`~PIL.ImageMath` only supports single-layer images. To process multi-band\n    images, use the :py:meth:`~PIL.Image.Image.split` method or\n    :py:func:`~PIL.Image.merge` function.\n\n    :param expression: A function that receives a dictionary.\n    :param options: Values to add to the function's dictionary. You\n                    can either use a dictionary, or one or more keyword\n                    arguments.\n    :return: The expression result. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.\n    \"\"\"\n\n    args: dict[str, Any] = ops.copy()\n    args.update(options)\n    args.update(kw)\n    for k, v in args.items():\n        if hasattr(v, \"im\"):\n            args[k] = _Operand(v)\n\n    out = expression(args)\n    try:\n        return out.im\n    except AttributeError:\n        return out\n\n\ndef unsafe_eval(\n    expression: str,\n    options: dict[str, Any] = {},\n    **kw: Any,\n) -> Any:\n    \"\"\"\n    Evaluates an image expression. This uses Python's ``eval()`` function to process\n    the expression string, and carries the security risks of doing so. It is not\n    recommended to process expressions without considering this.\n    :py:meth:`~lambda_eval` is a more secure alternative.\n\n    :py:mod:`~PIL.ImageMath` only supports single-layer images. To process multi-band\n    images, use the :py:meth:`~PIL.Image.Image.split` method or\n    :py:func:`~PIL.Image.merge` function.\n\n    :param expression: A string containing a Python-style expression.\n    :param options: Values to add to the evaluation context.  You\n                    can either use a dictionary, or one or more keyword\n                    arguments.\n    :return: The evaluated expression. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.\n    \"\"\"\n\n    # build execution namespace\n    args: dict[str, Any] = ops.copy()\n    for k in list(options.keys()) + list(kw.keys()):\n        if \"__\" in k or hasattr(builtins, k):\n            msg = f\"'{k}' not allowed\"\n            raise ValueError(msg)\n\n    args.update(options)\n    args.update(kw)\n    for k, v in args.items():\n        if hasattr(v, \"im\"):\n            args[k] = _Operand(v)\n\n    compiled_code = compile(expression, \"<string>\", \"eval\")\n\n    def scan(code: CodeType) -> None:\n        for const in code.co_consts:\n            if type(const) is type(compiled_code):\n                scan(const)\n\n        for name in code.co_names:\n            if name not in args and name != \"abs\":\n                msg = f\"'{name}' not allowed\"\n                raise ValueError(msg)\n\n    scan(compiled_code)\n    out = builtins.eval(expression, {\"__builtins\": {\"abs\": abs}}, args)\n    try:\n        return out.im\n    except AttributeError:\n        return out\n\n\ndef eval(\n    expression: str,\n    _dict: dict[str, Any] = {},\n    **kw: Any,\n) -> Any:\n    \"\"\"\n    Evaluates an image expression.\n\n    Deprecated. Use lambda_eval() or unsafe_eval() instead.\n\n    :param expression: A string containing a Python-style expression.\n    :param _dict: Values to add to the evaluation context.  You\n                  can either use a dictionary, or one or more keyword\n                  arguments.\n    :return: The evaluated expression. This is usually an image object, but can\n             also be an integer, a floating point value, or a pixel tuple,\n             depending on the expression.\n\n    ..  deprecated:: 10.3.0\n    \"\"\"\n\n    deprecate(\n        \"ImageMath.eval\",\n        12,\n        \"ImageMath.lambda_eval or ImageMath.unsafe_eval\",\n    )\n    return unsafe_eval(expression, _dict, **kw)\n", "src/PIL/JpegPresets.py": "\"\"\"\nJPEG quality settings equivalent to the Photoshop settings.\nCan be used when saving JPEG files.\n\nThe following presets are available by default:\n``web_low``, ``web_medium``, ``web_high``, ``web_very_high``, ``web_maximum``,\n``low``, ``medium``, ``high``, ``maximum``.\nMore presets can be added to the :py:data:`presets` dict if needed.\n\nTo apply the preset, specify::\n\n  quality=\"preset_name\"\n\nTo apply only the quantization table::\n\n  qtables=\"preset_name\"\n\nTo apply only the subsampling setting::\n\n  subsampling=\"preset_name\"\n\nExample::\n\n  im.save(\"image_name.jpg\", quality=\"web_high\")\n\nSubsampling\n-----------\n\nSubsampling is the practice of encoding images by implementing less resolution\nfor chroma information than for luma information.\n(ref.: https://en.wikipedia.org/wiki/Chroma_subsampling)\n\nPossible subsampling values are 0, 1 and 2 that correspond to 4:4:4, 4:2:2 and\n4:2:0.\n\nYou can get the subsampling of a JPEG with the\n:func:`.JpegImagePlugin.get_sampling` function.\n\nIn JPEG compressed data a JPEG marker is used instead of an EXIF\u00a0tag.\n(ref.: https://web.archive.org/web/20240227115053/https://exiv2.org/tags.html)\n\n\nQuantization tables\n-------------------\n\nThey are values use by the DCT (Discrete cosine transform) to remove\n*unnecessary* information from the image (the lossy part of the compression).\n(ref.: https://en.wikipedia.org/wiki/Quantization_matrix#Quantization_matrices,\nhttps://en.wikipedia.org/wiki/JPEG#Quantization)\n\nYou can get the quantization tables of a JPEG with::\n\n  im.quantization\n\nThis will return a dict with a number of lists. You can pass this dict\ndirectly as the qtables argument when saving a JPEG.\n\nThe quantization table format in presets is a list with sublists. These formats\nare interchangeable.\n\nLibjpeg ref.:\nhttps://web.archive.org/web/20120328125543/http://www.jpegcameras.com/libjpeg/libjpeg-3.html\n\n\"\"\"\n\nfrom __future__ import annotations\n\n# fmt: off\npresets = {\n            'web_low':      {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [20, 16, 25, 39, 50, 46, 62, 68,\n                                16, 18, 23, 38, 38, 53, 65, 68,\n                                25, 23, 31, 38, 53, 65, 68, 68,\n                                39, 38, 38, 53, 65, 68, 68, 68,\n                                50, 38, 53, 65, 68, 68, 68, 68,\n                                46, 53, 65, 68, 68, 68, 68, 68,\n                                62, 65, 68, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68],\n                               [21, 25, 32, 38, 54, 68, 68, 68,\n                                25, 28, 24, 38, 54, 68, 68, 68,\n                                32, 24, 32, 43, 66, 68, 68, 68,\n                                38, 38, 43, 53, 68, 68, 68, 68,\n                                54, 54, 66, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68,\n                                68, 68, 68, 68, 68, 68, 68, 68]\n                              ]},\n            'web_medium':   {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [16, 11, 11, 16, 23, 27, 31, 30,\n                                11, 12, 12, 15, 20, 23, 23, 30,\n                                11, 12, 13, 16, 23, 26, 35, 47,\n                                16, 15, 16, 23, 26, 37, 47, 64,\n                                23, 20, 23, 26, 39, 51, 64, 64,\n                                27, 23, 26, 37, 51, 64, 64, 64,\n                                31, 23, 35, 47, 64, 64, 64, 64,\n                                30, 30, 47, 64, 64, 64, 64, 64],\n                               [17, 15, 17, 21, 20, 26, 38, 48,\n                                15, 19, 18, 17, 20, 26, 35, 43,\n                                17, 18, 20, 22, 26, 30, 46, 53,\n                                21, 17, 22, 28, 30, 39, 53, 64,\n                                20, 20, 26, 30, 39, 48, 64, 64,\n                                26, 26, 30, 39, 48, 63, 64, 64,\n                                38, 35, 46, 53, 64, 64, 64, 64,\n                                48, 43, 53, 64, 64, 64, 64, 64]\n                             ]},\n            'web_high':     {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                               [6,   4,  4,  6,  9, 11, 12, 16,\n                                4,   5,  5,  6,  8, 10, 12, 12,\n                                4,   5,  5,  6, 10, 12, 14, 19,\n                                6,   6,  6, 11, 12, 15, 19, 28,\n                                9,   8, 10, 12, 16, 20, 27, 31,\n                                11, 10, 12, 15, 20, 27, 31, 31,\n                                12, 12, 14, 19, 27, 31, 31, 31,\n                                16, 12, 19, 28, 31, 31, 31, 31],\n                               [7,   7, 13, 24, 26, 31, 31, 31,\n                                7,  12, 16, 21, 31, 31, 31, 31,\n                                13, 16, 17, 31, 31, 31, 31, 31,\n                                24, 21, 31, 31, 31, 31, 31, 31,\n                                26, 31, 31, 31, 31, 31, 31, 31,\n                                31, 31, 31, 31, 31, 31, 31, 31,\n                                31, 31, 31, 31, 31, 31, 31, 31,\n                                31, 31, 31, 31, 31, 31, 31, 31]\n                             ]},\n            'web_very_high': {'subsampling':  0,  # \"4:4:4\"\n                              'quantization': [\n                               [2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  4,  5,  7,  9,\n                                2,   2,  2,  4,  5,  7,  9, 12,\n                                3,   3,  4,  5,  8, 10, 12, 12,\n                                4,   4,  5,  7, 10, 12, 12, 12,\n                                5,   5,  7,  9, 12, 12, 12, 12,\n                                6,   6,  9, 12, 12, 12, 12, 12],\n                               [3,   3,  5,  9, 13, 15, 15, 15,\n                                3,   4,  6, 11, 14, 12, 12, 12,\n                                5,   6,  9, 14, 12, 12, 12, 12,\n                                9,  11, 14, 12, 12, 12, 12, 12,\n                                13, 14, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12]\n                              ]},\n            'web_maximum':  {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                                [1,  1,  1,  1,  1,  1,  1,  1,\n                                 1,  1,  1,  1,  1,  1,  1,  1,\n                                 1,  1,  1,  1,  1,  1,  1,  2,\n                                 1,  1,  1,  1,  1,  1,  2,  2,\n                                 1,  1,  1,  1,  1,  2,  2,  3,\n                                 1,  1,  1,  1,  2,  2,  3,  3,\n                                 1,  1,  1,  2,  2,  3,  3,  3,\n                                 1,  1,  2,  2,  3,  3,  3,  3],\n                                [1,  1,  1,  2,  2,  3,  3,  3,\n                                 1,  1,  1,  2,  3,  3,  3,  3,\n                                 1,  1,  1,  3,  3,  3,  3,  3,\n                                 2,  2,  3,  3,  3,  3,  3,  3,\n                                 2,  3,  3,  3,  3,  3,  3,  3,\n                                 3,  3,  3,  3,  3,  3,  3,  3,\n                                 3,  3,  3,  3,  3,  3,  3,  3,\n                                 3,  3,  3,  3,  3,  3,  3,  3]\n                             ]},\n            'low':          {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [18, 14, 14, 21, 30, 35, 34, 17,\n                                14, 16, 16, 19, 26, 23, 12, 12,\n                                14, 16, 17, 21, 23, 12, 12, 12,\n                                21, 19, 21, 23, 12, 12, 12, 12,\n                                30, 26, 23, 12, 12, 12, 12, 12,\n                                35, 23, 12, 12, 12, 12, 12, 12,\n                                34, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12],\n                               [20, 19, 22, 27, 20, 20, 17, 17,\n                                19, 25, 23, 14, 14, 12, 12, 12,\n                                22, 23, 14, 14, 12, 12, 12, 12,\n                                27, 14, 14, 12, 12, 12, 12, 12,\n                                20, 14, 12, 12, 12, 12, 12, 12,\n                                20, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n            'medium':       {'subsampling':  2,  # \"4:2:0\"\n                             'quantization': [\n                               [12,  8,  8, 12, 17, 21, 24, 17,\n                                8,   9,  9, 11, 15, 19, 12, 12,\n                                8,   9, 10, 12, 19, 12, 12, 12,\n                                12, 11, 12, 21, 12, 12, 12, 12,\n                                17, 15, 19, 12, 12, 12, 12, 12,\n                                21, 19, 12, 12, 12, 12, 12, 12,\n                                24, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12],\n                               [13, 11, 13, 16, 20, 20, 17, 17,\n                                11, 14, 14, 14, 14, 12, 12, 12,\n                                13, 14, 14, 14, 12, 12, 12, 12,\n                                16, 14, 14, 12, 12, 12, 12, 12,\n                                20, 14, 12, 12, 12, 12, 12, 12,\n                                20, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n            'high':         {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                               [6,   4,  4,  6,  9, 11, 12, 16,\n                                4,   5,  5,  6,  8, 10, 12, 12,\n                                4,   5,  5,  6, 10, 12, 12, 12,\n                                6,   6,  6, 11, 12, 12, 12, 12,\n                                9,   8, 10, 12, 12, 12, 12, 12,\n                                11, 10, 12, 12, 12, 12, 12, 12,\n                                12, 12, 12, 12, 12, 12, 12, 12,\n                                16, 12, 12, 12, 12, 12, 12, 12],\n                               [7,   7, 13, 24, 20, 20, 17, 17,\n                                7,  12, 16, 14, 14, 12, 12, 12,\n                                13, 16, 14, 14, 12, 12, 12, 12,\n                                24, 14, 14, 12, 12, 12, 12, 12,\n                                20, 14, 12, 12, 12, 12, 12, 12,\n                                20, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12,\n                                17, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n            'maximum':      {'subsampling':  0,  # \"4:4:4\"\n                             'quantization': [\n                               [2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  3,  4,  5,  6,\n                                2,   2,  2,  2,  4,  5,  7,  9,\n                                2,   2,  2,  4,  5,  7,  9, 12,\n                                3,   3,  4,  5,  8, 10, 12, 12,\n                                4,   4,  5,  7, 10, 12, 12, 12,\n                                5,   5,  7,  9, 12, 12, 12, 12,\n                                6,   6,  9, 12, 12, 12, 12, 12],\n                               [3,   3,  5,  9, 13, 15, 15, 15,\n                                3,   4,  6, 10, 14, 12, 12, 12,\n                                5,   6,  9, 14, 12, 12, 12, 12,\n                                9,  10, 14, 12, 12, 12, 12, 12,\n                                13, 14, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12,\n                                15, 12, 12, 12, 12, 12, 12, 12]\n                             ]},\n}\n# fmt: on\n", "src/PIL/TiffTags.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# TIFF tags\n#\n# This module provides clear-text names for various well-known\n# TIFF tags.  the TIFF codec works just fine without it.\n#\n# Copyright (c) Secret Labs AB 1999.\n#\n# See the README file for information on usage and redistribution.\n#\n\n##\n# This module provides constants and clear-text names for various\n# well-known TIFF tags.\n##\nfrom __future__ import annotations\n\nfrom typing import NamedTuple\n\n\nclass _TagInfo(NamedTuple):\n    value: int | None\n    name: str\n    type: int | None\n    length: int | None\n    enum: dict[str, int]\n\n\nclass TagInfo(_TagInfo):\n    __slots__: list[str] = []\n\n    def __new__(cls, value=None, name=\"unknown\", type=None, length=None, enum=None):\n        return super().__new__(cls, value, name, type, length, enum or {})\n\n    def cvt_enum(self, value):\n        # Using get will call hash(value), which can be expensive\n        # for some types (e.g. Fraction). Since self.enum is rarely\n        # used, it's usually better to test it first.\n        return self.enum.get(value, value) if self.enum else value\n\n\ndef lookup(tag, group=None):\n    \"\"\"\n    :param tag: Integer tag number\n    :param group: Which :py:data:`~PIL.TiffTags.TAGS_V2_GROUPS` to look in\n\n    .. versionadded:: 8.3.0\n\n    :returns: Taginfo namedtuple, From the ``TAGS_V2`` info if possible,\n        otherwise just populating the value and name from ``TAGS``.\n        If the tag is not recognized, \"unknown\" is returned for the name\n\n    \"\"\"\n\n    if group is not None:\n        info = TAGS_V2_GROUPS[group].get(tag) if group in TAGS_V2_GROUPS else None\n    else:\n        info = TAGS_V2.get(tag)\n    return info or TagInfo(tag, TAGS.get(tag, \"unknown\"))\n\n\n##\n# Map tag numbers to tag info.\n#\n#  id: (Name, Type, Length[, enum_values])\n#\n# The length here differs from the length in the tiff spec.  For\n# numbers, the tiff spec is for the number of fields returned. We\n# agree here.  For string-like types, the tiff spec uses the length of\n# field in bytes.  In Pillow, we are using the number of expected\n# fields, in general 1 for string-like types.\n\n\nBYTE = 1\nASCII = 2\nSHORT = 3\nLONG = 4\nRATIONAL = 5\nSIGNED_BYTE = 6\nUNDEFINED = 7\nSIGNED_SHORT = 8\nSIGNED_LONG = 9\nSIGNED_RATIONAL = 10\nFLOAT = 11\nDOUBLE = 12\nIFD = 13\nLONG8 = 16\n\n_tags_v2 = {\n    254: (\"NewSubfileType\", LONG, 1),\n    255: (\"SubfileType\", SHORT, 1),\n    256: (\"ImageWidth\", LONG, 1),\n    257: (\"ImageLength\", LONG, 1),\n    258: (\"BitsPerSample\", SHORT, 0),\n    259: (\n        \"Compression\",\n        SHORT,\n        1,\n        {\n            \"Uncompressed\": 1,\n            \"CCITT 1d\": 2,\n            \"Group 3 Fax\": 3,\n            \"Group 4 Fax\": 4,\n            \"LZW\": 5,\n            \"JPEG\": 6,\n            \"PackBits\": 32773,\n        },\n    ),\n    262: (\n        \"PhotometricInterpretation\",\n        SHORT,\n        1,\n        {\n            \"WhiteIsZero\": 0,\n            \"BlackIsZero\": 1,\n            \"RGB\": 2,\n            \"RGB Palette\": 3,\n            \"Transparency Mask\": 4,\n            \"CMYK\": 5,\n            \"YCbCr\": 6,\n            \"CieLAB\": 8,\n            \"CFA\": 32803,  # TIFF/EP, Adobe DNG\n            \"LinearRaw\": 32892,  # Adobe DNG\n        },\n    ),\n    263: (\"Threshholding\", SHORT, 1),\n    264: (\"CellWidth\", SHORT, 1),\n    265: (\"CellLength\", SHORT, 1),\n    266: (\"FillOrder\", SHORT, 1),\n    269: (\"DocumentName\", ASCII, 1),\n    270: (\"ImageDescription\", ASCII, 1),\n    271: (\"Make\", ASCII, 1),\n    272: (\"Model\", ASCII, 1),\n    273: (\"StripOffsets\", LONG, 0),\n    274: (\"Orientation\", SHORT, 1),\n    277: (\"SamplesPerPixel\", SHORT, 1),\n    278: (\"RowsPerStrip\", LONG, 1),\n    279: (\"StripByteCounts\", LONG, 0),\n    280: (\"MinSampleValue\", SHORT, 0),\n    281: (\"MaxSampleValue\", SHORT, 0),\n    282: (\"XResolution\", RATIONAL, 1),\n    283: (\"YResolution\", RATIONAL, 1),\n    284: (\"PlanarConfiguration\", SHORT, 1, {\"Contiguous\": 1, \"Separate\": 2}),\n    285: (\"PageName\", ASCII, 1),\n    286: (\"XPosition\", RATIONAL, 1),\n    287: (\"YPosition\", RATIONAL, 1),\n    288: (\"FreeOffsets\", LONG, 1),\n    289: (\"FreeByteCounts\", LONG, 1),\n    290: (\"GrayResponseUnit\", SHORT, 1),\n    291: (\"GrayResponseCurve\", SHORT, 0),\n    292: (\"T4Options\", LONG, 1),\n    293: (\"T6Options\", LONG, 1),\n    296: (\"ResolutionUnit\", SHORT, 1, {\"none\": 1, \"inch\": 2, \"cm\": 3}),\n    297: (\"PageNumber\", SHORT, 2),\n    301: (\"TransferFunction\", SHORT, 0),\n    305: (\"Software\", ASCII, 1),\n    306: (\"DateTime\", ASCII, 1),\n    315: (\"Artist\", ASCII, 1),\n    316: (\"HostComputer\", ASCII, 1),\n    317: (\"Predictor\", SHORT, 1, {\"none\": 1, \"Horizontal Differencing\": 2}),\n    318: (\"WhitePoint\", RATIONAL, 2),\n    319: (\"PrimaryChromaticities\", RATIONAL, 6),\n    320: (\"ColorMap\", SHORT, 0),\n    321: (\"HalftoneHints\", SHORT, 2),\n    322: (\"TileWidth\", LONG, 1),\n    323: (\"TileLength\", LONG, 1),\n    324: (\"TileOffsets\", LONG, 0),\n    325: (\"TileByteCounts\", LONG, 0),\n    330: (\"SubIFDs\", LONG, 0),\n    332: (\"InkSet\", SHORT, 1),\n    333: (\"InkNames\", ASCII, 1),\n    334: (\"NumberOfInks\", SHORT, 1),\n    336: (\"DotRange\", SHORT, 0),\n    337: (\"TargetPrinter\", ASCII, 1),\n    338: (\"ExtraSamples\", SHORT, 0),\n    339: (\"SampleFormat\", SHORT, 0),\n    340: (\"SMinSampleValue\", DOUBLE, 0),\n    341: (\"SMaxSampleValue\", DOUBLE, 0),\n    342: (\"TransferRange\", SHORT, 6),\n    347: (\"JPEGTables\", UNDEFINED, 1),\n    # obsolete JPEG tags\n    512: (\"JPEGProc\", SHORT, 1),\n    513: (\"JPEGInterchangeFormat\", LONG, 1),\n    514: (\"JPEGInterchangeFormatLength\", LONG, 1),\n    515: (\"JPEGRestartInterval\", SHORT, 1),\n    517: (\"JPEGLosslessPredictors\", SHORT, 0),\n    518: (\"JPEGPointTransforms\", SHORT, 0),\n    519: (\"JPEGQTables\", LONG, 0),\n    520: (\"JPEGDCTables\", LONG, 0),\n    521: (\"JPEGACTables\", LONG, 0),\n    529: (\"YCbCrCoefficients\", RATIONAL, 3),\n    530: (\"YCbCrSubSampling\", SHORT, 2),\n    531: (\"YCbCrPositioning\", SHORT, 1),\n    532: (\"ReferenceBlackWhite\", RATIONAL, 6),\n    700: (\"XMP\", BYTE, 0),\n    33432: (\"Copyright\", ASCII, 1),\n    33723: (\"IptcNaaInfo\", UNDEFINED, 1),\n    34377: (\"PhotoshopInfo\", BYTE, 0),\n    # FIXME add more tags here\n    34665: (\"ExifIFD\", LONG, 1),\n    34675: (\"ICCProfile\", UNDEFINED, 1),\n    34853: (\"GPSInfoIFD\", LONG, 1),\n    36864: (\"ExifVersion\", UNDEFINED, 1),\n    37724: (\"ImageSourceData\", UNDEFINED, 1),\n    40965: (\"InteroperabilityIFD\", LONG, 1),\n    41730: (\"CFAPattern\", UNDEFINED, 1),\n    # MPInfo\n    45056: (\"MPFVersion\", UNDEFINED, 1),\n    45057: (\"NumberOfImages\", LONG, 1),\n    45058: (\"MPEntry\", UNDEFINED, 1),\n    45059: (\"ImageUIDList\", UNDEFINED, 0),  # UNDONE, check\n    45060: (\"TotalFrames\", LONG, 1),\n    45313: (\"MPIndividualNum\", LONG, 1),\n    45569: (\"PanOrientation\", LONG, 1),\n    45570: (\"PanOverlap_H\", RATIONAL, 1),\n    45571: (\"PanOverlap_V\", RATIONAL, 1),\n    45572: (\"BaseViewpointNum\", LONG, 1),\n    45573: (\"ConvergenceAngle\", SIGNED_RATIONAL, 1),\n    45574: (\"BaselineLength\", RATIONAL, 1),\n    45575: (\"VerticalDivergence\", SIGNED_RATIONAL, 1),\n    45576: (\"AxisDistance_X\", SIGNED_RATIONAL, 1),\n    45577: (\"AxisDistance_Y\", SIGNED_RATIONAL, 1),\n    45578: (\"AxisDistance_Z\", SIGNED_RATIONAL, 1),\n    45579: (\"YawAngle\", SIGNED_RATIONAL, 1),\n    45580: (\"PitchAngle\", SIGNED_RATIONAL, 1),\n    45581: (\"RollAngle\", SIGNED_RATIONAL, 1),\n    40960: (\"FlashPixVersion\", UNDEFINED, 1),\n    50741: (\"MakerNoteSafety\", SHORT, 1, {\"Unsafe\": 0, \"Safe\": 1}),\n    50780: (\"BestQualityScale\", RATIONAL, 1),\n    50838: (\"ImageJMetaDataByteCounts\", LONG, 0),  # Can be more than one\n    50839: (\"ImageJMetaData\", UNDEFINED, 1),  # see Issue #2006\n}\nTAGS_V2_GROUPS = {\n    # ExifIFD\n    34665: {\n        36864: (\"ExifVersion\", UNDEFINED, 1),\n        40960: (\"FlashPixVersion\", UNDEFINED, 1),\n        40965: (\"InteroperabilityIFD\", LONG, 1),\n        41730: (\"CFAPattern\", UNDEFINED, 1),\n    },\n    # GPSInfoIFD\n    34853: {\n        0: (\"GPSVersionID\", BYTE, 4),\n        1: (\"GPSLatitudeRef\", ASCII, 2),\n        2: (\"GPSLatitude\", RATIONAL, 3),\n        3: (\"GPSLongitudeRef\", ASCII, 2),\n        4: (\"GPSLongitude\", RATIONAL, 3),\n        5: (\"GPSAltitudeRef\", BYTE, 1),\n        6: (\"GPSAltitude\", RATIONAL, 1),\n        7: (\"GPSTimeStamp\", RATIONAL, 3),\n        8: (\"GPSSatellites\", ASCII, 0),\n        9: (\"GPSStatus\", ASCII, 2),\n        10: (\"GPSMeasureMode\", ASCII, 2),\n        11: (\"GPSDOP\", RATIONAL, 1),\n        12: (\"GPSSpeedRef\", ASCII, 2),\n        13: (\"GPSSpeed\", RATIONAL, 1),\n        14: (\"GPSTrackRef\", ASCII, 2),\n        15: (\"GPSTrack\", RATIONAL, 1),\n        16: (\"GPSImgDirectionRef\", ASCII, 2),\n        17: (\"GPSImgDirection\", RATIONAL, 1),\n        18: (\"GPSMapDatum\", ASCII, 0),\n        19: (\"GPSDestLatitudeRef\", ASCII, 2),\n        20: (\"GPSDestLatitude\", RATIONAL, 3),\n        21: (\"GPSDestLongitudeRef\", ASCII, 2),\n        22: (\"GPSDestLongitude\", RATIONAL, 3),\n        23: (\"GPSDestBearingRef\", ASCII, 2),\n        24: (\"GPSDestBearing\", RATIONAL, 1),\n        25: (\"GPSDestDistanceRef\", ASCII, 2),\n        26: (\"GPSDestDistance\", RATIONAL, 1),\n        27: (\"GPSProcessingMethod\", UNDEFINED, 0),\n        28: (\"GPSAreaInformation\", UNDEFINED, 0),\n        29: (\"GPSDateStamp\", ASCII, 11),\n        30: (\"GPSDifferential\", SHORT, 1),\n    },\n    # InteroperabilityIFD\n    40965: {1: (\"InteropIndex\", ASCII, 1), 2: (\"InteropVersion\", UNDEFINED, 1)},\n}\n\n# Legacy Tags structure\n# these tags aren't included above, but were in the previous versions\nTAGS = {\n    347: \"JPEGTables\",\n    700: \"XMP\",\n    # Additional Exif Info\n    32932: \"Wang Annotation\",\n    33434: \"ExposureTime\",\n    33437: \"FNumber\",\n    33445: \"MD FileTag\",\n    33446: \"MD ScalePixel\",\n    33447: \"MD ColorTable\",\n    33448: \"MD LabName\",\n    33449: \"MD SampleInfo\",\n    33450: \"MD PrepDate\",\n    33451: \"MD PrepTime\",\n    33452: \"MD FileUnits\",\n    33550: \"ModelPixelScaleTag\",\n    33723: \"IptcNaaInfo\",\n    33918: \"INGR Packet Data Tag\",\n    33919: \"INGR Flag Registers\",\n    33920: \"IrasB Transformation Matrix\",\n    33922: \"ModelTiepointTag\",\n    34264: \"ModelTransformationTag\",\n    34377: \"PhotoshopInfo\",\n    34735: \"GeoKeyDirectoryTag\",\n    34736: \"GeoDoubleParamsTag\",\n    34737: \"GeoAsciiParamsTag\",\n    34850: \"ExposureProgram\",\n    34852: \"SpectralSensitivity\",\n    34855: \"ISOSpeedRatings\",\n    34856: \"OECF\",\n    34864: \"SensitivityType\",\n    34865: \"StandardOutputSensitivity\",\n    34866: \"RecommendedExposureIndex\",\n    34867: \"ISOSpeed\",\n    34868: \"ISOSpeedLatitudeyyy\",\n    34869: \"ISOSpeedLatitudezzz\",\n    34908: \"HylaFAX FaxRecvParams\",\n    34909: \"HylaFAX FaxSubAddress\",\n    34910: \"HylaFAX FaxRecvTime\",\n    36864: \"ExifVersion\",\n    36867: \"DateTimeOriginal\",\n    36868: \"DateTimeDigitized\",\n    37121: \"ComponentsConfiguration\",\n    37122: \"CompressedBitsPerPixel\",\n    37724: \"ImageSourceData\",\n    37377: \"ShutterSpeedValue\",\n    37378: \"ApertureValue\",\n    37379: \"BrightnessValue\",\n    37380: \"ExposureBiasValue\",\n    37381: \"MaxApertureValue\",\n    37382: \"SubjectDistance\",\n    37383: \"MeteringMode\",\n    37384: \"LightSource\",\n    37385: \"Flash\",\n    37386: \"FocalLength\",\n    37396: \"SubjectArea\",\n    37500: \"MakerNote\",\n    37510: \"UserComment\",\n    37520: \"SubSec\",\n    37521: \"SubSecTimeOriginal\",\n    37522: \"SubsecTimeDigitized\",\n    40960: \"FlashPixVersion\",\n    40961: \"ColorSpace\",\n    40962: \"PixelXDimension\",\n    40963: \"PixelYDimension\",\n    40964: \"RelatedSoundFile\",\n    40965: \"InteroperabilityIFD\",\n    41483: \"FlashEnergy\",\n    41484: \"SpatialFrequencyResponse\",\n    41486: \"FocalPlaneXResolution\",\n    41487: \"FocalPlaneYResolution\",\n    41488: \"FocalPlaneResolutionUnit\",\n    41492: \"SubjectLocation\",\n    41493: \"ExposureIndex\",\n    41495: \"SensingMethod\",\n    41728: \"FileSource\",\n    41729: \"SceneType\",\n    41730: \"CFAPattern\",\n    41985: \"CustomRendered\",\n    41986: \"ExposureMode\",\n    41987: \"WhiteBalance\",\n    41988: \"DigitalZoomRatio\",\n    41989: \"FocalLengthIn35mmFilm\",\n    41990: \"SceneCaptureType\",\n    41991: \"GainControl\",\n    41992: \"Contrast\",\n    41993: \"Saturation\",\n    41994: \"Sharpness\",\n    41995: \"DeviceSettingDescription\",\n    41996: \"SubjectDistanceRange\",\n    42016: \"ImageUniqueID\",\n    42032: \"CameraOwnerName\",\n    42033: \"BodySerialNumber\",\n    42034: \"LensSpecification\",\n    42035: \"LensMake\",\n    42036: \"LensModel\",\n    42037: \"LensSerialNumber\",\n    42112: \"GDAL_METADATA\",\n    42113: \"GDAL_NODATA\",\n    42240: \"Gamma\",\n    50215: \"Oce Scanjob Description\",\n    50216: \"Oce Application Selector\",\n    50217: \"Oce Identification Number\",\n    50218: \"Oce ImageLogic Characteristics\",\n    # Adobe DNG\n    50706: \"DNGVersion\",\n    50707: \"DNGBackwardVersion\",\n    50708: \"UniqueCameraModel\",\n    50709: \"LocalizedCameraModel\",\n    50710: \"CFAPlaneColor\",\n    50711: \"CFALayout\",\n    50712: \"LinearizationTable\",\n    50713: \"BlackLevelRepeatDim\",\n    50714: \"BlackLevel\",\n    50715: \"BlackLevelDeltaH\",\n    50716: \"BlackLevelDeltaV\",\n    50717: \"WhiteLevel\",\n    50718: \"DefaultScale\",\n    50719: \"DefaultCropOrigin\",\n    50720: \"DefaultCropSize\",\n    50721: \"ColorMatrix1\",\n    50722: \"ColorMatrix2\",\n    50723: \"CameraCalibration1\",\n    50724: \"CameraCalibration2\",\n    50725: \"ReductionMatrix1\",\n    50726: \"ReductionMatrix2\",\n    50727: \"AnalogBalance\",\n    50728: \"AsShotNeutral\",\n    50729: \"AsShotWhiteXY\",\n    50730: \"BaselineExposure\",\n    50731: \"BaselineNoise\",\n    50732: \"BaselineSharpness\",\n    50733: \"BayerGreenSplit\",\n    50734: \"LinearResponseLimit\",\n    50735: \"CameraSerialNumber\",\n    50736: \"LensInfo\",\n    50737: \"ChromaBlurRadius\",\n    50738: \"AntiAliasStrength\",\n    50740: \"DNGPrivateData\",\n    50778: \"CalibrationIlluminant1\",\n    50779: \"CalibrationIlluminant2\",\n    50784: \"Alias Layer Metadata\",\n}\n\nTAGS_V2: dict[int, TagInfo] = {}\n\n\ndef _populate():\n    for k, v in _tags_v2.items():\n        # Populate legacy structure.\n        TAGS[k] = v[0]\n        if len(v) == 4:\n            for sk, sv in v[3].items():\n                TAGS[(k, sv)] = sk\n\n        TAGS_V2[k] = TagInfo(k, *v)\n\n    for tags in TAGS_V2_GROUPS.values():\n        for k, v in tags.items():\n            tags[k] = TagInfo(k, *v)\n\n\n_populate()\n##\n# Map type numbers to type names -- defined in ImageFileDirectory.\n\nTYPES: dict[int, str] = {}\n\n#\n# These tags are handled by default in libtiff, without\n# adding to the custom dictionary. From tif_dir.c, searching for\n# case TIFFTAG in the _TIFFVSetField function:\n# Line: item.\n# 148: case TIFFTAG_SUBFILETYPE:\n# 151: case TIFFTAG_IMAGEWIDTH:\n# 154: case TIFFTAG_IMAGELENGTH:\n# 157: case TIFFTAG_BITSPERSAMPLE:\n# 181: case TIFFTAG_COMPRESSION:\n# 202: case TIFFTAG_PHOTOMETRIC:\n# 205: case TIFFTAG_THRESHHOLDING:\n# 208: case TIFFTAG_FILLORDER:\n# 214: case TIFFTAG_ORIENTATION:\n# 221: case TIFFTAG_SAMPLESPERPIXEL:\n# 228: case TIFFTAG_ROWSPERSTRIP:\n# 238: case TIFFTAG_MINSAMPLEVALUE:\n# 241: case TIFFTAG_MAXSAMPLEVALUE:\n# 244: case TIFFTAG_SMINSAMPLEVALUE:\n# 247: case TIFFTAG_SMAXSAMPLEVALUE:\n# 250: case TIFFTAG_XRESOLUTION:\n# 256: case TIFFTAG_YRESOLUTION:\n# 262: case TIFFTAG_PLANARCONFIG:\n# 268: case TIFFTAG_XPOSITION:\n# 271: case TIFFTAG_YPOSITION:\n# 274: case TIFFTAG_RESOLUTIONUNIT:\n# 280: case TIFFTAG_PAGENUMBER:\n# 284: case TIFFTAG_HALFTONEHINTS:\n# 288: case TIFFTAG_COLORMAP:\n# 294: case TIFFTAG_EXTRASAMPLES:\n# 298: case TIFFTAG_MATTEING:\n# 305: case TIFFTAG_TILEWIDTH:\n# 316: case TIFFTAG_TILELENGTH:\n# 327: case TIFFTAG_TILEDEPTH:\n# 333: case TIFFTAG_DATATYPE:\n# 344: case TIFFTAG_SAMPLEFORMAT:\n# 361: case TIFFTAG_IMAGEDEPTH:\n# 364: case TIFFTAG_SUBIFD:\n# 376: case TIFFTAG_YCBCRPOSITIONING:\n# 379: case TIFFTAG_YCBCRSUBSAMPLING:\n# 383: case TIFFTAG_TRANSFERFUNCTION:\n# 389: case TIFFTAG_REFERENCEBLACKWHITE:\n# 393: case TIFFTAG_INKNAMES:\n\n# Following pseudo-tags are also handled by default in libtiff:\n# TIFFTAG_JPEGQUALITY 65537\n\n# some of these are not in our TAGS_V2 dict and were included from tiff.h\n\n# This list also exists in encode.c\nLIBTIFF_CORE = {\n    255,\n    256,\n    257,\n    258,\n    259,\n    262,\n    263,\n    266,\n    274,\n    277,\n    278,\n    280,\n    281,\n    340,\n    341,\n    282,\n    283,\n    284,\n    286,\n    287,\n    296,\n    297,\n    321,\n    320,\n    338,\n    32995,\n    322,\n    323,\n    32998,\n    32996,\n    339,\n    32997,\n    330,\n    531,\n    530,\n    301,\n    532,\n    333,\n    # as above\n    269,  # this has been in our tests forever, and works\n    65537,\n}\n\nLIBTIFF_CORE.remove(255)  # We don't have support for subfiletypes\nLIBTIFF_CORE.remove(322)  # We don't have support for writing tiled images with libtiff\nLIBTIFF_CORE.remove(323)  # Tiled images\nLIBTIFF_CORE.remove(333)  # Ink Names either\n\n# Note to advanced users: There may be combinations of these\n# parameters and values that when added properly, will work and\n# produce valid tiff images that may work in your application.\n# It is safe to add and remove tags from this set from Pillow's point\n# of view so long as you test against libtiff.\n", "src/PIL/ImageOps.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard image operations\n#\n# History:\n# 2001-10-20 fl   Created\n# 2001-10-23 fl   Added autocontrast operator\n# 2001-12-18 fl   Added Kevin's fit operator\n# 2004-03-14 fl   Fixed potential division by zero in equalize\n# 2005-05-05 fl   Fixed equalize for low number of values\n#\n# Copyright (c) 2001-2004 by Secret Labs AB\n# Copyright (c) 2001-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport functools\nimport operator\nimport re\nfrom typing import Protocol, Sequence, cast\n\nfrom . import ExifTags, Image, ImagePalette\n\n#\n# helpers\n\n\ndef _border(border: int | tuple[int, ...]) -> tuple[int, int, int, int]:\n    if isinstance(border, tuple):\n        if len(border) == 2:\n            left, top = right, bottom = border\n        elif len(border) == 4:\n            left, top, right, bottom = border\n    else:\n        left = top = right = bottom = border\n    return left, top, right, bottom\n\n\ndef _color(color: str | int | tuple[int, ...], mode: str) -> int | tuple[int, ...]:\n    if isinstance(color, str):\n        from . import ImageColor\n\n        color = ImageColor.getcolor(color, mode)\n    return color\n\n\ndef _lut(image: Image.Image, lut: list[int]) -> Image.Image:\n    if image.mode == \"P\":\n        # FIXME: apply to lookup table, not image data\n        msg = \"mode P support coming soon\"\n        raise NotImplementedError(msg)\n    elif image.mode in (\"L\", \"RGB\"):\n        if image.mode == \"RGB\" and len(lut) == 256:\n            lut = lut + lut + lut\n        return image.point(lut)\n    else:\n        msg = f\"not supported for mode {image.mode}\"\n        raise OSError(msg)\n\n\n#\n# actions\n\n\ndef autocontrast(\n    image: Image.Image,\n    cutoff: float | tuple[float, float] = 0,\n    ignore: int | Sequence[int] | None = None,\n    mask: Image.Image | None = None,\n    preserve_tone: bool = False,\n) -> Image.Image:\n    \"\"\"\n    Maximize (normalize) image contrast. This function calculates a\n    histogram of the input image (or mask region), removes ``cutoff`` percent of the\n    lightest and darkest pixels from the histogram, and remaps the image\n    so that the darkest pixel becomes black (0), and the lightest\n    becomes white (255).\n\n    :param image: The image to process.\n    :param cutoff: The percent to cut off from the histogram on the low and\n                   high ends. Either a tuple of (low, high), or a single\n                   number for both.\n    :param ignore: The background pixel value (use None for no background).\n    :param mask: Histogram used in contrast operation is computed using pixels\n                 within the mask. If no mask is given the entire image is used\n                 for histogram computation.\n    :param preserve_tone: Preserve image tone in Photoshop-like style autocontrast.\n\n                          .. versionadded:: 8.2.0\n\n    :return: An image.\n    \"\"\"\n    if preserve_tone:\n        histogram = image.convert(\"L\").histogram(mask)\n    else:\n        histogram = image.histogram(mask)\n\n    lut = []\n    for layer in range(0, len(histogram), 256):\n        h = histogram[layer : layer + 256]\n        if ignore is not None:\n            # get rid of outliers\n            if isinstance(ignore, int):\n                h[ignore] = 0\n            else:\n                for ix in ignore:\n                    h[ix] = 0\n        if cutoff:\n            # cut off pixels from both ends of the histogram\n            if not isinstance(cutoff, tuple):\n                cutoff = (cutoff, cutoff)\n            # get number of pixels\n            n = 0\n            for ix in range(256):\n                n = n + h[ix]\n            # remove cutoff% pixels from the low end\n            cut = int(n * cutoff[0] // 100)\n            for lo in range(256):\n                if cut > h[lo]:\n                    cut = cut - h[lo]\n                    h[lo] = 0\n                else:\n                    h[lo] -= cut\n                    cut = 0\n                if cut <= 0:\n                    break\n            # remove cutoff% samples from the high end\n            cut = int(n * cutoff[1] // 100)\n            for hi in range(255, -1, -1):\n                if cut > h[hi]:\n                    cut = cut - h[hi]\n                    h[hi] = 0\n                else:\n                    h[hi] -= cut\n                    cut = 0\n                if cut <= 0:\n                    break\n        # find lowest/highest samples after preprocessing\n        for lo in range(256):\n            if h[lo]:\n                break\n        for hi in range(255, -1, -1):\n            if h[hi]:\n                break\n        if hi <= lo:\n            # don't bother\n            lut.extend(list(range(256)))\n        else:\n            scale = 255.0 / (hi - lo)\n            offset = -lo * scale\n            for ix in range(256):\n                ix = int(ix * scale + offset)\n                if ix < 0:\n                    ix = 0\n                elif ix > 255:\n                    ix = 255\n                lut.append(ix)\n    return _lut(image, lut)\n\n\ndef colorize(\n    image: Image.Image,\n    black: str | tuple[int, ...],\n    white: str | tuple[int, ...],\n    mid: str | int | tuple[int, ...] | None = None,\n    blackpoint: int = 0,\n    whitepoint: int = 255,\n    midpoint: int = 127,\n) -> Image.Image:\n    \"\"\"\n    Colorize grayscale image.\n    This function calculates a color wedge which maps all black pixels in\n    the source image to the first color and all white pixels to the\n    second color. If ``mid`` is specified, it uses three-color mapping.\n    The ``black`` and ``white`` arguments should be RGB tuples or color names;\n    optionally you can use three-color mapping by also specifying ``mid``.\n    Mapping positions for any of the colors can be specified\n    (e.g. ``blackpoint``), where these parameters are the integer\n    value corresponding to where the corresponding color should be mapped.\n    These parameters must have logical order, such that\n    ``blackpoint <= midpoint <= whitepoint`` (if ``mid`` is specified).\n\n    :param image: The image to colorize.\n    :param black: The color to use for black input pixels.\n    :param white: The color to use for white input pixels.\n    :param mid: The color to use for midtone input pixels.\n    :param blackpoint: an int value [0, 255] for the black mapping.\n    :param whitepoint: an int value [0, 255] for the white mapping.\n    :param midpoint: an int value [0, 255] for the midtone mapping.\n    :return: An image.\n    \"\"\"\n\n    # Initial asserts\n    assert image.mode == \"L\"\n    if mid is None:\n        assert 0 <= blackpoint <= whitepoint <= 255\n    else:\n        assert 0 <= blackpoint <= midpoint <= whitepoint <= 255\n\n    # Define colors from arguments\n    rgb_black = cast(Sequence[int], _color(black, \"RGB\"))\n    rgb_white = cast(Sequence[int], _color(white, \"RGB\"))\n    rgb_mid = cast(Sequence[int], _color(mid, \"RGB\")) if mid is not None else None\n\n    # Empty lists for the mapping\n    red = []\n    green = []\n    blue = []\n\n    # Create the low-end values\n    for i in range(0, blackpoint):\n        red.append(rgb_black[0])\n        green.append(rgb_black[1])\n        blue.append(rgb_black[2])\n\n    # Create the mapping (2-color)\n    if rgb_mid is None:\n        range_map = range(0, whitepoint - blackpoint)\n\n        for i in range_map:\n            red.append(\n                rgb_black[0] + i * (rgb_white[0] - rgb_black[0]) // len(range_map)\n            )\n            green.append(\n                rgb_black[1] + i * (rgb_white[1] - rgb_black[1]) // len(range_map)\n            )\n            blue.append(\n                rgb_black[2] + i * (rgb_white[2] - rgb_black[2]) // len(range_map)\n            )\n\n    # Create the mapping (3-color)\n    else:\n        range_map1 = range(0, midpoint - blackpoint)\n        range_map2 = range(0, whitepoint - midpoint)\n\n        for i in range_map1:\n            red.append(\n                rgb_black[0] + i * (rgb_mid[0] - rgb_black[0]) // len(range_map1)\n            )\n            green.append(\n                rgb_black[1] + i * (rgb_mid[1] - rgb_black[1]) // len(range_map1)\n            )\n            blue.append(\n                rgb_black[2] + i * (rgb_mid[2] - rgb_black[2]) // len(range_map1)\n            )\n        for i in range_map2:\n            red.append(rgb_mid[0] + i * (rgb_white[0] - rgb_mid[0]) // len(range_map2))\n            green.append(\n                rgb_mid[1] + i * (rgb_white[1] - rgb_mid[1]) // len(range_map2)\n            )\n            blue.append(rgb_mid[2] + i * (rgb_white[2] - rgb_mid[2]) // len(range_map2))\n\n    # Create the high-end values\n    for i in range(0, 256 - whitepoint):\n        red.append(rgb_white[0])\n        green.append(rgb_white[1])\n        blue.append(rgb_white[2])\n\n    # Return converted image\n    image = image.convert(\"RGB\")\n    return _lut(image, red + green + blue)\n\n\ndef contain(\n    image: Image.Image, size: tuple[int, int], method: int = Image.Resampling.BICUBIC\n) -> Image.Image:\n    \"\"\"\n    Returns a resized version of the image, set to the maximum width and height\n    within the requested size, while maintaining the original aspect ratio.\n\n    :param image: The image to resize.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :return: An image.\n    \"\"\"\n\n    im_ratio = image.width / image.height\n    dest_ratio = size[0] / size[1]\n\n    if im_ratio != dest_ratio:\n        if im_ratio > dest_ratio:\n            new_height = round(image.height / image.width * size[0])\n            if new_height != size[1]:\n                size = (size[0], new_height)\n        else:\n            new_width = round(image.width / image.height * size[1])\n            if new_width != size[0]:\n                size = (new_width, size[1])\n    return image.resize(size, resample=method)\n\n\ndef cover(\n    image: Image.Image, size: tuple[int, int], method: int = Image.Resampling.BICUBIC\n) -> Image.Image:\n    \"\"\"\n    Returns a resized version of the image, so that the requested size is\n    covered, while maintaining the original aspect ratio.\n\n    :param image: The image to resize.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :return: An image.\n    \"\"\"\n\n    im_ratio = image.width / image.height\n    dest_ratio = size[0] / size[1]\n\n    if im_ratio != dest_ratio:\n        if im_ratio < dest_ratio:\n            new_height = round(image.height / image.width * size[0])\n            if new_height != size[1]:\n                size = (size[0], new_height)\n        else:\n            new_width = round(image.width / image.height * size[1])\n            if new_width != size[0]:\n                size = (new_width, size[1])\n    return image.resize(size, resample=method)\n\n\ndef pad(\n    image: Image.Image,\n    size: tuple[int, int],\n    method: int = Image.Resampling.BICUBIC,\n    color: str | int | tuple[int, ...] | None = None,\n    centering: tuple[float, float] = (0.5, 0.5),\n) -> Image.Image:\n    \"\"\"\n    Returns a resized and padded version of the image, expanded to fill the\n    requested aspect ratio and size.\n\n    :param image: The image to resize and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :param color: The background color of the padded image.\n    :param centering: Control the position of the original image within the\n                      padded version.\n\n                          (0.5, 0.5) will keep the image centered\n                          (0, 0) will keep the image aligned to the top left\n                          (1, 1) will keep the image aligned to the bottom\n                          right\n    :return: An image.\n    \"\"\"\n\n    resized = contain(image, size, method)\n    if resized.size == size:\n        out = resized\n    else:\n        out = Image.new(image.mode, size, color)\n        if resized.palette:\n            out.putpalette(resized.getpalette())\n        if resized.width != size[0]:\n            x = round((size[0] - resized.width) * max(0, min(centering[0], 1)))\n            out.paste(resized, (x, 0))\n        else:\n            y = round((size[1] - resized.height) * max(0, min(centering[1], 1)))\n            out.paste(resized, (0, y))\n    return out\n\n\ndef crop(image: Image.Image, border: int = 0) -> Image.Image:\n    \"\"\"\n    Remove border from image.  The same amount of pixels are removed\n    from all four sides.  This function works on all image modes.\n\n    .. seealso:: :py:meth:`~PIL.Image.Image.crop`\n\n    :param image: The image to crop.\n    :param border: The number of pixels to remove.\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)\n    return image.crop((left, top, image.size[0] - right, image.size[1] - bottom))\n\n\ndef scale(\n    image: Image.Image, factor: float, resample: int = Image.Resampling.BICUBIC\n) -> Image.Image:\n    \"\"\"\n    Returns a rescaled image by a specific factor given in parameter.\n    A factor greater than 1 expands the image, between 0 and 1 contracts the\n    image.\n\n    :param image: The image to rescale.\n    :param factor: The expansion factor, as a float.\n    :param resample: Resampling method to use. Default is\n                     :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                     See :ref:`concept-filters`.\n    :returns: An :py:class:`~PIL.Image.Image` object.\n    \"\"\"\n    if factor == 1:\n        return image.copy()\n    elif factor <= 0:\n        msg = \"the factor must be greater than 0\"\n        raise ValueError(msg)\n    else:\n        size = (round(factor * image.width), round(factor * image.height))\n        return image.resize(size, resample)\n\n\nclass SupportsGetMesh(Protocol):\n    \"\"\"\n    An object that supports the ``getmesh`` method, taking an image as an\n    argument, and returning a list of tuples. Each tuple contains two tuples,\n    the source box as a tuple of 4 integers, and a tuple of 8 integers for the\n    final quadrilateral, in order of top left, bottom left, bottom right, top\n    right.\n    \"\"\"\n\n    def getmesh(\n        self, image: Image.Image\n    ) -> list[\n        tuple[tuple[int, int, int, int], tuple[int, int, int, int, int, int, int, int]]\n    ]: ...\n\n\ndef deform(\n    image: Image.Image,\n    deformer: SupportsGetMesh,\n    resample: int = Image.Resampling.BILINEAR,\n) -> Image.Image:\n    \"\"\"\n    Deform the image.\n\n    :param image: The image to deform.\n    :param deformer: A deformer object.  Any object that implements a\n                    ``getmesh`` method can be used.\n    :param resample: An optional resampling filter. Same values possible as\n       in the PIL.Image.transform function.\n    :return: An image.\n    \"\"\"\n    return image.transform(\n        image.size, Image.Transform.MESH, deformer.getmesh(image), resample\n    )\n\n\ndef equalize(image: Image.Image, mask: Image.Image | None = None) -> Image.Image:\n    \"\"\"\n    Equalize the image histogram. This function applies a non-linear\n    mapping to the input image, in order to create a uniform\n    distribution of grayscale values in the output image.\n\n    :param image: The image to equalize.\n    :param mask: An optional mask.  If given, only the pixels selected by\n                 the mask are included in the analysis.\n    :return: An image.\n    \"\"\"\n    if image.mode == \"P\":\n        image = image.convert(\"RGB\")\n    h = image.histogram(mask)\n    lut = []\n    for b in range(0, len(h), 256):\n        histo = [_f for _f in h[b : b + 256] if _f]\n        if len(histo) <= 1:\n            lut.extend(list(range(256)))\n        else:\n            step = (functools.reduce(operator.add, histo) - histo[-1]) // 255\n            if not step:\n                lut.extend(list(range(256)))\n            else:\n                n = step // 2\n                for i in range(256):\n                    lut.append(n // step)\n                    n = n + h[i + b]\n    return _lut(image, lut)\n\n\ndef expand(\n    image: Image.Image,\n    border: int | tuple[int, ...] = 0,\n    fill: str | int | tuple[int, ...] = 0,\n) -> Image.Image:\n    \"\"\"\n    Add border to the image\n\n    :param image: The image to expand.\n    :param border: Border width, in pixels.\n    :param fill: Pixel fill value (a color value).  Default is 0 (black).\n    :return: An image.\n    \"\"\"\n    left, top, right, bottom = _border(border)\n    width = left + image.size[0] + right\n    height = top + image.size[1] + bottom\n    color = _color(fill, image.mode)\n    if image.palette:\n        palette = ImagePalette.ImagePalette(palette=image.getpalette())\n        if isinstance(color, tuple) and (len(color) == 3 or len(color) == 4):\n            color = palette.getcolor(color)\n    else:\n        palette = None\n    out = Image.new(image.mode, (width, height), color)\n    if palette:\n        out.putpalette(palette.palette)\n    out.paste(image, (left, top))\n    return out\n\n\ndef fit(\n    image: Image.Image,\n    size: tuple[int, int],\n    method: int = Image.Resampling.BICUBIC,\n    bleed: float = 0.0,\n    centering: tuple[float, float] = (0.5, 0.5),\n) -> Image.Image:\n    \"\"\"\n    Returns a resized and cropped version of the image, cropped to the\n    requested aspect ratio and size.\n\n    This function was contributed by Kevin Cazabon.\n\n    :param image: The image to resize and crop.\n    :param size: The requested output size in pixels, given as a\n                 (width, height) tuple.\n    :param method: Resampling method to use. Default is\n                   :py:attr:`~PIL.Image.Resampling.BICUBIC`.\n                   See :ref:`concept-filters`.\n    :param bleed: Remove a border around the outside of the image from all\n                  four edges. The value is a decimal percentage (use 0.01 for\n                  one percent). The default value is 0 (no border).\n                  Cannot be greater than or equal to 0.5.\n    :param centering: Control the cropping position.  Use (0.5, 0.5) for\n                      center cropping (e.g. if cropping the width, take 50% off\n                      of the left side, and therefore 50% off the right side).\n                      (0.0, 0.0) will crop from the top left corner (i.e. if\n                      cropping the width, take all of the crop off of the right\n                      side, and if cropping the height, take all of it off the\n                      bottom).  (1.0, 0.0) will crop from the bottom left\n                      corner, etc. (i.e. if cropping the width, take all of the\n                      crop off the left side, and if cropping the height take\n                      none from the top, and therefore all off the bottom).\n    :return: An image.\n    \"\"\"\n\n    # by Kevin Cazabon, Feb 17/2000\n    # kevin@cazabon.com\n    # https://www.cazabon.com\n\n    centering_x, centering_y = centering\n\n    if not 0.0 <= centering_x <= 1.0:\n        centering_x = 0.5\n    if not 0.0 <= centering_y <= 1.0:\n        centering_y = 0.5\n\n    if not 0.0 <= bleed < 0.5:\n        bleed = 0.0\n\n    # calculate the area to use for resizing and cropping, subtracting\n    # the 'bleed' around the edges\n\n    # number of pixels to trim off on Top and Bottom, Left and Right\n    bleed_pixels = (bleed * image.size[0], bleed * image.size[1])\n\n    live_size = (\n        image.size[0] - bleed_pixels[0] * 2,\n        image.size[1] - bleed_pixels[1] * 2,\n    )\n\n    # calculate the aspect ratio of the live_size\n    live_size_ratio = live_size[0] / live_size[1]\n\n    # calculate the aspect ratio of the output image\n    output_ratio = size[0] / size[1]\n\n    # figure out if the sides or top/bottom will be cropped off\n    if live_size_ratio == output_ratio:\n        # live_size is already the needed ratio\n        crop_width = live_size[0]\n        crop_height = live_size[1]\n    elif live_size_ratio >= output_ratio:\n        # live_size is wider than what's needed, crop the sides\n        crop_width = output_ratio * live_size[1]\n        crop_height = live_size[1]\n    else:\n        # live_size is taller than what's needed, crop the top and bottom\n        crop_width = live_size[0]\n        crop_height = live_size[0] / output_ratio\n\n    # make the crop\n    crop_left = bleed_pixels[0] + (live_size[0] - crop_width) * centering_x\n    crop_top = bleed_pixels[1] + (live_size[1] - crop_height) * centering_y\n\n    crop = (crop_left, crop_top, crop_left + crop_width, crop_top + crop_height)\n\n    # resize the image and return it\n    return image.resize(size, method, box=crop)\n\n\ndef flip(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Flip the image vertically (top to bottom).\n\n    :param image: The image to flip.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.Transpose.FLIP_TOP_BOTTOM)\n\n\ndef grayscale(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Convert the image to grayscale.\n\n    :param image: The image to convert.\n    :return: An image.\n    \"\"\"\n    return image.convert(\"L\")\n\n\ndef invert(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Invert (negate) the image.\n\n    :param image: The image to invert.\n    :return: An image.\n    \"\"\"\n    lut = list(range(255, -1, -1))\n    return image.point(lut) if image.mode == \"1\" else _lut(image, lut)\n\n\ndef mirror(image: Image.Image) -> Image.Image:\n    \"\"\"\n    Flip image horizontally (left to right).\n\n    :param image: The image to mirror.\n    :return: An image.\n    \"\"\"\n    return image.transpose(Image.Transpose.FLIP_LEFT_RIGHT)\n\n\ndef posterize(image: Image.Image, bits: int) -> Image.Image:\n    \"\"\"\n    Reduce the number of bits for each color channel.\n\n    :param image: The image to posterize.\n    :param bits: The number of bits to keep for each channel (1-8).\n    :return: An image.\n    \"\"\"\n    mask = ~(2 ** (8 - bits) - 1)\n    lut = [i & mask for i in range(256)]\n    return _lut(image, lut)\n\n\ndef solarize(image: Image.Image, threshold: int = 128) -> Image.Image:\n    \"\"\"\n    Invert all pixel values above a threshold.\n\n    :param image: The image to solarize.\n    :param threshold: All pixels above this grayscale level are inverted.\n    :return: An image.\n    \"\"\"\n    lut = []\n    for i in range(256):\n        if i < threshold:\n            lut.append(i)\n        else:\n            lut.append(255 - i)\n    return _lut(image, lut)\n\n\ndef exif_transpose(image: Image.Image, *, in_place: bool = False) -> Image.Image | None:\n    \"\"\"\n    If an image has an EXIF Orientation tag, other than 1, transpose the image\n    accordingly, and remove the orientation data.\n\n    :param image: The image to transpose.\n    :param in_place: Boolean. Keyword-only argument.\n        If ``True``, the original image is modified in-place, and ``None`` is returned.\n        If ``False`` (default), a new :py:class:`~PIL.Image.Image` object is returned\n        with the transposition applied. If there is no transposition, a copy of the\n        image will be returned.\n    \"\"\"\n    image.load()\n    image_exif = image.getexif()\n    orientation = image_exif.get(ExifTags.Base.Orientation, 1)\n    method = {\n        2: Image.Transpose.FLIP_LEFT_RIGHT,\n        3: Image.Transpose.ROTATE_180,\n        4: Image.Transpose.FLIP_TOP_BOTTOM,\n        5: Image.Transpose.TRANSPOSE,\n        6: Image.Transpose.ROTATE_270,\n        7: Image.Transpose.TRANSVERSE,\n        8: Image.Transpose.ROTATE_90,\n    }.get(orientation)\n    if method is not None:\n        transposed_image = image.transpose(method)\n        if in_place:\n            image.im = transposed_image.im\n            image.pyaccess = None\n            image._size = transposed_image._size\n        exif_image = image if in_place else transposed_image\n\n        exif = exif_image.getexif()\n        if ExifTags.Base.Orientation in exif:\n            del exif[ExifTags.Base.Orientation]\n            if \"exif\" in exif_image.info:\n                exif_image.info[\"exif\"] = exif.tobytes()\n            elif \"Raw profile type exif\" in exif_image.info:\n                exif_image.info[\"Raw profile type exif\"] = exif.tobytes().hex()\n            elif \"XML:com.adobe.xmp\" in exif_image.info:\n                for pattern in (\n                    r'tiff:Orientation=\"([0-9])\"',\n                    r\"<tiff:Orientation>([0-9])</tiff:Orientation>\",\n                ):\n                    exif_image.info[\"XML:com.adobe.xmp\"] = re.sub(\n                        pattern, \"\", exif_image.info[\"XML:com.adobe.xmp\"]\n                    )\n                    exif_image.info[\"xmp\"] = re.sub(\n                        pattern.encode(), b\"\", exif_image.info[\"xmp\"]\n                    )\n        if not in_place:\n            return transposed_image\n    elif not in_place:\n        return image.copy()\n    return None\n", "src/PIL/__main__.py": "from __future__ import annotations\n\nimport sys\n\nfrom .features import pilinfo\n\npilinfo(supported_formats=\"--report\" not in sys.argv)\n", "src/PIL/_util.py": "from __future__ import annotations\n\nimport os\nfrom typing import Any, NoReturn\n\nfrom ._typing import StrOrBytesPath, TypeGuard\n\n\ndef is_path(f: Any) -> TypeGuard[StrOrBytesPath]:\n    return isinstance(f, (bytes, str, os.PathLike))\n\n\ndef is_directory(f: Any) -> TypeGuard[StrOrBytesPath]:\n    \"\"\"Checks if an object is a string, and that it points to a directory.\"\"\"\n    return is_path(f) and os.path.isdir(f)\n\n\nclass DeferredError:\n    def __init__(self, ex: BaseException):\n        self.ex = ex\n\n    def __getattr__(self, elt: str) -> NoReturn:\n        raise self.ex\n\n    @staticmethod\n    def new(ex: BaseException) -> Any:\n        \"\"\"\n        Creates an object that raises the wrapped exception ``ex`` when used,\n        and casts it to :py:obj:`~typing.Any` type.\n        \"\"\"\n        return DeferredError(ex)\n", "src/PIL/ImageColor.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# map CSS3-style colour description strings to RGB\n#\n# History:\n# 2002-10-24 fl   Added support for CSS-style color strings\n# 2002-12-15 fl   Added RGBA support\n# 2004-03-27 fl   Fixed remaining int() problems for Python 1.5.2\n# 2004-07-19 fl   Fixed gray/grey spelling issues\n# 2009-03-05 fl   Fixed rounding error in grayscale calculation\n#\n# Copyright (c) 2002-2004 by Secret Labs AB\n# Copyright (c) 2002-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport re\nfrom functools import lru_cache\n\nfrom . import Image\n\n\n@lru_cache\ndef getrgb(color: str) -> tuple[int, int, int] | tuple[int, int, int, int]:\n    \"\"\"\n     Convert a color string to an RGB or RGBA tuple. If the string cannot be\n     parsed, this function raises a :py:exc:`ValueError` exception.\n\n    .. versionadded:: 1.1.4\n\n    :param color: A color string\n    :return: ``(red, green, blue[, alpha])``\n    \"\"\"\n    if len(color) > 100:\n        msg = \"color specifier is too long\"\n        raise ValueError(msg)\n    color = color.lower()\n\n    rgb = colormap.get(color, None)\n    if rgb:\n        if isinstance(rgb, tuple):\n            return rgb\n        rgb_tuple = getrgb(rgb)\n        assert len(rgb_tuple) == 3\n        colormap[color] = rgb_tuple\n        return rgb_tuple\n\n    # check for known string formats\n    if re.match(\"#[a-f0-9]{3}$\", color):\n        return int(color[1] * 2, 16), int(color[2] * 2, 16), int(color[3] * 2, 16)\n\n    if re.match(\"#[a-f0-9]{4}$\", color):\n        return (\n            int(color[1] * 2, 16),\n            int(color[2] * 2, 16),\n            int(color[3] * 2, 16),\n            int(color[4] * 2, 16),\n        )\n\n    if re.match(\"#[a-f0-9]{6}$\", color):\n        return int(color[1:3], 16), int(color[3:5], 16), int(color[5:7], 16)\n\n    if re.match(\"#[a-f0-9]{8}$\", color):\n        return (\n            int(color[1:3], 16),\n            int(color[3:5], 16),\n            int(color[5:7], 16),\n            int(color[7:9], 16),\n        )\n\n    m = re.match(r\"rgb\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$\", color)\n    if m:\n        return int(m.group(1)), int(m.group(2)), int(m.group(3))\n\n    m = re.match(r\"rgb\\(\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*,\\s*(\\d+)%\\s*\\)$\", color)\n    if m:\n        return (\n            int((int(m.group(1)) * 255) / 100.0 + 0.5),\n            int((int(m.group(2)) * 255) / 100.0 + 0.5),\n            int((int(m.group(3)) * 255) / 100.0 + 0.5),\n        )\n\n    m = re.match(\n        r\"hsl\\(\\s*(\\d+\\.?\\d*)\\s*,\\s*(\\d+\\.?\\d*)%\\s*,\\s*(\\d+\\.?\\d*)%\\s*\\)$\", color\n    )\n    if m:\n        from colorsys import hls_to_rgb\n\n        rgb_floats = hls_to_rgb(\n            float(m.group(1)) / 360.0,\n            float(m.group(3)) / 100.0,\n            float(m.group(2)) / 100.0,\n        )\n        return (\n            int(rgb_floats[0] * 255 + 0.5),\n            int(rgb_floats[1] * 255 + 0.5),\n            int(rgb_floats[2] * 255 + 0.5),\n        )\n\n    m = re.match(\n        r\"hs[bv]\\(\\s*(\\d+\\.?\\d*)\\s*,\\s*(\\d+\\.?\\d*)%\\s*,\\s*(\\d+\\.?\\d*)%\\s*\\)$\", color\n    )\n    if m:\n        from colorsys import hsv_to_rgb\n\n        rgb_floats = hsv_to_rgb(\n            float(m.group(1)) / 360.0,\n            float(m.group(2)) / 100.0,\n            float(m.group(3)) / 100.0,\n        )\n        return (\n            int(rgb_floats[0] * 255 + 0.5),\n            int(rgb_floats[1] * 255 + 0.5),\n            int(rgb_floats[2] * 255 + 0.5),\n        )\n\n    m = re.match(r\"rgba\\(\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*,\\s*(\\d+)\\s*\\)$\", color)\n    if m:\n        return int(m.group(1)), int(m.group(2)), int(m.group(3)), int(m.group(4))\n    msg = f\"unknown color specifier: {repr(color)}\"\n    raise ValueError(msg)\n\n\n@lru_cache\ndef getcolor(color: str, mode: str) -> int | tuple[int, ...]:\n    \"\"\"\n    Same as :py:func:`~PIL.ImageColor.getrgb` for most modes. However, if\n    ``mode`` is HSV, converts the RGB value to a HSV value, or if ``mode`` is\n    not color or a palette image, converts the RGB value to a grayscale value.\n    If the string cannot be parsed, this function raises a :py:exc:`ValueError`\n    exception.\n\n    .. versionadded:: 1.1.4\n\n    :param color: A color string\n    :param mode: Convert result to this mode\n    :return: ``graylevel, (graylevel, alpha) or (red, green, blue[, alpha])``\n    \"\"\"\n    # same as getrgb, but converts the result to the given mode\n    rgb, alpha = getrgb(color), 255\n    if len(rgb) == 4:\n        alpha = rgb[3]\n        rgb = rgb[:3]\n\n    if mode == \"HSV\":\n        from colorsys import rgb_to_hsv\n\n        r, g, b = rgb\n        h, s, v = rgb_to_hsv(r / 255, g / 255, b / 255)\n        return int(h * 255), int(s * 255), int(v * 255)\n    elif Image.getmodebase(mode) == \"L\":\n        r, g, b = rgb\n        # ITU-R Recommendation 601-2 for nonlinear RGB\n        # scaled to 24 bits to match the convert's implementation.\n        graylevel = (r * 19595 + g * 38470 + b * 7471 + 0x8000) >> 16\n        if mode[-1] == \"A\":\n            return graylevel, alpha\n        return graylevel\n    elif mode[-1] == \"A\":\n        return rgb + (alpha,)\n    return rgb\n\n\ncolormap: dict[str, str | tuple[int, int, int]] = {\n    # X11 colour table from https://drafts.csswg.org/css-color-4/, with\n    # gray/grey spelling issues fixed.  This is a superset of HTML 4.0\n    # colour names used in CSS 1.\n    \"aliceblue\": \"#f0f8ff\",\n    \"antiquewhite\": \"#faebd7\",\n    \"aqua\": \"#00ffff\",\n    \"aquamarine\": \"#7fffd4\",\n    \"azure\": \"#f0ffff\",\n    \"beige\": \"#f5f5dc\",\n    \"bisque\": \"#ffe4c4\",\n    \"black\": \"#000000\",\n    \"blanchedalmond\": \"#ffebcd\",\n    \"blue\": \"#0000ff\",\n    \"blueviolet\": \"#8a2be2\",\n    \"brown\": \"#a52a2a\",\n    \"burlywood\": \"#deb887\",\n    \"cadetblue\": \"#5f9ea0\",\n    \"chartreuse\": \"#7fff00\",\n    \"chocolate\": \"#d2691e\",\n    \"coral\": \"#ff7f50\",\n    \"cornflowerblue\": \"#6495ed\",\n    \"cornsilk\": \"#fff8dc\",\n    \"crimson\": \"#dc143c\",\n    \"cyan\": \"#00ffff\",\n    \"darkblue\": \"#00008b\",\n    \"darkcyan\": \"#008b8b\",\n    \"darkgoldenrod\": \"#b8860b\",\n    \"darkgray\": \"#a9a9a9\",\n    \"darkgrey\": \"#a9a9a9\",\n    \"darkgreen\": \"#006400\",\n    \"darkkhaki\": \"#bdb76b\",\n    \"darkmagenta\": \"#8b008b\",\n    \"darkolivegreen\": \"#556b2f\",\n    \"darkorange\": \"#ff8c00\",\n    \"darkorchid\": \"#9932cc\",\n    \"darkred\": \"#8b0000\",\n    \"darksalmon\": \"#e9967a\",\n    \"darkseagreen\": \"#8fbc8f\",\n    \"darkslateblue\": \"#483d8b\",\n    \"darkslategray\": \"#2f4f4f\",\n    \"darkslategrey\": \"#2f4f4f\",\n    \"darkturquoise\": \"#00ced1\",\n    \"darkviolet\": \"#9400d3\",\n    \"deeppink\": \"#ff1493\",\n    \"deepskyblue\": \"#00bfff\",\n    \"dimgray\": \"#696969\",\n    \"dimgrey\": \"#696969\",\n    \"dodgerblue\": \"#1e90ff\",\n    \"firebrick\": \"#b22222\",\n    \"floralwhite\": \"#fffaf0\",\n    \"forestgreen\": \"#228b22\",\n    \"fuchsia\": \"#ff00ff\",\n    \"gainsboro\": \"#dcdcdc\",\n    \"ghostwhite\": \"#f8f8ff\",\n    \"gold\": \"#ffd700\",\n    \"goldenrod\": \"#daa520\",\n    \"gray\": \"#808080\",\n    \"grey\": \"#808080\",\n    \"green\": \"#008000\",\n    \"greenyellow\": \"#adff2f\",\n    \"honeydew\": \"#f0fff0\",\n    \"hotpink\": \"#ff69b4\",\n    \"indianred\": \"#cd5c5c\",\n    \"indigo\": \"#4b0082\",\n    \"ivory\": \"#fffff0\",\n    \"khaki\": \"#f0e68c\",\n    \"lavender\": \"#e6e6fa\",\n    \"lavenderblush\": \"#fff0f5\",\n    \"lawngreen\": \"#7cfc00\",\n    \"lemonchiffon\": \"#fffacd\",\n    \"lightblue\": \"#add8e6\",\n    \"lightcoral\": \"#f08080\",\n    \"lightcyan\": \"#e0ffff\",\n    \"lightgoldenrodyellow\": \"#fafad2\",\n    \"lightgreen\": \"#90ee90\",\n    \"lightgray\": \"#d3d3d3\",\n    \"lightgrey\": \"#d3d3d3\",\n    \"lightpink\": \"#ffb6c1\",\n    \"lightsalmon\": \"#ffa07a\",\n    \"lightseagreen\": \"#20b2aa\",\n    \"lightskyblue\": \"#87cefa\",\n    \"lightslategray\": \"#778899\",\n    \"lightslategrey\": \"#778899\",\n    \"lightsteelblue\": \"#b0c4de\",\n    \"lightyellow\": \"#ffffe0\",\n    \"lime\": \"#00ff00\",\n    \"limegreen\": \"#32cd32\",\n    \"linen\": \"#faf0e6\",\n    \"magenta\": \"#ff00ff\",\n    \"maroon\": \"#800000\",\n    \"mediumaquamarine\": \"#66cdaa\",\n    \"mediumblue\": \"#0000cd\",\n    \"mediumorchid\": \"#ba55d3\",\n    \"mediumpurple\": \"#9370db\",\n    \"mediumseagreen\": \"#3cb371\",\n    \"mediumslateblue\": \"#7b68ee\",\n    \"mediumspringgreen\": \"#00fa9a\",\n    \"mediumturquoise\": \"#48d1cc\",\n    \"mediumvioletred\": \"#c71585\",\n    \"midnightblue\": \"#191970\",\n    \"mintcream\": \"#f5fffa\",\n    \"mistyrose\": \"#ffe4e1\",\n    \"moccasin\": \"#ffe4b5\",\n    \"navajowhite\": \"#ffdead\",\n    \"navy\": \"#000080\",\n    \"oldlace\": \"#fdf5e6\",\n    \"olive\": \"#808000\",\n    \"olivedrab\": \"#6b8e23\",\n    \"orange\": \"#ffa500\",\n    \"orangered\": \"#ff4500\",\n    \"orchid\": \"#da70d6\",\n    \"palegoldenrod\": \"#eee8aa\",\n    \"palegreen\": \"#98fb98\",\n    \"paleturquoise\": \"#afeeee\",\n    \"palevioletred\": \"#db7093\",\n    \"papayawhip\": \"#ffefd5\",\n    \"peachpuff\": \"#ffdab9\",\n    \"peru\": \"#cd853f\",\n    \"pink\": \"#ffc0cb\",\n    \"plum\": \"#dda0dd\",\n    \"powderblue\": \"#b0e0e6\",\n    \"purple\": \"#800080\",\n    \"rebeccapurple\": \"#663399\",\n    \"red\": \"#ff0000\",\n    \"rosybrown\": \"#bc8f8f\",\n    \"royalblue\": \"#4169e1\",\n    \"saddlebrown\": \"#8b4513\",\n    \"salmon\": \"#fa8072\",\n    \"sandybrown\": \"#f4a460\",\n    \"seagreen\": \"#2e8b57\",\n    \"seashell\": \"#fff5ee\",\n    \"sienna\": \"#a0522d\",\n    \"silver\": \"#c0c0c0\",\n    \"skyblue\": \"#87ceeb\",\n    \"slateblue\": \"#6a5acd\",\n    \"slategray\": \"#708090\",\n    \"slategrey\": \"#708090\",\n    \"snow\": \"#fffafa\",\n    \"springgreen\": \"#00ff7f\",\n    \"steelblue\": \"#4682b4\",\n    \"tan\": \"#d2b48c\",\n    \"teal\": \"#008080\",\n    \"thistle\": \"#d8bfd8\",\n    \"tomato\": \"#ff6347\",\n    \"turquoise\": \"#40e0d0\",\n    \"violet\": \"#ee82ee\",\n    \"wheat\": \"#f5deb3\",\n    \"white\": \"#ffffff\",\n    \"whitesmoke\": \"#f5f5f5\",\n    \"yellow\": \"#ffff00\",\n    \"yellowgreen\": \"#9acd32\",\n}\n", "src/PIL/ImageEnhance.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# image enhancement classes\n#\n# For a background, see \"Image Processing By Interpolation and\n# Extrapolation\", Paul Haeberli and Douglas Voorhies.  Available\n# at http://www.graficaobscura.com/interp/index.html\n#\n# History:\n# 1996-03-23 fl  Created\n# 2009-06-16 fl  Fixed mean calculation\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom . import Image, ImageFilter, ImageStat\n\n\nclass _Enhance:\n    image: Image.Image\n    degenerate: Image.Image\n\n    def enhance(self, factor: float) -> Image.Image:\n        \"\"\"\n        Returns an enhanced image.\n\n        :param factor: A floating point value controlling the enhancement.\n                       Factor 1.0 always returns a copy of the original image,\n                       lower factors mean less color (brightness, contrast,\n                       etc), and higher values more. There are no restrictions\n                       on this value.\n        :rtype: :py:class:`~PIL.Image.Image`\n        \"\"\"\n        return Image.blend(self.degenerate, self.image, factor)\n\n\nclass Color(_Enhance):\n    \"\"\"Adjust image color balance.\n\n    This class can be used to adjust the colour balance of an image, in\n    a manner similar to the controls on a colour TV set. An enhancement\n    factor of 0.0 gives a black and white image. A factor of 1.0 gives\n    the original image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        self.intermediate_mode = \"L\"\n        if \"A\" in image.getbands():\n            self.intermediate_mode = \"LA\"\n\n        self.degenerate = image.convert(self.intermediate_mode).convert(image.mode)\n\n\nclass Contrast(_Enhance):\n    \"\"\"Adjust image contrast.\n\n    This class can be used to control the contrast of an image, similar\n    to the contrast control on a TV set. An enhancement factor of 0.0\n    gives a solid gray image. A factor of 1.0 gives the original image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        mean = int(ImageStat.Stat(image.convert(\"L\")).mean[0] + 0.5)\n        self.degenerate = Image.new(\"L\", image.size, mean).convert(image.mode)\n\n        if \"A\" in image.getbands():\n            self.degenerate.putalpha(image.getchannel(\"A\"))\n\n\nclass Brightness(_Enhance):\n    \"\"\"Adjust image brightness.\n\n    This class can be used to control the brightness of an image.  An\n    enhancement factor of 0.0 gives a black image. A factor of 1.0 gives the\n    original image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        self.degenerate = Image.new(image.mode, image.size, 0)\n\n        if \"A\" in image.getbands():\n            self.degenerate.putalpha(image.getchannel(\"A\"))\n\n\nclass Sharpness(_Enhance):\n    \"\"\"Adjust image sharpness.\n\n    This class can be used to adjust the sharpness of an image. An\n    enhancement factor of 0.0 gives a blurred image, a factor of 1.0 gives the\n    original image, and a factor of 2.0 gives a sharpened image.\n    \"\"\"\n\n    def __init__(self, image: Image.Image) -> None:\n        self.image = image\n        self.degenerate = image.filter(ImageFilter.SMOOTH)\n\n        if \"A\" in image.getbands():\n            self.degenerate.putalpha(image.getchannel(\"A\"))\n", "src/PIL/PaletteFile.py": "#\n# Python Imaging Library\n# $Id$\n#\n# stuff to read simple, teragon-style palette files\n#\n# History:\n#       97-08-23 fl     Created\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1997.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom ._binary import o8\n\n\nclass PaletteFile:\n    \"\"\"File handler for Teragon-style palette files.\"\"\"\n\n    rawmode = \"RGB\"\n\n    def __init__(self, fp: IO[bytes]) -> None:\n        palette = [o8(i) * 3 for i in range(256)]\n\n        while True:\n            s = fp.readline()\n\n            if not s:\n                break\n            if s[:1] == b\"#\":\n                continue\n            if len(s) > 100:\n                msg = \"bad palette file\"\n                raise SyntaxError(msg)\n\n            v = [int(x) for x in s.split()]\n            try:\n                [i, r, g, b] = v\n            except ValueError:\n                [i, r] = v\n                g = b = r\n\n            if 0 <= i <= 255:\n                palette[i] = o8(r) + o8(g) + o8(b)\n\n        self.palette = b\"\".join(palette)\n\n    def getpalette(self) -> tuple[bytes, str]:\n        return self.palette, self.rawmode\n", "src/PIL/Jpeg2KImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# JPEG2000 file handling\n#\n# History:\n# 2014-03-12 ajh  Created\n# 2021-06-30 rogermb  Extract dpi information from the 'resc' header box\n#\n# Copyright (c) 2014 Coriolis Systems Limited\n# Copyright (c) 2014 Alastair Houghton\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport io\nimport os\nimport struct\nfrom typing import IO, Tuple, cast\n\nfrom . import Image, ImageFile, ImagePalette, _binary\n\n\nclass BoxReader:\n    \"\"\"\n    A small helper class to read fields stored in JPEG2000 header boxes\n    and to easily step into and read sub-boxes.\n    \"\"\"\n\n    def __init__(self, fp, length=-1):\n        self.fp = fp\n        self.has_length = length >= 0\n        self.length = length\n        self.remaining_in_box = -1\n\n    def _can_read(self, num_bytes: int) -> bool:\n        if self.has_length and self.fp.tell() + num_bytes > self.length:\n            # Outside box: ensure we don't read past the known file length\n            return False\n        if self.remaining_in_box >= 0:\n            # Inside box contents: ensure read does not go past box boundaries\n            return num_bytes <= self.remaining_in_box\n        else:\n            return True  # No length known, just read\n\n    def _read_bytes(self, num_bytes: int) -> bytes:\n        if not self._can_read(num_bytes):\n            msg = \"Not enough data in header\"\n            raise SyntaxError(msg)\n\n        data = self.fp.read(num_bytes)\n        if len(data) < num_bytes:\n            msg = f\"Expected to read {num_bytes} bytes but only got {len(data)}.\"\n            raise OSError(msg)\n\n        if self.remaining_in_box > 0:\n            self.remaining_in_box -= num_bytes\n        return data\n\n    def read_fields(self, field_format: str) -> tuple[int | bytes, ...]:\n        size = struct.calcsize(field_format)\n        data = self._read_bytes(size)\n        return struct.unpack(field_format, data)\n\n    def read_boxes(self) -> BoxReader:\n        size = self.remaining_in_box\n        data = self._read_bytes(size)\n        return BoxReader(io.BytesIO(data), size)\n\n    def has_next_box(self) -> bool:\n        if self.has_length:\n            return self.fp.tell() + self.remaining_in_box < self.length\n        else:\n            return True\n\n    def next_box_type(self) -> bytes:\n        # Skip the rest of the box if it has not been read\n        if self.remaining_in_box > 0:\n            self.fp.seek(self.remaining_in_box, os.SEEK_CUR)\n        self.remaining_in_box = -1\n\n        # Read the length and type of the next box\n        lbox, tbox = cast(Tuple[int, bytes], self.read_fields(\">I4s\"))\n        if lbox == 1:\n            lbox = cast(int, self.read_fields(\">Q\")[0])\n            hlen = 16\n        else:\n            hlen = 8\n\n        if lbox < hlen or not self._can_read(lbox - hlen):\n            msg = \"Invalid header length\"\n            raise SyntaxError(msg)\n\n        self.remaining_in_box = lbox - hlen\n        return tbox\n\n\ndef _parse_codestream(fp):\n    \"\"\"Parse the JPEG 2000 codestream to extract the size and component\n    count from the SIZ marker segment, returning a PIL (size, mode) tuple.\"\"\"\n\n    hdr = fp.read(2)\n    lsiz = _binary.i16be(hdr)\n    siz = hdr + fp.read(lsiz - 2)\n    lsiz, rsiz, xsiz, ysiz, xosiz, yosiz, _, _, _, _, csiz = struct.unpack_from(\n        \">HHIIIIIIIIH\", siz\n    )\n\n    size = (xsiz - xosiz, ysiz - yosiz)\n    if csiz == 1:\n        ssiz = struct.unpack_from(\">B\", siz, 38)\n        if (ssiz[0] & 0x7F) + 1 > 8:\n            mode = \"I;16\"\n        else:\n            mode = \"L\"\n    elif csiz == 2:\n        mode = \"LA\"\n    elif csiz == 3:\n        mode = \"RGB\"\n    elif csiz == 4:\n        mode = \"RGBA\"\n    else:\n        mode = \"\"\n\n    return size, mode\n\n\ndef _res_to_dpi(num: int, denom: int, exp: int) -> float | None:\n    \"\"\"Convert JPEG2000's (numerator, denominator, exponent-base-10) resolution,\n    calculated as (num / denom) * 10^exp and stored in dots per meter,\n    to floating-point dots per inch.\"\"\"\n    if denom == 0:\n        return None\n    return (254 * num * (10**exp)) / (10000 * denom)\n\n\ndef _parse_jp2_header(fp):\n    \"\"\"Parse the JP2 header box to extract size, component count,\n    color space information, and optionally DPI information,\n    returning a (size, mode, mimetype, dpi) tuple.\"\"\"\n\n    # Find the JP2 header box\n    reader = BoxReader(fp)\n    header = None\n    mimetype = None\n    while reader.has_next_box():\n        tbox = reader.next_box_type()\n\n        if tbox == b\"jp2h\":\n            header = reader.read_boxes()\n            break\n        elif tbox == b\"ftyp\":\n            if reader.read_fields(\">4s\")[0] == b\"jpx \":\n                mimetype = \"image/jpx\"\n\n    size = None\n    mode = None\n    bpc = None\n    nc = None\n    dpi = None  # 2-tuple of DPI info, or None\n    palette = None\n\n    while header.has_next_box():\n        tbox = header.next_box_type()\n\n        if tbox == b\"ihdr\":\n            height, width, nc, bpc = header.read_fields(\">IIHB\")\n            size = (width, height)\n            if nc == 1 and (bpc & 0x7F) > 8:\n                mode = \"I;16\"\n            elif nc == 1:\n                mode = \"L\"\n            elif nc == 2:\n                mode = \"LA\"\n            elif nc == 3:\n                mode = \"RGB\"\n            elif nc == 4:\n                mode = \"RGBA\"\n        elif tbox == b\"colr\" and nc == 4:\n            meth, _, _, enumcs = header.read_fields(\">BBBI\")\n            if meth == 1 and enumcs == 12:\n                mode = \"CMYK\"\n        elif tbox == b\"pclr\" and mode in (\"L\", \"LA\"):\n            ne, npc = header.read_fields(\">HB\")\n            bitdepths = header.read_fields(\">\" + (\"B\" * npc))\n            if max(bitdepths) <= 8:\n                palette = ImagePalette.ImagePalette()\n                for i in range(ne):\n                    palette.getcolor(header.read_fields(\">\" + (\"B\" * npc)))\n                mode = \"P\" if mode == \"L\" else \"PA\"\n        elif tbox == b\"res \":\n            res = header.read_boxes()\n            while res.has_next_box():\n                tres = res.next_box_type()\n                if tres == b\"resc\":\n                    vrcn, vrcd, hrcn, hrcd, vrce, hrce = res.read_fields(\">HHHHBB\")\n                    hres = _res_to_dpi(hrcn, hrcd, hrce)\n                    vres = _res_to_dpi(vrcn, vrcd, vrce)\n                    if hres is not None and vres is not None:\n                        dpi = (hres, vres)\n                    break\n\n    if size is None or mode is None:\n        msg = \"Malformed JP2 header\"\n        raise SyntaxError(msg)\n\n    return size, mode, mimetype, dpi, palette\n\n\n##\n# Image plugin for JPEG2000 images.\n\n\nclass Jpeg2KImageFile(ImageFile.ImageFile):\n    format = \"JPEG2000\"\n    format_description = \"JPEG 2000 (ISO 15444)\"\n\n    def _open(self) -> None:\n        sig = self.fp.read(4)\n        if sig == b\"\\xff\\x4f\\xff\\x51\":\n            self.codec = \"j2k\"\n            self._size, self._mode = _parse_codestream(self.fp)\n        else:\n            sig = sig + self.fp.read(8)\n\n            if sig == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\":\n                self.codec = \"jp2\"\n                header = _parse_jp2_header(self.fp)\n                self._size, self._mode, self.custom_mimetype, dpi, self.palette = header\n                if dpi is not None:\n                    self.info[\"dpi\"] = dpi\n                if self.fp.read(12).endswith(b\"jp2c\\xff\\x4f\\xff\\x51\"):\n                    self._parse_comment()\n            else:\n                msg = \"not a JPEG 2000 file\"\n                raise SyntaxError(msg)\n\n        if self.size is None or not self.mode:\n            msg = \"unable to determine size/mode\"\n            raise SyntaxError(msg)\n\n        self._reduce = 0\n        self.layers = 0\n\n        fd = -1\n        length = -1\n\n        try:\n            fd = self.fp.fileno()\n            length = os.fstat(fd).st_size\n        except Exception:\n            fd = -1\n            try:\n                pos = self.fp.tell()\n                self.fp.seek(0, io.SEEK_END)\n                length = self.fp.tell()\n                self.fp.seek(pos)\n            except Exception:\n                length = -1\n\n        self.tile = [\n            (\n                \"jpeg2k\",\n                (0, 0) + self.size,\n                0,\n                (self.codec, self._reduce, self.layers, fd, length),\n            )\n        ]\n\n    def _parse_comment(self) -> None:\n        hdr = self.fp.read(2)\n        length = _binary.i16be(hdr)\n        self.fp.seek(length - 2, os.SEEK_CUR)\n\n        while True:\n            marker = self.fp.read(2)\n            if not marker:\n                break\n            typ = marker[1]\n            if typ in (0x90, 0xD9):\n                # Start of tile or end of codestream\n                break\n            hdr = self.fp.read(2)\n            length = _binary.i16be(hdr)\n            if typ == 0x64:\n                # Comment\n                self.info[\"comment\"] = self.fp.read(length - 2)[2:]\n                break\n            else:\n                self.fp.seek(length - 2, os.SEEK_CUR)\n\n    @property\n    def reduce(self):\n        # https://github.com/python-pillow/Pillow/issues/4343 found that the\n        # new Image 'reduce' method was shadowed by this plugin's 'reduce'\n        # property. This attempts to allow for both scenarios\n        return self._reduce or super().reduce\n\n    @reduce.setter\n    def reduce(self, value):\n        self._reduce = value\n\n    def load(self):\n        if self.tile and self._reduce:\n            power = 1 << self._reduce\n            adjust = power >> 1\n            self._size = (\n                int((self.size[0] + adjust) / power),\n                int((self.size[1] + adjust) / power),\n            )\n\n            # Update the reduce and layers settings\n            t = self.tile[0]\n            t3 = (t[3][0], self._reduce, self.layers, t[3][3], t[3][4])\n            self.tile = [(t[0], (0, 0) + self.size, t[2], t3)]\n\n        return ImageFile.ImageFile.load(self)\n\n\ndef _accept(prefix: bytes) -> bool:\n    return (\n        prefix[:4] == b\"\\xff\\x4f\\xff\\x51\"\n        or prefix[:12] == b\"\\x00\\x00\\x00\\x0cjP  \\x0d\\x0a\\x87\\x0a\"\n    )\n\n\n# ------------------------------------------------------------\n# Save support\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # Get the keyword arguments\n    info = im.encoderinfo\n\n    if isinstance(filename, str):\n        filename = filename.encode()\n    if filename.endswith(b\".j2k\") or info.get(\"no_jp2\", False):\n        kind = \"j2k\"\n    else:\n        kind = \"jp2\"\n\n    offset = info.get(\"offset\", None)\n    tile_offset = info.get(\"tile_offset\", None)\n    tile_size = info.get(\"tile_size\", None)\n    quality_mode = info.get(\"quality_mode\", \"rates\")\n    quality_layers = info.get(\"quality_layers\", None)\n    if quality_layers is not None and not (\n        isinstance(quality_layers, (list, tuple))\n        and all(\n            isinstance(quality_layer, (int, float)) for quality_layer in quality_layers\n        )\n    ):\n        msg = \"quality_layers must be a sequence of numbers\"\n        raise ValueError(msg)\n\n    num_resolutions = info.get(\"num_resolutions\", 0)\n    cblk_size = info.get(\"codeblock_size\", None)\n    precinct_size = info.get(\"precinct_size\", None)\n    irreversible = info.get(\"irreversible\", False)\n    progression = info.get(\"progression\", \"LRCP\")\n    cinema_mode = info.get(\"cinema_mode\", \"no\")\n    mct = info.get(\"mct\", 0)\n    signed = info.get(\"signed\", False)\n    comment = info.get(\"comment\")\n    if isinstance(comment, str):\n        comment = comment.encode()\n    plt = info.get(\"plt\", False)\n\n    fd = -1\n    if hasattr(fp, \"fileno\"):\n        try:\n            fd = fp.fileno()\n        except Exception:\n            fd = -1\n\n    im.encoderconfig = (\n        offset,\n        tile_offset,\n        tile_size,\n        quality_mode,\n        quality_layers,\n        num_resolutions,\n        cblk_size,\n        precinct_size,\n        irreversible,\n        progression,\n        cinema_mode,\n        mct,\n        signed,\n        fd,\n        comment,\n        plt,\n    )\n\n    ImageFile._save(im, fp, [(\"jpeg2k\", (0, 0) + im.size, 0, kind)])\n\n\n# ------------------------------------------------------------\n# Registry stuff\n\n\nImage.register_open(Jpeg2KImageFile.format, Jpeg2KImageFile, _accept)\nImage.register_save(Jpeg2KImageFile.format, _save)\n\nImage.register_extensions(\n    Jpeg2KImageFile.format, [\".jp2\", \".j2k\", \".jpc\", \".jpf\", \".jpx\", \".j2c\"]\n)\n\nImage.register_mime(Jpeg2KImageFile.format, \"image/jp2\")\n", "src/PIL/_typing.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom typing import Any, Protocol, Sequence, TypeVar, Union\n\ntry:\n    import numpy.typing as npt\n\n    NumpyArray = npt.NDArray[Any]\nexcept ImportError:\n    pass\n\nif sys.version_info >= (3, 10):\n    from typing import TypeGuard\nelse:\n    try:\n        from typing_extensions import TypeGuard\n    except ImportError:\n\n        class TypeGuard:  # type: ignore[no-redef]\n            def __class_getitem__(cls, item: Any) -> type[bool]:\n                return bool\n\n\nCoords = Union[Sequence[float], Sequence[Sequence[float]]]\n\n\n_T_co = TypeVar(\"_T_co\", covariant=True)\n\n\nclass SupportsRead(Protocol[_T_co]):\n    def read(self, __length: int = ...) -> _T_co: ...\n\n\nStrOrBytesPath = Union[str, bytes, \"os.PathLike[str]\", \"os.PathLike[bytes]\"]\n\n\n__all__ = [\"TypeGuard\", \"StrOrBytesPath\", \"SupportsRead\"]\n", "src/PIL/ImageMode.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# standard mode descriptors\n#\n# History:\n# 2006-03-20 fl   Added\n#\n# Copyright (c) 2006 by Secret Labs AB.\n# Copyright (c) 2006 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport sys\nfrom functools import lru_cache\nfrom typing import NamedTuple\n\nfrom ._deprecate import deprecate\n\n\nclass ModeDescriptor(NamedTuple):\n    \"\"\"Wrapper for mode strings.\"\"\"\n\n    mode: str\n    bands: tuple[str, ...]\n    basemode: str\n    basetype: str\n    typestr: str\n\n    def __str__(self) -> str:\n        return self.mode\n\n\n@lru_cache\ndef getmode(mode: str) -> ModeDescriptor:\n    \"\"\"Gets a mode descriptor for the given mode.\"\"\"\n    endian = \"<\" if sys.byteorder == \"little\" else \">\"\n\n    modes = {\n        # core modes\n        # Bits need to be extended to bytes\n        \"1\": (\"L\", \"L\", (\"1\",), \"|b1\"),\n        \"L\": (\"L\", \"L\", (\"L\",), \"|u1\"),\n        \"I\": (\"L\", \"I\", (\"I\",), f\"{endian}i4\"),\n        \"F\": (\"L\", \"F\", (\"F\",), f\"{endian}f4\"),\n        \"P\": (\"P\", \"L\", (\"P\",), \"|u1\"),\n        \"RGB\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\"), \"|u1\"),\n        \"RGBX\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"X\"), \"|u1\"),\n        \"RGBA\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"A\"), \"|u1\"),\n        \"CMYK\": (\"RGB\", \"L\", (\"C\", \"M\", \"Y\", \"K\"), \"|u1\"),\n        \"YCbCr\": (\"RGB\", \"L\", (\"Y\", \"Cb\", \"Cr\"), \"|u1\"),\n        # UNDONE - unsigned |u1i1i1\n        \"LAB\": (\"RGB\", \"L\", (\"L\", \"A\", \"B\"), \"|u1\"),\n        \"HSV\": (\"RGB\", \"L\", (\"H\", \"S\", \"V\"), \"|u1\"),\n        # extra experimental modes\n        \"RGBa\": (\"RGB\", \"L\", (\"R\", \"G\", \"B\", \"a\"), \"|u1\"),\n        \"BGR;15\": (\"RGB\", \"L\", (\"B\", \"G\", \"R\"), \"|u1\"),\n        \"BGR;16\": (\"RGB\", \"L\", (\"B\", \"G\", \"R\"), \"|u1\"),\n        \"BGR;24\": (\"RGB\", \"L\", (\"B\", \"G\", \"R\"), \"|u1\"),\n        \"LA\": (\"L\", \"L\", (\"L\", \"A\"), \"|u1\"),\n        \"La\": (\"L\", \"L\", (\"L\", \"a\"), \"|u1\"),\n        \"PA\": (\"RGB\", \"L\", (\"P\", \"A\"), \"|u1\"),\n    }\n    if mode in modes:\n        if mode in (\"BGR;15\", \"BGR;16\", \"BGR;24\"):\n            deprecate(mode, 12)\n        base_mode, base_type, bands, type_str = modes[mode]\n        return ModeDescriptor(mode, bands, base_mode, base_type, type_str)\n\n    mapping_modes = {\n        # I;16 == I;16L, and I;32 == I;32L\n        \"I;16\": \"<u2\",\n        \"I;16S\": \"<i2\",\n        \"I;16L\": \"<u2\",\n        \"I;16LS\": \"<i2\",\n        \"I;16B\": \">u2\",\n        \"I;16BS\": \">i2\",\n        \"I;16N\": f\"{endian}u2\",\n        \"I;16NS\": f\"{endian}i2\",\n        \"I;32\": \"<u4\",\n        \"I;32B\": \">u4\",\n        \"I;32L\": \"<u4\",\n        \"I;32S\": \"<i4\",\n        \"I;32BS\": \">i4\",\n        \"I;32LS\": \"<i4\",\n    }\n\n    type_str = mapping_modes[mode]\n    return ModeDescriptor(mode, (\"I\",), \"L\", \"L\", type_str)\n", "src/PIL/Hdf5StubImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# HDF5 stub adapter\n#\n# Copyright (c) 2000-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific HDF5 image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\n# --------------------------------------------------------------------\n# Image adapter\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == b\"\\x89HDF\\r\\n\\x1a\\n\"\n\n\nclass HDF5StubImageFile(ImageFile.StubImageFile):\n    format = \"HDF5\"\n    format_description = \"HDF5\"\n\n    def _open(self) -> None:\n        offset = self.fp.tell()\n\n        if not _accept(self.fp.read(8)):\n            msg = \"Not an HDF file\"\n            raise SyntaxError(msg)\n\n        self.fp.seek(offset)\n\n        # make something up\n        self._mode = \"F\"\n        self._size = 1, 1\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"HDF5 save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(HDF5StubImageFile.format, HDF5StubImageFile, _accept)\nImage.register_save(HDF5StubImageFile.format, _save)\n\nImage.register_extensions(HDF5StubImageFile.format, [\".h5\", \".hdf\"])\n", "src/PIL/__init__.py": "\"\"\"Pillow (Fork of the Python Imaging Library)\n\nPillow is the friendly PIL fork by Jeffrey A. Clark and contributors.\n    https://github.com/python-pillow/Pillow/\n\nPillow is forked from PIL 1.1.7.\n\nPIL is the Python Imaging Library by Fredrik Lundh and contributors.\nCopyright (c) 1999 by Secret Labs AB.\n\nUse PIL.__version__ for this Pillow version.\n\n;-)\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom . import _version\n\n# VERSION was removed in Pillow 6.0.0.\n# PILLOW_VERSION was removed in Pillow 9.0.0.\n# Use __version__ instead.\n__version__ = _version.__version__\ndel _version\n\n\n_plugins = [\n    \"BlpImagePlugin\",\n    \"BmpImagePlugin\",\n    \"BufrStubImagePlugin\",\n    \"CurImagePlugin\",\n    \"DcxImagePlugin\",\n    \"DdsImagePlugin\",\n    \"EpsImagePlugin\",\n    \"FitsImagePlugin\",\n    \"FliImagePlugin\",\n    \"FpxImagePlugin\",\n    \"FtexImagePlugin\",\n    \"GbrImagePlugin\",\n    \"GifImagePlugin\",\n    \"GribStubImagePlugin\",\n    \"Hdf5StubImagePlugin\",\n    \"IcnsImagePlugin\",\n    \"IcoImagePlugin\",\n    \"ImImagePlugin\",\n    \"ImtImagePlugin\",\n    \"IptcImagePlugin\",\n    \"JpegImagePlugin\",\n    \"Jpeg2KImagePlugin\",\n    \"McIdasImagePlugin\",\n    \"MicImagePlugin\",\n    \"MpegImagePlugin\",\n    \"MpoImagePlugin\",\n    \"MspImagePlugin\",\n    \"PalmImagePlugin\",\n    \"PcdImagePlugin\",\n    \"PcxImagePlugin\",\n    \"PdfImagePlugin\",\n    \"PixarImagePlugin\",\n    \"PngImagePlugin\",\n    \"PpmImagePlugin\",\n    \"PsdImagePlugin\",\n    \"QoiImagePlugin\",\n    \"SgiImagePlugin\",\n    \"SpiderImagePlugin\",\n    \"SunImagePlugin\",\n    \"TgaImagePlugin\",\n    \"TiffImagePlugin\",\n    \"WebPImagePlugin\",\n    \"WmfImagePlugin\",\n    \"XbmImagePlugin\",\n    \"XpmImagePlugin\",\n    \"XVThumbImagePlugin\",\n]\n\n\nclass UnidentifiedImageError(OSError):\n    \"\"\"\n    Raised in :py:meth:`PIL.Image.open` if an image cannot be opened and identified.\n\n    If a PNG image raises this error, setting :data:`.ImageFile.LOAD_TRUNCATED_IMAGES`\n    to true may allow the image to be opened after all. The setting will ignore missing\n    data and checksum failures.\n    \"\"\"\n\n    pass\n", "src/PIL/ImImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# IFUNC IM file handling for PIL\n#\n# history:\n# 1995-09-01 fl   Created.\n# 1997-01-03 fl   Save palette images\n# 1997-01-08 fl   Added sequence support\n# 1997-01-23 fl   Added P and RGB save support\n# 1997-05-31 fl   Read floating point images\n# 1997-06-22 fl   Save floating point images\n# 1997-08-27 fl   Read and save 1-bit images\n# 1998-06-25 fl   Added support for RGB+LUT images\n# 1998-07-02 fl   Added support for YCC images\n# 1998-07-15 fl   Renamed offset attribute to avoid name clash\n# 1998-12-29 fl   Added I;16 support\n# 2001-02-17 fl   Use 're' instead of 'regex' (Python 2.1) (0.7)\n# 2003-09-26 fl   Added LA/PA support\n#\n# Copyright (c) 1997-2003 by Secret Labs AB.\n# Copyright (c) 1995-2001 by Fredrik Lundh.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nimport re\nfrom typing import IO, Any\n\nfrom . import Image, ImageFile, ImagePalette\n\n# --------------------------------------------------------------------\n# Standard tags\n\nCOMMENT = \"Comment\"\nDATE = \"Date\"\nEQUIPMENT = \"Digitalization equipment\"\nFRAMES = \"File size (no of images)\"\nLUT = \"Lut\"\nNAME = \"Name\"\nSCALE = \"Scale (x,y)\"\nSIZE = \"Image size (x*y)\"\nMODE = \"Image type\"\n\nTAGS = {\n    COMMENT: 0,\n    DATE: 0,\n    EQUIPMENT: 0,\n    FRAMES: 0,\n    LUT: 0,\n    NAME: 0,\n    SCALE: 0,\n    SIZE: 0,\n    MODE: 0,\n}\n\nOPEN = {\n    # ifunc93/p3cfunc formats\n    \"0 1 image\": (\"1\", \"1\"),\n    \"L 1 image\": (\"1\", \"1\"),\n    \"Greyscale image\": (\"L\", \"L\"),\n    \"Grayscale image\": (\"L\", \"L\"),\n    \"RGB image\": (\"RGB\", \"RGB;L\"),\n    \"RLB image\": (\"RGB\", \"RLB\"),\n    \"RYB image\": (\"RGB\", \"RLB\"),\n    \"B1 image\": (\"1\", \"1\"),\n    \"B2 image\": (\"P\", \"P;2\"),\n    \"B4 image\": (\"P\", \"P;4\"),\n    \"X 24 image\": (\"RGB\", \"RGB\"),\n    \"L 32 S image\": (\"I\", \"I;32\"),\n    \"L 32 F image\": (\"F\", \"F;32\"),\n    # old p3cfunc formats\n    \"RGB3 image\": (\"RGB\", \"RGB;T\"),\n    \"RYB3 image\": (\"RGB\", \"RYB;T\"),\n    # extensions\n    \"LA image\": (\"LA\", \"LA;L\"),\n    \"PA image\": (\"LA\", \"PA;L\"),\n    \"RGBA image\": (\"RGBA\", \"RGBA;L\"),\n    \"RGBX image\": (\"RGBX\", \"RGBX;L\"),\n    \"CMYK image\": (\"CMYK\", \"CMYK;L\"),\n    \"YCC image\": (\"YCbCr\", \"YCbCr;L\"),\n}\n\n# ifunc95 extensions\nfor i in [\"8\", \"8S\", \"16\", \"16S\", \"32\", \"32F\"]:\n    OPEN[f\"L {i} image\"] = (\"F\", f\"F;{i}\")\n    OPEN[f\"L*{i} image\"] = (\"F\", f\"F;{i}\")\nfor i in [\"16\", \"16L\", \"16B\"]:\n    OPEN[f\"L {i} image\"] = (f\"I;{i}\", f\"I;{i}\")\n    OPEN[f\"L*{i} image\"] = (f\"I;{i}\", f\"I;{i}\")\nfor i in [\"32S\"]:\n    OPEN[f\"L {i} image\"] = (\"I\", f\"I;{i}\")\n    OPEN[f\"L*{i} image\"] = (\"I\", f\"I;{i}\")\nfor j in range(2, 33):\n    OPEN[f\"L*{j} image\"] = (\"F\", f\"F;{j}\")\n\n\n# --------------------------------------------------------------------\n# Read IM directory\n\nsplit = re.compile(rb\"^([A-Za-z][^:]*):[ \\t]*(.*)[ \\t]*$\")\n\n\ndef number(s: Any) -> float:\n    try:\n        return int(s)\n    except ValueError:\n        return float(s)\n\n\n##\n# Image plugin for the IFUNC IM file format.\n\n\nclass ImImageFile(ImageFile.ImageFile):\n    format = \"IM\"\n    format_description = \"IFUNC Image Memory\"\n    _close_exclusive_fp_after_loading = False\n\n    def _open(self) -> None:\n        # Quick rejection: if there's not an LF among the first\n        # 100 bytes, this is (probably) not a text header.\n\n        if b\"\\n\" not in self.fp.read(100):\n            msg = \"not an IM file\"\n            raise SyntaxError(msg)\n        self.fp.seek(0)\n\n        n = 0\n\n        # Default values\n        self.info[MODE] = \"L\"\n        self.info[SIZE] = (512, 512)\n        self.info[FRAMES] = 1\n\n        self.rawmode = \"L\"\n\n        while True:\n            s = self.fp.read(1)\n\n            # Some versions of IFUNC uses \\n\\r instead of \\r\\n...\n            if s == b\"\\r\":\n                continue\n\n            if not s or s == b\"\\0\" or s == b\"\\x1A\":\n                break\n\n            # FIXME: this may read whole file if not a text file\n            s = s + self.fp.readline()\n\n            if len(s) > 100:\n                msg = \"not an IM file\"\n                raise SyntaxError(msg)\n\n            if s[-2:] == b\"\\r\\n\":\n                s = s[:-2]\n            elif s[-1:] == b\"\\n\":\n                s = s[:-1]\n\n            try:\n                m = split.match(s)\n            except re.error as e:\n                msg = \"not an IM file\"\n                raise SyntaxError(msg) from e\n\n            if m:\n                k, v = m.group(1, 2)\n\n                # Don't know if this is the correct encoding,\n                # but a decent guess (I guess)\n                k = k.decode(\"latin-1\", \"replace\")\n                v = v.decode(\"latin-1\", \"replace\")\n\n                # Convert value as appropriate\n                if k in [FRAMES, SCALE, SIZE]:\n                    v = v.replace(\"*\", \",\")\n                    v = tuple(map(number, v.split(\",\")))\n                    if len(v) == 1:\n                        v = v[0]\n                elif k == MODE and v in OPEN:\n                    v, self.rawmode = OPEN[v]\n\n                # Add to dictionary. Note that COMMENT tags are\n                # combined into a list of strings.\n                if k == COMMENT:\n                    if k in self.info:\n                        self.info[k].append(v)\n                    else:\n                        self.info[k] = [v]\n                else:\n                    self.info[k] = v\n\n                if k in TAGS:\n                    n += 1\n\n            else:\n                msg = f\"Syntax error in IM header: {s.decode('ascii', 'replace')}\"\n                raise SyntaxError(msg)\n\n        if not n:\n            msg = \"Not an IM file\"\n            raise SyntaxError(msg)\n\n        # Basic attributes\n        self._size = self.info[SIZE]\n        self._mode = self.info[MODE]\n\n        # Skip forward to start of image data\n        while s and s[:1] != b\"\\x1A\":\n            s = self.fp.read(1)\n        if not s:\n            msg = \"File truncated\"\n            raise SyntaxError(msg)\n\n        if LUT in self.info:\n            # convert lookup table to palette or lut attribute\n            palette = self.fp.read(768)\n            greyscale = 1  # greyscale palette\n            linear = 1  # linear greyscale palette\n            for i in range(256):\n                if palette[i] == palette[i + 256] == palette[i + 512]:\n                    if palette[i] != i:\n                        linear = 0\n                else:\n                    greyscale = 0\n            if self.mode in [\"L\", \"LA\", \"P\", \"PA\"]:\n                if greyscale:\n                    if not linear:\n                        self.lut = list(palette[:256])\n                else:\n                    if self.mode in [\"L\", \"P\"]:\n                        self._mode = self.rawmode = \"P\"\n                    elif self.mode in [\"LA\", \"PA\"]:\n                        self._mode = \"PA\"\n                        self.rawmode = \"PA;L\"\n                    self.palette = ImagePalette.raw(\"RGB;L\", palette)\n            elif self.mode == \"RGB\":\n                if not greyscale or not linear:\n                    self.lut = list(palette)\n\n        self.frame = 0\n\n        self.__offset = offs = self.fp.tell()\n\n        self._fp = self.fp  # FIXME: hack\n\n        if self.rawmode[:2] == \"F;\":\n            # ifunc95 formats\n            try:\n                # use bit decoder (if necessary)\n                bits = int(self.rawmode[2:])\n                if bits not in [8, 16, 32]:\n                    self.tile = [(\"bit\", (0, 0) + self.size, offs, (bits, 8, 3, 0, -1))]\n                    return\n            except ValueError:\n                pass\n\n        if self.rawmode in [\"RGB;T\", \"RYB;T\"]:\n            # Old LabEye/3PC files.  Would be very surprised if anyone\n            # ever stumbled upon such a file ;-)\n            size = self.size[0] * self.size[1]\n            self.tile = [\n                (\"raw\", (0, 0) + self.size, offs, (\"G\", 0, -1)),\n                (\"raw\", (0, 0) + self.size, offs + size, (\"R\", 0, -1)),\n                (\"raw\", (0, 0) + self.size, offs + 2 * size, (\"B\", 0, -1)),\n            ]\n        else:\n            # LabEye/IFUNC files\n            self.tile = [(\"raw\", (0, 0) + self.size, offs, (self.rawmode, 0, -1))]\n\n    @property\n    def n_frames(self) -> int:\n        return self.info[FRAMES]\n\n    @property\n    def is_animated(self) -> bool:\n        return self.info[FRAMES] > 1\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n\n        self.frame = frame\n\n        if self.mode == \"1\":\n            bits = 1\n        else:\n            bits = 8 * len(self.mode)\n\n        size = ((self.size[0] * bits + 7) // 8) * self.size[1]\n        offs = self.__offset + frame * size\n\n        self.fp = self._fp\n\n        self.tile = [(\"raw\", (0, 0) + self.size, offs, (self.rawmode, 0, -1))]\n\n    def tell(self) -> int:\n        return self.frame\n\n\n#\n# --------------------------------------------------------------------\n# Save IM files\n\n\nSAVE = {\n    # mode: (im type, raw mode)\n    \"1\": (\"0 1\", \"1\"),\n    \"L\": (\"Greyscale\", \"L\"),\n    \"LA\": (\"LA\", \"LA;L\"),\n    \"P\": (\"Greyscale\", \"P\"),\n    \"PA\": (\"LA\", \"PA;L\"),\n    \"I\": (\"L 32S\", \"I;32S\"),\n    \"I;16\": (\"L 16\", \"I;16\"),\n    \"I;16L\": (\"L 16L\", \"I;16L\"),\n    \"I;16B\": (\"L 16B\", \"I;16B\"),\n    \"F\": (\"L 32F\", \"F;32F\"),\n    \"RGB\": (\"RGB\", \"RGB;L\"),\n    \"RGBA\": (\"RGBA\", \"RGBA;L\"),\n    \"RGBX\": (\"RGBX\", \"RGBX;L\"),\n    \"CMYK\": (\"CMYK\", \"CMYK;L\"),\n    \"YCbCr\": (\"YCC\", \"YCbCr;L\"),\n}\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    try:\n        image_type, rawmode = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"Cannot save {im.mode} images as IM\"\n        raise ValueError(msg) from e\n\n    frames = im.encoderinfo.get(\"frames\", 1)\n\n    fp.write(f\"Image type: {image_type} image\\r\\n\".encode(\"ascii\"))\n    if filename:\n        # Each line must be 100 characters or less,\n        # or: SyntaxError(\"not an IM file\")\n        # 8 characters are used for \"Name: \" and \"\\r\\n\"\n        # Keep just the filename, ditch the potentially overlong path\n        if isinstance(filename, bytes):\n            filename = filename.decode(\"ascii\")\n        name, ext = os.path.splitext(os.path.basename(filename))\n        name = \"\".join([name[: 92 - len(ext)], ext])\n\n        fp.write(f\"Name: {name}\\r\\n\".encode(\"ascii\"))\n    fp.write((\"Image size (x*y): %d*%d\\r\\n\" % im.size).encode(\"ascii\"))\n    fp.write(f\"File size (no of images): {frames}\\r\\n\".encode(\"ascii\"))\n    if im.mode in [\"P\", \"PA\"]:\n        fp.write(b\"Lut: 1\\r\\n\")\n    fp.write(b\"\\000\" * (511 - fp.tell()) + b\"\\032\")\n    if im.mode in [\"P\", \"PA\"]:\n        im_palette = im.im.getpalette(\"RGB\", \"RGB;L\")\n        colors = len(im_palette) // 3\n        palette = b\"\"\n        for i in range(3):\n            palette += im_palette[colors * i : colors * (i + 1)]\n            palette += b\"\\x00\" * (256 - colors)\n        fp.write(palette)  # 768 bytes\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, -1))])\n\n\n#\n# --------------------------------------------------------------------\n# Registry\n\n\nImage.register_open(ImImageFile.format, ImImageFile)\nImage.register_save(ImImageFile.format, _save)\n\nImage.register_extension(ImImageFile.format, \".im\")\n", "src/PIL/features.py": "from __future__ import annotations\n\nimport collections\nimport os\nimport sys\nimport warnings\nfrom typing import IO\n\nimport PIL\n\nfrom . import Image\n\nmodules = {\n    \"pil\": (\"PIL._imaging\", \"PILLOW_VERSION\"),\n    \"tkinter\": (\"PIL._tkinter_finder\", \"tk_version\"),\n    \"freetype2\": (\"PIL._imagingft\", \"freetype2_version\"),\n    \"littlecms2\": (\"PIL._imagingcms\", \"littlecms_version\"),\n    \"webp\": (\"PIL._webp\", \"webpdecoder_version\"),\n}\n\n\ndef check_module(feature: str) -> bool:\n    \"\"\"\n    Checks if a module is available.\n\n    :param feature: The module to check for.\n    :returns: ``True`` if available, ``False`` otherwise.\n    :raises ValueError: If the module is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in modules:\n        msg = f\"Unknown module {feature}\"\n        raise ValueError(msg)\n\n    module, ver = modules[feature]\n\n    try:\n        __import__(module)\n        return True\n    except ModuleNotFoundError:\n        return False\n    except ImportError as ex:\n        warnings.warn(str(ex))\n        return False\n\n\ndef version_module(feature: str) -> str | None:\n    \"\"\"\n    :param feature: The module to check for.\n    :returns:\n        The loaded version number as a string, or ``None`` if unknown or not available.\n    :raises ValueError: If the module is not defined in this version of Pillow.\n    \"\"\"\n    if not check_module(feature):\n        return None\n\n    module, ver = modules[feature]\n\n    return getattr(__import__(module, fromlist=[ver]), ver)\n\n\ndef get_supported_modules() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported modules.\n    \"\"\"\n    return [f for f in modules if check_module(f)]\n\n\ncodecs = {\n    \"jpg\": (\"jpeg\", \"jpeglib\"),\n    \"jpg_2000\": (\"jpeg2k\", \"jp2klib\"),\n    \"zlib\": (\"zip\", \"zlib\"),\n    \"libtiff\": (\"libtiff\", \"libtiff\"),\n}\n\n\ndef check_codec(feature: str) -> bool:\n    \"\"\"\n    Checks if a codec is available.\n\n    :param feature: The codec to check for.\n    :returns: ``True`` if available, ``False`` otherwise.\n    :raises ValueError: If the codec is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in codecs:\n        msg = f\"Unknown codec {feature}\"\n        raise ValueError(msg)\n\n    codec, lib = codecs[feature]\n\n    return f\"{codec}_encoder\" in dir(Image.core)\n\n\ndef version_codec(feature: str) -> str | None:\n    \"\"\"\n    :param feature: The codec to check for.\n    :returns:\n        The version number as a string, or ``None`` if not available.\n        Checked at compile time for ``jpg``, run-time otherwise.\n    :raises ValueError: If the codec is not defined in this version of Pillow.\n    \"\"\"\n    if not check_codec(feature):\n        return None\n\n    codec, lib = codecs[feature]\n\n    version = getattr(Image.core, f\"{lib}_version\")\n\n    if feature == \"libtiff\":\n        return version.split(\"\\n\")[0].split(\"Version \")[1]\n\n    return version\n\n\ndef get_supported_codecs() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported codecs.\n    \"\"\"\n    return [f for f in codecs if check_codec(f)]\n\n\nfeatures = {\n    \"webp_anim\": (\"PIL._webp\", \"HAVE_WEBPANIM\", None),\n    \"webp_mux\": (\"PIL._webp\", \"HAVE_WEBPMUX\", None),\n    \"transp_webp\": (\"PIL._webp\", \"HAVE_TRANSPARENCY\", None),\n    \"raqm\": (\"PIL._imagingft\", \"HAVE_RAQM\", \"raqm_version\"),\n    \"fribidi\": (\"PIL._imagingft\", \"HAVE_FRIBIDI\", \"fribidi_version\"),\n    \"harfbuzz\": (\"PIL._imagingft\", \"HAVE_HARFBUZZ\", \"harfbuzz_version\"),\n    \"libjpeg_turbo\": (\"PIL._imaging\", \"HAVE_LIBJPEGTURBO\", \"libjpeg_turbo_version\"),\n    \"libimagequant\": (\"PIL._imaging\", \"HAVE_LIBIMAGEQUANT\", \"imagequant_version\"),\n    \"xcb\": (\"PIL._imaging\", \"HAVE_XCB\", None),\n}\n\n\ndef check_feature(feature: str) -> bool | None:\n    \"\"\"\n    Checks if a feature is available.\n\n    :param feature: The feature to check for.\n    :returns: ``True`` if available, ``False`` if unavailable, ``None`` if unknown.\n    :raises ValueError: If the feature is not defined in this version of Pillow.\n    \"\"\"\n    if feature not in features:\n        msg = f\"Unknown feature {feature}\"\n        raise ValueError(msg)\n\n    module, flag, ver = features[feature]\n\n    try:\n        imported_module = __import__(module, fromlist=[\"PIL\"])\n        return getattr(imported_module, flag)\n    except ModuleNotFoundError:\n        return None\n    except ImportError as ex:\n        warnings.warn(str(ex))\n        return None\n\n\ndef version_feature(feature: str) -> str | None:\n    \"\"\"\n    :param feature: The feature to check for.\n    :returns: The version number as a string, or ``None`` if not available.\n    :raises ValueError: If the feature is not defined in this version of Pillow.\n    \"\"\"\n    if not check_feature(feature):\n        return None\n\n    module, flag, ver = features[feature]\n\n    if ver is None:\n        return None\n\n    return getattr(__import__(module, fromlist=[ver]), ver)\n\n\ndef get_supported_features() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported features.\n    \"\"\"\n    return [f for f in features if check_feature(f)]\n\n\ndef check(feature: str) -> bool | None:\n    \"\"\"\n    :param feature: A module, codec, or feature name.\n    :returns:\n        ``True`` if the module, codec, or feature is available,\n        ``False`` or ``None`` otherwise.\n    \"\"\"\n\n    if feature in modules:\n        return check_module(feature)\n    if feature in codecs:\n        return check_codec(feature)\n    if feature in features:\n        return check_feature(feature)\n    warnings.warn(f\"Unknown feature '{feature}'.\", stacklevel=2)\n    return False\n\n\ndef version(feature: str) -> str | None:\n    \"\"\"\n    :param feature:\n        The module, codec, or feature to check for.\n    :returns:\n        The version number as a string, or ``None`` if unknown or not available.\n    \"\"\"\n    if feature in modules:\n        return version_module(feature)\n    if feature in codecs:\n        return version_codec(feature)\n    if feature in features:\n        return version_feature(feature)\n    return None\n\n\ndef get_supported() -> list[str]:\n    \"\"\"\n    :returns: A list of all supported modules, features, and codecs.\n    \"\"\"\n\n    ret = get_supported_modules()\n    ret.extend(get_supported_features())\n    ret.extend(get_supported_codecs())\n    return ret\n\n\ndef pilinfo(out: IO[str] | None = None, supported_formats: bool = True) -> None:\n    \"\"\"\n    Prints information about this installation of Pillow.\n    This function can be called with ``python3 -m PIL``.\n    It can also be called with ``python3 -m PIL.report`` or ``python3 -m PIL --report``\n    to have \"supported_formats\" set to ``False``, omitting the list of all supported\n    image file formats.\n\n    :param out:\n        The output stream to print to. Defaults to ``sys.stdout`` if ``None``.\n    :param supported_formats:\n        If ``True``, a list of all supported image file formats will be printed.\n    \"\"\"\n\n    if out is None:\n        out = sys.stdout\n\n    Image.init()\n\n    print(\"-\" * 68, file=out)\n    print(f\"Pillow {PIL.__version__}\", file=out)\n    py_version_lines = sys.version.splitlines()\n    print(f\"Python {py_version_lines[0].strip()}\", file=out)\n    for py_version in py_version_lines[1:]:\n        print(f\"       {py_version.strip()}\", file=out)\n    print(\"-\" * 68, file=out)\n    print(f\"Python executable is {sys.executable or 'unknown'}\", file=out)\n    if sys.prefix != sys.base_prefix:\n        print(f\"Environment Python files loaded from {sys.prefix}\", file=out)\n    print(f\"System Python files loaded from {sys.base_prefix}\", file=out)\n    print(\"-\" * 68, file=out)\n    print(\n        f\"Python Pillow modules loaded from {os.path.dirname(Image.__file__)}\",\n        file=out,\n    )\n    print(\n        f\"Binary Pillow modules loaded from {os.path.dirname(Image.core.__file__)}\",\n        file=out,\n    )\n    print(\"-\" * 68, file=out)\n\n    for name, feature in [\n        (\"pil\", \"PIL CORE\"),\n        (\"tkinter\", \"TKINTER\"),\n        (\"freetype2\", \"FREETYPE2\"),\n        (\"littlecms2\", \"LITTLECMS2\"),\n        (\"webp\", \"WEBP\"),\n        (\"transp_webp\", \"WEBP Transparency\"),\n        (\"webp_mux\", \"WEBPMUX\"),\n        (\"webp_anim\", \"WEBP Animation\"),\n        (\"jpg\", \"JPEG\"),\n        (\"jpg_2000\", \"OPENJPEG (JPEG2000)\"),\n        (\"zlib\", \"ZLIB (PNG/ZIP)\"),\n        (\"libtiff\", \"LIBTIFF\"),\n        (\"raqm\", \"RAQM (Bidirectional Text)\"),\n        (\"libimagequant\", \"LIBIMAGEQUANT (Quantization method)\"),\n        (\"xcb\", \"XCB (X protocol)\"),\n    ]:\n        if check(name):\n            v: str | None = None\n            if name == \"jpg\":\n                libjpeg_turbo_version = version_feature(\"libjpeg_turbo\")\n                if libjpeg_turbo_version is not None:\n                    v = \"libjpeg-turbo \" + libjpeg_turbo_version\n            if v is None:\n                v = version(name)\n            if v is not None:\n                version_static = name in (\"pil\", \"jpg\")\n                if name == \"littlecms2\":\n                    # this check is also in src/_imagingcms.c:setup_module()\n                    version_static = tuple(int(x) for x in v.split(\".\")) < (2, 7)\n                t = \"compiled for\" if version_static else \"loaded\"\n                if name == \"raqm\":\n                    for f in (\"fribidi\", \"harfbuzz\"):\n                        v2 = version_feature(f)\n                        if v2 is not None:\n                            v += f\", {f} {v2}\"\n                print(\"---\", feature, \"support ok,\", t, v, file=out)\n            else:\n                print(\"---\", feature, \"support ok\", file=out)\n        else:\n            print(\"***\", feature, \"support not installed\", file=out)\n    print(\"-\" * 68, file=out)\n\n    if supported_formats:\n        extensions = collections.defaultdict(list)\n        for ext, i in Image.EXTENSION.items():\n            extensions[i].append(ext)\n\n        for i in sorted(Image.ID):\n            line = f\"{i}\"\n            if i in Image.MIME:\n                line = f\"{line} {Image.MIME[i]}\"\n            print(line, file=out)\n\n            if i in extensions:\n                print(\n                    \"Extensions: {}\".format(\", \".join(sorted(extensions[i]))), file=out\n                )\n\n            features = []\n            if i in Image.OPEN:\n                features.append(\"open\")\n            if i in Image.SAVE:\n                features.append(\"save\")\n            if i in Image.SAVE_ALL:\n                features.append(\"save_all\")\n            if i in Image.DECODERS:\n                features.append(\"decode\")\n            if i in Image.ENCODERS:\n                features.append(\"encode\")\n\n            print(\"Features: {}\".format(\", \".join(features)), file=out)\n            print(\"-\" * 68, file=out)\n", "src/PIL/GifImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# GIF file handling\n#\n# History:\n# 1995-09-01 fl   Created\n# 1996-12-14 fl   Added interlace support\n# 1996-12-30 fl   Added animation support\n# 1997-01-05 fl   Added write support, fixed local colour map bug\n# 1997-02-23 fl   Make sure to load raster data in getdata()\n# 1997-07-05 fl   Support external decoder (0.4)\n# 1998-07-09 fl   Handle all modes when saving (0.5)\n# 1998-07-15 fl   Renamed offset attribute to avoid name clash\n# 2001-04-16 fl   Added rewind support (seek to frame 0) (0.6)\n# 2001-04-17 fl   Added palette optimization (0.7)\n# 2002-06-06 fl   Added transparency support for save (0.8)\n# 2004-02-24 fl   Disable interlacing for small images\n#\n# Copyright (c) 1997-2004 by Secret Labs AB\n# Copyright (c) 1995-2004 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport itertools\nimport math\nimport os\nimport subprocess\nimport sys\nfrom enum import IntEnum\nfrom functools import cached_property\nfrom typing import IO, TYPE_CHECKING, Any, List, Literal, NamedTuple, Union\n\nfrom . import (\n    Image,\n    ImageChops,\n    ImageFile,\n    ImageMath,\n    ImageOps,\n    ImagePalette,\n    ImageSequence,\n)\nfrom ._binary import i16le as i16\nfrom ._binary import o8\nfrom ._binary import o16le as o16\n\nif TYPE_CHECKING:\n    from . import _imaging\n\n\nclass LoadingStrategy(IntEnum):\n    \"\"\".. versionadded:: 9.1.0\"\"\"\n\n    RGB_AFTER_FIRST = 0\n    RGB_AFTER_DIFFERENT_PALETTE_ONLY = 1\n    RGB_ALWAYS = 2\n\n\n#: .. versionadded:: 9.1.0\nLOADING_STRATEGY = LoadingStrategy.RGB_AFTER_FIRST\n\n# --------------------------------------------------------------------\n# Identify/read GIF files\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:6] in [b\"GIF87a\", b\"GIF89a\"]\n\n\n##\n# Image plugin for GIF images.  This plugin supports both GIF87 and\n# GIF89 images.\n\n\nclass GifImageFile(ImageFile.ImageFile):\n    format = \"GIF\"\n    format_description = \"Compuserve GIF\"\n    _close_exclusive_fp_after_loading = False\n\n    global_palette = None\n\n    def data(self) -> bytes | None:\n        s = self.fp.read(1)\n        if s and s[0]:\n            return self.fp.read(s[0])\n        return None\n\n    def _is_palette_needed(self, p: bytes) -> bool:\n        for i in range(0, len(p), 3):\n            if not (i // 3 == p[i] == p[i + 1] == p[i + 2]):\n                return True\n        return False\n\n    def _open(self) -> None:\n        # Screen\n        s = self.fp.read(13)\n        if not _accept(s):\n            msg = \"not a GIF file\"\n            raise SyntaxError(msg)\n\n        self.info[\"version\"] = s[:6]\n        self._size = i16(s, 6), i16(s, 8)\n        self.tile = []\n        flags = s[10]\n        bits = (flags & 7) + 1\n\n        if flags & 128:\n            # get global palette\n            self.info[\"background\"] = s[11]\n            # check if palette contains colour indices\n            p = self.fp.read(3 << bits)\n            if self._is_palette_needed(p):\n                p = ImagePalette.raw(\"RGB\", p)\n                self.global_palette = self.palette = p\n\n        self._fp = self.fp  # FIXME: hack\n        self.__rewind = self.fp.tell()\n        self._n_frames: int | None = None\n        self._seek(0)  # get ready to read first frame\n\n    @property\n    def n_frames(self) -> int:\n        if self._n_frames is None:\n            current = self.tell()\n            try:\n                while True:\n                    self._seek(self.tell() + 1, False)\n            except EOFError:\n                self._n_frames = self.tell() + 1\n            self.seek(current)\n        return self._n_frames\n\n    @cached_property\n    def is_animated(self) -> bool:\n        if self._n_frames is not None:\n            return self._n_frames != 1\n\n        current = self.tell()\n        if current:\n            return True\n\n        try:\n            self._seek(1, False)\n            is_animated = True\n        except EOFError:\n            is_animated = False\n\n        self.seek(current)\n        return is_animated\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        if frame < self.__frame:\n            self.im = None\n            self._seek(0)\n\n        last_frame = self.__frame\n        for f in range(self.__frame + 1, frame + 1):\n            try:\n                self._seek(f)\n            except EOFError as e:\n                self.seek(last_frame)\n                msg = \"no more images in GIF file\"\n                raise EOFError(msg) from e\n\n    def _seek(self, frame: int, update_image: bool = True) -> None:\n        if frame == 0:\n            # rewind\n            self.__offset = 0\n            self.dispose: _imaging.ImagingCore | None = None\n            self.__frame = -1\n            self._fp.seek(self.__rewind)\n            self.disposal_method = 0\n            if \"comment\" in self.info:\n                del self.info[\"comment\"]\n        else:\n            # ensure that the previous frame was loaded\n            if self.tile and update_image:\n                self.load()\n\n        if frame != self.__frame + 1:\n            msg = f\"cannot seek to frame {frame}\"\n            raise ValueError(msg)\n\n        self.fp = self._fp\n        if self.__offset:\n            # backup to last frame\n            self.fp.seek(self.__offset)\n            while self.data():\n                pass\n            self.__offset = 0\n\n        s = self.fp.read(1)\n        if not s or s == b\";\":\n            msg = \"no more images in GIF file\"\n            raise EOFError(msg)\n\n        palette: ImagePalette.ImagePalette | Literal[False] | None = None\n\n        info: dict[str, Any] = {}\n        frame_transparency = None\n        interlace = None\n        frame_dispose_extent = None\n        while True:\n            if not s:\n                s = self.fp.read(1)\n            if not s or s == b\";\":\n                break\n\n            elif s == b\"!\":\n                #\n                # extensions\n                #\n                s = self.fp.read(1)\n                block = self.data()\n                if s[0] == 249 and block is not None:\n                    #\n                    # graphic control extension\n                    #\n                    flags = block[0]\n                    if flags & 1:\n                        frame_transparency = block[3]\n                    info[\"duration\"] = i16(block, 1) * 10\n\n                    # disposal method - find the value of bits 4 - 6\n                    dispose_bits = 0b00011100 & flags\n                    dispose_bits = dispose_bits >> 2\n                    if dispose_bits:\n                        # only set the dispose if it is not\n                        # unspecified. I'm not sure if this is\n                        # correct, but it seems to prevent the last\n                        # frame from looking odd for some animations\n                        self.disposal_method = dispose_bits\n                elif s[0] == 254:\n                    #\n                    # comment extension\n                    #\n                    comment = b\"\"\n\n                    # Read this comment block\n                    while block:\n                        comment += block\n                        block = self.data()\n\n                    if \"comment\" in info:\n                        # If multiple comment blocks in frame, separate with \\n\n                        info[\"comment\"] += b\"\\n\" + comment\n                    else:\n                        info[\"comment\"] = comment\n                    s = None\n                    continue\n                elif s[0] == 255 and frame == 0 and block is not None:\n                    #\n                    # application extension\n                    #\n                    info[\"extension\"] = block, self.fp.tell()\n                    if block[:11] == b\"NETSCAPE2.0\":\n                        block = self.data()\n                        if block and len(block) >= 3 and block[0] == 1:\n                            self.info[\"loop\"] = i16(block, 1)\n                while self.data():\n                    pass\n\n            elif s == b\",\":\n                #\n                # local image\n                #\n                s = self.fp.read(9)\n\n                # extent\n                x0, y0 = i16(s, 0), i16(s, 2)\n                x1, y1 = x0 + i16(s, 4), y0 + i16(s, 6)\n                if (x1 > self.size[0] or y1 > self.size[1]) and update_image:\n                    self._size = max(x1, self.size[0]), max(y1, self.size[1])\n                    Image._decompression_bomb_check(self._size)\n                frame_dispose_extent = x0, y0, x1, y1\n                flags = s[8]\n\n                interlace = (flags & 64) != 0\n\n                if flags & 128:\n                    bits = (flags & 7) + 1\n                    p = self.fp.read(3 << bits)\n                    if self._is_palette_needed(p):\n                        palette = ImagePalette.raw(\"RGB\", p)\n                    else:\n                        palette = False\n\n                # image data\n                bits = self.fp.read(1)[0]\n                self.__offset = self.fp.tell()\n                break\n            s = None\n\n        if interlace is None:\n            msg = \"image not found in GIF frame\"\n            raise EOFError(msg)\n\n        self.__frame = frame\n        if not update_image:\n            return\n\n        self.tile = []\n\n        if self.dispose:\n            self.im.paste(self.dispose, self.dispose_extent)\n\n        self._frame_palette = palette if palette is not None else self.global_palette\n        self._frame_transparency = frame_transparency\n        if frame == 0:\n            if self._frame_palette:\n                if LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS:\n                    self._mode = \"RGBA\" if frame_transparency is not None else \"RGB\"\n                else:\n                    self._mode = \"P\"\n            else:\n                self._mode = \"L\"\n\n            if not palette and self.global_palette:\n                from copy import copy\n\n                palette = copy(self.global_palette)\n            self.palette = palette\n        else:\n            if self.mode == \"P\":\n                if (\n                    LOADING_STRATEGY != LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY\n                    or palette\n                ):\n                    self.pyaccess = None\n                    if \"transparency\" in self.info:\n                        self.im.putpalettealpha(self.info[\"transparency\"], 0)\n                        self.im = self.im.convert(\"RGBA\", Image.Dither.FLOYDSTEINBERG)\n                        self._mode = \"RGBA\"\n                        del self.info[\"transparency\"]\n                    else:\n                        self._mode = \"RGB\"\n                        self.im = self.im.convert(\"RGB\", Image.Dither.FLOYDSTEINBERG)\n\n        def _rgb(color: int) -> tuple[int, int, int]:\n            if self._frame_palette:\n                if color * 3 + 3 > len(self._frame_palette.palette):\n                    color = 0\n                return tuple(self._frame_palette.palette[color * 3 : color * 3 + 3])\n            else:\n                return (color, color, color)\n\n        self.dispose = None\n        self.dispose_extent = frame_dispose_extent\n        if self.dispose_extent and self.disposal_method >= 2:\n            try:\n                if self.disposal_method == 2:\n                    # replace with background colour\n\n                    # only dispose the extent in this frame\n                    x0, y0, x1, y1 = self.dispose_extent\n                    dispose_size = (x1 - x0, y1 - y0)\n\n                    Image._decompression_bomb_check(dispose_size)\n\n                    # by convention, attempt to use transparency first\n                    dispose_mode = \"P\"\n                    color = self.info.get(\"transparency\", frame_transparency)\n                    if color is not None:\n                        if self.mode in (\"RGB\", \"RGBA\"):\n                            dispose_mode = \"RGBA\"\n                            color = _rgb(color) + (0,)\n                    else:\n                        color = self.info.get(\"background\", 0)\n                        if self.mode in (\"RGB\", \"RGBA\"):\n                            dispose_mode = \"RGB\"\n                            color = _rgb(color)\n                    self.dispose = Image.core.fill(dispose_mode, dispose_size, color)\n                else:\n                    # replace with previous contents\n                    if self.im is not None:\n                        # only dispose the extent in this frame\n                        self.dispose = self._crop(self.im, self.dispose_extent)\n                    elif frame_transparency is not None:\n                        x0, y0, x1, y1 = self.dispose_extent\n                        dispose_size = (x1 - x0, y1 - y0)\n\n                        Image._decompression_bomb_check(dispose_size)\n                        dispose_mode = \"P\"\n                        color = frame_transparency\n                        if self.mode in (\"RGB\", \"RGBA\"):\n                            dispose_mode = \"RGBA\"\n                            color = _rgb(frame_transparency) + (0,)\n                        self.dispose = Image.core.fill(\n                            dispose_mode, dispose_size, color\n                        )\n            except AttributeError:\n                pass\n\n        if interlace is not None:\n            transparency = -1\n            if frame_transparency is not None:\n                if frame == 0:\n                    if LOADING_STRATEGY != LoadingStrategy.RGB_ALWAYS:\n                        self.info[\"transparency\"] = frame_transparency\n                elif self.mode not in (\"RGB\", \"RGBA\"):\n                    transparency = frame_transparency\n            self.tile = [\n                (\n                    \"gif\",\n                    (x0, y0, x1, y1),\n                    self.__offset,\n                    (bits, interlace, transparency),\n                )\n            ]\n\n        if info.get(\"comment\"):\n            self.info[\"comment\"] = info[\"comment\"]\n        for k in [\"duration\", \"extension\"]:\n            if k in info:\n                self.info[k] = info[k]\n            elif k in self.info:\n                del self.info[k]\n\n    def load_prepare(self) -> None:\n        temp_mode = \"P\" if self._frame_palette else \"L\"\n        self._prev_im = None\n        if self.__frame == 0:\n            if self._frame_transparency is not None:\n                self.im = Image.core.fill(\n                    temp_mode, self.size, self._frame_transparency\n                )\n        elif self.mode in (\"RGB\", \"RGBA\"):\n            self._prev_im = self.im\n            if self._frame_palette:\n                self.im = Image.core.fill(\"P\", self.size, self._frame_transparency or 0)\n                self.im.putpalette(\"RGB\", *self._frame_palette.getdata())\n            else:\n                self.im = None\n        self._mode = temp_mode\n        self._frame_palette = None\n\n        super().load_prepare()\n\n    def load_end(self) -> None:\n        if self.__frame == 0:\n            if self.mode == \"P\" and LOADING_STRATEGY == LoadingStrategy.RGB_ALWAYS:\n                if self._frame_transparency is not None:\n                    self.im.putpalettealpha(self._frame_transparency, 0)\n                    self._mode = \"RGBA\"\n                else:\n                    self._mode = \"RGB\"\n                self.im = self.im.convert(self.mode, Image.Dither.FLOYDSTEINBERG)\n            return\n        if not self._prev_im:\n            return\n        if self._frame_transparency is not None:\n            self.im.putpalettealpha(self._frame_transparency, 0)\n            frame_im = self.im.convert(\"RGBA\")\n        else:\n            frame_im = self.im.convert(\"RGB\")\n\n        assert self.dispose_extent is not None\n        frame_im = self._crop(frame_im, self.dispose_extent)\n\n        self.im = self._prev_im\n        self._mode = self.im.mode\n        if frame_im.mode == \"RGBA\":\n            self.im.paste(frame_im, self.dispose_extent, frame_im)\n        else:\n            self.im.paste(frame_im, self.dispose_extent)\n\n    def tell(self) -> int:\n        return self.__frame\n\n\n# --------------------------------------------------------------------\n# Write GIF files\n\n\nRAWMODE = {\"1\": \"L\", \"L\": \"L\", \"P\": \"P\"}\n\n\ndef _normalize_mode(im: Image.Image) -> Image.Image:\n    \"\"\"\n    Takes an image (or frame), returns an image in a mode that is appropriate\n    for saving in a Gif.\n\n    It may return the original image, or it may return an image converted to\n    palette or 'L' mode.\n\n    :param im: Image object\n    :returns: Image object\n    \"\"\"\n    if im.mode in RAWMODE:\n        im.load()\n        return im\n    if Image.getmodebase(im.mode) == \"RGB\":\n        im = im.convert(\"P\", palette=Image.Palette.ADAPTIVE)\n        if im.palette.mode == \"RGBA\":\n            for rgba in im.palette.colors:\n                if rgba[3] == 0:\n                    im.info[\"transparency\"] = im.palette.colors[rgba]\n                    break\n        return im\n    return im.convert(\"L\")\n\n\n_Palette = Union[bytes, bytearray, List[int], ImagePalette.ImagePalette]\n\n\ndef _normalize_palette(\n    im: Image.Image, palette: _Palette | None, info: dict[str, Any]\n) -> Image.Image:\n    \"\"\"\n    Normalizes the palette for image.\n      - Sets the palette to the incoming palette, if provided.\n      - Ensures that there's a palette for L mode images\n      - Optimizes the palette if necessary/desired.\n\n    :param im: Image object\n    :param palette: bytes object containing the source palette, or ....\n    :param info: encoderinfo\n    :returns: Image object\n    \"\"\"\n    source_palette = None\n    if palette:\n        # a bytes palette\n        if isinstance(palette, (bytes, bytearray, list)):\n            source_palette = bytearray(palette[:768])\n        if isinstance(palette, ImagePalette.ImagePalette):\n            source_palette = bytearray(palette.palette)\n\n    if im.mode == \"P\":\n        if not source_palette:\n            source_palette = im.im.getpalette(\"RGB\")[:768]\n    else:  # L-mode\n        if not source_palette:\n            source_palette = bytearray(i // 3 for i in range(768))\n        im.palette = ImagePalette.ImagePalette(\"RGB\", palette=source_palette)\n\n    used_palette_colors: list[int] | None\n    if palette:\n        used_palette_colors = []\n        assert source_palette is not None\n        for i in range(0, len(source_palette), 3):\n            source_color = tuple(source_palette[i : i + 3])\n            index = im.palette.colors.get(source_color)\n            if index in used_palette_colors:\n                index = None\n            used_palette_colors.append(index)\n        for i, index in enumerate(used_palette_colors):\n            if index is None:\n                for j in range(len(used_palette_colors)):\n                    if j not in used_palette_colors:\n                        used_palette_colors[i] = j\n                        break\n        im = im.remap_palette(used_palette_colors)\n    else:\n        used_palette_colors = _get_optimize(im, info)\n        if used_palette_colors is not None:\n            im = im.remap_palette(used_palette_colors, source_palette)\n            if \"transparency\" in info:\n                try:\n                    info[\"transparency\"] = used_palette_colors.index(\n                        info[\"transparency\"]\n                    )\n                except ValueError:\n                    del info[\"transparency\"]\n            return im\n\n    im.palette.palette = source_palette\n    return im\n\n\ndef _write_single_frame(\n    im: Image.Image,\n    fp: IO[bytes],\n    palette: _Palette | None,\n) -> None:\n    im_out = _normalize_mode(im)\n    for k, v in im_out.info.items():\n        im.encoderinfo.setdefault(k, v)\n    im_out = _normalize_palette(im_out, palette, im.encoderinfo)\n\n    for s in _get_global_header(im_out, im.encoderinfo):\n        fp.write(s)\n\n    # local image header\n    flags = 0\n    if get_interlace(im):\n        flags = flags | 64\n    _write_local_header(fp, im, (0, 0), flags)\n\n    im_out.encoderconfig = (8, get_interlace(im))\n    ImageFile._save(im_out, fp, [(\"gif\", (0, 0) + im.size, 0, RAWMODE[im_out.mode])])\n\n    fp.write(b\"\\0\")  # end of image data\n\n\ndef _getbbox(\n    base_im: Image.Image, im_frame: Image.Image\n) -> tuple[Image.Image, tuple[int, int, int, int] | None]:\n    if _get_palette_bytes(im_frame) != _get_palette_bytes(base_im):\n        im_frame = im_frame.convert(\"RGBA\")\n        base_im = base_im.convert(\"RGBA\")\n    delta = ImageChops.subtract_modulo(im_frame, base_im)\n    return delta, delta.getbbox(alpha_only=False)\n\n\nclass _Frame(NamedTuple):\n    im: Image.Image\n    bbox: tuple[int, int, int, int] | None\n    encoderinfo: dict[str, Any]\n\n\ndef _write_multiple_frames(\n    im: Image.Image, fp: IO[bytes], palette: _Palette | None\n) -> bool:\n    duration = im.encoderinfo.get(\"duration\")\n    disposal = im.encoderinfo.get(\"disposal\", im.info.get(\"disposal\"))\n\n    im_frames: list[_Frame] = []\n    previous_im: Image.Image | None = None\n    frame_count = 0\n    background_im = None\n    for imSequence in itertools.chain([im], im.encoderinfo.get(\"append_images\", [])):\n        for im_frame in ImageSequence.Iterator(imSequence):\n            # a copy is required here since seek can still mutate the image\n            im_frame = _normalize_mode(im_frame.copy())\n            if frame_count == 0:\n                for k, v in im_frame.info.items():\n                    if k == \"transparency\":\n                        continue\n                    im.encoderinfo.setdefault(k, v)\n\n            encoderinfo = im.encoderinfo.copy()\n            if \"transparency\" in im_frame.info:\n                encoderinfo.setdefault(\"transparency\", im_frame.info[\"transparency\"])\n            im_frame = _normalize_palette(im_frame, palette, encoderinfo)\n            if isinstance(duration, (list, tuple)):\n                encoderinfo[\"duration\"] = duration[frame_count]\n            elif duration is None and \"duration\" in im_frame.info:\n                encoderinfo[\"duration\"] = im_frame.info[\"duration\"]\n            if isinstance(disposal, (list, tuple)):\n                encoderinfo[\"disposal\"] = disposal[frame_count]\n            frame_count += 1\n\n            diff_frame = None\n            if im_frames and previous_im:\n                # delta frame\n                delta, bbox = _getbbox(previous_im, im_frame)\n                if not bbox:\n                    # This frame is identical to the previous frame\n                    if encoderinfo.get(\"duration\"):\n                        im_frames[-1].encoderinfo[\"duration\"] += encoderinfo[\"duration\"]\n                    continue\n                if im_frames[-1].encoderinfo.get(\"disposal\") == 2:\n                    if background_im is None:\n                        color = im.encoderinfo.get(\n                            \"transparency\", im.info.get(\"transparency\", (0, 0, 0))\n                        )\n                        background = _get_background(im_frame, color)\n                        background_im = Image.new(\"P\", im_frame.size, background)\n                        background_im.putpalette(im_frames[0].im.palette)\n                    bbox = _getbbox(background_im, im_frame)[1]\n                elif encoderinfo.get(\"optimize\") and im_frame.mode != \"1\":\n                    if \"transparency\" not in encoderinfo:\n                        try:\n                            encoderinfo[\"transparency\"] = (\n                                im_frame.palette._new_color_index(im_frame)\n                            )\n                        except ValueError:\n                            pass\n                    if \"transparency\" in encoderinfo:\n                        # When the delta is zero, fill the image with transparency\n                        diff_frame = im_frame.copy()\n                        fill = Image.new(\"P\", delta.size, encoderinfo[\"transparency\"])\n                        if delta.mode == \"RGBA\":\n                            r, g, b, a = delta.split()\n                            mask = ImageMath.lambda_eval(\n                                lambda args: args[\"convert\"](\n                                    args[\"max\"](\n                                        args[\"max\"](\n                                            args[\"max\"](args[\"r\"], args[\"g\"]), args[\"b\"]\n                                        ),\n                                        args[\"a\"],\n                                    )\n                                    * 255,\n                                    \"1\",\n                                ),\n                                r=r,\n                                g=g,\n                                b=b,\n                                a=a,\n                            )\n                        else:\n                            if delta.mode == \"P\":\n                                # Convert to L without considering palette\n                                delta_l = Image.new(\"L\", delta.size)\n                                delta_l.putdata(delta.getdata())\n                                delta = delta_l\n                            mask = ImageMath.lambda_eval(\n                                lambda args: args[\"convert\"](args[\"im\"] * 255, \"1\"),\n                                im=delta,\n                            )\n                        diff_frame.paste(fill, mask=ImageOps.invert(mask))\n            else:\n                bbox = None\n            previous_im = im_frame\n            im_frames.append(_Frame(diff_frame or im_frame, bbox, encoderinfo))\n\n    if len(im_frames) == 1:\n        if \"duration\" in im.encoderinfo:\n            # Since multiple frames will not be written, use the combined duration\n            im.encoderinfo[\"duration\"] = im_frames[0].encoderinfo[\"duration\"]\n        return False\n\n    for frame_data in im_frames:\n        im_frame = frame_data.im\n        if not frame_data.bbox:\n            # global header\n            for s in _get_global_header(im_frame, frame_data.encoderinfo):\n                fp.write(s)\n            offset = (0, 0)\n        else:\n            # compress difference\n            if not palette:\n                frame_data.encoderinfo[\"include_color_table\"] = True\n\n            im_frame = im_frame.crop(frame_data.bbox)\n            offset = frame_data.bbox[:2]\n        _write_frame_data(fp, im_frame, offset, frame_data.encoderinfo)\n    return True\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, save_all=True)\n\n\ndef _save(\n    im: Image.Image, fp: IO[bytes], filename: str | bytes, save_all: bool = False\n) -> None:\n    # header\n    if \"palette\" in im.encoderinfo or \"palette\" in im.info:\n        palette = im.encoderinfo.get(\"palette\", im.info.get(\"palette\"))\n    else:\n        palette = None\n        im.encoderinfo.setdefault(\"optimize\", True)\n\n    if not save_all or not _write_multiple_frames(im, fp, palette):\n        _write_single_frame(im, fp, palette)\n\n    fp.write(b\";\")  # end of file\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\ndef get_interlace(im: Image.Image) -> int:\n    interlace = im.encoderinfo.get(\"interlace\", 1)\n\n    # workaround for @PIL153\n    if min(im.size) < 16:\n        interlace = 0\n\n    return interlace\n\n\ndef _write_local_header(\n    fp: IO[bytes], im: Image.Image, offset: tuple[int, int], flags: int\n) -> None:\n    try:\n        transparency = im.encoderinfo[\"transparency\"]\n    except KeyError:\n        transparency = None\n\n    if \"duration\" in im.encoderinfo:\n        duration = int(im.encoderinfo[\"duration\"] / 10)\n    else:\n        duration = 0\n\n    disposal = int(im.encoderinfo.get(\"disposal\", 0))\n\n    if transparency is not None or duration != 0 or disposal:\n        packed_flag = 1 if transparency is not None else 0\n        packed_flag |= disposal << 2\n\n        fp.write(\n            b\"!\"\n            + o8(249)  # extension intro\n            + o8(4)  # length\n            + o8(packed_flag)  # packed fields\n            + o16(duration)  # duration\n            + o8(transparency or 0)  # transparency index\n            + o8(0)\n        )\n\n    include_color_table = im.encoderinfo.get(\"include_color_table\")\n    if include_color_table:\n        palette_bytes = _get_palette_bytes(im)\n        color_table_size = _get_color_table_size(palette_bytes)\n        if color_table_size:\n            flags = flags | 128  # local color table flag\n            flags = flags | color_table_size\n\n    fp.write(\n        b\",\"\n        + o16(offset[0])  # offset\n        + o16(offset[1])\n        + o16(im.size[0])  # size\n        + o16(im.size[1])\n        + o8(flags)  # flags\n    )\n    if include_color_table and color_table_size:\n        fp.write(_get_header_palette(palette_bytes))\n    fp.write(o8(8))  # bits\n\n\ndef _save_netpbm(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    # Unused by default.\n    # To use, uncomment the register_save call at the end of the file.\n    #\n    # If you need real GIF compression and/or RGB quantization, you\n    # can use the external NETPBM/PBMPLUS utilities.  See comments\n    # below for information on how to enable this.\n    tempfile = im._dump()\n\n    try:\n        with open(filename, \"wb\") as f:\n            if im.mode != \"RGB\":\n                subprocess.check_call(\n                    [\"ppmtogif\", tempfile], stdout=f, stderr=subprocess.DEVNULL\n                )\n            else:\n                # Pipe ppmquant output into ppmtogif\n                # \"ppmquant 256 %s | ppmtogif > %s\" % (tempfile, filename)\n                quant_cmd = [\"ppmquant\", \"256\", tempfile]\n                togif_cmd = [\"ppmtogif\"]\n                quant_proc = subprocess.Popen(\n                    quant_cmd, stdout=subprocess.PIPE, stderr=subprocess.DEVNULL\n                )\n                togif_proc = subprocess.Popen(\n                    togif_cmd,\n                    stdin=quant_proc.stdout,\n                    stdout=f,\n                    stderr=subprocess.DEVNULL,\n                )\n\n                # Allow ppmquant to receive SIGPIPE if ppmtogif exits\n                assert quant_proc.stdout is not None\n                quant_proc.stdout.close()\n\n                retcode = quant_proc.wait()\n                if retcode:\n                    raise subprocess.CalledProcessError(retcode, quant_cmd)\n\n                retcode = togif_proc.wait()\n                if retcode:\n                    raise subprocess.CalledProcessError(retcode, togif_cmd)\n    finally:\n        try:\n            os.unlink(tempfile)\n        except OSError:\n            pass\n\n\n# Force optimization so that we can test performance against\n# cases where it took lots of memory and time previously.\n_FORCE_OPTIMIZE = False\n\n\ndef _get_optimize(im: Image.Image, info: dict[str, Any]) -> list[int] | None:\n    \"\"\"\n    Palette optimization is a potentially expensive operation.\n\n    This function determines if the palette should be optimized using\n    some heuristics, then returns the list of palette entries in use.\n\n    :param im: Image object\n    :param info: encoderinfo\n    :returns: list of indexes of palette entries in use, or None\n    \"\"\"\n    if im.mode in (\"P\", \"L\") and info and info.get(\"optimize\"):\n        # Potentially expensive operation.\n\n        # The palette saves 3 bytes per color not used, but palette\n        # lengths are restricted to 3*(2**N) bytes. Max saving would\n        # be 768 -> 6 bytes if we went all the way down to 2 colors.\n        # * If we're over 128 colors, we can't save any space.\n        # * If there aren't any holes, it's not worth collapsing.\n        # * If we have a 'large' image, the palette is in the noise.\n\n        # create the new palette if not every color is used\n        optimise = _FORCE_OPTIMIZE or im.mode == \"L\"\n        if optimise or im.width * im.height < 512 * 512:\n            # check which colors are used\n            used_palette_colors = []\n            for i, count in enumerate(im.histogram()):\n                if count:\n                    used_palette_colors.append(i)\n\n            if optimise or max(used_palette_colors) >= len(used_palette_colors):\n                return used_palette_colors\n\n            num_palette_colors = len(im.palette.palette) // Image.getmodebands(\n                im.palette.mode\n            )\n            current_palette_size = 1 << (num_palette_colors - 1).bit_length()\n            if (\n                # check that the palette would become smaller when saved\n                len(used_palette_colors) <= current_palette_size // 2\n                # check that the palette is not already the smallest possible size\n                and current_palette_size > 2\n            ):\n                return used_palette_colors\n    return None\n\n\ndef _get_color_table_size(palette_bytes: bytes) -> int:\n    # calculate the palette size for the header\n    if not palette_bytes:\n        return 0\n    elif len(palette_bytes) < 9:\n        return 1\n    else:\n        return math.ceil(math.log(len(palette_bytes) // 3, 2)) - 1\n\n\ndef _get_header_palette(palette_bytes: bytes) -> bytes:\n    \"\"\"\n    Returns the palette, null padded to the next power of 2 (*3) bytes\n    suitable for direct inclusion in the GIF header\n\n    :param palette_bytes: Unpadded palette bytes, in RGBRGB form\n    :returns: Null padded palette\n    \"\"\"\n    color_table_size = _get_color_table_size(palette_bytes)\n\n    # add the missing amount of bytes\n    # the palette has to be 2<<n in size\n    actual_target_size_diff = (2 << color_table_size) - len(palette_bytes) // 3\n    if actual_target_size_diff > 0:\n        palette_bytes += o8(0) * 3 * actual_target_size_diff\n    return palette_bytes\n\n\ndef _get_palette_bytes(im: Image.Image) -> bytes:\n    \"\"\"\n    Gets the palette for inclusion in the gif header\n\n    :param im: Image object\n    :returns: Bytes, len<=768 suitable for inclusion in gif header\n    \"\"\"\n    return im.palette.palette if im.palette else b\"\"\n\n\ndef _get_background(\n    im: Image.Image,\n    info_background: int | tuple[int, int, int] | tuple[int, int, int, int] | None,\n) -> int:\n    background = 0\n    if info_background:\n        if isinstance(info_background, tuple):\n            # WebPImagePlugin stores an RGBA value in info[\"background\"]\n            # So it must be converted to the same format as GifImagePlugin's\n            # info[\"background\"] - a global color table index\n            try:\n                background = im.palette.getcolor(info_background, im)\n            except ValueError as e:\n                if str(e) not in (\n                    # If all 256 colors are in use,\n                    # then there is no need for the background color\n                    \"cannot allocate more than 256 colors\",\n                    # Ignore non-opaque WebP background\n                    \"cannot add non-opaque RGBA color to RGB palette\",\n                ):\n                    raise\n        else:\n            background = info_background\n    return background\n\n\ndef _get_global_header(im: Image.Image, info: dict[str, Any]) -> list[bytes]:\n    \"\"\"Return a list of strings representing a GIF header\"\"\"\n\n    # Header Block\n    # https://www.matthewflickinger.com/lab/whatsinagif/bits_and_bytes.asp\n\n    version = b\"87a\"\n    if im.info.get(\"version\") == b\"89a\" or (\n        info\n        and (\n            \"transparency\" in info\n            or info.get(\"loop\") is not None\n            or info.get(\"duration\")\n            or info.get(\"comment\")\n        )\n    ):\n        version = b\"89a\"\n\n    background = _get_background(im, info.get(\"background\"))\n\n    palette_bytes = _get_palette_bytes(im)\n    color_table_size = _get_color_table_size(palette_bytes)\n\n    header = [\n        b\"GIF\"  # signature\n        + version  # version\n        + o16(im.size[0])  # canvas width\n        + o16(im.size[1]),  # canvas height\n        # Logical Screen Descriptor\n        # size of global color table + global color table flag\n        o8(color_table_size + 128),  # packed fields\n        # background + reserved/aspect\n        o8(background) + o8(0),\n        # Global Color Table\n        _get_header_palette(palette_bytes),\n    ]\n    if info.get(\"loop\") is not None:\n        header.append(\n            b\"!\"\n            + o8(255)  # extension intro\n            + o8(11)\n            + b\"NETSCAPE2.0\"\n            + o8(3)\n            + o8(1)\n            + o16(info[\"loop\"])  # number of loops\n            + o8(0)\n        )\n    if info.get(\"comment\"):\n        comment_block = b\"!\" + o8(254)  # extension intro\n\n        comment = info[\"comment\"]\n        if isinstance(comment, str):\n            comment = comment.encode()\n        for i in range(0, len(comment), 255):\n            subblock = comment[i : i + 255]\n            comment_block += o8(len(subblock)) + subblock\n\n        comment_block += o8(0)\n        header.append(comment_block)\n    return header\n\n\ndef _write_frame_data(\n    fp: IO[bytes],\n    im_frame: Image.Image,\n    offset: tuple[int, int],\n    params: dict[str, Any],\n) -> None:\n    try:\n        im_frame.encoderinfo = params\n\n        # local image header\n        _write_local_header(fp, im_frame, offset, 0)\n\n        ImageFile._save(\n            im_frame, fp, [(\"gif\", (0, 0) + im_frame.size, 0, RAWMODE[im_frame.mode])]\n        )\n\n        fp.write(b\"\\0\")  # end of image data\n    finally:\n        del im_frame.encoderinfo\n\n\n# --------------------------------------------------------------------\n# Legacy GIF utilities\n\n\ndef getheader(\n    im: Image.Image, palette: _Palette | None = None, info: dict[str, Any] | None = None\n) -> tuple[list[bytes], list[int] | None]:\n    \"\"\"\n    Legacy Method to get Gif data from image.\n\n    Warning:: May modify image data.\n\n    :param im: Image object\n    :param palette: bytes object containing the source palette, or ....\n    :param info: encoderinfo\n    :returns: tuple of(list of header items, optimized palette)\n\n    \"\"\"\n    if info is None:\n        info = {}\n\n    used_palette_colors = _get_optimize(im, info)\n\n    if \"background\" not in info and \"background\" in im.info:\n        info[\"background\"] = im.info[\"background\"]\n\n    im_mod = _normalize_palette(im, palette, info)\n    im.palette = im_mod.palette\n    im.im = im_mod.im\n    header = _get_global_header(im, info)\n\n    return header, used_palette_colors\n\n\ndef getdata(\n    im: Image.Image, offset: tuple[int, int] = (0, 0), **params: Any\n) -> list[bytes]:\n    \"\"\"\n    Legacy Method\n\n    Return a list of strings representing this image.\n    The first string is a local image header, the rest contains\n    encoded image data.\n\n    To specify duration, add the time in milliseconds,\n    e.g. ``getdata(im_frame, duration=1000)``\n\n    :param im: Image object\n    :param offset: Tuple of (x, y) pixels. Defaults to (0, 0)\n    :param \\\\**params: e.g. duration or other encoder info parameters\n    :returns: List of bytes containing GIF encoded frame data\n\n    \"\"\"\n    from io import BytesIO\n\n    class Collector(BytesIO):\n        data = []\n\n        if sys.version_info >= (3, 12):\n            from collections.abc import Buffer\n\n            def write(self, data: Buffer) -> int:\n                self.data.append(data)\n                return len(data)\n\n        else:\n\n            def write(self, data: Any) -> int:\n                self.data.append(data)\n                return len(data)\n\n    im.load()  # make sure raster data is available\n\n    fp = Collector()\n\n    _write_frame_data(fp, im, offset, params)\n\n    return fp.data\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(GifImageFile.format, GifImageFile, _accept)\nImage.register_save(GifImageFile.format, _save)\nImage.register_save_all(GifImageFile.format, _save_all)\nImage.register_extension(GifImageFile.format, \".gif\")\nImage.register_mime(GifImageFile.format, \"image/gif\")\n\n#\n# Uncomment the following line if you wish to use NETPBM/PBMPLUS\n# instead of the built-in \"uncompressed\" GIF encoder\n\n# Image.register_save(GifImageFile.format, _save_netpbm)\n", "src/PIL/FtexImagePlugin.py": "\"\"\"\nA Pillow loader for .ftc and .ftu files (FTEX)\nJerome Leclanche <jerome@leclan.ch>\n\nThe contents of this file are hereby released in the public domain (CC0)\nFull text of the CC0 license:\n  https://creativecommons.org/publicdomain/zero/1.0/\n\nIndependence War 2: Edge Of Chaos - Texture File Format - 16 October 2001\n\nThe textures used for 3D objects in Independence War 2: Edge Of Chaos are in a\npacked custom format called FTEX. This file format uses file extensions FTC\nand FTU.\n* FTC files are compressed textures (using standard texture compression).\n* FTU files are not compressed.\nTexture File Format\nThe FTC and FTU texture files both use the same format. This\nhas the following structure:\n{header}\n{format_directory}\n{data}\nWhere:\n{header} = {\n    u32:magic,\n    u32:version,\n    u32:width,\n    u32:height,\n    u32:mipmap_count,\n    u32:format_count\n}\n\n* The \"magic\" number is \"FTEX\".\n* \"width\" and \"height\" are the dimensions of the texture.\n* \"mipmap_count\" is the number of mipmaps in the texture.\n* \"format_count\" is the number of texture formats (different versions of the\nsame texture) in this file.\n\n{format_directory} = format_count * { u32:format, u32:where }\n\nThe format value is 0 for DXT1 compressed textures and 1 for 24-bit RGB\nuncompressed textures.\nThe texture data for a format starts at the position \"where\" in the file.\n\nEach set of texture data in the file has the following structure:\n{data} = format_count * { u32:mipmap_size, mipmap_size * { u8 } }\n* \"mipmap_size\" is the number of bytes in that mip level. For compressed\ntextures this is the size of the texture data compressed with DXT1. For 24 bit\nuncompressed textures, this is 3 * width * height. Following this are the image\nbytes for that mipmap level.\n\nNote: All data is stored in little-Endian (Intel) byte order.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport struct\nfrom enum import IntEnum\nfrom io import BytesIO\n\nfrom . import Image, ImageFile\n\nMAGIC = b\"FTEX\"\n\n\nclass Format(IntEnum):\n    DXT1 = 0\n    UNCOMPRESSED = 1\n\n\nclass FtexImageFile(ImageFile.ImageFile):\n    format = \"FTEX\"\n    format_description = \"Texture File Format (IW2:EOC)\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(4)):\n            msg = \"not an FTEX file\"\n            raise SyntaxError(msg)\n        struct.unpack(\"<i\", self.fp.read(4))  # version\n        self._size = struct.unpack(\"<2i\", self.fp.read(8))\n        mipmap_count, format_count = struct.unpack(\"<2i\", self.fp.read(8))\n\n        self._mode = \"RGB\"\n\n        # Only support single-format files.\n        # I don't know of any multi-format file.\n        assert format_count == 1\n\n        format, where = struct.unpack(\"<2i\", self.fp.read(8))\n        self.fp.seek(where)\n        (mipmap_size,) = struct.unpack(\"<i\", self.fp.read(4))\n\n        data = self.fp.read(mipmap_size)\n\n        if format == Format.DXT1:\n            self._mode = \"RGBA\"\n            self.tile = [(\"bcn\", (0, 0) + self.size, 0, 1)]\n        elif format == Format.UNCOMPRESSED:\n            self.tile = [(\"raw\", (0, 0) + self.size, 0, (\"RGB\", 0, 1))]\n        else:\n            msg = f\"Invalid texture compression format: {repr(format)}\"\n            raise ValueError(msg)\n\n        self.fp.close()\n        self.fp = BytesIO(data)\n\n    def load_seek(self, pos: int) -> None:\n        pass\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:4] == MAGIC\n\n\nImage.register_open(FtexImageFile.format, FtexImageFile, _accept)\nImage.register_extensions(FtexImageFile.format, [\".ftc\", \".ftu\"])\n", "src/PIL/BmpImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# BMP file handler\n#\n# Windows (and OS/2) native bitmap storage format.\n#\n# history:\n# 1995-09-01 fl   Created\n# 1996-04-30 fl   Added save\n# 1997-08-27 fl   Fixed save of 1-bit images\n# 1998-03-06 fl   Load P images as L where possible\n# 1998-07-03 fl   Load P images as 1 where possible\n# 1998-12-29 fl   Handle small palettes\n# 2002-12-30 fl   Fixed load of 1-bit palette images\n# 2003-04-21 fl   Fixed load of 1-bit monochrome images\n# 2003-04-23 fl   Added limited support for BI_BITFIELDS compression\n#\n# Copyright (c) 1997-2003 by Secret Labs AB\n# Copyright (c) 1995-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport os\nfrom typing import IO\n\nfrom . import Image, ImageFile, ImagePalette\nfrom ._binary import i16le as i16\nfrom ._binary import i32le as i32\nfrom ._binary import o8\nfrom ._binary import o16le as o16\nfrom ._binary import o32le as o32\n\n#\n# --------------------------------------------------------------------\n# Read BMP file\n\nBIT2MODE = {\n    # bits => mode, rawmode\n    1: (\"P\", \"P;1\"),\n    4: (\"P\", \"P;4\"),\n    8: (\"P\", \"P\"),\n    16: (\"RGB\", \"BGR;15\"),\n    24: (\"RGB\", \"BGR\"),\n    32: (\"RGB\", \"BGRX\"),\n}\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:2] == b\"BM\"\n\n\ndef _dib_accept(prefix: bytes) -> bool:\n    return i32(prefix) in [12, 40, 52, 56, 64, 108, 124]\n\n\n# =============================================================================\n# Image plugin for the Windows BMP format.\n# =============================================================================\nclass BmpImageFile(ImageFile.ImageFile):\n    \"\"\"Image plugin for the Windows Bitmap format (BMP)\"\"\"\n\n    # ------------------------------------------------------------- Description\n    format_description = \"Windows Bitmap\"\n    format = \"BMP\"\n\n    # -------------------------------------------------- BMP Compression values\n    COMPRESSIONS = {\"RAW\": 0, \"RLE8\": 1, \"RLE4\": 2, \"BITFIELDS\": 3, \"JPEG\": 4, \"PNG\": 5}\n    for k, v in COMPRESSIONS.items():\n        vars()[k] = v\n\n    def _bitmap(self, header=0, offset=0):\n        \"\"\"Read relevant info about the BMP\"\"\"\n        read, seek = self.fp.read, self.fp.seek\n        if header:\n            seek(header)\n        # read bmp header size @offset 14 (this is part of the header size)\n        file_info = {\"header_size\": i32(read(4)), \"direction\": -1}\n\n        # -------------------- If requested, read header at a specific position\n        # read the rest of the bmp header, without its size\n        header_data = ImageFile._safe_read(self.fp, file_info[\"header_size\"] - 4)\n\n        # ------------------------------- Windows Bitmap v2, IBM OS/2 Bitmap v1\n        # ----- This format has different offsets because of width/height types\n        # 12: BITMAPCOREHEADER/OS21XBITMAPHEADER\n        if file_info[\"header_size\"] == 12:\n            file_info[\"width\"] = i16(header_data, 0)\n            file_info[\"height\"] = i16(header_data, 2)\n            file_info[\"planes\"] = i16(header_data, 4)\n            file_info[\"bits\"] = i16(header_data, 6)\n            file_info[\"compression\"] = self.RAW\n            file_info[\"palette_padding\"] = 3\n\n        # --------------------------------------------- Windows Bitmap v3 to v5\n        #  40: BITMAPINFOHEADER\n        #  52: BITMAPV2HEADER\n        #  56: BITMAPV3HEADER\n        #  64: BITMAPCOREHEADER2/OS22XBITMAPHEADER\n        # 108: BITMAPV4HEADER\n        # 124: BITMAPV5HEADER\n        elif file_info[\"header_size\"] in (40, 52, 56, 64, 108, 124):\n            file_info[\"y_flip\"] = header_data[7] == 0xFF\n            file_info[\"direction\"] = 1 if file_info[\"y_flip\"] else -1\n            file_info[\"width\"] = i32(header_data, 0)\n            file_info[\"height\"] = (\n                i32(header_data, 4)\n                if not file_info[\"y_flip\"]\n                else 2**32 - i32(header_data, 4)\n            )\n            file_info[\"planes\"] = i16(header_data, 8)\n            file_info[\"bits\"] = i16(header_data, 10)\n            file_info[\"compression\"] = i32(header_data, 12)\n            # byte size of pixel data\n            file_info[\"data_size\"] = i32(header_data, 16)\n            file_info[\"pixels_per_meter\"] = (\n                i32(header_data, 20),\n                i32(header_data, 24),\n            )\n            file_info[\"colors\"] = i32(header_data, 28)\n            file_info[\"palette_padding\"] = 4\n            self.info[\"dpi\"] = tuple(x / 39.3701 for x in file_info[\"pixels_per_meter\"])\n            if file_info[\"compression\"] == self.BITFIELDS:\n                masks = [\"r_mask\", \"g_mask\", \"b_mask\"]\n                if len(header_data) >= 48:\n                    if len(header_data) >= 52:\n                        masks.append(\"a_mask\")\n                    else:\n                        file_info[\"a_mask\"] = 0x0\n                    for idx, mask in enumerate(masks):\n                        file_info[mask] = i32(header_data, 36 + idx * 4)\n                else:\n                    # 40 byte headers only have the three components in the\n                    # bitfields masks, ref:\n                    # https://msdn.microsoft.com/en-us/library/windows/desktop/dd183376(v=vs.85).aspx\n                    # See also\n                    # https://github.com/python-pillow/Pillow/issues/1293\n                    # There is a 4th component in the RGBQuad, in the alpha\n                    # location, but it is listed as a reserved component,\n                    # and it is not generally an alpha channel\n                    file_info[\"a_mask\"] = 0x0\n                    for mask in masks:\n                        file_info[mask] = i32(read(4))\n                file_info[\"rgb_mask\"] = (\n                    file_info[\"r_mask\"],\n                    file_info[\"g_mask\"],\n                    file_info[\"b_mask\"],\n                )\n                file_info[\"rgba_mask\"] = (\n                    file_info[\"r_mask\"],\n                    file_info[\"g_mask\"],\n                    file_info[\"b_mask\"],\n                    file_info[\"a_mask\"],\n                )\n        else:\n            msg = f\"Unsupported BMP header type ({file_info['header_size']})\"\n            raise OSError(msg)\n\n        # ------------------ Special case : header is reported 40, which\n        # ---------------------- is shorter than real size for bpp >= 16\n        self._size = file_info[\"width\"], file_info[\"height\"]\n\n        # ------- If color count was not found in the header, compute from bits\n        file_info[\"colors\"] = (\n            file_info[\"colors\"]\n            if file_info.get(\"colors\", 0)\n            else (1 << file_info[\"bits\"])\n        )\n        if offset == 14 + file_info[\"header_size\"] and file_info[\"bits\"] <= 8:\n            offset += 4 * file_info[\"colors\"]\n\n        # ---------------------- Check bit depth for unusual unsupported values\n        self._mode, raw_mode = BIT2MODE.get(file_info[\"bits\"], (None, None))\n        if self.mode is None:\n            msg = f\"Unsupported BMP pixel depth ({file_info['bits']})\"\n            raise OSError(msg)\n\n        # ---------------- Process BMP with Bitfields compression (not palette)\n        decoder_name = \"raw\"\n        if file_info[\"compression\"] == self.BITFIELDS:\n            SUPPORTED = {\n                32: [\n                    (0xFF0000, 0xFF00, 0xFF, 0x0),\n                    (0xFF000000, 0xFF0000, 0xFF00, 0x0),\n                    (0xFF000000, 0xFF00, 0xFF, 0x0),\n                    (0xFF000000, 0xFF0000, 0xFF00, 0xFF),\n                    (0xFF, 0xFF00, 0xFF0000, 0xFF000000),\n                    (0xFF0000, 0xFF00, 0xFF, 0xFF000000),\n                    (0xFF000000, 0xFF00, 0xFF, 0xFF0000),\n                    (0x0, 0x0, 0x0, 0x0),\n                ],\n                24: [(0xFF0000, 0xFF00, 0xFF)],\n                16: [(0xF800, 0x7E0, 0x1F), (0x7C00, 0x3E0, 0x1F)],\n            }\n            MASK_MODES = {\n                (32, (0xFF0000, 0xFF00, 0xFF, 0x0)): \"BGRX\",\n                (32, (0xFF000000, 0xFF0000, 0xFF00, 0x0)): \"XBGR\",\n                (32, (0xFF000000, 0xFF00, 0xFF, 0x0)): \"BGXR\",\n                (32, (0xFF000000, 0xFF0000, 0xFF00, 0xFF)): \"ABGR\",\n                (32, (0xFF, 0xFF00, 0xFF0000, 0xFF000000)): \"RGBA\",\n                (32, (0xFF0000, 0xFF00, 0xFF, 0xFF000000)): \"BGRA\",\n                (32, (0xFF000000, 0xFF00, 0xFF, 0xFF0000)): \"BGAR\",\n                (32, (0x0, 0x0, 0x0, 0x0)): \"BGRA\",\n                (24, (0xFF0000, 0xFF00, 0xFF)): \"BGR\",\n                (16, (0xF800, 0x7E0, 0x1F)): \"BGR;16\",\n                (16, (0x7C00, 0x3E0, 0x1F)): \"BGR;15\",\n            }\n            if file_info[\"bits\"] in SUPPORTED:\n                if (\n                    file_info[\"bits\"] == 32\n                    and file_info[\"rgba_mask\"] in SUPPORTED[file_info[\"bits\"]]\n                ):\n                    raw_mode = MASK_MODES[(file_info[\"bits\"], file_info[\"rgba_mask\"])]\n                    self._mode = \"RGBA\" if \"A\" in raw_mode else self.mode\n                elif (\n                    file_info[\"bits\"] in (24, 16)\n                    and file_info[\"rgb_mask\"] in SUPPORTED[file_info[\"bits\"]]\n                ):\n                    raw_mode = MASK_MODES[(file_info[\"bits\"], file_info[\"rgb_mask\"])]\n                else:\n                    msg = \"Unsupported BMP bitfields layout\"\n                    raise OSError(msg)\n            else:\n                msg = \"Unsupported BMP bitfields layout\"\n                raise OSError(msg)\n        elif file_info[\"compression\"] == self.RAW:\n            if file_info[\"bits\"] == 32 and header == 22:  # 32-bit .cur offset\n                raw_mode, self._mode = \"BGRA\", \"RGBA\"\n        elif file_info[\"compression\"] in (self.RLE8, self.RLE4):\n            decoder_name = \"bmp_rle\"\n        else:\n            msg = f\"Unsupported BMP compression ({file_info['compression']})\"\n            raise OSError(msg)\n\n        # --------------- Once the header is processed, process the palette/LUT\n        if self.mode == \"P\":  # Paletted for 1, 4 and 8 bit images\n            # ---------------------------------------------------- 1-bit images\n            if not (0 < file_info[\"colors\"] <= 65536):\n                msg = f\"Unsupported BMP Palette size ({file_info['colors']})\"\n                raise OSError(msg)\n            else:\n                padding = file_info[\"palette_padding\"]\n                palette = read(padding * file_info[\"colors\"])\n                grayscale = True\n                indices = (\n                    (0, 255)\n                    if file_info[\"colors\"] == 2\n                    else list(range(file_info[\"colors\"]))\n                )\n\n                # ----------------- Check if grayscale and ignore palette if so\n                for ind, val in enumerate(indices):\n                    rgb = palette[ind * padding : ind * padding + 3]\n                    if rgb != o8(val) * 3:\n                        grayscale = False\n\n                # ------- If all colors are gray, white or black, ditch palette\n                if grayscale:\n                    self._mode = \"1\" if file_info[\"colors\"] == 2 else \"L\"\n                    raw_mode = self.mode\n                else:\n                    self._mode = \"P\"\n                    self.palette = ImagePalette.raw(\n                        \"BGRX\" if padding == 4 else \"BGR\", palette\n                    )\n\n        # ---------------------------- Finally set the tile data for the plugin\n        self.info[\"compression\"] = file_info[\"compression\"]\n        args = [raw_mode]\n        if decoder_name == \"bmp_rle\":\n            args.append(file_info[\"compression\"] == self.RLE4)\n        else:\n            args.append(((file_info[\"width\"] * file_info[\"bits\"] + 31) >> 3) & (~3))\n        args.append(file_info[\"direction\"])\n        self.tile = [\n            (\n                decoder_name,\n                (0, 0, file_info[\"width\"], file_info[\"height\"]),\n                offset or self.fp.tell(),\n                tuple(args),\n            )\n        ]\n\n    def _open(self) -> None:\n        \"\"\"Open file, check magic number and read header\"\"\"\n        # read 14 bytes: magic number, filesize, reserved, header final offset\n        head_data = self.fp.read(14)\n        # choke if the file does not have the required magic bytes\n        if not _accept(head_data):\n            msg = \"Not a BMP file\"\n            raise SyntaxError(msg)\n        # read the start position of the BMP image data (u32)\n        offset = i32(head_data, 10)\n        # load bitmap information (offset=raster info)\n        self._bitmap(offset=offset)\n\n\nclass BmpRleDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n        rle4 = self.args[1]\n        data = bytearray()\n        x = 0\n        dest_length = self.state.xsize * self.state.ysize\n        while len(data) < dest_length:\n            pixels = self.fd.read(1)\n            byte = self.fd.read(1)\n            if not pixels or not byte:\n                break\n            num_pixels = pixels[0]\n            if num_pixels:\n                # encoded mode\n                if x + num_pixels > self.state.xsize:\n                    # Too much data for row\n                    num_pixels = max(0, self.state.xsize - x)\n                if rle4:\n                    first_pixel = o8(byte[0] >> 4)\n                    second_pixel = o8(byte[0] & 0x0F)\n                    for index in range(num_pixels):\n                        if index % 2 == 0:\n                            data += first_pixel\n                        else:\n                            data += second_pixel\n                else:\n                    data += byte * num_pixels\n                x += num_pixels\n            else:\n                if byte[0] == 0:\n                    # end of line\n                    while len(data) % self.state.xsize != 0:\n                        data += b\"\\x00\"\n                    x = 0\n                elif byte[0] == 1:\n                    # end of bitmap\n                    break\n                elif byte[0] == 2:\n                    # delta\n                    bytes_read = self.fd.read(2)\n                    if len(bytes_read) < 2:\n                        break\n                    right, up = self.fd.read(2)\n                    data += b\"\\x00\" * (right + up * self.state.xsize)\n                    x = len(data) % self.state.xsize\n                else:\n                    # absolute mode\n                    if rle4:\n                        # 2 pixels per byte\n                        byte_count = byte[0] // 2\n                        bytes_read = self.fd.read(byte_count)\n                        for byte_read in bytes_read:\n                            data += o8(byte_read >> 4)\n                            data += o8(byte_read & 0x0F)\n                    else:\n                        byte_count = byte[0]\n                        bytes_read = self.fd.read(byte_count)\n                        data += bytes_read\n                    if len(bytes_read) < byte_count:\n                        break\n                    x += byte[0]\n\n                    # align to 16-bit word boundary\n                    if self.fd.tell() % 2 != 0:\n                        self.fd.seek(1, os.SEEK_CUR)\n        rawmode = \"L\" if self.mode == \"L\" else \"P\"\n        self.set_as_raw(bytes(data), (rawmode, 0, self.args[-1]))\n        return -1, 0\n\n\n# =============================================================================\n# Image plugin for the DIB format (BMP alias)\n# =============================================================================\nclass DibImageFile(BmpImageFile):\n    format = \"DIB\"\n    format_description = \"Windows Bitmap\"\n\n    def _open(self) -> None:\n        self._bitmap()\n\n\n#\n# --------------------------------------------------------------------\n# Write BMP file\n\n\nSAVE = {\n    \"1\": (\"1\", 1, 2),\n    \"L\": (\"L\", 8, 256),\n    \"P\": (\"P\", 8, 256),\n    \"RGB\": (\"BGR\", 24, 0),\n    \"RGBA\": (\"BGRA\", 32, 0),\n}\n\n\ndef _dib_save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, False)\n\n\ndef _save(\n    im: Image.Image, fp: IO[bytes], filename: str | bytes, bitmap_header: bool = True\n) -> None:\n    try:\n        rawmode, bits, colors = SAVE[im.mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {im.mode} as BMP\"\n        raise OSError(msg) from e\n\n    info = im.encoderinfo\n\n    dpi = info.get(\"dpi\", (96, 96))\n\n    # 1 meter == 39.3701 inches\n    ppm = tuple(int(x * 39.3701 + 0.5) for x in dpi)\n\n    stride = ((im.size[0] * bits + 7) // 8 + 3) & (~3)\n    header = 40  # or 64 for OS/2 version 2\n    image = stride * im.size[1]\n\n    if im.mode == \"1\":\n        palette = b\"\".join(o8(i) * 4 for i in (0, 255))\n    elif im.mode == \"L\":\n        palette = b\"\".join(o8(i) * 4 for i in range(256))\n    elif im.mode == \"P\":\n        palette = im.im.getpalette(\"RGB\", \"BGRX\")\n        colors = len(palette) // 4\n    else:\n        palette = None\n\n    # bitmap header\n    if bitmap_header:\n        offset = 14 + header + colors * 4\n        file_size = offset + image\n        if file_size > 2**32 - 1:\n            msg = \"File size is too large for the BMP format\"\n            raise ValueError(msg)\n        fp.write(\n            b\"BM\"  # file type (magic)\n            + o32(file_size)  # file size\n            + o32(0)  # reserved\n            + o32(offset)  # image data offset\n        )\n\n    # bitmap info header\n    fp.write(\n        o32(header)  # info header size\n        + o32(im.size[0])  # width\n        + o32(im.size[1])  # height\n        + o16(1)  # planes\n        + o16(bits)  # depth\n        + o32(0)  # compression (0=uncompressed)\n        + o32(image)  # size of bitmap\n        + o32(ppm[0])  # resolution\n        + o32(ppm[1])  # resolution\n        + o32(colors)  # colors used\n        + o32(colors)  # colors important\n    )\n\n    fp.write(b\"\\0\" * (header - 40))  # padding (for OS/2 format)\n\n    if palette:\n        fp.write(palette)\n\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, stride, -1))])\n\n\n#\n# --------------------------------------------------------------------\n# Registry\n\n\nImage.register_open(BmpImageFile.format, BmpImageFile, _accept)\nImage.register_save(BmpImageFile.format, _save)\n\nImage.register_extension(BmpImageFile.format, \".bmp\")\n\nImage.register_mime(BmpImageFile.format, \"image/bmp\")\n\nImage.register_decoder(\"bmp_rle\", BmpRleDecoder)\n\nImage.register_open(DibImageFile.format, DibImageFile, _dib_accept)\nImage.register_save(DibImageFile.format, _dib_save)\n\nImage.register_extension(DibImageFile.format, \".dib\")\n\nImage.register_mime(DibImageFile.format, \"image/bmp\")\n", "src/PIL/_version.py": "# Master version for Pillow\nfrom __future__ import annotations\n\n__version__ = \"10.4.0.dev0\"\n", "src/PIL/PyAccess.py": "#\n# The Python Imaging Library\n# Pillow fork\n#\n# Python implementation of the PixelAccess Object\n#\n# Copyright (c) 1997-2009 by Secret Labs AB.  All rights reserved.\n# Copyright (c) 1995-2009 by Fredrik Lundh.\n# Copyright (c) 2013 Eric Soroos\n#\n# See the README file for information on usage and redistribution\n#\n\n# Notes:\n#\n#  * Implements the pixel access object following Access.c\n#  * Taking only the tuple form, which is used from python.\n#    * Fill.c uses the integer form, but it's still going to use the old\n#      Access.c implementation.\n#\nfrom __future__ import annotations\n\nimport logging\nimport sys\nfrom typing import TYPE_CHECKING\n\nfrom ._deprecate import deprecate\n\nFFI: type\ntry:\n    from cffi import FFI\n\n    defs = \"\"\"\n    struct Pixel_RGBA {\n        unsigned char r,g,b,a;\n    };\n    struct Pixel_I16 {\n        unsigned char l,r;\n    };\n    \"\"\"\n    ffi = FFI()\n    ffi.cdef(defs)\nexcept ImportError as ex:\n    # Allow error import for doc purposes, but error out when accessing\n    # anything in core.\n    from ._util import DeferredError\n\n    FFI = ffi = DeferredError.new(ex)\n\nlogger = logging.getLogger(__name__)\n\nif TYPE_CHECKING:\n    from . import Image\n\n\nclass PyAccess:\n    def __init__(self, img: Image.Image, readonly: bool = False) -> None:\n        deprecate(\"PyAccess\", 11)\n        vals = dict(img.im.unsafe_ptrs)\n        self.readonly = readonly\n        self.image8 = ffi.cast(\"unsigned char **\", vals[\"image8\"])\n        self.image32 = ffi.cast(\"int **\", vals[\"image32\"])\n        self.image = ffi.cast(\"unsigned char **\", vals[\"image\"])\n        self.xsize, self.ysize = img.im.size\n        self._img = img\n\n        # Keep pointer to im object to prevent dereferencing.\n        self._im = img.im\n        if self._im.mode in (\"P\", \"PA\"):\n            self._palette = img.palette\n\n        # Debugging is polluting test traces, only useful here\n        # when hacking on PyAccess\n        # logger.debug(\"%s\", vals)\n        self._post_init()\n\n    def _post_init(self) -> None:\n        pass\n\n    def __setitem__(self, xy, color):\n        \"\"\"\n        Modifies the pixel at x,y. The color is given as a single\n        numerical value for single band images, and a tuple for\n        multi-band images. In addition to this, RGB and RGBA tuples\n        are accepted for P and PA images.\n\n        :param xy: The pixel coordinate, given as (x, y). See\n           :ref:`coordinate-system`.\n        :param color: The pixel value.\n        \"\"\"\n        if self.readonly:\n            msg = \"Attempt to putpixel a read only image\"\n            raise ValueError(msg)\n        (x, y) = xy\n        if x < 0:\n            x = self.xsize + x\n        if y < 0:\n            y = self.ysize + y\n        (x, y) = self.check_xy((x, y))\n\n        if (\n            self._im.mode in (\"P\", \"PA\")\n            and isinstance(color, (list, tuple))\n            and len(color) in [3, 4]\n        ):\n            # RGB or RGBA value for a P or PA image\n            if self._im.mode == \"PA\":\n                alpha = color[3] if len(color) == 4 else 255\n                color = color[:3]\n            color = self._palette.getcolor(color, self._img)\n            if self._im.mode == \"PA\":\n                color = (color, alpha)\n\n        return self.set_pixel(x, y, color)\n\n    def __getitem__(self, xy: tuple[int, int]) -> float | tuple[int, ...]:\n        \"\"\"\n        Returns the pixel at x,y. The pixel is returned as a single\n        value for single band images or a tuple for multiple band\n        images\n\n        :param xy: The pixel coordinate, given as (x, y). See\n          :ref:`coordinate-system`.\n        :returns: a pixel value for single band images, a tuple of\n          pixel values for multiband images.\n        \"\"\"\n        (x, y) = xy\n        if x < 0:\n            x = self.xsize + x\n        if y < 0:\n            y = self.ysize + y\n        (x, y) = self.check_xy((x, y))\n        return self.get_pixel(x, y)\n\n    putpixel = __setitem__\n    getpixel = __getitem__\n\n    def check_xy(self, xy: tuple[int, int]) -> tuple[int, int]:\n        (x, y) = xy\n        if not (0 <= x < self.xsize and 0 <= y < self.ysize):\n            msg = \"pixel location out of range\"\n            raise ValueError(msg)\n        return xy\n\n    def get_pixel(self, x: int, y: int) -> float | tuple[int, ...]:\n        raise NotImplementedError()\n\n    def set_pixel(self, x: int, y: int, color: float | tuple[int, ...]) -> None:\n        raise NotImplementedError()\n\n\nclass _PyAccess32_2(PyAccess):\n    \"\"\"PA, LA, stored in first and last bytes of a 32 bit word\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> tuple[int, int]:\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.a\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple\n        pixel.r = min(color[0], 255)\n        pixel.a = min(color[1], 255)\n\n\nclass _PyAccess32_3(PyAccess):\n    \"\"\"RGB and friends, stored in the first three bytes of a 32 bit word\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> tuple[int, int, int]:\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.g, pixel.b\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple\n        pixel.r = min(color[0], 255)\n        pixel.g = min(color[1], 255)\n        pixel.b = min(color[2], 255)\n        pixel.a = 255\n\n\nclass _PyAccess32_4(PyAccess):\n    \"\"\"RGBA etc, all 4 bytes of a 32 bit word\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_RGBA **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> tuple[int, int, int, int]:\n        pixel = self.pixels[y][x]\n        return pixel.r, pixel.g, pixel.b, pixel.a\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        # tuple\n        pixel.r = min(color[0], 255)\n        pixel.g = min(color[1], 255)\n        pixel.b = min(color[2], 255)\n        pixel.a = min(color[3], 255)\n\n\nclass _PyAccess8(PyAccess):\n    \"\"\"1, L, P, 8 bit images stored as uint8\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image8\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 255)\n        except TypeError:\n            # tuple\n            self.pixels[y][x] = min(color[0], 255)\n\n\nclass _PyAccessI16_N(PyAccess):\n    \"\"\"I;16 access, native bitendian without conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"unsigned short **\", self.image)\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        try:\n            # integer\n            self.pixels[y][x] = min(color, 65535)\n        except TypeError:\n            # tuple\n            self.pixels[y][x] = min(color[0], 65535)\n\n\nclass _PyAccessI16_L(PyAccess):\n    \"\"\"I;16L access, with conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n\n    def get_pixel(self, x: int, y: int) -> int:\n        pixel = self.pixels[y][x]\n        return pixel.l + pixel.r * 256\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:\n            color = min(color, 65535)\n        except TypeError:\n            color = min(color[0], 65535)\n\n        pixel.l = color & 0xFF\n        pixel.r = color >> 8\n\n\nclass _PyAccessI16_B(PyAccess):\n    \"\"\"I;16B access, with conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"struct Pixel_I16 **\", self.image)\n\n    def get_pixel(self, x: int, y: int) -> int:\n        pixel = self.pixels[y][x]\n        return pixel.l * 256 + pixel.r\n\n    def set_pixel(self, x, y, color):\n        pixel = self.pixels[y][x]\n        try:\n            color = min(color, 65535)\n        except Exception:\n            color = min(color[0], 65535)\n\n        pixel.l = color >> 8\n        pixel.r = color & 0xFF\n\n\nclass _PyAccessI32_N(PyAccess):\n    \"\"\"Signed Int32 access, native endian\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        self.pixels[y][x] = color\n\n\nclass _PyAccessI32_Swap(PyAccess):\n    \"\"\"I;32L/B access, with byteswapping conversion\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = self.image32\n\n    def reverse(self, i):\n        orig = ffi.new(\"int *\", i)\n        chars = ffi.cast(\"unsigned char *\", orig)\n        chars[0], chars[1], chars[2], chars[3] = chars[3], chars[2], chars[1], chars[0]\n        return ffi.cast(\"int *\", chars)[0]\n\n    def get_pixel(self, x: int, y: int) -> int:\n        return self.reverse(self.pixels[y][x])\n\n    def set_pixel(self, x, y, color):\n        self.pixels[y][x] = self.reverse(color)\n\n\nclass _PyAccessF(PyAccess):\n    \"\"\"32 bit float access\"\"\"\n\n    def _post_init(self, *args, **kwargs):\n        self.pixels = ffi.cast(\"float **\", self.image32)\n\n    def get_pixel(self, x: int, y: int) -> float:\n        return self.pixels[y][x]\n\n    def set_pixel(self, x, y, color):\n        try:\n            # not a tuple\n            self.pixels[y][x] = color\n        except TypeError:\n            # tuple\n            self.pixels[y][x] = color[0]\n\n\nmode_map = {\n    \"1\": _PyAccess8,\n    \"L\": _PyAccess8,\n    \"P\": _PyAccess8,\n    \"I;16N\": _PyAccessI16_N,\n    \"LA\": _PyAccess32_2,\n    \"La\": _PyAccess32_2,\n    \"PA\": _PyAccess32_2,\n    \"RGB\": _PyAccess32_3,\n    \"LAB\": _PyAccess32_3,\n    \"HSV\": _PyAccess32_3,\n    \"YCbCr\": _PyAccess32_3,\n    \"RGBA\": _PyAccess32_4,\n    \"RGBa\": _PyAccess32_4,\n    \"RGBX\": _PyAccess32_4,\n    \"CMYK\": _PyAccess32_4,\n    \"F\": _PyAccessF,\n    \"I\": _PyAccessI32_N,\n}\n\nif sys.byteorder == \"little\":\n    mode_map[\"I;16\"] = _PyAccessI16_N\n    mode_map[\"I;16L\"] = _PyAccessI16_N\n    mode_map[\"I;16B\"] = _PyAccessI16_B\n\n    mode_map[\"I;32L\"] = _PyAccessI32_N\n    mode_map[\"I;32B\"] = _PyAccessI32_Swap\nelse:\n    mode_map[\"I;16\"] = _PyAccessI16_L\n    mode_map[\"I;16L\"] = _PyAccessI16_L\n    mode_map[\"I;16B\"] = _PyAccessI16_N\n\n    mode_map[\"I;32L\"] = _PyAccessI32_Swap\n    mode_map[\"I;32B\"] = _PyAccessI32_N\n\n\ndef new(img: Image.Image, readonly: bool = False) -> PyAccess | None:\n    access_type = mode_map.get(img.mode, None)\n    if not access_type:\n        logger.debug(\"PyAccess Not Implemented: %s\", img.mode)\n        return None\n    return access_type(img, readonly)\n", "src/PIL/PpmImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PPM support for PIL\n#\n# History:\n#       96-03-24 fl     Created\n#       98-03-06 fl     Write RGBA images (as RGB, that is)\n#\n# Copyright (c) Secret Labs AB 1997-98.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport math\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16be as i16\nfrom ._binary import o8\nfrom ._binary import o32le as o32\n\n#\n# --------------------------------------------------------------------\n\nb_whitespace = b\"\\x20\\x09\\x0a\\x0b\\x0c\\x0d\"\n\nMODES = {\n    # standard\n    b\"P1\": \"1\",\n    b\"P2\": \"L\",\n    b\"P3\": \"RGB\",\n    b\"P4\": \"1\",\n    b\"P5\": \"L\",\n    b\"P6\": \"RGB\",\n    # extensions\n    b\"P0CMYK\": \"CMYK\",\n    b\"Pf\": \"F\",\n    # PIL extensions (for test purposes only)\n    b\"PyP\": \"P\",\n    b\"PyRGBA\": \"RGBA\",\n    b\"PyCMYK\": \"CMYK\",\n}\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[0:1] == b\"P\" and prefix[1] in b\"0123456fy\"\n\n\n##\n# Image plugin for PBM, PGM, and PPM images.\n\n\nclass PpmImageFile(ImageFile.ImageFile):\n    format = \"PPM\"\n    format_description = \"Pbmplus image\"\n\n    def _read_magic(self) -> bytes:\n        assert self.fp is not None\n\n        magic = b\"\"\n        # read until whitespace or longest available magic number\n        for _ in range(6):\n            c = self.fp.read(1)\n            if not c or c in b_whitespace:\n                break\n            magic += c\n        return magic\n\n    def _read_token(self) -> bytes:\n        assert self.fp is not None\n\n        token = b\"\"\n        while len(token) <= 10:  # read until next whitespace or limit of 10 characters\n            c = self.fp.read(1)\n            if not c:\n                break\n            elif c in b_whitespace:  # token ended\n                if not token:\n                    # skip whitespace at start\n                    continue\n                break\n            elif c == b\"#\":\n                # ignores rest of the line; stops at CR, LF or EOF\n                while self.fp.read(1) not in b\"\\r\\n\":\n                    pass\n                continue\n            token += c\n        if not token:\n            # Token was not even 1 byte\n            msg = \"Reached EOF while reading header\"\n            raise ValueError(msg)\n        elif len(token) > 10:\n            msg = f\"Token too long in file header: {token.decode()}\"\n            raise ValueError(msg)\n        return token\n\n    def _open(self) -> None:\n        assert self.fp is not None\n\n        magic_number = self._read_magic()\n        try:\n            mode = MODES[magic_number]\n        except KeyError:\n            msg = \"not a PPM file\"\n            raise SyntaxError(msg)\n        self._mode = mode\n\n        if magic_number in (b\"P1\", b\"P4\"):\n            self.custom_mimetype = \"image/x-portable-bitmap\"\n        elif magic_number in (b\"P2\", b\"P5\"):\n            self.custom_mimetype = \"image/x-portable-graymap\"\n        elif magic_number in (b\"P3\", b\"P6\"):\n            self.custom_mimetype = \"image/x-portable-pixmap\"\n\n        self._size = int(self._read_token()), int(self._read_token())\n\n        decoder_name = \"raw\"\n        if magic_number in (b\"P1\", b\"P2\", b\"P3\"):\n            decoder_name = \"ppm_plain\"\n\n        args: str | tuple[str | int, ...]\n        if mode == \"1\":\n            args = \"1;I\"\n        elif mode == \"F\":\n            scale = float(self._read_token())\n            if scale == 0.0 or not math.isfinite(scale):\n                msg = \"scale must be finite and non-zero\"\n                raise ValueError(msg)\n            self.info[\"scale\"] = abs(scale)\n\n            rawmode = \"F;32F\" if scale < 0 else \"F;32BF\"\n            args = (rawmode, 0, -1)\n        else:\n            maxval = int(self._read_token())\n            if not 0 < maxval < 65536:\n                msg = \"maxval must be greater than 0 and less than 65536\"\n                raise ValueError(msg)\n            if maxval > 255 and mode == \"L\":\n                self._mode = \"I\"\n\n            rawmode = mode\n            if decoder_name != \"ppm_plain\":\n                # If maxval matches a bit depth, use the raw decoder directly\n                if maxval == 65535 and mode == \"L\":\n                    rawmode = \"I;16B\"\n                elif maxval != 255:\n                    decoder_name = \"ppm\"\n\n            args = rawmode if decoder_name == \"raw\" else (rawmode, maxval)\n        self.tile = [(decoder_name, (0, 0) + self.size, self.fp.tell(), args)]\n\n\n#\n# --------------------------------------------------------------------\n\n\nclass PpmPlainDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n    _comment_spans: bool\n\n    def _read_block(self) -> bytes:\n        assert self.fd is not None\n\n        return self.fd.read(ImageFile.SAFEBLOCK)\n\n    def _find_comment_end(self, block: bytes, start: int = 0) -> int:\n        a = block.find(b\"\\n\", start)\n        b = block.find(b\"\\r\", start)\n        return min(a, b) if a * b > 0 else max(a, b)  # lowest nonnegative index (or -1)\n\n    def _ignore_comments(self, block: bytes) -> bytes:\n        if self._comment_spans:\n            # Finish current comment\n            while block:\n                comment_end = self._find_comment_end(block)\n                if comment_end != -1:\n                    # Comment ends in this block\n                    # Delete tail of comment\n                    block = block[comment_end + 1 :]\n                    break\n                else:\n                    # Comment spans whole block\n                    # So read the next block, looking for the end\n                    block = self._read_block()\n\n        # Search for any further comments\n        self._comment_spans = False\n        while True:\n            comment_start = block.find(b\"#\")\n            if comment_start == -1:\n                # No comment found\n                break\n            comment_end = self._find_comment_end(block, comment_start)\n            if comment_end != -1:\n                # Comment ends in this block\n                # Delete comment\n                block = block[:comment_start] + block[comment_end + 1 :]\n            else:\n                # Comment continues to next block(s)\n                block = block[:comment_start]\n                self._comment_spans = True\n                break\n        return block\n\n    def _decode_bitonal(self) -> bytearray:\n        \"\"\"\n        This is a separate method because in the plain PBM format, all data tokens are\n        exactly one byte, so the inter-token whitespace is optional.\n        \"\"\"\n        data = bytearray()\n        total_bytes = self.state.xsize * self.state.ysize\n\n        while len(data) != total_bytes:\n            block = self._read_block()  # read next block\n            if not block:\n                # eof\n                break\n\n            block = self._ignore_comments(block)\n\n            tokens = b\"\".join(block.split())\n            for token in tokens:\n                if token not in (48, 49):\n                    msg = b\"Invalid token for this mode: %s\" % bytes([token])\n                    raise ValueError(msg)\n            data = (data + tokens)[:total_bytes]\n        invert = bytes.maketrans(b\"01\", b\"\\xFF\\x00\")\n        return data.translate(invert)\n\n    def _decode_blocks(self, maxval: int) -> bytearray:\n        data = bytearray()\n        max_len = 10\n        out_byte_count = 4 if self.mode == \"I\" else 1\n        out_max = 65535 if self.mode == \"I\" else 255\n        bands = Image.getmodebands(self.mode)\n        total_bytes = self.state.xsize * self.state.ysize * bands * out_byte_count\n\n        half_token = b\"\"\n        while len(data) != total_bytes:\n            block = self._read_block()  # read next block\n            if not block:\n                if half_token:\n                    block = bytearray(b\" \")  # flush half_token\n                else:\n                    # eof\n                    break\n\n            block = self._ignore_comments(block)\n\n            if half_token:\n                block = half_token + block  # stitch half_token to new block\n                half_token = b\"\"\n\n            tokens = block.split()\n\n            if block and not block[-1:].isspace():  # block might split token\n                half_token = tokens.pop()  # save half token for later\n                if len(half_token) > max_len:  # prevent buildup of half_token\n                    msg = (\n                        b\"Token too long found in data: %s\" % half_token[: max_len + 1]\n                    )\n                    raise ValueError(msg)\n\n            for token in tokens:\n                if len(token) > max_len:\n                    msg = b\"Token too long found in data: %s\" % token[: max_len + 1]\n                    raise ValueError(msg)\n                value = int(token)\n                if value < 0:\n                    msg_str = f\"Channel value is negative: {value}\"\n                    raise ValueError(msg_str)\n                if value > maxval:\n                    msg_str = f\"Channel value too large for this mode: {value}\"\n                    raise ValueError(msg_str)\n                value = round(value / maxval * out_max)\n                data += o32(value) if self.mode == \"I\" else o8(value)\n                if len(data) == total_bytes:  # finished!\n                    break\n        return data\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        self._comment_spans = False\n        if self.mode == \"1\":\n            data = self._decode_bitonal()\n            rawmode = \"1;8\"\n        else:\n            maxval = self.args[-1]\n            data = self._decode_blocks(maxval)\n            rawmode = \"I;32\" if self.mode == \"I\" else self.mode\n        self.set_as_raw(bytes(data), rawmode)\n        return -1, 0\n\n\nclass PpmDecoder(ImageFile.PyDecoder):\n    _pulls_fd = True\n\n    def decode(self, buffer: bytes) -> tuple[int, int]:\n        assert self.fd is not None\n\n        data = bytearray()\n        maxval = self.args[-1]\n        in_byte_count = 1 if maxval < 256 else 2\n        out_byte_count = 4 if self.mode == \"I\" else 1\n        out_max = 65535 if self.mode == \"I\" else 255\n        bands = Image.getmodebands(self.mode)\n        dest_length = self.state.xsize * self.state.ysize * bands * out_byte_count\n        while len(data) < dest_length:\n            pixels = self.fd.read(in_byte_count * bands)\n            if len(pixels) < in_byte_count * bands:\n                # eof\n                break\n            for b in range(bands):\n                value = (\n                    pixels[b] if in_byte_count == 1 else i16(pixels, b * in_byte_count)\n                )\n                value = min(out_max, round(value / maxval * out_max))\n                data += o32(value) if self.mode == \"I\" else o8(value)\n        rawmode = \"I;32\" if self.mode == \"I\" else self.mode\n        self.set_as_raw(bytes(data), rawmode)\n        return -1, 0\n\n\n#\n# --------------------------------------------------------------------\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if im.mode == \"1\":\n        rawmode, head = \"1;I\", b\"P4\"\n    elif im.mode == \"L\":\n        rawmode, head = \"L\", b\"P5\"\n    elif im.mode == \"I\":\n        rawmode, head = \"I;16B\", b\"P5\"\n    elif im.mode in (\"RGB\", \"RGBA\"):\n        rawmode, head = \"RGB\", b\"P6\"\n    elif im.mode == \"F\":\n        rawmode, head = \"F;32F\", b\"Pf\"\n    else:\n        msg = f\"cannot write mode {im.mode} as PPM\"\n        raise OSError(msg)\n    fp.write(head + b\"\\n%d %d\\n\" % im.size)\n    if head == b\"P6\":\n        fp.write(b\"255\\n\")\n    elif head == b\"P5\":\n        if rawmode == \"L\":\n            fp.write(b\"255\\n\")\n        else:\n            fp.write(b\"65535\\n\")\n    elif head == b\"Pf\":\n        fp.write(b\"-1.0\\n\")\n    row_order = -1 if im.mode == \"F\" else 1\n    ImageFile._save(im, fp, [(\"raw\", (0, 0) + im.size, 0, (rawmode, 0, row_order))])\n\n\n#\n# --------------------------------------------------------------------\n\n\nImage.register_open(PpmImageFile.format, PpmImageFile, _accept)\nImage.register_save(PpmImageFile.format, _save)\n\nImage.register_decoder(\"ppm\", PpmDecoder)\nImage.register_decoder(\"ppm_plain\", PpmPlainDecoder)\n\nImage.register_extensions(PpmImageFile.format, [\".pbm\", \".pgm\", \".ppm\", \".pnm\", \".pfm\"])\n\nImage.register_mime(PpmImageFile.format, \"image/x-portable-anymap\")\n", "src/PIL/PngImagePlugin.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PNG support code\n#\n# See \"PNG (Portable Network Graphics) Specification, version 1.0;\n# W3C Recommendation\", 1996-10-01, Thomas Boutell (ed.).\n#\n# history:\n# 1996-05-06 fl   Created (couldn't resist it)\n# 1996-12-14 fl   Upgraded, added read and verify support (0.2)\n# 1996-12-15 fl   Separate PNG stream parser\n# 1996-12-29 fl   Added write support, added getchunks\n# 1996-12-30 fl   Eliminated circular references in decoder (0.3)\n# 1998-07-12 fl   Read/write 16-bit images as mode I (0.4)\n# 2001-02-08 fl   Added transparency support (from Zircon) (0.5)\n# 2001-04-16 fl   Don't close data source in \"open\" method (0.6)\n# 2004-02-24 fl   Don't even pretend to support interlaced files (0.7)\n# 2004-08-31 fl   Do basic sanity check on chunk identifiers (0.8)\n# 2004-09-20 fl   Added PngInfo chunk container\n# 2004-12-18 fl   Added DPI read support (based on code by Niki Spahiev)\n# 2008-08-13 fl   Added tRNS support for RGB images\n# 2009-03-06 fl   Support for preserving ICC profiles (by Florian Hoech)\n# 2009-03-08 fl   Added zTXT support (from Lowell Alleman)\n# 2009-03-29 fl   Read interlaced PNG files (from Conrado Porto Lopes Gouvua)\n#\n# Copyright (c) 1997-2009 by Secret Labs AB\n# Copyright (c) 1996 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport itertools\nimport logging\nimport re\nimport struct\nimport warnings\nimport zlib\nfrom enum import IntEnum\nfrom typing import IO, TYPE_CHECKING, Any, NoReturn\n\nfrom . import Image, ImageChops, ImageFile, ImagePalette, ImageSequence\nfrom ._binary import i16be as i16\nfrom ._binary import i32be as i32\nfrom ._binary import o8\nfrom ._binary import o16be as o16\nfrom ._binary import o32be as o32\n\nif TYPE_CHECKING:\n    from . import _imaging\n\nlogger = logging.getLogger(__name__)\n\nis_cid = re.compile(rb\"\\w\\w\\w\\w\").match\n\n\n_MAGIC = b\"\\211PNG\\r\\n\\032\\n\"\n\n\n_MODES = {\n    # supported bits/color combinations, and corresponding modes/rawmodes\n    # Grayscale\n    (1, 0): (\"1\", \"1\"),\n    (2, 0): (\"L\", \"L;2\"),\n    (4, 0): (\"L\", \"L;4\"),\n    (8, 0): (\"L\", \"L\"),\n    (16, 0): (\"I;16\", \"I;16B\"),\n    # Truecolour\n    (8, 2): (\"RGB\", \"RGB\"),\n    (16, 2): (\"RGB\", \"RGB;16B\"),\n    # Indexed-colour\n    (1, 3): (\"P\", \"P;1\"),\n    (2, 3): (\"P\", \"P;2\"),\n    (4, 3): (\"P\", \"P;4\"),\n    (8, 3): (\"P\", \"P\"),\n    # Grayscale with alpha\n    (8, 4): (\"LA\", \"LA\"),\n    (16, 4): (\"RGBA\", \"LA;16B\"),  # LA;16B->LA not yet available\n    # Truecolour with alpha\n    (8, 6): (\"RGBA\", \"RGBA\"),\n    (16, 6): (\"RGBA\", \"RGBA;16B\"),\n}\n\n\n_simple_palette = re.compile(b\"^\\xff*\\x00\\xff*$\")\n\nMAX_TEXT_CHUNK = ImageFile.SAFEBLOCK\n\"\"\"\nMaximum decompressed size for a iTXt or zTXt chunk.\nEliminates decompression bombs where compressed chunks can expand 1000x.\nSee :ref:`Text in PNG File Format<png-text>`.\n\"\"\"\nMAX_TEXT_MEMORY = 64 * MAX_TEXT_CHUNK\n\"\"\"\nSet the maximum total text chunk size.\nSee :ref:`Text in PNG File Format<png-text>`.\n\"\"\"\n\n\n# APNG frame disposal modes\nclass Disposal(IntEnum):\n    OP_NONE = 0\n    \"\"\"\n    No disposal is done on this frame before rendering the next frame.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_BACKGROUND = 1\n    \"\"\"\n    This frame\u2019s modified region is cleared to fully transparent black before rendering\n    the next frame.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_PREVIOUS = 2\n    \"\"\"\n    This frame\u2019s modified region is reverted to the previous frame\u2019s contents before\n    rendering the next frame.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n\n\n# APNG frame blend modes\nclass Blend(IntEnum):\n    OP_SOURCE = 0\n    \"\"\"\n    All color components of this frame, including alpha, overwrite the previous output\n    image contents.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n    OP_OVER = 1\n    \"\"\"\n    This frame should be alpha composited with the previous output image contents.\n    See :ref:`Saving APNG sequences<apng-saving>`.\n    \"\"\"\n\n\ndef _safe_zlib_decompress(s):\n    dobj = zlib.decompressobj()\n    plaintext = dobj.decompress(s, MAX_TEXT_CHUNK)\n    if dobj.unconsumed_tail:\n        msg = \"Decompressed Data Too Large\"\n        raise ValueError(msg)\n    return plaintext\n\n\ndef _crc32(data, seed=0):\n    return zlib.crc32(data, seed) & 0xFFFFFFFF\n\n\n# --------------------------------------------------------------------\n# Support classes.  Suitable for PNG and related formats like MNG etc.\n\n\nclass ChunkStream:\n    def __init__(self, fp: IO[bytes]) -> None:\n        self.fp: IO[bytes] | None = fp\n        self.queue: list[tuple[bytes, int, int]] | None = []\n\n    def read(self) -> tuple[bytes, int, int]:\n        \"\"\"Fetch a new chunk. Returns header information.\"\"\"\n        cid = None\n\n        assert self.fp is not None\n        if self.queue:\n            cid, pos, length = self.queue.pop()\n            self.fp.seek(pos)\n        else:\n            s = self.fp.read(8)\n            cid = s[4:]\n            pos = self.fp.tell()\n            length = i32(s)\n\n        if not is_cid(cid):\n            if not ImageFile.LOAD_TRUNCATED_IMAGES:\n                msg = f\"broken PNG file (chunk {repr(cid)})\"\n                raise SyntaxError(msg)\n\n        return cid, pos, length\n\n    def __enter__(self) -> ChunkStream:\n        return self\n\n    def __exit__(self, *args: object) -> None:\n        self.close()\n\n    def close(self) -> None:\n        self.queue = self.fp = None\n\n    def push(self, cid: bytes, pos: int, length: int) -> None:\n        assert self.queue is not None\n        self.queue.append((cid, pos, length))\n\n    def call(self, cid, pos, length):\n        \"\"\"Call the appropriate chunk handler\"\"\"\n\n        logger.debug(\"STREAM %r %s %s\", cid, pos, length)\n        return getattr(self, f\"chunk_{cid.decode('ascii')}\")(pos, length)\n\n    def crc(self, cid: bytes, data: bytes) -> None:\n        \"\"\"Read and verify checksum\"\"\"\n\n        # Skip CRC checks for ancillary chunks if allowed to load truncated\n        # images\n        # 5th byte of first char is 1 [specs, section 5.4]\n        if ImageFile.LOAD_TRUNCATED_IMAGES and (cid[0] >> 5 & 1):\n            self.crc_skip(cid, data)\n            return\n\n        assert self.fp is not None\n        try:\n            crc1 = _crc32(data, _crc32(cid))\n            crc2 = i32(self.fp.read(4))\n            if crc1 != crc2:\n                msg = f\"broken PNG file (bad header checksum in {repr(cid)})\"\n                raise SyntaxError(msg)\n        except struct.error as e:\n            msg = f\"broken PNG file (incomplete checksum in {repr(cid)})\"\n            raise SyntaxError(msg) from e\n\n    def crc_skip(self, cid: bytes, data: bytes) -> None:\n        \"\"\"Read checksum\"\"\"\n\n        assert self.fp is not None\n        self.fp.read(4)\n\n    def verify(self, endchunk: bytes = b\"IEND\") -> list[bytes]:\n        # Simple approach; just calculate checksum for all remaining\n        # blocks.  Must be called directly after open.\n\n        cids = []\n\n        while True:\n            try:\n                cid, pos, length = self.read()\n            except struct.error as e:\n                msg = \"truncated PNG file\"\n                raise OSError(msg) from e\n\n            if cid == endchunk:\n                break\n            self.crc(cid, ImageFile._safe_read(self.fp, length))\n            cids.append(cid)\n\n        return cids\n\n\nclass iTXt(str):\n    \"\"\"\n    Subclass of string to allow iTXt chunks to look like strings while\n    keeping their extra information\n\n    \"\"\"\n\n    lang: str | bytes | None\n    tkey: str | bytes | None\n\n    @staticmethod\n    def __new__(cls, text, lang=None, tkey=None):\n        \"\"\"\n        :param cls: the class to use when creating the instance\n        :param text: value for this key\n        :param lang: language code\n        :param tkey: UTF-8 version of the key name\n        \"\"\"\n\n        self = str.__new__(cls, text)\n        self.lang = lang\n        self.tkey = tkey\n        return self\n\n\nclass PngInfo:\n    \"\"\"\n    PNG chunk container (for use with save(pnginfo=))\n\n    \"\"\"\n\n    def __init__(self) -> None:\n        self.chunks: list[tuple[bytes, bytes, bool]] = []\n\n    def add(self, cid: bytes, data: bytes, after_idat: bool = False) -> None:\n        \"\"\"Appends an arbitrary chunk. Use with caution.\n\n        :param cid: a byte string, 4 bytes long.\n        :param data: a byte string of the encoded data\n        :param after_idat: for use with private chunks. Whether the chunk\n                           should be written after IDAT\n\n        \"\"\"\n\n        self.chunks.append((cid, data, after_idat))\n\n    def add_itxt(\n        self,\n        key: str | bytes,\n        value: str | bytes,\n        lang: str | bytes = \"\",\n        tkey: str | bytes = \"\",\n        zip: bool = False,\n    ) -> None:\n        \"\"\"Appends an iTXt chunk.\n\n        :param key: latin-1 encodable text key name\n        :param value: value for this key\n        :param lang: language code\n        :param tkey: UTF-8 version of the key name\n        :param zip: compression flag\n\n        \"\"\"\n\n        if not isinstance(key, bytes):\n            key = key.encode(\"latin-1\", \"strict\")\n        if not isinstance(value, bytes):\n            value = value.encode(\"utf-8\", \"strict\")\n        if not isinstance(lang, bytes):\n            lang = lang.encode(\"utf-8\", \"strict\")\n        if not isinstance(tkey, bytes):\n            tkey = tkey.encode(\"utf-8\", \"strict\")\n\n        if zip:\n            self.add(\n                b\"iTXt\",\n                key + b\"\\0\\x01\\0\" + lang + b\"\\0\" + tkey + b\"\\0\" + zlib.compress(value),\n            )\n        else:\n            self.add(b\"iTXt\", key + b\"\\0\\0\\0\" + lang + b\"\\0\" + tkey + b\"\\0\" + value)\n\n    def add_text(\n        self, key: str | bytes, value: str | bytes | iTXt, zip: bool = False\n    ) -> None:\n        \"\"\"Appends a text chunk.\n\n        :param key: latin-1 encodable text key name\n        :param value: value for this key, text or an\n           :py:class:`PIL.PngImagePlugin.iTXt` instance\n        :param zip: compression flag\n\n        \"\"\"\n        if isinstance(value, iTXt):\n            return self.add_itxt(\n                key,\n                value,\n                value.lang if value.lang is not None else b\"\",\n                value.tkey if value.tkey is not None else b\"\",\n                zip=zip,\n            )\n\n        # The tEXt chunk stores latin-1 text\n        if not isinstance(value, bytes):\n            try:\n                value = value.encode(\"latin-1\", \"strict\")\n            except UnicodeError:\n                return self.add_itxt(key, value, zip=zip)\n\n        if not isinstance(key, bytes):\n            key = key.encode(\"latin-1\", \"strict\")\n\n        if zip:\n            self.add(b\"zTXt\", key + b\"\\0\\0\" + zlib.compress(value))\n        else:\n            self.add(b\"tEXt\", key + b\"\\0\" + value)\n\n\n# --------------------------------------------------------------------\n# PNG image stream (IHDR/IEND)\n\n\nclass PngStream(ChunkStream):\n    def __init__(self, fp):\n        super().__init__(fp)\n\n        # local copies of Image attributes\n        self.im_info = {}\n        self.im_text = {}\n        self.im_size = (0, 0)\n        self.im_mode = None\n        self.im_tile = None\n        self.im_palette = None\n        self.im_custom_mimetype = None\n        self.im_n_frames = None\n        self._seq_num = None\n        self.rewind_state = None\n\n        self.text_memory = 0\n\n    def check_text_memory(self, chunklen: int) -> None:\n        self.text_memory += chunklen\n        if self.text_memory > MAX_TEXT_MEMORY:\n            msg = (\n                \"Too much memory used in text chunks: \"\n                f\"{self.text_memory}>MAX_TEXT_MEMORY\"\n            )\n            raise ValueError(msg)\n\n    def save_rewind(self) -> None:\n        self.rewind_state = {\n            \"info\": self.im_info.copy(),\n            \"tile\": self.im_tile,\n            \"seq_num\": self._seq_num,\n        }\n\n    def rewind(self) -> None:\n        self.im_info = self.rewind_state[\"info\"].copy()\n        self.im_tile = self.rewind_state[\"tile\"]\n        self._seq_num = self.rewind_state[\"seq_num\"]\n\n    def chunk_iCCP(self, pos: int, length: int) -> bytes:\n        # ICC profile\n        s = ImageFile._safe_read(self.fp, length)\n        # according to PNG spec, the iCCP chunk contains:\n        # Profile name  1-79 bytes (character string)\n        # Null separator        1 byte (null character)\n        # Compression method    1 byte (0)\n        # Compressed profile    n bytes (zlib with deflate compression)\n        i = s.find(b\"\\0\")\n        logger.debug(\"iCCP profile name %r\", s[:i])\n        comp_method = s[i + 1]\n        logger.debug(\"Compression method %s\", comp_method)\n        if comp_method != 0:\n            msg = f\"Unknown compression method {comp_method} in iCCP chunk\"\n            raise SyntaxError(msg)\n        try:\n            icc_profile = _safe_zlib_decompress(s[i + 2 :])\n        except ValueError:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                icc_profile = None\n            else:\n                raise\n        except zlib.error:\n            icc_profile = None  # FIXME\n        self.im_info[\"icc_profile\"] = icc_profile\n        return s\n\n    def chunk_IHDR(self, pos: int, length: int) -> bytes:\n        # image header\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 13:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"Truncated IHDR chunk\"\n            raise ValueError(msg)\n        self.im_size = i32(s, 0), i32(s, 4)\n        try:\n            self.im_mode, self.im_rawmode = _MODES[(s[8], s[9])]\n        except Exception:\n            pass\n        if s[12]:\n            self.im_info[\"interlace\"] = 1\n        if s[11]:\n            msg = \"unknown filter category\"\n            raise SyntaxError(msg)\n        return s\n\n    def chunk_IDAT(self, pos: int, length: int) -> NoReturn:\n        # image data\n        if \"bbox\" in self.im_info:\n            tile = [(\"zip\", self.im_info[\"bbox\"], pos, self.im_rawmode)]\n        else:\n            if self.im_n_frames is not None:\n                self.im_info[\"default_image\"] = True\n            tile = [(\"zip\", (0, 0) + self.im_size, pos, self.im_rawmode)]\n        self.im_tile = tile\n        self.im_idat = length\n        msg = \"image data found\"\n        raise EOFError(msg)\n\n    def chunk_IEND(self, pos: int, length: int) -> NoReturn:\n        msg = \"end of PNG image\"\n        raise EOFError(msg)\n\n    def chunk_PLTE(self, pos: int, length: int) -> bytes:\n        # palette\n        s = ImageFile._safe_read(self.fp, length)\n        if self.im_mode == \"P\":\n            self.im_palette = \"RGB\", s\n        return s\n\n    def chunk_tRNS(self, pos: int, length: int) -> bytes:\n        # transparency\n        s = ImageFile._safe_read(self.fp, length)\n        if self.im_mode == \"P\":\n            if _simple_palette.match(s):\n                # tRNS contains only one full-transparent entry,\n                # other entries are full opaque\n                i = s.find(b\"\\0\")\n                if i >= 0:\n                    self.im_info[\"transparency\"] = i\n            else:\n                # otherwise, we have a byte string with one alpha value\n                # for each palette entry\n                self.im_info[\"transparency\"] = s\n        elif self.im_mode in (\"1\", \"L\", \"I;16\"):\n            self.im_info[\"transparency\"] = i16(s)\n        elif self.im_mode == \"RGB\":\n            self.im_info[\"transparency\"] = i16(s), i16(s, 2), i16(s, 4)\n        return s\n\n    def chunk_gAMA(self, pos: int, length: int) -> bytes:\n        # gamma setting\n        s = ImageFile._safe_read(self.fp, length)\n        self.im_info[\"gamma\"] = i32(s) / 100000.0\n        return s\n\n    def chunk_cHRM(self, pos: int, length: int) -> bytes:\n        # chromaticity, 8 unsigned ints, actual value is scaled by 100,000\n        # WP x,y, Red x,y, Green x,y Blue x,y\n\n        s = ImageFile._safe_read(self.fp, length)\n        raw_vals = struct.unpack(\">%dI\" % (len(s) // 4), s)\n        self.im_info[\"chromaticity\"] = tuple(elt / 100000.0 for elt in raw_vals)\n        return s\n\n    def chunk_sRGB(self, pos: int, length: int) -> bytes:\n        # srgb rendering intent, 1 byte\n        # 0 perceptual\n        # 1 relative colorimetric\n        # 2 saturation\n        # 3 absolute colorimetric\n\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 1:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"Truncated sRGB chunk\"\n            raise ValueError(msg)\n        self.im_info[\"srgb\"] = s[0]\n        return s\n\n    def chunk_pHYs(self, pos: int, length: int) -> bytes:\n        # pixels per unit\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 9:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"Truncated pHYs chunk\"\n            raise ValueError(msg)\n        px, py = i32(s, 0), i32(s, 4)\n        unit = s[8]\n        if unit == 1:  # meter\n            dpi = px * 0.0254, py * 0.0254\n            self.im_info[\"dpi\"] = dpi\n        elif unit == 0:\n            self.im_info[\"aspect\"] = px, py\n        return s\n\n    def chunk_tEXt(self, pos: int, length: int) -> bytes:\n        # text\n        s = ImageFile._safe_read(self.fp, length)\n        try:\n            k, v = s.split(b\"\\0\", 1)\n        except ValueError:\n            # fallback for broken tEXt tags\n            k = s\n            v = b\"\"\n        if k:\n            k = k.decode(\"latin-1\", \"strict\")\n            v_str = v.decode(\"latin-1\", \"replace\")\n\n            self.im_info[k] = v if k == \"exif\" else v_str\n            self.im_text[k] = v_str\n            self.check_text_memory(len(v_str))\n\n        return s\n\n    def chunk_zTXt(self, pos: int, length: int) -> bytes:\n        # compressed text\n        s = ImageFile._safe_read(self.fp, length)\n        try:\n            k, v = s.split(b\"\\0\", 1)\n        except ValueError:\n            k = s\n            v = b\"\"\n        if v:\n            comp_method = v[0]\n        else:\n            comp_method = 0\n        if comp_method != 0:\n            msg = f\"Unknown compression method {comp_method} in zTXt chunk\"\n            raise SyntaxError(msg)\n        try:\n            v = _safe_zlib_decompress(v[1:])\n        except ValueError:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                v = b\"\"\n            else:\n                raise\n        except zlib.error:\n            v = b\"\"\n\n        if k:\n            k = k.decode(\"latin-1\", \"strict\")\n            v = v.decode(\"latin-1\", \"replace\")\n\n            self.im_info[k] = self.im_text[k] = v\n            self.check_text_memory(len(v))\n\n        return s\n\n    def chunk_iTXt(self, pos: int, length: int) -> bytes:\n        # international text\n        r = s = ImageFile._safe_read(self.fp, length)\n        try:\n            k, r = r.split(b\"\\0\", 1)\n        except ValueError:\n            return s\n        if len(r) < 2:\n            return s\n        cf, cm, r = r[0], r[1], r[2:]\n        try:\n            lang, tk, v = r.split(b\"\\0\", 2)\n        except ValueError:\n            return s\n        if cf != 0:\n            if cm == 0:\n                try:\n                    v = _safe_zlib_decompress(v)\n                except ValueError:\n                    if ImageFile.LOAD_TRUNCATED_IMAGES:\n                        return s\n                    else:\n                        raise\n                except zlib.error:\n                    return s\n            else:\n                return s\n        if k == b\"XML:com.adobe.xmp\":\n            self.im_info[\"xmp\"] = v\n        try:\n            k = k.decode(\"latin-1\", \"strict\")\n            lang = lang.decode(\"utf-8\", \"strict\")\n            tk = tk.decode(\"utf-8\", \"strict\")\n            v = v.decode(\"utf-8\", \"strict\")\n        except UnicodeError:\n            return s\n\n        self.im_info[k] = self.im_text[k] = iTXt(v, lang, tk)\n        self.check_text_memory(len(v))\n\n        return s\n\n    def chunk_eXIf(self, pos: int, length: int) -> bytes:\n        s = ImageFile._safe_read(self.fp, length)\n        self.im_info[\"exif\"] = b\"Exif\\x00\\x00\" + s\n        return s\n\n    # APNG chunks\n    def chunk_acTL(self, pos: int, length: int) -> bytes:\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 8:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"APNG contains truncated acTL chunk\"\n            raise ValueError(msg)\n        if self.im_n_frames is not None:\n            self.im_n_frames = None\n            warnings.warn(\"Invalid APNG, will use default PNG image if possible\")\n            return s\n        n_frames = i32(s)\n        if n_frames == 0 or n_frames > 0x80000000:\n            warnings.warn(\"Invalid APNG, will use default PNG image if possible\")\n            return s\n        self.im_n_frames = n_frames\n        self.im_info[\"loop\"] = i32(s, 4)\n        self.im_custom_mimetype = \"image/apng\"\n        return s\n\n    def chunk_fcTL(self, pos: int, length: int) -> bytes:\n        s = ImageFile._safe_read(self.fp, length)\n        if length < 26:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                return s\n            msg = \"APNG contains truncated fcTL chunk\"\n            raise ValueError(msg)\n        seq = i32(s)\n        if (self._seq_num is None and seq != 0) or (\n            self._seq_num is not None and self._seq_num != seq - 1\n        ):\n            msg = \"APNG contains frame sequence errors\"\n            raise SyntaxError(msg)\n        self._seq_num = seq\n        width, height = i32(s, 4), i32(s, 8)\n        px, py = i32(s, 12), i32(s, 16)\n        im_w, im_h = self.im_size\n        if px + width > im_w or py + height > im_h:\n            msg = \"APNG contains invalid frames\"\n            raise SyntaxError(msg)\n        self.im_info[\"bbox\"] = (px, py, px + width, py + height)\n        delay_num, delay_den = i16(s, 20), i16(s, 22)\n        if delay_den == 0:\n            delay_den = 100\n        self.im_info[\"duration\"] = float(delay_num) / float(delay_den) * 1000\n        self.im_info[\"disposal\"] = s[24]\n        self.im_info[\"blend\"] = s[25]\n        return s\n\n    def chunk_fdAT(self, pos: int, length: int) -> bytes:\n        if length < 4:\n            if ImageFile.LOAD_TRUNCATED_IMAGES:\n                s = ImageFile._safe_read(self.fp, length)\n                return s\n            msg = \"APNG contains truncated fDAT chunk\"\n            raise ValueError(msg)\n        s = ImageFile._safe_read(self.fp, 4)\n        seq = i32(s)\n        if self._seq_num != seq - 1:\n            msg = \"APNG contains frame sequence errors\"\n            raise SyntaxError(msg)\n        self._seq_num = seq\n        return self.chunk_IDAT(pos + 4, length - 4)\n\n\n# --------------------------------------------------------------------\n# PNG reader\n\n\ndef _accept(prefix: bytes) -> bool:\n    return prefix[:8] == _MAGIC\n\n\n##\n# Image plugin for PNG images.\n\n\nclass PngImageFile(ImageFile.ImageFile):\n    format = \"PNG\"\n    format_description = \"Portable network graphics\"\n\n    def _open(self) -> None:\n        if not _accept(self.fp.read(8)):\n            msg = \"not a PNG file\"\n            raise SyntaxError(msg)\n        self._fp = self.fp\n        self.__frame = 0\n\n        #\n        # Parse headers up to the first IDAT or fDAT chunk\n\n        self.private_chunks: list[tuple[bytes, bytes] | tuple[bytes, bytes, bool]] = []\n        self.png: PngStream | None = PngStream(self.fp)\n\n        while True:\n            #\n            # get next chunk\n\n            cid, pos, length = self.png.read()\n\n            try:\n                s = self.png.call(cid, pos, length)\n            except EOFError:\n                break\n            except AttributeError:\n                logger.debug(\"%r %s %s (unknown)\", cid, pos, length)\n                s = ImageFile._safe_read(self.fp, length)\n                if cid[1:2].islower():\n                    self.private_chunks.append((cid, s))\n\n            self.png.crc(cid, s)\n\n        #\n        # Copy relevant attributes from the PngStream.  An alternative\n        # would be to let the PngStream class modify these attributes\n        # directly, but that introduces circular references which are\n        # difficult to break if things go wrong in the decoder...\n        # (believe me, I've tried ;-)\n\n        self._mode = self.png.im_mode\n        self._size = self.png.im_size\n        self.info = self.png.im_info\n        self._text = None\n        self.tile = self.png.im_tile\n        self.custom_mimetype = self.png.im_custom_mimetype\n        self.n_frames = self.png.im_n_frames or 1\n        self.default_image = self.info.get(\"default_image\", False)\n\n        if self.png.im_palette:\n            rawmode, data = self.png.im_palette\n            self.palette = ImagePalette.raw(rawmode, data)\n\n        if cid == b\"fdAT\":\n            self.__prepare_idat = length - 4\n        else:\n            self.__prepare_idat = length  # used by load_prepare()\n\n        if self.png.im_n_frames is not None:\n            self._close_exclusive_fp_after_loading = False\n            self.png.save_rewind()\n            self.__rewind_idat = self.__prepare_idat\n            self.__rewind = self._fp.tell()\n            if self.default_image:\n                # IDAT chunk contains default image and not first animation frame\n                self.n_frames += 1\n            self._seek(0)\n        self.is_animated = self.n_frames > 1\n\n    @property\n    def text(self):\n        # experimental\n        if self._text is None:\n            # iTxt, tEXt and zTXt chunks may appear at the end of the file\n            # So load the file to ensure that they are read\n            if self.is_animated:\n                frame = self.__frame\n                # for APNG, seek to the final frame before loading\n                self.seek(self.n_frames - 1)\n            self.load()\n            if self.is_animated:\n                self.seek(frame)\n        return self._text\n\n    def verify(self) -> None:\n        \"\"\"Verify PNG file\"\"\"\n\n        if self.fp is None:\n            msg = \"verify must be called directly after open\"\n            raise RuntimeError(msg)\n\n        # back up to beginning of IDAT block\n        self.fp.seek(self.tile[0][2] - 8)\n\n        assert self.png is not None\n        self.png.verify()\n        self.png.close()\n\n        if self._exclusive_fp:\n            self.fp.close()\n        self.fp = None\n\n    def seek(self, frame: int) -> None:\n        if not self._seek_check(frame):\n            return\n        if frame < self.__frame:\n            self._seek(0, True)\n\n        last_frame = self.__frame\n        for f in range(self.__frame + 1, frame + 1):\n            try:\n                self._seek(f)\n            except EOFError as e:\n                self.seek(last_frame)\n                msg = \"no more images in APNG file\"\n                raise EOFError(msg) from e\n\n    def _seek(self, frame: int, rewind: bool = False) -> None:\n        assert self.png is not None\n\n        self.dispose: _imaging.ImagingCore | None\n        if frame == 0:\n            if rewind:\n                self._fp.seek(self.__rewind)\n                self.png.rewind()\n                self.__prepare_idat = self.__rewind_idat\n                self.im = None\n                if self.pyaccess:\n                    self.pyaccess = None\n                self.info = self.png.im_info\n                self.tile = self.png.im_tile\n                self.fp = self._fp\n            self._prev_im = None\n            self.dispose = None\n            self.default_image = self.info.get(\"default_image\", False)\n            self.dispose_op = self.info.get(\"disposal\")\n            self.blend_op = self.info.get(\"blend\")\n            self.dispose_extent = self.info.get(\"bbox\")\n            self.__frame = 0\n        else:\n            if frame != self.__frame + 1:\n                msg = f\"cannot seek to frame {frame}\"\n                raise ValueError(msg)\n\n            # ensure previous frame was loaded\n            self.load()\n\n            if self.dispose:\n                self.im.paste(self.dispose, self.dispose_extent)\n            self._prev_im = self.im.copy()\n\n            self.fp = self._fp\n\n            # advance to the next frame\n            if self.__prepare_idat:\n                ImageFile._safe_read(self.fp, self.__prepare_idat)\n                self.__prepare_idat = 0\n            frame_start = False\n            while True:\n                self.fp.read(4)  # CRC\n\n                try:\n                    cid, pos, length = self.png.read()\n                except (struct.error, SyntaxError):\n                    break\n\n                if cid == b\"IEND\":\n                    msg = \"No more images in APNG file\"\n                    raise EOFError(msg)\n                if cid == b\"fcTL\":\n                    if frame_start:\n                        # there must be at least one fdAT chunk between fcTL chunks\n                        msg = \"APNG missing frame data\"\n                        raise SyntaxError(msg)\n                    frame_start = True\n\n                try:\n                    self.png.call(cid, pos, length)\n                except UnicodeDecodeError:\n                    break\n                except EOFError:\n                    if cid == b\"fdAT\":\n                        length -= 4\n                        if frame_start:\n                            self.__prepare_idat = length\n                            break\n                    ImageFile._safe_read(self.fp, length)\n                except AttributeError:\n                    logger.debug(\"%r %s %s (unknown)\", cid, pos, length)\n                    ImageFile._safe_read(self.fp, length)\n\n            self.__frame = frame\n            self.tile = self.png.im_tile\n            self.dispose_op = self.info.get(\"disposal\")\n            self.blend_op = self.info.get(\"blend\")\n            self.dispose_extent = self.info.get(\"bbox\")\n\n            if not self.tile:\n                msg = \"image not found in APNG frame\"\n                raise EOFError(msg)\n\n        # setup frame disposal (actual disposal done when needed in the next _seek())\n        if self._prev_im is None and self.dispose_op == Disposal.OP_PREVIOUS:\n            self.dispose_op = Disposal.OP_BACKGROUND\n\n        self.dispose = None\n        if self.dispose_op == Disposal.OP_PREVIOUS:\n            if self._prev_im:\n                self.dispose = self._prev_im.copy()\n                self.dispose = self._crop(self.dispose, self.dispose_extent)\n        elif self.dispose_op == Disposal.OP_BACKGROUND:\n            self.dispose = Image.core.fill(self.mode, self.size)\n            self.dispose = self._crop(self.dispose, self.dispose_extent)\n\n    def tell(self) -> int:\n        return self.__frame\n\n    def load_prepare(self) -> None:\n        \"\"\"internal: prepare to read PNG file\"\"\"\n\n        if self.info.get(\"interlace\"):\n            self.decoderconfig = self.decoderconfig + (1,)\n\n        self.__idat = self.__prepare_idat  # used by load_read()\n        ImageFile.ImageFile.load_prepare(self)\n\n    def load_read(self, read_bytes: int) -> bytes:\n        \"\"\"internal: read more image data\"\"\"\n\n        assert self.png is not None\n        while self.__idat == 0:\n            # end of chunk, skip forward to next one\n\n            self.fp.read(4)  # CRC\n\n            cid, pos, length = self.png.read()\n\n            if cid not in [b\"IDAT\", b\"DDAT\", b\"fdAT\"]:\n                self.png.push(cid, pos, length)\n                return b\"\"\n\n            if cid == b\"fdAT\":\n                try:\n                    self.png.call(cid, pos, length)\n                except EOFError:\n                    pass\n                self.__idat = length - 4  # sequence_num has already been read\n            else:\n                self.__idat = length  # empty chunks are allowed\n\n        # read more data from this chunk\n        if read_bytes <= 0:\n            read_bytes = self.__idat\n        else:\n            read_bytes = min(read_bytes, self.__idat)\n\n        self.__idat = self.__idat - read_bytes\n\n        return self.fp.read(read_bytes)\n\n    def load_end(self) -> None:\n        \"\"\"internal: finished reading image data\"\"\"\n        assert self.png is not None\n        if self.__idat != 0:\n            self.fp.read(self.__idat)\n        while True:\n            self.fp.read(4)  # CRC\n\n            try:\n                cid, pos, length = self.png.read()\n            except (struct.error, SyntaxError):\n                break\n\n            if cid == b\"IEND\":\n                break\n            elif cid == b\"fcTL\" and self.is_animated:\n                # start of the next frame, stop reading\n                self.__prepare_idat = 0\n                self.png.push(cid, pos, length)\n                break\n\n            try:\n                self.png.call(cid, pos, length)\n            except UnicodeDecodeError:\n                break\n            except EOFError:\n                if cid == b\"fdAT\":\n                    length -= 4\n                try:\n                    ImageFile._safe_read(self.fp, length)\n                except OSError as e:\n                    if ImageFile.LOAD_TRUNCATED_IMAGES:\n                        break\n                    else:\n                        raise e\n            except AttributeError:\n                logger.debug(\"%r %s %s (unknown)\", cid, pos, length)\n                s = ImageFile._safe_read(self.fp, length)\n                if cid[1:2].islower():\n                    self.private_chunks.append((cid, s, True))\n        self._text = self.png.im_text\n        if not self.is_animated:\n            self.png.close()\n            self.png = None\n        else:\n            if self._prev_im and self.blend_op == Blend.OP_OVER:\n                updated = self._crop(self.im, self.dispose_extent)\n                if self.im.mode == \"RGB\" and \"transparency\" in self.info:\n                    mask = updated.convert_transparent(\n                        \"RGBA\", self.info[\"transparency\"]\n                    )\n                else:\n                    mask = updated.convert(\"RGBA\")\n                self._prev_im.paste(updated, self.dispose_extent, mask)\n                self.im = self._prev_im\n                if self.pyaccess:\n                    self.pyaccess = None\n\n    def _getexif(self) -> dict[str, Any] | None:\n        if \"exif\" not in self.info:\n            self.load()\n        if \"exif\" not in self.info and \"Raw profile type exif\" not in self.info:\n            return None\n        return self.getexif()._get_merged_dict()\n\n    def getexif(self) -> Image.Exif:\n        if \"exif\" not in self.info:\n            self.load()\n\n        return super().getexif()\n\n\n# --------------------------------------------------------------------\n# PNG writer\n\n_OUTMODES = {\n    # supported PIL modes, and corresponding rawmode, bit depth and color type\n    \"1\": (\"1\", b\"\\x01\", b\"\\x00\"),\n    \"L;1\": (\"L;1\", b\"\\x01\", b\"\\x00\"),\n    \"L;2\": (\"L;2\", b\"\\x02\", b\"\\x00\"),\n    \"L;4\": (\"L;4\", b\"\\x04\", b\"\\x00\"),\n    \"L\": (\"L\", b\"\\x08\", b\"\\x00\"),\n    \"LA\": (\"LA\", b\"\\x08\", b\"\\x04\"),\n    \"I\": (\"I;16B\", b\"\\x10\", b\"\\x00\"),\n    \"I;16\": (\"I;16B\", b\"\\x10\", b\"\\x00\"),\n    \"I;16B\": (\"I;16B\", b\"\\x10\", b\"\\x00\"),\n    \"P;1\": (\"P;1\", b\"\\x01\", b\"\\x03\"),\n    \"P;2\": (\"P;2\", b\"\\x02\", b\"\\x03\"),\n    \"P;4\": (\"P;4\", b\"\\x04\", b\"\\x03\"),\n    \"P\": (\"P\", b\"\\x08\", b\"\\x03\"),\n    \"RGB\": (\"RGB\", b\"\\x08\", b\"\\x02\"),\n    \"RGBA\": (\"RGBA\", b\"\\x08\", b\"\\x06\"),\n}\n\n\ndef putchunk(fp, cid, *data):\n    \"\"\"Write a PNG chunk (including CRC field)\"\"\"\n\n    data = b\"\".join(data)\n\n    fp.write(o32(len(data)) + cid)\n    fp.write(data)\n    crc = _crc32(data, _crc32(cid))\n    fp.write(o32(crc))\n\n\nclass _idat:\n    # wrap output from the encoder in IDAT chunks\n\n    def __init__(self, fp, chunk):\n        self.fp = fp\n        self.chunk = chunk\n\n    def write(self, data: bytes) -> None:\n        self.chunk(self.fp, b\"IDAT\", data)\n\n\nclass _fdat:\n    # wrap encoder output in fdAT chunks\n\n    def __init__(self, fp, chunk, seq_num):\n        self.fp = fp\n        self.chunk = chunk\n        self.seq_num = seq_num\n\n    def write(self, data: bytes) -> None:\n        self.chunk(self.fp, b\"fdAT\", o32(self.seq_num), data)\n        self.seq_num += 1\n\n\ndef _write_multiple_frames(im, fp, chunk, rawmode, default_image, append_images):\n    duration = im.encoderinfo.get(\"duration\", im.info.get(\"duration\", 0))\n    loop = im.encoderinfo.get(\"loop\", im.info.get(\"loop\", 0))\n    disposal = im.encoderinfo.get(\"disposal\", im.info.get(\"disposal\", Disposal.OP_NONE))\n    blend = im.encoderinfo.get(\"blend\", im.info.get(\"blend\", Blend.OP_SOURCE))\n\n    if default_image:\n        chain = itertools.chain(append_images)\n    else:\n        chain = itertools.chain([im], append_images)\n\n    im_frames = []\n    frame_count = 0\n    for im_seq in chain:\n        for im_frame in ImageSequence.Iterator(im_seq):\n            if im_frame.mode == rawmode:\n                im_frame = im_frame.copy()\n            else:\n                im_frame = im_frame.convert(rawmode)\n            encoderinfo = im.encoderinfo.copy()\n            if isinstance(duration, (list, tuple)):\n                encoderinfo[\"duration\"] = duration[frame_count]\n            if isinstance(disposal, (list, tuple)):\n                encoderinfo[\"disposal\"] = disposal[frame_count]\n            if isinstance(blend, (list, tuple)):\n                encoderinfo[\"blend\"] = blend[frame_count]\n            frame_count += 1\n\n            if im_frames:\n                previous = im_frames[-1]\n                prev_disposal = previous[\"encoderinfo\"].get(\"disposal\")\n                prev_blend = previous[\"encoderinfo\"].get(\"blend\")\n                if prev_disposal == Disposal.OP_PREVIOUS and len(im_frames) < 2:\n                    prev_disposal = Disposal.OP_BACKGROUND\n\n                if prev_disposal == Disposal.OP_BACKGROUND:\n                    base_im = previous[\"im\"].copy()\n                    dispose = Image.core.fill(\"RGBA\", im.size, (0, 0, 0, 0))\n                    bbox = previous[\"bbox\"]\n                    if bbox:\n                        dispose = dispose.crop(bbox)\n                    else:\n                        bbox = (0, 0) + im.size\n                    base_im.paste(dispose, bbox)\n                elif prev_disposal == Disposal.OP_PREVIOUS:\n                    base_im = im_frames[-2][\"im\"]\n                else:\n                    base_im = previous[\"im\"]\n                delta = ImageChops.subtract_modulo(\n                    im_frame.convert(\"RGBA\"), base_im.convert(\"RGBA\")\n                )\n                bbox = delta.getbbox(alpha_only=False)\n                if (\n                    not bbox\n                    and prev_disposal == encoderinfo.get(\"disposal\")\n                    and prev_blend == encoderinfo.get(\"blend\")\n                ):\n                    previous[\"encoderinfo\"][\"duration\"] += encoderinfo.get(\n                        \"duration\", duration\n                    )\n                    continue\n            else:\n                bbox = None\n            if \"duration\" not in encoderinfo:\n                encoderinfo[\"duration\"] = duration\n            im_frames.append({\"im\": im_frame, \"bbox\": bbox, \"encoderinfo\": encoderinfo})\n\n    if len(im_frames) == 1 and not default_image:\n        return im_frames[0][\"im\"]\n\n    # animation control\n    chunk(\n        fp,\n        b\"acTL\",\n        o32(len(im_frames)),  # 0: num_frames\n        o32(loop),  # 4: num_plays\n    )\n\n    # default image IDAT (if it exists)\n    if default_image:\n        if im.mode != rawmode:\n            im = im.convert(rawmode)\n        ImageFile._save(im, _idat(fp, chunk), [(\"zip\", (0, 0) + im.size, 0, rawmode)])\n\n    seq_num = 0\n    for frame, frame_data in enumerate(im_frames):\n        im_frame = frame_data[\"im\"]\n        if not frame_data[\"bbox\"]:\n            bbox = (0, 0) + im_frame.size\n        else:\n            bbox = frame_data[\"bbox\"]\n            im_frame = im_frame.crop(bbox)\n        size = im_frame.size\n        encoderinfo = frame_data[\"encoderinfo\"]\n        frame_duration = int(round(encoderinfo[\"duration\"]))\n        frame_disposal = encoderinfo.get(\"disposal\", disposal)\n        frame_blend = encoderinfo.get(\"blend\", blend)\n        # frame control\n        chunk(\n            fp,\n            b\"fcTL\",\n            o32(seq_num),  # sequence_number\n            o32(size[0]),  # width\n            o32(size[1]),  # height\n            o32(bbox[0]),  # x_offset\n            o32(bbox[1]),  # y_offset\n            o16(frame_duration),  # delay_numerator\n            o16(1000),  # delay_denominator\n            o8(frame_disposal),  # dispose_op\n            o8(frame_blend),  # blend_op\n        )\n        seq_num += 1\n        # frame data\n        if frame == 0 and not default_image:\n            # first frame must be in IDAT chunks for backwards compatibility\n            ImageFile._save(\n                im_frame,\n                _idat(fp, chunk),\n                [(\"zip\", (0, 0) + im_frame.size, 0, rawmode)],\n            )\n        else:\n            fdat_chunks = _fdat(fp, chunk, seq_num)\n            ImageFile._save(\n                im_frame,\n                fdat_chunks,\n                [(\"zip\", (0, 0) + im_frame.size, 0, rawmode)],\n            )\n            seq_num = fdat_chunks.seq_num\n\n\ndef _save_all(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    _save(im, fp, filename, save_all=True)\n\n\ndef _save(im, fp, filename, chunk=putchunk, save_all=False):\n    # save an image to disk (called by the save method)\n\n    if save_all:\n        default_image = im.encoderinfo.get(\n            \"default_image\", im.info.get(\"default_image\")\n        )\n        modes = set()\n        sizes = set()\n        append_images = im.encoderinfo.get(\"append_images\", [])\n        for im_seq in itertools.chain([im], append_images):\n            for im_frame in ImageSequence.Iterator(im_seq):\n                modes.add(im_frame.mode)\n                sizes.add(im_frame.size)\n        for mode in (\"RGBA\", \"RGB\", \"P\"):\n            if mode in modes:\n                break\n        else:\n            mode = modes.pop()\n        size = tuple(max(frame_size[i] for frame_size in sizes) for i in range(2))\n    else:\n        size = im.size\n        mode = im.mode\n\n    if mode == \"P\":\n        #\n        # attempt to minimize storage requirements for palette images\n        if \"bits\" in im.encoderinfo:\n            # number of bits specified by user\n            colors = min(1 << im.encoderinfo[\"bits\"], 256)\n        else:\n            # check palette contents\n            if im.palette:\n                colors = max(min(len(im.palette.getdata()[1]) // 3, 256), 1)\n            else:\n                colors = 256\n\n        if colors <= 16:\n            if colors <= 2:\n                bits = 1\n            elif colors <= 4:\n                bits = 2\n            else:\n                bits = 4\n            mode = f\"{mode};{bits}\"\n\n    # encoder options\n    im.encoderconfig = (\n        im.encoderinfo.get(\"optimize\", False),\n        im.encoderinfo.get(\"compress_level\", -1),\n        im.encoderinfo.get(\"compress_type\", -1),\n        im.encoderinfo.get(\"dictionary\", b\"\"),\n    )\n\n    # get the corresponding PNG mode\n    try:\n        rawmode, bit_depth, color_type = _OUTMODES[mode]\n    except KeyError as e:\n        msg = f\"cannot write mode {mode} as PNG\"\n        raise OSError(msg) from e\n\n    #\n    # write minimal PNG file\n\n    fp.write(_MAGIC)\n\n    chunk(\n        fp,\n        b\"IHDR\",\n        o32(size[0]),  # 0: size\n        o32(size[1]),\n        bit_depth,\n        color_type,\n        b\"\\0\",  # 10: compression\n        b\"\\0\",  # 11: filter category\n        b\"\\0\",  # 12: interlace flag\n    )\n\n    chunks = [b\"cHRM\", b\"gAMA\", b\"sBIT\", b\"sRGB\", b\"tIME\"]\n\n    icc = im.encoderinfo.get(\"icc_profile\", im.info.get(\"icc_profile\"))\n    if icc:\n        # ICC profile\n        # according to PNG spec, the iCCP chunk contains:\n        # Profile name  1-79 bytes (character string)\n        # Null separator        1 byte (null character)\n        # Compression method    1 byte (0)\n        # Compressed profile    n bytes (zlib with deflate compression)\n        name = b\"ICC Profile\"\n        data = name + b\"\\0\\0\" + zlib.compress(icc)\n        chunk(fp, b\"iCCP\", data)\n\n        # You must either have sRGB or iCCP.\n        # Disallow sRGB chunks when an iCCP-chunk has been emitted.\n        chunks.remove(b\"sRGB\")\n\n    info = im.encoderinfo.get(\"pnginfo\")\n    if info:\n        chunks_multiple_allowed = [b\"sPLT\", b\"iTXt\", b\"tEXt\", b\"zTXt\"]\n        for info_chunk in info.chunks:\n            cid, data = info_chunk[:2]\n            if cid in chunks:\n                chunks.remove(cid)\n                chunk(fp, cid, data)\n            elif cid in chunks_multiple_allowed:\n                chunk(fp, cid, data)\n            elif cid[1:2].islower():\n                # Private chunk\n                after_idat = len(info_chunk) == 3 and info_chunk[2]\n                if not after_idat:\n                    chunk(fp, cid, data)\n\n    if im.mode == \"P\":\n        palette_byte_number = colors * 3\n        palette_bytes = im.im.getpalette(\"RGB\")[:palette_byte_number]\n        while len(palette_bytes) < palette_byte_number:\n            palette_bytes += b\"\\0\"\n        chunk(fp, b\"PLTE\", palette_bytes)\n\n    transparency = im.encoderinfo.get(\"transparency\", im.info.get(\"transparency\", None))\n\n    if transparency or transparency == 0:\n        if im.mode == \"P\":\n            # limit to actual palette size\n            alpha_bytes = colors\n            if isinstance(transparency, bytes):\n                chunk(fp, b\"tRNS\", transparency[:alpha_bytes])\n            else:\n                transparency = max(0, min(255, transparency))\n                alpha = b\"\\xFF\" * transparency + b\"\\0\"\n                chunk(fp, b\"tRNS\", alpha[:alpha_bytes])\n        elif im.mode in (\"1\", \"L\", \"I\", \"I;16\"):\n            transparency = max(0, min(65535, transparency))\n            chunk(fp, b\"tRNS\", o16(transparency))\n        elif im.mode == \"RGB\":\n            red, green, blue = transparency\n            chunk(fp, b\"tRNS\", o16(red) + o16(green) + o16(blue))\n        else:\n            if \"transparency\" in im.encoderinfo:\n                # don't bother with transparency if it's an RGBA\n                # and it's in the info dict. It's probably just stale.\n                msg = \"cannot use transparency for this mode\"\n                raise OSError(msg)\n    else:\n        if im.mode == \"P\" and im.im.getpalettemode() == \"RGBA\":\n            alpha = im.im.getpalette(\"RGBA\", \"A\")\n            alpha_bytes = colors\n            chunk(fp, b\"tRNS\", alpha[:alpha_bytes])\n\n    dpi = im.encoderinfo.get(\"dpi\")\n    if dpi:\n        chunk(\n            fp,\n            b\"pHYs\",\n            o32(int(dpi[0] / 0.0254 + 0.5)),\n            o32(int(dpi[1] / 0.0254 + 0.5)),\n            b\"\\x01\",\n        )\n\n    if info:\n        chunks = [b\"bKGD\", b\"hIST\"]\n        for info_chunk in info.chunks:\n            cid, data = info_chunk[:2]\n            if cid in chunks:\n                chunks.remove(cid)\n                chunk(fp, cid, data)\n\n    exif = im.encoderinfo.get(\"exif\")\n    if exif:\n        if isinstance(exif, Image.Exif):\n            exif = exif.tobytes(8)\n        if exif.startswith(b\"Exif\\x00\\x00\"):\n            exif = exif[6:]\n        chunk(fp, b\"eXIf\", exif)\n\n    if save_all:\n        im = _write_multiple_frames(\n            im, fp, chunk, rawmode, default_image, append_images\n        )\n    if im:\n        ImageFile._save(im, _idat(fp, chunk), [(\"zip\", (0, 0) + im.size, 0, rawmode)])\n\n    if info:\n        for info_chunk in info.chunks:\n            cid, data = info_chunk[:2]\n            if cid[1:2].islower():\n                # Private chunk\n                after_idat = len(info_chunk) == 3 and info_chunk[2]\n                if after_idat:\n                    chunk(fp, cid, data)\n\n    chunk(fp, b\"IEND\", b\"\")\n\n    if hasattr(fp, \"flush\"):\n        fp.flush()\n\n\n# --------------------------------------------------------------------\n# PNG chunk converter\n\n\ndef getchunks(im, **params):\n    \"\"\"Return a list of PNG chunks representing this image.\"\"\"\n\n    class collector:\n        data = []\n\n        def write(self, data: bytes) -> None:\n            pass\n\n        def append(self, chunk: bytes) -> None:\n            self.data.append(chunk)\n\n    def append(fp, cid, *data):\n        data = b\"\".join(data)\n        crc = o32(_crc32(data, _crc32(cid)))\n        fp.append((cid, data, crc))\n\n    fp = collector()\n\n    try:\n        im.encoderinfo = params\n        _save(im, fp, None, append)\n    finally:\n        del im.encoderinfo\n\n    return fp.data\n\n\n# --------------------------------------------------------------------\n# Registry\n\nImage.register_open(PngImageFile.format, PngImageFile, _accept)\nImage.register_save(PngImageFile.format, _save)\nImage.register_save_all(PngImageFile.format, _save_all)\n\nImage.register_extensions(PngImageFile.format, [\".png\", \".apng\"])\n\nImage.register_mime(PngImageFile.format, \"image/png\")\n", "src/PIL/WmfImagePlugin.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# WMF stub codec\n#\n# history:\n# 1996-12-14 fl   Created\n# 2004-02-22 fl   Turned into a stub driver\n# 2004-02-23 fl   Added EMF support\n#\n# Copyright (c) Secret Labs AB 1997-2004.  All rights reserved.\n# Copyright (c) Fredrik Lundh 1996.\n#\n# See the README file for information on usage and redistribution.\n#\n# WMF/EMF reference documentation:\n# https://winprotocoldoc.blob.core.windows.net/productionwindowsarchives/MS-WMF/[MS-WMF].pdf\n# http://wvware.sourceforge.net/caolan/index.html\n# http://wvware.sourceforge.net/caolan/ora-wmf.html\nfrom __future__ import annotations\n\nfrom typing import IO\n\nfrom . import Image, ImageFile\nfrom ._binary import i16le as word\nfrom ._binary import si16le as short\nfrom ._binary import si32le as _long\n\n_handler = None\n\n\ndef register_handler(handler: ImageFile.StubHandler | None) -> None:\n    \"\"\"\n    Install application-specific WMF image handler.\n\n    :param handler: Handler object.\n    \"\"\"\n    global _handler\n    _handler = handler\n\n\nif hasattr(Image.core, \"drawwmf\"):\n    # install default handler (windows only)\n\n    class WmfHandler(ImageFile.StubHandler):\n        def open(self, im: ImageFile.StubImageFile) -> None:\n            im._mode = \"RGB\"\n            self.bbox = im.info[\"wmf_bbox\"]\n\n        def load(self, im: ImageFile.StubImageFile) -> Image.Image:\n            im.fp.seek(0)  # rewind\n            return Image.frombytes(\n                \"RGB\",\n                im.size,\n                Image.core.drawwmf(im.fp.read(), im.size, self.bbox),\n                \"raw\",\n                \"BGR\",\n                (im.size[0] * 3 + 3) & -4,\n                -1,\n            )\n\n    register_handler(WmfHandler())\n\n#\n# --------------------------------------------------------------------\n# Read WMF file\n\n\ndef _accept(prefix: bytes) -> bool:\n    return (\n        prefix[:6] == b\"\\xd7\\xcd\\xc6\\x9a\\x00\\x00\" or prefix[:4] == b\"\\x01\\x00\\x00\\x00\"\n    )\n\n\n##\n# Image plugin for Windows metafiles.\n\n\nclass WmfStubImageFile(ImageFile.StubImageFile):\n    format = \"WMF\"\n    format_description = \"Windows Metafile\"\n\n    def _open(self) -> None:\n        self._inch = None\n\n        # check placable header\n        s = self.fp.read(80)\n\n        if s[:6] == b\"\\xd7\\xcd\\xc6\\x9a\\x00\\x00\":\n            # placeable windows metafile\n\n            # get units per inch\n            self._inch = word(s, 14)\n\n            # get bounding box\n            x0 = short(s, 6)\n            y0 = short(s, 8)\n            x1 = short(s, 10)\n            y1 = short(s, 12)\n\n            # normalize size to 72 dots per inch\n            self.info[\"dpi\"] = 72\n            size = (\n                (x1 - x0) * self.info[\"dpi\"] // self._inch,\n                (y1 - y0) * self.info[\"dpi\"] // self._inch,\n            )\n\n            self.info[\"wmf_bbox\"] = x0, y0, x1, y1\n\n            # sanity check (standard metafile header)\n            if s[22:26] != b\"\\x01\\x00\\t\\x00\":\n                msg = \"Unsupported WMF file format\"\n                raise SyntaxError(msg)\n\n        elif s[:4] == b\"\\x01\\x00\\x00\\x00\" and s[40:44] == b\" EMF\":\n            # enhanced metafile\n\n            # get bounding box\n            x0 = _long(s, 8)\n            y0 = _long(s, 12)\n            x1 = _long(s, 16)\n            y1 = _long(s, 20)\n\n            # get frame (in 0.01 millimeter units)\n            frame = _long(s, 24), _long(s, 28), _long(s, 32), _long(s, 36)\n\n            size = x1 - x0, y1 - y0\n\n            # calculate dots per inch from bbox and frame\n            xdpi = 2540.0 * (x1 - y0) / (frame[2] - frame[0])\n            ydpi = 2540.0 * (y1 - y0) / (frame[3] - frame[1])\n\n            self.info[\"wmf_bbox\"] = x0, y0, x1, y1\n\n            if xdpi == ydpi:\n                self.info[\"dpi\"] = xdpi\n            else:\n                self.info[\"dpi\"] = xdpi, ydpi\n\n        else:\n            msg = \"Unsupported file format\"\n            raise SyntaxError(msg)\n\n        self._mode = \"RGB\"\n        self._size = size\n\n        loader = self._load()\n        if loader:\n            loader.open(self)\n\n    def _load(self) -> ImageFile.StubHandler | None:\n        return _handler\n\n    def load(self, dpi=None):\n        if dpi is not None and self._inch is not None:\n            self.info[\"dpi\"] = dpi\n            x0, y0, x1, y1 = self.info[\"wmf_bbox\"]\n            self._size = (\n                (x1 - x0) * self.info[\"dpi\"] // self._inch,\n                (y1 - y0) * self.info[\"dpi\"] // self._inch,\n            )\n        return super().load()\n\n\ndef _save(im: Image.Image, fp: IO[bytes], filename: str | bytes) -> None:\n    if _handler is None or not hasattr(_handler, \"save\"):\n        msg = \"WMF save handler not installed\"\n        raise OSError(msg)\n    _handler.save(im, fp, filename)\n\n\n#\n# --------------------------------------------------------------------\n# Registry stuff\n\n\nImage.register_open(WmfStubImageFile.format, WmfStubImageFile, _accept)\nImage.register_save(WmfStubImageFile.format, _save)\n\nImage.register_extensions(WmfStubImageFile.format, [\".wmf\", \".emf\"])\n", "src/PIL/ImageQt.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# a simple Qt image interface.\n#\n# history:\n# 2006-06-03 fl: created\n# 2006-06-04 fl: inherit from QImage instead of wrapping it\n# 2006-06-05 fl: removed toimage helper; move string support to ImageQt\n# 2013-11-13 fl: add support for Qt5 (aurelien.ballier@cyclonit.com)\n#\n# Copyright (c) 2006 by Secret Labs AB\n# Copyright (c) 2006 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport sys\nfrom io import BytesIO\nfrom typing import Callable\n\nfrom . import Image\nfrom ._util import is_path\n\nqt_version: str | None\nqt_versions = [\n    [\"6\", \"PyQt6\"],\n    [\"side6\", \"PySide6\"],\n]\n\n# If a version has already been imported, attempt it first\nqt_versions.sort(key=lambda version: version[1] in sys.modules, reverse=True)\nfor version, qt_module in qt_versions:\n    try:\n        QBuffer: type\n        QIODevice: type\n        QImage: type\n        QPixmap: type\n        qRgba: Callable[[int, int, int, int], int]\n        if qt_module == \"PyQt6\":\n            from PyQt6.QtCore import QBuffer, QIODevice\n            from PyQt6.QtGui import QImage, QPixmap, qRgba\n        elif qt_module == \"PySide6\":\n            from PySide6.QtCore import QBuffer, QIODevice\n            from PySide6.QtGui import QImage, QPixmap, qRgba\n    except (ImportError, RuntimeError):\n        continue\n    qt_is_installed = True\n    qt_version = version\n    break\nelse:\n    qt_is_installed = False\n    qt_version = None\n\n\ndef rgb(r, g, b, a=255):\n    \"\"\"(Internal) Turns an RGB color into a Qt compatible color integer.\"\"\"\n    # use qRgb to pack the colors, and then turn the resulting long\n    # into a negative integer with the same bitpattern.\n    return qRgba(r, g, b, a) & 0xFFFFFFFF\n\n\ndef fromqimage(im):\n    \"\"\"\n    :param im: QImage or PIL ImageQt object\n    \"\"\"\n    buffer = QBuffer()\n    if qt_version == \"6\":\n        try:\n            qt_openmode = QIODevice.OpenModeFlag\n        except AttributeError:\n            qt_openmode = QIODevice.OpenMode\n    else:\n        qt_openmode = QIODevice\n    buffer.open(qt_openmode.ReadWrite)\n    # preserve alpha channel with png\n    # otherwise ppm is more friendly with Image.open\n    if im.hasAlphaChannel():\n        im.save(buffer, \"png\")\n    else:\n        im.save(buffer, \"ppm\")\n\n    b = BytesIO()\n    b.write(buffer.data())\n    buffer.close()\n    b.seek(0)\n\n    return Image.open(b)\n\n\ndef fromqpixmap(im):\n    return fromqimage(im)\n\n\ndef align8to32(bytes, width, mode):\n    \"\"\"\n    converts each scanline of data from 8 bit to 32 bit aligned\n    \"\"\"\n\n    bits_per_pixel = {\"1\": 1, \"L\": 8, \"P\": 8, \"I;16\": 16}[mode]\n\n    # calculate bytes per line and the extra padding if needed\n    bits_per_line = bits_per_pixel * width\n    full_bytes_per_line, remaining_bits_per_line = divmod(bits_per_line, 8)\n    bytes_per_line = full_bytes_per_line + (1 if remaining_bits_per_line else 0)\n\n    extra_padding = -bytes_per_line % 4\n\n    # already 32 bit aligned by luck\n    if not extra_padding:\n        return bytes\n\n    new_data = [\n        bytes[i * bytes_per_line : (i + 1) * bytes_per_line] + b\"\\x00\" * extra_padding\n        for i in range(len(bytes) // bytes_per_line)\n    ]\n\n    return b\"\".join(new_data)\n\n\ndef _toqclass_helper(im):\n    data = None\n    colortable = None\n    exclusive_fp = False\n\n    # handle filename, if given instead of image name\n    if hasattr(im, \"toUtf8\"):\n        # FIXME - is this really the best way to do this?\n        im = str(im.toUtf8(), \"utf-8\")\n    if is_path(im):\n        im = Image.open(im)\n        exclusive_fp = True\n\n    qt_format = QImage.Format if qt_version == \"6\" else QImage\n    if im.mode == \"1\":\n        format = qt_format.Format_Mono\n    elif im.mode == \"L\":\n        format = qt_format.Format_Indexed8\n        colortable = [rgb(i, i, i) for i in range(256)]\n    elif im.mode == \"P\":\n        format = qt_format.Format_Indexed8\n        palette = im.getpalette()\n        colortable = [rgb(*palette[i : i + 3]) for i in range(0, len(palette), 3)]\n    elif im.mode == \"RGB\":\n        # Populate the 4th channel with 255\n        im = im.convert(\"RGBA\")\n\n        data = im.tobytes(\"raw\", \"BGRA\")\n        format = qt_format.Format_RGB32\n    elif im.mode == \"RGBA\":\n        data = im.tobytes(\"raw\", \"BGRA\")\n        format = qt_format.Format_ARGB32\n    elif im.mode == \"I;16\":\n        im = im.point(lambda i: i * 256)\n\n        format = qt_format.Format_Grayscale16\n    else:\n        if exclusive_fp:\n            im.close()\n        msg = f\"unsupported image mode {repr(im.mode)}\"\n        raise ValueError(msg)\n\n    size = im.size\n    __data = data or align8to32(im.tobytes(), size[0], im.mode)\n    if exclusive_fp:\n        im.close()\n    return {\"data\": __data, \"size\": size, \"format\": format, \"colortable\": colortable}\n\n\nif qt_is_installed:\n\n    class ImageQt(QImage):\n        def __init__(self, im):\n            \"\"\"\n            An PIL image wrapper for Qt.  This is a subclass of PyQt's QImage\n            class.\n\n            :param im: A PIL Image object, or a file name (given either as\n                Python string or a PyQt string object).\n            \"\"\"\n            im_data = _toqclass_helper(im)\n            # must keep a reference, or Qt will crash!\n            # All QImage constructors that take data operate on an existing\n            # buffer, so this buffer has to hang on for the life of the image.\n            # Fixes https://github.com/python-pillow/Pillow/issues/1370\n            self.__data = im_data[\"data\"]\n            super().__init__(\n                self.__data,\n                im_data[\"size\"][0],\n                im_data[\"size\"][1],\n                im_data[\"format\"],\n            )\n            if im_data[\"colortable\"]:\n                self.setColorTable(im_data[\"colortable\"])\n\n\ndef toqimage(im) -> ImageQt:\n    return ImageQt(im)\n\n\ndef toqpixmap(im):\n    qimage = toqimage(im)\n    return QPixmap.fromImage(qimage)\n", "src/PIL/ImageFont.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# PIL raster font management\n#\n# History:\n# 1996-08-07 fl   created (experimental)\n# 1997-08-25 fl   minor adjustments to handle fonts from pilfont 0.3\n# 1999-02-06 fl   rewrote most font management stuff in C\n# 1999-03-17 fl   take pth files into account in load_path (from Richard Jones)\n# 2001-02-17 fl   added freetype support\n# 2001-05-09 fl   added TransposedFont wrapper class\n# 2002-03-04 fl   make sure we have a \"L\" or \"1\" font\n# 2002-12-04 fl   skip non-directory entries in the system path\n# 2003-04-29 fl   add embedded default font\n# 2003-09-27 fl   added support for truetype charmap encodings\n#\n# Todo:\n# Adapt to PILFONT2 format (16-bit fonts, compressed, single file)\n#\n# Copyright (c) 1997-2003 by Secret Labs AB\n# Copyright (c) 1996-2003 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\n\nfrom __future__ import annotations\n\nimport base64\nimport os\nimport sys\nimport warnings\nfrom enum import IntEnum\nfrom io import BytesIO\nfrom types import ModuleType\nfrom typing import IO, TYPE_CHECKING, Any, BinaryIO\n\nfrom . import Image\nfrom ._typing import StrOrBytesPath\nfrom ._util import DeferredError, is_path\n\nif TYPE_CHECKING:\n    from . import ImageFile\n    from ._imaging import ImagingFont\n    from ._imagingft import Font\n\n\nclass Layout(IntEnum):\n    BASIC = 0\n    RAQM = 1\n\n\nMAX_STRING_LENGTH = 1_000_000\n\n\ncore: ModuleType | DeferredError\ntry:\n    from . import _imagingft as core\nexcept ImportError as ex:\n    core = DeferredError.new(ex)\n\n\ndef _string_length_check(text: str | bytes | bytearray) -> None:\n    if MAX_STRING_LENGTH is not None and len(text) > MAX_STRING_LENGTH:\n        msg = \"too many characters in string\"\n        raise ValueError(msg)\n\n\n# FIXME: add support for pilfont2 format (see FontFile.py)\n\n# --------------------------------------------------------------------\n# Font metrics format:\n#       \"PILfont\" LF\n#       fontdescriptor LF\n#       (optional) key=value... LF\n#       \"DATA\" LF\n#       binary data: 256*10*2 bytes (dx, dy, dstbox, srcbox)\n#\n# To place a character, cut out srcbox and paste at dstbox,\n# relative to the character position.  Then move the character\n# position according to dx, dy.\n# --------------------------------------------------------------------\n\n\nclass ImageFont:\n    \"\"\"PIL font wrapper\"\"\"\n\n    font: ImagingFont\n\n    def _load_pilfont(self, filename: str) -> None:\n        with open(filename, \"rb\") as fp:\n            image: ImageFile.ImageFile | None = None\n            for ext in (\".png\", \".gif\", \".pbm\"):\n                if image:\n                    image.close()\n                try:\n                    fullname = os.path.splitext(filename)[0] + ext\n                    image = Image.open(fullname)\n                except Exception:\n                    pass\n                else:\n                    if image and image.mode in (\"1\", \"L\"):\n                        break\n            else:\n                if image:\n                    image.close()\n                msg = \"cannot find glyph data file\"\n                raise OSError(msg)\n\n            self.file = fullname\n\n            self._load_pilfont_data(fp, image)\n            image.close()\n\n    def _load_pilfont_data(self, file: IO[bytes], image: Image.Image) -> None:\n        # read PILfont header\n        if file.readline() != b\"PILfont\\n\":\n            msg = \"Not a PILfont file\"\n            raise SyntaxError(msg)\n        file.readline().split(b\";\")\n        self.info = []  # FIXME: should be a dictionary\n        while True:\n            s = file.readline()\n            if not s or s == b\"DATA\\n\":\n                break\n            self.info.append(s)\n\n        # read PILfont metrics\n        data = file.read(256 * 20)\n\n        # check image\n        if image.mode not in (\"1\", \"L\"):\n            msg = \"invalid font image mode\"\n            raise TypeError(msg)\n\n        image.load()\n\n        self.font = Image.core.font(image.im, data)\n\n    def getmask(self, text, mode=\"\", *args, **kwargs):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :return: An internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module.\n        \"\"\"\n        _string_length_check(text)\n        Image._decompression_bomb_check(self.font.getsize(text))\n        return self.font.getmask(text, mode)\n\n    def getbbox(\n        self, text: str | bytes | bytearray, *args: Any, **kwargs: Any\n    ) -> tuple[int, int, int, int]:\n        \"\"\"\n        Returns bounding box (in pixels) of given text.\n\n        .. versionadded:: 9.2.0\n\n        :param text: Text to render.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n        \"\"\"\n        _string_length_check(text)\n        width, height = self.font.getsize(text)\n        return 0, 0, width, height\n\n    def getlength(\n        self, text: str | bytes | bytearray, *args: Any, **kwargs: Any\n    ) -> int:\n        \"\"\"\n        Returns length (in pixels) of given text.\n        This is the amount by which following text should be offset.\n\n        .. versionadded:: 9.2.0\n        \"\"\"\n        _string_length_check(text)\n        width, height = self.font.getsize(text)\n        return width\n\n\n##\n# Wrapper for FreeType fonts.  Application code should use the\n# <b>truetype</b> factory function to create font objects.\n\n\nclass FreeTypeFont:\n    \"\"\"FreeType font wrapper (requires _imagingft service)\"\"\"\n\n    font: Font\n    font_bytes: bytes\n\n    def __init__(\n        self,\n        font: StrOrBytesPath | BinaryIO | None = None,\n        size: float = 10,\n        index: int = 0,\n        encoding: str = \"\",\n        layout_engine: Layout | None = None,\n    ) -> None:\n        # FIXME: use service provider instead\n\n        if isinstance(core, DeferredError):\n            raise core.ex\n\n        if size <= 0:\n            msg = \"font size must be greater than 0\"\n            raise ValueError(msg)\n\n        self.path = font\n        self.size = size\n        self.index = index\n        self.encoding = encoding\n\n        if layout_engine not in (Layout.BASIC, Layout.RAQM):\n            layout_engine = Layout.BASIC\n            if core.HAVE_RAQM:\n                layout_engine = Layout.RAQM\n        elif layout_engine == Layout.RAQM and not core.HAVE_RAQM:\n            warnings.warn(\n                \"Raqm layout was requested, but Raqm is not available. \"\n                \"Falling back to basic layout.\"\n            )\n            layout_engine = Layout.BASIC\n\n        self.layout_engine = layout_engine\n\n        def load_from_bytes(f):\n            self.font_bytes = f.read()\n            self.font = core.getfont(\n                \"\", size, index, encoding, self.font_bytes, layout_engine\n            )\n\n        if is_path(font):\n            font = os.path.realpath(os.fspath(font))\n            if sys.platform == \"win32\":\n                font_bytes_path = font if isinstance(font, bytes) else font.encode()\n                try:\n                    font_bytes_path.decode(\"ascii\")\n                except UnicodeDecodeError:\n                    # FreeType cannot load fonts with non-ASCII characters on Windows\n                    # So load it into memory first\n                    with open(font, \"rb\") as f:\n                        load_from_bytes(f)\n                    return\n            self.font = core.getfont(\n                font, size, index, encoding, layout_engine=layout_engine\n            )\n        else:\n            load_from_bytes(font)\n\n    def __getstate__(self):\n        return [self.path, self.size, self.index, self.encoding, self.layout_engine]\n\n    def __setstate__(self, state):\n        path, size, index, encoding, layout_engine = state\n        self.__init__(path, size, index, encoding, layout_engine)\n\n    def getname(self) -> tuple[str | None, str | None]:\n        \"\"\"\n        :return: A tuple of the font family (e.g. Helvetica) and the font style\n            (e.g. Bold)\n        \"\"\"\n        return self.font.family, self.font.style\n\n    def getmetrics(self) -> tuple[int, int]:\n        \"\"\"\n        :return: A tuple of the font ascent (the distance from the baseline to\n            the highest outline point) and descent (the distance from the\n            baseline to the lowest outline point, a negative value)\n        \"\"\"\n        return self.font.ascent, self.font.descent\n\n    def getlength(\n        self, text: str, mode=\"\", direction=None, features=None, language=None\n    ) -> float:\n        \"\"\"\n        Returns length (in pixels with 1/64 precision) of given text when rendered\n        in font with provided direction, features, and language.\n\n        This is the amount by which following text should be offset.\n        Text bounding box may extend past the length in some fonts,\n        e.g. when using italics or accents.\n\n        The result is returned as a float; it is a whole number if using basic layout.\n\n        Note that the sum of two lengths may not equal the length of a concatenated\n        string due to kerning. If you need to adjust for kerning, include the following\n        character and subtract its length.\n\n        For example, instead of ::\n\n          hello = font.getlength(\"Hello\")\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # not adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # may fail\n\n        use ::\n\n          hello = font.getlength(\"HelloW\") - font.getlength(\"W\")  # adjusted for kerning\n          world = font.getlength(\"World\")\n          hello_world = hello + world  # adjusted for kerning\n          assert hello_world == font.getlength(\"HelloWorld\")  # True\n\n        or disable kerning with (requires libraqm) ::\n\n          hello = draw.textlength(\"Hello\", font, features=[\"-kern\"])\n          world = draw.textlength(\"World\", font, features=[\"-kern\"])\n          hello_world = hello + world  # kerning is disabled, no need to adjust\n          assert hello_world == draw.textlength(\"HelloWorld\", font, features=[\"-kern\"])\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to measure.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :return: Either width for horizontal text, or height for vertical text.\n        \"\"\"\n        _string_length_check(text)\n        return self.font.getlength(text, mode, direction, features, language) / 64\n\n    def getbbox(\n        self,\n        text: str,\n        mode: str = \"\",\n        direction: str | None = None,\n        features: list[str] | None = None,\n        language: str | None = None,\n        stroke_width: float = 0,\n        anchor: str | None = None,\n    ) -> tuple[float, float, float, float]:\n        \"\"\"\n        Returns bounding box (in pixels) of given text relative to given anchor\n        when rendered in font with provided direction, features, and language.\n\n        Use :py:meth:`getlength()` to get the offset of following text with\n        1/64 pixel precision. The bounding box includes extra margins for\n        some fonts, e.g. italics or accents.\n\n        .. versionadded:: 8.0.0\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n        :param stroke_width: The width of the text stroke.\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left,\n                        specifically ``la`` for horizontal text and ``lt`` for\n                        vertical text. See :ref:`text-anchors` for details.\n\n        :return: ``(left, top, right, bottom)`` bounding box\n        \"\"\"\n        _string_length_check(text)\n        size, offset = self.font.getsize(\n            text, mode, direction, features, language, anchor\n        )\n        left, top = offset[0] - stroke_width, offset[1] - stroke_width\n        width, height = size[0] + 2 * stroke_width, size[1] + 2 * stroke_width\n        return left, top, left + width, top + height\n\n    def getmask(\n        self,\n        text,\n        mode=\"\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        anchor=None,\n        ink=0,\n        start=None,\n    ):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. If the font has embedded color data, the bitmap\n        should have mode ``RGBA``. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n                          .. versionadded:: 4.2.0\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n                         .. versionadded:: 4.2.0\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n                         .. versionadded:: 6.0.0\n\n        :param stroke_width: The width of the text stroke.\n\n                         .. versionadded:: 6.2.0\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left,\n                        specifically ``la`` for horizontal text and ``lt`` for\n                        vertical text. See :ref:`text-anchors` for details.\n\n                         .. versionadded:: 8.0.0\n\n        :param ink: Foreground ink for rendering in RGBA mode.\n\n                         .. versionadded:: 8.0.0\n\n        :param start: Tuple of horizontal and vertical offset, as text may render\n                      differently when starting at fractional coordinates.\n\n                         .. versionadded:: 9.4.0\n\n        :return: An internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module.\n        \"\"\"\n        return self.getmask2(\n            text,\n            mode,\n            direction=direction,\n            features=features,\n            language=language,\n            stroke_width=stroke_width,\n            anchor=anchor,\n            ink=ink,\n            start=start,\n        )[0]\n\n    def getmask2(\n        self,\n        text: str,\n        mode=\"\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        anchor=None,\n        ink=0,\n        start=None,\n        *args,\n        **kwargs,\n    ):\n        \"\"\"\n        Create a bitmap for the text.\n\n        If the font uses antialiasing, the bitmap should have mode ``L`` and use a\n        maximum value of 255. If the font has embedded color data, the bitmap\n        should have mode ``RGBA``. Otherwise, it should have mode ``1``.\n\n        :param text: Text to render.\n        :param mode: Used by some graphics drivers to indicate what mode the\n                     driver prefers; if empty, the renderer may return either\n                     mode. Note that the mode is always a string, to simplify\n                     C-level implementations.\n\n                     .. versionadded:: 1.1.5\n\n        :param direction: Direction of the text. It can be 'rtl' (right to\n                          left), 'ltr' (left to right) or 'ttb' (top to bottom).\n                          Requires libraqm.\n\n                          .. versionadded:: 4.2.0\n\n        :param features: A list of OpenType font features to be used during text\n                         layout. This is usually used to turn on optional\n                         font features that are not enabled by default,\n                         for example 'dlig' or 'ss01', but can be also\n                         used to turn off default font features for\n                         example '-liga' to disable ligatures or '-kern'\n                         to disable kerning.  To get all supported\n                         features, see\n                         https://learn.microsoft.com/en-us/typography/opentype/spec/featurelist\n                         Requires libraqm.\n\n                         .. versionadded:: 4.2.0\n\n        :param language: Language of the text. Different languages may use\n                         different glyph shapes or ligatures. This parameter tells\n                         the font which language the text is in, and to apply the\n                         correct substitutions as appropriate, if available.\n                         It should be a `BCP 47 language code\n                         <https://www.w3.org/International/articles/language-tags/>`_\n                         Requires libraqm.\n\n                         .. versionadded:: 6.0.0\n\n        :param stroke_width: The width of the text stroke.\n\n                         .. versionadded:: 6.2.0\n\n        :param anchor:  The text anchor alignment. Determines the relative location of\n                        the anchor to the text. The default alignment is top left,\n                        specifically ``la`` for horizontal text and ``lt`` for\n                        vertical text. See :ref:`text-anchors` for details.\n\n                         .. versionadded:: 8.0.0\n\n        :param ink: Foreground ink for rendering in RGBA mode.\n\n                         .. versionadded:: 8.0.0\n\n        :param start: Tuple of horizontal and vertical offset, as text may render\n                      differently when starting at fractional coordinates.\n\n                         .. versionadded:: 9.4.0\n\n        :return: A tuple of an internal PIL storage memory instance as defined by the\n                 :py:mod:`PIL.Image.core` interface module, and the text offset, the\n                 gap between the starting coordinate and the first marking\n        \"\"\"\n        _string_length_check(text)\n        if start is None:\n            start = (0, 0)\n\n        def fill(width, height):\n            size = (width, height)\n            Image._decompression_bomb_check(size)\n            return Image.core.fill(\"RGBA\" if mode == \"RGBA\" else \"L\", size)\n\n        return self.font.render(\n            text,\n            fill,\n            mode,\n            direction,\n            features,\n            language,\n            stroke_width,\n            anchor,\n            ink,\n            start[0],\n            start[1],\n        )\n\n    def font_variant(\n        self, font=None, size=None, index=None, encoding=None, layout_engine=None\n    ):\n        \"\"\"\n        Create a copy of this FreeTypeFont object,\n        using any specified arguments to override the settings.\n\n        Parameters are identical to the parameters used to initialize this\n        object.\n\n        :return: A FreeTypeFont object.\n        \"\"\"\n        if font is None:\n            try:\n                font = BytesIO(self.font_bytes)\n            except AttributeError:\n                font = self.path\n        return FreeTypeFont(\n            font=font,\n            size=self.size if size is None else size,\n            index=self.index if index is None else index,\n            encoding=self.encoding if encoding is None else encoding,\n            layout_engine=layout_engine or self.layout_engine,\n        )\n\n    def get_variation_names(self) -> list[bytes]:\n        \"\"\"\n        :returns: A list of the named styles in a variation font.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        try:\n            names = self.font.getvarnames()\n        except AttributeError as e:\n            msg = \"FreeType 2.9.1 or greater is required\"\n            raise NotImplementedError(msg) from e\n        return [name.replace(b\"\\x00\", b\"\") for name in names]\n\n    def set_variation_by_name(self, name):\n        \"\"\"\n        :param name: The name of the style.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        names = self.get_variation_names()\n        if not isinstance(name, bytes):\n            name = name.encode()\n        index = names.index(name) + 1\n\n        if index == getattr(self, \"_last_variation_index\", None):\n            # When the same name is set twice in a row,\n            # there is an 'unknown freetype error'\n            # https://savannah.nongnu.org/bugs/?56186\n            return\n        self._last_variation_index = index\n\n        self.font.setvarname(index)\n\n    def get_variation_axes(self):\n        \"\"\"\n        :returns: A list of the axes in a variation font.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        try:\n            axes = self.font.getvaraxes()\n        except AttributeError as e:\n            msg = \"FreeType 2.9.1 or greater is required\"\n            raise NotImplementedError(msg) from e\n        for axis in axes:\n            if axis[\"name\"]:\n                axis[\"name\"] = axis[\"name\"].replace(b\"\\x00\", b\"\")\n        return axes\n\n    def set_variation_by_axes(self, axes: list[float]) -> None:\n        \"\"\"\n        :param axes: A list of values for each axis.\n        :exception OSError: If the font is not a variation font.\n        \"\"\"\n        try:\n            self.font.setvaraxes(axes)\n        except AttributeError as e:\n            msg = \"FreeType 2.9.1 or greater is required\"\n            raise NotImplementedError(msg) from e\n\n\nclass TransposedFont:\n    \"\"\"Wrapper for writing rotated or mirrored text\"\"\"\n\n    def __init__(self, font, orientation=None):\n        \"\"\"\n        Wrapper that creates a transposed font from any existing font\n        object.\n\n        :param font: A font object.\n        :param orientation: An optional orientation.  If given, this should\n            be one of Image.Transpose.FLIP_LEFT_RIGHT, Image.Transpose.FLIP_TOP_BOTTOM,\n            Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_180, or\n            Image.Transpose.ROTATE_270.\n        \"\"\"\n        self.font = font\n        self.orientation = orientation  # any 'transpose' argument, or None\n\n    def getmask(self, text, mode=\"\", *args, **kwargs):\n        im = self.font.getmask(text, mode, *args, **kwargs)\n        if self.orientation is not None:\n            return im.transpose(self.orientation)\n        return im\n\n    def getbbox(self, text, *args, **kwargs):\n        # TransposedFont doesn't support getmask2, move top-left point to (0, 0)\n        # this has no effect on ImageFont and simulates anchor=\"lt\" for FreeTypeFont\n        left, top, right, bottom = self.font.getbbox(text, *args, **kwargs)\n        width = right - left\n        height = bottom - top\n        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):\n            return 0, 0, height, width\n        return 0, 0, width, height\n\n    def getlength(self, text: str, *args, **kwargs) -> float:\n        if self.orientation in (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270):\n            msg = \"text length is undefined for text rotated by 90 or 270 degrees\"\n            raise ValueError(msg)\n        return self.font.getlength(text, *args, **kwargs)\n\n\ndef load(filename: str) -> ImageFont:\n    \"\"\"\n    Load a font file.  This function loads a font object from the given\n    bitmap font file, and returns the corresponding font object.\n\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    \"\"\"\n    f = ImageFont()\n    f._load_pilfont(filename)\n    return f\n\n\ndef truetype(\n    font: StrOrBytesPath | BinaryIO | None = None,\n    size: float = 10,\n    index: int = 0,\n    encoding: str = \"\",\n    layout_engine: Layout | None = None,\n) -> FreeTypeFont:\n    \"\"\"\n    Load a TrueType or OpenType font from a file or file-like object,\n    and create a font object.\n    This function loads a font object from the given file or file-like\n    object, and creates a font object for a font of the given size.\n\n    Pillow uses FreeType to open font files. On Windows, be aware that FreeType\n    will keep the file open as long as the FreeTypeFont object exists. Windows\n    limits the number of files that can be open in C at once to 512, so if many\n    fonts are opened simultaneously and that limit is approached, an\n    ``OSError`` may be thrown, reporting that FreeType \"cannot open resource\".\n    A workaround would be to copy the file(s) into memory, and open that instead.\n\n    This function requires the _imagingft service.\n\n    :param font: A filename or file-like object containing a TrueType font.\n                 If the file is not found in this filename, the loader may also\n                 search in other directories, such as:\n\n                 * The :file:`fonts/` directory on Windows,\n                 * :file:`/Library/Fonts/`, :file:`/System/Library/Fonts/`\n                   and :file:`~/Library/Fonts/` on macOS.\n                 * :file:`~/.local/share/fonts`, :file:`/usr/local/share/fonts`,\n                   and :file:`/usr/share/fonts` on Linux; or those specified by\n                   the ``XDG_DATA_HOME`` and ``XDG_DATA_DIRS`` environment variables\n                   for user-installed and system-wide fonts, respectively.\n\n    :param size: The requested size, in pixels.\n    :param index: Which font face to load (default is first available face).\n    :param encoding: Which font encoding to use (default is Unicode). Possible\n                     encodings include (see the FreeType documentation for more\n                     information):\n\n                     * \"unic\" (Unicode)\n                     * \"symb\" (Microsoft Symbol)\n                     * \"ADOB\" (Adobe Standard)\n                     * \"ADBE\" (Adobe Expert)\n                     * \"ADBC\" (Adobe Custom)\n                     * \"armn\" (Apple Roman)\n                     * \"sjis\" (Shift JIS)\n                     * \"gb  \" (PRC)\n                     * \"big5\"\n                     * \"wans\" (Extended Wansung)\n                     * \"joha\" (Johab)\n                     * \"lat1\" (Latin-1)\n\n                     This specifies the character set to use. It does not alter the\n                     encoding of any text provided in subsequent operations.\n    :param layout_engine: Which layout engine to use, if available:\n                     :attr:`.ImageFont.Layout.BASIC` or :attr:`.ImageFont.Layout.RAQM`.\n                     If it is available, Raqm layout will be used by default.\n                     Otherwise, basic layout will be used.\n\n                     Raqm layout is recommended for all non-English text. If Raqm layout\n                     is not required, basic layout will have better performance.\n\n                     You can check support for Raqm layout using\n                     :py:func:`PIL.features.check_feature` with ``feature=\"raqm\"``.\n\n                     .. versionadded:: 4.2.0\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    :exception ValueError: If the font size is not greater than zero.\n    \"\"\"\n\n    def freetype(font: StrOrBytesPath | BinaryIO | None) -> FreeTypeFont:\n        return FreeTypeFont(font, size, index, encoding, layout_engine)\n\n    try:\n        return freetype(font)\n    except OSError:\n        if not is_path(font):\n            raise\n        ttf_filename = os.path.basename(font)\n\n        dirs = []\n        if sys.platform == \"win32\":\n            # check the windows font repository\n            # NOTE: must use uppercase WINDIR, to work around bugs in\n            # 1.5.2's os.environ.get()\n            windir = os.environ.get(\"WINDIR\")\n            if windir:\n                dirs.append(os.path.join(windir, \"fonts\"))\n        elif sys.platform in (\"linux\", \"linux2\"):\n            data_home = os.environ.get(\"XDG_DATA_HOME\")\n            if not data_home:\n                # The freedesktop spec defines the following default directory for\n                # when XDG_DATA_HOME is unset or empty. This user-level directory\n                # takes precedence over system-level directories.\n                data_home = os.path.expanduser(\"~/.local/share\")\n            xdg_dirs = [data_home]\n\n            data_dirs = os.environ.get(\"XDG_DATA_DIRS\")\n            if not data_dirs:\n                # Similarly, defaults are defined for the system-level directories\n                data_dirs = \"/usr/local/share:/usr/share\"\n            xdg_dirs += data_dirs.split(\":\")\n\n            dirs += [os.path.join(xdg_dir, \"fonts\") for xdg_dir in xdg_dirs]\n        elif sys.platform == \"darwin\":\n            dirs += [\n                \"/Library/Fonts\",\n                \"/System/Library/Fonts\",\n                os.path.expanduser(\"~/Library/Fonts\"),\n            ]\n\n        ext = os.path.splitext(ttf_filename)[1]\n        first_font_with_a_different_extension = None\n        for directory in dirs:\n            for walkroot, walkdir, walkfilenames in os.walk(directory):\n                for walkfilename in walkfilenames:\n                    if ext and walkfilename == ttf_filename:\n                        return freetype(os.path.join(walkroot, walkfilename))\n                    elif not ext and os.path.splitext(walkfilename)[0] == ttf_filename:\n                        fontpath = os.path.join(walkroot, walkfilename)\n                        if os.path.splitext(fontpath)[1] == \".ttf\":\n                            return freetype(fontpath)\n                        if not ext and first_font_with_a_different_extension is None:\n                            first_font_with_a_different_extension = fontpath\n        if first_font_with_a_different_extension:\n            return freetype(first_font_with_a_different_extension)\n        raise\n\n\ndef load_path(filename: str | bytes) -> ImageFont:\n    \"\"\"\n    Load font file. Same as :py:func:`~PIL.ImageFont.load`, but searches for a\n    bitmap font along the Python path.\n\n    :param filename: Name of font file.\n    :return: A font object.\n    :exception OSError: If the file could not be read.\n    \"\"\"\n    if not isinstance(filename, str):\n        filename = filename.decode(\"utf-8\")\n    for directory in sys.path:\n        try:\n            return load(os.path.join(directory, filename))\n        except OSError:\n            pass\n    msg = \"cannot find font file\"\n    raise OSError(msg)\n\n\ndef load_default(size: float | None = None) -> FreeTypeFont | ImageFont:\n    \"\"\"If FreeType support is available, load a version of Aileron Regular,\n    https://dotcolon.net/font/aileron, with a more limited character set.\n\n    Otherwise, load a \"better than nothing\" font.\n\n    .. versionadded:: 1.1.4\n\n    :param size: The font size of Aileron Regular.\n\n        .. versionadded:: 10.1.0\n\n    :return: A font object.\n    \"\"\"\n    f: FreeTypeFont | ImageFont\n    if isinstance(core, ModuleType) or size is not None:\n        f = truetype(\n            BytesIO(\n                base64.b64decode(\n                    b\"\"\"\nAAEAAAAPAIAAAwBwRkZUTYwDlUAAADFoAAAAHEdERUYAqADnAAAo8AAAACRHUE9ThhmITwAAKfgAA\nAduR1NVQnHxefoAACkUAAAA4k9TLzJovoHLAAABeAAAAGBjbWFw5lFQMQAAA6gAAAGqZ2FzcP//AA\nMAACjoAAAACGdseWYmRXoPAAAGQAAAHfhoZWFkE18ayQAAAPwAAAA2aGhlYQboArEAAAE0AAAAJGh\ntdHjjERZ8AAAB2AAAAdBsb2NhuOexrgAABVQAAADqbWF4cAC7AEYAAAFYAAAAIG5hbWUr+h5lAAAk\nOAAAA6Jwb3N0D3oPTQAAJ9wAAAEKAAEAAAABGhxJDqIhXw889QALA+gAAAAA0Bqf2QAAAADhCh2h/\n2r/LgOxAyAAAAAIAAIAAAAAAAAAAQAAA8r/GgAAA7j/av9qA7EAAQAAAAAAAAAAAAAAAAAAAHQAAQ\nAAAHQAQwAFAAAAAAACAAAAAQABAAAAQAAAAAAAAAADAfoBkAAFAAgCigJYAAAASwKKAlgAAAFeADI\nBPgAAAAAFAAAAAAAAAAAAAAcAAAAAAAAAAAAAAABVS1dOAEAAIPsCAwL/GgDIA8oA5iAAAJMAAAAA\nAhICsgAAACAAAwH0AAAAAAAAAU0AAADYAAAA8gA5AVMAVgJEAEYCRAA1AuQAKQKOAEAAsAArATsAZ\nAE7AB4CMABVAkQAUADc/+EBEgAgANwAJQEv//sCRAApAkQAggJEADwCRAAtAkQAIQJEADkCRAArAk\nQAMgJEACwCRAAxANwAJQDc/+ECRABnAkQAUAJEAEQB8wAjA1QANgJ/AB0CcwBkArsALwLFAGQCSwB\nkAjcAZALGAC8C2gBkAQgAZAIgADcCYQBkAj8AZANiAGQCzgBkAuEALwJWAGQC3QAvAmsAZAJJADQC\nZAAiAqoAXgJuACADuAAaAnEAGQJFABMCTwAuATMAYgEv//sBJwAiAkQAUAH0ADIBLAApAhMAJAJjA\nEoCEQAeAmcAHgIlAB4BIgAVAmcAHgJRAEoA7gA+AOn/8wIKAEoA9wBGA1cASgJRAEoCSgAeAmMASg\nJnAB4BSgBKAcsAGAE5ABQCUABCAgIAAQMRAAEB4v/6AgEAAQHOABQBLwBAAPoAYAEvACECRABNA0Y\nAJAItAHgBKgAcAkQAUAEsAHQAygAgAi0AOQD3ADYA9wAWAaEANgGhABYCbAAlAYMAeAGDADkA6/9q\nAhsAFAIKABUB/QAVAAAAAwAAAAMAAAAcAAEAAAAAAKQAAwABAAAAHAAEAIgAAAAeABAAAwAOAH4Aq\nQCrALEAtAC3ALsgGSAdICYgOiBEISL7Av//AAAAIACpAKsAsAC0ALcAuyAYIBwgJiA5IEQhIvsB//\n//4/+5/7j/tP+y/7D/reBR4E/gR+A14CzfTwVxAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAEGAAABAAAAAAAAAAECAAAAAgAAAAAAAAAAAAAAAAAAAAEAAAMEBQYHCAkKCwwNDg8QERIT\nFBUWFxgZGhscHR4fICEiIyQlJicoKSorLC0uLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVGR0hJSktMT\nU5PUFFSU1RVVldYWVpbXF1eX2BhAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGQAAA\nAAAAAAYnFmAAAAAABlAAAAAAAAAAAAAAAAAAAAAAAAAAAAY2htAAAAAAAAAABrbGlqAAAAAHAAbm9\nycwBnAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAmACYAJgAmAD4AUgCCAMoBCgFO\nAVwBcgGIAaYBvAHKAdYB6AH2AgwCIAJKAogCpgLWAw4DIgNkA5wDugPUA+gD/AQQBEYEogS8BPoFJ\ngVSBWoFgAWwBcoF1gX6BhQGJAZMBmgGiga0BuIHGgdUB2YHkAeiB8AH3AfyCAoIHAgqCDoITghcCG\noIogjSCPoJKglYCXwJwgnqCgIKKApACl4Klgq8CtwLDAs8C1YLjAuyC9oL7gwMDCYMSAxgDKAMrAz\nqDQoNTA1mDYQNoA2uDcAN2g3oDfYODA4iDkoOXA5sDnoOnA7EDvwAAAAFAAAAAAH0ArwAAwAGAAkA\nDAAPAAAxESERAxMhExcRASELARETAfT6qv6syKr+jgFUqsiqArz9RAGLAP/+1P8B/v3VAP8BLP4CA\nP8AAgA5//IAuQKyAAMACwAANyMDMwIyFhQGIiY0oE4MZk84JCQ4JLQB/v3AJDgkJDgAAgBWAeUBPA\nLfAAMABwAAEyMnMxcjJzOmRgpagkYKWgHl+vr6AAAAAAIARgAAAf4CsgAbAB8AAAEHMxUjByM3Iwc\njNyM1MzcjNTM3MwczNzMHMxUrAQczAZgdZXEvOi9bLzovWmYdZXEvOi9bLzovWp9bHlsBn4w429vb\n2ziMONvb29s4jAAAAAMANf+mAg4DDAAfACYALAAAJRQGBxUjNS4BJzMeARcRLgE0Njc1MxUeARcjJ\nicVHgEBFBYXNQ4BExU+ATU0Ag5xWDpgcgRcBz41Xl9oVTpVYwpcC1ttXP6cLTQuM5szOrVRZwlOTQ\nZqVzZECAEAGlukZAlOTQdrUG8O7iNlAQgxNhDlCDj+8/YGOjReAAAAAAUAKf/yArsCvAAHAAsAFQA\ndACcAABIyFhQGIiY0EyMBMwQiBhUUFjI2NTQSMhYUBiImNDYiBhUUFjI2NTR5iFBQiFCVVwHAV/5c\nOiMjOiPmiFBQiFCxOiMjOiMCvFaSVlaS/ZoCsjIzMC80NC8w/uNWklZWkhozMC80NC8wAAAAAgBA/\n/ICbgLAACIALgAAARUjEQYjIiY1NDY3LgE1NDYzMhcVJiMiBhUUFhcWOwE1MxUFFBYzMjc1IyIHDg\nECbmBcYYOOVkg7R4hsQjY4Q0RNRD4SLDxW/pJUXzksPCkUUk0BgUb+zBVUZ0BkDw5RO1huCkULQzp\nCOAMBcHDHRz0J/AIHRQAAAAEAKwHlAIUC3wADAAATIycze0YKWgHl+gAAAAABAGT/sAEXAwwACQAA\nEzMGEBcjLgE0Nt06dXU6OUBAAwzG/jDGVePs4wAAAAEAHv+wANEDDAAJAAATMx4BFAYHIzYQHjo5Q\nEA5OnUDDFXj7ONVxgHQAAAAAQBVAFIB2wHbAA4AAAE3FwcXBycHJzcnNxcnMwEtmxOfcTJjYzJxnx\nObCj4BKD07KYolmZkliik7PbMAAQBQAFUB9AIlAAsAAAEjFSM1IzUzNTMVMwH0tTq1tTq1AR/Kyjj\nOzgAAAAAB/+H/iACMAGQABAAANwcjNzOMWlFOXVrS3AAAAQAgAP8A8gE3AAMAABMjNTPy0tIA/zgA\nAQAl//IApQByAAcAADYyFhQGIiY0STgkJDgkciQ4JCQ4AAAAAf/7/+IBNALQAAMAABcjEzM5Pvs+H\ngLuAAAAAAIAKf/yAhsCwAADAAcAABIgECA2IBAgKQHy/g5gATL+zgLA/TJEAkYAAAAAAQCCAAABlg\nKyAAgAAAERIxEHNTc2MwGWVr6SIygCsv1OAldxW1sWAAEAPAAAAg4CwAAZAAA3IRUhNRM+ATU0JiM\niDwEjNz4BMzIWFRQGB7kBUv4x+kI2QTt+EAFWAQp8aGVtSl5GRjEA/0RVLzlLmAoKa3FsUkNxXQAA\nAAEALf/yAhYCwAAqAAABHgEVFAYjIi8BMxceATMyNjU0KwE1MzI2NTQmIyIGDwEjNz4BMzIWFRQGA\nYxBSZJo2RUBVgEHV0JBUaQREUBUQzc5TQcBVgEKfGhfcEMBbxJbQl1x0AoKRkZHPn9GSD80QUVCCg\npfbGBPOlgAAAACACEAAAIkArIACgAPAAAlIxUjNSE1ATMRMyMRBg8BAiRXVv6qAVZWV60dHLCurq4\nrAdn+QgFLMibzAAABADn/8gIZArIAHQAAATIWFRQGIyIvATMXFjMyNjU0JiMiByMTIRUhBzc2ATNv\nd5Fl1RQBVgIad0VSTkVhL1IwAYj+vh8rMAHHgGdtgcUKCoFXTU5bYgGRRvAuHQAAAAACACv/8gITA\nsAAFwAjAAABMhYVFAYjIhE0NjMyFh8BIycmIyIDNzYTMjY1NCYjIgYVFBYBLmp7imr0l3RZdAgBXA\nIYZ5wKJzU6QVNJSz5SUAHSgWltiQFGxcNlVQoKdv7sPiz+ZF1LTmJbU0lhAAAAAQAyAAACGgKyAAY\nAAAEVASMBITUCGv6oXAFL/oECsij9dgJsRgAAAAMALP/xAhgCwAAWACAALAAAAR4BFRQGIyImNTQ2\nNy4BNTQ2MhYVFAYmIgYVFBYyNjU0AzI2NTQmIyIGFRQWAZQ5S5BmbIpPOjA7ecp5P2F8Q0J8RIVJS\n0pLTEtOAW0TXTxpZ2ZqPF0SE1A3VWVlVTdQ/UU0N0RENzT9/ko+Ok1NOj1LAAIAMf/yAhkCwAAXAC\nMAAAEyERQGIyImLwEzFxYzMhMHBiMiJjU0NhMyNjU0JiMiBhUUFgEl9Jd0WXQIAVwCGGecCic1SWp\n7imo+UlBAQVNJAsD+usXDZVUKCnYBFD4sgWltif5kW1NJYV1LTmIAAAACACX/8gClAiAABwAPAAAS\nMhYUBiImNBIyFhQGIiY0STgkJDgkJDgkJDgkAiAkOCQkOP52JDgkJDgAAAAC/+H/iAClAiAABwAMA\nAASMhYUBiImNBMHIzczSTgkJDgkaFpSTl4CICQ4JCQ4/mba5gAAAQBnAB4B+AH0AAYAAAENARUlNS\nUB+P6qAVb+bwGRAbCmpkbJRMkAAAIAUAC7AfQBuwADAAcAAAEhNSERITUhAfT+XAGk/lwBpAGDOP8\nAOAABAEQAHgHVAfQABgAAARUFNS0BNQHV/m8BVv6qAStEyUSmpkYAAAAAAgAj//IB1ALAABgAIAAA\nATIWFRQHDgEHIz4BNz4BNTQmIyIGByM+ARIyFhQGIiY0AQRibmktIAJWBSEqNig+NTlHBFoDezQ4J\nCQ4JALAZ1BjaS03JS1DMD5LLDQ/SUVgcv2yJDgkJDgAAAAAAgA2/5gDFgKYADYAQgAAAQMGFRQzMj\nY1NCYjIg4CFRQWMzI2NxcGIyImNTQ+AjMyFhUUBiMiJwcGIyImNTQ2MzIfATcHNzYmIyIGFRQzMjY\nCej8EJjJJlnBAfGQ+oHtAhjUYg5OPx0h2k06Os3xRWQsVLjY5VHtdPBwJETcJDyUoOkZEJz8B0f74\nEQ8kZl6EkTFZjVOLlyknMVm1pmCiaTq4lX6CSCknTVRmmR8wPdYnQzxuSWVGAAIAHQAAAncCsgAHA\nAoAACUjByMTMxMjATMDAcj+UVz4dO5d/sjPZPT0ArL9TgE6ATQAAAADAGQAAAJMArIAEAAbACcAAA\nEeARUUBgcGKwERMzIXFhUUJRUzMjc2NTQnJiMTPgE1NCcmKwEVMzIBvkdHZkwiNt7LOSGq/oeFHBt\nhahIlSTM+cB8Yj5UWAW8QT0VYYgwFArIEF5Fv1eMED2NfDAL93AU+N24PBP0AAAAAAQAv//ICjwLA\nABsAAAEyFh8BIycmIyIGFRQWMzI/ATMHDgEjIiY1NDYBdX+PCwFWAiKiaHx5ZaIiAlYBCpWBk6a0A\nsCAagoKpqN/gaOmCgplhcicn8sAAAIAZAAAAp8CsgAMABkAAAEeARUUBgcGKwERMzITPgE1NCYnJi\nsBETMyAY59lJp8IzXN0jUVWmdjWRs5d3I4Aq4QqJWUug8EArL9mQ+PeHGHDgX92gAAAAABAGQAAAI\nvArIACwAAJRUhESEVIRUhFSEVAi/+NQHB/pUBTf6zRkYCskbwRvAAAAABAGQAAAIlArIACQAAExUh\nFSERIxEhFboBQ/69VgHBAmzwRv7KArJGAAAAAAEAL//yAo8CwAAfAAABMxEjNQcGIyImNTQ2MzIWH\nwEjJyYjIgYVFBYzMjY1IwGP90wfPnWTprSSf48LAVYCIqJofHllVG+hAU3+s3hARsicn8uAagoKpq\nN/gaN1XAAAAAEAZAAAAowCsgALAAABESMRIREjETMRIRECjFb+hFZWAXwCsv1OAS7+0gKy/sQBPAA\nAAAABAGQAAAC6ArIAAwAAMyMRM7pWVgKyAAABADf/8gHoArIAEwAAAREUBw4BIyImLwEzFxYzMjc2\nNREB6AIFcGpgbQIBVgIHfXQKAQKy/lYxIltob2EpKYyEFD0BpwAAAAABAGQAAAJ0ArIACwAACQEjA\nwcVIxEzEQEzATsBJ3ntQlZWAVVlAWH+nwEnR+ACsv6RAW8AAQBkAAACLwKyAAUAACUVIREzEQIv/j\nVWRkYCsv2UAAABAGQAAAMUArIAFAAAAREjETQ3BgcDIwMmJxYVESMRMxsBAxRWAiMxemx8NxsCVo7\nMywKy/U4BY7ZLco7+nAFmoFxLtP6dArL9lwJpAAAAAAEAZAAAAoACsgANAAAhIwEWFREjETMBJjUR\nMwKAhP67A1aEAUUDVAJeeov+pwKy/aJ5jAFZAAAAAgAv//ICuwLAAAkAEwAAEiAWFRQGICY1NBIyN\njU0JiIGFRTbATSsrP7MrNrYenrYegLAxaKhxsahov47nIeIm5uIhwACAGQAAAJHArIADgAYAAABHg\nEVFAYHBisBESMRMzITNjQnJisBETMyAZRUX2VOHzuAVtY7GlxcGDWIiDUCrgtnVlVpCgT+5gKy/rU\nV1BUF/vgAAAACAC//zAK9AsAAEgAcAAAlFhcHJiMiBwYjIiY1NDYgFhUUJRQWMjY1NCYiBgI9PUMx\nUDcfKh8omqysATSs/dR62Hp62HpICTg7NgkHxqGixcWitbWHnJyHiJubAAIAZAAAAlgCsgAXACMAA\nCUWFyMmJyYnJisBESMRMzIXHgEVFAYHFiUzMjc+ATU0JyYrAQIqDCJfGQwNWhAhglbiOx9QXEY1Tv\n6bhDATMj1lGSyMtYgtOXR0BwH+1wKyBApbU0BSESRAAgVAOGoQBAABADT/8gIoAsAAJQAAATIWFyM\nuASMiBhUUFhceARUUBiMiJiczHgEzMjY1NCYnLgE1NDYBOmd2ClwGS0E6SUNRdW+HZnKKC1wPWkQ9\nUk1cZGuEAsBwXUJHNjQ3OhIbZVZZbm5kREo+NT5DFRdYUFdrAAAAAAEAIgAAAmQCsgAHAAABIxEjE\nSM1IQJk9lb2AkICbP2UAmxGAAEAXv/yAmQCsgAXAAABERQHDgEiJicmNREzERQXHgEyNjc2NRECZA\nIIgfCBCAJWAgZYmlgGAgKy/k0qFFxzc1wUKgGz/lUrEkRQUEQSKwGrAAAAAAEAIAAAAnoCsgAGAAA\nhIwMzGwEzAYJ07l3N1FwCsv2PAnEAAAEAGgAAA7ECsgAMAAABAyMLASMDMxsBMxsBA7HAcZyicrZi\nkaB0nJkCsv1OAlP9rQKy/ZsCW/2kAmYAAAEAGQAAAm8CsgALAAAhCwEjEwMzGwEzAxMCCsrEY/bkY\nre+Y/D6AST+3AFcAVb+5gEa/q3+oQAAAQATAAACUQKyAAgAAAERIxEDMxsBMwFdVvRjwLphARD+8A\nEQAaL+sQFPAAABAC4AAAI5ArIACQAAJRUhNQEhNSEVAQI5/fUBof57Aen+YUZGQgIqRkX92QAAAAA\nBAGL/sAEFAwwABwAAARUjETMVIxEBBWlpowMMOP0UOANcAAAB//v/4gE0AtAAAwAABSMDMwE0Pvs+\nHgLuAAAAAQAi/7AAxQMMAAcAABcjNTMRIzUzxaNpaaNQOALsOAABAFAA1wH0AmgABgAAJQsBIxMzE\nwGwjY1GsESw1wFZ/qcBkf5vAAAAAQAy/6oBwv/iAAMAAAUhNSEBwv5wAZBWOAAAAAEAKQJEALYCsg\nADAAATIycztjhVUAJEbgAAAAACACT/8gHQAiAAHQAlAAAhJwcGIyImNTQ2OwE1NCcmIyIHIz4BMzI\nXFh0BFBcnMjY9ASYVFAF6CR0wVUtgkJoiAgdgaQlaBm1Zrg4DCuQ9R+5MOSFQR1tbDiwUUXBUXowf\nJ8c9SjRORzYSgVwAAAAAAgBK//ICRQLfABEAHgAAATIWFRQGIyImLwEVIxEzETc2EzI2NTQmIyIGH\nQEUFgFUcYCVbiNJEyNWVigySElcU01JXmECIJd4i5QTEDRJAt/+3jkq/hRuZV55ZWsdX14AAQAe//\nIB9wIgABgAAAEyFhcjJiMiBhUUFjMyNjczDgEjIiY1NDYBF152DFocbEJXU0A1Rw1aE3pbaoKQAiB\noWH5qZm1tPDlaXYuLgZcAAAACAB7/8gIZAt8AEQAeAAABESM1BwYjIiY1NDYzMhYfAREDMjY9ATQm\nIyIGFRQWAhlWKDJacYCVbiNJEyOnSV5hQUlcUwLf/SFVOSqXeIuUExA0ARb9VWVrHV9ebmVeeQACA\nB7/8gH9AiAAFQAbAAABFAchHgEzMjY3Mw4BIyImNTQ2MzIWJyIGByEmAf0C/oAGUkA1SwlaD4FXbI\nWObmt45UBVBwEqDQEYFhNjWD84W16Oh3+akU9aU60AAAEAFQAAARoC8gAWAAATBh0BMxUjESMRIzU\nzNTQ3PgEzMhcVJqcDbW1WOTkDB0k8Hx5oAngVITRC/jQBzEIsJRs5PwVHEwAAAAIAHv8uAhkCIAAi\nAC8AAAERFAcOASMiLwEzFx4BMzI2NzY9AQcGIyImNTQ2MzIWHwE1AzI2PQE0JiMiBhUUFgIZAQSEd\nNwRAVcBBU5DTlUDASgyWnGAlW4jSRMjp0leYUFJXFMCEv5wSh1zeq8KCTI8VU0ZIQk5Kpd4i5QTED\nRJ/iJlax1fXm5lXnkAAQBKAAACCgLkABcAAAEWFREjETQnLgEHDgEdASMRMxE3NjMyFgIIAlYCBDs\n6RVRWViE5UVViAYUbQP7WASQxGzI7AQJyf+kC5P7TPSxUAAACAD4AAACsAsAABwALAAASMhYUBiIm\nNBMjETNeLiAgLiBiVlYCwCAuICAu/WACEgAC//P/LgCnAsAABwAVAAASMhYUBiImNBcRFAcGIyInN\nRY3NjURWS4gIC4gYgMLcRwNSgYCAsAgLiAgLo79wCUbZAJGBzMOHgJEAAAAAQBKAAACCALfAAsAAC\nEnBxUjETMREzMHEwGTwTJWVvdu9/rgN6kC3/4oAQv6/ugAAQBG//wA3gLfAA8AABMRFBceATcVBiM\niJicmNRGcAQIcIxkkKi4CAQLf/bkhERoSBD4EJC8SNAJKAAAAAQBKAAADEAIgACQAAAEWFREjETQn\nJiMiFREjETQnJiMiFREjETMVNzYzMhYXNzYzMhYDCwVWBAxedFYEDF50VlYiJko7ThAvJkpEVAGfI\njn+vAEcQyRZ1v76ARxDJFnW/voCEk08HzYtRB9HAAAAAAEASgAAAgoCIAAWAAABFhURIxE0JyYjIg\nYdASMRMxU3NjMyFgIIAlYCCXBEVVZWITlRVWIBhRtA/tYBJDEbbHR/6QISWz0sVAAAAAACAB7/8gI\nsAiAABwARAAASIBYUBiAmNBIyNjU0JiIGFRSlAQCHh/8Ah7ieWlqeWgIgn/Cfn/D+s3ZfYHV1YF8A\nAgBK/zwCRQIgABEAHgAAATIWFRQGIyImLwERIxEzFTc2EzI2NTQmIyIGHQEUFgFUcYCVbiNJEyNWV\nigySElcU01JXmECIJd4i5QTEDT+8wLWVTkq/hRuZV55ZWsdX14AAgAe/zwCGQIgABEAHgAAAREjEQ\ncGIyImNTQ2MzIWHwE1AzI2PQE0JiMiBhUUFgIZVigyWnGAlW4jSRMjp0leYUFJXFMCEv0qARk5Kpd\n4i5QTEDRJ/iJlax1fXm5lXnkAAQBKAAABPgIeAA0AAAEyFxUmBhURIxEzFTc2ARoWDkdXVlYwIwIe\nB0EFVlf+0gISU0cYAAEAGP/yAa0CIAAjAAATMhYXIyYjIgYVFBYXHgEVFAYjIiYnMxYzMjY1NCYnL\ngE1NDbkV2MJWhNdKy04PF1XbVhWbgxaE2ktOjlEUllkAiBaS2MrJCUoEBlPQkhOVFZoKCUmLhIWSE\nBIUwAAAAEAFP/4ARQCiQAXAAATERQXHgE3FQYjIiYnJjURIzUzNTMVMxWxAQMmMx8qMjMEAUdHVmM\nBzP7PGw4mFgY/BSwxDjQBNUJ7e0IAAAABAEL/8gICAhIAFwAAAREjNQcGIyImJyY1ETMRFBceATMy\nNj0BAgJWITlRT2EKBVYEBkA1RFECEv3uWj4qTToiOQE+/tIlJC43c4DpAAAAAAEAAQAAAfwCEgAGA\nAABAyMDMxsBAfzJaclfop8CEv3uAhL+LQHTAAABAAEAAAMLAhIADAAAAQMjCwEjAzMbATMbAQMLqW\nZ2dmapY3t0a3Z7AhL97gG+/kICEv5AAcD+QwG9AAAB//oAAAHWAhIACwAAARMjJwcjEwMzFzczARq\n8ZIuKY763ZoWFYwEO/vLV1QEMAQbNzQAAAQAB/y4B+wISABEAAAEDDgEjIic1FjMyNj8BAzMbAQH7\n2iFZQB8NDRIpNhQH02GenQIS/cFVUAJGASozEwIt/i4B0gABABQAAAGxAg4ACQAAJRUhNQEhNSEVA\nQGx/mMBNP7iAYL+zkREQgGIREX+ewAAAAABAED/sAEOAwwALAAAASMiBhUUFxYVFAYHHgEVFAcGFR\nQWOwEVIyImNTQ3NjU0JzU2NTQnJjU0NjsBAQ4MKiMLDS4pKS4NCyMqDAtERAwLUlILDERECwLUGBk\nWTlsgKzUFBTcrIFtOFhkYOC87GFVMIkUIOAhFIkxVGDsvAAAAAAEAYP84AJoDIAADAAAXIxEzmjo6\nyAPoAAEAIf+wAO8DDAAsAAATFQYVFBcWFRQGKwE1MzI2NTQnJjU0NjcuATU0NzY1NCYrATUzMhYVF\nAcGFRTvUgsMREQLDCojCw0uKSkuDQsjKgwLREQMCwF6OAhFIkxVGDsvOBgZFk5bICs1BQU3KyBbTh\nYZGDgvOxhVTCJFAAABAE0A3wH2AWQAEwAAATMUIyImJyYjIhUjNDMyFhcWMzIBvjhuGywtQR0xOG4\nbLC1BHTEBZIURGCNMhREYIwAAAwAk/94DIgLoAAcAEQApAAAAIBYQBiAmECQgBhUUFiA2NTQlMhYX\nIyYjIgYUFjMyNjczDgEjIiY1NDYBAQFE3d3+vN0CB/7wubkBELn+xVBnD1wSWDo+QTcqOQZcEmZWX\nHN2Aujg/rbg4AFKpr+Mjb6+jYxbWEldV5ZZNShLVn5na34AAgB4AFIB9AGeAAUACwAAAQcXIyc3Mw\ncXIyc3AUqJiUmJifOJiUmJiQGepqampqampqYAAAIAHAHSAQ4CwAAHAA8AABIyFhQGIiY0NiIGFBY\nyNjRgakREakSTNCEhNCECwEJqQkJqCiM4IyM4AAAAAAIAUAAAAfQCCwALAA8AAAEzFSMVIzUjNTM1\nMxMhNSEBP7W1OrW1OrX+XAGkAVs4tLQ4sP31OAAAAQB0AkQBAQKyAAMAABMjNzOsOD1QAkRuAAAAA\nAEAIADsAKoBdgAHAAASMhYUBiImNEg6KCg6KAF2KDooKDoAAAIAOQBSAbUBngAFAAsAACUHIzcnMw\nUHIzcnMwELiUmJiUkBM4lJiYlJ+KampqampqYAAAABADYB5QDhAt8ABAAAEzczByM2Xk1OXQHv8Po\nAAQAWAeUAwQLfAAQAABMHIzczwV5NTl0C1fD6AAIANgHlAYsC3wAEAAkAABM3MwcjPwEzByM2Xk1O\nXapeTU5dAe/w+grw+gAAAgAWAeUBawLfAAQACQAAEwcjNzMXByM3M8FeTU5dql5NTl0C1fD6CvD6A\nAADACX/8gI1AHIABwAPABcAADYyFhQGIiY0NjIWFAYiJjQ2MhYUBiImNEk4JCQ4JOw4JCQ4JOw4JC\nQ4JHIkOCQkOCQkOCQkOCQkOCQkOAAAAAEAeABSAUoBngAFAAABBxcjJzcBSomJSYmJAZ6mpqamAAA\nAAAEAOQBSAQsBngAFAAAlByM3JzMBC4lJiYlJ+KampgAAAf9qAAABgQKyAAMAACsBATM/VwHAVwKy\nAAAAAAIAFAHIAdwClAAHABQAABMVIxUjNSM1BRUjNwcjJxcjNTMXN9pKMkoByDICKzQqATJLKysCl\nCmjoykBy46KiY3Lm5sAAQAVAAABvALyABgAAAERIxEjESMRIzUzNTQ3NjMyFxUmBgcGHQEBvFbCVj\nk5AxHHHx5iVgcDAg798gHM/jQBzEIOJRuWBUcIJDAVIRYAAAABABX//AHkAvIAJQAAJR4BNxUGIyI\nmJyY1ESYjIgcGHQEzFSMRIxEjNTM1NDc2MzIXERQBowIcIxkkKi4CAR4nXgwDbW1WLy8DEbNdOmYa\nEQQ/BCQvEjQCFQZWFSEWQv40AcxCDiUblhP9uSEAAAAAAAAWAQ4AAQAAAAAAAAATACgAAQAAAAAAA\nQAHAEwAAQAAAAAAAgAHAGQAAQAAAAAAAwAaAKIAAQAAAAAABAAHAM0AAQAAAAAABQA8AU8AAQAAAA\nAABgAPAawAAQAAAAAACAALAdQAAQAAAAAACQALAfgAAQAAAAAACwAXAjQAAQAAAAAADAAXAnwAAwA\nBBAkAAAAmAAAAAwABBAkAAQAOADwAAwABBAkAAgAOAFQAAwABBAkAAwA0AGwAAwABBAkABAAOAL0A\nAwABBAkABQB4ANUAAwABBAkABgAeAYwAAwABBAkACAAWAbwAAwABBAkACQAWAeAAAwABBAkACwAuA\ngQAAwABBAkADAAuAkwATgBvACAAUgBpAGcAaAB0AHMAIABSAGUAcwBlAHIAdgBlAGQALgAATm8gUm\nlnaHRzIFJlc2VydmVkLgAAQQBpAGwAZQByAG8AbgAAQWlsZXJvbgAAUgBlAGcAdQBsAGEAcgAAUmV\nndWxhcgAAMQAuADEAMAAyADsAVQBLAFcATgA7AEEAaQBsAGUAcgBvAG4ALQBSAGUAZwB1AGwAYQBy\nAAAxLjEwMjtVS1dOO0FpbGVyb24tUmVndWxhcgAAQQBpAGwAZQByAG8AbgAAQWlsZXJvbgAAVgBlA\nHIAcwBpAG8AbgAgADEALgAxADAAMgA7AFAAUwAgADAAMAAxAC4AMQAwADIAOwBoAG8AdABjAG8Abg\nB2ACAAMQAuADAALgA3ADAAOwBtAGEAawBlAG8AdABmAC4AbABpAGIAMgAuADUALgA1ADgAMwAyADk\nAAFZlcnNpb24gMS4xMDI7UFMgMDAxLjEwMjtob3Rjb252IDEuMC43MDttYWtlb3RmLmxpYjIuNS41\nODMyOQAAQQBpAGwAZQByAG8AbgAtAFIAZQBnAHUAbABhAHIAAEFpbGVyb24tUmVndWxhcgAAUwBvA\nHIAYQAgAFMAYQBnAGEAbgBvAABTb3JhIFNhZ2FubwAAUwBvAHIAYQAgAFMAYQBnAGEAbgBvAABTb3\nJhIFNhZ2FubwAAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGQAbwB0AGMAbwBsAG8AbgAuAG4AZQB0AAB\nodHRwOi8vd3d3LmRvdGNvbG9uLm5ldAAAaAB0AHQAcAA6AC8ALwB3AHcAdwAuAGQAbwB0AGMAbwBs\nAG8AbgAuAG4AZQB0AABodHRwOi8vd3d3LmRvdGNvbG9uLm5ldAAAAAACAAAAAAAA/4MAMgAAAAAAA\nAAAAAAAAAAAAAAAAAAAAHQAAAABAAIAAwAEAAUABgAHAAgACQAKAAsADAANAA4ADwAQABEAEgATAB\nQAFQAWABcAGAAZABoAGwAcAB0AHgAfACAAIQAiACMAJAAlACYAJwAoACkAKgArACwALQAuAC8AMAA\nxADIAMwA0ADUANgA3ADgAOQA6ADsAPAA9AD4APwBAAEEAQgBDAEQARQBGAEcASABJAEoASwBMAE0A\nTgBPAFAAUQBSAFMAVABVAFYAVwBYAFkAWgBbAFwAXQBeAF8AYABhAIsAqQCDAJMAjQDDAKoAtgC3A\nLQAtQCrAL4AvwC8AIwAwADBAAAAAAAB//8AAgABAAAADAAAABwAAAACAAIAAwBxAAEAcgBzAAIABA\nAAAAIAAAABAAAACgBMAGYAAkRGTFQADmxhdG4AGgAEAAAAAP//AAEAAAAWAANDQVQgAB5NT0wgABZ\nST00gABYAAP//AAEAAAAA//8AAgAAAAEAAmxpZ2EADmxvY2wAFAAAAAEAAQAAAAEAAAACAAYAEAAG\nAAAAAgASADQABAAAAAEATAADAAAAAgAQABYAAQAcAAAAAQABAE8AAQABAGcAAQABAE8AAwAAAAIAE\nAAWAAEAHAAAAAEAAQAvAAEAAQBnAAEAAQAvAAEAGgABAAgAAgAGAAwAcwACAE8AcgACAEwAAQABAE\nkAAAABAAAACgBGAGAAAkRGTFQADmxhdG4AHAAEAAAAAP//AAIAAAABABYAA0NBVCAAFk1PTCAAFlJ\nPTSAAFgAA//8AAgAAAAEAAmNwc3AADmtlcm4AFAAAAAEAAAAAAAEAAQACAAYADgABAAAAAQASAAIA\nAAACAB4ANgABAAoABQAFAAoAAgABACQAPQAAAAEAEgAEAAAAAQAMAAEAOP/nAAEAAQAkAAIGigAEA\nAAFJAXKABoAGQAA//gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAD/sv+4/+z/7v/MAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAD/xAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/9T/6AAAAAD/8QAA\nABD/vQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/7gAAAAAAAAAAAAAAAAAA//MAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAP/5AAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/gAAD/4AAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//L/9AAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAA/+gAAAAAAAkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/zAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/mAAAAAAAAAAAAAAAAAAD\n/4gAA//AAAAAA//YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/+AAAAAAAAP/OAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/zv/qAAAAAP/0AAAACAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAP/ZAAD/egAA/1kAAAAA/5D/rgAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAD/9AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAD/8AAA/7b/8P+wAAD/8P/E/98AAAAA/8P/+P/0//oAAAAAAAAAAAAA//gA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA/+AAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/w//C/9MAAP/SAAD/9wAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/yAAA/+kAAAAA//QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/9wAAAAD//QAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAP/2AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAP/cAAAAAAAAAAAAAAAA/7YAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAP/8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD/6AAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAkAFAAEAAAAAQACwAAABcA\nBgAAAAAAAAAIAA4AAAAAAAsAEgAAAAAAAAATABkAAwANAAAAAQAJAAAAAAAAAAAAAAAAAAAAGAAAA\nAAABwAAAAAAAAAAAAAAFQAFAAAAAAAYABgAAAAUAAAACgAAAAwAAgAPABEAFgAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAFAAEAEQBdAAYAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAcAAAAAAAAABwAAAAAACAAAAAAAAAAAAAcAAAAHAAAAEwAJ\nABUADgAPAAAACwAQAAAAAAAAAAAAAAAAAAUAGAACAAIAAgAAAAIAGAAXAAAAGAAAABYAFgACABYAA\ngAWAAAAEQADAAoAFAAMAA0ABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAASAAAAEgAGAAEAHgAkAC\nYAJwApACoALQAuAC8AMgAzADcAOAA5ADoAPAA9AEUASABOAE8AUgBTAFUAVwBZAFoAWwBcAF0AcwA\nAAAAAAQAAAADa3tfFAAAAANAan9kAAAAA4QodoQ==\n\"\"\"\n                )\n            ),\n            10 if size is None else size,\n            layout_engine=Layout.BASIC,\n        )\n    else:\n        f = ImageFont()\n        f._load_pilfont_data(\n            # courB08\n            BytesIO(\n                base64.b64decode(\n                    b\"\"\"\nUElMZm9udAo7Ozs7OzsxMDsKREFUQQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAA//8AAQAAAAAAAAABAAEA\nBgAAAAH/+gADAAAAAQAAAAMABgAGAAAAAf/6AAT//QADAAAABgADAAYAAAAA//kABQABAAYAAAAL\nAAgABgAAAAD/+AAFAAEACwAAABAACQAGAAAAAP/5AAUAAAAQAAAAFQAHAAYAAP////oABQAAABUA\nAAAbAAYABgAAAAH/+QAE//wAGwAAAB4AAwAGAAAAAf/5AAQAAQAeAAAAIQAIAAYAAAAB//kABAAB\nACEAAAAkAAgABgAAAAD/+QAE//0AJAAAACgABAAGAAAAAP/6AAX//wAoAAAALQAFAAYAAAAB//8A\nBAACAC0AAAAwAAMABgAAAAD//AAF//0AMAAAADUAAQAGAAAAAf//AAMAAAA1AAAANwABAAYAAAAB\n//kABQABADcAAAA7AAgABgAAAAD/+QAFAAAAOwAAAEAABwAGAAAAAP/5AAYAAABAAAAARgAHAAYA\nAAAA//kABQAAAEYAAABLAAcABgAAAAD/+QAFAAAASwAAAFAABwAGAAAAAP/5AAYAAABQAAAAVgAH\nAAYAAAAA//kABQAAAFYAAABbAAcABgAAAAD/+QAFAAAAWwAAAGAABwAGAAAAAP/5AAUAAABgAAAA\nZQAHAAYAAAAA//kABQAAAGUAAABqAAcABgAAAAD/+QAFAAAAagAAAG8ABwAGAAAAAf/8AAMAAABv\nAAAAcQAEAAYAAAAA//wAAwACAHEAAAB0AAYABgAAAAD/+gAE//8AdAAAAHgABQAGAAAAAP/7AAT/\n/gB4AAAAfAADAAYAAAAB//oABf//AHwAAACAAAUABgAAAAD/+gAFAAAAgAAAAIUABgAGAAAAAP/5\nAAYAAQCFAAAAiwAIAAYAAP////oABgAAAIsAAACSAAYABgAA////+gAFAAAAkgAAAJgABgAGAAAA\nAP/6AAUAAACYAAAAnQAGAAYAAP////oABQAAAJ0AAACjAAYABgAA////+gAFAAAAowAAAKkABgAG\nAAD////6AAUAAACpAAAArwAGAAYAAAAA//oABQAAAK8AAAC0AAYABgAA////+gAGAAAAtAAAALsA\nBgAGAAAAAP/6AAQAAAC7AAAAvwAGAAYAAP////oABQAAAL8AAADFAAYABgAA////+gAGAAAAxQAA\nAMwABgAGAAD////6AAUAAADMAAAA0gAGAAYAAP////oABQAAANIAAADYAAYABgAA////+gAGAAAA\n2AAAAN8ABgAGAAAAAP/6AAUAAADfAAAA5AAGAAYAAP////oABQAAAOQAAADqAAYABgAAAAD/+gAF\nAAEA6gAAAO8ABwAGAAD////6AAYAAADvAAAA9gAGAAYAAAAA//oABQAAAPYAAAD7AAYABgAA////\n+gAFAAAA+wAAAQEABgAGAAD////6AAYAAAEBAAABCAAGAAYAAP////oABgAAAQgAAAEPAAYABgAA\n////+gAGAAABDwAAARYABgAGAAAAAP/6AAYAAAEWAAABHAAGAAYAAP////oABgAAARwAAAEjAAYA\nBgAAAAD/+gAFAAABIwAAASgABgAGAAAAAf/5AAQAAQEoAAABKwAIAAYAAAAA//kABAABASsAAAEv\nAAgABgAAAAH/+QAEAAEBLwAAATIACAAGAAAAAP/5AAX//AEyAAABNwADAAYAAAAAAAEABgACATcA\nAAE9AAEABgAAAAH/+QAE//wBPQAAAUAAAwAGAAAAAP/7AAYAAAFAAAABRgAFAAYAAP////kABQAA\nAUYAAAFMAAcABgAAAAD/+wAFAAABTAAAAVEABQAGAAAAAP/5AAYAAAFRAAABVwAHAAYAAAAA//sA\nBQAAAVcAAAFcAAUABgAAAAD/+QAFAAABXAAAAWEABwAGAAAAAP/7AAYAAgFhAAABZwAHAAYAAP//\n//kABQAAAWcAAAFtAAcABgAAAAD/+QAGAAABbQAAAXMABwAGAAAAAP/5AAQAAgFzAAABdwAJAAYA\nAP////kABgAAAXcAAAF+AAcABgAAAAD/+QAGAAABfgAAAYQABwAGAAD////7AAUAAAGEAAABigAF\nAAYAAP////sABQAAAYoAAAGQAAUABgAAAAD/+wAFAAABkAAAAZUABQAGAAD////7AAUAAgGVAAAB\nmwAHAAYAAAAA//sABgACAZsAAAGhAAcABgAAAAD/+wAGAAABoQAAAacABQAGAAAAAP/7AAYAAAGn\nAAABrQAFAAYAAAAA//kABgAAAa0AAAGzAAcABgAA////+wAGAAABswAAAboABQAGAAD////7AAUA\nAAG6AAABwAAFAAYAAP////sABgAAAcAAAAHHAAUABgAAAAD/+wAGAAABxwAAAc0ABQAGAAD////7\nAAYAAgHNAAAB1AAHAAYAAAAA//sABQAAAdQAAAHZAAUABgAAAAH/+QAFAAEB2QAAAd0ACAAGAAAA\nAv/6AAMAAQHdAAAB3gAHAAYAAAAA//kABAABAd4AAAHiAAgABgAAAAD/+wAF//0B4gAAAecAAgAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\nAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAYAAAAB\n//sAAwACAecAAAHpAAcABgAAAAD/+QAFAAEB6QAAAe4ACAAGAAAAAP/5AAYAAAHuAAAB9AAHAAYA\nAAAA//oABf//AfQAAAH5AAUABgAAAAD/+QAGAAAB+QAAAf8ABwAGAAAAAv/5AAMAAgH/AAACAAAJ\nAAYAAAAA//kABQABAgAAAAIFAAgABgAAAAH/+gAE//sCBQAAAggAAQAGAAAAAP/5AAYAAAIIAAAC\nDgAHAAYAAAAB//kABf/+Ag4AAAISAAUABgAA////+wAGAAACEgAAAhkABQAGAAAAAP/7AAX//gIZ\nAAACHgADAAYAAAAA//wABf/9Ah4AAAIjAAEABgAAAAD/+QAHAAACIwAAAioABwAGAAAAAP/6AAT/\n+wIqAAACLgABAAYAAAAA//kABP/8Ai4AAAIyAAMABgAAAAD/+gAFAAACMgAAAjcABgAGAAAAAf/5\nAAT//QI3AAACOgAEAAYAAAAB//kABP/9AjoAAAI9AAQABgAAAAL/+QAE//sCPQAAAj8AAgAGAAD/\n///7AAYAAgI/AAACRgAHAAYAAAAA//kABgABAkYAAAJMAAgABgAAAAH//AAD//0CTAAAAk4AAQAG\nAAAAAf//AAQAAgJOAAACUQADAAYAAAAB//kABP/9AlEAAAJUAAQABgAAAAH/+QAF//4CVAAAAlgA\nBQAGAAD////7AAYAAAJYAAACXwAFAAYAAP////kABgAAAl8AAAJmAAcABgAA////+QAGAAACZgAA\nAm0ABwAGAAD////5AAYAAAJtAAACdAAHAAYAAAAA//sABQACAnQAAAJ5AAcABgAA////9wAGAAAC\neQAAAoAACQAGAAD////3AAYAAAKAAAAChwAJAAYAAP////cABgAAAocAAAKOAAkABgAA////9wAG\nAAACjgAAApUACQAGAAD////4AAYAAAKVAAACnAAIAAYAAP////cABgAAApwAAAKjAAkABgAA////\n+gAGAAACowAAAqoABgAGAAAAAP/6AAUAAgKqAAACrwAIAAYAAP////cABQAAAq8AAAK1AAkABgAA\n////9wAFAAACtQAAArsACQAGAAD////3AAUAAAK7AAACwQAJAAYAAP////gABQAAAsEAAALHAAgA\nBgAAAAD/9wAEAAACxwAAAssACQAGAAAAAP/3AAQAAALLAAACzwAJAAYAAAAA//cABAAAAs8AAALT\nAAkABgAAAAD/+AAEAAAC0wAAAtcACAAGAAD////6AAUAAALXAAAC3QAGAAYAAP////cABgAAAt0A\nAALkAAkABgAAAAD/9wAFAAAC5AAAAukACQAGAAAAAP/3AAUAAALpAAAC7gAJAAYAAAAA//cABQAA\nAu4AAALzAAkABgAAAAD/9wAFAAAC8wAAAvgACQAGAAAAAP/4AAUAAAL4AAAC/QAIAAYAAAAA//oA\nBf//Av0AAAMCAAUABgAA////+gAGAAADAgAAAwkABgAGAAD////3AAYAAAMJAAADEAAJAAYAAP//\n//cABgAAAxAAAAMXAAkABgAA////9wAGAAADFwAAAx4ACQAGAAD////4AAYAAAAAAAoABwASAAYA\nAP////cABgAAAAcACgAOABMABgAA////+gAFAAAADgAKABQAEAAGAAD////6AAYAAAAUAAoAGwAQ\nAAYAAAAA//gABgAAABsACgAhABIABgAAAAD/+AAGAAAAIQAKACcAEgAGAAAAAP/4AAYAAAAnAAoA\nLQASAAYAAAAA//gABgAAAC0ACgAzABIABgAAAAD/+QAGAAAAMwAKADkAEQAGAAAAAP/3AAYAAAA5\nAAoAPwATAAYAAP////sABQAAAD8ACgBFAA8ABgAAAAD/+wAFAAIARQAKAEoAEQAGAAAAAP/4AAUA\nAABKAAoATwASAAYAAAAA//gABQAAAE8ACgBUABIABgAAAAD/+AAFAAAAVAAKAFkAEgAGAAAAAP/5\nAAUAAABZAAoAXgARAAYAAAAA//gABgAAAF4ACgBkABIABgAAAAD/+AAGAAAAZAAKAGoAEgAGAAAA\nAP/4AAYAAABqAAoAcAASAAYAAAAA//kABgAAAHAACgB2ABEABgAAAAD/+AAFAAAAdgAKAHsAEgAG\nAAD////4AAYAAAB7AAoAggASAAYAAAAA//gABQAAAIIACgCHABIABgAAAAD/+AAFAAAAhwAKAIwA\nEgAGAAAAAP/4AAUAAACMAAoAkQASAAYAAAAA//gABQAAAJEACgCWABIABgAAAAD/+QAFAAAAlgAK\nAJsAEQAGAAAAAP/6AAX//wCbAAoAoAAPAAYAAAAA//oABQABAKAACgClABEABgAA////+AAGAAAA\npQAKAKwAEgAGAAD////4AAYAAACsAAoAswASAAYAAP////gABgAAALMACgC6ABIABgAA////+QAG\nAAAAugAKAMEAEQAGAAD////4AAYAAgDBAAoAyAAUAAYAAP////kABQACAMgACgDOABMABgAA////\n+QAGAAIAzgAKANUAEw==\n\"\"\"\n                )\n            ),\n            Image.open(\n                BytesIO(\n                    base64.b64decode(\n                        b\"\"\"\niVBORw0KGgoAAAANSUhEUgAAAx4AAAAUAQAAAAArMtZoAAAEwElEQVR4nABlAJr/AHVE4czCI/4u\nMc4b7vuds/xzjz5/3/7u/n9vMe7vnfH/9++vPn/xyf5zhxzjt8GHw8+2d83u8x27199/nxuQ6Od9\nM43/5z2I+9n9ZtmDBwMQECDRQw/eQIQohJXxpBCNVE6QCCAAAAD//wBlAJr/AgALyj1t/wINwq0g\nLeNZUworuN1cjTPIzrTX6ofHWeo3v336qPzfEwRmBnHTtf95/fglZK5N0PDgfRTslpGBvz7LFc4F\nIUXBWQGjQ5MGCx34EDFPwXiY4YbYxavpnhHFrk14CDAAAAD//wBlAJr/AgKqRooH2gAgPeggvUAA\nBu2WfgPoAwzRAABAAAAAAACQgLz/3Uv4Gv+gX7BJgDeeGP6AAAD1NMDzKHD7ANWr3loYbxsAD791\nNAADfcoIDyP44K/jv4Y63/Z+t98Ovt+ub4T48LAAAAD//wBlAJr/AuplMlADJAAAAGuAphWpqhMx\nin0A/fRvAYBABPgBwBUgABBQ/sYAyv9g0bCHgOLoGAAAAAAAREAAwI7nr0ArYpow7aX8//9LaP/9\nSjdavWA8ePHeBIKB//81/83ndznOaXx379wAAAD//wBlAJr/AqDxW+D3AABAAbUh/QMnbQag/gAY\nAYDAAACgtgD/gOqAAAB5IA/8AAAk+n9w0AAA8AAAmFRJuPo27ciC0cD5oeW4E7KA/wD3ECMAn2tt\ny8PgwH8AfAxFzC0JzeAMtratAsC/ffwAAAD//wBlAJr/BGKAyCAA4AAAAvgeYTAwHd1kmQF5chkG\nABoMIHcL5xVpTfQbUqzlAAAErwAQBgAAEOClA5D9il08AEh/tUzdCBsXkbgACED+woQg8Si9VeqY\nlODCn7lmF6NhnAEYgAAA/NMIAAAAAAD//2JgjLZgVGBg5Pv/Tvpc8hwGBjYGJADjHDrAwPzAjv/H\n/Wf3PzCwtzcwHmBgYGcwbZz8wHaCAQMDOwMDQ8MCBgYOC3W7mp+f0w+wHOYxO3OG+e376hsMZjk3\nAAAAAP//YmCMY2A4wMAIN5e5gQETPD6AZisDAwMDgzSDAAPjByiHcQMDAwMDg1nOze1lByRu5/47\nc4859311AYNZzg0AAAAA//9iYGDBYihOIIMuwIjGL39/fwffA8b//xv/P2BPtzzHwCBjUQAAAAD/\n/yLFBrIBAAAA//9i1HhcwdhizX7u8NZNzyLbvT97bfrMf/QHI8evOwcSqGUJAAAA//9iYBB81iSw\npEE170Qrg5MIYydHqwdDQRMrAwcVrQAAAAD//2J4x7j9AAMDn8Q/BgYLBoaiAwwMjPdvMDBYM1Tv\noJodAAAAAP//Yqo/83+dxePWlxl3npsel9lvLfPcqlE9725C+acfVLMEAAAA//9i+s9gwCoaaGMR\nevta/58PTEWzr21hufPjA8N+qlnBwAAAAAD//2JiWLci5v1+HmFXDqcnULE/MxgYGBj+f6CaJQAA\nAAD//2Ji2FrkY3iYpYC5qDeGgeEMAwPDvwQBBoYvcTwOVLMEAAAA//9isDBgkP///0EOg9z35v//\nGc/eeW7BwPj5+QGZhANUswMAAAD//2JgqGBgYGBgqEMXlvhMPUsAAAAA//8iYDd1AAAAAP//AwDR\nw7IkEbzhVQAAAABJRU5ErkJggg==\n\"\"\"\n                    )\n                )\n            ),\n        )\n    return f\n", "src/PIL/ImageDraw.py": "#\n# The Python Imaging Library\n# $Id$\n#\n# drawing interface operations\n#\n# History:\n# 1996-04-13 fl   Created (experimental)\n# 1996-08-07 fl   Filled polygons, ellipses.\n# 1996-08-13 fl   Added text support\n# 1998-06-28 fl   Handle I and F images\n# 1998-12-29 fl   Added arc; use arc primitive to draw ellipses\n# 1999-01-10 fl   Added shape stuff (experimental)\n# 1999-02-06 fl   Added bitmap support\n# 1999-02-11 fl   Changed all primitives to take options\n# 1999-02-20 fl   Fixed backwards compatibility\n# 2000-10-12 fl   Copy on write, when necessary\n# 2001-02-18 fl   Use default ink for bitmap/text also in fill mode\n# 2002-10-24 fl   Added support for CSS-style color strings\n# 2002-12-10 fl   Added experimental support for RGBA-on-RGB drawing\n# 2002-12-11 fl   Refactored low-level drawing API (work in progress)\n# 2004-08-26 fl   Made Draw() a factory function, added getdraw() support\n# 2004-09-04 fl   Added width support to line primitive\n# 2004-09-10 fl   Added font mode handling\n# 2006-06-19 fl   Added font bearing support (getmask2)\n#\n# Copyright (c) 1997-2006 by Secret Labs AB\n# Copyright (c) 1996-2006 by Fredrik Lundh\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport math\nimport numbers\nimport struct\nfrom types import ModuleType\nfrom typing import TYPE_CHECKING, AnyStr, Callable, List, Sequence, Tuple, Union, cast\n\nfrom . import Image, ImageColor\nfrom ._deprecate import deprecate\nfrom ._typing import Coords\n\n# experimental access to the outline API\nOutline: Callable[[], Image.core._Outline] | None\ntry:\n    Outline = Image.core.outline\nexcept AttributeError:\n    Outline = None\n\nif TYPE_CHECKING:\n    from . import ImageDraw2, ImageFont\n\n_Ink = Union[float, Tuple[int, ...], str]\n\n\"\"\"\nA simple 2D drawing interface for PIL images.\n<p>\nApplication code should use the <b>Draw</b> factory, instead of\ndirectly.\n\"\"\"\n\n\nclass ImageDraw:\n    font: (\n        ImageFont.ImageFont | ImageFont.FreeTypeFont | ImageFont.TransposedFont | None\n    ) = None\n\n    def __init__(self, im: Image.Image, mode: str | None = None) -> None:\n        \"\"\"\n        Create a drawing instance.\n\n        :param im: The image to draw in.\n        :param mode: Optional mode to use for color values.  For RGB\n           images, this argument can be RGB or RGBA (to blend the\n           drawing into the image).  For all other modes, this argument\n           must be the same as the image mode.  If omitted, the mode\n           defaults to the mode of the image.\n        \"\"\"\n        im.load()\n        if im.readonly:\n            im._copy()  # make it writeable\n        blend = 0\n        if mode is None:\n            mode = im.mode\n        if mode != im.mode:\n            if mode == \"RGBA\" and im.mode == \"RGB\":\n                blend = 1\n            else:\n                msg = \"mode mismatch\"\n                raise ValueError(msg)\n        if mode == \"P\":\n            self.palette = im.palette\n        else:\n            self.palette = None\n        self._image = im\n        self.im = im.im\n        self.draw = Image.core.draw(self.im, blend)\n        self.mode = mode\n        if mode in (\"I\", \"F\"):\n            self.ink = self.draw.draw_ink(1)\n        else:\n            self.ink = self.draw.draw_ink(-1)\n        if mode in (\"1\", \"P\", \"I\", \"F\"):\n            # FIXME: fix Fill2 to properly support matte for I+F images\n            self.fontmode = \"1\"\n        else:\n            self.fontmode = \"L\"  # aliasing is okay for other modes\n        self.fill = False\n\n    def getfont(\n        self,\n    ) -> ImageFont.ImageFont | ImageFont.FreeTypeFont | ImageFont.TransposedFont:\n        \"\"\"\n        Get the current default font.\n\n        To set the default font for this ImageDraw instance::\n\n            from PIL import ImageDraw, ImageFont\n            draw.font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\")\n\n        To set the default font for all future ImageDraw instances::\n\n            from PIL import ImageDraw, ImageFont\n            ImageDraw.ImageDraw.font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\")\n\n        If the current default font is ``None``,\n        it is initialized with ``ImageFont.load_default()``.\n\n        :returns: An image font.\"\"\"\n        if not self.font:\n            # FIXME: should add a font repository\n            from . import ImageFont\n\n            self.font = ImageFont.load_default()\n        return self.font\n\n    def _getfont(\n        self, font_size: float | None\n    ) -> ImageFont.ImageFont | ImageFont.FreeTypeFont | ImageFont.TransposedFont:\n        if font_size is not None:\n            from . import ImageFont\n\n            return ImageFont.load_default(font_size)\n        else:\n            return self.getfont()\n\n    def _getink(\n        self, ink: _Ink | None, fill: _Ink | None = None\n    ) -> tuple[int | None, int | None]:\n        result_ink = None\n        result_fill = None\n        if ink is None and fill is None:\n            if self.fill:\n                result_fill = self.ink\n            else:\n                result_ink = self.ink\n        else:\n            if ink is not None:\n                if isinstance(ink, str):\n                    ink = ImageColor.getcolor(ink, self.mode)\n                if self.palette and not isinstance(ink, numbers.Number):\n                    ink = self.palette.getcolor(ink, self._image)\n                result_ink = self.draw.draw_ink(ink)\n            if fill is not None:\n                if isinstance(fill, str):\n                    fill = ImageColor.getcolor(fill, self.mode)\n                if self.palette and not isinstance(fill, numbers.Number):\n                    fill = self.palette.getcolor(fill, self._image)\n                result_fill = self.draw.draw_ink(fill)\n        return result_ink, result_fill\n\n    def arc(\n        self,\n        xy: Coords,\n        start: float,\n        end: float,\n        fill: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw an arc.\"\"\"\n        ink, fill = self._getink(fill)\n        if ink is not None:\n            self.draw.draw_arc(xy, start, end, ink, width)\n\n    def bitmap(\n        self, xy: Sequence[int], bitmap: Image.Image, fill: _Ink | None = None\n    ) -> None:\n        \"\"\"Draw a bitmap.\"\"\"\n        bitmap.load()\n        ink, fill = self._getink(fill)\n        if ink is None:\n            ink = fill\n        if ink is not None:\n            self.draw.draw_bitmap(xy, bitmap.im, ink)\n\n    def chord(\n        self,\n        xy: Coords,\n        start: float,\n        end: float,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a chord.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_chord(xy, start, end, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_chord(xy, start, end, ink, 0, width)\n\n    def ellipse(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw an ellipse.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_ellipse(xy, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_ellipse(xy, ink, 0, width)\n\n    def circle(\n        self,\n        xy: Sequence[float],\n        radius: float,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a circle given center coordinates and a radius.\"\"\"\n        ellipse_xy = (xy[0] - radius, xy[1] - radius, xy[0] + radius, xy[1] + radius)\n        self.ellipse(ellipse_xy, fill, outline, width)\n\n    def line(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        width: int = 0,\n        joint: str | None = None,\n    ) -> None:\n        \"\"\"Draw a line, or a connected sequence of line segments.\"\"\"\n        ink = self._getink(fill)[0]\n        if ink is not None:\n            self.draw.draw_lines(xy, ink, width)\n            if joint == \"curve\" and width > 4:\n                points: Sequence[Sequence[float]]\n                if isinstance(xy[0], (list, tuple)):\n                    points = cast(Sequence[Sequence[float]], xy)\n                else:\n                    points = [\n                        cast(Sequence[float], tuple(xy[i : i + 2]))\n                        for i in range(0, len(xy), 2)\n                    ]\n                for i in range(1, len(points) - 1):\n                    point = points[i]\n                    angles = [\n                        math.degrees(math.atan2(end[0] - start[0], start[1] - end[1]))\n                        % 360\n                        for start, end in (\n                            (points[i - 1], point),\n                            (point, points[i + 1]),\n                        )\n                    ]\n                    if angles[0] == angles[1]:\n                        # This is a straight line, so no joint is required\n                        continue\n\n                    def coord_at_angle(\n                        coord: Sequence[float], angle: float\n                    ) -> tuple[float, ...]:\n                        x, y = coord\n                        angle -= 90\n                        distance = width / 2 - 1\n                        return tuple(\n                            p + (math.floor(p_d) if p_d > 0 else math.ceil(p_d))\n                            for p, p_d in (\n                                (x, distance * math.cos(math.radians(angle))),\n                                (y, distance * math.sin(math.radians(angle))),\n                            )\n                        )\n\n                    flipped = (\n                        angles[1] > angles[0] and angles[1] - 180 > angles[0]\n                    ) or (angles[1] < angles[0] and angles[1] + 180 > angles[0])\n                    coords = [\n                        (point[0] - width / 2 + 1, point[1] - width / 2 + 1),\n                        (point[0] + width / 2 - 1, point[1] + width / 2 - 1),\n                    ]\n                    if flipped:\n                        start, end = (angles[1] + 90, angles[0] + 90)\n                    else:\n                        start, end = (angles[0] - 90, angles[1] - 90)\n                    self.pieslice(coords, start - 90, end - 90, fill)\n\n                    if width > 8:\n                        # Cover potential gaps between the line and the joint\n                        if flipped:\n                            gap_coords = [\n                                coord_at_angle(point, angles[0] + 90),\n                                point,\n                                coord_at_angle(point, angles[1] + 90),\n                            ]\n                        else:\n                            gap_coords = [\n                                coord_at_angle(point, angles[0] - 90),\n                                point,\n                                coord_at_angle(point, angles[1] - 90),\n                            ]\n                        self.line(gap_coords, fill, width=3)\n\n    def shape(\n        self,\n        shape: Image.core._Outline,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n    ) -> None:\n        \"\"\"(Experimental) Draw a shape.\"\"\"\n        shape.close()\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_outline(shape, fill_ink, 1)\n        if ink is not None and ink != fill_ink:\n            self.draw.draw_outline(shape, ink, 0)\n\n    def pieslice(\n        self,\n        xy: Coords,\n        start: float,\n        end: float,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a pieslice.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_pieslice(xy, start, end, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_pieslice(xy, start, end, ink, 0, width)\n\n    def point(self, xy: Coords, fill: _Ink | None = None) -> None:\n        \"\"\"Draw one or more individual pixels.\"\"\"\n        ink, fill = self._getink(fill)\n        if ink is not None:\n            self.draw.draw_points(xy, ink)\n\n    def polygon(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a polygon.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_polygon(xy, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            if width == 1:\n                self.draw.draw_polygon(xy, ink, 0, width)\n            elif self.im is not None:\n                # To avoid expanding the polygon outwards,\n                # use the fill as a mask\n                mask = Image.new(\"1\", self.im.size)\n                mask_ink = self._getink(1)[0]\n\n                fill_im = mask.copy()\n                draw = Draw(fill_im)\n                draw.draw.draw_polygon(xy, mask_ink, 1)\n\n                ink_im = mask.copy()\n                draw = Draw(ink_im)\n                width = width * 2 - 1\n                draw.draw.draw_polygon(xy, mask_ink, 0, width)\n\n                mask.paste(ink_im, mask=fill_im)\n\n                im = Image.new(self.mode, self.im.size)\n                draw = Draw(im)\n                draw.draw.draw_polygon(xy, ink, 0, width)\n                self.im.paste(im.im, (0, 0) + im.size, mask.im)\n\n    def regular_polygon(\n        self,\n        bounding_circle: Sequence[Sequence[float] | float],\n        n_sides: int,\n        rotation: float = 0,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a regular polygon.\"\"\"\n        xy = _compute_regular_polygon_vertices(bounding_circle, n_sides, rotation)\n        self.polygon(xy, fill, outline, width)\n\n    def rectangle(\n        self,\n        xy: Coords,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n    ) -> None:\n        \"\"\"Draw a rectangle.\"\"\"\n        ink, fill_ink = self._getink(outline, fill)\n        if fill_ink is not None:\n            self.draw.draw_rectangle(xy, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            self.draw.draw_rectangle(xy, ink, 0, width)\n\n    def rounded_rectangle(\n        self,\n        xy: Coords,\n        radius: float = 0,\n        fill: _Ink | None = None,\n        outline: _Ink | None = None,\n        width: int = 1,\n        *,\n        corners: tuple[bool, bool, bool, bool] | None = None,\n    ) -> None:\n        \"\"\"Draw a rounded rectangle.\"\"\"\n        if isinstance(xy[0], (list, tuple)):\n            (x0, y0), (x1, y1) = cast(Sequence[Sequence[float]], xy)\n        else:\n            x0, y0, x1, y1 = cast(Sequence[float], xy)\n        if x1 < x0:\n            msg = \"x1 must be greater than or equal to x0\"\n            raise ValueError(msg)\n        if y1 < y0:\n            msg = \"y1 must be greater than or equal to y0\"\n            raise ValueError(msg)\n        if corners is None:\n            corners = (True, True, True, True)\n\n        d = radius * 2\n\n        x0 = round(x0)\n        y0 = round(y0)\n        x1 = round(x1)\n        y1 = round(y1)\n        full_x, full_y = False, False\n        if all(corners):\n            full_x = d >= x1 - x0 - 1\n            if full_x:\n                # The two left and two right corners are joined\n                d = x1 - x0\n            full_y = d >= y1 - y0 - 1\n            if full_y:\n                # The two top and two bottom corners are joined\n                d = y1 - y0\n            if full_x and full_y:\n                # If all corners are joined, that is a circle\n                return self.ellipse(xy, fill, outline, width)\n\n        if d == 0 or not any(corners):\n            # If the corners have no curve,\n            # or there are no corners,\n            # that is a rectangle\n            return self.rectangle(xy, fill, outline, width)\n\n        r = int(d // 2)\n        ink, fill_ink = self._getink(outline, fill)\n\n        def draw_corners(pieslice: bool) -> None:\n            parts: tuple[tuple[tuple[float, float, float, float], int, int], ...]\n            if full_x:\n                # Draw top and bottom halves\n                parts = (\n                    ((x0, y0, x0 + d, y0 + d), 180, 360),\n                    ((x0, y1 - d, x0 + d, y1), 0, 180),\n                )\n            elif full_y:\n                # Draw left and right halves\n                parts = (\n                    ((x0, y0, x0 + d, y0 + d), 90, 270),\n                    ((x1 - d, y0, x1, y0 + d), 270, 90),\n                )\n            else:\n                # Draw four separate corners\n                parts = tuple(\n                    part\n                    for i, part in enumerate(\n                        (\n                            ((x0, y0, x0 + d, y0 + d), 180, 270),\n                            ((x1 - d, y0, x1, y0 + d), 270, 360),\n                            ((x1 - d, y1 - d, x1, y1), 0, 90),\n                            ((x0, y1 - d, x0 + d, y1), 90, 180),\n                        )\n                    )\n                    if corners[i]\n                )\n            for part in parts:\n                if pieslice:\n                    self.draw.draw_pieslice(*(part + (fill_ink, 1)))\n                else:\n                    self.draw.draw_arc(*(part + (ink, width)))\n\n        if fill_ink is not None:\n            draw_corners(True)\n\n            if full_x:\n                self.draw.draw_rectangle((x0, y0 + r + 1, x1, y1 - r - 1), fill_ink, 1)\n            else:\n                self.draw.draw_rectangle((x0 + r + 1, y0, x1 - r - 1, y1), fill_ink, 1)\n            if not full_x and not full_y:\n                left = [x0, y0, x0 + r, y1]\n                if corners[0]:\n                    left[1] += r + 1\n                if corners[3]:\n                    left[3] -= r + 1\n                self.draw.draw_rectangle(left, fill_ink, 1)\n\n                right = [x1 - r, y0, x1, y1]\n                if corners[1]:\n                    right[1] += r + 1\n                if corners[2]:\n                    right[3] -= r + 1\n                self.draw.draw_rectangle(right, fill_ink, 1)\n        if ink is not None and ink != fill_ink and width != 0:\n            draw_corners(False)\n\n            if not full_x:\n                top = [x0, y0, x1, y0 + width - 1]\n                if corners[0]:\n                    top[0] += r + 1\n                if corners[1]:\n                    top[2] -= r + 1\n                self.draw.draw_rectangle(top, ink, 1)\n\n                bottom = [x0, y1 - width + 1, x1, y1]\n                if corners[3]:\n                    bottom[0] += r + 1\n                if corners[2]:\n                    bottom[2] -= r + 1\n                self.draw.draw_rectangle(bottom, ink, 1)\n            if not full_y:\n                left = [x0, y0, x0 + width - 1, y1]\n                if corners[0]:\n                    left[1] += r + 1\n                if corners[3]:\n                    left[3] -= r + 1\n                self.draw.draw_rectangle(left, ink, 1)\n\n                right = [x1 - width + 1, y0, x1, y1]\n                if corners[1]:\n                    right[1] += r + 1\n                if corners[2]:\n                    right[3] -= r + 1\n                self.draw.draw_rectangle(right, ink, 1)\n\n    def _multiline_check(self, text: AnyStr) -> bool:\n        split_character = \"\\n\" if isinstance(text, str) else b\"\\n\"\n\n        return split_character in text\n\n    def _multiline_split(self, text: AnyStr) -> list[AnyStr]:\n        return text.split(\"\\n\" if isinstance(text, str) else b\"\\n\")\n\n    def _multiline_spacing(self, font, spacing, stroke_width):\n        return (\n            self.textbbox((0, 0), \"A\", font, stroke_width=stroke_width)[3]\n            + stroke_width\n            + spacing\n        )\n\n    def text(\n        self,\n        xy: tuple[float, float],\n        text: str,\n        fill=None,\n        font: (\n            ImageFont.ImageFont\n            | ImageFont.FreeTypeFont\n            | ImageFont.TransposedFont\n            | None\n        ) = None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        stroke_fill=None,\n        embedded_color=False,\n        *args,\n        **kwargs,\n    ) -> None:\n        \"\"\"Draw text.\"\"\"\n        if embedded_color and self.mode not in (\"RGB\", \"RGBA\"):\n            msg = \"Embedded color supported only in RGB and RGBA modes\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(kwargs.get(\"font_size\"))\n\n        if self._multiline_check(text):\n            return self.multiline_text(\n                xy,\n                text,\n                fill,\n                font,\n                anchor,\n                spacing,\n                align,\n                direction,\n                features,\n                language,\n                stroke_width,\n                stroke_fill,\n                embedded_color,\n            )\n\n        def getink(fill: _Ink | None) -> int:\n            ink, fill_ink = self._getink(fill)\n            if ink is None:\n                assert fill_ink is not None\n                return fill_ink\n            return ink\n\n        def draw_text(ink, stroke_width=0, stroke_offset=None) -> None:\n            mode = self.fontmode\n            if stroke_width == 0 and embedded_color:\n                mode = \"RGBA\"\n            coord = []\n            start = []\n            for i in range(2):\n                coord.append(int(xy[i]))\n                start.append(math.modf(xy[i])[0])\n            try:\n                mask, offset = font.getmask2(  # type: ignore[union-attr,misc]\n                    text,\n                    mode,\n                    direction=direction,\n                    features=features,\n                    language=language,\n                    stroke_width=stroke_width,\n                    anchor=anchor,\n                    ink=ink,\n                    start=start,\n                    *args,\n                    **kwargs,\n                )\n                coord = [coord[0] + offset[0], coord[1] + offset[1]]\n            except AttributeError:\n                try:\n                    mask = font.getmask(  # type: ignore[misc]\n                        text,\n                        mode,\n                        direction,\n                        features,\n                        language,\n                        stroke_width,\n                        anchor,\n                        ink,\n                        start=start,\n                        *args,\n                        **kwargs,\n                    )\n                except TypeError:\n                    mask = font.getmask(text)\n            if stroke_offset:\n                coord = [coord[0] + stroke_offset[0], coord[1] + stroke_offset[1]]\n            if mode == \"RGBA\":\n                # font.getmask2(mode=\"RGBA\") returns color in RGB bands and mask in A\n                # extract mask and set text alpha\n                color, mask = mask, mask.getband(3)\n                ink_alpha = struct.pack(\"i\", ink)[3]\n                color.fillband(3, ink_alpha)\n                x, y = coord\n                if self.im is not None:\n                    self.im.paste(\n                        color, (x, y, x + mask.size[0], y + mask.size[1]), mask\n                    )\n            else:\n                self.draw.draw_bitmap(coord, mask, ink)\n\n        ink = getink(fill)\n        if ink is not None:\n            stroke_ink = None\n            if stroke_width:\n                stroke_ink = getink(stroke_fill) if stroke_fill is not None else ink\n\n            if stroke_ink is not None:\n                # Draw stroked text\n                draw_text(stroke_ink, stroke_width)\n\n                # Draw normal text\n                draw_text(ink, 0)\n            else:\n                # Only draw normal text\n                draw_text(ink)\n\n    def multiline_text(\n        self,\n        xy: tuple[float, float],\n        text: str,\n        fill=None,\n        font: (\n            ImageFont.ImageFont\n            | ImageFont.FreeTypeFont\n            | ImageFont.TransposedFont\n            | None\n        ) = None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        stroke_fill=None,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> None:\n        if direction == \"ttb\":\n            msg = \"ttb direction is unsupported for multiline text\"\n            raise ValueError(msg)\n\n        if anchor is None:\n            anchor = \"la\"\n        elif len(anchor) != 2:\n            msg = \"anchor must be a 2 character string\"\n            raise ValueError(msg)\n        elif anchor[1] in \"tb\":\n            msg = \"anchor not supported for multiline text\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n\n        widths = []\n        max_width: float = 0\n        lines = self._multiline_split(text)\n        line_spacing = self._multiline_spacing(font, spacing, stroke_width)\n        for line in lines:\n            line_width = self.textlength(\n                line, font, direction=direction, features=features, language=language\n            )\n            widths.append(line_width)\n            max_width = max(max_width, line_width)\n\n        top = xy[1]\n        if anchor[1] == \"m\":\n            top -= (len(lines) - 1) * line_spacing / 2.0\n        elif anchor[1] == \"d\":\n            top -= (len(lines) - 1) * line_spacing\n\n        for idx, line in enumerate(lines):\n            left = xy[0]\n            width_difference = max_width - widths[idx]\n\n            # first align left by anchor\n            if anchor[0] == \"m\":\n                left -= width_difference / 2.0\n            elif anchor[0] == \"r\":\n                left -= width_difference\n\n            # then align by align parameter\n            if align == \"left\":\n                pass\n            elif align == \"center\":\n                left += width_difference / 2.0\n            elif align == \"right\":\n                left += width_difference\n            else:\n                msg = 'align must be \"left\", \"center\" or \"right\"'\n                raise ValueError(msg)\n\n            self.text(\n                (left, top),\n                line,\n                fill,\n                font,\n                anchor,\n                direction=direction,\n                features=features,\n                language=language,\n                stroke_width=stroke_width,\n                stroke_fill=stroke_fill,\n                embedded_color=embedded_color,\n            )\n            top += line_spacing\n\n    def textlength(\n        self,\n        text: str,\n        font: (\n            ImageFont.ImageFont\n            | ImageFont.FreeTypeFont\n            | ImageFont.TransposedFont\n            | None\n        ) = None,\n        direction=None,\n        features=None,\n        language=None,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> float:\n        \"\"\"Get the length of a given string, in pixels with 1/64 precision.\"\"\"\n        if self._multiline_check(text):\n            msg = \"can't measure length of multiline text\"\n            raise ValueError(msg)\n        if embedded_color and self.mode not in (\"RGB\", \"RGBA\"):\n            msg = \"Embedded color supported only in RGB and RGBA modes\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n        mode = \"RGBA\" if embedded_color else self.fontmode\n        return font.getlength(text, mode, direction, features, language)\n\n    def textbbox(\n        self,\n        xy,\n        text,\n        font=None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> tuple[int, int, int, int]:\n        \"\"\"Get the bounding box of a given string, in pixels.\"\"\"\n        if embedded_color and self.mode not in (\"RGB\", \"RGBA\"):\n            msg = \"Embedded color supported only in RGB and RGBA modes\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n\n        if self._multiline_check(text):\n            return self.multiline_textbbox(\n                xy,\n                text,\n                font,\n                anchor,\n                spacing,\n                align,\n                direction,\n                features,\n                language,\n                stroke_width,\n                embedded_color,\n            )\n\n        mode = \"RGBA\" if embedded_color else self.fontmode\n        bbox = font.getbbox(\n            text, mode, direction, features, language, stroke_width, anchor\n        )\n        return bbox[0] + xy[0], bbox[1] + xy[1], bbox[2] + xy[0], bbox[3] + xy[1]\n\n    def multiline_textbbox(\n        self,\n        xy,\n        text,\n        font=None,\n        anchor=None,\n        spacing=4,\n        align=\"left\",\n        direction=None,\n        features=None,\n        language=None,\n        stroke_width=0,\n        embedded_color=False,\n        *,\n        font_size=None,\n    ) -> tuple[int, int, int, int]:\n        if direction == \"ttb\":\n            msg = \"ttb direction is unsupported for multiline text\"\n            raise ValueError(msg)\n\n        if anchor is None:\n            anchor = \"la\"\n        elif len(anchor) != 2:\n            msg = \"anchor must be a 2 character string\"\n            raise ValueError(msg)\n        elif anchor[1] in \"tb\":\n            msg = \"anchor not supported for multiline text\"\n            raise ValueError(msg)\n\n        if font is None:\n            font = self._getfont(font_size)\n\n        widths = []\n        max_width: float = 0\n        lines = self._multiline_split(text)\n        line_spacing = self._multiline_spacing(font, spacing, stroke_width)\n        for line in lines:\n            line_width = self.textlength(\n                line,\n                font,\n                direction=direction,\n                features=features,\n                language=language,\n                embedded_color=embedded_color,\n            )\n            widths.append(line_width)\n            max_width = max(max_width, line_width)\n\n        top = xy[1]\n        if anchor[1] == \"m\":\n            top -= (len(lines) - 1) * line_spacing / 2.0\n        elif anchor[1] == \"d\":\n            top -= (len(lines) - 1) * line_spacing\n\n        bbox: tuple[int, int, int, int] | None = None\n\n        for idx, line in enumerate(lines):\n            left = xy[0]\n            width_difference = max_width - widths[idx]\n\n            # first align left by anchor\n            if anchor[0] == \"m\":\n                left -= width_difference / 2.0\n            elif anchor[0] == \"r\":\n                left -= width_difference\n\n            # then align by align parameter\n            if align == \"left\":\n                pass\n            elif align == \"center\":\n                left += width_difference / 2.0\n            elif align == \"right\":\n                left += width_difference\n            else:\n                msg = 'align must be \"left\", \"center\" or \"right\"'\n                raise ValueError(msg)\n\n            bbox_line = self.textbbox(\n                (left, top),\n                line,\n                font,\n                anchor,\n                direction=direction,\n                features=features,\n                language=language,\n                stroke_width=stroke_width,\n                embedded_color=embedded_color,\n            )\n            if bbox is None:\n                bbox = bbox_line\n            else:\n                bbox = (\n                    min(bbox[0], bbox_line[0]),\n                    min(bbox[1], bbox_line[1]),\n                    max(bbox[2], bbox_line[2]),\n                    max(bbox[3], bbox_line[3]),\n                )\n\n            top += line_spacing\n\n        if bbox is None:\n            return xy[0], xy[1], xy[0], xy[1]\n        return bbox\n\n\ndef Draw(im: Image.Image, mode: str | None = None) -> ImageDraw:\n    \"\"\"\n    A simple 2D drawing interface for PIL images.\n\n    :param im: The image to draw in.\n    :param mode: Optional mode to use for color values.  For RGB\n       images, this argument can be RGB or RGBA (to blend the\n       drawing into the image).  For all other modes, this argument\n       must be the same as the image mode.  If omitted, the mode\n       defaults to the mode of the image.\n    \"\"\"\n    try:\n        return getattr(im, \"getdraw\")(mode)\n    except AttributeError:\n        return ImageDraw(im, mode)\n\n\ndef getdraw(\n    im: Image.Image | None = None, hints: list[str] | None = None\n) -> tuple[ImageDraw2.Draw | None, ModuleType]:\n    \"\"\"\n    :param im: The image to draw in.\n    :param hints: An optional list of hints. Deprecated.\n    :returns: A (drawing context, drawing resource factory) tuple.\n    \"\"\"\n    if hints is not None:\n        deprecate(\"'hints' parameter\", 12)\n    from . import ImageDraw2\n\n    draw = ImageDraw2.Draw(im) if im is not None else None\n    return draw, ImageDraw2\n\n\ndef floodfill(\n    image: Image.Image,\n    xy: tuple[int, int],\n    value: float | tuple[int, ...],\n    border: float | tuple[int, ...] | None = None,\n    thresh: float = 0,\n) -> None:\n    \"\"\"\n    (experimental) Fills a bounded region with a given color.\n\n    :param image: Target image.\n    :param xy: Seed position (a 2-item coordinate tuple). See\n        :ref:`coordinate-system`.\n    :param value: Fill color.\n    :param border: Optional border value.  If given, the region consists of\n        pixels with a color different from the border color.  If not given,\n        the region consists of pixels having the same color as the seed\n        pixel.\n    :param thresh: Optional threshold value which specifies a maximum\n        tolerable difference of a pixel value from the 'background' in\n        order for it to be replaced. Useful for filling regions of\n        non-homogeneous, but similar, colors.\n    \"\"\"\n    # based on an implementation by Eric S. Raymond\n    # amended by yo1995 @20180806\n    pixel = image.load()\n    x, y = xy\n    try:\n        background = pixel[x, y]\n        if _color_diff(value, background) <= thresh:\n            return  # seed point already has fill color\n        pixel[x, y] = value\n    except (ValueError, IndexError):\n        return  # seed point outside image\n    edge = {(x, y)}\n    # use a set to keep record of current and previous edge pixels\n    # to reduce memory consumption\n    full_edge = set()\n    while edge:\n        new_edge = set()\n        for x, y in edge:  # 4 adjacent method\n            for s, t in ((x + 1, y), (x - 1, y), (x, y + 1), (x, y - 1)):\n                # If already processed, or if a coordinate is negative, skip\n                if (s, t) in full_edge or s < 0 or t < 0:\n                    continue\n                try:\n                    p = pixel[s, t]\n                except (ValueError, IndexError):\n                    pass\n                else:\n                    full_edge.add((s, t))\n                    if border is None:\n                        fill = _color_diff(p, background) <= thresh\n                    else:\n                        fill = p not in (value, border)\n                    if fill:\n                        pixel[s, t] = value\n                        new_edge.add((s, t))\n        full_edge = edge  # discard pixels processed\n        edge = new_edge\n\n\ndef _compute_regular_polygon_vertices(\n    bounding_circle: Sequence[Sequence[float] | float], n_sides: int, rotation: float\n) -> list[tuple[float, float]]:\n    \"\"\"\n    Generate a list of vertices for a 2D regular polygon.\n\n    :param bounding_circle: The bounding circle is a sequence defined\n        by a point and radius. The polygon is inscribed in this circle.\n        (e.g. ``bounding_circle=(x, y, r)`` or ``((x, y), r)``)\n    :param n_sides: Number of sides\n        (e.g. ``n_sides=3`` for a triangle, ``6`` for a hexagon)\n    :param rotation: Apply an arbitrary rotation to the polygon\n        (e.g. ``rotation=90``, applies a 90 degree rotation)\n    :return: List of regular polygon vertices\n        (e.g. ``[(25, 50), (50, 50), (50, 25), (25, 25)]``)\n\n    How are the vertices computed?\n    1. Compute the following variables\n        - theta: Angle between the apothem & the nearest polygon vertex\n        - side_length: Length of each polygon edge\n        - centroid: Center of bounding circle (1st, 2nd elements of bounding_circle)\n        - polygon_radius: Polygon radius (last element of bounding_circle)\n        - angles: Location of each polygon vertex in polar grid\n            (e.g. A square with 0 degree rotation => [225.0, 315.0, 45.0, 135.0])\n\n    2. For each angle in angles, get the polygon vertex at that angle\n        The vertex is computed using the equation below.\n            X= xcos(\u03c6) + ysin(\u03c6)\n            Y= \u2212xsin(\u03c6) + ycos(\u03c6)\n\n        Note:\n            \u03c6 = angle in degrees\n            x = 0\n            y = polygon_radius\n\n        The formula above assumes rotation around the origin.\n        In our case, we are rotating around the centroid.\n        To account for this, we use the formula below\n            X = xcos(\u03c6) + ysin(\u03c6) + centroid_x\n            Y = \u2212xsin(\u03c6) + ycos(\u03c6) + centroid_y\n    \"\"\"\n    # 1. Error Handling\n    # 1.1 Check `n_sides` has an appropriate value\n    if not isinstance(n_sides, int):\n        msg = \"n_sides should be an int\"  # type: ignore[unreachable]\n        raise TypeError(msg)\n    if n_sides < 3:\n        msg = \"n_sides should be an int > 2\"\n        raise ValueError(msg)\n\n    # 1.2 Check `bounding_circle` has an appropriate value\n    if not isinstance(bounding_circle, (list, tuple)):\n        msg = \"bounding_circle should be a sequence\"\n        raise TypeError(msg)\n\n    if len(bounding_circle) == 3:\n        if not all(isinstance(i, (int, float)) for i in bounding_circle):\n            msg = \"bounding_circle should only contain numeric data\"\n            raise ValueError(msg)\n\n        *centroid, polygon_radius = cast(List[float], list(bounding_circle))\n    elif len(bounding_circle) == 2 and isinstance(bounding_circle[0], (list, tuple)):\n        if not all(\n            isinstance(i, (int, float)) for i in bounding_circle[0]\n        ) or not isinstance(bounding_circle[1], (int, float)):\n            msg = \"bounding_circle should only contain numeric data\"\n            raise ValueError(msg)\n\n        if len(bounding_circle[0]) != 2:\n            msg = \"bounding_circle centre should contain 2D coordinates (e.g. (x, y))\"\n            raise ValueError(msg)\n\n        centroid = cast(List[float], list(bounding_circle[0]))\n        polygon_radius = cast(float, bounding_circle[1])\n    else:\n        msg = (\n            \"bounding_circle should contain 2D coordinates \"\n            \"and a radius (e.g. (x, y, r) or ((x, y), r) )\"\n        )\n        raise ValueError(msg)\n\n    if polygon_radius <= 0:\n        msg = \"bounding_circle radius should be > 0\"\n        raise ValueError(msg)\n\n    # 1.3 Check `rotation` has an appropriate value\n    if not isinstance(rotation, (int, float)):\n        msg = \"rotation should be an int or float\"  # type: ignore[unreachable]\n        raise ValueError(msg)\n\n    # 2. Define Helper Functions\n    def _apply_rotation(point: list[float], degrees: float) -> tuple[float, float]:\n        return (\n            round(\n                point[0] * math.cos(math.radians(360 - degrees))\n                - point[1] * math.sin(math.radians(360 - degrees))\n                + centroid[0],\n                2,\n            ),\n            round(\n                point[1] * math.cos(math.radians(360 - degrees))\n                + point[0] * math.sin(math.radians(360 - degrees))\n                + centroid[1],\n                2,\n            ),\n        )\n\n    def _compute_polygon_vertex(angle: float) -> tuple[float, float]:\n        start_point = [polygon_radius, 0]\n        return _apply_rotation(start_point, angle)\n\n    def _get_angles(n_sides: int, rotation: float) -> list[float]:\n        angles = []\n        degrees = 360 / n_sides\n        # Start with the bottom left polygon vertex\n        current_angle = (270 - 0.5 * degrees) + rotation\n        for _ in range(0, n_sides):\n            angles.append(current_angle)\n            current_angle += degrees\n            if current_angle > 360:\n                current_angle -= 360\n        return angles\n\n    # 3. Variable Declarations\n    angles = _get_angles(n_sides, rotation)\n\n    # 4. Compute Vertices\n    return [_compute_polygon_vertex(angle) for angle in angles]\n\n\ndef _color_diff(\n    color1: float | tuple[int, ...], color2: float | tuple[int, ...]\n) -> float:\n    \"\"\"\n    Uses 1-norm distance to calculate difference between two values.\n    \"\"\"\n    first = color1 if isinstance(color1, tuple) else (color1,)\n    second = color2 if isinstance(color2, tuple) else (color2,)\n\n    return sum(abs(first[i] - second[i]) for i in range(0, len(second)))\n", "src/PIL/ImageStat.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# global image statistics\n#\n# History:\n# 1996-04-05 fl   Created\n# 1997-05-21 fl   Added mask; added rms, var, stddev attributes\n# 1997-08-05 fl   Added median\n# 1998-07-05 hk   Fixed integer overflow error\n#\n# Notes:\n# This class shows how to implement delayed evaluation of attributes.\n# To get a certain value, simply access the corresponding attribute.\n# The __getattr__ dispatcher takes care of the rest.\n#\n# Copyright (c) Secret Labs AB 1997.\n# Copyright (c) Fredrik Lundh 1996-97.\n#\n# See the README file for information on usage and redistribution.\n#\nfrom __future__ import annotations\n\nimport math\nfrom functools import cached_property\n\nfrom . import Image\n\n\nclass Stat:\n    def __init__(\n        self, image_or_list: Image.Image | list[int], mask: Image.Image | None = None\n    ) -> None:\n        \"\"\"\n        Calculate statistics for the given image. If a mask is included,\n        only the regions covered by that mask are included in the\n        statistics. You can also pass in a previously calculated histogram.\n\n        :param image: A PIL image, or a precalculated histogram.\n\n            .. note::\n\n                For a PIL image, calculations rely on the\n                :py:meth:`~PIL.Image.Image.histogram` method. The pixel counts are\n                grouped into 256 bins, even if the image has more than 8 bits per\n                channel. So ``I`` and ``F`` mode images have a maximum ``mean``,\n                ``median`` and ``rms`` of 255, and cannot have an ``extrema`` maximum\n                of more than 255.\n\n        :param mask: An optional mask.\n        \"\"\"\n        if isinstance(image_or_list, Image.Image):\n            self.h = image_or_list.histogram(mask)\n        elif isinstance(image_or_list, list):\n            self.h = image_or_list\n        else:\n            msg = \"first argument must be image or list\"  # type: ignore[unreachable]\n            raise TypeError(msg)\n        self.bands = list(range(len(self.h) // 256))\n\n    @cached_property\n    def extrema(self) -> list[tuple[int, int]]:\n        \"\"\"\n        Min/max values for each band in the image.\n\n        .. note::\n            This relies on the :py:meth:`~PIL.Image.Image.histogram` method, and\n            simply returns the low and high bins used. This is correct for\n            images with 8 bits per channel, but fails for other modes such as\n            ``I`` or ``F``. Instead, use :py:meth:`~PIL.Image.Image.getextrema` to\n            return per-band extrema for the image. This is more correct and\n            efficient because, for non-8-bit modes, the histogram method uses\n            :py:meth:`~PIL.Image.Image.getextrema` to determine the bins used.\n        \"\"\"\n\n        def minmax(histogram: list[int]) -> tuple[int, int]:\n            res_min, res_max = 255, 0\n            for i in range(256):\n                if histogram[i]:\n                    res_min = i\n                    break\n            for i in range(255, -1, -1):\n                if histogram[i]:\n                    res_max = i\n                    break\n            return res_min, res_max\n\n        return [minmax(self.h[i:]) for i in range(0, len(self.h), 256)]\n\n    @cached_property\n    def count(self) -> list[int]:\n        \"\"\"Total number of pixels for each band in the image.\"\"\"\n        return [sum(self.h[i : i + 256]) for i in range(0, len(self.h), 256)]\n\n    @cached_property\n    def sum(self) -> list[float]:\n        \"\"\"Sum of all pixels for each band in the image.\"\"\"\n\n        v = []\n        for i in range(0, len(self.h), 256):\n            layer_sum = 0.0\n            for j in range(256):\n                layer_sum += j * self.h[i + j]\n            v.append(layer_sum)\n        return v\n\n    @cached_property\n    def sum2(self) -> list[float]:\n        \"\"\"Squared sum of all pixels for each band in the image.\"\"\"\n\n        v = []\n        for i in range(0, len(self.h), 256):\n            sum2 = 0.0\n            for j in range(256):\n                sum2 += (j**2) * float(self.h[i + j])\n            v.append(sum2)\n        return v\n\n    @cached_property\n    def mean(self) -> list[float]:\n        \"\"\"Average (arithmetic mean) pixel level for each band in the image.\"\"\"\n        return [self.sum[i] / self.count[i] for i in self.bands]\n\n    @cached_property\n    def median(self) -> list[int]:\n        \"\"\"Median pixel level for each band in the image.\"\"\"\n\n        v = []\n        for i in self.bands:\n            s = 0\n            half = self.count[i] // 2\n            b = i * 256\n            for j in range(256):\n                s = s + self.h[b + j]\n                if s > half:\n                    break\n            v.append(j)\n        return v\n\n    @cached_property\n    def rms(self) -> list[float]:\n        \"\"\"RMS (root-mean-square) for each band in the image.\"\"\"\n        return [math.sqrt(self.sum2[i] / self.count[i]) for i in self.bands]\n\n    @cached_property\n    def var(self) -> list[float]:\n        \"\"\"Variance for each band in the image.\"\"\"\n        return [\n            (self.sum2[i] - (self.sum[i] ** 2.0) / self.count[i]) / self.count[i]\n            for i in self.bands\n        ]\n\n    @cached_property\n    def stddev(self) -> list[float]:\n        \"\"\"Standard deviation for each band in the image.\"\"\"\n        return [math.sqrt(self.var[i]) for i in self.bands]\n\n\nGlobal = Stat  # compatibility\n", "src/PIL/_binary.py": "#\n# The Python Imaging Library.\n# $Id$\n#\n# Binary input/output support routines.\n#\n# Copyright (c) 1997-2003 by Secret Labs AB\n# Copyright (c) 1995-2003 by Fredrik Lundh\n# Copyright (c) 2012 by Brian Crowell\n#\n# See the README file for information on usage and redistribution.\n#\n\n\n\"\"\"Binary input/output support routines.\"\"\"\nfrom __future__ import annotations\n\nfrom struct import pack, unpack_from\n\n\ndef i8(c: bytes) -> int:\n    return c[0]\n\n\ndef o8(i: int) -> bytes:\n    return bytes((i & 255,))\n\n\n# Input, le = little endian, be = big endian\ndef i16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to an unsigned integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<H\", c, o)[0]\n\n\ndef si16le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<h\", c, o)[0]\n\n\ndef si16be(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 2-bytes (16 bits) string to a signed integer, big endian.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\">h\", c, o)[0]\n\n\ndef i32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to an unsigned integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<I\", c, o)[0]\n\n\ndef si32le(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\"<i\", c, o)[0]\n\n\ndef si32be(c: bytes, o: int = 0) -> int:\n    \"\"\"\n    Converts a 4-bytes (32 bits) string to a signed integer, big endian.\n\n    :param c: string containing bytes to convert\n    :param o: offset of bytes to convert in string\n    \"\"\"\n    return unpack_from(\">i\", c, o)[0]\n\n\ndef i16be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">H\", c, o)[0]\n\n\ndef i32be(c: bytes, o: int = 0) -> int:\n    return unpack_from(\">I\", c, o)[0]\n\n\n# Output, le = little endian, be = big endian\ndef o16le(i: int) -> bytes:\n    return pack(\"<H\", i)\n\n\ndef o32le(i: int) -> bytes:\n    return pack(\"<I\", i)\n\n\ndef o16be(i: int) -> bytes:\n    return pack(\">H\", i)\n\n\ndef o32be(i: int) -> bytes:\n    return pack(\">I\", i)\n", "Tests/test_file_xvthumb.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, XVThumbImagePlugin\n\nfrom .helper import assert_image_similar, hopper\n\nTEST_FILE = \"Tests/images/hopper.p7\"\n\n\ndef test_open() -> None:\n    # Act\n    with Image.open(TEST_FILE) as im:\n        # Assert\n        assert im.format == \"XVThumb\"\n\n        # Create a Hopper image with a similar XV palette\n        im_hopper = hopper().quantize(palette=im)\n        assert_image_similar(im, im_hopper, 9)\n\n\ndef test_unexpected_eof() -> None:\n    # Test unexpected EOF reading XV thumbnail file\n    # Arrange\n    bad_file = \"Tests/images/hopper_bad.p7\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        XVThumbImagePlugin.XVThumbImageFile(bad_file)\n\n\ndef test_invalid_file() -> None:\n    # Arrange\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        XVThumbImagePlugin.XVThumbImageFile(invalid_file)\n", "Tests/test_file_qoi.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, QoiImagePlugin\n\nfrom .helper import assert_image_equal_tofile\n\n\ndef test_sanity() -> None:\n    with Image.open(\"Tests/images/hopper.qoi\") as im:\n        assert im.mode == \"RGB\"\n        assert im.size == (128, 128)\n        assert im.format == \"QOI\"\n\n        assert_image_equal_tofile(im, \"Tests/images/hopper.png\")\n\n    with Image.open(\"Tests/images/pil123rgba.qoi\") as im:\n        assert im.mode == \"RGBA\"\n        assert im.size == (162, 150)\n        assert im.format == \"QOI\"\n\n        assert_image_equal_tofile(im, \"Tests/images/pil123rgba.png\")\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        QoiImagePlugin.QoiImageFile(invalid_file)\n", "Tests/check_release_notes.py": "from __future__ import annotations\n\nimport sys\nfrom pathlib import Path\n\nfor rst in Path(\"docs/releasenotes\").glob(\"[1-9]*.rst\"):\n    if \"TODO\" in open(rst).read():\n        sys.exit(f\"Error: remove TODO from {rst}\")\n", "Tests/test_imagecms.py": "from __future__ import annotations\n\nimport datetime\nimport os\nimport re\nimport shutil\nimport sys\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import Any, Literal, cast\n\nimport pytest\n\nfrom PIL import Image, ImageMode, ImageWin, features\n\nfrom .helper import (\n    assert_image,\n    assert_image_equal,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    hopper,\n    is_pypy,\n)\n\ntry:\n    from PIL import ImageCms\n    from PIL.ImageCms import ImageCmsProfile\n\n    ImageCms.core.profile_open\nexcept ImportError:\n    # Skipped via setup_module()\n    pass\n\n\nSRGB = \"Tests/icc/sRGB_IEC61966-2-1_black_scaled.icc\"\nHAVE_PROFILE = os.path.exists(SRGB)\n\n\ndef setup_module() -> None:\n    try:\n        from PIL import ImageCms\n\n        # need to hit getattr to trigger the delayed import error\n        ImageCms.core.profile_open\n    except ImportError as v:\n        pytest.skip(str(v))\n\n\ndef skip_missing() -> None:\n    if not HAVE_PROFILE:\n        pytest.skip(\"SRGB profile not available\")\n\n\ndef test_sanity() -> None:\n    # basic smoke test.\n    # this mostly follows the cms_test outline.\n    with pytest.warns(DeprecationWarning):\n        v = ImageCms.versions()  # should return four strings\n    assert v[0] == \"1.0.0 pil\"\n    assert list(map(type, v)) == [str, str, str, str]\n\n    # internal version number\n    version = features.version_module(\"littlecms2\")\n    assert version is not None\n    assert re.search(r\"\\d+\\.\\d+(\\.\\d+)?$\", version)\n\n    skip_missing()\n    i = ImageCms.profileToProfile(hopper(), SRGB, SRGB)\n    assert i is not None\n    assert_image(i, \"RGB\", (128, 128))\n\n    i = hopper()\n    ImageCms.profileToProfile(i, SRGB, SRGB, inPlace=True)\n    assert_image(i, \"RGB\", (128, 128))\n\n    t = ImageCms.buildTransform(SRGB, SRGB, \"RGB\", \"RGB\")\n    i = ImageCms.applyTransform(hopper(), t)\n    assert i is not None\n    assert_image(i, \"RGB\", (128, 128))\n\n    with hopper() as i:\n        t = ImageCms.buildTransform(SRGB, SRGB, \"RGB\", \"RGB\")\n        ImageCms.applyTransform(hopper(), t, inPlace=True)\n        assert i is not None\n        assert_image(i, \"RGB\", (128, 128))\n\n    p = ImageCms.createProfile(\"sRGB\")\n    o = ImageCms.getOpenProfile(SRGB)\n    t = ImageCms.buildTransformFromOpenProfiles(p, o, \"RGB\", \"RGB\")\n    i = ImageCms.applyTransform(hopper(), t)\n    assert i is not None\n    assert_image(i, \"RGB\", (128, 128))\n\n    t = ImageCms.buildProofTransform(SRGB, SRGB, SRGB, \"RGB\", \"RGB\")\n    assert t.inputMode == \"RGB\"\n    assert t.outputMode == \"RGB\"\n    i = ImageCms.applyTransform(hopper(), t)\n    assert i is not None\n    assert_image(i, \"RGB\", (128, 128))\n\n    # test PointTransform convenience API\n    hopper().point(t)\n\n\ndef test_flags() -> None:\n    assert ImageCms.Flags.NONE.value == 0\n    assert ImageCms.Flags.GRIDPOINTS(0) == ImageCms.Flags.NONE\n    assert ImageCms.Flags.GRIDPOINTS(256) == ImageCms.Flags.NONE\n\n    assert ImageCms.Flags.GRIDPOINTS(255) == (255 << 16)\n    assert ImageCms.Flags.GRIDPOINTS(-1) == ImageCms.Flags.GRIDPOINTS(255)\n    assert ImageCms.Flags.GRIDPOINTS(511) == ImageCms.Flags.GRIDPOINTS(255)\n\n\ndef test_name() -> None:\n    skip_missing()\n    # get profile information for file\n    assert (\n        ImageCms.getProfileName(SRGB).strip()\n        == \"IEC 61966-2-1 Default RGB Colour Space - sRGB\"\n    )\n\n\ndef test_info() -> None:\n    skip_missing()\n    assert ImageCms.getProfileInfo(SRGB).splitlines() == [\n        \"sRGB IEC61966-2-1 black scaled\",\n        \"\",\n        \"Copyright International Color Consortium, 2009\",\n        \"\",\n    ]\n\n\ndef test_copyright() -> None:\n    skip_missing()\n    assert (\n        ImageCms.getProfileCopyright(SRGB).strip()\n        == \"Copyright International Color Consortium, 2009\"\n    )\n\n\ndef test_manufacturer() -> None:\n    skip_missing()\n    assert ImageCms.getProfileManufacturer(SRGB).strip() == \"\"\n\n\ndef test_model() -> None:\n    skip_missing()\n    assert (\n        ImageCms.getProfileModel(SRGB).strip()\n        == \"IEC 61966-2-1 Default RGB Colour Space - sRGB\"\n    )\n\n\ndef test_description() -> None:\n    skip_missing()\n    assert (\n        ImageCms.getProfileDescription(SRGB).strip() == \"sRGB IEC61966-2-1 black scaled\"\n    )\n\n\ndef test_intent() -> None:\n    skip_missing()\n    assert ImageCms.getDefaultIntent(SRGB) == 0\n    support = ImageCms.isIntentSupported(\n        SRGB, ImageCms.Intent.ABSOLUTE_COLORIMETRIC, ImageCms.Direction.INPUT\n    )\n    assert support == 1\n\n\ndef test_profile_object() -> None:\n    # same, using profile object\n    p = ImageCms.createProfile(\"sRGB\")\n    # assert ImageCms.getProfileName(p).strip() == \"sRGB built-in - (lcms internal)\"\n    # assert ImageCms.getProfileInfo(p).splitlines() ==\n    #     [\"sRGB built-in\", \"\", \"WhitePoint : D65 (daylight)\", \"\", \"\"]\n    assert ImageCms.getDefaultIntent(p) == 0\n    support = ImageCms.isIntentSupported(\n        p, ImageCms.Intent.ABSOLUTE_COLORIMETRIC, ImageCms.Direction.INPUT\n    )\n    assert support == 1\n\n\ndef test_extensions() -> None:\n    # extensions\n\n    with Image.open(\"Tests/images/rgb.jpg\") as i:\n        p = ImageCms.getOpenProfile(BytesIO(i.info[\"icc_profile\"]))\n    assert (\n        ImageCms.getProfileName(p).strip()\n        == \"IEC 61966-2.1 Default RGB colour space - sRGB\"\n    )\n\n\ndef test_exceptions() -> None:\n    # Test mode mismatch\n    psRGB = ImageCms.createProfile(\"sRGB\")\n    pLab = ImageCms.createProfile(\"LAB\")\n    t = ImageCms.buildTransform(pLab, psRGB, \"LAB\", \"RGB\")\n    with pytest.raises(ValueError, match=\"mode mismatch\"):\n        t.apply_in_place(hopper(\"RGBA\"))\n\n    # the procedural pyCMS API uses PyCMSError for all sorts of errors\n    with hopper() as im:\n        with pytest.raises(ImageCms.PyCMSError, match=\"cannot open profile file\"):\n            ImageCms.profileToProfile(im, \"foo\", \"bar\")\n\n    with pytest.raises(ImageCms.PyCMSError, match=\"cannot open profile file\"):\n        ImageCms.buildTransform(\"foo\", \"bar\", \"RGB\", \"RGB\")\n\n    with pytest.raises(ImageCms.PyCMSError, match=\"Invalid type for Profile\"):\n        ImageCms.getProfileName(None)  # type: ignore[arg-type]\n    skip_missing()\n\n    # Python <= 3.9: \"an integer is required (got type NoneType)\"\n    # Python > 3.9: \"'NoneType' object cannot be interpreted as an integer\"\n    with pytest.raises(ImageCms.PyCMSError, match=\"integer\"):\n        ImageCms.isIntentSupported(SRGB, None, None)  # type: ignore[arg-type]\n\n\ndef test_display_profile() -> None:\n    # try fetching the profile for the current display device\n    ImageCms.get_display_profile()\n\n    if sys.platform == \"win32\":\n        ImageCms.get_display_profile(ImageWin.HDC(0))\n        ImageCms.get_display_profile(ImageWin.HWND(0))\n\n\ndef test_lab_color_profile() -> None:\n    ImageCms.createProfile(\"LAB\", 5000)\n    ImageCms.createProfile(\"LAB\", 6500)\n\n\ndef test_unsupported_color_space() -> None:\n    with pytest.raises(\n        ImageCms.PyCMSError,\n        match=re.escape(\n            \"Color space not supported for on-the-fly profile creation (unsupported)\"\n        ),\n    ):\n        ImageCms.createProfile(\"unsupported\")  # type: ignore[arg-type]\n\n\ndef test_invalid_color_temperature() -> None:\n    with pytest.raises(\n        ImageCms.PyCMSError,\n        match='Color temperature must be numeric, \"invalid\" not valid',\n    ):\n        ImageCms.createProfile(\"LAB\", \"invalid\")  # type: ignore[arg-type]\n\n\n@pytest.mark.parametrize(\"flag\", (\"my string\", -1))\ndef test_invalid_flag(flag: str | int) -> None:\n    with hopper() as im:\n        with pytest.raises(\n            ImageCms.PyCMSError, match=\"flags must be an integer between 0 and \"\n        ):\n            ImageCms.profileToProfile(im, \"foo\", \"bar\", flags=flag)  # type: ignore[arg-type]\n\n\ndef test_simple_lab() -> None:\n    i = Image.new(\"RGB\", (10, 10), (128, 128, 128))\n\n    psRGB = ImageCms.createProfile(\"sRGB\")\n    pLab = ImageCms.createProfile(\"LAB\")\n    t = ImageCms.buildTransform(psRGB, pLab, \"RGB\", \"LAB\")\n\n    i_lab = ImageCms.applyTransform(i, t)\n    assert i_lab is not None\n    assert i_lab.mode == \"LAB\"\n\n    k = i_lab.getpixel((0, 0))\n    # not a linear luminance map. so L != 128:\n    assert k == (137, 128, 128)\n\n    l_data = i_lab.getdata(0)\n    a_data = i_lab.getdata(1)\n    b_data = i_lab.getdata(2)\n\n    assert list(l_data) == [137] * 100\n    assert list(a_data) == [128] * 100\n    assert list(b_data) == [128] * 100\n\n\ndef test_lab_color() -> None:\n    psRGB = ImageCms.createProfile(\"sRGB\")\n    pLab = ImageCms.createProfile(\"LAB\")\n    t = ImageCms.buildTransform(psRGB, pLab, \"RGB\", \"LAB\")\n\n    # Need to add a type mapping for some PIL type to TYPE_Lab_8 in findLCMSType, and\n    # have that mapping work back to a PIL mode (likely RGB).\n    i = ImageCms.applyTransform(hopper(), t)\n    assert i is not None\n    assert_image(i, \"LAB\", (128, 128))\n\n    # i.save('temp.lab.tif')  # visually verified vs PS.\n\n    assert_image_similar_tofile(i, \"Tests/images/hopper.Lab.tif\", 3.5)\n\n\ndef test_lab_srgb() -> None:\n    psRGB = ImageCms.createProfile(\"sRGB\")\n    pLab = ImageCms.createProfile(\"LAB\")\n    t = ImageCms.buildTransform(pLab, psRGB, \"LAB\", \"RGB\")\n\n    with Image.open(\"Tests/images/hopper.Lab.tif\") as img:\n        img_srgb = ImageCms.applyTransform(img, t)\n    assert img_srgb is not None\n\n    # img_srgb.save('temp.srgb.tif') # visually verified vs ps.\n\n    assert_image_similar(hopper(), img_srgb, 30)\n    assert img_srgb.info[\"icc_profile\"]\n\n    profile = ImageCmsProfile(BytesIO(img_srgb.info[\"icc_profile\"]))\n    assert \"sRGB\" in ImageCms.getProfileDescription(profile)\n\n\ndef test_lab_roundtrip() -> None:\n    # check to see if we're at least internally consistent.\n    psRGB = ImageCms.createProfile(\"sRGB\")\n    pLab = ImageCms.createProfile(\"LAB\")\n    t = ImageCms.buildTransform(psRGB, pLab, \"RGB\", \"LAB\")\n\n    t2 = ImageCms.buildTransform(pLab, psRGB, \"LAB\", \"RGB\")\n\n    i = ImageCms.applyTransform(hopper(), t)\n    assert i is not None\n    assert i.info[\"icc_profile\"] == ImageCmsProfile(pLab).tobytes()\n\n    out = ImageCms.applyTransform(i, t2)\n    assert out is not None\n    assert_image_similar(hopper(), out, 2)\n\n\ndef test_profile_tobytes() -> None:\n    with Image.open(\"Tests/images/rgb.jpg\") as i:\n        p = ImageCms.getOpenProfile(BytesIO(i.info[\"icc_profile\"]))\n\n    p2 = ImageCms.getOpenProfile(BytesIO(p.tobytes()))\n\n    # not the same bytes as the original icc_profile, but it does roundtrip\n    assert p.tobytes() == p2.tobytes()\n    assert ImageCms.getProfileName(p) == ImageCms.getProfileName(p2)\n    assert ImageCms.getProfileDescription(p) == ImageCms.getProfileDescription(p2)\n\n\ndef test_extended_information() -> None:\n    skip_missing()\n    o = ImageCms.getOpenProfile(SRGB)\n    p = o.profile\n\n    def assert_truncated_tuple_equal(\n        tup1: tuple[Any, ...] | None, tup2: tuple[Any, ...], digits: int = 10\n    ) -> None:\n        # Helper function to reduce precision of tuples of floats\n        # recursively and then check equality.\n        power = 10**digits\n\n        def truncate_tuple(tuple_value: tuple[Any, ...]) -> tuple[Any, ...]:\n            return tuple(\n                (\n                    truncate_tuple(val)\n                    if isinstance(val, tuple)\n                    else int(val * power) / power\n                )\n                for val in tuple_value\n            )\n\n        assert tup1 is not None\n        assert truncate_tuple(tup1) == truncate_tuple(tup2)\n\n    assert p.attributes == 4294967296\n    assert_truncated_tuple_equal(\n        p.blue_colorant,\n        (\n            (0.14306640625, 0.06060791015625, 0.7140960693359375),\n            (0.1558847490315394, 0.06603820639433387, 0.06060791015625),\n        ),\n    )\n    assert_truncated_tuple_equal(\n        p.blue_primary,\n        (\n            (0.14306641366715667, 0.06060790921083026, 0.7140960805782015),\n            (0.15588475410450106, 0.06603820408959558, 0.06060790921083026),\n        ),\n    )\n    assert_truncated_tuple_equal(\n        p.chromatic_adaptation,\n        (\n            (\n                (1.04791259765625, 0.0229339599609375, -0.050201416015625),\n                (0.02960205078125, 0.9904632568359375, -0.0170745849609375),\n                (-0.009246826171875, 0.0150604248046875, 0.7517852783203125),\n            ),\n            (\n                (1.0267159024652783, 0.022470062342089134, 0.0229339599609375),\n                (0.02951378324103937, 0.9875098886387147, 0.9904632568359375),\n                (-0.012205438066465256, 0.01987915407854985, 0.0150604248046875),\n            ),\n        ),\n    )\n    assert p.chromaticity is None\n    assert p.clut == {\n        0: (False, False, True),\n        1: (False, False, True),\n        2: (False, False, True),\n        3: (False, False, True),\n    }\n\n    assert p.colorant_table is None\n    assert p.colorant_table_out is None\n    assert p.colorimetric_intent is None\n    assert p.connection_space == \"XYZ \"\n    assert p.copyright == \"Copyright International Color Consortium, 2009\"\n    assert p.creation_date == datetime.datetime(2009, 2, 27, 21, 36, 31)\n    assert p.device_class == \"mntr\"\n    assert_truncated_tuple_equal(\n        p.green_colorant,\n        (\n            (0.3851470947265625, 0.7168731689453125, 0.097076416015625),\n            (0.32119769927720654, 0.5978443449048152, 0.7168731689453125),\n        ),\n    )\n    assert_truncated_tuple_equal(\n        p.green_primary,\n        (\n            (0.3851470888162112, 0.7168731974161346, 0.09707641738998518),\n            (0.32119768793686687, 0.5978443567149709, 0.7168731974161346),\n        ),\n    )\n    assert p.header_flags == 0\n    assert p.header_manufacturer == \"\\x00\\x00\\x00\\x00\"\n    assert p.header_model == \"\\x00\\x00\\x00\\x00\"\n    assert p.icc_measurement_condition == {\n        \"backing\": (0.0, 0.0, 0.0),\n        \"flare\": 0.0,\n        \"geo\": \"unknown\",\n        \"observer\": 1,\n        \"illuminant_type\": \"D65\",\n    }\n    assert p.icc_version == 33554432\n    assert p.icc_viewing_condition is None\n    assert p.intent_supported == {\n        0: (True, True, True),\n        1: (True, True, True),\n        2: (True, True, True),\n        3: (True, True, True),\n    }\n    assert p.is_matrix_shaper\n    assert p.luminance == ((0.0, 80.0, 0.0), (0.0, 1.0, 80.0))\n    assert p.manufacturer is None\n    assert_truncated_tuple_equal(\n        p.media_black_point,\n        (\n            (0.012054443359375, 0.0124969482421875, 0.01031494140625),\n            (0.34573304157549234, 0.35842450765864337, 0.0124969482421875),\n        ),\n    )\n    assert_truncated_tuple_equal(\n        p.media_white_point,\n        (\n            (0.964202880859375, 1.0, 0.8249053955078125),\n            (0.3457029219802284, 0.3585375327567059, 1.0),\n        ),\n    )\n    assert_truncated_tuple_equal(\n        (p.media_white_point_temperature,), (5000.722328847392,)\n    )\n    assert p.model == \"IEC 61966-2-1 Default RGB Colour Space - sRGB\"\n\n    assert p.perceptual_rendering_intent_gamut is None\n\n    assert p.profile_description == \"sRGB IEC61966-2-1 black scaled\"\n    assert p.profile_id == b\")\\xf8=\\xde\\xaf\\xf2U\\xaexB\\xfa\\xe4\\xca\\x839\\r\"\n    assert_truncated_tuple_equal(\n        p.red_colorant,\n        (\n            (0.436065673828125, 0.2224884033203125, 0.013916015625),\n            (0.6484536316398539, 0.3308524880306778, 0.2224884033203125),\n        ),\n    )\n    assert_truncated_tuple_equal(\n        p.red_primary,\n        (\n            (0.43606566581047446, 0.22248840582960838, 0.013916015621759925),\n            (0.6484536250319214, 0.3308524944738204, 0.22248840582960838),\n        ),\n    )\n    assert p.rendering_intent == 0\n    assert p.saturation_rendering_intent_gamut is None\n    assert p.screening_description is None\n    assert p.target is None\n    assert p.technology == \"CRT \"\n    assert p.version == 2.0\n    assert p.viewing_condition == \"Reference Viewing Condition in IEC 61966-2-1\"\n    assert p.xcolor_space == \"RGB \"\n\n\ndef test_non_ascii_path(tmp_path: Path) -> None:\n    skip_missing()\n    tempfile = str(tmp_path / (\"temp_\" + chr(128) + \".icc\"))\n    try:\n        shutil.copy(SRGB, tempfile)\n    except UnicodeEncodeError:\n        pytest.skip(\"Non-ASCII path could not be created\")\n\n    o = ImageCms.getOpenProfile(tempfile)\n    p = o.profile\n    assert p.model == \"IEC 61966-2-1 Default RGB Colour Space - sRGB\"\n\n\ndef test_profile_typesafety() -> None:\n    # does not segfault\n    with pytest.raises(TypeError, match=\"Invalid type for Profile\"):\n        ImageCms.ImageCmsProfile(0)  # type: ignore[arg-type]\n    with pytest.raises(TypeError, match=\"Invalid type for Profile\"):\n        ImageCms.ImageCmsProfile(1)  # type: ignore[arg-type]\n\n    # also check core function\n    with pytest.raises(TypeError):\n        ImageCms.core.profile_tobytes(0)  # type: ignore[arg-type]\n    with pytest.raises(TypeError):\n        ImageCms.core.profile_tobytes(1)  # type: ignore[arg-type]\n\n    if not is_pypy():\n        # core profile should not be directly instantiable\n        with pytest.raises(TypeError):\n            ImageCms.core.CmsProfile()\n        with pytest.raises(TypeError):\n            ImageCms.core.CmsProfile(0)  # type: ignore[call-arg]\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"fails on PyPy\")\ndef test_transform_typesafety() -> None:\n    # core transform should not be directly instantiable\n    with pytest.raises(TypeError):\n        ImageCms.core.CmsTransform()\n    with pytest.raises(TypeError):\n        ImageCms.core.CmsTransform(0)  # type: ignore[call-arg]\n\n\ndef assert_aux_channel_preserved(\n    mode: str, transform_in_place: bool, preserved_channel: str\n) -> None:\n    def create_test_image() -> Image.Image:\n        # set up test image with something interesting in the tested aux channel.\n        # fmt: off\n        nine_grid_deltas = [\n            (-1, -1), (-1, 0), (-1, 1),\n            (0,  -1),  (0, 0),  (0, 1),\n            (1,  -1),  (1, 0),  (1, 1),\n        ]\n        # fmt: on\n        chans = []\n        bands = ImageMode.getmode(mode).bands\n        for band_ndx in range(len(bands)):\n            channel_type = \"L\"  # 8-bit unorm\n            channel_pattern = hopper(channel_type)\n\n            # paste pattern with varying offsets to avoid correlation\n            # potentially hiding some bugs (like channels getting mixed).\n            paste_offset = (\n                int(band_ndx / len(bands) * channel_pattern.size[0]),\n                int(band_ndx / (len(bands) * 2) * channel_pattern.size[1]),\n            )\n            channel_data = Image.new(channel_type, channel_pattern.size)\n            for delta in nine_grid_deltas:\n                channel_data.paste(\n                    channel_pattern,\n                    (\n                        paste_offset[0] + delta[0] * channel_pattern.size[0],\n                        paste_offset[1] + delta[1] * channel_pattern.size[1],\n                    ),\n                )\n            chans.append(channel_data)\n        return Image.merge(mode, chans)\n\n    source_image = create_test_image()\n    source_image_aux = source_image.getchannel(preserved_channel)\n\n    # create some transform, it doesn't matter which one\n    source_profile = ImageCms.createProfile(\"sRGB\")\n    destination_profile = ImageCms.createProfile(\"sRGB\")\n    t = ImageCms.buildTransform(\n        source_profile, destination_profile, inMode=mode, outMode=mode\n    )\n\n    # apply transform\n    result_image: Image.Image | None\n    if transform_in_place:\n        ImageCms.applyTransform(source_image, t, inPlace=True)\n        result_image = source_image\n    else:\n        result_image = ImageCms.applyTransform(source_image, t, inPlace=False)\n    assert result_image is not None\n    result_image_aux = result_image.getchannel(preserved_channel)\n\n    assert_image_equal(source_image_aux, result_image_aux)\n\n\ndef test_preserve_auxiliary_channels_rgba() -> None:\n    assert_aux_channel_preserved(\n        mode=\"RGBA\", transform_in_place=False, preserved_channel=\"A\"\n    )\n\n\ndef test_preserve_auxiliary_channels_rgba_in_place() -> None:\n    assert_aux_channel_preserved(\n        mode=\"RGBA\", transform_in_place=True, preserved_channel=\"A\"\n    )\n\n\ndef test_preserve_auxiliary_channels_rgbx() -> None:\n    assert_aux_channel_preserved(\n        mode=\"RGBX\", transform_in_place=False, preserved_channel=\"X\"\n    )\n\n\ndef test_preserve_auxiliary_channels_rgbx_in_place() -> None:\n    assert_aux_channel_preserved(\n        mode=\"RGBX\", transform_in_place=True, preserved_channel=\"X\"\n    )\n\n\ndef test_auxiliary_channels_isolated() -> None:\n    # test data in aux channels does not affect non-aux channels\n    aux_channel_formats = [\n        # format, profile, color-only format, source test image\n        (\"RGBA\", \"sRGB\", \"RGB\", hopper(\"RGBA\")),\n        (\"RGBX\", \"sRGB\", \"RGB\", hopper(\"RGBX\")),\n        (\"LAB\", \"LAB\", \"LAB\", Image.open(\"Tests/images/hopper.Lab.tif\")),\n    ]\n    for src_format in aux_channel_formats:\n        for dst_format in aux_channel_formats:\n            for transform_in_place in [True, False]:\n                # inplace only if format doesn't change\n                if transform_in_place and src_format[0] != dst_format[0]:\n                    continue\n\n                # convert with and without AUX data, test colors are equal\n                src_colorSpace = cast(Literal[\"LAB\", \"XYZ\", \"sRGB\"], src_format[1])\n                source_profile = ImageCms.createProfile(src_colorSpace)\n                dst_colorSpace = cast(Literal[\"LAB\", \"XYZ\", \"sRGB\"], dst_format[1])\n                destination_profile = ImageCms.createProfile(dst_colorSpace)\n                source_image = src_format[3]\n                test_transform = ImageCms.buildTransform(\n                    source_profile,\n                    destination_profile,\n                    inMode=src_format[0],\n                    outMode=dst_format[0],\n                )\n\n                # test conversion from aux-ful source\n                test_image: Image.Image | None\n                if transform_in_place:\n                    test_image = source_image.copy()\n                    ImageCms.applyTransform(test_image, test_transform, inPlace=True)\n                else:\n                    test_image = ImageCms.applyTransform(\n                        source_image, test_transform, inPlace=False\n                    )\n                assert test_image is not None\n\n                # reference conversion from aux-less source\n                reference_transform = ImageCms.buildTransform(\n                    source_profile,\n                    destination_profile,\n                    inMode=src_format[2],\n                    outMode=dst_format[2],\n                )\n                reference_image = ImageCms.applyTransform(\n                    source_image.convert(src_format[2]), reference_transform\n                )\n                assert reference_image is not None\n                assert_image_equal(test_image.convert(dst_format[2]), reference_image)\n\n\ndef test_long_modes() -> None:\n    p = ImageCms.getOpenProfile(\"Tests/icc/sGrey-v2-nano.icc\")\n    ImageCms.buildTransform(p, p, \"ABCDEFGHI\", \"ABCDEFGHI\")\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"RGBA\", \"RGBX\"))\ndef test_rgb_lab(mode: str) -> None:\n    im = Image.new(mode, (1, 1))\n    converted_im = im.convert(\"LAB\")\n    assert converted_im.getpixel((0, 0)) == (0, 128, 128)\n\n    im = Image.new(\"LAB\", (1, 1), (255, 0, 0))\n    converted_im = im.convert(mode)\n    assert converted_im.getpixel((0, 0))[:3] == (0, 255, 255)\n\n\ndef test_deprecation() -> None:\n    with pytest.warns(DeprecationWarning):\n        assert ImageCms.DESCRIPTION.strip().startswith(\"pyCMS\")\n    with pytest.warns(DeprecationWarning):\n        assert ImageCms.VERSION == \"1.0.0 pil\"\n    with pytest.warns(DeprecationWarning):\n        assert isinstance(ImageCms.FLAGS, dict)\n", "Tests/test_imagepath.py": "from __future__ import annotations\n\nimport array\nimport math\nimport struct\nfrom typing import Sequence\n\nimport pytest\n\nfrom PIL import Image, ImagePath\n\n\ndef test_path() -> None:\n    p = ImagePath.Path(list(range(10)))\n\n    # sequence interface\n    assert len(p) == 5\n    assert p[0] == (0.0, 1.0)\n    assert p[-1] == (8.0, 9.0)\n    assert list(p[:1]) == [(0.0, 1.0)]\n    with pytest.raises(TypeError) as cm:\n        p[\"foo\"]\n    assert str(cm.value) == \"Path indices must be integers, not str\"\n    assert list(p) == [(0.0, 1.0), (2.0, 3.0), (4.0, 5.0), (6.0, 7.0), (8.0, 9.0)]\n\n    # method sanity check\n    assert p.tolist() == [\n        (0.0, 1.0),\n        (2.0, 3.0),\n        (4.0, 5.0),\n        (6.0, 7.0),\n        (8.0, 9.0),\n    ]\n    assert p.tolist(True) == [0.0, 1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0]\n\n    assert p.getbbox() == (0.0, 1.0, 8.0, 9.0)\n\n    assert p.compact(5) == 2\n    assert list(p) == [(0.0, 1.0), (4.0, 5.0), (8.0, 9.0)]\n\n    p.transform((1, 0, 1, 0, 1, 1))\n    assert list(p) == [(1.0, 2.0), (5.0, 6.0), (9.0, 10.0)]\n\n\n@pytest.mark.parametrize(\n    \"coords\",\n    (\n        (0, 1),\n        [0, 1],\n        (0.0, 1.0),\n        [0.0, 1.0],\n        ((0, 1),),\n        [(0, 1)],\n        ((0.0, 1.0),),\n        [(0.0, 1.0)],\n        array.array(\"f\", [0, 1]),\n        array.array(\"f\", [0, 1]).tobytes(),\n        ImagePath.Path((0, 1)),\n    ),\n)\ndef test_path_constructors(\n    coords: Sequence[float] | array.array[float] | ImagePath.Path,\n) -> None:\n    # Arrange / Act\n    p = ImagePath.Path(coords)\n\n    # Assert\n    assert list(p) == [(0.0, 1.0)]\n\n\n@pytest.mark.parametrize(\n    \"coords\",\n    (\n        (\"a\", \"b\"),\n        ([0, 1],),\n        [[0, 1]],\n        ([0.0, 1.0],),\n        [[0.0, 1.0]],\n    ),\n)\ndef test_invalid_path_constructors(\n    coords: tuple[str, str] | Sequence[Sequence[int]]\n) -> None:\n    # Act\n    with pytest.raises(ValueError) as e:\n        ImagePath.Path(coords)\n\n    # Assert\n    assert str(e.value) == \"incorrect coordinate type\"\n\n\n@pytest.mark.parametrize(\n    \"coords\",\n    (\n        (0,),\n        [0],\n        (0, 1, 2),\n        [0, 1, 2],\n    ),\n)\ndef test_path_odd_number_of_coordinates(coords: Sequence[int]) -> None:\n    # Act\n    with pytest.raises(ValueError) as e:\n        ImagePath.Path(coords)\n\n    # Assert\n    assert str(e.value) == \"wrong number of coordinates\"\n\n\n@pytest.mark.parametrize(\n    \"coords, expected\",\n    [\n        ([0, 1, 2, 3], (0.0, 1.0, 2.0, 3.0)),\n        ([3, 2, 1, 0], (1.0, 0.0, 3.0, 2.0)),\n        (0, (0.0, 0.0, 0.0, 0.0)),\n        (1, (0.0, 0.0, 0.0, 0.0)),\n    ],\n)\ndef test_getbbox(\n    coords: int | list[int], expected: tuple[float, float, float, float]\n) -> None:\n    # Arrange\n    p = ImagePath.Path(coords)\n\n    # Act / Assert\n    assert p.getbbox() == expected\n\n\ndef test_getbbox_no_args() -> None:\n    # Arrange\n    p = ImagePath.Path([0, 1, 2, 3])\n\n    # Act / Assert\n    with pytest.raises(TypeError):\n        p.getbbox(1)\n\n\n@pytest.mark.parametrize(\n    \"coords, expected\",\n    [\n        (0, []),\n        (list(range(6)), [(0.0, 3.0), (4.0, 9.0), (8.0, 15.0)]),\n    ],\n)\ndef test_map(coords: int | list[int], expected: list[tuple[float, float]]) -> None:\n    # Arrange\n    p = ImagePath.Path(coords)\n\n    # Act\n    # Modifies the path in-place\n    p.map(lambda x, y: (x * 2, y * 3))\n\n    # Assert\n    assert list(p) == expected\n\n\ndef test_transform() -> None:\n    # Arrange\n    p = ImagePath.Path([0, 1, 2, 3])\n    theta = math.pi / 15\n\n    # Act\n    # Affine transform, in-place\n    p.transform(\n        (math.cos(theta), math.sin(theta), 20, -math.sin(theta), math.cos(theta), 20),\n    )\n\n    # Assert\n    assert p.tolist() == [\n        (20.20791169081776, 20.978147600733806),\n        (22.58003027392089, 22.518619420565898),\n    ]\n\n\ndef test_transform_with_wrap() -> None:\n    # Arrange\n    p = ImagePath.Path([0, 1, 2, 3])\n    theta = math.pi / 15\n\n    # Act\n    # Affine transform, in-place, with wrap parameter\n    p.transform(\n        (math.cos(theta), math.sin(theta), 20, -math.sin(theta), math.cos(theta), 20),\n        1.0,\n    )\n\n    # Assert\n    assert p.tolist() == [\n        (0.20791169081775962, 20.978147600733806),\n        (0.5800302739208902, 22.518619420565898),\n    ]\n\n\ndef test_overflow_segfault() -> None:\n    # Some Pythons fail getting the argument as an integer, and it falls\n    # through to the sequence. Seeing this on 32-bit Windows.\n    with pytest.raises((TypeError, MemoryError)):\n        # post patch, this fails with a memory error\n        x = Evil()\n\n        # This fails due to the invalid malloc above,\n        # and segfaults\n        for i in range(200000):\n            x[i] = b\"0\" * 16\n\n\nclass Evil:\n    def __init__(self) -> None:\n        self.corrupt = Image.core.path(0x4000000000000000)\n\n    def __getitem__(self, i: int) -> bytes:\n        x = self.corrupt[i]\n        return struct.pack(\"dd\", x[0], x[1])\n\n    def __setitem__(self, i: int, x: bytes) -> None:\n        self.corrupt[i] = struct.unpack(\"dd\", x)\n", "Tests/test_file_libtiff_small.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom pathlib import Path\n\nfrom PIL import Image\n\nfrom .test_file_libtiff import LibTiffTestCase\n\n\nclass TestFileLibTiffSmall(LibTiffTestCase):\n    \"\"\"The small lena image was failing on open in the libtiff\n    decoder because the file pointer was set to the wrong place\n    by a spurious seek. It wasn't failing with the byteio method.\n\n    It was fixed by forcing an lseek to the beginning of the\n    file just before reading in libtiff. These tests remain\n    to ensure that it stays fixed.\"\"\"\n\n    def test_g4_hopper_file(self, tmp_path: Path) -> None:\n        \"\"\"Testing the open file load path\"\"\"\n\n        test_file = \"Tests/images/hopper_g4.tif\"\n        with open(test_file, \"rb\") as f:\n            with Image.open(f) as im:\n                assert im.size == (128, 128)\n                self._assert_noerr(tmp_path, im)\n\n    def test_g4_hopper_bytesio(self, tmp_path: Path) -> None:\n        \"\"\"Testing the bytesio loading code path\"\"\"\n        test_file = \"Tests/images/hopper_g4.tif\"\n        s = BytesIO()\n        with open(test_file, \"rb\") as f:\n            s.write(f.read())\n            s.seek(0)\n        with Image.open(s) as im:\n            assert im.size == (128, 128)\n            self._assert_noerr(tmp_path, im)\n\n    def test_g4_hopper(self, tmp_path: Path) -> None:\n        \"\"\"The 128x128 lena image failed for some reason.\"\"\"\n\n        test_file = \"Tests/images/hopper_g4.tif\"\n        with Image.open(test_file) as im:\n            assert im.size == (128, 128)\n            self._assert_noerr(tmp_path, im)\n", "Tests/test_binary.py": "from __future__ import annotations\n\nfrom PIL import _binary\n\n\ndef test_standard() -> None:\n    assert _binary.i8(b\"*\") == 42\n    assert _binary.o8(42) == b\"*\"\n\n\ndef test_little_endian() -> None:\n    assert _binary.i16le(b\"\\xff\\xff\\x00\\x00\") == 65535\n    assert _binary.i32le(b\"\\xff\\xff\\x00\\x00\") == 65535\n\n    assert _binary.o16le(65535) == b\"\\xff\\xff\"\n    assert _binary.o32le(65535) == b\"\\xff\\xff\\x00\\x00\"\n\n\ndef test_big_endian() -> None:\n    assert _binary.i16be(b\"\\x00\\x00\\xff\\xff\") == 0\n    assert _binary.i32be(b\"\\x00\\x00\\xff\\xff\") == 65535\n\n    assert _binary.o16be(65535) == b\"\\xff\\xff\"\n    assert _binary.o32be(65535) == b\"\\x00\\x00\\xff\\xff\"\n", "Tests/check_libtiff_segfault.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nTEST_FILE = \"Tests/images/libtiff_segfault.tif\"\n\n\ndef test_libtiff_segfault() -> None:\n    \"\"\"This test should not segfault. It will on Pillow <= 3.1.0 and\n    libtiff >= 4.0.0\n    \"\"\"\n\n    with pytest.raises(OSError):\n        with Image.open(TEST_FILE) as im:\n            im.load()\n", "Tests/test_tiff_ifdrational.py": "from __future__ import annotations\n\nfrom fractions import Fraction\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, TiffImagePlugin\nfrom PIL.TiffImagePlugin import IFDRational\n\nfrom .helper import hopper, skip_unless_feature\n\n\ndef _test_equal(num, denom, target) -> None:\n    t = IFDRational(num, denom)\n\n    assert target == t\n    assert t == target\n\n\ndef test_sanity() -> None:\n    _test_equal(1, 1, 1)\n    _test_equal(1, 1, Fraction(1, 1))\n\n    _test_equal(2, 2, 1)\n    _test_equal(1.0, 1, Fraction(1, 1))\n\n    _test_equal(Fraction(1, 1), 1, Fraction(1, 1))\n    _test_equal(IFDRational(1, 1), 1, 1)\n\n    _test_equal(1, 2, Fraction(1, 2))\n    _test_equal(1, 2, IFDRational(1, 2))\n\n    _test_equal(7, 5, 1.4)\n\n\ndef test_ranges() -> None:\n    for num in range(1, 10):\n        for denom in range(1, 10):\n            assert IFDRational(num, denom) == IFDRational(num, denom)\n\n\ndef test_nonetype() -> None:\n    # Fails if the _delegate function doesn't return a valid function\n\n    xres = IFDRational(72)\n    yres = IFDRational(72)\n    assert xres._val is not None\n    assert xres.numerator is not None\n    assert xres.denominator is not None\n    assert yres._val is not None\n\n    assert xres and 1\n    assert xres and yres\n\n\n@pytest.mark.parametrize(\n    \"libtiff\", (pytest.param(True, marks=skip_unless_feature(\"libtiff\")), False)\n)\ndef test_ifd_rational_save(\n    monkeypatch: pytest.MonkeyPatch, tmp_path: Path, libtiff: bool\n) -> None:\n    im = hopper()\n    out = str(tmp_path / \"temp.tiff\")\n    res = IFDRational(301, 1)\n\n    monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", libtiff)\n    im.save(out, dpi=(res, res), compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert float(IFDRational(301, 1)) == float(reloaded.tag_v2[282])\n", "Tests/test_image_access.py": "from __future__ import annotations\n\nimport os\nimport subprocess\nimport sys\nimport sysconfig\nfrom types import ModuleType\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal, hopper, is_win32\n\n# CFFI imports pycparser which doesn't support PYTHONOPTIMIZE=2\n# https://github.com/eliben/pycparser/pull/198#issuecomment-317001670\ncffi: ModuleType | None\nif os.environ.get(\"PYTHONOPTIMIZE\") == \"2\":\n    cffi = None\nelse:\n    try:\n        import cffi\n\n        from PIL import PyAccess\n    except ImportError:\n        cffi = None\n\nnumpy: ModuleType | None\ntry:\n    import numpy\nexcept ImportError:\n    numpy = None\n\n\nclass AccessTest:\n    # Initial value\n    _init_cffi_access = Image.USE_CFFI_ACCESS\n    _need_cffi_access = False\n\n    @classmethod\n    def setup_class(cls) -> None:\n        Image.USE_CFFI_ACCESS = cls._need_cffi_access\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        Image.USE_CFFI_ACCESS = cls._init_cffi_access\n\n\nclass TestImagePutPixel(AccessTest):\n    def test_sanity(self) -> None:\n        im1 = hopper()\n        im2 = Image.new(im1.mode, im1.size, 0)\n\n        for y in range(im1.size[1]):\n            for x in range(im1.size[0]):\n                pos = x, y\n                im2.putpixel(pos, im1.getpixel(pos))\n\n        assert_image_equal(im1, im2)\n\n        im2 = Image.new(im1.mode, im1.size, 0)\n        im2.readonly = 1\n\n        for y in range(im1.size[1]):\n            for x in range(im1.size[0]):\n                pos = x, y\n                im2.putpixel(pos, im1.getpixel(pos))\n\n        assert not im2.readonly\n        assert_image_equal(im1, im2)\n\n        im2 = Image.new(im1.mode, im1.size, 0)\n\n        pix1 = im1.load()\n        pix2 = im2.load()\n\n        with pytest.raises(TypeError):\n            pix1[0, \"0\"]\n        with pytest.raises(TypeError):\n            pix1[\"0\", 0]\n\n        for y in range(im1.size[1]):\n            for x in range(im1.size[0]):\n                pix2[x, y] = pix1[x, y]\n\n        assert_image_equal(im1, im2)\n\n    def test_sanity_negative_index(self) -> None:\n        im1 = hopper()\n        im2 = Image.new(im1.mode, im1.size, 0)\n\n        width, height = im1.size\n        assert im1.getpixel((0, 0)) == im1.getpixel((-width, -height))\n        assert im1.getpixel((-1, -1)) == im1.getpixel((width - 1, height - 1))\n\n        for y in range(-1, -im1.size[1] - 1, -1):\n            for x in range(-1, -im1.size[0] - 1, -1):\n                pos = x, y\n                im2.putpixel(pos, im1.getpixel(pos))\n\n        assert_image_equal(im1, im2)\n\n        im2 = Image.new(im1.mode, im1.size, 0)\n        im2.readonly = 1\n\n        for y in range(-1, -im1.size[1] - 1, -1):\n            for x in range(-1, -im1.size[0] - 1, -1):\n                pos = x, y\n                im2.putpixel(pos, im1.getpixel(pos))\n\n        assert not im2.readonly\n        assert_image_equal(im1, im2)\n\n        im2 = Image.new(im1.mode, im1.size, 0)\n\n        pix1 = im1.load()\n        pix2 = im2.load()\n\n        for y in range(-1, -im1.size[1] - 1, -1):\n            for x in range(-1, -im1.size[0] - 1, -1):\n                pix2[x, y] = pix1[x, y]\n\n        assert_image_equal(im1, im2)\n\n    @pytest.mark.skipif(numpy is None, reason=\"NumPy not installed\")\n    def test_numpy(self) -> None:\n        im = hopper()\n        pix = im.load()\n\n        assert numpy is not None\n        assert pix[numpy.int32(1), numpy.int32(2)] == (18, 20, 59)\n\n\nclass TestImageGetPixel(AccessTest):\n    @staticmethod\n    def color(mode: str) -> int | tuple[int, ...]:\n        bands = Image.getmodebands(mode)\n        if bands == 1:\n            return 1\n        if mode in (\"BGR;15\", \"BGR;16\"):\n            # These modes have less than 8 bits per band,\n            # so (1, 2, 3) cannot be roundtripped.\n            return (16, 32, 49)\n        return tuple(range(1, bands + 1))\n\n    def check(self, mode: str, expected_color_int: int | None = None) -> None:\n        if self._need_cffi_access and mode.startswith(\"BGR;\"):\n            pytest.skip(\"Support not added to deprecated module for BGR;* modes\")\n\n        expected_color = (\n            self.color(mode) if expected_color_int is None else expected_color_int\n        )\n\n        # Check putpixel\n        im = Image.new(mode, (1, 1), None)\n        im.putpixel((0, 0), expected_color)\n        actual_color = im.getpixel((0, 0))\n        assert actual_color == expected_color, (\n            f\"put/getpixel roundtrip failed for mode {mode}, \"\n            f\"expected {expected_color} got {actual_color}\"\n        )\n\n        # Check putpixel negative index\n        im.putpixel((-1, -1), expected_color)\n        actual_color = im.getpixel((-1, -1))\n        assert actual_color == expected_color, (\n            f\"put/getpixel roundtrip negative index failed for mode {mode}, \"\n            f\"expected {expected_color} got {actual_color}\"\n        )\n\n        # Check 0x0 image with None initial color\n        im = Image.new(mode, (0, 0), None)\n        assert im.load() is not None\n        error = ValueError if self._need_cffi_access else IndexError\n        with pytest.raises(error):\n            im.putpixel((0, 0), expected_color)\n        with pytest.raises(error):\n            im.getpixel((0, 0))\n        # Check negative index\n        with pytest.raises(error):\n            im.putpixel((-1, -1), expected_color)\n        with pytest.raises(error):\n            im.getpixel((-1, -1))\n\n        # Check initial color\n        im = Image.new(mode, (1, 1), expected_color)\n        actual_color = im.getpixel((0, 0))\n        assert actual_color == expected_color, (\n            f\"initial color failed for mode {mode}, \"\n            f\"expected {expected_color} got {actual_color}\"\n        )\n\n        # Check initial color negative index\n        actual_color = im.getpixel((-1, -1))\n        assert actual_color == expected_color, (\n            f\"initial color failed with negative index for mode {mode}, \"\n            f\"expected {expected_color} got {actual_color}\"\n        )\n\n        # Check 0x0 image with initial color\n        im = Image.new(mode, (0, 0), expected_color)\n        with pytest.raises(error):\n            im.getpixel((0, 0))\n        # Check negative index\n        with pytest.raises(error):\n            im.getpixel((-1, -1))\n\n    @pytest.mark.parametrize(\"mode\", Image.MODES)\n    def test_basic(self, mode: str) -> None:\n        self.check(mode)\n\n    @pytest.mark.parametrize(\"mode\", (\"BGR;15\", \"BGR;16\", \"BGR;24\"))\n    def test_deprecated(self, mode: str) -> None:\n        with pytest.warns(DeprecationWarning):\n            self.check(mode)\n\n    def test_list(self) -> None:\n        im = hopper()\n        assert im.getpixel([0, 0]) == (20, 20, 70)\n\n    @pytest.mark.parametrize(\"mode\", (\"I;16\", \"I;16B\"))\n    @pytest.mark.parametrize(\"expected_color\", (2**15 - 1, 2**15, 2**15 + 1, 2**16 - 1))\n    def test_signedness(self, mode: str, expected_color: int) -> None:\n        # See https://github.com/python-pillow/Pillow/issues/452\n        # pixelaccess is using signed int* instead of uint*\n        self.check(mode, expected_color)\n\n    @pytest.mark.parametrize(\"mode\", (\"P\", \"PA\"))\n    @pytest.mark.parametrize(\"color\", ((255, 0, 0), (255, 0, 0, 255)))\n    def test_p_putpixel_rgb_rgba(self, mode: str, color: tuple[int, ...]) -> None:\n        im = Image.new(mode, (1, 1))\n        im.putpixel((0, 0), color)\n\n        alpha = color[3] if len(color) == 4 and mode == \"PA\" else 255\n        assert im.convert(\"RGBA\").getpixel((0, 0)) == (255, 0, 0, alpha)\n\n\n@pytest.mark.filterwarnings(\"ignore::DeprecationWarning\")\n@pytest.mark.skipif(cffi is None, reason=\"No CFFI\")\nclass TestCffiPutPixel(TestImagePutPixel):\n    _need_cffi_access = True\n\n\n@pytest.mark.filterwarnings(\"ignore::DeprecationWarning\")\n@pytest.mark.skipif(cffi is None, reason=\"No CFFI\")\nclass TestCffiGetPixel(TestImageGetPixel):\n    _need_cffi_access = True\n\n\n@pytest.mark.skipif(cffi is None, reason=\"No CFFI\")\nclass TestCffi(AccessTest):\n    _need_cffi_access = True\n\n    def _test_get_access(self, im: Image.Image) -> None:\n        \"\"\"Do we get the same thing as the old pixel access\n\n        Using private interfaces, forcing a capi access and\n        a pyaccess for the same image\"\"\"\n        caccess = im.im.pixel_access(False)\n        with pytest.warns(DeprecationWarning):\n            access = PyAccess.new(im, False)\n        assert access is not None\n\n        w, h = im.size\n        for x in range(0, w, 10):\n            for y in range(0, h, 10):\n                assert access[(x, y)] == caccess[(x, y)]\n\n        # Access an out-of-range pixel\n        with pytest.raises(ValueError):\n            access[(access.xsize + 1, access.ysize + 1)]\n\n    def test_get_vs_c(self) -> None:\n        with pytest.warns(DeprecationWarning):\n            rgb = hopper(\"RGB\")\n            rgb.load()\n            self._test_get_access(rgb)\n            for mode in (\"RGBA\", \"L\", \"LA\", \"1\", \"P\", \"F\"):\n                self._test_get_access(hopper(mode))\n\n            for mode in (\"I;16\", \"I;16L\", \"I;16B\", \"I;16N\", \"I\"):\n                im = Image.new(mode, (10, 10), 40000)\n                self._test_get_access(im)\n\n    def _test_set_access(self, im: Image.Image, color: tuple[int, ...] | float) -> None:\n        \"\"\"Are we writing the correct bits into the image?\n\n        Using private interfaces, forcing a capi access and\n        a pyaccess for the same image\"\"\"\n        caccess = im.im.pixel_access(False)\n        with pytest.warns(DeprecationWarning):\n            access = PyAccess.new(im, False)\n        assert access is not None\n\n        w, h = im.size\n        for x in range(0, w, 10):\n            for y in range(0, h, 10):\n                access[(x, y)] = color\n                assert color == caccess[(x, y)]\n\n        # Attempt to set the value on a read-only image\n        with pytest.warns(DeprecationWarning):\n            access = PyAccess.new(im, True)\n        assert access is not None\n\n        with pytest.raises(ValueError):\n            access[(0, 0)] = color\n\n    def test_set_vs_c(self) -> None:\n        rgb = hopper(\"RGB\")\n        with pytest.warns(DeprecationWarning):\n            rgb.load()\n        self._test_set_access(rgb, (255, 128, 0))\n        self._test_set_access(hopper(\"RGBA\"), (255, 192, 128, 0))\n        self._test_set_access(hopper(\"L\"), 128)\n        self._test_set_access(hopper(\"LA\"), (128, 128))\n        self._test_set_access(hopper(\"1\"), 255)\n        self._test_set_access(hopper(\"P\"), 128)\n        self._test_set_access(hopper(\"PA\"), (128, 128))\n        self._test_set_access(hopper(\"F\"), 1024.0)\n\n        for mode in (\"I;16\", \"I;16L\", \"I;16B\", \"I;16N\", \"I\"):\n            im = Image.new(mode, (10, 10), 40000)\n            self._test_set_access(im, 45000)\n\n    @pytest.mark.filterwarnings(\"ignore::DeprecationWarning\")\n    def test_not_implemented(self) -> None:\n        assert PyAccess.new(hopper(\"BGR;15\")) is None\n\n    # Ref https://github.com/python-pillow/Pillow/pull/2009\n    def test_reference_counting(self) -> None:\n        size = 10\n\n        for _ in range(10):\n            # Do not save references to the image, only to the access object\n            with pytest.warns(DeprecationWarning):\n                px = Image.new(\"L\", (size, 1), 0).load()\n            for i in range(size):\n                # Pixels can contain garbage if image is released\n                assert px[i, 0] == 0\n\n    @pytest.mark.parametrize(\"mode\", (\"P\", \"PA\"))\n    def test_p_putpixel_rgb_rgba(self, mode: str) -> None:\n        for color in ((255, 0, 0), (255, 0, 0, 127 if mode == \"PA\" else 255)):\n            im = Image.new(mode, (1, 1))\n            with pytest.warns(DeprecationWarning):\n                access = PyAccess.new(im, False)\n                assert access is not None\n\n                access.putpixel((0, 0), color)\n\n                if len(color) == 3:\n                    color += (255,)\n                assert im.convert(\"RGBA\").getpixel((0, 0)) == color\n\n\nclass TestImagePutPixelError(AccessTest):\n    IMAGE_MODES1 = [\"LA\", \"RGB\", \"RGBA\", \"BGR;15\"]\n    IMAGE_MODES2 = [\"L\", \"I\", \"I;16\"]\n    INVALID_TYPES = [\"foo\", 1.0, None]\n\n    @pytest.mark.parametrize(\"mode\", IMAGE_MODES1)\n    def test_putpixel_type_error1(self, mode: str) -> None:\n        im = hopper(mode)\n        for v in self.INVALID_TYPES:\n            with pytest.raises(TypeError, match=\"color must be int or tuple\"):\n                im.putpixel((0, 0), v)\n\n    @pytest.mark.parametrize(\n        (\"mode\", \"band_numbers\", \"match\"),\n        (\n            (\"L\", (0, 2), \"color must be int or single-element tuple\"),\n            (\"LA\", (0, 3), \"color must be int, or tuple of one or two elements\"),\n            (\n                \"BGR;15\",\n                (0, 2),\n                \"color must be int, or tuple of one or three elements\",\n            ),\n            (\n                \"RGB\",\n                (0, 2, 5),\n                \"color must be int, or tuple of one, three or four elements\",\n            ),\n        ),\n    )\n    def test_putpixel_invalid_number_of_bands(\n        self, mode: str, band_numbers: tuple[int, ...], match: str\n    ) -> None:\n        im = hopper(mode)\n        for band_number in band_numbers:\n            with pytest.raises(TypeError, match=match):\n                im.putpixel((0, 0), (0,) * band_number)\n\n    @pytest.mark.parametrize(\"mode\", IMAGE_MODES2)\n    def test_putpixel_type_error2(self, mode: str) -> None:\n        im = hopper(mode)\n        for v in self.INVALID_TYPES:\n            with pytest.raises(\n                TypeError, match=\"color must be int or single-element tuple\"\n            ):\n                im.putpixel((0, 0), v)\n\n    @pytest.mark.parametrize(\"mode\", IMAGE_MODES1 + IMAGE_MODES2)\n    def test_putpixel_overflow_error(self, mode: str) -> None:\n        im = hopper(mode)\n        with pytest.raises(OverflowError):\n            im.putpixel((0, 0), 2**80)\n\n\nclass TestEmbeddable:\n    @pytest.mark.xfail(reason=\"failing test\")\n    @pytest.mark.skipif(not is_win32(), reason=\"requires Windows\")\n    def test_embeddable(self) -> None:\n        import ctypes\n\n        from setuptools.command import build_ext\n\n        with open(\"embed_pil.c\", \"w\", encoding=\"utf-8\") as fh:\n            home = sys.prefix.replace(\"\\\\\", \"\\\\\\\\\")\n            fh.write(\n                f\"\"\"\n#include \"Python.h\"\n\nint main(int argc, char* argv[])\n{{\n    char *home = \"{home}\";\n    wchar_t *whome = Py_DecodeLocale(home, NULL);\n    Py_SetPythonHome(whome);\n\n    Py_InitializeEx(0);\n    Py_DECREF(PyImport_ImportModule(\"PIL.Image\"));\n    Py_Finalize();\n\n    Py_InitializeEx(0);\n    Py_DECREF(PyImport_ImportModule(\"PIL.Image\"));\n    Py_Finalize();\n\n    PyMem_RawFree(whome);\n\n    return 0;\n}}\n        \"\"\"\n            )\n\n        compiler = getattr(build_ext, \"new_compiler\")()\n        compiler.add_include_dir(sysconfig.get_config_var(\"INCLUDEPY\"))\n\n        libdir = sysconfig.get_config_var(\"LIBDIR\") or sysconfig.get_config_var(\n            \"INCLUDEPY\"\n        ).replace(\"include\", \"libs\")\n        compiler.add_library_dir(libdir)\n        objects = compiler.compile([\"embed_pil.c\"])\n        compiler.link_executable(objects, \"embed_pil\")\n\n        env = os.environ.copy()\n        env[\"PATH\"] = sys.prefix + \";\" + env[\"PATH\"]\n\n        # Do not display the Windows Error Reporting dialog\n        getattr(ctypes, \"windll\").kernel32.SetErrorMode(0x0002)\n\n        process = subprocess.Popen([\"embed_pil.exe\"], env=env)\n        process.communicate()\n        assert process.returncode == 0\n", "Tests/test_file_container.py": "from __future__ import annotations\n\nfrom typing import Literal\n\nimport pytest\n\nfrom PIL import ContainerIO, Image\n\nfrom .helper import hopper\n\nTEST_FILE = \"Tests/images/dummy.container\"\n\n\ndef test_sanity() -> None:\n    dir(Image)\n    dir(ContainerIO)\n\n\ndef test_isatty() -> None:\n    with hopper() as im:\n        container = ContainerIO.ContainerIO(im, 0, 0)\n\n    assert container.isatty() is False\n\n\n@pytest.mark.parametrize(\n    \"mode, expected_position\",\n    (\n        (0, 33),\n        (1, 66),\n        (2, 100),\n    ),\n)\ndef test_seek_mode(mode: Literal[0, 1, 2], expected_position: int) -> None:\n    # Arrange\n    with open(TEST_FILE, \"rb\") as fh:\n        container = ContainerIO.ContainerIO(fh, 22, 100)\n\n        # Act\n        container.seek(33, mode)\n        container.seek(33, mode)\n\n        # Assert\n        assert container.tell() == expected_position\n\n\n@pytest.mark.parametrize(\"bytesmode\", (True, False))\ndef test_read_n0(bytesmode: bool) -> None:\n    # Arrange\n    with open(TEST_FILE, \"rb\" if bytesmode else \"r\") as fh:\n        container = ContainerIO.ContainerIO(fh, 22, 100)\n\n        # Act\n        container.seek(81)\n        data = container.read()\n\n        # Assert\n        if bytesmode:\n            data = data.decode()\n        assert data == \"7\\nThis is line 8\\n\"\n\n\n@pytest.mark.parametrize(\"bytesmode\", (True, False))\ndef test_read_n(bytesmode: bool) -> None:\n    # Arrange\n    with open(TEST_FILE, \"rb\" if bytesmode else \"r\") as fh:\n        container = ContainerIO.ContainerIO(fh, 22, 100)\n\n        # Act\n        container.seek(81)\n        data = container.read(3)\n\n        # Assert\n        if bytesmode:\n            data = data.decode()\n        assert data == \"7\\nT\"\n\n\n@pytest.mark.parametrize(\"bytesmode\", (True, False))\ndef test_read_eof(bytesmode: bool) -> None:\n    # Arrange\n    with open(TEST_FILE, \"rb\" if bytesmode else \"r\") as fh:\n        container = ContainerIO.ContainerIO(fh, 22, 100)\n\n        # Act\n        container.seek(100)\n        data = container.read()\n\n        # Assert\n        if bytesmode:\n            data = data.decode()\n        assert data == \"\"\n\n\n@pytest.mark.parametrize(\"bytesmode\", (True, False))\ndef test_readline(bytesmode: bool) -> None:\n    # Arrange\n    with open(TEST_FILE, \"rb\" if bytesmode else \"r\") as fh:\n        container = ContainerIO.ContainerIO(fh, 0, 120)\n\n        # Act\n        data = container.readline()\n\n        # Assert\n        if bytesmode:\n            data = data.decode()\n        assert data == \"This is line 1\\n\"\n\n\n@pytest.mark.parametrize(\"bytesmode\", (True, False))\ndef test_readlines(bytesmode: bool) -> None:\n    # Arrange\n    expected = [\n        \"This is line 1\\n\",\n        \"This is line 2\\n\",\n        \"This is line 3\\n\",\n        \"This is line 4\\n\",\n        \"This is line 5\\n\",\n        \"This is line 6\\n\",\n        \"This is line 7\\n\",\n        \"This is line 8\\n\",\n    ]\n    with open(TEST_FILE, \"rb\" if bytesmode else \"r\") as fh:\n        container = ContainerIO.ContainerIO(fh, 0, 120)\n\n        # Act\n        data = container.readlines()\n\n        # Assert\n        if bytesmode:\n            data = [line.decode() for line in data]\n        assert data == expected\n", "Tests/test_pdfparser.py": "from __future__ import annotations\n\nimport time\n\nimport pytest\n\nfrom PIL.PdfParser import (\n    IndirectObjectDef,\n    IndirectReference,\n    PdfBinary,\n    PdfDict,\n    PdfFormatError,\n    PdfName,\n    PdfParser,\n    PdfStream,\n    decode_text,\n    encode_text,\n    pdf_repr,\n)\n\n\ndef test_text_encode_decode() -> None:\n    assert encode_text(\"abc\") == b\"\\xFE\\xFF\\x00a\\x00b\\x00c\"\n    assert decode_text(b\"\\xFE\\xFF\\x00a\\x00b\\x00c\") == \"abc\"\n    assert decode_text(b\"abc\") == \"abc\"\n    assert decode_text(b\"\\x1B a \\x1C\") == \"\\u02D9 a \\u02DD\"\n\n\ndef test_indirect_refs() -> None:\n    assert IndirectReference(1, 2) == IndirectReference(1, 2)\n    assert IndirectReference(1, 2) != IndirectReference(1, 3)\n    assert IndirectReference(1, 2) != IndirectObjectDef(1, 2)\n    assert IndirectReference(1, 2) != (1, 2)\n    assert IndirectObjectDef(1, 2) == IndirectObjectDef(1, 2)\n    assert IndirectObjectDef(1, 2) != IndirectObjectDef(1, 3)\n    assert IndirectObjectDef(1, 2) != IndirectReference(1, 2)\n    assert IndirectObjectDef(1, 2) != (1, 2)\n\n\ndef test_parsing() -> None:\n    assert PdfParser.interpret_name(b\"Name#23Hash\") == b\"Name#Hash\"\n    assert PdfParser.interpret_name(b\"Name#23Hash\", as_text=True) == \"Name#Hash\"\n    assert PdfParser.get_value(b\"1 2 R \", 0) == (IndirectReference(1, 2), 5)\n    assert PdfParser.get_value(b\"true[\", 0) == (True, 4)\n    assert PdfParser.get_value(b\"false%\", 0) == (False, 5)\n    assert PdfParser.get_value(b\"null<\", 0) == (None, 4)\n    assert PdfParser.get_value(b\"%cmt\\n %cmt\\n 123\\n\", 0) == (123, 15)\n    assert PdfParser.get_value(b\"<901FA3>\", 0) == (b\"\\x90\\x1F\\xA3\", 8)\n    assert PdfParser.get_value(b\"asd < 9 0 1 f A > qwe\", 3) == (b\"\\x90\\x1F\\xA0\", 17)\n    assert PdfParser.get_value(b\"(asd)\", 0) == (b\"asd\", 5)\n    assert PdfParser.get_value(b\"(asd(qwe)zxc)zzz(aaa)\", 0) == (b\"asd(qwe)zxc\", 13)\n    assert PdfParser.get_value(b\"(Two \\\\\\nwords.)\", 0) == (b\"Two words.\", 14)\n    assert PdfParser.get_value(b\"(Two\\nlines.)\", 0) == (b\"Two\\nlines.\", 12)\n    assert PdfParser.get_value(b\"(Two\\r\\nlines.)\", 0) == (b\"Two\\nlines.\", 13)\n    assert PdfParser.get_value(b\"(Two\\\\nlines.)\", 0) == (b\"Two\\nlines.\", 13)\n    assert PdfParser.get_value(b\"(One\\\\(paren).\", 0) == (b\"One(paren\", 12)\n    assert PdfParser.get_value(b\"(One\\\\)paren).\", 0) == (b\"One)paren\", 12)\n    assert PdfParser.get_value(b\"(\\\\0053)\", 0) == (b\"\\x053\", 7)\n    assert PdfParser.get_value(b\"(\\\\053)\", 0) == (b\"\\x2B\", 6)\n    assert PdfParser.get_value(b\"(\\\\53)\", 0) == (b\"\\x2B\", 5)\n    assert PdfParser.get_value(b\"(\\\\53a)\", 0) == (b\"\\x2Ba\", 6)\n    assert PdfParser.get_value(b\"(\\\\1111)\", 0) == (b\"\\x491\", 7)\n    assert PdfParser.get_value(b\" 123 (\", 0) == (123, 4)\n    assert round(abs(PdfParser.get_value(b\" 123.4 %\", 0)[0] - 123.4), 7) == 0\n    assert PdfParser.get_value(b\" 123.4 %\", 0)[1] == 6\n    with pytest.raises(PdfFormatError):\n        PdfParser.get_value(b\"]\", 0)\n    d = PdfParser.get_value(b\"<</Name (value) /N /V>>\", 0)[0]\n    assert isinstance(d, PdfDict)\n    assert len(d) == 2\n    assert d.Name == \"value\"\n    assert d[b\"Name\"] == b\"value\"\n    assert d.N == PdfName(\"V\")\n    a = PdfParser.get_value(b\"[/Name (value) /N /V]\", 0)[0]\n    assert isinstance(a, list)\n    assert len(a) == 4\n    assert a[0] == PdfName(\"Name\")\n    s = PdfParser.get_value(\n        b\"<</Name (value) /Length 5>>\\nstream\\nabcde\\nendstream<<...\", 0\n    )[0]\n    assert isinstance(s, PdfStream)\n    assert s.dictionary.Name == \"value\"\n    assert s.decode() == b\"abcde\"\n    for name in [\"CreationDate\", \"ModDate\"]:\n        for date, value in {\n            b\"20180729214124\": \"20180729214124\",\n            b\"D:20180729214124\": \"20180729214124\",\n            b\"D:2018072921\": \"20180729210000\",\n            b\"D:20180729214124Z\": \"20180729214124\",\n            b\"D:20180729214124+08'00'\": \"20180729134124\",\n            b\"D:20180729214124-05'00'\": \"20180730024124\",\n        }.items():\n            b = b\"<</\" + name.encode() + b\" (\" + date + b\")>>\"\n            d = PdfParser.get_value(b, 0)[0]\n            assert time.strftime(\"%Y%m%d%H%M%S\", getattr(d, name)) == value\n\n\ndef test_pdf_repr() -> None:\n    assert bytes(IndirectReference(1, 2)) == b\"1 2 R\"\n    assert bytes(IndirectObjectDef(*IndirectReference(1, 2))) == b\"1 2 obj\"\n    assert bytes(PdfName(b\"Name#Hash\")) == b\"/Name#23Hash\"\n    assert bytes(PdfName(\"Name#Hash\")) == b\"/Name#23Hash\"\n    assert bytes(PdfDict({b\"Name\": IndirectReference(1, 2)})) == b\"<<\\n/Name 1 2 R\\n>>\"\n    assert bytes(PdfDict({\"Name\": IndirectReference(1, 2)})) == b\"<<\\n/Name 1 2 R\\n>>\"\n    assert pdf_repr(IndirectReference(1, 2)) == b\"1 2 R\"\n    assert pdf_repr(IndirectObjectDef(*IndirectReference(1, 2))) == b\"1 2 obj\"\n    assert pdf_repr(PdfName(b\"Name#Hash\")) == b\"/Name#23Hash\"\n    assert pdf_repr(PdfName(\"Name#Hash\")) == b\"/Name#23Hash\"\n    assert (\n        pdf_repr(PdfDict({b\"Name\": IndirectReference(1, 2)})) == b\"<<\\n/Name 1 2 R\\n>>\"\n    )\n    assert (\n        pdf_repr(PdfDict({\"Name\": IndirectReference(1, 2)})) == b\"<<\\n/Name 1 2 R\\n>>\"\n    )\n    assert pdf_repr(123) == b\"123\"\n    assert pdf_repr(True) == b\"true\"\n    assert pdf_repr(False) == b\"false\"\n    assert pdf_repr(None) == b\"null\"\n    assert pdf_repr(b\"a)/b\\\\(c\") == rb\"(a\\)/b\\\\\\(c)\"\n    assert pdf_repr([123, True, {\"a\": PdfName(b\"b\")}]) == b\"[ 123 true <<\\n/a /b\\n>> ]\"\n    assert pdf_repr(PdfBinary(b\"\\x90\\x1F\\xA0\")) == b\"<901FA0>\"\n\n\ndef test_duplicate_xref_entry() -> None:\n    pdf = PdfParser(\"Tests/images/duplicate_xref_entry.pdf\")\n    assert pdf.xref_table.existing_entries[6][0] == 1197\n    pdf.close()\n", "Tests/test_file_webp_animated.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nfrom PIL import Image, features\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    is_big_endian,\n    skip_unless_feature,\n)\n\npytestmark = [\n    skip_unless_feature(\"webp\"),\n    skip_unless_feature(\"webp_anim\"),\n]\n\n\ndef test_n_frames() -> None:\n    \"\"\"Ensure that WebP format sets n_frames and is_animated attributes correctly.\"\"\"\n\n    with Image.open(\"Tests/images/hopper.webp\") as im:\n        assert im.n_frames == 1\n        assert not im.is_animated\n\n    with Image.open(\"Tests/images/iss634.webp\") as im:\n        assert im.n_frames == 42\n        assert im.is_animated\n\n\ndef test_write_animation_L(tmp_path: Path) -> None:\n    \"\"\"\n    Convert an animated GIF to animated WebP, then compare the frame count, and first\n    and last frames to ensure they're visually similar.\n    \"\"\"\n\n    with Image.open(\"Tests/images/iss634.gif\") as orig:\n        assert orig.n_frames > 1\n\n        temp_file = str(tmp_path / \"temp.webp\")\n        orig.save(temp_file, save_all=True)\n        with Image.open(temp_file) as im:\n            assert im.n_frames == orig.n_frames\n\n            # Compare first and last frames to the original animated GIF\n            orig.load()\n            im.load()\n            assert_image_similar(im, orig.convert(\"RGBA\"), 32.9)\n\n            if is_big_endian():\n                version = features.version_module(\"webp\")\n                assert version is not None\n                if parse_version(version) < parse_version(\"1.2.2\"):\n                    pytest.skip(\"Fails with libwebp earlier than 1.2.2\")\n            orig.seek(orig.n_frames - 1)\n            im.seek(im.n_frames - 1)\n            orig.load()\n            im.load()\n            assert_image_similar(im, orig.convert(\"RGBA\"), 32.9)\n\n\ndef test_write_animation_RGB(tmp_path: Path) -> None:\n    \"\"\"\n    Write an animated WebP from RGB frames, and ensure the frames\n    are visually similar to the originals.\n    \"\"\"\n\n    def check(temp_file: str) -> None:\n        with Image.open(temp_file) as im:\n            assert im.n_frames == 2\n\n            # Compare first frame to original\n            im.load()\n            assert_image_equal(im, frame1.convert(\"RGBA\"))\n\n            # Compare second frame to original\n            if is_big_endian():\n                version = features.version_module(\"webp\")\n                assert version is not None\n                if parse_version(version) < parse_version(\"1.2.2\"):\n                    pytest.skip(\"Fails with libwebp earlier than 1.2.2\")\n            im.seek(1)\n            im.load()\n            assert_image_equal(im, frame2.convert(\"RGBA\"))\n\n    with Image.open(\"Tests/images/anim_frame1.webp\") as frame1:\n        with Image.open(\"Tests/images/anim_frame2.webp\") as frame2:\n            temp_file1 = str(tmp_path / \"temp.webp\")\n            frame1.copy().save(\n                temp_file1, save_all=True, append_images=[frame2], lossless=True\n            )\n            check(temp_file1)\n\n            # Tests appending using a generator\n            def im_generator(ims):\n                yield from ims\n\n            temp_file2 = str(tmp_path / \"temp_generator.webp\")\n            frame1.copy().save(\n                temp_file2,\n                save_all=True,\n                append_images=im_generator([frame2]),\n                lossless=True,\n            )\n            check(temp_file2)\n\n\ndef test_timestamp_and_duration(tmp_path: Path) -> None:\n    \"\"\"\n    Try passing a list of durations, and make sure the encoded\n    timestamps and durations are correct.\n    \"\"\"\n\n    durations = [0, 10, 20, 30, 40]\n    temp_file = str(tmp_path / \"temp.webp\")\n    with Image.open(\"Tests/images/anim_frame1.webp\") as frame1:\n        with Image.open(\"Tests/images/anim_frame2.webp\") as frame2:\n            frame1.save(\n                temp_file,\n                save_all=True,\n                append_images=[frame2, frame1, frame2, frame1],\n                duration=durations,\n            )\n\n    with Image.open(temp_file) as im:\n        assert im.n_frames == 5\n        assert im.is_animated\n\n        # Check that timestamps and durations match original values specified\n        ts = 0\n        for frame in range(im.n_frames):\n            im.seek(frame)\n            im.load()\n            assert im.info[\"duration\"] == durations[frame]\n            assert im.info[\"timestamp\"] == ts\n            ts += durations[frame]\n\n\ndef test_float_duration(tmp_path: Path) -> None:\n    temp_file = str(tmp_path / \"temp.webp\")\n    with Image.open(\"Tests/images/iss634.apng\") as im:\n        assert im.info[\"duration\"] == 70.0\n\n        im.save(temp_file, save_all=True)\n\n    with Image.open(temp_file) as reloaded:\n        reloaded.load()\n        assert reloaded.info[\"duration\"] == 70\n\n\ndef test_seeking(tmp_path: Path) -> None:\n    \"\"\"\n    Create an animated WebP file, and then try seeking through frames in reverse-order,\n    verifying the timestamps and durations are correct.\n    \"\"\"\n\n    dur = 33\n    temp_file = str(tmp_path / \"temp.webp\")\n    with Image.open(\"Tests/images/anim_frame1.webp\") as frame1:\n        with Image.open(\"Tests/images/anim_frame2.webp\") as frame2:\n            frame1.save(\n                temp_file,\n                save_all=True,\n                append_images=[frame2, frame1, frame2, frame1],\n                duration=dur,\n            )\n\n    with Image.open(temp_file) as im:\n        assert im.n_frames == 5\n        assert im.is_animated\n\n        # Traverse frames in reverse, checking timestamps and durations\n        ts = dur * (im.n_frames - 1)\n        for frame in reversed(range(im.n_frames)):\n            im.seek(frame)\n            im.load()\n            assert im.info[\"duration\"] == dur\n            assert im.info[\"timestamp\"] == ts\n            ts -= dur\n\n\ndef test_seek_errors() -> None:\n    with Image.open(\"Tests/images/iss634.webp\") as im:\n        with pytest.raises(EOFError):\n            im.seek(-1)\n\n        with pytest.raises(EOFError):\n            im.seek(42)\n\n\ndef test_alpha_quality(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/transparent.png\") as im:\n        first_frame = Image.new(\"L\", im.size)\n\n        out = str(tmp_path / \"temp.webp\")\n        first_frame.save(out, save_all=True, append_images=[im])\n\n        out_quality = str(tmp_path / \"quality.webp\")\n        first_frame.save(\n            out_quality, save_all=True, append_images=[im], alpha_quality=50\n        )\n        with Image.open(out) as reloaded:\n            reloaded.seek(1)\n            with Image.open(out_quality) as reloaded_quality:\n                reloaded_quality.seek(1)\n                assert reloaded.tobytes() != reloaded_quality.tobytes()\n", "Tests/test_image_getdata.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    data = hopper().getdata()\n\n    len(data)\n    list(data)\n\n    assert data[0] == (20, 20, 70)\n\n\ndef test_mode() -> None:\n    def getdata(mode: str) -> tuple[float | tuple[int, ...], int, int]:\n        im = hopper(mode).resize((32, 30), Image.Resampling.NEAREST)\n        data = im.getdata()\n        return data[0], len(data), len(list(data))\n\n    assert getdata(\"1\") == (0, 960, 960)\n    assert getdata(\"L\") == (17, 960, 960)\n    assert getdata(\"I\") == (17, 960, 960)\n    assert getdata(\"F\") == (17.0, 960, 960)\n    assert getdata(\"RGB\") == ((11, 13, 52), 960, 960)\n    assert getdata(\"RGBA\") == ((11, 13, 52, 255), 960, 960)\n    assert getdata(\"CMYK\") == ((244, 242, 203, 0), 960, 960)\n    assert getdata(\"YCbCr\") == ((16, 147, 123), 960, 960)\n", "Tests/test_image_getextrema.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\n\ndef test_extrema() -> None:\n    def extrema(mode: str) -> tuple[float, float] | tuple[tuple[int, int], ...]:\n        return hopper(mode).getextrema()\n\n    assert extrema(\"1\") == (0, 255)\n    assert extrema(\"L\") == (1, 255)\n    assert extrema(\"I\") == (1, 255)\n    assert extrema(\"F\") == (1, 255)\n    assert extrema(\"P\") == (0, 225)  # fixed palette\n    assert extrema(\"RGB\") == ((0, 255), (0, 255), (0, 255))\n    assert extrema(\"RGBA\") == ((0, 255), (0, 255), (0, 255), (255, 255))\n    assert extrema(\"CMYK\") == ((0, 255), (0, 255), (0, 255), (0, 0))\n    assert extrema(\"I;16\") == (1, 255)\n\n\ndef test_true_16() -> None:\n    with Image.open(\"Tests/images/16_bit_noise.tif\") as im:\n        assert im.mode == \"I;16\"\n        extrema = im.getextrema()\n    assert extrema == (106, 285)\n", "Tests/bench_cffi_access.py": "from __future__ import annotations\n\nimport time\n\nfrom PIL import PyAccess\n\nfrom .helper import hopper\n\n# Not running this test by default. No DOS against CI.\n\n\ndef iterate_get(size, access) -> None:\n    (w, h) = size\n    for x in range(w):\n        for y in range(h):\n            access[(x, y)]\n\n\ndef iterate_set(size, access) -> None:\n    (w, h) = size\n    for x in range(w):\n        for y in range(h):\n            access[(x, y)] = (x % 256, y % 256, 0)\n\n\ndef timer(func, label, *args) -> None:\n    iterations = 5000\n    starttime = time.time()\n    for x in range(iterations):\n        func(*args)\n        if time.time() - starttime > 10:\n            break\n    endtime = time.time()\n    print(\n        f\"{label}: completed {x + 1} iterations in {endtime - starttime:.4f}s, \"\n        f\"{(endtime - starttime) / (x + 1.0):.6f}s per iteration\"\n    )\n\n\ndef test_direct() -> None:\n    im = hopper()\n    im.load()\n    # im = Image.new(\"RGB\", (2000, 2000), (1, 3, 2))\n    caccess = im.im.pixel_access(False)\n    access = PyAccess.new(im, False)\n\n    assert access is not None\n    assert caccess[(0, 0)] == access[(0, 0)]\n\n    print(f\"Size: {im.width}x{im.height}\")\n    timer(iterate_get, \"PyAccess - get\", im.size, access)\n    timer(iterate_set, \"PyAccess - set\", im.size, access)\n    timer(iterate_get, \"C-api - get\", im.size, caccess)\n    timer(iterate_set, \"C-api - set\", im.size, caccess)\n", "Tests/test_file_palm.py": "from __future__ import annotations\n\nimport os.path\nimport subprocess\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal, hopper, magick_command\n\n\ndef helper_save_as_palm(tmp_path: Path, mode: str) -> None:\n    # Arrange\n    im = hopper(mode)\n    outfile = str(tmp_path / (\"temp_\" + mode + \".palm\"))\n\n    # Act\n    im.save(outfile)\n\n    # Assert\n    assert os.path.isfile(outfile)\n    assert os.path.getsize(outfile) > 0\n\n\ndef open_with_magick(magick: list[str], tmp_path: Path, f: str) -> Image.Image:\n    outfile = str(tmp_path / \"temp.png\")\n    rc = subprocess.call(\n        magick + [f, outfile], stdout=subprocess.DEVNULL, stderr=subprocess.STDOUT\n    )\n    assert not rc\n    return Image.open(outfile)\n\n\ndef roundtrip(tmp_path: Path, mode: str) -> None:\n    magick = magick_command()\n    if not magick:\n        return\n\n    im = hopper(mode)\n    outfile = str(tmp_path / \"temp.palm\")\n\n    im.save(outfile)\n    converted = open_with_magick(magick, tmp_path, outfile)\n    assert_image_equal(converted, im)\n\n\ndef test_monochrome(tmp_path: Path) -> None:\n    # Arrange\n    mode = \"1\"\n\n    # Act / Assert\n    helper_save_as_palm(tmp_path, mode)\n    roundtrip(tmp_path, mode)\n\n\n@pytest.mark.xfail(reason=\"Palm P image is wrong\")\ndef test_p_mode(tmp_path: Path) -> None:\n    # Arrange\n    mode = \"P\"\n\n    # Act / Assert\n    helper_save_as_palm(tmp_path, mode)\n    roundtrip(tmp_path, mode)\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"RGB\"))\ndef test_oserror(tmp_path: Path, mode: str) -> None:\n    with pytest.raises(OSError):\n        helper_save_as_palm(tmp_path, mode)\n", "Tests/test_locale.py": "from __future__ import annotations\n\nimport locale\n\nimport pytest\n\nfrom PIL import Image\n\n# ref https://github.com/python-pillow/Pillow/issues/272\n# on windows, in polish locale:\n\n# import locale\n# print(locale.setlocale(locale.LC_ALL, 'polish'))\n# import string\n# print(len(string.whitespace))\n# print(ord(string.whitespace[6]))\n\n# Polish_Poland.1250\n# 7\n# 160\n\n# one of string.whitespace is not freely convertible into ascii.\n\npath = \"Tests/images/hopper.jpg\"\n\n\ndef test_sanity() -> None:\n    with Image.open(path):\n        pass\n    try:\n        locale.setlocale(locale.LC_ALL, \"polish\")\n    except locale.Error:\n        pytest.skip(\"Polish locale not available\")\n\n    try:\n        with Image.open(path):\n            pass\n    finally:\n        locale.setlocale(locale.LC_ALL, (None, None))\n", "Tests/test_file_iptc.py": "from __future__ import annotations\n\nimport sys\nfrom io import BytesIO, StringIO\n\nimport pytest\n\nfrom PIL import Image, IptcImagePlugin\n\nfrom .helper import assert_image_equal, hopper\n\nTEST_FILE = \"Tests/images/iptc.jpg\"\n\n\ndef test_open() -> None:\n    expected = Image.new(\"L\", (1, 1))\n\n    f = BytesIO(\n        b\"\\x1c\\x03<\\x00\\x02\\x01\\x00\\x1c\\x03x\\x00\\x01\\x01\\x1c\\x03\\x14\\x00\\x01\\x01\"\n        b\"\\x1c\\x03\\x1e\\x00\\x01\\x01\\x1c\\x08\\n\\x00\\x01\\x00\"\n    )\n    with Image.open(f) as im:\n        assert im.tile == [(\"iptc\", (0, 0, 1, 1), 25, \"raw\")]\n        assert_image_equal(im, expected)\n\n\ndef test_getiptcinfo_jpg_none() -> None:\n    # Arrange\n    with hopper() as im:\n        # Act\n        iptc = IptcImagePlugin.getiptcinfo(im)\n\n    # Assert\n    assert iptc is None\n\n\ndef test_getiptcinfo_jpg_found() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        # Act\n        iptc = IptcImagePlugin.getiptcinfo(im)\n\n    # Assert\n    assert isinstance(iptc, dict)\n    assert iptc[(2, 90)] == b\"Budapest\"\n    assert iptc[(2, 101)] == b\"Hungary\"\n\n\ndef test_getiptcinfo_fotostation() -> None:\n    # Arrange\n    with open(TEST_FILE, \"rb\") as fp:\n        data = bytearray(fp.read())\n    data[86] = 240\n    f = BytesIO(data)\n    with Image.open(f) as im:\n        # Act\n        iptc = IptcImagePlugin.getiptcinfo(im)\n\n    # Assert\n    for tag in iptc.keys():\n        if tag[0] == 240:\n            return\n    pytest.fail(\"FotoStation tag not found\")\n\n\ndef test_getiptcinfo_zero_padding() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        im.info[\"photoshop\"][0x0404] += b\"\\x00\\x00\\x00\"\n\n        # Act\n        iptc = IptcImagePlugin.getiptcinfo(im)\n\n    # Assert\n    assert isinstance(iptc, dict)\n    assert len(iptc) == 3\n\n\ndef test_getiptcinfo_tiff_none() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/hopper.tif\") as im:\n        # Act\n        iptc = IptcImagePlugin.getiptcinfo(im)\n\n    # Assert\n    assert iptc is None\n\n\ndef test_i() -> None:\n    # Arrange\n    c = b\"a\"\n\n    # Act\n    with pytest.warns(DeprecationWarning):\n        ret = IptcImagePlugin.i(c)\n\n    # Assert\n    assert ret == 97\n\n\ndef test_dump(monkeypatch: pytest.MonkeyPatch) -> None:\n    # Arrange\n    c = b\"abc\"\n    # Temporarily redirect stdout\n    mystdout = StringIO()\n    monkeypatch.setattr(sys, \"stdout\", mystdout)\n\n    # Act\n    with pytest.warns(DeprecationWarning):\n        IptcImagePlugin.dump(c)\n\n    # Assert\n    assert mystdout.getvalue() == \"61 62 63 \\n\"\n\n\ndef test_pad_deprecation() -> None:\n    with pytest.warns(DeprecationWarning):\n        assert IptcImagePlugin.PAD == b\"\\0\\0\\0\\0\"\n", "Tests/test_tiff_crashes.py": "# Reproductions/tests for crashes/read errors in TiffDecode.c\n\n# When run in Python, all of these images should fail for\n# one reason or another, either as a buffer overrun,\n# unrecognized datastream, or truncated image file.\n# There shouldn't be any segfaults.\n#\n# if run like\n# `valgrind --tool=memcheck pytest test_tiff_crashes.py 2>&1 | grep TiffDecode.c`\n# the output should be empty. There may be Python issues\n# in the valgrind especially if run in a debug Python\n# version.\nfrom __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import on_ci\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\n        \"Tests/images/crash_1.tif\",\n        \"Tests/images/crash_2.tif\",\n        \"Tests/images/crash-2020-10-test.tif\",\n        \"Tests/images/crash-0c7e0e8e11ce787078f00b5b0ca409a167f070e0.tif\",\n        \"Tests/images/crash-0e16d3bfb83be87356d026d66919deaefca44dac.tif\",\n        \"Tests/images/crash-1152ec2d1a1a71395b6f2ce6721c38924d025bf3.tif\",\n        \"Tests/images/crash-1185209cf7655b5aed8ae5e77784dfdd18ab59e9.tif\",\n        \"Tests/images/crash-338516dbd2f0e83caddb8ce256c22db3bd6dc40f.tif\",\n        \"Tests/images/crash-4f085cc12ece8cde18758d42608bed6a2a2cfb1c.tif\",\n        \"Tests/images/crash-86214e58da443d2b80820cff9677a38a33dcbbca.tif\",\n        \"Tests/images/crash-f46f5b2f43c370fe65706c11449f567ecc345e74.tif\",\n        \"Tests/images/crash-63b1dffefc8c075ddc606c0a2f5fdc15ece78863.tif\",\n        \"Tests/images/crash-74d2a78403a5a59db1fb0a2b8735ac068a75f6e3.tif\",\n        \"Tests/images/crash-81154a65438ba5aaeca73fd502fa4850fbde60f8.tif\",\n        \"Tests/images/crash-0da013a13571cc8eb457a39fee8db18f8a3c7127.tif\",\n    ],\n)\n@pytest.mark.filterwarnings(\"ignore:Possibly corrupt EXIF data\")\n@pytest.mark.filterwarnings(\"ignore:Metadata warning\")\n@pytest.mark.filterwarnings(\"ignore:Truncated File Read\")\ndef test_tiff_crashes(test_file: str) -> None:\n    try:\n        with Image.open(test_file) as im:\n            im.load()\n    except FileNotFoundError:\n        if on_ci():\n            raise\n        pytest.skip(\"test image not found\")\n    except OSError:\n        pass\n", "Tests/test_file_webp_metadata.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import mark_if_feature_version, skip_unless_feature\n\npytestmark = [\n    skip_unless_feature(\"webp\"),\n    skip_unless_feature(\"webp_mux\"),\n]\n\nElementTree: ModuleType | None\ntry:\n    from defusedxml import ElementTree\nexcept ImportError:\n    ElementTree = None\n\n\ndef test_read_exif_metadata() -> None:\n    file_path = \"Tests/images/flower.webp\"\n    with Image.open(file_path) as image:\n        assert image.format == \"WEBP\"\n        exif_data = image.info.get(\"exif\", None)\n        assert exif_data\n\n        exif = image._getexif()\n\n        # Camera make\n        assert exif[271] == \"Canon\"\n\n        with Image.open(\"Tests/images/flower.jpg\") as jpeg_image:\n            expected_exif = jpeg_image.info[\"exif\"]\n\n            assert exif_data == expected_exif\n\n\ndef test_read_exif_metadata_without_prefix() -> None:\n    with Image.open(\"Tests/images/flower2.webp\") as im:\n        # Assert prefix is not present\n        assert im.info[\"exif\"][:6] != b\"Exif\\x00\\x00\"\n\n        exif = im.getexif()\n        assert exif[305] == \"Adobe Photoshop CS6 (Macintosh)\"\n\n\n@mark_if_feature_version(\n    pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n)\ndef test_write_exif_metadata() -> None:\n    file_path = \"Tests/images/flower.jpg\"\n    test_buffer = BytesIO()\n    with Image.open(file_path) as image:\n        expected_exif = image.info[\"exif\"]\n\n        image.save(test_buffer, \"webp\", exif=expected_exif)\n\n    test_buffer.seek(0)\n    with Image.open(test_buffer) as webp_image:\n        webp_exif = webp_image.info.get(\"exif\", None)\n    assert webp_exif == expected_exif[6:], \"WebP EXIF didn't match\"\n\n\ndef test_read_icc_profile() -> None:\n    file_path = \"Tests/images/flower2.webp\"\n    with Image.open(file_path) as image:\n        assert image.format == \"WEBP\"\n        assert image.info.get(\"icc_profile\", None)\n\n        icc = image.info[\"icc_profile\"]\n\n        with Image.open(\"Tests/images/flower2.jpg\") as jpeg_image:\n            expected_icc = jpeg_image.info[\"icc_profile\"]\n\n            assert icc == expected_icc\n\n\n@mark_if_feature_version(\n    pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n)\ndef test_write_icc_metadata() -> None:\n    file_path = \"Tests/images/flower2.jpg\"\n    test_buffer = BytesIO()\n    with Image.open(file_path) as image:\n        expected_icc_profile = image.info[\"icc_profile\"]\n\n        image.save(test_buffer, \"webp\", icc_profile=expected_icc_profile)\n\n    test_buffer.seek(0)\n    with Image.open(test_buffer) as webp_image:\n        webp_icc_profile = webp_image.info.get(\"icc_profile\", None)\n\n    assert webp_icc_profile\n    if webp_icc_profile:\n        assert webp_icc_profile == expected_icc_profile, \"Webp ICC didn't match\"\n\n\n@mark_if_feature_version(\n    pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n)\ndef test_read_no_exif() -> None:\n    file_path = \"Tests/images/flower.jpg\"\n    test_buffer = BytesIO()\n    with Image.open(file_path) as image:\n        assert \"exif\" in image.info\n\n        image.save(test_buffer, \"webp\")\n\n    test_buffer.seek(0)\n    with Image.open(test_buffer) as webp_image:\n        assert not webp_image._getexif()\n\n\ndef test_getxmp() -> None:\n    with Image.open(\"Tests/images/flower.webp\") as im:\n        assert \"xmp\" not in im.info\n        assert im.getxmp() == {}\n\n    with Image.open(\"Tests/images/flower2.webp\") as im:\n        if ElementTree is None:\n            with pytest.warns(\n                UserWarning,\n                match=\"XMP data cannot be read without defusedxml dependency\",\n            ):\n                assert im.getxmp() == {}\n        else:\n            assert \"xmp\" in im.info\n            assert (\n                im.getxmp()[\"xmpmeta\"][\"xmptk\"]\n                == \"Adobe XMP Core 5.3-c011 66.145661, 2012/02/06-14:56:27        \"\n            )\n\n\n@skip_unless_feature(\"webp_anim\")\ndef test_write_animated_metadata(tmp_path: Path) -> None:\n    iccp_data = b\"<iccp_data>\"\n    exif_data = b\"<exif_data>\"\n    xmp_data = b\"<xmp_data>\"\n\n    temp_file = str(tmp_path / \"temp.webp\")\n    with Image.open(\"Tests/images/anim_frame1.webp\") as frame1:\n        with Image.open(\"Tests/images/anim_frame2.webp\") as frame2:\n            frame1.save(\n                temp_file,\n                save_all=True,\n                append_images=[frame2, frame1, frame2],\n                icc_profile=iccp_data,\n                exif=exif_data,\n                xmp=xmp_data,\n            )\n\n    with Image.open(temp_file) as image:\n        assert \"icc_profile\" in image.info\n        assert \"exif\" in image.info\n        assert \"xmp\" in image.info\n        assert iccp_data == image.info.get(\"icc_profile\", None)\n        assert exif_data == image.info.get(\"exif\", None)\n        assert xmp_data == image.info.get(\"xmp\", None)\n", "Tests/test_file_pcd.py": "from __future__ import annotations\n\nfrom PIL import Image\n\n\ndef test_load_raw() -> None:\n    with Image.open(\"Tests/images/hopper.pcd\") as im:\n        im.load()  # should not segfault.\n\n    # Note that this image was created with a resized hopper\n    # image, which was then converted to pcd with imagemagick\n    # and the colors are wonky in Pillow.  It's unclear if this\n    # is a pillow or a convert issue, as other images not generated\n    # from convert look find on pillow and not imagemagick.\n\n    # target = hopper().resize((768,512))\n    # assert_image_similar(im, target, 10)\n", "Tests/test_util.py": "from __future__ import annotations\n\nfrom pathlib import Path, PurePath\n\nimport pytest\n\nfrom PIL import _util\n\n\n@pytest.mark.parametrize(\n    \"test_path\", [\"filename.ext\", Path(\"filename.ext\"), PurePath(\"filename.ext\")]\n)\ndef test_is_path(test_path: str | Path | PurePath) -> None:\n    # Act\n    it_is = _util.is_path(test_path)\n\n    # Assert\n    assert it_is\n\n\ndef test_is_not_path(tmp_path: Path) -> None:\n    # Arrange\n    with (tmp_path / \"temp.ext\").open(\"w\") as fp:\n        pass\n\n    # Act\n    it_is_not = _util.is_path(fp)\n\n    # Assert\n    assert not it_is_not\n\n\ndef test_is_directory() -> None:\n    # Arrange\n    directory = \"Tests\"\n\n    # Act\n    it_is = _util.is_directory(directory)\n\n    # Assert\n    assert it_is\n\n\ndef test_is_not_directory() -> None:\n    # Arrange\n    text = \"abc\"\n\n    # Act\n    it_is_not = _util.is_directory(text)\n\n    # Assert\n    assert not it_is_not\n\n\ndef test_deferred_error() -> None:\n    # Arrange\n\n    # Act\n    thing = _util.DeferredError.new(ValueError(\"Some error text\"))\n\n    # Assert\n    with pytest.raises(ValueError):\n        thing.some_attr\n", "Tests/test_bmp_reference.py": "from __future__ import annotations\n\nimport os\nimport warnings\n\nfrom PIL import Image\n\nfrom .helper import assert_image_similar\n\nbase = os.path.join(\"Tests\", \"images\", \"bmp\")\n\n\ndef get_files(d: str, ext: str = \".bmp\") -> list[str]:\n    return [\n        os.path.join(base, d, f) for f in os.listdir(os.path.join(base, d)) if ext in f\n    ]\n\n\ndef test_bad() -> None:\n    \"\"\"These shouldn't crash/dos, but they shouldn't return anything\n    either\"\"\"\n    for f in get_files(\"b\"):\n        # Assert that there is no unclosed file warning\n        with warnings.catch_warnings():\n            try:\n                with Image.open(f) as im:\n                    im.load()\n            except Exception:  # as msg:\n                pass\n\n\ndef test_questionable() -> None:\n    \"\"\"These shouldn't crash/dos, but it's not well defined that these\n    are in spec\"\"\"\n    supported = [\n        \"pal8os2v2.bmp\",\n        \"rgb24prof.bmp\",\n        \"pal1p1.bmp\",\n        \"pal4rletrns.bmp\",\n        \"pal8offs.bmp\",\n        \"rgb24lprof.bmp\",\n        \"rgb32fakealpha.bmp\",\n        \"rgb24largepal.bmp\",\n        \"pal8os2sp.bmp\",\n        \"pal8rletrns.bmp\",\n        \"rgb32bf-xbgr.bmp\",\n        \"rgba32.bmp\",\n        \"rgb32h52.bmp\",\n        \"rgba32h56.bmp\",\n    ]\n    for f in get_files(\"q\"):\n        try:\n            with Image.open(f) as im:\n                im.load()\n            if os.path.basename(f) not in supported:\n                print(f\"Please add {f} to the partially supported bmp specs.\")\n        except Exception:  # as msg:\n            if os.path.basename(f) in supported:\n                raise\n\n\ndef test_good() -> None:\n    \"\"\"These should all work. There's a set of target files in the\n    html directory that we can compare against.\"\"\"\n\n    # Target files, if they're not just replacing the extension\n    file_map = {\n        \"pal1wb.bmp\": \"pal1.png\",\n        \"pal4rle.bmp\": \"pal4.png\",\n        \"pal8-0.bmp\": \"pal8.png\",\n        \"pal8rle.bmp\": \"pal8.png\",\n        \"pal8topdown.bmp\": \"pal8.png\",\n        \"pal8nonsquare.bmp\": \"pal8nonsquare-v.png\",\n        \"pal8os2.bmp\": \"pal8.png\",\n        \"pal8os2sp.bmp\": \"pal8.png\",\n        \"pal8os2v2.bmp\": \"pal8.png\",\n        \"pal8os2v2-16.bmp\": \"pal8.png\",\n        \"pal8v4.bmp\": \"pal8.png\",\n        \"pal8v5.bmp\": \"pal8.png\",\n        \"rgb16-565pal.bmp\": \"rgb16-565.png\",\n        \"rgb24pal.bmp\": \"rgb24.png\",\n        \"rgb32.bmp\": \"rgb24.png\",\n        \"rgb32bf.bmp\": \"rgb24.png\",\n    }\n\n    def get_compare(f: str) -> str:\n        name = os.path.split(f)[1]\n        if name in file_map:\n            return os.path.join(base, \"html\", file_map[name])\n        name = os.path.splitext(name)[0]\n        return os.path.join(base, \"html\", f\"{name}.png\")\n\n    for f in get_files(\"g\"):\n        try:\n            with Image.open(f) as im:\n                im.load()\n                with Image.open(get_compare(f)) as compare:\n                    compare.load()\n                    if im.mode == \"P\":\n                        # assert image similar doesn't really work\n                        # with paletized image, since the palette might\n                        # be differently ordered for an equivalent image.\n                        im = im.convert(\"RGBA\")\n                        compare = im.convert(\"RGBA\")\n                    assert_image_similar(im, compare, 5)\n\n        except Exception as msg:\n            # there are three here that are unsupported:\n            unsupported = (\n                os.path.join(base, \"g\", \"rgb32bf.bmp\"),\n                os.path.join(base, \"g\", \"pal8rle.bmp\"),\n                os.path.join(base, \"g\", \"pal4rle.bmp\"),\n            )\n            assert f in unsupported, f\"Unsupported Image {f}: {msg}\"\n", "Tests/test_file_sgi.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, SgiImagePlugin\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    hopper,\n)\n\n\ndef test_rgb() -> None:\n    # Created with ImageMagick then renamed:\n    # convert hopper.ppm -compress None sgi:hopper.rgb\n    test_file = \"Tests/images/hopper.rgb\"\n\n    with Image.open(test_file) as im:\n        assert_image_equal(im, hopper())\n        assert im.get_format_mimetype() == \"image/rgb\"\n\n\ndef test_rgb16() -> None:\n    assert_image_equal_tofile(hopper(), \"Tests/images/hopper16.rgb\")\n\n\ndef test_l() -> None:\n    # Created with ImageMagick\n    # convert hopper.ppm -monochrome -compress None sgi:hopper.bw\n    test_file = \"Tests/images/hopper.bw\"\n\n    with Image.open(test_file) as im:\n        assert_image_similar(im, hopper(\"L\"), 2)\n        assert im.get_format_mimetype() == \"image/sgi\"\n\n\ndef test_rgba() -> None:\n    # Created with ImageMagick:\n    # convert transparent.png -compress None transparent.sgi\n    test_file = \"Tests/images/transparent.sgi\"\n\n    with Image.open(test_file) as im:\n        assert_image_equal_tofile(im, \"Tests/images/transparent.png\")\n        assert im.get_format_mimetype() == \"image/sgi\"\n\n\ndef test_rle() -> None:\n    # Created with ImageMagick:\n    # convert hopper.ppm  hopper.sgi\n    test_file = \"Tests/images/hopper.sgi\"\n\n    with Image.open(test_file) as im:\n        assert_image_equal_tofile(im, \"Tests/images/hopper.rgb\")\n\n\ndef test_rle16() -> None:\n    test_file = \"Tests/images/tv16.sgi\"\n\n    with Image.open(test_file) as im:\n        assert_image_equal_tofile(im, \"Tests/images/tv.rgb\")\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(ValueError):\n        SgiImagePlugin.SgiImageFile(invalid_file)\n\n\ndef test_write(tmp_path: Path) -> None:\n    def roundtrip(img: Image.Image) -> None:\n        out = str(tmp_path / \"temp.sgi\")\n        img.save(out, format=\"sgi\")\n        assert_image_equal_tofile(img, out)\n\n        out = str(tmp_path / \"fp.sgi\")\n        with open(out, \"wb\") as fp:\n            img.save(fp)\n            assert_image_equal_tofile(img, out)\n\n            assert not fp.closed\n\n    for mode in (\"L\", \"RGB\", \"RGBA\"):\n        roundtrip(hopper(mode))\n\n    # Test 1 dimension for an L mode image\n    roundtrip(Image.new(\"L\", (10, 1)))\n\n\ndef test_write16(tmp_path: Path) -> None:\n    test_file = \"Tests/images/hopper16.rgb\"\n\n    with Image.open(test_file) as im:\n        out = str(tmp_path / \"temp.sgi\")\n        im.save(out, format=\"sgi\", bpc=2)\n\n        assert_image_equal_tofile(im, out)\n\n\ndef test_unsupported_mode(tmp_path: Path) -> None:\n    im = hopper(\"LA\")\n    out = str(tmp_path / \"temp.sgi\")\n\n    with pytest.raises(ValueError):\n        im.save(out, format=\"sgi\")\n", "Tests/test_map.py": "from __future__ import annotations\n\nimport sys\n\nimport pytest\n\nfrom PIL import Image\n\n\ndef test_overflow() -> None:\n    # There is the potential to overflow comparisons in map.c\n    # if there are > SIZE_MAX bytes in the image or if\n    # the file encodes an offset that makes\n    # (offset + size(bytes)) > SIZE_MAX\n\n    # Note that this image triggers the decompression bomb warning:\n    max_pixels = Image.MAX_IMAGE_PIXELS\n    Image.MAX_IMAGE_PIXELS = None\n\n    # This image hits the offset test.\n    with Image.open(\"Tests/images/l2rgb_read.bmp\") as im:\n        with pytest.raises((ValueError, MemoryError, OSError)):\n            im.load()\n\n    Image.MAX_IMAGE_PIXELS = max_pixels\n\n\ndef test_tobytes() -> None:\n    # Note that this image triggers the decompression bomb warning:\n    max_pixels = Image.MAX_IMAGE_PIXELS\n    Image.MAX_IMAGE_PIXELS = None\n\n    # Previously raised an access violation on Windows\n    with Image.open(\"Tests/images/l2rgb_read.bmp\") as im:\n        with pytest.raises((ValueError, MemoryError, OSError)):\n            im.tobytes()\n\n    Image.MAX_IMAGE_PIXELS = max_pixels\n\n\n@pytest.mark.skipif(sys.maxsize <= 2**32, reason=\"Requires 64-bit system\")\ndef test_ysize() -> None:\n    numpy = pytest.importorskip(\"numpy\", reason=\"NumPy not installed\")\n\n    # Should not raise 'Integer overflow in ysize'\n    arr = numpy.zeros((46341, 46341), dtype=numpy.uint8)\n    Image.fromarray(arr)\n", "Tests/test_file_png.py": "from __future__ import annotations\n\nimport re\nimport sys\nimport warnings\nimport zlib\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import Any, cast\n\nimport pytest\n\nfrom PIL import Image, ImageFile, PngImagePlugin, features\n\nfrom .helper import (\n    PillowLeakTestCase,\n    assert_image,\n    assert_image_equal,\n    assert_image_equal_tofile,\n    hopper,\n    is_win32,\n    mark_if_feature_version,\n    skip_unless_feature,\n)\n\nElementTree: ModuleType | None\ntry:\n    from defusedxml import ElementTree\nexcept ImportError:\n    ElementTree = None\n\n# sample png stream\n\nTEST_PNG_FILE = \"Tests/images/hopper.png\"\n\n# stuff to create inline PNG images\n\nMAGIC = PngImagePlugin._MAGIC\n\n\ndef chunk(cid: bytes, *data: bytes) -> bytes:\n    test_file = BytesIO()\n    PngImagePlugin.putchunk(*(test_file, cid) + data)\n    return test_file.getvalue()\n\n\no32 = PngImagePlugin.o32\n\nIHDR = chunk(b\"IHDR\", o32(1), o32(1), b\"\\x08\\x02\", b\"\\0\\0\\0\")\nIDAT = chunk(b\"IDAT\")\nIEND = chunk(b\"IEND\")\n\nHEAD = MAGIC + IHDR\nTAIL = IDAT + IEND\n\n\ndef load(data: bytes) -> Image.Image:\n    return Image.open(BytesIO(data))\n\n\ndef roundtrip(im: Image.Image, **options: Any) -> PngImagePlugin.PngImageFile:\n    out = BytesIO()\n    im.save(out, \"PNG\", **options)\n    out.seek(0)\n    return cast(PngImagePlugin.PngImageFile, Image.open(out))\n\n\n@skip_unless_feature(\"zlib\")\nclass TestFilePng:\n    def get_chunks(self, filename: str) -> list[bytes]:\n        chunks = []\n        with open(filename, \"rb\") as fp:\n            fp.read(8)\n            with PngImagePlugin.PngStream(fp) as png:\n                while True:\n                    cid, pos, length = png.read()\n                    chunks.append(cid)\n                    try:\n                        s = png.call(cid, pos, length)\n                    except EOFError:\n                        break\n                    png.crc(cid, s)\n        return chunks\n\n    def test_sanity(self, tmp_path: Path) -> None:\n        # internal version number\n        version = features.version_codec(\"zlib\")\n        assert version is not None\n        assert re.search(r\"\\d+(\\.\\d+){1,3}(\\.zlib\\-ng)?$\", version)\n\n        test_file = str(tmp_path / \"temp.png\")\n\n        hopper(\"RGB\").save(test_file)\n\n        with Image.open(test_file) as im:\n            im.load()\n            assert im.mode == \"RGB\"\n            assert im.size == (128, 128)\n            assert im.format == \"PNG\"\n            assert im.get_format_mimetype() == \"image/png\"\n\n        for mode in [\"1\", \"L\", \"P\", \"RGB\", \"I\", \"I;16\", \"I;16B\"]:\n            im = hopper(mode)\n            im.save(test_file)\n            with Image.open(test_file) as reloaded:\n                if mode in (\"I\", \"I;16B\"):\n                    reloaded = reloaded.convert(mode)\n                assert_image_equal(reloaded, im)\n\n    def test_invalid_file(self) -> None:\n        invalid_file = \"Tests/images/flower.jpg\"\n\n        with pytest.raises(SyntaxError):\n            PngImagePlugin.PngImageFile(invalid_file)\n\n    def test_broken(self) -> None:\n        # Check reading of totally broken files.  In this case, the test\n        # file was checked into Subversion as a text file.\n\n        test_file = \"Tests/images/broken.png\"\n        with pytest.raises(OSError):\n            with Image.open(test_file):\n                pass\n\n    def test_bad_text(self) -> None:\n        # Make sure PIL can read malformed tEXt chunks (@PIL152)\n\n        im = load(HEAD + chunk(b\"tEXt\") + TAIL)\n        assert im.info == {}\n\n        im = load(HEAD + chunk(b\"tEXt\", b\"spam\") + TAIL)\n        assert im.info == {\"spam\": \"\"}\n\n        im = load(HEAD + chunk(b\"tEXt\", b\"spam\\0\") + TAIL)\n        assert im.info == {\"spam\": \"\"}\n\n        im = load(HEAD + chunk(b\"tEXt\", b\"spam\\0egg\") + TAIL)\n        assert im.info == {\"spam\": \"egg\"}\n\n        im = load(HEAD + chunk(b\"tEXt\", b\"spam\\0egg\\0\") + TAIL)\n        assert im.info == {\"spam\": \"egg\\x00\"}\n\n    def test_bad_ztxt(self) -> None:\n        # Test reading malformed zTXt chunks (python-pillow/Pillow#318)\n\n        im = load(HEAD + chunk(b\"zTXt\") + TAIL)\n        assert im.info == {}\n\n        im = load(HEAD + chunk(b\"zTXt\", b\"spam\") + TAIL)\n        assert im.info == {\"spam\": \"\"}\n\n        im = load(HEAD + chunk(b\"zTXt\", b\"spam\\0\") + TAIL)\n        assert im.info == {\"spam\": \"\"}\n\n        im = load(HEAD + chunk(b\"zTXt\", b\"spam\\0\\0\") + TAIL)\n        assert im.info == {\"spam\": \"\"}\n\n        im = load(HEAD + chunk(b\"zTXt\", b\"spam\\0\\0\" + zlib.compress(b\"egg\")[:1]) + TAIL)\n        assert im.info == {\"spam\": \"\"}\n\n        im = load(HEAD + chunk(b\"zTXt\", b\"spam\\0\\0\" + zlib.compress(b\"egg\")) + TAIL)\n        assert im.info == {\"spam\": \"egg\"}\n\n    def test_bad_itxt(self) -> None:\n        im = load(HEAD + chunk(b\"iTXt\") + TAIL)\n        assert im.info == {}\n\n        im = load(HEAD + chunk(b\"iTXt\", b\"spam\") + TAIL)\n        assert im.info == {}\n\n        im = load(HEAD + chunk(b\"iTXt\", b\"spam\\0\") + TAIL)\n        assert im.info == {}\n\n        im = load(HEAD + chunk(b\"iTXt\", b\"spam\\0\\x02\") + TAIL)\n        assert im.info == {}\n\n        im = load(HEAD + chunk(b\"iTXt\", b\"spam\\0\\0\\0foo\\0\") + TAIL)\n        assert im.info == {}\n\n        im = load(HEAD + chunk(b\"iTXt\", b\"spam\\0\\0\\0en\\0Spam\\0egg\") + TAIL)\n        assert im.info == {\"spam\": \"egg\"}\n        assert im.info[\"spam\"].lang == \"en\"\n        assert im.info[\"spam\"].tkey == \"Spam\"\n\n        im = load(\n            HEAD\n            + chunk(b\"iTXt\", b\"spam\\0\\1\\0en\\0Spam\\0\" + zlib.compress(b\"egg\")[:1])\n            + TAIL\n        )\n        assert im.info == {\"spam\": \"\"}\n\n        im = load(\n            HEAD\n            + chunk(b\"iTXt\", b\"spam\\0\\1\\1en\\0Spam\\0\" + zlib.compress(b\"egg\"))\n            + TAIL\n        )\n        assert im.info == {}\n\n        im = load(\n            HEAD\n            + chunk(b\"iTXt\", b\"spam\\0\\1\\0en\\0Spam\\0\" + zlib.compress(b\"egg\"))\n            + TAIL\n        )\n        assert im.info == {\"spam\": \"egg\"}\n        assert im.info[\"spam\"].lang == \"en\"\n        assert im.info[\"spam\"].tkey == \"Spam\"\n\n    def test_interlace(self) -> None:\n        test_file = \"Tests/images/pil123p.png\"\n        with Image.open(test_file) as im:\n            assert_image(im, \"P\", (162, 150))\n            assert im.info.get(\"interlace\")\n\n            im.load()\n\n        test_file = \"Tests/images/pil123rgba.png\"\n        with Image.open(test_file) as im:\n            assert_image(im, \"RGBA\", (162, 150))\n            assert im.info.get(\"interlace\")\n\n            im.load()\n\n    def test_load_transparent_p(self) -> None:\n        test_file = \"Tests/images/pil123p.png\"\n        with Image.open(test_file) as im:\n            assert_image(im, \"P\", (162, 150))\n            im = im.convert(\"RGBA\")\n        assert_image(im, \"RGBA\", (162, 150))\n\n        # image has 124 unique alpha values\n        assert len(im.getchannel(\"A\").getcolors()) == 124\n\n    def test_load_transparent_rgb(self) -> None:\n        test_file = \"Tests/images/rgb_trns.png\"\n        with Image.open(test_file) as im:\n            assert im.info[\"transparency\"] == (0, 255, 52)\n\n            assert_image(im, \"RGB\", (64, 64))\n            im = im.convert(\"RGBA\")\n        assert_image(im, \"RGBA\", (64, 64))\n\n        # image has 876 transparent pixels\n        assert im.getchannel(\"A\").getcolors()[0][0] == 876\n\n    def test_save_p_transparent_palette(self, tmp_path: Path) -> None:\n        in_file = \"Tests/images/pil123p.png\"\n        with Image.open(in_file) as im:\n            # 'transparency' contains a byte string with the opacity for\n            # each palette entry\n            assert len(im.info[\"transparency\"]) == 256\n\n            test_file = str(tmp_path / \"temp.png\")\n            im.save(test_file)\n\n        # check if saved image contains same transparency\n        with Image.open(test_file) as im:\n            assert len(im.info[\"transparency\"]) == 256\n\n            assert_image(im, \"P\", (162, 150))\n            im = im.convert(\"RGBA\")\n        assert_image(im, \"RGBA\", (162, 150))\n\n        # image has 124 unique alpha values\n        assert len(im.getchannel(\"A\").getcolors()) == 124\n\n    def test_save_p_single_transparency(self, tmp_path: Path) -> None:\n        in_file = \"Tests/images/p_trns_single.png\"\n        with Image.open(in_file) as im:\n            # pixel value 164 is full transparent\n            assert im.info[\"transparency\"] == 164\n            assert im.getpixel((31, 31)) == 164\n\n            test_file = str(tmp_path / \"temp.png\")\n            im.save(test_file)\n\n        # check if saved image contains same transparency\n        with Image.open(test_file) as im:\n            assert im.info[\"transparency\"] == 164\n            assert im.getpixel((31, 31)) == 164\n            assert_image(im, \"P\", (64, 64))\n            im = im.convert(\"RGBA\")\n        assert_image(im, \"RGBA\", (64, 64))\n\n        assert im.getpixel((31, 31)) == (0, 255, 52, 0)\n\n        # image has 876 transparent pixels\n        assert im.getchannel(\"A\").getcolors()[0][0] == 876\n\n    def test_save_p_transparent_black(self, tmp_path: Path) -> None:\n        # check if solid black image with full transparency\n        # is supported (check for #1838)\n        im = Image.new(\"RGBA\", (10, 10), (0, 0, 0, 0))\n        assert im.getcolors() == [(100, (0, 0, 0, 0))]\n\n        im = im.convert(\"P\")\n        test_file = str(tmp_path / \"temp.png\")\n        im.save(test_file)\n\n        # check if saved image contains same transparency\n        with Image.open(test_file) as im:\n            assert len(im.info[\"transparency\"]) == 256\n            assert_image(im, \"P\", (10, 10))\n            im = im.convert(\"RGBA\")\n        assert_image(im, \"RGBA\", (10, 10))\n        assert im.getcolors() == [(100, (0, 0, 0, 0))]\n\n    def test_save_grayscale_transparency(self, tmp_path: Path) -> None:\n        for mode, num_transparent in {\"1\": 1994, \"L\": 559, \"I;16\": 559}.items():\n            in_file = \"Tests/images/\" + mode.split(\";\")[0].lower() + \"_trns.png\"\n            with Image.open(in_file) as im:\n                assert im.mode == mode\n                assert im.info[\"transparency\"] == 255\n\n                im_rgba = im.convert(\"RGBA\")\n            assert im_rgba.getchannel(\"A\").getcolors()[0][0] == num_transparent\n\n            test_file = str(tmp_path / \"temp.png\")\n            im.save(test_file)\n\n            with Image.open(test_file) as test_im:\n                assert test_im.mode == mode\n                assert test_im.info[\"transparency\"] == 255\n                assert_image_equal(im, test_im)\n\n            test_im_rgba = test_im.convert(\"RGBA\")\n            assert test_im_rgba.getchannel(\"A\").getcolors()[0][0] == num_transparent\n\n    def test_save_rgb_single_transparency(self, tmp_path: Path) -> None:\n        in_file = \"Tests/images/caption_6_33_22.png\"\n        with Image.open(in_file) as im:\n            test_file = str(tmp_path / \"temp.png\")\n            im.save(test_file)\n\n    def test_load_verify(self) -> None:\n        # Check open/load/verify exception (@PIL150)\n\n        with Image.open(TEST_PNG_FILE) as im:\n            # Assert that there is no unclosed file warning\n            with warnings.catch_warnings():\n                im.verify()\n\n        with Image.open(TEST_PNG_FILE) as im:\n            im.load()\n            with pytest.raises(RuntimeError):\n                im.verify()\n\n    def test_verify_struct_error(self) -> None:\n        # Check open/load/verify exception (#1755)\n\n        # offsets to test, -10: breaks in i32() in read. (OSError)\n        #                  -13: breaks in crc, txt chunk.\n        #                  -14: malformed chunk\n\n        for offset in (-10, -13, -14):\n            with open(TEST_PNG_FILE, \"rb\") as f:\n                test_file = f.read()[:offset]\n\n            with Image.open(BytesIO(test_file)) as im:\n                assert im.fp is not None\n                with pytest.raises((OSError, SyntaxError)):\n                    im.verify()\n\n    def test_verify_ignores_crc_error(self) -> None:\n        # check ignores crc errors in ancillary chunks\n\n        chunk_data = chunk(b\"tEXt\", b\"spam\")\n        broken_crc_chunk_data = chunk_data[:-1] + b\"q\"  # break CRC\n\n        image_data = HEAD + broken_crc_chunk_data + TAIL\n        with pytest.raises(SyntaxError):\n            PngImagePlugin.PngImageFile(BytesIO(image_data))\n\n        ImageFile.LOAD_TRUNCATED_IMAGES = True\n        try:\n            im = load(image_data)\n            assert im is not None\n        finally:\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    def test_verify_not_ignores_crc_error_in_required_chunk(self) -> None:\n        # check does not ignore crc errors in required chunks\n\n        image_data = MAGIC + IHDR[:-1] + b\"q\" + TAIL\n\n        ImageFile.LOAD_TRUNCATED_IMAGES = True\n        try:\n            with pytest.raises(SyntaxError):\n                PngImagePlugin.PngImageFile(BytesIO(image_data))\n        finally:\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    def test_roundtrip_dpi(self) -> None:\n        # Check dpi roundtripping\n\n        with Image.open(TEST_PNG_FILE) as im:\n            im = roundtrip(im, dpi=(100.33, 100.33))\n        assert im.info[\"dpi\"] == (100.33, 100.33)\n\n    def test_load_float_dpi(self) -> None:\n        with Image.open(TEST_PNG_FILE) as im:\n            assert im.info[\"dpi\"] == (95.9866, 95.9866)\n\n    def test_roundtrip_text(self) -> None:\n        # Check text roundtripping\n\n        with Image.open(TEST_PNG_FILE) as im:\n            info = PngImagePlugin.PngInfo()\n            info.add_text(\"TXT\", \"VALUE\")\n            info.add_text(\"ZIP\", \"VALUE\", zip=True)\n\n            im = roundtrip(im, pnginfo=info)\n        assert im.info == {\"TXT\": \"VALUE\", \"ZIP\": \"VALUE\"}\n        assert im.text == {\"TXT\": \"VALUE\", \"ZIP\": \"VALUE\"}\n\n    def test_roundtrip_itxt(self) -> None:\n        # Check iTXt roundtripping\n\n        im = Image.new(\"RGB\", (32, 32))\n        info = PngImagePlugin.PngInfo()\n        info.add_itxt(\"spam\", \"Eggs\", \"en\", \"Spam\")\n        info.add_text(\"eggs\", PngImagePlugin.iTXt(\"Spam\", \"en\", \"Eggs\"), zip=True)\n\n        im = roundtrip(im, pnginfo=info)\n        assert im.info == {\"spam\": \"Eggs\", \"eggs\": \"Spam\"}\n        assert im.text == {\"spam\": \"Eggs\", \"eggs\": \"Spam\"}\n        assert im.text[\"spam\"].lang == \"en\"\n        assert im.text[\"spam\"].tkey == \"Spam\"\n        assert im.text[\"eggs\"].lang == \"en\"\n        assert im.text[\"eggs\"].tkey == \"Eggs\"\n\n    def test_nonunicode_text(self) -> None:\n        # Check so that non-Unicode text is saved as a tEXt rather than iTXt\n\n        im = Image.new(\"RGB\", (32, 32))\n        info = PngImagePlugin.PngInfo()\n        info.add_text(\"Text\", \"Ascii\")\n        im = roundtrip(im, pnginfo=info)\n        assert isinstance(im.info[\"Text\"], str)\n\n    def test_unicode_text(self) -> None:\n        # Check preservation of non-ASCII characters\n\n        def rt_text(value: str) -> None:\n            im = Image.new(\"RGB\", (32, 32))\n            info = PngImagePlugin.PngInfo()\n            info.add_text(\"Text\", value)\n            im = roundtrip(im, pnginfo=info)\n            assert im.info == {\"Text\": value}\n\n        rt_text(\" Aa\" + chr(0xA0) + chr(0xC4) + chr(0xFF))  # Latin1\n        rt_text(chr(0x400) + chr(0x472) + chr(0x4FF))  # Cyrillic\n        # CJK:\n        rt_text(chr(0x4E00) + chr(0x66F0) + chr(0x9FBA) + chr(0x3042) + chr(0xAC00))\n        rt_text(\"A\" + chr(0xC4) + chr(0x472) + chr(0x3042))  # Combined\n\n    def test_scary(self) -> None:\n        # Check reading of evil PNG file.  For information, see:\n        # http://scary.beasts.org/security/CESA-2004-001.txt\n        # The first byte is removed from pngtest_bad.png\n        # to avoid classification as malware.\n\n        with open(\"Tests/images/pngtest_bad.png.bin\", \"rb\") as fd:\n            data = b\"\\x89\" + fd.read()\n\n        pngfile = BytesIO(data)\n        with pytest.raises(OSError):\n            with Image.open(pngfile):\n                pass\n\n    def test_trns_rgb(self) -> None:\n        # Check writing and reading of tRNS chunks for RGB images.\n        # Independent file sample provided by Sebastian Spaeth.\n\n        test_file = \"Tests/images/caption_6_33_22.png\"\n        with Image.open(test_file) as im:\n            assert im.info[\"transparency\"] == (248, 248, 248)\n\n            # check saving transparency by default\n            im = roundtrip(im)\n        assert im.info[\"transparency\"] == (248, 248, 248)\n\n        im = roundtrip(im, transparency=(0, 1, 2))\n        assert im.info[\"transparency\"] == (0, 1, 2)\n\n    def test_trns_p(self, tmp_path: Path) -> None:\n        # Check writing a transparency of 0, issue #528\n        im = hopper(\"P\")\n        im.info[\"transparency\"] = 0\n\n        f = str(tmp_path / \"temp.png\")\n        im.save(f)\n\n        with Image.open(f) as im2:\n            assert \"transparency\" in im2.info\n\n            assert_image_equal(im2.convert(\"RGBA\"), im.convert(\"RGBA\"))\n\n    def test_trns_null(self) -> None:\n        # Check reading images with null tRNS value, issue #1239\n        test_file = \"Tests/images/tRNS_null_1x1.png\"\n        with Image.open(test_file) as im:\n            assert im.info[\"transparency\"] == 0\n\n    def test_save_icc_profile(self) -> None:\n        with Image.open(\"Tests/images/icc_profile_none.png\") as im:\n            assert im.info[\"icc_profile\"] is None\n\n            with Image.open(\"Tests/images/icc_profile.png\") as with_icc:\n                expected_icc = with_icc.info[\"icc_profile\"]\n\n                im = roundtrip(im, icc_profile=expected_icc)\n                assert im.info[\"icc_profile\"] == expected_icc\n\n    def test_discard_icc_profile(self) -> None:\n        with Image.open(\"Tests/images/icc_profile.png\") as im:\n            assert \"icc_profile\" in im.info\n\n            im = roundtrip(im, icc_profile=None)\n        assert \"icc_profile\" not in im.info\n\n    def test_roundtrip_icc_profile(self) -> None:\n        with Image.open(\"Tests/images/icc_profile.png\") as im:\n            expected_icc = im.info[\"icc_profile\"]\n\n            im = roundtrip(im)\n        assert im.info[\"icc_profile\"] == expected_icc\n\n    def test_roundtrip_no_icc_profile(self) -> None:\n        with Image.open(\"Tests/images/icc_profile_none.png\") as im:\n            assert im.info[\"icc_profile\"] is None\n\n            im = roundtrip(im)\n        assert \"icc_profile\" not in im.info\n\n    def test_repr_png(self) -> None:\n        im = hopper()\n        b = im._repr_png_()\n        assert b is not None\n\n        with Image.open(BytesIO(b)) as repr_png:\n            assert repr_png.format == \"PNG\"\n            assert_image_equal(im, repr_png)\n\n    def test_repr_png_error_returns_none(self) -> None:\n        im = hopper(\"F\")\n\n        assert im._repr_png_() is None\n\n    def test_chunk_order(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/icc_profile.png\") as im:\n            test_file = str(tmp_path / \"temp.png\")\n            im.convert(\"P\").save(test_file, dpi=(100, 100))\n\n        chunks = self.get_chunks(test_file)\n\n        # https://www.w3.org/TR/PNG/#5ChunkOrdering\n        # IHDR - shall be first\n        assert chunks.index(b\"IHDR\") == 0\n        # PLTE - before first IDAT\n        assert chunks.index(b\"PLTE\") < chunks.index(b\"IDAT\")\n        # iCCP - before PLTE and IDAT\n        assert chunks.index(b\"iCCP\") < chunks.index(b\"PLTE\")\n        assert chunks.index(b\"iCCP\") < chunks.index(b\"IDAT\")\n        # tRNS - after PLTE, before IDAT\n        assert chunks.index(b\"tRNS\") > chunks.index(b\"PLTE\")\n        assert chunks.index(b\"tRNS\") < chunks.index(b\"IDAT\")\n        # pHYs - before IDAT\n        assert chunks.index(b\"pHYs\") < chunks.index(b\"IDAT\")\n\n    def test_getchunks(self) -> None:\n        im = hopper()\n\n        chunks = PngImagePlugin.getchunks(im)\n        assert len(chunks) == 3\n\n    def test_read_private_chunks(self) -> None:\n        with Image.open(\"Tests/images/exif.png\") as im:\n            assert im.private_chunks == [(b\"orNT\", b\"\\x01\")]\n\n    def test_roundtrip_private_chunk(self) -> None:\n        # Check private chunk roundtripping\n\n        with Image.open(TEST_PNG_FILE) as im:\n            info = PngImagePlugin.PngInfo()\n            info.add(b\"prIV\", b\"VALUE\")\n            info.add(b\"atEC\", b\"VALUE2\")\n            info.add(b\"prIV\", b\"VALUE3\", True)\n\n            im = roundtrip(im, pnginfo=info)\n        assert im.private_chunks == [(b\"prIV\", b\"VALUE\"), (b\"atEC\", b\"VALUE2\")]\n        im.load()\n        assert im.private_chunks == [\n            (b\"prIV\", b\"VALUE\"),\n            (b\"atEC\", b\"VALUE2\"),\n            (b\"prIV\", b\"VALUE3\", True),\n        ]\n\n    def test_textual_chunks_after_idat(self) -> None:\n        with Image.open(\"Tests/images/hopper.png\") as im:\n            assert \"comment\" in im.text\n            for k, v in {\n                \"date:create\": \"2014-09-04T09:37:08+03:00\",\n                \"date:modify\": \"2014-09-04T09:37:08+03:00\",\n            }.items():\n                assert im.text[k] == v\n\n        # Raises a SyntaxError in load_end\n        with Image.open(\"Tests/images/broken_data_stream.png\") as im:\n            with pytest.raises(OSError):\n                assert isinstance(im.text, dict)\n\n        # Raises a UnicodeDecodeError in load_end\n        with Image.open(\"Tests/images/truncated_image.png\") as im:\n            # The file is truncated\n            with pytest.raises(OSError):\n                im.text()\n            ImageFile.LOAD_TRUNCATED_IMAGES = True\n            assert isinstance(im.text, dict)\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n        # Raises an EOFError in load_end\n        with Image.open(\"Tests/images/hopper_idat_after_image_end.png\") as im:\n            assert im.text == {\"TXT\": \"VALUE\", \"ZIP\": \"VALUE\"}\n\n    def test_unknown_compression_method(self) -> None:\n        with pytest.raises(SyntaxError, match=\"Unknown compression method\"):\n            PngImagePlugin.PngImageFile(\"Tests/images/unknown_compression_method.png\")\n\n    def test_padded_idat(self) -> None:\n        # This image has been manually hexedited\n        # so that the IDAT chunk has padding at the end\n        # Set MAXBLOCK to the length of the actual data\n        # so that the decoder finishes reading before the chunk ends\n        MAXBLOCK = ImageFile.MAXBLOCK\n        ImageFile.MAXBLOCK = 45\n        ImageFile.LOAD_TRUNCATED_IMAGES = True\n\n        with Image.open(\"Tests/images/padded_idat.png\") as im:\n            im.load()\n\n            ImageFile.MAXBLOCK = MAXBLOCK\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n            assert_image_equal_tofile(im, \"Tests/images/bw_gradient.png\")\n\n    @pytest.mark.parametrize(\n        \"cid\", (b\"IHDR\", b\"sRGB\", b\"pHYs\", b\"acTL\", b\"fcTL\", b\"fdAT\")\n    )\n    def test_truncated_chunks(self, cid: bytes) -> None:\n        fp = BytesIO()\n        with PngImagePlugin.PngStream(fp) as png:\n            with pytest.raises(ValueError):\n                png.call(cid, 0, 0)\n\n            ImageFile.LOAD_TRUNCATED_IMAGES = True\n            png.call(cid, 0, 0)\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    def test_specify_bits(self, tmp_path: Path) -> None:\n        im = hopper(\"P\")\n\n        out = str(tmp_path / \"temp.png\")\n        im.save(out, bits=4)\n\n        with Image.open(out) as reloaded:\n            assert len(reloaded.png.im_palette[1]) == 48\n\n    def test_plte_length(self, tmp_path: Path) -> None:\n        im = Image.new(\"P\", (1, 1))\n        im.putpalette((1, 1, 1))\n\n        out = str(tmp_path / \"temp.png\")\n        im.save(str(tmp_path / \"temp.png\"))\n\n        with Image.open(out) as reloaded:\n            assert len(reloaded.png.im_palette[1]) == 3\n\n    def test_getxmp(self) -> None:\n        with Image.open(\"Tests/images/color_snakes.png\") as im:\n            if ElementTree is None:\n                with pytest.warns(\n                    UserWarning,\n                    match=\"XMP data cannot be read without defusedxml dependency\",\n                ):\n                    assert im.getxmp() == {}\n            else:\n                assert \"xmp\" in im.info\n                xmp = im.getxmp()\n\n                description = xmp[\"xmpmeta\"][\"RDF\"][\"Description\"]\n                assert description[\"PixelXDimension\"] == \"10\"\n                assert description[\"subject\"][\"Seq\"] is None\n\n    def test_exif(self) -> None:\n        # With an EXIF chunk\n        with Image.open(\"Tests/images/exif.png\") as im:\n            exif = im._getexif()\n        assert exif[274] == 1\n\n        # With an ImageMagick zTXt chunk\n        with Image.open(\"Tests/images/exif_imagemagick.png\") as im:\n            exif = im._getexif()\n            assert exif[274] == 1\n\n            # Assert that info still can be extracted\n            # when the image is no longer a PngImageFile instance\n            exif = im.copy().getexif()\n            assert exif[274] == 1\n\n        # With a tEXt chunk\n        with Image.open(\"Tests/images/exif_text.png\") as im:\n            exif = im._getexif()\n        assert exif[274] == 1\n\n        # With XMP tags\n        with Image.open(\"Tests/images/xmp_tags_orientation.png\") as im:\n            exif = im.getexif()\n        assert exif[274] == 3\n\n    def test_exif_save(self, tmp_path: Path) -> None:\n        # Test exif is not saved from info\n        test_file = str(tmp_path / \"temp.png\")\n        with Image.open(\"Tests/images/exif.png\") as im:\n            im.save(test_file)\n\n        with Image.open(test_file) as reloaded:\n            assert reloaded._getexif() is None\n\n        # Test passing in exif\n        with Image.open(\"Tests/images/exif.png\") as im:\n            im.save(test_file, exif=im.getexif())\n\n        with Image.open(test_file) as reloaded:\n            exif = reloaded._getexif()\n        assert exif[274] == 1\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_exif_from_jpg(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/pil_sample_rgb.jpg\") as im:\n            test_file = str(tmp_path / \"temp.png\")\n            im.save(test_file, exif=im.getexif())\n\n        with Image.open(test_file) as reloaded:\n            exif = reloaded._getexif()\n        assert exif[305] == \"Adobe Photoshop CS Macintosh\"\n\n    def test_exif_argument(self, tmp_path: Path) -> None:\n        with Image.open(TEST_PNG_FILE) as im:\n            test_file = str(tmp_path / \"temp.png\")\n            im.save(test_file, exif=b\"exifstring\")\n\n        with Image.open(test_file) as reloaded:\n            assert reloaded.info[\"exif\"] == b\"Exif\\x00\\x00exifstring\"\n\n    def test_tell(self) -> None:\n        with Image.open(TEST_PNG_FILE) as im:\n            assert im.tell() == 0\n\n    def test_seek(self) -> None:\n        with Image.open(TEST_PNG_FILE) as im:\n            im.seek(0)\n\n            with pytest.raises(EOFError):\n                im.seek(1)\n\n    @pytest.mark.parametrize(\"buffer\", (True, False))\n    def test_save_stdout(self, buffer: bool) -> None:\n        old_stdout = sys.stdout\n\n        class MyStdOut:\n            buffer = BytesIO()\n\n        mystdout: MyStdOut | BytesIO = MyStdOut() if buffer else BytesIO()\n\n        sys.stdout = mystdout  # type: ignore[assignment]\n\n        with Image.open(TEST_PNG_FILE) as im:\n            im.save(sys.stdout, \"PNG\")\n\n        # Reset stdout\n        sys.stdout = old_stdout\n\n        if isinstance(mystdout, MyStdOut):\n            mystdout = mystdout.buffer\n        with Image.open(mystdout) as reloaded:\n            assert_image_equal_tofile(reloaded, TEST_PNG_FILE)\n\n    def test_truncated_end_chunk(self) -> None:\n        with Image.open(\"Tests/images/truncated_end_chunk.png\") as im:\n            with pytest.raises(OSError):\n                im.load()\n\n        ImageFile.LOAD_TRUNCATED_IMAGES = True\n        try:\n            with Image.open(\"Tests/images/truncated_end_chunk.png\") as im:\n                assert_image_equal_tofile(im, \"Tests/images/hopper.png\")\n        finally:\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n\n@pytest.mark.skipif(is_win32(), reason=\"Requires Unix or macOS\")\n@skip_unless_feature(\"zlib\")\nclass TestTruncatedPngPLeaks(PillowLeakTestCase):\n    mem_limit = 2 * 1024  # max increase in K\n    iterations = 100  # Leak is 56k/iteration, this will leak 5.6megs\n\n    def test_leak_load(self) -> None:\n        with open(\"Tests/images/hopper.png\", \"rb\") as f:\n            DATA = BytesIO(f.read(16 * 1024))\n\n        ImageFile.LOAD_TRUNCATED_IMAGES = True\n        with Image.open(DATA) as im:\n            im.load()\n\n        def core() -> None:\n            with Image.open(DATA) as im:\n                im.load()\n\n        try:\n            self._test_leak(core)\n        finally:\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n", "Tests/test_file_jpeg.py": "from __future__ import annotations\n\nimport os\nimport re\nimport warnings\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import Any, cast\n\nimport pytest\n\nfrom PIL import (\n    ExifTags,\n    Image,\n    ImageFile,\n    ImageOps,\n    JpegImagePlugin,\n    UnidentifiedImageError,\n    features,\n)\n\nfrom .helper import (\n    assert_image,\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    cjpeg_available,\n    djpeg_available,\n    hopper,\n    is_win32,\n    mark_if_feature_version,\n    skip_unless_feature,\n)\n\nElementTree: ModuleType | None\ntry:\n    from defusedxml import ElementTree\nexcept ImportError:\n    ElementTree = None\n\nTEST_FILE = \"Tests/images/hopper.jpg\"\n\n\n@skip_unless_feature(\"jpg\")\nclass TestFileJpeg:\n    def roundtrip_with_bytes(\n        self, im: Image.Image, **options: Any\n    ) -> tuple[JpegImagePlugin.JpegImageFile, int]:\n        out = BytesIO()\n        im.save(out, \"JPEG\", **options)\n        test_bytes = out.tell()\n        out.seek(0)\n        reloaded = cast(JpegImagePlugin.JpegImageFile, Image.open(out))\n        return reloaded, test_bytes\n\n    def roundtrip(\n        self, im: Image.Image, **options: Any\n    ) -> JpegImagePlugin.JpegImageFile:\n        return self.roundtrip_with_bytes(im, **options)[0]\n\n    def gen_random_image(self, size: tuple[int, int], mode: str = \"RGB\") -> Image.Image:\n        \"\"\"Generates a very hard to compress file\n        :param size: tuple\n        :param mode: optional image mode\n\n        \"\"\"\n        return Image.frombytes(mode, size, os.urandom(size[0] * size[1] * len(mode)))\n\n    def test_sanity(self) -> None:\n        # internal version number\n        version = features.version_codec(\"jpg\")\n        assert version is not None\n        assert re.search(r\"\\d+\\.\\d+$\", version)\n\n        with Image.open(TEST_FILE) as im:\n            im.load()\n            assert im.mode == \"RGB\"\n            assert im.size == (128, 128)\n            assert im.format == \"JPEG\"\n            assert im.get_format_mimetype() == \"image/jpeg\"\n\n    @pytest.mark.parametrize(\"size\", ((1, 0), (0, 1), (0, 0)))\n    def test_zero(self, size: tuple[int, int], tmp_path: Path) -> None:\n        f = str(tmp_path / \"temp.jpg\")\n        im = Image.new(\"RGB\", size)\n        with pytest.raises(ValueError):\n            im.save(f)\n\n    def test_app(self) -> None:\n        # Test APP/COM reader (@PIL135)\n        with Image.open(TEST_FILE) as im:\n            assert im.applist[0] == (\"APP0\", b\"JFIF\\x00\\x01\\x01\\x01\\x00`\\x00`\\x00\\x00\")\n            assert im.applist[1] == (\n                \"COM\",\n                b\"File written by Adobe Photoshop\\xa8 4.0\\x00\",\n            )\n            assert len(im.applist) == 2\n\n            assert im.info[\"comment\"] == b\"File written by Adobe Photoshop\\xa8 4.0\\x00\"\n            assert im.app[\"COM\"] == im.info[\"comment\"]\n\n    def test_comment_write(self) -> None:\n        with Image.open(TEST_FILE) as im:\n            assert im.info[\"comment\"] == b\"File written by Adobe Photoshop\\xa8 4.0\\x00\"\n\n            # Test that existing comment is saved by default\n            out = BytesIO()\n            im.save(out, format=\"JPEG\")\n            with Image.open(out) as reloaded:\n                assert im.info[\"comment\"] == reloaded.info[\"comment\"]\n\n            # Ensure that a blank comment causes any existing comment to be removed\n            for comment in (\"\", b\"\", None):\n                out = BytesIO()\n                im.save(out, format=\"JPEG\", comment=comment)\n                with Image.open(out) as reloaded:\n                    assert \"comment\" not in reloaded.info\n\n            # Test that a comment argument overrides the default comment\n            for comment in (\"Test comment text\", b\"Test comment text\"):\n                out = BytesIO()\n                im.save(out, format=\"JPEG\", comment=comment)\n                with Image.open(out) as reloaded:\n                    assert reloaded.info[\"comment\"] == b\"Test comment text\"\n\n    def test_cmyk(self) -> None:\n        # Test CMYK handling.  Thanks to Tim and Charlie for test data,\n        # Michael for getting me to look one more time.\n        f = \"Tests/images/pil_sample_cmyk.jpg\"\n        with Image.open(f) as im:\n            # the source image has red pixels in the upper left corner.\n            c, m, y, k = (x / 255.0 for x in im.getpixel((0, 0)))\n            assert c == 0.0\n            assert m > 0.8\n            assert y > 0.8\n            assert k == 0.0\n            # the opposite corner is black\n            c, m, y, k = (\n                x / 255.0 for x in im.getpixel((im.size[0] - 1, im.size[1] - 1))\n            )\n            assert k > 0.9\n            # roundtrip, and check again\n            im = self.roundtrip(im)\n            c, m, y, k = (x / 255.0 for x in im.getpixel((0, 0)))\n            assert c == 0.0\n            assert m > 0.8\n            assert y > 0.8\n            assert k == 0.0\n            c, m, y, k = (\n                x / 255.0 for x in im.getpixel((im.size[0] - 1, im.size[1] - 1))\n            )\n            assert k > 0.9\n\n    def test_rgb(self) -> None:\n        def getchannels(im: JpegImagePlugin.JpegImageFile) -> tuple[int, int, int]:\n            return tuple(v[0] for v in im.layer)\n\n        im = hopper()\n        im_ycbcr = self.roundtrip(im)\n        assert getchannels(im_ycbcr) == (1, 2, 3)\n        assert_image_similar(im, im_ycbcr, 17)\n\n        im_rgb = self.roundtrip(im, keep_rgb=True)\n        assert getchannels(im_rgb) == (ord(\"R\"), ord(\"G\"), ord(\"B\"))\n        assert_image_similar(im, im_rgb, 12)\n\n    @pytest.mark.parametrize(\n        \"test_image_path\",\n        [TEST_FILE, \"Tests/images/pil_sample_cmyk.jpg\"],\n    )\n    def test_dpi(self, test_image_path: str) -> None:\n        def test(xdpi: int, ydpi: int | None = None) -> tuple[int, int] | None:\n            with Image.open(test_image_path) as im:\n                im = self.roundtrip(im, dpi=(xdpi, ydpi or xdpi))\n            return im.info.get(\"dpi\")\n\n        assert test(72) == (72, 72)\n        assert test(300) == (300, 300)\n        assert test(100, 200) == (100, 200)\n        assert test(0) is None  # square pixels\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_icc(self, tmp_path: Path) -> None:\n        # Test ICC support\n        with Image.open(\"Tests/images/rgb.jpg\") as im1:\n            icc_profile = im1.info[\"icc_profile\"]\n            assert len(icc_profile) == 3144\n            # Roundtrip via physical file.\n            f = str(tmp_path / \"temp.jpg\")\n            im1.save(f, icc_profile=icc_profile)\n        with Image.open(f) as im2:\n            assert im2.info.get(\"icc_profile\") == icc_profile\n            # Roundtrip via memory buffer.\n            im1 = self.roundtrip(hopper())\n            im2 = self.roundtrip(hopper(), icc_profile=icc_profile)\n            assert_image_equal(im1, im2)\n            assert not im1.info.get(\"icc_profile\")\n            assert im2.info.get(\"icc_profile\")\n\n    @pytest.mark.parametrize(\n        \"n\",\n        (\n            0,\n            1,\n            3,\n            4,\n            5,\n            65533 - 14,  # full JPEG marker block\n            65533 - 14 + 1,  # full block plus one byte\n            ImageFile.MAXBLOCK,  # full buffer block\n            ImageFile.MAXBLOCK + 1,  # full buffer block plus one byte\n            ImageFile.MAXBLOCK * 4 + 3,  # large block\n        ),\n    )\n    def test_icc_big(self, n: int) -> None:\n        # Make sure that the \"extra\" support handles large blocks\n        # The ICC APP marker can store 65519 bytes per marker, so\n        # using a 4-byte test code should allow us to detect out of\n        # order issues.\n        icc_profile = (b\"Test\" * int(n / 4 + 1))[:n]\n        assert len(icc_profile) == n  # sanity\n        im1 = self.roundtrip(hopper(), icc_profile=icc_profile)\n        assert im1.info.get(\"icc_profile\") == (icc_profile or None)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_large_icc_meta(self, tmp_path: Path) -> None:\n        # https://github.com/python-pillow/Pillow/issues/148\n        # Sometimes the meta data on the icc_profile block is bigger than\n        # Image.MAXBLOCK or the image size.\n        with Image.open(\"Tests/images/icc_profile_big.jpg\") as im:\n            f = str(tmp_path / \"temp.jpg\")\n            icc_profile = im.info[\"icc_profile\"]\n            # Should not raise OSError for image with icc larger than image size.\n            im.save(\n                f,\n                progressive=True,\n                quality=95,\n                icc_profile=icc_profile,\n                optimize=True,\n            )\n\n        with Image.open(\"Tests/images/flower2.jpg\") as im:\n            f = str(tmp_path / \"temp2.jpg\")\n            im.save(f, progressive=True, quality=94, icc_profile=b\" \" * 53955)\n\n        with Image.open(\"Tests/images/flower2.jpg\") as im:\n            f = str(tmp_path / \"temp3.jpg\")\n            im.save(f, progressive=True, quality=94, exif=b\" \" * 43668)\n\n    def test_optimize(self) -> None:\n        im1, im1_bytes = self.roundtrip_with_bytes(hopper())\n        im2, im2_bytes = self.roundtrip_with_bytes(hopper(), optimize=0)\n        im3, im3_bytes = self.roundtrip_with_bytes(hopper(), optimize=1)\n        assert_image_equal(im1, im2)\n        assert_image_equal(im1, im3)\n        assert im1_bytes >= im2_bytes\n        assert im1_bytes >= im3_bytes\n\n    def test_optimize_large_buffer(self, tmp_path: Path) -> None:\n        # https://github.com/python-pillow/Pillow/issues/148\n        f = str(tmp_path / \"temp.jpg\")\n        # this requires ~ 1.5x Image.MAXBLOCK\n        im = Image.new(\"RGB\", (4096, 4096), 0xFF3333)\n        im.save(f, format=\"JPEG\", optimize=True)\n\n    def test_progressive(self) -> None:\n        im1, im1_bytes = self.roundtrip_with_bytes(hopper())\n        im2 = self.roundtrip(hopper(), progressive=False)\n        im3, im3_bytes = self.roundtrip_with_bytes(hopper(), progressive=True)\n        assert not im1.info.get(\"progressive\")\n        assert not im2.info.get(\"progressive\")\n        assert im3.info.get(\"progressive\")\n\n        assert_image_equal(im1, im3)\n        assert im1_bytes >= im3_bytes\n\n    def test_progressive_large_buffer(self, tmp_path: Path) -> None:\n        f = str(tmp_path / \"temp.jpg\")\n        # this requires ~ 1.5x Image.MAXBLOCK\n        im = Image.new(\"RGB\", (4096, 4096), 0xFF3333)\n        im.save(f, format=\"JPEG\", progressive=True)\n\n    def test_progressive_large_buffer_highest_quality(self, tmp_path: Path) -> None:\n        f = str(tmp_path / \"temp.jpg\")\n        im = self.gen_random_image((255, 255))\n        # this requires more bytes than pixels in the image\n        im.save(f, format=\"JPEG\", progressive=True, quality=100)\n\n    def test_progressive_cmyk_buffer(self) -> None:\n        # Issue 2272, quality 90 cmyk image is tripping the large buffer bug.\n        f = BytesIO()\n        im = self.gen_random_image((256, 256), \"CMYK\")\n        im.save(f, format=\"JPEG\", progressive=True, quality=94)\n\n    def test_large_exif(self, tmp_path: Path) -> None:\n        # https://github.com/python-pillow/Pillow/issues/148\n        f = str(tmp_path / \"temp.jpg\")\n        im = hopper()\n        im.save(f, \"JPEG\", quality=90, exif=b\"1\" * 65533)\n\n        with pytest.raises(ValueError):\n            im.save(f, \"JPEG\", quality=90, exif=b\"1\" * 65534)\n\n    def test_exif_typeerror(self) -> None:\n        with Image.open(\"Tests/images/exif_typeerror.jpg\") as im:\n            # Should not raise a TypeError\n            im._getexif()\n\n    def test_exif_gps(self, tmp_path: Path) -> None:\n        expected_exif_gps = {\n            0: b\"\\x00\\x00\\x00\\x01\",\n            2: 4294967295,\n            5: b\"\\x01\",\n            30: 65535,\n            29: \"1999:99:99 99:99:99\",\n        }\n        gps_index = 34853\n\n        # Reading\n        with Image.open(\"Tests/images/exif_gps.jpg\") as im:\n            exif = im._getexif()\n            assert exif[gps_index] == expected_exif_gps\n\n        # Writing\n        f = str(tmp_path / \"temp.jpg\")\n        exif = Image.Exif()\n        exif[gps_index] = expected_exif_gps\n        hopper().save(f, exif=exif)\n\n        with Image.open(f) as reloaded:\n            exif = reloaded._getexif()\n            assert exif[gps_index] == expected_exif_gps\n\n    def test_empty_exif_gps(self) -> None:\n        with Image.open(\"Tests/images/empty_gps_ifd.jpg\") as im:\n            exif = im.getexif()\n            del exif[0x8769]\n\n            # Assert that it needs to be transposed\n            assert exif[0x0112] == Image.Transpose.TRANSVERSE\n\n            # Assert that the GPS IFD is present and empty\n            assert exif.get_ifd(0x8825) == {}\n\n            transposed = ImageOps.exif_transpose(im)\n        assert transposed is not None\n        exif = transposed.getexif()\n        assert exif.get_ifd(0x8825) == {}\n\n        # Assert that it was transposed\n        assert 0x0112 not in exif\n\n    def test_exif_equality(self) -> None:\n        # In 7.2.0, Exif rationals were changed to be read as\n        # TiffImagePlugin.IFDRational. This class had a bug in __eq__,\n        # breaking the self-equality of Exif data\n        exifs = []\n        for i in range(2):\n            with Image.open(\"Tests/images/exif-200dpcm.jpg\") as im:\n                exifs.append(im._getexif())\n        assert exifs[0] == exifs[1]\n\n    def test_exif_rollback(self) -> None:\n        # rolling back exif support in 3.1 to pre-3.0 formatting.\n        # expected from 2.9, with b/u qualifiers switched for 3.2 compatibility\n        # this test passes on 2.9 and 3.1, but not 3.0\n        expected_exif = {\n            34867: 4294967295,\n            258: (24, 24, 24),\n            36867: \"2099:09:29 10:10:10\",\n            34853: {\n                0: b\"\\x00\\x00\\x00\\x01\",\n                2: 4294967295,\n                5: b\"\\x01\",\n                30: 65535,\n                29: \"1999:99:99 99:99:99\",\n            },\n            296: 65535,\n            34665: 185,\n            41994: 65535,\n            514: 4294967295,\n            271: \"Make\",\n            272: \"XXX-XXX\",\n            305: \"PIL\",\n            42034: (1, 1, 1, 1),\n            42035: \"LensMake\",\n            34856: b\"\\xaa\\xaa\\xaa\\xaa\\xaa\\xaa\",\n            282: 4294967295,\n            33434: 4294967295,\n        }\n\n        with Image.open(\"Tests/images/exif_gps.jpg\") as im:\n            exif = im._getexif()\n\n        for tag, value in expected_exif.items():\n            assert value == exif[tag]\n\n    def test_exif_gps_typeerror(self) -> None:\n        with Image.open(\"Tests/images/exif_gps_typeerror.jpg\") as im:\n            # Should not raise a TypeError\n            im._getexif()\n\n    def test_progressive_compat(self) -> None:\n        im1 = self.roundtrip(hopper())\n        assert not im1.info.get(\"progressive\")\n        assert not im1.info.get(\"progression\")\n\n        im2 = self.roundtrip(hopper(), progressive=0)\n        im3 = self.roundtrip(hopper(), progression=0)  # compatibility\n        assert not im2.info.get(\"progressive\")\n        assert not im2.info.get(\"progression\")\n        assert not im3.info.get(\"progressive\")\n        assert not im3.info.get(\"progression\")\n\n        im2 = self.roundtrip(hopper(), progressive=1)\n        im3 = self.roundtrip(hopper(), progression=1)  # compatibility\n        assert_image_equal(im1, im2)\n        assert_image_equal(im1, im3)\n        assert im2.info.get(\"progressive\")\n        assert im2.info.get(\"progression\")\n        assert im3.info.get(\"progressive\")\n        assert im3.info.get(\"progression\")\n\n    def test_quality(self) -> None:\n        im1, im1_bytes = self.roundtrip_with_bytes(hopper())\n        im2, im2_bytes = self.roundtrip_with_bytes(hopper(), quality=50)\n        assert_image(im1, im2.mode, im2.size)\n        assert im1_bytes >= im2_bytes\n\n        im3, im3_bytes = self.roundtrip_with_bytes(hopper(), quality=0)\n        assert_image(im1, im3.mode, im3.size)\n        assert im2_bytes > im3_bytes\n\n    def test_smooth(self) -> None:\n        im1 = self.roundtrip(hopper())\n        im2 = self.roundtrip(hopper(), smooth=100)\n        assert_image(im1, im2.mode, im2.size)\n\n    def test_subsampling(self) -> None:\n        def getsampling(\n            im: JpegImagePlugin.JpegImageFile,\n        ) -> tuple[int, int, int, int, int, int]:\n            layer = im.layer\n            return layer[0][1:3] + layer[1][1:3] + layer[2][1:3]\n\n        # experimental API\n        for subsampling in (-1, 3):  # (default, invalid)\n            im = self.roundtrip(hopper(), subsampling=subsampling)\n            assert getsampling(im) == (2, 2, 1, 1, 1, 1)\n        for subsampling1 in (0, \"4:4:4\"):\n            im = self.roundtrip(hopper(), subsampling=subsampling1)\n            assert getsampling(im) == (1, 1, 1, 1, 1, 1)\n        for subsampling1 in (1, \"4:2:2\"):\n            im = self.roundtrip(hopper(), subsampling=subsampling1)\n            assert getsampling(im) == (2, 1, 1, 1, 1, 1)\n        for subsampling1 in (2, \"4:2:0\", \"4:1:1\"):\n            im = self.roundtrip(hopper(), subsampling=subsampling1)\n            assert getsampling(im) == (2, 2, 1, 1, 1, 1)\n\n        # RGB colorspace\n        for subsampling1 in (-1, 0, \"4:4:4\"):\n            # \"4:4:4\" doesn't really make sense for RGB, but the conversion\n            # to an integer happens at a higher level\n            im = self.roundtrip(hopper(), keep_rgb=True, subsampling=subsampling1)\n            assert getsampling(im) == (1, 1, 1, 1, 1, 1)\n        for subsampling1 in (1, \"4:2:2\", 2, \"4:2:0\", 3):\n            with pytest.raises(OSError):\n                self.roundtrip(hopper(), keep_rgb=True, subsampling=subsampling1)\n\n        with pytest.raises(TypeError):\n            self.roundtrip(hopper(), subsampling=\"1:1:1\")\n\n    def test_exif(self) -> None:\n        with Image.open(\"Tests/images/pil_sample_rgb.jpg\") as im:\n            info = im._getexif()\n            assert info[305] == \"Adobe Photoshop CS Macintosh\"\n\n    def test_get_child_images(self) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            ims = im.get_child_images()\n\n        assert len(ims) == 1\n        assert_image_similar_tofile(ims[0], \"Tests/images/flower_thumbnail.png\", 2.1)\n\n    def test_mp(self) -> None:\n        with Image.open(\"Tests/images/pil_sample_rgb.jpg\") as im:\n            assert im._getmp() is None\n\n    def test_quality_keep(self, tmp_path: Path) -> None:\n        # RGB\n        with Image.open(\"Tests/images/hopper.jpg\") as im:\n            f = str(tmp_path / \"temp.jpg\")\n            im.save(f, quality=\"keep\")\n        # Grayscale\n        with Image.open(\"Tests/images/hopper_gray.jpg\") as im:\n            f = str(tmp_path / \"temp.jpg\")\n            im.save(f, quality=\"keep\")\n        # CMYK\n        with Image.open(\"Tests/images/pil_sample_cmyk.jpg\") as im:\n            f = str(tmp_path / \"temp.jpg\")\n            im.save(f, quality=\"keep\")\n\n    def test_junk_jpeg_header(self) -> None:\n        # https://github.com/python-pillow/Pillow/issues/630\n        filename = \"Tests/images/junk_jpeg_header.jpg\"\n        with Image.open(filename):\n            pass\n\n    def test_ff00_jpeg_header(self) -> None:\n        filename = \"Tests/images/jpeg_ff00_header.jpg\"\n        with Image.open(filename):\n            pass\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_truncated_jpeg_should_read_all_the_data(self) -> None:\n        filename = \"Tests/images/truncated_jpeg.jpg\"\n        ImageFile.LOAD_TRUNCATED_IMAGES = True\n        with Image.open(filename) as im:\n            im.load()\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n            assert im.getbbox() is not None\n\n    def test_truncated_jpeg_throws_oserror(self) -> None:\n        filename = \"Tests/images/truncated_jpeg.jpg\"\n        with Image.open(filename) as im:\n            with pytest.raises(OSError):\n                im.load()\n\n            # Test that the error is raised if loaded a second time\n            with pytest.raises(OSError):\n                im.load()\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_qtables(self, tmp_path: Path) -> None:\n        def _n_qtables_helper(n: int, test_file: str) -> None:\n            with Image.open(test_file) as im:\n                f = str(tmp_path / \"temp.jpg\")\n                im.save(f, qtables=[[n] * 64] * n)\n            with Image.open(f) as im:\n                assert len(im.quantization) == n\n                reloaded = self.roundtrip(im, qtables=\"keep\")\n                assert im.quantization == reloaded.quantization\n                assert max(reloaded.quantization[0]) <= 255\n\n        with Image.open(\"Tests/images/hopper.jpg\") as im:\n            qtables = im.quantization\n            reloaded = self.roundtrip(im, qtables=qtables, subsampling=0)\n            assert im.quantization == reloaded.quantization\n            assert_image_similar(im, self.roundtrip(im, qtables=\"web_low\"), 30)\n            assert_image_similar(im, self.roundtrip(im, qtables=\"web_high\"), 30)\n            assert_image_similar(im, self.roundtrip(im, qtables=\"keep\"), 30)\n\n            # valid bounds for baseline qtable\n            bounds_qtable = [int(s) for s in (\"255 1 \" * 32).split(None)]\n            im2 = self.roundtrip(im, qtables=[bounds_qtable])\n            assert im2.quantization == {0: bounds_qtable}\n\n            # values from wizard.txt in jpeg9-a src package.\n            standard_l_qtable = [\n                int(s)\n                for s in \"\"\"\n                16  11  10  16  24  40  51  61\n                12  12  14  19  26  58  60  55\n                14  13  16  24  40  57  69  56\n                14  17  22  29  51  87  80  62\n                18  22  37  56  68 109 103  77\n                24  35  55  64  81 104 113  92\n                49  64  78  87 103 121 120 101\n                72  92  95  98 112 100 103  99\n                \"\"\".split(\n                    None\n                )\n            ]\n\n            standard_chrominance_qtable = [\n                int(s)\n                for s in \"\"\"\n                17  18  24  47  99  99  99  99\n                18  21  26  66  99  99  99  99\n                24  26  56  99  99  99  99  99\n                47  66  99  99  99  99  99  99\n                99  99  99  99  99  99  99  99\n                99  99  99  99  99  99  99  99\n                99  99  99  99  99  99  99  99\n                99  99  99  99  99  99  99  99\n                \"\"\".split(\n                    None\n                )\n            ]\n            # list of qtable lists\n            assert_image_similar(\n                im,\n                self.roundtrip(\n                    im, qtables=[standard_l_qtable, standard_chrominance_qtable]\n                ),\n                30,\n            )\n\n            # tuple of qtable lists\n            assert_image_similar(\n                im,\n                self.roundtrip(\n                    im, qtables=(standard_l_qtable, standard_chrominance_qtable)\n                ),\n                30,\n            )\n\n            # dict of qtable lists\n            assert_image_similar(\n                im,\n                self.roundtrip(\n                    im, qtables={0: standard_l_qtable, 1: standard_chrominance_qtable}\n                ),\n                30,\n            )\n\n            _n_qtables_helper(1, \"Tests/images/hopper_gray.jpg\")\n            _n_qtables_helper(1, \"Tests/images/pil_sample_rgb.jpg\")\n            _n_qtables_helper(2, \"Tests/images/pil_sample_rgb.jpg\")\n            _n_qtables_helper(3, \"Tests/images/pil_sample_rgb.jpg\")\n            _n_qtables_helper(1, \"Tests/images/pil_sample_cmyk.jpg\")\n            _n_qtables_helper(2, \"Tests/images/pil_sample_cmyk.jpg\")\n            _n_qtables_helper(3, \"Tests/images/pil_sample_cmyk.jpg\")\n            _n_qtables_helper(4, \"Tests/images/pil_sample_cmyk.jpg\")\n\n            # not a sequence\n            with pytest.raises(ValueError):\n                self.roundtrip(im, qtables=\"a\")\n            # sequence wrong length\n            with pytest.raises(ValueError):\n                self.roundtrip(im, qtables=[])\n            # sequence wrong length\n            with pytest.raises(ValueError):\n                self.roundtrip(im, qtables=[1, 2, 3, 4, 5])\n\n            # qtable entry not a sequence\n            with pytest.raises(ValueError):\n                self.roundtrip(im, qtables=[1])\n            # qtable entry has wrong number of items\n            with pytest.raises(ValueError):\n                self.roundtrip(im, qtables=[[1, 2, 3, 4]])\n\n    def test_load_16bit_qtables(self) -> None:\n        with Image.open(\"Tests/images/hopper_16bit_qtables.jpg\") as im:\n            assert len(im.quantization) == 2\n            assert len(im.quantization[0]) == 64\n            assert max(im.quantization[0]) > 255\n\n    def test_save_multiple_16bit_qtables(self) -> None:\n        with Image.open(\"Tests/images/hopper_16bit_qtables.jpg\") as im:\n            im2 = self.roundtrip(im, qtables=\"keep\")\n            assert im.quantization == im2.quantization\n\n    def test_save_single_16bit_qtable(self) -> None:\n        with Image.open(\"Tests/images/hopper_16bit_qtables.jpg\") as im:\n            im2 = self.roundtrip(im, qtables={0: im.quantization[0]})\n            assert len(im2.quantization) == 1\n            assert im2.quantization[0] == im.quantization[0]\n\n    def test_save_low_quality_baseline_qtables(self) -> None:\n        with Image.open(TEST_FILE) as im:\n            im2 = self.roundtrip(im, quality=10)\n            assert len(im2.quantization) == 2\n            assert max(im2.quantization[0]) <= 255\n            assert max(im2.quantization[1]) <= 255\n\n    @pytest.mark.parametrize(\n        \"blocks, rows, markers\",\n        ((0, 0, 0), (1, 0, 15), (3, 0, 5), (8, 0, 1), (0, 1, 3), (0, 2, 1)),\n    )\n    def test_restart_markers(self, blocks: int, rows: int, markers: int) -> None:\n        im = Image.new(\"RGB\", (32, 32))  # 16 MCUs\n        out = BytesIO()\n        im.save(\n            out,\n            format=\"JPEG\",\n            restart_marker_blocks=blocks,\n            restart_marker_rows=rows,\n            # force 8x8 pixel MCUs\n            subsampling=0,\n        )\n        assert len(re.findall(b\"\\xff[\\xd0-\\xd7]\", out.getvalue())) == markers\n\n    @pytest.mark.skipif(not djpeg_available(), reason=\"djpeg not available\")\n    def test_load_djpeg(self) -> None:\n        with Image.open(TEST_FILE) as img:\n            img.load_djpeg()\n            assert_image_similar_tofile(img, TEST_FILE, 5)\n\n    @pytest.mark.skipif(not cjpeg_available(), reason=\"cjpeg not available\")\n    def test_save_cjpeg(self, tmp_path: Path) -> None:\n        with Image.open(TEST_FILE) as img:\n            tempfile = str(tmp_path / \"temp.jpg\")\n            JpegImagePlugin._save_cjpeg(img, BytesIO(), tempfile)\n            # Default save quality is 75%, so a tiny bit of difference is alright\n            assert_image_similar_tofile(img, tempfile, 17)\n\n    def test_no_duplicate_0x1001_tag(self) -> None:\n        # Arrange\n        tag_ids = {v: k for k, v in ExifTags.TAGS.items()}\n\n        # Assert\n        assert tag_ids[\"RelatedImageWidth\"] == 0x1001\n        assert tag_ids[\"RelatedImageLength\"] == 0x1002\n\n    def test_MAXBLOCK_scaling(self, tmp_path: Path) -> None:\n        im = self.gen_random_image((512, 512))\n        f = str(tmp_path / \"temp.jpeg\")\n        im.save(f, quality=100, optimize=True)\n\n        with Image.open(f) as reloaded:\n            # none of these should crash\n            reloaded.save(f, quality=\"keep\")\n            reloaded.save(f, quality=\"keep\", progressive=True)\n            reloaded.save(f, quality=\"keep\", optimize=True)\n\n    def test_bad_mpo_header(self) -> None:\n        \"\"\"Treat unknown MPO as JPEG\"\"\"\n        # Arrange\n\n        # Act\n        # Shouldn't raise error\n        fn = \"Tests/images/sugarshack_bad_mpo_header.jpg\"\n        with pytest.warns(UserWarning, Image.open, fn) as im:\n            # Assert\n            assert im.format == \"JPEG\"\n\n    @pytest.mark.parametrize(\"mode\", (\"1\", \"L\", \"RGB\", \"RGBX\", \"CMYK\", \"YCbCr\"))\n    def test_save_correct_modes(self, mode: str) -> None:\n        out = BytesIO()\n        img = Image.new(mode, (20, 20))\n        img.save(out, \"JPEG\")\n\n    @pytest.mark.parametrize(\"mode\", (\"LA\", \"La\", \"RGBA\", \"RGBa\", \"P\"))\n    def test_save_wrong_modes(self, mode: str) -> None:\n        # ref https://github.com/python-pillow/Pillow/issues/2005\n        out = BytesIO()\n        img = Image.new(mode, (20, 20))\n        with pytest.raises(OSError):\n            img.save(out, \"JPEG\")\n\n    def test_save_tiff_with_dpi(self, tmp_path: Path) -> None:\n        # Arrange\n        outfile = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/hopper.tif\") as im:\n            # Act\n            im.save(outfile, \"JPEG\", dpi=im.info[\"dpi\"])\n\n            # Assert\n            with Image.open(outfile) as reloaded:\n                reloaded.load()\n                assert im.info[\"dpi\"] == reloaded.info[\"dpi\"]\n\n    def test_save_dpi_rounding(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.jpg\")\n        with Image.open(\"Tests/images/hopper.jpg\") as im:\n            im.save(outfile, dpi=(72.2, 72.2))\n\n            with Image.open(outfile) as reloaded:\n                assert reloaded.info[\"dpi\"] == (72, 72)\n\n            im.save(outfile, dpi=(72.8, 72.8))\n\n        with Image.open(outfile) as reloaded:\n            assert reloaded.info[\"dpi\"] == (73, 73)\n\n    def test_dpi_tuple_from_exif(self) -> None:\n        # Arrange\n        # This Photoshop CC 2017 image has DPI in EXIF not metadata\n        # EXIF XResolution is (2000000, 10000)\n        with Image.open(\"Tests/images/photoshop-200dpi.jpg\") as im:\n            # Act / Assert\n            assert im.info.get(\"dpi\") == (200, 200)\n\n    def test_dpi_int_from_exif(self) -> None:\n        # Arrange\n        # This image has DPI in EXIF not metadata\n        # EXIF XResolution is 72\n        with Image.open(\"Tests/images/exif-72dpi-int.jpg\") as im:\n            # Act / Assert\n            assert im.info.get(\"dpi\") == (72, 72)\n\n    def test_dpi_from_dpcm_exif(self) -> None:\n        # Arrange\n        # This is photoshop-200dpi.jpg with EXIF resolution unit set to cm:\n        # exiftool -exif:ResolutionUnit=cm photoshop-200dpi.jpg\n        with Image.open(\"Tests/images/exif-200dpcm.jpg\") as im:\n            # Act / Assert\n            assert im.info.get(\"dpi\") == (508, 508)\n\n    def test_dpi_exif_zero_division(self) -> None:\n        # Arrange\n        # This is photoshop-200dpi.jpg with EXIF resolution set to 0/0:\n        # exiftool -XResolution=0/0 -YResolution=0/0 photoshop-200dpi.jpg\n        with Image.open(\"Tests/images/exif-dpi-zerodivision.jpg\") as im:\n            # Act / Assert\n            # This should return the default, and not raise a ZeroDivisionError\n            assert im.info.get(\"dpi\") == (72, 72)\n\n    def test_dpi_exif_string(self) -> None:\n        # Arrange\n        # 0x011A tag in this exif contains string '300300\\x02'\n        with Image.open(\"Tests/images/broken_exif_dpi.jpg\") as im:\n            # Act / Assert\n            # This should return the default\n            assert im.info.get(\"dpi\") == (72, 72)\n\n    def test_dpi_exif_truncated(self) -> None:\n        # Arrange\n        with Image.open(\"Tests/images/truncated_exif_dpi.jpg\") as im:\n            # Act / Assert\n            # This should return the default\n            assert im.info.get(\"dpi\") == (72, 72)\n\n    def test_no_dpi_in_exif(self) -> None:\n        # Arrange\n        # This is photoshop-200dpi.jpg with resolution removed from EXIF:\n        # exiftool \"-*resolution*\"= photoshop-200dpi.jpg\n        with Image.open(\"Tests/images/no-dpi-in-exif.jpg\") as im:\n            # Act / Assert\n            # \"When the image resolution is unknown, 72 [dpi] is designated.\"\n            # https://web.archive.org/web/20240227115053/https://exiv2.org/tags.html\n            assert im.info.get(\"dpi\") == (72, 72)\n\n    def test_invalid_exif(self) -> None:\n        # This is no-dpi-in-exif with the tiff header of the exif block\n        # hexedited from MM * to FF FF FF FF\n        with Image.open(\"Tests/images/invalid-exif.jpg\") as im:\n            # This should return the default, and not a SyntaxError or\n            # OSError for unidentified image.\n            assert im.info.get(\"dpi\") == (72, 72)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_exif_x_resolution(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            exif = im.getexif()\n            assert exif[282] == 180\n\n            out = str(tmp_path / \"out.jpg\")\n            with warnings.catch_warnings():\n                im.save(out, exif=exif)\n\n        with Image.open(out) as reloaded:\n            assert reloaded.getexif()[282] == 180\n\n    def test_invalid_exif_x_resolution(self) -> None:\n        # When no x or y resolution is defined in EXIF\n        with Image.open(\"Tests/images/invalid-exif-without-x-resolution.jpg\") as im:\n            # This should return the default, and not a ValueError or\n            # OSError for an unidentified image.\n            assert im.info.get(\"dpi\") == (72, 72)\n\n    def test_ifd_offset_exif(self) -> None:\n        # Arrange\n        # This image has been manually hexedited to have an IFD offset of 10,\n        # in contrast to normal 8\n        with Image.open(\"Tests/images/exif-ifd-offset.jpg\") as im:\n            # Act / Assert\n            assert im._getexif()[306] == \"2017:03:13 23:03:09\"\n\n    def test_multiple_exif(self) -> None:\n        with Image.open(\"Tests/images/multiple_exif.jpg\") as im:\n            assert im.info[\"exif\"] == b\"Exif\\x00\\x00firstsecond\"\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_photoshop(self) -> None:\n        with Image.open(\"Tests/images/photoshop-200dpi.jpg\") as im:\n            assert im.info[\"photoshop\"][0x03ED] == {\n                \"XResolution\": 200.0,\n                \"DisplayedUnitsX\": 1,\n                \"YResolution\": 200.0,\n                \"DisplayedUnitsY\": 1,\n            }\n\n            # Test that the image can still load, even with broken Photoshop data\n            # This image had the APP13 length hexedited to be smaller\n            assert_image_equal_tofile(im, \"Tests/images/photoshop-200dpi-broken.jpg\")\n\n        # This image does not contain a Photoshop header string\n        with Image.open(\"Tests/images/app13.jpg\") as im:\n            assert \"photoshop\" not in im.info\n\n    def test_photoshop_malformed_and_multiple(self) -> None:\n        with Image.open(\"Tests/images/app13-multiple.jpg\") as im:\n            assert \"photoshop\" in im.info\n            assert 24 == len(im.info[\"photoshop\"])\n            apps_13_lengths = [len(v) for k, v in im.applist if k == \"APP13\"]\n            assert [65504, 24] == apps_13_lengths\n\n    def test_adobe_transform(self) -> None:\n        with Image.open(\"Tests/images/pil_sample_rgb.jpg\") as im:\n            assert im.info[\"adobe_transform\"] == 1\n\n        with Image.open(\"Tests/images/pil_sample_cmyk.jpg\") as im:\n            assert im.info[\"adobe_transform\"] == 2\n\n        # This image has been manually hexedited\n        # so that the APP14 reports its length to be 11,\n        # leaving no room for \"adobe_transform\"\n        with Image.open(\"Tests/images/truncated_app14.jpg\") as im:\n            assert \"adobe\" in im.info\n            assert \"adobe_transform\" not in im.info\n\n    def test_icc_after_SOF(self) -> None:\n        with Image.open(\"Tests/images/icc-after-SOF.jpg\") as im:\n            assert im.info[\"icc_profile\"] == b\"profile\"\n\n    def test_jpeg_magic_number(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        size = 4097\n        buffer = BytesIO(b\"\\xFF\" * size)  # Many xFF bytes\n        max_pos = 0\n        orig_read = buffer.read\n\n        def read(n: int | None = -1) -> bytes:\n            nonlocal max_pos\n            res = orig_read(n)\n            max_pos = max(max_pos, buffer.tell())\n            return res\n\n        monkeypatch.setattr(buffer, \"read\", read)\n        with pytest.raises(UnidentifiedImageError):\n            with Image.open(buffer):\n                pass\n\n        # Assert the entire file has not been read\n        assert 0 < max_pos < size\n\n    def test_getxmp(self) -> None:\n        with Image.open(\"Tests/images/xmp_test.jpg\") as im:\n            if ElementTree is None:\n                with pytest.warns(\n                    UserWarning,\n                    match=\"XMP data cannot be read without defusedxml dependency\",\n                ):\n                    assert im.getxmp() == {}\n            else:\n                assert \"xmp\" in im.info\n                xmp = im.getxmp()\n\n                description = xmp[\"xmpmeta\"][\"RDF\"][\"Description\"]\n                assert description[\"DerivedFrom\"] == {\n                    \"documentID\": \"8367D410E636EA95B7DE7EBA1C43A412\",\n                    \"originalDocumentID\": \"8367D410E636EA95B7DE7EBA1C43A412\",\n                }\n                assert description[\"Look\"][\"Description\"][\"Group\"][\"Alt\"][\"li\"] == {\n                    \"lang\": \"x-default\",\n                    \"text\": \"Profiles\",\n                }\n                assert description[\"ToneCurve\"][\"Seq\"][\"li\"] == [\"0, 0\", \"255, 255\"]\n\n                # Attribute\n                assert description[\"Version\"] == \"10.4\"\n\n        if ElementTree is not None:\n            with Image.open(\"Tests/images/hopper.jpg\") as im:\n                assert im.getxmp() == {}\n\n    def test_getxmp_no_prefix(self) -> None:\n        with Image.open(\"Tests/images/xmp_no_prefix.jpg\") as im:\n            if ElementTree is None:\n                with pytest.warns(\n                    UserWarning,\n                    match=\"XMP data cannot be read without defusedxml dependency\",\n                ):\n                    assert im.getxmp() == {}\n            else:\n                assert im.getxmp() == {\"xmpmeta\": {\"key\": \"value\"}}\n\n    def test_getxmp_padded(self) -> None:\n        with Image.open(\"Tests/images/xmp_padded.jpg\") as im:\n            if ElementTree is None:\n                with pytest.warns(\n                    UserWarning,\n                    match=\"XMP data cannot be read without defusedxml dependency\",\n                ):\n                    assert im.getxmp() == {}\n            else:\n                assert im.getxmp() == {\"xmpmeta\": None}\n\n    @pytest.mark.timeout(timeout=1)\n    def test_eof(self) -> None:\n        # Even though this decoder never says that it is finished\n        # the image should still end when there is no new data\n        class InfiniteMockPyDecoder(ImageFile.PyDecoder):\n            def decode(self, buffer: bytes) -> tuple[int, int]:\n                return 0, 0\n\n        Image.register_decoder(\"INFINITE\", InfiniteMockPyDecoder)\n\n        with Image.open(TEST_FILE) as im:\n            im.tile = [\n                (\"INFINITE\", (0, 0, 128, 128), 0, (\"RGB\", 0, 1)),\n            ]\n            ImageFile.LOAD_TRUNCATED_IMAGES = True\n            im.load()\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    def test_separate_tables(self) -> None:\n        im = hopper()\n        data = []  # [interchange, tables-only, image-only]\n        for streamtype in range(3):\n            out = BytesIO()\n            im.save(out, format=\"JPEG\", streamtype=streamtype)\n            data.append(out.getvalue())\n\n        # SOI, EOI\n        for marker in b\"\\xff\\xd8\", b\"\\xff\\xd9\":\n            assert marker in data[1] and marker in data[2]\n        # DHT, DQT\n        for marker in b\"\\xff\\xc4\", b\"\\xff\\xdb\":\n            assert marker in data[1] and marker not in data[2]\n        # SOF0, SOS, APP0 (JFIF header)\n        for marker in b\"\\xff\\xc0\", b\"\\xff\\xda\", b\"\\xff\\xe0\":\n            assert marker not in data[1] and marker in data[2]\n\n        with Image.open(BytesIO(data[0])) as interchange_im:\n            with Image.open(BytesIO(data[1] + data[2])) as combined_im:\n                assert_image_equal(interchange_im, combined_im)\n\n    def test_repr_jpeg(self) -> None:\n        im = hopper()\n        b = im._repr_jpeg_()\n        assert b is not None\n\n        with Image.open(BytesIO(b)) as repr_jpeg:\n            assert repr_jpeg.format == \"JPEG\"\n            assert_image_similar(im, repr_jpeg, 17)\n\n    def test_repr_jpeg_error_returns_none(self) -> None:\n        im = hopper(\"F\")\n\n        assert im._repr_jpeg_() is None\n\n\n@pytest.mark.skipif(not is_win32(), reason=\"Windows only\")\n@skip_unless_feature(\"jpg\")\nclass TestFileCloseW32:\n    def test_fd_leak(self, tmp_path: Path) -> None:\n        tmpfile = str(tmp_path / \"temp.jpg\")\n\n        with Image.open(\"Tests/images/hopper.jpg\") as im:\n            im.save(tmpfile)\n\n        im = Image.open(tmpfile)\n        fp = im.fp\n        assert not fp.closed\n        with pytest.raises(OSError):\n            os.remove(tmpfile)\n        im.load()\n        assert fp.closed\n        # this should not fail, as load should have closed the file.\n        os.remove(tmpfile)\n", "Tests/test_image_point.py": "from __future__ import annotations\n\nimport pytest\n\nfrom .helper import assert_image_equal, hopper\n\n\ndef test_sanity() -> None:\n    im = hopper()\n\n    with pytest.raises(ValueError):\n        im.point(list(range(256)))\n    im.point(list(range(256)) * 3)\n    im.point(lambda x: x)\n    im.point(lambda x: x * 1.2)\n\n    im = im.convert(\"I\")\n    with pytest.raises(ValueError):\n        im.point(list(range(256)))\n    im.point(lambda x: x * 1)\n    im.point(lambda x: x + 1)\n    im.point(lambda x: x - 1)\n    im.point(lambda x: x * 1 + 1)\n    im.point(lambda x: 0.1 + 0.2 * x)\n    im.point(lambda x: -x)\n    im.point(lambda x: x - 0.5)\n    im.point(lambda x: 1 - x / 2)\n    im.point(lambda x: (2 + x) / 3)\n    im.point(lambda x: 0.5)\n    im.point(lambda x: x / 1)\n    im.point(lambda x: x + x)\n    with pytest.raises(TypeError):\n        im.point(lambda x: x * x)\n    with pytest.raises(TypeError):\n        im.point(lambda x: x / x)\n    with pytest.raises(TypeError):\n        im.point(lambda x: 1 / x)\n    with pytest.raises(TypeError):\n        im.point(lambda x: x // 2)\n\n\ndef test_16bit_lut() -> None:\n    \"\"\"Tests for 16 bit -> 8 bit lut for converting I->L images\n    see https://github.com/python-pillow/Pillow/issues/440\n    \"\"\"\n    im = hopper(\"I\")\n    im.point(list(range(256)) * 256, \"L\")\n\n\ndef test_f_lut() -> None:\n    \"\"\"Tests for floating point lut of 8bit gray image\"\"\"\n    im = hopper(\"L\")\n    lut = [0.5 * float(x) for x in range(256)]\n\n    out = im.point(lut, \"F\")\n\n    int_lut = [x // 2 for x in range(256)]\n    assert_image_equal(out.convert(\"L\"), im.point(int_lut, \"L\"))\n\n\ndef test_f_mode() -> None:\n    im = hopper(\"F\")\n    with pytest.raises(ValueError):\n        im.point([])\n", "Tests/test_color_lut.py": "from __future__ import annotations\n\nfrom array import array\nfrom types import ModuleType\n\nimport pytest\n\nfrom PIL import Image, ImageFilter\n\nfrom .helper import assert_image_equal\n\nnumpy: ModuleType | None\ntry:\n    import numpy\nexcept ImportError:\n    numpy = None\n\n\nclass TestColorLut3DCoreAPI:\n    def generate_identity_table(\n        self, channels: int, size: int | tuple[int, int, int]\n    ) -> tuple[int, int, int, int, list[float]]:\n        if isinstance(size, tuple):\n            size_1d, size_2d, size_3d = size\n        else:\n            size_1d, size_2d, size_3d = (size, size, size)\n\n        table = [\n            [\n                r / (size_1d - 1) if size_1d != 1 else 0,\n                g / (size_2d - 1) if size_2d != 1 else 0,\n                b / (size_3d - 1) if size_3d != 1 else 0,\n                r / (size_1d - 1) if size_1d != 1 else 0,\n                g / (size_2d - 1) if size_2d != 1 else 0,\n            ][:channels]\n            for b in range(size_3d)\n            for g in range(size_2d)\n            for r in range(size_1d)\n        ]\n        return (\n            channels,\n            size_1d,\n            size_2d,\n            size_3d,\n            [item for sublist in table for item in sublist],\n        )\n\n    def test_wrong_args(self) -> None:\n        im = Image.new(\"RGB\", (10, 10), 0)\n\n        with pytest.raises(ValueError, match=\"filter\"):\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BICUBIC, *self.generate_identity_table(3, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"image mode\"):\n            im.im.color_lut_3d(\n                \"wrong\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"table_channels\"):\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, *self.generate_identity_table(5, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"table_channels\"):\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, *self.generate_identity_table(1, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"table_channels\"):\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, *self.generate_identity_table(2, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"Table size\"):\n            im.im.color_lut_3d(\n                \"RGB\",\n                Image.Resampling.BILINEAR,\n                *self.generate_identity_table(3, (1, 3, 3)),\n            )\n\n        with pytest.raises(ValueError, match=\"Table size\"):\n            im.im.color_lut_3d(\n                \"RGB\",\n                Image.Resampling.BILINEAR,\n                *self.generate_identity_table(3, (66, 3, 3)),\n            )\n\n        with pytest.raises(ValueError, match=r\"size1D \\* size2D \\* size3D\"):\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, 0] * 7\n            )\n\n        with pytest.raises(ValueError, match=r\"size1D \\* size2D \\* size3D\"):\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, 0] * 9\n            )\n\n        with pytest.raises(TypeError):\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, 3, 2, 2, 2, [0, 0, \"0\"] * 8\n            )\n\n        with pytest.raises(TypeError):\n            im.im.color_lut_3d(\"RGB\", Image.Resampling.BILINEAR, 3, 2, 2, 2, 16)\n\n    def test_correct_args(self) -> None:\n        im = Image.new(\"RGB\", (10, 10), 0)\n\n        im.im.color_lut_3d(\n            \"RGB\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n        )\n\n        im.im.color_lut_3d(\n            \"CMYK\", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)\n        )\n\n        im.im.color_lut_3d(\n            \"RGB\",\n            Image.Resampling.BILINEAR,\n            *self.generate_identity_table(3, (2, 3, 3)),\n        )\n\n        im.im.color_lut_3d(\n            \"RGB\",\n            Image.Resampling.BILINEAR,\n            *self.generate_identity_table(3, (65, 3, 3)),\n        )\n\n        im.im.color_lut_3d(\n            \"RGB\",\n            Image.Resampling.BILINEAR,\n            *self.generate_identity_table(3, (3, 65, 3)),\n        )\n\n        im.im.color_lut_3d(\n            \"RGB\",\n            Image.Resampling.BILINEAR,\n            *self.generate_identity_table(3, (3, 3, 65)),\n        )\n\n    def test_wrong_mode(self) -> None:\n        with pytest.raises(ValueError, match=\"wrong mode\"):\n            im = Image.new(\"L\", (10, 10), 0)\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"wrong mode\"):\n            im = Image.new(\"RGB\", (10, 10), 0)\n            im.im.color_lut_3d(\n                \"L\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"wrong mode\"):\n            im = Image.new(\"L\", (10, 10), 0)\n            im.im.color_lut_3d(\n                \"L\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"wrong mode\"):\n            im = Image.new(\"RGB\", (10, 10), 0)\n            im.im.color_lut_3d(\n                \"RGBA\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n            )\n\n        with pytest.raises(ValueError, match=\"wrong mode\"):\n            im = Image.new(\"RGB\", (10, 10), 0)\n            im.im.color_lut_3d(\n                \"RGB\", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)\n            )\n\n    def test_correct_mode(self) -> None:\n        im = Image.new(\"RGBA\", (10, 10), 0)\n        im.im.color_lut_3d(\n            \"RGBA\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n        )\n\n        im = Image.new(\"RGBA\", (10, 10), 0)\n        im.im.color_lut_3d(\n            \"RGBA\", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)\n        )\n\n        im = Image.new(\"RGB\", (10, 10), 0)\n        im.im.color_lut_3d(\n            \"HSV\", Image.Resampling.BILINEAR, *self.generate_identity_table(3, 3)\n        )\n\n        im = Image.new(\"RGB\", (10, 10), 0)\n        im.im.color_lut_3d(\n            \"RGBA\", Image.Resampling.BILINEAR, *self.generate_identity_table(4, 3)\n        )\n\n    def test_identities(self) -> None:\n        g = Image.linear_gradient(\"L\")\n        im = Image.merge(\n            \"RGB\",\n            [\n                g,\n                g.transpose(Image.Transpose.ROTATE_90),\n                g.transpose(Image.Transpose.ROTATE_180),\n            ],\n        )\n\n        # Fast test with small cubes\n        for size in [2, 3, 5, 7, 11, 16, 17]:\n            assert_image_equal(\n                im,\n                im._new(\n                    im.im.color_lut_3d(\n                        \"RGB\",\n                        Image.Resampling.BILINEAR,\n                        *self.generate_identity_table(3, size),\n                    )\n                ),\n            )\n\n        # Not so fast\n        assert_image_equal(\n            im,\n            im._new(\n                im.im.color_lut_3d(\n                    \"RGB\",\n                    Image.Resampling.BILINEAR,\n                    *self.generate_identity_table(3, (2, 2, 65)),\n                )\n            ),\n        )\n\n    def test_identities_4_channels(self) -> None:\n        g = Image.linear_gradient(\"L\")\n        im = Image.merge(\n            \"RGB\",\n            [\n                g,\n                g.transpose(Image.Transpose.ROTATE_90),\n                g.transpose(Image.Transpose.ROTATE_180),\n            ],\n        )\n\n        # Red channel copied to alpha\n        assert_image_equal(\n            Image.merge(\"RGBA\", (im.split() * 2)[:4]),\n            im._new(\n                im.im.color_lut_3d(\n                    \"RGBA\",\n                    Image.Resampling.BILINEAR,\n                    *self.generate_identity_table(4, 17),\n                )\n            ),\n        )\n\n    def test_copy_alpha_channel(self) -> None:\n        g = Image.linear_gradient(\"L\")\n        im = Image.merge(\n            \"RGBA\",\n            [\n                g,\n                g.transpose(Image.Transpose.ROTATE_90),\n                g.transpose(Image.Transpose.ROTATE_180),\n                g.transpose(Image.Transpose.ROTATE_270),\n            ],\n        )\n\n        assert_image_equal(\n            im,\n            im._new(\n                im.im.color_lut_3d(\n                    \"RGBA\",\n                    Image.Resampling.BILINEAR,\n                    *self.generate_identity_table(3, 17),\n                )\n            ),\n        )\n\n    def test_channels_order(self) -> None:\n        g = Image.linear_gradient(\"L\")\n        im = Image.merge(\n            \"RGB\",\n            [\n                g,\n                g.transpose(Image.Transpose.ROTATE_90),\n                g.transpose(Image.Transpose.ROTATE_180),\n            ],\n        )\n\n        # Reverse channels by splitting and using table\n        # fmt: off\n        assert_image_equal(\n            Image.merge('RGB', im.split()[::-1]),\n            im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,\n                    3, 2, 2, 2, [\n                        0, 0, 0,  0, 0, 1,\n                        0, 1, 0,  0, 1, 1,\n\n                        1, 0, 0,  1, 0, 1,\n                        1, 1, 0,  1, 1, 1,\n                    ])))\n        # fmt: on\n\n    def test_overflow(self) -> None:\n        g = Image.linear_gradient(\"L\")\n        im = Image.merge(\n            \"RGB\",\n            [\n                g,\n                g.transpose(Image.Transpose.ROTATE_90),\n                g.transpose(Image.Transpose.ROTATE_180),\n            ],\n        )\n\n        # fmt: off\n        transformed = im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,\n                              3, 2, 2, 2,\n                              [\n                                  -1, -1, -1,   2, -1, -1,\n                                  -1,  2, -1,   2,  2, -1,\n\n                                  -1, -1,  2,   2, -1,  2,\n                                  -1,  2,  2,   2,  2,  2,\n                              ])).load()\n        # fmt: on\n        assert transformed[0, 0] == (0, 0, 255)\n        assert transformed[50, 50] == (0, 0, 255)\n        assert transformed[255, 0] == (0, 255, 255)\n        assert transformed[205, 50] == (0, 255, 255)\n        assert transformed[0, 255] == (255, 0, 0)\n        assert transformed[50, 205] == (255, 0, 0)\n        assert transformed[255, 255] == (255, 255, 0)\n        assert transformed[205, 205] == (255, 255, 0)\n\n        # fmt: off\n        transformed = im._new(im.im.color_lut_3d('RGB', Image.Resampling.BILINEAR,\n                              3, 2, 2, 2,\n                              [\n                                  -3, -3, -3,   5, -3, -3,\n                                  -3,  5, -3,   5,  5, -3,\n\n                                  -3, -3,  5,   5, -3,  5,\n                                  -3,  5,  5,   5,  5,  5,\n                              ])).load()\n        # fmt: on\n        assert transformed[0, 0] == (0, 0, 255)\n        assert transformed[50, 50] == (0, 0, 255)\n        assert transformed[255, 0] == (0, 255, 255)\n        assert transformed[205, 50] == (0, 255, 255)\n        assert transformed[0, 255] == (255, 0, 0)\n        assert transformed[50, 205] == (255, 0, 0)\n        assert transformed[255, 255] == (255, 255, 0)\n        assert transformed[205, 205] == (255, 255, 0)\n\n\nclass TestColorLut3DFilter:\n    def test_wrong_args(self) -> None:\n        with pytest.raises(ValueError, match=\"should be either an integer\"):\n            ImageFilter.Color3DLUT(\"small\", [1])  # type: ignore[arg-type]\n\n        with pytest.raises(ValueError, match=\"should be either an integer\"):\n            ImageFilter.Color3DLUT((11, 11), [1])  # type: ignore[arg-type]\n\n        with pytest.raises(ValueError, match=r\"in \\[2, 65\\] range\"):\n            ImageFilter.Color3DLUT((11, 11, 1), [1])\n\n        with pytest.raises(ValueError, match=r\"in \\[2, 65\\] range\"):\n            ImageFilter.Color3DLUT((11, 11, 66), [1])\n\n        with pytest.raises(ValueError, match=\"table should have .+ items\"):\n            ImageFilter.Color3DLUT((3, 3, 3), [1, 1, 1])\n\n        with pytest.raises(ValueError, match=\"table should have .+ items\"):\n            ImageFilter.Color3DLUT((3, 3, 3), [[1, 1, 1]] * 2)\n\n        with pytest.raises(ValueError, match=\"should have a length of 4\"):\n            ImageFilter.Color3DLUT((3, 3, 3), [[1, 1, 1]] * 27, channels=4)\n\n        with pytest.raises(ValueError, match=\"should have a length of 3\"):\n            ImageFilter.Color3DLUT((2, 2, 2), [[1, 1]] * 8)\n\n        with pytest.raises(ValueError, match=\"Only 3 or 4 output\"):\n            ImageFilter.Color3DLUT((2, 2, 2), [[1, 1]] * 8, channels=2)\n\n    def test_convert_table(self) -> None:\n        lut = ImageFilter.Color3DLUT(2, [0, 1, 2] * 8)\n        assert tuple(lut.size) == (2, 2, 2)\n        assert lut.name == \"Color 3D LUT\"\n\n        # fmt: off\n        lut = ImageFilter.Color3DLUT((2, 2, 2), [\n            (0, 1, 2), (3, 4, 5), (6, 7, 8), (9, 10, 11),\n            (12, 13, 14), (15, 16, 17), (18, 19, 20), (21, 22, 23)])\n        # fmt: on\n        assert tuple(lut.size) == (2, 2, 2)\n        assert lut.table == list(range(24))\n\n        lut = ImageFilter.Color3DLUT((2, 2, 2), [(0, 1, 2, 3)] * 8, channels=4)\n        assert tuple(lut.size) == (2, 2, 2)\n        assert lut.table == list(range(4)) * 8\n\n    @pytest.mark.skipif(numpy is None, reason=\"NumPy not installed\")\n    def test_numpy_sources(self) -> None:\n        assert numpy is not None\n        table = numpy.ones((5, 6, 7, 3), dtype=numpy.float16)\n        with pytest.raises(ValueError, match=\"should have either channels\"):\n            lut = ImageFilter.Color3DLUT((5, 6, 7), table)\n\n        table = numpy.ones((7, 6, 5, 3), dtype=numpy.float16)\n        lut = ImageFilter.Color3DLUT((5, 6, 7), table)\n        assert isinstance(lut.table, numpy.ndarray)\n        assert lut.table.dtype == table.dtype\n        assert lut.table.shape == (table.size,)\n\n        table = numpy.ones((7 * 6 * 5, 3), dtype=numpy.float16)\n        lut = ImageFilter.Color3DLUT((5, 6, 7), table)\n        assert lut.table.shape == (table.size,)\n\n        table = numpy.ones((7 * 6 * 5 * 3), dtype=numpy.float16)\n        lut = ImageFilter.Color3DLUT((5, 6, 7), table)\n        assert lut.table.shape == (table.size,)\n\n        # Check application\n        Image.new(\"RGB\", (10, 10), 0).filter(lut)\n\n        # Check copy\n        table[0] = 33\n        assert lut.table[0] == 1\n\n        # Check not copy\n        table = numpy.ones((7 * 6 * 5 * 3), dtype=numpy.float16)\n        lut = ImageFilter.Color3DLUT((5, 6, 7), table, _copy_table=False)\n        table[0] = 33\n        assert lut.table[0] == 33\n\n    @pytest.mark.skipif(numpy is None, reason=\"NumPy not installed\")\n    def test_numpy_formats(self) -> None:\n        assert numpy is not None\n        g = Image.linear_gradient(\"L\")\n        im = Image.merge(\n            \"RGB\",\n            [\n                g,\n                g.transpose(Image.Transpose.ROTATE_90),\n                g.transpose(Image.Transpose.ROTATE_180),\n            ],\n        )\n\n        lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))\n        lut.table = numpy.array(lut.table, dtype=numpy.float32)[:-1]\n        with pytest.raises(ValueError, match=\"should have table_channels\"):\n            im.filter(lut)\n\n        lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))\n        lut.table = numpy.array(lut.table, dtype=numpy.float32).reshape((7 * 9 * 11), 3)\n        with pytest.raises(ValueError, match=\"should have table_channels\"):\n            im.filter(lut)\n\n        lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))\n        lut.table = numpy.array(lut.table, dtype=numpy.float16)\n        assert_image_equal(im, im.filter(lut))\n\n        lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))\n        lut.table = numpy.array(lut.table, dtype=numpy.float32)\n        assert_image_equal(im, im.filter(lut))\n\n        lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))\n        lut.table = numpy.array(lut.table, dtype=numpy.float64)\n        assert_image_equal(im, im.filter(lut))\n\n        lut = ImageFilter.Color3DLUT.generate((7, 9, 11), lambda r, g, b: (r, g, b))\n        lut.table = numpy.array(lut.table, dtype=numpy.int32)\n        im.filter(lut)\n        lut.table = numpy.array(lut.table, dtype=numpy.int8)\n        im.filter(lut)\n\n    def test_repr(self) -> None:\n        lut = ImageFilter.Color3DLUT(2, [0, 1, 2] * 8)\n        assert repr(lut) == \"<Color3DLUT from list size=2x2x2 channels=3>\"\n\n        lut = ImageFilter.Color3DLUT(\n            (3, 4, 5),\n            array(\"f\", [0, 0, 0, 0] * (3 * 4 * 5)),\n            channels=4,\n            target_mode=\"YCbCr\",\n            _copy_table=False,\n        )\n        assert (\n            repr(lut)\n            == \"<Color3DLUT from array size=3x4x5 channels=4 target_mode=YCbCr>\"\n        )\n\n\nclass TestGenerateColorLut3D:\n    def test_wrong_channels_count(self) -> None:\n        with pytest.raises(ValueError, match=\"3 or 4 output channels\"):\n            ImageFilter.Color3DLUT.generate(\n                5, channels=2, callback=lambda r, g, b: (r, g, b)\n            )\n\n        with pytest.raises(ValueError, match=\"should have either channels\"):\n            ImageFilter.Color3DLUT.generate(5, lambda r, g, b: (r, g, b, r))\n\n        with pytest.raises(ValueError, match=\"should have either channels\"):\n            ImageFilter.Color3DLUT.generate(\n                5, channels=4, callback=lambda r, g, b: (r, g, b)\n            )\n\n    def test_3_channels(self) -> None:\n        lut = ImageFilter.Color3DLUT.generate(5, lambda r, g, b: (r, g, b))\n        assert tuple(lut.size) == (5, 5, 5)\n        assert lut.name == \"Color 3D LUT\"\n        # fmt: off\n        assert lut.table[:24] == [\n            0.0, 0.0, 0.0,  0.25, 0.0, 0.0,  0.5, 0.0, 0.0,  0.75, 0.0, 0.0,\n            1.0, 0.0, 0.0,  0.0, 0.25, 0.0,  0.25, 0.25, 0.0,  0.5, 0.25, 0.0]\n        # fmt: on\n\n    def test_4_channels(self) -> None:\n        lut = ImageFilter.Color3DLUT.generate(\n            5, channels=4, callback=lambda r, g, b: (b, r, g, (r + g + b) / 2)\n        )\n        assert tuple(lut.size) == (5, 5, 5)\n        assert lut.name == \"Color 3D LUT\"\n        # fmt: off\n        assert lut.table[:24] == [\n            0.0, 0.0, 0.0, 0.0,  0.0, 0.25, 0.0, 0.125,  0.0, 0.5, 0.0, 0.25,\n            0.0, 0.75, 0.0, 0.375,  0.0, 1.0, 0.0, 0.5,  0.0, 0.0, 0.25, 0.125\n        ]\n        # fmt: on\n\n    def test_apply(self) -> None:\n        lut = ImageFilter.Color3DLUT.generate(5, lambda r, g, b: (r, g, b))\n\n        g = Image.linear_gradient(\"L\")\n        im = Image.merge(\n            \"RGB\",\n            [\n                g,\n                g.transpose(Image.Transpose.ROTATE_90),\n                g.transpose(Image.Transpose.ROTATE_180),\n            ],\n        )\n        assert im == im.filter(lut)\n\n\nclass TestTransformColorLut3D:\n    def test_wrong_args(self) -> None:\n        source = ImageFilter.Color3DLUT.generate(5, lambda r, g, b: (r, g, b))\n\n        with pytest.raises(ValueError, match=\"Only 3 or 4 output\"):\n            source.transform(lambda r, g, b: (r, g, b), channels=8)\n\n        with pytest.raises(ValueError, match=\"should have either channels\"):\n            source.transform(lambda r, g, b: (r, g, b), channels=4)\n\n        with pytest.raises(ValueError, match=\"should have either channels\"):\n            source.transform(lambda r, g, b: (r, g, b, 1))\n\n        with pytest.raises(TypeError):\n            source.transform(lambda r, g, b, a: (r, g, b))\n\n    def test_target_mode(self) -> None:\n        source = ImageFilter.Color3DLUT.generate(\n            2, lambda r, g, b: (r, g, b), target_mode=\"HSV\"\n        )\n\n        lut = source.transform(lambda r, g, b: (r, g, b))\n        assert lut.mode == \"HSV\"\n\n        lut = source.transform(lambda r, g, b: (r, g, b), target_mode=\"RGB\")\n        assert lut.mode == \"RGB\"\n\n    def test_3_to_3_channels(self) -> None:\n        source = ImageFilter.Color3DLUT.generate((3, 4, 5), lambda r, g, b: (r, g, b))\n        lut = source.transform(lambda r, g, b: (r * r, g * g, b * b))\n        assert tuple(lut.size) == tuple(source.size)\n        assert len(lut.table) == len(source.table)\n        assert lut.table != source.table\n        assert lut.table[:10] == [0.0, 0.0, 0.0, 0.25, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0]\n\n    def test_3_to_4_channels(self) -> None:\n        source = ImageFilter.Color3DLUT.generate((6, 5, 4), lambda r, g, b: (r, g, b))\n        lut = source.transform(lambda r, g, b: (r * r, g * g, b * b, 1), channels=4)\n        assert tuple(lut.size) == tuple(source.size)\n        assert len(lut.table) != len(source.table)\n        assert lut.table != source.table\n        # fmt: off\n        assert lut.table[:16] == [\n            0.0, 0.0, 0.0, 1,  0.2**2, 0.0, 0.0, 1,\n            0.4**2, 0.0, 0.0, 1,  0.6**2, 0.0, 0.0, 1]\n        # fmt: on\n\n    def test_4_to_3_channels(self) -> None:\n        source = ImageFilter.Color3DLUT.generate(\n            (3, 6, 5), lambda r, g, b: (r, g, b, 1), channels=4\n        )\n        lut = source.transform(\n            lambda r, g, b, a: (a - r * r, a - g * g, a - b * b), channels=3\n        )\n        assert tuple(lut.size) == tuple(source.size)\n        assert len(lut.table) != len(source.table)\n        assert lut.table != source.table\n        # fmt: off\n        assert lut.table[:18] == [\n            1.0, 1.0, 1.0,  0.75, 1.0, 1.0,  0.0, 1.0, 1.0,\n            1.0, 0.96, 1.0,  0.75, 0.96, 1.0,  0.0, 0.96, 1.0]\n        # fmt: on\n\n    def test_4_to_4_channels(self) -> None:\n        source = ImageFilter.Color3DLUT.generate(\n            (6, 5, 4), lambda r, g, b: (r, g, b, 1), channels=4\n        )\n        lut = source.transform(lambda r, g, b, a: (r * r, g * g, b * b, a - 0.5))\n        assert tuple(lut.size) == tuple(source.size)\n        assert len(lut.table) == len(source.table)\n        assert lut.table != source.table\n        # fmt: off\n        assert lut.table[:16] == [\n            0.0, 0.0, 0.0, 0.5,  0.2**2, 0.0, 0.0, 0.5,\n            0.4**2, 0.0, 0.0, 0.5,  0.6**2, 0.0, 0.0, 0.5]\n        # fmt: on\n\n    def test_with_normals_3_channels(self) -> None:\n        source = ImageFilter.Color3DLUT.generate(\n            (6, 5, 4), lambda r, g, b: (r * r, g * g, b * b)\n        )\n        lut = source.transform(\n            lambda nr, ng, nb, r, g, b: (nr - r, ng - g, nb - b), with_normals=True\n        )\n        assert tuple(lut.size) == tuple(source.size)\n        assert len(lut.table) == len(source.table)\n        assert lut.table != source.table\n        # fmt: off\n        assert lut.table[:18] == [\n            0.0, 0.0, 0.0,  0.16, 0.0, 0.0,  0.24, 0.0, 0.0,\n            0.24, 0.0, 0.0,  0.8 - (0.8**2), 0, 0,  0, 0, 0]\n        # fmt: on\n\n    def test_with_normals_4_channels(self) -> None:\n        source = ImageFilter.Color3DLUT.generate(\n            (3, 6, 5), lambda r, g, b: (r * r, g * g, b * b, 1), channels=4\n        )\n        lut = source.transform(\n            lambda nr, ng, nb, r, g, b, a: (nr - r, ng - g, nb - b, a - 0.5),\n            with_normals=True,\n        )\n        assert tuple(lut.size) == tuple(source.size)\n        assert len(lut.table) == len(source.table)\n        assert lut.table != source.table\n        # fmt: off\n        assert lut.table[:16] == [\n            0.0, 0.0, 0.0, 0.5,  0.25, 0.0, 0.0, 0.5,\n            0.0, 0.0, 0.0, 0.5,  0.0, 0.16, 0.0, 0.5]\n        # fmt: on\n", "Tests/test_image_transform.py": "from __future__ import annotations\n\nimport math\nfrom typing import Callable\n\nimport pytest\n\nfrom PIL import Image, ImageTransform\n\nfrom .helper import assert_image_equal, assert_image_similar, hopper\n\n\nclass TestImageTransform:\n    def test_sanity(self) -> None:\n        im = hopper()\n\n        for transform in (\n            ImageTransform.AffineTransform((1, 0, 0, 0, 1, 0)),\n            ImageTransform.PerspectiveTransform((1, 0, 0, 0, 1, 0, 0, 0)),\n            ImageTransform.ExtentTransform((0, 0) + im.size),\n            ImageTransform.QuadTransform(\n                (0, 0, 0, im.height, im.width, im.height, im.width, 0)\n            ),\n            ImageTransform.MeshTransform(\n                [\n                    (\n                        (0, 0) + im.size,\n                        (0, 0, 0, im.height, im.width, im.height, im.width, 0),\n                    )\n                ]\n            ),\n        ):\n            assert_image_equal(im, im.transform(im.size, transform))\n\n    def test_info(self) -> None:\n        comment = b\"File written by Adobe Photoshop\\xa8 4.0\"\n\n        with Image.open(\"Tests/images/hopper.gif\") as im:\n            assert im.info[\"comment\"] == comment\n\n            transform = ImageTransform.ExtentTransform((0, 0, 0, 0))\n            new_im = im.transform((100, 100), transform)\n        assert new_im.info[\"comment\"] == comment\n\n    def test_palette(self) -> None:\n        with Image.open(\"Tests/images/hopper.gif\") as im:\n            transformed = im.transform(\n                im.size, Image.Transform.AFFINE, [1, 0, 0, 0, 1, 0]\n            )\n            assert im.palette.palette == transformed.palette.palette\n\n    def test_extent(self) -> None:\n        im = hopper(\"RGB\")\n        (w, h) = im.size\n        transformed = im.transform(\n            im.size,\n            Image.Transform.EXTENT,\n            (0, 0, w // 2, h // 2),  # ul -> lr\n            Image.Resampling.BILINEAR,\n        )\n\n        scaled = im.resize((w * 2, h * 2), Image.Resampling.BILINEAR).crop((0, 0, w, h))\n\n        # undone -- precision?\n        assert_image_similar(transformed, scaled, 23)\n\n    def test_quad(self) -> None:\n        # one simple quad transform, equivalent to scale & crop upper left quad\n        im = hopper(\"RGB\")\n        (w, h) = im.size\n        transformed = im.transform(\n            im.size,\n            Image.Transform.QUAD,\n            (0, 0, 0, h // 2, w // 2, h // 2, w // 2, 0),  # ul -> ccw around quad\n            Image.Resampling.BILINEAR,\n        )\n\n        scaled = im.transform(\n            (w, h),\n            Image.Transform.AFFINE,\n            (0.5, 0, 0, 0, 0.5, 0),\n            Image.Resampling.BILINEAR,\n        )\n\n        assert_image_equal(transformed, scaled)\n\n    @pytest.mark.parametrize(\n        \"mode, expected_pixel\",\n        (\n            (\"RGB\", (255, 0, 0)),\n            (\"RGBA\", (255, 0, 0, 255)),\n            (\"LA\", (76, 0)),\n        ),\n    )\n    def test_fill(self, mode: str, expected_pixel: tuple[int, ...]) -> None:\n        im = hopper(mode)\n        (w, h) = im.size\n        transformed = im.transform(\n            im.size,\n            Image.Transform.EXTENT,\n            (0, 0, w * 2, h * 2),\n            Image.Resampling.BILINEAR,\n            fillcolor=\"red\",\n        )\n        assert transformed.getpixel((w - 1, h - 1)) == expected_pixel\n\n    def test_mesh(self) -> None:\n        # this should be a checkerboard of halfsized hoppers in ul, lr\n        im = hopper(\"RGBA\")\n        (w, h) = im.size\n        transformed = im.transform(\n            im.size,\n            Image.Transform.MESH,\n            (\n                (\n                    (0, 0, w // 2, h // 2),  # box\n                    (0, 0, 0, h, w, h, w, 0),  # ul -> ccw around quad\n                ),\n                (\n                    (w // 2, h // 2, w, h),  # box\n                    (0, 0, 0, h, w, h, w, 0),  # ul -> ccw around quad\n                ),\n            ),\n            Image.Resampling.BILINEAR,\n        )\n\n        scaled = im.transform(\n            (w // 2, h // 2),\n            Image.Transform.AFFINE,\n            (2, 0, 0, 0, 2, 0),\n            Image.Resampling.BILINEAR,\n        )\n\n        checker = Image.new(\"RGBA\", im.size)\n        checker.paste(scaled, (0, 0))\n        checker.paste(scaled, (w // 2, h // 2))\n\n        assert_image_equal(transformed, checker)\n\n        # now, check to see that the extra area is (0, 0, 0, 0)\n        blank = Image.new(\"RGBA\", (w // 2, h // 2), (0, 0, 0, 0))\n\n        assert_image_equal(blank, transformed.crop((w // 2, 0, w, h // 2)))\n        assert_image_equal(blank, transformed.crop((0, h // 2, w // 2, h)))\n\n    def _test_alpha_premult(\n        self, op: Callable[[Image.Image, tuple[int, int]], Image.Image]\n    ) -> None:\n        # create image with half white, half black,\n        # with the black half transparent.\n        # do op,\n        # there should be no darkness in the white section.\n        im = Image.new(\"RGBA\", (10, 10), (0, 0, 0, 0))\n        im2 = Image.new(\"RGBA\", (5, 10), (255, 255, 255, 255))\n        im.paste(im2, (0, 0))\n\n        im = op(im, (40, 10))\n        im_background = Image.new(\"RGB\", (40, 10), (255, 255, 255))\n        im_background.paste(im, (0, 0), im)\n\n        hist = im_background.histogram()\n        assert 40 * 10 == hist[-1]\n\n    def test_alpha_premult_resize(self) -> None:\n        def op(im: Image.Image, sz: tuple[int, int]) -> Image.Image:\n            return im.resize(sz, Image.Resampling.BILINEAR)\n\n        self._test_alpha_premult(op)\n\n    def test_alpha_premult_transform(self) -> None:\n        def op(im: Image.Image, sz: tuple[int, int]) -> Image.Image:\n            (w, h) = im.size\n            return im.transform(\n                sz, Image.Transform.EXTENT, (0, 0, w, h), Image.Resampling.BILINEAR\n            )\n\n        self._test_alpha_premult(op)\n\n    def _test_nearest(\n        self, op: Callable[[Image.Image, tuple[int, int]], Image.Image], mode: str\n    ) -> None:\n        # create white image with half transparent,\n        # do op,\n        # the image should remain white with half transparent\n        transparent, opaque = {\n            \"RGBA\": ((255, 255, 255, 0), (255, 255, 255, 255)),\n            \"LA\": ((255, 0), (255, 255)),\n        }[mode]\n        im = Image.new(mode, (10, 10), transparent)\n        im2 = Image.new(mode, (5, 10), opaque)\n        im.paste(im2, (0, 0))\n\n        im = op(im, (40, 10))\n\n        colors = sorted(im.getcolors())\n        assert colors == sorted(\n            (\n                (20 * 10, opaque),\n                (20 * 10, transparent),\n            )\n        )\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBA\", \"LA\"))\n    def test_nearest_resize(self, mode: str) -> None:\n        def op(im: Image.Image, sz: tuple[int, int]) -> Image.Image:\n            return im.resize(sz, Image.Resampling.NEAREST)\n\n        self._test_nearest(op, mode)\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBA\", \"LA\"))\n    def test_nearest_transform(self, mode: str) -> None:\n        def op(im: Image.Image, sz: tuple[int, int]) -> Image.Image:\n            (w, h) = im.size\n            return im.transform(\n                sz, Image.Transform.EXTENT, (0, 0, w, h), Image.Resampling.NEAREST\n            )\n\n        self._test_nearest(op, mode)\n\n    def test_blank_fill(self) -> None:\n        # attempting to hit\n        # https://github.com/python-pillow/Pillow/issues/254 reported\n        #\n        # issue is that transforms with transparent overflow area\n        # contained junk from previous images, especially on systems with\n        # constrained memory. So, attempt to fill up memory with a\n        # pattern, free it, and then run the mesh test again. Using a 1Mp\n        # image with 4 bands, for 4 megs of data allocated, x 64. OMM (64\n        # bit 12.04 VM with 512 megs available, this fails with Pillow <\n        # a0eaf06cc5f62a6fb6de556989ac1014ff3348ea\n        #\n        # Running by default, but I'd totally understand not doing it in\n        # the future\n\n        pattern: list[Image.Image] | None = [\n            Image.new(\"RGBA\", (1024, 1024), (a, a, a, a)) for a in range(1, 65)\n        ]\n\n        # Yeah. Watch some JIT optimize this out.\n        pattern = None  # noqa: F841\n\n        self.test_mesh()\n\n    def test_missing_method_data(self) -> None:\n        with hopper() as im:\n            with pytest.raises(ValueError):\n                im.transform((100, 100), None)\n\n    @pytest.mark.parametrize(\"resample\", (Image.Resampling.BOX, \"unknown\"))\n    def test_unknown_resampling_filter(self, resample: Image.Resampling | str) -> None:\n        with hopper() as im:\n            (w, h) = im.size\n            with pytest.raises(ValueError):\n                im.transform((100, 100), Image.Transform.EXTENT, (0, 0, w, h), resample)\n\n\nclass TestImageTransformAffine:\n    transform = Image.Transform.AFFINE\n\n    def _test_image(self) -> Image.Image:\n        im = hopper(\"RGB\")\n        return im.crop((10, 20, im.width - 10, im.height - 20))\n\n    @pytest.mark.parametrize(\n        \"deg, transpose\",\n        (\n            (0, None),\n            (90, Image.Transpose.ROTATE_90),\n            (180, Image.Transpose.ROTATE_180),\n            (270, Image.Transpose.ROTATE_270),\n        ),\n    )\n    def test_rotate(self, deg: int, transpose: Image.Transpose | None) -> None:\n        im = self._test_image()\n\n        angle = -math.radians(deg)\n        matrix = [\n            round(math.cos(angle), 15),\n            round(math.sin(angle), 15),\n            0.0,\n            round(-math.sin(angle), 15),\n            round(math.cos(angle), 15),\n            0.0,\n            0,\n            0,\n        ]\n        matrix[2] = (1 - matrix[0] - matrix[1]) * im.width / 2\n        matrix[5] = (1 - matrix[3] - matrix[4]) * im.height / 2\n\n        if transpose is not None:\n            transposed = im.transpose(transpose)\n        else:\n            transposed = im\n\n        for resample in [\n            Image.Resampling.NEAREST,\n            Image.Resampling.BILINEAR,\n            Image.Resampling.BICUBIC,\n        ]:\n            transformed = im.transform(\n                transposed.size, self.transform, matrix, resample\n            )\n            assert_image_equal(transposed, transformed)\n\n    @pytest.mark.parametrize(\n        \"scale, epsilon_scale\",\n        (\n            (1.1, 6.9),\n            (1.5, 5.5),\n            (2.0, 5.5),\n            (2.3, 3.7),\n            (2.5, 3.7),\n        ),\n    )\n    @pytest.mark.parametrize(\n        \"resample,epsilon\",\n        (\n            (Image.Resampling.NEAREST, 0),\n            (Image.Resampling.BILINEAR, 2),\n            (Image.Resampling.BICUBIC, 1),\n        ),\n    )\n    def test_resize(\n        self,\n        scale: float,\n        epsilon_scale: float,\n        resample: Image.Resampling,\n        epsilon: int,\n    ) -> None:\n        im = self._test_image()\n\n        size_up = int(round(im.width * scale)), int(round(im.height * scale))\n        matrix_up = [1 / scale, 0, 0, 0, 1 / scale, 0, 0, 0]\n        matrix_down = [scale, 0, 0, 0, scale, 0, 0, 0]\n\n        transformed = im.transform(size_up, self.transform, matrix_up, resample)\n        transformed = transformed.transform(\n            im.size, self.transform, matrix_down, resample\n        )\n        assert_image_similar(transformed, im, epsilon * epsilon_scale)\n\n    @pytest.mark.parametrize(\n        \"x, y, epsilon_scale\",\n        (\n            (0.1, 0, 3.7),\n            (0.6, 0, 9.1),\n            (50, 50, 0),\n        ),\n    )\n    @pytest.mark.parametrize(\n        \"resample, epsilon\",\n        (\n            (Image.Resampling.NEAREST, 0),\n            (Image.Resampling.BILINEAR, 1.5),\n            (Image.Resampling.BICUBIC, 1),\n        ),\n    )\n    def test_translate(\n        self,\n        x: float,\n        y: float,\n        epsilon_scale: float,\n        resample: Image.Resampling,\n        epsilon: float,\n    ) -> None:\n        im = self._test_image()\n\n        size_up = int(round(im.width + x)), int(round(im.height + y))\n        matrix_up = [1, 0, -x, 0, 1, -y, 0, 0]\n        matrix_down = [1, 0, x, 0, 1, y, 0, 0]\n\n        transformed = im.transform(size_up, self.transform, matrix_up, resample)\n        transformed = transformed.transform(\n            im.size, self.transform, matrix_down, resample\n        )\n        assert_image_similar(transformed, im, epsilon * epsilon_scale)\n\n\nclass TestImageTransformPerspective(TestImageTransformAffine):\n    # Repeat all tests for AFFINE transformations with PERSPECTIVE\n    transform = Image.Transform.PERSPECTIVE\n", "Tests/test_file_psd.py": "from __future__ import annotations\n\nimport warnings\n\nimport pytest\n\nfrom PIL import Image, PsdImagePlugin, UnidentifiedImageError\n\nfrom .helper import assert_image_equal_tofile, assert_image_similar, hopper, is_pypy\n\ntest_file = \"Tests/images/hopper.psd\"\n\n\ndef test_sanity() -> None:\n    with Image.open(test_file) as im:\n        im.load()\n        assert im.mode == \"RGB\"\n        assert im.size == (128, 128)\n        assert im.format == \"PSD\"\n        assert im.get_format_mimetype() == \"image/vnd.adobe.photoshop\"\n\n        im2 = hopper()\n        assert_image_similar(im, im2, 4.8)\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    def open() -> None:\n        im = Image.open(test_file)\n        im.load()\n\n    with pytest.warns(ResourceWarning):\n        open()\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        im = Image.open(test_file)\n        im.load()\n        im.close()\n\n\ndef test_context_manager() -> None:\n    with warnings.catch_warnings():\n        with Image.open(test_file) as im:\n            im.load()\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        PsdImagePlugin.PsdImageFile(invalid_file)\n\n\ndef test_n_frames() -> None:\n    with Image.open(\"Tests/images/hopper_merged.psd\") as im:\n        assert im.n_frames == 1\n        assert not im.is_animated\n\n    for path in [test_file, \"Tests/images/negative_layer_count.psd\"]:\n        with Image.open(path) as im:\n            assert im.n_frames == 2\n            assert im.is_animated\n\n\ndef test_eoferror() -> None:\n    with Image.open(test_file) as im:\n        # PSD seek index starts at 1 rather than 0\n        n_frames = im.n_frames + 1\n\n        # Test seeking past the last frame\n        with pytest.raises(EOFError):\n            im.seek(n_frames)\n        assert im.tell() < n_frames\n\n        # Test that seeking to the last frame does not raise an error\n        im.seek(n_frames - 1)\n\n\ndef test_seek_tell() -> None:\n    with Image.open(test_file) as im:\n        layer_number = im.tell()\n        assert layer_number == 1\n\n        with pytest.raises(EOFError):\n            im.seek(0)\n\n        im.seek(1)\n        layer_number = im.tell()\n        assert layer_number == 1\n\n        im.seek(2)\n        layer_number = im.tell()\n        assert layer_number == 2\n\n\ndef test_seek_eoferror() -> None:\n    with Image.open(test_file) as im:\n        with pytest.raises(EOFError):\n            im.seek(-1)\n\n\ndef test_open_after_exclusive_load() -> None:\n    with Image.open(test_file) as im:\n        im.load()\n        im.seek(im.tell() + 1)\n        im.load()\n\n\ndef test_rgba() -> None:\n    with Image.open(\"Tests/images/rgba.psd\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/imagedraw_square.png\")\n\n\ndef test_negative_top_left_layer() -> None:\n    with Image.open(\"Tests/images/negative_top_left_layer.psd\") as im:\n        assert im.layers[0][2] == (-50, -50, 50, 50)\n\n\ndef test_layer_skip() -> None:\n    with Image.open(\"Tests/images/five_channels.psd\") as im:\n        assert im.n_frames == 1\n\n\ndef test_icc_profile() -> None:\n    with Image.open(test_file) as im:\n        assert \"icc_profile\" in im.info\n\n        icc_profile = im.info[\"icc_profile\"]\n        assert len(icc_profile) == 3144\n\n\ndef test_no_icc_profile() -> None:\n    with Image.open(\"Tests/images/hopper_merged.psd\") as im:\n        assert \"icc_profile\" not in im.info\n\n\ndef test_combined_larger_than_size() -> None:\n    # The combined size of the individual parts is larger than the\n    # declared 'size' of the extra data field, resulting in a backwards seek.\n\n    # If we instead take the 'size' of the extra data field as the source of truth,\n    # then the seek can't be negative\n    with pytest.raises(OSError):\n        with Image.open(\"Tests/images/combined_larger_than_size.psd\"):\n            pass\n\n\n@pytest.mark.parametrize(\n    \"test_file,raises\",\n    [\n        (\n            \"Tests/images/timeout-1ee28a249896e05b83840ae8140622de8e648ba9.psd\",\n            UnidentifiedImageError,\n        ),\n        (\n            \"Tests/images/timeout-598843abc37fc080ec36a2699ebbd44f795d3a6f.psd\",\n            UnidentifiedImageError,\n        ),\n        (\"Tests/images/timeout-c8efc3fded6426986ba867a399791bae544f59bc.psd\", OSError),\n        (\"Tests/images/timeout-dedc7a4ebd856d79b4359bbcc79e8ef231ce38f6.psd\", OSError),\n    ],\n)\ndef test_crashes(test_file: str, raises: type[Exception]) -> None:\n    with open(test_file, \"rb\") as f:\n        with pytest.raises(raises):\n            with Image.open(f):\n                pass\n", "Tests/test_imagesequence.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImageSequence, TiffImagePlugin\n\nfrom .helper import assert_image_equal, hopper, skip_unless_feature\n\n\ndef test_sanity(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.im\")\n\n    im = hopper(\"RGB\")\n    im.save(test_file)\n\n    seq = ImageSequence.Iterator(im)\n\n    index = 0\n    for frame in seq:\n        assert_image_equal(im, frame)\n        assert im.tell() == index\n        index += 1\n\n    assert index == 1\n\n    with pytest.raises(AttributeError):\n        ImageSequence.Iterator(0)  # type: ignore[arg-type]\n\n\ndef test_iterator() -> None:\n    with Image.open(\"Tests/images/multipage.tiff\") as im:\n        i = ImageSequence.Iterator(im)\n        for index in range(0, im.n_frames):\n            assert i[index] == next(i)\n        with pytest.raises(IndexError):\n            i[index + 1]\n        with pytest.raises(StopIteration):\n            next(i)\n\n\ndef test_iterator_min_frame() -> None:\n    with Image.open(\"Tests/images/hopper.psd\") as im:\n        i = ImageSequence.Iterator(im)\n        for index in range(1, im.n_frames):\n            assert i[index] == next(i)\n\n\n@pytest.mark.parametrize(\n    \"libtiff\", (pytest.param(True, marks=skip_unless_feature(\"libtiff\")), False)\n)\ndef test_multipage_tiff(monkeypatch: pytest.MonkeyPatch, libtiff: bool) -> None:\n    monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", libtiff)\n    with Image.open(\"Tests/images/multipage.tiff\") as im:\n        for index, frame in enumerate(ImageSequence.Iterator(im)):\n            frame.load()\n            assert index == im.tell()\n            frame.convert(\"RGB\")\n\n\ndef test_consecutive() -> None:\n    with Image.open(\"Tests/images/multipage.tiff\") as im:\n        first_frame = None\n        for frame in ImageSequence.Iterator(im):\n            if first_frame is None:\n                first_frame = frame.copy()\n        assert first_frame is not None\n        for frame in ImageSequence.Iterator(im):\n            assert_image_equal(frame, first_frame)\n            break\n\n\ndef test_palette_mmap() -> None:\n    # Using mmap in ImageFile can require to reload the palette.\n    with Image.open(\"Tests/images/multipage-mmap.tiff\") as im:\n        color1 = im.getpalette()[:3]\n        im.seek(0)\n        color2 = im.getpalette()[:3]\n        assert color1 == color2\n\n\ndef test_all_frames() -> None:\n    # Test a single image\n    with Image.open(\"Tests/images/iss634.gif\") as im:\n        ims = ImageSequence.all_frames(im)\n\n        assert len(ims) == 42\n        for i, im_frame in enumerate(ims):\n            assert im_frame is not im\n\n            im.seek(i)\n            assert_image_equal(im, im_frame)\n\n        # Test a series of images\n        ims = ImageSequence.all_frames([im, hopper(), im])\n        assert len(ims) == 85\n\n        # Test an operation\n        ims = ImageSequence.all_frames(im, lambda im_frame: im_frame.rotate(90))\n        for i, im_frame in enumerate(ims):\n            im.seek(i)\n            assert_image_equal(im.rotate(90), im_frame)\n", "Tests/test_file_pdf.py": "from __future__ import annotations\n\nimport io\nimport os\nimport os.path\nimport tempfile\nimport time\nfrom pathlib import Path\nfrom typing import Any, Generator\n\nimport pytest\n\nfrom PIL import Image, PdfParser, features\n\nfrom .helper import hopper, mark_if_feature_version, skip_unless_feature\n\n\ndef helper_save_as_pdf(tmp_path: Path, mode: str, **kwargs: Any) -> str:\n    # Arrange\n    im = hopper(mode)\n    outfile = str(tmp_path / (\"temp_\" + mode + \".pdf\"))\n\n    # Act\n    im.save(outfile, **kwargs)\n\n    # Assert\n    assert os.path.isfile(outfile)\n    assert os.path.getsize(outfile) > 0\n    with PdfParser.PdfParser(outfile) as pdf:\n        if kwargs.get(\"append_images\", False) or kwargs.get(\"append\", False):\n            assert len(pdf.pages) > 1\n        else:\n            assert len(pdf.pages) > 0\n    with open(outfile, \"rb\") as fp:\n        contents = fp.read()\n    size = tuple(\n        float(d) for d in contents.split(b\"/MediaBox [ 0 0 \")[1].split(b\"]\")[0].split()\n    )\n    assert im.size == size\n\n    return outfile\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"P\", \"RGB\", \"CMYK\"))\ndef test_save(tmp_path: Path, mode: str) -> None:\n    helper_save_as_pdf(tmp_path, mode)\n\n\n@skip_unless_feature(\"jpg_2000\")\n@pytest.mark.parametrize(\"mode\", (\"LA\", \"RGBA\"))\ndef test_save_alpha(tmp_path: Path, mode: str) -> None:\n    helper_save_as_pdf(tmp_path, mode)\n\n\ndef test_p_alpha(tmp_path: Path) -> None:\n    # Arrange\n    outfile = str(tmp_path / \"temp.pdf\")\n    with Image.open(\"Tests/images/pil123p.png\") as im:\n        assert im.mode == \"P\"\n        assert isinstance(im.info[\"transparency\"], bytes)\n\n        # Act\n        im.save(outfile)\n\n    # Assert\n    with open(outfile, \"rb\") as fp:\n        contents = fp.read()\n    assert b\"\\n/SMask \" in contents\n\n\ndef test_monochrome(tmp_path: Path) -> None:\n    # Arrange\n    mode = \"1\"\n\n    # Act / Assert\n    outfile = helper_save_as_pdf(tmp_path, mode)\n    assert os.path.getsize(outfile) < (5000 if features.check(\"libtiff\") else 15000)\n\n\ndef test_unsupported_mode(tmp_path: Path) -> None:\n    im = hopper(\"PA\")\n    outfile = str(tmp_path / \"temp_PA.pdf\")\n\n    with pytest.raises(ValueError):\n        im.save(outfile)\n\n\ndef test_resolution(tmp_path: Path) -> None:\n    im = hopper()\n\n    outfile = str(tmp_path / \"temp.pdf\")\n    im.save(outfile, resolution=150)\n\n    with open(outfile, \"rb\") as fp:\n        contents = fp.read()\n\n    size = tuple(\n        float(d)\n        for d in contents.split(b\"stream\\nq \")[1].split(b\" 0 0 cm\")[0].split(b\" 0 0 \")\n    )\n    assert size == (61.44, 61.44)\n\n    size = tuple(\n        float(d) for d in contents.split(b\"/MediaBox [ 0 0 \")[1].split(b\"]\")[0].split()\n    )\n    assert size == (61.44, 61.44)\n\n\n@pytest.mark.parametrize(\n    \"params\",\n    (\n        {\"dpi\": (75, 150)},\n        {\"dpi\": (75, 150), \"resolution\": 200},\n    ),\n)\ndef test_dpi(params: dict[str, int | tuple[int, int]], tmp_path: Path) -> None:\n    im = hopper()\n\n    outfile = str(tmp_path / \"temp.pdf\")\n    im.save(outfile, **params)\n\n    with open(outfile, \"rb\") as fp:\n        contents = fp.read()\n\n    size = tuple(\n        float(d)\n        for d in contents.split(b\"stream\\nq \")[1].split(b\" 0 0 cm\")[0].split(b\" 0 0 \")\n    )\n    assert size == (122.88, 61.44)\n\n    size = tuple(\n        float(d) for d in contents.split(b\"/MediaBox [ 0 0 \")[1].split(b\"]\")[0].split()\n    )\n    assert size == (122.88, 61.44)\n\n\n@mark_if_feature_version(\n    pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n)\ndef test_save_all(tmp_path: Path) -> None:\n    # Single frame image\n    helper_save_as_pdf(tmp_path, \"RGB\", save_all=True)\n\n    # Multiframe image\n    with Image.open(\"Tests/images/dispose_bgnd.gif\") as im:\n        outfile = str(tmp_path / \"temp.pdf\")\n        im.save(outfile, save_all=True)\n\n        assert os.path.isfile(outfile)\n        assert os.path.getsize(outfile) > 0\n\n        # Append images\n        ims = [hopper()]\n        im.copy().save(outfile, save_all=True, append_images=ims)\n\n        assert os.path.isfile(outfile)\n        assert os.path.getsize(outfile) > 0\n\n        # Test appending using a generator\n        def im_generator(ims: list[Image.Image]) -> Generator[Image.Image, None, None]:\n            yield from ims\n\n        im.save(outfile, save_all=True, append_images=im_generator(ims))\n\n    assert os.path.isfile(outfile)\n    assert os.path.getsize(outfile) > 0\n\n    # Append JPEG images\n    with Image.open(\"Tests/images/flower.jpg\") as jpeg:\n        jpeg.save(outfile, save_all=True, append_images=[jpeg.copy()])\n\n    assert os.path.isfile(outfile)\n    assert os.path.getsize(outfile) > 0\n\n\ndef test_multiframe_normal_save(tmp_path: Path) -> None:\n    # Test saving a multiframe image without save_all\n    with Image.open(\"Tests/images/dispose_bgnd.gif\") as im:\n        outfile = str(tmp_path / \"temp.pdf\")\n        im.save(outfile)\n\n    assert os.path.isfile(outfile)\n    assert os.path.getsize(outfile) > 0\n\n\ndef test_pdf_open(tmp_path: Path) -> None:\n    # fail on a buffer full of null bytes\n    with pytest.raises(PdfParser.PdfFormatError):\n        PdfParser.PdfParser(buf=bytearray(65536))\n\n    # make an empty PDF object\n    with PdfParser.PdfParser() as empty_pdf:\n        assert len(empty_pdf.pages) == 0\n        assert len(empty_pdf.info) == 0\n        assert not empty_pdf.should_close_buf\n        assert not empty_pdf.should_close_file\n\n    # make a PDF file\n    pdf_filename = helper_save_as_pdf(tmp_path, \"RGB\")\n\n    # open the PDF file\n    with PdfParser.PdfParser(filename=pdf_filename) as hopper_pdf:\n        assert len(hopper_pdf.pages) == 1\n        assert hopper_pdf.should_close_buf\n        assert hopper_pdf.should_close_file\n\n    # read a PDF file from a buffer with a non-zero offset\n    with open(pdf_filename, \"rb\") as f:\n        content = b\"xyzzy\" + f.read()\n    with PdfParser.PdfParser(buf=content, start_offset=5) as hopper_pdf:\n        assert len(hopper_pdf.pages) == 1\n        assert not hopper_pdf.should_close_buf\n        assert not hopper_pdf.should_close_file\n\n    # read a PDF file from an already open file\n    with open(pdf_filename, \"rb\") as f:\n        with PdfParser.PdfParser(f=f) as hopper_pdf:\n            assert len(hopper_pdf.pages) == 1\n            assert hopper_pdf.should_close_buf\n            assert not hopper_pdf.should_close_file\n\n\ndef test_pdf_append_fails_on_nonexistent_file() -> None:\n    im = hopper(\"RGB\")\n    with tempfile.TemporaryDirectory() as temp_dir:\n        with pytest.raises(OSError):\n            im.save(os.path.join(temp_dir, \"nonexistent.pdf\"), append=True)\n\n\ndef check_pdf_pages_consistency(pdf: PdfParser.PdfParser) -> None:\n    pages_info = pdf.read_indirect(pdf.pages_ref)\n    assert b\"Parent\" not in pages_info\n    assert b\"Kids\" in pages_info\n    kids_not_used = pages_info[b\"Kids\"]\n    for page_ref in pdf.pages:\n        while True:\n            if page_ref in kids_not_used:\n                kids_not_used.remove(page_ref)\n            page_info = pdf.read_indirect(page_ref)\n            assert b\"Parent\" in page_info\n            page_ref = page_info[b\"Parent\"]\n            if page_ref == pdf.pages_ref:\n                break\n        assert pdf.pages_ref == page_info[b\"Parent\"]\n    assert kids_not_used == []\n\n\ndef test_pdf_append(tmp_path: Path) -> None:\n    # make a PDF file\n    pdf_filename = helper_save_as_pdf(tmp_path, \"RGB\", producer=\"PdfParser\")\n\n    # open it, check pages and info\n    with PdfParser.PdfParser(pdf_filename, mode=\"r+b\") as pdf:\n        assert len(pdf.pages) == 1\n        assert len(pdf.info) == 4\n        assert pdf.info.Title == os.path.splitext(os.path.basename(pdf_filename))[0]\n        assert pdf.info.Producer == \"PdfParser\"\n        assert b\"CreationDate\" in pdf.info\n        assert b\"ModDate\" in pdf.info\n        check_pdf_pages_consistency(pdf)\n\n        # append some info\n        pdf.info.Title = \"abc\"\n        pdf.info.Author = \"def\"\n        pdf.info.Subject = \"ghi\\uABCD\"\n        pdf.info.Keywords = \"qw)e\\\\r(ty\"\n        pdf.info.Creator = \"hopper()\"\n        pdf.start_writing()\n        pdf.write_xref_and_trailer()\n\n    # open it again, check pages and info again\n    with PdfParser.PdfParser(pdf_filename) as pdf:\n        assert len(pdf.pages) == 1\n        assert len(pdf.info) == 8\n        assert pdf.info.Title == \"abc\"\n        assert b\"CreationDate\" in pdf.info\n        assert b\"ModDate\" in pdf.info\n        check_pdf_pages_consistency(pdf)\n\n    # append two images\n    mode_cmyk = hopper(\"CMYK\")\n    mode_p = hopper(\"P\")\n    mode_cmyk.save(pdf_filename, append=True, save_all=True, append_images=[mode_p])\n\n    # open the PDF again, check pages and info again\n    with PdfParser.PdfParser(pdf_filename) as pdf:\n        assert len(pdf.pages) == 3\n        assert len(pdf.info) == 8\n        assert PdfParser.decode_text(pdf.info[b\"Title\"]) == \"abc\"\n        assert pdf.info.Title == \"abc\"\n        assert pdf.info.Producer == \"PdfParser\"\n        assert pdf.info.Keywords == \"qw)e\\\\r(ty\"\n        assert pdf.info.Subject == \"ghi\\uABCD\"\n        assert b\"CreationDate\" in pdf.info\n        assert b\"ModDate\" in pdf.info\n        check_pdf_pages_consistency(pdf)\n\n\ndef test_pdf_info(tmp_path: Path) -> None:\n    # make a PDF file\n    pdf_filename = helper_save_as_pdf(\n        tmp_path,\n        \"RGB\",\n        title=\"title\",\n        author=\"author\",\n        subject=\"subject\",\n        keywords=\"keywords\",\n        creator=\"creator\",\n        producer=\"producer\",\n        creationDate=time.strptime(\"2000\", \"%Y\"),\n        modDate=time.strptime(\"2001\", \"%Y\"),\n    )\n\n    # open it, check pages and info\n    with PdfParser.PdfParser(pdf_filename) as pdf:\n        assert len(pdf.info) == 8\n        assert pdf.info.Title == \"title\"\n        assert pdf.info.Author == \"author\"\n        assert pdf.info.Subject == \"subject\"\n        assert pdf.info.Keywords == \"keywords\"\n        assert pdf.info.Creator == \"creator\"\n        assert pdf.info.Producer == \"producer\"\n        assert pdf.info.CreationDate == time.strptime(\"2000\", \"%Y\")\n        assert pdf.info.ModDate == time.strptime(\"2001\", \"%Y\")\n        check_pdf_pages_consistency(pdf)\n\n\ndef test_pdf_append_to_bytesio() -> None:\n    im = hopper(\"RGB\")\n    f = io.BytesIO()\n    im.save(f, format=\"PDF\")\n    initial_size = len(f.getvalue())\n    assert initial_size > 0\n    im = hopper(\"P\")\n    f = io.BytesIO(f.getvalue())\n    im.save(f, format=\"PDF\", append=True)\n    assert len(f.getvalue()) > initial_size\n\n\n@pytest.mark.timeout(1)\n@pytest.mark.skipif(\"PILLOW_VALGRIND_TEST\" in os.environ, reason=\"Valgrind is slower\")\n@pytest.mark.parametrize(\"newline\", (b\"\\r\", b\"\\n\"))\ndef test_redos(newline: bytes) -> None:\n    malicious = b\" trailer<<>>\" + newline * 3456\n\n    # This particular exception isn't relevant here.\n    # The important thing is it doesn't timeout, cause a ReDoS (CVE-2021-25292).\n    with pytest.raises(PdfParser.PdfFormatError):\n        PdfParser.PdfParser(buf=malicious)\n", "Tests/check_jpeg_leaks.py": "from __future__ import annotations\n\nfrom io import BytesIO\n\nimport pytest\n\nfrom .helper import hopper, is_win32\n\niterations = 5000\n\n\n\"\"\"\nWhen run on a system without the jpeg leak fixes,\nthe valgrind runs look like this.\n\nvalgrind --tool=massif python test-installed.py -s -v Tests/check_jpeg_leaks.py\n\n\"\"\"\n\n\npytestmark = pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\")\n\n\"\"\"\npre patch:\n\n    MB\n31.62^                                                                       :\n     |                                                              @:@:@:@#::\n     |                                                     @:@:@@:@:@:@:@:@#::\n     |                                             ::::::::@:@:@@:@:@:@:@:@#::\n     |                                   :::::@::::::: ::::@:@:@@:@:@:@:@:@#::\n     |                          @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |               ::::::@::::@:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |          ::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |         :::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |        ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |        ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |      ::::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |      : ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |     @: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |    @@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |   :@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     |   :@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     | :@:@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     | :@:@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n     | :@:@@: ::::::::: : :@: : @:::::::::::::@: : ::: ::::@:@:@@:@:@:@:@:@#::\n   0 +----------------------------------------------------------------------->Gi\n     0                                                                   8.535\n\n\npost-patch:\n\n    MB\n21.03^          :::@@:::@::::@@:::::::@@::::::::@::::::::::::@:::@:::::::@::::\n     |         #:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |         #:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |        :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |        :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |        :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |      :::#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |      : :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |      : :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |     @: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |    @@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |    @@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |    @@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |   :@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     |   :@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n     | :@:@@: :#:::@ :::@::::@ : :: : @ :::::: :@:: ::: :::: @:: @:::::::@::::\n   0 +----------------------------------------------------------------------->Gi\n     0                                                                   8.421\n\n\"\"\"\n\n\nstandard_l_qtable = (\n    # fmt: off\n    16, 11, 10, 16,  24,  40,  51,  61,\n    12, 12, 14, 19,  26,  58,  60,  55,\n    14, 13, 16, 24,  40,  57,  69,  56,\n    14, 17, 22, 29,  51,  87,  80,  62,\n    18, 22, 37, 56,  68, 109, 103,  77,\n    24, 35, 55, 64,  81, 104, 113,  92,\n    49, 64, 78, 87, 103, 121, 120, 101,\n    72, 92, 95, 98, 112, 100, 103,  99,\n    # fmt: on\n)\n\nstandard_chrominance_qtable = (\n    # fmt: off\n    17, 18, 24, 47, 99, 99, 99, 99,\n    18, 21, 26, 66, 99, 99, 99, 99,\n    24, 26, 56, 99, 99, 99, 99, 99,\n    47, 66, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    99, 99, 99, 99, 99, 99, 99, 99,\n    # fmt: on\n)\n\n\n@pytest.mark.parametrize(\n    \"qtables\",\n    (\n        (standard_l_qtable, standard_chrominance_qtable),\n        [standard_l_qtable, standard_chrominance_qtable],\n    ),\n)\ndef test_qtables_leak(qtables: tuple[tuple[int, ...]] | list[tuple[int, ...]]) -> None:\n    im = hopper(\"RGB\")\n    for _ in range(iterations):\n        test_output = BytesIO()\n        im.save(test_output, \"JPEG\", qtables=qtables)\n\n\ndef test_exif_leak() -> None:\n    \"\"\"\n    pre patch:\n\n        MB\n    177.1^                                                                       #\n         |                                                                    @@@#\n         |                                                                :@@@@@@#\n         |                                                             ::::@@@@@@#\n         |                                                         ::::::::@@@@@@#\n         |                                                     @@::::: ::::@@@@@@#\n         |                                                  @@@@ ::::: ::::@@@@@@#\n         |                                               @@@@@@@ ::::: ::::@@@@@@#\n         |                                           @@::@@@@@@@ ::::: ::::@@@@@@#\n         |                                        @@@@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                                   @@@@@@ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                                @@@@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                            @::@@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                        ::::@: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                     :@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |                ::@@::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |            @@::: @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |         @::@ : : @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |      :::@: @ : : @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n         |   @@@:: @: @ : : @ ::@@: : @: @@ @@ @@ @ @@ : @@@@@@@ ::::: ::::@@@@@@#\n       0 +----------------------------------------------------------------------->Gi\n         0                                                                   11.37\n\n\n    post patch:\n\n        MB\n    21.06^        ::::::::::::::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      ##::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      # ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      # ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |      # ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |     @# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |    @@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         |   @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @@@@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n         | @ @@@# ::: ::::: : ::::::::::@::::@::::@::::@::::@::::@:::::::::@::::::\n       0 +----------------------------------------------------------------------->Gi\n         0                                                                   11.33\n    \"\"\"\n    im = hopper(\"RGB\")\n    exif = b\"12345678\" * 4096\n\n    for _ in range(iterations):\n        test_output = BytesIO()\n        im.save(test_output, \"JPEG\", exif=exif)\n\n\ndef test_base_save() -> None:\n    \"\"\"\n    base case:\n        MB\n    20.99^           :::::         :::::::::::::::::::::::::::::::::::::::::::@:::\n         |         ##: : ::::::@::::::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |         # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |         # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |         # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |       @@# : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |       @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |       @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |     @@@ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |     @ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         |    @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@@@@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n         | :@ @@ @ # : : :: :: @:: :::: :::: :::: : : : : : : :::::::::::: :::@:::\n       0 +----------------------------------------------------------------------->Gi\n         0                                                                   7.882\"\"\"\n    im = hopper(\"RGB\")\n\n    for _ in range(iterations):\n        test_output = BytesIO()\n        im.save(test_output, \"JPEG\")\n", "Tests/test_psdraw.py": "from __future__ import annotations\n\nimport os\nimport sys\nfrom io import BytesIO\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, PSDraw\n\n\ndef _create_document(ps: PSDraw.PSDraw) -> None:\n    title = \"hopper\"\n    box = (1 * 72, 2 * 72, 7 * 72, 10 * 72)  # in points\n\n    ps.begin_document(title)\n\n    # draw diagonal lines in a cross\n    ps.line((1 * 72, 2 * 72), (7 * 72, 10 * 72))\n    ps.line((7 * 72, 2 * 72), (1 * 72, 10 * 72))\n\n    # draw the image (75 dpi)\n    with Image.open(\"Tests/images/hopper.ppm\") as im:\n        ps.image(box, im, 75)\n    ps.rectangle(box)\n\n    # draw title\n    ps.setfont(\"Courier\", 36)\n    ps.text((3 * 72, 4 * 72), title)\n\n    ps.end_document()\n\n\ndef test_draw_postscript(tmp_path: Path) -> None:\n    # Based on Pillow tutorial, but there is no textsize:\n    # https://pillow.readthedocs.io/en/latest/handbook/tutorial.html#drawing-postscript\n\n    # Arrange\n    tempfile = str(tmp_path / \"temp.ps\")\n    with open(tempfile, \"wb\") as fp:\n        # Act\n        ps = PSDraw.PSDraw(fp)\n        _create_document(ps)\n\n    # Assert\n    # Check non-zero file was created\n    assert os.path.isfile(tempfile)\n    assert os.path.getsize(tempfile) > 0\n\n\n@pytest.mark.parametrize(\"buffer\", (True, False))\ndef test_stdout(buffer: bool) -> None:\n    # Temporarily redirect stdout\n    old_stdout = sys.stdout\n\n    class MyStdOut:\n        buffer = BytesIO()\n\n    mystdout: MyStdOut | BytesIO = MyStdOut() if buffer else BytesIO()\n\n    sys.stdout = mystdout  # type: ignore[assignment]\n\n    ps = PSDraw.PSDraw()\n    _create_document(ps)\n\n    # Reset stdout\n    sys.stdout = old_stdout\n\n    if isinstance(mystdout, MyStdOut):\n        mystdout = mystdout.buffer\n    assert mystdout.getvalue() != b\"\"\n", "Tests/test_file_cur.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import CurImagePlugin, Image\n\nTEST_FILE = \"Tests/images/deerstalker.cur\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert im.size == (32, 32)\n        assert isinstance(im, CurImagePlugin.CurImageFile)\n        # Check some pixel colors to ensure image is loaded properly\n        assert im.getpixel((10, 1)) == (0, 0, 0, 0)\n        assert im.getpixel((11, 1)) == (253, 254, 254, 1)\n        assert im.getpixel((16, 16)) == (84, 87, 86, 255)\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        CurImagePlugin.CurImageFile(invalid_file)\n\n    no_cursors_file = \"Tests/images/no_cursors.cur\"\n\n    cur = CurImagePlugin.CurImageFile(TEST_FILE)\n    cur.fp.close()\n    with open(no_cursors_file, \"rb\") as cur.fp:\n        with pytest.raises(TypeError):\n            cur._open()\n", "Tests/test_image_draft.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nfrom .helper import fromstring, skip_unless_feature, tostring\n\npytestmark = skip_unless_feature(\"jpg\")\n\n\ndef draft_roundtrip(\n    in_mode: str,\n    in_size: tuple[int, int],\n    req_mode: str | None,\n    req_size: tuple[int, int] | None,\n) -> Image.Image:\n    im = Image.new(in_mode, in_size)\n    data = tostring(im, \"JPEG\")\n    im = fromstring(data)\n    result = im.draft(req_mode, req_size)\n    assert result is not None\n    box = result[1]\n    scale, _ = im.decoderconfig\n    assert box[:2] == (0, 0)\n    assert (im.width - scale) < box[2] <= im.width\n    assert (im.height - scale) < box[3] <= im.height\n    return im\n\n\ndef test_size() -> None:\n    for in_size, req_size, out_size in [\n        ((435, 361), (2048, 2048), (435, 361)),  # bigger\n        ((435, 361), (435, 361), (435, 361)),  # same\n        ((128, 128), (64, 64), (64, 64)),\n        ((128, 128), (32, 32), (32, 32)),\n        ((128, 128), (16, 16), (16, 16)),\n        # large requested width\n        ((435, 361), (218, 128), (435, 361)),  # almost 2x\n        ((435, 361), (217, 128), (218, 181)),  # more than 2x\n        ((435, 361), (109, 64), (218, 181)),  # almost 4x\n        ((435, 361), (108, 64), (109, 91)),  # more than 4x\n        ((435, 361), (55, 32), (109, 91)),  # almost 8x\n        ((435, 361), (54, 32), (55, 46)),  # more than 8x\n        ((435, 361), (27, 16), (55, 46)),  # more than 16x\n        # and vice versa\n        ((435, 361), (128, 181), (435, 361)),  # almost 2x\n        ((435, 361), (128, 180), (218, 181)),  # more than 2x\n        ((435, 361), (64, 91), (218, 181)),  # almost 4x\n        ((435, 361), (64, 90), (109, 91)),  # more than 4x\n        ((435, 361), (32, 46), (109, 91)),  # almost 8x\n        ((435, 361), (32, 45), (55, 46)),  # more than 8x\n        ((435, 361), (16, 22), (55, 46)),  # more than 16x\n    ]:\n        im = draft_roundtrip(\"L\", in_size, None, req_size)\n        im.load()\n        assert im.size == out_size\n\n\ndef test_mode() -> None:\n    for in_mode, req_mode, out_mode in [\n        (\"RGB\", \"1\", \"RGB\"),\n        (\"RGB\", \"L\", \"L\"),\n        (\"RGB\", \"RGB\", \"RGB\"),\n        (\"RGB\", \"YCbCr\", \"YCbCr\"),\n        (\"L\", \"1\", \"L\"),\n        (\"L\", \"L\", \"L\"),\n        (\"L\", \"RGB\", \"L\"),\n        (\"L\", \"YCbCr\", \"L\"),\n        (\"CMYK\", \"1\", \"CMYK\"),\n        (\"CMYK\", \"L\", \"CMYK\"),\n        (\"CMYK\", \"RGB\", \"CMYK\"),\n        (\"CMYK\", \"YCbCr\", \"CMYK\"),\n    ]:\n        im = draft_roundtrip(in_mode, (64, 64), req_mode, None)\n        im.load()\n        assert im.mode == out_mode\n\n\ndef test_several_drafts() -> None:\n    im = draft_roundtrip(\"L\", (128, 128), None, (64, 64))\n    im.draft(None, (64, 64))\n    im.load()\n", "Tests/test_file_fpx.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal_tofile\n\nFpxImagePlugin = pytest.importorskip(\n    \"PIL.FpxImagePlugin\", reason=\"olefile not installed\"\n)\n\n\ndef test_sanity() -> None:\n    with Image.open(\"Tests/images/input_bw_one_band.fpx\") as im:\n        assert im.mode == \"L\"\n        assert im.size == (70, 46)\n        assert im.format == \"FPX\"\n\n        assert_image_equal_tofile(im, \"Tests/images/input_bw_one_band.png\")\n\n\ndef test_close() -> None:\n    with Image.open(\"Tests/images/input_bw_one_band.fpx\") as im:\n        pass\n    assert im.ole.fp.closed\n\n    im = Image.open(\"Tests/images/input_bw_one_band.fpx\")\n    im.close()\n    assert im.ole.fp.closed\n\n\ndef test_invalid_file() -> None:\n    # Test an invalid OLE file\n    invalid_file = \"Tests/images/flower.jpg\"\n    with pytest.raises(SyntaxError):\n        FpxImagePlugin.FpxImageFile(invalid_file)\n\n    # Test a valid OLE file, but not an FPX file\n    ole_file = \"Tests/images/test-ole-file.doc\"\n    with pytest.raises(SyntaxError):\n        FpxImagePlugin.FpxImageFile(ole_file)\n\n\ndef test_fpx_invalid_number_of_bands() -> None:\n    with pytest.raises(OSError, match=\"Invalid number of bands\"):\n        with Image.open(\"Tests/images/input_bw_five_bands.fpx\"):\n            pass\n", "Tests/test_file_tar.py": "from __future__ import annotations\n\nimport warnings\n\nimport pytest\n\nfrom PIL import Image, TarIO, features\n\nfrom .helper import is_pypy\n\n# Sample tar archive\nTEST_TAR_FILE = \"Tests/images/hopper.tar\"\n\n\n@pytest.mark.parametrize(\n    \"codec, test_path, format\",\n    (\n        (\"zlib\", \"hopper.png\", \"PNG\"),\n        (\"jpg\", \"hopper.jpg\", \"JPEG\"),\n    ),\n)\ndef test_sanity(codec: str, test_path: str, format: str) -> None:\n    if features.check(codec):\n        with TarIO.TarIO(TEST_TAR_FILE, test_path) as tar:\n            with Image.open(tar) as im:\n                im.load()\n                assert im.mode == \"RGB\"\n                assert im.size == (128, 128)\n                assert im.format == format\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    with pytest.warns(ResourceWarning):\n        TarIO.TarIO(TEST_TAR_FILE, \"hopper.jpg\")\n\n\ndef test_close() -> None:\n    with warnings.catch_warnings():\n        tar = TarIO.TarIO(TEST_TAR_FILE, \"hopper.jpg\")\n        tar.close()\n\n\ndef test_contextmanager() -> None:\n    with warnings.catch_warnings():\n        with TarIO.TarIO(TEST_TAR_FILE, \"hopper.jpg\"):\n            pass\n", "Tests/test_image_reduce.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageMath, ImageMode\n\nfrom .helper import convert_to_comparable, skip_unless_feature\n\ncodecs = dir(Image.core)\n\n\n# There are several internal implementations\nremarkable_factors = [\n    # special implementations\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    # 1xN implementation\n    (1, 2),\n    (1, 3),\n    (1, 4),\n    (1, 7),\n    # Nx1 implementation\n    (2, 1),\n    (3, 1),\n    (4, 1),\n    (7, 1),\n    # general implementation with different paths\n    (4, 6),\n    (5, 6),\n    (4, 7),\n    (5, 7),\n    (19, 17),\n]\n\ngradients_image = Image.open(\"Tests/images/radial_gradients.png\")\ngradients_image.load()\n\n\n@pytest.mark.parametrize(\n    \"size, expected\",\n    (\n        (3, (4, 4)),\n        ((3, 1), (4, 10)),\n        ((1, 3), (10, 4)),\n    ),\n)\ndef test_args_factor(size: int | tuple[int, int], expected: tuple[int, int]) -> None:\n    im = Image.new(\"L\", (10, 10))\n    assert expected == im.reduce(size).size\n\n\n@pytest.mark.parametrize(\n    \"size, expected_error\", ((0, ValueError), (2.0, TypeError), ((0, 10), ValueError))\n)\ndef test_args_factor_error(\n    size: float | tuple[int, int], expected_error: type[Exception]\n) -> None:\n    im = Image.new(\"L\", (10, 10))\n    with pytest.raises(expected_error):\n        im.reduce(size)  # type: ignore[arg-type]\n\n\n@pytest.mark.parametrize(\n    \"size, expected\",\n    (\n        ((0, 0, 10, 10), (5, 5)),\n        ((5, 5, 6, 6), (1, 1)),\n    ),\n)\ndef test_args_box(size: tuple[int, int, int, int], expected: tuple[int, int]) -> None:\n    im = Image.new(\"L\", (10, 10))\n    assert expected == im.reduce(2, size).size\n\n\n@pytest.mark.parametrize(\n    \"size, expected_error\",\n    (\n        (\"stri\", TypeError),\n        ((0, 0, 11, 10), ValueError),\n        ((0, 0, 10, 11), ValueError),\n        ((-1, 0, 10, 10), ValueError),\n        ((0, -1, 10, 10), ValueError),\n        ((0, 5, 10, 5), ValueError),\n        ((5, 0, 5, 10), ValueError),\n    ),\n)\ndef test_args_box_error(\n    size: str | tuple[int, int, int, int], expected_error: type[Exception]\n) -> None:\n    im = Image.new(\"L\", (10, 10))\n    with pytest.raises(expected_error):\n        im.reduce(2, size).size  # type: ignore[arg-type]\n\n\n@pytest.mark.parametrize(\"mode\", (\"P\", \"1\", \"I;16\"))\ndef test_unsupported_modes(mode: str) -> None:\n    im = Image.new(\"P\", (10, 10))\n    with pytest.raises(ValueError):\n        im.reduce(3)\n\n\ndef get_image(mode: str) -> Image.Image:\n    mode_info = ImageMode.getmode(mode)\n    if mode_info.basetype == \"L\":\n        bands: list[Image.Image] = [gradients_image]\n        for _ in mode_info.bands[1:]:\n            # rotate previous image\n            band = bands[-1].transpose(Image.Transpose.ROTATE_90)\n            bands.append(band)\n        # Correct alpha channel by transforming completely transparent pixels.\n        # Low alpha values also emphasize error after alpha multiplication.\n        if mode.endswith(\"A\"):\n            bands[-1] = bands[-1].point(lambda x: int(85 + x / 1.5))\n        im = Image.merge(mode, bands)\n    else:\n        assert len(mode_info.bands) == 1\n        im = gradients_image.convert(mode)\n    # change the height to make a not-square image\n    return im.crop((0, 0, im.width, im.height - 5))\n\n\ndef compare_reduce_with_box(im: Image.Image, factor: int | tuple[int, int]) -> None:\n    box = (11, 13, 146, 164)\n    reduced = im.reduce(factor, box=box)\n    reference = im.crop(box).reduce(factor)\n    assert reduced == reference\n\n\ndef compare_reduce_with_reference(\n    im: Image.Image,\n    factor: int | tuple[int, int],\n    average_diff: float = 0.4,\n    max_diff: int = 1,\n) -> None:\n    \"\"\"Image.reduce() should look very similar to Image.resize(BOX).\n\n    A reference image is compiled from a large source area\n    and possible last column and last row.\n    +-----------+\n    |..........c|\n    |..........c|\n    |..........c|\n    |rrrrrrrrrrp|\n    +-----------+\n    \"\"\"\n    reduced = im.reduce(factor)\n\n    if not isinstance(factor, (list, tuple)):\n        factor = (factor, factor)\n\n    reference = Image.new(im.mode, reduced.size)\n    area_size = (im.size[0] // factor[0], im.size[1] // factor[1])\n    area_box = (0, 0, area_size[0] * factor[0], area_size[1] * factor[1])\n    area = im.resize(area_size, Image.Resampling.BOX, area_box)\n    reference.paste(area, (0, 0))\n\n    if area_size[0] < reduced.size[0]:\n        assert reduced.size[0] - area_size[0] == 1\n        last_column_box = (area_box[2], 0, im.size[0], area_box[3])\n        last_column = im.resize(\n            (1, area_size[1]), Image.Resampling.BOX, last_column_box\n        )\n        reference.paste(last_column, (area_size[0], 0))\n\n    if area_size[1] < reduced.size[1]:\n        assert reduced.size[1] - area_size[1] == 1\n        last_row_box = (0, area_box[3], area_box[2], im.size[1])\n        last_row = im.resize((area_size[0], 1), Image.Resampling.BOX, last_row_box)\n        reference.paste(last_row, (0, area_size[1]))\n\n    if area_size[0] < reduced.size[0] and area_size[1] < reduced.size[1]:\n        last_pixel_box = (area_box[2], area_box[3], im.size[0], im.size[1])\n        last_pixel = im.resize((1, 1), Image.Resampling.BOX, last_pixel_box)\n        reference.paste(last_pixel, area_size)\n\n    assert_compare_images(reduced, reference, average_diff, max_diff)\n\n\ndef assert_compare_images(\n    a: Image.Image, b: Image.Image, max_average_diff: float, max_diff: int = 255\n) -> None:\n    assert a.mode == b.mode, f\"got mode {repr(a.mode)}, expected {repr(b.mode)}\"\n    assert a.size == b.size, f\"got size {repr(a.size)}, expected {repr(b.size)}\"\n\n    a, b = convert_to_comparable(a, b)\n\n    bands = ImageMode.getmode(a.mode).bands\n    for band, ach, bch in zip(bands, a.split(), b.split()):\n        ch_diff = ImageMath.lambda_eval(\n            lambda args: args[\"convert\"](abs(args[\"a\"] - args[\"b\"]), \"L\"), a=ach, b=bch\n        )\n        ch_hist = ch_diff.histogram()\n\n        average_diff = sum(i * num for i, num in enumerate(ch_hist)) / (\n            a.size[0] * a.size[1]\n        )\n        msg = (\n            f\"average pixel value difference {average_diff:.4f} > \"\n            f\"expected {max_average_diff:.4f} for '{band}' band\"\n        )\n        assert max_average_diff >= average_diff, msg\n\n        last_diff = [i for i, num in enumerate(ch_hist) if num > 0][-1]\n        assert max_diff >= last_diff, (\n            f\"max pixel value difference {last_diff} > expected {max_diff} \"\n            f\"for '{band}' band\"\n        )\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_L(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"L\")\n    compare_reduce_with_reference(im, factor)\n    compare_reduce_with_box(im, factor)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_LA(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"LA\")\n    compare_reduce_with_reference(im, factor, 0.8, 5)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_LA_opaque(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"LA\")\n    # With opaque alpha, an error should be way smaller.\n    im.putalpha(Image.new(\"L\", im.size, 255))\n    compare_reduce_with_reference(im, factor)\n    compare_reduce_with_box(im, factor)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_La(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"La\")\n    compare_reduce_with_reference(im, factor)\n    compare_reduce_with_box(im, factor)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_RGB(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"RGB\")\n    compare_reduce_with_reference(im, factor)\n    compare_reduce_with_box(im, factor)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_RGBA(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"RGBA\")\n    compare_reduce_with_reference(im, factor, 0.8, 5)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_RGBA_opaque(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"RGBA\")\n    # With opaque alpha, an error should be way smaller.\n    im.putalpha(Image.new(\"L\", im.size, 255))\n    compare_reduce_with_reference(im, factor)\n    compare_reduce_with_box(im, factor)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_RGBa(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"RGBa\")\n    compare_reduce_with_reference(im, factor)\n    compare_reduce_with_box(im, factor)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_I(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"I\")\n    compare_reduce_with_reference(im, factor)\n    compare_reduce_with_box(im, factor)\n\n\n@pytest.mark.parametrize(\"factor\", remarkable_factors)\ndef test_mode_F(factor: int | tuple[int, int]) -> None:\n    im = get_image(\"F\")\n    compare_reduce_with_reference(im, factor, 0, 0)\n    compare_reduce_with_box(im, factor)\n\n\n@skip_unless_feature(\"jpg_2000\")\ndef test_jpeg2k() -> None:\n    with Image.open(\"Tests/images/test-card-lossless.jp2\") as im:\n        assert im.reduce(2).size == (320, 240)\n", "Tests/test_image_copy.py": "from __future__ import annotations\n\nimport copy\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import hopper, skip_unless_feature\n\n\n@pytest.mark.parametrize(\"mode\", (\"1\", \"P\", \"L\", \"RGB\", \"I\", \"F\"))\ndef test_copy(mode: str) -> None:\n    cropped_coordinates = (10, 10, 20, 20)\n    cropped_size = (10, 10)\n\n    # Internal copy method\n    im = hopper(mode)\n    out = im.copy()\n    assert out.mode == im.mode\n    assert out.size == im.size\n\n    # Python's copy method\n    im = hopper(mode)\n    out = copy.copy(im)\n    assert out.mode == im.mode\n    assert out.size == im.size\n\n    # Internal copy method on a cropped image\n    im = hopper(mode)\n    out = im.crop(cropped_coordinates).copy()\n    assert out.mode == im.mode\n    assert out.size == cropped_size\n\n    # Python's copy method on a cropped image\n    im = hopper(mode)\n    out = copy.copy(im.crop(cropped_coordinates))\n    assert out.mode == im.mode\n    assert out.size == cropped_size\n\n\ndef test_copy_zero() -> None:\n    im = Image.new(\"RGB\", (0, 0))\n    out = im.copy()\n    assert out.mode == im.mode\n    assert out.size == im.size\n\n\n@skip_unless_feature(\"libtiff\")\ndef test_deepcopy() -> None:\n    with Image.open(\"Tests/images/g4_orientation_5.tif\") as im:\n        out = copy.deepcopy(im)\n    assert out.size == (590, 88)\n", "Tests/test_image_thumbnail.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    fromstring,\n    hopper,\n    skip_unless_feature,\n    tostring,\n)\n\n\ndef test_sanity() -> None:\n    im = hopper()\n    im.thumbnail((100, 100))\n\n    assert im.size == (100, 100)\n\n\ndef test_aspect() -> None:\n    im = Image.new(\"L\", (128, 128))\n    im.thumbnail((100, 100))\n    assert im.size == (100, 100)\n\n    im = Image.new(\"L\", (128, 256))\n    im.thumbnail((100, 100))\n    assert im.size == (50, 100)\n\n    im = Image.new(\"L\", (128, 256))\n    im.thumbnail((50, 100))\n    assert im.size == (50, 100)\n\n    im = Image.new(\"L\", (256, 128))\n    im.thumbnail((100, 100))\n    assert im.size == (100, 50)\n\n    im = Image.new(\"L\", (256, 128))\n    im.thumbnail((100, 50))\n    assert im.size == (100, 50)\n\n    im = Image.new(\"L\", (64, 64))\n    im.thumbnail((100, 100))\n    assert im.size == (64, 64)\n\n    im = Image.new(\"L\", (256, 162))  # ratio is 1.5802469136\n    im.thumbnail((33, 33))\n    assert im.size == (33, 21)  # ratio is 1.5714285714\n\n    im = Image.new(\"L\", (162, 256))  # ratio is 0.6328125\n    im.thumbnail((33, 33))\n    assert im.size == (21, 33)  # ratio is 0.6363636364\n\n    im = Image.new(\"L\", (145, 100))  # ratio is 1.45\n    im.thumbnail((50, 50))\n    assert im.size == (50, 34)  # ratio is 1.47058823529\n\n    im = Image.new(\"L\", (100, 145))  # ratio is 0.689655172414\n    im.thumbnail((50, 50))\n    assert im.size == (34, 50)  # ratio is 0.68\n\n    im = Image.new(\"L\", (100, 30))  # ratio is 3.333333333333\n    im.thumbnail((75, 75))\n    assert im.size == (75, 23)  # ratio is 3.260869565217\n\n\ndef test_division_by_zero() -> None:\n    im = Image.new(\"L\", (200, 2))\n    im.thumbnail((75, 75))\n    assert im.size == (75, 1)\n\n\ndef test_float() -> None:\n    im = Image.new(\"L\", (128, 128))\n    im.thumbnail((99.9, 99.9))\n    assert im.size == (99, 99)\n\n\ndef test_no_resize() -> None:\n    # Check that draft() can resize the image to the destination size\n    with Image.open(\"Tests/images/hopper.jpg\") as im:\n        im.draft(None, (64, 64))\n        assert im.size == (64, 64)\n\n    # Test thumbnail(), where only draft() is necessary to resize the image\n    with Image.open(\"Tests/images/hopper.jpg\") as im:\n        im.thumbnail((64, 64))\n        assert im.size == (64, 64)\n\n\n@skip_unless_feature(\"libtiff\")\ndef test_load_first() -> None:\n    # load() may change the size of the image\n    # Test that thumbnail() is calling it before performing size calculations\n    with Image.open(\"Tests/images/g4_orientation_5.tif\") as im:\n        im.thumbnail((64, 64))\n        assert im.size == (64, 10)\n\n    # Test thumbnail(), without draft(),\n    # on an image that is large enough once load() has changed the size\n    with Image.open(\"Tests/images/g4_orientation_5.tif\") as im:\n        im.thumbnail((590, 88), reducing_gap=None)\n        assert im.size == (590, 88)\n\n\ndef test_load_first_unless_jpeg() -> None:\n    # Test that thumbnail() still uses draft() for JPEG\n    with Image.open(\"Tests/images/hopper.jpg\") as im:\n        draft = im.draft\n\n        def im_draft(\n            mode: str, size: tuple[int, int]\n        ) -> tuple[str, tuple[int, int, float, float]] | None:\n            result = draft(mode, size)\n            assert result is not None\n\n            return result\n\n        im.draft = im_draft\n\n        im.thumbnail((64, 64))\n\n\n# valgrind test is failing with memory allocated in libjpeg\n@pytest.mark.valgrind_known_error(reason=\"Known Failing\")\ndef test_DCT_scaling_edges() -> None:\n    # Make an image with red borders and size (N * 8) + 1 to cross DCT grid\n    im = Image.new(\"RGB\", (257, 257), \"red\")\n    im.paste(Image.new(\"RGB\", (235, 235)), (11, 11))\n\n    thumb = fromstring(tostring(im, \"JPEG\", quality=99, subsampling=0))\n    # small reducing_gap to amplify the effect\n    thumb.thumbnail((32, 32), Image.Resampling.BICUBIC, reducing_gap=1.0)\n\n    ref = im.resize((32, 32), Image.Resampling.BICUBIC)\n    # This is still JPEG, some error is present. Without the fix it is 11.5\n    assert_image_similar(thumb, ref, 1.5)\n\n\ndef test_reducing_gap_values() -> None:\n    im = hopper()\n    im.thumbnail((18, 18), Image.Resampling.BICUBIC)\n\n    ref = hopper()\n    ref.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=2.0)\n    # reducing_gap=2.0 should be the default\n    assert_image_equal(ref, im)\n\n    ref = hopper()\n    ref.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=None)\n    with pytest.raises(pytest.fail.Exception):\n        assert_image_equal(ref, im)\n\n    assert_image_similar(ref, im, 3.5)\n\n\ndef test_reducing_gap_for_DCT_scaling() -> None:\n    with Image.open(\"Tests/images/hopper.jpg\") as ref:\n        # thumbnail should call draft with reducing_gap scale\n        ref.draft(None, (18 * 3, 18 * 3))\n        ref = ref.resize((18, 18), Image.Resampling.BICUBIC)\n\n        with Image.open(\"Tests/images/hopper.jpg\") as im:\n            im.thumbnail((18, 18), Image.Resampling.BICUBIC, reducing_gap=3.0)\n\n            assert_image_similar(ref, im, 1.4)\n", "Tests/test_image_filter.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageFilter\n\nfrom .helper import assert_image_equal, hopper\n\n\n@pytest.mark.parametrize(\n    \"filter_to_apply\",\n    (\n        ImageFilter.BLUR,\n        ImageFilter.CONTOUR,\n        ImageFilter.DETAIL,\n        ImageFilter.EDGE_ENHANCE,\n        ImageFilter.EDGE_ENHANCE_MORE,\n        ImageFilter.EMBOSS,\n        ImageFilter.FIND_EDGES,\n        ImageFilter.SMOOTH,\n        ImageFilter.SMOOTH_MORE,\n        ImageFilter.SHARPEN,\n        ImageFilter.MaxFilter,\n        ImageFilter.MedianFilter,\n        ImageFilter.MinFilter,\n        ImageFilter.ModeFilter,\n        ImageFilter.GaussianBlur,\n        ImageFilter.GaussianBlur(0),\n        ImageFilter.GaussianBlur(5),\n        ImageFilter.GaussianBlur((2, 5)),\n        ImageFilter.BoxBlur(0),\n        ImageFilter.BoxBlur(5),\n        ImageFilter.BoxBlur((2, 5)),\n        ImageFilter.UnsharpMask,\n        ImageFilter.UnsharpMask(10),\n    ),\n)\n@pytest.mark.parametrize(\"mode\", (\"L\", \"I\", \"RGB\", \"CMYK\"))\ndef test_sanity(filter_to_apply: ImageFilter.Filter, mode: str) -> None:\n    im = hopper(mode)\n    if mode != \"I\" or isinstance(filter_to_apply, ImageFilter.BuiltinFilter):\n        out = im.filter(filter_to_apply)\n        assert out.mode == im.mode\n        assert out.size == im.size\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"I\", \"RGB\", \"CMYK\"))\ndef test_sanity_error(mode: str) -> None:\n    im = hopper(mode)\n    with pytest.raises(TypeError):\n        im.filter(\"hello\")  # type: ignore[arg-type]\n\n\n# crashes on small images\n@pytest.mark.parametrize(\"size\", ((1, 1), (2, 2), (3, 3)))\ndef test_crash(size: tuple[int, int]) -> None:\n    im = Image.new(\"RGB\", size)\n    im.filter(ImageFilter.SMOOTH)\n\n\n@pytest.mark.parametrize(\n    \"mode, expected\",\n    (\n        (\"1\", (4, 0)),\n        (\"L\", (4, 0)),\n        (\"P\", (4, 0)),\n        (\"RGB\", ((4, 0, 0), (0, 0, 0))),\n    ),\n)\ndef test_modefilter(\n    mode: str,\n    expected: tuple[int, int] | tuple[tuple[int, int, int], tuple[int, int, int]],\n) -> None:\n    im = Image.new(mode, (3, 3), None)\n    im.putdata(list(range(9)))\n    # image is:\n    #   0 1 2\n    #   3 4 5\n    #   6 7 8\n    mod = im.filter(ImageFilter.ModeFilter).getpixel((1, 1))\n    im.putdata([0, 0, 1, 2, 5, 1, 5, 2, 0])  # mode=0\n    mod2 = im.filter(ImageFilter.ModeFilter).getpixel((1, 1))\n    assert (mod, mod2) == expected\n\n\n@pytest.mark.parametrize(\n    \"mode, expected\",\n    (\n        (\"1\", (0, 4, 8)),\n        (\"L\", (0, 4, 8)),\n        (\"RGB\", ((0, 0, 0), (4, 0, 0), (8, 0, 0))),\n        (\"I\", (0, 4, 8)),\n        (\"F\", (0.0, 4.0, 8.0)),\n    ),\n)\ndef test_rankfilter(\n    mode: str,\n    expected: (\n        tuple[float, float, float]\n        | tuple[tuple[int, int, int], tuple[int, int, int], tuple[int, int, int]]\n    ),\n) -> None:\n    im = Image.new(mode, (3, 3), None)\n    im.putdata(list(range(9)))\n    # image is:\n    #   0 1 2\n    #   3 4 5\n    #   6 7 8\n    minimum = im.filter(ImageFilter.MinFilter).getpixel((1, 1))\n    med = im.filter(ImageFilter.MedianFilter).getpixel((1, 1))\n    maximum = im.filter(ImageFilter.MaxFilter).getpixel((1, 1))\n    assert (minimum, med, maximum) == expected\n\n\n@pytest.mark.parametrize(\n    \"filter\", (ImageFilter.MinFilter, ImageFilter.MedianFilter, ImageFilter.MaxFilter)\n)\ndef test_rankfilter_error(filter: ImageFilter.RankFilter) -> None:\n    with pytest.raises(ValueError):\n        im = Image.new(\"P\", (3, 3), None)\n        im.putdata(list(range(9)))\n        # image is:\n        #   0 1 2\n        #   3 4 5\n        #   6 7 8\n        im.filter(filter).getpixel((1, 1))\n\n\ndef test_rankfilter_properties() -> None:\n    rankfilter = ImageFilter.RankFilter(1, 2)\n\n    assert rankfilter.size == 1\n    assert rankfilter.rank == 2\n\n\ndef test_builtinfilter_p() -> None:\n    builtin_filter = ImageFilter.BuiltinFilter()\n\n    with pytest.raises(ValueError):\n        builtin_filter.filter(hopper(\"P\").im)\n\n\ndef test_kernel_not_enough_coefficients() -> None:\n    with pytest.raises(ValueError):\n        ImageFilter.Kernel((3, 3), (0, 0))\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"LA\", \"I\", \"RGB\", \"CMYK\"))\ndef test_consistency_3x3(mode: str) -> None:\n    with Image.open(\"Tests/images/hopper.bmp\") as source:\n        with Image.open(\"Tests/images/hopper_emboss.bmp\") as reference:\n            kernel = ImageFilter.Kernel(\n                (3, 3),\n                # fmt: off\n                (-1, -1,  0,\n                 -1,  0,  1,\n                 0,   1,  1),\n                # fmt: on\n                0.3,\n            )\n            assert_image_equal(source.filter(kernel), reference)\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"LA\", \"I\", \"RGB\", \"CMYK\"))\ndef test_consistency_5x5(mode: str) -> None:\n    with Image.open(\"Tests/images/hopper.bmp\") as source:\n        with Image.open(\"Tests/images/hopper_emboss_more.bmp\") as reference:\n            kernel = ImageFilter.Kernel(\n                (5, 5),\n                # fmt: off\n                (-1, -1, -1, -1,  0,\n                 -1, -1, -1,  0,  1,\n                 -1, -1,  0,  1,  1,\n                 -1,  0,  1,  1,  1,\n                 0,   1,  1,  1,  1),\n                # fmt: on\n                0.3,\n            )\n            assert_image_equal(source.filter(kernel), reference)\n\n\n@pytest.mark.parametrize(\n    \"radius\",\n    (\n        -2,\n        (-2, -2),\n        (-2, 2),\n        (2, -2),\n    ),\n)\ndef test_invalid_box_blur_filter(radius: int | tuple[int, int]) -> None:\n    with pytest.raises(ValueError):\n        ImageFilter.BoxBlur(radius)\n\n    im = hopper()\n    box_blur_filter = ImageFilter.BoxBlur(2)\n    box_blur_filter.radius = radius\n    with pytest.raises(ValueError):\n        im.filter(box_blur_filter)\n", "Tests/test_imageshow.py": "from __future__ import annotations\n\nfrom typing import Any\n\nimport pytest\n\nfrom PIL import Image, ImageShow\n\nfrom .helper import hopper, is_win32, on_ci\n\n\ndef test_sanity() -> None:\n    dir(Image)\n    dir(ImageShow)\n\n\ndef test_register() -> None:\n    # Test registering a viewer that is not a class\n    ImageShow.register(\"not a class\")\n\n    # Restore original state\n    ImageShow._viewers.pop()\n\n\n@pytest.mark.parametrize(\n    \"order\",\n    [-1, 0],\n)\ndef test_viewer_show(order: int) -> None:\n    class TestViewer(ImageShow.Viewer):\n        def show_image(self, image: Image.Image, **options: Any) -> bool:\n            self.methodCalled = True\n            return True\n\n    viewer = TestViewer()\n    ImageShow.register(viewer, order)\n\n    for mode in (\"1\", \"I;16\", \"LA\", \"RGB\", \"RGBA\"):\n        viewer.methodCalled = False\n        with hopper(mode) as im:\n            assert ImageShow.show(im)\n        assert viewer.methodCalled\n\n    # Restore original state\n    ImageShow._viewers.pop(0)\n\n\n@pytest.mark.skipif(\n    not on_ci() or is_win32(),\n    reason=\"Only run on CIs; hangs on Windows CIs\",\n)\n@pytest.mark.parametrize(\"mode\", (\"1\", \"I;16\", \"LA\", \"RGB\", \"RGBA\"))\ndef test_show(mode: str) -> None:\n    im = hopper(mode)\n    assert ImageShow.show(im)\n\n\ndef test_show_without_viewers() -> None:\n    viewers = ImageShow._viewers\n    ImageShow._viewers = []\n\n    with hopper() as im:\n        assert not ImageShow.show(im)\n\n    ImageShow._viewers = viewers\n\n\ndef test_viewer() -> None:\n    viewer = ImageShow.Viewer()\n\n    im = Image.new(\"L\", (1, 1))\n    assert viewer.get_format(im) is None\n\n    with pytest.raises(NotImplementedError):\n        viewer.get_command(\"\")\n\n\n@pytest.mark.parametrize(\"viewer\", ImageShow._viewers)\ndef test_viewers(viewer: ImageShow.Viewer) -> None:\n    try:\n        viewer.get_command(\"test.jpg\")\n    except NotImplementedError:\n        pass\n\n\ndef test_ipythonviewer() -> None:\n    pytest.importorskip(\"IPython\", reason=\"IPython not installed\")\n    for viewer in ImageShow._viewers:\n        if isinstance(viewer, ImageShow.IPythonViewer):\n            test_viewer = viewer\n            break\n    else:\n        pytest.fail()\n\n    im = hopper()\n    assert test_viewer.show(im) == 1\n", "Tests/test_image_resize.py": "\"\"\"\nTests for resize functionality.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom itertools import permutations\nfrom pathlib import Path\nfrom typing import Generator\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    hopper,\n    skip_unless_feature,\n)\n\n\nclass TestImagingCoreResize:\n    def resize(\n        self, im: Image.Image, size: tuple[int, int], f: Image.Resampling\n    ) -> Image.Image:\n        # Image class independent version of resize.\n        im.load()\n        return im._new(im.im.resize(size, f))\n\n    @pytest.mark.parametrize(\n        \"mode\", (\"1\", \"P\", \"L\", \"I\", \"F\", \"RGB\", \"RGBA\", \"CMYK\", \"YCbCr\", \"I;16\")\n    )\n    def test_nearest_mode(self, mode: str) -> None:\n        im = hopper(mode)\n        r = self.resize(im, (15, 12), Image.Resampling.NEAREST)\n        assert r.mode == mode\n        assert r.size == (15, 12)\n        assert r.im.bands == im.im.bands\n\n    def test_convolution_modes(self) -> None:\n        with pytest.raises(ValueError):\n            self.resize(hopper(\"1\"), (15, 12), Image.Resampling.BILINEAR)\n        with pytest.raises(ValueError):\n            self.resize(hopper(\"P\"), (15, 12), Image.Resampling.BILINEAR)\n        with pytest.raises(ValueError):\n            self.resize(hopper(\"I;16\"), (15, 12), Image.Resampling.BILINEAR)\n        for mode in [\"L\", \"I\", \"F\", \"RGB\", \"RGBA\", \"CMYK\", \"YCbCr\"]:\n            im = hopper(mode)\n            r = self.resize(im, (15, 12), Image.Resampling.BILINEAR)\n            assert r.mode == mode\n            assert r.size == (15, 12)\n            assert r.im.bands == im.im.bands\n\n    @pytest.mark.parametrize(\n        \"resample\",\n        (\n            Image.Resampling.NEAREST,\n            Image.Resampling.BOX,\n            Image.Resampling.BILINEAR,\n            Image.Resampling.HAMMING,\n            Image.Resampling.BICUBIC,\n            Image.Resampling.LANCZOS,\n        ),\n    )\n    def test_reduce_filters(self, resample: Image.Resampling) -> None:\n        r = self.resize(hopper(\"RGB\"), (15, 12), resample)\n        assert r.mode == \"RGB\"\n        assert r.size == (15, 12)\n\n    @pytest.mark.parametrize(\n        \"resample\",\n        (\n            Image.Resampling.NEAREST,\n            Image.Resampling.BOX,\n            Image.Resampling.BILINEAR,\n            Image.Resampling.HAMMING,\n            Image.Resampling.BICUBIC,\n            Image.Resampling.LANCZOS,\n        ),\n    )\n    def test_enlarge_filters(self, resample: Image.Resampling) -> None:\n        r = self.resize(hopper(\"RGB\"), (212, 195), resample)\n        assert r.mode == \"RGB\"\n        assert r.size == (212, 195)\n\n    @pytest.mark.parametrize(\n        \"resample\",\n        (\n            Image.Resampling.NEAREST,\n            Image.Resampling.BOX,\n            Image.Resampling.BILINEAR,\n            Image.Resampling.HAMMING,\n            Image.Resampling.BICUBIC,\n            Image.Resampling.LANCZOS,\n        ),\n    )\n    @pytest.mark.parametrize(\n        \"mode, channels_set\",\n        (\n            (\"RGB\", (\"blank\", \"filled\", \"dirty\")),\n            (\"RGBA\", (\"blank\", \"blank\", \"filled\", \"dirty\")),\n            (\"LA\", (\"filled\", \"dirty\")),\n        ),\n    )\n    def test_endianness(\n        self, resample: Image.Resampling, mode: str, channels_set: tuple[str, ...]\n    ) -> None:\n        # Make an image with one colored pixel, in one channel.\n        # When resized, that channel should be the same as a GS image.\n        # Other channels should be unaffected.\n        # The R and A channels should not swap, which is indicative of\n        # an endianness issues.\n\n        samples = {\n            \"blank\": Image.new(\"L\", (2, 2), 0),\n            \"filled\": Image.new(\"L\", (2, 2), 255),\n            \"dirty\": Image.new(\"L\", (2, 2), 0),\n        }\n        samples[\"dirty\"].putpixel((1, 1), 128)\n\n        # samples resized with current filter\n        references = {\n            name: self.resize(ch, (4, 4), resample) for name, ch in samples.items()\n        }\n\n        for channels in set(permutations(channels_set)):\n            # compile image from different channels permutations\n            im = Image.merge(mode, [samples[ch] for ch in channels])\n            resized = self.resize(im, (4, 4), resample)\n\n            for i, ch in enumerate(resized.split()):\n                # check what resized channel in image is the same\n                # as separately resized channel\n                assert_image_equal(ch, references[channels[i]])\n\n    @pytest.mark.parametrize(\n        \"resample\",\n        (\n            Image.Resampling.NEAREST,\n            Image.Resampling.BOX,\n            Image.Resampling.BILINEAR,\n            Image.Resampling.HAMMING,\n            Image.Resampling.BICUBIC,\n            Image.Resampling.LANCZOS,\n        ),\n    )\n    def test_enlarge_zero(self, resample: Image.Resampling) -> None:\n        r = self.resize(Image.new(\"RGB\", (0, 0), \"white\"), (212, 195), resample)\n        assert r.mode == \"RGB\"\n        assert r.size == (212, 195)\n        assert r.getdata()[0] == (0, 0, 0)\n\n    def test_unknown_filter(self) -> None:\n        with pytest.raises(ValueError):\n            self.resize(hopper(), (10, 10), 9)  # type: ignore[arg-type]\n\n    def test_cross_platform(self, tmp_path: Path) -> None:\n        # This test is intended for only check for consistent behaviour across\n        # platforms. So if a future Pillow change requires that the test file\n        # be updated, that is okay.\n        im = hopper().resize((64, 64))\n        temp_file = str(tmp_path / \"temp.gif\")\n        im.save(temp_file)\n\n        with Image.open(temp_file) as reloaded:\n            assert_image_equal_tofile(reloaded, \"Tests/images/hopper_resized.gif\")\n\n\n@pytest.fixture\ndef gradients_image() -> Generator[Image.Image, None, None]:\n    with Image.open(\"Tests/images/radial_gradients.png\") as im:\n        im.load()\n    try:\n        yield im\n    finally:\n        im.close()\n\n\nclass TestReducingGapResize:\n    def test_reducing_gap_values(self, gradients_image: Image.Image) -> None:\n        ref = gradients_image.resize(\n            (52, 34), Image.Resampling.BICUBIC, reducing_gap=None\n        )\n        im = gradients_image.resize((52, 34), Image.Resampling.BICUBIC)\n        assert_image_equal(ref, im)\n\n        with pytest.raises(ValueError):\n            gradients_image.resize((52, 34), Image.Resampling.BICUBIC, reducing_gap=0)\n\n        with pytest.raises(ValueError):\n            gradients_image.resize(\n                (52, 34), Image.Resampling.BICUBIC, reducing_gap=0.99\n            )\n\n    @pytest.mark.parametrize(\n        \"box, epsilon\",\n        ((None, 4), ((1.1, 2.2, 510.8, 510.9), 4), ((3, 10, 410, 256), 10)),\n    )\n    def test_reducing_gap_1(\n        self,\n        gradients_image: Image.Image,\n        box: tuple[float, float, float, float],\n        epsilon: float,\n    ) -> None:\n        ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)\n        im = gradients_image.resize(\n            (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=1.0\n        )\n\n        with pytest.raises(pytest.fail.Exception):\n            assert_image_equal(ref, im)\n\n        assert_image_similar(ref, im, epsilon)\n\n    @pytest.mark.parametrize(\n        \"box, epsilon\",\n        ((None, 1.5), ((1.1, 2.2, 510.8, 510.9), 1.5), ((3, 10, 410, 256), 1)),\n    )\n    def test_reducing_gap_2(\n        self,\n        gradients_image: Image.Image,\n        box: tuple[float, float, float, float],\n        epsilon: float,\n    ) -> None:\n        ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)\n        im = gradients_image.resize(\n            (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=2.0\n        )\n\n        with pytest.raises(pytest.fail.Exception):\n            assert_image_equal(ref, im)\n\n        assert_image_similar(ref, im, epsilon)\n\n    @pytest.mark.parametrize(\n        \"box, epsilon\",\n        ((None, 1), ((1.1, 2.2, 510.8, 510.9), 1), ((3, 10, 410, 256), 0.5)),\n    )\n    def test_reducing_gap_3(\n        self,\n        gradients_image: Image.Image,\n        box: tuple[float, float, float, float],\n        epsilon: float,\n    ) -> None:\n        ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)\n        im = gradients_image.resize(\n            (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=3.0\n        )\n\n        with pytest.raises(pytest.fail.Exception):\n            assert_image_equal(ref, im)\n\n        assert_image_similar(ref, im, epsilon)\n\n    @pytest.mark.parametrize(\"box\", (None, (1.1, 2.2, 510.8, 510.9), (3, 10, 410, 256)))\n    def test_reducing_gap_8(\n        self, gradients_image: Image.Image, box: tuple[float, float, float, float]\n    ) -> None:\n        ref = gradients_image.resize((52, 34), Image.Resampling.BICUBIC, box=box)\n        im = gradients_image.resize(\n            (52, 34), Image.Resampling.BICUBIC, box=box, reducing_gap=8.0\n        )\n\n        assert_image_equal(ref, im)\n\n    @pytest.mark.parametrize(\n        \"box, epsilon\",\n        (((0, 0, 512, 512), 5.5), ((0.9, 1.7, 128, 128), 9.5)),\n    )\n    def test_box_filter(\n        self,\n        gradients_image: Image.Image,\n        box: tuple[float, float, float, float],\n        epsilon: float,\n    ) -> None:\n        ref = gradients_image.resize((52, 34), Image.Resampling.BOX, box=box)\n        im = gradients_image.resize(\n            (52, 34), Image.Resampling.BOX, box=box, reducing_gap=1.0\n        )\n\n        assert_image_similar(ref, im, epsilon)\n\n\nclass TestImageResize:\n    def test_resize(self) -> None:\n        def resize(mode: str, size: tuple[int, int]) -> None:\n            out = hopper(mode).resize(size)\n            assert out.mode == mode\n            assert out.size == size\n\n        for mode in \"1\", \"P\", \"L\", \"RGB\", \"I\", \"F\":\n            resize(mode, (112, 103))\n            resize(mode, (188, 214))\n\n        # Test unknown resampling filter\n        with hopper() as im:\n            with pytest.raises(ValueError):\n                im.resize((10, 10), \"unknown\")\n\n    @skip_unless_feature(\"libtiff\")\n    def test_load_first(self) -> None:\n        # load() may change the size of the image\n        # Test that resize() is calling it before getting the size\n        with Image.open(\"Tests/images/g4_orientation_5.tif\") as im:\n            im = im.resize((64, 64))\n            assert im.size == (64, 64)\n\n    @pytest.mark.parametrize(\"mode\", (\"L\", \"RGB\", \"I\", \"F\"))\n    def test_default_filter_bicubic(self, mode: str) -> None:\n        im = hopper(mode)\n        assert im.resize((20, 20), Image.Resampling.BICUBIC) == im.resize((20, 20))\n\n    @pytest.mark.parametrize(\n        \"mode\", (\"1\", \"P\", \"I;16\", \"I;16L\", \"I;16B\", \"BGR;15\", \"BGR;16\")\n    )\n    def test_default_filter_nearest(self, mode: str) -> None:\n        im = hopper(mode)\n        assert im.resize((20, 20), Image.Resampling.NEAREST) == im.resize((20, 20))\n", "Tests/createfontdatachunk.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport base64\nimport os\n\nif __name__ == \"__main__\":\n    # create font data chunk for embedding\n    font = \"Tests/images/courB08\"\n    print(\"    f._load_pilfont_data(\")\n    print(f\"         # {os.path.basename(font)}\")\n    print(\"         BytesIO(base64.decodestring(b'''\")\n    with open(font + \".pil\", \"rb\") as fp:\n        print(base64.b64encode(fp.read()).decode())\n    print(\"''')), Image.open(BytesIO(base64.decodestring(b'''\")\n    with open(font + \".pbm\", \"rb\") as fp:\n        print(base64.b64encode(fp.read()).decode())\n    print(\"'''))))\")\n", "Tests/test_imagefile.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom typing import Any\n\nimport pytest\n\nfrom PIL import (\n    BmpImagePlugin,\n    EpsImagePlugin,\n    Image,\n    ImageFile,\n    UnidentifiedImageError,\n    _binary,\n    features,\n)\n\nfrom .helper import (\n    assert_image,\n    assert_image_equal,\n    assert_image_similar,\n    fromstring,\n    hopper,\n    skip_unless_feature,\n    tostring,\n)\n\n# save original block sizes\nMAXBLOCK = ImageFile.MAXBLOCK\nSAFEBLOCK = ImageFile.SAFEBLOCK\n\n\nclass TestImageFile:\n    def test_parser(self) -> None:\n        def roundtrip(format: str) -> tuple[Image.Image, Image.Image]:\n            im = hopper(\"L\").resize((1000, 1000), Image.Resampling.NEAREST)\n            if format in (\"MSP\", \"XBM\"):\n                im = im.convert(\"1\")\n\n            test_file = BytesIO()\n\n            im.copy().save(test_file, format)\n\n            data = test_file.getvalue()\n\n            parser = ImageFile.Parser()\n            parser.feed(data)\n            im_out = parser.close()\n\n            return im, im_out\n\n        assert_image_equal(*roundtrip(\"BMP\"))\n        im1, im2 = roundtrip(\"GIF\")\n        assert_image_similar(im1.convert(\"P\"), im2, 1)\n        assert_image_equal(*roundtrip(\"IM\"))\n        assert_image_equal(*roundtrip(\"MSP\"))\n        if features.check(\"zlib\"):\n            try:\n                # force multiple blocks in PNG driver\n                ImageFile.MAXBLOCK = 8192\n                assert_image_equal(*roundtrip(\"PNG\"))\n            finally:\n                ImageFile.MAXBLOCK = MAXBLOCK\n        assert_image_equal(*roundtrip(\"PPM\"))\n        assert_image_equal(*roundtrip(\"TIFF\"))\n        assert_image_equal(*roundtrip(\"XBM\"))\n        assert_image_equal(*roundtrip(\"TGA\"))\n        assert_image_equal(*roundtrip(\"PCX\"))\n\n        if EpsImagePlugin.has_ghostscript():\n            im1, im2 = roundtrip(\"EPS\")\n            # This test fails on Ubuntu 12.04, PPC (Bigendian) It\n            # appears to be a ghostscript 9.05 bug, since the\n            # ghostscript rendering is wonky and the file is identical\n            # to that written on ubuntu 12.04 x64\n            # md5sum: ba974835ff2d6f3f2fd0053a23521d4a\n\n            # EPS comes back in RGB:\n            assert_image_similar(im1, im2.convert(\"L\"), 20)\n\n        if features.check(\"jpg\"):\n            im1, im2 = roundtrip(\"JPEG\")  # lossy compression\n            assert_image(im1, im2.mode, im2.size)\n\n        with pytest.raises(OSError):\n            roundtrip(\"PDF\")\n\n    def test_ico(self) -> None:\n        with open(\"Tests/images/python.ico\", \"rb\") as f:\n            data = f.read()\n        with ImageFile.Parser() as p:\n            p.feed(data)\n            assert (48, 48) == p.image.size\n\n    @skip_unless_feature(\"webp\")\n    @skip_unless_feature(\"webp_anim\")\n    def test_incremental_webp(self) -> None:\n        with ImageFile.Parser() as p:\n            with open(\"Tests/images/hopper.webp\", \"rb\") as f:\n                p.feed(f.read(1024))\n\n                # Check that insufficient data was given in the first feed\n                assert not p.image\n\n                p.feed(f.read())\n            assert (128, 128) == p.image.size\n\n    @skip_unless_feature(\"zlib\")\n    def test_safeblock(self) -> None:\n        im1 = hopper()\n\n        try:\n            ImageFile.SAFEBLOCK = 1\n            im2 = fromstring(tostring(im1, \"PNG\"))\n        finally:\n            ImageFile.SAFEBLOCK = SAFEBLOCK\n\n        assert_image_equal(im1, im2)\n\n    def test_raise_oserror(self) -> None:\n        with pytest.warns(DeprecationWarning):\n            with pytest.raises(OSError):\n                ImageFile.raise_oserror(1)\n\n    def test_raise_typeerror(self) -> None:\n        with pytest.raises(TypeError):\n            parser = ImageFile.Parser()\n            parser.feed(1)\n\n    def test_negative_stride(self) -> None:\n        with open(\"Tests/images/raw_negative_stride.bin\", \"rb\") as f:\n            input = f.read()\n        p = ImageFile.Parser()\n        p.feed(input)\n        with pytest.raises(OSError):\n            p.close()\n\n    def test_no_format(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        class DummyImageFile(ImageFile.ImageFile):\n            def _open(self) -> None:\n                self._mode = \"RGB\"\n                self._size = (1, 1)\n\n        im = DummyImageFile(buf)\n        assert im.format is None\n        assert im.get_format_mimetype() is None\n\n    def test_oserror(self) -> None:\n        im = Image.new(\"RGB\", (1, 1))\n        with pytest.raises(OSError):\n            im.save(BytesIO(), \"JPEG2000\", num_resolutions=2)\n\n    def test_truncated(self) -> None:\n        b = BytesIO(\n            b\"BM000000000000\"  # head_data\n            + _binary.o32le(\n                ImageFile.SAFEBLOCK + 1 + 4\n            )  # header_size, so BmpImagePlugin will try to read SAFEBLOCK + 1 bytes\n            + (\n                b\"0\" * ImageFile.SAFEBLOCK\n            )  # only SAFEBLOCK bytes, so that the header is truncated\n        )\n        with pytest.raises(OSError) as e:\n            BmpImagePlugin.BmpImageFile(b)\n        assert str(e.value) == \"Truncated File Read\"\n\n    @skip_unless_feature(\"zlib\")\n    def test_truncated_with_errors(self) -> None:\n        with Image.open(\"Tests/images/truncated_image.png\") as im:\n            with pytest.raises(OSError):\n                im.load()\n\n            # Test that the error is raised if loaded a second time\n            with pytest.raises(OSError):\n                im.load()\n\n    @skip_unless_feature(\"zlib\")\n    def test_truncated_without_errors(self) -> None:\n        with Image.open(\"Tests/images/truncated_image.png\") as im:\n            ImageFile.LOAD_TRUNCATED_IMAGES = True\n            try:\n                im.load()\n            finally:\n                ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    @skip_unless_feature(\"zlib\")\n    def test_broken_datastream_with_errors(self) -> None:\n        with Image.open(\"Tests/images/broken_data_stream.png\") as im:\n            with pytest.raises(OSError):\n                im.load()\n\n    @skip_unless_feature(\"zlib\")\n    def test_broken_datastream_without_errors(self) -> None:\n        with Image.open(\"Tests/images/broken_data_stream.png\") as im:\n            ImageFile.LOAD_TRUNCATED_IMAGES = True\n            try:\n                im.load()\n            finally:\n                ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n\nclass MockPyDecoder(ImageFile.PyDecoder):\n    last: MockPyDecoder\n\n    def __init__(self, mode: str, *args: Any) -> None:\n        MockPyDecoder.last = self\n\n        super().__init__(mode, *args)\n\n    def decode(self, buffer):\n        # eof\n        return -1, 0\n\n\nclass MockPyEncoder(ImageFile.PyEncoder):\n    last: MockPyEncoder | None\n\n    def __init__(self, mode: str, *args: Any) -> None:\n        MockPyEncoder.last = self\n\n        super().__init__(mode, *args)\n\n    def encode(self, buffer):\n        return 1, 1, b\"\"\n\n    def cleanup(self) -> None:\n        self.cleanup_called = True\n\n\nxoff, yoff, xsize, ysize = 10, 20, 100, 100\n\n\nclass MockImageFile(ImageFile.ImageFile):\n    def _open(self) -> None:\n        self.rawmode = \"RGBA\"\n        self._mode = \"RGBA\"\n        self._size = (200, 200)\n        self.tile = [(\"MOCK\", (xoff, yoff, xoff + xsize, yoff + ysize), 32, None)]\n\n\nclass CodecsTest:\n    @classmethod\n    def setup_class(cls) -> None:\n        Image.register_decoder(\"MOCK\", MockPyDecoder)\n        Image.register_encoder(\"MOCK\", MockPyEncoder)\n\n\nclass TestPyDecoder(CodecsTest):\n    def test_setimage(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n\n        im.load()\n\n        assert MockPyDecoder.last.state.xoff == xoff\n        assert MockPyDecoder.last.state.yoff == yoff\n        assert MockPyDecoder.last.state.xsize == xsize\n        assert MockPyDecoder.last.state.ysize == ysize\n\n        with pytest.raises(ValueError):\n            MockPyDecoder.last.set_as_raw(b\"\\x00\")\n\n    def test_extents_none(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n        im.tile = [(\"MOCK\", None, 32, None)]\n\n        im.load()\n\n        assert MockPyDecoder.last.state.xoff == 0\n        assert MockPyDecoder.last.state.yoff == 0\n        assert MockPyDecoder.last.state.xsize == 200\n        assert MockPyDecoder.last.state.ysize == 200\n\n    def test_negsize(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n        im.tile = [(\"MOCK\", (xoff, yoff, -10, yoff + ysize), 32, None)]\n\n        with pytest.raises(ValueError):\n            im.load()\n\n        im.tile = [(\"MOCK\", (xoff, yoff, xoff + xsize, -10), 32, None)]\n        with pytest.raises(ValueError):\n            im.load()\n\n    def test_oversize(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n        im.tile = [(\"MOCK\", (xoff, yoff, xoff + xsize + 100, yoff + ysize), 32, None)]\n\n        with pytest.raises(ValueError):\n            im.load()\n\n        im.tile = [(\"MOCK\", (xoff, yoff, xoff + xsize, yoff + ysize + 100), 32, None)]\n        with pytest.raises(ValueError):\n            im.load()\n\n    def test_decode(self) -> None:\n        decoder = ImageFile.PyDecoder(None)\n        with pytest.raises(NotImplementedError):\n            decoder.decode(None)\n\n\nclass TestPyEncoder(CodecsTest):\n    def test_setimage(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n\n        fp = BytesIO()\n        ImageFile._save(\n            im, fp, [(\"MOCK\", (xoff, yoff, xoff + xsize, yoff + ysize), 0, \"RGB\")]\n        )\n\n        assert MockPyEncoder.last\n        assert MockPyEncoder.last.state.xoff == xoff\n        assert MockPyEncoder.last.state.yoff == yoff\n        assert MockPyEncoder.last.state.xsize == xsize\n        assert MockPyEncoder.last.state.ysize == ysize\n\n    def test_extents_none(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n        im.tile = [(\"MOCK\", None, 32, None)]\n\n        fp = BytesIO()\n        ImageFile._save(im, fp, [(\"MOCK\", None, 0, \"RGB\")])\n\n        assert MockPyEncoder.last\n        assert MockPyEncoder.last.state.xoff == 0\n        assert MockPyEncoder.last.state.yoff == 0\n        assert MockPyEncoder.last.state.xsize == 200\n        assert MockPyEncoder.last.state.ysize == 200\n\n    def test_negsize(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n\n        fp = BytesIO()\n        MockPyEncoder.last = None\n        with pytest.raises(ValueError):\n            ImageFile._save(\n                im, fp, [(\"MOCK\", (xoff, yoff, -10, yoff + ysize), 0, \"RGB\")]\n            )\n        last: MockPyEncoder | None = MockPyEncoder.last\n        assert last\n        assert last.cleanup_called\n\n        with pytest.raises(ValueError):\n            ImageFile._save(\n                im, fp, [(\"MOCK\", (xoff, yoff, xoff + xsize, -10), 0, \"RGB\")]\n            )\n\n    def test_oversize(self) -> None:\n        buf = BytesIO(b\"\\x00\" * 255)\n\n        im = MockImageFile(buf)\n\n        fp = BytesIO()\n        with pytest.raises(ValueError):\n            ImageFile._save(\n                im,\n                fp,\n                [(\"MOCK\", (xoff, yoff, xoff + xsize + 100, yoff + ysize), 0, \"RGB\")],\n            )\n\n        with pytest.raises(ValueError):\n            ImageFile._save(\n                im,\n                fp,\n                [(\"MOCK\", (xoff, yoff, xoff + xsize, yoff + ysize + 100), 0, \"RGB\")],\n            )\n\n    def test_encode(self) -> None:\n        encoder = ImageFile.PyEncoder(None)\n        with pytest.raises(NotImplementedError):\n            encoder.encode(0)\n\n        bytes_consumed, errcode = encoder.encode_to_pyfd()\n        assert bytes_consumed == 0\n        assert ImageFile.ERRORS[errcode] == \"bad configuration\"\n\n        encoder._pushes_fd = True\n        with pytest.raises(NotImplementedError):\n            encoder.encode_to_pyfd()\n\n        with pytest.raises(NotImplementedError):\n            encoder.encode_to_file(None, None)\n\n    def test_zero_height(self) -> None:\n        with pytest.raises(UnidentifiedImageError):\n            Image.open(\"Tests/images/zero_height.j2k\")\n", "Tests/test_image_getcolors.py": "from __future__ import annotations\n\nfrom .helper import hopper\n\n\ndef test_getcolors() -> None:\n    def getcolors(mode: str, limit: int | None = None) -> int | None:\n        im = hopper(mode)\n        if limit:\n            colors = im.getcolors(limit)\n        else:\n            colors = im.getcolors()\n        if colors:\n            return len(colors)\n        return None\n\n    assert getcolors(\"1\") == 2\n    assert getcolors(\"L\") == 255\n    assert getcolors(\"I\") == 255\n    assert getcolors(\"F\") == 255\n    assert getcolors(\"P\") == 96  # fixed palette\n    assert getcolors(\"RGB\") is None\n    assert getcolors(\"RGBA\") is None\n    assert getcolors(\"CMYK\") is None\n    assert getcolors(\"YCbCr\") is None\n\n    assert getcolors(\"L\", 128) is None\n    assert getcolors(\"L\", 1024) == 255\n\n    assert getcolors(\"RGB\", 8192) is None\n    assert getcolors(\"RGB\", 16384) == 10100\n    assert getcolors(\"RGB\", 100000) == 10100\n\n    assert getcolors(\"RGBA\", 16384) == 10100\n    assert getcolors(\"CMYK\", 16384) == 10100\n    assert getcolors(\"YCbCr\", 16384) == 9329\n\n\n# --------------------------------------------------------------------\n\n\ndef test_pack() -> None:\n    # Pack problems for small tables (@PIL209)\n\n    im = hopper().quantize(3).convert(\"RGB\")\n\n    expected = [\n        (4039, (172, 166, 181)),\n        (4385, (124, 113, 134)),\n        (7960, (31, 20, 33)),\n    ]\n\n    A = im.getcolors(maxcolors=2)\n    assert A is None\n\n    A = im.getcolors(maxcolors=3)\n    A.sort()\n    assert A == expected\n\n    A = im.getcolors(maxcolors=4)\n    A.sort()\n    assert A == expected\n\n    A = im.getcolors(maxcolors=8)\n    A.sort()\n    assert A == expected\n\n    A = im.getcolors(maxcolors=16)\n    A.sort()\n    assert A == expected\n", "Tests/test_imagedraw.py": "from __future__ import annotations\n\nimport contextlib\nimport os.path\nfrom typing import Sequence\n\nimport pytest\n\nfrom PIL import Image, ImageColor, ImageDraw, ImageFont, features\nfrom PIL._typing import Coords\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar_tofile,\n    hopper,\n    skip_unless_feature,\n)\n\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nGRAY = (190, 190, 190)\nDEFAULT_MODE = \"RGB\"\nIMAGES_PATH = os.path.join(\"Tests\", \"images\", \"imagedraw\")\n\n# Image size\nW, H = 100, 100\n\n# Bounding box points\nX0 = int(W / 4)\nX1 = int(X0 * 3)\nY0 = int(H / 4)\nY1 = int(X0 * 3)\n\n# Bounding boxes\nBBOX = (((X0, Y0), (X1, Y1)), [(X0, Y0), (X1, Y1)], (X0, Y0, X1, Y1), [X0, Y0, X1, Y1])\n\n# Coordinate sequences\nPOINTS = (\n    ((10, 10), (20, 40), (30, 30)),\n    [(10, 10), (20, 40), (30, 30)],\n    (10, 10, 20, 40, 30, 30),\n    [10, 10, 20, 40, 30, 30],\n)\n\nKITE_POINTS = (\n    ((10, 50), (70, 10), (90, 50), (70, 90), (10, 50)),\n    [(10, 50), (70, 10), (90, 50), (70, 90), (10, 50)],\n)\n\n\ndef test_sanity() -> None:\n    im = hopper(\"RGB\").copy()\n\n    draw = ImageDraw.ImageDraw(im)\n    draw = ImageDraw.Draw(im)\n\n    draw.ellipse(list(range(4)))\n    draw.line(list(range(10)))\n    draw.polygon(list(range(100)))\n    draw.rectangle(list(range(4)))\n\n\ndef test_valueerror() -> None:\n    with Image.open(\"Tests/images/chi.gif\") as im:\n        draw = ImageDraw.Draw(im)\n        draw.line((0, 0), fill=(0, 0, 0))\n\n\ndef test_mode_mismatch() -> None:\n    im = hopper(\"RGB\").copy()\n\n    with pytest.raises(ValueError):\n        ImageDraw.ImageDraw(im, mode=\"L\")\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\n@pytest.mark.parametrize(\"start, end\", ((0, 180), (0.5, 180.4)))\ndef test_arc(bbox: Coords, start: float, end: float) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.arc(bbox, start, end)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_arc.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_arc_end_le_start(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    start = 270.5\n    end = 0\n\n    # Act\n    draw.arc(bbox, start=start, end=end)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_arc_end_le_start.png\")\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_arc_no_loops(bbox: Coords) -> None:\n    # No need to go in loops\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    start = 5\n    end = 370\n\n    # Act\n    draw.arc(bbox, start=start, end=end)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_arc_no_loops.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_arc_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.arc(bbox, 10, 260, width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_arc_width.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_arc_width_pieslice_large(bbox: Coords) -> None:\n    # Tests an arc with a large enough width that it is a pieslice\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.arc(bbox, 10, 260, fill=\"yellow\", width=100)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_arc_width_pieslice.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_arc_width_fill(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.arc(bbox, 10, 260, fill=\"yellow\", width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_arc_width_fill.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_arc_width_non_whole_angle(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = \"Tests/images/imagedraw_arc_width_non_whole_angle.png\"\n\n    # Act\n    draw.arc(bbox, 10, 259.5, width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 1)\n\n\ndef test_arc_high() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (200, 200))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.arc([10, 10, 89, 189], 20, 330, width=20, fill=\"white\")\n    draw.arc([110, 10, 189, 189], 20, 150, width=20, fill=\"white\")\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_arc_high.png\")\n\n\ndef test_bitmap() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    with Image.open(\"Tests/images/pil123rgba.png\") as small:\n        small = small.resize((50, 50), Image.Resampling.NEAREST)\n\n        # Act\n        draw.bitmap((10, 10), small)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_bitmap.png\")\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"L\"))\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_chord(mode: str, bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(mode, (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = f\"Tests/images/imagedraw_chord_{mode}.png\"\n\n    # Act\n    draw.chord(bbox, 0, 180, fill=\"red\", outline=\"yellow\")\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_chord_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.chord(bbox, 10, 260, outline=\"yellow\", width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_chord_width.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_chord_width_fill(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.chord(bbox, 10, 260, fill=\"red\", outline=\"yellow\", width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_chord_width_fill.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_chord_zero_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.chord(bbox, 10, 260, fill=\"red\", outline=\"yellow\", width=0)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_chord_zero_width.png\")\n\n\ndef test_chord_too_fat() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (100, 100))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.chord([-150, -150, 99, 99], 15, 60, width=10, fill=\"white\", outline=\"red\")\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_chord_too_fat.png\")\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"L\"))\n@pytest.mark.parametrize(\"xy\", ((W / 2, H / 2), [W / 2, H / 2]))\ndef test_circle(mode: str, xy: Sequence[float]) -> None:\n    # Arrange\n    im = Image.new(mode, (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = f\"Tests/images/imagedraw_ellipse_{mode}.png\"\n\n    # Act\n    draw.circle(xy, 25, fill=\"green\", outline=\"blue\")\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 1)\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"L\"))\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_ellipse(mode: str, bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(mode, (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = f\"Tests/images/imagedraw_ellipse_{mode}.png\"\n\n    # Act\n    draw.ellipse(bbox, fill=\"green\", outline=\"blue\")\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_ellipse_translucent(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im, \"RGBA\")\n\n    # Act\n    draw.ellipse(bbox, fill=(0, 255, 0, 127))\n\n    # Assert\n    expected = \"Tests/images/imagedraw_ellipse_translucent.png\"\n    assert_image_similar_tofile(im, expected, 1)\n\n\ndef test_ellipse_edge() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.ellipse(((0, 0), (W - 1, H - 1)), fill=\"white\")\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_ellipse_edge.png\", 1)\n\n\ndef test_ellipse_symmetric() -> None:\n    for width, bbox in (\n        (100, (24, 24, 75, 75)),\n        (101, (25, 25, 75, 75)),\n    ):\n        im = Image.new(\"RGB\", (width, 100))\n        draw = ImageDraw.Draw(im)\n        draw.ellipse(bbox, fill=\"green\", outline=\"blue\")\n        assert_image_equal(im, im.transpose(Image.Transpose.FLIP_LEFT_RIGHT))\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_ellipse_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.ellipse(bbox, outline=\"blue\", width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_ellipse_width.png\", 1)\n\n\ndef test_ellipse_width_large() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (500, 500))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.ellipse((25, 25, 475, 475), outline=\"blue\", width=75)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_ellipse_width_large.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_ellipse_width_fill(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.ellipse(bbox, fill=\"green\", outline=\"blue\", width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_ellipse_width_fill.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_ellipse_zero_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.ellipse(bbox, fill=\"green\", outline=\"blue\", width=0)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_ellipse_zero_width.png\")\n\n\ndef ellipse_various_sizes_helper(filled: bool) -> Image.Image:\n    ellipse_sizes = range(32)\n    image_size = sum(ellipse_sizes) + len(ellipse_sizes) + 1\n    im = Image.new(\"RGB\", (image_size, image_size))\n    draw = ImageDraw.Draw(im)\n\n    x = 1\n    for w in ellipse_sizes:\n        y = 1\n        for h in ellipse_sizes:\n            x1 = x + w\n            if w:\n                x1 -= 1\n            y1 = y + h\n            if h:\n                y1 -= 1\n            border = [x, y, x1, y1]\n            if filled:\n                draw.ellipse(border, fill=\"white\")\n            else:\n                draw.ellipse(border, outline=\"white\")\n            y += h + 1\n        x += w + 1\n\n    return im\n\n\ndef test_ellipse_various_sizes() -> None:\n    im = ellipse_various_sizes_helper(False)\n\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_ellipse_various_sizes.png\")\n\n\ndef test_ellipse_various_sizes_filled() -> None:\n    im = ellipse_various_sizes_helper(True)\n\n    assert_image_equal_tofile(\n        im, \"Tests/images/imagedraw_ellipse_various_sizes_filled.png\"\n    )\n\n\n@pytest.mark.parametrize(\"points\", POINTS)\ndef test_line(points: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.line(points, fill=\"yellow\", width=2)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_line.png\")\n\n\ndef test_shape1() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (100, 100), \"white\")\n    draw = ImageDraw.Draw(im)\n    x0, y0 = 5, 5\n    x1, y1 = 5, 50\n    x2, y2 = 95, 50\n    x3, y3 = 95, 5\n\n    # Act\n    assert ImageDraw.Outline is not None\n    s = ImageDraw.Outline()\n    s.move(x0, y0)\n    s.curve(x1, y1, x2, y2, x3, y3)\n    s.line(x0, y0)\n\n    draw.shape(s, fill=1)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_shape1.png\")\n\n\ndef test_shape2() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (100, 100), \"white\")\n    draw = ImageDraw.Draw(im)\n    x0, y0 = 95, 95\n    x1, y1 = 95, 50\n    x2, y2 = 5, 50\n    x3, y3 = 5, 95\n\n    # Act\n    assert ImageDraw.Outline is not None\n    s = ImageDraw.Outline()\n    s.move(x0, y0)\n    s.curve(x1, y1, x2, y2, x3, y3)\n    s.line(x0, y0)\n\n    draw.shape(s, outline=\"blue\")\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_shape2.png\")\n\n\ndef test_transform() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (100, 100), \"white\")\n    expected = im.copy()\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    assert ImageDraw.Outline is not None\n    s = ImageDraw.Outline()\n    s.line(0, 0)\n    s.transform((0, 0, 0, 0, 0, 0))\n\n    draw.shape(s, fill=1)\n\n    # Assert\n    assert_image_equal(im, expected)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\n@pytest.mark.parametrize(\"start, end\", ((-92, 46), (-92.2, 46.2)))\ndef test_pieslice(bbox: Coords, start: float, end: float) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.pieslice(bbox, start, end, fill=\"white\", outline=\"blue\")\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_pieslice.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_pieslice_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.pieslice(bbox, 10, 260, outline=\"blue\", width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_pieslice_width.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_pieslice_width_fill(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = \"Tests/images/imagedraw_pieslice_width_fill.png\"\n\n    # Act\n    draw.pieslice(bbox, 10, 260, fill=\"white\", outline=\"blue\", width=5)\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_pieslice_zero_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.pieslice(bbox, 10, 260, fill=\"white\", outline=\"blue\", width=0)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_pieslice_zero_width.png\")\n\n\ndef test_pieslice_wide() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (200, 100))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.pieslice([0, 0, 199, 99], 190, 170, width=10, fill=\"white\", outline=\"red\")\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_pieslice_wide.png\")\n\n\ndef test_pieslice_no_spikes() -> None:\n    im = Image.new(\"RGB\", (161, 161), \"white\")\n    draw = ImageDraw.Draw(im)\n    cxs = (\n        [140] * 3\n        + list(range(140, 19, -20))\n        + [20] * 5\n        + list(range(20, 141, 20))\n        + [140] * 2\n    )\n    cys = (\n        list(range(80, 141, 20))\n        + [140] * 5\n        + list(range(140, 19, -20))\n        + [20] * 5\n        + list(range(20, 80, 20))\n    )\n\n    for cx, cy, angle in zip(cxs, cys, range(0, 360, 15)):\n        draw.pieslice(\n            [cx - 100, cy - 100, cx + 100, cy + 100], angle, angle + 1, fill=\"black\"\n        )\n        draw.point([cx, cy], fill=\"red\")\n\n    im_pre_erase = im.copy()\n    draw.rectangle([21, 21, 139, 139], fill=\"white\")\n\n    assert_image_equal(im, im_pre_erase)\n\n\n@pytest.mark.parametrize(\"points\", POINTS)\ndef test_point(points: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.point(points, fill=\"yellow\")\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_point.png\")\n\n\ndef test_point_I16() -> None:\n    # Arrange\n    im = Image.new(\"I;16\", (1, 1))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.point((0, 0), fill=0x1234)\n\n    # Assert\n    assert im.getpixel((0, 0)) == 0x1234\n\n\n@pytest.mark.parametrize(\"points\", POINTS)\ndef test_polygon(points: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.polygon(points, fill=\"red\", outline=\"blue\")\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_polygon.png\")\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"L\"))\n@pytest.mark.parametrize(\"kite_points\", KITE_POINTS)\ndef test_polygon_kite(\n    mode: str, kite_points: tuple[tuple[int, int], ...] | list[tuple[int, int]]\n) -> None:\n    # Test drawing lines of different gradients (dx>dy, dy>dx) and\n    # vertical (dx==0) and horizontal (dy==0) lines\n    # Arrange\n    im = Image.new(mode, (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = f\"Tests/images/imagedraw_polygon_kite_{mode}.png\"\n\n    # Act\n    draw.polygon(kite_points, fill=\"blue\", outline=\"yellow\")\n\n    # Assert\n    assert_image_equal_tofile(im, expected)\n\n\ndef test_polygon_1px_high() -> None:\n    # Test drawing a 1px high polygon\n    # Arrange\n    im = Image.new(\"RGB\", (3, 3))\n    draw = ImageDraw.Draw(im)\n    expected = \"Tests/images/imagedraw_polygon_1px_high.png\"\n\n    # Act\n    draw.polygon([(0, 1), (0, 1), (2, 1), (2, 1)], \"#f00\")\n\n    # Assert\n    assert_image_equal_tofile(im, expected)\n\n\ndef test_polygon_1px_high_translucent() -> None:\n    # Test drawing a translucent 1px high polygon\n    # Arrange\n    im = Image.new(\"RGB\", (4, 3))\n    draw = ImageDraw.Draw(im, \"RGBA\")\n    expected = \"Tests/images/imagedraw_polygon_1px_high_translucent.png\"\n\n    # Act\n    draw.polygon([(1, 1), (1, 1), (3, 1), (3, 1)], (255, 0, 0, 127))\n\n    # Assert\n    assert_image_equal_tofile(im, expected)\n\n\ndef test_polygon_translucent() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im, \"RGBA\")\n\n    # Act\n    draw.polygon([(20, 80), (80, 80), (80, 20)], fill=(0, 255, 0, 127))\n\n    # Assert\n    expected = \"Tests/images/imagedraw_polygon_translucent.png\"\n    assert_image_equal_tofile(im, expected)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rectangle(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rectangle(bbox, fill=\"black\", outline=\"green\")\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_rectangle.png\")\n\n\ndef test_big_rectangle() -> None:\n    # Test drawing a rectangle bigger than the image\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    bbox = [(-1, -1), (W + 1, H + 1)]\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rectangle(bbox, fill=\"orange\")\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_big_rectangle.png\", 1)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rectangle_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = \"Tests/images/imagedraw_rectangle_width.png\"\n\n    # Act\n    draw.rectangle(bbox, outline=\"green\", width=5)\n\n    # Assert\n    assert_image_equal_tofile(im, expected)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rectangle_width_fill(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = \"Tests/images/imagedraw_rectangle_width_fill.png\"\n\n    # Act\n    draw.rectangle(bbox, fill=\"blue\", outline=\"green\", width=5)\n\n    # Assert\n    assert_image_equal_tofile(im, expected)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rectangle_zero_width(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rectangle(bbox, fill=\"blue\", outline=\"green\", width=0)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_rectangle_zero_width.png\")\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rectangle_I16(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"I;16\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rectangle(bbox, outline=0xFFFF)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_rectangle_I.tiff\")\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rectangle_translucent_outline(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im, \"RGBA\")\n\n    # Act\n    draw.rectangle(bbox, fill=\"black\", outline=(0, 255, 0, 127), width=5)\n\n    # Assert\n    assert_image_equal_tofile(\n        im, \"Tests/images/imagedraw_rectangle_translucent_outline.png\"\n    )\n\n\n@pytest.mark.parametrize(\n    \"xy\",\n    [(10, 20, 190, 180), ([10, 20], [190, 180]), ((10, 20), (190, 180))],\n)\ndef test_rounded_rectangle(\n    xy: (\n        tuple[int, int, int, int]\n        | tuple[list[int]]\n        | tuple[tuple[int, int], tuple[int, int]]\n    )\n) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (200, 200))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rounded_rectangle(xy, 30, fill=\"red\", outline=\"green\", width=5)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_rounded_rectangle.png\")\n\n\n@pytest.mark.parametrize(\"top_left\", (True, False))\n@pytest.mark.parametrize(\"top_right\", (True, False))\n@pytest.mark.parametrize(\"bottom_right\", (True, False))\n@pytest.mark.parametrize(\"bottom_left\", (True, False))\ndef test_rounded_rectangle_corners(\n    top_left: bool, top_right: bool, bottom_right: bool, bottom_left: bool\n) -> None:\n    corners = (top_left, top_right, bottom_right, bottom_left)\n\n    # Arrange\n    im = Image.new(\"RGB\", (200, 200))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rounded_rectangle(\n        (10, 20, 190, 180), 30, fill=\"red\", outline=\"green\", width=5, corners=corners\n    )\n\n    # Assert\n    suffix = \"\".join(\n        (\n            (\"y\" if top_left else \"n\"),\n            (\"y\" if top_right else \"n\"),\n            (\"y\" if bottom_right else \"n\"),\n            (\"y\" if bottom_left else \"n\"),\n        )\n    )\n    assert_image_equal_tofile(\n        im, \"Tests/images/imagedraw_rounded_rectangle_corners_\" + suffix + \".png\"\n    )\n\n\n@pytest.mark.parametrize(\n    \"xy, radius, type\",\n    [\n        ((10, 20, 190, 180), 30.5, \"given\"),\n        ((10, 10, 181, 190), 90, \"width\"),\n        ((10, 20, 190, 181), 85, \"height\"),\n    ],\n)\ndef test_rounded_rectangle_non_integer_radius(\n    xy: tuple[int, int, int, int], radius: float, type: str\n) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (200, 200))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rounded_rectangle(xy, radius, fill=\"red\", outline=\"green\", width=5)\n\n    # Assert\n    assert_image_equal_tofile(\n        im,\n        \"Tests/images/imagedraw_rounded_rectangle_non_integer_radius_\" + type + \".png\",\n    )\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rounded_rectangle_zero_radius(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.rounded_rectangle(bbox, 0, fill=\"blue\", outline=\"green\", width=5)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_rectangle_width_fill.png\")\n\n\n@pytest.mark.parametrize(\n    \"xy, suffix\",\n    [\n        ((20, 10, 80, 90), \"x\"),\n        ((20, 10, 81, 90), \"x_odd\"),\n        ((20, 10, 81.1, 90), \"x_odd\"),\n        ((10, 20, 90, 80), \"y\"),\n        ((10, 20, 90, 81), \"y_odd\"),\n        ((10, 20, 90, 81.1), \"y_odd\"),\n        ((20, 20, 80, 80), \"both\"),\n    ],\n)\ndef test_rounded_rectangle_translucent(\n    xy: tuple[int, int, int, int], suffix: str\n) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im, \"RGBA\")\n\n    # Act\n    draw.rounded_rectangle(\n        xy, 30, fill=(255, 0, 0, 127), outline=(0, 255, 0, 127), width=5\n    )\n\n    # Assert\n    assert_image_equal_tofile(\n        im, \"Tests/images/imagedraw_rounded_rectangle_\" + suffix + \".png\"\n    )\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_floodfill(bbox: Coords) -> None:\n    red = ImageColor.getrgb(\"red\")\n\n    mode_values: list[tuple[str, int | tuple[int, ...]]] = [\n        (\"L\", 1),\n        (\"RGBA\", (255, 0, 0, 0)),\n        (\"RGB\", red),\n    ]\n    for mode, value in mode_values:\n        # Arrange\n        im = Image.new(mode, (W, H))\n        draw = ImageDraw.Draw(im)\n        draw.rectangle(bbox, outline=\"yellow\", fill=\"green\")\n        centre_point = (int(W / 2), int(H / 2))\n\n        # Act\n        ImageDraw.floodfill(im, centre_point, value)\n\n        # Assert\n        expected = \"Tests/images/imagedraw_floodfill_\" + mode + \".png\"\n        with Image.open(expected) as im_floodfill:\n            assert_image_equal(im, im_floodfill)\n\n    # Test that using the same colour does not change the image\n    ImageDraw.floodfill(im, centre_point, red)\n    assert_image_equal(im, im_floodfill)\n\n    # Test that filling outside the image does not change the image\n    ImageDraw.floodfill(im, (W, H), red)\n    assert_image_equal(im, im_floodfill)\n\n    # Test filling at the edge of an image\n    im = Image.new(\"RGB\", (1, 1))\n    ImageDraw.floodfill(im, (0, 0), red)\n    assert_image_equal(im, Image.new(\"RGB\", (1, 1), red))\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_floodfill_border(bbox: Coords) -> None:\n    # floodfill() is experimental\n\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    draw.rectangle(bbox, outline=\"yellow\", fill=\"green\")\n    centre_point = (int(W / 2), int(H / 2))\n\n    # Act\n    ImageDraw.floodfill(\n        im,\n        centre_point,\n        ImageColor.getrgb(\"red\"),\n        border=ImageColor.getrgb(\"black\"),\n    )\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_floodfill2.png\")\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_floodfill_thresh(bbox: Coords) -> None:\n    # floodfill() is experimental\n\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    draw.rectangle(bbox, outline=\"darkgreen\", fill=\"green\")\n    centre_point = (int(W / 2), int(H / 2))\n\n    # Act\n    ImageDraw.floodfill(im, centre_point, ImageColor.getrgb(\"red\"), thresh=30)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_floodfill2.png\")\n\n\ndef test_floodfill_not_negative() -> None:\n    # floodfill() is experimental\n    # Test that floodfill does not extend into negative coordinates\n\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    draw.line((W / 2, 0, W / 2, H / 2), fill=\"green\")\n    draw.line((0, H / 2, W / 2, H / 2), fill=\"green\")\n\n    # Act\n    ImageDraw.floodfill(im, (int(W / 4), int(H / 4)), ImageColor.getrgb(\"red\"))\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_floodfill_not_negative.png\")\n\n\ndef create_base_image_draw(\n    size: tuple[int, int],\n    mode: str = DEFAULT_MODE,\n    background1: tuple[int, int, int] = WHITE,\n    background2: tuple[int, int, int] = GRAY,\n) -> tuple[Image.Image, ImageDraw.ImageDraw]:\n    img = Image.new(mode, size, background1)\n    for x in range(0, size[0]):\n        for y in range(0, size[1]):\n            if (x + y) % 2 == 0:\n                img.putpixel((x, y), background2)\n    return img, ImageDraw.Draw(img)\n\n\ndef test_square() -> None:\n    expected = os.path.join(IMAGES_PATH, \"square.png\")\n    img, draw = create_base_image_draw((10, 10))\n    draw.polygon([(2, 2), (2, 7), (7, 7), (7, 2)], BLACK)\n    assert_image_equal_tofile(img, expected, \"square as normal polygon failed\")\n    img, draw = create_base_image_draw((10, 10))\n    draw.polygon([(7, 7), (7, 2), (2, 2), (2, 7)], BLACK)\n    assert_image_equal_tofile(img, expected, \"square as inverted polygon failed\")\n    img, draw = create_base_image_draw((10, 10))\n    draw.rectangle((2, 2, 7, 7), BLACK)\n    assert_image_equal_tofile(img, expected, \"square as normal rectangle failed\")\n\n\ndef test_triangle_right() -> None:\n    img, draw = create_base_image_draw((20, 20))\n    draw.polygon([(3, 5), (17, 5), (10, 12)], BLACK)\n    assert_image_equal_tofile(\n        img, os.path.join(IMAGES_PATH, \"triangle_right.png\"), \"triangle right failed\"\n    )\n\n\n@pytest.mark.parametrize(\n    \"fill, suffix\",\n    ((BLACK, \"width\"), (None, \"width_no_fill\")),\n)\ndef test_triangle_right_width(fill: tuple[int, int, int] | None, suffix: str) -> None:\n    img, draw = create_base_image_draw((100, 100))\n    draw.polygon([(15, 25), (85, 25), (50, 60)], fill, WHITE, width=5)\n    assert_image_equal_tofile(\n        img, os.path.join(IMAGES_PATH, \"triangle_right_\" + suffix + \".png\")\n    )\n\n\ndef test_line_horizontal() -> None:\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 5, 14, 5), BLACK, 2)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_horizontal_w2px_normal.png\"),\n        \"line straight horizontal normal 2px wide failed\",\n    )\n\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((14, 5, 5, 5), BLACK, 2)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_horizontal_w2px_inverted.png\"),\n        \"line straight horizontal inverted 2px wide failed\",\n    )\n\n    expected = os.path.join(IMAGES_PATH, \"line_horizontal_w3px.png\")\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 5, 14, 5), BLACK, 3)\n    assert_image_equal_tofile(\n        img, expected, \"line straight horizontal normal 3px wide failed\"\n    )\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((14, 5, 5, 5), BLACK, 3)\n    assert_image_equal_tofile(\n        img, expected, \"line straight horizontal inverted 3px wide failed\"\n    )\n\n    img, draw = create_base_image_draw((200, 110))\n    draw.line((5, 55, 195, 55), BLACK, 101)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_horizontal_w101px.png\"),\n        \"line straight horizontal 101px wide failed\",\n    )\n\n\n@pytest.mark.xfail(reason=\"failing test\")\ndef test_line_h_s1_w2() -> None:\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 5, 14, 6), BLACK, 2)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_horizontal_slope1px_w2px.png\"),\n        \"line horizontal 1px slope 2px wide failed\",\n    )\n\n\ndef test_line_vertical() -> None:\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 5, 5, 14), BLACK, 2)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_vertical_w2px_normal.png\"),\n        \"line straight vertical normal 2px wide failed\",\n    )\n\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 14, 5, 5), BLACK, 2)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_vertical_w2px_inverted.png\"),\n        \"line straight vertical inverted 2px wide failed\",\n    )\n\n    expected = os.path.join(IMAGES_PATH, \"line_vertical_w3px.png\")\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 5, 5, 14), BLACK, 3)\n    assert_image_equal_tofile(\n        img, expected, \"line straight vertical normal 3px wide failed\"\n    )\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 14, 5, 5), BLACK, 3)\n    assert_image_equal_tofile(\n        img, expected, \"line straight vertical inverted 3px wide failed\"\n    )\n\n    img, draw = create_base_image_draw((110, 200))\n    draw.line((55, 5, 55, 195), BLACK, 101)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_vertical_w101px.png\"),\n        \"line straight vertical 101px wide failed\",\n    )\n\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 5, 6, 14), BLACK, 2)\n    assert_image_equal_tofile(\n        img,\n        os.path.join(IMAGES_PATH, \"line_vertical_slope1px_w2px.png\"),\n        \"line vertical 1px slope 2px wide failed\",\n    )\n\n\ndef test_line_oblique_45() -> None:\n    expected = os.path.join(IMAGES_PATH, \"line_oblique_45_w3px_a.png\")\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 5, 14, 14), BLACK, 3)\n    assert_image_equal_tofile(img, expected, \"line oblique 45 normal 3px wide A failed\")\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((14, 14, 5, 5), BLACK, 3)\n    assert_image_equal_tofile(\n        img, expected, \"line oblique 45 inverted 3px wide A failed\"\n    )\n\n    expected = os.path.join(IMAGES_PATH, \"line_oblique_45_w3px_b.png\")\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((14, 5, 5, 14), BLACK, 3)\n    assert_image_equal_tofile(img, expected, \"line oblique 45 normal 3px wide B failed\")\n    img, draw = create_base_image_draw((20, 20))\n    draw.line((5, 14, 14, 5), BLACK, 3)\n    assert_image_equal_tofile(\n        img, expected, \"line oblique 45 inverted 3px wide B failed\"\n    )\n\n\ndef test_wide_line_dot() -> None:\n    # Test drawing a wide \"line\" from one point to another just draws a single point\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.line([(50, 50), (50, 50)], width=3)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_wide_line_dot.png\", 1)\n\n\ndef test_wide_line_larger_than_int() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    expected = \"Tests/images/imagedraw_wide_line_larger_than_int.png\"\n\n    # Act\n    draw.line([(0, 0), (32768, 32768)], width=3)\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 1)\n\n\n@pytest.mark.parametrize(\n    \"xy\",\n    [\n        [\n            (400, 280),\n            (380, 280),\n            (450, 280),\n            (440, 120),\n            (350, 200),\n            (310, 280),\n            (300, 280),\n            (250, 280),\n            (250, 200),\n            (150, 200),\n            (150, 260),\n            (50, 200),\n            (150, 50),\n            (250, 100),\n        ],\n        (\n            400,\n            280,\n            380,\n            280,\n            450,\n            280,\n            440,\n            120,\n            350,\n            200,\n            310,\n            280,\n            300,\n            280,\n            250,\n            280,\n            250,\n            200,\n            150,\n            200,\n            150,\n            260,\n            50,\n            200,\n            150,\n            50,\n            250,\n            100,\n        ),\n        [\n            400,\n            280,\n            380,\n            280,\n            450,\n            280,\n            440,\n            120,\n            350,\n            200,\n            310,\n            280,\n            300,\n            280,\n            250,\n            280,\n            250,\n            200,\n            150,\n            200,\n            150,\n            260,\n            50,\n            200,\n            150,\n            50,\n            250,\n            100,\n        ],\n    ],\n)\ndef test_line_joint(xy: list[tuple[int, int]] | tuple[int, ...] | list[int]) -> None:\n    im = Image.new(\"RGB\", (500, 325))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.line(xy, GRAY, 50, \"curve\")\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_line_joint_curve.png\", 3)\n\n\ndef test_textsize_empty_string() -> None:\n    # https://github.com/python-pillow/Pillow/issues/2783\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    # Should not cause 'SystemError: <built-in method getsize of\n    # ImagingFont object at 0x...> returned NULL without setting an error'\n    draw.textbbox((0, 0), \"\")\n    draw.textbbox((0, 0), \"\\n\")\n    draw.textbbox((0, 0), \"test\\n\")\n    draw.textlength(\"\")\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_textbbox_stroke() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\", 20)\n\n    # Act / Assert\n    assert draw.textbbox((2, 2), \"A\", font, stroke_width=2) == (0, 4, 16, 20)\n    assert draw.textbbox((2, 2), \"A\", font, stroke_width=4) == (-2, 2, 18, 22)\n    assert draw.textbbox((2, 2), \"ABC\\nAaaa\", font, stroke_width=2) == (0, 4, 52, 44)\n    assert draw.textbbox((2, 2), \"ABC\\nAaaa\", font, stroke_width=4) == (-2, 2, 54, 50)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_stroke() -> None:\n    for suffix, stroke_fill in {\"same\": None, \"different\": \"#0f0\"}.items():\n        # Arrange\n        im = Image.new(\"RGB\", (120, 130))\n        draw = ImageDraw.Draw(im)\n        font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\", 120)\n\n        # Act\n        draw.text((12, 12), \"A\", \"#f00\", font, stroke_width=2, stroke_fill=stroke_fill)\n\n        # Assert\n        assert_image_similar_tofile(\n            im, \"Tests/images/imagedraw_stroke_\" + suffix + \".png\", 3.1\n        )\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_stroke_descender() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (120, 130))\n    draw = ImageDraw.Draw(im)\n    font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\", 120)\n\n    # Act\n    draw.text((12, 2), \"y\", \"#f00\", font, stroke_width=2, stroke_fill=\"#0f0\")\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_stroke_descender.png\", 6.76)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_split_word() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (230, 55))\n    expected = im.copy()\n    expected_draw = ImageDraw.Draw(expected)\n    font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\", 48)\n    expected_draw.text((0, 0), \"paradise\", font=font)\n\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    draw.text((0, 0), \"par\", font=font)\n\n    length = draw.textlength(\"par\", font=font)\n    draw.text((length, 0), \"adise\", font=font)\n\n    # Assert\n    assert_image_equal(im, expected)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_stroke_multiline() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (100, 250))\n    draw = ImageDraw.Draw(im)\n    font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\", 120)\n\n    # Act\n    draw.multiline_text(\n        (12, 12), \"A\\nB\", \"#f00\", font, stroke_width=2, stroke_fill=\"#0f0\"\n    )\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_stroke_multiline.png\", 3.3)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_setting_default_font() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (100, 250))\n    draw = ImageDraw.Draw(im)\n    font = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\", 120)\n\n    # Act\n    ImageDraw.ImageDraw.font = font\n\n    # Assert\n    try:\n        assert draw.getfont() == font\n    finally:\n        ImageDraw.ImageDraw.font = None\n        assert isinstance(draw.getfont(), ImageFont.load_default().__class__)\n\n\ndef test_default_font_size() -> None:\n    freetype_support = features.check_module(\"freetype2\")\n    text = \"Default font at a specific size.\"\n\n    im = Image.new(\"RGB\", (220, 25))\n    draw = ImageDraw.Draw(im)\n    with contextlib.nullcontext() if freetype_support else pytest.raises(ImportError):\n        draw.text((0, 0), text, font_size=16)\n        assert_image_equal_tofile(im, \"Tests/images/imagedraw_default_font_size.png\")\n\n    with contextlib.nullcontext() if freetype_support else pytest.raises(ImportError):\n        assert draw.textlength(text, font_size=16) == 216\n\n    with contextlib.nullcontext() if freetype_support else pytest.raises(ImportError):\n        assert draw.textbbox((0, 0), text, font_size=16) == (0, 3, 216, 19)\n\n    im = Image.new(\"RGB\", (220, 25))\n    draw = ImageDraw.Draw(im)\n    with contextlib.nullcontext() if freetype_support else pytest.raises(ImportError):\n        draw.multiline_text((0, 0), text, font_size=16)\n        assert_image_equal_tofile(im, \"Tests/images/imagedraw_default_font_size.png\")\n\n    with contextlib.nullcontext() if freetype_support else pytest.raises(ImportError):\n        assert draw.multiline_textbbox((0, 0), text, font_size=16) == (0, 3, 216, 19)\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_same_color_outline(bbox: Coords) -> None:\n    # Prepare shape\n    x0, y0 = 5, 5\n    x1, y1 = 5, 50\n    x2, y2 = 95, 50\n    x3, y3 = 95, 5\n\n    assert ImageDraw.Outline is not None\n    s = ImageDraw.Outline()\n    s.move(x0, y0)\n    s.curve(x1, y1, x2, y2, x3, y3)\n    s.line(x0, y0)\n\n    # Begin\n    for mode in [\"RGB\", \"L\"]:\n        fill = \"red\"\n        for outline in [None, \"red\", \"#f00\"]:\n            for operation, args in {\n                \"chord\": [bbox, 0, 180],\n                \"ellipse\": [bbox],\n                \"shape\": [s],\n                \"pieslice\": [bbox, -90, 45],\n                \"polygon\": [[(18, 30), (85, 30), (60, 72)]],\n                \"rectangle\": [bbox],\n            }.items():\n                # Arrange\n                im = Image.new(mode, (W, H))\n                draw = ImageDraw.Draw(im)\n\n                # Act\n                draw_method = getattr(draw, operation)\n                assert isinstance(args, list)\n                args += [fill, outline]\n                draw_method(*args)\n\n                # Assert\n                expected = f\"Tests/images/imagedraw_outline_{operation}_{mode}.png\"\n                assert_image_similar_tofile(im, expected, 1)\n\n\n@pytest.mark.parametrize(\n    \"n_sides, polygon_name, args\",\n    [\n        (4, \"square\", {}),\n        (8, \"regular_octagon\", {}),\n        (4, \"square_rotate_45\", {\"rotation\": 45}),\n        (3, \"triangle_width\", {\"outline\": \"yellow\", \"width\": 5}),\n    ],\n)\ndef test_draw_regular_polygon(\n    n_sides: int, polygon_name: str, args: dict[str, int | str]\n) -> None:\n    im = Image.new(\"RGBA\", size=(W, H), color=(255, 0, 0, 0))\n    filename = f\"Tests/images/imagedraw_{polygon_name}.png\"\n    draw = ImageDraw.Draw(im)\n    bounding_circle = ((W // 2, H // 2), 25)\n    rotation = int(args.get(\"rotation\", 0))\n    outline = args.get(\"outline\")\n    width = int(args.get(\"width\", 1))\n    draw.regular_polygon(bounding_circle, n_sides, rotation, \"red\", outline, width)\n    assert_image_equal_tofile(im, filename)\n\n\n@pytest.mark.parametrize(\n    \"n_sides, expected_vertices\",\n    [\n        (3, [(28.35, 62.5), (71.65, 62.5), (50.0, 25.0)]),\n        (4, [(32.32, 67.68), (67.68, 67.68), (67.68, 32.32), (32.32, 32.32)]),\n        (\n            5,\n            [\n                (35.31, 70.23),\n                (64.69, 70.23),\n                (73.78, 42.27),\n                (50.0, 25.0),\n                (26.22, 42.27),\n            ],\n        ),\n        (\n            6,\n            [\n                (37.5, 71.65),\n                (62.5, 71.65),\n                (75.0, 50.0),\n                (62.5, 28.35),\n                (37.5, 28.35),\n                (25.0, 50.0),\n            ],\n        ),\n    ],\n)\ndef test_compute_regular_polygon_vertices(\n    n_sides: int, expected_vertices: list[tuple[float, float]]\n) -> None:\n    bounding_circle = (W // 2, H // 2, 25)\n    vertices = ImageDraw._compute_regular_polygon_vertices(bounding_circle, n_sides, 0)\n    assert vertices == expected_vertices\n\n\n@pytest.mark.parametrize(\n    \"n_sides, bounding_circle, rotation, expected_error, error_message\",\n    [\n        (None, (50, 50, 25), 0, TypeError, \"n_sides should be an int\"),\n        (1, (50, 50, 25), 0, ValueError, \"n_sides should be an int > 2\"),\n        (3, 50, 0, TypeError, \"bounding_circle should be a sequence\"),\n        (\n            3,\n            (50, 50, 100, 100),\n            0,\n            ValueError,\n            \"bounding_circle should contain 2D coordinates \"\n            \"and a radius (e.g. (x, y, r) or ((x, y), r) )\",\n        ),\n        (\n            3,\n            (50, 50, \"25\"),\n            0,\n            ValueError,\n            \"bounding_circle should only contain numeric data\",\n        ),\n        (\n            3,\n            ((50, 50, 50), 25),\n            0,\n            ValueError,\n            \"bounding_circle centre should contain 2D coordinates (e.g. (x, y))\",\n        ),\n        (\n            3,\n            (50, 50, 0),\n            0,\n            ValueError,\n            \"bounding_circle radius should be > 0\",\n        ),\n        (\n            3,\n            (50, 50, 25),\n            \"0\",\n            ValueError,\n            \"rotation should be an int or float\",\n        ),\n    ],\n)\ndef test_compute_regular_polygon_vertices_input_error_handling(\n    n_sides: int,\n    bounding_circle: int | tuple[int | tuple[int] | str, ...],\n    rotation: int | str,\n    expected_error: type[Exception],\n    error_message: str,\n) -> None:\n    with pytest.raises(expected_error) as e:\n        ImageDraw._compute_regular_polygon_vertices(bounding_circle, n_sides, rotation)  # type: ignore[arg-type]\n    assert str(e.value) == error_message\n\n\ndef test_continuous_horizontal_edges_polygon() -> None:\n    xy = [\n        (2, 6),\n        (6, 6),\n        (12, 6),\n        (12, 12),\n        (8, 12),\n        (8, 8),\n        (4, 8),\n        (2, 8),\n    ]\n    img, draw = create_base_image_draw((16, 16))\n    draw.polygon(xy, BLACK)\n    expected = os.path.join(IMAGES_PATH, \"continuous_horizontal_edges_polygon.png\")\n    assert_image_equal_tofile(\n        img, expected, \"continuous horizontal edges polygon failed\"\n    )\n\n\ndef test_discontiguous_corners_polygon() -> None:\n    img, draw = create_base_image_draw((84, 68))\n    draw.polygon(((1, 21), (34, 4), (71, 1), (38, 18)), BLACK)\n    draw.polygon(((71, 44), (38, 27), (1, 24)), BLACK)\n    draw.polygon(\n        ((38, 66), (5, 49), (77, 49), (47, 66), (82, 63), (82, 47), (1, 47), (1, 63)),\n        BLACK,\n    )\n    expected = os.path.join(IMAGES_PATH, \"discontiguous_corners_polygon.png\")\n    assert_image_similar_tofile(img, expected, 1)\n\n\ndef test_polygon2() -> None:\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    draw.polygon([(18, 30), (19, 31), (18, 30), (85, 30), (60, 72)], \"red\")\n    expected = \"Tests/images/imagedraw_outline_polygon_RGB.png\"\n    assert_image_similar_tofile(im, expected, 1)\n\n\n@pytest.mark.parametrize(\"xy\", ((1, 1, 0, 1), (1, 1, 1, 0)))\ndef test_incorrectly_ordered_coordinates(xy: tuple[int, int, int, int]) -> None:\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw.Draw(im)\n    with pytest.raises(ValueError):\n        draw.arc(xy, 10, 260)\n    with pytest.raises(ValueError):\n        draw.chord(xy, 10, 260)\n    with pytest.raises(ValueError):\n        draw.ellipse(xy)\n    with pytest.raises(ValueError):\n        draw.pieslice(xy, 10, 260)\n    with pytest.raises(ValueError):\n        draw.rectangle(xy)\n    with pytest.raises(ValueError):\n        draw.rounded_rectangle(xy)\n\n\ndef test_getdraw() -> None:\n    with pytest.warns(DeprecationWarning):\n        ImageDraw.getdraw(None, [])\n", "Tests/test_core_resources.py": "from __future__ import annotations\n\nimport sys\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import is_pypy\n\n\ndef test_get_stats() -> None:\n    # Create at least one image\n    Image.new(\"RGB\", (10, 10))\n\n    stats = Image.core.get_stats()\n    assert \"new_count\" in stats\n    assert \"reused_blocks\" in stats\n    assert \"freed_blocks\" in stats\n    assert \"allocated_blocks\" in stats\n    assert \"reallocated_blocks\" in stats\n    assert \"blocks_cached\" in stats\n\n\ndef test_reset_stats() -> None:\n    Image.core.reset_stats()\n\n    stats = Image.core.get_stats()\n    assert stats[\"new_count\"] == 0\n    assert stats[\"reused_blocks\"] == 0\n    assert stats[\"freed_blocks\"] == 0\n    assert stats[\"allocated_blocks\"] == 0\n    assert stats[\"reallocated_blocks\"] == 0\n    assert stats[\"blocks_cached\"] == 0\n\n\nclass TestCoreMemory:\n    def teardown_method(self) -> None:\n        # Restore default values\n        Image.core.set_alignment(1)\n        Image.core.set_block_size(1024 * 1024)\n        Image.core.set_blocks_max(0)\n        Image.core.clear_cache()\n\n    def test_get_alignment(self) -> None:\n        alignment = Image.core.get_alignment()\n\n        assert alignment > 0\n\n    def test_set_alignment(self) -> None:\n        for i in [1, 2, 4, 8, 16, 32]:\n            Image.core.set_alignment(i)\n            alignment = Image.core.get_alignment()\n            assert alignment == i\n\n            # Try to construct new image\n            Image.new(\"RGB\", (10, 10))\n\n        with pytest.raises(ValueError):\n            Image.core.set_alignment(0)\n        with pytest.raises(ValueError):\n            Image.core.set_alignment(-1)\n        with pytest.raises(ValueError):\n            Image.core.set_alignment(3)\n\n    def test_get_block_size(self) -> None:\n        block_size = Image.core.get_block_size()\n\n        assert block_size >= 4096\n\n    def test_set_block_size(self) -> None:\n        for i in [4096, 2 * 4096, 3 * 4096]:\n            Image.core.set_block_size(i)\n            block_size = Image.core.get_block_size()\n            assert block_size == i\n\n            # Try to construct new image\n            Image.new(\"RGB\", (10, 10))\n\n        with pytest.raises(ValueError):\n            Image.core.set_block_size(0)\n        with pytest.raises(ValueError):\n            Image.core.set_block_size(-1)\n        with pytest.raises(ValueError):\n            Image.core.set_block_size(4000)\n\n    def test_set_block_size_stats(self) -> None:\n        Image.core.reset_stats()\n        Image.core.set_blocks_max(0)\n        Image.core.set_block_size(4096)\n        Image.new(\"RGB\", (256, 256))\n\n        stats = Image.core.get_stats()\n        assert stats[\"new_count\"] >= 1\n        assert stats[\"allocated_blocks\"] >= 64\n        if not is_pypy():\n            assert stats[\"freed_blocks\"] >= 64\n\n    def test_get_blocks_max(self) -> None:\n        blocks_max = Image.core.get_blocks_max()\n\n        assert blocks_max >= 0\n\n    def test_set_blocks_max(self) -> None:\n        for i in [0, 1, 10]:\n            Image.core.set_blocks_max(i)\n            blocks_max = Image.core.get_blocks_max()\n            assert blocks_max == i\n\n            # Try to construct new image\n            Image.new(\"RGB\", (10, 10))\n\n        with pytest.raises(ValueError):\n            Image.core.set_blocks_max(-1)\n        if sys.maxsize < 2**32:\n            with pytest.raises(ValueError):\n                Image.core.set_blocks_max(2**29)\n\n    @pytest.mark.skipif(is_pypy(), reason=\"Images not collected\")\n    def test_set_blocks_max_stats(self) -> None:\n        Image.core.reset_stats()\n        Image.core.set_blocks_max(128)\n        Image.core.set_block_size(4096)\n        Image.new(\"RGB\", (256, 256))\n        Image.new(\"RGB\", (256, 256))\n\n        stats = Image.core.get_stats()\n        assert stats[\"new_count\"] >= 2\n        assert stats[\"allocated_blocks\"] >= 64\n        assert stats[\"reused_blocks\"] >= 64\n        assert stats[\"freed_blocks\"] == 0\n        assert stats[\"blocks_cached\"] == 64\n\n    @pytest.mark.skipif(is_pypy(), reason=\"Images not collected\")\n    def test_clear_cache_stats(self) -> None:\n        Image.core.reset_stats()\n        Image.core.clear_cache()\n        Image.core.set_blocks_max(128)\n        Image.core.set_block_size(4096)\n        Image.new(\"RGB\", (256, 256))\n        Image.new(\"RGB\", (256, 256))\n        # Keep 16 blocks in cache\n        Image.core.clear_cache(16)\n\n        stats = Image.core.get_stats()\n        assert stats[\"new_count\"] >= 2\n        assert stats[\"allocated_blocks\"] >= 64\n        assert stats[\"reused_blocks\"] >= 64\n        assert stats[\"freed_blocks\"] >= 48\n        assert stats[\"blocks_cached\"] == 16\n\n    def test_large_images(self) -> None:\n        Image.core.reset_stats()\n        Image.core.set_blocks_max(0)\n        Image.core.set_block_size(4096)\n        Image.new(\"RGB\", (2048, 16))\n        Image.core.clear_cache()\n\n        stats = Image.core.get_stats()\n        assert stats[\"new_count\"] >= 1\n        assert stats[\"allocated_blocks\"] >= 16\n        assert stats[\"reused_blocks\"] >= 0\n        assert stats[\"blocks_cached\"] == 0\n        if not is_pypy():\n            assert stats[\"freed_blocks\"] >= 16\n\n\nclass TestEnvVars:\n    def teardown_method(self) -> None:\n        # Restore default values\n        Image.core.set_alignment(1)\n        Image.core.set_block_size(1024 * 1024)\n        Image.core.set_blocks_max(0)\n        Image.core.clear_cache()\n\n    def test_units(self) -> None:\n        Image._apply_env_variables({\"PILLOW_BLOCKS_MAX\": \"2K\"})\n        assert Image.core.get_blocks_max() == 2 * 1024\n        Image._apply_env_variables({\"PILLOW_BLOCK_SIZE\": \"2m\"})\n        assert Image.core.get_block_size() == 2 * 1024 * 1024\n\n    @pytest.mark.parametrize(\n        \"var\",\n        (\n            {\"PILLOW_ALIGNMENT\": \"15\"},\n            {\"PILLOW_BLOCK_SIZE\": \"1024\"},\n            {\"PILLOW_BLOCKS_MAX\": \"wat\"},\n        ),\n    )\n    def test_warnings(self, var: dict[str, str]) -> None:\n        with pytest.warns(UserWarning):\n            Image._apply_env_variables(var)\n", "Tests/test_imageops_usm.py": "from __future__ import annotations\n\nfrom typing import Generator\n\nimport pytest\n\nfrom PIL import Image, ImageFile, ImageFilter\n\n\n@pytest.fixture\ndef test_images() -> Generator[dict[str, ImageFile.ImageFile], None, None]:\n    ims = {\n        \"im\": Image.open(\"Tests/images/hopper.ppm\"),\n        \"snakes\": Image.open(\"Tests/images/color_snakes.png\"),\n    }\n    try:\n        yield ims\n    finally:\n        for im in ims.values():\n            im.close()\n\n\ndef test_filter_api(test_images: dict[str, ImageFile.ImageFile]) -> None:\n    im = test_images[\"im\"]\n\n    test_filter = ImageFilter.GaussianBlur(2.0)\n    i = im.filter(test_filter)\n    assert i.mode == \"RGB\"\n    assert i.size == (128, 128)\n\n    test_filter2 = ImageFilter.UnsharpMask(2.0, 125, 8)\n    i = im.filter(test_filter2)\n    assert i.mode == \"RGB\"\n    assert i.size == (128, 128)\n\n\ndef test_usm_formats(test_images: dict[str, ImageFile.ImageFile]) -> None:\n    im = test_images[\"im\"]\n\n    usm = ImageFilter.UnsharpMask\n    with pytest.raises(ValueError):\n        im.convert(\"1\").filter(usm)\n    im.convert(\"L\").filter(usm)\n    with pytest.raises(ValueError):\n        im.convert(\"I\").filter(usm)\n    with pytest.raises(ValueError):\n        im.convert(\"F\").filter(usm)\n    im.convert(\"RGB\").filter(usm)\n    im.convert(\"RGBA\").filter(usm)\n    im.convert(\"CMYK\").filter(usm)\n    with pytest.raises(ValueError):\n        im.convert(\"YCbCr\").filter(usm)\n\n\ndef test_blur_formats(test_images: dict[str, ImageFile.ImageFile]) -> None:\n    im = test_images[\"im\"]\n\n    blur = ImageFilter.GaussianBlur\n    with pytest.raises(ValueError):\n        im.convert(\"1\").filter(blur)\n    with pytest.raises(ValueError):\n        im.convert(\"I\").filter(blur)\n    with pytest.raises(ValueError):\n        im.convert(\"F\").filter(blur)\n    im.convert(\"RGB\").filter(blur)\n    im.convert(\"RGBA\").filter(blur)\n    im.convert(\"CMYK\").filter(blur)\n    with pytest.raises(ValueError):\n        im.convert(\"YCbCr\").filter(blur)\n\n\ndef test_usm_accuracy(test_images: dict[str, ImageFile.ImageFile]) -> None:\n    snakes = test_images[\"snakes\"]\n\n    src = snakes.convert(\"RGB\")\n    i = src.filter(ImageFilter.UnsharpMask(5, 1024, 0))\n    # Image should not be changed because it have only 0 and 255 levels.\n    assert i.tobytes() == src.tobytes()\n\n\ndef test_blur_accuracy(test_images: dict[str, ImageFile.ImageFile]) -> None:\n    snakes = test_images[\"snakes\"]\n\n    i = snakes.filter(ImageFilter.GaussianBlur(0.4))\n    # These pixels surrounded with pixels with 255 intensity.\n    # They must be very close to 255.\n    for x, y, c in [\n        (1, 0, 1),\n        (2, 0, 1),\n        (7, 8, 1),\n        (8, 8, 1),\n        (2, 9, 1),\n        (7, 3, 0),\n        (8, 3, 0),\n        (5, 8, 0),\n        (5, 9, 0),\n        (1, 3, 0),\n        (4, 3, 2),\n        (4, 2, 2),\n    ]:\n        assert i.im.getpixel((x, y))[c] >= 250\n    # Fuzzy match.\n\n    def gp(x, y):\n        return i.im.getpixel((x, y))\n\n    assert 236 <= gp(7, 4)[0] <= 239\n    assert 236 <= gp(7, 5)[2] <= 239\n    assert 236 <= gp(7, 6)[2] <= 239\n    assert 236 <= gp(7, 7)[1] <= 239\n    assert 236 <= gp(8, 4)[0] <= 239\n    assert 236 <= gp(8, 5)[2] <= 239\n    assert 236 <= gp(8, 6)[2] <= 239\n    assert 236 <= gp(8, 7)[1] <= 239\n", "Tests/test_file_gif.py": "from __future__ import annotations\n\nimport warnings\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import Generator\n\nimport pytest\n\nfrom PIL import GifImagePlugin, Image, ImageDraw, ImagePalette, ImageSequence, features\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    hopper,\n    is_pypy,\n    netpbm_available,\n)\n\n# sample gif stream\nTEST_GIF = \"Tests/images/hopper.gif\"\n\nwith open(TEST_GIF, \"rb\") as f:\n    data = f.read()\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_GIF) as im:\n        im.load()\n        assert im.mode == \"P\"\n        assert im.size == (128, 128)\n        assert im.format == \"GIF\"\n        assert im.info[\"version\"] == b\"GIF89a\"\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    def open() -> None:\n        im = Image.open(TEST_GIF)\n        im.load()\n\n    with pytest.warns(ResourceWarning):\n        open()\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        im = Image.open(TEST_GIF)\n        im.load()\n        im.close()\n\n\ndef test_seek_after_close() -> None:\n    im = Image.open(\"Tests/images/iss634.gif\")\n    assert isinstance(im, GifImagePlugin.GifImageFile)\n    im.load()\n    im.close()\n\n    with pytest.raises(ValueError):\n        im.is_animated\n    with pytest.raises(ValueError):\n        im.n_frames\n    with pytest.raises(ValueError):\n        im.seek(1)\n\n\ndef test_context_manager() -> None:\n    with warnings.catch_warnings():\n        with Image.open(TEST_GIF) as im:\n            im.load()\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        GifImagePlugin.GifImageFile(invalid_file)\n\n\ndef test_l_mode_transparency() -> None:\n    with Image.open(\"Tests/images/no_palette_with_transparency.gif\") as im:\n        assert im.mode == \"L\"\n        assert im.load()[0, 0] == 128\n        assert im.info[\"transparency\"] == 255\n\n        im.seek(1)\n        assert im.mode == \"L\"\n        assert im.load()[0, 0] == 128\n\n\ndef test_l_mode_after_rgb() -> None:\n    with Image.open(\"Tests/images/no_palette_after_rgb.gif\") as im:\n        im.seek(1)\n        assert im.mode == \"RGB\"\n\n        im.seek(2)\n        assert im.mode == \"RGB\"\n\n\ndef test_palette_not_needed_for_second_frame() -> None:\n    with Image.open(\"Tests/images/palette_not_needed_for_second_frame.gif\") as im:\n        im.seek(1)\n        assert_image_similar(im, hopper(\"L\").convert(\"RGB\"), 8)\n\n\ndef test_strategy() -> None:\n    with Image.open(\"Tests/images/iss634.gif\") as im:\n        expected_rgb_always = im.convert(\"RGB\")\n\n    with Image.open(\"Tests/images/chi.gif\") as im:\n        expected_rgb_always_rgba = im.convert(\"RGBA\")\n\n        im.seek(1)\n        expected_different = im.convert(\"RGB\")\n\n    try:\n        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_ALWAYS\n        with Image.open(\"Tests/images/iss634.gif\") as im:\n            assert im.mode == \"RGB\"\n            assert_image_equal(im, expected_rgb_always)\n\n        with Image.open(\"Tests/images/chi.gif\") as im:\n            assert im.mode == \"RGBA\"\n            assert_image_equal(im, expected_rgb_always_rgba)\n\n        GifImagePlugin.LOADING_STRATEGY = (\n            GifImagePlugin.LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY\n        )\n        # Stay in P mode with only a global palette\n        with Image.open(\"Tests/images/chi.gif\") as im:\n            assert im.mode == \"P\"\n\n            im.seek(1)\n            assert im.mode == \"P\"\n            assert_image_equal(im.convert(\"RGB\"), expected_different)\n\n        # Change to RGB mode when a frame has an individual palette\n        with Image.open(\"Tests/images/iss634.gif\") as im:\n            assert im.mode == \"P\"\n\n            im.seek(1)\n            assert im.mode == \"RGB\"\n    finally:\n        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST\n\n\ndef test_optimize() -> None:\n    def test_grayscale(optimize: int) -> int:\n        im = Image.new(\"L\", (1, 1), 0)\n        filename = BytesIO()\n        im.save(filename, \"GIF\", optimize=optimize)\n        return len(filename.getvalue())\n\n    def test_bilevel(optimize: int) -> int:\n        im = Image.new(\"1\", (1, 1), 0)\n        test_file = BytesIO()\n        im.save(test_file, \"GIF\", optimize=optimize)\n        return len(test_file.getvalue())\n\n    assert test_grayscale(0) == 799\n    assert test_grayscale(1) == 43\n    assert test_bilevel(0) == 799\n    assert test_bilevel(1) == 799\n\n\n@pytest.mark.parametrize(\n    \"colors, size, expected_palette_length\",\n    (\n        # These do optimize the palette\n        (256, 511, 256),\n        (255, 511, 255),\n        (129, 511, 129),\n        (128, 511, 128),\n        (64, 511, 64),\n        (4, 511, 4),\n        # These don't optimize the palette\n        (128, 513, 256),\n        (64, 513, 256),\n        (4, 513, 256),\n    ),\n)\ndef test_optimize_correctness(\n    colors: int, size: int, expected_palette_length: int\n) -> None:\n    # 256 color Palette image, posterize to > 128 and < 128 levels.\n    # Size bigger and smaller than 512x512.\n    # Check the palette for number of colors allocated.\n    # Check for correctness after conversion back to RGB.\n\n    # make an image with empty colors in the start of the palette range\n    im = Image.frombytes(\n        \"P\", (colors, colors), bytes(range(256 - colors, 256)) * colors\n    )\n    im = im.resize((size, size))\n    outfile = BytesIO()\n    im.save(outfile, \"GIF\")\n    outfile.seek(0)\n    with Image.open(outfile) as reloaded:\n        # check palette length\n        palette_length = max(i + 1 for i, v in enumerate(reloaded.histogram()) if v)\n        assert expected_palette_length == palette_length\n\n        assert_image_equal(im.convert(\"RGB\"), reloaded.convert(\"RGB\"))\n\n\ndef test_optimize_full_l() -> None:\n    im = Image.frombytes(\"L\", (16, 16), bytes(range(256)))\n    test_file = BytesIO()\n    im.save(test_file, \"GIF\", optimize=True)\n    assert im.mode == \"L\"\n\n\ndef test_optimize_if_palette_can_be_reduced_by_half() -> None:\n    im = Image.new(\"P\", (8, 1))\n    im.palette = ImagePalette.raw(\"RGB\", bytes((0, 0, 0) * 150))\n    for i in range(8):\n        im.putpixel((i, 0), (i + 1, 0, 0))\n\n    for optimize, colors in ((False, 256), (True, 8)):\n        out = BytesIO()\n        im.save(out, \"GIF\", optimize=optimize)\n        with Image.open(out) as reloaded:\n            assert len(reloaded.palette.palette) // 3 == colors\n\n\ndef test_full_palette_second_frame(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"P\", (1, 256))\n\n    full_palette_im = Image.new(\"P\", (1, 256))\n    for i in range(256):\n        full_palette_im.putpixel((0, i), i)\n    full_palette_im.palette = ImagePalette.ImagePalette(\n        \"RGB\", bytearray(i // 3 for i in range(768))\n    )\n    full_palette_im.palette.dirty = 1\n\n    im.save(out, save_all=True, append_images=[full_palette_im])\n\n    with Image.open(out) as reloaded:\n        reloaded.seek(1)\n\n        for i in range(256):\n            reloaded.getpixel((0, i)) == i\n\n\ndef test_roundtrip(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im = hopper()\n    im.save(out)\n    with Image.open(out) as reread:\n        assert_image_similar(reread.convert(\"RGB\"), im, 50)\n\n\ndef test_roundtrip2(tmp_path: Path) -> None:\n    # see https://github.com/python-pillow/Pillow/issues/403\n    out = str(tmp_path / \"temp.gif\")\n    with Image.open(TEST_GIF) as im:\n        im2 = im.copy()\n        im2.save(out)\n    with Image.open(out) as reread:\n        assert_image_similar(reread.convert(\"RGB\"), hopper(), 50)\n\n\ndef test_roundtrip_save_all(tmp_path: Path) -> None:\n    # Single frame image\n    out = str(tmp_path / \"temp.gif\")\n    im = hopper()\n    im.save(out, save_all=True)\n    with Image.open(out) as reread:\n        assert_image_similar(reread.convert(\"RGB\"), im, 50)\n\n    # Multiframe image\n    with Image.open(\"Tests/images/dispose_bgnd.gif\") as im:\n        out = str(tmp_path / \"temp.gif\")\n        im.save(out, save_all=True)\n\n    with Image.open(out) as reread:\n        assert reread.n_frames == 5\n\n\ndef test_roundtrip_save_all_1(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"1\", (1, 1))\n    im2 = Image.new(\"1\", (1, 1), 1)\n    im.save(out, save_all=True, append_images=[im2])\n\n    with Image.open(out) as reloaded:\n        assert reloaded.getpixel((0, 0)) == 0\n\n        reloaded.seek(1)\n        assert reloaded.getpixel((0, 0)) == 255\n\n\n@pytest.mark.parametrize(\n    \"path, mode\",\n    (\n        (\"Tests/images/dispose_bgnd.gif\", \"RGB\"),\n        # Hexeditted copy of dispose_bgnd to add transparency\n        (\"Tests/images/dispose_bgnd_rgba.gif\", \"RGBA\"),\n    ),\n)\ndef test_loading_multiple_palettes(path: str, mode: str) -> None:\n    with Image.open(path) as im:\n        assert im.mode == \"P\"\n        first_frame_colors = im.palette.colors.keys()\n        original_color = im.convert(\"RGB\").load()[0, 0]\n\n        im.seek(1)\n        assert im.mode == mode\n        if mode == \"RGBA\":\n            im = im.convert(\"RGB\")\n\n        # Check a color only from the old palette\n        assert im.load()[0, 0] == original_color\n\n        # Check a color from the new palette\n        assert im.load()[24, 24] not in first_frame_colors\n\n\ndef test_headers_saving_for_animated_gifs(tmp_path: Path) -> None:\n    important_headers = [\"background\", \"version\", \"duration\", \"loop\"]\n    # Multiframe image\n    with Image.open(\"Tests/images/dispose_bgnd.gif\") as im:\n        info = im.info.copy()\n\n        out = str(tmp_path / \"temp.gif\")\n        im.save(out, save_all=True)\n    with Image.open(out) as reread:\n        for header in important_headers:\n            assert info[header] == reread.info[header]\n\n\ndef test_palette_handling(tmp_path: Path) -> None:\n    # see https://github.com/python-pillow/Pillow/issues/513\n\n    with Image.open(TEST_GIF) as im:\n        im = im.convert(\"RGB\")\n\n        im = im.resize((100, 100), Image.Resampling.LANCZOS)\n        im2 = im.convert(\"P\", palette=Image.Palette.ADAPTIVE, colors=256)\n\n        f = str(tmp_path / \"temp.gif\")\n        im2.save(f, optimize=True)\n\n    with Image.open(f) as reloaded:\n        assert_image_similar(im, reloaded.convert(\"RGB\"), 10)\n\n\ndef test_palette_434(tmp_path: Path) -> None:\n    # see https://github.com/python-pillow/Pillow/issues/434\n\n    def roundtrip(im: Image.Image, **kwargs: bool) -> Image.Image:\n        out = str(tmp_path / \"temp.gif\")\n        im.copy().save(out, **kwargs)\n        reloaded = Image.open(out)\n\n        return reloaded\n\n    orig = \"Tests/images/test.colors.gif\"\n    with Image.open(orig) as im:\n        with roundtrip(im) as reloaded:\n            assert_image_similar(im, reloaded, 1)\n        with roundtrip(im, optimize=True) as reloaded:\n            assert_image_similar(im, reloaded, 1)\n\n        im = im.convert(\"RGB\")\n        # check automatic P conversion\n        with roundtrip(im) as reloaded:\n            reloaded = reloaded.convert(\"RGB\")\n            assert_image_equal(im, reloaded)\n\n\n@pytest.mark.skipif(not netpbm_available(), reason=\"Netpbm not available\")\ndef test_save_netpbm_bmp_mode(tmp_path: Path) -> None:\n    with Image.open(TEST_GIF) as img:\n        img = img.convert(\"RGB\")\n\n        tempfile = str(tmp_path / \"temp.gif\")\n        b = BytesIO()\n        GifImagePlugin._save_netpbm(img, b, tempfile)\n        with Image.open(tempfile) as reloaded:\n            assert_image_similar(img, reloaded.convert(\"RGB\"), 0)\n\n\n@pytest.mark.skipif(not netpbm_available(), reason=\"Netpbm not available\")\ndef test_save_netpbm_l_mode(tmp_path: Path) -> None:\n    with Image.open(TEST_GIF) as img:\n        img = img.convert(\"L\")\n\n        tempfile = str(tmp_path / \"temp.gif\")\n        b = BytesIO()\n        GifImagePlugin._save_netpbm(img, b, tempfile)\n        with Image.open(tempfile) as reloaded:\n            assert_image_similar(img, reloaded.convert(\"L\"), 0)\n\n\ndef test_seek() -> None:\n    with Image.open(\"Tests/images/dispose_none.gif\") as img:\n        frame_count = 0\n        try:\n            while True:\n                frame_count += 1\n                img.seek(img.tell() + 1)\n        except EOFError:\n            assert frame_count == 5\n\n\ndef test_seek_info() -> None:\n    with Image.open(\"Tests/images/iss634.gif\") as im:\n        info = im.info.copy()\n\n        im.seek(1)\n        im.seek(0)\n\n        assert im.info == info\n\n\ndef test_seek_rewind() -> None:\n    with Image.open(\"Tests/images/iss634.gif\") as im:\n        im.seek(2)\n        im.seek(1)\n\n        with Image.open(\"Tests/images/iss634.gif\") as expected:\n            expected.seek(1)\n            assert_image_equal(im, expected)\n\n\n@pytest.mark.parametrize(\n    \"path, n_frames\",\n    (\n        (TEST_GIF, 1),\n        (\"Tests/images/comment_after_last_frame.gif\", 2),\n        (\"Tests/images/iss634.gif\", 42),\n    ),\n)\ndef test_n_frames(path: str, n_frames: int) -> None:\n    # Test is_animated before n_frames\n    with Image.open(path) as im:\n        assert im.is_animated == (n_frames != 1)\n\n    # Test is_animated after n_frames\n    with Image.open(path) as im:\n        assert im.n_frames == n_frames\n        assert im.is_animated == (n_frames != 1)\n\n\ndef test_no_change() -> None:\n    # Test n_frames does not change the image\n    with Image.open(\"Tests/images/dispose_bgnd.gif\") as im:\n        im.seek(1)\n        expected = im.copy()\n        assert im.n_frames == 5\n        assert_image_equal(im, expected)\n\n    # Test is_animated does not change the image\n    with Image.open(\"Tests/images/dispose_bgnd.gif\") as im:\n        im.seek(3)\n        expected = im.copy()\n        assert im.is_animated\n        assert_image_equal(im, expected)\n\n    with Image.open(\"Tests/images/comment_after_only_frame.gif\") as im:\n        expected = Image.new(\"P\", (1, 1))\n        assert not im.is_animated\n        assert_image_equal(im, expected)\n\n\ndef test_eoferror() -> None:\n    with Image.open(TEST_GIF) as im:\n        n_frames = im.n_frames\n\n        # Test seeking past the last frame\n        with pytest.raises(EOFError):\n            im.seek(n_frames)\n        assert im.tell() < n_frames\n\n        # Test that seeking to the last frame does not raise an error\n        im.seek(n_frames - 1)\n\n\ndef test_first_frame_transparency() -> None:\n    with Image.open(\"Tests/images/first_frame_transparency.gif\") as im:\n        px = im.load()\n        assert px[0, 0] == im.info[\"transparency\"]\n\n\ndef test_dispose_none() -> None:\n    with Image.open(\"Tests/images/dispose_none.gif\") as img:\n        try:\n            while True:\n                img.seek(img.tell() + 1)\n                assert img.disposal_method == 1\n        except EOFError:\n            pass\n\n\ndef test_dispose_none_load_end() -> None:\n    # Test image created with:\n    #\n    # im = Image.open(\"transparent.gif\")\n    # im_rotated = im.rotate(180)\n    # im.save(\"dispose_none_load_end.gif\",\n    #         save_all=True, append_images=[im_rotated], disposal=[1,2])\n    with Image.open(\"Tests/images/dispose_none_load_end.gif\") as img:\n        img.seek(1)\n\n        assert_image_equal_tofile(img, \"Tests/images/dispose_none_load_end_second.png\")\n\n\ndef test_dispose_background() -> None:\n    with Image.open(\"Tests/images/dispose_bgnd.gif\") as img:\n        try:\n            while True:\n                img.seek(img.tell() + 1)\n                assert img.disposal_method == 2\n        except EOFError:\n            pass\n\n\ndef test_dispose_background_transparency() -> None:\n    with Image.open(\"Tests/images/dispose_bgnd_transparency.gif\") as img:\n        img.seek(2)\n        px = img.load()\n        assert px[35, 30][3] == 0\n\n\n@pytest.mark.parametrize(\n    \"loading_strategy, expected_colors\",\n    (\n        (\n            GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST,\n            (\n                (2, 1, 2),\n                ((0, 255, 24, 255), (0, 0, 255, 255), (0, 255, 24, 255)),\n                ((0, 0, 0, 0), (0, 0, 255, 255), (0, 0, 0, 0)),\n            ),\n        ),\n        (\n            GifImagePlugin.LoadingStrategy.RGB_AFTER_DIFFERENT_PALETTE_ONLY,\n            (\n                (2, 1, 2),\n                (0, 1, 0),\n                (2, 1, 2),\n            ),\n        ),\n    ),\n)\ndef test_transparent_dispose(\n    loading_strategy: GifImagePlugin.LoadingStrategy,\n    expected_colors: tuple[tuple[int | tuple[int, int, int, int], ...]],\n) -> None:\n    GifImagePlugin.LOADING_STRATEGY = loading_strategy\n    try:\n        with Image.open(\"Tests/images/transparent_dispose.gif\") as img:\n            for frame in range(3):\n                img.seek(frame)\n                for x in range(3):\n                    color = img.getpixel((x, 0))\n                    assert color == expected_colors[frame][x]\n    finally:\n        GifImagePlugin.LOADING_STRATEGY = GifImagePlugin.LoadingStrategy.RGB_AFTER_FIRST\n\n\ndef test_dispose_previous() -> None:\n    with Image.open(\"Tests/images/dispose_prev.gif\") as img:\n        try:\n            while True:\n                img.seek(img.tell() + 1)\n                assert img.disposal_method == 3\n        except EOFError:\n            pass\n\n\ndef test_dispose_previous_first_frame() -> None:\n    with Image.open(\"Tests/images/dispose_prev_first_frame.gif\") as im:\n        im.seek(1)\n        assert_image_equal_tofile(\n            im, \"Tests/images/dispose_prev_first_frame_seeked.png\"\n        )\n\n\ndef test_previous_frame_loaded() -> None:\n    with Image.open(\"Tests/images/dispose_none.gif\") as img:\n        img.load()\n        img.seek(1)\n        img.load()\n        img.seek(2)\n        with Image.open(\"Tests/images/dispose_none.gif\") as img_skipped:\n            img_skipped.seek(2)\n            assert_image_equal(img_skipped, img)\n\n\ndef test_save_dispose(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im_list = [\n        Image.new(\"L\", (100, 100), \"#000\"),\n        Image.new(\"L\", (100, 100), \"#111\"),\n        Image.new(\"L\", (100, 100), \"#222\"),\n    ]\n    for method in range(0, 4):\n        im_list[0].save(out, save_all=True, append_images=im_list[1:], disposal=method)\n        with Image.open(out) as img:\n            for _ in range(2):\n                img.seek(img.tell() + 1)\n                assert img.disposal_method == method\n\n    # Check per frame disposal\n    im_list[0].save(\n        out,\n        save_all=True,\n        append_images=im_list[1:],\n        disposal=tuple(range(len(im_list))),\n    )\n\n    with Image.open(out) as img:\n        for i in range(2):\n            img.seek(img.tell() + 1)\n            assert img.disposal_method == i + 1\n\n\ndef test_dispose2_palette(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    # Four colors: white, gray, black, red\n    circles = [(255, 255, 255), (153, 153, 153), (0, 0, 0), (255, 0, 0)]\n\n    im_list = []\n    for circle in circles:\n        # Red background\n        img = Image.new(\"RGB\", (100, 100), (255, 0, 0))\n\n        # Circle in center of each frame\n        d = ImageDraw.Draw(img)\n        d.ellipse([(40, 40), (60, 60)], fill=circle)\n\n        im_list.append(img)\n\n    im_list[0].save(out, save_all=True, append_images=im_list[1:], disposal=2)\n\n    with Image.open(out) as img:\n        for i, circle in enumerate(circles):\n            img.seek(i)\n            rgb_img = img.convert(\"RGB\")\n\n            # Check top left pixel matches background\n            assert rgb_img.getpixel((0, 0)) == (255, 0, 0)\n\n            # Center remains red every frame\n            assert rgb_img.getpixel((50, 50)) == circle\n\n            # Check that frame transparency wasn't added unnecessarily\n            assert getattr(img, \"_frame_transparency\") is None\n\n\ndef test_dispose2_diff(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    # 4 frames: red/blue, red/red, blue/blue, red/blue\n    circles = [\n        ((255, 0, 0, 255), (0, 0, 255, 255)),\n        ((255, 0, 0, 255), (255, 0, 0, 255)),\n        ((0, 0, 255, 255), (0, 0, 255, 255)),\n        ((255, 0, 0, 255), (0, 0, 255, 255)),\n    ]\n\n    im_list = []\n    for i in range(len(circles)):\n        # Transparent BG\n        img = Image.new(\"RGBA\", (100, 100), (255, 255, 255, 0))\n\n        # Two circles per frame\n        d = ImageDraw.Draw(img)\n        d.ellipse([(0, 30), (40, 70)], fill=circles[i][0])\n        d.ellipse([(60, 30), (100, 70)], fill=circles[i][1])\n\n        im_list.append(img)\n\n    im_list[0].save(\n        out, save_all=True, append_images=im_list[1:], disposal=2, transparency=0\n    )\n\n    with Image.open(out) as img:\n        for i, colours in enumerate(circles):\n            img.seek(i)\n            rgb_img = img.convert(\"RGBA\")\n\n            # Check left circle is correct colour\n            assert rgb_img.getpixel((20, 50)) == colours[0]\n\n            # Check right circle is correct colour\n            assert rgb_img.getpixel((80, 50)) == colours[1]\n\n            # Check BG is correct colour\n            assert rgb_img.getpixel((1, 1)) == (255, 255, 255, 0)\n\n\ndef test_dispose2_background(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im_list = []\n\n    im = Image.new(\"P\", (100, 100))\n    d = ImageDraw.Draw(im)\n    d.rectangle([(50, 0), (100, 100)], fill=\"#f00\")\n    d.rectangle([(0, 0), (50, 100)], fill=\"#0f0\")\n    im_list.append(im)\n\n    im = Image.new(\"P\", (100, 100))\n    d = ImageDraw.Draw(im)\n    d.rectangle([(0, 0), (100, 50)], fill=\"#f00\")\n    d.rectangle([(0, 50), (100, 100)], fill=\"#0f0\")\n    im_list.append(im)\n\n    im_list[0].save(\n        out, save_all=True, append_images=im_list[1:], disposal=[0, 2], background=1\n    )\n\n    with Image.open(out) as im:\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (255, 0, 0)\n\n\ndef test_dispose2_background_frame(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im_list = [Image.new(\"RGBA\", (1, 20))]\n\n    different_frame = Image.new(\"RGBA\", (1, 20))\n    different_frame.putpixel((0, 10), (255, 0, 0, 255))\n    im_list.append(different_frame)\n\n    # Frame that matches the background\n    im_list.append(Image.new(\"RGBA\", (1, 20)))\n\n    im_list[0].save(out, save_all=True, append_images=im_list[1:], disposal=2)\n\n    with Image.open(out) as im:\n        assert im.n_frames == 3\n\n\ndef test_dispose2_previous_frame(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im = Image.new(\"P\", (100, 100))\n    im.info[\"transparency\"] = 0\n    d = ImageDraw.Draw(im)\n    d.rectangle([(0, 0), (100, 50)], 1)\n    im.putpalette((0, 0, 0, 255, 0, 0))\n\n    im2 = Image.new(\"P\", (100, 100))\n    im2.putpalette((0, 0, 0))\n\n    im.save(out, save_all=True, append_images=[im2], disposal=[0, 2])\n\n    with Image.open(out) as im:\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (0, 0, 0, 255)\n\n\ndef test_transparency_in_second_frame(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    with Image.open(\"Tests/images/different_transparency.gif\") as im:\n        assert im.info[\"transparency\"] == 0\n\n        # Seek to the second frame\n        im.seek(im.tell() + 1)\n        assert \"transparency\" not in im.info\n\n        assert_image_equal_tofile(im, \"Tests/images/different_transparency_merged.png\")\n\n        im.save(out, save_all=True)\n\n    with Image.open(out) as reread:\n        reread.seek(reread.tell() + 1)\n        assert_image_equal_tofile(\n            reread, \"Tests/images/different_transparency_merged.png\"\n        )\n\n\ndef test_no_transparency_in_second_frame() -> None:\n    with Image.open(\"Tests/images/iss634.gif\") as img:\n        # Seek to the second frame\n        img.seek(img.tell() + 1)\n        assert \"transparency\" not in img.info\n\n        # All transparent pixels should be replaced with the color from the first frame\n        assert img.histogram()[255] == 0\n\n\ndef test_remapped_transparency(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im = Image.new(\"P\", (1, 2))\n    im2 = im.copy()\n\n    # Add transparency at a higher index\n    # so that it will be optimized to a lower index\n    im.putpixel((0, 1), 5)\n    im.info[\"transparency\"] = 5\n    im.save(out, save_all=True, append_images=[im2])\n\n    with Image.open(out) as reloaded:\n        assert reloaded.info[\"transparency\"] == reloaded.getpixel((0, 1))\n\n\ndef test_duration(tmp_path: Path) -> None:\n    duration = 1000\n\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"L\", (100, 100), \"#000\")\n\n    # Check that the argument has priority over the info settings\n    im.info[\"duration\"] = 100\n    im.save(out, duration=duration)\n\n    with Image.open(out) as reread:\n        assert reread.info[\"duration\"] == duration\n\n\ndef test_multiple_duration(tmp_path: Path) -> None:\n    duration_list = [1000, 2000, 3000]\n\n    out = str(tmp_path / \"temp.gif\")\n    im_list = [\n        Image.new(\"L\", (100, 100), \"#000\"),\n        Image.new(\"L\", (100, 100), \"#111\"),\n        Image.new(\"L\", (100, 100), \"#222\"),\n    ]\n\n    # Duration as list\n    im_list[0].save(\n        out, save_all=True, append_images=im_list[1:], duration=duration_list\n    )\n    with Image.open(out) as reread:\n        for duration in duration_list:\n            assert reread.info[\"duration\"] == duration\n            try:\n                reread.seek(reread.tell() + 1)\n            except EOFError:\n                pass\n\n    # Duration as tuple\n    im_list[0].save(\n        out, save_all=True, append_images=im_list[1:], duration=tuple(duration_list)\n    )\n    with Image.open(out) as reread:\n        for duration in duration_list:\n            assert reread.info[\"duration\"] == duration\n            try:\n                reread.seek(reread.tell() + 1)\n            except EOFError:\n                pass\n\n\ndef test_roundtrip_info_duration(tmp_path: Path) -> None:\n    duration_list = [100, 500, 500]\n\n    out = str(tmp_path / \"temp.gif\")\n    with Image.open(\"Tests/images/transparent_dispose.gif\") as im:\n        assert [\n            frame.info[\"duration\"] for frame in ImageSequence.Iterator(im)\n        ] == duration_list\n\n        im.save(out, save_all=True)\n\n    with Image.open(out) as reloaded:\n        assert [\n            frame.info[\"duration\"] for frame in ImageSequence.Iterator(reloaded)\n        ] == duration_list\n\n\ndef test_roundtrip_info_duration_combined(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    with Image.open(\"Tests/images/duplicate_frame.gif\") as im:\n        assert [frame.info[\"duration\"] for frame in ImageSequence.Iterator(im)] == [\n            1000,\n            1000,\n            1000,\n        ]\n        im.save(out, save_all=True)\n\n    with Image.open(out) as reloaded:\n        assert [\n            frame.info[\"duration\"] for frame in ImageSequence.Iterator(reloaded)\n        ] == [1000, 2000]\n\n\ndef test_identical_frames(tmp_path: Path) -> None:\n    duration_list = [1000, 1500, 2000, 4000]\n\n    out = str(tmp_path / \"temp.gif\")\n    im_list = [\n        Image.new(\"L\", (100, 100), \"#000\"),\n        Image.new(\"L\", (100, 100), \"#000\"),\n        Image.new(\"L\", (100, 100), \"#000\"),\n        Image.new(\"L\", (100, 100), \"#111\"),\n    ]\n\n    # Duration as list\n    im_list[0].save(\n        out, save_all=True, append_images=im_list[1:], duration=duration_list\n    )\n    with Image.open(out) as reread:\n        # Assert that the first three frames were combined\n        assert reread.n_frames == 2\n\n        # Assert that the new duration is the total of the identical frames\n        assert reread.info[\"duration\"] == 4500\n\n\n@pytest.mark.parametrize(\n    \"duration\",\n    (\n        [1000, 1500, 2000],\n        (1000, 1500, 2000),\n        # One more duration than the number of frames\n        [1000, 1500, 2000, 4000],\n        1500,\n    ),\n)\ndef test_identical_frames_to_single_frame(\n    duration: int | list[int], tmp_path: Path\n) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im_list = [\n        Image.new(\"L\", (100, 100), \"#000\"),\n        Image.new(\"L\", (100, 100), \"#000\"),\n        Image.new(\"L\", (100, 100), \"#000\"),\n    ]\n\n    im_list[0].save(out, save_all=True, append_images=im_list[1:], duration=duration)\n    with Image.open(out) as reread:\n        # Assert that all frames were combined\n        assert reread.n_frames == 1\n\n        # Assert that the new duration is the total of the identical frames\n        assert reread.info[\"duration\"] == 4500\n\n\ndef test_loop_none(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    im.save(out, loop=None)\n    with Image.open(out) as reread:\n        assert \"loop\" not in reread.info\n\n\ndef test_number_of_loops(tmp_path: Path) -> None:\n    number_of_loops = 2\n\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    im.save(out, loop=number_of_loops)\n    with Image.open(out) as reread:\n        assert reread.info[\"loop\"] == number_of_loops\n\n    # Check that even if a subsequent GIF frame has the number of loops specified,\n    # only the value from the first frame is used\n    with Image.open(\"Tests/images/duplicate_number_of_loops.gif\") as im:\n        assert im.info[\"loop\"] == 2\n\n        im.seek(1)\n        assert im.info[\"loop\"] == 2\n\n\ndef test_background(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    im.info[\"background\"] = 1\n    im.save(out)\n    with Image.open(out) as reread:\n        assert reread.info[\"background\"] == im.info[\"background\"]\n\n\ndef test_webp_background(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    # Test opaque WebP background\n    if features.check(\"webp\") and features.check(\"webp_anim\"):\n        with Image.open(\"Tests/images/hopper.webp\") as im:\n            assert im.info[\"background\"] == (255, 255, 255, 255)\n            im.save(out)\n\n    # Test non-opaque WebP background\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    im.info[\"background\"] = (0, 0, 0, 0)\n    im.save(out)\n\n\ndef test_comment(tmp_path: Path) -> None:\n    with Image.open(TEST_GIF) as im:\n        assert im.info[\"comment\"] == b\"File written by Adobe Photoshop\\xa8 4.0\"\n\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    im.info[\"comment\"] = b\"Test comment text\"\n    im.save(out)\n    with Image.open(out) as reread:\n        assert reread.info[\"comment\"] == im.info[\"comment\"]\n\n    im.info[\"comment\"] = \"Test comment text\"\n    im.save(out)\n    with Image.open(out) as reread:\n        assert reread.info[\"comment\"] == im.info[\"comment\"].encode()\n\n        # Test that GIF89a is used for comments\n        assert reread.info[\"version\"] == b\"GIF89a\"\n\n\ndef test_comment_over_255(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    comment = b\"Test comment text\"\n    while len(comment) < 256:\n        comment += comment\n    im.info[\"comment\"] = comment\n    im.save(out)\n    with Image.open(out) as reread:\n        assert reread.info[\"comment\"] == comment\n\n        # Test that GIF89a is used for comments\n        assert reread.info[\"version\"] == b\"GIF89a\"\n\n\ndef test_zero_comment_subblocks() -> None:\n    with Image.open(\"Tests/images/hopper_zero_comment_subblocks.gif\") as im:\n        assert_image_equal_tofile(im, TEST_GIF)\n\n\ndef test_read_multiple_comment_blocks() -> None:\n    with Image.open(\"Tests/images/multiple_comments.gif\") as im:\n        # Multiple comment blocks in a frame are separated not concatenated\n        assert im.info[\"comment\"] == b\"Test comment 1\\nTest comment 2\"\n\n\ndef test_empty_string_comment(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    with Image.open(\"Tests/images/chi.gif\") as im:\n        assert \"comment\" in im.info\n\n        # Empty string comment should suppress existing comment\n        im.save(out, save_all=True, comment=\"\")\n\n    with Image.open(out) as reread:\n        for frame in ImageSequence.Iterator(reread):\n            assert \"comment\" not in frame.info\n\n\ndef test_retain_comment_in_subsequent_frames(tmp_path: Path) -> None:\n    # Test that a comment block at the beginning is kept\n    with Image.open(\"Tests/images/chi.gif\") as im:\n        for frame in ImageSequence.Iterator(im):\n            assert frame.info[\"comment\"] == b\"Created with GIMP\"\n\n    with Image.open(\"Tests/images/second_frame_comment.gif\") as im:\n        assert \"comment\" not in im.info\n\n        # Test that a comment in the middle is read\n        im.seek(1)\n        assert im.info[\"comment\"] == b\"Comment in the second frame\"\n\n        # Test that it is still present in a later frame\n        im.seek(2)\n        assert im.info[\"comment\"] == b\"Comment in the second frame\"\n\n        # Test that rewinding removes the comment\n        im.seek(0)\n        assert \"comment\" not in im.info\n\n    # Test that a saved image keeps the comment\n    out = str(tmp_path / \"temp.gif\")\n    with Image.open(\"Tests/images/dispose_prev.gif\") as im:\n        im.save(out, save_all=True, comment=\"Test\")\n\n    with Image.open(out) as reread:\n        for frame in ImageSequence.Iterator(reread):\n            assert frame.info[\"comment\"] == b\"Test\"\n\n\ndef test_version(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    def assert_version_after_save(im: Image.Image, version: bytes) -> None:\n        im.save(out)\n        with Image.open(out) as reread:\n            assert reread.info[\"version\"] == version\n\n    # Test that GIF87a is used by default\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    assert_version_after_save(im, b\"GIF87a\")\n\n    # Test setting the version to 89a\n    im = Image.new(\"L\", (100, 100), \"#000\")\n    im.info[\"version\"] = b\"89a\"\n    assert_version_after_save(im, b\"GIF89a\")\n\n    # Test that adding a GIF89a feature changes the version\n    im.info[\"transparency\"] = 1\n    assert_version_after_save(im, b\"GIF89a\")\n\n    # Test that a GIF87a image is also saved in that format\n    with Image.open(\"Tests/images/test.colors.gif\") as im:\n        assert_version_after_save(im, b\"GIF87a\")\n\n        # Test that a GIF89a image is also saved in that format\n        im.info[\"version\"] = b\"GIF89a\"\n        assert_version_after_save(im, b\"GIF87a\")\n\n\ndef test_append_images(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    # Test appending single frame images\n    im = Image.new(\"RGB\", (100, 100), \"#f00\")\n    ims = [Image.new(\"RGB\", (100, 100), color) for color in [\"#0f0\", \"#00f\"]]\n    im.copy().save(out, save_all=True, append_images=ims)\n\n    with Image.open(out) as reread:\n        assert reread.n_frames == 3\n\n    # Tests appending using a generator\n    def im_generator(ims: list[Image.Image]) -> Generator[Image.Image, None, None]:\n        yield from ims\n\n    im.save(out, save_all=True, append_images=im_generator(ims))\n\n    with Image.open(out) as reread:\n        assert reread.n_frames == 3\n\n    # Tests appending single and multiple frame images\n    with Image.open(\"Tests/images/dispose_none.gif\") as im:\n        with Image.open(\"Tests/images/dispose_prev.gif\") as im2:\n            im.save(out, save_all=True, append_images=[im2])\n\n    with Image.open(out) as reread:\n        assert reread.n_frames == 10\n\n\ndef test_append_different_size_image(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im = Image.new(\"RGB\", (100, 100))\n    bigger_im = Image.new(\"RGB\", (200, 200), \"#f00\")\n\n    im.save(out, save_all=True, append_images=[bigger_im])\n\n    with Image.open(out) as reread:\n        assert reread.size == (100, 100)\n\n        reread.seek(1)\n        assert reread.size == (100, 100)\n\n\ndef test_transparent_optimize(tmp_path: Path) -> None:\n    # From issue #2195, if the transparent color is incorrectly optimized out, GIF loses\n    # transparency.\n    # Need a palette that isn't using the 0 color,\n    # where the transparent color is actually the top palette entry to trigger the bug.\n\n    data = bytes(range(1, 254))\n    palette = ImagePalette.ImagePalette(\"RGB\", list(range(256)) * 3)\n\n    im = Image.new(\"L\", (253, 1))\n    im.frombytes(data)\n    im.putpalette(palette)\n\n    out = str(tmp_path / \"temp.gif\")\n    im.save(out, transparency=im.getpixel((252, 0)))\n\n    with Image.open(out) as reloaded:\n        assert reloaded.info[\"transparency\"] == reloaded.getpixel((252, 0))\n\n\ndef test_removed_transparency(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    im = Image.new(\"RGB\", (256, 1))\n\n    for x in range(256):\n        im.putpixel((x, 0), (x, 0, 0))\n\n    im.info[\"transparency\"] = (255, 255, 255)\n    with pytest.warns(UserWarning):\n        im.save(out)\n\n    with Image.open(out) as reloaded:\n        assert \"transparency\" not in reloaded.info\n\n\ndef test_rgb_transparency(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    # Single frame\n    im = Image.new(\"RGB\", (1, 1))\n    im.info[\"transparency\"] = (255, 0, 0)\n    im.save(out)\n\n    with Image.open(out) as reloaded:\n        assert \"transparency\" in reloaded.info\n\n    # Multiple frames\n    im = Image.new(\"RGB\", (1, 1))\n    im.info[\"transparency\"] = b\"\"\n    ims = [Image.new(\"RGB\", (1, 1))]\n    with pytest.warns(UserWarning):\n        im.save(out, save_all=True, append_images=ims)\n\n    with Image.open(out) as reloaded:\n        assert \"transparency\" not in reloaded.info\n\n\ndef test_rgba_transparency(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im = hopper(\"P\")\n    im.save(out, save_all=True, append_images=[Image.new(\"RGBA\", im.size)])\n\n    with Image.open(out) as reloaded:\n        reloaded.seek(1)\n        assert_image_equal(hopper(\"P\").convert(\"RGB\"), reloaded)\n\n\ndef test_background_outside_palettte(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/background_outside_palette.gif\") as im:\n        im.seek(1)\n        assert im.info[\"background\"] == 255\n\n\ndef test_bbox(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im = Image.new(\"RGB\", (100, 100), \"#fff\")\n    ims = [Image.new(\"RGB\", (100, 100), \"#000\")]\n    im.save(out, save_all=True, append_images=ims)\n\n    with Image.open(out) as reread:\n        assert reread.n_frames == 2\n\n\ndef test_bbox_alpha(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n\n    im = Image.new(\"RGBA\", (1, 2), (255, 0, 0, 255))\n    im.putpixel((0, 1), (255, 0, 0, 0))\n    im2 = Image.new(\"RGBA\", (1, 2), (255, 0, 0, 0))\n    im.save(out, save_all=True, append_images=[im2])\n\n    with Image.open(out) as reread:\n        assert reread.n_frames == 2\n\n\ndef test_palette_save_L(tmp_path: Path) -> None:\n    # Generate an L mode image with a separate palette\n\n    im = hopper(\"P\")\n    im_l = Image.frombytes(\"L\", im.size, im.tobytes())\n    palette = im.getpalette()\n    assert palette is not None\n\n    out = str(tmp_path / \"temp.gif\")\n    im_l.save(out, palette=bytes(palette))\n\n    with Image.open(out) as reloaded:\n        assert_image_equal(reloaded.convert(\"RGB\"), im.convert(\"RGB\"))\n\n\ndef test_palette_save_P(tmp_path: Path) -> None:\n    im = Image.new(\"P\", (1, 2))\n    im.putpixel((0, 1), 1)\n\n    out = str(tmp_path / \"temp.gif\")\n    im.save(out, palette=bytes((1, 2, 3, 4, 5, 6)))\n\n    with Image.open(out) as reloaded:\n        reloaded_rgb = reloaded.convert(\"RGB\")\n\n        assert reloaded_rgb.getpixel((0, 0)) == (1, 2, 3)\n        assert reloaded_rgb.getpixel((0, 1)) == (4, 5, 6)\n\n\ndef test_palette_save_duplicate_entries(tmp_path: Path) -> None:\n    im = Image.new(\"P\", (1, 2))\n    im.putpixel((0, 1), 1)\n\n    im.putpalette((0, 0, 0, 0, 0, 0))\n\n    out = str(tmp_path / \"temp.gif\")\n    im.save(out, palette=[0, 0, 0, 0, 0, 0, 1, 1, 1])\n\n    with Image.open(out) as reloaded:\n        assert reloaded.convert(\"RGB\").getpixel((0, 1)) == (0, 0, 0)\n\n\ndef test_palette_save_all_P(tmp_path: Path) -> None:\n    frames = []\n    colors = ((255, 0, 0), (0, 255, 0))\n    for color in colors:\n        frame = Image.new(\"P\", (100, 100))\n        frame.putpalette(color)\n        frames.append(frame)\n\n    out = str(tmp_path / \"temp.gif\")\n    frames[0].save(\n        out, save_all=True, palette=[255, 0, 0, 0, 255, 0], append_images=frames[1:]\n    )\n\n    with Image.open(out) as im:\n        # Assert that the frames are correct, and each frame has the same palette\n        assert_image_equal(im.convert(\"RGB\"), frames[0].convert(\"RGB\"))\n        assert im.palette.palette == im.global_palette.palette\n\n        im.seek(1)\n        assert_image_equal(im.convert(\"RGB\"), frames[1].convert(\"RGB\"))\n        assert im.palette.palette == im.global_palette.palette\n\n\ndef test_palette_save_ImagePalette(tmp_path: Path) -> None:\n    # Pass in a different palette, as an ImagePalette.ImagePalette\n    # effectively the same as test_palette_save_P\n\n    im = hopper(\"P\")\n    palette = ImagePalette.ImagePalette(\"RGB\", list(range(256))[::-1] * 3)\n\n    out = str(tmp_path / \"temp.gif\")\n    im.save(out, palette=palette)\n\n    with Image.open(out) as reloaded:\n        im.putpalette(palette)\n        assert_image_equal(reloaded.convert(\"RGB\"), im.convert(\"RGB\"))\n\n\ndef test_save_I(tmp_path: Path) -> None:\n    # Test saving something that would trigger the auto-convert to 'L'\n\n    im = hopper(\"I\")\n\n    out = str(tmp_path / \"temp.gif\")\n    im.save(out)\n\n    with Image.open(out) as reloaded:\n        assert_image_equal(reloaded.convert(\"L\"), im.convert(\"L\"))\n\n\ndef test_getdata() -> None:\n    # Test getheader/getdata against legacy values.\n    # Create a 'P' image with holes in the palette.\n    im = Image._wedge().resize((16, 16), Image.Resampling.NEAREST)\n    im.putpalette(ImagePalette.ImagePalette(\"RGB\"))\n    im.info = {\"background\": 0}\n\n    passed_palette = bytes(255 - i // 3 for i in range(768))\n\n    GifImagePlugin._FORCE_OPTIMIZE = True\n    try:\n        h = GifImagePlugin.getheader(im, passed_palette)\n        d = GifImagePlugin.getdata(im)\n\n        import pickle\n\n        # Enable to get target values on pre-refactor version\n        # with open('Tests/images/gif_header_data.pkl', 'wb') as f:\n        #    pickle.dump((h, d), f, 1)\n        with open(\"Tests/images/gif_header_data.pkl\", \"rb\") as f:\n            (h_target, d_target) = pickle.load(f)\n\n        assert h == h_target\n        assert d == d_target\n    finally:\n        GifImagePlugin._FORCE_OPTIMIZE = False\n\n\ndef test_lzw_bits() -> None:\n    # see https://github.com/python-pillow/Pillow/issues/2811\n    with Image.open(\"Tests/images/issue_2811.gif\") as im:\n        assert im.tile[0][3][0] == 11  # LZW bits\n        # codec error prepatch\n        im.load()\n\n\ndef test_extents() -> None:\n    with Image.open(\"Tests/images/test_extents.gif\") as im:\n        assert im.size == (100, 100)\n\n        # Check that n_frames does not change the size\n        assert im.n_frames == 2\n        assert im.size == (100, 100)\n\n        im.seek(1)\n        assert im.size == (150, 150)\n\n\ndef test_missing_background() -> None:\n    # The Global Color Table Flag isn't set, so there is no background color index,\n    # but the disposal method is \"Restore to background color\"\n    with Image.open(\"Tests/images/missing_background.gif\") as im:\n        im.seek(1)\n        assert_image_equal_tofile(im, \"Tests/images/missing_background_first_frame.png\")\n\n\ndef test_saving_rgba(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.gif\")\n    with Image.open(\"Tests/images/transparent.png\") as im:\n        im.save(out)\n\n    with Image.open(out) as reloaded:\n        reloaded_rgba = reloaded.convert(\"RGBA\")\n        assert reloaded_rgba.load()[0, 0][3] == 0\n", "Tests/test_imagefont.py": "from __future__ import annotations\n\nimport copy\nimport os\nimport re\nimport shutil\nimport sys\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import Any, BinaryIO\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nfrom PIL import Image, ImageDraw, ImageFont, features\nfrom PIL._typing import StrOrBytesPath\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar_tofile,\n    is_win32,\n    skip_unless_feature,\n    skip_unless_feature_version,\n)\n\nFONT_PATH = \"Tests/fonts/FreeMono.ttf\"\nFONT_SIZE = 20\n\nTEST_TEXT = \"hey you\\nyou are awesome\\nthis looks awkward\"\n\n\npytestmark = skip_unless_feature(\"freetype2\")\n\n\ndef test_sanity() -> None:\n    version = features.version_module(\"freetype2\")\n    assert version is not None\n    assert re.search(r\"\\d+\\.\\d+\\.\\d+$\", version)\n\n\n@pytest.fixture(\n    scope=\"module\",\n    params=[\n        pytest.param(ImageFont.Layout.BASIC),\n        pytest.param(ImageFont.Layout.RAQM, marks=skip_unless_feature(\"raqm\")),\n    ],\n)\ndef layout_engine(request: pytest.FixtureRequest) -> ImageFont.Layout:\n    return request.param\n\n\n@pytest.fixture(scope=\"module\")\ndef font(layout_engine: ImageFont.Layout) -> ImageFont.FreeTypeFont:\n    return ImageFont.truetype(FONT_PATH, FONT_SIZE, layout_engine=layout_engine)\n\n\ndef test_font_properties(font: ImageFont.FreeTypeFont) -> None:\n    assert font.path == FONT_PATH\n    assert font.size == FONT_SIZE\n\n    font_copy = font.font_variant()\n    assert font_copy.path == FONT_PATH\n    assert font_copy.size == FONT_SIZE\n\n    font_copy = font.font_variant(size=FONT_SIZE + 1)\n    assert font_copy.size == FONT_SIZE + 1\n\n    second_font_path = \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\"\n    font_copy = font.font_variant(font=second_font_path)\n    assert font_copy.path == second_font_path\n\n\ndef _render(\n    font: StrOrBytesPath | BinaryIO, layout_engine: ImageFont.Layout\n) -> Image.Image:\n    txt = \"Hello World!\"\n    ttf = ImageFont.truetype(font, FONT_SIZE, layout_engine=layout_engine)\n    ttf.getbbox(txt)\n\n    img = Image.new(\"RGB\", (256, 64), \"white\")\n    d = ImageDraw.Draw(img)\n    d.text((10, 10), txt, font=ttf, fill=\"black\")\n\n    return img\n\n\n@pytest.mark.parametrize(\"font\", (FONT_PATH, Path(FONT_PATH)))\ndef test_font_with_name(layout_engine: ImageFont.Layout, font: str | Path) -> None:\n    _render(font, layout_engine)\n\n\ndef test_font_with_filelike(layout_engine: ImageFont.Layout) -> None:\n    def _font_as_bytes() -> BytesIO:\n        with open(FONT_PATH, \"rb\") as f:\n            font_bytes = BytesIO(f.read())\n        return font_bytes\n\n    ttf = ImageFont.truetype(_font_as_bytes(), FONT_SIZE, layout_engine=layout_engine)\n    ttf_copy = ttf.font_variant()\n    assert ttf_copy.font_bytes == ttf.font_bytes\n\n    _render(_font_as_bytes(), layout_engine)\n    # Usage note:  making two fonts from the same buffer fails.\n    # shared_bytes = _font_as_bytes()\n    # _render(shared_bytes)\n    # with pytest.raises(Exception):\n    #   _render(shared_bytes)\n\n\ndef test_font_with_open_file(layout_engine: ImageFont.Layout) -> None:\n    with open(FONT_PATH, \"rb\") as f:\n        _render(f, layout_engine)\n\n\ndef test_render_equal(layout_engine: ImageFont.Layout) -> None:\n    img_path = _render(FONT_PATH, layout_engine)\n    with open(FONT_PATH, \"rb\") as f:\n        font_filelike = BytesIO(f.read())\n    img_filelike = _render(font_filelike, layout_engine)\n\n    assert_image_equal(img_path, img_filelike)\n\n\ndef test_non_ascii_path(tmp_path: Path, layout_engine: ImageFont.Layout) -> None:\n    tempfile = str(tmp_path / (\"temp_\" + chr(128) + \".ttf\"))\n    try:\n        shutil.copy(FONT_PATH, tempfile)\n    except UnicodeEncodeError:\n        pytest.skip(\"Non-ASCII path could not be created\")\n\n    ImageFont.truetype(tempfile, FONT_SIZE, layout_engine=layout_engine)\n\n\ndef test_transparent_background(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"RGBA\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    txt = \"Hello World!\"\n    draw.text((10, 10), txt, font=font)\n\n    target = \"Tests/images/transparent_background_text.png\"\n    assert_image_similar_tofile(im, target, 4.09)\n\n    target = \"Tests/images/transparent_background_text_L.png\"\n    assert_image_similar_tofile(im.convert(\"L\"), target, 0.01)\n\n\ndef test_I16(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"I;16\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    txt = \"Hello World!\"\n    draw.text((10, 10), txt, fill=0xFFFE, font=font)\n\n    assert im.getpixel((12, 14)) == 0xFFFE\n\n    target = \"Tests/images/transparent_background_text_L.png\"\n    assert_image_similar_tofile(im.convert(\"L\"), target, 0.01)\n\n\ndef test_textbbox_equal(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    txt = \"Hello World!\"\n    bbox = draw.textbbox((10, 10), txt, font)\n    draw.text((10, 10), txt, font=font)\n    draw.rectangle(bbox)\n\n    assert_image_similar_tofile(im, \"Tests/images/rectangle_surrounding_text.png\", 2.5)\n\n\n@pytest.mark.parametrize(\n    \"text, mode, fontname, size, length_basic, length_raqm\",\n    (\n        # basic test\n        (\"text\", \"L\", \"FreeMono.ttf\", 15, 36, 36),\n        (\"text\", \"1\", \"FreeMono.ttf\", 15, 36, 36),\n        # issue 4177\n        (\"rrr\", \"L\", \"DejaVuSans/DejaVuSans.ttf\", 18, 21, 22.21875),\n        (\"rrr\", \"1\", \"DejaVuSans/DejaVuSans.ttf\", 18, 24, 22.21875),\n        # test 'l' not including extra margin\n        # using exact value 2047 / 64 for raqm, checked with debugger\n        (\"ill\", \"L\", \"OpenSansCondensed-LightItalic.ttf\", 63, 33, 31.984375),\n        (\"ill\", \"1\", \"OpenSansCondensed-LightItalic.ttf\", 63, 33, 31.984375),\n    ),\n)\ndef test_getlength(\n    text: str,\n    mode: str,\n    fontname: str,\n    size: int,\n    layout_engine: ImageFont.Layout,\n    length_basic: int,\n    length_raqm: float,\n) -> None:\n    f = ImageFont.truetype(\"Tests/fonts/\" + fontname, size, layout_engine=layout_engine)\n\n    im = Image.new(mode, (1, 1), 0)\n    d = ImageDraw.Draw(im)\n\n    if layout_engine == ImageFont.Layout.BASIC:\n        length = d.textlength(text, f)\n        assert length == length_basic\n    else:\n        # disable kerning, kerning metrics changed\n        length = d.textlength(text, f, features=[\"-kern\"])\n        assert length == length_raqm\n\n\ndef test_float_size(layout_engine: ImageFont.Layout) -> None:\n    lengths = []\n    for size in (48, 48.5, 49):\n        f = ImageFont.truetype(\n            \"Tests/fonts/NotoSans-Regular.ttf\", size, layout_engine=layout_engine\n        )\n        lengths.append(f.getlength(\"text\"))\n    assert lengths[0] != lengths[1] != lengths[2]\n\n\ndef test_render_multiline(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    line_spacing = font.getbbox(\"A\")[3] + 4\n    lines = TEST_TEXT.split(\"\\n\")\n    y: float = 0\n    for line in lines:\n        draw.text((0, y), line, font=font)\n        y += line_spacing\n\n    # some versions of freetype have different horizontal spacing.\n    # setting a tight epsilon, I'm showing the original test failure\n    # at epsilon = ~38.\n    assert_image_similar_tofile(im, \"Tests/images/multiline_text.png\", 6.2)\n\n\ndef test_render_multiline_text(font: ImageFont.FreeTypeFont) -> None:\n    # Test that text() correctly connects to multiline_text()\n    # and that align defaults to left\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), TEST_TEXT, font=font)\n\n    assert_image_similar_tofile(im, \"Tests/images/multiline_text.png\", 0.01)\n\n    # Test that text() can pass on additional arguments\n    # to multiline_text()\n    draw.text(\n        (0, 0), TEST_TEXT, fill=None, font=font, anchor=None, spacing=4, align=\"left\"\n    )\n    draw.text((0, 0), TEST_TEXT, None, font, None, 4, \"left\")\n\n\n@pytest.mark.parametrize(\n    \"align, ext\", ((\"left\", \"\"), (\"center\", \"_center\"), (\"right\", \"_right\"))\n)\ndef test_render_multiline_text_align(\n    font: ImageFont.FreeTypeFont, align: str, ext: str\n) -> None:\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.multiline_text((0, 0), TEST_TEXT, font=font, align=align)\n\n    assert_image_similar_tofile(im, f\"Tests/images/multiline_text{ext}.png\", 0.01)\n\n\ndef test_unknown_align(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    # Act/Assert\n    with pytest.raises(ValueError):\n        draw.multiline_text((0, 0), TEST_TEXT, font=font, align=\"unknown\")\n\n\ndef test_draw_align(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(\"RGB\", (300, 100), \"white\")\n    draw = ImageDraw.Draw(im)\n    line = \"some text\"\n    draw.text((100, 40), line, (0, 0, 0), font=font, align=\"left\")\n\n\ndef test_multiline_bbox(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    # Test that textbbox() correctly connects to multiline_textbbox()\n    assert draw.textbbox((0, 0), TEST_TEXT, font=font) == draw.multiline_textbbox(\n        (0, 0), TEST_TEXT, font=font\n    )\n\n    # Test that multiline_textbbox corresponds to ImageFont.textbbox()\n    # for single line text\n    assert font.getbbox(\"A\") == draw.multiline_textbbox((0, 0), \"A\", font=font)\n\n    # Test that textbbox() can pass on additional arguments\n    # to multiline_textbbox()\n    draw.textbbox((0, 0), TEST_TEXT, font=font, spacing=4)\n\n\ndef test_multiline_width(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    assert (\n        draw.textbbox((0, 0), \"longest line\", font=font)[2]\n        == draw.multiline_textbbox((0, 0), \"longest line\\nline\", font=font)[2]\n    )\n\n\ndef test_multiline_spacing(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.multiline_text((0, 0), TEST_TEXT, font=font, spacing=10)\n\n    assert_image_similar_tofile(im, \"Tests/images/multiline_text_spacing.png\", 2.5)\n\n\n@pytest.mark.parametrize(\n    \"orientation\", (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270)\n)\ndef test_rotated_transposed_font(\n    font: ImageFont.FreeTypeFont, orientation: Image.Transpose\n) -> None:\n    img_gray = Image.new(\"L\", (100, 100))\n    draw = ImageDraw.Draw(img_gray)\n    word = \"testing\"\n\n    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)\n\n    # Original font\n    draw.font = font\n    bbox_a = draw.textbbox((10, 10), word)\n\n    # Rotated font\n    draw.font = transposed_font\n    bbox_b = draw.textbbox((20, 20), word)\n\n    # Check (w, h) of box a is (h, w) of box b\n    assert (\n        bbox_a[2] - bbox_a[0],\n        bbox_a[3] - bbox_a[1],\n    ) == (\n        bbox_b[3] - bbox_b[1],\n        bbox_b[2] - bbox_b[0],\n    )\n\n    # Check top left co-ordinates are correct\n    assert bbox_b[:2] == (20, 20)\n\n    # text length is undefined for vertical text\n    with pytest.raises(ValueError):\n        draw.textlength(word)\n\n\n@pytest.mark.parametrize(\n    \"orientation\",\n    (\n        None,\n        Image.Transpose.ROTATE_180,\n        Image.Transpose.FLIP_LEFT_RIGHT,\n        Image.Transpose.FLIP_TOP_BOTTOM,\n    ),\n)\ndef test_unrotated_transposed_font(\n    font: ImageFont.FreeTypeFont, orientation: Image.Transpose\n) -> None:\n    img_gray = Image.new(\"L\", (100, 100))\n    draw = ImageDraw.Draw(img_gray)\n    word = \"testing\"\n\n    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)\n\n    # Original font\n    draw.font = font\n    bbox_a = draw.textbbox((10, 10), word)\n    length_a = draw.textlength(word)\n\n    # Rotated font\n    draw.font = transposed_font\n    bbox_b = draw.textbbox((20, 20), word)\n    length_b = draw.textlength(word)\n\n    # Check boxes a and b are same size\n    assert (\n        bbox_a[2] - bbox_a[0],\n        bbox_a[3] - bbox_a[1],\n    ) == (\n        bbox_b[2] - bbox_b[0],\n        bbox_b[3] - bbox_b[1],\n    )\n\n    # Check top left co-ordinates are correct\n    assert bbox_b[:2] == (20, 20)\n\n    assert length_a == length_b\n\n\n@pytest.mark.parametrize(\n    \"orientation\", (Image.Transpose.ROTATE_90, Image.Transpose.ROTATE_270)\n)\ndef test_rotated_transposed_font_get_mask(\n    font: ImageFont.FreeTypeFont, orientation: Image.Transpose\n) -> None:\n    # Arrange\n    text = \"mask this\"\n    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)\n\n    # Act\n    mask = transposed_font.getmask(text)\n\n    # Assert\n    assert mask.size == (13, 108)\n\n\n@pytest.mark.parametrize(\n    \"orientation\",\n    (\n        None,\n        Image.Transpose.ROTATE_180,\n        Image.Transpose.FLIP_LEFT_RIGHT,\n        Image.Transpose.FLIP_TOP_BOTTOM,\n    ),\n)\ndef test_unrotated_transposed_font_get_mask(\n    font: ImageFont.FreeTypeFont, orientation: Image.Transpose\n) -> None:\n    # Arrange\n    text = \"mask this\"\n    transposed_font = ImageFont.TransposedFont(font, orientation=orientation)\n\n    # Act\n    mask = transposed_font.getmask(text)\n\n    # Assert\n    assert mask.size == (108, 13)\n\n\ndef test_free_type_font_get_name(font: ImageFont.FreeTypeFont) -> None:\n    assert (\"FreeMono\", \"Regular\") == font.getname()\n\n\ndef test_free_type_font_get_metrics(font: ImageFont.FreeTypeFont) -> None:\n    ascent, descent = font.getmetrics()\n\n    assert isinstance(ascent, int)\n    assert isinstance(descent, int)\n    assert (ascent, descent) == (16, 4)\n\n\ndef test_free_type_font_get_mask(font: ImageFont.FreeTypeFont) -> None:\n    # Arrange\n    text = \"mask this\"\n\n    # Act\n    mask = font.getmask(text)\n\n    # Assert\n    assert mask.size == (108, 13)\n\n\ndef test_load_path_not_found() -> None:\n    # Arrange\n    filename = \"somefilenamethatdoesntexist.ttf\"\n\n    # Act/Assert\n    with pytest.raises(OSError):\n        ImageFont.load_path(filename)\n    with pytest.raises(OSError):\n        ImageFont.truetype(filename)\n\n\ndef test_load_non_font_bytes() -> None:\n    with open(\"Tests/images/hopper.jpg\", \"rb\") as f:\n        with pytest.raises(OSError):\n            ImageFont.truetype(f)\n\n\ndef test_default_font() -> None:\n    # Arrange\n    txt = \"This is a default font using FreeType support.\"\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    default_font = ImageFont.load_default()\n    draw.text((10, 10), txt, font=default_font)\n\n    larger_default_font = ImageFont.load_default(size=14)\n    draw.text((10, 60), txt, font=larger_default_font)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/default_font_freetype.png\")\n\n\n@pytest.mark.parametrize(\"mode\", (\"\", \"1\", \"RGBA\"))\ndef test_getbbox(font: ImageFont.FreeTypeFont, mode: str) -> None:\n    assert (0, 4, 12, 16) == font.getbbox(\"A\", mode)\n\n\ndef test_getbbox_empty(font: ImageFont.FreeTypeFont) -> None:\n    # issue #2614, should not crash.\n    assert (0, 0, 0, 0) == font.getbbox(\"\")\n\n\ndef test_render_empty(font: ImageFont.FreeTypeFont) -> None:\n    # issue 2666\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    target = im.copy()\n    draw = ImageDraw.Draw(im)\n    # should not crash here.\n    draw.text((10, 10), \"\", font=font)\n    assert_image_equal(im, target)\n\n\ndef test_unicode_extended(layout_engine: ImageFont.Layout) -> None:\n    # issue #3777\n    text = \"A\\u278A\\U0001F12B\"\n    target = \"Tests/images/unicode_extended.png\"\n\n    ttf = ImageFont.truetype(\n        \"Tests/fonts/NotoSansSymbols-Regular.ttf\",\n        FONT_SIZE,\n        layout_engine=layout_engine,\n    )\n    img = Image.new(\"RGB\", (100, 60))\n    d = ImageDraw.Draw(img)\n    d.text((10, 10), text, font=ttf)\n\n    # fails with 14.7\n    assert_image_similar_tofile(img, target, 6.2)\n\n\n@pytest.mark.parametrize(\n    \"platform, font_directory\",\n    ((\"linux\", \"/usr/local/share/fonts\"), (\"darwin\", \"/System/Library/Fonts\")),\n)\n@pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\")\ndef test_find_font(\n    monkeypatch: pytest.MonkeyPatch, platform: str, font_directory: str\n) -> None:\n    def _test_fake_loading_font(path_to_fake: str, fontname: str) -> None:\n        # Make a copy of FreeTypeFont so we can patch the original\n        free_type_font = copy.deepcopy(ImageFont.FreeTypeFont)\n        with monkeypatch.context() as m:\n            m.setattr(ImageFont, \"_FreeTypeFont\", free_type_font, raising=False)\n\n            def loadable_font(\n                filepath: str, size: int, index: int, encoding: str, *args: Any\n            ) -> ImageFont.FreeTypeFont:\n                _freeTypeFont = getattr(ImageFont, \"_FreeTypeFont\")\n                if filepath == path_to_fake:\n                    return _freeTypeFont(FONT_PATH, size, index, encoding, *args)\n                return _freeTypeFont(filepath, size, index, encoding, *args)\n\n            m.setattr(ImageFont, \"FreeTypeFont\", loadable_font)\n            font = ImageFont.truetype(fontname)\n            # Make sure it's loaded\n            name = font.getname()\n            assert (\"FreeMono\", \"Regular\") == name\n\n    # A lot of mocking here - this is more for hitting code and\n    # catching syntax like errors\n    monkeypatch.setattr(sys, \"platform\", platform)\n    if platform == \"linux\":\n        monkeypatch.setenv(\"XDG_DATA_HOME\", os.path.expanduser(\"~/.local/share\"))\n        monkeypatch.setenv(\"XDG_DATA_DIRS\", \"/usr/share/:/usr/local/share/\")\n\n    def fake_walker(path: str) -> list[tuple[str, list[str], list[str]]]:\n        if path == font_directory:\n            return [\n                (\n                    path,\n                    [],\n                    [\"Arial.ttf\", \"Single.otf\", \"Duplicate.otf\", \"Duplicate.ttf\"],\n                )\n            ]\n        return [(path, [], [\"some_random_font.ttf\"])]\n\n    monkeypatch.setattr(os, \"walk\", fake_walker)\n\n    # Test that the font loads both with and without the extension\n    _test_fake_loading_font(font_directory + \"/Arial.ttf\", \"Arial.ttf\")\n    _test_fake_loading_font(font_directory + \"/Arial.ttf\", \"Arial\")\n\n    # Test that non-ttf fonts can be found without the extension\n    _test_fake_loading_font(font_directory + \"/Single.otf\", \"Single\")\n\n    # Test that ttf fonts are preferred if the extension is not specified\n    _test_fake_loading_font(font_directory + \"/Duplicate.ttf\", \"Duplicate\")\n\n\ndef test_imagefont_getters(font: ImageFont.FreeTypeFont) -> None:\n    assert font.getmetrics() == (16, 4)\n    assert font.font.ascent == 16\n    assert font.font.descent == 4\n    assert font.font.height == 20\n    assert font.font.x_ppem == 20\n    assert font.font.y_ppem == 20\n    assert font.font.glyphs == 4177\n    assert font.getbbox(\"A\") == (0, 4, 12, 16)\n    assert font.getbbox(\"AB\") == (0, 4, 24, 16)\n    assert font.getbbox(\"M\") == (0, 4, 12, 16)\n    assert font.getbbox(\"y\") == (0, 7, 12, 20)\n    assert font.getbbox(\"a\") == (0, 7, 12, 16)\n    assert font.getlength(\"A\") == 12\n    assert font.getlength(\"AB\") == 24\n    assert font.getlength(\"M\") == 12\n    assert font.getlength(\"y\") == 12\n    assert font.getlength(\"a\") == 12\n\n\n@pytest.mark.parametrize(\"stroke_width\", (0, 2))\ndef test_getsize_stroke(font: ImageFont.FreeTypeFont, stroke_width: int) -> None:\n    assert font.getbbox(\"A\", stroke_width=stroke_width) == (\n        0 - stroke_width,\n        4 - stroke_width,\n        12 + stroke_width,\n        16 + stroke_width,\n    )\n\n\ndef test_complex_font_settings() -> None:\n    t = ImageFont.truetype(FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.BASIC)\n    with pytest.raises(KeyError):\n        t.getmask(\"\u0430\u0431\u0432\u0433\", direction=\"rtl\")\n    with pytest.raises(KeyError):\n        t.getmask(\"\u0430\u0431\u0432\u0433\", features=[\"-kern\"])\n    with pytest.raises(KeyError):\n        t.getmask(\"\u0430\u0431\u0432\u0433\", language=\"sr\")\n\n\ndef test_variation_get(font: ImageFont.FreeTypeFont) -> None:\n    version = features.version_module(\"freetype2\")\n    assert version is not None\n    freetype = parse_version(version)\n    if freetype < parse_version(\"2.9.1\"):\n        with pytest.raises(NotImplementedError):\n            font.get_variation_names()\n        with pytest.raises(NotImplementedError):\n            font.get_variation_axes()\n        return\n\n    with pytest.raises(OSError):\n        font.get_variation_names()\n    with pytest.raises(OSError):\n        font.get_variation_axes()\n\n    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\")\n    assert font.get_variation_names(), [\n        b\"ExtraLight\",\n        b\"Light\",\n        b\"Regular\",\n        b\"Semibold\",\n        b\"Bold\",\n        b\"Black\",\n        b\"Black Medium Contrast\",\n        b\"Black High Contrast\",\n        b\"Default\",\n    ]\n    assert font.get_variation_axes() == [\n        {\"name\": b\"Weight\", \"minimum\": 200, \"maximum\": 900, \"default\": 389},\n        {\"name\": b\"Contrast\", \"minimum\": 0, \"maximum\": 100, \"default\": 0},\n    ]\n\n    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\")\n    assert font.get_variation_names() == [\n        b\"20\",\n        b\"40\",\n        b\"60\",\n        b\"80\",\n        b\"100\",\n        b\"120\",\n        b\"140\",\n        b\"160\",\n        b\"180\",\n        b\"200\",\n        b\"220\",\n        b\"240\",\n        b\"260\",\n        b\"280\",\n        b\"300\",\n        b\"Regular\",\n    ]\n    assert font.get_variation_axes() == [\n        {\"name\": b\"Size\", \"minimum\": 0, \"maximum\": 300, \"default\": 0}\n    ]\n\n\ndef _check_text(font: ImageFont.FreeTypeFont, path: str, epsilon: float) -> None:\n    im = Image.new(\"RGB\", (100, 75), \"white\")\n    d = ImageDraw.Draw(im)\n    d.text((10, 10), \"Text\", font=font, fill=\"black\")\n\n    try:\n        assert_image_similar_tofile(im, path, epsilon)\n    except AssertionError:\n        if \"_adobe\" in path:\n            path = path.replace(\"_adobe\", \"_adobe_older_harfbuzz\")\n            assert_image_similar_tofile(im, path, epsilon)\n        else:\n            raise\n\n\ndef test_variation_set_by_name(font: ImageFont.FreeTypeFont) -> None:\n    version = features.version_module(\"freetype2\")\n    assert version is not None\n    freetype = parse_version(version)\n    if freetype < parse_version(\"2.9.1\"):\n        with pytest.raises(NotImplementedError):\n            font.set_variation_by_name(\"Bold\")\n        return\n\n    with pytest.raises(OSError):\n        font.set_variation_by_name(\"Bold\")\n\n    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\", 36)\n    _check_text(font, \"Tests/images/variation_adobe.png\", 11)\n    for name in [\"Bold\", b\"Bold\"]:\n        font.set_variation_by_name(name)\n        assert font.getname()[1] == \"Bold\"\n    _check_text(font, \"Tests/images/variation_adobe_name.png\", 16)\n\n    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\", 36)\n    _check_text(font, \"Tests/images/variation_tiny.png\", 40)\n    for name in [\"200\", b\"200\"]:\n        font.set_variation_by_name(name)\n        assert font.getname()[1] == \"200\"\n    _check_text(font, \"Tests/images/variation_tiny_name.png\", 40)\n\n\ndef test_variation_set_by_axes(font: ImageFont.FreeTypeFont) -> None:\n    version = features.version_module(\"freetype2\")\n    assert version is not None\n    freetype = parse_version(version)\n    if freetype < parse_version(\"2.9.1\"):\n        with pytest.raises(NotImplementedError):\n            font.set_variation_by_axes([100])\n        return\n\n    with pytest.raises(OSError):\n        font.set_variation_by_axes([500, 50])\n\n    font = ImageFont.truetype(\"Tests/fonts/AdobeVFPrototype.ttf\", 36)\n    font.set_variation_by_axes([500, 50])\n    _check_text(font, \"Tests/images/variation_adobe_axes.png\", 11.05)\n\n    font = ImageFont.truetype(\"Tests/fonts/TINY5x3GX.ttf\", 36)\n    font.set_variation_by_axes([100])\n    _check_text(font, \"Tests/images/variation_tiny_axes.png\", 32.5)\n\n\n@pytest.mark.parametrize(\n    \"anchor, left, top\",\n    (\n        # test horizontal anchors\n        (\"ls\", 0, -36),\n        (\"ms\", -64, -36),\n        (\"rs\", -128, -36),\n        # test vertical anchors\n        (\"ma\", -64, 16),\n        (\"mt\", -64, 0),\n        (\"mm\", -64, -17),\n        (\"mb\", -64, -44),\n        (\"md\", -64, -51),\n    ),\n    ids=(\"ls\", \"ms\", \"rs\", \"ma\", \"mt\", \"mm\", \"mb\", \"md\"),\n)\ndef test_anchor(\n    layout_engine: ImageFont.Layout, anchor: str, left: int, top: int\n) -> None:\n    name, text = \"quick\", \"Quick\"\n    path = f\"Tests/images/test_anchor_{name}_{anchor}.png\"\n\n    if layout_engine == ImageFont.Layout.RAQM:\n        width, height = (129, 44)\n    else:\n        width, height = (128, 44)\n\n    bbox_expected = (left, top, left + width, top + height)\n\n    f = ImageFont.truetype(\n        \"Tests/fonts/NotoSans-Regular.ttf\", 48, layout_engine=layout_engine\n    )\n\n    im = Image.new(\"RGB\", (200, 200), \"white\")\n    d = ImageDraw.Draw(im)\n    d.line(((0, 100), (200, 100)), \"gray\")\n    d.line(((100, 0), (100, 200)), \"gray\")\n    d.text((100, 100), text, fill=\"black\", anchor=anchor, font=f)\n\n    assert d.textbbox((0, 0), text, f, anchor=anchor) == bbox_expected\n\n    assert_image_similar_tofile(im, path, 7)\n\n\n@pytest.mark.parametrize(\n    \"anchor, align\",\n    (\n        # test horizontal anchors\n        (\"lm\", \"left\"),\n        (\"lm\", \"center\"),\n        (\"lm\", \"right\"),\n        (\"mm\", \"left\"),\n        (\"mm\", \"center\"),\n        (\"mm\", \"right\"),\n        (\"rm\", \"left\"),\n        (\"rm\", \"center\"),\n        (\"rm\", \"right\"),\n        # test vertical anchors\n        (\"ma\", \"center\"),\n        # (\"mm\", \"center\"),  # duplicate\n        (\"md\", \"center\"),\n    ),\n)\ndef test_anchor_multiline(\n    layout_engine: ImageFont.Layout, anchor: str, align: str\n) -> None:\n    target = f\"Tests/images/test_anchor_multiline_{anchor}_{align}.png\"\n    text = \"a\\nlong\\ntext sample\"\n\n    f = ImageFont.truetype(\n        \"Tests/fonts/NotoSans-Regular.ttf\", 48, layout_engine=layout_engine\n    )\n\n    # test render\n    im = Image.new(\"RGB\", (600, 400), \"white\")\n    d = ImageDraw.Draw(im)\n    d.line(((0, 200), (600, 200)), \"gray\")\n    d.line(((300, 0), (300, 400)), \"gray\")\n    d.multiline_text((300, 200), text, fill=\"black\", anchor=anchor, font=f, align=align)\n\n    assert_image_similar_tofile(im, target, 4)\n\n\ndef test_anchor_invalid(font: ImageFont.FreeTypeFont) -> None:\n    im = Image.new(\"RGB\", (100, 100), \"white\")\n    d = ImageDraw.Draw(im)\n    d.font = font\n\n    for anchor in [\"\", \"l\", \"a\", \"lax\", \"sa\", \"xa\", \"lx\"]:\n        with pytest.raises(ValueError):\n            font.getmask2(\"hello\", anchor=anchor)\n        with pytest.raises(ValueError):\n            font.getbbox(\"hello\", anchor=anchor)\n        with pytest.raises(ValueError):\n            d.text((0, 0), \"hello\", anchor=anchor)\n        with pytest.raises(ValueError):\n            d.textbbox((0, 0), \"hello\", anchor=anchor)\n        with pytest.raises(ValueError):\n            d.multiline_text((0, 0), \"foo\\nbar\", anchor=anchor)\n        with pytest.raises(ValueError):\n            d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=anchor)\n    for anchor in [\"lt\", \"lb\"]:\n        with pytest.raises(ValueError):\n            d.multiline_text((0, 0), \"foo\\nbar\", anchor=anchor)\n        with pytest.raises(ValueError):\n            d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=anchor)\n\n\n@pytest.mark.parametrize(\"bpp\", (1, 2, 4, 8))\ndef test_bitmap_font(layout_engine: ImageFont.Layout, bpp: int) -> None:\n    text = \"Bitmap Font\"\n    layout_name = [\"basic\", \"raqm\"][layout_engine]\n    target = f\"Tests/images/bitmap_font_{bpp}_{layout_name}.png\"\n    font = ImageFont.truetype(\n        f\"Tests/fonts/DejaVuSans/DejaVuSans-24-{bpp}-stripped.ttf\",\n        24,\n        layout_engine=layout_engine,\n    )\n\n    im = Image.new(\"RGB\", (160, 35), \"white\")\n    draw = ImageDraw.Draw(im)\n    draw.text((2, 2), text, \"black\", font)\n\n    assert_image_equal_tofile(im, target)\n\n\ndef test_bitmap_font_stroke(layout_engine: ImageFont.Layout) -> None:\n    text = \"Bitmap Font\"\n    layout_name = [\"basic\", \"raqm\"][layout_engine]\n    target = f\"Tests/images/bitmap_font_stroke_{layout_name}.png\"\n    font = ImageFont.truetype(\n        \"Tests/fonts/DejaVuSans/DejaVuSans-24-8-stripped.ttf\",\n        24,\n        layout_engine=layout_engine,\n    )\n\n    im = Image.new(\"RGB\", (160, 35), \"white\")\n    draw = ImageDraw.Draw(im)\n    draw.text((2, 2), text, \"black\", font, stroke_width=2, stroke_fill=\"red\")\n\n    assert_image_similar_tofile(im, target, 0.03)\n\n\n@pytest.mark.parametrize(\"embedded_color\", (False, True))\ndef test_bitmap_blend(layout_engine: ImageFont.Layout, embedded_color: bool) -> None:\n    font = ImageFont.truetype(\n        \"Tests/fonts/EBDTTestFont.ttf\", size=64, layout_engine=layout_engine\n    )\n\n    im = Image.new(\"RGBA\", (128, 96), \"white\")\n    d = ImageDraw.Draw(im)\n    d.text((16, 16), \"AA\", font=font, fill=\"#8E2F52\", embedded_color=embedded_color)\n\n    assert_image_equal_tofile(im, \"Tests/images/bitmap_font_blend.png\")\n\n\ndef test_standard_embedded_color(layout_engine: ImageFont.Layout) -> None:\n    txt = \"Hello World!\"\n    ttf = ImageFont.truetype(FONT_PATH, 40, layout_engine=layout_engine)\n    ttf.getbbox(txt)\n\n    im = Image.new(\"RGB\", (300, 64), \"white\")\n    d = ImageDraw.Draw(im)\n    d.text((10, 10), txt, font=ttf, fill=\"#fa6\", embedded_color=True)\n\n    assert_image_similar_tofile(im, \"Tests/images/standard_embedded.png\", 3.1)\n\n\n@pytest.mark.parametrize(\"fontmode\", (\"1\", \"L\", \"RGBA\"))\ndef test_float_coord(layout_engine: ImageFont.Layout, fontmode: str) -> None:\n    txt = \"Hello World!\"\n    ttf = ImageFont.truetype(FONT_PATH, 40, layout_engine=layout_engine)\n\n    im = Image.new(\"RGB\", (300, 64), \"white\")\n    d = ImageDraw.Draw(im)\n    if fontmode == \"1\":\n        d.fontmode = \"1\"\n\n    embedded_color = fontmode == \"RGBA\"\n    d.text((9.5, 9.5), txt, font=ttf, fill=\"#fa6\", embedded_color=embedded_color)\n    try:\n        assert_image_similar_tofile(im, \"Tests/images/text_float_coord.png\", 3.9)\n    except AssertionError:\n        if fontmode == \"1\" and layout_engine == ImageFont.Layout.BASIC:\n            assert_image_similar_tofile(\n                im, \"Tests/images/text_float_coord_1_alt.png\", 1\n            )\n        else:\n            raise\n\n\ndef test_cbdt(layout_engine: ImageFont.Layout) -> None:\n    try:\n        font = ImageFont.truetype(\n            \"Tests/fonts/CBDTTestFont.ttf\", size=64, layout_engine=layout_engine\n        )\n\n        im = Image.new(\"RGB\", (128, 96), \"white\")\n        d = ImageDraw.Draw(im)\n\n        d.text((16, 16), \"AB\", font=font, embedded_color=True)\n\n        assert_image_equal_tofile(im, \"Tests/images/cbdt.png\")\n    except OSError as e:  # pragma: no cover\n        assert str(e) in (\"unimplemented feature\", \"unknown file format\")\n        pytest.skip(\"freetype compiled without libpng or CBDT support\")\n\n\ndef test_cbdt_mask(layout_engine: ImageFont.Layout) -> None:\n    try:\n        font = ImageFont.truetype(\n            \"Tests/fonts/CBDTTestFont.ttf\", size=64, layout_engine=layout_engine\n        )\n\n        im = Image.new(\"RGB\", (128, 96), \"white\")\n        d = ImageDraw.Draw(im)\n\n        d.text((16, 16), \"AB\", \"green\", font=font)\n\n        assert_image_equal_tofile(im, \"Tests/images/cbdt_mask.png\")\n    except OSError as e:  # pragma: no cover\n        assert str(e) in (\"unimplemented feature\", \"unknown file format\")\n        pytest.skip(\"freetype compiled without libpng or CBDT support\")\n\n\ndef test_sbix(layout_engine: ImageFont.Layout) -> None:\n    try:\n        font = ImageFont.truetype(\n            \"Tests/fonts/chromacheck-sbix.woff\", size=300, layout_engine=layout_engine\n        )\n\n        im = Image.new(\"RGB\", (400, 400), \"white\")\n        d = ImageDraw.Draw(im)\n\n        d.text((50, 50), \"\\uE901\", font=font, embedded_color=True)\n\n        assert_image_similar_tofile(im, \"Tests/images/chromacheck-sbix.png\", 1)\n    except OSError as e:  # pragma: no cover\n        assert str(e) in (\"unimplemented feature\", \"unknown file format\")\n        pytest.skip(\"freetype compiled without libpng or SBIX support\")\n\n\ndef test_sbix_mask(layout_engine: ImageFont.Layout) -> None:\n    try:\n        font = ImageFont.truetype(\n            \"Tests/fonts/chromacheck-sbix.woff\", size=300, layout_engine=layout_engine\n        )\n\n        im = Image.new(\"RGB\", (400, 400), \"white\")\n        d = ImageDraw.Draw(im)\n\n        d.text((50, 50), \"\\uE901\", (100, 0, 0), font=font)\n\n        assert_image_similar_tofile(im, \"Tests/images/chromacheck-sbix_mask.png\", 1)\n    except OSError as e:  # pragma: no cover\n        assert str(e) in (\"unimplemented feature\", \"unknown file format\")\n        pytest.skip(\"freetype compiled without libpng or SBIX support\")\n\n\n@skip_unless_feature_version(\"freetype2\", \"2.10.0\")\ndef test_colr(layout_engine: ImageFont.Layout) -> None:\n    font = ImageFont.truetype(\n        \"Tests/fonts/BungeeColor-Regular_colr_Windows.ttf\",\n        size=64,\n        layout_engine=layout_engine,\n    )\n\n    im = Image.new(\"RGB\", (300, 75), \"white\")\n    d = ImageDraw.Draw(im)\n\n    d.text((15, 5), \"Bungee\", font=font, embedded_color=True)\n\n    assert_image_similar_tofile(im, \"Tests/images/colr_bungee.png\", 21)\n\n\n@skip_unless_feature_version(\"freetype2\", \"2.10.0\")\ndef test_colr_mask(layout_engine: ImageFont.Layout) -> None:\n    font = ImageFont.truetype(\n        \"Tests/fonts/BungeeColor-Regular_colr_Windows.ttf\",\n        size=64,\n        layout_engine=layout_engine,\n    )\n\n    im = Image.new(\"RGB\", (300, 75), \"white\")\n    d = ImageDraw.Draw(im)\n\n    d.text((15, 5), \"Bungee\", \"black\", font=font)\n\n    assert_image_similar_tofile(im, \"Tests/images/colr_bungee_mask.png\", 22)\n\n\ndef test_woff2(layout_engine: ImageFont.Layout) -> None:\n    try:\n        font = ImageFont.truetype(\n            \"Tests/fonts/OpenSans.woff2\",\n            size=64,\n            layout_engine=layout_engine,\n        )\n    except OSError as e:\n        assert str(e) in (\"unimplemented feature\", \"unknown file format\")\n        pytest.skip(\"FreeType compiled without brotli or WOFF2 support\")\n\n    im = Image.new(\"RGB\", (350, 100), \"white\")\n    d = ImageDraw.Draw(im)\n\n    d.text((15, 5), \"OpenSans\", \"black\", font=font)\n\n    assert_image_similar_tofile(im, \"Tests/images/test_woff2.png\", 5)\n\n\ndef test_render_mono_size() -> None:\n    # issue 4177\n\n    im = Image.new(\"P\", (100, 30), \"white\")\n    draw = ImageDraw.Draw(im)\n    ttf = ImageFont.truetype(\n        \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\",\n        18,\n        layout_engine=ImageFont.Layout.BASIC,\n    )\n\n    draw.text((10, 10), \"r\" * 10, \"black\", ttf)\n    assert_image_equal_tofile(im, \"Tests/images/text_mono.gif\")\n\n\ndef test_too_many_characters(font: ImageFont.FreeTypeFont) -> None:\n    with pytest.raises(ValueError):\n        font.getlength(\"A\" * 1_000_001)\n    with pytest.raises(ValueError):\n        font.getbbox(\"A\" * 1_000_001)\n    with pytest.raises(ValueError):\n        font.getmask2(\"A\" * 1_000_001)\n\n    transposed_font = ImageFont.TransposedFont(font)\n    with pytest.raises(ValueError):\n        transposed_font.getlength(\"A\" * 1_000_001)\n\n    imagefont = ImageFont.ImageFont()\n    with pytest.raises(ValueError):\n        imagefont.getlength(\"A\" * 1_000_001)\n    with pytest.raises(ValueError):\n        imagefont.getbbox(\"A\" * 1_000_001)\n    with pytest.raises(ValueError):\n        imagefont.getmask(\"A\" * 1_000_001)\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\n        \"Tests/fonts/oom-e8e927ba6c0d38274a37c1567560eb33baf74627.ttf\",\n        \"Tests/fonts/oom-4da0210eb7081b0bf15bf16cc4c52ce02c1e1bbc.ttf\",\n    ],\n)\ndef test_oom(test_file: str) -> None:\n    with open(test_file, \"rb\") as f:\n        font = ImageFont.truetype(BytesIO(f.read()))\n        with pytest.raises(Image.DecompressionBombError):\n            font.getmask(\"Test Text\")\n\n\ndef test_raqm_missing_warning(monkeypatch: pytest.MonkeyPatch) -> None:\n    monkeypatch.setattr(ImageFont.core, \"HAVE_RAQM\", False)\n    with pytest.warns(UserWarning) as record:\n        font = ImageFont.truetype(\n            FONT_PATH, FONT_SIZE, layout_engine=ImageFont.Layout.RAQM\n        )\n    assert font.layout_engine == ImageFont.Layout.BASIC\n    assert str(record[-1].message) == (\n        \"Raqm layout was requested, but Raqm is not available. \"\n        \"Falling back to basic layout.\"\n    )\n\n\n@pytest.mark.parametrize(\"size\", [-1, 0])\ndef test_invalid_truetype_sizes_raise_valueerror(\n    layout_engine: ImageFont.Layout, size: int\n) -> None:\n    with pytest.raises(ValueError):\n        ImageFont.truetype(FONT_PATH, size, layout_engine=layout_engine)\n", "Tests/test_image_histogram.py": "from __future__ import annotations\n\nfrom .helper import hopper\n\n\ndef test_histogram() -> None:\n    def histogram(mode: str) -> tuple[int, int, int]:\n        h = hopper(mode).histogram()\n        return len(h), min(h), max(h)\n\n    assert histogram(\"1\") == (256, 0, 10994)\n    assert histogram(\"L\") == (256, 0, 662)\n    assert histogram(\"I\") == (256, 0, 662)\n    assert histogram(\"F\") == (256, 0, 662)\n    assert histogram(\"P\") == (256, 0, 1551)\n    assert histogram(\"RGB\") == (768, 4, 675)\n    assert histogram(\"RGBA\") == (1024, 0, 16384)\n    assert histogram(\"CMYK\") == (1024, 0, 16384)\n    assert histogram(\"YCbCr\") == (768, 0, 1908)\n", "Tests/test_file_bmp.py": "from __future__ import annotations\n\nimport io\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import BmpImagePlugin, Image, _binary\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar_tofile,\n    hopper,\n)\n\n\ndef test_sanity(tmp_path: Path) -> None:\n    def roundtrip(im: Image.Image) -> None:\n        outfile = str(tmp_path / \"temp.bmp\")\n\n        im.save(outfile, \"BMP\")\n\n        with Image.open(outfile) as reloaded:\n            reloaded.load()\n            assert im.mode == reloaded.mode\n            assert im.size == reloaded.size\n            assert reloaded.format == \"BMP\"\n            assert reloaded.get_format_mimetype() == \"image/bmp\"\n\n    roundtrip(hopper())\n\n    roundtrip(hopper(\"1\"))\n    roundtrip(hopper(\"L\"))\n    roundtrip(hopper(\"P\"))\n    roundtrip(hopper(\"RGB\"))\n\n\ndef test_invalid_file() -> None:\n    with open(\"Tests/images/flower.jpg\", \"rb\") as fp:\n        with pytest.raises(SyntaxError):\n            BmpImagePlugin.BmpImageFile(fp)\n\n\ndef test_fallback_if_mmap_errors() -> None:\n    # This image has been truncated,\n    # so that the buffer is not large enough when using mmap\n    with Image.open(\"Tests/images/mmap_error.bmp\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/pal8_offset.bmp\")\n\n\ndef test_save_to_bytes() -> None:\n    output = io.BytesIO()\n    im = hopper()\n    im.save(output, \"BMP\")\n\n    output.seek(0)\n    with Image.open(output) as reloaded:\n        assert im.mode == reloaded.mode\n        assert im.size == reloaded.size\n        assert reloaded.format == \"BMP\"\n\n\ndef test_small_palette(tmp_path: Path) -> None:\n    im = Image.new(\"P\", (1, 1))\n    colors = [0, 0, 0, 125, 125, 125, 255, 255, 255]\n    im.putpalette(colors)\n\n    out = str(tmp_path / \"temp.bmp\")\n    im.save(out)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.getpalette() == colors\n\n\ndef test_save_too_large(tmp_path: Path) -> None:\n    outfile = str(tmp_path / \"temp.bmp\")\n    with Image.new(\"RGB\", (1, 1)) as im:\n        im._size = (37838, 37838)\n        with pytest.raises(ValueError):\n            im.save(outfile)\n\n\ndef test_dpi() -> None:\n    dpi = (72, 72)\n\n    output = io.BytesIO()\n    with hopper() as im:\n        im.save(output, \"BMP\", dpi=dpi)\n\n    output.seek(0)\n    with Image.open(output) as reloaded:\n        assert reloaded.info[\"dpi\"] == (72.008961115161, 72.008961115161)\n\n\ndef test_save_bmp_with_dpi(tmp_path: Path) -> None:\n    # Test for #1301\n    # Arrange\n    outfile = str(tmp_path / \"temp.jpg\")\n    with Image.open(\"Tests/images/hopper.bmp\") as im:\n        assert im.info[\"dpi\"] == (95.98654816726399, 95.98654816726399)\n\n        # Act\n        im.save(outfile, \"JPEG\", dpi=im.info[\"dpi\"])\n\n        # Assert\n        with Image.open(outfile) as reloaded:\n            reloaded.load()\n            assert reloaded.info[\"dpi\"] == (96, 96)\n            assert reloaded.size == im.size\n            assert reloaded.format == \"JPEG\"\n\n\ndef test_save_float_dpi(tmp_path: Path) -> None:\n    outfile = str(tmp_path / \"temp.bmp\")\n    with Image.open(\"Tests/images/hopper.bmp\") as im:\n        im.save(outfile, dpi=(72.21216100543306, 72.21216100543306))\n        with Image.open(outfile) as reloaded:\n            assert reloaded.info[\"dpi\"] == (72.21216100543306, 72.21216100543306)\n\n\ndef test_load_dib() -> None:\n    # test for #1293, Imagegrab returning Unsupported Bitfields Format\n    with Image.open(\"Tests/images/clipboard.dib\") as im:\n        assert im.format == \"DIB\"\n        assert im.get_format_mimetype() == \"image/bmp\"\n\n        assert_image_equal_tofile(im, \"Tests/images/clipboard_target.png\")\n\n\n@pytest.mark.parametrize(\n    \"header_size, path\",\n    (\n        (12, \"g/pal8os2.bmp\"),\n        (40, \"g/pal1.bmp\"),\n        (52, \"q/rgb32h52.bmp\"),\n        (56, \"q/rgba32h56.bmp\"),\n        (64, \"q/pal8os2v2.bmp\"),\n        (108, \"g/pal8v4.bmp\"),\n        (124, \"g/pal8v5.bmp\"),\n    ),\n)\ndef test_dib_header_size(header_size: int, path: str) -> None:\n    image_path = \"Tests/images/bmp/\" + path\n    with open(image_path, \"rb\") as fp:\n        data = fp.read()[14:]\n    assert _binary.i32le(data) == header_size\n\n    dib = io.BytesIO(data)\n    with Image.open(dib) as im:\n        im.load()\n\n\ndef test_save_dib(tmp_path: Path) -> None:\n    outfile = str(tmp_path / \"temp.dib\")\n\n    with Image.open(\"Tests/images/clipboard.dib\") as im:\n        im.save(outfile)\n\n        with Image.open(outfile) as reloaded:\n            assert reloaded.format == \"DIB\"\n            assert reloaded.get_format_mimetype() == \"image/bmp\"\n            assert_image_equal(im, reloaded)\n\n\ndef test_rgba_bitfields() -> None:\n    # This test image has been manually hexedited\n    # to change the bitfield compression in the header from XBGR to RGBA\n    with Image.open(\"Tests/images/rgb32bf-rgba.bmp\") as im:\n        # So before the comparing the image, swap the channels\n        b, g, r = im.split()[1:]\n        im = Image.merge(\"RGB\", (r, g, b))\n\n    assert_image_equal_tofile(im, \"Tests/images/bmp/q/rgb32bf-xbgr.bmp\")\n\n    # This test image has been manually hexedited\n    # to change the bitfield compression in the header from XBGR to ABGR\n    with Image.open(\"Tests/images/rgb32bf-abgr.bmp\") as im:\n        assert_image_equal_tofile(\n            im.convert(\"RGB\"), \"Tests/images/bmp/q/rgb32bf-xbgr.bmp\"\n        )\n\n\ndef test_rle8() -> None:\n    with Image.open(\"Tests/images/hopper_rle8.bmp\") as im:\n        assert_image_similar_tofile(im.convert(\"RGB\"), \"Tests/images/hopper.bmp\", 12)\n\n    with Image.open(\"Tests/images/hopper_rle8_grayscale.bmp\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/bw_gradient.png\")\n\n    # This test image has been manually hexedited\n    # to have rows with too much data\n    with Image.open(\"Tests/images/hopper_rle8_row_overflow.bmp\") as im:\n        assert_image_similar_tofile(im.convert(\"RGB\"), \"Tests/images/hopper.bmp\", 12)\n\n    # Signal end of bitmap before the image is finished\n    with open(\"Tests/images/bmp/g/pal8rle.bmp\", \"rb\") as fp:\n        data = fp.read(1063) + b\"\\x01\"\n        with Image.open(io.BytesIO(data)) as im:\n            with pytest.raises(ValueError):\n                im.load()\n\n\ndef test_rle4() -> None:\n    with Image.open(\"Tests/images/bmp/g/pal4rle.bmp\") as im:\n        assert_image_similar_tofile(im, \"Tests/images/bmp/g/pal4.bmp\", 12)\n\n\n@pytest.mark.parametrize(\n    \"file_name,length\",\n    (\n        # EOF immediately after the header\n        (\"Tests/images/hopper_rle8.bmp\", 1078),\n        # EOF during delta\n        (\"Tests/images/bmp/q/pal8rletrns.bmp\", 3670),\n        # EOF when reading data in absolute mode\n        (\"Tests/images/bmp/g/pal8rle.bmp\", 1064),\n    ),\n)\ndef test_rle8_eof(file_name: str, length: int) -> None:\n    with open(file_name, \"rb\") as fp:\n        data = fp.read(length)\n        with Image.open(io.BytesIO(data)) as im:\n            with pytest.raises(ValueError):\n                im.load()\n\n\ndef test_offset() -> None:\n    # This image has been hexedited\n    # to exclude the palette size from the pixel data offset\n    with Image.open(\"Tests/images/pal8_offset.bmp\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/bmp/g/pal8.bmp\")\n", "Tests/test_deprecate.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import _deprecate\n\n\n@pytest.mark.parametrize(\n    \"version, expected\",\n    [\n        (\n            11,\n            \"Old thing is deprecated and will be removed in Pillow 11 \"\n            r\"\\(2024-10-15\\)\\. Use new thing instead\\.\",\n        ),\n        (\n            None,\n            r\"Old thing is deprecated and will be removed in a future version\\. \"\n            r\"Use new thing instead\\.\",\n        ),\n    ],\n)\ndef test_version(version: int | None, expected: str) -> None:\n    with pytest.warns(DeprecationWarning, match=expected):\n        _deprecate.deprecate(\"Old thing\", version, \"new thing\")\n\n\ndef test_unknown_version() -> None:\n    expected = r\"Unknown removal version: 12345. Update PIL\\._deprecate\\?\"\n    with pytest.raises(ValueError, match=expected):\n        _deprecate.deprecate(\"Old thing\", 12345, \"new thing\")\n\n\n@pytest.mark.parametrize(\n    \"deprecated, plural, expected\",\n    [\n        (\n            \"Old thing\",\n            False,\n            r\"Old thing is deprecated and should be removed\\.\",\n        ),\n        (\n            \"Old things\",\n            True,\n            r\"Old things are deprecated and should be removed\\.\",\n        ),\n    ],\n)\ndef test_old_version(deprecated: str, plural: bool, expected: str) -> None:\n    expected = r\"\"\n    with pytest.raises(RuntimeError, match=expected):\n        _deprecate.deprecate(deprecated, 1, plural=plural)\n\n\ndef test_plural() -> None:\n    expected = (\n        r\"Old things are deprecated and will be removed in Pillow 11 \\(2024-10-15\\)\\. \"\n        r\"Use new thing instead\\.\"\n    )\n    with pytest.warns(DeprecationWarning, match=expected):\n        _deprecate.deprecate(\"Old things\", 11, \"new thing\", plural=True)\n\n\ndef test_replacement_and_action() -> None:\n    expected = \"Use only one of 'replacement' and 'action'\"\n    with pytest.raises(ValueError, match=expected):\n        _deprecate.deprecate(\n            \"Old thing\", 11, replacement=\"new thing\", action=\"Upgrade to new thing\"\n        )\n\n\n@pytest.mark.parametrize(\n    \"action\",\n    [\n        \"Upgrade to new thing\",\n        \"Upgrade to new thing.\",\n    ],\n)\ndef test_action(action: str) -> None:\n    expected = (\n        r\"Old thing is deprecated and will be removed in Pillow 11 \\(2024-10-15\\)\\. \"\n        r\"Upgrade to new thing\\.\"\n    )\n    with pytest.warns(DeprecationWarning, match=expected):\n        _deprecate.deprecate(\"Old thing\", 11, action=action)\n\n\ndef test_no_replacement_or_action() -> None:\n    expected = (\n        r\"Old thing is deprecated and will be removed in Pillow 11 \\(2024-10-15\\)\"\n    )\n    with pytest.warns(DeprecationWarning, match=expected):\n        _deprecate.deprecate(\"Old thing\", 11)\n", "Tests/test_file_hdf5stub.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import IO\n\nimport pytest\n\nfrom PIL import Hdf5StubImagePlugin, Image, ImageFile\n\nTEST_FILE = \"Tests/images/hdf5.h5\"\n\n\ndef test_open() -> None:\n    # Act\n    with Image.open(TEST_FILE) as im:\n        # Assert\n        assert im.format == \"HDF5\"\n\n        # Dummy data from the stub\n        assert im.mode == \"F\"\n        assert im.size == (1, 1)\n\n\ndef test_invalid_file() -> None:\n    # Arrange\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        Hdf5StubImagePlugin.HDF5StubImageFile(invalid_file)\n\n\ndef test_load() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        # Act / Assert: stub cannot load without an implemented handler\n        with pytest.raises(OSError):\n            im.load()\n\n\ndef test_save() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        dummy_fp = BytesIO()\n        dummy_filename = \"dummy.filename\"\n\n        # Act / Assert: stub cannot save without an implemented handler\n        with pytest.raises(OSError):\n            im.save(dummy_filename)\n        with pytest.raises(OSError):\n            Hdf5StubImagePlugin._save(im, dummy_fp, dummy_filename)\n\n\ndef test_handler(tmp_path: Path) -> None:\n    class TestHandler(ImageFile.StubHandler):\n        opened = False\n        loaded = False\n        saved = False\n\n        def open(self, im: Image.Image) -> None:\n            self.opened = True\n\n        def load(self, im: Image.Image) -> Image.Image:\n            self.loaded = True\n            im.fp.close()\n            return Image.new(\"RGB\", (1, 1))\n\n        def is_loaded(self) -> bool:\n            return self.loaded\n\n        def save(self, im: Image.Image, fp: IO[bytes], filename: str) -> None:\n            self.saved = True\n\n    handler = TestHandler()\n    Hdf5StubImagePlugin.register_handler(handler)\n    with Image.open(TEST_FILE) as im:\n        assert handler.opened\n        assert not handler.is_loaded()\n\n        im.load()\n        assert handler.is_loaded()\n\n        temp_file = str(tmp_path / \"temp.h5\")\n        im.save(temp_file)\n        assert handler.saved\n\n    Hdf5StubImagePlugin._handler = None\n", "Tests/check_fli_overflow.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nTEST_FILE = \"Tests/images/fli_overflow.fli\"\n\n\ndef test_fli_overflow() -> None:\n    # this should not crash with a malloc error or access violation\n    with Image.open(TEST_FILE) as im:\n        im.load()\n", "Tests/test_imagefontpil.py": "from __future__ import annotations\n\nimport struct\nfrom io import BytesIO\n\nimport pytest\n\nfrom PIL import Image, ImageDraw, ImageFont, _util, features\n\nfrom .helper import assert_image_equal_tofile\n\noriginal_core = ImageFont.core\n\n\ndef setup_module() -> None:\n    if features.check_module(\"freetype2\"):\n        ImageFont.core = _util.DeferredError(ImportError(\"Disabled for testing\"))\n\n\ndef teardown_module() -> None:\n    ImageFont.core = original_core\n\n\ndef test_default_font() -> None:\n    # Arrange\n    txt = 'This is a \"better than nothing\" default font.'\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n\n    # Act\n    default_font = ImageFont.load_default()\n    draw.text((10, 10), txt, font=default_font)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/default_font.png\")\n\n\ndef test_size_without_freetype() -> None:\n    with pytest.raises(ImportError):\n        ImageFont.load_default(size=14)\n\n\ndef test_unicode() -> None:\n    # should not segfault, should return UnicodeDecodeError\n    # issue #2826\n    font = ImageFont.load_default()\n    with pytest.raises(UnicodeEncodeError):\n        font.getbbox(\"\u2019\")\n\n\ndef test_textbbox() -> None:\n    im = Image.new(\"RGB\", (200, 200))\n    d = ImageDraw.Draw(im)\n    default_font = ImageFont.load_default()\n    assert d.textlength(\"test\", font=default_font) == 24\n    assert d.textbbox((0, 0), \"test\", font=default_font) == (0, 0, 24, 11)\n\n\ndef test_decompression_bomb() -> None:\n    glyph = struct.pack(\">hhhhhhhhhh\", 1, 0, 0, 0, 256, 256, 0, 0, 256, 256)\n    fp = BytesIO(b\"PILfont\\n\\nDATA\\n\" + glyph * 256)\n\n    font = ImageFont.ImageFont()\n    font._load_pilfont_data(fp, Image.new(\"L\", (256, 256)))\n    with pytest.raises(Image.DecompressionBombError):\n        font.getmask(\"A\" * 1_000_000)\n\n\n@pytest.mark.timeout(4)\ndef test_oom() -> None:\n    glyph = struct.pack(\n        \">hhhhhhhhhh\", 1, 0, -32767, -32767, 32767, 32767, -32767, -32767, 32767, 32767\n    )\n    fp = BytesIO(b\"PILfont\\n\\nDATA\\n\" + glyph * 256)\n\n    font = ImageFont.ImageFont()\n    font._load_pilfont_data(fp, Image.new(\"L\", (1, 1)))\n    font.getmask(\"A\" * 1_000_000)\n\n\ndef test_freetypefont_without_freetype() -> None:\n    with pytest.raises(ImportError):\n        ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\")\n", "Tests/test_file_fits.py": "from __future__ import annotations\n\nfrom io import BytesIO\n\nimport pytest\n\nfrom PIL import FitsImagePlugin, Image\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, hopper\n\nTEST_FILE = \"Tests/images/hopper.fits\"\n\n\ndef test_open() -> None:\n    # Act\n    with Image.open(TEST_FILE) as im:\n        # Assert\n        assert im.format == \"FITS\"\n        assert im.size == (128, 128)\n        assert im.mode == \"L\"\n\n        assert_image_equal(im, hopper(\"L\"))\n\n\ndef test_gzip1() -> None:\n    with Image.open(\"Tests/images/m13_gzip.fits\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/m13.fits\")\n\n\ndef test_invalid_file() -> None:\n    # Arrange\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        FitsImagePlugin.FitsImageFile(invalid_file)\n\n\ndef test_truncated_fits() -> None:\n    # No END to headers\n    image_data = b\"SIMPLE  =                    T\" + b\" \" * 50 + b\"TRUNCATE\"\n    with pytest.raises(OSError):\n        FitsImagePlugin.FitsImageFile(BytesIO(image_data))\n\n\ndef test_naxis_zero() -> None:\n    # This test image has been manually hexedited\n    # to set the number of data axes to zero\n    with pytest.raises(ValueError):\n        with Image.open(\"Tests/images/hopper_naxis_zero.fits\"):\n            pass\n\n\ndef test_comment() -> None:\n    image_data = b\"SIMPLE  =                    T / comment string\"\n    with pytest.raises(OSError):\n        FitsImagePlugin.FitsImageFile(BytesIO(image_data))\n", "Tests/test_file_xpm.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, XpmImagePlugin\n\nfrom .helper import assert_image_similar, hopper\n\nTEST_FILE = \"Tests/images/hopper.xpm\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_FILE) as im:\n        im.load()\n        assert im.mode == \"P\"\n        assert im.size == (128, 128)\n        assert im.format == \"XPM\"\n\n        # large error due to quantization->44 colors.\n        assert_image_similar(im.convert(\"RGB\"), hopper(\"RGB\"), 60)\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        XpmImagePlugin.XpmImageFile(invalid_file)\n\n\ndef test_load_read() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        dummy_bytes = 1\n\n        # Act\n        data = im.load_read(dummy_bytes)\n\n    # Assert\n    assert len(data) == 16384\n", "Tests/test_lib_image.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\n\ndef test_setmode() -> None:\n    im = Image.new(\"L\", (1, 1), 255)\n    im.im.setmode(\"1\")\n    assert im.im.getpixel((0, 0)) == 255\n    im.im.setmode(\"L\")\n    assert im.im.getpixel((0, 0)) == 255\n\n    im = Image.new(\"1\", (1, 1), 1)\n    im.im.setmode(\"L\")\n    assert im.im.getpixel((0, 0)) == 255\n    im.im.setmode(\"1\")\n    assert im.im.getpixel((0, 0)) == 255\n\n    im = Image.new(\"RGB\", (1, 1), (1, 2, 3))\n    im.im.setmode(\"RGB\")\n    assert im.im.getpixel((0, 0)) == (1, 2, 3)\n    im.im.setmode(\"RGBA\")\n    assert im.im.getpixel((0, 0)) == (1, 2, 3, 255)\n    im.im.setmode(\"RGBX\")\n    assert im.im.getpixel((0, 0)) == (1, 2, 3, 255)\n    im.im.setmode(\"RGB\")\n    assert im.im.getpixel((0, 0)) == (1, 2, 3)\n\n    with pytest.raises(ValueError):\n        im.im.setmode(\"L\")\n    with pytest.raises(ValueError):\n        im.im.setmode(\"RGBABCDE\")\n", "Tests/test_imagegrab.py": "from __future__ import annotations\n\nimport os\nimport shutil\nimport subprocess\nimport sys\n\nimport pytest\n\nfrom PIL import Image, ImageGrab\n\nfrom .helper import assert_image_equal_tofile, skip_unless_feature\n\n\nclass TestImageGrab:\n    @pytest.mark.skipif(\n        os.environ.get(\"USERNAME\") == \"ContainerAdministrator\",\n        reason=\"can't grab screen when running in Docker\",\n    )\n    @pytest.mark.skipif(\n        sys.platform not in (\"win32\", \"darwin\"), reason=\"requires Windows or macOS\"\n    )\n    def test_grab(self) -> None:\n        ImageGrab.grab()\n        ImageGrab.grab(include_layered_windows=True)\n        ImageGrab.grab(all_screens=True)\n\n        im = ImageGrab.grab(bbox=(10, 20, 50, 80))\n        assert im.size == (40, 60)\n\n    @skip_unless_feature(\"xcb\")\n    def test_grab_x11(self) -> None:\n        try:\n            if sys.platform not in (\"win32\", \"darwin\"):\n                ImageGrab.grab()\n\n            ImageGrab.grab(xdisplay=\"\")\n        except OSError as e:\n            pytest.skip(str(e))\n\n    @pytest.mark.skipif(Image.core.HAVE_XCB, reason=\"tests missing XCB\")\n    def test_grab_no_xcb(self) -> None:\n        if sys.platform not in (\"win32\", \"darwin\") and not shutil.which(\n            \"gnome-screenshot\"\n        ):\n            with pytest.raises(OSError) as e:\n                ImageGrab.grab()\n            assert str(e.value).startswith(\"Pillow was built without XCB support\")\n\n        with pytest.raises(OSError) as e:\n            ImageGrab.grab(xdisplay=\"\")\n        assert str(e.value).startswith(\"Pillow was built without XCB support\")\n\n    @skip_unless_feature(\"xcb\")\n    def test_grab_invalid_xdisplay(self) -> None:\n        with pytest.raises(OSError) as e:\n            ImageGrab.grab(xdisplay=\"error.test:0.0\")\n        assert str(e.value).startswith(\"X connection failed\")\n\n    def test_grabclipboard(self) -> None:\n        if sys.platform == \"darwin\":\n            subprocess.call([\"screencapture\", \"-cx\"])\n        elif sys.platform == \"win32\":\n            p = subprocess.Popen([\"powershell\", \"-command\", \"-\"], stdin=subprocess.PIPE)\n            p.stdin.write(\n                b\"\"\"[Reflection.Assembly]::LoadWithPartialName(\"System.Drawing\")\n[Reflection.Assembly]::LoadWithPartialName(\"System.Windows.Forms\")\n$bmp = New-Object Drawing.Bitmap 200, 200\n[Windows.Forms.Clipboard]::SetImage($bmp)\"\"\"\n            )\n            p.communicate()\n        else:\n            if not shutil.which(\"wl-paste\") and not shutil.which(\"xclip\"):\n                with pytest.raises(\n                    NotImplementedError,\n                    match=\"wl-paste or xclip is required for\"\n                    r\" ImageGrab.grabclipboard\\(\\) on Linux\",\n                ):\n                    ImageGrab.grabclipboard()\n            return\n\n        ImageGrab.grabclipboard()\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"Windows only\")\n    def test_grabclipboard_file(self) -> None:\n        p = subprocess.Popen([\"powershell\", \"-command\", \"-\"], stdin=subprocess.PIPE)\n        assert p.stdin is not None\n        p.stdin.write(rb'Set-Clipboard -Path \"Tests\\images\\hopper.gif\"')\n        p.communicate()\n\n        im = ImageGrab.grabclipboard()\n        assert len(im) == 1\n        assert os.path.samefile(im[0], \"Tests/images/hopper.gif\")\n\n    @pytest.mark.skipif(sys.platform != \"win32\", reason=\"Windows only\")\n    def test_grabclipboard_png(self) -> None:\n        p = subprocess.Popen([\"powershell\", \"-command\", \"-\"], stdin=subprocess.PIPE)\n        assert p.stdin is not None\n        p.stdin.write(\n            rb\"\"\"$bytes = [System.IO.File]::ReadAllBytes(\"Tests\\images\\hopper.png\")\n$ms = new-object System.IO.MemoryStream(, $bytes)\n[Reflection.Assembly]::LoadWithPartialName(\"System.Windows.Forms\")\n[Windows.Forms.Clipboard]::SetData(\"PNG\", $ms)\"\"\"\n        )\n        p.communicate()\n\n        im = ImageGrab.grabclipboard()\n        assert_image_equal_tofile(im, \"Tests/images/hopper.png\")\n\n    @pytest.mark.skipif(\n        (\n            sys.platform != \"linux\"\n            or not all(shutil.which(cmd) for cmd in (\"wl-paste\", \"wl-copy\"))\n        ),\n        reason=\"Linux with wl-clipboard only\",\n    )\n    @pytest.mark.parametrize(\"ext\", (\"gif\", \"png\", \"ico\"))\n    def test_grabclipboard_wl_clipboard(self, ext: str) -> None:\n        image_path = \"Tests/images/hopper.\" + ext\n        with open(image_path, \"rb\") as fp:\n            subprocess.call([\"wl-copy\"], stdin=fp)\n        im = ImageGrab.grabclipboard()\n        assert_image_equal_tofile(im, image_path)\n\n    @pytest.mark.skipif(\n        (\n            sys.platform != \"linux\"\n            or not all(shutil.which(cmd) for cmd in (\"wl-paste\", \"wl-copy\"))\n        ),\n        reason=\"Linux with wl-clipboard only\",\n    )\n    @pytest.mark.parametrize(\"arg\", (\"text\", \"--clear\"))\n    def test_grabclipboard_wl_clipboard_errors(self, arg: str) -> None:\n        subprocess.call([\"wl-copy\", arg])\n        assert ImageGrab.grabclipboard() is None\n", "Tests/test_pickle.py": "from __future__ import annotations\n\nimport pickle\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImageDraw, ImageFont\n\nfrom .helper import assert_image_equal, skip_unless_feature\n\nFONT_SIZE = 20\nFONT_PATH = \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\"\n\n\ndef helper_pickle_file(\n    tmp_path: Path, protocol: int, test_file: str, mode: str | None\n) -> None:\n    # Arrange\n    with Image.open(test_file) as im:\n        filename = str(tmp_path / \"temp.pkl\")\n        if mode:\n            im = im.convert(mode)\n\n        # Act\n        with open(filename, \"wb\") as f:\n            pickle.dump(im, f, protocol)\n        with open(filename, \"rb\") as f:\n            loaded_im = pickle.load(f)\n\n        # Assert\n        assert im == loaded_im\n\n\ndef helper_pickle_string(protocol: int, test_file: str, mode: str | None) -> None:\n    with Image.open(test_file) as im:\n        if mode:\n            im = im.convert(mode)\n\n        # Act\n        dumped_string = pickle.dumps(im, protocol)\n        loaded_im = pickle.loads(dumped_string)\n\n        # Assert\n        assert im == loaded_im\n\n\n@pytest.mark.parametrize(\n    (\"test_file\", \"test_mode\"),\n    [\n        (\"Tests/images/hopper.jpg\", None),\n        (\"Tests/images/hopper.jpg\", \"L\"),\n        (\"Tests/images/hopper.jpg\", \"PA\"),\n        pytest.param(\n            \"Tests/images/hopper.webp\", None, marks=skip_unless_feature(\"webp\")\n        ),\n        (\"Tests/images/hopper.tif\", None),\n        (\"Tests/images/test-card.png\", None),\n        (\"Tests/images/zero_bb.png\", None),\n        (\"Tests/images/zero_bb_scale2.png\", None),\n        (\"Tests/images/non_zero_bb.png\", None),\n        (\"Tests/images/non_zero_bb_scale2.png\", None),\n        (\"Tests/images/p_trns_single.png\", None),\n        (\"Tests/images/pil123p.png\", None),\n        (\"Tests/images/itxt_chunks.png\", None),\n    ],\n)\n@pytest.mark.parametrize(\"protocol\", range(0, pickle.HIGHEST_PROTOCOL + 1))\ndef test_pickle_image(\n    tmp_path: Path, test_file: str, test_mode: str | None, protocol: int\n) -> None:\n    # Act / Assert\n    helper_pickle_string(protocol, test_file, test_mode)\n    helper_pickle_file(tmp_path, protocol, test_file, test_mode)\n\n\ndef test_pickle_la_mode_with_palette(tmp_path: Path) -> None:\n    # Arrange\n    filename = str(tmp_path / \"temp.pkl\")\n    with Image.open(\"Tests/images/hopper.jpg\") as im:\n        im = im.convert(\"PA\")\n\n    # Act / Assert\n    for protocol in range(0, pickle.HIGHEST_PROTOCOL + 1):\n        im._mode = \"LA\"\n        with open(filename, \"wb\") as f:\n            pickle.dump(im, f, protocol)\n        with open(filename, \"rb\") as f:\n            loaded_im = pickle.load(f)\n\n        im._mode = \"PA\"\n        assert im == loaded_im\n\n\n@skip_unless_feature(\"webp\")\ndef test_pickle_tell() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/hopper.webp\") as image:\n        # Act: roundtrip\n        unpickled_image = pickle.loads(pickle.dumps(image))\n\n    # Assert\n    assert unpickled_image.tell() == 0\n\n\ndef helper_assert_pickled_font_images(\n    font1: ImageFont.FreeTypeFont, font2: ImageFont.FreeTypeFont\n) -> None:\n    # Arrange\n    im1 = Image.new(mode=\"RGBA\", size=(300, 100))\n    im2 = Image.new(mode=\"RGBA\", size=(300, 100))\n    draw1 = ImageDraw.Draw(im1)\n    draw2 = ImageDraw.Draw(im2)\n    txt = \"Hello World!\"\n\n    # Act\n    draw1.text((10, 10), txt, font=font1)\n    draw2.text((10, 10), txt, font=font2)\n\n    # Assert\n    assert_image_equal(im1, im2)\n\n\n@skip_unless_feature(\"freetype2\")\n@pytest.mark.parametrize(\"protocol\", list(range(0, pickle.HIGHEST_PROTOCOL + 1)))\ndef test_pickle_font_string(protocol: int) -> None:\n    # Arrange\n    font = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    # Act: roundtrip\n    pickled_font = pickle.dumps(font, protocol)\n    unpickled_font = pickle.loads(pickled_font)\n\n    # Assert\n    helper_assert_pickled_font_images(font, unpickled_font)\n\n\n@skip_unless_feature(\"freetype2\")\n@pytest.mark.parametrize(\"protocol\", list(range(0, pickle.HIGHEST_PROTOCOL + 1)))\ndef test_pickle_font_file(tmp_path: Path, protocol: int) -> None:\n    # Arrange\n    font = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n    filename = str(tmp_path / \"temp.pkl\")\n\n    # Act: roundtrip\n    with open(filename, \"wb\") as f:\n        pickle.dump(font, f, protocol)\n    with open(filename, \"rb\") as f:\n        unpickled_font = pickle.load(f)\n\n    # Assert\n    helper_assert_pickled_font_images(font, unpickled_font)\n", "Tests/test_image_paste.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import CachedProperty, assert_image_equal\n\n\nclass TestImagingPaste:\n    size = 128\n\n    def assert_9points_image(\n        self, im: Image.Image, expected: list[tuple[int, int, int, int]]\n    ) -> None:\n        px = im.load()\n        actual = [\n            px[0, 0],\n            px[self.size // 2, 0],\n            px[self.size - 1, 0],\n            px[0, self.size // 2],\n            px[self.size // 2, self.size // 2],\n            px[self.size - 1, self.size // 2],\n            px[0, self.size - 1],\n            px[self.size // 2, self.size - 1],\n            px[self.size - 1, self.size - 1],\n        ]\n        assert actual == [\n            point[0] if im.mode == \"L\" else point[: len(im.mode)] for point in expected\n        ]\n\n    def assert_9points_paste(\n        self,\n        im: Image.Image,\n        im2: Image.Image | str | tuple[int, ...],\n        mask: Image.Image,\n        expected: list[tuple[int, int, int, int]],\n    ) -> None:\n        im3 = im.copy()\n        im3.paste(im2, (0, 0), mask)\n        self.assert_9points_image(im3, expected)\n\n        # Abbreviated syntax\n        im.paste(im2, mask)\n        self.assert_9points_image(im, expected)\n\n    @CachedProperty\n    def mask_1(self) -> Image.Image:\n        mask = Image.new(\"1\", (self.size, self.size))\n        px = mask.load()\n        for y in range(mask.height):\n            for x in range(mask.width):\n                px[y, x] = (x + y) % 2\n        return mask\n\n    @CachedProperty\n    def mask_L(self) -> Image.Image:\n        return self.gradient_L.transpose(Image.Transpose.ROTATE_270)\n\n    @CachedProperty\n    def gradient_L(self) -> Image.Image:\n        gradient = Image.new(\"L\", (self.size, self.size))\n        px = gradient.load()\n        for y in range(gradient.height):\n            for x in range(gradient.width):\n                px[y, x] = (x + y) % 255\n        return gradient\n\n    @CachedProperty\n    def gradient_RGB(self) -> Image.Image:\n        return Image.merge(\n            \"RGB\",\n            [\n                self.gradient_L,\n                self.gradient_L.transpose(Image.Transpose.ROTATE_90),\n                self.gradient_L.transpose(Image.Transpose.ROTATE_180),\n            ],\n        )\n\n    @CachedProperty\n    def gradient_LA(self) -> Image.Image:\n        return Image.merge(\n            \"LA\",\n            [\n                self.gradient_L,\n                self.gradient_L.transpose(Image.Transpose.ROTATE_90),\n            ],\n        )\n\n    @CachedProperty\n    def gradient_RGBA(self) -> Image.Image:\n        return Image.merge(\n            \"RGBA\",\n            [\n                self.gradient_L,\n                self.gradient_L.transpose(Image.Transpose.ROTATE_90),\n                self.gradient_L.transpose(Image.Transpose.ROTATE_180),\n                self.gradient_L.transpose(Image.Transpose.ROTATE_270),\n            ],\n        )\n\n    @CachedProperty\n    def gradient_RGBa(self) -> Image.Image:\n        return Image.merge(\n            \"RGBa\",\n            [\n                self.gradient_L,\n                self.gradient_L.transpose(Image.Transpose.ROTATE_90),\n                self.gradient_L.transpose(Image.Transpose.ROTATE_180),\n                self.gradient_L.transpose(Image.Transpose.ROTATE_270),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_image_solid(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), \"red\")\n        im2 = getattr(self, \"gradient_\" + mode)\n\n        im.paste(im2, (12, 23))\n\n        im = im.crop((12, 23, im2.width + 12, im2.height + 23))\n        assert_image_equal(im, im2)\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_image_mask_1(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), \"white\")\n        im2 = getattr(self, \"gradient_\" + mode)\n\n        self.assert_9points_paste(\n            im,\n            im2,\n            self.mask_1,\n            [\n                (255, 255, 255, 255),\n                (255, 255, 255, 255),\n                (127, 254, 127, 0),\n                (255, 255, 255, 255),\n                (255, 255, 255, 255),\n                (191, 190, 63, 64),\n                (127, 0, 127, 254),\n                (191, 64, 63, 190),\n                (255, 255, 255, 255),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_image_mask_L(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), \"white\")\n        im2 = getattr(self, \"gradient_\" + mode)\n\n        self.assert_9points_paste(\n            im,\n            im2,\n            self.mask_L,\n            [\n                (128, 191, 255, 191),\n                (208, 239, 239, 208),\n                (255, 255, 255, 255),\n                (112, 111, 206, 207),\n                (192, 191, 191, 191),\n                (239, 239, 207, 207),\n                (128, 1, 128, 254),\n                (207, 113, 112, 207),\n                (255, 191, 128, 191),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_image_mask_LA(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), \"white\")\n        im2 = getattr(self, \"gradient_\" + mode)\n\n        self.assert_9points_paste(\n            im,\n            im2,\n            self.gradient_LA,\n            [\n                (128, 191, 255, 191),\n                (112, 207, 206, 111),\n                (128, 254, 128, 1),\n                (208, 208, 239, 239),\n                (192, 191, 191, 191),\n                (207, 207, 112, 113),\n                (255, 255, 255, 255),\n                (239, 207, 207, 239),\n                (255, 191, 128, 191),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_image_mask_RGBA(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), \"white\")\n        im2 = getattr(self, \"gradient_\" + mode)\n\n        self.assert_9points_paste(\n            im,\n            im2,\n            self.gradient_RGBA,\n            [\n                (128, 191, 255, 191),\n                (208, 239, 239, 208),\n                (255, 255, 255, 255),\n                (112, 111, 206, 207),\n                (192, 191, 191, 191),\n                (239, 239, 207, 207),\n                (128, 1, 128, 254),\n                (207, 113, 112, 207),\n                (255, 191, 128, 191),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_image_mask_RGBa(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), \"white\")\n        im2 = getattr(self, \"gradient_\" + mode)\n\n        self.assert_9points_paste(\n            im,\n            im2,\n            self.gradient_RGBa,\n            [\n                (128, 255, 126, 255),\n                (0, 127, 126, 255),\n                (126, 253, 126, 255),\n                (128, 127, 254, 255),\n                (0, 255, 254, 255),\n                (126, 125, 254, 255),\n                (128, 1, 128, 255),\n                (0, 129, 128, 255),\n                (126, 255, 128, 255),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_color_solid(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), \"black\")\n\n        rect = (12, 23, 128 + 12, 128 + 23)\n        im.paste(\"white\", rect)\n\n        hist = im.crop(rect).histogram()\n        while hist:\n            head, hist = hist[:256], hist[256:]\n            assert head[255] == 128 * 128\n            assert sum(head[:255]) == 0\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_color_mask_1(self, mode: str) -> None:\n        im = Image.new(mode, (200, 200), (50, 60, 70, 80)[: len(mode)])\n        color = (10, 20, 30, 40)[: len(mode)]\n\n        self.assert_9points_paste(\n            im,\n            color,\n            self.mask_1,\n            [\n                (50, 60, 70, 80),\n                (50, 60, 70, 80),\n                (10, 20, 30, 40),\n                (50, 60, 70, 80),\n                (50, 60, 70, 80),\n                (10, 20, 30, 40),\n                (10, 20, 30, 40),\n                (10, 20, 30, 40),\n                (50, 60, 70, 80),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_color_mask_L(self, mode: str) -> None:\n        im = getattr(self, \"gradient_\" + mode).copy()\n        color = \"white\"\n\n        self.assert_9points_paste(\n            im,\n            color,\n            self.mask_L,\n            [\n                (127, 191, 254, 191),\n                (111, 207, 206, 110),\n                (127, 254, 127, 0),\n                (207, 207, 239, 239),\n                (191, 191, 190, 191),\n                (207, 206, 111, 112),\n                (254, 254, 254, 255),\n                (239, 206, 206, 238),\n                (254, 191, 127, 191),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_color_mask_RGBA(self, mode: str) -> None:\n        im = getattr(self, \"gradient_\" + mode).copy()\n        color = \"white\"\n\n        self.assert_9points_paste(\n            im,\n            color,\n            self.gradient_RGBA,\n            [\n                (127, 191, 254, 191),\n                (111, 207, 206, 110),\n                (127, 254, 127, 0),\n                (207, 207, 239, 239),\n                (191, 191, 190, 191),\n                (207, 206, 111, 112),\n                (254, 254, 254, 255),\n                (239, 206, 206, 238),\n                (254, 191, 127, 191),\n            ],\n        )\n\n    @pytest.mark.parametrize(\"mode\", [\"RGBA\", \"RGB\", \"L\"])\n    def test_color_mask_RGBa(self, mode: str) -> None:\n        im = getattr(self, \"gradient_\" + mode).copy()\n        color = \"white\"\n\n        self.assert_9points_paste(\n            im,\n            color,\n            self.gradient_RGBa,\n            [\n                (255, 63, 126, 63),\n                (47, 143, 142, 46),\n                (126, 253, 126, 255),\n                (15, 15, 47, 47),\n                (63, 63, 62, 63),\n                (142, 141, 46, 47),\n                (255, 255, 255, 0),\n                (48, 15, 15, 47),\n                (126, 63, 255, 63),\n            ],\n        )\n\n    def test_different_sizes(self) -> None:\n        im = Image.new(\"RGB\", (100, 100))\n        im2 = Image.new(\"RGB\", (50, 50))\n\n        im.copy().paste(im2)\n        im.copy().paste(im2, (0, 0))\n\n    def test_incorrect_abbreviated_form(self) -> None:\n        im = Image.new(\"L\", (1, 1))\n        with pytest.raises(ValueError):\n            im.paste(im, im, im)\n", "Tests/test_shell_injection.py": "from __future__ import annotations\n\nimport shutil\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import IO, Callable\n\nimport pytest\n\nfrom PIL import GifImagePlugin, Image, JpegImagePlugin\n\nfrom .helper import cjpeg_available, djpeg_available, is_win32, netpbm_available\n\nTEST_JPG = \"Tests/images/hopper.jpg\"\nTEST_GIF = \"Tests/images/hopper.gif\"\n\ntest_filenames = (\"temp_';\", 'temp_\";', \"temp_'\\\"|\", \"temp_'\\\"||\", \"temp_'\\\"&&\")\n\n\n@pytest.mark.skipif(is_win32(), reason=\"Requires Unix or macOS\")\nclass TestShellInjection:\n    def assert_save_filename_check(\n        self,\n        tmp_path: Path,\n        src_img: Image.Image,\n        save_func: Callable[[Image.Image, IO[bytes], str | bytes], None],\n    ) -> None:\n        for filename in test_filenames:\n            dest_file = str(tmp_path / filename)\n            save_func(src_img, BytesIO(), dest_file)\n            # If file can't be opened, shell injection probably occurred\n            with Image.open(dest_file) as im:\n                im.load()\n\n    @pytest.mark.skipif(not djpeg_available(), reason=\"djpeg not available\")\n    def test_load_djpeg_filename(self, tmp_path: Path) -> None:\n        for filename in test_filenames:\n            src_file = str(tmp_path / filename)\n            shutil.copy(TEST_JPG, src_file)\n\n            with Image.open(src_file) as im:\n                im.load_djpeg()\n\n    @pytest.mark.skipif(not cjpeg_available(), reason=\"cjpeg not available\")\n    def test_save_cjpeg_filename(self, tmp_path: Path) -> None:\n        with Image.open(TEST_JPG) as im:\n            self.assert_save_filename_check(tmp_path, im, JpegImagePlugin._save_cjpeg)\n\n    @pytest.mark.skipif(not netpbm_available(), reason=\"Netpbm not available\")\n    def test_save_netpbm_filename_bmp_mode(self, tmp_path: Path) -> None:\n        with Image.open(TEST_GIF) as im:\n            im = im.convert(\"RGB\")\n            self.assert_save_filename_check(tmp_path, im, GifImagePlugin._save_netpbm)\n\n    @pytest.mark.skipif(not netpbm_available(), reason=\"Netpbm not available\")\n    def test_save_netpbm_filename_l_mode(self, tmp_path: Path) -> None:\n        with Image.open(TEST_GIF) as im:\n            im = im.convert(\"L\")\n            self.assert_save_filename_check(tmp_path, im, GifImagePlugin._save_netpbm)\n", "Tests/test_pyroma.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import __version__\n\npyroma = pytest.importorskip(\"pyroma\", reason=\"Pyroma not installed\")\n\n\ndef test_pyroma() -> None:\n    # Arrange\n    data = pyroma.projectdata.get_data(\".\")\n\n    # Act\n    rating = pyroma.ratings.rate(data)\n\n    # Assert\n    if \"rc\" in __version__:\n        # Pyroma needs to chill about RC versions and not kill all our tests.\n        assert rating == (\n            9,\n            [\"The package's version number does not comply with PEP-386.\"],\n        )\n\n    else:\n        # Should have a perfect score\n        assert rating == (10, [])\n", "Tests/test_numpy.py": "from __future__ import annotations\n\nimport warnings\nfrom typing import TYPE_CHECKING\n\nimport pytest\n\nfrom PIL import Image, _typing\n\nfrom .helper import assert_deep_equal, assert_image, hopper, skip_unless_feature\n\nif TYPE_CHECKING:\n    import numpy\n    import numpy.typing as npt\nelse:\n    numpy = pytest.importorskip(\"numpy\", reason=\"NumPy not installed\")\n\nTEST_IMAGE_SIZE = (10, 10)\n\n\ndef test_numpy_to_image() -> None:\n    def to_image(dtype: npt.DTypeLike, bands: int = 1, boolean: int = 0) -> Image.Image:\n        if bands == 1:\n            if boolean:\n                data = [0, 255] * 50\n            else:\n                data = list(range(100))\n            a = numpy.array(data, dtype=dtype)\n            a.shape = TEST_IMAGE_SIZE\n            i = Image.fromarray(a)\n            if list(i.getdata()) != data:\n                print(\"data mismatch for\", dtype)\n        else:\n            data = list(range(100))\n            a = numpy.array([[x] * bands for x in data], dtype=dtype)\n            a.shape = TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1], bands\n            i = Image.fromarray(a)\n            if list(i.getchannel(0).getdata()) != list(range(100)):\n                print(\"data mismatch for\", dtype)\n        return i\n\n    # Check supported 1-bit integer formats\n    assert_image(to_image(bool, 1, 1), \"1\", TEST_IMAGE_SIZE)\n    assert_image(to_image(numpy.bool_, 1, 1), \"1\", TEST_IMAGE_SIZE)\n\n    # Check supported 8-bit integer formats\n    assert_image(to_image(numpy.uint8), \"L\", TEST_IMAGE_SIZE)\n    assert_image(to_image(numpy.uint8, 3), \"RGB\", TEST_IMAGE_SIZE)\n    assert_image(to_image(numpy.uint8, 4), \"RGBA\", TEST_IMAGE_SIZE)\n    assert_image(to_image(numpy.int8), \"I\", TEST_IMAGE_SIZE)\n\n    # Check non-fixed-size integer types\n    # These may fail, depending on the platform, since we have no native\n    # 64-bit int image types.\n    # assert_image(to_image(numpy.uint), \"I\", TEST_IMAGE_SIZE)\n    # assert_image(to_image(numpy.int), \"I\", TEST_IMAGE_SIZE)\n\n    # Check 16-bit integer formats\n    if Image._ENDIAN == \"<\":\n        assert_image(to_image(numpy.uint16), \"I;16\", TEST_IMAGE_SIZE)\n    else:\n        assert_image(to_image(numpy.uint16), \"I;16B\", TEST_IMAGE_SIZE)\n\n    assert_image(to_image(numpy.int16), \"I\", TEST_IMAGE_SIZE)\n\n    # Check 32-bit integer formats\n    assert_image(to_image(numpy.uint32), \"I\", TEST_IMAGE_SIZE)\n    assert_image(to_image(numpy.int32), \"I\", TEST_IMAGE_SIZE)\n\n    # Check 64-bit integer formats\n    with pytest.raises(TypeError):\n        to_image(numpy.uint64)\n    with pytest.raises(TypeError):\n        to_image(numpy.int64)\n\n    # Check floating-point formats\n    assert_image(to_image(float), \"F\", TEST_IMAGE_SIZE)\n    with pytest.raises(TypeError):\n        to_image(numpy.float16)\n    assert_image(to_image(numpy.float32), \"F\", TEST_IMAGE_SIZE)\n    assert_image(to_image(numpy.float64), \"F\", TEST_IMAGE_SIZE)\n\n    assert_image(to_image(numpy.uint8, 2), \"LA\", (10, 10))\n    assert_image(to_image(numpy.uint8, 3), \"RGB\", (10, 10))\n    assert_image(to_image(numpy.uint8, 4), \"RGBA\", (10, 10))\n\n\n# Based on an erring example at\n# https://stackoverflow.com/questions/10854903/what-is-causing-dimension-dependent-attributeerror-in-pil-fromarray-function\ndef test_3d_array() -> None:\n    size = (5, TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1])\n    a = numpy.ones(size, dtype=numpy.uint8)\n    assert_image(Image.fromarray(a[1, :, :]), \"L\", TEST_IMAGE_SIZE)\n    size = (TEST_IMAGE_SIZE[0], 5, TEST_IMAGE_SIZE[1])\n    a = numpy.ones(size, dtype=numpy.uint8)\n    assert_image(Image.fromarray(a[:, 1, :]), \"L\", TEST_IMAGE_SIZE)\n    size = (TEST_IMAGE_SIZE[0], TEST_IMAGE_SIZE[1], 5)\n    a = numpy.ones(size, dtype=numpy.uint8)\n    assert_image(Image.fromarray(a[:, :, 1]), \"L\", TEST_IMAGE_SIZE)\n\n\ndef test_1d_array() -> None:\n    a = numpy.ones(5, dtype=numpy.uint8)\n    assert_image(Image.fromarray(a), \"L\", (1, 5))\n\n\ndef _test_img_equals_nparray(img: Image.Image, np_img: _typing.NumpyArray) -> None:\n    assert len(np_img.shape) >= 2\n    np_size = np_img.shape[1], np_img.shape[0]\n    assert img.size == np_size\n    px = img.load()\n    for x in range(0, img.size[0], int(img.size[0] / 10)):\n        for y in range(0, img.size[1], int(img.size[1] / 10)):\n            assert_deep_equal(px[x, y], np_img[y, x])\n\n\ndef test_16bit() -> None:\n    with Image.open(\"Tests/images/16bit.cropped.tif\") as img:\n        np_img = numpy.array(img)\n        _test_img_equals_nparray(img, np_img)\n    assert np_img.dtype == numpy.dtype(\"<u2\")\n\n\ndef test_1bit() -> None:\n    # Test that 1-bit arrays convert to numpy and back\n    # See: https://github.com/python-pillow/Pillow/issues/350\n    arr = numpy.array([[1, 0, 0, 1, 0], [0, 1, 0, 0, 0]], \"u1\")\n    img = Image.fromarray(arr * 255).convert(\"1\")\n    assert img.mode == \"1\"\n    arr_back = numpy.array(img)\n    numpy.testing.assert_array_equal(arr, arr_back)\n\n\ndef test_save_tiff_uint16() -> None:\n    # Tests that we're getting the pixel value in the right byte order.\n    pixel_value = 0x1234\n    a = numpy.array(\n        [pixel_value] * TEST_IMAGE_SIZE[0] * TEST_IMAGE_SIZE[1], dtype=numpy.uint16\n    )\n    a.shape = TEST_IMAGE_SIZE\n    img = Image.fromarray(a)\n\n    img_px = img.load()\n    assert img_px[0, 0] == pixel_value\n\n\n@pytest.mark.parametrize(\n    \"mode, dtype\",\n    (\n        (\"L\", numpy.uint8),\n        (\"I\", numpy.int32),\n        (\"F\", numpy.float32),\n        (\"LA\", numpy.uint8),\n        (\"RGB\", numpy.uint8),\n        (\"RGBA\", numpy.uint8),\n        (\"RGBX\", numpy.uint8),\n        (\"CMYK\", numpy.uint8),\n        (\"YCbCr\", numpy.uint8),\n        (\"I;16\", \"<u2\"),\n        (\"I;16B\", \">u2\"),\n        (\"I;16L\", \"<u2\"),\n        (\"HSV\", numpy.uint8),\n    ),\n)\ndef test_to_array(mode: str, dtype: npt.DTypeLike) -> None:\n    img = hopper(mode)\n\n    # Resize to non-square\n    img = img.crop((3, 0, 124, 127))\n    assert img.size == (121, 127)\n\n    np_img = numpy.array(img)\n    _test_img_equals_nparray(img, np_img)\n    assert np_img.dtype == dtype\n\n\ndef test_point_lut() -> None:\n    # See https://github.com/python-pillow/Pillow/issues/439\n\n    data = list(range(256)) * 3\n    lut = numpy.array(data, dtype=numpy.uint8)\n\n    im = hopper()\n\n    im.point(lut)\n\n\ndef test_putdata() -> None:\n    # Shouldn't segfault\n    # See https://github.com/python-pillow/Pillow/issues/1008\n\n    im = Image.new(\"F\", (150, 100))\n    arr = numpy.zeros((15000,), numpy.float32)\n    im.putdata(arr)\n\n    assert len(im.getdata()) == len(arr)\n\n\n@pytest.mark.parametrize(\n    \"dtype\",\n    (\n        bool,\n        numpy.bool_,\n        numpy.int8,\n        numpy.int16,\n        numpy.int32,\n        numpy.uint8,\n        numpy.uint16,\n        numpy.uint32,\n        float,\n        numpy.float32,\n        numpy.float64,\n    ),\n)\ndef test_roundtrip_eye(dtype: npt.DTypeLike) -> None:\n    arr = numpy.eye(10, dtype=dtype)\n    numpy.testing.assert_array_equal(arr, numpy.array(Image.fromarray(arr)))\n\n\ndef test_zero_size() -> None:\n    # Shouldn't cause floating point exception\n    # See https://github.com/python-pillow/Pillow/issues/2259\n\n    im = Image.fromarray(numpy.empty((0, 0), dtype=numpy.uint8))\n\n    assert im.size == (0, 0)\n\n\n@skip_unless_feature(\"libtiff\")\ndef test_load_first() -> None:\n    with Image.open(\"Tests/images/g4_orientation_5.tif\") as im:\n        a = numpy.array(im)\n        assert a.shape == (88, 590)\n\n\ndef test_bool() -> None:\n    # https://github.com/python-pillow/Pillow/issues/2044\n    a = numpy.zeros((10, 2), dtype=bool)\n    a[0][0] = True\n\n    im2 = Image.fromarray(a)\n    assert im2.getdata()[0] == 255\n\n\ndef test_no_resource_warning_for_numpy_array() -> None:\n    # https://github.com/python-pillow/Pillow/issues/835\n    # Arrange\n    from numpy import array\n\n    test_file = \"Tests/images/hopper.png\"\n    with Image.open(test_file) as im:\n        # Act/Assert\n        with warnings.catch_warnings():\n            array(im)\n", "Tests/test_decompression_bomb.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\nTEST_FILE = \"Tests/images/hopper.ppm\"\n\nORIGINAL_LIMIT = Image.MAX_IMAGE_PIXELS\n\n\nclass TestDecompressionBomb:\n    def teardown_method(self) -> None:\n        Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT\n\n    def test_no_warning_small_file(self) -> None:\n        # Implicit assert: no warning.\n        # A warning would cause a failure.\n        with Image.open(TEST_FILE):\n            pass\n\n    def test_no_warning_no_limit(self) -> None:\n        # Arrange\n        # Turn limit off\n        Image.MAX_IMAGE_PIXELS = None\n        assert Image.MAX_IMAGE_PIXELS is None\n\n        # Act / Assert\n        # Implicit assert: no warning.\n        # A warning would cause a failure.\n        with Image.open(TEST_FILE):\n            pass\n\n    def test_warning(self) -> None:\n        # Set limit to trigger warning on the test file\n        Image.MAX_IMAGE_PIXELS = 128 * 128 - 1\n        assert Image.MAX_IMAGE_PIXELS == 128 * 128 - 1\n\n        with pytest.warns(Image.DecompressionBombWarning):\n            with Image.open(TEST_FILE):\n                pass\n\n    def test_exception(self) -> None:\n        # Set limit to trigger exception on the test file\n        Image.MAX_IMAGE_PIXELS = 64 * 128 - 1\n        assert Image.MAX_IMAGE_PIXELS == 64 * 128 - 1\n\n        with pytest.raises(Image.DecompressionBombError):\n            with Image.open(TEST_FILE):\n                pass\n\n    def test_exception_ico(self) -> None:\n        with pytest.raises(Image.DecompressionBombError):\n            with Image.open(\"Tests/images/decompression_bomb.ico\"):\n                pass\n\n    def test_exception_gif(self) -> None:\n        with pytest.raises(Image.DecompressionBombError):\n            with Image.open(\"Tests/images/decompression_bomb.gif\"):\n                pass\n\n    def test_exception_gif_extents(self) -> None:\n        with Image.open(\"Tests/images/decompression_bomb_extents.gif\") as im:\n            with pytest.raises(Image.DecompressionBombError):\n                im.seek(1)\n\n    def test_exception_gif_zero_width(self) -> None:\n        # Set limit to trigger exception on the test file\n        Image.MAX_IMAGE_PIXELS = 4 * 64 * 128\n        assert Image.MAX_IMAGE_PIXELS == 4 * 64 * 128\n\n        with pytest.raises(Image.DecompressionBombError):\n            with Image.open(\"Tests/images/zero_width.gif\"):\n                pass\n\n    def test_exception_bmp(self) -> None:\n        with pytest.raises(Image.DecompressionBombError):\n            with Image.open(\"Tests/images/bmp/b/reallybig.bmp\"):\n                pass\n\n\nclass TestDecompressionCrop:\n    @classmethod\n    def setup_class(cls) -> None:\n        width, height = 128, 128\n        Image.MAX_IMAGE_PIXELS = height * width * 4 - 1\n\n    @classmethod\n    def teardown_class(cls) -> None:\n        Image.MAX_IMAGE_PIXELS = ORIGINAL_LIMIT\n\n    def test_enlarge_crop(self) -> None:\n        # Crops can extend the extents, therefore we should have the\n        # same decompression bomb warnings on them.\n        with hopper() as src:\n            box = (0, 0, src.width * 2, src.height * 2)\n            with pytest.warns(Image.DecompressionBombWarning):\n                src.crop(box)\n\n    def test_crop_decompression_checks(self) -> None:\n        im = Image.new(\"RGB\", (100, 100))\n\n        for value in ((-9999, -9999, -9990, -9990), (-999, -999, -990, -990)):\n            assert im.crop(value).size == (9, 9)\n\n        with pytest.warns(Image.DecompressionBombWarning):\n            im.crop((-160, -160, 99, 99))\n\n        with pytest.raises(Image.DecompressionBombError):\n            im.crop((-99909, -99990, 99999, 99999))\n", "Tests/test_file_webp.py": "from __future__ import annotations\n\nimport io\nimport re\nimport sys\nimport warnings\nfrom pathlib import Path\nfrom typing import Any\n\nimport pytest\n\nfrom PIL import Image, WebPImagePlugin, features\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    hopper,\n    skip_unless_feature,\n)\n\ntry:\n    from PIL import _webp\n\n    HAVE_WEBP = True\nexcept ImportError:\n    HAVE_WEBP = False\n\n\nclass TestUnsupportedWebp:\n    def test_unsupported(self) -> None:\n        if HAVE_WEBP:\n            WebPImagePlugin.SUPPORTED = False\n\n        file_path = \"Tests/images/hopper.webp\"\n        with pytest.warns(UserWarning):\n            with pytest.raises(OSError):\n                with Image.open(file_path):\n                    pass\n\n        if HAVE_WEBP:\n            WebPImagePlugin.SUPPORTED = True\n\n\n@skip_unless_feature(\"webp\")\nclass TestFileWebp:\n    def setup_method(self) -> None:\n        self.rgb_mode = \"RGB\"\n\n    def test_version(self) -> None:\n        _webp.WebPDecoderVersion()\n        _webp.WebPDecoderBuggyAlpha()\n        version = features.version_module(\"webp\")\n        assert version is not None\n        assert re.search(r\"\\d+\\.\\d+\\.\\d+$\", version)\n\n    def test_read_rgb(self) -> None:\n        \"\"\"\n        Can we read a RGB mode WebP file without error?\n        Does it have the bits we expect?\n        \"\"\"\n\n        with Image.open(\"Tests/images/hopper.webp\") as image:\n            assert image.mode == self.rgb_mode\n            assert image.size == (128, 128)\n            assert image.format == \"WEBP\"\n            image.load()\n            image.getdata()\n\n            # generated with:\n            # dwebp -ppm ../../Tests/images/hopper.webp -o hopper_webp_bits.ppm\n            assert_image_similar_tofile(image, \"Tests/images/hopper_webp_bits.ppm\", 1.0)\n\n    def _roundtrip(\n        self, tmp_path: Path, mode: str, epsilon: float, args: dict[str, Any] = {}\n    ) -> None:\n        temp_file = str(tmp_path / \"temp.webp\")\n\n        hopper(mode).save(temp_file, **args)\n        with Image.open(temp_file) as image:\n            assert image.mode == self.rgb_mode\n            assert image.size == (128, 128)\n            assert image.format == \"WEBP\"\n            image.load()\n            image.getdata()\n\n            if mode == self.rgb_mode:\n                # generated with: dwebp -ppm temp.webp -o hopper_webp_write.ppm\n                assert_image_similar_tofile(\n                    image, \"Tests/images/hopper_webp_write.ppm\", 12.0\n                )\n\n            # This test asserts that the images are similar. If the average pixel\n            # difference between the two images is less than the epsilon value,\n            # then we're going to accept that it's a reasonable lossy version of\n            # the image.\n            target = hopper(mode)\n            if mode != self.rgb_mode:\n                target = target.convert(self.rgb_mode)\n            assert_image_similar(image, target, epsilon)\n\n    def test_write_rgb(self, tmp_path: Path) -> None:\n        \"\"\"\n        Can we write a RGB mode file to webp without error?\n        Does it have the bits we expect?\n        \"\"\"\n\n        self._roundtrip(tmp_path, self.rgb_mode, 12.5)\n\n    def test_write_method(self, tmp_path: Path) -> None:\n        self._roundtrip(tmp_path, self.rgb_mode, 12.0, {\"method\": 6})\n\n        buffer_no_args = io.BytesIO()\n        hopper().save(buffer_no_args, format=\"WEBP\")\n\n        buffer_method = io.BytesIO()\n        hopper().save(buffer_method, format=\"WEBP\", method=6)\n        assert buffer_no_args.getbuffer() != buffer_method.getbuffer()\n\n    @skip_unless_feature(\"webp_anim\")\n    def test_save_all(self, tmp_path: Path) -> None:\n        temp_file = str(tmp_path / \"temp.webp\")\n        im = Image.new(\"RGB\", (1, 1))\n        im2 = Image.new(\"RGB\", (1, 1), \"#f00\")\n        im.save(temp_file, save_all=True, append_images=[im2])\n\n        with Image.open(temp_file) as reloaded:\n            assert_image_equal(im, reloaded)\n\n            reloaded.seek(1)\n            assert_image_similar(im2, reloaded, 1)\n\n    def test_icc_profile(self, tmp_path: Path) -> None:\n        self._roundtrip(tmp_path, self.rgb_mode, 12.5, {\"icc_profile\": None})\n        if _webp.HAVE_WEBPANIM:\n            self._roundtrip(\n                tmp_path, self.rgb_mode, 12.5, {\"icc_profile\": None, \"save_all\": True}\n            )\n\n    def test_write_unsupported_mode_L(self, tmp_path: Path) -> None:\n        \"\"\"\n        Saving a black-and-white file to WebP format should work, and be\n        similar to the original file.\n        \"\"\"\n\n        self._roundtrip(tmp_path, \"L\", 10.0)\n\n    def test_write_unsupported_mode_P(self, tmp_path: Path) -> None:\n        \"\"\"\n        Saving a palette-based file to WebP format should work, and be\n        similar to the original file.\n        \"\"\"\n\n        self._roundtrip(tmp_path, \"P\", 50.0)\n\n    @pytest.mark.skipif(sys.maxsize <= 2**32, reason=\"Requires 64-bit system\")\n    def test_write_encoding_error_message(self, tmp_path: Path) -> None:\n        temp_file = str(tmp_path / \"temp.webp\")\n        im = Image.new(\"RGB\", (15000, 15000))\n        with pytest.raises(ValueError) as e:\n            im.save(temp_file, method=0)\n        assert str(e.value) == \"encoding error 6\"\n\n    def test_WebPEncode_with_invalid_args(self) -> None:\n        \"\"\"\n        Calling encoder functions with no arguments should result in an error.\n        \"\"\"\n\n        if _webp.HAVE_WEBPANIM:\n            with pytest.raises(TypeError):\n                _webp.WebPAnimEncoder()\n        with pytest.raises(TypeError):\n            _webp.WebPEncode()\n\n    def test_WebPDecode_with_invalid_args(self) -> None:\n        \"\"\"\n        Calling decoder functions with no arguments should result in an error.\n        \"\"\"\n\n        if _webp.HAVE_WEBPANIM:\n            with pytest.raises(TypeError):\n                _webp.WebPAnimDecoder()\n        with pytest.raises(TypeError):\n            _webp.WebPDecode()\n\n    def test_no_resource_warning(self, tmp_path: Path) -> None:\n        file_path = \"Tests/images/hopper.webp\"\n        with Image.open(file_path) as image:\n            temp_file = str(tmp_path / \"temp.webp\")\n            with warnings.catch_warnings():\n                image.save(temp_file)\n\n    def test_file_pointer_could_be_reused(self) -> None:\n        file_path = \"Tests/images/hopper.webp\"\n        with open(file_path, \"rb\") as blob:\n            Image.open(blob).load()\n            Image.open(blob).load()\n\n    @pytest.mark.parametrize(\n        \"background\",\n        (0, (0,), (-1, 0, 1, 2), (253, 254, 255, 256)),\n    )\n    @skip_unless_feature(\"webp_anim\")\n    def test_invalid_background(\n        self, background: int | tuple[int, ...], tmp_path: Path\n    ) -> None:\n        temp_file = str(tmp_path / \"temp.webp\")\n        im = hopper()\n        with pytest.raises(OSError):\n            im.save(temp_file, save_all=True, append_images=[im], background=background)\n\n    @skip_unless_feature(\"webp_anim\")\n    def test_background_from_gif(self, tmp_path: Path) -> None:\n        # Save L mode GIF with background\n        with Image.open(\"Tests/images/no_palette_with_background.gif\") as im:\n            out_webp = str(tmp_path / \"temp.webp\")\n            im.save(out_webp, save_all=True)\n\n        # Save P mode GIF with background\n        with Image.open(\"Tests/images/chi.gif\") as im:\n            original_value = im.convert(\"RGB\").getpixel((1, 1))\n\n            # Save as WEBP\n            out_webp = str(tmp_path / \"temp.webp\")\n            im.save(out_webp, save_all=True)\n\n        # Save as GIF\n        out_gif = str(tmp_path / \"temp.gif\")\n        with Image.open(out_webp) as im:\n            im.save(out_gif)\n\n        with Image.open(out_gif) as reread:\n            reread_value = reread.convert(\"RGB\").getpixel((1, 1))\n        difference = sum(abs(original_value[i] - reread_value[i]) for i in range(0, 3))\n        assert difference < 5\n\n    @skip_unless_feature(\"webp_anim\")\n    def test_duration(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/dispose_bgnd.gif\") as im:\n            assert im.info[\"duration\"] == 1000\n\n            out_webp = str(tmp_path / \"temp.webp\")\n            im.save(out_webp, save_all=True)\n\n        with Image.open(out_webp) as reloaded:\n            reloaded.load()\n            assert reloaded.info[\"duration\"] == 1000\n\n    def test_roundtrip_rgba_palette(self, tmp_path: Path) -> None:\n        temp_file = str(tmp_path / \"temp.webp\")\n        im = Image.new(\"RGBA\", (1, 1)).convert(\"P\")\n        assert im.mode == \"P\"\n        assert im.palette.mode == \"RGBA\"\n        im.save(temp_file)\n\n        with Image.open(temp_file) as im:\n            assert im.getpixel((0, 0)) == (0, 0, 0, 0)\n", "Tests/test_file_ftex.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import FtexImagePlugin, Image\n\nfrom .helper import assert_image_equal_tofile, assert_image_similar\n\n\ndef test_load_raw() -> None:\n    with Image.open(\"Tests/images/ftex_uncompressed.ftu\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/ftex_uncompressed.png\")\n\n\ndef test_load_dxt1() -> None:\n    with Image.open(\"Tests/images/ftex_dxt1.ftc\") as im:\n        with Image.open(\"Tests/images/ftex_dxt1.png\") as target:\n            assert_image_similar(im, target.convert(\"RGBA\"), 15)\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        FtexImagePlugin.FtexImageFile(invalid_file)\n", "Tests/test_file_gribstub.py": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import IO\n\nimport pytest\n\nfrom PIL import GribStubImagePlugin, Image, ImageFile\n\nfrom .helper import hopper\n\nTEST_FILE = \"Tests/images/WAlaska.wind.7days.grb\"\n\n\ndef test_open() -> None:\n    # Act\n    with Image.open(TEST_FILE) as im:\n        # Assert\n        assert im.format == \"GRIB\"\n\n        # Dummy data from the stub\n        assert im.mode == \"F\"\n        assert im.size == (1, 1)\n\n\ndef test_invalid_file() -> None:\n    # Arrange\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        GribStubImagePlugin.GribStubImageFile(invalid_file)\n\n\ndef test_load() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        # Act / Assert: stub cannot load without an implemented handler\n        with pytest.raises(OSError):\n            im.load()\n\n\ndef test_save(tmp_path: Path) -> None:\n    # Arrange\n    im = hopper()\n    tmpfile = str(tmp_path / \"temp.grib\")\n\n    # Act / Assert: stub cannot save without an implemented handler\n    with pytest.raises(OSError):\n        im.save(tmpfile)\n\n\ndef test_handler(tmp_path: Path) -> None:\n    class TestHandler(ImageFile.StubHandler):\n        opened = False\n        loaded = False\n        saved = False\n\n        def open(self, im: Image.Image) -> None:\n            self.opened = True\n\n        def load(self, im: Image.Image) -> Image.Image:\n            self.loaded = True\n            im.fp.close()\n            return Image.new(\"RGB\", (1, 1))\n\n        def is_loaded(self) -> bool:\n            return self.loaded\n\n        def save(self, im: Image.Image, fp: IO[bytes], filename: str) -> None:\n            self.saved = True\n\n    handler = TestHandler()\n    GribStubImagePlugin.register_handler(handler)\n    with Image.open(TEST_FILE) as im:\n        assert handler.opened\n        assert not handler.is_loaded()\n\n        im.load()\n        assert handler.is_loaded()\n\n        temp_file = str(tmp_path / \"temp.grib\")\n        im.save(temp_file)\n        assert handler.saved\n\n    GribStubImagePlugin._handler = None\n", "Tests/test_imagetk.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal, hopper\n\ntry:\n    import tkinter as tk\n\n    from PIL import ImageTk\n\n    dir(ImageTk)\n    HAS_TK = True\nexcept (OSError, ImportError):\n    # Skipped via pytestmark\n    HAS_TK = False\n\nTK_MODES = (\"1\", \"L\", \"P\", \"RGB\", \"RGBA\")\n\n\npytestmark = pytest.mark.skipif(not HAS_TK, reason=\"Tk not installed\")\n\n\ndef setup_module() -> None:\n    try:\n        # setup tk\n        tk.Frame()\n        # root = tk.Tk()\n    except RuntimeError as v:\n        pytest.skip(f\"RuntimeError: {v}\")\n    except tk.TclError as v:\n        pytest.skip(f\"TCL Error: {v}\")\n\n\ndef test_kw() -> None:\n    TEST_JPG = \"Tests/images/hopper.jpg\"\n    TEST_PNG = \"Tests/images/hopper.png\"\n    with Image.open(TEST_JPG) as im1:\n        with Image.open(TEST_PNG) as im2:\n            with open(TEST_PNG, \"rb\") as fp:\n                data = fp.read()\n            kw = {\"file\": TEST_JPG, \"data\": data}\n\n            # Test \"file\"\n            im = ImageTk._get_image_from_kw(kw)\n            assert_image_equal(im, im1)\n\n            # Test \"data\"\n            im = ImageTk._get_image_from_kw(kw)\n            assert_image_equal(im, im2)\n\n    # Test no relevant entry\n    im = ImageTk._get_image_from_kw(kw)\n    assert im is None\n\n\n@pytest.mark.parametrize(\"mode\", TK_MODES)\ndef test_photoimage(mode: str) -> None:\n    # test as image:\n    im = hopper(mode)\n\n    # this should not crash\n    im_tk = ImageTk.PhotoImage(im)\n\n    assert im_tk.width() == im.width\n    assert im_tk.height() == im.height\n\n    reloaded = ImageTk.getimage(im_tk)\n    assert_image_equal(reloaded, im.convert(\"RGBA\"))\n\n\ndef test_photoimage_apply_transparency() -> None:\n    with Image.open(\"Tests/images/pil123p.png\") as im:\n        im_tk = ImageTk.PhotoImage(im)\n        reloaded = ImageTk.getimage(im_tk)\n        assert_image_equal(reloaded, im.convert(\"RGBA\"))\n\n\n@pytest.mark.parametrize(\"mode\", TK_MODES)\ndef test_photoimage_blank(mode: str) -> None:\n    # test a image using mode/size:\n    im_tk = ImageTk.PhotoImage(mode, (100, 100))\n\n    assert im_tk.width() == 100\n    assert im_tk.height() == 100\n\n    im = Image.new(mode, (100, 100))\n    reloaded = ImageTk.getimage(im_tk)\n    assert_image_equal(reloaded.convert(mode), im)\n\n\ndef test_bitmapimage() -> None:\n    im = hopper(\"1\")\n\n    # this should not crash\n    im_tk = ImageTk.BitmapImage(im)\n\n    assert im_tk.width() == im.width\n    assert im_tk.height() == im.height\n\n    # reloaded = ImageTk.getimage(im_tk)\n    # assert_image_equal(reloaded, im)\n", "Tests/test_file_gd.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import GdImageFile, UnidentifiedImageError\n\nTEST_GD_FILE = \"Tests/images/hopper.gd\"\n\n\ndef test_sanity() -> None:\n    with GdImageFile.open(TEST_GD_FILE) as im:\n        assert im.size == (128, 128)\n        assert im.format == \"GD\"\n\n\ndef test_bad_mode() -> None:\n    with pytest.raises(ValueError):\n        GdImageFile.open(TEST_GD_FILE, \"bad mode\")\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(UnidentifiedImageError):\n        GdImageFile.open(invalid_file)\n", "Tests/test_format_lab.py": "from __future__ import annotations\n\nfrom PIL import Image\n\n\ndef test_white() -> None:\n    with Image.open(\"Tests/images/lab.tif\") as i:\n        i.load()\n\n        assert i.mode == \"LAB\"\n\n        assert i.getbands() == (\"L\", \"A\", \"B\")\n\n        k = i.getpixel((0, 0))\n\n        L = i.getdata(0)\n        a = i.getdata(1)\n        b = i.getdata(2)\n\n    assert k == (255, 128, 128)\n\n    assert list(L) == [255] * 100\n    assert list(a) == [128] * 100\n    assert list(b) == [128] * 100\n\n\ndef test_green() -> None:\n    # l= 50 (/100), a = -100 (-128 .. 128) b=0 in PS\n    # == RGB: 0, 152, 117\n    with Image.open(\"Tests/images/lab-green.tif\") as i:\n        k = i.getpixel((0, 0))\n    assert k == (128, 28, 128)\n\n\ndef test_red() -> None:\n    # l= 50 (/100), a = 100 (-128 .. 128) b=0 in PS\n    # == RGB: 255, 0, 124\n    with Image.open(\"Tests/images/lab-red.tif\") as i:\n        k = i.getpixel((0, 0))\n    assert k == (128, 228, 128)\n", "Tests/test_imagemath_lambda_eval.py": "from __future__ import annotations\n\nfrom PIL import Image, ImageMath\n\n\ndef pixel(im: Image.Image | int) -> str | int:\n    if isinstance(im, int):\n        return int(im)  # hack to deal with booleans\n\n    return f\"{im.mode} {repr(im.getpixel((0, 0)))}\"\n\n\nA = Image.new(\"L\", (1, 1), 1)\nB = Image.new(\"L\", (1, 1), 2)\nZ = Image.new(\"L\", (1, 1), 0)  # Z for zero\nF = Image.new(\"F\", (1, 1), 3)\nI = Image.new(\"I\", (1, 1), 4)  # noqa: E741\n\nA2 = A.resize((2, 2))\nB2 = B.resize((2, 2))\n\nimages = {\"A\": A, \"B\": B, \"F\": F, \"I\": I}\n\n\ndef test_sanity() -> None:\n    assert ImageMath.lambda_eval(lambda args: 1) == 1\n    assert ImageMath.lambda_eval(lambda args: 1 + args[\"A\"], A=2) == 3\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] + args[\"B\"], A=A, B=B))\n        == \"I 3\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] + args[\"B\"], images))\n        == \"I 3\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"float\"](args[\"A\"]) + args[\"B\"], images\n            )\n        )\n        == \"F 3.0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"int\"](args[\"float\"](args[\"A\"]) + args[\"B\"]), images\n            )\n        )\n        == \"I 3\"\n    )\n\n\ndef test_ops() -> None:\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] * -1, images)) == \"I -1\"\n\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] + args[\"B\"], images))\n        == \"I 3\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] - args[\"B\"], images))\n        == \"I -1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] * args[\"B\"], images))\n        == \"I 2\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] / args[\"B\"], images))\n        == \"I 0\"\n    )\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] ** 2, images)) == \"I 4\"\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] ** 33, images))\n        == \"I 2147483647\"\n    )\n\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"float\"](args[\"A\"]) + args[\"B\"], images\n            )\n        )\n        == \"F 3.0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"float\"](args[\"A\"]) - args[\"B\"], images\n            )\n        )\n        == \"F -1.0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"float\"](args[\"A\"]) * args[\"B\"], images\n            )\n        )\n        == \"F 2.0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"float\"](args[\"A\"]) / args[\"B\"], images\n            )\n        )\n        == \"F 0.5\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"float\"](args[\"B\"]) ** 2, images))\n        == \"F 4.0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(lambda args: args[\"float\"](args[\"B\"]) ** 33, images)\n        )\n        == \"F 8589934592.0\"\n    )\n\n\ndef test_logical() -> None:\n    assert pixel(ImageMath.lambda_eval(lambda args: not args[\"A\"], images)) == 0\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] and args[\"B\"], images))\n        == \"L 2\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] or args[\"B\"], images))\n        == \"L 1\"\n    )\n\n\ndef test_convert() -> None:\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"convert\"](args[\"A\"] + args[\"B\"], \"L\"), images\n            )\n        )\n        == \"L 3\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"convert\"](args[\"A\"] + args[\"B\"], \"1\"), images\n            )\n        )\n        == \"1 0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"convert\"](args[\"A\"] + args[\"B\"], \"RGB\"), images\n            )\n        )\n        == \"RGB (3, 3, 3)\"\n    )\n\n\ndef test_compare() -> None:\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"min\"](args[\"A\"], args[\"B\"]), images\n            )\n        )\n        == \"I 1\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"max\"](args[\"A\"], args[\"B\"]), images\n            )\n        )\n        == \"I 2\"\n    )\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] == 1, images)) == \"I 1\"\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] == 2, images)) == \"I 0\"\n\n\ndef test_one_image_larger() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] + args[\"B\"], A=A2, B=B))\n        == \"I 3\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] + args[\"B\"], A=A, B=B2))\n        == \"I 3\"\n    )\n\n\ndef test_abs() -> None:\n    assert pixel(ImageMath.lambda_eval(lambda args: abs(args[\"A\"]), A=A)) == \"I 1\"\n    assert pixel(ImageMath.lambda_eval(lambda args: abs(args[\"B\"]), B=B)) == \"I 2\"\n\n\ndef test_binary_mod() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] % args[\"A\"], A=A)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] % args[\"B\"], B=B)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] % args[\"B\"], A=A, B=B))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] % args[\"A\"], A=A, B=B))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] % args[\"A\"], A=A, Z=Z))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] % args[\"B\"], B=B, Z=Z))\n        == \"I 0\"\n    )\n\n\ndef test_bitwise_invert() -> None:\n    assert pixel(ImageMath.lambda_eval(lambda args: ~args[\"Z\"], Z=Z)) == \"I -1\"\n    assert pixel(ImageMath.lambda_eval(lambda args: ~args[\"A\"], A=A)) == \"I -2\"\n    assert pixel(ImageMath.lambda_eval(lambda args: ~args[\"B\"], B=B)) == \"I -3\"\n\n\ndef test_bitwise_and() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] & args[\"Z\"], A=A, Z=Z))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] & args[\"A\"], A=A, Z=Z))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] & args[\"Z\"], A=A, Z=Z))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] & args[\"A\"], A=A, Z=Z))\n        == \"I 1\"\n    )\n\n\ndef test_bitwise_or() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] | args[\"Z\"], A=A, Z=Z))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] | args[\"A\"], A=A, Z=Z))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] | args[\"Z\"], A=A, Z=Z))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] | args[\"A\"], A=A, Z=Z))\n        == \"I 1\"\n    )\n\n\ndef test_bitwise_xor() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] ^ args[\"Z\"], A=A, Z=Z))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] ^ args[\"A\"], A=A, Z=Z))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] ^ args[\"Z\"], A=A, Z=Z))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] ^ args[\"A\"], A=A, Z=Z))\n        == \"I 0\"\n    )\n\n\ndef test_bitwise_leftshift() -> None:\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] << 0, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] << 1, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] << 0, A=A)) == \"I 1\"\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] << 1, A=A)) == \"I 2\"\n\n\ndef test_bitwise_rightshift() -> None:\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] >> 0, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"Z\"] >> 1, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] >> 0, A=A)) == \"I 1\"\n    assert pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] >> 1, A=A)) == \"I 0\"\n\n\ndef test_logical_eq() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] == args[\"A\"], A=A)) == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] == args[\"B\"], B=B)) == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] == args[\"B\"], A=A, B=B))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] == args[\"A\"], A=A, B=B))\n        == \"I 0\"\n    )\n\n\ndef test_logical_ne() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] != args[\"A\"], A=A)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] != args[\"B\"], B=B)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] != args[\"B\"], A=A, B=B))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] != args[\"A\"], A=A, B=B))\n        == \"I 1\"\n    )\n\n\ndef test_logical_lt() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] < args[\"A\"], A=A)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] < args[\"B\"], B=B)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] < args[\"B\"], A=A, B=B))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] < args[\"A\"], A=A, B=B))\n        == \"I 0\"\n    )\n\n\ndef test_logical_le() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] <= args[\"A\"], A=A)) == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] <= args[\"B\"], B=B)) == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] <= args[\"B\"], A=A, B=B))\n        == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] <= args[\"A\"], A=A, B=B))\n        == \"I 0\"\n    )\n\n\ndef test_logical_gt() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] > args[\"A\"], A=A)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] > args[\"B\"], B=B)) == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] > args[\"B\"], A=A, B=B))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] > args[\"A\"], A=A, B=B))\n        == \"I 1\"\n    )\n\n\ndef test_logical_ge() -> None:\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] >= args[\"A\"], A=A)) == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] >= args[\"B\"], B=B)) == \"I 1\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"A\"] >= args[\"B\"], A=A, B=B))\n        == \"I 0\"\n    )\n    assert (\n        pixel(ImageMath.lambda_eval(lambda args: args[\"B\"] >= args[\"A\"], A=A, B=B))\n        == \"I 1\"\n    )\n\n\ndef test_logical_equal() -> None:\n    assert (\n        pixel(\n            ImageMath.lambda_eval(lambda args: args[\"equal\"](args[\"A\"], args[\"A\"]), A=A)\n        )\n        == \"I 1\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(lambda args: args[\"equal\"](args[\"B\"], args[\"B\"]), B=B)\n        )\n        == \"I 1\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(lambda args: args[\"equal\"](args[\"Z\"], args[\"Z\"]), Z=Z)\n        )\n        == \"I 1\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"equal\"](args[\"A\"], args[\"B\"]), A=A, B=B\n            )\n        )\n        == \"I 0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"equal\"](args[\"B\"], args[\"A\"]), A=A, B=B\n            )\n        )\n        == \"I 0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"equal\"](args[\"A\"], args[\"Z\"]), A=A, Z=Z\n            )\n        )\n        == \"I 0\"\n    )\n\n\ndef test_logical_not_equal() -> None:\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"notequal\"](args[\"A\"], args[\"A\"]), A=A\n            )\n        )\n        == \"I 0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"notequal\"](args[\"B\"], args[\"B\"]), B=B\n            )\n        )\n        == \"I 0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"notequal\"](args[\"Z\"], args[\"Z\"]), Z=Z\n            )\n        )\n        == \"I 0\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"notequal\"](args[\"A\"], args[\"B\"]), A=A, B=B\n            )\n        )\n        == \"I 1\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"notequal\"](args[\"B\"], args[\"A\"]), A=A, B=B\n            )\n        )\n        == \"I 1\"\n    )\n    assert (\n        pixel(\n            ImageMath.lambda_eval(\n                lambda args: args[\"notequal\"](args[\"A\"], args[\"Z\"]), A=A, Z=Z\n            )\n        )\n        == \"I 1\"\n    )\n", "Tests/test_file_xbm.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, XbmImagePlugin\n\nfrom .helper import hopper\n\nPIL151 = b\"\"\"\n#define basic_width 32\n#define basic_height 32\nstatic char basic_bits[] = {\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n0x80, 0xff, 0xff, 0x01, 0x40, 0x00, 0x00, 0x02,\n0x20, 0x00, 0x00, 0x04, 0x20, 0x00, 0x00, 0x04, 0x10, 0x00, 0x00, 0x08,\n0x10, 0x00, 0x00, 0x08,\n0x10, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x08,\n0x10, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x08, 0x10, 0x00, 0x00, 0x08,\n0x20, 0x00, 0x00, 0x04,\n0x20, 0x00, 0x00, 0x04, 0x40, 0x00, 0x00, 0x02,\n0x80, 0xff, 0xff, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n0x00, 0x00, 0x00, 0x00,\n};\n\"\"\"\n\n\ndef test_pil151() -> None:\n    with Image.open(BytesIO(PIL151)) as im:\n        im.load()\n        assert im.mode == \"1\"\n        assert im.size == (32, 32)\n\n\ndef test_open() -> None:\n    # Arrange\n    # Created with `convert hopper.png hopper.xbm`\n    filename = \"Tests/images/hopper.xbm\"\n\n    # Act\n    with Image.open(filename) as im:\n        # Assert\n        assert im.mode == \"1\"\n        assert im.size == (128, 128)\n\n\ndef test_open_filename_with_underscore() -> None:\n    # Arrange\n    # Created with `convert hopper.png hopper_underscore.xbm`\n    filename = \"Tests/images/hopper_underscore.xbm\"\n\n    # Act\n    with Image.open(filename) as im:\n        # Assert\n        assert im.mode == \"1\"\n        assert im.size == (128, 128)\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        XbmImagePlugin.XbmImageFile(invalid_file)\n\n\ndef test_save_wrong_mode(tmp_path: Path) -> None:\n    im = hopper()\n    out = str(tmp_path / \"temp.xbm\")\n\n    with pytest.raises(OSError):\n        im.save(out)\n\n\ndef test_hotspot(tmp_path: Path) -> None:\n    im = hopper(\"1\")\n    out = str(tmp_path / \"temp.xbm\")\n\n    hotspot = (0, 7)\n    im.save(out, hotspot=hotspot)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.info[\"hotspot\"] == hotspot\n", "Tests/test_file_gimppalette.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL.GimpPaletteFile import GimpPaletteFile\n\n\ndef test_sanity() -> None:\n    with open(\"Tests/images/test.gpl\", \"rb\") as fp:\n        GimpPaletteFile(fp)\n\n    with open(\"Tests/images/hopper.jpg\", \"rb\") as fp:\n        with pytest.raises(SyntaxError):\n            GimpPaletteFile(fp)\n\n    with open(\"Tests/images/bad_palette_file.gpl\", \"rb\") as fp:\n        with pytest.raises(SyntaxError):\n            GimpPaletteFile(fp)\n\n    with open(\"Tests/images/bad_palette_entry.gpl\", \"rb\") as fp:\n        with pytest.raises(ValueError):\n            GimpPaletteFile(fp)\n\n\ndef test_get_palette() -> None:\n    # Arrange\n    with open(\"Tests/images/custom_gimp_palette.gpl\", \"rb\") as fp:\n        palette_file = GimpPaletteFile(fp)\n\n    # Act\n    palette, mode = palette_file.getpalette()\n\n    # Assert\n    assert mode == \"RGB\"\n", "Tests/test_image_mode.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageMode\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    with hopper() as im:\n        im.mode\n\n    ImageMode.getmode(\"1\")\n    ImageMode.getmode(\"L\")\n    ImageMode.getmode(\"P\")\n    ImageMode.getmode(\"RGB\")\n    ImageMode.getmode(\"I\")\n    ImageMode.getmode(\"F\")\n\n    m = ImageMode.getmode(\"1\")\n    assert m.mode == \"1\"\n    assert str(m) == \"1\"\n    assert m.bands == (\"1\",)\n    assert m.basemode == \"L\"\n    assert m.basetype == \"L\"\n    assert m.typestr == \"|b1\"\n\n    for mode in (\n        \"I;16\",\n        \"I;16S\",\n        \"I;16L\",\n        \"I;16LS\",\n        \"I;16B\",\n        \"I;16BS\",\n        \"I;16N\",\n        \"I;16NS\",\n    ):\n        m = ImageMode.getmode(mode)\n        assert m.mode == mode\n        assert str(m) == mode\n        assert m.bands == (\"I\",)\n        assert m.basemode == \"L\"\n        assert m.basetype == \"L\"\n\n    m = ImageMode.getmode(\"RGB\")\n    assert m.mode == \"RGB\"\n    assert str(m) == \"RGB\"\n    assert m.bands == (\"R\", \"G\", \"B\")\n    assert m.basemode == \"RGB\"\n    assert m.basetype == \"L\"\n    assert m.typestr == \"|u1\"\n\n\n@pytest.mark.parametrize(\n    \"mode, expected_base, expected_type, expected_bands, expected_band_names\",\n    (\n        (\"1\", \"L\", \"L\", 1, (\"1\",)),\n        (\"L\", \"L\", \"L\", 1, (\"L\",)),\n        (\"P\", \"P\", \"L\", 1, (\"P\",)),\n        (\"I\", \"L\", \"I\", 1, (\"I\",)),\n        (\"F\", \"L\", \"F\", 1, (\"F\",)),\n        (\"RGB\", \"RGB\", \"L\", 3, (\"R\", \"G\", \"B\")),\n        (\"RGBA\", \"RGB\", \"L\", 4, (\"R\", \"G\", \"B\", \"A\")),\n        (\"RGBX\", \"RGB\", \"L\", 4, (\"R\", \"G\", \"B\", \"X\")),\n        (\"CMYK\", \"RGB\", \"L\", 4, (\"C\", \"M\", \"Y\", \"K\")),\n        (\"YCbCr\", \"RGB\", \"L\", 3, (\"Y\", \"Cb\", \"Cr\")),\n    ),\n)\ndef test_properties(\n    mode: str,\n    expected_base: str,\n    expected_type: str,\n    expected_bands: int,\n    expected_band_names: tuple[str, ...],\n) -> None:\n    assert Image.getmodebase(mode) == expected_base\n    assert Image.getmodetype(mode) == expected_type\n    assert Image.getmodebands(mode) == expected_bands\n    assert Image.getmodebandnames(mode) == expected_band_names\n", "Tests/test_image_tobytes.py": "from __future__ import annotations\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    data = hopper().tobytes()\n    assert isinstance(data, bytes)\n", "Tests/test_file_libtiff.py": "from __future__ import annotations\n\nimport base64\nimport io\nimport itertools\nimport os\nimport re\nimport sys\nfrom pathlib import Path\nfrom typing import Any, NamedTuple\n\nimport pytest\n\nfrom PIL import Image, ImageFilter, ImageOps, TiffImagePlugin, TiffTags, features\nfrom PIL.TiffImagePlugin import OSUBFILETYPE, SAMPLEFORMAT, STRIPOFFSETS, SUBIFD\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    hopper,\n    mark_if_feature_version,\n    skip_unless_feature,\n)\n\n\n@skip_unless_feature(\"libtiff\")\nclass LibTiffTestCase:\n    def _assert_noerr(self, tmp_path: Path, im: TiffImagePlugin.TiffImageFile) -> None:\n        \"\"\"Helper tests that assert basic sanity about the g4 tiff reading\"\"\"\n        # 1 bit\n        assert im.mode == \"1\"\n\n        # Does the data actually load\n        im.load()\n        im.getdata()\n\n        try:\n            assert im._compression == \"group4\"\n        except AttributeError:\n            print(\"No _compression\")\n            print(dir(im))\n\n        # can we write it back out, in a different form.\n        out = str(tmp_path / \"temp.png\")\n        im.save(out)\n\n        out_bytes = io.BytesIO()\n        im.save(out_bytes, format=\"tiff\", compression=\"group4\")\n\n\nclass TestFileLibTiff(LibTiffTestCase):\n    def test_version(self) -> None:\n        version = features.version_codec(\"libtiff\")\n        assert version is not None\n        assert re.search(r\"\\d+\\.\\d+\\.\\d+t?$\", version)\n\n    def test_g4_tiff(self, tmp_path: Path) -> None:\n        \"\"\"Test the ordinary file path load path\"\"\"\n\n        test_file = \"Tests/images/hopper_g4_500.tif\"\n        with Image.open(test_file) as im:\n            assert im.size == (500, 500)\n            self._assert_noerr(tmp_path, im)\n\n    def test_g4_large(self, tmp_path: Path) -> None:\n        test_file = \"Tests/images/pport_g4.tif\"\n        with Image.open(test_file) as im:\n            self._assert_noerr(tmp_path, im)\n\n    def test_g4_tiff_file(self, tmp_path: Path) -> None:\n        \"\"\"Testing the string load path\"\"\"\n\n        test_file = \"Tests/images/hopper_g4_500.tif\"\n        with open(test_file, \"rb\") as f:\n            with Image.open(f) as im:\n                assert im.size == (500, 500)\n                self._assert_noerr(tmp_path, im)\n\n    def test_g4_tiff_bytesio(self, tmp_path: Path) -> None:\n        \"\"\"Testing the stringio loading code path\"\"\"\n        test_file = \"Tests/images/hopper_g4_500.tif\"\n        s = io.BytesIO()\n        with open(test_file, \"rb\") as f:\n            s.write(f.read())\n            s.seek(0)\n        with Image.open(s) as im:\n            assert im.size == (500, 500)\n            self._assert_noerr(tmp_path, im)\n\n    def test_g4_non_disk_file_object(self, tmp_path: Path) -> None:\n        \"\"\"Testing loading from non-disk non-BytesIO file object\"\"\"\n        test_file = \"Tests/images/hopper_g4_500.tif\"\n        s = io.BytesIO()\n        with open(test_file, \"rb\") as f:\n            s.write(f.read())\n            s.seek(0)\n        r = io.BufferedReader(s)\n        with Image.open(r) as im:\n            assert im.size == (500, 500)\n            self._assert_noerr(tmp_path, im)\n\n    def test_g4_eq_png(self) -> None:\n        \"\"\"Checking that we're actually getting the data that we expect\"\"\"\n        with Image.open(\"Tests/images/hopper_bw_500.png\") as png:\n            assert_image_equal_tofile(png, \"Tests/images/hopper_g4_500.tif\")\n\n    # see https://github.com/python-pillow/Pillow/issues/279\n    def test_g4_fillorder_eq_png(self) -> None:\n        \"\"\"Checking that we're actually getting the data that we expect\"\"\"\n        with Image.open(\"Tests/images/g4-fillorder-test.tif\") as g4:\n            assert_image_equal_tofile(g4, \"Tests/images/g4-fillorder-test.png\")\n\n    def test_g4_write(self, tmp_path: Path) -> None:\n        \"\"\"Checking to see that the saved image is the same as what we wrote\"\"\"\n        test_file = \"Tests/images/hopper_g4_500.tif\"\n        with Image.open(test_file) as orig:\n            out = str(tmp_path / \"temp.tif\")\n            rot = orig.transpose(Image.Transpose.ROTATE_90)\n            assert rot.size == (500, 500)\n            rot.save(out)\n\n            with Image.open(out) as reread:\n                assert reread.size == (500, 500)\n                self._assert_noerr(tmp_path, reread)\n                assert_image_equal(reread, rot)\n                assert reread.info[\"compression\"] == \"group4\"\n\n                assert reread.info[\"compression\"] == orig.info[\"compression\"]\n\n                assert orig.tobytes() != reread.tobytes()\n\n    def test_adobe_deflate_tiff(self) -> None:\n        test_file = \"Tests/images/tiff_adobe_deflate.tif\"\n        with Image.open(test_file) as im:\n            assert im.mode == \"RGB\"\n            assert im.size == (278, 374)\n            assert im.tile[0][:3] == (\"libtiff\", (0, 0, 278, 374), 0)\n            im.load()\n\n            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")\n\n    @pytest.mark.parametrize(\"legacy_api\", (False, True))\n    def test_write_metadata(self, legacy_api: bool, tmp_path: Path) -> None:\n        \"\"\"Test metadata writing through libtiff\"\"\"\n        f = str(tmp_path / \"temp.tiff\")\n        with Image.open(\"Tests/images/hopper_g4.tif\") as img:\n            img.save(f, tiffinfo=img.tag)\n\n            if legacy_api:\n                original = img.tag.named()\n            else:\n                original = img.tag_v2.named()\n\n        # PhotometricInterpretation is set from SAVE_INFO,\n        # not the original image.\n        ignored = [\n            \"StripByteCounts\",\n            \"RowsPerStrip\",\n            \"PageNumber\",\n            \"PhotometricInterpretation\",\n        ]\n\n        with Image.open(f) as loaded:\n            if legacy_api:\n                reloaded = loaded.tag.named()\n            else:\n                reloaded = loaded.tag_v2.named()\n\n        for tag, value in itertools.chain(reloaded.items(), original.items()):\n            if tag not in ignored:\n                val = original[tag]\n                if tag.endswith(\"Resolution\"):\n                    if legacy_api:\n                        assert val[0][0] / val[0][1] == (\n                            4294967295 / 113653537\n                        ), f\"{tag} didn't roundtrip\"\n                    else:\n                        assert val == 37.79000115940079, f\"{tag} didn't roundtrip\"\n                else:\n                    assert val == value, f\"{tag} didn't roundtrip\"\n\n        # https://github.com/python-pillow/Pillow/issues/1561\n        requested_fields = [\"StripByteCounts\", \"RowsPerStrip\", \"StripOffsets\"]\n        for field in requested_fields:\n            assert field in reloaded, f\"{field} not in metadata\"\n\n    @pytest.mark.valgrind_known_error(reason=\"Known invalid metadata\")\n    def test_additional_metadata(\n        self, monkeypatch: pytest.MonkeyPatch, tmp_path: Path\n    ) -> None:\n        # these should not crash. Seriously dummy data, most of it doesn't make\n        # any sense, so we're running up against limits where we're asking\n        # libtiff to do stupid things.\n\n        # Get the list of the ones that we should be able to write\n\n        core_items = {\n            tag: info\n            for tag, info in ((s, TiffTags.lookup(s)) for s in TiffTags.LIBTIFF_CORE)\n            if info.type is not None\n        }\n\n        # Exclude ones that have special meaning\n        # that we're already testing them\n        with Image.open(\"Tests/images/hopper_g4.tif\") as im:\n            for tag in im.tag_v2:\n                try:\n                    del core_items[tag]\n                except KeyError:\n                    pass\n            del core_items[320]  # colormap is special, tested below\n\n            # Type codes:\n            #     2: \"ascii\",\n            #     3: \"short\",\n            #     4: \"long\",\n            #     5: \"rational\",\n            #     12: \"double\",\n            # Type: dummy value\n            values = {\n                2: \"test\",\n                3: 1,\n                4: 2**20,\n                5: TiffImagePlugin.IFDRational(100, 1),\n                12: 1.05,\n            }\n\n            new_ifd = TiffImagePlugin.ImageFileDirectory_v2()\n            for tag, info in core_items.items():\n                if info.length == 1:\n                    new_ifd[tag] = values[info.type]\n                if info.length == 0:\n                    new_ifd[tag] = tuple(values[info.type] for _ in range(3))\n                else:\n                    new_ifd[tag] = tuple(values[info.type] for _ in range(info.length))\n\n            # Extra samples really doesn't make sense in this application.\n            del new_ifd[338]\n\n            out = str(tmp_path / \"temp.tif\")\n            monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", True)\n\n            im.save(out, tiffinfo=new_ifd)\n\n    @pytest.mark.parametrize(\n        \"libtiff\",\n        (\n            pytest.param(\n                True,\n                marks=pytest.mark.skipif(\n                    not getattr(Image.core, \"libtiff_support_custom_tags\", False),\n                    reason=\"Custom tags not supported by older libtiff\",\n                ),\n            ),\n            False,\n        ),\n    )\n    def test_custom_metadata(\n        self, monkeypatch: pytest.MonkeyPatch, tmp_path: Path, libtiff: bool\n    ) -> None:\n        monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", libtiff)\n\n        class Tc(NamedTuple):\n            value: Any\n            type: int\n            supported_by_default: bool\n\n        custom = {\n            37000 + k: v\n            for k, v in enumerate(\n                [\n                    Tc(4, TiffTags.SHORT, True),\n                    Tc(123456789, TiffTags.LONG, True),\n                    Tc(-4, TiffTags.SIGNED_BYTE, False),\n                    Tc(-4, TiffTags.SIGNED_SHORT, False),\n                    Tc(-123456789, TiffTags.SIGNED_LONG, False),\n                    Tc(TiffImagePlugin.IFDRational(4, 7), TiffTags.RATIONAL, True),\n                    Tc(4.25, TiffTags.FLOAT, True),\n                    Tc(4.25, TiffTags.DOUBLE, True),\n                    Tc(\"custom tag value\", TiffTags.ASCII, True),\n                    Tc(b\"custom tag value\", TiffTags.BYTE, True),\n                    Tc((4, 5, 6), TiffTags.SHORT, True),\n                    Tc((123456789, 9, 34, 234, 219387, 92432323), TiffTags.LONG, True),\n                    Tc((-4, 9, 10), TiffTags.SIGNED_BYTE, False),\n                    Tc((-4, 5, 6), TiffTags.SIGNED_SHORT, False),\n                    Tc(\n                        (-123456789, 9, 34, 234, 219387, -92432323),\n                        TiffTags.SIGNED_LONG,\n                        False,\n                    ),\n                    Tc((4.25, 5.25), TiffTags.FLOAT, True),\n                    Tc((4.25, 5.25), TiffTags.DOUBLE, True),\n                    # array of TIFF_BYTE requires bytes instead of tuple for backwards\n                    # compatibility\n                    Tc(bytes([4]), TiffTags.BYTE, True),\n                    Tc(bytes((4, 9, 10)), TiffTags.BYTE, True),\n                ]\n            )\n        }\n\n        def check_tags(\n            tiffinfo: TiffImagePlugin.ImageFileDirectory_v2 | dict[int, str]\n        ) -> None:\n            im = hopper()\n\n            out = str(tmp_path / \"temp.tif\")\n            im.save(out, tiffinfo=tiffinfo)\n\n            with Image.open(out) as reloaded:\n                for tag, value in tiffinfo.items():\n                    reloaded_value = reloaded.tag_v2[tag]\n                    if (\n                        isinstance(reloaded_value, TiffImagePlugin.IFDRational)\n                        and libtiff\n                    ):\n                        # libtiff does not support real RATIONALS\n                        assert round(abs(float(reloaded_value) - float(value)), 7) == 0\n                        continue\n\n                    assert reloaded_value == value\n\n        # Test with types\n        ifd = TiffImagePlugin.ImageFileDirectory_v2()\n        for tag, tagdata in custom.items():\n            ifd[tag] = tagdata.value\n            ifd.tagtype[tag] = tagdata.type\n        check_tags(ifd)\n\n        # Test without types. This only works for some types, int for example are\n        # always encoded as LONG and not SIGNED_LONG.\n        check_tags(\n            {\n                tag: tagdata.value\n                for tag, tagdata in custom.items()\n                if tagdata.supported_by_default\n            }\n        )\n\n    def test_osubfiletype(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/g4_orientation_6.tif\") as im:\n            im.tag_v2[OSUBFILETYPE] = 1\n            im.save(outfile)\n\n    def test_subifd(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/g4_orientation_6.tif\") as im:\n            im.tag_v2[SUBIFD] = 10000\n\n            # Should not segfault\n            im.save(outfile)\n\n    def test_xmlpacket_tag(\n        self, monkeypatch: pytest.MonkeyPatch, tmp_path: Path\n    ) -> None:\n        monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", True)\n\n        out = str(tmp_path / \"temp.tif\")\n        hopper().save(out, tiffinfo={700: b\"xmlpacket tag\"})\n\n        with Image.open(out) as reloaded:\n            if 700 in reloaded.tag_v2:\n                assert reloaded.tag_v2[700] == b\"xmlpacket tag\"\n\n    def test_int_dpi(self, monkeypatch: pytest.MonkeyPatch, tmp_path: Path) -> None:\n        # issue #1765\n        im = hopper(\"RGB\")\n        out = str(tmp_path / \"temp.tif\")\n        monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", True)\n        im.save(out, dpi=(72, 72))\n        with Image.open(out) as reloaded:\n            assert reloaded.info[\"dpi\"] == (72.0, 72.0)\n\n    def test_g3_compression(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/hopper_g4_500.tif\") as i:\n            out = str(tmp_path / \"temp.tif\")\n            i.save(out, compression=\"group3\")\n\n            with Image.open(out) as reread:\n                assert reread.info[\"compression\"] == \"group3\"\n                assert_image_equal(reread, i)\n\n    def test_little_endian(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/16bit.deflate.tif\") as im:\n            assert im.getpixel((0, 0)) == 480\n            assert im.mode == \"I;16\"\n\n            b = im.tobytes()\n            # Bytes are in image native order (little endian)\n            assert b[0] == ord(b\"\\xe0\")\n            assert b[1] == ord(b\"\\x01\")\n\n            out = str(tmp_path / \"temp.tif\")\n            # out = \"temp.le.tif\"\n            im.save(out)\n        with Image.open(out) as reread:\n            assert reread.info[\"compression\"] == im.info[\"compression\"]\n            assert reread.getpixel((0, 0)) == 480\n        # UNDONE - libtiff defaults to writing in native endian, so\n        # on big endian, we'll get back mode = 'I;16B' here.\n\n    def test_big_endian(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/16bit.MM.deflate.tif\") as im:\n            assert im.getpixel((0, 0)) == 480\n            assert im.mode == \"I;16B\"\n\n            b = im.tobytes()\n\n            # Bytes are in image native order (big endian)\n            assert b[0] == ord(b\"\\x01\")\n            assert b[1] == ord(b\"\\xe0\")\n\n            out = str(tmp_path / \"temp.tif\")\n            im.save(out)\n            with Image.open(out) as reread:\n                assert reread.info[\"compression\"] == im.info[\"compression\"]\n                assert reread.getpixel((0, 0)) == 480\n\n    def test_g4_string_info(self, tmp_path: Path) -> None:\n        \"\"\"Tests String data in info directory\"\"\"\n        test_file = \"Tests/images/hopper_g4_500.tif\"\n        with Image.open(test_file) as orig:\n            out = str(tmp_path / \"temp.tif\")\n\n            orig.tag[269] = \"temp.tif\"\n            orig.save(out)\n\n        with Image.open(out) as reread:\n            assert \"temp.tif\" == reread.tag_v2[269]\n            assert \"temp.tif\" == reread.tag[269][0]\n\n    def test_12bit_rawmode(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        \"\"\"Are we generating the same interpretation\n        of the image as Imagemagick is?\"\"\"\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(\"Tests/images/12bit.cropped.tif\") as im:\n            im.load()\n            monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", False)\n            # to make the target --\n            # convert 12bit.cropped.tif -depth 16 tmp.tif\n            # convert tmp.tif -evaluate RightShift 4 12in16bit2.tif\n            # imagemagick will auto scale so that a 12bit FFF is 16bit FFF0,\n            # so we need to unshift so that the integer values are the same.\n\n            assert_image_equal_tofile(im, \"Tests/images/12in16bit.tif\")\n\n    def test_blur(self, tmp_path: Path) -> None:\n        # test case from irc, how to do blur on b/w image\n        # and save to compressed tif.\n        out = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/pport_g4.tif\") as im:\n            im = im.convert(\"L\")\n\n        im = im.filter(ImageFilter.GaussianBlur(4))\n        im.save(out, compression=\"tiff_adobe_deflate\")\n\n        assert_image_equal_tofile(im, out)\n\n    def test_compressions(self, tmp_path: Path) -> None:\n        # Test various tiff compressions and assert similar image content but reduced\n        # file sizes.\n        im = hopper(\"RGB\")\n        out = str(tmp_path / \"temp.tif\")\n        im.save(out)\n        size_raw = os.path.getsize(out)\n\n        for compression in (\"packbits\", \"tiff_lzw\"):\n            im.save(out, compression=compression)\n            size_compressed = os.path.getsize(out)\n            assert_image_equal_tofile(im, out)\n\n        im.save(out, compression=\"jpeg\")\n        size_jpeg = os.path.getsize(out)\n        with Image.open(out) as im2:\n            assert_image_similar(im, im2, 30)\n\n        im.save(out, compression=\"jpeg\", quality=30)\n        size_jpeg_30 = os.path.getsize(out)\n        assert_image_similar_tofile(im2, out, 30)\n\n        assert size_raw > size_compressed\n        assert size_compressed > size_jpeg\n        assert size_jpeg > size_jpeg_30\n\n    def test_tiff_jpeg_compression(self, tmp_path: Path) -> None:\n        im = hopper(\"RGB\")\n        out = str(tmp_path / \"temp.tif\")\n        im.save(out, compression=\"tiff_jpeg\")\n\n        with Image.open(out) as reloaded:\n            assert reloaded.info[\"compression\"] == \"jpeg\"\n\n    def test_tiff_deflate_compression(self, tmp_path: Path) -> None:\n        im = hopper(\"RGB\")\n        out = str(tmp_path / \"temp.tif\")\n        im.save(out, compression=\"tiff_deflate\")\n\n        with Image.open(out) as reloaded:\n            assert reloaded.info[\"compression\"] == \"tiff_adobe_deflate\"\n\n    def test_quality(self, tmp_path: Path) -> None:\n        im = hopper(\"RGB\")\n        out = str(tmp_path / \"temp.tif\")\n\n        with pytest.raises(ValueError):\n            im.save(out, compression=\"tiff_lzw\", quality=50)\n        with pytest.raises(ValueError):\n            im.save(out, compression=\"jpeg\", quality=-1)\n        with pytest.raises(ValueError):\n            im.save(out, compression=\"jpeg\", quality=101)\n        with pytest.raises(ValueError):\n            im.save(out, compression=\"jpeg\", quality=\"good\")\n        im.save(out, compression=\"jpeg\", quality=0)\n        im.save(out, compression=\"jpeg\", quality=100)\n\n    def test_cmyk_save(self, tmp_path: Path) -> None:\n        im = hopper(\"CMYK\")\n        out = str(tmp_path / \"temp.tif\")\n\n        im.save(out, compression=\"tiff_adobe_deflate\")\n        assert_image_equal_tofile(im, out)\n\n    @pytest.mark.parametrize(\"im\", (hopper(\"P\"), Image.new(\"P\", (1, 1), \"#000\")))\n    def test_palette_save(\n        self, im: Image.Image, monkeypatch: pytest.MonkeyPatch, tmp_path: Path\n    ) -> None:\n        out = str(tmp_path / \"temp.tif\")\n\n        monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", True)\n        im.save(out)\n\n        with Image.open(out) as reloaded:\n            # colormap/palette tag\n            assert len(reloaded.tag_v2[320]) == 768\n\n    @pytest.mark.parametrize(\"compression\", (\"tiff_ccitt\", \"group3\", \"group4\"))\n    def test_bw_compression_w_rgb(self, compression: str, tmp_path: Path) -> None:\n        im = hopper(\"RGB\")\n        out = str(tmp_path / \"temp.tif\")\n\n        with pytest.raises(OSError):\n            im.save(out, compression=compression)\n\n    def test_fp_leak(self) -> None:\n        im: Image.Image | None = Image.open(\"Tests/images/hopper_g4_500.tif\")\n        assert im is not None\n        fn = im.fp.fileno()\n\n        os.fstat(fn)\n        im.load()  # this should close it.\n        with pytest.raises(OSError):\n            os.fstat(fn)\n        im = None  # this should force even more closed.\n        with pytest.raises(OSError):\n            os.fstat(fn)\n        with pytest.raises(OSError):\n            os.close(fn)\n\n    def test_multipage(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        # issue #862\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(\"Tests/images/multipage.tiff\") as im:\n            # file is a multipage tiff,  10x10 green, 10x10 red, 20x20 blue\n\n            im.seek(0)\n            assert im.size == (10, 10)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)\n            assert im.tag.next\n\n            im.seek(1)\n            assert im.size == (10, 10)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (255, 0, 0)\n            assert im.tag.next\n\n            im.seek(2)\n            assert not im.tag.next\n            assert im.size == (20, 20)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 255)\n\n    def test_multipage_nframes(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        # issue #862\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(\"Tests/images/multipage.tiff\") as im:\n            frames = im.n_frames\n            assert frames == 3\n            for _ in range(frames):\n                im.seek(0)\n                # Should not raise ValueError: I/O operation on closed file\n                im.load()\n\n    def test_multipage_seek_backwards(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(\"Tests/images/multipage.tiff\") as im:\n            im.seek(1)\n            im.load()\n\n            im.seek(0)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)\n\n    def test__next(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(\"Tests/images/hopper.tif\") as im:\n            assert not im.tag.next\n            im.load()\n            assert not im.tag.next\n\n    def test_4bit(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        # Arrange\n        test_file = \"Tests/images/hopper_gray_4bpp.tif\"\n        original = hopper(\"L\")\n\n        # Act\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(test_file) as im:\n\n            # Assert\n            assert im.size == (128, 128)\n            assert im.mode == \"L\"\n            assert_image_similar(im, original, 7.3)\n\n    def test_gray_semibyte_per_pixel(self) -> None:\n        test_files = (\n            (\n                24.8,  # epsilon\n                (  # group\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2I.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2R.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2IR.tif\",\n                ),\n            ),\n            (\n                7.3,  # epsilon\n                (  # group\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4I.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4R.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4IR.tif\",\n                ),\n            ),\n        )\n        original = hopper(\"L\")\n        for epsilon, group in test_files:\n            with Image.open(group[0]) as im:\n                assert im.size == (128, 128)\n                assert im.mode == \"L\"\n                assert_image_similar(im, original, epsilon)\n            for file in group[1:]:\n                with Image.open(file) as im2:\n                    assert im2.size == (128, 128)\n                    assert im2.mode == \"L\"\n                    assert_image_equal(im, im2)\n\n    def test_save_bytesio(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        # PR 1011\n        # Test TIFF saving to io.BytesIO() object.\n\n        monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", True)\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n\n        # Generate test image\n        pilim = hopper()\n\n        def save_bytesio(compression: str | None = None) -> None:\n            buffer_io = io.BytesIO()\n            pilim.save(buffer_io, format=\"tiff\", compression=compression)\n            buffer_io.seek(0)\n\n            with Image.open(buffer_io) as saved_im:\n                assert_image_similar(pilim, saved_im, 0)\n\n        save_bytesio()\n        save_bytesio(\"raw\")\n        save_bytesio(\"packbits\")\n        save_bytesio(\"tiff_lzw\")\n\n    def test_save_ycbcr(self, tmp_path: Path) -> None:\n        im = hopper(\"YCbCr\")\n        outfile = str(tmp_path / \"temp.tif\")\n        im.save(outfile, compression=\"jpeg\")\n\n        with Image.open(outfile) as reloaded:\n            assert reloaded.tag_v2[530] == (1, 1)\n            assert reloaded.tag_v2[532] == (0, 255, 128, 255, 128, 255)\n\n    def test_exif_ifd(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/tiff_adobe_deflate.tif\") as im:\n            assert im.tag_v2[34665] == 125456\n            im.save(outfile)\n\n        with Image.open(outfile) as reloaded:\n            if Image.core.libtiff_support_custom_tags:\n                assert reloaded.tag_v2[34665] == 125456\n\n    def test_crashing_metadata(\n        self, monkeypatch: pytest.MonkeyPatch, tmp_path: Path\n    ) -> None:\n        # issue 1597\n        with Image.open(\"Tests/images/rdf.tif\") as im:\n            out = str(tmp_path / \"temp.tif\")\n\n            monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", True)\n            # this shouldn't crash\n            im.save(out, format=\"TIFF\")\n\n    def test_page_number_x_0(self, tmp_path: Path) -> None:\n        # Issue 973\n        # Test TIFF with tag 297 (Page Number) having value of 0 0.\n        # The first number is the current page number.\n        # The second is the total number of pages, zero means not available.\n        outfile = str(tmp_path / \"temp.tif\")\n        # Created by printing a page in Chrome to PDF, then:\n        # /usr/bin/gs -q -sDEVICE=tiffg3 -sOutputFile=total-pages-zero.tif\n        # -dNOPAUSE /tmp/test.pdf -c quit\n        infile = \"Tests/images/total-pages-zero.tif\"\n        with Image.open(infile) as im:\n            # Should not divide by zero\n            im.save(outfile)\n\n    def test_fd_duplication(self, tmp_path: Path) -> None:\n        # https://github.com/python-pillow/Pillow/issues/1651\n\n        tmpfile = str(tmp_path / \"temp.tif\")\n        with open(tmpfile, \"wb\") as f:\n            with open(\"Tests/images/g4-multi.tiff\", \"rb\") as src:\n                f.write(src.read())\n\n        im = Image.open(tmpfile)\n        assert isinstance(im, TiffImagePlugin.TiffImageFile)\n        im.n_frames\n        im.close()\n        # Should not raise PermissionError.\n        os.remove(tmpfile)\n\n    def test_read_icc(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        with Image.open(\"Tests/images/hopper.iccprofile.tif\") as img:\n            icc = img.info.get(\"icc_profile\")\n            assert icc is not None\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(\"Tests/images/hopper.iccprofile.tif\") as img:\n            icc_libtiff = img.info.get(\"icc_profile\")\n            assert icc_libtiff is not None\n        assert icc == icc_libtiff\n\n    @pytest.mark.parametrize(\n        \"libtiff\",\n        (\n            pytest.param(\n                True,\n                marks=pytest.mark.skipif(\n                    not getattr(Image.core, \"libtiff_support_custom_tags\", False),\n                    reason=\"Custom tags not supported by older libtiff\",\n                ),\n            ),\n            False,\n        ),\n    )\n    def test_write_icc(\n        self, monkeypatch: pytest.MonkeyPatch, tmp_path: Path, libtiff: bool\n    ) -> None:\n        monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", libtiff)\n\n        with Image.open(\"Tests/images/hopper.iccprofile.tif\") as img:\n            icc_profile = img.info[\"icc_profile\"]\n\n            out = str(tmp_path / \"temp.tif\")\n            img.save(out, icc_profile=icc_profile)\n        with Image.open(out) as reloaded:\n            assert icc_profile == reloaded.info[\"icc_profile\"]\n\n    def test_multipage_compression(self) -> None:\n        with Image.open(\"Tests/images/compression.tif\") as im:\n            im.seek(0)\n            assert im._compression == \"tiff_ccitt\"\n            assert im.size == (10, 10)\n\n            im.seek(1)\n            assert im._compression == \"packbits\"\n            assert im.size == (10, 10)\n            im.load()\n\n            im.seek(0)\n            assert im._compression == \"tiff_ccitt\"\n            assert im.size == (10, 10)\n            im.load()\n\n    def test_save_tiff_with_jpegtables(self, tmp_path: Path) -> None:\n        # Arrange\n        outfile = str(tmp_path / \"temp.tif\")\n\n        # Created with ImageMagick: convert hopper.jpg hopper_jpg.tif\n        # Contains JPEGTables (347) tag\n        infile = \"Tests/images/hopper_jpg.tif\"\n        with Image.open(infile) as im:\n            # Act / Assert\n            # Should not raise UnicodeDecodeError or anything else\n            im.save(outfile)\n\n    def test_16bit_RGB_tiff(self) -> None:\n        with Image.open(\"Tests/images/tiff_16bit_RGB.tiff\") as im:\n            assert im.mode == \"RGB\"\n            assert im.size == (100, 40)\n            assert im.tile, [\n                (\n                    \"libtiff\",\n                    (0, 0, 100, 40),\n                    0,\n                    (\"RGB;16N\", \"tiff_adobe_deflate\", False, 8),\n                )\n            ]\n            im.load()\n\n            assert_image_equal_tofile(im, \"Tests/images/tiff_16bit_RGB_target.png\")\n\n    def test_16bit_RGBa_tiff(self) -> None:\n        with Image.open(\"Tests/images/tiff_16bit_RGBa.tiff\") as im:\n            assert im.mode == \"RGBA\"\n            assert im.size == (100, 40)\n            assert im.tile, [\n                (\"libtiff\", (0, 0, 100, 40), 0, (\"RGBa;16N\", \"tiff_lzw\", False, 38236))\n            ]\n            im.load()\n\n            assert_image_equal_tofile(im, \"Tests/images/tiff_16bit_RGBa_target.png\")\n\n    @skip_unless_feature(\"jpg\")\n    def test_gimp_tiff(self) -> None:\n        # Read TIFF JPEG images from GIMP [@PIL168]\n        filename = \"Tests/images/pil168.tif\"\n        with Image.open(filename) as im:\n            assert im.mode == \"RGB\"\n            assert im.size == (256, 256)\n            assert im.tile == [\n                (\"libtiff\", (0, 0, 256, 256), 0, (\"RGB\", \"jpeg\", False, 5122))\n            ]\n            im.load()\n\n            assert_image_equal_tofile(im, \"Tests/images/pil168.png\")\n\n    def test_sampleformat(self) -> None:\n        # https://github.com/python-pillow/Pillow/issues/1466\n        with Image.open(\"Tests/images/copyleft.tiff\") as im:\n            assert im.mode == \"RGB\"\n\n            assert_image_equal_tofile(im, \"Tests/images/copyleft.png\", mode=\"RGB\")\n\n    def test_sampleformat_write(\n        self, monkeypatch: pytest.MonkeyPatch, tmp_path: Path\n    ) -> None:\n        im = Image.new(\"F\", (1, 1))\n        out = str(tmp_path / \"temp.tif\")\n        monkeypatch.setattr(TiffImagePlugin, \"WRITE_LIBTIFF\", True)\n        im.save(out)\n\n        with Image.open(out) as reloaded:\n            assert reloaded.mode == \"F\"\n            assert reloaded.getexif()[SAMPLEFORMAT] == 3\n\n    def test_lzma(self, capfd: pytest.CaptureFixture[str]) -> None:\n        try:\n            with Image.open(\"Tests/images/hopper_lzma.tif\") as im:\n                assert im.mode == \"RGB\"\n                assert im.size == (128, 128)\n                assert im.format == \"TIFF\"\n                im2 = hopper()\n                assert_image_similar(im, im2, 5)\n        except OSError:\n            captured = capfd.readouterr()\n            if \"LZMA compression support is not configured\" in captured.err:\n                pytest.skip(\"LZMA compression support is not configured\")\n            sys.stdout.write(captured.out)\n            sys.stderr.write(captured.err)\n            raise\n\n    def test_webp(self, capfd: pytest.CaptureFixture[str]) -> None:\n        try:\n            with Image.open(\"Tests/images/hopper_webp.tif\") as im:\n                assert im.mode == \"RGB\"\n                assert im.size == (128, 128)\n                assert im.format == \"TIFF\"\n                assert_image_similar_tofile(im, \"Tests/images/hopper_webp.png\", 1)\n        except OSError:\n            captured = capfd.readouterr()\n            if \"WEBP compression support is not configured\" in captured.err:\n                pytest.skip(\"WEBP compression support is not configured\")\n            if (\n                \"Compression scheme 50001 strip decoding is not implemented\"\n                in captured.err\n            ):\n                pytest.skip(\n                    \"Compression scheme 50001 strip decoding is not implemented\"\n                )\n            sys.stdout.write(captured.out)\n            sys.stderr.write(captured.err)\n            raise\n\n    def test_lzw(self) -> None:\n        with Image.open(\"Tests/images/hopper_lzw.tif\") as im:\n            assert im.mode == \"RGB\"\n            assert im.size == (128, 128)\n            assert im.format == \"TIFF\"\n            im2 = hopper()\n            assert_image_similar(im, im2, 5)\n\n    def test_strip_cmyk_jpeg(self) -> None:\n        infile = \"Tests/images/tiff_strip_cmyk_jpeg.tif\"\n        with Image.open(infile) as im:\n            assert_image_similar_tofile(im, \"Tests/images/pil_sample_cmyk.jpg\", 0.5)\n\n    def test_strip_cmyk_16l_jpeg(self) -> None:\n        infile = \"Tests/images/tiff_strip_cmyk_16l_jpeg.tif\"\n        with Image.open(infile) as im:\n            assert_image_similar_tofile(im, \"Tests/images/pil_sample_cmyk.jpg\", 0.5)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_strip_ycbcr_jpeg_2x2_sampling(self) -> None:\n        infile = \"Tests/images/tiff_strip_ycbcr_jpeg_2x2_sampling.tif\"\n        with Image.open(infile) as im:\n            assert_image_similar_tofile(im, \"Tests/images/flower.jpg\", 1.2)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_strip_ycbcr_jpeg_1x1_sampling(self) -> None:\n        infile = \"Tests/images/tiff_strip_ycbcr_jpeg_1x1_sampling.tif\"\n        with Image.open(infile) as im:\n            assert_image_similar_tofile(im, \"Tests/images/flower2.jpg\", 0.01)\n\n    def test_tiled_cmyk_jpeg(self) -> None:\n        infile = \"Tests/images/tiff_tiled_cmyk_jpeg.tif\"\n        with Image.open(infile) as im:\n            assert_image_similar_tofile(im, \"Tests/images/pil_sample_cmyk.jpg\", 0.5)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_tiled_ycbcr_jpeg_1x1_sampling(self) -> None:\n        infile = \"Tests/images/tiff_tiled_ycbcr_jpeg_1x1_sampling.tif\"\n        with Image.open(infile) as im:\n            assert_image_similar_tofile(im, \"Tests/images/flower2.jpg\", 0.01)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_tiled_ycbcr_jpeg_2x2_sampling(self) -> None:\n        infile = \"Tests/images/tiff_tiled_ycbcr_jpeg_2x2_sampling.tif\"\n        with Image.open(infile) as im:\n            assert_image_similar_tofile(im, \"Tests/images/flower.jpg\", 1.5)\n\n    def test_strip_planar_rgb(self) -> None:\n        # gdal_translate -co TILED=no -co INTERLEAVE=BAND -co COMPRESS=LZW \\\n        # tiff_strip_raw.tif tiff_strip_planar_lzw.tiff\n        infile = \"Tests/images/tiff_strip_planar_lzw.tiff\"\n        with Image.open(infile) as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")\n\n    def test_tiled_planar_rgb(self) -> None:\n        # gdal_translate -co TILED=yes -co INTERLEAVE=BAND -co COMPRESS=LZW \\\n        # tiff_tiled_raw.tif tiff_tiled_planar_lzw.tiff\n        infile = \"Tests/images/tiff_tiled_planar_lzw.tiff\"\n        with Image.open(infile) as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")\n\n    def test_tiled_planar_16bit_RGB(self) -> None:\n        # gdal_translate -co TILED=yes -co INTERLEAVE=BAND -co COMPRESS=LZW \\\n        # tiff_16bit_RGB.tiff tiff_tiled_planar_16bit_RGB.tiff\n        with Image.open(\"Tests/images/tiff_tiled_planar_16bit_RGB.tiff\") as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_16bit_RGB_target.png\")\n\n    def test_strip_planar_16bit_RGB(self) -> None:\n        # gdal_translate -co TILED=no -co INTERLEAVE=BAND -co COMPRESS=LZW \\\n        # tiff_16bit_RGB.tiff tiff_strip_planar_16bit_RGB.tiff\n        with Image.open(\"Tests/images/tiff_strip_planar_16bit_RGB.tiff\") as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_16bit_RGB_target.png\")\n\n    def test_tiled_planar_16bit_RGBa(self) -> None:\n        # gdal_translate -co TILED=yes \\\n        # -co INTERLEAVE=BAND -co COMPRESS=LZW -co ALPHA=PREMULTIPLIED \\\n        # tiff_16bit_RGBa.tiff tiff_tiled_planar_16bit_RGBa.tiff\n        with Image.open(\"Tests/images/tiff_tiled_planar_16bit_RGBa.tiff\") as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_16bit_RGBa_target.png\")\n\n    def test_strip_planar_16bit_RGBa(self) -> None:\n        # gdal_translate -co TILED=no \\\n        # -co INTERLEAVE=BAND -co COMPRESS=LZW -co ALPHA=PREMULTIPLIED \\\n        # tiff_16bit_RGBa.tiff tiff_strip_planar_16bit_RGBa.tiff\n        with Image.open(\"Tests/images/tiff_strip_planar_16bit_RGBa.tiff\") as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_16bit_RGBa_target.png\")\n\n    @pytest.mark.parametrize(\"compression\", (None, \"jpeg\"))\n    def test_block_tile_tags(self, compression: str | None, tmp_path: Path) -> None:\n        im = hopper()\n        out = str(tmp_path / \"temp.tif\")\n\n        tags = {\n            TiffImagePlugin.TILEWIDTH: 256,\n            TiffImagePlugin.TILELENGTH: 256,\n            TiffImagePlugin.TILEOFFSETS: 256,\n            TiffImagePlugin.TILEBYTECOUNTS: 256,\n        }\n        im.save(out, exif=tags, compression=compression)\n\n        with Image.open(out) as reloaded:\n            for tag in tags:\n                assert tag not in reloaded.getexif()\n\n    def test_old_style_jpeg(self) -> None:\n        with Image.open(\"Tests/images/old-style-jpeg-compression.tif\") as im:\n            assert_image_equal_tofile(im, \"Tests/images/old-style-jpeg-compression.png\")\n\n    def test_open_missing_samplesperpixel(self) -> None:\n        with Image.open(\n            \"Tests/images/old-style-jpeg-compression-no-samplesperpixel.tif\"\n        ) as im:\n            assert_image_equal_tofile(im, \"Tests/images/old-style-jpeg-compression.png\")\n\n    @pytest.mark.parametrize(\n        \"file_name, mode, size, tile\",\n        [\n            (\n                \"tiff_wrong_bits_per_sample.tiff\",\n                \"RGBA\",\n                (52, 53),\n                [(\"raw\", (0, 0, 52, 53), 160, (\"RGBA\", 0, 1))],\n            ),\n            (\n                \"tiff_wrong_bits_per_sample_2.tiff\",\n                \"RGB\",\n                (16, 16),\n                [(\"raw\", (0, 0, 16, 16), 8, (\"RGB\", 0, 1))],\n            ),\n            (\n                \"tiff_wrong_bits_per_sample_3.tiff\",\n                \"RGBA\",\n                (512, 256),\n                [(\"libtiff\", (0, 0, 512, 256), 0, (\"RGBA\", \"tiff_lzw\", False, 48782))],\n            ),\n        ],\n    )\n    def test_wrong_bits_per_sample(\n        self, file_name: str, mode: str, size: tuple[int, int], tile\n    ) -> None:\n        with Image.open(\"Tests/images/\" + file_name) as im:\n            assert im.mode == mode\n            assert im.size == size\n            assert im.tile == tile\n            im.load()\n\n    def test_no_rows_per_strip(self) -> None:\n        # This image does not have a RowsPerStrip TIFF tag\n        infile = \"Tests/images/no_rows_per_strip.tif\"\n        with Image.open(infile) as im:\n            im.load()\n        assert im.size == (950, 975)\n\n    def test_orientation(self) -> None:\n        with Image.open(\"Tests/images/g4_orientation_1.tif\") as base_im:\n            for i in range(2, 9):\n                with Image.open(\"Tests/images/g4_orientation_\" + str(i) + \".tif\") as im:\n                    assert 274 in im.tag_v2\n\n                    im.load()\n                    assert 274 not in im.tag_v2\n\n                    assert_image_similar(base_im, im, 0.7)\n\n    def test_exif_transpose(self) -> None:\n        with Image.open(\"Tests/images/g4_orientation_1.tif\") as base_im:\n            for i in range(2, 9):\n                with Image.open(\"Tests/images/g4_orientation_\" + str(i) + \".tif\") as im:\n                    im = ImageOps.exif_transpose(im)\n\n                    assert_image_similar(base_im, im, 0.7)\n\n    @pytest.mark.valgrind_known_error(reason=\"Backtrace in Python Core\")\n    def test_sampleformat_not_corrupted(self) -> None:\n        # Assert that a TIFF image with SampleFormat=UINT tag is not corrupted\n        # when saving to a new file.\n        # Pillow 6.0 fails with \"OSError: cannot identify image file\".\n        tiff = io.BytesIO(\n            base64.b64decode(\n                b\"SUkqAAgAAAAPAP4ABAABAAAAAAAAAAABBAABAAAAAQAAAAEBBAABAAAAAQAA\"\n                b\"AAIBAwADAAAAwgAAAAMBAwABAAAACAAAAAYBAwABAAAAAgAAABEBBAABAAAA\"\n                b\"4AAAABUBAwABAAAAAwAAABYBBAABAAAAAQAAABcBBAABAAAACwAAABoBBQAB\"\n                b\"AAAAyAAAABsBBQABAAAA0AAAABwBAwABAAAAAQAAACgBAwABAAAAAQAAAFMB\"\n                b\"AwADAAAA2AAAAAAAAAAIAAgACAABAAAAAQAAAAEAAAABAAAAAQABAAEAAAB4\"\n                b\"nGNgYAAAAAMAAQ==\"\n            )\n        )\n        out = io.BytesIO()\n        with Image.open(tiff) as im:\n            im.save(out, format=\"tiff\")\n        out.seek(0)\n        with Image.open(out) as im:\n            im.load()\n\n    def test_realloc_overflow(self, monkeypatch: pytest.MonkeyPatch) -> None:\n        monkeypatch.setattr(TiffImagePlugin, \"READ_LIBTIFF\", True)\n        with Image.open(\"Tests/images/tiff_overflow_rows_per_strip.tif\") as im:\n            with pytest.raises(OSError) as e:\n                im.load()\n\n            # Assert that the error code is IMAGING_CODEC_MEMORY\n            assert str(e.value) == \"-9\"\n\n    @pytest.mark.parametrize(\"compression\", (\"tiff_adobe_deflate\", \"jpeg\"))\n    def test_save_multistrip(self, compression: str, tmp_path: Path) -> None:\n        im = hopper(\"RGB\").resize((256, 256))\n        out = str(tmp_path / \"temp.tif\")\n        im.save(out, compression=compression)\n\n        with Image.open(out) as im:\n            # Assert that there are multiple strips\n            assert isinstance(im, TiffImagePlugin.TiffImageFile)\n            assert len(im.tag_v2[STRIPOFFSETS]) > 1\n\n    @pytest.mark.parametrize(\"argument\", (True, False))\n    def test_save_single_strip(self, argument: bool, tmp_path: Path) -> None:\n        im = hopper(\"RGB\").resize((256, 256))\n        out = str(tmp_path / \"temp.tif\")\n\n        if not argument:\n            TiffImagePlugin.STRIP_SIZE = 2**18\n        try:\n            arguments: dict[str, str | int] = {\"compression\": \"tiff_adobe_deflate\"}\n            if argument:\n                arguments[\"strip_size\"] = 2**18\n            im.save(out, **arguments)\n\n            with Image.open(out) as im:\n                assert isinstance(im, TiffImagePlugin.TiffImageFile)\n                assert len(im.tag_v2[STRIPOFFSETS]) == 1\n        finally:\n            TiffImagePlugin.STRIP_SIZE = 65536\n\n    @pytest.mark.parametrize(\"compression\", (\"tiff_adobe_deflate\", None))\n    def test_save_zero(self, compression: str | None, tmp_path: Path) -> None:\n        im = Image.new(\"RGB\", (0, 0))\n        out = str(tmp_path / \"temp.tif\")\n        with pytest.raises(SystemError):\n            im.save(out, compression=compression)\n\n    def test_save_many_compressed(self, tmp_path: Path) -> None:\n        im = hopper()\n        out = str(tmp_path / \"temp.tif\")\n        for _ in range(10000):\n            im.save(out, compression=\"jpeg\")\n\n    @pytest.mark.parametrize(\n        \"path, sizes\",\n        (\n            (\"Tests/images/hopper.tif\", ()),\n            (\"Tests/images/child_ifd.tiff\", (16, 8)),\n            (\"Tests/images/child_ifd_jpeg.tiff\", (20,)),\n        ),\n    )\n    def test_get_child_images(self, path: str, sizes: tuple[int, ...]) -> None:\n        with Image.open(path) as im:\n            ims = im.get_child_images()\n\n        assert len(ims) == len(sizes)\n        for i, im in enumerate(ims):\n            w = sizes[i]\n            expected = Image.new(\"RGB\", (w, w), \"#f00\")\n            assert_image_similar(im, expected, 1)\n", "Tests/test_file_ico.py": "from __future__ import annotations\n\nimport io\nimport os\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import IcoImagePlugin, Image, ImageDraw\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, hopper\n\nTEST_ICO_FILE = \"Tests/images/hopper.ico\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_ICO_FILE) as im:\n        im.load()\n    assert im.mode == \"RGBA\"\n    assert im.size == (16, 16)\n    assert im.format == \"ICO\"\n    assert im.get_format_mimetype() == \"image/x-icon\"\n\n\ndef test_load() -> None:\n    with Image.open(TEST_ICO_FILE) as im:\n        assert im.load()[0, 0] == (1, 1, 9, 255)\n\n\ndef test_mask() -> None:\n    with Image.open(\"Tests/images/hopper_mask.ico\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/hopper_mask.png\")\n\n\ndef test_black_and_white() -> None:\n    with Image.open(\"Tests/images/black_and_white.ico\") as im:\n        assert im.mode == \"RGBA\"\n        assert im.size == (16, 16)\n\n\ndef test_palette(tmp_path: Path) -> None:\n    temp_file = str(tmp_path / \"temp.ico\")\n\n    im = Image.new(\"P\", (16, 16))\n    im.save(temp_file)\n\n    with Image.open(temp_file) as reloaded:\n        assert reloaded.mode == \"P\"\n        assert reloaded.palette is not None\n\n\ndef test_invalid_file() -> None:\n    with open(\"Tests/images/flower.jpg\", \"rb\") as fp:\n        with pytest.raises(SyntaxError):\n            IcoImagePlugin.IcoImageFile(fp)\n\n\ndef test_save_to_bytes() -> None:\n    output = io.BytesIO()\n    im = hopper()\n    im.save(output, \"ico\", sizes=[(32, 32), (64, 64)])\n\n    # The default image\n    output.seek(0)\n    with Image.open(output) as reloaded:\n        assert reloaded.info[\"sizes\"] == {(32, 32), (64, 64)}\n\n        assert im.mode == reloaded.mode\n        assert (64, 64) == reloaded.size\n        assert reloaded.format == \"ICO\"\n        assert_image_equal(\n            reloaded, hopper().resize((64, 64), Image.Resampling.LANCZOS)\n        )\n\n    # The other one\n    output.seek(0)\n    with Image.open(output) as reloaded:\n        reloaded.size = (32, 32)\n\n        assert im.mode == reloaded.mode\n        assert (32, 32) == reloaded.size\n        assert reloaded.format == \"ICO\"\n        assert_image_equal(\n            reloaded, hopper().resize((32, 32), Image.Resampling.LANCZOS)\n        )\n\n\ndef test_getpixel(tmp_path: Path) -> None:\n    temp_file = str(tmp_path / \"temp.ico\")\n\n    im = hopper()\n    im.save(temp_file, \"ico\", sizes=[(32, 32), (64, 64)])\n\n    with Image.open(temp_file) as reloaded:\n        reloaded.load()\n        reloaded.size = (32, 32)\n\n        assert reloaded.getpixel((0, 0)) == (18, 20, 62)\n\n\ndef test_no_duplicates(tmp_path: Path) -> None:\n    temp_file = str(tmp_path / \"temp.ico\")\n    temp_file2 = str(tmp_path / \"temp2.ico\")\n\n    im = hopper()\n    sizes = [(32, 32), (64, 64)]\n    im.save(temp_file, \"ico\", sizes=sizes)\n\n    sizes.append(sizes[-1])\n    im.save(temp_file2, \"ico\", sizes=sizes)\n\n    assert os.path.getsize(temp_file) == os.path.getsize(temp_file2)\n\n\ndef test_different_bit_depths(tmp_path: Path) -> None:\n    temp_file = str(tmp_path / \"temp.ico\")\n    temp_file2 = str(tmp_path / \"temp2.ico\")\n\n    im = hopper()\n    im.save(temp_file, \"ico\", bitmap_format=\"bmp\", sizes=[(128, 128)])\n\n    hopper(\"1\").save(\n        temp_file2,\n        \"ico\",\n        bitmap_format=\"bmp\",\n        sizes=[(128, 128)],\n        append_images=[im],\n    )\n\n    assert os.path.getsize(temp_file) != os.path.getsize(temp_file2)\n\n    # Test that only matching sizes of different bit depths are saved\n    temp_file3 = str(tmp_path / \"temp3.ico\")\n    temp_file4 = str(tmp_path / \"temp4.ico\")\n\n    im.save(temp_file3, \"ico\", bitmap_format=\"bmp\", sizes=[(128, 128)])\n    im.save(\n        temp_file4,\n        \"ico\",\n        bitmap_format=\"bmp\",\n        sizes=[(128, 128)],\n        append_images=[Image.new(\"P\", (64, 64))],\n    )\n\n    assert os.path.getsize(temp_file3) == os.path.getsize(temp_file4)\n\n\n@pytest.mark.parametrize(\"mode\", (\"1\", \"L\", \"P\", \"RGB\", \"RGBA\"))\ndef test_save_to_bytes_bmp(mode: str) -> None:\n    output = io.BytesIO()\n    im = hopper(mode)\n    im.save(output, \"ico\", bitmap_format=\"bmp\", sizes=[(32, 32), (64, 64)])\n\n    # The default image\n    output.seek(0)\n    with Image.open(output) as reloaded:\n        assert reloaded.info[\"sizes\"] == {(32, 32), (64, 64)}\n\n        assert \"RGBA\" == reloaded.mode\n        assert (64, 64) == reloaded.size\n        assert reloaded.format == \"ICO\"\n        im = hopper(mode).resize((64, 64), Image.Resampling.LANCZOS).convert(\"RGBA\")\n        assert_image_equal(reloaded, im)\n\n    # The other one\n    output.seek(0)\n    with Image.open(output) as reloaded:\n        reloaded.size = (32, 32)\n\n        assert \"RGBA\" == reloaded.mode\n        assert (32, 32) == reloaded.size\n        assert reloaded.format == \"ICO\"\n        im = hopper(mode).resize((32, 32), Image.Resampling.LANCZOS).convert(\"RGBA\")\n        assert_image_equal(reloaded, im)\n\n\ndef test_incorrect_size() -> None:\n    with Image.open(TEST_ICO_FILE) as im:\n        with pytest.raises(ValueError):\n            im.size = (1, 1)\n\n\ndef test_save_256x256(tmp_path: Path) -> None:\n    \"\"\"Issue #2264 https://github.com/python-pillow/Pillow/issues/2264\"\"\"\n    # Arrange\n    with Image.open(\"Tests/images/hopper_256x256.ico\") as im:\n        outfile = str(tmp_path / \"temp_saved_hopper_256x256.ico\")\n\n        # Act\n        im.save(outfile)\n    with Image.open(outfile) as im_saved:\n        # Assert\n        assert im_saved.size == (256, 256)\n\n\ndef test_only_save_relevant_sizes(tmp_path: Path) -> None:\n    \"\"\"Issue #2266 https://github.com/python-pillow/Pillow/issues/2266\n    Should save in 16x16, 24x24, 32x32, 48x48 sizes\n    and not in 16x16, 24x24, 32x32, 48x48, 48x48, 48x48, 48x48 sizes\n    \"\"\"\n    # Arrange\n    with Image.open(\"Tests/images/python.ico\") as im:  # 16x16, 32x32, 48x48\n        outfile = str(tmp_path / \"temp_saved_python.ico\")\n        # Act\n        im.save(outfile)\n\n    with Image.open(outfile) as im_saved:\n        # Assert\n        assert im_saved.info[\"sizes\"] == {(16, 16), (24, 24), (32, 32), (48, 48)}\n\n\ndef test_save_append_images(tmp_path: Path) -> None:\n    # append_images should be used for scaled down versions of the image\n    im = hopper(\"RGBA\")\n    provided_im = Image.new(\"RGBA\", (32, 32), (255, 0, 0))\n    outfile = str(tmp_path / \"temp_saved_multi_icon.ico\")\n    im.save(outfile, sizes=[(32, 32), (128, 128)], append_images=[provided_im])\n\n    with Image.open(outfile) as reread:\n        assert_image_equal(reread, hopper(\"RGBA\"))\n\n        reread.size = (32, 32)\n        assert_image_equal(reread, provided_im)\n\n\ndef test_unexpected_size() -> None:\n    # This image has been manually hexedited to state that it is 16x32\n    # while the image within is still 16x16\n    with pytest.warns(UserWarning):\n        with Image.open(\"Tests/images/hopper_unexpected.ico\") as im:\n            assert im.size == (16, 16)\n\n\ndef test_draw_reloaded(tmp_path: Path) -> None:\n    with Image.open(TEST_ICO_FILE) as im:\n        outfile = str(tmp_path / \"temp_saved_hopper_draw.ico\")\n\n        draw = ImageDraw.Draw(im)\n        draw.line((0, 0) + im.size, \"#f00\")\n        im.save(outfile)\n\n    with Image.open(outfile) as im:\n        assert_image_equal_tofile(im, \"Tests/images/hopper_draw.ico\")\n", "Tests/check_jp2_overflow.py": "# Reproductions/tests for OOB read errors in FliDecode.c\n\n# When run in python, all of these images should fail for\n# one reason or another, either as a buffer overrun,\n# unrecognized datastream, or truncated image file.\n# There shouldn't be any segfaults.\n#\n# if run like\n# `valgrind --tool=memcheck python check_jp2_overflow.py  2>&1 | grep Decode.c`\n# the output should be empty. There may be python issues\n# in the valgrind especially if run in a debug python\n# version.\nfrom __future__ import annotations\n\nfrom PIL import Image\n\nrepro = (\"00r0_gray_l.jp2\", \"00r1_graya_la.jp2\")\n\nfor path in repro:\n    with Image.open(path) as im:\n        try:\n            im.load()\n        except Exception as msg:\n            print(msg)\n", "Tests/test_file_tiff.py": "from __future__ import annotations\n\nimport os\nimport warnings\nfrom io import BytesIO\nfrom pathlib import Path\nfrom types import ModuleType\nfrom typing import Generator\n\nimport pytest\n\nfrom PIL import Image, ImageFile, TiffImagePlugin, UnidentifiedImageError\nfrom PIL.TiffImagePlugin import RESOLUTION_UNIT, X_RESOLUTION, Y_RESOLUTION\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    hopper,\n    is_pypy,\n    is_win32,\n)\n\nElementTree: ModuleType | None\ntry:\n    from defusedxml import ElementTree\nexcept ImportError:\n    ElementTree = None\n\n\nclass TestFileTiff:\n    def test_sanity(self, tmp_path: Path) -> None:\n        filename = str(tmp_path / \"temp.tif\")\n\n        hopper(\"RGB\").save(filename)\n\n        with Image.open(filename) as im:\n            im.load()\n        assert im.mode == \"RGB\"\n        assert im.size == (128, 128)\n        assert im.format == \"TIFF\"\n\n        hopper(\"1\").save(filename)\n        with Image.open(filename):\n            pass\n\n        hopper(\"L\").save(filename)\n        with Image.open(filename):\n            pass\n\n        hopper(\"P\").save(filename)\n        with Image.open(filename):\n            pass\n\n        hopper(\"RGB\").save(filename)\n        with Image.open(filename):\n            pass\n\n        hopper(\"I\").save(filename)\n        with Image.open(filename):\n            pass\n\n    @pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\n    def test_unclosed_file(self) -> None:\n        def open() -> None:\n            im = Image.open(\"Tests/images/multipage.tiff\")\n            im.load()\n\n        with pytest.warns(ResourceWarning):\n            open()\n\n    def test_closed_file(self) -> None:\n        with warnings.catch_warnings():\n            im = Image.open(\"Tests/images/multipage.tiff\")\n            im.load()\n            im.close()\n\n    def test_seek_after_close(self) -> None:\n        im = Image.open(\"Tests/images/multipage.tiff\")\n        im.close()\n\n        with pytest.raises(ValueError):\n            im.n_frames\n        with pytest.raises(ValueError):\n            im.seek(1)\n\n    def test_context_manager(self) -> None:\n        with warnings.catch_warnings():\n            with Image.open(\"Tests/images/multipage.tiff\") as im:\n                im.load()\n\n    def test_mac_tiff(self) -> None:\n        # Read RGBa images from macOS [@PIL136]\n\n        filename = \"Tests/images/pil136.tiff\"\n        with Image.open(filename) as im:\n            assert im.mode == \"RGBA\"\n            assert im.size == (55, 43)\n            assert im.tile == [(\"raw\", (0, 0, 55, 43), 8, (\"RGBa\", 0, 1))]\n            im.load()\n\n            assert_image_similar_tofile(im, \"Tests/images/pil136.png\", 1)\n\n    def test_bigtiff(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/hopper_bigtiff.tif\") as im:\n            assert_image_equal_tofile(im, \"Tests/images/hopper.tif\")\n\n        with Image.open(\"Tests/images/hopper_bigtiff.tif\") as im:\n            # multistrip support not yet implemented\n            del im.tag_v2[273]\n\n            outfile = str(tmp_path / \"temp.tif\")\n            im.save(outfile, save_all=True, append_images=[im], tiffinfo=im.tag_v2)\n\n    def test_seek_too_large(self) -> None:\n        with pytest.raises(ValueError, match=\"Unable to seek to frame\"):\n            Image.open(\"Tests/images/seek_too_large.tif\")\n\n    def test_set_legacy_api(self) -> None:\n        ifd = TiffImagePlugin.ImageFileDirectory_v2()\n        with pytest.raises(Exception) as e:\n            ifd.legacy_api = False\n        assert str(e.value) == \"Not allowing setting of legacy api\"\n\n    def test_xyres_tiff(self) -> None:\n        filename = \"Tests/images/pil168.tif\"\n        with Image.open(filename) as im:\n            # legacy api\n            assert isinstance(im.tag[X_RESOLUTION][0], tuple)\n            assert isinstance(im.tag[Y_RESOLUTION][0], tuple)\n\n            # v2 api\n            assert isinstance(im.tag_v2[X_RESOLUTION], TiffImagePlugin.IFDRational)\n            assert isinstance(im.tag_v2[Y_RESOLUTION], TiffImagePlugin.IFDRational)\n\n            assert im.info[\"dpi\"] == (72.0, 72.0)\n\n    def test_xyres_fallback_tiff(self) -> None:\n        filename = \"Tests/images/compression.tif\"\n        with Image.open(filename) as im:\n            # v2 api\n            assert isinstance(im.tag_v2[X_RESOLUTION], TiffImagePlugin.IFDRational)\n            assert isinstance(im.tag_v2[Y_RESOLUTION], TiffImagePlugin.IFDRational)\n            with pytest.raises(KeyError):\n                im.tag_v2[RESOLUTION_UNIT]\n\n            # Legacy.\n            assert im.info[\"resolution\"] == (100.0, 100.0)\n            # Fallback \"inch\".\n            assert im.info[\"dpi\"] == (100.0, 100.0)\n\n    def test_int_resolution(self) -> None:\n        filename = \"Tests/images/pil168.tif\"\n        with Image.open(filename) as im:\n            # Try to read a file where X,Y_RESOLUTION are ints\n            im.tag_v2[X_RESOLUTION] = 71\n            im.tag_v2[Y_RESOLUTION] = 71\n            im._setup()\n            assert im.info[\"dpi\"] == (71.0, 71.0)\n\n    @pytest.mark.parametrize(\n        \"resolution_unit, dpi\",\n        [(None, 72.8), (2, 72.8), (3, 184.912)],\n    )\n    def test_load_float_dpi(self, resolution_unit: int | None, dpi: float) -> None:\n        with Image.open(\n            \"Tests/images/hopper_float_dpi_\" + str(resolution_unit) + \".tif\"\n        ) as im:\n            assert im.tag_v2.get(RESOLUTION_UNIT) == resolution_unit\n            assert im.info[\"dpi\"] == (dpi, dpi)\n\n    def test_save_float_dpi(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/hopper.tif\") as im:\n            dpi = (72.2, 72.2)\n            im.save(outfile, dpi=dpi)\n\n            with Image.open(outfile) as reloaded:\n                assert reloaded.info[\"dpi\"] == dpi\n\n    def test_save_setting_missing_resolution(self) -> None:\n        b = BytesIO()\n        with Image.open(\"Tests/images/10ct_32bit_128.tiff\") as im:\n            im.save(b, format=\"tiff\", resolution=123.45)\n        with Image.open(b) as im:\n            assert im.tag_v2[X_RESOLUTION] == 123.45\n            assert im.tag_v2[Y_RESOLUTION] == 123.45\n\n    def test_invalid_file(self) -> None:\n        invalid_file = \"Tests/images/flower.jpg\"\n\n        with pytest.raises(SyntaxError):\n            TiffImagePlugin.TiffImageFile(invalid_file)\n\n        TiffImagePlugin.PREFIXES.append(b\"\\xff\\xd8\\xff\\xe0\")\n        with pytest.raises(SyntaxError):\n            TiffImagePlugin.TiffImageFile(invalid_file)\n        TiffImagePlugin.PREFIXES.pop()\n\n    def test_bad_exif(self) -> None:\n        with Image.open(\"Tests/images/hopper_bad_exif.jpg\") as i:\n            # Should not raise struct.error.\n            with pytest.warns(UserWarning):\n                i._getexif()\n\n    def test_save_rgba(self, tmp_path: Path) -> None:\n        im = hopper(\"RGBA\")\n        outfile = str(tmp_path / \"temp.tif\")\n        im.save(outfile)\n\n    def test_save_unsupported_mode(self, tmp_path: Path) -> None:\n        im = hopper(\"HSV\")\n        outfile = str(tmp_path / \"temp.tif\")\n        with pytest.raises(OSError):\n            im.save(outfile)\n\n    def test_8bit_s(self) -> None:\n        with Image.open(\"Tests/images/8bit.s.tif\") as im:\n            im.load()\n            assert im.mode == \"L\"\n            assert im.getpixel((50, 50)) == 184\n\n    def test_little_endian(self) -> None:\n        with Image.open(\"Tests/images/16bit.cropped.tif\") as im:\n            assert im.getpixel((0, 0)) == 480\n            assert im.mode == \"I;16\"\n\n            b = im.tobytes()\n        # Bytes are in image native order (little endian)\n        assert b[0] == ord(b\"\\xe0\")\n        assert b[1] == ord(b\"\\x01\")\n\n    def test_big_endian(self) -> None:\n        with Image.open(\"Tests/images/16bit.MM.cropped.tif\") as im:\n            assert im.getpixel((0, 0)) == 480\n            assert im.mode == \"I;16B\"\n\n            b = im.tobytes()\n        # Bytes are in image native order (big endian)\n        assert b[0] == ord(b\"\\x01\")\n        assert b[1] == ord(b\"\\xe0\")\n\n    def test_16bit_r(self) -> None:\n        with Image.open(\"Tests/images/16bit.r.tif\") as im:\n            assert im.getpixel((0, 0)) == 480\n            assert im.mode == \"I;16\"\n\n            b = im.tobytes()\n        assert b[0] == ord(b\"\\xe0\")\n        assert b[1] == ord(b\"\\x01\")\n\n    def test_16bit_s(self) -> None:\n        with Image.open(\"Tests/images/16bit.s.tif\") as im:\n            im.load()\n            assert im.mode == \"I\"\n            assert im.getpixel((0, 0)) == 32767\n            assert im.getpixel((0, 1)) == 0\n\n    def test_12bit_rawmode(self) -> None:\n        \"\"\"Are we generating the same interpretation\n        of the image as Imagemagick is?\"\"\"\n\n        with Image.open(\"Tests/images/12bit.cropped.tif\") as im:\n            # to make the target --\n            # convert 12bit.cropped.tif -depth 16 tmp.tif\n            # convert tmp.tif -evaluate RightShift 4 12in16bit2.tif\n            # imagemagick will auto scale so that a 12bit FFF is 16bit FFF0,\n            # so we need to unshift so that the integer values are the same.\n\n            assert_image_equal_tofile(im, \"Tests/images/12in16bit.tif\")\n\n    def test_32bit_float(self) -> None:\n        # Issue 614, specific 32-bit float format\n        path = \"Tests/images/10ct_32bit_128.tiff\"\n        with Image.open(path) as im:\n            im.load()\n\n            assert im.getpixel((0, 0)) == -0.4526388943195343\n            assert im.getextrema() == (-3.140936851501465, 3.140684127807617)\n\n    def test_unknown_pixel_mode(self) -> None:\n        with pytest.raises(OSError):\n            with Image.open(\"Tests/images/hopper_unknown_pixel_mode.tif\"):\n                pass\n\n    @pytest.mark.parametrize(\n        \"path, n_frames\",\n        (\n            (\"Tests/images/multipage-lastframe.tif\", 1),\n            (\"Tests/images/multipage.tiff\", 3),\n        ),\n    )\n    def test_n_frames(self, path: str, n_frames: int) -> None:\n        with Image.open(path) as im:\n            assert im.n_frames == n_frames\n            assert im.is_animated == (n_frames != 1)\n\n    def test_eoferror(self) -> None:\n        with Image.open(\"Tests/images/multipage-lastframe.tif\") as im:\n            n_frames = im.n_frames\n\n            # Test seeking past the last frame\n            with pytest.raises(EOFError):\n                im.seek(n_frames)\n            assert im.tell() < n_frames\n\n            # Test that seeking to the last frame does not raise an error\n            im.seek(n_frames - 1)\n\n    def test_multipage(self) -> None:\n        # issue #862\n        with Image.open(\"Tests/images/multipage.tiff\") as im:\n            # file is a multipage tiff: 10x10 green, 10x10 red, 20x20 blue\n\n            im.seek(0)\n            assert im.size == (10, 10)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)\n\n            im.seek(1)\n            im.load()\n            assert im.size == (10, 10)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (255, 0, 0)\n\n            im.seek(0)\n            im.load()\n            assert im.size == (10, 10)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 128, 0)\n\n            im.seek(2)\n            im.load()\n            assert im.size == (20, 20)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 255)\n\n    def test_multipage_last_frame(self) -> None:\n        with Image.open(\"Tests/images/multipage-lastframe.tif\") as im:\n            im.load()\n            assert im.size == (20, 20)\n            assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 255)\n\n    def test_frame_order(self) -> None:\n        # A frame can't progress to itself after reading\n        with Image.open(\"Tests/images/multipage_single_frame_loop.tiff\") as im:\n            assert im.n_frames == 1\n\n        # A frame can't progress to a frame that has already been read\n        with Image.open(\"Tests/images/multipage_multiple_frame_loop.tiff\") as im:\n            assert im.n_frames == 2\n\n        # Frames don't have to be in sequence\n        with Image.open(\"Tests/images/multipage_out_of_order.tiff\") as im:\n            assert im.n_frames == 3\n\n    def test___str__(self) -> None:\n        filename = \"Tests/images/pil136.tiff\"\n        with Image.open(filename) as im:\n            # Act\n            ret = str(im.ifd)\n\n            # Assert\n            assert isinstance(ret, str)\n\n    def test_dict(self) -> None:\n        # Arrange\n        filename = \"Tests/images/pil136.tiff\"\n        with Image.open(filename) as im:\n            # v2 interface\n            v2_tags = {\n                256: 55,\n                257: 43,\n                258: (8, 8, 8, 8),\n                259: 1,\n                262: 2,\n                296: 2,\n                273: (8,),\n                338: (1,),\n                277: 4,\n                279: (9460,),\n                282: 72.0,\n                283: 72.0,\n                284: 1,\n            }\n            assert dict(im.tag_v2) == v2_tags\n\n            # legacy interface\n            legacy_tags = {\n                256: (55,),\n                257: (43,),\n                258: (8, 8, 8, 8),\n                259: (1,),\n                262: (2,),\n                296: (2,),\n                273: (8,),\n                338: (1,),\n                277: (4,),\n                279: (9460,),\n                282: ((720000, 10000),),\n                283: ((720000, 10000),),\n                284: (1,),\n            }\n            assert dict(im.tag) == legacy_tags\n\n    def test__delitem__(self) -> None:\n        filename = \"Tests/images/pil136.tiff\"\n        with Image.open(filename) as im:\n            len_before = len(dict(im.ifd))\n            del im.ifd[256]\n            len_after = len(dict(im.ifd))\n            assert len_before == len_after + 1\n\n    @pytest.mark.parametrize(\"legacy_api\", (False, True))\n    def test_load_byte(self, legacy_api: bool) -> None:\n        ifd = TiffImagePlugin.ImageFileDirectory_v2()\n        data = b\"abc\"\n        ret = ifd.load_byte(data, legacy_api)\n        assert ret == b\"abc\"\n\n    def test_load_string(self) -> None:\n        ifd = TiffImagePlugin.ImageFileDirectory_v2()\n        data = b\"abc\\0\"\n        ret = ifd.load_string(data, False)\n        assert ret == \"abc\"\n\n    def test_load_float(self) -> None:\n        ifd = TiffImagePlugin.ImageFileDirectory_v2()\n        data = b\"abcdabcd\"\n        ret = ifd.load_float(data, False)\n        assert ret == (1.6777999408082104e22, 1.6777999408082104e22)\n\n    def test_load_double(self) -> None:\n        ifd = TiffImagePlugin.ImageFileDirectory_v2()\n        data = b\"abcdefghabcdefgh\"\n        ret = ifd.load_double(data, False)\n        assert ret == (8.540883223036124e194, 8.540883223036124e194)\n\n    def test_ifd_tag_type(self) -> None:\n        with Image.open(\"Tests/images/ifd_tag_type.tiff\") as im:\n            assert 0x8825 in im.tag_v2\n\n    def test_exif(self, tmp_path: Path) -> None:\n        def check_exif(exif: Image.Exif) -> None:\n            assert sorted(exif.keys()) == [\n                256,\n                257,\n                258,\n                259,\n                262,\n                271,\n                272,\n                273,\n                277,\n                278,\n                279,\n                282,\n                283,\n                284,\n                296,\n                297,\n                305,\n                339,\n                700,\n                34665,\n                34853,\n                50735,\n            ]\n            assert exif[256] == 640\n            assert exif[271] == \"FLIR\"\n\n            gps = exif.get_ifd(0x8825)\n            assert list(gps.keys()) == [0, 1, 2, 3, 4, 5, 6, 18]\n            assert gps[0] == b\"\\x03\\x02\\x00\\x00\"\n            assert gps[18] == \"WGS-84\"\n\n        outfile = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/ifd_tag_type.tiff\") as im:\n            exif = im.getexif()\n            check_exif(exif)\n\n            im.save(outfile, exif=exif)\n\n        outfile2 = str(tmp_path / \"temp2.tif\")\n        with Image.open(outfile) as im:\n            exif = im.getexif()\n            check_exif(exif)\n\n            im.save(outfile2, exif=exif.tobytes())\n\n        with Image.open(outfile2) as im:\n            exif = im.getexif()\n            check_exif(exif)\n\n    def test_modify_exif(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n        with Image.open(\"Tests/images/ifd_tag_type.tiff\") as im:\n            exif = im.getexif()\n            exif[264] = 100\n\n            im.save(outfile, exif=exif)\n\n        with Image.open(outfile) as im:\n            exif = im.getexif()\n            assert exif[264] == 100\n\n    def test_reload_exif_after_seek(self) -> None:\n        with Image.open(\"Tests/images/multipage.tiff\") as im:\n            exif = im.getexif()\n            del exif[256]\n            im.seek(1)\n\n            assert 256 in exif\n\n    def test_exif_frames(self) -> None:\n        # Test that EXIF data can change across frames\n        with Image.open(\"Tests/images/g4-multi.tiff\") as im:\n            assert im.getexif()[273] == (328, 815)\n\n            im.seek(1)\n            assert im.getexif()[273] == (1408, 1907)\n\n    @pytest.mark.parametrize(\"mode\", (\"1\", \"L\"))\n    def test_photometric(self, mode: str, tmp_path: Path) -> None:\n        filename = str(tmp_path / \"temp.tif\")\n        im = hopper(mode)\n        im.save(filename, tiffinfo={262: 0})\n        with Image.open(filename) as reloaded:\n            assert reloaded.tag_v2[262] == 0\n            assert_image_equal(im, reloaded)\n\n    def test_seek(self) -> None:\n        filename = \"Tests/images/pil136.tiff\"\n        with Image.open(filename) as im:\n            im.seek(0)\n            assert im.tell() == 0\n\n    def test_seek_eof(self) -> None:\n        filename = \"Tests/images/pil136.tiff\"\n        with Image.open(filename) as im:\n            assert im.tell() == 0\n            with pytest.raises(EOFError):\n                im.seek(-1)\n            with pytest.raises(EOFError):\n                im.seek(1)\n\n    def test__limit_rational_int(self) -> None:\n        from PIL.TiffImagePlugin import _limit_rational\n\n        value = 34\n        ret = _limit_rational(value, 65536)\n        assert ret == (34, 1)\n\n    def test__limit_rational_float(self) -> None:\n        from PIL.TiffImagePlugin import _limit_rational\n\n        value = 22.3\n        ret = _limit_rational(value, 65536)\n        assert ret == (223, 10)\n\n    def test_4bit(self) -> None:\n        test_file = \"Tests/images/hopper_gray_4bpp.tif\"\n        original = hopper(\"L\")\n        with Image.open(test_file) as im:\n            assert im.size == (128, 128)\n            assert im.mode == \"L\"\n            assert_image_similar(im, original, 7.3)\n\n    def test_gray_semibyte_per_pixel(self) -> None:\n        test_files = (\n            (\n                24.8,  # epsilon\n                (  # group\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2I.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2R.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper2IR.tif\",\n                ),\n            ),\n            (\n                7.3,  # epsilon\n                (  # group\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4I.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4R.tif\",\n                    \"Tests/images/tiff_gray_2_4_bpp/hopper4IR.tif\",\n                ),\n            ),\n        )\n        original = hopper(\"L\")\n        for epsilon, group in test_files:\n            with Image.open(group[0]) as im:\n                assert im.size == (128, 128)\n                assert im.mode == \"L\"\n                assert_image_similar(im, original, epsilon)\n                for file in group[1:]:\n                    with Image.open(file) as im2:\n                        assert im2.size == (128, 128)\n                        assert im2.mode == \"L\"\n                        assert_image_equal(im, im2)\n\n    def test_with_underscores(self, tmp_path: Path) -> None:\n        kwargs = {\"resolution_unit\": \"inch\", \"x_resolution\": 72, \"y_resolution\": 36}\n        filename = str(tmp_path / \"temp.tif\")\n        hopper(\"RGB\").save(filename, **kwargs)\n        with Image.open(filename) as im:\n            # legacy interface\n            assert im.tag[X_RESOLUTION][0][0] == 72\n            assert im.tag[Y_RESOLUTION][0][0] == 36\n\n            # v2 interface\n            assert im.tag_v2[X_RESOLUTION] == 72\n            assert im.tag_v2[Y_RESOLUTION] == 36\n\n    def test_roundtrip_tiff_uint16(self, tmp_path: Path) -> None:\n        # Test an image of all '0' values\n        pixel_value = 0x1234\n        infile = \"Tests/images/uint16_1_4660.tif\"\n        with Image.open(infile) as im:\n            assert im.getpixel((0, 0)) == pixel_value\n\n            tmpfile = str(tmp_path / \"temp.tif\")\n            im.save(tmpfile)\n\n            assert_image_equal_tofile(im, tmpfile)\n\n    def test_rowsperstrip(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n        im = hopper()\n        im.save(outfile, tiffinfo={278: 256})\n\n        with Image.open(outfile) as im:\n            assert isinstance(im, TiffImagePlugin.TiffImageFile)\n            assert im.tag_v2[278] == 256\n\n    def test_strip_raw(self) -> None:\n        infile = \"Tests/images/tiff_strip_raw.tif\"\n        with Image.open(infile) as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")\n\n    def test_strip_planar_raw(self) -> None:\n        # gdal_translate -of GTiff -co INTERLEAVE=BAND \\\n        # tiff_strip_raw.tif tiff_strip_planar_raw.tiff\n        infile = \"Tests/images/tiff_strip_planar_raw.tif\"\n        with Image.open(infile) as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")\n\n    def test_strip_planar_raw_with_overviews(self) -> None:\n        # gdaladdo tiff_strip_planar_raw2.tif 2 4 8 16\n        infile = \"Tests/images/tiff_strip_planar_raw_with_overviews.tif\"\n        with Image.open(infile) as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")\n\n    def test_tiled_planar_raw(self) -> None:\n        # gdal_translate -of GTiff -co TILED=YES -co BLOCKXSIZE=32 \\\n        # -co BLOCKYSIZE=32 -co INTERLEAVE=BAND \\\n        # tiff_tiled_raw.tif tiff_tiled_planar_raw.tiff\n        infile = \"Tests/images/tiff_tiled_planar_raw.tif\"\n        with Image.open(infile) as im:\n            assert_image_equal_tofile(im, \"Tests/images/tiff_adobe_deflate.png\")\n\n    def test_planar_configuration_save(self, tmp_path: Path) -> None:\n        infile = \"Tests/images/tiff_tiled_planar_raw.tif\"\n        with Image.open(infile) as im:\n            assert im._planar_configuration == 2\n\n            outfile = str(tmp_path / \"temp.tif\")\n            im.save(outfile)\n\n            with Image.open(outfile) as reloaded:\n                assert_image_equal_tofile(reloaded, infile)\n\n    @pytest.mark.parametrize(\"mode\", (\"P\", \"PA\"))\n    def test_palette(self, mode: str, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n\n        im = hopper(mode)\n        im.save(outfile)\n\n        with Image.open(outfile) as reloaded:\n            assert_image_equal(im.convert(\"RGB\"), reloaded.convert(\"RGB\"))\n\n    def test_tiff_save_all(self) -> None:\n        mp = BytesIO()\n        with Image.open(\"Tests/images/multipage.tiff\") as im:\n            im.save(mp, format=\"tiff\", save_all=True)\n\n        mp.seek(0, os.SEEK_SET)\n        with Image.open(mp) as im:\n            assert im.n_frames == 3\n\n        # Test appending images\n        mp = BytesIO()\n        im = Image.new(\"RGB\", (100, 100), \"#f00\")\n        ims = [Image.new(\"RGB\", (100, 100), color) for color in [\"#0f0\", \"#00f\"]]\n        im.copy().save(mp, format=\"TIFF\", save_all=True, append_images=ims)\n\n        mp.seek(0, os.SEEK_SET)\n        with Image.open(mp) as reread:\n            assert reread.n_frames == 3\n\n        # Test appending using a generator\n        def im_generator(ims: list[Image.Image]) -> Generator[Image.Image, None, None]:\n            yield from ims\n\n        mp = BytesIO()\n        im.save(mp, format=\"TIFF\", save_all=True, append_images=im_generator(ims))\n\n        mp.seek(0, os.SEEK_SET)\n        with Image.open(mp) as reread:\n            assert reread.n_frames == 3\n\n    def test_saving_icc_profile(self, tmp_path: Path) -> None:\n        # Tests saving TIFF with icc_profile set.\n        # At the time of writing this will only work for non-compressed tiffs\n        # as libtiff does not support embedded ICC profiles,\n        # ImageFile._save(..) however does.\n        im = Image.new(\"RGB\", (1, 1))\n        im.info[\"icc_profile\"] = \"Dummy value\"\n\n        # Try save-load round trip to make sure both handle icc_profile.\n        tmpfile = str(tmp_path / \"temp.tif\")\n        im.save(tmpfile, \"TIFF\", compression=\"raw\")\n        with Image.open(tmpfile) as reloaded:\n            assert b\"Dummy value\" == reloaded.info[\"icc_profile\"]\n\n    def test_save_icc_profile(self, tmp_path: Path) -> None:\n        im = hopper()\n        assert \"icc_profile\" not in im.info\n\n        outfile = str(tmp_path / \"temp.tif\")\n        icc_profile = b\"Dummy value\"\n        im.save(outfile, icc_profile=icc_profile)\n\n        with Image.open(outfile) as reloaded:\n            assert reloaded.info[\"icc_profile\"] == icc_profile\n\n    def test_save_bmp_compression(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/hopper.bmp\") as im:\n            assert im.info[\"compression\"] == 0\n\n            outfile = str(tmp_path / \"temp.tif\")\n            im.save(outfile)\n\n    def test_discard_icc_profile(self, tmp_path: Path) -> None:\n        outfile = str(tmp_path / \"temp.tif\")\n\n        with Image.open(\"Tests/images/icc_profile.png\") as im:\n            assert \"icc_profile\" in im.info\n\n            im.save(outfile, icc_profile=None)\n\n        with Image.open(outfile) as reloaded:\n            assert \"icc_profile\" not in reloaded.info\n\n    def test_getxmp(self) -> None:\n        with Image.open(\"Tests/images/lab.tif\") as im:\n            if ElementTree is None:\n                with pytest.warns(\n                    UserWarning,\n                    match=\"XMP data cannot be read without defusedxml dependency\",\n                ):\n                    assert im.getxmp() == {}\n            else:\n                assert \"xmp\" in im.info\n                xmp = im.getxmp()\n\n                description = xmp[\"xmpmeta\"][\"RDF\"][\"Description\"]\n                assert description[0][\"format\"] == \"image/tiff\"\n                assert description[3][\"BitsPerSample\"][\"Seq\"][\"li\"] == [\"8\", \"8\", \"8\"]\n\n    def test_get_photoshop_blocks(self) -> None:\n        with Image.open(\"Tests/images/lab.tif\") as im:\n            assert list(im.get_photoshop_blocks().keys()) == [\n                1061,\n                1002,\n                1005,\n                1062,\n                1037,\n                1049,\n                1011,\n                1034,\n                10000,\n                1013,\n                1016,\n                1032,\n                1054,\n                1050,\n                1064,\n                1041,\n                1044,\n                1036,\n                1057,\n                4000,\n                4001,\n            ]\n\n    def test_tiff_chunks(self, tmp_path: Path) -> None:\n        tmpfile = str(tmp_path / \"temp.tif\")\n\n        im = hopper()\n        with open(tmpfile, \"wb\") as fp:\n            for y in range(0, 128, 32):\n                chunk = im.crop((0, y, 128, y + 32))\n                if y == 0:\n                    chunk.save(\n                        fp,\n                        \"TIFF\",\n                        tiffinfo={\n                            TiffImagePlugin.IMAGEWIDTH: 128,\n                            TiffImagePlugin.IMAGELENGTH: 128,\n                        },\n                    )\n                else:\n                    fp.write(chunk.tobytes())\n\n        assert_image_equal_tofile(im, tmpfile)\n\n    def test_close_on_load_exclusive(self, tmp_path: Path) -> None:\n        # similar to test_fd_leak, but runs on unixlike os\n        tmpfile = str(tmp_path / \"temp.tif\")\n\n        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:\n            im.save(tmpfile)\n\n        im = Image.open(tmpfile)\n        fp = im.fp\n        assert not fp.closed\n        im.load()\n        assert fp.closed\n\n    def test_close_on_load_nonexclusive(self, tmp_path: Path) -> None:\n        tmpfile = str(tmp_path / \"temp.tif\")\n\n        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:\n            im.save(tmpfile)\n\n        with open(tmpfile, \"rb\") as f:\n            im = Image.open(f)\n            fp = im.fp\n            assert not fp.closed\n            im.load()\n            assert not fp.closed\n\n    # Ignore this UserWarning which triggers for four tags:\n    # \"Possibly corrupt EXIF data.  Expecting to read 50404352 bytes but...\"\n    @pytest.mark.filterwarnings(\"ignore:Possibly corrupt EXIF data\")\n    # Ignore this UserWarning:\n    @pytest.mark.filterwarnings(\"ignore:Truncated File Read\")\n    @pytest.mark.skipif(\n        not os.path.exists(\"Tests/images/string_dimension.tiff\"),\n        reason=\"Extra image files not installed\",\n    )\n    def test_string_dimension(self) -> None:\n        # Assert that an error is raised if one of the dimensions is a string\n        with Image.open(\"Tests/images/string_dimension.tiff\") as im:\n            with pytest.raises(OSError):\n                im.load()\n\n    @pytest.mark.timeout(6)\n    @pytest.mark.filterwarnings(\"ignore:Truncated File Read\")\n    def test_timeout(self) -> None:\n        with Image.open(\"Tests/images/timeout-6646305047838720\") as im:\n            ImageFile.LOAD_TRUNCATED_IMAGES = True\n            im.load()\n            ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    @pytest.mark.parametrize(\n        \"test_file\",\n        [\n            \"Tests/images/oom-225817ca0f8c663be7ab4b9e717b02c661e66834.tif\",\n        ],\n    )\n    @pytest.mark.timeout(2)\n    def test_oom(self, test_file: str) -> None:\n        with pytest.raises(UnidentifiedImageError):\n            with pytest.warns(UserWarning):\n                with Image.open(test_file):\n                    pass\n\n\n@pytest.mark.skipif(not is_win32(), reason=\"Windows only\")\nclass TestFileTiffW32:\n    def test_fd_leak(self, tmp_path: Path) -> None:\n        tmpfile = str(tmp_path / \"temp.tif\")\n\n        # this is an mmaped file.\n        with Image.open(\"Tests/images/uint16_1_4660.tif\") as im:\n            im.save(tmpfile)\n\n        im = Image.open(tmpfile)\n        fp = im.fp\n        assert not fp.closed\n        with pytest.raises(OSError):\n            os.remove(tmpfile)\n        im.load()\n        assert fp.closed\n\n        # this closes the mmap\n        im.close()\n\n        # this should not fail, as load should have closed the file pointer,\n        # and close should have closed the mmap\n        os.remove(tmpfile)\n", "Tests/test_file_jpeg2k.py": "from __future__ import annotations\n\nimport os\nimport re\nfrom io import BytesIO\nfrom pathlib import Path\nfrom typing import Any\n\nimport pytest\n\nfrom PIL import (\n    Image,\n    ImageFile,\n    Jpeg2KImagePlugin,\n    UnidentifiedImageError,\n    _binary,\n    features,\n)\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    skip_unless_feature,\n    skip_unless_feature_version,\n)\n\nEXTRA_DIR = \"Tests/images/jpeg2000\"\n\npytestmark = skip_unless_feature(\"jpg_2000\")\n\ntest_card = Image.open(\"Tests/images/test-card.png\")\ntest_card.load()\n\n# OpenJPEG 2.0.0 outputs this debugging message sometimes; we should\n# ignore it---it doesn't represent a test failure.\n# 'Not enough memory to handle tile data'\n\n\ndef roundtrip(im: Image.Image, **options: Any) -> Image.Image:\n    out = BytesIO()\n    im.save(out, \"JPEG2000\", **options)\n    out.seek(0)\n    with Image.open(out) as im:\n        im.load()\n    return im\n\n\ndef test_sanity() -> None:\n    # Internal version number\n    version = features.version_codec(\"jpg_2000\")\n    assert version is not None\n    assert re.search(r\"\\d+\\.\\d+\\.\\d+$\", version)\n\n    with Image.open(\"Tests/images/test-card-lossless.jp2\") as im:\n        px = im.load()\n        assert px[0, 0] == (0, 0, 0)\n        assert im.mode == \"RGB\"\n        assert im.size == (640, 480)\n        assert im.format == \"JPEG2000\"\n        assert im.get_format_mimetype() == \"image/jp2\"\n\n\ndef test_jpf() -> None:\n    with Image.open(\"Tests/images/balloon.jpf\") as im:\n        assert im.format == \"JPEG2000\"\n        assert im.get_format_mimetype() == \"image/jpx\"\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        Jpeg2KImagePlugin.Jpeg2KImageFile(invalid_file)\n\n\ndef test_bytesio() -> None:\n    with open(\"Tests/images/test-card-lossless.jp2\", \"rb\") as f:\n        data = BytesIO(f.read())\n    with Image.open(data) as im:\n        im.load()\n        assert_image_similar(im, test_card, 1.0e-3)\n\n\n# These two test pre-written JPEG 2000 files that were not written with\n# PIL (they were made using Adobe Photoshop)\n\n\ndef test_lossless(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/test-card-lossless.jp2\") as im:\n        im.load()\n        outfile = str(tmp_path / \"temp_test-card.png\")\n        im.save(outfile)\n    assert_image_similar(im, test_card, 1.0e-3)\n\n\ndef test_lossy_tiled() -> None:\n    assert_image_similar_tofile(\n        test_card, \"Tests/images/test-card-lossy-tiled.jp2\", 2.0\n    )\n\n\ndef test_lossless_rt() -> None:\n    im = roundtrip(test_card)\n    assert_image_equal(im, test_card)\n\n\ndef test_lossy_rt() -> None:\n    im = roundtrip(test_card, quality_layers=[20])\n    assert_image_similar(im, test_card, 2.0)\n\n\ndef test_tiled_rt() -> None:\n    im = roundtrip(test_card, tile_size=(128, 128))\n    assert_image_equal(im, test_card)\n\n\ndef test_tiled_offset_rt() -> None:\n    im = roundtrip(test_card, tile_size=(128, 128), tile_offset=(0, 0), offset=(32, 32))\n    assert_image_equal(im, test_card)\n\n\ndef test_tiled_offset_too_small() -> None:\n    with pytest.raises(ValueError):\n        roundtrip(test_card, tile_size=(128, 128), tile_offset=(0, 0), offset=(128, 32))\n\n\ndef test_irreversible_rt() -> None:\n    im = roundtrip(test_card, irreversible=True, quality_layers=[20])\n    assert_image_similar(im, test_card, 2.0)\n\n\ndef test_prog_qual_rt() -> None:\n    im = roundtrip(test_card, quality_layers=[60, 40, 20], progression=\"LRCP\")\n    assert_image_similar(im, test_card, 2.0)\n\n\ndef test_prog_res_rt() -> None:\n    im = roundtrip(test_card, num_resolutions=8, progression=\"RLCP\")\n    assert_image_equal(im, test_card)\n\n\n@pytest.mark.parametrize(\"num_resolutions\", range(2, 6))\ndef test_default_num_resolutions(num_resolutions: int) -> None:\n    d = 1 << (num_resolutions - 1)\n    im = test_card.resize((d - 1, d - 1))\n    with pytest.raises(OSError):\n        roundtrip(im, num_resolutions=num_resolutions)\n    reloaded = roundtrip(im)\n    assert_image_equal(im, reloaded)\n\n\ndef test_reduce() -> None:\n    with Image.open(\"Tests/images/test-card-lossless.jp2\") as im:\n        assert callable(im.reduce)\n\n        im.reduce = 2\n        assert im.reduce == 2\n\n        im.load()\n        assert im.size == (160, 120)\n\n        im.thumbnail((40, 40))\n        assert im.size == (40, 30)\n\n\ndef test_load_dpi() -> None:\n    with Image.open(\"Tests/images/test-card-lossless.jp2\") as im:\n        assert im.info[\"dpi\"] == (71.9836, 71.9836)\n\n    with Image.open(\"Tests/images/zero_dpi.jp2\") as im:\n        assert \"dpi\" not in im.info\n\n\ndef test_restricted_icc_profile() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = True\n    try:\n        # JPEG2000 image with a restricted ICC profile and a known colorspace\n        with Image.open(\"Tests/images/balloon_eciRGBv2_aware.jp2\") as im:\n            assert im.mode == \"RGB\"\n    finally:\n        ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n\ndef test_header_errors() -> None:\n    for path in (\n        \"Tests/images/invalid_header_length.jp2\",\n        \"Tests/images/not_enough_data.jp2\",\n    ):\n        with pytest.raises(UnidentifiedImageError):\n            with Image.open(path):\n                pass\n\n    with pytest.raises(OSError):\n        with Image.open(\"Tests/images/expected_to_read.jp2\"):\n            pass\n\n\ndef test_layers_type(tmp_path: Path) -> None:\n    outfile = str(tmp_path / \"temp_layers.jp2\")\n    for quality_layers in [[100, 50, 10], (100, 50, 10), None]:\n        test_card.save(outfile, quality_layers=quality_layers)\n\n    for quality_layers_str in [\"quality_layers\", (\"100\", \"50\", \"10\")]:\n        with pytest.raises(ValueError):\n            test_card.save(outfile, quality_layers=quality_layers_str)\n\n\ndef test_layers() -> None:\n    out = BytesIO()\n    test_card.save(out, \"JPEG2000\", quality_layers=[100, 50, 10], progression=\"LRCP\")\n    out.seek(0)\n\n    with Image.open(out) as im:\n        im.layers = 1\n        im.load()\n        assert_image_similar(im, test_card, 13)\n\n    out.seek(0)\n    with Image.open(out) as im:\n        im.layers = 3\n        im.load()\n        assert_image_similar(im, test_card, 0.4)\n\n\n@pytest.mark.parametrize(\n    \"name, args, offset, data\",\n    (\n        (\"foo.j2k\", {}, 0, b\"\\xff\\x4f\"),\n        (\"foo.jp2\", {}, 4, b\"jP\"),\n        (None, {\"no_jp2\": True}, 0, b\"\\xff\\x4f\"),\n        (\"foo.j2k\", {\"no_jp2\": True}, 0, b\"\\xff\\x4f\"),\n        (\"foo.jp2\", {\"no_jp2\": True}, 0, b\"\\xff\\x4f\"),\n        (\"foo.j2k\", {\"no_jp2\": False}, 0, b\"\\xff\\x4f\"),\n        (\"foo.jp2\", {\"no_jp2\": False}, 4, b\"jP\"),\n        (\"foo.jp2\", {\"no_jp2\": False}, 4, b\"jP\"),\n    ),\n)\ndef test_no_jp2(name: str, args: dict[str, bool], offset: int, data: bytes) -> None:\n    out = BytesIO()\n    if name:\n        out.name = name\n    test_card.save(out, \"JPEG2000\", **args)\n    out.seek(offset)\n    assert out.read(2) == data\n\n\ndef test_mct() -> None:\n    # Three component\n    for val in (0, 1):\n        out = BytesIO()\n        test_card.save(out, \"JPEG2000\", mct=val, no_jp2=True)\n\n        assert out.getvalue()[59] == val\n        with Image.open(out) as im:\n            assert_image_similar(im, test_card, 1.0e-3)\n\n    # Single component should have MCT disabled\n    for val in (0, 1):\n        out = BytesIO()\n        with Image.open(\"Tests/images/16bit.cropped.jp2\") as jp2:\n            jp2.save(out, \"JPEG2000\", mct=val, no_jp2=True)\n\n        assert out.getvalue()[53] == 0\n        with Image.open(out) as im:\n            assert_image_similar(im, jp2, 1.0e-3)\n\n\ndef test_sgnd(tmp_path: Path) -> None:\n    outfile = str(tmp_path / \"temp.jp2\")\n\n    im = Image.new(\"L\", (1, 1))\n    im.save(outfile)\n    with Image.open(outfile) as reloaded:\n        assert reloaded.getpixel((0, 0)) == 0\n\n    im = Image.new(\"L\", (1, 1))\n    im.save(outfile, signed=True)\n    with Image.open(outfile) as reloaded_signed:\n        assert reloaded_signed.getpixel((0, 0)) == 128\n\n\n@pytest.mark.parametrize(\"ext\", (\".j2k\", \".jp2\"))\ndef test_rgba(ext: str) -> None:\n    # Arrange\n    with Image.open(\"Tests/images/rgb_trns_ycbc\" + ext) as im:\n        # Act\n        im.load()\n\n        # Assert\n        assert im.mode == \"RGBA\"\n\n\n@pytest.mark.skipif(\n    not os.path.exists(EXTRA_DIR), reason=\"Extra image files not installed\"\n)\n@skip_unless_feature_version(\"jpg_2000\", \"2.5.1\")\ndef test_cmyk() -> None:\n    with Image.open(f\"{EXTRA_DIR}/issue205.jp2\") as im:\n        assert im.mode == \"CMYK\"\n        assert im.getpixel((0, 0)) == (185, 134, 0, 0)\n\n\n@pytest.mark.parametrize(\"ext\", (\".j2k\", \".jp2\"))\ndef test_16bit_monochrome_has_correct_mode(ext: str) -> None:\n    with Image.open(\"Tests/images/16bit.cropped\" + ext) as im:\n        im.load()\n        assert im.mode == \"I;16\"\n\n\ndef test_16bit_monochrome_jp2_like_tiff() -> None:\n    with Image.open(\"Tests/images/16bit.cropped.tif\") as tiff_16bit:\n        assert_image_similar_tofile(tiff_16bit, \"Tests/images/16bit.cropped.jp2\", 1e-3)\n\n\ndef test_16bit_monochrome_j2k_like_tiff() -> None:\n    with Image.open(\"Tests/images/16bit.cropped.tif\") as tiff_16bit:\n        assert_image_similar_tofile(tiff_16bit, \"Tests/images/16bit.cropped.j2k\", 1e-3)\n\n\ndef test_16bit_j2k_roundtrips() -> None:\n    with Image.open(\"Tests/images/16bit.cropped.j2k\") as j2k:\n        im = roundtrip(j2k)\n        assert_image_equal(im, j2k)\n\n\ndef test_16bit_jp2_roundtrips() -> None:\n    with Image.open(\"Tests/images/16bit.cropped.jp2\") as jp2:\n        im = roundtrip(jp2)\n        assert_image_equal(im, jp2)\n\n\ndef test_issue_6194() -> None:\n    with Image.open(\"Tests/images/issue_6194.j2k\") as im:\n        assert im.getpixel((5, 5)) == 31\n\n\ndef test_unbound_local() -> None:\n    # prepatch, a malformed jp2 file could cause an UnboundLocalError exception.\n    with pytest.raises(OSError):\n        with Image.open(\"Tests/images/unbound_variable.jp2\"):\n            pass\n\n\ndef test_parser_feed() -> None:\n    # Arrange\n    with open(\"Tests/images/test-card-lossless.jp2\", \"rb\") as f:\n        data = f.read()\n\n    # Act\n    p = ImageFile.Parser()\n    p.feed(data)\n\n    # Assert\n    assert p.image is not None\n    assert p.image.size == (640, 480)\n\n\n@pytest.mark.skipif(\n    not os.path.exists(EXTRA_DIR), reason=\"Extra image files not installed\"\n)\n@pytest.mark.parametrize(\"name\", (\"subsampling_1\", \"subsampling_2\", \"zoo1\", \"zoo2\"))\ndef test_subsampling_decode(name: str) -> None:\n    test = f\"{EXTRA_DIR}/{name}.jp2\"\n    reference = f\"{EXTRA_DIR}/{name}.ppm\"\n\n    with Image.open(test) as im:\n        epsilon = 3.0  # for YCbCr images\n        with Image.open(reference) as im2:\n            width, height = im2.size\n            if name[-1] == \"2\":\n                # RGB reference images are downscaled\n                epsilon = 3e-3\n                width, height = width * 2, height * 2\n            expected = im2.resize((width, height), Image.Resampling.NEAREST)\n        assert_image_similar(im, expected, epsilon)\n\n\n@pytest.mark.skipif(\n    not os.path.exists(EXTRA_DIR), reason=\"Extra image files not installed\"\n)\ndef test_pclr() -> None:\n    with Image.open(f\"{EXTRA_DIR}/issue104_jpxstream.jp2\") as im:\n        assert im.mode == \"P\"\n        assert len(im.palette.colors) == 256\n        assert im.palette.colors[(255, 255, 255)] == 0\n\n\ndef test_comment() -> None:\n    with Image.open(\"Tests/images/comment.jp2\") as im:\n        assert im.info[\"comment\"] == b\"Created by OpenJPEG version 2.5.0\"\n\n    # Test an image that is truncated partway through a codestream\n    with open(\"Tests/images/comment.jp2\", \"rb\") as fp:\n        b = BytesIO(fp.read(130))\n        with Image.open(b) as im:\n            pass\n\n\ndef test_save_comment() -> None:\n    for comment in (\"Created by Pillow\", b\"Created by Pillow\"):\n        out = BytesIO()\n        test_card.save(out, \"JPEG2000\", comment=comment)\n\n        with Image.open(out) as im:\n            assert im.info[\"comment\"] == b\"Created by Pillow\"\n\n    out = BytesIO()\n    long_comment = b\" \" * 65531\n    test_card.save(out, \"JPEG2000\", comment=long_comment)\n    with Image.open(out) as im:\n        assert im.info[\"comment\"] == long_comment\n\n    with pytest.raises(ValueError):\n        test_card.save(out, \"JPEG2000\", comment=long_comment + b\" \")\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\n        \"Tests/images/crash-4fb027452e6988530aa5dabee76eecacb3b79f8a.j2k\",\n        \"Tests/images/crash-7d4c83eb92150fb8f1653a697703ae06ae7c4998.j2k\",\n        \"Tests/images/crash-ccca68ff40171fdae983d924e127a721cab2bd50.j2k\",\n        \"Tests/images/crash-d2c93af851d3ab9a19e34503626368b2ecde9c03.j2k\",\n    ],\n)\ndef test_crashes(test_file: str) -> None:\n    with open(test_file, \"rb\") as f:\n        with Image.open(f) as im:\n            # Valgrind should not complain here\n            try:\n                im.load()\n            except OSError:\n                pass\n\n\n@skip_unless_feature_version(\"jpg_2000\", \"2.4.0\")\ndef test_plt_marker() -> None:\n    # Search the start of the codesteam for PLT\n    out = BytesIO()\n    test_card.save(out, \"JPEG2000\", no_jp2=True, plt=True)\n    out.seek(0)\n    while True:\n        marker = out.read(2)\n        if not marker:\n            pytest.fail(\"End of stream without PLT\")\n\n        jp2_boxid = _binary.i16be(marker)\n        if jp2_boxid == 0xFF4F:\n            # SOC has no length\n            continue\n        elif jp2_boxid == 0xFF58:\n            # PLT\n            return\n        elif jp2_boxid == 0xFF93:\n            pytest.fail(\"SOD without finding PLT first\")\n\n        hdr = out.read(2)\n        length = _binary.i16be(hdr)\n        out.seek(length - 2, os.SEEK_CUR)\n\n\ndef test_9bit() -> None:\n    with Image.open(\"Tests/images/9bit.j2k\") as im:\n        assert im.mode == \"I;16\"\n        assert im.size == (128, 128)\n", "Tests/test_image_putpalette.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImagePalette\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, hopper\n\n\ndef test_putpalette() -> None:\n    def palette(mode: str) -> str | tuple[str, list[int]]:\n        im = hopper(mode).copy()\n        im.putpalette(list(range(256)) * 3)\n        p = im.getpalette()\n        if p:\n            return im.mode, p[:10]\n        return im.mode\n\n    with pytest.raises(ValueError):\n        palette(\"1\")\n    for mode in [\"L\", \"LA\", \"P\", \"PA\"]:\n        assert palette(mode) == (\n            \"PA\" if \"A\" in mode else \"P\",\n            [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n        )\n    with pytest.raises(ValueError):\n        palette(\"I\")\n    with pytest.raises(ValueError):\n        palette(\"F\")\n    with pytest.raises(ValueError):\n        palette(\"RGB\")\n    with pytest.raises(ValueError):\n        palette(\"RGBA\")\n    with pytest.raises(ValueError):\n        palette(\"YCbCr\")\n\n    with Image.open(\"Tests/images/hopper_gray.jpg\") as im:\n        assert im.mode == \"L\"\n        im.putpalette(list(range(256)) * 3)\n\n    with Image.open(\"Tests/images/la.tga\") as im:\n        assert im.mode == \"LA\"\n        im.putpalette(list(range(256)) * 3)\n\n\ndef test_imagepalette() -> None:\n    im = hopper(\"P\")\n    im.putpalette(ImagePalette.negative())\n    assert_image_equal_tofile(im.convert(\"RGB\"), \"Tests/images/palette_negative.png\")\n\n    im.putpalette(ImagePalette.random())\n\n    im.putpalette(ImagePalette.sepia())\n    assert_image_equal_tofile(im.convert(\"RGB\"), \"Tests/images/palette_sepia.png\")\n\n    im.putpalette(ImagePalette.wedge())\n    assert_image_equal_tofile(im.convert(\"RGB\"), \"Tests/images/palette_wedge.png\")\n\n\ndef test_putpalette_with_alpha_values() -> None:\n    with Image.open(\"Tests/images/transparent.gif\") as im:\n        expected = im.convert(\"RGBA\")\n\n        palette = im.getpalette()\n        transparency = im.info.pop(\"transparency\")\n\n        palette_with_alpha_values = []\n        for i in range(256):\n            color = palette[i * 3 : i * 3 + 3]\n            alpha = 0 if i == transparency else 255\n            palette_with_alpha_values += color + [alpha]\n        im.putpalette(palette_with_alpha_values, \"RGBA\")\n\n        assert_image_equal(im.convert(\"RGBA\"), expected)\n\n\n@pytest.mark.parametrize(\n    \"mode, palette\",\n    (\n        (\"RGBA\", (1, 2, 3, 4)),\n        (\"RGBAX\", (1, 2, 3, 4, 0)),\n        (\"ARGB\", (4, 1, 2, 3)),\n    ),\n)\ndef test_rgba_palette(mode: str, palette: tuple[int, ...]) -> None:\n    im = Image.new(\"P\", (1, 1))\n    im.putpalette(palette, mode)\n    assert im.getpalette() == [1, 2, 3]\n    assert im.palette.colors == {(1, 2, 3, 4): 0}\n\n\ndef test_empty_palette() -> None:\n    im = Image.new(\"P\", (1, 1))\n    assert im.getpalette() == []\n\n\ndef test_undefined_palette_index() -> None:\n    im = Image.new(\"P\", (1, 1), 3)\n    im.putpalette((1, 2, 3))\n    assert im.convert(\"RGB\").getpixel((0, 0)) == (0, 0, 0)\n", "Tests/test_file_imt.py": "from __future__ import annotations\n\nimport io\n\nimport pytest\n\nfrom PIL import Image, ImtImagePlugin\n\nfrom .helper import assert_image_equal_tofile\n\n\ndef test_sanity() -> None:\n    with Image.open(\"Tests/images/bw_gradient.imt\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/bw_gradient.png\")\n\n\n@pytest.mark.parametrize(\"data\", (b\"\\n\", b\"\\n-\", b\"width 1\\n\"))\ndef test_invalid_file(data: bytes) -> None:\n    with io.BytesIO(data) as fp:\n        with pytest.raises(SyntaxError):\n            ImtImagePlugin.ImtImageFile(fp)\n", "Tests/test_file_webp_alpha.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    hopper,\n)\n\n_webp = pytest.importorskip(\"PIL._webp\", reason=\"WebP support not installed\")\n\n\ndef setup_module() -> None:\n    if _webp.WebPDecoderBuggyAlpha():\n        pytest.skip(\"Buggy early version of WebP installed, not testing transparency\")\n\n\ndef test_read_rgba() -> None:\n    \"\"\"\n    Can we read an RGBA mode file without error?\n    Does it have the bits we expect?\n    \"\"\"\n\n    # Generated with `cwebp transparent.png -o transparent.webp`\n    file_path = \"Tests/images/transparent.webp\"\n    with Image.open(file_path) as image:\n        assert image.mode == \"RGBA\"\n        assert image.size == (200, 150)\n        assert image.format == \"WEBP\"\n        image.load()\n        image.getdata()\n\n        image.tobytes()\n\n        assert_image_similar_tofile(image, \"Tests/images/transparent.png\", 20.0)\n\n\ndef test_write_lossless_rgb(tmp_path: Path) -> None:\n    \"\"\"\n    Can we write an RGBA mode file with lossless compression without error?\n    Does it have the bits we expect?\n    \"\"\"\n\n    temp_file = str(tmp_path / \"temp.webp\")\n    # temp_file = \"temp.webp\"\n\n    pil_image = hopper(\"RGBA\")\n\n    mask = Image.new(\"RGBA\", (64, 64), (128, 128, 128, 128))\n    # Add some partially transparent bits:\n    pil_image.paste(mask, (0, 0), mask)\n\n    pil_image.save(temp_file, lossless=True)\n\n    with Image.open(temp_file) as image:\n        image.load()\n\n        assert image.mode == \"RGBA\"\n        assert image.size == pil_image.size\n        assert image.format == \"WEBP\"\n        image.load()\n        image.getdata()\n\n        assert_image_equal(image, pil_image)\n\n\ndef test_write_rgba(tmp_path: Path) -> None:\n    \"\"\"\n    Can we write a RGBA mode file to WebP without error.\n    Does it have the bits we expect?\n    \"\"\"\n\n    temp_file = str(tmp_path / \"temp.webp\")\n\n    pil_image = Image.new(\"RGBA\", (10, 10), (255, 0, 0, 20))\n    pil_image.save(temp_file)\n\n    if _webp.WebPDecoderBuggyAlpha():\n        return\n\n    with Image.open(temp_file) as image:\n        image.load()\n\n        assert image.mode == \"RGBA\"\n        assert image.size == (10, 10)\n        assert image.format == \"WEBP\"\n        image.load()\n        image.getdata()\n\n        # Early versions of WebP are known to produce higher deviations:\n        # deal with it\n        if _webp.WebPDecoderVersion() <= 0x201:\n            assert_image_similar(image, pil_image, 3.0)\n        else:\n            assert_image_similar(image, pil_image, 1.0)\n\n\ndef test_keep_rgb_values_when_transparent(tmp_path: Path) -> None:\n    \"\"\"\n    Saving transparent pixels should retain their original RGB values\n    when using the \"exact\" parameter.\n    \"\"\"\n\n    image = hopper(\"RGB\")\n\n    # create a copy of the image\n    # with the left half transparent\n    half_transparent_image = image.copy()\n    new_alpha = Image.new(\"L\", (128, 128), 255)\n    new_alpha.paste(0, (0, 0, 64, 128))\n    half_transparent_image.putalpha(new_alpha)\n\n    # save with transparent area preserved\n    temp_file = str(tmp_path / \"temp.webp\")\n    half_transparent_image.save(temp_file, exact=True, lossless=True)\n\n    with Image.open(temp_file) as reloaded:\n        assert reloaded.mode == \"RGBA\"\n        assert reloaded.format == \"WEBP\"\n\n        # even though it is lossless, if we don't use exact=True\n        # in libwebp >= 0.5, the transparent area will be filled with black\n        # (or something more conducive to compression)\n        assert_image_equal(reloaded.convert(\"RGB\"), image)\n\n\ndef test_write_unsupported_mode_PA(tmp_path: Path) -> None:\n    \"\"\"\n    Saving a palette-based file with transparency to WebP format\n    should work, and be similar to the original file.\n    \"\"\"\n\n    temp_file = str(tmp_path / \"temp.webp\")\n    file_path = \"Tests/images/transparent.gif\"\n    with Image.open(file_path) as im:\n        im.save(temp_file)\n    with Image.open(temp_file) as image:\n        assert image.mode == \"RGBA\"\n        assert image.size == (200, 150)\n        assert image.format == \"WEBP\"\n\n        image.load()\n        image.getdata()\n        with Image.open(file_path) as im:\n            target = im.convert(\"RGBA\")\n\n        assert_image_similar(image, target, 25.0)\n\n\ndef test_alpha_quality(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/transparent.png\") as im:\n        out = str(tmp_path / \"temp.webp\")\n        im.save(out)\n\n        out_quality = str(tmp_path / \"quality.webp\")\n        im.save(out_quality, alpha_quality=50)\n        with Image.open(out) as reloaded:\n            with Image.open(out_quality) as reloaded_quality:\n                assert reloaded.tobytes() != reloaded_quality.tobytes()\n", "Tests/check_imaging_leaks.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nfrom typing import Any, Callable\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import is_win32\n\nmin_iterations = 100\nmax_iterations = 10000\n\npytestmark = pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\")\n\n\ndef _get_mem_usage() -> float:\n    from resource import RUSAGE_SELF, getpagesize, getrusage\n\n    mem = getrusage(RUSAGE_SELF).ru_maxrss\n    return mem * getpagesize() / 1024 / 1024\n\n\ndef _test_leak(\n    min_iterations: int,\n    max_iterations: int,\n    fn: Callable[..., Image.Image | None],\n    *args: Any,\n) -> None:\n    mem_limit = None\n    for i in range(max_iterations):\n        fn(*args)\n        mem = _get_mem_usage()\n        if i < min_iterations:\n            mem_limit = mem + 1\n            continue\n        msg = f\"memory usage limit exceeded after {i + 1} iterations\"\n        assert mem_limit is not None\n        assert mem <= mem_limit, msg\n\n\ndef test_leak_putdata() -> None:\n    im = Image.new(\"RGB\", (25, 25))\n    _test_leak(min_iterations, max_iterations, im.putdata, im.getdata())\n\n\ndef test_leak_getlist() -> None:\n    im = Image.new(\"P\", (25, 25))\n    _test_leak(\n        min_iterations,\n        max_iterations,\n        # Pass a new list at each iteration.\n        lambda: im.point(range(256)),\n    )\n", "Tests/test_imagedraw2.py": "from __future__ import annotations\n\nimport os.path\n\nimport pytest\n\nfrom PIL import Image, ImageDraw, ImageDraw2, features\nfrom PIL._typing import Coords\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar_tofile,\n    hopper,\n    skip_unless_feature,\n)\n\nBLACK = (0, 0, 0)\nWHITE = (255, 255, 255)\nGRAY = (190, 190, 190)\nDEFAULT_MODE = \"RGB\"\nIMAGES_PATH = os.path.join(\"Tests\", \"images\", \"imagedraw\")\n\n# Image size\nW, H = 100, 100\n\n# Bounding box points\nX0 = int(W / 4)\nX1 = int(X0 * 3)\nY0 = int(H / 4)\nY1 = int(X0 * 3)\n\n# Bounding boxes\nBBOX = (((X0, Y0), (X1, Y1)), [(X0, Y0), (X1, Y1)], (X0, Y0, X1, Y1), [X0, Y0, X1, Y1])\n\n# Coordinate sequences\nPOINTS = (\n    ((10, 10), (20, 40), (30, 30)),\n    [(10, 10), (20, 40), (30, 30)],\n    (10, 10, 20, 40, 30, 30),\n    [10, 10, 20, 40, 30, 30],\n)\n\nFONT_PATH = \"Tests/fonts/FreeMono.ttf\"\n\n\ndef test_sanity() -> None:\n    im = hopper(\"RGB\").copy()\n\n    draw = ImageDraw2.Draw(im)\n    pen = ImageDraw2.Pen(\"blue\", width=7)\n    draw.line(list(range(10)), pen)\n\n    draw2, handler = ImageDraw.getdraw(im)\n    assert draw2 is not None\n    pen = ImageDraw2.Pen(\"blue\", width=7)\n    draw2.line(list(range(10)), pen)\n\n\ndef test_mode() -> None:\n    draw = ImageDraw2.Draw(\"L\", (1, 1))\n    assert draw.image.mode == \"L\"\n\n    with pytest.raises(ValueError):\n        ImageDraw2.Draw(\"L\")\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_ellipse(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    pen = ImageDraw2.Pen(\"blue\", width=2)\n    brush = ImageDraw2.Brush(\"green\")\n\n    # Act\n    draw.ellipse(bbox, pen, brush)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_ellipse_RGB.png\", 1)\n\n\ndef test_ellipse_edge() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    brush = ImageDraw2.Brush(\"white\")\n\n    # Act\n    draw.ellipse(((0, 0), (W - 1, H - 1)), brush)\n\n    # Assert\n    assert_image_similar_tofile(im, \"Tests/images/imagedraw_ellipse_edge.png\", 1)\n\n\n@pytest.mark.parametrize(\"points\", POINTS)\ndef test_line(points: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    pen = ImageDraw2.Pen(\"yellow\", width=2)\n\n    # Act\n    draw.line(points, pen)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_line.png\")\n\n\n@pytest.mark.parametrize(\"points\", POINTS)\ndef test_line_pen_as_brush(points: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    pen = None\n    brush = ImageDraw2.Pen(\"yellow\", width=2)\n\n    # Act\n    # Pass in the pen as the brush parameter\n    draw.line(points, pen, brush)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_line.png\")\n\n\n@pytest.mark.parametrize(\"points\", POINTS)\ndef test_polygon(points: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    pen = ImageDraw2.Pen(\"blue\", width=2)\n    brush = ImageDraw2.Brush(\"red\")\n\n    # Act\n    draw.polygon(points, pen, brush)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_polygon.png\")\n\n\n@pytest.mark.parametrize(\"bbox\", BBOX)\ndef test_rectangle(bbox: Coords) -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    pen = ImageDraw2.Pen(\"green\", width=2)\n    brush = ImageDraw2.Brush(\"black\")\n\n    # Act\n    draw.rectangle(bbox, pen, brush)\n\n    # Assert\n    assert_image_equal_tofile(im, \"Tests/images/imagedraw_rectangle.png\")\n\n\ndef test_big_rectangle() -> None:\n    # Test drawing a rectangle bigger than the image\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    bbox = [(-1, -1), (W + 1, H + 1)]\n    brush = ImageDraw2.Brush(\"orange\")\n    draw = ImageDraw2.Draw(im)\n    expected = \"Tests/images/imagedraw_big_rectangle.png\"\n\n    # Act\n    draw.rectangle(bbox, brush)\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 1)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_text() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    font = ImageDraw2.Font(\"white\", FONT_PATH)\n    expected = \"Tests/images/imagedraw2_text.png\"\n\n    # Act\n    draw.text((5, 5), \"ImageDraw2\", font)\n\n    # Assert\n    assert_image_similar_tofile(im, expected, 13)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_textbbox() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    font = ImageDraw2.Font(\"white\", FONT_PATH)\n\n    # Act\n    bbox = draw.textbbox((0, 0), \"ImageDraw2\", font)\n\n    # Assert\n    right = 72 if features.check_feature(\"raqm\") else 70\n    assert bbox == (0, 2, right, 12)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_textsize_empty_string() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    font = ImageDraw2.Font(\"white\", FONT_PATH)\n\n    # Act\n    # Should not cause 'SystemError: <built-in method getsize of\n    # ImagingFont object at 0x...> returned NULL without setting an error'\n    draw.textbbox((0, 0), \"\", font)\n    draw.textbbox((0, 0), \"\\n\", font)\n    draw.textbbox((0, 0), \"test\\n\", font)\n    draw.textlength(\"\", font)\n\n\n@skip_unless_feature(\"freetype2\")\ndef test_flush() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (W, H))\n    draw = ImageDraw2.Draw(im)\n    font = ImageDraw2.Font(\"white\", FONT_PATH)\n\n    # Act\n    draw.text((5, 5), \"ImageDraw2\", font)\n    im2 = draw.flush()\n\n    # Assert\n    assert_image_equal(im, im2)\n", "Tests/32bit_segfault_check.py": "#!/usr/bin/env python3\nfrom __future__ import annotations\n\nimport sys\n\nfrom PIL import Image\n\nif sys.maxsize < 2**32:\n    im = Image.new(\"L\", (999999, 999999), 0)\n", "Tests/test_file_sun.py": "from __future__ import annotations\n\nimport os\n\nimport pytest\n\nfrom PIL import Image, SunImagePlugin\n\nfrom .helper import assert_image_equal_tofile, assert_image_similar, hopper\n\nEXTRA_DIR = \"Tests/images/sunraster\"\n\n\ndef test_sanity() -> None:\n    # Arrange\n    # Created with ImageMagick: convert hopper.jpg hopper.ras\n    test_file = \"Tests/images/hopper.ras\"\n\n    # Act\n    with Image.open(test_file) as im:\n        # Assert\n        assert im.size == (128, 128)\n\n        assert_image_similar(im, hopper(), 5)  # visually verified\n\n    invalid_file = \"Tests/images/flower.jpg\"\n    with pytest.raises(SyntaxError):\n        SunImagePlugin.SunImageFile(invalid_file)\n\n\ndef test_im1() -> None:\n    with Image.open(\"Tests/images/sunraster.im1\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/sunraster.im1.png\")\n\n\n@pytest.mark.skipif(\n    not os.path.exists(EXTRA_DIR), reason=\"Extra image files not installed\"\n)\ndef test_others() -> None:\n    files = (\n        os.path.join(EXTRA_DIR, f)\n        for f in os.listdir(EXTRA_DIR)\n        if os.path.splitext(f)[1] in (\".sun\", \".SUN\", \".ras\")\n    )\n    for path in files:\n        with Image.open(path) as im:\n            im.load()\n            assert isinstance(im, SunImagePlugin.SunImageFile)\n            assert_image_equal_tofile(im, f\"{os.path.splitext(path)[0]}.png\")\n", "Tests/test_file_dcx.py": "from __future__ import annotations\n\nimport warnings\n\nimport pytest\n\nfrom PIL import DcxImagePlugin, Image\n\nfrom .helper import assert_image_equal, hopper, is_pypy\n\n# Created with ImageMagick: convert hopper.ppm hopper.dcx\nTEST_FILE = \"Tests/images/hopper.dcx\"\n\n\ndef test_sanity() -> None:\n    # Arrange\n\n    # Act\n    with Image.open(TEST_FILE) as im:\n        # Assert\n        assert im.size == (128, 128)\n        assert isinstance(im, DcxImagePlugin.DcxImageFile)\n        orig = hopper()\n        assert_image_equal(im, orig)\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    def open() -> None:\n        im = Image.open(TEST_FILE)\n        im.load()\n\n    with pytest.warns(ResourceWarning):\n        open()\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        im = Image.open(TEST_FILE)\n        im.load()\n        im.close()\n\n\ndef test_context_manager() -> None:\n    with warnings.catch_warnings():\n        with Image.open(TEST_FILE) as im:\n            im.load()\n\n\ndef test_invalid_file() -> None:\n    with open(\"Tests/images/flower.jpg\", \"rb\") as fp:\n        with pytest.raises(SyntaxError):\n            DcxImagePlugin.DcxImageFile(fp)\n\n\ndef test_tell() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        # Act\n        frame = im.tell()\n\n        # Assert\n        assert frame == 0\n\n\ndef test_n_frames() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert im.n_frames == 1\n        assert not im.is_animated\n\n\ndef test_eoferror() -> None:\n    with Image.open(TEST_FILE) as im:\n        n_frames = im.n_frames\n\n        # Test seeking past the last frame\n        with pytest.raises(EOFError):\n            im.seek(n_frames)\n        assert im.tell() < n_frames\n\n        # Test that seeking to the last frame does not raise an error\n        im.seek(n_frames - 1)\n\n\ndef test_seek_too_far() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        frame = 999  # too big on purpose\n\n    # Act / Assert\n    with pytest.raises(EOFError):\n        im.seek(frame)\n", "Tests/test_file_dds.py": "\"\"\"Test DdsImagePlugin\"\"\"\n\nfrom __future__ import annotations\n\nfrom io import BytesIO\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import DdsImagePlugin, Image\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, hopper\n\nTEST_FILE_DXT1 = \"Tests/images/dxt1-rgb-4bbp-noalpha_MipMaps-1.dds\"\nTEST_FILE_DXT3 = \"Tests/images/dxt3-argb-8bbp-explicitalpha_MipMaps-1.dds\"\nTEST_FILE_DXT5 = \"Tests/images/dxt5-argb-8bbp-interpolatedalpha_MipMaps-1.dds\"\nTEST_FILE_ATI1 = \"Tests/images/ati1.dds\"\nTEST_FILE_ATI2 = \"Tests/images/ati2.dds\"\nTEST_FILE_DX10_BC4_TYPELESS = \"Tests/images/bc4_typeless.dds\"\nTEST_FILE_DX10_BC4_UNORM = \"Tests/images/bc4_unorm.dds\"\nTEST_FILE_DX10_BC5_TYPELESS = \"Tests/images/bc5_typeless.dds\"\nTEST_FILE_DX10_BC5_UNORM = \"Tests/images/bc5_unorm.dds\"\nTEST_FILE_DX10_BC5_SNORM = \"Tests/images/bc5_snorm.dds\"\nTEST_FILE_DX10_BC1 = \"Tests/images/bc1.dds\"\nTEST_FILE_DX10_BC1_TYPELESS = \"Tests/images/bc1_typeless.dds\"\nTEST_FILE_BC4U = \"Tests/images/bc4u.dds\"\nTEST_FILE_BC5S = \"Tests/images/bc5s.dds\"\nTEST_FILE_BC5U = \"Tests/images/bc5u.dds\"\nTEST_FILE_BC6H = \"Tests/images/bc6h.dds\"\nTEST_FILE_BC6HS = \"Tests/images/bc6h_sf.dds\"\nTEST_FILE_DX10_BC7 = \"Tests/images/bc7-argb-8bpp_MipMaps-1.dds\"\nTEST_FILE_DX10_BC7_UNORM_SRGB = \"Tests/images/DXGI_FORMAT_BC7_UNORM_SRGB.dds\"\nTEST_FILE_DX10_R8G8B8A8 = \"Tests/images/argb-32bpp_MipMaps-1.dds\"\nTEST_FILE_DX10_R8G8B8A8_UNORM_SRGB = \"Tests/images/DXGI_FORMAT_R8G8B8A8_UNORM_SRGB.dds\"\nTEST_FILE_UNCOMPRESSED_L = \"Tests/images/uncompressed_l.dds\"\nTEST_FILE_UNCOMPRESSED_L_WITH_ALPHA = \"Tests/images/uncompressed_la.dds\"\nTEST_FILE_UNCOMPRESSED_RGB = \"Tests/images/hopper.dds\"\nTEST_FILE_UNCOMPRESSED_BGR15 = \"Tests/images/bgr15.dds\"\nTEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA = \"Tests/images/uncompressed_rgb.dds\"\n\n\n@pytest.mark.parametrize(\n    \"image_path\",\n    (\n        TEST_FILE_DXT1,\n        # hexeditted to use DX10 FourCC\n        TEST_FILE_DX10_BC1,\n        TEST_FILE_DX10_BC1_TYPELESS,\n    ),\n)\ndef test_sanity_dxt1_bc1(image_path: str) -> None:\n    \"\"\"Check DXT1 and BC1 images can be opened\"\"\"\n    with Image.open(TEST_FILE_DXT1.replace(\".dds\", \".png\")) as target:\n        target = target.convert(\"RGBA\")\n    with Image.open(image_path) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGBA\"\n        assert im.size == (256, 256)\n\n        assert_image_equal(im, target)\n\n\ndef test_sanity_dxt3() -> None:\n    \"\"\"Check DXT3 images can be opened\"\"\"\n\n    with Image.open(TEST_FILE_DXT3) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGBA\"\n        assert im.size == (256, 256)\n\n        assert_image_equal_tofile(im, TEST_FILE_DXT3.replace(\".dds\", \".png\"))\n\n\ndef test_sanity_dxt5() -> None:\n    \"\"\"Check DXT5 images can be opened\"\"\"\n\n    with Image.open(TEST_FILE_DXT5) as im:\n        im.load()\n\n    assert im.format == \"DDS\"\n    assert im.mode == \"RGBA\"\n    assert im.size == (256, 256)\n\n    assert_image_equal_tofile(im, TEST_FILE_DXT5.replace(\".dds\", \".png\"))\n\n\n@pytest.mark.parametrize(\n    \"image_path\",\n    (\n        TEST_FILE_ATI1,\n        # hexeditted to use BC4U FourCC\n        TEST_FILE_BC4U,\n    ),\n)\ndef test_sanity_ati1_bc4u(image_path: str) -> None:\n    \"\"\"Check ATI1 and BC4U images can be opened\"\"\"\n\n    with Image.open(image_path) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"L\"\n        assert im.size == (64, 64)\n\n        assert_image_equal_tofile(im, TEST_FILE_ATI1.replace(\".dds\", \".png\"))\n\n\n@pytest.mark.parametrize(\n    \"image_path\",\n    (\n        TEST_FILE_DX10_BC4_UNORM,\n        # hexeditted to be typeless\n        TEST_FILE_DX10_BC4_TYPELESS,\n    ),\n)\ndef test_dx10_bc4(image_path: str) -> None:\n    \"\"\"Check DX10 BC4 images can be opened\"\"\"\n\n    with Image.open(image_path) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"L\"\n        assert im.size == (64, 64)\n\n        assert_image_equal_tofile(im, TEST_FILE_DX10_BC4_UNORM.replace(\".dds\", \".png\"))\n\n\n@pytest.mark.parametrize(\n    \"image_path\",\n    (\n        TEST_FILE_ATI2,\n        # hexeditted to use BC5U FourCC\n        TEST_FILE_BC5U,\n    ),\n)\ndef test_sanity_ati2_bc5u(image_path: str) -> None:\n    \"\"\"Check ATI2 and BC5U images can be opened\"\"\"\n\n    with Image.open(image_path) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGB\"\n        assert im.size == (256, 256)\n\n        assert_image_equal_tofile(im, TEST_FILE_DX10_BC5_UNORM.replace(\".dds\", \".png\"))\n\n\n@pytest.mark.parametrize(\n    (\"image_path\", \"expected_path\"),\n    (\n        # hexeditted to be typeless\n        (TEST_FILE_DX10_BC5_TYPELESS, TEST_FILE_DX10_BC5_UNORM),\n        (TEST_FILE_DX10_BC5_UNORM, TEST_FILE_DX10_BC5_UNORM),\n        # hexeditted to use DX10 FourCC\n        (TEST_FILE_DX10_BC5_SNORM, TEST_FILE_BC5S),\n        (TEST_FILE_BC5S, TEST_FILE_BC5S),\n    ),\n)\ndef test_dx10_bc5(image_path: str, expected_path: str) -> None:\n    \"\"\"Check DX10 BC5 images can be opened\"\"\"\n\n    with Image.open(image_path) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGB\"\n        assert im.size == (256, 256)\n\n        assert_image_equal_tofile(im, expected_path.replace(\".dds\", \".png\"))\n\n\n@pytest.mark.parametrize(\"image_path\", (TEST_FILE_BC6H, TEST_FILE_BC6HS))\ndef test_dx10_bc6h(image_path: str) -> None:\n    \"\"\"Check DX10 BC6H/BC6HS images can be opened\"\"\"\n\n    with Image.open(image_path) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGB\"\n        assert im.size == (128, 128)\n\n        assert_image_equal_tofile(im, image_path.replace(\".dds\", \".png\"))\n\n\ndef test_dx10_bc7() -> None:\n    \"\"\"Check DX10 images can be opened\"\"\"\n\n    with Image.open(TEST_FILE_DX10_BC7) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGBA\"\n        assert im.size == (256, 256)\n\n        assert_image_equal_tofile(im, TEST_FILE_DX10_BC7.replace(\".dds\", \".png\"))\n\n\ndef test_dx10_bc7_unorm_srgb() -> None:\n    \"\"\"Check DX10 unsigned normalized integer images can be opened\"\"\"\n\n    with Image.open(TEST_FILE_DX10_BC7_UNORM_SRGB) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGBA\"\n        assert im.size == (16, 16)\n        assert im.info[\"gamma\"] == 1 / 2.2\n\n        assert_image_equal_tofile(\n            im, TEST_FILE_DX10_BC7_UNORM_SRGB.replace(\".dds\", \".png\")\n        )\n\n\ndef test_dx10_r8g8b8a8() -> None:\n    \"\"\"Check DX10 images can be opened\"\"\"\n\n    with Image.open(TEST_FILE_DX10_R8G8B8A8) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGBA\"\n        assert im.size == (256, 256)\n\n        assert_image_equal_tofile(im, TEST_FILE_DX10_R8G8B8A8.replace(\".dds\", \".png\"))\n\n\ndef test_dx10_r8g8b8a8_unorm_srgb() -> None:\n    \"\"\"Check DX10 unsigned normalized integer images can be opened\"\"\"\n\n    with Image.open(TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB) as im:\n        im.load()\n\n        assert im.format == \"DDS\"\n        assert im.mode == \"RGBA\"\n        assert im.size == (16, 16)\n        assert im.info[\"gamma\"] == 1 / 2.2\n\n        assert_image_equal_tofile(\n            im, TEST_FILE_DX10_R8G8B8A8_UNORM_SRGB.replace(\".dds\", \".png\")\n        )\n\n\n@pytest.mark.parametrize(\n    (\"mode\", \"size\", \"test_file\"),\n    [\n        (\"L\", (128, 128), TEST_FILE_UNCOMPRESSED_L),\n        (\"LA\", (128, 128), TEST_FILE_UNCOMPRESSED_L_WITH_ALPHA),\n        (\"RGB\", (128, 128), TEST_FILE_UNCOMPRESSED_RGB),\n        (\"RGB\", (128, 128), TEST_FILE_UNCOMPRESSED_BGR15),\n        (\"RGBA\", (800, 600), TEST_FILE_UNCOMPRESSED_RGB_WITH_ALPHA),\n    ],\n)\ndef test_uncompressed(mode: str, size: tuple[int, int], test_file: str) -> None:\n    \"\"\"Check uncompressed images can be opened\"\"\"\n\n    with Image.open(test_file) as im:\n        assert im.format == \"DDS\"\n        assert im.mode == mode\n        assert im.size == size\n\n        assert_image_equal_tofile(im, test_file.replace(\".dds\", \".png\"))\n\n\ndef test__accept_true() -> None:\n    \"\"\"Check valid prefix\"\"\"\n    # Arrange\n    prefix = b\"DDS etc\"\n\n    # Act\n    output = DdsImagePlugin._accept(prefix)\n\n    # Assert\n    assert output\n\n\ndef test__accept_false() -> None:\n    \"\"\"Check invalid prefix\"\"\"\n    # Arrange\n    prefix = b\"something invalid\"\n\n    # Act\n    output = DdsImagePlugin._accept(prefix)\n\n    # Assert\n    assert not output\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        DdsImagePlugin.DdsImageFile(invalid_file)\n\n\ndef test_short_header() -> None:\n    \"\"\"Check a short header\"\"\"\n    with open(TEST_FILE_DXT5, \"rb\") as f:\n        img_file = f.read()\n\n    def short_header() -> None:\n        with Image.open(BytesIO(img_file[:119])):\n            pass  # pragma: no cover\n\n    with pytest.raises(OSError):\n        short_header()\n\n\ndef test_short_file() -> None:\n    \"\"\"Check that the appropriate error is thrown for a short file\"\"\"\n\n    with open(TEST_FILE_DXT5, \"rb\") as f:\n        img_file = f.read()\n\n    def short_file() -> None:\n        with Image.open(BytesIO(img_file[:-100])) as im:\n            im.load()\n\n    with pytest.raises(OSError):\n        short_file()\n\n\ndef test_dxt5_colorblock_alpha_issue_4142() -> None:\n    \"\"\"Check that colorblocks are decoded correctly in DXT5\"\"\"\n\n    with Image.open(\"Tests/images/dxt5-colorblock-alpha-issue-4142.dds\") as im:\n        px = im.getpixel((0, 0))\n        assert px[0] != 0\n        assert px[1] != 0\n        assert px[2] != 0\n\n        px = im.getpixel((1, 0))\n        assert px[0] != 0\n        assert px[1] != 0\n        assert px[2] != 0\n\n\ndef test_palette() -> None:\n    with Image.open(\"Tests/images/palette.dds\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/transparent.gif\")\n\n\ndef test_unsupported_bitcount() -> None:\n    with pytest.raises(OSError):\n        with Image.open(\"Tests/images/unsupported_bitcount.dds\"):\n            pass\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    (\n        \"Tests/images/unimplemented_dxgi_format.dds\",\n        \"Tests/images/unimplemented_pfflags.dds\",\n    ),\n)\ndef test_not_implemented(test_file: str) -> None:\n    with pytest.raises(NotImplementedError):\n        with Image.open(test_file):\n            pass\n\n\ndef test_save_unsupported_mode(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.dds\")\n    im = hopper(\"HSV\")\n    with pytest.raises(OSError):\n        im.save(out)\n\n\n@pytest.mark.parametrize(\n    (\"mode\", \"test_file\"),\n    [\n        (\"L\", \"Tests/images/linear_gradient.png\"),\n        (\"LA\", \"Tests/images/uncompressed_la.png\"),\n        (\"RGB\", \"Tests/images/hopper.png\"),\n        (\"RGBA\", \"Tests/images/pil123rgba.png\"),\n    ],\n)\ndef test_save(mode: str, test_file: str, tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.dds\")\n    with Image.open(test_file) as im:\n        assert im.mode == mode\n        im.save(out)\n\n        with Image.open(out) as reloaded:\n            assert_image_equal(im, reloaded)\n", "Tests/test_imagecolor.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageColor\n\n\ndef test_hash() -> None:\n    # short 3 components\n    assert (255, 0, 0) == ImageColor.getrgb(\"#f00\")\n    assert (0, 255, 0) == ImageColor.getrgb(\"#0f0\")\n    assert (0, 0, 255) == ImageColor.getrgb(\"#00f\")\n\n    # short 4 components\n    assert (255, 0, 0, 0) == ImageColor.getrgb(\"#f000\")\n    assert (0, 255, 0, 0) == ImageColor.getrgb(\"#0f00\")\n    assert (0, 0, 255, 0) == ImageColor.getrgb(\"#00f0\")\n    assert (0, 0, 0, 255) == ImageColor.getrgb(\"#000f\")\n\n    # long 3 components\n    assert (222, 0, 0) == ImageColor.getrgb(\"#de0000\")\n    assert (0, 222, 0) == ImageColor.getrgb(\"#00de00\")\n    assert (0, 0, 222) == ImageColor.getrgb(\"#0000de\")\n\n    # long 4 components\n    assert (222, 0, 0, 0) == ImageColor.getrgb(\"#de000000\")\n    assert (0, 222, 0, 0) == ImageColor.getrgb(\"#00de0000\")\n    assert (0, 0, 222, 0) == ImageColor.getrgb(\"#0000de00\")\n    assert (0, 0, 0, 222) == ImageColor.getrgb(\"#000000de\")\n\n    # case insensitivity\n    assert ImageColor.getrgb(\"#DEF\") == ImageColor.getrgb(\"#def\")\n    assert ImageColor.getrgb(\"#CDEF\") == ImageColor.getrgb(\"#cdef\")\n    assert ImageColor.getrgb(\"#DEFDEF\") == ImageColor.getrgb(\"#defdef\")\n    assert ImageColor.getrgb(\"#CDEFCDEF\") == ImageColor.getrgb(\"#cdefcdef\")\n\n    # not a number\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#fo0\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#fo00\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#fo0000\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#fo000000\")\n\n    # wrong number of components\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#f0000\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#f000000\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#f00000000\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#f000000000\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"#f00000 \")\n\n\ndef test_colormap() -> None:\n    assert (0, 0, 0) == ImageColor.getrgb(\"black\")\n    assert (255, 255, 255) == ImageColor.getrgb(\"white\")\n    assert (255, 255, 255) == ImageColor.getrgb(\"WHITE\")\n\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"black \")\n\n\ndef test_functions() -> None:\n    # rgb numbers\n    assert (255, 0, 0) == ImageColor.getrgb(\"rgb(255,0,0)\")\n    assert (0, 255, 0) == ImageColor.getrgb(\"rgb(0,255,0)\")\n    assert (0, 0, 255) == ImageColor.getrgb(\"rgb(0,0,255)\")\n\n    # percents\n    assert (255, 0, 0) == ImageColor.getrgb(\"rgb(100%,0%,0%)\")\n    assert (0, 255, 0) == ImageColor.getrgb(\"rgb(0%,100%,0%)\")\n    assert (0, 0, 255) == ImageColor.getrgb(\"rgb(0%,0%,100%)\")\n\n    # rgba numbers\n    assert (255, 0, 0, 0) == ImageColor.getrgb(\"rgba(255,0,0,0)\")\n    assert (0, 255, 0, 0) == ImageColor.getrgb(\"rgba(0,255,0,0)\")\n    assert (0, 0, 255, 0) == ImageColor.getrgb(\"rgba(0,0,255,0)\")\n    assert (0, 0, 0, 255) == ImageColor.getrgb(\"rgba(0,0,0,255)\")\n\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsl(0,100%,50%)\")\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsl(360,100%,50%)\")\n    assert (0, 255, 255) == ImageColor.getrgb(\"hsl(180,100%,50%)\")\n\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsv(0,100%,100%)\")\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsv(360,100%,100%)\")\n    assert (0, 255, 255) == ImageColor.getrgb(\"hsv(180,100%,100%)\")\n\n    # alternate format\n    assert ImageColor.getrgb(\"hsb(0,100%,50%)\") == ImageColor.getrgb(\"hsv(0,100%,50%)\")\n\n    # floats\n    assert (254, 3, 3) == ImageColor.getrgb(\"hsl(0.1,99.2%,50.3%)\")\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsl(360.,100.0%,50%)\")\n\n    assert (253, 2, 2) == ImageColor.getrgb(\"hsv(0.1,99.2%,99.3%)\")\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsv(360.,100.0%,100%)\")\n\n    # case insensitivity\n    assert ImageColor.getrgb(\"RGB(255,0,0)\") == ImageColor.getrgb(\"rgb(255,0,0)\")\n    assert ImageColor.getrgb(\"RGB(100%,0%,0%)\") == ImageColor.getrgb(\"rgb(100%,0%,0%)\")\n    assert ImageColor.getrgb(\"RGBA(255,0,0,0)\") == ImageColor.getrgb(\"rgba(255,0,0,0)\")\n    assert ImageColor.getrgb(\"HSL(0,100%,50%)\") == ImageColor.getrgb(\"hsl(0,100%,50%)\")\n    assert ImageColor.getrgb(\"HSV(0,100%,50%)\") == ImageColor.getrgb(\"hsv(0,100%,50%)\")\n    assert ImageColor.getrgb(\"HSB(0,100%,50%)\") == ImageColor.getrgb(\"hsb(0,100%,50%)\")\n\n    # space agnosticism\n    assert (255, 0, 0) == ImageColor.getrgb(\"rgb(  255  ,  0  ,  0  )\")\n    assert (255, 0, 0) == ImageColor.getrgb(\"rgb(  100%  ,  0%  ,  0%  )\")\n    assert (255, 0, 0, 0) == ImageColor.getrgb(\"rgba(  255  ,  0  ,  0  ,  0  )\")\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsl(  0  ,  100%  ,  50%  )\")\n    assert (255, 0, 0) == ImageColor.getrgb(\"hsv(  0  ,  100%  ,  100%  )\")\n\n    # wrong number of components\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgb(255,0)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgb(255,0,0,0)\")\n\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgb(100%,0%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgb(100%,0%,0)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgb(100%,0%,0 %)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgb(100%,0%,0%,0%)\")\n\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgba(255,0,0)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"rgba(255,0,0,0,0)\")\n\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsl(0,100%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsl(0,100%,0%,0%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsl(0%,100%,50%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsl(0,100,50%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsl(0,100%,50)\")\n\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsv(0,100%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsv(0,100%,0%,0%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsv(0%,100%,50%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsv(0,100,50%)\")\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(\"hsv(0,100%,50)\")\n\n\n# look for rounding errors (based on code by Tim Hatch)\ndef test_rounding_errors() -> None:\n    for color in ImageColor.colormap:\n        expected = Image.new(\"RGB\", (1, 1), color).convert(\"L\").getpixel((0, 0))\n        actual = ImageColor.getcolor(color, \"L\")\n        assert expected == actual\n\n    assert (0, 255, 115) == ImageColor.getcolor(\"rgba(0, 255, 115, 33)\", \"RGB\")\n    Image.new(\"RGB\", (1, 1), \"white\")\n\n    assert (0, 0, 0, 255) == ImageColor.getcolor(\"black\", \"RGBA\")\n    assert (255, 255, 255, 255) == ImageColor.getcolor(\"white\", \"RGBA\")\n    assert (0, 255, 115, 33) == ImageColor.getcolor(\"rgba(0, 255, 115, 33)\", \"RGBA\")\n    Image.new(\"RGBA\", (1, 1), \"white\")\n\n    assert 0 == ImageColor.getcolor(\"black\", \"L\")\n    assert 255 == ImageColor.getcolor(\"white\", \"L\")\n    assert 163 == ImageColor.getcolor(\"rgba(0, 255, 115, 33)\", \"L\")\n    Image.new(\"L\", (1, 1), \"white\")\n\n    assert 0 == ImageColor.getcolor(\"black\", \"1\")\n    assert 255 == ImageColor.getcolor(\"white\", \"1\")\n    # The following test is wrong, but is current behavior\n    # The correct result should be 255 due to the mode 1\n    assert 163 == ImageColor.getcolor(\"rgba(0, 255, 115, 33)\", \"1\")\n    # Correct behavior\n    # assert\n    #     255, ImageColor.getcolor(\"rgba(0, 255, 115, 33)\", \"1\"))\n    Image.new(\"1\", (1, 1), \"white\")\n\n    assert (0, 255) == ImageColor.getcolor(\"black\", \"LA\")\n    assert (255, 255) == ImageColor.getcolor(\"white\", \"LA\")\n    assert (163, 33) == ImageColor.getcolor(\"rgba(0, 255, 115, 33)\", \"LA\")\n    Image.new(\"LA\", (1, 1), \"white\")\n\n\ndef test_color_hsv() -> None:\n    assert (170, 255, 255) == ImageColor.getcolor(\"hsv(240, 100%, 100%)\", \"HSV\")\n\n\ndef test_color_too_long() -> None:\n    # Arrange\n    color_too_long = \"hsl(\" + \"1\" * 40 + \",\" + \"1\" * 40 + \"%,\" + \"1\" * 40 + \"%)\"\n\n    # Act / Assert\n    with pytest.raises(ValueError):\n        ImageColor.getrgb(color_too_long)\n", "Tests/test_font_leaks.py": "from __future__ import annotations\n\nfrom PIL import Image, ImageDraw, ImageFont, _util\n\nfrom .helper import PillowLeakTestCase, features, skip_unless_feature\n\noriginal_core = ImageFont.core\n\n\nclass TestTTypeFontLeak(PillowLeakTestCase):\n    # fails at iteration 3 in main\n    iterations = 10\n    mem_limit = 4096  # k\n\n    def _test_font(self, font: ImageFont.FreeTypeFont | ImageFont.ImageFont) -> None:\n        im = Image.new(\"RGB\", (255, 255), \"white\")\n        draw = ImageDraw.ImageDraw(im)\n        self._test_leak(\n            lambda: draw.text(\n                (0, 0), \"some text \" * 1024, font=font, fill=\"black\"  # ~10k\n            )\n        )\n\n    @skip_unless_feature(\"freetype2\")\n    def test_leak(self) -> None:\n        ttype = ImageFont.truetype(\"Tests/fonts/FreeMono.ttf\", 20)\n        self._test_font(ttype)\n\n\nclass TestDefaultFontLeak(TestTTypeFontLeak):\n    # fails at iteration 37 in main\n    iterations = 100\n    mem_limit = 1024  # k\n\n    def test_leak(self) -> None:\n        if features.check_module(\"freetype2\"):\n            ImageFont.core = _util.DeferredError(ImportError(\"Disabled for testing\"))\n        try:\n            default_font = ImageFont.load_default()\n        finally:\n            ImageFont.core = original_core\n\n        self._test_font(default_font)\n", "Tests/check_j2k_overflow.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\n\ndef test_j2k_overflow(tmp_path: Path) -> None:\n    im = Image.new(\"RGBA\", (1024, 131584))\n    target = str(tmp_path / \"temp.jpc\")\n    with pytest.raises(OSError):\n        im.save(target)\n", "Tests/test_file_webp_lossless.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal, hopper\n\n_webp = pytest.importorskip(\"PIL._webp\", reason=\"WebP support not installed\")\nRGB_MODE = \"RGB\"\n\n\ndef test_write_lossless_rgb(tmp_path: Path) -> None:\n    if _webp.WebPDecoderVersion() < 0x0200:\n        pytest.skip(\"lossless not included\")\n\n    temp_file = str(tmp_path / \"temp.webp\")\n\n    hopper(RGB_MODE).save(temp_file, lossless=True)\n\n    with Image.open(temp_file) as image:\n        image.load()\n\n        assert image.mode == RGB_MODE\n        assert image.size == (128, 128)\n        assert image.format == \"WEBP\"\n        image.load()\n        image.getdata()\n\n        assert_image_equal(image, hopper(RGB_MODE))\n", "Tests/check_j2k_leaks.py": "from __future__ import annotations\n\nfrom io import BytesIO\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import is_win32, skip_unless_feature\n\n# Limits for testing the leak\nmem_limit = 1024 * 1048576\nstack_size = 8 * 1048576\niterations = int((mem_limit / stack_size) * 2)\ntest_file = \"Tests/images/rgb_trns_ycbc.jp2\"\n\npytestmark = [\n    pytest.mark.skipif(is_win32(), reason=\"requires Unix or macOS\"),\n    skip_unless_feature(\"jpg_2000\"),\n]\n\n\ndef test_leak_load() -> None:\n    from resource import RLIMIT_AS, RLIMIT_STACK, setrlimit\n\n    setrlimit(RLIMIT_STACK, (stack_size, stack_size))\n    setrlimit(RLIMIT_AS, (mem_limit, mem_limit))\n    for _ in range(iterations):\n        with Image.open(test_file) as im:\n            im.load()\n\n\ndef test_leak_save() -> None:\n    from resource import RLIMIT_AS, RLIMIT_STACK, setrlimit\n\n    setrlimit(RLIMIT_STACK, (stack_size, stack_size))\n    setrlimit(RLIMIT_AS, (mem_limit, mem_limit))\n    for _ in range(iterations):\n        with Image.open(test_file) as im:\n            im.load()\n            test_output = BytesIO()\n            im.save(test_output, \"JPEG2000\")\n            test_output.seek(0)\n            test_output.read()\n", "Tests/test_imagestat.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageStat\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    im = hopper()\n\n    st = ImageStat.Stat(im)\n    st = ImageStat.Stat(im.histogram())\n    st = ImageStat.Stat(im, Image.new(\"1\", im.size, 1))\n\n    # Check these run. Exceptions will cause failures.\n    st.extrema\n    st.sum\n    st.mean\n    st.median\n    st.rms\n    st.sum2\n    st.var\n    st.stddev\n\n    with pytest.raises(AttributeError):\n        st.spam()  # type: ignore[attr-defined]\n\n    with pytest.raises(TypeError):\n        ImageStat.Stat(1)  # type: ignore[arg-type]\n\n\ndef test_hopper() -> None:\n    im = hopper()\n\n    st = ImageStat.Stat(im)\n\n    # verify a few values\n    assert st.extrema[0] == (0, 255)\n    assert st.median[0] == 72\n    assert st.sum[0] == 1470218\n    assert st.sum[1] == 1311896\n    assert st.sum[2] == 1563008\n\n\ndef test_constant() -> None:\n    im = Image.new(\"L\", (128, 128), 128)\n\n    st = ImageStat.Stat(im)\n\n    assert st.extrema[0] == (128, 128)\n    assert st.sum[0] == 128**3\n    assert st.sum2[0] == 128**4\n    assert st.mean[0] == 128\n    assert st.median[0] == 128\n    assert st.rms[0] == 128\n    assert st.var[0] == 0\n    assert st.stddev[0] == 0\n", "Tests/check_icns_dos.py": "# Tests potential DOS of IcnsImagePlugin with 0 length block.\n# Run from anywhere that PIL is importable.\nfrom __future__ import annotations\n\nfrom io import BytesIO\n\nfrom PIL import Image\n\nwith Image.open(BytesIO(b\"icns\\x00\\x00\\x00\\x10hang\\x00\\x00\\x00\\x00\")):\n    pass\n", "Tests/test_file_tiff_metadata.py": "from __future__ import annotations\n\nimport io\nimport struct\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, TiffImagePlugin, TiffTags\nfrom PIL.TiffImagePlugin import IFDRational\n\nfrom .helper import assert_deep_equal, hopper\n\nTAG_IDS: dict[str, int] = {\n    info.name: info.value\n    for info in TiffTags.TAGS_V2.values()\n    if info.value is not None\n}\n\n\ndef test_rt_metadata(tmp_path: Path) -> None:\n    \"\"\"Test writing arbitrary metadata into the tiff image directory\n    Use case is ImageJ private tags, one numeric, one arbitrary\n    data.  https://github.com/python-pillow/Pillow/issues/291\n    \"\"\"\n\n    img = hopper()\n\n    # Behaviour change: re #1416\n    # Pre ifd rewrite, ImageJMetaData was being written as a string(2),\n    # Post ifd rewrite, it's defined as arbitrary bytes(7). It should\n    # roundtrip with the actual bytes, rather than stripped text\n    # of the premerge tests.\n    #\n    # For text items, we still have to decode('ascii','replace') because\n    # the tiff file format can't take 8 bit bytes in that field.\n\n    base_text_data = \"This is some arbitrary metadata for a text field\"\n    bin_data = base_text_data.encode(\"ascii\") + b\" \\xff\"\n    text_data = base_text_data + \" \" + chr(255)\n    reloaded_text_data = base_text_data + \" ?\"\n    float_data = 12.345\n    double_data = 67.89\n    info = TiffImagePlugin.ImageFileDirectory()\n\n    ImageJMetaData = TAG_IDS[\"ImageJMetaData\"]\n    ImageJMetaDataByteCounts = TAG_IDS[\"ImageJMetaDataByteCounts\"]\n    ImageDescription = TAG_IDS[\"ImageDescription\"]\n\n    info[ImageJMetaDataByteCounts] = len(bin_data)\n    info[ImageJMetaData] = bin_data\n    info[TAG_IDS[\"RollAngle\"]] = float_data\n    info.tagtype[TAG_IDS[\"RollAngle\"]] = 11\n    info[TAG_IDS[\"YawAngle\"]] = double_data\n    info.tagtype[TAG_IDS[\"YawAngle\"]] = 12\n\n    info[ImageDescription] = text_data\n\n    f = str(tmp_path / \"temp.tif\")\n\n    img.save(f, tiffinfo=info)\n\n    with Image.open(f) as loaded:\n        assert loaded.tag[ImageJMetaDataByteCounts] == (len(bin_data),)\n        assert loaded.tag_v2[ImageJMetaDataByteCounts] == (len(bin_data),)\n\n        assert loaded.tag[ImageJMetaData] == bin_data\n        assert loaded.tag_v2[ImageJMetaData] == bin_data\n\n        assert loaded.tag[ImageDescription] == (reloaded_text_data,)\n        assert loaded.tag_v2[ImageDescription] == reloaded_text_data\n\n        loaded_float = loaded.tag[TAG_IDS[\"RollAngle\"]][0]\n        assert round(abs(loaded_float - float_data), 5) == 0\n        loaded_double = loaded.tag[TAG_IDS[\"YawAngle\"]][0]\n        assert round(abs(loaded_double - double_data), 7) == 0\n\n    # check with 2 element ImageJMetaDataByteCounts, issue #2006\n\n    info[ImageJMetaDataByteCounts] = (8, len(bin_data) - 8)\n    img.save(f, tiffinfo=info)\n    with Image.open(f) as loaded:\n        assert loaded.tag[ImageJMetaDataByteCounts] == (8, len(bin_data) - 8)\n        assert loaded.tag_v2[ImageJMetaDataByteCounts] == (8, len(bin_data) - 8)\n\n\ndef test_read_metadata() -> None:\n    with Image.open(\"Tests/images/hopper_g4.tif\") as img:\n        assert {\n            \"YResolution\": IFDRational(4294967295, 113653537),\n            \"PlanarConfiguration\": 1,\n            \"BitsPerSample\": (1,),\n            \"ImageLength\": 128,\n            \"Compression\": 4,\n            \"FillOrder\": 1,\n            \"RowsPerStrip\": 128,\n            \"ResolutionUnit\": 3,\n            \"PhotometricInterpretation\": 0,\n            \"PageNumber\": (0, 1),\n            \"XResolution\": IFDRational(4294967295, 113653537),\n            \"ImageWidth\": 128,\n            \"Orientation\": 1,\n            \"StripByteCounts\": (1968,),\n            \"SamplesPerPixel\": 1,\n            \"StripOffsets\": (8,),\n        } == img.tag_v2.named()\n\n        assert {\n            \"YResolution\": ((4294967295, 113653537),),\n            \"PlanarConfiguration\": (1,),\n            \"BitsPerSample\": (1,),\n            \"ImageLength\": (128,),\n            \"Compression\": (4,),\n            \"FillOrder\": (1,),\n            \"RowsPerStrip\": (128,),\n            \"ResolutionUnit\": (3,),\n            \"PhotometricInterpretation\": (0,),\n            \"PageNumber\": (0, 1),\n            \"XResolution\": ((4294967295, 113653537),),\n            \"ImageWidth\": (128,),\n            \"Orientation\": (1,),\n            \"StripByteCounts\": (1968,),\n            \"SamplesPerPixel\": (1,),\n            \"StripOffsets\": (8,),\n        } == img.tag.named()\n\n\ndef test_write_metadata(tmp_path: Path) -> None:\n    \"\"\"Test metadata writing through the python code\"\"\"\n    with Image.open(\"Tests/images/hopper.tif\") as img:\n        f = str(tmp_path / \"temp.tiff\")\n        del img.tag[278]\n        img.save(f, tiffinfo=img.tag)\n\n        original = img.tag_v2.named()\n\n    with Image.open(f) as loaded:\n        reloaded = loaded.tag_v2.named()\n\n    ignored = [\"StripByteCounts\", \"RowsPerStrip\", \"PageNumber\", \"StripOffsets\"]\n\n    for tag, value in reloaded.items():\n        if tag in ignored:\n            continue\n        if isinstance(original[tag], tuple) and isinstance(\n            original[tag][0], IFDRational\n        ):\n            # Need to compare element by element in the tuple,\n            # not comparing tuples of object references\n            assert_deep_equal(\n                original[tag],\n                value,\n                f\"{tag} didn't roundtrip, {original[tag]}, {value}\",\n            )\n        else:\n            assert (\n                original[tag] == value\n            ), f\"{tag} didn't roundtrip, {original[tag]}, {value}\"\n\n    for tag, value in original.items():\n        if tag not in ignored:\n            assert value == reloaded[tag], f\"{tag} didn't roundtrip\"\n\n\ndef test_change_stripbytecounts_tag_type(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.tiff\")\n    with Image.open(\"Tests/images/hopper.tif\") as im:\n        info = im.tag_v2\n        del info[278]\n\n        # Resize the image so that STRIPBYTECOUNTS will be larger than a SHORT\n        im = im.resize((500, 500))\n        info[TiffImagePlugin.IMAGEWIDTH] = im.width\n\n        # STRIPBYTECOUNTS can be a SHORT or a LONG\n        info.tagtype[TiffImagePlugin.STRIPBYTECOUNTS] = TiffTags.SHORT\n\n        im.save(out, tiffinfo=info)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.tag_v2.tagtype[TiffImagePlugin.STRIPBYTECOUNTS] == TiffTags.LONG\n\n\ndef test_no_duplicate_50741_tag() -> None:\n    assert TAG_IDS[\"MakerNoteSafety\"] == 50741\n    assert TAG_IDS[\"BestQualityScale\"] == 50780\n\n\ndef test_iptc(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.tiff\")\n    with Image.open(\"Tests/images/hopper.Lab.tif\") as im:\n        im.save(out)\n\n\n@pytest.mark.parametrize(\"value, expected\", ((b\"test\", \"test\"), (1, \"1\")))\ndef test_writing_other_types_to_ascii(\n    value: bytes | int, expected: str, tmp_path: Path\n) -> None:\n    info = TiffImagePlugin.ImageFileDirectory_v2()\n\n    tag = TiffTags.TAGS_V2[271]\n    assert tag.type == TiffTags.ASCII\n\n    info[271] = value\n\n    im = hopper()\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.tag_v2[271] == expected\n\n\n@pytest.mark.parametrize(\"value\", (1, IFDRational(1)))\ndef test_writing_other_types_to_bytes(value: int | IFDRational, tmp_path: Path) -> None:\n    im = hopper()\n    info = TiffImagePlugin.ImageFileDirectory_v2()\n\n    tag = TiffTags.TAGS_V2[700]\n    assert tag.type == TiffTags.BYTE\n\n    info[700] = value\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.tag_v2[700] == b\"\\x01\"\n\n\n@pytest.mark.parametrize(\"value\", (1, IFDRational(1)))\ndef test_writing_other_types_to_undefined(\n    value: int | IFDRational, tmp_path: Path\n) -> None:\n    im = hopper()\n    info = TiffImagePlugin.ImageFileDirectory_v2()\n\n    tag = TiffTags.TAGS_V2[33723]\n    assert tag.type == TiffTags.UNDEFINED\n\n    info[33723] = value\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.tag_v2[33723] == b\"1\"\n\n\ndef test_undefined_zero(tmp_path: Path) -> None:\n    # Check that the tag has not been changed since this test was created\n    tag = TiffTags.TAGS_V2[45059]\n    assert tag.type == TiffTags.UNDEFINED\n    assert tag.length == 0\n\n    info = TiffImagePlugin.ImageFileDirectory(b\"II*\\x00\\x08\\x00\\x00\\x00\")\n    info[45059] = b\"test\"\n\n    # Assert that the tag value does not change by setting it to itself\n    original = info[45059]\n    info[45059] = info[45059]\n    assert info[45059] == original\n\n\ndef test_empty_metadata() -> None:\n    f = io.BytesIO(b\"II*\\x00\\x08\\x00\\x00\\x00\")\n    head = f.read(8)\n    info = TiffImagePlugin.ImageFileDirectory(head)\n    # Should not raise struct.error.\n    with pytest.warns(UserWarning):\n        info.load(f)\n\n\ndef test_iccprofile(tmp_path: Path) -> None:\n    # https://github.com/python-pillow/Pillow/issues/1462\n    out = str(tmp_path / \"temp.tiff\")\n    with Image.open(\"Tests/images/hopper.iccprofile.tif\") as im:\n        im.save(out)\n\n    with Image.open(out) as reloaded:\n        assert not isinstance(im.info[\"icc_profile\"], tuple)\n        assert im.info[\"icc_profile\"] == reloaded.info[\"icc_profile\"]\n\n\ndef test_iccprofile_binary() -> None:\n    # https://github.com/python-pillow/Pillow/issues/1526\n    # We should be able to load this,\n    # but probably won't be able to save it.\n\n    with Image.open(\"Tests/images/hopper.iccprofile_binary.tif\") as im:\n        assert im.tag_v2.tagtype[34675] == 1\n        assert im.info[\"icc_profile\"]\n\n\ndef test_iccprofile_save_png(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/hopper.iccprofile.tif\") as im:\n        outfile = str(tmp_path / \"temp.png\")\n        im.save(outfile)\n\n\ndef test_iccprofile_binary_save_png(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/hopper.iccprofile_binary.tif\") as im:\n        outfile = str(tmp_path / \"temp.png\")\n        im.save(outfile)\n\n\ndef test_exif_div_zero(tmp_path: Path) -> None:\n    im = hopper()\n    info = TiffImagePlugin.ImageFileDirectory_v2()\n    info[41988] = TiffImagePlugin.IFDRational(0, 0)\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info, compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert 0 == reloaded.tag_v2[41988].numerator\n        assert 0 == reloaded.tag_v2[41988].denominator\n\n\ndef test_ifd_unsigned_rational(tmp_path: Path) -> None:\n    im = hopper()\n    info = TiffImagePlugin.ImageFileDirectory_v2()\n\n    max_long = 2**32 - 1\n\n    # 4 bytes unsigned long\n    numerator = max_long\n\n    info[41493] = TiffImagePlugin.IFDRational(numerator, 1)\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info, compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert max_long == reloaded.tag_v2[41493].numerator\n        assert 1 == reloaded.tag_v2[41493].denominator\n\n    # out of bounds of 4 byte unsigned long\n    numerator = max_long + 1\n\n    info[41493] = TiffImagePlugin.IFDRational(numerator, 1)\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info, compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert max_long == reloaded.tag_v2[41493].numerator\n        assert 1 == reloaded.tag_v2[41493].denominator\n\n\ndef test_ifd_signed_rational(tmp_path: Path) -> None:\n    im = hopper()\n    info = TiffImagePlugin.ImageFileDirectory_v2()\n\n    # pair of 4 byte signed longs\n    numerator = 2**31 - 1\n    denominator = -(2**31)\n\n    info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info, compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert numerator == reloaded.tag_v2[37380].numerator\n        assert denominator == reloaded.tag_v2[37380].denominator\n\n    numerator = -(2**31)\n    denominator = 2**31 - 1\n\n    info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info, compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert numerator == reloaded.tag_v2[37380].numerator\n        assert denominator == reloaded.tag_v2[37380].denominator\n\n    # out of bounds of 4 byte signed long\n    numerator = -(2**31) - 1\n    denominator = 1\n\n    info[37380] = TiffImagePlugin.IFDRational(numerator, denominator)\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info, compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert 2**31 - 1 == reloaded.tag_v2[37380].numerator\n        assert -1 == reloaded.tag_v2[37380].denominator\n\n\ndef test_ifd_signed_long(tmp_path: Path) -> None:\n    im = hopper()\n    info = TiffImagePlugin.ImageFileDirectory_v2()\n\n    info[37000] = -60000\n\n    out = str(tmp_path / \"temp.tiff\")\n    im.save(out, tiffinfo=info, compression=\"raw\")\n\n    with Image.open(out) as reloaded:\n        assert reloaded.tag_v2[37000] == -60000\n\n\ndef test_empty_values() -> None:\n    data = io.BytesIO(\n        b\"II*\\x00\\x08\\x00\\x00\\x00\\x03\\x00\\x1a\\x01\\x05\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x00\\x00\\x00\\x00\\x1b\\x01\\x05\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n        b\"\\x98\\x82\\x02\\x00\\x07\\x00\\x00\\x002\\x00\\x00\\x00\\x00\\x00\\x00\\x00a \"\n        b\"text\\x00\\x00\"\n    )\n    head = data.read(8)\n    info = TiffImagePlugin.ImageFileDirectory_v2(head)\n    info.load(data)\n    # Should not raise ValueError.\n    info_dict = dict(info)\n    assert 33432 in info_dict\n\n\ndef test_photoshop_info(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/issue_2278.tif\") as im:\n        assert len(im.tag_v2[34377]) == 70\n        assert isinstance(im.tag_v2[34377], bytes)\n        out = str(tmp_path / \"temp.tiff\")\n        im.save(out)\n    with Image.open(out) as reloaded:\n        assert len(reloaded.tag_v2[34377]) == 70\n        assert isinstance(reloaded.tag_v2[34377], bytes)\n\n\ndef test_too_many_entries() -> None:\n    ifd = TiffImagePlugin.ImageFileDirectory_v2()\n\n    #    277: (\"SamplesPerPixel\", SHORT, 1),\n    ifd._tagdata[277] = struct.pack(\"<hh\", 4, 4)\n    ifd.tagtype[277] = TiffTags.SHORT\n\n    # Should not raise ValueError.\n    with pytest.warns(UserWarning):\n        assert ifd[277] == 4\n\n\ndef test_tag_group_data() -> None:\n    base_ifd = TiffImagePlugin.ImageFileDirectory_v2()\n    interop_ifd = TiffImagePlugin.ImageFileDirectory_v2(group=40965)\n    for ifd in (base_ifd, interop_ifd):\n        ifd[2] = \"test\"\n        ifd[256] = 10\n\n    assert base_ifd.tagtype[256] == 4\n    assert interop_ifd.tagtype[256] != base_ifd.tagtype[256]\n\n    assert interop_ifd.tagtype[2] == 7\n    assert base_ifd.tagtype[2] != interop_ifd.tagtype[256]\n\n\ndef test_empty_subifd(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.jpg\")\n\n    im = hopper()\n    exif = im.getexif()\n    exif[TiffImagePlugin.EXIFIFD] = {}\n    im.save(out, exif=exif)\n\n    with Image.open(out) as reloaded:\n        exif = reloaded.getexif()\n        assert exif.get_ifd(TiffImagePlugin.EXIFIFD) == {}\n", "Tests/test_imageops.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageDraw, ImageOps, ImageStat, features\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    assert_tuple_approx_equal,\n    hopper,\n)\n\n\nclass Deformer(ImageOps.SupportsGetMesh):\n    def getmesh(\n        self, im: Image.Image\n    ) -> list[\n        tuple[tuple[int, int, int, int], tuple[int, int, int, int, int, int, int, int]]\n    ]:\n        x, y = im.size\n        return [((0, 0, x, y), (0, 0, x, 0, x, y, y, 0))]\n\n\ndeformer = Deformer()\n\n\ndef test_sanity() -> None:\n    ImageOps.autocontrast(hopper(\"L\"))\n    ImageOps.autocontrast(hopper(\"RGB\"))\n\n    ImageOps.autocontrast(hopper(\"L\"), cutoff=10)\n    ImageOps.autocontrast(hopper(\"L\"), cutoff=(2, 10))\n    ImageOps.autocontrast(hopper(\"L\"), ignore=[0, 255])\n    ImageOps.autocontrast(hopper(\"L\"), mask=hopper(\"L\"))\n    ImageOps.autocontrast(hopper(\"L\"), preserve_tone=True)\n\n    ImageOps.colorize(hopper(\"L\"), (0, 0, 0), (255, 255, 255))\n    ImageOps.colorize(hopper(\"L\"), \"black\", \"white\")\n\n    ImageOps.pad(hopper(\"L\"), (128, 128))\n    ImageOps.pad(hopper(\"RGB\"), (128, 128))\n\n    ImageOps.contain(hopper(\"L\"), (128, 128))\n    ImageOps.contain(hopper(\"RGB\"), (128, 128))\n\n    ImageOps.cover(hopper(\"L\"), (128, 128))\n    ImageOps.cover(hopper(\"RGB\"), (128, 128))\n\n    ImageOps.crop(hopper(\"L\"), 1)\n    ImageOps.crop(hopper(\"RGB\"), 1)\n\n    ImageOps.deform(hopper(\"L\"), deformer)\n    ImageOps.deform(hopper(\"RGB\"), deformer)\n\n    ImageOps.equalize(hopper(\"L\"))\n    ImageOps.equalize(hopper(\"RGB\"))\n\n    ImageOps.expand(hopper(\"L\"), 1)\n    ImageOps.expand(hopper(\"RGB\"), 1)\n    ImageOps.expand(hopper(\"L\"), 2, \"blue\")\n    ImageOps.expand(hopper(\"RGB\"), 2, \"blue\")\n\n    ImageOps.fit(hopper(\"L\"), (128, 128))\n    ImageOps.fit(hopper(\"RGB\"), (128, 128))\n\n    ImageOps.flip(hopper(\"L\"))\n    ImageOps.flip(hopper(\"RGB\"))\n\n    ImageOps.grayscale(hopper(\"L\"))\n    ImageOps.grayscale(hopper(\"RGB\"))\n\n    ImageOps.invert(hopper(\"1\"))\n    ImageOps.invert(hopper(\"L\"))\n    ImageOps.invert(hopper(\"RGB\"))\n\n    ImageOps.mirror(hopper(\"L\"))\n    ImageOps.mirror(hopper(\"RGB\"))\n\n    ImageOps.posterize(hopper(\"L\"), 4)\n    ImageOps.posterize(hopper(\"RGB\"), 4)\n\n    ImageOps.solarize(hopper(\"L\"))\n    ImageOps.solarize(hopper(\"RGB\"))\n\n    ImageOps.exif_transpose(hopper(\"L\"))\n    ImageOps.exif_transpose(hopper(\"RGB\"))\n\n\ndef test_1pxfit() -> None:\n    # Division by zero in equalize if image is 1 pixel high\n    newimg = ImageOps.fit(hopper(\"RGB\").resize((1, 1)), (35, 35))\n    assert newimg.size == (35, 35)\n\n    newimg = ImageOps.fit(hopper(\"RGB\").resize((1, 100)), (35, 35))\n    assert newimg.size == (35, 35)\n\n    newimg = ImageOps.fit(hopper(\"RGB\").resize((100, 1)), (35, 35))\n    assert newimg.size == (35, 35)\n\n\ndef test_fit_same_ratio() -> None:\n    # The ratio for this image is 1000.0 / 755 = 1.3245033112582782\n    # If the ratios are not acknowledged to be the same,\n    # and Pillow attempts to adjust the width to\n    # 1.3245033112582782 * 755 = 1000.0000000000001\n    # then centering this greater width causes a negative x offset when cropping\n    with Image.new(\"RGB\", (1000, 755)) as im:\n        new_im = ImageOps.fit(im, (1000, 755))\n        assert new_im.size == (1000, 755)\n\n\n@pytest.mark.parametrize(\"new_size\", ((256, 256), (512, 256), (256, 512)))\ndef test_contain(new_size: tuple[int, int]) -> None:\n    im = hopper()\n    new_im = ImageOps.contain(im, new_size)\n    assert new_im.size == (256, 256)\n\n\ndef test_contain_round() -> None:\n    im = Image.new(\"1\", (43, 63), 1)\n    new_im = ImageOps.contain(im, (5, 7))\n    assert new_im.width == 5\n\n    im = Image.new(\"1\", (63, 43), 1)\n    new_im = ImageOps.contain(im, (7, 5))\n    assert new_im.height == 5\n\n\n@pytest.mark.parametrize(\n    \"image_name, expected_size\",\n    (\n        (\"colr_bungee.png\", (1024, 256)),  # landscape\n        (\"imagedraw_stroke_multiline.png\", (256, 640)),  # portrait\n        (\"hopper.png\", (256, 256)),  # square\n    ),\n)\ndef test_cover(image_name: str, expected_size: tuple[int, int]) -> None:\n    with Image.open(\"Tests/images/\" + image_name) as im:\n        new_im = ImageOps.cover(im, (256, 256))\n        assert new_im.size == expected_size\n\n\ndef test_pad() -> None:\n    # Same ratio\n    im = hopper()\n    new_size = (im.width * 2, im.height * 2)\n    new_im = ImageOps.pad(im, new_size)\n    assert new_im.size == new_size\n\n    for label, color, new_size in [\n        (\"h\", None, (im.width * 4, im.height * 2)),\n        (\"v\", \"#f00\", (im.width * 2, im.height * 4)),\n    ]:\n        for i, centering in enumerate([(0, 0), (0.5, 0.5), (1, 1)]):\n            new_im = ImageOps.pad(im, new_size, color=color, centering=centering)\n            assert new_im.size == new_size\n\n            assert_image_similar_tofile(\n                new_im, \"Tests/images/imageops_pad_\" + label + \"_\" + str(i) + \".jpg\", 6\n            )\n\n\ndef test_pad_round() -> None:\n    im = Image.new(\"1\", (1, 1), 1)\n    new_im = ImageOps.pad(im, (4, 1))\n    assert new_im.load()[2, 0] == 1\n\n    new_im = ImageOps.pad(im, (1, 4))\n    assert new_im.load()[0, 2] == 1\n\n\n@pytest.mark.parametrize(\"mode\", (\"P\", \"PA\"))\ndef test_palette(mode: str) -> None:\n    im = hopper(mode)\n\n    # Expand\n    expanded_im = ImageOps.expand(im)\n    assert_image_equal(im.convert(\"RGB\"), expanded_im.convert(\"RGB\"))\n\n    # Pad\n    padded_im = ImageOps.pad(im, (256, 128), centering=(0, 0))\n    assert_image_equal(\n        im.convert(\"RGB\"), padded_im.convert(\"RGB\").crop((0, 0, 128, 128))\n    )\n\n\ndef test_pil163() -> None:\n    # Division by zero in equalize if < 255 pixels in image (@PIL163)\n\n    i = hopper(\"RGB\").resize((15, 16))\n\n    ImageOps.equalize(i.convert(\"L\"))\n    ImageOps.equalize(i.convert(\"P\"))\n    ImageOps.equalize(i.convert(\"RGB\"))\n\n\ndef test_scale() -> None:\n    # Test the scaling function\n    i = hopper(\"L\").resize((50, 50))\n\n    with pytest.raises(ValueError):\n        ImageOps.scale(i, -1)\n\n    newimg = ImageOps.scale(i, 1)\n    assert newimg.size == (50, 50)\n\n    newimg = ImageOps.scale(i, 2)\n    assert newimg.size == (100, 100)\n\n    newimg = ImageOps.scale(i, 0.5)\n    assert newimg.size == (25, 25)\n\n\n@pytest.mark.parametrize(\"border\", (10, (1, 2, 3, 4)))\ndef test_expand_palette(border: int | tuple[int, int, int, int]) -> None:\n    with Image.open(\"Tests/images/p_16.tga\") as im:\n        im_expanded = ImageOps.expand(im, border, (255, 0, 0))\n\n        if isinstance(border, int):\n            left = top = right = bottom = border\n        else:\n            left, top, right, bottom = border\n        px = im_expanded.convert(\"RGB\").load()\n        for x in range(im_expanded.width):\n            for b in range(top):\n                assert px[x, b] == (255, 0, 0)\n            for b in range(bottom):\n                assert px[x, im_expanded.height - 1 - b] == (255, 0, 0)\n        for y in range(im_expanded.height):\n            for b in range(left):\n                assert px[b, y] == (255, 0, 0)\n            for b in range(right):\n                assert px[im_expanded.width - 1 - b, y] == (255, 0, 0)\n\n        im_cropped = im_expanded.crop(\n            (left, top, im_expanded.width - right, im_expanded.height - bottom)\n        )\n        assert_image_equal(im_cropped, im)\n\n\ndef test_colorize_2color() -> None:\n    # Test the colorizing function with 2-color functionality\n\n    # Open test image (256px by 10px, black to white)\n    with Image.open(\"Tests/images/bw_gradient.png\") as im:\n        im = im.convert(\"L\")\n\n    # Create image with original 2-color functionality\n    im_test = ImageOps.colorize(im, \"red\", \"green\")\n\n    # Test output image (2-color)\n    left = (0, 1)\n    middle = (127, 1)\n    right = (255, 1)\n    assert_tuple_approx_equal(\n        im_test.getpixel(left),\n        (255, 0, 0),\n        threshold=1,\n        msg=\"black test pixel incorrect\",\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(middle),\n        (127, 63, 0),\n        threshold=1,\n        msg=\"mid test pixel incorrect\",\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(right),\n        (0, 127, 0),\n        threshold=1,\n        msg=\"white test pixel incorrect\",\n    )\n\n\ndef test_colorize_2color_offset() -> None:\n    # Test the colorizing function with 2-color functionality and offset\n\n    # Open test image (256px by 10px, black to white)\n    with Image.open(\"Tests/images/bw_gradient.png\") as im:\n        im = im.convert(\"L\")\n\n    # Create image with original 2-color functionality with offsets\n    im_test = ImageOps.colorize(\n        im, black=\"red\", white=\"green\", blackpoint=50, whitepoint=100\n    )\n\n    # Test output image (2-color) with offsets\n    left = (25, 1)\n    middle = (75, 1)\n    right = (125, 1)\n    assert_tuple_approx_equal(\n        im_test.getpixel(left),\n        (255, 0, 0),\n        threshold=1,\n        msg=\"black test pixel incorrect\",\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(middle),\n        (127, 63, 0),\n        threshold=1,\n        msg=\"mid test pixel incorrect\",\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(right),\n        (0, 127, 0),\n        threshold=1,\n        msg=\"white test pixel incorrect\",\n    )\n\n\ndef test_colorize_3color_offset() -> None:\n    # Test the colorizing function with 3-color functionality and offset\n\n    # Open test image (256px by 10px, black to white)\n    with Image.open(\"Tests/images/bw_gradient.png\") as im:\n        im = im.convert(\"L\")\n\n    # Create image with new three color functionality with offsets\n    im_test = ImageOps.colorize(\n        im,\n        black=\"red\",\n        white=\"green\",\n        mid=\"blue\",\n        blackpoint=50,\n        whitepoint=200,\n        midpoint=100,\n    )\n\n    # Test output image (3-color) with offsets\n    left = (25, 1)\n    left_middle = (75, 1)\n    middle = (100, 1)\n    right_middle = (150, 1)\n    right = (225, 1)\n    assert_tuple_approx_equal(\n        im_test.getpixel(left),\n        (255, 0, 0),\n        threshold=1,\n        msg=\"black test pixel incorrect\",\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(left_middle),\n        (127, 0, 127),\n        threshold=1,\n        msg=\"low-mid test pixel incorrect\",\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(middle), (0, 0, 255), threshold=1, msg=\"mid incorrect\"\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(right_middle),\n        (0, 63, 127),\n        threshold=1,\n        msg=\"high-mid test pixel incorrect\",\n    )\n    assert_tuple_approx_equal(\n        im_test.getpixel(right),\n        (0, 127, 0),\n        threshold=1,\n        msg=\"white test pixel incorrect\",\n    )\n\n\ndef test_exif_transpose() -> None:\n    exts = [\".jpg\"]\n    if features.check(\"webp\") and features.check(\"webp_anim\"):\n        exts.append(\".webp\")\n    for ext in exts:\n        with Image.open(\"Tests/images/hopper\" + ext) as base_im:\n\n            def check(orientation_im: Image.Image) -> None:\n                for im in [\n                    orientation_im,\n                    orientation_im.copy(),\n                ]:  # ImageFile  # Image\n                    if orientation_im is base_im:\n                        assert \"exif\" not in im.info\n                    else:\n                        original_exif = im.info[\"exif\"]\n                    transposed_im = ImageOps.exif_transpose(im)\n                    assert transposed_im is not None\n                    assert_image_similar(base_im, transposed_im, 17)\n                    if orientation_im is base_im:\n                        assert \"exif\" not in im.info\n                    else:\n                        assert transposed_im.info[\"exif\"] != original_exif\n\n                        assert 0x0112 in im.getexif()\n                        assert 0x0112 not in transposed_im.getexif()\n\n                    # Repeat the operation to test that it does not keep transposing\n                    transposed_im2 = ImageOps.exif_transpose(transposed_im)\n                    assert transposed_im2 is not None\n                    assert_image_equal(transposed_im2, transposed_im)\n\n            check(base_im)\n            for i in range(2, 9):\n                with Image.open(\n                    \"Tests/images/hopper_orientation_\" + str(i) + ext\n                ) as orientation_im:\n                    check(orientation_im)\n\n    # Orientation from \"XML:com.adobe.xmp\" info key\n    for suffix in (\"\", \"_exiftool\"):\n        with Image.open(\"Tests/images/xmp_tags_orientation\" + suffix + \".png\") as im:\n            assert im.getexif()[0x0112] == 3\n\n            transposed_im = ImageOps.exif_transpose(im)\n            assert transposed_im is not None\n            assert 0x0112 not in transposed_im.getexif()\n\n            transposed_im._reload_exif()\n            assert 0x0112 not in transposed_im.getexif()\n\n    # Orientation from \"Raw profile type exif\" info key\n    # This test image has been manually hexedited from exif_imagemagick.png\n    # to have a different orientation\n    with Image.open(\"Tests/images/exif_imagemagick_orientation.png\") as im:\n        assert im.getexif()[0x0112] == 3\n\n        transposed_im = ImageOps.exif_transpose(im)\n        assert transposed_im is not None\n        assert 0x0112 not in transposed_im.getexif()\n\n    # Orientation set directly on Image.Exif\n    im = hopper()\n    im.getexif()[0x0112] = 3\n    transposed_im = ImageOps.exif_transpose(im)\n    assert transposed_im is not None\n    assert 0x0112 not in transposed_im.getexif()\n\n\ndef test_exif_transpose_in_place() -> None:\n    with Image.open(\"Tests/images/orientation_rectangle.jpg\") as im:\n        assert im.size == (2, 1)\n        assert im.getexif()[0x0112] == 8\n        expected = im.rotate(90, expand=True)\n\n        ImageOps.exif_transpose(im, in_place=True)\n        assert im.size == (1, 2)\n        assert 0x0112 not in im.getexif()\n        assert_image_equal(im, expected)\n\n\ndef test_autocontrast_unsupported_mode() -> None:\n    im = Image.new(\"RGBA\", (1, 1))\n    with pytest.raises(OSError):\n        ImageOps.autocontrast(im)\n\n\ndef test_autocontrast_cutoff() -> None:\n    # Test the cutoff argument of autocontrast\n    with Image.open(\"Tests/images/bw_gradient.png\") as img:\n\n        def autocontrast(cutoff: int | tuple[int, int]) -> list[int]:\n            return ImageOps.autocontrast(img, cutoff).histogram()\n\n        assert autocontrast(10) == autocontrast((10, 10))\n        assert autocontrast(10) != autocontrast((1, 10))\n\n\ndef test_autocontrast_mask_toy_input() -> None:\n    # Test the mask argument of autocontrast\n    with Image.open(\"Tests/images/bw_gradient.png\") as img:\n        rect_mask = Image.new(\"L\", img.size, 0)\n        draw = ImageDraw.Draw(rect_mask)\n        x0 = img.size[0] // 4\n        y0 = img.size[1] // 4\n        x1 = 3 * img.size[0] // 4\n        y1 = 3 * img.size[1] // 4\n        draw.rectangle((x0, y0, x1, y1), fill=255)\n\n        result = ImageOps.autocontrast(img, mask=rect_mask)\n        result_nomask = ImageOps.autocontrast(img)\n\n        assert result != result_nomask\n        assert ImageStat.Stat(result, mask=rect_mask).median == [127]\n        assert ImageStat.Stat(result_nomask).median == [128]\n\n\ndef test_autocontrast_mask_real_input() -> None:\n    # Test the autocontrast with a rectangular mask\n    with Image.open(\"Tests/images/iptc.jpg\") as img:\n        rect_mask = Image.new(\"L\", img.size, 0)\n        draw = ImageDraw.Draw(rect_mask)\n        x0, y0 = img.size[0] // 2, img.size[1] // 2\n        x1, y1 = img.size[0] - 40, img.size[1]\n        draw.rectangle((x0, y0, x1, y1), fill=255)\n\n        result = ImageOps.autocontrast(img, mask=rect_mask)\n        result_nomask = ImageOps.autocontrast(img)\n\n        assert result_nomask != result\n        assert_tuple_approx_equal(\n            ImageStat.Stat(result, mask=rect_mask).median,\n            (195, 202, 184),\n            threshold=2,\n            msg=\"autocontrast with mask pixel incorrect\",\n        )\n        assert_tuple_approx_equal(\n            ImageStat.Stat(result_nomask).median,\n            (119, 106, 79),\n            threshold=2,\n            msg=\"autocontrast without mask pixel incorrect\",\n        )\n\n\ndef test_autocontrast_preserve_tone() -> None:\n    def autocontrast(mode: str, preserve_tone: bool) -> list[int]:\n        im = hopper(mode)\n        return ImageOps.autocontrast(im, preserve_tone=preserve_tone).histogram()\n\n    assert autocontrast(\"RGB\", True) != autocontrast(\"RGB\", False)\n    assert autocontrast(\"L\", True) == autocontrast(\"L\", False)\n\n\ndef test_autocontrast_preserve_gradient() -> None:\n    gradient = Image.linear_gradient(\"L\")\n\n    # test with a grayscale gradient that extends to 0,255.\n    # Should be a noop.\n    out = ImageOps.autocontrast(gradient, cutoff=0, preserve_tone=True)\n\n    assert_image_equal(gradient, out)\n\n    # cutoff the top and bottom\n    # autocontrast should make the first and last histogram entries equal\n    # and, with rounding, should be 10% of the image pixels\n    out = ImageOps.autocontrast(gradient, cutoff=10, preserve_tone=True)\n    hist = out.histogram()\n    assert hist[0] == hist[-1]\n    assert hist[-1] == 256 * round(256 * 0.10)\n\n    # in rgb\n    img = gradient.convert(\"RGB\")\n    out = ImageOps.autocontrast(img, cutoff=0, preserve_tone=True)\n    assert_image_equal(img, out)\n\n\n@pytest.mark.parametrize(\n    \"color\", ((255, 255, 255), (127, 255, 0), (127, 127, 127), (0, 0, 0))\n)\ndef test_autocontrast_preserve_one_color(color: tuple[int, int, int]) -> None:\n    img = Image.new(\"RGB\", (10, 10), color)\n\n    # single color images shouldn't change\n    out = ImageOps.autocontrast(img, cutoff=0, preserve_tone=True)\n    assert_image_equal(img, out)  # single color, no cutoff\n\n    # even if there is a cutoff\n    out = ImageOps.autocontrast(\n        img, cutoff=10, preserve_tone=True\n    )  # single color 10 cutoff\n    assert_image_equal(img, out)\n", "Tests/test_imagefontctl.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageDraw, ImageFont\n\nfrom .helper import assert_image_similar_tofile, skip_unless_feature\n\nFONT_SIZE = 20\nFONT_PATH = \"Tests/fonts/DejaVuSans/DejaVuSans.ttf\"\n\npytestmark = skip_unless_feature(\"raqm\")\n\n\ndef test_english() -> None:\n    # smoke test, this should not fail\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"TEST\", font=ttf, fill=500, direction=\"ltr\")\n\n\ndef test_complex_text() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"\u0627\u0647\u0644\u0627 \u0639\u0645\u0627\u0646\", font=ttf, fill=500)\n\n    target = \"Tests/images/test_text.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\ndef test_y_offset() -> None:\n    ttf = ImageFont.truetype(\"Tests/fonts/NotoNastaliqUrdu-Regular.ttf\", FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"\u0627\u0644\u0639\u0627\u0644\u0645 \u0627\u0644\u0639\u0631\u0628\u064a\", font=ttf, fill=500)\n\n    target = \"Tests/images/test_y_offset.png\"\n    assert_image_similar_tofile(im, target, 1.7)\n\n\ndef test_complex_unicode_text() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"\u0627\u0644\u0633\u0644\u0627\u0645 \u0639\u0644\u064a\u0643\u0645\", font=ttf, fill=500)\n\n    target = \"Tests/images/test_complex_unicode_text.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n    ttf = ImageFont.truetype(\"Tests/fonts/KhmerOSBattambang-Regular.ttf\", FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"\u179b\u17c4\u1780\u17bb\u1794\u17d2\u1794\u178f\u17d2\u178f\u17b7\", font=ttf, fill=500)\n\n    target = \"Tests/images/test_complex_unicode_text2.png\"\n    assert_image_similar_tofile(im, target, 2.33)\n\n\ndef test_text_direction_rtl() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"English \u0639\u0631\u0628\u064a\", font=ttf, fill=500, direction=\"rtl\")\n\n    target = \"Tests/images/test_direction_rtl.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\ndef test_text_direction_ltr() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"\u0633\u0644\u0637\u0646\u0629 \u0639\u0645\u0627\u0646 Oman\", font=ttf, fill=500, direction=\"ltr\")\n\n    target = \"Tests/images/test_direction_ltr.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\ndef test_text_direction_rtl2() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"Oman \u0633\u0644\u0637\u0646\u0629 \u0639\u0645\u0627\u0646\", font=ttf, fill=500, direction=\"rtl\")\n\n    target = \"Tests/images/test_direction_ltr.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\ndef test_text_direction_ttb() -> None:\n    ttf = ImageFont.truetype(\"Tests/fonts/NotoSansJP-Regular.otf\", FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(100, 300))\n    draw = ImageDraw.Draw(im)\n    try:\n        draw.text((0, 0), \"English \u3042\u3044\", font=ttf, fill=500, direction=\"ttb\")\n    except ValueError as ex:\n        if str(ex) == \"libraqm 0.7 or greater required for 'ttb' direction\":\n            pytest.skip(\"libraqm 0.7 or greater not available\")\n\n    target = \"Tests/images/test_direction_ttb.png\"\n    assert_image_similar_tofile(im, target, 2.8)\n\n\ndef test_text_direction_ttb_stroke() -> None:\n    ttf = ImageFont.truetype(\"Tests/fonts/NotoSansJP-Regular.otf\", 50)\n\n    im = Image.new(mode=\"RGB\", size=(100, 300))\n    draw = ImageDraw.Draw(im)\n    try:\n        draw.text(\n            (27, 27),\n            \"\u3042\u3044\",\n            font=ttf,\n            fill=500,\n            direction=\"ttb\",\n            stroke_width=2,\n            stroke_fill=\"#0f0\",\n        )\n    except ValueError as ex:\n        if str(ex) == \"libraqm 0.7 or greater required for 'ttb' direction\":\n            pytest.skip(\"libraqm 0.7 or greater not available\")\n\n    target = \"Tests/images/test_direction_ttb_stroke.png\"\n    assert_image_similar_tofile(im, target, 19.4)\n\n\ndef test_ligature_features() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"filling\", font=ttf, fill=500, features=[\"-liga\"])\n    target = \"Tests/images/test_ligature_features.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n    liga_bbox = ttf.getbbox(\"fi\", features=[\"-liga\"])\n    assert liga_bbox == (0, 4, 13, 19)\n\n\ndef test_kerning_features() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"TeToAV\", font=ttf, fill=500, features=[\"-kern\"])\n\n    target = \"Tests/images/test_kerning_features.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\ndef test_arabictext_features() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text(\n        (0, 0),\n        \"\u0627\u0644\u0644\u063a\u0629 \u0627\u0644\u0639\u0631\u0628\u064a\u0629\",\n        font=ttf,\n        fill=500,\n        features=[\"-fina\", \"-init\", \"-medi\"],\n    )\n\n    target = \"Tests/images/test_arabictext_features.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\ndef test_x_max_and_y_offset() -> None:\n    ttf = ImageFont.truetype(\"Tests/fonts/ArefRuqaa-Regular.ttf\", 40)\n\n    im = Image.new(mode=\"RGB\", size=(50, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"\u0644\u062d\", font=ttf, fill=500)\n\n    target = \"Tests/images/test_x_max_and_y_offset.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\ndef test_language() -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n\n    im = Image.new(mode=\"RGB\", size=(300, 100))\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), \"\u0430\u0431\u0432\u0433\", font=ttf, fill=500, language=\"sr\")\n\n    target = \"Tests/images/test_language.png\"\n    assert_image_similar_tofile(im, target, 0.5)\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"1\"))\n@pytest.mark.parametrize(\n    \"text, direction, expected\",\n    (\n        (\"\u0633\u0644\u0637\u0646\u0629 \u0639\u0645\u0627\u0646 Oman\", None, 173.703125),\n        (\"\u0633\u0644\u0637\u0646\u0629 \u0639\u0645\u0627\u0646 Oman\", \"ltr\", 173.703125),\n        (\"Oman \u0633\u0644\u0637\u0646\u0629 \u0639\u0645\u0627\u0646\", \"rtl\", 173.703125),\n        (\"English \u0639\u0631\u0628\u064a\", \"rtl\", 123.796875),\n        (\"test\", \"ttb\", 80.0),\n    ),\n    ids=(\"None\", \"ltr\", \"rtl2\", \"rtl\", \"ttb\"),\n)\ndef test_getlength(\n    mode: str, text: str, direction: str | None, expected: float\n) -> None:\n    ttf = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n    im = Image.new(mode, (1, 1), 0)\n    d = ImageDraw.Draw(im)\n\n    try:\n        assert d.textlength(text, ttf, direction) == expected\n    except ValueError as ex:\n        if (\n            direction == \"ttb\"\n            and str(ex) == \"libraqm 0.7 or greater required for 'ttb' direction\"\n        ):\n            pytest.skip(\"libraqm 0.7 or greater not available\")\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"1\"))\n@pytest.mark.parametrize(\"direction\", (\"ltr\", \"ttb\"))\n@pytest.mark.parametrize(\n    \"text\",\n    (\"i\" + (\"\\u030C\" * 15) + \"i\", \"i\" + \"\\u032C\" * 15 + \"i\", \"\\u035Cii\", \"i\\u0305i\"),\n    ids=(\"caron-above\", \"caron-below\", \"double-breve\", \"overline\"),\n)\ndef test_getlength_combine(mode: str, direction: str, text: str) -> None:\n    if text == \"i\\u0305i\" and direction == \"ttb\":\n        pytest.skip(\"fails with this font\")\n\n    ttf = ImageFont.truetype(\"Tests/fonts/NotoSans-Regular.ttf\", 48)\n\n    try:\n        target = ttf.getlength(\"ii\", mode, direction)\n        actual = ttf.getlength(text, mode, direction)\n\n        assert actual == target\n    except ValueError as ex:\n        if (\n            direction == \"ttb\"\n            and str(ex) == \"libraqm 0.7 or greater required for 'ttb' direction\"\n        ):\n            pytest.skip(\"libraqm 0.7 or greater not available\")\n\n\n@pytest.mark.parametrize(\"anchor\", (\"lt\", \"mm\", \"rb\", \"sm\"))\ndef test_anchor_ttb(anchor: str) -> None:\n    text = \"f\"\n    path = f\"Tests/images/test_anchor_ttb_{text}_{anchor}.png\"\n    f = ImageFont.truetype(\"Tests/fonts/NotoSans-Regular.ttf\", 120)\n\n    im = Image.new(\"RGB\", (200, 400), \"white\")\n    d = ImageDraw.Draw(im)\n    d.line(((0, 200), (200, 200)), \"gray\")\n    d.line(((100, 0), (100, 400)), \"gray\")\n    try:\n        d.text((100, 200), text, fill=\"black\", anchor=anchor, direction=\"ttb\", font=f)\n    except ValueError as ex:\n        if str(ex) == \"libraqm 0.7 or greater required for 'ttb' direction\":\n            pytest.skip(\"libraqm 0.7 or greater not available\")\n\n    assert_image_similar_tofile(im, path, 1)  # fails at 5\n\n\ncombine_tests = (\n    # extends above (e.g. issue #4553)\n    (\"caron\", \"a\\u030C\\u030C\\u030C\\u030C\\u030Cb\", None, None, 0.08),\n    (\"caron_la\", \"a\\u030C\\u030C\\u030C\\u030C\\u030Cb\", \"la\", None, 0.08),\n    (\"caron_lt\", \"a\\u030C\\u030C\\u030C\\u030C\\u030Cb\", \"lt\", None, 0.08),\n    (\"caron_ls\", \"a\\u030C\\u030C\\u030C\\u030C\\u030Cb\", \"ls\", None, 0.08),\n    (\"caron_ttb\", \"ca\" + (\"\\u030C\" * 15) + \"b\", None, \"ttb\", 0.3),\n    (\"caron_ttb_lt\", \"ca\" + (\"\\u030C\" * 15) + \"b\", \"lt\", \"ttb\", 0.3),\n    # extends below\n    (\"caron_below\", \"a\\u032C\\u032C\\u032C\\u032C\\u032Cb\", None, None, 0.02),\n    (\"caron_below_ld\", \"a\\u032C\\u032C\\u032C\\u032C\\u032Cb\", \"ld\", None, 0.02),\n    (\"caron_below_lb\", \"a\\u032C\\u032C\\u032C\\u032C\\u032Cb\", \"lb\", None, 0.02),\n    (\"caron_below_ls\", \"a\\u032C\\u032C\\u032C\\u032C\\u032Cb\", \"ls\", None, 0.02),\n    (\"caron_below_ttb\", \"a\" + (\"\\u032C\" * 15) + \"b\", None, \"ttb\", 0.03),\n    (\"caron_below_ttb_lb\", \"a\" + (\"\\u032C\" * 15) + \"b\", \"lb\", \"ttb\", 0.03),\n    # extends to the right (e.g. issue #3745)\n    (\"double_breve_below\", \"a\\u035Ci\", None, None, 0.02),\n    (\"double_breve_below_ma\", \"a\\u035Ci\", \"ma\", None, 0.02),\n    (\"double_breve_below_ra\", \"a\\u035Ci\", \"ra\", None, 0.02),\n    (\"double_breve_below_ttb\", \"a\\u035Cb\", None, \"ttb\", 0.02),\n    (\"double_breve_below_ttb_rt\", \"a\\u035Cb\", \"rt\", \"ttb\", 0.02),\n    (\"double_breve_below_ttb_mt\", \"a\\u035Cb\", \"mt\", \"ttb\", 0.02),\n    (\"double_breve_below_ttb_st\", \"a\\u035Cb\", \"st\", \"ttb\", 0.02),\n    # extends to the left (fail=0.064)\n    (\"overline\", \"i\\u0305\", None, None, 0.02),\n    (\"overline_la\", \"i\\u0305\", \"la\", None, 0.02),\n    (\"overline_ra\", \"i\\u0305\", \"ra\", None, 0.02),\n    (\"overline_ttb\", \"i\\u0305\", None, \"ttb\", 0.02),\n    (\"overline_ttb_rt\", \"i\\u0305\", \"rt\", \"ttb\", 0.02),\n    (\"overline_ttb_mt\", \"i\\u0305\", \"mt\", \"ttb\", 0.02),\n    (\"overline_ttb_st\", \"i\\u0305\", \"st\", \"ttb\", 0.02),\n)\n\n\n# this tests various combining characters for anchor alignment and clipping\n@pytest.mark.parametrize(\n    \"name, text, anchor, dir, epsilon\", combine_tests, ids=[r[0] for r in combine_tests]\n)\ndef test_combine(\n    name: str, text: str, dir: str | None, anchor: str | None, epsilon: float\n) -> None:\n    path = f\"Tests/images/test_combine_{name}.png\"\n    f = ImageFont.truetype(\"Tests/fonts/NotoSans-Regular.ttf\", 48)\n\n    im = Image.new(\"RGB\", (400, 400), \"white\")\n    d = ImageDraw.Draw(im)\n    d.line(((0, 200), (400, 200)), \"gray\")\n    d.line(((200, 0), (200, 400)), \"gray\")\n    try:\n        d.text((200, 200), text, fill=\"black\", anchor=anchor, direction=dir, font=f)\n    except ValueError as ex:\n        if str(ex) == \"libraqm 0.7 or greater required for 'ttb' direction\":\n            pytest.skip(\"libraqm 0.7 or greater not available\")\n\n    assert_image_similar_tofile(im, path, epsilon)\n\n\n@pytest.mark.parametrize(\n    \"anchor, align\",\n    (\n        (\"lm\", \"left\"),  # pass with getsize\n        (\"lm\", \"center\"),  # fail at 2.12\n        (\"lm\", \"right\"),  # fail at 2.57\n        (\"mm\", \"left\"),  # fail at 2.12\n        (\"mm\", \"center\"),  # pass with getsize\n        (\"mm\", \"right\"),  # fail at 2.12\n        (\"rm\", \"left\"),  # fail at 2.57\n        (\"rm\", \"center\"),  # fail at 2.12\n        (\"rm\", \"right\"),  # pass with getsize\n    ),\n)\ndef test_combine_multiline(anchor: str, align: str) -> None:\n    # test that multiline text uses getlength, not getsize or getbbox\n\n    path = f\"Tests/images/test_combine_multiline_{anchor}_{align}.png\"\n    f = ImageFont.truetype(\"Tests/fonts/NotoSans-Regular.ttf\", 48)\n    text = \"i\\u0305\\u035C\\ntext\"  # i with overline and double breve, and a word\n\n    im = Image.new(\"RGB\", (400, 400), \"white\")\n    d = ImageDraw.Draw(im)\n    d.line(((0, 200), (400, 200)), \"gray\")\n    d.line(((200, 0), (200, 400)), \"gray\")\n    bbox = d.multiline_textbbox((200, 200), text, anchor=anchor, font=f, align=align)\n    d.rectangle(bbox, outline=\"red\")\n    d.multiline_text((200, 200), text, fill=\"black\", anchor=anchor, font=f, align=align)\n\n    assert_image_similar_tofile(im, path, 0.015)\n\n\ndef test_anchor_invalid_ttb() -> None:\n    font = ImageFont.truetype(FONT_PATH, FONT_SIZE)\n    im = Image.new(\"RGB\", (100, 100), \"white\")\n    d = ImageDraw.Draw(im)\n    d.font = font\n\n    for anchor in [\"\", \"l\", \"a\", \"lax\", \"xa\", \"la\", \"ls\", \"ld\", \"lx\"]:\n        with pytest.raises(ValueError):\n            font.getmask2(\"hello\", anchor=anchor, direction=\"ttb\")\n        with pytest.raises(ValueError):\n            font.getbbox(\"hello\", anchor=anchor, direction=\"ttb\")\n        with pytest.raises(ValueError):\n            d.text((0, 0), \"hello\", anchor=anchor, direction=\"ttb\")\n        with pytest.raises(ValueError):\n            d.textbbox((0, 0), \"hello\", anchor=anchor, direction=\"ttb\")\n        with pytest.raises(ValueError):\n            d.multiline_text((0, 0), \"foo\\nbar\", anchor=anchor, direction=\"ttb\")\n        with pytest.raises(ValueError):\n            d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=anchor, direction=\"ttb\")\n    # ttb multiline text does not support anchors at all\n    with pytest.raises(ValueError):\n        d.multiline_text((0, 0), \"foo\\nbar\", anchor=\"mm\", direction=\"ttb\")\n    with pytest.raises(ValueError):\n        d.multiline_textbbox((0, 0), \"foo\\nbar\", anchor=\"mm\", direction=\"ttb\")\n", "Tests/test_features.py": "from __future__ import annotations\n\nimport io\nimport re\nfrom typing import Callable\n\nimport pytest\n\nfrom PIL import features\n\nfrom .helper import skip_unless_feature\n\ntry:\n    from PIL import _webp\nexcept ImportError:\n    pass\n\n\ndef test_check() -> None:\n    # Check the correctness of the convenience function\n    for module in features.modules:\n        assert features.check_module(module) == features.check(module)\n    for codec in features.codecs:\n        assert features.check_codec(codec) == features.check(codec)\n    for feature in features.features:\n        assert features.check_feature(feature) == features.check(feature)\n\n\ndef test_version() -> None:\n    # Check the correctness of the convenience function\n    # and the format of version numbers\n\n    def test(name: str, function: Callable[[str], str | None]) -> None:\n        version = features.version(name)\n        if not features.check(name):\n            assert version is None\n        else:\n            assert function(name) == version\n            if name != \"PIL\":\n                if name == \"zlib\" and version is not None:\n                    version = re.sub(\".zlib-ng$\", \"\", version)\n                elif name == \"libtiff\" and version is not None:\n                    version = re.sub(\"t$\", \"\", version)\n                assert version is None or re.search(r\"\\d+(\\.\\d+)*$\", version)\n\n    for module in features.modules:\n        test(module, features.version_module)\n    for codec in features.codecs:\n        test(codec, features.version_codec)\n    for feature in features.features:\n        test(feature, features.version_feature)\n\n\n@skip_unless_feature(\"webp\")\ndef test_webp_transparency() -> None:\n    assert features.check(\"transp_webp\") != _webp.WebPDecoderBuggyAlpha()\n    assert features.check(\"transp_webp\") == _webp.HAVE_TRANSPARENCY\n\n\n@skip_unless_feature(\"webp\")\ndef test_webp_mux() -> None:\n    assert features.check(\"webp_mux\") == _webp.HAVE_WEBPMUX\n\n\n@skip_unless_feature(\"webp\")\ndef test_webp_anim() -> None:\n    assert features.check(\"webp_anim\") == _webp.HAVE_WEBPANIM\n\n\n@skip_unless_feature(\"libjpeg_turbo\")\ndef test_libjpeg_turbo_version() -> None:\n    version = features.version(\"libjpeg_turbo\")\n    assert version is not None\n    assert re.search(r\"\\d+\\.\\d+\\.\\d+$\", version)\n\n\n@skip_unless_feature(\"libimagequant\")\ndef test_libimagequant_version() -> None:\n    version = features.version(\"libimagequant\")\n    assert version is not None\n    assert re.search(r\"\\d+\\.\\d+\\.\\d+$\", version)\n\n\n@pytest.mark.parametrize(\"feature\", features.modules)\ndef test_check_modules(feature: str) -> None:\n    assert features.check_module(feature) in [True, False]\n\n\n@pytest.mark.parametrize(\"feature\", features.codecs)\ndef test_check_codecs(feature: str) -> None:\n    assert features.check_codec(feature) in [True, False]\n\n\ndef test_check_warns_on_nonexistent() -> None:\n    with pytest.warns(UserWarning) as cm:\n        has_feature = features.check(\"typo\")\n    assert has_feature is False\n    assert str(cm[-1].message) == \"Unknown feature 'typo'.\"\n\n\ndef test_supported_modules() -> None:\n    assert isinstance(features.get_supported_modules(), list)\n    assert isinstance(features.get_supported_codecs(), list)\n    assert isinstance(features.get_supported_features(), list)\n    assert isinstance(features.get_supported(), list)\n\n\ndef test_unsupported_codec() -> None:\n    # Arrange\n    codec = \"unsupported_codec\"\n    # Act / Assert\n    with pytest.raises(ValueError):\n        features.check_codec(codec)\n    with pytest.raises(ValueError):\n        features.version_codec(codec)\n\n\ndef test_unsupported_module() -> None:\n    # Arrange\n    module = \"unsupported_module\"\n    # Act / Assert\n    with pytest.raises(ValueError):\n        features.check_module(module)\n    with pytest.raises(ValueError):\n        features.version_module(module)\n\n\n@pytest.mark.parametrize(\"supported_formats\", (True, False))\ndef test_pilinfo(supported_formats: bool) -> None:\n    buf = io.StringIO()\n    features.pilinfo(buf, supported_formats=supported_formats)\n    out = buf.getvalue()\n    lines = out.splitlines()\n    assert lines[0] == \"-\" * 68\n    assert lines[1].startswith(\"Pillow \")\n    assert lines[2].startswith(\"Python \")\n    lines = lines[3:]\n    while lines[0].startswith(\"    \"):\n        lines = lines[1:]\n    assert lines[0] == \"-\" * 68\n    assert lines[1].startswith(\"Python executable is\")\n    lines = lines[2:]\n    if lines[0].startswith(\"Environment Python files loaded from\"):\n        lines = lines[1:]\n    assert lines[0].startswith(\"System Python files loaded from\")\n    assert lines[1] == \"-\" * 68\n    assert lines[2].startswith(\"Python Pillow modules loaded from \")\n    assert lines[3].startswith(\"Binary Pillow modules loaded from \")\n    assert lines[4] == \"-\" * 68\n    jpeg = (\n        \"\\n\"\n        + \"-\" * 68\n        + \"\\n\"\n        + \"JPEG image/jpeg\\n\"\n        + \"Extensions: .jfif, .jpe, .jpeg, .jpg\\n\"\n        + \"Features: open, save\\n\"\n        + \"-\" * 68\n        + \"\\n\"\n    )\n    assert supported_formats == (jpeg in out)\n", "Tests/test_image_load.py": "from __future__ import annotations\n\nimport logging\nimport os\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    im = hopper()\n    pix = im.load()\n\n    assert pix[0, 0] == (20, 20, 70)\n\n\ndef test_close() -> None:\n    im = Image.open(\"Tests/images/hopper.gif\")\n    im.close()\n    with pytest.raises(ValueError):\n        im.load()\n    with pytest.raises(ValueError):\n        im.getpixel((0, 0))\n\n\ndef test_close_after_load(caplog: pytest.LogCaptureFixture) -> None:\n    im = Image.open(\"Tests/images/hopper.gif\")\n    im.load()\n    with caplog.at_level(logging.DEBUG):\n        im.close()\n    assert len(caplog.records) == 0\n\n\ndef test_contextmanager() -> None:\n    fn = None\n    with Image.open(\"Tests/images/hopper.gif\") as im:\n        fn = im.fp.fileno()\n        os.fstat(fn)\n\n    with pytest.raises(OSError):\n        os.fstat(fn)\n\n\ndef test_contextmanager_non_exclusive_fp() -> None:\n    with open(\"Tests/images/hopper.gif\", \"rb\") as fp:\n        with Image.open(fp):\n            pass\n\n        assert not fp.closed\n", "Tests/test_image.py": "from __future__ import annotations\n\nimport io\nimport logging\nimport os\nimport shutil\nimport sys\nimport tempfile\nimport warnings\nfrom pathlib import Path\nfrom typing import IO, Any\n\nimport pytest\n\nfrom PIL import (\n    ExifTags,\n    Image,\n    ImageDraw,\n    ImageFile,\n    ImagePalette,\n    UnidentifiedImageError,\n    features,\n)\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    assert_image_similar_tofile,\n    assert_not_all_same,\n    hopper,\n    is_big_endian,\n    is_win32,\n    mark_if_feature_version,\n    skip_unless_feature,\n)\n\n\n# Deprecation helper\ndef helper_image_new(mode: str, size: tuple[int, int]) -> Image.Image:\n    if mode.startswith(\"BGR;\"):\n        with pytest.warns(DeprecationWarning):\n            return Image.new(mode, size)\n    else:\n        return Image.new(mode, size)\n\n\nclass TestImage:\n    @pytest.mark.parametrize(\"mode\", Image.MODES + [\"BGR;15\", \"BGR;16\", \"BGR;24\"])\n    def test_image_modes_success(self, mode: str) -> None:\n        helper_image_new(mode, (1, 1))\n\n    @pytest.mark.parametrize(\"mode\", (\"\", \"bad\", \"very very long\"))\n    def test_image_modes_fail(self, mode: str) -> None:\n        with pytest.raises(ValueError) as e:\n            Image.new(mode, (1, 1))\n        assert str(e.value) == \"unrecognized image mode\"\n\n    def test_exception_inheritance(self) -> None:\n        assert issubclass(UnidentifiedImageError, OSError)\n\n    def test_sanity(self) -> None:\n        im = Image.new(\"L\", (100, 100))\n        assert repr(im)[:45] == \"<PIL.Image.Image image mode=L size=100x100 at\"\n        assert im.mode == \"L\"\n        assert im.size == (100, 100)\n\n        im = Image.new(\"RGB\", (100, 100))\n        assert repr(im)[:45] == \"<PIL.Image.Image image mode=RGB size=100x100 \"\n        assert im.mode == \"RGB\"\n        assert im.size == (100, 100)\n\n        Image.new(\"L\", (100, 100), None)\n        im2 = Image.new(\"L\", (100, 100), 0)\n        im3 = Image.new(\"L\", (100, 100), \"black\")\n\n        assert im2.getcolors() == [(10000, 0)]\n        assert im3.getcolors() == [(10000, 0)]\n\n        with pytest.raises(ValueError):\n            Image.new(\"X\", (100, 100))\n        with pytest.raises(ValueError):\n            Image.new(\"\", (100, 100))\n        # with pytest.raises(MemoryError):\n        #   Image.new(\"L\", (1000000, 1000000))\n\n    def test_repr_pretty(self) -> None:\n        class Pretty:\n            def text(self, text: str) -> None:\n                self.pretty_output = text\n\n        im = Image.new(\"L\", (100, 100))\n\n        p = Pretty()\n        im._repr_pretty_(p, None)\n        assert p.pretty_output == \"<PIL.Image.Image image mode=L size=100x100>\"\n\n    def test_open_formats(self) -> None:\n        PNGFILE = \"Tests/images/hopper.png\"\n        JPGFILE = \"Tests/images/hopper.jpg\"\n\n        with pytest.raises(TypeError):\n            with Image.open(PNGFILE, formats=123):  # type: ignore[arg-type]\n                pass\n\n        format_list: list[list[str] | tuple[str, ...]] = [\n            [\"JPEG\"],\n            (\"JPEG\",),\n            [\"jpeg\"],\n            [\"Jpeg\"],\n            [\"jPeG\"],\n            [\"JpEg\"],\n        ]\n        for formats in format_list:\n            with pytest.raises(UnidentifiedImageError):\n                with Image.open(PNGFILE, formats=formats):\n                    pass\n\n            with Image.open(JPGFILE, formats=formats) as im:\n                assert im.mode == \"RGB\"\n                assert im.size == (128, 128)\n\n        for file in [PNGFILE, JPGFILE]:\n            with Image.open(file, formats=None) as im:\n                assert im.mode == \"RGB\"\n                assert im.size == (128, 128)\n\n    def test_width_height(self) -> None:\n        im = Image.new(\"RGB\", (1, 2))\n        assert im.width == 1\n        assert im.height == 2\n\n        with pytest.raises(AttributeError):\n            im.size = (3, 4)  # type: ignore[misc]\n\n    def test_set_mode(self) -> None:\n        im = Image.new(\"RGB\", (1, 1))\n\n        with pytest.raises(AttributeError):\n            im.mode = \"P\"  # type: ignore[misc]\n\n    def test_invalid_image(self) -> None:\n        im = io.BytesIO(b\"\")\n        with pytest.raises(UnidentifiedImageError):\n            with Image.open(im):\n                pass\n\n    def test_bad_mode(self) -> None:\n        with pytest.raises(ValueError):\n            with Image.open(\"filename\", \"bad mode\"):  # type: ignore[arg-type]\n                pass\n\n    def test_stringio(self) -> None:\n        with pytest.raises(ValueError):\n            with Image.open(io.StringIO()):  # type: ignore[arg-type]\n                pass\n\n    def test_pathlib(self, tmp_path: Path) -> None:\n        with Image.open(Path(\"Tests/images/multipage-mmap.tiff\")) as im:\n            assert im.mode == \"P\"\n            assert im.size == (10, 10)\n\n        with Image.open(Path(\"Tests/images/hopper.jpg\")) as im:\n            assert im.mode == \"RGB\"\n            assert im.size == (128, 128)\n\n            for ext in (\".jpg\", \".jp2\"):\n                if ext == \".jp2\" and not features.check_codec(\"jpg_2000\"):\n                    pytest.skip(\"jpg_2000 not available\")\n                temp_file = str(tmp_path / (\"temp.\" + ext))\n                if os.path.exists(temp_file):\n                    os.remove(temp_file)\n                im.save(Path(temp_file))\n\n    def test_fp_name(self, tmp_path: Path) -> None:\n        temp_file = str(tmp_path / \"temp.jpg\")\n\n        class FP(io.BytesIO):\n            name: str\n\n            if sys.version_info >= (3, 12):\n                from collections.abc import Buffer\n\n                def write(self, data: Buffer) -> int:\n                    return len(data)\n\n            else:\n\n                def write(self, data: Any) -> int:\n                    return len(data)\n\n        fp = FP()\n        fp.name = temp_file\n\n        im = hopper()\n        im.save(fp)\n\n    def test_tempfile(self) -> None:\n        # see #1460, pathlib support breaks tempfile.TemporaryFile on py27\n        # Will error out on save on 3.0.0\n        im = hopper()\n        with tempfile.TemporaryFile() as fp:\n            im.save(fp, \"JPEG\")\n            fp.seek(0)\n            with Image.open(fp) as reloaded:\n                assert_image_similar(im, reloaded, 20)\n\n    def test_unknown_extension(self, tmp_path: Path) -> None:\n        im = hopper()\n        temp_file = str(tmp_path / \"temp.unknown\")\n        with pytest.raises(ValueError):\n            im.save(temp_file)\n\n    def test_internals(self) -> None:\n        im = Image.new(\"L\", (100, 100))\n        im.readonly = 1\n        im._copy()\n        assert not im.readonly\n\n        im.readonly = 1\n        im.paste(0, (0, 0, 100, 100))\n        assert not im.readonly\n\n    @pytest.mark.skipif(is_win32(), reason=\"Test requires opening tempfile twice\")\n    @pytest.mark.skipif(\n        sys.platform == \"cygwin\",\n        reason=\"Test requires opening an mmaped file for writing\",\n    )\n    def test_readonly_save(self, tmp_path: Path) -> None:\n        temp_file = str(tmp_path / \"temp.bmp\")\n        shutil.copy(\"Tests/images/rgb32bf-rgba.bmp\", temp_file)\n\n        with Image.open(temp_file) as im:\n            assert im.readonly\n            im.save(temp_file)\n\n    def test_dump(self, tmp_path: Path) -> None:\n        im = Image.new(\"L\", (10, 10))\n        im._dump(str(tmp_path / \"temp_L.ppm\"))\n\n        im = Image.new(\"RGB\", (10, 10))\n        im._dump(str(tmp_path / \"temp_RGB.ppm\"))\n\n        im = Image.new(\"HSV\", (10, 10))\n        with pytest.raises(ValueError):\n            im._dump(str(tmp_path / \"temp_HSV.ppm\"))\n\n    def test_comparison_with_other_type(self) -> None:\n        # Arrange\n        item = Image.new(\"RGB\", (25, 25), \"#000\")\n        num = 12\n\n        # Act/Assert\n        # Shouldn't cause AttributeError (#774)\n        assert item is not None\n        assert item != num\n\n    def test_expand_x(self) -> None:\n        # Arrange\n        im = hopper()\n        orig_size = im.size\n        xmargin = 5\n\n        # Act\n        im = im._expand(xmargin)\n\n        # Assert\n        assert im.size[0] == orig_size[0] + 2 * xmargin\n        assert im.size[1] == orig_size[1] + 2 * xmargin\n\n    def test_expand_xy(self) -> None:\n        # Arrange\n        im = hopper()\n        orig_size = im.size\n        xmargin = 5\n        ymargin = 3\n\n        # Act\n        im = im._expand(xmargin, ymargin)\n\n        # Assert\n        assert im.size[0] == orig_size[0] + 2 * xmargin\n        assert im.size[1] == orig_size[1] + 2 * ymargin\n\n    def test_getbands(self) -> None:\n        # Assert\n        assert hopper(\"RGB\").getbands() == (\"R\", \"G\", \"B\")\n        assert hopper(\"YCbCr\").getbands() == (\"Y\", \"Cb\", \"Cr\")\n\n    def test_getchannel_wrong_params(self) -> None:\n        im = hopper()\n\n        with pytest.raises(ValueError):\n            im.getchannel(-1)\n        with pytest.raises(ValueError):\n            im.getchannel(3)\n        with pytest.raises(ValueError):\n            im.getchannel(\"Z\")\n        with pytest.raises(ValueError):\n            im.getchannel(\"1\")\n\n    def test_getchannel(self) -> None:\n        im = hopper(\"YCbCr\")\n        Y, Cb, Cr = im.split()\n\n        assert_image_equal(Y, im.getchannel(0))\n        assert_image_equal(Y, im.getchannel(\"Y\"))\n        assert_image_equal(Cb, im.getchannel(1))\n        assert_image_equal(Cb, im.getchannel(\"Cb\"))\n        assert_image_equal(Cr, im.getchannel(2))\n        assert_image_equal(Cr, im.getchannel(\"Cr\"))\n\n    def test_getbbox(self) -> None:\n        # Arrange\n        im = hopper()\n\n        # Act\n        bbox = im.getbbox()\n\n        # Assert\n        assert bbox == (0, 0, 128, 128)\n\n    def test_ne(self) -> None:\n        # Arrange\n        im1 = Image.new(\"RGB\", (25, 25), \"black\")\n        im2 = Image.new(\"RGB\", (25, 25), \"white\")\n\n        # Act / Assert\n        assert im1 != im2\n\n    def test_alpha_composite(self) -> None:\n        # https://stackoverflow.com/questions/3374878\n        # Arrange\n        expected_colors = sorted(\n            [\n                (1122, (128, 127, 0, 255)),\n                (1089, (0, 255, 0, 255)),\n                (3300, (255, 0, 0, 255)),\n                (1156, (170, 85, 0, 192)),\n                (1122, (0, 255, 0, 128)),\n                (1122, (255, 0, 0, 128)),\n                (1089, (0, 255, 0, 0)),\n            ]\n        )\n\n        dst = Image.new(\"RGBA\", size=(100, 100), color=(0, 255, 0, 255))\n        draw = ImageDraw.Draw(dst)\n        draw.rectangle((0, 33, 100, 66), fill=(0, 255, 0, 128))\n        draw.rectangle((0, 67, 100, 100), fill=(0, 255, 0, 0))\n        src = Image.new(\"RGBA\", size=(100, 100), color=(255, 0, 0, 255))\n        draw = ImageDraw.Draw(src)\n        draw.rectangle((33, 0, 66, 100), fill=(255, 0, 0, 128))\n        draw.rectangle((67, 0, 100, 100), fill=(255, 0, 0, 0))\n\n        # Act\n        img = Image.alpha_composite(dst, src)\n\n        # Assert\n        img_colors = sorted(img.getcolors())\n        assert img_colors == expected_colors\n\n    def test_alpha_inplace(self) -> None:\n        src = Image.new(\"RGBA\", (128, 128), \"blue\")\n\n        over = Image.new(\"RGBA\", (128, 128), \"red\")\n        mask = hopper(\"L\")\n        over.putalpha(mask)\n\n        target = Image.alpha_composite(src, over)\n\n        # basic\n        full = src.copy()\n        full.alpha_composite(over)\n        assert_image_equal(full, target)\n\n        # with offset down to right\n        offset = src.copy()\n        offset.alpha_composite(over, (64, 64))\n        assert_image_equal(offset.crop((64, 64, 127, 127)), target.crop((0, 0, 63, 63)))\n        assert offset.size == (128, 128)\n\n        # with negative offset\n        offset = src.copy()\n        offset.alpha_composite(over, (-64, -64))\n        assert_image_equal(offset.crop((0, 0, 63, 63)), target.crop((64, 64, 127, 127)))\n        assert offset.size == (128, 128)\n\n        # offset and crop\n        box = src.copy()\n        box.alpha_composite(over, (64, 64), (0, 0, 32, 32))\n        assert_image_equal(box.crop((64, 64, 96, 96)), target.crop((0, 0, 32, 32)))\n        assert_image_equal(box.crop((96, 96, 128, 128)), src.crop((0, 0, 32, 32)))\n        assert box.size == (128, 128)\n\n        # source point\n        source = src.copy()\n        source.alpha_composite(over, (32, 32), (32, 32, 96, 96))\n\n        assert_image_equal(source.crop((32, 32, 96, 96)), target.crop((32, 32, 96, 96)))\n        assert source.size == (128, 128)\n\n        # errors\n        with pytest.raises(ValueError):\n            source.alpha_composite(over, \"invalid destination\")  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            source.alpha_composite(over, (0, 0), \"invalid source\")  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            source.alpha_composite(over, 0)  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            source.alpha_composite(over, (0, 0), 0)  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            source.alpha_composite(over, (0, 0), (0, -1))\n\n    def test_register_open_duplicates(self) -> None:\n        # Arrange\n        factory, accept = Image.OPEN[\"JPEG\"]\n        id_length = len(Image.ID)\n\n        # Act\n        Image.register_open(\"JPEG\", factory, accept)\n\n        # Assert\n        assert len(Image.ID) == id_length\n\n    def test_registered_extensions_uninitialized(self) -> None:\n        # Arrange\n        Image._initialized = 0\n\n        # Act\n        Image.registered_extensions()\n\n        # Assert\n        assert Image._initialized == 2\n\n    def test_registered_extensions(self) -> None:\n        # Arrange\n        # Open an image to trigger plugin registration\n        with Image.open(\"Tests/images/rgb.jpg\"):\n            pass\n\n        # Act\n        extensions = Image.registered_extensions()\n\n        # Assert\n        assert extensions\n        for ext in [\".cur\", \".icns\", \".tif\", \".tiff\"]:\n            assert ext in extensions\n\n    def test_effect_mandelbrot(self) -> None:\n        # Arrange\n        size = (512, 512)\n        extent = (-3, -2.5, 2, 2.5)\n        quality = 100\n\n        # Act\n        im = Image.effect_mandelbrot(size, extent, quality)\n\n        # Assert\n        assert im.size == (512, 512)\n        assert_image_equal_tofile(im, \"Tests/images/effect_mandelbrot.png\")\n\n    def test_effect_mandelbrot_bad_arguments(self) -> None:\n        # Arrange\n        size = (512, 512)\n        # Get coordinates the wrong way round:\n        extent = (+3, +2.5, -2, -2.5)\n        # Quality < 2:\n        quality = 1\n\n        # Act/Assert\n        with pytest.raises(ValueError):\n            Image.effect_mandelbrot(size, extent, quality)\n\n    def test_effect_noise(self) -> None:\n        # Arrange\n        size = (100, 100)\n        sigma = 128\n\n        # Act\n        im = Image.effect_noise(size, sigma)\n\n        # Assert\n        assert im.size == (100, 100)\n        assert im.mode == \"L\"\n        p0 = im.getpixel((0, 0))\n        p1 = im.getpixel((0, 1))\n        p2 = im.getpixel((0, 2))\n        p3 = im.getpixel((0, 3))\n        p4 = im.getpixel((0, 4))\n        assert_not_all_same([p0, p1, p2, p3, p4])\n\n    def test_effect_spread(self) -> None:\n        # Arrange\n        im = hopper()\n        distance = 10\n\n        # Act\n        im2 = im.effect_spread(distance)\n\n        # Assert\n        assert im.size == (128, 128)\n        assert_image_similar_tofile(im2, \"Tests/images/effect_spread.png\", 110)\n\n    def test_effect_spread_zero(self) -> None:\n        # Arrange\n        im = hopper()\n        distance = 0\n\n        # Act\n        im2 = im.effect_spread(distance)\n\n        # Assert\n        assert_image_equal(im, im2)\n\n    def test_check_size(self) -> None:\n        # Checking that the _check_size function throws value errors when we want it to\n        with pytest.raises(ValueError):\n            # not a tuple\n            Image.new(\"RGB\", 0)  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            # tuple too short\n            Image.new(\"RGB\", (0,))  # type: ignore[arg-type]\n        with pytest.raises(ValueError):\n            Image.new(\"RGB\", (-1, -1))  # w,h < 0\n\n        # this should pass with 0 sized images, #2259\n        im = Image.new(\"L\", (0, 0))\n        assert im.size == (0, 0)\n\n        im = Image.new(\"L\", (0, 100))\n        assert im.size == (0, 100)\n\n        im = Image.new(\"L\", (100, 0))\n        assert im.size == (100, 0)\n\n        assert Image.new(\"RGB\", (1, 1))\n        # Should pass lists too\n        i = Image.new(\"RGB\", [1, 1])\n        assert isinstance(i.size, tuple)\n\n    @pytest.mark.timeout(0.75)\n    @pytest.mark.skipif(\n        \"PILLOW_VALGRIND_TEST\" in os.environ, reason=\"Valgrind is slower\"\n    )\n    @pytest.mark.parametrize(\"size\", ((0, 100000000), (100000000, 0)))\n    def test_empty_image(self, size: tuple[int, int]) -> None:\n        Image.new(\"RGB\", size)\n\n    def test_storage_neg(self) -> None:\n        # Storage.c accepted negative values for xsize, ysize.  Was\n        # test_neg_ppm, but the core function for that has been\n        # removed Calling directly into core to test the error in\n        # Storage.c, rather than the size check above\n\n        with pytest.raises(ValueError):\n            Image.core.fill(\"RGB\", (2, -2), (0, 0, 0))\n\n    def test_one_item_tuple(self) -> None:\n        for mode in (\"I\", \"F\", \"L\"):\n            im = Image.new(mode, (100, 100), (5,))\n            px = im.load()\n            assert px[0, 0] == 5\n\n    def test_linear_gradient_wrong_mode(self) -> None:\n        # Arrange\n        wrong_mode = \"RGB\"\n\n        # Act / Assert\n        with pytest.raises(ValueError):\n            Image.linear_gradient(wrong_mode)\n\n    @pytest.mark.parametrize(\"mode\", (\"L\", \"P\", \"I\", \"F\"))\n    def test_linear_gradient(self, mode: str) -> None:\n        # Arrange\n        target_file = \"Tests/images/linear_gradient.png\"\n\n        # Act\n        im = Image.linear_gradient(mode)\n\n        # Assert\n        assert im.size == (256, 256)\n        assert im.mode == mode\n        assert im.getpixel((0, 0)) == 0\n        assert im.getpixel((255, 255)) == 255\n        with Image.open(target_file) as target:\n            target = target.convert(mode)\n        assert_image_equal(im, target)\n\n    def test_radial_gradient_wrong_mode(self) -> None:\n        # Arrange\n        wrong_mode = \"RGB\"\n\n        # Act / Assert\n        with pytest.raises(ValueError):\n            Image.radial_gradient(wrong_mode)\n\n    @pytest.mark.parametrize(\"mode\", (\"L\", \"P\", \"I\", \"F\"))\n    def test_radial_gradient(self, mode: str) -> None:\n        # Arrange\n        target_file = \"Tests/images/radial_gradient.png\"\n\n        # Act\n        im = Image.radial_gradient(mode)\n\n        # Assert\n        assert im.size == (256, 256)\n        assert im.mode == mode\n        assert im.getpixel((0, 0)) == 255\n        assert im.getpixel((128, 128)) == 0\n        with Image.open(target_file) as target:\n            target = target.convert(mode)\n        assert_image_equal(im, target)\n\n    def test_register_extensions(self) -> None:\n        test_format = \"a\"\n        exts = [\"b\", \"c\"]\n        for ext in exts:\n            Image.register_extension(test_format, ext)\n        ext_individual = Image.EXTENSION.copy()\n        for ext in exts:\n            del Image.EXTENSION[ext]\n\n        Image.register_extensions(test_format, exts)\n        ext_multiple = Image.EXTENSION.copy()\n        for ext in exts:\n            del Image.EXTENSION[ext]\n\n        assert ext_individual == ext_multiple\n\n    def test_remap_palette(self) -> None:\n        # Test identity transform\n        with Image.open(\"Tests/images/hopper.gif\") as im:\n            assert_image_equal(im, im.remap_palette(list(range(256))))\n\n        # Test identity transform with an RGBA palette\n        im = Image.new(\"P\", (256, 1))\n        for x in range(256):\n            im.putpixel((x, 0), x)\n        im.putpalette(list(range(256)) * 4, \"RGBA\")\n        im_remapped = im.remap_palette(list(range(256)))\n        assert_image_equal(im, im_remapped)\n        assert im.palette.palette == im_remapped.palette.palette\n\n        # Test illegal image mode\n        with hopper() as im:\n            with pytest.raises(ValueError):\n                im.remap_palette(None)\n\n    def test_remap_palette_transparency(self) -> None:\n        im = Image.new(\"P\", (1, 2), (0, 0, 0))\n        im.putpixel((0, 1), (255, 0, 0))\n        im.info[\"transparency\"] = 0\n\n        im_remapped = im.remap_palette([1, 0])\n        assert im_remapped.info[\"transparency\"] == 1\n        assert len(im_remapped.getpalette()) == 6\n\n        # Test unused transparency\n        im.info[\"transparency\"] = 2\n\n        im_remapped = im.remap_palette([1, 0])\n        assert \"transparency\" not in im_remapped.info\n\n    def test__new(self) -> None:\n        im = hopper(\"RGB\")\n        im_p = hopper(\"P\")\n\n        blank_p = Image.new(\"P\", (10, 10))\n        blank_pa = Image.new(\"PA\", (10, 10))\n        blank_p.palette = None\n        blank_pa.palette = None\n\n        def _make_new(\n            base_image: Image.Image,\n            image: Image.Image,\n            palette_result: ImagePalette.ImagePalette | None = None,\n        ) -> None:\n            new_image = base_image._new(image.im)\n            assert new_image.mode == image.mode\n            assert new_image.size == image.size\n            assert new_image.info == base_image.info\n            if palette_result is not None:\n                assert new_image.palette.tobytes() == palette_result.tobytes()\n            else:\n                assert new_image.palette is None\n\n        _make_new(im, im_p, ImagePalette.ImagePalette(list(range(256)) * 3))\n        _make_new(im_p, im, None)\n        _make_new(im, blank_p, ImagePalette.ImagePalette())\n        _make_new(im, blank_pa, ImagePalette.ImagePalette())\n\n    @pytest.mark.parametrize(\n        \"mode, color\",\n        (\n            (\"RGB\", \"#DDEEFF\"),\n            (\"RGB\", (221, 238, 255)),\n            (\"RGBA\", (221, 238, 255, 255)),\n        ),\n    )\n    def test_p_from_rgb_rgba(self, mode: str, color: str | tuple[int, ...]) -> None:\n        im = Image.new(\"P\", (100, 100), color)\n        expected = Image.new(mode, (100, 100), color)\n        assert_image_equal(im.convert(mode), expected)\n\n    def test_no_resource_warning_on_save(self, tmp_path: Path) -> None:\n        # https://github.com/python-pillow/Pillow/issues/835\n        # Arrange\n        test_file = \"Tests/images/hopper.png\"\n        temp_file = str(tmp_path / \"temp.jpg\")\n\n        # Act/Assert\n        with Image.open(test_file) as im:\n            with warnings.catch_warnings():\n                im.save(temp_file)\n\n    def test_no_new_file_on_error(self, tmp_path: Path) -> None:\n        temp_file = str(tmp_path / \"temp.jpg\")\n\n        im = Image.new(\"RGB\", (0, 0))\n        with pytest.raises(ValueError):\n            im.save(temp_file)\n\n        assert not os.path.exists(temp_file)\n\n    def test_load_on_nonexclusive_multiframe(self) -> None:\n        with open(\"Tests/images/frozenpond.mpo\", \"rb\") as fp:\n\n            def act(fp: IO[bytes]) -> None:\n                im = Image.open(fp)\n                im.load()\n\n            act(fp)\n\n            with Image.open(fp) as im:\n                im.load()\n\n            assert not fp.closed\n\n    def test_empty_exif(self) -> None:\n        with Image.open(\"Tests/images/exif.png\") as im:\n            exif = im.getexif()\n        assert dict(exif)\n\n        # Test that exif data is cleared after another load\n        exif.load(None)\n        assert not dict(exif)\n\n        # Test loading just the EXIF header\n        exif.load(b\"Exif\\x00\\x00\")\n        assert not dict(exif)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_exif_jpeg(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/exif-72dpi-int.jpg\") as im:  # Little endian\n            exif = im.getexif()\n            assert 258 not in exif\n            assert 274 in exif\n            assert 282 in exif\n            assert exif[296] == 2\n            assert exif[11] == \"gThumb 3.0.1\"\n\n            out = str(tmp_path / \"temp.jpg\")\n            exif[258] = 8\n            del exif[274]\n            del exif[282]\n            exif[296] = 455\n            exif[11] = \"Pillow test\"\n            im.save(out, exif=exif)\n        with Image.open(out) as reloaded:\n            reloaded_exif = reloaded.getexif()\n            assert reloaded_exif[258] == 8\n            assert 274 not in reloaded_exif\n            assert 282 not in reloaded_exif\n            assert reloaded_exif[296] == 455\n            assert reloaded_exif[11] == \"Pillow test\"\n\n        with Image.open(\"Tests/images/no-dpi-in-exif.jpg\") as im:  # Big endian\n            exif = im.getexif()\n            assert 258 not in exif\n            assert 306 in exif\n            assert exif[274] == 1\n            assert exif[305] == \"Adobe Photoshop CC 2017 (Macintosh)\"\n\n            out = str(tmp_path / \"temp.jpg\")\n            exif[258] = 8\n            del exif[306]\n            exif[274] = 455\n            exif[305] = \"Pillow test\"\n            im.save(out, exif=exif)\n        with Image.open(out) as reloaded:\n            reloaded_exif = reloaded.getexif()\n            assert reloaded_exif[258] == 8\n            assert 306 not in reloaded_exif\n            assert reloaded_exif[274] == 455\n            assert reloaded_exif[305] == \"Pillow test\"\n\n    @skip_unless_feature(\"webp\")\n    @skip_unless_feature(\"webp_anim\")\n    def test_exif_webp(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/hopper.webp\") as im:\n            exif = im.getexif()\n            assert exif == {}\n\n            out = str(tmp_path / \"temp.webp\")\n            exif[258] = 8\n            exif[40963] = 455\n            exif[305] = \"Pillow test\"\n\n            def check_exif() -> None:\n                with Image.open(out) as reloaded:\n                    reloaded_exif = reloaded.getexif()\n                    assert reloaded_exif[258] == 8\n                    assert reloaded_exif[40963] == 455\n                    assert reloaded_exif[305] == \"Pillow test\"\n\n            im.save(out, exif=exif)\n            check_exif()\n            im.save(out, exif=exif, save_all=True)\n            check_exif()\n\n    def test_exif_png(self, tmp_path: Path) -> None:\n        with Image.open(\"Tests/images/exif.png\") as im:\n            exif = im.getexif()\n            assert exif == {274: 1}\n\n            out = str(tmp_path / \"temp.png\")\n            exif[258] = 8\n            del exif[274]\n            exif[40963] = 455\n            exif[305] = \"Pillow test\"\n            im.save(out, exif=exif)\n\n        with Image.open(out) as reloaded:\n            reloaded_exif = reloaded.getexif()\n            assert reloaded_exif == {258: 8, 40963: 455, 305: \"Pillow test\"}\n\n    def test_exif_interop(self) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            exif = im.getexif()\n            assert exif.get_ifd(0xA005) == {\n                1: \"R98\",\n                2: b\"0100\",\n                4097: 2272,\n                4098: 1704,\n            }\n\n            reloaded_exif = Image.Exif()\n            reloaded_exif.load(exif.tobytes())\n            assert reloaded_exif.get_ifd(0xA005) == exif.get_ifd(0xA005)\n\n    def test_exif_ifd1(self) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            exif = im.getexif()\n            assert exif.get_ifd(ExifTags.IFD.IFD1) == {\n                513: 2036,\n                514: 5448,\n                259: 6,\n                296: 2,\n                282: 180.0,\n                283: 180.0,\n            }\n\n    def test_exif_ifd(self) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            exif = im.getexif()\n        del exif.get_ifd(0x8769)[0xA005]\n\n        reloaded_exif = Image.Exif()\n        reloaded_exif.load(exif.tobytes())\n        assert reloaded_exif.get_ifd(0x8769) == exif.get_ifd(0x8769)\n\n    def test_exif_load_from_fp(self) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            data = im.info[\"exif\"]\n            if data.startswith(b\"Exif\\x00\\x00\"):\n                data = data[6:]\n            fp = io.BytesIO(data)\n\n            exif = Image.Exif()\n            exif.load_from_fp(fp)\n            assert exif == {\n                271: \"Canon\",\n                272: \"Canon PowerShot S40\",\n                274: 1,\n                282: 180.0,\n                283: 180.0,\n                296: 2,\n                306: \"2003:12:14 12:01:44\",\n                531: 1,\n                34665: 196,\n            }\n\n    def test_exif_hide_offsets(self) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            exif = im.getexif()\n\n        # Check offsets are present initially\n        assert 0x8769 in exif\n        for tag in (0xA005, 0x927C):\n            assert tag in exif.get_ifd(0x8769)\n        assert exif.get_ifd(0xA005)\n        loaded_exif = exif\n\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            new_exif = im.getexif()\n\n            for exif in (loaded_exif, new_exif):\n                exif.hide_offsets()\n\n                # Assert they are hidden afterwards,\n                # but that the IFDs are still available\n                assert 0x8769 not in exif\n                assert exif.get_ifd(0x8769)\n                for tag in (0xA005, 0x927C):\n                    assert tag not in exif.get_ifd(0x8769)\n                assert exif.get_ifd(0xA005)\n\n    def test_empty_xmp(self) -> None:\n        with Image.open(\"Tests/images/hopper.gif\") as im:\n            assert im.getxmp() == {}\n\n    @pytest.mark.parametrize(\"size\", ((1, 0), (0, 1), (0, 0)))\n    def test_zero_tobytes(self, size: tuple[int, int]) -> None:\n        im = Image.new(\"RGB\", size)\n        assert im.tobytes() == b\"\"\n\n    @pytest.mark.parametrize(\"size\", ((1, 0), (0, 1), (0, 0)))\n    def test_zero_frombytes(self, size: tuple[int, int]) -> None:\n        Image.frombytes(\"RGB\", size, b\"\")\n\n        im = Image.new(\"RGB\", size)\n        im.frombytes(b\"\")\n\n    def test_has_transparency_data(self) -> None:\n        for mode in (\"1\", \"L\", \"P\", \"RGB\"):\n            im = Image.new(mode, (1, 1))\n            assert not im.has_transparency_data\n\n        for mode in (\"LA\", \"La\", \"PA\", \"RGBA\", \"RGBa\"):\n            im = Image.new(mode, (1, 1))\n            assert im.has_transparency_data\n\n        # P mode with \"transparency\" info\n        with Image.open(\"Tests/images/first_frame_transparency.gif\") as im:\n            assert \"transparency\" in im.info\n            assert im.has_transparency_data\n\n        # RGB mode with \"transparency\" info\n        with Image.open(\"Tests/images/rgb_trns.png\") as im:\n            assert \"transparency\" in im.info\n            assert im.has_transparency_data\n\n        # P mode with RGBA palette\n        im = Image.new(\"RGBA\", (1, 1)).convert(\"P\")\n        assert im.mode == \"P\"\n        assert im.palette.mode == \"RGBA\"\n        assert im.has_transparency_data\n\n    def test_apply_transparency(self) -> None:\n        im = Image.new(\"P\", (1, 1))\n        im.putpalette((0, 0, 0, 1, 1, 1))\n        assert im.palette.colors == {(0, 0, 0): 0, (1, 1, 1): 1}\n\n        # Test that no transformation is applied without transparency\n        im.apply_transparency()\n        assert im.palette.colors == {(0, 0, 0): 0, (1, 1, 1): 1}\n\n        # Test that a transparency index is applied\n        im.info[\"transparency\"] = 0\n        im.apply_transparency()\n        assert \"transparency\" not in im.info\n        assert im.palette.colors == {(0, 0, 0, 0): 0, (1, 1, 1, 255): 1}\n\n        # Test that existing transparency is kept\n        im = Image.new(\"P\", (1, 1))\n        im.putpalette((0, 0, 0, 255, 1, 1, 1, 128), \"RGBA\")\n        im.info[\"transparency\"] = 0\n        im.apply_transparency()\n        assert im.palette.colors == {(0, 0, 0, 0): 0, (1, 1, 1, 128): 1}\n\n        # Test that transparency bytes are applied\n        with Image.open(\"Tests/images/pil123p.png\") as im:\n            assert isinstance(im.info[\"transparency\"], bytes)\n            assert im.palette.colors[(27, 35, 6)] == 24\n            im.apply_transparency()\n            assert im.palette.colors[(27, 35, 6, 214)] == 24\n\n    def test_constants(self) -> None:\n        for enum in (\n            Image.Transpose,\n            Image.Transform,\n            Image.Resampling,\n            Image.Dither,\n            Image.Palette,\n            Image.Quantize,\n        ):\n            for name in enum.__members__:\n                assert getattr(Image, name) == enum[name]\n\n    @pytest.mark.parametrize(\n        \"path\",\n        [\n            \"fli_overrun.bin\",\n            \"sgi_overrun.bin\",\n            \"sgi_overrun_expandrow.bin\",\n            \"sgi_overrun_expandrow2.bin\",\n            \"pcx_overrun.bin\",\n            \"pcx_overrun2.bin\",\n            \"ossfuzz-4836216264589312.pcx\",\n            \"01r_00.pcx\",\n        ],\n    )\n    def test_overrun(self, path: str) -> None:\n        \"\"\"For overrun completeness, test as:\n        valgrind pytest -qq Tests/test_image.py::TestImage::test_overrun | grep decode.c\n        \"\"\"\n        with Image.open(os.path.join(\"Tests/images\", path)) as im:\n            try:\n                im.load()\n                pytest.fail()\n            except OSError as e:\n                buffer_overrun = str(e) == \"buffer overrun when reading image file\"\n                truncated = \"image file is truncated\" in str(e)\n\n                assert buffer_overrun or truncated\n\n    def test_fli_overrun2(self) -> None:\n        with Image.open(\"Tests/images/fli_overrun2.bin\") as im:\n            try:\n                im.seek(1)\n                pytest.fail()\n            except OSError as e:\n                assert str(e) == \"buffer overrun when reading image file\"\n\n    def test_exit_fp(self) -> None:\n        with Image.new(\"L\", (1, 1)) as im:\n            pass\n        assert not hasattr(im, \"fp\")\n\n    def test_close_graceful(self, caplog: pytest.LogCaptureFixture) -> None:\n        with Image.open(\"Tests/images/hopper.jpg\") as im:\n            copy = im.copy()\n            with caplog.at_level(logging.DEBUG):\n                im.close()\n                copy.close()\n            assert len(caplog.records) == 0\n            assert im.fp is None\n\n\nclass TestImageBytes:\n    @pytest.mark.parametrize(\"mode\", Image.MODES + [\"BGR;15\", \"BGR;16\", \"BGR;24\"])\n    def test_roundtrip_bytes_constructor(self, mode: str) -> None:\n        im = hopper(mode)\n        source_bytes = im.tobytes()\n\n        if mode.startswith(\"BGR;\"):\n            with pytest.warns(DeprecationWarning):\n                reloaded = Image.frombytes(mode, im.size, source_bytes)\n        else:\n            reloaded = Image.frombytes(mode, im.size, source_bytes)\n        assert reloaded.tobytes() == source_bytes\n\n    @pytest.mark.parametrize(\"mode\", Image.MODES + [\"BGR;15\", \"BGR;16\", \"BGR;24\"])\n    def test_roundtrip_bytes_method(self, mode: str) -> None:\n        im = hopper(mode)\n        source_bytes = im.tobytes()\n\n        reloaded = helper_image_new(mode, im.size)\n        reloaded.frombytes(source_bytes)\n        assert reloaded.tobytes() == source_bytes\n\n    @pytest.mark.parametrize(\"mode\", Image.MODES + [\"BGR;15\", \"BGR;16\", \"BGR;24\"])\n    def test_getdata_putdata(self, mode: str) -> None:\n        if is_big_endian() and mode == \"BGR;15\":\n            pytest.xfail(\"Known failure of BGR;15 on big-endian\")\n        im = hopper(mode)\n        reloaded = helper_image_new(mode, im.size)\n        reloaded.putdata(im.getdata())\n        assert_image_equal(im, reloaded)\n\n\nclass MockEncoder(ImageFile.PyEncoder):\n    pass\n\n\nclass TestRegistry:\n    def test_encode_registry(self) -> None:\n        Image.register_encoder(\"MOCK\", MockEncoder)\n        assert \"MOCK\" in Image.ENCODERS\n\n        enc = Image._getencoder(\"RGB\", \"MOCK\", (\"args\",), extra=(\"extra\",))\n\n        assert isinstance(enc, MockEncoder)\n        assert enc.mode == \"RGB\"\n        assert enc.args == (\"args\", \"extra\")\n\n    def test_encode_registry_fail(self) -> None:\n        with pytest.raises(OSError):\n            Image._getencoder(\"RGB\", \"DoesNotExist\", (\"args\",), extra=(\"extra\",))\n", "Tests/test_image_crop.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal, hopper\n\n\n@pytest.mark.parametrize(\"mode\", (\"1\", \"P\", \"L\", \"RGB\", \"I\", \"F\"))\ndef test_crop(mode: str) -> None:\n    im = hopper(mode)\n    assert_image_equal(im.crop(), im)\n\n    cropped = im.crop((50, 50, 100, 100))\n    assert cropped.mode == mode\n    assert cropped.size == (50, 50)\n\n\ndef test_wide_crop() -> None:\n    def crop(bbox: tuple[int, int, int, int]) -> tuple[int, ...]:\n        i = im.crop(bbox)\n        h = i.histogram()\n        while h and not h[-1]:\n            del h[-1]\n        return tuple(h)\n\n    im = Image.new(\"L\", (100, 100), 1)\n\n    assert crop((0, 0, 100, 100)) == (0, 10000)\n    assert crop((25, 25, 75, 75)) == (0, 2500)\n\n    # sides\n    assert crop((-25, 0, 25, 50)) == (1250, 1250)\n    assert crop((0, -25, 50, 25)) == (1250, 1250)\n    assert crop((75, 0, 125, 50)) == (1250, 1250)\n    assert crop((0, 75, 50, 125)) == (1250, 1250)\n\n    assert crop((-25, 25, 125, 75)) == (2500, 5000)\n    assert crop((25, -25, 75, 125)) == (2500, 5000)\n\n    # corners\n    assert crop((-25, -25, 25, 25)) == (1875, 625)\n    assert crop((75, -25, 125, 25)) == (1875, 625)\n    assert crop((75, 75, 125, 125)) == (1875, 625)\n    assert crop((-25, 75, 25, 125)) == (1875, 625)\n\n\n@pytest.mark.parametrize(\"box\", ((8, 2, 2, 8), (2, 8, 8, 2), (8, 8, 2, 2)))\ndef test_negative_crop(box: tuple[int, int, int, int]) -> None:\n    im = Image.new(\"RGB\", (10, 10))\n\n    with pytest.raises(ValueError):\n        im.crop(box)\n\n\ndef test_crop_float() -> None:\n    # Check cropping floats are rounded to nearest integer\n    # https://github.com/python-pillow/Pillow/issues/1744\n\n    # Arrange\n    im = Image.new(\"RGB\", (10, 10))\n    assert im.size == (10, 10)\n\n    # Act\n    cropped = im.crop((0.9, 1.1, 4.2, 5.8))\n\n    # Assert\n    assert cropped.size == (3, 5)\n\n\ndef test_crop_crash() -> None:\n    # Image.crop crashes prepatch with an access violation\n    # apparently a use after free on Windows, see\n    # https://github.com/python-pillow/Pillow/issues/1077\n\n    test_img = \"Tests/images/bmp/g/pal8-0.bmp\"\n    extents = (1, 1, 10, 10)\n    # works prepatch\n    with Image.open(test_img) as img:\n        img2 = img.crop(extents)\n    img2.load()\n\n    # fail prepatch\n    with Image.open(test_img) as img:\n        img = img.crop(extents)\n    img.load()\n\n\ndef test_crop_zero() -> None:\n    im = Image.new(\"RGB\", (0, 0), \"white\")\n\n    cropped = im.crop((0, 0, 0, 0))\n    assert cropped.size == (0, 0)\n\n    cropped = im.crop((10, 10, 20, 20))\n    assert cropped.size == (10, 10)\n    assert cropped.getdata()[0] == (0, 0, 0)\n\n    im = Image.new(\"RGB\", (0, 0))\n\n    cropped = im.crop((10, 10, 20, 20))\n    assert cropped.size == (10, 10)\n    assert cropped.getdata()[2] == (0, 0, 0)\n", "Tests/test_image_fromqimage.py": "from __future__ import annotations\n\nimport warnings\n\nimport pytest\n\nfrom PIL import Image\n\nwith warnings.catch_warnings():\n    warnings.simplefilter(\"ignore\", category=DeprecationWarning)\n    from PIL import ImageQt\n\nfrom .helper import assert_image_equal, hopper\n\npytestmark = pytest.mark.skipif(\n    not ImageQt.qt_is_installed, reason=\"Qt bindings are not installed\"\n)\n\nims: list[Image.Image] = []\n\n\ndef setup_module() -> None:\n    ims.append(hopper())\n    ims.append(Image.open(\"Tests/images/transparent.png\"))\n    ims.append(Image.open(\"Tests/images/7x13.png\"))\n\n\ndef teardown_module() -> None:\n    for im in ims:\n        im.close()\n\n\ndef roundtrip(expected: Image.Image) -> None:\n    # PIL -> Qt\n    intermediate = expected.toqimage()\n    # Qt -> PIL\n    result = ImageQt.fromqimage(intermediate)\n\n    if intermediate.hasAlphaChannel():\n        assert_image_equal(result, expected.convert(\"RGBA\"))\n    else:\n        assert_image_equal(result, expected.convert(\"RGB\"))\n\n\ndef test_sanity_1() -> None:\n    for im in ims:\n        roundtrip(im.convert(\"1\"))\n\n\ndef test_sanity_rgb() -> None:\n    for im in ims:\n        roundtrip(im.convert(\"RGB\"))\n\n\ndef test_sanity_rgba() -> None:\n    for im in ims:\n        roundtrip(im.convert(\"RGBA\"))\n\n\ndef test_sanity_l() -> None:\n    for im in ims:\n        roundtrip(im.convert(\"L\"))\n\n\ndef test_sanity_p() -> None:\n    for im in ims:\n        roundtrip(im.convert(\"P\"))\n", "Tests/check_png_dos.py": "from __future__ import annotations\n\nimport zlib\nfrom io import BytesIO\n\nfrom PIL import Image, ImageFile, PngImagePlugin\n\nTEST_FILE = \"Tests/images/png_decompression_dos.png\"\n\n\ndef test_ignore_dos_text() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = True\n\n    try:\n        im = Image.open(TEST_FILE)\n        im.load()\n    finally:\n        ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n    assert isinstance(im, PngImagePlugin.PngImageFile)\n    for s in im.text.values():\n        assert len(s) < 1024 * 1024, \"Text chunk larger than 1M\"\n\n    for s in im.info.values():\n        assert len(s) < 1024 * 1024, \"Text chunk larger than 1M\"\n\n\ndef test_dos_text() -> None:\n    try:\n        im = Image.open(TEST_FILE)\n        im.load()\n    except ValueError as msg:\n        assert msg, \"Decompressed Data Too Large\"\n        return\n\n    assert isinstance(im, PngImagePlugin.PngImageFile)\n    for s in im.text.values():\n        assert len(s) < 1024 * 1024, \"Text chunk larger than 1M\"\n\n\ndef test_dos_total_memory() -> None:\n    im = Image.new(\"L\", (1, 1))\n    compressed_data = zlib.compress(b\"a\" * 1024 * 1023)\n\n    info = PngImagePlugin.PngInfo()\n\n    for x in range(64):\n        info.add_text(f\"t{x}\", compressed_data, zip=True)\n        info.add_itxt(f\"i{x}\", compressed_data, zip=True)\n\n    b = BytesIO()\n    im.save(b, \"PNG\", pnginfo=info)\n    b.seek(0)\n\n    try:\n        im2 = Image.open(b)\n    except ValueError as msg:\n        assert \"Too much memory\" in str(msg)\n        return\n\n    total_len = 0\n    assert isinstance(im2, PngImagePlugin.PngImageFile)\n    for txt in im2.text.values():\n        total_len += len(txt)\n    assert total_len < 64 * 1024 * 1024, \"Total text chunks greater than 64M\"\n", "Tests/check_j2k_dos.py": "# Tests potential DOS of Jpeg2kImagePlugin with 0 length block.\n# Run from anywhere that PIL is importable.\nfrom __future__ import annotations\n\nfrom io import BytesIO\n\nfrom PIL import Image\n\nwith Image.open(\n    BytesIO(b\"\\x00\\x00\\x00\\x0cjP\\x20\\x20\\x0d\\x0a\\x87\\x0a\\x00\\x00\\x00\\x00hang\")\n):\n    pass\n", "Tests/test_imageqt.py": "from __future__ import annotations\n\nimport warnings\n\nimport pytest\n\nfrom PIL import ImageQt\n\nfrom .helper import assert_image_similar, hopper\n\npytestmark = pytest.mark.skipif(\n    not ImageQt.qt_is_installed, reason=\"Qt bindings are not installed\"\n)\n\nif ImageQt.qt_is_installed:\n    from PIL.ImageQt import qRgba\n\n\ndef test_rgb() -> None:\n    # from https://doc.qt.io/archives/qt-4.8/qcolor.html\n    # typedef QRgb\n    # An ARGB quadruplet on the format #AARRGGBB,\n    # equivalent to an unsigned int.\n    if ImageQt.qt_version == \"6\":\n        from PyQt6.QtGui import qRgb\n    elif ImageQt.qt_version == \"side6\":\n        from PySide6.QtGui import qRgb\n\n    assert qRgb(0, 0, 0) == qRgba(0, 0, 0, 255)\n\n    def checkrgb(r: int, g: int, b: int) -> None:\n        val = ImageQt.rgb(r, g, b)\n        val = val % 2**24  # drop the alpha\n        assert val >> 16 == r\n        assert ((val >> 8) % 2**8) == g\n        assert val % 2**8 == b\n\n    checkrgb(0, 0, 0)\n    checkrgb(255, 0, 0)\n    checkrgb(0, 255, 0)\n    checkrgb(0, 0, 255)\n\n\n@pytest.mark.parametrize(\"mode\", (\"1\", \"RGB\", \"RGBA\", \"L\", \"P\", \"I;16\"))\ndef test_image(mode: str) -> None:\n    im = hopper(mode)\n    roundtripped_im = ImageQt.fromqimage(ImageQt.ImageQt(im))\n    if mode not in (\"RGB\", \"RGBA\"):\n        im = im.convert(\"RGB\")\n    assert_image_similar(roundtripped_im, im, 1)\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        ImageQt.ImageQt(\"Tests/images/hopper.gif\")\n", "Tests/test_file_gimpgradient.py": "from __future__ import annotations\n\nfrom PIL import GimpGradientFile, ImagePalette\n\n\ndef test_linear_pos_le_middle() -> None:\n    # Arrange\n    middle = 0.5\n    pos = 0.25\n\n    # Act\n    ret = GimpGradientFile.linear(middle, pos)\n\n    # Assert\n    assert ret == 0.25\n\n\ndef test_linear_pos_le_small_middle() -> None:\n    # Arrange\n    middle = 1e-11\n    pos = 1e-12\n\n    # Act\n    ret = GimpGradientFile.linear(middle, pos)\n\n    # Assert\n    assert ret == 0.0\n\n\ndef test_linear_pos_gt_middle() -> None:\n    # Arrange\n    middle = 0.5\n    pos = 0.75\n\n    # Act\n    ret = GimpGradientFile.linear(middle, pos)\n\n    # Assert\n    assert ret == 0.75\n\n\ndef test_linear_pos_gt_small_middle() -> None:\n    # Arrange\n    middle = 1 - 1e-11\n    pos = 1 - 1e-12\n\n    # Act\n    ret = GimpGradientFile.linear(middle, pos)\n\n    # Assert\n    assert ret == 1.0\n\n\ndef test_curved() -> None:\n    # Arrange\n    middle = 0.5\n    pos = 0.75\n\n    # Act\n    ret = GimpGradientFile.curved(middle, pos)\n\n    # Assert\n    assert ret == 0.75\n\n\ndef test_sine() -> None:\n    # Arrange\n    middle = 0.5\n    pos = 0.75\n\n    # Act\n    ret = GimpGradientFile.sine(middle, pos)\n\n    # Assert\n    assert ret == 0.8535533905932737\n\n\ndef test_sphere_increasing() -> None:\n    # Arrange\n    middle = 0.5\n    pos = 0.75\n\n    # Act\n    ret = GimpGradientFile.sphere_increasing(middle, pos)\n\n    # Assert\n    assert round(abs(ret - 0.9682458365518543), 7) == 0\n\n\ndef test_sphere_decreasing() -> None:\n    # Arrange\n    middle = 0.5\n    pos = 0.75\n\n    # Act\n    ret = GimpGradientFile.sphere_decreasing(middle, pos)\n\n    # Assert\n    assert ret == 0.3385621722338523\n\n\ndef test_load_via_imagepalette() -> None:\n    # Arrange\n    test_file = \"Tests/images/gimp_gradient.ggr\"\n\n    # Act\n    palette = ImagePalette.load(test_file)\n\n    # Assert\n    # load returns raw palette information\n    assert len(palette[0]) == 1024\n    assert palette[1] == \"RGBA\"\n\n\ndef test_load_1_3_via_imagepalette() -> None:\n    # Arrange\n    # GIMP 1.3 gradient files contain a name field\n    test_file = \"Tests/images/gimp_gradient_with_name.ggr\"\n\n    # Act\n    palette = ImagePalette.load(test_file)\n\n    # Assert\n    # load returns raw palette information\n    assert len(palette[0]) == 1024\n    assert palette[1] == \"RGBA\"\n", "Tests/test_image_getbands.py": "from __future__ import annotations\n\nfrom PIL import Image\n\n\ndef test_getbands() -> None:\n    assert Image.new(\"1\", (1, 1)).getbands() == (\"1\",)\n    assert Image.new(\"L\", (1, 1)).getbands() == (\"L\",)\n    assert Image.new(\"I\", (1, 1)).getbands() == (\"I\",)\n    assert Image.new(\"F\", (1, 1)).getbands() == (\"F\",)\n    assert Image.new(\"P\", (1, 1)).getbands() == (\"P\",)\n    assert Image.new(\"RGB\", (1, 1)).getbands() == (\"R\", \"G\", \"B\")\n    assert Image.new(\"RGBA\", (1, 1)).getbands() == (\"R\", \"G\", \"B\", \"A\")\n    assert Image.new(\"CMYK\", (1, 1)).getbands() == (\"C\", \"M\", \"Y\", \"K\")\n    assert Image.new(\"YCbCr\", (1, 1)).getbands() == (\"Y\", \"Cb\", \"Cr\")\n", "Tests/test_font_crash.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageDraw, ImageFont\n\nfrom .helper import skip_unless_feature\n\n\nclass TestFontCrash:\n    def _fuzz_font(self, font: ImageFont.FreeTypeFont) -> None:\n        # from fuzzers.fuzz_font\n        font.getbbox(\"ABC\")\n        font.getmask(\"test text\")\n        with Image.new(mode=\"RGBA\", size=(200, 200)) as im:\n            draw = ImageDraw.Draw(im)\n            draw.multiline_textbbox((10, 10), \"ABC\\nAaaa\", font, stroke_width=2)\n            draw.text((10, 10), \"Test Text\", font=font, fill=\"#000\")\n\n    @skip_unless_feature(\"freetype2\")\n    def test_segfault(self) -> None:\n        with pytest.raises(OSError):\n            font = ImageFont.truetype(\"Tests/fonts/fuzz_font-5203009437302784\")\n            self._fuzz_font(font)\n", "Tests/test_image_getprojection.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    im = hopper()\n\n    projection = im.getprojection()\n\n    assert len(projection) == 2\n    assert len(projection[0]) == im.size[0]\n    assert len(projection[1]) == im.size[1]\n\n    # 8-bit image\n    im = Image.new(\"L\", (10, 10))\n    assert im.getprojection()[0] == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert im.getprojection()[1] == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    im.paste(255, (2, 4, 8, 6))\n    assert im.getprojection()[0] == [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]\n    assert im.getprojection()[1] == [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]\n\n    # 32-bit image\n    im = Image.new(\"RGB\", (10, 10))\n    assert im.getprojection()[0] == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert im.getprojection()[1] == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    im.paste(255, (2, 4, 8, 6))\n    assert im.getprojection()[0] == [0, 0, 1, 1, 1, 1, 1, 1, 0, 0]\n    assert im.getprojection()[1] == [0, 0, 0, 0, 1, 1, 0, 0, 0, 0]\n", "Tests/helper.py": "\"\"\"\nHelper functions.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport os\nimport shutil\nimport subprocess\nimport sys\nimport sysconfig\nimport tempfile\nfrom functools import lru_cache\nfrom io import BytesIO\nfrom typing import Any, Callable, Sequence\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nfrom PIL import Image, ImageFile, ImageMath, features\n\nlogger = logging.getLogger(__name__)\n\nuploader = None\nif os.environ.get(\"SHOW_ERRORS\"):\n    uploader = \"show\"\nelif \"GITHUB_ACTIONS\" in os.environ:\n    uploader = \"github_actions\"\n\n\ndef upload(a: Image.Image, b: Image.Image) -> str | None:\n    if uploader == \"show\":\n        # local img.show for errors.\n        a.show()\n        b.show()\n    elif uploader == \"github_actions\":\n        dir_errors = os.path.join(os.path.dirname(__file__), \"errors\")\n        os.makedirs(dir_errors, exist_ok=True)\n        tmpdir = tempfile.mkdtemp(dir=dir_errors)\n        a.save(os.path.join(tmpdir, \"a.png\"))\n        b.save(os.path.join(tmpdir, \"b.png\"))\n        return tmpdir\n    return None\n\n\ndef convert_to_comparable(\n    a: Image.Image, b: Image.Image\n) -> tuple[Image.Image, Image.Image]:\n    new_a, new_b = a, b\n    if a.mode == \"P\":\n        new_a = Image.new(\"L\", a.size)\n        new_b = Image.new(\"L\", b.size)\n        new_a.putdata(a.getdata())\n        new_b.putdata(b.getdata())\n    elif a.mode == \"I;16\":\n        new_a = a.convert(\"I\")\n        new_b = b.convert(\"I\")\n    return new_a, new_b\n\n\ndef assert_deep_equal(\n    a: Sequence[Any], b: Sequence[Any], msg: str | None = None\n) -> None:\n    try:\n        assert len(a) == len(b), msg or f\"got length {len(a)}, expected {len(b)}\"\n    except Exception:\n        assert a == b, msg\n\n\ndef assert_image(\n    im: Image.Image, mode: str, size: tuple[int, int], msg: str | None = None\n) -> None:\n    if mode is not None:\n        assert im.mode == mode, (\n            msg or f\"got mode {repr(im.mode)}, expected {repr(mode)}\"\n        )\n\n    if size is not None:\n        assert im.size == size, (\n            msg or f\"got size {repr(im.size)}, expected {repr(size)}\"\n        )\n\n\ndef assert_image_equal(a: Image.Image, b: Image.Image, msg: str | None = None) -> None:\n    assert a.mode == b.mode, msg or f\"got mode {repr(a.mode)}, expected {repr(b.mode)}\"\n    assert a.size == b.size, msg or f\"got size {repr(a.size)}, expected {repr(b.size)}\"\n    if a.tobytes() != b.tobytes():\n        try:\n            url = upload(a, b)\n            if url:\n                logger.error(\"URL for test images: %s\", url)\n        except Exception:\n            pass\n\n        pytest.fail(msg or \"got different content\")\n\n\ndef assert_image_equal_tofile(\n    a: Image.Image, filename: str, msg: str | None = None, mode: str | None = None\n) -> None:\n    with Image.open(filename) as img:\n        if mode:\n            img = img.convert(mode)\n        assert_image_equal(a, img, msg)\n\n\ndef assert_image_similar(\n    a: Image.Image, b: Image.Image, epsilon: float, msg: str | None = None\n) -> None:\n    assert a.mode == b.mode, msg or f\"got mode {repr(a.mode)}, expected {repr(b.mode)}\"\n    assert a.size == b.size, msg or f\"got size {repr(a.size)}, expected {repr(b.size)}\"\n\n    a, b = convert_to_comparable(a, b)\n\n    diff = 0\n    for ach, bch in zip(a.split(), b.split()):\n        chdiff = ImageMath.lambda_eval(\n            lambda args: abs(args[\"a\"] - args[\"b\"]), a=ach, b=bch\n        ).convert(\"L\")\n        diff += sum(i * num for i, num in enumerate(chdiff.histogram()))\n\n    ave_diff = diff / (a.size[0] * a.size[1])\n    try:\n        assert epsilon >= ave_diff, (\n            (msg or \"\")\n            + f\" average pixel value difference {ave_diff:.4f} > epsilon {epsilon:.4f}\"\n        )\n    except Exception as e:\n        try:\n            url = upload(a, b)\n            if url:\n                logger.exception(\"URL for test images: %s\", url)\n        except Exception:\n            pass\n        raise e\n\n\ndef assert_image_similar_tofile(\n    a: Image.Image,\n    filename: str,\n    epsilon: float,\n    msg: str | None = None,\n    mode: str | None = None,\n) -> None:\n    with Image.open(filename) as img:\n        if mode:\n            img = img.convert(mode)\n        assert_image_similar(a, img, epsilon, msg)\n\n\ndef assert_all_same(items: Sequence[Any], msg: str | None = None) -> None:\n    assert items.count(items[0]) == len(items), msg\n\n\ndef assert_not_all_same(items: Sequence[Any], msg: str | None = None) -> None:\n    assert items.count(items[0]) != len(items), msg\n\n\ndef assert_tuple_approx_equal(\n    actuals: Sequence[int], targets: tuple[int, ...], threshold: int, msg: str\n) -> None:\n    \"\"\"Tests if actuals has values within threshold from targets\"\"\"\n    for i, target in enumerate(targets):\n        if not (target - threshold <= actuals[i] <= target + threshold):\n            pytest.fail(msg + \": \" + repr(actuals) + \" != \" + repr(targets))\n\n\ndef skip_unless_feature(feature: str) -> pytest.MarkDecorator:\n    reason = f\"{feature} not available\"\n    return pytest.mark.skipif(not features.check(feature), reason=reason)\n\n\ndef skip_unless_feature_version(\n    feature: str, required: str, reason: str | None = None\n) -> pytest.MarkDecorator:\n    version = features.version(feature)\n    if version is None:\n        return pytest.mark.skip(f\"{feature} not available\")\n    if reason is None:\n        reason = f\"{feature} is older than {required}\"\n    version_required = parse_version(required)\n    version_available = parse_version(version)\n    return pytest.mark.skipif(version_available < version_required, reason=reason)\n\n\ndef mark_if_feature_version(\n    mark: pytest.MarkDecorator,\n    feature: str,\n    version_blacklist: str,\n    reason: str | None = None,\n) -> pytest.MarkDecorator:\n    version = features.version(feature)\n    if version is None:\n        return pytest.mark.pil_noop_mark()\n    if reason is None:\n        reason = f\"{feature} is {version_blacklist}\"\n    version_required = parse_version(version_blacklist)\n    version_available = parse_version(version)\n    if (\n        version_available.major == version_required.major\n        and version_available.minor == version_required.minor\n    ):\n        return mark(reason=reason)\n    return pytest.mark.pil_noop_mark()\n\n\n@pytest.mark.skipif(sys.platform.startswith(\"win32\"), reason=\"Requires Unix or macOS\")\nclass PillowLeakTestCase:\n    # requires unix/macOS\n    iterations = 100  # count\n    mem_limit = 512  # k\n\n    def _get_mem_usage(self) -> float:\n        \"\"\"\n        Gets the RUSAGE memory usage, returns in K. Encapsulates the difference\n        between macOS and Linux rss reporting\n\n        :returns: memory usage in kilobytes\n        \"\"\"\n\n        from resource import RUSAGE_SELF, getrusage\n\n        mem = getrusage(RUSAGE_SELF).ru_maxrss\n        # man 2 getrusage:\n        #     ru_maxrss\n        # This is the maximum resident set size utilized\n        # in bytes on macOS, in kilobytes on Linux\n        return mem / 1024 if sys.platform == \"darwin\" else mem\n\n    def _test_leak(self, core: Callable[[], None]) -> None:\n        start_mem = self._get_mem_usage()\n        for cycle in range(self.iterations):\n            core()\n            mem = self._get_mem_usage() - start_mem\n            msg = f\"memory usage limit exceeded in iteration {cycle}\"\n            assert mem < self.mem_limit, msg\n\n\n# helpers\n\n\ndef fromstring(data: bytes) -> ImageFile.ImageFile:\n    return Image.open(BytesIO(data))\n\n\ndef tostring(im: Image.Image, string_format: str, **options: Any) -> bytes:\n    out = BytesIO()\n    im.save(out, string_format, **options)\n    return out.getvalue()\n\n\ndef hopper(mode: str | None = None) -> Image.Image:\n    # Use caching to reduce reading from disk, but return a copy\n    # so that the cached image isn't modified by the tests\n    # (for fast, isolated, repeatable tests).\n\n    if mode is None:\n        # Always return fresh not-yet-loaded version of image.\n        # Operations on not-yet-loaded images are a separate class of errors\n        # that we should catch.\n        return Image.open(\"Tests/images/hopper.ppm\")\n\n    return _cached_hopper(mode).copy()\n\n\n@lru_cache\ndef _cached_hopper(mode: str) -> Image.Image:\n    if mode == \"F\":\n        im = hopper(\"L\")\n    else:\n        im = hopper()\n    if mode.startswith(\"BGR;\"):\n        with pytest.warns(DeprecationWarning):\n            im = im.convert(mode)\n    else:\n        try:\n            im = im.convert(mode)\n        except ImportError:\n            if mode == \"LAB\":\n                im = Image.open(\"Tests/images/hopper.Lab.tif\")\n            else:\n                raise\n    return im\n\n\ndef djpeg_available() -> bool:\n    if shutil.which(\"djpeg\"):\n        try:\n            subprocess.check_call([\"djpeg\", \"-version\"])\n            return True\n        except subprocess.CalledProcessError:  # pragma: no cover\n            return False\n    return False\n\n\ndef cjpeg_available() -> bool:\n    if shutil.which(\"cjpeg\"):\n        try:\n            subprocess.check_call([\"cjpeg\", \"-version\"])\n            return True\n        except subprocess.CalledProcessError:  # pragma: no cover\n            return False\n    return False\n\n\ndef netpbm_available() -> bool:\n    return bool(shutil.which(\"ppmquant\") and shutil.which(\"ppmtogif\"))\n\n\ndef magick_command() -> list[str] | None:\n    if sys.platform == \"win32\":\n        magickhome = os.environ.get(\"MAGICK_HOME\")\n        if magickhome:\n            imagemagick = [os.path.join(magickhome, \"convert.exe\")]\n            graphicsmagick = [os.path.join(magickhome, \"gm.exe\"), \"convert\"]\n        else:\n            imagemagick = None\n            graphicsmagick = None\n    else:\n        imagemagick = [\"convert\"]\n        graphicsmagick = [\"gm\", \"convert\"]\n\n    if imagemagick and shutil.which(imagemagick[0]):\n        return imagemagick\n    if graphicsmagick and shutil.which(graphicsmagick[0]):\n        return graphicsmagick\n    return None\n\n\ndef on_appveyor() -> bool:\n    return \"APPVEYOR\" in os.environ\n\n\ndef on_github_actions() -> bool:\n    return \"GITHUB_ACTIONS\" in os.environ\n\n\ndef on_ci() -> bool:\n    # GitHub Actions and AppVeyor have \"CI\"\n    return \"CI\" in os.environ\n\n\ndef is_big_endian() -> bool:\n    return sys.byteorder == \"big\"\n\n\ndef is_ppc64le() -> bool:\n    import platform\n\n    return platform.machine() == \"ppc64le\"\n\n\ndef is_win32() -> bool:\n    return sys.platform.startswith(\"win32\")\n\n\ndef is_pypy() -> bool:\n    return hasattr(sys, \"pypy_translation_info\")\n\n\ndef is_mingw() -> bool:\n    return sysconfig.get_platform() == \"mingw\"\n\n\nclass CachedProperty:\n    def __init__(self, func: Callable[[Any], Any]) -> None:\n        self.func = func\n\n    def __get__(self, instance: Any, cls: type[Any] | None = None) -> Any:\n        result = instance.__dict__[self.func.__name__] = self.func(instance)\n        return result\n", "Tests/check_large_memory_numpy.py": "from __future__ import annotations\n\nimport sys\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\n# This test is not run automatically.\n#\n# It requires > 2gb memory for the >2 gigapixel image generated in the\n# second test.  Running this automatically would amount to a denial of\n# service on our testing infrastructure.  I expect this test to fail\n# on any 32-bit machine, as well as any smallish things (like\n# Raspberry Pis).\n\n\nnp = pytest.importorskip(\"numpy\", reason=\"NumPy not installed\")\n\nYDIM = 32769\nXDIM = 48000\n\n\npytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason=\"requires 64-bit system\")\n\n\ndef _write_png(tmp_path: Path, xdim: int, ydim: int) -> None:\n    dtype = np.uint8\n    a = np.zeros((xdim, ydim), dtype=dtype)\n    f = str(tmp_path / \"temp.png\")\n    im = Image.fromarray(a, \"L\")\n    im.save(f)\n\n\ndef test_large(tmp_path: Path) -> None:\n    \"\"\"succeeded prepatch\"\"\"\n    _write_png(tmp_path, XDIM, YDIM)\n\n\ndef test_2gpx(tmp_path: Path) -> None:\n    \"\"\"failed prepatch\"\"\"\n    _write_png(tmp_path, XDIM, XDIM)\n", "Tests/test_imagepalette.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImagePalette\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile\n\n\ndef test_sanity() -> None:\n    palette = ImagePalette.ImagePalette(\"RGB\", list(range(256)) * 3)\n    assert len(palette.colors) == 256\n\n\ndef test_reload() -> None:\n    with Image.open(\"Tests/images/hopper.gif\") as im:\n        original = im.copy()\n        im.palette.dirty = 1\n        assert_image_equal(im.convert(\"RGB\"), original.convert(\"RGB\"))\n\n\ndef test_getcolor() -> None:\n    palette = ImagePalette.ImagePalette()\n    assert len(palette.palette) == 0\n    assert len(palette.colors) == 0\n\n    test_map = {}\n    for i in range(256):\n        test_map[palette.getcolor((i, i, i))] = i\n    assert len(test_map) == 256\n\n    # Colors can be converted between RGB and RGBA\n    rgba_palette = ImagePalette.ImagePalette(\"RGBA\")\n    assert rgba_palette.getcolor((0, 0, 0)) == rgba_palette.getcolor((0, 0, 0, 255))\n\n    assert palette.getcolor((0, 0, 0)) == palette.getcolor((0, 0, 0, 255))\n\n    # An error is raised when the palette is full\n    with pytest.raises(ValueError):\n        palette.getcolor((1, 2, 3))\n    # But not if the image is not using one of the palette entries\n    palette.getcolor((1, 2, 3), image=Image.new(\"P\", (1, 1)))\n\n    # Test unknown color specifier\n    with pytest.raises(ValueError):\n        palette.getcolor(\"unknown\")  # type: ignore[arg-type]\n\n\ndef test_getcolor_rgba_color_rgb_palette() -> None:\n    palette = ImagePalette.ImagePalette(\"RGB\")\n\n    # Opaque RGBA colors are converted\n    assert palette.getcolor((0, 0, 0, 255)) == palette.getcolor((0, 0, 0))\n\n    with pytest.raises(ValueError):\n        palette.getcolor((0, 0, 0, 128))\n\n\n@pytest.mark.parametrize(\n    \"index, palette\",\n    [\n        # Test when the palette is not full\n        (0, ImagePalette.ImagePalette()),\n        # Test when the palette is full\n        (255, ImagePalette.ImagePalette(\"RGB\", list(range(256)) * 3)),\n    ],\n)\ndef test_getcolor_not_special(index: int, palette: ImagePalette.ImagePalette) -> None:\n    im = Image.new(\"P\", (1, 1))\n\n    # Do not use transparency index as a new color\n    im.info[\"transparency\"] = index\n    index1 = palette.getcolor((0, 0, 0), im)\n    assert index1 != index\n\n    # Do not use background index as a new color\n    im.info[\"background\"] = index1\n    index2 = palette.getcolor((0, 0, 1), im)\n    assert index2 not in (index, index1)\n\n\ndef test_file(tmp_path: Path) -> None:\n    palette = ImagePalette.ImagePalette(\"RGB\", list(range(256)) * 3)\n\n    f = str(tmp_path / \"temp.lut\")\n\n    palette.save(f)\n\n    p = ImagePalette.load(f)\n\n    # load returns raw palette information\n    assert len(p[0]) == 768\n    assert p[1] == \"RGB\"\n\n    p = ImagePalette.raw(p[1], p[0])\n    assert isinstance(p, ImagePalette.ImagePalette)\n    assert p.palette == palette.tobytes()\n\n\ndef test_make_linear_lut() -> None:\n    # Arrange\n    black = 0\n    white = 255\n\n    # Act\n    lut = ImagePalette.make_linear_lut(black, white)\n\n    # Assert\n    assert isinstance(lut, list)\n    assert len(lut) == 256\n    # Check values\n    for i in range(0, len(lut)):\n        assert lut[i] == i\n\n\ndef test_make_linear_lut_not_yet_implemented() -> None:\n    # Update after FIXME\n    # Arrange\n    black = 1\n    white = 255\n\n    # Act\n    with pytest.raises(NotImplementedError):\n        ImagePalette.make_linear_lut(black, white)\n\n\ndef test_make_gamma_lut() -> None:\n    # Arrange\n    exp = 5\n\n    # Act\n    lut = ImagePalette.make_gamma_lut(exp)\n\n    # Assert\n    assert isinstance(lut, list)\n    assert len(lut) == 256\n    # Check a few values\n    assert lut[0] == 0\n    assert lut[63] == 0\n    assert lut[127] == 8\n    assert lut[191] == 60\n    assert lut[255] == 255\n\n\ndef test_rawmode_valueerrors(tmp_path: Path) -> None:\n    # Arrange\n    palette = ImagePalette.raw(\"RGB\", list(range(256)) * 3)\n\n    # Act / Assert\n    with pytest.raises(ValueError):\n        palette.tobytes()\n    with pytest.raises(ValueError):\n        palette.getcolor((1, 2, 3))\n    f = str(tmp_path / \"temp.lut\")\n    with pytest.raises(ValueError):\n        palette.save(f)\n\n\ndef test_getdata() -> None:\n    # Arrange\n    data_in = list(range(256)) * 3\n    palette = ImagePalette.ImagePalette(\"RGB\", data_in)\n\n    # Act\n    mode, data_out = palette.getdata()\n\n    # Assert\n    assert mode == \"RGB\"\n\n\ndef test_rawmode_getdata() -> None:\n    # Arrange\n    data_in = list(range(256)) * 3\n    palette = ImagePalette.raw(\"RGB\", data_in)\n\n    # Act\n    rawmode, data_out = palette.getdata()\n\n    # Assert\n    assert rawmode == \"RGB\"\n    assert data_in == data_out\n\n\ndef test_2bit_palette(tmp_path: Path) -> None:\n    # issue #2258, 2 bit palettes are corrupted.\n    outfile = str(tmp_path / \"temp.png\")\n\n    rgb = b\"\\x00\" * 2 + b\"\\x01\" * 2 + b\"\\x02\" * 2\n    img = Image.frombytes(\"P\", (6, 1), rgb)\n    img.putpalette(b\"\\xFF\\x00\\x00\\x00\\xFF\\x00\\x00\\x00\\xFF\")  # RGB\n    img.save(outfile, format=\"PNG\")\n\n    assert_image_equal_tofile(img, outfile)\n\n\ndef test_invalid_palette() -> None:\n    with pytest.raises(OSError):\n        ImagePalette.load(\"Tests/images/hopper.jpg\")\n", "Tests/conftest.py": "from __future__ import annotations\n\nimport io\n\nimport pytest\n\n\ndef pytest_report_header(config: pytest.Config) -> str:\n    try:\n        from PIL import features\n\n        with io.StringIO() as out:\n            features.pilinfo(out=out, supported_formats=False)\n            return out.getvalue()\n    except Exception as e:\n        return f\"pytest_report_header failed: {e}\"\n\n\ndef pytest_configure(config: pytest.Config) -> None:\n    config.addinivalue_line(\n        \"markers\",\n        \"pil_noop_mark: A conditional mark where nothing special happens\",\n    )\n\n    # We're marking some tests to ignore valgrind errors and XFAIL them.\n    # Ensure that the mark is defined\n    # even in cases where pytest-valgrind isn't installed\n    try:\n        config.addinivalue_line(\n            \"markers\",\n            \"valgrind_known_error: Tests that have known issues with valgrind\",\n        )\n    except Exception:\n        # valgrind is already installed\n        pass\n", "Tests/test_file_mpo.py": "from __future__ import annotations\n\nimport warnings\nfrom io import BytesIO\nfrom typing import Any, cast\n\nimport pytest\n\nfrom PIL import Image, MpoImagePlugin\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    is_pypy,\n    skip_unless_feature,\n)\n\ntest_files = [\"Tests/images/sugarshack.mpo\", \"Tests/images/frozenpond.mpo\"]\n\npytestmark = skip_unless_feature(\"jpg\")\n\n\ndef roundtrip(im: Image.Image, **options: Any) -> MpoImagePlugin.MpoImageFile:\n    out = BytesIO()\n    im.save(out, \"MPO\", **options)\n    out.seek(0)\n    return cast(MpoImagePlugin.MpoImageFile, Image.open(out))\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_sanity(test_file: str) -> None:\n    with Image.open(test_file) as im:\n        im.load()\n        assert im.mode == \"RGB\"\n        assert im.size == (640, 480)\n        assert im.format == \"MPO\"\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    def open() -> None:\n        im = Image.open(test_files[0])\n        im.load()\n\n    with pytest.warns(ResourceWarning):\n        open()\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        im = Image.open(test_files[0])\n        im.load()\n        im.close()\n\n\ndef test_seek_after_close() -> None:\n    im = Image.open(test_files[0])\n    im.close()\n\n    with pytest.raises(ValueError):\n        im.seek(1)\n\n\ndef test_context_manager() -> None:\n    with warnings.catch_warnings():\n        with Image.open(test_files[0]) as im:\n            im.load()\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_app(test_file: str) -> None:\n    # Test APP/COM reader (@PIL135)\n    with Image.open(test_file) as im:\n        assert im.applist[0][0] == \"APP1\"\n        assert im.applist[1][0] == \"APP2\"\n        assert (\n            im.applist[1][1][:16] == b\"MPF\\x00MM\\x00*\\x00\\x00\\x00\\x08\\x00\\x03\\xb0\\x00\"\n        )\n        assert len(im.applist) == 2\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_exif(test_file: str) -> None:\n    with Image.open(test_file) as im_original:\n        im_reloaded = roundtrip(im_original, save_all=True, exif=im_original.getexif())\n\n    for im in (im_original, im_reloaded):\n        info = im._getexif()\n        assert info[272] == \"Nintendo 3DS\"\n        assert info[296] == 2\n        assert info[34665] == 188\n\n\ndef test_frame_size() -> None:\n    # This image has been hexedited to contain a different size\n    # in the SOF marker of the second frame\n    with Image.open(\"Tests/images/sugarshack_frame_size.mpo\") as im:\n        assert im.size == (640, 480)\n\n        im.seek(1)\n        assert im.size == (680, 480)\n\n        im.seek(0)\n        assert im.size == (640, 480)\n\n\ndef test_ignore_frame_size() -> None:\n    # Ignore the different size of the second frame\n    # since this is not a \"Large Thumbnail\" image\n    with Image.open(\"Tests/images/ignore_frame_size.mpo\") as im:\n        assert im.size == (64, 64)\n\n        im.seek(1)\n        assert (\n            im.mpinfo[0xB002][1][\"Attribute\"][\"MPType\"]\n            == \"Multi-Frame Image: (Disparity)\"\n        )\n        assert im.size == (64, 64)\n\n\ndef test_parallax() -> None:\n    # Nintendo\n    with Image.open(\"Tests/images/sugarshack.mpo\") as im:\n        exif = im.getexif()\n        assert exif.get_ifd(0x927C)[0x1101][\"Parallax\"] == -44.798187255859375\n\n    # Fujifilm\n    with Image.open(\"Tests/images/fujifilm.mpo\") as im:\n        im.seek(1)\n        exif = im.getexif()\n        assert exif.get_ifd(0x927C)[0xB211] == -3.125\n\n\ndef test_reload_exif_after_seek() -> None:\n    with Image.open(\"Tests/images/sugarshack.mpo\") as im:\n        exif = im.getexif()\n        del exif[296]\n\n        im.seek(1)\n        assert 296 in exif\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_mp(test_file: str) -> None:\n    with Image.open(test_file) as im:\n        mpinfo = im._getmp()\n        assert mpinfo[45056] == b\"0100\"\n        assert mpinfo[45057] == 2\n\n\ndef test_mp_offset() -> None:\n    # This image has been manually hexedited to have an IFD offset of 10\n    # in APP2 data, in contrast to normal 8\n    with Image.open(\"Tests/images/sugarshack_ifd_offset.mpo\") as im:\n        mpinfo = im._getmp()\n        assert mpinfo[45056] == b\"0100\"\n        assert mpinfo[45057] == 2\n\n\ndef test_mp_no_data() -> None:\n    # This image has been manually hexedited to have the second frame\n    # beyond the end of the file\n    with Image.open(\"Tests/images/sugarshack_no_data.mpo\") as im:\n        with pytest.raises(ValueError):\n            im.seek(1)\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_mp_attribute(test_file: str) -> None:\n    with Image.open(test_file) as im:\n        mpinfo = im._getmp()\n    for frame_number, mpentry in enumerate(mpinfo[0xB002]):\n        mpattr = mpentry[\"Attribute\"]\n        if frame_number:\n            assert not mpattr[\"RepresentativeImageFlag\"]\n        else:\n            assert mpattr[\"RepresentativeImageFlag\"]\n        assert not mpattr[\"DependentParentImageFlag\"]\n        assert not mpattr[\"DependentChildImageFlag\"]\n        assert mpattr[\"ImageDataFormat\"] == \"JPEG\"\n        assert mpattr[\"MPType\"] == \"Multi-Frame Image: (Disparity)\"\n        assert mpattr[\"Reserved\"] == 0\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_seek(test_file: str) -> None:\n    with Image.open(test_file) as im:\n        assert im.tell() == 0\n        # prior to first image raises an error, both blatant and borderline\n        with pytest.raises(EOFError):\n            im.seek(-1)\n        with pytest.raises(EOFError):\n            im.seek(-523)\n        # after the final image raises an error,\n        # both blatant and borderline\n        with pytest.raises(EOFError):\n            im.seek(2)\n        with pytest.raises(EOFError):\n            im.seek(523)\n        # bad calls shouldn't change the frame\n        assert im.tell() == 0\n        # this one will work\n        im.seek(1)\n        assert im.tell() == 1\n        # and this one, too\n        im.seek(0)\n        assert im.tell() == 0\n\n\ndef test_n_frames() -> None:\n    with Image.open(\"Tests/images/sugarshack.mpo\") as im:\n        assert im.n_frames == 2\n        assert im.is_animated\n\n\ndef test_eoferror() -> None:\n    with Image.open(\"Tests/images/sugarshack.mpo\") as im:\n        n_frames = im.n_frames\n\n        # Test seeking past the last frame\n        with pytest.raises(EOFError):\n            im.seek(n_frames)\n        assert im.tell() < n_frames\n\n        # Test that seeking to the last frame does not raise an error\n        im.seek(n_frames - 1)\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_image_grab(test_file: str) -> None:\n    with Image.open(test_file) as im:\n        assert im.tell() == 0\n        im0 = im.tobytes()\n        im.seek(1)\n        assert im.tell() == 1\n        im1 = im.tobytes()\n        im.seek(0)\n        assert im.tell() == 0\n        im02 = im.tobytes()\n        assert im0 == im02\n        assert im0 != im1\n\n\n@pytest.mark.parametrize(\"test_file\", test_files)\ndef test_save(test_file: str) -> None:\n    with Image.open(test_file) as im:\n        assert im.tell() == 0\n        jpg0 = roundtrip(im)\n        assert_image_similar(im, jpg0, 30)\n        im.seek(1)\n        assert im.tell() == 1\n        jpg1 = roundtrip(im)\n        assert_image_similar(im, jpg1, 30)\n\n\ndef test_save_all() -> None:\n    for test_file in test_files:\n        with Image.open(test_file) as im:\n            im_reloaded = roundtrip(im, save_all=True)\n\n            im.seek(0)\n            assert_image_similar(im, im_reloaded, 30)\n\n            im.seek(1)\n            im_reloaded.seek(1)\n            assert_image_similar(im, im_reloaded, 30)\n\n    im = Image.new(\"RGB\", (1, 1))\n    im2 = Image.new(\"RGB\", (1, 1), \"#f00\")\n    im_reloaded = roundtrip(im, save_all=True, append_images=[im2])\n\n    assert_image_equal(im, im_reloaded)\n    assert im_reloaded.mpinfo[45056] == b\"0100\"\n\n    im_reloaded.seek(1)\n    assert_image_similar(im2, im_reloaded, 1)\n\n    # Test that a single frame image will not be saved as an MPO\n    jpg = roundtrip(im, save_all=True)\n    assert \"mp\" not in jpg.info\n", "Tests/test_box_blur.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageFilter\n\nsample = Image.new(\"L\", (7, 5))\n# fmt: off\nsample.putdata(sum([\n    [210, 50,  20,  10,  220, 230, 80],\n    [190, 210, 20,  180, 170, 40,  110],\n    [120, 210, 250, 60,  220, 0,   220],\n    [220, 40,  230, 80,  130, 250, 40],\n    [250, 0,   80,  30,  60,  20,  110],\n], []))\n# fmt: on\n\n\ndef test_imageops_box_blur() -> None:\n    i = sample.filter(ImageFilter.BoxBlur(1))\n    assert i.mode == sample.mode\n    assert i.size == sample.size\n    assert isinstance(i, Image.Image)\n\n\ndef box_blur(image: Image.Image, radius: float = 1, n: int = 1) -> Image.Image:\n    return image._new(image.im.box_blur((radius, radius), n))\n\n\ndef assert_image(im: Image.Image, data: list[list[int]], delta: int = 0) -> None:\n    it = iter(im.getdata())\n    for data_row in data:\n        im_row = [next(it) for _ in range(im.size[0])]\n        if any(abs(data_v - im_v) > delta for data_v, im_v in zip(data_row, im_row)):\n            assert im_row == data_row\n    with pytest.raises(StopIteration):\n        next(it)\n\n\ndef assert_blur(\n    im: Image.Image,\n    radius: float,\n    data: list[list[int]],\n    passes: int = 1,\n    delta: int = 0,\n) -> None:\n    # check grayscale image\n    assert_image(box_blur(im, radius, passes), data, delta)\n    rgba = Image.merge(\"RGBA\", (im, im, im, im))\n    for band in box_blur(rgba, radius, passes).split():\n        assert_image(band, data, delta)\n\n\ndef test_color_modes() -> None:\n    with pytest.raises(ValueError):\n        box_blur(sample.convert(\"1\"))\n    with pytest.raises(ValueError):\n        box_blur(sample.convert(\"P\"))\n    box_blur(sample.convert(\"L\"))\n    box_blur(sample.convert(\"LA\"))\n    box_blur(sample.convert(\"LA\").convert(\"La\"))\n    with pytest.raises(ValueError):\n        box_blur(sample.convert(\"I\"))\n    with pytest.raises(ValueError):\n        box_blur(sample.convert(\"F\"))\n    box_blur(sample.convert(\"RGB\"))\n    box_blur(sample.convert(\"RGBA\"))\n    box_blur(sample.convert(\"RGBA\").convert(\"RGBa\"))\n    box_blur(sample.convert(\"CMYK\"))\n    with pytest.raises(ValueError):\n        box_blur(sample.convert(\"YCbCr\"))\n\n\ndef test_radius_0() -> None:\n    assert_blur(\n        sample,\n        0,\n        [\n            # fmt: off\n            [210, 50,  20,  10,  220, 230, 80],\n            [190, 210, 20,  180, 170, 40,  110],\n            [120, 210, 250, 60,  220, 0,   220],\n            [220, 40,  230, 80,  130, 250, 40],\n            [250, 0,   80,  30,  60,  20,  110],\n            # fmt: on\n        ],\n    )\n\n\ndef test_radius_0_02() -> None:\n    assert_blur(\n        sample,\n        0.02,\n        [\n            # fmt: off\n            [206, 55,  20,  17,  215, 223, 83],\n            [189, 203, 31,  171, 169, 46,  110],\n            [125, 206, 241, 69,  210, 13,  210],\n            [215, 49,  221, 82,  131, 235, 48],\n            [244, 7,   80,  32,  60,  27,  107],\n            # fmt: on\n        ],\n        delta=2,\n    )\n\n\ndef test_radius_0_05() -> None:\n    assert_blur(\n        sample,\n        0.05,\n        [\n            # fmt: off\n            [202, 62,  22,  27,  209, 215, 88],\n            [188, 194, 44,  161, 168, 56,  111],\n            [131, 201, 229, 81,  198, 31,  198],\n            [209, 62,  209, 86,  133, 216, 59],\n            [237, 17,  80,  36,  60,  35,  103],\n            # fmt: on\n        ],\n        delta=2,\n    )\n\n\ndef test_radius_0_1() -> None:\n    assert_blur(\n        sample,\n        0.1,\n        [\n            # fmt: off\n            [196, 72,  24,  40,  200, 203, 93],\n            [187, 183, 62,  148, 166, 68,  111],\n            [139, 193, 213, 96,  182, 54,  182],\n            [201, 78,  193, 91,  133, 191, 73],\n            [227, 31,  80,  42,  61,  47,  99],\n            # fmt: on\n        ],\n        delta=1,\n    )\n\n\ndef test_radius_0_5() -> None:\n    assert_blur(\n        sample,\n        0.5,\n        [\n            # fmt: off\n            [176, 101, 46,  83,  163, 165, 111],\n            [176, 149, 108, 122, 144, 120, 117],\n            [164, 171, 159, 141, 134, 119, 129],\n            [170, 136, 133, 114, 116, 124, 109],\n            [184, 95,  72,  70,  69,  81,  89],\n            # fmt: on\n        ],\n        delta=1,\n    )\n\n\ndef test_radius_1() -> None:\n    assert_blur(\n        sample,\n        1,\n        [\n            # fmt: off\n            [170, 109, 63,  97,  146, 153, 116],\n            [168, 142, 112, 128, 126, 143, 121],\n            [169, 166, 142, 149, 126, 131, 114],\n            [159, 156, 109, 127, 94,  117, 112],\n            [164, 128, 63,  87,  76,  89,  90],\n            # fmt: on\n        ],\n        delta=1,\n    )\n\n\ndef test_radius_1_5() -> None:\n    assert_blur(\n        sample,\n        1.5,\n        [\n            # fmt: off\n            [155, 120, 105, 112, 124, 137, 130],\n            [160, 136, 124, 125, 127, 134, 130],\n            [166, 147, 130, 125, 120, 121, 119],\n            [168, 145, 119, 109, 103, 105, 110],\n            [168, 134, 96,  85,  85,  89,  97],\n            # fmt: on\n        ],\n        delta=1,\n    )\n\n\ndef test_radius_bigger_then_half() -> None:\n    assert_blur(\n        sample,\n        3,\n        [\n            # fmt: off\n            [144, 145, 142, 128, 114, 115, 117],\n            [148, 145, 137, 122, 109, 111, 112],\n            [152, 145, 131, 117, 103, 107, 108],\n            [156, 144, 126, 111, 97,  102, 103],\n            [160, 144, 121, 106, 92,  98,  99],\n            # fmt: on\n        ],\n        delta=1,\n    )\n\n\ndef test_radius_bigger_then_width() -> None:\n    assert_blur(\n        sample,\n        10,\n        [\n            [158, 153, 147, 141, 135, 129, 123],\n            [159, 153, 147, 141, 136, 130, 124],\n            [159, 154, 148, 142, 136, 130, 124],\n            [160, 154, 148, 142, 137, 131, 125],\n            [160, 155, 149, 143, 137, 131, 125],\n        ],\n        delta=0,\n    )\n\n\ndef test_extreme_large_radius() -> None:\n    assert_blur(\n        sample,\n        600,\n        [\n            [162, 162, 162, 162, 162, 162, 162],\n            [162, 162, 162, 162, 162, 162, 162],\n            [162, 162, 162, 162, 162, 162, 162],\n            [162, 162, 162, 162, 162, 162, 162],\n            [162, 162, 162, 162, 162, 162, 162],\n        ],\n        delta=1,\n    )\n\n\ndef test_two_passes() -> None:\n    assert_blur(\n        sample,\n        1,\n        [\n            # fmt: off\n            [153, 123, 102, 109, 132, 135, 129],\n            [159, 138, 123, 121, 133, 131, 126],\n            [162, 147, 136, 124, 127, 121, 121],\n            [159, 140, 125, 108, 111, 106, 108],\n            [154, 126, 105, 87,  94,  93,  97],\n            # fmt: on\n        ],\n        passes=2,\n        delta=1,\n    )\n\n\ndef test_three_passes() -> None:\n    assert_blur(\n        sample,\n        1,\n        [\n            # fmt: off\n            [146, 131, 116, 118, 126, 131, 130],\n            [151, 138, 125, 123, 126, 128, 127],\n            [154, 143, 129, 123, 120, 120, 119],\n            [152, 139, 122, 113, 108, 108, 108],\n            [148, 132, 112, 102, 97,  99,  100],\n            # fmt: on\n        ],\n        passes=3,\n        delta=1,\n    )\n", "Tests/test_file_pcx.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImageFile, PcxImagePlugin\n\nfrom .helper import assert_image_equal, hopper\n\n\ndef _roundtrip(tmp_path: Path, im: Image.Image) -> None:\n    f = str(tmp_path / \"temp.pcx\")\n    im.save(f)\n    with Image.open(f) as im2:\n        assert im2.mode == im.mode\n        assert im2.size == im.size\n        assert im2.format == \"PCX\"\n        assert im2.get_format_mimetype() == \"image/x-pcx\"\n        assert_image_equal(im2, im)\n\n\ndef test_sanity(tmp_path: Path) -> None:\n    for mode in (\"1\", \"L\", \"P\", \"RGB\"):\n        _roundtrip(tmp_path, hopper(mode))\n\n    # Test a palette with less than 256 colors\n    im = Image.new(\"P\", (1, 1))\n    im.putpalette((255, 0, 0))\n    _roundtrip(tmp_path, im)\n\n    # Test an unsupported mode\n    f = str(tmp_path / \"temp.pcx\")\n    im = hopper(\"RGBA\")\n    with pytest.raises(ValueError):\n        im.save(f)\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        PcxImagePlugin.PcxImageFile(invalid_file)\n\n\n@pytest.mark.parametrize(\"mode\", (\"1\", \"L\", \"P\", \"RGB\"))\ndef test_odd(tmp_path: Path, mode: str) -> None:\n    # See issue #523, odd sized images should have a stride that's even.\n    # Not that ImageMagick or GIMP write PCX that way.\n    # We were not handling properly.\n    # larger, odd sized images are better here to ensure that\n    # we handle interrupted scan lines properly.\n    _roundtrip(tmp_path, hopper(mode).resize((511, 511)))\n\n\ndef test_odd_read() -> None:\n    # Reading an image with an odd stride, making it malformed\n    with Image.open(\"Tests/images/odd_stride.pcx\") as im:\n        im.load()\n\n        assert im.size == (371, 150)\n\n\ndef test_pil184() -> None:\n    # Check reading of files where xmin/xmax is not zero.\n\n    test_file = \"Tests/images/pil184.pcx\"\n    with Image.open(test_file) as im:\n        assert im.size == (447, 144)\n        assert im.tile[0][1] == (0, 0, 447, 144)\n\n        # Make sure all pixels are either 0 or 255.\n        assert im.histogram()[0] + im.histogram()[255] == 447 * 144\n\n\ndef test_1px_width(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (1, 256))\n    px = im.load()\n    for y in range(256):\n        px[0, y] = y\n    _roundtrip(tmp_path, im)\n\n\ndef test_large_count(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (256, 1))\n    px = im.load()\n    for x in range(256):\n        px[x, 0] = x // 67 * 67\n    _roundtrip(tmp_path, im)\n\n\ndef _test_buffer_overflow(tmp_path: Path, im: Image.Image, size: int = 1024) -> None:\n    _last = ImageFile.MAXBLOCK\n    ImageFile.MAXBLOCK = size\n    try:\n        _roundtrip(tmp_path, im)\n    finally:\n        ImageFile.MAXBLOCK = _last\n\n\ndef test_break_in_count_overflow(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (256, 5))\n    px = im.load()\n    for y in range(4):\n        for x in range(256):\n            px[x, y] = x % 128\n    _test_buffer_overflow(tmp_path, im)\n\n\ndef test_break_one_in_loop(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (256, 5))\n    px = im.load()\n    for y in range(5):\n        for x in range(256):\n            px[x, y] = x % 128\n    _test_buffer_overflow(tmp_path, im)\n\n\ndef test_break_many_in_loop(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (256, 5))\n    px = im.load()\n    for y in range(4):\n        for x in range(256):\n            px[x, y] = x % 128\n    for x in range(8):\n        px[x, 4] = 16\n    _test_buffer_overflow(tmp_path, im)\n\n\ndef test_break_one_at_end(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (256, 5))\n    px = im.load()\n    for y in range(5):\n        for x in range(256):\n            px[x, y] = x % 128\n    px[0, 3] = 128 + 64\n    _test_buffer_overflow(tmp_path, im)\n\n\ndef test_break_many_at_end(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (256, 5))\n    px = im.load()\n    for y in range(5):\n        for x in range(256):\n            px[x, y] = x % 128\n    for x in range(4):\n        px[x * 2, 3] = 128 + 64\n        px[x + 256 - 4, 3] = 0\n    _test_buffer_overflow(tmp_path, im)\n\n\ndef test_break_padding(tmp_path: Path) -> None:\n    im = Image.new(\"L\", (257, 5))\n    px = im.load()\n    for y in range(5):\n        for x in range(257):\n            px[x, y] = x % 128\n    for x in range(5):\n        px[x, 3] = 0\n    _test_buffer_overflow(tmp_path, im)\n", "Tests/test_image_putdata.py": "from __future__ import annotations\n\nimport sys\nfrom array import array\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal, hopper\n\n\ndef test_sanity() -> None:\n    im1 = hopper()\n\n    data = list(im1.getdata())\n\n    im2 = Image.new(im1.mode, im1.size, 0)\n    im2.putdata(data)\n\n    assert_image_equal(im1, im2)\n\n    # readonly\n    im2 = Image.new(im1.mode, im2.size, 0)\n    im2.readonly = 1\n    im2.putdata(data)\n\n    assert not im2.readonly\n    assert_image_equal(im1, im2)\n\n\ndef test_long_integers() -> None:\n    # see bug-200802-systemerror\n    def put(value: int) -> tuple[int, int, int, int]:\n        im = Image.new(\"RGBA\", (1, 1))\n        im.putdata([value])\n        return im.getpixel((0, 0))\n\n    assert put(0xFFFFFFFF) == (255, 255, 255, 255)\n    assert put(0xFFFFFFFF) == (255, 255, 255, 255)\n    assert put(-1) == (255, 255, 255, 255)\n    assert put(-1) == (255, 255, 255, 255)\n    if sys.maxsize > 2**32:\n        assert put(sys.maxsize) == (255, 255, 255, 255)\n    else:\n        assert put(sys.maxsize) == (255, 255, 255, 127)\n\n\ndef test_pypy_performance() -> None:\n    im = Image.new(\"L\", (256, 256))\n    im.putdata(list(range(256)) * 256)\n\n\ndef test_mode_with_L_with_float() -> None:\n    im = Image.new(\"L\", (1, 1), 0)\n    im.putdata([2.0])\n    assert im.getpixel((0, 0)) == 2\n\n\n@pytest.mark.parametrize(\"mode\", (\"I\", \"I;16\", \"I;16L\", \"I;16B\"))\ndef test_mode_i(mode: str) -> None:\n    src = hopper(\"L\")\n    data = list(src.getdata())\n    im = Image.new(mode, src.size, 0)\n    im.putdata(data, 2, 256)\n\n    target = [2 * elt + 256 for elt in data]\n    assert list(im.getdata()) == target\n\n\ndef test_mode_F() -> None:\n    src = hopper(\"L\")\n    data = list(src.getdata())\n    im = Image.new(\"F\", src.size, 0)\n    im.putdata(data, 2.0, 256.0)\n\n    target = [2.0 * float(elt) + 256.0 for elt in data]\n    assert list(im.getdata()) == target\n\n\n@pytest.mark.parametrize(\"mode\", (\"BGR;15\", \"BGR;16\", \"BGR;24\"))\ndef test_mode_BGR(mode: str) -> None:\n    data = [(16, 32, 49), (32, 32, 98)]\n    with pytest.warns(DeprecationWarning):\n        im = Image.new(mode, (1, 2))\n    im.putdata(data)\n\n    assert list(im.getdata()) == data\n\n\ndef test_array_B() -> None:\n    # shouldn't segfault\n    # see https://github.com/python-pillow/Pillow/issues/1008\n\n    arr = array(\"B\", [0]) * 15000\n    im = Image.new(\"L\", (150, 100))\n    im.putdata(arr)\n\n    assert len(im.getdata()) == len(arr)\n\n\ndef test_array_F() -> None:\n    # shouldn't segfault\n    # see https://github.com/python-pillow/Pillow/issues/1008\n\n    im = Image.new(\"F\", (150, 100))\n    arr = array(\"f\", [0.0]) * 15000\n    im.putdata(arr)\n\n    assert len(im.getdata()) == len(arr)\n\n\ndef test_not_flattened() -> None:\n    im = Image.new(\"L\", (1, 1))\n    with pytest.raises(TypeError):\n        im.putdata([[0]])\n    with pytest.raises(TypeError):\n        im.putdata([[0]], 2)\n\n    with pytest.raises(TypeError):\n        im = Image.new(\"I\", (1, 1))\n        im.putdata([[0]])\n    with pytest.raises(TypeError):\n        im = Image.new(\"F\", (1, 1))\n        im.putdata([[0]])\n", "Tests/test_fontfile.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import FontFile\n\n\ndef test_save(tmp_path: Path) -> None:\n    tempname = str(tmp_path / \"temp.pil\")\n\n    font = FontFile.FontFile()\n    with pytest.raises(ValueError):\n        font.save(tempname)\n", "Tests/test_qt_image_toqimage.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import ImageQt\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, hopper\n\npytestmark = pytest.mark.skipif(\n    not ImageQt.qt_is_installed, reason=\"Qt bindings are not installed\"\n)\n\nif ImageQt.qt_is_installed:\n    from PIL.ImageQt import QImage\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"RGBA\", \"L\", \"P\", \"1\"))\ndef test_sanity(mode: str, tmp_path: Path) -> None:\n    src = hopper(mode)\n    data = ImageQt.toqimage(src)\n\n    assert isinstance(data, QImage)\n    assert not data.isNull()\n\n    # reload directly from the qimage\n    rt = ImageQt.fromqimage(data)\n    if mode in (\"L\", \"P\", \"1\"):\n        assert_image_equal(rt, src.convert(\"RGB\"))\n    else:\n        assert_image_equal(rt, src)\n\n    if mode == \"1\":\n        # BW appears to not save correctly on Qt\n        # kicks out errors on console:\n        #     libpng warning: Invalid color type/bit depth combination\n        #                     in IHDR\n        #     libpng error: Invalid IHDR data\n        return\n\n    # Test saving the file\n    tempfile = str(tmp_path / f\"temp_{mode}.png\")\n    data.save(tempfile)\n\n    # Check that it actually worked.\n    assert_image_equal_tofile(src, tempfile)\n", "Tests/test_uploader.py": "from __future__ import annotations\n\nfrom .helper import assert_image_equal, assert_image_similar, hopper\n\n\ndef check_upload_equal() -> None:\n    result = hopper(\"P\").convert(\"RGB\")\n    target = hopper(\"RGB\")\n    assert_image_equal(result, target)\n\n\ndef check_upload_similar() -> None:\n    result = hopper(\"P\").convert(\"RGB\")\n    target = hopper(\"RGB\")\n    assert_image_similar(result, target, 0)\n", "Tests/test_image_entropy.py": "from __future__ import annotations\n\nfrom .helper import hopper\n\n\ndef test_entropy() -> None:\n    def entropy(mode: str) -> float:\n        return hopper(mode).entropy()\n\n    assert round(abs(entropy(\"1\") - 0.9138803254693582), 7) == 0\n    assert round(abs(entropy(\"L\") - 7.063008716585465), 7) == 0\n    assert round(abs(entropy(\"I\") - 7.063008716585465), 7) == 0\n    assert round(abs(entropy(\"F\") - 7.063008716585465), 7) == 0\n    assert round(abs(entropy(\"P\") - 5.082506854662517), 7) == 0\n    assert round(abs(entropy(\"RGB\") - 8.821286587714319), 7) == 0\n    assert round(abs(entropy(\"RGBA\") - 7.42724306524488), 7) == 0\n    assert round(abs(entropy(\"CMYK\") - 7.4272430652448795), 7) == 0\n    assert round(abs(entropy(\"YCbCr\") - 7.698360534903628), 7) == 0\n", "Tests/test_file_tga.py": "from __future__ import annotations\n\nimport os\nfrom glob import glob\nfrom itertools import product\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, UnidentifiedImageError\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, hopper\n\n_TGA_DIR = os.path.join(\"Tests\", \"images\", \"tga\")\n_TGA_DIR_COMMON = os.path.join(_TGA_DIR, \"common\")\n\n\n_MODES = (\"L\", \"LA\", \"P\", \"RGB\", \"RGBA\")\n_ORIGINS = (\"tl\", \"bl\")\n\n_ORIGIN_TO_ORIENTATION = {\"tl\": 1, \"bl\": -1}\n\n\n@pytest.mark.parametrize(\"mode\", _MODES)\ndef test_sanity(mode: str, tmp_path: Path) -> None:\n    def roundtrip(original_im: Image.Image) -> None:\n        out = str(tmp_path / \"temp.tga\")\n\n        original_im.save(out, rle=rle)\n        with Image.open(out) as saved_im:\n            if rle:\n                assert saved_im.info[\"compression\"] == original_im.info[\"compression\"]\n            assert saved_im.info[\"orientation\"] == original_im.info[\"orientation\"]\n            if mode == \"P\":\n                assert saved_im.getpalette() == original_im.getpalette()\n\n            assert_image_equal(saved_im, original_im)\n\n    png_paths = glob(os.path.join(_TGA_DIR_COMMON, f\"*x*_{mode.lower()}.png\"))\n\n    for png_path in png_paths:\n        with Image.open(png_path) as reference_im:\n            assert reference_im.mode == mode\n\n            path_no_ext = os.path.splitext(png_path)[0]\n            for origin, rle in product(_ORIGINS, (True, False)):\n                tga_path = \"{}_{}_{}.tga\".format(\n                    path_no_ext, origin, \"rle\" if rle else \"raw\"\n                )\n\n                with Image.open(tga_path) as original_im:\n                    assert original_im.format == \"TGA\"\n                    assert original_im.get_format_mimetype() == \"image/x-tga\"\n                    if rle:\n                        assert original_im.info[\"compression\"] == \"tga_rle\"\n                    assert (\n                        original_im.info[\"orientation\"]\n                        == _ORIGIN_TO_ORIENTATION[origin]\n                    )\n                    if mode == \"P\":\n                        assert original_im.getpalette() == reference_im.getpalette()\n\n                    assert_image_equal(original_im, reference_im)\n\n                    roundtrip(original_im)\n\n\ndef test_palette_depth_8(tmp_path: Path) -> None:\n    with pytest.raises(UnidentifiedImageError):\n        Image.open(\"Tests/images/p_8.tga\")\n\n\ndef test_palette_depth_16(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/p_16.tga\") as im:\n        assert_image_equal_tofile(im.convert(\"RGB\"), \"Tests/images/p_16.png\")\n\n        out = str(tmp_path / \"temp.png\")\n        im.save(out)\n        with Image.open(out) as reloaded:\n            assert_image_equal_tofile(reloaded.convert(\"RGB\"), \"Tests/images/p_16.png\")\n\n\ndef test_id_field() -> None:\n    # tga file with id field\n    test_file = \"Tests/images/tga_id_field.tga\"\n\n    # Act\n    with Image.open(test_file) as im:\n        # Assert\n        assert im.size == (100, 100)\n\n\ndef test_id_field_rle() -> None:\n    # tga file with id field\n    test_file = \"Tests/images/rgb32rle.tga\"\n\n    # Act\n    with Image.open(test_file) as im:\n        # Assert\n        assert im.size == (199, 199)\n\n\ndef test_cross_scan_line() -> None:\n    with Image.open(\"Tests/images/cross_scan_line.tga\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/cross_scan_line.png\")\n\n    with Image.open(\"Tests/images/cross_scan_line_truncated.tga\") as im:\n        with pytest.raises(OSError):\n            im.load()\n\n\ndef test_save(tmp_path: Path) -> None:\n    test_file = \"Tests/images/tga_id_field.tga\"\n    with Image.open(test_file) as im:\n        out = str(tmp_path / \"temp.tga\")\n\n        # Save\n        im.save(out)\n        with Image.open(out) as test_im:\n            assert test_im.size == (100, 100)\n            assert test_im.info[\"id_section\"] == im.info[\"id_section\"]\n\n        # RGBA save\n        im.convert(\"RGBA\").save(out)\n    with Image.open(out) as test_im:\n        assert test_im.size == (100, 100)\n\n\ndef test_small_palette(tmp_path: Path) -> None:\n    im = Image.new(\"P\", (1, 1))\n    colors = [0, 0, 0]\n    im.putpalette(colors)\n\n    out = str(tmp_path / \"temp.tga\")\n    im.save(out)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.getpalette() == colors\n\n\ndef test_missing_palette() -> None:\n    with Image.open(\"Tests/images/dilation4.lut\") as im:\n        assert im.mode == \"L\"\n\n\ndef test_save_wrong_mode(tmp_path: Path) -> None:\n    im = hopper(\"PA\")\n    out = str(tmp_path / \"temp.tga\")\n\n    with pytest.raises(OSError):\n        im.save(out)\n\n\ndef test_save_mapdepth() -> None:\n    # This image has been manually hexedited from 200x32_p_bl_raw.tga\n    # to include an origin\n    test_file = \"Tests/images/200x32_p_bl_raw_origin.tga\"\n    with Image.open(test_file) as im:\n        assert_image_equal_tofile(im, \"Tests/images/tga/common/200x32_p.png\")\n\n\ndef test_save_id_section(tmp_path: Path) -> None:\n    test_file = \"Tests/images/rgb32rle.tga\"\n    with Image.open(test_file) as im:\n        out = str(tmp_path / \"temp.tga\")\n\n        # Check there is no id section\n        im.save(out)\n    with Image.open(out) as test_im:\n        assert \"id_section\" not in test_im.info\n\n    # Save with custom id section\n    im.save(out, id_section=b\"Test content\")\n    with Image.open(out) as test_im:\n        assert test_im.info[\"id_section\"] == b\"Test content\"\n\n    # Save with custom id section greater than 255 characters\n    id_section = b\"Test content\" * 25\n    with pytest.warns(UserWarning):\n        im.save(out, id_section=id_section)\n\n    with Image.open(out) as test_im:\n        assert test_im.info[\"id_section\"] == id_section[:255]\n\n    test_file = \"Tests/images/tga_id_field.tga\"\n    with Image.open(test_file) as im:\n        # Save with no id section\n        im.save(out, id_section=\"\")\n    with Image.open(out) as test_im:\n        assert \"id_section\" not in test_im.info\n\n\ndef test_save_orientation(tmp_path: Path) -> None:\n    test_file = \"Tests/images/rgb32rle.tga\"\n    out = str(tmp_path / \"temp.tga\")\n    with Image.open(test_file) as im:\n        assert im.info[\"orientation\"] == -1\n\n        im.save(out, orientation=1)\n    with Image.open(out) as test_im:\n        assert test_im.info[\"orientation\"] == 1\n\n\ndef test_horizontal_orientations() -> None:\n    # These images have been manually hexedited to have the relevant orientations\n    with Image.open(\"Tests/images/rgb32rle_top_right.tga\") as im:\n        assert im.load()[90, 90][:3] == (0, 0, 0)\n\n    with Image.open(\"Tests/images/rgb32rle_bottom_right.tga\") as im:\n        assert im.load()[90, 90][:3] == (0, 255, 0)\n\n\ndef test_save_rle(tmp_path: Path) -> None:\n    test_file = \"Tests/images/rgb32rle.tga\"\n    with Image.open(test_file) as im:\n        assert im.info[\"compression\"] == \"tga_rle\"\n\n        out = str(tmp_path / \"temp.tga\")\n\n        # Save\n        im.save(out)\n    with Image.open(out) as test_im:\n        assert test_im.size == (199, 199)\n        assert test_im.info[\"compression\"] == \"tga_rle\"\n\n    # Save without compression\n    im.save(out, compression=None)\n    with Image.open(out) as test_im:\n        assert \"compression\" not in test_im.info\n\n    # RGBA save\n    im.convert(\"RGBA\").save(out)\n    with Image.open(out) as test_im:\n        assert test_im.size == (199, 199)\n\n    test_file = \"Tests/images/tga_id_field.tga\"\n    with Image.open(test_file) as im:\n        assert \"compression\" not in im.info\n\n        # Save with compression\n        im.save(out, compression=\"tga_rle\")\n    with Image.open(out) as test_im:\n        assert test_im.info[\"compression\"] == \"tga_rle\"\n\n\ndef test_save_l_transparency(tmp_path: Path) -> None:\n    # There are 559 transparent pixels in la.tga.\n    num_transparent = 559\n\n    in_file = \"Tests/images/la.tga\"\n    with Image.open(in_file) as im:\n        assert im.mode == \"LA\"\n        assert im.getchannel(\"A\").getcolors()[0][0] == num_transparent\n\n        out = str(tmp_path / \"temp.tga\")\n        im.save(out)\n\n    with Image.open(out) as test_im:\n        assert test_im.mode == \"LA\"\n        assert test_im.getchannel(\"A\").getcolors()[0][0] == num_transparent\n\n        assert_image_equal(im, test_im)\n", "Tests/test_image_array.py": "from __future__ import annotations\n\nfrom typing import TYPE_CHECKING, Any\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\nnumpy = pytest.importorskip(\"numpy\", reason=\"NumPy not installed\")\n\nim = hopper().resize((128, 100))\n\nif TYPE_CHECKING:\n    import numpy.typing as npt\n\n\ndef test_toarray() -> None:\n    def test(mode: str) -> tuple[tuple[int, ...], str, int]:\n        ai = numpy.array(im.convert(mode))\n        return ai.shape, ai.dtype.str, ai.nbytes\n\n    def test_with_dtype(dtype: npt.DTypeLike) -> None:\n        ai = numpy.array(im, dtype=dtype)\n        assert ai.dtype == dtype\n\n    # assert test(\"1\") == ((100, 128), '|b1', 1600))\n    assert test(\"L\") == ((100, 128), \"|u1\", 12800)\n\n    # FIXME: wrong?\n    assert test(\"I\") == ((100, 128), Image._ENDIAN + \"i4\", 51200)\n    # FIXME: wrong?\n    assert test(\"F\") == ((100, 128), Image._ENDIAN + \"f4\", 51200)\n\n    assert test(\"LA\") == ((100, 128, 2), \"|u1\", 25600)\n    assert test(\"RGB\") == ((100, 128, 3), \"|u1\", 38400)\n    assert test(\"RGBA\") == ((100, 128, 4), \"|u1\", 51200)\n    assert test(\"RGBX\") == ((100, 128, 4), \"|u1\", 51200)\n\n    test_with_dtype(numpy.float64)\n    test_with_dtype(numpy.uint8)\n\n    with Image.open(\"Tests/images/truncated_jpeg.jpg\") as im_truncated:\n        if parse_version(numpy.__version__) >= parse_version(\"1.23\"):\n            with pytest.raises(OSError):\n                numpy.array(im_truncated)\n        else:\n            with pytest.warns(UserWarning):\n                numpy.array(im_truncated)\n\n\ndef test_fromarray() -> None:\n    class Wrapper:\n        \"\"\"Class with API matching Image.fromarray\"\"\"\n\n        def __init__(self, img: Image.Image, arr_params: dict[str, Any]) -> None:\n            self.img = img\n            self.__array_interface__ = arr_params\n\n        def tobytes(self) -> bytes:\n            return self.img.tobytes()\n\n    def test(mode: str) -> tuple[str, tuple[int, int], bool]:\n        i = im.convert(mode)\n        a = numpy.array(i)\n        # Make wrapper instance for image, new array interface\n        wrapped = Wrapper(\n            i,\n            {\n                \"shape\": a.shape,\n                \"typestr\": a.dtype.str,\n                \"version\": 3,\n                \"data\": a.data,\n                \"strides\": 1,  # pretend it's non-contiguous\n            },\n        )\n        out = Image.fromarray(wrapped)\n        return out.mode, out.size, list(i.getdata()) == list(out.getdata())\n\n    # assert test(\"1\") == (\"1\", (128, 100), True)\n    assert test(\"L\") == (\"L\", (128, 100), True)\n    assert test(\"I\") == (\"I\", (128, 100), True)\n    assert test(\"F\") == (\"F\", (128, 100), True)\n    assert test(\"LA\") == (\"LA\", (128, 100), True)\n    assert test(\"RGB\") == (\"RGB\", (128, 100), True)\n    assert test(\"RGBA\") == (\"RGBA\", (128, 100), True)\n    assert test(\"RGBX\") == (\"RGBA\", (128, 100), True)\n\n    # Test mode is None with no \"typestr\" in the array interface\n    wrapped = Wrapper(hopper(\"L\"), {\"shape\": (100, 128)})\n    with pytest.raises(TypeError):\n        Image.fromarray(wrapped)\n\n\ndef test_fromarray_strides_without_tobytes() -> None:\n    class Wrapper:\n        def __init__(self, arr_params: dict[str, Any]) -> None:\n            self.__array_interface__ = arr_params\n\n    with pytest.raises(ValueError):\n        wrapped = Wrapper({\"shape\": (1, 1), \"strides\": (1, 1)})\n        Image.fromarray(wrapped, \"L\")\n\n\ndef test_fromarray_palette() -> None:\n    # Arrange\n    i = im.convert(\"L\")\n    a = numpy.array(i)\n\n    # Act\n    out = Image.fromarray(a, \"P\")\n\n    # Assert that the Python and C palettes match\n    assert len(out.palette.colors) == len(out.im.getpalette()) / 3\n", "Tests/test_image_getim.py": "from __future__ import annotations\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    im = hopper()\n    type_repr = repr(type(im.getim()))\n\n    assert \"PyCapsule\" in type_repr\n    assert isinstance(im.im.id, int)\n", "Tests/test_imagemorph.py": "# Test the ImageMorphology functionality\nfrom __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImageMorph, _imagingmorph\n\nfrom .helper import assert_image_equal_tofile, hopper\n\n\ndef string_to_img(image_string: str) -> Image.Image:\n    \"\"\"Turn a string image representation into a binary image\"\"\"\n    rows = [s for s in image_string.replace(\" \", \"\").split(\"\\n\") if len(s)]\n    height = len(rows)\n    width = len(rows[0])\n    im = Image.new(\"L\", (width, height))\n    for i in range(width):\n        for j in range(height):\n            c = rows[j][i]\n            v = c in \"X1\"\n            im.putpixel((i, j), v)\n\n    return im\n\n\nA = string_to_img(\n    \"\"\"\n    .......\n    .......\n    ..111..\n    ..111..\n    ..111..\n    .......\n    .......\n    \"\"\"\n)\n\n\ndef img_to_string(im: Image.Image) -> str:\n    \"\"\"Turn a (small) binary image into a string representation\"\"\"\n    chars = \".1\"\n    width, height = im.size\n    return \"\\n\".join(\n        \"\".join(chars[im.getpixel((c, r)) > 0] for c in range(width))\n        for r in range(height)\n    )\n\n\ndef img_string_normalize(im: str) -> str:\n    return img_to_string(string_to_img(im))\n\n\ndef assert_img_equal_img_string(a: Image.Image, b_string: str) -> None:\n    assert img_to_string(a) == img_string_normalize(b_string)\n\n\ndef test_str_to_img() -> None:\n    assert_image_equal_tofile(A, \"Tests/images/morph_a.png\")\n\n\n@pytest.mark.parametrize(\n    \"op\", (\"corner\", \"dilation4\", \"dilation8\", \"erosion4\", \"erosion8\", \"edge\")\n)\ndef test_lut(op: str) -> None:\n    lb = ImageMorph.LutBuilder(op_name=op)\n    assert lb.get_lut() is None\n\n    lut = lb.build_lut()\n    with open(f\"Tests/images/{op}.lut\", \"rb\") as f:\n        assert lut == bytearray(f.read())\n\n\ndef test_no_operator_loaded() -> None:\n    im = Image.new(\"L\", (1, 1))\n    mop = ImageMorph.MorphOp()\n    with pytest.raises(Exception) as e:\n        mop.apply(im)\n    assert str(e.value) == \"No operator loaded\"\n    with pytest.raises(Exception) as e:\n        mop.match(im)\n    assert str(e.value) == \"No operator loaded\"\n    with pytest.raises(Exception) as e:\n        mop.save_lut(\"\")\n    assert str(e.value) == \"No operator loaded\"\n\n\n# Test the named patterns\ndef test_erosion8() -> None:\n    # erosion8\n    mop = ImageMorph.MorphOp(op_name=\"erosion8\")\n    count, Aout = mop.apply(A)\n    assert count == 8\n    assert_img_equal_img_string(\n        Aout,\n        \"\"\"\n                                     .......\n                                     .......\n                                     .......\n                                     ...1...\n                                     .......\n                                     .......\n                                     .......\n                                     \"\"\",\n    )\n\n\ndef test_dialation8() -> None:\n    # dialation8\n    mop = ImageMorph.MorphOp(op_name=\"dilation8\")\n    count, Aout = mop.apply(A)\n    assert count == 16\n    assert_img_equal_img_string(\n        Aout,\n        \"\"\"\n                                     .......\n                                     .11111.\n                                     .11111.\n                                     .11111.\n                                     .11111.\n                                     .11111.\n                                     .......\n                                     \"\"\",\n    )\n\n\ndef test_erosion4() -> None:\n    # erosion4\n    mop = ImageMorph.MorphOp(op_name=\"dilation4\")\n    count, Aout = mop.apply(A)\n    assert count == 12\n    assert_img_equal_img_string(\n        Aout,\n        \"\"\"\n                                     .......\n                                     ..111..\n                                     .11111.\n                                     .11111.\n                                     .11111.\n                                     ..111..\n                                     .......\n                                     \"\"\",\n    )\n\n\ndef test_edge() -> None:\n    # edge\n    mop = ImageMorph.MorphOp(op_name=\"edge\")\n    count, Aout = mop.apply(A)\n    assert count == 1\n    assert_img_equal_img_string(\n        Aout,\n        \"\"\"\n                                     .......\n                                     .......\n                                     ..111..\n                                     ..1.1..\n                                     ..111..\n                                     .......\n                                     .......\n                                     \"\"\",\n    )\n\n\ndef test_corner() -> None:\n    # Create a corner detector pattern\n    mop = ImageMorph.MorphOp(patterns=[\"1:(... ... ...)->0\", \"4:(00. 01. ...)->1\"])\n    count, Aout = mop.apply(A)\n    assert count == 5\n    assert_img_equal_img_string(\n        Aout,\n        \"\"\"\n                                     .......\n                                     .......\n                                     ..1.1..\n                                     .......\n                                     ..1.1..\n                                     .......\n                                     .......\n                                     \"\"\",\n    )\n\n    # Test the coordinate counting with the same operator\n    coords = mop.match(A)\n    assert len(coords) == 4\n    assert tuple(coords) == ((2, 2), (4, 2), (2, 4), (4, 4))\n\n    coords = mop.get_on_pixels(Aout)\n    assert len(coords) == 4\n    assert tuple(coords) == ((2, 2), (4, 2), (2, 4), (4, 4))\n\n\ndef test_mirroring() -> None:\n    # Test 'M' for mirroring\n    mop = ImageMorph.MorphOp(patterns=[\"1:(... ... ...)->0\", \"M:(00. 01. ...)->1\"])\n    count, Aout = mop.apply(A)\n    assert count == 7\n    assert_img_equal_img_string(\n        Aout,\n        \"\"\"\n                                     .......\n                                     .......\n                                     ..1.1..\n                                     .......\n                                     .......\n                                     .......\n                                     .......\n                                     \"\"\",\n    )\n\n\ndef test_negate() -> None:\n    # Test 'N' for negate\n    mop = ImageMorph.MorphOp(patterns=[\"1:(... ... ...)->0\", \"N:(00. 01. ...)->1\"])\n    count, Aout = mop.apply(A)\n    assert count == 8\n    assert_img_equal_img_string(\n        Aout,\n        \"\"\"\n                                     .......\n                                     .......\n                                     ..1....\n                                     .......\n                                     .......\n                                     .......\n                                     .......\n                                     \"\"\",\n    )\n\n\ndef test_incorrect_mode() -> None:\n    im = hopper(\"RGB\")\n    mop = ImageMorph.MorphOp(op_name=\"erosion8\")\n\n    with pytest.raises(ValueError) as e:\n        mop.apply(im)\n    assert str(e.value) == \"Image mode must be L\"\n    with pytest.raises(ValueError) as e:\n        mop.match(im)\n    assert str(e.value) == \"Image mode must be L\"\n    with pytest.raises(ValueError) as e:\n        mop.get_on_pixels(im)\n    assert str(e.value) == \"Image mode must be L\"\n\n\ndef test_add_patterns() -> None:\n    # Arrange\n    lb = ImageMorph.LutBuilder(op_name=\"corner\")\n    assert lb.patterns == [\"1:(... ... ...)->0\", \"4:(00. 01. ...)->1\"]\n    new_patterns = [\"M:(00. 01. ...)->1\", \"N:(00. 01. ...)->1\"]\n\n    # Act\n    lb.add_patterns(new_patterns)\n\n    # Assert\n    assert lb.patterns == [\n        \"1:(... ... ...)->0\",\n        \"4:(00. 01. ...)->1\",\n        \"M:(00. 01. ...)->1\",\n        \"N:(00. 01. ...)->1\",\n    ]\n\n\ndef test_unknown_pattern() -> None:\n    with pytest.raises(Exception):\n        ImageMorph.LutBuilder(op_name=\"unknown\")\n\n\ndef test_pattern_syntax_error() -> None:\n    # Arrange\n    lb = ImageMorph.LutBuilder(op_name=\"corner\")\n    new_patterns = [\"a pattern with a syntax error\"]\n    lb.add_patterns(new_patterns)\n\n    # Act / Assert\n    with pytest.raises(Exception) as e:\n        lb.build_lut()\n    assert str(e.value) == 'Syntax error in pattern \"a pattern with a syntax error\"'\n\n\ndef test_load_invalid_mrl() -> None:\n    # Arrange\n    invalid_mrl = \"Tests/images/hopper.png\"\n    mop = ImageMorph.MorphOp()\n\n    # Act / Assert\n    with pytest.raises(Exception) as e:\n        mop.load_lut(invalid_mrl)\n    assert str(e.value) == \"Wrong size operator file!\"\n\n\ndef test_roundtrip_mrl(tmp_path: Path) -> None:\n    # Arrange\n    tempfile = str(tmp_path / \"temp.mrl\")\n    mop = ImageMorph.MorphOp(op_name=\"corner\")\n    initial_lut = mop.lut\n\n    # Act\n    mop.save_lut(tempfile)\n    mop.load_lut(tempfile)\n\n    # Act / Assert\n    assert mop.lut == initial_lut\n\n\ndef test_set_lut() -> None:\n    # Arrange\n    lb = ImageMorph.LutBuilder(op_name=\"corner\")\n    lut = lb.build_lut()\n    mop = ImageMorph.MorphOp()\n\n    # Act\n    mop.set_lut(lut)\n\n    # Assert\n    assert mop.lut == lut\n\n\ndef test_wrong_mode() -> None:\n    lut = ImageMorph.LutBuilder(op_name=\"corner\").build_lut()\n    imrgb = Image.new(\"RGB\", (10, 10))\n    iml = Image.new(\"L\", (10, 10))\n\n    with pytest.raises(RuntimeError):\n        _imagingmorph.apply(bytes(lut), imrgb.im.id, iml.im.id)\n\n    with pytest.raises(RuntimeError):\n        _imagingmorph.apply(bytes(lut), iml.im.id, imrgb.im.id)\n\n    with pytest.raises(RuntimeError):\n        _imagingmorph.match(bytes(lut), imrgb.im.id)\n\n    # Should not raise\n    _imagingmorph.match(bytes(lut), iml.im.id)\n", "Tests/test_lib_pack.py": "from __future__ import annotations\n\nimport sys\n\nimport pytest\n\nfrom PIL import Image\n\nX = 255\n\n\nclass TestLibPack:\n    def assert_pack(\n        self,\n        mode: str,\n        rawmode: str,\n        data: int | bytes,\n        *pixels: float | tuple[int, ...],\n    ) -> None:\n        \"\"\"\n        data - either raw bytes with data or just number of bytes in rawmode.\n        \"\"\"\n        im = Image.new(mode, (len(pixels), 1))\n        for x, pixel in enumerate(pixels):\n            im.putpixel((x, 0), pixel)\n\n        if isinstance(data, int):\n            data_len = data * len(pixels)\n            data = bytes(range(1, data_len + 1))\n\n        assert data == im.tobytes(\"raw\", rawmode)\n\n    def test_1(self) -> None:\n        self.assert_pack(\"1\", \"1\", b\"\\x01\", 0, 0, 0, 0, 0, 0, 0, X)\n        self.assert_pack(\"1\", \"1;I\", b\"\\x01\", X, X, X, X, X, X, X, 0)\n        self.assert_pack(\"1\", \"1;R\", b\"\\x01\", X, 0, 0, 0, 0, 0, 0, 0)\n        self.assert_pack(\"1\", \"1;IR\", b\"\\x01\", 0, X, X, X, X, X, X, X)\n\n        self.assert_pack(\"1\", \"1\", b\"\\xaa\", X, 0, X, 0, X, 0, X, 0)\n        self.assert_pack(\"1\", \"1;I\", b\"\\xaa\", 0, X, 0, X, 0, X, 0, X)\n        self.assert_pack(\"1\", \"1;R\", b\"\\xaa\", 0, X, 0, X, 0, X, 0, X)\n        self.assert_pack(\"1\", \"1;IR\", b\"\\xaa\", X, 0, X, 0, X, 0, X, 0)\n\n        self.assert_pack(\"1\", \"L\", b\"\\xff\\x00\\x00\\xff\\x00\\x00\", X, 0, 0, X, 0, 0)\n\n    def test_L(self) -> None:\n        self.assert_pack(\"L\", \"L\", 1, 1, 2, 3, 4)\n        self.assert_pack(\"L\", \"L;16\", b\"\\x00\\xc6\\x00\\xaf\", 198, 175)\n        self.assert_pack(\"L\", \"L;16B\", b\"\\xc6\\x00\\xaf\\x00\", 198, 175)\n\n    def test_LA(self) -> None:\n        self.assert_pack(\"LA\", \"LA\", 2, (1, 2), (3, 4), (5, 6))\n        self.assert_pack(\"LA\", \"LA;L\", 2, (1, 4), (2, 5), (3, 6))\n\n    def test_La(self) -> None:\n        self.assert_pack(\"La\", \"La\", 2, (1, 2), (3, 4), (5, 6))\n\n    def test_P(self) -> None:\n        self.assert_pack(\"P\", \"P;1\", b\"\\xe4\", 1, 1, 1, 0, 0, 255, 0, 0)\n        self.assert_pack(\"P\", \"P;2\", b\"\\xe4\", 3, 2, 1, 0)\n        self.assert_pack(\"P\", \"P;4\", b\"\\x02\\xef\", 0, 2, 14, 15)\n        self.assert_pack(\"P\", \"P\", 1, 1, 2, 3, 4)\n\n    def test_PA(self) -> None:\n        self.assert_pack(\"PA\", \"PA\", 2, (1, 2), (3, 4), (5, 6))\n        self.assert_pack(\"PA\", \"PA;L\", 2, (1, 4), (2, 5), (3, 6))\n\n    def test_RGB(self) -> None:\n        self.assert_pack(\"RGB\", \"RGB\", 3, (1, 2, 3), (4, 5, 6), (7, 8, 9))\n        self.assert_pack(\n            \"RGB\", \"RGBX\", b\"\\x01\\x02\\x03\\xff\\x05\\x06\\x07\\xff\", (1, 2, 3), (5, 6, 7)\n        )\n        self.assert_pack(\n            \"RGB\", \"XRGB\", b\"\\x00\\x02\\x03\\x04\\x00\\x06\\x07\\x08\", (2, 3, 4), (6, 7, 8)\n        )\n        self.assert_pack(\"RGB\", \"BGR\", 3, (3, 2, 1), (6, 5, 4), (9, 8, 7))\n        self.assert_pack(\n            \"RGB\", \"BGRX\", b\"\\x01\\x02\\x03\\x00\\x05\\x06\\x07\\x00\", (3, 2, 1), (7, 6, 5)\n        )\n        self.assert_pack(\n            \"RGB\", \"XBGR\", b\"\\x00\\x02\\x03\\x04\\x00\\x06\\x07\\x08\", (4, 3, 2), (8, 7, 6)\n        )\n        self.assert_pack(\"RGB\", \"RGB;L\", 3, (1, 4, 7), (2, 5, 8), (3, 6, 9))\n        self.assert_pack(\"RGB\", \"R\", 1, (1, 9, 9), (2, 9, 9), (3, 9, 9))\n        self.assert_pack(\"RGB\", \"G\", 1, (9, 1, 9), (9, 2, 9), (9, 3, 9))\n        self.assert_pack(\"RGB\", \"B\", 1, (9, 9, 1), (9, 9, 2), (9, 9, 3))\n\n    def test_RGBA(self) -> None:\n        self.assert_pack(\"RGBA\", \"RGBA\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12))\n        self.assert_pack(\n            \"RGBA\", \"RGBA;L\", 4, (1, 4, 7, 10), (2, 5, 8, 11), (3, 6, 9, 12)\n        )\n        self.assert_pack(\"RGBA\", \"RGB\", 3, (1, 2, 3, 14), (4, 5, 6, 15), (7, 8, 9, 16))\n        self.assert_pack(\"RGBA\", \"BGR\", 3, (3, 2, 1, 14), (6, 5, 4, 15), (9, 8, 7, 16))\n        self.assert_pack(\"RGBA\", \"BGRA\", 4, (3, 2, 1, 4), (7, 6, 5, 8), (11, 10, 9, 12))\n        self.assert_pack(\"RGBA\", \"ABGR\", 4, (4, 3, 2, 1), (8, 7, 6, 5), (12, 11, 10, 9))\n        self.assert_pack(\n            \"RGBA\",\n            \"BGRa\",\n            4,\n            (191, 127, 63, 4),\n            (223, 191, 159, 8),\n            (233, 212, 191, 12),\n        )\n        self.assert_pack(\"RGBA\", \"R\", 1, (1, 0, 8, 9), (2, 0, 8, 9), (3, 0, 8, 0))\n        self.assert_pack(\"RGBA\", \"G\", 1, (6, 1, 8, 9), (6, 2, 8, 9), (6, 3, 8, 9))\n        self.assert_pack(\"RGBA\", \"B\", 1, (6, 7, 1, 9), (6, 7, 2, 0), (6, 7, 3, 9))\n        self.assert_pack(\"RGBA\", \"A\", 1, (6, 7, 0, 1), (6, 7, 0, 2), (0, 7, 0, 3))\n\n    def test_RGBa(self) -> None:\n        self.assert_pack(\"RGBa\", \"RGBa\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12))\n        self.assert_pack(\"RGBa\", \"BGRa\", 4, (3, 2, 1, 4), (7, 6, 5, 8), (11, 10, 9, 12))\n        self.assert_pack(\"RGBa\", \"aBGR\", 4, (4, 3, 2, 1), (8, 7, 6, 5), (12, 11, 10, 9))\n\n    def test_RGBX(self) -> None:\n        self.assert_pack(\"RGBX\", \"RGBX\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12))\n        self.assert_pack(\n            \"RGBX\", \"RGBX;L\", 4, (1, 4, 7, 10), (2, 5, 8, 11), (3, 6, 9, 12)\n        )\n        self.assert_pack(\"RGBX\", \"RGB\", 3, (1, 2, 3, X), (4, 5, 6, X), (7, 8, 9, X))\n        self.assert_pack(\"RGBX\", \"BGR\", 3, (3, 2, 1, X), (6, 5, 4, X), (9, 8, 7, X))\n        self.assert_pack(\n            \"RGBX\",\n            \"BGRX\",\n            b\"\\x01\\x02\\x03\\x00\\x05\\x06\\x07\\x00\\t\\n\\x0b\\x00\",\n            (3, 2, 1, X),\n            (7, 6, 5, X),\n            (11, 10, 9, X),\n        )\n        self.assert_pack(\n            \"RGBX\",\n            \"XBGR\",\n            b\"\\x00\\x02\\x03\\x04\\x00\\x06\\x07\\x08\\x00\\n\\x0b\\x0c\",\n            (4, 3, 2, X),\n            (8, 7, 6, X),\n            (12, 11, 10, X),\n        )\n        self.assert_pack(\"RGBX\", \"R\", 1, (1, 0, 8, 9), (2, 0, 8, 9), (3, 0, 8, 0))\n        self.assert_pack(\"RGBX\", \"G\", 1, (6, 1, 8, 9), (6, 2, 8, 9), (6, 3, 8, 9))\n        self.assert_pack(\"RGBX\", \"B\", 1, (6, 7, 1, 9), (6, 7, 2, 0), (6, 7, 3, 9))\n        self.assert_pack(\"RGBX\", \"X\", 1, (6, 7, 0, 1), (6, 7, 0, 2), (0, 7, 0, 3))\n\n    def test_CMYK(self) -> None:\n        self.assert_pack(\"CMYK\", \"CMYK\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12))\n        self.assert_pack(\n            \"CMYK\",\n            \"CMYK;I\",\n            4,\n            (254, 253, 252, 251),\n            (250, 249, 248, 247),\n            (246, 245, 244, 243),\n        )\n        self.assert_pack(\n            \"CMYK\", \"CMYK;L\", 4, (1, 4, 7, 10), (2, 5, 8, 11), (3, 6, 9, 12)\n        )\n        self.assert_pack(\"CMYK\", \"K\", 1, (6, 7, 0, 1), (6, 7, 0, 2), (0, 7, 0, 3))\n\n    def test_YCbCr(self) -> None:\n        self.assert_pack(\"YCbCr\", \"YCbCr\", 3, (1, 2, 3), (4, 5, 6), (7, 8, 9))\n        self.assert_pack(\"YCbCr\", \"YCbCr;L\", 3, (1, 4, 7), (2, 5, 8), (3, 6, 9))\n        self.assert_pack(\n            \"YCbCr\",\n            \"YCbCrX\",\n            b\"\\x01\\x02\\x03\\xff\\x05\\x06\\x07\\xff\\t\\n\\x0b\\xff\",\n            (1, 2, 3),\n            (5, 6, 7),\n            (9, 10, 11),\n        )\n        self.assert_pack(\n            \"YCbCr\",\n            \"YCbCrK\",\n            b\"\\x01\\x02\\x03\\xff\\x05\\x06\\x07\\xff\\t\\n\\x0b\\xff\",\n            (1, 2, 3),\n            (5, 6, 7),\n            (9, 10, 11),\n        )\n        self.assert_pack(\"YCbCr\", \"Y\", 1, (1, 0, 8, 9), (2, 0, 8, 9), (3, 0, 8, 0))\n        self.assert_pack(\"YCbCr\", \"Cb\", 1, (6, 1, 8, 9), (6, 2, 8, 9), (6, 3, 8, 9))\n        self.assert_pack(\"YCbCr\", \"Cr\", 1, (6, 7, 1, 9), (6, 7, 2, 0), (6, 7, 3, 9))\n\n    def test_LAB(self) -> None:\n        self.assert_pack(\"LAB\", \"LAB\", 3, (1, 130, 131), (4, 133, 134), (7, 136, 137))\n        self.assert_pack(\"LAB\", \"L\", 1, (1, 9, 9), (2, 9, 9), (3, 9, 9))\n        self.assert_pack(\"LAB\", \"A\", 1, (9, 1, 9), (9, 2, 9), (9, 3, 9))\n        self.assert_pack(\"LAB\", \"B\", 1, (9, 9, 1), (9, 9, 2), (9, 9, 3))\n\n    def test_HSV(self) -> None:\n        self.assert_pack(\"HSV\", \"HSV\", 3, (1, 2, 3), (4, 5, 6), (7, 8, 9))\n        self.assert_pack(\"HSV\", \"H\", 1, (1, 9, 9), (2, 9, 9), (3, 9, 9))\n        self.assert_pack(\"HSV\", \"S\", 1, (9, 1, 9), (9, 2, 9), (9, 3, 9))\n        self.assert_pack(\"HSV\", \"V\", 1, (9, 9, 1), (9, 9, 2), (9, 9, 3))\n\n    def test_I(self) -> None:\n        self.assert_pack(\"I\", \"I;16B\", 2, 0x0102, 0x0304)\n        self.assert_pack(\n            \"I\", \"I;32S\", b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\", 0x01000083, -2097151999\n        )\n\n        if sys.byteorder == \"little\":\n            self.assert_pack(\"I\", \"I\", 4, 0x04030201, 0x08070605)\n            self.assert_pack(\n                \"I\",\n                \"I;32NS\",\n                b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\",\n                0x01000083,\n                -2097151999,\n            )\n        else:\n            self.assert_pack(\"I\", \"I\", 4, 0x01020304, 0x05060708)\n            self.assert_pack(\n                \"I\",\n                \"I;32NS\",\n                b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\",\n                -2097151999,\n                0x01000083,\n            )\n\n    def test_I16(self) -> None:\n        if sys.byteorder == \"little\":\n            self.assert_pack(\"I;16N\", \"I;16N\", 2, 0x0201, 0x0403, 0x0605)\n        else:\n            self.assert_pack(\"I;16N\", \"I;16N\", 2, 0x0102, 0x0304, 0x0506)\n\n    def test_F_float(self) -> None:\n        self.assert_pack(\"F\", \"F;32F\", 4, 1.539989614439558e-36, 4.063216068939723e-34)\n\n        if sys.byteorder == \"little\":\n            self.assert_pack(\"F\", \"F\", 4, 1.539989614439558e-36, 4.063216068939723e-34)\n            self.assert_pack(\n                \"F\", \"F;32NF\", 4, 1.539989614439558e-36, 4.063216068939723e-34\n            )\n        else:\n            self.assert_pack(\"F\", \"F\", 4, 2.387939260590663e-38, 6.301941157072183e-36)\n            self.assert_pack(\n                \"F\", \"F;32NF\", 4, 2.387939260590663e-38, 6.301941157072183e-36\n            )\n\n\nclass TestLibUnpack:\n    def assert_unpack(\n        self,\n        mode: str,\n        rawmode: str,\n        data: int | bytes,\n        *pixels: float | tuple[int, ...],\n    ) -> None:\n        \"\"\"\n        data - either raw bytes with data or just number of bytes in rawmode.\n        \"\"\"\n        if isinstance(data, int):\n            data_len = data * len(pixels)\n            data = bytes(range(1, data_len + 1))\n\n        im = Image.frombytes(mode, (len(pixels), 1), data, \"raw\", rawmode, 0, 1)\n\n        for x, pixel in enumerate(pixels):\n            assert pixel == im.getpixel((x, 0))\n\n    def test_1(self) -> None:\n        self.assert_unpack(\"1\", \"1\", b\"\\x01\", 0, 0, 0, 0, 0, 0, 0, X)\n        self.assert_unpack(\"1\", \"1;I\", b\"\\x01\", X, X, X, X, X, X, X, 0)\n        self.assert_unpack(\"1\", \"1;R\", b\"\\x01\", X, 0, 0, 0, 0, 0, 0, 0)\n        self.assert_unpack(\"1\", \"1;IR\", b\"\\x01\", 0, X, X, X, X, X, X, X)\n\n        self.assert_unpack(\"1\", \"1\", b\"\\xaa\", X, 0, X, 0, X, 0, X, 0)\n        self.assert_unpack(\"1\", \"1;I\", b\"\\xaa\", 0, X, 0, X, 0, X, 0, X)\n        self.assert_unpack(\"1\", \"1;R\", b\"\\xaa\", 0, X, 0, X, 0, X, 0, X)\n        self.assert_unpack(\"1\", \"1;IR\", b\"\\xaa\", X, 0, X, 0, X, 0, X, 0)\n\n        self.assert_unpack(\"1\", \"1;8\", b\"\\x00\\x01\\x02\\xff\", 0, X, X, X)\n\n    def test_L(self) -> None:\n        self.assert_unpack(\"L\", \"L;2\", b\"\\xe4\", 255, 170, 85, 0)\n        self.assert_unpack(\"L\", \"L;2I\", b\"\\xe4\", 0, 85, 170, 255)\n        self.assert_unpack(\"L\", \"L;2R\", b\"\\xe4\", 0, 170, 85, 255)\n        self.assert_unpack(\"L\", \"L;2IR\", b\"\\xe4\", 255, 85, 170, 0)\n\n        self.assert_unpack(\"L\", \"L;4\", b\"\\x02\\xef\", 0, 34, 238, 255)\n        self.assert_unpack(\"L\", \"L;4I\", b\"\\x02\\xef\", 255, 221, 17, 0)\n        self.assert_unpack(\"L\", \"L;4R\", b\"\\x02\\xef\", 68, 0, 255, 119)\n        self.assert_unpack(\"L\", \"L;4IR\", b\"\\x02\\xef\", 187, 255, 0, 136)\n\n        self.assert_unpack(\"L\", \"L\", 1, 1, 2, 3, 4)\n        self.assert_unpack(\"L\", \"L;I\", 1, 254, 253, 252, 251)\n        self.assert_unpack(\"L\", \"L;R\", 1, 128, 64, 192, 32)\n        self.assert_unpack(\"L\", \"L;16\", 2, 2, 4, 6, 8)\n        self.assert_unpack(\"L\", \"L;16B\", 2, 1, 3, 5, 7)\n        self.assert_unpack(\"L\", \"L;16\", b\"\\x00\\xc6\\x00\\xaf\", 198, 175)\n        self.assert_unpack(\"L\", \"L;16B\", b\"\\xc6\\x00\\xaf\\x00\", 198, 175)\n\n    def test_LA(self) -> None:\n        self.assert_unpack(\"LA\", \"LA\", 2, (1, 2), (3, 4), (5, 6))\n        self.assert_unpack(\"LA\", \"LA;L\", 2, (1, 4), (2, 5), (3, 6))\n\n    def test_La(self) -> None:\n        self.assert_unpack(\"La\", \"La\", 2, (1, 2), (3, 4), (5, 6))\n\n    def test_P(self) -> None:\n        self.assert_unpack(\"P\", \"P;1\", b\"\\xe4\", 1, 1, 1, 0, 0, 1, 0, 0)\n        self.assert_unpack(\"P\", \"P;2\", b\"\\xe4\", 3, 2, 1, 0)\n        # erroneous?\n        # self.assert_unpack(\"P\", \"P;2L\", b'\\xe4', 1, 1, 1, 0)\n        self.assert_unpack(\"P\", \"P;4\", b\"\\x02\\xef\", 0, 2, 14, 15)\n        # erroneous?\n        # self.assert_unpack(\"P\", \"P;4L\", b'\\x02\\xef', 2, 10, 10, 0)\n        self.assert_unpack(\"P\", \"P\", 1, 1, 2, 3, 4)\n        self.assert_unpack(\"P\", \"P;R\", 1, 128, 64, 192, 32)\n\n    def test_PA(self) -> None:\n        self.assert_unpack(\"PA\", \"PA\", 2, (1, 2), (3, 4), (5, 6))\n        self.assert_unpack(\"PA\", \"PA;L\", 2, (1, 4), (2, 5), (3, 6))\n\n    def test_RGB(self) -> None:\n        self.assert_unpack(\"RGB\", \"RGB\", 3, (1, 2, 3), (4, 5, 6), (7, 8, 9))\n        self.assert_unpack(\"RGB\", \"RGB;L\", 3, (1, 4, 7), (2, 5, 8), (3, 6, 9))\n        self.assert_unpack(\"RGB\", \"RGB;R\", 3, (128, 64, 192), (32, 160, 96))\n        self.assert_unpack(\"RGB\", \"RGB;16L\", 6, (2, 4, 6), (8, 10, 12))\n        self.assert_unpack(\"RGB\", \"RGB;16B\", 6, (1, 3, 5), (7, 9, 11))\n        self.assert_unpack(\"RGB\", \"BGR\", 3, (3, 2, 1), (6, 5, 4), (9, 8, 7))\n        self.assert_unpack(\"RGB\", \"RGB;15\", 2, (8, 131, 0), (24, 0, 8))\n        self.assert_unpack(\"RGB\", \"BGR;15\", 2, (0, 131, 8), (8, 0, 24))\n        self.assert_unpack(\"RGB\", \"RGB;16\", 2, (8, 64, 0), (24, 129, 0))\n        self.assert_unpack(\"RGB\", \"BGR;16\", 2, (0, 64, 8), (0, 129, 24))\n        self.assert_unpack(\"RGB\", \"RGB;4B\", 2, (17, 0, 34), (51, 0, 68))\n        self.assert_unpack(\"RGB\", \"RGBX\", 4, (1, 2, 3), (5, 6, 7), (9, 10, 11))\n        self.assert_unpack(\"RGB\", \"RGBX;L\", 4, (1, 4, 7), (2, 5, 8), (3, 6, 9))\n        self.assert_unpack(\"RGB\", \"BGRX\", 4, (3, 2, 1), (7, 6, 5), (11, 10, 9))\n        self.assert_unpack(\"RGB\", \"XRGB\", 4, (2, 3, 4), (6, 7, 8), (10, 11, 12))\n        self.assert_unpack(\"RGB\", \"XBGR\", 4, (4, 3, 2), (8, 7, 6), (12, 11, 10))\n        self.assert_unpack(\n            \"RGB\",\n            \"YCC;P\",\n            b\"D]\\x9c\\x82\\x1a\\x91\\xfaOC\\xe7J\\x12\",  # random data\n            (127, 102, 0),\n            (192, 227, 0),\n            (213, 255, 170),\n            (98, 255, 133),\n        )\n        self.assert_unpack(\"RGB\", \"R\", 1, (1, 0, 0), (2, 0, 0), (3, 0, 0))\n        self.assert_unpack(\"RGB\", \"G\", 1, (0, 1, 0), (0, 2, 0), (0, 3, 0))\n        self.assert_unpack(\"RGB\", \"B\", 1, (0, 0, 1), (0, 0, 2), (0, 0, 3))\n\n        self.assert_unpack(\"RGB\", \"R;16B\", 2, (1, 0, 0), (3, 0, 0), (5, 0, 0))\n        self.assert_unpack(\"RGB\", \"G;16B\", 2, (0, 1, 0), (0, 3, 0), (0, 5, 0))\n        self.assert_unpack(\"RGB\", \"B;16B\", 2, (0, 0, 1), (0, 0, 3), (0, 0, 5))\n\n        self.assert_unpack(\"RGB\", \"R;16L\", 2, (2, 0, 0), (4, 0, 0), (6, 0, 0))\n        self.assert_unpack(\"RGB\", \"G;16L\", 2, (0, 2, 0), (0, 4, 0), (0, 6, 0))\n        self.assert_unpack(\"RGB\", \"B;16L\", 2, (0, 0, 2), (0, 0, 4), (0, 0, 6))\n\n        if sys.byteorder == \"little\":\n            self.assert_unpack(\"RGB\", \"R;16N\", 2, (2, 0, 0), (4, 0, 0), (6, 0, 0))\n            self.assert_unpack(\"RGB\", \"G;16N\", 2, (0, 2, 0), (0, 4, 0), (0, 6, 0))\n            self.assert_unpack(\"RGB\", \"B;16N\", 2, (0, 0, 2), (0, 0, 4), (0, 0, 6))\n        else:\n            self.assert_unpack(\"RGB\", \"R;16N\", 2, (1, 0, 0), (3, 0, 0), (5, 0, 0))\n            self.assert_unpack(\"RGB\", \"G;16N\", 2, (0, 1, 0), (0, 3, 0), (0, 5, 0))\n            self.assert_unpack(\"RGB\", \"B;16N\", 2, (0, 0, 1), (0, 0, 3), (0, 0, 5))\n\n        self.assert_unpack(\n            \"RGB\", \"CMYK\", 4, (250, 249, 248), (242, 241, 240), (234, 233, 233)\n        )\n\n    def test_BGR(self) -> None:\n        with pytest.warns(DeprecationWarning):\n            self.assert_unpack(\n                \"BGR;15\", \"BGR;15\", 3, (8, 131, 0), (24, 0, 8), (41, 131, 8)\n            )\n            self.assert_unpack(\n                \"BGR;16\", \"BGR;16\", 3, (8, 64, 0), (24, 129, 0), (41, 194, 0)\n            )\n            self.assert_unpack(\"BGR;24\", \"BGR;24\", 3, (1, 2, 3), (4, 5, 6), (7, 8, 9))\n\n    def test_RGBA(self) -> None:\n        self.assert_unpack(\"RGBA\", \"LA\", 2, (1, 1, 1, 2), (3, 3, 3, 4), (5, 5, 5, 6))\n        self.assert_unpack(\n            \"RGBA\", \"LA;16B\", 4, (1, 1, 1, 3), (5, 5, 5, 7), (9, 9, 9, 11)\n        )\n        self.assert_unpack(\n            \"RGBA\", \"RGBA\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)\n        )\n        self.assert_unpack(\n            \"RGBA\", \"RGBAX\", 5, (1, 2, 3, 4), (6, 7, 8, 9), (11, 12, 13, 14)\n        )\n        self.assert_unpack(\n            \"RGBA\", \"RGBAXX\", 6, (1, 2, 3, 4), (7, 8, 9, 10), (13, 14, 15, 16)\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBa\",\n            4,\n            (63, 127, 191, 4),\n            (159, 191, 223, 8),\n            (191, 212, 233, 12),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBa\",\n            b\"\\x01\\x02\\x03\\x00\\x10\\x20\\x30\\x7f\\x10\\x20\\x30\\xff\",\n            (0, 0, 0, 0),\n            (32, 64, 96, 127),\n            (16, 32, 48, 255),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBaX\",\n            b\"\\x01\\x02\\x03\\x00-\\x10\\x20\\x30\\x7f-\\x10\\x20\\x30\\xff-\",\n            (0, 0, 0, 0),\n            (32, 64, 96, 127),\n            (16, 32, 48, 255),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBaXX\",\n            b\"\\x01\\x02\\x03\\x00==\\x10\\x20\\x30\\x7f!!\\x10\\x20\\x30\\xff??\",\n            (0, 0, 0, 0),\n            (32, 64, 96, 127),\n            (16, 32, 48, 255),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBa;16L\",\n            8,\n            (63, 127, 191, 8),\n            (159, 191, 223, 16),\n            (191, 212, 233, 24),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBa;16L\",\n            b\"\\x88\\x01\\x88\\x02\\x88\\x03\\x88\\x00\\x88\\x10\\x88\\x20\\x88\\x30\\x88\\xff\",\n            (0, 0, 0, 0),\n            (16, 32, 48, 255),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBa;16B\",\n            8,\n            (36, 109, 182, 7),\n            (153, 187, 221, 15),\n            (188, 210, 232, 23),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBa;16B\",\n            b\"\\x01\\x88\\x02\\x88\\x03\\x88\\x00\\x88\\x10\\x88\\x20\\x88\\x30\\x88\\xff\\x88\",\n            (0, 0, 0, 0),\n            (16, 32, 48, 255),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"BGRa\",\n            4,\n            (191, 127, 63, 4),\n            (223, 191, 159, 8),\n            (233, 212, 191, 12),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"BGRa\",\n            b\"\\x01\\x02\\x03\\x00\\x10\\x20\\x30\\xff\",\n            (0, 0, 0, 0),\n            (48, 32, 16, 255),\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"RGBA;I\",\n            4,\n            (254, 253, 252, 4),\n            (250, 249, 248, 8),\n            (246, 245, 244, 12),\n        )\n        self.assert_unpack(\n            \"RGBA\", \"RGBA;L\", 4, (1, 4, 7, 10), (2, 5, 8, 11), (3, 6, 9, 12)\n        )\n        self.assert_unpack(\"RGBA\", \"RGBA;15\", 2, (8, 131, 0, 0), (24, 0, 8, 0))\n        self.assert_unpack(\"RGBA\", \"BGRA;15\", 2, (0, 131, 8, 0), (8, 0, 24, 0))\n        self.assert_unpack(\"RGBA\", \"RGBA;4B\", 2, (17, 0, 34, 0), (51, 0, 68, 0))\n        self.assert_unpack(\"RGBA\", \"RGBA;16L\", 8, (2, 4, 6, 8), (10, 12, 14, 16))\n        self.assert_unpack(\"RGBA\", \"RGBA;16B\", 8, (1, 3, 5, 7), (9, 11, 13, 15))\n        self.assert_unpack(\"RGBA\", \"BGRA;16L\", 8, (6, 4, 2, 8), (14, 12, 10, 16))\n        self.assert_unpack(\"RGBA\", \"BGRA;16B\", 8, (5, 3, 1, 7), (13, 11, 9, 15))\n        self.assert_unpack(\n            \"RGBA\", \"BGRA\", 4, (3, 2, 1, 4), (7, 6, 5, 8), (11, 10, 9, 12)\n        )\n        self.assert_unpack(\n            \"RGBA\", \"ARGB\", 4, (2, 3, 4, 1), (6, 7, 8, 5), (10, 11, 12, 9)\n        )\n        self.assert_unpack(\n            \"RGBA\", \"ABGR\", 4, (4, 3, 2, 1), (8, 7, 6, 5), (12, 11, 10, 9)\n        )\n        self.assert_unpack(\n            \"RGBA\",\n            \"YCCA;P\",\n            b\"]bE\\x04\\xdd\\xbej\\xed57T\\xce\\xac\\xce:\\x11\",  # random data\n            (0, 161, 0, 4),\n            (255, 255, 255, 237),\n            (27, 158, 0, 206),\n            (0, 118, 0, 17),\n        )\n        self.assert_unpack(\"RGBA\", \"R\", 1, (1, 0, 0, 0), (2, 0, 0, 0), (3, 0, 0, 0))\n        self.assert_unpack(\"RGBA\", \"G\", 1, (0, 1, 0, 0), (0, 2, 0, 0), (0, 3, 0, 0))\n        self.assert_unpack(\"RGBA\", \"B\", 1, (0, 0, 1, 0), (0, 0, 2, 0), (0, 0, 3, 0))\n        self.assert_unpack(\"RGBA\", \"A\", 1, (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 0, 3))\n\n        self.assert_unpack(\"RGBA\", \"R;16B\", 2, (1, 0, 0, 0), (3, 0, 0, 0), (5, 0, 0, 0))\n        self.assert_unpack(\"RGBA\", \"G;16B\", 2, (0, 1, 0, 0), (0, 3, 0, 0), (0, 5, 0, 0))\n        self.assert_unpack(\"RGBA\", \"B;16B\", 2, (0, 0, 1, 0), (0, 0, 3, 0), (0, 0, 5, 0))\n        self.assert_unpack(\"RGBA\", \"A;16B\", 2, (0, 0, 0, 1), (0, 0, 0, 3), (0, 0, 0, 5))\n\n        self.assert_unpack(\"RGBA\", \"R;16L\", 2, (2, 0, 0, 0), (4, 0, 0, 0), (6, 0, 0, 0))\n        self.assert_unpack(\"RGBA\", \"G;16L\", 2, (0, 2, 0, 0), (0, 4, 0, 0), (0, 6, 0, 0))\n        self.assert_unpack(\"RGBA\", \"B;16L\", 2, (0, 0, 2, 0), (0, 0, 4, 0), (0, 0, 6, 0))\n        self.assert_unpack(\"RGBA\", \"A;16L\", 2, (0, 0, 0, 2), (0, 0, 0, 4), (0, 0, 0, 6))\n\n        if sys.byteorder == \"little\":\n            self.assert_unpack(\n                \"RGBA\", \"R;16N\", 2, (2, 0, 0, 0), (4, 0, 0, 0), (6, 0, 0, 0)\n            )\n            self.assert_unpack(\n                \"RGBA\", \"G;16N\", 2, (0, 2, 0, 0), (0, 4, 0, 0), (0, 6, 0, 0)\n            )\n            self.assert_unpack(\n                \"RGBA\", \"B;16N\", 2, (0, 0, 2, 0), (0, 0, 4, 0), (0, 0, 6, 0)\n            )\n            self.assert_unpack(\n                \"RGBA\", \"A;16N\", 2, (0, 0, 0, 2), (0, 0, 0, 4), (0, 0, 0, 6)\n            )\n        else:\n            self.assert_unpack(\n                \"RGBA\", \"R;16N\", 2, (1, 0, 0, 0), (3, 0, 0, 0), (5, 0, 0, 0)\n            )\n            self.assert_unpack(\n                \"RGBA\", \"G;16N\", 2, (0, 1, 0, 0), (0, 3, 0, 0), (0, 5, 0, 0)\n            )\n            self.assert_unpack(\n                \"RGBA\", \"B;16N\", 2, (0, 0, 1, 0), (0, 0, 3, 0), (0, 0, 5, 0)\n            )\n            self.assert_unpack(\n                \"RGBA\", \"A;16N\", 2, (0, 0, 0, 1), (0, 0, 0, 3), (0, 0, 0, 5)\n            )\n\n    def test_RGBa(self) -> None:\n        self.assert_unpack(\n            \"RGBa\", \"RGBa\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)\n        )\n        self.assert_unpack(\n            \"RGBa\", \"BGRa\", 4, (3, 2, 1, 4), (7, 6, 5, 8), (11, 10, 9, 12)\n        )\n        self.assert_unpack(\n            \"RGBa\", \"aRGB\", 4, (2, 3, 4, 1), (6, 7, 8, 5), (10, 11, 12, 9)\n        )\n        self.assert_unpack(\n            \"RGBa\", \"aBGR\", 4, (4, 3, 2, 1), (8, 7, 6, 5), (12, 11, 10, 9)\n        )\n\n    def test_RGBX(self) -> None:\n        self.assert_unpack(\"RGBX\", \"RGB\", 3, (1, 2, 3, X), (4, 5, 6, X), (7, 8, 9, X))\n        self.assert_unpack(\"RGBX\", \"RGB;L\", 3, (1, 4, 7, X), (2, 5, 8, X), (3, 6, 9, X))\n        self.assert_unpack(\"RGBX\", \"RGB;16B\", 6, (1, 3, 5, X), (7, 9, 11, X))\n        self.assert_unpack(\"RGBX\", \"BGR\", 3, (3, 2, 1, X), (6, 5, 4, X), (9, 8, 7, X))\n        self.assert_unpack(\"RGBX\", \"RGB;15\", 2, (8, 131, 0, X), (24, 0, 8, X))\n        self.assert_unpack(\"RGBX\", \"BGR;15\", 2, (0, 131, 8, X), (8, 0, 24, X))\n        self.assert_unpack(\"RGBX\", \"RGB;4B\", 2, (17, 0, 34, X), (51, 0, 68, X))\n        self.assert_unpack(\n            \"RGBX\", \"RGBX\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)\n        )\n        self.assert_unpack(\n            \"RGBX\", \"RGBXX\", 5, (1, 2, 3, 4), (6, 7, 8, 9), (11, 12, 13, 14)\n        )\n        self.assert_unpack(\n            \"RGBX\", \"RGBXXX\", 6, (1, 2, 3, 4), (7, 8, 9, 10), (13, 14, 15, 16)\n        )\n        self.assert_unpack(\n            \"RGBX\", \"RGBX;L\", 4, (1, 4, 7, 10), (2, 5, 8, 11), (3, 6, 9, 12)\n        )\n        self.assert_unpack(\"RGBX\", \"RGBX;16L\", 8, (2, 4, 6, 8), (10, 12, 14, 16))\n        self.assert_unpack(\"RGBX\", \"RGBX;16B\", 8, (1, 3, 5, 7), (9, 11, 13, 15))\n        self.assert_unpack(\n            \"RGBX\", \"BGRX\", 4, (3, 2, 1, X), (7, 6, 5, X), (11, 10, 9, X)\n        )\n        self.assert_unpack(\n            \"RGBX\", \"XRGB\", 4, (2, 3, 4, X), (6, 7, 8, X), (10, 11, 12, X)\n        )\n        self.assert_unpack(\n            \"RGBX\", \"XBGR\", 4, (4, 3, 2, X), (8, 7, 6, X), (12, 11, 10, X)\n        )\n        self.assert_unpack(\n            \"RGBX\",\n            \"YCC;P\",\n            b\"D]\\x9c\\x82\\x1a\\x91\\xfaOC\\xe7J\\x12\",  # random data\n            (127, 102, 0, X),\n            (192, 227, 0, X),\n            (213, 255, 170, X),\n            (98, 255, 133, X),\n        )\n        self.assert_unpack(\"RGBX\", \"R\", 1, (1, 0, 0, 0), (2, 0, 0, 0), (3, 0, 0, 0))\n        self.assert_unpack(\"RGBX\", \"G\", 1, (0, 1, 0, 0), (0, 2, 0, 0), (0, 3, 0, 0))\n        self.assert_unpack(\"RGBX\", \"B\", 1, (0, 0, 1, 0), (0, 0, 2, 0), (0, 0, 3, 0))\n        self.assert_unpack(\"RGBX\", \"X\", 1, (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 0, 3))\n\n    def test_CMYK(self) -> None:\n        self.assert_unpack(\n            \"CMYK\", \"CMYK\", 4, (1, 2, 3, 4), (5, 6, 7, 8), (9, 10, 11, 12)\n        )\n        self.assert_unpack(\n            \"CMYK\", \"CMYKX\", 5, (1, 2, 3, 4), (6, 7, 8, 9), (11, 12, 13, 14)\n        )\n        self.assert_unpack(\n            \"CMYK\", \"CMYKXX\", 6, (1, 2, 3, 4), (7, 8, 9, 10), (13, 14, 15, 16)\n        )\n        self.assert_unpack(\n            \"CMYK\",\n            \"CMYK;I\",\n            4,\n            (254, 253, 252, 251),\n            (250, 249, 248, 247),\n            (246, 245, 244, 243),\n        )\n        self.assert_unpack(\n            \"CMYK\", \"CMYK;L\", 4, (1, 4, 7, 10), (2, 5, 8, 11), (3, 6, 9, 12)\n        )\n        self.assert_unpack(\"CMYK\", \"C\", 1, (1, 0, 0, 0), (2, 0, 0, 0), (3, 0, 0, 0))\n        self.assert_unpack(\"CMYK\", \"M\", 1, (0, 1, 0, 0), (0, 2, 0, 0), (0, 3, 0, 0))\n        self.assert_unpack(\"CMYK\", \"Y\", 1, (0, 0, 1, 0), (0, 0, 2, 0), (0, 0, 3, 0))\n        self.assert_unpack(\"CMYK\", \"K\", 1, (0, 0, 0, 1), (0, 0, 0, 2), (0, 0, 0, 3))\n        self.assert_unpack(\n            \"CMYK\", \"C;I\", 1, (254, 0, 0, 0), (253, 0, 0, 0), (252, 0, 0, 0)\n        )\n        self.assert_unpack(\n            \"CMYK\", \"M;I\", 1, (0, 254, 0, 0), (0, 253, 0, 0), (0, 252, 0, 0)\n        )\n        self.assert_unpack(\n            \"CMYK\", \"Y;I\", 1, (0, 0, 254, 0), (0, 0, 253, 0), (0, 0, 252, 0)\n        )\n        self.assert_unpack(\n            \"CMYK\", \"K;I\", 1, (0, 0, 0, 254), (0, 0, 0, 253), (0, 0, 0, 252)\n        )\n\n    def test_YCbCr(self) -> None:\n        self.assert_unpack(\"YCbCr\", \"YCbCr\", 3, (1, 2, 3), (4, 5, 6), (7, 8, 9))\n        self.assert_unpack(\"YCbCr\", \"YCbCr;L\", 3, (1, 4, 7), (2, 5, 8), (3, 6, 9))\n        self.assert_unpack(\"YCbCr\", \"YCbCrK\", 4, (1, 2, 3), (5, 6, 7), (9, 10, 11))\n        self.assert_unpack(\"YCbCr\", \"YCbCrX\", 4, (1, 2, 3), (5, 6, 7), (9, 10, 11))\n\n    def test_LAB(self) -> None:\n        self.assert_unpack(\"LAB\", \"LAB\", 3, (1, 130, 131), (4, 133, 134), (7, 136, 137))\n        self.assert_unpack(\"LAB\", \"L\", 1, (1, 0, 0), (2, 0, 0), (3, 0, 0))\n        self.assert_unpack(\"LAB\", \"A\", 1, (0, 1, 0), (0, 2, 0), (0, 3, 0))\n        self.assert_unpack(\"LAB\", \"B\", 1, (0, 0, 1), (0, 0, 2), (0, 0, 3))\n\n    def test_HSV(self) -> None:\n        self.assert_unpack(\"HSV\", \"HSV\", 3, (1, 2, 3), (4, 5, 6), (7, 8, 9))\n        self.assert_unpack(\"HSV\", \"H\", 1, (1, 0, 0), (2, 0, 0), (3, 0, 0))\n        self.assert_unpack(\"HSV\", \"S\", 1, (0, 1, 0), (0, 2, 0), (0, 3, 0))\n        self.assert_unpack(\"HSV\", \"V\", 1, (0, 0, 1), (0, 0, 2), (0, 0, 3))\n\n    def test_I(self) -> None:\n        self.assert_unpack(\"I\", \"I;8\", 1, 0x01, 0x02, 0x03, 0x04)\n        self.assert_unpack(\"I\", \"I;8S\", b\"\\x01\\x83\", 1, -125)\n        self.assert_unpack(\"I\", \"I;16\", 2, 0x0201, 0x0403)\n        self.assert_unpack(\"I\", \"I;16S\", b\"\\x83\\x01\\x01\\x83\", 0x0183, -31999)\n        self.assert_unpack(\"I\", \"I;16B\", 2, 0x0102, 0x0304)\n        self.assert_unpack(\"I\", \"I;16BS\", b\"\\x83\\x01\\x01\\x83\", -31999, 0x0183)\n        self.assert_unpack(\"I\", \"I;32\", 4, 0x04030201, 0x08070605)\n        self.assert_unpack(\n            \"I\", \"I;32S\", b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\", 0x01000083, -2097151999\n        )\n        self.assert_unpack(\"I\", \"I;32B\", 4, 0x01020304, 0x05060708)\n        self.assert_unpack(\n            \"I\", \"I;32BS\", b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\", -2097151999, 0x01000083\n        )\n\n        if sys.byteorder == \"little\":\n            self.assert_unpack(\"I\", \"I\", 4, 0x04030201, 0x08070605)\n            self.assert_unpack(\"I\", \"I;16N\", 2, 0x0201, 0x0403)\n            self.assert_unpack(\"I\", \"I;16NS\", b\"\\x83\\x01\\x01\\x83\", 0x0183, -31999)\n            self.assert_unpack(\"I\", \"I;32N\", 4, 0x04030201, 0x08070605)\n            self.assert_unpack(\n                \"I\",\n                \"I;32NS\",\n                b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\",\n                0x01000083,\n                -2097151999,\n            )\n        else:\n            self.assert_unpack(\"I\", \"I\", 4, 0x01020304, 0x05060708)\n            self.assert_unpack(\"I\", \"I;16N\", 2, 0x0102, 0x0304)\n            self.assert_unpack(\"I\", \"I;16NS\", b\"\\x83\\x01\\x01\\x83\", -31999, 0x0183)\n            self.assert_unpack(\"I\", \"I;32N\", 4, 0x01020304, 0x05060708)\n            self.assert_unpack(\n                \"I\",\n                \"I;32NS\",\n                b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\",\n                -2097151999,\n                0x01000083,\n            )\n\n    def test_F_int(self) -> None:\n        self.assert_unpack(\"F\", \"F;8\", 1, 0x01, 0x02, 0x03, 0x04)\n        self.assert_unpack(\"F\", \"F;8S\", b\"\\x01\\x83\", 1, -125)\n        self.assert_unpack(\"F\", \"F;16\", 2, 0x0201, 0x0403)\n        self.assert_unpack(\"F\", \"F;16S\", b\"\\x83\\x01\\x01\\x83\", 0x0183, -31999)\n        self.assert_unpack(\"F\", \"F;16B\", 2, 0x0102, 0x0304)\n        self.assert_unpack(\"F\", \"F;16BS\", b\"\\x83\\x01\\x01\\x83\", -31999, 0x0183)\n        self.assert_unpack(\"F\", \"F;32\", 4, 67305984, 134678016)\n        self.assert_unpack(\n            \"F\", \"F;32S\", b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\", 16777348, -2097152000\n        )\n        self.assert_unpack(\"F\", \"F;32B\", 4, 0x01020304, 0x05060708)\n        self.assert_unpack(\n            \"F\", \"F;32BS\", b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\", -2097152000, 16777348\n        )\n\n        if sys.byteorder == \"little\":\n            self.assert_unpack(\"F\", \"F;16N\", 2, 0x0201, 0x0403)\n            self.assert_unpack(\"F\", \"F;16NS\", b\"\\x83\\x01\\x01\\x83\", 0x0183, -31999)\n            self.assert_unpack(\"F\", \"F;32N\", 4, 67305984, 134678016)\n            self.assert_unpack(\n                \"F\",\n                \"F;32NS\",\n                b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\",\n                16777348,\n                -2097152000,\n            )\n        else:\n            self.assert_unpack(\"F\", \"F;16N\", 2, 0x0102, 0x0304)\n            self.assert_unpack(\"F\", \"F;16NS\", b\"\\x83\\x01\\x01\\x83\", -31999, 0x0183)\n            self.assert_unpack(\"F\", \"F;32N\", 4, 0x01020304, 0x05060708)\n            self.assert_unpack(\n                \"F\",\n                \"F;32NS\",\n                b\"\\x83\\x00\\x00\\x01\\x01\\x00\\x00\\x83\",\n                -2097152000,\n                16777348,\n            )\n\n    def test_F_float(self) -> None:\n        self.assert_unpack(\n            \"F\", \"F;32F\", 4, 1.539989614439558e-36, 4.063216068939723e-34\n        )\n        self.assert_unpack(\n            \"F\", \"F;32BF\", 4, 2.387939260590663e-38, 6.301941157072183e-36\n        )\n        self.assert_unpack(\n            \"F\",\n            \"F;64F\",\n            b\"333333\\xc3?\\x00\\x00\\x00\\x00\\x00J\\x93\\xc0\",  # by struct.pack\n            0.15000000596046448,\n            -1234.5,\n        )\n        self.assert_unpack(\n            \"F\",\n            \"F;64BF\",\n            b\"?\\xc3333333\\xc0\\x93J\\x00\\x00\\x00\\x00\\x00\",  # by struct.pack\n            0.15000000596046448,\n            -1234.5,\n        )\n\n        if sys.byteorder == \"little\":\n            self.assert_unpack(\n                \"F\", \"F\", 4, 1.539989614439558e-36, 4.063216068939723e-34\n            )\n            self.assert_unpack(\n                \"F\", \"F;32NF\", 4, 1.539989614439558e-36, 4.063216068939723e-34\n            )\n            self.assert_unpack(\n                \"F\",\n                \"F;64NF\",\n                b\"333333\\xc3?\\x00\\x00\\x00\\x00\\x00J\\x93\\xc0\",\n                0.15000000596046448,\n                -1234.5,\n            )\n        else:\n            self.assert_unpack(\n                \"F\", \"F\", 4, 2.387939260590663e-38, 6.301941157072183e-36\n            )\n            self.assert_unpack(\n                \"F\", \"F;32NF\", 4, 2.387939260590663e-38, 6.301941157072183e-36\n            )\n            self.assert_unpack(\n                \"F\",\n                \"F;64NF\",\n                b\"?\\xc3333333\\xc0\\x93J\\x00\\x00\\x00\\x00\\x00\",\n                0.15000000596046448,\n                -1234.5,\n            )\n\n    def test_I16(self) -> None:\n        self.assert_unpack(\"I;16\", \"I;16\", 2, 0x0201, 0x0403, 0x0605)\n        self.assert_unpack(\"I;16\", \"I;16B\", 2, 0x0102, 0x0304, 0x0506)\n        self.assert_unpack(\"I;16B\", \"I;16B\", 2, 0x0102, 0x0304, 0x0506)\n        self.assert_unpack(\"I;16L\", \"I;16L\", 2, 0x0201, 0x0403, 0x0605)\n        self.assert_unpack(\"I;16\", \"I;12\", 2, 0x0010, 0x0203, 0x0040)\n        if sys.byteorder == \"little\":\n            self.assert_unpack(\"I;16\", \"I;16N\", 2, 0x0201, 0x0403, 0x0605)\n            self.assert_unpack(\"I;16B\", \"I;16N\", 2, 0x0201, 0x0403, 0x0605)\n            self.assert_unpack(\"I;16L\", \"I;16N\", 2, 0x0201, 0x0403, 0x0605)\n            self.assert_unpack(\"I;16N\", \"I;16N\", 2, 0x0201, 0x0403, 0x0605)\n        else:\n            self.assert_unpack(\"I;16\", \"I;16N\", 2, 0x0102, 0x0304, 0x0506)\n            self.assert_unpack(\"I;16B\", \"I;16N\", 2, 0x0102, 0x0304, 0x0506)\n            self.assert_unpack(\"I;16L\", \"I;16N\", 2, 0x0102, 0x0304, 0x0506)\n            self.assert_unpack(\"I;16N\", \"I;16N\", 2, 0x0102, 0x0304, 0x0506)\n\n    def test_CMYK16(self) -> None:\n        self.assert_unpack(\"CMYK\", \"CMYK;16L\", 8, (2, 4, 6, 8), (10, 12, 14, 16))\n        self.assert_unpack(\"CMYK\", \"CMYK;16B\", 8, (1, 3, 5, 7), (9, 11, 13, 15))\n        if sys.byteorder == \"little\":\n            self.assert_unpack(\"CMYK\", \"CMYK;16N\", 8, (2, 4, 6, 8), (10, 12, 14, 16))\n        else:\n            self.assert_unpack(\"CMYK\", \"CMYK;16N\", 8, (1, 3, 5, 7), (9, 11, 13, 15))\n\n    def test_value_error(self) -> None:\n        with pytest.raises(ValueError):\n            self.assert_unpack(\"L\", \"L\", 0, 0)\n        with pytest.raises(ValueError):\n            self.assert_unpack(\"RGB\", \"RGB\", 2, 0)\n        with pytest.raises(ValueError):\n            self.assert_unpack(\"CMYK\", \"CMYK\", 2, 0)\n", "Tests/test_file_apng.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImageSequence, PngImagePlugin\n\n\n# APNG browser support tests and fixtures via:\n# https://philip.html5.org/tests/apng/tests.html\n# (referenced from https://wiki.mozilla.org/APNG_Specification)\ndef test_apng_basic() -> None:\n    with Image.open(\"Tests/images/apng/single_frame.png\") as im:\n        assert not im.is_animated\n        assert im.n_frames == 1\n        assert im.get_format_mimetype() == \"image/apng\"\n        assert im.info.get(\"default_image\") is None\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/single_frame_default.png\") as im:\n        assert im.is_animated\n        assert im.n_frames == 2\n        assert im.get_format_mimetype() == \"image/apng\"\n        assert im.info.get(\"default_image\")\n        assert im.getpixel((0, 0)) == (255, 0, 0, 255)\n        assert im.getpixel((64, 32)) == (255, 0, 0, 255)\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n        # test out of bounds seek\n        with pytest.raises(EOFError):\n            im.seek(2)\n\n        # test rewind support\n        im.seek(0)\n        assert im.getpixel((0, 0)) == (255, 0, 0, 255)\n        assert im.getpixel((64, 32)) == (255, 0, 0, 255)\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n\n@pytest.mark.parametrize(\n    \"filename\",\n    (\"Tests/images/apng/split_fdat.png\", \"Tests/images/apng/split_fdat_zero_chunk.png\"),\n)\ndef test_apng_fdat(filename: str) -> None:\n    with Image.open(filename) as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n\ndef test_apng_dispose() -> None:\n    with Image.open(\"Tests/images/apng/dispose_op_none.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/dispose_op_background.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 0, 0, 0)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n    with Image.open(\"Tests/images/apng/dispose_op_background_final.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/dispose_op_previous.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/dispose_op_previous_final.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/dispose_op_previous_first.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 0, 0, 0)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n\ndef test_apng_dispose_region() -> None:\n    with Image.open(\"Tests/images/apng/dispose_op_none_region.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/dispose_op_background_before_region.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 0, 0, 0)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n    with Image.open(\"Tests/images/apng/dispose_op_background_region.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 0, 255, 255)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n    with Image.open(\"Tests/images/apng/dispose_op_previous_region.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n\ndef test_apng_dispose_op_previous_frame() -> None:\n    # Test that the dispose settings being used are from the previous frame\n    #\n    # Image created with:\n    # red = Image.new(\"RGBA\", (128, 64), (255, 0, 0, 255))\n    # green = red.copy()\n    # green.paste(Image.new(\"RGBA\", (64, 32), (0, 255, 0, 255)))\n    # blue = red.copy()\n    # blue.paste(Image.new(\"RGBA\", (64, 32), (0, 255, 0, 255)), (64, 32))\n    #\n    # red.save(\n    #     \"Tests/images/apng/dispose_op_previous_frame.png\",\n    #     save_all=True,\n    #     append_images=[green, blue],\n    #     disposal=[\n    #         PngImagePlugin.Disposal.OP_NONE,\n    #         PngImagePlugin.Disposal.OP_PREVIOUS,\n    #         PngImagePlugin.Disposal.OP_PREVIOUS\n    #     ],\n    # )\n    with Image.open(\"Tests/images/apng/dispose_op_previous_frame.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (255, 0, 0, 255)\n\n\ndef test_apng_dispose_op_background_p_mode() -> None:\n    with Image.open(\"Tests/images/apng/dispose_op_background_p_mode.png\") as im:\n        im.seek(1)\n        im.load()\n        assert im.size == (128, 64)\n\n\ndef test_apng_blend() -> None:\n    with Image.open(\"Tests/images/apng/blend_op_source_solid.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/blend_op_source_transparent.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 0, 0, 0)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n    with Image.open(\"Tests/images/apng/blend_op_source_near_transparent.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 2)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 2)\n\n    with Image.open(\"Tests/images/apng/blend_op_over.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/blend_op_over_near_transparent.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 97)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n\ndef test_apng_blend_transparency() -> None:\n    with Image.open(\"Tests/images/blend_transparency.png\") as im:\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (255, 0, 0)\n\n\ndef test_apng_chunk_order() -> None:\n    with Image.open(\"Tests/images/apng/fctl_actl.png\") as im:\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n\ndef test_apng_delay() -> None:\n    with Image.open(\"Tests/images/apng/delay.png\") as im:\n        im.seek(1)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(2)\n        assert im.info.get(\"duration\") == 1000.0\n        im.seek(3)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(4)\n        assert im.info.get(\"duration\") == 1000.0\n\n    with Image.open(\"Tests/images/apng/delay_round.png\") as im:\n        im.seek(1)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(2)\n        assert im.info.get(\"duration\") == 1000.0\n\n    with Image.open(\"Tests/images/apng/delay_short_max.png\") as im:\n        im.seek(1)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(2)\n        assert im.info.get(\"duration\") == 1000.0\n\n    with Image.open(\"Tests/images/apng/delay_zero_denom.png\") as im:\n        im.seek(1)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(2)\n        assert im.info.get(\"duration\") == 1000.0\n\n    with Image.open(\"Tests/images/apng/delay_zero_numer.png\") as im:\n        im.seek(1)\n        assert im.info.get(\"duration\") == 0.0\n        im.seek(2)\n        assert im.info.get(\"duration\") == 0.0\n        im.seek(3)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(4)\n        assert im.info.get(\"duration\") == 1000.0\n\n\ndef test_apng_num_plays() -> None:\n    with Image.open(\"Tests/images/apng/num_plays.png\") as im:\n        assert im.info.get(\"loop\") == 0\n\n    with Image.open(\"Tests/images/apng/num_plays_1.png\") as im:\n        assert im.info.get(\"loop\") == 1\n\n\ndef test_apng_mode() -> None:\n    with Image.open(\"Tests/images/apng/mode_16bit.png\") as im:\n        assert im.mode == \"RGBA\"\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (0, 0, 128, 191)\n        assert im.getpixel((64, 32)) == (0, 0, 128, 191)\n\n    with Image.open(\"Tests/images/apng/mode_grayscale.png\") as im:\n        assert im.mode == \"L\"\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == 128\n        assert im.getpixel((64, 32)) == 255\n\n    with Image.open(\"Tests/images/apng/mode_grayscale_alpha.png\") as im:\n        assert im.mode == \"LA\"\n        im.seek(im.n_frames - 1)\n        assert im.getpixel((0, 0)) == (128, 191)\n        assert im.getpixel((64, 32)) == (128, 191)\n\n    with Image.open(\"Tests/images/apng/mode_palette.png\") as im:\n        assert im.mode == \"P\"\n        im.seek(im.n_frames - 1)\n        im = im.convert(\"RGB\")\n        assert im.getpixel((0, 0)) == (0, 255, 0)\n        assert im.getpixel((64, 32)) == (0, 255, 0)\n\n    with Image.open(\"Tests/images/apng/mode_palette_alpha.png\") as im:\n        assert im.mode == \"P\"\n        im.seek(im.n_frames - 1)\n        im = im.convert(\"RGBA\")\n        assert im.getpixel((0, 0)) == (255, 0, 0, 0)\n        assert im.getpixel((64, 32)) == (255, 0, 0, 0)\n\n    with Image.open(\"Tests/images/apng/mode_palette_1bit_alpha.png\") as im:\n        assert im.mode == \"P\"\n        im.seek(im.n_frames - 1)\n        im = im.convert(\"RGBA\")\n        assert im.getpixel((0, 0)) == (0, 0, 255, 128)\n        assert im.getpixel((64, 32)) == (0, 0, 255, 128)\n\n\ndef test_apng_chunk_errors() -> None:\n    with Image.open(\"Tests/images/apng/chunk_no_actl.png\") as im:\n        assert not im.is_animated\n\n    with pytest.warns(UserWarning):\n        with Image.open(\"Tests/images/apng/chunk_multi_actl.png\") as im:\n            im.load()\n        assert not im.is_animated\n\n    with Image.open(\"Tests/images/apng/chunk_actl_after_idat.png\") as im:\n        assert not im.is_animated\n\n    with Image.open(\"Tests/images/apng/chunk_no_fctl.png\") as im:\n        with pytest.raises(SyntaxError):\n            im.seek(im.n_frames - 1)\n\n    with Image.open(\"Tests/images/apng/chunk_repeat_fctl.png\") as im:\n        with pytest.raises(SyntaxError):\n            im.seek(im.n_frames - 1)\n\n    with Image.open(\"Tests/images/apng/chunk_no_fdat.png\") as im:\n        with pytest.raises(SyntaxError):\n            im.seek(im.n_frames - 1)\n\n\ndef test_apng_syntax_errors() -> None:\n    with pytest.warns(UserWarning):\n        with Image.open(\"Tests/images/apng/syntax_num_frames_zero.png\") as im:\n            assert not im.is_animated\n            with pytest.raises(OSError):\n                im.load()\n\n    with pytest.warns(UserWarning):\n        with Image.open(\"Tests/images/apng/syntax_num_frames_zero_default.png\") as im:\n            assert not im.is_animated\n            im.load()\n\n    # we can handle this case gracefully\n    exception = None\n    with Image.open(\"Tests/images/apng/syntax_num_frames_low.png\") as im:\n        try:\n            im.seek(im.n_frames - 1)\n        except Exception as e:\n            exception = e\n        assert exception is None\n\n    with pytest.raises(OSError):\n        with Image.open(\"Tests/images/apng/syntax_num_frames_high.png\") as im:\n            im.seek(im.n_frames - 1)\n            im.load()\n\n    with pytest.warns(UserWarning):\n        with Image.open(\"Tests/images/apng/syntax_num_frames_invalid.png\") as im:\n            assert not im.is_animated\n            im.load()\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    (\n        \"sequence_start.png\",\n        \"sequence_gap.png\",\n        \"sequence_repeat.png\",\n        \"sequence_repeat_chunk.png\",\n        \"sequence_reorder.png\",\n        \"sequence_reorder_chunk.png\",\n        \"sequence_fdat_fctl.png\",\n    ),\n)\ndef test_apng_sequence_errors(test_file: str) -> None:\n    with pytest.raises(SyntaxError):\n        with Image.open(f\"Tests/images/apng/{test_file}\") as im:\n            im.seek(im.n_frames - 1)\n            im.load()\n\n\ndef test_apng_save(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/apng/single_frame.png\") as im:\n        test_file = str(tmp_path / \"temp.png\")\n        im.save(test_file, save_all=True)\n\n    with Image.open(test_file) as im:\n        im.load()\n        assert not im.is_animated\n        assert im.n_frames == 1\n        assert im.get_format_mimetype() == \"image/png\"\n        assert im.info.get(\"default_image\") is None\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    with Image.open(\"Tests/images/apng/single_frame_default.png\") as im:\n        frames = [frame_im.copy() for frame_im in ImageSequence.Iterator(im)]\n        frames[0].save(\n            test_file, save_all=True, default_image=True, append_images=frames[1:]\n        )\n\n    with Image.open(test_file) as im:\n        im.load()\n        assert im.is_animated\n        assert im.n_frames == 2\n        assert im.get_format_mimetype() == \"image/apng\"\n        assert im.info.get(\"default_image\")\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n\ndef test_apng_save_alpha(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.png\")\n\n    im = Image.new(\"RGBA\", (1, 1), (255, 0, 0, 255))\n    im2 = Image.new(\"RGBA\", (1, 1), (255, 0, 0, 127))\n    im.save(test_file, save_all=True, append_images=[im2])\n\n    with Image.open(test_file) as reloaded:\n        assert reloaded.getpixel((0, 0)) == (255, 0, 0, 255)\n\n        reloaded.seek(1)\n        assert reloaded.getpixel((0, 0)) == (255, 0, 0, 127)\n\n\ndef test_apng_save_split_fdat(tmp_path: Path) -> None:\n    # test to make sure we do not generate sequence errors when writing\n    # frames with image data spanning multiple fdAT chunks (in this case\n    # both the default image and first animation frame will span multiple\n    # data chunks)\n    test_file = str(tmp_path / \"temp.png\")\n    with Image.open(\"Tests/images/old-style-jpeg-compression.png\") as im:\n        frames = [im.copy(), Image.new(\"RGBA\", im.size, (255, 0, 0, 255))]\n        im.save(\n            test_file,\n            save_all=True,\n            default_image=True,\n            append_images=frames,\n        )\n    with Image.open(test_file) as im:\n        exception = None\n        try:\n            im.seek(im.n_frames - 1)\n            im.load()\n        except Exception as e:\n            exception = e\n        assert exception is None\n\n\ndef test_apng_save_duration_loop(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.png\")\n    with Image.open(\"Tests/images/apng/delay.png\") as im:\n        frames = []\n        durations = []\n        loop = im.info.get(\"loop\")\n        default_image = im.info.get(\"default_image\")\n        for i, frame_im in enumerate(ImageSequence.Iterator(im)):\n            frames.append(frame_im.copy())\n            if i != 0 or not default_image:\n                durations.append(frame_im.info.get(\"duration\", 0))\n        frames[0].save(\n            test_file,\n            save_all=True,\n            default_image=default_image,\n            append_images=frames[1:],\n            duration=durations,\n            loop=loop,\n        )\n\n    with Image.open(test_file) as im:\n        im.load()\n        assert im.info.get(\"loop\") == loop\n        im.seek(1)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(2)\n        assert im.info.get(\"duration\") == 1000.0\n        im.seek(3)\n        assert im.info.get(\"duration\") == 500.0\n        im.seek(4)\n        assert im.info.get(\"duration\") == 1000.0\n\n    # test removal of duplicated frames\n    frame = Image.new(\"RGBA\", (128, 64), (255, 0, 0, 255))\n    frame.save(\n        test_file, save_all=True, append_images=[frame, frame], duration=[500, 100, 150]\n    )\n    with Image.open(test_file) as im:\n        assert im.n_frames == 1\n        assert \"duration\" not in im.info\n\n    different_frame = Image.new(\"RGBA\", (128, 64))\n    frame.save(\n        test_file,\n        save_all=True,\n        append_images=[frame, different_frame],\n        duration=[500, 100, 150],\n    )\n    with Image.open(test_file) as im:\n        assert im.n_frames == 2\n        assert im.info[\"duration\"] == 600\n\n        im.seek(1)\n        assert im.info[\"duration\"] == 150\n\n    # test info duration\n    frame.info[\"duration\"] = 300\n    frame.save(test_file, save_all=True, append_images=[frame, different_frame])\n    with Image.open(test_file) as im:\n        assert im.n_frames == 2\n        assert im.info[\"duration\"] == 600\n\n\ndef test_apng_save_disposal(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.png\")\n    size = (128, 64)\n    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))\n    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))\n    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))\n\n    # test OP_NONE\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[green, transparent],\n        disposal=PngImagePlugin.Disposal.OP_NONE,\n        blend=PngImagePlugin.Blend.OP_OVER,\n    )\n    with Image.open(test_file) as im:\n        im.seek(2)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    # test OP_BACKGROUND\n    disposal = [\n        PngImagePlugin.Disposal.OP_NONE,\n        PngImagePlugin.Disposal.OP_BACKGROUND,\n        PngImagePlugin.Disposal.OP_NONE,\n    ]\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[red, transparent],\n        disposal=disposal,\n        blend=PngImagePlugin.Blend.OP_OVER,\n    )\n    with Image.open(test_file) as im:\n        im.seek(2)\n        assert im.getpixel((0, 0)) == (0, 0, 0, 0)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n    disposal = [\n        PngImagePlugin.Disposal.OP_NONE,\n        PngImagePlugin.Disposal.OP_BACKGROUND,\n    ]\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[green],\n        disposal=disposal,\n        blend=PngImagePlugin.Blend.OP_OVER,\n    )\n    with Image.open(test_file) as im:\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    # test OP_PREVIOUS\n    disposal = [\n        PngImagePlugin.Disposal.OP_NONE,\n        PngImagePlugin.Disposal.OP_PREVIOUS,\n        PngImagePlugin.Disposal.OP_NONE,\n    ]\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[green, red, transparent],\n        default_image=True,\n        disposal=disposal,\n        blend=PngImagePlugin.Blend.OP_OVER,\n    )\n    with Image.open(test_file) as im:\n        im.seek(3)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    disposal = [\n        PngImagePlugin.Disposal.OP_NONE,\n        PngImagePlugin.Disposal.OP_PREVIOUS,\n    ]\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[green],\n        disposal=disposal,\n        blend=PngImagePlugin.Blend.OP_OVER,\n    )\n    with Image.open(test_file) as im:\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    # test info disposal\n    red.info[\"disposal\"] = PngImagePlugin.Disposal.OP_BACKGROUND\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[Image.new(\"RGBA\", (10, 10), (0, 255, 0, 255))],\n    )\n    with Image.open(test_file) as im:\n        im.seek(1)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n\ndef test_apng_save_disposal_previous(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.png\")\n    size = (128, 64)\n    blue = Image.new(\"RGBA\", size, (0, 0, 255, 255))\n    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))\n    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))\n\n    # test OP_NONE\n    blue.save(\n        test_file,\n        save_all=True,\n        append_images=[red, green],\n        disposal=PngImagePlugin.Disposal.OP_PREVIOUS,\n    )\n    with Image.open(test_file) as im:\n        assert im.getpixel((0, 0)) == (0, 0, 255, 255)\n\n        im.seek(2)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n\ndef test_apng_save_blend(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.png\")\n    size = (128, 64)\n    red = Image.new(\"RGBA\", size, (255, 0, 0, 255))\n    green = Image.new(\"RGBA\", size, (0, 255, 0, 255))\n    transparent = Image.new(\"RGBA\", size, (0, 0, 0, 0))\n\n    # test OP_SOURCE on solid color\n    blend = [\n        PngImagePlugin.Blend.OP_OVER,\n        PngImagePlugin.Blend.OP_SOURCE,\n    ]\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[red, green],\n        default_image=True,\n        disposal=PngImagePlugin.Disposal.OP_NONE,\n        blend=blend,\n    )\n    with Image.open(test_file) as im:\n        im.seek(2)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    # test OP_SOURCE on transparent color\n    blend = [\n        PngImagePlugin.Blend.OP_OVER,\n        PngImagePlugin.Blend.OP_SOURCE,\n    ]\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[red, transparent],\n        default_image=True,\n        disposal=PngImagePlugin.Disposal.OP_NONE,\n        blend=blend,\n    )\n    with Image.open(test_file) as im:\n        im.seek(2)\n        assert im.getpixel((0, 0)) == (0, 0, 0, 0)\n        assert im.getpixel((64, 32)) == (0, 0, 0, 0)\n\n    # test OP_OVER\n    red.save(\n        test_file,\n        save_all=True,\n        append_images=[green, transparent],\n        default_image=True,\n        disposal=PngImagePlugin.Disposal.OP_NONE,\n        blend=PngImagePlugin.Blend.OP_OVER,\n    )\n    with Image.open(test_file) as im:\n        im.seek(1)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n        im.seek(2)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n        assert im.getpixel((64, 32)) == (0, 255, 0, 255)\n\n    # test info blend\n    red.info[\"blend\"] = PngImagePlugin.Blend.OP_OVER\n    red.save(test_file, save_all=True, append_images=[green, transparent])\n    with Image.open(test_file) as im:\n        im.seek(2)\n        assert im.getpixel((0, 0)) == (0, 255, 0, 255)\n\n\ndef test_apng_save_size(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.png\")\n\n    im = Image.new(\"L\", (100, 100))\n    im.save(test_file, save_all=True, append_images=[Image.new(\"L\", (200, 200))])\n\n    with Image.open(test_file) as reloaded:\n        assert reloaded.size == (200, 200)\n\n\ndef test_seek_after_close() -> None:\n    im = Image.open(\"Tests/images/apng/delay.png\")\n    im.seek(1)\n    im.close()\n\n    with pytest.raises(ValueError):\n        im.seek(0)\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGBA\", \"RGB\", \"P\"))\n@pytest.mark.parametrize(\"default_image\", (True, False))\n@pytest.mark.parametrize(\"duplicate\", (True, False))\ndef test_different_modes_in_later_frames(\n    mode: str, default_image: bool, duplicate: bool, tmp_path: Path\n) -> None:\n    test_file = str(tmp_path / \"temp.png\")\n\n    im = Image.new(\"L\", (1, 1))\n    im.save(\n        test_file,\n        save_all=True,\n        default_image=default_image,\n        append_images=[im.convert(mode) if duplicate else Image.new(mode, (1, 1), 1)],\n    )\n    with Image.open(test_file) as reloaded:\n        assert reloaded.mode == mode\n\n\ndef test_apng_repeated_seeks_give_correct_info() -> None:\n    with Image.open(\"Tests/images/apng/different_durations.png\") as im:\n        for i in range(3):\n            im.seek(0)\n            assert im.info[\"duration\"] == 4000\n            im.seek(1)\n            assert im.info[\"duration\"] == 1000\n", "Tests/test_imagewin.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import ImageWin\n\nfrom .helper import hopper, is_win32\n\n\nclass TestImageWin:\n    def test_sanity(self) -> None:\n        dir(ImageWin)\n\n    def test_hdc(self) -> None:\n        # Arrange\n        dc = 50\n\n        # Act\n        hdc = ImageWin.HDC(dc)\n        dc2 = int(hdc)\n\n        # Assert\n        assert dc2 == 50\n\n    def test_hwnd(self) -> None:\n        # Arrange\n        wnd = 50\n\n        # Act\n        hwnd = ImageWin.HWND(wnd)\n        wnd2 = int(hwnd)\n\n        # Assert\n        assert wnd2 == 50\n\n\n@pytest.mark.skipif(not is_win32(), reason=\"Windows only\")\nclass TestImageWinDib:\n    def test_dib_image(self) -> None:\n        # Arrange\n        im = hopper()\n\n        # Act\n        dib = ImageWin.Dib(im)\n\n        # Assert\n        assert dib.size == im.size\n\n    def test_dib_mode_string(self) -> None:\n        # Arrange\n        mode = \"RGBA\"\n        size = (128, 128)\n\n        # Act\n        dib = ImageWin.Dib(mode, size)\n\n        # Assert\n        assert dib.size == (128, 128)\n\n    def test_dib_paste(self) -> None:\n        # Arrange\n        im = hopper()\n\n        mode = \"RGBA\"\n        size = (128, 128)\n        dib = ImageWin.Dib(mode, size)\n\n        # Act\n        dib.paste(im)\n\n        # Assert\n        assert dib.size == (128, 128)\n\n    def test_dib_paste_bbox(self) -> None:\n        # Arrange\n        im = hopper()\n        bbox = (0, 0, 10, 10)\n\n        mode = \"RGBA\"\n        size = (128, 128)\n        dib = ImageWin.Dib(mode, size)\n\n        # Act\n        dib.paste(im, bbox)\n\n        # Assert\n        assert dib.size == (128, 128)\n\n    def test_dib_frombytes_tobytes_roundtrip(self) -> None:\n        # Arrange\n        # Make two different DIB images\n        im = hopper()\n        dib1 = ImageWin.Dib(im)\n\n        mode = \"RGB\"\n        size = (128, 128)\n        dib2 = ImageWin.Dib(mode, size)\n\n        # Confirm they're different\n        assert dib1.tobytes() != dib2.tobytes()\n\n        # Act\n        # Make one the same as the using tobytes()/frombytes()\n        test_buffer = dib1.tobytes()\n        for datatype in (\"bytes\", \"memoryview\"):\n            if datatype == \"memoryview\":\n                test_buffer = memoryview(test_buffer)\n            dib2.frombytes(test_buffer)\n\n            # Assert\n            # Confirm they're the same\n            assert dib1.tobytes() == dib2.tobytes()\n", "Tests/check_fli_oob.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nrepro_ss2 = (\n    \"images/fli_oob/06r/06r00.fli\",\n    \"images/fli_oob/06r/others/06r01.fli\",\n    \"images/fli_oob/06r/others/06r02.fli\",\n    \"images/fli_oob/06r/others/06r03.fli\",\n    \"images/fli_oob/06r/others/06r04.fli\",\n)\n\nrepro_lc = (\n    \"images/fli_oob/05r/05r00.fli\",\n    \"images/fli_oob/05r/others/05r03.fli\",\n    \"images/fli_oob/05r/others/05r06.fli\",\n    \"images/fli_oob/05r/others/05r05.fli\",\n    \"images/fli_oob/05r/others/05r01.fli\",\n    \"images/fli_oob/05r/others/05r04.fli\",\n    \"images/fli_oob/05r/others/05r02.fli\",\n    \"images/fli_oob/05r/others/05r07.fli\",\n    \"images/fli_oob/patch0/000000\",\n    \"images/fli_oob/patch0/000001\",\n    \"images/fli_oob/patch0/000002\",\n    \"images/fli_oob/patch0/000003\",\n)\n\n\nrepro_advance = (\n    \"images/fli_oob/03r/03r00.fli\",\n    \"images/fli_oob/03r/others/03r01.fli\",\n    \"images/fli_oob/03r/others/03r09.fli\",\n    \"images/fli_oob/03r/others/03r11.fli\",\n    \"images/fli_oob/03r/others/03r05.fli\",\n    \"images/fli_oob/03r/others/03r10.fli\",\n    \"images/fli_oob/03r/others/03r06.fli\",\n    \"images/fli_oob/03r/others/03r08.fli\",\n    \"images/fli_oob/03r/others/03r03.fli\",\n    \"images/fli_oob/03r/others/03r07.fli\",\n    \"images/fli_oob/03r/others/03r02.fli\",\n    \"images/fli_oob/03r/others/03r04.fli\",\n)\n\nrepro_brun = (\n    \"images/fli_oob/04r/initial.fli\",\n    \"images/fli_oob/04r/others/04r02.fli\",\n    \"images/fli_oob/04r/others/04r05.fli\",\n    \"images/fli_oob/04r/others/04r04.fli\",\n    \"images/fli_oob/04r/others/04r03.fli\",\n    \"images/fli_oob/04r/others/04r01.fli\",\n    \"images/fli_oob/04r/04r00.fli\",\n)\n\nrepro_copy = (\n    \"images/fli_oob/02r/others/02r02.fli\",\n    \"images/fli_oob/02r/others/02r04.fli\",\n    \"images/fli_oob/02r/others/02r03.fli\",\n    \"images/fli_oob/02r/others/02r01.fli\",\n    \"images/fli_oob/02r/02r00.fli\",\n)\n\n\nfor path in repro_ss2 + repro_lc + repro_advance + repro_brun + repro_copy:\n    with Image.open(path) as im:\n        try:\n            im.load()\n        except Exception as msg:\n            print(msg)\n", "Tests/test_mode_i16.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\noriginal = hopper().resize((32, 32)).convert(\"I\")\n\n\ndef verify(im1: Image.Image) -> None:\n    im2 = original.copy()\n    assert im1.size == im2.size\n    pix1 = im1.load()\n    pix2 = im2.load()\n    for y in range(im1.size[1]):\n        for x in range(im1.size[0]):\n            xy = x, y\n            p1 = pix1[xy]\n            p2 = pix2[xy]\n            assert (\n                p1 == p2\n            ), f\"got {repr(p1)} from mode {im1.mode} at {xy}, expected {repr(p2)}\"\n\n\n@pytest.mark.parametrize(\"mode\", (\"L\", \"I;16\", \"I;16B\", \"I;16L\", \"I\"))\ndef test_basic(tmp_path: Path, mode: str) -> None:\n    # PIL 1.1 has limited support for 16-bit image data.  Check that\n    # create/copy/transform and save works as expected.\n\n    im_in = original.convert(mode)\n    verify(im_in)\n\n    w, h = im_in.size\n\n    im_out = im_in.copy()\n    verify(im_out)  # copy\n\n    im_out = im_in.transform((w, h), Image.Transform.EXTENT, (0, 0, w, h))\n    verify(im_out)  # transform\n\n    filename = str(tmp_path / \"temp.im\")\n    im_in.save(filename)\n\n    with Image.open(filename) as im_out:\n        verify(im_in)\n        verify(im_out)\n\n    im_out = im_in.crop((0, 0, w, h))\n    verify(im_out)\n\n    im_out = Image.new(mode, (w, h), None)\n    im_out.paste(im_in.crop((0, 0, w // 2, h)), (0, 0))\n    im_out.paste(im_in.crop((w // 2, 0, w, h)), (w // 2, 0))\n\n    verify(im_in)\n    verify(im_out)\n\n    im_in = Image.new(mode, (1, 1), 1)\n    assert im_in.getpixel((0, 0)) == 1\n\n    im_in.putpixel((0, 0), 2)\n    assert im_in.getpixel((0, 0)) == 2\n\n    if mode == \"L\":\n        maximum = 255\n    else:\n        maximum = 32767\n\n    im_in = Image.new(mode, (1, 1), 256)\n    assert im_in.getpixel((0, 0)) == min(256, maximum)\n\n    im_in.putpixel((0, 0), 512)\n    assert im_in.getpixel((0, 0)) == min(512, maximum)\n\n\ndef test_tobytes() -> None:\n    def tobytes(mode: str) -> bytes:\n        return Image.new(mode, (1, 1), 1).tobytes()\n\n    order = 1 if Image._ENDIAN == \"<\" else -1\n\n    assert tobytes(\"L\") == b\"\\x01\"\n    assert tobytes(\"I;16\") == b\"\\x01\\x00\"\n    assert tobytes(\"I;16B\") == b\"\\x00\\x01\"\n    assert tobytes(\"I\") == b\"\\x01\\x00\\x00\\x00\"[::order]\n\n\ndef test_convert() -> None:\n    im = original.copy()\n\n    for mode in (\"I;16\", \"I;16B\", \"I;16N\"):\n        verify(im.convert(mode))\n        verify(im.convert(mode).convert(\"L\"))\n        verify(im.convert(mode).convert(\"I\"))\n", "Tests/check_large_memory.py": "from __future__ import annotations\n\nimport sys\nfrom pathlib import Path\nfrom types import ModuleType\n\nimport pytest\n\nfrom PIL import Image\n\n# This test is not run automatically.\n#\n# It requires > 2gb memory for the >2 gigapixel image generated in the\n# second test.  Running this automatically would amount to a denial of\n# service on our testing infrastructure.  I expect this test to fail\n# on any 32-bit machine, as well as any smallish things (like\n# Raspberry Pis). It does succeed on a 3gb Ubuntu 12.04x64 VM on Python\n# 2.7 and 3.2.\n\n\nnumpy: ModuleType | None\ntry:\n    import numpy\nexcept ImportError:\n    numpy = None\n\nYDIM = 32769\nXDIM = 48000\n\n\npytestmark = pytest.mark.skipif(sys.maxsize <= 2**32, reason=\"requires 64-bit system\")\n\n\ndef _write_png(tmp_path: Path, xdim: int, ydim: int) -> None:\n    f = str(tmp_path / \"temp.png\")\n    im = Image.new(\"L\", (xdim, ydim), 0)\n    im.save(f)\n\n\ndef test_large(tmp_path: Path) -> None:\n    \"\"\"succeeded prepatch\"\"\"\n    _write_png(tmp_path, XDIM, YDIM)\n\n\ndef test_2gpx(tmp_path: Path) -> None:\n    \"\"\"failed prepatch\"\"\"\n    _write_png(tmp_path, XDIM, XDIM)\n\n\n@pytest.mark.skipif(numpy is None, reason=\"Numpy is not installed\")\ndef test_size_greater_than_int() -> None:\n    assert numpy is not None\n    arr = numpy.ndarray(shape=(16394, 16394))\n    Image.fromarray(arr)\n", "Tests/test_file_mcidas.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, McIdasImagePlugin\n\nfrom .helper import assert_image_equal_tofile\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        McIdasImagePlugin.McIdasImageFile(invalid_file)\n\n\ndef test_valid_file() -> None:\n    # Arrange\n    # https://ghrc.nsstc.nasa.gov/hydro/details/cmx3g8\n    # https://ghrc.nsstc.nasa.gov/pub/fieldCampaigns/camex3/cmx3g8/browse/\n    test_file = \"Tests/images/cmx3g8_wv_1998.260_0745_mcidas.ara\"\n    saved_file = \"Tests/images/cmx3g8_wv_1998.260_0745_mcidas.tiff\"\n\n    # Act\n    with Image.open(test_file) as im:\n        im.load()\n\n        # Assert\n        assert im.format == \"MCIDAS\"\n        assert im.mode == \"I\"\n        assert im.size == (1800, 400)\n        assert_image_equal_tofile(im, saved_file)\n", "Tests/test_file_pixar.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, PixarImagePlugin\n\nfrom .helper import assert_image_similar, hopper\n\nTEST_FILE = \"Tests/images/hopper.pxr\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_FILE) as im:\n        im.load()\n        assert im.mode == \"RGB\"\n        assert im.size == (128, 128)\n        assert im.format == \"PIXAR\"\n        assert im.get_format_mimetype() is None\n\n        im2 = hopper()\n        assert_image_similar(im, im2, 4.8)\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        PixarImagePlugin.PixarImageFile(invalid_file)\n", "Tests/test_file_mic.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImagePalette\n\nfrom .helper import assert_image_similar, hopper, skip_unless_feature\n\nMicImagePlugin = pytest.importorskip(\n    \"PIL.MicImagePlugin\", reason=\"olefile not installed\"\n)\npytestmark = skip_unless_feature(\"libtiff\")\nTEST_FILE = \"Tests/images/hopper.mic\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_FILE) as im:\n        im.load()\n        assert im.mode == \"RGBA\"\n        assert im.size == (128, 128)\n        assert im.format == \"MIC\"\n\n        # Adjust for the gamma of 2.2 encoded into the file\n        lut = ImagePalette.make_gamma_lut(1 / 2.2)\n        im = Image.merge(\"RGBA\", [chan.point(lut) for chan in im.split()])\n\n        im2 = hopper(\"RGBA\")\n        assert_image_similar(im, im2, 10)\n\n\ndef test_n_frames() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert im.n_frames == 1\n\n\ndef test_is_animated() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert not im.is_animated\n\n\ndef test_tell() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert im.tell() == 0\n\n\ndef test_seek() -> None:\n    with Image.open(TEST_FILE) as im:\n        im.seek(0)\n        assert im.tell() == 0\n\n        with pytest.raises(EOFError):\n            im.seek(99)\n        assert im.tell() == 0\n\n\ndef test_close() -> None:\n    with Image.open(TEST_FILE) as im:\n        pass\n    assert im.ole.fp.closed\n\n    im = Image.open(TEST_FILE)\n    im.close()\n    assert im.ole.fp.closed\n\n\ndef test_invalid_file() -> None:\n    # Test an invalid OLE file\n    invalid_file = \"Tests/images/flower.jpg\"\n    with pytest.raises(SyntaxError):\n        MicImagePlugin.MicImageFile(invalid_file)\n\n    # Test a valid OLE file, but not a MIC file\n    ole_file = \"Tests/images/test-ole-file.doc\"\n    with pytest.raises(SyntaxError):\n        MicImagePlugin.MicImageFile(ole_file)\n", "Tests/test_font_bdf.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import BdfFontFile, FontFile\n\nfilename = \"Tests/images/courB08.bdf\"\n\n\ndef test_sanity() -> None:\n    with open(filename, \"rb\") as test_file:\n        font = BdfFontFile.BdfFontFile(test_file)\n\n    assert isinstance(font, FontFile.FontFile)\n    assert len([_f for _f in font.glyph if _f]) == 190\n\n\ndef test_invalid_file() -> None:\n    with open(\"Tests/images/flower.jpg\", \"rb\") as fp:\n        with pytest.raises(SyntaxError):\n            BdfFontFile.BdfFontFile(fp)\n", "Tests/test_main.py": "from __future__ import annotations\n\nimport os\nimport subprocess\nimport sys\n\nimport pytest\n\n\n@pytest.mark.parametrize(\n    \"args, report\",\n    (([\"PIL\"], False), ([\"PIL\", \"--report\"], True), ([\"PIL.report\"], True)),\n)\ndef test_main(args: list[str], report: bool) -> None:\n    args = [sys.executable, \"-m\"] + args\n    out = subprocess.check_output(args).decode(\"utf-8\")\n    lines = out.splitlines()\n    assert lines[0] == \"-\" * 68\n    assert lines[1].startswith(\"Pillow \")\n    assert lines[2].startswith(\"Python \")\n    lines = lines[3:]\n    while lines[0].startswith(\"    \"):\n        lines = lines[1:]\n    assert lines[0] == \"-\" * 68\n    assert lines[1].startswith(\"Python executable is\")\n    lines = lines[2:]\n    if lines[0].startswith(\"Environment Python files loaded from\"):\n        lines = lines[1:]\n    assert lines[0].startswith(\"System Python files loaded from\")\n    assert lines[1] == \"-\" * 68\n    assert lines[2].startswith(\"Python Pillow modules loaded from \")\n    assert lines[3].startswith(\"Binary Pillow modules loaded from \")\n    assert lines[4] == \"-\" * 68\n    jpeg = (\n        os.linesep\n        + \"-\" * 68\n        + os.linesep\n        + \"JPEG image/jpeg\"\n        + os.linesep\n        + \"Extensions: .jfif, .jpe, .jpeg, .jpg\"\n        + os.linesep\n        + \"Features: open, save\"\n        + os.linesep\n        + \"-\" * 68\n        + os.linesep\n    )\n    assert report == (jpeg not in out)\n", "Tests/test_imagewin_pointers.py": "from __future__ import annotations\n\nfrom io import BytesIO\nfrom pathlib import Path\n\nfrom PIL import Image, ImageWin\n\nfrom .helper import hopper, is_win32\n\n# see https://github.com/python-pillow/Pillow/pull/1431#issuecomment-144692652\n\nif is_win32():\n    import ctypes\n    import ctypes.wintypes\n\n    class BITMAPFILEHEADER(ctypes.Structure):\n        _pack_ = 2\n        _fields_ = [\n            (\"bfType\", ctypes.wintypes.WORD),\n            (\"bfSize\", ctypes.wintypes.DWORD),\n            (\"bfReserved1\", ctypes.wintypes.WORD),\n            (\"bfReserved2\", ctypes.wintypes.WORD),\n            (\"bfOffBits\", ctypes.wintypes.DWORD),\n        ]\n\n    class BITMAPINFOHEADER(ctypes.Structure):\n        _pack_ = 2\n        _fields_ = [\n            (\"biSize\", ctypes.wintypes.DWORD),\n            (\"biWidth\", ctypes.wintypes.LONG),\n            (\"biHeight\", ctypes.wintypes.LONG),\n            (\"biPlanes\", ctypes.wintypes.WORD),\n            (\"biBitCount\", ctypes.wintypes.WORD),\n            (\"biCompression\", ctypes.wintypes.DWORD),\n            (\"biSizeImage\", ctypes.wintypes.DWORD),\n            (\"biXPelsPerMeter\", ctypes.wintypes.LONG),\n            (\"biYPelsPerMeter\", ctypes.wintypes.LONG),\n            (\"biClrUsed\", ctypes.wintypes.DWORD),\n            (\"biClrImportant\", ctypes.wintypes.DWORD),\n        ]\n\n    BI_RGB = 0\n    DIB_RGB_COLORS = 0\n\n    memcpy = ctypes.cdll.msvcrt.memcpy\n    memcpy.argtypes = [ctypes.c_void_p, ctypes.c_void_p, ctypes.c_size_t]\n\n    windll = getattr(ctypes, \"windll\")\n    CreateCompatibleDC = windll.gdi32.CreateCompatibleDC\n    CreateCompatibleDC.argtypes = [ctypes.wintypes.HDC]\n    CreateCompatibleDC.restype = ctypes.wintypes.HDC\n\n    DeleteDC = windll.gdi32.DeleteDC\n    DeleteDC.argtypes = [ctypes.wintypes.HDC]\n\n    SelectObject = windll.gdi32.SelectObject\n    SelectObject.argtypes = [ctypes.wintypes.HDC, ctypes.wintypes.HGDIOBJ]\n    SelectObject.restype = ctypes.wintypes.HGDIOBJ\n\n    DeleteObject = windll.gdi32.DeleteObject\n    DeleteObject.argtypes = [ctypes.wintypes.HGDIOBJ]\n\n    CreateDIBSection = windll.gdi32.CreateDIBSection\n    CreateDIBSection.argtypes = [\n        ctypes.wintypes.HDC,\n        ctypes.c_void_p,\n        ctypes.c_uint,\n        ctypes.POINTER(ctypes.c_void_p),\n        ctypes.wintypes.HANDLE,\n        ctypes.wintypes.DWORD,\n    ]\n    CreateDIBSection.restype = ctypes.wintypes.HBITMAP\n\n    def serialize_dib(bi: BITMAPINFOHEADER, pixels: ctypes.c_void_p) -> bytearray:\n        bf = BITMAPFILEHEADER()\n        bf.bfType = 0x4D42\n        bf.bfOffBits = ctypes.sizeof(bf) + bi.biSize\n        bf.bfSize = bf.bfOffBits + bi.biSizeImage\n        bf.bfReserved1 = bf.bfReserved2 = 0\n\n        buf = (ctypes.c_byte * bf.bfSize)()\n        bp = ctypes.addressof(buf)\n        memcpy(bp, ctypes.byref(bf), ctypes.sizeof(bf))\n        memcpy(bp + ctypes.sizeof(bf), ctypes.byref(bi), bi.biSize)\n        memcpy(bp + bf.bfOffBits, pixels, bi.biSizeImage)\n        return bytearray(buf)\n\n    def test_pointer(tmp_path: Path) -> None:\n        im = hopper()\n        (width, height) = im.size\n        opath = str(tmp_path / \"temp.png\")\n        imdib = ImageWin.Dib(im)\n\n        hdr = BITMAPINFOHEADER()\n        hdr.biSize = ctypes.sizeof(hdr)\n        hdr.biWidth = width\n        hdr.biHeight = height\n        hdr.biPlanes = 1\n        hdr.biBitCount = 32\n        hdr.biCompression = BI_RGB\n        hdr.biSizeImage = width * height * 4\n        hdr.biClrUsed = 0\n        hdr.biClrImportant = 0\n\n        hdc = CreateCompatibleDC(None)\n        pixels = ctypes.c_void_p()\n        dib = CreateDIBSection(\n            hdc, ctypes.byref(hdr), DIB_RGB_COLORS, ctypes.byref(pixels), None, 0\n        )\n        SelectObject(hdc, dib)\n\n        imdib.expose(hdc)\n        bitmap = serialize_dib(hdr, pixels)\n        DeleteObject(dib)\n        DeleteDC(hdc)\n\n        with Image.open(BytesIO(bitmap)) as im:\n            im.save(opath)\n", "Tests/test_file_blp.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    hopper,\n)\n\n\ndef test_load_blp1() -> None:\n    with Image.open(\"Tests/images/blp/blp1_jpeg.blp\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/blp/blp1_jpeg.png\")\n\n    with Image.open(\"Tests/images/blp/blp1_jpeg2.blp\") as im:\n        im.load()\n\n\ndef test_load_blp2_raw() -> None:\n    with Image.open(\"Tests/images/blp/blp2_raw.blp\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_raw.png\")\n\n\ndef test_load_blp2_dxt1() -> None:\n    with Image.open(\"Tests/images/blp/blp2_dxt1.blp\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1.png\")\n\n\ndef test_load_blp2_dxt1a() -> None:\n    with Image.open(\"Tests/images/blp/blp2_dxt1a.blp\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/blp/blp2_dxt1a.png\")\n\n\ndef test_save(tmp_path: Path) -> None:\n    f = str(tmp_path / \"temp.blp\")\n\n    for version in (\"BLP1\", \"BLP2\"):\n        im = hopper(\"P\")\n        im.save(f, blp_version=version)\n\n        with Image.open(f) as reloaded:\n            assert_image_equal(im.convert(\"RGB\"), reloaded)\n\n        with Image.open(\"Tests/images/transparent.png\") as im:\n            f = str(tmp_path / \"temp.blp\")\n            im.convert(\"P\").save(f, blp_version=version)\n\n            with Image.open(f) as reloaded:\n                assert_image_similar(im, reloaded, 8)\n\n    im = hopper()\n    with pytest.raises(ValueError):\n        im.save(f)\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\n        \"Tests/images/timeout-060745d3f534ad6e4128c51d336ea5489182c69d.blp\",\n        \"Tests/images/timeout-31c8f86233ea728339c6e586be7af661a09b5b98.blp\",\n        \"Tests/images/timeout-60d8b7c8469d59fc9ffff6b3a3dc0faeae6ea8ee.blp\",\n        \"Tests/images/timeout-8073b430977660cdd48d96f6406ddfd4114e69c7.blp\",\n        \"Tests/images/timeout-bba4f2e026b5786529370e5dfe9a11b1bf991f07.blp\",\n        \"Tests/images/timeout-d6ec061c4afdef39d3edf6da8927240bb07fe9b7.blp\",\n        \"Tests/images/timeout-ef9112a065e7183fa7faa2e18929b03e44ee16bf.blp\",\n    ],\n)\ndef test_crashes(test_file: str) -> None:\n    with open(test_file, \"rb\") as f:\n        with Image.open(f) as im:\n            with pytest.raises(OSError):\n                im.load()\n", "Tests/test_file_mpeg.py": "from __future__ import annotations\n\nfrom io import BytesIO\n\nimport pytest\n\nfrom PIL import Image, MpegImagePlugin\n\n\ndef test_identify() -> None:\n    # Arrange\n    b = BytesIO(b\"\\x00\\x00\\x01\\xb3\\x01\\x00\\x01\")\n\n    # Act\n    with Image.open(b) as im:\n        # Assert\n        assert im.format == \"MPEG\"\n\n        assert im.mode == \"RGB\"\n        assert im.size == (16, 1)\n\n\ndef test_invalid_file() -> None:\n    # Arrange\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        MpegImagePlugin.MpegImageFile(invalid_file)\n\n\ndef test_load() -> None:\n    # Arrange\n    b = BytesIO(b\"\\x00\\x00\\x01\\xb3\\x01\\x00\\x01\")\n\n    with Image.open(b) as im:\n        # Act / Assert: cannot load\n        with pytest.raises(OSError):\n            im.load()\n", "Tests/__init__.py": "", "Tests/test_file_im.py": "from __future__ import annotations\n\nimport filecmp\nimport warnings\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImImagePlugin\n\nfrom .helper import assert_image_equal_tofile, hopper, is_pypy\n\n# sample im\nTEST_IM = \"Tests/images/hopper.im\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_IM) as im:\n        im.load()\n        assert im.mode == \"RGB\"\n        assert im.size == (128, 128)\n        assert im.format == \"IM\"\n\n\ndef test_name_limit(tmp_path: Path) -> None:\n    out = str(tmp_path / (\"name_limit_test\" * 7 + \".im\"))\n    with Image.open(TEST_IM) as im:\n        im.save(out)\n    assert filecmp.cmp(out, \"Tests/images/hopper_long_name.im\")\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    def open() -> None:\n        im = Image.open(TEST_IM)\n        im.load()\n\n    with pytest.warns(ResourceWarning):\n        open()\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        im = Image.open(TEST_IM)\n        im.load()\n        im.close()\n\n\ndef test_context_manager() -> None:\n    with warnings.catch_warnings():\n        with Image.open(TEST_IM) as im:\n            im.load()\n\n\ndef test_tell() -> None:\n    # Arrange\n    with Image.open(TEST_IM) as im:\n        # Act\n        frame = im.tell()\n\n    # Assert\n    assert frame == 0\n\n\ndef test_n_frames() -> None:\n    with Image.open(TEST_IM) as im:\n        assert im.n_frames == 1\n        assert not im.is_animated\n\n\ndef test_eoferror() -> None:\n    with Image.open(TEST_IM) as im:\n        n_frames = im.n_frames\n\n        # Test seeking past the last frame\n        with pytest.raises(EOFError):\n            im.seek(n_frames)\n        assert im.tell() < n_frames\n\n        # Test that seeking to the last frame does not raise an error\n        im.seek(n_frames - 1)\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"P\", \"PA\"))\ndef test_roundtrip(mode: str, tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.im\")\n    im = hopper(mode)\n    im.save(out)\n    assert_image_equal_tofile(im, out)\n\n\ndef test_small_palette(tmp_path: Path) -> None:\n    im = Image.new(\"P\", (1, 1))\n    colors = [0, 1, 2]\n    im.putpalette(colors)\n\n    out = str(tmp_path / \"temp.im\")\n    im.save(out)\n\n    with Image.open(out) as reloaded:\n        assert reloaded.getpalette() == colors + [0] * 765\n\n\ndef test_save_unsupported_mode(tmp_path: Path) -> None:\n    out = str(tmp_path / \"temp.im\")\n    im = hopper(\"HSV\")\n    with pytest.raises(ValueError):\n        im.save(out)\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        ImImagePlugin.ImImageFile(invalid_file)\n\n\ndef test_number() -> None:\n    assert ImImagePlugin.number(\"1.2\") == 1.2\n", "Tests/test_image_putalpha.py": "from __future__ import annotations\n\nfrom PIL import Image\n\n\ndef test_interface() -> None:\n    im = Image.new(\"RGBA\", (1, 1), (1, 2, 3, 0))\n    assert im.getpixel((0, 0)) == (1, 2, 3, 0)\n\n    im = Image.new(\"RGBA\", (1, 1), (1, 2, 3))\n    assert im.getpixel((0, 0)) == (1, 2, 3, 255)\n\n    im.putalpha(Image.new(\"L\", im.size, 4))\n    assert im.getpixel((0, 0)) == (1, 2, 3, 4)\n\n    im.putalpha(5)\n    assert im.getpixel((0, 0)) == (1, 2, 3, 5)\n\n\ndef test_promote() -> None:\n    im = Image.new(\"L\", (1, 1), 1)\n    assert im.getpixel((0, 0)) == 1\n\n    im.putalpha(2)\n    assert im.mode == \"LA\"\n    assert im.getpixel((0, 0)) == (1, 2)\n\n    im = Image.new(\"P\", (1, 1), 1)\n    assert im.getpixel((0, 0)) == 1\n\n    im.putalpha(2)\n    assert im.mode == \"PA\"\n    assert im.getpixel((0, 0)) == (1, 2)\n\n    im = Image.new(\"RGB\", (1, 1), (1, 2, 3))\n    assert im.getpixel((0, 0)) == (1, 2, 3)\n\n    im.putalpha(4)\n    assert im.mode == \"RGBA\"\n    assert im.getpixel((0, 0)) == (1, 2, 3, 4)\n\n\ndef test_readonly() -> None:\n    im = Image.new(\"RGB\", (1, 1), (1, 2, 3))\n    im.readonly = 1\n\n    im.putalpha(4)\n    assert not im.readonly\n    assert im.mode == \"RGBA\"\n    assert im.getpixel((0, 0)) == (1, 2, 3, 4)\n", "Tests/test_file_wmf.py": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import IO\n\nimport pytest\n\nfrom PIL import Image, ImageFile, WmfImagePlugin\n\nfrom .helper import assert_image_similar_tofile, hopper\n\n\ndef test_load_raw() -> None:\n    # Test basic EMF open and rendering\n    with Image.open(\"Tests/images/drawing.emf\") as im:\n        if hasattr(Image.core, \"drawwmf\"):\n            # Currently, support for WMF/EMF is Windows-only\n            im.load()\n            # Compare to reference rendering\n            assert_image_similar_tofile(im, \"Tests/images/drawing_emf_ref.png\", 0)\n\n    # Test basic WMF open and rendering\n    with Image.open(\"Tests/images/drawing.wmf\") as im:\n        if hasattr(Image.core, \"drawwmf\"):\n            # Currently, support for WMF/EMF is Windows-only\n            im.load()\n            # Compare to reference rendering\n            assert_image_similar_tofile(im, \"Tests/images/drawing_wmf_ref.png\", 2.0)\n\n\ndef test_load() -> None:\n    with Image.open(\"Tests/images/drawing.emf\") as im:\n        if hasattr(Image.core, \"drawwmf\"):\n            assert im.load()[0, 0] == (255, 255, 255)\n\n\ndef test_register_handler(tmp_path: Path) -> None:\n    class TestHandler(ImageFile.StubHandler):\n        methodCalled = False\n\n        def load(self, im: ImageFile.StubImageFile) -> Image.Image:\n            return Image.new(\"RGB\", (1, 1))\n\n        def save(self, im: Image.Image, fp: IO[bytes], filename: str) -> None:\n            self.methodCalled = True\n\n    handler = TestHandler()\n    original_handler = WmfImagePlugin._handler\n    WmfImagePlugin.register_handler(handler)\n\n    im = hopper()\n    tmpfile = str(tmp_path / \"temp.wmf\")\n    im.save(tmpfile)\n    assert handler.methodCalled\n\n    # Restore the state before this test\n    WmfImagePlugin.register_handler(original_handler)\n\n\ndef test_load_float_dpi() -> None:\n    with Image.open(\"Tests/images/drawing.emf\") as im:\n        assert im.info[\"dpi\"] == 1423.7668161434979\n\n\ndef test_load_set_dpi() -> None:\n    with Image.open(\"Tests/images/drawing.wmf\") as im:\n        assert im.size == (82, 82)\n\n        if hasattr(Image.core, \"drawwmf\"):\n            im.load(144)\n            assert im.size == (164, 164)\n\n            assert_image_similar_tofile(im, \"Tests/images/drawing_wmf_ref_144.png\", 2.1)\n\n\n@pytest.mark.parametrize(\"ext\", (\".wmf\", \".emf\"))\ndef test_save(ext: str, tmp_path: Path) -> None:\n    im = hopper()\n\n    tmpfile = str(tmp_path / (\"temp\" + ext))\n    with pytest.raises(OSError):\n        im.save(tmpfile)\n", "Tests/test_file_wal.py": "from __future__ import annotations\n\nfrom PIL import WalImageFile\n\nfrom .helper import assert_image_equal_tofile\n\nTEST_FILE = \"Tests/images/hopper.wal\"\n\n\ndef test_open() -> None:\n    with WalImageFile.open(TEST_FILE) as im:\n        assert im.format == \"WAL\"\n        assert im.format_description == \"Quake2 Texture\"\n        assert im.mode == \"P\"\n        assert im.size == (128, 128)\n\n        assert isinstance(im, WalImageFile.WalImageFile)\n\n        assert_image_equal_tofile(im, \"Tests/images/hopper_wal.png\")\n\n\ndef test_load() -> None:\n    with WalImageFile.open(TEST_FILE) as im:\n        assert im.load()[0, 0] == 122\n\n        # Test again now that it has already been loaded once\n        assert im.load()[0, 0] == 122\n", "Tests/test_image_convert.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image, assert_image_equal, assert_image_similar, hopper\n\n\ndef test_sanity() -> None:\n    def convert(im: Image.Image, mode: str) -> None:\n        out = im.convert(mode)\n        assert out.mode == mode\n        assert out.size == im.size\n\n    modes = (\n        \"1\",\n        \"L\",\n        \"LA\",\n        \"P\",\n        \"PA\",\n        \"I\",\n        \"F\",\n        \"RGB\",\n        \"RGBA\",\n        \"RGBX\",\n        \"CMYK\",\n        \"YCbCr\",\n        \"HSV\",\n    )\n\n    for input_mode in modes:\n        im = hopper(input_mode)\n        for output_mode in modes:\n            convert(im, output_mode)\n\n        # Check 0\n        im = Image.new(input_mode, (0, 0))\n        for output_mode in modes:\n            convert(im, output_mode)\n\n\ndef test_unsupported_conversion() -> None:\n    im = hopper()\n    with pytest.raises(ValueError):\n        im.convert(\"INVALID\")\n\n\ndef test_default() -> None:\n    im = hopper(\"P\")\n    assert im.mode == \"P\"\n    converted_im = im.convert()\n    assert_image(converted_im, \"RGB\", im.size)\n    converted_im = im.convert()\n    assert_image(converted_im, \"RGB\", im.size)\n\n    im.info[\"transparency\"] = 0\n    converted_im = im.convert()\n    assert_image(converted_im, \"RGBA\", im.size)\n\n\n# ref https://github.com/python-pillow/Pillow/issues/274\n\n\ndef _test_float_conversion(im: Image.Image) -> None:\n    orig = im.getpixel((5, 5))\n    converted = im.convert(\"F\").getpixel((5, 5))\n    assert orig == converted\n\n\ndef test_8bit() -> None:\n    with Image.open(\"Tests/images/hopper.jpg\") as im:\n        _test_float_conversion(im.convert(\"L\"))\n\n\ndef test_16bit() -> None:\n    with Image.open(\"Tests/images/16bit.cropped.tif\") as im:\n        _test_float_conversion(im)\n\n    for color in (65535, 65536):\n        im = Image.new(\"I\", (1, 1), color)\n        im_i16 = im.convert(\"I;16\")\n        assert im_i16.getpixel((0, 0)) == 65535\n\n\ndef test_16bit_workaround() -> None:\n    with Image.open(\"Tests/images/16bit.cropped.tif\") as im:\n        _test_float_conversion(im.convert(\"I\"))\n\n\ndef test_opaque() -> None:\n    alpha = hopper(\"P\").convert(\"PA\").getchannel(\"A\")\n\n    solid = Image.new(\"L\", (128, 128), 255)\n    assert_image_equal(alpha, solid)\n\n\ndef test_rgba_p() -> None:\n    im = hopper(\"RGBA\")\n    im.putalpha(hopper(\"L\"))\n\n    converted = im.convert(\"P\")\n    comparable = converted.convert(\"RGBA\")\n\n    assert_image_similar(im, comparable, 20)\n\n\ndef test_rgba() -> None:\n    with Image.open(\"Tests/images/transparent.png\") as im:\n        assert im.mode == \"RGBA\"\n\n        assert_image_similar(im.convert(\"RGBa\").convert(\"RGB\"), im.convert(\"RGB\"), 1.5)\n\n\ndef test_trns_p(tmp_path: Path) -> None:\n    im = hopper(\"P\")\n    im.info[\"transparency\"] = 0\n\n    f = str(tmp_path / \"temp.png\")\n\n    im_l = im.convert(\"L\")\n    assert im_l.info[\"transparency\"] == 0\n    im_l.save(f)\n\n    im_rgb = im.convert(\"RGB\")\n    assert im_rgb.info[\"transparency\"] == (0, 0, 0)\n    im_rgb.save(f)\n\n\n# ref https://github.com/python-pillow/Pillow/issues/664\n\n\n@pytest.mark.parametrize(\"mode\", (\"LA\", \"PA\", \"RGBA\"))\ndef test_trns_p_transparency(mode: str) -> None:\n    # Arrange\n    im = hopper(\"P\")\n    im.info[\"transparency\"] = 128\n\n    # Act\n    converted_im = im.convert(mode)\n\n    # Assert\n    assert \"transparency\" not in converted_im.info\n    if mode == \"PA\":\n        assert converted_im.palette is not None\n    else:\n        # https://github.com/python-pillow/Pillow/issues/2702\n        assert converted_im.palette is None\n\n\ndef test_trns_l(tmp_path: Path) -> None:\n    im = hopper(\"L\")\n    im.info[\"transparency\"] = 128\n\n    f = str(tmp_path / \"temp.png\")\n\n    im_la = im.convert(\"LA\")\n    assert \"transparency\" not in im_la.info\n    im_la.save(f)\n\n    im_rgb = im.convert(\"RGB\")\n    assert im_rgb.info[\"transparency\"] == (128, 128, 128)  # undone\n    im_rgb.save(f)\n\n    im_p = im.convert(\"P\")\n    assert \"transparency\" in im_p.info\n    im_p.save(f)\n\n    im_p = im.convert(\"P\", palette=Image.Palette.ADAPTIVE)\n    assert \"transparency\" in im_p.info\n    im_p.save(f)\n\n\ndef test_trns_RGB(tmp_path: Path) -> None:\n    im = hopper(\"RGB\")\n    im.info[\"transparency\"] = im.getpixel((0, 0))\n\n    f = str(tmp_path / \"temp.png\")\n\n    im_l = im.convert(\"L\")\n    assert im_l.info[\"transparency\"] == im_l.getpixel((0, 0))  # undone\n    im_l.save(f)\n\n    im_la = im.convert(\"LA\")\n    assert \"transparency\" not in im_la.info\n    im_la.save(f)\n\n    im_la = im.convert(\"La\")\n    assert \"transparency\" not in im_la.info\n    assert im_la.getpixel((0, 0)) == (0, 0)\n\n    im_p = im.convert(\"P\")\n    assert \"transparency\" in im_p.info\n    im_p.save(f)\n\n    im_rgba = im.convert(\"RGBA\")\n    assert \"transparency\" not in im_rgba.info\n    im_rgba.save(f)\n\n    im_rgba = im.convert(\"RGBa\")\n    assert \"transparency\" not in im_rgba.info\n    assert im_rgba.getpixel((0, 0)) == (0, 0, 0, 0)\n\n    im_p = pytest.warns(UserWarning, im.convert, \"P\", palette=Image.Palette.ADAPTIVE)\n    assert \"transparency\" not in im_p.info\n    im_p.save(f)\n\n    im = Image.new(\"RGB\", (1, 1))\n    im.info[\"transparency\"] = im.getpixel((0, 0))\n    im_p = im.convert(\"P\", palette=Image.Palette.ADAPTIVE)\n    assert im_p.info[\"transparency\"] == im_p.getpixel((0, 0))\n    im_p.save(f)\n\n\n@pytest.mark.parametrize(\"convert_mode\", (\"L\", \"LA\", \"I\"))\ndef test_l_macro_rounding(convert_mode: str) -> None:\n    for mode in (\"P\", \"PA\"):\n        im = Image.new(mode, (1, 1))\n        im.palette.getcolor((0, 1, 2))\n\n        converted_im = im.convert(convert_mode)\n        px = converted_im.load()\n        converted_color = px[0, 0]\n        if convert_mode == \"LA\":\n            converted_color = converted_color[0]\n        assert converted_color == 1\n\n\ndef test_gif_with_rgba_palette_to_p() -> None:\n    # See https://github.com/python-pillow/Pillow/issues/2433\n    with Image.open(\"Tests/images/hopper.gif\") as im:\n        im.info[\"transparency\"] = 255\n        im.load()\n        assert im.palette.mode == \"RGB\"\n        im_p = im.convert(\"P\")\n\n    # Should not raise ValueError: unrecognized raw mode\n    im_p.load()\n\n\ndef test_p_la() -> None:\n    im = hopper(\"RGBA\")\n    alpha = hopper(\"L\")\n    im.putalpha(alpha)\n\n    comparable = im.convert(\"P\").convert(\"LA\").getchannel(\"A\")\n\n    assert_image_similar(alpha, comparable, 5)\n\n\ndef test_p2pa_alpha() -> None:\n    with Image.open(\"Tests/images/tiny.png\") as im:\n        assert im.mode == \"P\"\n\n        im_pa = im.convert(\"PA\")\n    assert im_pa.mode == \"PA\"\n\n    im_a = im_pa.getchannel(\"A\")\n    for x in range(4):\n        alpha = 255 if x > 1 else 0\n        for y in range(4):\n            assert im_a.getpixel((x, y)) == alpha\n\n\ndef test_p2pa_palette() -> None:\n    with Image.open(\"Tests/images/tiny.png\") as im:\n        im_pa = im.convert(\"PA\")\n    assert im_pa.getpalette() == im.getpalette()\n\n\ndef test_matrix_illegal_conversion() -> None:\n    # Arrange\n    im = hopper(\"CMYK\")\n    # fmt: off\n    matrix = (\n        0.412453, 0.357580, 0.180423, 0,\n        0.212671, 0.715160, 0.072169, 0,\n        0.019334, 0.119193, 0.950227, 0)\n    # fmt: on\n    assert im.mode != \"RGB\"\n\n    # Act / Assert\n    with pytest.raises(ValueError):\n        im.convert(mode=\"CMYK\", matrix=matrix)\n\n\ndef test_matrix_wrong_mode() -> None:\n    # Arrange\n    im = hopper(\"L\")\n    # fmt: off\n    matrix = (\n        0.412453, 0.357580, 0.180423, 0,\n        0.212671, 0.715160, 0.072169, 0,\n        0.019334, 0.119193, 0.950227, 0)\n    # fmt: on\n    assert im.mode == \"L\"\n\n    # Act / Assert\n    with pytest.raises(ValueError):\n        im.convert(mode=\"L\", matrix=matrix)\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGB\", \"L\"))\ndef test_matrix_xyz(mode: str) -> None:\n    # Arrange\n    im = hopper(\"RGB\")\n    im.info[\"transparency\"] = (255, 0, 0)\n    # fmt: off\n    matrix = (\n        0.412453, 0.357580, 0.180423, 0,\n        0.212671, 0.715160, 0.072169, 0,\n        0.019334, 0.119193, 0.950227, 0)\n    # fmt: on\n    assert im.mode == \"RGB\"\n\n    # Act\n    # Convert an RGB image to the CIE XYZ colour space\n    converted_im = im.convert(mode=mode, matrix=matrix)\n\n    # Assert\n    assert converted_im.mode == mode\n    assert converted_im.size == im.size\n    with Image.open(\"Tests/images/hopper-XYZ.png\") as target:\n        if converted_im.mode == \"RGB\":\n            assert_image_similar(converted_im, target, 3)\n            assert converted_im.info[\"transparency\"] == (105, 54, 4)\n        else:\n            assert_image_similar(converted_im, target.getchannel(0), 1)\n            assert converted_im.info[\"transparency\"] == 105\n\n\ndef test_matrix_identity() -> None:\n    # Arrange\n    im = hopper(\"RGB\")\n    # fmt: off\n    identity_matrix = (\n        1, 0, 0, 0,\n        0, 1, 0, 0,\n        0, 0, 1, 0)\n    # fmt: on\n    assert im.mode == \"RGB\"\n\n    # Act\n    # Convert with an identity matrix\n    converted_im = im.convert(mode=\"RGB\", matrix=identity_matrix)\n\n    # Assert\n    # No change\n    assert_image_equal(converted_im, im)\n", "Tests/test_file_eps.py": "from __future__ import annotations\n\nimport io\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import EpsImagePlugin, Image, UnidentifiedImageError, features\n\nfrom .helper import (\n    assert_image_similar,\n    assert_image_similar_tofile,\n    hopper,\n    is_win32,\n    mark_if_feature_version,\n    skip_unless_feature,\n)\n\nHAS_GHOSTSCRIPT = EpsImagePlugin.has_ghostscript()\n\n# Our two EPS test files (they are identical except for their bounding boxes)\nFILE1 = \"Tests/images/zero_bb.eps\"\nFILE2 = \"Tests/images/non_zero_bb.eps\"\n\n# Due to palletization, we'll need to convert these to RGB after load\nFILE1_COMPARE = \"Tests/images/zero_bb.png\"\nFILE1_COMPARE_SCALE2 = \"Tests/images/zero_bb_scale2.png\"\n\nFILE2_COMPARE = \"Tests/images/non_zero_bb.png\"\nFILE2_COMPARE_SCALE2 = \"Tests/images/non_zero_bb_scale2.png\"\n\n# EPS test files with binary preview\nFILE3 = \"Tests/images/binary_preview_map.eps\"\n\n# Three unsigned 32bit little-endian values:\n#   0xC6D3D0C5 magic number\n#   byte position of start of postscript section (12)\n#   byte length of postscript section (0)\n# this byte length isn't valid, but we don't read it\nsimple_binary_header = b\"\\xc5\\xd0\\xd3\\xc6\\x0c\\x00\\x00\\x00\\x00\\x00\\x00\\x00\"\n\n# taken from page 8 of the specification\n# https://web.archive.org/web/20220120164601/https://www.adobe.com/content/dam/acom/en/devnet/actionscript/articles/5002.EPSF_Spec.pdf\nsimple_eps_file = (\n    b\"%!PS-Adobe-3.0 EPSF-3.0\",\n    b\"%%BoundingBox: 5 5 105 105\",\n    b\"10 setlinewidth\",\n    b\"10 10 moveto\",\n    b\"0 90 rlineto 90 0 rlineto 0 -90 rlineto closepath\",\n    b\"stroke\",\n)\nsimple_eps_file_with_comments = (\n    simple_eps_file[:1]\n    + (\n        b\"%%Comment1: Some Value\",\n        b\"%%SecondComment: Another Value\",\n    )\n    + simple_eps_file[1:]\n)\nsimple_eps_file_without_version = simple_eps_file[1:]\nsimple_eps_file_without_boundingbox = simple_eps_file[:1] + simple_eps_file[2:]\nsimple_eps_file_with_invalid_boundingbox = (\n    simple_eps_file[:1] + (b\"%%BoundingBox: a b c d\",) + simple_eps_file[2:]\n)\nsimple_eps_file_with_invalid_boundingbox_valid_imagedata = (\n    simple_eps_file_with_invalid_boundingbox + (b\"%ImageData: 100 100 8 3\",)\n)\nsimple_eps_file_with_long_ascii_comment = (\n    simple_eps_file[:2] + (b\"%%Comment: \" + b\"X\" * 300,) + simple_eps_file[2:]\n)\nsimple_eps_file_with_long_binary_data = (\n    simple_eps_file[:2]\n    + (\n        b\"%%BeginBinary: 300\",\n        b\"\\0\" * 300,\n        b\"%%EndBinary\",\n    )\n    + simple_eps_file[2:]\n)\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\n@pytest.mark.parametrize(\n    (\"filename\", \"size\"), ((FILE1, (460, 352)), (FILE2, (360, 252)))\n)\n@pytest.mark.parametrize(\"scale\", (1, 2))\ndef test_sanity(filename: str, size: tuple[int, int], scale: int) -> None:\n    expected_size = tuple(s * scale for s in size)\n    with Image.open(filename) as image:\n        image.load(scale=scale)\n        assert image.mode == \"RGB\"\n        assert image.size == expected_size\n        assert image.format == \"EPS\"\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\ndef test_load() -> None:\n    with Image.open(FILE1) as im:\n        assert im.load()[0, 0] == (255, 255, 255)\n\n        # Test again now that it has already been loaded once\n        assert im.load()[0, 0] == (255, 255, 255)\n\n\ndef test_binary() -> None:\n    if HAS_GHOSTSCRIPT:\n        assert EpsImagePlugin.gs_binary is not None\n    else:\n        assert EpsImagePlugin.gs_binary is False\n\n    if not is_win32():\n        assert EpsImagePlugin.gs_windows_binary is None\n    elif not HAS_GHOSTSCRIPT:\n        assert EpsImagePlugin.gs_windows_binary is False\n    else:\n        assert EpsImagePlugin.gs_windows_binary is not None\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n    with pytest.raises(SyntaxError):\n        EpsImagePlugin.EpsImageFile(invalid_file)\n\n\ndef test_binary_header_only() -> None:\n    data = io.BytesIO(simple_binary_header)\n    with pytest.raises(SyntaxError, match='EPS header missing \"%!PS-Adobe\" comment'):\n        EpsImagePlugin.EpsImageFile(data)\n\n\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\ndef test_missing_version_comment(prefix: bytes) -> None:\n    data = io.BytesIO(prefix + b\"\\n\".join(simple_eps_file_without_version))\n    with pytest.raises(SyntaxError):\n        EpsImagePlugin.EpsImageFile(data)\n\n\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\ndef test_missing_boundingbox_comment(prefix: bytes) -> None:\n    data = io.BytesIO(prefix + b\"\\n\".join(simple_eps_file_without_boundingbox))\n    with pytest.raises(SyntaxError, match='EPS header missing \"%%BoundingBox\" comment'):\n        EpsImagePlugin.EpsImageFile(data)\n\n\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\ndef test_invalid_boundingbox_comment(prefix: bytes) -> None:\n    data = io.BytesIO(prefix + b\"\\n\".join(simple_eps_file_with_invalid_boundingbox))\n    with pytest.raises(OSError, match=\"cannot determine EPS bounding box\"):\n        EpsImagePlugin.EpsImageFile(data)\n\n\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\ndef test_invalid_boundingbox_comment_valid_imagedata_comment(prefix: bytes) -> None:\n    data = io.BytesIO(\n        prefix + b\"\\n\".join(simple_eps_file_with_invalid_boundingbox_valid_imagedata)\n    )\n    with Image.open(data) as img:\n        assert img.mode == \"RGB\"\n        assert img.size == (100, 100)\n        assert img.format == \"EPS\"\n\n\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\ndef test_ascii_comment_too_long(prefix: bytes) -> None:\n    data = io.BytesIO(prefix + b\"\\n\".join(simple_eps_file_with_long_ascii_comment))\n    with pytest.raises(SyntaxError, match=\"not an EPS file\"):\n        EpsImagePlugin.EpsImageFile(data)\n\n\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\ndef test_long_binary_data(prefix: bytes) -> None:\n    data = io.BytesIO(prefix + b\"\\n\".join(simple_eps_file_with_long_binary_data))\n    EpsImagePlugin.EpsImageFile(data)\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\ndef test_load_long_binary_data(prefix: bytes) -> None:\n    data = io.BytesIO(prefix + b\"\\n\".join(simple_eps_file_with_long_binary_data))\n    with Image.open(data) as img:\n        img.load()\n        assert img.mode == \"RGB\"\n        assert img.size == (100, 100)\n        assert img.format == \"EPS\"\n\n\n@mark_if_feature_version(\n    pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n)\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\ndef test_cmyk() -> None:\n    with Image.open(\"Tests/images/pil_sample_cmyk.eps\") as cmyk_image:\n        assert cmyk_image.mode == \"CMYK\"\n        assert cmyk_image.size == (100, 100)\n        assert cmyk_image.format == \"EPS\"\n\n        cmyk_image.load()\n        assert cmyk_image.mode == \"RGB\"\n\n        if features.check(\"jpg\"):\n            assert_image_similar_tofile(\n                cmyk_image, \"Tests/images/pil_sample_rgb.jpg\", 10\n            )\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\ndef test_showpage() -> None:\n    # See https://github.com/python-pillow/Pillow/issues/2615\n    with Image.open(\"Tests/images/reqd_showpage.eps\") as plot_image:\n        with Image.open(\"Tests/images/reqd_showpage.png\") as target:\n            # should not crash/hang\n            plot_image.load()\n            # fonts could be slightly different\n            assert_image_similar(plot_image, target, 6)\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\ndef test_transparency() -> None:\n    with Image.open(\"Tests/images/reqd_showpage.eps\") as plot_image:\n        plot_image.load(transparency=True)\n        assert plot_image.mode == \"RGBA\"\n\n        with Image.open(\"Tests/images/reqd_showpage_transparency.png\") as target:\n            # fonts could be slightly different\n            assert_image_similar(plot_image, target, 6)\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\ndef test_file_object(tmp_path: Path) -> None:\n    # issue 479\n    with Image.open(FILE1) as image1:\n        with open(str(tmp_path / \"temp.eps\"), \"wb\") as fh:\n            image1.save(fh, \"EPS\")\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\ndef test_bytesio_object() -> None:\n    with open(FILE1, \"rb\") as f:\n        img_bytes = io.BytesIO(f.read())\n\n    with Image.open(img_bytes) as img:\n        img.load()\n\n        with Image.open(FILE1_COMPARE) as image1_scale1_compare:\n            image1_scale1_compare = image1_scale1_compare.convert(\"RGB\")\n        image1_scale1_compare.load()\n        assert_image_similar(img, image1_scale1_compare, 5)\n\n\ndef test_1_mode() -> None:\n    with Image.open(\"Tests/images/1.eps\") as im:\n        assert im.mode == \"1\"\n\n\ndef test_image_mode_not_supported(tmp_path: Path) -> None:\n    im = hopper(\"RGBA\")\n    tmpfile = str(tmp_path / \"temp.eps\")\n    with pytest.raises(ValueError):\n        im.save(tmpfile)\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\n@skip_unless_feature(\"zlib\")\ndef test_render_scale1() -> None:\n    # We need png support for these render test\n\n    # Zero bounding box\n    with Image.open(FILE1) as image1_scale1:\n        image1_scale1.load()\n        with Image.open(FILE1_COMPARE) as image1_scale1_compare:\n            image1_scale1_compare = image1_scale1_compare.convert(\"RGB\")\n        image1_scale1_compare.load()\n        assert_image_similar(image1_scale1, image1_scale1_compare, 5)\n\n    # Non-zero bounding box\n    with Image.open(FILE2) as image2_scale1:\n        image2_scale1.load()\n        with Image.open(FILE2_COMPARE) as image2_scale1_compare:\n            image2_scale1_compare = image2_scale1_compare.convert(\"RGB\")\n        image2_scale1_compare.load()\n        assert_image_similar(image2_scale1, image2_scale1_compare, 10)\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\n@skip_unless_feature(\"zlib\")\ndef test_render_scale2() -> None:\n    # We need png support for these render test\n\n    # Zero bounding box\n    with Image.open(FILE1) as image1_scale2:\n        image1_scale2.load(scale=2)\n        with Image.open(FILE1_COMPARE_SCALE2) as image1_scale2_compare:\n            image1_scale2_compare = image1_scale2_compare.convert(\"RGB\")\n        image1_scale2_compare.load()\n        assert_image_similar(image1_scale2, image1_scale2_compare, 5)\n\n    # Non-zero bounding box\n    with Image.open(FILE2) as image2_scale2:\n        image2_scale2.load(scale=2)\n        with Image.open(FILE2_COMPARE_SCALE2) as image2_scale2_compare:\n            image2_scale2_compare = image2_scale2_compare.convert(\"RGB\")\n        image2_scale2_compare.load()\n        assert_image_similar(image2_scale2, image2_scale2_compare, 10)\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\n@pytest.mark.parametrize(\"filename\", (FILE1, FILE2, \"Tests/images/illu10_preview.eps\"))\ndef test_resize(filename: str) -> None:\n    with Image.open(filename) as im:\n        new_size = (100, 100)\n        im = im.resize(new_size)\n        assert im.size == new_size\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\n@pytest.mark.parametrize(\"filename\", (FILE1, FILE2))\ndef test_thumbnail(filename: str) -> None:\n    # Issue #619\n    with Image.open(filename) as im:\n        new_size = (100, 100)\n        im.thumbnail(new_size)\n        assert max(im.size) == max(new_size)\n\n\ndef test_read_binary_preview() -> None:\n    # Issue 302\n    # open image with binary preview\n    with Image.open(FILE3):\n        pass\n\n\ndef test_readline_psfile(tmp_path: Path) -> None:\n    # check all the freaking line endings possible from the spec\n    # test_string = u'something\\r\\nelse\\n\\rbaz\\rbif\\n'\n    line_endings = [\"\\r\\n\", \"\\n\", \"\\n\\r\", \"\\r\"]\n    strings = [\"something\", \"else\", \"baz\", \"bif\"]\n\n    def _test_readline(t: EpsImagePlugin.PSFile, ending: str) -> None:\n        ending = f\"Failure with line ending: {''.join(str(ord(s)) for s in ending)}\"\n        assert t.readline().strip(\"\\r\\n\") == \"something\", ending\n        assert t.readline().strip(\"\\r\\n\") == \"else\", ending\n        assert t.readline().strip(\"\\r\\n\") == \"baz\", ending\n        assert t.readline().strip(\"\\r\\n\") == \"bif\", ending\n\n    def _test_readline_io_psfile(test_string: str, ending: str) -> None:\n        f = io.BytesIO(test_string.encode(\"latin-1\"))\n        with pytest.warns(DeprecationWarning):\n            t = EpsImagePlugin.PSFile(f)\n        _test_readline(t, ending)\n\n    def _test_readline_file_psfile(test_string: str, ending: str) -> None:\n        f = str(tmp_path / \"temp.txt\")\n        with open(f, \"wb\") as w:\n            w.write(test_string.encode(\"latin-1\"))\n\n        with open(f, \"rb\") as r:\n            with pytest.warns(DeprecationWarning):\n                t = EpsImagePlugin.PSFile(r)\n            _test_readline(t, ending)\n\n    for ending in line_endings:\n        s = ending.join(strings)\n        _test_readline_io_psfile(s, ending)\n        _test_readline_file_psfile(s, ending)\n\n\ndef test_psfile_deprecation() -> None:\n    with pytest.warns(DeprecationWarning):\n        EpsImagePlugin.PSFile(None)\n\n\n@pytest.mark.parametrize(\"prefix\", (b\"\", simple_binary_header))\n@pytest.mark.parametrize(\n    \"line_ending\",\n    (b\"\\r\\n\", b\"\\n\", b\"\\n\\r\", b\"\\r\"),\n)\ndef test_readline(prefix: bytes, line_ending: bytes) -> None:\n    simple_file = prefix + line_ending.join(simple_eps_file_with_comments)\n    data = io.BytesIO(simple_file)\n    test_file = EpsImagePlugin.EpsImageFile(data)\n    assert test_file.info[\"Comment1\"] == \"Some Value\"\n    assert test_file.info[\"SecondComment\"] == \"Another Value\"\n    assert test_file.size == (100, 100)\n\n\n@pytest.mark.parametrize(\n    \"filename\",\n    (\n        \"Tests/images/illu10_no_preview.eps\",\n        \"Tests/images/illu10_preview.eps\",\n        \"Tests/images/illuCS6_no_preview.eps\",\n        \"Tests/images/illuCS6_preview.eps\",\n    ),\n)\ndef test_open_eps(filename: str) -> None:\n    # https://github.com/python-pillow/Pillow/issues/1104\n    with Image.open(filename) as img:\n        assert img.mode == \"RGB\"\n\n\n@pytest.mark.skipif(not HAS_GHOSTSCRIPT, reason=\"Ghostscript not available\")\ndef test_emptyline() -> None:\n    # Test file includes an empty line in the header data\n    emptyline_file = \"Tests/images/zero_bb_emptyline.eps\"\n\n    with Image.open(emptyline_file) as image:\n        image.load()\n    assert image.mode == \"RGB\"\n    assert image.size == (460, 352)\n    assert image.format == \"EPS\"\n\n\n@pytest.mark.timeout(timeout=5)\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\"Tests/images/timeout-d675703545fee17acab56e5fec644c19979175de.eps\"],\n)\ndef test_timeout(test_file: str) -> None:\n    with open(test_file, \"rb\") as f:\n        with pytest.raises(UnidentifiedImageError):\n            with Image.open(f):\n                pass\n\n\ndef test_bounding_box_in_trailer() -> None:\n    # Check bounding boxes are parsed in the same way\n    # when specified in the header and the trailer\n    with Image.open(\"Tests/images/zero_bb_trailer.eps\") as trailer_image, Image.open(\n        FILE1\n    ) as header_image:\n        assert trailer_image.size == header_image.size\n\n\ndef test_eof_before_bounding_box() -> None:\n    with pytest.raises(OSError):\n        with Image.open(\"Tests/images/zero_bb_eof_before_boundingbox.eps\"):\n            pass\n\n\ndef test_invalid_data_after_eof() -> None:\n    with open(\"Tests/images/illuCS6_preview.eps\", \"rb\") as f:\n        img_bytes = io.BytesIO(f.read() + b\"\\r\\n%\" + (b\" \" * 255))\n\n    with Image.open(img_bytes) as img:\n        assert img.mode == \"RGB\"\n", "Tests/test_image_getbbox.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\n\ndef test_sanity() -> None:\n    bbox = hopper().getbbox()\n    assert isinstance(bbox, tuple)\n\n\ndef test_bbox() -> None:\n    def check(im: Image.Image, fill_color: int | tuple[int, ...]) -> None:\n        assert im.getbbox() is None\n\n        im.paste(fill_color, (10, 25, 90, 75))\n        assert im.getbbox() == (10, 25, 90, 75)\n\n        im.paste(fill_color, (25, 10, 75, 90))\n        assert im.getbbox() == (10, 10, 90, 90)\n\n        im.paste(fill_color, (-10, -10, 110, 110))\n        assert im.getbbox() == (0, 0, 100, 100)\n\n    # 8-bit mode\n    im = Image.new(\"L\", (100, 100), 0)\n    check(im, 255)\n\n    # 32-bit mode\n    im = Image.new(\"RGB\", (100, 100), 0)\n    check(im, 255)\n\n    for mode in (\"RGBA\", \"RGBa\"):\n        for rgba_color in ((0, 0, 0, 0), (127, 127, 127, 0), (255, 255, 255, 0)):\n            im = Image.new(mode, (100, 100), rgba_color)\n            check(im, (255, 255, 255, 255))\n\n    for mode in (\"La\", \"LA\", \"PA\"):\n        for color in ((0, 0), (127, 0), (255, 0)):\n            im = Image.new(mode, (100, 100), color)\n            check(im, (255, 255))\n\n\n@pytest.mark.parametrize(\"mode\", (\"RGBA\", \"RGBa\", \"La\", \"LA\", \"PA\"))\ndef test_bbox_alpha_only_false(mode: str) -> None:\n    im = Image.new(mode, (100, 100))\n    assert im.getbbox(alpha_only=False) is None\n\n    fill_color = [1] * Image.getmodebands(mode)\n    fill_color[-1] = 0\n    im.paste(tuple(fill_color), (25, 25, 75, 75))\n    assert im.getbbox(alpha_only=False) == (25, 25, 75, 75)\n\n    assert im.getbbox() is None\n", "Tests/test_file_msp.py": "from __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, MspImagePlugin\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, hopper\n\nTEST_FILE = \"Tests/images/hopper.msp\"\nEXTRA_DIR = \"Tests/images/picins\"\nYA_EXTRA_DIR = \"Tests/images/msp\"\n\n\ndef test_sanity(tmp_path: Path) -> None:\n    test_file = str(tmp_path / \"temp.msp\")\n\n    hopper(\"1\").save(test_file)\n\n    with Image.open(test_file) as im:\n        im.load()\n        assert im.mode == \"1\"\n        assert im.size == (128, 128)\n        assert im.format == \"MSP\"\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        MspImagePlugin.MspImageFile(invalid_file)\n\n\ndef test_bad_checksum() -> None:\n    # Arrange\n    # This was created by forcing Pillow to save with checksum=0\n    bad_checksum = \"Tests/images/hopper_bad_checksum.msp\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        MspImagePlugin.MspImageFile(bad_checksum)\n\n\ndef test_open_windows_v1() -> None:\n    # Arrange\n    # Act\n    with Image.open(TEST_FILE) as im:\n        # Assert\n        assert_image_equal(im, hopper(\"1\"))\n        assert isinstance(im, MspImagePlugin.MspImageFile)\n\n\ndef _assert_file_image_equal(source_path: str, target_path: str) -> None:\n    with Image.open(source_path) as im:\n        assert_image_equal_tofile(im, target_path)\n\n\n@pytest.mark.skipif(\n    not os.path.exists(EXTRA_DIR), reason=\"Extra image files not installed\"\n)\ndef test_open_windows_v2() -> None:\n    files = (\n        os.path.join(EXTRA_DIR, f)\n        for f in os.listdir(EXTRA_DIR)\n        if os.path.splitext(f)[1] == \".msp\"\n    )\n    for path in files:\n        _assert_file_image_equal(path, path.replace(\".msp\", \".png\"))\n\n\n@pytest.mark.skipif(\n    not os.path.exists(YA_EXTRA_DIR), reason=\"Even More Extra image files not installed\"\n)\ndef test_msp_v2() -> None:\n    for f in os.listdir(YA_EXTRA_DIR):\n        if \".MSP\" not in f:\n            continue\n        path = os.path.join(YA_EXTRA_DIR, f)\n        _assert_file_image_equal(path, path.replace(\".MSP\", \".png\"))\n\n\ndef test_cannot_save_wrong_mode(tmp_path: Path) -> None:\n    # Arrange\n    im = hopper()\n    filename = str(tmp_path / \"temp.msp\")\n\n    # Act/Assert\n    with pytest.raises(OSError):\n        im.save(filename)\n", "Tests/test_format_hsv.py": "from __future__ import annotations\n\nimport colorsys\nimport itertools\nfrom typing import Callable\n\nfrom PIL import Image\n\nfrom .helper import assert_image_similar, hopper\n\n\ndef int_to_float(i: int) -> float:\n    return i / 255\n\n\ndef tuple_to_ints(tp: tuple[float, float, float]) -> tuple[int, int, int]:\n    x, y, z = tp\n    return int(x * 255.0), int(y * 255.0), int(z * 255.0)\n\n\ndef test_sanity() -> None:\n    Image.new(\"HSV\", (100, 100))\n\n\ndef wedge() -> Image.Image:\n    w = Image._wedge()\n    w90 = w.rotate(90)\n\n    (px, h) = w.size\n\n    r = Image.new(\"L\", (px * 3, h))\n    g = r.copy()\n    b = r.copy()\n\n    r.paste(w, (0, 0))\n    r.paste(w90, (px, 0))\n\n    g.paste(w90, (0, 0))\n    g.paste(w, (2 * px, 0))\n\n    b.paste(w, (px, 0))\n    b.paste(w90, (2 * px, 0))\n\n    img = Image.merge(\"RGB\", (r, g, b))\n\n    return img\n\n\ndef to_xxx_colorsys(\n    im: Image.Image,\n    func: Callable[[float, float, float], tuple[float, float, float]],\n    mode: str,\n) -> Image.Image:\n    # convert the hard way using the library colorsys routines.\n\n    (r, g, b) = im.split()\n\n    conv_func = int_to_float\n\n    converted = [\n        tuple_to_ints(func(conv_func(_r), conv_func(_g), conv_func(_b)))\n        for (_r, _g, _b) in itertools.zip_longest(r.tobytes(), g.tobytes(), b.tobytes())\n    ]\n\n    new_bytes = b\"\".join(\n        bytes(chr(h) + chr(s) + chr(v), \"latin-1\") for (h, s, v) in converted\n    )\n\n    hsv = Image.frombytes(mode, r.size, new_bytes)\n\n    return hsv\n\n\ndef to_hsv_colorsys(im: Image.Image) -> Image.Image:\n    return to_xxx_colorsys(im, colorsys.rgb_to_hsv, \"HSV\")\n\n\ndef to_rgb_colorsys(im: Image.Image) -> Image.Image:\n    return to_xxx_colorsys(im, colorsys.hsv_to_rgb, \"RGB\")\n\n\ndef test_wedge() -> None:\n    src = wedge().resize((3 * 32, 32), Image.Resampling.BILINEAR)\n    im = src.convert(\"HSV\")\n    comparable = to_hsv_colorsys(src)\n\n    assert_image_similar(\n        im.getchannel(0), comparable.getchannel(0), 1, \"Hue conversion is wrong\"\n    )\n    assert_image_similar(\n        im.getchannel(1),\n        comparable.getchannel(1),\n        1,\n        \"Saturation conversion is wrong\",\n    )\n    assert_image_similar(\n        im.getchannel(2), comparable.getchannel(2), 1, \"Value conversion is wrong\"\n    )\n\n    comparable = src\n    im = im.convert(\"RGB\")\n\n    assert_image_similar(\n        im.getchannel(0), comparable.getchannel(0), 3, \"R conversion is wrong\"\n    )\n    assert_image_similar(\n        im.getchannel(1), comparable.getchannel(1), 3, \"G conversion is wrong\"\n    )\n    assert_image_similar(\n        im.getchannel(2), comparable.getchannel(2), 3, \"B conversion is wrong\"\n    )\n\n\ndef test_convert() -> None:\n    im = hopper(\"RGB\").convert(\"HSV\")\n    comparable = to_hsv_colorsys(hopper(\"RGB\"))\n\n    assert_image_similar(\n        im.getchannel(0), comparable.getchannel(0), 1, \"Hue conversion is wrong\"\n    )\n    assert_image_similar(\n        im.getchannel(1),\n        comparable.getchannel(1),\n        1,\n        \"Saturation conversion is wrong\",\n    )\n    assert_image_similar(\n        im.getchannel(2), comparable.getchannel(2), 1, \"Value conversion is wrong\"\n    )\n\n\ndef test_hsv_to_rgb() -> None:\n    comparable = to_hsv_colorsys(hopper(\"RGB\"))\n    converted = comparable.convert(\"RGB\")\n    comparable = to_rgb_colorsys(comparable)\n\n    assert_image_similar(\n        converted.getchannel(0),\n        comparable.getchannel(0),\n        3,\n        \"R conversion is wrong\",\n    )\n    assert_image_similar(\n        converted.getchannel(1),\n        comparable.getchannel(1),\n        3,\n        \"G conversion is wrong\",\n    )\n    assert_image_similar(\n        converted.getchannel(2),\n        comparable.getchannel(2),\n        3,\n        \"B conversion is wrong\",\n    )\n", "Tests/test_imagemath_unsafe_eval.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageMath\n\n\ndef pixel(im: Image.Image | int) -> str | int:\n    if isinstance(im, int):\n        return int(im)  # hack to deal with booleans\n\n    return f\"{im.mode} {repr(im.getpixel((0, 0)))}\"\n\n\nA = Image.new(\"L\", (1, 1), 1)\nB = Image.new(\"L\", (1, 1), 2)\nZ = Image.new(\"L\", (1, 1), 0)  # Z for zero\nF = Image.new(\"F\", (1, 1), 3)\nI = Image.new(\"I\", (1, 1), 4)  # noqa: E741\n\nA2 = A.resize((2, 2))\nB2 = B.resize((2, 2))\n\nimages = {\"A\": A, \"B\": B, \"F\": F, \"I\": I}\n\n\ndef test_sanity() -> None:\n    assert ImageMath.unsafe_eval(\"1\") == 1\n    assert ImageMath.unsafe_eval(\"1+A\", A=2) == 3\n    assert pixel(ImageMath.unsafe_eval(\"A+B\", A=A, B=B)) == \"I 3\"\n    assert pixel(ImageMath.unsafe_eval(\"A+B\", images)) == \"I 3\"\n    assert pixel(ImageMath.unsafe_eval(\"float(A)+B\", images)) == \"F 3.0\"\n    assert pixel(ImageMath.unsafe_eval(\"int(float(A)+B)\", images)) == \"I 3\"\n\n\ndef test_eval_deprecated() -> None:\n    with pytest.warns(DeprecationWarning):\n        assert ImageMath.eval(\"1\") == 1\n\n\ndef test_ops() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"-A\", images)) == \"I -1\"\n    assert pixel(ImageMath.unsafe_eval(\"+B\", images)) == \"L 2\"\n\n    assert pixel(ImageMath.unsafe_eval(\"A+B\", images)) == \"I 3\"\n    assert pixel(ImageMath.unsafe_eval(\"A-B\", images)) == \"I -1\"\n    assert pixel(ImageMath.unsafe_eval(\"A*B\", images)) == \"I 2\"\n    assert pixel(ImageMath.unsafe_eval(\"A/B\", images)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B**2\", images)) == \"I 4\"\n    assert pixel(ImageMath.unsafe_eval(\"B**33\", images)) == \"I 2147483647\"\n\n    assert pixel(ImageMath.unsafe_eval(\"float(A)+B\", images)) == \"F 3.0\"\n    assert pixel(ImageMath.unsafe_eval(\"float(A)-B\", images)) == \"F -1.0\"\n    assert pixel(ImageMath.unsafe_eval(\"float(A)*B\", images)) == \"F 2.0\"\n    assert pixel(ImageMath.unsafe_eval(\"float(A)/B\", images)) == \"F 0.5\"\n    assert pixel(ImageMath.unsafe_eval(\"float(B)**2\", images)) == \"F 4.0\"\n    assert pixel(ImageMath.unsafe_eval(\"float(B)**33\", images)) == \"F 8589934592.0\"\n\n\n@pytest.mark.parametrize(\n    \"expression\",\n    (\n        \"exec('pass')\",\n        \"(lambda: exec('pass'))()\",\n        \"(lambda: (lambda: exec('pass'))())()\",\n    ),\n)\ndef test_prevent_exec(expression: str) -> None:\n    with pytest.raises(ValueError):\n        ImageMath.unsafe_eval(expression)\n\n\ndef test_prevent_double_underscores() -> None:\n    with pytest.raises(ValueError):\n        ImageMath.unsafe_eval(\"1\", {\"__\": None})\n\n\ndef test_prevent_builtins() -> None:\n    with pytest.raises(ValueError):\n        ImageMath.unsafe_eval(\"(lambda: exec('exit()'))()\", {\"exec\": None})\n\n\ndef test_logical() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"not A\", images)) == 0\n    assert pixel(ImageMath.unsafe_eval(\"A and B\", images)) == \"L 2\"\n    assert pixel(ImageMath.unsafe_eval(\"A or B\", images)) == \"L 1\"\n\n\ndef test_convert() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"convert(A+B, 'L')\", images)) == \"L 3\"\n    assert pixel(ImageMath.unsafe_eval(\"convert(A+B, '1')\", images)) == \"1 0\"\n    assert (\n        pixel(ImageMath.unsafe_eval(\"convert(A+B, 'RGB')\", images)) == \"RGB (3, 3, 3)\"\n    )\n\n\ndef test_compare() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"min(A, B)\", images)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"max(A, B)\", images)) == \"I 2\"\n    assert pixel(ImageMath.unsafe_eval(\"A == 1\", images)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A == 2\", images)) == \"I 0\"\n\n\ndef test_one_image_larger() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A+B\", A=A2, B=B)) == \"I 3\"\n    assert pixel(ImageMath.unsafe_eval(\"A+B\", A=A, B=B2)) == \"I 3\"\n\n\ndef test_abs() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"abs(A)\", A=A)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"abs(B)\", B=B)) == \"I 2\"\n\n\ndef test_binary_mod() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A%A\", A=A)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B%B\", B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A%B\", A=A, B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"B%A\", A=A, B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"Z%A\", A=A, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"Z%B\", B=B, Z=Z)) == \"I 0\"\n\n\ndef test_bitwise_invert() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"~Z\", Z=Z)) == \"I -1\"\n    assert pixel(ImageMath.unsafe_eval(\"~A\", A=A)) == \"I -2\"\n    assert pixel(ImageMath.unsafe_eval(\"~B\", B=B)) == \"I -3\"\n\n\ndef test_bitwise_and() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"Z&Z\", A=A, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"Z&A\", A=A, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A&Z\", A=A, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A&A\", A=A, Z=Z)) == \"I 1\"\n\n\ndef test_bitwise_or() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"Z|Z\", A=A, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"Z|A\", A=A, Z=Z)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A|Z\", A=A, Z=Z)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A|A\", A=A, Z=Z)) == \"I 1\"\n\n\ndef test_bitwise_xor() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"Z^Z\", A=A, Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"Z^A\", A=A, Z=Z)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A^Z\", A=A, Z=Z)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A^A\", A=A, Z=Z)) == \"I 0\"\n\n\ndef test_bitwise_leftshift() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"Z<<0\", Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"Z<<1\", Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A<<0\", A=A)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A<<1\", A=A)) == \"I 2\"\n\n\ndef test_bitwise_rightshift() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"Z>>0\", Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"Z>>1\", Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A>>0\", A=A)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A>>1\", A=A)) == \"I 0\"\n\n\ndef test_logical_eq() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A==A\", A=A)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"B==B\", B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A==B\", A=A, B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B==A\", A=A, B=B)) == \"I 0\"\n\n\ndef test_logical_ne() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A!=A\", A=A)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B!=B\", B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A!=B\", A=A, B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"B!=A\", A=A, B=B)) == \"I 1\"\n\n\ndef test_logical_lt() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A<A\", A=A)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B<B\", B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A<B\", A=A, B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"B<A\", A=A, B=B)) == \"I 0\"\n\n\ndef test_logical_le() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A<=A\", A=A)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"B<=B\", B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A<=B\", A=A, B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"B<=A\", A=A, B=B)) == \"I 0\"\n\n\ndef test_logical_gt() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A>A\", A=A)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B>B\", B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"A>B\", A=A, B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B>A\", A=A, B=B)) == \"I 1\"\n\n\ndef test_logical_ge() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"A>=A\", A=A)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"B>=B\", B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"A>=B\", A=A, B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"B>=A\", A=A, B=B)) == \"I 1\"\n\n\ndef test_logical_equal() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"equal(A, A)\", A=A)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"equal(B, B)\", B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"equal(Z, Z)\", Z=Z)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"equal(A, B)\", A=A, B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"equal(B, A)\", A=A, B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"equal(A, Z)\", A=A, Z=Z)) == \"I 0\"\n\n\ndef test_logical_not_equal() -> None:\n    assert pixel(ImageMath.unsafe_eval(\"notequal(A, A)\", A=A)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"notequal(B, B)\", B=B)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"notequal(Z, Z)\", Z=Z)) == \"I 0\"\n    assert pixel(ImageMath.unsafe_eval(\"notequal(A, B)\", A=A, B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"notequal(B, A)\", A=A, B=B)) == \"I 1\"\n    assert pixel(ImageMath.unsafe_eval(\"notequal(A, Z)\", A=A, Z=Z)) == \"I 1\"\n", "Tests/test_image_split.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, features\n\nfrom .helper import assert_image_equal, hopper\n\n\ndef test_split() -> None:\n    def split(mode: str) -> list[tuple[str, int, int]]:\n        layers = hopper(mode).split()\n        return [(i.mode, i.size[0], i.size[1]) for i in layers]\n\n    assert split(\"1\") == [(\"1\", 128, 128)]\n    assert split(\"L\") == [(\"L\", 128, 128)]\n    assert split(\"I\") == [(\"I\", 128, 128)]\n    assert split(\"F\") == [(\"F\", 128, 128)]\n    assert split(\"P\") == [(\"P\", 128, 128)]\n    assert split(\"RGB\") == [(\"L\", 128, 128), (\"L\", 128, 128), (\"L\", 128, 128)]\n    assert split(\"RGBA\") == [\n        (\"L\", 128, 128),\n        (\"L\", 128, 128),\n        (\"L\", 128, 128),\n        (\"L\", 128, 128),\n    ]\n    assert split(\"CMYK\") == [\n        (\"L\", 128, 128),\n        (\"L\", 128, 128),\n        (\"L\", 128, 128),\n        (\"L\", 128, 128),\n    ]\n    assert split(\"YCbCr\") == [(\"L\", 128, 128), (\"L\", 128, 128), (\"L\", 128, 128)]\n\n\n@pytest.mark.parametrize(\n    \"mode\", (\"1\", \"L\", \"I\", \"F\", \"P\", \"RGB\", \"RGBA\", \"CMYK\", \"YCbCr\")\n)\ndef test_split_merge(mode: str) -> None:\n    expected = Image.merge(mode, hopper(mode).split())\n    assert_image_equal(hopper(mode), expected)\n\n\ndef test_split_open(tmp_path: Path) -> None:\n    if features.check(\"zlib\"):\n        test_file = str(tmp_path / \"temp.png\")\n    else:\n        test_file = str(tmp_path / \"temp.pcx\")\n\n    def split_open(mode: str) -> int:\n        hopper(mode).save(test_file)\n        with Image.open(test_file) as im:\n            return len(im.split())\n\n    assert split_open(\"1\") == 1\n    assert split_open(\"L\") == 1\n    assert split_open(\"P\") == 1\n    assert split_open(\"RGB\") == 3\n    if features.check(\"zlib\"):\n        assert split_open(\"RGBA\") == 4\n", "Tests/test_file_gbr.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import GbrImagePlugin, Image\n\nfrom .helper import assert_image_equal_tofile\n\n\ndef test_gbr_file() -> None:\n    with Image.open(\"Tests/images/gbr.gbr\") as im:\n        assert_image_equal_tofile(im, \"Tests/images/gbr.png\")\n\n\ndef test_load() -> None:\n    with Image.open(\"Tests/images/gbr.gbr\") as im:\n        assert im.load()[0, 0] == (0, 0, 0, 0)\n\n        # Test again now that it has already been loaded once\n        assert im.load()[0, 0] == (0, 0, 0, 0)\n\n\ndef test_multiple_load_operations() -> None:\n    with Image.open(\"Tests/images/gbr.gbr\") as im:\n        im.load()\n        im.load()\n        assert_image_equal_tofile(im, \"Tests/images/gbr.png\")\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        GbrImagePlugin.GbrImageFile(invalid_file)\n", "Tests/test_file_fli.py": "from __future__ import annotations\n\nimport warnings\n\nimport pytest\n\nfrom PIL import FliImagePlugin, Image, ImageFile\n\nfrom .helper import assert_image_equal, assert_image_equal_tofile, is_pypy\n\n# created as an export of a palette image from Gimp2.6\n# save as...-> hopper.fli, default options.\nstatic_test_file = \"Tests/images/hopper.fli\"\n\n# From https://samples.ffmpeg.org/fli-flc/\nanimated_test_file = \"Tests/images/a.fli\"\n\n# From https://samples.ffmpeg.org/fli-flc/\nanimated_test_file_with_prefix_chunk = \"Tests/images/2422.flc\"\n\n\ndef test_sanity() -> None:\n    with Image.open(static_test_file) as im:\n        im.load()\n        assert im.mode == \"P\"\n        assert im.size == (128, 128)\n        assert im.format == \"FLI\"\n        assert not im.is_animated\n\n    with Image.open(animated_test_file) as im:\n        assert im.mode == \"P\"\n        assert im.size == (320, 200)\n        assert im.format == \"FLI\"\n        assert im.info[\"duration\"] == 71\n        assert im.is_animated\n\n\ndef test_prefix_chunk() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = True\n    try:\n        with Image.open(animated_test_file_with_prefix_chunk) as im:\n            assert im.mode == \"P\"\n            assert im.size == (320, 200)\n            assert im.format == \"FLI\"\n            assert im.info[\"duration\"] == 171\n            assert im.is_animated\n\n            palette = im.getpalette()\n            assert palette[3:6] == [255, 255, 255]\n            assert palette[381:384] == [204, 204, 12]\n            assert palette[765:] == [252, 0, 0]\n    finally:\n        ImageFile.LOAD_TRUNCATED_IMAGES = False\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    def open() -> None:\n        im = Image.open(static_test_file)\n        im.load()\n\n    with pytest.warns(ResourceWarning):\n        open()\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        im = Image.open(static_test_file)\n        im.load()\n        im.close()\n\n\ndef test_seek_after_close() -> None:\n    im = Image.open(animated_test_file)\n    im.seek(1)\n    im.close()\n\n    with pytest.raises(ValueError):\n        im.seek(0)\n\n\ndef test_context_manager() -> None:\n    with warnings.catch_warnings():\n        with Image.open(static_test_file) as im:\n            im.load()\n\n\ndef test_tell() -> None:\n    # Arrange\n    with Image.open(static_test_file) as im:\n        # Act\n        frame = im.tell()\n\n        # Assert\n        assert frame == 0\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    with pytest.raises(SyntaxError):\n        FliImagePlugin.FliImageFile(invalid_file)\n\n\ndef test_palette_chunk_second() -> None:\n    with Image.open(\"Tests/images/hopper_palette_chunk_second.fli\") as im:\n        with Image.open(static_test_file) as expected:\n            assert_image_equal(im.convert(\"RGB\"), expected.convert(\"RGB\"))\n\n\ndef test_n_frames() -> None:\n    with Image.open(static_test_file) as im:\n        assert im.n_frames == 1\n        assert not im.is_animated\n\n    with Image.open(animated_test_file) as im:\n        assert im.n_frames == 384\n        assert im.is_animated\n\n\ndef test_eoferror() -> None:\n    with Image.open(animated_test_file) as im:\n        n_frames = im.n_frames\n\n        # Test seeking past the last frame\n        with pytest.raises(EOFError):\n            im.seek(n_frames)\n        assert im.tell() < n_frames\n\n        # Test that seeking to the last frame does not raise an error\n        im.seek(n_frames - 1)\n\n\ndef test_seek_tell() -> None:\n    with Image.open(animated_test_file) as im:\n        layer_number = im.tell()\n        assert layer_number == 0\n\n        im.seek(0)\n        layer_number = im.tell()\n        assert layer_number == 0\n\n        im.seek(1)\n        layer_number = im.tell()\n        assert layer_number == 1\n\n        im.seek(2)\n        layer_number = im.tell()\n        assert layer_number == 2\n\n        im.seek(1)\n        layer_number = im.tell()\n        assert layer_number == 1\n\n\ndef test_seek() -> None:\n    with Image.open(animated_test_file) as im:\n        im.seek(50)\n\n        assert_image_equal_tofile(im, \"Tests/images/a_fli.png\")\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\n        \"Tests/images/timeout-9139147ce93e20eb14088fe238e541443ffd64b3.fli\",\n        \"Tests/images/timeout-bff0a9dc7243a8e6ede2408d2ffa6a9964698b87.fli\",\n    ],\n)\n@pytest.mark.timeout(timeout=3)\ndef test_timeouts(test_file: str) -> None:\n    with open(test_file, \"rb\") as f:\n        with Image.open(f) as im:\n            with pytest.raises(OSError):\n                im.load()\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\n        \"Tests/images/crash-5762152299364352.fli\",\n    ],\n)\ndef test_crash(test_file: str) -> None:\n    with open(test_file, \"rb\") as f:\n        with Image.open(f) as im:\n            with pytest.raises(OSError):\n                im.load()\n", "Tests/test_file_ppm.py": "from __future__ import annotations\n\nimport sys\nfrom io import BytesIO\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, PpmImagePlugin\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    hopper,\n)\n\n# sample ppm stream\nTEST_FILE = \"Tests/images/hopper.ppm\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert im.mode == \"RGB\"\n        assert im.size == (128, 128)\n        assert im.format == \"PPM\"\n        assert im.get_format_mimetype() == \"image/x-portable-pixmap\"\n\n\n@pytest.mark.parametrize(\n    \"data, mode, pixels\",\n    (\n        (b\"P2 3 1 4 0 2 4\", \"L\", (0, 128, 255)),\n        (b\"P2 3 1 257 0 128 257\", \"I\", (0, 32640, 65535)),\n        # P3 with maxval < 255\n        (\n            b\"P3 3 1 17 0 1 2 8 9 10 15 16 17\",\n            \"RGB\",\n            ((0, 15, 30), (120, 135, 150), (225, 240, 255)),\n        ),\n        # P3 with maxval > 255\n        # Scale down to 255, since there is no RGB mode with more than 8-bit\n        (\n            b\"P3 3 1 257 0 1 2 128 129 130 256 257 257\",\n            \"RGB\",\n            ((0, 1, 2), (127, 128, 129), (254, 255, 255)),\n        ),\n        (b\"P5 3 1 4 \\x00\\x02\\x04\", \"L\", (0, 128, 255)),\n        (b\"P5 3 1 257 \\x00\\x00\\x00\\x80\\x01\\x01\", \"I\", (0, 32640, 65535)),\n        # P6 with maxval < 255\n        (\n            b\"P6 3 1 17 \\x00\\x01\\x02\\x08\\x09\\x0A\\x0F\\x10\\x11\",\n            \"RGB\",\n            (\n                (0, 15, 30),\n                (120, 135, 150),\n                (225, 240, 255),\n            ),\n        ),\n        # P6 with maxval > 255\n        (\n            b\"P6 3 1 257 \\x00\\x00\\x00\\x01\\x00\\x02\"\n            b\"\\x00\\x80\\x00\\x81\\x00\\x82\\x01\\x00\\x01\\x01\\xFF\\xFF\",\n            \"RGB\",\n            (\n                (0, 1, 2),\n                (127, 128, 129),\n                (254, 255, 255),\n            ),\n        ),\n    ),\n)\ndef test_arbitrary_maxval(\n    data: bytes, mode: str, pixels: tuple[int | tuple[int, int, int], ...]\n) -> None:\n    fp = BytesIO(data)\n    with Image.open(fp) as im:\n        assert im.size == (3, 1)\n        assert im.mode == mode\n\n        px = im.load()\n        assert tuple(px[x, 0] for x in range(3)) == pixels\n\n\ndef test_16bit_pgm() -> None:\n    with Image.open(\"Tests/images/16_bit_binary.pgm\") as im:\n        assert im.mode == \"I\"\n        assert im.size == (20, 100)\n        assert im.get_format_mimetype() == \"image/x-portable-graymap\"\n\n        assert_image_equal_tofile(im, \"Tests/images/16_bit_binary_pgm.tiff\")\n\n\ndef test_16bit_pgm_write(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/16_bit_binary.pgm\") as im:\n        filename = str(tmp_path / \"temp.pgm\")\n        im.save(filename, \"PPM\")\n\n        assert_image_equal_tofile(im, filename)\n\n\ndef test_pnm(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/hopper.pnm\") as im:\n        assert_image_similar(im, hopper(), 0.0001)\n\n        filename = str(tmp_path / \"temp.pnm\")\n        im.save(filename)\n\n        assert_image_equal_tofile(im, filename)\n\n\ndef test_pfm(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/hopper.pfm\") as im:\n        assert im.info[\"scale\"] == 1.0\n        assert_image_equal(im, hopper(\"F\"))\n\n        filename = str(tmp_path / \"tmp.pfm\")\n        im.save(filename)\n\n        assert_image_equal_tofile(im, filename)\n\n\ndef test_pfm_big_endian(tmp_path: Path) -> None:\n    with Image.open(\"Tests/images/hopper_be.pfm\") as im:\n        assert im.info[\"scale\"] == 2.5\n        assert_image_equal(im, hopper(\"F\"))\n\n        filename = str(tmp_path / \"tmp.pfm\")\n        im.save(filename)\n\n        assert_image_equal_tofile(im, filename)\n\n\n@pytest.mark.parametrize(\n    \"data\",\n    [\n        b\"Pf 1 1 NaN \\0\\0\\0\\0\",\n        b\"Pf 1 1 inf \\0\\0\\0\\0\",\n        b\"Pf 1 1 -inf \\0\\0\\0\\0\",\n        b\"Pf 1 1 0.0 \\0\\0\\0\\0\",\n        b\"Pf 1 1 -0.0 \\0\\0\\0\\0\",\n    ],\n)\ndef test_pfm_invalid(data: bytes) -> None:\n    with pytest.raises(ValueError):\n        with Image.open(BytesIO(data)):\n            pass\n\n\n@pytest.mark.parametrize(\n    \"plain_path, raw_path\",\n    (\n        (\n            \"Tests/images/hopper_1bit_plain.pbm\",  # P1\n            \"Tests/images/hopper_1bit.pbm\",  # P4\n        ),\n        (\n            \"Tests/images/hopper_8bit_plain.pgm\",  # P2\n            \"Tests/images/hopper_8bit.pgm\",  # P5\n        ),\n        (\n            \"Tests/images/hopper_8bit_plain.ppm\",  # P3\n            \"Tests/images/hopper_8bit.ppm\",  # P6\n        ),\n    ),\n)\ndef test_plain(plain_path: str, raw_path: str) -> None:\n    with Image.open(plain_path) as im:\n        assert_image_equal_tofile(im, raw_path)\n\n\ndef test_16bit_plain_pgm() -> None:\n    # P2 with maxval 2 ** 16 - 1\n    with Image.open(\"Tests/images/hopper_16bit_plain.pgm\") as im:\n        assert im.mode == \"I\"\n        assert im.size == (128, 128)\n        assert im.get_format_mimetype() == \"image/x-portable-graymap\"\n\n        # P5 with maxval 2 ** 16 - 1\n        assert_image_equal_tofile(im, \"Tests/images/hopper_16bit.pgm\")\n\n\n@pytest.mark.parametrize(\n    \"header, data, comment_count\",\n    (\n        (b\"P1\\n2 2\", b\"1010\", 10**6),\n        (b\"P2\\n3 1\\n4\", b\"0 2 4\", 1),\n        (b\"P3\\n2 2\\n255\", b\"0 0 0 001 1 1 2 2 2 255 255 255\", 10**6),\n    ),\n)\ndef test_plain_data_with_comment(\n    tmp_path: Path, header: bytes, data: bytes, comment_count: int\n) -> None:\n    path1 = str(tmp_path / \"temp1.ppm\")\n    path2 = str(tmp_path / \"temp2.ppm\")\n    comment = b\"# comment\" * comment_count\n    with open(path1, \"wb\") as f1, open(path2, \"wb\") as f2:\n        f1.write(header + b\"\\n\\n\" + data)\n        f2.write(header + b\"\\n\" + comment + b\"\\n\" + data + comment)\n\n    with Image.open(path1) as im:\n        assert_image_equal_tofile(im, path2)\n\n\n@pytest.mark.parametrize(\"data\", (b\"P1\\n128 128\\n\", b\"P3\\n128 128\\n255\\n\"))\ndef test_plain_truncated_data(tmp_path: Path, data: bytes) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(data)\n\n    with Image.open(path) as im:\n        with pytest.raises(ValueError):\n            im.load()\n\n\n@pytest.mark.parametrize(\"data\", (b\"P1\\n128 128\\n1009\", b\"P3\\n128 128\\n255\\n100A\"))\ndef test_plain_invalid_data(tmp_path: Path, data: bytes) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(data)\n\n    with Image.open(path) as im:\n        with pytest.raises(ValueError):\n            im.load()\n\n\n@pytest.mark.parametrize(\n    \"data\",\n    (\n        b\"P3\\n128 128\\n255\\n012345678910\",  # half token too long\n        b\"P3\\n128 128\\n255\\n012345678910 0\",  # token too long\n    ),\n)\ndef test_plain_ppm_token_too_long(tmp_path: Path, data: bytes) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(data)\n\n    with Image.open(path) as im:\n        with pytest.raises(ValueError):\n            im.load()\n\n\ndef test_plain_ppm_value_negative(tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P3\\n128 128\\n255\\n-1\")\n\n    with Image.open(path) as im:\n        with pytest.raises(ValueError, match=\"Channel value is negative\"):\n            im.load()\n\n\ndef test_plain_ppm_value_too_large(tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P3\\n128 128\\n255\\n256\")\n\n    with Image.open(path) as im:\n        with pytest.raises(ValueError, match=\"Channel value too large\"):\n            im.load()\n\n\ndef test_magic() -> None:\n    with pytest.raises(SyntaxError):\n        PpmImagePlugin.PpmImageFile(fp=BytesIO(b\"PyInvalid\"))\n\n\ndef test_header_with_comments(tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P6 #comment\\n#comment\\r12#comment\\r8\\n128 #comment\\n255\\n\")\n\n    with Image.open(path) as im:\n        assert im.size == (128, 128)\n\n\ndef test_non_integer_token(tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P6\\nTEST\")\n\n    with pytest.raises(ValueError):\n        with Image.open(path):\n            pass\n\n\ndef test_header_token_too_long(tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P6\\n 01234567890\")\n\n    with pytest.raises(ValueError) as e:\n        with Image.open(path):\n            pass\n\n    assert str(e.value) == \"Token too long in file header: 01234567890\"\n\n\ndef test_truncated_file(tmp_path: Path) -> None:\n    # Test EOF in header\n    path = str(tmp_path / \"temp.pgm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P6\")\n\n    with pytest.raises(ValueError) as e:\n        with Image.open(path):\n            pass\n\n    assert str(e.value) == \"Reached EOF while reading header\"\n\n    # Test EOF for PyDecoder\n    fp = BytesIO(b\"P5 3 1 4\")\n    with Image.open(fp) as im:\n        with pytest.raises(ValueError):\n            im.load()\n\n\ndef test_not_enough_image_data(tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P2 1 2 255 255\")\n\n    with Image.open(path) as im:\n        with pytest.raises(ValueError):\n            im.load()\n\n\n@pytest.mark.parametrize(\"maxval\", (b\"0\", b\"65536\"))\ndef test_invalid_maxval(maxval: bytes, tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.ppm\")\n    with open(path, \"wb\") as f:\n        f.write(b\"P6\\n3 1 \" + maxval)\n\n    with pytest.raises(ValueError) as e:\n        with Image.open(path):\n            pass\n\n    assert str(e.value) == \"maxval must be greater than 0 and less than 65536\"\n\n\ndef test_neg_ppm() -> None:\n    # Storage.c accepted negative values for xsize, ysize.  the\n    # internal open_ppm function didn't check for sanity but it\n    # has been removed. The default opener doesn't accept negative\n    # sizes.\n\n    with pytest.raises(OSError):\n        with Image.open(\"Tests/images/negative_size.ppm\"):\n            pass\n\n\ndef test_mimetypes(tmp_path: Path) -> None:\n    path = str(tmp_path / \"temp.pgm\")\n\n    with open(path, \"wb\") as f:\n        f.write(b\"P4\\n128 128\\n255\")\n    with Image.open(path) as im:\n        assert im.get_format_mimetype() == \"image/x-portable-bitmap\"\n\n    with open(path, \"wb\") as f:\n        f.write(b\"PyCMYK\\n128 128\\n255\")\n    with Image.open(path) as im:\n        assert im.get_format_mimetype() == \"image/x-portable-anymap\"\n\n\n@pytest.mark.parametrize(\"buffer\", (True, False))\ndef test_save_stdout(buffer: bool) -> None:\n    old_stdout = sys.stdout\n\n    class MyStdOut:\n        buffer = BytesIO()\n\n    mystdout: MyStdOut | BytesIO = MyStdOut() if buffer else BytesIO()\n\n    sys.stdout = mystdout  # type: ignore[assignment]\n\n    with Image.open(TEST_FILE) as im:\n        im.save(sys.stdout, \"PPM\")\n\n    # Reset stdout\n    sys.stdout = old_stdout\n\n    if isinstance(mystdout, MyStdOut):\n        mystdout = mystdout.buffer\n    with Image.open(mystdout) as reloaded:\n        assert_image_equal_tofile(reloaded, TEST_FILE)\n", "Tests/test_font_pcf.py": "from __future__ import annotations\n\nimport os\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import FontFile, Image, ImageDraw, ImageFont, PcfFontFile\n\nfrom .helper import (\n    assert_image_equal_tofile,\n    assert_image_similar_tofile,\n    skip_unless_feature,\n)\n\nfontname = \"Tests/fonts/10x20-ISO8859-1.pcf\"\n\nmessage = \"hello, world\"\n\n\npytestmark = skip_unless_feature(\"zlib\")\n\n\ndef save_font(request: pytest.FixtureRequest, tmp_path: Path) -> str:\n    with open(fontname, \"rb\") as test_file:\n        font = PcfFontFile.PcfFontFile(test_file)\n    assert isinstance(font, FontFile.FontFile)\n    # check the number of characters in the font\n    assert len([_f for _f in font.glyph if _f]) == 223\n\n    tempname = str(tmp_path / \"temp.pil\")\n\n    def delete_tempfile() -> None:\n        try:\n            os.remove(tempname[:-4] + \".pbm\")\n        except OSError:\n            pass  # report?\n\n    request.addfinalizer(delete_tempfile)\n    font.save(tempname)\n\n    with Image.open(tempname.replace(\".pil\", \".pbm\")) as loaded:\n        assert_image_equal_tofile(loaded, \"Tests/fonts/10x20.pbm\")\n\n    with open(tempname, \"rb\") as f_loaded:\n        with open(\"Tests/fonts/10x20.pil\", \"rb\") as f_target:\n            assert f_loaded.read() == f_target.read()\n    return tempname\n\n\ndef test_sanity(request: pytest.FixtureRequest, tmp_path: Path) -> None:\n    save_font(request, tmp_path)\n\n\ndef test_less_than_256_characters() -> None:\n    with open(\"Tests/fonts/10x20-ISO8859-1-fewer-characters.pcf\", \"rb\") as test_file:\n        font = PcfFontFile.PcfFontFile(test_file)\n    assert isinstance(font, FontFile.FontFile)\n    # check the number of characters in the font\n    assert len([_f for _f in font.glyph if _f]) == 127\n\n\ndef test_invalid_file() -> None:\n    with open(\"Tests/images/flower.jpg\", \"rb\") as fp:\n        with pytest.raises(SyntaxError):\n            PcfFontFile.PcfFontFile(fp)\n\n\ndef test_draw(request: pytest.FixtureRequest, tmp_path: Path) -> None:\n    tempname = save_font(request, tmp_path)\n    font = ImageFont.load(tempname)\n    im = Image.new(\"L\", (130, 30), \"white\")\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), message, \"black\", font=font)\n    assert_image_similar_tofile(im, \"Tests/images/test_draw_pbm_target.png\", 0)\n\n\ndef test_textsize(request: pytest.FixtureRequest, tmp_path: Path) -> None:\n    tempname = save_font(request, tmp_path)\n    font = ImageFont.load(tempname)\n    for i in range(255):\n        (ox, oy, dx, dy) = font.getbbox(chr(i))\n        assert ox == 0\n        assert oy == 0\n        assert dy == 20\n        assert dx in (0, 10)\n        assert font.getlength(chr(i)) == dx\n    for i in range(len(message)):\n        msg = message[: i + 1]\n        assert font.getlength(msg) == len(msg) * 10\n        assert font.getbbox(msg) == (0, 0, len(msg) * 10, 20)\n\n\ndef _test_high_characters(\n    request: pytest.FixtureRequest, tmp_path: Path, message: str | bytes\n) -> None:\n    tempname = save_font(request, tmp_path)\n    font = ImageFont.load(tempname)\n    im = Image.new(\"L\", (750, 30), \"white\")\n    draw = ImageDraw.Draw(im)\n    draw.text((0, 0), message, \"black\", font=font)\n    assert_image_similar_tofile(im, \"Tests/images/high_ascii_chars.png\", 0)\n\n\ndef test_high_characters(request: pytest.FixtureRequest, tmp_path: Path) -> None:\n    message = \"\".join(chr(i + 1) for i in range(140, 232))\n    _test_high_characters(request, tmp_path, message)\n    # accept bytes instances.\n    _test_high_characters(request, tmp_path, message.encode(\"latin1\"))\n", "Tests/test_font_pcf_charsets.py": "from __future__ import annotations\n\nimport os\nfrom pathlib import Path\nfrom typing import TypedDict\n\nimport pytest\n\nfrom PIL import FontFile, Image, ImageDraw, ImageFont, PcfFontFile\n\nfrom .helper import (\n    assert_image_equal_tofile,\n    assert_image_similar_tofile,\n    skip_unless_feature,\n)\n\nfontname = \"Tests/fonts/ter-x20b.pcf\"\n\n\nclass Charset(TypedDict):\n    glyph_count: int\n    message: str\n    image1: str\n\n\ncharsets: dict[str, Charset] = {\n    \"iso8859-1\": {\n        \"glyph_count\": 223,\n        \"message\": \"hello, world\",\n        \"image1\": \"Tests/images/test_draw_pbm_ter_en_target.png\",\n    },\n    \"iso8859-2\": {\n        \"glyph_count\": 223,\n        \"message\": \"witaj \u015bwiecie\",\n        \"image1\": \"Tests/images/test_draw_pbm_ter_pl_target.png\",\n    },\n    \"cp1250\": {\n        \"glyph_count\": 250,\n        \"message\": \"witaj \u015bwiecie\",\n        \"image1\": \"Tests/images/test_draw_pbm_ter_pl_target.png\",\n    },\n}\n\n\npytestmark = skip_unless_feature(\"zlib\")\n\n\ndef save_font(request: pytest.FixtureRequest, tmp_path: Path, encoding: str) -> str:\n    with open(fontname, \"rb\") as test_file:\n        font = PcfFontFile.PcfFontFile(test_file, encoding)\n    assert isinstance(font, FontFile.FontFile)\n    # check the number of characters in the font\n    assert len([_f for _f in font.glyph if _f]) == charsets[encoding][\"glyph_count\"]\n\n    tempname = str(tmp_path / \"temp.pil\")\n\n    def delete_tempfile() -> None:\n        try:\n            os.remove(tempname[:-4] + \".pbm\")\n        except OSError:\n            pass  # report?\n\n    request.addfinalizer(delete_tempfile)\n    font.save(tempname)\n\n    with Image.open(tempname.replace(\".pil\", \".pbm\")) as loaded:\n        assert_image_equal_tofile(loaded, f\"Tests/fonts/ter-x20b-{encoding}.pbm\")\n\n    with open(tempname, \"rb\") as f_loaded:\n        with open(f\"Tests/fonts/ter-x20b-{encoding}.pil\", \"rb\") as f_target:\n            assert f_loaded.read() == f_target.read()\n    return tempname\n\n\n@pytest.mark.parametrize(\"encoding\", (\"iso8859-1\", \"iso8859-2\", \"cp1250\"))\ndef test_sanity(request: pytest.FixtureRequest, tmp_path: Path, encoding: str) -> None:\n    save_font(request, tmp_path, encoding)\n\n\n@pytest.mark.parametrize(\"encoding\", (\"iso8859-1\", \"iso8859-2\", \"cp1250\"))\ndef test_draw(request: pytest.FixtureRequest, tmp_path: Path, encoding: str) -> None:\n    tempname = save_font(request, tmp_path, encoding)\n    font = ImageFont.load(tempname)\n    im = Image.new(\"L\", (150, 30), \"white\")\n    draw = ImageDraw.Draw(im)\n    message = charsets[encoding][\"message\"].encode(encoding)\n    draw.text((0, 0), message, \"black\", font=font)\n    assert_image_similar_tofile(im, charsets[encoding][\"image1\"], 0)\n\n\n@pytest.mark.parametrize(\"encoding\", (\"iso8859-1\", \"iso8859-2\", \"cp1250\"))\ndef test_textsize(\n    request: pytest.FixtureRequest, tmp_path: Path, encoding: str\n) -> None:\n    tempname = save_font(request, tmp_path, encoding)\n    font = ImageFont.load(tempname)\n    for i in range(255):\n        (ox, oy, dx, dy) = font.getbbox(bytearray([i]))\n        assert ox == 0\n        assert oy == 0\n        assert dy == 20\n        assert dx in (0, 10)\n        assert font.getlength(bytearray([i])) == dx\n    message = charsets[encoding][\"message\"].encode(encoding)\n    for i in range(len(message)):\n        msg = message[: i + 1]\n        assert font.getlength(msg) == len(msg) * 10\n        assert font.getbbox(msg) == (0, 0, len(msg) * 10, 20)\n", "Tests/test_000_sanity.py": "from __future__ import annotations\n\nfrom PIL import Image\n\n\ndef test_sanity() -> None:\n    # Make sure we have the binary extension\n    Image.core.new(\"L\", (100, 100))\n\n    # Create an image and do stuff with it.\n    im = Image.new(\"1\", (100, 100))\n    assert (im.mode, im.size) == (\"1\", (100, 100))\n    assert len(im.tobytes()) == 1300\n\n    # Create images in all remaining major modes.\n    Image.new(\"L\", (100, 100))\n    Image.new(\"P\", (100, 100))\n    Image.new(\"RGB\", (100, 100))\n    Image.new(\"I\", (100, 100))\n    Image.new(\"F\", (100, 100))\n", "Tests/test_file_bufrstub.py": "from __future__ import annotations\n\nfrom pathlib import Path\nfrom typing import IO\n\nimport pytest\n\nfrom PIL import BufrStubImagePlugin, Image, ImageFile\n\nfrom .helper import hopper\n\nTEST_FILE = \"Tests/images/gfs.t06z.rassda.tm00.bufr_d\"\n\n\ndef test_open() -> None:\n    # Act\n    with Image.open(TEST_FILE) as im:\n        # Assert\n        assert im.format == \"BUFR\"\n\n        # Dummy data from the stub\n        assert im.mode == \"F\"\n        assert im.size == (1, 1)\n\n\ndef test_invalid_file() -> None:\n    # Arrange\n    invalid_file = \"Tests/images/flower.jpg\"\n\n    # Act / Assert\n    with pytest.raises(SyntaxError):\n        BufrStubImagePlugin.BufrStubImageFile(invalid_file)\n\n\ndef test_load() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        # Act / Assert: stub cannot load without an implemented handler\n        with pytest.raises(OSError):\n            im.load()\n\n\ndef test_save(tmp_path: Path) -> None:\n    # Arrange\n    im = hopper()\n    tmpfile = str(tmp_path / \"temp.bufr\")\n\n    # Act / Assert: stub cannot save without an implemented handler\n    with pytest.raises(OSError):\n        im.save(tmpfile)\n\n\ndef test_handler(tmp_path: Path) -> None:\n    class TestHandler(ImageFile.StubHandler):\n        opened = False\n        loaded = False\n        saved = False\n\n        def open(self, im: ImageFile.StubImageFile) -> None:\n            self.opened = True\n\n        def load(self, im: ImageFile.StubImageFile) -> Image.Image:\n            self.loaded = True\n            im.fp.close()\n            return Image.new(\"RGB\", (1, 1))\n\n        def is_loaded(self) -> bool:\n            return self.loaded\n\n        def save(self, im: Image.Image, fp: IO[bytes], filename: str) -> None:\n            self.saved = True\n\n    handler = TestHandler()\n    BufrStubImagePlugin.register_handler(handler)\n    with Image.open(TEST_FILE) as im:\n        assert handler.opened\n        assert not handler.is_loaded()\n\n        im.load()\n        assert handler.is_loaded()\n\n        temp_file = str(tmp_path / \"temp.bufr\")\n        im.save(temp_file)\n        assert handler.saved\n\n    BufrStubImagePlugin._handler = None\n", "Tests/test_imagechops.py": "from __future__ import annotations\n\nfrom typing import Callable\n\nfrom PIL import Image, ImageChops\n\nfrom .helper import assert_image_equal, hopper\n\nBLACK = (0, 0, 0)\nBROWN = (127, 64, 0)\nCYAN = (0, 255, 255)\nDARK_GREEN = (0, 128, 0)\nGREEN = (0, 255, 0)\nORANGE = (255, 128, 0)\nWHITE = (255, 255, 255)\n\nGRAY = 128\n\n\ndef test_sanity() -> None:\n    im = hopper(\"L\")\n\n    ImageChops.constant(im, 128)\n    ImageChops.duplicate(im)\n    ImageChops.invert(im)\n    ImageChops.lighter(im, im)\n    ImageChops.darker(im, im)\n    ImageChops.difference(im, im)\n    ImageChops.multiply(im, im)\n    ImageChops.screen(im, im)\n\n    ImageChops.add(im, im)\n    ImageChops.add(im, im, 2.0)\n    ImageChops.add(im, im, 2.0, 128)\n    ImageChops.subtract(im, im)\n    ImageChops.subtract(im, im, 2.0)\n    ImageChops.subtract(im, im, 2.0, 128)\n\n    ImageChops.add_modulo(im, im)\n    ImageChops.subtract_modulo(im, im)\n\n    ImageChops.blend(im, im, 0.5)\n    ImageChops.composite(im, im, im)\n\n    ImageChops.soft_light(im, im)\n    ImageChops.hard_light(im, im)\n    ImageChops.overlay(im, im)\n\n    ImageChops.offset(im, 10)\n    ImageChops.offset(im, 10, 20)\n\n\ndef test_add() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_ellipse_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_floodfill_RGB.png\") as im2:\n            # Act\n            new = ImageChops.add(im1, im2)\n\n    # Assert\n    assert new.getbbox() == (25, 25, 76, 76)\n    assert new.getpixel((50, 50)) == ORANGE\n\n\ndef test_add_scale_offset() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_ellipse_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_floodfill_RGB.png\") as im2:\n            # Act\n            new = ImageChops.add(im1, im2, scale=2.5, offset=100)\n\n    # Assert\n    assert new.getbbox() == (0, 0, 100, 100)\n    assert new.getpixel((50, 50)) == (202, 151, 100)\n\n\ndef test_add_clip() -> None:\n    # Arrange\n    im = hopper()\n\n    # Act\n    new = ImageChops.add(im, im)\n\n    # Assert\n    assert new.getpixel((50, 50)) == (255, 255, 254)\n\n\ndef test_add_modulo() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_ellipse_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_floodfill_RGB.png\") as im2:\n            # Act\n            new = ImageChops.add_modulo(im1, im2)\n\n    # Assert\n    assert new.getbbox() == (25, 25, 76, 76)\n    assert new.getpixel((50, 50)) == ORANGE\n\n\ndef test_add_modulo_no_clip() -> None:\n    # Arrange\n    im = hopper()\n\n    # Act\n    new = ImageChops.add_modulo(im, im)\n\n    # Assert\n    assert new.getpixel((50, 50)) == (224, 76, 254)\n\n\ndef test_blend() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_ellipse_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_floodfill_RGB.png\") as im2:\n            # Act\n            new = ImageChops.blend(im1, im2, 0.5)\n\n    # Assert\n    assert new.getbbox() == (25, 25, 76, 76)\n    assert new.getpixel((50, 50)) == BROWN\n\n\ndef test_constant() -> None:\n    # Arrange\n    im = Image.new(\"RGB\", (20, 10))\n\n    # Act\n    new = ImageChops.constant(im, GRAY)\n\n    # Assert\n    assert new.size == im.size\n    assert new.getpixel((0, 0)) == GRAY\n    assert new.getpixel((19, 9)) == GRAY\n\n\ndef test_darker_image() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_outline_chord_RGB.png\") as im2:\n            # Act\n            new = ImageChops.darker(im1, im2)\n\n            # Assert\n            assert_image_equal(new, im2)\n\n\ndef test_darker_pixel() -> None:\n    # Arrange\n    im1 = hopper()\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im2:\n        # Act\n        new = ImageChops.darker(im1, im2)\n\n    # Assert\n    assert new.getpixel((50, 50)) == (240, 166, 0)\n\n\ndef test_difference() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_arc_end_le_start.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_arc_no_loops.png\") as im2:\n            # Act\n            new = ImageChops.difference(im1, im2)\n\n    # Assert\n    assert new.getbbox() == (25, 25, 76, 76)\n\n\ndef test_difference_pixel() -> None:\n    # Arrange\n    im1 = hopper()\n    with Image.open(\"Tests/images/imagedraw_polygon_kite_RGB.png\") as im2:\n        # Act\n        new = ImageChops.difference(im1, im2)\n\n    # Assert\n    assert new.getpixel((50, 50)) == (240, 166, 128)\n\n\ndef test_duplicate() -> None:\n    # Arrange\n    im = hopper()\n\n    # Act\n    new = ImageChops.duplicate(im)\n\n    # Assert\n    assert_image_equal(new, im)\n\n\ndef test_invert() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_floodfill_RGB.png\") as im:\n        # Act\n        new = ImageChops.invert(im)\n\n    # Assert\n    assert new.getbbox() == (0, 0, 100, 100)\n    assert new.getpixel((0, 0)) == WHITE\n    assert new.getpixel((50, 50)) == CYAN\n\n\ndef test_lighter_image() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_outline_chord_RGB.png\") as im2:\n            # Act\n            new = ImageChops.lighter(im1, im2)\n\n        # Assert\n        assert_image_equal(new, im1)\n\n\ndef test_lighter_pixel() -> None:\n    # Arrange\n    im1 = hopper()\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im2:\n        # Act\n        new = ImageChops.lighter(im1, im2)\n\n    # Assert\n    assert new.getpixel((50, 50)) == (255, 255, 127)\n\n\ndef test_multiply_black() -> None:\n    \"\"\"If you multiply an image with a solid black image,\n    the result is black.\"\"\"\n    # Arrange\n    im1 = hopper()\n    black = Image.new(\"RGB\", im1.size, \"black\")\n\n    # Act\n    new = ImageChops.multiply(im1, black)\n\n    # Assert\n    assert_image_equal(new, black)\n\n\ndef test_multiply_green() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_floodfill_RGB.png\") as im:\n        green = Image.new(\"RGB\", im.size, \"green\")\n\n        # Act\n        new = ImageChops.multiply(im, green)\n\n    # Assert\n    assert new.getbbox() == (25, 25, 76, 76)\n    assert new.getpixel((25, 25)) == DARK_GREEN\n    assert new.getpixel((50, 50)) == BLACK\n\n\ndef test_multiply_white() -> None:\n    \"\"\"If you multiply with a solid white image, the image is unaffected.\"\"\"\n    # Arrange\n    im1 = hopper()\n    white = Image.new(\"RGB\", im1.size, \"white\")\n\n    # Act\n    new = ImageChops.multiply(im1, white)\n\n    # Assert\n    assert_image_equal(new, im1)\n\n\ndef test_offset() -> None:\n    # Arrange\n    xoffset = 45\n    yoffset = 20\n    with Image.open(\"Tests/images/imagedraw_ellipse_RGB.png\") as im:\n        # Act\n        new = ImageChops.offset(im, xoffset, yoffset)\n\n        # Assert\n        assert new.getbbox() == (0, 45, 100, 96)\n        assert new.getpixel((50, 50)) == BLACK\n        assert new.getpixel((50 + xoffset, 50 + yoffset)) == DARK_GREEN\n\n        # Test no yoffset\n        assert ImageChops.offset(im, xoffset) == ImageChops.offset(im, xoffset, xoffset)\n\n\ndef test_screen() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_ellipse_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_floodfill_RGB.png\") as im2:\n            # Act\n            new = ImageChops.screen(im1, im2)\n\n    # Assert\n    assert new.getbbox() == (25, 25, 76, 76)\n    assert new.getpixel((50, 50)) == ORANGE\n\n\ndef test_subtract() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_outline_chord_RGB.png\") as im2:\n            # Act\n            new = ImageChops.subtract(im1, im2)\n\n    # Assert\n    assert new.getbbox() == (25, 50, 76, 76)\n    assert new.getpixel((50, 51)) == GREEN\n    assert new.getpixel((50, 52)) == BLACK\n\n\ndef test_subtract_scale_offset() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_outline_chord_RGB.png\") as im2:\n            # Act\n            new = ImageChops.subtract(im1, im2, scale=2.5, offset=100)\n\n    # Assert\n    assert new.getbbox() == (0, 0, 100, 100)\n    assert new.getpixel((50, 50)) == (100, 202, 100)\n\n\ndef test_subtract_clip() -> None:\n    # Arrange\n    im1 = hopper()\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im2:\n        # Act\n        new = ImageChops.subtract(im1, im2)\n\n    # Assert\n    assert new.getpixel((50, 50)) == (0, 0, 127)\n\n\ndef test_subtract_modulo() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im1:\n        with Image.open(\"Tests/images/imagedraw_outline_chord_RGB.png\") as im2:\n            # Act\n            new = ImageChops.subtract_modulo(im1, im2)\n\n    # Assert\n    assert new.getbbox() == (25, 50, 76, 76)\n    assert new.getpixel((50, 51)) == GREEN\n    assert new.getpixel((50, 52)) == BLACK\n\n\ndef test_subtract_modulo_no_clip() -> None:\n    # Arrange\n    im1 = hopper()\n    with Image.open(\"Tests/images/imagedraw_chord_RGB.png\") as im2:\n        # Act\n        new = ImageChops.subtract_modulo(im1, im2)\n\n    # Assert\n    assert new.getpixel((50, 50)) == (241, 167, 127)\n\n\ndef test_soft_light() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/hopper.png\") as im1:\n        with Image.open(\"Tests/images/hopper-XYZ.png\") as im2:\n            # Act\n            new = ImageChops.soft_light(im1, im2)\n\n    # Assert\n    assert new.getpixel((64, 64)) == (163, 54, 32)\n    assert new.getpixel((15, 100)) == (1, 1, 3)\n\n\ndef test_hard_light() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/hopper.png\") as im1:\n        with Image.open(\"Tests/images/hopper-XYZ.png\") as im2:\n            # Act\n            new = ImageChops.hard_light(im1, im2)\n\n    # Assert\n    assert new.getpixel((64, 64)) == (144, 50, 27)\n    assert new.getpixel((15, 100)) == (1, 1, 2)\n\n\ndef test_overlay() -> None:\n    # Arrange\n    with Image.open(\"Tests/images/hopper.png\") as im1:\n        with Image.open(\"Tests/images/hopper-XYZ.png\") as im2:\n            # Act\n            new = ImageChops.overlay(im1, im2)\n\n    # Assert\n    assert new.getpixel((64, 64)) == (159, 50, 27)\n    assert new.getpixel((15, 100)) == (1, 1, 2)\n\n\ndef test_logical() -> None:\n    def table(\n        op: Callable[[Image.Image, Image.Image], Image.Image], a: int, b: int\n    ) -> tuple[int, int, int, int]:\n        out = []\n        for x in (a, b):\n            imx = Image.new(\"1\", (1, 1), x)\n            for y in (a, b):\n                imy = Image.new(\"1\", (1, 1), y)\n                out.append(op(imx, imy).getpixel((0, 0)))\n        return tuple(out)\n\n    assert table(ImageChops.logical_and, 0, 1) == (0, 0, 0, 255)\n    assert table(ImageChops.logical_or, 0, 1) == (0, 255, 255, 255)\n    assert table(ImageChops.logical_xor, 0, 1) == (0, 255, 255, 0)\n\n    assert table(ImageChops.logical_and, 0, 128) == (0, 0, 0, 255)\n    assert table(ImageChops.logical_or, 0, 128) == (0, 255, 255, 255)\n    assert table(ImageChops.logical_xor, 0, 128) == (0, 255, 255, 0)\n\n    assert table(ImageChops.logical_and, 0, 255) == (0, 0, 0, 255)\n    assert table(ImageChops.logical_or, 0, 255) == (0, 255, 255, 255)\n    assert table(ImageChops.logical_xor, 0, 255) == (0, 255, 255, 0)\n", "Tests/test_imageenhance.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image, ImageEnhance\n\nfrom .helper import assert_image_equal, hopper\n\n\ndef test_sanity() -> None:\n    # FIXME: assert_image\n    # Implicit asserts no exception:\n    ImageEnhance.Color(hopper()).enhance(0.5)\n    ImageEnhance.Contrast(hopper()).enhance(0.5)\n    ImageEnhance.Brightness(hopper()).enhance(0.5)\n    ImageEnhance.Sharpness(hopper()).enhance(0.5)\n\n\ndef test_crash() -> None:\n    # crashes on small images\n    im = Image.new(\"RGB\", (1, 1))\n    ImageEnhance.Sharpness(im).enhance(0.5)\n\n\ndef _half_transparent_image() -> Image.Image:\n    # returns an image, half transparent, half solid\n    im = hopper(\"RGB\")\n\n    transparent = Image.new(\"L\", im.size, 0)\n    solid = Image.new(\"L\", (im.size[0] // 2, im.size[1]), 255)\n    transparent.paste(solid, (0, 0))\n    im.putalpha(transparent)\n\n    return im\n\n\ndef _check_alpha(\n    im: Image.Image, original: Image.Image, op: str, amount: float\n) -> None:\n    assert im.getbands() == original.getbands()\n    assert_image_equal(\n        im.getchannel(\"A\"),\n        original.getchannel(\"A\"),\n        f\"Diff on {op}: {amount}\",\n    )\n\n\n@pytest.mark.parametrize(\"op\", (\"Color\", \"Brightness\", \"Contrast\", \"Sharpness\"))\ndef test_alpha(op: str) -> None:\n    # Issue https://github.com/python-pillow/Pillow/issues/899\n    # Is alpha preserved through image enhancement?\n\n    original = _half_transparent_image()\n\n    for amount in [0, 0.5, 1.0]:\n        _check_alpha(\n            getattr(ImageEnhance, op)(original).enhance(amount),\n            original,\n            op,\n            amount,\n        )\n", "Tests/check_wheel.py": "from __future__ import annotations\n\nimport sys\n\nfrom PIL import features\n\n\ndef test_wheel_modules() -> None:\n    expected_modules = {\"pil\", \"tkinter\", \"freetype2\", \"littlecms2\", \"webp\"}\n\n    # tkinter is not available in cibuildwheel installed CPython on Windows\n    try:\n        import tkinter\n\n        assert tkinter\n    except ImportError:\n        expected_modules.remove(\"tkinter\")\n\n    assert set(features.get_supported_modules()) == expected_modules\n\n\ndef test_wheel_codecs() -> None:\n    expected_codecs = {\"jpg\", \"jpg_2000\", \"zlib\", \"libtiff\"}\n\n    assert set(features.get_supported_codecs()) == expected_codecs\n\n\ndef test_wheel_features() -> None:\n    expected_features = {\n        \"webp_anim\",\n        \"webp_mux\",\n        \"transp_webp\",\n        \"raqm\",\n        \"fribidi\",\n        \"harfbuzz\",\n        \"libjpeg_turbo\",\n        \"xcb\",\n    }\n\n    if sys.platform == \"win32\":\n        expected_features.remove(\"xcb\")\n\n    assert set(features.get_supported_features()) == expected_features\n", "Tests/test_image_frombytes.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import assert_image_equal, hopper\n\n\n@pytest.mark.parametrize(\"data_type\", (\"bytes\", \"memoryview\"))\ndef test_sanity(data_type: str) -> None:\n    im1 = hopper()\n\n    data = im1.tobytes()\n    if data_type == \"memoryview\":\n        data = memoryview(data)\n    im2 = Image.frombytes(im1.mode, im1.size, data)\n\n    assert_image_equal(im1, im2)\n", "Tests/test_image_getpalette.py": "from __future__ import annotations\n\nfrom PIL import Image\n\nfrom .helper import hopper\n\n\ndef test_palette() -> None:\n    def palette(mode: str) -> list[int] | None:\n        p = hopper(mode).getpalette()\n        if p:\n            return p[:10]\n        return None\n\n    assert palette(\"1\") is None\n    assert palette(\"L\") is None\n    assert palette(\"I\") is None\n    assert palette(\"F\") is None\n    assert palette(\"P\") == [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert palette(\"RGB\") is None\n    assert palette(\"RGBA\") is None\n    assert palette(\"CMYK\") is None\n    assert palette(\"YCbCr\") is None\n\n\ndef test_palette_rawmode() -> None:\n    im = Image.new(\"P\", (1, 1))\n    im.putpalette((1, 2, 3))\n\n    for rawmode in (\"RGB\", None):\n        rgb = im.getpalette(rawmode)\n        assert rgb == [1, 2, 3]\n\n    # Convert the RGB palette to RGBA\n    rgba = im.getpalette(\"RGBA\")\n    assert rgba == [1, 2, 3, 255]\n\n    im.putpalette((1, 2, 3, 4), \"RGBA\")\n\n    # Convert the RGBA palette to RGB\n    rgb = im.getpalette(\"RGB\")\n    assert rgb == [1, 2, 3]\n\n    for rawmode in (\"RGBA\", None):\n        rgba = im.getpalette(rawmode)\n        assert rgba == [1, 2, 3, 4]\n", "Tests/test_image_tobitmap.py": "from __future__ import annotations\n\nimport pytest\n\nfrom .helper import assert_image_equal, fromstring, hopper\n\n\ndef test_sanity() -> None:\n    with pytest.raises(ValueError):\n        hopper().tobitmap()\n\n    im1 = hopper().convert(\"1\")\n\n    bitmap = im1.tobitmap()\n\n    assert isinstance(bitmap, bytes)\n    assert_image_equal(im1, fromstring(bitmap))\n", "Tests/test_image_transpose.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\nfrom PIL.Image import Transpose\n\nfrom . import helper\nfrom .helper import assert_image_equal\n\nHOPPER = {\n    mode: helper.hopper(mode).crop((0, 0, 121, 127)).copy()\n    for mode in [\"L\", \"RGB\", \"I;16\", \"I;16L\", \"I;16B\"]\n}\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_flip_left_right(mode: str) -> None:\n    im = HOPPER[mode]\n    out = im.transpose(Transpose.FLIP_LEFT_RIGHT)\n    assert out.mode == mode\n    assert out.size == im.size\n\n    x, y = im.size\n    assert im.getpixel((1, 1)) == out.getpixel((x - 2, 1))\n    assert im.getpixel((x - 2, 1)) == out.getpixel((1, 1))\n    assert im.getpixel((1, y - 2)) == out.getpixel((x - 2, y - 2))\n    assert im.getpixel((x - 2, y - 2)) == out.getpixel((1, y - 2))\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_flip_top_bottom(mode: str) -> None:\n    im = HOPPER[mode]\n    out = im.transpose(Transpose.FLIP_TOP_BOTTOM)\n    assert out.mode == mode\n    assert out.size == im.size\n\n    x, y = im.size\n    assert im.getpixel((1, 1)) == out.getpixel((1, y - 2))\n    assert im.getpixel((x - 2, 1)) == out.getpixel((x - 2, y - 2))\n    assert im.getpixel((1, y - 2)) == out.getpixel((1, 1))\n    assert im.getpixel((x - 2, y - 2)) == out.getpixel((x - 2, 1))\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_rotate_90(mode: str) -> None:\n    im = HOPPER[mode]\n    out = im.transpose(Transpose.ROTATE_90)\n    assert out.mode == mode\n    assert out.size == im.size[::-1]\n\n    x, y = im.size\n    assert im.getpixel((1, 1)) == out.getpixel((1, x - 2))\n    assert im.getpixel((x - 2, 1)) == out.getpixel((1, 1))\n    assert im.getpixel((1, y - 2)) == out.getpixel((y - 2, x - 2))\n    assert im.getpixel((x - 2, y - 2)) == out.getpixel((y - 2, 1))\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_rotate_180(mode: str) -> None:\n    im = HOPPER[mode]\n    out = im.transpose(Transpose.ROTATE_180)\n    assert out.mode == mode\n    assert out.size == im.size\n\n    x, y = im.size\n    assert im.getpixel((1, 1)) == out.getpixel((x - 2, y - 2))\n    assert im.getpixel((x - 2, 1)) == out.getpixel((1, y - 2))\n    assert im.getpixel((1, y - 2)) == out.getpixel((x - 2, 1))\n    assert im.getpixel((x - 2, y - 2)) == out.getpixel((1, 1))\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_rotate_270(mode: str) -> None:\n    im = HOPPER[mode]\n    out = im.transpose(Transpose.ROTATE_270)\n    assert out.mode == mode\n    assert out.size == im.size[::-1]\n\n    x, y = im.size\n    assert im.getpixel((1, 1)) == out.getpixel((y - 2, 1))\n    assert im.getpixel((x - 2, 1)) == out.getpixel((y - 2, x - 2))\n    assert im.getpixel((1, y - 2)) == out.getpixel((1, 1))\n    assert im.getpixel((x - 2, y - 2)) == out.getpixel((1, x - 2))\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_transpose(mode: str) -> None:\n    im = HOPPER[mode]\n    out = im.transpose(Transpose.TRANSPOSE)\n    assert out.mode == mode\n    assert out.size == im.size[::-1]\n\n    x, y = im.size\n    assert im.getpixel((1, 1)) == out.getpixel((1, 1))\n    assert im.getpixel((x - 2, 1)) == out.getpixel((1, x - 2))\n    assert im.getpixel((1, y - 2)) == out.getpixel((y - 2, 1))\n    assert im.getpixel((x - 2, y - 2)) == out.getpixel((y - 2, x - 2))\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_tranverse(mode: str) -> None:\n    im = HOPPER[mode]\n    out = im.transpose(Transpose.TRANSVERSE)\n    assert out.mode == mode\n    assert out.size == im.size[::-1]\n\n    x, y = im.size\n    assert im.getpixel((1, 1)) == out.getpixel((y - 2, x - 2))\n    assert im.getpixel((x - 2, 1)) == out.getpixel((y - 2, 1))\n    assert im.getpixel((1, y - 2)) == out.getpixel((1, x - 2))\n    assert im.getpixel((x - 2, y - 2)) == out.getpixel((1, 1))\n\n\n@pytest.mark.parametrize(\"mode\", HOPPER)\ndef test_roundtrip(mode: str) -> None:\n    im = HOPPER[mode]\n\n    def transpose(first: Transpose, second: Transpose) -> Image.Image:\n        return im.transpose(first).transpose(second)\n\n    assert_image_equal(\n        im, transpose(Transpose.FLIP_LEFT_RIGHT, Transpose.FLIP_LEFT_RIGHT)\n    )\n    assert_image_equal(\n        im, transpose(Transpose.FLIP_TOP_BOTTOM, Transpose.FLIP_TOP_BOTTOM)\n    )\n    assert_image_equal(im, transpose(Transpose.ROTATE_90, Transpose.ROTATE_270))\n    assert_image_equal(im, transpose(Transpose.ROTATE_180, Transpose.ROTATE_180))\n    assert_image_equal(\n        im.transpose(Transpose.TRANSPOSE),\n        transpose(Transpose.ROTATE_90, Transpose.FLIP_TOP_BOTTOM),\n    )\n    assert_image_equal(\n        im.transpose(Transpose.TRANSPOSE),\n        transpose(Transpose.ROTATE_270, Transpose.FLIP_LEFT_RIGHT),\n    )\n    assert_image_equal(\n        im.transpose(Transpose.TRANSVERSE),\n        transpose(Transpose.ROTATE_90, Transpose.FLIP_LEFT_RIGHT),\n    )\n    assert_image_equal(\n        im.transpose(Transpose.TRANSVERSE),\n        transpose(Transpose.ROTATE_270, Transpose.FLIP_TOP_BOTTOM),\n    )\n    assert_image_equal(\n        im.transpose(Transpose.TRANSVERSE),\n        transpose(Transpose.ROTATE_180, Transpose.TRANSPOSE),\n    )\n", "Tests/test_file_spider.py": "from __future__ import annotations\n\nimport tempfile\nimport warnings\nfrom io import BytesIO\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImageSequence, SpiderImagePlugin\n\nfrom .helper import assert_image_equal, hopper, is_pypy\n\nTEST_FILE = \"Tests/images/hopper.spider\"\n\n\ndef test_sanity() -> None:\n    with Image.open(TEST_FILE) as im:\n        im.load()\n        assert im.mode == \"F\"\n        assert im.size == (128, 128)\n        assert im.format == \"SPIDER\"\n\n\n@pytest.mark.skipif(is_pypy(), reason=\"Requires CPython\")\ndef test_unclosed_file() -> None:\n    def open() -> None:\n        im = Image.open(TEST_FILE)\n        im.load()\n\n    with pytest.warns(ResourceWarning):\n        open()\n\n\ndef test_closed_file() -> None:\n    with warnings.catch_warnings():\n        im = Image.open(TEST_FILE)\n        im.load()\n        im.close()\n\n\ndef test_context_manager() -> None:\n    with warnings.catch_warnings():\n        with Image.open(TEST_FILE) as im:\n            im.load()\n\n\ndef test_save(tmp_path: Path) -> None:\n    # Arrange\n    temp = str(tmp_path / \"temp.spider\")\n    im = hopper()\n\n    # Act\n    im.save(temp, \"SPIDER\")\n\n    # Assert\n    with Image.open(temp) as im2:\n        assert im2.mode == \"F\"\n        assert im2.size == (128, 128)\n        assert im2.format == \"SPIDER\"\n\n\ndef test_tempfile() -> None:\n    # Arrange\n    im = hopper()\n\n    # Act\n    with tempfile.TemporaryFile() as fp:\n        im.save(fp, \"SPIDER\")\n\n        # Assert\n        fp.seek(0)\n        with Image.open(fp) as reloaded:\n            assert reloaded.mode == \"F\"\n            assert reloaded.size == (128, 128)\n            assert reloaded.format == \"SPIDER\"\n\n\ndef test_is_spider_image() -> None:\n    assert SpiderImagePlugin.isSpiderImage(TEST_FILE)\n\n\ndef test_tell() -> None:\n    # Arrange\n    with Image.open(TEST_FILE) as im:\n        # Act\n        index = im.tell()\n\n        # Assert\n        assert index == 0\n\n\ndef test_n_frames() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert im.n_frames == 1\n        assert not im.is_animated\n\n\ndef test_load_image_series() -> None:\n    # Arrange\n    not_spider_file = \"Tests/images/hopper.ppm\"\n    file_list = [TEST_FILE, not_spider_file, \"path/not_found.ext\"]\n\n    # Act\n    img_list = SpiderImagePlugin.loadImageSeries(file_list)\n\n    # Assert\n    assert len(img_list) == 1\n    assert isinstance(img_list[0], Image.Image)\n    assert img_list[0].size == (128, 128)\n\n\ndef test_load_image_series_no_input() -> None:\n    # Arrange\n    file_list = None\n\n    # Act\n    img_list = SpiderImagePlugin.loadImageSeries(file_list)\n\n    # Assert\n    assert img_list is None\n\n\ndef test_is_int_not_a_number() -> None:\n    # Arrange\n    not_a_number = \"a\"\n\n    # Act\n    ret = SpiderImagePlugin.isInt(not_a_number)\n\n    # Assert\n    assert ret == 0\n\n\ndef test_invalid_file() -> None:\n    invalid_file = \"Tests/images/invalid.spider\"\n\n    with pytest.raises(OSError):\n        with Image.open(invalid_file):\n            pass\n\n\ndef test_nonstack_file() -> None:\n    with Image.open(TEST_FILE) as im:\n        with pytest.raises(EOFError):\n            im.seek(0)\n\n\ndef test_nonstack_dos() -> None:\n    with Image.open(TEST_FILE) as im:\n        for i, frame in enumerate(ImageSequence.Iterator(im)):\n            assert i <= 1, \"Non-stack DOS file test failed\"\n\n\n# for issue #4093\ndef test_odd_size() -> None:\n    data = BytesIO()\n    width = 100\n    im = Image.new(\"F\", (width, 64))\n    im.save(data, format=\"SPIDER\")\n\n    data.seek(0)\n    with Image.open(data) as im2:\n        assert_image_equal(im, im2)\n", "Tests/test_image_quantize.py": "from __future__ import annotations\n\nimport pytest\nfrom packaging.version import parse as parse_version\n\nfrom PIL import Image, features\n\nfrom .helper import assert_image_similar, hopper, is_ppc64le, skip_unless_feature\n\n\ndef test_sanity() -> None:\n    image = hopper()\n    converted = image.quantize()\n    assert converted.mode == \"P\"\n    assert_image_similar(converted.convert(\"RGB\"), image, 10)\n\n    image = hopper()\n    converted = image.quantize(palette=hopper(\"P\"))\n    assert converted.mode == \"P\"\n    assert_image_similar(converted.convert(\"RGB\"), image, 60)\n\n\n@skip_unless_feature(\"libimagequant\")\ndef test_libimagequant_quantize() -> None:\n    image = hopper()\n    if is_ppc64le():\n        version = features.version_feature(\"libimagequant\")\n        assert version is not None\n        if parse_version(version) < parse_version(\"4\"):\n            pytest.skip(\"Fails with libimagequant earlier than 4.0.0 on ppc64le\")\n    converted = image.quantize(100, Image.Quantize.LIBIMAGEQUANT)\n    assert converted.mode == \"P\"\n    assert_image_similar(converted.convert(\"RGB\"), image, 15)\n    assert len(converted.getcolors()) == 100\n\n\ndef test_octree_quantize() -> None:\n    image = hopper()\n    converted = image.quantize(100, Image.Quantize.FASTOCTREE)\n    assert converted.mode == \"P\"\n    assert_image_similar(converted.convert(\"RGB\"), image, 20)\n    assert len(converted.getcolors()) == 100\n\n\ndef test_rgba_quantize() -> None:\n    image = hopper(\"RGBA\")\n    with pytest.raises(ValueError):\n        image.quantize(method=0)\n\n    assert image.quantize().convert().mode == \"RGBA\"\n\n\ndef test_quantize() -> None:\n    with Image.open(\"Tests/images/caption_6_33_22.png\") as image:\n        image = image.convert(\"RGB\")\n    converted = image.quantize()\n    assert converted.mode == \"P\"\n    assert_image_similar(converted.convert(\"RGB\"), image, 1)\n\n\ndef test_quantize_no_dither() -> None:\n    image = hopper()\n    with Image.open(\"Tests/images/caption_6_33_22.png\") as palette:\n        palette = palette.convert(\"P\")\n\n    converted = image.quantize(dither=Image.Dither.NONE, palette=palette)\n    assert converted.mode == \"P\"\n    assert converted.palette.palette == palette.palette.palette\n\n\ndef test_quantize_no_dither2() -> None:\n    im = Image.new(\"RGB\", (9, 1))\n    im.putdata([(p,) * 3 for p in range(0, 36, 4)])\n\n    palette = Image.new(\"P\", (1, 1))\n    data = (0, 0, 0, 32, 32, 32)\n    palette.putpalette(data)\n    quantized = im.quantize(dither=Image.Dither.NONE, palette=palette)\n\n    assert tuple(quantized.palette.palette) == data\n\n    px = quantized.load()\n    for x in range(9):\n        assert px[x, 0] == (0 if x < 5 else 1)\n\n\ndef test_quantize_dither_diff() -> None:\n    image = hopper()\n    with Image.open(\"Tests/images/caption_6_33_22.png\") as palette:\n        palette = palette.convert(\"P\")\n\n    dither = image.quantize(dither=Image.Dither.FLOYDSTEINBERG, palette=palette)\n    nodither = image.quantize(dither=Image.Dither.NONE, palette=palette)\n\n    assert dither.tobytes() != nodither.tobytes()\n\n\n@pytest.mark.parametrize(\n    \"method\", (Image.Quantize.MEDIANCUT, Image.Quantize.MAXCOVERAGE)\n)\ndef test_quantize_kmeans(method: Image.Quantize) -> None:\n    im = hopper()\n    no_kmeans = im.quantize(kmeans=0, method=method)\n    kmeans = im.quantize(kmeans=1, method=method)\n    assert kmeans.tobytes() != no_kmeans.tobytes()\n\n    with pytest.raises(ValueError):\n        im.quantize(kmeans=-1, method=method)\n\n\ndef test_colors() -> None:\n    im = hopper()\n    colors = 2\n    converted = im.quantize(colors)\n    assert len(converted.palette.palette) == colors * len(\"RGB\")\n\n\ndef test_transparent_colors_equal() -> None:\n    im = Image.new(\"RGBA\", (1, 2), (0, 0, 0, 0))\n    px = im.load()\n    px[0, 1] = (255, 255, 255, 0)\n\n    converted = im.quantize()\n    converted_px = converted.load()\n    assert converted_px[0, 0] == converted_px[0, 1]\n\n\n@pytest.mark.parametrize(\n    \"method, color\",\n    (\n        (Image.Quantize.MEDIANCUT, (0, 0, 0)),\n        (Image.Quantize.MAXCOVERAGE, (0, 0, 0)),\n        (Image.Quantize.FASTOCTREE, (0, 0, 0)),\n        (Image.Quantize.FASTOCTREE, (0, 0, 0, 0)),\n    ),\n)\ndef test_palette(method: Image.Quantize, color: tuple[int, ...]) -> None:\n    im = Image.new(\"RGBA\" if len(color) == 4 else \"RGB\", (1, 1), color)\n\n    converted = im.quantize(method=method)\n    converted_px = converted.load()\n    assert converted_px[0, 0] == converted.palette.colors[color]\n\n\ndef test_small_palette() -> None:\n    # Arrange\n    im = hopper()\n\n    colors = (255, 0, 0, 0, 0, 255)\n    p = Image.new(\"P\", (1, 1))\n    p.putpalette(colors)\n\n    # Act\n    im = im.quantize(palette=p)\n\n    # Assert\n    assert len(im.getcolors()) == 2\n", "Tests/test_qt_image_qapplication.py": "from __future__ import annotations\n\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import Image, ImageQt\n\nfrom .helper import assert_image_equal_tofile, assert_image_similar, hopper\n\nif ImageQt.qt_is_installed:\n    from PIL.ImageQt import QPixmap\n\n    if ImageQt.qt_version == \"6\":\n        from PyQt6.QtCore import QPoint\n        from PyQt6.QtGui import QImage, QPainter, QRegion\n        from PyQt6.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget\n    elif ImageQt.qt_version == \"side6\":\n        from PySide6.QtCore import QPoint\n        from PySide6.QtGui import QImage, QPainter, QRegion\n        from PySide6.QtWidgets import QApplication, QHBoxLayout, QLabel, QWidget\n\n    class Example(QWidget):\n        def __init__(self) -> None:\n            super().__init__()\n\n            img = hopper().resize((1000, 1000))\n\n            qimage = ImageQt.ImageQt(img)\n\n            pixmap1 = ImageQt.QPixmap.fromImage(qimage)\n\n            QHBoxLayout(self)  # hbox\n\n            lbl = QLabel(self)\n            # Segfault in the problem\n            lbl.setPixmap(pixmap1.copy())\n\n\ndef roundtrip(expected: Image.Image) -> None:\n    result = ImageQt.fromqpixmap(ImageQt.toqpixmap(expected))\n    # Qt saves all pixmaps as rgb\n    assert_image_similar(result, expected.convert(\"RGB\"), 1)\n\n\n@pytest.mark.skipif(not ImageQt.qt_is_installed, reason=\"Qt bindings are not installed\")\ndef test_sanity(tmp_path: Path) -> None:\n    # Segfault test\n    app: QApplication | None = QApplication([])\n    ex = Example()\n    assert app  # Silence warning\n    assert ex  # Silence warning\n\n    for mode in (\"1\", \"RGB\", \"RGBA\", \"L\", \"P\"):\n        # to QPixmap\n        im = hopper(mode)\n        data = ImageQt.toqpixmap(im)\n\n        assert isinstance(data, QPixmap)\n        assert not data.isNull()\n\n        # Test saving the file\n        tempfile = str(tmp_path / f\"temp_{mode}.png\")\n        data.save(tempfile)\n\n        # Render the image\n        qimage = ImageQt.ImageQt(im)\n        data = QPixmap.fromImage(qimage)\n        qt_format = QImage.Format if ImageQt.qt_version == \"6\" else QImage\n        qimage = QImage(128, 128, qt_format.Format_ARGB32)\n        painter = QPainter(qimage)\n        image_label = QLabel()\n        image_label.setPixmap(data)\n        image_label.render(painter, QPoint(0, 0), QRegion(0, 0, 128, 128))\n        painter.end()\n        rendered_tempfile = str(tmp_path / f\"temp_rendered_{mode}.png\")\n        qimage.save(rendered_tempfile)\n        assert_image_equal_tofile(im.convert(\"RGBA\"), rendered_tempfile)\n\n        # from QPixmap\n        roundtrip(hopper(mode))\n\n    app.quit()\n    app = None\n", "Tests/test_webp_leaks.py": "from __future__ import annotations\n\nfrom io import BytesIO\n\nfrom PIL import Image\n\nfrom .helper import PillowLeakTestCase, skip_unless_feature\n\ntest_file = \"Tests/images/hopper.webp\"\n\n\n@skip_unless_feature(\"webp\")\nclass TestWebPLeaks(PillowLeakTestCase):\n    mem_limit = 3 * 1024  # kb\n    iterations = 100\n\n    def test_leak_load(self) -> None:\n        with open(test_file, \"rb\") as f:\n            im_data = f.read()\n\n        def core() -> None:\n            with Image.open(BytesIO(im_data)) as im:\n                im.load()\n\n        self._test_leak(core)\n", "Tests/test_image_rotate.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_equal_tofile,\n    assert_image_similar,\n    hopper,\n)\n\n\ndef rotate(\n    im: Image.Image,\n    mode: str,\n    angle: int,\n    center: tuple[int, int] | None = None,\n    translate: tuple[int, int] | None = None,\n) -> None:\n    out = im.rotate(angle, center=center, translate=translate)\n    assert out.mode == mode\n    assert out.size == im.size  # default rotate clips output\n    out = im.rotate(angle, center=center, translate=translate, expand=1)\n    assert out.mode == mode\n    if angle % 180 == 0:\n        assert out.size == im.size\n    elif im.size == (0, 0):\n        assert out.size == im.size\n    else:\n        assert out.size != im.size\n\n\n@pytest.mark.parametrize(\"mode\", (\"1\", \"P\", \"L\", \"RGB\", \"I\", \"F\"))\ndef test_mode(mode: str) -> None:\n    im = hopper(mode)\n    rotate(im, mode, 45)\n\n\n@pytest.mark.parametrize(\"angle\", (0, 90, 180, 270))\ndef test_angle(angle: int) -> None:\n    with Image.open(\"Tests/images/test-card.png\") as im:\n        rotate(im, im.mode, angle)\n\n    im = hopper()\n    assert_image_equal(im.rotate(angle), im.rotate(angle, expand=1))\n\n\n@pytest.mark.parametrize(\"angle\", (0, 45, 90, 180, 270))\ndef test_zero(angle: int) -> None:\n    im = Image.new(\"RGB\", (0, 0))\n    rotate(im, im.mode, angle)\n\n\ndef test_resample() -> None:\n    # Target image creation, inspected by eye.\n    # >>> im = Image.open('Tests/images/hopper.ppm')\n    # >>> im = im.rotate(45, resample=Image.Resampling.BICUBIC, expand=True)\n    # >>> im.save('Tests/images/hopper_45.png')\n\n    with Image.open(\"Tests/images/hopper_45.png\") as target:\n        for resample, epsilon in (\n            (Image.Resampling.NEAREST, 10),\n            (Image.Resampling.BILINEAR, 5),\n            (Image.Resampling.BICUBIC, 0),\n        ):\n            im = hopper()\n            im = im.rotate(45, resample=resample, expand=True)\n            assert_image_similar(im, target, epsilon)\n\n\ndef test_center_0() -> None:\n    im = hopper()\n    im = im.rotate(45, center=(0, 0), resample=Image.Resampling.BICUBIC)\n\n    with Image.open(\"Tests/images/hopper_45.png\") as target:\n        target_origin = target.size[1] / 2\n        target = target.crop((0, target_origin, 128, target_origin + 128))\n\n    assert_image_similar(im, target, 15)\n\n\ndef test_center_14() -> None:\n    im = hopper()\n    im = im.rotate(45, center=(14, 14), resample=Image.Resampling.BICUBIC)\n\n    with Image.open(\"Tests/images/hopper_45.png\") as target:\n        target_origin = target.size[1] / 2 - 14\n        target = target.crop((6, target_origin, 128 + 6, target_origin + 128))\n\n        assert_image_similar(im, target, 10)\n\n\ndef test_translate() -> None:\n    im = hopper()\n    with Image.open(\"Tests/images/hopper_45.png\") as target:\n        target_origin = (target.size[1] / 2 - 64) - 5\n        target = target.crop(\n            (target_origin, target_origin, target_origin + 128, target_origin + 128)\n        )\n\n    im = im.rotate(45, translate=(5, 5), resample=Image.Resampling.BICUBIC)\n\n    assert_image_similar(im, target, 1)\n\n\ndef test_fastpath_center() -> None:\n    # if the center is -1,-1 and we rotate by 90<=x<=270 the\n    # resulting image should be black\n    for angle in (90, 180, 270):\n        im = hopper().rotate(angle, center=(-1, -1))\n        assert_image_equal(im, Image.new(\"RGB\", im.size, \"black\"))\n\n\ndef test_fastpath_translate() -> None:\n    # if we post-translate by -128\n    # resulting image should be black\n    for angle in (0, 90, 180, 270):\n        im = hopper().rotate(angle, translate=(-128, -128))\n        assert_image_equal(im, Image.new(\"RGB\", im.size, \"black\"))\n\n\ndef test_center() -> None:\n    im = hopper()\n    rotate(im, im.mode, 45, center=(0, 0))\n    rotate(im, im.mode, 45, translate=(im.size[0] // 2, 0))\n    rotate(im, im.mode, 45, center=(0, 0), translate=(im.size[0] // 2, 0))\n\n\ndef test_rotate_no_fill() -> None:\n    im = Image.new(\"RGB\", (100, 100), \"green\")\n    im = im.rotate(45)\n    assert_image_equal_tofile(im, \"Tests/images/rotate_45_no_fill.png\")\n\n\ndef test_rotate_with_fill() -> None:\n    im = Image.new(\"RGB\", (100, 100), \"green\")\n    im = im.rotate(45, fillcolor=\"white\")\n    assert_image_equal_tofile(im, \"Tests/images/rotate_45_with_fill.png\")\n\n\ndef test_alpha_rotate_no_fill() -> None:\n    # Alpha images are handled differently internally\n    im = Image.new(\"RGBA\", (10, 10), \"green\")\n    im = im.rotate(45, expand=1)\n    corner = im.getpixel((0, 0))\n    assert corner == (0, 0, 0, 0)\n\n\ndef test_alpha_rotate_with_fill() -> None:\n    # Alpha images are handled differently internally\n    im = Image.new(\"RGBA\", (10, 10), \"green\")\n    im = im.rotate(45, expand=1, fillcolor=(255, 0, 0, 255))\n    corner = im.getpixel((0, 0))\n    assert corner == (255, 0, 0, 255)\n", "Tests/test_image_resample.py": "from __future__ import annotations\n\nfrom contextlib import contextmanager\nfrom typing import Generator\n\nimport pytest\n\nfrom PIL import Image, ImageDraw\n\nfrom .helper import (\n    assert_image_equal,\n    assert_image_similar,\n    hopper,\n    mark_if_feature_version,\n)\n\n\nclass TestImagingResampleVulnerability:\n    # see https://github.com/python-pillow/Pillow/issues/1710\n    def test_overflow(self) -> None:\n        im = hopper(\"L\")\n        size_too_large = 0x100000008 // 4\n        size_normal = 1000  # unimportant\n        for xsize, ysize in (\n            (size_too_large, size_normal),\n            (size_normal, size_too_large),\n        ):\n            with pytest.raises(MemoryError):\n                # any resampling filter will do here\n                im.im.resize((xsize, ysize), Image.Resampling.BILINEAR)\n\n    def test_invalid_size(self) -> None:\n        im = hopper()\n\n        # Should not crash\n        im.resize((100, 100))\n\n        with pytest.raises(ValueError):\n            im.resize((-100, 100))\n\n        with pytest.raises(ValueError):\n            im.resize((100, -100))\n\n    def test_modify_after_resizing(self) -> None:\n        im = hopper(\"RGB\")\n        # get copy with same size\n        copy = im.resize(im.size)\n        # some in-place operation\n        copy.paste(\"black\", (0, 0, im.width // 2, im.height // 2))\n        # image should be different\n        assert im.tobytes() != copy.tobytes()\n\n\nclass TestImagingCoreResampleAccuracy:\n    def make_case(self, mode: str, size: tuple[int, int], color: int) -> Image.Image:\n        \"\"\"Makes a sample image with two dark and two bright squares.\n        For example:\n        e0 e0 1f 1f\n        e0 e0 1f 1f\n        1f 1f e0 e0\n        1f 1f e0 e0\n        \"\"\"\n        case = Image.new(\"L\", size, 255 - color)\n        rectangle = ImageDraw.Draw(case).rectangle\n        rectangle((0, 0, size[0] // 2 - 1, size[1] // 2 - 1), color)\n        rectangle((size[0] // 2, size[1] // 2, size[0], size[1]), color)\n\n        return Image.merge(mode, [case] * len(mode))\n\n    def make_sample(self, data: str, size: tuple[int, int]) -> Image.Image:\n        \"\"\"Restores a sample image from given data string which contains\n        hex-encoded pixels from the top left fourth of a sample.\n        \"\"\"\n        data = data.replace(\" \", \"\")\n        sample = Image.new(\"L\", size)\n        s_px = sample.load()\n        w, h = size[0] // 2, size[1] // 2\n        for y in range(h):\n            for x in range(w):\n                val = int(data[(y * w + x) * 2 : (y * w + x + 1) * 2], 16)\n                s_px[x, y] = val\n                s_px[size[0] - x - 1, size[1] - y - 1] = val\n                s_px[x, size[1] - y - 1] = 255 - val\n                s_px[size[0] - x - 1, y] = 255 - val\n        return sample\n\n    def check_case(self, case: Image.Image, sample: Image.Image) -> None:\n        s_px = sample.load()\n        c_px = case.load()\n        for y in range(case.size[1]):\n            for x in range(case.size[0]):\n                if c_px[x, y] != s_px[x, y]:\n                    message = (\n                        f\"\\nHave: \\n{self.serialize_image(case)}\\n\"\n                        f\"\\nExpected: \\n{self.serialize_image(sample)}\"\n                    )\n                    assert s_px[x, y] == c_px[x, y], message\n\n    def serialize_image(self, image: Image.Image) -> str:\n        s_px = image.load()\n        return \"\\n\".join(\n            \" \".join(f\"{s_px[x, y]:02x}\" for x in range(image.size[0]))\n            for y in range(image.size[1])\n        )\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_reduce_box(self, mode: str) -> None:\n        case = self.make_case(mode, (8, 8), 0xE1)\n        case = case.resize((4, 4), Image.Resampling.BOX)\n        # fmt: off\n        data = (\"e1 e1\"\n                \"e1 e1\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (4, 4)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_reduce_bilinear(self, mode: str) -> None:\n        case = self.make_case(mode, (8, 8), 0xE1)\n        case = case.resize((4, 4), Image.Resampling.BILINEAR)\n        # fmt: off\n        data = (\"e1 c9\"\n                \"c9 b7\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (4, 4)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_reduce_hamming(self, mode: str) -> None:\n        case = self.make_case(mode, (8, 8), 0xE1)\n        case = case.resize((4, 4), Image.Resampling.HAMMING)\n        # fmt: off\n        data = (\"e1 da\"\n                \"da d3\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (4, 4)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_reduce_bicubic(self, mode: str) -> None:\n        case = self.make_case(mode, (12, 12), 0xE1)\n        case = case.resize((6, 6), Image.Resampling.BICUBIC)\n        # fmt: off\n        data = (\"e1 e3 d4\"\n                \"e3 e5 d6\"\n                \"d4 d6 c9\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (6, 6)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_reduce_lanczos(self, mode: str) -> None:\n        case = self.make_case(mode, (16, 16), 0xE1)\n        case = case.resize((8, 8), Image.Resampling.LANCZOS)\n        # fmt: off\n        data = (\"e1 e0 e4 d7\"\n                \"e0 df e3 d6\"\n                \"e4 e3 e7 da\"\n                \"d7 d6 d9 ce\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (8, 8)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_enlarge_box(self, mode: str) -> None:\n        case = self.make_case(mode, (2, 2), 0xE1)\n        case = case.resize((4, 4), Image.Resampling.BOX)\n        # fmt: off\n        data = (\"e1 e1\"\n                \"e1 e1\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (4, 4)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_enlarge_bilinear(self, mode: str) -> None:\n        case = self.make_case(mode, (2, 2), 0xE1)\n        case = case.resize((4, 4), Image.Resampling.BILINEAR)\n        # fmt: off\n        data = (\"e1 b0\"\n                \"b0 98\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (4, 4)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_enlarge_hamming(self, mode: str) -> None:\n        case = self.make_case(mode, (2, 2), 0xE1)\n        case = case.resize((4, 4), Image.Resampling.HAMMING)\n        # fmt: off\n        data = (\"e1 d2\"\n                \"d2 c5\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (4, 4)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_enlarge_bicubic(self, mode: str) -> None:\n        case = self.make_case(mode, (4, 4), 0xE1)\n        case = case.resize((8, 8), Image.Resampling.BICUBIC)\n        # fmt: off\n        data = (\"e1 e5 ee b9\"\n                \"e5 e9 f3 bc\"\n                \"ee f3 fd c1\"\n                \"b9 bc c1 a2\")\n        # fmt: on\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (8, 8)))\n\n    @pytest.mark.parametrize(\"mode\", (\"RGBX\", \"RGB\", \"La\", \"L\"))\n    def test_enlarge_lanczos(self, mode: str) -> None:\n        case = self.make_case(mode, (6, 6), 0xE1)\n        case = case.resize((12, 12), Image.Resampling.LANCZOS)\n        data = (\n            \"e1 e0 db ed f5 b8\"\n            \"e0 df da ec f3 b7\"\n            \"db db d6 e7 ee b5\"\n            \"ed ec e6 fb ff bf\"\n            \"f5 f4 ee ff ff c4\"\n            \"b8 b7 b4 bf c4 a0\"\n        )\n        for channel in case.split():\n            self.check_case(channel, self.make_sample(data, (12, 12)))\n\n    def test_box_filter_correct_range(self) -> None:\n        im = Image.new(\"RGB\", (8, 8), \"#1688ff\").resize(\n            (100, 100), Image.Resampling.BOX\n        )\n        ref = Image.new(\"RGB\", (100, 100), \"#1688ff\")\n        assert_image_equal(im, ref)\n\n\nclass TestCoreResampleConsistency:\n    def make_case(\n        self, mode: str, fill: tuple[int, int, int] | float\n    ) -> tuple[Image.Image, tuple[int, ...]]:\n        im = Image.new(mode, (512, 9), fill)\n        return im.resize((9, 512), Image.Resampling.LANCZOS), im.load()[0, 0]\n\n    def run_case(self, case: tuple[Image.Image, int | tuple[int, ...]]) -> None:\n        channel, color = case\n        px = channel.load()\n        for x in range(channel.size[0]):\n            for y in range(channel.size[1]):\n                if px[x, y] != color:\n                    message = f\"{px[x, y]} != {color} for pixel {(x, y)}\"\n                    assert px[x, y] == color, message\n\n    def test_8u(self) -> None:\n        im, color = self.make_case(\"RGB\", (0, 64, 255))\n        r, g, b = im.split()\n        self.run_case((r, color[0]))\n        self.run_case((g, color[1]))\n        self.run_case((b, color[2]))\n        self.run_case(self.make_case(\"L\", 12))\n\n    def test_32i(self) -> None:\n        self.run_case(self.make_case(\"I\", 12))\n        self.run_case(self.make_case(\"I\", 0x7FFFFFFF))\n        self.run_case(self.make_case(\"I\", -12))\n        self.run_case(self.make_case(\"I\", -1 << 31))\n\n    def test_32f(self) -> None:\n        self.run_case(self.make_case(\"F\", 1))\n        self.run_case(self.make_case(\"F\", 3.40282306074e38))\n        self.run_case(self.make_case(\"F\", 1.175494e-38))\n        self.run_case(self.make_case(\"F\", 1.192093e-07))\n\n\nclass TestCoreResampleAlphaCorrect:\n    def make_levels_case(self, mode: str) -> Image.Image:\n        i = Image.new(mode, (256, 16))\n        px = i.load()\n        for y in range(i.size[1]):\n            for x in range(i.size[0]):\n                pix = [x] * len(mode)\n                pix[-1] = 255 - y * 16\n                px[x, y] = tuple(pix)\n        return i\n\n    def run_levels_case(self, i: Image.Image) -> None:\n        px = i.load()\n        for y in range(i.size[1]):\n            used_colors = {px[x, y][0] for x in range(i.size[0])}\n            assert 256 == len(used_colors), (\n                \"All colors should be present in resized image. \"\n                f\"Only {len(used_colors)} on line {y}.\"\n            )\n\n    @pytest.mark.xfail(reason=\"Current implementation isn't precise enough\")\n    def test_levels_rgba(self) -> None:\n        case = self.make_levels_case(\"RGBA\")\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.BOX))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.BILINEAR))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.HAMMING))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.BICUBIC))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.LANCZOS))\n\n    @pytest.mark.xfail(reason=\"Current implementation isn't precise enough\")\n    def test_levels_la(self) -> None:\n        case = self.make_levels_case(\"LA\")\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.BOX))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.BILINEAR))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.HAMMING))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.BICUBIC))\n        self.run_levels_case(case.resize((512, 32), Image.Resampling.LANCZOS))\n\n    def make_dirty_case(\n        self, mode: str, clean_pixel: tuple[int, ...], dirty_pixel: tuple[int, ...]\n    ) -> Image.Image:\n        i = Image.new(mode, (64, 64), dirty_pixel)\n        px = i.load()\n        xdiv4 = i.size[0] // 4\n        ydiv4 = i.size[1] // 4\n        for y in range(ydiv4 * 2):\n            for x in range(xdiv4 * 2):\n                px[x + xdiv4, y + ydiv4] = clean_pixel\n        return i\n\n    def run_dirty_case(self, i: Image.Image, clean_pixel: tuple[int, ...]) -> None:\n        px = i.load()\n        for y in range(i.size[1]):\n            for x in range(i.size[0]):\n                if px[x, y][-1] != 0 and px[x, y][:-1] != clean_pixel:\n                    message = (\n                        f\"pixel at ({x}, {y}) is different:\\n\"\n                        f\"{px[x, y]}\\n{clean_pixel}\"\n                    )\n                    assert px[x, y][:3] == clean_pixel, message\n\n    def test_dirty_pixels_rgba(self) -> None:\n        case = self.make_dirty_case(\"RGBA\", (255, 255, 0, 128), (0, 0, 255, 0))\n        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BOX), (255, 255, 0))\n        self.run_dirty_case(\n            case.resize((20, 20), Image.Resampling.BILINEAR), (255, 255, 0)\n        )\n        self.run_dirty_case(\n            case.resize((20, 20), Image.Resampling.HAMMING), (255, 255, 0)\n        )\n        self.run_dirty_case(\n            case.resize((20, 20), Image.Resampling.BICUBIC), (255, 255, 0)\n        )\n        self.run_dirty_case(\n            case.resize((20, 20), Image.Resampling.LANCZOS), (255, 255, 0)\n        )\n\n    def test_dirty_pixels_la(self) -> None:\n        case = self.make_dirty_case(\"LA\", (255, 128), (0, 0))\n        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BOX), (255,))\n        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BILINEAR), (255,))\n        self.run_dirty_case(case.resize((20, 20), Image.Resampling.HAMMING), (255,))\n        self.run_dirty_case(case.resize((20, 20), Image.Resampling.BICUBIC), (255,))\n        self.run_dirty_case(case.resize((20, 20), Image.Resampling.LANCZOS), (255,))\n\n\nclass TestCoreResamplePasses:\n    @contextmanager\n    def count(self, diff: int) -> Generator[None, None, None]:\n        count = Image.core.get_stats()[\"new_count\"]\n        yield\n        assert Image.core.get_stats()[\"new_count\"] - count == diff\n\n    def test_horizontal(self) -> None:\n        im = hopper(\"L\")\n        with self.count(1):\n            im.resize((im.size[0] - 10, im.size[1]), Image.Resampling.BILINEAR)\n\n    def test_vertical(self) -> None:\n        im = hopper(\"L\")\n        with self.count(1):\n            im.resize((im.size[0], im.size[1] - 10), Image.Resampling.BILINEAR)\n\n    def test_both(self) -> None:\n        im = hopper(\"L\")\n        with self.count(2):\n            im.resize((im.size[0] - 10, im.size[1] - 10), Image.Resampling.BILINEAR)\n\n    def test_box_horizontal(self) -> None:\n        im = hopper(\"L\")\n        box = (20, 0, im.size[0] - 20, im.size[1])\n        with self.count(1):\n            # the same size, but different box\n            with_box = im.resize(im.size, Image.Resampling.BILINEAR, box)\n        with self.count(2):\n            cropped = im.crop(box).resize(im.size, Image.Resampling.BILINEAR)\n        assert_image_similar(with_box, cropped, 0.1)\n\n    def test_box_vertical(self) -> None:\n        im = hopper(\"L\")\n        box = (0, 20, im.size[0], im.size[1] - 20)\n        with self.count(1):\n            # the same size, but different box\n            with_box = im.resize(im.size, Image.Resampling.BILINEAR, box)\n        with self.count(2):\n            cropped = im.crop(box).resize(im.size, Image.Resampling.BILINEAR)\n        assert_image_similar(with_box, cropped, 0.1)\n\n\nclass TestCoreResampleCoefficients:\n    def test_reduce(self) -> None:\n        test_color = 254\n\n        for size in range(400000, 400010, 2):\n            i = Image.new(\"L\", (size, 1), 0)\n            draw = ImageDraw.Draw(i)\n            draw.rectangle((0, 0, i.size[0] // 2 - 1, 0), test_color)\n\n            px = i.resize((5, i.size[1]), Image.Resampling.BICUBIC).load()\n            if px[2, 0] != test_color // 2:\n                assert test_color // 2 == px[2, 0]\n\n    def test_non_zero_coefficients(self) -> None:\n        # regression test for the wrong coefficients calculation\n        # due to bug https://github.com/python-pillow/Pillow/issues/2161\n        im = Image.new(\"RGBA\", (1280, 1280), (0x20, 0x40, 0x60, 0xFF))\n        histogram = im.resize((256, 256), Image.Resampling.BICUBIC).histogram()\n\n        # first channel\n        assert histogram[0x100 * 0 + 0x20] == 0x10000\n        # second channel\n        assert histogram[0x100 * 1 + 0x40] == 0x10000\n        # third channel\n        assert histogram[0x100 * 2 + 0x60] == 0x10000\n        # fourth channel\n        assert histogram[0x100 * 3 + 0xFF] == 0x10000\n\n\nclass TestCoreResampleBox:\n    @pytest.mark.parametrize(\n        \"resample\",\n        (\n            Image.Resampling.NEAREST,\n            Image.Resampling.BOX,\n            Image.Resampling.BILINEAR,\n            Image.Resampling.HAMMING,\n            Image.Resampling.BICUBIC,\n            Image.Resampling.LANCZOS,\n        ),\n    )\n    def test_wrong_arguments(self, resample: Image.Resampling) -> None:\n        im = hopper()\n        im.resize((32, 32), resample, (0, 0, im.width, im.height))\n        im.resize((32, 32), resample, (20, 20, im.width, im.height))\n        im.resize((32, 32), resample, (20, 20, 20, 100))\n        im.resize((32, 32), resample, (20, 20, 100, 20))\n\n        with pytest.raises(TypeError, match=\"must be sequence of length 4\"):\n            im.resize((32, 32), resample, (im.width, im.height))  # type: ignore[arg-type]\n\n        with pytest.raises(ValueError, match=\"can't be negative\"):\n            im.resize((32, 32), resample, (-20, 20, 100, 100))\n        with pytest.raises(ValueError, match=\"can't be negative\"):\n            im.resize((32, 32), resample, (20, -20, 100, 100))\n\n        with pytest.raises(ValueError, match=\"can't be empty\"):\n            im.resize((32, 32), resample, (20.1, 20, 20, 100))\n        with pytest.raises(ValueError, match=\"can't be empty\"):\n            im.resize((32, 32), resample, (20, 20.1, 100, 20))\n        with pytest.raises(ValueError, match=\"can't be empty\"):\n            im.resize((32, 32), resample, (20.1, 20.1, 20, 20))\n\n        with pytest.raises(ValueError, match=\"can't exceed\"):\n            im.resize((32, 32), resample, (0, 0, im.width + 1, im.height))\n        with pytest.raises(ValueError, match=\"can't exceed\"):\n            im.resize((32, 32), resample, (0, 0, im.width, im.height + 1))\n\n    def resize_tiled(\n        self, im: Image.Image, dst_size: tuple[int, int], xtiles: int, ytiles: int\n    ) -> Image.Image:\n        def split_range(\n            size: int, tiles: int\n        ) -> Generator[tuple[int, int], None, None]:\n            scale = size / tiles\n            for i in range(tiles):\n                yield int(round(scale * i)), int(round(scale * (i + 1)))\n\n        tiled = Image.new(im.mode, dst_size)\n        scale = (im.size[0] / tiled.size[0], im.size[1] / tiled.size[1])\n\n        for y0, y1 in split_range(dst_size[1], ytiles):\n            for x0, x1 in split_range(dst_size[0], xtiles):\n                box = (x0 * scale[0], y0 * scale[1], x1 * scale[0], y1 * scale[1])\n                tile = im.resize((x1 - x0, y1 - y0), Image.Resampling.BICUBIC, box)\n                tiled.paste(tile, (x0, y0))\n        return tiled\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_tiles(self) -> None:\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            assert im.size == (480, 360)\n            dst_size = (251, 188)\n            reference = im.resize(dst_size, Image.Resampling.BICUBIC)\n\n            for tiles in [(1, 1), (3, 3), (9, 7), (100, 100)]:\n                tiled = self.resize_tiled(im, dst_size, *tiles)\n                assert_image_similar(reference, tiled, 0.01)\n\n    @mark_if_feature_version(\n        pytest.mark.valgrind_known_error, \"libjpeg_turbo\", \"2.0\", reason=\"Known Failing\"\n    )\n    def test_subsample(self) -> None:\n        # This test shows advantages of the subpixel resizing\n        # after supersampling (e.g. during JPEG decoding).\n        with Image.open(\"Tests/images/flower.jpg\") as im:\n            assert im.size == (480, 360)\n            dst_size = (48, 36)\n            # Reference is cropped image resized to destination\n            reference = im.crop((0, 0, 473, 353)).resize(\n                dst_size, Image.Resampling.BICUBIC\n            )\n            # Image.Resampling.BOX emulates supersampling (480 / 8 = 60, 360 / 8 = 45)\n            supersampled = im.resize((60, 45), Image.Resampling.BOX)\n\n        with_box = supersampled.resize(\n            dst_size, Image.Resampling.BICUBIC, (0, 0, 59.125, 44.125)\n        )\n        without_box = supersampled.resize(dst_size, Image.Resampling.BICUBIC)\n\n        # error with box should be much smaller than without\n        assert_image_similar(reference, with_box, 6)\n        with pytest.raises(AssertionError, match=r\"difference 29\\.\"):\n            assert_image_similar(reference, without_box, 5)\n\n    @pytest.mark.parametrize(\"mode\", (\"RGB\", \"L\", \"RGBA\", \"LA\", \"I\", \"\"))\n    @pytest.mark.parametrize(\n        \"resample\", (Image.Resampling.NEAREST, Image.Resampling.BILINEAR)\n    )\n    def test_formats(self, mode: str, resample: Image.Resampling) -> None:\n        im = hopper(mode)\n        box = (20, 20, im.size[0] - 20, im.size[1] - 20)\n        with_box = im.resize((32, 32), resample, box)\n        cropped = im.crop(box).resize((32, 32), resample)\n        assert_image_similar(cropped, with_box, 0.4)\n\n    def test_passthrough(self) -> None:\n        # When no resize is required\n        im = hopper()\n\n        for size, box in [\n            ((40, 50), (0, 0, 40, 50)),\n            ((40, 50), (0, 10, 40, 60)),\n            ((40, 50), (10, 0, 50, 50)),\n            ((40, 50), (10, 20, 50, 70)),\n        ]:\n            res = im.resize(size, Image.Resampling.LANCZOS, box)\n            assert res.size == size\n            assert_image_equal(res, im.crop(box), f\">>> {size} {box}\")\n\n    def test_no_passthrough(self) -> None:\n        # When resize is required\n        im = hopper()\n\n        for size, box in [\n            ((40, 50), (0.4, 0.4, 40.4, 50.4)),\n            ((40, 50), (0.4, 10.4, 40.4, 60.4)),\n            ((40, 50), (10.4, 0.4, 50.4, 50.4)),\n            ((40, 50), (10.4, 20.4, 50.4, 70.4)),\n        ]:\n            res = im.resize(size, Image.Resampling.LANCZOS, box)\n            assert res.size == size\n            with pytest.raises(AssertionError, match=r\"difference \\d\"):\n                # check that the difference at least that much\n                assert_image_similar(res, im.crop(box), 20, f\">>> {size} {box}\")\n\n    @pytest.mark.parametrize(\n        \"flt\", (Image.Resampling.NEAREST, Image.Resampling.BICUBIC)\n    )\n    def test_skip_horizontal(self, flt: Image.Resampling) -> None:\n        # Can skip resize for one dimension\n        im = hopper()\n\n        for size, box in [\n            ((40, 50), (0, 0, 40, 90)),\n            ((40, 50), (0, 20, 40, 90)),\n            ((40, 50), (10, 0, 50, 90)),\n            ((40, 50), (10, 20, 50, 90)),\n        ]:\n            res = im.resize(size, flt, box)\n            assert res.size == size\n            # Borders should be slightly different\n            assert_image_similar(\n                res,\n                im.crop(box).resize(size, flt),\n                0.4,\n                f\">>> {size} {box} {flt}\",\n            )\n\n    @pytest.mark.parametrize(\n        \"flt\", (Image.Resampling.NEAREST, Image.Resampling.BICUBIC)\n    )\n    def test_skip_vertical(self, flt: Image.Resampling) -> None:\n        # Can skip resize for one dimension\n        im = hopper()\n\n        for size, box in [\n            ((40, 50), (0, 0, 90, 50)),\n            ((40, 50), (20, 0, 90, 50)),\n            ((40, 50), (0, 10, 90, 60)),\n            ((40, 50), (20, 10, 90, 60)),\n        ]:\n            res = im.resize(size, flt, box)\n            assert res.size == size\n            # Borders should be slightly different\n            assert_image_similar(\n                res,\n                im.crop(box).resize(size, flt),\n                0.4,\n                f\">>> {size} {box} {flt}\",\n            )\n", "Tests/test_sgi_crash.py": "from __future__ import annotations\n\nimport pytest\n\nfrom PIL import Image\n\n\n@pytest.mark.parametrize(\n    \"test_file\",\n    [\n        \"Tests/images/sgi_overrun_expandrowF04.bin\",\n        \"Tests/images/sgi_crash.bin\",\n        \"Tests/images/crash-6b7f2244da6d0ae297ee0754a424213444e92778.sgi\",\n        \"Tests/images/ossfuzz-5730089102868480.sgi\",\n        \"Tests/images/crash-754d9c7ec485ffb76a90eeaab191ef69a2a3a3cd.sgi\",\n        \"Tests/images/crash-465703f71a0f0094873a3e0e82c9f798161171b8.sgi\",\n        \"Tests/images/crash-64834657ee604b8797bf99eac6a194c124a9a8ba.sgi\",\n        \"Tests/images/crash-abcf1c97b8fe42a6c68f1fb0b978530c98d57ced.sgi\",\n        \"Tests/images/crash-b82e64d4f3f76d7465b6af535283029eda211259.sgi\",\n        \"Tests/images/crash-c1b2595b8b0b92cc5f38b6635e98e3a119ade807.sgi\",\n        \"Tests/images/crash-db8bfa78b19721225425530c5946217720d7df4e.sgi\",\n    ],\n)\ndef test_crashes(test_file: str) -> None:\n    with open(test_file, \"rb\") as f:\n        with Image.open(f) as im:\n            with pytest.raises(OSError):\n                im.load()\n", "Tests/test_file_icns.py": "from __future__ import annotations\n\nimport io\nimport os\nimport warnings\nfrom pathlib import Path\n\nimport pytest\n\nfrom PIL import IcnsImagePlugin, Image, _binary\n\nfrom .helper import assert_image_equal, assert_image_similar_tofile, skip_unless_feature\n\n# sample icon file\nTEST_FILE = \"Tests/images/pillow.icns\"\n\n\ndef test_sanity() -> None:\n    # Loading this icon by default should result in the largest size\n    # (512x512@2x) being loaded\n    with Image.open(TEST_FILE) as im:\n        # Assert that there is no unclosed file warning\n        with warnings.catch_warnings():\n            im.load()\n\n        assert im.mode == \"RGBA\"\n        assert im.size == (1024, 1024)\n        assert im.format == \"ICNS\"\n\n\ndef test_load() -> None:\n    with Image.open(TEST_FILE) as im:\n        assert im.load()[0, 0] == (0, 0, 0, 0)\n\n        # Test again now that it has already been loaded once\n        assert im.load()[0, 0] == (0, 0, 0, 0)\n\n\ndef test_save(tmp_path: Path) -> None:\n    temp_file = str(tmp_path / \"temp.icns\")\n\n    with Image.open(TEST_FILE) as im:\n        im.save(temp_file)\n\n    with Image.open(temp_file) as reread:\n        assert reread.mode == \"RGBA\"\n        assert reread.size == (1024, 1024)\n        assert reread.format == \"ICNS\"\n\n    file_length = os.path.getsize(temp_file)\n    with open(temp_file, \"rb\") as fp:\n        fp.seek(4)\n        assert _binary.i32be(fp.read(4)) == file_length\n\n\ndef test_save_append_images(tmp_path: Path) -> None:\n    temp_file = str(tmp_path / \"temp.icns\")\n    provided_im = Image.new(\"RGBA\", (32, 32), (255, 0, 0, 128))\n\n    with Image.open(TEST_FILE) as im:\n        im.save(temp_file, append_images=[provided_im])\n\n        assert_image_similar_tofile(im, temp_file, 1)\n\n        with Image.open(temp_file) as reread:\n            reread.size = (16, 16, 2)\n            reread.load()\n            assert_image_equal(reread, provided_im)\n\n\ndef test_save_fp() -> None:\n    fp = io.BytesIO()\n\n    with Image.open(TEST_FILE) as im:\n        im.save(fp, format=\"ICNS\")\n\n    with Image.open(fp) as reread:\n        assert reread.mode == \"RGBA\"\n        assert reread.size == (1024, 1024)\n        assert reread.format == \"ICNS\"\n\n\ndef test_sizes() -> None:\n    # Check that we can load all of the sizes, and that the final pixel\n    # dimensions are as expected\n    with Image.open(TEST_FILE) as im:\n        for w, h, r in im.info[\"sizes\"]:\n            wr = w * r\n            hr = h * r\n            im.size = (w, h, r)\n            im.load()\n            assert im.mode == \"RGBA\"\n            assert im.size == (wr, hr)\n\n        # Check that we cannot load an incorrect size\n        with pytest.raises(ValueError):\n            im.size = (1, 1)\n\n\ndef test_older_icon() -> None:\n    # This icon was made with Icon Composer rather than iconutil; it still\n    # uses PNG rather than JP2, however (since it was made on 10.9).\n    with Image.open(\"Tests/images/pillow2.icns\") as im:\n        for w, h, r in im.info[\"sizes\"]:\n            wr = w * r\n            hr = h * r\n            with Image.open(\"Tests/images/pillow2.icns\") as im2:\n                im2.size = (w, h, r)\n                im2.load()\n                assert im2.mode == \"RGBA\"\n                assert im2.size == (wr, hr)\n\n\n@skip_unless_feature(\"jpg_2000\")\ndef test_jp2_icon() -> None:\n    # This icon uses JPEG 2000 images instead of the PNG images.\n    # The advantage of doing this is that OS X 10.5 supports JPEG 2000\n    # but not PNG; some commercial software therefore does just this.\n\n    with Image.open(\"Tests/images/pillow3.icns\") as im:\n        for w, h, r in im.info[\"sizes\"]:\n            wr = w * r\n            hr = h * r\n            with Image.open(\"Tests/images/pillow3.icns\") as im2:\n                im2.size = (w, h, r)\n                im2.load()\n                assert im2.mode == \"RGBA\"\n                assert im2.size == (wr, hr)\n\n\ndef test_getimage() -> None:\n    with open(TEST_FILE, \"rb\") as fp:\n        icns_file = IcnsImagePlugin.IcnsFile(fp)\n\n        im = icns_file.getimage()\n        assert im.mode == \"RGBA\"\n        assert im.size == (1024, 1024)\n\n        im = icns_file.getimage((512, 512))\n        assert im.mode == \"RGBA\"\n        assert im.size == (512, 512)\n\n\ndef test_not_an_icns_file() -> None:\n    with io.BytesIO(b\"invalid\\n\") as fp:\n        with pytest.raises(SyntaxError):\n            IcnsImagePlugin.IcnsFile(fp)\n\n\n@skip_unless_feature(\"jpg_2000\")\ndef test_icns_decompression_bomb() -> None:\n    with Image.open(\n        \"Tests/images/oom-8ed3316a4109213ca96fb8a256a0bfefdece1461.icns\"\n    ) as im:\n        with pytest.raises(Image.DecompressionBombError):\n            im.load()\n", "Tests/oss-fuzz/fuzz_pillow.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport atheris\n\nwith atheris.instrument_imports():\n    import sys\n\n    import fuzzers\n\n\ndef TestOneInput(data: bytes) -> None:\n    try:\n        fuzzers.fuzz_image(data)\n    except Exception:\n        # We're catching all exceptions because Pillow's exceptions are\n        # directly inheriting from Exception.\n        pass\n\n\ndef main() -> None:\n    fuzzers.enable_decompressionbomb_error()\n    atheris.Setup(sys.argv, TestOneInput)\n    atheris.Fuzz()\n    fuzzers.disable_decompressionbomb_error()\n\n\nif __name__ == \"__main__\":\n    main()\n", "Tests/oss-fuzz/fuzz_font.py": "#!/usr/bin/python3\n\n# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\nimport atheris\n\nwith atheris.instrument_imports():\n    import sys\n\n    import fuzzers\n\n\ndef TestOneInput(data: bytes) -> None:\n    try:\n        fuzzers.fuzz_font(data)\n    except Exception:\n        # We're catching all exceptions because Pillow's exceptions are\n        # directly inheriting from Exception.\n        pass\n\n\ndef main() -> None:\n    fuzzers.enable_decompressionbomb_error()\n    atheris.Setup(sys.argv, TestOneInput)\n    atheris.Fuzz()\n    fuzzers.disable_decompressionbomb_error()\n\n\nif __name__ == \"__main__\":\n    main()\n", "Tests/oss-fuzz/fuzzers.py": "from __future__ import annotations\n\nimport io\nimport warnings\n\nfrom PIL import Image, ImageDraw, ImageFile, ImageFilter, ImageFont\n\n\ndef enable_decompressionbomb_error() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = True\n    warnings.filterwarnings(\"ignore\")\n    warnings.simplefilter(\"error\", Image.DecompressionBombWarning)\n\n\ndef disable_decompressionbomb_error() -> None:\n    ImageFile.LOAD_TRUNCATED_IMAGES = False\n    warnings.resetwarnings()\n\n\ndef fuzz_image(data: bytes) -> None:\n    # This will fail on some images in the corpus, as we have many\n    # invalid images in the test suite.\n    with Image.open(io.BytesIO(data)) as im:\n        im.rotate(45)\n        im.filter(ImageFilter.DETAIL)\n        im.save(io.BytesIO(), \"BMP\")\n\n\ndef fuzz_font(data: bytes) -> None:\n    wrapper = io.BytesIO(data)\n    try:\n        font = ImageFont.truetype(wrapper)\n    except OSError:\n        # Catch pcf/pilfonts/random garbage here. They return\n        # different font objects.\n        return\n\n    font.getbbox(\"ABC\")\n    font.getmask(\"test text\")\n    with Image.new(mode=\"RGBA\", size=(200, 200)) as im:\n        draw = ImageDraw.Draw(im)\n        draw.multiline_textbbox((10, 10), \"ABC\\nAaaa\", font, stroke_width=2)\n        draw.text((10, 10), \"Test Text\", font=font, fill=\"#000\")\n", "Tests/oss-fuzz/test_fuzzers.py": "from __future__ import annotations\n\nimport subprocess\nimport sys\n\nimport fuzzers\nimport packaging\nimport pytest\n\nfrom PIL import Image, UnidentifiedImageError, features\nfrom Tests.helper import skip_unless_feature\n\nif sys.platform.startswith(\"win32\"):\n    pytest.skip(\"Fuzzer is linux only\", allow_module_level=True)\nlibjpeg_turbo_version = features.version(\"libjpeg_turbo\")\nif libjpeg_turbo_version is not None:\n    version = packaging.version.parse(libjpeg_turbo_version)\n    if version.major == 2 and version.minor == 0:\n        pytestmark = pytest.mark.valgrind_known_error(\n            reason=\"Known failing with libjpeg_turbo 2.0\"\n        )\n\n\n@pytest.mark.parametrize(\n    \"path\",\n    subprocess.check_output(\"find Tests/images -type f\", shell=True).split(b\"\\n\"),\n)\ndef test_fuzz_images(path: str) -> None:\n    fuzzers.enable_decompressionbomb_error()\n    try:\n        with open(path, \"rb\") as f:\n            fuzzers.fuzz_image(f.read())\n            assert True\n    except (\n        OSError,\n        SyntaxError,\n        MemoryError,\n        ValueError,\n        NotImplementedError,\n        OverflowError,\n    ):\n        # Known exceptions that are through from Pillow\n        assert True\n    except (\n        Image.DecompressionBombError,\n        Image.DecompressionBombWarning,\n        UnidentifiedImageError,\n    ):\n        # Known Image.* exceptions\n        assert True\n    finally:\n        fuzzers.disable_decompressionbomb_error()\n\n\n@skip_unless_feature(\"freetype2\")\n@pytest.mark.parametrize(\n    \"path\", subprocess.check_output(\"find Tests/fonts -type f\", shell=True).split(b\"\\n\")\n)\ndef test_fuzz_fonts(path: str) -> None:\n    if not path:\n        return\n    with open(path, \"rb\") as f:\n        try:\n            fuzzers.fuzz_font(f.read())\n        except (Image.DecompressionBombError, Image.DecompressionBombWarning, OSError):\n            pass\n        assert True\n", "winbuild/build_prepare.py": "from __future__ import annotations\n\nimport argparse\nimport os\nimport platform\nimport re\nimport shutil\nimport struct\nimport subprocess\n\n\ndef cmd_cd(path: str) -> str:\n    return f\"cd /D {path}\"\n\n\ndef cmd_set(name: str, value: str) -> str:\n    return f\"set {name}={value}\"\n\n\ndef cmd_append(name: str, value: str) -> str:\n    op = \"path \" if name == \"PATH\" else f\"set {name}=\"\n    return op + f\"%{name}%;{value}\"\n\n\ndef cmd_copy(src: str, tgt: str) -> str:\n    return f'copy /Y /B \"{src}\" \"{tgt}\"'\n\n\ndef cmd_xcopy(src: str, tgt: str) -> str:\n    return f'xcopy /Y /E \"{src}\" \"{tgt}\"'\n\n\ndef cmd_mkdir(path: str) -> str:\n    return f'mkdir \"{path}\"'\n\n\ndef cmd_rmdir(path: str) -> str:\n    return f'rmdir /S /Q \"{path}\"'\n\n\ndef cmd_nmake(\n    makefile: str | None = None,\n    target: str = \"\",\n    params: list[str] | None = None,\n) -> str:\n    params = \"\" if params is None else \" \".join(params)\n\n    return \" \".join(\n        [\n            \"{nmake}\",\n            \"-nologo\",\n            f'-f \"{makefile}\"' if makefile is not None else \"\",\n            f\"{params}\",\n            f'\"{target}\"',\n        ]\n    )\n\n\ndef cmds_cmake(\n    target: str | tuple[str, ...] | list[str], *params, build_dir: str = \".\"\n) -> list[str]:\n    if not isinstance(target, str):\n        target = \" \".join(target)\n\n    return [\n        \" \".join(\n            [\n                \"{cmake}\",\n                \"-DCMAKE_BUILD_TYPE=Release\",\n                \"-DCMAKE_VERBOSE_MAKEFILE=ON\",\n                \"-DCMAKE_RULE_MESSAGES:BOOL=OFF\",  # for NMake\n                \"-DCMAKE_C_COMPILER=cl.exe\",  # for Ninja\n                \"-DCMAKE_CXX_COMPILER=cl.exe\",  # for Ninja\n                \"-DCMAKE_C_FLAGS=-nologo\",\n                \"-DCMAKE_CXX_FLAGS=-nologo\",\n                *params,\n                '-G \"{cmake_generator}\"',\n                f'-B \"{build_dir}\"',\n                \"-S .\",\n            ]\n        ),\n        f'{{cmake}} --build \"{build_dir}\" --clean-first --parallel --target {target}',\n    ]\n\n\ndef cmd_msbuild(\n    file: str,\n    configuration: str = \"Release\",\n    target: str = \"Build\",\n    plat: str = \"{msbuild_arch}\",\n) -> str:\n    return \" \".join(\n        [\n            \"{msbuild}\",\n            f\"{file}\",\n            f'/t:\"{target}\"',\n            f'/p:Configuration=\"{configuration}\"',\n            f\"/p:Platform={plat}\",\n            \"/m\",\n        ]\n    )\n\n\nSF_PROJECTS = \"https://sourceforge.net/projects\"\n\nARCHITECTURES = {\n    \"x86\": {\"vcvars_arch\": \"x86\", \"msbuild_arch\": \"Win32\"},\n    \"AMD64\": {\"vcvars_arch\": \"x86_amd64\", \"msbuild_arch\": \"x64\"},\n    \"ARM64\": {\"vcvars_arch\": \"x86_arm64\", \"msbuild_arch\": \"ARM64\"},\n}\n\nV = {\n    \"BROTLI\": \"1.1.0\",\n    \"FREETYPE\": \"2.13.2\",\n    \"FRIBIDI\": \"1.0.15\",\n    \"HARFBUZZ\": \"8.5.0\",\n    \"JPEGTURBO\": \"3.0.3\",\n    \"LCMS2\": \"2.16\",\n    \"LIBPNG\": \"1.6.43\",\n    \"LIBWEBP\": \"1.4.0\",\n    \"OPENJPEG\": \"2.5.2\",\n    \"TIFF\": \"4.6.0\",\n    \"XZ\": \"5.4.5\",\n    \"ZLIB\": \"1.3.1\",\n}\nV[\"LIBPNG_DOTLESS\"] = V[\"LIBPNG\"].replace(\".\", \"\")\nV[\"LIBPNG_XY\"] = \"\".join(V[\"LIBPNG\"].split(\".\")[:2])\nV[\"ZLIB_DOTLESS\"] = V[\"ZLIB\"].replace(\".\", \"\")\n\n\n# dependencies, listed in order of compilation\nDEPS = {\n    \"libjpeg\": {\n        \"url\": f\"{SF_PROJECTS}/libjpeg-turbo/files/{V['JPEGTURBO']}/\"\n        f\"libjpeg-turbo-{V['JPEGTURBO']}.tar.gz/download\",\n        \"filename\": f\"libjpeg-turbo-{V['JPEGTURBO']}.tar.gz\",\n        \"dir\": f\"libjpeg-turbo-{V['JPEGTURBO']}\",\n        \"license\": [\"README.ijg\", \"LICENSE.md\"],\n        \"license_pattern\": (\n            \"(LEGAL ISSUES\\n============\\n\\n.+?)\\n\\nREFERENCES\\n==========\"\n            \".+(libjpeg-turbo Licenses\\n======================\\n\\n.+)$\"\n        ),\n        \"patch\": {\n            r\"CMakeLists.txt\": {\n                # libjpeg-turbo does not detect MSVC x86_arm64 cross-compiler correctly\n                'if(MSVC_IDE AND CMAKE_GENERATOR_PLATFORM MATCHES \"arm64\")': \"if({architecture} STREQUAL ARM64)\",  # noqa: E501\n            },\n        },\n        \"build\": [\n            *cmds_cmake(\n                (\"jpeg-static\", \"cjpeg-static\", \"djpeg-static\"),\n                \"-DENABLE_SHARED:BOOL=FALSE\",\n                \"-DWITH_JPEG8:BOOL=TRUE\",\n                \"-DWITH_CRT_DLL:BOOL=TRUE\",\n            ),\n            cmd_copy(\"jpeg-static.lib\", \"libjpeg.lib\"),\n            cmd_copy(\"cjpeg-static.exe\", \"cjpeg.exe\"),\n            cmd_copy(\"djpeg-static.exe\", \"djpeg.exe\"),\n        ],\n        \"headers\": [\"j*.h\"],\n        \"libs\": [\"libjpeg.lib\"],\n        \"bins\": [\"cjpeg.exe\", \"djpeg.exe\"],\n    },\n    \"zlib\": {\n        \"url\": f\"https://zlib.net/zlib{V['ZLIB_DOTLESS']}.zip\",\n        \"filename\": f\"zlib{V['ZLIB_DOTLESS']}.zip\",\n        \"dir\": f\"zlib-{V['ZLIB']}\",\n        \"license\": \"README\",\n        \"license_pattern\": \"Copyright notice:\\n\\n(.+)$\",\n        \"build\": [\n            cmd_nmake(r\"win32\\Makefile.msc\", \"clean\"),\n            cmd_nmake(r\"win32\\Makefile.msc\", \"zlib.lib\"),\n            cmd_copy(\"zlib.lib\", \"z.lib\"),\n        ],\n        \"headers\": [r\"z*.h\"],\n        \"libs\": [r\"*.lib\"],\n    },\n    \"xz\": {\n        \"url\": f\"{SF_PROJECTS}/lzmautils/files/xz-{V['XZ']}.tar.gz/download\",\n        \"filename\": f\"xz-{V['XZ']}.tar.gz\",\n        \"dir\": f\"xz-{V['XZ']}\",\n        \"license\": \"COPYING\",\n        \"build\": [\n            *cmds_cmake(\"liblzma\", \"-DBUILD_SHARED_LIBS:BOOL=OFF\"),\n            cmd_mkdir(r\"{inc_dir}\\lzma\"),\n            cmd_copy(r\"src\\liblzma\\api\\lzma\\*.h\", r\"{inc_dir}\\lzma\"),\n        ],\n        \"headers\": [r\"src\\liblzma\\api\\lzma.h\"],\n        \"libs\": [r\"liblzma.lib\"],\n    },\n    \"libwebp\": {\n        \"url\": f\"http://downloads.webmproject.org/releases/webp/libwebp-{V['LIBWEBP']}.tar.gz\",\n        \"filename\": f\"libwebp-{V['LIBWEBP']}.tar.gz\",\n        \"dir\": f\"libwebp-{V['LIBWEBP']}\",\n        \"license\": \"COPYING\",\n        \"patch\": {\n            r\"src\\enc\\picture_csp_enc.c\": {\n                # link against libsharpyuv.lib\n                '#include \"sharpyuv/sharpyuv.h\"': '#include \"sharpyuv/sharpyuv.h\"\\n#pragma comment(lib, \"libsharpyuv.lib\")',  # noqa: E501\n            }\n        },\n        \"build\": [\n            *cmds_cmake(\n                \"webp webpdemux webpmux\",\n                \"-DBUILD_SHARED_LIBS:BOOL=OFF\",\n                \"-DWEBP_LINK_STATIC:BOOL=OFF\",\n            ),\n            cmd_mkdir(r\"{inc_dir}\\webp\"),\n            cmd_copy(r\"src\\webp\\*.h\", r\"{inc_dir}\\webp\"),\n        ],\n        \"libs\": [r\"libsharpyuv.lib\", r\"libwebp*.lib\"],\n    },\n    \"libtiff\": {\n        \"url\": f\"https://download.osgeo.org/libtiff/tiff-{V['TIFF']}.tar.gz\",\n        \"filename\": f\"tiff-{V['TIFF']}.tar.gz\",\n        \"dir\": f\"tiff-{V['TIFF']}\",\n        \"license\": \"LICENSE.md\",\n        \"patch\": {\n            r\"libtiff\\tif_lzma.c\": {\n                # link against liblzma.lib\n                \"#ifdef LZMA_SUPPORT\": '#ifdef LZMA_SUPPORT\\n#pragma comment(lib, \"liblzma.lib\")',  # noqa: E501\n            },\n            r\"libtiff\\tif_webp.c\": {\n                # link against libwebp.lib\n                \"#ifdef WEBP_SUPPORT\": '#ifdef WEBP_SUPPORT\\n#pragma comment(lib, \"libwebp.lib\")',  # noqa: E501\n            },\n            r\"test\\CMakeLists.txt\": {\n                \"add_executable(test_write_read_tags ../placeholder.h)\": \"\",\n                \"target_sources(test_write_read_tags PRIVATE test_write_read_tags.c)\": \"\",  # noqa: E501\n                \"target_link_libraries(test_write_read_tags PRIVATE tiff)\": \"\",\n                \"list(APPEND simple_tests test_write_read_tags)\": \"\",\n            },\n        },\n        \"build\": [\n            *cmds_cmake(\n                \"tiff\",\n                \"-DBUILD_SHARED_LIBS:BOOL=OFF\",\n                \"-DWebP_LIBRARY=libwebp\",\n                '-DCMAKE_C_FLAGS=\"-nologo -DLZMA_API_STATIC\"',\n            )\n        ],\n        \"headers\": [r\"libtiff\\tiff*.h\"],\n        \"libs\": [r\"libtiff\\*.lib\"],\n    },\n    \"libpng\": {\n        \"url\": f\"{SF_PROJECTS}/libpng/files/libpng{V['LIBPNG_XY']}/{V['LIBPNG']}/\"\n        f\"lpng{V['LIBPNG_DOTLESS']}.zip/download\",\n        \"filename\": f\"lpng{V['LIBPNG_DOTLESS']}.zip\",\n        \"dir\": f\"lpng{V['LIBPNG_DOTLESS']}\",\n        \"license\": \"LICENSE\",\n        \"build\": [\n            *cmds_cmake(\"png_static\", \"-DPNG_SHARED:BOOL=OFF\", \"-DPNG_TESTS:BOOL=OFF\"),\n            cmd_copy(\n                f\"libpng{V['LIBPNG_XY']}_static.lib\", f\"libpng{V['LIBPNG_XY']}.lib\"\n            ),\n        ],\n        \"headers\": [r\"png*.h\"],\n        \"libs\": [f\"libpng{V['LIBPNG_XY']}.lib\"],\n    },\n    \"brotli\": {\n        \"url\": f\"https://github.com/google/brotli/archive/refs/tags/v{V['BROTLI']}.tar.gz\",\n        \"filename\": f\"brotli-{V['BROTLI']}.tar.gz\",\n        \"dir\": f\"brotli-{V['BROTLI']}\",\n        \"license\": \"LICENSE\",\n        \"build\": [\n            *cmds_cmake((\"brotlicommon\", \"brotlidec\"), \"-DBUILD_SHARED_LIBS:BOOL=OFF\"),\n            cmd_xcopy(r\"c\\include\", \"{inc_dir}\"),\n        ],\n        \"libs\": [\"*.lib\"],\n    },\n    \"freetype\": {\n        \"url\": f\"https://download.savannah.gnu.org/releases/freetype/freetype-{V['FREETYPE']}.tar.gz\",\n        \"filename\": f\"freetype-{V['FREETYPE']}.tar.gz\",\n        \"dir\": f\"freetype-{V['FREETYPE']}\",\n        \"license\": [\"LICENSE.TXT\", r\"docs\\FTL.TXT\", r\"docs\\GPLv2.TXT\"],\n        \"patch\": {\n            r\"builds\\windows\\vc2010\\freetype.vcxproj\": {\n                # freetype setting is /MD for .dll and /MT for .lib, we need /MD\n                \"<RuntimeLibrary>MultiThreaded</RuntimeLibrary>\": \"<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\",  # noqa: E501\n                # freetype doesn't specify SDK version, MSBuild may guess incorrectly\n                '<PropertyGroup Label=\"Globals\">': '<PropertyGroup Label=\"Globals\">\\n    <WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>',  # noqa: E501\n            },\n            r\"builds\\windows\\vc2010\\freetype.user.props\": {\n                \"<UserDefines></UserDefines>\": \"<UserDefines>FT_CONFIG_OPTION_SYSTEM_ZLIB;FT_CONFIG_OPTION_USE_PNG;FT_CONFIG_OPTION_USE_HARFBUZZ;FT_CONFIG_OPTION_USE_BROTLI</UserDefines>\",  # noqa: E501\n                \"<UserIncludeDirectories></UserIncludeDirectories>\": r\"<UserIncludeDirectories>{dir_harfbuzz}\\src;{inc_dir}</UserIncludeDirectories>\",  # noqa: E501\n                \"<UserLibraryDirectories></UserLibraryDirectories>\": \"<UserLibraryDirectories>{lib_dir}</UserLibraryDirectories>\",  # noqa: E501\n                \"<UserDependencies></UserDependencies>\": f\"<UserDependencies>zlib.lib;libpng{V['LIBPNG_XY']}.lib;brotlicommon.lib;brotlidec.lib</UserDependencies>\",  # noqa: E501\n            },\n            r\"src/autofit/afshaper.c\": {\n                # link against harfbuzz.lib\n                \"#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ\": '#ifdef FT_CONFIG_OPTION_USE_HARFBUZZ\\n#pragma comment(lib, \"harfbuzz.lib\")',  # noqa: E501\n            },\n        },\n        \"build\": [\n            cmd_rmdir(\"objs\"),\n            cmd_msbuild(\n                r\"builds\\windows\\vc2010\\freetype.sln\", \"Release Static\", \"Clean\"\n            ),\n            cmd_msbuild(\n                r\"builds\\windows\\vc2010\\freetype.sln\", \"Release Static\", \"Build\"\n            ),\n            cmd_xcopy(\"include\", \"{inc_dir}\"),\n        ],\n        \"libs\": [r\"objs\\{msbuild_arch}\\Release Static\\freetype.lib\"],\n    },\n    \"lcms2\": {\n        \"url\": f\"{SF_PROJECTS}/lcms/files/lcms/{V['LCMS2']}/lcms2-{V['LCMS2']}.tar.gz/download\",  # noqa: E501\n        \"filename\": f\"lcms2-{V['LCMS2']}.tar.gz\",\n        \"dir\": f\"lcms2-{V['LCMS2']}\",\n        \"license\": \"LICENSE\",\n        \"patch\": {\n            r\"Projects\\VC2022\\lcms2_static\\lcms2_static.vcxproj\": {\n                # default is /MD for x86 and /MT for x64, we need /MD always\n                \"<RuntimeLibrary>MultiThreaded</RuntimeLibrary>\": \"<RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\",  # noqa: E501\n                # retarget to default toolset (selected by vcvarsall.bat)\n                \"<PlatformToolset>v143</PlatformToolset>\": \"<PlatformToolset>$(DefaultPlatformToolset)</PlatformToolset>\",  # noqa: E501\n                # retarget to latest (selected by vcvarsall.bat)\n                \"<WindowsTargetPlatformVersion>10.0</WindowsTargetPlatformVersion>\": \"<WindowsTargetPlatformVersion>$(WindowsSDKVersion)</WindowsTargetPlatformVersion>\",  # noqa: E501\n            }\n        },\n        \"build\": [\n            cmd_rmdir(\"Lib\"),\n            cmd_rmdir(r\"Projects\\VC2022\\Release\"),\n            cmd_msbuild(r\"Projects\\VC2022\\lcms2.sln\", \"Release\", \"Clean\"),\n            cmd_msbuild(\n                r\"Projects\\VC2022\\lcms2.sln\", \"Release\", \"lcms2_static:Rebuild\"\n            ),\n            cmd_xcopy(\"include\", \"{inc_dir}\"),\n        ],\n        \"libs\": [r\"Lib\\MS\\*.lib\"],\n    },\n    \"openjpeg\": {\n        \"url\": f\"https://github.com/uclouvain/openjpeg/archive/v{V['OPENJPEG']}.tar.gz\",\n        \"filename\": f\"openjpeg-{V['OPENJPEG']}.tar.gz\",\n        \"dir\": f\"openjpeg-{V['OPENJPEG']}\",\n        \"license\": \"LICENSE\",\n        \"build\": [\n            *cmds_cmake(\n                \"openjp2\", \"-DBUILD_CODEC:BOOL=OFF\", \"-DBUILD_SHARED_LIBS:BOOL=OFF\"\n            ),\n            cmd_mkdir(rf\"{{inc_dir}}\\openjpeg-{V['OPENJPEG']}\"),\n            cmd_copy(r\"src\\lib\\openjp2\\*.h\", rf\"{{inc_dir}}\\openjpeg-{V['OPENJPEG']}\"),\n        ],\n        \"libs\": [r\"bin\\*.lib\"],\n    },\n    \"libimagequant\": {\n        # commit: Merge branch 'master' into msvc (matches 2.17.0 tag)\n        \"url\": \"https://github.com/ImageOptim/libimagequant/archive/e4c1334be0eff290af5e2b4155057c2953a313ab.zip\",\n        \"filename\": \"libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab.zip\",\n        \"dir\": \"libimagequant-e4c1334be0eff290af5e2b4155057c2953a313ab\",\n        \"license\": \"COPYRIGHT\",\n        \"patch\": {\n            \"CMakeLists.txt\": {\n                \"if(OPENMP_FOUND)\": \"if(false)\",\n                \"install\": \"#install\",\n                # libimagequant does not detect MSVC x86_arm64 cross-compiler correctly\n                \"if(${{CMAKE_SYSTEM_PROCESSOR}} STREQUAL ARM64)\": \"if({architecture} STREQUAL ARM64)\",  # noqa: E501\n            }\n        },\n        \"build\": [\n            *cmds_cmake(\"imagequant_a\"),\n            cmd_copy(\"imagequant_a.lib\", \"imagequant.lib\"),\n        ],\n        \"headers\": [r\"*.h\"],\n        \"libs\": [r\"imagequant.lib\"],\n    },\n    \"harfbuzz\": {\n        \"url\": f\"https://github.com/harfbuzz/harfbuzz/archive/{V['HARFBUZZ']}.zip\",\n        \"filename\": f\"harfbuzz-{V['HARFBUZZ']}.zip\",\n        \"dir\": f\"harfbuzz-{V['HARFBUZZ']}\",\n        \"license\": \"COPYING\",\n        \"build\": [\n            *cmds_cmake(\n                \"harfbuzz\",\n                \"-DHB_HAVE_FREETYPE:BOOL=TRUE\",\n                '-DCMAKE_CXX_FLAGS=\"-nologo -d2FH4-\"',\n            ),\n        ],\n        \"headers\": [r\"src\\*.h\"],\n        \"libs\": [r\"*.lib\"],\n    },\n    \"fribidi\": {\n        \"url\": f\"https://github.com/fribidi/fribidi/archive/v{V['FRIBIDI']}.zip\",\n        \"filename\": f\"fribidi-{V['FRIBIDI']}.zip\",\n        \"dir\": f\"fribidi-{V['FRIBIDI']}\",\n        \"license\": \"COPYING\",\n        \"build\": [\n            cmd_copy(r\"COPYING\", rf\"{{bin_dir}}\\fribidi-{V['FRIBIDI']}-COPYING\"),\n            cmd_copy(r\"{winbuild_dir}\\fribidi.cmake\", r\"CMakeLists.txt\"),\n            # generated tab.i files cannot be cross-compiled\n            \" ^&^& \".join(\n                [\n                    \"if {architecture}==ARM64 cmd /c call {vcvarsall} x86\",\n                    *cmds_cmake(\"fribidi-gen\", \"-DARCH=x86\", build_dir=\"build_x86\"),\n                ]\n            ),\n            *cmds_cmake(\"fribidi\", \"-DARCH={architecture}\"),\n        ],\n        \"bins\": [r\"*.dll\"],\n    },\n}\n\n\n# based on distutils._msvccompiler from CPython 3.7.4\ndef find_msvs(architecture: str) -> dict[str, str] | None:\n    root = os.environ.get(\"ProgramFiles(x86)\") or os.environ.get(\"ProgramFiles\")\n    if not root:\n        print(\"Program Files not found\")\n        return None\n\n    requires = [\"-requires\", \"Microsoft.VisualStudio.Component.VC.Tools.x86.x64\"]\n    if architecture == \"ARM64\":\n        requires += [\"-requires\", \"Microsoft.VisualStudio.Component.VC.Tools.ARM64\"]\n\n    try:\n        vspath = (\n            subprocess.check_output(\n                [\n                    os.path.join(\n                        root, \"Microsoft Visual Studio\", \"Installer\", \"vswhere.exe\"\n                    ),\n                    \"-latest\",\n                    \"-prerelease\",\n                    *requires,\n                    \"-property\",\n                    \"installationPath\",\n                    \"-products\",\n                    \"*\",\n                ]\n            )\n            .decode(encoding=\"mbcs\")\n            .strip()\n        )\n    except (subprocess.CalledProcessError, OSError, UnicodeDecodeError):\n        print(\"vswhere not found\")\n        return None\n\n    if not os.path.isdir(os.path.join(vspath, \"VC\", \"Auxiliary\", \"Build\")):\n        print(\"Visual Studio seems to be missing C compiler\")\n        return None\n\n    # vs2017\n    msbuild = os.path.join(vspath, \"MSBuild\", \"15.0\", \"Bin\", \"MSBuild.exe\")\n    if not os.path.isfile(msbuild):\n        # vs2019\n        msbuild = os.path.join(vspath, \"MSBuild\", \"Current\", \"Bin\", \"MSBuild.exe\")\n        if not os.path.isfile(msbuild):\n            print(\"Visual Studio MSBuild not found\")\n            return None\n\n    vcvarsall = os.path.join(vspath, \"VC\", \"Auxiliary\", \"Build\", \"vcvarsall.bat\")\n    if not os.path.isfile(vcvarsall):\n        print(\"Visual Studio vcvarsall not found\")\n        return None\n\n    return {\n        \"vs_dir\": vspath,\n        \"msbuild\": f'\"{msbuild}\"',\n        \"vcvarsall\": f'\"{vcvarsall}\"',\n        \"nmake\": \"nmake.exe\",  # nmake selected by vcvarsall\n    }\n\n\ndef download_dep(url: str, file: str) -> None:\n    import urllib.error\n    import urllib.request\n\n    ex = None\n    for i in range(3):\n        try:\n            print(f\"Fetching {url} (attempt {i + 1})...\")\n            content = urllib.request.urlopen(url).read()\n            with open(file, \"wb\") as f:\n                f.write(content)\n            break\n        except urllib.error.URLError as e:\n            ex = e\n    else:\n        raise RuntimeError(ex)\n\n\ndef extract_dep(url: str, filename: str, prefs: dict[str, str]) -> None:\n    import tarfile\n    import zipfile\n\n    depends_dir = prefs[\"depends_dir\"]\n    sources_dir = prefs[\"src_dir\"]\n\n    file = os.path.join(depends_dir, filename)\n    if not os.path.exists(file):\n        # First try our mirror\n        mirror_url = (\n            f\"https://raw.githubusercontent.com/\"\n            f\"python-pillow/pillow-depends/main/{filename}\"\n        )\n        try:\n            download_dep(mirror_url, file)\n        except RuntimeError as exc:\n            # Otherwise try upstream\n            print(exc)\n            download_dep(url, file)\n\n    print(\"Extracting \" + filename)\n    sources_dir_abs = os.path.abspath(sources_dir)\n    if filename.endswith(\".zip\"):\n        with zipfile.ZipFile(file) as zf:\n            for member in zf.namelist():\n                member_abspath = os.path.abspath(os.path.join(sources_dir, member))\n                member_prefix = os.path.commonpath([sources_dir_abs, member_abspath])\n                if sources_dir_abs != member_prefix:\n                    msg = \"Attempted Path Traversal in Zip File\"\n                    raise RuntimeError(msg)\n            zf.extractall(sources_dir)\n    elif filename.endswith((\".tar.gz\", \".tgz\")):\n        with tarfile.open(file, \"r:gz\") as tgz:\n            for member in tgz.getnames():\n                member_abspath = os.path.abspath(os.path.join(sources_dir, member))\n                member_prefix = os.path.commonpath([sources_dir_abs, member_abspath])\n                if sources_dir_abs != member_prefix:\n                    msg = \"Attempted Path Traversal in Tar File\"\n                    raise RuntimeError(msg)\n            tgz.extractall(sources_dir)\n    else:\n        msg = \"Unknown archive type: \" + filename\n        raise RuntimeError(msg)\n\n\ndef write_script(\n    name: str, lines: list[str], prefs: dict[str, str], verbose: bool\n) -> None:\n    name = os.path.join(prefs[\"build_dir\"], name)\n    lines = [line.format(**prefs) for line in lines]\n    print(\"Writing \" + name)\n    with open(name, \"w\", newline=\"\") as f:\n        f.write(os.linesep.join(lines))\n    if verbose:\n        for line in lines:\n            print(\"    \" + line)\n\n\ndef get_footer(dep: dict) -> list[str]:\n    lines = []\n    for out in dep.get(\"headers\", []):\n        lines.append(cmd_copy(out, \"{inc_dir}\"))\n    for out in dep.get(\"libs\", []):\n        lines.append(cmd_copy(out, \"{lib_dir}\"))\n    for out in dep.get(\"bins\", []):\n        lines.append(cmd_copy(out, \"{bin_dir}\"))\n    return lines\n\n\ndef build_env(prefs: dict[str, str], verbose: bool) -> None:\n    lines = [\n        \"if defined DISTUTILS_USE_SDK goto end\",\n        cmd_set(\"INCLUDE\", \"{inc_dir}\"),\n        cmd_set(\"INCLIB\", \"{lib_dir}\"),\n        cmd_set(\"LIB\", \"{lib_dir}\"),\n        cmd_append(\"PATH\", \"{bin_dir}\"),\n        \"call {vcvarsall} {vcvars_arch}\",\n        cmd_set(\"DISTUTILS_USE_SDK\", \"1\"),  # use same compiler to build Pillow\n        cmd_set(\"py_vcruntime_redist\", \"true\"),  # always use /MD, never /MT\n        \":end\",\n        \"@echo on\",\n    ]\n    write_script(\"build_env.cmd\", lines, prefs, verbose)\n\n\ndef build_dep(name: str, prefs: dict[str, str], verbose: bool) -> str:\n    dep = DEPS[name]\n    directory = dep[\"dir\"]\n    file = f\"build_dep_{name}.cmd\"\n    license_dir = prefs[\"license_dir\"]\n    sources_dir = prefs[\"src_dir\"]\n\n    extract_dep(dep[\"url\"], dep[\"filename\"], prefs)\n\n    licenses = dep[\"license\"]\n    if isinstance(licenses, str):\n        licenses = [licenses]\n    license_text = \"\"\n    for license_file in licenses:\n        with open(os.path.join(sources_dir, directory, license_file)) as f:\n            license_text += f.read()\n    if \"license_pattern\" in dep:\n        match = re.search(dep[\"license_pattern\"], license_text, re.DOTALL)\n        license_text = \"\\n\".join(match.groups())\n    assert len(license_text) > 50\n    with open(os.path.join(license_dir, f\"{directory}.txt\"), \"w\") as f:\n        print(f\"Writing license {directory}.txt\")\n        f.write(license_text)\n\n    for patch_file, patch_list in dep.get(\"patch\", {}).items():\n        patch_file = os.path.join(sources_dir, directory, patch_file.format(**prefs))\n        with open(patch_file) as f:\n            text = f.read()\n        for patch_from, patch_to in patch_list.items():\n            patch_from = patch_from.format(**prefs)\n            patch_to = patch_to.format(**prefs)\n            assert patch_from in text\n            text = text.replace(patch_from, patch_to)\n        with open(patch_file, \"w\") as f:\n            print(f\"Patching {patch_file}\")\n            f.write(text)\n\n    banner = f\"Building {name} ({directory})\"\n    lines = [\n        r'call \"{build_dir}\\build_env.cmd\"',\n        \"@echo \" + (\"=\" * 70),\n        f\"@echo ==== {banner:<60} ====\",\n        \"@echo \" + (\"=\" * 70),\n        cmd_cd(os.path.join(sources_dir, directory)),\n        *dep.get(\"build\", []),\n        *get_footer(dep),\n    ]\n\n    write_script(file, lines, prefs, verbose)\n    return file\n\n\ndef build_dep_all(disabled: list[str], prefs: dict[str, str], verbose: bool) -> None:\n    lines = [r'call \"{build_dir}\\build_env.cmd\"']\n    gha_groups = \"GITHUB_ACTIONS\" in os.environ\n    for dep_name in DEPS:\n        print()\n        if dep_name in disabled:\n            print(f\"Skipping disabled dependency {dep_name}\")\n            continue\n        script = build_dep(dep_name, prefs, verbose)\n        if gha_groups:\n            lines.append(f\"@echo ::group::Running {script}\")\n        lines.append(rf'cmd.exe /c \"{{build_dir}}\\{script}\"')\n        lines.append(\"if errorlevel 1 echo Build failed! && exit /B 1\")\n        if gha_groups:\n            lines.append(\"@echo ::endgroup::\")\n    print()\n    lines.append(\"@echo All Pillow dependencies built successfully!\")\n    write_script(\"build_dep_all.cmd\", lines, prefs, verbose)\n\n\ndef main() -> None:\n    winbuild_dir = os.path.dirname(os.path.realpath(__file__))\n\n    parser = argparse.ArgumentParser(\n        prog=\"winbuild\\\\build_prepare.py\",\n        description=\"Download and generate build scripts for Pillow dependencies.\",\n        epilog=\"\"\"Arguments can also be supplied using the environment variables\n                  PILLOW_BUILD, PILLOW_DEPS, ARCHITECTURE. See winbuild\\\\build.rst\n                  for more information.\"\"\",\n    )\n    parser.add_argument(\n        \"-v\", \"--verbose\", action=\"store_true\", help=\"print generated scripts\"\n    )\n    parser.add_argument(\n        \"-d\",\n        \"--dir\",\n        \"--build-dir\",\n        dest=\"build_dir\",\n        metavar=\"PILLOW_BUILD\",\n        default=os.environ.get(\"PILLOW_BUILD\", os.path.join(winbuild_dir, \"build\")),\n        help=\"build directory (default: 'winbuild\\\\build')\",\n    )\n    parser.add_argument(\n        \"--depends\",\n        dest=\"depends_dir\",\n        metavar=\"PILLOW_DEPS\",\n        default=os.environ.get(\"PILLOW_DEPS\", os.path.join(winbuild_dir, \"depends\")),\n        help=\"directory used to store cached dependencies \"\n        \"(default: 'winbuild\\\\depends')\",\n    )\n    parser.add_argument(\n        \"--architecture\",\n        choices=ARCHITECTURES,\n        default=os.environ.get(\n            \"ARCHITECTURE\",\n            (\n                \"ARM64\"\n                if platform.machine() == \"ARM64\"\n                else (\"x86\" if struct.calcsize(\"P\") == 4 else \"AMD64\")\n            ),\n        ),\n        help=\"build architecture (default: same as host Python)\",\n    )\n    parser.add_argument(\n        \"--nmake\",\n        dest=\"cmake_generator\",\n        action=\"store_const\",\n        const=\"NMake Makefiles\",\n        default=\"Ninja\",\n        help=\"build dependencies using NMake instead of Ninja\",\n    )\n    parser.add_argument(\n        \"--no-imagequant\",\n        action=\"store_true\",\n        help=\"skip GPL-licensed optional dependency libimagequant\",\n    )\n    parser.add_argument(\n        \"--no-fribidi\",\n        \"--no-raqm\",\n        action=\"store_true\",\n        help=\"skip LGPL-licensed optional dependency FriBiDi\",\n    )\n    args = parser.parse_args()\n\n    arch_prefs = ARCHITECTURES[args.architecture]\n    print(\"Target architecture:\", args.architecture)\n\n    msvs = find_msvs(args.architecture)\n    if msvs is None:\n        msg = \"Visual Studio not found. Please install Visual Studio 2017 or newer.\"\n        raise RuntimeError(msg)\n    print(\"Found Visual Studio at:\", msvs[\"vs_dir\"])\n\n    # dependency cache directory\n    args.depends_dir = os.path.abspath(args.depends_dir)\n    os.makedirs(args.depends_dir, exist_ok=True)\n    print(\"Caching dependencies in:\", args.depends_dir)\n\n    args.build_dir = os.path.abspath(args.build_dir)\n    print(\"Using output directory:\", args.build_dir)\n\n    # build directory for *.h files\n    inc_dir = os.path.join(args.build_dir, \"inc\")\n    # build directory for *.lib files\n    lib_dir = os.path.join(args.build_dir, \"lib\")\n    # build directory for *.bin files\n    bin_dir = os.path.join(args.build_dir, \"bin\")\n    # directory for storing project files\n    sources_dir = os.path.join(args.build_dir, \"src\")\n    # copy dependency licenses to this directory\n    license_dir = os.path.join(args.build_dir, \"license\")\n\n    shutil.rmtree(args.build_dir, ignore_errors=True)\n    os.makedirs(args.build_dir, exist_ok=False)\n    for path in [inc_dir, lib_dir, bin_dir, sources_dir, license_dir]:\n        os.makedirs(path, exist_ok=True)\n\n    disabled = []\n    if args.no_imagequant:\n        disabled += [\"libimagequant\"]\n    if args.no_fribidi:\n        disabled += [\"fribidi\"]\n\n    prefs = {\n        \"architecture\": args.architecture,\n        **arch_prefs,\n        # Pillow paths\n        \"winbuild_dir\": winbuild_dir,\n        # Build paths\n        \"bin_dir\": bin_dir,\n        \"build_dir\": args.build_dir,\n        \"depends_dir\": args.depends_dir,\n        \"inc_dir\": inc_dir,\n        \"lib_dir\": lib_dir,\n        \"license_dir\": license_dir,\n        \"src_dir\": sources_dir,\n        # Compilers / Tools\n        **msvs,\n        \"cmake\": \"cmake.exe\",  # TODO find CMAKE automatically\n        \"cmake_generator\": args.cmake_generator,\n        # TODO find NASM automatically\n    }\n\n    for k, v in DEPS.items():\n        prefs[f\"dir_{k}\"] = os.path.join(sources_dir, v[\"dir\"])\n\n    print()\n\n    write_script(\".gitignore\", [\"*\"], prefs, args.verbose)\n    build_env(prefs, args.verbose)\n    build_dep_all(disabled, prefs, args.verbose)\n\n\nif __name__ == \"__main__\":\n    main()\n"}