{"exercises.py": "from pytest_perf.deco import extras\n\n\n@extras('perf')\ndef discovery_perf():\n    \"discovery\"\n    import importlib_metadata  # end warmup\n\n    importlib_metadata.distribution('ipython')\n\n\ndef entry_points_perf():\n    \"entry_points()\"\n    import importlib_metadata  # end warmup\n\n    importlib_metadata.entry_points()\n\n\n@extras('perf')\ndef cached_distribution_perf():\n    \"cached distribution\"\n    import importlib_metadata\n\n    importlib_metadata.distribution('ipython')  # end warmup\n    importlib_metadata.distribution('ipython')\n\n\n@extras('perf')\ndef uncached_distribution_perf():\n    \"uncached distribution\"\n    import importlib\n    import importlib_metadata\n\n    # end warmup\n    importlib.invalidate_caches()\n    importlib_metadata.distribution('ipython')\n\n\ndef entrypoint_regexp_perf():\n    import importlib_metadata\n    import re\n\n    input = '0' + ' ' * 2**10 + '0'  # end warmup\n\n    re.match(importlib_metadata.EntryPoint.pattern, input)\n", "conftest.py": "import sys\n\n\ncollect_ignore = [\n    # this module fails mypy tests because 'setup.py' matches './setup.py'\n    'tests/data/sources/example/setup.py',\n]\n\n\ndef pytest_configure():\n    remove_importlib_metadata()\n\n\ndef remove_importlib_metadata():\n    \"\"\"\n    Because pytest imports importlib_metadata, the coverage\n    reports are broken (#322). So work around the issue by\n    undoing the changes made by pytest's import of\n    importlib_metadata (if any).\n    \"\"\"\n    if sys.meta_path[-1].__class__.__name__ == 'MetadataPathFinder':\n        del sys.meta_path[-1]\n    for mod in list(sys.modules):\n        if mod.startswith('importlib_metadata'):\n            del sys.modules[mod]\n", "importlib_metadata/diagnose.py": "import sys\n\nfrom . import Distribution\n\n\ndef inspect(path):\n    print(\"Inspecting\", path)\n    dists = list(Distribution.discover(path=[path]))\n    if not dists:\n        return\n    print(\"Found\", len(dists), \"packages:\", end=' ')\n    print(', '.join(dist.name for dist in dists))\n\n\ndef run():\n    for path in sys.path:\n        inspect(path)\n\n\nif __name__ == '__main__':\n    run()\n", "importlib_metadata/_itertools.py": "from itertools import filterfalse\n\n\ndef unique_everseen(iterable, key=None):\n    \"List unique elements, preserving order. Remember all elements ever seen.\"\n    # unique_everseen('AAAABBBCCDAABBB') --> A B C D\n    # unique_everseen('ABBCcAD', str.lower) --> A B C D\n    seen = set()\n    seen_add = seen.add\n    if key is None:\n        for element in filterfalse(seen.__contains__, iterable):\n            seen_add(element)\n            yield element\n    else:\n        for element in iterable:\n            k = key(element)\n            if k not in seen:\n                seen_add(k)\n                yield element\n\n\n# copied from more_itertools 8.8\ndef always_iterable(obj, base_type=(str, bytes)):\n    \"\"\"If *obj* is iterable, return an iterator over its items::\n\n        >>> obj = (1, 2, 3)\n        >>> list(always_iterable(obj))\n        [1, 2, 3]\n\n    If *obj* is not iterable, return a one-item iterable containing *obj*::\n\n        >>> obj = 1\n        >>> list(always_iterable(obj))\n        [1]\n\n    If *obj* is ``None``, return an empty iterable:\n\n        >>> obj = None\n        >>> list(always_iterable(None))\n        []\n\n    By default, binary and text strings are not considered iterable::\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj))\n        ['foo']\n\n    If *base_type* is set, objects for which ``isinstance(obj, base_type)``\n    returns ``True`` won't be considered iterable.\n\n        >>> obj = {'a': 1}\n        >>> list(always_iterable(obj))  # Iterate over the dict's keys\n        ['a']\n        >>> list(always_iterable(obj, base_type=dict))  # Treat dicts as a unit\n        [{'a': 1}]\n\n    Set *base_type* to ``None`` to avoid any special handling and treat objects\n    Python considers iterable as iterable:\n\n        >>> obj = 'foo'\n        >>> list(always_iterable(obj, base_type=None))\n        ['f', 'o', 'o']\n    \"\"\"\n    if obj is None:\n        return iter(())\n\n    if (base_type is not None) and isinstance(obj, base_type):\n        return iter((obj,))\n\n    try:\n        return iter(obj)\n    except TypeError:\n        return iter((obj,))\n", "importlib_metadata/_text.py": "import re\n\nfrom ._functools import method_cache\n\n\n# from jaraco.text 3.5\nclass FoldedCase(str):\n    \"\"\"\n    A case insensitive string class; behaves just like str\n    except compares equal when the only variation is case.\n\n    >>> s = FoldedCase('hello world')\n\n    >>> s == 'Hello World'\n    True\n\n    >>> 'Hello World' == s\n    True\n\n    >>> s != 'Hello World'\n    False\n\n    >>> s.index('O')\n    4\n\n    >>> s.split('O')\n    ['hell', ' w', 'rld']\n\n    >>> sorted(map(FoldedCase, ['GAMMA', 'alpha', 'Beta']))\n    ['alpha', 'Beta', 'GAMMA']\n\n    Sequence membership is straightforward.\n\n    >>> \"Hello World\" in [s]\n    True\n    >>> s in [\"Hello World\"]\n    True\n\n    You may test for set inclusion, but candidate and elements\n    must both be folded.\n\n    >>> FoldedCase(\"Hello World\") in {s}\n    True\n    >>> s in {FoldedCase(\"Hello World\")}\n    True\n\n    String inclusion works as long as the FoldedCase object\n    is on the right.\n\n    >>> \"hello\" in FoldedCase(\"Hello World\")\n    True\n\n    But not if the FoldedCase object is on the left:\n\n    >>> FoldedCase('hello') in 'Hello World'\n    False\n\n    In that case, use in_:\n\n    >>> FoldedCase('hello').in_('Hello World')\n    True\n\n    >>> FoldedCase('hello') > FoldedCase('Hello')\n    False\n    \"\"\"\n\n    def __lt__(self, other):\n        return self.lower() < other.lower()\n\n    def __gt__(self, other):\n        return self.lower() > other.lower()\n\n    def __eq__(self, other):\n        return self.lower() == other.lower()\n\n    def __ne__(self, other):\n        return self.lower() != other.lower()\n\n    def __hash__(self):\n        return hash(self.lower())\n\n    def __contains__(self, other):\n        return super().lower().__contains__(other.lower())\n\n    def in_(self, other):\n        \"Does self appear in other?\"\n        return self in FoldedCase(other)\n\n    # cache lower since it's likely to be called frequently.\n    @method_cache\n    def lower(self):\n        return super().lower()\n\n    def index(self, sub):\n        return self.lower().index(sub.lower())\n\n    def split(self, splitter=' ', maxsplit=0):\n        pattern = re.compile(re.escape(splitter), re.I)\n        return pattern.split(self, maxsplit)\n", "importlib_metadata/_collections.py": "import collections\n\n\n# from jaraco.collections 3.3\nclass FreezableDefaultDict(collections.defaultdict):\n    \"\"\"\n    Often it is desirable to prevent the mutation of\n    a default dict after its initial construction, such\n    as to prevent mutation during iteration.\n\n    >>> dd = FreezableDefaultDict(list)\n    >>> dd[0].append('1')\n    >>> dd.freeze()\n    >>> dd[1]\n    []\n    >>> len(dd)\n    1\n    \"\"\"\n\n    def __missing__(self, key):\n        return getattr(self, '_frozen', super().__missing__)(key)\n\n    def freeze(self):\n        self._frozen = lambda key: self.default_factory()\n\n\nclass Pair(collections.namedtuple('Pair', 'name value')):\n    @classmethod\n    def parse(cls, text):\n        return cls(*map(str.strip, text.split(\"=\", 1)))\n", "importlib_metadata/_meta.py": "from __future__ import annotations\n\nimport os\nfrom typing import Protocol\nfrom typing import Any, Dict, Iterator, List, Optional, TypeVar, Union, overload\n\n\n_T = TypeVar(\"_T\")\n\n\nclass PackageMetadata(Protocol):\n    def __len__(self) -> int: ...  # pragma: no cover\n\n    def __contains__(self, item: str) -> bool: ...  # pragma: no cover\n\n    def __getitem__(self, key: str) -> str: ...  # pragma: no cover\n\n    def __iter__(self) -> Iterator[str]: ...  # pragma: no cover\n\n    @overload\n    def get(\n        self, name: str, failobj: None = None\n    ) -> Optional[str]: ...  # pragma: no cover\n\n    @overload\n    def get(self, name: str, failobj: _T) -> Union[str, _T]: ...  # pragma: no cover\n\n    # overload per python/importlib_metadata#435\n    @overload\n    def get_all(\n        self, name: str, failobj: None = None\n    ) -> Optional[List[Any]]: ...  # pragma: no cover\n\n    @overload\n    def get_all(self, name: str, failobj: _T) -> Union[List[Any], _T]:\n        \"\"\"\n        Return all values associated with a possibly multi-valued key.\n        \"\"\"\n\n    @property\n    def json(self) -> Dict[str, Union[str, List[str]]]:\n        \"\"\"\n        A JSON-compatible form of the metadata.\n        \"\"\"\n\n\nclass SimplePath(Protocol):\n    \"\"\"\n    A minimal subset of pathlib.Path required by Distribution.\n    \"\"\"\n\n    def joinpath(\n        self, other: Union[str, os.PathLike[str]]\n    ) -> SimplePath: ...  # pragma: no cover\n\n    def __truediv__(\n        self, other: Union[str, os.PathLike[str]]\n    ) -> SimplePath: ...  # pragma: no cover\n\n    @property\n    def parent(self) -> SimplePath: ...  # pragma: no cover\n\n    def read_text(self, encoding=None) -> str: ...  # pragma: no cover\n\n    def read_bytes(self) -> bytes: ...  # pragma: no cover\n\n    def exists(self) -> bool: ...  # pragma: no cover\n", "importlib_metadata/_adapters.py": "import re\nimport textwrap\nimport email.message\n\nfrom ._text import FoldedCase\n\n\nclass Message(email.message.Message):\n    multiple_use_keys = set(\n        map(\n            FoldedCase,\n            [\n                'Classifier',\n                'Obsoletes-Dist',\n                'Platform',\n                'Project-URL',\n                'Provides-Dist',\n                'Provides-Extra',\n                'Requires-Dist',\n                'Requires-External',\n                'Supported-Platform',\n                'Dynamic',\n            ],\n        )\n    )\n    \"\"\"\n    Keys that may be indicated multiple times per PEP 566.\n    \"\"\"\n\n    def __new__(cls, orig: email.message.Message):\n        res = super().__new__(cls)\n        vars(res).update(vars(orig))\n        return res\n\n    def __init__(self, *args, **kwargs):\n        self._headers = self._repair_headers()\n\n    # suppress spurious error from mypy\n    def __iter__(self):\n        return super().__iter__()\n\n    def __getitem__(self, item):\n        \"\"\"\n        Override parent behavior to typical dict behavior.\n\n        ``email.message.Message`` will emit None values for missing\n        keys. Typical mappings, including this ``Message``, will raise\n        a key error for missing keys.\n\n        Ref python/importlib_metadata#371.\n        \"\"\"\n        res = super().__getitem__(item)\n        if res is None:\n            raise KeyError(item)\n        return res\n\n    def _repair_headers(self):\n        def redent(value):\n            \"Correct for RFC822 indentation\"\n            if not value or '\\n' not in value:\n                return value\n            return textwrap.dedent(' ' * 8 + value)\n\n        headers = [(key, redent(value)) for key, value in vars(self)['_headers']]\n        if self._payload:\n            headers.append(('Description', self.get_payload()))\n        return headers\n\n    @property\n    def json(self):\n        \"\"\"\n        Convert PackageMetadata to a JSON-compatible format\n        per PEP 0566.\n        \"\"\"\n\n        def transform(key):\n            value = self.get_all(key) if key in self.multiple_use_keys else self[key]\n            if key == 'Keywords':\n                value = re.split(r'\\s+', value)\n            tk = key.lower().replace('-', '_')\n            return tk, value\n\n        return dict(map(transform, map(FoldedCase, self)))\n", "importlib_metadata/_functools.py": "import types\nimport functools\n\n\n# from jaraco.functools 3.3\ndef method_cache(method, cache_wrapper=None):\n    \"\"\"\n    Wrap lru_cache to support storing the cache data in the object instances.\n\n    Abstracts the common paradigm where the method explicitly saves an\n    underscore-prefixed protected property on first call and returns that\n    subsequently.\n\n    >>> class MyClass:\n    ...     calls = 0\n    ...\n    ...     @method_cache\n    ...     def method(self, value):\n    ...         self.calls += 1\n    ...         return value\n\n    >>> a = MyClass()\n    >>> a.method(3)\n    3\n    >>> for x in range(75):\n    ...     res = a.method(x)\n    >>> a.calls\n    75\n\n    Note that the apparent behavior will be exactly like that of lru_cache\n    except that the cache is stored on each instance, so values in one\n    instance will not flush values from another, and when an instance is\n    deleted, so are the cached values for that instance.\n\n    >>> b = MyClass()\n    >>> for x in range(35):\n    ...     res = b.method(x)\n    >>> b.calls\n    35\n    >>> a.method(0)\n    0\n    >>> a.calls\n    75\n\n    Note that if method had been decorated with ``functools.lru_cache()``,\n    a.calls would have been 76 (due to the cached value of 0 having been\n    flushed by the 'b' instance).\n\n    Clear the cache with ``.cache_clear()``\n\n    >>> a.method.cache_clear()\n\n    Same for a method that hasn't yet been called.\n\n    >>> c = MyClass()\n    >>> c.method.cache_clear()\n\n    Another cache wrapper may be supplied:\n\n    >>> cache = functools.lru_cache(maxsize=2)\n    >>> MyClass.method2 = method_cache(lambda self: 3, cache_wrapper=cache)\n    >>> a = MyClass()\n    >>> a.method2()\n    3\n\n    Caution - do not subsequently wrap the method with another decorator, such\n    as ``@property``, which changes the semantics of the function.\n\n    See also\n    http://code.activestate.com/recipes/577452-a-memoize-decorator-for-instance-methods/\n    for another implementation and additional justification.\n    \"\"\"\n    cache_wrapper = cache_wrapper or functools.lru_cache()\n\n    def wrapper(self, *args, **kwargs):\n        # it's the first call, replace the method with a cached, bound method\n        bound_method = types.MethodType(method, self)\n        cached_method = cache_wrapper(bound_method)\n        setattr(self, method.__name__, cached_method)\n        return cached_method(*args, **kwargs)\n\n    # Support cache clear even before cache has been created.\n    wrapper.cache_clear = lambda: None\n\n    return wrapper\n\n\n# From jaraco.functools 3.3\ndef pass_none(func):\n    \"\"\"\n    Wrap func so it's not called if its first param is None\n\n    >>> print_text = pass_none(print)\n    >>> print_text('text')\n    text\n    >>> print_text(None)\n    \"\"\"\n\n    @functools.wraps(func)\n    def wrapper(param, *args, **kwargs):\n        if param is not None:\n            return func(param, *args, **kwargs)\n\n    return wrapper\n", "importlib_metadata/_compat.py": "import sys\nimport platform\n\n\n__all__ = ['install', 'NullFinder']\n\n\ndef install(cls):\n    \"\"\"\n    Class decorator for installation on sys.meta_path.\n\n    Adds the backport DistributionFinder to sys.meta_path and\n    attempts to disable the finder functionality of the stdlib\n    DistributionFinder.\n    \"\"\"\n    sys.meta_path.append(cls())\n    disable_stdlib_finder()\n    return cls\n\n\ndef disable_stdlib_finder():\n    \"\"\"\n    Give the backport primacy for discovering path-based distributions\n    by monkey-patching the stdlib O_O.\n\n    See #91 for more background for rationale on this sketchy\n    behavior.\n    \"\"\"\n\n    def matches(finder):\n        return getattr(\n            finder, '__module__', None\n        ) == '_frozen_importlib_external' and hasattr(finder, 'find_distributions')\n\n    for finder in filter(matches, sys.meta_path):  # pragma: nocover\n        del finder.find_distributions\n\n\nclass NullFinder:\n    \"\"\"\n    A \"Finder\" (aka \"MetaPathFinder\") that never finds any modules,\n    but may find distributions.\n    \"\"\"\n\n    @staticmethod\n    def find_spec(*args, **kwargs):\n        return None\n\n\ndef pypy_partial(val):\n    \"\"\"\n    Adjust for variable stacklevel on partial under PyPy.\n\n    Workaround for #327.\n    \"\"\"\n    is_pypy = platform.python_implementation() == 'PyPy'\n    return val + is_pypy\n", "importlib_metadata/__init__.py": "from __future__ import annotations\n\nimport os\nimport re\nimport abc\nimport sys\nimport json\nimport zipp\nimport email\nimport types\nimport inspect\nimport pathlib\nimport operator\nimport textwrap\nimport functools\nimport itertools\nimport posixpath\nimport collections\n\nfrom . import _meta\nfrom .compat import py39, py311\nfrom ._collections import FreezableDefaultDict, Pair\nfrom ._compat import (\n    NullFinder,\n    install,\n)\nfrom ._functools import method_cache, pass_none\nfrom ._itertools import always_iterable, unique_everseen\nfrom ._meta import PackageMetadata, SimplePath\n\nfrom contextlib import suppress\nfrom importlib import import_module\nfrom importlib.abc import MetaPathFinder\nfrom itertools import starmap\nfrom typing import Any, Iterable, List, Mapping, Match, Optional, Set, cast\n\n__all__ = [\n    'Distribution',\n    'DistributionFinder',\n    'PackageMetadata',\n    'PackageNotFoundError',\n    'distribution',\n    'distributions',\n    'entry_points',\n    'files',\n    'metadata',\n    'packages_distributions',\n    'requires',\n    'version',\n]\n\n\nclass PackageNotFoundError(ModuleNotFoundError):\n    \"\"\"The package was not found.\"\"\"\n\n    def __str__(self) -> str:\n        return f\"No package metadata was found for {self.name}\"\n\n    @property\n    def name(self) -> str:  # type: ignore[override]\n        (name,) = self.args\n        return name\n\n\nclass Sectioned:\n    \"\"\"\n    A simple entry point config parser for performance\n\n    >>> for item in Sectioned.read(Sectioned._sample):\n    ...     print(item)\n    Pair(name='sec1', value='# comments ignored')\n    Pair(name='sec1', value='a = 1')\n    Pair(name='sec1', value='b = 2')\n    Pair(name='sec2', value='a = 2')\n\n    >>> res = Sectioned.section_pairs(Sectioned._sample)\n    >>> item = next(res)\n    >>> item.name\n    'sec1'\n    >>> item.value\n    Pair(name='a', value='1')\n    >>> item = next(res)\n    >>> item.value\n    Pair(name='b', value='2')\n    >>> item = next(res)\n    >>> item.name\n    'sec2'\n    >>> item.value\n    Pair(name='a', value='2')\n    >>> list(res)\n    []\n    \"\"\"\n\n    _sample = textwrap.dedent(\n        \"\"\"\n        [sec1]\n        # comments ignored\n        a = 1\n        b = 2\n\n        [sec2]\n        a = 2\n        \"\"\"\n    ).lstrip()\n\n    @classmethod\n    def section_pairs(cls, text):\n        return (\n            section._replace(value=Pair.parse(section.value))\n            for section in cls.read(text, filter_=cls.valid)\n            if section.name is not None\n        )\n\n    @staticmethod\n    def read(text, filter_=None):\n        lines = filter(filter_, map(str.strip, text.splitlines()))\n        name = None\n        for value in lines:\n            section_match = value.startswith('[') and value.endswith(']')\n            if section_match:\n                name = value.strip('[]')\n                continue\n            yield Pair(name, value)\n\n    @staticmethod\n    def valid(line: str):\n        return line and not line.startswith('#')\n\n\nclass EntryPoint:\n    \"\"\"An entry point as defined by Python packaging conventions.\n\n    See `the packaging docs on entry points\n    <https://packaging.python.org/specifications/entry-points/>`_\n    for more information.\n\n    >>> ep = EntryPoint(\n    ...     name=None, group=None, value='package.module:attr [extra1, extra2]')\n    >>> ep.module\n    'package.module'\n    >>> ep.attr\n    'attr'\n    >>> ep.extras\n    ['extra1', 'extra2']\n    \"\"\"\n\n    pattern = re.compile(\n        r'(?P<module>[\\w.]+)\\s*'\n        r'(:\\s*(?P<attr>[\\w.]+)\\s*)?'\n        r'((?P<extras>\\[.*\\])\\s*)?$'\n    )\n    \"\"\"\n    A regular expression describing the syntax for an entry point,\n    which might look like:\n\n        - module\n        - package.module\n        - package.module:attribute\n        - package.module:object.attribute\n        - package.module:attr [extra1, extra2]\n\n    Other combinations are possible as well.\n\n    The expression is lenient about whitespace around the ':',\n    following the attr, and following any extras.\n    \"\"\"\n\n    name: str\n    value: str\n    group: str\n\n    dist: Optional[Distribution] = None\n\n    def __init__(self, name: str, value: str, group: str) -> None:\n        vars(self).update(name=name, value=value, group=group)\n\n    def load(self) -> Any:\n        \"\"\"Load the entry point from its definition. If only a module\n        is indicated by the value, return that module. Otherwise,\n        return the named object.\n        \"\"\"\n        match = cast(Match, self.pattern.match(self.value))\n        module = import_module(match.group('module'))\n        attrs = filter(None, (match.group('attr') or '').split('.'))\n        return functools.reduce(getattr, attrs, module)\n\n    @property\n    def module(self) -> str:\n        match = self.pattern.match(self.value)\n        assert match is not None\n        return match.group('module')\n\n    @property\n    def attr(self) -> str:\n        match = self.pattern.match(self.value)\n        assert match is not None\n        return match.group('attr')\n\n    @property\n    def extras(self) -> List[str]:\n        match = self.pattern.match(self.value)\n        assert match is not None\n        return re.findall(r'\\w+', match.group('extras') or '')\n\n    def _for(self, dist):\n        vars(self).update(dist=dist)\n        return self\n\n    def matches(self, **params):\n        \"\"\"\n        EntryPoint matches the given parameters.\n\n        >>> ep = EntryPoint(group='foo', name='bar', value='bing:bong [extra1, extra2]')\n        >>> ep.matches(group='foo')\n        True\n        >>> ep.matches(name='bar', value='bing:bong [extra1, extra2]')\n        True\n        >>> ep.matches(group='foo', name='other')\n        False\n        >>> ep.matches()\n        True\n        >>> ep.matches(extras=['extra1', 'extra2'])\n        True\n        >>> ep.matches(module='bing')\n        True\n        >>> ep.matches(attr='bong')\n        True\n        \"\"\"\n        attrs = (getattr(self, param) for param in params)\n        return all(map(operator.eq, params.values(), attrs))\n\n    def _key(self):\n        return self.name, self.value, self.group\n\n    def __lt__(self, other):\n        return self._key() < other._key()\n\n    def __eq__(self, other):\n        return self._key() == other._key()\n\n    def __setattr__(self, name, value):\n        raise AttributeError(\"EntryPoint objects are immutable.\")\n\n    def __repr__(self):\n        return (\n            f'EntryPoint(name={self.name!r}, value={self.value!r}, '\n            f'group={self.group!r})'\n        )\n\n    def __hash__(self) -> int:\n        return hash(self._key())\n\n\nclass EntryPoints(tuple):\n    \"\"\"\n    An immutable collection of selectable EntryPoint objects.\n    \"\"\"\n\n    __slots__ = ()\n\n    def __getitem__(self, name: str) -> EntryPoint:  # type: ignore[override]\n        \"\"\"\n        Get the EntryPoint in self matching name.\n        \"\"\"\n        try:\n            return next(iter(self.select(name=name)))\n        except StopIteration:\n            raise KeyError(name)\n\n    def __repr__(self):\n        \"\"\"\n        Repr with classname and tuple constructor to\n        signal that we deviate from regular tuple behavior.\n        \"\"\"\n        return '%s(%r)' % (self.__class__.__name__, tuple(self))\n\n    def select(self, **params) -> EntryPoints:\n        \"\"\"\n        Select entry points from self that match the\n        given parameters (typically group and/or name).\n        \"\"\"\n        return EntryPoints(ep for ep in self if py39.ep_matches(ep, **params))\n\n    @property\n    def names(self) -> Set[str]:\n        \"\"\"\n        Return the set of all names of all entry points.\n        \"\"\"\n        return {ep.name for ep in self}\n\n    @property\n    def groups(self) -> Set[str]:\n        \"\"\"\n        Return the set of all groups of all entry points.\n        \"\"\"\n        return {ep.group for ep in self}\n\n    @classmethod\n    def _from_text_for(cls, text, dist):\n        return cls(ep._for(dist) for ep in cls._from_text(text))\n\n    @staticmethod\n    def _from_text(text):\n        return (\n            EntryPoint(name=item.value.name, value=item.value.value, group=item.name)\n            for item in Sectioned.section_pairs(text or '')\n        )\n\n\nclass PackagePath(pathlib.PurePosixPath):\n    \"\"\"A reference to a path in a package\"\"\"\n\n    hash: Optional[FileHash]\n    size: int\n    dist: Distribution\n\n    def read_text(self, encoding: str = 'utf-8') -> str:  # type: ignore[override]\n        return self.locate().read_text(encoding=encoding)\n\n    def read_binary(self) -> bytes:\n        return self.locate().read_bytes()\n\n    def locate(self) -> SimplePath:\n        \"\"\"Return a path-like object for this path\"\"\"\n        return self.dist.locate_file(self)\n\n\nclass FileHash:\n    def __init__(self, spec: str) -> None:\n        self.mode, _, self.value = spec.partition('=')\n\n    def __repr__(self) -> str:\n        return f'<FileHash mode: {self.mode} value: {self.value}>'\n\n\nclass Distribution(metaclass=abc.ABCMeta):\n    \"\"\"\n    An abstract Python distribution package.\n\n    Custom providers may derive from this class and define\n    the abstract methods to provide a concrete implementation\n    for their environment. Some providers may opt to override\n    the default implementation of some properties to bypass\n    the file-reading mechanism.\n    \"\"\"\n\n    @abc.abstractmethod\n    def read_text(self, filename) -> Optional[str]:\n        \"\"\"Attempt to load metadata file given by the name.\n\n        Python distribution metadata is organized by blobs of text\n        typically represented as \"files\" in the metadata directory\n        (e.g. package-1.0.dist-info). These files include things\n        like:\n\n        - METADATA: The distribution metadata including fields\n          like Name and Version and Description.\n        - entry_points.txt: A series of entry points as defined in\n          `the entry points spec <https://packaging.python.org/en/latest/specifications/entry-points/#file-format>`_.\n        - RECORD: A record of files according to\n          `this recording spec <https://packaging.python.org/en/latest/specifications/recording-installed-packages/#the-record-file>`_.\n\n        A package may provide any set of files, including those\n        not listed here or none at all.\n\n        :param filename: The name of the file in the distribution info.\n        :return: The text if found, otherwise None.\n        \"\"\"\n\n    @abc.abstractmethod\n    def locate_file(self, path: str | os.PathLike[str]) -> SimplePath:\n        \"\"\"\n        Given a path to a file in this distribution, return a SimplePath\n        to it.\n        \"\"\"\n\n    @classmethod\n    def from_name(cls, name: str) -> Distribution:\n        \"\"\"Return the Distribution for the given package name.\n\n        :param name: The name of the distribution package to search for.\n        :return: The Distribution instance (or subclass thereof) for the named\n            package, if found.\n        :raises PackageNotFoundError: When the named package's distribution\n            metadata cannot be found.\n        :raises ValueError: When an invalid value is supplied for name.\n        \"\"\"\n        if not name:\n            raise ValueError(\"A distribution name is required.\")\n        try:\n            return next(iter(cls.discover(name=name)))\n        except StopIteration:\n            raise PackageNotFoundError(name)\n\n    @classmethod\n    def discover(\n        cls, *, context: Optional[DistributionFinder.Context] = None, **kwargs\n    ) -> Iterable[Distribution]:\n        \"\"\"Return an iterable of Distribution objects for all packages.\n\n        Pass a ``context`` or pass keyword arguments for constructing\n        a context.\n\n        :context: A ``DistributionFinder.Context`` object.\n        :return: Iterable of Distribution objects for packages matching\n          the context.\n        \"\"\"\n        if context and kwargs:\n            raise ValueError(\"cannot accept context and kwargs\")\n        context = context or DistributionFinder.Context(**kwargs)\n        return itertools.chain.from_iterable(\n            resolver(context) for resolver in cls._discover_resolvers()\n        )\n\n    @staticmethod\n    def at(path: str | os.PathLike[str]) -> Distribution:\n        \"\"\"Return a Distribution for the indicated metadata path.\n\n        :param path: a string or path-like object\n        :return: a concrete Distribution instance for the path\n        \"\"\"\n        return PathDistribution(pathlib.Path(path))\n\n    @staticmethod\n    def _discover_resolvers():\n        \"\"\"Search the meta_path for resolvers (MetadataPathFinders).\"\"\"\n        declared = (\n            getattr(finder, 'find_distributions', None) for finder in sys.meta_path\n        )\n        return filter(None, declared)\n\n    @property\n    def metadata(self) -> _meta.PackageMetadata:\n        \"\"\"Return the parsed metadata for this Distribution.\n\n        The returned object will have keys that name the various bits of\n        metadata per the\n        `Core metadata specifications <https://packaging.python.org/en/latest/specifications/core-metadata/#core-metadata>`_.\n\n        Custom providers may provide the METADATA file or override this\n        property.\n        \"\"\"\n        # deferred for performance (python/cpython#109829)\n        from . import _adapters\n\n        opt_text = (\n            self.read_text('METADATA')\n            or self.read_text('PKG-INFO')\n            # This last clause is here to support old egg-info files.  Its\n            # effect is to just end up using the PathDistribution's self._path\n            # (which points to the egg-info file) attribute unchanged.\n            or self.read_text('')\n        )\n        text = cast(str, opt_text)\n        return _adapters.Message(email.message_from_string(text))\n\n    @property\n    def name(self) -> str:\n        \"\"\"Return the 'Name' metadata for the distribution package.\"\"\"\n        return self.metadata['Name']\n\n    @property\n    def _normalized_name(self):\n        \"\"\"Return a normalized version of the name.\"\"\"\n        return Prepared.normalize(self.name)\n\n    @property\n    def version(self) -> str:\n        \"\"\"Return the 'Version' metadata for the distribution package.\"\"\"\n        return self.metadata['Version']\n\n    @property\n    def entry_points(self) -> EntryPoints:\n        \"\"\"\n        Return EntryPoints for this distribution.\n\n        Custom providers may provide the ``entry_points.txt`` file\n        or override this property.\n        \"\"\"\n        return EntryPoints._from_text_for(self.read_text('entry_points.txt'), self)\n\n    @property\n    def files(self) -> Optional[List[PackagePath]]:\n        \"\"\"Files in this distribution.\n\n        :return: List of PackagePath for this distribution or None\n\n        Result is `None` if the metadata file that enumerates files\n        (i.e. RECORD for dist-info, or installed-files.txt or\n        SOURCES.txt for egg-info) is missing.\n        Result may be empty if the metadata exists but is empty.\n\n        Custom providers are recommended to provide a \"RECORD\" file (in\n        ``read_text``) or override this property to allow for callers to be\n        able to resolve filenames provided by the package.\n        \"\"\"\n\n        def make_file(name, hash=None, size_str=None):\n            result = PackagePath(name)\n            result.hash = FileHash(hash) if hash else None\n            result.size = int(size_str) if size_str else None\n            result.dist = self\n            return result\n\n        @pass_none\n        def make_files(lines):\n            # Delay csv import, since Distribution.files is not as widely used\n            # as other parts of importlib.metadata\n            import csv\n\n            return starmap(make_file, csv.reader(lines))\n\n        @pass_none\n        def skip_missing_files(package_paths):\n            return list(filter(lambda path: path.locate().exists(), package_paths))\n\n        return skip_missing_files(\n            make_files(\n                self._read_files_distinfo()\n                or self._read_files_egginfo_installed()\n                or self._read_files_egginfo_sources()\n            )\n        )\n\n    def _read_files_distinfo(self):\n        \"\"\"\n        Read the lines of RECORD.\n        \"\"\"\n        text = self.read_text('RECORD')\n        return text and text.splitlines()\n\n    def _read_files_egginfo_installed(self):\n        \"\"\"\n        Read installed-files.txt and return lines in a similar\n        CSV-parsable format as RECORD: each file must be placed\n        relative to the site-packages directory and must also be\n        quoted (since file names can contain literal commas).\n\n        This file is written when the package is installed by pip,\n        but it might not be written for other installation methods.\n        Assume the file is accurate if it exists.\n        \"\"\"\n        text = self.read_text('installed-files.txt')\n        # Prepend the .egg-info/ subdir to the lines in this file.\n        # But this subdir is only available from PathDistribution's\n        # self._path.\n        subdir = getattr(self, '_path', None)\n        if not text or not subdir:\n            return\n\n        paths = (\n            py311.relative_fix((subdir / name).resolve())\n            .relative_to(self.locate_file('').resolve(), walk_up=True)\n            .as_posix()\n            for name in text.splitlines()\n        )\n        return map('\"{}\"'.format, paths)\n\n    def _read_files_egginfo_sources(self):\n        \"\"\"\n        Read SOURCES.txt and return lines in a similar CSV-parsable\n        format as RECORD: each file name must be quoted (since it\n        might contain literal commas).\n\n        Note that SOURCES.txt is not a reliable source for what\n        files are installed by a package. This file is generated\n        for a source archive, and the files that are present\n        there (e.g. setup.py) may not correctly reflect the files\n        that are present after the package has been installed.\n        \"\"\"\n        text = self.read_text('SOURCES.txt')\n        return text and map('\"{}\"'.format, text.splitlines())\n\n    @property\n    def requires(self) -> Optional[List[str]]:\n        \"\"\"Generated requirements specified for this Distribution\"\"\"\n        reqs = self._read_dist_info_reqs() or self._read_egg_info_reqs()\n        return reqs and list(reqs)\n\n    def _read_dist_info_reqs(self):\n        return self.metadata.get_all('Requires-Dist')\n\n    def _read_egg_info_reqs(self):\n        source = self.read_text('requires.txt')\n        return pass_none(self._deps_from_requires_text)(source)\n\n    @classmethod\n    def _deps_from_requires_text(cls, source):\n        return cls._convert_egg_info_reqs_to_simple_reqs(Sectioned.read(source))\n\n    @staticmethod\n    def _convert_egg_info_reqs_to_simple_reqs(sections):\n        \"\"\"\n        Historically, setuptools would solicit and store 'extra'\n        requirements, including those with environment markers,\n        in separate sections. More modern tools expect each\n        dependency to be defined separately, with any relevant\n        extras and environment markers attached directly to that\n        requirement. This method converts the former to the\n        latter. See _test_deps_from_requires_text for an example.\n        \"\"\"\n\n        def make_condition(name):\n            return name and f'extra == \"{name}\"'\n\n        def quoted_marker(section):\n            section = section or ''\n            extra, sep, markers = section.partition(':')\n            if extra and markers:\n                markers = f'({markers})'\n            conditions = list(filter(None, [markers, make_condition(extra)]))\n            return '; ' + ' and '.join(conditions) if conditions else ''\n\n        def url_req_space(req):\n            \"\"\"\n            PEP 508 requires a space between the url_spec and the quoted_marker.\n            Ref python/importlib_metadata#357.\n            \"\"\"\n            # '@' is uniquely indicative of a url_req.\n            return ' ' * ('@' in req)\n\n        for section in sections:\n            space = url_req_space(section.value)\n            yield section.value + space + quoted_marker(section.name)\n\n    @property\n    def origin(self):\n        return self._load_json('direct_url.json')\n\n    def _load_json(self, filename):\n        return pass_none(json.loads)(\n            self.read_text(filename),\n            object_hook=lambda data: types.SimpleNamespace(**data),\n        )\n\n\nclass DistributionFinder(MetaPathFinder):\n    \"\"\"\n    A MetaPathFinder capable of discovering installed distributions.\n\n    Custom providers should implement this interface in order to\n    supply metadata.\n    \"\"\"\n\n    class Context:\n        \"\"\"\n        Keyword arguments presented by the caller to\n        ``distributions()`` or ``Distribution.discover()``\n        to narrow the scope of a search for distributions\n        in all DistributionFinders.\n\n        Each DistributionFinder may expect any parameters\n        and should attempt to honor the canonical\n        parameters defined below when appropriate.\n\n        This mechanism gives a custom provider a means to\n        solicit additional details from the caller beyond\n        \"name\" and \"path\" when searching distributions.\n        For example, imagine a provider that exposes suites\n        of packages in either a \"public\" or \"private\" ``realm``.\n        A caller may wish to query only for distributions in\n        a particular realm and could call\n        ``distributions(realm=\"private\")`` to signal to the\n        custom provider to only include distributions from that\n        realm.\n        \"\"\"\n\n        name = None\n        \"\"\"\n        Specific name for which a distribution finder should match.\n        A name of ``None`` matches all distributions.\n        \"\"\"\n\n        def __init__(self, **kwargs):\n            vars(self).update(kwargs)\n\n        @property\n        def path(self) -> List[str]:\n            \"\"\"\n            The sequence of directory path that a distribution finder\n            should search.\n\n            Typically refers to Python installed package paths such as\n            \"site-packages\" directories and defaults to ``sys.path``.\n            \"\"\"\n            return vars(self).get('path', sys.path)\n\n    @abc.abstractmethod\n    def find_distributions(self, context=Context()) -> Iterable[Distribution]:\n        \"\"\"\n        Find distributions.\n\n        Return an iterable of all Distribution instances capable of\n        loading the metadata for packages matching the ``context``,\n        a DistributionFinder.Context instance.\n        \"\"\"\n\n\nclass FastPath:\n    \"\"\"\n    Micro-optimized class for searching a root for children.\n\n    Root is a path on the file system that may contain metadata\n    directories either as natural directories or within a zip file.\n\n    >>> FastPath('').children()\n    ['...']\n\n    FastPath objects are cached and recycled for any given root.\n\n    >>> FastPath('foobar') is FastPath('foobar')\n    True\n    \"\"\"\n\n    @functools.lru_cache()  # type: ignore\n    def __new__(cls, root):\n        return super().__new__(cls)\n\n    def __init__(self, root):\n        self.root = root\n\n    def joinpath(self, child):\n        return pathlib.Path(self.root, child)\n\n    def children(self):\n        with suppress(Exception):\n            return os.listdir(self.root or '.')\n        with suppress(Exception):\n            return self.zip_children()\n        return []\n\n    def zip_children(self):\n        zip_path = zipp.Path(self.root)\n        names = zip_path.root.namelist()\n        self.joinpath = zip_path.joinpath\n\n        return dict.fromkeys(child.split(posixpath.sep, 1)[0] for child in names)\n\n    def search(self, name):\n        return self.lookup(self.mtime).search(name)\n\n    @property\n    def mtime(self):\n        with suppress(OSError):\n            return os.stat(self.root).st_mtime\n        self.lookup.cache_clear()\n\n    @method_cache\n    def lookup(self, mtime):\n        return Lookup(self)\n\n\nclass Lookup:\n    \"\"\"\n    A micro-optimized class for searching a (fast) path for metadata.\n    \"\"\"\n\n    def __init__(self, path: FastPath):\n        \"\"\"\n        Calculate all of the children representing metadata.\n\n        From the children in the path, calculate early all of the\n        children that appear to represent metadata (infos) or legacy\n        metadata (eggs).\n        \"\"\"\n\n        base = os.path.basename(path.root).lower()\n        base_is_egg = base.endswith(\".egg\")\n        self.infos = FreezableDefaultDict(list)\n        self.eggs = FreezableDefaultDict(list)\n\n        for child in path.children():\n            low = child.lower()\n            if low.endswith((\".dist-info\", \".egg-info\")):\n                # rpartition is faster than splitext and suitable for this purpose.\n                name = low.rpartition(\".\")[0].partition(\"-\")[0]\n                normalized = Prepared.normalize(name)\n                self.infos[normalized].append(path.joinpath(child))\n            elif base_is_egg and low == \"egg-info\":\n                name = base.rpartition(\".\")[0].partition(\"-\")[0]\n                legacy_normalized = Prepared.legacy_normalize(name)\n                self.eggs[legacy_normalized].append(path.joinpath(child))\n\n        self.infos.freeze()\n        self.eggs.freeze()\n\n    def search(self, prepared: Prepared):\n        \"\"\"\n        Yield all infos and eggs matching the Prepared query.\n        \"\"\"\n        infos = (\n            self.infos[prepared.normalized]\n            if prepared\n            else itertools.chain.from_iterable(self.infos.values())\n        )\n        eggs = (\n            self.eggs[prepared.legacy_normalized]\n            if prepared\n            else itertools.chain.from_iterable(self.eggs.values())\n        )\n        return itertools.chain(infos, eggs)\n\n\nclass Prepared:\n    \"\"\"\n    A prepared search query for metadata on a possibly-named package.\n\n    Pre-calculates the normalization to prevent repeated operations.\n\n    >>> none = Prepared(None)\n    >>> none.normalized\n    >>> none.legacy_normalized\n    >>> bool(none)\n    False\n    >>> sample = Prepared('Sample__Pkg-name.foo')\n    >>> sample.normalized\n    'sample_pkg_name_foo'\n    >>> sample.legacy_normalized\n    'sample__pkg_name.foo'\n    >>> bool(sample)\n    True\n    \"\"\"\n\n    normalized = None\n    legacy_normalized = None\n\n    def __init__(self, name: Optional[str]):\n        self.name = name\n        if name is None:\n            return\n        self.normalized = self.normalize(name)\n        self.legacy_normalized = self.legacy_normalize(name)\n\n    @staticmethod\n    def normalize(name):\n        \"\"\"\n        PEP 503 normalization plus dashes as underscores.\n        \"\"\"\n        return re.sub(r\"[-_.]+\", \"-\", name).lower().replace('-', '_')\n\n    @staticmethod\n    def legacy_normalize(name):\n        \"\"\"\n        Normalize the package name as found in the convention in\n        older packaging tools versions and specs.\n        \"\"\"\n        return name.lower().replace('-', '_')\n\n    def __bool__(self):\n        return bool(self.name)\n\n\n@install\nclass MetadataPathFinder(NullFinder, DistributionFinder):\n    \"\"\"A degenerate finder for distribution packages on the file system.\n\n    This finder supplies only a find_distributions() method for versions\n    of Python that do not have a PathFinder find_distributions().\n    \"\"\"\n\n    @classmethod\n    def find_distributions(\n        cls, context=DistributionFinder.Context()\n    ) -> Iterable[PathDistribution]:\n        \"\"\"\n        Find distributions.\n\n        Return an iterable of all Distribution instances capable of\n        loading the metadata for packages matching ``context.name``\n        (or all names if ``None`` indicated) along the paths in the list\n        of directories ``context.path``.\n        \"\"\"\n        found = cls._search_paths(context.name, context.path)\n        return map(PathDistribution, found)\n\n    @classmethod\n    def _search_paths(cls, name, paths):\n        \"\"\"Find metadata directories in paths heuristically.\"\"\"\n        prepared = Prepared(name)\n        return itertools.chain.from_iterable(\n            path.search(prepared) for path in map(FastPath, paths)\n        )\n\n    @classmethod\n    def invalidate_caches(cls) -> None:\n        FastPath.__new__.cache_clear()\n\n\nclass PathDistribution(Distribution):\n    def __init__(self, path: SimplePath) -> None:\n        \"\"\"Construct a distribution.\n\n        :param path: SimplePath indicating the metadata directory.\n        \"\"\"\n        self._path = path\n\n    def read_text(self, filename: str | os.PathLike[str]) -> Optional[str]:\n        with suppress(\n            FileNotFoundError,\n            IsADirectoryError,\n            KeyError,\n            NotADirectoryError,\n            PermissionError,\n        ):\n            return self._path.joinpath(filename).read_text(encoding='utf-8')\n\n        return None\n\n    read_text.__doc__ = Distribution.read_text.__doc__\n\n    def locate_file(self, path: str | os.PathLike[str]) -> SimplePath:\n        return self._path.parent / path\n\n    @property\n    def _normalized_name(self):\n        \"\"\"\n        Performance optimization: where possible, resolve the\n        normalized name from the file system path.\n        \"\"\"\n        stem = os.path.basename(str(self._path))\n        return (\n            pass_none(Prepared.normalize)(self._name_from_stem(stem))\n            or super()._normalized_name\n        )\n\n    @staticmethod\n    def _name_from_stem(stem):\n        \"\"\"\n        >>> PathDistribution._name_from_stem('foo-3.0.egg-info')\n        'foo'\n        >>> PathDistribution._name_from_stem('CherryPy-3.0.dist-info')\n        'CherryPy'\n        >>> PathDistribution._name_from_stem('face.egg-info')\n        'face'\n        >>> PathDistribution._name_from_stem('foo.bar')\n        \"\"\"\n        filename, ext = os.path.splitext(stem)\n        if ext not in ('.dist-info', '.egg-info'):\n            return\n        name, sep, rest = filename.partition('-')\n        return name\n\n\ndef distribution(distribution_name: str) -> Distribution:\n    \"\"\"Get the ``Distribution`` instance for the named package.\n\n    :param distribution_name: The name of the distribution package as a string.\n    :return: A ``Distribution`` instance (or subclass thereof).\n    \"\"\"\n    return Distribution.from_name(distribution_name)\n\n\ndef distributions(**kwargs) -> Iterable[Distribution]:\n    \"\"\"Get all ``Distribution`` instances in the current environment.\n\n    :return: An iterable of ``Distribution`` instances.\n    \"\"\"\n    return Distribution.discover(**kwargs)\n\n\ndef metadata(distribution_name: str) -> _meta.PackageMetadata:\n    \"\"\"Get the metadata for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: A PackageMetadata containing the parsed metadata.\n    \"\"\"\n    return Distribution.from_name(distribution_name).metadata\n\n\ndef version(distribution_name: str) -> str:\n    \"\"\"Get the version string for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: The version string for the package as defined in the package's\n        \"Version\" metadata key.\n    \"\"\"\n    return distribution(distribution_name).version\n\n\n_unique = functools.partial(\n    unique_everseen,\n    key=py39.normalized_name,\n)\n\"\"\"\nWrapper for ``distributions`` to return unique distributions by name.\n\"\"\"\n\n\ndef entry_points(**params) -> EntryPoints:\n    \"\"\"Return EntryPoint objects for all installed packages.\n\n    Pass selection parameters (group or name) to filter the\n    result to entry points matching those properties (see\n    EntryPoints.select()).\n\n    :return: EntryPoints for all installed packages.\n    \"\"\"\n    eps = itertools.chain.from_iterable(\n        dist.entry_points for dist in _unique(distributions())\n    )\n    return EntryPoints(eps).select(**params)\n\n\ndef files(distribution_name: str) -> Optional[List[PackagePath]]:\n    \"\"\"Return a list of files for the named package.\n\n    :param distribution_name: The name of the distribution package to query.\n    :return: List of files composing the distribution.\n    \"\"\"\n    return distribution(distribution_name).files\n\n\ndef requires(distribution_name: str) -> Optional[List[str]]:\n    \"\"\"\n    Return a list of requirements for the named package.\n\n    :return: An iterable of requirements, suitable for\n        packaging.requirement.Requirement.\n    \"\"\"\n    return distribution(distribution_name).requires\n\n\ndef packages_distributions() -> Mapping[str, List[str]]:\n    \"\"\"\n    Return a mapping of top-level packages to their\n    distributions.\n\n    >>> import collections.abc\n    >>> pkgs = packages_distributions()\n    >>> all(isinstance(dist, collections.abc.Sequence) for dist in pkgs.values())\n    True\n    \"\"\"\n    pkg_to_dist = collections.defaultdict(list)\n    for dist in distributions():\n        for pkg in _top_level_declared(dist) or _top_level_inferred(dist):\n            pkg_to_dist[pkg].append(dist.metadata['Name'])\n    return dict(pkg_to_dist)\n\n\ndef _top_level_declared(dist):\n    return (dist.read_text('top_level.txt') or '').split()\n\n\ndef _topmost(name: PackagePath) -> Optional[str]:\n    \"\"\"\n    Return the top-most parent as long as there is a parent.\n    \"\"\"\n    top, *rest = name.parts\n    return top if rest else None\n\n\ndef _get_toplevel_name(name: PackagePath) -> str:\n    \"\"\"\n    Infer a possibly importable module name from a name presumed on\n    sys.path.\n\n    >>> _get_toplevel_name(PackagePath('foo.py'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo.pyc'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo/__init__.py'))\n    'foo'\n    >>> _get_toplevel_name(PackagePath('foo.pth'))\n    'foo.pth'\n    >>> _get_toplevel_name(PackagePath('foo.dist-info'))\n    'foo.dist-info'\n    \"\"\"\n    return _topmost(name) or (\n        # python/typeshed#10328\n        inspect.getmodulename(name)  # type: ignore\n        or str(name)\n    )\n\n\ndef _top_level_inferred(dist):\n    opt_names = set(map(_get_toplevel_name, always_iterable(dist.files)))\n\n    def importable_name(name):\n        return '.' not in name\n\n    return filter(importable_name, opt_names)\n", "importlib_metadata/compat/py39.py": "\"\"\"\nCompatibility layer with Python 3.8/3.9\n\"\"\"\n\nfrom typing import TYPE_CHECKING, Any, Optional\n\nif TYPE_CHECKING:  # pragma: no cover\n    # Prevent circular imports on runtime.\n    from .. import Distribution, EntryPoint\nelse:\n    Distribution = EntryPoint = Any\n\n\ndef normalized_name(dist: Distribution) -> Optional[str]:\n    \"\"\"\n    Honor name normalization for distributions that don't provide ``_normalized_name``.\n    \"\"\"\n    try:\n        return dist._normalized_name\n    except AttributeError:\n        from .. import Prepared  # -> delay to prevent circular imports.\n\n        return Prepared.normalize(getattr(dist, \"name\", None) or dist.metadata['Name'])\n\n\ndef ep_matches(ep: EntryPoint, **params) -> bool:\n    \"\"\"\n    Workaround for ``EntryPoint`` objects without the ``matches`` method.\n    \"\"\"\n    try:\n        return ep.matches(**params)\n    except AttributeError:\n        from .. import EntryPoint  # -> delay to prevent circular imports.\n\n        # Reconstruct the EntryPoint object to make sure it is compatible.\n        return EntryPoint(ep.name, ep.value, ep.group).matches(**params)\n", "importlib_metadata/compat/__init__.py": "", "importlib_metadata/compat/py311.py": "import os\nimport pathlib\nimport sys\nimport types\n\n\ndef wrap(path):  # pragma: no cover\n    \"\"\"\n    Workaround for https://github.com/python/cpython/issues/84538\n    to add backward compatibility for walk_up=True.\n    An example affected package is dask-labextension, which uses\n    jupyter-packaging to install JupyterLab javascript files outside\n    of site-packages.\n    \"\"\"\n\n    def relative_to(root, *, walk_up=False):\n        return pathlib.Path(os.path.relpath(path, root))\n\n    return types.SimpleNamespace(relative_to=relative_to)\n\n\nrelative_fix = wrap if sys.version_info < (3, 12) else lambda x: x\n", "docs/conf.py": "extensions = [\n    'sphinx.ext.autodoc',\n    'jaraco.packaging.sphinx',\n]\n\nmaster_doc = \"index\"\nhtml_theme = \"furo\"\n\n# Link dates and other references in the changelog\nextensions += ['rst.linker']\nlink_files = {\n    '../NEWS.rst': dict(\n        using=dict(GH='https://github.com'),\n        replace=[\n            dict(\n                pattern=r'(Issue #|\\B#)(?P<issue>\\d+)',\n                url='{package_url}/issues/{issue}',\n            ),\n            dict(\n                pattern=r'(?m:^((?P<scm_version>v?\\d+(\\.\\d+){1,2}))\\n[-=]+\\n)',\n                with_scm='{text}\\n{rev[timestamp]:%d %b %Y}\\n',\n            ),\n            dict(\n                pattern=r'PEP[- ](?P<pep_number>\\d+)',\n                url='https://peps.python.org/pep-{pep_number:0>4}/',\n            ),\n            dict(\n                pattern=r'(python/cpython#|Python #|py-)(?P<python>\\d+)',\n                url='https://github.com/python/cpython/issues/{python}',\n            ),\n        ],\n    )\n}\n\n# Be strict about any broken references\nnitpicky = True\n\n# Include Python intersphinx mapping to prevent failures\n# jaraco/skeleton#51\nextensions += ['sphinx.ext.intersphinx']\nintersphinx_mapping = {\n    'python': ('https://docs.python.org/3', None),\n}\n\n# Preserve authored syntax for defaults\nautodoc_preserve_defaults = True\n\nextensions += ['jaraco.tidelift']\n\nintersphinx_mapping.update(\n    importlib_resources=(\n        'https://importlib-resources.readthedocs.io/en/latest/',\n        None,\n    ),\n)\n\nintersphinx_mapping.update(\n    packaging=(\n        'https://packaging.python.org/en/latest/',\n        None,\n    ),\n)\n\nnitpick_ignore = [\n    # Workaround for #316\n    ('py:class', 'importlib_metadata.EntryPoints'),\n    ('py:class', 'importlib_metadata.PackagePath'),\n    ('py:class', 'importlib_metadata.SelectableGroups'),\n    ('py:class', 'importlib_metadata._meta._T'),\n    # Workaround for #435\n    ('py:class', '_T'),\n]\n", "docs/__init__.py": "", "tests/test_integration.py": "\"\"\"\nTest behaviors specific to importlib_metadata.\n\nThese tests are excluded downstream in CPython as they\ntest functionality only in importlib_metadata or require\nbehaviors ('packaging') that aren't available in the\nstdlib.\n\"\"\"\n\nimport unittest\nimport packaging.requirements\nimport packaging.version\n\nfrom . import fixtures\nfrom importlib_metadata import (\n    _compat,\n    version,\n)\n\n\nclass IntegrationTests(fixtures.DistInfoPkg, unittest.TestCase):\n    def test_package_spec_installed(self):\n        \"\"\"\n        Illustrate the recommended procedure to determine if\n        a specified version of a package is installed.\n        \"\"\"\n\n        def is_installed(package_spec):\n            req = packaging.requirements.Requirement(package_spec)\n            return version(req.name) in req.specifier\n\n        assert is_installed('distinfo-pkg==1.0')\n        assert is_installed('distinfo-pkg>=1.0,<2.0')\n        assert not is_installed('distinfo-pkg<1.0')\n\n\nclass FinderTests(fixtures.Fixtures, unittest.TestCase):\n    def test_finder_without_module(self):\n        class ModuleFreeFinder:\n            \"\"\"\n            A finder without an __module__ attribute\n            \"\"\"\n\n            def find_module(self, name):\n                pass\n\n            def __getattribute__(self, name):\n                if name == '__module__':\n                    raise AttributeError(name)\n                return super().__getattribute__(name)\n\n        self.fixtures.enter_context(fixtures.install_finder(ModuleFreeFinder()))\n        _compat.disable_stdlib_finder()\n", "tests/test_zip.py": "import sys\nimport unittest\n\nfrom . import fixtures\nfrom importlib_metadata import (\n    PackageNotFoundError,\n    distribution,\n    distributions,\n    entry_points,\n    files,\n    version,\n)\n\n\nclass TestZip(fixtures.ZipFixtures, unittest.TestCase):\n    def setUp(self):\n        super().setUp()\n        self._fixture_on_path('example-21.12-py3-none-any.whl')\n\n    def test_zip_version(self):\n        self.assertEqual(version('example'), '21.12')\n\n    def test_zip_version_does_not_match(self):\n        with self.assertRaises(PackageNotFoundError):\n            version('definitely-not-installed')\n\n    def test_zip_entry_points(self):\n        scripts = entry_points(group='console_scripts')\n        entry_point = scripts['example']\n        self.assertEqual(entry_point.value, 'example:main')\n        entry_point = scripts['Example']\n        self.assertEqual(entry_point.value, 'example:main')\n\n    def test_missing_metadata(self):\n        self.assertIsNone(distribution('example').read_text('does not exist'))\n\n    def test_case_insensitive(self):\n        self.assertEqual(version('Example'), '21.12')\n\n    def test_files(self):\n        for file in files('example'):\n            path = str(file.dist.locate_file(file))\n            assert '.whl/' in path, path\n\n    def test_one_distribution(self):\n        dists = list(distributions(path=sys.path[:1]))\n        assert len(dists) == 1\n\n\nclass TestEgg(TestZip):\n    def setUp(self):\n        super().setUp()\n        self._fixture_on_path('example-21.12-py3.6.egg')\n\n    def test_files(self):\n        for file in files('example'):\n            path = str(file.dist.locate_file(file))\n            assert '.egg/' in path, path\n\n    def test_normalized_name(self):\n        dist = distribution('example')\n        assert dist._normalized_name == 'example'\n", "tests/_context.py": "import contextlib\n\n\n# from jaraco.context 4.3\nclass suppress(contextlib.suppress, contextlib.ContextDecorator):\n    \"\"\"\n    A version of contextlib.suppress with decorator support.\n\n    >>> @suppress(KeyError)\n    ... def key_error():\n    ...     {}['']\n    >>> key_error()\n    \"\"\"\n", "tests/fixtures.py": "import sys\nimport copy\nimport json\nimport shutil\nimport pathlib\nimport textwrap\nimport functools\nimport contextlib\n\nfrom .compat.py312 import import_helper\nfrom .compat.py39 import os_helper\n\nfrom . import _path\nfrom ._path import FilesSpec\n\n\ntry:\n    from importlib import resources  # type: ignore\n\n    getattr(resources, 'files')\n    getattr(resources, 'as_file')\nexcept (ImportError, AttributeError):\n    import importlib_resources as resources  # type: ignore\n\n\n@contextlib.contextmanager\ndef tmp_path():\n    \"\"\"\n    Like os_helper.temp_dir, but yields a pathlib.Path.\n    \"\"\"\n    with os_helper.temp_dir() as path:\n        yield pathlib.Path(path)\n\n\n@contextlib.contextmanager\ndef install_finder(finder):\n    sys.meta_path.append(finder)\n    try:\n        yield\n    finally:\n        sys.meta_path.remove(finder)\n\n\nclass Fixtures:\n    def setUp(self):\n        self.fixtures = contextlib.ExitStack()\n        self.addCleanup(self.fixtures.close)\n\n\nclass SiteDir(Fixtures):\n    def setUp(self):\n        super().setUp()\n        self.site_dir = self.fixtures.enter_context(tmp_path())\n\n\nclass OnSysPath(Fixtures):\n    @staticmethod\n    @contextlib.contextmanager\n    def add_sys_path(dir):\n        sys.path[:0] = [str(dir)]\n        try:\n            yield\n        finally:\n            sys.path.remove(str(dir))\n\n    def setUp(self):\n        super().setUp()\n        self.fixtures.enter_context(self.add_sys_path(self.site_dir))\n        self.fixtures.enter_context(import_helper.isolated_modules())\n\n\nclass SiteBuilder(SiteDir):\n    def setUp(self):\n        super().setUp()\n        for cls in self.__class__.mro():\n            with contextlib.suppress(AttributeError):\n                build_files(cls.files, prefix=self.site_dir)\n\n\nclass DistInfoPkg(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"distinfo_pkg-1.0.0.dist-info\": {\n            \"METADATA\": \"\"\"\n                Name: distinfo-pkg\n                Author: Steven Ma\n                Version: 1.0.0\n                Requires-Dist: wheel >= 1.0\n                Requires-Dist: pytest; extra == 'test'\n                Keywords: sample package\n\n                Once upon a time\n                There was a distinfo pkg\n                \"\"\",\n            \"RECORD\": \"mod.py,sha256=abc,20\\n\",\n            \"entry_points.txt\": \"\"\"\n                [entries]\n                main = mod:main\n                ns:sub = mod:main\n            \"\"\",\n        },\n        \"mod.py\": \"\"\"\n            def main():\n                print(\"hello world\")\n            \"\"\",\n    }\n\n    def make_uppercase(self):\n        \"\"\"\n        Rewrite metadata with everything uppercase.\n        \"\"\"\n        shutil.rmtree(self.site_dir / \"distinfo_pkg-1.0.0.dist-info\")\n        files = copy.deepcopy(DistInfoPkg.files)\n        info = files[\"distinfo_pkg-1.0.0.dist-info\"]\n        info[\"METADATA\"] = info[\"METADATA\"].upper()\n        build_files(files, self.site_dir)\n\n\nclass DistInfoPkgEditable(DistInfoPkg):\n    \"\"\"\n    Package with a PEP 660 direct_url.json.\n    \"\"\"\n\n    some_hash = '524127ce937f7cb65665130c695abd18ca386f60bb29687efb976faa1596fdcc'\n    files: FilesSpec = {\n        'distinfo_pkg-1.0.0.dist-info': {\n            'direct_url.json': json.dumps({\n                \"archive_info\": {\n                    \"hash\": f\"sha256={some_hash}\",\n                    \"hashes\": {\"sha256\": f\"{some_hash}\"},\n                },\n                \"url\": \"file:///path/to/distinfo_pkg-1.0.0.editable-py3-none-any.whl\",\n            })\n        },\n    }\n\n\nclass DistInfoPkgWithDot(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"pkg_dot-1.0.0.dist-info\": {\n            \"METADATA\": \"\"\"\n                Name: pkg.dot\n                Version: 1.0.0\n                \"\"\",\n        },\n    }\n\n\nclass DistInfoPkgWithDotLegacy(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"pkg.dot-1.0.0.dist-info\": {\n            \"METADATA\": \"\"\"\n                Name: pkg.dot\n                Version: 1.0.0\n                \"\"\",\n        },\n        \"pkg.lot.egg-info\": {\n            \"METADATA\": \"\"\"\n                Name: pkg.lot\n                Version: 1.0.0\n                \"\"\",\n        },\n    }\n\n\nclass DistInfoPkgOffPath(SiteBuilder):\n    files = DistInfoPkg.files\n\n\nclass EggInfoPkg(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"egginfo_pkg.egg-info\": {\n            \"PKG-INFO\": \"\"\"\n                Name: egginfo-pkg\n                Author: Steven Ma\n                License: Unknown\n                Version: 1.0.0\n                Classifier: Intended Audience :: Developers\n                Classifier: Topic :: Software Development :: Libraries\n                Keywords: sample package\n                Description: Once upon a time\n                        There was an egginfo package\n                \"\"\",\n            \"SOURCES.txt\": \"\"\"\n                mod.py\n                egginfo_pkg.egg-info/top_level.txt\n            \"\"\",\n            \"entry_points.txt\": \"\"\"\n                [entries]\n                main = mod:main\n            \"\"\",\n            \"requires.txt\": \"\"\"\n                wheel >= 1.0; python_version >= \"2.7\"\n                [test]\n                pytest\n            \"\"\",\n            \"top_level.txt\": \"mod\\n\",\n        },\n        \"mod.py\": \"\"\"\n            def main():\n                print(\"hello world\")\n            \"\"\",\n    }\n\n\nclass EggInfoPkgPipInstalledNoToplevel(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"egg_with_module_pkg.egg-info\": {\n            \"PKG-INFO\": \"Name: egg_with_module-pkg\",\n            # SOURCES.txt is made from the source archive, and contains files\n            # (setup.py) that are not present after installation.\n            \"SOURCES.txt\": \"\"\"\n                egg_with_module.py\n                setup.py\n                egg_with_module_pkg.egg-info/PKG-INFO\n                egg_with_module_pkg.egg-info/SOURCES.txt\n                egg_with_module_pkg.egg-info/top_level.txt\n            \"\"\",\n            # installed-files.txt is written by pip, and is a strictly more\n            # accurate source than SOURCES.txt as to the installed contents of\n            # the package.\n            \"installed-files.txt\": \"\"\"\n                ../egg_with_module.py\n                PKG-INFO\n                SOURCES.txt\n                top_level.txt\n            \"\"\",\n            # missing top_level.txt (to trigger fallback to installed-files.txt)\n        },\n        \"egg_with_module.py\": \"\"\"\n            def main():\n                print(\"hello world\")\n            \"\"\",\n    }\n\n\nclass EggInfoPkgPipInstalledExternalDataFiles(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"egg_with_module_pkg.egg-info\": {\n            \"PKG-INFO\": \"Name: egg_with_module-pkg\",\n            # SOURCES.txt is made from the source archive, and contains files\n            # (setup.py) that are not present after installation.\n            \"SOURCES.txt\": \"\"\"\n                egg_with_module.py\n                setup.py\n                egg_with_module.json\n                egg_with_module_pkg.egg-info/PKG-INFO\n                egg_with_module_pkg.egg-info/SOURCES.txt\n                egg_with_module_pkg.egg-info/top_level.txt\n            \"\"\",\n            # installed-files.txt is written by pip, and is a strictly more\n            # accurate source than SOURCES.txt as to the installed contents of\n            # the package.\n            \"installed-files.txt\": \"\"\"\n                ../../../etc/jupyter/jupyter_notebook_config.d/relative.json\n                /etc/jupyter/jupyter_notebook_config.d/absolute.json\n                ../egg_with_module.py\n                PKG-INFO\n                SOURCES.txt\n                top_level.txt\n            \"\"\",\n            # missing top_level.txt (to trigger fallback to installed-files.txt)\n        },\n        \"egg_with_module.py\": \"\"\"\n            def main():\n                print(\"hello world\")\n            \"\"\",\n    }\n\n\nclass EggInfoPkgPipInstalledNoModules(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"egg_with_no_modules_pkg.egg-info\": {\n            \"PKG-INFO\": \"Name: egg_with_no_modules-pkg\",\n            # SOURCES.txt is made from the source archive, and contains files\n            # (setup.py) that are not present after installation.\n            \"SOURCES.txt\": \"\"\"\n                setup.py\n                egg_with_no_modules_pkg.egg-info/PKG-INFO\n                egg_with_no_modules_pkg.egg-info/SOURCES.txt\n                egg_with_no_modules_pkg.egg-info/top_level.txt\n            \"\"\",\n            # installed-files.txt is written by pip, and is a strictly more\n            # accurate source than SOURCES.txt as to the installed contents of\n            # the package.\n            \"installed-files.txt\": \"\"\"\n                PKG-INFO\n                SOURCES.txt\n                top_level.txt\n            \"\"\",\n            # top_level.txt correctly reflects that no modules are installed\n            \"top_level.txt\": b\"\\n\",\n        },\n    }\n\n\nclass EggInfoPkgSourcesFallback(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"sources_fallback_pkg.egg-info\": {\n            \"PKG-INFO\": \"Name: sources_fallback-pkg\",\n            # SOURCES.txt is made from the source archive, and contains files\n            # (setup.py) that are not present after installation.\n            \"SOURCES.txt\": \"\"\"\n                sources_fallback.py\n                setup.py\n                sources_fallback_pkg.egg-info/PKG-INFO\n                sources_fallback_pkg.egg-info/SOURCES.txt\n            \"\"\",\n            # missing installed-files.txt (i.e. not installed by pip) and\n            # missing top_level.txt (to trigger fallback to SOURCES.txt)\n        },\n        \"sources_fallback.py\": \"\"\"\n            def main():\n                print(\"hello world\")\n            \"\"\",\n    }\n\n\nclass EggInfoFile(OnSysPath, SiteBuilder):\n    files: FilesSpec = {\n        \"egginfo_file.egg-info\": \"\"\"\n            Metadata-Version: 1.0\n            Name: egginfo_file\n            Version: 0.1\n            Summary: An example package\n            Home-page: www.example.com\n            Author: Eric Haffa-Vee\n            Author-email: eric@example.coms\n            License: UNKNOWN\n            Description: UNKNOWN\n            Platform: UNKNOWN\n            \"\"\",\n    }\n\n\n# dedent all text strings before writing\norig = _path.create.registry[str]\n_path.create.register(str, lambda content, path: orig(DALS(content), path))\n\n\nbuild_files = _path.build\n\n\ndef build_record(file_defs):\n    return ''.join(f'{name},,\\n' for name in record_names(file_defs))\n\n\ndef record_names(file_defs):\n    recording = _path.Recording()\n    _path.build(file_defs, recording)\n    return recording.record\n\n\nclass FileBuilder:\n    def unicode_filename(self):\n        return os_helper.FS_NONASCII or self.skip(\n            \"File system does not support non-ascii.\"\n        )\n\n\ndef DALS(str):\n    \"Dedent and left-strip\"\n    return textwrap.dedent(str).lstrip()\n\n\nclass ZipFixtures:\n    root = 'tests.data'\n\n    def _fixture_on_path(self, filename):\n        pkg_file = resources.files(self.root).joinpath(filename)\n        file = self.resources.enter_context(resources.as_file(pkg_file))\n        assert file.name.startswith('example'), file.name\n        sys.path.insert(0, str(file))\n        self.resources.callback(sys.path.pop, 0)\n\n    def setUp(self):\n        # Add self.zip_name to the front of sys.path.\n        self.resources = contextlib.ExitStack()\n        self.addCleanup(self.resources.close)\n\n\ndef parameterize(*args_set):\n    \"\"\"Run test method with a series of parameters.\"\"\"\n\n    def wrapper(func):\n        @functools.wraps(func)\n        def _inner(self):\n            for args in args_set:\n                with self.subTest(**args):\n                    func(self, **args)\n\n        return _inner\n\n    return wrapper\n", "tests/_path.py": "# from jaraco.path 3.7\n\nimport functools\nimport pathlib\nfrom typing import Dict, Protocol, Union\nfrom typing import runtime_checkable\n\n\nclass Symlink(str):\n    \"\"\"\n    A string indicating the target of a symlink.\n    \"\"\"\n\n\nFilesSpec = Dict[str, Union[str, bytes, Symlink, 'FilesSpec']]  # type: ignore\n\n\n@runtime_checkable\nclass TreeMaker(Protocol):\n    def __truediv__(self, *args, **kwargs): ...  # pragma: no cover\n\n    def mkdir(self, **kwargs): ...  # pragma: no cover\n\n    def write_text(self, content, **kwargs): ...  # pragma: no cover\n\n    def write_bytes(self, content): ...  # pragma: no cover\n\n    def symlink_to(self, target): ...  # pragma: no cover\n\n\ndef _ensure_tree_maker(obj: Union[str, TreeMaker]) -> TreeMaker:\n    return obj if isinstance(obj, TreeMaker) else pathlib.Path(obj)  # type: ignore\n\n\ndef build(\n    spec: FilesSpec,\n    prefix: Union[str, TreeMaker] = pathlib.Path(),  # type: ignore\n):\n    \"\"\"\n    Build a set of files/directories, as described by the spec.\n\n    Each key represents a pathname, and the value represents\n    the content. Content may be a nested directory.\n\n    >>> spec = {\n    ...     'README.txt': \"A README file\",\n    ...     \"foo\": {\n    ...         \"__init__.py\": \"\",\n    ...         \"bar\": {\n    ...             \"__init__.py\": \"\",\n    ...         },\n    ...         \"baz.py\": \"# Some code\",\n    ...         \"bar.py\": Symlink(\"baz.py\"),\n    ...     },\n    ...     \"bing\": Symlink(\"foo\"),\n    ... }\n    >>> target = getfixture('tmp_path')\n    >>> build(spec, target)\n    >>> target.joinpath('foo/baz.py').read_text(encoding='utf-8')\n    '# Some code'\n    >>> target.joinpath('bing/bar.py').read_text(encoding='utf-8')\n    '# Some code'\n    \"\"\"\n    for name, contents in spec.items():\n        create(contents, _ensure_tree_maker(prefix) / name)\n\n\n@functools.singledispatch\ndef create(content: Union[str, bytes, FilesSpec], path):\n    path.mkdir(exist_ok=True)\n    build(content, prefix=path)  # type: ignore\n\n\n@create.register\ndef _(content: bytes, path):\n    path.write_bytes(content)\n\n\n@create.register\ndef _(content: str, path):\n    path.write_text(content, encoding='utf-8')\n\n\n@create.register\ndef _(content: Symlink, path):\n    path.symlink_to(content)\n\n\nclass Recording:\n    \"\"\"\n    A TreeMaker object that records everything that would be written.\n\n    >>> r = Recording()\n    >>> build({'foo': {'foo1.txt': 'yes'}, 'bar.txt': 'abc'}, r)\n    >>> r.record\n    ['foo/foo1.txt', 'bar.txt']\n    \"\"\"\n\n    def __init__(self, loc=pathlib.PurePosixPath(), record=None):\n        self.loc = loc\n        self.record = record if record is not None else []\n\n    def __truediv__(self, other):\n        return Recording(self.loc / other, self.record)\n\n    def write_text(self, content, **kwargs):\n        self.record.append(str(self.loc))\n\n    write_bytes = write_text\n\n    def mkdir(self, **kwargs):\n        return\n\n    def symlink_to(self, target):\n        pass\n", "tests/test_api.py": "import re\nimport textwrap\nimport unittest\nimport importlib\n\nfrom . import fixtures\nfrom importlib_metadata import (\n    Distribution,\n    PackageNotFoundError,\n    distribution,\n    entry_points,\n    files,\n    metadata,\n    requires,\n    version,\n)\n\n\nclass APITests(\n    fixtures.EggInfoPkg,\n    fixtures.EggInfoPkgPipInstalledNoToplevel,\n    fixtures.EggInfoPkgPipInstalledNoModules,\n    fixtures.EggInfoPkgPipInstalledExternalDataFiles,\n    fixtures.EggInfoPkgSourcesFallback,\n    fixtures.DistInfoPkg,\n    fixtures.DistInfoPkgWithDot,\n    fixtures.EggInfoFile,\n    unittest.TestCase,\n):\n    version_pattern = r'\\d+\\.\\d+(\\.\\d)?'\n\n    def test_retrieves_version_of_self(self):\n        pkg_version = version('egginfo-pkg')\n        assert isinstance(pkg_version, str)\n        assert re.match(self.version_pattern, pkg_version)\n\n    def test_retrieves_version_of_distinfo_pkg(self):\n        pkg_version = version('distinfo-pkg')\n        assert isinstance(pkg_version, str)\n        assert re.match(self.version_pattern, pkg_version)\n\n    def test_for_name_does_not_exist(self):\n        with self.assertRaises(PackageNotFoundError):\n            distribution('does-not-exist')\n\n    def test_name_normalization(self):\n        names = 'pkg.dot', 'pkg_dot', 'pkg-dot', 'pkg..dot', 'Pkg.Dot'\n        for name in names:\n            with self.subTest(name):\n                assert distribution(name).metadata['Name'] == 'pkg.dot'\n\n    def test_prefix_not_matched(self):\n        prefixes = 'p', 'pkg', 'pkg.'\n        for prefix in prefixes:\n            with self.subTest(prefix):\n                with self.assertRaises(PackageNotFoundError):\n                    distribution(prefix)\n\n    def test_for_top_level(self):\n        tests = [\n            ('egginfo-pkg', 'mod'),\n            ('egg_with_no_modules-pkg', ''),\n        ]\n        for pkg_name, expect_content in tests:\n            with self.subTest(pkg_name):\n                self.assertEqual(\n                    distribution(pkg_name).read_text('top_level.txt').strip(),\n                    expect_content,\n                )\n\n    def test_read_text(self):\n        tests = [\n            ('egginfo-pkg', 'mod\\n'),\n            ('egg_with_no_modules-pkg', '\\n'),\n        ]\n        for pkg_name, expect_content in tests:\n            with self.subTest(pkg_name):\n                top_level = [\n                    path for path in files(pkg_name) if path.name == 'top_level.txt'\n                ][0]\n                self.assertEqual(top_level.read_text(), expect_content)\n\n    def test_entry_points(self):\n        eps = entry_points()\n        assert 'entries' in eps.groups\n        entries = eps.select(group='entries')\n        assert 'main' in entries.names\n        ep = entries['main']\n        self.assertEqual(ep.value, 'mod:main')\n        self.assertEqual(ep.extras, [])\n\n    def test_entry_points_distribution(self):\n        entries = entry_points(group='entries')\n        for entry in (\"main\", \"ns:sub\"):\n            ep = entries[entry]\n            self.assertIn(ep.dist.name, ('distinfo-pkg', 'egginfo-pkg'))\n            self.assertEqual(ep.dist.version, \"1.0.0\")\n\n    def test_entry_points_unique_packages_normalized(self):\n        \"\"\"\n        Entry points should only be exposed for the first package\n        on sys.path with a given name (even when normalized).\n        \"\"\"\n        alt_site_dir = self.fixtures.enter_context(fixtures.tmp_path())\n        self.fixtures.enter_context(self.add_sys_path(alt_site_dir))\n        alt_pkg = {\n            \"DistInfo_pkg-1.1.0.dist-info\": {\n                \"METADATA\": \"\"\"\n                Name: distinfo-pkg\n                Version: 1.1.0\n                \"\"\",\n                \"entry_points.txt\": \"\"\"\n                [entries]\n                main = mod:altmain\n            \"\"\",\n            },\n        }\n        fixtures.build_files(alt_pkg, alt_site_dir)\n        entries = entry_points(group='entries')\n        assert not any(\n            ep.dist.name == 'distinfo-pkg' and ep.dist.version == '1.0.0'\n            for ep in entries\n        )\n        # ns:sub doesn't exist in alt_pkg\n        assert 'ns:sub' not in entries.names\n\n    def test_entry_points_missing_name(self):\n        with self.assertRaises(KeyError):\n            entry_points(group='entries')['missing']\n\n    def test_entry_points_missing_group(self):\n        assert entry_points(group='missing') == ()\n\n    def test_entry_points_allows_no_attributes(self):\n        ep = entry_points().select(group='entries', name='main')\n        with self.assertRaises(AttributeError):\n            ep.foo = 4\n\n    def test_metadata_for_this_package(self):\n        md = metadata('egginfo-pkg')\n        assert md['author'] == 'Steven Ma'\n        assert md['LICENSE'] == 'Unknown'\n        assert md['Name'] == 'egginfo-pkg'\n        classifiers = md.get_all('Classifier')\n        assert 'Topic :: Software Development :: Libraries' in classifiers\n\n    def test_importlib_metadata_version(self):\n        resolved = version('importlib-metadata')\n        assert re.match(self.version_pattern, resolved)\n\n    def test_missing_key(self):\n        \"\"\"\n        Requesting a missing key raises KeyError.\n        \"\"\"\n        md = metadata('distinfo-pkg')\n        with self.assertRaises(KeyError):\n            md['does-not-exist']\n\n    def test_get_key(self):\n        \"\"\"\n        Getting a key gets the key.\n        \"\"\"\n        md = metadata('egginfo-pkg')\n        assert md.get('Name') == 'egginfo-pkg'\n\n    def test_get_missing_key(self):\n        \"\"\"\n        Requesting a missing key will return None.\n        \"\"\"\n        md = metadata('distinfo-pkg')\n        assert md.get('does-not-exist') is None\n\n    @staticmethod\n    def _test_files(files):\n        root = files[0].root\n        for file in files:\n            assert file.root == root\n            assert not file.hash or file.hash.value\n            assert not file.hash or file.hash.mode == 'sha256'\n            assert not file.size or file.size >= 0\n            assert file.locate().exists()\n            assert isinstance(file.read_binary(), bytes)\n            if file.name.endswith('.py'):\n                file.read_text()\n\n    def test_file_hash_repr(self):\n        util = [p for p in files('distinfo-pkg') if p.name == 'mod.py'][0]\n        self.assertRegex(repr(util.hash), '<FileHash mode: sha256 value: .*>')\n\n    def test_files_dist_info(self):\n        self._test_files(files('distinfo-pkg'))\n\n    def test_files_egg_info(self):\n        self._test_files(files('egginfo-pkg'))\n        self._test_files(files('egg_with_module-pkg'))\n        self._test_files(files('egg_with_no_modules-pkg'))\n        self._test_files(files('sources_fallback-pkg'))\n\n    def test_version_egg_info_file(self):\n        self.assertEqual(version('egginfo-file'), '0.1')\n\n    def test_requires_egg_info_file(self):\n        requirements = requires('egginfo-file')\n        self.assertIsNone(requirements)\n\n    def test_requires_egg_info(self):\n        deps = requires('egginfo-pkg')\n        assert len(deps) == 2\n        assert any(dep == 'wheel >= 1.0; python_version >= \"2.7\"' for dep in deps)\n\n    def test_requires_egg_info_empty(self):\n        fixtures.build_files(\n            {\n                'requires.txt': '',\n            },\n            self.site_dir.joinpath('egginfo_pkg.egg-info'),\n        )\n        deps = requires('egginfo-pkg')\n        assert deps == []\n\n    def test_requires_dist_info(self):\n        deps = requires('distinfo-pkg')\n        assert len(deps) == 2\n        assert all(deps)\n        assert 'wheel >= 1.0' in deps\n        assert \"pytest; extra == 'test'\" in deps\n\n    def test_more_complex_deps_requires_text(self):\n        requires = textwrap.dedent(\n            \"\"\"\n            dep1\n            dep2\n\n            [:python_version < \"3\"]\n            dep3\n\n            [extra1]\n            dep4\n            dep6@ git+https://example.com/python/dep.git@v1.0.0\n\n            [extra2:python_version < \"3\"]\n            dep5\n            \"\"\"\n        )\n        deps = sorted(Distribution._deps_from_requires_text(requires))\n        expected = [\n            'dep1',\n            'dep2',\n            'dep3; python_version < \"3\"',\n            'dep4; extra == \"extra1\"',\n            'dep5; (python_version < \"3\") and extra == \"extra2\"',\n            'dep6@ git+https://example.com/python/dep.git@v1.0.0 ; extra == \"extra1\"',\n        ]\n        # It's important that the environment marker expression be\n        # wrapped in parentheses to avoid the following 'and' binding more\n        # tightly than some other part of the environment expression.\n\n        assert deps == expected\n\n    def test_as_json(self):\n        md = metadata('distinfo-pkg').json\n        assert 'name' in md\n        assert md['keywords'] == ['sample', 'package']\n        desc = md['description']\n        assert desc.startswith('Once upon a time\\nThere was')\n        assert len(md['requires_dist']) == 2\n\n    def test_as_json_egg_info(self):\n        md = metadata('egginfo-pkg').json\n        assert 'name' in md\n        assert md['keywords'] == ['sample', 'package']\n        desc = md['description']\n        assert desc.startswith('Once upon a time\\nThere was')\n        assert len(md['classifier']) == 2\n\n    def test_as_json_odd_case(self):\n        self.make_uppercase()\n        md = metadata('distinfo-pkg').json\n        assert 'name' in md\n        assert len(md['requires_dist']) == 2\n        assert md['keywords'] == ['SAMPLE', 'PACKAGE']\n\n\nclass LegacyDots(fixtures.DistInfoPkgWithDotLegacy, unittest.TestCase):\n    def test_name_normalization(self):\n        names = 'pkg.dot', 'pkg_dot', 'pkg-dot', 'pkg..dot', 'Pkg.Dot'\n        for name in names:\n            with self.subTest(name):\n                assert distribution(name).metadata['Name'] == 'pkg.dot'\n\n    def test_name_normalization_versionless_egg_info(self):\n        names = 'pkg.lot', 'pkg_lot', 'pkg-lot', 'pkg..lot', 'Pkg.Lot'\n        for name in names:\n            with self.subTest(name):\n                assert distribution(name).metadata['Name'] == 'pkg.lot'\n\n\nclass OffSysPathTests(fixtures.DistInfoPkgOffPath, unittest.TestCase):\n    def test_find_distributions_specified_path(self):\n        dists = Distribution.discover(path=[str(self.site_dir)])\n        assert any(dist.metadata['Name'] == 'distinfo-pkg' for dist in dists)\n\n    def test_distribution_at_pathlib(self):\n        \"\"\"Demonstrate how to load metadata direct from a directory.\"\"\"\n        dist_info_path = self.site_dir / 'distinfo_pkg-1.0.0.dist-info'\n        dist = Distribution.at(dist_info_path)\n        assert dist.version == '1.0.0'\n\n    def test_distribution_at_str(self):\n        dist_info_path = self.site_dir / 'distinfo_pkg-1.0.0.dist-info'\n        dist = Distribution.at(str(dist_info_path))\n        assert dist.version == '1.0.0'\n\n\nclass InvalidateCache(unittest.TestCase):\n    def test_invalidate_cache(self):\n        # No externally observable behavior, but ensures test coverage...\n        importlib.invalidate_caches()\n", "tests/test_main.py": "import re\nimport pickle\nimport unittest\nimport importlib\nimport importlib_metadata\nfrom .compat.py39 import os_helper\n\nimport pyfakefs.fake_filesystem_unittest as ffs\n\nfrom . import fixtures\nfrom ._path import Symlink\nfrom importlib_metadata import (\n    Distribution,\n    EntryPoint,\n    PackageNotFoundError,\n    _unique,\n    distributions,\n    entry_points,\n    metadata,\n    packages_distributions,\n    version,\n)\n\n\nclass BasicTests(fixtures.DistInfoPkg, unittest.TestCase):\n    version_pattern = r'\\d+\\.\\d+(\\.\\d)?'\n\n    def test_retrieves_version_of_self(self):\n        dist = Distribution.from_name('distinfo-pkg')\n        assert isinstance(dist.version, str)\n        assert re.match(self.version_pattern, dist.version)\n\n    def test_for_name_does_not_exist(self):\n        with self.assertRaises(PackageNotFoundError):\n            Distribution.from_name('does-not-exist')\n\n    def test_package_not_found_mentions_metadata(self):\n        \"\"\"\n        When a package is not found, that could indicate that the\n        package is not installed or that it is installed without\n        metadata. Ensure the exception mentions metadata to help\n        guide users toward the cause. See #124.\n        \"\"\"\n        with self.assertRaises(PackageNotFoundError) as ctx:\n            Distribution.from_name('does-not-exist')\n\n        assert \"metadata\" in str(ctx.exception)\n\n    def test_abc_enforced(self):\n        with self.assertRaises(TypeError):\n            type('DistributionSubclass', (Distribution,), {})()\n\n    @fixtures.parameterize(\n        dict(name=None),\n        dict(name=''),\n    )\n    def test_invalid_inputs_to_from_name(self, name):\n        with self.assertRaises(Exception):\n            Distribution.from_name(name)\n\n\nclass ImportTests(fixtures.DistInfoPkg, unittest.TestCase):\n    def test_import_nonexistent_module(self):\n        # Ensure that the MetadataPathFinder does not crash an import of a\n        # non-existent module.\n        with self.assertRaises(ImportError):\n            importlib.import_module('does_not_exist')\n\n    def test_resolve(self):\n        ep = entry_points(group='entries')['main']\n        self.assertEqual(ep.load().__name__, \"main\")\n\n    def test_entrypoint_with_colon_in_name(self):\n        ep = entry_points(group='entries')['ns:sub']\n        self.assertEqual(ep.value, 'mod:main')\n\n    def test_resolve_without_attr(self):\n        ep = EntryPoint(\n            name='ep',\n            value='importlib_metadata',\n            group='grp',\n        )\n        assert ep.load() is importlib_metadata\n\n\nclass NameNormalizationTests(fixtures.OnSysPath, fixtures.SiteDir, unittest.TestCase):\n    @staticmethod\n    def make_pkg(name):\n        \"\"\"\n        Create minimal metadata for a dist-info package with\n        the indicated name on the file system.\n        \"\"\"\n        return {\n            f'{name}.dist-info': {\n                'METADATA': 'VERSION: 1.0\\n',\n            },\n        }\n\n    def test_dashes_in_dist_name_found_as_underscores(self):\n        \"\"\"\n        For a package with a dash in the name, the dist-info metadata\n        uses underscores in the name. Ensure the metadata loads.\n        \"\"\"\n        fixtures.build_files(self.make_pkg('my_pkg'), self.site_dir)\n        assert version('my-pkg') == '1.0'\n\n    def test_dist_name_found_as_any_case(self):\n        \"\"\"\n        Ensure the metadata loads when queried with any case.\n        \"\"\"\n        pkg_name = 'CherryPy'\n        fixtures.build_files(self.make_pkg(pkg_name), self.site_dir)\n        assert version(pkg_name) == '1.0'\n        assert version(pkg_name.lower()) == '1.0'\n        assert version(pkg_name.upper()) == '1.0'\n\n    def test_unique_distributions(self):\n        \"\"\"\n        Two distributions varying only by non-normalized name on\n        the file system should resolve as the same.\n        \"\"\"\n        fixtures.build_files(self.make_pkg('abc'), self.site_dir)\n        before = list(_unique(distributions()))\n\n        alt_site_dir = self.fixtures.enter_context(fixtures.tmp_path())\n        self.fixtures.enter_context(self.add_sys_path(alt_site_dir))\n        fixtures.build_files(self.make_pkg('ABC'), alt_site_dir)\n        after = list(_unique(distributions()))\n\n        assert len(after) == len(before)\n\n\nclass NonASCIITests(fixtures.OnSysPath, fixtures.SiteDir, unittest.TestCase):\n    @staticmethod\n    def pkg_with_non_ascii_description(site_dir):\n        \"\"\"\n        Create minimal metadata for a package with non-ASCII in\n        the description.\n        \"\"\"\n        contents = {\n            'portend.dist-info': {\n                'METADATA': 'Description: p\u00f4r\u02c8tend',\n            },\n        }\n        fixtures.build_files(contents, site_dir)\n        return 'portend'\n\n    @staticmethod\n    def pkg_with_non_ascii_description_egg_info(site_dir):\n        \"\"\"\n        Create minimal metadata for an egg-info package with\n        non-ASCII in the description.\n        \"\"\"\n        contents = {\n            'portend.dist-info': {\n                'METADATA': \"\"\"\n                Name: portend\n\n                p\u00f4r\u02c8tend\"\"\",\n            },\n        }\n        fixtures.build_files(contents, site_dir)\n        return 'portend'\n\n    def test_metadata_loads(self):\n        pkg_name = self.pkg_with_non_ascii_description(self.site_dir)\n        meta = metadata(pkg_name)\n        assert meta['Description'] == 'p\u00f4r\u02c8tend'\n\n    def test_metadata_loads_egg_info(self):\n        pkg_name = self.pkg_with_non_ascii_description_egg_info(self.site_dir)\n        meta = metadata(pkg_name)\n        assert meta['Description'] == 'p\u00f4r\u02c8tend'\n\n\nclass DiscoveryTests(\n    fixtures.EggInfoPkg,\n    fixtures.EggInfoPkgPipInstalledNoToplevel,\n    fixtures.EggInfoPkgPipInstalledNoModules,\n    fixtures.EggInfoPkgSourcesFallback,\n    fixtures.DistInfoPkg,\n    unittest.TestCase,\n):\n    def test_package_discovery(self):\n        dists = list(distributions())\n        assert all(isinstance(dist, Distribution) for dist in dists)\n        assert any(dist.metadata['Name'] == 'egginfo-pkg' for dist in dists)\n        assert any(dist.metadata['Name'] == 'egg_with_module-pkg' for dist in dists)\n        assert any(dist.metadata['Name'] == 'egg_with_no_modules-pkg' for dist in dists)\n        assert any(dist.metadata['Name'] == 'sources_fallback-pkg' for dist in dists)\n        assert any(dist.metadata['Name'] == 'distinfo-pkg' for dist in dists)\n\n    def test_invalid_usage(self):\n        with self.assertRaises(ValueError):\n            list(distributions(context='something', name='else'))\n\n    def test_interleaved_discovery(self):\n        \"\"\"\n        Ensure interleaved searches are safe.\n\n        When the search is cached, it is possible for searches to be\n        interleaved, so make sure those use-cases are safe.\n\n        Ref #293\n        \"\"\"\n        dists = distributions()\n        next(dists)\n        version('egginfo-pkg')\n        next(dists)\n\n\nclass DirectoryTest(fixtures.OnSysPath, fixtures.SiteDir, unittest.TestCase):\n    def test_egg_info(self):\n        # make an `EGG-INFO` directory that's unrelated\n        self.site_dir.joinpath('EGG-INFO').mkdir()\n        # used to crash with `IsADirectoryError`\n        with self.assertRaises(PackageNotFoundError):\n            version('unknown-package')\n\n    def test_egg(self):\n        egg = self.site_dir.joinpath('foo-3.6.egg')\n        egg.mkdir()\n        with self.add_sys_path(egg):\n            with self.assertRaises(PackageNotFoundError):\n                version('foo')\n\n\nclass MissingSysPath(fixtures.OnSysPath, unittest.TestCase):\n    site_dir = '/does-not-exist'\n\n    def test_discovery(self):\n        \"\"\"\n        Discovering distributions should succeed even if\n        there is an invalid path on sys.path.\n        \"\"\"\n        importlib_metadata.distributions()\n\n\nclass InaccessibleSysPath(fixtures.OnSysPath, ffs.TestCase):\n    site_dir = '/access-denied'\n\n    def setUp(self):\n        super().setUp()\n        self.setUpPyfakefs()\n        self.fs.create_dir(self.site_dir, perm_bits=000)\n\n    def test_discovery(self):\n        \"\"\"\n        Discovering distributions should succeed even if\n        there is an invalid path on sys.path.\n        \"\"\"\n        list(importlib_metadata.distributions())\n\n\nclass TestEntryPoints(unittest.TestCase):\n    def __init__(self, *args):\n        super().__init__(*args)\n        self.ep = importlib_metadata.EntryPoint(\n            name='name', value='value', group='group'\n        )\n\n    def test_entry_point_pickleable(self):\n        revived = pickle.loads(pickle.dumps(self.ep))\n        assert revived == self.ep\n\n    def test_positional_args(self):\n        \"\"\"\n        Capture legacy (namedtuple) construction, discouraged.\n        \"\"\"\n        EntryPoint('name', 'value', 'group')\n\n    def test_immutable(self):\n        \"\"\"EntryPoints should be immutable\"\"\"\n        with self.assertRaises(AttributeError):\n            self.ep.name = 'badactor'\n\n    def test_repr(self):\n        assert 'EntryPoint' in repr(self.ep)\n        assert 'name=' in repr(self.ep)\n        assert \"'name'\" in repr(self.ep)\n\n    def test_hashable(self):\n        \"\"\"EntryPoints should be hashable\"\"\"\n        hash(self.ep)\n\n    def test_module(self):\n        assert self.ep.module == 'value'\n\n    def test_attr(self):\n        assert self.ep.attr is None\n\n    def test_sortable(self):\n        \"\"\"\n        EntryPoint objects are sortable, but result is undefined.\n        \"\"\"\n        sorted([\n            EntryPoint(name='b', value='val', group='group'),\n            EntryPoint(name='a', value='val', group='group'),\n        ])\n\n\nclass FileSystem(\n    fixtures.OnSysPath, fixtures.SiteDir, fixtures.FileBuilder, unittest.TestCase\n):\n    def test_unicode_dir_on_sys_path(self):\n        \"\"\"\n        Ensure a Unicode subdirectory of a directory on sys.path\n        does not crash.\n        \"\"\"\n        fixtures.build_files(\n            {self.unicode_filename(): {}},\n            prefix=self.site_dir,\n        )\n        list(distributions())\n\n\nclass PackagesDistributionsPrebuiltTest(fixtures.ZipFixtures, unittest.TestCase):\n    def test_packages_distributions_example(self):\n        self._fixture_on_path('example-21.12-py3-none-any.whl')\n        assert packages_distributions()['example'] == ['example']\n\n    def test_packages_distributions_example2(self):\n        \"\"\"\n        Test packages_distributions on a wheel built\n        by trampolim.\n        \"\"\"\n        self._fixture_on_path('example2-1.0.0-py3-none-any.whl')\n        assert packages_distributions()['example2'] == ['example2']\n\n\nclass PackagesDistributionsTest(\n    fixtures.OnSysPath, fixtures.SiteDir, unittest.TestCase\n):\n    def test_packages_distributions_neither_toplevel_nor_files(self):\n        \"\"\"\n        Test a package built without 'top-level.txt' or a file list.\n        \"\"\"\n        fixtures.build_files(\n            {\n                'trim_example-1.0.0.dist-info': {\n                    'METADATA': \"\"\"\n                Name: trim_example\n                Version: 1.0.0\n                \"\"\",\n                }\n            },\n            prefix=self.site_dir,\n        )\n        packages_distributions()\n\n    def test_packages_distributions_all_module_types(self):\n        \"\"\"\n        Test top-level modules detected on a package without 'top-level.txt'.\n        \"\"\"\n        suffixes = importlib.machinery.all_suffixes()\n        metadata = dict(\n            METADATA=\"\"\"\n                Name: all_distributions\n                Version: 1.0.0\n                \"\"\",\n        )\n        files = {\n            'all_distributions-1.0.0.dist-info': metadata,\n        }\n        for i, suffix in enumerate(suffixes):\n            files.update({\n                f'importable-name {i}{suffix}': '',\n                f'in_namespace_{i}': {\n                    f'mod{suffix}': '',\n                },\n                f'in_package_{i}': {\n                    '__init__.py': '',\n                    f'mod{suffix}': '',\n                },\n            })\n        metadata.update(RECORD=fixtures.build_record(files))\n        fixtures.build_files(files, prefix=self.site_dir)\n\n        distributions = packages_distributions()\n\n        for i in range(len(suffixes)):\n            assert distributions[f'importable-name {i}'] == ['all_distributions']\n            assert distributions[f'in_namespace_{i}'] == ['all_distributions']\n            assert distributions[f'in_package_{i}'] == ['all_distributions']\n\n        assert not any(name.endswith('.dist-info') for name in distributions)\n\n    @os_helper.skip_unless_symlink\n    def test_packages_distributions_symlinked_top_level(self) -> None:\n        \"\"\"\n        Distribution is resolvable from a simple top-level symlink in RECORD.\n        See #452.\n        \"\"\"\n\n        files: fixtures.FilesSpec = {\n            \"symlinked_pkg-1.0.0.dist-info\": {\n                \"METADATA\": \"\"\"\n                    Name: symlinked-pkg\n                    Version: 1.0.0\n                    \"\"\",\n                \"RECORD\": \"symlinked,,\\n\",\n            },\n            \".symlink.target\": {},\n            \"symlinked\": Symlink(\".symlink.target\"),\n        }\n\n        fixtures.build_files(files, self.site_dir)\n        assert packages_distributions()['symlinked'] == ['symlinked-pkg']\n\n\nclass PackagesDistributionsEggTest(\n    fixtures.EggInfoPkg,\n    fixtures.EggInfoPkgPipInstalledNoToplevel,\n    fixtures.EggInfoPkgPipInstalledNoModules,\n    fixtures.EggInfoPkgSourcesFallback,\n    unittest.TestCase,\n):\n    def test_packages_distributions_on_eggs(self):\n        \"\"\"\n        Test old-style egg packages with a variation of 'top_level.txt',\n        'SOURCES.txt', and 'installed-files.txt', available.\n        \"\"\"\n        distributions = packages_distributions()\n\n        def import_names_from_package(package_name):\n            return {\n                import_name\n                for import_name, package_names in distributions.items()\n                if package_name in package_names\n            }\n\n        # egginfo-pkg declares one import ('mod') via top_level.txt\n        assert import_names_from_package('egginfo-pkg') == {'mod'}\n\n        # egg_with_module-pkg has one import ('egg_with_module') inferred from\n        # installed-files.txt (top_level.txt is missing)\n        assert import_names_from_package('egg_with_module-pkg') == {'egg_with_module'}\n\n        # egg_with_no_modules-pkg should not be associated with any import names\n        # (top_level.txt is empty, and installed-files.txt has no .py files)\n        assert import_names_from_package('egg_with_no_modules-pkg') == set()\n\n        # sources_fallback-pkg has one import ('sources_fallback') inferred from\n        # SOURCES.txt (top_level.txt and installed-files.txt is missing)\n        assert import_names_from_package('sources_fallback-pkg') == {'sources_fallback'}\n\n\nclass EditableDistributionTest(fixtures.DistInfoPkgEditable, unittest.TestCase):\n    def test_origin(self):\n        dist = Distribution.from_name('distinfo-pkg')\n        assert dist.origin.url.endswith('.whl')\n        assert dist.origin.archive_info.hashes.sha256\n", "tests/__init__.py": "", "tests/compat/py312.py": "import contextlib\n\nfrom .py39 import import_helper\n\n\n@contextlib.contextmanager\ndef isolated_modules():\n    \"\"\"\n    Save modules on entry and cleanup on exit.\n    \"\"\"\n    (saved,) = import_helper.modules_setup()\n    try:\n        yield\n    finally:\n        import_helper.modules_cleanup(saved)\n\n\nvars(import_helper).setdefault('isolated_modules', isolated_modules)\n", "tests/compat/py39.py": "from jaraco.test.cpython import from_test_support, try_import\n\n\nos_helper = try_import('os_helper') or from_test_support(\n    'FS_NONASCII', 'skip_unless_symlink', 'temp_dir'\n)\nimport_helper = try_import('import_helper') or from_test_support(\n    'modules_setup', 'modules_cleanup'\n)\n", "tests/compat/__init__.py": "", "tests/compat/test_py39_compat.py": "import sys\nimport pathlib\nimport unittest\n\nfrom .. import fixtures\nfrom importlib_metadata import (\n    distribution,\n    distributions,\n    entry_points,\n    metadata,\n    version,\n)\n\n\nclass OldStdlibFinderTests(fixtures.DistInfoPkgOffPath, unittest.TestCase):\n    def setUp(self):\n        if sys.version_info >= (3, 10):\n            self.skipTest(\"Tests specific for Python 3.8/3.9\")\n        super().setUp()\n\n    def _meta_path_finder(self):\n        from importlib.metadata import (\n            Distribution,\n            DistributionFinder,\n            PathDistribution,\n        )\n        from importlib.util import spec_from_file_location\n\n        path = pathlib.Path(self.site_dir)\n\n        class CustomDistribution(Distribution):\n            def __init__(self, name, path):\n                self.name = name\n                self._path_distribution = PathDistribution(path)\n\n            def read_text(self, filename):\n                return self._path_distribution.read_text(filename)\n\n            def locate_file(self, path):\n                return self._path_distribution.locate_file(path)\n\n        class CustomFinder:\n            @classmethod\n            def find_spec(cls, fullname, _path=None, _target=None):\n                candidate = pathlib.Path(path, *fullname.split(\".\")).with_suffix(\".py\")\n                if candidate.exists():\n                    return spec_from_file_location(fullname, candidate)\n\n            @classmethod\n            def find_distributions(self, context=DistributionFinder.Context()):\n                for dist_info in path.glob(\"*.dist-info\"):\n                    yield PathDistribution(dist_info)\n                    name, _, _ = str(dist_info).partition(\"-\")\n                    yield CustomDistribution(name + \"_custom\", dist_info)\n\n        return CustomFinder\n\n    def test_compatibility_with_old_stdlib_path_distribution(self):\n        \"\"\"\n        Given a custom finder that uses Python 3.8/3.9 importlib.metadata is installed,\n        when importlib_metadata functions are called, there should be no exceptions.\n        Ref python/importlib_metadata#396.\n        \"\"\"\n        self.fixtures.enter_context(fixtures.install_finder(self._meta_path_finder()))\n\n        assert list(distributions())\n        assert distribution(\"distinfo_pkg\")\n        assert distribution(\"distinfo_pkg_custom\")\n        assert version(\"distinfo_pkg\") > \"0\"\n        assert version(\"distinfo_pkg_custom\") > \"0\"\n        assert list(metadata(\"distinfo_pkg\"))\n        assert list(metadata(\"distinfo_pkg_custom\"))\n        assert list(entry_points(group=\"entries\"))\n", "tests/data/__init__.py": "", "tests/data/sources/example2/example2/__init__.py": "def main():\n    return \"example\"\n", "tests/data/sources/example/setup.py": "from setuptools import setup\n\nsetup(\n    name='example',\n    version='21.12',\n    license='Apache Software License',\n    packages=['example'],\n    entry_points={\n        'console_scripts': ['example = example:main', 'Example=example:main'],\n    },\n)\n", "tests/data/sources/example/example/__init__.py": "def main():\n    return 'example'\n"}