{"noxfile.py": "# Copyright 2019 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport os\nimport pathlib\nimport shutil\n\nimport nox\n\nCURRENT_DIRECTORY = pathlib.Path(__file__).parent.absolute()\n\n# https://github.com/psf/black/issues/2964, pin click version to 8.0.4 to\n# avoid incompatiblity with black.\nCLICK_VERSION = \"click==8.0.4\"\nBLACK_VERSION = \"black==19.3b0\"\nBLACK_PATHS = [\n    \"google\",\n    \"tests\",\n    \"tests_async\",\n    \"noxfile.py\",\n    \"setup.py\",\n    \"docs/conf.py\",\n]\n\n\n@nox.session(python=\"3.8\")\ndef lint(session):\n    session.install(\n        \"flake8\", \"flake8-import-order\", \"docutils\", CLICK_VERSION, BLACK_VERSION\n    )\n    session.install(\"-e\", \".\")\n    session.run(\"black\", \"--check\", *BLACK_PATHS)\n    session.run(\n        \"flake8\",\n        \"--import-order-style=google\",\n        \"--application-import-names=google,tests,system_tests\",\n        \"google\",\n        \"tests\",\n        \"tests_async\",\n    )\n    session.run(\n        \"python\", \"setup.py\", \"check\", \"--metadata\", \"--restructuredtext\", \"--strict\"\n    )\n\n\n@nox.session(python=\"3.8\")\ndef blacken(session):\n    \"\"\"Run black.\n    Format code to uniform standard.\n    The Python version should be consistent with what is\n    supplied in the Python Owlbot postprocessor.\n\n    https://github.com/googleapis/synthtool/blob/master/docker/owlbot/python/Dockerfile\n    \"\"\"\n    session.install(CLICK_VERSION, BLACK_VERSION)\n    session.run(\"black\", *BLACK_PATHS)\n\n\n@nox.session(python=\"3.8\")\ndef mypy(session):\n    \"\"\"Verify type hints are mypy compatible.\"\"\"\n    session.install(\"-e\", \".\")\n    session.install(\n        \"mypy\",\n        \"types-cachetools\",\n        \"types-certifi\",\n        \"types-freezegun\",\n        \"types-pyOpenSSL\",\n        \"types-requests\",\n        \"types-setuptools\",\n        \"types-mock\",\n    )\n    session.run(\"mypy\", \"-p\", \"google\", \"-p\", \"tests\", \"-p\", \"tests_async\")\n\n\n@nox.session(python=[\"3.7\", \"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"])\ndef unit(session):\n    constraints_path = str(\n        CURRENT_DIRECTORY / \"testing\" / f\"constraints-{session.python}.txt\"\n    )\n    session.install(\"-r\", \"testing/requirements.txt\", \"-c\", constraints_path)\n    session.install(\"-e\", \".\", \"-c\", constraints_path)\n    session.run(\n        \"pytest\",\n        f\"--junitxml=unit_{session.python}_sponge_log.xml\",\n        \"--cov=google.auth\",\n        \"--cov=google.oauth2\",\n        \"--cov=tests\",\n        \"--cov-report=term-missing\",\n        \"tests\",\n        \"tests_async\",\n    )\n\n\n@nox.session(python=\"3.8\")\ndef cover(session):\n    session.install(\"-r\", \"testing/requirements.txt\")\n    session.install(\"-e\", \".\")\n    session.run(\n        \"pytest\",\n        \"--cov=google.auth\",\n        \"--cov=google.oauth2\",\n        \"--cov=tests\",\n        \"--cov=tests_async\",\n        \"--cov-report=term-missing\",\n        \"tests\",\n        \"tests_async\",\n    )\n    session.run(\"coverage\", \"report\", \"--show-missing\", \"--fail-under=100\")\n\n\n@nox.session(python=\"3.9\")\ndef docs(session):\n    \"\"\"Build the docs for this library.\"\"\"\n\n    session.install(\"-e\", \".[aiohttp]\")\n    session.install(\"sphinx\", \"alabaster\", \"recommonmark\", \"sphinx-docstring-typing\")\n\n    shutil.rmtree(os.path.join(\"docs\", \"_build\"), ignore_errors=True)\n    session.run(\n        \"sphinx-build\",\n        \"-T\",  # show full traceback on exception\n        \"-W\",  # warnings as errors\n        \"-N\",  # no colors\n        \"-b\",\n        \"html\",\n        \"-d\",\n        os.path.join(\"docs\", \"_build\", \"doctrees\", \"\"),\n        os.path.join(\"docs\", \"\"),\n        os.path.join(\"docs\", \"_build\", \"html\", \"\"),\n    )\n\n\n@nox.session(python=\"pypy\")\ndef pypy(session):\n    session.install(\"-r\", \"testing/requirements.txt\")\n    session.install(\"-e\", \".\")\n    session.run(\n        \"pytest\",\n        f\"--junitxml=unit_{session.python}_sponge_log.xml\",\n        \"--cov=google.auth\",\n        \"--cov=google.oauth2\",\n        \"--cov=tests\",\n        \"tests\",\n        \"tests_async\",\n    )\n", "setup.py": "# Copyright 2014 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport io\nimport os\n\nfrom setuptools import find_namespace_packages\nfrom setuptools import setup\n\n\nDEPENDENCIES = (\n    \"cachetools>=2.0.0,<6.0\",\n    \"pyasn1-modules>=0.2.1\",\n    # rsa==4.5 is the last version to support 2.7\n    # https://github.com/sybrenstuvel/python-rsa/issues/152#issuecomment-643470233\n    \"rsa>=3.1.4,<5\",\n)\n\nextras = {\n    \"aiohttp\": [\"aiohttp >= 3.6.2, < 4.0.0.dev0\", \"requests >= 2.20.0, < 3.0.0.dev0\"],\n    \"pyopenssl\": [\"pyopenssl>=20.0.0\", \"cryptography>=38.0.3\"],\n    \"requests\": \"requests >= 2.20.0, < 3.0.0.dev0\",\n    \"reauth\": \"pyu2f>=0.1.5\",\n    # Enterprise cert only works for OpenSSL 1.1.1. Newer versions of these\n    # dependencies are built with OpenSSL 3.0 so we need to fix the version.\n    \"enterprise_cert\": [\"cryptography==36.0.2\", \"pyopenssl==22.0.0\"],\n}\n\nwith io.open(\"README.rst\", \"r\") as fh:\n    long_description = fh.read()\n\npackage_root = os.path.abspath(os.path.dirname(__file__))\n\nversion = {}\nwith open(os.path.join(package_root, \"google/auth/version.py\")) as fp:\n    exec(fp.read(), version)\nversion = version[\"__version__\"]\n\nsetup(\n    name=\"google-auth\",\n    version=version,\n    author=\"Google Cloud Platform\",\n    author_email=\"googleapis-packages@google.com\",\n    description=\"Google Authentication Library\",\n    long_description=long_description,\n    url=\"https://github.com/googleapis/google-auth-library-python\",\n    packages=find_namespace_packages(\n        exclude=(\"tests*\", \"system_tests*\", \"docs*\", \"samples*\")\n    ),\n    install_requires=DEPENDENCIES,\n    extras_require=extras,\n    python_requires=\">=3.7\",\n    license=\"Apache 2.0\",\n    keywords=\"google auth oauth client\",\n    classifiers=[\n        \"Programming Language :: Python :: 3\",\n        \"Programming Language :: Python :: 3.7\",\n        \"Programming Language :: Python :: 3.8\",\n        \"Programming Language :: Python :: 3.9\",\n        \"Programming Language :: Python :: 3.10\",\n        \"Programming Language :: Python :: 3.11\",\n        \"Programming Language :: Python :: 3.12\",\n        \"Development Status :: 5 - Production/Stable\",\n        \"Intended Audience :: Developers\",\n        \"License :: OSI Approved :: Apache Software License\",\n        \"Operating System :: POSIX\",\n        \"Operating System :: Microsoft :: Windows\",\n        \"Operating System :: MacOS :: MacOS X\",\n        \"Operating System :: OS Independent\",\n        \"Topic :: Internet :: WWW/HTTP\",\n    ],\n)\n", "owlbot.py": "import synthtool as s\nfrom synthtool import gcp\n\ncommon = gcp.CommonTemplates()\n\n# ----------------------------------------------------------------------------\n# Add templated files\n# ----------------------------------------------------------------------------\ntemplated_files = common.py_library(unit_cov_level=100, cov_level=100)\n\n\ns.move(\n    templated_files / \".kokoro\",\n    excludes=[\n        \"continuous/common.cfg\",\n        \"presubmit/common.cfg\",\n        \"build.sh\",\n        \"samples/*\",\n    ],\n)  # just move kokoro configs\ns.move(\n    # needed by samples kokoro jobs\n    templated_files / \".trampolinerc\"\n)\ns.move(\n    templated_files / \"renovate.json\",\n)\n\n\nassert 1 == s.replace(\n    \".kokoro/docs/docs-presubmit.cfg\",\n    'value: \"docs docfx\"',\n    'value: \"docs\"',\n)\n\ns.shell.run([\"nox\", \"-s\", \"blacken\"], hide_output=False)\n", "samples/cloud-client/snippets/authenticate_implicit_with_adc.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_implicit_adc]\n\nfrom google.cloud import storage\n\n\ndef authenticate_implicit_with_adc(project_id=\"your-google-cloud-project-id\"):\n    \"\"\"\n    When interacting with Google Cloud Client libraries, the library can auto-detect the\n    credentials to use.\n\n    // TODO(Developer):\n    //  1. Before running this sample,\n    //  set up ADC as described in https://cloud.google.com/docs/authentication/external/set-up-adc\n    //  2. Replace the project variable.\n    //  3. Make sure that the user account or service account that you are using\n    //  has the required permissions. For this sample, you must have \"storage.buckets.list\".\n    Args:\n        project_id: The project id of your Google Cloud project.\n    \"\"\"\n\n    # This snippet demonstrates how to list buckets.\n    # *NOTE*: Replace the client created below with the client required for your application.\n    # Note that the credentials are not specified when constructing the client.\n    # Hence, the client library will look for credentials using ADC.\n    storage_client = storage.Client(project=project_id)\n    buckets = storage_client.list_buckets()\n    print(\"Buckets:\")\n    for bucket in buckets:\n        print(bucket.name)\n    print(\"Listed all storage buckets.\")\n\n# [END auth_cloud_implicit_adc]\n", "samples/cloud-client/snippets/idtoken_from_impersonated_credentials.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [auth_cloud_idtoken_impersonated_credentials]\n\nimport google\nfrom google.auth import impersonated_credentials\nimport google.auth.transport.requests\n\n\ndef idtoken_from_impersonated_credentials(\n        impersonated_service_account: str, scope: str, target_audience: str):\n    \"\"\"\n      Use a service account (SA1) to impersonate as another service account (SA2) and obtain id token\n      for the impersonated account.\n      To obtain token for SA2, SA1 should have the \"roles/iam.serviceAccountTokenCreator\" permission\n      on SA2.\n\n    Args:\n        impersonated_service_account: The name of the privilege-bearing service account for whom the credential is created.\n            Examples: name@project.service.gserviceaccount.com\n\n        scope: Provide the scopes that you might need to request to access Google APIs,\n            depending on the level of access you need.\n            For this example, we use the cloud-wide scope and use IAM to narrow the permissions.\n            https://cloud.google.com/docs/authentication#authorization_for_services\n            For more information, see: https://developers.google.com/identity/protocols/oauth2/scopes\n\n        target_audience: The service name for which the id token is requested. Service name refers to the\n            logical identifier of an API service, such as \"iap.googleapis.com\".\n            Examples: iap.googleapis.com\n    \"\"\"\n\n    # Construct the GoogleCredentials object which obtains the default configuration from your\n    # working environment.\n    credentials, project_id = google.auth.default()\n\n    # Create the impersonated credential.\n    target_credentials = impersonated_credentials.Credentials(\n        source_credentials=credentials,\n        target_principal=impersonated_service_account,\n        # delegates: The chained list of delegates required to grant the final accessToken.\n        # For more information, see:\n        # https://cloud.google.com/iam/docs/create-short-lived-credentials-direct#sa-credentials-permissions\n        # Delegate is NOT USED here.\n        delegates=[],\n        target_scopes=[scope],\n        lifetime=300)\n\n    # Set the impersonated credential, target audience and token options.\n    id_creds = impersonated_credentials.IDTokenCredentials(\n        target_credentials,\n        target_audience=target_audience,\n        include_email=True)\n\n    # Get the ID token.\n    # Once you've obtained the ID token, use it to make an authenticated call\n    # to the target audience.\n    request = google.auth.transport.requests.Request()\n    id_creds.refresh(request)\n    # token = id_creds.token\n    print(\"Generated ID token.\")\n\n# [auth_cloud_idtoken_impersonated_credentials]\n", "samples/cloud-client/snippets/noxfile.py": "# Copyright 2019 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport pathlib\n\nimport nox\n\nCURRENT_DIRECTORY = pathlib.Path(__file__).parent.absolute()\n\n# https://github.com/psf/black/issues/2964, pin click version to 8.0.4 to\n# avoid incompatiblity with black.\nCLICK_VERSION = \"click==8.0.4\"\nBLACK_VERSION = \"black==19.3b0\"\nBLACK_PATHS = [\n    \"google\",\n    \"tests\",\n    \"tests_async\",\n    \"noxfile.py\",\n    \"setup.py\",\n    \"docs/conf.py\",\n]\n\n\n# Error if a python version is missing\nnox.options.error_on_missing_interpreters = True\n\n#\n# Style Checks\n#\n\n\n# Linting with flake8.\n#\n# We ignore the following rules:\n#   E203: whitespace before \u2018:\u2019\n#   E266: too many leading \u2018#\u2019 for block comment\n#   E501: line too long\n#   I202: Additional newline in a section of imports\n#\n# We also need to specify the rules which are ignored by default:\n# ['E226', 'W504', 'E126', 'E123', 'W503', 'E24', 'E704', 'E121']\nFLAKE8_COMMON_ARGS = [\n    \"--show-source\",\n    \"--builtin=gettext\",\n    \"--max-complexity=20\",\n    \"--exclude=.nox,.cache,env,lib,generated_pb2,*_pb2.py,*_pb2_grpc.py\",\n    \"--ignore=E121,E123,E126,E203,E226,E24,E266,E501,E704,W503,W504,I202\",\n    \"--max-line-length=88\",\n]\n\n\n@nox.session(python=[\"3.7\", \"3.8\", \"3.9\", \"3.10\", \"3.11\", \"3.12\"])\ndef unit(session):\n    # constraints_path = str(\n    #     CURRENT_DIRECTORY / \"testing\" / f\"constraints-{session.python}.txt\"\n    # )\n    session.install(\"-r\", \"requirements.txt\")\n    # session.install(\"-e\", \".\")\n    session.run(\n        \"pytest\",\n        f\"--junitxml=unit_{session.python}_sponge_log.xml\",\n        \"snippets_test.py\",\n        # \"tests_async\",\n    )\n\n\n@nox.session\ndef lint(session: nox.sessions.Session) -> None:\n    session.install(\"flake8\")\n\n    args = FLAKE8_COMMON_ARGS + [\n        \".\",\n    ]\n    session.run(\"flake8\", *args)\n", "samples/cloud-client/snippets/noxfile_config.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# Default TEST_CONFIG_OVERRIDE for python repos.\n\n# You can copy this file into your directory, then it will be inported from\n# the noxfile.py.\n\n# The source of truth:\n# https://github.com/GoogleCloudPlatform/python-docs-samples/blob/master/noxfile_config.py\n\nTEST_CONFIG_OVERRIDE = {\n    # You can opt out from the test for specific Python versions.\n    \"ignored_versions\": [\"2.7\"],\n    # Old samples are opted out of enforcing Python type hints\n    # All new samples should feature them\n    \"enforce_type_hints\": True,\n    # An envvar key for determining the project id to use. Change it\n    # to 'BUILD_SPECIFIC_GCLOUD_PROJECT' if you want to opt in using a\n    # build specific Cloud project. You can also use your own string\n    # to use your own Cloud project.\n    # \"gcloud_project_env\": \"GOOGLE_CLOUD_PROJECT\",\n    \"gcloud_project_env\": \"GOOGLE_CLOUD_PROJECT\",\n    # A dictionary you want to inject into your test. Don't put any\n    # secrets here. These values will override predefined values.\n    \"envs\": {},\n}\n", "samples/cloud-client/snippets/idtoken_from_service_account.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_idtoken_service_account]\n\nimport google.auth\nimport google.auth.transport.requests\n\nfrom google.oauth2 import service_account\n\n\ndef get_idToken_from_serviceaccount(json_credential_path: str, target_audience: str):\n    \"\"\"\n    TODO(Developer): Replace the below variables before running the code.\n\n    *NOTE*:\n    Using service account keys introduces risk; they are long-lived, and can be used by anyone\n    that obtains the key. Proper rotation and storage reduce this risk but do not eliminate it.\n    For these reasons, you should consider an alternative approach that\n    does not use a service account key. Several alternatives to service account keys\n    are described here:\n    https://cloud.google.com/docs/authentication/external/set-up-adc\n\n    Args:\n        json_credential_path: Path to the service account json credential file.\n        target_audience: The url or target audience to obtain the ID token for.\n                        Examples: http://www.abc.com\n    \"\"\"\n\n    # Obtain the id token by providing the json file path and target audience.\n    credentials = service_account.IDTokenCredentials.from_service_account_file(\n        filename=json_credential_path,\n        target_audience=target_audience)\n\n    request = google.auth.transport.requests.Request()\n    credentials.refresh(request)\n    print(\"Generated ID token.\")\n\n# [END auth_cloud_idtoken_service_account]\n", "samples/cloud-client/snippets/authenticate_explicit_with_adc.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_explicit_adc]\n\nfrom google.cloud import storage\n\nimport google.oauth2.credentials\nimport google.auth\n\n\ndef authenticate_explicit_with_adc():\n    \"\"\"\n    List storage buckets by authenticating with ADC.\n\n    // TODO(Developer):\n    //  1. Before running this sample,\n    //  set up ADC as described in https://cloud.google.com/docs/authentication/external/set-up-adc\n    //  2. Replace the project variable.\n    //  3. Make sure you have the necessary permission to list storage buckets: \"storage.buckets.list\"\n    \"\"\"\n\n    # Construct the Google credentials object which obtains the default configuration from your\n    # working environment.\n    # google.auth.default() will give you ComputeEngineCredentials\n    # if you are on a GCE (or other metadata server supported environments).\n    credentials, project_id = google.auth.default()\n    # If you are authenticating to a Cloud API, you can let the library include the default scope,\n    # https://www.googleapis.com/auth/cloud-platform, because IAM is used to provide fine-grained\n    # permissions for Cloud.\n    # If you need to provide a scope, specify it as follows:\n    # credentials = google.auth.default(scopes=scope)\n    # For more information on scopes to use,\n    # see: https://developers.google.com/identity/protocols/oauth2/scopes\n\n    # Construct the Storage client.\n    storage_client = storage.Client(credentials=credentials, project=project_id)\n    buckets = storage_client.list_buckets()\n    print(\"Buckets:\")\n    for bucket in buckets:\n        print(bucket.name)\n    print(\"Listed all storage buckets.\")\n\n# [END auth_cloud_explicit_adc]\n", "samples/cloud-client/snippets/verify_google_idtoken.py": "# Copyright 2022 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n# http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n# [START auth_cloud_verify_google_idtoken]\n\nimport google\nimport google.auth.transport.requests\nfrom google.oauth2 import id_token\n\n\ndef verify_google_idtoken(idtoken: str, audience=\"iap.googleapis.com\",\n                          jwk_url=\"https://www.googleapis.com/oauth2/v3/certs\"):\n    \"\"\"\n      Verifies the obtained Google id token. This is done at the receiving end of the OIDC endpoint.\n      The most common use case for verifying the ID token is when you are protecting\n      your own APIs with IAP. Google services already verify credentials as a platform,\n      so verifying ID tokens before making Google API calls is usually unnecessary.\n\n    Args:\n        idtoken: The Google ID token to verify.\n\n        audience: The service name for which the id token is requested. Service name refers to the\n            logical identifier of an API service, such as \"iap.googleapis.com\".\n\n        jwk_url: To verify id tokens, get the Json Web Key endpoint (jwk).\n            OpenID Connect allows the use of a \"Discovery document,\" a JSON document found at a\n            well-known location containing key-value pairs which provide details about the\n            OpenID Connect provider's configuration.\n            For more information on validating the jwt, see:\n            https://developers.google.com/identity/protocols/oauth2/openid-connect#validatinganidtoken\n\n            Here, we validate Google's token using Google's OpenID Connect service (jwkUrl).\n            For more information on jwk,see:\n            https://auth0.com/docs/secure/tokens/json-web-tokens/json-web-key-sets\n    \"\"\"\n\n    request = google.auth.transport.requests.Request()\n    # Set the parameters and verify the token.\n    # Setting \"certs_url\" is optional. When verifying a Google ID token, this is set by default.\n    result = id_token.verify_token(idtoken, request, audience, clock_skew_in_seconds=10)\n\n    # Verify that the token contains subject and email claims.\n    # Get the User id.\n    if not result[\"sub\"] is None:\n        print(f\"User id: {result['sub']}\")\n    # Optionally, if \"INCLUDE_EMAIL\" was set in the token options, check if the\n    # email was verified.\n    if result['email_verified'] == \"True\":\n        print(f\"Email verified {result['email']}\")\n\n# [END auth_cloud_verify_google_idtoken]\n", "google/oauth2/service_account.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0\n\nThis module implements the JWT Profile for OAuth 2.0 Authorization Grants\nas defined by `RFC 7523`_ with particular support for how this RFC is\nimplemented in Google's infrastructure. Google refers to these credentials\nas *Service Accounts*.\n\nService accounts are used for server-to-server communication, such as\ninteractions between a web application server and a Google service. The\nservice account belongs to your application instead of to an individual end\nuser. In contrast to other OAuth 2.0 profiles, no users are involved and your\napplication \"acts\" as the service account.\n\nTypically an application uses a service account when the application uses\nGoogle APIs to work with its own data rather than a user's data. For example,\nan application that uses Google Cloud Datastore for data persistence would use\na service account to authenticate its calls to the Google Cloud Datastore API.\nHowever, an application that needs to access a user's Drive documents would\nuse the normal OAuth 2.0 profile.\n\nAdditionally, Google Apps domain administrators can grant service accounts\n`domain-wide delegation`_ authority to access user data on behalf of users in\nthe domain.\n\nThis profile uses a JWT to acquire an OAuth 2.0 access token. The JWT is used\nin place of the usual authorization token returned during the standard\nOAuth 2.0 Authorization Code grant. The JWT is only used for this purpose, as\nthe acquired access token is used as the bearer token when making requests\nusing these credentials.\n\nThis profile differs from normal OAuth 2.0 profile because no user consent\nstep is required. The use of the private key allows this profile to assert\nidentity directly.\n\nThis profile also differs from the :mod:`google.auth.jwt` authentication\nbecause the JWT credentials use the JWT directly as the bearer token. This\nprofile instead only uses the JWT to obtain an OAuth 2.0 access token. The\nobtained OAuth 2.0 access token is used as the bearer token.\n\nDomain-wide delegation\n----------------------\n\nDomain-wide delegation allows a service account to access user data on\nbehalf of any user in a Google Apps domain without consent from the user.\nFor example, an application that uses the Google Calendar API to add events to\nthe calendars of all users in a Google Apps domain would use a service account\nto access the Google Calendar API on behalf of users.\n\nThe Google Apps administrator must explicitly authorize the service account to\ndo this. This authorization step is referred to as \"delegating domain-wide\nauthority\" to a service account.\n\nYou can use domain-wise delegation by creating a set of credentials with a\nspecific subject using :meth:`~Credentials.with_subject`.\n\n.. _RFC 7523: https://tools.ietf.org/html/rfc7523\n\"\"\"\n\nimport copy\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import _service_account_info\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import metrics\nfrom google.oauth2 import _client\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n_GOOGLE_OAUTH2_TOKEN_ENDPOINT = \"https://oauth2.googleapis.com/token\"\n\n\nclass Credentials(\n    credentials.Signing,\n    credentials.Scoped,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Service account credentials\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = service_account.Credentials.from_service_account_file(\n            'service-account.json')\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = service_account.Credentials.from_service_account_info(\n            service_account_info)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = service_account.Credentials.from_service_account_file(\n            'service-account.json',\n            scopes=['email'],\n            subject='user@example.com')\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    To add a quota project, use :meth:`with_quota_project`::\n\n        credentials = credentials.with_quota_project('myproject-123')\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        service_account_email,\n        token_uri,\n        scopes=None,\n        default_scopes=None,\n        subject=None,\n        project_id=None,\n        quota_project_id=None,\n        additional_claims=None,\n        always_use_jwt_access=False,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n        trust_boundary=None,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            service_account_email (str): The service account's email.\n            scopes (Sequence[str]): User-defined scopes to request during the\n                authorization grant.\n            default_scopes (Sequence[str]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            token_uri (str): The OAuth 2.0 Token URI.\n            subject (str): For domain-wide delegation, the email address of the\n                user to for which to request delegated access.\n            project_id  (str): Project ID associated with the service account\n                credential.\n            quota_project_id (Optional[str]): The project ID used for quota and\n                billing.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT assertion used in the authorization grant.\n            always_use_jwt_access (Optional[bool]): Whether self signed JWT should\n                be always used.\n            universe_domain (str): The universe domain. The default\n                universe domain is googleapis.com. For default value self\n                signed jwt is used for token refresh.\n            trust_boundary (str): String representation of trust boundary meta.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_service_account_file` or\n            :meth:`from_service_account_info` are used instead of calling the\n            constructor directly.\n        \"\"\"\n        super(Credentials, self).__init__()\n\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._signer = signer\n        self._service_account_email = service_account_email\n        self._subject = subject\n        self._project_id = project_id\n        self._quota_project_id = quota_project_id\n        self._token_uri = token_uri\n        self._always_use_jwt_access = always_use_jwt_access\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n\n        if universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            self._always_use_jwt_access = True\n\n        self._jwt_credentials = None\n\n        if additional_claims is not None:\n            self._additional_claims = additional_claims\n        else:\n            self._additional_claims = {}\n        self._trust_boundary = {\"locations\": [], \"encoded_locations\": \"0x0\"}\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates a Credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        return cls(\n            signer,\n            service_account_email=info[\"client_email\"],\n            token_uri=info[\"token_uri\"],\n            project_id=info.get(\"project_id\"),\n            universe_domain=info.get(\n                \"universe_domain\", credentials.DEFAULT_UNIVERSE_DOMAIN\n            ),\n            trust_boundary=info.get(\"trust_boundary\"),\n            **kwargs\n        )\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates a Credentials instance from parsed service account info.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(\n            info, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from a service account json file.\n\n        Args:\n            filename (str): The path to the service account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.Credentials: The constructed\n                credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        return self._service_account_email\n\n    @property\n    def project_id(self):\n        \"\"\"Project ID associated with this credential.\"\"\"\n        return self._project_id\n\n    @property\n    def requires_scopes(self):\n        \"\"\"Checks if the credentials requires scopes.\n\n        Returns:\n            bool: True if there are no scopes set otherwise False.\n        \"\"\"\n        return True if not self._scopes else False\n\n    def _make_copy(self):\n        cred = self.__class__(\n            self._signer,\n            service_account_email=self._service_account_email,\n            scopes=copy.copy(self._scopes),\n            default_scopes=copy.copy(self._default_scopes),\n            token_uri=self._token_uri,\n            subject=self._subject,\n            project_id=self._project_id,\n            quota_project_id=self._quota_project_id,\n            additional_claims=self._additional_claims.copy(),\n            always_use_jwt_access=self._always_use_jwt_access,\n            universe_domain=self._universe_domain,\n        )\n        return cred\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        cred = self._make_copy()\n        cred._scopes = scopes\n        cred._default_scopes = default_scopes\n        return cred\n\n    def with_always_use_jwt_access(self, always_use_jwt_access):\n        \"\"\"Create a copy of these credentials with the specified always_use_jwt_access value.\n\n        Args:\n            always_use_jwt_access (bool): Whether always use self signed JWT or not.\n\n        Returns:\n            google.auth.service_account.Credentials: A new credentials\n                instance.\n        Raises:\n            google.auth.exceptions.InvalidValue: If the universe domain is not\n                default and always_use_jwt_access is False.\n        \"\"\"\n        cred = self._make_copy()\n        if (\n            cred._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN\n            and not always_use_jwt_access\n        ):\n            raise exceptions.InvalidValue(\n                \"always_use_jwt_access should be True for non-default universe domain\"\n            )\n        cred._always_use_jwt_access = always_use_jwt_access\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        cred = self._make_copy()\n        cred._universe_domain = universe_domain\n        if universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            cred._always_use_jwt_access = True\n        return cred\n\n    def with_subject(self, subject):\n        \"\"\"Create a copy of these credentials with the specified subject.\n\n        Args:\n            subject (str): The subject claim.\n\n        Returns:\n            google.auth.service_account.Credentials: A new credentials\n                instance.\n        \"\"\"\n        cred = self._make_copy()\n        cred._subject = subject\n        return cred\n\n    def with_claims(self, additional_claims):\n        \"\"\"Returns a copy of these credentials with modified claims.\n\n        Args:\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload. This will be merged with the current\n                additional claims.\n\n        Returns:\n            google.auth.service_account.Credentials: A new credentials\n                instance.\n        \"\"\"\n        new_additional_claims = copy.deepcopy(self._additional_claims)\n        new_additional_claims.update(additional_claims or {})\n        cred = self._make_copy()\n        cred._additional_claims = new_additional_claims\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        cred = self._make_copy()\n        cred._quota_project_id = quota_project_id\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        cred = self._make_copy()\n        cred._token_uri = token_uri\n        return cred\n\n    def _make_authorization_grant_assertion(self):\n        \"\"\"Create the OAuth 2.0 assertion.\n\n        This assertion is used during the OAuth 2.0 grant to acquire an\n        access token.\n\n        Returns:\n            bytes: The authorization grant assertion.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)\n        expiry = now + lifetime\n\n        payload = {\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            # The issuer must be the service account email.\n            \"iss\": self._service_account_email,\n            # The audience must be the auth token endpoint's URI\n            \"aud\": _GOOGLE_OAUTH2_TOKEN_ENDPOINT,\n            \"scope\": _helpers.scopes_to_string(self._scopes or ()),\n        }\n\n        payload.update(self._additional_claims)\n\n        # The subject can be a user email for domain-wide delegation.\n        if self._subject:\n            payload.setdefault(\"sub\", self._subject)\n\n        token = jwt.encode(self._signer, payload)\n\n        return token\n\n    def _use_self_signed_jwt(self):\n        # Since domain wide delegation doesn't work with self signed JWT. If\n        # subject exists, then we should not use self signed JWT.\n        return self._subject is None and self._jwt_credentials is not None\n\n    def _metric_header_for_usage(self):\n        if self._use_self_signed_jwt():\n            return metrics.CRED_TYPE_SA_JWT\n        return metrics.CRED_TYPE_SA_ASSERTION\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        if self._always_use_jwt_access and not self._jwt_credentials:\n            # If self signed jwt should be used but jwt credential is not\n            # created, try to create one with scopes\n            self._create_self_signed_jwt(None)\n\n        if (\n            self._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN\n            and self._subject\n        ):\n            raise exceptions.RefreshError(\n                \"domain wide delegation is not supported for non-default universe domain\"\n            )\n\n        if self._use_self_signed_jwt():\n            self._jwt_credentials.refresh(request)\n            self.token = self._jwt_credentials.token.decode()\n            self.expiry = self._jwt_credentials.expiry\n        else:\n            assertion = self._make_authorization_grant_assertion()\n            access_token, expiry, _ = _client.jwt_grant(\n                request, self._token_uri, assertion\n            )\n            self.token = access_token\n            self.expiry = expiry\n\n    def _create_self_signed_jwt(self, audience):\n        \"\"\"Create a self-signed JWT from the credentials if requirements are met.\n\n        Args:\n            audience (str): The service URL. ``https://[API_ENDPOINT]/``\n        \"\"\"\n        # https://google.aip.dev/auth/4111\n        if self._always_use_jwt_access:\n            if self._scopes:\n                additional_claims = {\"scope\": \" \".join(self._scopes)}\n                if (\n                    self._jwt_credentials is None\n                    or self._jwt_credentials.additional_claims != additional_claims\n                ):\n                    self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                        self, None, additional_claims=additional_claims\n                    )\n            elif audience:\n                if (\n                    self._jwt_credentials is None\n                    or self._jwt_credentials._audience != audience\n                ):\n\n                    self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                        self, audience\n                    )\n            elif self._default_scopes:\n                additional_claims = {\"scope\": \" \".join(self._default_scopes)}\n                if (\n                    self._jwt_credentials is None\n                    or additional_claims != self._jwt_credentials.additional_claims\n                ):\n                    self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                        self, None, additional_claims=additional_claims\n                    )\n        elif not self._scopes and audience:\n            self._jwt_credentials = jwt.Credentials.from_signing_credentials(\n                self, audience\n            )\n\n    @_helpers.copy_docstring(credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer_email(self):\n        return self._service_account_email\n\n\nclass IDTokenCredentials(\n    credentials.Signing,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    These credentials are largely similar to :class:`.Credentials`, but instead\n    of using an OAuth 2.0 Access Token as the bearer token, they use an Open\n    ID Connect ID Token as the bearer token. These credentials are useful when\n    communicating to services that require ID Tokens and can not accept access\n    tokens.\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = (\n            service_account.IDTokenCredentials.from_service_account_file(\n                'service-account.json'))\n\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = (\n            service_account.IDTokenCredentials.from_service_account_info(\n                service_account_info))\n\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = (\n            service_account.IDTokenCredentials.from_service_account_file(\n                'service-account.json',\n                scopes=['email'],\n                subject='user@example.com'))\n\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        service_account_email,\n        token_uri,\n        target_audience,\n        additional_claims=None,\n        quota_project_id=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            service_account_email (str): The service account's email.\n            token_uri (str): The OAuth 2.0 Token URI.\n            target_audience (str): The intended audience for these credentials,\n                used when requesting the ID Token. The ID Token's ``aud`` claim\n                will be set to this string.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT assertion used in the authorization grant.\n            quota_project_id (Optional[str]): The project ID used for quota and billing.\n            universe_domain (str): The universe domain. The default\n                universe domain is googleapis.com. For default value IAM ID\n                token endponint is used for token refresh. Note that\n                iam.serviceAccountTokenCreator role is required to use the IAM\n                endpoint.\n        .. note:: Typically one of the helper constructors\n            :meth:`from_service_account_file` or\n            :meth:`from_service_account_info` are used instead of calling the\n            constructor directly.\n        \"\"\"\n        super(IDTokenCredentials, self).__init__()\n        self._signer = signer\n        self._service_account_email = service_account_email\n        self._token_uri = token_uri\n        self._target_audience = target_audience\n        self._quota_project_id = quota_project_id\n        self._use_iam_endpoint = False\n\n        if not universe_domain:\n            self._universe_domain = credentials.DEFAULT_UNIVERSE_DOMAIN\n        else:\n            self._universe_domain = universe_domain\n        self._iam_id_token_endpoint = iam._IAM_IDTOKEN_ENDPOINT.replace(\n            \"googleapis.com\", self._universe_domain\n        )\n\n        if self._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            self._use_iam_endpoint = True\n\n        if additional_claims is not None:\n            self._additional_claims = additional_claims\n        else:\n            self._additional_claims = {}\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates a credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.IDTokenCredentials: The constructed credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        kwargs.setdefault(\"service_account_email\", info[\"client_email\"])\n        kwargs.setdefault(\"token_uri\", info[\"token_uri\"])\n        if \"universe_domain\" in info:\n            kwargs[\"universe_domain\"] = info[\"universe_domain\"]\n        return cls(signer, **kwargs)\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates a credentials instance from parsed service account info.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(\n            info, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates a credentials instance from a service account json file.\n\n        Args:\n            filename (str): The path to the service account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: The constructed\n                credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\", \"token_uri\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    def _make_copy(self):\n        cred = self.__class__(\n            self._signer,\n            service_account_email=self._service_account_email,\n            token_uri=self._token_uri,\n            target_audience=self._target_audience,\n            additional_claims=self._additional_claims.copy(),\n            quota_project_id=self.quota_project_id,\n            universe_domain=self._universe_domain,\n        )\n        # _use_iam_endpoint is not exposed in the constructor\n        cred._use_iam_endpoint = self._use_iam_endpoint\n        return cred\n\n    def with_target_audience(self, target_audience):\n        \"\"\"Create a copy of these credentials with the specified target\n        audience.\n\n        Args:\n            target_audience (str): The intended audience for these credentials,\n            used when requesting the ID Token.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: A new credentials\n                instance.\n        \"\"\"\n        cred = self._make_copy()\n        cred._target_audience = target_audience\n        return cred\n\n    def _with_use_iam_endpoint(self, use_iam_endpoint):\n        \"\"\"Create a copy of these credentials with the use_iam_endpoint value.\n\n        Args:\n            use_iam_endpoint (bool): If True, IAM generateIdToken endpoint will\n                be used instead of the token_uri. Note that\n                iam.serviceAccountTokenCreator role is required to use the IAM\n                endpoint. The default value is False. This feature is currently\n                experimental and subject to change without notice.\n\n        Returns:\n            google.auth.service_account.IDTokenCredentials: A new credentials\n                instance.\n        Raises:\n            google.auth.exceptions.InvalidValue: If the universe domain is not\n                default and use_iam_endpoint is False.\n        \"\"\"\n        cred = self._make_copy()\n        if (\n            cred._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN\n            and not use_iam_endpoint\n        ):\n            raise exceptions.InvalidValue(\n                \"use_iam_endpoint should be True for non-default universe domain\"\n            )\n        cred._use_iam_endpoint = use_iam_endpoint\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        cred = self._make_copy()\n        cred._quota_project_id = quota_project_id\n        return cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        cred = self._make_copy()\n        cred._token_uri = token_uri\n        return cred\n\n    def _make_authorization_grant_assertion(self):\n        \"\"\"Create the OAuth 2.0 assertion.\n\n        This assertion is used during the OAuth 2.0 grant to acquire an\n        ID token.\n\n        Returns:\n            bytes: The authorization grant assertion.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)\n        expiry = now + lifetime\n\n        payload = {\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            # The issuer must be the service account email.\n            \"iss\": self.service_account_email,\n            # The audience must be the auth token endpoint's URI\n            \"aud\": _GOOGLE_OAUTH2_TOKEN_ENDPOINT,\n            # The target audience specifies which service the ID token is\n            # intended for.\n            \"target_audience\": self._target_audience,\n        }\n\n        payload.update(self._additional_claims)\n\n        token = jwt.encode(self._signer, payload)\n\n        return token\n\n    def _refresh_with_iam_endpoint(self, request):\n        \"\"\"Use IAM generateIdToken endpoint to obtain an ID token.\n\n        It works as follows:\n\n        1. First we create a self signed jwt with\n        https://www.googleapis.com/auth/iam being the scope.\n\n        2. Next we use the self signed jwt as the access token, and make a POST\n        request to IAM generateIdToken endpoint. The request body is:\n            {\n                \"audience\": self._target_audience,\n                \"includeEmail\": \"true\",\n                \"useEmailAzp\": \"true\",\n            }\n\n        If the request is succesfully, it will return {\"token\":\"the ID token\"},\n        and we can extract the ID token and compute its expiry.\n        \"\"\"\n        jwt_credentials = jwt.Credentials.from_signing_credentials(\n            self,\n            None,\n            additional_claims={\"scope\": \"https://www.googleapis.com/auth/iam\"},\n        )\n        jwt_credentials.refresh(request)\n        self.token, self.expiry = _client.call_iam_generate_id_token_endpoint(\n            request,\n            self._iam_id_token_endpoint,\n            self.signer_email,\n            self._target_audience,\n            jwt_credentials.token.decode(),\n        )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        if self._use_iam_endpoint:\n            self._refresh_with_iam_endpoint(request)\n        else:\n            assertion = self._make_authorization_grant_assertion()\n            access_token, expiry, _ = _client.id_token_jwt_grant(\n                request, self._token_uri, assertion\n            )\n            self.token = access_token\n            self.expiry = expiry\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        return self._service_account_email\n\n    @_helpers.copy_docstring(credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer_email(self):\n        return self._service_account_email\n", "google/oauth2/_credentials_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Async Credentials.\n\nThis module provides credentials based on OAuth 2.0 access and refresh tokens.\nThese credentials usually access resources on behalf of a user (resource\nowner).\n\nSpecifically, this is intended to use access tokens acquired using the\n`Authorization Code grant`_ and can refresh those tokens using a\noptional `refresh token`_.\n\nObtaining the initial access and refresh token is outside of the scope of this\nmodule. Consult `rfc6749 section 4.1`_ for complete details on the\nAuthorization Code grant flow.\n\n.. _Authorization Code grant: https://tools.ietf.org/html/rfc6749#section-1.3.1\n.. _refresh token: https://tools.ietf.org/html/rfc6749#section-6\n.. _rfc6749 section 4.1: https://tools.ietf.org/html/rfc6749#section-4.1\n\"\"\"\n\nfrom google.auth import _credentials_async as credentials\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.oauth2 import _reauth_async as reauth\nfrom google.oauth2 import credentials as oauth2_credentials\n\n\nclass Credentials(oauth2_credentials.Credentials):\n    \"\"\"Credentials using OAuth 2.0 access and refresh tokens.\n\n    The credentials are considered immutable. If you want to modify the\n    quota project, use :meth:`with_quota_project` or ::\n\n        credentials = credentials.with_quota_project('myproject-123)\n    \"\"\"\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    async def refresh(self, request):\n        if (\n            self._refresh_token is None\n            or self._token_uri is None\n            or self._client_id is None\n            or self._client_secret is None\n        ):\n            raise exceptions.RefreshError(\n                \"The credentials do not contain the necessary fields need to \"\n                \"refresh the access token. You must specify refresh_token, \"\n                \"token_uri, client_id, and client_secret.\"\n            )\n\n        (\n            access_token,\n            refresh_token,\n            expiry,\n            grant_response,\n            rapt_token,\n        ) = await reauth.refresh_grant(\n            request,\n            self._token_uri,\n            self._refresh_token,\n            self._client_id,\n            self._client_secret,\n            scopes=self._scopes,\n            rapt_token=self._rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n        )\n\n        self.token = access_token\n        self.expiry = expiry\n        self._refresh_token = refresh_token\n        self._id_token = grant_response.get(\"id_token\")\n        self._rapt_token = rapt_token\n\n        if self._scopes and \"scope\" in grant_response:\n            requested_scopes = frozenset(self._scopes)\n            granted_scopes = frozenset(grant_response[\"scope\"].split())\n            scopes_requested_but_not_granted = requested_scopes - granted_scopes\n            if scopes_requested_but_not_granted:\n                raise exceptions.RefreshError(\n                    \"Not all requested scopes were granted by the \"\n                    \"authorization server, missing scopes {}.\".format(\n                        \", \".join(scopes_requested_but_not_granted)\n                    )\n                )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    async def before_request(self, request, method, url, headers):\n        if not self.valid:\n            await self.refresh(request)\n        self.apply(headers)\n\n\nclass UserAccessTokenCredentials(oauth2_credentials.UserAccessTokenCredentials):\n    \"\"\"Access token credentials for user account.\n\n    Obtain the access token for a given user account or the current active\n    user account with the ``gcloud auth print-access-token`` command.\n\n    Args:\n        account (Optional[str]): Account to get the access token for. If not\n            specified, the current active account will be used.\n        quota_project_id (Optional[str]): The project ID used for quota\n            and billing.\n\n    \"\"\"\n", "google/oauth2/webauthn_handler.py": "import abc\nimport os\nimport struct\nimport subprocess\n\nfrom google.auth import exceptions\nfrom google.oauth2.webauthn_types import GetRequest, GetResponse\n\n\nclass WebAuthnHandler(abc.ABC):\n    @abc.abstractmethod\n    def is_available(self) -> bool:\n        \"\"\"Check whether this WebAuthn handler is available\"\"\"\n        raise NotImplementedError(\"is_available method must be implemented\")\n\n    @abc.abstractmethod\n    def get(self, get_request: GetRequest) -> GetResponse:\n        \"\"\"WebAuthn get (assertion)\"\"\"\n        raise NotImplementedError(\"get method must be implemented\")\n\n\nclass PluginHandler(WebAuthnHandler):\n    \"\"\"Offloads WebAuthn get reqeust to a pluggable command-line tool.\n\n    Offloads WebAuthn get to a plugin which takes the form of a\n    command-line tool. The command-line tool is configurable via the\n    PluginHandler._ENV_VAR environment variable.\n\n    The WebAuthn plugin should implement the following interface:\n\n    Communication occurs over stdin/stdout, and messages are both sent and\n    received in the form:\n\n    [4 bytes - payload size (little-endian)][variable bytes - json payload]\n    \"\"\"\n\n    _ENV_VAR = \"GOOGLE_AUTH_WEBAUTHN_PLUGIN\"\n\n    def is_available(self) -> bool:\n        try:\n            self._find_plugin()\n        except Exception:\n            return False\n        else:\n            return True\n\n    def get(self, get_request: GetRequest) -> GetResponse:\n        request_json = get_request.to_json()\n        cmd = self._find_plugin()\n        response_json = self._call_plugin(cmd, request_json)\n        return GetResponse.from_json(response_json)\n\n    def _call_plugin(self, cmd: str, input_json: str) -> str:\n        # Calculate length of input\n        input_length = len(input_json)\n        length_bytes_le = struct.pack(\"<I\", input_length)\n        request = length_bytes_le + input_json.encode()\n\n        # Call plugin\n        process_result = subprocess.run(\n            [cmd], input=request, capture_output=True, check=True\n        )\n\n        # Check length of response\n        response_len_le = process_result.stdout[:4]\n        response_len = struct.unpack(\"<I\", response_len_le)[0]\n        response = process_result.stdout[4:]\n        if response_len != len(response):\n            raise exceptions.MalformedError(\n                \"Plugin response length {} does not match data {}\".format(\n                    response_len, len(response)\n                )\n            )\n        return response.decode()\n\n    def _find_plugin(self) -> str:\n        plugin_cmd = os.environ.get(PluginHandler._ENV_VAR)\n        if plugin_cmd is None:\n            raise exceptions.InvalidResource(\n                \"{} env var is not set\".format(PluginHandler._ENV_VAR)\n            )\n        return plugin_cmd\n", "google/oauth2/utils.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Utilities.\n\nThis module provides implementations for various OAuth 2.0 utilities.\nThis includes `OAuth error handling`_ and\n`Client authentication for OAuth flows`_.\n\nOAuth error handling\n--------------------\nThis will define interfaces for handling OAuth related error responses as\nstated in `RFC 6749 section 5.2`_.\nThis will include a common function to convert these HTTP error responses to a\n:class:`google.auth.exceptions.OAuthError` exception.\n\n\nClient authentication for OAuth flows\n-------------------------------------\nWe introduce an interface for defining client authentication credentials based\non `RFC 6749 section 2.3.1`_. This will expose the following\ncapabilities:\n\n    * Ability to support basic authentication via request header.\n    * Ability to support bearer token authentication via request header.\n    * Ability to support client ID / secret authentication via request body.\n\n.. _RFC 6749 section 2.3.1: https://tools.ietf.org/html/rfc6749#section-2.3.1\n.. _RFC 6749 section 5.2: https://tools.ietf.org/html/rfc6749#section-5.2\n\"\"\"\n\nimport abc\nimport base64\nimport enum\nimport json\n\nfrom google.auth import exceptions\n\n\n# OAuth client authentication based on\n# https://tools.ietf.org/html/rfc6749#section-2.3.\nclass ClientAuthType(enum.Enum):\n    basic = 1\n    request_body = 2\n\n\nclass ClientAuthentication(object):\n    \"\"\"Defines the client authentication credentials for basic and request-body\n    types based on https://tools.ietf.org/html/rfc6749#section-2.3.1.\n    \"\"\"\n\n    def __init__(self, client_auth_type, client_id, client_secret=None):\n        \"\"\"Instantiates a client authentication object containing the client ID\n        and secret credentials for basic and response-body auth.\n\n        Args:\n            client_auth_type (google.oauth2.oauth_utils.ClientAuthType): The\n                client authentication type.\n            client_id (str): The client ID.\n            client_secret (Optional[str]): The client secret.\n        \"\"\"\n        self.client_auth_type = client_auth_type\n        self.client_id = client_id\n        self.client_secret = client_secret\n\n\nclass OAuthClientAuthHandler(metaclass=abc.ABCMeta):\n    \"\"\"Abstract class for handling client authentication in OAuth-based\n    operations.\n    \"\"\"\n\n    def __init__(self, client_authentication=None):\n        \"\"\"Instantiates an OAuth client authentication handler.\n\n        Args:\n            client_authentication (Optional[google.oauth2.utils.ClientAuthentication]):\n                The OAuth client authentication credentials if available.\n        \"\"\"\n        super(OAuthClientAuthHandler, self).__init__()\n        self._client_authentication = client_authentication\n\n    def apply_client_authentication_options(\n        self, headers, request_body=None, bearer_token=None\n    ):\n        \"\"\"Applies client authentication on the OAuth request's headers or POST\n        body.\n\n        Args:\n            headers (Mapping[str, str]): The HTTP request header.\n            request_body (Optional[Mapping[str, str]]): The HTTP request body\n                dictionary. For requests that do not support request body, this\n                is None and will be ignored.\n            bearer_token (Optional[str]): The optional bearer token.\n        \"\"\"\n        # Inject authenticated header.\n        self._inject_authenticated_headers(headers, bearer_token)\n        # Inject authenticated request body.\n        if bearer_token is None:\n            self._inject_authenticated_request_body(request_body)\n\n    def _inject_authenticated_headers(self, headers, bearer_token=None):\n        if bearer_token is not None:\n            headers[\"Authorization\"] = \"Bearer %s\" % bearer_token\n        elif (\n            self._client_authentication is not None\n            and self._client_authentication.client_auth_type is ClientAuthType.basic\n        ):\n            username = self._client_authentication.client_id\n            password = self._client_authentication.client_secret or \"\"\n\n            credentials = base64.b64encode(\n                (\"%s:%s\" % (username, password)).encode()\n            ).decode()\n            headers[\"Authorization\"] = \"Basic %s\" % credentials\n\n    def _inject_authenticated_request_body(self, request_body):\n        if (\n            self._client_authentication is not None\n            and self._client_authentication.client_auth_type\n            is ClientAuthType.request_body\n        ):\n            if request_body is None:\n                raise exceptions.OAuthError(\n                    \"HTTP request does not support request-body\"\n                )\n            else:\n                request_body[\"client_id\"] = self._client_authentication.client_id\n                request_body[\"client_secret\"] = (\n                    self._client_authentication.client_secret or \"\"\n                )\n\n\ndef handle_error_response(response_body):\n    \"\"\"Translates an error response from an OAuth operation into an\n    OAuthError exception.\n\n    Args:\n        response_body (str): The decoded response data.\n\n    Raises:\n        google.auth.exceptions.OAuthError\n    \"\"\"\n    try:\n        error_components = []\n        error_data = json.loads(response_body)\n\n        error_components.append(\"Error code {}\".format(error_data[\"error\"]))\n        if \"error_description\" in error_data:\n            error_components.append(\": {}\".format(error_data[\"error_description\"]))\n        if \"error_uri\" in error_data:\n            error_components.append(\" - {}\".format(error_data[\"error_uri\"]))\n        error_details = \"\".join(error_components)\n    # If no details could be extracted, use the response data.\n    except (KeyError, ValueError):\n        error_details = response_body\n\n    raise exceptions.OAuthError(error_details, response_body)\n", "google/oauth2/sts.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Token Exchange Spec.\n\nThis module defines a token exchange utility based on the `OAuth 2.0 Token\nExchange`_ spec. This will be mainly used to exchange external credentials\nfor GCP access tokens in workload identity pools to access Google APIs.\n\nThe implementation will support various types of client authentication as\nallowed in the spec.\n\nA deviation on the spec will be for additional Google specific options that\ncannot be easily mapped to parameters defined in the RFC.\n\nThe returned dictionary response will be based on the `rfc8693 section 2.2.1`_\nspec JSON response.\n\n.. _OAuth 2.0 Token Exchange: https://tools.ietf.org/html/rfc8693\n.. _rfc8693 section 2.2.1: https://tools.ietf.org/html/rfc8693#section-2.2.1\n\"\"\"\n\nimport http.client as http_client\nimport json\nimport urllib\n\nfrom google.oauth2 import utils\n\n\n_URLENCODED_HEADERS = {\"Content-Type\": \"application/x-www-form-urlencoded\"}\n\n\nclass Client(utils.OAuthClientAuthHandler):\n    \"\"\"Implements the OAuth 2.0 token exchange spec based on\n    https://tools.ietf.org/html/rfc8693.\n    \"\"\"\n\n    def __init__(self, token_exchange_endpoint, client_authentication=None):\n        \"\"\"Initializes an STS client instance.\n\n        Args:\n            token_exchange_endpoint (str): The token exchange endpoint.\n            client_authentication (Optional(google.oauth2.oauth2_utils.ClientAuthentication)):\n                The optional OAuth client authentication credentials if available.\n        \"\"\"\n        super(Client, self).__init__(client_authentication)\n        self._token_exchange_endpoint = token_exchange_endpoint\n\n    def _make_request(self, request, headers, request_body):\n        # Initialize request headers.\n        request_headers = _URLENCODED_HEADERS.copy()\n\n        # Inject additional headers.\n        if headers:\n            for k, v in dict(headers).items():\n                request_headers[k] = v\n\n        # Apply OAuth client authentication.\n        self.apply_client_authentication_options(request_headers, request_body)\n\n        # Execute request.\n        response = request(\n            url=self._token_exchange_endpoint,\n            method=\"POST\",\n            headers=request_headers,\n            body=urllib.parse.urlencode(request_body).encode(\"utf-8\"),\n        )\n\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        # If non-200 response received, translate to OAuthError exception.\n        if response.status != http_client.OK:\n            utils.handle_error_response(response_body)\n\n        response_data = json.loads(response_body)\n\n        # Return successful response.\n        return response_data\n\n    def exchange_token(\n        self,\n        request,\n        grant_type,\n        subject_token,\n        subject_token_type,\n        resource=None,\n        audience=None,\n        scopes=None,\n        requested_token_type=None,\n        actor_token=None,\n        actor_token_type=None,\n        additional_options=None,\n        additional_headers=None,\n    ):\n        \"\"\"Exchanges the provided token for another type of token based on the\n        rfc8693 spec.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            grant_type (str): The OAuth 2.0 token exchange grant type.\n            subject_token (str): The OAuth 2.0 token exchange subject token.\n            subject_token_type (str): The OAuth 2.0 token exchange subject token type.\n            resource (Optional[str]): The optional OAuth 2.0 token exchange resource field.\n            audience (Optional[str]): The optional OAuth 2.0 token exchange audience field.\n            scopes (Optional[Sequence[str]]): The optional list of scopes to use.\n            requested_token_type (Optional[str]): The optional OAuth 2.0 token exchange requested\n                token type.\n            actor_token (Optional[str]): The optional OAuth 2.0 token exchange actor token.\n            actor_token_type (Optional[str]): The optional OAuth 2.0 token exchange actor token type.\n            additional_options (Optional[Mapping[str, str]]): The optional additional\n                non-standard Google specific options.\n            additional_headers (Optional[Mapping[str, str]]): The optional additional\n                headers to pass to the token exchange endpoint.\n\n        Returns:\n            Mapping[str, str]: The token exchange JSON-decoded response data containing\n                the requested token and its expiration time.\n\n        Raises:\n            google.auth.exceptions.OAuthError: If the token endpoint returned\n                an error.\n        \"\"\"\n        # Initialize request body.\n        request_body = {\n            \"grant_type\": grant_type,\n            \"resource\": resource,\n            \"audience\": audience,\n            \"scope\": \" \".join(scopes or []),\n            \"requested_token_type\": requested_token_type,\n            \"subject_token\": subject_token,\n            \"subject_token_type\": subject_token_type,\n            \"actor_token\": actor_token,\n            \"actor_token_type\": actor_token_type,\n            \"options\": None,\n        }\n        # Add additional non-standard options.\n        if additional_options:\n            request_body[\"options\"] = urllib.parse.quote(json.dumps(additional_options))\n        # Remove empty fields in request body.\n        for k, v in dict(request_body).items():\n            if v is None or v == \"\":\n                del request_body[k]\n\n        return self._make_request(request, additional_headers, request_body)\n\n    def refresh_token(self, request, refresh_token):\n        \"\"\"Exchanges a refresh token for an access token based on the\n        RFC6749 spec.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            subject_token (str): The OAuth 2.0 refresh token.\n        \"\"\"\n\n        return self._make_request(\n            request,\n            None,\n            {\"grant_type\": \"refresh_token\", \"refresh_token\": refresh_token},\n        )\n", "google/oauth2/id_token.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google ID Token helpers.\n\nProvides support for verifying `OpenID Connect ID Tokens`_, especially ones\ngenerated by Google infrastructure.\n\nTo parse and verify an ID Token issued by Google's OAuth 2.0 authorization\nserver use :func:`verify_oauth2_token`. To verify an ID Token issued by\nFirebase, use :func:`verify_firebase_token`.\n\nA general purpose ID Token verifier is available as :func:`verify_token`.\n\nExample::\n\n    from google.oauth2 import id_token\n    from google.auth.transport import requests\n\n    request = requests.Request()\n\n    id_info = id_token.verify_oauth2_token(\n        token, request, 'my-client-id.example.com')\n\n    userid = id_info['sub']\n\nBy default, this will re-fetch certificates for each verification. Because\nGoogle's public keys are only changed infrequently (on the order of once per\nday), you may wish to take advantage of caching to reduce latency and the\npotential for network errors. This can be accomplished using an external\nlibrary like `CacheControl`_ to create a cache-aware\n:class:`google.auth.transport.Request`::\n\n    import cachecontrol\n    import google.auth.transport.requests\n    import requests\n\n    session = requests.session()\n    cached_session = cachecontrol.CacheControl(session)\n    request = google.auth.transport.requests.Request(session=cached_session)\n\n.. _OpenID Connect ID Tokens:\n    http://openid.net/specs/openid-connect-core-1_0.html#IDToken\n.. _CacheControl: https://cachecontrol.readthedocs.io\n\"\"\"\n\nimport http.client as http_client\nimport json\nimport os\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import jwt\n\n\n# The URL that provides public certificates for verifying ID tokens issued\n# by Google's OAuth 2.0 authorization server.\n_GOOGLE_OAUTH2_CERTS_URL = \"https://www.googleapis.com/oauth2/v1/certs\"\n\n# The URL that provides public certificates for verifying ID tokens issued\n# by Firebase and the Google APIs infrastructure\n_GOOGLE_APIS_CERTS_URL = (\n    \"https://www.googleapis.com/robot/v1/metadata/x509\"\n    \"/securetoken@system.gserviceaccount.com\"\n)\n\n_GOOGLE_ISSUERS = [\"accounts.google.com\", \"https://accounts.google.com\"]\n\n\ndef _fetch_certs(request, certs_url):\n    \"\"\"Fetches certificates.\n\n    Google-style cerificate endpoints return JSON in the format of\n    ``{'key id': 'x509 certificate'}``.\n\n    Args:\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        certs_url (str): The certificate endpoint URL.\n\n    Returns:\n        Mapping[str, str]: A mapping of public key ID to x.509 certificate\n            data.\n    \"\"\"\n    response = request(certs_url, method=\"GET\")\n\n    if response.status != http_client.OK:\n        raise exceptions.TransportError(\n            \"Could not fetch certificates at {}\".format(certs_url)\n        )\n\n    return json.loads(response.data.decode(\"utf-8\"))\n\n\ndef verify_token(\n    id_token,\n    request,\n    audience=None,\n    certs_url=_GOOGLE_OAUTH2_CERTS_URL,\n    clock_skew_in_seconds=0,\n):\n    \"\"\"Verifies an ID token and returns the decoded token.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        audience (str or list): The audience or audiences that this token is\n            intended for. If None then the audience is not verified.\n        certs_url (str): The URL that specifies the certificates to use to\n            verify the token. This URL should return JSON in the format of\n            ``{'key id': 'x509 certificate'}``.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    certs = _fetch_certs(request, certs_url)\n\n    return jwt.decode(\n        id_token,\n        certs=certs,\n        audience=audience,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\ndef verify_oauth2_token(id_token, request, audience=None, clock_skew_in_seconds=0):\n    \"\"\"Verifies an ID Token issued by Google's OAuth 2.0 authorization server.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        audience (str): The audience that this token is intended for. This is\n            typically your application's OAuth 2.0 client ID. If None then the\n            audience is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n\n    Raises:\n        exceptions.GoogleAuthError: If the issuer is invalid.\n        ValueError: If token verification fails\n    \"\"\"\n    idinfo = verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=_GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n    if idinfo[\"iss\"] not in _GOOGLE_ISSUERS:\n        raise exceptions.GoogleAuthError(\n            \"Wrong issuer. 'iss' should be one of the following: {}\".format(\n                _GOOGLE_ISSUERS\n            )\n        )\n\n    return idinfo\n\n\ndef verify_firebase_token(id_token, request, audience=None, clock_skew_in_seconds=0):\n    \"\"\"Verifies an ID Token issued by Firebase Authentication.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests.\n        audience (str): The audience that this token is intended for. This is\n            typically your Firebase application ID. If None then the audience\n            is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    return verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=_GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\ndef fetch_id_token_credentials(audience, request=None):\n    \"\"\"Create the ID Token credentials from the current environment.\n\n    This function acquires ID token from the environment in the following order.\n    See https://google.aip.dev/auth/4110.\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON file, then ID token is\n       acquired using this service account credentials.\n    2. If the application is running in Compute Engine, App Engine or Cloud Run,\n       then the ID token are obtained from the metadata server.\n    3. If metadata server doesn't exist and no valid service account credentials\n       are found, :class:`~google.auth.exceptions.DefaultCredentialsError` will\n       be raised.\n\n    Example::\n\n        import google.oauth2.id_token\n        import google.auth.transport.requests\n\n        request = google.auth.transport.requests.Request()\n        target_audience = \"https://pubsub.googleapis.com\"\n\n        # Create ID token credentials.\n        credentials = google.oauth2.id_token.fetch_id_token_credentials(target_audience, request=request)\n\n        # Refresh the credential to obtain an ID token.\n        credentials.refresh(request)\n\n        id_token = credentials.token\n        id_token_expiry = credentials.expiry\n\n    Args:\n        audience (str): The audience that this ID token is intended for.\n        request (Optional[google.auth.transport.Request]): A callable used to make\n            HTTP requests. A request object will be created if not provided.\n\n    Returns:\n        google.auth.credentials.Credentials: The ID token credentials.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If metadata server doesn't exist and no valid service account\n            credentials are found.\n    \"\"\"\n    # 1. Try to get credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    # variable.\n    credentials_filename = os.environ.get(environment_vars.CREDENTIALS)\n    if credentials_filename:\n        if not (\n            os.path.exists(credentials_filename)\n            and os.path.isfile(credentials_filename)\n        ):\n            raise exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS path is either not found or invalid.\"\n            )\n\n        try:\n            with open(credentials_filename, \"r\") as f:\n                from google.oauth2 import service_account\n\n                info = json.load(f)\n                if info.get(\"type\") == \"service_account\":\n                    return service_account.IDTokenCredentials.from_service_account_info(\n                        info, target_audience=audience\n                    )\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS is not valid service account credentials.\",\n                caught_exc,\n            )\n            raise new_exc from caught_exc\n\n    # 2. Try to fetch ID token from metada server if it exists. The code\n    # works for GAE and Cloud Run metadata server as well.\n    try:\n        from google.auth import compute_engine\n        from google.auth.compute_engine import _metadata\n\n        # Create a request object if not provided.\n        if not request:\n            import google.auth.transport.requests\n\n            request = google.auth.transport.requests.Request()\n\n        if _metadata.ping(request):\n            return compute_engine.IDTokenCredentials(\n                request, audience, use_metadata_identity_endpoint=True\n            )\n    except (ImportError, exceptions.TransportError):\n        pass\n\n    raise exceptions.DefaultCredentialsError(\n        \"Neither metadata server or valid service account credentials are found.\"\n    )\n\n\ndef fetch_id_token(request, audience):\n    \"\"\"Fetch the ID Token from the current environment.\n\n    This function acquires ID token from the environment in the following order.\n    See https://google.aip.dev/auth/4110.\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON file, then ID token is\n       acquired using this service account credentials.\n    2. If the application is running in Compute Engine, App Engine or Cloud Run,\n       then the ID token are obtained from the metadata server.\n    3. If metadata server doesn't exist and no valid service account credentials\n       are found, :class:`~google.auth.exceptions.DefaultCredentialsError` will\n       be raised.\n\n    Example::\n\n        import google.oauth2.id_token\n        import google.auth.transport.requests\n\n        request = google.auth.transport.requests.Request()\n        target_audience = \"https://pubsub.googleapis.com\"\n\n        id_token = google.oauth2.id_token.fetch_id_token(request, target_audience)\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        audience (str): The audience that this ID token is intended for.\n\n    Returns:\n        str: The ID token.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If metadata server doesn't exist and no valid service account\n            credentials are found.\n    \"\"\"\n    id_token_credentials = fetch_id_token_credentials(audience, request=request)\n    id_token_credentials.refresh(request)\n    return id_token_credentials.token\n", "google/oauth2/reauth.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A module that provides functions for handling rapt authentication.\n\nReauth is a process of obtaining additional authentication (such as password,\nsecurity token, etc.) while refreshing OAuth 2.0 credentials for a user.\n\nCredentials that use the Reauth flow must have the reauth scope,\n``https://www.googleapis.com/auth/accounts.reauth``.\n\nThis module provides a high-level function for executing the Reauth process,\n:func:`refresh_grant`, and lower-level helpers for doing the individual\nsteps of the reauth process.\n\nThose steps are:\n\n1. Obtaining a list of challenges from the reauth server.\n2. Running through each challenge and sending the result back to the reauth\n   server.\n3. Refreshing the access token using the returned rapt token.\n\"\"\"\n\nimport sys\n\nfrom google.auth import exceptions\nfrom google.auth import metrics\nfrom google.oauth2 import _client\nfrom google.oauth2 import challenges\n\n\n_REAUTH_SCOPE = \"https://www.googleapis.com/auth/accounts.reauth\"\n_REAUTH_API = \"https://reauth.googleapis.com/v2/sessions\"\n\n_REAUTH_NEEDED_ERROR = \"invalid_grant\"\n_REAUTH_NEEDED_ERROR_INVALID_RAPT = \"invalid_rapt\"\n_REAUTH_NEEDED_ERROR_RAPT_REQUIRED = \"rapt_required\"\n\n_AUTHENTICATED = \"AUTHENTICATED\"\n_CHALLENGE_REQUIRED = \"CHALLENGE_REQUIRED\"\n_CHALLENGE_PENDING = \"CHALLENGE_PENDING\"\n\n\n# Override this global variable to set custom max number of rounds of reauth\n# challenges should be run.\nRUN_CHALLENGE_RETRY_LIMIT = 5\n\n\ndef is_interactive():\n    \"\"\"Check if we are in an interractive environment.\n\n    Override this function with a different logic if you are using this library\n    outside a CLI.\n\n    If the rapt token needs refreshing, the user needs to answer the challenges.\n    If the user is not in an interractive environment, the challenges can not\n    be answered and we just wait for timeout for no reason.\n\n    Returns:\n        bool: True if is interactive environment, False otherwise.\n    \"\"\"\n\n    return sys.stdin.isatty()\n\n\ndef _get_challenges(\n    request, supported_challenge_types, access_token, requested_scopes=None\n):\n    \"\"\"Does initial request to reauth API to get the challenges.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        supported_challenge_types (Sequence[str]): list of challenge names\n            supported by the manager.\n        access_token (str): Access token with reauth scopes.\n        requested_scopes (Optional(Sequence[str])): Authorized scopes for the credentials.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\"supportedChallengeTypes\": supported_challenge_types}\n    if requested_scopes:\n        body[\"oauthScopesForDomainPolicyLookup\"] = requested_scopes\n    metrics_header = {metrics.API_CLIENT_HEADER: metrics.reauth_start()}\n\n    return _client._token_endpoint_request(\n        request,\n        _REAUTH_API + \":start\",\n        body,\n        access_token=access_token,\n        use_json=True,\n        headers=metrics_header,\n    )\n\n\ndef _send_challenge_result(\n    request, session_id, challenge_id, client_input, access_token\n):\n    \"\"\"Attempt to refresh access token by sending next challenge result.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        session_id (str): session id returned by the initial reauth call.\n        challenge_id (str): challenge id returned by the initial reauth call.\n        client_input: dict with a challenge-specific client input. For example:\n            ``{'credential': password}`` for password challenge.\n        access_token (str): Access token with reauth scopes.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\n        \"sessionId\": session_id,\n        \"challengeId\": challenge_id,\n        \"action\": \"RESPOND\",\n        \"proposalResponse\": client_input,\n    }\n    metrics_header = {metrics.API_CLIENT_HEADER: metrics.reauth_continue()}\n\n    return _client._token_endpoint_request(\n        request,\n        _REAUTH_API + \"/{}:continue\".format(session_id),\n        body,\n        access_token=access_token,\n        use_json=True,\n        headers=metrics_header,\n    )\n\n\ndef _run_next_challenge(msg, request, access_token):\n    \"\"\"Get the next challenge from msg and run it.\n\n    Args:\n        msg (dict): Reauth API response body (either from the initial request to\n            https://reauth.googleapis.com/v2/sessions:start or from sending the\n            previous challenge response to\n            https://reauth.googleapis.com/v2/sessions/id:continue)\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        access_token (str): reauth access token\n\n    Returns:\n        dict: The response from the reauth API.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed.\n    \"\"\"\n    for challenge in msg[\"challenges\"]:\n        if challenge[\"status\"] != \"READY\":\n            # Skip non-activated challenges.\n            continue\n        c = challenges.AVAILABLE_CHALLENGES.get(challenge[\"challengeType\"], None)\n        if not c:\n            raise exceptions.ReauthFailError(\n                \"Unsupported challenge type {0}. Supported types: {1}\".format(\n                    challenge[\"challengeType\"],\n                    \",\".join(list(challenges.AVAILABLE_CHALLENGES.keys())),\n                )\n            )\n        if not c.is_locally_eligible:\n            raise exceptions.ReauthFailError(\n                \"Challenge {0} is not locally eligible\".format(\n                    challenge[\"challengeType\"]\n                )\n            )\n        client_input = c.obtain_challenge_input(challenge)\n        if not client_input:\n            return None\n        return _send_challenge_result(\n            request,\n            msg[\"sessionId\"],\n            challenge[\"challengeId\"],\n            client_input,\n            access_token,\n        )\n    return None\n\n\ndef _obtain_rapt(request, access_token, requested_scopes):\n    \"\"\"Given an http request method and reauth access token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        access_token (str): reauth access token\n        requested_scopes (Sequence[str]): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed\n    \"\"\"\n    msg = _get_challenges(\n        request,\n        list(challenges.AVAILABLE_CHALLENGES.keys()),\n        access_token,\n        requested_scopes,\n    )\n\n    if msg[\"status\"] == _AUTHENTICATED:\n        return msg[\"encodedProofOfReauthToken\"]\n\n    for _ in range(0, RUN_CHALLENGE_RETRY_LIMIT):\n        if not (\n            msg[\"status\"] == _CHALLENGE_REQUIRED or msg[\"status\"] == _CHALLENGE_PENDING\n        ):\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge failed due to API error: {}\".format(\n                    msg[\"status\"]\n                )\n            )\n\n        if not is_interactive():\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge could not be answered because you are not\"\n                \" in an interactive session.\"\n            )\n\n        msg = _run_next_challenge(msg, request, access_token)\n\n        if not msg:\n            raise exceptions.ReauthFailError(\"Failed to obtain rapt token.\")\n        if msg[\"status\"] == _AUTHENTICATED:\n            return msg[\"encodedProofOfReauthToken\"]\n\n    # If we got here it means we didn't get authenticated.\n    raise exceptions.ReauthFailError(\"Failed to obtain rapt token.\")\n\n\ndef get_rapt_token(\n    request, client_id, client_secret, refresh_token, token_uri, scopes=None\n):\n    \"\"\"Given an http request method and refresh_token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        client_id (str): client id to get access token for reauth scope.\n        client_secret (str): client secret for the client_id\n        refresh_token (str): refresh token to refresh access token\n        token_uri (str): uri to refresh access token\n        scopes (Optional(Sequence[str])): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n    Raises:\n        google.auth.exceptions.RefreshError: If reauth failed.\n    \"\"\"\n    sys.stderr.write(\"Reauthentication required.\\n\")\n\n    # Get access token for reauth.\n    access_token, _, _, _ = _client.refresh_grant(\n        request=request,\n        client_id=client_id,\n        client_secret=client_secret,\n        refresh_token=refresh_token,\n        token_uri=token_uri,\n        scopes=[_REAUTH_SCOPE],\n    )\n\n    # Get rapt token from reauth API.\n    rapt_token = _obtain_rapt(request, access_token, requested_scopes=scopes)\n    sys.stderr.write(\"Reauthentication successful.\\n\")\n\n    return rapt_token\n\n\ndef refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    enable_reauth_refresh=False,\n):\n    \"\"\"Implements the reauthentication flow.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The rapt token for reauth.\n        enable_reauth_refresh (Optional[bool]): Whether reauth refresh flow\n            should be used. The default value is False. This option is for\n            gcloud only, other users should use the default value.\n\n    Returns:\n        Tuple[str, Optional[str], Optional[datetime], Mapping[str, str], str]: The\n            access token, new refresh token, expiration, the additional data\n            returned by the token endpoint, and the rapt token.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\n        \"grant_type\": _client._REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n    metrics_header = {metrics.API_CLIENT_HEADER: metrics.token_request_user()}\n\n    response_status_ok, response_data, retryable_error = _client._token_endpoint_request_no_throw(\n        request, token_uri, body, headers=metrics_header\n    )\n\n    if not response_status_ok and isinstance(response_data, str):\n        raise exceptions.RefreshError(response_data, retryable=False)\n\n    if (\n        not response_status_ok\n        and response_data.get(\"error\") == _REAUTH_NEEDED_ERROR\n        and (\n            response_data.get(\"error_subtype\") == _REAUTH_NEEDED_ERROR_INVALID_RAPT\n            or response_data.get(\"error_subtype\") == _REAUTH_NEEDED_ERROR_RAPT_REQUIRED\n        )\n    ):\n        if not enable_reauth_refresh:\n            raise exceptions.RefreshError(\n                \"Reauthentication is needed. Please run `gcloud auth application-default login` to reauthenticate.\"\n            )\n\n        rapt_token = get_rapt_token(\n            request, client_id, client_secret, refresh_token, token_uri, scopes=scopes\n        )\n        body[\"rapt\"] = rapt_token\n        (\n            response_status_ok,\n            response_data,\n            retryable_error,\n        ) = _client._token_endpoint_request_no_throw(\n            request, token_uri, body, headers=metrics_header\n        )\n\n    if not response_status_ok:\n        _client._handle_error_response(response_data, retryable_error)\n    return _client._handle_refresh_grant_response(response_data, refresh_token) + (\n        rapt_token,\n    )\n", "google/oauth2/gdch_credentials.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Experimental GDCH credentials support.\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import _service_account_info\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.oauth2 import _client\n\n\nTOKEN_EXCHANGE_TYPE = \"urn:ietf:params:oauth:token-type:token-exchange\"\nACCESS_TOKEN_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\nSERVICE_ACCOUNT_TOKEN_TYPE = \"urn:k8s:params:oauth:token-type:serviceaccount\"\nJWT_LIFETIME = datetime.timedelta(seconds=3600)  # 1 hour\n\n\nclass ServiceAccountCredentials(credentials.Credentials):\n    \"\"\"Credentials for GDCH (`Google Distributed Cloud Hosted`_) for service\n    account users.\n\n    .. _Google Distributed Cloud Hosted:\n        https://cloud.google.com/blog/topics/hybrid-cloud/\\\n            announcing-google-distributed-cloud-edge-and-hosted\n\n    To create a GDCH service account credential, first create a JSON file of\n    the following format::\n\n        {\n            \"type\": \"gdch_service_account\",\n            \"format_version\": \"1\",\n            \"project\": \"<project name>\",\n            \"private_key_id\": \"<key id>\",\n            \"private_key\": \"-----BEGIN EC PRIVATE KEY-----\\n<key bytes>\\n-----END EC PRIVATE KEY-----\\n\",\n            \"name\": \"<service identity name>\",\n            \"ca_cert_path\": \"<CA cert path>\",\n            \"token_uri\": \"https://service-identity.<Domain>/authenticate\"\n        }\n\n    The \"format_version\" field stands for the format of the JSON file. For now\n    it is always \"1\". The `private_key_id` and `private_key` is used for signing.\n    The `ca_cert_path` is used for token server TLS certificate verification.\n\n    After the JSON file is created, set `GOOGLE_APPLICATION_CREDENTIALS` environment\n    variable to the JSON file path, then use the following code to create the\n    credential::\n\n        import google.auth\n\n        credential, _ = google.auth.default()\n        credential = credential.with_gdch_audience(\"<the audience>\")\n\n    We can also create the credential directly::\n\n        from google.oauth import gdch_credentials\n\n        credential = gdch_credentials.ServiceAccountCredentials.from_service_account_file(\"<the json file path>\")\n        credential = credential.with_gdch_audience(\"<the audience>\")\n\n    The token is obtained in the following way. This class first creates a\n    self signed JWT. It uses the `name` value as the `iss` and `sub` claim, and\n    the `token_uri` as the `aud` claim, and signs the JWT with the `private_key`.\n    It then sends the JWT to the `token_uri` to exchange a final token for\n    `audience`.\n    \"\"\"\n\n    def __init__(\n        self, signer, service_identity_name, project, audience, token_uri, ca_cert_path\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            service_identity_name (str): The service identity name. It will be\n                used as the `iss` and `sub` claim in the self signed JWT.\n            project (str): The project.\n            audience (str): The audience for the final token.\n            token_uri (str): The token server uri.\n            ca_cert_path (str): The CA cert path for token server side TLS\n                certificate verification. If the token server uses well known\n                CA, then this parameter can be `None`.\n        \"\"\"\n        super(ServiceAccountCredentials, self).__init__()\n        self._signer = signer\n        self._service_identity_name = service_identity_name\n        self._project = project\n        self._audience = audience\n        self._token_uri = token_uri\n        self._ca_cert_path = ca_cert_path\n\n    def _create_jwt(self):\n        now = _helpers.utcnow()\n        expiry = now + JWT_LIFETIME\n        iss_sub_value = \"system:serviceaccount:{}:{}\".format(\n            self._project, self._service_identity_name\n        )\n\n        payload = {\n            \"iss\": iss_sub_value,\n            \"sub\": iss_sub_value,\n            \"aud\": self._token_uri,\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n        }\n\n        return _helpers.from_bytes(jwt.encode(self._signer, payload))\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        import google.auth.transport.requests\n\n        if not isinstance(request, google.auth.transport.requests.Request):\n            raise exceptions.RefreshError(\n                \"For GDCH service account credentials, request must be a google.auth.transport.requests.Request object\"\n            )\n\n        # Create a self signed JWT, and do token exchange.\n        jwt_token = self._create_jwt()\n        request_body = {\n            \"grant_type\": TOKEN_EXCHANGE_TYPE,\n            \"audience\": self._audience,\n            \"requested_token_type\": ACCESS_TOKEN_TOKEN_TYPE,\n            \"subject_token\": jwt_token,\n            \"subject_token_type\": SERVICE_ACCOUNT_TOKEN_TYPE,\n        }\n        response_data = _client._token_endpoint_request(\n            request,\n            self._token_uri,\n            request_body,\n            access_token=None,\n            use_json=True,\n            verify=self._ca_cert_path,\n        )\n\n        self.token, _, self.expiry, _ = _client._handle_refresh_grant_response(\n            response_data, None\n        )\n\n    def with_gdch_audience(self, audience):\n        \"\"\"Create a copy of GDCH credentials with the specified audience.\n\n        Args:\n            audience (str): The intended audience for GDCH credentials.\n        \"\"\"\n        return self.__class__(\n            self._signer,\n            self._service_identity_name,\n            self._project,\n            audience,\n            self._token_uri,\n            self._ca_cert_path,\n        )\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info):\n        \"\"\"Creates a Credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n\n        Returns:\n            google.oauth2.gdch_credentials.ServiceAccountCredentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        if info[\"format_version\"] != \"1\":\n            raise ValueError(\"Only format version 1 is supported\")\n\n        return cls(\n            signer,\n            info[\"name\"],  # service_identity_name\n            info[\"project\"],\n            None,  # audience\n            info[\"token_uri\"],\n            info.get(\"ca_cert_path\", None),\n        )\n\n    @classmethod\n    def from_service_account_info(cls, info):\n        \"\"\"Creates a Credentials instance from parsed service account info.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.oauth2.gdch_credentials.ServiceAccountCredentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(\n            info,\n            require=[\n                \"format_version\",\n                \"private_key_id\",\n                \"private_key\",\n                \"name\",\n                \"project\",\n                \"token_uri\",\n            ],\n            use_rsa_signer=False,\n        )\n        return cls._from_signer_and_info(signer, info)\n\n    @classmethod\n    def from_service_account_file(cls, filename):\n        \"\"\"Creates a Credentials instance from a service account json file.\n\n        Args:\n            filename (str): The path to the service account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.oauth2.gdch_credentials.ServiceAccountCredentials: The constructed\n                credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename,\n            require=[\n                \"format_version\",\n                \"private_key_id\",\n                \"private_key\",\n                \"name\",\n                \"project\",\n                \"token_uri\",\n            ],\n            use_rsa_signer=False,\n        )\n        return cls._from_signer_and_info(signer, info)\n", "google/oauth2/credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 Credentials.\n\nThis module provides credentials based on OAuth 2.0 access and refresh tokens.\nThese credentials usually access resources on behalf of a user (resource\nowner).\n\nSpecifically, this is intended to use access tokens acquired using the\n`Authorization Code grant`_ and can refresh those tokens using a\noptional `refresh token`_.\n\nObtaining the initial access and refresh token is outside of the scope of this\nmodule. Consult `rfc6749 section 4.1`_ for complete details on the\nAuthorization Code grant flow.\n\n.. _Authorization Code grant: https://tools.ietf.org/html/rfc6749#section-1.3.1\n.. _refresh token: https://tools.ietf.org/html/rfc6749#section-6\n.. _rfc6749 section 4.1: https://tools.ietf.org/html/rfc6749#section-4.1\n\"\"\"\n\nfrom datetime import datetime\nimport io\nimport json\nimport logging\nimport warnings\n\nfrom google.auth import _cloud_sdk\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import metrics\nfrom google.oauth2 import reauth\n\n_LOGGER = logging.getLogger(__name__)\n\n\n# The Google OAuth 2.0 token endpoint. Used for authorized user credentials.\n_GOOGLE_OAUTH2_TOKEN_ENDPOINT = \"https://oauth2.googleapis.com/token\"\n\n\nclass Credentials(credentials.ReadOnlyScoped, credentials.CredentialsWithQuotaProject):\n    \"\"\"Credentials using OAuth 2.0 access and refresh tokens.\n\n    The credentials are considered immutable except the tokens and the token\n    expiry, which are updated after refresh. If you want to modify the quota\n    project, use :meth:`with_quota_project` or ::\n\n        credentials = credentials.with_quota_project('myproject-123')\n\n    Reauth is disabled by default. To enable reauth, set the\n    `enable_reauth_refresh` parameter to True in the constructor. Note that\n    reauth feature is intended for gcloud to use only.\n    If reauth is enabled, `pyu2f` dependency has to be installed in order to use security\n    key reauth feature. Dependency can be installed via `pip install pyu2f` or `pip install\n    google-auth[reauth]`.\n    \"\"\"\n\n    def __init__(\n        self,\n        token,\n        refresh_token=None,\n        id_token=None,\n        token_uri=None,\n        client_id=None,\n        client_secret=None,\n        scopes=None,\n        default_scopes=None,\n        quota_project_id=None,\n        expiry=None,\n        rapt_token=None,\n        refresh_handler=None,\n        enable_reauth_refresh=False,\n        granted_scopes=None,\n        trust_boundary=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n        account=None,\n    ):\n        \"\"\"\n        Args:\n            token (Optional(str)): The OAuth 2.0 access token. Can be None\n                if refresh information is provided.\n            refresh_token (str): The OAuth 2.0 refresh token. If specified,\n                credentials can be refreshed.\n            id_token (str): The Open ID Connect ID Token.\n            token_uri (str): The OAuth 2.0 authorization server's token\n                endpoint URI. Must be specified for refresh, can be left as\n                None if the token can not be refreshed.\n            client_id (str): The OAuth 2.0 client ID. Must be specified for\n                refresh, can be left as None if the token can not be refreshed.\n            client_secret(str): The OAuth 2.0 client secret. Must be specified\n                for refresh, can be left as None if the token can not be\n                refreshed.\n            scopes (Sequence[str]): The scopes used to obtain authorization.\n                This parameter is used by :meth:`has_scopes`. OAuth 2.0\n                credentials can not request additional scopes after\n                authorization. The scopes must be derivable from the refresh\n                token if refresh information is provided (e.g. The refresh\n                token scopes are a superset of this or contain a wild card\n                scope like 'https://www.googleapis.com/auth/any-api').\n            default_scopes (Sequence[str]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            quota_project_id (Optional[str]): The project ID used for quota and billing.\n                This project may be different from the project used to\n                create the credentials.\n            rapt_token (Optional[str]): The reauth Proof Token.\n            refresh_handler (Optional[Callable[[google.auth.transport.Request, Sequence[str]], [str, datetime]]]):\n                A callable which takes in the HTTP request callable and the list of\n                OAuth scopes and when called returns an access token string for the\n                requested scopes and its expiry datetime. This is useful when no\n                refresh tokens are provided and tokens are obtained by calling\n                some external process on demand. It is particularly useful for\n                retrieving downscoped tokens from a token broker.\n            enable_reauth_refresh (Optional[bool]): Whether reauth refresh flow\n                should be used. This flag is for gcloud to use only.\n            granted_scopes (Optional[Sequence[str]]): The scopes that were consented/granted by the user.\n                This could be different from the requested scopes and it could be empty if granted\n                and requested scopes were same.\n            trust_boundary (str): String representation of trust boundary meta.\n            universe_domain (Optional[str]): The universe domain. The default\n                universe domain is googleapis.com.\n            account (Optional[str]): The account associated with the credential.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self.token = token\n        self.expiry = expiry\n        self._refresh_token = refresh_token\n        self._id_token = id_token\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._granted_scopes = granted_scopes\n        self._token_uri = token_uri\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._quota_project_id = quota_project_id\n        self._rapt_token = rapt_token\n        self.refresh_handler = refresh_handler\n        self._enable_reauth_refresh = enable_reauth_refresh\n        self._trust_boundary = trust_boundary\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n        self._account = account or \"\"\n\n    def __getstate__(self):\n        \"\"\"A __getstate__ method must exist for the __setstate__ to be called\n        This is identical to the default implementation.\n        See https://docs.python.org/3.7/library/pickle.html#object.__setstate__\n        \"\"\"\n        state_dict = self.__dict__.copy()\n        # Remove _refresh_handler function as there are limitations pickling and\n        # unpickling certain callables (lambda, functools.partial instances)\n        # because they need to be importable.\n        # Instead, the refresh_handler setter should be used to repopulate this.\n        if \"_refresh_handler\" in state_dict:\n            del state_dict[\"_refresh_handler\"]\n\n        if \"_refresh_worker\" in state_dict:\n            del state_dict[\"_refresh_worker\"]\n        return state_dict\n\n    def __setstate__(self, d):\n        \"\"\"Credentials pickled with older versions of the class do not have\n        all the attributes.\"\"\"\n        self.token = d.get(\"token\")\n        self.expiry = d.get(\"expiry\")\n        self._refresh_token = d.get(\"_refresh_token\")\n        self._id_token = d.get(\"_id_token\")\n        self._scopes = d.get(\"_scopes\")\n        self._default_scopes = d.get(\"_default_scopes\")\n        self._granted_scopes = d.get(\"_granted_scopes\")\n        self._token_uri = d.get(\"_token_uri\")\n        self._client_id = d.get(\"_client_id\")\n        self._client_secret = d.get(\"_client_secret\")\n        self._quota_project_id = d.get(\"_quota_project_id\")\n        self._rapt_token = d.get(\"_rapt_token\")\n        self._enable_reauth_refresh = d.get(\"_enable_reauth_refresh\")\n        self._trust_boundary = d.get(\"_trust_boundary\")\n        self._universe_domain = (\n            d.get(\"_universe_domain\") or credentials.DEFAULT_UNIVERSE_DOMAIN\n        )\n        # The refresh_handler setter should be used to repopulate this.\n        self._refresh_handler = None\n        self._refresh_worker = None\n        self._use_non_blocking_refresh = d.get(\"_use_non_blocking_refresh\", False)\n        self._account = d.get(\"_account\", \"\")\n\n    @property\n    def refresh_token(self):\n        \"\"\"Optional[str]: The OAuth 2.0 refresh token.\"\"\"\n        return self._refresh_token\n\n    @property\n    def scopes(self):\n        \"\"\"Optional[str]: The OAuth 2.0 permission scopes.\"\"\"\n        return self._scopes\n\n    @property\n    def granted_scopes(self):\n        \"\"\"Optional[Sequence[str]]: The OAuth 2.0 permission scopes that were granted by the user.\"\"\"\n        return self._granted_scopes\n\n    @property\n    def token_uri(self):\n        \"\"\"Optional[str]: The OAuth 2.0 authorization server's token endpoint\n        URI.\"\"\"\n        return self._token_uri\n\n    @property\n    def id_token(self):\n        \"\"\"Optional[str]: The Open ID Connect ID Token.\n\n        Depending on the authorization server and the scopes requested, this\n        may be populated when credentials are obtained and updated when\n        :meth:`refresh` is called. This token is a JWT. It can be verified\n        and decoded using :func:`google.oauth2.id_token.verify_oauth2_token`.\n        \"\"\"\n        return self._id_token\n\n    @property\n    def client_id(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client ID.\"\"\"\n        return self._client_id\n\n    @property\n    def client_secret(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client secret.\"\"\"\n        return self._client_secret\n\n    @property\n    def requires_scopes(self):\n        \"\"\"False: OAuth 2.0 credentials have their scopes set when\n        the initial token is requested and can not be changed.\"\"\"\n        return False\n\n    @property\n    def rapt_token(self):\n        \"\"\"Optional[str]: The reauth Proof Token.\"\"\"\n        return self._rapt_token\n\n    @property\n    def refresh_handler(self):\n        \"\"\"Returns the refresh handler if available.\n\n        Returns:\n           Optional[Callable[[google.auth.transport.Request, Sequence[str]], [str, datetime]]]:\n               The current refresh handler.\n        \"\"\"\n        return self._refresh_handler\n\n    @refresh_handler.setter\n    def refresh_handler(self, value):\n        \"\"\"Updates the current refresh handler.\n\n        Args:\n            value (Optional[Callable[[google.auth.transport.Request, Sequence[str]], [str, datetime]]]):\n                The updated value of the refresh handler.\n\n        Raises:\n            TypeError: If the value is not a callable or None.\n        \"\"\"\n        if not callable(value) and value is not None:\n            raise TypeError(\"The provided refresh_handler is not a callable or None.\")\n        self._refresh_handler = value\n\n    @property\n    def account(self):\n        \"\"\"str: The user account associated with the credential. If the account is unknown an empty string is returned.\"\"\"\n        return self._account\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=self.token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=self._universe_domain,\n            account=self._account,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=self.quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=self._universe_domain,\n            account=self._account,\n        )\n\n    def with_account(self, account):\n        \"\"\"Returns a copy of these credentials with a modified account.\n\n        Args:\n            account (str): The account to set\n\n        Returns:\n            google.oauth2.credentials.Credentials: A new credentials instance.\n        \"\"\"\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=self._token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=self.quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=self._universe_domain,\n            account=account,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n\n        return self.__class__(\n            self.token,\n            refresh_token=self.refresh_token,\n            id_token=self.id_token,\n            token_uri=self._token_uri,\n            client_id=self.client_id,\n            client_secret=self.client_secret,\n            scopes=self.scopes,\n            default_scopes=self.default_scopes,\n            granted_scopes=self.granted_scopes,\n            quota_project_id=self.quota_project_id,\n            rapt_token=self.rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n            trust_boundary=self._trust_boundary,\n            universe_domain=universe_domain,\n            account=self._account,\n        )\n\n    def _metric_header_for_usage(self):\n        return metrics.CRED_TYPE_USER\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        if self._universe_domain != credentials.DEFAULT_UNIVERSE_DOMAIN:\n            raise exceptions.RefreshError(\n                \"User credential refresh is only supported in the default \"\n                \"googleapis.com universe domain, but the current universe \"\n                \"domain is {}. If you created the credential with an access \"\n                \"token, it's likely that the provided token is expired now, \"\n                \"please update your code with a valid token.\".format(\n                    self._universe_domain\n                )\n            )\n\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # Use refresh handler if available and no refresh token is\n        # available. This is useful in general when tokens are obtained by calling\n        # some external process on demand. It is particularly useful for retrieving\n        # downscoped tokens from a token broker.\n        if self._refresh_token is None and self.refresh_handler:\n            token, expiry = self.refresh_handler(request, scopes=scopes)\n            # Validate returned data.\n            if not isinstance(token, str):\n                raise exceptions.RefreshError(\n                    \"The refresh_handler returned token is not a string.\"\n                )\n            if not isinstance(expiry, datetime):\n                raise exceptions.RefreshError(\n                    \"The refresh_handler returned expiry is not a datetime object.\"\n                )\n            if _helpers.utcnow() >= expiry - _helpers.REFRESH_THRESHOLD:\n                raise exceptions.RefreshError(\n                    \"The credentials returned by the refresh_handler are \"\n                    \"already expired.\"\n                )\n            self.token = token\n            self.expiry = expiry\n            return\n\n        if (\n            self._refresh_token is None\n            or self._token_uri is None\n            or self._client_id is None\n            or self._client_secret is None\n        ):\n            raise exceptions.RefreshError(\n                \"The credentials do not contain the necessary fields need to \"\n                \"refresh the access token. You must specify refresh_token, \"\n                \"token_uri, client_id, and client_secret.\"\n            )\n\n        (\n            access_token,\n            refresh_token,\n            expiry,\n            grant_response,\n            rapt_token,\n        ) = reauth.refresh_grant(\n            request,\n            self._token_uri,\n            self._refresh_token,\n            self._client_id,\n            self._client_secret,\n            scopes=scopes,\n            rapt_token=self._rapt_token,\n            enable_reauth_refresh=self._enable_reauth_refresh,\n        )\n\n        self.token = access_token\n        self.expiry = expiry\n        self._refresh_token = refresh_token\n        self._id_token = grant_response.get(\"id_token\")\n        self._rapt_token = rapt_token\n\n        if scopes and \"scope\" in grant_response:\n            requested_scopes = frozenset(scopes)\n            self._granted_scopes = grant_response[\"scope\"].split()\n            granted_scopes = frozenset(self._granted_scopes)\n            scopes_requested_but_not_granted = requested_scopes - granted_scopes\n            if scopes_requested_but_not_granted:\n                # User might be presented with unbundled scopes at the time of\n                # consent. So it is a valid scenario to not have all the requested\n                # scopes as part of granted scopes but log a warning in case the\n                # developer wants to debug the scenario.\n                _LOGGER.warning(\n                    \"Not all requested scopes were granted by the \"\n                    \"authorization server, missing scopes {}.\".format(\n                        \", \".join(scopes_requested_but_not_granted)\n                    )\n                )\n\n    @classmethod\n    def from_authorized_user_info(cls, info, scopes=None):\n        \"\"\"Creates a Credentials instance from parsed authorized user info.\n\n        Args:\n            info (Mapping[str, str]): The authorized user info in Google\n                format.\n            scopes (Sequence[str]): Optional list of scopes to include in the\n                credentials.\n\n        Returns:\n            google.oauth2.credentials.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        keys_needed = set((\"refresh_token\", \"client_id\", \"client_secret\"))\n        missing = keys_needed.difference(info.keys())\n\n        if missing:\n            raise ValueError(\n                \"Authorized user info was not in the expected format, missing \"\n                \"fields {}.\".format(\", \".join(missing))\n            )\n\n        # access token expiry (datetime obj); auto-expire if not saved\n        expiry = info.get(\"expiry\")\n        if expiry:\n            expiry = datetime.strptime(\n                expiry.rstrip(\"Z\").split(\".\")[0], \"%Y-%m-%dT%H:%M:%S\"\n            )\n        else:\n            expiry = _helpers.utcnow() - _helpers.REFRESH_THRESHOLD\n\n        # process scopes, which needs to be a seq\n        if scopes is None and \"scopes\" in info:\n            scopes = info.get(\"scopes\")\n            if isinstance(scopes, str):\n                scopes = scopes.split(\" \")\n\n        return cls(\n            token=info.get(\"token\"),\n            refresh_token=info.get(\"refresh_token\"),\n            token_uri=_GOOGLE_OAUTH2_TOKEN_ENDPOINT,  # always overrides\n            scopes=scopes,\n            client_id=info.get(\"client_id\"),\n            client_secret=info.get(\"client_secret\"),\n            quota_project_id=info.get(\"quota_project_id\"),  # may not exist\n            expiry=expiry,\n            rapt_token=info.get(\"rapt_token\"),  # may not exist\n            trust_boundary=info.get(\"trust_boundary\"),  # may not exist\n            universe_domain=info.get(\"universe_domain\"),  # may not exist\n            account=info.get(\"account\", \"\"),  # may not exist\n        )\n\n    @classmethod\n    def from_authorized_user_file(cls, filename, scopes=None):\n        \"\"\"Creates a Credentials instance from an authorized user json file.\n\n        Args:\n            filename (str): The path to the authorized user json file.\n            scopes (Sequence[str]): Optional list of scopes to include in the\n                credentials.\n\n        Returns:\n            google.oauth2.credentials.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: If the file is not in the expected format.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n            return cls.from_authorized_user_info(data, scopes)\n\n    def to_json(self, strip=None):\n        \"\"\"Utility function that creates a JSON representation of a Credentials\n        object.\n\n        Args:\n            strip (Sequence[str]): Optional list of members to exclude from the\n                                   generated JSON.\n\n        Returns:\n            str: A JSON representation of this instance. When converted into\n            a dictionary, it can be passed to from_authorized_user_info()\n            to create a new credential instance.\n        \"\"\"\n        prep = {\n            \"token\": self.token,\n            \"refresh_token\": self.refresh_token,\n            \"token_uri\": self.token_uri,\n            \"client_id\": self.client_id,\n            \"client_secret\": self.client_secret,\n            \"scopes\": self.scopes,\n            \"rapt_token\": self.rapt_token,\n            \"universe_domain\": self._universe_domain,\n            \"account\": self._account,\n        }\n        if self.expiry:  # flatten expiry timestamp\n            prep[\"expiry\"] = self.expiry.isoformat() + \"Z\"\n\n        # Remove empty entries (those which are None)\n        prep = {k: v for k, v in prep.items() if v is not None}\n\n        # Remove entries that explicitely need to be removed\n        if strip is not None:\n            prep = {k: v for k, v in prep.items() if k not in strip}\n\n        return json.dumps(prep)\n\n\nclass UserAccessTokenCredentials(credentials.CredentialsWithQuotaProject):\n    \"\"\"Access token credentials for user account.\n\n    Obtain the access token for a given user account or the current active\n    user account with the ``gcloud auth print-access-token`` command.\n\n    Args:\n        account (Optional[str]): Account to get the access token for. If not\n            specified, the current active account will be used.\n        quota_project_id (Optional[str]): The project ID used for quota\n            and billing.\n    \"\"\"\n\n    def __init__(self, account=None, quota_project_id=None):\n        warnings.warn(\n            \"UserAccessTokenCredentials is deprecated, please use \"\n            \"google.oauth2.credentials.Credentials instead. To use \"\n            \"that credential type, simply run \"\n            \"`gcloud auth application-default login` and let the \"\n            \"client libraries pick up the application default credentials.\"\n        )\n        super(UserAccessTokenCredentials, self).__init__()\n        self._account = account\n        self._quota_project_id = quota_project_id\n\n    def with_account(self, account):\n        \"\"\"Create a new instance with the given account.\n\n        Args:\n            account (str): Account to get the access token for.\n\n        Returns:\n            google.oauth2.credentials.UserAccessTokenCredentials: The created\n                credentials with the given account.\n        \"\"\"\n        return self.__class__(account=account, quota_project_id=self._quota_project_id)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(account=self._account, quota_project_id=quota_project_id)\n\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (google.auth.transport.Request): This argument is required\n                by the base class interface but not used in this implementation,\n                so just set it to `None`.\n\n        Raises:\n            google.auth.exceptions.UserAccessTokenError: If the access token\n                refresh failed.\n        \"\"\"\n        self.token = _cloud_sdk.get_auth_access_token(self._account)\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def before_request(self, request, method, url, headers):\n        self.refresh(request)\n        self.apply(headers)\n", "google/oauth2/_client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 client.\n\nThis is a client for interacting with an OAuth 2.0 authorization server's\ntoken endpoint.\n\nFor more information about the token endpoint, see\n`Section 3.1 of rfc6749`_\n\n.. _Section 3.1 of rfc6749: https://tools.ietf.org/html/rfc6749#section-3.2\n\"\"\"\n\nimport datetime\nimport http.client as http_client\nimport json\nimport urllib\n\nfrom google.auth import _exponential_backoff\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.auth import metrics\nfrom google.auth import transport\n\n_URLENCODED_CONTENT_TYPE = \"application/x-www-form-urlencoded\"\n_JSON_CONTENT_TYPE = \"application/json\"\n_JWT_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:jwt-bearer\"\n_REFRESH_GRANT_TYPE = \"refresh_token\"\n\n\ndef _handle_error_response(response_data, retryable_error):\n    \"\"\"Translates an error response into an exception.\n\n    Args:\n        response_data (Mapping | str): The decoded response data.\n        retryable_error Optional[bool]: A boolean indicating if an error is retryable.\n            Defaults to False.\n\n    Raises:\n        google.auth.exceptions.RefreshError: The errors contained in response_data.\n    \"\"\"\n\n    retryable_error = retryable_error if retryable_error else False\n\n    if isinstance(response_data, str):\n        raise exceptions.RefreshError(response_data, retryable=retryable_error)\n    try:\n        error_details = \"{}: {}\".format(\n            response_data[\"error\"], response_data.get(\"error_description\")\n        )\n    # If no details could be extracted, use the response data.\n    except (KeyError, ValueError):\n        error_details = json.dumps(response_data)\n\n    raise exceptions.RefreshError(\n        error_details, response_data, retryable=retryable_error\n    )\n\n\ndef _can_retry(status_code, response_data):\n    \"\"\"Checks if a request can be retried by inspecting the status code\n    and response body of the request.\n\n    Args:\n        status_code (int): The response status code.\n        response_data (Mapping | str): The decoded response data.\n\n    Returns:\n      bool: True if the response is retryable. False otherwise.\n    \"\"\"\n    if status_code in transport.DEFAULT_RETRYABLE_STATUS_CODES:\n        return True\n\n    try:\n        # For a failed response, response_body could be a string\n        error_desc = response_data.get(\"error_description\") or \"\"\n        error_code = response_data.get(\"error\") or \"\"\n\n        if not isinstance(error_code, str) or not isinstance(error_desc, str):\n            return False\n\n        # Per Oauth 2.0 RFC https://www.rfc-editor.org/rfc/rfc6749.html#section-4.1.2.1\n        # This is needed because a redirect will not return a 500 status code.\n        retryable_error_descriptions = {\n            \"internal_failure\",\n            \"server_error\",\n            \"temporarily_unavailable\",\n        }\n\n        if any(e in retryable_error_descriptions for e in (error_code, error_desc)):\n            return True\n\n    except AttributeError:\n        pass\n\n    return False\n\n\ndef _parse_expiry(response_data):\n    \"\"\"Parses the expiry field from a response into a datetime.\n\n    Args:\n        response_data (Mapping): The JSON-parsed response data.\n\n    Returns:\n        Optional[datetime]: The expiration or ``None`` if no expiration was\n            specified.\n    \"\"\"\n    expires_in = response_data.get(\"expires_in\", None)\n\n    if expires_in is not None:\n        # Some services do not respect the OAUTH2.0 RFC and send expires_in as a\n        # JSON String.\n        if isinstance(expires_in, str):\n            expires_in = int(expires_in)\n\n        return _helpers.utcnow() + datetime.timedelta(seconds=expires_in)\n    else:\n        return None\n\n\ndef _token_endpoint_request_no_throw(\n    request,\n    token_uri,\n    body,\n    access_token=None,\n    use_json=False,\n    can_retry=True,\n    headers=None,\n    **kwargs\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n    This function doesn't throw on response errors.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n        headers (Optional[Mapping[str, str]]): The headers for the request.\n        kwargs: Additional arguments passed on to the request method. The\n            kwargs will be passed to `requests.request` method, see:\n            https://docs.python-requests.org/en/latest/api/#requests.request.\n            For example, you can use `cert=(\"cert_pem_path\", \"key_pem_path\")`\n            to set up client side SSL certificate, and use\n            `verify=\"ca_bundle_path\"` to set up the CA certificates for sever\n            side SSL certificate verification.\n\n    Returns:\n        Tuple(bool, Mapping[str, str], Optional[bool]): A boolean indicating\n          if the request is successful, a mapping for the JSON-decoded response\n          data and in the case of an error a boolean indicating if the error\n          is retryable.\n    \"\"\"\n    if use_json:\n        headers_to_use = {\"Content-Type\": _JSON_CONTENT_TYPE}\n        body = json.dumps(body).encode(\"utf-8\")\n    else:\n        headers_to_use = {\"Content-Type\": _URLENCODED_CONTENT_TYPE}\n        body = urllib.parse.urlencode(body).encode(\"utf-8\")\n\n    if access_token:\n        headers_to_use[\"Authorization\"] = \"Bearer {}\".format(access_token)\n\n    if headers:\n        headers_to_use.update(headers)\n\n    def _perform_request():\n        response = request(\n            method=\"POST\", url=token_uri, headers=headers_to_use, body=body, **kwargs\n        )\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n        response_data = \"\"\n        try:\n            # response_body should be a JSON\n            response_data = json.loads(response_body)\n        except ValueError:\n            response_data = response_body\n\n        if response.status == http_client.OK:\n            return True, response_data, None\n\n        retryable_error = _can_retry(\n            status_code=response.status, response_data=response_data\n        )\n\n        return False, response_data, retryable_error\n\n    request_succeeded, response_data, retryable_error = _perform_request()\n\n    if request_succeeded or not retryable_error or not can_retry:\n        return request_succeeded, response_data, retryable_error\n\n    retries = _exponential_backoff.ExponentialBackoff()\n    for _ in retries:\n        request_succeeded, response_data, retryable_error = _perform_request()\n        if request_succeeded or not retryable_error:\n            return request_succeeded, response_data, retryable_error\n\n    return False, response_data, retryable_error\n\n\ndef _token_endpoint_request(\n    request,\n    token_uri,\n    body,\n    access_token=None,\n    use_json=False,\n    can_retry=True,\n    headers=None,\n    **kwargs\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n        headers (Optional[Mapping[str, str]]): The headers for the request.\n        kwargs: Additional arguments passed on to the request method. The\n            kwargs will be passed to `requests.request` method, see:\n            https://docs.python-requests.org/en/latest/api/#requests.request.\n            For example, you can use `cert=(\"cert_pem_path\", \"key_pem_path\")`\n            to set up client side SSL certificate, and use\n            `verify=\"ca_bundle_path\"` to set up the CA certificates for sever\n            side SSL certificate verification.\n\n    Returns:\n        Mapping[str, str]: The JSON-decoded response data.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n\n    response_status_ok, response_data, retryable_error = _token_endpoint_request_no_throw(\n        request,\n        token_uri,\n        body,\n        access_token=access_token,\n        use_json=use_json,\n        can_retry=can_retry,\n        headers=headers,\n        **kwargs\n    )\n    if not response_status_ok:\n        _handle_error_response(response_data, retryable_error)\n    return response_data\n\n\ndef jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants.\n\n    For more details, see `rfc7523 section 4`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        assertion (str): The OAuth 2.0 assertion.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]: The access token,\n            expiration, and additional data returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc7523 section 4: https://tools.ietf.org/html/rfc7523#section-4\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": _JWT_GRANT_TYPE}\n\n    response_data = _token_endpoint_request(\n        request,\n        token_uri,\n        body,\n        can_retry=can_retry,\n        headers={\n            metrics.API_CLIENT_HEADER: metrics.token_request_access_token_sa_assertion()\n        },\n    )\n\n    try:\n        access_token = response_data[\"access_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No access token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    expiry = _parse_expiry(response_data)\n\n    return access_token, expiry, response_data\n\n\ndef call_iam_generate_id_token_endpoint(\n    request, iam_id_token_endpoint, signer_email, audience, access_token\n):\n    \"\"\"Call iam.generateIdToken endpoint to get ID token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        iam_id_token_endpoint (str): The IAM ID token endpoint to use.\n        signer_email (str): The signer email used to form the IAM\n            generateIdToken endpoint.\n        audience (str): The audience for the ID token.\n        access_token (str): The access token used to call the IAM endpoint.\n\n    Returns:\n        Tuple[str, datetime]: The ID token and expiration.\n    \"\"\"\n    body = {\"audience\": audience, \"includeEmail\": \"true\", \"useEmailAzp\": \"true\"}\n\n    response_data = _token_endpoint_request(\n        request,\n        iam_id_token_endpoint.format(signer_email),\n        body,\n        access_token=access_token,\n        use_json=True,\n    )\n\n    try:\n        id_token = response_data[\"token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No ID token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    payload = jwt.decode(id_token, verify=False)\n    expiry = datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    return id_token, expiry\n\n\ndef id_token_jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants, but\n    requests an OpenID Connect ID Token instead of an access token.\n\n    This is a variant on the standard JWT Profile that is currently unique\n    to Google. This was added for the benefit of authenticating to services\n    that require ID Tokens instead of access tokens or JWT bearer tokens.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorization server's token endpoint\n            URI.\n        assertion (str): JWT token signed by a service account. The token's\n            payload must include a ``target_audience`` claim.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]:\n            The (encoded) Open ID Connect ID Token, expiration, and additional\n            data returned by the endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": _JWT_GRANT_TYPE}\n\n    response_data = _token_endpoint_request(\n        request,\n        token_uri,\n        body,\n        can_retry=can_retry,\n        headers={\n            metrics.API_CLIENT_HEADER: metrics.token_request_id_token_sa_assertion()\n        },\n    )\n\n    try:\n        id_token = response_data[\"id_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No ID token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    payload = jwt.decode(id_token, verify=False)\n    expiry = datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    return id_token, expiry, response_data\n\n\ndef _handle_refresh_grant_response(response_data, refresh_token):\n    \"\"\"Extract tokens from refresh grant response.\n\n    Args:\n        response_data (Mapping[str, str]): Refresh grant response data.\n        refresh_token (str): Current refresh token.\n\n    Returns:\n        Tuple[str, str, Optional[datetime], Mapping[str, str]]: The access token,\n            refresh token, expiration, and additional data returned by the token\n            endpoint. If response_data doesn't have refresh token, then the current\n            refresh token will be returned.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    try:\n        access_token = response_data[\"access_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No access token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    refresh_token = response_data.get(\"refresh_token\", refresh_token)\n    expiry = _parse_expiry(response_data)\n\n    return access_token, refresh_token, expiry, response_data\n\n\ndef refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    can_retry=True,\n):\n    \"\"\"Implements the OAuth 2.0 refresh token grant.\n\n    For more details, see `rfc678 section 6`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The reauth Proof Token.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, str, Optional[datetime], Mapping[str, str]]: The access\n            token, new or current refresh token, expiration, and additional data\n            returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc6748 section 6: https://tools.ietf.org/html/rfc6749#section-6\n    \"\"\"\n    body = {\n        \"grant_type\": _REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n\n    response_data = _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n    return _handle_refresh_grant_response(response_data, refresh_token)\n", "google/oauth2/_id_token_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google ID Token helpers.\n\nProvides support for verifying `OpenID Connect ID Tokens`_, especially ones\ngenerated by Google infrastructure.\n\nTo parse and verify an ID Token issued by Google's OAuth 2.0 authorization\nserver use :func:`verify_oauth2_token`. To verify an ID Token issued by\nFirebase, use :func:`verify_firebase_token`.\n\nA general purpose ID Token verifier is available as :func:`verify_token`.\n\nExample::\n\n    from google.oauth2 import _id_token_async\n    from google.auth.transport import aiohttp_requests\n\n    request = aiohttp_requests.Request()\n\n    id_info = await _id_token_async.verify_oauth2_token(\n        token, request, 'my-client-id.example.com')\n\n    if id_info['iss'] != 'https://accounts.google.com':\n        raise ValueError('Wrong issuer.')\n\n    userid = id_info['sub']\n\nBy default, this will re-fetch certificates for each verification. Because\nGoogle's public keys are only changed infrequently (on the order of once per\nday), you may wish to take advantage of caching to reduce latency and the\npotential for network errors. This can be accomplished using an external\nlibrary like `CacheControl`_ to create a cache-aware\n:class:`google.auth.transport.Request`::\n\n    import cachecontrol\n    import google.auth.transport.requests\n    import requests\n\n    session = requests.session()\n    cached_session = cachecontrol.CacheControl(session)\n    request = google.auth.transport.requests.Request(session=cached_session)\n\n.. _OpenID Connect ID Token:\n    http://openid.net/specs/openid-connect-core-1_0.html#IDToken\n.. _CacheControl: https://cachecontrol.readthedocs.io\n\"\"\"\n\nimport http.client as http_client\nimport json\nimport os\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.auth.transport import requests\nfrom google.oauth2 import id_token as sync_id_token\n\n\nasync def _fetch_certs(request, certs_url):\n    \"\"\"Fetches certificates.\n\n    Google-style cerificate endpoints return JSON in the format of\n    ``{'key id': 'x509 certificate'}``.\n\n    Args:\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        certs_url (str): The certificate endpoint URL.\n\n    Returns:\n        Mapping[str, str]: A mapping of public key ID to x.509 certificate\n            data.\n    \"\"\"\n    response = await request(certs_url, method=\"GET\")\n\n    if response.status != http_client.OK:\n        raise exceptions.TransportError(\n            \"Could not fetch certificates at {}\".format(certs_url)\n        )\n\n    data = await response.content()\n\n    return json.loads(data)\n\n\nasync def verify_token(\n    id_token,\n    request,\n    audience=None,\n    certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,\n    clock_skew_in_seconds=0,\n):\n    \"\"\"Verifies an ID token and returns the decoded token.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        audience (str): The audience that this token is intended for. If None\n            then the audience is not verified.\n        certs_url (str): The URL that specifies the certificates to use to\n            verify the token. This URL should return JSON in the format of\n            ``{'key id': 'x509 certificate'}``.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    certs = await _fetch_certs(request, certs_url)\n\n    return jwt.decode(\n        id_token,\n        certs=certs,\n        audience=audience,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\nasync def verify_oauth2_token(\n    id_token, request, audience=None, clock_skew_in_seconds=0\n):\n    \"\"\"Verifies an ID Token issued by Google's OAuth 2.0 authorization server.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        audience (str): The audience that this token is intended for. This is\n            typically your application's OAuth 2.0 client ID. If None then the\n            audience is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n\n    Raises:\n        exceptions.GoogleAuthError: If the issuer is invalid.\n    \"\"\"\n    idinfo = await verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=sync_id_token._GOOGLE_OAUTH2_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n    if idinfo[\"iss\"] not in sync_id_token._GOOGLE_ISSUERS:\n        raise exceptions.GoogleAuthError(\n            \"Wrong issuer. 'iss' should be one of the following: {}\".format(\n                sync_id_token._GOOGLE_ISSUERS\n            )\n        )\n\n    return idinfo\n\n\nasync def verify_firebase_token(\n    id_token, request, audience=None, clock_skew_in_seconds=0\n):\n    \"\"\"Verifies an ID Token issued by Firebase Authentication.\n\n    Args:\n        id_token (Union[str, bytes]): The encoded token.\n        request (google.auth.transport.Request): The object used to make\n            HTTP requests. This must be an aiohttp request.\n        audience (str): The audience that this token is intended for. This is\n            typically your Firebase application ID. If None then the audience\n            is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, Any]: The decoded token.\n    \"\"\"\n    return await verify_token(\n        id_token,\n        request,\n        audience=audience,\n        certs_url=sync_id_token._GOOGLE_APIS_CERTS_URL,\n        clock_skew_in_seconds=clock_skew_in_seconds,\n    )\n\n\nasync def fetch_id_token(request, audience):\n    \"\"\"Fetch the ID Token from the current environment.\n\n    This function acquires ID token from the environment in the following order.\n    See https://google.aip.dev/auth/4110.\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON file, then ID token is\n       acquired using this service account credentials.\n    2. If the application is running in Compute Engine, App Engine or Cloud Run,\n       then the ID token are obtained from the metadata server.\n    3. If metadata server doesn't exist and no valid service account credentials\n       are found, :class:`~google.auth.exceptions.DefaultCredentialsError` will\n       be raised.\n\n    Example::\n\n        import google.oauth2._id_token_async\n        import google.auth.transport.aiohttp_requests\n\n        request = google.auth.transport.aiohttp_requests.Request()\n        target_audience = \"https://pubsub.googleapis.com\"\n\n        id_token = await google.oauth2._id_token_async.fetch_id_token(request, target_audience)\n\n    Args:\n        request (google.auth.transport.aiohttp_requests.Request): A callable used to make\n            HTTP requests.\n        audience (str): The audience that this ID token is intended for.\n\n    Returns:\n        str: The ID token.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If metadata server doesn't exist and no valid service account\n            credentials are found.\n    \"\"\"\n    # 1. Try to get credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    # variable.\n    credentials_filename = os.environ.get(environment_vars.CREDENTIALS)\n    if credentials_filename:\n        if not (\n            os.path.exists(credentials_filename)\n            and os.path.isfile(credentials_filename)\n        ):\n            raise exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS path is either not found or invalid.\"\n            )\n\n        try:\n            with open(credentials_filename, \"r\") as f:\n                from google.oauth2 import _service_account_async as service_account\n\n                info = json.load(f)\n                if info.get(\"type\") == \"service_account\":\n                    credentials = service_account.IDTokenCredentials.from_service_account_info(\n                        info, target_audience=audience\n                    )\n                    await credentials.refresh(request)\n                    return credentials.token\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"GOOGLE_APPLICATION_CREDENTIALS is not valid service account credentials.\",\n                caught_exc,\n            )\n            raise new_exc from caught_exc\n\n    # 2. Try to fetch ID token from metada server if it exists. The code works\n    # for GAE and Cloud Run metadata server as well.\n    try:\n        from google.auth import compute_engine\n        from google.auth.compute_engine import _metadata\n\n        request_new = requests.Request()\n        if _metadata.ping(request_new):\n            credentials = compute_engine.IDTokenCredentials(\n                request_new, audience, use_metadata_identity_endpoint=True\n            )\n            credentials.refresh(request_new)\n            return credentials.token\n    except (ImportError, exceptions.TransportError):\n        pass\n\n    raise exceptions.DefaultCredentialsError(\n        \"Neither metadata server or valid service account credentials are found.\"\n    )\n", "google/oauth2/_service_account_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Service Accounts: JSON Web Token (JWT) Profile for OAuth 2.0\n\nNOTE: This file adds asynchronous refresh methods to both credentials\nclasses, and therefore async/await syntax is required when calling this\nmethod when using service account credentials with asynchronous functionality.\nOtherwise, all other methods are inherited from the regular service account\ncredentials file google.oauth2.service_account\n\n\"\"\"\n\nfrom google.auth import _credentials_async as credentials_async\nfrom google.auth import _helpers\nfrom google.oauth2 import _client_async\nfrom google.oauth2 import service_account\n\n\nclass Credentials(\n    service_account.Credentials, credentials_async.Scoped, credentials_async.Credentials\n):\n    \"\"\"Service account credentials\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = _service_account_async.Credentials.from_service_account_file(\n            'service-account.json')\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = _service_account_async.Credentials.from_service_account_info(\n            service_account_info)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = _service_account_async.Credentials.from_service_account_file(\n            'service-account.json',\n            scopes=['email'],\n            subject='user@example.com')\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    To add a quota project, use :meth:`with_quota_project`::\n\n        credentials = credentials.with_quota_project('myproject-123')\n    \"\"\"\n\n    @_helpers.copy_docstring(credentials_async.Credentials)\n    async def refresh(self, request):\n        assertion = self._make_authorization_grant_assertion()\n        access_token, expiry, _ = await _client_async.jwt_grant(\n            request, self._token_uri, assertion\n        )\n        self.token = access_token\n        self.expiry = expiry\n\n\nclass IDTokenCredentials(\n    service_account.IDTokenCredentials,\n    credentials_async.Signing,\n    credentials_async.Credentials,\n):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    These credentials are largely similar to :class:`.Credentials`, but instead\n    of using an OAuth 2.0 Access Token as the bearer token, they use an Open\n    ID Connect ID Token as the bearer token. These credentials are useful when\n    communicating to services that require ID Tokens and can not accept access\n    tokens.\n\n    Usually, you'll create these credentials with one of the helper\n    constructors. To create credentials using a Google service account\n    private key JSON file::\n\n        credentials = (\n            _service_account_async.IDTokenCredentials.from_service_account_file(\n                'service-account.json'))\n\n    Or if you already have the service account file loaded::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = (\n            _service_account_async.IDTokenCredentials.from_service_account_info(\n                service_account_info))\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify additional scopes and a subject if necessary::\n\n        credentials = (\n            _service_account_async.IDTokenCredentials.from_service_account_file(\n                'service-account.json',\n                scopes=['email'],\n                subject='user@example.com'))\n\n    The credentials are considered immutable. If you want to modify the scopes\n    or the subject used for delegation, use :meth:`with_scopes` or\n    :meth:`with_subject`::\n\n        scoped_credentials = credentials.with_scopes(['email'])\n        delegated_credentials = credentials.with_subject(subject)\n\n    \"\"\"\n\n    @_helpers.copy_docstring(credentials_async.Credentials)\n    async def refresh(self, request):\n        assertion = self._make_authorization_grant_assertion()\n        access_token, expiry, _ = await _client_async.id_token_jwt_grant(\n            request, self._token_uri, assertion\n        )\n        self.token = access_token\n        self.expiry = expiry\n", "google/oauth2/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google OAuth 2.0 Library for Python.\"\"\"\n\nimport sys\nimport warnings\n\n\nclass Python37DeprecationWarning(DeprecationWarning):  # pragma: NO COVER\n    \"\"\"\n    Deprecation warning raised when Python 3.7 runtime is detected.\n    Python 3.7 support will be dropped after January 1, 2024.\n    \"\"\"\n\n    pass\n\n\n# Checks if the current runtime is Python 3.7.\nif sys.version_info.major == 3 and sys.version_info.minor == 7:  # pragma: NO COVER\n    message = (\n        \"After January 1, 2024, new releases of this library will drop support \"\n        \"for Python 3.7.\"\n    )\n    warnings.warn(message, Python37DeprecationWarning)\n", "google/oauth2/webauthn_types.py": "from dataclasses import dataclass\nimport json\nfrom typing import Any, Dict, List, Optional\n\nfrom google.auth import exceptions\n\n\n@dataclass(frozen=True)\nclass PublicKeyCredentialDescriptor:\n    \"\"\"Descriptor for a security key based credential.\n\n    https://www.w3.org/TR/webauthn-3/#dictionary-credential-descriptor\n\n    Args:\n        id: <url-safe base64-encoded> credential id (key handle).\n        transports: <'usb'|'nfc'|'ble'|'internal'> List of supported transports.\n    \"\"\"\n\n    id: str\n    transports: Optional[List[str]] = None\n\n    def to_dict(self):\n        cred = {\"type\": \"public-key\", \"id\": self.id}\n        if self.transports:\n            cred[\"transports\"] = self.transports\n        return cred\n\n\n@dataclass\nclass AuthenticationExtensionsClientInputs:\n    \"\"\"Client extensions inputs for WebAuthn extensions.\n\n    Args:\n        appid: app id that can be asserted with in addition to rpid.\n            https://www.w3.org/TR/webauthn-3/#sctn-appid-extension\n    \"\"\"\n\n    appid: Optional[str] = None\n\n    def to_dict(self):\n        extensions = {}\n        if self.appid:\n            extensions[\"appid\"] = self.appid\n        return extensions\n\n\n@dataclass\nclass GetRequest:\n    \"\"\"WebAuthn get request\n\n    Args:\n        origin: Origin where the WebAuthn get assertion takes place.\n        rpid: Relying Party ID.\n        challenge: <url-safe base64-encoded> raw challenge.\n        timeout_ms: Timeout number in millisecond.\n        allow_credentials: List of allowed credentials.\n        user_verification: <'required'|'preferred'|'discouraged'> User verification requirement.\n        extensions: WebAuthn authentication extensions inputs.\n    \"\"\"\n\n    origin: str\n    rpid: str\n    challenge: str\n    timeout_ms: Optional[int] = None\n    allow_credentials: Optional[List[PublicKeyCredentialDescriptor]] = None\n    user_verification: Optional[str] = None\n    extensions: Optional[AuthenticationExtensionsClientInputs] = None\n\n    def to_json(self) -> str:\n        req_options: Dict[str, Any] = {\"rpid\": self.rpid, \"challenge\": self.challenge}\n        if self.timeout_ms:\n            req_options[\"timeout\"] = self.timeout_ms\n        if self.allow_credentials:\n            req_options[\"allowCredentials\"] = [\n                c.to_dict() for c in self.allow_credentials\n            ]\n        if self.user_verification:\n            req_options[\"userVerification\"] = self.user_verification\n        if self.extensions:\n            req_options[\"extensions\"] = self.extensions.to_dict()\n        return json.dumps(\n            {\"type\": \"get\", \"origin\": self.origin, \"requestData\": req_options}\n        )\n\n\n@dataclass(frozen=True)\nclass AuthenticatorAssertionResponse:\n    \"\"\"Authenticator response to a WebAuthn get (assertion) request.\n\n    https://www.w3.org/TR/webauthn-3/#authenticatorassertionresponse\n\n    Args:\n        client_data_json: <url-safe base64-encoded> client data JSON.\n        authenticator_data: <url-safe base64-encoded> authenticator data.\n        signature: <url-safe base64-encoded> signature.\n        user_handle: <url-safe base64-encoded> user handle.\n    \"\"\"\n\n    client_data_json: str\n    authenticator_data: str\n    signature: str\n    user_handle: Optional[str]\n\n\n@dataclass(frozen=True)\nclass GetResponse:\n    \"\"\"WebAuthn get (assertion) response.\n\n    Args:\n        id: <url-safe base64-encoded> credential id (key handle).\n        response: The authenticator assertion response.\n        authenticator_attachment: <'cross-platform'|'platform'> The attachment status of the authenticator.\n        client_extension_results: WebAuthn authentication extensions output results in a dictionary.\n    \"\"\"\n\n    id: str\n    response: AuthenticatorAssertionResponse\n    authenticator_attachment: Optional[str]\n    client_extension_results: Optional[Dict]\n\n    @staticmethod\n    def from_json(json_str: str):\n        \"\"\"Verify and construct GetResponse from a JSON string.\"\"\"\n        try:\n            resp_json = json.loads(json_str)\n        except ValueError:\n            raise exceptions.MalformedError(\"Invalid Get JSON response\")\n        if resp_json.get(\"type\") != \"getResponse\":\n            raise exceptions.MalformedError(\n                \"Invalid Get response type: {}\".format(resp_json.get(\"type\"))\n            )\n        pk_cred = resp_json.get(\"responseData\")\n        if pk_cred is None:\n            if resp_json.get(\"error\"):\n                raise exceptions.ReauthFailError(\n                    \"WebAuthn.get failure: {}\".format(resp_json[\"error\"])\n                )\n            else:\n                raise exceptions.MalformedError(\"Get response is empty\")\n        if pk_cred.get(\"type\") != \"public-key\":\n            raise exceptions.MalformedError(\n                \"Invalid credential type: {}\".format(pk_cred.get(\"type\"))\n            )\n        assertion_json = pk_cred[\"response\"]\n        assertion_resp = AuthenticatorAssertionResponse(\n            client_data_json=assertion_json[\"clientDataJSON\"],\n            authenticator_data=assertion_json[\"authenticatorData\"],\n            signature=assertion_json[\"signature\"],\n            user_handle=assertion_json.get(\"userHandle\"),\n        )\n        return GetResponse(\n            id=pk_cred[\"id\"],\n            response=assertion_resp,\n            authenticator_attachment=pk_cred.get(\"authenticatorAttachment\"),\n            client_extension_results=pk_cred.get(\"clientExtensionResults\"),\n        )\n", "google/oauth2/webauthn_handler_factory.py": "from typing import List, Optional\n\nfrom google.oauth2.webauthn_handler import PluginHandler, WebAuthnHandler\n\n\nclass WebauthnHandlerFactory:\n    handlers: List[WebAuthnHandler]\n\n    def __init__(self):\n        self.handlers = [PluginHandler()]\n\n    def get_handler(self) -> Optional[WebAuthnHandler]:\n        for handler in self.handlers:\n            if handler.is_available():\n                return handler\n        return None\n", "google/oauth2/challenges.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\" Challenges for reauthentication.\n\"\"\"\n\nimport abc\nimport base64\nimport getpass\nimport sys\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.oauth2 import webauthn_handler_factory\nfrom google.oauth2.webauthn_types import (\n    AuthenticationExtensionsClientInputs,\n    GetRequest,\n    PublicKeyCredentialDescriptor,\n)\n\n\nREAUTH_ORIGIN = \"https://accounts.google.com\"\nSAML_CHALLENGE_MESSAGE = (\n    \"Please run `gcloud auth login` to complete reauthentication with SAML.\"\n)\nWEBAUTHN_TIMEOUT_MS = 120000  # Two minute timeout\n\n\ndef get_user_password(text):\n    \"\"\"Get password from user.\n\n    Override this function with a different logic if you are using this library\n    outside a CLI.\n\n    Args:\n        text (str): message for the password prompt.\n\n    Returns:\n        str: password string.\n    \"\"\"\n    return getpass.getpass(text)\n\n\nclass ReauthChallenge(metaclass=abc.ABCMeta):\n    \"\"\"Base class for reauth challenges.\"\"\"\n\n    @property\n    @abc.abstractmethod\n    def name(self):  # pragma: NO COVER\n        \"\"\"Returns the name of the challenge.\"\"\"\n        raise NotImplementedError(\"name property must be implemented\")\n\n    @property\n    @abc.abstractmethod\n    def is_locally_eligible(self):  # pragma: NO COVER\n        \"\"\"Returns true if a challenge is supported locally on this machine.\"\"\"\n        raise NotImplementedError(\"is_locally_eligible property must be implemented\")\n\n    @abc.abstractmethod\n    def obtain_challenge_input(self, metadata):  # pragma: NO COVER\n        \"\"\"Performs logic required to obtain credentials and returns it.\n\n        Args:\n            metadata (Mapping): challenge metadata returned in the 'challenges' field in\n                the initial reauth request. Includes the 'challengeType' field\n                and other challenge-specific fields.\n\n        Returns:\n            response that will be send to the reauth service as the content of\n            the 'proposalResponse' field in the request body. Usually a dict\n            with the keys specific to the challenge. For example,\n            ``{'credential': password}`` for password challenge.\n        \"\"\"\n        raise NotImplementedError(\"obtain_challenge_input method must be implemented\")\n\n\nclass PasswordChallenge(ReauthChallenge):\n    \"\"\"Challenge that asks for user's password.\"\"\"\n\n    @property\n    def name(self):\n        return \"PASSWORD\"\n\n    @property\n    def is_locally_eligible(self):\n        return True\n\n    @_helpers.copy_docstring(ReauthChallenge)\n    def obtain_challenge_input(self, unused_metadata):\n        passwd = get_user_password(\"Please enter your password:\")\n        if not passwd:\n            passwd = \" \"  # avoid the server crashing in case of no password :D\n        return {\"credential\": passwd}\n\n\nclass SecurityKeyChallenge(ReauthChallenge):\n    \"\"\"Challenge that asks for user's security key touch.\"\"\"\n\n    @property\n    def name(self):\n        return \"SECURITY_KEY\"\n\n    @property\n    def is_locally_eligible(self):\n        return True\n\n    @_helpers.copy_docstring(ReauthChallenge)\n    def obtain_challenge_input(self, metadata):\n        # Check if there is an available Webauthn Handler, if not use pyu2f\n        try:\n            factory = webauthn_handler_factory.WebauthnHandlerFactory()\n            webauthn_handler = factory.get_handler()\n            if webauthn_handler is not None:\n                sys.stderr.write(\"Please insert and touch your security key\\n\")\n                return self._obtain_challenge_input_webauthn(metadata, webauthn_handler)\n        except Exception:\n            # Attempt pyu2f if exception in webauthn flow\n            pass\n\n        try:\n            import pyu2f.convenience.authenticator  # type: ignore\n            import pyu2f.errors  # type: ignore\n            import pyu2f.model  # type: ignore\n        except ImportError:\n            raise exceptions.ReauthFailError(\n                \"pyu2f dependency is required to use Security key reauth feature. \"\n                \"It can be installed via `pip install pyu2f` or `pip install google-auth[reauth]`.\"\n            )\n        sk = metadata[\"securityKey\"]\n        challenges = sk[\"challenges\"]\n        # Read both 'applicationId' and 'relyingPartyId', if they are the same, use\n        # applicationId, if they are different, use relyingPartyId first and retry\n        # with applicationId\n        application_id = sk[\"applicationId\"]\n        relying_party_id = sk[\"relyingPartyId\"]\n\n        if application_id != relying_party_id:\n            application_parameters = [relying_party_id, application_id]\n        else:\n            application_parameters = [application_id]\n\n        challenge_data = []\n        for c in challenges:\n            kh = c[\"keyHandle\"].encode(\"ascii\")\n            key = pyu2f.model.RegisteredKey(bytearray(base64.urlsafe_b64decode(kh)))\n            challenge = c[\"challenge\"].encode(\"ascii\")\n            challenge = base64.urlsafe_b64decode(challenge)\n            challenge_data.append({\"key\": key, \"challenge\": challenge})\n\n        # Track number of tries to suppress error message until all application_parameters\n        # are tried.\n        tries = 0\n        for app_id in application_parameters:\n            try:\n                tries += 1\n                api = pyu2f.convenience.authenticator.CreateCompositeAuthenticator(\n                    REAUTH_ORIGIN\n                )\n                response = api.Authenticate(\n                    app_id, challenge_data, print_callback=sys.stderr.write\n                )\n                return {\"securityKey\": response}\n            except pyu2f.errors.U2FError as e:\n                if e.code == pyu2f.errors.U2FError.DEVICE_INELIGIBLE:\n                    # Only show error if all app_ids have been tried\n                    if tries == len(application_parameters):\n                        sys.stderr.write(\"Ineligible security key.\\n\")\n                        return None\n                    continue\n                if e.code == pyu2f.errors.U2FError.TIMEOUT:\n                    sys.stderr.write(\n                        \"Timed out while waiting for security key touch.\\n\"\n                    )\n                else:\n                    raise e\n            except pyu2f.errors.PluginError as e:\n                sys.stderr.write(\"Plugin error: {}.\\n\".format(e))\n                continue\n            except pyu2f.errors.NoDeviceFoundError:\n                sys.stderr.write(\"No security key found.\\n\")\n            return None\n\n    def _obtain_challenge_input_webauthn(self, metadata, webauthn_handler):\n        sk = metadata.get(\"securityKey\")\n        if sk is None:\n            raise exceptions.InvalidValue(\"securityKey is None\")\n        challenges = sk.get(\"challenges\")\n        application_id = sk.get(\"applicationId\")\n        relying_party_id = sk.get(\"relyingPartyId\")\n        if challenges is None or len(challenges) < 1:\n            raise exceptions.InvalidValue(\"challenges is None or empty\")\n        if application_id is None:\n            raise exceptions.InvalidValue(\"application_id is None\")\n        if relying_party_id is None:\n            raise exceptions.InvalidValue(\"relying_party_id is None\")\n\n        allow_credentials = []\n        for challenge in challenges:\n            kh = challenge.get(\"keyHandle\")\n            if kh is None:\n                raise exceptions.InvalidValue(\"keyHandle is None\")\n            key_handle = self._unpadded_urlsafe_b64recode(kh)\n            allow_credentials.append(PublicKeyCredentialDescriptor(id=key_handle))\n\n        extension = AuthenticationExtensionsClientInputs(appid=application_id)\n\n        challenge = challenges[0].get(\"challenge\")\n        if challenge is None:\n            raise exceptions.InvalidValue(\"challenge is None\")\n\n        get_request = GetRequest(\n            origin=REAUTH_ORIGIN,\n            rpid=relying_party_id,\n            challenge=self._unpadded_urlsafe_b64recode(challenge),\n            timeout_ms=WEBAUTHN_TIMEOUT_MS,\n            allow_credentials=allow_credentials,\n            user_verification=\"required\",\n            extensions=extension,\n        )\n\n        try:\n            get_response = webauthn_handler.get(get_request)\n        except Exception as e:\n            sys.stderr.write(\"Webauthn Error: {}.\\n\".format(e))\n            raise e\n\n        response = {\n            \"clientData\": get_response.response.client_data_json,\n            \"authenticatorData\": get_response.response.authenticator_data,\n            \"signatureData\": get_response.response.signature,\n            \"applicationId\": application_id,\n            \"keyHandle\": get_response.id,\n            \"securityKeyReplyType\": 2,\n        }\n        return {\"securityKey\": response}\n\n    def _unpadded_urlsafe_b64recode(self, s):\n        \"\"\"Converts standard b64 encoded string to url safe b64 encoded string\n        with no padding.\"\"\"\n        b = base64.urlsafe_b64decode(s)\n        return base64.urlsafe_b64encode(b).decode().rstrip(\"=\")\n\n\nclass SamlChallenge(ReauthChallenge):\n    \"\"\"Challenge that asks the users to browse to their ID Providers.\n\n    Currently SAML challenge is not supported. When obtaining the challenge\n    input, exception will be raised to instruct the users to run\n    `gcloud auth login` for reauthentication.\n    \"\"\"\n\n    @property\n    def name(self):\n        return \"SAML\"\n\n    @property\n    def is_locally_eligible(self):\n        return True\n\n    def obtain_challenge_input(self, metadata):\n        # Magic Arch has not fully supported returning a proper dedirect URL\n        # for programmatic SAML users today. So we error our here and request\n        # users to use gcloud to complete a login.\n        raise exceptions.ReauthSamlChallengeFailError(SAML_CHALLENGE_MESSAGE)\n\n\nAVAILABLE_CHALLENGES = {\n    challenge.name: challenge\n    for challenge in [SecurityKeyChallenge(), PasswordChallenge(), SamlChallenge()]\n}\n", "google/oauth2/_client_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"OAuth 2.0 async client.\n\nThis is a client for interacting with an OAuth 2.0 authorization server's\ntoken endpoint.\n\nFor more information about the token endpoint, see\n`Section 3.1 of rfc6749`_\n\n.. _Section 3.1 of rfc6749: https://tools.ietf.org/html/rfc6749#section-3.2\n\"\"\"\n\nimport datetime\nimport http.client as http_client\nimport json\nimport urllib\n\nfrom google.auth import _exponential_backoff\nfrom google.auth import exceptions\nfrom google.auth import jwt\nfrom google.oauth2 import _client as client\n\n\nasync def _token_endpoint_request_no_throw(\n    request, token_uri, body, access_token=None, use_json=False, can_retry=True\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n    This function doesn't throw on response errors.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple(bool, Mapping[str, str], Optional[bool]): A boolean indicating\n          if the request is successful, a mapping for the JSON-decoded response\n          data and in the case of an error a boolean indicating if the error\n          is retryable.\n    \"\"\"\n    if use_json:\n        headers = {\"Content-Type\": client._JSON_CONTENT_TYPE}\n        body = json.dumps(body).encode(\"utf-8\")\n    else:\n        headers = {\"Content-Type\": client._URLENCODED_CONTENT_TYPE}\n        body = urllib.parse.urlencode(body).encode(\"utf-8\")\n\n    if access_token:\n        headers[\"Authorization\"] = \"Bearer {}\".format(access_token)\n\n    async def _perform_request():\n        response = await request(\n            method=\"POST\", url=token_uri, headers=headers, body=body\n        )\n\n        # Using data.read() resulted in zlib decompression errors. This may require future investigation.\n        response_body1 = await response.content()\n\n        response_body = (\n            response_body1.decode(\"utf-8\")\n            if hasattr(response_body1, \"decode\")\n            else response_body1\n        )\n\n        try:\n            response_data = json.loads(response_body)\n        except ValueError:\n            response_data = response_body\n\n        if response.status == http_client.OK:\n            return True, response_data, None\n\n        retryable_error = client._can_retry(\n            status_code=response.status, response_data=response_data\n        )\n\n        return False, response_data, retryable_error\n\n    request_succeeded, response_data, retryable_error = await _perform_request()\n\n    if request_succeeded or not retryable_error or not can_retry:\n        return request_succeeded, response_data, retryable_error\n\n    retries = _exponential_backoff.ExponentialBackoff()\n    for _ in retries:\n        request_succeeded, response_data, retryable_error = await _perform_request()\n        if request_succeeded or not retryable_error:\n            return request_succeeded, response_data, retryable_error\n\n    return False, response_data, retryable_error\n\n\nasync def _token_endpoint_request(\n    request, token_uri, body, access_token=None, use_json=False, can_retry=True\n):\n    \"\"\"Makes a request to the OAuth 2.0 authorization server's token endpoint.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        body (Mapping[str, str]): The parameters to send in the request body.\n        access_token (Optional(str)): The access token needed to make the request.\n        use_json (Optional(bool)): Use urlencoded format or json format for the\n            content type. The default value is False.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Mapping[str, str]: The JSON-decoded response data.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n\n    response_status_ok, response_data, retryable_error = await _token_endpoint_request_no_throw(\n        request,\n        token_uri,\n        body,\n        access_token=access_token,\n        use_json=use_json,\n        can_retry=can_retry,\n    )\n    if not response_status_ok:\n        client._handle_error_response(response_data, retryable_error)\n    return response_data\n\n\nasync def jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants.\n\n    For more details, see `rfc7523 section 4`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        assertion (str): The OAuth 2.0 assertion.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]: The access token,\n            expiration, and additional data returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc7523 section 4: https://tools.ietf.org/html/rfc7523#section-4\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": client._JWT_GRANT_TYPE}\n\n    response_data = await _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n\n    try:\n        access_token = response_data[\"access_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No access token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    expiry = client._parse_expiry(response_data)\n\n    return access_token, expiry, response_data\n\n\nasync def id_token_jwt_grant(request, token_uri, assertion, can_retry=True):\n    \"\"\"Implements the JWT Profile for OAuth 2.0 Authorization Grants, but\n    requests an OpenID Connect ID Token instead of an access token.\n\n    This is a variant on the standard JWT Profile that is currently unique\n    to Google. This was added for the benefit of authenticating to services\n    that require ID Tokens instead of access tokens or JWT bearer tokens.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorization server's token endpoint\n            URI.\n        assertion (str): JWT token signed by a service account. The token's\n            payload must include a ``target_audience`` claim.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[datetime], Mapping[str, str]]:\n            The (encoded) Open ID Connect ID Token, expiration, and additional\n            data returned by the endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\"assertion\": assertion, \"grant_type\": client._JWT_GRANT_TYPE}\n\n    response_data = await _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n\n    try:\n        id_token = response_data[\"id_token\"]\n    except KeyError as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"No ID token in response.\", response_data, retryable=False\n        )\n        raise new_exc from caught_exc\n\n    payload = jwt.decode(id_token, verify=False)\n    expiry = datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    return id_token, expiry, response_data\n\n\nasync def refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    can_retry=True,\n):\n    \"\"\"Implements the OAuth 2.0 refresh token grant.\n\n    For more details, see `rfc678 section 6`_.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The reauth Proof Token.\n        can_retry (bool): Enable or disable request retry behavior.\n\n    Returns:\n        Tuple[str, Optional[str], Optional[datetime], Mapping[str, str]]: The\n            access token, new or current refresh token, expiration, and additional data\n            returned by the token endpoint.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n\n    .. _rfc6748 section 6: https://tools.ietf.org/html/rfc6749#section-6\n    \"\"\"\n    body = {\n        \"grant_type\": client._REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n\n    response_data = await _token_endpoint_request(\n        request, token_uri, body, can_retry=can_retry\n    )\n    return client._handle_refresh_grant_response(response_data, refresh_token)\n", "google/oauth2/_reauth_async.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"A module that provides functions for handling rapt authentication.\n\nReauth is a process of obtaining additional authentication (such as password,\nsecurity token, etc.) while refreshing OAuth 2.0 credentials for a user.\n\nCredentials that use the Reauth flow must have the reauth scope,\n``https://www.googleapis.com/auth/accounts.reauth``.\n\nThis module provides a high-level function for executing the Reauth process,\n:func:`refresh_grant`, and lower-level helpers for doing the individual\nsteps of the reauth process.\n\nThose steps are:\n\n1. Obtaining a list of challenges from the reauth server.\n2. Running through each challenge and sending the result back to the reauth\n   server.\n3. Refreshing the access token using the returned rapt token.\n\"\"\"\n\nimport sys\n\nfrom google.auth import exceptions\nfrom google.oauth2 import _client\nfrom google.oauth2 import _client_async\nfrom google.oauth2 import challenges\nfrom google.oauth2 import reauth\n\n\nasync def _get_challenges(\n    request, supported_challenge_types, access_token, requested_scopes=None\n):\n    \"\"\"Does initial request to reauth API to get the challenges.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        supported_challenge_types (Sequence[str]): list of challenge names\n            supported by the manager.\n        access_token (str): Access token with reauth scopes.\n        requested_scopes (Optional(Sequence[str])): Authorized scopes for the credentials.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\"supportedChallengeTypes\": supported_challenge_types}\n    if requested_scopes:\n        body[\"oauthScopesForDomainPolicyLookup\"] = requested_scopes\n\n    return await _client_async._token_endpoint_request(\n        request,\n        reauth._REAUTH_API + \":start\",\n        body,\n        access_token=access_token,\n        use_json=True,\n    )\n\n\nasync def _send_challenge_result(\n    request, session_id, challenge_id, client_input, access_token\n):\n    \"\"\"Attempt to refresh access token by sending next challenge result.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        session_id (str): session id returned by the initial reauth call.\n        challenge_id (str): challenge id returned by the initial reauth call.\n        client_input: dict with a challenge-specific client input. For example:\n            ``{'credential': password}`` for password challenge.\n        access_token (str): Access token with reauth scopes.\n\n    Returns:\n        dict: The response from the reauth API.\n    \"\"\"\n    body = {\n        \"sessionId\": session_id,\n        \"challengeId\": challenge_id,\n        \"action\": \"RESPOND\",\n        \"proposalResponse\": client_input,\n    }\n\n    return await _client_async._token_endpoint_request(\n        request,\n        reauth._REAUTH_API + \"/{}:continue\".format(session_id),\n        body,\n        access_token=access_token,\n        use_json=True,\n    )\n\n\nasync def _run_next_challenge(msg, request, access_token):\n    \"\"\"Get the next challenge from msg and run it.\n\n    Args:\n        msg (dict): Reauth API response body (either from the initial request to\n            https://reauth.googleapis.com/v2/sessions:start or from sending the\n            previous challenge response to\n            https://reauth.googleapis.com/v2/sessions/id:continue)\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        access_token (str): reauth access token\n\n    Returns:\n        dict: The response from the reauth API.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed.\n    \"\"\"\n    for challenge in msg[\"challenges\"]:\n        if challenge[\"status\"] != \"READY\":\n            # Skip non-activated challenges.\n            continue\n        c = challenges.AVAILABLE_CHALLENGES.get(challenge[\"challengeType\"], None)\n        if not c:\n            raise exceptions.ReauthFailError(\n                \"Unsupported challenge type {0}. Supported types: {1}\".format(\n                    challenge[\"challengeType\"],\n                    \",\".join(list(challenges.AVAILABLE_CHALLENGES.keys())),\n                )\n            )\n        if not c.is_locally_eligible:\n            raise exceptions.ReauthFailError(\n                \"Challenge {0} is not locally eligible\".format(\n                    challenge[\"challengeType\"]\n                )\n            )\n        client_input = c.obtain_challenge_input(challenge)\n        if not client_input:\n            return None\n        return await _send_challenge_result(\n            request,\n            msg[\"sessionId\"],\n            challenge[\"challengeId\"],\n            client_input,\n            access_token,\n        )\n    return None\n\n\nasync def _obtain_rapt(request, access_token, requested_scopes):\n    \"\"\"Given an http request method and reauth access token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        access_token (str): reauth access token\n        requested_scopes (Sequence[str]): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n\n    Raises:\n        google.auth.exceptions.ReauthError: if reauth failed\n    \"\"\"\n    msg = await _get_challenges(\n        request,\n        list(challenges.AVAILABLE_CHALLENGES.keys()),\n        access_token,\n        requested_scopes,\n    )\n\n    if msg[\"status\"] == reauth._AUTHENTICATED:\n        return msg[\"encodedProofOfReauthToken\"]\n\n    for _ in range(0, reauth.RUN_CHALLENGE_RETRY_LIMIT):\n        if not (\n            msg[\"status\"] == reauth._CHALLENGE_REQUIRED\n            or msg[\"status\"] == reauth._CHALLENGE_PENDING\n        ):\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge failed due to API error: {}\".format(\n                    msg[\"status\"]\n                )\n            )\n\n        if not reauth.is_interactive():\n            raise exceptions.ReauthFailError(\n                \"Reauthentication challenge could not be answered because you are not\"\n                \" in an interactive session.\"\n            )\n\n        msg = await _run_next_challenge(msg, request, access_token)\n\n        if msg[\"status\"] == reauth._AUTHENTICATED:\n            return msg[\"encodedProofOfReauthToken\"]\n\n    # If we got here it means we didn't get authenticated.\n    raise exceptions.ReauthFailError(\"Failed to obtain rapt token.\")\n\n\nasync def get_rapt_token(\n    request, client_id, client_secret, refresh_token, token_uri, scopes=None\n):\n    \"\"\"Given an http request method and refresh_token, get rapt token.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        client_id (str): client id to get access token for reauth scope.\n        client_secret (str): client secret for the client_id\n        refresh_token (str): refresh token to refresh access token\n        token_uri (str): uri to refresh access token\n        scopes (Optional(Sequence[str])): scopes required by the client application\n\n    Returns:\n        str: The rapt token.\n    Raises:\n        google.auth.exceptions.RefreshError: If reauth failed.\n    \"\"\"\n    sys.stderr.write(\"Reauthentication required.\\n\")\n\n    # Get access token for reauth.\n    access_token, _, _, _ = await _client_async.refresh_grant(\n        request=request,\n        client_id=client_id,\n        client_secret=client_secret,\n        refresh_token=refresh_token,\n        token_uri=token_uri,\n        scopes=[reauth._REAUTH_SCOPE],\n    )\n\n    # Get rapt token from reauth API.\n    rapt_token = await _obtain_rapt(request, access_token, requested_scopes=scopes)\n\n    return rapt_token\n\n\nasync def refresh_grant(\n    request,\n    token_uri,\n    refresh_token,\n    client_id,\n    client_secret,\n    scopes=None,\n    rapt_token=None,\n    enable_reauth_refresh=False,\n):\n    \"\"\"Implements the reauthentication flow.\n\n    Args:\n        request (google.auth.transport.Request): A callable used to make\n            HTTP requests. This must be an aiohttp request.\n        token_uri (str): The OAuth 2.0 authorizations server's token endpoint\n            URI.\n        refresh_token (str): The refresh token to use to get a new access\n            token.\n        client_id (str): The OAuth 2.0 application's client ID.\n        client_secret (str): The Oauth 2.0 appliaction's client secret.\n        scopes (Optional(Sequence[str])): Scopes to request. If present, all\n            scopes must be authorized for the refresh token. Useful if refresh\n            token has a wild card scope (e.g.\n            'https://www.googleapis.com/auth/any-api').\n        rapt_token (Optional(str)): The rapt token for reauth.\n        enable_reauth_refresh (Optional[bool]): Whether reauth refresh flow\n            should be used. The default value is False. This option is for\n            gcloud only, other users should use the default value.\n\n    Returns:\n        Tuple[str, Optional[str], Optional[datetime], Mapping[str, str], str]: The\n            access token, new refresh token, expiration, the additional data\n            returned by the token endpoint, and the rapt token.\n\n    Raises:\n        google.auth.exceptions.RefreshError: If the token endpoint returned\n            an error.\n    \"\"\"\n    body = {\n        \"grant_type\": _client._REFRESH_GRANT_TYPE,\n        \"client_id\": client_id,\n        \"client_secret\": client_secret,\n        \"refresh_token\": refresh_token,\n    }\n    if scopes:\n        body[\"scope\"] = \" \".join(scopes)\n    if rapt_token:\n        body[\"rapt\"] = rapt_token\n\n    response_status_ok, response_data, retryable_error = await _client_async._token_endpoint_request_no_throw(\n        request, token_uri, body\n    )\n    if (\n        not response_status_ok\n        and response_data.get(\"error\") == reauth._REAUTH_NEEDED_ERROR\n        and (\n            response_data.get(\"error_subtype\")\n            == reauth._REAUTH_NEEDED_ERROR_INVALID_RAPT\n            or response_data.get(\"error_subtype\")\n            == reauth._REAUTH_NEEDED_ERROR_RAPT_REQUIRED\n        )\n    ):\n        if not enable_reauth_refresh:\n            raise exceptions.RefreshError(\n                \"Reauthentication is needed. Please run `gcloud auth application-default login` to reauthenticate.\"\n            )\n\n        rapt_token = await get_rapt_token(\n            request, client_id, client_secret, refresh_token, token_uri, scopes=scopes\n        )\n        body[\"rapt\"] = rapt_token\n        (\n            response_status_ok,\n            response_data,\n            retryable_error,\n        ) = await _client_async._token_endpoint_request_no_throw(\n            request, token_uri, body\n        )\n\n    if not response_status_ok:\n        _client._handle_error_response(response_data, retryable_error)\n    refresh_response = _client._handle_refresh_grant_response(\n        response_data, refresh_token\n    )\n    return refresh_response + (rapt_token,)\n", "google/auth/api_key.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google API key support.\nThis module provides authentication using the `API key`_.\n.. _API key:\n    https://cloud.google.com/docs/authentication/api-keys/\n\"\"\"\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\n\n\nclass Credentials(credentials.Credentials):\n    \"\"\"API key credentials.\n    These credentials use API key to provide authorization to applications.\n    \"\"\"\n\n    def __init__(self, token):\n        \"\"\"\n        Args:\n            token (str): API key string\n        Raises:\n            ValueError: If the provided API key is not a non-empty string.\n        \"\"\"\n        super(Credentials, self).__init__()\n        if not token:\n            raise exceptions.InvalidValue(\"Token must be a non-empty API key string\")\n        self.token = token\n\n    @property\n    def expired(self):\n        return False\n\n    @property\n    def valid(self):\n        return True\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        return\n\n    def apply(self, headers, token=None):\n        \"\"\"Apply the API key token to the x-goog-api-key header.\n        Args:\n            headers (Mapping): The HTTP request headers.\n            token (Optional[str]): If specified, overrides the current access\n                token.\n        \"\"\"\n        headers[\"x-goog-api-key\"] = token or self.token\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n        Refreshes the credentials if necessary, then calls :meth:`apply` to\n        apply the token to the x-goog-api-key header.\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            method (str): The request's HTTP method or the RPC method being\n                invoked.\n            url (str): The request's URI or the RPC service's URI.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        self.apply(headers)\n", "google/auth/_credentials_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"Interfaces for credentials.\"\"\"\n\nimport abc\nimport inspect\n\nfrom google.auth import credentials\n\n\nclass Credentials(credentials.Credentials, metaclass=abc.ABCMeta):\n    \"\"\"Async inherited credentials class from google.auth.credentials.\n    The added functionality is the before_request call which requires\n    async/await syntax.\n    All credentials have a :attr:`token` that is used for authentication and\n    may also optionally set an :attr:`expiry` to indicate when the token will\n    no longer be valid.\n\n    Most credentials will be :attr:`invalid` until :meth:`refresh` is called.\n    Credentials can do this automatically before the first HTTP request in\n    :meth:`before_request`.\n\n    Although the token and expiration will change as the credentials are\n    :meth:`refreshed <refresh>` and used, credentials should be considered\n    immutable. Various credentials will accept configuration such as private\n    keys, scopes, and other options. These options are not changeable after\n    construction. Some classes will provide mechanisms to copy the credentials\n    with modifications such as :meth:`ScopedCredentials.with_scopes`.\n    \"\"\"\n\n    async def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n\n        Refreshes the credentials if necessary, then calls :meth:`apply` to\n        apply the token to the authentication header.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            method (str): The request's HTTP method or the RPC method being\n                invoked.\n            url (str): The request's URI or the RPC service's URI.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (Subclasses may use these arguments to ascertain information about\n        # the http request.)\n\n        if not self.valid:\n            if inspect.iscoroutinefunction(self.refresh):\n                await self.refresh(request)\n            else:\n                self.refresh(request)\n        self.apply(headers)\n\n\nclass CredentialsWithQuotaProject(credentials.CredentialsWithQuotaProject):\n    \"\"\"Abstract base for credentials supporting ``with_quota_project`` factory\"\"\"\n\n\nclass AnonymousCredentials(credentials.AnonymousCredentials, Credentials):\n    \"\"\"Credentials that do not provide any authentication information.\n\n    These are useful in the case of services that support anonymous access or\n    local service emulators that do not use credentials. This class inherits\n    from the sync anonymous credentials file, but is kept if async credentials\n    is initialized and we would like anonymous credentials.\n    \"\"\"\n\n\nclass ReadOnlyScoped(credentials.ReadOnlyScoped, metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials whose scopes can be queried.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = _credentials_async.with_scopes(scopes=['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = _credentials_async.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n\nclass Scoped(credentials.Scoped):\n    \"\"\"Interface for credentials whose scopes can be replaced while copying.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = _credentials_async.create_scoped(['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n\ndef with_scopes_if_required(credentials, scopes):\n    \"\"\"Creates a copy of the credentials with scopes if scoping is required.\n\n    This helper function is useful when you do not know (or care to know) the\n    specific type of credentials you are using (such as when you use\n    :func:`google.auth.default`). This function will call\n    :meth:`Scoped.with_scopes` if the credentials are scoped credentials and if\n    the credentials require scoping. Otherwise, it will return the credentials\n    as-is.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            scope if necessary.\n        scopes (Sequence[str]): The list of scopes to use.\n\n    Returns:\n        google.auth._credentials_async.Credentials: Either a new set of scoped\n            credentials, or the passed in credentials instance if no scoping\n            was required.\n    \"\"\"\n    if isinstance(credentials, Scoped) and credentials.requires_scopes:\n        return credentials.with_scopes(scopes)\n    else:\n        return credentials\n\n\nclass Signing(credentials.Signing, metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials that can cryptographically sign messages.\"\"\"\n", "google/auth/downscoped.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Downscoping with Credential Access Boundaries\n\nThis module provides the ability to downscope credentials using\n`Downscoping with Credential Access Boundaries`_. This is useful to restrict the\nIdentity and Access Management (IAM) permissions that a short-lived credential\ncan use.\n\nTo downscope permissions of a source credential, a Credential Access Boundary\nthat specifies which resources the new credential can access, as well as\nan upper bound on the permissions that are available on each resource, has to\nbe defined. A downscoped credential can then be instantiated using the source\ncredential and the Credential Access Boundary.\n\nThe common pattern of usage is to have a token broker with elevated access\ngenerate these downscoped credentials from higher access source credentials and\npass the downscoped short-lived access tokens to a token consumer via some\nsecure authenticated channel for limited access to Google Cloud Storage\nresources.\n\nFor example, a token broker can be set up on a server in a private network.\nVarious workloads (token consumers) in the same network will send authenticated\nrequests to that broker for downscoped tokens to access or modify specific google\ncloud storage buckets.\n\nThe broker will instantiate downscoped credentials instances that can be used to\ngenerate short lived downscoped access tokens that can be passed to the token\nconsumer. These downscoped access tokens can be injected by the consumer into\ngoogle.oauth2.Credentials and used to initialize a storage client instance to\naccess Google Cloud Storage resources with restricted access.\n\nNote: Only Cloud Storage supports Credential Access Boundaries. Other Google\nCloud services do not support this feature.\n\n.. _Downscoping with Credential Access Boundaries: https://cloud.google.com/iam/docs/downscoping-short-lived-credentials\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.oauth2 import sts\n\n# The maximum number of access boundary rules a Credential Access Boundary can\n# contain.\n_MAX_ACCESS_BOUNDARY_RULES_COUNT = 10\n# The token exchange grant_type used for exchanging credentials.\n_STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n# The token exchange requested_token_type. This is always an access_token.\n_STS_REQUESTED_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\n# The STS token URL used to exchanged a short lived access token for a downscoped one.\n_STS_TOKEN_URL_PATTERN = \"https://sts.{}/v1/token\"\n# The subject token type to use when exchanging a short lived access token for a\n# downscoped token.\n_STS_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\n\n\nclass CredentialAccessBoundary(object):\n    \"\"\"Defines a Credential Access Boundary which contains a list of access boundary\n    rules. Each rule contains information on the resource that the rule applies to,\n    the upper bound of the permissions that are available on that resource and an\n    optional condition to further restrict permissions.\n    \"\"\"\n\n    def __init__(self, rules=[]):\n        \"\"\"Instantiates a Credential Access Boundary. A Credential Access Boundary\n        can contain up to 10 access boundary rules.\n\n        Args:\n            rules (Sequence[google.auth.downscoped.AccessBoundaryRule]): The list of\n                access boundary rules limiting the access that a downscoped credential\n                will have.\n        Raises:\n            InvalidType: If any of the rules are not a valid type.\n            InvalidValue: If the provided rules exceed the maximum allowed.\n        \"\"\"\n        self.rules = rules\n\n    @property\n    def rules(self):\n        \"\"\"Returns the list of access boundary rules defined on the Credential\n        Access Boundary.\n\n        Returns:\n            Tuple[google.auth.downscoped.AccessBoundaryRule, ...]: The list of access\n                boundary rules defined on the Credential Access Boundary. These are returned\n                as an immutable tuple to prevent modification.\n        \"\"\"\n        return tuple(self._rules)\n\n    @rules.setter\n    def rules(self, value):\n        \"\"\"Updates the current rules on the Credential Access Boundary. This will overwrite\n        the existing set of rules.\n\n        Args:\n            value (Sequence[google.auth.downscoped.AccessBoundaryRule]): The list of\n                access boundary rules limiting the access that a downscoped credential\n                will have.\n        Raises:\n            InvalidType: If any of the rules are not a valid type.\n            InvalidValue: If the provided rules exceed the maximum allowed.\n        \"\"\"\n        if len(value) > _MAX_ACCESS_BOUNDARY_RULES_COUNT:\n            raise exceptions.InvalidValue(\n                \"Credential access boundary rules can have a maximum of {} rules.\".format(\n                    _MAX_ACCESS_BOUNDARY_RULES_COUNT\n                )\n            )\n        for access_boundary_rule in value:\n            if not isinstance(access_boundary_rule, AccessBoundaryRule):\n                raise exceptions.InvalidType(\n                    \"List of rules provided do not contain a valid 'google.auth.downscoped.AccessBoundaryRule'.\"\n                )\n        # Make a copy of the original list.\n        self._rules = list(value)\n\n    def add_rule(self, rule):\n        \"\"\"Adds a single access boundary rule to the existing rules.\n\n        Args:\n            rule (google.auth.downscoped.AccessBoundaryRule): The access boundary rule,\n                limiting the access that a downscoped credential will have, to be added to\n                the existing rules.\n        Raises:\n            InvalidType: If any of the rules are not a valid type.\n            InvalidValue: If the provided rules exceed the maximum allowed.\n        \"\"\"\n        if len(self.rules) == _MAX_ACCESS_BOUNDARY_RULES_COUNT:\n            raise exceptions.InvalidValue(\n                \"Credential access boundary rules can have a maximum of {} rules.\".format(\n                    _MAX_ACCESS_BOUNDARY_RULES_COUNT\n                )\n            )\n        if not isinstance(rule, AccessBoundaryRule):\n            raise exceptions.InvalidType(\n                \"The provided rule does not contain a valid 'google.auth.downscoped.AccessBoundaryRule'.\"\n            )\n        self._rules.append(rule)\n\n    def to_json(self):\n        \"\"\"Generates the dictionary representation of the Credential Access Boundary.\n        This uses the format expected by the Security Token Service API as documented in\n        `Defining a Credential Access Boundary`_.\n\n        .. _Defining a Credential Access Boundary:\n            https://cloud.google.com/iam/docs/downscoping-short-lived-credentials#define-boundary\n\n        Returns:\n            Mapping: Credential Access Boundary Rule represented in a dictionary object.\n        \"\"\"\n        rules = []\n        for access_boundary_rule in self.rules:\n            rules.append(access_boundary_rule.to_json())\n\n        return {\"accessBoundary\": {\"accessBoundaryRules\": rules}}\n\n\nclass AccessBoundaryRule(object):\n    \"\"\"Defines an access boundary rule which contains information on the resource that\n    the rule applies to, the upper bound of the permissions that are available on that\n    resource and an optional condition to further restrict permissions.\n    \"\"\"\n\n    def __init__(\n        self, available_resource, available_permissions, availability_condition=None\n    ):\n        \"\"\"Instantiates a single access boundary rule.\n\n        Args:\n            available_resource (str): The full resource name of the Cloud Storage bucket\n                that the rule applies to. Use the format\n                \"//storage.googleapis.com/projects/_/buckets/bucket-name\".\n            available_permissions (Sequence[str]): A list defining the upper bound that\n                the downscoped token will have on the available permissions for the\n                resource. Each value is the identifier for an IAM predefined role or\n                custom role, with the prefix \"inRole:\". For example:\n                \"inRole:roles/storage.objectViewer\".\n                Only the permissions in these roles will be available.\n            availability_condition (Optional[google.auth.downscoped.AvailabilityCondition]):\n                Optional condition that restricts the availability of permissions to\n                specific Cloud Storage objects.\n\n        Raises:\n            InvalidType: If any of the parameters are not of the expected types.\n            InvalidValue: If any of the parameters are not of the expected values.\n        \"\"\"\n        self.available_resource = available_resource\n        self.available_permissions = available_permissions\n        self.availability_condition = availability_condition\n\n    @property\n    def available_resource(self):\n        \"\"\"Returns the current available resource.\n\n        Returns:\n           str: The current available resource.\n        \"\"\"\n        return self._available_resource\n\n    @available_resource.setter\n    def available_resource(self, value):\n        \"\"\"Updates the current available resource.\n\n        Args:\n            value (str): The updated value of the available resource.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not a string.\n        \"\"\"\n        if not isinstance(value, str):\n            raise exceptions.InvalidType(\n                \"The provided available_resource is not a string.\"\n            )\n        self._available_resource = value\n\n    @property\n    def available_permissions(self):\n        \"\"\"Returns the current available permissions.\n\n        Returns:\n           Tuple[str, ...]: The current available permissions. These are returned\n               as an immutable tuple to prevent modification.\n        \"\"\"\n        return tuple(self._available_permissions)\n\n    @available_permissions.setter\n    def available_permissions(self, value):\n        \"\"\"Updates the current available permissions.\n\n        Args:\n            value (Sequence[str]): The updated value of the available permissions.\n\n        Raises:\n            InvalidType: If the value is not a list of strings.\n            InvalidValue: If the value is not valid.\n        \"\"\"\n        for available_permission in value:\n            if not isinstance(available_permission, str):\n                raise exceptions.InvalidType(\n                    \"Provided available_permissions are not a list of strings.\"\n                )\n            if available_permission.find(\"inRole:\") != 0:\n                raise exceptions.InvalidValue(\n                    \"available_permissions must be prefixed with 'inRole:'.\"\n                )\n        # Make a copy of the original list.\n        self._available_permissions = list(value)\n\n    @property\n    def availability_condition(self):\n        \"\"\"Returns the current availability condition.\n\n        Returns:\n           Optional[google.auth.downscoped.AvailabilityCondition]: The current\n               availability condition.\n        \"\"\"\n        return self._availability_condition\n\n    @availability_condition.setter\n    def availability_condition(self, value):\n        \"\"\"Updates the current availability condition.\n\n        Args:\n            value (Optional[google.auth.downscoped.AvailabilityCondition]): The updated\n                value of the availability condition.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type google.auth.downscoped.AvailabilityCondition\n                or None.\n        \"\"\"\n        if not isinstance(value, AvailabilityCondition) and value is not None:\n            raise exceptions.InvalidType(\n                \"The provided availability_condition is not a 'google.auth.downscoped.AvailabilityCondition' or None.\"\n            )\n        self._availability_condition = value\n\n    def to_json(self):\n        \"\"\"Generates the dictionary representation of the access boundary rule.\n        This uses the format expected by the Security Token Service API as documented in\n        `Defining a Credential Access Boundary`_.\n\n        .. _Defining a Credential Access Boundary:\n            https://cloud.google.com/iam/docs/downscoping-short-lived-credentials#define-boundary\n\n        Returns:\n            Mapping: The access boundary rule represented in a dictionary object.\n        \"\"\"\n        json = {\n            \"availablePermissions\": list(self.available_permissions),\n            \"availableResource\": self.available_resource,\n        }\n        if self.availability_condition:\n            json[\"availabilityCondition\"] = self.availability_condition.to_json()\n        return json\n\n\nclass AvailabilityCondition(object):\n    \"\"\"An optional condition that can be used as part of a Credential Access Boundary\n    to further restrict permissions.\"\"\"\n\n    def __init__(self, expression, title=None, description=None):\n        \"\"\"Instantiates an availability condition using the provided expression and\n        optional title or description.\n\n        Args:\n            expression (str): A condition expression that specifies the Cloud Storage\n                objects where permissions are available. For example, this expression\n                makes permissions available for objects whose name starts with \"customer-a\":\n                \"resource.name.startsWith('projects/_/buckets/example-bucket/objects/customer-a')\"\n            title (Optional[str]): An optional short string that identifies the purpose of\n                the condition.\n            description (Optional[str]): Optional details about the purpose of the condition.\n\n        Raises:\n            InvalidType: If any of the parameters are not of the expected types.\n            InvalidValue: If any of the parameters are not of the expected values.\n        \"\"\"\n        self.expression = expression\n        self.title = title\n        self.description = description\n\n    @property\n    def expression(self):\n        \"\"\"Returns the current condition expression.\n\n        Returns:\n           str: The current conditon expression.\n        \"\"\"\n        return self._expression\n\n    @expression.setter\n    def expression(self, value):\n        \"\"\"Updates the current condition expression.\n\n        Args:\n            value (str): The updated value of the condition expression.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type string.\n        \"\"\"\n        if not isinstance(value, str):\n            raise exceptions.InvalidType(\"The provided expression is not a string.\")\n        self._expression = value\n\n    @property\n    def title(self):\n        \"\"\"Returns the current title.\n\n        Returns:\n           Optional[str]: The current title.\n        \"\"\"\n        return self._title\n\n    @title.setter\n    def title(self, value):\n        \"\"\"Updates the current title.\n\n        Args:\n            value (Optional[str]): The updated value of the title.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type string or None.\n        \"\"\"\n        if not isinstance(value, str) and value is not None:\n            raise exceptions.InvalidType(\"The provided title is not a string or None.\")\n        self._title = value\n\n    @property\n    def description(self):\n        \"\"\"Returns the current description.\n\n        Returns:\n           Optional[str]: The current description.\n        \"\"\"\n        return self._description\n\n    @description.setter\n    def description(self, value):\n        \"\"\"Updates the current description.\n\n        Args:\n            value (Optional[str]): The updated value of the description.\n\n        Raises:\n            google.auth.exceptions.InvalidType: If the value is not of type string or None.\n        \"\"\"\n        if not isinstance(value, str) and value is not None:\n            raise exceptions.InvalidType(\n                \"The provided description is not a string or None.\"\n            )\n        self._description = value\n\n    def to_json(self):\n        \"\"\"Generates the dictionary representation of the availability condition.\n        This uses the format expected by the Security Token Service API as documented in\n        `Defining a Credential Access Boundary`_.\n\n        .. _Defining a Credential Access Boundary:\n            https://cloud.google.com/iam/docs/downscoping-short-lived-credentials#define-boundary\n\n        Returns:\n            Mapping[str, str]: The availability condition represented in a dictionary\n                object.\n        \"\"\"\n        json = {\"expression\": self.expression}\n        if self.title:\n            json[\"title\"] = self.title\n        if self.description:\n            json[\"description\"] = self.description\n        return json\n\n\nclass Credentials(credentials.CredentialsWithQuotaProject):\n    \"\"\"Defines a set of Google credentials that are downscoped from an existing set\n    of Google OAuth2 credentials. This is useful to restrict the Identity and Access\n    Management (IAM) permissions that a short-lived credential can use.\n    The common pattern of usage is to have a token broker with elevated access\n    generate these downscoped credentials from higher access source credentials and\n    pass the downscoped short-lived access tokens to a token consumer via some\n    secure authenticated channel for limited access to Google Cloud Storage\n    resources.\n    \"\"\"\n\n    def __init__(\n        self,\n        source_credentials,\n        credential_access_boundary,\n        quota_project_id=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n    ):\n        \"\"\"Instantiates a downscoped credentials object using the provided source\n        credentials and credential access boundary rules.\n        To downscope permissions of a source credential, a Credential Access Boundary\n        that specifies which resources the new credential can access, as well as an\n        upper bound on the permissions that are available on each resource, has to be\n        defined. A downscoped credential can then be instantiated using the source\n        credential and the Credential Access Boundary.\n\n        Args:\n            source_credentials (google.auth.credentials.Credentials): The source credentials\n                to be downscoped based on the provided Credential Access Boundary rules.\n            credential_access_boundary (google.auth.downscoped.CredentialAccessBoundary):\n                The Credential Access Boundary which contains a list of access boundary\n                rules. Each rule contains information on the resource that the rule applies to,\n                the upper bound of the permissions that are available on that resource and an\n                optional condition to further restrict permissions.\n            quota_project_id (Optional[str]): The optional quota project ID.\n            universe_domain (Optional[str]): The universe domain value, default is googleapis.com\n        Raises:\n            google.auth.exceptions.RefreshError: If the source credentials\n                return an error on token refresh.\n            google.auth.exceptions.OAuthError: If the STS token exchange\n                endpoint returned an error during downscoped token generation.\n        \"\"\"\n\n        super(Credentials, self).__init__()\n        self._source_credentials = source_credentials\n        self._credential_access_boundary = credential_access_boundary\n        self._quota_project_id = quota_project_id\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n        self._sts_client = sts.Client(\n            _STS_TOKEN_URL_PATTERN.format(self.universe_domain)\n        )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        # Generate an access token from the source credentials.\n        self._source_credentials.refresh(request)\n        now = _helpers.utcnow()\n        # Exchange the access token for a downscoped access token.\n        response_data = self._sts_client.exchange_token(\n            request=request,\n            grant_type=_STS_GRANT_TYPE,\n            subject_token=self._source_credentials.token,\n            subject_token_type=_STS_SUBJECT_TOKEN_TYPE,\n            requested_token_type=_STS_REQUESTED_TOKEN_TYPE,\n            additional_options=self._credential_access_boundary.to_json(),\n        )\n        self.token = response_data.get(\"access_token\")\n        # For downscoping CAB flow, the STS endpoint may not return the expiration\n        # field for some flows. The generated downscoped token should always have\n        # the same expiration time as the source credentials. When no expires_in\n        # field is returned in the response, we can just get the expiration time\n        # from the source credentials.\n        if response_data.get(\"expires_in\"):\n            lifetime = datetime.timedelta(seconds=response_data.get(\"expires_in\"))\n            self.expiry = now + lifetime\n        else:\n            self.expiry = self._source_credentials.expiry\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            self._source_credentials,\n            self._credential_access_boundary,\n            quota_project_id=quota_project_id,\n        )\n", "google/auth/iam.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Tools for using the Google `Cloud Identity and Access Management (IAM)\nAPI`_'s auth-related functionality.\n\n.. _Cloud Identity and Access Management (IAM) API:\n    https://cloud.google.com/iam/docs/\n\"\"\"\n\nimport base64\nimport http.client as http_client\nimport json\n\nfrom google.auth import _helpers\nfrom google.auth import crypt\nfrom google.auth import exceptions\n\n\n_IAM_SCOPE = [\"https://www.googleapis.com/auth/iam\"]\n\n_IAM_ENDPOINT = (\n    \"https://iamcredentials.googleapis.com/v1/projects/-\"\n    + \"/serviceAccounts/{}:generateAccessToken\"\n)\n\n_IAM_SIGN_ENDPOINT = (\n    \"https://iamcredentials.googleapis.com/v1/projects/-\"\n    + \"/serviceAccounts/{}:signBlob\"\n)\n\n_IAM_IDTOKEN_ENDPOINT = (\n    \"https://iamcredentials.googleapis.com/v1/\"\n    + \"projects/-/serviceAccounts/{}:generateIdToken\"\n)\n\n\nclass Signer(crypt.Signer):\n    \"\"\"Signs messages using the IAM `signBlob API`_.\n\n    This is useful when you need to sign bytes but do not have access to the\n    credential's private key file.\n\n    .. _signBlob API:\n        https://cloud.google.com/iam/reference/rest/v1/projects.serviceAccounts\n        /signBlob\n    \"\"\"\n\n    def __init__(self, request, credentials, service_account_email):\n        \"\"\"\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            credentials (google.auth.credentials.Credentials): The credentials\n                that will be used to authenticate the request to the IAM API.\n                The credentials must have of one the following scopes:\n\n                - https://www.googleapis.com/auth/iam\n                - https://www.googleapis.com/auth/cloud-platform\n            service_account_email (str): The service account email identifying\n                which service account to use to sign bytes. Often, this can\n                be the same as the service account email in the given\n                credentials.\n        \"\"\"\n        self._request = request\n        self._credentials = credentials\n        self._service_account_email = service_account_email\n\n    def _make_signing_request(self, message):\n        \"\"\"Makes a request to the API signBlob API.\"\"\"\n        message = _helpers.to_bytes(message)\n\n        method = \"POST\"\n        url = _IAM_SIGN_ENDPOINT.format(self._service_account_email)\n        headers = {\"Content-Type\": \"application/json\"}\n        body = json.dumps(\n            {\"payload\": base64.b64encode(message).decode(\"utf-8\")}\n        ).encode(\"utf-8\")\n\n        self._credentials.before_request(self._request, method, url, headers)\n        response = self._request(url=url, method=method, body=body, headers=headers)\n\n        if response.status != http_client.OK:\n            raise exceptions.TransportError(\n                \"Error calling the IAM signBlob API: {}\".format(response.data)\n            )\n\n        return json.loads(response.data.decode(\"utf-8\"))\n\n    @property\n    def key_id(self):\n        \"\"\"Optional[str]: The key ID used to identify this private key.\n\n        .. warning::\n           This is always ``None``. The key ID used by IAM can not\n           be reliably determined ahead of time.\n        \"\"\"\n        return None\n\n    @_helpers.copy_docstring(crypt.Signer)\n    def sign(self, message):\n        response = self._make_signing_request(message)\n        return base64.b64decode(response[\"signedBlob\"])\n", "google/auth/exceptions.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Exceptions used in the google.auth package.\"\"\"\n\n\nclass GoogleAuthError(Exception):\n    \"\"\"Base class for all google.auth errors.\"\"\"\n\n    def __init__(self, *args, **kwargs):\n        super(GoogleAuthError, self).__init__(*args)\n        retryable = kwargs.get(\"retryable\", False)\n        self._retryable = retryable\n\n    @property\n    def retryable(self):\n        return self._retryable\n\n\nclass TransportError(GoogleAuthError):\n    \"\"\"Used to indicate an error occurred during an HTTP request.\"\"\"\n\n\nclass RefreshError(GoogleAuthError):\n    \"\"\"Used to indicate that an refreshing the credentials' access token\n    failed.\"\"\"\n\n\nclass UserAccessTokenError(GoogleAuthError):\n    \"\"\"Used to indicate ``gcloud auth print-access-token`` command failed.\"\"\"\n\n\nclass DefaultCredentialsError(GoogleAuthError):\n    \"\"\"Used to indicate that acquiring default credentials failed.\"\"\"\n\n\nclass MutualTLSChannelError(GoogleAuthError):\n    \"\"\"Used to indicate that mutual TLS channel creation is failed, or mutual\n    TLS channel credentials is missing or invalid.\"\"\"\n\n\nclass ClientCertError(GoogleAuthError):\n    \"\"\"Used to indicate that client certificate is missing or invalid.\"\"\"\n\n    @property\n    def retryable(self):\n        return False\n\n\nclass OAuthError(GoogleAuthError):\n    \"\"\"Used to indicate an error occurred during an OAuth related HTTP\n    request.\"\"\"\n\n\nclass ReauthFailError(RefreshError):\n    \"\"\"An exception for when reauth failed.\"\"\"\n\n    def __init__(self, message=None, **kwargs):\n        super(ReauthFailError, self).__init__(\n            \"Reauthentication failed. {0}\".format(message), **kwargs\n        )\n\n\nclass ReauthSamlChallengeFailError(ReauthFailError):\n    \"\"\"An exception for SAML reauth challenge failures.\"\"\"\n\n\nclass MalformedError(DefaultCredentialsError, ValueError):\n    \"\"\"An exception for malformed data.\"\"\"\n\n\nclass InvalidResource(DefaultCredentialsError, ValueError):\n    \"\"\"An exception for URL error.\"\"\"\n\n\nclass InvalidOperation(DefaultCredentialsError, ValueError):\n    \"\"\"An exception for invalid operation.\"\"\"\n\n\nclass InvalidValue(DefaultCredentialsError, ValueError):\n    \"\"\"Used to wrap general ValueError of python.\"\"\"\n\n\nclass InvalidType(DefaultCredentialsError, TypeError):\n    \"\"\"Used to wrap general TypeError of python.\"\"\"\n\n\nclass OSError(DefaultCredentialsError, EnvironmentError):\n    \"\"\"Used to wrap EnvironmentError(OSError after python3.3).\"\"\"\n", "google/auth/_cloud_sdk.py": "# Copyright 2015 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helpers for reading the Google Cloud SDK's configuration.\"\"\"\n\nimport os\nimport subprocess\n\nfrom google.auth import _helpers\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\n\n\n# The ~/.config subdirectory containing gcloud credentials.\n_CONFIG_DIRECTORY = \"gcloud\"\n# Windows systems store config at %APPDATA%\\gcloud\n_WINDOWS_CONFIG_ROOT_ENV_VAR = \"APPDATA\"\n# The name of the file in the Cloud SDK config that contains default\n# credentials.\n_CREDENTIALS_FILENAME = \"application_default_credentials.json\"\n# The name of the Cloud SDK shell script\n_CLOUD_SDK_POSIX_COMMAND = \"gcloud\"\n_CLOUD_SDK_WINDOWS_COMMAND = \"gcloud.cmd\"\n# The command to get the Cloud SDK configuration\n_CLOUD_SDK_CONFIG_GET_PROJECT_COMMAND = (\"config\", \"get\", \"project\")\n# The command to get google user access token\n_CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND = (\"auth\", \"print-access-token\")\n# Cloud SDK's application-default client ID\nCLOUD_SDK_CLIENT_ID = (\n    \"764086051850-6qr4p6gpi6hn506pt8ejuq83di341hur.apps.googleusercontent.com\"\n)\n\n\ndef get_config_path():\n    \"\"\"Returns the absolute path the the Cloud SDK's configuration directory.\n\n    Returns:\n        str: The Cloud SDK config path.\n    \"\"\"\n    # If the path is explicitly set, return that.\n    try:\n        return os.environ[environment_vars.CLOUD_SDK_CONFIG_DIR]\n    except KeyError:\n        pass\n\n    # Non-windows systems store this at ~/.config/gcloud\n    if os.name != \"nt\":\n        return os.path.join(os.path.expanduser(\"~\"), \".config\", _CONFIG_DIRECTORY)\n    # Windows systems store config at %APPDATA%\\gcloud\n    else:\n        try:\n            return os.path.join(\n                os.environ[_WINDOWS_CONFIG_ROOT_ENV_VAR], _CONFIG_DIRECTORY\n            )\n        except KeyError:\n            # This should never happen unless someone is really\n            # messing with things, but we'll cover the case anyway.\n            drive = os.environ.get(\"SystemDrive\", \"C:\")\n            return os.path.join(drive, \"\\\\\", _CONFIG_DIRECTORY)\n\n\ndef get_application_default_credentials_path():\n    \"\"\"Gets the path to the application default credentials file.\n\n    The path may or may not exist.\n\n    Returns:\n        str: The full path to application default credentials.\n    \"\"\"\n    config_path = get_config_path()\n    return os.path.join(config_path, _CREDENTIALS_FILENAME)\n\n\ndef _run_subprocess_ignore_stderr(command):\n    \"\"\" Return subprocess.check_output with the given command and ignores stderr.\"\"\"\n    with open(os.devnull, \"w\") as devnull:\n        output = subprocess.check_output(command, stderr=devnull)\n    return output\n\n\ndef get_project_id():\n    \"\"\"Gets the project ID from the Cloud SDK.\n\n    Returns:\n        Optional[str]: The project ID.\n    \"\"\"\n    if os.name == \"nt\":\n        command = _CLOUD_SDK_WINDOWS_COMMAND\n    else:\n        command = _CLOUD_SDK_POSIX_COMMAND\n\n    try:\n        # Ignore the stderr coming from gcloud, so it won't be mixed into the output.\n        # https://github.com/googleapis/google-auth-library-python/issues/673\n        project = _run_subprocess_ignore_stderr(\n            (command,) + _CLOUD_SDK_CONFIG_GET_PROJECT_COMMAND\n        )\n\n        # Turn bytes into a string and remove \"\\n\"\n        project = _helpers.from_bytes(project).strip()\n        return project if project else None\n    except (subprocess.CalledProcessError, OSError, IOError):\n        return None\n\n\ndef get_auth_access_token(account=None):\n    \"\"\"Load user access token with the ``gcloud auth print-access-token`` command.\n\n    Args:\n        account (Optional[str]): Account to get the access token for. If not\n            specified, the current active account will be used.\n\n    Returns:\n        str: The user access token.\n\n    Raises:\n        google.auth.exceptions.UserAccessTokenError: if failed to get access\n            token from gcloud.\n    \"\"\"\n    if os.name == \"nt\":\n        command = _CLOUD_SDK_WINDOWS_COMMAND\n    else:\n        command = _CLOUD_SDK_POSIX_COMMAND\n\n    try:\n        if account:\n            command = (\n                (command,)\n                + _CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND\n                + (\"--account=\" + account,)\n            )\n        else:\n            command = (command,) + _CLOUD_SDK_USER_ACCESS_TOKEN_COMMAND\n\n        access_token = subprocess.check_output(command, stderr=subprocess.STDOUT)\n        # remove the trailing \"\\n\"\n        return access_token.decode(\"utf-8\").strip()\n    except (subprocess.CalledProcessError, OSError, IOError) as caught_exc:\n        new_exc = exceptions.UserAccessTokenError(\n            \"Failed to obtain access token\", caught_exc\n        )\n        raise new_exc from caught_exc\n", "google/auth/_jwt_async.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"JSON Web Tokens\n\nProvides support for creating (encoding) and verifying (decoding) JWTs,\nespecially JWTs generated and consumed by Google infrastructure.\n\nSee `rfc7519`_ for more details on JWTs.\n\nTo encode a JWT use :func:`encode`::\n\n    from google.auth import crypt\n    from google.auth import jwt_async\n\n    signer = crypt.Signer(private_key)\n    payload = {'some': 'payload'}\n    encoded = jwt_async.encode(signer, payload)\n\nTo decode a JWT and verify claims use :func:`decode`::\n\n    claims = jwt_async.decode(encoded, certs=public_certs)\n\nYou can also skip verification::\n\n    claims = jwt_async.decode(encoded, verify=False)\n\n.. _rfc7519: https://tools.ietf.org/html/rfc7519\n\n\nNOTE: This async support is experimental and marked internal. This surface may\nchange in minor releases.\n\"\"\"\n\nfrom google.auth import _credentials_async\nfrom google.auth import jwt\n\n\ndef encode(signer, payload, header=None, key_id=None):\n    \"\"\"Make a signed JWT.\n\n    Args:\n        signer (google.auth.crypt.Signer): The signer used to sign the JWT.\n        payload (Mapping[str, str]): The JWT payload.\n        header (Mapping[str, str]): Additional JWT header payload.\n        key_id (str): The key id to add to the JWT header. If the\n            signer has a key id it will be used as the default. If this is\n            specified it will override the signer's key id.\n\n    Returns:\n        bytes: The encoded JWT.\n    \"\"\"\n    return jwt.encode(signer, payload, header, key_id)\n\n\ndef decode(token, certs=None, verify=True, audience=None):\n    \"\"\"Decode and verify a JWT.\n\n    Args:\n        token (str): The encoded JWT.\n        certs (Union[str, bytes, Mapping[str, Union[str, bytes]]]): The\n            certificate used to validate the JWT signature. If bytes or string,\n            it must the the public key certificate in PEM format. If a mapping,\n            it must be a mapping of key IDs to public key certificates in PEM\n            format. The mapping must contain the same key ID that's specified\n            in the token's header.\n        verify (bool): Whether to perform signature and claim validation.\n            Verification is done by default.\n        audience (str): The audience claim, 'aud', that this JWT should\n            contain. If None then the JWT's 'aud' parameter is not verified.\n\n    Returns:\n        Mapping[str, str]: The deserialized JSON payload in the JWT.\n\n    Raises:\n        ValueError: if any verification checks failed.\n    \"\"\"\n\n    return jwt.decode(token, certs, verify, audience)\n\n\nclass Credentials(\n    jwt.Credentials, _credentials_async.Signing, _credentials_async.Credentials\n):\n    \"\"\"Credentials that use a JWT as the bearer token.\n\n    These credentials require an \"audience\" claim. This claim identifies the\n    intended recipient of the bearer token.\n\n    The constructor arguments determine the claims for the JWT that is\n    sent with requests. Usually, you'll construct these credentials with\n    one of the helper constructors as shown in the next section.\n\n    To create JWT credentials using a Google service account private key\n    JSON file::\n\n        audience = 'https://pubsub.googleapis.com/google.pubsub.v1.Publisher'\n        credentials = jwt_async.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience)\n\n    If you already have the service account file loaded and parsed::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = jwt_async.Credentials.from_service_account_info(\n            service_account_info,\n            audience=audience)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify the JWT claims::\n\n        credentials = jwt_async.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience,\n            additional_claims={'meta': 'data'})\n\n    You can also construct the credentials directly if you have a\n    :class:`~google.auth.crypt.Signer` instance::\n\n        credentials = jwt_async.Credentials(\n            signer,\n            issuer='your-issuer',\n            subject='your-subject',\n            audience=audience)\n\n    The claims are considered immutable. If you want to modify the claims,\n    you can easily create another instance using :meth:`with_claims`::\n\n        new_audience = (\n            'https://pubsub.googleapis.com/google.pubsub.v1.Subscriber')\n        new_credentials = credentials.with_claims(audience=new_audience)\n    \"\"\"\n\n\nclass OnDemandCredentials(\n    jwt.OnDemandCredentials, _credentials_async.Signing, _credentials_async.Credentials\n):\n    \"\"\"On-demand JWT credentials.\n\n    Like :class:`Credentials`, this class uses a JWT as the bearer token for\n    authentication. However, this class does not require the audience at\n    construction time. Instead, it will generate a new token on-demand for\n    each request using the request URI as the audience. It caches tokens\n    so that multiple requests to the same URI do not incur the overhead\n    of generating a new token every time.\n\n    This behavior is especially useful for `gRPC`_ clients. A gRPC service may\n    have multiple audience and gRPC clients may not know all of the audiences\n    required for accessing a particular service. With these credentials,\n    no knowledge of the audiences is required ahead of time.\n\n    .. _grpc: http://www.grpc.io/\n    \"\"\"\n", "google/auth/external_account_authorized_user.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"External Account Authorized User Credentials.\nThis module provides credentials based on OAuth 2.0 access and refresh tokens.\nThese credentials usually access resources on behalf of a user (resource\nowner).\n\nSpecifically, these are sourced using external identities via Workforce Identity Federation.\n\nObtaining the initial access and refresh token can be done through the Google Cloud CLI.\n\nExample credential:\n{\n  \"type\": \"external_account_authorized_user\",\n  \"audience\": \"//iam.googleapis.com/locations/global/workforcePools/$WORKFORCE_POOL_ID/providers/$PROVIDER_ID\",\n  \"refresh_token\": \"refreshToken\",\n  \"token_url\": \"https://sts.googleapis.com/v1/oauth/token\",\n  \"token_info_url\": \"https://sts.googleapis.com/v1/instrospect\",\n  \"client_id\": \"clientId\",\n  \"client_secret\": \"clientSecret\"\n}\n\"\"\"\n\nimport datetime\nimport io\nimport json\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.oauth2 import sts\nfrom google.oauth2 import utils\n\n_EXTERNAL_ACCOUNT_AUTHORIZED_USER_JSON_TYPE = \"external_account_authorized_user\"\n\n\nclass Credentials(\n    credentials.CredentialsWithQuotaProject,\n    credentials.ReadOnlyScoped,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Credentials for External Account Authorized Users.\n\n    This is used to instantiate Credentials for exchanging refresh tokens from\n    authorized users for Google access token and authorizing requests to Google\n    APIs.\n\n    The credentials are considered immutable. If you want to modify the\n    quota project, use `with_quota_project` and if you want to modify the token\n    uri, use `with_token_uri`.\n    \"\"\"\n\n    def __init__(\n        self,\n        token=None,\n        expiry=None,\n        refresh_token=None,\n        audience=None,\n        client_id=None,\n        client_secret=None,\n        token_url=None,\n        token_info_url=None,\n        revoke_url=None,\n        scopes=None,\n        quota_project_id=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n    ):\n        \"\"\"Instantiates a external account authorized user credentials object.\n\n        Args:\n        token (str): The OAuth 2.0 access token. Can be None if refresh information\n            is provided.\n        expiry (datetime.datetime): The optional expiration datetime of the OAuth 2.0 access\n            token.\n        refresh_token (str): The optional OAuth 2.0 refresh token. If specified,\n            credentials can be refreshed.\n        audience (str): The optional STS audience which contains the resource name for the workforce\n            pool and the provider identifier in that pool.\n        client_id (str): The OAuth 2.0 client ID. Must be specified for refresh, can be left as\n            None if the token can not be refreshed.\n        client_secret (str): The OAuth 2.0 client secret. Must be specified for refresh, can be\n            left as None if the token can not be refreshed.\n        token_url (str): The optional STS token exchange endpoint for refresh. Must be specified for\n            refresh, can be left as None if the token can not be refreshed.\n        token_info_url (str): The optional STS endpoint URL for token introspection.\n        revoke_url (str): The optional STS endpoint URL for revoking tokens.\n        quota_project_id (str): The optional project ID used for quota and billing.\n            This project may be different from the project used to\n            create the credentials.\n        universe_domain (Optional[str]): The universe domain. The default value\n            is googleapis.com.\n\n        Returns:\n            google.auth.external_account_authorized_user.Credentials: The\n                constructed credentials.\n        \"\"\"\n        super(Credentials, self).__init__()\n\n        self.token = token\n        self.expiry = expiry\n        self._audience = audience\n        self._refresh_token = refresh_token\n        self._token_url = token_url\n        self._token_info_url = token_info_url\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._revoke_url = revoke_url\n        self._quota_project_id = quota_project_id\n        self._scopes = scopes\n        self._universe_domain = universe_domain or credentials.DEFAULT_UNIVERSE_DOMAIN\n\n        if not self.valid and not self.can_refresh:\n            raise exceptions.InvalidOperation(\n                \"Token should be created with fields to make it valid (`token` and \"\n                \"`expiry`), or fields to allow it to refresh (`refresh_token`, \"\n                \"`token_url`, `client_id`, `client_secret`).\"\n            )\n\n        self._client_auth = None\n        if self._client_id:\n            self._client_auth = utils.ClientAuthentication(\n                utils.ClientAuthType.basic, self._client_id, self._client_secret\n            )\n        self._sts_client = sts.Client(self._token_url, self._client_auth)\n\n    @property\n    def info(self):\n        \"\"\"Generates the serializable dictionary representation of the current\n        credentials.\n\n        Returns:\n            Mapping: The dictionary representation of the credentials. This is the\n                reverse of the \"from_info\" method defined in this class. It is\n                useful for serializing the current credentials so it can deserialized\n                later.\n        \"\"\"\n        config_info = self.constructor_args()\n        config_info.update(type=_EXTERNAL_ACCOUNT_AUTHORIZED_USER_JSON_TYPE)\n        if config_info[\"expiry\"]:\n            config_info[\"expiry\"] = config_info[\"expiry\"].isoformat() + \"Z\"\n\n        return {key: value for key, value in config_info.items() if value is not None}\n\n    def constructor_args(self):\n        return {\n            \"audience\": self._audience,\n            \"refresh_token\": self._refresh_token,\n            \"token_url\": self._token_url,\n            \"token_info_url\": self._token_info_url,\n            \"client_id\": self._client_id,\n            \"client_secret\": self._client_secret,\n            \"token\": self.token,\n            \"expiry\": self.expiry,\n            \"revoke_url\": self._revoke_url,\n            \"scopes\": self._scopes,\n            \"quota_project_id\": self._quota_project_id,\n            \"universe_domain\": self._universe_domain,\n        }\n\n    @property\n    def scopes(self):\n        \"\"\"Optional[str]: The OAuth 2.0 permission scopes.\"\"\"\n        return self._scopes\n\n    @property\n    def requires_scopes(self):\n        \"\"\" False: OAuth 2.0 credentials have their scopes set when\n        the initial token is requested and can not be changed.\"\"\"\n        return False\n\n    @property\n    def client_id(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client ID.\"\"\"\n        return self._client_id\n\n    @property\n    def client_secret(self):\n        \"\"\"Optional[str]: The OAuth 2.0 client secret.\"\"\"\n        return self._client_secret\n\n    @property\n    def audience(self):\n        \"\"\"Optional[str]: The STS audience which contains the resource name for the\n            workforce pool and the provider identifier in that pool.\"\"\"\n        return self._audience\n\n    @property\n    def refresh_token(self):\n        \"\"\"Optional[str]: The OAuth 2.0 refresh token.\"\"\"\n        return self._refresh_token\n\n    @property\n    def token_url(self):\n        \"\"\"Optional[str]: The STS token exchange endpoint for refresh.\"\"\"\n        return self._token_url\n\n    @property\n    def token_info_url(self):\n        \"\"\"Optional[str]: The STS endpoint for token info.\"\"\"\n        return self._token_info_url\n\n    @property\n    def revoke_url(self):\n        \"\"\"Optional[str]: The STS endpoint for token revocation.\"\"\"\n        return self._revoke_url\n\n    @property\n    def is_user(self):\n        \"\"\" True: This credential always represents a user.\"\"\"\n        return True\n\n    @property\n    def can_refresh(self):\n        return all(\n            (self._refresh_token, self._token_url, self._client_id, self._client_secret)\n        )\n\n    def get_project_id(self, request=None):\n        \"\"\"Retrieves the project ID corresponding to the workload identity or workforce pool.\n        For workforce pool credentials, it returns the project ID corresponding to\n        the workforce_pool_user_project.\n\n        When not determinable, None is returned.\n\n        Args:\n            request (google.auth.transport.requests.Request): Request object.\n                Unused here, but passed from _default.default().\n\n        Return:\n          str: project ID is not determinable for this credential type so it returns None\n        \"\"\"\n\n        return None\n\n    def to_json(self, strip=None):\n        \"\"\"Utility function that creates a JSON representation of this\n        credential.\n        Args:\n            strip (Sequence[str]): Optional list of members to exclude from the\n                                   generated JSON.\n        Returns:\n            str: A JSON representation of this instance. When converted into\n            a dictionary, it can be passed to from_info()\n            to create a new instance.\n        \"\"\"\n        strip = strip if strip else []\n        return json.dumps({k: v for (k, v) in self.info.items() if k not in strip})\n\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the credentials could\n                not be refreshed.\n        \"\"\"\n        if not self.can_refresh:\n            raise exceptions.RefreshError(\n                \"The credentials do not contain the necessary fields need to \"\n                \"refresh the access token. You must specify refresh_token, \"\n                \"token_url, client_id, and client_secret.\"\n            )\n\n        now = _helpers.utcnow()\n        response_data = self._make_sts_request(request)\n\n        self.token = response_data.get(\"access_token\")\n\n        lifetime = datetime.timedelta(seconds=response_data.get(\"expires_in\"))\n        self.expiry = now + lifetime\n\n        if \"refresh_token\" in response_data:\n            self._refresh_token = response_data[\"refresh_token\"]\n\n    def _make_sts_request(self, request):\n        return self._sts_client.refresh_token(request, self._refresh_token)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        kwargs = self.constructor_args()\n        kwargs.update(quota_project_id=quota_project_id)\n        return self.__class__(**kwargs)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        kwargs = self.constructor_args()\n        kwargs.update(token_url=token_uri)\n        return self.__class__(**kwargs)\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        kwargs = self.constructor_args()\n        kwargs.update(universe_domain=universe_domain)\n        return self.__class__(**kwargs)\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates a Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.external_account_authorized_user.Credentials: The\n                constructed credentials.\n\n        Raises:\n            ValueError: For invalid parameters.\n        \"\"\"\n        expiry = info.get(\"expiry\")\n        if expiry:\n            expiry = datetime.datetime.strptime(\n                expiry.rstrip(\"Z\").split(\".\")[0], \"%Y-%m-%dT%H:%M:%S\"\n            )\n        return cls(\n            audience=info.get(\"audience\"),\n            refresh_token=info.get(\"refresh_token\"),\n            token_url=info.get(\"token_url\"),\n            token_info_url=info.get(\"token_info_url\"),\n            client_id=info.get(\"client_id\"),\n            client_secret=info.get(\"client_secret\"),\n            token=info.get(\"token\"),\n            expiry=expiry,\n            revoke_url=info.get(\"revoke_url\"),\n            quota_project_id=info.get(\"quota_project_id\"),\n            scopes=info.get(\"scopes\"),\n            universe_domain=info.get(\n                \"universe_domain\", credentials.DEFAULT_UNIVERSE_DOMAIN\n            ),\n            **kwargs\n        )\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.external_account_authorized_user.Credentials: The\n                constructed credentials.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n            return cls.from_info(data, **kwargs)\n", "google/auth/version.py": "# Copyright 2021 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n__version__ = \"2.30.0\"\n", "google/auth/_default.py": "# Copyright 2015 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Application default credentials.\n\nImplements application default credentials and project ID detection.\n\"\"\"\n\nimport io\nimport json\nimport logging\nimport os\nimport warnings\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nimport google.auth.transport._http_client\n\n_LOGGER = logging.getLogger(__name__)\n\n# Valid types accepted for file-based credentials.\n_AUTHORIZED_USER_TYPE = \"authorized_user\"\n_SERVICE_ACCOUNT_TYPE = \"service_account\"\n_EXTERNAL_ACCOUNT_TYPE = \"external_account\"\n_EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE = \"external_account_authorized_user\"\n_IMPERSONATED_SERVICE_ACCOUNT_TYPE = \"impersonated_service_account\"\n_GDCH_SERVICE_ACCOUNT_TYPE = \"gdch_service_account\"\n_VALID_TYPES = (\n    _AUTHORIZED_USER_TYPE,\n    _SERVICE_ACCOUNT_TYPE,\n    _EXTERNAL_ACCOUNT_TYPE,\n    _EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE,\n    _IMPERSONATED_SERVICE_ACCOUNT_TYPE,\n    _GDCH_SERVICE_ACCOUNT_TYPE,\n)\n\n# Help message when no credentials can be found.\n_CLOUD_SDK_MISSING_CREDENTIALS = \"\"\"\\\nYour default credentials were not found. To set up Application Default Credentials, \\\nsee https://cloud.google.com/docs/authentication/external/set-up-adc for more information.\\\n\"\"\"\n\n# Warning when using Cloud SDK user credentials\n_CLOUD_SDK_CREDENTIALS_WARNING = \"\"\"\\\nYour application has authenticated using end user credentials from Google \\\nCloud SDK without a quota project. You might receive a \"quota exceeded\" \\\nor \"API not enabled\" error. See the following page for troubleshooting: \\\nhttps://cloud.google.com/docs/authentication/adc-troubleshooting/user-creds. \\\n\"\"\"\n\n# The subject token type used for AWS external_account credentials.\n_AWS_SUBJECT_TOKEN_TYPE = \"urn:ietf:params:aws:token-type:aws4_request\"\n\n\ndef _warn_about_problematic_credentials(credentials):\n    \"\"\"Determines if the credentials are problematic.\n\n    Credentials from the Cloud SDK that are associated with Cloud SDK's project\n    are problematic because they may not have APIs enabled and have limited\n    quota. If this is the case, warn about it.\n    \"\"\"\n    from google.auth import _cloud_sdk\n\n    if credentials.client_id == _cloud_sdk.CLOUD_SDK_CLIENT_ID:\n        warnings.warn(_CLOUD_SDK_CREDENTIALS_WARNING)\n\n\ndef load_credentials_from_file(\n    filename, scopes=None, default_scopes=None, quota_project_id=None, request=None\n):\n    \"\"\"Loads Google credentials from a file.\n\n    The credentials file must be a service account key, stored authorized\n    user credentials, external account credentials, or impersonated service\n    account credentials.\n\n    Args:\n        filename (str): The full path to the credentials file.\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n        quota_project_id (Optional[str]):  The project ID used for\n            quota and billing.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to determine the associated project ID\n            for a workload identity pool resource (external account credentials).\n            If not specified, then it will use a\n            google.auth.transport.requests.Request client to make requests.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. Authorized user credentials do not\n            have the project ID information. External account credentials project\n            IDs may not always be determined.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the file is in the\n            wrong format or is missing.\n    \"\"\"\n    if not os.path.exists(filename):\n        raise exceptions.DefaultCredentialsError(\n            \"File {} was not found.\".format(filename)\n        )\n\n    with io.open(filename, \"r\") as file_obj:\n        try:\n            info = json.load(file_obj)\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"File {} is not a valid json file.\".format(filename), caught_exc\n            )\n            raise new_exc from caught_exc\n    return _load_credentials_from_info(\n        filename, info, scopes, default_scopes, quota_project_id, request\n    )\n\n\ndef load_credentials_from_dict(\n    info, scopes=None, default_scopes=None, quota_project_id=None, request=None\n):\n    \"\"\"Loads Google credentials from a dict.\n\n    The credentials file must be a service account key, stored authorized\n    user credentials, external account credentials, or impersonated service\n    account credentials.\n\n    Args:\n        info (Dict[str, Any]): A dict object containing the credentials\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n        quota_project_id (Optional[str]):  The project ID used for\n            quota and billing.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to determine the associated project ID\n            for a workload identity pool resource (external account credentials).\n            If not specified, then it will use a\n            google.auth.transport.requests.Request client to make requests.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. Authorized user credentials do not\n            have the project ID information. External account credentials project\n            IDs may not always be determined.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the file is in the\n            wrong format or is missing.\n    \"\"\"\n    if not isinstance(info, dict):\n        raise exceptions.DefaultCredentialsError(\n            \"info object was of type {} but dict type was expected.\".format(type(info))\n        )\n\n    return _load_credentials_from_info(\n        \"dict object\", info, scopes, default_scopes, quota_project_id, request\n    )\n\n\ndef _load_credentials_from_info(\n    filename, info, scopes, default_scopes, quota_project_id, request\n):\n    from google.auth.credentials import CredentialsWithQuotaProject\n\n    credential_type = info.get(\"type\")\n\n    if credential_type == _AUTHORIZED_USER_TYPE:\n        credentials, project_id = _get_authorized_user_credentials(\n            filename, info, scopes\n        )\n\n    elif credential_type == _SERVICE_ACCOUNT_TYPE:\n        credentials, project_id = _get_service_account_credentials(\n            filename, info, scopes, default_scopes\n        )\n\n    elif credential_type == _EXTERNAL_ACCOUNT_TYPE:\n        credentials, project_id = _get_external_account_credentials(\n            info,\n            filename,\n            scopes=scopes,\n            default_scopes=default_scopes,\n            request=request,\n        )\n\n    elif credential_type == _EXTERNAL_ACCOUNT_AUTHORIZED_USER_TYPE:\n        credentials, project_id = _get_external_account_authorized_user_credentials(\n            filename, info, request\n        )\n\n    elif credential_type == _IMPERSONATED_SERVICE_ACCOUNT_TYPE:\n        credentials, project_id = _get_impersonated_service_account_credentials(\n            filename, info, scopes\n        )\n    elif credential_type == _GDCH_SERVICE_ACCOUNT_TYPE:\n        credentials, project_id = _get_gdch_service_account_credentials(filename, info)\n    else:\n        raise exceptions.DefaultCredentialsError(\n            \"The file {file} does not have a valid type. \"\n            \"Type is {type}, expected one of {valid_types}.\".format(\n                file=filename, type=credential_type, valid_types=_VALID_TYPES\n            )\n        )\n    if isinstance(credentials, CredentialsWithQuotaProject):\n        credentials = _apply_quota_project_id(credentials, quota_project_id)\n    return credentials, project_id\n\n\ndef _get_gcloud_sdk_credentials(quota_project_id=None):\n    \"\"\"Gets the credentials and project ID from the Cloud SDK.\"\"\"\n    from google.auth import _cloud_sdk\n\n    _LOGGER.debug(\"Checking Cloud SDK credentials as part of auth process...\")\n\n    # Check if application default credentials exist.\n    credentials_filename = _cloud_sdk.get_application_default_credentials_path()\n\n    if not os.path.isfile(credentials_filename):\n        _LOGGER.debug(\"Cloud SDK credentials not found on disk; not using them\")\n        return None, None\n\n    credentials, project_id = load_credentials_from_file(\n        credentials_filename, quota_project_id=quota_project_id\n    )\n\n    if not project_id:\n        project_id = _cloud_sdk.get_project_id()\n\n    return credentials, project_id\n\n\ndef _get_explicit_environ_credentials(quota_project_id=None):\n    \"\"\"Gets credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    variable.\"\"\"\n    from google.auth import _cloud_sdk\n\n    cloud_sdk_adc_path = _cloud_sdk.get_application_default_credentials_path()\n    explicit_file = os.environ.get(environment_vars.CREDENTIALS)\n\n    _LOGGER.debug(\n        \"Checking %s for explicit credentials as part of auth process...\", explicit_file\n    )\n\n    if explicit_file is not None and explicit_file == cloud_sdk_adc_path:\n        # Cloud sdk flow calls gcloud to fetch project id, so if the explicit\n        # file path is cloud sdk credentials path, then we should fall back\n        # to cloud sdk flow, otherwise project id cannot be obtained.\n        _LOGGER.debug(\n            \"Explicit credentials path %s is the same as Cloud SDK credentials path, fall back to Cloud SDK credentials flow...\",\n            explicit_file,\n        )\n        return _get_gcloud_sdk_credentials(quota_project_id=quota_project_id)\n\n    if explicit_file is not None:\n        credentials, project_id = load_credentials_from_file(\n            os.environ[environment_vars.CREDENTIALS], quota_project_id=quota_project_id\n        )\n\n        return credentials, project_id\n\n    else:\n        return None, None\n\n\ndef _get_gae_credentials():\n    \"\"\"Gets Google App Engine App Identity credentials and project ID.\"\"\"\n    # If not GAE gen1, prefer the metadata service even if the GAE APIs are\n    # available as per https://google.aip.dev/auth/4115.\n    if os.environ.get(environment_vars.LEGACY_APPENGINE_RUNTIME) != \"python27\":\n        return None, None\n\n    # While this library is normally bundled with app_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n    try:\n        _LOGGER.debug(\"Checking for App Engine runtime as part of auth process...\")\n        import google.auth.app_engine as app_engine\n    except ImportError:\n        _LOGGER.warning(\"Import of App Engine auth library failed.\")\n        return None, None\n\n    try:\n        credentials = app_engine.Credentials()\n        project_id = app_engine.get_project_id()\n        return credentials, project_id\n    except EnvironmentError:\n        _LOGGER.debug(\n            \"No App Engine library was found so cannot authentication via App Engine Identity Credentials.\"\n        )\n        return None, None\n\n\ndef _get_gce_credentials(request=None, quota_project_id=None):\n    \"\"\"Gets credentials and project ID from the GCE Metadata Service.\"\"\"\n    # Ping requires a transport, but we want application default credentials\n    # to require no arguments. So, we'll use the _http_client transport which\n    # uses http.client. This is only acceptable because the metadata server\n    # doesn't do SSL and never requires proxies.\n\n    # While this library is normally bundled with compute_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n    try:\n        from google.auth import compute_engine\n        from google.auth.compute_engine import _metadata\n    except ImportError:\n        _LOGGER.warning(\"Import of Compute Engine auth library failed.\")\n        return None, None\n\n    if request is None:\n        request = google.auth.transport._http_client.Request()\n\n    if _metadata.is_on_gce(request=request):\n        # Get the project ID.\n        try:\n            project_id = _metadata.get_project_id(request=request)\n        except exceptions.TransportError:\n            project_id = None\n\n        cred = compute_engine.Credentials()\n        cred = _apply_quota_project_id(cred, quota_project_id)\n\n        return cred, project_id\n    else:\n        _LOGGER.warning(\n            \"Authentication failed using Compute Engine authentication due to unavailable metadata server.\"\n        )\n        return None, None\n\n\ndef _get_external_account_credentials(\n    info, filename, scopes=None, default_scopes=None, request=None\n):\n    \"\"\"Loads external account Credentials from the parsed external account info.\n\n    The credentials information must correspond to a supported external account\n    credentials.\n\n    Args:\n        info (Mapping[str, str]): The external account info in Google format.\n        filename (str): The full path to the credentials file.\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary.\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to determine the associated project ID\n            for a workload identity pool resource (external account credentials).\n            If not specified, then it will use a\n            google.auth.transport.requests.Request client to make requests.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. External account credentials project\n            IDs may not always be determined.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the info dictionary\n            is in the wrong format or is missing required information.\n    \"\"\"\n    # There are currently 3 types of external_account credentials.\n    if info.get(\"subject_token_type\") == _AWS_SUBJECT_TOKEN_TYPE:\n        # Check if configuration corresponds to an AWS credentials.\n        from google.auth import aws\n\n        credentials = aws.Credentials.from_info(\n            info, scopes=scopes, default_scopes=default_scopes\n        )\n    elif (\n        info.get(\"credential_source\") is not None\n        and info.get(\"credential_source\").get(\"executable\") is not None\n    ):\n        from google.auth import pluggable\n\n        credentials = pluggable.Credentials.from_info(\n            info, scopes=scopes, default_scopes=default_scopes\n        )\n    else:\n        try:\n            # Check if configuration corresponds to an Identity Pool credentials.\n            from google.auth import identity_pool\n\n            credentials = identity_pool.Credentials.from_info(\n                info, scopes=scopes, default_scopes=default_scopes\n            )\n        except ValueError:\n            # If the configuration is invalid or does not correspond to any\n            # supported external_account credentials, raise an error.\n            raise exceptions.DefaultCredentialsError(\n                \"Failed to load external account credentials from {}\".format(filename)\n            )\n    if request is None:\n        import google.auth.transport.requests\n\n        request = google.auth.transport.requests.Request()\n\n    return credentials, credentials.get_project_id(request=request)\n\n\ndef _get_external_account_authorized_user_credentials(\n    filename, info, scopes=None, default_scopes=None, request=None\n):\n    try:\n        from google.auth import external_account_authorized_user\n\n        credentials = external_account_authorized_user.Credentials.from_info(info)\n    except ValueError:\n        raise exceptions.DefaultCredentialsError(\n            \"Failed to load external account authorized user credentials from {}\".format(\n                filename\n            )\n        )\n\n    return credentials, None\n\n\ndef _get_authorized_user_credentials(filename, info, scopes=None):\n    from google.oauth2 import credentials\n\n    try:\n        credentials = credentials.Credentials.from_authorized_user_info(\n            info, scopes=scopes\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load authorized user credentials from {}\".format(filename)\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, None\n\n\ndef _get_service_account_credentials(filename, info, scopes=None, default_scopes=None):\n    from google.oauth2 import service_account\n\n    try:\n        credentials = service_account.Credentials.from_service_account_info(\n            info, scopes=scopes, default_scopes=default_scopes\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load service account credentials from {}\".format(filename)\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, info.get(\"project_id\")\n\n\ndef _get_impersonated_service_account_credentials(filename, info, scopes):\n    from google.auth import impersonated_credentials\n\n    try:\n        source_credentials_info = info.get(\"source_credentials\")\n        source_credentials_type = source_credentials_info.get(\"type\")\n        if source_credentials_type == _AUTHORIZED_USER_TYPE:\n            source_credentials, _ = _get_authorized_user_credentials(\n                filename, source_credentials_info\n            )\n        elif source_credentials_type == _SERVICE_ACCOUNT_TYPE:\n            source_credentials, _ = _get_service_account_credentials(\n                filename, source_credentials_info\n            )\n        else:\n            raise exceptions.InvalidType(\n                \"source credential of type {} is not supported.\".format(\n                    source_credentials_type\n                )\n            )\n        impersonation_url = info.get(\"service_account_impersonation_url\")\n        start_index = impersonation_url.rfind(\"/\")\n        end_index = impersonation_url.find(\":generateAccessToken\")\n        if start_index == -1 or end_index == -1 or start_index > end_index:\n            raise exceptions.InvalidValue(\n                \"Cannot extract target principal from {}\".format(impersonation_url)\n            )\n        target_principal = impersonation_url[start_index + 1 : end_index]\n        delegates = info.get(\"delegates\")\n        quota_project_id = info.get(\"quota_project_id\")\n        credentials = impersonated_credentials.Credentials(\n            source_credentials,\n            target_principal,\n            scopes,\n            delegates,\n            quota_project_id=quota_project_id,\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load impersonated service account credentials from {}\".format(\n            filename\n        )\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, None\n\n\ndef _get_gdch_service_account_credentials(filename, info):\n    from google.oauth2 import gdch_credentials\n\n    try:\n        credentials = gdch_credentials.ServiceAccountCredentials.from_service_account_info(\n            info\n        )\n    except ValueError as caught_exc:\n        msg = \"Failed to load GDCH service account credentials from {}\".format(filename)\n        new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n        raise new_exc from caught_exc\n    return credentials, info.get(\"project\")\n\n\ndef get_api_key_credentials(key):\n    \"\"\"Return credentials with the given API key.\"\"\"\n    from google.auth import api_key\n\n    return api_key.Credentials(key)\n\n\ndef _apply_quota_project_id(credentials, quota_project_id):\n    if quota_project_id:\n        credentials = credentials.with_quota_project(quota_project_id)\n    else:\n        credentials = credentials.with_quota_project_from_environment()\n\n    from google.oauth2 import credentials as authorized_user_credentials\n\n    if isinstance(credentials, authorized_user_credentials.Credentials) and (\n        not credentials.quota_project_id\n    ):\n        _warn_about_problematic_credentials(credentials)\n    return credentials\n\n\ndef default(scopes=None, request=None, quota_project_id=None, default_scopes=None):\n    \"\"\"Gets the default credentials for the current environment.\n\n    `Application Default Credentials`_ provides an easy way to obtain\n    credentials to call Google APIs for server-to-server or local applications.\n    This function acquires credentials from the environment in the following\n    order:\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON private key file, then it is\n       loaded and returned. The project ID returned is the project ID defined\n       in the service account file if available (some older files do not\n       contain project ID information).\n\n       If the environment variable is set to the path of a valid external\n       account JSON configuration file (workload identity federation), then the\n       configuration file is used to determine and retrieve the external\n       credentials from the current environment (AWS, Azure, etc).\n       These will then be exchanged for Google access tokens via the Google STS\n       endpoint.\n       The project ID returned in this case is the one corresponding to the\n       underlying workload identity pool resource if determinable.\n\n       If the environment variable is set to the path of a valid GDCH service\n       account JSON file (`Google Distributed Cloud Hosted`_), then a GDCH\n       credential will be returned. The project ID returned is the project\n       specified in the JSON file.\n    2. If the `Google Cloud SDK`_ is installed and has application default\n       credentials set they are loaded and returned.\n\n       To enable application default credentials with the Cloud SDK run::\n\n            gcloud auth application-default login\n\n       If the Cloud SDK has an active project, the project ID is returned. The\n       active project can be set using::\n\n            gcloud config set project\n\n    3. If the application is running in the `App Engine standard environment`_\n       (first generation) then the credentials and project ID from the\n       `App Identity Service`_ are used.\n    4. If the application is running in `Compute Engine`_ or `Cloud Run`_ or\n       the `App Engine flexible environment`_ or the `App Engine standard\n       environment`_ (second generation) then the credentials and project ID\n       are obtained from the `Metadata Service`_.\n    5. If no credentials are found,\n       :class:`~google.auth.exceptions.DefaultCredentialsError` will be raised.\n\n    .. _Application Default Credentials: https://developers.google.com\\\n            /identity/protocols/application-default-credentials\n    .. _Google Cloud SDK: https://cloud.google.com/sdk\n    .. _App Engine standard environment: https://cloud.google.com/appengine\n    .. _App Identity Service: https://cloud.google.com/appengine/docs/python\\\n            /appidentity/\n    .. _Compute Engine: https://cloud.google.com/compute\n    .. _App Engine flexible environment: https://cloud.google.com\\\n            /appengine/flexible\n    .. _Metadata Service: https://cloud.google.com/compute/docs\\\n            /storing-retrieving-metadata\n    .. _Cloud Run: https://cloud.google.com/run\n    .. _Google Distributed Cloud Hosted: https://cloud.google.com/blog/topics\\\n            /hybrid-cloud/announcing-google-distributed-cloud-edge-and-hosted\n\n    Example::\n\n        import google.auth\n\n        credentials, project_id = google.auth.default()\n\n    Args:\n        scopes (Sequence[str]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary.\n        request (Optional[google.auth.transport.Request]): An object used to make\n            HTTP requests. This is used to either detect whether the application\n            is running on Compute Engine or to determine the associated project\n            ID for a workload identity pool resource (external account\n            credentials). If not specified, then it will either use the standard\n            library http client to make requests for Compute Engine credentials\n            or a google.auth.transport.requests.Request client for external\n            account credentials.\n        quota_project_id (Optional[str]): The project ID used for\n            quota and billing.\n        default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n    Returns:\n        Tuple[~google.auth.credentials.Credentials, Optional[str]]:\n            the current environment's credentials and project ID. Project ID\n            may be None, which indicates that the Project ID could not be\n            ascertained from the environment.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If no credentials were found, or if the credentials found were\n            invalid.\n    \"\"\"\n    from google.auth.credentials import with_scopes_if_required\n    from google.auth.credentials import CredentialsWithQuotaProject\n\n    explicit_project_id = os.environ.get(\n        environment_vars.PROJECT, os.environ.get(environment_vars.LEGACY_PROJECT)\n    )\n\n    checkers = (\n        # Avoid passing scopes here to prevent passing scopes to user credentials.\n        # with_scopes_if_required() below will ensure scopes/default scopes are\n        # safely set on the returned credentials since requires_scopes will\n        # guard against setting scopes on user credentials.\n        lambda: _get_explicit_environ_credentials(quota_project_id=quota_project_id),\n        lambda: _get_gcloud_sdk_credentials(quota_project_id=quota_project_id),\n        _get_gae_credentials,\n        lambda: _get_gce_credentials(request, quota_project_id=quota_project_id),\n    )\n\n    for checker in checkers:\n        credentials, project_id = checker()\n        if credentials is not None:\n            credentials = with_scopes_if_required(\n                credentials, scopes, default_scopes=default_scopes\n            )\n\n            effective_project_id = explicit_project_id or project_id\n\n            # For external account credentials, scopes are required to determine\n            # the project ID. Try to get the project ID again if not yet\n            # determined.\n            if not effective_project_id and callable(\n                getattr(credentials, \"get_project_id\", None)\n            ):\n                if request is None:\n                    import google.auth.transport.requests\n\n                    request = google.auth.transport.requests.Request()\n                effective_project_id = credentials.get_project_id(request=request)\n\n            if quota_project_id and isinstance(\n                credentials, CredentialsWithQuotaProject\n            ):\n                credentials = credentials.with_quota_project(quota_project_id)\n\n            if not effective_project_id:\n                _LOGGER.warning(\n                    \"No project ID could be determined. Consider running \"\n                    \"`gcloud config set project` or setting the %s \"\n                    \"environment variable\",\n                    environment_vars.PROJECT,\n                )\n            return credentials, effective_project_id\n\n    raise exceptions.DefaultCredentialsError(_CLOUD_SDK_MISSING_CREDENTIALS)\n", "google/auth/impersonated_credentials.py": "# Copyright 2018 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Cloud Impersonated credentials.\n\nThis module provides authentication for applications where local credentials\nimpersonates a remote service account using `IAM Credentials API`_.\n\nThis class can be used to impersonate a service account as long as the original\nCredential object has the \"Service Account Token Creator\" role on the target\nservice account.\n\n    .. _IAM Credentials API:\n        https://cloud.google.com/iam/credentials/reference/rest/\n\"\"\"\n\nimport base64\nimport copy\nfrom datetime import datetime\nimport http.client as http_client\nimport json\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import metrics\n\n\n_REFRESH_ERROR = \"Unable to acquire impersonated credentials\"\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n\n\ndef _make_iam_token_request(\n    request, principal, headers, body, iam_endpoint_override=None\n):\n    \"\"\"Makes a request to the Google Cloud IAM service for an access token.\n    Args:\n        request (Request): The Request object to use.\n        principal (str): The principal to request an access token for.\n        headers (Mapping[str, str]): Map of headers to transmit.\n        body (Mapping[str, str]): JSON Payload body for the iamcredentials\n            API call.\n        iam_endpoint_override (Optiona[str]): The full IAM endpoint override\n            with the target_principal embedded. This is useful when supporting\n            impersonation with regional endpoints.\n\n    Raises:\n        google.auth.exceptions.TransportError: Raised if there is an underlying\n            HTTP connection error\n        google.auth.exceptions.RefreshError: Raised if the impersonated\n            credentials are not available.  Common reasons are\n            `iamcredentials.googleapis.com` is not enabled or the\n            `Service Account Token Creator` is not assigned\n    \"\"\"\n    iam_endpoint = iam_endpoint_override or iam._IAM_ENDPOINT.format(principal)\n\n    body = json.dumps(body).encode(\"utf-8\")\n\n    response = request(url=iam_endpoint, method=\"POST\", headers=headers, body=body)\n\n    # support both string and bytes type response.data\n    response_body = (\n        response.data.decode(\"utf-8\")\n        if hasattr(response.data, \"decode\")\n        else response.data\n    )\n\n    if response.status != http_client.OK:\n        raise exceptions.RefreshError(_REFRESH_ERROR, response_body)\n\n    try:\n        token_response = json.loads(response_body)\n        token = token_response[\"accessToken\"]\n        expiry = datetime.strptime(token_response[\"expireTime\"], \"%Y-%m-%dT%H:%M:%SZ\")\n\n        return token, expiry\n\n    except (KeyError, ValueError) as caught_exc:\n        new_exc = exceptions.RefreshError(\n            \"{}: No access token or invalid expiration in response.\".format(\n                _REFRESH_ERROR\n            ),\n            response_body,\n        )\n        raise new_exc from caught_exc\n\n\nclass Credentials(\n    credentials.Scoped, credentials.CredentialsWithQuotaProject, credentials.Signing\n):\n    \"\"\"This module defines impersonated credentials which are essentially\n    impersonated identities.\n\n    Impersonated Credentials allows credentials issued to a user or\n    service account to impersonate another. The target service account must\n    grant the originating credential principal the\n    `Service Account Token Creator`_ IAM role:\n\n    For more information about Token Creator IAM role and\n    IAMCredentials API, see\n    `Creating Short-Lived Service Account Credentials`_.\n\n    .. _Service Account Token Creator:\n        https://cloud.google.com/iam/docs/service-accounts#the_service_account_token_creator_role\n\n    .. _Creating Short-Lived Service Account Credentials:\n        https://cloud.google.com/iam/docs/creating-short-lived-service-account-credentials\n\n    Usage:\n\n    First grant source_credentials the `Service Account Token Creator`\n    role on the target account to impersonate.   In this example, the\n    service account represented by svc_account.json has the\n    token creator role on\n    `impersonated-account@_project_.iam.gserviceaccount.com`.\n\n    Enable the IAMCredentials API on the source project:\n    `gcloud services enable iamcredentials.googleapis.com`.\n\n    Initialize a source credential which does not have access to\n    list bucket::\n\n        from google.oauth2 import service_account\n\n        target_scopes = [\n            'https://www.googleapis.com/auth/devstorage.read_only']\n\n        source_credentials = (\n            service_account.Credentials.from_service_account_file(\n                '/path/to/svc_account.json',\n                scopes=target_scopes))\n\n    Now use the source credentials to acquire credentials to impersonate\n    another service account::\n\n        from google.auth import impersonated_credentials\n\n        target_credentials = impersonated_credentials.Credentials(\n          source_credentials=source_credentials,\n          target_principal='impersonated-account@_project_.iam.gserviceaccount.com',\n          target_scopes = target_scopes,\n          lifetime=500)\n\n    Resource access is granted::\n\n        client = storage.Client(credentials=target_credentials)\n        buckets = client.list_buckets(project='your_project')\n        for bucket in buckets:\n          print(bucket.name)\n    \"\"\"\n\n    def __init__(\n        self,\n        source_credentials,\n        target_principal,\n        target_scopes,\n        delegates=None,\n        lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,\n        quota_project_id=None,\n        iam_endpoint_override=None,\n    ):\n        \"\"\"\n        Args:\n            source_credentials (google.auth.Credentials): The source credential\n                used as to acquire the impersonated credentials.\n            target_principal (str): The service account to impersonate.\n            target_scopes (Sequence[str]): Scopes to request during the\n                authorization grant.\n            delegates (Sequence[str]): The chained list of delegates required\n                to grant the final access_token.  If set, the sequence of\n                identities must have \"Service Account Token Creator\" capability\n                granted to the prceeding identity.  For example, if set to\n                [serviceAccountB, serviceAccountC], the source_credential\n                must have the Token Creator role on serviceAccountB.\n                serviceAccountB must have the Token Creator on\n                serviceAccountC.\n                Finally, C must have Token Creator on target_principal.\n                If left unset, source_credential must have that role on\n                target_principal.\n            lifetime (int): Number of seconds the delegated credential should\n                be valid for (upto 3600).\n            quota_project_id (Optional[str]): The project ID used for quota and billing.\n                This project may be different from the project used to\n                create the credentials.\n            iam_endpoint_override (Optiona[str]): The full IAM endpoint override\n                with the target_principal embedded. This is useful when supporting\n                impersonation with regional endpoints.\n        \"\"\"\n\n        super(Credentials, self).__init__()\n\n        self._source_credentials = copy.copy(source_credentials)\n        # Service account source credentials must have the _IAM_SCOPE\n        # added to refresh correctly. User credentials cannot have\n        # their original scopes modified.\n        if isinstance(self._source_credentials, credentials.Scoped):\n            self._source_credentials = self._source_credentials.with_scopes(\n                iam._IAM_SCOPE\n            )\n            # If the source credential is service account and self signed jwt\n            # is needed, we need to create a jwt credential inside it\n            if (\n                hasattr(self._source_credentials, \"_create_self_signed_jwt\")\n                and self._source_credentials._always_use_jwt_access\n            ):\n                self._source_credentials._create_self_signed_jwt(None)\n        self._target_principal = target_principal\n        self._target_scopes = target_scopes\n        self._delegates = delegates\n        self._lifetime = lifetime or _DEFAULT_TOKEN_LIFETIME_SECS\n        self.token = None\n        self.expiry = _helpers.utcnow()\n        self._quota_project_id = quota_project_id\n        self._iam_endpoint_override = iam_endpoint_override\n\n    def _metric_header_for_usage(self):\n        return metrics.CRED_TYPE_SA_IMPERSONATE\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        self._update_token(request)\n\n    def _update_token(self, request):\n        \"\"\"Updates credentials with a new access_token representing\n        the impersonated account.\n\n        Args:\n            request (google.auth.transport.requests.Request): Request object\n                to use for refreshing credentials.\n        \"\"\"\n\n        # Refresh our source credentials if it is not valid.\n        if (\n            self._source_credentials.token_state == credentials.TokenState.STALE\n            or self._source_credentials.token_state == credentials.TokenState.INVALID\n        ):\n            self._source_credentials.refresh(request)\n\n        body = {\n            \"delegates\": self._delegates,\n            \"scope\": self._target_scopes,\n            \"lifetime\": str(self._lifetime) + \"s\",\n        }\n\n        headers = {\n            \"Content-Type\": \"application/json\",\n            metrics.API_CLIENT_HEADER: metrics.token_request_access_token_impersonate(),\n        }\n\n        # Apply the source credentials authentication info.\n        self._source_credentials.apply(headers)\n\n        self.token, self.expiry = _make_iam_token_request(\n            request=request,\n            principal=self._target_principal,\n            headers=headers,\n            body=body,\n            iam_endpoint_override=self._iam_endpoint_override,\n        )\n\n    def sign_bytes(self, message):\n        from google.auth.transport.requests import AuthorizedSession\n\n        iam_sign_endpoint = iam._IAM_SIGN_ENDPOINT.format(self._target_principal)\n\n        body = {\n            \"payload\": base64.b64encode(message).decode(\"utf-8\"),\n            \"delegates\": self._delegates,\n        }\n\n        headers = {\"Content-Type\": \"application/json\"}\n\n        authed_session = AuthorizedSession(self._source_credentials)\n\n        try:\n            response = authed_session.post(\n                url=iam_sign_endpoint, headers=headers, json=body\n            )\n        finally:\n            authed_session.close()\n\n        if response.status_code != http_client.OK:\n            raise exceptions.TransportError(\n                \"Error calling sign_bytes: {}\".format(response.json())\n            )\n\n        return base64.b64decode(response.json()[\"signedBlob\"])\n\n    @property\n    def signer_email(self):\n        return self._target_principal\n\n    @property\n    def service_account_email(self):\n        return self._target_principal\n\n    @property\n    def signer(self):\n        return self\n\n    @property\n    def requires_scopes(self):\n        return not self._target_scopes\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            self._source_credentials,\n            target_principal=self._target_principal,\n            target_scopes=self._target_scopes,\n            delegates=self._delegates,\n            lifetime=self._lifetime,\n            quota_project_id=quota_project_id,\n            iam_endpoint_override=self._iam_endpoint_override,\n        )\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        return self.__class__(\n            self._source_credentials,\n            target_principal=self._target_principal,\n            target_scopes=scopes or default_scopes,\n            delegates=self._delegates,\n            lifetime=self._lifetime,\n            quota_project_id=self._quota_project_id,\n            iam_endpoint_override=self._iam_endpoint_override,\n        )\n\n\nclass IDTokenCredentials(credentials.CredentialsWithQuotaProject):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    \"\"\"\n\n    def __init__(\n        self,\n        target_credentials,\n        target_audience=None,\n        include_email=False,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            target_credentials (google.auth.Credentials): The target\n                credential used as to acquire the id tokens for.\n            target_audience (string): Audience to issue the token for.\n            include_email (bool): Include email in IdToken\n            quota_project_id (Optional[str]):  The project ID used for\n                quota and billing.\n        \"\"\"\n        super(IDTokenCredentials, self).__init__()\n\n        if not isinstance(target_credentials, Credentials):\n            raise exceptions.GoogleAuthError(\n                \"Provided Credential must be \" \"impersonated_credentials\"\n            )\n        self._target_credentials = target_credentials\n        self._target_audience = target_audience\n        self._include_email = include_email\n        self._quota_project_id = quota_project_id\n\n    def from_credentials(self, target_credentials, target_audience=None):\n        return self.__class__(\n            target_credentials=target_credentials,\n            target_audience=target_audience,\n            include_email=self._include_email,\n            quota_project_id=self._quota_project_id,\n        )\n\n    def with_target_audience(self, target_audience):\n        return self.__class__(\n            target_credentials=self._target_credentials,\n            target_audience=target_audience,\n            include_email=self._include_email,\n            quota_project_id=self._quota_project_id,\n        )\n\n    def with_include_email(self, include_email):\n        return self.__class__(\n            target_credentials=self._target_credentials,\n            target_audience=self._target_audience,\n            include_email=include_email,\n            quota_project_id=self._quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            target_credentials=self._target_credentials,\n            target_audience=self._target_audience,\n            include_email=self._include_email,\n            quota_project_id=quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        from google.auth.transport.requests import AuthorizedSession\n\n        iam_sign_endpoint = iam._IAM_IDTOKEN_ENDPOINT.format(\n            self._target_credentials.signer_email\n        )\n\n        body = {\n            \"audience\": self._target_audience,\n            \"delegates\": self._target_credentials._delegates,\n            \"includeEmail\": self._include_email,\n        }\n\n        headers = {\n            \"Content-Type\": \"application/json\",\n            metrics.API_CLIENT_HEADER: metrics.token_request_id_token_impersonate(),\n        }\n\n        authed_session = AuthorizedSession(\n            self._target_credentials._source_credentials, auth_request=request\n        )\n\n        try:\n            response = authed_session.post(\n                url=iam_sign_endpoint,\n                headers=headers,\n                data=json.dumps(body).encode(\"utf-8\"),\n            )\n        finally:\n            authed_session.close()\n\n        if response.status_code != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Error getting ID token: {}\".format(response.json())\n            )\n\n        id_token = response.json()[\"token\"]\n        self.token = id_token\n        self.expiry = datetime.utcfromtimestamp(\n            jwt.decode(id_token, verify=False)[\"exp\"]\n        )\n", "google/auth/pluggable.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Pluggable Credentials.\nPluggable Credentials are initialized using external_account arguments which\nare typically loaded from third-party executables. Unlike other\ncredentials that can be initialized with a list of explicit arguments, secrets\nor credentials, external account clients use the environment and hints/guidelines\nprovided by the external_account JSON file to retrieve credentials and exchange\nthem for Google access tokens.\n\nExample credential_source for pluggable credential:\n{\n    \"executable\": {\n        \"command\": \"/path/to/get/credentials.sh --arg1=value1 --arg2=value2\",\n        \"timeout_millis\": 5000,\n        \"output_file\": \"/path/to/generated/cached/credentials\"\n    }\n}\n\"\"\"\n\ntry:\n    from collections.abc import Mapping\n# Python 2.7 compatibility\nexcept ImportError:  # pragma: NO COVER\n    from collections import Mapping  # type: ignore\nimport json\nimport os\nimport subprocess\nimport sys\nimport time\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import external_account\n\n# The max supported executable spec version.\nEXECUTABLE_SUPPORTED_MAX_VERSION = 1\n\nEXECUTABLE_TIMEOUT_MILLIS_DEFAULT = 30 * 1000  # 30 seconds\nEXECUTABLE_TIMEOUT_MILLIS_LOWER_BOUND = 5 * 1000  # 5 seconds\nEXECUTABLE_TIMEOUT_MILLIS_UPPER_BOUND = 120 * 1000  # 2 minutes\n\nEXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_LOWER_BOUND = 30 * 1000  # 30 seconds\nEXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_UPPER_BOUND = 30 * 60 * 1000  # 30 minutes\n\n\nclass Credentials(external_account.Credentials):\n    \"\"\"External account credentials sourced from executables.\"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url,\n        credential_source,\n        *args,\n        **kwargs\n    ):\n        \"\"\"Instantiates an external account credentials object from a executables.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type.\n            token_url (str): The STS endpoint URL.\n            credential_source (Mapping): The credential source dictionary used to\n                provide instructions on how to retrieve external credential to be\n                exchanged for Google access tokens.\n\n                Example credential_source for pluggable credential:\n\n                    {\n                        \"executable\": {\n                            \"command\": \"/path/to/get/credentials.sh --arg1=value1 --arg2=value2\",\n                            \"timeout_millis\": 5000,\n                            \"output_file\": \"/path/to/generated/cached/credentials\"\n                        }\n                    }\n            args (List): Optional positional arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n            kwargs (Mapping): Optional keyword arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                access token retrieval logic.\n            google.auth.exceptions.InvalidValue: For invalid parameters.\n            google.auth.exceptions.MalformedError: For invalid parameters.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_file` or\n            :meth:`from_info` are used instead of calling the constructor directly.\n        \"\"\"\n\n        self.interactive = kwargs.pop(\"interactive\", False)\n        super(Credentials, self).__init__(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            credential_source=credential_source,\n            *args,\n            **kwargs\n        )\n        if not isinstance(credential_source, Mapping):\n            self._credential_source_executable = None\n            raise exceptions.MalformedError(\n                \"Missing credential_source. The credential_source is not a dict.\"\n            )\n        self._credential_source_executable = credential_source.get(\"executable\")\n        if not self._credential_source_executable:\n            raise exceptions.MalformedError(\n                \"Missing credential_source. An 'executable' must be provided.\"\n            )\n        self._credential_source_executable_command = self._credential_source_executable.get(\n            \"command\"\n        )\n        self._credential_source_executable_timeout_millis = self._credential_source_executable.get(\n            \"timeout_millis\"\n        )\n        self._credential_source_executable_interactive_timeout_millis = self._credential_source_executable.get(\n            \"interactive_timeout_millis\"\n        )\n        self._credential_source_executable_output_file = self._credential_source_executable.get(\n            \"output_file\"\n        )\n\n        # Dummy value. This variable is only used via injection, not exposed to ctor\n        self._tokeninfo_username = \"\"\n\n        if not self._credential_source_executable_command:\n            raise exceptions.MalformedError(\n                \"Missing command field. Executable command must be provided.\"\n            )\n        if not self._credential_source_executable_timeout_millis:\n            self._credential_source_executable_timeout_millis = (\n                EXECUTABLE_TIMEOUT_MILLIS_DEFAULT\n            )\n        elif (\n            self._credential_source_executable_timeout_millis\n            < EXECUTABLE_TIMEOUT_MILLIS_LOWER_BOUND\n            or self._credential_source_executable_timeout_millis\n            > EXECUTABLE_TIMEOUT_MILLIS_UPPER_BOUND\n        ):\n            raise exceptions.InvalidValue(\"Timeout must be between 5 and 120 seconds.\")\n\n        if self._credential_source_executable_interactive_timeout_millis:\n            if (\n                self._credential_source_executable_interactive_timeout_millis\n                < EXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_LOWER_BOUND\n                or self._credential_source_executable_interactive_timeout_millis\n                > EXECUTABLE_INTERACTIVE_TIMEOUT_MILLIS_UPPER_BOUND\n            ):\n                raise exceptions.InvalidValue(\n                    \"Interactive timeout must be between 30 seconds and 30 minutes.\"\n                )\n\n    @_helpers.copy_docstring(external_account.Credentials)\n    def retrieve_subject_token(self, request):\n        self._validate_running_mode()\n\n        # Check output file.\n        if self._credential_source_executable_output_file is not None:\n            try:\n                with open(\n                    self._credential_source_executable_output_file, encoding=\"utf-8\"\n                ) as output_file:\n                    response = json.load(output_file)\n            except Exception:\n                pass\n            else:\n                try:\n                    # If the cached response is expired, _parse_subject_token will raise an error which will be ignored and we will call the executable again.\n                    subject_token = self._parse_subject_token(response)\n                    if (\n                        \"expiration_time\" not in response\n                    ):  # Always treat missing expiration_time as expired and proceed to executable run.\n                        raise exceptions.RefreshError\n                except (exceptions.MalformedError, exceptions.InvalidValue):\n                    raise\n                except exceptions.RefreshError:\n                    pass\n                else:\n                    return subject_token\n\n        if not _helpers.is_python_3():\n            raise exceptions.RefreshError(\n                \"Pluggable auth is only supported for python 3.7+\"\n            )\n\n        # Inject env vars.\n        env = os.environ.copy()\n        self._inject_env_variables(env)\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_REVOKE\"] = \"0\"\n\n        # Run executable.\n        exe_timeout = (\n            self._credential_source_executable_interactive_timeout_millis / 1000\n            if self.interactive\n            else self._credential_source_executable_timeout_millis / 1000\n        )\n        exe_stdin = sys.stdin if self.interactive else None\n        exe_stdout = sys.stdout if self.interactive else subprocess.PIPE\n        exe_stderr = sys.stdout if self.interactive else subprocess.STDOUT\n\n        result = subprocess.run(\n            self._credential_source_executable_command.split(),\n            timeout=exe_timeout,\n            stdin=exe_stdin,\n            stdout=exe_stdout,\n            stderr=exe_stderr,\n            env=env,\n        )\n        if result.returncode != 0:\n            raise exceptions.RefreshError(\n                \"Executable exited with non-zero return code {}. Error: {}\".format(\n                    result.returncode, result.stdout\n                )\n            )\n\n        # Handle executable output.\n        response = json.loads(result.stdout.decode(\"utf-8\")) if result.stdout else None\n        if not response and self._credential_source_executable_output_file is not None:\n            response = json.load(\n                open(self._credential_source_executable_output_file, encoding=\"utf-8\")\n            )\n\n        subject_token = self._parse_subject_token(response)\n        return subject_token\n\n    def revoke(self, request):\n        \"\"\"Revokes the subject token using the credential_source object.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Raises:\n            google.auth.exceptions.RefreshError: If the executable revocation\n                not properly executed.\n\n        \"\"\"\n        if not self.interactive:\n            raise exceptions.InvalidValue(\n                \"Revoke is only enabled under interactive mode.\"\n            )\n        self._validate_running_mode()\n\n        if not _helpers.is_python_3():\n            raise exceptions.RefreshError(\n                \"Pluggable auth is only supported for python 3.7+\"\n            )\n\n        # Inject variables\n        env = os.environ.copy()\n        self._inject_env_variables(env)\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_REVOKE\"] = \"1\"\n\n        # Run executable\n        result = subprocess.run(\n            self._credential_source_executable_command.split(),\n            timeout=self._credential_source_executable_interactive_timeout_millis\n            / 1000,\n            stdout=subprocess.PIPE,\n            stderr=subprocess.STDOUT,\n            env=env,\n        )\n\n        if result.returncode != 0:\n            raise exceptions.RefreshError(\n                \"Auth revoke failed on executable. Exit with non-zero return code {}. Error: {}\".format(\n                    result.returncode, result.stdout\n                )\n            )\n\n        response = json.loads(result.stdout.decode(\"utf-8\"))\n        self._validate_revoke_response(response)\n\n    @property\n    def external_account_id(self):\n        \"\"\"Returns the external account identifier.\n\n        When service account impersonation is used the identifier is the service\n        account email.\n\n        Without service account impersonation, this returns None, unless it is\n        being used by the Google Cloud CLI which populates this field.\n        \"\"\"\n\n        return self.service_account_email or self._tokeninfo_username\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates a Pluggable Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The Pluggable external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.pluggable.Credentials: The constructed\n                credentials.\n\n        Raises:\n            google.auth.exceptions.InvalidValue: For invalid parameters.\n            google.auth.exceptions.MalformedError: For invalid parameters.\n        \"\"\"\n        return super(Credentials, cls).from_info(info, **kwargs)\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates an Pluggable Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the Pluggable external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.pluggable.Credentials: The constructed\n                credentials.\n        \"\"\"\n        return super(Credentials, cls).from_file(filename, **kwargs)\n\n    def _inject_env_variables(self, env):\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_AUDIENCE\"] = self._audience\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_TOKEN_TYPE\"] = self._subject_token_type\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_ID\"] = self.external_account_id\n        env[\"GOOGLE_EXTERNAL_ACCOUNT_INTERACTIVE\"] = \"1\" if self.interactive else \"0\"\n\n        if self._service_account_impersonation_url is not None:\n            env[\n                \"GOOGLE_EXTERNAL_ACCOUNT_IMPERSONATED_EMAIL\"\n            ] = self.service_account_email\n        if self._credential_source_executable_output_file is not None:\n            env[\n                \"GOOGLE_EXTERNAL_ACCOUNT_OUTPUT_FILE\"\n            ] = self._credential_source_executable_output_file\n\n    def _parse_subject_token(self, response):\n        self._validate_response_schema(response)\n        if not response[\"success\"]:\n            if \"code\" not in response or \"message\" not in response:\n                raise exceptions.MalformedError(\n                    \"Error code and message fields are required in the response.\"\n                )\n            raise exceptions.RefreshError(\n                \"Executable returned unsuccessful response: code: {}, message: {}.\".format(\n                    response[\"code\"], response[\"message\"]\n                )\n            )\n        if \"expiration_time\" in response and response[\"expiration_time\"] < time.time():\n            raise exceptions.RefreshError(\n                \"The token returned by the executable is expired.\"\n            )\n        if \"token_type\" not in response:\n            raise exceptions.MalformedError(\n                \"The executable response is missing the token_type field.\"\n            )\n        if (\n            response[\"token_type\"] == \"urn:ietf:params:oauth:token-type:jwt\"\n            or response[\"token_type\"] == \"urn:ietf:params:oauth:token-type:id_token\"\n        ):  # OIDC\n            return response[\"id_token\"]\n        elif response[\"token_type\"] == \"urn:ietf:params:oauth:token-type:saml2\":  # SAML\n            return response[\"saml_response\"]\n        else:\n            raise exceptions.RefreshError(\"Executable returned unsupported token type.\")\n\n    def _validate_revoke_response(self, response):\n        self._validate_response_schema(response)\n        if not response[\"success\"]:\n            raise exceptions.RefreshError(\"Revoke failed with unsuccessful response.\")\n\n    def _validate_response_schema(self, response):\n        if \"version\" not in response:\n            raise exceptions.MalformedError(\n                \"The executable response is missing the version field.\"\n            )\n        if response[\"version\"] > EXECUTABLE_SUPPORTED_MAX_VERSION:\n            raise exceptions.RefreshError(\n                \"Executable returned unsupported version {}.\".format(\n                    response[\"version\"]\n                )\n            )\n\n        if \"success\" not in response:\n            raise exceptions.MalformedError(\n                \"The executable response is missing the success field.\"\n            )\n\n    def _validate_running_mode(self):\n        env_allow_executables = os.environ.get(\n            \"GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES\"\n        )\n        if env_allow_executables != \"1\":\n            raise exceptions.MalformedError(\n                \"Executables need to be explicitly allowed (set GOOGLE_EXTERNAL_ACCOUNT_ALLOW_EXECUTABLES to '1') to run.\"\n            )\n\n        if self.interactive and not self._credential_source_executable_output_file:\n            raise exceptions.MalformedError(\n                \"An output_file must be specified in the credential configuration for interactive mode.\"\n            )\n\n        if (\n            self.interactive\n            and not self._credential_source_executable_interactive_timeout_millis\n        ):\n            raise exceptions.InvalidOperation(\n                \"Interactive mode cannot run without an interactive timeout.\"\n            )\n\n        if self.interactive and not self.is_workforce_pool:\n            raise exceptions.InvalidValue(\n                \"Interactive mode is only enabled for workforce pool.\"\n            )\n\n    def _create_default_metrics_options(self):\n        metrics_options = super(Credentials, self)._create_default_metrics_options()\n        metrics_options[\"source\"] = \"executable\"\n        return metrics_options\n", "google/auth/credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\n\"\"\"Interfaces for credentials.\"\"\"\n\nimport abc\nfrom enum import Enum\nimport os\n\nfrom google.auth import _helpers, environment_vars\nfrom google.auth import exceptions\nfrom google.auth import metrics\nfrom google.auth._refresh_worker import RefreshThreadManager\n\nDEFAULT_UNIVERSE_DOMAIN = \"googleapis.com\"\n\n\nclass Credentials(metaclass=abc.ABCMeta):\n    \"\"\"Base class for all credentials.\n\n    All credentials have a :attr:`token` that is used for authentication and\n    may also optionally set an :attr:`expiry` to indicate when the token will\n    no longer be valid.\n\n    Most credentials will be :attr:`invalid` until :meth:`refresh` is called.\n    Credentials can do this automatically before the first HTTP request in\n    :meth:`before_request`.\n\n    Although the token and expiration will change as the credentials are\n    :meth:`refreshed <refresh>` and used, credentials should be considered\n    immutable. Various credentials will accept configuration such as private\n    keys, scopes, and other options. These options are not changeable after\n    construction. Some classes will provide mechanisms to copy the credentials\n    with modifications such as :meth:`ScopedCredentials.with_scopes`.\n    \"\"\"\n\n    def __init__(self):\n        self.token = None\n        \"\"\"str: The bearer token that can be used in HTTP headers to make\n        authenticated requests.\"\"\"\n        self.expiry = None\n        \"\"\"Optional[datetime]: When the token expires and is no longer valid.\n        If this is None, the token is assumed to never expire.\"\"\"\n        self._quota_project_id = None\n        \"\"\"Optional[str]: Project to use for quota and billing purposes.\"\"\"\n        self._trust_boundary = None\n        \"\"\"Optional[dict]: Cache of a trust boundary response which has a list\n        of allowed regions and an encoded string representation of credentials\n        trust boundary.\"\"\"\n        self._universe_domain = DEFAULT_UNIVERSE_DOMAIN\n        \"\"\"Optional[str]: The universe domain value, default is googleapis.com\n        \"\"\"\n\n        self._use_non_blocking_refresh = False\n        self._refresh_worker = RefreshThreadManager()\n\n    @property\n    def expired(self):\n        \"\"\"Checks if the credentials are expired.\n\n        Note that credentials can be invalid but not expired because\n        Credentials with :attr:`expiry` set to None is considered to never\n        expire.\n\n        .. deprecated:: v2.24.0\n          Prefer checking :attr:`token_state` instead.\n        \"\"\"\n        if not self.expiry:\n            return False\n        # Remove some threshold from expiry to err on the side of reporting\n        # expiration early so that we avoid the 401-refresh-retry loop.\n        skewed_expiry = self.expiry - _helpers.REFRESH_THRESHOLD\n        return _helpers.utcnow() >= skewed_expiry\n\n    @property\n    def valid(self):\n        \"\"\"Checks the validity of the credentials.\n\n        This is True if the credentials have a :attr:`token` and the token\n        is not :attr:`expired`.\n\n        .. deprecated:: v2.24.0\n          Prefer checking :attr:`token_state` instead.\n        \"\"\"\n        return self.token is not None and not self.expired\n\n    @property\n    def token_state(self):\n        \"\"\"\n        See `:obj:`TokenState`\n        \"\"\"\n        if self.token is None:\n            return TokenState.INVALID\n\n        # Credentials that can't expire are always treated as fresh.\n        if self.expiry is None:\n            return TokenState.FRESH\n\n        expired = _helpers.utcnow() >= self.expiry\n        if expired:\n            return TokenState.INVALID\n\n        is_stale = _helpers.utcnow() >= (self.expiry - _helpers.REFRESH_THRESHOLD)\n        if is_stale:\n            return TokenState.STALE\n\n        return TokenState.FRESH\n\n    @property\n    def quota_project_id(self):\n        \"\"\"Project to use for quota and billing purposes.\"\"\"\n        return self._quota_project_id\n\n    @property\n    def universe_domain(self):\n        \"\"\"The universe domain value.\"\"\"\n        return self._universe_domain\n\n    @abc.abstractmethod\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the credentials could\n                not be refreshed.\n        \"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Refresh must be implemented\")\n\n    def _metric_header_for_usage(self):\n        \"\"\"The x-goog-api-client header for token usage metric.\n\n        This header will be added to the API service requests in before_request\n        method. For example, \"cred-type/sa-jwt\" means service account self\n        signed jwt access token is used in the API service request\n        authorization header. Children credentials classes need to override\n        this method to provide the header value, if the token usage metric is\n        needed.\n\n        Returns:\n            str: The x-goog-api-client header value.\n        \"\"\"\n        return None\n\n    def apply(self, headers, token=None):\n        \"\"\"Apply the token to the authentication header.\n\n        Args:\n            headers (Mapping): The HTTP request headers.\n            token (Optional[str]): If specified, overrides the current access\n                token.\n        \"\"\"\n        headers[\"authorization\"] = \"Bearer {}\".format(\n            _helpers.from_bytes(token or self.token)\n        )\n        \"\"\"Trust boundary value will be a cached value from global lookup.\n\n        The response of trust boundary will be a list of regions and a hex\n        encoded representation.\n\n        An example of global lookup response:\n        {\n          \"locations\": [\n            \"us-central1\", \"us-east1\", \"europe-west1\", \"asia-east1\"\n          ]\n          \"encoded_locations\": \"0xA30\"\n        }\n        \"\"\"\n        if self._trust_boundary is not None:\n            headers[\"x-allowed-locations\"] = self._trust_boundary[\"encoded_locations\"]\n        if self.quota_project_id:\n            headers[\"x-goog-user-project\"] = self.quota_project_id\n\n    def _blocking_refresh(self, request):\n        if not self.valid:\n            self.refresh(request)\n\n    def _non_blocking_refresh(self, request):\n        use_blocking_refresh_fallback = False\n\n        if self.token_state == TokenState.STALE:\n            use_blocking_refresh_fallback = not self._refresh_worker.start_refresh(\n                self, request\n            )\n\n        if self.token_state == TokenState.INVALID or use_blocking_refresh_fallback:\n            self.refresh(request)\n            # If the blocking refresh succeeds then we can clear the error info\n            # on the background refresh worker, and perform refreshes in a\n            # background thread.\n            self._refresh_worker.clear_error()\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n\n        Refreshes the credentials if necessary, then calls :meth:`apply` to\n        apply the token to the authentication header.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            method (str): The request's HTTP method or the RPC method being\n                invoked.\n            url (str): The request's URI or the RPC service's URI.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (Subclasses may use these arguments to ascertain information about\n        # the http request.)\n        if self._use_non_blocking_refresh:\n            self._non_blocking_refresh(request)\n        else:\n            self._blocking_refresh(request)\n\n        metrics.add_metric_header(headers, self._metric_header_for_usage())\n        self.apply(headers)\n\n    def with_non_blocking_refresh(self):\n        self._use_non_blocking_refresh = True\n\n\nclass CredentialsWithQuotaProject(Credentials):\n    \"\"\"Abstract base for credentials supporting ``with_quota_project`` factory\"\"\"\n\n    def with_quota_project(self, quota_project_id):\n        \"\"\"Returns a copy of these credentials with a modified quota project.\n\n        Args:\n            quota_project_id (str): The project to use for quota and\n                billing purposes\n\n        Returns:\n            google.auth.credentials.Credentials: A new credentials instance.\n        \"\"\"\n        raise NotImplementedError(\"This credential does not support quota project.\")\n\n    def with_quota_project_from_environment(self):\n        quota_from_env = os.environ.get(environment_vars.GOOGLE_CLOUD_QUOTA_PROJECT)\n        if quota_from_env:\n            return self.with_quota_project(quota_from_env)\n        return self\n\n\nclass CredentialsWithTokenUri(Credentials):\n    \"\"\"Abstract base for credentials supporting ``with_token_uri`` factory\"\"\"\n\n    def with_token_uri(self, token_uri):\n        \"\"\"Returns a copy of these credentials with a modified token uri.\n\n        Args:\n            token_uri (str): The uri to use for fetching/exchanging tokens\n\n        Returns:\n            google.auth.credentials.Credentials: A new credentials instance.\n        \"\"\"\n        raise NotImplementedError(\"This credential does not use token uri.\")\n\n\nclass CredentialsWithUniverseDomain(Credentials):\n    \"\"\"Abstract base for credentials supporting ``with_universe_domain`` factory\"\"\"\n\n    def with_universe_domain(self, universe_domain):\n        \"\"\"Returns a copy of these credentials with a modified universe domain.\n\n        Args:\n            universe_domain (str): The universe domain to use\n\n        Returns:\n            google.auth.credentials.Credentials: A new credentials instance.\n        \"\"\"\n        raise NotImplementedError(\n            \"This credential does not support with_universe_domain.\"\n        )\n\n\nclass AnonymousCredentials(Credentials):\n    \"\"\"Credentials that do not provide any authentication information.\n\n    These are useful in the case of services that support anonymous access or\n    local service emulators that do not use credentials.\n    \"\"\"\n\n    @property\n    def expired(self):\n        \"\"\"Returns `False`, anonymous credentials never expire.\"\"\"\n        return False\n\n    @property\n    def valid(self):\n        \"\"\"Returns `True`, anonymous credentials are always valid.\"\"\"\n        return True\n\n    def refresh(self, request):\n        \"\"\"Raises :class:``InvalidOperation``, anonymous credentials cannot be\n        refreshed.\"\"\"\n        raise exceptions.InvalidOperation(\"Anonymous credentials cannot be refreshed.\")\n\n    def apply(self, headers, token=None):\n        \"\"\"Anonymous credentials do nothing to the request.\n\n        The optional ``token`` argument is not supported.\n\n        Raises:\n            google.auth.exceptions.InvalidValue: If a token was specified.\n        \"\"\"\n        if token is not None:\n            raise exceptions.InvalidValue(\"Anonymous credentials don't support tokens.\")\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Anonymous credentials do nothing to the request.\"\"\"\n\n\nclass ReadOnlyScoped(metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials whose scopes can be queried.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n    def __init__(self):\n        super(ReadOnlyScoped, self).__init__()\n        self._scopes = None\n        self._default_scopes = None\n\n    @property\n    def scopes(self):\n        \"\"\"Sequence[str]: the credentials' current set of scopes.\"\"\"\n        return self._scopes\n\n    @property\n    def default_scopes(self):\n        \"\"\"Sequence[str]: the credentials' current set of default scopes.\"\"\"\n        return self._default_scopes\n\n    @abc.abstractproperty\n    def requires_scopes(self):\n        \"\"\"True if these credentials require scopes to obtain an access token.\n        \"\"\"\n        return False\n\n    def has_scopes(self, scopes):\n        \"\"\"Checks if the credentials have the given scopes.\n\n        .. warning: This method is not guaranteed to be accurate if the\n            credentials are :attr:`~Credentials.invalid`.\n\n        Args:\n            scopes (Sequence[str]): The list of scopes to check.\n\n        Returns:\n            bool: True if the credentials have the given scopes.\n        \"\"\"\n        credential_scopes = (\n            self._scopes if self._scopes is not None else self._default_scopes\n        )\n        return set(scopes).issubset(set(credential_scopes or []))\n\n\nclass Scoped(ReadOnlyScoped):\n    \"\"\"Interface for credentials whose scopes can be replaced while copying.\n\n    OAuth 2.0-based credentials allow limiting access using scopes as described\n    in `RFC6749 Section 3.3`_.\n    If a credential class implements this interface then the credentials either\n    use scopes in their implementation.\n\n    Some credentials require scopes in order to obtain a token. You can check\n    if scoping is necessary with :attr:`requires_scopes`::\n\n        if credentials.requires_scopes:\n            # Scoping is required.\n            credentials = credentials.create_scoped(['one', 'two'])\n\n    Credentials that require scopes must either be constructed with scopes::\n\n        credentials = SomeScopedCredentials(scopes=['one', 'two'])\n\n    Or must copy an existing instance using :meth:`with_scopes`::\n\n        scoped_credentials = credentials.with_scopes(scopes=['one', 'two'])\n\n    Some credentials have scopes but do not allow or require scopes to be set,\n    these credentials can be used as-is.\n\n    .. _RFC6749 Section 3.3: https://tools.ietf.org/html/rfc6749#section-3.3\n    \"\"\"\n\n    @abc.abstractmethod\n    def with_scopes(self, scopes, default_scopes=None):\n        \"\"\"Create a copy of these credentials with the specified scopes.\n\n        Args:\n            scopes (Sequence[str]): The list of scopes to attach to the\n                current credentials.\n\n        Raises:\n            NotImplementedError: If the credentials' scopes can not be changed.\n                This can be avoided by checking :attr:`requires_scopes` before\n                calling this method.\n        \"\"\"\n        raise NotImplementedError(\"This class does not require scoping.\")\n\n\ndef with_scopes_if_required(credentials, scopes, default_scopes=None):\n    \"\"\"Creates a copy of the credentials with scopes if scoping is required.\n\n    This helper function is useful when you do not know (or care to know) the\n    specific type of credentials you are using (such as when you use\n    :func:`google.auth.default`). This function will call\n    :meth:`Scoped.with_scopes` if the credentials are scoped credentials and if\n    the credentials require scoping. Otherwise, it will return the credentials\n    as-is.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            scope if necessary.\n        scopes (Sequence[str]): The list of scopes to use.\n        default_scopes (Sequence[str]): Default scopes passed by a\n            Google client library. Use 'scopes' for user-defined scopes.\n\n    Returns:\n        google.auth.credentials.Credentials: Either a new set of scoped\n            credentials, or the passed in credentials instance if no scoping\n            was required.\n    \"\"\"\n    if isinstance(credentials, Scoped) and credentials.requires_scopes:\n        return credentials.with_scopes(scopes, default_scopes=default_scopes)\n    else:\n        return credentials\n\n\nclass Signing(metaclass=abc.ABCMeta):\n    \"\"\"Interface for credentials that can cryptographically sign messages.\"\"\"\n\n    @abc.abstractmethod\n    def sign_bytes(self, message):\n        \"\"\"Signs the given message.\n\n        Args:\n            message (bytes): The message to sign.\n\n        Returns:\n            bytes: The message's cryptographic signature.\n        \"\"\"\n        # pylint: disable=missing-raises-doc,redundant-returns-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Sign bytes must be implemented.\")\n\n    @abc.abstractproperty\n    def signer_email(self):\n        \"\"\"Optional[str]: An email address that identifies the signer.\"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Signer email must be implemented.\")\n\n    @abc.abstractproperty\n    def signer(self):\n        \"\"\"google.auth.crypt.Signer: The signer used to sign bytes.\"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Signer must be implemented.\")\n\n\nclass TokenState(Enum):\n    \"\"\"\n    Tracks the state of a token.\n    FRESH: The token is valid. It is not expired or close to expired, or the token has no expiry.\n    STALE: The token is close to expired, and should be refreshed. The token can be used normally.\n    INVALID: The token is expired or invalid. The token cannot be used for a normal operation.\n    \"\"\"\n\n    FRESH = 1\n    STALE = 2\n    INVALID = 3\n", "google/auth/_service_account_info.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helper functions for loading data from a Google service account file.\"\"\"\n\nimport io\nimport json\n\nfrom google.auth import crypt\nfrom google.auth import exceptions\n\n\ndef from_dict(data, require=None, use_rsa_signer=True):\n    \"\"\"Validates a dictionary containing Google service account data.\n\n    Creates and returns a :class:`google.auth.crypt.Signer` instance from the\n    private key specified in the data.\n\n    Args:\n        data (Mapping[str, str]): The service account data\n        require (Sequence[str]): List of keys required to be present in the\n            info.\n        use_rsa_signer (Optional[bool]): Whether to use RSA signer or EC signer.\n            We use RSA signer by default.\n\n    Returns:\n        google.auth.crypt.Signer: A signer created from the private key in the\n            service account file.\n\n    Raises:\n        MalformedError: if the data was in the wrong format, or if one of the\n            required keys is missing.\n    \"\"\"\n    keys_needed = set(require if require is not None else [])\n\n    missing = keys_needed.difference(data.keys())\n\n    if missing:\n        raise exceptions.MalformedError(\n            \"Service account info was not in the expected format, missing \"\n            \"fields {}.\".format(\", \".join(missing))\n        )\n\n    # Create a signer.\n    if use_rsa_signer:\n        signer = crypt.RSASigner.from_service_account_info(data)\n    else:\n        signer = crypt.ES256Signer.from_service_account_info(data)\n\n    return signer\n\n\ndef from_filename(filename, require=None, use_rsa_signer=True):\n    \"\"\"Reads a Google service account JSON file and returns its parsed info.\n\n    Args:\n        filename (str): The path to the service account .json file.\n        require (Sequence[str]): List of keys required to be present in the\n            info.\n        use_rsa_signer (Optional[bool]): Whether to use RSA signer or EC signer.\n            We use RSA signer by default.\n\n    Returns:\n        Tuple[ Mapping[str, str], google.auth.crypt.Signer ]: The verified\n            info and a signer instance.\n    \"\"\"\n    with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n        data = json.load(json_file)\n        return data, from_dict(data, require=require, use_rsa_signer=use_rsa_signer)\n", "google/auth/_oauth2client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helpers for transitioning from oauth2client to google-auth.\n\n.. warning::\n    This module is private as it is intended to assist first-party downstream\n    clients with the transition from oauth2client to google-auth.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nfrom google.auth import _helpers\nimport google.auth.app_engine\nimport google.auth.compute_engine\nimport google.oauth2.credentials\nimport google.oauth2.service_account\n\ntry:\n    import oauth2client.client  # type: ignore\n    import oauth2client.contrib.gce  # type: ignore\n    import oauth2client.service_account  # type: ignore\nexcept ImportError as caught_exc:\n    raise ImportError(\"oauth2client is not installed.\") from caught_exc\n\ntry:\n    import oauth2client.contrib.appengine  # type: ignore\n\n    _HAS_APPENGINE = True\nexcept ImportError:\n    _HAS_APPENGINE = False\n\n\n_CONVERT_ERROR_TMPL = \"Unable to convert {} to a google-auth credentials class.\"\n\n\ndef _convert_oauth2_credentials(credentials):\n    \"\"\"Converts to :class:`google.oauth2.credentials.Credentials`.\n\n    Args:\n        credentials (Union[oauth2client.client.OAuth2Credentials,\n            oauth2client.client.GoogleCredentials]): The credentials to\n            convert.\n\n    Returns:\n        google.oauth2.credentials.Credentials: The converted credentials.\n    \"\"\"\n    new_credentials = google.oauth2.credentials.Credentials(\n        token=credentials.access_token,\n        refresh_token=credentials.refresh_token,\n        token_uri=credentials.token_uri,\n        client_id=credentials.client_id,\n        client_secret=credentials.client_secret,\n        scopes=credentials.scopes,\n    )\n\n    new_credentials._expires = credentials.token_expiry\n\n    return new_credentials\n\n\ndef _convert_service_account_credentials(credentials):\n    \"\"\"Converts to :class:`google.oauth2.service_account.Credentials`.\n\n    Args:\n        credentials (Union[\n            oauth2client.service_account.ServiceAccountCredentials,\n            oauth2client.service_account._JWTAccessCredentials]): The\n            credentials to convert.\n\n    Returns:\n        google.oauth2.service_account.Credentials: The converted credentials.\n    \"\"\"\n    info = credentials.serialization_data.copy()\n    info[\"token_uri\"] = credentials.token_uri\n    return google.oauth2.service_account.Credentials.from_service_account_info(info)\n\n\ndef _convert_gce_app_assertion_credentials(credentials):\n    \"\"\"Converts to :class:`google.auth.compute_engine.Credentials`.\n\n    Args:\n        credentials (oauth2client.contrib.gce.AppAssertionCredentials): The\n            credentials to convert.\n\n    Returns:\n        google.oauth2.service_account.Credentials: The converted credentials.\n    \"\"\"\n    return google.auth.compute_engine.Credentials(\n        service_account_email=credentials.service_account_email\n    )\n\n\ndef _convert_appengine_app_assertion_credentials(credentials):\n    \"\"\"Converts to :class:`google.auth.app_engine.Credentials`.\n\n    Args:\n        credentials (oauth2client.contrib.app_engine.AppAssertionCredentials):\n            The credentials to convert.\n\n    Returns:\n        google.oauth2.service_account.Credentials: The converted credentials.\n    \"\"\"\n    # pylint: disable=invalid-name\n    return google.auth.app_engine.Credentials(\n        scopes=_helpers.string_to_scopes(credentials.scope),\n        service_account_id=credentials.service_account_id,\n    )\n\n\n_CLASS_CONVERSION_MAP = {\n    oauth2client.client.OAuth2Credentials: _convert_oauth2_credentials,\n    oauth2client.client.GoogleCredentials: _convert_oauth2_credentials,\n    oauth2client.service_account.ServiceAccountCredentials: _convert_service_account_credentials,\n    oauth2client.service_account._JWTAccessCredentials: _convert_service_account_credentials,\n    oauth2client.contrib.gce.AppAssertionCredentials: _convert_gce_app_assertion_credentials,\n}\n\nif _HAS_APPENGINE:\n    _CLASS_CONVERSION_MAP[\n        oauth2client.contrib.appengine.AppAssertionCredentials\n    ] = _convert_appengine_app_assertion_credentials\n\n\ndef convert(credentials):\n    \"\"\"Convert oauth2client credentials to google-auth credentials.\n\n    This class converts:\n\n    - :class:`oauth2client.client.OAuth2Credentials` to\n      :class:`google.oauth2.credentials.Credentials`.\n    - :class:`oauth2client.client.GoogleCredentials` to\n      :class:`google.oauth2.credentials.Credentials`.\n    - :class:`oauth2client.service_account.ServiceAccountCredentials` to\n      :class:`google.oauth2.service_account.Credentials`.\n    - :class:`oauth2client.service_account._JWTAccessCredentials` to\n      :class:`google.oauth2.service_account.Credentials`.\n    - :class:`oauth2client.contrib.gce.AppAssertionCredentials` to\n      :class:`google.auth.compute_engine.Credentials`.\n    - :class:`oauth2client.contrib.appengine.AppAssertionCredentials` to\n      :class:`google.auth.app_engine.Credentials`.\n\n    Returns:\n        google.auth.credentials.Credentials: The converted credentials.\n\n    Raises:\n        ValueError: If the credentials could not be converted.\n    \"\"\"\n\n    credentials_class = type(credentials)\n\n    try:\n        return _CLASS_CONVERSION_MAP[credentials_class](credentials)\n    except KeyError as caught_exc:\n        new_exc = ValueError(_CONVERT_ERROR_TMPL.format(credentials_class))\n        raise new_exc from caught_exc\n", "google/auth/metrics.py": "# Copyright 2023 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\" We use x-goog-api-client header to report metrics. This module provides\nthe constants and helper methods to construct x-goog-api-client header.\n\"\"\"\n\nimport platform\n\nfrom google.auth import version\n\n\nAPI_CLIENT_HEADER = \"x-goog-api-client\"\n\n# BYOID Specific consts\nBYOID_HEADER_SECTION = \"google-byoid-sdk\"\n\n# Auth request type\nREQUEST_TYPE_ACCESS_TOKEN = \"auth-request-type/at\"\nREQUEST_TYPE_ID_TOKEN = \"auth-request-type/it\"\nREQUEST_TYPE_MDS_PING = \"auth-request-type/mds\"\nREQUEST_TYPE_REAUTH_START = \"auth-request-type/re-start\"\nREQUEST_TYPE_REAUTH_CONTINUE = \"auth-request-type/re-cont\"\n\n# Credential type\nCRED_TYPE_USER = \"cred-type/u\"\nCRED_TYPE_SA_ASSERTION = \"cred-type/sa\"\nCRED_TYPE_SA_JWT = \"cred-type/jwt\"\nCRED_TYPE_SA_MDS = \"cred-type/mds\"\nCRED_TYPE_SA_IMPERSONATE = \"cred-type/imp\"\n\n\n# Versions\ndef python_and_auth_lib_version():\n    return \"gl-python/{} auth/{}\".format(platform.python_version(), version.__version__)\n\n\n# Token request metric header values\n\n# x-goog-api-client header value for access token request via metadata server.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/mds\"\ndef token_request_access_token_mds():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ACCESS_TOKEN, CRED_TYPE_SA_MDS\n    )\n\n\n# x-goog-api-client header value for ID token request via metadata server.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/mds\"\ndef token_request_id_token_mds():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_MDS\n    )\n\n\n# x-goog-api-client header value for impersonated credentials access token request.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/imp\"\ndef token_request_access_token_impersonate():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(),\n        REQUEST_TYPE_ACCESS_TOKEN,\n        CRED_TYPE_SA_IMPERSONATE,\n    )\n\n\n# x-goog-api-client header value for impersonated credentials ID token request.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/imp\"\ndef token_request_id_token_impersonate():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_IMPERSONATE\n    )\n\n\n# x-goog-api-client header value for service account credentials access token\n# request (assertion flow).\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/at cred-type/sa\"\ndef token_request_access_token_sa_assertion():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ACCESS_TOKEN, CRED_TYPE_SA_ASSERTION\n    )\n\n\n# x-goog-api-client header value for service account credentials ID token\n# request (assertion flow).\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/it cred-type/sa\"\ndef token_request_id_token_sa_assertion():\n    return \"{} {} {}\".format(\n        python_and_auth_lib_version(), REQUEST_TYPE_ID_TOKEN, CRED_TYPE_SA_ASSERTION\n    )\n\n\n# x-goog-api-client header value for user credentials token request.\n# Example: \"gl-python/3.7 auth/1.1 cred-type/u\"\ndef token_request_user():\n    return \"{} {}\".format(python_and_auth_lib_version(), CRED_TYPE_USER)\n\n\n# Miscellenous metrics\n\n# x-goog-api-client header value for metadata server ping.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/mds\"\ndef mds_ping():\n    return \"{} {}\".format(python_and_auth_lib_version(), REQUEST_TYPE_MDS_PING)\n\n\n# x-goog-api-client header value for reauth start endpoint calls.\n# Example: \"gl-python/3.7 auth/1.1 auth-request-type/re-start\"\ndef reauth_start():\n    return \"{} {}\".format(python_and_auth_lib_version(), REQUEST_TYPE_REAUTH_START)\n\n\n# x-goog-api-client header value for reauth continue endpoint calls.\n# Example: \"gl-python/3.7 auth/1.1 cred-type/re-cont\"\ndef reauth_continue():\n    return \"{} {}\".format(python_and_auth_lib_version(), REQUEST_TYPE_REAUTH_CONTINUE)\n\n\n# x-goog-api-client header value for BYOID calls to the Security Token Service exchange token endpoint.\n# Example: \"gl-python/3.7 auth/1.1 google-byoid-sdk source/aws sa-impersonation/true sa-impersonation/true\"\ndef byoid_metrics_header(metrics_options):\n    header = \"{} {}\".format(python_and_auth_lib_version(), BYOID_HEADER_SECTION)\n    for key, value in metrics_options.items():\n        header = \"{} {}/{}\".format(header, key, value)\n    return header\n\n\ndef add_metric_header(headers, metric_header_value):\n    \"\"\"Add x-goog-api-client header with the given value.\n\n    Args:\n        headers (Mapping[str, str]): The headers to which we will add the\n            metric header.\n        metric_header_value (Optional[str]): If value is None, do nothing;\n            if headers already has a x-goog-api-client header, append the value\n            to the existing header; otherwise add a new x-goog-api-client\n            header with the given value.\n    \"\"\"\n    if not metric_header_value:\n        return\n    if API_CLIENT_HEADER not in headers:\n        headers[API_CLIENT_HEADER] = metric_header_value\n    else:\n        headers[API_CLIENT_HEADER] += \" \" + metric_header_value\n", "google/auth/identity_pool.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Identity Pool Credentials.\n\nThis module provides credentials to access Google Cloud resources from on-prem\nor non-Google Cloud platforms which support external credentials (e.g. OIDC ID\ntokens) retrieved from local file locations or local servers. This includes\nMicrosoft Azure and OIDC identity providers (e.g. K8s workloads registered with\nHub with Hub workload identity enabled).\n\nThese credentials are recommended over the use of service account credentials\nin on-prem/non-Google Cloud platforms as they do not involve the management of\nlong-live service account private keys.\n\nIdentity Pool Credentials are initialized using external_account\narguments which are typically loaded from an external credentials file or\nan external credentials URL.\n\nThis module also provides a definition for an abstract subject token supplier.\nThis supplier can be implemented to return a valid OIDC or SAML2.0 subject token\nand used to create Identity Pool credentials. The credentials will then call the\nsupplier instead of using pre-defined methods such as reading a local file or\ncalling a URL.\n\"\"\"\n\ntry:\n    from collections.abc import Mapping\n# Python 2.7 compatibility\nexcept ImportError:  # pragma: NO COVER\n    from collections import Mapping  # type: ignore\nimport abc\nimport json\nimport os\nfrom typing import NamedTuple\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth import external_account\n\n\nclass SubjectTokenSupplier(metaclass=abc.ABCMeta):\n    \"\"\"Base class for subject token suppliers. This can be implemented with custom logic to retrieve\n    a subject token to exchange for a Google Cloud access token when using Workload or\n    Workforce Identity Federation. The identity pool credential does not cache the subject token,\n    so caching logic should be added in the implementation.\n    \"\"\"\n\n    @abc.abstractmethod\n    def get_subject_token(self, context, request):\n        \"\"\"Returns the requested subject token. The subject token must be valid.\n\n        .. warning: This is not cached by the calling Google credential, so caching logic should be implemented in the supplier.\n\n        Args:\n            context (google.auth.externalaccount.SupplierContext): The context object\n                containing information about the requested audience and subject token type.\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                subject token retrieval logic.\n\n        Returns:\n            str: The requested subject token string.\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n\nclass _TokenContent(NamedTuple):\n    \"\"\"Models the token content response from file and url internal suppliers.\n        Attributes:\n            content (str): The string content of the file or URL response.\n            location (str): The location the content was retrieved from. This will either be a file location or a URL.\n    \"\"\"\n\n    content: str\n    location: str\n\n\nclass _FileSupplier(SubjectTokenSupplier):\n    \"\"\" Internal implementation of subject token supplier which supports reading a subject token from a file.\"\"\"\n\n    def __init__(self, path, format_type, subject_token_field_name):\n        self._path = path\n        self._format_type = format_type\n        self._subject_token_field_name = subject_token_field_name\n\n    @_helpers.copy_docstring(SubjectTokenSupplier)\n    def get_subject_token(self, context, request):\n        if not os.path.exists(self._path):\n            raise exceptions.RefreshError(\"File '{}' was not found.\".format(self._path))\n\n        with open(self._path, \"r\", encoding=\"utf-8\") as file_obj:\n            token_content = _TokenContent(file_obj.read(), self._path)\n\n        return _parse_token_data(\n            token_content, self._format_type, self._subject_token_field_name\n        )\n\n\nclass _UrlSupplier(SubjectTokenSupplier):\n    \"\"\" Internal implementation of subject token supplier which supports retrieving a subject token by calling a URL endpoint.\"\"\"\n\n    def __init__(self, url, format_type, subject_token_field_name, headers):\n        self._url = url\n        self._format_type = format_type\n        self._subject_token_field_name = subject_token_field_name\n        self._headers = headers\n\n    @_helpers.copy_docstring(SubjectTokenSupplier)\n    def get_subject_token(self, context, request):\n        response = request(url=self._url, method=\"GET\", headers=self._headers)\n\n        # support both string and bytes type response.data\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != 200:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve Identity Pool subject token\", response_body\n            )\n        token_content = _TokenContent(response_body, self._url)\n        return _parse_token_data(\n            token_content, self._format_type, self._subject_token_field_name\n        )\n\n\ndef _parse_token_data(token_content, format_type=\"text\", subject_token_field_name=None):\n    if format_type == \"text\":\n        token = token_content.content\n    else:\n        try:\n            # Parse file content as JSON.\n            response_data = json.loads(token_content.content)\n            # Get the subject_token.\n            token = response_data[subject_token_field_name]\n        except (KeyError, ValueError):\n            raise exceptions.RefreshError(\n                \"Unable to parse subject_token from JSON file '{}' using key '{}'\".format(\n                    token_content.location, subject_token_field_name\n                )\n            )\n    if not token:\n        raise exceptions.RefreshError(\n            \"Missing subject_token in the credential_source file\"\n        )\n    return token\n\n\nclass Credentials(external_account.Credentials):\n    \"\"\"External account credentials sourced from files and URLs.\"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url=external_account._DEFAULT_TOKEN_URL,\n        credential_source=None,\n        subject_token_supplier=None,\n        *args,\n        **kwargs\n    ):\n        \"\"\"Instantiates an external account credentials object from a file/URL.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:oauth:token-type:jwt\u201d\n                    \u201curn:ietf:params:oauth:token-type:id-token\u201d\n                    \u201curn:ietf:params:oauth:token-type:saml2\u201d\n\n            token_url (Optional [str]): The STS endpoint URL. If not provided, will default to \"https://sts.googleapis.com/v1/token\".\n            credential_source (Optional [Mapping]): The credential source dictionary used to\n                provide instructions on how to retrieve external credential to be\n                exchanged for Google access tokens. Either a credential source or\n                a subject token supplier must be provided.\n\n                Example credential_source for url-sourced credential::\n\n                    {\n                        \"url\": \"http://www.example.com\",\n                        \"format\": {\n                            \"type\": \"json\",\n                            \"subject_token_field_name\": \"access_token\",\n                        },\n                        \"headers\": {\"foo\": \"bar\"},\n                    }\n\n                Example credential_source for file-sourced credential::\n\n                    {\n                        \"file\": \"/path/to/token/file.txt\"\n                    }\n            subject_token_supplier (Optional [SubjectTokenSupplier]): Optional subject token supplier.\n                This will be called to supply a valid subject token which will then\n                be exchanged for Google access tokens. Either a subject token  supplier\n                or a credential source must be provided.\n            args (List): Optional positional arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n            kwargs (Mapping): Optional keyword arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                access token retrieval logic.\n            ValueError: For invalid parameters.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_file` or\n            :meth:`from_info` are used instead of calling the constructor directly.\n        \"\"\"\n\n        super(Credentials, self).__init__(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            credential_source=credential_source,\n            *args,\n            **kwargs\n        )\n        if credential_source is None and subject_token_supplier is None:\n            raise exceptions.InvalidValue(\n                \"A valid credential source or a subject token supplier must be provided.\"\n            )\n        if credential_source is not None and subject_token_supplier is not None:\n            raise exceptions.InvalidValue(\n                \"Identity pool credential cannot have both a credential source and a subject token supplier.\"\n            )\n\n        if subject_token_supplier is not None:\n            self._subject_token_supplier = subject_token_supplier\n            self._credential_source_file = None\n            self._credential_source_url = None\n        else:\n            if not isinstance(credential_source, Mapping):\n                self._credential_source_executable = None\n                raise exceptions.MalformedError(\n                    \"Invalid credential_source. The credential_source is not a dict.\"\n                )\n            self._credential_source_file = credential_source.get(\"file\")\n            self._credential_source_url = credential_source.get(\"url\")\n            self._credential_source_headers = credential_source.get(\"headers\")\n            credential_source_format = credential_source.get(\"format\", {})\n            # Get credential_source format type. When not provided, this\n            # defaults to text.\n            self._credential_source_format_type = (\n                credential_source_format.get(\"type\") or \"text\"\n            )\n            # environment_id is only supported in AWS or dedicated future external\n            # account credentials.\n            if \"environment_id\" in credential_source:\n                raise exceptions.MalformedError(\n                    \"Invalid Identity Pool credential_source field 'environment_id'\"\n                )\n            if self._credential_source_format_type not in [\"text\", \"json\"]:\n                raise exceptions.MalformedError(\n                    \"Invalid credential_source format '{}'\".format(\n                        self._credential_source_format_type\n                    )\n                )\n            # For JSON types, get the required subject_token field name.\n            if self._credential_source_format_type == \"json\":\n                self._credential_source_field_name = credential_source_format.get(\n                    \"subject_token_field_name\"\n                )\n                if self._credential_source_field_name is None:\n                    raise exceptions.MalformedError(\n                        \"Missing subject_token_field_name for JSON credential_source format\"\n                    )\n            else:\n                self._credential_source_field_name = None\n\n            if self._credential_source_file and self._credential_source_url:\n                raise exceptions.MalformedError(\n                    \"Ambiguous credential_source. 'file' is mutually exclusive with 'url'.\"\n                )\n            if not self._credential_source_file and not self._credential_source_url:\n                raise exceptions.MalformedError(\n                    \"Missing credential_source. A 'file' or 'url' must be provided.\"\n                )\n\n            if self._credential_source_file:\n                self._subject_token_supplier = _FileSupplier(\n                    self._credential_source_file,\n                    self._credential_source_format_type,\n                    self._credential_source_field_name,\n                )\n            else:\n                self._subject_token_supplier = _UrlSupplier(\n                    self._credential_source_url,\n                    self._credential_source_format_type,\n                    self._credential_source_field_name,\n                    self._credential_source_headers,\n                )\n\n    @_helpers.copy_docstring(external_account.Credentials)\n    def retrieve_subject_token(self, request):\n        return self._subject_token_supplier.get_subject_token(\n            self._supplier_context, request\n        )\n\n    def _create_default_metrics_options(self):\n        metrics_options = super(Credentials, self)._create_default_metrics_options()\n        # Check that credential source is a dict before checking for file vs url. This check needs to be done\n        # here because the external_account credential constructor needs to pass the metrics options to the\n        # impersonated credential object before the identity_pool credentials are validated.\n        if isinstance(self._credential_source, Mapping):\n            if self._credential_source.get(\"file\"):\n                metrics_options[\"source\"] = \"file\"\n            else:\n                metrics_options[\"source\"] = \"url\"\n        else:\n            metrics_options[\"source\"] = \"programmatic\"\n        return metrics_options\n\n    def _has_custom_supplier(self):\n        return self._credential_source is None\n\n    def _constructor_args(self):\n        args = super(Credentials, self)._constructor_args()\n        # If a custom supplier was used, append it to the args dict.\n        if self._has_custom_supplier():\n            args.update({\"subject_token_supplier\": self._subject_token_supplier})\n        return args\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates an Identity Pool Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The Identity Pool external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n\n        Raises:\n            ValueError: For invalid parameters.\n        \"\"\"\n        subject_token_supplier = info.get(\"subject_token_supplier\")\n        kwargs.update({\"subject_token_supplier\": subject_token_supplier})\n        return super(Credentials, cls).from_info(info, **kwargs)\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates an IdentityPool Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the IdentityPool external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n        \"\"\"\n        return super(Credentials, cls).from_file(filename, **kwargs)\n", "google/auth/app_engine.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google App Engine standard environment support.\n\nThis module provides authentication and signing for applications running on App\nEngine in the standard environment using the `App Identity API`_.\n\n\n.. _App Identity API:\n    https://cloud.google.com/appengine/docs/python/appidentity/\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import crypt\nfrom google.auth import exceptions\n\n# pytype: disable=import-error\ntry:\n    from google.appengine.api import app_identity  # type: ignore\nexcept ImportError:\n    app_identity = None  # type: ignore\n# pytype: enable=import-error\n\n\nclass Signer(crypt.Signer):\n    \"\"\"Signs messages using the App Engine App Identity service.\n\n    This can be used in place of :class:`google.auth.crypt.Signer` when\n    running in the App Engine standard environment.\n    \"\"\"\n\n    @property\n    def key_id(self):\n        \"\"\"Optional[str]: The key ID used to identify this private key.\n\n        .. warning::\n           This is always ``None``. The key ID used by App Engine can not\n           be reliably determined ahead of time.\n        \"\"\"\n        return None\n\n    @_helpers.copy_docstring(crypt.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        _, signature = app_identity.sign_blob(message)\n        return signature\n\n\ndef get_project_id():\n    \"\"\"Gets the project ID for the current App Engine application.\n\n    Returns:\n        str: The project ID\n\n    Raises:\n        google.auth.exceptions.OSError: If the App Engine APIs are unavailable.\n    \"\"\"\n    # pylint: disable=missing-raises-doc\n    # Pylint rightfully thinks google.auth.exceptions.OSError is OSError, but doesn't\n    # realize it's a valid alias.\n    if app_identity is None:\n        raise exceptions.OSError(\"The App Engine APIs are not available.\")\n    return app_identity.get_application_id()\n\n\nclass Credentials(\n    credentials.Scoped, credentials.Signing, credentials.CredentialsWithQuotaProject\n):\n    \"\"\"App Engine standard environment credentials.\n\n    These credentials use the App Engine App Identity API to obtain access\n    tokens.\n    \"\"\"\n\n    def __init__(\n        self,\n        scopes=None,\n        default_scopes=None,\n        service_account_id=None,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            scopes (Sequence[str]): Scopes to request from the App Identity\n                API.\n            default_scopes (Sequence[str]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            service_account_id (str): The service account ID passed into\n                :func:`google.appengine.api.app_identity.get_access_token`.\n                If not specified, the default application service account\n                ID will be used.\n            quota_project_id (Optional[str]): The project ID used for quota\n                and billing.\n\n        Raises:\n            google.auth.exceptions.OSError: If the App Engine APIs are unavailable.\n        \"\"\"\n        # pylint: disable=missing-raises-doc\n        # Pylint rightfully thinks google.auth.exceptions.OSError is OSError, but doesn't\n        # realize it's a valid alias.\n        if app_identity is None:\n            raise exceptions.OSError(\"The App Engine APIs are not available.\")\n\n        super(Credentials, self).__init__()\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._service_account_id = service_account_id\n        self._signer = Signer()\n        self._quota_project_id = quota_project_id\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # pylint: disable=unused-argument\n        token, ttl = app_identity.get_access_token(scopes, self._service_account_id)\n        expiry = datetime.datetime.utcfromtimestamp(ttl)\n\n        self.token, self.expiry = token, expiry\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        if self._service_account_id is None:\n            self._service_account_id = app_identity.get_service_account_name()\n        return self._service_account_id\n\n    @property\n    def requires_scopes(self):\n        \"\"\"Checks if the credentials requires scopes.\n\n        Returns:\n            bool: True if there are no scopes set otherwise False.\n        \"\"\"\n        return not self._scopes and not self._default_scopes\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        return self.__class__(\n            scopes=scopes,\n            default_scopes=default_scopes,\n            service_account_id=self._service_account_id,\n            quota_project_id=self.quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            scopes=self._scopes,\n            service_account_id=self._service_account_id,\n            quota_project_id=quota_project_id,\n        )\n\n    @_helpers.copy_docstring(credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer_email(self):\n        return self.service_account_email\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n", "google/auth/_exponential_backoff.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport random\nimport time\n\n# The default amount of retry attempts\n_DEFAULT_RETRY_TOTAL_ATTEMPTS = 3\n\n# The default initial backoff period (1.0 second).\n_DEFAULT_INITIAL_INTERVAL_SECONDS = 1.0\n\n# The default randomization factor (0.1 which results in a random period ranging\n# between 10% below and 10% above the retry interval).\n_DEFAULT_RANDOMIZATION_FACTOR = 0.1\n\n# The default multiplier value (2 which is 100% increase per back off).\n_DEFAULT_MULTIPLIER = 2.0\n\n\"\"\"Exponential Backoff Utility\n\nThis is a private module that implements the exponential back off algorithm.\nIt can be used as a utility for code that needs to retry on failure, for example\nan HTTP request.\n\"\"\"\n\n\nclass ExponentialBackoff:\n    \"\"\"An exponential backoff iterator. This can be used in a for loop to\n    perform requests with exponential backoff.\n\n    Args:\n        total_attempts Optional[int]:\n            The maximum amount of retries that should happen.\n            The default value is 3 attempts.\n        initial_wait_seconds Optional[int]:\n            The amount of time to sleep in the first backoff. This parameter\n            should be in seconds.\n            The default value is 1 second.\n        randomization_factor Optional[float]:\n            The amount of jitter that should be in each backoff. For example,\n            a value of 0.1 will introduce a jitter range of 10% to the\n            current backoff period.\n            The default value is 0.1.\n        multiplier Optional[float]:\n            The backoff multipler. This adjusts how much each backoff will\n            increase. For example a value of 2.0 leads to a 200% backoff\n            on each attempt. If the initial_wait is 1.0 it would look like\n            this sequence [1.0, 2.0, 4.0, 8.0].\n            The default value is 2.0.\n    \"\"\"\n\n    def __init__(\n        self,\n        total_attempts=_DEFAULT_RETRY_TOTAL_ATTEMPTS,\n        initial_wait_seconds=_DEFAULT_INITIAL_INTERVAL_SECONDS,\n        randomization_factor=_DEFAULT_RANDOMIZATION_FACTOR,\n        multiplier=_DEFAULT_MULTIPLIER,\n    ):\n        self._total_attempts = total_attempts\n        self._initial_wait_seconds = initial_wait_seconds\n\n        self._current_wait_in_seconds = self._initial_wait_seconds\n\n        self._randomization_factor = randomization_factor\n        self._multiplier = multiplier\n        self._backoff_count = 0\n\n    def __iter__(self):\n        self._backoff_count = 0\n        self._current_wait_in_seconds = self._initial_wait_seconds\n        return self\n\n    def __next__(self):\n        if self._backoff_count >= self._total_attempts:\n            raise StopIteration\n        self._backoff_count += 1\n\n        jitter_variance = self._current_wait_in_seconds * self._randomization_factor\n        jitter = random.uniform(\n            self._current_wait_in_seconds - jitter_variance,\n            self._current_wait_in_seconds + jitter_variance,\n        )\n\n        time.sleep(jitter)\n\n        self._current_wait_in_seconds *= self._multiplier\n        return self._backoff_count\n\n    @property\n    def total_attempts(self):\n        \"\"\"The total amount of backoff attempts that will be made.\"\"\"\n        return self._total_attempts\n\n    @property\n    def backoff_count(self):\n        \"\"\"The current amount of backoff attempts that have been made.\"\"\"\n        return self._backoff_count\n", "google/auth/environment_vars.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Environment variables used by :mod:`google.auth`.\"\"\"\n\n\nPROJECT = \"GOOGLE_CLOUD_PROJECT\"\n\"\"\"Environment variable defining default project.\n\nThis used by :func:`google.auth.default` to explicitly set a project ID. This\nenvironment variable is also used by the Google Cloud Python Library.\n\"\"\"\n\nLEGACY_PROJECT = \"GCLOUD_PROJECT\"\n\"\"\"Previously used environment variable defining the default project.\n\nThis environment variable is used instead of the current one in some\nsituations (such as Google App Engine).\n\"\"\"\n\nGOOGLE_CLOUD_QUOTA_PROJECT = \"GOOGLE_CLOUD_QUOTA_PROJECT\"\n\"\"\"Environment variable defining the project to be used for\nquota and billing.\"\"\"\n\nCREDENTIALS = \"GOOGLE_APPLICATION_CREDENTIALS\"\n\"\"\"Environment variable defining the location of Google application default\ncredentials.\"\"\"\n\n# The environment variable name which can replace ~/.config if set.\nCLOUD_SDK_CONFIG_DIR = \"CLOUDSDK_CONFIG\"\n\"\"\"Environment variable defines the location of Google Cloud SDK's config\nfiles.\"\"\"\n\n# These two variables allow for customization of the addresses used when\n# contacting the GCE metadata service.\nGCE_METADATA_HOST = \"GCE_METADATA_HOST\"\n\"\"\"Environment variable providing an alternate hostname or host:port to be\nused for GCE metadata requests.\n\nThis environment variable was originally named GCE_METADATA_ROOT. The system will\ncheck this environemnt variable first; should there be no value present,\nthe system will fall back to the old variable.\n\"\"\"\n\nGCE_METADATA_ROOT = \"GCE_METADATA_ROOT\"\n\"\"\"Old environment variable for GCE_METADATA_HOST.\"\"\"\n\nGCE_METADATA_IP = \"GCE_METADATA_IP\"\n\"\"\"Environment variable providing an alternate ip:port to be used for ip-only\nGCE metadata requests.\"\"\"\n\nGOOGLE_API_USE_CLIENT_CERTIFICATE = \"GOOGLE_API_USE_CLIENT_CERTIFICATE\"\n\"\"\"Environment variable controlling whether to use client certificate or not.\n\nThe default value is false. Users have to explicitly set this value to true\nin order to use client certificate to establish a mutual TLS channel.\"\"\"\n\nLEGACY_APPENGINE_RUNTIME = \"APPENGINE_RUNTIME\"\n\"\"\"Gen1 environment variable defining the App Engine Runtime.\n\nUsed to distinguish between GAE gen1 and GAE gen2+.\n\"\"\"\n\n# AWS environment variables used with AWS workload identity pools to retrieve\n# AWS security credentials and the AWS region needed to create a serialized\n# signed requests to the AWS STS GetCalledIdentity API that can be exchanged\n# for a Google access tokens via the GCP STS endpoint.\n# When not available the AWS metadata server is used to retrieve these values.\nAWS_ACCESS_KEY_ID = \"AWS_ACCESS_KEY_ID\"\nAWS_SECRET_ACCESS_KEY = \"AWS_SECRET_ACCESS_KEY\"\nAWS_SESSION_TOKEN = \"AWS_SESSION_TOKEN\"\nAWS_REGION = \"AWS_REGION\"\nAWS_DEFAULT_REGION = \"AWS_DEFAULT_REGION\"\n", "google/auth/_refresh_worker.py": "# Copyright 2023 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nimport copy\nimport logging\nimport threading\n\nimport google.auth.exceptions as e\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass RefreshThreadManager:\n    \"\"\"\n    Organizes exactly one background job that refresh a token.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"Initializes the manager.\"\"\"\n\n        self._worker = None\n        self._lock = threading.Lock()  # protects access to worker threads.\n\n    def start_refresh(self, cred, request):\n        \"\"\"Starts a refresh thread for the given credentials.\n        The credentials are refreshed using the request parameter.\n        request and cred MUST not be None\n\n        Returns True if a background refresh was kicked off. False otherwise.\n\n        Args:\n            cred: A credentials object.\n            request: A request object.\n        Returns:\n          bool\n        \"\"\"\n        if cred is None or request is None:\n            raise e.InvalidValue(\n                \"Unable to start refresh. cred and request must be valid and instantiated objects.\"\n            )\n\n        with self._lock:\n            if self._worker is not None and self._worker._error_info is not None:\n                return False\n\n            if self._worker is None or not self._worker.is_alive():  # pragma: NO COVER\n                self._worker = RefreshThread(cred=cred, request=copy.deepcopy(request))\n                self._worker.start()\n        return True\n\n    def clear_error(self):\n        \"\"\"\n      Removes any errors that were stored from previous background refreshes.\n      \"\"\"\n        with self._lock:\n            if self._worker:\n                self._worker._error_info = None\n\n    def __getstate__(self):\n        \"\"\"Pickle helper that serializes the _lock attribute.\"\"\"\n        state = self.__dict__.copy()\n        state[\"_lock\"] = None\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Pickle helper that deserializes the _lock attribute.\"\"\"\n        state[\"_lock\"] = threading.Lock()\n        self.__dict__.update(state)\n\n\nclass RefreshThread(threading.Thread):\n    \"\"\"\n    Thread that refreshes credentials.\n    \"\"\"\n\n    def __init__(self, cred, request, **kwargs):\n        \"\"\"Initializes the thread.\n\n        Args:\n            cred: A Credential object to refresh.\n            request: A Request object used to perform a credential refresh.\n            **kwargs: Additional keyword arguments.\n        \"\"\"\n\n        super().__init__(**kwargs)\n        self._cred = cred\n        self._request = request\n        self._error_info = None\n\n    def run(self):\n        \"\"\"\n        Perform the credential refresh.\n        \"\"\"\n        try:\n            self._cred.refresh(self._request)\n        except Exception as err:  # pragma: NO COVER\n            _LOGGER.error(f\"Background refresh failed due to: {err}\")\n            self._error_info = err\n", "google/auth/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Auth Library for Python.\"\"\"\n\nimport logging\nimport sys\nimport warnings\n\nfrom google.auth import version as google_auth_version\nfrom google.auth._default import (\n    default,\n    load_credentials_from_dict,\n    load_credentials_from_file,\n)\n\n\n__version__ = google_auth_version.__version__\n\n\n__all__ = [\"default\", \"load_credentials_from_file\", \"load_credentials_from_dict\"]\n\n\nclass Python37DeprecationWarning(DeprecationWarning):  # pragma: NO COVER\n    \"\"\"\n    Deprecation warning raised when Python 3.7 runtime is detected.\n    Python 3.7 support will be dropped after January 1, 2024.\n    \"\"\"\n\n    pass\n\n\n# Checks if the current runtime is Python 3.7.\nif sys.version_info.major == 3 and sys.version_info.minor == 7:  # pragma: NO COVER\n    message = (\n        \"After January 1, 2024, new releases of this library will drop support \"\n        \"for Python 3.7.\"\n    )\n    warnings.warn(message, Python37DeprecationWarning)\n\n# Set default logging handler to avoid \"No handler found\" warnings.\nlogging.getLogger(__name__).addHandler(logging.NullHandler())\n", "google/auth/_helpers.py": "# Copyright 2015 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helper functions for commonly used utilities.\"\"\"\n\nimport base64\nimport calendar\nimport datetime\nfrom email.message import Message\nimport sys\nimport urllib\n\nfrom google.auth import exceptions\n\n# The smallest MDS cache used by this library stores tokens until 4 minutes from\n# expiry.\nREFRESH_THRESHOLD = datetime.timedelta(minutes=3, seconds=45)\n\n\ndef copy_docstring(source_class):\n    \"\"\"Decorator that copies a method's docstring from another class.\n\n    Args:\n        source_class (type): The class that has the documented method.\n\n    Returns:\n        Callable: A decorator that will copy the docstring of the same\n            named method in the source class to the decorated method.\n    \"\"\"\n\n    def decorator(method):\n        \"\"\"Decorator implementation.\n\n        Args:\n            method (Callable): The method to copy the docstring to.\n\n        Returns:\n            Callable: the same method passed in with an updated docstring.\n\n        Raises:\n            google.auth.exceptions.InvalidOperation: if the method already has a docstring.\n        \"\"\"\n        if method.__doc__:\n            raise exceptions.InvalidOperation(\"Method already has a docstring.\")\n\n        source_method = getattr(source_class, method.__name__)\n        method.__doc__ = source_method.__doc__\n\n        return method\n\n    return decorator\n\n\ndef parse_content_type(header_value):\n    \"\"\"Parse a 'content-type' header value to get just the plain media-type (without parameters).\n\n    This is done using the class Message from email.message as suggested in PEP 594\n        (because the cgi is now deprecated and will be removed in python 3.13,\n        see https://peps.python.org/pep-0594/#cgi).\n\n    Args:\n        header_value (str): The value of a 'content-type' header as a string.\n\n    Returns:\n        str: A string with just the lowercase media-type from the parsed 'content-type' header.\n            If the provided content-type is not parsable, returns 'text/plain',\n            the default value for textual files.\n    \"\"\"\n    m = Message()\n    m[\"content-type\"] = header_value\n    return (\n        m.get_content_type()\n    )  # Despite the name, actually returns just the media-type\n\n\ndef utcnow():\n    \"\"\"Returns the current UTC datetime.\n\n    Returns:\n        datetime: The current time in UTC.\n    \"\"\"\n    # We used datetime.utcnow() before, since it's deprecated from python 3.12,\n    # we are using datetime.now(timezone.utc) now. \"utcnow()\" is offset-native\n    # (no timezone info), but \"now()\" is offset-aware (with timezone info).\n    # This will cause datetime comparison problem. For backward compatibility,\n    # we need to remove the timezone info.\n    now = datetime.datetime.now(datetime.timezone.utc)\n    now = now.replace(tzinfo=None)\n    return now\n\n\ndef datetime_to_secs(value):\n    \"\"\"Convert a datetime object to the number of seconds since the UNIX epoch.\n\n    Args:\n        value (datetime): The datetime to convert.\n\n    Returns:\n        int: The number of seconds since the UNIX epoch.\n    \"\"\"\n    return calendar.timegm(value.utctimetuple())\n\n\ndef to_bytes(value, encoding=\"utf-8\"):\n    \"\"\"Converts a string value to bytes, if necessary.\n\n    Args:\n        value (Union[str, bytes]): The value to be converted.\n        encoding (str): The encoding to use to convert unicode to bytes.\n            Defaults to \"utf-8\".\n\n    Returns:\n        bytes: The original value converted to bytes (if unicode) or as\n            passed in if it started out as bytes.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: If the value could not be converted to bytes.\n    \"\"\"\n    result = value.encode(encoding) if isinstance(value, str) else value\n    if isinstance(result, bytes):\n        return result\n    else:\n        raise exceptions.InvalidValue(\n            \"{0!r} could not be converted to bytes\".format(value)\n        )\n\n\ndef from_bytes(value):\n    \"\"\"Converts bytes to a string value, if necessary.\n\n    Args:\n        value (Union[str, bytes]): The value to be converted.\n\n    Returns:\n        str: The original value converted to unicode (if bytes) or as passed in\n            if it started out as unicode.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: If the value could not be converted to unicode.\n    \"\"\"\n    result = value.decode(\"utf-8\") if isinstance(value, bytes) else value\n    if isinstance(result, str):\n        return result\n    else:\n        raise exceptions.InvalidValue(\n            \"{0!r} could not be converted to unicode\".format(value)\n        )\n\n\ndef update_query(url, params, remove=None):\n    \"\"\"Updates a URL's query parameters.\n\n    Replaces any current values if they are already present in the URL.\n\n    Args:\n        url (str): The URL to update.\n        params (Mapping[str, str]): A mapping of query parameter\n            keys to values.\n        remove (Sequence[str]): Parameters to remove from the query string.\n\n    Returns:\n        str: The URL with updated query parameters.\n\n    Examples:\n\n        >>> url = 'http://example.com?a=1'\n        >>> update_query(url, {'a': '2'})\n        http://example.com?a=2\n        >>> update_query(url, {'b': '3'})\n        http://example.com?a=1&b=3\n        >> update_query(url, {'b': '3'}, remove=['a'])\n        http://example.com?b=3\n\n    \"\"\"\n    if remove is None:\n        remove = []\n\n    # Split the URL into parts.\n    parts = urllib.parse.urlparse(url)\n    # Parse the query string.\n    query_params = urllib.parse.parse_qs(parts.query)\n    # Update the query parameters with the new parameters.\n    query_params.update(params)\n    # Remove any values specified in remove.\n    query_params = {\n        key: value for key, value in query_params.items() if key not in remove\n    }\n    # Re-encoded the query string.\n    new_query = urllib.parse.urlencode(query_params, doseq=True)\n    # Unsplit the url.\n    new_parts = parts._replace(query=new_query)\n    return urllib.parse.urlunparse(new_parts)\n\n\ndef scopes_to_string(scopes):\n    \"\"\"Converts scope value to a string suitable for sending to OAuth 2.0\n    authorization servers.\n\n    Args:\n        scopes (Sequence[str]): The sequence of scopes to convert.\n\n    Returns:\n        str: The scopes formatted as a single string.\n    \"\"\"\n    return \" \".join(scopes)\n\n\ndef string_to_scopes(scopes):\n    \"\"\"Converts stringifed scopes value to a list.\n\n    Args:\n        scopes (Union[Sequence, str]): The string of space-separated scopes\n            to convert.\n    Returns:\n        Sequence(str): The separated scopes.\n    \"\"\"\n    if not scopes:\n        return []\n\n    return scopes.split(\" \")\n\n\ndef padded_urlsafe_b64decode(value):\n    \"\"\"Decodes base64 strings lacking padding characters.\n\n    Google infrastructure tends to omit the base64 padding characters.\n\n    Args:\n        value (Union[str, bytes]): The encoded value.\n\n    Returns:\n        bytes: The decoded value\n    \"\"\"\n    b64string = to_bytes(value)\n    padded = b64string + b\"=\" * (-len(b64string) % 4)\n    return base64.urlsafe_b64decode(padded)\n\n\ndef unpadded_urlsafe_b64encode(value):\n    \"\"\"Encodes base64 strings removing any padding characters.\n\n    `rfc 7515`_ defines Base64url to NOT include any padding\n    characters, but the stdlib doesn't do that by default.\n\n    _rfc7515: https://tools.ietf.org/html/rfc7515#page-6\n\n    Args:\n        value (Union[str|bytes]): The bytes-like value to encode\n\n    Returns:\n        Union[str|bytes]: The encoded value\n    \"\"\"\n    return base64.urlsafe_b64encode(value).rstrip(b\"=\")\n\n\ndef is_python_3():\n    \"\"\"Check if the Python interpreter is Python 2 or 3.\n\n    Returns:\n        bool: True if the Python interpreter is Python 3 and False otherwise.\n    \"\"\"\n    return sys.version_info > (3, 0)\n", "google/auth/aws.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"AWS Credentials and AWS Signature V4 Request Signer.\n\nThis module provides credentials to access Google Cloud resources from Amazon\nWeb Services (AWS) workloads. These credentials are recommended over the\nuse of service account credentials in AWS as they do not involve the management\nof long-live service account private keys.\n\nAWS Credentials are initialized using external_account arguments which are\ntypically loaded from the external credentials JSON file.\n\nThis module also provides a definition for an abstract AWS security credentials supplier.\nThis supplier can be implemented to return valid AWS security credentials and an AWS region\nand used to create AWS credentials. The credentials will then call the\nsupplier instead of using pre-defined methods such as calling the EC2 metadata endpoints.\n\nThis module also provides a basic implementation of the\n`AWS Signature Version 4`_ request signing algorithm.\n\nAWS Credentials use serialized signed requests to the\n`AWS STS GetCallerIdentity`_ API that can be exchanged for Google access tokens\nvia the GCP STS endpoint.\n\n.. _AWS Signature Version 4: https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n.. _AWS STS GetCallerIdentity: https://docs.aws.amazon.com/STS/latest/APIReference/API_GetCallerIdentity.html\n\"\"\"\n\nimport abc\nfrom dataclasses import dataclass\nimport hashlib\nimport hmac\nimport http.client as http_client\nimport json\nimport os\nimport posixpath\nimport re\nfrom typing import Optional\nimport urllib\nfrom urllib.parse import urljoin\n\nfrom google.auth import _helpers\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import external_account\n\n# AWS Signature Version 4 signing algorithm identifier.\n_AWS_ALGORITHM = \"AWS4-HMAC-SHA256\"\n# The termination string for the AWS credential scope value as defined in\n# https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n_AWS_REQUEST_TYPE = \"aws4_request\"\n# The AWS authorization header name for the security session token if available.\n_AWS_SECURITY_TOKEN_HEADER = \"x-amz-security-token\"\n# The AWS authorization header name for the auto-generated date.\n_AWS_DATE_HEADER = \"x-amz-date\"\n# The default AWS regional credential verification URL.\n_DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL = (\n    \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\"\n)\n# IMDSV2 session token lifetime. This is set to a low value because the session token is used immediately.\n_IMDSV2_SESSION_TOKEN_TTL_SECONDS = \"300\"\n\n\nclass RequestSigner(object):\n    \"\"\"Implements an AWS request signer based on the AWS Signature Version 4 signing\n    process.\n    https://docs.aws.amazon.com/general/latest/gr/signature-version-4.html\n    \"\"\"\n\n    def __init__(self, region_name):\n        \"\"\"Instantiates an AWS request signer used to compute authenticated signed\n        requests to AWS APIs based on the AWS Signature Version 4 signing process.\n\n        Args:\n            region_name (str): The AWS region to use.\n        \"\"\"\n\n        self._region_name = region_name\n\n    def get_request_options(\n        self,\n        aws_security_credentials,\n        url,\n        method,\n        request_payload=\"\",\n        additional_headers={},\n    ):\n        \"\"\"Generates the signed request for the provided HTTP request for calling\n        an AWS API. This follows the steps described at:\n        https://docs.aws.amazon.com/general/latest/gr/sigv4_signing.html\n\n        Args:\n            aws_security_credentials (AWSSecurityCredentials): The AWS security credentials.\n            url (str): The AWS service URL containing the canonical URI and\n                query string.\n            method (str): The HTTP method used to call this API.\n            request_payload (Optional[str]): The optional request payload if\n                available.\n            additional_headers (Optional[Mapping[str, str]]): The optional\n                additional headers needed for the requested AWS API.\n\n        Returns:\n            Mapping[str, str]: The AWS signed request dictionary object.\n        \"\"\"\n\n        additional_headers = additional_headers or {}\n\n        uri = urllib.parse.urlparse(url)\n        # Normalize the URL path. This is needed for the canonical_uri.\n        # os.path.normpath can't be used since it normalizes \"/\" paths\n        # to \"\\\\\" in Windows OS.\n        normalized_uri = urllib.parse.urlparse(\n            urljoin(url, posixpath.normpath(uri.path))\n        )\n        # Validate provided URL.\n        if not uri.hostname or uri.scheme != \"https\":\n            raise exceptions.InvalidResource(\"Invalid AWS service URL\")\n\n        header_map = _generate_authentication_header_map(\n            host=uri.hostname,\n            canonical_uri=normalized_uri.path or \"/\",\n            canonical_querystring=_get_canonical_querystring(uri.query),\n            method=method,\n            region=self._region_name,\n            aws_security_credentials=aws_security_credentials,\n            request_payload=request_payload,\n            additional_headers=additional_headers,\n        )\n        headers = {\n            \"Authorization\": header_map.get(\"authorization_header\"),\n            \"host\": uri.hostname,\n        }\n        # Add x-amz-date if available.\n        if \"amz_date\" in header_map:\n            headers[_AWS_DATE_HEADER] = header_map.get(\"amz_date\")\n        # Append additional optional headers, eg. X-Amz-Target, Content-Type, etc.\n        for key in additional_headers:\n            headers[key] = additional_headers[key]\n\n        # Add session token if available.\n        if aws_security_credentials.session_token is not None:\n            headers[_AWS_SECURITY_TOKEN_HEADER] = aws_security_credentials.session_token\n\n        signed_request = {\"url\": url, \"method\": method, \"headers\": headers}\n        if request_payload:\n            signed_request[\"data\"] = request_payload\n        return signed_request\n\n\ndef _get_canonical_querystring(query):\n    \"\"\"Generates the canonical query string given a raw query string.\n    Logic is based on\n    https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n\n    Args:\n        query (str): The raw query string.\n\n    Returns:\n        str: The canonical query string.\n    \"\"\"\n    # Parse raw query string.\n    querystring = urllib.parse.parse_qs(query)\n    querystring_encoded_map = {}\n    for key in querystring:\n        quote_key = urllib.parse.quote(key, safe=\"-_.~\")\n        # URI encode key.\n        querystring_encoded_map[quote_key] = []\n        for item in querystring[key]:\n            # For each key, URI encode all values for that key.\n            querystring_encoded_map[quote_key].append(\n                urllib.parse.quote(item, safe=\"-_.~\")\n            )\n        # Sort values for each key.\n        querystring_encoded_map[quote_key].sort()\n    # Sort keys.\n    sorted_keys = list(querystring_encoded_map.keys())\n    sorted_keys.sort()\n    # Reconstruct the query string. Preserve keys with multiple values.\n    querystring_encoded_pairs = []\n    for key in sorted_keys:\n        for item in querystring_encoded_map[key]:\n            querystring_encoded_pairs.append(\"{}={}\".format(key, item))\n    return \"&\".join(querystring_encoded_pairs)\n\n\ndef _sign(key, msg):\n    \"\"\"Creates the HMAC-SHA256 hash of the provided message using the provided\n    key.\n\n    Args:\n        key (str): The HMAC-SHA256 key to use.\n        msg (str): The message to hash.\n\n    Returns:\n        str: The computed hash bytes.\n    \"\"\"\n    return hmac.new(key, msg.encode(\"utf-8\"), hashlib.sha256).digest()\n\n\ndef _get_signing_key(key, date_stamp, region_name, service_name):\n    \"\"\"Calculates the signing key used to calculate the signature for\n    AWS Signature Version 4 based on:\n    https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n\n    Args:\n        key (str): The AWS secret access key.\n        date_stamp (str): The '%Y%m%d' date format.\n        region_name (str): The AWS region.\n        service_name (str): The AWS service name, eg. sts.\n\n    Returns:\n        str: The signing key bytes.\n    \"\"\"\n    k_date = _sign((\"AWS4\" + key).encode(\"utf-8\"), date_stamp)\n    k_region = _sign(k_date, region_name)\n    k_service = _sign(k_region, service_name)\n    k_signing = _sign(k_service, \"aws4_request\")\n    return k_signing\n\n\ndef _generate_authentication_header_map(\n    host,\n    canonical_uri,\n    canonical_querystring,\n    method,\n    region,\n    aws_security_credentials,\n    request_payload=\"\",\n    additional_headers={},\n):\n    \"\"\"Generates the authentication header map needed for generating the AWS\n    Signature Version 4 signed request.\n\n    Args:\n        host (str): The AWS service URL hostname.\n        canonical_uri (str): The AWS service URL path name.\n        canonical_querystring (str): The AWS service URL query string.\n        method (str): The HTTP method used to call this API.\n        region (str): The AWS region.\n        aws_security_credentials (AWSSecurityCredentials): The AWS security credentials.\n        request_payload (Optional[str]): The optional request payload if\n            available.\n        additional_headers (Optional[Mapping[str, str]]): The optional\n            additional headers needed for the requested AWS API.\n\n    Returns:\n        Mapping[str, str]: The AWS authentication header dictionary object.\n            This contains the x-amz-date and authorization header information.\n    \"\"\"\n    # iam.amazonaws.com host => iam service.\n    # sts.us-east-2.amazonaws.com host => sts service.\n    service_name = host.split(\".\")[0]\n\n    current_time = _helpers.utcnow()\n    amz_date = current_time.strftime(\"%Y%m%dT%H%M%SZ\")\n    date_stamp = current_time.strftime(\"%Y%m%d\")\n\n    # Change all additional headers to be lower case.\n    full_headers = {}\n    for key in additional_headers:\n        full_headers[key.lower()] = additional_headers[key]\n    # Add AWS session token if available.\n    if aws_security_credentials.session_token is not None:\n        full_headers[\n            _AWS_SECURITY_TOKEN_HEADER\n        ] = aws_security_credentials.session_token\n\n    # Required headers\n    full_headers[\"host\"] = host\n    # Do not use generated x-amz-date if the date header is provided.\n    # Previously the date was not fixed with x-amz- and could be provided\n    # manually.\n    # https://github.com/boto/botocore/blob/879f8440a4e9ace5d3cf145ce8b3d5e5ffb892ef/tests/unit/auth/aws4_testsuite/get-header-value-trim.req\n    if \"date\" not in full_headers:\n        full_headers[_AWS_DATE_HEADER] = amz_date\n\n    # Header keys need to be sorted alphabetically.\n    canonical_headers = \"\"\n    header_keys = list(full_headers.keys())\n    header_keys.sort()\n    for key in header_keys:\n        canonical_headers = \"{}{}:{}\\n\".format(\n            canonical_headers, key, full_headers[key]\n        )\n    signed_headers = \";\".join(header_keys)\n\n    payload_hash = hashlib.sha256((request_payload or \"\").encode(\"utf-8\")).hexdigest()\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-create-canonical-request.html\n    canonical_request = \"{}\\n{}\\n{}\\n{}\\n{}\\n{}\".format(\n        method,\n        canonical_uri,\n        canonical_querystring,\n        canonical_headers,\n        signed_headers,\n        payload_hash,\n    )\n\n    credential_scope = \"{}/{}/{}/{}\".format(\n        date_stamp, region, service_name, _AWS_REQUEST_TYPE\n    )\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-create-string-to-sign.html\n    string_to_sign = \"{}\\n{}\\n{}\\n{}\".format(\n        _AWS_ALGORITHM,\n        amz_date,\n        credential_scope,\n        hashlib.sha256(canonical_request.encode(\"utf-8\")).hexdigest(),\n    )\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-calculate-signature.html\n    signing_key = _get_signing_key(\n        aws_security_credentials.secret_access_key, date_stamp, region, service_name\n    )\n    signature = hmac.new(\n        signing_key, string_to_sign.encode(\"utf-8\"), hashlib.sha256\n    ).hexdigest()\n\n    # https://docs.aws.amazon.com/general/latest/gr/sigv4-add-signature-to-request.html\n    authorization_header = \"{} Credential={}/{}, SignedHeaders={}, Signature={}\".format(\n        _AWS_ALGORITHM,\n        aws_security_credentials.access_key_id,\n        credential_scope,\n        signed_headers,\n        signature,\n    )\n\n    authentication_header = {\"authorization_header\": authorization_header}\n    # Do not use generated x-amz-date if the date header is provided.\n    if \"date\" not in full_headers:\n        authentication_header[\"amz_date\"] = amz_date\n    return authentication_header\n\n\n@dataclass\nclass AwsSecurityCredentials:\n    \"\"\"A class that models AWS security credentials with an optional session token.\n\n        Attributes:\n            access_key_id (str): The AWS security credentials access key id.\n            secret_access_key (str): The AWS security credentials secret access key.\n            session_token (Optional[str]): The optional AWS security credentials session token. This should be set when using temporary credentials.\n    \"\"\"\n\n    access_key_id: str\n    secret_access_key: str\n    session_token: Optional[str] = None\n\n\nclass AwsSecurityCredentialsSupplier(metaclass=abc.ABCMeta):\n    \"\"\"Base class for AWS security credential suppliers. This can be implemented with custom logic to retrieve\n    AWS security credentials to exchange for a Google Cloud access token. The AWS external account credential does\n    not cache the AWS security credentials, so caching logic should be added in the implementation.\n    \"\"\"\n\n    @abc.abstractmethod\n    def get_aws_security_credentials(self, context, request):\n        \"\"\"Returns the AWS security credentials for the requested context.\n\n        .. warning: This is not cached by the calling Google credential, so caching logic should be implemented in the supplier.\n\n        Args:\n            context (google.auth.externalaccount.SupplierContext): The context object\n                containing information about the requested audience and subject token type.\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                security credential retrieval logic.\n\n        Returns:\n            AwsSecurityCredentials: The requested AWS security credentials.\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n    @abc.abstractmethod\n    def get_aws_region(self, context, request):\n        \"\"\"Returns the AWS region for the requested context.\n\n        Args:\n            context (google.auth.externalaccount.SupplierContext): The context object\n                containing information about the requested audience and subject token type.\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                region retrieval logic.\n\n        Returns:\n            str: The AWS region.\n        \"\"\"\n        raise NotImplementedError(\"\")\n\n\nclass _DefaultAwsSecurityCredentialsSupplier(AwsSecurityCredentialsSupplier):\n    \"\"\"Default implementation of AWS security credentials supplier. Supports retrieving\n    credentials and region via EC2 metadata endpoints and environment variables.\n    \"\"\"\n\n    def __init__(self, credential_source):\n        self._region_url = credential_source.get(\"region_url\")\n        self._security_credentials_url = credential_source.get(\"url\")\n        self._imdsv2_session_token_url = credential_source.get(\n            \"imdsv2_session_token_url\"\n        )\n\n    @_helpers.copy_docstring(AwsSecurityCredentialsSupplier)\n    def get_aws_security_credentials(self, context, request):\n\n        # Check environment variables for permanent credentials first.\n        # https://docs.aws.amazon.com/general/latest/gr/aws-sec-cred-types.html\n        env_aws_access_key_id = os.environ.get(environment_vars.AWS_ACCESS_KEY_ID)\n        env_aws_secret_access_key = os.environ.get(\n            environment_vars.AWS_SECRET_ACCESS_KEY\n        )\n        # This is normally not available for permanent credentials.\n        env_aws_session_token = os.environ.get(environment_vars.AWS_SESSION_TOKEN)\n        if env_aws_access_key_id and env_aws_secret_access_key:\n            return AwsSecurityCredentials(\n                env_aws_access_key_id, env_aws_secret_access_key, env_aws_session_token\n            )\n\n        imdsv2_session_token = self._get_imdsv2_session_token(request)\n        role_name = self._get_metadata_role_name(request, imdsv2_session_token)\n\n        # Get security credentials.\n        credentials = self._get_metadata_security_credentials(\n            request, role_name, imdsv2_session_token\n        )\n\n        return AwsSecurityCredentials(\n            credentials.get(\"AccessKeyId\"),\n            credentials.get(\"SecretAccessKey\"),\n            credentials.get(\"Token\"),\n        )\n\n    @_helpers.copy_docstring(AwsSecurityCredentialsSupplier)\n    def get_aws_region(self, context, request):\n        # The AWS metadata server is not available in some AWS environments\n        # such as AWS lambda. Instead, it is available via environment\n        # variable.\n        env_aws_region = os.environ.get(environment_vars.AWS_REGION)\n        if env_aws_region is not None:\n            return env_aws_region\n\n        env_aws_region = os.environ.get(environment_vars.AWS_DEFAULT_REGION)\n        if env_aws_region is not None:\n            return env_aws_region\n\n        if not self._region_url:\n            raise exceptions.RefreshError(\"Unable to determine AWS region\")\n\n        headers = None\n        imdsv2_session_token = self._get_imdsv2_session_token(request)\n        if imdsv2_session_token is not None:\n            headers = {\"X-aws-ec2-metadata-token\": imdsv2_session_token}\n\n        response = request(url=self._region_url, method=\"GET\", headers=headers)\n\n        # Support both string and bytes type response.data.\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve AWS region: {}\".format(response_body)\n            )\n\n        # This endpoint will return the region in format: us-east-2b.\n        # Only the us-east-2 part should be used.\n        return response_body[:-1]\n\n    def _get_imdsv2_session_token(self, request):\n        if request is not None and self._imdsv2_session_token_url is not None:\n            headers = {\n                \"X-aws-ec2-metadata-token-ttl-seconds\": _IMDSV2_SESSION_TOKEN_TTL_SECONDS\n            }\n\n            imdsv2_session_token_response = request(\n                url=self._imdsv2_session_token_url, method=\"PUT\", headers=headers\n            )\n\n            if imdsv2_session_token_response.status != http_client.OK:\n                raise exceptions.RefreshError(\n                    \"Unable to retrieve AWS Session Token: {}\".format(\n                        imdsv2_session_token_response.data\n                    )\n                )\n\n            return imdsv2_session_token_response.data\n        else:\n            return None\n\n    def _get_metadata_security_credentials(\n        self, request, role_name, imdsv2_session_token\n    ):\n        \"\"\"Retrieves the AWS security credentials required for signing AWS\n        requests from the AWS metadata server.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            role_name (str): The AWS role name required by the AWS metadata\n                server security_credentials endpoint in order to return the\n                credentials.\n            imdsv2_session_token (str): The AWS IMDSv2 session token to be added as a\n                header in the requests to AWS metadata endpoint.\n\n        Returns:\n            Mapping[str, str]: The AWS metadata server security credentials\n                response.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error occurs while\n                retrieving the AWS security credentials.\n        \"\"\"\n        headers = {\"Content-Type\": \"application/json\"}\n        if imdsv2_session_token is not None:\n            headers[\"X-aws-ec2-metadata-token\"] = imdsv2_session_token\n\n        response = request(\n            url=\"{}/{}\".format(self._security_credentials_url, role_name),\n            method=\"GET\",\n            headers=headers,\n        )\n\n        # support both string and bytes type response.data\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve AWS security credentials: {}\".format(response_body)\n            )\n\n        credentials_response = json.loads(response_body)\n\n        return credentials_response\n\n    def _get_metadata_role_name(self, request, imdsv2_session_token):\n        \"\"\"Retrieves the AWS role currently attached to the current AWS\n        workload by querying the AWS metadata server. This is needed for the\n        AWS metadata server security credentials endpoint in order to retrieve\n        the AWS security credentials needed to sign requests to AWS APIs.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n            imdsv2_session_token (str): The AWS IMDSv2 session token to be added as a\n                header in the requests to AWS metadata endpoint.\n\n        Returns:\n            str: The AWS role name.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error occurs while\n                retrieving the AWS role name.\n        \"\"\"\n        if self._security_credentials_url is None:\n            raise exceptions.RefreshError(\n                \"Unable to determine the AWS metadata server security credentials endpoint\"\n            )\n\n        headers = None\n        if imdsv2_session_token is not None:\n            headers = {\"X-aws-ec2-metadata-token\": imdsv2_session_token}\n\n        response = request(\n            url=self._security_credentials_url, method=\"GET\", headers=headers\n        )\n\n        # support both string and bytes type response.data\n        response_body = (\n            response.data.decode(\"utf-8\")\n            if hasattr(response.data, \"decode\")\n            else response.data\n        )\n\n        if response.status != http_client.OK:\n            raise exceptions.RefreshError(\n                \"Unable to retrieve AWS role name {}\".format(response_body)\n            )\n\n        return response_body\n\n\nclass Credentials(external_account.Credentials):\n    \"\"\"AWS external account credentials.\n    This is used to exchange serialized AWS signature v4 signed requests to\n    AWS STS GetCallerIdentity service for Google access tokens.\n    \"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url=external_account._DEFAULT_TOKEN_URL,\n        credential_source=None,\n        aws_security_credentials_supplier=None,\n        *args,\n        **kwargs\n    ):\n        \"\"\"Instantiates an AWS workload external account credentials object.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:aws:token-type:aws4_request\u201d\n\n            token_url (Optional [str]): The STS endpoint URL. If not provided, will default to \"https://sts.googleapis.com/v1/token\".\n            credential_source (Optional [Mapping]): The credential source dictionary used\n                to provide instructions on how to retrieve external credential to be exchanged for Google access tokens.\n                Either a credential source or an AWS security credentials supplier must be provided.\n\n                Example credential_source for AWS credential::\n\n                    {\n                        \"environment_id\": \"aws1\",\n                        \"regional_cred_verification_url\": \"https://sts.{region}.amazonaws.com?Action=GetCallerIdentity&Version=2011-06-15\",\n                        \"region_url\": \"http://169.254.169.254/latest/meta-data/placement/availability-zone\",\n                        \"url\": \"http://169.254.169.254/latest/meta-data/iam/security-credentials\",\n                        imdsv2_session_token_url\": \"http://169.254.169.254/latest/api/token\"\n                    }\n\n            aws_security_credentials_supplier (Optional [AwsSecurityCredentialsSupplier]): Optional AWS security credentials supplier.\n                This will be called to supply valid AWS security credentails which will then\n                be exchanged for Google access tokens. Either an AWS security credentials supplier\n                or a credential source must be provided.\n            args (List): Optional positional arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n            kwargs (Mapping): Optional keyword arguments passed into the underlying :meth:`~external_account.Credentials.__init__` method.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If an error is encountered during\n                access token retrieval logic.\n            ValueError: For invalid parameters.\n\n        .. note:: Typically one of the helper constructors\n            :meth:`from_file` or\n            :meth:`from_info` are used instead of calling the constructor directly.\n        \"\"\"\n        super(Credentials, self).__init__(\n            audience=audience,\n            subject_token_type=subject_token_type,\n            token_url=token_url,\n            credential_source=credential_source,\n            *args,\n            **kwargs\n        )\n        if credential_source is None and aws_security_credentials_supplier is None:\n            raise exceptions.InvalidValue(\n                \"A valid credential source or AWS security credentials supplier must be provided.\"\n            )\n        if (\n            credential_source is not None\n            and aws_security_credentials_supplier is not None\n        ):\n            raise exceptions.InvalidValue(\n                \"AWS credential cannot have both a credential source and an AWS security credentials supplier.\"\n            )\n\n        if aws_security_credentials_supplier:\n            self._aws_security_credentials_supplier = aws_security_credentials_supplier\n            # The regional cred verification URL would normally be provided through the credential source. So set it to the default one here.\n            self._cred_verification_url = (\n                _DEFAULT_AWS_REGIONAL_CREDENTIAL_VERIFICATION_URL\n            )\n        else:\n            environment_id = credential_source.get(\"environment_id\") or \"\"\n            self._aws_security_credentials_supplier = _DefaultAwsSecurityCredentialsSupplier(\n                credential_source\n            )\n            self._cred_verification_url = credential_source.get(\n                \"regional_cred_verification_url\"\n            )\n\n            # Get the environment ID, i.e. \"aws1\". Currently, only one version supported (1).\n            matches = re.match(r\"^(aws)([\\d]+)$\", environment_id)\n            if matches:\n                env_id, env_version = matches.groups()\n            else:\n                env_id, env_version = (None, None)\n\n            if env_id != \"aws\" or self._cred_verification_url is None:\n                raise exceptions.InvalidResource(\n                    \"No valid AWS 'credential_source' provided\"\n                )\n            elif env_version is None or int(env_version) != 1:\n                raise exceptions.InvalidValue(\n                    \"aws version '{}' is not supported in the current build.\".format(\n                        env_version\n                    )\n                )\n\n        self._target_resource = audience\n        self._request_signer = None\n\n    def retrieve_subject_token(self, request):\n        \"\"\"Retrieves the subject token using the credential_source object.\n        The subject token is a serialized `AWS GetCallerIdentity signed request`_.\n\n        The logic is summarized as:\n\n        Retrieve the AWS region from the AWS_REGION or AWS_DEFAULT_REGION\n        environment variable or from the AWS metadata server availability-zone\n        if not found in the environment variable.\n\n        Check AWS credentials in environment variables. If not found, retrieve\n        from the AWS metadata server security-credentials endpoint.\n\n        When retrieving AWS credentials from the metadata server\n        security-credentials endpoint, the AWS role needs to be determined by\n        calling the security-credentials endpoint without any argument. Then the\n        credentials can be retrieved via: security-credentials/role_name\n\n        Generate the signed request to AWS STS GetCallerIdentity action.\n\n        Inject x-goog-cloud-target-resource into header and serialize the\n        signed request. This will be the subject-token to pass to GCP STS.\n\n        .. _AWS GetCallerIdentity signed request:\n            https://cloud.google.com/iam/docs/access-resources-aws#exchange-token\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Returns:\n            str: The retrieved subject token.\n        \"\"\"\n\n        # Initialize the request signer if not yet initialized after determining\n        # the current AWS region.\n        if self._request_signer is None:\n            self._region = self._aws_security_credentials_supplier.get_aws_region(\n                self._supplier_context, request\n            )\n            self._request_signer = RequestSigner(self._region)\n\n        # Retrieve the AWS security credentials needed to generate the signed\n        # request.\n        aws_security_credentials = self._aws_security_credentials_supplier.get_aws_security_credentials(\n            self._supplier_context, request\n        )\n        # Generate the signed request to AWS STS GetCallerIdentity API.\n        # Use the required regional endpoint. Otherwise, the request will fail.\n        request_options = self._request_signer.get_request_options(\n            aws_security_credentials,\n            self._cred_verification_url.replace(\"{region}\", self._region),\n            \"POST\",\n        )\n        # The GCP STS endpoint expects the headers to be formatted as:\n        # [\n        #   {key: 'x-amz-date', value: '...'},\n        #   {key: 'Authorization', value: '...'},\n        #   ...\n        # ]\n        # And then serialized as:\n        # quote(json.dumps({\n        #   url: '...',\n        #   method: 'POST',\n        #   headers: [{key: 'x-amz-date', value: '...'}, ...]\n        # }))\n        request_headers = request_options.get(\"headers\")\n        # The full, canonical resource name of the workload identity pool\n        # provider, with or without the HTTPS prefix.\n        # Including this header as part of the signature is recommended to\n        # ensure data integrity.\n        request_headers[\"x-goog-cloud-target-resource\"] = self._target_resource\n\n        # Serialize AWS signed request.\n        aws_signed_req = {}\n        aws_signed_req[\"url\"] = request_options.get(\"url\")\n        aws_signed_req[\"method\"] = request_options.get(\"method\")\n        aws_signed_req[\"headers\"] = []\n        # Reformat header to GCP STS expected format.\n        for key in request_headers.keys():\n            aws_signed_req[\"headers\"].append(\n                {\"key\": key, \"value\": request_headers[key]}\n            )\n\n        return urllib.parse.quote(\n            json.dumps(aws_signed_req, separators=(\",\", \":\"), sort_keys=True)\n        )\n\n    def _create_default_metrics_options(self):\n        metrics_options = super(Credentials, self)._create_default_metrics_options()\n        metrics_options[\"source\"] = \"aws\"\n        if self._has_custom_supplier():\n            metrics_options[\"source\"] = \"programmatic\"\n        return metrics_options\n\n    def _has_custom_supplier(self):\n        return self._credential_source is None\n\n    def _constructor_args(self):\n        args = super(Credentials, self)._constructor_args()\n        # If a custom supplier was used, append it to the args dict.\n        if self._has_custom_supplier():\n            args.update(\n                {\n                    \"aws_security_credentials_supplier\": self._aws_security_credentials_supplier\n                }\n            )\n        return args\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates an AWS Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The AWS external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.aws.Credentials: The constructed credentials.\n\n        Raises:\n            ValueError: For invalid parameters.\n        \"\"\"\n        aws_security_credentials_supplier = info.get(\n            \"aws_security_credentials_supplier\"\n        )\n        kwargs.update(\n            {\"aws_security_credentials_supplier\": aws_security_credentials_supplier}\n        )\n        return super(Credentials, cls).from_info(info, **kwargs)\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates an AWS Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the AWS external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.aws.Credentials: The constructed credentials.\n        \"\"\"\n        return super(Credentials, cls).from_file(filename, **kwargs)\n", "google/auth/jwt.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"JSON Web Tokens\n\nProvides support for creating (encoding) and verifying (decoding) JWTs,\nespecially JWTs generated and consumed by Google infrastructure.\n\nSee `rfc7519`_ for more details on JWTs.\n\nTo encode a JWT use :func:`encode`::\n\n    from google.auth import crypt\n    from google.auth import jwt\n\n    signer = crypt.Signer(private_key)\n    payload = {'some': 'payload'}\n    encoded = jwt.encode(signer, payload)\n\nTo decode a JWT and verify claims use :func:`decode`::\n\n    claims = jwt.decode(encoded, certs=public_certs)\n\nYou can also skip verification::\n\n    claims = jwt.decode(encoded, verify=False)\n\n.. _rfc7519: https://tools.ietf.org/html/rfc7519\n\n\"\"\"\n\ntry:\n    from collections.abc import Mapping\n# Python 2.7 compatibility\nexcept ImportError:  # pragma: NO COVER\n    from collections import Mapping  # type: ignore\nimport copy\nimport datetime\nimport json\nimport urllib\n\nimport cachetools\n\nfrom google.auth import _helpers\nfrom google.auth import _service_account_info\nfrom google.auth import crypt\nfrom google.auth import exceptions\nimport google.auth.credentials\n\ntry:\n    from google.auth.crypt import es256\nexcept ImportError:  # pragma: NO COVER\n    es256 = None  # type: ignore\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n_DEFAULT_MAX_CACHE_SIZE = 10\n_ALGORITHM_TO_VERIFIER_CLASS = {\"RS256\": crypt.RSAVerifier}\n_CRYPTOGRAPHY_BASED_ALGORITHMS = frozenset([\"ES256\"])\n\nif es256 is not None:  # pragma: NO COVER\n    _ALGORITHM_TO_VERIFIER_CLASS[\"ES256\"] = es256.ES256Verifier  # type: ignore\n\n\ndef encode(signer, payload, header=None, key_id=None):\n    \"\"\"Make a signed JWT.\n\n    Args:\n        signer (google.auth.crypt.Signer): The signer used to sign the JWT.\n        payload (Mapping[str, str]): The JWT payload.\n        header (Mapping[str, str]): Additional JWT header payload.\n        key_id (str): The key id to add to the JWT header. If the\n            signer has a key id it will be used as the default. If this is\n            specified it will override the signer's key id.\n\n    Returns:\n        bytes: The encoded JWT.\n    \"\"\"\n    if header is None:\n        header = {}\n\n    if key_id is None:\n        key_id = signer.key_id\n\n    header.update({\"typ\": \"JWT\"})\n\n    if \"alg\" not in header:\n        if es256 is not None and isinstance(signer, es256.ES256Signer):\n            header.update({\"alg\": \"ES256\"})\n        else:\n            header.update({\"alg\": \"RS256\"})\n\n    if key_id is not None:\n        header[\"kid\"] = key_id\n\n    segments = [\n        _helpers.unpadded_urlsafe_b64encode(json.dumps(header).encode(\"utf-8\")),\n        _helpers.unpadded_urlsafe_b64encode(json.dumps(payload).encode(\"utf-8\")),\n    ]\n\n    signing_input = b\".\".join(segments)\n    signature = signer.sign(signing_input)\n    segments.append(_helpers.unpadded_urlsafe_b64encode(signature))\n\n    return b\".\".join(segments)\n\n\ndef _decode_jwt_segment(encoded_section):\n    \"\"\"Decodes a single JWT segment.\"\"\"\n    section_bytes = _helpers.padded_urlsafe_b64decode(encoded_section)\n    try:\n        return json.loads(section_bytes.decode(\"utf-8\"))\n    except ValueError as caught_exc:\n        new_exc = exceptions.MalformedError(\n            \"Can't parse segment: {0}\".format(section_bytes)\n        )\n        raise new_exc from caught_exc\n\n\ndef _unverified_decode(token):\n    \"\"\"Decodes a token and does no verification.\n\n    Args:\n        token (Union[str, bytes]): The encoded JWT.\n\n    Returns:\n        Tuple[Mapping, Mapping, str, str]: header, payload, signed_section, and\n            signature.\n\n    Raises:\n        google.auth.exceptions.MalformedError: if there are an incorrect amount of segments in the token or segments of the wrong type.\n    \"\"\"\n    token = _helpers.to_bytes(token)\n\n    if token.count(b\".\") != 2:\n        raise exceptions.MalformedError(\n            \"Wrong number of segments in token: {0}\".format(token)\n        )\n\n    encoded_header, encoded_payload, signature = token.split(b\".\")\n    signed_section = encoded_header + b\".\" + encoded_payload\n    signature = _helpers.padded_urlsafe_b64decode(signature)\n\n    # Parse segments\n    header = _decode_jwt_segment(encoded_header)\n    payload = _decode_jwt_segment(encoded_payload)\n\n    if not isinstance(header, Mapping):\n        raise exceptions.MalformedError(\n            \"Header segment should be a JSON object: {0}\".format(encoded_header)\n        )\n\n    if not isinstance(payload, Mapping):\n        raise exceptions.MalformedError(\n            \"Payload segment should be a JSON object: {0}\".format(encoded_payload)\n        )\n\n    return header, payload, signed_section, signature\n\n\ndef decode_header(token):\n    \"\"\"Return the decoded header of a token.\n\n    No verification is done. This is useful to extract the key id from\n    the header in order to acquire the appropriate certificate to verify\n    the token.\n\n    Args:\n        token (Union[str, bytes]): the encoded JWT.\n\n    Returns:\n        Mapping: The decoded JWT header.\n    \"\"\"\n    header, _, _, _ = _unverified_decode(token)\n    return header\n\n\ndef _verify_iat_and_exp(payload, clock_skew_in_seconds=0):\n    \"\"\"Verifies the ``iat`` (Issued At) and ``exp`` (Expires) claims in a token\n    payload.\n\n    Args:\n        payload (Mapping[str, str]): The JWT payload.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: if value validation failed.\n        google.auth.exceptions.MalformedError: if schema validation failed.\n    \"\"\"\n    now = _helpers.datetime_to_secs(_helpers.utcnow())\n\n    # Make sure the iat and exp claims are present.\n    for key in (\"iat\", \"exp\"):\n        if key not in payload:\n            raise exceptions.MalformedError(\n                \"Token does not contain required claim {}\".format(key)\n            )\n\n    # Make sure the token wasn't issued in the future.\n    iat = payload[\"iat\"]\n    # Err on the side of accepting a token that is slightly early to account\n    # for clock skew.\n    earliest = iat - clock_skew_in_seconds\n    if now < earliest:\n        raise exceptions.InvalidValue(\n            \"Token used too early, {} < {}. Check that your computer's clock is set correctly.\".format(\n                now, iat\n            )\n        )\n\n    # Make sure the token wasn't issued in the past.\n    exp = payload[\"exp\"]\n    # Err on the side of accepting a token that is slightly out of date\n    # to account for clow skew.\n    latest = exp + clock_skew_in_seconds\n    if latest < now:\n        raise exceptions.InvalidValue(\"Token expired, {} < {}\".format(latest, now))\n\n\ndef decode(token, certs=None, verify=True, audience=None, clock_skew_in_seconds=0):\n    \"\"\"Decode and verify a JWT.\n\n    Args:\n        token (str): The encoded JWT.\n        certs (Union[str, bytes, Mapping[str, Union[str, bytes]]]): The\n            certificate used to validate the JWT signature. If bytes or string,\n            it must the the public key certificate in PEM format. If a mapping,\n            it must be a mapping of key IDs to public key certificates in PEM\n            format. The mapping must contain the same key ID that's specified\n            in the token's header.\n        verify (bool): Whether to perform signature and claim validation.\n            Verification is done by default.\n        audience (str or list): The audience claim, 'aud', that this JWT should\n            contain. Or a list of audience claims. If None then the JWT's 'aud'\n            parameter is not verified.\n        clock_skew_in_seconds (int): The clock skew used for `iat` and `exp`\n            validation.\n\n    Returns:\n        Mapping[str, str]: The deserialized JSON payload in the JWT.\n\n    Raises:\n        google.auth.exceptions.InvalidValue: if value validation failed.\n        google.auth.exceptions.MalformedError: if schema validation failed.\n    \"\"\"\n    header, payload, signed_section, signature = _unverified_decode(token)\n\n    if not verify:\n        return payload\n\n    # Pluck the key id and algorithm from the header and make sure we have\n    # a verifier that can support it.\n    key_alg = header.get(\"alg\")\n    key_id = header.get(\"kid\")\n\n    try:\n        verifier_cls = _ALGORITHM_TO_VERIFIER_CLASS[key_alg]\n    except KeyError as exc:\n        if key_alg in _CRYPTOGRAPHY_BASED_ALGORITHMS:\n            raise exceptions.InvalidValue(\n                \"The key algorithm {} requires the cryptography package to be installed.\".format(\n                    key_alg\n                )\n            ) from exc\n        else:\n            raise exceptions.InvalidValue(\n                \"Unsupported signature algorithm {}\".format(key_alg)\n            ) from exc\n    # If certs is specified as a dictionary of key IDs to certificates, then\n    # use the certificate identified by the key ID in the token header.\n    if isinstance(certs, Mapping):\n        if key_id:\n            if key_id not in certs:\n                raise exceptions.MalformedError(\n                    \"Certificate for key id {} not found.\".format(key_id)\n                )\n            certs_to_check = [certs[key_id]]\n        # If there's no key id in the header, check against all of the certs.\n        else:\n            certs_to_check = certs.values()\n    else:\n        certs_to_check = certs\n\n    # Verify that the signature matches the message.\n    if not crypt.verify_signature(\n        signed_section, signature, certs_to_check, verifier_cls\n    ):\n        raise exceptions.MalformedError(\"Could not verify token signature.\")\n\n    # Verify the issued at and created times in the payload.\n    _verify_iat_and_exp(payload, clock_skew_in_seconds)\n\n    # Check audience.\n    if audience is not None:\n        claim_audience = payload.get(\"aud\")\n        if isinstance(audience, str):\n            audience = [audience]\n        if claim_audience not in audience:\n            raise exceptions.InvalidValue(\n                \"Token has wrong audience {}, expected one of {}\".format(\n                    claim_audience, audience\n                )\n            )\n\n    return payload\n\n\nclass Credentials(\n    google.auth.credentials.Signing, google.auth.credentials.CredentialsWithQuotaProject\n):\n    \"\"\"Credentials that use a JWT as the bearer token.\n\n    These credentials require an \"audience\" claim. This claim identifies the\n    intended recipient of the bearer token.\n\n    The constructor arguments determine the claims for the JWT that is\n    sent with requests. Usually, you'll construct these credentials with\n    one of the helper constructors as shown in the next section.\n\n    To create JWT credentials using a Google service account private key\n    JSON file::\n\n        audience = 'https://pubsub.googleapis.com/google.pubsub.v1.Publisher'\n        credentials = jwt.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience)\n\n    If you already have the service account file loaded and parsed::\n\n        service_account_info = json.load(open('service_account.json'))\n        credentials = jwt.Credentials.from_service_account_info(\n            service_account_info,\n            audience=audience)\n\n    Both helper methods pass on arguments to the constructor, so you can\n    specify the JWT claims::\n\n        credentials = jwt.Credentials.from_service_account_file(\n            'service-account.json',\n            audience=audience,\n            additional_claims={'meta': 'data'})\n\n    You can also construct the credentials directly if you have a\n    :class:`~google.auth.crypt.Signer` instance::\n\n        credentials = jwt.Credentials(\n            signer,\n            issuer='your-issuer',\n            subject='your-subject',\n            audience=audience)\n\n    The claims are considered immutable. If you want to modify the claims,\n    you can easily create another instance using :meth:`with_claims`::\n\n        new_audience = (\n            'https://pubsub.googleapis.com/google.pubsub.v1.Subscriber')\n        new_credentials = credentials.with_claims(audience=new_audience)\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        issuer,\n        subject,\n        audience,\n        additional_claims=None,\n        token_lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            issuer (str): The `iss` claim.\n            subject (str): The `sub` claim.\n            audience (str): the `aud` claim. The intended audience for the\n                credentials.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload.\n            token_lifetime (int): The amount of time in seconds for\n                which the token is valid. Defaults to 1 hour.\n            quota_project_id (Optional[str]): The project ID used for quota\n                and billing.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self._signer = signer\n        self._issuer = issuer\n        self._subject = subject\n        self._audience = audience\n        self._token_lifetime = token_lifetime\n        self._quota_project_id = quota_project_id\n\n        if additional_claims is None:\n            additional_claims = {}\n\n        self._additional_claims = additional_claims\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates a Credentials instance from a signer and service account\n        info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        kwargs.setdefault(\"subject\", info[\"client_email\"])\n        kwargs.setdefault(\"issuer\", info[\"client_email\"])\n        return cls(signer, **kwargs)\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates an Credentials instance from a dictionary.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(info, require=[\"client_email\"])\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from a service account .json file\n        in Google format.\n\n        Args:\n            filename (str): The path to the service account .json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: The constructed credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_signing_credentials(cls, credentials, audience, **kwargs):\n        \"\"\"Creates a new :class:`google.auth.jwt.Credentials` instance from an\n        existing :class:`google.auth.credentials.Signing` instance.\n\n        The new instance will use the same signer as the existing instance and\n        will use the existing instance's signer email as the issuer and\n        subject by default.\n\n        Example::\n\n            svc_creds = service_account.Credentials.from_service_account_file(\n                'service_account.json')\n            audience = (\n                'https://pubsub.googleapis.com/google.pubsub.v1.Publisher')\n            jwt_creds = jwt.Credentials.from_signing_credentials(\n                svc_creds, audience=audience)\n\n        Args:\n            credentials (google.auth.credentials.Signing): The credentials to\n                use to construct the new credentials.\n            audience (str): the `aud` claim. The intended audience for the\n                credentials.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: A new Credentials instance.\n        \"\"\"\n        kwargs.setdefault(\"issuer\", credentials.signer_email)\n        kwargs.setdefault(\"subject\", credentials.signer_email)\n        return cls(credentials.signer, audience=audience, **kwargs)\n\n    def with_claims(\n        self, issuer=None, subject=None, audience=None, additional_claims=None\n    ):\n        \"\"\"Returns a copy of these credentials with modified claims.\n\n        Args:\n            issuer (str): The `iss` claim. If unspecified the current issuer\n                claim will be used.\n            subject (str): The `sub` claim. If unspecified the current subject\n                claim will be used.\n            audience (str): the `aud` claim. If unspecified the current\n                audience claim will be used.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload. This will be merged with the current\n                additional claims.\n\n        Returns:\n            google.auth.jwt.Credentials: A new credentials instance.\n        \"\"\"\n        new_additional_claims = copy.deepcopy(self._additional_claims)\n        new_additional_claims.update(additional_claims or {})\n\n        return self.__class__(\n            self._signer,\n            issuer=issuer if issuer is not None else self._issuer,\n            subject=subject if subject is not None else self._subject,\n            audience=audience if audience is not None else self._audience,\n            additional_claims=new_additional_claims,\n            quota_project_id=self._quota_project_id,\n        )\n\n    @_helpers.copy_docstring(google.auth.credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        return self.__class__(\n            self._signer,\n            issuer=self._issuer,\n            subject=self._subject,\n            audience=self._audience,\n            additional_claims=self._additional_claims,\n            quota_project_id=quota_project_id,\n        )\n\n    def _make_jwt(self):\n        \"\"\"Make a signed JWT.\n\n        Returns:\n            Tuple[bytes, datetime]: The encoded JWT and the expiration.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=self._token_lifetime)\n        expiry = now + lifetime\n\n        payload = {\n            \"iss\": self._issuer,\n            \"sub\": self._subject,\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n        }\n        if self._audience:\n            payload[\"aud\"] = self._audience\n\n        payload.update(self._additional_claims)\n\n        jwt = encode(self._signer, payload)\n\n        return jwt, expiry\n\n    def refresh(self, request):\n        \"\"\"Refreshes the access token.\n\n        Args:\n            request (Any): Unused.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (pylint doesn't correctly recognize overridden methods.)\n        self.token, self.expiry = self._make_jwt()\n\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer_email(self):\n        return self._issuer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    @property  # type: ignore\n    def additional_claims(self):\n        \"\"\" Additional claims the JWT object was created with.\"\"\"\n        return self._additional_claims\n\n\nclass OnDemandCredentials(\n    google.auth.credentials.Signing, google.auth.credentials.CredentialsWithQuotaProject\n):\n    \"\"\"On-demand JWT credentials.\n\n    Like :class:`Credentials`, this class uses a JWT as the bearer token for\n    authentication. However, this class does not require the audience at\n    construction time. Instead, it will generate a new token on-demand for\n    each request using the request URI as the audience. It caches tokens\n    so that multiple requests to the same URI do not incur the overhead\n    of generating a new token every time.\n\n    This behavior is especially useful for `gRPC`_ clients. A gRPC service may\n    have multiple audience and gRPC clients may not know all of the audiences\n    required for accessing a particular service. With these credentials,\n    no knowledge of the audiences is required ahead of time.\n\n    .. _grpc: http://www.grpc.io/\n    \"\"\"\n\n    def __init__(\n        self,\n        signer,\n        issuer,\n        subject,\n        additional_claims=None,\n        token_lifetime=_DEFAULT_TOKEN_LIFETIME_SECS,\n        max_cache_size=_DEFAULT_MAX_CACHE_SIZE,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            issuer (str): The `iss` claim.\n            subject (str): The `sub` claim.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload.\n            token_lifetime (int): The amount of time in seconds for\n                which the token is valid. Defaults to 1 hour.\n            max_cache_size (int): The maximum number of JWT tokens to keep in\n                cache. Tokens are cached using :class:`cachetools.LRUCache`.\n            quota_project_id (Optional[str]): The project ID used for quota\n                and billing.\n\n        \"\"\"\n        super(OnDemandCredentials, self).__init__()\n        self._signer = signer\n        self._issuer = issuer\n        self._subject = subject\n        self._token_lifetime = token_lifetime\n        self._quota_project_id = quota_project_id\n\n        if additional_claims is None:\n            additional_claims = {}\n\n        self._additional_claims = additional_claims\n        self._cache = cachetools.LRUCache(maxsize=max_cache_size)\n\n    @classmethod\n    def _from_signer_and_info(cls, signer, info, **kwargs):\n        \"\"\"Creates an OnDemandCredentials instance from a signer and service\n        account info.\n\n        Args:\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n            info (Mapping[str, str]): The service account info.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        kwargs.setdefault(\"subject\", info[\"client_email\"])\n        kwargs.setdefault(\"issuer\", info[\"client_email\"])\n        return cls(signer, **kwargs)\n\n    @classmethod\n    def from_service_account_info(cls, info, **kwargs):\n        \"\"\"Creates an OnDemandCredentials instance from a dictionary.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: The constructed credentials.\n\n        Raises:\n            google.auth.exceptions.MalformedError: If the info is not in the expected format.\n        \"\"\"\n        signer = _service_account_info.from_dict(info, require=[\"client_email\"])\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_service_account_file(cls, filename, **kwargs):\n        \"\"\"Creates an OnDemandCredentials instance from a service account .json\n        file in Google format.\n\n        Args:\n            filename (str): The path to the service account .json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: The constructed credentials.\n        \"\"\"\n        info, signer = _service_account_info.from_filename(\n            filename, require=[\"client_email\"]\n        )\n        return cls._from_signer_and_info(signer, info, **kwargs)\n\n    @classmethod\n    def from_signing_credentials(cls, credentials, **kwargs):\n        \"\"\"Creates a new :class:`google.auth.jwt.OnDemandCredentials` instance\n        from an existing :class:`google.auth.credentials.Signing` instance.\n\n        The new instance will use the same signer as the existing instance and\n        will use the existing instance's signer email as the issuer and\n        subject by default.\n\n        Example::\n\n            svc_creds = service_account.Credentials.from_service_account_file(\n                'service_account.json')\n            jwt_creds = jwt.OnDemandCredentials.from_signing_credentials(\n                svc_creds)\n\n        Args:\n            credentials (google.auth.credentials.Signing): The credentials to\n                use to construct the new credentials.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.jwt.Credentials: A new Credentials instance.\n        \"\"\"\n        kwargs.setdefault(\"issuer\", credentials.signer_email)\n        kwargs.setdefault(\"subject\", credentials.signer_email)\n        return cls(credentials.signer, **kwargs)\n\n    def with_claims(self, issuer=None, subject=None, additional_claims=None):\n        \"\"\"Returns a copy of these credentials with modified claims.\n\n        Args:\n            issuer (str): The `iss` claim. If unspecified the current issuer\n                claim will be used.\n            subject (str): The `sub` claim. If unspecified the current subject\n                claim will be used.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT payload. This will be merged with the current\n                additional claims.\n\n        Returns:\n            google.auth.jwt.OnDemandCredentials: A new credentials instance.\n        \"\"\"\n        new_additional_claims = copy.deepcopy(self._additional_claims)\n        new_additional_claims.update(additional_claims or {})\n\n        return self.__class__(\n            self._signer,\n            issuer=issuer if issuer is not None else self._issuer,\n            subject=subject if subject is not None else self._subject,\n            additional_claims=new_additional_claims,\n            max_cache_size=self._cache.maxsize,\n            quota_project_id=self._quota_project_id,\n        )\n\n    @_helpers.copy_docstring(google.auth.credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n\n        return self.__class__(\n            self._signer,\n            issuer=self._issuer,\n            subject=self._subject,\n            additional_claims=self._additional_claims,\n            max_cache_size=self._cache.maxsize,\n            quota_project_id=quota_project_id,\n        )\n\n    @property\n    def valid(self):\n        \"\"\"Checks the validity of the credentials.\n\n        These credentials are always valid because it generates tokens on\n        demand.\n        \"\"\"\n        return True\n\n    def _make_jwt_for_audience(self, audience):\n        \"\"\"Make a new JWT for the given audience.\n\n        Args:\n            audience (str): The intended audience.\n\n        Returns:\n            Tuple[bytes, datetime]: The encoded JWT and the expiration.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=self._token_lifetime)\n        expiry = now + lifetime\n\n        payload = {\n            \"iss\": self._issuer,\n            \"sub\": self._subject,\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            \"aud\": audience,\n        }\n\n        payload.update(self._additional_claims)\n\n        jwt = encode(self._signer, payload)\n\n        return jwt, expiry\n\n    def _get_jwt_for_audience(self, audience):\n        \"\"\"Get a JWT For a given audience.\n\n        If there is already an existing, non-expired token in the cache for\n        the audience, that token is used. Otherwise, a new token will be\n        created.\n\n        Args:\n            audience (str): The intended audience.\n\n        Returns:\n            bytes: The encoded JWT.\n        \"\"\"\n        token, expiry = self._cache.get(audience, (None, None))\n\n        if token is None or expiry < _helpers.utcnow():\n            token, expiry = self._make_jwt_for_audience(audience)\n            self._cache[audience] = token, expiry\n\n        return token\n\n    def refresh(self, request):\n        \"\"\"Raises an exception, these credentials can not be directly\n        refreshed.\n\n        Args:\n            request (Any): Unused.\n\n        Raises:\n            google.auth.RefreshError\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (pylint doesn't correctly recognize overridden methods.)\n        raise exceptions.RefreshError(\n            \"OnDemandCredentials can not be directly refreshed.\"\n        )\n\n    def before_request(self, request, method, url, headers):\n        \"\"\"Performs credential-specific before request logic.\n\n        Args:\n            request (Any): Unused. JWT credentials do not need to make an\n                HTTP request to refresh.\n            method (str): The request's HTTP method.\n            url (str): The request's URI. This is used as the audience claim\n                when generating the JWT.\n            headers (Mapping): The request's headers.\n        \"\"\"\n        # pylint: disable=unused-argument\n        # (pylint doesn't correctly recognize overridden methods.)\n        parts = urllib.parse.urlsplit(url)\n        # Strip query string and fragment\n        audience = urllib.parse.urlunsplit(\n            (parts.scheme, parts.netloc, parts.path, \"\", \"\")\n        )\n        token = self._get_jwt_for_audience(audience)\n        self.apply(headers, token=token)\n\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def sign_bytes(self, message):\n        return self._signer.sign(message)\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer_email(self):\n        return self._issuer\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(google.auth.credentials.Signing)\n    def signer(self):\n        return self._signer\n", "google/auth/_default_async.py": "# Copyright 2020 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Application default credentials.\n\nImplements application default credentials and project ID detection.\n\"\"\"\n\nimport io\nimport json\nimport os\n\nfrom google.auth import _default\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\n\n\ndef load_credentials_from_file(filename, scopes=None, quota_project_id=None):\n    \"\"\"Loads Google credentials from a file.\n\n    The credentials file must be a service account key or stored authorized\n    user credentials.\n\n    Args:\n        filename (str): The full path to the credentials file.\n        scopes (Optional[Sequence[str]]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary\n        quota_project_id (Optional[str]):  The project ID used for\n                quota and billing.\n\n    Returns:\n        Tuple[google.auth.credentials.Credentials, Optional[str]]: Loaded\n            credentials and the project ID. Authorized user credentials do not\n            have the project ID information.\n\n    Raises:\n        google.auth.exceptions.DefaultCredentialsError: if the file is in the\n            wrong format or is missing.\n    \"\"\"\n    if not os.path.exists(filename):\n        raise exceptions.DefaultCredentialsError(\n            \"File {} was not found.\".format(filename)\n        )\n\n    with io.open(filename, \"r\") as file_obj:\n        try:\n            info = json.load(file_obj)\n        except ValueError as caught_exc:\n            new_exc = exceptions.DefaultCredentialsError(\n                \"File {} is not a valid json file.\".format(filename), caught_exc\n            )\n            raise new_exc from caught_exc\n\n    # The type key should indicate that the file is either a service account\n    # credentials file or an authorized user credentials file.\n    credential_type = info.get(\"type\")\n\n    if credential_type == _default._AUTHORIZED_USER_TYPE:\n        from google.oauth2 import _credentials_async as credentials\n\n        try:\n            credentials = credentials.Credentials.from_authorized_user_info(\n                info, scopes=scopes\n            )\n        except ValueError as caught_exc:\n            msg = \"Failed to load authorized user credentials from {}\".format(filename)\n            new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n            raise new_exc from caught_exc\n        if quota_project_id:\n            credentials = credentials.with_quota_project(quota_project_id)\n        if not credentials.quota_project_id:\n            _default._warn_about_problematic_credentials(credentials)\n        return credentials, None\n\n    elif credential_type == _default._SERVICE_ACCOUNT_TYPE:\n        from google.oauth2 import _service_account_async as service_account\n\n        try:\n            credentials = service_account.Credentials.from_service_account_info(\n                info, scopes=scopes\n            ).with_quota_project(quota_project_id)\n        except ValueError as caught_exc:\n            msg = \"Failed to load service account credentials from {}\".format(filename)\n            new_exc = exceptions.DefaultCredentialsError(msg, caught_exc)\n            raise new_exc from caught_exc\n        return credentials, info.get(\"project_id\")\n\n    else:\n        raise exceptions.DefaultCredentialsError(\n            \"The file {file} does not have a valid type. \"\n            \"Type is {type}, expected one of {valid_types}.\".format(\n                file=filename, type=credential_type, valid_types=_default._VALID_TYPES\n            )\n        )\n\n\ndef _get_gcloud_sdk_credentials(quota_project_id=None):\n    \"\"\"Gets the credentials and project ID from the Cloud SDK.\"\"\"\n    from google.auth import _cloud_sdk\n\n    # Check if application default credentials exist.\n    credentials_filename = _cloud_sdk.get_application_default_credentials_path()\n\n    if not os.path.isfile(credentials_filename):\n        return None, None\n\n    credentials, project_id = load_credentials_from_file(\n        credentials_filename, quota_project_id=quota_project_id\n    )\n\n    if not project_id:\n        project_id = _cloud_sdk.get_project_id()\n\n    return credentials, project_id\n\n\ndef _get_explicit_environ_credentials(quota_project_id=None):\n    \"\"\"Gets credentials from the GOOGLE_APPLICATION_CREDENTIALS environment\n    variable.\"\"\"\n    from google.auth import _cloud_sdk\n\n    cloud_sdk_adc_path = _cloud_sdk.get_application_default_credentials_path()\n    explicit_file = os.environ.get(environment_vars.CREDENTIALS)\n\n    if explicit_file is not None and explicit_file == cloud_sdk_adc_path:\n        # Cloud sdk flow calls gcloud to fetch project id, so if the explicit\n        # file path is cloud sdk credentials path, then we should fall back\n        # to cloud sdk flow, otherwise project id cannot be obtained.\n        return _get_gcloud_sdk_credentials(quota_project_id=quota_project_id)\n\n    if explicit_file is not None:\n        credentials, project_id = load_credentials_from_file(\n            os.environ[environment_vars.CREDENTIALS], quota_project_id=quota_project_id\n        )\n\n        return credentials, project_id\n\n    else:\n        return None, None\n\n\ndef _get_gae_credentials():\n    \"\"\"Gets Google App Engine App Identity credentials and project ID.\"\"\"\n    # While this library is normally bundled with app_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n\n    return _default._get_gae_credentials()\n\n\ndef _get_gce_credentials(request=None):\n    \"\"\"Gets credentials and project ID from the GCE Metadata Service.\"\"\"\n    # Ping requires a transport, but we want application default credentials\n    # to require no arguments. So, we'll use the _http_client transport which\n    # uses http.client. This is only acceptable because the metadata server\n    # doesn't do SSL and never requires proxies.\n\n    # While this library is normally bundled with compute_engine, there are\n    # some cases where it's not available, so we tolerate ImportError.\n\n    return _default._get_gce_credentials(request)\n\n\ndef default_async(scopes=None, request=None, quota_project_id=None):\n    \"\"\"Gets the default credentials for the current environment.\n\n    `Application Default Credentials`_ provides an easy way to obtain\n    credentials to call Google APIs for server-to-server or local applications.\n    This function acquires credentials from the environment in the following\n    order:\n\n    1. If the environment variable ``GOOGLE_APPLICATION_CREDENTIALS`` is set\n       to the path of a valid service account JSON private key file, then it is\n       loaded and returned. The project ID returned is the project ID defined\n       in the service account file if available (some older files do not\n       contain project ID information).\n    2. If the `Google Cloud SDK`_ is installed and has application default\n       credentials set they are loaded and returned.\n\n       To enable application default credentials with the Cloud SDK run::\n\n            gcloud auth application-default login\n\n       If the Cloud SDK has an active project, the project ID is returned. The\n       active project can be set using::\n\n            gcloud config set project\n\n    3. If the application is running in the `App Engine standard environment`_\n       (first generation) then the credentials and project ID from the\n       `App Identity Service`_ are used.\n    4. If the application is running in `Compute Engine`_ or `Cloud Run`_ or\n       the `App Engine flexible environment`_ or the `App Engine standard\n       environment`_ (second generation) then the credentials and project ID\n       are obtained from the `Metadata Service`_.\n    5. If no credentials are found,\n       :class:`~google.auth.exceptions.DefaultCredentialsError` will be raised.\n\n    .. _Application Default Credentials: https://developers.google.com\\\n            /identity/protocols/application-default-credentials\n    .. _Google Cloud SDK: https://cloud.google.com/sdk\n    .. _App Engine standard environment: https://cloud.google.com/appengine\n    .. _App Identity Service: https://cloud.google.com/appengine/docs/python\\\n            /appidentity/\n    .. _Compute Engine: https://cloud.google.com/compute\n    .. _App Engine flexible environment: https://cloud.google.com\\\n            /appengine/flexible\n    .. _Metadata Service: https://cloud.google.com/compute/docs\\\n            /storing-retrieving-metadata\n    .. _Cloud Run: https://cloud.google.com/run\n\n    Example::\n\n        import google.auth\n\n        credentials, project_id = google.auth.default()\n\n    Args:\n        scopes (Sequence[str]): The list of scopes for the credentials. If\n            specified, the credentials will automatically be scoped if\n            necessary.\n        request (google.auth.transport.Request): An object used to make\n            HTTP requests. This is used to detect whether the application\n            is running on Compute Engine. If not specified, then it will\n            use the standard library http client to make requests.\n        quota_project_id (Optional[str]):  The project ID used for\n            quota and billing.\n    Returns:\n        Tuple[~google.auth.credentials.Credentials, Optional[str]]:\n            the current environment's credentials and project ID. Project ID\n            may be None, which indicates that the Project ID could not be\n            ascertained from the environment.\n\n    Raises:\n        ~google.auth.exceptions.DefaultCredentialsError:\n            If no credentials were found, or if the credentials found were\n            invalid.\n    \"\"\"\n    from google.auth._credentials_async import with_scopes_if_required\n    from google.auth.credentials import CredentialsWithQuotaProject\n\n    explicit_project_id = os.environ.get(\n        environment_vars.PROJECT, os.environ.get(environment_vars.LEGACY_PROJECT)\n    )\n\n    checkers = (\n        lambda: _get_explicit_environ_credentials(quota_project_id=quota_project_id),\n        lambda: _get_gcloud_sdk_credentials(quota_project_id=quota_project_id),\n        _get_gae_credentials,\n        lambda: _get_gce_credentials(request),\n    )\n\n    for checker in checkers:\n        credentials, project_id = checker()\n        if credentials is not None:\n            credentials = with_scopes_if_required(credentials, scopes)\n            if quota_project_id and isinstance(\n                credentials, CredentialsWithQuotaProject\n            ):\n                credentials = credentials.with_quota_project(quota_project_id)\n            effective_project_id = explicit_project_id or project_id\n            if not effective_project_id:\n                _default._LOGGER.warning(\n                    \"No project ID could be determined. Consider running \"\n                    \"`gcloud config set project` or setting the %s \"\n                    \"environment variable\",\n                    environment_vars.PROJECT,\n                )\n            return credentials, effective_project_id\n\n    raise exceptions.DefaultCredentialsError(_default._CLOUD_SDK_MISSING_CREDENTIALS)\n", "google/auth/external_account.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"External Account Credentials.\n\nThis module provides credentials that exchange workload identity pool external\ncredentials for Google access tokens. This facilitates accessing Google Cloud\nPlatform resources from on-prem and non-Google Cloud platforms (e.g. AWS,\nMicrosoft Azure, OIDC identity providers), using native credentials retrieved\nfrom the current environment without the need to copy, save and manage\nlong-lived service account credentials.\n\nSpecifically, this is intended to use access tokens acquired using the GCP STS\ntoken exchange endpoint following the `OAuth 2.0 Token Exchange`_ spec.\n\n.. _OAuth 2.0 Token Exchange: https://tools.ietf.org/html/rfc8693\n\"\"\"\n\nimport abc\nimport copy\nfrom dataclasses import dataclass\nimport datetime\nimport io\nimport json\nimport re\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import impersonated_credentials\nfrom google.auth import metrics\nfrom google.oauth2 import sts\nfrom google.oauth2 import utils\n\n# External account JSON type identifier.\n_EXTERNAL_ACCOUNT_JSON_TYPE = \"external_account\"\n# The token exchange grant_type used for exchanging credentials.\n_STS_GRANT_TYPE = \"urn:ietf:params:oauth:grant-type:token-exchange\"\n# The token exchange requested_token_type. This is always an access_token.\n_STS_REQUESTED_TOKEN_TYPE = \"urn:ietf:params:oauth:token-type:access_token\"\n# Cloud resource manager URL used to retrieve project information.\n_CLOUD_RESOURCE_MANAGER = \"https://cloudresourcemanager.googleapis.com/v1/projects/\"\n# Default Google sts token url.\n_DEFAULT_TOKEN_URL = \"https://sts.{universe_domain}/v1/token\"\n\n\n@dataclass\nclass SupplierContext:\n    \"\"\"A context class that contains information about the requested third party credential that is passed\n        to AWS security credential and subject token suppliers.\n\n        Attributes:\n            subject_token_type (str): The requested subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:oauth:token-type:jwt\u201d\n                    \u201curn:ietf:params:oauth:token-type:id-token\u201d\n                    \u201curn:ietf:params:oauth:token-type:saml2\u201d\n                    \u201curn:ietf:params:aws:token-type:aws4_request\u201d\n\n            audience (str): The requested audience for the subject token.\n    \"\"\"\n\n    subject_token_type: str\n    audience: str\n\n\nclass Credentials(\n    credentials.Scoped,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithTokenUri,\n    metaclass=abc.ABCMeta,\n):\n    \"\"\"Base class for all external account credentials.\n\n    This is used to instantiate Credentials for exchanging external account\n    credentials for Google access token and authorizing requests to Google APIs.\n    The base class implements the common logic for exchanging external account\n    credentials for Google access tokens.\n    \"\"\"\n\n    def __init__(\n        self,\n        audience,\n        subject_token_type,\n        token_url,\n        credential_source,\n        service_account_impersonation_url=None,\n        service_account_impersonation_options=None,\n        client_id=None,\n        client_secret=None,\n        token_info_url=None,\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        workforce_pool_user_project=None,\n        universe_domain=credentials.DEFAULT_UNIVERSE_DOMAIN,\n        trust_boundary=None,\n    ):\n        \"\"\"Instantiates an external account credentials object.\n\n        Args:\n            audience (str): The STS audience field.\n            subject_token_type (str): The subject token type based on the Oauth2.0 token exchange spec.\n                Expected values include::\n\n                    \u201curn:ietf:params:oauth:token-type:jwt\u201d\n                    \u201curn:ietf:params:oauth:token-type:id-token\u201d\n                    \u201curn:ietf:params:oauth:token-type:saml2\u201d\n                    \u201curn:ietf:params:aws:token-type:aws4_request\u201d\n\n            token_url (str): The STS endpoint URL.\n            credential_source (Mapping): The credential source dictionary.\n            service_account_impersonation_url (Optional[str]): The optional service account\n                impersonation generateAccessToken URL.\n            client_id (Optional[str]): The optional client ID.\n            client_secret (Optional[str]): The optional client secret.\n            token_info_url (str): The optional STS endpoint URL for token introspection.\n            quota_project_id (Optional[str]): The optional quota project ID.\n            scopes (Optional[Sequence[str]]): Optional scopes to request during the\n                authorization grant.\n            default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            workforce_pool_user_project (Optona[str]): The optional workforce pool user\n                project number when the credential corresponds to a workforce pool and not\n                a workload identity pool. The underlying principal must still have\n                serviceusage.services.use IAM permission to use the project for\n                billing/quota.\n            universe_domain (str): The universe domain. The default universe\n                domain is googleapis.com.\n            trust_boundary (str): String representation of trust boundary meta.\n        Raises:\n            google.auth.exceptions.RefreshError: If the generateAccessToken\n                endpoint returned an error.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self._audience = audience\n        self._subject_token_type = subject_token_type\n        self._universe_domain = universe_domain\n        self._token_url = token_url\n        if self._token_url == _DEFAULT_TOKEN_URL:\n            self._token_url = self._token_url.replace(\n                \"{universe_domain}\", self._universe_domain\n            )\n        self._token_info_url = token_info_url\n        self._credential_source = credential_source\n        self._service_account_impersonation_url = service_account_impersonation_url\n        self._service_account_impersonation_options = (\n            service_account_impersonation_options or {}\n        )\n        self._client_id = client_id\n        self._client_secret = client_secret\n        self._quota_project_id = quota_project_id\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._workforce_pool_user_project = workforce_pool_user_project\n        self._trust_boundary = {\n            \"locations\": [],\n            \"encoded_locations\": \"0x0\",\n        }  # expose a placeholder trust boundary value.\n\n        if self._client_id:\n            self._client_auth = utils.ClientAuthentication(\n                utils.ClientAuthType.basic, self._client_id, self._client_secret\n            )\n        else:\n            self._client_auth = None\n        self._sts_client = sts.Client(self._token_url, self._client_auth)\n\n        self._metrics_options = self._create_default_metrics_options()\n\n        self._impersonated_credentials = None\n        self._project_id = None\n        self._supplier_context = SupplierContext(\n            self._subject_token_type, self._audience\n        )\n\n        if not self.is_workforce_pool and self._workforce_pool_user_project:\n            # Workload identity pools do not support workforce pool user projects.\n            raise exceptions.InvalidValue(\n                \"workforce_pool_user_project should not be set for non-workforce pool \"\n                \"credentials\"\n            )\n\n    @property\n    def info(self):\n        \"\"\"Generates the dictionary representation of the current credentials.\n\n        Returns:\n            Mapping: The dictionary representation of the credentials. This is the\n                reverse of \"from_info\" defined on the subclasses of this class. It is\n                useful for serializing the current credentials so it can deserialized\n                later.\n        \"\"\"\n        config_info = self._constructor_args()\n        config_info.update(\n            type=_EXTERNAL_ACCOUNT_JSON_TYPE,\n            service_account_impersonation=config_info.pop(\n                \"service_account_impersonation_options\", None\n            ),\n        )\n        config_info.pop(\"scopes\", None)\n        config_info.pop(\"default_scopes\", None)\n        return {key: value for key, value in config_info.items() if value is not None}\n\n    def _constructor_args(self):\n        args = {\n            \"audience\": self._audience,\n            \"subject_token_type\": self._subject_token_type,\n            \"token_url\": self._token_url,\n            \"token_info_url\": self._token_info_url,\n            \"service_account_impersonation_url\": self._service_account_impersonation_url,\n            \"service_account_impersonation_options\": copy.deepcopy(\n                self._service_account_impersonation_options\n            )\n            or None,\n            \"credential_source\": copy.deepcopy(self._credential_source),\n            \"quota_project_id\": self._quota_project_id,\n            \"client_id\": self._client_id,\n            \"client_secret\": self._client_secret,\n            \"workforce_pool_user_project\": self._workforce_pool_user_project,\n            \"scopes\": self._scopes,\n            \"default_scopes\": self._default_scopes,\n            \"universe_domain\": self._universe_domain,\n        }\n        if not self.is_workforce_pool:\n            args.pop(\"workforce_pool_user_project\")\n        return args\n\n    @property\n    def service_account_email(self):\n        \"\"\"Returns the service account email if service account impersonation is used.\n\n        Returns:\n            Optional[str]: The service account email if impersonation is used. Otherwise\n                None is returned.\n        \"\"\"\n        if self._service_account_impersonation_url:\n            # Parse email from URL. The formal looks as follows:\n            # https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/name@project-id.iam.gserviceaccount.com:generateAccessToken\n            url = self._service_account_impersonation_url\n            start_index = url.rfind(\"/\")\n            end_index = url.find(\":generateAccessToken\")\n            if start_index != -1 and end_index != -1 and start_index < end_index:\n                start_index = start_index + 1\n                return url[start_index:end_index]\n        return None\n\n    @property\n    def is_user(self):\n        \"\"\"Returns whether the credentials represent a user (True) or workload (False).\n        Workloads behave similarly to service accounts. Currently workloads will use\n        service account impersonation but will eventually not require impersonation.\n        As a result, this property is more reliable than the service account email\n        property in determining if the credentials represent a user or workload.\n\n        Returns:\n            bool: True if the credentials represent a user. False if they represent a\n                workload.\n        \"\"\"\n        # If service account impersonation is used, the credentials will always represent a\n        # service account.\n        if self._service_account_impersonation_url:\n            return False\n        return self.is_workforce_pool\n\n    @property\n    def is_workforce_pool(self):\n        \"\"\"Returns whether the credentials represent a workforce pool (True) or\n        workload (False) based on the credentials' audience.\n\n        This will also return True for impersonated workforce pool credentials.\n\n        Returns:\n            bool: True if the credentials represent a workforce pool. False if they\n                represent a workload.\n        \"\"\"\n        # Workforce pools representing users have the following audience format:\n        # //iam.googleapis.com/locations/$location/workforcePools/$poolId/providers/$providerId\n        p = re.compile(r\"//iam\\.googleapis\\.com/locations/[^/]+/workforcePools/\")\n        return p.match(self._audience or \"\") is not None\n\n    @property\n    def requires_scopes(self):\n        \"\"\"Checks if the credentials requires scopes.\n\n        Returns:\n            bool: True if there are no scopes set otherwise False.\n        \"\"\"\n        return not self._scopes and not self._default_scopes\n\n    @property\n    def project_number(self):\n        \"\"\"Optional[str]: The project number corresponding to the workload identity pool.\"\"\"\n\n        # STS audience pattern:\n        # //iam.googleapis.com/projects/$PROJECT_NUMBER/locations/...\n        components = self._audience.split(\"/\")\n        try:\n            project_index = components.index(\"projects\")\n            if project_index + 1 < len(components):\n                return components[project_index + 1] or None\n        except ValueError:\n            return None\n\n    @property\n    def token_info_url(self):\n        \"\"\"Optional[str]: The STS token introspection endpoint.\"\"\"\n\n        return self._token_info_url\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        kwargs = self._constructor_args()\n        kwargs.update(scopes=scopes, default_scopes=default_scopes)\n        scoped = self.__class__(**kwargs)\n        scoped._metrics_options = self._metrics_options\n        return scoped\n\n    @abc.abstractmethod\n    def retrieve_subject_token(self, request):\n        \"\"\"Retrieves the subject token using the credential_source object.\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Returns:\n            str: The retrieved subject token.\n        \"\"\"\n        # pylint: disable=missing-raises-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"retrieve_subject_token must be implemented\")\n\n    def get_project_id(self, request):\n        \"\"\"Retrieves the project ID corresponding to the workload identity or workforce pool.\n        For workforce pool credentials, it returns the project ID corresponding to\n        the workforce_pool_user_project.\n\n        When not determinable, None is returned.\n\n        This is introduced to support the current pattern of using the Auth library:\n\n            credentials, project_id = google.auth.default()\n\n        The resource may not have permission (resourcemanager.projects.get) to\n        call this API or the required scopes may not be selected:\n        https://cloud.google.com/resource-manager/reference/rest/v1/projects/get#authorization-scopes\n\n        Args:\n            request (google.auth.transport.Request): A callable used to make\n                HTTP requests.\n        Returns:\n            Optional[str]: The project ID corresponding to the workload identity pool\n                or workforce pool if determinable.\n        \"\"\"\n        if self._project_id:\n            # If already retrieved, return the cached project ID value.\n            return self._project_id\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # Scopes are required in order to retrieve a valid access token.\n        project_number = self.project_number or self._workforce_pool_user_project\n        if project_number and scopes:\n            headers = {}\n            url = _CLOUD_RESOURCE_MANAGER + project_number\n            self.before_request(request, \"GET\", url, headers)\n            response = request(url=url, method=\"GET\", headers=headers)\n\n            response_body = (\n                response.data.decode(\"utf-8\")\n                if hasattr(response.data, \"decode\")\n                else response.data\n            )\n            response_data = json.loads(response_body)\n\n            if response.status == 200:\n                # Cache result as this field is immutable.\n                self._project_id = response_data.get(\"projectId\")\n                return self._project_id\n\n        return None\n\n    @_helpers.copy_docstring(credentials.Credentials)\n    def refresh(self, request):\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n\n        if self._should_initialize_impersonated_credentials():\n            self._impersonated_credentials = self._initialize_impersonated_credentials()\n\n        if self._impersonated_credentials:\n            self._impersonated_credentials.refresh(request)\n            self.token = self._impersonated_credentials.token\n            self.expiry = self._impersonated_credentials.expiry\n        else:\n            now = _helpers.utcnow()\n            additional_options = None\n            # Do not pass workforce_pool_user_project when client authentication\n            # is used. The client ID is sufficient for determining the user project.\n            if self._workforce_pool_user_project and not self._client_id:\n                additional_options = {\"userProject\": self._workforce_pool_user_project}\n            additional_headers = {\n                metrics.API_CLIENT_HEADER: metrics.byoid_metrics_header(\n                    self._metrics_options\n                )\n            }\n            response_data = self._sts_client.exchange_token(\n                request=request,\n                grant_type=_STS_GRANT_TYPE,\n                subject_token=self.retrieve_subject_token(request),\n                subject_token_type=self._subject_token_type,\n                audience=self._audience,\n                scopes=scopes,\n                requested_token_type=_STS_REQUESTED_TOKEN_TYPE,\n                additional_options=additional_options,\n                additional_headers=additional_headers,\n            )\n            self.token = response_data.get(\"access_token\")\n            expires_in = response_data.get(\"expires_in\")\n            # Some services do not respect the OAUTH2.0 RFC and send expires_in as a\n            # JSON String.\n            if isinstance(expires_in, str):\n                expires_in = int(expires_in)\n\n            lifetime = datetime.timedelta(seconds=expires_in)\n\n            self.expiry = now + lifetime\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        # Return copy of instance with the provided quota project ID.\n        kwargs = self._constructor_args()\n        kwargs.update(quota_project_id=quota_project_id)\n        new_cred = self.__class__(**kwargs)\n        new_cred._metrics_options = self._metrics_options\n        return new_cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n        kwargs = self._constructor_args()\n        kwargs.update(token_url=token_uri)\n        new_cred = self.__class__(**kwargs)\n        new_cred._metrics_options = self._metrics_options\n        return new_cred\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        kwargs = self._constructor_args()\n        kwargs.update(universe_domain=universe_domain)\n        new_cred = self.__class__(**kwargs)\n        new_cred._metrics_options = self._metrics_options\n        return new_cred\n\n    def _should_initialize_impersonated_credentials(self):\n        return (\n            self._service_account_impersonation_url is not None\n            and self._impersonated_credentials is None\n        )\n\n    def _initialize_impersonated_credentials(self):\n        \"\"\"Generates an impersonated credentials.\n\n        For more details, see `projects.serviceAccounts.generateAccessToken`_.\n\n        .. _projects.serviceAccounts.generateAccessToken: https://cloud.google.com/iam/docs/reference/credentials/rest/v1/projects.serviceAccounts/generateAccessToken\n\n        Returns:\n            impersonated_credentials.Credential: The impersonated credentials\n                object.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the generateAccessToken\n                endpoint returned an error.\n        \"\"\"\n        # Return copy of instance with no service account impersonation.\n        kwargs = self._constructor_args()\n        kwargs.update(\n            service_account_impersonation_url=None,\n            service_account_impersonation_options={},\n        )\n        source_credentials = self.__class__(**kwargs)\n        source_credentials._metrics_options = self._metrics_options\n\n        # Determine target_principal.\n        target_principal = self.service_account_email\n        if not target_principal:\n            raise exceptions.RefreshError(\n                \"Unable to determine target principal from service account impersonation URL.\"\n            )\n\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        # Initialize and return impersonated credentials.\n        return impersonated_credentials.Credentials(\n            source_credentials=source_credentials,\n            target_principal=target_principal,\n            target_scopes=scopes,\n            quota_project_id=self._quota_project_id,\n            iam_endpoint_override=self._service_account_impersonation_url,\n            lifetime=self._service_account_impersonation_options.get(\n                \"token_lifetime_seconds\"\n            ),\n        )\n\n    def _create_default_metrics_options(self):\n        metrics_options = {}\n        if self._service_account_impersonation_url:\n            metrics_options[\"sa-impersonation\"] = \"true\"\n        else:\n            metrics_options[\"sa-impersonation\"] = \"false\"\n        if self._service_account_impersonation_options.get(\"token_lifetime_seconds\"):\n            metrics_options[\"config-lifetime\"] = \"true\"\n        else:\n            metrics_options[\"config-lifetime\"] = \"false\"\n\n        return metrics_options\n\n    @classmethod\n    def from_info(cls, info, **kwargs):\n        \"\"\"Creates a Credentials instance from parsed external account info.\n\n        Args:\n            info (Mapping[str, str]): The external account info in Google\n                format.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n\n        Raises:\n            InvalidValue: For invalid parameters.\n        \"\"\"\n        return cls(\n            audience=info.get(\"audience\"),\n            subject_token_type=info.get(\"subject_token_type\"),\n            token_url=info.get(\"token_url\"),\n            token_info_url=info.get(\"token_info_url\"),\n            service_account_impersonation_url=info.get(\n                \"service_account_impersonation_url\"\n            ),\n            service_account_impersonation_options=info.get(\n                \"service_account_impersonation\"\n            )\n            or {},\n            client_id=info.get(\"client_id\"),\n            client_secret=info.get(\"client_secret\"),\n            credential_source=info.get(\"credential_source\"),\n            quota_project_id=info.get(\"quota_project_id\"),\n            workforce_pool_user_project=info.get(\"workforce_pool_user_project\"),\n            universe_domain=info.get(\n                \"universe_domain\", credentials.DEFAULT_UNIVERSE_DOMAIN\n            ),\n            **kwargs\n        )\n\n    @classmethod\n    def from_file(cls, filename, **kwargs):\n        \"\"\"Creates a Credentials instance from an external account json file.\n\n        Args:\n            filename (str): The path to the external account json file.\n            kwargs: Additional arguments to pass to the constructor.\n\n        Returns:\n            google.auth.identity_pool.Credentials: The constructed\n                credentials.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n            return cls.from_info(data, **kwargs)\n", "google/auth/compute_engine/credentials.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Compute Engine credentials.\n\nThis module provides authentication for an application running on Google\nCompute Engine using the Compute Engine metadata server.\n\n\"\"\"\n\nimport datetime\n\nfrom google.auth import _helpers\nfrom google.auth import credentials\nfrom google.auth import exceptions\nfrom google.auth import iam\nfrom google.auth import jwt\nfrom google.auth import metrics\nfrom google.auth.compute_engine import _metadata\nfrom google.oauth2 import _client\n\n\nclass Credentials(\n    credentials.Scoped,\n    credentials.CredentialsWithQuotaProject,\n    credentials.CredentialsWithUniverseDomain,\n):\n    \"\"\"Compute Engine Credentials.\n\n    These credentials use the Google Compute Engine metadata server to obtain\n    OAuth 2.0 access tokens associated with the instance's service account,\n    and are also used for Cloud Run, Flex and App Engine (except for the Python\n    2.7 runtime, which is supported only on older versions of this library).\n\n    For more information about Compute Engine authentication, including how\n    to configure scopes, see the `Compute Engine authentication\n    documentation`_.\n\n    .. note:: On Compute Engine the metadata server ignores requested scopes.\n        On Cloud Run, Flex and App Engine the server honours requested scopes.\n\n    .. _Compute Engine authentication documentation:\n        https://cloud.google.com/compute/docs/authentication#using\n    \"\"\"\n\n    def __init__(\n        self,\n        service_account_email=\"default\",\n        quota_project_id=None,\n        scopes=None,\n        default_scopes=None,\n        universe_domain=None,\n    ):\n        \"\"\"\n        Args:\n            service_account_email (str): The service account email to use, or\n                'default'. A Compute Engine instance may have multiple service\n                accounts.\n            quota_project_id (Optional[str]): The project ID used for quota and\n                billing.\n            scopes (Optional[Sequence[str]]): The list of scopes for the credentials.\n            default_scopes (Optional[Sequence[str]]): Default scopes passed by a\n                Google client library. Use 'scopes' for user-defined scopes.\n            universe_domain (Optional[str]): The universe domain. If not\n                provided or None, credential will attempt to fetch the value\n                from metadata server. If metadata server doesn't have universe\n                domain endpoint, then the default googleapis.com will be used.\n        \"\"\"\n        super(Credentials, self).__init__()\n        self._service_account_email = service_account_email\n        self._quota_project_id = quota_project_id\n        self._scopes = scopes\n        self._default_scopes = default_scopes\n        self._universe_domain_cached = False\n        if universe_domain:\n            self._universe_domain = universe_domain\n            self._universe_domain_cached = True\n\n    def _retrieve_info(self, request):\n        \"\"\"Retrieve information about the service account.\n\n        Updates the scopes and retrieves the full service account email.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n        \"\"\"\n        info = _metadata.get_service_account_info(\n            request, service_account=self._service_account_email\n        )\n\n        self._service_account_email = info[\"email\"]\n\n        # Don't override scopes requested by the user.\n        if self._scopes is None:\n            self._scopes = info[\"scopes\"]\n\n    def _metric_header_for_usage(self):\n        return metrics.CRED_TYPE_SA_MDS\n\n    def refresh(self, request):\n        \"\"\"Refresh the access token and scopes.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the Compute Engine metadata\n                service can't be reached if if the instance has not\n                credentials.\n        \"\"\"\n        scopes = self._scopes if self._scopes is not None else self._default_scopes\n        try:\n            self._retrieve_info(request)\n            self.token, self.expiry = _metadata.get_service_account_token(\n                request, service_account=self._service_account_email, scopes=scopes\n            )\n        except exceptions.TransportError as caught_exc:\n            new_exc = exceptions.RefreshError(caught_exc)\n            raise new_exc from caught_exc\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\n\n        .. note:: This is not guaranteed to be set until :meth:`refresh` has been\n            called.\n        \"\"\"\n        return self._service_account_email\n\n    @property\n    def requires_scopes(self):\n        return not self._scopes\n\n    @property\n    def universe_domain(self):\n        if self._universe_domain_cached:\n            return self._universe_domain\n\n        from google.auth.transport import requests as google_auth_requests\n\n        self._universe_domain = _metadata.get_universe_domain(\n            google_auth_requests.Request()\n        )\n        self._universe_domain_cached = True\n        return self._universe_domain\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n        creds = self.__class__(\n            service_account_email=self._service_account_email,\n            quota_project_id=quota_project_id,\n            scopes=self._scopes,\n            default_scopes=self._default_scopes,\n        )\n        creds._universe_domain = self._universe_domain\n        creds._universe_domain_cached = self._universe_domain_cached\n        return creds\n\n    @_helpers.copy_docstring(credentials.Scoped)\n    def with_scopes(self, scopes, default_scopes=None):\n        # Compute Engine credentials can not be scoped (the metadata service\n        # ignores the scopes parameter). App Engine, Cloud Run and Flex support\n        # requesting scopes.\n        creds = self.__class__(\n            scopes=scopes,\n            default_scopes=default_scopes,\n            service_account_email=self._service_account_email,\n            quota_project_id=self._quota_project_id,\n        )\n        creds._universe_domain = self._universe_domain\n        creds._universe_domain_cached = self._universe_domain_cached\n        return creds\n\n    @_helpers.copy_docstring(credentials.CredentialsWithUniverseDomain)\n    def with_universe_domain(self, universe_domain):\n        return self.__class__(\n            scopes=self._scopes,\n            default_scopes=self._default_scopes,\n            service_account_email=self._service_account_email,\n            quota_project_id=self._quota_project_id,\n            universe_domain=universe_domain,\n        )\n\n\n_DEFAULT_TOKEN_LIFETIME_SECS = 3600  # 1 hour in seconds\n_DEFAULT_TOKEN_URI = \"https://www.googleapis.com/oauth2/v4/token\"\n\n\nclass IDTokenCredentials(\n    credentials.CredentialsWithQuotaProject,\n    credentials.Signing,\n    credentials.CredentialsWithTokenUri,\n):\n    \"\"\"Open ID Connect ID Token-based service account credentials.\n\n    These credentials relies on the default service account of a GCE instance.\n\n    ID token can be requested from `GCE metadata server identity endpoint`_, IAM\n    token endpoint or other token endpoints you specify. If metadata server\n    identity endpoint is not used, the GCE instance must have been started with\n    a service account that has access to the IAM Cloud API.\n\n    .. _GCE metadata server identity endpoint:\n        https://cloud.google.com/compute/docs/instances/verifying-instance-identity\n    \"\"\"\n\n    def __init__(\n        self,\n        request,\n        target_audience,\n        token_uri=None,\n        additional_claims=None,\n        service_account_email=None,\n        signer=None,\n        use_metadata_identity_endpoint=False,\n        quota_project_id=None,\n    ):\n        \"\"\"\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n            target_audience (str): The intended audience for these credentials,\n                used when requesting the ID Token. The ID Token's ``aud`` claim\n                will be set to this string.\n            token_uri (str): The OAuth 2.0 Token URI.\n            additional_claims (Mapping[str, str]): Any additional claims for\n                the JWT assertion used in the authorization grant.\n            service_account_email (str): Optional explicit service account to\n                use to sign JWT tokens.\n                By default, this is the default GCE service account.\n            signer (google.auth.crypt.Signer): The signer used to sign JWTs.\n                In case the signer is specified, the request argument will be\n                ignored.\n            use_metadata_identity_endpoint (bool): Whether to use GCE metadata\n                identity endpoint. For backward compatibility the default value\n                is False. If set to True, ``token_uri``, ``additional_claims``,\n                ``service_account_email``, ``signer`` argument should not be set;\n                otherwise ValueError will be raised.\n            quota_project_id (Optional[str]): The project ID used for quota and\n                billing.\n\n        Raises:\n            ValueError:\n                If ``use_metadata_identity_endpoint`` is set to True, and one of\n                ``token_uri``, ``additional_claims``, ``service_account_email``,\n                 ``signer`` arguments is set.\n        \"\"\"\n        super(IDTokenCredentials, self).__init__()\n\n        self._quota_project_id = quota_project_id\n        self._use_metadata_identity_endpoint = use_metadata_identity_endpoint\n        self._target_audience = target_audience\n\n        if use_metadata_identity_endpoint:\n            if token_uri or additional_claims or service_account_email or signer:\n                raise exceptions.MalformedError(\n                    \"If use_metadata_identity_endpoint is set, token_uri, \"\n                    \"additional_claims, service_account_email, signer arguments\"\n                    \" must not be set\"\n                )\n            self._token_uri = None\n            self._additional_claims = None\n            self._signer = None\n\n        if service_account_email is None:\n            sa_info = _metadata.get_service_account_info(request)\n            self._service_account_email = sa_info[\"email\"]\n        else:\n            self._service_account_email = service_account_email\n\n        if not use_metadata_identity_endpoint:\n            if signer is None:\n                signer = iam.Signer(\n                    request=request,\n                    credentials=Credentials(),\n                    service_account_email=self._service_account_email,\n                )\n            self._signer = signer\n            self._token_uri = token_uri or _DEFAULT_TOKEN_URI\n\n            if additional_claims is not None:\n                self._additional_claims = additional_claims\n            else:\n                self._additional_claims = {}\n\n    def with_target_audience(self, target_audience):\n        \"\"\"Create a copy of these credentials with the specified target\n        audience.\n        Args:\n            target_audience (str): The intended audience for these credentials,\n            used when requesting the ID Token.\n        Returns:\n            google.auth.service_account.IDTokenCredentials: A new credentials\n                instance.\n        \"\"\"\n        # since the signer is already instantiated,\n        # the request is not needed\n        if self._use_metadata_identity_endpoint:\n            return self.__class__(\n                None,\n                target_audience=target_audience,\n                use_metadata_identity_endpoint=True,\n                quota_project_id=self._quota_project_id,\n            )\n        else:\n            return self.__class__(\n                None,\n                service_account_email=self._service_account_email,\n                token_uri=self._token_uri,\n                target_audience=target_audience,\n                additional_claims=self._additional_claims.copy(),\n                signer=self.signer,\n                use_metadata_identity_endpoint=False,\n                quota_project_id=self._quota_project_id,\n            )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithQuotaProject)\n    def with_quota_project(self, quota_project_id):\n\n        # since the signer is already instantiated,\n        # the request is not needed\n        if self._use_metadata_identity_endpoint:\n            return self.__class__(\n                None,\n                target_audience=self._target_audience,\n                use_metadata_identity_endpoint=True,\n                quota_project_id=quota_project_id,\n            )\n        else:\n            return self.__class__(\n                None,\n                service_account_email=self._service_account_email,\n                token_uri=self._token_uri,\n                target_audience=self._target_audience,\n                additional_claims=self._additional_claims.copy(),\n                signer=self.signer,\n                use_metadata_identity_endpoint=False,\n                quota_project_id=quota_project_id,\n            )\n\n    @_helpers.copy_docstring(credentials.CredentialsWithTokenUri)\n    def with_token_uri(self, token_uri):\n\n        # since the signer is already instantiated,\n        # the request is not needed\n        if self._use_metadata_identity_endpoint:\n            raise exceptions.MalformedError(\n                \"If use_metadata_identity_endpoint is set, token_uri\" \" must not be set\"\n            )\n        else:\n            return self.__class__(\n                None,\n                service_account_email=self._service_account_email,\n                token_uri=token_uri,\n                target_audience=self._target_audience,\n                additional_claims=self._additional_claims.copy(),\n                signer=self.signer,\n                use_metadata_identity_endpoint=False,\n                quota_project_id=self.quota_project_id,\n            )\n\n    def _make_authorization_grant_assertion(self):\n        \"\"\"Create the OAuth 2.0 assertion.\n        This assertion is used during the OAuth 2.0 grant to acquire an\n        ID token.\n        Returns:\n            bytes: The authorization grant assertion.\n        \"\"\"\n        now = _helpers.utcnow()\n        lifetime = datetime.timedelta(seconds=_DEFAULT_TOKEN_LIFETIME_SECS)\n        expiry = now + lifetime\n\n        payload = {\n            \"iat\": _helpers.datetime_to_secs(now),\n            \"exp\": _helpers.datetime_to_secs(expiry),\n            # The issuer must be the service account email.\n            \"iss\": self.service_account_email,\n            # The audience must be the auth token endpoint's URI\n            \"aud\": self._token_uri,\n            # The target audience specifies which service the ID token is\n            # intended for.\n            \"target_audience\": self._target_audience,\n        }\n\n        payload.update(self._additional_claims)\n\n        token = jwt.encode(self._signer, payload)\n\n        return token\n\n    def _call_metadata_identity_endpoint(self, request):\n        \"\"\"Request ID token from metadata identity endpoint.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Returns:\n            Tuple[str, datetime.datetime]: The ID token and the expiry of the ID token.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the Compute Engine metadata\n                service can't be reached or if the instance has no credentials.\n            ValueError: If extracting expiry from the obtained ID token fails.\n        \"\"\"\n        try:\n            path = \"instance/service-accounts/default/identity\"\n            params = {\"audience\": self._target_audience, \"format\": \"full\"}\n            metrics_header = {\n                metrics.API_CLIENT_HEADER: metrics.token_request_id_token_mds()\n            }\n            id_token = _metadata.get(\n                request, path, params=params, headers=metrics_header\n            )\n        except exceptions.TransportError as caught_exc:\n            new_exc = exceptions.RefreshError(caught_exc)\n            raise new_exc from caught_exc\n\n        _, payload, _, _ = jwt._unverified_decode(id_token)\n        return id_token, datetime.datetime.utcfromtimestamp(payload[\"exp\"])\n\n    def refresh(self, request):\n        \"\"\"Refreshes the ID token.\n\n        Args:\n            request (google.auth.transport.Request): The object used to make\n                HTTP requests.\n\n        Raises:\n            google.auth.exceptions.RefreshError: If the credentials could\n                not be refreshed.\n            ValueError: If extracting expiry from the obtained ID token fails.\n        \"\"\"\n        if self._use_metadata_identity_endpoint:\n            self.token, self.expiry = self._call_metadata_identity_endpoint(request)\n        else:\n            assertion = self._make_authorization_grant_assertion()\n            access_token, expiry, _ = _client.id_token_jwt_grant(\n                request, self._token_uri, assertion\n            )\n            self.token = access_token\n            self.expiry = expiry\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(credentials.Signing)\n    def signer(self):\n        return self._signer\n\n    def sign_bytes(self, message):\n        \"\"\"Signs the given message.\n\n        Args:\n            message (bytes): The message to sign.\n\n        Returns:\n            bytes: The message's cryptographic signature.\n\n        Raises:\n            ValueError:\n                Signer is not available if metadata identity endpoint is used.\n        \"\"\"\n        if self._use_metadata_identity_endpoint:\n            raise exceptions.InvalidOperation(\n                \"Signer is not available if metadata identity endpoint is used\"\n            )\n        return self._signer.sign(message)\n\n    @property\n    def service_account_email(self):\n        \"\"\"The service account email.\"\"\"\n        return self._service_account_email\n\n    @property\n    def signer_email(self):\n        return self._service_account_email\n", "google/auth/compute_engine/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Google Compute Engine authentication.\"\"\"\n\nfrom google.auth.compute_engine._metadata import detect_gce_residency_linux\nfrom google.auth.compute_engine.credentials import Credentials\nfrom google.auth.compute_engine.credentials import IDTokenCredentials\n\n\n__all__ = [\"Credentials\", \"IDTokenCredentials\", \"detect_gce_residency_linux\"]\n", "google/auth/crypt/_python_rsa.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Pure-Python RSA cryptography implementation.\n\nUses the ``rsa``, ``pyasn1`` and ``pyasn1_modules`` packages\nto parse PEM files storing PKCS#1 or PKCS#8 keys as well as\ncertificates. There is no support for p12 files.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport io\n\nfrom pyasn1.codec.der import decoder  # type: ignore\nfrom pyasn1_modules import pem  # type: ignore\nfrom pyasn1_modules.rfc2459 import Certificate  # type: ignore\nfrom pyasn1_modules.rfc5208 import PrivateKeyInfo  # type: ignore\nimport rsa  # type: ignore\n\nfrom google.auth import _helpers\nfrom google.auth import exceptions\nfrom google.auth.crypt import base\n\n_POW2 = (128, 64, 32, 16, 8, 4, 2, 1)\n_CERTIFICATE_MARKER = b\"-----BEGIN CERTIFICATE-----\"\n_PKCS1_MARKER = (\"-----BEGIN RSA PRIVATE KEY-----\", \"-----END RSA PRIVATE KEY-----\")\n_PKCS8_MARKER = (\"-----BEGIN PRIVATE KEY-----\", \"-----END PRIVATE KEY-----\")\n_PKCS8_SPEC = PrivateKeyInfo()\n\n\ndef _bit_list_to_bytes(bit_list):\n    \"\"\"Converts an iterable of 1s and 0s to bytes.\n\n    Combines the list 8 at a time, treating each group of 8 bits\n    as a single byte.\n\n    Args:\n        bit_list (Sequence): Sequence of 1s and 0s.\n\n    Returns:\n        bytes: The decoded bytes.\n    \"\"\"\n    num_bits = len(bit_list)\n    byte_vals = bytearray()\n    for start in range(0, num_bits, 8):\n        curr_bits = bit_list[start : start + 8]\n        char_val = sum(val * digit for val, digit in zip(_POW2, curr_bits))\n        byte_vals.append(char_val)\n    return bytes(byte_vals)\n\n\nclass RSAVerifier(base.Verifier):\n    \"\"\"Verifies RSA cryptographic signatures using public keys.\n\n    Args:\n        public_key (rsa.key.PublicKey): The public key used to verify\n            signatures.\n    \"\"\"\n\n    def __init__(self, public_key):\n        self._pubkey = public_key\n\n    @_helpers.copy_docstring(base.Verifier)\n    def verify(self, message, signature):\n        message = _helpers.to_bytes(message)\n        try:\n            return rsa.pkcs1.verify(message, signature, self._pubkey)\n        except (ValueError, rsa.pkcs1.VerificationError):\n            return False\n\n    @classmethod\n    def from_string(cls, public_key):\n        \"\"\"Construct an Verifier instance from a public key or public\n        certificate string.\n\n        Args:\n            public_key (Union[str, bytes]): The public key in PEM format or the\n                x509 public key certificate.\n\n        Returns:\n            google.auth.crypt._python_rsa.RSAVerifier: The constructed verifier.\n\n        Raises:\n            ValueError: If the public_key can't be parsed.\n        \"\"\"\n        public_key = _helpers.to_bytes(public_key)\n        is_x509_cert = _CERTIFICATE_MARKER in public_key\n\n        # If this is a certificate, extract the public key info.\n        if is_x509_cert:\n            der = rsa.pem.load_pem(public_key, \"CERTIFICATE\")\n            asn1_cert, remaining = decoder.decode(der, asn1Spec=Certificate())\n            if remaining != b\"\":\n                raise exceptions.InvalidValue(\"Unused bytes\", remaining)\n\n            cert_info = asn1_cert[\"tbsCertificate\"][\"subjectPublicKeyInfo\"]\n            key_bytes = _bit_list_to_bytes(cert_info[\"subjectPublicKey\"])\n            pubkey = rsa.PublicKey.load_pkcs1(key_bytes, \"DER\")\n        else:\n            pubkey = rsa.PublicKey.load_pkcs1(public_key, \"PEM\")\n        return cls(pubkey)\n\n\nclass RSASigner(base.Signer, base.FromServiceAccountMixin):\n    \"\"\"Signs messages with an RSA private key.\n\n    Args:\n        private_key (rsa.key.PrivateKey): The private key to sign with.\n        key_id (str): Optional key ID used to identify this private key. This\n            can be useful to associate the private key with its associated\n            public key or certificate.\n    \"\"\"\n\n    def __init__(self, private_key, key_id=None):\n        self._key = private_key\n        self._key_id = key_id\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(base.Signer)\n    def key_id(self):\n        return self._key_id\n\n    @_helpers.copy_docstring(base.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        return rsa.pkcs1.sign(message, self._key, \"SHA-256\")\n\n    @classmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct an Signer instance from a private key in PEM format.\n\n        Args:\n            key (str): Private key in PEM format.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n\n        Raises:\n            ValueError: If the key cannot be parsed as PKCS#1 or PKCS#8 in\n                PEM format.\n        \"\"\"\n        key = _helpers.from_bytes(key)  # PEM expects str in Python 3\n        marker_id, key_bytes = pem.readPemBlocksFromFile(\n            io.StringIO(key), _PKCS1_MARKER, _PKCS8_MARKER\n        )\n\n        # Key is in pkcs1 format.\n        if marker_id == 0:\n            private_key = rsa.key.PrivateKey.load_pkcs1(key_bytes, format=\"DER\")\n        # Key is in pkcs8.\n        elif marker_id == 1:\n            key_info, remaining = decoder.decode(key_bytes, asn1Spec=_PKCS8_SPEC)\n            if remaining != b\"\":\n                raise exceptions.InvalidValue(\"Unused bytes\", remaining)\n            private_key_info = key_info.getComponentByName(\"privateKey\")\n            private_key = rsa.key.PrivateKey.load_pkcs1(\n                private_key_info.asOctets(), format=\"DER\"\n            )\n        else:\n            raise exceptions.MalformedError(\"No key could be detected.\")\n\n        return cls(private_key, key_id=key_id)\n", "google/auth/crypt/base.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Base classes for cryptographic signers and verifiers.\"\"\"\n\nimport abc\nimport io\nimport json\n\nfrom google.auth import exceptions\n\n_JSON_FILE_PRIVATE_KEY = \"private_key\"\n_JSON_FILE_PRIVATE_KEY_ID = \"private_key_id\"\n\n\nclass Verifier(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for crytographic signature verifiers.\"\"\"\n\n    @abc.abstractmethod\n    def verify(self, message, signature):\n        \"\"\"Verifies a message against a cryptographic signature.\n\n        Args:\n            message (Union[str, bytes]): The message to verify.\n            signature (Union[str, bytes]): The cryptography signature to check.\n\n        Returns:\n            bool: True if message was signed by the private key associated\n            with the public key that this object was constructed with.\n        \"\"\"\n        # pylint: disable=missing-raises-doc,redundant-returns-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Verify must be implemented\")\n\n\nclass Signer(metaclass=abc.ABCMeta):\n    \"\"\"Abstract base class for cryptographic signers.\"\"\"\n\n    @abc.abstractproperty\n    def key_id(self):\n        \"\"\"Optional[str]: The key ID used to identify this private key.\"\"\"\n        raise NotImplementedError(\"Key id must be implemented\")\n\n    @abc.abstractmethod\n    def sign(self, message):\n        \"\"\"Signs a message.\n\n        Args:\n            message (Union[str, bytes]): The message to be signed.\n\n        Returns:\n            bytes: The signature of the message.\n        \"\"\"\n        # pylint: disable=missing-raises-doc,redundant-returns-doc\n        # (pylint doesn't recognize that this is abstract)\n        raise NotImplementedError(\"Sign must be implemented\")\n\n\nclass FromServiceAccountMixin(metaclass=abc.ABCMeta):\n    \"\"\"Mix-in to enable factory constructors for a Signer.\"\"\"\n\n    @abc.abstractmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct an Signer instance from a private key string.\n\n        Args:\n            key (str): Private key as a string.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n\n        Raises:\n            ValueError: If the key cannot be parsed.\n        \"\"\"\n        raise NotImplementedError(\"from_string must be implemented\")\n\n    @classmethod\n    def from_service_account_info(cls, info):\n        \"\"\"Creates a Signer instance instance from a dictionary containing\n        service account info in Google format.\n\n        Args:\n            info (Mapping[str, str]): The service account info in Google\n                format.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n\n        Raises:\n            ValueError: If the info is not in the expected format.\n        \"\"\"\n        if _JSON_FILE_PRIVATE_KEY not in info:\n            raise exceptions.MalformedError(\n                \"The private_key field was not found in the service account \" \"info.\"\n            )\n\n        return cls.from_string(\n            info[_JSON_FILE_PRIVATE_KEY], info.get(_JSON_FILE_PRIVATE_KEY_ID)\n        )\n\n    @classmethod\n    def from_service_account_file(cls, filename):\n        \"\"\"Creates a Signer instance from a service account .json file\n        in Google format.\n\n        Args:\n            filename (str): The path to the service account .json file.\n\n        Returns:\n            google.auth.crypt.Signer: The constructed signer.\n        \"\"\"\n        with io.open(filename, \"r\", encoding=\"utf-8\") as json_file:\n            data = json.load(json_file)\n\n        return cls.from_service_account_info(data)\n", "google/auth/crypt/_cryptography_rsa.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"RSA verifier and signer that use the ``cryptography`` library.\n\nThis is a much faster implementation than the default (in\n``google.auth.crypt._python_rsa``), which depends on the pure-Python\n``rsa`` library.\n\"\"\"\n\nimport cryptography.exceptions\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import padding\nimport cryptography.x509\n\nfrom google.auth import _helpers\nfrom google.auth.crypt import base\n\n_CERTIFICATE_MARKER = b\"-----BEGIN CERTIFICATE-----\"\n_BACKEND = backends.default_backend()\n_PADDING = padding.PKCS1v15()\n_SHA256 = hashes.SHA256()\n\n\nclass RSAVerifier(base.Verifier):\n    \"\"\"Verifies RSA cryptographic signatures using public keys.\n\n    Args:\n        public_key (\n                cryptography.hazmat.primitives.asymmetric.rsa.RSAPublicKey):\n            The public key used to verify signatures.\n    \"\"\"\n\n    def __init__(self, public_key):\n        self._pubkey = public_key\n\n    @_helpers.copy_docstring(base.Verifier)\n    def verify(self, message, signature):\n        message = _helpers.to_bytes(message)\n        try:\n            self._pubkey.verify(signature, message, _PADDING, _SHA256)\n            return True\n        except (ValueError, cryptography.exceptions.InvalidSignature):\n            return False\n\n    @classmethod\n    def from_string(cls, public_key):\n        \"\"\"Construct an Verifier instance from a public key or public\n        certificate string.\n\n        Args:\n            public_key (Union[str, bytes]): The public key in PEM format or the\n                x509 public key certificate.\n\n        Returns:\n            Verifier: The constructed verifier.\n\n        Raises:\n            ValueError: If the public key can't be parsed.\n        \"\"\"\n        public_key_data = _helpers.to_bytes(public_key)\n\n        if _CERTIFICATE_MARKER in public_key_data:\n            cert = cryptography.x509.load_pem_x509_certificate(\n                public_key_data, _BACKEND\n            )\n            pubkey = cert.public_key()\n\n        else:\n            pubkey = serialization.load_pem_public_key(public_key_data, _BACKEND)\n\n        return cls(pubkey)\n\n\nclass RSASigner(base.Signer, base.FromServiceAccountMixin):\n    \"\"\"Signs messages with an RSA private key.\n\n    Args:\n        private_key (\n                cryptography.hazmat.primitives.asymmetric.rsa.RSAPrivateKey):\n            The private key to sign with.\n        key_id (str): Optional key ID used to identify this private key. This\n            can be useful to associate the private key with its associated\n            public key or certificate.\n    \"\"\"\n\n    def __init__(self, private_key, key_id=None):\n        self._key = private_key\n        self._key_id = key_id\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(base.Signer)\n    def key_id(self):\n        return self._key_id\n\n    @_helpers.copy_docstring(base.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        return self._key.sign(message, _PADDING, _SHA256)\n\n    @classmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct a RSASigner from a private key in PEM format.\n\n        Args:\n            key (Union[bytes, str]): Private key in PEM format.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt._cryptography_rsa.RSASigner: The\n            constructed signer.\n\n        Raises:\n            ValueError: If ``key`` is not ``bytes`` or ``str`` (unicode).\n            UnicodeDecodeError: If ``key`` is ``bytes`` but cannot be decoded\n                into a UTF-8 ``str``.\n            ValueError: If ``cryptography`` \"Could not deserialize key data.\"\n        \"\"\"\n        key = _helpers.to_bytes(key)\n        private_key = serialization.load_pem_private_key(\n            key, password=None, backend=_BACKEND\n        )\n        return cls(private_key, key_id=key_id)\n\n    def __getstate__(self):\n        \"\"\"Pickle helper that serializes the _key attribute.\"\"\"\n        state = self.__dict__.copy()\n        state[\"_key\"] = self._key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption(),\n        )\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Pickle helper that deserializes the _key attribute.\"\"\"\n        state[\"_key\"] = serialization.load_pem_private_key(state[\"_key\"], None)\n        self.__dict__.update(state)\n", "google/auth/crypt/es256.py": "# Copyright 2017 Google Inc.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"ECDSA (ES256) verifier and signer that use the ``cryptography`` library.\n\"\"\"\n\nfrom cryptography import utils  # type: ignore\nimport cryptography.exceptions\nfrom cryptography.hazmat import backends\nfrom cryptography.hazmat.primitives import hashes\nfrom cryptography.hazmat.primitives import serialization\nfrom cryptography.hazmat.primitives.asymmetric import ec\nfrom cryptography.hazmat.primitives.asymmetric import padding\nfrom cryptography.hazmat.primitives.asymmetric.utils import decode_dss_signature\nfrom cryptography.hazmat.primitives.asymmetric.utils import encode_dss_signature\nimport cryptography.x509\n\nfrom google.auth import _helpers\nfrom google.auth.crypt import base\n\n\n_CERTIFICATE_MARKER = b\"-----BEGIN CERTIFICATE-----\"\n_BACKEND = backends.default_backend()\n_PADDING = padding.PKCS1v15()\n\n\nclass ES256Verifier(base.Verifier):\n    \"\"\"Verifies ECDSA cryptographic signatures using public keys.\n\n    Args:\n        public_key (\n                cryptography.hazmat.primitives.asymmetric.ec.ECDSAPublicKey):\n            The public key used to verify signatures.\n    \"\"\"\n\n    def __init__(self, public_key):\n        self._pubkey = public_key\n\n    @_helpers.copy_docstring(base.Verifier)\n    def verify(self, message, signature):\n        # First convert (r||s) raw signature to ASN1 encoded signature.\n        sig_bytes = _helpers.to_bytes(signature)\n        if len(sig_bytes) != 64:\n            return False\n        r = (\n            int.from_bytes(sig_bytes[:32], byteorder=\"big\")\n            if _helpers.is_python_3()\n            else utils.int_from_bytes(sig_bytes[:32], byteorder=\"big\")\n        )\n        s = (\n            int.from_bytes(sig_bytes[32:], byteorder=\"big\")\n            if _helpers.is_python_3()\n            else utils.int_from_bytes(sig_bytes[32:], byteorder=\"big\")\n        )\n        asn1_sig = encode_dss_signature(r, s)\n\n        message = _helpers.to_bytes(message)\n        try:\n            self._pubkey.verify(asn1_sig, message, ec.ECDSA(hashes.SHA256()))\n            return True\n        except (ValueError, cryptography.exceptions.InvalidSignature):\n            return False\n\n    @classmethod\n    def from_string(cls, public_key):\n        \"\"\"Construct an Verifier instance from a public key or public\n        certificate string.\n\n        Args:\n            public_key (Union[str, bytes]): The public key in PEM format or the\n                x509 public key certificate.\n\n        Returns:\n            Verifier: The constructed verifier.\n\n        Raises:\n            ValueError: If the public key can't be parsed.\n        \"\"\"\n        public_key_data = _helpers.to_bytes(public_key)\n\n        if _CERTIFICATE_MARKER in public_key_data:\n            cert = cryptography.x509.load_pem_x509_certificate(\n                public_key_data, _BACKEND\n            )\n            pubkey = cert.public_key()\n\n        else:\n            pubkey = serialization.load_pem_public_key(public_key_data, _BACKEND)\n\n        return cls(pubkey)\n\n\nclass ES256Signer(base.Signer, base.FromServiceAccountMixin):\n    \"\"\"Signs messages with an ECDSA private key.\n\n    Args:\n        private_key (\n                cryptography.hazmat.primitives.asymmetric.ec.ECDSAPrivateKey):\n            The private key to sign with.\n        key_id (str): Optional key ID used to identify this private key. This\n            can be useful to associate the private key with its associated\n            public key or certificate.\n    \"\"\"\n\n    def __init__(self, private_key, key_id=None):\n        self._key = private_key\n        self._key_id = key_id\n\n    @property  # type: ignore\n    @_helpers.copy_docstring(base.Signer)\n    def key_id(self):\n        return self._key_id\n\n    @_helpers.copy_docstring(base.Signer)\n    def sign(self, message):\n        message = _helpers.to_bytes(message)\n        asn1_signature = self._key.sign(message, ec.ECDSA(hashes.SHA256()))\n\n        # Convert ASN1 encoded signature to (r||s) raw signature.\n        (r, s) = decode_dss_signature(asn1_signature)\n        return (\n            (r.to_bytes(32, byteorder=\"big\") + s.to_bytes(32, byteorder=\"big\"))\n            if _helpers.is_python_3()\n            else (utils.int_to_bytes(r, 32) + utils.int_to_bytes(s, 32))\n        )\n\n    @classmethod\n    def from_string(cls, key, key_id=None):\n        \"\"\"Construct a RSASigner from a private key in PEM format.\n\n        Args:\n            key (Union[bytes, str]): Private key in PEM format.\n            key_id (str): An optional key id used to identify the private key.\n\n        Returns:\n            google.auth.crypt._cryptography_rsa.RSASigner: The\n            constructed signer.\n\n        Raises:\n            ValueError: If ``key`` is not ``bytes`` or ``str`` (unicode).\n            UnicodeDecodeError: If ``key`` is ``bytes`` but cannot be decoded\n                into a UTF-8 ``str``.\n            ValueError: If ``cryptography`` \"Could not deserialize key data.\"\n        \"\"\"\n        key = _helpers.to_bytes(key)\n        private_key = serialization.load_pem_private_key(\n            key, password=None, backend=_BACKEND\n        )\n        return cls(private_key, key_id=key_id)\n\n    def __getstate__(self):\n        \"\"\"Pickle helper that serializes the _key attribute.\"\"\"\n        state = self.__dict__.copy()\n        state[\"_key\"] = self._key.private_bytes(\n            encoding=serialization.Encoding.PEM,\n            format=serialization.PrivateFormat.PKCS8,\n            encryption_algorithm=serialization.NoEncryption(),\n        )\n        return state\n\n    def __setstate__(self, state):\n        \"\"\"Pickle helper that deserializes the _key attribute.\"\"\"\n        state[\"_key\"] = serialization.load_pem_private_key(state[\"_key\"], None)\n        self.__dict__.update(state)\n", "google/auth/crypt/rsa.py": "# Copyright 2017 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"RSA cryptography signer and verifier.\"\"\"\n\n\ntry:\n    # Prefer cryptograph-based RSA implementation.\n    from google.auth.crypt import _cryptography_rsa\n\n    RSASigner = _cryptography_rsa.RSASigner\n    RSAVerifier = _cryptography_rsa.RSAVerifier\nexcept ImportError:  # pragma: NO COVER\n    # Fallback to pure-python RSA implementation if cryptography is\n    # unavailable.\n    from google.auth.crypt import _python_rsa\n\n    RSASigner = _python_rsa.RSASigner  # type: ignore\n    RSAVerifier = _python_rsa.RSAVerifier  # type: ignore\n", "google/auth/crypt/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Cryptography helpers for verifying and signing messages.\n\nThe simplest way to verify signatures is using :func:`verify_signature`::\n\n    cert = open('certs.pem').read()\n    valid = crypt.verify_signature(message, signature, cert)\n\nIf you're going to verify many messages with the same certificate, you can use\n:class:`RSAVerifier`::\n\n    cert = open('certs.pem').read()\n    verifier = crypt.RSAVerifier.from_string(cert)\n    valid = verifier.verify(message, signature)\n\nTo sign messages use :class:`RSASigner` with a private key::\n\n    private_key = open('private_key.pem').read()\n    signer = crypt.RSASigner.from_string(private_key)\n    signature = signer.sign(message)\n\nThe code above also works for :class:`ES256Signer` and :class:`ES256Verifier`.\nNote that these two classes are only available if your `cryptography` dependency\nversion is at least 1.4.0.\n\"\"\"\n\nfrom google.auth.crypt import base\nfrom google.auth.crypt import rsa\n\ntry:\n    from google.auth.crypt import es256\nexcept ImportError:  # pragma: NO COVER\n    es256 = None  # type: ignore\n\nif es256 is not None:  # pragma: NO COVER\n    __all__ = [\n        \"ES256Signer\",\n        \"ES256Verifier\",\n        \"RSASigner\",\n        \"RSAVerifier\",\n        \"Signer\",\n        \"Verifier\",\n    ]\nelse:  # pragma: NO COVER\n    __all__ = [\"RSASigner\", \"RSAVerifier\", \"Signer\", \"Verifier\"]\n\n\n# Aliases to maintain the v1.0.0 interface, as the crypt module was split\n# into submodules.\nSigner = base.Signer\nVerifier = base.Verifier\nRSASigner = rsa.RSASigner\nRSAVerifier = rsa.RSAVerifier\n\nif es256 is not None:  # pragma: NO COVER\n    ES256Signer = es256.ES256Signer\n    ES256Verifier = es256.ES256Verifier\n\n\ndef verify_signature(message, signature, certs, verifier_cls=rsa.RSAVerifier):\n    \"\"\"Verify an RSA or ECDSA cryptographic signature.\n\n    Checks that the provided ``signature`` was generated from ``bytes`` using\n    the private key associated with the ``cert``.\n\n    Args:\n        message (Union[str, bytes]): The plaintext message.\n        signature (Union[str, bytes]): The cryptographic signature to check.\n        certs (Union[Sequence, str, bytes]): The certificate or certificates\n            to use to check the signature.\n        verifier_cls (Optional[~google.auth.crypt.base.Signer]): Which verifier\n            class to use for verification. This can be used to select different\n            algorithms, such as RSA or ECDSA. Default value is :class:`RSAVerifier`.\n\n    Returns:\n        bool: True if the signature is valid, otherwise False.\n    \"\"\"\n    if isinstance(certs, (str, bytes)):\n        certs = [certs]\n\n    for cert in certs:\n        verifier = verifier_cls.from_string(cert)\n        if verifier.verify(message, signature):\n            return True\n    return False\n", "google/auth/crypt/_helpers.py": "", "google/auth/transport/grpc.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Authorization support for gRPC.\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport os\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth.transport import _mtls_helper\nfrom google.oauth2 import service_account\n\ntry:\n    import grpc  # type: ignore\nexcept ImportError as caught_exc:  # pragma: NO COVER\n    raise ImportError(\n        \"gRPC is not installed from please install the grpcio package to use the gRPC transport.\"\n    ) from caught_exc\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass AuthMetadataPlugin(grpc.AuthMetadataPlugin):\n    \"\"\"A `gRPC AuthMetadataPlugin`_ that inserts the credentials into each\n    request.\n\n    .. _gRPC AuthMetadataPlugin:\n        http://www.grpc.io/grpc/python/grpc.html#grpc.AuthMetadataPlugin\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to requests.\n        request (google.auth.transport.Request): A HTTP transport request\n            object used to refresh credentials as needed.\n        default_host (Optional[str]): A host like \"pubsub.googleapis.com\".\n            This is used when a self-signed JWT is created from service\n            account credentials.\n    \"\"\"\n\n    def __init__(self, credentials, request, default_host=None):\n        # pylint: disable=no-value-for-parameter\n        # pylint doesn't realize that the super method takes no arguments\n        # because this class is the same name as the superclass.\n        super(AuthMetadataPlugin, self).__init__()\n        self._credentials = credentials\n        self._request = request\n        self._default_host = default_host\n\n    def _get_authorization_headers(self, context):\n        \"\"\"Gets the authorization headers for a request.\n\n        Returns:\n            Sequence[Tuple[str, str]]: A list of request headers (key, value)\n                to add to the request.\n        \"\"\"\n        headers = {}\n\n        # https://google.aip.dev/auth/4111\n        # Attempt to use self-signed JWTs when a service account is used.\n        # A default host must be explicitly provided since it cannot always\n        # be determined from the context.service_url.\n        if isinstance(self._credentials, service_account.Credentials):\n            self._credentials._create_self_signed_jwt(\n                \"https://{}/\".format(self._default_host) if self._default_host else None\n            )\n\n        self._credentials.before_request(\n            self._request, context.method_name, context.service_url, headers\n        )\n\n        return list(headers.items())\n\n    def __call__(self, context, callback):\n        \"\"\"Passes authorization metadata into the given callback.\n\n        Args:\n            context (grpc.AuthMetadataContext): The RPC context.\n            callback (grpc.AuthMetadataPluginCallback): The callback that will\n                be invoked to pass in the authorization metadata.\n        \"\"\"\n        callback(self._get_authorization_headers(context), None)\n\n\ndef secure_authorized_channel(\n    credentials,\n    request,\n    target,\n    ssl_credentials=None,\n    client_cert_callback=None,\n    **kwargs\n):\n    \"\"\"Creates a secure authorized gRPC channel.\n\n    This creates a channel with SSL and :class:`AuthMetadataPlugin`. This\n    channel can be used to create a stub that can make authorized requests.\n    Users can configure client certificate or rely on device certificates to\n    establish a mutual TLS channel, if the `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    variable is explicitly set to `true`.\n\n    Example::\n\n        import google.auth\n        import google.auth.transport.grpc\n        import google.auth.transport.requests\n        from google.cloud.speech.v1 import cloud_speech_pb2\n\n        # Get credentials.\n        credentials, _ = google.auth.default()\n\n        # Get an HTTP request function to refresh credentials.\n        request = google.auth.transport.requests.Request()\n\n        # Create a channel.\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, regular_endpoint, request,\n            ssl_credentials=grpc.ssl_channel_credentials())\n\n        # Use the channel to create a stub.\n        cloud_speech.create_Speech_stub(channel)\n\n    Usage:\n\n    There are actually a couple of options to create a channel, depending on if\n    you want to create a regular or mutual TLS channel.\n\n    First let's list the endpoints (regular vs mutual TLS) to choose from::\n\n        regular_endpoint = 'speech.googleapis.com:443'\n        mtls_endpoint = 'speech.mtls.googleapis.com:443'\n\n    Option 1: create a regular (non-mutual) TLS channel by explicitly setting\n    the ssl_credentials::\n\n        regular_ssl_credentials = grpc.ssl_channel_credentials()\n\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, regular_endpoint, request,\n            ssl_credentials=regular_ssl_credentials)\n\n    Option 2: create a mutual TLS channel by calling a callback which returns\n    the client side certificate and the key (Note that\n    `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment variable must be explicitly\n    set to `true`)::\n\n        def my_client_cert_callback():\n            code_to_load_client_cert_and_key()\n            if loaded:\n                return (pem_cert_bytes, pem_key_bytes)\n            raise MyClientCertFailureException()\n\n        try:\n            channel = google.auth.transport.grpc.secure_authorized_channel(\n                credentials, mtls_endpoint, request,\n                client_cert_callback=my_client_cert_callback)\n        except MyClientCertFailureException:\n            # handle the exception\n\n    Option 3: use application default SSL credentials. It searches and uses\n    the command in a context aware metadata file, which is available on devices\n    with endpoint verification support (Note that\n    `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment variable must be explicitly\n    set to `true`).\n    See https://cloud.google.com/endpoint-verification/docs/overview::\n\n        try:\n            default_ssl_credentials = SslCredentials()\n        except:\n            # Exception can be raised if the context aware metadata is malformed.\n            # See :class:`SslCredentials` for the possible exceptions.\n\n        # Choose the endpoint based on the SSL credentials type.\n        if default_ssl_credentials.is_mtls:\n            endpoint_to_use = mtls_endpoint\n        else:\n            endpoint_to_use = regular_endpoint\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, endpoint_to_use, request,\n            ssl_credentials=default_ssl_credentials)\n\n    Option 4: not setting ssl_credentials and client_cert_callback. For devices\n    without endpoint verification support or `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    environment variable is not `true`, a regular TLS channel is created;\n    otherwise, a mutual TLS channel is created, however, the call should be\n    wrapped in a try/except block in case of malformed context aware metadata.\n\n    The following code uses regular_endpoint, it works the same no matter the\n    created channle is regular or mutual TLS. Regular endpoint ignores client\n    certificate and key::\n\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, regular_endpoint, request)\n\n    The following code uses mtls_endpoint, if the created channle is regular,\n    and API mtls_endpoint is confgured to require client SSL credentials, API\n    calls using this channel will be rejected::\n\n        channel = google.auth.transport.grpc.secure_authorized_channel(\n            credentials, mtls_endpoint, request)\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to requests.\n        request (google.auth.transport.Request): A HTTP transport request\n            object used to refresh credentials as needed. Even though gRPC\n            is a separate transport, there's no way to refresh the credentials\n            without using a standard http transport.\n        target (str): The host and port of the service.\n        ssl_credentials (grpc.ChannelCredentials): Optional SSL channel\n            credentials. This can be used to specify different certificates.\n            This argument is mutually exclusive with client_cert_callback;\n            providing both will raise an exception.\n            If ssl_credentials and client_cert_callback are None, application\n            default SSL credentials are used if `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n            environment variable is explicitly set to `true`, otherwise one way TLS\n            SSL credentials are used.\n        client_cert_callback (Callable[[], (bytes, bytes)]): Optional\n            callback function to obtain client certicate and key for mutual TLS\n            connection. This argument is mutually exclusive with\n            ssl_credentials; providing both will raise an exception.\n            This argument does nothing unless `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n            environment variable is explicitly set to `true`.\n        kwargs: Additional arguments to pass to :func:`grpc.secure_channel`.\n\n    Returns:\n        grpc.Channel: The created gRPC channel.\n\n    Raises:\n        google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n            creation failed for any reason.\n    \"\"\"\n    # Create the metadata plugin for inserting the authorization header.\n    metadata_plugin = AuthMetadataPlugin(credentials, request)\n\n    # Create a set of grpc.CallCredentials using the metadata plugin.\n    google_auth_credentials = grpc.metadata_call_credentials(metadata_plugin)\n\n    if ssl_credentials and client_cert_callback:\n        raise exceptions.MalformedError(\n            \"Received both ssl_credentials and client_cert_callback; \"\n            \"these are mutually exclusive.\"\n        )\n\n    # If SSL credentials are not explicitly set, try client_cert_callback and ADC.\n    if not ssl_credentials:\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert == \"true\" and client_cert_callback:\n            # Use the callback if provided.\n            cert, key = client_cert_callback()\n            ssl_credentials = grpc.ssl_channel_credentials(\n                certificate_chain=cert, private_key=key\n            )\n        elif use_client_cert == \"true\":\n            # Use application default SSL credentials.\n            adc_ssl_credentils = SslCredentials()\n            ssl_credentials = adc_ssl_credentils.ssl_credentials\n        else:\n            ssl_credentials = grpc.ssl_channel_credentials()\n\n    # Combine the ssl credentials and the authorization credentials.\n    composite_credentials = grpc.composite_channel_credentials(\n        ssl_credentials, google_auth_credentials\n    )\n\n    return grpc.secure_channel(target, composite_credentials, **kwargs)\n\n\nclass SslCredentials:\n    \"\"\"Class for application default SSL credentials.\n\n    The behavior is controlled by `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment\n    variable whose default value is `false`. Client certificate will not be used\n    unless the environment variable is explicitly set to `true`. See\n    https://google.aip.dev/auth/4114\n\n    If the environment variable is `true`, then for devices with endpoint verification\n    support, a device certificate will be automatically loaded and mutual TLS will\n    be established.\n    See https://cloud.google.com/endpoint-verification/docs/overview.\n    \"\"\"\n\n    def __init__(self):\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert != \"true\":\n            self._is_mtls = False\n        else:\n            # Load client SSL credentials.\n            metadata_path = _mtls_helper._check_dca_metadata_path(\n                _mtls_helper.CONTEXT_AWARE_METADATA_PATH\n            )\n            self._is_mtls = metadata_path is not None\n\n    @property\n    def ssl_credentials(self):\n        \"\"\"Get the created SSL channel credentials.\n\n        For devices with endpoint verification support, if the device certificate\n        loading has any problems, corresponding exceptions will be raised. For\n        a device without endpoint verification support, no exceptions will be\n        raised.\n\n        Returns:\n            grpc.ChannelCredentials: The created grpc channel credentials.\n\n        Raises:\n            google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n                creation failed for any reason.\n        \"\"\"\n        if self._is_mtls:\n            try:\n                _, cert, key, _ = _mtls_helper.get_client_ssl_credentials()\n                self._ssl_credentials = grpc.ssl_channel_credentials(\n                    certificate_chain=cert, private_key=key\n                )\n            except exceptions.ClientCertError as caught_exc:\n                new_exc = exceptions.MutualTLSChannelError(caught_exc)\n                raise new_exc from caught_exc\n        else:\n            self._ssl_credentials = grpc.ssl_channel_credentials()\n\n        return self._ssl_credentials\n\n    @property\n    def is_mtls(self):\n        \"\"\"Indicates if the created SSL channel credentials is mutual TLS.\"\"\"\n        return self._is_mtls\n", "google/auth/transport/_mtls_helper.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Helper functions for getting mTLS cert and key.\"\"\"\n\nimport json\nimport logging\nfrom os import environ, path\nimport re\nimport subprocess\n\nfrom google.auth import exceptions\n\nCONTEXT_AWARE_METADATA_PATH = \"~/.secureConnect/context_aware_metadata.json\"\n_CERTIFICATE_CONFIGURATION_DEFAULT_PATH = \"~/.config/gcloud/certificate_config.json\"\n_CERTIFICATE_CONFIGURATION_ENV = \"GOOGLE_API_CERTIFICATE_CONFIG\"\n_CERT_PROVIDER_COMMAND = \"cert_provider_command\"\n_CERT_REGEX = re.compile(\n    b\"-----BEGIN CERTIFICATE-----.+-----END CERTIFICATE-----\\r?\\n?\", re.DOTALL\n)\n\n# support various format of key files, e.g.\n# \"-----BEGIN PRIVATE KEY-----...\",\n# \"-----BEGIN EC PRIVATE KEY-----...\",\n# \"-----BEGIN RSA PRIVATE KEY-----...\"\n# \"-----BEGIN ENCRYPTED PRIVATE KEY-----\"\n_KEY_REGEX = re.compile(\n    b\"-----BEGIN [A-Z ]*PRIVATE KEY-----.+-----END [A-Z ]*PRIVATE KEY-----\\r?\\n?\",\n    re.DOTALL,\n)\n\n_LOGGER = logging.getLogger(__name__)\n\n\n_PASSPHRASE_REGEX = re.compile(\n    b\"-----BEGIN PASSPHRASE-----(.+)-----END PASSPHRASE-----\", re.DOTALL\n)\n\n\ndef _check_dca_metadata_path(metadata_path):\n    \"\"\"Checks for context aware metadata. If it exists, returns the absolute path;\n    otherwise returns None.\n\n    Args:\n        metadata_path (str): context aware metadata path.\n\n    Returns:\n        str: absolute path if exists and None otherwise.\n    \"\"\"\n    metadata_path = path.expanduser(metadata_path)\n    if not path.exists(metadata_path):\n        _LOGGER.debug(\"%s is not found, skip client SSL authentication.\", metadata_path)\n        return None\n    return metadata_path\n\n\ndef _load_json_file(path):\n    \"\"\"Reads and loads JSON from the given path. Used to read both X509 workload certificate and\n    secure connect configurations.\n\n    Args:\n        path (str): the path to read from.\n\n    Returns:\n        Dict[str, str]: The JSON stored at the file.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: If failed to parse the file as JSON.\n    \"\"\"\n    try:\n        with open(path) as f:\n            json_data = json.load(f)\n    except ValueError as caught_exc:\n        new_exc = exceptions.ClientCertError(caught_exc)\n        raise new_exc from caught_exc\n\n    return json_data\n\n\ndef _get_workload_cert_and_key(certificate_config_path=None):\n    \"\"\"Read the workload identity cert and key files specified in the certificate config provided.\n    If no config path is provided, check the environment variable: \"GOOGLE_API_CERTIFICATE_CONFIG\"\n    first, then the well known gcloud location: \"~/.config/gcloud/certificate_config.json\".\n\n    Args:\n        certificate_config_path (string): The certificate config path. If no path is provided,\n        the environment variable will be checked first, then the well known gcloud location.\n\n    Returns:\n        Tuple[Optional[bytes], Optional[bytes]]: client certificate bytes in PEM format and key\n            bytes in PEM format.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when retrieving\n        the certificate or key information.\n    \"\"\"\n    absolute_path = _get_cert_config_path(certificate_config_path)\n    if absolute_path is None:\n        return None, None\n    data = _load_json_file(absolute_path)\n\n    if \"cert_configs\" not in data:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"cert configs\" object is expected'.format(\n                absolute_path\n            )\n        )\n    cert_configs = data[\"cert_configs\"]\n\n    if \"workload\" not in cert_configs:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"workload\" cert config is expected'.format(\n                absolute_path\n            )\n        )\n    workload = cert_configs[\"workload\"]\n\n    if \"cert_path\" not in workload:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"cert_path\" is expected in the workload cert config'.format(\n                absolute_path\n            )\n        )\n    cert_path = workload[\"cert_path\"]\n\n    if \"key_path\" not in workload:\n        raise exceptions.ClientCertError(\n            'Certificate config file {} is in an invalid format, a \"key_path\" is expected in the workload cert config'.format(\n                absolute_path\n            )\n        )\n    key_path = workload[\"key_path\"]\n\n    return _read_cert_and_key_files(cert_path, key_path)\n\n\ndef _get_cert_config_path(certificate_config_path=None):\n    \"\"\"Gets the certificate configuration full path using the following order of precedence:\n\n    1: Explicit override, if set\n    2: Environment variable, if set\n    3: Well-known location\n\n    Returns \"None\" if the selected config file does not exist.\n\n    Args:\n        certificate_config_path (string): The certificate config path. If provided, the well known\n        location and environment variable will be ignored.\n\n    Returns:\n        The absolute path of the certificate config file, and None if the file does not exist.\n    \"\"\"\n\n    if certificate_config_path is None:\n        env_path = environ.get(_CERTIFICATE_CONFIGURATION_ENV, None)\n        if env_path is not None and env_path != \"\":\n            certificate_config_path = env_path\n        else:\n            certificate_config_path = _CERTIFICATE_CONFIGURATION_DEFAULT_PATH\n\n    certificate_config_path = path.expanduser(certificate_config_path)\n    if not path.exists(certificate_config_path):\n        return None\n    return certificate_config_path\n\n\ndef _read_cert_and_key_files(cert_path, key_path):\n    cert_data = _read_cert_file(cert_path)\n    key_data = _read_key_file(key_path)\n\n    return cert_data, key_data\n\n\ndef _read_cert_file(cert_path):\n    with open(cert_path, \"rb\") as cert_file:\n        cert_data = cert_file.read()\n\n    cert_match = re.findall(_CERT_REGEX, cert_data)\n    if len(cert_match) != 1:\n        raise exceptions.ClientCertError(\n            \"Certificate file {} is in an invalid format, a single PEM formatted certificate is expected\".format(\n                cert_path\n            )\n        )\n    return cert_match[0]\n\n\ndef _read_key_file(key_path):\n    with open(key_path, \"rb\") as key_file:\n        key_data = key_file.read()\n\n    key_match = re.findall(_KEY_REGEX, key_data)\n    if len(key_match) != 1:\n        raise exceptions.ClientCertError(\n            \"Private key file {} is in an invalid format, a single PEM formatted private key is expected\".format(\n                key_path\n            )\n        )\n\n    return key_match[0]\n\n\ndef _run_cert_provider_command(command, expect_encrypted_key=False):\n    \"\"\"Run the provided command, and return client side mTLS cert, key and\n    passphrase.\n\n    Args:\n        command (List[str]): cert provider command.\n        expect_encrypted_key (bool): If encrypted private key is expected.\n\n    Returns:\n        Tuple[bytes, bytes, bytes]: client certificate bytes in PEM format, key\n            bytes in PEM format and passphrase bytes.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when running\n            the cert provider command or generating cert, key and passphrase.\n    \"\"\"\n    try:\n        process = subprocess.Popen(\n            command, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n        )\n        stdout, stderr = process.communicate()\n    except OSError as caught_exc:\n        new_exc = exceptions.ClientCertError(caught_exc)\n        raise new_exc from caught_exc\n\n    # Check cert provider command execution error.\n    if process.returncode != 0:\n        raise exceptions.ClientCertError(\n            \"Cert provider command returns non-zero status code %s\" % process.returncode\n        )\n\n    # Extract certificate (chain), key and passphrase.\n    cert_match = re.findall(_CERT_REGEX, stdout)\n    if len(cert_match) != 1:\n        raise exceptions.ClientCertError(\"Client SSL certificate is missing or invalid\")\n    key_match = re.findall(_KEY_REGEX, stdout)\n    if len(key_match) != 1:\n        raise exceptions.ClientCertError(\"Client SSL key is missing or invalid\")\n    passphrase_match = re.findall(_PASSPHRASE_REGEX, stdout)\n\n    if expect_encrypted_key:\n        if len(passphrase_match) != 1:\n            raise exceptions.ClientCertError(\"Passphrase is missing or invalid\")\n        if b\"ENCRYPTED\" not in key_match[0]:\n            raise exceptions.ClientCertError(\"Encrypted private key is expected\")\n        return cert_match[0], key_match[0], passphrase_match[0].strip()\n\n    if b\"ENCRYPTED\" in key_match[0]:\n        raise exceptions.ClientCertError(\"Encrypted private key is not expected\")\n    if len(passphrase_match) > 0:\n        raise exceptions.ClientCertError(\"Passphrase is not expected\")\n    return cert_match[0], key_match[0], None\n\n\ndef get_client_ssl_credentials(\n    generate_encrypted_key=False,\n    context_aware_metadata_path=CONTEXT_AWARE_METADATA_PATH,\n):\n    \"\"\"Returns the client side certificate, private key and passphrase.\n\n    Args:\n        generate_encrypted_key (bool): If set to True, encrypted private key\n            and passphrase will be generated; otherwise, unencrypted private key\n            will be generated and passphrase will be None.\n        context_aware_metadata_path (str): The context_aware_metadata.json file path.\n\n    Returns:\n        Tuple[bool, bytes, bytes, bytes]:\n            A boolean indicating if cert, key and passphrase are obtained, the\n            cert bytes and key bytes both in PEM format, and passphrase bytes.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when getting\n            the cert, key and passphrase.\n    \"\"\"\n    metadata_path = _check_dca_metadata_path(context_aware_metadata_path)\n\n    if metadata_path:\n        metadata_json = _load_json_file(metadata_path)\n\n        if _CERT_PROVIDER_COMMAND not in metadata_json:\n            raise exceptions.ClientCertError(\"Cert provider command is not found\")\n\n        command = metadata_json[_CERT_PROVIDER_COMMAND]\n\n        if generate_encrypted_key and \"--with_passphrase\" not in command:\n            command.append(\"--with_passphrase\")\n\n        # Execute the command.\n        cert, key, passphrase = _run_cert_provider_command(\n            command, expect_encrypted_key=generate_encrypted_key\n        )\n        return True, cert, key, passphrase\n\n    return False, None, None, None\n\n\ndef get_client_cert_and_key(client_cert_callback=None):\n    \"\"\"Returns the client side certificate and private key. The function first\n    tries to get certificate and key from client_cert_callback; if the callback\n    is None or doesn't provide certificate and key, the function tries application\n    default SSL credentials.\n\n    Args:\n        client_cert_callback (Optional[Callable[[], (bytes, bytes)]]): An\n            optional callback which returns client certificate bytes and private\n            key bytes both in PEM format.\n\n    Returns:\n        Tuple[bool, bytes, bytes]:\n            A boolean indicating if cert and key are obtained, the cert bytes\n            and key bytes both in PEM format.\n\n    Raises:\n        google.auth.exceptions.ClientCertError: if problems occurs when getting\n            the cert and key.\n    \"\"\"\n    if client_cert_callback:\n        cert, key = client_cert_callback()\n        return True, cert, key\n\n    has_cert, cert, key, _ = get_client_ssl_credentials(generate_encrypted_key=False)\n    return has_cert, cert, key\n\n\ndef decrypt_private_key(key, passphrase):\n    \"\"\"A helper function to decrypt the private key with the given passphrase.\n    google-auth library doesn't support passphrase protected private key for\n    mutual TLS channel. This helper function can be used to decrypt the\n    passphrase protected private key in order to estalish mutual TLS channel.\n\n    For example, if you have a function which produces client cert, passphrase\n    protected private key and passphrase, you can convert it to a client cert\n    callback function accepted by google-auth::\n\n        from google.auth.transport import _mtls_helper\n\n        def your_client_cert_function():\n            return cert, encrypted_key, passphrase\n\n        # callback accepted by google-auth for mutual TLS channel.\n        def client_cert_callback():\n            cert, encrypted_key, passphrase = your_client_cert_function()\n            decrypted_key = _mtls_helper.decrypt_private_key(encrypted_key,\n                passphrase)\n            return cert, decrypted_key\n\n    Args:\n        key (bytes): The private key bytes in PEM format.\n        passphrase (bytes): The passphrase bytes.\n\n    Returns:\n        bytes: The decrypted private key in PEM format.\n\n    Raises:\n        ImportError: If pyOpenSSL is not installed.\n        OpenSSL.crypto.Error: If there is any problem decrypting the private key.\n    \"\"\"\n    from OpenSSL import crypto\n\n    # First convert encrypted_key_bytes to PKey object\n    pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key, passphrase=passphrase)\n\n    # Then dump the decrypted key bytes\n    return crypto.dump_privatekey(crypto.FILETYPE_PEM, pkey)\n", "google/auth/transport/_custom_tls_signer.py": "# Copyright 2022 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"\nCode for configuring client side TLS to offload the signing operation to\nsigning libraries.\n\"\"\"\n\nimport ctypes\nimport json\nimport logging\nimport os\nimport sys\n\nimport cffi  # type: ignore\n\nfrom google.auth import exceptions\n\n_LOGGER = logging.getLogger(__name__)\n\n# C++ offload lib requires google-auth lib to provide the following callback:\n#     using SignFunc = int (*)(unsigned char *sig, size_t *sig_len,\n#             const unsigned char *tbs, size_t tbs_len)\n# The bytes to be signed and the length are provided via `tbs` and `tbs_len`,\n# the callback computes the signature, and write the signature and its length\n# into `sig` and `sig_len`.\n# If the signing is successful, the callback returns 1, otherwise it returns 0.\nSIGN_CALLBACK_CTYPE = ctypes.CFUNCTYPE(\n    ctypes.c_int,  # return type\n    ctypes.POINTER(ctypes.c_ubyte),  # sig\n    ctypes.POINTER(ctypes.c_size_t),  # sig_len\n    ctypes.POINTER(ctypes.c_ubyte),  # tbs\n    ctypes.c_size_t,  # tbs_len\n)\n\n\n# Cast SSL_CTX* to void*\ndef _cast_ssl_ctx_to_void_p_pyopenssl(ssl_ctx):\n    return ctypes.cast(int(cffi.FFI().cast(\"intptr_t\", ssl_ctx)), ctypes.c_void_p)\n\n\n# Cast SSL_CTX* to void*\ndef _cast_ssl_ctx_to_void_p_stdlib(context):\n    return ctypes.c_void_p.from_address(\n        id(context) + ctypes.sizeof(ctypes.c_void_p) * 2\n    )\n\n\n# Load offload library and set up the function types.\ndef load_offload_lib(offload_lib_path):\n    _LOGGER.debug(\"loading offload library from %s\", offload_lib_path)\n\n    # winmode parameter is only available for python 3.8+.\n    lib = (\n        ctypes.CDLL(offload_lib_path, winmode=0)\n        if sys.version_info >= (3, 8) and os.name == \"nt\"\n        else ctypes.CDLL(offload_lib_path)\n    )\n\n    # Set up types for:\n    # int ConfigureSslContext(SignFunc sign_func, const char *cert, SSL_CTX *ctx)\n    lib.ConfigureSslContext.argtypes = [\n        SIGN_CALLBACK_CTYPE,\n        ctypes.c_char_p,\n        ctypes.c_void_p,\n    ]\n    lib.ConfigureSslContext.restype = ctypes.c_int\n\n    return lib\n\n\n# Load signer library and set up the function types.\n# See: https://github.com/googleapis/enterprise-certificate-proxy/blob/main/cshared/main.go\ndef load_signer_lib(signer_lib_path):\n    _LOGGER.debug(\"loading signer library from %s\", signer_lib_path)\n\n    # winmode parameter is only available for python 3.8+.\n    lib = (\n        ctypes.CDLL(signer_lib_path, winmode=0)\n        if sys.version_info >= (3, 8) and os.name == \"nt\"\n        else ctypes.CDLL(signer_lib_path)\n    )\n\n    # Set up types for:\n    # func GetCertPemForPython(configFilePath *C.char, certHolder *byte, certHolderLen int)\n    lib.GetCertPemForPython.argtypes = [ctypes.c_char_p, ctypes.c_char_p, ctypes.c_int]\n    # Returns: certLen\n    lib.GetCertPemForPython.restype = ctypes.c_int\n\n    # Set up types for:\n    # func SignForPython(configFilePath *C.char, digest *byte, digestLen int,\n    #     sigHolder *byte, sigHolderLen int)\n    lib.SignForPython.argtypes = [\n        ctypes.c_char_p,\n        ctypes.c_char_p,\n        ctypes.c_int,\n        ctypes.c_char_p,\n        ctypes.c_int,\n    ]\n    # Returns: the signature length\n    lib.SignForPython.restype = ctypes.c_int\n\n    return lib\n\n\ndef load_provider_lib(provider_lib_path):\n    _LOGGER.debug(\"loading provider library from %s\", provider_lib_path)\n\n    # winmode parameter is only available for python 3.8+.\n    lib = (\n        ctypes.CDLL(provider_lib_path, winmode=0)\n        if sys.version_info >= (3, 8) and os.name == \"nt\"\n        else ctypes.CDLL(provider_lib_path)\n    )\n\n    lib.ECP_attach_to_ctx.argtypes = [ctypes.c_void_p, ctypes.c_char_p]\n    lib.ECP_attach_to_ctx.restype = ctypes.c_int\n\n    return lib\n\n\n# Computes SHA256 hash.\ndef _compute_sha256_digest(to_be_signed, to_be_signed_len):\n    from cryptography.hazmat.primitives import hashes\n\n    data = ctypes.string_at(to_be_signed, to_be_signed_len)\n    hash = hashes.Hash(hashes.SHA256())\n    hash.update(data)\n    return hash.finalize()\n\n\n# Create the signing callback. The actual signing work is done by the\n# `SignForPython` method from the signer lib.\ndef get_sign_callback(signer_lib, config_file_path):\n    def sign_callback(sig, sig_len, tbs, tbs_len):\n        _LOGGER.debug(\"calling sign callback...\")\n\n        digest = _compute_sha256_digest(tbs, tbs_len)\n        digestArray = ctypes.c_char * len(digest)\n\n        # reserve 2000 bytes for the signature, shoud be more then enough.\n        # RSA signature is 256 bytes, EC signature is 70~72.\n        sig_holder_len = 2000\n        sig_holder = ctypes.create_string_buffer(sig_holder_len)\n\n        signature_len = signer_lib.SignForPython(\n            config_file_path.encode(),  # configFilePath\n            digestArray.from_buffer(bytearray(digest)),  # digest\n            len(digest),  # digestLen\n            sig_holder,  # sigHolder\n            sig_holder_len,  # sigHolderLen\n        )\n\n        if signature_len == 0:\n            # signing failed, return 0\n            return 0\n\n        sig_len[0] = signature_len\n        bs = bytearray(sig_holder)\n        for i in range(signature_len):\n            sig[i] = bs[i]\n\n        return 1\n\n    return SIGN_CALLBACK_CTYPE(sign_callback)\n\n\n# Obtain the certificate bytes by calling the `GetCertPemForPython` method from\n# the signer lib. The method is called twice, the first time is to compute the\n# cert length, then we create a buffer to hold the cert, and call it again to\n# fill the buffer.\ndef get_cert(signer_lib, config_file_path):\n    # First call to calculate the cert length\n    cert_len = signer_lib.GetCertPemForPython(\n        config_file_path.encode(),  # configFilePath\n        None,  # certHolder\n        0,  # certHolderLen\n    )\n    if cert_len == 0:\n        raise exceptions.MutualTLSChannelError(\"failed to get certificate\")\n\n    # Then we create an array to hold the cert, and call again to fill the cert\n    cert_holder = ctypes.create_string_buffer(cert_len)\n    signer_lib.GetCertPemForPython(\n        config_file_path.encode(),  # configFilePath\n        cert_holder,  # certHolder\n        cert_len,  # certHolderLen\n    )\n    return bytes(cert_holder)\n\n\nclass CustomTlsSigner(object):\n    def __init__(self, enterprise_cert_file_path):\n        \"\"\"\n        This class loads the offload and signer library, and calls APIs from\n        these libraries to obtain the cert and a signing callback, and attach\n        them to SSL context. The cert and the signing callback will be used\n        for client authentication in TLS handshake.\n\n        Args:\n            enterprise_cert_file_path (str): the path to a enterprise cert JSON\n                file. The file should contain the following field:\n\n                    {\n                        \"libs\": {\n                            \"ecp_client\": \"...\",\n                            \"tls_offload\": \"...\"\n                        }\n                    }\n        \"\"\"\n        self._enterprise_cert_file_path = enterprise_cert_file_path\n        self._cert = None\n        self._sign_callback = None\n        self._provider_lib = None\n\n    def load_libraries(self):\n        with open(self._enterprise_cert_file_path, \"r\") as f:\n            enterprise_cert_json = json.load(f)\n            libs = enterprise_cert_json.get(\"libs\", {})\n\n            signer_library = libs.get(\"ecp_client\", None)\n            offload_library = libs.get(\"tls_offload\", None)\n            provider_library = libs.get(\"ecp_provider\", None)\n\n        # Using newer provider implementation. This is mutually exclusive to the\n        # offload implementation.\n        if provider_library:\n            self._provider_lib = load_provider_lib(provider_library)\n            return\n\n        # Using old offload implementation\n        if offload_library and signer_library:\n            self._offload_lib = load_offload_lib(offload_library)\n            self._signer_lib = load_signer_lib(signer_library)\n            self.set_up_custom_key()\n            return\n\n        raise exceptions.MutualTLSChannelError(\"enterprise cert file is invalid\")\n\n    def set_up_custom_key(self):\n        # We need to keep a reference of the cert and sign callback so it won't\n        # be garbage collected, otherwise it will crash when used by signer lib.\n        self._cert = get_cert(self._signer_lib, self._enterprise_cert_file_path)\n        self._sign_callback = get_sign_callback(\n            self._signer_lib, self._enterprise_cert_file_path\n        )\n\n    def should_use_provider(self):\n        if self._provider_lib:\n            return True\n        return False\n\n    def attach_to_ssl_context(self, ctx):\n        if self.should_use_provider():\n            if not self._provider_lib.ECP_attach_to_ctx(\n                _cast_ssl_ctx_to_void_p_stdlib(ctx),\n                self._enterprise_cert_file_path.encode(\"ascii\"),\n            ):\n                raise exceptions.MutualTLSChannelError(\n                    \"failed to configure ECP Provider SSL context\"\n                )\n        elif self._offload_lib and self._signer_lib:\n            if not self._offload_lib.ConfigureSslContext(\n                self._sign_callback,\n                ctypes.c_char_p(self._cert),\n                _cast_ssl_ctx_to_void_p_pyopenssl(ctx._ctx._context),\n            ):\n                raise exceptions.MutualTLSChannelError(\n                    \"failed to configure ECP Offload SSL context\"\n                )\n        else:\n            raise exceptions.MutualTLSChannelError(\"Invalid ECP configuration.\")\n", "google/auth/transport/mtls.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Utilites for mutual TLS.\"\"\"\n\nfrom google.auth import exceptions\nfrom google.auth.transport import _mtls_helper\n\n\ndef has_default_client_cert_source():\n    \"\"\"Check if default client SSL credentials exists on the device.\n\n    Returns:\n        bool: indicating if the default client cert source exists.\n    \"\"\"\n    metadata_path = _mtls_helper._check_dca_metadata_path(\n        _mtls_helper.CONTEXT_AWARE_METADATA_PATH\n    )\n    return metadata_path is not None\n\n\ndef default_client_cert_source():\n    \"\"\"Get a callback which returns the default client SSL credentials.\n\n    Returns:\n        Callable[[], [bytes, bytes]]: A callback which returns the default\n            client certificate bytes and private key bytes, both in PEM format.\n\n    Raises:\n        google.auth.exceptions.DefaultClientCertSourceError: If the default\n            client SSL credentials don't exist or are malformed.\n    \"\"\"\n    if not has_default_client_cert_source():\n        raise exceptions.MutualTLSChannelError(\n            \"Default client cert source doesn't exist\"\n        )\n\n    def callback():\n        try:\n            _, cert_bytes, key_bytes = _mtls_helper.get_client_cert_and_key()\n        except (OSError, RuntimeError, ValueError) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        return cert_bytes, key_bytes\n\n    return callback\n\n\ndef default_client_encrypted_cert_source(cert_path, key_path):\n    \"\"\"Get a callback which returns the default encrpyted client SSL credentials.\n\n    Args:\n        cert_path (str): The cert file path. The default client certificate will\n            be written to this file when the returned callback is called.\n        key_path (str): The key file path. The default encrypted client key will\n            be written to this file when the returned callback is called.\n\n    Returns:\n        Callable[[], [str, str, bytes]]: A callback which generates the default\n            client certificate, encrpyted private key and passphrase. It writes\n            the certificate and private key into the cert_path and key_path, and\n            returns the cert_path, key_path and passphrase bytes.\n\n    Raises:\n        google.auth.exceptions.DefaultClientCertSourceError: If any problem\n            occurs when loading or saving the client certificate and key.\n    \"\"\"\n    if not has_default_client_cert_source():\n        raise exceptions.MutualTLSChannelError(\n            \"Default client encrypted cert source doesn't exist\"\n        )\n\n    def callback():\n        try:\n            (\n                _,\n                cert_bytes,\n                key_bytes,\n                passphrase_bytes,\n            ) = _mtls_helper.get_client_ssl_credentials(generate_encrypted_key=True)\n            with open(cert_path, \"wb\") as cert_file:\n                cert_file.write(cert_bytes)\n            with open(key_path, \"wb\") as key_file:\n                key_file.write(key_bytes)\n        except (exceptions.ClientCertError, OSError) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        return cert_path, key_path, passphrase_bytes\n\n    return callback\n", "google/auth/transport/_aiohttp_requests.py": "# Copyright 2020 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for Async HTTP (aiohttp).\n\nNOTE: This async support is experimental and marked internal. This surface may\nchange in minor releases.\n\"\"\"\n\nfrom __future__ import absolute_import\n\nimport asyncio\nimport functools\n\nimport aiohttp  # type: ignore\nimport urllib3  # type: ignore\n\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.auth.transport import requests\n\n# Timeout can be re-defined depending on async requirement. Currently made 60s more than\n# sync timeout.\n_DEFAULT_TIMEOUT = 180  # in seconds\n\n\nclass _CombinedResponse(transport.Response):\n    \"\"\"\n    In order to more closely resemble the `requests` interface, where a raw\n    and deflated content could be accessed at once, this class lazily reads the\n    stream in `transport.Response` so both return forms can be used.\n\n    The gzip and deflate transfer-encodings are automatically decoded for you\n    because the default parameter for autodecompress into the ClientSession is set\n    to False, and therefore we add this class to act as a wrapper for a user to be\n    able to access both the raw and decoded response bodies - mirroring the sync\n    implementation.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n        self._raw_content = None\n\n    def _is_compressed(self):\n        headers = self._response.headers\n        return \"Content-Encoding\" in headers and (\n            headers[\"Content-Encoding\"] == \"gzip\"\n            or headers[\"Content-Encoding\"] == \"deflate\"\n        )\n\n    @property\n    def status(self):\n        return self._response.status\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.content\n\n    async def raw_content(self):\n        if self._raw_content is None:\n            self._raw_content = await self._response.content.read()\n        return self._raw_content\n\n    async def content(self):\n        # Load raw_content if necessary\n        await self.raw_content()\n        if self._is_compressed():\n            decoder = urllib3.response.MultiDecoder(\n                self._response.headers[\"Content-Encoding\"]\n            )\n            decompressed = decoder.decompress(self._raw_content)\n            return decompressed\n\n        return self._raw_content\n\n\nclass _Response(transport.Response):\n    \"\"\"\n    Requests transport response adapter.\n\n    Args:\n        response (requests.Response): The raw Requests response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n\n    @property\n    def status(self):\n        return self._response.status\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.content\n\n\nclass Request(transport.Request):\n    \"\"\"Requests request adapter.\n\n    This class is used internally for making requests using asyncio transports\n    in a consistent way. If you use :class:`AuthorizedSession` you do not need\n    to construct or use this class directly.\n\n    This class can be useful if you want to manually refresh a\n    :class:`~google.auth.credentials.Credentials` instance::\n\n        import google.auth.transport.aiohttp_requests\n\n        request = google.auth.transport.aiohttp_requests.Request()\n\n        credentials.refresh(request)\n\n    Args:\n        session (aiohttp.ClientSession): An instance :class:`aiohttp.ClientSession` used\n            to make HTTP requests. If not specified, a session will be created.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    def __init__(self, session=None):\n        # TODO: Use auto_decompress property for aiohttp 3.7+\n        if session is not None and session._auto_decompress:\n            raise exceptions.InvalidOperation(\n                \"Client sessions with auto_decompress=True are not supported.\"\n            )\n        self.session = session\n\n    async def __call__(\n        self,\n        url,\n        method=\"GET\",\n        body=None,\n        headers=None,\n        timeout=_DEFAULT_TIMEOUT,\n        **kwargs,\n    ):\n        \"\"\"\n        Make an HTTP request using aiohttp.\n\n        Args:\n            url (str): The URL to be requested.\n            method (Optional[str]):\n                The HTTP method to use for the request. Defaults to 'GET'.\n            body (Optional[bytes]):\n                The payload or body in HTTP request.\n            headers (Optional[Mapping[str, str]]):\n                Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                requests default timeout will be used.\n            kwargs: Additional arguments passed through to the underlying\n                requests :meth:`requests.Session.request` method.\n\n        Returns:\n            google.auth.transport.Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n\n        try:\n            if self.session is None:  # pragma: NO COVER\n                self.session = aiohttp.ClientSession(\n                    auto_decompress=False\n                )  # pragma: NO COVER\n            requests._LOGGER.debug(\"Making request: %s %s\", method, url)\n            response = await self.session.request(\n                method, url, data=body, headers=headers, timeout=timeout, **kwargs\n            )\n            return _CombinedResponse(response)\n\n        except aiohttp.ClientError as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n        except asyncio.TimeoutError as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n\nclass AuthorizedSession(aiohttp.ClientSession):\n    \"\"\"This is an async implementation of the Authorized Session class. We utilize an\n    aiohttp transport instance, and the interface mirrors the google.auth.transport.requests\n    Authorized Session class, except for the change in the transport used in the async use case.\n\n    A Requests Session class with credentials.\n\n    This class is used to perform requests to API endpoints that require\n    authorization::\n\n        from google.auth.transport import aiohttp_requests\n\n        async with aiohttp_requests.AuthorizedSession(credentials) as authed_session:\n            response = await authed_session.request(\n                'GET', 'https://www.googleapis.com/storage/v1/b')\n\n    The underlying :meth:`request` implementation handles adding the\n    credentials' headers to the request and refreshing credentials as needed.\n\n    Args:\n        credentials (google.auth._credentials_async.Credentials):\n            The credentials to add to the request.\n        refresh_status_codes (Sequence[int]): Which HTTP status codes indicate\n            that credentials should be refreshed and the request should be\n            retried.\n        max_refresh_attempts (int): The maximum number of times to attempt to\n            refresh the credentials and retry the request.\n        refresh_timeout (Optional[int]): The timeout value in seconds for\n            credential refresh HTTP requests.\n        auth_request (google.auth.transport.aiohttp_requests.Request):\n            (Optional) An instance of\n            :class:`~google.auth.transport.aiohttp_requests.Request` used when\n            refreshing credentials. If not passed,\n            an instance of :class:`~google.auth.transport.aiohttp_requests.Request`\n            is created.\n        kwargs: Additional arguments passed through to the underlying\n            ClientSession :meth:`aiohttp.ClientSession` object.\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials,\n        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,\n        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,\n        refresh_timeout=None,\n        auth_request=None,\n        auto_decompress=False,\n        **kwargs,\n    ):\n        super(AuthorizedSession, self).__init__(**kwargs)\n        self.credentials = credentials\n        self._refresh_status_codes = refresh_status_codes\n        self._max_refresh_attempts = max_refresh_attempts\n        self._refresh_timeout = refresh_timeout\n        self._is_mtls = False\n        self._auth_request = auth_request\n        self._auth_request_session = None\n        self._loop = asyncio.get_event_loop()\n        self._refresh_lock = asyncio.Lock()\n        self._auto_decompress = auto_decompress\n\n    async def request(\n        self,\n        method,\n        url,\n        data=None,\n        headers=None,\n        max_allowed_time=None,\n        timeout=_DEFAULT_TIMEOUT,\n        auto_decompress=False,\n        **kwargs,\n    ):\n\n        \"\"\"Implementation of Authorized Session aiohttp request.\n\n        Args:\n            method (str):\n                The http request method used (e.g. GET, PUT, DELETE)\n            url (str):\n                The url at which the http request is sent.\n            data (Optional[dict]): Dictionary, list of tuples, bytes, or file-like\n                object to send in the body of the Request.\n            headers (Optional[dict]): Dictionary of HTTP Headers to send with the\n                Request.\n            timeout (Optional[Union[float, aiohttp.ClientTimeout]]):\n                The amount of time in seconds to wait for the server response\n                with each individual request. Can also be passed as an\n                ``aiohttp.ClientTimeout`` object.\n            max_allowed_time (Optional[float]):\n                If the method runs longer than this, a ``Timeout`` exception is\n                automatically raised. Unlike the ``timeout`` parameter, this\n                value applies to the total method execution time, even if\n                multiple requests are made under the hood.\n\n                Mind that it is not guaranteed that the timeout error is raised\n                at ``max_allowed_time``. It might take longer, for example, if\n                an underlying request takes a lot of time, but the request\n                itself does not timeout, e.g. if a large file is being\n                transmitted. The timout error will be raised after such\n                request completes.\n        \"\"\"\n        # Headers come in as bytes which isn't expected behavior, the resumable\n        # media libraries in some cases expect a str type for the header values,\n        # but sometimes the operations return these in bytes types.\n        if headers:\n            for key in headers.keys():\n                if type(headers[key]) is bytes:\n                    headers[key] = headers[key].decode(\"utf-8\")\n\n        async with aiohttp.ClientSession(\n            auto_decompress=self._auto_decompress,\n            trust_env=kwargs.get(\"trust_env\", False),\n        ) as self._auth_request_session:\n            auth_request = Request(self._auth_request_session)\n            self._auth_request = auth_request\n\n            # Use a kwarg for this instead of an attribute to maintain\n            # thread-safety.\n            _credential_refresh_attempt = kwargs.pop(\"_credential_refresh_attempt\", 0)\n            # Make a copy of the headers. They will be modified by the credentials\n            # and we want to pass the original headers if we recurse.\n            request_headers = headers.copy() if headers is not None else {}\n\n            # Do not apply the timeout unconditionally in order to not override the\n            # _auth_request's default timeout.\n            auth_request = (\n                self._auth_request\n                if timeout is None\n                else functools.partial(self._auth_request, timeout=timeout)\n            )\n\n            remaining_time = max_allowed_time\n\n            with requests.TimeoutGuard(remaining_time, asyncio.TimeoutError) as guard:\n                await self.credentials.before_request(\n                    auth_request, method, url, request_headers\n                )\n\n            with requests.TimeoutGuard(remaining_time, asyncio.TimeoutError) as guard:\n                response = await super(AuthorizedSession, self).request(\n                    method,\n                    url,\n                    data=data,\n                    headers=request_headers,\n                    timeout=timeout,\n                    **kwargs,\n                )\n\n            remaining_time = guard.remaining_timeout\n\n            if (\n                response.status in self._refresh_status_codes\n                and _credential_refresh_attempt < self._max_refresh_attempts\n            ):\n\n                requests._LOGGER.info(\n                    \"Refreshing credentials due to a %s response. Attempt %s/%s.\",\n                    response.status,\n                    _credential_refresh_attempt + 1,\n                    self._max_refresh_attempts,\n                )\n\n                # Do not apply the timeout unconditionally in order to not override the\n                # _auth_request's default timeout.\n                auth_request = (\n                    self._auth_request\n                    if timeout is None\n                    else functools.partial(self._auth_request, timeout=timeout)\n                )\n\n                with requests.TimeoutGuard(\n                    remaining_time, asyncio.TimeoutError\n                ) as guard:\n                    async with self._refresh_lock:\n                        await self._loop.run_in_executor(\n                            None, self.credentials.refresh, auth_request\n                        )\n\n                remaining_time = guard.remaining_timeout\n\n                return await self.request(\n                    method,\n                    url,\n                    data=data,\n                    headers=headers,\n                    max_allowed_time=remaining_time,\n                    timeout=timeout,\n                    _credential_refresh_attempt=_credential_refresh_attempt + 1,\n                    **kwargs,\n                )\n\n        return response\n", "google/auth/transport/requests.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for Requests.\"\"\"\n\nfrom __future__ import absolute_import\n\nimport functools\nimport logging\nimport numbers\nimport os\nimport time\n\ntry:\n    import requests\nexcept ImportError as caught_exc:  # pragma: NO COVER\n    raise ImportError(\n        \"The requests library is not installed from please install the requests package to use the requests transport.\"\n    ) from caught_exc\nimport requests.adapters  # pylint: disable=ungrouped-imports\nimport requests.exceptions  # pylint: disable=ungrouped-imports\nfrom requests.packages.urllib3.util.ssl_ import (  # type: ignore\n    create_urllib3_context,\n)  # pylint: disable=ungrouped-imports\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nimport google.auth.transport._mtls_helper\nfrom google.oauth2 import service_account\n\n_LOGGER = logging.getLogger(__name__)\n\n_DEFAULT_TIMEOUT = 120  # in seconds\n\n\nclass _Response(transport.Response):\n    \"\"\"Requests transport response adapter.\n\n    Args:\n        response (requests.Response): The raw Requests response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n\n    @property\n    def status(self):\n        return self._response.status_code\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.content\n\n\nclass TimeoutGuard(object):\n    \"\"\"A context manager raising an error if the suite execution took too long.\n\n    Args:\n        timeout (Union[None, Union[float, Tuple[float, float]]]):\n            The maximum number of seconds a suite can run without the context\n            manager raising a timeout exception on exit. If passed as a tuple,\n            the smaller of the values is taken as a timeout. If ``None``, a\n            timeout error is never raised.\n        timeout_error_type (Optional[Exception]):\n            The type of the error to raise on timeout. Defaults to\n            :class:`requests.exceptions.Timeout`.\n    \"\"\"\n\n    def __init__(self, timeout, timeout_error_type=requests.exceptions.Timeout):\n        self._timeout = timeout\n        self.remaining_timeout = timeout\n        self._timeout_error_type = timeout_error_type\n\n    def __enter__(self):\n        self._start = time.time()\n        return self\n\n    def __exit__(self, exc_type, exc_value, traceback):\n        if exc_value:\n            return  # let the error bubble up automatically\n\n        if self._timeout is None:\n            return  # nothing to do, the timeout was not specified\n\n        elapsed = time.time() - self._start\n        deadline_hit = False\n\n        if isinstance(self._timeout, numbers.Number):\n            self.remaining_timeout = self._timeout - elapsed\n            deadline_hit = self.remaining_timeout <= 0\n        else:\n            self.remaining_timeout = tuple(x - elapsed for x in self._timeout)\n            deadline_hit = min(self.remaining_timeout) <= 0\n\n        if deadline_hit:\n            raise self._timeout_error_type()\n\n\nclass Request(transport.Request):\n    \"\"\"Requests request adapter.\n\n    This class is used internally for making requests using various transports\n    in a consistent way. If you use :class:`AuthorizedSession` you do not need\n    to construct or use this class directly.\n\n    This class can be useful if you want to manually refresh a\n    :class:`~google.auth.credentials.Credentials` instance::\n\n        import google.auth.transport.requests\n        import requests\n\n        request = google.auth.transport.requests.Request()\n\n        credentials.refresh(request)\n\n    Args:\n        session (requests.Session): An instance :class:`requests.Session` used\n            to make HTTP requests. If not specified, a session will be created.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    def __init__(self, session=None):\n        if not session:\n            session = requests.Session()\n\n        self.session = session\n\n    def __del__(self):\n        try:\n            if hasattr(self, \"session\") and self.session is not None:\n                self.session.close()\n        except TypeError:\n            # NOTE: For certain Python binary built, the queue.Empty exception\n            # might not be considered a normal Python exception causing\n            # TypeError.\n            pass\n\n    def __call__(\n        self,\n        url,\n        method=\"GET\",\n        body=None,\n        headers=None,\n        timeout=_DEFAULT_TIMEOUT,\n        **kwargs\n    ):\n        \"\"\"Make an HTTP request using requests.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload or body in HTTP request.\n            headers (Mapping[str, str]): Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                requests default timeout will be used.\n            kwargs: Additional arguments passed through to the underlying\n                requests :meth:`~requests.Session.request` method.\n\n        Returns:\n            google.auth.transport.Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        try:\n            _LOGGER.debug(\"Making request: %s %s\", method, url)\n            response = self.session.request(\n                method, url, data=body, headers=headers, timeout=timeout, **kwargs\n            )\n            return _Response(response)\n        except requests.exceptions.RequestException as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n\nclass _MutualTlsAdapter(requests.adapters.HTTPAdapter):\n    \"\"\"\n    A TransportAdapter that enables mutual TLS.\n\n    Args:\n        cert (bytes): client certificate in PEM format\n        key (bytes): client private key in PEM format\n\n    Raises:\n        ImportError: if certifi or pyOpenSSL is not installed\n        OpenSSL.crypto.Error: if client cert or key is invalid\n    \"\"\"\n\n    def __init__(self, cert, key):\n        import certifi\n        from OpenSSL import crypto\n        import urllib3.contrib.pyopenssl  # type: ignore\n\n        urllib3.contrib.pyopenssl.inject_into_urllib3()\n\n        pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key)\n        x509 = crypto.load_certificate(crypto.FILETYPE_PEM, cert)\n\n        ctx_poolmanager = create_urllib3_context()\n        ctx_poolmanager.load_verify_locations(cafile=certifi.where())\n        ctx_poolmanager._ctx.use_certificate(x509)\n        ctx_poolmanager._ctx.use_privatekey(pkey)\n        self._ctx_poolmanager = ctx_poolmanager\n\n        ctx_proxymanager = create_urllib3_context()\n        ctx_proxymanager.load_verify_locations(cafile=certifi.where())\n        ctx_proxymanager._ctx.use_certificate(x509)\n        ctx_proxymanager._ctx.use_privatekey(pkey)\n        self._ctx_proxymanager = ctx_proxymanager\n\n        super(_MutualTlsAdapter, self).__init__()\n\n    def init_poolmanager(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_poolmanager\n        super(_MutualTlsAdapter, self).init_poolmanager(*args, **kwargs)\n\n    def proxy_manager_for(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_proxymanager\n        return super(_MutualTlsAdapter, self).proxy_manager_for(*args, **kwargs)\n\n\nclass _MutualTlsOffloadAdapter(requests.adapters.HTTPAdapter):\n    \"\"\"\n    A TransportAdapter that enables mutual TLS and offloads the client side\n    signing operation to the signing library.\n\n    Args:\n        enterprise_cert_file_path (str): the path to a enterprise cert JSON\n            file. The file should contain the following field:\n\n                {\n                    \"libs\": {\n                        \"signer_library\": \"...\",\n                        \"offload_library\": \"...\"\n                    }\n                }\n\n    Raises:\n        ImportError: if certifi or pyOpenSSL is not installed\n        google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n            creation failed for any reason.\n    \"\"\"\n\n    def __init__(self, enterprise_cert_file_path):\n        import certifi\n        from google.auth.transport import _custom_tls_signer\n\n        self.signer = _custom_tls_signer.CustomTlsSigner(enterprise_cert_file_path)\n        self.signer.load_libraries()\n\n        import urllib3.contrib.pyopenssl\n\n        urllib3.contrib.pyopenssl.inject_into_urllib3()\n\n        poolmanager = create_urllib3_context()\n        poolmanager.load_verify_locations(cafile=certifi.where())\n        self.signer.attach_to_ssl_context(poolmanager)\n        self._ctx_poolmanager = poolmanager\n\n        proxymanager = create_urllib3_context()\n        proxymanager.load_verify_locations(cafile=certifi.where())\n        self.signer.attach_to_ssl_context(proxymanager)\n        self._ctx_proxymanager = proxymanager\n\n        super(_MutualTlsOffloadAdapter, self).__init__()\n\n    def init_poolmanager(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_poolmanager\n        super(_MutualTlsOffloadAdapter, self).init_poolmanager(*args, **kwargs)\n\n    def proxy_manager_for(self, *args, **kwargs):\n        kwargs[\"ssl_context\"] = self._ctx_proxymanager\n        return super(_MutualTlsOffloadAdapter, self).proxy_manager_for(*args, **kwargs)\n\n\nclass AuthorizedSession(requests.Session):\n    \"\"\"A Requests Session class with credentials.\n\n    This class is used to perform requests to API endpoints that require\n    authorization::\n\n        from google.auth.transport.requests import AuthorizedSession\n\n        authed_session = AuthorizedSession(credentials)\n\n        response = authed_session.request(\n            'GET', 'https://www.googleapis.com/storage/v1/b')\n\n\n    The underlying :meth:`request` implementation handles adding the\n    credentials' headers to the request and refreshing credentials as needed.\n\n    This class also supports mutual TLS via :meth:`configure_mtls_channel`\n    method. In order to use this method, the `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    environment variable must be explicitly set to ``true``, otherwise it does\n    nothing. Assume the environment is set to ``true``, the method behaves in the\n    following manner:\n\n    If client_cert_callback is provided, client certificate and private\n    key are loaded using the callback; if client_cert_callback is None,\n    application default SSL credentials will be used. Exceptions are raised if\n    there are problems with the certificate, private key, or the loading process,\n    so it should be called within a try/except block.\n\n    First we set the environment variable to ``true``, then create an :class:`AuthorizedSession`\n    instance and specify the endpoints::\n\n        regular_endpoint = 'https://pubsub.googleapis.com/v1/projects/{my_project_id}/topics'\n        mtls_endpoint = 'https://pubsub.mtls.googleapis.com/v1/projects/{my_project_id}/topics'\n\n        authed_session = AuthorizedSession(credentials)\n\n    Now we can pass a callback to :meth:`configure_mtls_channel`::\n\n        def my_cert_callback():\n            # some code to load client cert bytes and private key bytes, both in\n            # PEM format.\n            some_code_to_load_client_cert_and_key()\n            if loaded:\n                return cert, key\n            raise MyClientCertFailureException()\n\n        # Always call configure_mtls_channel within a try/except block.\n        try:\n            authed_session.configure_mtls_channel(my_cert_callback)\n        except:\n            # handle exceptions.\n\n        if authed_session.is_mtls:\n            response = authed_session.request('GET', mtls_endpoint)\n        else:\n            response = authed_session.request('GET', regular_endpoint)\n\n\n    You can alternatively use application default SSL credentials like this::\n\n        try:\n            authed_session.configure_mtls_channel()\n        except:\n            # handle exceptions.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to the request.\n        refresh_status_codes (Sequence[int]): Which HTTP status codes indicate\n            that credentials should be refreshed and the request should be\n            retried.\n        max_refresh_attempts (int): The maximum number of times to attempt to\n            refresh the credentials and retry the request.\n        refresh_timeout (Optional[int]): The timeout value in seconds for\n            credential refresh HTTP requests.\n        auth_request (google.auth.transport.requests.Request):\n            (Optional) An instance of\n            :class:`~google.auth.transport.requests.Request` used when\n            refreshing credentials. If not passed,\n            an instance of :class:`~google.auth.transport.requests.Request`\n            is created.\n        default_host (Optional[str]): A host like \"pubsub.googleapis.com\".\n            This is used when a self-signed JWT is created from service\n            account credentials.\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials,\n        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,\n        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,\n        refresh_timeout=None,\n        auth_request=None,\n        default_host=None,\n    ):\n        super(AuthorizedSession, self).__init__()\n        self.credentials = credentials\n        self._refresh_status_codes = refresh_status_codes\n        self._max_refresh_attempts = max_refresh_attempts\n        self._refresh_timeout = refresh_timeout\n        self._is_mtls = False\n        self._default_host = default_host\n\n        if auth_request is None:\n            self._auth_request_session = requests.Session()\n\n            # Using an adapter to make HTTP requests robust to network errors.\n            # This adapter retrys HTTP requests when network errors occur\n            # and the requests seems safely retryable.\n            retry_adapter = requests.adapters.HTTPAdapter(max_retries=3)\n            self._auth_request_session.mount(\"https://\", retry_adapter)\n\n            # Do not pass `self` as the session here, as it can lead to\n            # infinite recursion.\n            auth_request = Request(self._auth_request_session)\n        else:\n            self._auth_request_session = None\n\n        # Request instance used by internal methods (for example,\n        # credentials.refresh).\n        self._auth_request = auth_request\n\n        # https://google.aip.dev/auth/4111\n        # Attempt to use self-signed JWTs when a service account is used.\n        if isinstance(self.credentials, service_account.Credentials):\n            self.credentials._create_self_signed_jwt(\n                \"https://{}/\".format(self._default_host) if self._default_host else None\n            )\n\n    def configure_mtls_channel(self, client_cert_callback=None):\n        \"\"\"Configure the client certificate and key for SSL connection.\n\n        The function does nothing unless `GOOGLE_API_USE_CLIENT_CERTIFICATE` is\n        explicitly set to `true`. In this case if client certificate and key are\n        successfully obtained (from the given client_cert_callback or from application\n        default SSL credentials), a :class:`_MutualTlsAdapter` instance will be mounted\n        to \"https://\" prefix.\n\n        Args:\n            client_cert_callback (Optional[Callable[[], (bytes, bytes)]]):\n                The optional callback returns the client certificate and private\n                key bytes both in PEM format.\n                If the callback is None, application default SSL credentials\n                will be used.\n\n        Raises:\n            google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n                creation failed for any reason.\n        \"\"\"\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert != \"true\":\n            self._is_mtls = False\n            return\n\n        try:\n            import OpenSSL\n        except ImportError as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        try:\n            (\n                self._is_mtls,\n                cert,\n                key,\n            ) = google.auth.transport._mtls_helper.get_client_cert_and_key(\n                client_cert_callback\n            )\n\n            if self._is_mtls:\n                mtls_adapter = _MutualTlsAdapter(cert, key)\n                self.mount(\"https://\", mtls_adapter)\n        except (\n            exceptions.ClientCertError,\n            ImportError,\n            OpenSSL.crypto.Error,\n        ) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n    def request(\n        self,\n        method,\n        url,\n        data=None,\n        headers=None,\n        max_allowed_time=None,\n        timeout=_DEFAULT_TIMEOUT,\n        **kwargs\n    ):\n        \"\"\"Implementation of Requests' request.\n\n        Args:\n            timeout (Optional[Union[float, Tuple[float, float]]]):\n                The amount of time in seconds to wait for the server response\n                with each individual request. Can also be passed as a tuple\n                ``(connect_timeout, read_timeout)``. See :meth:`requests.Session.request`\n                documentation for details.\n            max_allowed_time (Optional[float]):\n                If the method runs longer than this, a ``Timeout`` exception is\n                automatically raised. Unlike the ``timeout`` parameter, this\n                value applies to the total method execution time, even if\n                multiple requests are made under the hood.\n\n                Mind that it is not guaranteed that the timeout error is raised\n                at ``max_allowed_time``. It might take longer, for example, if\n                an underlying request takes a lot of time, but the request\n                itself does not timeout, e.g. if a large file is being\n                transmitted. The timout error will be raised after such\n                request completes.\n        \"\"\"\n        # pylint: disable=arguments-differ\n        # Requests has a ton of arguments to request, but only two\n        # (method, url) are required. We pass through all of the other\n        # arguments to super, so no need to exhaustively list them here.\n\n        # Use a kwarg for this instead of an attribute to maintain\n        # thread-safety.\n        _credential_refresh_attempt = kwargs.pop(\"_credential_refresh_attempt\", 0)\n\n        # Make a copy of the headers. They will be modified by the credentials\n        # and we want to pass the original headers if we recurse.\n        request_headers = headers.copy() if headers is not None else {}\n\n        # Do not apply the timeout unconditionally in order to not override the\n        # _auth_request's default timeout.\n        auth_request = (\n            self._auth_request\n            if timeout is None\n            else functools.partial(self._auth_request, timeout=timeout)\n        )\n\n        remaining_time = max_allowed_time\n\n        with TimeoutGuard(remaining_time) as guard:\n            self.credentials.before_request(auth_request, method, url, request_headers)\n        remaining_time = guard.remaining_timeout\n\n        with TimeoutGuard(remaining_time) as guard:\n            response = super(AuthorizedSession, self).request(\n                method,\n                url,\n                data=data,\n                headers=request_headers,\n                timeout=timeout,\n                **kwargs\n            )\n        remaining_time = guard.remaining_timeout\n\n        # If the response indicated that the credentials needed to be\n        # refreshed, then refresh the credentials and re-attempt the\n        # request.\n        # A stored token may expire between the time it is retrieved and\n        # the time the request is made, so we may need to try twice.\n        if (\n            response.status_code in self._refresh_status_codes\n            and _credential_refresh_attempt < self._max_refresh_attempts\n        ):\n\n            _LOGGER.info(\n                \"Refreshing credentials due to a %s response. Attempt %s/%s.\",\n                response.status_code,\n                _credential_refresh_attempt + 1,\n                self._max_refresh_attempts,\n            )\n\n            # Do not apply the timeout unconditionally in order to not override the\n            # _auth_request's default timeout.\n            auth_request = (\n                self._auth_request\n                if timeout is None\n                else functools.partial(self._auth_request, timeout=timeout)\n            )\n\n            with TimeoutGuard(remaining_time) as guard:\n                self.credentials.refresh(auth_request)\n            remaining_time = guard.remaining_timeout\n\n            # Recurse. Pass in the original headers, not our modified set, but\n            # do pass the adjusted max allowed time (i.e. the remaining total time).\n            return self.request(\n                method,\n                url,\n                data=data,\n                headers=headers,\n                max_allowed_time=remaining_time,\n                timeout=timeout,\n                _credential_refresh_attempt=_credential_refresh_attempt + 1,\n                **kwargs\n            )\n\n        return response\n\n    @property\n    def is_mtls(self):\n        \"\"\"Indicates if the created SSL channel is mutual TLS.\"\"\"\n        return self._is_mtls\n\n    def close(self):\n        if self._auth_request_session is not None:\n            self._auth_request_session.close()\n        super(AuthorizedSession, self).close()\n", "google/auth/transport/urllib3.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for urllib3.\"\"\"\n\nfrom __future__ import absolute_import\n\nimport logging\nimport os\nimport warnings\n\n# Certifi is Mozilla's certificate bundle. Urllib3 needs a certificate bundle\n# to verify HTTPS requests, and certifi is the recommended and most reliable\n# way to get a root certificate bundle. See\n# http://urllib3.readthedocs.io/en/latest/user-guide.html\\\n#   #certificate-verification\n# For more details.\ntry:\n    import certifi\nexcept ImportError:  # pragma: NO COVER\n    certifi = None  # type: ignore\n\ntry:\n    import urllib3  # type: ignore\n    import urllib3.exceptions  # type: ignore\nexcept ImportError as caught_exc:  # pragma: NO COVER\n    raise ImportError(\n        \"The urllib3 library is not installed from please install the \"\n        \"urllib3 package to use the urllib3 transport.\"\n    ) from caught_exc\n\nfrom packaging import version  # type: ignore\n\nfrom google.auth import environment_vars\nfrom google.auth import exceptions\nfrom google.auth import transport\nfrom google.oauth2 import service_account\n\nif version.parse(urllib3.__version__) >= version.parse(\"2.0.0\"):  # pragma: NO COVER\n    RequestMethods = urllib3._request_methods.RequestMethods  # type: ignore\nelse:  # pragma: NO COVER\n    RequestMethods = urllib3.request.RequestMethods  # type: ignore\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass _Response(transport.Response):\n    \"\"\"urllib3 transport response adapter.\n\n    Args:\n        response (urllib3.response.HTTPResponse): The raw urllib3 response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._response = response\n\n    @property\n    def status(self):\n        return self._response.status\n\n    @property\n    def headers(self):\n        return self._response.headers\n\n    @property\n    def data(self):\n        return self._response.data\n\n\nclass Request(transport.Request):\n    \"\"\"urllib3 request adapter.\n\n    This class is used internally for making requests using various transports\n    in a consistent way. If you use :class:`AuthorizedHttp` you do not need\n    to construct or use this class directly.\n\n    This class can be useful if you want to manually refresh a\n    :class:`~google.auth.credentials.Credentials` instance::\n\n        import google.auth.transport.urllib3\n        import urllib3\n\n        http = urllib3.PoolManager()\n        request = google.auth.transport.urllib3.Request(http)\n\n        credentials.refresh(request)\n\n    Args:\n        http (urllib3.request.RequestMethods): An instance of any urllib3\n            class that implements :class:`~urllib3.request.RequestMethods`,\n            usually :class:`urllib3.PoolManager`.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    def __init__(self, http):\n        self.http = http\n\n    def __call__(\n        self, url, method=\"GET\", body=None, headers=None, timeout=None, **kwargs\n    ):\n        \"\"\"Make an HTTP request using urllib3.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload / body in HTTP request.\n            headers (Mapping[str, str]): Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                urllib3 default timeout will be used.\n            kwargs: Additional arguments passed throught to the underlying\n                urllib3 :meth:`urlopen` method.\n\n        Returns:\n            google.auth.transport.Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        # urllib3 uses a sentinel default value for timeout, so only set it if\n        # specified.\n        if timeout is not None:\n            kwargs[\"timeout\"] = timeout\n\n        try:\n            _LOGGER.debug(\"Making request: %s %s\", method, url)\n            response = self.http.request(\n                method, url, body=body, headers=headers, **kwargs\n            )\n            return _Response(response)\n        except urllib3.exceptions.HTTPError as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n\ndef _make_default_http():\n    if certifi is not None:\n        return urllib3.PoolManager(cert_reqs=\"CERT_REQUIRED\", ca_certs=certifi.where())\n    else:\n        return urllib3.PoolManager()\n\n\ndef _make_mutual_tls_http(cert, key):\n    \"\"\"Create a mutual TLS HTTP connection with the given client cert and key.\n    See https://github.com/urllib3/urllib3/issues/474#issuecomment-253168415\n\n    Args:\n        cert (bytes): client certificate in PEM format\n        key (bytes): client private key in PEM format\n\n    Returns:\n        urllib3.PoolManager: Mutual TLS HTTP connection.\n\n    Raises:\n        ImportError: If certifi or pyOpenSSL is not installed.\n        OpenSSL.crypto.Error: If the cert or key is invalid.\n    \"\"\"\n    import certifi\n    from OpenSSL import crypto\n    import urllib3.contrib.pyopenssl  # type: ignore\n\n    urllib3.contrib.pyopenssl.inject_into_urllib3()\n    ctx = urllib3.util.ssl_.create_urllib3_context()\n    ctx.load_verify_locations(cafile=certifi.where())\n\n    pkey = crypto.load_privatekey(crypto.FILETYPE_PEM, key)\n    x509 = crypto.load_certificate(crypto.FILETYPE_PEM, cert)\n\n    ctx._ctx.use_certificate(x509)\n    ctx._ctx.use_privatekey(pkey)\n\n    http = urllib3.PoolManager(ssl_context=ctx)\n    return http\n\n\nclass AuthorizedHttp(RequestMethods):  # type: ignore\n    \"\"\"A urllib3 HTTP class with credentials.\n\n    This class is used to perform requests to API endpoints that require\n    authorization::\n\n        from google.auth.transport.urllib3 import AuthorizedHttp\n\n        authed_http = AuthorizedHttp(credentials)\n\n        response = authed_http.request(\n            'GET', 'https://www.googleapis.com/storage/v1/b')\n\n    This class implements :class:`urllib3.request.RequestMethods` and can be\n    used just like any other :class:`urllib3.PoolManager`.\n\n    The underlying :meth:`urlopen` implementation handles adding the\n    credentials' headers to the request and refreshing credentials as needed.\n\n    This class also supports mutual TLS via :meth:`configure_mtls_channel`\n    method. In order to use this method, the `GOOGLE_API_USE_CLIENT_CERTIFICATE`\n    environment variable must be explicitly set to `true`, otherwise it does\n    nothing. Assume the environment is set to `true`, the method behaves in the\n    following manner:\n    If client_cert_callback is provided, client certificate and private\n    key are loaded using the callback; if client_cert_callback is None,\n    application default SSL credentials will be used. Exceptions are raised if\n    there are problems with the certificate, private key, or the loading process,\n    so it should be called within a try/except block.\n\n    First we set the environment variable to `true`, then create an :class:`AuthorizedHttp`\n    instance and specify the endpoints::\n\n        regular_endpoint = 'https://pubsub.googleapis.com/v1/projects/{my_project_id}/topics'\n        mtls_endpoint = 'https://pubsub.mtls.googleapis.com/v1/projects/{my_project_id}/topics'\n\n        authed_http = AuthorizedHttp(credentials)\n\n    Now we can pass a callback to :meth:`configure_mtls_channel`::\n\n        def my_cert_callback():\n            # some code to load client cert bytes and private key bytes, both in\n            # PEM format.\n            some_code_to_load_client_cert_and_key()\n            if loaded:\n                return cert, key\n            raise MyClientCertFailureException()\n\n        # Always call configure_mtls_channel within a try/except block.\n        try:\n            is_mtls = authed_http.configure_mtls_channel(my_cert_callback)\n        except:\n            # handle exceptions.\n\n        if is_mtls:\n            response = authed_http.request('GET', mtls_endpoint)\n        else:\n            response = authed_http.request('GET', regular_endpoint)\n\n    You can alternatively use application default SSL credentials like this::\n\n        try:\n            is_mtls = authed_http.configure_mtls_channel()\n        except:\n            # handle exceptions.\n\n    Args:\n        credentials (google.auth.credentials.Credentials): The credentials to\n            add to the request.\n        http (urllib3.PoolManager): The underlying HTTP object to\n            use to make requests. If not specified, a\n            :class:`urllib3.PoolManager` instance will be constructed with\n            sane defaults.\n        refresh_status_codes (Sequence[int]): Which HTTP status codes indicate\n            that credentials should be refreshed and the request should be\n            retried.\n        max_refresh_attempts (int): The maximum number of times to attempt to\n            refresh the credentials and retry the request.\n        default_host (Optional[str]): A host like \"pubsub.googleapis.com\".\n            This is used when a self-signed JWT is created from service\n            account credentials.\n    \"\"\"\n\n    def __init__(\n        self,\n        credentials,\n        http=None,\n        refresh_status_codes=transport.DEFAULT_REFRESH_STATUS_CODES,\n        max_refresh_attempts=transport.DEFAULT_MAX_REFRESH_ATTEMPTS,\n        default_host=None,\n    ):\n        if http is None:\n            self.http = _make_default_http()\n            self._has_user_provided_http = False\n        else:\n            self.http = http\n            self._has_user_provided_http = True\n\n        self.credentials = credentials\n        self._refresh_status_codes = refresh_status_codes\n        self._max_refresh_attempts = max_refresh_attempts\n        self._default_host = default_host\n        # Request instance used by internal methods (for example,\n        # credentials.refresh).\n        self._request = Request(self.http)\n\n        # https://google.aip.dev/auth/4111\n        # Attempt to use self-signed JWTs when a service account is used.\n        if isinstance(self.credentials, service_account.Credentials):\n            self.credentials._create_self_signed_jwt(\n                \"https://{}/\".format(self._default_host) if self._default_host else None\n            )\n\n        super(AuthorizedHttp, self).__init__()\n\n    def configure_mtls_channel(self, client_cert_callback=None):\n        \"\"\"Configures mutual TLS channel using the given client_cert_callback or\n        application default SSL credentials. The behavior is controlled by\n        `GOOGLE_API_USE_CLIENT_CERTIFICATE` environment variable.\n        (1) If the environment variable value is `true`, the function returns True\n        if the channel is mutual TLS and False otherwise. The `http` provided\n        in the constructor will be overwritten.\n        (2) If the environment variable is not set or `false`, the function does\n        nothing and it always return False.\n\n        Args:\n            client_cert_callback (Optional[Callable[[], (bytes, bytes)]]):\n                The optional callback returns the client certificate and private\n                key bytes both in PEM format.\n                If the callback is None, application default SSL credentials\n                will be used.\n\n        Returns:\n            True if the channel is mutual TLS and False otherwise.\n\n        Raises:\n            google.auth.exceptions.MutualTLSChannelError: If mutual TLS channel\n                creation failed for any reason.\n        \"\"\"\n        use_client_cert = os.getenv(\n            environment_vars.GOOGLE_API_USE_CLIENT_CERTIFICATE, \"false\"\n        )\n        if use_client_cert != \"true\":\n            return False\n\n        try:\n            import OpenSSL\n        except ImportError as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        try:\n            found_cert_key, cert, key = transport._mtls_helper.get_client_cert_and_key(\n                client_cert_callback\n            )\n\n            if found_cert_key:\n                self.http = _make_mutual_tls_http(cert, key)\n            else:\n                self.http = _make_default_http()\n        except (\n            exceptions.ClientCertError,\n            ImportError,\n            OpenSSL.crypto.Error,\n        ) as caught_exc:\n            new_exc = exceptions.MutualTLSChannelError(caught_exc)\n            raise new_exc from caught_exc\n\n        if self._has_user_provided_http:\n            self._has_user_provided_http = False\n            warnings.warn(\n                \"`http` provided in the constructor is overwritten\", UserWarning\n            )\n\n        return found_cert_key\n\n    def urlopen(self, method, url, body=None, headers=None, **kwargs):\n        \"\"\"Implementation of urllib3's urlopen.\"\"\"\n        # pylint: disable=arguments-differ\n        # We use kwargs to collect additional args that we don't need to\n        # introspect here. However, we do explicitly collect the two\n        # positional arguments.\n\n        # Use a kwarg for this instead of an attribute to maintain\n        # thread-safety.\n        _credential_refresh_attempt = kwargs.pop(\"_credential_refresh_attempt\", 0)\n\n        if headers is None:\n            headers = self.headers\n\n        # Make a copy of the headers. They will be modified by the credentials\n        # and we want to pass the original headers if we recurse.\n        request_headers = headers.copy()\n\n        self.credentials.before_request(self._request, method, url, request_headers)\n\n        response = self.http.urlopen(\n            method, url, body=body, headers=request_headers, **kwargs\n        )\n\n        # If the response indicated that the credentials needed to be\n        # refreshed, then refresh the credentials and re-attempt the\n        # request.\n        # A stored token may expire between the time it is retrieved and\n        # the time the request is made, so we may need to try twice.\n        # The reason urllib3's retries aren't used is because they\n        # don't allow you to modify the request headers. :/\n        if (\n            response.status in self._refresh_status_codes\n            and _credential_refresh_attempt < self._max_refresh_attempts\n        ):\n\n            _LOGGER.info(\n                \"Refreshing credentials due to a %s response. Attempt %s/%s.\",\n                response.status,\n                _credential_refresh_attempt + 1,\n                self._max_refresh_attempts,\n            )\n\n            self.credentials.refresh(self._request)\n\n            # Recurse. Pass in the original headers, not our modified set.\n            return self.urlopen(\n                method,\n                url,\n                body=body,\n                headers=headers,\n                _credential_refresh_attempt=_credential_refresh_attempt + 1,\n                **kwargs\n            )\n\n        return response\n\n    # Proxy methods for compliance with the urllib3.PoolManager interface\n\n    def __enter__(self):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        return self.http.__enter__()\n\n    def __exit__(self, exc_type, exc_val, exc_tb):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        return self.http.__exit__(exc_type, exc_val, exc_tb)\n\n    def __del__(self):\n        if hasattr(self, \"http\") and self.http is not None:\n            self.http.clear()\n\n    @property\n    def headers(self):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        return self.http.headers\n\n    @headers.setter\n    def headers(self, value):\n        \"\"\"Proxy to ``self.http``.\"\"\"\n        self.http.headers = value\n", "google/auth/transport/_http_client.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport adapter for http.client, for internal use only.\"\"\"\n\nimport http.client as http_client\nimport logging\nimport socket\nimport urllib\n\nfrom google.auth import exceptions\nfrom google.auth import transport\n\n_LOGGER = logging.getLogger(__name__)\n\n\nclass Response(transport.Response):\n    \"\"\"http.client transport response adapter.\n\n    Args:\n        response (http.client.HTTPResponse): The raw http client response.\n    \"\"\"\n\n    def __init__(self, response):\n        self._status = response.status\n        self._headers = {key.lower(): value for key, value in response.getheaders()}\n        self._data = response.read()\n\n    @property\n    def status(self):\n        return self._status\n\n    @property\n    def headers(self):\n        return self._headers\n\n    @property\n    def data(self):\n        return self._data\n\n\nclass Request(transport.Request):\n    \"\"\"http.client transport request adapter.\"\"\"\n\n    def __call__(\n        self, url, method=\"GET\", body=None, headers=None, timeout=None, **kwargs\n    ):\n        \"\"\"Make an HTTP request using http.client.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload / body in HTTP request.\n            headers (Mapping): Request headers.\n            timeout (Optional(int)): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                socket global default timeout will be used.\n            kwargs: Additional arguments passed throught to the underlying\n                :meth:`~http.client.HTTPConnection.request` method.\n\n        Returns:\n            Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        # socket._GLOBAL_DEFAULT_TIMEOUT is the default in http.client.\n        if timeout is None:\n            timeout = socket._GLOBAL_DEFAULT_TIMEOUT\n\n        # http.client doesn't allow None as the headers argument.\n        if headers is None:\n            headers = {}\n\n        # http.client needs the host and path parts specified separately.\n        parts = urllib.parse.urlsplit(url)\n        path = urllib.parse.urlunsplit(\n            (\"\", \"\", parts.path, parts.query, parts.fragment)\n        )\n\n        if parts.scheme != \"http\":\n            raise exceptions.TransportError(\n                \"http.client transport only supports the http scheme, {}\"\n                \"was specified\".format(parts.scheme)\n            )\n\n        connection = http_client.HTTPConnection(parts.netloc, timeout=timeout)\n\n        try:\n            _LOGGER.debug(\"Making request: %s %s\", method, url)\n\n            connection.request(method, path, body=body, headers=headers, **kwargs)\n            response = connection.getresponse()\n            return Response(response)\n\n        except (http_client.HTTPException, socket.error) as caught_exc:\n            new_exc = exceptions.TransportError(caught_exc)\n            raise new_exc from caught_exc\n\n        finally:\n            connection.close()\n", "google/auth/transport/__init__.py": "# Copyright 2016 Google LLC\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#      http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\n\"\"\"Transport - HTTP client library support.\n\n:mod:`google.auth` is designed to work with various HTTP client libraries such\nas urllib3 and requests. In order to work across these libraries with different\ninterfaces some abstraction is needed.\n\nThis module provides two interfaces that are implemented by transport adapters\nto support HTTP libraries. :class:`Request` defines the interface expected by\n:mod:`google.auth` to make requests. :class:`Response` defines the interface\nfor the return value of :class:`Request`.\n\"\"\"\n\nimport abc\nimport http.client as http_client\n\nDEFAULT_RETRYABLE_STATUS_CODES = (\n    http_client.INTERNAL_SERVER_ERROR,\n    http_client.SERVICE_UNAVAILABLE,\n    http_client.REQUEST_TIMEOUT,\n    http_client.TOO_MANY_REQUESTS,\n)\n\"\"\"Sequence[int]:  HTTP status codes indicating a request can be retried.\n\"\"\"\n\n\nDEFAULT_REFRESH_STATUS_CODES = (http_client.UNAUTHORIZED,)\n\"\"\"Sequence[int]:  Which HTTP status code indicate that credentials should be\nrefreshed.\n\"\"\"\n\nDEFAULT_MAX_REFRESH_ATTEMPTS = 2\n\"\"\"int: How many times to refresh the credentials and retry a request.\"\"\"\n\n\nclass Response(metaclass=abc.ABCMeta):\n    \"\"\"HTTP Response data.\"\"\"\n\n    @abc.abstractproperty\n    def status(self):\n        \"\"\"int: The HTTP status code.\"\"\"\n        raise NotImplementedError(\"status must be implemented.\")\n\n    @abc.abstractproperty\n    def headers(self):\n        \"\"\"Mapping[str, str]: The HTTP response headers.\"\"\"\n        raise NotImplementedError(\"headers must be implemented.\")\n\n    @abc.abstractproperty\n    def data(self):\n        \"\"\"bytes: The response body.\"\"\"\n        raise NotImplementedError(\"data must be implemented.\")\n\n\nclass Request(metaclass=abc.ABCMeta):\n    \"\"\"Interface for a callable that makes HTTP requests.\n\n    Specific transport implementations should provide an implementation of\n    this that adapts their specific request / response API.\n\n    .. automethod:: __call__\n    \"\"\"\n\n    @abc.abstractmethod\n    def __call__(\n        self, url, method=\"GET\", body=None, headers=None, timeout=None, **kwargs\n    ):\n        \"\"\"Make an HTTP request.\n\n        Args:\n            url (str): The URI to be requested.\n            method (str): The HTTP method to use for the request. Defaults\n                to 'GET'.\n            body (bytes): The payload / body in HTTP request.\n            headers (Mapping[str, str]): Request headers.\n            timeout (Optional[int]): The number of seconds to wait for a\n                response from the server. If not specified or if None, the\n                transport-specific default timeout will be used.\n            kwargs: Additionally arguments passed on to the transport's\n                request method.\n\n        Returns:\n            Response: The HTTP response.\n\n        Raises:\n            google.auth.exceptions.TransportError: If any exception occurred.\n        \"\"\"\n        # pylint: disable=redundant-returns-doc, missing-raises-doc\n        # (pylint doesn't play well with abstract docstrings.)\n        raise NotImplementedError(\"__call__ must be implemented.\")\n"}